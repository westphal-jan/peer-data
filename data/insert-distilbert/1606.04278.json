{"id": "1606.04278", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2016", "title": "Exact and efficient top-K inference for multi-target prediction by querying separable linear relational models", "abstract": "many complex analysis multi - target prediction problems that concern large target spaces are informally characterised by a need for efficient prediction strategies that avoid the computation of predictions for all targets explicitly. examples of such problems emerge currently in several subfields of machine learning, such as collaborative filtering, multi - label classification, dyadic prediction and biological network cost inference. in this article we analyse efficient and exact algorithms adapted for computing into the top - $ k $ price predictions extracted in the above problem settings, using a general class of models that we traditionally refer to as separable linear or relational models. we show how to use those inference alignment algorithms, which are modifications products of well - known information retrieval methods, in a tremendous variety of machine learning settings. furthermore, we study the possibility of scoring items sampling incompletely, while still retaining an exact top - amount k retrieval. experimental results in several application domains reveal that supporting the so - called automatic threshold algorithm is very scalable, performing often many orders of magnitude more efficiently than the naive ensemble approach.", "histories": [["v1", "Tue, 14 Jun 2016 09:41:27 GMT  (1024kb,D)", "http://arxiv.org/abs/1606.04278v1", null]], "reviews": [], "SUBJECTS": "cs.IR cs.LG", "authors": ["michiel stock", "krzysztof dembczynski", "bernard de baets", "willem waegeman"], "accepted": false, "id": "1606.04278"}, "pdf": {"name": "1606.04278.pdf", "metadata": {"source": "CRF", "title": "Exact and efficient top-K inference for multi-target prediction by querying separable linear relational models", "authors": ["Michiel Stock", "Bernard De Baets", "Willem Waegeman"], "emails": ["firstname.lastname@ugent.be", "krzysztof.dembczynski@cs.put.poznan.pl"], "sections": [{"heading": null, "text": "Keywords top-K retrieval \u00b7 exact inference \u00b7 precision at K \u00b7 multi-target prediction"}, {"heading": "1 Introduction and formal problem description", "text": "Subjected to both great expectations as well as great criticism, \u201cBig Data\u201d and \u201cBig Data Analytics\u201d are two notions that are without doubt highly popular\nMichiel Stock, Bernard De Baets and Willem Waegeman KERMIT, Department of Mathematical Modelling, Statistics and Bioinformatics Ghent University, 9000 Ghent, Belgium E-mail: firstname.lastname@ugent.be\nKrzysztof Dembczyn\u0301ski Institute of Computing Science Poznan University of Technology, Poznan 60-695, Poland E-mail: krzysztof.dembczynski@cs.put.poznan.pl\nar X\niv :1\n60 6.\n04 27\n8v 1\n[ cs\n.I R\n] 1\n4 Ju\nn 20\n16\nthese days. Not only does \u201cBig Data\u201d generate a number of interesting research questions for classical machine learning settings such as classification and regression problems, it also leads to novel challenges in less traditional learning settings. For example, though multi-target prediction is not a recent field (see e.g. [9]), Big Data problems nowadays routinely deal with very large output spaces. Roughly speaking, multi-target prediction can be seen as a term that intends to unify methods that are developed in several subfields of machine learning. Multi-target prediction has as general research theme the principles behind learning problems where predictions for multiple targets need to be generated simultaneously1. In this work we will use a general notation s(x, y) to denote the predicted score of a multi-target prediction model, where x will be referred to as an instance or query, and y as a target, a label or an item. We give a couple of examples that are analyzed in more detail later in this article to make this point more clear:\n\u2013 In collaborative filtering methods for recommender systems, s(x, y) will represent a score that indicates the degree to which query x will be interested in item y. Using methods such as matrix factorization, users and items are here typically represented by a set of latent variables \u2013 see e.g. [45,49]. \u2013 In multi-label classification and multivariate regression (often denoted as multi-output regression), s(x, y) will represent the prediction for instance x and label y, where typically a feature representation is available for the user, whereas no additional information about y is known in the basic setting \u2013 see e.g. [2,14,47]. \u2013 In content-based filtering, dyadic prediction and network inference problems, feature vectors will be available for both instances x and targets y. For example, in content-based filtering, one would recommend items to users based on user profiles and side information about items [4,11]. In proteinligand interaction modelling for drug design, a bio-informatics application of dyadic prediction, one would model a compatibility score s(x, y) based on feature descriptions of proteins and ligands [29,51].\nUsing a generic methodology, we analyze in this article efficient methods for finding the best scoring targets in the above application domains. Existing machine learning methods in those domains are often suffering from severe bottlenecks when predictions need to be generated and stored for a large number of couples (x, y). As a result, instead of computing the scores s(x, y) explicitly for all couples, one could argue that it suffices to retrieve the objects y resulting in the highest scores for a given object x. For example, in computational drug design it suffices to retrieve the best-binding molecules for a given protein \u2013 see e.g. [28]. Similarly, in marketing applications of recommender systems, one is often mainly interested in those products that are most relevant for a given user \u2013 see e.g. [44]. More formally, rephrased as an information retrieval problem, we are often interested in finding the set that contains the K\n1 We refer to the ICML 2013 tutorial and the ECML-PKDD 2014 workshop on multitarget prediction for an overview.\nhighest-scoring objects of this database with respect to a certain instance (or query) x.\nLet us introduce some further notation to make this problem statement a bit more precise. Using a generic notation, we consider two types of objects x \u2208 X and y \u2208 Y. For simplicity, we assume that Y is finite with cardinality M . We will analyse bilinear models that calculate for each couple (x, y) the following score as prediction:\ns(x, y) = u(x)\u1d40t(y) = R\u2211 r=1 ur(x) tr(y) . (1)\nAs the representations need to be separated for x and y, we call the above class of models separable linear relational (SEP-LR) models. Each of the two objects is represented by an R-dimensional model vector:\nu(x) = (u1(x), u2(x), . . . , uR(x)) \u1d40 ,\nt(y) = (t1(y), t2(y), . . . , tR(y)) \u1d40 .\nThe general applicability of SEP-LR models to the application domains that are mentioned above will be further discussed in Section 3. In matrix factorization methods, R will correspond to the rank of the low-rank decomposition. In multi-label classification problems, it will be the number of features.\nAs we are interested in computing only a subset of the predictions for couples (x, y), we define the set SKx , containing the K most relevant objects y for the query x. The problem that we intend to solve can then be formally written as:\nSKx = arg max S\u2208[Y]K min y\u2208S s(x, y) , (2)\nwith [Y]K the set of all K-element subsets of Y. Thus, for two objects y \u2208 SKx and y\u2032 /\u2208 SKx , it holds that s(x, y) \u2265 s(x, y\u2032). The set SKx is not necessarily unique, because ties may occur. Let us remark that problem statement (2) is related to nearest neighbor search, but finding the point with maximum inner product or maximum cosine similarity is not identical to finding the point that is closest w.r.t. Euclidean distance:\narg min y\u2208Y ||u(x)\u2212 t(y)||2 = arg min y\u2208Y ||t(y)||2 \u2212 2u(x)\u1d40t(y) + ||u(x)||2\n= arg min y\u2208Y\n||t(y)||2 \u2212 2u(x)\u1d40t(y) .\nThe term ||u(x)||2 can be dropped as it remains constant as soon as x is fixed, but ||t(y)||2 cannot be omitted. When the norm of t(y) is the same for each y, this expression is equivalent with (1). In many applications, the norm of the items has a clear meaning and cannot be omitted. Also, in contrast to distances, we study more general problem settings in which x and y belong to a different domain and a distance between them is less natural to define.\nExisting methods for speeding up nearest neighbor search, such as [17], are hence not directly applicable to maximum inner product search.\nOne approach to compute the maximum inner product would be to partition the target space using efficient data structures such as k-d trees [7], ball trees [35], cover trees [8] or branch-and-bound search techniques [31]. Methods of that kind are able to find the top-scoring predictions in an efficient way for low-dimensional Euclidean embeddings (in our case, when R is small), but they bring no improvement compared to a naive linear search when the dimensionality is larger than twenty. Space partitioning methods are hence inapplicable to the problem settings that are the focus of this paper.\nWhen time efficiency is more important than predictive power, one could opt for employing specialized approximate algorithms. Locality-sensitive hashing techniques, which are popular for the related problem of nearest neighbor search, would be a good choice. Recently, a locality-sensing hashing method for maximum inner product search has been developed [41,42]. However, in addition to delivering approximate predictions, methods of that kind are usually restricted to finding the top-1 set. Another approximate method would be to cluster the queries x in several groups, for which rankings of targets y can be precomputed by means of predictive indices and related data structures [1, 23].\nIn this article we are interested in computing the set SKx as efficiently as possible in an exact manner. To this end, we depart from a trained model s(x, y) and we make a number of additional assumptions that are all quite natural for the applications we have in mind. First, we assume that the topK predictions should be returned, where K \u2265 1. Second, we also assume that R can be bigger than twenty, so that space partitioning methods become inapplicable. Third, we assume that at prediction time queries x need to be processed one-by-one. If queries are arriving in large batches, further speed-ups could be obtained by using specialized libraries for matrix multiplication.\nWe analyse exact algorithms for inferring the top-K set by adopting existing methods from the database and information retrieval literature. Indeed, a strongly related problem as (2) is often observed in information retrieval [27]. When queries and documents have sparse representations and relevance is defined by means of cosine similarity, one can reduce the computational complexity of retrieval by using data structures such as inverted indices [54]. We will exploit a similar idea. Even though most of the specialized techniques in information retrieval put a strong emphasis on sparsity, which makes them inapplicable to multi-target prediction problems, we will show that certain techniques can be used to compute the top-K set more efficiently compared to linear search. In particular, we are analyzing in this paper Fagin\u2019s algorithm and extensions thereof [20]. Similar to inverted indices, those algorithms will score for a given query the items of several lists until one is guaranteed to have found the top-K scoring items. More details are provided below.\nThe remainder of this work is structured as follows. We present and discuss in Section 2 three exact algorithms for obtaining the K highest scores for a given query. In Section 3 we will give an overview of machine learning prob-\nlems that can be cast in our general framework, followed by Section 4, where we experimentally study the algorithms using datasets for several application domains. Finally, in Section 5, we conclude with some practical guidelines and some directions for future research.\n2 Exact algorithms for top-K inference\nThe most straightforward way to solve problem (2) is by simply calculating the score s(x, y) for each target y and retaining the K targets with the highest scores. We will call this algorithm the naive algorithm, as we have to calculate all M scores to gather the top-K highest scoring targets. Computing the score for one object has a time and space complexity of O(R), as this amounts to computing a weighted sum of R terms. Apart from some set operations that can be done with a time complexity of O(1), we also occasionally have to update the current top-K set when a new target is scored higher than the worst target in the current list. Using efficient data structures such as heaps, this can be done with a time complexity of O(logK). Hence the time complexity for the naive algorithm is O((R + logK)M).\nWe show that the problem can be solved more efficiently using exact methods that are well known in database research and information retrieval, namely Fagin\u2019s algorithm [20] and the so-called threshold algorithm [21]. Both algorithms in essence find in an efficient way the maximum of an aggregation operator Q(z1, ..., zR). More specifically, if z1, ..., zR are the R grades of an object, then Q(z1, ..., zR) represents the overall grade of that object. Fagin\u2019s algorithm and the threshold algorithm both find in an exact but efficient manner the K objects in a database with highest Q(z1, ..., zR). The algorithms assume that all variables z1, ..., zR belong to the interval [0, 1] and Q has to be an increasing aggregation operator, i.e., Q(z1, ..., zR) \u2264 Q(z\u20321, ..., z\u2032R) if zr \u2264 z\u2032r for every r.\nGiven a query x, problem statement (2) can be easily transformed into the original problem setting of Fagin by defining zr = ur(x)tr(y). The resulting values zr do not necessarily belong to the interval [0, 1], but they can be transformed accordingly for a fixed query x and set of targets Y. In what follows we therefore assume that Fagin\u2019s algorithm and the threshold algorithm are applicable, and we further adopt a machine learning notation in explaining the two algorithms.\nKey to both algorithms is a set of R sorted lists L1, ..., LR that contain pointers to all the targets, ordered according to each of the R model descriptors ti(y). The pseudo-code of Fagin\u2019s algorithm is given in Algorithm 1. It first scans the targets that are at the top of the selected lists until K targets are found that occur somewhere close to the top of each list (the random access phase). Those targets are stored in the set targetsToCheck. Subsequently, the score for all observed targets is calculated in a second phase, and the set SKx is constructed as the K targets with highest scores in this set (the sorted access phase).\nAlgorithm 1 Fagin\u2019s Algorithm Input: Y, x, K, L1, . . . , LR Output: SKx\n1: SKx \u2190 \u2205 2: bookkeeping[1..M ] \u2190 0 3: targetsToCheck \u2190 0 4: numberOfTargetsInAllLists \u2190 0 5: while numberOfTargetsInAllLists < K do 6: for r \u2190 1 to R do 7: y \u2190 get next item from Lr 8: targetsToCheck \u2190 targetsToCheck \u222a {y} 9: bookkeeping[y] \u2190 bookkeeping[y]+1\n10: if bookkeeping[r] = R then 11: numberOfTargetsInAllLists \u2190 numberOfTargetsInAllLists +1 12: for y in targetsToCheck do 13: score \u2190 s(x, y) . O(R) 14: if lowest score in SKx < score then 15: update SKx with scored item y . O(logK)\nAlgorithm 2 Threshold Algorithm Input: Y, x, K, L1, . . . , LR Output: SKx\n1: SKx \u2190 \u2205 2: calculated \u2190 \u2205 3: lowerBound \u2190 \u2212\u221e 4: upperBound \u2190 +\u221e 5: while lowerBound < upperBound do 6: upperBound \u2190 0 7: for r \u2190 1 to R do 8: y \u2190 get next item from Lr 9: if y 6\u2208 calculated then\n10: score \u2190 s(x, y) . O(R) 11: calculated \u2190 calculated \u222a {y} 12: if lowerBound < score then 13: update SKx with the new scored item . O(logK) 14: if |SKx | = K then 15: lowerBound \u2190 lowest score of a target in SKx . O(1) 16: upperBound \u2190 upperBound + ur(x) tr(y) . O(1)\nIt should be intuitively clear that the set SKx will be computed in a correct manner. The stopping criterion implies that for at least K targets the score s(x, y) has been computed. The best targets in targetsToCheck will be returned as the set SKx , while the monotonicity of the scoring function guarantees that the scores for these K targets are at least as high as for any target not in the considered top of the sorted lists. If ur(x) is negative, the corresponding list Lr is reverted in the first part of the algorithm. This is equivalent to transferring the sign of ur(x) to the corresponding features of tr(y), i.e. working with |ur(x)| and \u2212tr(y). Without loss of generality, we can thus assume that the score s(x, y) is increasing w.r.t. all tr(y).\nThe pseudo-code of the threshold algorithm is given in Algorithm 2. In contrast to Fagin\u2019s algorithm, this approach uses information of the query x to put emphasis on the dimensions in t(y) that are relevant for u(x). The algorithm is therefore not divided in a random and a sorted access phase. In iteration d, it scores the targets observed at depth d in the lists. It keeps popping elements from lists to obtain promising targets until a stopping criterion is reached, i.e., when the lowest score in the current top-K set, the lower bound, exceeds an upper bound on the values of the scores of targets that have not been investigated yet. This is summarized in the following theorem.\nTheorem 1 Upon termination of the threshold algorithm, it has found the set SKx .\nProof In iteration d, let yLr(d) be the target at position d of list Lr, then the upper bound is given by:\nupperBound(d) = R\u2211 r=1 ur(x) tr(yLr(d)) . (3)\nFor a given query x, if an item y has not occurred in any of the lists at depth d, its score s(x, y) will not exceed upperBound(d). As the score can be calculated as an increasing function of the components of tr(y), it follows that upperBound(d) is greater than or equal to the score of any target not yet encountered. As a result, this is an upper bound on the scores of such targets, so it should be clear that the algorithm computes the set SKx in a correct manner. ut\nThe algorithms are illustrated on a small toy example in Table 1. Here, a database of size N = 10 is queried for the top-1 set using a model with R = 4 components. The naive approach consists of scoring all ten items and withholding the one with the largest score. Fagin\u2019s algorithm scans the sorted lists for five steps, at that point item 5 has been encountered in each list, terminating the random access phase. All nine items seen in the random access phase are scored in the sorted access phase. The threshold algorithm terminates after two steps, when the lower bound has exceeded the upper bound. Five items are scored by this algorithm. All three methods return {6} as the correct top-1 set, but they differ in the number of items that have been scored.\nIn what follows we compare the computational complexity of Fagin\u2019s algorithm and the threshold algorithm from a multi-target prediction perspective. To this end, we consider the cost associated with the number of targets that have to be scored, and we derive a bound accordingly. In both algorithms, the R lists of the features for the M targets have to be sorted. Using conventional sorting algorithms, this can be done with a time complexity of O(RM logM). If the targets remain unchanged, or are updated only slowly, this is an operation that has to be done only once. Consequently, the cost of sorting should not be included in the computational cost for computing SKx .\nIn Algorithm 1, lines 5 to 11 are concerned with finding the relevant targets to score. Suppose the lists have to be followed to a depth D \u2264M , then this part has a time complexity of O(RD). The last part of Fagin\u2019s algorithm is identical to the naive algorithm, resulting in a time complexity of O(MFR), because MF targets are scored (with MF \u2264M). For independent lists (i.e. the position of a given target is independent for the different lists), the number of targets MF to score is of the order M R\u22121 R K 1 R . Following this simplifying assumption and again ignoring the cost of maintaining the current best top-K list, we obtain a time complexity of O(RM R\u22121R K 1R ). The time complexity of Fagin\u2019s algorithm is thus less than the time complexity of the naive algorithm, but the improvement is in practice rather small. More specifically, Fagin\u2019s algorithm will calculate the fewest scores when all components of the representation t(y) have a very strong (positive or negative) correlation. However, if those components are highly correlated, they likely share information and perhaps some effort should be done to reduce the number of components, e.g. by means of feature selection techniques.\nThe complexity analysis of the threshold algorithm is rather simple: it only calculates MT scores with MT \u2264 M , so its computational complexity is\nO(MTR). It has been shown in [21] that the threshold algorithm is instanceoptimal, meaning that the algorithm cannot be outperformed by any other algorithm when wild guesses are not allowed.\nDefinition 1 (Instance optimality) Let A be a class of algorithms, let Y be a class of target sets and let cost(A,Y, x) be the cost when running algorithm A on target set Y for query x. We say that an algorithm B is instance-optimal over A and Y if B \u2208 A and if for every A \u2208 A, every Y \u2208 Y and every x in X it holds that\ncost(B,Y, x) = O(cost(A,Y, x)) .\nThe above equation means that there exist constants c and c\u2032 such that cost(B,Y, x) \u2264 c\u00d7 cost(A,Y, x) + c\u2032 for every choice of x, Y \u2208 Y and A \u2208 A.\nIn other words, if an algorithm B is instance-optimal, then for any query x no algorithm that obtains a lower time complexity exists. However, it can still be the case that another instance-optimal algorithm will need less computations than B, but the difference would then be attributed to a constant time factor. This type of optimality is in fact much stronger than optimality in the average case or worst case: it holds for every query. We can easily show that the threshold algorithm is instance-optimal for the problem that is the main interest of this paper. To this end, we have to make a restriction to algorithms that do not make wild guesses.\nDefinition 2 (Wild guess) An algorithm for solving (2) is said to make a wild guess if it computes for a given target y the score s(x, y) before y has been observed in any of the lists L1, ..., LR.\nTheorem 2 Let Y be the class of all possible target sets Y. Let A be the class of algorithms that solve for any query x problem (2) in an exact manner without making wild guesses. Then the threshold algorithm is instance-optimal over A and Y.\nThis result follows immediately from Theorem 6.1 in [21] by transforming problem statement (2) to the original problem setting of Fagin, as discussed more formally above, and observing that this leads to searching for the maximum of a monotonic aggregation operator. Crucial in the above theorem is that we make a restriction to algorithms that do not make wild guesses. Due to lucky shots, algorithms that make wild guesses would be able to find the top-K set more rapidly, but they would not outperform a deterministic algorithm for general queries x. As we focus in this article on deterministic algorithms, we omit further details of the comparison with stochastic methods, but the analysis becomes much more delicate if one would like to extend the above theorem beyond the class of deterministic algorithms. We refer to [21] for more details. In the next statement, we formally show that Fagin\u2019s algorithm cannot be instance-optimal.\nTheorem 3 Let Y be the class of all possible target sets Y. Let A be the class of algorithms that solve for any query x problem (2) in an exact manner without making wild guesses. Then Fagin\u2019s algorithm is not instance-optimal over A and Y.\nProof To show that Fagin\u2019s algorithm is not instance-optimal, it suffices to prove that it has a larger time complexity than the threshold algorithm for one particular query x. Adopting the same notation as in Table 1, let us assume that u(x) = (1, 1) with R = 2 and let us define the lists L1 and L2 as in Table 2. We consider in this example a dataset that contains M targets and we assume that the values of t1(y) increase with the indices {1, . . .M} of the items, while the values of t1(y) increase with the indices. With the construction of t1(y) and t2(y) as in the table, Fagin\u2019s algorithm needs M/2 steps to terminate, whereas the threshold algorithm only needs two steps, independent of M . So, the former has for this artificial dataset a time complexity of O(M), whereas the latter has a complexity of O(1). As a result, Fagin\u2019s algorithm cannot be instance-optimal. ut\nThe above theorem confirms that datasets can be found where Fagin\u2019s algorithm will suffer from a higher time complexity than the threshold algorithm. Conversely, due to the instance-optimality of the threshold algorithm, one cannot find datasets where this threshold algorithm will exhibit a higher\ntime complexity than Fagin\u2019s algorithm. The next theorem supports a related, but different claim.\nTheorem 4 For any query x and for any possible target set Y, the threshold algorithm never computes more scores s(x, y) than Fagin\u2019s algorithm.\nProof For simplicity we give a proof by contradiction for the case K = 1 (top-1). An extension for the case K > 1 is then immediate. Let us assume that Fagin\u2019s algorithm terminates at depth d in the lists Li. Suppose also that the threshold algorithm needs to compute more scores than Fagin\u2019s algorithm, implying that it terminates at a depth larger than d. At depth d an upper bound on the score of targets that have not been observed yet is given by Eq. (3). At depth d, a lower bound on the highest score is given by the target that has been observed in all lists Li when Fagin\u2019s algorithm reaches this depth. We know that at depth d this lower bound exceeds the upper bound in Eq. (3). As a result, the threshold algorithm should also stop at this depth, so this is a contradiction. ut\nThe threshold algorithm will never compute scores for more targets than Fagin\u2019s algorithm, but this does not imply that it will always need less computations. This is due to the fact that it is characterized by some additional overhead for computing the lower and upper bound in each iteration, and for verifying whether the first bound exceeds the latter. This additional overhead does not influence the time complexity of the threshold algorithm, but it explains why constants need to be considered in the definition of instanceoptimality.\nIn contrast to Fagin\u2019s algorithm, the threshold algorithm does not require a large buffer size, as only the upper and lower bounds are needed to scan the lists. Consequently, the buffer size of the threshold algorithm is as a result bounded, while this is not the case for Fagin\u2019s algorithm. The latter will hence suffer from a too large memory consumption, making it a practically less useful method, especially for high-dimensional problems. Sorting the lists can be done offline and parallel extensions can be easily implemented [22]. If speed predominates over accuracy, the threshold algorithm can be halted before the stopping criterion is reached, so that the top-K set is potentially not correct, but the running time is shorter. For example, if the threshold algorithm would be terminated in the first step of the example above, we would have obtained the correct top by scoring only three targets. This modification is known as the halted threshold algorithm [21]. Later on in the experiments we show that this heuristic could yield quite satisfactory results.\nThe threshold algorithm can also elegantly deal with sparse data. If u(x) and t(y) are large, sparse, non-negative feature vectors (e.g. in memory-based collaborative filtering or when dealing with bag-of-word features), only the non-zero elements and corresponding pointers have to be stored. By using sparse vector-vector multiplication implementations, the calculation of a single score can be reduced. The sorted lists Lr only need to contain the pointers for items where tr(y) is positive. Furthermore, one only has to consider lists\nAlgorithm 3 Calculating the scores for the Partial Threshold Algorithm Input: u(x), t(y), upperBound, lowerBound, L1, . . . , LR, d Output: score or fail\n1: score \u2190 upperBound 2: for r \u2190 1 to R do 3: score \u2190 score - ur(x) tr(yLr(d)) 4: score \u2190 score + ur(x) tr(y) 5: if score \u2264 lowerBound then 6: break and return a fail . item y will not improve SKx\ncorresponding to non-zero elements of u(x) (Algorithm 2, line 7). Thus, in addition to improving the computing time for calculating a single score (which can also be done using the naive algorithm), much fewer items have to be scored. We will demonstrate this in the experimental section.\nDespite the strong theoretical result above, we show that it is still possible to slightly improve the threshold algorithm in some cases. The reason is that Theorem 2 does not take the dimensionality R of feature vectors into account. We propose a small modification so that not all scores have to be calculated completely. Let us assume that the following double inequality holds for the score of a newly-observed target y at depth d of the threshold algorithm:\ns(x, y) \u2264 l\u2211\nr=1\nur(x) tr(y) + R\u2211 r=l+1 ur(x) tr(yLr(d)) \u2264 lowerBound(d) , (4)\nwith 1 \u2264 l < R. For such a target it is not needed to calculate the score entirely. Algorithm 3 modifies the scoring functionality of the original threshold algorithm by applying this idea. We will refer to this modification as the partial threshold algorithm. It stops the calculation when it becomes clear that the score cannot improve the lower bound. We start from the upper bound and gradually update the score to either obtain the full score or to halt when the partially calculated score is lower than the lower bound. The partial threshold algorithm will return the same top-K set and is still an exact algorithm. The number of items that are considered is the same as with the threshold algorithm, only the calculation of some scores that do not improve the top will be halted early, resulting in a decrease in computations."}, {"heading": "3 Application domains and relationships with SEP-LR models", "text": "In this section we illustrate that many multi-target prediction methods are specific instantiations of SEP-LR models and the inference methods discussed in the previous sections. The methods that we consider in Section 3.1 are frequently encountered in the area of recommender systems. The methods that we discuss in Sections 3.2 and 3.3 are used in other domains as well.\nFor the application domains discussed below, many of the currently used techniques boil down to SEP-LR models. When that is the case, the algorithms\nof Section 2 can be applied to decrease the running time at no cost in predictive performance, as we can guarantee that the correct top-K predictions will be returned. When a non-SEP-LR model is used, it may be considered to switch to a SEP-LR model to perform queries potentially faster. This may lead to a decreased performance as one is restricted to linear models. Depending on the application this trade-off may be worth considering or not.\n3.1 Memory-based and model-based collaborative filtering\nIn this section we discuss how our methodology can be applied to so-called user-based and item-based collaborative filtering. Since these methods directly process the available dataset, they are often denoted as memory-based collaborative filtering. To keep the discussion accessible, let us focus on the latter of the two settings, where recommendations are made by retrieving items that are similar to the items a user has seen before \u2013 see e.g. [39]. A popular similarity measure in this area is the cosine similarity:\ncos(x, y) = \u3008x,y\u3009 \u2016x\u20162\u2016y\u20162 , (5)\nin which x should be interpreted as an item that has been seen before, whereas y rather refers to an item that could be recommended. The vectors x and y here typically consist of ratings or zero-one purchase flags for different users. Using this notation, item-based collaborative filtering can be interpreted as a specific case of model (1) by defining\nu(x) = x\n\u2016x\u20162 and t(y) =\ny\n\u2016y\u20162 . (6)\nA similar reasoning can be followed for user-based collaborative filtering methods and other similarity measures such as the Pearson correlation and the adjusted cosine similarity. Both measures can also be written as dot products, but sparsity will be lost due to centring.\nIn contrast to the memory-based approach, collaborative filtering can also be performed by building a model to explain the preference of a user for a particular target. This is referred to as model-based collaborative filtering and includes models such as Bayesian networks, clustering and matrix factorization methods [32]. Here, each target and each user are associated with a vector of R latent variables of which the dot product represents the joint preference. A matrix C containing the ratings for each combination of objects x and y is approximated as a product of two low-rank matrices: C \u2248 UT. This means that the predicted scores in model (1) can be written in matrixform as S = UT, such that the score s(x, y) of the i-th user and j-th item is computed as a dot-product of the i-th row in U and the j-th column in T. As a result, the connection with SEP-LR models holds for basically all matrix decomposition algorithms, inclucing non-negative matrix factorization, independent component analysis, sparse principal component analysis and singular value decomposition methods [25].\n3.2 Multi-label classification, multivariate regression and multi-task learning\nIn this section we discuss applications of SEP-LR models in three large subfields of machine learning that have a lot of commonalities, namely multi-label classification, multivariate regression and multi-task learning. The former two subfields consider the simultaneous prediction of multiple binary or real-valued targets, respectively [14,47]. Multi-task learning then further unifies those subfields, and further extends them to problems where not all targets are observed (or relevant) for all instances [5,10]. However, all multi-label classification and multivariate regression problems can also be solved with multi-task learning methods. Of course, finding the top-K set is only relevant when an ordering of the targets is appropriate. For example, consider a protein-ligand interaction prediction problem where the goal is to find for a given ligand a set of proteins from a large database that are likely to show affinity towards it. If the model that is used predicts binding energy, the problem is a multivariate regression problem. When the model returns a value that is related to the probability that a given ligand will interact with a particular protein or not, we are in a multi-label classification setting.\nUsing the notation introduced before, this means that x represents an instance and y a target (a.k.a. label or output). As we will be computing the K most relevant targets for a given instance x, we end up with a so-called label ranking setting. Furthermore, suppose we have M targets and a set of Ntr training instances for which a feature representation \u03c8(x) is available.\nMany multi-label classification, multivariate regression and multi-task learning methods can be formulated as SEP-LR models. Due to lack of space, we only discuss a few representative cases. The first approach is a very simple approach: it defines independent models for different targets. This method is known as the binary relevance method in the multi-label classification community [47]. Using linear models or linear basis function models, this implies that the model for target y can be represented as\ns(x, y) = w\u1d40y\u03c8(x) .\nHence, this model is a specific case of the SEP-LR framework, with u(x) = \u03c8(x) and t(y) = wy.\nMultivariate (kernel) ridge regression is probably the most basic model of this kind. Ridge regression constructs a model for every target separately, ignoring potential dependencies between targets. Such dependencies can be modelled using more sophisticated methods. In multivariate regression, dependencies between targets are often modelled using (kernel) PCA, which transforms the problem into a set of uncorrelated tasks (see e.g. [52]). An alternative but related approach consists of using a specialised loss function or regularisation term that enforces models of different targets to behave more similar, e.g. [18,19,30]. An interesting example from this point of view is the partial least squares (PLS) algorithm, which projects the features onto a lowerdimensional subspace [40]. The inference algorithms discussed in this work are applicable to all these methods.\n3.3 Pairwise learning, content-based filtering and supervised network inference\nFinally, there are applications where feature representations are available for both x and y, resulting in separable linear relational models of the following type:\ns(x, y) = Vec(W)\u1d40(\u03c6(y)\u2297\u03c8(x)) = \u03c8(x)\u1d40W\u03c6(y) .\nHere, Vec is the vectorisation operator, which stacks the columns of a matrix into a vector and \u2297 is the Kronecker product. The second part of the equation is used to stress that this can be seen as a standard linear model to make predictions for a pair of objects. This model can be cast in the form of Eq. (1) by writing the terms explicitly:\ns(x, y) = \u2211 i,j wij\u03c8(x)i\u03c6(y)j ,\nwith wij denoting the element from W on the i-th row and j-th column. Models of this type are frequently encountered in several subfields of machine learning, such as pairwise learning, content-based filtering, biological network inference, dyadic prediction and conditional ranking. They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].\nSome authors, such as [15], claim that pairwise methods in kernel form are not viable for large-scale problems as they scale O(N2M2) in memory and O(N3M3) in time complexity for most algorithms. For some models though, when the kernels can be factorised using the Kronecker product, the memory and time complexity reduce to O(N2 + M2) and O(N3 + M3), respectively, see [36,50]. In a similar vein, this factorization allows for fast querying using the threshold algorithm and Fagin\u2019s algorithm.\nRecently, a method called two-step regularised least squares was proposed, as an intuitive way to bring this paradigm to practice [37]. Prior knowledge on similarities of the different tasks is incorporated in a standard multi-output ridge regression by performing a second ridge regression, using a kernel matrix describing the similarity between these tasks. It can be shown that two-step regularised least squares is equivalent to using ridge regression with a kernel based on the Kronecker product."}, {"heading": "4 Experimental results", "text": "The goal of this experimental section is twofold. Firstly, we want to show that the proposed methods can be applied to the different machine learning settings described above. In addition to that, we also want to illustrate the scalability and practical use of the algorithms. By means of several case studies using\ndifferent datasets we will elucidate the algorithms of Section 2. Fagin\u2019s algorithm is included in this manuscript for didactic interest, but we observed in initial experiments that it could not cope adequately with most of the higherdimensional problems. The buffer needed to store targets that are encountered in the lists grows rather quickly when the dimensionality of the data increases. Hence, we have omitted experiments with this algorithm. Instead, for the experimental validation we focus on the practical use of the threshold and partial threshold algorithm and compare their performance with the naive algorithm.\n4.1 Data dependencies in collaborative filtering\nIn this series of experiments we study the scalability of the threshold algorithm for a collection of collaborative filtering datasets. We use five sparse datasets for memory-based and model-based collaborative filtering using the cosine similarity and matrix factorization respectively. The datasets are listed in Table 3. We use the Movielens dataset with both 100K and 1M, the BookCrossing dataset, both from Grouplens2, the Audioscrobbler dataset3, and a recipe composition dataset4. We have removed empty rows and columns and taken the logarithm of the positive values of the Audioscrobbler dataset. In the Audioscrobber and Recipes datasets the scores are obtained by implicit feedback (i.e. a zero indicates no observation for a given item-user pair), for the others by explicit feedback (i.e. a zero indicates no match for a given item-user pair).\nFor memory-based collaborative filtering, we used the cosine similarity to define a set of items with a high similarity to the query. As described above, if each item is normalized, such that the L2-norm is equal to one, a dot product is equivalent to the cosine similarity. For model-based collaborative filtering, we applied matrix factorization by means of probabilistic PCA [46], having as advantage that a computationally efficient expectation maximisation algorithm can be used. We used 5, 10, 50, 100 and 250 latent features in the decomposition of all datasets.\n2 http://grouplens.org/ 3 http://www-etud.iro.umontreal.ca/\u02dcbergstrj/audioscrobbler data.html 4 This dataset [3] is strictly speaking not a collaborative filtering benchmark dataset, but it can be treated using a similar workflow. Here the goal would be to find related recipes for a particular ingredient combination. See [12] for an recommender system built using this dataset.\nWe performed a large series of queries to compare the performance of the different algorithms discussed in Section 2. For memory-based collaborative filtering, we used the naive and threshold algorithms. For matrix factorization, the partial threshold algorithm was also used for querying. For each experiment we randomly chose a dataset, the size of the top among the values 1, 5, 10, 50 and 100 and ten queries from the rows of the data matrix. To assess the effect of the size of the database, we randomly witheld 10%, 50% or all the items in the database. Each of the algorithms was applied to find the same top-K relevant targets for all these settings.\nThe number of scores calculated by the threshold algorithm relative to the number of scores calculated by the naive algorithm for the different settings is given in Figure 1. As guaranteed by the design of the threshold algorithm, in the worst-case scenario the same number of items has to be scored as by the naive algorithm. Clearly, the average gain increases for both settings with database size, as expected. Furthermore, the larger the top-K that is sought, the smaller the gain. The difference between top-1 and top-50 seems to be roughly an order of magnitude for most cases. Comparing the memory-based with the model-based setting, the former shows larger improvements in computational costs, even for small datasets and large top sizes. This is because the threshold algorithm can deal well with sparseness, as discussed in Section 2. For the matrix factorization experiments, we see that the relative efficiency decreases when the number of latent features R increases. Large improvements in running time are mainly to be expected when the dimensionally of the data is modest.\n4.2 Running time and partial threshold algorithm using Uniprot data\nIn this experiment we study the improvement in querying time and whether the computation time can be reduced by means of the partial threshold algorithm. To this end we use a large multi-label classification dataset related to protein function. We downloaded the complete Uniprot database5, containing more than half a million of annotated protein sequences. We consider the problem of functionally annotating a protein based on its amino acid sequence. The function of the protein is represented by the gene ontology (GO) label. The GO annotation represents the molecular function, location and biological role of a protein. We ended up with a dataset containing 211,149 proteins with 21,274 distinct labels.\nAs a feature representation, we used weighted subsequence kernels [40], which define similarity between sequences based on subsequences of a fixed length. It is infeasible to compute a complete kernel matrix for hundreds of thousands of instances. We performed an approximation inspired by the Nystro\u0308m method [16], a method to approximate the decomposition of large kernel matrices. We arbitrarily selected 500 reference substrings with a length\n5 http://www.uniprot.org\nof 100 amino acids from the database, for which we calculated the different subsequence kernels with subsequence lengths from one to twenty with respect to the full protein sequences in the dataset. Thus, if we treat the subsequence length as a hyperparameter, each protein is described by 500 features. In order to find the best model, the models were trained using 80% of the data, while 20% was withheld as a validation set. All models were evaluated by calculating the AUC over the different functional labels, for each protein separately, and averaging over different proteins. Apart from the subsequence length, each model has its own hyperparameter that had to be optimized:\n\u2013 Ridge: the best combination of substring length and regularisation parameter from the grid {0.01, 0.1, 1, 10, 100} was chosen, \u2013 PLS: the dimension of the latent subspace was treated as a hyperparameter, and selected from the grid {10, 50, 100, 250}.\nWe measured the classification performance using the area under the ROC curve (AUC) over the labels, averaged over all proteins in the test set (i.e.\ninstance-wise AUC). For ridge regression, we obtained an AUC of 0.982, while for the PLS model an AUC of 0.980 was attained. We used the naive, threshold and partial threshold algorithm to query for the top 1, 5, 10, 25 or 50 most likely labels on the complete label space or random 10% or 50% subsets. Each datapoint represents the average efficiency of a batch of ten protein queries. The results are represented in Figure 2.\nIn the first graph of Figure 2, we plotted the relative improvement in number of scores of the threshold algorithm plotted against the improvement in running time for a series of queries on the Uniprot dataset. It is clear that an improvement in the number of scores translates into a proportional improvement in running time (R2 = 0.964). Similarly as for the collaborative filtering results, larger improvements occur for large databases and small top sizes. It is interesting to note that much larger improvements are recorded for the ridge regression model than for PLS. Most likely, this is because PLS orthogonalizes the variables before mapping to the output space, influencing the distribution of the features.\nThe second graph of Figure 2 compares the computational performance of the partial threshold algorithm described in Section 2 with the standard threshold algorithm. Recall that the number of items the partial threshold algorithm tries to score is always the same as for the threshold algorithm. In most cases, the partial threshold algorithm will only calculate a fraction of a score. To compare with the threshold algorithm, we measure the average fraction of partial scores u(x)rt(y)r that are added. Hence, each item that is fully scored by the partial threshold algorithm is given a value of one, while partially scored items receive the value of the proportion calculated in Algorithm 3. Here, we show that the partial threshold algorithm always has to calculate less full scores compared to the threshold algorithm. Since this algorithm has some extra overhead compared to the original threshold algorithm (the score is updated in two steps), this algorithm is only expected to improve in time when on average only a relatively small fraction of a score has to be calculated. Only for ridge regression with top size equal to one, we see an improvement noticeably larger than 200%. For these queries we observe a small improvement in running time compared to the threshold algorithm, while for the other experiments a small increase in running time is detected. Likewise, for the model-based collaborative filtering datasets of Section 4.1, a similar pattern was observed. The partial threshold algorithm has to calculate only roughly half a score on average and in practice shows something between a minor increase or decrease in running time.\n4.3 Behaviour of individual queries\nTo study the behaviour of the threshold algorithm in more detail, we analyzed the lower bound for 100 queries for the top-5 for the Audioscrobbler dataset (model-based collaborative filtering with 50 latent features) and the Uniprot dataset (using partial least squares). The results are represented in Figure 3.\nThese plots demonstrate that even though it may take many iterations for the algorithm to terminate, the correct top is often found swiftly. The top graphs monitor the lower bound (i.e. the worst score in the current top-K set). In most cases this lower bound does not increase dramatically after a few hundred iterations. Hence, if the desired top does only need to contain good candidates instead of the correct top-K set, one can decrease computation time by early halting. Furthermore, the lower plots demonstrate that, at least for these cases, the threshold algorithm often finds the correct top much sooner than it terminates. This can be seen in the lower plots of Figure 3 where there is a strong lag between the time the correct top is found and the time the algorithm returns this top. We can conclude that it could make sense in some cases to use the halted threshold algorithm (see [21]) which stops when the computational resources have run out (e.g. when a specified maximum querying time has been exceeded).\n4.4 Large-scale text classification\nIn this final experiment we demonstrate the scalability of the threshold algorithm on a huge text mining task with the goal of putting Wikipedia articles in 325,056 possible categories. This dataset was downloaded from the Kaggle \u2018Large Scale Hierarchical Text Classification\u2019 challenge6 [38]. The training data contained 2,365,436 articles which were labeled with the different categories they belong to. Each article had a feature description in the form of a sparse bag-of-words vector, with a length of 1,617,899. The word counts were transformed into term frequency-inverse document frequencies [33]. We performed partial least squares regression to map the feature vectors to the output space. This approach is similar to that performed by [34] on this dataset. The models had 10, 50, 100, 500 and 1000 latent features. The threshold algorithm was used for the different models to fetch the highest-scoring class (i.e. K=1). The models were evaluated using average AUC over the labels and precision-at-1 (the percentage of queries that returned the correct class at the top) on a random test set of 10,000 articles. As a baseline, we also included a popular recommender which always returns a score proportional to the probability of\n6 https://www.kaggle.com/c/lshtc\nthe label occurrence, independent of the word-features. The results are represented in Table 4.\nAll our models have a better prediction accuracy than the baseline and the performance increases with the number of latent features used. As was the case for the previous experiments, the average number of scores needed to find the top increases with R, but seems to scale well (when R is 1000, on average only 2.8% of the classes have to be considered)."}, {"heading": "5 Conclusions and future perspectives", "text": "In this paper we have discussed three generally-applicable methods for finding efficiently the most relevant targets in a wide range of multi-target prediction problems. The experimental results clearly confirm that the threshold algorithm is quite scalable, and often many orders of magnitude more efficient than the naive approach. We can thus conclude that this algorithm is very suitable for querying in large-data settings using many popular machine learning techniques. We have shown experimentally that large improvements can be expected when the size M of the database is large and when only a small top-K set is requested. Furthermore, the number of scores that have to be calculated increases with the dimension R. When querying time is vital, it is thus recommended to consider the use of (supervised) dimension reduction techniques on the features. Empirically, we have also shown that the threshold algorithm can cope well with large sparse feature vectors.\nWe proposed a small modification to the threshold algorithm. By making use of the lower and upper bound, the calculation of the scores can be terminated early while still retaining an exact method. In the experiments, we provided a proof-of-concept, showing a modest reduction in the number of calculations. In practice, due to the extra computational overhead that is created, this is not always translated into an reduced running time. We are optimistic that this modification can be of use in future applications for two reasons. Firstly, certain hardware implementations might be suited for this algorithm as it is now hard to beat optimized implementations for ordinary matrix multiplication. Secondly, we believe that our partial threshold algorithm may lead to very efficient inexact querying algorithms. In Section 4.3 we demonstrated that the threshold algorithm is often overly conservative to determine when\nthe correct top is found. In future work, we will study the trade-off between uncertainty in the top-K set and computational cost.\nThe framework that we presented works well for SEP-LR models corresponding to Eq. (1), which applies to a wide range of statistical models. However, in certain applications, one also encounters pairwise features that jointly describe information of a query and a target. For example in bioinformatics, if one wants to find miRNAs (small nucleic acid sequences with a regulating function) that can interact with messenger RNA, one sometimes considers the number of nucleotide matches between these sequences (e.g. [13]). Similarly, when recommending products to users, one could consider as a feature the number of views a user had on a page where the product is mentioned. Features of that kind cannot be incorporated into SEP-LR models. One would need linear models of the following form:\ns(x, y) = R\u2211 r=1 qr(x, y) ,\nwith q(x, y) = (q1(x, y), q2(x, y), ..., qR(x, y)) \u1d40 a pairwise representation of the query and target. This can be thought of as a generalisation of Eq. (1). Note that the feature description is never known in advance, because it depends upon the query x. Finding efficient algorithms for dealing with these types of models is also an interesting topic for future research."}, {"heading": "Acknowledgments", "text": "Part of this work was carried out using the Stevin Supercomputer Infrastructure at Ghent University, funded by Ghent University, the Hercules Foundation and the Flemish Government - department EWI."}], "references": [{"title": "Fast top-k retrieval for model based recommendation", "author": ["D. Agarwal", "M. Gurevich"], "venue": "Proceedings of the Fifth ACM International Conference on Web Search and Data Mining, pp. 483\u2013492", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Multi-label learning with millions of labels: Recommending advertiser bid phrases for web pages", "author": ["R. Agrawal", "A. Gupta", "Y. Prabhu", "M. Varma"], "venue": "Proceedings of the 22nd International Conference on World Wide Web, pp. 13\u201324", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "Flavor network and the principles of food pairing", "author": ["Y.Y. Ahn", "S.E. Ahnert", "J.P. Bagrow", "A.L. Barab\u00e1si"], "venue": "Scientific Reports 1(196)", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Unifying collaborative and content-based filtering", "author": ["J. Basilico", "T. Hofmann"], "venue": "Proceedings of the 21st International Conference on Machine Learning, pp. 9\u201316", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2004}, {"title": "Exploiting task relatedness for multiple task learning", "author": ["S. Ben-David", "R. Schuller"], "venue": "Proceedings of the 16th Annual Conference on Computational Learning Theory and 7th Kernel Workshop, pp. 567\u2013580", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2003}, {"title": "Kernel methods for predicting protein-protein interactions", "author": ["A. Ben-Hur", "W.S. Noble"], "venue": "Bioinformatics 21(Suppl 1), i38\u201346", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2005}, {"title": "Multidimensional binary search trees used for associative searching", "author": ["J.L. Bentley"], "venue": "Communications of the ACM 18, 509\u2013517", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1975}, {"title": "Cover trees for nearest neighbor", "author": ["A. Beygelzimer", "S. Kakade", "J. Langford"], "venue": "Proceedings of the 23rd International Conference on Machine Learning, pp. 97\u2013104", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2006}, {"title": "Top-down induction of clustering trees", "author": ["H. Blockeel", "L. De Raedt", "J. Ramon"], "venue": "Proceedings of the Fifteenth International Conference on Machine Learning, pp. 55\u201363", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1998}, {"title": "Multitask learning", "author": ["R. Caruana"], "venue": "Machine learning 75, 41\u201375", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1997}, {"title": "Personalized recommendation on dynamic content using predictive bilinear models", "author": ["W. Chu", "S.T. Park"], "venue": "Proceedings of the 18th International Conference on World Wide Web, pp. 691\u2013700", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "Data-driven recipe completion using machine learning methods", "author": ["M. De Clercq", "M. Stock", "B. De Baets", "W. Waegeman"], "venue": "Trends in Food Science & Technology 49, 1\u201313", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "miRNA target prediction through modeling quantitative and qualitative miRNA binding site information in a stacked model structure", "author": ["A. De Paepe", "G. Van Peer", "M. Stock", "P.J. Volders", "J. Vandesompele", "B. De Baets", "W. Waegeman"], "venue": "Nucleic Acid Research Submitted", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2015}, {"title": "On label dependence and loss minimization in multi-label classification", "author": ["K. Dembczynski", "W. Waegeman", "W. Cheng", "E. H\u00fcllermeier"], "venue": "Machine Learning 88(1-2), 5\u201345", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "Similarity-based machine learning methods for predicting drug-target interactions: a brief review", "author": ["H. Ding", "I. Takigawa", "H. Mamitsuka", "S. Zhu"], "venue": "Briefings in Bioinformatics 14(5), 734\u201347", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2013}, {"title": "On the Nystr\u00f6m method for approximating a Gram matrix for improved kernel-based learning", "author": ["P. Drineas", "M. Mahoney"], "venue": "Journal of Machine Learning Research 6, 2153\u20132175", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2005}, {"title": "Using the triangle inequality to accelerate k-means", "author": ["C. Elkan"], "venue": "Proceedings of the 20th International Conference on Machine Learning, pp. 147\u2013153", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2003}, {"title": "Learning multiple tasks with kernel methods", "author": ["T. Evgeniou"], "venue": "Journal of Machine Learning Research 6, 615\u2013637", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2005}, {"title": "Regularized multi-task learning", "author": ["T. Evgeniou", "M. Pontil"], "venue": "Proceedings of the Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pp. 109\u2013117", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2004}, {"title": "Combining fuzzy information from multiple systems", "author": ["R. Fagin"], "venue": "Journal of Computer and System Sciences 58(1), 83\u201399", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1999}, {"title": "Optimal aggregation algorithms for middleware", "author": ["R. Fagin", "A. Lotem", "M. Naor"], "venue": "Journal of Computer and System Sciences 66(4), 614\u2013656", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2003}, {"title": "Querying big data: bridging theory and practice", "author": ["W. Fan", "J.P. Huai"], "venue": "Journal of Computer Science and Technology 29(5), 849\u2013869", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Predictive indexing for fast search", "author": ["S. Goel", "J. Langford", "A. Strehl"], "venue": "Advances in Neural Information Processing Systems, pp. 505\u2013512", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2009}, {"title": "Predicting drug-target interactions from chemical and genomic kernels using Bayesian matrix factorization", "author": ["M. G\u00f6nen"], "venue": "Bioinformatics 28(18), 2304\u201310", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2012}, {"title": "The Elements of Statistical Learning", "author": ["T. Hastie", "R. Tibshirani", "J. Friedman"], "venue": "Springer Series in Statistics. Springer New York Inc., New York, NY, USA", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2001}, {"title": "Large-scale prediction of protein-protein interactions from structures", "author": ["M. Hue", "M. Riffle", "J.P. Vert", "W.S. Noble"], "venue": "BMC Bioinformatics 11(144), 1\u201310", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2010}, {"title": "A survey of top-k query processing techniques in relational database systems", "author": ["I.F. Ilyas", "G. Beskales", "M.A. Soliman"], "venue": "ACM Computing Surveys 40(4)", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2008}, {"title": "Virtual screening of GPCRs: an in silico chemogenomics approach", "author": ["L. Jacob", "B. Hoffmann", "V. Stoven", "J.P. Vert"], "venue": "BMC Bioinformatics 9(1), 1\u201316", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2008}, {"title": "Protein-ligand interaction prediction: an improved chemogenomics approach", "author": ["L. Jacob", "J.P. Vert"], "venue": "Bioinformatics 24(19), 2149\u20132156", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2008}, {"title": "A dirty model for multi-task learning", "author": ["A. Jalali", "S. Sanghavi", "P. Ravikumar", "C. Ruan"], "venue": "Neural Information Processing Symposium, pp. 964\u2013972", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2010}, {"title": "Efficient retrieval of recommendations in a matrix factorization framework", "author": ["N. Koenigstein", "P. Ram", "Y. Shavitt"], "venue": "Proceedings of the 21st ACM International Conference on Information and Knowledge Management, pp. 535\u2013544", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2012}, {"title": "A comparative study of collaborative filtering algorithms", "author": ["J. Lee", "M. Sun", "G. Lebanon"], "venue": "ACM Transactions on the Web 5(1), 1\u201327", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2011}, {"title": "Introduction to Information Retrieval", "author": ["C.D. Manning", "P. Raghavan", "H. Sch\u00fctze"], "venue": "Cambridge University Press, New York, NY, USA", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2008}, {"title": "Fast label embeddings for extremely large output spaces", "author": ["P. Mineiro", "N. Karampatziakis"], "venue": "CoRR abs/1412.6", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2014}, {"title": "Five balltree construction algorithms", "author": ["S.M. Omohundro"], "venue": "Science 51, 1\u201322", "citeRegEx": "35", "shortCiteRegEx": null, "year": 1989}, {"title": "Efficient regularized least-squares algorithms for conditional ranking on relational data", "author": ["T. Pahikkala", "A. Airola", "M. Stock", "B. De Baets", "W. Waegeman"], "venue": "Machine Learning 93(2-3), 321\u2013356", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2013}, {"title": "A two-step learning approach for solving full and almost full cold start problems in dyadic prediction", "author": ["T. Pahikkala", "M. Stock", "A. Airola", "T. Aittokallio", "B. De Baets", "W. Waegeman"], "venue": "Lecture Notes in Computer Science 8725, 517\u2013532", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2014}, {"title": "LSHTC: a benchmark for large-scale text classification", "author": ["I. Partalas", "A. Kosmopoulos", "N. Baskiotis", "T. Artieres", "G. Paliouras", "E. Gaussier", "I. Androutsopoulos", "M.R. Amini", "P. Galinari"], "venue": "submitted to CoRR pp. 1\u20139", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2015}, {"title": "Item-based collaborative filtering recommendation algorithms", "author": ["B. Sarwar", "G. Karypis", "J. Konstan", "J. Reidl"], "venue": "Proceedings of the Tenth International Conference on World Wide Web - WWW \u201901, pp. 285\u2013295. ACM Press, New York, New York, USA", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2001}, {"title": "Kernel Methods for Pattern Analysis", "author": ["J. Shawe-Taylor", "N. Cristianini"], "venue": "Cambridge University Press", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2004}, {"title": "Asymmetric lsh (ALSH) for sublinear time maximum inner product search (MIPS)", "author": ["A. Shrivastava", "P. Li"], "venue": "Advances in Neural Information Processing Systems 27, pp. 2321\u20132329", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2014}, {"title": "Improved asymmetric locality sensitive hashing (ALSH) for maximum inner product search (MIPS)", "author": ["A. Shrivastava", "P. Li"], "venue": "Proceedings of the Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2015}, {"title": "Identification of functionally related enzymes by learning-torank methods", "author": ["M. Stock", "T. Fober", "E. H\u00fcllermeier", "S. Glinca", "G. Klebe", "T. Pahikkala", "A. Airola", "B. De Baets", "W. Waegeman"], "venue": "IEEE Transactions on Computational Biology and Bioinformatics 11(6), 1157\u20131169", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2014}, {"title": "A survey of collaborative filtering techniques", "author": ["X. Su", "T.M. Khoshgoftaar"], "venue": "Advances in Artificial Intelligence 2009, 1\u201319", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2009}, {"title": "Matrix factorization and neighbor based algorithms for the netflix prize problem", "author": ["G. Tak\u00e1cs", "I. Pil\u00e1szy", "B. N\u00e9meth", "D. Tikk"], "venue": "Proceedings of the 2008 ACM conference on Recommender systems, pp. 267\u2013274. ACM Press, New York, New York, USA", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2008}, {"title": "Probabilistic principal component analysis", "author": ["M. Tipping", "C. Bishop"], "venue": "Journal of the Royal Statistical Society 3, 611\u2013622", "citeRegEx": "46", "shortCiteRegEx": null, "year": 1997}, {"title": "Multi-label classification: an overview", "author": ["G. Tsoumakas", "I. Katakis"], "venue": "International Journal of Data Warehousing & Mining 3(3), 1\u201313", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2007}, {"title": "A new pairwise kernel for biological network inference with support vector machines", "author": ["J.P. Vert", "J. Qiu", "W.S. Noble"], "venue": "BMC Bioinformatics 8(S-10), 1\u201310", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2007}, {"title": "Matrix factorization techniques for recommender systems", "author": ["C. Volinsky"], "venue": "pp. 30\u201337", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2009}, {"title": "A kernel-based framework for learning graded relations from data", "author": ["W. Waegeman", "T. Pahikkala", "A. Airola", "T. Salakoski", "M. Stock", "B. De Baets"], "venue": "IEEE Transactions on Fuzzy Systems 20(6), 1090\u20131101", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2012}, {"title": "Predicting target-ligand interactions using protein ligand-binding site and ligand substructures", "author": ["C. Wang", "J. Liu", "F. Luo", "Z. Deng", "Q.N. Hu"], "venue": "BMC Systems Biology 9(S1), S2", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2015}, {"title": "Kernel dependency estimation", "author": ["J. Weston", "O. Chapelle", "A. Elisseeff", "B. Sch\u00f6lkopf", "V. Vapnik"], "venue": "Advances in Neural Information Processing Systems, vol. 39, pp. 440\u201350", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2006}, {"title": "Drug-target interaction prediction from chemical, genomic and pharmacological data in an integrated framework", "author": ["Y. Yamanishi", "M. Kotera", "M. Kanehisa", "S. Goto"], "venue": "Bioinformatics 26(12), i246\u201354", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2010}, {"title": "Inverted files for text search engines", "author": ["J. Zobel", "A. Moffat"], "venue": "ACM Computing Surveys 38(2)", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [{"referenceID": 8, "context": "[9]), Big Data problems nowadays routinely deal with very large output spaces.", "startOffset": 0, "endOffset": 3}, {"referenceID": 44, "context": "[45,49].", "startOffset": 0, "endOffset": 7}, {"referenceID": 48, "context": "[45,49].", "startOffset": 0, "endOffset": 7}, {"referenceID": 1, "context": "[2,14,47].", "startOffset": 0, "endOffset": 9}, {"referenceID": 13, "context": "[2,14,47].", "startOffset": 0, "endOffset": 9}, {"referenceID": 46, "context": "[2,14,47].", "startOffset": 0, "endOffset": 9}, {"referenceID": 3, "context": "For example, in content-based filtering, one would recommend items to users based on user profiles and side information about items [4,11].", "startOffset": 132, "endOffset": 138}, {"referenceID": 10, "context": "For example, in content-based filtering, one would recommend items to users based on user profiles and side information about items [4,11].", "startOffset": 132, "endOffset": 138}, {"referenceID": 28, "context": "on feature descriptions of proteins and ligands [29,51].", "startOffset": 48, "endOffset": 55}, {"referenceID": 50, "context": "on feature descriptions of proteins and ligands [29,51].", "startOffset": 48, "endOffset": 55}, {"referenceID": 27, "context": "[28].", "startOffset": 0, "endOffset": 4}, {"referenceID": 43, "context": "[44].", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "Existing methods for speeding up nearest neighbor search, such as [17], are hence not directly applicable to maximum inner product search.", "startOffset": 66, "endOffset": 70}, {"referenceID": 6, "context": "One approach to compute the maximum inner product would be to partition the target space using efficient data structures such as k-d trees [7], ball trees [35], cover trees [8] or branch-and-bound search techniques [31].", "startOffset": 139, "endOffset": 142}, {"referenceID": 34, "context": "One approach to compute the maximum inner product would be to partition the target space using efficient data structures such as k-d trees [7], ball trees [35], cover trees [8] or branch-and-bound search techniques [31].", "startOffset": 155, "endOffset": 159}, {"referenceID": 7, "context": "One approach to compute the maximum inner product would be to partition the target space using efficient data structures such as k-d trees [7], ball trees [35], cover trees [8] or branch-and-bound search techniques [31].", "startOffset": 173, "endOffset": 176}, {"referenceID": 30, "context": "One approach to compute the maximum inner product would be to partition the target space using efficient data structures such as k-d trees [7], ball trees [35], cover trees [8] or branch-and-bound search techniques [31].", "startOffset": 215, "endOffset": 219}, {"referenceID": 40, "context": "Recently, a locality-sensing hashing method for maximum inner product search has been developed [41,42].", "startOffset": 96, "endOffset": 103}, {"referenceID": 41, "context": "Recently, a locality-sensing hashing method for maximum inner product search has been developed [41,42].", "startOffset": 96, "endOffset": 103}, {"referenceID": 0, "context": "Another approximate method would be to cluster the queries x in several groups, for which rankings of targets y can be precomputed by means of predictive indices and related data structures [1, 23].", "startOffset": 190, "endOffset": 197}, {"referenceID": 22, "context": "Another approximate method would be to cluster the queries x in several groups, for which rankings of targets y can be precomputed by means of predictive indices and related data structures [1, 23].", "startOffset": 190, "endOffset": 197}, {"referenceID": 26, "context": "strongly related problem as (2) is often observed in information retrieval [27].", "startOffset": 75, "endOffset": 79}, {"referenceID": 53, "context": "When queries and documents have sparse representations and relevance is defined by means of cosine similarity, one can reduce the computational complexity of retrieval by using data structures such as inverted indices [54].", "startOffset": 218, "endOffset": 222}, {"referenceID": 19, "context": "In particular, we are analyzing in this paper Fagin\u2019s algorithm and extensions thereof [20].", "startOffset": 87, "endOffset": 91}, {"referenceID": 19, "context": "We show that the problem can be solved more efficiently using exact methods that are well known in database research and information retrieval, namely Fagin\u2019s algorithm [20] and the so-called threshold algorithm [21].", "startOffset": 169, "endOffset": 173}, {"referenceID": 20, "context": "We show that the problem can be solved more efficiently using exact methods that are well known in database research and information retrieval, namely Fagin\u2019s algorithm [20] and the so-called threshold algorithm [21].", "startOffset": 212, "endOffset": 216}, {"referenceID": 0, "context": ", zR belong to the interval [0, 1] and Q has to be an increasing aggregation operator, i.", "startOffset": 28, "endOffset": 34}, {"referenceID": 0, "context": "The resulting values zr do not necessarily belong to the interval [0, 1], but they can be transformed accordingly for a fixed query x and set of targets Y.", "startOffset": 66, "endOffset": 72}, {"referenceID": 20, "context": "It has been shown in [21] that the threshold algorithm is instanceoptimal, meaning that the algorithm cannot be outperformed by any other algorithm when wild guesses are not allowed.", "startOffset": 21, "endOffset": 25}, {"referenceID": 20, "context": "1 in [21] by transforming problem statement (2) to the original problem setting of Fagin, as discussed more formally above, and observing that this leads to searching for the max-", "startOffset": 5, "endOffset": 9}, {"referenceID": 20, "context": "We refer to [21] for more details.", "startOffset": 12, "endOffset": 16}, {"referenceID": 21, "context": "Sorting the lists can be done offline and parallel extensions can be easily implemented [22].", "startOffset": 88, "endOffset": 92}, {"referenceID": 20, "context": "This modification is known as the halted threshold algorithm [21].", "startOffset": 61, "endOffset": 65}, {"referenceID": 38, "context": "[39].", "startOffset": 0, "endOffset": 4}, {"referenceID": 31, "context": "This is referred to as model-based collaborative filtering and includes models such as Bayesian networks, clustering and matrix factorization methods [32].", "startOffset": 150, "endOffset": 154}, {"referenceID": 24, "context": "As a result, the connection with SEP-LR models holds for basically all matrix decomposition algorithms, inclucing non-negative matrix factorization, independent component analysis, sparse principal component analysis and singular value decomposition methods [25].", "startOffset": 258, "endOffset": 262}, {"referenceID": 13, "context": "targets, respectively [14,47].", "startOffset": 22, "endOffset": 29}, {"referenceID": 46, "context": "targets, respectively [14,47].", "startOffset": 22, "endOffset": 29}, {"referenceID": 4, "context": "Multi-task learning then further unifies those subfields, and further extends them to problems where not all targets are observed (or relevant) for all instances [5,10].", "startOffset": 162, "endOffset": 168}, {"referenceID": 9, "context": "Multi-task learning then further unifies those subfields, and further extends them to problems where not all targets are observed (or relevant) for all instances [5,10].", "startOffset": 162, "endOffset": 168}, {"referenceID": 46, "context": "This method is known as the binary relevance method in the multi-label classification community [47].", "startOffset": 96, "endOffset": 100}, {"referenceID": 51, "context": "[52]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18,19,30].", "startOffset": 0, "endOffset": 10}, {"referenceID": 18, "context": "[18,19,30].", "startOffset": 0, "endOffset": 10}, {"referenceID": 29, "context": "[18,19,30].", "startOffset": 0, "endOffset": 10}, {"referenceID": 39, "context": "An interesting example from this point of view is the partial least squares (PLS) algorithm, which projects the features onto a lowerdimensional subspace [40].", "startOffset": 154, "endOffset": 158}, {"referenceID": 5, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 123, "endOffset": 132}, {"referenceID": 25, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 123, "endOffset": 132}, {"referenceID": 47, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 123, "endOffset": 132}, {"referenceID": 42, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 161, "endOffset": 165}, {"referenceID": 23, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 189, "endOffset": 199}, {"referenceID": 27, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 189, "endOffset": 199}, {"referenceID": 52, "context": "They are particularly popular in certain domains of bioinformatics, such as the prediction of protein-protein interactions [6,26,48], enzyme function prediction [43] and proteochemometrics [24,28,53].", "startOffset": 189, "endOffset": 199}, {"referenceID": 14, "context": "Some authors, such as [15], claim that pairwise methods in kernel form are not viable for large-scale problems as they scale O(NM) in memory and O(NM) in time complexity for most algorithms.", "startOffset": 22, "endOffset": 26}, {"referenceID": 35, "context": "For some models though, when the kernels can be factorised using the Kronecker product, the memory and time complexity reduce to O(N + M) and O(N + M), respectively, see [36,50].", "startOffset": 170, "endOffset": 177}, {"referenceID": 49, "context": "For some models though, when the kernels can be factorised using the Kronecker product, the memory and time complexity reduce to O(N + M) and O(N + M), respectively, see [36,50].", "startOffset": 170, "endOffset": 177}, {"referenceID": 36, "context": "Recently, a method called two-step regularised least squares was proposed, as an intuitive way to bring this paradigm to practice [37].", "startOffset": 130, "endOffset": 134}, {"referenceID": 45, "context": "For model-based collaborative filtering, we applied matrix factorization by means of probabilistic PCA [46], having as advantage that a computationally efficient expectation maximisation algorithm can be used.", "startOffset": 103, "endOffset": 107}, {"referenceID": 2, "context": "html 4 This dataset [3] is strictly speaking not a collaborative filtering benchmark dataset, but it can be treated using a similar workflow.", "startOffset": 20, "endOffset": 23}, {"referenceID": 11, "context": "See [12] for an recommender system built using this dataset.", "startOffset": 4, "endOffset": 8}, {"referenceID": 39, "context": "As a feature representation, we used weighted subsequence kernels [40], which define similarity between sequences based on subsequences of a fixed length.", "startOffset": 66, "endOffset": 70}, {"referenceID": 15, "context": "We performed an approximation inspired by the Nystr\u00f6m method [16], a method to approximate the decomposition of large kernel matrices.", "startOffset": 61, "endOffset": 65}, {"referenceID": 20, "context": "We can conclude that it could make sense in some cases to use the halted threshold algorithm (see [21]) which stops when the computational resources have run out (e.", "startOffset": 98, "endOffset": 102}, {"referenceID": 37, "context": "This dataset was downloaded from the Kaggle \u2018Large Scale Hierarchical Text Classification\u2019 challenge [38].", "startOffset": 101, "endOffset": 105}, {"referenceID": 32, "context": "The word counts were transformed into term frequency-inverse document frequencies [33].", "startOffset": 82, "endOffset": 86}, {"referenceID": 33, "context": "This approach is similar to that performed by [34] on this dataset.", "startOffset": 46, "endOffset": 50}, {"referenceID": 12, "context": "[13]).", "startOffset": 0, "endOffset": 4}], "year": 2016, "abstractText": "Many complex multi-target prediction problems that concern large target spaces are characterised by a need for efficient prediction strategies that avoid the computation of predictions for all targets explicitly. Examples of such problems emerge in several subfields of machine learning, such as collaborative filtering, multi-label classification, dyadic prediction and biological network inference. In this article we analyse efficient and exact algorithms for computing the top-K predictions in the above problem settings, using a general class of models that we refer to as separable linear relational models. We show how to use those inference algorithms, which are modifications of well-known information retrieval methods, in a variety of machine learning settings. Furthermore, we study the possibility of scoring items incompletely, while still retaining an exact top-K retrieval. Experimental results in several application domains reveal that the so-called threshold algorithm is very scalable, performing often many orders of magnitude more efficiently than the naive approach.", "creator": "LaTeX with hyperref package"}}}