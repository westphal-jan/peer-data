{"id": "1606.06355", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Jun-2016", "title": "A Hierarchical Reinforcement Learning Method for Persistent Time-Sensitive Tasks", "abstract": "reinforcement learning approaches has been applied to many interesting problems such as improving the famous shuttle td - gammon and the current inverted helicopter flight. however, little effort has been put into developing methods to learn policies for eliminating complex persistent tasks and tasks that are time - sensitive. writing in this short paper, we take a step towards solving of this problem by using signal temporal logic ( stl ) as task specification, and taking this advantage of the temporal abstraction feature that the options framework provide. we show via simulation that a relatively easy to implement algorithm workshop that combines stl and options can learn a satisfactory policy with a small number of training cases", "histories": [["v1", "Mon, 20 Jun 2016 22:43:29 GMT  (467kb,D)", "http://arxiv.org/abs/1606.06355v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["xiao li", "calin belta"], "accepted": false, "id": "1606.06355"}, "pdf": {"name": "1606.06355.pdf", "metadata": {"source": "CRF", "title": "A Hierarchical Reinforcement Learning Method for Persistent Time-Sensitive Tasks", "authors": ["Xiao Li", "Calin Belta"], "emails": ["xli87@bu.edu", "cbelta@bu.edu"], "sections": [{"heading": null, "text": "I. INTRODUCTION\nReinforcement learning is the problem of learning from interaction with the environment to achieve a goal [3]. Usually the interaction model is unknown to the learning agent and an optimal policy is to be learned with sequences of interaction experiences and a reward that indicates the \u201dcorrectness\u201d of taking an action hence the reinforcement. There has been a number of successful attempts to apply reinforcement learning to the field of control. One of the most widely known efforts is learning of a flight controller for aggressive aerobatic maneuvers on a RC helicopter [2]. In addition, a PR2 (Personal Robot 2) has learned to perform a number of household chores such at placing a coat hanger, twisting open bottle caps, etc using ideas from reinforcement learning [4]. More recent efforts in this area has led a learning agent to play many of the classic Atari 2600 games at the professional human level [5], and the the possibility of a match at the game of Go between AlphaGo (an AI agent created by Google Deepmind [6]) and one of the top Go players in the world Lee Sedol.\nReinforcement learning has great potential in areas where precise modeling of system and environmental dynamics are difficult but interaction data is available, which is the case for many real world applications. In classical reinforcement learning, the reward structure needs to be carefully designed to obtain a desirable outcome, and often additional techniques such as reward shaping [7],[8] need to be applied to improve the learning efficiency. Moreover, the tasks being learned are often single goal episodic tasks such as reaching a destination in shortest time [9], paddling a ball [10] or winning a game that has a set of well defined rules [5],[1]. Little effort has been put into creating a learning\nX. Li is with the Department of Mechanical Engineering. C. Belta is with the Division of Systems Engineering and the Department of Mechanical Engineering at Boston University, Boston, MA -2215. Email: {xli87,cbelta}@bu.edu\nThis work is partially supported by the ONR under grant N00014-14-10554 and by the NSF under grant NRI-1426907, CMMI-1400167\nagent for complex time-sensitive multi-goal persistent tasks. Persistence requires that the task is continuous/cyclic and does not have a notion of termination (or absorbing state), whereas multi-goal time-sensitiveness indicates that the task consists of subtasks and it is desirable to switch among them in a predefined timely fashion. An example of such a task is controlling of a robotic manipulator on an assembly line. Here the manipulator may switch from fastening a screw at one location to wielding at another location, and the time between the switch may need to be controlled depending on how the position and orientation of the part are handled by possibly the conveyer belt or other manipulators.\nLearning of simple persistent tasks has traditionally been tackled using average reward reinforcement learning [11]. Well known algorithms include R-learning [12] and Hlearning [13]. However these methods work well with only unichain MDPs where every deterministic and stationary policy on that MDP contains only a single loop, also called a recurrent class of states [14]. This is obviously not enough for any task of reasonable complexity. [15],[16] uses model-based approaches to learn policies that maximize the probability of satisfying a given linear temporal logic (LTL) formula. However, using probability of satisfaction to guide learning can be of low efficiency because no \u201dpartial credit\u201d is given to the agent for being \u201dclose\u201d to satisfying the specification. And thus the agent performs random search before it \u201daccidentally\u201d satisfies the LTL specification for the first time. Moreover, LTL has time-abstract semantics that prevent users from specifying time bounds quantitatively.\nIn this paper we turned to signal temporal logic (STL), a rich predicate logic that can describe tasks involving bounds on physical states, continuous time windows and logical relationships. For example the assembly line manipulator control task described earlier can be easily expressed using STL in the form \u201dfrom start of the assembly task until the end, with a period of \u2206t repeatedly position the endeffector to within a tolerance of the screw location and perform fastening motion, and then position the end-effector to within a tolerance of the wielding point and perform the wielding task\u201d (the STL formula is presented in the next section). The one significant convenience that STL brings is its equipment with a continuous measure of satisfiability called the robustness degree, which translates naturally to a continuous reward structure that can be used in the reinforcement learning framework. Therefore with STL the user only has to \u201dspell out\u201d the task requirements in a compact yet powerful language and the rest will be taken care of (no need to struggle with designing a good reward structure). ar X\niv :1\n60 6.\n06 35\n5v 1\n[ cs\n.A I]\n2 0\nJu n\n20 16\nThe challenge of using STL is that evaluation of the robustness degree requires a state trajectory, therefore either some kind of memory needs to be incorporated into the learning agent or the state/action space be expanded to incorporate trajectories that the agent can choose from. Here we adopt the options framework [17] which abstracts each subtask as an MDP with a policy of its own, and a higher level policy is present to choose among the subtask policies at appropriate times. In this paper we present an algorithm that given an STL task specification, automatically generates a set of subtasks, and by interacting with the environment simultaneously learn the subtasks\u2019 policies and the higher level policy that will lead the agent to satisfy the given specification.\nSection II introduces the Q-learning algorithm that subsequent contents are developed on, as well as the options framework and STL. Section III describes in detail the proposed algorithm. Section IV provides simulation results to verify the proposed approach and some discussions about the advantages and shortcomings of the algorithm. Section V concludes with final remarks and directions for future work."}, {"heading": "II. BACKGROUND", "text": "Reinforcement learning bears the curse of dimensionality. Especially for discretized representations of state and action spaces (used in many classical tabular methods [3]), the number of parameters (state value, action value, etc) increase exponentially with the size of the state/action space. One attempt to alleviate such computational burden is to exploit temporal and state abstractions and the possibility of learning on a reduced set of abstractions as oppose to the primitive state and actions. Ideas along this line are called hierarchical reinforcement learning (HRL) in the literature, and a survey of advances in this area as well as the main approaches used are provided in [18]. We base our work on the options framework developed in [17] for its ability to deal with temporally extended actions, which is an extremely helpful factor in the development of an algorithm that learns a policy that satisfies the complicated task specification given by an STL formula."}, {"heading": "A. Reinforcement Learning Framework and Q-Learning", "text": "Here we briefly describe the reinforcement learning framework for discrete-time finite Markov decision processes (MDP).\nDefinition 1: An MDP is a tuple \u3008S,A, T (\u00b7, \u00b7, \u00b7), R(\u00b7, \u00b7, \u00b7)\u3009 where \u2022 S is a finite set of states; \u2022 A is a finite set of actions; \u2022 T : S\u00d7A\u00d7S \u2192 [0, 1] is the transition probability with T (s, a, s\u2032) being the probability of taking action a \u2208 A at state s \u2208 S and end up in state s\u2032 \u2208 S;\n\u2022 R : S \u00d7 A \u00d7 S \u2192 IR is the reward function with R(s, a, s\u2032) being the reward obtained by taking action a in s and end in s\u2032. In reinforcement learning, the transition model T (s, a, s\u2032) and the reward structure R(s, a, s\u2032) are unknown to the\nlearning agent (but an immediate reward r is given to the agent after each action), instead the agent has to interact with the environment and figure out the optimal sequence of actions to take in order to maximize the obtained reward. We have based our method on one of the most popular modelfree off-policy reinforcement learning algorithms called Qlearning [19]. In short, Q-learning aims at finding a policy \u03c0 : S \u2192 A that maximizes the expected sum of discounted reward given by\nV (s) = E[ \u221e\u2211 i=0 \u03b3iri]. (1)\nHere \u03b3 \u2208 [0,1] is a constant discount factor and is decayed with time (hence the exponent i) to put higher value on more recent rewards. ri is the one step immediate reward at step i. Equation (1) can be written recursively as\nV (s) = \u2211 s\u2032\u2208S T (s, a, s\u2032)(r + \u03b3V (s\u2032)), (2)\nwhich becomes the well known Bellman\u2019s Equation. Algorithms exist that learns the optimal value function V (s) from experience. The most famous one is perhaps the temporal difference learning algorithm (also called TD-learning [20]). After V (s) converges to its optimal value V ?(s), we have the recursive relationship\nV ?(s) = max a\u2208A \u2211 s\u2032\u2208S T (s, a, s\u2032)(r + \u03b3V ?(s\u2032)). (3)\nAnd the optimal policy is calculated from\n\u03c0?(s) = arg max a\u2208A V ?(s). (4)\nHowever without knowing the transition model T (s, a, s\u2032), it is difficult to extract the optimal policy from V ?(s). This is where Q-learning comes in. Define an action-value function that assigns a value to each state-action pair (also known as the Q function) as follows\nQ(s, a) = \u2211 s\u2032 T (s, a, s\u2032)(r + \u03b3V (s\u2032)). (5)\nThen following Equation (3) we have\nV ?(s) = max a\u2208A Q?(s, a). (6)\nNow we can write the optimal Q-function in a recursive form by\nQ?(s, a) = \u2211 s\u2032\u2208S T (s, a, s\u2032)(r + \u03b3max a\u2208A Q?(s, a)). (7)\nAnd Q?(s, a) can be approximated by calculating a running average of the Q-values obtained from experience.\nAssume at time t the agent takes action a, transitions from state s to s\u2032, and obtains a one step immediate reward r\n(experiences usually take form of a tuple (s, a, s\u2032, r)). The Q-function is then update following\nQ(s, a)\u2190 Q(s, a) +\u03b1t(r+ \u03b3max a\u2032\u2208A\nQ(s\u2032, a\u2032)\u2212Q(s, a)), (8)\nwhere \u03b1 \u2208 [0, 1] is the learning rate. It is proven in [21] that if the choice of \u03b1 satisfies \u2211\u221e t \u03b1t = \u221e and \u2211\u221e t \u03b1 2 t < \u221e while every state and action are visited infinitely often, then Q(s, a) converges (denoted by Q?(s, a)). In practice it is usually sufficient to use a constant \u03b1 and thus the subscript t is dropped in later formulations. After convergence, the optimal policy can be calculated by\n\u03c0?(s) = arg max a\u2208A Q?(s, a). (9)\nSince action a is an explicit variable of the Q-function, Equation (15) can be easy evaluated."}, {"heading": "B. Option-Based Hierarchical Reinforcement Learning", "text": "The options framework deals explicitly with temporally extended actions. An option is defined by a tuple \u3008I, \u03c0, \u03b2\u3009 where I \u2286 S is the initiation set denoting the states where an option is available. \u03c0 : S \u2192 A is the option\u2019s policy (also called a flat policy) and \u03b2 : S \u2192 [0, 1] is the termination map defining the probability of termination of an option at each state. Suppose at time t the agent resides at state s. Instead of choosing an action a \u2208 A, the agent chooses an option o = \u3008Io, \u03c0o, \u03b2o\u3009 \u2208 O, where O is the set of options (note that option o needs to be available at state s i.e. s \u2208 Io). After selecting the option, the agent follows the option\u2019s flat policy \u03c0o(s) until termination is invoked. If the termination state is s\u2032, then \u03b2(s\u2032) > 0. Analogous to Q-learning, the experience that the agent obtained now becomes a tuple (s, o, s\u2032, ro), where ro is a lumped reward from executing option o to termination. Assuming that option o is being executed for k time steps, now instead of updating an action-value function Q(s, a), an option-value function is updated using\nQ(s, o)\u2190 Q(s, o)+\u03b1(ro+\u03b3kmax o\u2032\u2208O Q(s\u2032, o\u2032)\u2212Q(s, o)). (10)\nThis update is applied each time an option is executed to termination. Equation (10) is very similar to Equation (8) except for the exponent k on the discount factor \u03b3. This is to signify that the option is executed for a temporally extend period of time and future rewards should be discounted accordingly. It is worth mentioning that a primitive action can be considered a one step option oa = \u3008Ia, \u03c0a, \u03b2a\u3009 where Ia = S, \u03c0a(s) = a and \u03b2a(s) = 1,\u2200s \u2208 S, therefore if oa is executed at all times then Equation (10) becomes Equation (8). The optimal options policy \u00b5 : S \u2192 O is obtained by\n\u00b5?(s) = arg max o\u2208O Q?(s, o). (11)\nThe flat policy \u03c0o(s) for each option in O can be provided by the user or be learned simultaneously with the options policy \u00b5(s). Details on simultaneous learning will be discussed in\nthe next section. We refer readers to [17] for a detailed formulation of the options framework."}, {"heading": "C. Signal Temporal Logic (STL)", "text": "Signal temporal logic is a framework used to describe an expressive collection of specifications in a compact form. It was originally developed to monitor continuous-time signals, but can be extended to describe desired state constraints in a control system. Here we briefly present the necessary definitions of STL and refer interested readers to [22], [23], [24] for further details. Informally, STL formulas consist of boolean connectives \u00ac(negation/not), \u2227(conjunction/and), \u2228 (disjunction/or), as well as bounded-time temporal operators U[t1,t2) (until between t1 and t2), \u2666[t1,t2) (eventually between t1 and t2) and 2[t1,t2) (always between t1 and t2) that operate on a finite set of predicates over the underlying states. As a quick example, consider a robot traveling in a plane with its position (x, y) as states. The trajectory of the robot is specified by a simple STL formula\n\u03c6 = 2[0,4)\u03c8, \u03c8 = 2[0,4)[(x > 10) \u2227 (x < 14) \u2227 (y > 6) \u2227 (y < 10)]. (12)\nThe formula in Equation (12) reads \u201dalways in 0 to 4 time steps, x is to be greater than 10 and smaller than 12, and y greater than 6 and smaller than 8\u201d, which specifies that the robot should stay in a square region given by bound (xmax = 14, xmin = 10, ymax = 10, ymin = 6) from 0 to 4 time steps.\nIn this paper, we constrain STL to be defined over sequences of discrete valued states produced by the MDP in Definition (1). We denote st to be the state at time t, and st:t+k to be a time series of the state trajectory from t to t+k, i.e. st:t+k = [st, st+1, . . . , st+k]. The usefulness of STL lies in its equipment with a set of quantitative measure of how well a given formula is satisfied, which is called robustness degree (robustness for short). In the above example, a term like x > 10 is called a predicate which we denote by p. Let p take the form of a general inequality f(s) < c, where f(s) is a function of the states and c is a constant (such as f(x, y) = x+2y < 7). If a state trajectory st:t+k is provided, the robustness of an STL formula is defined recursively by\nr(st, f(st) < c) = c\u2212 f(st), r(st,\u00ac\u03c6) = \u2212r(st, \u03c6), r(st, \u03c61 \u2227 \u03c62) = min(r(st, \u03c61), r(st, \u03c62)), r(st, \u03c61 \u2228 \u03c62) = max(r(st, \u03c61), r(st, \u03c62)), r(st:t+k,2[t,t+k]\u03c6) = min\nt\u2032\u2208[t,t+k) (r(st\u2032 , \u03c6)),\nr(st:t+k,\u2666[t,t+k]\u03c6) = max t\u2032\u2208[t,t+k) (r(st\u2032 , \u03c6)),\nr(st:t+k, \u03c61U[t,t+k)\u03c62) =\nmax t\u2032\u2208[t,t+k)\n( min ( r(st\u2032 , \u03c61), min\nt\u2032\u2032\u2208[t,t\u2032) r(st\u2032\u2032, \u03c62)\n)) .\n(13)\nNote that in general if formula \u03c6 contains temporal operators (2,\u2666, U ), a state trajectory st:t+k is required to evaluate robustness, but if \u03c6 contains only boolean connected predicates, the robustness is then evaluated with respective to one particular state st. Using the above definition of robustness, a larger positive value means stronger satisfaction and a larger negative value means stronger violation of the STL formula.\nTable I shows an example of how to calculate the robustness of a trajectory given STL formula in Equation (12). We can see that for this trajectory the overall robustness is negative meaning that Equation (12) is violated. The reason is that the first point in the trajectory lies outside the desired square given by \u03c8 and the STL formula dictates that all positions should stay inside the square within the timeframe of 0 to 4 . If instead of 2[0,4)\u03c8 we specify \u2666[0,4)\u03c8, then r(s0:4, \u03c6) = 1 because \u2666 (eventually) looks at the highest satisfying point whereas 2(always) looks at the highest violation point. The point of maximum satisfaction occurs at the center of the square (s = (12, 8)) with a robustness value of 2.\nEven though the example above uses the simplest form of STL formula for explanation, an STL specification can be much richer. For the assembly line manipulator task mentioned in the Introduction, let pee be the position of the end-effector, pscrew be the position of the screw to be fastened, and pwield be the wielding point. Then the assembly task can be expressed by the STL formula\n\u03c6assembly = 2[0,\u221e)[\u2666[0,\u2206t)(|pee \u2212 pscrew| < \u03b7screw)\u2227 \u2666[0,\u2206t)(|pee \u2212 pwield| < \u03b7wield)].\n(14)\nIn the above formula | \u00b7 | is the Euclidean distance. \u03b7screw and \u03b7wield are the position thresholds for the screw fastening and wielding tasks respectively."}, {"heading": "III. REINFORCEMENT LEARNING FOR STL SPECIFIED GOALS", "text": "The options framework provides a way to expand the action space to a set of options. Executing options generate repeatable trajectories that can be used to evaluate STL robustness. In this section we present an algorithm that, given an STL formula that describes the desired behavior of the system, automatically generates a set of options. The algorithm then learns a hierarchically optimal options policy and all options\u2019 flat policies by interacting with the environment (more on hierarchical optimality in the next section)."}, {"heading": "A. Problem Formulation", "text": "Given an options policy \u00b5 : S \u2192 O, let V \u00b5(s) be the expected sum of discounted lumped reward of state s obtained from following \u00b5, which can be written recursively as\nV \u00b5(s) = E[ro + \u03b3 ko o V \u00b5(s\u2032)]. (15)\nIn the above equation, the subscripts o denote the option being executed i.e. o = \u00b5(s) at each state s. ro = r(st:t+ko , \u03c6) is the lumped reward obtained from executing option o at time t and state s, and terminating at time t + ko and state s\u2032 (refer to Equation (13) for notation and robustness calculation). Here we denote ko to be the number of time steps option o takes to terminate. The problem that we address in this paper can then be formulated as:\nProblem 1: Given an MDP M = \u3008S,A, T,R\u3009 with unknown transition model T (s, a, s\u2032) and reward structure R(s, a, s\u2032), an STL formula \u03c6 over S, and a set of options O, find a policy \u00b5 : S \u2192 O that maximizes the expected sum of discounted lumped reward as specified in Equation (15).\nBefore the algorithm is presented, we introduce some terminology. First a primitive option is an option whose policy is a flat policy (i.e \u03c0p : S \u2192 A). This is in contrast with a hierarchical option whose policy maps states to lower level options (\u03c0h : S \u2192 O). In other words a hierarchical option is an option over option and thus higher up the hierarchy. We will not be using hierarchical options in this paper. A temporally combined option is an option constructed from executing a selected set of options in a predefined order. For example, suppose we have two primitive options op1 = \u3008Ip1, \u03c0p1, \u03b2p1\u3009 and op2 = \u3008Ip2, \u03c0p2, \u03b2p2\u3009, a temporally combined option op1\u22122 = \u3008Ip1\u22122, \u03c0p1\u22122, \u03b2p1\u22122\u3009 can be executed by first following option op1 until termination and then follow option op2 until termination. Therefore the initiation set Ip1\u22122 = Ip1 and the termination map \u03b2p1\u22122 = \u03b2p2. Also it should be ensured that the states where termination of option op1 is possible should be an element of the initiation set of op2 i.e. {s : \u03b2p1(s) > 0} \u2286 Ip2. A temporally combined option can be a primitive option or a hierarchical option depending on its constituent options. For the method presented in this paper, all options are primitive options hence the subscript p is dropped."}, {"heading": "B. The Hierarchical STL Learning Algorithm (HSTLLearning)", "text": "Given a STL specification containing n boolean connected predicates \u03c81 to \u03c8n (like the \u03c8 in Equation (12)), for each \u03c8i \u2208 {\u03c81, . . . , \u03c8n}, construct a primitive option oi = \u3008Ii, \u03c0i, \u03b2i\u3009 ( Ii and \u03b2i are user defined). Using these primitive options, a set of temporally combined options OT is constructed. The way in which OT is constructed can be controlled by the user. For example if the primitive options set is Op = {o1, o2, o3} , a possible temporally combined options set can be OT = {o1, o2, o3, o1\u22122, o1\u22123, o2\u22123, o1\u22122\u22123}.\nHere we take advantage of the fact that Q-learning is an offpolicy learning algorithm, meaning that the learned policy is independent of the exploration scheme [25]. Hence multiple policies can be learned simultaneously while the agent is interacting with the environment. In the case of this example, n+ 1 policies need to be learned where n is the number of boolean connected predicates in the STL specification (hence the number of flat policies) and one more for the options policy \u00b5 : S \u2192 OT . The complete learning algorithm is present in Algorithm 1.\nAlgorithm 1 HSTL-Learning 1: procedure HSTL-UPDATE(\u03c6, o, Traj,Act) 2: For each of the n primitive options, initialized action-\nvalue function Q(s, a) \u2190 Q0(s, a), initiation set I and termination map \u03b2 3: Construct the temporally combined options set OT 4: Initialize the option-value function Qi(s, o) \u2190 Q0(s, o) for o \u2208 OT 5: Choose learning rates \u03b1 and discount factors \u03b3 for all learning agents 6: sk \u2190 Traj[:, k] . this is the state where o is terminated. colon indicates all elements in the dimension 7: for i = 1 to k \u2212 1 do 8: si \u2190 Traj[:, i] 9: ai \u2190 Act[:, i] 10: si+1 \u2190 Traj[:, i+ 1] 11: for j = 1 to n do . update all primitive\noptions\u2019 Q-functions 12: rj \u2190 r(si+1, \u03c8i) . robustness as the reward\nfor flat policy learning, refer to Equation (13) 13: Qj(si, ai) \u2190 Qj(si, ai) + \u03b1j(rj +\n\u03b3j max ai+1\u2208A Qj(si+1, ai+1)\u2212Qj(si, ai)) 14: end for 15: Trajseg = Traj[:, i : k] . i : k indicates\nelement i to k 16: roi = r(Trajseg, \u03c6) 17: Q(si, o) \u2190 Q(si, o) + \u03b1o(roi +\n\u03b3ko max ok\u2208OT Q(sk, ok)\u2212Q(si, o)) 18: end for return all Qj(s, a) for j \u2208 1, . . . , n and Q(s, o) 19: end procedure\nThe inputs to Algorithm 1 are an STL specification \u03c6, the currently selected option o \u2208 OT , and the trajectory resulted from executing o to termination Traj. Here Traj is a m\u00d7k matrix where m is the dimension of state space and k is the number of time steps o is executed before termination. Act is a q \u00d7 k matrix where q is the dimension of primitive action space. The algorithm outputs the updated n + 1 Qfunctions. The main idea of Algorithm 1 is that every time an option is executed to termination, the resulting trajectory is used to calculate a reward based on evaluating its robustness against the given STL formula (line 19). This reward is used to update the Q-function Q(s, o). In cases where the time of\nexecuting an option to termination is less than that required to evaluate the robustness of the given STL formula, the upper time bound of the STL formula is adjusted to coincide with the execution time of the option, and evaluation is proceeded as usual. This is to ensure that choices of options are Markovian and does not depend on previous history. In addition, every primitive step (s, a, s\u2032) within the trajectory is used to update the Q-function Q(s, a) for all options\u2019 flat policies, with the reward being the robustness of the resulting state s\u2032 with respective to the corresponding \u03c8 (line 15). Because Q(s, o) is updated once only when an option terminates, convergence to a desirable policy can be quite slow. To speed up the learning process, an intra-option update step is introduced which follows from the idea of intra-option value learning presented in [17]. If an option is initiated at state st and terminated at st+k with trajectory st:t+k, then for every intermediate state si, i \u2208 [t, t+ k] we can also consider the sub-trajectory si:t+k a valid experience, where option o is initiated at state si and terminated at st:t+k. Therefore instead of updating Q(s, o) only once for state st, it is updated for all intermediate states (lines 18-20), which drastically increases the efficiency for experience usage."}, {"heading": "C. Discussion", "text": "In this subsection we discuss some of the advantages and shortcomings of the proposed method. Unlike conventional reinforcement learning approaches where manual design of rewards is necessary, STL provides a way to conveniently specify complicated task goals while naturally translates the specifications to rewards. In addition, since robustness is a continuous measure of satisfiability, the resulting reward structure helps to speed up learning of the flat policies much like potential-based reward shaping [8].\nThe correctness and completeness of the proposed algorithm are determined by the options framework. Here we introduce the notion of hierarchical optimality. A policy is said to be hierarchically optimal if it achieves the highest cumulative reward among all policies consistent with the given hierarchy [26]. In general, a hierarchical learning algorithm with a fixed set of options converges to a hierarchically optimal policy [17], which is the case for the HSTL-learning algorithm. More specifically, the HSTL-learning algorithm will find a hierarchically optimal policy \u00b5? that satisfies\n\u00b5?(s) = arg max \u00b5 V \u00b5(s) (16)\nfor a fixed set of options (V \u03c0 defined in Equation (15)). Whether robustness of the STL specification is satisfied/maximized depends on the set of options provided to the algorithm. A policy leading to trajectories that maximize the robustness of the given STL formula will be found if the trajectories can be constructed from the options provided. Therefore the correctness and completeness of the proposed algorithm are related to the hierarchical optimality property, and hence also depend on the set of options provided.\nOn complexity, Algorithm 1 requires k+n operations per update. Here k is the number of steps the current option\ntakes to terminate, and n is the number of elements in the set OT . n depends on the number of flat policies and how OT is constructed. Like Q-learning, the number of training steps required for convergence depends largely on the learning parameters listed in Table II, and convergence is guaranteed if each state-action pair is visited infinitely often (convergence guarantee discussed in Section II-A).\nFinally, it is worth mentioning that multiple trajectories exist that maximally satisfy a given STL formula (for example any trajectory that passes through x = 1 maximally satisfy \u03c6 = \u2666[0,t)[(x > 0) \u2227 (x < 2)]). The proposed method chooses only the most greedy trajectory given the set of available options. This takes away some flexibility and the diversity of policies an agent can learn, but is also a predictable characteristic that can be used towards one\u2019s advantage."}, {"heading": "IV. CASE STUDY", "text": "In this section we evaluate the performance of the proposed method in a simulated environment, and provide a discussion of the results. As depicted in Figure (1), a mobile robot navigates in a 15\u00d715 grid world with three rectangular regions A, B, C enclosed by colored borders. The state space of the robot is its 2D position s = (x, y), which takes 225 discrete combinations. The robot has an action space A = {Up,Down,Left,Right}. The robot\u2019s transition model entails that it follows a given action with probability 0.7, or randomly choose the other three actions each with probability 0.1. The robot has full state observability but does not have knowledge about its transition model. The goal is for the robot to interact with the environment by taking sequences of actions and observing the resultant states, and in the end learn a policy that when followed satisfy the STL specification\n\u03c6 = 2[0,\u221e)(\u2666[0,40)\u03c8A \u2227 \u2666[0,40)\u03c8B \u2227 \u2666[0,40)\u03c8C), (17)\nwhere\n\u03c8A = (x > 3) \u2227 (x < 9) \u2227 (y > 10) \u2227 (y < 14), \u03c8B = (x > 1) \u2227 (x < 5) \u2227 (y > 1) \u2227 (y < 5), \u03c8C = (x > 9) \u2227 (x < 13) \u2227 (y > 1) \u2227 (y < 7). (18)\nIn English the above specification says \u201dfor as long as the robot is running (2[0,\u221e)), enter regions A, B and C every 40 time steps\u201d. This is a cyclic task with no termination. Three primitive options are constructed oi = \u3008Ii, \u03c0i, \u03b2i\u3009, i = A,B,C. Here we let their initiation sets to be the entire state space i.e. Ii = S, which means all three options can be initiated anywhere. The termination map is given by\n\u03b2i(s) =\n{ 1 s = arg max\ns\u2208S (r(s, \u03c8i)) (19a)\n0 otherwise, (19b)\nwhich indicates that each option only terminates when entering a state where the robustness of that state with respective to the corresponding \u03c8i is maximum. The last step is to\nconstruct the set of temporally combined options. Here we used OT = {oA, oB , oC , oAB , oAC , oBC , oABC} (the hypen in the subscript is dropped to save space). Note that the order of subscript is the order in which each primitive option is executed. To obtain a reasonable explorationexploitation ratio, an \u2212greedy exploration policy is carried out. The agent follows the greedy policy (exploitation) with probability 1 \u2212 , and chooses a random option/action with probability (exploration). The \u2212 greedy exploration is implemented both at the options policy \u00b5 : S \u2192 OT and flat policy \u03c0 : S \u2192 A level. It is important that the flat policies converge faster and takes greedy actions at higher probability than the options policy because execution of options depend on the flat policies. This is enforced by decaying the exploration probabilities linearly with time for both \u03c0(s) and \u00b5(s) ( (t) = 0 \u2212 d \u00d7 t where d is the rate of decay) while ensuring that flatpolicies decay faster. The exploration probabilities have a lower limit of 0.1 which is to preserve some exploration even near convergence. Table II shows the learning parameters used in simulation. Even though the task specified by the STL formula in Equation (17) is persistent without termination, we divide our learning process in episodes of 200 option choices. That is to say that within each episode the robot chooses an option according to the \u2212 greedy policy and executes the option to termination, and repeat for 200 times. Then the robot is randomly placed at another location and the next learning episode starts. We performed the training process for 1200 episodes on a Mac with 3 GHz processor and 8 GB memory, and the training took 36 minutes 12 seconds to complete. The resulting policies and two sample runs are presented in Figure (2).\nFigures (2a), (2b), and (2c) shows the three flat policies \u03c0A, \u03c0B , and \u03c0C learned by the algorithm. The red dot represents the termination state for each option defined by the\ntermination map. In this case the flat policies lead the robot to this state because it is the state of maximum robustness (but termination can be any state or set of states defined by the user). Figure (2d) shows the learned options policy \u00b5(s). This is the policy that the robot follows at the highest level. For example \u00b5(s) = oBC at state s = (5, 11), therefore option oB and oC will be executed to termination in order. For the STL formula in Equation (17), the desired trajectory as t \u2192 \u221e will be a loop that goes through regions A, B and C, the action/option taken at any other state should lead\nthe agent to this loop along a trajectory that evaluates to the highest robustness degree. Figures (2e) and (2f) shows two sample runs with different initial positions (indicated by the red star), and the resulting behavior is as expected. The color of the arrows corresponds to the color coding of the options in the previous options policy subfigure, and are subject to overlay. It can be observed that although for the 1200 episodes of training neither the flat policies nor the options policy has converged (for example at state s = (0, 14) in \u03c0C), the resulting policies succeed in navigating the robot towards the desired behavior.\nAs discussed in Section III-C, the quality of the learned policies with respective to maximizing robustness depends on the set of options provided to the algorithm. Figure (3) shows a comparison of cumulative reward per episode between two different sets of temporally combined options. The first is the set OT1 = OT used in previous simulation. The second set OT2 = {oA, oB , oC , oAB , oBA, oAC , oCA, oBC , oCB , oABC , oACB , oBAC , oBCA, oCAB , oCBA} takes into account the permutation of primitive options. Results show that using options set OT2 achieves an average of 34.8% higher cumulative reward per episode compared to using OT2 (negative reward values are due to \u2212 greedy random exploration when following learned policies). However the time used to\ntrain the agent for the same 1200 episodes is 43 minutes 51 seconds for OT2 compared to 36 minutes 12 seconds for OT1. In a way this allows the user to leverage a tradeoff between computational resource and optimality by deciding on the number and complexity of the options provided to the framework."}, {"heading": "V. CONCLUSION", "text": "In this paper we have developed a reinforcement learning algorithm that takes in an STL formula as task specification, and learns a hierarchy of policies that maximizes the expected sum of discounted robustness degree with hierarchical optimality. We have taken advantage of the options framework to provide to the learning agent a set of temporally extended actions (options), and the \u201dcorrectness\u201d of choosing an option at a state is evaluated by calculating the robustness degree of the resulting trajectory against the given STL formula. This naturally becomes the one step immediate reward in the reinforcement learning architecture and thus takes away the burden of manually designing a reward structure. We have shown in simulation that the proposed algorithm learns an options policy and the dependent flat policies that guide the agent to satisfy the task specification with a relatively low number of training steps. The temporal and state abstraction provided by options and STL respectively decomposes a complicated task into a hierarchy of simpler subtasks, and thus modularizing the learning process and increasing the learning efficiency. Moreover, the policies learned for the subtasks can be reused for learning a different high level task and therefore knowledge transfer is enabled. In future work we will look at applying the proposed algorithm to more realistic problems and extending from discrete state and action spaces to continuous ones."}], "references": [{"title": "Temporal difference learning and td-gammon", "author": ["G. Tesauro"], "venue": "Communications of the ACM, vol. 38, no. 3, pp. 58\u201368, 1995.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "Autonomous inverted helicopter flight via reinforcement learning", "author": ["A. Ng", "A. Coates", "M. Diel", "V. Ganapathi", "J. Schulte", "B. Tse", "E. Berger", "E. Liang"], "venue": "International Symposium on Experimental Robotics, 2004.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2004}, {"title": "Reinforcement Learning: An Introduction, 2nd ed", "author": ["R.S. Sutton", "A.G. Barto"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "End-to-End Training of Deep Visuomotor Policies", "author": ["S. Levine", "C. Finn", "T. Darrell", "P. Abbeel"], "venue": "Arxiv, p. 6922, 2015. [Online]. Available: http://arxiv.org/abs/1504.00702", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "Human-level control through deep reinforcement learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A. a. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski", "S. Petersen", "C. Beattie", "A. Sadik", "I. Antonoglou", "H. King", "D. Kumaran", "D. Wierstra", "S. Legg", "D. Hassabis"], "venue": "Nature, vol. 518, no. 7540, pp. 529\u2013533, 2015.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2015}, {"title": "Mastering the game of Go with deep neural networks and tree search", "author": ["D. Silver", "A. Huang", "C.J. Maddison", "A. Guez", "L. Sifre", "G.V.D. Driessche", "J. Schrittwieser", "I. Antonoglou", "V. Panneershelvam", "M. Lanctot", "S. Dieleman", "D. Grewe", "J. Nham", "N. Kalchbrenner", "I. Sutskever", "T. Lillicrap", "M. Leach", "K. Kavukcuoglu"], "venue": "Nature, vol. 529, no. 7585, pp. 484\u2013489, 2016. [Online]. Available: http://dx.doi.org/10.1038/nature16961", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2016}, {"title": "Policy invariance under reward transformations : Theory and application to reward shaping", "author": ["A.Y. Ng", "D. Harada", "S. Russell"], "venue": "Sixteenth International Conference on Machine Learning, vol. 3, pp. 278\u2013287, 1999.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1999}, {"title": "Shaping and policy search in reinforcement learning", "author": ["A.Y. Ng"], "venue": "Ph.D. dissertation, Computer Science, UC Berkeley, Berkeley, CA, 2003.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}, {"title": "Reinforcement Learning Benchmarks and Bake-offs II", "author": ["A. Dutech", "T. Edmunds", "J. Kok", "M. Lagoudakis", "M. Littman", "M. Riedmiller", "B. Russell", "B. Scherrer", "R. Sutton", "S. Timmer", "N. Vlassis", "A. White", "S. Whiteson"], "venue": "Workshop at 2005 NIPS Conference, pp. 1\u201350, 2005.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "Imitation and Reinforcement Learning", "author": ["J. Kober", "J. Peters"], "venue": "Robotics and Automation Magazine, vol. 17, no. 2, pp. 55\u201362, 2010.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Average reward reinforcement learning: Foundations, algorithms, and empirical results", "author": ["S. Mahadevan"], "venue": "Machine Learning, vol. 22, no. 1-3, pp. 159\u2013195, 1996.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1996}, {"title": "A Reinforcement Learning Method for Maximizing Undiscounted Rewards", "author": ["A. Schwartz"], "venue": "Proceedings of the Tenth International Conference on Machine Learning, pp. 298\u2013305, 1993.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1993}, {"title": "H-learning: A reinforcement learning method for optimizing undiscounted average reward", "author": ["P. Tadepalli", "D. Ok"], "venue": "Corvallis, OR, USA, Tech. Rep., 1994.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1994}, {"title": "Markov Decision Processes: Discrete Stochastic Dynamic Programming", "author": ["M.L. Puterman"], "venue": "p. 672, 1994.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1994}, {"title": "Probably approximately correct MDP learning and control with temporal logic constraints", "author": ["J. Fu", "U. Topcu"], "venue": "CoRR, 2014.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2014}, {"title": "A learning based approach to control synthesis of markov decision processes for linear temporal logic specifications", "author": ["D. Sadigh", "E. Kim", "S. Coogan", "S. Sastry", "S. Seshia"], "venue": "CoRR, 2014.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2014}, {"title": "Between MDPs and Semi- MDPs: Learning, Planning, and Representing Knowledge at Multiple Temporal Scales", "author": ["R.S. Sutton", "D. Precup", "S. Singh"], "venue": "Artificial Intelligence, vol. 1, no. 98-74, pp. 1\u201339, 1998.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1998}, {"title": "Recent Advances in Hierarchical Reinforcement Learning", "author": ["A.G. Barto"], "venue": "Discrete Event Dynamic Systems:Theory and Application, vol. 13, p. 4177, 2003.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2003}, {"title": "Learning from delayed rewards", "author": ["C.J.C.H. Watkins"], "venue": "Ph.D. dissertation, King\u2019s College, Cambridge, England, 1989.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1989}, {"title": "Learning to predict by the methods of temporal differences", "author": ["R.S. Sutton"], "venue": "MACHINE LEARNING. Kluwer Academic Publishers, 1988, pp. 9\u201344.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1988}, {"title": "Convergence of Q-learning: A simple proof", "author": ["F.S. Melo"], "venue": "Institute Of Systems and Robotics, Tech. Rep, pp. 1\u20134.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 0}, {"title": "Robust satisfaction of temporal logic over real-valued signals", "author": ["A. Donz\u00e9", "O. Maler"], "venue": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), vol. 6246 LNCS, pp. 92\u2013106, 2010.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2010}, {"title": "Monitoring Temporal Properties of Continuous Signals", "author": ["O. Maler", "D. Nickovic"], "venue": "Formal Techniques, Modelling and Analysis of Timed and Fault-Tolerant Systems, pp. 152 \u2013 166, 2004.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "Robust Temporal Logic Model Predictive Control", "author": ["S. Sadraddini", "C. Belta"], "venue": "53rd Annual Conference on Communication, Control, and Computing (Allerton), 2015.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2015}, {"title": "RL 5 : On-policy and off-policy algorithms", "author": ["M. Herrmann"], "venue": "Edinburgh, UK, 2015.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2015}, {"title": "Hierarchical Reinforcement Learning with the MAXQ Value Function Decomposition", "author": ["T.G. Dietterich"], "venue": "Journal of Artificial Intelligence Research, vol. 13, pp. 227\u2013303, 2000.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 0, "context": "Abstract\u2014 Reinforcement learning has been applied to many interesting problems such as the famous TD-gammon [1] and the inverted helicopter flight [2].", "startOffset": 108, "endOffset": 111}, {"referenceID": 1, "context": "Abstract\u2014 Reinforcement learning has been applied to many interesting problems such as the famous TD-gammon [1] and the inverted helicopter flight [2].", "startOffset": 147, "endOffset": 150}, {"referenceID": 2, "context": "Reinforcement learning is the problem of learning from interaction with the environment to achieve a goal [3].", "startOffset": 106, "endOffset": 109}, {"referenceID": 1, "context": "One of the most widely known efforts is learning of a flight controller for aggressive aerobatic maneuvers on a RC helicopter [2].", "startOffset": 126, "endOffset": 129}, {"referenceID": 3, "context": "In addition, a PR2 (Personal Robot 2) has learned to perform a number of household chores such at placing a coat hanger, twisting open bottle caps, etc using ideas from reinforcement learning [4].", "startOffset": 192, "endOffset": 195}, {"referenceID": 4, "context": "More recent efforts in this area has led a learning agent to play many of the classic Atari 2600 games at the professional human level [5], and the the possibility of a match at the game of Go between AlphaGo (an AI agent created by Google Deepmind [6]) and one of the top Go players in the world Lee Sedol.", "startOffset": 135, "endOffset": 138}, {"referenceID": 5, "context": "More recent efforts in this area has led a learning agent to play many of the classic Atari 2600 games at the professional human level [5], and the the possibility of a match at the game of Go between AlphaGo (an AI agent created by Google Deepmind [6]) and one of the top Go players in the world Lee Sedol.", "startOffset": 249, "endOffset": 252}, {"referenceID": 6, "context": "In classical reinforcement learning, the reward structure needs to be carefully designed to obtain a desirable outcome, and often additional techniques such as reward shaping [7],[8] need to be applied to improve the learning efficiency.", "startOffset": 175, "endOffset": 178}, {"referenceID": 7, "context": "In classical reinforcement learning, the reward structure needs to be carefully designed to obtain a desirable outcome, and often additional techniques such as reward shaping [7],[8] need to be applied to improve the learning efficiency.", "startOffset": 179, "endOffset": 182}, {"referenceID": 8, "context": "a destination in shortest time [9], paddling a ball [10] or winning a game that has a set of well defined rules [5],[1].", "startOffset": 31, "endOffset": 34}, {"referenceID": 9, "context": "a destination in shortest time [9], paddling a ball [10] or winning a game that has a set of well defined rules [5],[1].", "startOffset": 52, "endOffset": 56}, {"referenceID": 4, "context": "a destination in shortest time [9], paddling a ball [10] or winning a game that has a set of well defined rules [5],[1].", "startOffset": 112, "endOffset": 115}, {"referenceID": 0, "context": "a destination in shortest time [9], paddling a ball [10] or winning a game that has a set of well defined rules [5],[1].", "startOffset": 116, "endOffset": 119}, {"referenceID": 10, "context": "Learning of simple persistent tasks has traditionally been tackled using average reward reinforcement learning [11].", "startOffset": 111, "endOffset": 115}, {"referenceID": 11, "context": "Well known algorithms include R-learning [12] and Hlearning [13].", "startOffset": 41, "endOffset": 45}, {"referenceID": 12, "context": "Well known algorithms include R-learning [12] and Hlearning [13].", "startOffset": 60, "endOffset": 64}, {"referenceID": 13, "context": "However these methods work well with only unichain MDPs where every deterministic and stationary policy on that MDP contains only a single loop, also called a recurrent class of states [14].", "startOffset": 185, "endOffset": 189}, {"referenceID": 14, "context": "[15],[16] uses model-based approaches to learn policies that maximize the probability of satisfying a given linear temporal logic (LTL) formula.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[15],[16] uses model-based approaches to learn policies that maximize the probability of satisfying a given linear temporal logic (LTL) formula.", "startOffset": 5, "endOffset": 9}, {"referenceID": 16, "context": "Here we adopt the options framework [17] which abstracts each subtask as an MDP with a policy of its own, and a higher", "startOffset": 36, "endOffset": 40}, {"referenceID": 2, "context": "Especially for discretized representations of state and action spaces (used in many classical tabular methods [3]), the number of parameters (state value, action value, etc) increase exponentially with the size of the state/action space.", "startOffset": 110, "endOffset": 113}, {"referenceID": 17, "context": "Ideas along this line are called hierarchical reinforcement learning (HRL) in the literature, and a survey of advances in this area as well as the main approaches used are provided in [18].", "startOffset": 184, "endOffset": 188}, {"referenceID": 16, "context": "We base our work on the options framework developed in [17] for its ability to deal with temporally extended actions, which is an extremely helpful factor in the development of an algorithm that learns a policy that satisfies the complicated task specification given by an", "startOffset": 55, "endOffset": 59}, {"referenceID": 0, "context": "\u2022 S is a finite set of states; \u2022 A is a finite set of actions; \u2022 T : S\u00d7A\u00d7S \u2192 [0, 1] is the transition probability with T (s, a, s\u2032) being the probability of taking action a \u2208 A at state s \u2208 S and end up in state s\u2032 \u2208 S; \u2022 R : S \u00d7 A \u00d7 S \u2192 IR is the reward function with R(s, a, s\u2032) being the reward obtained by taking action a in s and end in s\u2032.", "startOffset": 77, "endOffset": 83}, {"referenceID": 18, "context": "learning [19].", "startOffset": 9, "endOffset": 13}, {"referenceID": 0, "context": "Here \u03b3 \u2208 [0,1] is a constant discount factor and is decayed with time (hence the exponent i) to put higher value on more recent rewards.", "startOffset": 9, "endOffset": 14}, {"referenceID": 19, "context": "The most famous one is perhaps the temporal difference learning algorithm (also called TD-learning [20]).", "startOffset": 99, "endOffset": 103}, {"referenceID": 0, "context": "where \u03b1 \u2208 [0, 1] is the learning rate.", "startOffset": 10, "endOffset": 16}, {"referenceID": 20, "context": "It is proven in [21] that if the choice of \u03b1 satisfies \u2211\u221e t \u03b1t = \u221e and \u2211\u221e t \u03b1 2 t < \u221e while every state and action are visited infinitely often, then Q(s, a) converges (denoted by Q(s, a)).", "startOffset": 16, "endOffset": 20}, {"referenceID": 0, "context": "\u03c0 : S \u2192 A is the option\u2019s policy (also called a flat policy) and \u03b2 : S \u2192 [0, 1] is the termination map defining the probability of termination of an option at each state.", "startOffset": 73, "endOffset": 79}, {"referenceID": 16, "context": "We refer readers to [17] for a detailed formulation of the options framework.", "startOffset": 20, "endOffset": 24}, {"referenceID": 21, "context": "Here we briefly present the necessary definitions of STL and refer interested readers to [22], [23], [24] for further details.", "startOffset": 89, "endOffset": 93}, {"referenceID": 22, "context": "Here we briefly present the necessary definitions of STL and refer interested readers to [22], [23], [24] for further details.", "startOffset": 95, "endOffset": 99}, {"referenceID": 23, "context": "Here we briefly present the necessary definitions of STL and refer interested readers to [22], [23], [24] for further details.", "startOffset": 101, "endOffset": 105}, {"referenceID": 24, "context": "policy learning algorithm, meaning that the learned policy is independent of the exploration scheme [25].", "startOffset": 100, "endOffset": 104}, {"referenceID": 16, "context": "To speed up the learning process, an intra-option update step is introduced which follows from the idea of intra-option value learning presented in [17].", "startOffset": 148, "endOffset": 152}, {"referenceID": 7, "context": "In addition, since robustness is a continuous measure of satisfiability, the resulting reward structure helps to speed up learning of the flat policies much like potential-based reward shaping [8].", "startOffset": 193, "endOffset": 196}, {"referenceID": 25, "context": "A policy is said to be hierarchically optimal if it achieves the highest cumulative reward among all policies consistent with the given hierarchy [26].", "startOffset": 146, "endOffset": 150}, {"referenceID": 16, "context": "In general, a hierarchical learning algorithm with a fixed set of options converges to a hierarchically optimal policy [17], which is the case for the HSTL-learning algorithm.", "startOffset": 119, "endOffset": 123}, {"referenceID": 0, "context": "The red dot in each figure denotes the state of termination defined by the termination map \u03b2i : S \u2192 [0, 1].", "startOffset": 100, "endOffset": 106}], "year": 2016, "abstractText": "Reinforcement learning has been applied to many interesting problems such as the famous TD-gammon [1] and the inverted helicopter flight [2]. However little effort has been put into developing methods to learn policies for complex persistent tasks and tasks that are time-sensitive. In this paper we take a step towards solving this problem by using signal temporal logic (STL) as task specification, and taking advantage of the temporal abstraction feature that the options framework provide. We show via simulation that a relatively easy to implement algorithm that combines STL and options can learn a satisfactory policy with a small number of training cases.", "creator": "LaTeX with hyperref package"}}}