{"id": "1606.07259", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jun-2016", "title": "Log-based Evaluation of Label Splits for Process Models", "abstract": "process mining techniques aim to extract insights in analyzing processes from event logs. one of the challenges in creating process mining is identifying interesting and meaningful event labels that contribute to a better understanding modeling of the process. our application area is mining data from smart homes for elderly, where the ultimate goal is to signal deviations from usual behavior tables and provide timely recommendations in order to extend the period of independent living. extracting individual process models showing user behavior is an important instrument in achieving this goal. however, the interpretation of sensor data at an appropriate abstraction level is not straightforward. for example, a passive motion sensor in a bedroom can be triggered by tossing and turning in bed or by getting up. we try to derive the actual activity depending on the context ( time, previous events, etc. ). in this paper finally we introduce the notion of label refinements, which subtly links more abstract event descriptions with their more refined counterparts. we present a statistical evaluation method to determine the usefulness of a label refinement for a given event log from a process perspective. based on data from smart estate homes, we show how our statistical evaluation method for label refinements can be used in practice. our method was able to select two label type refinements out of a partial set of candidate label refinements that both had a positive effect on model precision.", "histories": [["v1", "Thu, 23 Jun 2016 10:29:48 GMT  (1373kb,D)", "http://arxiv.org/abs/1606.07259v1", "Paper accepted at the 20th International Conference on Knowledge-Based and Intelligent Information &amp; Engineering Systems, to appear in Procedia Computer Science"]], "COMMENTS": "Paper accepted at the 20th International Conference on Knowledge-Based and Intelligent Information &amp; Engineering Systems, to appear in Procedia Computer Science", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["niek tax", "natalia sidorova", "reinder haakma", "wil m p van der aalst"], "accepted": false, "id": "1606.07259"}, "pdf": {"name": "1606.07259.pdf", "metadata": {"source": "CRF", "title": "Log-based Evaluation of Label Splits for Process Models", "authors": ["Niek Taxa", "Natalia Sidorovaa", "Reinder Haakmab", "Wil M. P. van der Aalsta"], "emails": ["n.tax@tue.nl"], "sections": [{"heading": null, "text": "Process mining techniques aim to extract insights in processes from event logs. One of the challenges in process mining is identifying interesting and meaningful event labels that contribute to a better understanding of the process. Our application area is mining data from smart homes for elderly, where the ultimate goal is to signal deviations from usual behavior and provide timely recommendations in order to extend the period of independent living. Extracting individual process models showing user behavior is an important instrument in achieving this goal. However, the interpretation of sensor data at an appropriate abstraction level is not straightforward. For example, a motion sensor in a bedroom can be triggered by tossing and turning in bed or by getting up. We try to derive the actual activity depending on the context (time, previous events, etc.). In this paper we introduce the notion of label refinements, which links more abstract event descriptions with their more refined counterparts. We present a statistical evaluation method to determine the usefulness of a label refinement for a given event log from a process perspective. Based on data from smart homes, we show how our statistical evaluation method for label refinements can be used in practice. Our method was able to select two label refinements out of a set of candidate label refinements that both had a positive effect on model precision.\nKeywords: Label refinement; Process Mining; Sensor Networks"}, {"heading": "1. Introduction", "text": "Process mining is a fast growing discipline that brings together knowledge and techniques from computational intelligence, data mining, process modeling and process analysis15. The process mining task is the automatic or semi-automatic analysis of events that are logged during process execution, where event records contain information on what was done, by whom, for whom, where, when, etc. Events are grouped into cases (process instances), e.g. per patient for a hospital log, or per insurance claim for an insurance company. An important task within process mining is process discovery, which focuses on extracting interpretable models\n\u2217Corresponding author. Tel.: +31-63-408-5760; E-mail address: n.tax@tue.nl\nar X\niv :1\n60 6.\n07 25\n9v 1\n[ cs\n.D B\n] 2\nof processes from event logs. One of the attributes of the events is usually used as its label. These event labels are then used as transition/activity labels in the process models created by process discovery algorithms.\nProcess mining takes its roots in the field of business process management, where the definition of labels for events is considered to be rather straightforward. In recent years, the application domain of process mining has broadened. A wide variety of event types can be used as input and analysis may be challenging. One of the most challenging application areas is LifeLogging, which focuses on acquisition and analysis of personal daily life data. LifeLogs amongst others combine data collected through mobile phones, wearable devices, and/or smart home sensors. The emergence of LifeLogging tools and the resulting increase in availability of activity data enable a process-centric analysis of human behavior14. The aim of process mining analysis on LifeLogging data is to find frequent activity patterns and represent them in a human interpretable process model. Such a process model could then also be used to\ndetect deviations from one\u2019s regular behavior. Process mining in the human behavior application domain closely relates to the field of activity recognition, which aims to detect human activities from sensors and finding patterns between human activities2. Process mining, however, aims to produce interpretable models that can provide insights by visually inspecting them. In contrast, most activity recognition techniques produce non-interpretable models.\nImagine an elderly person of whom we want to discover a process model describing his/her daily behavior. Events are generated by sensors, either periodically (e.g. by a temperature sensor or heart rate monitor), or triggered by some activity (e.g. motion). Table 1 shows an example log obtained by fusing data from such sensors. The dots indicate that only a fraction of the logged events are shown. Assigning meaningful labels to these events is not straightforward. A Bedroom motion event can be caused by different human activities, e.g. by Tossing & turning or by Getting up. In some cases it is necessary to distinguish between Tossing & turning and Getting up, for example when we aim to generate a timely reminder to take medication that needs to be taken before breakfast. Based on contextual information (e.g. a specific increase in heart rate, a time stamp, etc.), the distinction between the two types of activities might be identified, and each event with label Bedroom motion can be refined into either Tossing & turning or Getting up. The last column in Table 1 shows the desired event labels. Figure 1 shows a process model that can be deduced from such a log using existing process discovery techniques, like the ones from17,21.\nMany relabelings of Bedroom motion events are possible. Expert knowledge, data mining or machine learning techniques can be used to generate ideas for potential labeling functions. The goal of this labeling function is to give \u201csimilar\u201d events the same label. However, similarity is a relative notion, so the initially\nchosen labeling function can be too abstract or too fine-grained to generate an informative process model. Once a process discovery algorithm has been applied and a process model is obtained, one can assess whether the labeling function used on the original event log allowed the process discovery algorithm to discover an informative process model. However, it is computationally costly to apply process mining algorithms to multiple event logs generated from a single original event log using different event labeling functions with varying levels of abstraction. Therefore, we provide a statistical approach to evaluate label refinement usefulness in the context of process discovery that is based on significance testing of differences in event ordering relations.\nThe Fodina20 and the \u03b1\u2217 7 process discovery algorithms assume that there is one column in the event log that indicates the activity and refine this label based on a threshold of differentness on the event labels occurring directly before and after. In this paper we assume that the information what activity is performed is spread over multiple columns. We choose one column as primary activity column and refine the activity labels based on the other columns and temporal information. We validate whether a refinement makes sense from a process perspective by taking into account all temporal event information in the event log, using statistical testing and information gain. Evaluating splits based on information gain is a well-known approach in the area of decision tree learning11, where ground truth labels are available in contrast to the label refinement setting. Label refinements draw similarities with automatic learning of ontologies8 in the sense that both are concerned with inferring multiple levels of semantic interpretations from data. Ontology quality evaluation techniques1 can be used to evaluate (automatically inferred) ontologies, however these techniques are not process-centric, i.e., they do not take into account ordering relations between elements of the ontology in execution sequences.\nSection 2 gives formal definitions of label refinements, process models, and related concepts. In Section 3, we discuss when a label refinement is useful from a process mining perspective. A statistical method to evaluate the usefulness of a label refinement is described in Section 4. In Section 5 we discuss the results of the proposed method on a real life smart home data set. We draw conclusions in Section 6."}, {"heading": "2. Label Refinements & Process Models", "text": "In this section we introduce the notions related to event logs and relabeling functions for traces and then define the notions of refinements and abstractions. We also introduce the Petri net process model notation.\nWe use the usual sequence definition, and denote a sequence by listing its elements, e.g. we write \u3008a1, a2, . . . , an\u3009 for a (finite) sequence s : {1, . . . , n} \u2192 A of elements from some alphabet A, where s(i) = ai for any i \u2208 {1, . . . , n}. The length of a sequence s : {1, . . . , n} \u2192 A is |s| = n; s1s2 denotes the concatenation of sequences s1 and s2. A language L over an alphabet A is a set of sequences over A. Lp is the prefix closure of a language L (with L \u2286 Lp).\nAn event is the most elementary element of an event log. Let I be a set of event identifiers, T be a set of timestamps, and A1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 An be an attribute domain consisting of n attributes (e.g. resource, activity name, cost, etc.), each of a certain type. An event is a tuple e = (i, t, a1, . . . , an), with i \u2208 I, t \u2208 T , and (a1, . . . , an) \u2208 A1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 An. The event label of an event is the attribute set (a1 . . . , an); ei, et and ea respectively denote the identifier, the timestamp and label of event e. E = I\u00d7T \u00d7A1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7An is a universe of events overA1, . . . ,An. The lines of Table 1, where we do not consider the activity column for now, are events from an event universe over the event attributes sensor, address, and heart rate.\nEvents are often considered in the context of other events. We call E \u2286 E an event set, if E does not contain any events with the same event identifier. The events in Table 1 together form an event set. A trace \u03c3 is a finite sequence formed by the events from an event set E \u2286 E that respects the time ordering of events, i.e. for all k,m \u2208 N, 1 \u2264 k < m \u2264 |E|, we have: \u03c3(k)t \u2264 \u03c3(m)t. We define the universe of traces over event universe E, denoted \u03a3(E), as the set of all possible traces over E. We omit E in \u03a3(E) and use the shorter notation \u03a3 when the event universe is clear from the context.\nOften it is useful to partition an event set into smaller sets in which events belong together according to some criterion. We might for example be interested in discovering the typical behavior of households over the course of a day. In order to do so, we can e.g. group together events with the same address and the same day-part of the timestamp, as indicated by the horizontal lines in Table 1. For each of these event sets, we can construct a trace; time stamps define the ordering of events within the trace. For events of a trace having the\nsame time stamps, an arbitrary ordering can be chosen within a trace. An event partitioning function is a function ep : E \u2192 Tid that defines the partitioning of an arbitrary set of events E \u2286 E from a given event universe E into event sets E1, . . . , E j, . . . where each E j is the maximal subset of E such that for any e1, e2 \u2208 E j, ep(e1) = ep(e2); the value of ep shared by all the elements of E j defines the value of the trace attribute Tid. Note that complex, multidimensional trace attributes are also possible, i.e. a combination of the name of the person performing the event activity and the date of the event, so that every trace contains activities of one person during one day. The event sets obtained by applying an event partitioning can be transformed into traces (respecting the time ordering of events).\nAn event log L is a finite set of traces L \u2286 \u03a3(E). AL \u2286 A1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 An denotes the alphabet of event labels that occur in log L. The traces of a log are often transformed before doing further analysis: very detailed but not necessarily informative event descriptions are transformed into some informative and repeatable labels. For the labels of the log in Table 1, the heart rate values can be abstracted to low, normal, and high or the label can be redefined to a subset of the event attributes. Next to that, if the event partitioning function maps each event from Table 1 to its address and the day-part of the timestamp, these attributes (indicated in gray) become the trace attribute and can safely be removed from individual events. The new label is then defined as a combination of the sensor and abstracted heart rate values.\nAfter this relabeling step, some traces of the log can become identically labeled (the event id\u2019s would still be different). The information about the number of occurrences of a sequence of labels in an event log is highly relevant for process mining, since it allows differentiating between the main stream behavior of a process (frequently occurring behavioral patterns) and exceptional behavior.\nLet \u03a3(E) and \u03a3\u2032(E\u2032) be two universes of traces defined over event universes E,E\u2032. A function l : \u03a3\u2192 \u03a3\u2032 is a trace relabeling function if for all traces \u03c3, \u03b3 \u2208 \u03a3 such that if \u03c3 is a prefix of \u03b3, l(\u03c3) is a prefix of or equal to l(\u03b3). We lift l to event logs: for L \u2286 \u03a3, the relabeling l(L) is defined as {l(\u03c3)|\u03c3 \u2208 L}.\nOften, relabeling functions are defined using a more narrow approach: first defining an event relabeling function and then lifting that function to traces. In the context of business processes, event relabeling functions are mostly mere projections of events on the values of a single attribute, such as activity name. We consider a more general definition to allow for history-dependent interpretation of events, which is necessary in the context of LifeLogging. Prefix preservation requirement is necessary to allow for logging, compliance checking and other forms of analysis performed at run time.\nLet \u03a3, \u03a31, and \u03a32 be trace universes over E,E1,E2 respectively with E,E1,E2 being pairwise different. Let l1 : \u03a3 \u2192 \u03a31 and l2 : \u03a3 \u2192 \u03a32 be trace relabeling functions. Relabeling function l1 is a refinement of relabeling function l2, denoted by l1 l2, iff \u2200\u03c31,\u03c32\u2208\u03a3 : l1(\u03c31) = l1(\u03c32) =\u21d2 l2(\u03c31) = l2(\u03c32); l2 is then called an abstraction of l1. We call a refinement l1 of l2 a strict refinement, denoted by l1 \u227a l2, when \u2203\u03c31,\u03c32\u2208\u03a3 : l1(\u03c31) , l1(\u03c32) \u2227 l2(\u03c31) = l2(\u03c32). We call refinement l1 of l2 an equal length refinement, denoted by l1 = l2,when \u2200\u03c3 \u2208 \u03a3 : |l1(\u03c3)| = |l2(\u03c3)|.\nLet \u03a3,\u03a31 be trace universes over E,E1 respectively, l : \u03a3 \u2192 \u03a31 a trace relabeling function, and L1 be a language L1 \u2286 \u03a31 over E1. Trace concretization l\u22121 : \u03a31 \u2192 2\u03a3 is a function defined as l\u22121(\u03c31) = {\u03c3 \u2208 \u03a3|l(\u03c3) = \u03c31}, for each \u03c31 \u2208 \u03a31. Language concretization of L1 is language l\u22121(L1) = \u222a\u03c31\u2208L1 l\u22121(\u03c3\u2032).\nThe goal of process discovery is to discover a process model that represents the behavior seen in an event log. A frequently used process modeling notation in the process mining field is the Petri net12. Petri nets are directed bipartite graphs consisting of transitions and places, connected by arcs. Transitions represent activities, while places represent the enabling conditions of transitions. Labels are assigned to transitions to indicate the type of activity that they model. A special label \u03c4 is used to represent invisible transitions, which are only used for routing purposes and not recorded in the execution log.\nA labeled Petri net N = \u3008P,T, F, AM , `\u3009 is a tuple where P is a finite set of places, T is a finite set of transitions such that P \u2229 T = \u2205, F \u2286 (P \u00d7 T ) \u222a (T \u00d7 P) is a set of directed arcs, called the flow relation, AM is an alphabet of labels representing activities, with \u03c4 < AM being a label representing invisible events, and ` : T \u2192 AM \u222a {\u03c4} is a labeling function that assigns a label to each transition. For a node n \u2208 (P \u222a T ) we use \u2022n and n\u2022 to denote the set of input and output nodes of n, defined as \u2022n = {n\u2032|(n\u2032, n) \u2208 F} and n\u2022 = {n|(n, n\u2032) \u2208 F}. An example of a Petri net can be seen in Figure 1, where circles represent places and squares represent transitions.\nA state of a Petri net is defined by its marking M \u2208 NP being a multiset of places. A marking is graphically\ndenoted by putting M(p) tokens on each place p \u2208 P. A pair (N,M) is called a marked Petri net. State changes occur through transition firings. A transition t is enabled (can fire) in a given marking M if each input place p \u2208 \u2022t contains at least one token. Once a transition fires, one token is removed from each input place of t and one token is added to each output place of t, leading to a new marking M\u2032 defined as M\u2032 = M\u2212\u2022t+ t\u2022. A firing of a transition t leading from marking M to marking M\u2032 is denoted as M `(t)\u2212\u2192 M\u2032. M1 `(\u03c3)\u2212\u2192 M2 indicates that M2 can be reached from M1 through a firing sequence \u03c3\u2032 \u2208 AM\u2217. Many process modeling notations have formal executional semantics and define a language of accepting traces L. For Petri net N2 in Figure 2, L(N2) = {\u3008Bedroom motion,Livingroom Motion\u3009, \u3008Bedroom motion,Bedroom motion,Livingroom Motion\u3009, \u3008Bedroom motion, . . . ,Bedroom motion,Livingroom Motion\u3009}.\n3. On the Quality of Label Refinements for Process Mining\nProcess discovery algorithms discover a process model based on an event log, where event labels are obtained by applying an event relabeling function to an original log. The main quality metrics discovered process models are fitness, precision, generalization and simplicity15. Fitness represents the share of the behavior seen in the log that is allowed by the process model. Precision aims at narrowing the set of traces that belong to the language of the discovered process model, but was not observed in the event log. Generalization aims at preventing overfitting, and simplicity measures the \u201cunderstandability\u201d and \u201cwell-structuredness\u201d of models.\nIntuitively, an event relabeling function is better than another one if it improves the quality of the discovered\nmodel along these quality dimensions. However, the quality metrics are currently defined in such a way that only results of discovery algorithms applied to the very same log can be compared, while two different relabeling functions produce logs with different event labels. The Petri net N1 in Figure 2 has perfect precision and fitness for the event log with labels as shown in the refined label column of Table 1. At the same time, Petri net N2 has perfect fitness and precision for the event log with labels as in the sensor column of Table 1. However, Petri net N1 is useful for the purpose of sending a reminder message to take medicines after getting up, while Petri net N2 is not. This suggests that Petri net N1 is more precise than N2, but only with respect to the original log. Thus we have to make the comparison in the context of the original log. Suppose we have a set of events E, which is part of some universe of events E. We choose a case identifier and build an event log L from E. Then we choose relabeling functions l1 and l2 with l1 \u227a l2 and obtain L1 = l1(L) and L2 = l2(L) (see Figure 3). Applying process discovery to L1 and L2 results in two process models, which respectively accept languages L1 and L2. These languages cannot be compared directly, since they contain traces consisting of different event labels. Precision metrics look at \u201credundant\u201d traces in the mined models with respect to the log used as input for the discovery algorithm (see e.g.10,13). Using the inverse functions l\u221211 , l \u22121 2 , every trace of L1 and L2 can be mapped to a set of traces built from the events from E. Taking the union of the sets obtained with l\u221211 , l \u22121 2 over the traces of the languages, we obtain comparable languages\nand can conclude whether the relabeling function results in a model that is more precise with respect to the original log.\nFitness and simplicity of the models depend mostly on the performance of the process discovery algorithm, and not on the choice of the relabeling function. Precision defined in terms of events of the original universe E of events is however highly dependent on the appropriateness of the relabeling function: choosing a more refined relabeling function can increase the precision by eliminating the behavior that would be allowed in the model discovered with a more abstract relabeling function. Generalization can potentially suffer as the result of a higher precision."}, {"heading": "3.1. Label Refinement Quality", "text": "The comparison of the languages generated by models is not feasible due to its complexity; for many classes of process models, including Petri nets, the problem of language inclusion is just not decidable. Therefore, we need a different, practical approach to deciding on the usefulness of a relabeling function refinement. We start with discussing the usefulness by comparing the discovered models.\nConsider event log L, relabeling functions l1, l2, l3 such that l2 \u227a l1 \u2227 l3 \u227a l1, and event logs L1 = l1(L), L2 = l2(L), L3 = l3(L). Let the N1,N2,N3 in Figure 4 be the Petri nets obtained by applying process discovery to L1, L2, L3 respectively. The square inside the transition between places p3 and p4 indicates that it is a subprocess.\nWe can see that refinement l2 does not lead to a meaningful interpretation of b as b1 and b2, since the behavior of the model is not related to the choice between b1 and b2: transitions labeled with b1 and b2 have the same input and output places. Refinement l2 does not provide new insight and unnecessarily harms the understandability of the Petri net by creating more transitions then needed. On the other hand, l3 results in gain of precision, as L(N3), does not contain \u3008a, b1, e\u3009 and \u3008a, b2, d\u3009, while N1 does not distinguish between b1 and b2, which suggests that both types of traces are possible."}, {"heading": "4. Evaluation Method for Label Refinements for Process Models", "text": "In the previous section we showed that we can compare the usefulness of a label refinement by inspecting the Petri net obtained with process discovery. A naive way to evaluate label refinement would be to apply process discovery to all possible label refinements. The number of possible label refinements to consider can however be large and process discovery is a computationally expensive task. Therefore, this naive approach quickly becomes computationally infeasible. We now present a way to estimate the usefulness of a label refinement based on statistics and log relations.\nAlgorithm 1 shows the steps of the label refinements evaluation method. The evaluation method consists of an entropy-based component that measures whether a label refinement makes the log statistics more unbalanced, and a statistical test that tests whether there is a label statistic that tests whether the label refinement makes a statistically significant difference to at least one of the log statistics. In the following two sections we described the entropy-based measure and the statistical testing respectively."}, {"heading": "4.1. Log Statistics", "text": "Event ordering patterns are crucial to most process discovery algorithms. Table 2 provides an overview of well-known log-based ordering relations described in process discovery literature17,18,22,21 and provides\nexamples. Let L be an event log. Let b, c \u2208 AL. Formal definitions of these log-based ordering statistics are as follows:\n\u2022 #+L,>(b, c) is the number of occurrences of b in the traces of L that are directly followed by c, i.e. in some \u03c3 \u2208 L, i \u2208 {1, . . . , |\u03c3|} we have [\u03c3(i)]a = b and [\u03c3(i + 1)]a = c (direct successor), #\u2212L,>(b, c) is the number of occurrences of b which are not directly followed by c; \u2022 #+L,>>(b, c) and #\u2212L,>>(b, c) is the number of occurrences of b that are, respectively, are not, followed by c: for a trace \u03c3 \u2208 L and i \u2208 {1, . . . , |\u03c3|}, and [\u03c3(i)]a = [\u03c3(i + 2)]a = b and [\u03c3(i + 1)]a = c and b , c (length-two loops); \u2022 #+L,>>>(b, c) and #\u2212L,>>>(b, c) is the number of occurrences of b that are, respectively are not, eventually\nfollowed by c: for a trace \u03c3 \u2208 L, i, j \u2208 N with i < j, [\u03c3(i)]a = b and [\u03c3( j)]a = c (direct or indirect successor).\nIn the general sense, let #+L,s(b, c) and # \u2212 L,s(b, c) be the count of the number of b\u2019s that do, respectively do not, satisfy relation s in log L with respect to c. Let L be an event log. Let l1 and l2 be two relabeling functions that are to be compared, such that l2 \u227a= l1. Let L1 = l1(L) and L2 = l2(L). Let l1 and l2 have the property {a1, a2 \u2208 AL2 )|\u2203\u03c31,\u03c32\u2208L : l1(\u03c31) = \u03bba \u2227 l1(\u03c32) = \u03bb\u2032a \u2227 l2(\u03c31) = \u03b6a1 \u2227 l2(\u03c32) = \u03b6\u2032a2} , \u2205, that is, l2 refines activity a into distinct activities a1 and a2. The difference in control flow between a1 and a2 can be expressed as the dissimilarity in log-based ordering statistics between event label a1 and b \u2208 AL2 \\ {a1, a2} on the one hand, and a2 and b on the other hand. Each log-based ordering statistics of a1 and a2 with regard to any other activity b can be formulated in the form of a contingency table, as shown in Table 3."}, {"heading": "4.2. Information Gain", "text": "The binary entropy function, Hb(p) = \u2212p log2 p \u2212 (1 \u2212 p) log2(1 \u2212 p), where 0 log2 0 = 0, is a measure of uncertainty. Applied on a log statistic, the binary entropy function represents a degree of nondeterminism. Nondeterministic, unbalanced, log statistics are a helpful to process discovery algorithms that operate of log statistics, as it provides low uncertainty to the mining algorithm. Low entropy in the log statistics indicate high predictability of the process, making it easier for process discovery algorithms to return a sensible process model.\nConsider the contingency tables in Table 4, based on log statistics obtained from Table 1 between the events labeled Tossing & turning and Getting up and the events labeled Living room motion. On the right hand side of the table, separated by the bar, are the log statistics of the before-split label in the before-split log. All five events with label Getting up directly precede an event with label Living room motion, while all sixteen events with label Tossing & turning are not directly preceded by Living room motion. Furthermore, all events with refined labels do not directly or eventually follow an event with label Living room motion, and all events with refined labels do eventually precede an event with label Living room motion.\nLog statistics with a high degree of non-determinism, like the directly precedes statistic of the bedroom\nmotion events before the split, might confuse a mining algorithm as there is no clear structure here: the Bedroom motion event might directly precede Livingroom motion, but most of the time it does not. After the split we see a completely deterministic directly precedes statistic, where Tossing & turning never and Getting up always directly precedes Livingroom motion. This increased determinism is reflected by the entropy of the directly precedes statistic before and after the split. Before the split we have \u2212 55+16 log2 5 5+16 \u2212 16 5+16 log2 16 5+16 = 0.7919 bit of entropy in the directly precedes statistic, compared to \u2212 00+16 log2 0 0+16 \u2212 16 0+16 log2 16\n0+16 = 0 bit of entropy for Tossing & turning and \u2212 00+5 log2 0 0+5 \u2212 5 0+5 log2 5 0+5 = 0 bit of entropy for Getting up. The conditional entropy of the log statistic after the split is the weighted average of the entropy of the labels created in the split, which is \u2212 1621 0 \u00d7 5 21 0 = 0. The information gain of this label split with regard to the directly precedes Livingroom motion statistic is equal to the total entropy of the log statistic prior to the split, minus the conditional entropy after the split, this 0.7919 \u2212 0 = 0.7919. Relative information gain6 is a metric that provides insight in the ratio of bits of entropy reduced by a refinement, and can be calculated by dividing the information gain by the before-split entropy. The relative information gain of the directly precedes Livingroom motion statistic is 0.79190.7919 = 1. Figure 2 shows the effect of this label refinement on the resulting Petri net obtained by process discovery.\nSo far we have calculated the Relative information gain for a single log statistic. A label refinement however can have impact on multiple log statistics at once. We need a measure that integrates the information gain values of all log statistics to express the quality of a label refinement with respect to the determinism of the log statistics. We therefore sum over the entropy of all log statistics before the label split to obtain the total before-split entropy. We sum over the conditional entropies of all log statistics after the label split to obtain the total after-split entropy. Information Gain and Relative information gain are calculated as before. We let relative in f ormation gain(L1, L2) be the function that returns the Relative information gain based on the pre-split log L1 and post-split log L2, where the set of refined label pairs in L2 from which the log statistics are used corresponds to {a1, a2 \u2208 AL2 |\u2203\u03c31,\u03c32\u2208L : l1(\u03c31) = \u03bba \u2227 l1(\u03c32) = \u03bb \u2032 a\u2227, with the a the corresponding label in L1."}, {"heading": "4.3. Statistical Testing", "text": "Relative information gain can be high by chance for a refinement when the generated refined labels are infrequent. Statistical testing of log statistic differences in addition to calculating relative information gain enables us to distinguish between information gain obtained by chance and actual information gain. Fisher\u2019s exact test5 is a statistical significance test for the analysis of contingency tables. When applied to the table above, it calculates a p-value for the null hypothesis that a1 and a2 events are equally likely to hold log relation s with regard to label b. Fisher\u2019s exact test assumes individual observations to be independent and row and column totals to be fixed. Independence of individual observations might be affected by the grouping\nAlgorithm 1 Algorithm of the label refinement statistical evaluation method Input: Event log L, Relabeling functions l1 and l2 such that l2 \u227a= l1, Output: the Relative information gain of l1 w.r.t l2, Parameters: Set of log-based ordering statistics S, Significance level \u03b1.\nall significant different = true; L1=l1(L); L2=l2(L); split set = {a1, a2 \u2208 A(L2)|\u2203\u03c31 ,\u03c32\u2208L : l1(\u03c31) = \u03bba \u2227 l1(\u03c32) = \u03bb \u2032 a\u2227 l2(\u03c31) = \u03b6a1 \u2227 l2(\u03c32) = \u03b6 \u2032 a2}; For each a1, a2 \u2208 split set: pair signi f icant di f f erent = false; For each {b \u2208 A(L2) \\ {a1, a2}}:\nFor each s \u2208 S: p = f isher test(#+L2 ,s(a1, b), # \u2212 L2 ,s (a1, b), #+L2 ,s(a2, b), # \u2212 L2 ,s\n(a2, b)); If(p < \u03b1) pair significant different = true;\nIf(!pair signi f icant di f f erent) all signi f icant di f f erent = false; If(all signi f icant di f f erent) return relative in f ormation gain(L1, L2); Else return 0.0;\nof events in traces. In this paper we consider individual observations independence to be working assumption. The test was designed for experiments where both the row and column totals where conditioned. In our setting, the column totals are conditioned by the relabeling function, as the number of events of each label depends on the relabeling. The row totals however, are not conditioned and are an observation. Fisher\u2019s exact test is not strictly speaking exact when one or both of the row or column totals are unconditioned, but will instead be slightly conservative9, meaning that the probability of the p-value being less than or equal to the significance level when the null hypothesis is true is less than the significance level. Fisher\u2019s exact test is computationally expensive for large numbers of observations. For large sample sizes, either the \u03c72 test of independence or the G-test of independence can be used, which are both found to be inaccurate for small sample sizes. A popular guideline is to not use the \u03c72 test of independence or the G-test for samples sizes less than one thousand9. The computational complexity of the evaluation procedure is O(|S | \u00d7 |A(L)| \u00d7 |split set|). Many process discovery algorithms are exponential in the number of labels16. Based on this we can conclude that statistical evaluation of label refinements is computationally less expensive than checking label refinement usefulness through process discovery."}, {"heading": "4.4. Correcting for Multiple Testing", "text": "The computational complexity indicates the number of hypothesis tests performed. When a large set of potential label refinements is evaluated, the evaluation method described is susceptible to the repeated testing problem. The larger the set of hypotheses tested, the higher the probability of incorrectly rejecting the null hypothesis in at least one of the hypothesis tests. Applying a Bonferroni correction3,4 to the hypothesis tests performed in the statistical evaluation method of label refinements keeps the familywise error rate constant."}, {"heading": "4.5. Example Case", "text": "Consider the event log in Table 1 and imagine a scenario where a home care worker knows from experience that the elderly always sets his alarm clock at 8:30 AM. Based on such expert knowledge we are able to define a label refinement such that all bedroom movements after 8:30 AM are considered as Getting up events, while all other bedroom movements are considered to be Tossing & turning events. The rightmost column shows the refined labels obtained through this expert relabeling function. To evaluate the usefulness of this label refinement from a process model point of view, we apply the statistical evaluation method described in Section 4. As parameters we set the significance level threshold to the frequently used value of 0.01.\nTable 5 shows the outcome of the statistical tests performed as part of the label refinement usefulness evaluation. Four hypothesis tests have been performed, after Bonferroni correction each hypothesis test is tested at significance level 0.014 = 0.0025. The direct following statistic of Tossing & turning and Getting up with Living room motion is statistically significantly given this significance level. The label refinement constructed with expert knowledge is found to be a useful label refinement through statistical evaluation."}, {"heading": "5. Real life evaluation", "text": "We apply our label refinement evaluation method to a set of candidate label refinements on the Van Kasteren smart home environment data set19 in order to illustrate the effects of label splits in the context of process mining of real life processes. The van Kasteren data set consists of 1285 events divided over fourteen different sensors. Events are segmented in days from midnight to midnight, to define cases in the event log. The candidate set of label refinements consists of splitting each of the fourteen event types t into two event types based on the their time in the day, such that t events where the time since the start of the day is smaller than the median for t are separated from t events where it is equal to or larger than the median. Figure 5 shows the dependency graph obtained with the Heuristics Miner21. A dependency graph depicts causal relations between activities that meet a certainty threshold. A dependency graph can be directly converted into a Petri net21, however, for the sake of readability we included the dependency graphs instead of the Petri nets. The precision10 of the Petri net corresponding to Figure 5 is 0.56 on a scale from 0 to 1.\nOut of the fourteen candidate label refinements, two label refinements are selected by our approach. The first label refinement found is the split of Hall-bathroom door into Hall-bathroom door 1 and Hall-bathroom door 2, with a timestamp below, respectively above or equal to the median time in the day of Hall-bathroom door events. The resulting labels of this refinement are statistically significantly different in terms of their eventually follows relation with Front door (p-value: 3.06 \u00d7 10\u221226) and their eventually follows relation with Plates cupboard (p-value: 3.66 \u00d7 10\u221223) and Microwave 1.85 \u00d7 1024. The relative information gain on the whole event log caused by this label refinement is 3.47%. Figure 6 shows a Heuristics Net mined with the Heuristics Miner21 on the van Kasteren log with the refined Hall-bathroom door label. The model discovered on the log with this label refinement (Figure 6) has a precision of 0.69, up from 0.53 without the refinement. The increased precision shows that the label refinement helps restricting the share of behavior allowed by the model that is not covered by the event log. The second label refinement found is the split of Cups cupboard into Cups cupboard 1 and Cups cupboard 2. The resulting labels of this refinement are statistically significantly different in terms of their eventually precedes relation with Groceries cupboard (p-value: 2.53 \u00d7 10\u221234) and their eventually follows relation with Fridge (p-value: 2.2 \u00d7 10\u221222). The relative information gain on the whole event log caused by this label refinement is 0.53%. Figure 7 shows a Heuristics Net mined with the Heuristics Miner on the van Kasteren log with the refined Cups cupboard label, of which the precision is 0.61, up to 0.53 without the refinement. The label refinement with higher information gain also results in a higher improvement in terms of precision, which is in agreement with the intuition that more deterministic log statistics help the miner in mining structured, non-flower-like, models."}, {"heading": "6. Conclusion & Future Work", "text": "We have provided a theoretical and conceptual notion of when label refinements and abstractions are useful from a process discovery point of view. Based on this notion of usefulness, we have shown a framework based on statistics and information theory to evaluate the usefulness of a label refinement or abstraction. In addition, we have shown the applicability of this statistical framework through a real life smart home case, where our method selected two label refinements out of a larger candidate set that increased the precision of the resulting process model. Methods for automatic inference of useful label refinements from event attributes are still to be explored. Such methods may generate a set of candidate label refinements, after which the statistical evaluation method described in this paper can be used to select the most promising label refinement from a set of candidate label refinements."}], "references": [{"title": "A survey of ontology evaluation techniques", "author": ["J. Brank", "M. Grobelnik", "D. Mladenic"], "venue": "In Proceedings of the conference on data mining and data warehouses, pages 166\u2013170,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Sensor-based activity recognition", "author": ["L. Chen", "J. Hoey", "C. Nugent", "D. Cook", "Z. Yu"], "venue": "IEEE Transactions on Systems, Man and Cybernetics Part C: Applications and Reviews, 42(6):790\u2013808,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Estimation of the medians for dependent variables", "author": ["O.J. Dunn"], "venue": "The Annals of Mathematical Statistics, 30(1):192\u2013197,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1959}, {"title": "Multiple comparisons among means", "author": ["O.J. Dunn"], "venue": "Journal of the American Statistical Association, 56(293):52\u201364,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1961}, {"title": "Statistical methods for research workers", "author": ["R.A. Fisher"], "venue": "Number 5. Genesis Publishing Pvt Ltd,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1934}, {"title": "On information and sufficiency", "author": ["S. Kullback", "R.A. Leibler"], "venue": "The Annals of Mathematical Statistics, 22(1):79\u201386,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1951}, {"title": "Process mining: Extending \u03b1-algorithm to mine duplicate tasks in process logs", "author": ["J. Li", "D. Liu", "B. Yang"], "venue": "In Advances in Web and Network Technologies, and Information Management, volume 4537 of LNCS, pages 396\u2013407. Springer Berlin Heidelberg,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Ontology learning for the semantic web, volume 665", "author": ["A. Maedche"], "venue": "Springer Science & Business Media,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Handbook of biological statistics, volume 2", "author": ["J.H. McDonald"], "venue": "Sparky House Publishing Baltimore, MD,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "A fresh look at precision in process conformance", "author": ["J. Mu\u00f1oz Gama", "J. Carmona"], "venue": "In Business Process Management, volume 6336 of LNCS, pages 211\u2013226. Springer Berlin Heidelberg,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "C4", "author": ["J.R. Quinlan"], "venue": "5: programs for machine learning. Elsevier,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Lectures on Petri nets I: basic models: advances in Petri nets, volume 1491", "author": ["W. Reisig", "G. Rozenberg"], "venue": "Springer Science & Business Media,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1998}, {"title": "and W", "author": ["A. Rozina"], "venue": "M. P. van der Aalst. Conformance checking of processes based on monitoring real behavior. Information Systems, 33(1):64\u201395,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2008}, {"title": "Discovery of personal processes from labeled sensor data\u2013an application of process mining to personalized health care", "author": ["T. Sztyler", "J. V\u00f6lker", "J. Carmona", "O. Meier", "H. Stuckenschmidt"], "venue": "In Proceedings of the International Workshop on Algorithms & Theories for the Analysis of Event Data, ATAED, pages 22\u201323,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2015}, {"title": "Process mining: discovery, conformance and enhancement of business processes", "author": ["W.M.P. van der Aalst"], "venue": "Springer Science & Business Media,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "Distributed process discovery and conformance checking", "author": ["W.M.P. van der Aalst"], "venue": "In Fundamental Approaches to Software Engineering,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}, {"title": "Workflow mining: Discovering process models from event logs", "author": ["W.M.P. van der Aalst", "A.J.M.M. Weijters", "L. Maruster"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2004}, {"title": "Multi-phase process mining: Building instance graphs", "author": ["B.F. van Dongen", "W.M.P. van der Aalst"], "venue": "In Conceptual Modeling\u2013ER 2004,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2004}, {"title": "Accurate activity recognition in a home setting", "author": ["T. van Kasteren", "A. Noulas", "G. Englebienne", "B. Kr\u00f6se"], "venue": "In Proceedings of the 10th International Conference on Ubiquitous Computing,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2008}, {"title": "Advanced in Process Mining: Artificial Negative Events and Other Techniques", "author": ["S.K. Vanden Broucke"], "venue": "PhD thesis, KU Leuven,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2014}, {"title": "Flexible heuristics miner (fhm)", "author": ["A.J.M.M. Weijters", "J.T.S. Ribeiro"], "venue": "In Proceedings of the 2011 IEEE Symposium on Computational Intelligence and Data Mining, pages 310\u2013317. IEEE,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Detecting implicit dependencies between tasks from event logs", "author": ["L. Wen", "J. Wang", "J. Sun"], "venue": "Frontiers of WWW Research and Development-APWeb 2006, pages 591\u2013603,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [], "year": 2016, "abstractText": "Process mining techniques aim to extract insights in processes from event logs. One of the challenges in process mining is identifying interesting and meaningful event labels that contribute to a better understanding of the process. Our application area is mining data from smart homes for elderly, where the ultimate goal is to signal deviations from usual behavior and provide timely recommendations in order to extend the period of independent living. Extracting individual process models showing user behavior is an important instrument in achieving this goal. However, the interpretation of sensor data at an appropriate abstraction level is not straightforward. For example, a motion sensor in a bedroom can be triggered by tossing and turning in bed or by getting up. We try to derive the actual activity depending on the context (time, previous events, etc.). In this paper we introduce the notion of label refinements, which links more abstract event descriptions with their more refined counterparts. We present a statistical evaluation method to determine the usefulness of a label refinement for a given event log from a process perspective. Based on data from smart homes, we show how our statistical evaluation method for label refinements can be used in practice. Our method was able to select two label refinements out of a set of candidate label refinements that both had a positive effect on model precision.", "creator": "LaTeX with hyperref package"}}}