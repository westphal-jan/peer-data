{"id": "1608.04207", "review": {"conference": "iclr", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Aug-2016", "title": "Fine-grained Analysis of Sentence Embeddings Using Auxiliary Prediction Tasks", "abstract": "there is a lot of research building interest in encoding variable variable length message sentences into fixed length vectors, in a way that preserves the sentence meanings. two common inference methods include representations based on averaging word vectors, and representations based on the hidden states of their recurrent neural networks such as lstms. the sentence vectors themselves are used as features for subsequent symbolic machine learning tasks later or for pre - training therapy in the context of deep learning. however, surprisingly not much is known about the properties that are encoded in these sentence representations and about assessing the language information they capture. we propose a framework that facilitates better collaborative understanding behaviour of the encoded representations. we define prediction tasks around isolated aspects of sentence structure ( namely sentence length, word content, and word boundary order ), and score representations by allowing the ability to train a classifier procedure to solve each phrase prediction task when using the representation as input. separately we demonstrate the potential ecological contribution of the approach by analyzing how different sentence representation mechanisms. the analysis sheds light on the relative strengths of different sentence embedding methods with respect to these low level tree prediction tasks, and on the effect of the encoded vector's dimensionality on the resulting representations.", "histories": [["v1", "Mon, 15 Aug 2016 08:51:38 GMT  (653kb,D)", "http://arxiv.org/abs/1608.04207v1", null], ["v2", "Sun, 11 Sep 2016 13:22:13 GMT  (653kb,D)", "http://arxiv.org/abs/1608.04207v2", null], ["v3", "Thu, 9 Feb 2017 06:58:50 GMT  (225kb,D)", "http://arxiv.org/abs/1608.04207v3", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["yossi adi", "einat kermany", "yonatan belinkov", "ofer lavi", "yoav goldberg"], "accepted": true, "id": "1608.04207"}, "pdf": {"name": "1608.04207.pdf", "metadata": {"source": "CRF", "title": "Fine-grained Analysis of Sentence Embeddings Using Auxiliary Prediction Tasks", "authors": ["Yossi Adi", "Einat Kermany", "Yonatan Belinkov", "Ofer Lavi", "Yoav Goldberg"], "emails": ["oferl}@il.ibm.com", "belinkov@mit.edu", "yossiadidrum}@gmail.com"], "sections": [{"heading": null, "text": "We propose a framework that facilitates better understanding of the encoded representations. We define prediction tasks around isolated aspects of sentence structure (namely sentence length, word content, and word order), and score representations by the ability to train a classifier to solve each prediction task when using the representation as input. We demonstrate the potential contribution of the approach by analyzing different sentence representation mechanisms. The analysis sheds light on the relative strengths of different sentence embedding methods with respect to these low level prediction tasks, and on the effect of the encoded vector\u2019s dimensionality on the resulting representations."}, {"heading": "1 Introduction", "text": "While sentence embeddings or sentence representations play a central role in recent deep learning ap-\nproaches to NLP, little is known about the information that is captured by different sentence embedding learning mechanisms. We propose a methodology facilitating fine-grained measurement of some of the information encoded in sentence embeddings, as well as performing fine-grained comparison of different sentence embedding methods.\nIn sentence embeddings, sentences, which are variable-length sequences of discrete symbols, are encoded into fixed length continuous vectors that are then used for further prediction tasks. A simple and common approach is producing word-level vectors using, e.g., word2vec (Mikolov et al., 2013a; Mikolov et al., 2013b), and summing or averaging the vectors of the words participating in the sentence. This continuous-bag-of-words (CBOW) approach disregards the word order in the sentence.1\nAnother approach is the encoder-decoder architecture, producing models also known as sequenceto-sequence models (Sutskever et al., 2014; Cho et al., 2014; Bahdanau et al., 2014, inter alia). In this architecture, an encoder network (e.g. an LSTM) is used to produce a vector representation of the sentence, which is then fed as input into a decoder network that uses it to perform some prediction task (e.g. recreate the sentence, or produce a translation of it). The encoder and decoder networks are trained jointly in order to perform the final task.\nSome systems (for example in machine transla-\n1We use the term CBOW to refer to a sentence representation that is composed of an average of the vectors of the words in the sentence, not to be confused with the training method by the same name which is used in the word2vec algorithm.\nar X\niv :1\n60 8.\n04 20\n7v 1\n[ cs\n.C L\n] 1\n5 A\ntion) train the system end-to-end, and use the trained system for prediction (Bahdanau et al., 2014). Such systems do not generally care about the encoded vectors, which are used merely as intermediate values. However, another common case is to train an encoder-decoder network and then throw away the decoder and use the trained encoder as a general mechanism for obtaining sentence representations. For example, an encoder-decoder network can be trained as an auto-encoder, where the encoder creates a vector representation, and the decoder attempts to recreate the original sentence (Li et al., 2015). Similarly, Kiros et al. (2015) train a network to encode a sentence such that the decoder can recreate its neighboring sentences in the text. Such networks do not require specially labeled data, and can be trained on large amounts of unannotated text. As the decoder needs information about the sentence in order to perform well, it is clear that the encoded vectors capture a non-trivial amount of information about the sentence, making the encoder appealing to use as a general purpose, stand-alone sentence encoding mechanism. The sentence encodings can then be used as input for other prediction tasks for which less training data is available (Dai and Le, 2015). In this work we focus on these \u201cgeneral purpose\u201d sentence encodings.\nThe resulting sentence representations are opaque, and there is currently no good way of comparing different representations short of using them as input for different high-level semantic tasks (e.g. sentiment classification, entailment recognition, document retrieval, question answering, sentence similarity, etc.) and measuring how well they perform on these tasks. This is the approach taken by Li et al. (2015), ?) and Kiros et al. (2015). This method of comparing sentence embeddings leaves a lot to be desired: the comparison is at a very coarse-grained level, does not tell us much about the kind of information that is encoded in the representation, and does not help us form generalizable conclusions.\nOur Contribution We take a first step towards opening the black box of vector embeddings for sentences. We propose a methodology that facilitates comparing sentence embeddings on a much finer-grained level, and demonstrate its use by an-\nalyzing and comparing different sentence representations. We analyze sentence representation methods that are based on LSTM auto-encoders and the simple CBOW representation produced by averaging word2vec word embeddings. For each of CBOW and LSTM auto-encoder, we compare different numbers of dimensions, exploring the effect of the dimensionality on the resulting representation. We also provide some comparison to the skipthought embeddings of Kiros et al. (2015).\nIn this work, we focus on what are arguably the three most basic characteristics of a sequence: its length, the items within it, and their order. We investigate different sentence representations based on the capacity to which they encode these aspects. Our analysis of these low-level properties leads to interesting, actionable insights, exposing relative strengths and weaknesses of the different representations.\nLimitations Focusing on low-level sentence properties also has limitations: The tasks focus on measuring the preservation of surface aspects of the sentence and do not measure syntactic and semantic generalization abilities; the tasks are not directly related to any specific downstream application (although the properties we test are important factors in many tasks \u2013 knowing that a model is good at predicting length and word order is likely advantageous for syntactic parsing, while models that excel at word content are good for text classification tasks). Dealing with these limitations requires a complementary set of auxiliary tasks, which is outside the scope of this study and is left for future work.\nThe study also suffers from the general limitations of empirical work: we do not prove general theorems but rather measure behaviors on several data points and attempt to draw conclusions from these measurements. There is always the risk that our conclusions only hold for the datasets on which we measured, and will not generalize. However, we do consider our large sample of sentences from Wikipedia to be representative of the English language, at least in terms of the three basic sentence properties that we study.\nSummary of Findings Our analysis reveals the following insights regarding the different sentence\nembedding methods:\n\u2022 Sentence representations based on averaged word vectors are surprisingly effective, and encode a non-trivial amount of information regarding word order and sentence length.\n\u2022 LSTM auto-encoders are more effective at encoding word order than word content.\n\u2022 Increasing the number of dimensions benefits some tasks more than others.\n\u2022 Adding more hidden units sometimes degrades the encoders\u2019 ability to encode word content. This degradation is not correlated with the BLEU scores of the decoder, suggesting that BLEU over the decoder output is sub-optimal for evaluating the encoders\u2019 quality.\n\u2022 LSTM encoders trained as auto-encoders do not rely on oredering patterns in the training sentences when encoding novel sentences, while the skipthought encoders do rely on such patterns."}, {"heading": "2 Related Work", "text": "Word-level distributed representations have been analyzed rather extensively, both empirically and theoretically, for example by Baroni et al. (2014), Levy and Goldberg (2014) and Levy et al. (2015). In contrast, the analysis of sentence-level representations has been much more limited. One common approach is to compare the performance of the sentence embeddings on down-stream tasks (Hill et al., 2016). While the resulting analysis reveals differences in performance of different models, it does not adequately explain what kind of linguistic properties of the sentence they capture. Other studies analyze the hidden units learned by neural networks when training a sentence representation model (Elman, 1991; Karpathy et al., 2015; Ka\u0301da\u0301r et al., 2016). This approach often associates certain linguistic aspects with certain hidden units. Ka\u0301da\u0301r et al. (2016) propose a methodology for quantifying the contribution of each input word to a resulting GRU-based encoding. These methods depend on the specific learning model and cannot be applied to arbitrary representations. Moreover, it is still not clear what is captured by the final sentence embeddings.\nOur work is orthogonal and complementary to the previous efforts: we analyze the resulting sentence embeddings by devising auxiliary prediction tasks for core sentence properties. The methodology we porpose is general and can be applied to any sentence representation model."}, {"heading": "3 Approach", "text": "We aim to inspect and compare encoded sentence vectors in a task-independent manner. The main idea of our method is to focus on isolated aspects of sentence structure, and design experiments to measure to what extent each aspect is captured in a given representation.\nIn each experiment, we formulate a prediction task. Given a sentence representation method, we create training data and train a classifier to predict a specific sentence property (e.g. their length) based on their vector representations. We then measure how well we can train a model to perform the task. The basic premise is that if we cannot train a classifier to predict some property of a sentence based on its vector representation, then this property is not encoded in the representation (or rather, not encoded in a useful way, considering how the representation is likely to be used).\nThe experiments in this work focus on low-level properties of sentences \u2013 the sentence length, the identities of words in a sentence, and the order of the words. We consider these to be the core elements of sentence structure. Generalizing the approach to higher-level semantic and syntactic properties holds great potential, which we hope will be explored in future work, by us or by others."}, {"heading": "3.1 The Prediction Tasks", "text": "We now turn to describe the specific prediction tasks. We use lower case italics (s, w) to refer to sentences and words, and boldface to refer to their corresponding vector representations (s, w). When more than one element is considered, they are distinguished by indices (w1, w2, w1, w2).\nOur underlying corpus for generating the classification instances consists of 200,000 Wikipedia sentences, where 150,000 sentences are used to generate training examples, and 25,000 sentences are used for each of the test and development examples.\nThese sentences are a subset of the training set that was used to train the original sentence encoders. The idea behind this setup is to test the models on what are presumably their best embeddings.\nLength Task This task measures to what extent the sentence representation encodes its length. Given a sentence representation s \u2208 Rk, the goal of the classifier is to predict the length (number of words) in the original sentence s. The task is formulated as multiclass classification, with eight output classes corresponding to binned lengths.2 The resulting dataset is reasonably balanced, with a majority class (lengths 5-8 words) of 5,182 test instances and a minority class (34-70) of 1,084 test instances. Predicting the majority class results in classification accuracy of 20.1%.\nWord-content Task This task measures to what extent the sentence representation encodes the identities of words within it. Given a sentence representation s \u2208 Rk and a word representation w \u2208 Rd, the goal of the classifier is to determine whether w appears in the s, with access to neither w nor s. This is formulated as a binary classification task, where the input is the concatenation of s and w.\nTo create a dataset for this task, we need to provide positive and negative examples. Obtaining positive examples is straightforward: we simply pick a random word from each sentence. For negative examples, we could pick a random word from the entire corpus. However, we found that such a dataset tends to push models to memorize words as either positive or negative words, instead of finding their relation to the sentence representation. Therefore, for each sentence we pick as a negative example a word that appears as a positive example somewhere in our dataset, but does not appear in the given sentence. This forces the models to learn a relationship between word and sentence representations. We generate one positive and one negative example from each sentence. The dataset is balanced, with a baseline accuracy of 50%.\nWord-order Task This task measures to what extent the sentence representation encodes word order. Given a sentence representation s \u2208 Rk and the\n2We use the bins (5-8), (9-12), (13-16), (17-20), (21-25), (26-29), (30-33), (34-70).\nrepresentations of two words that appear in the sentence, w1,w2 \u2208 Rd, the goal of the classifier is to predict whether w1 appears before or after w2 in the original sentence s. Again, the model has no access to the original sentence and the two words. This is formulated as a binary classification task, where the input is a concatenation of the three vectors s, w1 and w2.\nFor each sentence in the corpus, we simply pick two random words from the sentence as a positive example. For negative examples, we flip the order of the words. We generate one positive and one negative example from each sentence. The dataset is balanced, with a baseline accuracy of 50%."}, {"heading": "4 Sentence Representation Models", "text": "Given a sentence s = {w1, w2, ..., wN} we aim to find a sentence representation s using an encoder:\nENC : s = {w1, w2, ..., wN} 7\u2192 s \u2208 Rk\nThe encoding process usually assumes a vector representation wi \u2208 Rd for each word in the vocabulary. In general, the word and sentence embedding dimensions, d and k, need not be the same. The word vectors can be learned together with other encoder parameters or pre-trained. Below we describe different instantiations of ENC.\nContinuous Bag-of-words (CBOW) This simple yet effective text representation consists of performing element-wise averaging of word vectors that are obtained using a word-embedding method such as word2vec.\nDespite its obliviousness to word order, CBOW has proven useful in different tasks (?) and is easy to compute, making it an important model class to consider.\nEncoder-Decoder (ED) The encoder-decoder framework has been successfully used in a number of sequence-to-sequence learning tasks (Sutskever et al., 2014; Bahdanau et al., 2014; Dai and Le, 2015; Li et al., 2015). After the encoding phase, a decoder maps the sentence representation back to the sequence of words:\nDEC : s \u2208 Rk 7\u2192 s = {w1, w2, ..., wN}\nHere we investigate the specific case of an autoencoder, where the entire encoding-decoding process can be trained end-to-end from a corpus of raw texts. The sentence representation is the final output vector of the encoder. We use a long short-term memory (LSTM) recurrent neural network (Hochreiter and Schmidhuber, 1997; Graves et al., 2013) for both encoder and decoder. The LSTM decoder is similar to the LSTM encoder but with different weights."}, {"heading": "5 Experimental Setup", "text": "Sentence Encoders The bag-of-words (CBOW) and encoder-decoder models are trained on 1 million sentences from a 2012 Wikipedia dump. We use NLTK (Bird, 2006) for tokenization, and constrain sentence lengths to be between 5 and 70 words.\nFor the CBOW model, we train Skip-gram word vectors (Mikolov et al., 2013a), with hierarchicalsoftmax and a window size of 5 words, using the Gensim implementation.3 We control for the embedding size k and train word vectors of sizes k \u2208 {100, 300, 500, 750, 1000}.\nFor the encoder-decoder models, we use an inhouse implementation using the Torch7 tookit (Collobert et al., 2011). The decoder is trained as a language model, attempting to predict the correct word at each time step using a negative-log-likelihood objective (cross-entropy loss over the softmax layer). We use one layer of LSTM cells for the encoder and decoder using the implementation in Le\u0301onard et al. (2015).\nWe use the same size for word and sentence representations (i.e. d = k), and train models of sizes k \u2208 {100, 300, 500, 750, 1000}. We follow previous work on sequence-to-sequence learning (Sutskever et al., 2014; Li et al., 2015) in reversing the input sentences and clipping gradients. Word vectors are initialized to random values.\nWe evaluate the encoder-decoder models using BLEU scores (Papineni et al., 2002), a popular machine translation evaluation metric that is also used to evaluate auto-encoder models (Li et al., 2015). BLEU score measures how well the original sentence is recreated, and can be thought of as a proxy for the quality of the encoded representation. We\n3https://radimrehurek.com/gensim\ncompare it with the performance of the models on the three prediction tasks. The results of the higherdimensional models are comparable to those found in the literature, which serves as a sanity check for the quality of the learned models.\nAuxiliary Task Classifier For the auxiliary task predictors, we use multi-layer perceptrons with a single hidden layer and ReLU activation, which were carefully tuned for each of the tasks. We experimented with several network architectures prior to arriving at this configuration.\nFurther details regarding the training and architectures of both the sentence encoders and auxiliary task classifiers are available in the Appendix."}, {"heading": "6 Results", "text": "In this section we provide a detailed description of our experimental results along with their analysis. For each of the three main tests \u2013 length, content and order \u2013 we investigate the performance of different sentence representation models across embedding size."}, {"heading": "6.1 Length Experiments", "text": "We begin by investigating how well the different representations encode sentence length. Figure 1 shows the performance of the different models on the length task, as well as the BLEU obtained by the LSTM encoder-decoder (ED).\n100 300 500 750 1000\nRepresentation dimensions\n10\n20\n30\n40\n50\n60\n70\n80\n90\nL e n\ng th\np re\nd ic\nti o n\na c c u\nra c y\n0\n5\n10\n15\n20\n25\n30\n35\nB L E U\nED CBOW ED BLEU\nFigure 1: Length accuracy vs. embedding size for different models; ED BLEU scores given for reference.\nWith enough dimensions, the LSTM embeddings are very good at capturing sentence length, obtain-\ning accuracies between 82% and 87%. Length prediction ability is not correlated with BLEU scores: from 300 dimensions onward the length prediction accuracies of the LSTM remain relatively stable, while the BLEU score of the encoder-decoder model increases as more dimensions are added.\nSomewhat surprisingly, the CBOW model also encodes a fair amount of length information, with length prediction accuracies of 45% to 65%, way above the 20% baseline. This is remarkable, as the CBOW representation consists of averaged word vectors, and we did not expect it to encode length at all. We return to CBOW\u2019s exceptional performance in Section 7."}, {"heading": "6.2 Word Content Experiments", "text": "To what extent do the different sentence representations encode the identities of the words in the sentence? Figure 2 visualizes the performance of our models on the word content test.\n100 300 500 750 1000\nRepresentation dimensions\n50\n55\n60\n65\n70\n75\n80\n85\n90\nC o n\nte n\nt p\nre d\nic ti\no n\na c c u\nra c y\n0\n5\n10\n15\n20\n25\n30\n35\nB L E U\nCBOW ED ED BLEU\nFigure 2: Content accuracy vs. embedding size for different models; ED BLEU scores given for reference.\nAll the representations encode some amount of word information, and clearly outperform the random baseline of 50%. Some trends are worth noting. While the capacity of the LSTM encoder to preserve word identities generally increases when adding dimensions, the performance peaks at 750 dimensions and drops afterwards. This stands in contrast to the BLEU score of the respective encoderdecoder models. We hypothesize that this occurs because a sizable part of the auto-encoder performance comes from the decoder, which also improves as we add more dimensions. At 1000 dimensions, the decoder\u2019s language model may be strong enough to al-\nlow the representation produced by the encoder to be less informative with regard to word content.\nCBOW representations with low dimensional vectors (100 and 300 dimensions) perform exceptionally well, outperforming the more complex, sequence-aware models by a wide margin. If your task requires access to word identities, it is worth considering this simple representation. Interestingly, CBOW scores drop at higher dimensions.\nHow well do the models preserve content when we increase the sentence length? In Fig. 3 we plot content prediction accuracy vs. sentence length for different models.\nAs expected, all models suffer a drop in content accuracy on longer sentences. The degradation is roughly linear in the sentence length. For the encoder-decoder, models with fewer dimensions seem to degrade slower."}, {"heading": "6.3 Word Order Experiments", "text": "Figure 4 shows the performance of the different models on the order test. The LSTM encoders are very capable of encoding word order, with LSTM1000 allowing the recovery of word order in 91% of the cases. Similar to the length test, LSTM order prediction accuracy is only loosely correlated with BLEU scores. It is worth to notice that increasing the representation size helps the LSTM-encoder to better encode order information.\nSurprisingly, the CBOW encodings manage to reach an accuracy of 70% on the word order task, 20% above the baseline. This is remarkable as, by definition, the CBOW encoder does not attempt to preserve word order information. One way to ex-\n100 300 500 750 1000\nRepresentation dimensions\n50\n60\n70\n80\n90\nO rd\ne r\np re\nd ic\nti o n\na c c u\nra c y\n0\n5\n10\n15\n20\n25\n30\n35\nB L E U\nED CBOW ED BLEU\nFigure 4: Order accuracy vs. embedding size for different models; ED BLEU scores given for reference.\nplain this is by considering distribution patterns of words in natural language sentences: some words tend to appear before others. In the next section we analyze the effect of natural language on the different models."}, {"heading": "7 Importance of \u201cNatural Languageness\u201d", "text": "Natural language imposes many constraints on sentence structure. To what extent do the different encoders rely on specific properties of word distributions in natural language sentences when encoding sentences?\nTo account for this, we perform additional experiments in which we attempt to control for the effect of natural language.\nHow can CBOW encode sentence length? Is the ability of CBOW embeddings to encode length related to specific words being indicative of longer or shorter sentences? To control for this, we created a synthetic dataset where each word in each sentence is replaced by a random word from the dictionary and re-ran the length test for the CBOW embeddings using this dataset. As Fig. 5 shows, this only leads to a slight decrease in accuracy, indicating that the identity of the words is not the main component in CBOW\u2019s success at predicting length.\nAn alternative explanation for CBOW\u2019s ability to encode sentence length is given by considering the norms of the sentence embeddings. Indeed, Fig. 6 shows that the embedding norm decreases as sentences grows longer. We believe this is one of the main reasons for the strong CBOW results.\nWhile the correlation between the number of averaged vector and the resulting norm surprised us, in\nretrospect it is an expected behavior that has sound mathematical foundations. To understand the behavior, consider the different word vectors to be random variables, with the values in each dimension centered roughly around zero. The central limit theorem tells us that as we add samples, the expected average of the values will better approximate the true mean, causing the norm of the average vector to decrease. We expect the correlation between the sentence length and its norm to be more pronounced with shorter sentences (above some number of samples we will already be very close to the true mean, and the norm will not decrease further), a behavior which we indeed observe in practice.\nHow does CBOW encode word order? The surprisingly strong performance of the CBOW model on the order task made us hypothesize that much of the word order information is captured in general natural language word order statistics.\nTo investigate this, we re-run the word order tests, but this time drop the sentence embedding in training and testing time, learning from the word-pairs alone. In other words, we feed the network as input two word embeddings and ask which word comes\nfirst in the sentence. This test isolates general word order statistics of language from information that is contained in the sentence embedding (Fig. 7).\nThe difference between including and removing the sentence embeddings when using the CBOW model is minor, while the LSTM-ED suffers a significant drop. Clearly, the LSTM-ED model encodes word order, while the prediction ability of CBOW is mostly explained by general language statistics. However, CBOW does benefit from the sentence to some extent: we observe a gain of \u223c3% accuracy points when the CBOW tests are allowed access to the sentence representation. This may be explained by higher order statistics of correlation between word order patterns and the occurrences of specific words.\nHow important is English word order for encoding sentences? To what extent are the models trained to rely on natural language word order when encoding sentences? To control for this, we create a synthetic dataset, PERMUTED, in which the word order in each sentence is randomly permuted. Then, we repeat the length, content and order experiments using the PERMUTED dataset (we still use the original sentence encoders that are trained on non-permuted sentences). While the permuted sentence representation is the same for CBOW, it is completely different when generated by the encoderdecoder.\nResults are presented in Fig. 8. When considering CBOW embeddings, word order accuracy drops to chance level, as expected, while results on the other tests remain the same. Moving to the LSTM encoder-decoder, the results on all three tests are\ncomparable to the ones using non-permuted sentences. These results are somewhat surprising since the models were originally trained on \u201creal\u201d, nonpermuted sentences. This indicates that the LSTM encoder-decoder is a general-purpose sequence encoder that for the most part does not rely on word ordering properties of natural language when encoding sentences. The small and consistent drop in word order accuracy on the permuted sentences can be attributed to the encoder relying on natural language word order to some extent, but can also be explained by the word order prediction task becoming harder due to the inability to use general word order statistics. The results suggest that a trained encoder will transfer well across different natural language domains, as long as the vocabularies remain stable. When considering the decoder\u2019s BLEU score on the permuted dataset (not shown), we do see a dramatic\ndecrease in accuracy. For example, LSTM encoderdecoder with 1000 dimensions drops from 32.5 to 8.2 BLEU score. These results suggests that the decoder, which is thrown away, contains most of the language-specific information."}, {"heading": "8 Skip-Thought Vectors", "text": "In addition to the experiments on CBOW and LSTM-encoders, we also experiment with the skipthought vectors model (Kiros et al., 2015). This model extends the idea of the auto-encoder to neighboring sentences.\nGiven a sentence si, it first encodes it using an RNN, similar to the auto-encoder model. However, instead of predicting the original sentence, skipthought predicts the preceding and following sentences, si\u22121 and si+1. The encoder and decoder are implemented with gated recurrent units (Cho et al., 2014).\nHere, we deviate from the controlled environment and use the author\u2019s provided model4 with the recommended embeddings size of 4800. This makes the direct comparison of the models \u201cunfair\u201d. However, our aim is not to decide which is the \u201cbest\u201d model but rather to show how our method can be used to measure the kinds of information captured by different representations.\nTable 1 summarizes the performance of the skipthought embeddings in each of the prediction tasks on both the PERMUTED and original dataset.\nThe performance of the skip-thought embeddings is well above the baselines and roughly similar for all tasks. Its performance is similar to the higherdimensional encoder-decoder models, except in the order task where it lags somewhat behind. However, we note that the results are not directly comparable as skip-thought was trained on a different corpus.\nThe more interesting finding is its performance on the PERMUTED sentences. In this setting we\n4https://github.com/ryankiros/skip-thoughts\nsee a large drop. In contrast to the LSTM encoderdecoder, skip-thought\u2019s ability to predict length and word content does degrade significantly on the permuted sentences, suggesting that the encoding process of the skip-thought model is indeed specialized towards natural language texts."}, {"heading": "9 Conclusion", "text": "We presented a methodology for performing finegrained analysis of sentence embeddings using auxiliary prediction tasks. Our analysis reveals some properties of sentence embedding methods:\n\u2022 CBOW is surprisingly effective \u2013 in addition to being very strong at content, it is also predictive of length and word order. 300 dimensions perform best, with greatly degraded word-content prediction performance on higher dimensions.\n\u2022 With enough dimensions, LSTM auto-encoders are very effective at encoding word order information, and less so at encoding word content. Increasing the dimensionality of the LSTM encoder does not significantly improve its ability to encode length, but does increase its ability to encode content and order information. 500 dimensional embeddings are already quite effective for encoding word order, with little gains beyond that. Word content accuracy peaks at 750 dimensions and drops at 1000, suggesting that larger is not always better.\n\u2022 The trained LSTM encoder (when trained with an auto-encoder objective) does not rely on ordering patterns in the training sentences when encoding novel sequences.\nIn contrast, the skip-thought encoder does rely on such patterns. Its performance on the other tasks is similar to the higher-dimensional LSTM encoder, which is impressive considering it was trained on a different corpus.\n\u2022 Finally, the encoder-decoder\u2019s ability to recreate sentences (BLEU) is not entirely indicative of the quality of the encoder at representing aspects such as word identity and order. This suggests that BLEU is sub-optimal for model selection."}, {"heading": "Appendix: Technical Details", "text": "Encoder Decoder\nParameters of the encoder-decoder were tuned on a dedicated validation set. We experienced with different learning rates (0.1, 0.01, 0.001), dropout-rates (0.1, 0.2, 0.3, 0.5) (Hinton et al., 2012) and optimization techniques (AdaGrad (Duchi et al., 2011), AdaDelta (Zeiler, 2012), Adam (Kingma and Ba, 2014) and RMSprop (Tieleman and Hinton, 2012)). We also experimented with different batch sizes (8, 16, 32), and found improvement in runtime but no significant improvement in performance.\nBased on the tuned parameters, we trained the encoder-decoder models on a single GPU (NVIDIA Tesla K40), with mini-batches of 32 sentences, learning rate of 0.01, dropout rate of 0.1, and the AdaGrad optimizer; training takes approximately 10 days and is stopped after 5 epochs with no loss improvement on a validation set.\nPrediction Tasks\nParameters for the predictions tasks as well as classifier architecture were tuned on a dedicated validation set. We experienced with one, two and three layers feed-forward network using ReLU (Nair and Hinton, 2010; Glorot et al., 2011), tanh and sigmoid activation functions. We tried different hidden layer sizes; the same as the input size, twice as the input size and one and a half times as the input size. We tried different learning rates (0.1, 0.01, 0.001), dropout rates (0.1, 0.3, 0.5, 0.8) and different optimization techniques (AdaGrad, AdaDelta and Adam).\nOur best tuned classifier, which we use for all experiments, is a feed-forward network with one hidden layer and a ReLU activation function. We set the size of the hidden layer to be the same size as the input vector. We place a softmax layer on top whose size varies according to the specific task, and apply dropout before the softmax layer. We optimize the log-likelihood using AdaGrad. We use a dropout rate of 0.8 and a learning rate of 0.01. Training is stopped after 5 epochs with no loss improvement on the development set. Training was done on a single GPU (NVIDIA Tesla K40)."}], "references": [{"title": "Kyunghyun Cho", "author": ["Dzmitry Bahdanau"], "venue": "and Yoshua Bengio.", "citeRegEx": "Bahdanau et al.2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Georgiana Dinu", "author": ["Marco Baroni"], "venue": "and Germ\u00e1n Kruszewski.", "citeRegEx": "Baroni et al.2014", "shortCiteRegEx": null, "year": 2014}, {"title": "NLTK: the natural language toolkit", "author": ["Steven Bird"], "venue": "In Proceedings of the COLING/ACL on Interactive presentation sessions,", "citeRegEx": "Bird.,? \\Q2006\\E", "shortCiteRegEx": "Bird.", "year": 2006}, {"title": "Holger Schwenk", "author": ["Kyunghyun Cho", "Bart Van Merri\u00ebnboer", "Caglar Gulcehre", "Dzmitry Bahdanau", "Fethi Bougares"], "venue": "and Yoshua Bengio.", "citeRegEx": "Cho et al.2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Koray Kavukcuoglu", "author": ["Ronan Collobert"], "venue": "and Cl\u00e9ment Farabet.", "citeRegEx": "Collobert et al.2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Semi-supervised sequence learning", "author": ["Dai", "Le2015] Andrew M Dai", "Quoc V Le"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Dai et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Dai et al\\.", "year": 2015}, {"title": "Elad Hazan", "author": ["John Duchi"], "venue": "and Yoram Singer.", "citeRegEx": "Duchi et al.2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Distributed representations, simple recurrent networks, and grammatical structure", "author": ["Jeffrey L Elman"], "venue": "Machine learning,", "citeRegEx": "Elman.,? \\Q1991\\E", "shortCiteRegEx": "Elman.", "year": 1991}, {"title": "Antoine Bordes", "author": ["Xavier Glorot"], "venue": "and Yoshua Bengio.", "citeRegEx": "Glorot et al.2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Abdel-rahman Mohamed", "author": ["Alex Graves"], "venue": "and Geoffrey Hinton.", "citeRegEx": "Graves et al.2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Kyunghyun Cho", "author": ["Felix Hill"], "venue": "and Anna Korhonen.", "citeRegEx": "Hill et al.2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Ilya Sutskever", "author": ["Geoffrey E. Hinton", "Nitish Srivastava", "Alex Krizhevsky"], "venue": "and Ruslan Salakhutdinov.", "citeRegEx": "Hinton et al.2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Long short-term memory", "author": ["Hochreiter", "Schmidhuber1997] Sepp Hochreiter", "J\u00fcrgen Schmidhuber"], "venue": "Neural Computation,", "citeRegEx": "Hochreiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter et al\\.", "year": 1997}, {"title": "Grzegorz Chrupa\u0142a", "author": ["\u00c1kos K\u00e1d\u00e1r"], "venue": "and Afra Alishahi.", "citeRegEx": "K\u00e1d\u00e1r et al.2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Justin Johnson", "author": ["Andrej Karpathy"], "venue": "and Fei-Fei Li.", "citeRegEx": "Karpathy et al.2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980", "author": ["Kingma", "Ba2014] Diederik Kingma", "Jimmy Ba"], "venue": null, "citeRegEx": "Kingma et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kingma et al\\.", "year": 2014}, {"title": "Antonio Torralba", "author": ["Ryan Kiros", "Yukun Zhu", "Ruslan R Salakhutdinov", "Richard Zemel", "Raquel Urtasun"], "venue": "and Sanja Fidler.", "citeRegEx": "Kiros et al.2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Sagar Waghmare", "author": ["Nicholas L\u00e9onard"], "venue": "and Yang Wang.", "citeRegEx": "L\u00e9onard et al.2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Linguistic regularities in sparse and explicit word representations", "author": ["Levy", "Goldberg2014] Omer Levy", "Yoav Goldberg"], "venue": "In Proc. of CONLL,", "citeRegEx": "Levy et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Levy et al\\.", "year": 2014}, {"title": "Yoav Goldberg", "author": ["Omer Levy"], "venue": "and Ido Dagan.", "citeRegEx": "Levy et al.2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Minh-Thang Luong", "author": ["Jiwei Li"], "venue": "and Dan Jurafsky.", "citeRegEx": "Li et al.2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Efficient estimation of word representations in vector space. arXiv preprint arXiv:1301.3781", "author": ["Kai Chen", "Greg Corrado", "Jeffrey Dean"], "venue": null, "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Distributed representations of words and phrases and their compositionality", "author": ["Ilya Sutskever", "Kai Chen", "Greg S Corrado", "Jeff Dean"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["Nair", "Hinton2010] Vinod Nair", "Geoffrey E Hinton"], "venue": "In Proceedings of the 27th International Conference on Machine Learning", "citeRegEx": "Nair et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2010}, {"title": "Todd Ward", "author": ["Kishore Papineni", "Salim Roukos"], "venue": "and Wei-Jing Zhu.", "citeRegEx": "Papineni et al.2002", "shortCiteRegEx": null, "year": 2002}, {"title": "Oriol Vinyals", "author": ["Ilya Sutskever"], "venue": "and Quoc VV Le.", "citeRegEx": "Sutskever et al.2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Lecture 6.5-rmsprop. COURSERA: Neural networks for machine learning", "author": ["Tieleman", "Hinton2012] Tijmen Tieleman", "Geoffrey Hinton"], "venue": null, "citeRegEx": "Tieleman et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Tieleman et al\\.", "year": 2012}, {"title": "Adadelta: an adaptive learning rate method", "author": ["Matthew D Zeiler"], "venue": "arXiv preprint arXiv:1212.5701", "citeRegEx": "Zeiler.,? \\Q2012\\E", "shortCiteRegEx": "Zeiler.", "year": 2012}], "referenceMentions": [], "year": 2017, "abstractText": "There is a lot of research interest in encoding variable length sentences into fixed length vectors, in a way that preserves the sentence meanings. Two common methods include representations based on averaging word vectors, and representations based on the hidden states of recurrent neural networks such as LSTMs. The sentence vectors are used as features for subsequent machine learning tasks or for pretraining in the context of deep learning. However, not much is known about the properties that are encoded in these sentence representations and about the language information they capture. We propose a framework that facilitates better understanding of the encoded representations. We define prediction tasks around isolated aspects of sentence structure (namely sentence length, word content, and word order), and score representations by the ability to train a classifier to solve each prediction task when using the representation as input. We demonstrate the potential contribution of the approach by analyzing different sentence representation mechanisms. The analysis sheds light on the relative strengths of different sentence embedding methods with respect to these low level prediction tasks, and on the effect of the encoded vector\u2019s dimensionality on the resulting representations.", "creator": "LaTeX with hyperref package"}}}