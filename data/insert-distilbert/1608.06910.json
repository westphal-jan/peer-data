{"id": "1608.06910", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Aug-2016", "title": "A Parallel Memory-efficient Epistemic Logic Program Solver: Harder, Better, Faster", "abstract": "as the practical use of answer set programming ( asp ) has substantially grown with the accelerated development of emotionally efficient solvers, we expect soon a further growing interest in extensions of asp processes as their semantics stabilize and solvers supporting setting them consequently mature. epistemic specifications, which progressively adds modal operators k and m to the language of asp, is one such extension. whatever we call a program in specifically this derived language an epistemic logic program ( elp ). solvers have thus far been practical for only the simplest elps due to exponential growth of rounding the memory required. we describe a solver that is able to solve harder problems better ( without exponentially - growing memory needs w. r. t. k and m numerical occurrences ) and faster than any other standard known elp solver.", "histories": [["v1", "Wed, 24 Aug 2016 18:18:08 GMT  (332kb,D)", "https://arxiv.org/abs/1608.06910v1", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"], ["v2", "Thu, 13 Oct 2016 16:25:52 GMT  (332kb,D)", "http://arxiv.org/abs/1608.06910v2", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"]], "COMMENTS": "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["patrick thor kahl", "anthony p leclerc", "tran cao son"], "accepted": false, "id": "1608.06910"}, "pdf": {"name": "1608.06910.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["ANTHONY P. LECLERC"], "emails": ["patrick.kahl@navy.mil", "anthony.leclerc@navy.mil", "leclerca@cofc.edu", "tson@cs.nmsu.edu"], "sections": [{"heading": null, "text": "Keywords: Epistemic Logic Program Solver, Logic Programming Tools, Epistemic Specifications, Answer Set Programming Extensions, Solver Algorithms"}, {"heading": "1 Introduction", "text": "The language of Epistemic Specifications [12,13] was introduced in the early 1990s by Michael Gelfond after observing the need for more powerful introspective reasoning than that offered by answer set programming (ASP) alone, extending ASP with modal operators K (\u201cknown\u201d) and M (\u201cmay be true\u201d). A program written in this language is called an epistemic logic program (ELP), with semantics defined using the notion of a world view\u2014a collection of sets of literals (belief sets), analogous to the answer sets of an ASP program. A renewed interest in Epistemic Specifications [27,8] in 2011 included a proposed change to the semantics by Gelfond [14] in a preliminary effort to avoid unintended world views. That work was continued by Kahl et al. [19,20] in the hopes of finding a satisfactory semantics with respect to intuition and modeling of problems. Later attempts to improve the semantics were offered by Su et al. [26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.\nAlong with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang\u2019s algorithm [30], ESmodels by Zhizheng Zhang et al. [25,7,34,33], and most recently ELPS by Balai [2,3].\nIn this paper, we present results of our efforts to implement a new ELP solver that incorporates updated semantics and uses a scalable approach that greatly decreases both the memory and time required for solving harder ELPs compared to other solvers.\nar X\niv :1\n60 8.\n06 91\n0v 2\n[ cs\n.A I]\n1 3\nO ct"}, {"heading": "2 Syntax and Semantics", "text": "In general, the syntax and semantics of the language of Epistemic Specifications follow that of ASP with the notable addition of modal operators K and M, plus the new notion of a world view. We assume familiarity with logic programming\u2014ASP in particular. For a good introduction, see any of [6,18,10,15]. For simplicity, the syntax presented does not include certain language features (e.g., aggregates) of the proposed ASP core standard [1], but that does not mean such features should necessarily be considered excluded from the language. As previous authors have done before us, we will use AS(P) to denote the set of all answer sets of an ASP program P."}, {"heading": "2.1 Syntax", "text": "An epistemic logic program is a set of rules of the form\n`1 or ... or `k \u2190 g1, ..., gm, not gm+1, ..., not gn.\nwhere k \u2265 0, m \u2265 0, n \u2265 m, each `i is a literal (an atom or a classically-negated atom), and each gi is either a literal (often called an objective literal within the context of Epistemic Specifications), or a subjective literal (a literal immediately preceded by K or M). As in ASP, a rule having a literal with a variable term is a shorthand for all ground instantiations of the rule."}, {"heading": "2.2 Semantics", "text": "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].\nDefinition 1. [When a Subjective Literal Is Satisfied] LetW be a non-empty set of consistent sets of ground literals, and ` be a ground literal.\n\u2022 K ` is satisfied by W if \u2200A \u2208W : ` \u2208 A. \u2022 not K ` is satisfied by W if \u2203A \u2208W : ` /\u2208 A. \u2022 M` is satisfied by W if \u2203A \u2208W : ` \u2208 A. \u2022 not M` is satisfied by W if \u2200A \u2208W : ` /\u2208 A.\nWe will use symbol |= to mean satisfies; e.g., W |= K ` means K ` is satisfied by W.\nDefinition 2. [Modal Reduct] Let\u03a0 be a ground epistemic logic program andW be a non-empty set of consistent sets of ground literals. We denote by \u03a0W the modal reduct of \u03a0 with respect to W defined as the ASP program1 obtained from \u03a0 by replacing/removing subjective literals and/or deleting associated rules in \u03a0 per the following table: subjective literal \u03d5 if W |= \u03d5 then... if W 6|= \u03d5 then...\nK ` replace K ` with ` delete rule containing K ` not K ` remove not K ` replace not K ` with not ` M` remove M` replace M` with not not ` not M` replace not M` with not ` delete rule containing not M`\n1 with nested expressions of the form not not ` as defined in [22]\nDefinition 3. [Epistemic Negations2] Let \u03a0 be a ground epistemic logic program and W be a non-empty set of consistent sets of literals. We denote by EP (\u03a0) the set of distinct subjective literals in \u03a0 taking the form not K` and M` (called epistemic negations) as follows:\nEP (\u03a0) = { not K` : K` appears in \u03a0 } \u222a {M` : M` appears in \u03a0 }.\nWe use \u03a6 to denote a subset of EP (\u03a0), and we denote by \u03a6W the subset of epistemic negations inEP (\u03a0) that are satisfied byW ; i.e., \u03a6W = { \u03d5 : \u03d5 \u2208 EP (\u03a0) \u2227W |= \u03d5 }.\nDefinition 4. [World View] Let \u03a0 be a ground epistemic logic program and W be a non-empty set of consistent sets of literals. W is a world view of \u03a0 if:\n\u2022 W= AS(\u03a0W); and \u2022 there is no W \u2032 such that W \u2032= AS(\u03a0W \u2032) and \u03a6W \u2032 \u2283 \u03a6W .\nNote here the addition of a maximality requirement on \u03a6W with respect to other guesses (corresponding to other candidate world views) that is not in the semantics of [19,20]. See [24] for discussion concerning the intuition behind the proposed new semantics."}, {"heading": "2.3 Discussion and Additional Definitions", "text": "The semantics of an epistemic logic program \u03a0 as described herein is equivalent to the semantics described by Shen & Eiter in [24] for \u03a0 translated to their syntax. The proof can be found in the appendix.\nAlthough we prefer our syntax to that proposed in [24], we find the definition of an epistemic reduct an excellent tool for describing the new semantics, particularly with the emphasis on our ELP solver. We therefore present the following additional definitions.\nDefinition 5. [Epistemic Reduct, Reduct-verifiable] Let\u03a0 be a ground epistemic logic program, \u03a6 be a subset ofEP (\u03a0), and \u03a8=EP (\u03a0)\\\u03a6. We denote by \u03a0\u03a6 the epistemic reduct of \u03a0 with respect to \u03a6 defined as the ASP program obtained from \u03a0 (assuming existence of corresponding W) by considering as\nSATISFIED: the subjective literals in \u03a6 and the complements of the subjective literals in \u03a8 NOT SATISFIED: the subjective literals in \u03a8 and the complements of the subjective literals in \u03a63\nand taking actions according to the table given for the modal reduct in Definition 2.\nFor given \u03a0, we say that \u03a6 is reduct-verifiable if W=AS(\u03a0\u03a6), W 6=\u2205, and \u03a6W=\u03a6.\nDefinition 6. [World View (alternative definition)] Let \u03a0 be a ground ELP, \u03a6\u2286EP (\u03a0), and W=AS(\u03a0\u03a6). W is a world view of \u03a0 if:\n\u2022 \u03a6 is reduct-verifiable and \u2022 there exists no reduct-verifiable \u03a6\u2032 \u2286EP (\u03a0) such that \u03a6\u2032 \u2283 \u03a6.\n2 introduced by Shen & Eiter in [24] using a different syntax (see the appendix) 3 K ` and not K ` are complements; M ` and not M ` are complements"}, {"heading": "3 Algorithms for Computing World Views", "text": "Definitions 5 and 6 show that a world view of a program \u03a0 can be computed by guessing a set \u03a6 \u2286 EP (\u03a0) and verifying that \u03a6 is maximal (with respect to \u2286) reductverifiable. As such, we use the term guess to refer to a set of elements from EP (\u03a0) in the descriptions of our algorithms. For completeness of the paper, we include herein the basic algorithm implemented in existing state-of-the-art ELP solvers (Algorithm 1). A pictorial description of Algorithm 1 is given in Figure 1(a). It is easy to see Algorithm 1 is complete if Translation (Step 2) guarantees all world views of\u03a0 are disjoint subsets (groups) of the answer sets of \u03a0 \u2032. One such translation was proposed in [20].\nAlgorithm 1: Compute World Views \u2013 Old Algorithm Input: \u03a0 : an epistemic logic program Output: The set \u2126 = {\u03c9 : \u03c9 is a world view of \u03a0} 1 \u2126 \u2190 \u2205 2 Translation: ASP program \u03a0 \u2032 is created from input ELP \u03a0 (effecting generation of \u03a0\u03a6\nfor all guesses \u03a6 \u2286 EP (\u03a0)). 3 Computation: \u03a0 \u2032 is solved using an ASP solver. 4 Aggregation: Answer sets of \u03a0 \u2032 are grouped according to corresponding \u03a6. 5 Verification: Each group G is verified (if \u03a6G = \u03a6 then G is added to \u2126). 6 return \u2126\nAlthough Algorithm 1 is simple and easy to implement as an add-on to an ASP solver, its main drawback lies in Steps 3 & 4. Specifically, it requires that all answer sets of program \u03a0 \u2032 are computed and then grouped before world views can be identified. This works well for very small programs but can be impractical memory-wise since the number of guesses grows exponentially with the number of subjective literals. In addition, existing implementations of this algorithm do not allow for early termination when the number of world views found reaches a user-specified limit (e.g., 1)."}, {"heading": "3.1 New Algorithm", "text": "Our new algorithm improves Algorithm 1 by addressing the memory growth problem. It divides the work into parts instead of computing everything in one call. The basic steps are given in Algorithm 2. A pictorial description of the algorithm is given in Figure 1(b). In the form shown, the algorithm does not address the maximality requirement of the updated semantics. Details of how the values of guesses are added to the program in the Paritition step (Step 4) will be described in the implementation section, where selection of guesses is done systematically via an ordered search with pruning that ensures the maximality requirement is properly addressed. It is easy to see how limiting the number of guesses during the Partition step of Algorithm 2 can alleviate the memory concerns of Algorithm 1; however, as the selection of guesses for each iteration is not specified, the algorithm can be implemented in a variety of ways. The algorithm will thus be further refined in Algorithms 3, 4, and 5.\nAlgorithm 2: Compute World Views \u2013 New Algorithm Input: \u03a0 : an epistemic logic program Output: The set \u2126 = {\u03c9 : \u03c9 is a world view of \u03a0} 1 \u2126 \u2190 \u2205 2 Translation: ASP program \u03a0 \u2032 is created from input ELP \u03a0 (without the inclusion of\nguesses for subjective literals) 3 repeat 4 Partition: \u03a0 \u2032\u2032 is created by adding ASP representation of guesses (\u03a6 values) to \u03a0 \u2032 5 Computation: \u03a0 \u2032\u2032 is solved using an ASP solver 6 Aggregation: Answer sets of \u03a0 \u2032\u2032 are grouped according to corresponding \u03a6. 7 Verification: Each group G is verified (if \u03a6G = \u03a6 then G is added to \u2126). 8 until all guesses tried 9 return \u2126\nAlgorithm 2 offers advantages over Algorithm 1 by providing a divide-and-conquer search method that is configurable to allow for:\n\u2022 efficient use of memory, \u2022 parallel processing, and \u2022 early termination after a pre-specified number of world views found."}, {"heading": "3.2 Instantiations of the New Algorithm: Overview", "text": "The basic idea behind the new algorithm is to follow Definition 6 in computing the world views. To ensure completeness in an efficient manner, guesses need to be selected in a way that facilitates satisfaction of the second condition of the definition. In our approach, guesses are ranked (into levels) in decreasing order by their cardinality. The\ncardinality of a guess, |\u03a6|, is called the guess size. A guess is filtered out if it is a subset of a prior guess that was found to be reduct-verifiable. Combined with the selection order, this eliminates the possibility of a reduct-verifiable guess being a superset of any guess that is not filtered out. We therefore start with the guess \u03a6 = EP (\u03a0) and work systematically down in order of guess size, filtering out guesses that are subsets of previously found world views. So to determine if a guess yields a world view, we need only compute the answer sets of the epistemic reduct (\u03a0\u03a6) and check that \u03a6 is reduct-verifiable. Algorithm 3 implements this idea. In this algorithm, ASP(\u03a6) denotes the ASP representation of subjective literals that are considered satisfied when creating \u03a0\u03a6, and \u03a0 \u2032 is constructed in such a way that the corresponding AS(\u03a0 \u2032\u2032)4= AS(\u03a0\u03a6).\nAlgorithm 3: Compute World Views \u2013 Level Order, One Guess at a Time Input: \u03a0 : an epistemic logic program, n\u2126 : max number of world views desired Output: The set \u2126 = {\u03c9 : \u03c9 is a world view of \u03a0} 1 \u2126 \u2190 \u2205 2 \u03a0 \u2032 \u2190 result of Step 2 of Algorithm 2 3 foreach subset \u03a6 of EP (\u03a0) in decreasing order of |\u03a6| do 4 if (\u2203\u03c9 \u2208 \u2126 : \u03a6 \u2282 \u03a6\u03c9) then continue // pruning filter 5 construct \u03a0 \u2032\u2032 = \u03a0 \u2032 \u222a ASP(\u03a6) 6 compute C = AS(\u03a0 \u2032\u2032) // candidate world view 7 if (C 6= \u2205) \u2227 (\u03a6C = \u03a6) then add C to \u2126 // check if world view 8 if |\u2126| = n\u2126 then break // return if desired # world views found"}, {"heading": "9 return \u2126", "text": "Note the pruning filter on Line 4 of Algorithm 3 that, combined with the search order, implements the maximality requirement of Definition 6. This filter can be turned off to revert to the semantics of [20]. We refer to this filter later in Algorithms 4 & 5 without explicit pseudocode when we say filtered.\nAlthough Algorithm 3 solves the memory problem, it increases the number of calls to the ASP solver. As such, the algorithm can be inefficient. To address this concern, we implement Algorithm 4 that computes the world views for multiple guesses at the same time. The trade-off is that grouping (the Aggregation step of Algorithm 2) must be performed. Additionally, care needs to be taken to ensure completeness and avoid repetition. We accomplish this by requiring that all guesses in a set have the same guess size, all sets of guesses are pairwise disjoint, and all guesses of the same size are tried (or filtered out) before moving to the next level. This is achieved as follows. We introduce parameter nG representing the (maximum) number of guesses per ASP solver call, and partition each level Lk = {\u03a6 : (\u03a6 \u2286 EP (\u03a0)) \u2227 (|\u03a6| = k)} (for 0 \u2264 k \u2264 |EP (\u03a0)|) into groups of at most nG guesses. Detail on the implementation is given in the next subsection. Figure 2 shows a visual description of this algorithm.\nFinally, in order to utilize the computing power of modern computers and enhance the performance of the solver, we implement a parallel version of the algorithm. For brevity, we omit parameter n\u2126 and associated pseudocode for early termination when desired number of world views is found.\n4 modulo certain fresh literals (see Section 3.3)\nAlgorithm 4: Compute World Views \u2013 Level Order, Multiple Guesses at a Time Input: \u03a0 : an epistemic logic program, nG : #groups per ASP solver call Output: The set \u2126 = {\u03c9 : \u03c9 is a world view of \u03a0} 1 \u2126 \u2190 \u2205 2 \u03a0 \u2032 \u2190 result of Step 2 of Algorithm 2 3 for k \u2190 |EP (\u03a0)| downto 0 do // for each level do . . .\n4 Partition Lk into t = \u2308 |Lk | nG \u2309 groups G1k, . . . , G t k such that |Gik| \u2264 nG 5 foreach filtered group Gik of Lk do 6 construct \u03a0 \u2032\u2032 = \u03a0 \u2032 \u222aASP(Gik) 7 compute Gas = AS(\u03a0 \u2032\u2032) 8 foreach associated candidate world view C of Gas do // group 9 if (C 6= \u2205) \u2227 (\u03a6C = \u03a6) then add C to \u2126 // check if world view\n10 return \u2126\nAlgorithm 5: Compute World Views \u2013 Parallel Version Input: \u03a0 : an epistemic logic program, nG : #groups per ASP solver call, np : #processes Output: The set \u2126 = {\u03c9 : \u03c9 is a world view of \u03a0} 1 \u2126 \u2190 \u2205 2 \u03a0 \u2032 \u2190 result of Step 2 of Algorithm 2 3 for k \u2190 |EP (\u03a0)| downto 0 do // for each level do . . .\n4 Partition Lk into t = \u2308 |Lk | nG \u2309 groups G1k, . . . , G t k such that |Gik| \u2264 nG\n5 Mark every group as not considered 6 repeat 7 for i\u2190 1 to np do // for each processor do . . . 8 select a filtered group G from G1k, . . . , G t k that is marked as not considered\n9 mark group G as considered 10 construct \u03a0 \u2032\u2032i = \u03a0\n\u2032 \u222aASP(G) 11 for i\u2190 1 to np do in parallel // solve in parallel 12 compute Gasi = AS(\u03a0 \u2032\u2032 i )\n// accumulate the results of each processor and . . . 13 for i\u2190 1 to np do 14 foreach associated candidate world view C of Gasi do // group 15 if (C 6= \u2205)\u2227 (\u03a6C = \u03a6) then add C to \u2126 // check if world view\n16 until every group is either marked as considered or filtered out\n17 return \u2126"}, {"heading": "3.3 Implementation Representation", "text": "Let \u03a0 be a ground ELP and EP (\u03a0) be its set of epistemic negations. Let IEP be an enumeration of EP (\u03a0) and for each \u03d5 \u2208 EP (\u03a0), let ord(\u03d5) be the index of \u03d5 in IEP . We represent each guess \u03a6 \u2286 EP (\u03a0) with a bitvector of length n = |EP (\u03a0)| as follows: B\u03a6 = [b1, b2, ..., bn] where for i = ord(\u03d5), bit bi = 1 iff \u03d5 \u2208 \u03a6.\nEach bitvector representing a guess can be represented by an integer X such that 0 \u2264 X \u2264 2n\u22121; thus, eachX represents a unique subset ofEP (\u03a0) and vice versa. This one-to-one correspondence is useful in the implementation as it allows for fast checking of the subset relation between guesses (Line 4, Algorithm 3). For later use, we denote by popcount(X) the number of one bits in the binary representation of X .\nAs an example, consider EP (\u03a0) = {not K `1, not K `2, M `3}. Assuming we enumerate the elements of EP (\u03a0) from left to right, the bitvector B\u03a6 = [b1, b2, b3] would be constructed with bit b1 representing the truth value (w.r.t. membership in \u03a6, where 1=True and 0=False) of not K `1, b2 representing the truth value of not K `2, and b3 representing the truth value of M `3. For example, a bitvector B\u03a6 = [0, 1, 1] would represent \u03a6 = {not K `2, M `3}.\nFor the translation of an ELP \u03a0 to an ASP program, we use a variant of the one developed in [20]. For each literal ` in the epistemic negations of EP (\u03a0) of the form not K `, let k `, k0 `, and k1 ` be fresh atoms created by prefixing ` with k , k0 , and k1 (respectively), substituting 2 for \u00ac if ` is a classically-negated atom. Likewise, for epistemic negations of the form M ` in EP (\u03a0), let m `, m0 `, m1 ` be fresh atoms\ncreated in like fashion. For example, if `=p(a) then k ` denotes k p(a), but if `=\u00acp(a) then k ` denotes k 2p(a). An atom denoted by k `, k0 `, or k1 ` will be referred to as a k-atom, whereas an atom denoted by m `, m0 `, or m1 ` will be referred to as an matom. By a k-/m-literal we mean a k-/m-atom or its negation. For a set of sets of literals C, we use the notation C\\km to mean C modulo k-/m-literals (i.e., with k-/m-literals removed from the sets of C).\nIntuitive meanings of the atoms are: k1 ` stands for \u201cK ` is True,\u201d k0 ` stands for \u201cK ` is False,\u201d m1 ` stands for \u201cM ` is True,\u201d and m0 ` stands for \u201cM ` is False.\u201d We can thus view k1 ` as corresponding to K `, k0 ` as corresponding to not K `, etc."}, {"heading": "3.4 Implementation Details", "text": "We describe here implementation details for Algorithm 5.\n1. Translation: Given ground ELP \u03a0 , we create ASP program \u03a0 \u2032 by (i) leaving rules without subjective literals unchanged; and (ii) for rules containing subjective literals, replacing subjective literals and adding new rules per the following table.\nSUBJECTIVE LITERAL REPLACE WITH\nADD RULES\nK ` not \u00ack `, ` \u00ack ` \u2190 k0 `. not K ` \u00ack ` \u00ack ` \u2190 k1 `, not `.\nM ` m ` m `\u2190 m1 `. not M ` not m ` m `\u2190 m0 `, not not `.\nWe note that this translation is slightly different from the translation in [20] in that it does not add the rules for guessing the values of elements in EP (\u03a0). On the other hand, it implies that if equivalent rules for guessing the values of elements inEP (\u03a0) are added to \u03a0 \u2032 then correctness of the algorithm is maintained. This property is guaranteed by the partitioning step of the algorithm.\n2. Partition: The algorithm employs a bitvector representation for guesses in partitioning the search space. The partitioning of a level, Lk, occurs on Line 4 of the\nalgorithm. Each group of bitvectors, G1k, . . . , G t k for t = \u2308 |Lk | nG \u2309 , is produced \u201con\ndemand\u201d with group size at most nG, and G1k containing the first nG elements of Lk, G 2 k containing the next nG elements of Lk, etc. Partitioning is accomplished using a generating function \u201cseeded\u201d with an appropriate bitvector of length n with k one bits. Each subsequent call to the generating function produces the \u201cnext\u201d bitvector of length n with k one bits. Thus, storage is required only for representing groups of guesses currently under consideration. 3. \u03a0 \u2032\u2032 = \u03a0 \u2032 \u222a ASP(G), where G is a set of bitvectors, is implemented as \u03a0 \u2032 \u222a ASP({XB : (B \u2208 G) \u2227 (XB is the integer whose binary representation isB)}). 4. Aggregation: Answer sets of \u03a0 \u2032\u2032 are grouped by common k-/m-atoms of the form k0 `, k1 `, m0 `, and m1 `, each group representing a candidate world view. It is easy to see that a group\u2019s k-/m-atoms correspond to a guess \u03a6X for some X \u2208 G.\n5. Verification: For each group C representing a candidate world view, check that the following conditions are met for all its k-/m-atoms:\n(a) if k1 ` is in the sets of C, then ` is in every set of C; (b) if k0 ` is in the sets of C, then ` is missing from at least one set of C; (c) if m1 ` is in the sets of C, then ` is in at least one set of C; and (d) if m0 ` is in the sets of C, then ` is missing from every set of C.\nC\\km is a world view of \u03a0 if the conditions above are met."}, {"heading": "3.5 Correctness of Algorithm", "text": "The correctness of the algorithm follows from the proofs for soundness and completeness given in [20] when one considers that we are simply partitioning the search space into groups of manageable size (rather than generating all possible combinations of subjective literal truth values en masse) and imposing a popcount-level search order. It is easy to see that the maximality requirement of the new semantics is guaranteed by the level-based search order and filtering by considering that: \u2022 if a set of answer sets C corresponding to \u03a6C is found that satisfies the verification\nconditions of Step 5, then the ordered search and the filtering out of any corresponding \u03a6 \u2282 \u03a6C ensures that no previous world view W was found corresponding to \u03a6W such that \u03a6W \u2283 \u03a6C ; and \u2022 if a set of answer sets C corresponding to \u03a6C is found to be a world view, then any set C \u2032 corresponding to \u03a6C\u2032 where \u03a6C\u2032 \u2282 \u03a6C will be filtered out thereafter."}, {"heading": "4 Test Results", "text": "We tested an implementation of our algorithm on a DellTM PrecisionTM T3500 server with an Intel R\u00a9 Xeon R\u00a9W3670@3.2GHz with 6 cores and 12 GB RAM running CentOS v6.7 operating system. For the front-end, we used the ELPS solver by Balai [2] to convert an ELPS program (see [3]) to an associated ASP program, grounding it with ASP grounder gringo by Kaminski [23] in order to obtain what would be the result of Step 2 of our algorithm for a corresponding ground ELP from the ungrounded ELPS program. We then took the resulting ground ASP program as input to our solver, ELPsolve\u2014a loosely-coupled system that uses ASP solver clingo by Kaminski & Kaufmann [23].\nThis method allowed us to directly compare our solver performance with that of ELPS for the same input programs. The following table shows our results, giving the best run time (elapsed time in seconds) observed over the course of testing. A dash (\u2013) in the ELPS column indicates that a runtime error occurred due to insufficient memory.\n\u03a0 |EP (\u03a0)| ELPS ELPsolve \u03a0 |EP (\u03a0)| ELPS ELPsolve eligible01 2 <1s <1s yale1 5 <1s <1s eligible06 12 1s <1s yale2 8 <1s <1s eligible08 16 16s 1s yale3 11 <1s <1s eligible09 18 150s 2s yale4 14 <1s <1s eligible10 20 \u2013 4s yale5 17 13s <1s eligible12 24 \u2013 119s yale6 26 \u2013 <1s eligible14 28 \u2013 1667s yale7 30 \u2013 2s eligible16 32 \u2013 16124s yale8 34 \u2013 76s\nThe eligibleN programs are ELPS implementations of the scholarship eligibility problem (see [12]) with N corresponding to the number of students. The yaleN programs are ELPS implementations of a version of the Yale shooting problem (see [17]) that use the epistemic conformant planning module defined in [20] with N corresponding to the horizon (number of steps in a plan). For the yaleN programs, ELPsolve incorporates two heuristics found during analysis of the conformant planning module:\n1. reduction of the search space size by a factor of 4 by recognizing that two specific subjective literals must be satisfied in a world view;5 and 2. the horizon corresponds to a particular level (guess size) for searching.\nFigure 3 shows how run times for solving eligible12 with ELPsolve improve with an increase in the number of processors used. Note that although the 6-core Xeon processor in our test machine is hyperthread-enabled, it is unlikely that there would be any significant speed-up by simply increasing the number of processors assigned to multi-task beyond 6 as our implementation uses 2-thread multi-threading for each task.\nFigure 4 shows the peak memory usage for ELPS and ELPsolve (max #guesses per ASP call set at 300 for both 1 and 6 processors) when solving various eligibleN programs. Note the blue line curving sharply upward for ELPS asN grows whereas the memory required for ELPsolve remains relatively low and flat.\n5 This heuristic is generalizable, though a thorough discussion will be left for a future paper."}, {"heading": "5 Related Work", "text": "In [30], Yan Zhang investigated computational properties of epistemic logic programs, leading to the development of an algorithm for computing world views. Michael Kelly implemented the algorithm as solver Wviews [28], a project for his Honours Thesis.\nCui, Zhizheng Zhang and Zhao [7] investigated the problem of grounding an epistemic logic program. That work culminated in the development of a grounder known as ESParser. Their more recent efforts [34,33] include the development of an associated solver called ESmodels [25]. See [20] for a comparison of solver performance between ESmodels and ELPS.\nBalai and Kahl [3] extended Epistemic Specifications by adding a sorted signature. A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2]. Our solver complements this work by addressing the memory growth problem and updating it for the new semantics.\nZhizheng Zhang and Shutao Zhang [32] investigated combining ideas from Graded Modal Logic with ASP. Their langauge can be viewed as an extension of Epistemic Specifications, adding the modal concepts \u201cat least as many as\u201d and \u201cat most as many as\u201d to the language. They continued this work with Wang [31], referring to the language as GI-log. A GI-log solver called GIsolver [25] was developed using a generate-andtest algorithm similar (at a high level) to the one described in Algorithm 1.\nShen and Eiter [24] proposed the updated semantics used in this paper and implemented in our solver, albeit using different syntactic notation. Their work resolved most of the open questions raised in [19] and provided inspiration for our algorithm."}, {"heading": "6 Conclusions and Future Work", "text": "We improved the algorithm and developed a solver for epistemic logic programs that:\n\u2022 incorporates the latest semantics (as proposed by Shen & Eiter [24]), \u2022 addresses the memory issues that plague some other implementations, \u2022 uses multi-processing to improve performance, \u2022 allows early termination when desired number of solutions found, \u2022 solves harder programs faster, and \u2022 permits solving programs on a typical laptop computer that were previously beyond\nthe capabilities of other solvers with reasonable resources.\nFor the future, we plan to enhance our solver further by allowing the use of distributed processing to make it reasonable to solve more programs. We also plan to look at generalizing certain heuristics that could significantly reduce the search space for certain classes of programs. Finally, we plan to look at techniques such as multi-shot solving [11] to avoid the need for repeatedly restarting the ASP solver from scratch.\nWe observe that with small modification our implementation could solve GI-log programs [31], though a suitable front end is needed to handle the program syntax.\nFollow-up work will be to explore applications for the language as solver improvements make its use more practical. Promising areas include planning & scheduling, policy management, diagnostics, and computer-assisted decision making."}, {"heading": "Acknowledgments", "text": "We would like to acknowledge the efforts of Yi-Dong Shen and Thomas Eiter whose work provided a positive influence on the development of our solver. We thank Evgenii Balai for providing the front end to our solver by adding an extra option to ELPS to output the ASP translation. We couldn\u2019t produce our results without the use of gringo & clingo from the Potassco team, especially Roland Kaminski and Ben Kaufmann. Finally, we thank the anonymous reviewers for their comments and suggestions."}, {"heading": "Appendix: Proof of Semantic Equivalence to Shen-Eiter Semantics", "text": "In this appendix, we prove the equivalence between the semantics of epistemic logic programs (Section 2) and the semantics of logic programs with epistemic negation as defined by Shen & Eiter in [24].\nFor the benefit of the reader, the following table summarizes the notational differences between our language and that of Shen & Eiter for semantically equivalent forms.\nOUR NOTATION SE NOTATION TERMINOLOGY \u00ac \u223c classical (strong) negation not \u00ac default negation not K not epistemic negation\nK \u00ac not M not \u00ac\nnot M \u00ac not \u00ac\nLet \u03a0 be a ground epistemic logic program. Let r be a rule in \u03a0 . In this appendix, we use the following short hand to represent r:\nH \u2190 B+, not B\u2212, K L1, not K L2, M L3, not M L4 (1)\nwhereH is h1 or . . . or hn andB+,B\u2212, L1, ..., L4 are sets of objective literals. For L = {`1, ..., `m}, xL stands for {x`1, ..., x`m}with x \u2208 {not,K,not K,M,not M}. In Shen-Eiter notation [24], the above rule will become the following:\nH \u2190 B+, \u00acB\u2212, \u00ac not L1, not L2, not \u00acL3, \u00ac not \u00acL4 (2)\nWe denote by SE(x) the corresponding syntactic form of x in Shen-Eiter notation; e.g., SE(\u03a0) denotes the program obtained by translating \u03a0 to Shen-Eiter notation. We further define EP (SE(\u03a0)) as being equivalent to SE(EP (\u03a0)) (see Definition 3). When clear from the context, we may use \u03a6W to mean SE(\u03a6W), r to mean SE(r), etc.\nIn proving the correspondence between the two semantics, we make the following assumptions and notes:\n\u2022 The presence of classical negation can be eliminated using standard transformation (e.g., the one proposed in [16]). For this reason, we will assume that programs in consideration do not contain classical negation. \u2022 Shen-Eiter programs allow not \u00ac` (not K not ` in our notation) which we con-\nsider equivalent to M ` in our syntax. \u2022 In Shen-Eiter programs, \u00ac\u00ac` (not not ` in our notation) is treated as `.\nWe use \u201cX-reduct\u201d where X is \u201cKLS\u201d (to refer to the modal reduct discussed in this paper) or \u201cSE\u201d (to refer to the epistemic reduct proposed by Shen & Eiter in [24]). For ASP programs with nested default negation, a \u201cnested-negation removal transformation\u201d refers to the usual substitution of not not ` with not `\u2032 plus the addition of rule `\u2032 \u2190 not ` where `\u2032 is a fresh literal and answer sets are modulo `\u2032 as described in [22]. We use \u201cGelfond-Lifschitz transformation\u201d to refer to the reduction from logic programs with default negation to positive programs as per [16]. We say that a rule whose body contains a conjunct of the form \u00ac> in Shen-Eiter notation is a useless rule as this rule is always satisfied (body is false) and cannot be used to justify anything.\nIn the following, whenever we refer to a rule r, we mean a rule with sets of atoms L1, . . . , L4 as in (1). We use \u03a0 to denote an arbitrary but fixed ground epistemic logic program. Furthermore, for a program \u03a0, a set of sets of atoms W, a set A \u2208 W, and a rule r \u2208 \u03a0, by the reduct of r in (\u03a0W )A (resp. reduct of SE(r) in (SE(\u03a0)\u03a6W )A) we mean the rule (if it exists) obtained from r after:\n1. computing the modal reduct of\u03a0 with respect toW according to Definition 2 (resp. the epistemic reduct of SE(\u03a0) with respect to \u03a6W as per [24]); and then 2. computing the Gelfond-Lifschitz transformation on the result with respect to A.\nLemma 1. Let r be a rule in\u03a0 ,W be a collection of sets of atoms in\u03a0 , andA \u2208W. If there exists some ` \u2208 L1 of r such that W 6|= K ` then there is no reduct of r in (\u03a0W )A and either there is no reduct of r in (SE(\u03a0)\u03a6W )A or the reduct of r is a useless rule.\nProof. W 6|= K ` implies that r is removed in the KLS-reduct and hence (\u03a0W )A does not contain the reduct of r.\nW 6|= K ` means that W |= not K `. This means that not ` \u2208 \u03a6W . Thus, the SEreduct of r in SE(\u03a0) is a rule whose body contains \u00ac>, a useless rule. This implies that (SE(\u03a0)\u03a6W )A contains no reduct of r if the Gelfond-Lifschitz transformation removes it; or a useless rule, which is the reduct of r.\nLemma 2. Let r be a rule in\u03a0,W be a collection of sets of atoms in\u03a0, andA \u2208W. If there exists some ` \u2208 L2\u2229A such thatW 6|= not K`, then (\u03a0W )A and (SE(\u03a0)\u03a6W )A contain no reduct of r.\nProof. W 6|= not K ` implies that there exists some S \u2208 W such that ` 6\u2208 S. This implies that W 6|= not ` and so not ` 6\u2208 \u03a6W .\nLet r\u2032 and r\u2032\u2032 be the result obtained by applying the KLS-reduct and the SE-reduct on r, respectively. We have r\u2032 \u2208 \u03a0W and r\u2032\u2032 \u2208 SE(\u03a0)\u03a6W .\nSinceW 6|= not K`, not ` occurs in the body of r\u2032. Because ` \u2208 A, the GelfondLifschitz transformation will remove the rule r\u2032 from \u03a0W when constructing (\u03a0W )A, i.e., (\u03a0W )A does not contain the reduct of r.\nSimilarly, since not ` 6\u2208 \u03a6W , \u00ac` occurs in the body of r\u2032\u2032 in SE(\u03a0), and ` \u2208 A, the Gelfond-Lifschitz transformation will remove the rule r\u2032\u2032 when constructing (SE(\u03a0)\u03a6W )A, i.e., (SE(\u03a0)\u03a6W )A does not contain the reduct of r.\nSo, in this case, neither (\u03a0W )A nor (SE(\u03a0)\u03a6W )A contains the reduct of r.\nLemma 3. Let r be a rule in\u03a0 ,W be a collection of sets of atoms in\u03a0 andA \u2208W . If there exists some ` \u2208 L3 such that W 6|= M ` then (\u03a0W )A and (SE(\u03a0)\u03a6W )A contain no reduct of r or a useless reduct of r with respect to A.\nProof. W 6|= M ` implies that there exists no S \u2208 W such that ` \u2208 S, i.e., for every S \u2208W , ` 6\u2208 S. This implies that W 6|= not \u00ac` and so not \u00ac` 6\u2208 \u03a6W . This also implies that ` 6\u2208 A.\nIn this case, we observe that not not ` occurs in the body of the KLS-reduct r\u2032 of r in \u03a0W and \u00ac\u00ac` occurs in the body of the SE-reduct r\u2032\u2032 of r in SE(\u03a0)\u03a6W. Shen & Eiter treat \u00ac\u00ac` as `. Since ` 6\u2208 A, (SE(\u03a0)\u03a6W )A will contain no reduct of r (if it is removed by the Gelfond-Lifschitz reduct) or a useless rule with respect to A.\nIn KLS, nested default negation is treated differently. The nested-negation removal transformation results in not not ` appearing in the body of r\u2032. Furthermore, \u03a0W contains the rule \u201cnot `\u2190 not `\u201d where not ` is a fresh atom representing not `. Let\u03a0n be the programs obtained from\u03a0W after the nested-negation removal transformation. Because ` 6\u2208 A, any answer set A\u2032 of \u03a0n whose reduction results into A must contain not `. This implies that the Gelfond-Lifschitz transformation will remove r\u2032 from \u03a0n when constructing (\u03a0W )A.\nSo, in this case, (\u03a0W )A does not contain the reduct of r and (SE(\u03a0)\u03a6W )A contain no reduct of r or a useless reduct of r with respect to A.\nLemma 4. Let r be a rule in \u03a0 , W be a collection of sets of atoms in \u03a0 and A \u2208 W . If there exists some ` \u2208 L4 such that W 6|= not M ` then (\u03a0W )A contains no reduct of r and (SE(\u03a0)\u03a6W )A contains no reduct of r or a useless reduct of r.\nProof. W 6|= not M ` implies that r is removed in the KLS-reduct and hence (\u03a0W )A does not contain the reduct of r.\nW 6|= not M ` implies that there exists some S \u2208 W such that ` \u2208 S. It means that W 6|= K not ` and hence not \u00ac` \u2208 \u03a6W . Thus, the SE-reduct of r in SE(\u03a0)\u03a6W is a rule whose body contains \u00ac>. Again, this means that (SE(\u03a0)\u03a6W )A contains no reduct of r or a useless rule which is the reduct of r.\nTheorem 1. LetW be a collection of sets of atoms in\u03a0 .W is a world view of\u03a0 under the KLS semantics if and only if W is a candidate world view of SE(\u03a0) w.r.t. \u03a6W .\nProof. Observe that for each not ` occurring in SE(\u03a0), it holds that\n\u2022 if not ` \u2208 \u03a6W then not ` is true in W ; or \u2022 if not ` \u2208 EP (SE(\u03a0)) \\ \u03a6W then not ` is false in W .\nLet Lt2 = {` | ` \u2208 L2\u2227W |= not K `} and L f 2 = {` | ` \u2208 L2\u2227W 6|= not K `}. Let Lt3 = {` | ` \u2208 L3 \u2227 W |= M `} and L f 3 = {` | ` \u2208 L3 \u2227 W 6|= M `}. Consider A \u2208 W and let r be a rule of the form (1). Lemmas 1-4 show that if (\u03a0W )A or (SE(\u03a0)\u03a6W )A contains a useful reduct of r then the following conditions hold:\n\u2022 L1 \u2286 A (Lemma 1). \u2022 for every ` \u2208 Lf2 , ` 6\u2208 A (Lemma 2). \u2022 Lf3 = \u2205 (Lemma 3). \u2022 L4 \u2229A = \u2205 (Lemma 4). \u2022 B\u2212 \u2229 A = \u2205 (otherwise, the rule will be removed by the Gelfond-Liftschitz\ntransformation).\nUnder the above conditions, the reduct of r in \u03a0W is\nr\u2032 : H \u2190 B+, not B\u2212, L1, not Lf2 , not L4\nand its reduct in (SE(\u03a0))\u03a6W is\nr\u2032\u2032 : H \u2190 B+, not B\u2212,\u00ac\u00acL1,\u00acLf2 ,\u00ac\u00ac\u00acL4\nSince \u00ac\u00acL = L as stated in Shen & Eiter\u2019s proposal and because L4 \u2229 A = \u2205 and Lf2 \u2229A = \u2205, we can conclude that the reduct of r in (\u03a0W )A and in (SE(\u03a0)\u03a6W )A is\nr+ : `1 or `2 . . . or `n \u2190 B+, L1\nIn other words, we have that (\u03a0W )A is identical6 to (SE(\u03a0)\u03a6W )A. As such, if W is a world view of \u03a0 , A is an answer set of (\u03a0W )A, i.e., A is also an answer set of (SE(\u03a0)\u03a6W )A. Conversely, if W is a candidate world view of \u03a0 with respect to \u03a6W then A is an answer set of (SE(\u03a0)\u03a6W )A and hence also an answer set of (\u03a0W )A. Since this holds for every A \u2208W , we have the conclusion of the theorem.\n6 with the exception of the useless rules in different programs and some extra fresh atoms such as not a representing not a and the rule not a \u2190 not a introduced to deal with not not a; such atoms can be eliminated by using the splitting set theorem and the fact that, by construction, not not a appears in \u03a0W only if a 6\u2208 A"}], "references": [{"title": "Texas Tech University, software & documentation available for download at https://github.com/iensen/elps/wiki", "author": ["E. Balai"], "venue": "ELPS", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2015}, {"title": "Epistemic logic programs with sorts", "author": ["E. Balai", "P. Kahl"], "venue": "Inclezan, D., Maratea, M. (eds.) ASPOCP 2014", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "sismodels (2001), see http://www.mbal.tk/ for more information", "author": ["M. Balduccini"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2001}, {"title": "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning\u2014Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday, Lecture Notes in Computer Science, vol", "author": ["M. Balduccini", "Son", "T.C. (eds."], "venue": "6565. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Knowledge Representation, Reasoning, and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "ESParser: An epistemic specification grounder", "author": ["R. Cui", "Z. Zhang", "K. Zhao"], "venue": "Delgrande, J.P., Faber, W. (eds.) CSSS-12. pp. 1823\u20131827. IEEE Computer Society CPS", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Epistemic equilibrium logic", "author": ["L. Fari\u00f1as del Cerro", "A. Herzig", "E.I. Su"], "venue": "Yang, Q., Wooldridge, M. (eds.) IJCAI 2015. AAAI Press / IJCAI", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2015}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan & Claypool Publishers", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Clingo = ASP + control: Preliminary report", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Kowalski, R.A., Bowen, K.A. (eds.) ICLP 2014. vol. abs/1405.3694. The MIT Press", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Strong introspection", "author": ["M. Gelfond"], "venue": "Dean, T.L., McKeown, K. (eds.) AAAI-91. vol. 1, pp. 386\u2013391. AAAI Press / The MIT Press", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1991}, {"title": "Logic programming and reasoning with incomplete information", "author": ["M. Gelfond"], "venue": "Annals of Mathematics and Artificial Intelligence 12(1\u20132), 89\u2013116", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1994}, {"title": "New definition of epistemic specifications", "author": ["M. Gelfond"], "venue": "Delgrande, J.P., Faber, W. (eds.) LPNMR-11. Lecture Notes in Computer Science, vol. 6645, pp. 260\u2013265. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "Knowledge Representation, Reasoning, and the Design of Intelligent Agents: The Answer-Set Programming Approach", "author": ["M. Gelfond", "Y. Kahl"], "venue": "Cambridge University Press", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2014}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9(3/4), 365\u2013385", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1991}, {"title": "Nonmonotonic logic and temporal projection", "author": ["S. Hanks", "D. McDermott"], "venue": "Artificial Intelligence 33(3), 379\u2013412", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1987}, {"title": "Handbook of Knowledge Representation", "author": ["F. van Harmelen", "V. Lifschitz", "Porter", "B. (eds."], "venue": "Foundations of Artificial Intelligence, Elsevier", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Refining the Semantics for Epistemic Logic Programs", "author": ["P. Kahl"], "venue": "Ph.D. thesis, Texas Tech University, Lubbock, TX, USA", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "The language of epistemic specifications (refined) including a prototype solver", "author": ["P. Kahl", "R. Watson", "E. Balai", "M. Gelfond", "Y. Zhang"], "venue": "Journal of Logic and Computation", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Wviews: A Worldview Solver for Epistemic Logic Programs", "author": ["M. Kelly"], "venue": "Honour\u2019s thesis, University of Western Sydney", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2007}, {"title": "Nested expressions in logic programs", "author": ["V. Lifschitz", "L.R. Tang", "H. Turner"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 369\u2013389", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1999}, {"title": "Evaluating epistemic negation in answer set programming", "author": ["Y.D. Shen", "T. Eiter"], "venue": "Artificial Intelligence 237, 115\u2013135", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2016}, {"title": "Extensions of Equilibrium Logic by Modal Concepts", "author": ["E.I. Su"], "venue": "Ph.D. thesis, University of Toulouse, Toulouse, France", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2015}, {"title": "An Inference Engine for Epistemic Specifications", "author": ["R.G. Watson"], "venue": "Master\u2019s thesis, University of Texas at El Paso", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1994}, {"title": "Computational properties of epistemic logic programs", "author": ["Y. Zhang"], "venue": "Doherty, P., Mylopoulos, J., Welty, C.A. (eds.) KR-06. pp. 308\u2013317. AAAI Press", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2006}, {"title": "Logic programming with graded introspection", "author": ["Z. Zhang", "B. Wang", "S. Zhang"], "venue": "Inclezan, D., Maratea, M. (eds.) ASPOCP 2015", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2015}, {"title": "Logic programming with graded modality", "author": ["Z. Zhang", "S. Zhang"], "venue": "Calimeri, F., Ianni, G., Truszczy\u0144ski, M. (eds.) LPNMR 2015. Lecture Notes in Artificial Intelligence, vol. 9345. Springer-Verlag", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2015}, {"title": "ESmodels: An epistemic specification solver", "author": ["Z. Zhang", "K. Zhao"], "venue": "CoRR abs/1405.3486", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2014}, {"title": "ESmodels: An inference engine of epistemic specifications", "author": ["Z. Zhang", "K. Zhao", "R. Cui"], "venue": "Luo, J. (ed.) ICTAI 2013. pp. 769\u2013774. IEEE", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2013}], "referenceMentions": [{"referenceID": 9, "context": "The language of Epistemic Specifications [12,13] was introduced in the early 1990s by Michael Gelfond after observing the need for more powerful introspective reasoning than that offered by answer set programming (ASP) alone, extending ASP with modal operators K (\u201cknown\u201d) and M (\u201cmay be true\u201d).", "startOffset": 41, "endOffset": 48}, {"referenceID": 10, "context": "The language of Epistemic Specifications [12,13] was introduced in the early 1990s by Michael Gelfond after observing the need for more powerful introspective reasoning than that offered by answer set programming (ASP) alone, extending ASP with modal operators K (\u201cknown\u201d) and M (\u201cmay be true\u201d).", "startOffset": 41, "endOffset": 48}, {"referenceID": 11, "context": "A renewed interest in Epistemic Specifications [27,8] in 2011 included a proposed change to the semantics by Gelfond [14] in a preliminary effort to avoid unintended world views.", "startOffset": 117, "endOffset": 121}, {"referenceID": 16, "context": "[19,20] in the hopes of finding a satisfactory semantics with respect to intuition and modeling of problems.", "startOffset": 0, "endOffset": 7}, {"referenceID": 17, "context": "[19,20] in the hopes of finding a satisfactory semantics with respect to intuition and modeling of problems.", "startOffset": 0, "endOffset": 7}, {"referenceID": 21, "context": "[26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.", "startOffset": 0, "endOffset": 6}, {"referenceID": 6, "context": "[26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.", "startOffset": 0, "endOffset": 6}, {"referenceID": 20, "context": "[26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.", "startOffset": 41, "endOffset": 45}, {"referenceID": 22, "context": "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang\u2019s algorithm [30], ESmodels by Zhizheng Zhang et al.", "startOffset": 129, "endOffset": 133}, {"referenceID": 2, "context": "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang\u2019s algorithm [30], ESmodels by Zhizheng Zhang et al.", "startOffset": 159, "endOffset": 162}, {"referenceID": 18, "context": "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang\u2019s algorithm [30], ESmodels by Zhizheng Zhang et al.", "startOffset": 180, "endOffset": 187}, {"referenceID": 23, "context": "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang\u2019s algorithm [30], ESmodels by Zhizheng Zhang et al.", "startOffset": 223, "endOffset": 227}, {"referenceID": 5, "context": "[25,7,34,33], and most recently ELPS by Balai [2,3].", "startOffset": 0, "endOffset": 12}, {"referenceID": 27, "context": "[25,7,34,33], and most recently ELPS by Balai [2,3].", "startOffset": 0, "endOffset": 12}, {"referenceID": 26, "context": "[25,7,34,33], and most recently ELPS by Balai [2,3].", "startOffset": 0, "endOffset": 12}, {"referenceID": 0, "context": "[25,7,34,33], and most recently ELPS by Balai [2,3].", "startOffset": 46, "endOffset": 51}, {"referenceID": 1, "context": "[25,7,34,33], and most recently ELPS by Balai [2,3].", "startOffset": 46, "endOffset": 51}, {"referenceID": 4, "context": "For a good introduction, see any of [6,18,10,15].", "startOffset": 36, "endOffset": 48}, {"referenceID": 15, "context": "For a good introduction, see any of [6,18,10,15].", "startOffset": 36, "endOffset": 48}, {"referenceID": 7, "context": "For a good introduction, see any of [6,18,10,15].", "startOffset": 36, "endOffset": 48}, {"referenceID": 12, "context": "For a good introduction, see any of [6,18,10,15].", "startOffset": 36, "endOffset": 48}, {"referenceID": 16, "context": "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].", "startOffset": 84, "endOffset": 91}, {"referenceID": 17, "context": "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].", "startOffset": 84, "endOffset": 91}, {"referenceID": 20, "context": "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].", "startOffset": 147, "endOffset": 151}, {"referenceID": 19, "context": "1 with nested expressions of the form not not ` as defined in [22]", "startOffset": 62, "endOffset": 66}, {"referenceID": 16, "context": "Note here the addition of a maximality requirement on \u03a6W with respect to other guesses (corresponding to other candidate world views) that is not in the semantics of [19,20].", "startOffset": 166, "endOffset": 173}, {"referenceID": 17, "context": "Note here the addition of a maximality requirement on \u03a6W with respect to other guesses (corresponding to other candidate world views) that is not in the semantics of [19,20].", "startOffset": 166, "endOffset": 173}, {"referenceID": 20, "context": "See [24] for discussion concerning the intuition behind the proposed new semantics.", "startOffset": 4, "endOffset": 8}, {"referenceID": 20, "context": "The semantics of an epistemic logic program \u03a0 as described herein is equivalent to the semantics described by Shen & Eiter in [24] for \u03a0 translated to their syntax.", "startOffset": 126, "endOffset": 130}, {"referenceID": 20, "context": "Although we prefer our syntax to that proposed in [24], we find the definition of an epistemic reduct an excellent tool for describing the new semantics, particularly with the emphasis on our ELP solver.", "startOffset": 50, "endOffset": 54}, {"referenceID": 20, "context": "2 introduced by Shen & Eiter in [24] using a different syntax (see the appendix) 3 K ` and not K ` are complements; M ` and not M ` are complements", "startOffset": 32, "endOffset": 36}, {"referenceID": 17, "context": "One such translation was proposed in [20].", "startOffset": 37, "endOffset": 41}, {"referenceID": 17, "context": "This filter can be turned off to revert to the semantics of [20].", "startOffset": 60, "endOffset": 64}, {"referenceID": 17, "context": "For the translation of an ELP \u03a0 to an ASP program, we use a variant of the one developed in [20].", "startOffset": 92, "endOffset": 96}, {"referenceID": 17, "context": "We note that this translation is slightly different from the translation in [20] in that it does not add the rules for guessing the values of elements in EP (\u03a0).", "startOffset": 76, "endOffset": 80}, {"referenceID": 17, "context": "The correctness of the algorithm follows from the proofs for soundness and completeness given in [20] when one considers that we are simply partitioning the search space into groups of manageable size (rather than generating all possible combinations of subjective literal truth values en masse) and imposing a popcount-level search order.", "startOffset": 97, "endOffset": 101}, {"referenceID": 0, "context": "For the front-end, we used the ELPS solver by Balai [2] to convert an ELPS program (see [3]) to an associated ASP program, grounding it with ASP grounder gringo by Kaminski [23] in order to obtain what would be the result of Step 2 of our algorithm for a corresponding ground ELP from the ungrounded ELPS program.", "startOffset": 52, "endOffset": 55}, {"referenceID": 1, "context": "For the front-end, we used the ELPS solver by Balai [2] to convert an ELPS program (see [3]) to an associated ASP program, grounding it with ASP grounder gringo by Kaminski [23] in order to obtain what would be the result of Step 2 of our algorithm for a corresponding ground ELP from the ungrounded ELPS program.", "startOffset": 88, "endOffset": 91}, {"referenceID": 9, "context": "The eligibleN programs are ELPS implementations of the scholarship eligibility problem (see [12]) with N corresponding to the number of students.", "startOffset": 92, "endOffset": 96}, {"referenceID": 14, "context": "The yaleN programs are ELPS implementations of a version of the Yale shooting problem (see [17]) that use the epistemic conformant planning module defined in [20] with N corresponding to the horizon (number of steps in a plan).", "startOffset": 91, "endOffset": 95}, {"referenceID": 17, "context": "The yaleN programs are ELPS implementations of a version of the Yale shooting problem (see [17]) that use the epistemic conformant planning module defined in [20] with N corresponding to the horizon (number of steps in a plan).", "startOffset": 158, "endOffset": 162}, {"referenceID": 23, "context": "In [30], Yan Zhang investigated computational properties of epistemic logic programs, leading to the development of an algorithm for computing world views.", "startOffset": 3, "endOffset": 7}, {"referenceID": 5, "context": "Cui, Zhizheng Zhang and Zhao [7] investigated the problem of grounding an epistemic logic program.", "startOffset": 29, "endOffset": 32}, {"referenceID": 27, "context": "Their more recent efforts [34,33] include the development of an associated solver called ESmodels [25].", "startOffset": 26, "endOffset": 33}, {"referenceID": 26, "context": "Their more recent efforts [34,33] include the development of an associated solver called ESmodels [25].", "startOffset": 26, "endOffset": 33}, {"referenceID": 17, "context": "See [20] for a comparison of solver performance between ESmodels and ELPS.", "startOffset": 4, "endOffset": 8}, {"referenceID": 1, "context": "Balai and Kahl [3] extended Epistemic Specifications by adding a sorted signature.", "startOffset": 15, "endOffset": 18}, {"referenceID": 17, "context": "A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2].", "startOffset": 35, "endOffset": 42}, {"referenceID": 16, "context": "A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2].", "startOffset": 35, "endOffset": 42}, {"referenceID": 0, "context": "A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2].", "startOffset": 91, "endOffset": 94}, {"referenceID": 25, "context": "Zhizheng Zhang and Shutao Zhang [32] investigated combining ideas from Graded Modal Logic with ASP.", "startOffset": 32, "endOffset": 36}, {"referenceID": 24, "context": "They continued this work with Wang [31], referring to the language as GI-log.", "startOffset": 35, "endOffset": 39}, {"referenceID": 20, "context": "Shen and Eiter [24] proposed the updated semantics used in this paper and implemented in our solver, albeit using different syntactic notation.", "startOffset": 15, "endOffset": 19}, {"referenceID": 16, "context": "Their work resolved most of the open questions raised in [19] and provided inspiration for our algorithm.", "startOffset": 57, "endOffset": 61}, {"referenceID": 20, "context": "\u2022 incorporates the latest semantics (as proposed by Shen & Eiter [24]), \u2022 addresses the memory issues that plague some other implementations, \u2022 uses multi-processing to improve performance, \u2022 allows early termination when desired number of solutions found, \u2022 solves harder programs faster, and \u2022 permits solving programs on a typical laptop computer that were previously beyond the capabilities of other solvers with reasonable resources.", "startOffset": 65, "endOffset": 69}, {"referenceID": 8, "context": "Finally, we plan to look at techniques such as multi-shot solving [11] to avoid the need for repeatedly restarting the ASP solver from scratch.", "startOffset": 66, "endOffset": 70}, {"referenceID": 24, "context": "We observe that with small modification our implementation could solve GI-log programs [31], though a suitable front end is needed to handle the program syntax.", "startOffset": 87, "endOffset": 91}], "year": 2016, "abstractText": "As the practical use of answer set programming (ASP) has grown with the development of efficient solvers, we expect a growing interest in extensions of ASP as their semantics stabilize and solvers supporting them mature. Epistemic Specifications, which adds modal operators K and M to the language of ASP, is one such extension. We call a program in this language an epistemic logic program (ELP). Solvers have thus far been practical for only the simplest ELPs due to exponential growth of the search space. We describe a solver that is able to solve harder problems better (e.g., without exponentially-growing memory needs w.r.t. K and M occurrences) and faster than any other known ELP solver.", "creator": "LaTeX with hyperref package"}}}