{"id": "1608.07115", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Aug-2016", "title": "Aligning Packed Dependency Trees: a theory of composition for distributional semantics", "abstract": "we present a new framework for compositional distributional semantics in which the distributional contexts of different lexemes are expressed in terms of anchored packed dependency density trees. we show that these structures have the potential to capture the full term sentential contexts of construct a data lexeme and provide a uniform lattice basis for the composition of distributional knowledge in a way specifically that captures both mutual disambiguation and generalization.", "histories": [["v1", "Thu, 25 Aug 2016 12:44:05 GMT  (294kb,D)", "http://arxiv.org/abs/1608.07115v1", "To appear in Special issue of Computational Linguistics - Formal Distributional Semantics"]], "COMMENTS": "To appear in Special issue of Computational Linguistics - Formal Distributional Semantics", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["david weir", "julie weeds", "jeremy reffin", "thomas kober"], "accepted": false, "id": "1608.07115"}, "pdf": {"name": "1608.07115.pdf", "metadata": {"source": "CRF", "title": "Aligning Packed Dependency Trees: a theory of composition for distributional semantics", "authors": ["David Weir", "Julie Weeds", "Jeremy Reffin", "Thomas Kober"], "emails": ["d.j.weir@sussex.ac.uk", "j.e.weeds@sussex.ac.uk", "j.p.reffin@sussex.ac.uk", "t.kober@sussex.ac.uk"], "sections": [{"heading": "1 Introduction", "text": "This paper addresses a central unresolved issue in distributional semantics: how to model semantic composition. Although there has recently been considerable interest in this problem, it remains unclear what distributional composition actually means. Our view is that distributional composition is a matter of contextualizing the lexemes being composed. This goes well beyond traditional word sense disambiguation, where each lexeme is assigned one of a fixed number of senses. Our proposal is that composition involves deriving a finegrained characterization of the distributional meaning of each lexeme in the phrase, where the meaning that is associated with each lexeme is bespoke to that particular context.\nDistributional composition is, therefore, a matter of integrating the meaning of each of the lexemes in the phrase. To achieve this we need a structure within which all of the lexemes\u2019 semantics can be overlaid. Once this is done, the lexemes can collectively agree on the semantics of the phrase, and in so doing, determine the semantics that they have in the context of that phrase. Our process of composition thus creates a single structure that encodes contextualized representations of every lexeme in the phrase.\nThe (uncontextualized) distributional knowledge of a lexeme is typically formed by aggregating distributional features across all uses of the lexeme found within the corpus, where distributional features arise from co-occurrences found in the corpus. The distributional features of a lexeme are associated with weights that encode the strength of that feature. Contextualization involves inferring adjustments to these weights to reflect the context in which the lexeme is being used. The weights of distributional features that don\u2019t fit the context are reduced, while the weight of those features that are compatible with the context can be boosted.\nAs an example, consider how we contextualize the distributional features of the word wooden in the context of the phrase wooden floor. The uncontextualized representation of wooden presumably includes distributional features associated with different uses, for example The director fired the wooden actor and I sat on the wooden chair. So, while we may have observed in a corpus that it is plausible for the adjective wooden to modify floor, table, toy, actor and voice, in the specific context of the phrase wooden floor, we need to find a way to down-weight the distributional features of being something that can modify\nar X\niv :1\n60 8.\n07 11\n5v 1\n[ cs\n.C L\n] 2\n5 A\nug 2\nactor and voice, while up-weighting the distributional features of being something that can modify table and toy.\nIn the example above we considered so-called first-order distributional features; these involve a single dependency relation, e.g. an adjective modifying a noun. Similar inferences can also be made with respect to distributional features that involve higher-order grammatical dependencies1. For example, suppose that we have observed that a noun that wooden modifies (e.g. actor) can be the direct object of the verb fired, as in The director fired the wooden actor. We want this distributional feature of wooden to be down-weighted in the distributional representation of wooden in the context of wooden table, since things made of wood do not typically lose their job.\nIn addition to specialising the distributional representation of wood to reflect the context wooden floor, the distributional representation of floor should also be refined, downweighting distributional features arising in contexts such as Prices fell through the floor, while up-weighting distributional features arising in contexts such as I polished the concrete floor.\nIn our example, some of the distributional features of wooden, in particular, those to do with the noun that this sense of wooden could modify, are internal to the phrase wooden floor in the sense that they are alternatives to one of the words in the phrase. Although it is specifically a floor that is wooden, our proposal is that the contextualized representation of wooden should recognise that it is plausible that nouns such as chair and toy could be modified by the particular sense of wooden that is being used. The remaining distributional features are external to the phrase. For example, the verb mop could be an external feature, since things that can be modified by wooden can be the direct object of mop. The external features of wooden and floor with respect to the phrase wooden floor provide something akin to the traditional interpretation of the distributional semantics of the phrase, i.e. a representation of those (external) contexts in which this phrase can occur.\nWhile internal features are, in a sense, inconsistent with the specific semantics of the phrase, they provide a way to embellish the characterization of the distributional meaning of the lexemes in the phrase. Recall that our goal is to infer a rich and fine-grained representation of the contextualized distributional meaning of each of the lexemes in the phrase.\nHaving introduced the proposal that distributional composition should be viewed as a matter of contextualization, the question arises as to how to realise this conception. Since each lexeme in the phrase needs to be able to contribute to the contextualization of the other lexemes in the phrase, we need to be able to align what we know about each of the lexeme\u2019s distributional features so that this can be achieved. The problem is that the uncontextualized distributional knowledge associated with the different lexemes in the phrase take a different perspective on the feature space. To overcome this we need to: (a) provide a way of structuring the distributional feature space, which we do by typing distributional features with dependency paths; and (b) find a way to systematically modify the perspective that each lexeme has on this structured feature space in such a way that they are all aligned with one another.\nFollowing Baroni and Lenci (2010), we use typed dependency relations as the bases for our distributional features, and following Pado\u0301 and Lapata (2007), we include higher-order dependency relations in this space. However, in contrast to previous proposals, the higher order dependency relations provides structure to the space which is crucial to our definition of composition. Each co-occurrence associated with a lexeme such as wooden is typed by the path in the dependency tree that connects the lexeme wooden with the co-occurring lexeme, e.g. fired. This allows us to encode a lexeme\u2019s distributional knowledge with a hierarchical structure that we call an Anchored Packed Dependency Tree (Apt). As we show, this data structure provides a way for us to align the distributional knowledge of the lexemes that are being composed in such a way that the inferences needed to achieve contextualization can be implemented.\n1Given some dependency tree, a k-th order dependency holds between two lexemes (nodes) in the tree when the path between the two lexemes has length k."}, {"heading": "2 The Distributional Lexicon", "text": "In this section, we begin the formalisation of our proposal by describing the distributional lexicon: a collection of entries that characterize the distributional semantics of lexemes. Table 1 provides a summary of the notation that we are using.\nLet V be a finite alphabet of lexemes2, where each lexeme is assumed to incorporate a part-of-speech tag; let R be a finite alphabet of grammatical dependency relations; and let TV,R be the set of dependency trees where every node is labeled with a member of V , and every directed edge is labeled with an element of R. Figure 1 shows eight examples of dependency trees.\n2There is no reason why lexemes could not include multi-word phrases tagged with an appropriate part of speech."}, {"heading": "2.1 Typed Co-occurrences", "text": "When two lexemes w and w\u2032 co-occur in a dependency tree3 in t \u2208 TV,R, we represent this co-occurrence as a triple \u27e8w, \u03c4, w\u2032\u27e9 where \u03c4 is a string that encodes the co-occurrence type of this co-occurrence, capturing the syntactic relationship that holds between these occurrences of the two lexemes. In particular, \u03c4 encodes the sequence of dependencies that lie along the path in t between the occurrences of w and w\u2032 in t. In general, a path from w to w\u2032 in t initially travels up towards the root of t (against the directionality of the dependency edges) until an ancestor of w\u2032 is reached. It then travels down the tree to w\u2032 (following the directionality of the dependencies). The string \u03c4 must, therefore, not only encode the sequence of dependency relations appearing along the path, but also whether each edge is traversed in a forward or backward direction. In particular, given the path \u27e8v0, . . . , vk\u27e9 in t, where k > 0, w labels v0 and w\u2032 labels vk, the string \u03c4 = x1 . . . xk encodes the co-occurrence type associated with this path as follows:\n\u2022 if the edge connecting vi\u22121 and vi runs from vi\u22121 to vi and is labeled by r then xi = r; and\n\u2022 if the edge connecting vi\u22121 and vi runs from vi to vi\u22121 and is labeled by r then xi = r.\nHence, co-occurrence types are strings in R\u2217R\u2217, where R = { r \u2223 r \u2208 R }. It is useful to be able to refer to the order of a co-occurrence type, where this simply refers to the length of the dependency path. It is also convenient to be able to refer to the inverse of a co-occurrence type. This can be thought of as the same path, but traversed in the reverse direction. To be precise, given the co-occurrence type \u03c4 = x1 \u22c5 . . . \u22c5 xn where each xi \u2208 R\u222aR for 1 \u2264 i \u2264 n, the inverse of \u03c4 , denoted \u03c4\u22121, is the path xn\u22121 \u22c5 . . . \u22c5x1\u22121 where r\u22121 = r and r\u22121 = r for r \u2208 R. For example, the inverse of amod\u22c5dobj\u22c5nsubj is nsubj\u22c5dobj\u22c5amod.\nThe following typed co-occurrences for the lexeme white/JJ arise in the tree shown in Figure 1(a).\n\u27e8white/JJ, amod\u22c5dobj\u22c5nsubj, we/PRP\u27e9 \u27e8white/JJ, amod\u22c5amod, fizzy/JJ\u27e9 \u27e8white/JJ, amod\u22c5dobj, bought/VBD\u27e9 \u27e8white/JJ, amod\u22c5amod, dry/JJ\u27e9 \u27e8white/JJ, amod\u22c5det, the/DT\u27e9 \u27e8white/JJ, , white/JJ\u27e9 \u27e8white/JJ, amod\u22c5amod\u22c5advmod, slightly/RB\u27e9 \u27e8white/JJ, amod, wine/NN\u27e9\nNotice that we have included the co-occurrence \u27e8white/JJ, , white/JJ\u27e9. This gives a uniformity to our typing system that simplifies the formulation of distributional composition in Section 4, and leads to the need for a refinement to our co-occurrence type encodings. Since we permit paths that traverse both forwards and backwards along the same dependency, e.g. in the co-occurrence \u27e8white/JJ, amod\u22c5amod, dry/JJ\u27e9, it is logical to consider \u27e8white/JJ, amod\u22c5dobj\u22c5dobj\u22c5amod, dry/JJ\u27e9 a valid co-occurrence. However, in line with our decision to include \u27e8white/JJ, , white/JJ\u27e9 rather than \u27e8white/JJ, amod\u22c5amod, white/JJ\u27e9, all co-occurrence types are canonicalized through a dependency cancellation process in which adjacent, complementary dependencies are cancelled out. In particular, all occurrences within the string of either rr or rr for r \u2208 R are replaced with , and this process is repeated until no further reductions are possible.\nThe reduced co-occurrence type produced from \u03c4 is denoted \u2193(\u03c4), and defined as follows:\n\u2193(\u03c4) = { \u2193(\u03c41\u03c42) if \u03c4 = \u03c41 r r \u03c42 or \u03c4 = \u03c41 r r \u03c42 for some r \u2208 R \u03c4 otherwise\n(1)\nFor the remainder of the paper, we only consider reduced co-occurrence types when associating a type with a co-occurrence.\nGiven a tree t \u2208 TV,R, lexemes w and w\u2032 and reduced co-occurrence type \u03c4 , the number of times that the co-occurrence \u27e8w, \u03c4, w\u2032\u27e9 occurs in t is denoted #(\u27e8w, \u03c4, w\u2032\u27e9, t), and, given some corpus C of dependency trees, the sum of all #(\u27e8w, \u03c4, w\u2032\u27e9, t) across all t \u2208 C is denoted\n3In order to avoid over-complicating our presentation, when possible, we do not distinguish between a node in a dependency tree and the lexeme that appears at that node.\n#\u27e8w, \u03c4, w\u2032\u27e9. Note that in order to simplify our notation, the dependence on the corpus C is not expressed in our notation.\nIt is common to use alternatives to raw counts in order to capture the strength of each distributional feature. A variety of alternatives are considered during the experimental work presented in Section 5. Among the options we have considered are probabilities and various versions of positive pointwise mutual information. While, in practice, the precise method for weighting features is of practical importance, it is not an intrinsic part of the theory that this paper is introducing. In the exposition below we denote the weight of the distributional feature \u27e8 \u03c4,w\u2032 \u27e9 of the lexeme w with the expression w(w, \u27e8 \u03c4,w\u2032 \u27e9)."}, {"heading": "2.2 Anchored Packed Trees", "text": "Given a dependency tree corpus C \u2282 TV,R and a lexeme w \u2208 V , we are interested in capturing the aggregation of all distributional contexts of w in C within a single structure. We achieve this with what we call an Anchored Packed Tree (Apt). Apts are central to the proposals in this paper: not only can they be used to encode the aggregate of all distributional features of a lexeme over a corpus of dependency trees, but they can also be used to express the distributional features of a lexeme that has been contextualized within some dependency tree (see Section 4).\nThe Apt for w given C, is denoted \u2225w\u2225, and referred to as the elementary Apt for w. Below, we describe a tree-based interpretation of \u2225w\u2225, but in the first instance we define it as a mapping from pairs (\u03c4,w\u2032) where \u03c4 \u2208 R\u2217R\u2217 and w\u2032 \u2208 V , such that \u2225w\u2225(\u03c4,w\u2032) gives the weight of the typed co-occurrence \u27e8w, \u03c4, w\u2032\u27e9 in the corpus C. It is nothing more than those components of the weight function that specify the weights of distributional features of w. In other words, for each \u03c4 \u2208 R\u2217R\u2217 and w\u2032 \u2208 V :\n\u2225w\u2225(\u03c4,w\u2032) =w(w, \u27e8 \u03c4,w\u2032 \u27e9) (2)\nThe restriction of \u2225w\u2225 to co-occurrence types that are at most order k is referred to as a k-th order Apt. The distributional lexicon derived from a corpus C is a collection of lexical entries where the entry for the lexeme w is the elementary Apt \u2225w\u2225.\nFormulating Apts as functions simplifies the definitions that appear below. However, since an Apt encodes co-occurrences that are aggregated over a set of dependency trees, they can also be interpreted as having a tree structure. In our tree-based interpretation of Apts, nodes are associated with weighted multisets of lexemes. In particular, \u2225w\u2225(\u03c4) is thought of as a node that is associated with the weighted lexeme multiset in which the weight of w\u2032 in the multiset is \u2225w\u2225(\u03c4,w\u2032). We refer to the node \u2225w\u2225( ) as the anchor of the Apt \u2225w\u2225.\nFigure 2 shows three elementary Apts that can be produced from the corpus shown in Figure 1. On the far left we give the letter corresponding to the sentence in Figure 1 that generated the typed co-occurrences. Each column corresponds to one node in the Apt, giving the multiset of lexemes at that node. Weights are not shown, and only non-empty nodes are displayed.\nIt is worth dwelling on the contents of the anchor node of the top Apt in Figure 2, which is the elementary Apt for dry/JJ. The weighted multiset at the anchor node is denoted \u2225w\u2225( ). The lexeme dry/JJ occurs three times, and the weight \u2225w\u2225( ,dry/JJ) reflects this count. Three other lexemes also occur at this same node: fizzy/JJ, white/JJ and clean/JJ. These lexemes arose from the following co-occurrences in trees in Figure 1: \u27e8dry/JJ, amod\u22c5amod, fizzy/JJ\u27e9, \u27e8dry/JJ, amod\u22c5amod, white/JJ\u27e9 and \u27e8dry/JJ, amod\u22c5amod, clean/JJ\u27e9, all of which involve the co-occurrence type amod \u22c5amod. These lexemes appear in the multiset \u2225w\u2225( ) because \u2193 (amod\u22c5amod) = ."}, {"heading": "3 Apt Similarity", "text": "One of the most fundamental aspects of any treatment of distributional semantics is that it supports a way of measuring distributional similarity. In this section, we describe a\nstraightforward way in which the similarity of two Apts can be measured through a mapping from Apts to vectors.\nFirst define the set of distributional features\nfeats = { \u27e8 \u03c4,w\u2032 \u27e9 \u2223 w\u2032 \u2208 V , \u03c4 \u2208 R\u2217R\u2217 and w(w, \u27e8 \u03c4,w\u2032 \u27e9) > 0 for some w \u2208 V } (3)\nThe vector space that we use to encode Apts includes one dimension for each element of feats, and we use the pair \u27e8 \u03c4,w \u27e9 to refer to its corresponding dimension.\nGiven an Apt A, we denote the vectorized representation of A with \u00d0\u2192 A, and the value that the vector \u00d0\u2192 A has on dimension \u27e8 \u03c4,w\u2032 \u27e9 is denoted \u00d0\u2192A [\u27e8 \u03c4,w\u2032 \u27e9]. For each \u27e8 \u03c4,w\u2032 \u27e9 \u2208 feats:\n\u00d0\u00d0\u2192 \u2225w\u2225 [\u27e8 \u03c4,w\u2032 \u27e9] = \u03c6(\u03c4,w)w(w, \u27e8 \u03c4,w\u2032 \u27e9) (4)\nwhere \u03c6(\u03c4,w) is a path weighting function which is intended to reflect the fact that not all of the distributional features are equally important in determining the distributional similarity of two Apts. Generally speaking, syntactically distant co-occurrences provide a weaker characterization of the semantics of a lexeme than co-occurrences that are syntactically closer. By multiplying each w(w, \u27e8 \u03c4,w\u2032 \u27e9) by \u03c6(\u03c4,w) we are able to capture this give a suitable instantiation of \u03c6(\u03c4,w).\nOne option for \u03c6(\u03c4,w) is to use p(\u03c4 \u2223w), i.e. the probability that when randomly selecting one of the co-occurrences \u27e8w, \u03c4 \u2032, w\u2032\u27e9, where w\u2032 can be any lexeme in V , \u03c4 \u2032 is the co-occurrence type \u03c4 . We can estimate these path probabilities from the co-occurrence counts in C as follows:\np(\u03c4 \u2223w) = #\u27e8w, \u03c4, \u2217\u27e9 #\u27e8w, \u2217, \u2217\u27e9\n(5)\nwhere #\u27e8w, \u03c4, \u2217\u27e9 = \u2211w\u2032\u2208V #\u27e8w, \u03c4, w\u2032\u27e9 #\u27e8w, \u2217, \u2217\u27e9 = \u2211w\u2032\u2208V \u2211\u03c4\u2208R\u0304\u2217R\u2217 #\u27e8w, \u03c4, w\u2032\u27e9 p(\u03c4 \u2223w) typically falls off rapidly as a function of the length of \u03c4 as desired. The similarity of two Apts, A1 and A2, which we denote sim(A1,A2), can be measured in terms of the similarity of vectors \u00d0\u2192 A1 and \u00d0\u2192 A2. The similarity of vectors can be measured in a variety of ways (Lin, 1998; Lee, 1999; Weeds and Weir, 2005; Curran, 2004). One popular option involves the use of the cosine measure:\nsim(A1,A2) = cos( \u00d0\u2192 A1, \u00d0\u2192 A2) (6)\nIt is common to apply cosine to vectors containing positive pointwise mutual information (PPMI) values. If the weights used in the Apts are counts or probabilities then they can be transformed into PPMI values at this point.\nAs a consequence of the fact that the different co-occurrence types of the co-occurrences associated with a lexeme are being differentiated, vectorized Apts are much sparser than traditional vector representations used to model distributional semantics. This can be mitigated in various ways, including:\n\u2022 reducing the granularity of the dependency relations and/or the part-of-speech tag-set;\n\u2022 applying various normalizations of lexemes such as case normalization, lemmatization, or stemming;\n\u2022 disregarding all distributional features involving co-occurrence types over a certain length;\n\u2022 applying some form of distributional smoothing, where distributional features of a lexeme are inferred based on the features of distributionally similar lexemes."}, {"heading": "4 Distributional Composition", "text": "In this section we turn to the central topic of the paper, namely distributional composition. We begin with an informal explanation of our approach, and then present a more precise formalisation."}, {"heading": "4.1 Discussion of Approach", "text": "Our starting point is the observation that although we have shown that all of the elementary Apts in the distributional lexicon can be placed in the same vector space (see Section 3), there is an important sense in which Apts for different parts of speech are not comparable. For example, many of the dimensions that make sense for verbs, such as those involving a co-occurrence type that begins with dobj or nsubj, do not make sense for a noun. However, as we now explain, the co-occurrence type structure present in an Apt allows us to address this, making way for our definition of distributional composition.\nConsider the Apt for the lexeme dry/JJ shown at the top of Figure 2. The anchor of this Apt is the node at which the lexeme dry/JJ appears. We can, however, take a different perspective on this Apt, for example, one in which the anchor is the node at which the lexemes bought/VBD and folded/VBD appear. This Apt is shown at the top of Figure 3. Adjusting the position of the anchor is significant because the starting point of the paths given by the co-occurrence types changes. For example, when the Apt shown at the top of Figure 3 is applied to the co-occurrence type nsubj, we reach the node at which the lexemes we/PRP and he/PRP appear. Thus, this Apt can be seen as a characterisation of the distributional properties of the verbs that nouns that dry/JJ modifies can take as their direct object. In fact, it looks rather like the elementary Apt for some verb. The lower tree in Figure 3 shows the elementary Apt for clothes/NNS (the centre Apt shown in Figure 2) where the anchor has been moved to the node at which the lexemes folded/VBD, hung/VBD and bought/VBD appear.\nNotice that in both of the Apts shown in Figure 3 parts of the tree are shown in faded text. These are nodes and edges that are removed from the Apt as a result of where the anchor has been moved. The elementary tree for dry/JJ shown in Figure 2 reflects the fact that at least some of the nouns that dry/JJ modifies can be the direct object of a verb, or the subject of a verb. When we move the anchor, as shown at the top of Figure 3, we resolve this ambiguity to the case where the noun being modified is a direct object. The incompatible parts of the Apt are removed. This corresponds to restricting the co-occurrence types of composed Apts to those that belong to the set R\u2217R\u2217, just as was the case for elementary Apts. For example, note that in the upper Apt of Figure 3, neither the path dobj \u22c5nsubj from the node labeled with bought/VBD and folded/VBD to the node labeled caused/VBD, or the path dobj\u22c5subj\u22c5dobj from the node labeled with bought/VBD and folded/VBD to the node labeled laughter/NN are in R\u2217R\u2217.\nGiven a sufficiently rich elementary Apt for dry/JJ, those verbs that have nouns that dry/JJ can plausibly modify as direct objects have elementary Apts that are in some sense \u201ccompatible\u201d with the Apt produced by shifting the anchor node as illustrated at the top of Figure 3. An example is the Apt for folded/VBD shown at the bottom of Figure 2. Loosely speaking, this means that when applied to the same co-occurrence type, the Apt in Figure 3 and the Apt at the bottom of Figure 2 are generally expected to give sets of lexemes with related elements.\nBy moving the anchors of the Apt for dry/JJ and clothes/NNS as in Figure 3, we have, in effect, aligned all of the nodes of the Apts for dry/JJ and clothes/NN with the nodes they correspond to in the Apt for folded/VBD. Not only does this make it possible, in principle at least, to establish whether or not the composition of dry/JJ, clothes/NNS and folded/VBD is plausible, it provides the basis for the contextualization of Apts, as we now explain.\nRecall that elementary Apts are produced by aggregating contexts taken from all of the occurrences of the lexeme in a corpus. As described in the introduction, we need a way to contextualize aggregated Apts in order to produce a fine-grained characterization of the distributional semantics of the lexeme in context. There are two distinct aspects to the contextualization of Apts, both of which can be captured through Apt composition: cooccurrence filtering \u2014 the down-weighting of co-occurrences that are not compatible with the way the lexeme is being used in its current context; and co-occurrence embellishment \u2014 the up-weighting of compatible co-occurrences that appear in the Apts for the lexemes with which it is being composed.\nBoth co-occurrence filtering and co-occurrence embellishment can be achieved through Apt composition. The process of composing the elementary Apts for the lexemes that\nappear in a phrase involves two distinct steps. First, the elementary Apts for each of the lexemes being composed are aligned in a way that is determined by the dependency tree for the phrase. The result of this alignment of the elementary Apts, is that each node in one of the Apts is matched up with (at most) one of the nodes in each of the other Apts. The second step of this process involves merging nodes that have been matched up with one another in order to produce the resulting composed Apt that represents the distributional semantics of the dependency tree. It is during this second step that we are in a position to determine those co-occurrences that are compatible across the nodes that have been matched up.\nFigure 4 illustrates the composition of Apts on the basis of a dependency tree shown in the upper centre of the figure. In the lower right, the figure shows the full Apt that results from merging the six aligned Apts, one for each of the lexemes in the dependency tree. Each node in the dependency tree is labeled with a lexeme, and around the dependency tree, we show the elementary Apts for each lexeme. The six elementary Apts are aligned on the basis of the position of their lexeme in the dependency tree. Note that the tree shown in grey within the Apt is structurally identical to the dependency tree in the upper centre of the figure. The nodes of the dependency tree are labeled with single lexemes, whereas each node of the Apt is labeled by a weighted lexeme multiset. The lexeme labelling a node in the dependency tree is one of the lexemes found in the weighted lexeme multiset associated with the corresponding node within the Apt. We refer to the nodes in the composed Apt that come from nodes in the dependency tree (the grey nodes) as the internal context, and the remaining nodes as the external context.\nAs we have seen, the alignment of Apts can be achieved by adjusting the location of the anchor. The specific adjustments to the anchor locations are determined by the dependency tree for the phrase. For example, Figure 5 shows a dependency analysis of the phrase folded dry clothes. To align the elementary Apts for the lexemes in this tree, we do the following.\n\u2022 The anchor of the elementary Apt for dry/JJ is moved to the node on which the\n(a )\n\u22ee w\ne bo\nu gh\nt \u22ee\n\u22ee \u22ee\n\u22ee th\ne sl\nig h tl\ny fi\nzz y\nw in\ne \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee d\nry \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee w h it e \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee (b ) \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee yo u r \u22ee \u22ee d ry jo ke ca u se d la u gh te r \u22ee \u22ee \u22ee \u22ee \u22ee (c ) \u22ee h e fo ld ed \u22ee \u22ee \u22ee \u22ee th e \u22ee cl ea n cl o th es \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee d ry \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee\n(c )\n\u22ee h e\nfo ld\ned \u22ee\n\u22ee \u22ee\n\u22ee th\ne \u22ee\ncl ea\nn c lo\nth e s\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee d ry \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee\n(d )\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\nyo u\nr \u22ee\n\u22ee \u22ee\nc lo\nth e s\nlo o k\n\u22ee gr\nea t\n\u22ee \u22ee\n\u22ee \u22ee\n(e )\nth e\nm a n\nh u\nn g\nu p\n\u22ee \u22ee\n\u22ee th\ne \u22ee\nw et\nc lo\nth e s\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee \u22ee (f ) a bo y bo u gh t \u22ee \u22ee \u22ee \u22ee so m e ve ry ex pe n si ve c lo th e s \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee ye st\ner d a y\n(c )\n\u22ee h e\nfo ld\ne d\n\u22ee \u22ee\n\u22ee \u22ee\nth e\n\u22ee cl\nea n\ncl o th\nes \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee d ry\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\n(g )\n\u22ee sh\ne fo\nld e d\nu p\n\u22ee \u22ee\n\u22ee \u22ee\n\u22ee \u22ee\na ll\n\u22ee \u22ee\n\u22ee o f\nth e\nla u\nn d ry \u22ee (h ) \u22ee h e fo ld e d \u22ee u n d er p re ss u re \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee \u22ee d e t n su b j p r p d o b j d e t p o ss a d v m o d a m o d n su b j d o b jx c o m p t m o d n m o d d e t c a se n m o d c a se\nF ig\nu re\n6: V\ner ti\nca ll\ny al\nig n\ned A p t\ns fo\nr d ry\n/J J ,\ncl o th\nes /N\nN S\na n\nd fo\nld ed\n/V B\nD a s\nd et\ner m\nin ed\nb y\nth e\ntr ee\nin F\nig u\nre 5 .\nT h\ne le\ntt er\ns in\nb ra\nck et\ns o n\nth e\nle ft\nre fe\nr to\nth e\nd ep\nen d\nen cy\ntr ee\ns sh\now n\nin F\nig u\nre 1\nfr om\nw h\nic h\nth es\ne A p t\ns a re\nco n\nst ru\nct ed\n. F\no r\nsp a ce\nre a so\nn s,\np a rt\no f\nsp ee\nch ta\ng s\nh av\ne b\nee n\no m\nit te\nd .\nBefore we discuss how the nodes in aligned Apts are merged, we formalize the notion of Apt alignment. We do this by first defining so-called offset Apts, which formalizes the idea of adjusting the location of an anchor. We then define how to align all of the Apts for the lexemes in a phrase based on a dependency tree."}, {"heading": "4.2 Offset Apts", "text": "Given some offset, \u03b4, a string in R\u2217R\u2217, the Apt A when offset by \u03b4 is denoted A\u03b4. Offsetting an Apt by \u03b4 involves moving the anchor to the position reached by following the path \u03b4 from the original anchor position. In order to define A\u03b4, we must define A\u03b4(\u03c4,w\u2032) for each \u03c4 \u2208 R\u2217R\u2217 and w\u2032 \u2208 V , or in terms of our alternative tree-based representation, we need to specify the \u03c4 \u2032 such that A\u03b4(\u03c4) and A(\u03c4 \u2032) yield the same node (weighted lexeme multiset).\nAs shown in the Equation 7 below, path offset can be specified by making use of the co-occurrence type reduction operator that was introduced in Section 2.2. Given a string \u03b4 in R\u2217R\u2217 and an Apt A, the offset Apt A\u03b4 is defined as follows. For each \u03c4 \u2208 R\u2217R\u2217 and w \u2208 V :\nA\u03b4(\u03c4,w) = A(\u2193(\u03b4\u03c4),w) (7)\nor equivalently, for each \u03c4 \u2208 R\u2217R\u2217:\nA\u03b4(\u03c4) = A(\u2193(\u03b4\u03c4)) (8)\nAs required, Equation 7 defines A\u03b4 by specifying the weighted lexeme multiset we get when A\u03b4 is applied to co-occurrence type \u03c4 as being the lexeme multiset that A produces when applied to the co-occurrence type \u2193(\u03b4\u03c4).\nAs an illustrative example, consider the Apt shown at the top of Figure 2. Let us call this Apt A. Note that A is anchored at the node where the lexeme dry/JJ appears. Consider the Apt produced when we apply the offset amod\u22c5dobj. This is shown at the top of Figure 3. Let us refer to this Apt as A\u2032. The anchor of A\u2032 is the node at which the lexemes bought/VDB and folded/VBD appear. Now we show how the two nodes A\u2032(nsubj) and A\u2032(dobj\u22c5amod\u22c5advmod) are defined in terms of A on the basis of Equation 8. In both cases the offset \u03b4 = amod\u22c5dobj.\n\u2022 For the case where \u03c4 = nsubj we have\nA\u2032(nsubj) = A(\u2193(amod\u22c5dobj\u22c5nsubj)) = A(amod\u22c5dobj\u22c5nsubj)\nWith respect to the anchor of A, this correctly addresses the node at which the lexemes we/PRP and he/PRP appear.\n\u2022 Where \u03c4 = dobj\u22c5amod\u22c5advmod we have\nA\u2032(dobj\u22c5amod\u22c5advmod) = A(\u2193(amod\u22c5dobj\u22c5dobj\u22c5amod\u22c5advmod)) = A(\u2193(amod\u22c5amod\u22c5advmod)) = A(\u2193(advmod)) = A(advmod)\nWith respect to the anchor of A, this correctly addresses the node at which the lexeme slightly/RB appears.\nIn practice, the offset Apt A\u03b4 can be obtained by prepending the inverse of the path offset, \u03b4\u22121, to all of the co-occurrence types in A and then repeatedly applying the reduction operator until no further reductions are possible. In other words, if \u03c4 addresses a node in A, then \u03c4 \u2032 addresses a node in A\u03b4 iff \u03c4 \u2032 =\u2193(\u03b4\u22121\u03c4) and \u03c4 \u2032 \u2208 R\u2217R\u2217."}, {"heading": "4.3 Syntax-driven Apt Alignment", "text": "We now make use of offset Apts, as defined in Equation 7, as a way to align all of the Apts associated with a dependency tree. Consider the following scenario:\n\u2022 w1 . . .wn is a the phrase (or sentence) where each wi \u2208 V for 1 \u2264 i \u2264 n;\n\u2022 t \u2208 TV,R is a dependency analysis of the string w1 . . .wn;\n\u2022 wh is the lexeme at the root of t. In other words, h is the position (index) in the phrase at which the head appears;\n\u2022 \u2225wi\u2225 is the elementary Apt for wi for each i, 1 \u2264 i \u2264 n; and\n\u2022 \u03b4i, the offset of wi in t with respect to the root, is the path in t from wi to wh. In other words, \u27e8wi, \u03b4i, wh\u27e9 is a co-occurrence in t for each i, 1 \u2264 i \u2264 n. Note that \u03b4h = .\nWe define the distributional semantics for the tree t, denoted \u2225t\u2225, as follows:\n\u2225t\u2225 =\u2294{ \u2225w1\u2225\u03b41 , . . . , \u2225wn\u2225\u03b4n } (9)\nThe definition of \u2294 is considered in Section 4.4. In general, \u2294 operates on a set of n aligned Apts, merging them into a single Apt. The multiset at each node in the resulting Apt is formed by merging n multisets, one from each of the elements of { \u2225w1\u2225\u03b41 , . . . , \u2225wn\u2225\u03b4n }. It is this multiset merging operation that we focus on in Section 4.4.\nAlthough \u2225t\u2225 can be taken to be the distributional semantics of the tree as a whole, the same Apt, when associated with different anchors (i.e. when offset in some appropriate way) provides a representation of each of the contextualized lexemes that appear in the tree.\nFor each i, for 1 \u2264 i \u2264 n, the Apt for wi when contextualized by its role in the dependency tree t, denoted \u2225wi; t\u2225, is the Apt that satisfies the equality:\n\u2225wi; t\u2225\u03b4i = \u2225t\u2225 (10)\nAlternatively, this can also be expressed with the equality:\n\u2225wi; t\u2225 = \u2225t\u2225\u03b4i \u22121\n(11)\nNote that \u2225wh; t\u2225 and \u2225t\u2225 are identical. In other words, we take the representation of the distributional semantics of a dependency tree to be the Apt for the lexeme at the root of that tree that has been contextualized by the other lexemes appearing below it in the tree.\nEquation 9 defined Apt composition as a \u201cone-step\u201d process in the sense that all of the n elementary Apts that are associated with nodes in the dependency tree are composed at once to produce the resulting (composed) Apt. There are, however, alternative strategies that could be formulated. One possibility is fully incremental left-to-right composition, where, working left-to-right through the string of lexemes, the elementary Apts for the first two lexemes are composed, with the resulting Apt then being composed with the elementary Apt for the third lexeme, and so on. It is always possible to compose Apts in this fully incremental way, whatever the structure in the dependency tree. The tree structure, is however, critical in determining how the adjacent Apts need to be aligned."}, {"heading": "4.4 Merging Aligned Apts", "text": "We now turn to the question of how to implement the function \u2294 which appears in Equation 9. \u2294 takes a set of n aligned Apts, {A1, . . .An }, one for each node in the dependency tree t. It merges the Apts together node by node to produce a single Apt, \u2294{A1, . . .An }, that represents the semantics of the dependency tree. Our discussion, therefore, addresses the question of how to merge the multisets that appear at nodes that are aligned with each other and form the nodes of the Apt being produced.\nThe elementary Apt for a lexeme expresses those co-occurrences that are distributionally compatible with the lexeme given the corpus. When lexemes in some phrase are\ncomposed, our objective is to capture the extent to which the co-occurrences arising in the elementary Apts are mutually compatible with the phrase as a whole. Once the elementary Apts that are being composed have been aligned, we are in a position to determine the extent to which co-occurrences are mutually compatible: co-occurrences that need to be compatible with one another are brought together through the alignment. We consider two alternative ways in which this can be achieved.\nWe begin with \u2294int which provides a tight implementation of the mutual compatibility of co-occurrences. In particular, a co-occurrence is only deemed to be compatible with the composed lexemes to the extent that is distributionally compatible with the lexeme that it is least compatible with. This corresponds to the multiset version of intersection. In particular, for all \u03c4 \u2208 R\u2217R\u2217 and w\u2032 \u2208 V :\n\u2294 int {A1, . . . ,An }(\u03c4,w\u2032) = min 1\u2264i\u2264n Ai(\u03c4,w\u2032) (12)\nIt is clear that the effectiveness of \u2294int increases as the size of C grows, and that it would particularly benefit from distributional smoothing (Dagan, Pereira, and Lee, 1994) which can be used to improve plausible co-occurrence coverage by inferring co-occurrences in the Apt for a lexeme w based on the co-occurrences in the Apts of distributionally similar lexemes.\nAn alternative to \u2294int is \u2294uni where we determine distributional compatibility of a cooccurrence by aggregating across the distributional compatibility of the co-occurrence for each of the lexemes being composed. In particular, for all \u03c4 \u2208 (R \u222aR)\u2217 and w\u2032 \u2208 V :\n\u2294 uni {A1, . . . ,An }(\u03c4,w\u2032) = \u2211 1\u2264i\u2264n Ai(\u03c4,w\u2032) (13)\nWhile this clearly achieves co-occurrence embellishment, whether co-occurrence filtering is achieved depends on the weighting scheme being used. For example, if negative weights are allowed, then co-occurrence filtering can be achieved.\nThere is one very important feature of Apt composition that is a distinctive aspect of our proposal, and therefore worth dwelling on. In Section 4.1, when discussing Figure 4, we made reference to the notions of internal and external context. The internal context of a composed Apt is that part of the Apt that corresponds to the nodes in the dependency tree that generated the composed Apt. One might have expected that the only lexeme appearing at an internal node is the lexeme that appears at the corresponding node in the dependency tree. However, this is absolutely not the objective: at each node in the internal context, we expect to find a set of alternative lexemes that are, to varying degrees, distributionally compatible with that position in the Apt. We expect that a lexeme that is distributionally compatible with a substantial number of the lexemes being composed will result in a distributional feature with non-zero weight in the vectorized Apt. There is, therefore, no distinction being made between internal and external nodes. This enriches the distributional representation of the contextualized lexemes, and overcomes the potential problem arising from the fact that as larger and larger units are composed, there is less and less external context around to characterize distributional meaning."}, {"heading": "5 Experiments", "text": "In this section we consider some empirical evidence in support of Apts. First, we consider some of the different ways in which Apts can be instantiated. Second, we present a number of case studies showing the disambiguating effect of Apt composition in adjectivenoun composition. Finally, we evaluate the model using the phrase-based compositionality benchmarks of Mitchell and Lapata (2008) and Mitchell and Lapata (2010)."}, {"heading": "5.1 Instantiating Apts", "text": "We have constructed Apt lexicons from three different corpora.\n\u2022 clean wiki is a corpus used for the case studies in 5.2. This corpus is a cleaned 2013 Wikipedia dump (Wilson, 2015) which we have tokenised, part-of-speech-tagged, lemmatised and dependency-parsed using the Malt Parser (Nivre, 2004). This corpus contains approximately 0.6 billion tokens.\n\u2022 BNC is the British National Corpus. It has been tokenised, POS-tagged, lemmatised and dependency-parsed as described in Grefenstette et al. (2013) and contains approximately 0.1 billion tokens.\n\u2022 concat is a concatenation of the ukWaC corpus (Ferraresi et al., 2008), a mid-2009 dump of the English Wikipedia and the British National Corpus. This corpus has been tokenised, POS-tagged, lemmatised and dependency-parsed as described in Grefenstette et al. (2013) and contains about 2.8 billion tokens.\nHaving constructed lexicons, there are a number of hyperparameters to be explored during composition. First there is the composition operation itself. We have explored variants which take a union of the features such as add and max and variants which take an intersection of the features such as mult, min and intersective add, where intersective add(a, b) = a + b iff a > 0 and b > 0; 0 otherwise.\nSecond, the Apt theory is agnostic to the type or derivation of the weights which are being composed. The weights in the elementary Apts can be counts, probabilities, or some variant of PPMI or other association function. Whilst it is generally accepted that the use of some association function such as PPMI is normally beneficial in the determination of lexical similarity, there is a choice over whether these weights should be seen as part of the representation of the lexeme, or as part of the similarity calculation. In the instantiation which we refer to as as compose first, Apt weights are probabilities. These are composed and transformed to PPMI scores before computing cosine similarities. In the instantiation which we refer to as compose second, Apt weights are PPMI scores.\nThere are a number of modifications that can be made to the standard PPMI calculation. First, it is common (Levy, Goldberg, and Dagan, 2015) to delete rare words when building co-occurrence vectors. Low frequency features contribute little to similarity calculations because they co-occur with very few of the targets. Their inclusion will tend to reduce similarity scores across the board, but have little effect on ranking. Filtering, on the other hand, improves efficiency. In other experiments, we have found that a feature frequency threshold of 1000 works well. On a corpus the size of Wikipedia ( 1.5 billion tokens), this leads to a feature space for nouns of approximately 80,000 dimensions (when including only first-order paths) and approximately 230,000 dimensions (when including paths up to order 2).\nLevy, Goldberg, and Dagan (2015) also showed that the use of context distribution smoothing (cds), \u03b1 = 0.75, can lead to performance comparable with state-of-the-art word embeddings on word similarity tasks.\npmi\u03b1 (w\u2032,w; \u03c4) = log #\u27e8w, \u03c4, w\u2032\u27e9#\u27e8\u2217, \u03c4, \u2217\u27e9\u03b1\n#\u27e8w, \u03c4, \u2217\u27e9#\u27e8\u2217, \u03c4, w\u2032\u27e9\u03b1\nLevy, Goldberg, and Dagan (2015) further showed that using shifted PMI, which is analogous to the use of negative sampling in word embeddings, can be advantageous. When shifting PMI, all values are shifted down by log k before the threshold is applied.\nsppmi (w\u2032,w; \u03c4) = max (pmi (w\u2032,w; \u03c4) \u2212 log k,0)\nFinally, there are many possible options for the path weighting function \u03c6(\u03c4,w). These include the path probability p(\u03c4 \u2223w) as discussed in Section 3, constant path weighting, and inverse path length or harmonic function (which is equivalent to the dynamic context window used in many neural implementations such as GloVe (Pennington, Socher, and Manning, 2014))."}, {"heading": "5.2 Disambiguation", "text": "Here we consider the differences between using aligned and unaligned Apt representations as well as the differences between using \u2294uni and \u2294int when carrying out adjective-noun (AN) composition. From the clean wiki corpus described in Section 5.1, a small number of high frequency nouns were chosen which are ambiguous or broad in meaning together with potentially disambiguating adjectives. We use the compose first option described above where composition is carried out on Apts containing probabilities.\nw(w, \u27e8 \u03c4,w\u2032 \u27e9) = #\u27e8w, \u03c4, w \u2032\u27e9\n#\u27e8w, \u2217, \u2217\u27e9 The closest distributional neighbours of the individual lexemes before and after composition with the disambiguating adjective are then examined. In order to calculate similarities, contexts are weighted using the variant of PPMI advocated by Levy, Goldberg, and Dagan (2015) wherecds is applied with \u03b1 = 0.75. However, no shift is applied to the PMI values since we have found shifting to have little or negative effect when working with relatively small corpora. Similarity is then computed using the standard cosine measure. For illustrative purposes the top ten neighbours of each word or phrase are shown, concentrating on ranks rather than absolute similarity scores.\nTable 2 illustrates what happens when \u2294uni is used to merge aligned and unaligned Apt representations when the noun shoot is placed in the contexts of green and six-week. Boldface\nis used in the entries of compounds where a neighbour appears to be highly suggestive of the intended sense and where it has a rank higher or equal to its rank in the entry for the uncontextualised noun. In this example, it is clear that merging the unaligned Apt representations provides very little disambiguation of the target noun. This is because typed co-occurrences for an adjective mostly belong in a different space to typed co-occurrences for a noun. Addition of these spaces leads to significantly lower absolute similarity scores, but little change in the ranking of neighbours. Whilst we only show one example here, this observation appears to hold true whenever words with different part of speech tags are composed. Intersection of these spaces via \u2294int generally leads to substantially degraded neighbours, often little better than random, as illustrated by Table 3.\nOn the other hand when Apts are correctly aligned and merged using \u2294uni, we see the disambiguating effect of the adjective. A green shoot is more similar to leaf, flower, fruit and tree. A six-week shoot is more similar to tour, session, show and concert. This disambiguating effect is even more apparent when \u2294int is used to merge the Apt representations (see Table 3).\nTable 4 further illustrates the difference between using \u2294uni and \u2294int when composing aligned Apt representations. Again, boldface is used in the entries of compounds where a neighbour appears to be highly suggestive of the intended sense and where it has a rank higher or equal to its rank in the entry for the uncontextualised noun. In these examples, we can see that both \u2294uni and \u2294int appear to be effective in carrying out some disambiguation. Looking at the example of musical group, both \u2294uni and \u2294int increase the relative similarity of band and music to group when it is contextualised by musical. However, \u2294int also leads to a number of other words being selected as neighbours which are closely related to the musical sense of group e.g. troupe, ensemble and trio. This is not the case when \u2294uni is used \u2014 the other neighbours still appear related to the general meaning of group. This trend is also seen in some of the other examples such as ethnic group, human body and magnetic field. Further, even when \u2294uni leads to the successful selection of a large number of sense specific neighbours, e.g. see literary work, the neighbours selected appear to be higher frequency, more general words than when \u2294int is used.\nThe reason for this is likely to be the effect that each of these composition operations has on the number of non-zero dimensions in the composed representations. Ignoring the relatively small effect the feature association function may have on this, it is obvious that \u2294uni should increase the number of non-zero dimensions whereas \u2294int should decrease the number of non-zero dimensions. In general, the number of non-zero dimensions is highly correlated with frequency, which makes composed representations based on \u2294uni behave like high frequency words and composed representations based on \u2294int behave like low frequency words. Further, when using similarity measures based on PPMI, as demonstrated by Weeds (2003), it is not unusual to find that the neighbours of high frequency entities (with a large number of non-zero dimensions) are other high frequency entities (also with a large number of non-zero dimensions). Nor is it unusual to find that the neighbours of low frequency entities (with a small number of non-zero dimensions) are other low frequency entities (with a small number of non-zero dimensions). Weeds, Weir, and McCarthy (2004) showed that frequency is also a surprisingly good indicator of the generality of the word. Hence \u2294uni leads to more general neighbours and \u2294int leads to more specific neighbours.\nFinally, note that whilst \u2294int has produced high quality neighbours in these examples where only two words are composed, using \u2294int in the context of the composition of an entire sentence would tend to lead to very sparse representations. The majority of the internal nodes of the Apt composed using an intersective operation such as \u2294int must necessarily only include the lexemes actually used in the sentence. \u2294uni on the other hand will have added to these internal representations, suggesting similar words which might have been used in those contexts and giving rise to a rich representation which might be used to calculate sentence similarity. Further, the use of PPMI, or some other similar form of feature weighting and selection, will mean that those internal (and external) contexts which are not supported by a majority of the lexemes in the sentence will tend to be considered insignificant and therefore will be ignored in similarity calculations. By using shifted PPMI, it should be possible to further reduce the number of non-zero dimensions in a representation constructed using \u2294uni which should also allow us to control the specificity/generality of the neighbours observed."}, {"heading": "5.3 Phrase-based Composition Tasks", "text": "Here we look at the performance of one instantiation of the Apt framework on two benchmark tasks for phrase-based composition."}, {"heading": "5.3.1 Experiment 1: the M&L2010 dataset", "text": "The first experiment uses the M&L2010 dataset, introduced by Mitchell and Lapata (2010), which contains human similarity judgements for adjective-noun (AN), noun-noun (NN) and verb-object (VO) combinations on a seven-point rating scale. It contains 108 combinations in each category such as \u27e8social activity, economic condition\u27e9, \u27e8tv set, bedroom window\u27e9 and \u27e8fight war,win battle\u27e9. This dataset has been used in a number of evaluations of compositional methods including Mitchell and Lapata (2010), Blacoe and Lapata (2012), Turney (2012), Hermann and Blunsom (2013) and Kiela and Clark (2014). For example, Blacoe and Lapata (2012) show that multiplication in a simple distributional space (referred to here as an untyped VSM) outperforms the distributional memory (DM) method of Baroni and Zamparelli (2010) and the neural language model (NLM) method of Collobert and Weston (2008).\nWhilst often not explicit, the experimental procedure in most of this work would appear to be the calculation of Spearman\u2019s rank correlation coefficient \u03c1 between model scores and individual, non-aggregated, human ratings. For example, if there are 108 phrase pairs being judged by 6 humans, this would lead to a dataset containing 648 data points. The procedure is discussed at length in Turney (2012), who argues that this method tends to underestimate model performance. Accordingly, Turney explicitly uses a different procedure where a separate Spearman\u2019s \u03c1 is calculated between the model scores and the scores of each participant. These coefficients are then averaged to give the performance indicator for each model. Here, we report results using the original M&L method, see Table 5. We found that using the Turney method scores were typically higher by 0.01 to 0.04. If model scores are evaluated against aggregated human scores, then the values of Spearman\u2019s \u03c1 tends to be still higher, typically 0.1 to 0.12 higher than the values reported here.\nFor this experiment, we have constructed an order 2 Apt lexicon for the BNC corpus. This is the same corpus used by Mitchell and Lapata (2010) and for the best performing algorithms in Blacoe and Lapata (2012). We note that the larger concat corpus was used by Blacoe and Lapata (2012) in the evaluation of the DM algorithm (Baroni and Lenci, 2010). We use the compose second option described above where the elementary Apt weights are PPMI. With regard to the different parameter settings in the PPMI calculation\n(Levy, Goldberg, and Dagan, 2015), we tuned on a number of popular word similarity tasks: MEN (Bruni, Tran, and Baroni, 2014); WordSim-353 (Finkelstein et al., 2001); and SimLex-999 (Hill, Reichart, and Korhonen, 2015). In these tuning experiments, we found that context distribution smoothing gave mixed results. However, shifting PPMI (k = 10) gave optimal results across all of the word similarity tasks. Therefore we report results here for vanilla PPMI (shift k = 1) and shifted PPMI (shift k = 10). For composition, we report results for both \u2294uni and \u2294int. Results are shown in Table 5.\nFor this task and with this corpus \u2294uni consistently outperforms \u2294int. Shifting PPMI by log 10 consistently improves results for \u2294uni, but has a large negative effect on the results for \u2294int. We believe that this is due to the relatively small size of the corpus. Shifting PPMI reduces the number of non-zero dimensions in each vector which increases the likelihood of a zero intersection. In the case of AN composition, all of the intersections were zero for this setting, making it impossible to compute a correlation.\nComparing these results with the state-of-the-art, we can see that \u2294uni clearly outperforms DM and NLM as tested by Blacoe and Lapata (2012). This method of composition is also achieving close to the best results in Mitchell and Lapata (2010) and Blacoe and Lapata (2012). It is interesting to note that our model does substantially better than the stateof-the-art on verb-object composition, but is considerably worse at noun-noun composition. Exploring why this is so is a matter for further research. We have undertaken experiments with a larger corpus and a larger range of hyper-parameter settings which indicate that the performance of the Apt models can be increased significantly. However, these results are not presented here, since an equatable comparison with existing models would require a similar exploration of the hyper-parameter space across all models being compared."}, {"heading": "5.3.2 Experiment 2: the M&L2008 dataset", "text": "The second experiment uses the M&L2008 dataset, introduced by Mitchell and Lapata (2008), which contains pairs of intransitive sensitives together with human judgments of similarity. The dataset contains 120 unique subject, verb, landmark triples with a varying number of human judgments per item. On average each triple is rated by 30 participants. The task is to rate the similarity of the verb and the landmark given the potentially disambiguating context of the subject. For example, in the context of the subject fire one might expect glowed to be close to burned but not close to beamed. Conversely, in the context of the subject face one might expect glowed to be close to beamed and not close to burned.\nThis dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013). These evaluations clearly follow the experimental procedure of Mitchell and Lapata and do not evaluate against mean scores. Instead, separate points are created for each human annotator, as discussed in Section 5.3.1.\nThe multi-step regression algorithm of Grefenstette et al. (2013) achieved \u03c1 = 0.23 on this dataset. In the evaluation of Dinu, Pham, and Baroni (2013), the lexical function algorithm, which learns a matrix representation for each functor and defines composition as matrix-vector multiplication, was the best performing compositional algorithm at this task. With optimal parameter settings, it achieved around \u03c1 = 0.26. In this evaluation, the full additive model of Guevara (2010) achieved \u03c1 < 0.05.\nIn order to make our results directly comparable with these previous evaluations, we have used the same corpus to construct our Apt lexicons, namely the concat corpus described in Section 5.1. Otherwise, the Apt lexicon was constructed as described in Section 5.3.1. As before note that k = 1 in shifted PPMI is equivalent to not shifting PPMI. Results are shown in Table 6.\nWe see that \u2294uni is highly competitive with the optimised lexical function model which was the best performing model in the evaluation of Dinu, Pham, and Baroni (2013). In that evaluation, the lexical function model achieved between 0.23 and 0.26 depending on the parameters used in dimensionality reduction. Using vanilla PPMI, without any context distribution smoothing or shifting, \u2294uni achieves \u03c1 = 0.20, which is less than \u2294int. However, when using shifted PPMI as weights, the best result is 0.26. The shifting of PPMI means that contexts need to be more surprising in order to be considered as features. This makes sense when using an additive model such as \u2294uni.\nWe also see that at this task and using this corpus \u2294int performs relatively well. Using vanilla PPMI, without any context distribution smoothing or shifting, it achieves \u03c1 = 0.23 which equals the performance of the multi-step regression algorithm Grefenstette et al. (2013). Here, however, shifting PPMI has a negative impact on performance. This is largely due to the intersective nature of the composition operation \u2014 if shifting PPMI removes a feature from one of the unigram representations, it cannot be recovered during composition."}, {"heading": "6 Related Work", "text": "Our work brings together two strands usually treated as separate though related problems: representing phrasal meaning by creating distributional representations through composition; and representing word meaning in context by modifying the distributional representation of a word. In common with some other work on lexical distributional similarity, we use a typed co-occurrence space. However, we propose the use of higher-order grammatical dependency relations to enable the representation of phrasal meaning and the representation of word meaning in context."}, {"heading": "6.1 Representing Phrasal Meaning", "text": "The problem of representing phrasal meaning has traditionally been tackled by taking vector representations for words (Turney and Pantel, 2010) and combining them using some function to produce a data structure that represents the phrase or sentence. Mitchell and Lapata (2008, 2010) found that simple additive and multiplicative functions applied to proximitybased vector representations were no less effective than more complex functions when performance was assessed against human similarity judgements of simple paired phrases.\nThe word embeddings learnt by the continuous bag-of-words model (CBOW) and the continuous skip-gram model proposed by Mikolov et al. (2013a, 2013b) are currently among the most popular forms of distributional word representations. Whilst using a neural network architecture, the intuitions behind such distributed representations of words are the same as in traditional distributional representations. As argued by Pennington et al. (2014), both count-based and prediction-based models probe the underlying corpus co-occurrences statistics. For example, the CBOW architecture predicts the current word based on context (which is viewed as a bag-of-words) and the skip-gram architecture predicts surrounding words given the current word. Mikolov et al. (2013c) showed that it is possible to use these models to efficiently learn low-dimensional representations for words which appear to capture both syntactic and semantic regularities. Mikolov et al. (2013b) also demonstrated the possibility of composing skip-gram representations using addition. For example, they found that adding the vectors for Russian and river results in a very similar vector to the\nresult of adding the vectors for Volga and river. This is similar to the multiplicative model of Mitchell and Lapata (2008) since the sum of two skip-gram word vectors is related to the product of two word context distributions.\nWhilst our model shares with these the use of vector addition as a composition operation, the underlying framework is very different. Specifically, the actual vectors added depend not just on the form of the words but also their grammatical relationship within the phrase or sentence. This means that the representation for, say, glass window is not equal to the representation of window glass. The direction of the nn relationship between the words leads to a different alignment of the Apts and consequently a different representation for the phrases.\nThere are other approaches which incorporate theoretical ideas from formal semantics and machine learning, use syntactic information, and specialise the data structures to the task in hand. For adjective-noun phrase composition, Baroni and Zamparelli (2010) and Guevara (2010) borrowed from formal semantics the notion that an adjective acts as a modifying function on the noun. They represented a noun as a vector, an adjective as a matrix, which could be induced from pairs of nouns and adjective noun phrases, and composed the two using matrix-by-vector multiplication to produce a vector for the noun phrase. Separately, Coecke, Sadrzadeh, and Clark (2011) proposed a broader compositional framework that incorporated from formal semantics the notion of function application derived from syntactic structure (Montague, 1970; Lambek, 1999). These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013).\nThe MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition. This model, however, was made much more flexible by requiring and using task-specific labelled training data to create taskspecific distributional data structures, and by allowing non-linear relationships between component data structures and the composed result. The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013).\nHowever, whilst these approaches all pay attention to syntax, they all require large amounts of training data. For example, running regression models to accurately predict the matrix or tensor for each individual adjective or verb requires a large number of exemplar compositions containing that adjective or verb. Socher\u2019s MV-RNN model further requires task-specific labelled training data. Our approach, on the other hand, is purely count-based and directly aggregates information about each word from the corpus.\nOther approaches have been proposed. Clarke (2007, 2012) suggested a context-theoretic semantic framework, incorporating a generative model that assigned probabilities to arbitrary word sequences. This approach shared with Coecke, Sadrzadeh, and Clark (2011) an ambition to provide a bridge between compositional distributional semantics and formal logic-based semantics. In a similar vein, Garrette, Erk, and Mooney (2011) combined word-level distributional vector representations with logic-based representation using a probabilistic reasoning framework. Lewis and Steedman (2013) also attempted to combine distributional and logical semantics by learning a lexicon for CCG (Combinatory Categorial Grammar (Steedman, 2000)) which first maps natural language to a deterministic logical form and then performs a distributional clustering over logical predicates based on arguments. The CCG formalism was also used by Hermann and Blunsom (2013) as a means for incorporating syntax-sensitivity into vector space representations of sentential semantics based on recursive auto-encoders (Socher et al. (2011a, 2011b)). They achieved this by representing each combinatory step in a CCG parse tree with an auto-encoder function, where it is possible to parameterise both the weight matrix and bias on the combinatory rule and the CCG category.\nTurney (2012) offered a model that incorporated assessments of word-level semantic relations in order to determine phrasal-level similarity. This work uses two different word-level distributional representations to encapsulate two types of similarity, and captures instances\nwhere the components of a composed noun phrase bore similarity to another word through a mix of those similarity types. Crucially, it views similarity of phrases as a function of the similarities of the components and does not attempt to derive modified vectors for phrases or words in context. Dinu and Thater (2012) also compared computing sentence similarity via additive compositional models with an alignment-based approach, where sentence similarity is a function of the similarities of component words, and simple word overlap. Their results showed that a model based on a mixture of these approaches outperformed all of the individual approaches on a number of textual entailment datasets."}, {"heading": "6.2 Typed Co-occurrence Models", "text": "In untyped co-occurrence models, such as those considered by Mitchell and Lapata (2008, 2010) , co-occurrences are simple, untyped pairs of words which co-occur together (usually within some window of proximity but possibly within some grammatical relation). The lack of typing makes it possible to compose vectors through addition and multiplication. However, in the computation of lexical distributional similarity using grammatical dependency relations, it has been typical (Lin, 1998; Lee, 1999; Weeds and Weir, 2005) to consider the type of a co-occurrence (for example, does dog occur with eat as its direct object or its subject?) as part of the feature space. The distinction between vector spaces based on untyped and typed co-occurrences was formalised by Pado\u0301 and Lapata (2007) and Baroni and Lenci (2010). In particular, Baroni and Lenci (2010) showed that typed co-occurrences based on grammatical relations were better than untyped co-occurrences for distinguishing certain semantic relations. However, as shown by Weeds, Weir, and Reffin (2014), it does not make sense to compose typed features based on first-order dependency relations through multiplication and addition, since the vector spaces for different parts of speech are largely non-overlapping.\nPado\u0301 and Lapata (2007) constructed features using higher-order grammatical dependency relations. They defined a path through a dependency tree in terms of the node words. This allowed words which are only indirectly related within a sentence to be considered as co-occurring. For example, in a lorry carries apples, there is a path of length 2 between the nouns lorry and apples via the node carry. However, they also used a word-based basis mapping which essentially reduces all of the salient grammatical paths to untyped cooccurrences. Given the paths \u27e8lorry, carry\u27e9 and \u27e8lorry, carry,apples\u27e9 for lorry, these would be mapped to the basis elements carry and apples respectively."}, {"heading": "6.3 Representing Word Meaning in Context", "text": "A long-standing topic in distributional semantics has been the modification of a canonical representation of a lexeme\u2019s meaning to reflect the context in which it is found. Typically, a canonical vector for a lexeme is estimated from all corpus occurrences and the vector then modified to reflect the instance context (Lund and Burgess, 1996; Erk and Pado\u0301, 2008; Mitchell and Lapata, 2008; Thater, Dinu, and Pinkal, 2009; Thater, Fu\u0308rstenau, and Pinkal, 2010; Thater, Fu\u0308rstenau, and Pinkal, 2011; Van de Cruys, Poibeau, and Korhonen, 2011; Erk, 2012).\nAs described in Mitchell and Lapata (2008, 2010), lexeme vectors have typically been modified using simple additive and multiplicative compositional functions. Other approaches, however, share with our proposal the use of syntax to drive modification of the distributional representation (Erk and Pado\u0301, 2008; Thater, Dinu, and Pinkal, 2009; Thater, Fu\u0308rstenau, and Pinkal, 2010; Thater, Fu\u0308rstenau, and Pinkal, 2011).\nErk and Pado\u0301 (2008) introduced a structured vector space model of word meaning that computes the meaning of a word in the context of another word via selectional preferences. This approach was shown to work well at ranking paraphrases taken from the SemEval2007 lexical substitution task (McCarthy and Navigli, 2007). In the Erk & Pado\u0301 approach, the meaning of ball in the context of the phrase catch ball is computed by combining the lexical vector for ball with the object preference vector of catch i.e. things which can be caught. Whilst this approach is based on very similar intuitions to ours, it is in fact quite different. The lexical vector which is modified is not the co-occurrence vector, as in our\nmodel, but a vector of neighbours computed from co-occurrences. For example, the lexical vector for catch in the Erk & Pado\u0301 approach might contain throw, catch and organise. These neighbours of catch are then combined with verbs which have been seen with ball in the direct object relation using vector addition or component-wise multiplication. Thus, it is possible to carry out this approach with reference only to observed first order grammatical dependency relationship. In their experiments, they used the \u201cdependency-based\u201d vector space of Pado\u0301 and Lapata (2007) where target and context words are linked by a valid dependency path (i.e. not necessarily a single first-order grammatical relation). However, higher-order dependency paths were purely used to provide extra contexts for target words, than would be seen in a traditional first-order dependency model, during the computation of neighbour sets. Further, the Erk & Pado\u0301 approach does not construct a representation of the phrase since this model is focussed on lexical disambiguation rather than composition and it is not obvious how one would carry out further disambiguations within the context of a whole sentence.\nMore recently, Thater, Fu\u0308rstenau, and Pinkal (2011) used a similar approach but considered a broader range of operations for combining two vectors where individual vector components are reweighted. Specifically, they found that reweighting vector components based on the distributional similarity score between words defining vector components and the observed context words led to improved performance at ranking paraphrases.\nThater, Fu\u0308rstenau, and Pinkal (2010) noted that vectors of two syntactically related words typically have different syntactic environments, making it difficult to combine information in the respective vectors. They build on Thater, Dinu, and Pinkal (2009), where the meaning of argument nouns was modelled in terms of the predicates they co-occur with (referred to as a first-order vector) and the meaning of predicates in terms of second-order co-occurrence frequencies with other predicates. These predicate vectors can be obtained by adding argument vectors. For example, the verb catch will contain counts on the dimension for kick introduced by the direct-object ball and counts on the dimension for contract introduced by the direct-object cold. In other words, like in the Erk & Pado\u0301 approach, the vector for a verb can be seen as a vector of similar verbs, thus making this notion of second-order dependency compatible with that used in work on word sense discrimination (Schu\u0308tze, 1998) rather than referring to second-order (or higher order) grammatical dependencies as in this work. Contextualisation can then be achieved by multiplication of a second-order predicate vector with a first-order argument vector since this selects the dimensions which are common to both. Thater, Fu\u0308rstenau, and Pinkal (2010) presented a more general model where every word is modelled in terms of first-order and second-order co-occurrences and demonstrate high performance at ranking paraphrases."}, {"heading": "7 Directions for Future Work", "text": ""}, {"heading": "7.1 Representations", "text": "There are a number of apparent limitations of our approach that are simply a reflection of our decision to adopt dependency-based syntactic analysis.\nFirst, surface disparities in syntactic structure (e.g. active versus passive tense formations, compound sentence structures) will disrupt sentence-level comparisons using a simple Apt structure based on surface dependency relations, but this can be addressed, for example, by syntax-based pre-processing. The Apt approach is agnostic in this regard.\nSecond, traditional dependency parsing does not distinguish between the order of modifiers. Hence the phrases happiest blonde person and blonde happiest person receive the same dependency representation and therefore also the same semantic representation. However, we believe that our approach is flexible enough to be able to accommodate a more sensitive grammar formalism which does allow for distinctions in modifier scope to be made if an application demands it. In future work we intend to look at other grammar formalisms including CCG (Steedman, 2000).\nBy proposing a count-based method for composition we are bucking the growing trend of working with prediction-based word embeddings. Whilst there has been initial evidence (Ba-\nroni, Dinu, and Kruszewski, 2014) that prediction-based methods are superior to count-based methods at the lexeme level e.g. for synonym detection and concept categorisation, it has also been shown (Levy and Goldberg, 2014) that the skip-gram model with negative sampling as introduced in Mikolov et al. (2013a) is equivalent to implicit factorisation of the PPMI matrix. Levy, Goldberg, and Dagan (2015) also demonstrated how traditional count-based methods could be improved by transferring hyperparameters used by the prediction-based methods (such as context distribution smoothing and negative sampling). This led to the count-based methods outperforming the prediction-based methods on a number of word similarity tasks. A next step for us is to take the lessons learnt from work on word embeddings and find a way to produce lower dimensionality Apt representations without destroying the necessary structure which drives composition. The advantages of this from a computational point of view are obvious. It remains to be seen what effect the improved generalization also promised by dimensionality reduction will have on composition via Apts.\nBy considering examples, we have seen that composition of Apts using both union and intersection can lead to nearest neighbours which are clearly disambiguating. On benchmark phrase-based composition tasks, the performance of union in Apt composition is close to or equalling the state-of-the-art on those tasks. However, we believe that the performance of intersection in Apt composition is currently limited by the impoverished nature of word representations based directly on corpus statistics. Even given a very large corpus, there are always many plausible co-occurrences which have not been observed. One possible solution, which we explore elsewhere, is to smooth the word representations using their distributional neighbours before applying an intersective composition operation."}, {"heading": "7.2 Applications", "text": "In Section 5.2, we demonstrated the potential for using Apts to carry out word sense disambiguation / induction. Uncontextualised, elementary Apts typically contain a corpusdetermined mixture of co-occurrences referencing different usages. The Apt generated by a dependency tree, however, provides contextualised lexeme representations where the weights have been adjusted by the influence of the contextual lexemes so that the co-occurrences relating to the correct usage have been appropriately up-weighted, and the co-occurrences found in other circumstances down-weighted. In other words, Apt structures automatically perform word sense induction on lexeme-level representations which is demonstrable through the lexeme similarity measure. For example, we observed that the contextualised lexeme representation of body in the Apt constructed by embedding it in the phrase human body had a relatively high similarity to the uncontextualised representation of brain and a relatively low similarity to council, while the equivalent lexeme representation for body embedded in the Apt constructed for the phrase legislative body showed the reverse pattern.\nOne common criticism of distributional thesauruses is that they conflate different semantic relations into a single notion of similarity. For example, when comparing representations based on grammatical dependency relations, the most similar word to an adjective such as hot will usually be found to be its antonym cold. This is because hot and cold are both used to modify many of the same nouns. However, if as in the Apt framework, the representation of cold includes not only the direct dependents of cold, but also the indirect dependents, e.g. verbs which co-occur with cold things, it is possible that more differences between its representation and that of hot might be found. One would imagine that the things which are done to hot things are more different to the things which are done to cold things than they are to the things which are done to very warm things. Further, the examples in Section 5.2 raises the possibility that different composition operations might be used to distinguish different semantic relations including hypernyms, hyponyms and co-hyponyms. For example, \u2294uni tends to lead to more general neighbours (e.g. hypernyms) and \u2294int tends to lead to more specific neighbours (e.g. hyponyms).\nPhrase-level or sentence-level plausibility measures offer the prospect of a continuous measure of the appropriateness / plausibility of a complete phrase or sentence, based on a combination of semantic and syntactic dependency relations. Apts offer a way to measure the plausibility of a lexeme when embedded in a dependency tree, suggesting that Apts may be successfully employed in tackling sentence completion tasks, such as the Microsoft\nResearch Sentence Completion Challenge (Zweig and Burges, 2012). Here the objective is to identify the word that will fill out a partially completed sentence in the best possible way. For example, is flurried or profitable the best completion of the sentence below.\n\u201dPresently he emerged looking even more [flurried / profitable] than before.\u201d\nWe can compose the Apts for the partially completed sentence. Comparing the result with the elementary Apts for each of the candidates should provide a good, direct measurement of which candidate is more plausible. An improved language model has implications for parsing, speech recognition and machine translation.\nA central goal of compositional distributional semantics is to create a data structure that represents an entire phrase or sentence. The composed Apt for a dependency tree provides such a structure, but leaves open the question as to how this structure might be exploited for phrase-level or sentence-level semantic comparison.\nThe first point to be made is that, unusually, we have available not only a representation of the whole dependency tree but also contextualised (vector) representations for the lexemes in the dependency tree. This makes available to us any analytical technique which requires separate analysis of lexical components of the phrase or sentence. However, this leads to the problem of how to read the structure at the global phrase/sentence-level.\nFor similarity measures, one straightforward option would be to create a vector from the Apt anchored at the head of the phrase or sentence being considered. Thus the phrasal vector for a red rose would be created taking the node containing rose as the anchor. In other words, the vector representation of the phrase a red rose will be the same as the contextualised representation of rose. Similarly, the vector representation for the sentence he took the dog for a walk will be the same as the contextualised representation of the verb took.\nSuch a representation provides a continuous model of similarity (and meaning) at the phrasal-level and/or sentence-level. We anticipate that vector comparisons of phrase or sentence-level vectors produced in this manner will provide some coherent numerical measure of distributional similarity. This approach should be useful for paraphrase recognition tasks. For example, in order to identify good candidate paraphrases for questions in a questionanswering task, Berant and Liang (2014) employ a paraphrase model based on adding word embeddings constructed using the CBOW model of Mikolov et al. (2013). Whilst the authors achieve state-of-the-art using a mixture of methods, a paraphrase model based on the addition of vectors of untyped co-occurrences alone cannot distinguish meanings where syntax is important. For example, the sentences Oswald shot Kennedy and Kennedy shot Oswald would have the same representations. On the other hand, Apt composition is syntax-driven and will provide a representation of each sentence which is sensitive to lexical meaning and syntax.\nAnother advantage of using Apt composition in paraphrase recognition, over some other syntax-driven proposals, is that the same structure is used to represent words, phrases and sentences. Provided the head node is of the same type of speech, words and phrases of different lengths can easily be compared within our model. An adjective-noun compound such as male sibling is directly comparable with the single noun brother. Further, there is no need for there to be high similarity between aligned components of phrases or sentences. For example, the phrase female scholar can be expected to have a high similarity with the phrase educated woman, in terms at least of their external contexts."}, {"heading": "8 Conclusions", "text": "This paper presents a new theory of compositional distributional semantics. It employs a single structure, the Apt, which can represent the distributional semantics of lexemes, phrases and even sentences. By retaining higher-order grammatical structure in the representations of lexemes, composition captures mutual disambiguation and mutual generalisation of constituents. Apts allow lexemes and phrases to be compared in isolation or in context. Further, we have demonstrated how one instantiation of this theory can achieve results which\nare very competitive with state-of-the-art results on benchmark phrase-based composition tasks.\nAs we have discussed, Apts have a wide range of potential applications including word sense induction, word sense disambiguation, parse reranking, dependency parsing and language modelling more generally, and also paraphrase recognition. Further work is required to gain an understanding of which instantiations of the theory are suited to each of these applications."}, {"heading": "9 Acknowledgements", "text": "This work was funded by UK EPSRC project EP/IO37458/1 \u201cA Unified Model of Compositional and Distributional Compositional Semantics: Theory and Applications\u201d. We would like to thank all members of the DISCO project team. Particular thanks to Miroslav Batchkarov, Stephen Clark, Daoud Clarke, Roland Davis, Bill Keller, Tamara Polajnar, Laura Rimell, Mehrnoosh Sadrzadeh, David Sheldrick and Andreas Vlachos. We would also like to thank the anonymous reviewers for their helpful comments."}], "references": [{"title": "Don\u2019t count, predict! a systematic comparison of contextcounting vs. context-predicting semantic vectors", "author": ["Baroni", "Dinu", "Kruszewski2014] Baroni", "Marco", "Georgiana Dinu", "Germ\u00e1n Kruszewski"], "venue": "In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),", "citeRegEx": "Baroni et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2014}, {"title": "Distributional memory: A general framework for corpus-based semantics", "author": ["Baroni", "Lenci2010] Baroni", "Marco", "Alessandro Lenci"], "venue": "Computational Linguistics,", "citeRegEx": "Baroni et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2010}, {"title": "Nouns are vectors, adjectives are matrices: Representing adjective-noun constructions in semantic space", "author": ["Baroni", "Zamparelli2010] Baroni", "Marco", "Roberto Zamparelli"], "venue": "In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Baroni et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2010}, {"title": "Semantic parsing via paraphrasing. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["Berant", "Liang2014] Berant", "Jonathan", "Percy Liang"], "venue": null, "citeRegEx": "Berant et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Berant et al\\.", "year": 2014}, {"title": "A comparison of vectorbased representations for semantic composition", "author": ["Blacoe", "Lapata2012] Blacoe", "William", "Mirella Lapata"], "venue": "In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,", "citeRegEx": "Blacoe et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Blacoe et al\\.", "year": 2012}, {"title": "Multimodal distributional semantics", "author": ["Bruni", "Tran", "Baroni2014] Bruni", "Elia", "Nam Khanh Tran", "Marco Baroni"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Bruni et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Bruni et al\\.", "year": 2014}, {"title": "Context-theoretic Semantics for Natural Language: an Algebraic Framework", "author": ["Clarke", "Daoud"], "venue": "Ph.D. thesis,", "citeRegEx": "Clarke and Daoud.,? \\Q2007\\E", "shortCiteRegEx": "Clarke and Daoud.", "year": 2007}, {"title": "A context-theoretic framework for compositionality in distributional semantics", "author": ["Clarke", "Daoud"], "venue": "Computational Linguistics,", "citeRegEx": "Clarke and Daoud.,? \\Q2012\\E", "shortCiteRegEx": "Clarke and Daoud.", "year": 2012}, {"title": "Mathematical foundations for a compositional distributed model of meaning", "author": ["Coecke", "Sadrzadeh", "Clark2011] Coecke", "Bob", "Mehrnoosh Sadrzadeh", "Stephen Clark"], "venue": "Linguistic Analysis,", "citeRegEx": "Coecke et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Coecke et al\\.", "year": 2011}, {"title": "A unified architecture for natural language processing: Deep neural networks with multitask learning", "author": ["Collobert", "Weston2008] Collobert", "Ronan", "Jason Weston"], "venue": "In Proceedings of the 25th International Conference on Machine Learning,", "citeRegEx": "Collobert et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Collobert et al\\.", "year": 2008}, {"title": "From Distributional to Semantic Similarity", "author": ["Curran", "James"], "venue": "Ph.D. thesis,", "citeRegEx": "Curran and James.,? \\Q2004\\E", "shortCiteRegEx": "Curran and James.", "year": 2004}, {"title": "Similarity-based estimation of word cooccurrence probabilities", "author": ["Dagan", "Pereira", "Lee1994] Dagan", "Ido", "Fernando Pereira", "Lillian Lee"], "venue": "In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Dagan et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Dagan et al\\.", "year": 1994}, {"title": "General estimation and evaluation of compositional distributional semantic models", "author": ["Dinu", "Pham", "Baroni2013] Dinu", "Georgiana", "Nghia The Pham", "Marco Baroni"], "venue": "In Proceedings of the Workshop on Continuous Vector Space Models and their Compositionality,", "citeRegEx": "Dinu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Dinu et al\\.", "year": 2013}, {"title": "Saarland: Vector-based models of semantic textual similarity", "author": ["Dinu", "Thater2012] Dinu", "Georgiana", "Stefan Thater"], "venue": "*SEM", "citeRegEx": "Dinu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dinu et al\\.", "year": 2012}, {"title": "Vector space models of word meaning and phrase meaning: A survey", "author": ["Erk", "Katrin"], "venue": "Language and Linguistics Compass,", "citeRegEx": "Erk and Katrin.,? \\Q2012\\E", "shortCiteRegEx": "Erk and Katrin.", "year": 2012}, {"title": "A structured vector space model for word meaning in context", "author": ["Erk", "Pad\u00f32008] Erk", "Katrin", "Sebastian Pad\u00f3"], "venue": "In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Erk et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Erk et al\\.", "year": 2008}, {"title": "Introducing and evaluating ukwac, a very large web-derived corpus of english", "author": ["Ferraresi et al.2008] Ferraresi", "Adriano", "Eros Zanchetta", "Marco Baroni", "Silvia Bernardini"], "venue": "In Proceedings of the WAC4 Workshop at LREC", "citeRegEx": "Ferraresi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ferraresi et al\\.", "year": 2008}, {"title": "Placing search in context: The concept revisited", "author": ["Lev", "Evgeniy Gabrilovich", "Yossi Matias", "Ehud Rivlin", "Zach Solan", "Gadi Wolfman", "Eytan Ruppin"], "venue": "In Proceedings of the 10th International Conference on World Wide Web, WWW", "citeRegEx": "Finkelstein et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Finkelstein et al\\.", "year": 2001}, {"title": "Integrating logical representations with probabilistic information using markov logic", "author": ["Garrette", "Erk", "Mooney2011] Garrette", "Dan", "Katrin Erk", "Raymond Mooney"], "venue": "In Proceedings of the Ninth International Conference on Computational Semantics,", "citeRegEx": "Garrette et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Garrette et al\\.", "year": 2011}, {"title": "Multi-step regression learning for compositional distributional semantics", "author": ["Edward", "Georgiana Dinu", "Yao-Zhong Zhang", "Mehrnoosh Sadrzadeh", "Marco Baroni"], "venue": "Proceedings of the Tenth International Conference on Computational Semantics", "citeRegEx": "Grefenstette et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Grefenstette et al\\.", "year": 2013}, {"title": "A regression model of adjective-noun compositionality in distributional semantics", "author": ["Guevara", "Emiliano"], "venue": "In Proceedings of the ACL GEMS Workshop,", "citeRegEx": "Guevara and Emiliano.,? \\Q2010\\E", "shortCiteRegEx": "Guevara and Emiliano.", "year": 2010}, {"title": "The role of syntax in vector space models of compositional semantics. In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["Hermann", "Blunsom2013] Hermann", "Karl Moritz", "Phil Blunsom"], "venue": "Association for Computational Linguistics", "citeRegEx": "Hermann et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hermann et al\\.", "year": 2013}, {"title": "Simlex-999: Evaluating semantic models with (genuine) similarity estimation", "author": ["Hill", "Reichart", "Korhonen2015] Hill", "Felix", "Roi Reichart", "Anna Korhonen"], "venue": "Computational Linguistics,", "citeRegEx": "Hill et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Hill et al\\.", "year": 2015}, {"title": "A systematic study of semantic vector space model parameters", "author": ["Kiela", "Clark2014] Kiela", "Douwe", "Stephen Clark"], "venue": "In Proceedings of the 2nd Workshop on Continuous Vector Space Models and their Compositionality (CVSC),", "citeRegEx": "Kiela et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kiela et al\\.", "year": 2014}, {"title": "Type grammar revisited", "author": ["J. Lambek"], "venue": "Logical Aspects of Computational Linguistics,", "citeRegEx": "Lambek,? \\Q1999\\E", "shortCiteRegEx": "Lambek", "year": 1999}, {"title": "Measures of distributional similarity", "author": ["Lee", "Lillian"], "venue": "In Proceedings of the 37th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Lee and Lillian.,? \\Q1999\\E", "shortCiteRegEx": "Lee and Lillian.", "year": 1999}, {"title": "Neural word embedding as implicit matrix factorization", "author": ["Levy", "Goldberg2014] Levy", "Omer", "Yoav Goldberg"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Levy et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Levy et al\\.", "year": 2014}, {"title": "Improving distributional similarity with lessons learned from word embeddings. Transactions of the Association for Computational Linguistics, 3:211\u2013225", "author": ["Levy", "Goldberg", "Dagan2015] Levy", "Omer", "Yoav Goldberg", "Ido Dagan"], "venue": null, "citeRegEx": "Levy et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Levy et al\\.", "year": 2015}, {"title": "Combined distributional and logical semantics", "author": ["Lewis", "Steedman2013] Lewis", "Mike", "Mark Steedman"], "venue": "In Transactions of the Association for Computational Linguistics,", "citeRegEx": "Lewis et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Lewis et al\\.", "year": 2013}, {"title": "Automatic retrieval and clustering of similar words", "author": ["Lin", "Dekang"], "venue": "In Proceedings of the 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics,", "citeRegEx": "Lin and Dekang.,? \\Q1998\\E", "shortCiteRegEx": "Lin and Dekang.", "year": 1998}, {"title": "Producing high-dimensional semantic spaces from lexical co-occurrence", "author": ["Lund", "Burgess1996] Lund", "Kevin", "Curt Burgess"], "venue": "Behavior Research Methods, Instruments,", "citeRegEx": "Lund et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Lund et al\\.", "year": 1996}, {"title": "Semeval-2007 task 10: English lexical substitution task", "author": ["McCarthy", "Navigli2007] McCarthy", "Diana", "Robert Navigli"], "venue": "In Proceedings of the 4th International Workshop on Semantic Evaluations", "citeRegEx": "McCarthy et al\\.,? \\Q2007\\E", "shortCiteRegEx": "McCarthy et al\\.", "year": 2007}, {"title": "Efficient estimation of word representations in vector space. arXiv preprint arXiv:1301.3781", "author": ["Mikolov et al.2013a] Mikolov", "Tomas", "Kai Chen", "Greg Corrado", "Jeffrey Dean"], "venue": null, "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Distributed representations of words and phrases and their compositionality", "author": ["Mikolov et al.2013b] Mikolov", "Tomas", "Ilya Sutskever", "Kai Chen", "Greg S Corrado", "Jeff Dean"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Linguistic regularities in continuous space word representations", "author": ["Mikolov", "Yih", "Zweig2013] Mikolov", "Tomas", "Wen-tau Yih", "Geoffrey Zweig"], "venue": "In Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Vector-based models of semantic composition", "author": ["Mitchell", "Lapata2008] Mitchell", "Jeff", "Mirella Lapata"], "venue": "In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics: Human Language Technology Conference,", "citeRegEx": "Mitchell et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Mitchell et al\\.", "year": 2008}, {"title": "Composition in distributional models of semantics", "author": ["Mitchell", "Lapata2010] Mitchell", "Jeff", "Mirella Lapata"], "venue": "Cognitive Science,", "citeRegEx": "Mitchell et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Mitchell et al\\.", "year": 2010}, {"title": "English as a formal language", "author": ["Montague", "Richard"], "venue": null, "citeRegEx": "Montague and Richard.,? \\Q1970\\E", "shortCiteRegEx": "Montague and Richard.", "year": 1970}, {"title": "Dependency-based construction of semantic space models", "author": ["Pad\u00f3", "Lapata2007] Pad\u00f3", "Sebastian", "Mirella Lapata"], "venue": "Computational Linguistics,", "citeRegEx": "Pad\u00f3 et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Pad\u00f3 et al\\.", "year": 2007}, {"title": "Glove: Global vectors for word representation", "author": ["Pennington", "Socher", "Manning2014] Pennington", "Jeffrey", "Richard Socher", "Christopher Manning"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Pennington et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Pennington et al\\.", "year": 2014}, {"title": "Dynamic pooling and unfolding recursive autoencoders for paraphrase detection", "author": ["Socher", "Richard", "Eric H. Huang", "Jeffrey Pennington", "Christopher D Manning", "Andrew Y. Ng"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Socher et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2011}, {"title": "Semantic compositionality through recursive matrix-vector spaces", "author": ["Socher et al.2012] Socher", "Richard", "Brody Huval", "Christopher D. Manning", "Andrew Y. Ng"], "venue": "In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,", "citeRegEx": "Socher et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2012}, {"title": "Semi-supervised recursive autoencoders for predicting sentiment distributions", "author": ["Socher et al.2011] Socher", "Richard", "Jeffrey Pennington", "Eric H. Huang", "Andrew Y. Ng", "Christopher D. Manning"], "venue": "In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Socher et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2011}, {"title": "Recursive deep models for semantic compositionality over a sentiment treebank", "author": ["Socher et al.2013] Socher", "Richard", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher D. Manning", "Andrew Ng", "Christopher Potts"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Socher et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2013}, {"title": "Ranking paraphrases in context", "author": ["Thater", "Dinu", "Pinkal2009] Thater", "Stefan", "Georgiana Dinu", "Manfred Pinkal"], "venue": "In Proceedings of the 2009 ACL Workshop on Applied Textual Inference,", "citeRegEx": "Thater et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Thater et al\\.", "year": 2009}, {"title": "Contextualizing semantic representations using syntactically enriched vector models", "author": ["Thater", "F\u00fcrstenau", "Pinkal2010] Thater", "Stefan", "Hagen F\u00fcrstenau", "Manfred Pinkal"], "venue": "In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Thater et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Thater et al\\.", "year": 2010}, {"title": "Word meaning in context: A simple and effective vector model", "author": ["Thater", "F\u00fcrstenau", "Pinkal2011] Thater", "Stefan", "Hagen F\u00fcrstenau", "Manfred Pinkal"], "venue": "In Proceedings of 5th International Joint Conference on Natural Language Processing,", "citeRegEx": "Thater et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Thater et al\\.", "year": 2011}, {"title": "Domain and function: A dual-space model of semantic relations and compositions", "author": ["Turney", "Peter D"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Turney and D.,? \\Q2012\\E", "shortCiteRegEx": "Turney and D.", "year": 2012}, {"title": "From frequency to meaning: Vector space models of semantics", "author": ["Turney", "Pantel2010] Turney", "Peter D", "Patrick Pantel"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Turney et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Turney et al\\.", "year": 2010}, {"title": "Latent vector weighting for word meaning in context", "author": ["Van de Cruys", "Poibeau", "Korhonen2011] Van de Cruys", "Tim", "Thierry Poibeau", "Anna Korhonen"], "venue": "In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Cruys et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Cruys et al\\.", "year": 2011}, {"title": "Measures and Applications of Lexical Distributional Similarity", "author": ["Weeds", "Julie"], "venue": "Ph.D. thesis,", "citeRegEx": "Weeds and Julie.,? \\Q2003\\E", "shortCiteRegEx": "Weeds and Julie.", "year": 2003}, {"title": "Co-occurrence retrieval: a flexible framework for distributional similarity", "author": ["Weeds", "Weir2005] Weeds", "Julie", "David Weir"], "venue": "Computational Linguistics,", "citeRegEx": "Weeds et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Weeds et al\\.", "year": 2005}, {"title": "Characterising measures of lexical distributional similarity", "author": ["Weeds", "Weir", "McCarthy2004] Weeds", "Julie", "David Weir", "Diana McCarthy"], "venue": "In Proceedings of the 20th International Conference on Computational Linguistics,", "citeRegEx": "Weeds et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Weeds et al\\.", "year": 2004}, {"title": "Distributional composition using higher-order dependency vectors", "author": ["Weeds", "Weir", "Reffin2014] Weeds", "Julie", "David Weir", "Jeremy Reffin"], "venue": "In Proceedings of the 2nd Workshop on Continuous Vector Space Models and their Compositionality (CVSC),", "citeRegEx": "Weeds et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Weeds et al\\.", "year": 2014}, {"title": "The unknown perils of mining wikipedia. https://blog.lateral.io/2015/06/the-unknown-perils-of-mining-wikipedia/, June", "author": ["Wilson", "Benjamin"], "venue": null, "citeRegEx": "Wilson and Benjamin.,? \\Q2015\\E", "shortCiteRegEx": "Wilson and Benjamin.", "year": 2015}, {"title": "A challenge set for advancing language modeling", "author": ["Zweig", "Burges2012] Zweig", "Geoffrey", "Chris JC Burges"], "venue": "In Proceedings of the NAACL-HLT", "citeRegEx": "Zweig et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zweig et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 19, "context": "It has been tokenised, POS-tagged, lemmatised and dependency-parsed as described in Grefenstette et al. (2013) and contains approximately 0.", "startOffset": 84, "endOffset": 111}, {"referenceID": 16, "context": "\u2022 concat is a concatenation of the ukWaC corpus (Ferraresi et al., 2008), a mid-2009 dump of the English Wikipedia and the British National Corpus.", "startOffset": 48, "endOffset": 72}, {"referenceID": 16, "context": "\u2022 concat is a concatenation of the ukWaC corpus (Ferraresi et al., 2008), a mid-2009 dump of the English Wikipedia and the British National Corpus. This corpus has been tokenised, POS-tagged, lemmatised and dependency-parsed as described in Grefenstette et al. (2013) and contains about 2.", "startOffset": 49, "endOffset": 268}, {"referenceID": 17, "context": "(Levy, Goldberg, and Dagan, 2015), we tuned on a number of popular word similarity tasks: MEN (Bruni, Tran, and Baroni, 2014); WordSim-353 (Finkelstein et al., 2001); and SimLex-999 (Hill, Reichart, and Korhonen, 2015).", "startOffset": 139, "endOffset": 165}, {"referenceID": 17, "context": "(Levy, Goldberg, and Dagan, 2015), we tuned on a number of popular word similarity tasks: MEN (Bruni, Tran, and Baroni, 2014); WordSim-353 (Finkelstein et al., 2001); and SimLex-999 (Hill, Reichart, and Korhonen, 2015). In these tuning experiments, we found that context distribution smoothing gave mixed results. However, shifting PPMI (k = 10) gave optimal results across all of the word similarity tasks. Therefore we report results here for vanilla PPMI (shift k = 1) and shifted PPMI (shift k = 10). For composition, we report results for both \u2294uni and \u2294int. Results are shown in Table 5. For this task and with this corpus \u2294uni consistently outperforms \u2294int. Shifting PPMI by log 10 consistently improves results for \u2294uni, but has a large negative effect on the results for \u2294int. We believe that this is due to the relatively small size of the corpus. Shifting PPMI reduces the number of non-zero dimensions in each vector which increases the likelihood of a zero intersection. In the case of AN composition, all of the intersections were zero for this setting, making it impossible to compute a correlation. Comparing these results with the state-of-the-art, we can see that \u2294uni clearly outperforms DM and NLM as tested by Blacoe and Lapata (2012). This method of composition is also achieving close to the best results in Mitchell and Lapata (2010) and Blacoe and Lapata (2012).", "startOffset": 140, "endOffset": 1256}, {"referenceID": 17, "context": "(Levy, Goldberg, and Dagan, 2015), we tuned on a number of popular word similarity tasks: MEN (Bruni, Tran, and Baroni, 2014); WordSim-353 (Finkelstein et al., 2001); and SimLex-999 (Hill, Reichart, and Korhonen, 2015). In these tuning experiments, we found that context distribution smoothing gave mixed results. However, shifting PPMI (k = 10) gave optimal results across all of the word similarity tasks. Therefore we report results here for vanilla PPMI (shift k = 1) and shifted PPMI (shift k = 10). For composition, we report results for both \u2294uni and \u2294int. Results are shown in Table 5. For this task and with this corpus \u2294uni consistently outperforms \u2294int. Shifting PPMI by log 10 consistently improves results for \u2294uni, but has a large negative effect on the results for \u2294int. We believe that this is due to the relatively small size of the corpus. Shifting PPMI reduces the number of non-zero dimensions in each vector which increases the likelihood of a zero intersection. In the case of AN composition, all of the intersections were zero for this setting, making it impossible to compute a correlation. Comparing these results with the state-of-the-art, we can see that \u2294uni clearly outperforms DM and NLM as tested by Blacoe and Lapata (2012). This method of composition is also achieving close to the best results in Mitchell and Lapata (2010) and Blacoe and Lapata (2012).", "startOffset": 140, "endOffset": 1358}, {"referenceID": 17, "context": "(Levy, Goldberg, and Dagan, 2015), we tuned on a number of popular word similarity tasks: MEN (Bruni, Tran, and Baroni, 2014); WordSim-353 (Finkelstein et al., 2001); and SimLex-999 (Hill, Reichart, and Korhonen, 2015). In these tuning experiments, we found that context distribution smoothing gave mixed results. However, shifting PPMI (k = 10) gave optimal results across all of the word similarity tasks. Therefore we report results here for vanilla PPMI (shift k = 1) and shifted PPMI (shift k = 10). For composition, we report results for both \u2294uni and \u2294int. Results are shown in Table 5. For this task and with this corpus \u2294uni consistently outperforms \u2294int. Shifting PPMI by log 10 consistently improves results for \u2294uni, but has a large negative effect on the results for \u2294int. We believe that this is due to the relatively small size of the corpus. Shifting PPMI reduces the number of non-zero dimensions in each vector which increases the likelihood of a zero intersection. In the case of AN composition, all of the intersections were zero for this setting, making it impossible to compute a correlation. Comparing these results with the state-of-the-art, we can see that \u2294uni clearly outperforms DM and NLM as tested by Blacoe and Lapata (2012). This method of composition is also achieving close to the best results in Mitchell and Lapata (2010) and Blacoe and Lapata (2012). It is interesting to note that our model does substantially better than the stateof-the-art on verb-object composition, but is considerably worse at noun-noun composition.", "startOffset": 140, "endOffset": 1387}, {"referenceID": 19, "context": "This dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013).", "startOffset": 56, "endOffset": 83}, {"referenceID": 19, "context": "This dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013). These evaluations clearly follow the experimental procedure of Mitchell and Lapata and do not evaluate against mean scores.", "startOffset": 56, "endOffset": 117}, {"referenceID": 19, "context": "This dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013). These evaluations clearly follow the experimental procedure of Mitchell and Lapata and do not evaluate against mean scores. Instead, separate points are created for each human annotator, as discussed in Section 5.3.1. The multi-step regression algorithm of Grefenstette et al. (2013) achieved \u03c1 = 0.", "startOffset": 56, "endOffset": 402}, {"referenceID": 19, "context": "This dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013). These evaluations clearly follow the experimental procedure of Mitchell and Lapata and do not evaluate against mean scores. Instead, separate points are created for each human annotator, as discussed in Section 5.3.1. The multi-step regression algorithm of Grefenstette et al. (2013) achieved \u03c1 = 0.23 on this dataset. In the evaluation of Dinu, Pham, and Baroni (2013), the lexical function algorithm, which learns a matrix representation for each functor and defines composition as matrix-vector multiplication, was the best performing compositional algorithm at this task.", "startOffset": 56, "endOffset": 488}, {"referenceID": 19, "context": "This dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013). These evaluations clearly follow the experimental procedure of Mitchell and Lapata and do not evaluate against mean scores. Instead, separate points are created for each human annotator, as discussed in Section 5.3.1. The multi-step regression algorithm of Grefenstette et al. (2013) achieved \u03c1 = 0.23 on this dataset. In the evaluation of Dinu, Pham, and Baroni (2013), the lexical function algorithm, which learns a matrix representation for each functor and defines composition as matrix-vector multiplication, was the best performing compositional algorithm at this task. With optimal parameter settings, it achieved around \u03c1 = 0.26. In this evaluation, the full additive model of Guevara (2010) achieved \u03c1 < 0.", "startOffset": 56, "endOffset": 818}, {"referenceID": 19, "context": "This dataset was used in the evaluations carried out by Grefenstette et al. (2013) and Dinu, Pham, and Baroni (2013). These evaluations clearly follow the experimental procedure of Mitchell and Lapata and do not evaluate against mean scores. Instead, separate points are created for each human annotator, as discussed in Section 5.3.1. The multi-step regression algorithm of Grefenstette et al. (2013) achieved \u03c1 = 0.23 on this dataset. In the evaluation of Dinu, Pham, and Baroni (2013), the lexical function algorithm, which learns a matrix representation for each functor and defines composition as matrix-vector multiplication, was the best performing compositional algorithm at this task. With optimal parameter settings, it achieved around \u03c1 = 0.26. In this evaluation, the full additive model of Guevara (2010) achieved \u03c1 < 0.05. In order to make our results directly comparable with these previous evaluations, we have used the same corpus to construct our Apt lexicons, namely the concat corpus described in Section 5.1. Otherwise, the Apt lexicon was constructed as described in Section 5.3.1. As before note that k = 1 in shifted PPMI is equivalent to not shifting PPMI. Results are shown in Table 6. We see that \u2294uni is highly competitive with the optimised lexical function model which was the best performing model in the evaluation of Dinu, Pham, and Baroni (2013). In that evaluation, the lexical function model achieved between 0.", "startOffset": 56, "endOffset": 1380}, {"referenceID": 19, "context": "23 Grefenstette et al. (2013)", "startOffset": 3, "endOffset": 30}, {"referenceID": 19, "context": "23 which equals the performance of the multi-step regression algorithm Grefenstette et al. (2013). Here, however, shifting PPMI has a negative impact on performance.", "startOffset": 71, "endOffset": 98}, {"referenceID": 32, "context": "The word embeddings learnt by the continuous bag-of-words model (CBOW) and the continuous skip-gram model proposed by Mikolov et al. (2013a, 2013b) are currently among the most popular forms of distributional word representations. Whilst using a neural network architecture, the intuitions behind such distributed representations of words are the same as in traditional distributional representations. As argued by Pennington et al. (2014), both count-based and prediction-based models probe the underlying corpus co-occurrences statistics.", "startOffset": 118, "endOffset": 440}, {"referenceID": 32, "context": "The word embeddings learnt by the continuous bag-of-words model (CBOW) and the continuous skip-gram model proposed by Mikolov et al. (2013a, 2013b) are currently among the most popular forms of distributional word representations. Whilst using a neural network architecture, the intuitions behind such distributed representations of words are the same as in traditional distributional representations. As argued by Pennington et al. (2014), both count-based and prediction-based models probe the underlying corpus co-occurrences statistics. For example, the CBOW architecture predicts the current word based on context (which is viewed as a bag-of-words) and the skip-gram architecture predicts surrounding words given the current word. Mikolov et al. (2013c) showed that it is possible to use these models to efficiently learn low-dimensional representations for words which appear to capture both syntactic and semantic regularities.", "startOffset": 118, "endOffset": 760}, {"referenceID": 32, "context": "The word embeddings learnt by the continuous bag-of-words model (CBOW) and the continuous skip-gram model proposed by Mikolov et al. (2013a, 2013b) are currently among the most popular forms of distributional word representations. Whilst using a neural network architecture, the intuitions behind such distributed representations of words are the same as in traditional distributional representations. As argued by Pennington et al. (2014), both count-based and prediction-based models probe the underlying corpus co-occurrences statistics. For example, the CBOW architecture predicts the current word based on context (which is viewed as a bag-of-words) and the skip-gram architecture predicts surrounding words given the current word. Mikolov et al. (2013c) showed that it is possible to use these models to efficiently learn low-dimensional representations for words which appear to capture both syntactic and semantic regularities. Mikolov et al. (2013b) also demonstrated the possibility of composing skip-gram representations using addition.", "startOffset": 118, "endOffset": 959}, {"referenceID": 24, "context": "Separately, Coecke, Sadrzadeh, and Clark (2011) proposed a broader compositional framework that incorporated from formal semantics the notion of function application derived from syntactic structure (Montague, 1970; Lambek, 1999).", "startOffset": 199, "endOffset": 229}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013).", "startOffset": 198, "endOffset": 225}, {"referenceID": 41, "context": "The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013).", "startOffset": 101, "endOffset": 143}, {"referenceID": 43, "context": "The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013).", "startOffset": 101, "endOffset": 143}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix.", "startOffset": 199, "endOffset": 268}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix.", "startOffset": 199, "endOffset": 311}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition.", "startOffset": 199, "endOffset": 485}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition. This model, however, was made much more flexible by requiring and using task-specific labelled training data to create taskspecific distributional data structures, and by allowing non-linear relationships between component data structures and the composed result. The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013). However, whilst these approaches all pay attention to syntax, they all require large amounts of training data. For example, running regression models to accurately predict the matrix or tensor for each individual adjective or verb requires a large number of exemplar compositions containing that adjective or verb. Socher\u2019s MV-RNN model further requires task-specific labelled training data. Our approach, on the other hand, is purely count-based and directly aggregates information about each word from the corpus. Other approaches have been proposed. Clarke (2007, 2012) suggested a context-theoretic semantic framework, incorporating a generative model that assigned probabilities to arbitrary word sequences. This approach shared with Coecke, Sadrzadeh, and Clark (2011) an ambition to provide a bridge between compositional distributional semantics and formal logic-based semantics.", "startOffset": 199, "endOffset": 1728}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition. This model, however, was made much more flexible by requiring and using task-specific labelled training data to create taskspecific distributional data structures, and by allowing non-linear relationships between component data structures and the composed result. The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013). However, whilst these approaches all pay attention to syntax, they all require large amounts of training data. For example, running regression models to accurately predict the matrix or tensor for each individual adjective or verb requires a large number of exemplar compositions containing that adjective or verb. Socher\u2019s MV-RNN model further requires task-specific labelled training data. Our approach, on the other hand, is purely count-based and directly aggregates information about each word from the corpus. Other approaches have been proposed. Clarke (2007, 2012) suggested a context-theoretic semantic framework, incorporating a generative model that assigned probabilities to arbitrary word sequences. This approach shared with Coecke, Sadrzadeh, and Clark (2011) an ambition to provide a bridge between compositional distributional semantics and formal logic-based semantics. In a similar vein, Garrette, Erk, and Mooney (2011) combined word-level distributional vector representations with logic-based representation using a probabilistic reasoning framework.", "startOffset": 199, "endOffset": 1893}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition. This model, however, was made much more flexible by requiring and using task-specific labelled training data to create taskspecific distributional data structures, and by allowing non-linear relationships between component data structures and the composed result. The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013). However, whilst these approaches all pay attention to syntax, they all require large amounts of training data. For example, running regression models to accurately predict the matrix or tensor for each individual adjective or verb requires a large number of exemplar compositions containing that adjective or verb. Socher\u2019s MV-RNN model further requires task-specific labelled training data. Our approach, on the other hand, is purely count-based and directly aggregates information about each word from the corpus. Other approaches have been proposed. Clarke (2007, 2012) suggested a context-theoretic semantic framework, incorporating a generative model that assigned probabilities to arbitrary word sequences. This approach shared with Coecke, Sadrzadeh, and Clark (2011) an ambition to provide a bridge between compositional distributional semantics and formal logic-based semantics. In a similar vein, Garrette, Erk, and Mooney (2011) combined word-level distributional vector representations with logic-based representation using a probabilistic reasoning framework. Lewis and Steedman (2013) also attempted to combine distributional and logical semantics by learning a lexicon for CCG (Combinatory Categorial Grammar (Steedman, 2000)) which first maps natural language to a deterministic logical form and then performs a distributional clustering over logical predicates based on arguments.", "startOffset": 199, "endOffset": 2052}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition. This model, however, was made much more flexible by requiring and using task-specific labelled training data to create taskspecific distributional data structures, and by allowing non-linear relationships between component data structures and the composed result. The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013). However, whilst these approaches all pay attention to syntax, they all require large amounts of training data. For example, running regression models to accurately predict the matrix or tensor for each individual adjective or verb requires a large number of exemplar compositions containing that adjective or verb. Socher\u2019s MV-RNN model further requires task-specific labelled training data. Our approach, on the other hand, is purely count-based and directly aggregates information about each word from the corpus. Other approaches have been proposed. Clarke (2007, 2012) suggested a context-theoretic semantic framework, incorporating a generative model that assigned probabilities to arbitrary word sequences. This approach shared with Coecke, Sadrzadeh, and Clark (2011) an ambition to provide a bridge between compositional distributional semantics and formal logic-based semantics. In a similar vein, Garrette, Erk, and Mooney (2011) combined word-level distributional vector representations with logic-based representation using a probabilistic reasoning framework. Lewis and Steedman (2013) also attempted to combine distributional and logical semantics by learning a lexicon for CCG (Combinatory Categorial Grammar (Steedman, 2000)) which first maps natural language to a deterministic logical form and then performs a distributional clustering over logical predicates based on arguments. The CCG formalism was also used by Hermann and Blunsom (2013) as a means for incorporating syntax-sensitivity into vector space representations of sentential semantics based on recursive auto-encoders (Socher et al.", "startOffset": 199, "endOffset": 2413}, {"referenceID": 19, "context": "These two approaches were subsequently combined and extended to incorporate simple transitive and intransitive sentences, with functions represented by tensors, and arguments represented by vectors (Grefenstette et al., 2013). The MV-RNN model of Socher et al. (2012) broadened the Baroni and Zamparelli (2010) approach; all words, regardless of part-of-speech, were modelled with both a vector and a matrix. This approach also shared features with Coecke, Sadrzadeh, and Clark (2011) in using syntax to guide the order of phrasal composition. This model, however, was made much more flexible by requiring and using task-specific labelled training data to create taskspecific distributional data structures, and by allowing non-linear relationships between component data structures and the composed result. The payoff for this increased flexibility has come with impressive performance in sentiment analysis (Socher et al., 2012; Socher et al., 2013). However, whilst these approaches all pay attention to syntax, they all require large amounts of training data. For example, running regression models to accurately predict the matrix or tensor for each individual adjective or verb requires a large number of exemplar compositions containing that adjective or verb. Socher\u2019s MV-RNN model further requires task-specific labelled training data. Our approach, on the other hand, is purely count-based and directly aggregates information about each word from the corpus. Other approaches have been proposed. Clarke (2007, 2012) suggested a context-theoretic semantic framework, incorporating a generative model that assigned probabilities to arbitrary word sequences. This approach shared with Coecke, Sadrzadeh, and Clark (2011) an ambition to provide a bridge between compositional distributional semantics and formal logic-based semantics. In a similar vein, Garrette, Erk, and Mooney (2011) combined word-level distributional vector representations with logic-based representation using a probabilistic reasoning framework. Lewis and Steedman (2013) also attempted to combine distributional and logical semantics by learning a lexicon for CCG (Combinatory Categorial Grammar (Steedman, 2000)) which first maps natural language to a deterministic logical form and then performs a distributional clustering over logical predicates based on arguments. The CCG formalism was also used by Hermann and Blunsom (2013) as a means for incorporating syntax-sensitivity into vector space representations of sentential semantics based on recursive auto-encoders (Socher et al. (2011a, 2011b)). They achieved this by representing each combinatory step in a CCG parse tree with an auto-encoder function, where it is possible to parameterise both the weight matrix and bias on the combinatory rule and the CCG category. Turney (2012) offered a model that incorporated assessments of word-level semantic relations in order to determine phrasal-level similarity.", "startOffset": 199, "endOffset": 2821}, {"referenceID": 32, "context": "for synonym detection and concept categorisation, it has also been shown (Levy and Goldberg, 2014) that the skip-gram model with negative sampling as introduced in Mikolov et al. (2013a) is equivalent to implicit factorisation of the PPMI matrix.", "startOffset": 164, "endOffset": 187}, {"referenceID": 32, "context": "for synonym detection and concept categorisation, it has also been shown (Levy and Goldberg, 2014) that the skip-gram model with negative sampling as introduced in Mikolov et al. (2013a) is equivalent to implicit factorisation of the PPMI matrix. Levy, Goldberg, and Dagan (2015) also demonstrated how traditional count-based methods could be improved by transferring hyperparameters used by the prediction-based methods (such as context distribution smoothing and negative sampling).", "startOffset": 164, "endOffset": 280}, {"referenceID": 32, "context": "For example, in order to identify good candidate paraphrases for questions in a questionanswering task, Berant and Liang (2014) employ a paraphrase model based on adding word embeddings constructed using the CBOW model of Mikolov et al. (2013). Whilst the authors achieve state-of-the-art using a mixture of methods, a paraphrase model based on the addition of vectors of untyped co-occurrences alone cannot distinguish meanings where syntax is important.", "startOffset": 222, "endOffset": 244}], "year": 2016, "abstractText": "We present a new framework for compositional distributional semantics in which the distributional contexts of lexemes are expressed in terms of anchored packed dependency trees. We show that these structures have the potential to capture the full sentential contexts of a lexeme and provide a uniform basis for the composition of distributional knowledge in a way that captures both mutual disambiguation and gen-", "creator": "LaTeX with hyperref package"}}}