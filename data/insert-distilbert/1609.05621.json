{"id": "1609.05621", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Sep-2016", "title": "Extending Unification in $\\mathcal{EL}$ to Disunification: The Case of Dismatching and Local Disunification", "abstract": "unification in description logics has been introduced as a means to successfully detect redundancies in ontologies. we try to extend the known decidability results sought for unification in the basic description logic $ \\ mathcal { el } $ to produce disunification since negative constraints constraints can be used to avoid unwanted compound unifiers. while decidability of the solvability of general $ \\ mathcal { el } $ - disunification problems remains an open problem, we obtain np - completeness results for two interesting special cases : np dismatching problems, where one side of each negative constraint must be ground, and local solvability of disunification problems, where individually we consider only solutions that are completely constructed from terms occurring in the input problem. more precisely, we first show that dismatching can be reduced to local differential disunification, and then provide two complementary np - algorithms for finding local solutions of disunification problems.", "histories": [["v1", "Mon, 19 Sep 2016 07:45:50 GMT  (38kb)", "http://arxiv.org/abs/1609.05621v1", "32 pages, extended version of a paper from RTA'15"], ["v2", "Wed, 5 Oct 2016 21:44:19 GMT  (40kb)", "http://arxiv.org/abs/1609.05621v2", "32 pages, extended version of a paper from RTA'15"]], "COMMENTS": "32 pages, extended version of a paper from RTA'15", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["franz baader", "stefan borgwardt", "barbara morawska"], "accepted": false, "id": "1609.05621"}, "pdf": {"name": "1609.05621.pdf", "metadata": {"source": "CRF", "title": "EXTENDING UNIFICATION IN EL TO DISUNIFICATION: THE CASE OF DISMATCHING AND LOCAL DISUNIFICATION", "authors": [], "emails": ["Franz.Baader@tu-dresden.de", "Stefan.Borgwardt@tu-dresden.de", "Barbara.Morawska@tu-dresden.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 9.\n05 62\n1v 1\n[ cs\n.L O\n] 1\n9 Se"}, {"heading": "1. Introduction", "text": "Description logics (DLs) [10] are a family of logic-based knowledge representation formalisms, which can be used to represent the conceptual knowledge of an application domain in a structured and formally well-understood way. They are employed in various application areas, but their most notable success so far is the adoption of the DL-based language OWL [26] as standard ontology language for the semantic web. DLs allow their users to define the important notions (classes, relations) of the domain using concepts and roles; to state constraints on the way these notions\n1998 ACM Subject Classification: F.4.1, I.2.3, I.2.4. Key words and phrases: Knowledge Representation, Description Logics, Unification, Disunifica-\ntion, Computational Complexity. Supported by DFG under grant BA 1122/14-2.\nLOGICAL METHODS IN COMPUTER SCIENCE DOI:10.2168/LMCS-???\nc\u00a9 F. Baader, S. Borgwardt, and B. Morawska Creative Commons\n1\ncan be interpreted using terminological axioms; and to deduce consequences such as subsumption (subclass) relationships from the definitions and constraints. The expressivity of a particular DL is determined by the constructors available for building concepts.\nThe DL EL, which offers the concept constructors conjunction (\u2293), existential restriction (\u2203r.C), and the top concept (\u22a4), has drawn considerable attention in the last decade since, on the one hand, important inference problems such as the subsumption problem are polynomial in EL, even with respect to expressive terminological axioms [18]. On the other hand, though quite inexpressive, EL is used to define biomedical ontologies, such as the large medical ontology SNOMEDCT.1 For these reasons, the most recent OWL version, OWL2, contains the profile OWL2EL,2 which is based on a maximally tractable extension of EL [11]. Unification in Description Logics was introduced in [4] as a novel inference service that can be used to detect redundancies in ontologies. It is shown there that unification in the DL FL0, which differs from EL in that existential restriction is replaced by value restriction (\u2200r.C), is ExpTime-complete. The applicability of this result was not only hampered by this high complexity, but also by the fact that FL0 is not used in practice to formulate ontologies. In contrast, as mentioned above, EL is employed to build large biomedical ontologies for which detecting redundancies is a useful inference service. For example, assume that one developer of a medical ontology defines the concept of a patient with severe head injury as\nPatient \u2293 \u2203finding.(Head_injury \u2293 \u2203severity.Severe), (1.1)\nwhereas another one represents it as\nPatient \u2293 \u2203finding.(Severe_finding \u2293 Injury \u2293 \u2203finding_site.Head). (1.2)\nFormally, these two concepts are not equivalent, but they are nevertheless meant to represent the same concept. They can obviously be made equivalent by treating the concept names Head_injury and Severe_finding as variables, and substituting the first one by Injury \u2293 \u2203finding_site.Head and the second one by \u2203severity.Severe. In this case, we say that the concepts are unifiable, and call the substitution that makes them equivalent a unifier. In [1], we were able to show that unification in EL is of considerably lower complexity than unification in FL0: the decision problem for EL is NP-complete. The main idea underlying the proof of this result is to show that any solvable EL-unification problem has a local unifier, i.e., a unifier built from a polynomial number of so-called atoms determined by the unification problem. However, the brute-force \u201cguess and then test\u201d NP-algorithm obtained from this result, which guesses a local substitution and then checks (in polynomial time) whether it is a unifier, is not useful in practice. We thus developed a goal-oriented unification algorithm for EL, which is more efficient since nondeterministic decisions are only made if they are triggered by \u201cunsolved parts\u201d of the unification problem. Another option\n1http://www.ihtsdo.org/snomed-ct/ 2http://www.w3.org/TR/owl2-profiles/\nfor obtaining a more efficient unification algorithm is a translation to satisfiability in propositional logic (SAT): in [2] it is shown how a given EL-unification problem \u0393 can be translated in polynomial time into a propositional formula whose satisfying valuations correspond to the local unifiers of \u0393. Intuitively, a unifier of two EL concepts proposes definitions for the concept names that are used as variables: in our example, we know that, if we define Head_injury as Injury \u2293 \u2203finding_site.Head and Severe_finding as \u2203severity.Severe, then the two concepts (1.1) and (1.2) are equivalent w.r.t. these definitions. Of course, this example was constructed such that the unifier (which is actually local) provides sensible definitions for the concept names used as variables. In general, the existence of a unifier only says that there is a structural similarity between the two concepts. The developer that uses unification as a tool for finding redundancies in an ontology or between two different ontologies needs to inspect the unifier(s) to see whether the definitions it suggests really make sense. For example, the substitution that replaces Head_injury by Patient\u2293 Injury\u2293\u2203finding_site.Head and Severe_finding by Patient\u2293\u2203severity.Severe is also a local unifier, which however does not make sense since findings (i.e. Head_Injury or Severe_finding) cannot be patients. Unfortunately, even small unification problems like the one in our example can have too many local unifiers for manual inspection. In [13] we propose to restrict the attention to so-called minimal unifiers, which form a subset of all local unifiers. In our example, the nonsensical unifier is indeed not minimal. In general, however, the restriction to minimal unifiers may preclude interesting local unifiers. In addition, as shown in [13], computing minimal unifiers is actually harder than computing local unifiers (unless the polynomial hierarchy collapses). In the present paper, we propose disunification as a more direct approach for avoiding local unifiers that do not make sense. In addition to positive constraints (requiring equivalence or subsumption between concepts), a disunification problem may also contain negative constraints (preventing equivalence or subsumption between concepts). In our example, the nonsensical unifier can be avoided by adding the dissubsumption constraint\nHead_injury 6\u2291? Patient (1.3)\nto the equivalence constraint (1.1) \u2261? (1.2). We add a superscript \u00b7? to the relation symbols (like 6\u2291 and \u2261) to make clear that these are not axioms that are stated to hold, but rather constraints that need to be solved by finding an appropriate substitution.\nUnification and disunification in DLs is actually a special case of unification and disunification modulo equational theories (see [4] and [1] for the equational theories respectively corresponding to FL0 and EL). Disunification modulo equational theories has, e.g., been investigated in [19, 20]. It is well-known in unification theory that for effectively finitary equational theories, i.e., theories for which finite complete sets of unifiers can effectively be computed, disunification can be reduced to unification: to decide whether a disunification problem has a solution, one computes a finite complete set of unifiers of the equations and then checks whether any of the unifiers in this set also solves the disequations. Unfortunately, for FL0 and EL, this approach is not feasible since the corresponding equational theories have unification type zero [1, 4],\nand thus finite complete sets of unifiers need not even exist. Nevertheless, it was shown in [6] that the approach used in [4] to decide unification (reduction to language equations, which are then solved using tree automata) can be adapted such that it can also deal with disunification. This yields the result that disunification in FL0 has the same complexity (ExpTime-complete) as unification.\nFor EL, going from unification to disunification appears to be more problematic. In fact, the main reason for unification to be decidable and in NP is locality: if the problem has a unifier then it has a local unifier. We will show that disunification in EL is not local in this sense by providing an example of a disunification problem that has a solution, but no local solution. Decidability and complexity of disunification in EL remains an open problem, but we provide partial solutions that are of interest in practice. On the one hand, we investigate dismatching problems, i.e., disunification problems where the negative constraints are dissubsumptions C 6\u2291? D for which either C or D is ground (i.e., does not contain a variable). Note that the dissubsumption (1.3) from above actually satisfies this restriction since Patient is not a variable. We prove that (general) solvability of dismatching problems can be reduced to local disunification, i.e., the question whether a given EL-disunification problem has a local solution, which shows that dismatching in EL is NP-complete. On the other hand, we develop two specialized algorithms to solve local disunification problems that extend the ones for unification [1, 2]: a goal-oriented algorithm that reduces the amount of nondeterministic guesses necessary to find a local solution, as well as a translation to SAT. The reason we present two kinds of algorithms is that, in the case of unification, they have proved to complement each other well in first evaluations [12]: the goaloriented algorithm needs less memory and finds minimal solutions faster, while the SAT reduction generates larger data structures, but outperforms the goal-oriented algorithm on unsolvable problems. The remainder of this article is organized as follows. Section 2 introduces syntax and semantics of EL and recalls some basic results about (dis)subsumption in EL. In Section 3, we introduce disunification and the special case of unification, and recall known results about unification in EL and local solutions. Section 4 contains our reduction from dismatching to local disunification, while Sections 5 and 6 describe the two algorithms for local disunification. We discuss related work in Section 7, and summarize our results as well as sketch directions for future research in Section 8. This is an extended version of the conference paper [15]. In this paper, we give full proofs of all our results, and add some results on how to actually compute local solutions using the decision procedures presented in Sections 5 and 6."}, {"heading": "2. Subsumption and dissubsumption in EL", "text": "The syntax of EL is defined based on two sets NC and NR of concept names and role names, respectively. Concept terms are built from concept names using the constructors conjunction (C \u2293 D), existential restriction (\u2203r.C for r \u2208 NR), and top (\u22a4). An interpretation I = (\u2206I , \u00b7I) consists of a non-empty domain \u2206I and an interpretation function that maps concept names to subsets of \u2206I and role names to\nbinary relations over \u2206I . This function is extended to concept terms as shown in the semantics column of Table 1.\nA concept term C is subsumed by a concept term D (written C \u2291 D) if for every interpretation I it holds that CI \u2286 DI . We write a dissubsumption C 6\u2291 D to abbreviate the fact that C \u2291 D does not hold. The two concept terms C and D are equivalent (written C \u2261 D) if C \u2291 D and D \u2291 C, i.e. they are always interpreted as the same set. The binary subsumption relation \u2291 on concept terms is reflexive and transitive, and \u2261 is an equivalence relation, which justifies the notation. Note that we use \u201c=\u201d to denote syntactic equality between concept terms, whereas \u201c\u2261\u201d denotes semantic equivalence. Since conjunction is interpreted as set intersection, we can treat \u2293 as a commutative and associative operator, and thus dispense with parentheses in nested conjunctions. An atom is a concept name or an existential restriction. Hence, every concept term C is a conjunction of atoms or \u22a4. We call the atoms in this conjunction the top-level atoms of C. Obviously, C is equivalent to the conjunction of its top-level atoms, where the empty conjunction corresponds to \u22a4. An atom is flat if it is a concept name or an existential restriction of the form \u2203r.A with A \u2208 NC. Subsumption in EL is decidable in polynomial time [9] and can be checked by recursively comparing the top-level atoms of the two concept terms.\nLemma 1 ([1]). For two atoms C,D, we have C \u2291 D iff C = D is a concept name or C = \u2203r.C \u2032, D = \u2203r.D\u2032, and C \u2032 \u2291 D\u2032. If C,D are concept terms, then C \u2291 D iff for every top-level atom D\u2032 of D there is a top-level atom C \u2032 of C such that C \u2032 \u2291 D\u2032.\nWe obtain the following contrapositive formulation characterizing dissubsumption.\nLemma 2. For two concept terms C,D, we have C 6\u2291 D iff there is a top-level atom D\u2032 of D such that for all top-level atoms C \u2032 of C it holds that C \u2032 6\u2291 D\u2032.\nIn particular, C 6\u2291 D is characterized by the existence of a top-level atom D\u2032 of D for which C 6\u2291 D\u2032 holds. By further analyzing the structure of atoms, we obtain the following.\nLemma 3. Let C,D be two atoms. Then we have C 6\u2291 D iff either\n(1) C or D is a concept name and C 6= D; or\n(2) D = \u2203r.D\u2032, C = \u2203s.C \u2032, and r 6= s; or\n(3) D = \u2203r.D\u2032, C = \u2203r.C \u2032, and C \u2032 6\u2291 D\u2032."}, {"heading": "3. Disunification", "text": "As described in the introduction, we now partition the set NC into a set of (concept) variables (Nv) and a set of (concept) constants (Nc). A concept term is ground if it does not contain any variables. We define a quite general notion of disunification problems that is similar to the equational formulae used in [20].\nDefinition 4. A disunification problem \u0393 is a formula built from subsumptions of the form C \u2291? D, where C and D are concept terms, using the logical connectives \u2227, \u2228, and \u00ac. We use equations C \u2261? D to abbreviate (C \u2291? D) \u2227 (D \u2291? C), dissubsumptions C 6\u2291? D for \u00ac(C \u2291? D), and disequations C 6\u2261? D instead of (C 6\u2291? D)\u2228(D 6\u2291? C). A basic disunification problem is a conjunction of subsumptions and dissubsumptions. A dismatching problem is a basic disunification problem in which all dissubsumptions C 6\u2291? D are such that either C or D is ground. Finally, a unification problem is a conjunction of subsumptions.\nTo define the semantics of disunification problems, we now fix a finite signature \u03a3 \u2286 NC \u222aNR and assume that all disunification problems contain only concept terms constructed over the symbols in \u03a3. A substitution \u03c3 maps every variable in \u03a3 to a ground concept term constructed over the symbols of \u03a3. This mapping can be extended to all concept terms (over \u03a3) in the usual way. A substitution \u03c3 solves a subsumption C \u2291? D if \u03c3(C) \u2291 \u03c3(D); it solves \u03931 \u2227 \u03932 if it solves both \u03931 and \u03932; it solves \u03931 \u2228 \u03932 if it solves \u03931 or \u03932; and it solves \u00ac\u0393 if it does not solve \u0393. A substitution that solves a given disunification problem is called a solution of this problem. A disunification problem is solvable if it has a solution. By disunification we refer to the decision problem of checking whether a given disunification problem is solvable, and will similarly talk of dismatching and unification. In contrast to unification, in disunification it does make a difference whether or not solutions may contain variables from Nv\u2229\u03a3 or additional symbols from (NC\u222aNR)\\\u03a3 [19]. In the context of the application sketched in the introduction, restricting solutions to ground terms over the signature of the ontology to be checked for redundancy is appropriate: since a solution \u03c3 is supposed to provide definitions for the variables in \u03a3, it should not use the variables themselves to define them; moreover, definitions that contain newly generated symbols would be meaningless to the user.\n3.1. Reduction to basic disunification problems. We will consider only basic disunification problems in the following. The reason is that there is a straightforward NP-reduction from solvability of arbitrary disunification problems to solvability of basic disunification problems. In this reduction, we view all subsumptions occurring in the disunification problem as propositional variables and guess a satisfying valuation of the resulting propositional formula in nondeterministic polynomial time. It then\nsuffices to check solvability of the basic disunification problem obtained as the conjunction of all subsumptions evaluated to true and the negations of all subsumptions evaluated to false. This reduction consists of polynomially many guesses followed by a polynomial satisfaction check. Hence, doing this before the NP-algorithms for the problems considered in the following sections leaves the overall complexity in NP. In fact, in contrast to the use of an NP-oracle within an NP-algorithm, all the tests that are applied are deterministic polynomial time. Overall, there are polynomially many guesses (in the reduction and the NP-algorithm) with deterministic polynomial tests at the end.\nHence, from now on we restrict our considerations to basic disunification problems. For simplicity, we will call them disunification problems and consider them to be sets containing subsumptions and dissubsumptions.\n3.2. Reduction to flat disunification problems. We further simplify our analysis by considering flat disunification problems, which means that they may only contain flat dissubsumptions of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291\n? D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Dm for flat atoms C1, . . . , Cn, D1, . . . , Dm with m,n \u2265 0,\n3 and flat subsumptions of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291\n? D1 for flat atoms C1, . . . , Cn, D1 with n \u2265 0. This restriction is without loss of generality: to flatten concept terms, one can simply introduce new variables and equations to abbreviate subterms [1]. Moreover, a subsumption of the form C \u2291? D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Dm is equivalent to the conjunction of C \u2291 ? D1, . . . , C \u2291 ? Dm. Any solution of a disunification problem \u0393 can be extended to a solution of the resulting flat disunification problem \u0393\u2032, and conversely every solution of \u0393\u2032 also solves \u0393. This flattening procedure also works for unification problems. However, dismatching problems cannot without loss of generality be restricted to being flat since the introduction of new variables to abbreviate subterms may destroy the property that one side of each dissubsumption is ground (see also Section 4).\n3.3. Local disunification. For solving flat unification problems, it has been shown that it suffices to consider so-called local solutions [1], which are restricted to use only the atoms occurring in the input problem. We define this notion here for disunification.\nLet \u0393 be a flat disunification problem. We denote by At the set of all (flat) atoms occurring as subterms in \u0393, by Var the set of variables occurring in \u0393, and by Atnv := At \\ Var the set of non-variable atoms of \u0393. Let S : Var \u2192 2\nAtnv be an assignment (for \u0393), i.e. a function that assigns to each variable X \u2208 Var a set SX \u2286 Atnv of non-variable atoms. The relation >S on Var is defined as the transitive closure of {(X, Y ) \u2208 Var \u00d7 Var | Y occurs in an atom of SX}. If this defines a strict partial order, i.e. >S is irreflexive, then S is called acyclic. In this case, we can define the substitution \u03c3S inductively along >S as follows: if X is minimal w.r.t. >S, then\n3Recall that the empty conjunction is \u22a4.\nall elements of SX are ground and we simply take\n\u03c3S(X) := l\nD\u2208SX\nD;\notherwise, we assume that \u03c3S(Y ) is defined for all Y \u2208 Var with X >S Y , and set\n\u03c3S(X) := l\nD\u2208SX\n\u03c3S(D).\nIt is easy to see that the concept terms \u03c3S(D) are ground and constructed from the symbols of \u03a3, and hence \u03c3S is a valid candidate for a solution of \u0393 according to Definition 4.\nDefinition 5. Let \u0393 be a flat disunification problem. A substitution \u03c3 is called local (w.r.t. \u0393) if there exists an acyclic assignment S for \u0393 such that \u03c3 = \u03c3S. The disunification problem \u0393 is locally solvable if it has a local solution, i.e. a solution that is a local substitution. Local disunification is the problem of checking flat disunification problems for local solvability.\nNote that assignments and local solutions are defined only for flat disunification problems, because both are based on the assumption that all subterms occurring in the input problem are flat. Although solvability of disunification problems is equivalent to solvability of flat disunification problems, it is not straightforward to extend the notion of local solutions to general disunification problems \u0393. In particular, there may be several flat disunification problems that are equivalent to \u0393 w.r.t. solvability, but they induce different sets of flat atoms, and hence different kinds of local substitutions.\nObviously, local disunification is decidable in NP: We can guess an assignment S, and check it for acyclicity and whether the induced substitution solves the disunification problem in polynomial time. The corresponding complexity lower bound follows from NP-hardness of (local) solvability of unification problems in EL [1].\nFact 3.1. Local disunification in EL is NP-complete.\nIt has been shown that unification in EL is local in the sense that the equivalent flattened problem has a local solution iff the original problem is solvable, and hence (general) solvability of unification problems in EL can be decided in NP [1]. The next example shows that disunification in EL is not local in this sense.\nExample 6. Consider the flat disunification problem\n\u0393 := {X \u2291? B, A \u2293B \u2293 C \u2291? X, \u2203r.X \u2291? Y, \u22a4 6\u2291? Y, Y 6\u2291? \u2203r.B}\nwith concept variables X, Y and concept constants A,B,C. The substitution \u03c3 with \u03c3(X) := A \u2293 B \u2293 C and \u03c3(Y ) := \u2203r.(A \u2293 C) is a solution of \u0393. For \u03c3 to be local, the atom \u2203r.(A \u2293 C) would have to be of the form \u03c3(D) for a non-variable atom D occurring in \u0393. But the only candidates for D are \u2203r.X and \u2203r.B, none of which satisfy \u2203r.(A \u2293 C) = \u03c3(D). We show that \u0393 cannot have another solution that is local. Assume to the contrary that \u0393 has a local solution \u03b3. We know that \u03b3(Y ) cannot be \u22a4 since \u03b3 must solve\n\u22a4 6\u2291? Y . Furthermore, none of the constants A,B,C can be a top-level atom of \u03b3(Y ) since this would contradict \u2203r.X \u2291? Y (see Lemma 1). That leaves only the nonvariable atoms \u2203r.\u03b3(X) and \u2203r.B, which are, however, ruled out by Y 6\u2291? \u2203r.B since both \u03b3(X) and B are subsumed by B (see Lemma 3).\nThe decidability and complexity of general disunification in EL is still open. In the following, we first consider the special case of solving dismatching problems, for which we show a similar result as for unification: every dismatching problem can be polynomially reduced to a flat problem that has a local solution iff the original problem is solvable. The main difference is that this reduction is nondeterministic. In this way, we reduce dismatching to local disunification. We then provide two different NPalgorithms for the latter problem by extending the rule-based unification algorithm from [1] and adapting the SAT encoding of unification problems from [2]. These algorithms are more efficient than the brute-force \u201cguess and then test\u201d procedure on which our argument for Fact 3.1 was based."}, {"heading": "4. Reducing dismatching to local disunification", "text": "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29]. In particular, the matching problems for EL investigated in [3] are similar to our dismatching problems in that there subsumptions are restricted to ones where one side is ground. Another motivation comes from our experience that dismatching problems already suffice to formulate most of the negative constraints one may want to put on unification problems, as described in the introduction.\nAs mentioned in Section 3, we cannot restrict our attention to flat dismatching problems without loss of generality. Instead, the nondeterministic algorithm we present in the following reduces any dismatching problem \u0393 to a flat disunification problem \u0393\u2032 with the property that local solvability of \u0393\u2032 is equivalent to the solvability of \u0393. Since the algorithm takes at most polynomial time in the size of \u0393, this shows, together with Fact 3.1, that dismatching in EL is NP-complete. For simplicity, we assume that the subsumptions and the non-ground sides of the dissubsumptions have already been flattened using the approach mentioned in the previous section. This retains the property that all dissubsumptions have one ground side and does not affect the solvability of the problem.\nOur procedure exhaustively applies a set of rules to the (dis)subsumptions in a dismatching problem (see Figures 1 and 2). Each rule consists of a condition under which it is applicable to a given subsumption or dissubsumption s, and an action that is executed on s. Actions usually include the removal of s from the input problem, and often new subsumptions or dissubsumptions are introduced to replace it. Actions can fail, which indicates that the current dismatching problem has no solution. In all rules, C1, . . . , Cn and D1, . . . , Dm denote atoms. The rule Left Decomposition includes the special case where the left-hand side of s is \u22a4, in which case s is simply removed from the problem. We use the rule Flattening Left-Ground Subsumptions to eliminate"}, {"heading": "Right Decomposition:", "text": ""}, {"heading": "Left Decomposition:", "text": ""}, {"heading": "Atomic Decomposition:", "text": "the non-flat, left-ground subsumptions that may be introduced by Flattening RightGround Dissubsumptions.\nNote that at most one rule is applicable to any given (dis)subsumption. The choice which (dis)subsumption to consider next is don\u2019t care nondeterministic, but the choices in the rules Right Decomposition and Solving Left-Ground Dissubsumptions are don\u2019t know nondeterministic.\nAlgorithm 7. Let \u03930 be a dismatching problem. We initialize \u0393 := \u03930. While any of the rules of Figures 1 and 2 is applicable to any element of \u0393, choose one such element and apply the corresponding rule. If any rule application fails, return \u201cfailure\u201d.\nNote that each rule application takes only polynomial time in the size of the chosen (dis)subsumption. In particular, subsumptions between ground atoms can be checked in polynomial time [9].\nLemma 8. Every run of Algorithm 7 terminates in time polynomial in the size of \u03930.\nProof. Let \u03930, . . . , \u0393k be the sequence of disunification problems created during a run of the algorithm, i.e.\n\u2022 \u03930 is the input dismatching problem;\n\u2022 for all j, 0 \u2264 j \u2264 k \u2212 1, \u0393j+1 is the result of successfully applying one rule to a (dis)subsumption in \u0393j ; and\n\u2022 either no rule is applicable to any element of \u0393k, or a rule application to a (dis)subsumption in \u0393k failed."}, {"heading": "Flattening Right-Ground Dissubsumptions:", "text": ""}, {"heading": "Flattening Left-Ground Subsumptions:", "text": ""}, {"heading": "Solving Left-Ground Dissubsumptions:", "text": "We prove that k is polynomial in the size of \u03930 by measuring the size of subsumptions and dissubsumptions via the function c that is defined as follows:\nc(C 6\u2291? D) := c(C \u2291? D) := |C| \u00b7 |D|,\nwhere |C| is the size of the concept term C; the latter is measured in the number of symbols it takes to write down C, where we count each concept name as one symbol, and \u201c\u2203r.\u201d is also one symbol. Note that we always have |C| \u2265 1 since C must contain at least one concept name or \u22a4, and thus also c(s) \u2265 1 for any (dis)subsumption s. We now define the size c(\u0393) of a disunification problem \u0393 as the sum of the sizes c(s) for all s \u2208 \u0393 to which a rule is applicable. Since c(\u03930) is obviously polynomial in the size of \u03930, it now suffices to show that c(\u0393j) > c(\u0393j+1) holds for all j, 0 \u2264 j \u2264 k\u2212 1. To show this, we consider the rule that was applied to s \u2208 \u0393j in order to obtain \u0393j+1:\n\u2022 Right Decomposition: Then s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? D1 \u2293 . . .Dm and we must have\nm > 1 since we assumed that the rule application was successful. Thus, we get |C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn| \u00b7 |D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Dm| > |C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn| \u00b7 |Di| for every choice of i \u2208 {1, . . . , m}, and thus c(\u0393j) > c(\u0393j+1).\n\u2022 Left Decomposition: Then s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? D and, if n = 0, then we have\nc(\u0393j) = c(\u0393j+1) + c(s) \u2265 c(\u0393j+1) + 1 > c(\u0393j+1). Otherwise, n > 1, and thus\n|C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn| \u00b7 |D| = (|C1|+ \u00b7 \u00b7 \u00b7+ |Cn|+ (n\u2212 1)) \u00b7 |D|\n> |C1| \u00b7 |D|+ \u00b7 \u00b7 \u00b7+ |Cn| \u00b7 |D|.\n\u2022 Atomic Decomposition: It suffices to consider Case e) since Case a) is impossible and the other cases are trivial. Then s = \u2203r.C \u2032 6\u2291? \u2203r.D\u2032, and we get |\u2203r.C \u2032| \u00b7 |\u2203r.D\u2032| = (|C \u2032|+ 1) \u00b7 (|D\u2032|+ 1) > |C \u2032| \u00b7 |D\u2032|.\n\u2022 Flattening Right-Ground Dissubsumptions: Then s = X 6\u2291? \u2203r.D is replaced by X 6\u2291? \u2203r.XD and D \u2291\n? XD. To the dissubsumption, no further rule is applicable, and hence it does not count towards c(\u0393j). Regarding the subsumption, we have |X| \u00b7 |\u2203r.D| = |D|+ 1 > |D| = |D| \u00b7 |XD|.\n\u2022 Flattening Left-Ground Subsumptions: Then the subsumption s is of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2293 \u2203r1.D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rm.Dm \u2291\n? X and only to the subsumptions D1 \u2291 ? XD1, . . . , Dm \u2291 ? XDm this rule may be applicable again. But we have\n|C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2293 \u2203r1.D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rm.Dm| \u00b7 |X|\n= |C1|+ \u00b7 \u00b7 \u00b7+ |Cn|+ |\u2203r1.D1|+ \u00b7 \u00b7 \u00b7+ |\u2203rm.Dm|+ (n+m\u2212 1)\n\u2265 |\u2203r1.D1|+ \u00b7 \u00b7 \u00b7+ |\u2203rm.Dm|\n> |D1|+ \u00b7 \u00b7 \u00b7+ |Dm|\n= |D1| \u00b7 |XD1 |+ \u00b7 \u00b7 \u00b7+ |Dm| \u00b7 |XDm|.\n\u2022 Solving Left-Ground Dissubsumptions: Then s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? X and to a\ngenerated subsumption of the form X \u2291? A or X \u2291? \u2203r.Z no further rule is applicable. If n = 0, then no further dissubsumptions are generated, and thus c(\u0393j) > c(\u0393j+1). Otherwise, we denote by |si| the size of the dissubsumption resulting from applying Atomic Decomposition to Ci 6\u2291\n? \u2203r.Z, 1 \u2264 i \u2264 n, where we consider this number to be 0 if the dissubsumption was simply discarded (c.f. Cases b)\u2013d) of Atomic Decomposition).\nIf |si| = 0, we obtain |Ci| \u2265 1 > 0 = |si|. But also in Case e), we have Ci = \u2203r.C \u2032 i, and thus |Ci| = |C \u2032 i|+ 1 = |C \u2032 i| \u00b7 |Z|+ 1 > |si|. Hence, we get\n|C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn| \u00b7 |X| = |C1|+ \u00b7 \u00b7 \u00b7+ |Cn|+ (n\u2212 1)\n\u2265 |C1|+ \u00b7 \u00b7 \u00b7+ |Cn|\n> |s1|+ \u00b7 \u00b7 \u00b7+ |sn|,\nand thus again c(\u0393j) > c(\u0393j+1).\nNote that the rule Solving Left-Ground Dissubsumptions is not limited to nonflat dissubsumptions, and thus the algorithm completely eliminates all left-ground dissubsumptions from \u0393. It is also easy to see that, if the algorithm is successful, then the resulting disunification problem \u0393 is flat. We now prove that this nondeterministic procedure is correct in the following sense.\nLemma 9. The dismatching problem \u03930 is solvable iff there is a successful run of Algorithm 7 such that the resulting flat disunification problem \u0393 has a local solution.\nProof. For soundness (i.e. the \u201cif\u201d direction), let \u03c3 be the local solution of \u0393 and consider the run of Algorithm 7 that produced \u0393. It is easy to show by induction on the reverse order in which the rules have been applied that \u03c3 solves all subsumptions that have been considered. Indeed, this follows from simple applications of Lemmata 1\u20133 and the properties of subsumption. This implies that \u03c3 is also a solution of \u03930.\nShowing completeness (i.e. the \u201conly if\u201d direction) is a little more involved. Let \u03b3 be a solution of \u03930. We guide the rule applications of Algorithm 7 and extend \u03b3 to the newly introduced variables in such a way to maintain the invariant that \u201c\u03b3 solves all (dis)subsumptions of \u0393\u201d. This obviously holds after the initialization \u0393 := \u03930. Afterwards, we will use \u03b3 to define a local solution of \u0393. Consider a (dis)subsumption s \u2208 \u0393 (which is solved by \u03b3) to which one of the rules of Figures 1 and 2 is applicable. We make a case distinction on which rule is to be applied:\n\u2022 Right Decomposition: Then s is of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Dm for\nm 6= 1. Since \u03b3(C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn) 6\u2291 \u03b3(D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Dm), by applying Lemma 2 twice, we can find an index i \u2208 {1, . . . , m} such that \u03b3(C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn) 6\u2291 \u03b3(Di). Thus, we can choose this index in the rule application in order to satisfy the invariant.\n\u2022 Left Decomposition: Then s is of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? D, where n 6= 1 and\nD is a non-variable atom. This means that \u03b3(D) is also an atom, and thus by Lemma 2 we know that \u03b3(Ci) 6\u2291 \u03b3(D) holds for all i \u2208 {1, . . . , n}, as required. \u2022 Atomic Decomposition: Then s is of the form C 6\u2291? D for two non-variable atoms C and D. Since \u03b3(C) 6\u2291 \u03b3(D), Case a) cannot apply. If one of the Cases b)\u2013d) applies, then s is simply removed from \u0393 and there is nothing to show. Otherwise, we have D = \u2203r.D\u2032 and C = \u2203r.C \u2032, and the new dissubsumption C \u2032 6\u2291? D\u2032\nis added to \u0393. Moreover, we have \u03b3(C) = \u2203r.\u03b3(C \u2032) and \u03b3(D) = \u2203r.\u03b3(D\u2032), and thus by Lemma 3 we know that \u03b3(C \u2032) 6\u2291 \u03b3(D\u2032).\n\u2022 Flattening Right-Ground Dissubsumptions: Then s is of the form X 6\u2291? \u2203r.D. By defining \u03b3(XD) := D, \u03b3 solves X 6\u2291 ? \u2203r.XD and D \u2291 ? XD.\n\u2022 Flattening Left-Ground Subsumptions: Then the subsumption s is of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2293 \u2203r1.D1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rm.Dm \u2291\n? X, where all D1, . . . , Dm are ground. If we extend \u03b3 by defining \u03b3(XDi) := Di for all i \u2208 {1, . . . , m}, then this obviously satisfies the new subsumptions D1 \u2291 ? XD1 , . . . , Dm \u2291 ? XDm , and C1\u2293 \u00b7 \u00b7 \u00b7\u2293Cn \u2293\u2203r1.XD1 \u2293 \u00b7 \u00b7 \u00b7\u2293\u2203rm.XDm \u2291 ? X by our assumption that \u03b3 solves s.\n\u2022 Solving Left-Ground Dissubsumptions: Then the dissubsumption s is of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291\n? X, where X is a variable and C1, . . . , Cn are ground atoms. By Lemma 2, there must be a ground top-level atom D of \u03b3(X) such that C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 D, i.e. C1 6\u2291 D, . . . , Cn 6\u2291 D. If D is a concept constant, we can choose this in the rule application since we know that \u03b3(X) \u2291 D. Otherwise, we have D = \u2203r.D\u2032. By extending \u03b3 to \u03b3(Z) := D\u2032, we ensure that\nX \u2291? \u2203r.Z, C1 6\u2291 ? \u2203r.Z, . . .Cn 6\u2291 ? \u2203r.Z are solved by \u03b3. The remaining claim follows as for Atomic Decomposition above.\nOnce no more rules can be applied, we obtain a flat disunification problem \u0393 of which the extended substitution \u03b3 is a (possibly non-local) solution. To obtain a local solution, we denote by At, Var, and Atnv the sets as defined in Section 3 and define the assignment S induced by \u03b3 as in [2]:\nSX := {D \u2208 Atnv | \u03b3(X) \u2291 \u03b3(D)},\nfor all (old and new) variables X \u2208 Var. It was shown in [2] that S is acyclic and the substitution \u03c3S solves all subsumptions in \u0393.\n4 Furthermore, it is easy to show that \u03b3(C) \u2291 \u03c3S(C) holds for all concept terms C.\nSince \u0393 contains no left-ground dissubsumptions anymore, it remains to show that \u03c3S solves all remaining right-ground dissubsumptions in \u0393 and all flat dissubsumptions created by an application of the rule Flattening Right-Ground Dissubsumptions. Consider first any flat right-ground dissubsumption X 6\u2291? D in \u0393. We have already shown that \u03b3(X) 6\u2291 D holds. Since \u03b3(X) \u2291 \u03c3S(X), by the transitivity of subsumption \u03c3S(X) \u2291 D cannot hold, and thus \u03c3S also solves the dissubsumption.\nConsider now a dissubsumption X 6\u2291? \u2203r.XD that was created by an application of the rule Flattening Right-Ground Dissubsumptions to X 6\u2291? \u2203r.D. By the same argument as above, from \u03b3(X) 6\u2291 \u2203r.D we can derive that \u03c3S(X) 6\u2291 \u2203r.D holds. We now show that \u03c3S(XD) \u2291 D holds, which implies that \u03c3S(\u2203r.XD) \u2291 \u2203r.D, and thus by the transitivity of subsumption it cannot be the case that \u03c3S(X) \u2291 \u03c3S(\u2203r.XD), which concludes the proof by showing that \u03c3S solves \u0393. We show that \u03c3S(XC) \u2291 C holds for all variables XC for which a subsumption C \u2291? XC was introduced by a Flattening rule. We prove this claim by induction on the role depth of C, which is the maximum nesting depth of existential restrictions occurring in it. Let C1, . . . , Cn be the top-level atoms of C. Then \u0393 contains a flat subsumption C \u20321\u2293\u00b7 \u00b7 \u00b7\u2293C \u2032 n \u2291 ? XC , where Ci = C \u2032 i if Ci is flat, and Ci = \u2203r.Di and C \u2032 i = \u2203r.XDi otherwise. Since the role depth of each such Di is strictly smaller than that of C, by induction we know that \u03c3S(XDi) \u2291 Di, and thus \u03c3S(C \u2032 1\u2293\u00b7 \u00b7 \u00b7\u2293C \u2032 n) \u2291 C1\u2293\u00b7 \u00b7 \u00b7\u2293Cn = C by Lemma 1. Furthermore, for all i \u2208 {1, . . . , n} we have \u03b3(XC) = C \u2291 Ci = \u03b3(C \u2032 i) and C \u2032i \u2208 Atnv. Thus, C \u2032 i \u2208 SXC by the definition of S. The definition of \u03c3S now yields that \u03c3S(XC) \u2291 \u03c3S(C \u2032 1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 C \u2032 n) \u2291 C (see Section 3.3).\nThe disunification problem of Example 6 is in fact a dismatching problem. Applying Algorithm 7 to this problem, we can use the rule Solving Left-Ground Dissubsumptions to replace \u22a4 6\u2291? Y with Y \u2291? \u2203r.Z. The presence of the new atom \u2203r.Z makes the solution \u03c3 introduced in Example 6 local.\nTogether with Fact 3.1 and the NP-hardness of unification in EL [1], this shows the following complexity result.\nTheorem 10. Dismatching in EL is NP-complete.\n4More precisely, it was shown that \u03b3 induces a satisfying valuation of a SAT problem, which in turn induces the solution \u03c3S above. For details, see [2] or Sections 6.1 and 6.2.\nAdditionally, one can see from the proof of Lemma 9 that any local solution of the constructed disunification problem \u0393 is also a solution of the original problem \u03930. Hence, if we are interested in actually computing solutions of \u03930 in order to show them to the user, we can collect the solutions of the flat problems \u0393 produced by the successful runs of Algorithm 7."}, {"heading": "5. A goal-oriented algorithm for local disunification", "text": "In this section, we present a sound and complete algorithm that provides a more goal-directed way to solve local disunification problems than blindly guessing an assignment as described in Section 4. The approach is based on transformation rules that are applied to subsumptions and dissubsumptions in order to derive a local solution. To solve the subsumptions, we reuse the rules of the goal-oriented algorithm for unification in EL [1, 14], which produces only local unifiers. Since any local solution of the disunification problem is in particular a local unifier of the subsumptions in the problem, one might think that it is then sufficient to check whether any of the produced unifiers also solves the dissubsumptions. This would not be complete, however, since the goal-oriented algorithm for unification does not produce all local unifiers. For this reason, we have additional rules for solving the dissubsumptions. Both rule sets contain (deterministic) eager rules that are applied with the highest priority, and nondeterministic rules that are only applied if no eager rule is applicable. The goal of the eager rules is to enable the algorithm to detect obvious contradictions as early as possible in order to reduce the number of nondeterministic choices it has to make.\nLet now \u03930 be the flat disunification problem for which we want to decide local solvability, and let the sets At, Var, and Atnv be defined as in Section 3. We assume without loss of generality that the dissubsumptions in \u03930 have only a single atom on the right-hand side. If this is not the case, it can easily be achieved by exhaustive application of the nondeterministic rule Right Decomposition (see Figure 1) without affecting the complexity of the overall procedure. Starting with \u03930, the algorithm maintains a current disunification problem \u0393 and a current acyclic assignment S, which initially assigns the empty set to all variables. In addition, for each subsumption or dissubsumption in \u0393, it maintains the information on whether it is solved or not. Initially, all subsumptions of \u03930 are unsolved, except those with a variable on the right-hand side, and all dissubsumptions in \u03930 are unsolved, except those with a variable on the left-hand side and a non-variable atom on the right-hand side.\nSubsumptions of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? X and dissubsumptions of the form X 6\u2291? D, for a non-variable atom D, are called initially solved. Intuitively, they only specify constraints on the assignment SX . More formally, this intuition is captured by the process of expanding \u0393 w.r.t. the variable X, which performs the following actions:\n\u2022 every initially solved subsumption s \u2208 \u0393 of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? X is\nexpanded by adding the subsumption C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Cn \u2291 ? E to \u0393 for every E \u2208 SX , and\n\u2022 every initially solved dissubsumption X 6\u2291? D \u2208 \u0393 is expanded by adding E 6\u2291? D to \u0393 for every E \u2208 SX .\nA (non-failing) application of a rule of our algorithm does the following:\n\u2022 it solves exactly one unsolved subsumption or dissubsumption,\n\u2022 it may extend the current assignment S by adding elements of Atnv to some set SX ,\n\u2022 it may introduce new flat subsumptions or dissubsumptions built from elements of At, and\n\u2022 it keeps \u0393 expanded w.r.t. all variables X.\nSubsumptions and dissubsumptions are only added by a rule application or by expansion if they are not already present in \u0393. If a new subsumption or dissubsumption is added to \u0393, it is marked as unsolved, unless it is initially solved (because of its form). Solving subsumptions and dissubsumptions is mostly independent, except for expanding \u0393, which can add new unsolved subsumptions and dissubsumptions at the same time, and may be triggered by solving a subsumption or a dissubsumption.\nThe rules of our algorithm are depicted in Figures 3 and 4. The rules dealing with subsumptions are essentially the same as in [14]; note that several of these may be applicable to the same subsumption. In the rule Local Extension, the left-hand side of s may be a variable, and then s is of the form Y 6\u2291? X. This dissubsumption is not initially solved, because X is not a non-variable atom.\nAlgorithm 11. Let \u03930 be a flat disunification problem. We initialize \u0393 := \u03930 and SX := \u2205 for all variables X. While \u0393 contains an unsolved element, do the following:\n(1) Eager rule application: If any eager rules (Figure 3) are applicable to some unsolved element s \u2208 \u0393, apply an arbitrarily chosen one to s. If the rule application fails, return \u201cfailure\u201d.\n(2) Nondeterministic rule application: If no eager rule is applicable, let s be an unsolved subsumption or dissubsumption in \u0393. If one of the nondeterministic rules (Figure 4) applies to s, choose one and apply it. If none of these rules apply to s or the rule application fails, return \u201cfailure\u201d.\nOnce all elements of \u0393 are solved, return the substitution \u03c3S that is induced by the current assignment.\nAs with Algorithm 7, the choice which (dis)subsumption to consider next and which eager rule to apply is don\u2019t care nondeterministic, while the choice of which nondeterministic rule to apply and the choices inside the rules are don\u2019t know nondeterministic. Each of these latter choices may result in a different solution \u03c3S.\n5.1. Termination.\nLemma 12. Every run of Algorithm 11 terminates in time polynomial in the size of \u03930."}, {"heading": "Eager Ground Solving:", "text": ""}, {"heading": "Eager Solving:", "text": ""}, {"heading": "Eager Extension:", "text": ""}, {"heading": "Eager Top Solving:", "text": ""}, {"heading": "Eager Left Decomposition:", "text": ""}, {"heading": "Eager Atomic Decomposition:", "text": "Proof. Each rule application solves one subsumption or dissubsumption. We show that only polynomially many subsumptions and dissubsumptions are produced during a run of the algorithm, and thus there can be only polynomially many rule applications during one run of the algorithm.\nA new subsumption or dissubsumption may be created only by an application of the rules Decomposition, Eager Left Decomposition, or Eager Atomic Decomposition, and then it is of the form C \u2291? D or C 6\u2291? D, with C,D \u2208 At. Obviously, there are only polynomially many such (dis)subsumptions."}, {"heading": "Decomposition:", "text": ""}, {"heading": "Extension:", "text": ""}, {"heading": "Local Extension:", "text": "Now, we consider (dis)subsumptions created by expanding \u0393. They can have the following forms, where D,E \u2208 Atnv:\n(1) C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? E, for C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? X in \u0393, (2) E 6\u2291? D, for X 6\u2291? D in \u0393.\nDissubsumptions of the type (2) are also of the form described above. For the subsumptions of type (1), note that C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn is either the left-hand side of a subsumption from the original problem \u03930, or was created by a Decomposition rule, in which case we have n = 1. Thus, there can also be at most polynomially many subsumptions of the first type.\nFinally, each rule application takes at most polynomial time.\n5.2. Soundness. Assume that a run of the algorithm terminates with success, i.e. all subsumptions and dissubsumptions are solved. Let \u0393\u0302 be the set of all subsumptions and dissubsumptions produced by this run, S be the final assignment, and \u03c3S the induced substitution (see Section 3). Observe that the algorithm never removes elements from the current disunification problem, but only marks them as solved, and hence \u0393\u0302 contains \u03930. To show that \u03c3S solves \u0393\u0302, and thus \u03930, we use induction on the following order on (dis)subsumptions.\nDefinition 13. Consider any (dis)subsumption s of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? Cn+1 or C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? Cn+1 in \u0393\u0302.\n\u2022 We define m(s) := (m1(s), m2(s)), where \u2013 m1(s) := {X1, . . . , Xm} is the multiset containing all occurrences of variables in the concept terms C1, . . . , Cn, Cn+1 (and hence m1(s) = \u2205 if s is ground);\n\u2013 m2(s) := |s| is the size of s, i.e. the number of symbols in s (see the proof of Lemma 8).\n\u2022 The strict partial order \u227b on such pairs is the lexicographic order, where the second components are compared w.r.t. the usual order on natural numbers, and the first components are compared w.r.t. the multiset extension of >S [5].\n\u2022 We extend \u227b to \u0393\u0302 by setting s1 \u227b s2 iff m(s1) \u227b m(s2).\nSince multiset extensions and lexicographic products of well-founded strict partial orders are again well-founded [5], \u227b is a well-founded strict partial order on \u0393\u0302.\nLemma 14. The substitution \u03c3S is a solution of \u0393\u0302, and thus also of its subset \u03930.\nProof. Consider a (dis)subsumption s \u2208 \u0393\u0302 and assume that \u03c3S solves all s \u2032 \u2208 \u0393\u0302 with s \u2032 \u227a s. Since s is solved, either it has been solved by a rule application or it was initially solved.\nIf s is a dissubsumption that is initially solved, then s = X 6\u2291? D, where X is a variable and D a non-variable atom. By expansion, for every E \u2208 SX , we have sE = E 6\u2291\n? D \u2208 \u0393\u0302. We know that s \u227b sE , because E may only contain a variable strictly smaller than X, and thus m1(s) > m1(sE). Hence by induction, \u03c3S solves all dissubsumptions sE with E \u2208 SX . Since the top-level atoms of \u03c3S(X) are exactly those of the form \u03c3S(E) for E \u2208 SX , by Lemma 2 we know that \u03c3S also solves s.\nIf s is a subsumption that is initially solved, then s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? X,\nwhere X is a variable. By expansion, for every E \u2208 SX , there is a subsumption sE = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291\n? E in \u0393\u0302. We have sE \u227a s since m1(sE) < m1(s), for every E \u2208 SX . Hence, by induction all subsumptions sE are solved by \u03c3S . By the definition of \u03c3S(X) and Lemma 1, \u03c3S solves s.\nIf s was solved by a rule application, we consider which rule was applied.\n\u2022 Eager Ground Solving: Then s is ground and holds under any substitution.\n\u2022 Eager Solving: Since this rule fails for all dissubsumptions to which it is applicable, but we assumed that the run was successful, we have s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? D\nand \u03c3S(D) occurs on the top-level of \u03c3S(C1)\u2293 \u00b7 \u00b7 \u00b7 \u2293\u03c3S(Cn). Hence, \u03c3S solves the subsumption.\n\u2022 (Eager) Extension: Then s = X\u2293C1\u2293\u00b7 \u00b7 \u00b7\u2293Cn \u2291 ? D for a variable X and D \u2208 SX .\nBy the definition of \u03c3S, we have \u03c3S(X) \u2291 \u03c3S(D) and thus \u03c3S solves s.\n\u2022 Eager Top Solving: This rule cannot have been applied since we assumed the run to be successful.\n\u2022 Eager Left Decomposition: Then either s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? D with n > 1,\nor s = \u22a4 6\u2291? D, for a non-variable atom D. In the latter case, \u03c3S solves s by Lemma 2. In the former case, for each i \u2208 {1, . . . , n} we have si := Ci 6\u2291\n? D \u2208 \u0393\u0302. Notice that m1(s) \u2265 m1(si) and m2(s) > m2(si) and hence s \u227b si. Thus, by induction we have that \u03c3S(Ci) 6\u2291 \u03c3S(D). By applying Lemma 2 twice, we conclude that \u03c3S(C1) \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u03c3S(Cn) 6\u2291 \u03c3S(D).\n\u2022 Eager Atomic Decomposition: Then s = C 6\u2291? D, where C and D are non-variable atoms. Since we assume that the run was successful, Case a) cannot apply. In\nCases b)\u2013d), \u03c3S must solve s by Lemma 3. Finally, in Case e), we have C = \u2203r.C \u2032, D = \u2203r.D\u2032, and s\u2032 = C \u2032 6\u2291? D\u2032 \u2208 \u0393\u0302. Notice that s \u227b s\u2032, because m1(s) = m1(s \u2032) and m2(s) > m2(s \u2032). Hence, by induction we get \u03c3S(C \u2032) 6\u2291 \u03c3S(D \u2032) and thus \u03c3S(C) 6\u2291 \u03c3S(D) by Lemma 3. \u2022 Decomposition: Then s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? \u2203s.D with Ci = \u2203s.C for some\ni \u2208 {1, . . . , n} and we have s\u2032 = C \u2291? D \u2208 \u0393\u0302. We know that s\u2032 \u227a s, because m1(s \u2032) \u2264 m1(s) and m2(s \u2032) < m2(s). By induction, we get \u03c3S(C) \u2291 \u03c3S(D), and hence \u03c3S solves s. \u2022 Local Extension: Then s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291 ? X and there is a non-variable atom\nD \u2208 SX such that s \u2032 = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Cn 6\u2291 ? D \u2208 \u0393\u0302. We have s \u227b s\u2032, because D may only contain a variable strictly smaller than X, and thus m1(s) > m1(s\n\u2032). Hence by induction, \u03c3 solves s\u2032. Since \u03c3S(D) is a top-level atom of \u03c3S(X), \u03c3S solves s by Lemma 2.\n5.3. Completeness. Assume now that \u03930 has a local solution \u03c3. We show that \u03c3 can guide the choices of Algorithm 11 to obtain a local solution \u03c3\u2032 of \u03930 such that, for every variable X, we have \u03c3(X) \u2291 \u03c3\u2032(X). The following invariants will be maintained throughout the run of the algorithm for the current set of (dis)subsumptions \u0393 and the current assignment S:\n(I) \u03c3 is a solution of \u0393.\n(II) For each D \u2208 SX , we have \u03c3(X) \u2291 \u03c3(D).\nBy Lemma 1, chains of the form \u03c3(X1) \u2291 \u03c3(\u2203r1.X2), . . .\u03c3(Xn\u22121) \u2291 \u03c3(\u2203rn\u22121.Xn) with X1 = Xn are impossible, and thus invariant (II) implies that S is acyclic. Hence, if extending S during a rule application preserves this invariant, this extension will not cause the algorithm to fail.\nLemma 15. The invariants are maintained by the operation of expanding \u0393.\nProof. Since expansion does not affect the assignment S, we have to check only invariant (I). Consider a subsumption s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291\n? X in \u0393, for which a new subsumption sE = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291\n? E is created because E \u2208 SX . By the invariants, \u03c3 solves s and \u03c3(X) \u2291 \u03c3(E). Hence by transitivity of subsumption, \u03c3 also solves sE, i.e. invariant (I) is satisfied after adding sE to \u0393.\nFor a dissubsumption s = X 6\u2291? D \u2208 \u0393 and E \u2208 SX , a new dissubsumption sE = E 6\u2291\n? D is created. Since \u03c3 solves s and \u03c3(X) \u2291 \u03c3(E) by invariant (II), we have \u03c3(E) 6\u2291 \u03c3(D) by transitivity of subsumption, i.e. \u03c3 solves sE .\nNow we show that if the invariants are satisfied, the eager rules maintain the invariants and do not lead to failure.\nLemma 16. The application of an eager rule never fails and maintains the invariants.\nProof. There are six eager rules to consider:\n\u2022 Eager Ground Solving: By invariant (I), \u03c3 solves all ground (dis)subsumptions in \u0393, and thus they must be valid. Therefore the rule cannot fail, and obviously it preserves the invariants.\n\u2022 Eager Solving: The rule does not affect the invariants. It could fail only in the case that \u0393 contains a dissubsumption s = C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291\n? D for which there exists an index i \u2208 {1, . . . , n} such that Ci = D or Ci is a variable and D \u2208 SCi . By invariant (I) and Lemma 1, the former case is impossible. In the latter case, invariant (II) similarly yields a contradiction to invariant (I).\n\u2022 Eager Extension: Consider any C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cm \u2291 ? D \u2208 \u0393 such that there is an\nindex i \u2208 {1, . . . , n} with Ci = X \u2208 Var and {C1, . . . , Cm} \\ {X} \u2286 SX . By the invariants and Lemma 1, we have \u03c3(X) \u2291 \u03c3(C1)\u2293 \u00b7 \u00b7 \u00b7\u2293\u03c3(Cm) \u2291 \u03c3(D), and thus adding D to SX maintains invariant (II). Therefore, the application of the rule does not cause S to be cyclic, and does not fail. Invariant (I) is not affected by this rule.\n\u2022 Eager Top Solving: By invariant (I), this rule will never be applied since \u03c3(C) 6\u2291? \u22a4 is impossible by Lemma 2.\n\u2022 Eager Left Decomposition: This rule never fails. Furthermore, S is not affected by the rule, and hence invariant (I) is preserved. Finally, if \u03c3 solves C1\u2293\u00b7 \u00b7 \u00b7\u2293Cn 6\u2291\n? D, then it must also solve Ci 6\u2291 ? D for each i \u2208 {1, . . . , n} by Lemma 2.\n\u2022 Eager Atomic Decomposition: Case a) cannot apply since \u03c3 is a solution of \u0393. Invariant (II) is not affected, because S is not changed by these rules. The fact that invariant (I) is maintained in Case e) follows from Lemma 3.\nNow we show that the nondeterministic rules can be applied in such a way that the invariants are maintained and the application does not lead to failure.\nLemma 17. If s is an unsolved (dis)subsumption of \u0393 to which no eager rule applies, then there is a nondeterministic rule that can be successfully applied to s while maintaining the invariants.\nProof. If s is an unsolved subsumption, then it is of the form C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? D, where D is a non-variable atom. By invariant (I), we have \u03c3(C1)\u2293\u00b7 \u00b7 \u00b7\u2293\u03c3(Cn) \u2291 \u03c3(D). By Lemma 1, there is an index i \u2208 {1, . . . , n} and a top-level atom E of \u03c3(Ci) such that E \u2291 \u03c3(D).\n\u2022 If Ci is a constant, then by Lemma 1 we have Ci = E = D, and thus Eager Solving is applicable, which contradicts the assumption.\n\u2022 If Ci = \u2203r.C \u2032, then \u03c3(Ci) = \u2203r.\u03c3(C \u2032) = E and by Lemma 1 we must have D = \u2203r.D\u2032 and \u03c3(C \u2032) \u2291 \u03c3(D\u2032). Thus, the Decomposition rule can be successfully applied to s and results in a new subsumption C \u2032 \u2291? D\u2032 that is solved by \u03c3.\n\u2022 If Ci is a variable, then invariant (II) is preserved by adding D to SCi since \u03c3(Ci) \u2291 E \u2291 \u03c3(D). Thus, we can successfully apply the Extension rule to s.\nIf s is an unsolved dissubsumption, then it must be of the form C1\u2293\u00b7 \u00b7 \u00b7\u2293Cn 6\u2291 ? X since otherwise one of the eager rules in Figure 3 would be applicable to it. We have \u03c3(C1)\u2293\u00b7 \u00b7 \u00b7\u2293\u03c3(Cn) 6\u2291 \u03c3(X) by invariant (I). By Lemma 2, there is a top-level atom E\nof \u03c3(X) such that \u03c3(C1)\u2293 \u00b7 \u00b7 \u00b7 \u2293 \u03c3(Cn) 6\u2291 E. Since \u03c3 is local, we must have E = \u03c3(D) for some D \u2208 Atnv. Hence, adding D to SX maintains invariant (II), and adding C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn 6\u2291\n? D to \u0393 maintains invariant (I). Thus, we can successfully apply the Local Extension rule to s.\nThis concludes the proof of correctness of Algorithm 11. Moreover, together with Lemma 8, we obtain an alternative proof of Fact 3.1.\nTheorem 18. The flat disunification problem \u03930 has a local solution iff there is a successful run of Algorithm 11 on \u03930.\nWe have restricted the nondeterministic choices of Algorithm 11 in such way that non-variable atoms are only added to the assignment S if this is necessary to directly solve some (dis)subsumption in \u0393. Hence, the algorithm cannot be used to compute all local solutions of \u0393, but already selects the more \u201cinteresting\u201d ones. As described in the introduction, further dissubsumptions of the form X 6\u2291? D with X \u2208 Var and D \u2208 Atnv can be added to \u0393 in order to further restrict the solution space."}, {"heading": "6. Encoding local disunification into SAT", "text": "In the following, we consider an alternative algorithm for local disunification that is based on a polynomial encoding into a SAT problem. This reduction is a generalization of the one developed for unification problems in [2]. We again consider a flat disunification problem \u0393 and the sets At, Var, and Atnv as in Section 3. Since we are restricting our considerations to local solutions, we can without loss of generality assume that the sets Nv, Nc, and NR contain exactly the variables, constants, and role names occurring in \u0393. To further simplify the reduction, we assume in the following that all flat dissubsumptions in \u0393 are of the form X 6\u2291? Y for variables X, Y . This is without loss of generality, which can be shown using a transformation similar to that of Section 3.2. The translation uses the propositional variables [C \u2291 D] for all C,D \u2208 At. The SAT problem consists of a set of clauses Cl(\u0393) over these variables that express properties of (dis)subsumption in EL and encode the elements of \u0393. The intuition is that a satisfying valuation of Cl(\u0393) induces a local solution \u03c3 of \u0393 such that \u03c3(C) \u2291 \u03c3(D) holds whenever [C \u2291 D] is true under the valuation. The solution \u03c3 is constructed by first extracting an acyclic assignment S out of the satisfying valuation and then computing \u03c3 := \u03c3S. We additionally introduce the variables [X > Y ] for all X, Y \u2208 Nv to ensure that the generated assignment S is indeed acyclic. This is achieved by adding clauses to Cl(\u0393) that express that >S is a strict partial order, i.e. irreflexive and transitive. We further use the auxiliary variables pC,X,D for all X \u2208 Nv, C \u2208 At, and D \u2208 Atnv to express the restrictions imposed by dissubsumptions of the form C 6\u2291? X in clausal form. More precisely, whenever [C \u2291 X ] is false for some X \u2208 Nv and C \u2208 At, then the dissubsumption \u03c3(C) 6\u2291 \u03c3(X) should hold. By Lemma 2, this means that we need to find an atom D \u2208 Atnv that is a top-level atom of \u03c3(X) and satisfies \u03c3(C) 6\u2291 \u03c3(D).\nThis is enforced by making the auxiliary variable pC,X,D true, which makes [X \u2291 D] true and [C \u2291 D] false (see Definition 19(IV) and Lemma 22 for details). To denote propositional clauses, we use the implicative form \u03c6 \u2192 \u03c8, where \u03c6 is the conjunction of all negative literals of the clause, and \u03c8 is the disjunction of all positive literals. We use \u22a4 to denote an empty conjunction, and \u22a5 for an empty disjunction.\nDefinition 19. The set Cl(\u0393) contains the following propositional clauses:\n(I) Translation of \u0393. a. For every subsumption C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? D in \u0393 with D \u2208 Atnv:\n\u22a4 \u2192 [C1 \u2291 D] \u2228 \u00b7 \u00b7 \u00b7 \u2228 [Cn \u2291 D]\nb. For every subsumption C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? X in \u0393 with X \u2208 Nv, and every\nE \u2208 Atnv:\n[X \u2291 E] \u2192 [C1 \u2291 E] \u2228 \u00b7 \u00b7 \u00b7 \u2228 [Cn \u2291 E]\nc. For every dissubsumption X 6\u2291? Y in \u0393: [X \u2291 Y ] \u2192 \u22a5\n(II) Properties of subsumptions between non-variable atoms. a. For every A \u2208 Nc: \u22a4 \u2192 [A \u2291 A]\nb. For every A,B \u2208 Nc with A 6= B: [A \u2291 B] \u2192 \u22a5\nc. For every \u2203r.A, \u2203s.B \u2208 Atnv with r 6= s: [\u2203r.A \u2291 \u2203s.B] \u2192 \u22a5\nd. For every A \u2208 Nc and \u2203r.B \u2208 Atnv:\n[A \u2291 \u2203r.B] \u2192 \u22a5 and [\u2203r.B \u2291 A] \u2192 \u22a5\ne. For every \u2203r.A, \u2203r.B \u2208 Atnv:\n[\u2203r.A \u2291 \u2203r.B] \u2192 [A \u2291 B] and [A \u2291 B] \u2192 [\u2203r.A \u2291 \u2203r.B]\n(III) Transitivity of subsumption. For every C1, C2, C3 \u2208 At: [C1 \u2291 C2] \u2227 [C2 \u2291 C3] \u2192 [C1 \u2291 C3] (IV) Dissubsumptions of the form C 6\u2291? X with a variable X. For every C \u2208 At, X \u2208 Nv:\n\u22a4 \u2192 [C \u2291 X ] \u2228 \u2228\nD\u2208Atnv\npC,X,D,\nand additionally for every D \u2208 Atnv:\npC,X,D \u2192 [X \u2291 D] and pC,X,D \u2227 [C \u2291 D] \u2192 \u22a5\n(V) Properties of >. a. For every X \u2208 Nv: [X > X ] \u2192 \u22a5\nb. For every X, Y, Z \u2208 Nv: [X > Y ] \u2227 [Y > Z] \u2192 [X > Z]\nc. For every X, Y \u2208 Nv and \u2203r.Y \u2208 At: [X \u2291 \u2203r.Y ] \u2192 [X > Y ]\nThe main difference to the encoding in [2] lies in the clauses (IV) that ensure the presence of a non-variable atom D that solves the dissubsumption C 6\u2291? X (cf. Lemma 2). We also need some additional clauses in (II) to deal with dissubsumptions.\nIt is easy to see that Cl(\u0393) can be constructed in time cubic in the size of \u0393 (due to the clauses in (III) and (V)b). We prove the correctness of this reduction in the following two sections.\n6.1. Soundness. Let \u03c4 be a valuation of the propositional variables that satisfies Cl(\u0393). We define the assignment S\u03c4 as follows:\nS\u03c4X := {D \u2208 Atnv | \u03c4([X \u2291 D]) = 1}.\nWe show the following property of >S\u03c4 ; the proof is exactly the same as in [2], but uses a different notation.\nLemma 20. The relation >S\u03c4 is irreflexive.\nProof. We first show that X >S\u03c4 Y implies \u03c4([X > Y ]) = 1 for all X, Y \u2208 Nv. If Y occurs in an atom of S\u03c4X , then this atom must be of the form \u2203r.Y with r \u2208 NR. By construction of S\u03c4 , this implies that \u03c4([X \u2291 \u2203r.Y ]) = 1. Since \u03c4 satisfies the clauses in (V)c, we have \u03c4([X > Y ]) = 1. By definition of >S\u03c4 and the transitivity clauses in (V)b, we conclude that \u03c4([X > Y ]) = 1 whenever X >S\u03c4 Y .\nAssume now that X >S\u03c4 X holds for some X \u2208 Nv. By the claim above, this implies that \u03c4([X > X ]) = 1. But this is impossible since \u03c4 satisfies the clauses in (V)a.\nThis in particular shows that S\u03c4 is acyclic. In the following, let \u03c3\u03c4 denote the substitution \u03c3S\u03c4 induced by S \u03c4 . We show that \u03c3\u03c4 is a solution of \u0393.\nLemma 21. If C,D \u2208 At such that \u03c4([C \u2291 D]) = 1, then \u03c3\u03c4 (C) \u2291 \u03c3\u03c4 (D).\nProof. We show this by induction on the pairs (rd(\u03c3\u03c4 (D)),Var(D)), where Var(D) is either the variable that occurs in D, or \u22a5 if D is ground. These pairs are compared by the lexicographic extension of the order > on natural numbers for the first component and the order >S\u03c4 for the second component, which is extended by Y >S\u03c4 \u22a5 for all Y \u2208 Nv.\nWe make a case distinction on the form of C and D and consider first the case that D is a variable. Let \u03c3\u03c4 (E) be any top-level atom of \u03c3\u03c4 (D), which means that \u03c4([D \u2291 E]) = 1. By the clauses in (III), we also have \u03c4([C \u2291 E]) = 1. Since rd(\u03c3\u03c4 (D)) \u2265 rd(\u03c3\u03c4 (E)) and Var(D) = D >S\u03c4 Var(E), by induction we get \u03c3\u03c4 (C) \u2291 \u03c3\u03c4 (E). Since \u03c3\u03c4 (D) is equivalent to the conjunction of all its top-level atoms, by Lemma 1 we obtain \u03c3\u03c4 (C) \u2291 \u03c3\u03c4 (D).\nIf D is a non-variable atom and C is a variable, then \u03c3\u03c4 (C) \u2291 \u03c3\u03c4 (D) holds by construction of S\u03c4 and Lemma 1.\nIf C,D are both non-variable atoms, then by the clauses in (II) they must either be the same concept constant, or be existential restrictions using the same role name. In the first case, the claim follows immediately. In the latter case, let C = \u2203r.C \u2032 and D = \u2203r.D\u2032. By the clauses in (II)e, we have \u03c4([C \u2032 \u2291 D\u2032]) = 1. Since rd(\u03c3\u03c4 (D)) > rd(\u03c3\u03c4 (D \u2032)), by induction we get \u03c3\u03c4 (C \u2032) \u2291 \u03c3\u03c4 (D\n\u2032), and thus \u03c3\u03c4 (C) \u2291 \u03c3\u03c4 (D) by Lemma 1.\nWe now show that the converse of this lemma also holds.\nLemma 22. If C,D \u2208 At such that \u03c4([C \u2291 D]) = 0, then \u03c3\u03c4 (C) 6\u2291 \u03c3\u03c4 (D).\nProof. We show this by induction on the tuples (rd(\u03c3\u03c4 (C)),Var(C),Var(D)) and make a case distinction on the form of C and D. If D is a variable, then by the clauses in (IV) there must be a D\u2032 \u2208 Atnv such that \u03c4(pC,D,D\u2032) = 1. This implies that \u03c4([D \u2291 D\u2032]) = 1 and \u03c4([C \u2291 D\u2032]) = 0. By construction of S\u03c4 , \u03c3\u03c4 (D\n\u2032) is a toplevel atom of \u03c3\u03c4 (D) and Var(D) >S\u03c4 Var(D\n\u2032). Since rd(\u03c3\u03c4 (C)) = rd(\u03c3\u03c4 (C)) and Var(C) = Var(C), by induction we get \u03c3\u03c4 (C) 6\u2291 \u03c3\u03c4 (D\n\u2032), and thus \u03c3\u03c4 (C) 6\u2291 \u03c3\u03c4 (D) by Lemma 2.\nIf D is a non-variable atom and C is a variable, then consider any top-level atom \u03c3\u03c4 (E) of \u03c3\u03c4 (C), which means that we have \u03c4([C \u2291 E]) = 1. By the clauses in (III) this implies that \u03c4([E \u2291 D]) = 0. Since we have rd(\u03c3\u03c4 (C)) \u2265 rd(\u03c3\u03c4 (E)) and Var(C) = C >S\u03c4 Var(E), by induction we get \u03c3\u03c4 (E) 6\u2291 \u03c3\u03c4 (D). Since \u03c3\u03c4 (C) is equivalent to the conjunction of all its top-level atoms, by Lemma 2 we get \u03c3\u03c4 (C) 6\u2291 \u03c3\u03c4 (D). If C,D are both non-variable atoms, then by the clauses in (II), they are either different constants, a constant and an existential restriction, or two existential restrictions. In the first two cases, \u03c3\u03c4 (C) 6\u2291 \u03c3\u03c4 (D) holds by Lemma 1. In the last case, they can either contain two different roles or the same role. Again, the former case is covered by Lemma 1, while in the latter case we have C = \u2203r.C \u2032, D = \u2203r.D\u2032, and \u03c4([C \u2032 \u2291 D\u2032]) = 0 by the clauses in (II)e. Since rd(\u03c3\u03c4 (C)) > rd(\u03c3\u03c4 (C\n\u2032)), by induction we get \u03c3\u03c4 (C \u2032) 6\u2291 \u03c3\u03c4 (D \u2032), and thus \u03c3\u03c4 (C) 6\u2291 \u03c3\u03c4 (D) by Lemma 2.\nThis suffices to show soundness of the reduction.\nLemma 23. The local substitution \u03c3\u03c4 solves \u0393.\nProof. Consider any flat subsumption C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Cn \u2291 ? D in \u0393. If D \u2208 Atnv, then we have \u03c3\u03c4 (Ci) \u2291 \u03c3\u03c4 (D) for some i, 1 \u2264 i \u2264 n, by the clauses in (I) and Lemma 21. By Lemma 1, \u03c3\u03c4 solves the subsumption.\nIf D is a variable, then consider any top-level atom \u03c3\u03c4 (E) of \u03c3\u03c4 (D), for which we must have \u03c4([D \u2291 E]) = 1. By the clauses in (I), there must be an i, 1 \u2264 i \u2264 n, such that \u03c4([Ci \u2291 E]) = 1, and thus \u03c3\u03c4 (Ci) \u2291 \u03c3\u03c4 (E) by Lemma 21. Again, by Lemma 1 this implies that \u03c3\u03c4 solves the subsumption.\nFinally, consider a dissubsumption X 6\u2291? Y in \u0393. Then by the clauses in (I) and Lemma 22 we have \u03c3\u03c4 (X) 6\u2291 \u03c3\u03c4 (Y ) i.e. \u03c3\u03c4 solves the dissubsumption.\n6.2. Completeness. Let now \u03c3 be a ground local solution of \u0393 and >\u03c3 the resulting partial order on Nv, defined as follows for all X, Y \u2208 Nv:\nX >\u03c3 Y iff \u03c3(X) \u2291 \u2203r1. . . .\u2203rn.\u03c3(Y ) for some r1, . . . , rn \u2208 NR with n \u2265 1.\nNote that >\u03c3 is irreflexive since X >\u03c3 X is impossible by Lemma 1, and it is transitive since \u2291 is transitive and closed under applying existential restrictions on both sides.\nThus, >\u03c3 is a strict partial order. We define a valuation \u03c4\u03c3 as follows for all C,D \u2208 At, E \u2208 Atnv, and X, Y \u2208 Nv:\n\u03c4\u03c3([C \u2291 D]) :=\n{\n1 if \u03c3(C) \u2291 \u03c3(D)\n0 otherwise\n\u03c4\u03c3(pC,X,E) :=\n{\n1 if \u03c3(X) \u2291 \u03c3(E) and \u03c3(C) 6\u2291 \u03c3(E)\n0 otherwise\n\u03c4\u03c3([X > Y ]) :=\n{\n1 if X >\u03c3 Y\n0 otherwise\nLemma 24. The valuation \u03c4\u03c3 satisfies all clauses of Cl(\u0393).\nProof. For (I)a, consider any flat subsumption C1\u2293\u00b7 \u00b7 \u00b7\u2293Cn \u2291 ? D in \u0393 with D \u2208 Atnv. Since \u03c3 solves \u0393, we have \u03c3(C1) \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u03c3(Cn) \u2291 \u03c3(D). Since \u03c3(D) is an atom, by Lemma 1 there must be an i, 1 \u2264 i \u2264 n, and a top-level atom E of \u03c3(Ci) such that \u03c3(Ci) \u2291 E \u2291 \u03c3(D). By the definition of \u03c4\u03c3, this shows that \u03c4\u03c3([Ci \u2291 D]) = 1, and thus the clause is satisfied.\nConsider now an arbitrary flat subsumption C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Cn \u2291 ? X from \u0393 where X is a variable, and any E \u2208 Atnv such that \u03c4\u03c3([X \u2291 E]) = 1. This implies that we have \u03c3(C1) \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u03c3(Cn) \u2291 \u03c3(X) \u2291 \u03c3(E), and thus as above there is a top-level atom F of some \u03c3(Ci) such that \u03c3(Ci) \u2291 F \u2291 \u03c3(E), which shows that \u03c4\u03c3([Ci \u2291 E]) = 1, as required for the clause in (I)b.\nFor every dissubsumption X 6\u2291? Y in \u0393, we must have \u03c3(X) 6\u2291 \u03c3(Y ), and thus \u03c4\u03c3([X \u2291 Y ]) = 0, satisfying the clause in (I)c.\nFor A \u2208 Nc, we have \u03c3(A) \u2291 \u03c3(A), and thus \u03c4\u03c3([A \u2291 A]) = 1. Similar arguments show that the remaining clauses in (II) are also satisfied (see Lemma 1). For (III), consider C1, C2, C3 \u2208 At with \u03c4\u03c3([C1 \u2291 C2]) = \u03c4\u03c3([C2 \u2291 C3]) = 1, and thus \u03c3(C1) \u2291 \u03c3(C2) \u2291 \u03c3(C3). By transitivity of \u2291, we infer \u03c4\u03c3([C1 \u2291 C3]) = 1.\nFor all C \u2208 At, X \u2208 Nv, and D \u2208 Atnv with \u03c4\u03c3(pC,X,D) = 1, we must have \u03c4\u03c3([X \u2291 D]) = 1 and \u03c4\u03c3([C \u2291 D]) = 0 by the definition of \u03c4\u03c3. Furthermore, whenever \u03c4\u03c3([C \u2291 X ]) = 0, we have \u03c3(C) 6\u2291 \u03c3(X), and thus by Lemma 2 there must be a toplevel atom E of \u03c3(X) such that \u03c3(C) 6\u2291 E. Since \u03c3 is a local solution, E must be of the form \u03c3(F ) for some F \u2208 Atnv, and thus we obtain \u03c3(X) \u2291 \u03c3(F ) and \u03c3(C) 6\u2291 \u03c3(F ), and hence \u03c4\u03c3(pC,X,F ) = 1. This shows that all clauses in (IV) are satisfied by \u03c4\u03c3.\nFor (V)a, recall that >\u03c3 is irreflexive. Transitivity of >\u03c3 yields satisfaction of the clauses in (V)b. Finally, if \u03c3(X) \u2291 \u03c3(\u2203r.Y ) = \u2203r.\u03c3(Y ) for some X, Y \u2208 Nv with \u2203r.Y \u2208 At, we have X >\u03c3 Y by definition, and thus the clauses in (V)c are satisfied by \u03c4\u03c3.\nThis completes the proof of the correctness of the translation presented in Definition 19, which provides us with a reduction of local disunification (and thus also of dismatching) to SAT. Since the size of Cl(\u0393) is polynomial in the size of \u0393, we obtain yet another proof of Fact 3.1.\nTheorem 25. The flat disunification problem \u0393 has a local solution iff Cl(\u0393) is satisfiable.\nRegarding the computation of actual solutions, we note that the definition of S\u03c4 in Section 6.1 describes how to obtain local solutions of \u0393 from the satisfying valuations of Cl(\u0393). From a syntactic point of view, this approach does not yield all local solutions. In fact, the transitivity clauses (III) may force us to add atoms to S\u03c4 that are, syntactically, not necessary to solve \u0393. Also note that different satisfying valuations \u03c4 may sometimes yield equivalent unifiers, because some atoms in the substitution \u03c3\u03c4 (X) of a variable X may be subsumed by others. Nevertheless, we can show that, by applying the construction of Section 6.1 to the satisfying valuations of Cl(\u0393), we obtain all local solutions of \u0393 modulo equivalence. We call two solutions \u03c3 and \u03b3 equivalent if \u03c3(X) \u2261 \u03b3(X) holds for all X \u2208 Nv.\nLemma 26. Let \u03c3 be a local solution of the flat disunification problem \u0393. Then there is a satisfying valuation \u03c4 of Cl(\u0393) such that \u03c3S\u03c4 is equivalent to \u03c3.\nProof. Let S be the acyclic assignment underlying \u03c3, \u03c4 := \u03c4\u03c3 be the satisfying valuation induced by \u03c3 as defined in Section 6.2, and S\u03c4 and \u03b3 := \u03c3S\u03c4 be as defined in Section 6.1. We first show that SX \u2286 S \u03c4 X holds for all X \u2208 Nv. To this end, consider any non-variable atom D \u2208 SX . Since \u03c3(D) is a top-level atom of \u03c3(X), by Lemma 1 we have \u03c3(X) \u2291 \u03c3(D). Hence, the definitions of \u03c4 and S\u03c4 yield that \u03c4([X \u2291 D]) = 1 and D \u2208 S\u03c4X , as required. We can now show by induction on the well-founded strict partial order >S\u03c4 that \u03c3(X) \u2261 \u03b3(X) holds for all X \u2208 Nv. Assume that \u03c3(Y ) \u2261 \u03b3(Y ) holds for all variables Y <S\u03c4 X, and hence \u03c3(D) \u2261 \u03b3(D) holds for all non-variable atoms D \u2208 S \u03c4 X , including those in SX (it trivially holds if D is ground). Since \u03c3(X) consists exactly of the toplevel atoms \u03c3(D), D \u2208 SX , and similarly \u03b3(X) consists exactly of the top-level atoms \u03b3(D), D \u2208 S\u03c4X , we thus know that each top-level atom of \u03c3(X) is equivalent to a toplevel atom of \u03b3(X). Hence, \u03b3(X) \u2291 \u03c3(X) holds by Lemma 1. For the other direction, consider any top-level atom of \u03b3(X), which must be of the form \u03b3(D) with D \u2208 S\u03c4X . By the definition of S\u03c4 , we obtain \u03c4([X \u2291 D]) = 1, which yields \u03c3(X) \u2291 \u03c3(D) by the definition of \u03c4 . Hence, there must be a top-level atom of \u03c3(X) that is subsumed by \u03b3(D) \u2261 \u03c3(D), and thus Lemma 1 yields \u03c3(X) \u2291 \u03b3(X).\nThe SAT reduction has been implemented in our prototype system UEL,5 which uses SAT4J6 as external SAT solver. First experiments show that disunification is indeed helpful for reducing the number and the size of solutions. For example, a slightly modified version of the example from the introduction has 128 solutions without any dissubsumptions (see [12] for more details). Each additional dissubsumption disallowing a particular non-variable atom in the assignments (e.g. the dissubsumption (1.3) from the introduction) roughly halves the number of remaining solutions. The runtime performance of the solver for local disunification problems is comparable to the one for pure unification problems, even on larger problems.\n5version 1.4.0, available at http://uel.sourceforge.net/ 6http://www.sat4j.org/"}, {"heading": "7. Related work", "text": "Since Description Logics and Modal Logics are closely related [32], results on unification in one of these two areas carry over to the other one. In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31]. An important open problem in the area is the question whether unification in the basic modal logic K, which corresponds to the DL ALC, is decidable. It is only known that relatively minor extensions of K have an undecidable unification problem [33]. Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30]. To be more precise, a normal modal logic L induces an equational theory EL that axiomatizes equivalence in this logic, where the formulas are viewed as terms. Validity is then just equivalence to \u22a4 and inconsistency is equivalence to \u22a5. An inference rule is of the form\nA1, . . . , Am B1, . . . , Bn (7.1)\nwhere A1, . . . , Bn are formulas (terms) that may contain variables. More precisely, it is not a single rule but a rule schema that stands for all its instances\n\u03c3(A1), . . . , \u03c3(Am) \u03c3(B1), . . . , \u03c3(Bn) (7.2)\nwhere \u03c3 is a substitution. The semantics of such a rule (7.2) is the following: whenever all of its premises are valid, then one of the consequences must be valid as well. We only admit the inference rule (7.1) for the logic L if all its instances (7.2) satisfy this requirement. Thus, we say that the inference rule (7.1) is admissible for L if\n\u03c3(A1) =EL \u22a4 \u2227 . . . \u2227 \u03c3(Am) =EL \u22a4 implies \u03c3(B1) =EL \u22a4 \u2228 . . . \u2228 \u03c3(Bn) =EL \u22a4\nfor all substitutions \u03c3. Obviously, this is the case iff the disunification problem\n{A1 \u2261 ? \u22a4, . . . , Am \u2261 ? \u22a4, B1 6\u2261 ? \u22a4, . . . , Bn 6\u2261 ? \u22a4}\ndoes not have a solution. As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19\u201321]. As shown in [1], equivalence in EL can be axiomatized by the equational theory of semilattices with monotone functions, which extends the theory ACUI of an associative-commutativeidempotent binary function symbol \u2217 (corresponding to \u2293) with unit (corresponding to \u22a4) by unary function symbols hr (corresponding to \u2203r) that are monotone in the sense that they satisfy the identities hr(x) \u2217 hr(x \u2217 y) = hr(x \u2217 y). Perhaps the closest to our present work is thus the investigation of disunification in ACUI with free function symbols (i.e., additional function symbols of arbitrary arity that satisfy no non-trivial identities). This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28]. To be more precise, the NP upper bound is shown in [7] for the theory ACI with free function symbols, using general combination results for disunification developed in the same article. However, it is easy to see that the approach applied in [7] also\nworks for ACUI. In contrast, the NP upper bound in [22] is shown for ACUI with free function symbols by directly designing a dedicated algorithm for disunification in this theory."}, {"heading": "8. Conclusions", "text": "We have considered disunification in the description logic EL. While the complexity of the general problem remains open, we have identified two restrictions under which the complexity does not increase when compared to plain unification in EL, i.e. remains in NP. We developed a nondeterministic polynomial reduction from dismatching problems to local disunification problems, and presented two algorithms to solve the latter. These procedures extend known algorithms for unification in EL without a large negative impact on their performance. Regarding future work, we want to investigate the decidability and complexity of general disunification in EL, and consider also the case where non-ground solutions are allowed. In contrast to unification, these extensions make the problem harder to solve. From a more practical point of view, we plan to implement also the goaloriented algorithm for local disunification, and to evaluate the performance of both presented algorithms on real-world problems. In addition, we will investigate whether a reduction to answer set programming (ASP) [17, 23] rather than SAT leads to a better performance."}, {"heading": "37\u201347, 2012.", "text": "[15] Franz Baader, Stefan Borgwardt, and Barbara Morawska. Dismatching and local disunification in EL. In Maribel Fern\u00e1ndez, editor, Proc. of the 26th Int. Conf. on Rewriting Techniques and Applications (RTA\u201915), volume 36 of Leibniz International Proceedings in Informatics, pages 40\u201356. Dagstuhl Publishing, 2015. doi:10.4230/LIPIcs.RTA.2015.40. [16] Sergey Babenyshev, Vladimir V. Rybakov, Renate Schmidt, and Dmitry Tishkovsky. A tableau method for checking rule admissibility in S4. In Proc. of the 6th Workshop on Methods for Modalities (M4M-6), 2009. [17] Chitta Baral. Knowledge Representation, Reasoning and Declarative Problem Solving. Cambridge University Press, 2003.\n[18] Sebastian Brandt. Polynomial time reasoning in a description logic with existential restrictions, GCI axioms, and\u2014what else? In Ramon L\u00f3pez de M\u00e1ntaras and Lorenza Saitta, editors, Proc. of the 16th Eur. Conf. on Artificial Intelligence (ECAI\u201904), pages 298\u2013302. IOS Press, 2004. [19] W. L. Buntine and H.-J. B\u00fcrckert. On solving equations and disequations. Journal of the ACM, 41(4):591\u2013629, 1994. doi:10.1145/179812.179813. [20] H. Comon. Disunification: A survey. In J.-L. Lassez and G. Plotkin, editors, Computational Logic: Essays in Honor of Alan Robinson, pages 322\u2013359. MIT Press, Cambridge, MA, 1991. [21] Hubert Comon and Pierre Lescanne. Equational problems and disunification. Journal of Logic and Computation, 7(3/4):371\u2013425, 1989. doi:10.1016/S0747-7171(89)80017-3. [22] Agostino Dovier, Carla Piazza, and Enrico Pontelli. Disunification in ACI1 theories. Constraints, 9(1):35\u201391, 2004. doi:10.1023/B:CONS.0000006182.84033.6e. [23] Michael Gelfond and Vladimir Lifschitz. The stable model semantics for logic programming. In Robert A. Kowalski and Kenneth A. Bowen, editors, Proc. of the 5th Int. Conf. and Symp. on Logic Programming (ICLP\u201988), pages 1070\u20131080. MIT Press, 1988. [24] Silvio Ghilardi. Unification through projectivity. Journal of Logic and Computation, 7(6):733\u2013752, 1997. doi:10.1093/logcom/7.6.733. [25] Silvio Ghilardi. Unification in intuitionistic logic. Journal of Symbolic Logic, 64 (2):859\u2013880, 1999. doi:10.2307/2586506. [26] Ian Horrocks, Peter F. Patel-Schneider, and Frank van Harmelen. From SHIQ and RDF to OWL: The making of a web ontology language. Journal of Web Semantics, 1(1):7\u201326, 2003. doi:10.1016/j.websem.2003.07.001. [27] Rosalie Iemhoff and George Metcalfe. Proof theory for admissible rules. Annals of Pure and Applied Logic, 159(1-2):171\u2013186, 2009. doi:10.1016/j.apal.2008.10.011. [28] Deepak Kapur and Paliath Narendran. Complexity of unification problems with associative-commutative operators. Journal of Automated Reasoning, 9:261\u2013288, 1992. doi:10.1007/BF00245463. [29] Ralf K\u00fcsters. Chapter 6: Matching. In Non-Standard Inferences in Description Logics, volume 2100 of Lecture Notes in Computer Science, pages 153\u2013227. Springer-Verlag, 2001. doi:10.1007/3-540-44613-3_6. [30] Vladimir V. Rybakov. Admissibility of logical inference rules, volume 136 of Studies in Logic and the Foundations of Mathematics. North-Holland Publishing Co., Amsterdam, 1997. [31] Vladimir V. Rybakov. Multi-modal and temporal logics with universal formula - reduction of admissibility to validity and unification. Journal of Logic and Computation, 18(4):509\u2013519, 2008. doi:10.1093/logcom/exm078. [32] Klaus Schild. A correspondence theory for terminological logics: Preliminary report. In John Mylopoulos and Raymond Reiter, editors, Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI\u201991), pages 466\u2013471. Morgan Kaufmann, 1991.\n[33] Frank Wolter and Michael Zakharyaschev. Undecidability of the unification and admissibility problems for modal and description logics. ACM Transactions on Computational Logic, 9(4):25:1\u201325:20, 2008. doi:10.1145/1380572.1380574."}], "references": [{"title": "Unification in the description logic EL", "author": ["Franz Baader", "Barbara Morawska"], "venue": "Logical Methods in Computer Science,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "SAT encoding of unification in EL", "author": ["Franz Baader", "Barbara Morawska"], "venue": "Proc. of the 17th Int. Conf. on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR\u201910),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2010}, {"title": "Matching with respect to general concept inclusions in the description logic EL", "author": ["Franz Baader", "Barbara Morawska"], "venue": "Proc. of the 37th German Conf. on Artificial Intelligence (KI\u201914),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "Unification of concept terms in description logics", "author": ["Franz Baader", "Paliath Narendran"], "venue": "J. of Symbolic Computation,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2001}, {"title": "Term Rewriting and All That", "author": ["Franz Baader", "Tobias Nipkow"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1999}, {"title": "Solving language equations and disequations with applications to disunification in description logics and monadic set constraints", "author": ["Franz Baader", "Alexander Okhotin"], "venue": "Proc. of the 18th Int. Conf. on Logic for Programming, Artifical Intelligence, and Reasoning (LPAR\u201912),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Combination techniques and decision problems for disunification", "author": ["Franz Baader", "Klaus U. Schulz"], "venue": "Theoretical Computer Science,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1995}, {"title": "Matching in description logics", "author": ["Franz Baader", "Ralf K\u00fcsters", "Alex Borgida", "Deborah L. McGuinness"], "venue": "Journal of Logic and Computation,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1999}, {"title": "Computing least common subsumers in description logics with existential restrictions", "author": ["Franz Baader", "Ralf K\u00fcsters", "Ralf Molitor"], "venue": "Proc. of the 16th Int. Joint Conf. on Artificial Intelligence", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1999}, {"title": "The Description Logic Handbook: Theory, Implementation, and Applications", "author": ["Franz Baader", "Diego Calvanese", "Deborah McGuinness", "Daniele Nardi", "Peter F. Patel-Schneider", "editors"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "Pushing the EL envelope further", "author": ["Franz Baader", "Sebastian Brandt", "Carsten Lutz"], "venue": "Proc. of the 4th Int. Workshop on OWL: Experiences and Directions (OWLED\u201908DC),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2008}, {"title": "UEL: Unification solver for EL", "author": ["Franz Baader", "Stefan Borgwardt", "Julian Alfredo Mendez", "Barbara Morawska"], "venue": "Proc. of the 25th Int. Workshop on Description Logics (DL\u201912),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Computing minimal EL-unifiers is hard", "author": ["Franz Baader", "Stefan Borgwardt", "Barbara Morawska"], "venue": "Proc. of the 9th Int. Conf. on Advances in Modal Logic (AiML\u201912),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2012}, {"title": "A goal-oriented algorithm for unification in EL w.r.t. cycle-restricted TBoxes", "author": ["Franz Baader", "Stefan Borgwardt", "Barbara Morawska"], "venue": "Proc. of the 25th Int. Workshop on Description Logics (DL\u201912),", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Dismatching and local disunification in EL", "author": ["Franz Baader", "Stefan Borgwardt", "Barbara Morawska"], "venue": "Proc. of the 26th Int. Conf. on Rewriting Techniques and Applications (RTA\u201915),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2015}, {"title": "A tableau method for checking rule admissibility in S4", "author": ["Sergey Babenyshev", "Vladimir V. Rybakov", "Renate Schmidt", "Dmitry Tishkovsky"], "venue": "In Proc. of the 6th Workshop on Methods for Modalities", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["Chitta Baral"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2003}, {"title": "Polynomial time reasoning in a description logic with existential restrictions, GCI axioms, and\u2014what else", "author": ["Sebastian Brandt"], "venue": "Proc. of the 16th Eur. Conf. on Artificial Intelligence", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2004}, {"title": "On solving equations and disequations", "author": ["W.L. Buntine", "H.-J. B\u00fcrckert"], "venue": "Journal of the ACM,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1994}, {"title": "Disunification: A survey", "author": ["H. Comon"], "venue": "Computational Logic: Essays in Honor of Alan Robinson,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1991}, {"title": "Equational problems and disunification", "author": ["Hubert Comon", "Pierre Lescanne"], "venue": "Journal of Logic and Computation,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1989}, {"title": "Disunification in ACI1", "author": ["Agostino Dovier", "Carla Piazza", "Enrico Pontelli"], "venue": "theories. Constraints,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2004}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "Proc. of the 5th Int. Conf. and Symp. on Logic Programming", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1988}, {"title": "Unification through projectivity", "author": ["Silvio Ghilardi"], "venue": "Journal of Logic and Computation,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1997}, {"title": "Unification in intuitionistic logic", "author": ["Silvio Ghilardi"], "venue": "Journal of Symbolic Logic,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1999}, {"title": "From SHIQ and RDF to OWL: The making of a web ontology language", "author": ["Ian Horrocks", "Peter F. Patel-Schneider", "Frank van Harmelen"], "venue": "Journal of Web Semantics,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2003}, {"title": "Proof theory for admissible rules", "author": ["Rosalie Iemhoff", "George Metcalfe"], "venue": "Annals of Pure and Applied Logic,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "Complexity of unification problems with associative-commutative operators", "author": ["Deepak Kapur", "Paliath Narendran"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1992}, {"title": "Non-Standard Inferences in Description Logics, volume 2100 of Lecture Notes in Computer Science, pages 153\u2013227", "author": ["Ralf K\u00fcsters"], "venue": null, "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2001}, {"title": "Admissibility of logical inference rules, volume 136 of Studies in Logic and the Foundations of Mathematics", "author": ["Vladimir V. Rybakov"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1997}, {"title": "Multi-modal and temporal logics with universal formula - reduction of admissibility to validity and unification", "author": ["Vladimir V. Rybakov"], "venue": "Journal of Logic and Computation,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2008}, {"title": "A correspondence theory for terminological logics: Preliminary report", "author": ["Klaus Schild"], "venue": "Proc. of the 12th Int. Joint Conf. on Artificial Intelligence", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1991}, {"title": "Undecidability of the unification and admissibility problems for modal and description logics", "author": ["Frank Wolter", "Michael Zakharyaschev"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2008}], "referenceMentions": [{"referenceID": 9, "context": "Description logics (DLs) [10] are a family of logic-based knowledge representation formalisms, which can be used to represent the conceptual knowledge of an application domain in a structured and formally well-understood way.", "startOffset": 25, "endOffset": 29}, {"referenceID": 25, "context": "They are employed in various application areas, but their most notable success so far is the adoption of the DL-based language OWL [26] as standard ontology language for the semantic web.", "startOffset": 131, "endOffset": 135}, {"referenceID": 17, "context": "C), and the top concept (\u22a4), has drawn considerable attention in the last decade since, on the one hand, important inference problems such as the subsumption problem are polynomial in EL, even with respect to expressive terminological axioms [18].", "startOffset": 242, "endOffset": 246}, {"referenceID": 10, "context": "For these reasons, the most recent OWL version, OWL2, contains the profile OWL2EL, which is based on a maximally tractable extension of EL [11].", "startOffset": 139, "endOffset": 143}, {"referenceID": 3, "context": "Unification in Description Logics was introduced in [4] as a novel inference service that can be used to detect redundancies in ontologies.", "startOffset": 52, "endOffset": 55}, {"referenceID": 0, "context": "In [1], we were able to show that unification in EL is of considerably lower complexity than unification in FL0: the decision problem for EL is NP-complete.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "for obtaining a more efficient unification algorithm is a translation to satisfiability in propositional logic (SAT): in [2] it is shown how a given EL-unification problem \u0393 can be translated in polynomial time into a propositional formula whose satisfying valuations correspond to the local unifiers of \u0393.", "startOffset": 121, "endOffset": 124}, {"referenceID": 12, "context": "In [13] we propose to restrict the attention to so-called minimal unifiers, which form a subset of all local unifiers.", "startOffset": 3, "endOffset": 7}, {"referenceID": 12, "context": "In addition, as shown in [13], computing minimal unifiers is actually harder than computing local unifiers (unless the polynomial hierarchy collapses).", "startOffset": 25, "endOffset": 29}, {"referenceID": 3, "context": "Unification and disunification in DLs is actually a special case of unification and disunification modulo equational theories (see [4] and [1] for the equational theories respectively corresponding to FL0 and EL).", "startOffset": 131, "endOffset": 134}, {"referenceID": 0, "context": "Unification and disunification in DLs is actually a special case of unification and disunification modulo equational theories (see [4] and [1] for the equational theories respectively corresponding to FL0 and EL).", "startOffset": 139, "endOffset": 142}, {"referenceID": 18, "context": ", been investigated in [19, 20].", "startOffset": 23, "endOffset": 31}, {"referenceID": 19, "context": ", been investigated in [19, 20].", "startOffset": 23, "endOffset": 31}, {"referenceID": 0, "context": "Unfortunately, for FL0 and EL, this approach is not feasible since the corresponding equational theories have unification type zero [1, 4],", "startOffset": 132, "endOffset": 138}, {"referenceID": 3, "context": "Unfortunately, for FL0 and EL, this approach is not feasible since the corresponding equational theories have unification type zero [1, 4],", "startOffset": 132, "endOffset": 138}, {"referenceID": 5, "context": "Nevertheless, it was shown in [6] that the approach used in [4] to decide unification (reduction to language equations, which are then solved using tree automata) can be adapted such that it can also deal with disunification.", "startOffset": 30, "endOffset": 33}, {"referenceID": 3, "context": "Nevertheless, it was shown in [6] that the approach used in [4] to decide unification (reduction to language equations, which are then solved using tree automata) can be adapted such that it can also deal with disunification.", "startOffset": 60, "endOffset": 63}, {"referenceID": 0, "context": "On the other hand, we develop two specialized algorithms to solve local disunification problems that extend the ones for unification [1, 2]: a goal-oriented algorithm that reduces the amount of nondeterministic guesses necessary to find a local solution, as well as a translation to SAT.", "startOffset": 133, "endOffset": 139}, {"referenceID": 1, "context": "On the other hand, we develop two specialized algorithms to solve local disunification problems that extend the ones for unification [1, 2]: a goal-oriented algorithm that reduces the amount of nondeterministic guesses necessary to find a local solution, as well as a translation to SAT.", "startOffset": 133, "endOffset": 139}, {"referenceID": 11, "context": "The reason we present two kinds of algorithms is that, in the case of unification, they have proved to complement each other well in first evaluations [12]: the goaloriented algorithm needs less memory and finds minimal solutions faster, while the SAT reduction generates larger data structures, but outperforms the goal-oriented algorithm on unsolvable problems.", "startOffset": 151, "endOffset": 155}, {"referenceID": 14, "context": "This is an extended version of the conference paper [15].", "startOffset": 52, "endOffset": 56}, {"referenceID": 8, "context": "Subsumption in EL is decidable in polynomial time [9] and can be checked by recursively comparing the top-level atoms of the two concept terms.", "startOffset": 50, "endOffset": 53}, {"referenceID": 0, "context": "Lemma 1 ([1]).", "startOffset": 9, "endOffset": 12}, {"referenceID": 19, "context": "We define a quite general notion of disunification problems that is similar to the equational formulae used in [20].", "startOffset": 111, "endOffset": 115}, {"referenceID": 18, "context": "In contrast to unification, in disunification it does make a difference whether or not solutions may contain variables from Nv\u2229\u03a3 or additional symbols from (NC\u222aNR)\\\u03a3 [19].", "startOffset": 166, "endOffset": 170}, {"referenceID": 0, "context": "This restriction is without loss of generality: to flatten concept terms, one can simply introduce new variables and equations to abbreviate subterms [1].", "startOffset": 150, "endOffset": 153}, {"referenceID": 0, "context": "For solving flat unification problems, it has been shown that it suffices to consider so-called local solutions [1], which are restricted to use only the atoms occurring in the input problem.", "startOffset": 112, "endOffset": 115}, {"referenceID": 0, "context": "The corresponding complexity lower bound follows from NP-hardness of (local) solvability of unification problems in EL [1].", "startOffset": 119, "endOffset": 122}, {"referenceID": 0, "context": "It has been shown that unification in EL is local in the sense that the equivalent flattened problem has a local solution iff the original problem is solvable, and hence (general) solvability of unification problems in EL can be decided in NP [1].", "startOffset": 243, "endOffset": 246}, {"referenceID": 0, "context": "We then provide two different NPalgorithms for the latter problem by extending the rule-based unification algorithm from [1] and adapting the SAT encoding of unification problems from [2].", "startOffset": 121, "endOffset": 124}, {"referenceID": 1, "context": "We then provide two different NPalgorithms for the latter problem by extending the rule-based unification algorithm from [1] and adapting the SAT encoding of unification problems from [2].", "startOffset": 184, "endOffset": 187}, {"referenceID": 2, "context": "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29].", "startOffset": 164, "endOffset": 174}, {"referenceID": 7, "context": "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29].", "startOffset": 164, "endOffset": 174}, {"referenceID": 28, "context": "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29].", "startOffset": 164, "endOffset": 174}, {"referenceID": 2, "context": "In particular, the matching problems for EL investigated in [3] are similar to our dismatching problems in that there subsumptions are restricted to ones where one side is ground.", "startOffset": 60, "endOffset": 63}, {"referenceID": 8, "context": "In particular, subsumptions between ground atoms can be checked in polynomial time [9].", "startOffset": 83, "endOffset": 86}, {"referenceID": 1, "context": "To obtain a local solution, we denote by At, Var, and Atnv the sets as defined in Section 3 and define the assignment S induced by \u03b3 as in [2]:", "startOffset": 139, "endOffset": 142}, {"referenceID": 1, "context": "It was shown in [2] that S is acyclic and the substitution \u03c3S solves all subsumptions in \u0393.", "startOffset": 16, "endOffset": 19}, {"referenceID": 0, "context": "1 and the NP-hardness of unification in EL [1], this shows the following complexity result.", "startOffset": 43, "endOffset": 46}, {"referenceID": 1, "context": "For details, see [2] or Sections 6.", "startOffset": 17, "endOffset": 20}, {"referenceID": 0, "context": "To solve the subsumptions, we reuse the rules of the goal-oriented algorithm for unification in EL [1, 14], which produces only local unifiers.", "startOffset": 99, "endOffset": 106}, {"referenceID": 13, "context": "To solve the subsumptions, we reuse the rules of the goal-oriented algorithm for unification in EL [1, 14], which produces only local unifiers.", "startOffset": 99, "endOffset": 106}, {"referenceID": 13, "context": "The rules dealing with subsumptions are essentially the same as in [14]; note that several of these may be applicable to the same subsumption.", "startOffset": 67, "endOffset": 71}, {"referenceID": 4, "context": "the multiset extension of >S [5].", "startOffset": 29, "endOffset": 32}, {"referenceID": 4, "context": "orders are again well-founded [5], \u227b is a well-founded strict partial order on \u0393\u0302.", "startOffset": 30, "endOffset": 33}, {"referenceID": 1, "context": "This reduction is a generalization of the one developed for unification problems in [2].", "startOffset": 84, "endOffset": 87}, {"referenceID": 1, "context": "The main difference to the encoding in [2] lies in the clauses (IV) that ensure the presence of a non-variable atom D that solves the dissubsumption C 6\u2291 X (cf.", "startOffset": 39, "endOffset": 42}, {"referenceID": 1, "context": "We show the following property of >S\u03c4 ; the proof is exactly the same as in [2], but uses a different notation.", "startOffset": 76, "endOffset": 79}, {"referenceID": 11, "context": "For example, a slightly modified version of the example from the introduction has 128 solutions without any dissubsumptions (see [12] for more details).", "startOffset": 129, "endOffset": 133}, {"referenceID": 31, "context": "Since Description Logics and Modal Logics are closely related [32], results on unification in one of these two areas carry over to the other one.", "startOffset": 62, "endOffset": 66}, {"referenceID": 23, "context": "In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31].", "startOffset": 105, "endOffset": 117}, {"referenceID": 24, "context": "In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31].", "startOffset": 105, "endOffset": 117}, {"referenceID": 30, "context": "In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31].", "startOffset": 105, "endOffset": 117}, {"referenceID": 32, "context": "It is only known that relatively minor extensions of K have an undecidable unification problem [33].", "startOffset": 95, "endOffset": 99}, {"referenceID": 15, "context": "Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30].", "startOffset": 140, "endOffset": 152}, {"referenceID": 26, "context": "Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30].", "startOffset": 140, "endOffset": 152}, {"referenceID": 29, "context": "Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30].", "startOffset": 140, "endOffset": 152}, {"referenceID": 18, "context": "As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19\u201321].", "startOffset": 139, "endOffset": 146}, {"referenceID": 19, "context": "As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19\u201321].", "startOffset": 139, "endOffset": 146}, {"referenceID": 20, "context": "As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19\u201321].", "startOffset": 139, "endOffset": 146}, {"referenceID": 0, "context": "As shown in [1], equivalence in EL can be axiomatized by the equational theory of semilattices with monotone functions, which extends the theory ACUI of an associative-commutativeidempotent binary function symbol \u2217 (corresponding to \u2293) with unit (corresponding to \u22a4) by unary function symbols hr (corresponding to \u2203r) that are monotone in the sense that they satisfy the identities hr(x) \u2217 hr(x \u2217 y) = hr(x \u2217 y).", "startOffset": 12, "endOffset": 15}, {"referenceID": 6, "context": "This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28].", "startOffset": 37, "endOffset": 44}, {"referenceID": 21, "context": "This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28].", "startOffset": 37, "endOffset": 44}, {"referenceID": 27, "context": "This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28].", "startOffset": 130, "endOffset": 134}, {"referenceID": 6, "context": "To be more precise, the NP upper bound is shown in [7] for the theory ACI with free function symbols, using general combination results for disunification developed in the same article.", "startOffset": 51, "endOffset": 54}, {"referenceID": 6, "context": "However, it is easy to see that the approach applied in [7] also", "startOffset": 56, "endOffset": 59}, {"referenceID": 21, "context": "In contrast, the NP upper bound in [22] is shown for ACUI with free function symbols by directly designing a dedicated algorithm for disunification in this theory.", "startOffset": 35, "endOffset": 39}, {"referenceID": 16, "context": "In addition, we will investigate whether a reduction to answer set programming (ASP) [17, 23] rather than SAT leads to a better performance.", "startOffset": 85, "endOffset": 93}, {"referenceID": 22, "context": "In addition, we will investigate whether a reduction to answer set programming (ASP) [17, 23] rather than SAT leads to a better performance.", "startOffset": 85, "endOffset": 93}], "year": 2017, "abstractText": "Unification in Description Logics has been introduced as a means to detect redundancies in ontologies. We try to extend the known decidability results for unification in the Description Logic EL to disunification since negative constraints can be used to avoid unwanted unifiers. While decidability of the solvability of general EL-disunification problems remains an open problem, we obtain NP-completeness results for two interesting special cases: dismatching problems, where one side of each negative constraint must be ground, and local solvability of disunification problems, where we consider only solutions that are constructed from terms occurring in the input problem. More precisely, we first show that dismatching can be reduced to local disunification, and then provide two complementary NP-algorithms for finding local solutions of disunification problems.", "creator": "LaTeX with hyperref package"}}}