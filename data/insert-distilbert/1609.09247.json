{"id": "1609.09247", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Sep-2016", "title": "Training Dependency Parsers with Partial Annotation", "abstract": "recently, these has been a surge boost on colleagues studying how to obtain partially annotated baseline data for model supervision. however, there still lacks a systematic study on how to train statistical models with partial output annotation ( pa ). taking dependency parsing as our case study, see this paper instead describes one and compares two straightforward approaches especially for three mainstream dependency parsers. the first approach is previously proposed to directly train a log - constrained linear graph - based parser ( llgpar ) with pa based on a forest - based objective. this work proposal for about the first time proposes as the second approach to directly training a linear graph - based parse ( ec lgpar ) and a linear transition - based parser ( cf ltpar ) with pa based on the idea of constrained decoding. we collectively conduct extensive experiments on penn treebank under three different settings for simulating pa, i. e., random dependencies, most uncertain dependencies, and independent dependencies with divergent outputs away from the three parsers. the following results show that simple llgpar computing is most effective in simply learning from pa and both ltpar lags behind the graph - based counterparts by large margin. moreover, lgpar and ltpar programs can achieve best performance predictions by using llgpar to complete pa into full annotation ( gs fa ).", "histories": [["v1", "Thu, 29 Sep 2016 08:12:14 GMT  (178kb)", "http://arxiv.org/abs/1609.09247v1", null]], "reviews": [], "SUBJECTS": "cs.CL cs.LG", "authors": ["zhenghua li", "yue zhang", "jiayuan chao", "min zhang"], "accepted": false, "id": "1609.09247"}, "pdf": {"name": "1609.09247.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Zhenghua Li", "Yue Zhang", "Jiayuan Chao", "Min Zhang"], "emails": ["zhli13@suda.edu.cn,", "minzhang@suda.edu.cn,", "zhangyue1107@qq.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 9.\n09 24\n7v 1\n[ cs\n.C L\n] 2\n9 Se\np 20\n16"}, {"heading": "1 Introduction", "text": "Traditional supervised approaches for structural classification assume full annotation (FA), meaning that the training instances have complete manually-labeled structures. In the case of dependency parsing, FA means a complete parse tree is provided for each training sentence. However, recent studies suggest that it is more economic and effective to construct labeled data with partial annotation (PA). A lot of research effort has been attracted to obtain partially-labeled data for different tasks via active learning (Sassano and Kurohashi, 2010; Mirroshandel and Nasr, 2011; Li et al., 2012; Marcheggiani and Artie\u0300res, 2014; Flannery and Mori, 2015; Li et al., 2016), cross-lingual syntax projection (Spreyer and Kuhn, 2009; Ganchev et al., 2009; Jiang et al., 2010; Li et al., 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al., 2013; Liu et al., 2014; Nivre et al., 2014; Yang and Vozila, 2014). Figure 1 gives an example sentence partially annotated with two dependencies.\nHowever, there still lacks systematic study on how to train structural models such as dependency parsers with PA. Most previous works listed above rely on ad-hoc strategies designed for only basic dependency parsers. One exception is that Li et al. (2014) convert partial trees into forests and train a log-linear graph-based dependency parser (LLGPar) with PA based on a forest-base objective, showing promising results. Meanwhile, it is still unclear how PAs can be used to train state-of-the-art linear graphbased (LGPar) and transition-based parser (LTPar). Please refer to Section 6 for detailed discussions of previous methods for training parsers with PA.\nThis paper aims to thoroughly study this issue and make systematic comparison on different approaches of training parsers with PA. In summary, we make the following contributions.\n\u2022 We present a general framework for directly training state-of-the-art LGPar and LTPar with PA based on constrained decoding. The basic idea is to use the current feature weights to parse the sentence under the PA-constrained search space, and use the best parse as a pseudo gold-standard\n\u2217Correspondence author\nreference for feature weight update during perceptron training. We also implement the forestobjective based approach of Li et al. (2014) for LLGPar.\n\u2022 We have made thorough comparison among different directly-train approaches under three different settings for simulating PA, i.e., random dependencies, most uncertain dependencies, and dependencies with divergent outputs from the three parsers. We have also compared the proposed directlytrain approaches with the straightforward complete-then-train approach.\n\u2022 Extensive experiments on Penn Treebank lead to several interesting and clear findings."}, {"heading": "2 Dependency Parsing", "text": "Given an input sentence x = w0w1...wn, dependency parsing builds a complete dependency tree d rooted at w0, where w0 is an artificial token linking to the root of the sentence (Ku\u0308bler et al., 2009). A dependency tree comprises a set of dependencies, namely d = {h y m : 0 \u2264 h \u2264 n, 1 \u2264 m \u2264 n}, where h y m is a dependency from a head word h to a modifier word m. A complete dependency tree contains n dependencies, namely |d| = n, whereas a partial dependency tree contains less than n dependencies, namely |d| < n. Alternatively, FA can be understood as a special form of PA. For clarity, we denote a complete tree as d and a partial tree as dp. The decoding procedure aims to find an optimal complete tree d\u2217:\nd\u2217 = arg max d\u2208Y(x) Score(x,d;w) Score(x,d;w) = w \u00b7 f(x,d) (1)\nwhere Y(x) defines the search space containing all legal trees for x; Score(x,d;w) is a score/probability of d; f(x,d) is a sparse accumulated feature vector corresponding to d; w is the feature weight vector."}, {"heading": "2.1 Graph-based Approach", "text": "To facilitate efficient search, the graph-based method factorizes the score of a dependency into those of small subtrees p:\nScore(x,d;w) = \u2211\np\u2286d\nScore(x,p;w) (2)\nDynamic programming based exact search are usually applied to find the optimal tree (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras, 2007; Koo and Collins, 2010). We adopt the second-order model of McDonald and Pereira (2006) which incorporates two kinds of subtrees, i.e., single dependencies and adjacent siblings, and the feature set described in Bohnet (2010).\nA log-linear graph-based parser (LLGPar) defines the conditional probability of d given x as\np(d|x;w) = eScore(x,d;w)\u2211\nd\u2032\u2208Y(x) e Score(x,d\u2032;w)\n(3)\nFor training, w is optimized using gradient descent to maximize the likelihood of the training data. A linear graph-based parser (LGPar) uses perceptron-like online training to directly learn w. The workflow is similar to Algorithm 1, except that the gold-standard reference d+ is directly provided in the training data without the need of constrained decoding in line 6. Previous work mostly adopts\nAlgorithm 1 Perceptron training based on constrained decoding. 1: Input: Partially labeled data D = {(xj ,d p j )} N j=1; Output: w; Initialization: w\n(0) = 0, k = 0 2: for i = 1 to I do // iterations 3: for (xj ,d p\nj ) \u2208 D do // traverse 4: d\u2212 = arg max\nd\u2208Y(xj) Score(xj ,d;w) // Unconstrained decoding: LGPar\n5: a\u2212 = arg max a\u2192d\u2208Y(xj) Score(xj ,a \u2192 d;w) // Unconstrained decoding: LTPar 6: d+ = arg max d\u2208Y(xj ,d p j ) Score(xj ,d;w) // Constrained decoding: LGPar 7: a+ = arg max a\u2192d\u2208Y(xj ,d p j ) Score(xj ,a \u2192 d;w) // Constrained decoding: LTPar 8: wk+1 = wk + f(x,d+)\u2212 f(x,d\u2212) // Update: LGPar 9: wk+1 = wk + f(x,a+)\u2212 f(x,a\u2212) // Update: LTPar\n10: k = k + 1 11: end for 12: end for\nlinear models to build dependency parsers since perceptron training is simple yet effective in achieving competitive parsing accuracy in variety of languages. Recently, LLGPar attracts more attention due to its capability in producing subtree probabilities and learning from PA (Li et al., 2014; Ma and Zhao, 2015)."}, {"heading": "2.2 Transition-based Approach", "text": "The transition-based method builds a dependency by applying sequence of shift/reduce actions a, and factorizes the score of a tree into the sum of scores of each action in a (Yamada and Matsumoto, 2003; Nivre, 2003; Zhang and Nivre, 2011):\nScore(x,d;w) = Score(x,a \u2192 d;w)\n= \u2211|a|\ni=1 Score(x, ci, ai;w)\n(4)\nwhere ai is the action taken at step i and ci is the configuration status after taking action a1...ai\u22121. State-of-the-art transition-based methods usually use inexact beam search to find a highest-scoring action sequence, and adopt global perceptron-like training to learn w. We build an arc-eager transition-based dependency parser and the state-of-the-art features described in (Zhang and Nivre, 2011), referred as a linear transition-based parser (LTPar)."}, {"heading": "3 Directly training parsers with PA", "text": "As described in Li et al. (2014), LLGPar can naturally learn from PA based on the idea of ambiguous labeling, which allows a sentence to have multiple parse trees (forest) as its gold-standard reference (Riezler et al., 2002; Dredze et al., 2009; Ta\u0308ckstro\u0308m et al., 2013). First, a partial tree dp is converted in to a forest by adding all possible dependencies pointing to remaining words without heads, with the constraint that a newly added dependency does not violate existing ones in dp. The forest can be formally defined as F(x,dp) = {d : d \u2208 Y(x),dp \u2286 d}, whose conditional probability is the sum of probabilities of all trees that it contains:\np(dp|x;w) = \u2211\nd\u2208F(x,dp)\np(d|x;w) (5)\nThen, we can define an forest-based training objective function to maximize the likelihood of training data as described in Li et al. (2014).\nLGPar can be extended to directly learn from PA based on the idea of constrained decoding, as shown in Algorithm 1, which has been previously applied to Chinese word segmentation with partially labeled sequences (Jiang et al., 2010). The idea is using the best tree d+ in the constrained search space Y(xj ,d p j ) (line 6) as a pseudo gold-standard reference for weight update. In traditional perceptron training, d+ would be a complete parse tree provided in the training data. It is trivial to implement constrained decoding for graph-based parsers, and we only need to disable some illegal combination operations during dynamic programming.\nLTPar can also directly learn from PA in a similar way, as shown in Algorithm 1. Constrained decoding is performed to find a pseudo gold-standard reference (line 7). It is more complicate to design constrained decoding for transition-based parsing than graph-based parsing. Fortunately, Nivre et al. (2014) propose a procedure to enable arc-eager parsers to decode in the search space constrained by some given dependencies. We ignore the details due to the space limitation."}, {"heading": "4 Experiments", "text": ""}, {"heading": "4.1 Data, parameter settings, and evaluation metric", "text": "We conduct experiments on Penn Treebank (PTB), and follow the standard data split data (sec 2-21 as training, sec 22 as development, and sec 23 as test). Original bracketed structures are converted into dependency structures using Penn2Malt with default head-finding rules. We build a CRF-based bigram part-of-speech (POS) tagger to produce automatic POS tags for all train/dev/test data (10-way jackknifing on training data), with tagging accuracy 97.3% on test data. As suggested by an earlier anonymous reviewer, we further split the training data into two parts. We assume that the first 1K training sentences are provided as a small-scale data with FA, which can be obtained by a small amount of manual annotation or through cross-lingual projection methods. We simulate PA for the remaining 39K sentences. Table 1 shows the data statistics.\nWe train LLGPar with stochastic gradient descent (Finkel et al., 2008). We set the beam size to 64 during both training and evaluation of LTPar. Following standard practice established by Collins (2002), we adopt averaged weights for evaluation of LGPar and LTPar and use the early-update strategy during training LTPar.\nSince we have two sets of training data, we adopt the simple corpus-weighting strategy of Li et al. (2014). In each iteration, we merge train-1K and a subset of random 10K sentences from train-39K , shuffle them, and then use them for training. For all parsers, training terminates when the peak parsing accuracy on dev data does not improve in 30 consecutive iterations. For evaluation, we use the standard unlabeled attachment score (UAS) excluding punctuation marks.\n4.2 Three settings for simulating PA on train-39K\nIn order to simulating PA for each sentence in train-39K , we only keep \u03b1% gold-standard dependencies (not considering punctuation marks), and remove all other dependencies. We experiment with three simulation settings to fully investigate the capability of different approaches in learning from PA.\nRandom (30% or 15%): For each sentence in train-39K , we randomly select \u03b1% words, and only keep dependencies linking to these words. With this setting, we aim to purely study the issue without biasing to certain structures. This setting may be best fit the scenario automatic syntax projection based on bitext, where the projected dependencies tend to be arbitrary (and noisy) due to the errors in automatic source-language parses and word alignments and non-isomorphism syntax between languages.\nUncertain (30% or 15%): In their work of active learning with PA, Li et al. (2016) show that the marginal probabilities from LLGPar is the most effective uncertainty measurement for selecting the most informative words to be annotated. Following their work, we first train LLGPar on train-1K with FA, and then use LLGPar to parse train-39K and select \u03b1% most uncertain words to keep their heads.\nFollowing Li et al. (2016), we measure the uncertainty of a word wi according to the marginal probability gap between its two most likely heads h0i and h 1 i .\nUncertainty(x, i) = p(h0i y i|x)\u2212 p(h 1 i y i|x) (6)\n.\nThe intuition is that the smaller the probability gap is, the more uncertain the model is about wi. The marginal probability of a dependency is the sum of probabilities of all legal trees that contain the dependency.\np(h y m|x) = \u2211\nd\u2208Y(x):hym\u2208d\np(d|x) (7)\nThis setting fits the scenario of active learning, which aims to save annotation effort by only annotating the most useful structures. From another perspective, this settings may tend to bias to LLGPar by keeping structures that are most useful for LLGPar.\nDivergence (13.68%): We train all three parsers on train-1K , and use them to parse train-39K . If their output trees do not assign the same head to a word, then we keep the gold-standard dependency pointing to the word, leading to 13.68% remaining dependencies. Different from the uncertain setting, this setting does not bias to any parser."}, {"heading": "4.3 Results of different parsers trained on FA", "text": "We train the three parsers on all the training data with FA. We also employ four publicly available parsers with their default settings. BerkeleyParser (v1.7) is a constituent-structure parser, whose results are converted into dependency structures (Petrov and Klein, 2007). TurboParser (v2.1.0) is a linear graph-based dependency parser using linear programming for inference (Martins et al., 2013). Mate-tool (v3.3) is a linear graph-based dependency parser very similar to our implemented LGPar (Bohnet, 2010). ZPar (v0.6) is a linear transition-based dependency parser very similar to our implemented LGPar (Zhang and Clark, 2011). The results are shown in Table 2. We can see that the three parsers that we implement achieve competitive parsing accuracy and serve as strong baselines."}, {"heading": "4.4 Results of the directly-train approaches", "text": "The three parsers are directly trained on train-1K with FA and train-39K with PA based on the methods described in Section 3. Table 3 shows the results.\nComparing the three parsers, we have several clear findings. (1) LLGPar achieves best performance over all settings and is very effective in learning from PA. (2) The accuracy gap between LGPar and LLGPar becomes larger with PA than with FA, indicating LGPar is less effective in learning from PA than LLGPar. (3) LTPar lags behind LLGPar by large margin and is ineffective in learning from PA.\nFA (random) vs. PA (random): from the results in the two major columns, we can see that LLGPar achieves higher accuracy by about 0.5% when trained on sentences with \u03b1% random dependencies than when trained on \u03b1% random sentences with FA. This is reasonable and can be explained under the assumption that LLGPar can make full use of PA in model training. In fact, in both cases, the training\ndata contains approximately the same number of annotated dependencies. However, from the perspective of model training, given some dependencies in the case of PA, more information about the syntactic structure can be derived.1 Taking Figure 1 as an example, \u201cI1\u201d can only modify \u201csaw2\u201d due to the singleroot and single-head constraints; similarly, \u201cSarah3\u201d can only modify either \u201csaw2\u201d or \u201cwith2\u201d; and so on. Therefore, given the same amount of annotated dependencies, random PA contains more syntactic information than random FA, which explains why LLGPar performs better with PA than FA.\nIn contrast, both LGPar and LTPar achieve slight lower accuracy with PA than with FA. This is another evidence that LGPar and LTPar is less effective than LLGPar in learning from PA.\nPA (random) vs. PA (uncertain): we can see that all three parser achieves much higher accuracy in the latter case.2 The annotated dependencies in PA (uncertain) are most uncertain ones for current statistical parser (i.e., LLGPar), and thus are more helpful for training the models than those in PA (random). Another phenomenon is that, in the case of PA (uncertain), increasing \u03b1% = 15% to 30% actually doubles the number of annotated dependencies, but only boost accuracy of LLGPar by 93.02 \u2212 92.44 = 0.58%, which indicates that newly added 15% dependencies are much less useful since the model can already well handle these low-uncertainty dependencies.\nPA (uncertain, 15%) vs. PA (divergence): we can see that the all three parsers achieve similar parsing accuracies. This indicates that uncertainty measurement based on LLGPar can actually discovers useful dependencies to be annotated without particularly biasing towards itself.\nIn summary, we can conclude from the results that LLGPar can effectively learn from PA, whereas LGPar is slightly less effective and LTPar is ineffective at all."}, {"heading": "4.5 Results of the complete-then-train methods", "text": "The most straight-forward method for learning from PA is the complete-then-learn method (Mirroshandel and Nasr, 2011). The idea is first using an existing parser to complete partial trees in train-39K into full trees based on constrained decoding, and then training the target parser on train-1K with FA and train-39K with completed FA.\nResults of completing via constrained decoding: Table 4 reports UAS of the completed trees on train-39K using two different strategies for completion. \u201cNo constraints (0%)\u201d means that train-39K has no annotated dependencies and normal decoding without constraints is used. In the remaining columns, each parser performs constrained decoding on PA where \u03b1% dependencies are provided in each sentence.\n\u2022 Coarsely-trained-self for completion: We complete PA into FA using corresponding parsers coarsely trained on only train-1K with FA. We call these parsers LLGPar-1K , LLTPar-1K , LTPar1K respectively.\n\u2022 Fine-trained-LLGPar for completion: We complete PA into FA using LLGPar fine trained on both train-1K with FA and train-39K with PA. We call this LLGPar as LLGPar-1K+39K . Please note that LLGPar-1K+39K actually performs closed test in this setting, meaning that it parses its\n1Also, as suggested in the work of Li et al. (2016), annotating PA is more time-consuming than annotating FA in terms of averaged time for each dependency, since dependencies in the same sentence are correlated and earlier annotated dependencies usually make later annotation easier.\n2The only exception is LTPar with 30% PA, the accuracy increases by only 91.35\u2212 91.12 = 0.23%, which may be caused by the ineffectiveness of LTPar in learning from PA.\ntraining data. For example, LLGPar-1K+39K trained on random (30%) is employed to complete the same data by filling the remaining 70% dependencies.\nComparing the three parsers trained on train-1K , we can see that constrained decoding has similar effects on all three parsers, and is able to return much more accurate trees. Numbers in parenthesis show the accuracy gap between normal (0%) and constrained decoding. This suggests that constrained decoding itself is not responsible for the ineffectiveness of Algorithm 1 for LTPar.\nComparing the results of LLGPar-1K and LLGPar-1K+39K (numbers in parenthesis showing the accuracy gap), it is obvious that the latter produces much better full trees since the fine-trained LLGPar can make extra use of PA in train-39K during training.\nResults of training on completed FA: Table 5 compares performance of the three parsers trained on train-1K with FA and train-39K with completed FA, from which we can draw several clear and interesting findings. First, different from the case of directly training on PA, the three parsers achieve very similar parsing accuracies when trained on data with completed FA in both completion settings. Second, using parsers coarsely-trained on train-1K for completion leads to very bad performance, which is even much worse than those of the directly-train method in Table 3 except for LTPar with uncertain (30%). Third, using the fine-trained LLGPar-1K+39K for completion makes LGPar and LTPar achieve nearly the same accuracies with LLGPar, which may be because LLGPar provides complementary effects during completion, analogous to the scenario of co-training."}, {"heading": "4.6 Results on test data: directly-train vs. complete-then-train", "text": "Table 6 reports UAS on test data of parsers directly trained on train-1K with FA and train-39K with PA, and of those trained on train-1K with FA and train-39K with FA completed by fine-trained LLGPar1K+39K . The results are consistent with the those on dev data in Table 3 and 5. Comparing the two settings, we can draw two interesting findings. First, LLGPar performs slightly better with the directlytrain method. Second, LGPar performs slightly better with the complete-then-train method in most cases except for uncertain (30%). Third, LTPar performs much better with the complete-then-train method."}, {"heading": "5 Failed attempts to enhancing LTPar", "text": "All experimental results in the previous section suggest that LTPar is ineffective in learning from PA, and Table 4 indicates that constrained decoding itself works well for LTPar. In contrast, LGPar is also based on constrained decoding and works much better than LTPar. The most important difference is that in line 4-7 of Algorithm 1, LGPar uses dynamic programming based exact search algorithm to find the highest-scoring tree according to the current model, whereas LTPar use approximate beam search\nalgorithm. The approximate search procedure may cause the optimal tree drops off the beam too soon and thus the returned a+ may cause the model be updated to bias to certain wrong structures, which cannot be further covered due to the lack of sufficient supervision in the scenario of PA.\nWe have tried three strategies to enhance LTPar so far though little progress has been made. First, we set the beam size to 32/64/128/256, and hope LTPar may learn better from PA with larger beam. Second, as suggested by an earlier anonymous reviewer, we use k-best a+ and a\u2212 instead of the 1-best outputs for feature weight update. We try to use the averaged feature vector of k-best a+ and/or k-best a\u2212 in line 9. Third, we also try a conservative update strategy. The idea is that first we obtain a\u2212 (corresponding to a tree d\u2212) in line 5. Then, for each dependency in d\u2212 that is compatible with those in the partial tree dpj , we temporarily insert it into d p j . We use the enlarged d p j in line 7. In this way, the returned d+ is more similar to d\u2212 so that less risk is taken during model update. So far, the results for all three strategies are negative. However, we will keep looking into this issue in future. We will give more detailed descriptions and results upon publication with extra space."}, {"heading": "6 Related work", "text": "In parsing community, most previous works adopt ad-hoc methods to learn from PA. Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree.\nMirroshandel and Nasr (2011) and Majidi and Crane (2013) adopt the complete-then-learn method. They use parsers coarsely trained on existing data with FA for completion via constrained decoding. However, our experiments show that this leads to dramatic decrease in parsing accuracy.\nNivre et al. (2014) present a constrained decoding procedure for arc-eager transition-based parsers. However, their work focuses on allowing their parser to effectively exploit external constraints during the evaluation phase. In this work, we directly employ their method and show that constrained decoding is effective for LTPar and thus irresponsible for its ineffectiveness in learning PA.\nDirectly learning from PA based on constrained decoding is previously proposed by Jiang et al. (2013) for Chinese word segmentation, which is treated as a character-level sequence labeling problem. In this work, we first apply the idea to LGPar and LTPar for directly learning from PA.\nDirectly learning from PA based on a forest-based objective in LLGPar is first proposed by Li et al. (2014), inspired by the idea of ambiguous labeling. Similar ideas have been extensively explored recently in sequence labeling tasks (Liu et al., 2014; Yang and Vozila, 2014; Marcheggiani and Artie\u0300res, 2014).\nHwa (1999) pioneers the idea of exploring PA for constituent grammar induction based on a variant Inside-Outside re-estimation algorithm (Pereira and Schabes, 1992). Clark and Curran (2006) propose to train a Combinatorial Categorial Grammar parser using partially labeled data only containing predicateargument dependencies. Mielens et al. (2015) propose to impute missing dependencies based on Gibbs sampling in order to enable traditional parsers to learn from partial trees."}, {"heading": "7 Conclusions", "text": "This paper investigates the problem of training dependency parsers on partially labeled data. Particularly, we focus on the realistic scenario where we have a small-scale training dataset with FA and a largescale training dataset with PA. We experiment with three settings for simulating PA. We compare several directly-train and complete-then-train approaches with three mainstream parsers, i.e., LLGPar, LGPar, and LTPar. Finally, we draw the following important conclusions. (1) For the complete-thentrain approach, using parsers coarsely trained on small-scale data with FA for completion leads to unsatisfactory results. (2) LLGPar is able to make full use of PA for training. In contrast, LGPar is slightly inferior and LTPar performs badly in learning from PA. (3) The complete-then-train approach can make LGPar and LTPar on par with LLGPar in terms of parsing accuracy if using LLGPar fine trained on all data with both FA and PA for completion.\nFor future, we will further investigate the reason behind the ineffectiveness of LTPar in learning from PA, and try to propose effective strategies to solve the issue. Our next plan is to employ the dynamic programming-enhanced beam search by merging equivalent states proposed by Huang and Sagae (2010), which allows the parser to explore larger search space during decoding. Moreover, we also plan to consider more constraints beyond dependencies. For example, Nivre et al. (2014) propose a constrained decoding procedure which can also incorporate bracketing constraints, i.e., a certain span forming a single-root subtree, which would be interesting yet challenging for graph-based parsers due to the complexity of designing dynamic programming based algorithms."}, {"heading": "Acknowledgments", "text": "The authors would like to thank the anonymous reviewers for the helpful comments."}], "references": [{"title": "Top accuracy and fast dependency parsing is not a contradiction", "author": ["Bernd Bohnet"], "venue": "In Proceedings of COLING,", "citeRegEx": "Bohnet.,? \\Q2010\\E", "shortCiteRegEx": "Bohnet.", "year": 2010}, {"title": "Experiments with a higher-order projective dependency parser", "author": ["Xavier Carreras"], "venue": "In Proceedings of EMNLP/CoNLL,", "citeRegEx": "Carreras.,? \\Q2007\\E", "shortCiteRegEx": "Carreras.", "year": 2007}, {"title": "Partial training for a lexicalized-grammar parser", "author": ["Clark", "Curran2006] Stephen Clark", "James Curran"], "venue": "In Proceedings of the Human Language Technology Conference of the NAACL,", "citeRegEx": "Clark et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Clark et al\\.", "year": 2006}, {"title": "Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms", "author": ["Michael Collins"], "venue": "In Proceedings of EMNLP", "citeRegEx": "Collins.,? \\Q2002\\E", "shortCiteRegEx": "Collins.", "year": 2002}, {"title": "Sequence learning from data with multiple labels", "author": ["Dredze et al.2009] Mark Dredze", "Partha Pratim Talukdar", "Koby Crammer"], "venue": "In ECML/PKDD Workshop on Learning from Multi-Label Data", "citeRegEx": "Dredze et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Dredze et al\\.", "year": 2009}, {"title": "Efficient, feature-based, conditional random field parsing", "author": ["Alex Kleeman", "Christopher D. Manning"], "venue": "In Proceedings of ACL,", "citeRegEx": "Finkel et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Finkel et al\\.", "year": 2008}, {"title": "Combining active learning and partial annotation for domain adaptation of a japanese dependency parser", "author": ["Flannery", "Mori2015] Daniel Flannery", "Shinsuke Mori"], "venue": "In Proceedings of the 14th International Conference on Parsing Technologies,", "citeRegEx": "Flannery et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Flannery et al\\.", "year": 2015}, {"title": "Dependency grammar induction via bitext projection constraints", "author": ["Jennifer Gillenwater", "Ben Taskar"], "venue": "In Proceedings of ACL-IJCNLP", "citeRegEx": "Ganchev et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Ganchev et al\\.", "year": 2009}, {"title": "Dynamic programming for linear-time incremental parsing", "author": ["Huang", "Sagae2010] Liang Huang", "Kenji Sagae"], "venue": "In Proceedings of ACL", "citeRegEx": "Huang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2010}, {"title": "Supervised grammar induction using training data with limited constituent information", "author": ["Rebecca Hwa"], "venue": "In Proceedings of ACL,", "citeRegEx": "Hwa.,? \\Q1999\\E", "shortCiteRegEx": "Hwa.", "year": 1999}, {"title": "Dependency parsing and projection based on word-pair classification", "author": ["Jiang et al.2010] Wenbin Jiang", "Qun Liu"], "venue": "In ACL,", "citeRegEx": "Jiang and Liu.,? \\Q2010\\E", "shortCiteRegEx": "Jiang and Liu.", "year": 2010}, {"title": "Discriminative learning with natural annotations: Word segmentation as a case study", "author": ["Jiang et al.2013] Wenbin Jiang", "Meng Sun", "Yajuan L\u00fc", "Yating Yang", "Qun Liu"], "venue": "In Proceedings of ACL,", "citeRegEx": "Jiang et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Jiang et al\\.", "year": 2013}, {"title": "Efficient third-order dependency parsers", "author": ["Koo", "Collins2010] Terry Koo", "Michael Collins"], "venue": "In ACL,", "citeRegEx": "Koo et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Koo et al\\.", "year": 2010}, {"title": "Dependency Parsing (Synthesis Lectures On Human Language Technologies)", "author": ["K\u00fcbler et al.2009] Sandra K\u00fcbler", "Ryan McDonald", "Joakim Nivre"], "venue": null, "citeRegEx": "K\u00fcbler et al\\.,? \\Q2009\\E", "shortCiteRegEx": "K\u00fcbler et al\\.", "year": 2009}, {"title": "Active learning for Chinese word segmentation", "author": ["Li et al.2012] Shoushan Li", "Guodong Zhou", "Chu-Ren Huang"], "venue": "In Proceedings of COLING 2012: Posters,", "citeRegEx": "Li et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Li et al\\.", "year": 2012}, {"title": "Soft cross-lingual syntax projection for dependency parsing", "author": ["Li et al.2014] Zhenghua Li", "Min Zhang", "Wenliang Chen"], "venue": "In COLING,", "citeRegEx": "Li et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Li et al\\.", "year": 2014}, {"title": "Active learning for dependency parsing with partial annotation", "author": ["Li et al.2016] Zhenghua Li", "Min Zhang", "Yue Zhang", "Zhanyi Liu", "Wenliang Chen", "Hua Wu", "Haifeng Wang"], "venue": null, "citeRegEx": "Li et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Li et al\\.", "year": 2016}, {"title": "Domain adaptation for CRFbased Chinese word segmentation using free annotations", "author": ["Liu et al.2014] Yijia Liu", "Yue Zhang", "Wanxiang Che", "Ting Liu", "Fan Wu"], "venue": "In Proceedings of EMNLP,", "citeRegEx": "Liu et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2014}, {"title": "Probabilistic models for high-order projective dependency parsing", "author": ["Ma", "Zhao2015] Xuezhe Ma", "Hai Zhao"], "venue": "In arXiv:1502.04174,", "citeRegEx": "Ma et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2015}, {"title": "Active learning for dependency parsing by a committee of parsers", "author": ["Majidi", "Crane2013] Saeed Majidi", "Gregory Crane"], "venue": "In Proceedings of IWPT,", "citeRegEx": "Majidi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Majidi et al\\.", "year": 2013}, {"title": "An experimental comparison of active learning strategies for partially labeled sequences", "author": ["Marcheggiani", "Arti\u00e8res2014] Diego Marcheggiani", "Thierry Arti\u00e8res"], "venue": "In Proceedings of EMNLP,", "citeRegEx": "Marcheggiani et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Marcheggiani et al\\.", "year": 2014}, {"title": "Turning on the turbo: Fast thirdorder non-projective turbo parsers", "author": ["Miguel Almeida", "Noah A. Smith"], "venue": "In Proceedings of ACL,", "citeRegEx": "Martins et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Martins et al\\.", "year": 2013}, {"title": "Online learning of approximate dependency parsing algorithms", "author": ["McDonald", "Pereira2006] Ryan McDonald", "Fernando Pereira"], "venue": "In Proceedings of EACL,", "citeRegEx": "McDonald et al\\.,? \\Q2006\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2006}, {"title": "Online large-margin training of dependency parsers", "author": ["Koby Crammer", "Fernando Pereira"], "venue": "In Proceedings of ACL,", "citeRegEx": "McDonald et al\\.,? \\Q2005\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2005}, {"title": "Parse imputation for dependency annotations", "author": ["Liang Sun", "Jason Baldridge"], "venue": "In Proceedings of ACL-IJCNLP,", "citeRegEx": "Mielens et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mielens et al\\.", "year": 2015}, {"title": "Active learning for dependency parsing using partially annotated sentences", "author": ["Mirroshandel", "Alexis Nasr"], "venue": "In Proceedings of the 12th International Conference on Parsing Technologies,", "citeRegEx": "Mirroshandel et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Mirroshandel et al\\.", "year": 2011}, {"title": "Constrained arc-eager dependency parsing", "author": ["Nivre et al.2014] Joakim Nivre", "Yoav Goldberg", "Ryan McDonald"], "venue": "In Computational Linguistics,", "citeRegEx": "Nivre et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Nivre et al\\.", "year": 2014}, {"title": "An efficient algorithm for projective dependency parsing", "author": ["Joakim Nivre"], "venue": "In Proceedings of IWPT,", "citeRegEx": "Nivre.,? \\Q2003\\E", "shortCiteRegEx": "Nivre.", "year": 2003}, {"title": "Inside-outside reestimation from partially bracketed corpora", "author": ["Pereira", "Schabes1992] Fernando Pereira", "Yves Schabes"], "venue": "In Proceedings of the Workshop on Speech and Natural Language (HLT),", "citeRegEx": "Pereira et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Pereira et al\\.", "year": 1992}, {"title": "Improved inference for unlexicalized parsing", "author": ["Petrov", "Klein2007] Slav Petrov", "Dan Klein"], "venue": "In Proceedings of NAACL", "citeRegEx": "Petrov et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Petrov et al\\.", "year": 2007}, {"title": "Parsing the wall street journal using a lexical-functional grammar and discriminative estimation techniques", "author": ["Tracy H. King", "Ronald M. Kaplan", "Richard Crouch", "John T. III Maxwell", "Mark Johnson"], "venue": "Proceedings of ACL,", "citeRegEx": "Riezler et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Riezler et al\\.", "year": 2002}, {"title": "Using smaller constituents rather than sentences in active learning for japanese dependency parsing", "author": ["Sassano", "Kurohashi2010] Manabu Sassano", "Sadao Kurohashi"], "venue": "In Proceedings of ACL,", "citeRegEx": "Sassano et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Sassano et al\\.", "year": 2010}, {"title": "Data-driven dependency parsing of new languages using incomplete and noisy training data", "author": ["Spreyer", "Kuhn2009] Kathrin Spreyer", "Jonas Kuhn"], "venue": "In CoNLL,", "citeRegEx": "Spreyer et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Spreyer et al\\.", "year": 2009}, {"title": "Target language adaptation of discriminative transfer parsers", "author": ["Ryan McDonald", "Joakim Nivre"], "venue": "In Proceedings of NAACL,", "citeRegEx": "T\u00e4ckstr\u00f6m et al\\.,? \\Q2013\\E", "shortCiteRegEx": "T\u00e4ckstr\u00f6m et al\\.", "year": 2013}, {"title": "Statistical dependency analysis with support vector machines", "author": ["Yamada", "Matsumoto2003] Hiroyasu Yamada", "Yuji Matsumoto"], "venue": "In Proceedings of IWPT,", "citeRegEx": "Yamada et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Yamada et al\\.", "year": 2003}, {"title": "Semi-supervised Chinese word segmentation using partial-label learning with conditional random fields", "author": ["Yang", "Vozila2014] Fan Yang", "Paul Vozila"], "venue": "In Proceedings of EMNLP,", "citeRegEx": "Yang et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Yang et al\\.", "year": 2014}, {"title": "Syntactic processing using the generalized perceptron and beam search", "author": ["Zhang", "Clark2011] Yue Zhang", "Stephen Clark"], "venue": "Computational Linguistics,", "citeRegEx": "Zhang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2011}, {"title": "Transition-based dependency parsing with rich nonlocal features", "author": ["Zhang", "Nivre2011] Yue Zhang", "Joakim Nivre"], "venue": "In Proceedings of ACL,", "citeRegEx": "Zhang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 14, "context": "A lot of research effort has been attracted to obtain partially-labeled data for different tasks via active learning (Sassano and Kurohashi, 2010; Mirroshandel and Nasr, 2011; Li et al., 2012; Marcheggiani and Arti\u00e8res, 2014; Flannery and Mori, 2015; Li et al., 2016), cross-lingual syntax projection (Spreyer and Kuhn, 2009; Ganchev et al.", "startOffset": 117, "endOffset": 267}, {"referenceID": 16, "context": "A lot of research effort has been attracted to obtain partially-labeled data for different tasks via active learning (Sassano and Kurohashi, 2010; Mirroshandel and Nasr, 2011; Li et al., 2012; Marcheggiani and Arti\u00e8res, 2014; Flannery and Mori, 2015; Li et al., 2016), cross-lingual syntax projection (Spreyer and Kuhn, 2009; Ganchev et al.", "startOffset": 117, "endOffset": 267}, {"referenceID": 7, "context": ", 2016), cross-lingual syntax projection (Spreyer and Kuhn, 2009; Ganchev et al., 2009; Jiang et al., 2010; Li et al., 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al.", "startOffset": 41, "endOffset": 124}, {"referenceID": 15, "context": ", 2016), cross-lingual syntax projection (Spreyer and Kuhn, 2009; Ganchev et al., 2009; Jiang et al., 2010; Li et al., 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al.", "startOffset": 41, "endOffset": 124}, {"referenceID": 11, "context": ", 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al., 2013; Liu et al., 2014; Nivre et al., 2014; Yang and Vozila, 2014).", "startOffset": 70, "endOffset": 151}, {"referenceID": 17, "context": ", 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al., 2013; Liu et al., 2014; Nivre et al., 2014; Yang and Vozila, 2014).", "startOffset": 70, "endOffset": 151}, {"referenceID": 26, "context": ", 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al., 2013; Liu et al., 2014; Nivre et al., 2014; Yang and Vozila, 2014).", "startOffset": 70, "endOffset": 151}, {"referenceID": 7, "context": ", 2016), cross-lingual syntax projection (Spreyer and Kuhn, 2009; Ganchev et al., 2009; Jiang et al., 2010; Li et al., 2014), or mining natural annotation implicitly encoded in web pages (Jiang et al., 2013; Liu et al., 2014; Nivre et al., 2014; Yang and Vozila, 2014). Figure 1 gives an example sentence partially annotated with two dependencies. However, there still lacks systematic study on how to train structural models such as dependency parsers with PA. Most previous works listed above rely on ad-hoc strategies designed for only basic dependency parsers. One exception is that Li et al. (2014) convert partial trees into forests and train a log-linear graph-based dependency parser (LLGPar) with PA based on a forest-base objective, showing promising results.", "startOffset": 66, "endOffset": 604}, {"referenceID": 14, "context": "We also implement the forestobjective based approach of Li et al. (2014) for LLGPar.", "startOffset": 56, "endOffset": 73}, {"referenceID": 13, "context": "wn, dependency parsing builds a complete dependency tree d rooted at w0, where w0 is an artificial token linking to the root of the sentence (K\u00fcbler et al., 2009).", "startOffset": 141, "endOffset": 162}, {"referenceID": 23, "context": "Dynamic programming based exact search are usually applied to find the optimal tree (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras, 2007; Koo and Collins, 2010).", "startOffset": 84, "endOffset": 174}, {"referenceID": 1, "context": "Dynamic programming based exact search are usually applied to find the optimal tree (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras, 2007; Koo and Collins, 2010).", "startOffset": 84, "endOffset": 174}, {"referenceID": 0, "context": ", 2005; McDonald and Pereira, 2006; Carreras, 2007; Koo and Collins, 2010). We adopt the second-order model of McDonald and Pereira (2006) which incorporates two kinds of subtrees, i.", "startOffset": 36, "endOffset": 139}, {"referenceID": 0, "context": ", single dependencies and adjacent siblings, and the feature set described in Bohnet (2010). A log-linear graph-based parser (LLGPar) defines the conditional probability of d given x as", "startOffset": 78, "endOffset": 92}, {"referenceID": 15, "context": "Recently, LLGPar attracts more attention due to its capability in producing subtree probabilities and learning from PA (Li et al., 2014; Ma and Zhao, 2015).", "startOffset": 119, "endOffset": 155}, {"referenceID": 27, "context": "2 Transition-based Approach The transition-based method builds a dependency by applying sequence of shift/reduce actions a, and factorizes the score of a tree into the sum of scores of each action in a (Yamada and Matsumoto, 2003; Nivre, 2003; Zhang and Nivre, 2011):", "startOffset": 202, "endOffset": 266}, {"referenceID": 30, "context": "(2014), LLGPar can naturally learn from PA based on the idea of ambiguous labeling, which allows a sentence to have multiple parse trees (forest) as its gold-standard reference (Riezler et al., 2002; Dredze et al., 2009; T\u00e4ckstr\u00f6m et al., 2013).", "startOffset": 177, "endOffset": 244}, {"referenceID": 4, "context": "(2014), LLGPar can naturally learn from PA based on the idea of ambiguous labeling, which allows a sentence to have multiple parse trees (forest) as its gold-standard reference (Riezler et al., 2002; Dredze et al., 2009; T\u00e4ckstr\u00f6m et al., 2013).", "startOffset": 177, "endOffset": 244}, {"referenceID": 33, "context": "(2014), LLGPar can naturally learn from PA based on the idea of ambiguous labeling, which allows a sentence to have multiple parse trees (forest) as its gold-standard reference (Riezler et al., 2002; Dredze et al., 2009; T\u00e4ckstr\u00f6m et al., 2013).", "startOffset": 177, "endOffset": 244}, {"referenceID": 13, "context": "3 Directly training parsers with PA As described in Li et al. (2014), LLGPar can naturally learn from PA based on the idea of ambiguous labeling, which allows a sentence to have multiple parse trees (forest) as its gold-standard reference (Riezler et al.", "startOffset": 52, "endOffset": 69}, {"referenceID": 13, "context": "Then, we can define an forest-based training objective function to maximize the likelihood of training data as described in Li et al. (2014). LGPar can be extended to directly learn from PA based on the idea of constrained decoding, as shown in Algorithm 1, which has been previously applied to Chinese word segmentation with partially labeled sequences (Jiang et al.", "startOffset": 124, "endOffset": 141}, {"referenceID": 26, "context": "Fortunately, Nivre et al. (2014) propose a procedure to enable arc-eager parsers to decode in the search space constrained by some given dependencies.", "startOffset": 13, "endOffset": 33}, {"referenceID": 5, "context": "We train LLGPar with stochastic gradient descent (Finkel et al., 2008).", "startOffset": 49, "endOffset": 70}, {"referenceID": 3, "context": "Following standard practice established by Collins (2002), we adopt averaged weights for evaluation of LGPar and LTPar and use the early-update strategy during training LTPar.", "startOffset": 43, "endOffset": 58}, {"referenceID": 3, "context": "Following standard practice established by Collins (2002), we adopt averaged weights for evaluation of LGPar and LTPar and use the early-update strategy during training LTPar. Since we have two sets of training data, we adopt the simple corpus-weighting strategy of Li et al. (2014). In each iteration, we merge train-1K and a subset of random 10K sentences from train-39K , shuffle them, and then use them for training.", "startOffset": 43, "endOffset": 283}, {"referenceID": 14, "context": "Uncertain (30% or 15%): In their work of active learning with PA, Li et al. (2016) show that the marginal probabilities from LLGPar is the most effective uncertainty measurement for selecting the most informative words to be annotated.", "startOffset": 66, "endOffset": 83}, {"referenceID": 14, "context": "Uncertain (30% or 15%): In their work of active learning with PA, Li et al. (2016) show that the marginal probabilities from LLGPar is the most effective uncertainty measurement for selecting the most informative words to be annotated. Following their work, we first train LLGPar on train-1K with FA, and then use LLGPar to parse train-39K and select \u03b1% most uncertain words to keep their heads. Following Li et al. (2016), we measure the uncertainty of a word wi according to the marginal probability gap between its two most likely heads hi and h 1 i .", "startOffset": 66, "endOffset": 423}, {"referenceID": 21, "context": "0) is a linear graph-based dependency parser using linear programming for inference (Martins et al., 2013).", "startOffset": 84, "endOffset": 106}, {"referenceID": 0, "context": "3) is a linear graph-based dependency parser very similar to our implemented LGPar (Bohnet, 2010).", "startOffset": 83, "endOffset": 97}, {"referenceID": 14, "context": "Please note that LLGPar-1K+39K actually performs closed test in this setting, meaning that it parses its Also, as suggested in the work of Li et al. (2016), annotating PA is more time-consuming than annotating FA in terms of averaged time for each dependency, since dependencies in the same sentence are correlated and earlier annotated dependencies usually make later annotation easier.", "startOffset": 139, "endOffset": 156}, {"referenceID": 17, "context": "Similar ideas have been extensively explored recently in sequence labeling tasks (Liu et al., 2014; Yang and Vozila, 2014; Marcheggiani and Arti\u00e8res, 2014).", "startOffset": 81, "endOffset": 155}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree.", "startOffset": 30, "endOffset": 50}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree.", "startOffset": 30, "endOffset": 80}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree. Mirroshandel and Nasr (2011) and Majidi and Crane (2013) adopt the complete-then-learn method.", "startOffset": 30, "endOffset": 298}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree. Mirroshandel and Nasr (2011) and Majidi and Crane (2013) adopt the complete-then-learn method.", "startOffset": 30, "endOffset": 326}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree. Mirroshandel and Nasr (2011) and Majidi and Crane (2013) adopt the complete-then-learn method. They use parsers coarsely trained on existing data with FA for completion via constrained decoding. However, our experiments show that this leads to dramatic decrease in parsing accuracy. Nivre et al. (2014) present a constrained decoding procedure for arc-eager transition-based parsers.", "startOffset": 30, "endOffset": 572}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree. Mirroshandel and Nasr (2011) and Majidi and Crane (2013) adopt the complete-then-learn method. They use parsers coarsely trained on existing data with FA for completion via constrained decoding. However, our experiments show that this leads to dramatic decrease in parsing accuracy. Nivre et al. (2014) present a constrained decoding procedure for arc-eager transition-based parsers. However, their work focuses on allowing their parser to effectively exploit external constraints during the evaluation phase. In this work, we directly employ their method and show that constrained decoding is effective for LTPar and thus irresponsible for its ineffectiveness in learning PA. Directly learning from PA based on constrained decoding is previously proposed by Jiang et al. (2013) for Chinese word segmentation, which is treated as a character-level sequence labeling problem.", "startOffset": 30, "endOffset": 1048}, {"referenceID": 10, "context": "Sassano and Kurohashi (2010), Jiang et al. (2010), and Flannery and Mori (2015) convert partially annotated instances into local dependency/non-dependency classification instances, which may suffer from the lack of non-local correlation between dependencies in a tree. Mirroshandel and Nasr (2011) and Majidi and Crane (2013) adopt the complete-then-learn method. They use parsers coarsely trained on existing data with FA for completion via constrained decoding. However, our experiments show that this leads to dramatic decrease in parsing accuracy. Nivre et al. (2014) present a constrained decoding procedure for arc-eager transition-based parsers. However, their work focuses on allowing their parser to effectively exploit external constraints during the evaluation phase. In this work, we directly employ their method and show that constrained decoding is effective for LTPar and thus irresponsible for its ineffectiveness in learning PA. Directly learning from PA based on constrained decoding is previously proposed by Jiang et al. (2013) for Chinese word segmentation, which is treated as a character-level sequence labeling problem. In this work, we first apply the idea to LGPar and LTPar for directly learning from PA. Directly learning from PA based on a forest-based objective in LLGPar is first proposed by Li et al. (2014), inspired by the idea of ambiguous labeling.", "startOffset": 30, "endOffset": 1340}, {"referenceID": 9, "context": "Hwa (1999) pioneers the idea of exploring PA for constituent grammar induction based on a variant Inside-Outside re-estimation algorithm (Pereira and Schabes, 1992).", "startOffset": 0, "endOffset": 11}, {"referenceID": 9, "context": "Hwa (1999) pioneers the idea of exploring PA for constituent grammar induction based on a variant Inside-Outside re-estimation algorithm (Pereira and Schabes, 1992). Clark and Curran (2006) propose to train a Combinatorial Categorial Grammar parser using partially labeled data only containing predicateargument dependencies.", "startOffset": 0, "endOffset": 190}, {"referenceID": 9, "context": "Hwa (1999) pioneers the idea of exploring PA for constituent grammar induction based on a variant Inside-Outside re-estimation algorithm (Pereira and Schabes, 1992). Clark and Curran (2006) propose to train a Combinatorial Categorial Grammar parser using partially labeled data only containing predicateargument dependencies. Mielens et al. (2015) propose to impute missing dependencies based on Gibbs sampling in order to enable traditional parsers to learn from partial trees.", "startOffset": 0, "endOffset": 348}, {"referenceID": 26, "context": "For example, Nivre et al. (2014) propose a constrained decoding procedure which can also incorporate bracketing constraints, i.", "startOffset": 13, "endOffset": 33}], "year": 2016, "abstractText": "Recently, these has been a surge on studying how to obtain partially annotated data for model supervision. However, there still lacks a systematic study on how to train statistical models with partial annotation (PA). Taking dependency parsing as our case study, this paper describes and compares two straightforward approaches for three mainstream dependency parsers. The first approach is previously proposed to directly train a log-linear graph-based parser (LLGPar) with PA based on a forest-based objective. This work for the first time proposes the second approach to directly training a linear graph-based parse (LGPar) and a linear transition-based parser (LTPar) with PA based on the idea of constrained decoding. We conduct extensive experiments on Penn Treebank under three different settings for simulating PA, i.e., random dependencies, most uncertain dependencies, and dependencies with divergent outputs from the three parsers. The results show that LLGPar is most effective in learning from PA and LTPar lags behind the graphbased counterparts by large margin. Moreover, LGPar and LTPar can achieve best performance by using LLGPar to complete PA into full annotation (FA).", "creator": "LaTeX with hyperref package"}}}