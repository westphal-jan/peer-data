{"id": "1610.06664", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Oct-2016", "title": "Stochastic Gradient MCMC with Stale Gradients", "abstract": "simple stochastic gradient mcmc ( labeled sg - mcmc ) has played an important role in large - scale bayesian learning, with well - developed theoretical convergence properties. even in such applications of sg - mcmc, it is becoming increasingly painfully popular to employ distributed systems, as where stochastic gradients are computed based on some outdated parameters, yielding what are termed stale gradients. while stale gradients could be directly directly used in sg - mcmc, their impact ratio on convergence properties has not been well studied. in this paper we develop theory paper to show that while the bias and mse of an sg - mcmc algorithm depend on the staleness data of stochastic gradients, its equivalent estimation variance ( relative to the expected estimate, based on a prescribed number distribution of samples ) similarly is independent of it. naturally in a simple bayesian distributed system with such sg - mode mcmc, where stale gradients are computed once asynchronously by involving a set of workers, our general theory indicates a linear speedup on the decrease of estimation variance w. r. t. the likelihood number matrix of workers. experiments on linear synthetic data and deep neural transmission networks validate our theory, demonstrating the effectiveness and scalability dependence of sg - mcmc with stale gradients.", "histories": [["v1", "Fri, 21 Oct 2016 04:18:11 GMT  (1093kb,D)", "http://arxiv.org/abs/1610.06664v1", "NIPS2016"]], "COMMENTS": "NIPS2016", "reviews": [], "SUBJECTS": "stat.ML cs.LG", "authors": ["changyou chen", "nan ding", "chunyuan li", "yizhe zhang", "lawrence carin"], "accepted": true, "id": "1610.06664"}, "pdf": {"name": "1610.06664.pdf", "metadata": {"source": "CRF", "title": "Stochastic Gradient MCMC with Stale Gradients", "authors": ["Changyou Chen", "Nan Ding", "Chunyuan Li", "Yizhe Zhang", "Lawrence Carin"], "emails": ["cc448@duke.edu;", "cl319@duke.edu;", "yz196@duke.edu;", "lcarin@duke.edu;", "dingnan@google.com"], "sections": [{"heading": "1 Introduction", "text": "The pervasiveness of big data has made scalable machine learning increasingly important, especially for deep models. A basic technique is to adopt stochastic optimization algorithms [1], e.g., stochastic gradient descent and its extensions [2]. In each iteration of stochastic optimization, a minibatch of data is used to evaluate the gradients of the objective function and update model parameters (errors are introduced in the gradients, because they are computed based on minibatches rather than the entire dataset; since the minibatches are typically selected at random, this yields the term \u201cstochastic\u201d gradient). This is highly scalable because processing a minibatch of data in each iteration is relatively cheap compared to analyzing the entire (large) dataset at once. Under certain conditions, stochastic optimization is guaranteed to converge to a (local) optima [1]. Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].\nIn order to handle large-scale data, distributed stochastic optimization algorithms have been developed, for example [6], to further improve scalability. In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9]. A downside of an asynchronous implementation is that stale gradients must be used in parameter updates (\u201cstale gradients\u201d are stochastic gradients computed based on outdated parameters, instead of the latest parameters; they are easier to compute in a distributed system, but introduce additional errors relative to traditional stochastic gradients). While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied. Distributed SG-MCMC algorithms share characteristics with distributed stochastic optimization, and thus are highly scalable and suitable for large-scale Bayesian learning. Existing Bayesian distributed systems with traditional MCMC\n29th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n61 0.\n06 66\n4v 1\n[ st\nat .M\nL ]\n2 1\nO ct\n2 01\nmethods, such as [13], usually employ stale statistics instead of stale gradients, where stale statistics are summarized based on outdated parameters, e.g., outdated topic distributions in distributed Gibbs sampling [13]. Little theory exists to guarantee the convergence of such methods. For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].\nIn this paper, by extending techniques from standard SG-MCMC [17], we develop theory to study the convergence behavior of SG-MCMC with Stale gradients (S2G-MCMC). Our goal is to evaluate the posterior average of a test function \u03c6(x), defined as \u03c6\u0304 , \u222b X \u03c6(x)\u03c1(x)d x, where \u03c1(x) is the desired posterior distribution with x the possibly augmented model parameters (see Section 2). In practice, S2G-MCMC generates L samples {xl}Ll=1 and uses the sample average \u03c6\u0302L , 1L \u2211L l=1 \u03c6(xl) to approximate \u03c6\u0304. We measure how \u03c6\u0302L approximates \u03c6\u0304 in terms of bias, MSE and estimation variance,\ndefined as |E\u03c6\u0302L \u2212 \u03c6\u0304|, E ( \u03c6\u0302L \u2212 \u03c6\u0304 )2 and E ( \u03c6\u0302L \u2212 E\u03c6\u0302L )2 , respectively. From the definitions, the\nbias and MSE characterize how accurately \u03c6\u0302L approximates \u03c6\u0304, and the variance characterizes how fast \u03c6\u0302L converges to its own expectation (for a prescribed number of samples L). Our theoretical results show that while the bias and MSE depend on the staleness of stochastic gradients, the variance is independent of it. In a simple asynchronous Bayesian distributed system with S2G-MCMC, our theory indicates a linear speedup on the decrease of the variance w.r.t. the number of workers used to calculate the stale gradients, while maintaining the same optimal bias level as standard SG-MCMC. We validate our theory on several synthetic experiments and deep neural network models, demonstrating the effectiveness and scalability of the proposed S2G-MCMC framework.\nRelated Work Using stale gradients is a standard setup in distributed stochastic optimization systems. Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20]. Furthermore, recent research on stochastic optimization has been extended to non-convex problems with provable convergence rates [12]. In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper."}, {"heading": "2 Stochastic Gradient MCMC", "text": "Throughout this paper, we denote vectors as bold lower-case letters, and matrices as bold uppercase letters. For example, N (m,\u03a3) means a multivariate Gaussian distribution with mean m and covariance \u03a3. In the analysis we consider algorithms with fixed-stepsizes for simplicity; decreasingstepsize variants can be addressed similarly as in [17].\nThe goal of SG-MCMC is to generate random samples from a posterior distribution p(\u03b8|D) \u221d p(\u03b8) \u220fN i=1 p(di |\u03b8), which are used to evaluate a test function. Here \u03b8 \u2208 Rn represents the parameter vector and D = {d1, \u00b7 \u00b7 \u00b7 ,dN} represents the data, p(\u03b8) is the prior distribution, and p(di |\u03b8) the likelihood for di. SG-MCMC algorithms are based on a class of stochastic differential equations, called It\u00f4 diffusion, defined as\nd xt = F (xt)dt+ g(xt)dwt , (1)\nwhere x \u2208 Rm represents the model states, typically x augments \u03b8 such that \u03b8 \u2286 x and n \u2264 m; t is the time index, wt \u2208 Rm is m-dimensional Brownian motion, functions F : Rm \u2192 Rm and g : Rm \u2192 Rm\u00d7m are assumed to satisfy the usual Lipschitz continuity condition [25]. For appropriate functions F and g, the stationary distribution, \u03c1(x), of the It\u00f4 diffusion (1) has a marginal distribution equal to the posterior distribution p(\u03b8|D) [26]. For example, denoting the unnormalized negative log-posterior as U(\u03b8) , \u2212 log p(\u03b8) \u2212 \u2211N i=1 log p(di |\u03b8), the stochastic gradient Langevin dynamic (SGLD) method [3] is based on 1st-order Langevin dynamics, with x = \u03b8, and F (xt) = \u2212\u2207\u03b8U(\u03b8), g(xt) = \u221a 2 In, where In is the n \u00d7 n identity matrix. The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin\ndynamics, with x = (\u03b8,q), and F (xt) = (\nq \u2212B q\u2212\u2207\u03b8U(\u03b8)\n) , g(xt) = \u221a 2B (\n0 0 0 In\n) for a\nscalar B > 0; q is an auxiliary variable known as the momentum [4, 5]. Diffusion forms for other\nSG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.\nIn order to efficiently draw samples from the continuous-time diffusion (1), SG-MCMC algorithms typically apply two approximations: i) Instead of analytically integrating infinitesimal increments dt, numerical integration over small step size h is used to approximate the integration of the true dynamics. ii) Instead of working with the full gradient \u2207\u03b8U(\u03b8lh), a stochastic gradient \u2207\u03b8U\u0303l(\u03b8lh), defined as\n\u2207\u03b8U\u0303l(\u03b8) , \u2212\u2207\u03b8 log p(\u03b8)\u2212 N\nJ J\u2211 i=1 \u2207\u03b8 log p(d\u03c0i |\u03b8), (2)\nis calculated from a minibatch of size J , where {\u03c01, \u00b7 \u00b7 \u00b7 , \u03c0J} is a random subset of {1, \u00b7 \u00b7 \u00b7 , N}. Note that to match the time index t in (1), parameters have been and will be indexed by \u201clh\u201d in the l-th iteration."}, {"heading": "3 Stochastic Gradient MCMC with Stale Gradients", "text": "In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.\n3.1 Stale stochastic gradient MCMC (S2G-MCMC)\nThe setting for S2G-MCMC is the same as the standard SG-MCMC described above, except that the stochastic gradient (2) is replaced with a stochastic gradient evaluated with outdated parameter \u03b8(l\u2212\u03c4l)h instead of the latest version \u03b8lh (see Appendix A for an example):\n\u2207\u03b8U\u0302\u03c4l(\u03b8) , \u2212\u2207\u03b8 log p(\u03b8(l\u2212\u03c4l)h)\u2212 N\nJ J\u2211 i=1 \u2207\u03b8 log p(d\u03c0i |\u03b8(l\u2212\u03c4l)h), (3)\nwhere \u03c4l \u2208 Z+ denotes the staleness of the parameter used to calculate the stochastic gradient in the l-th iteration. A distinctive difference between S2G-MCMC and SG-MCMC is that stale stochastic gradients are no longer unbiased estimations of the true gradients. This leads to additional challenges in developing convergence bounds, one of the main contributions of this paper.\nAlgorithm 1 State update of SGHMC with the stale stochastic gradient\u2207\u03b8U\u0302\u03c4l(\u03b8)\nInput: xlh = (\u03b8lh,qlh),\u2207\u03b8U\u0302\u03c4l(\u03b8), \u03c4l, \u03c4 , h, B Output: x(l+1)h = (\u03b8(l+1)h,q(l+1)h) if \u03c4l \u2264 \u03c4 then\nDraw \u03b6l \u223c N (0, I); q(l+1)h = (1\u2212Bh) qlh\u2212\u2207\u03b8U\u0302\u03c4l(\u03b8)h+ \u221a 2Bh\u03b6l;\n\u03b8(l+1)h = \u03b8lh + q(l+1)h h; end if\nWe assume a bounded staleness for all \u03c4l\u2019s, i.e.,\nmax l \u03c4l \u2264 \u03c4\nfor some constant \u03c4 . As an example, Algorithm 1 describes the update rule of the stale-SGHMC in each iteration with the Euler integrator, where the stale gradient \u2207\u03b8U\u0302\u03c4l(\u03b8) with staleness \u03c4l is used."}, {"heading": "3.2 Convergence analysis", "text": "This section analyzes the convergence properties of the basic S2G-MCMC; an extension with multiple chains is discussed in Section 3.3. It is shown that the bias and MSE depend on the staleness parameter \u03c4 , while the variance is independent of it, yielding significant speedup in Bayesian distributed systems.\nBias and MSE In [17], the bias and MSE of the standard SG-MCMC algorithms with a Kth order integrator were analyzed, where the order of an integrator reflects how accurately an SG-MCMC algorithm approximates the corresponding continuous diffusion. Specifically, if evolving xt with a numerical integrator using discrete time increment h induces an error bounded by O(hK), the integrator is called a Kth order integrator, e.g., the popular Euler method used in SGLD [3] is a 1st-order integrator. In particular, [17] proved the bounds stated in Lemma 1.\nLemma 1 ([17]). Under standard assumptions (see Appendix B), the bias and MSE of SG-MCMC with a Kth-order integrator at time T = hL are bounded as:\nBias: \u2223\u2223\u2223E\u03c6\u0302L \u2212 \u03c6\u0304\u2223\u2223\u2223 = O(\u2211l \u2016E\u2206Vl\u2016\nL +\n1\nLh + hK ) MSE: E ( \u03c6\u0302L \u2212 \u03c6\u0304 )2 = O ( 1 L \u2211 l E \u2016\u2206Vl\u2016 2\nL +\n1\nLh + h2K\n)\nHere \u2206Vl , L \u2212 L\u0303l, where L is the generator of the It\u00f4 diffusion (1) defined as\nLf(xt) , lim h\u21920+ E [f(xt+h)]\u2212 f(xt) h =\n( F (xt) \u00b7 \u2207x + 1\n2\n( g(xt)g(xt) T ) :\u2207x\u2207Tx ) f(xt) , (4)\nfor any compactly supported twice differentiable function f : Rn \u2192 R, h\u2192 0+ means h approaches zero along the positive real axis. L\u0303l is the same as L except using the stochastic gradient\u2207U\u0303l instead of the full gradient.\nWe show that the bounds of the bias and MSE of S2G-MCMC share similar forms as SG-MCMC, but with additional dependence on the staleness parameter. In addition to the assumptions in SG-MCMC [17] (see details in Appendix B), the following additional assumption is imposed.\nAssumption 1. The noise in the stochastic gradients is well-behaved, such that: 1) the stochastic gradient is unbiased, i.e., \u2207\u03b8U(\u03b8) = E\u03be\u2207\u03b8U\u0303(\u03b8) where \u03be denotes the random permutation over\n{1, \u00b7 \u00b7 \u00b7 , N}; 2) the variance of stochastic gradient is bounded, i.e., E\u03be \u2225\u2225\u2225U(\u03b8)\u2212 U\u0303(\u03b8)\u2225\u2225\u22252 \u2264 \u03c32; 3) the\ngradient function\u2207\u03b8U is Lipschitz (so is\u2207\u03b8U\u0303 ), i.e., \u2016\u2207\u03b8U(x)\u2212\u2207\u03b8U(y)\u2016 \u2264 C \u2016x\u2212y\u2016 ,\u2200x,y.\nIn the following theorems, we omit the assumption statement for conciseness. Due to the staleness of the stochastic gradients, the term \u2206Vl in S2G-MCMC is equal to L\u2212L\u0303l\u2212\u03c4l , where L\u0303l\u2212\u03c4l arises from \u2207\u03b8U\u0302\u03c4l . The challenge arises to bound these terms involving \u2206Vl. To this end, define flh ,\u2225\u2225xlh\u2212x(l\u22121)h\u2225\u2225, and \u03c8 to be a functional satisfying the Poisson Equation\u2217:\n1\nL L\u2211 l=1 L\u03c8(xlh) = \u03c6\u0302L \u2212 \u03c6\u0304 . (5)\nTheorem 2. After L iterations, the bias of S2G-MCMC with a Kth-order integrator is bounded, for some constant D1 independent of {L, h, \u03c4}, as:\u2223\u2223\u2223E\u03c6\u0302L \u2212 \u03c6\u0304\u2223\u2223\u2223 \u2264 D1( 1\nLh +M1\u03c4h+M2h\nK ) ,\nwhere M1 , maxl |Lflh|maxl \u2016E\u2207\u03c8(xlh)\u2016C, M2 , \u2211K k=1 \u2211 l EL\u0303 k+1 l \u03c8(x(l\u22121)h) (k+1)!L are constants.\nTheorem 3. After L iterations, the MSE of S2G-MCMC with a Kth-order integrator is bounded, for some constant D2 independent of {L, h, \u03c4}, as:\nE ( \u03c6\u0302L \u2212 \u03c6\u0304 )2 \u2264 D2 ( 1\nLh + M\u03031\u03c4\n2h2 + M\u03032h 2K ) ,\nwhere constants M\u03031 , maxl \u2016E\u2207\u03c8(xlh)\u20162 maxl (Lflh)2 C2, M\u03032 , E( \u2211 l L\u0303 K+1 l \u03c8(x(l\u22121)h) L(K+1)! )\n2. The theorems indicate that both the bias and MSE depend on the staleness parameter \u03c4 . For a fixed computational time, this could possibly lead to unimproved bounds, compared to standard SG-MCMC, when \u03c4 is too large, i.e., the terms with \u03c4 would dominate, as is the case in the distributed system discussed in Section 4. Nevertheless, better bounds than standard SG-MCMC could be obtained if the decrease of 1Lh is faster than the increase of the staleness in a distributed system.\n\u2217The existence of a nice \u03c8 is guaranteed in the elliptic/hypoelliptic SDE settings when x is on a torus [25].\nVariance Next we investigate the convergence behavior of the variance, Var(\u03c6\u0302L) , E ( \u03c6\u0302L \u2212 E\u03c6\u0302L )2 . Theorem 4 indicates the variance is independent of \u03c4 , hence a linear speedup in the\ndecrease of variance is always achievable when stale gradients are computed in parallel. An example is discussed in the Bayesian distributed system in Section 4. Theorem 4. After L iterations, the variance of S2G-MCMC with a Kth-order integrator is bounded, for some constant D, as:\nVar ( \u03c6\u0302L ) \u2264 D ( 1\nLh + h2K\n) .\nThe variance bound is the same as for standard SG-MCMC, whereas L could increase linearly w.r.t. the number of workers in a distributed setting, yielding significant variance reduction. When optimizing the the variance bound w.r.t.h, we get an optimal variance bound stated in Corollary 5. Corollary 5. In term of estimation variance, the optimal convergence rate of S2G-MCMC with a Kth-order integrator is bounded as: Var ( \u03c6\u0302L ) \u2264 O ( L\u22122K/(2K+1) ) .\nIn real distributed systems, the decrease of 1/Lh and increase of \u03c4 , in the bias and MSE bounds, would typically cancel, leading to the same bias and MSE level compared to standard SG-MCMC, whereas a linear speedup on the decrease of variance w.r.t. the number of workers is always achievable. More details are discussed in Section 4."}, {"heading": "3.3 Extension to multiple parallel chains", "text": "This section extends the theory to the setting with S parallel chains, each independently running an S2G-MCMC algorithm. After generating samples from the S chains, an aggregation step is needed to combine the sample average from each chain, i.e., {\u03c6\u0302Ls}Ms=1, where Ls is the number of iterations on chain s. For generality, we allow each chain to have different step sizes, e.g., (hs)Ss=1. We aggregate the sample averages as \u03c6\u0302SL , \u2211S s=1 Ts T \u03c6\u0302Ls , where Ts , Lshs, T , \u2211S s=1 Ts.\nInterestingly, with increasing S, using multiple chains does not seem to directly improve the convergence rate for the bias, but improves the MSE bound, as stated in Theorem 6.\nTheorem 6. Let Tm , maxl Tl, hm , maxl hl, T\u0304 = T/S, the bias and MSE of S parallel S2GMCMC chains with a Kth-order integrator are bounded, for some constants D1 and D2 independent of {L, h, \u03c4}, as:\nBias: \u2223\u2223\u2223E\u03c6\u0302SL \u2212 \u03c6\u0304\u2223\u2223\u2223 \u2264 D1( 1T\u0304 + TmT\u0304 (M1\u03c4hs +M2hKs ) ) MSE: E ( \u03c6\u0302SL \u2212 \u03c6\u0304 )2 \u2264 D2 ( 1\u2212 1/T\u0304\nT +\n1 T\u0304 2 + T 2m T\u0304 2 ( M21 \u03c4 2h2s +M 2 2h 2K s )) .\nAssume that T\u0304 = T/S is independent of the number of chains. As a result, using multiple chains does not directly improve the bound for the bias\u2020. However, for the MSE bound, although the last two terms are independent of S, the first term decreases linearly with respect to S because T = T\u0304 S. This indicates a decreased estimation variance with more chains. This matches the intuition because more samples can be obtained with more chains in a given amount of time.\nThe decrease of MSE for multiple-chain is due to the decrease of the variance as stated in Theorem 7. Theorem 7. The variance of S parallel S2G-MCMC chains with a Kth-order integrator is bounded, for some constant D independent of {L, h, \u03c4}, as:\nE ( \u03c6\u0302SL \u2212 E\u03c6\u0302SL )2 \u2264 D\n( 1\nT + S\u2211 s=1 T 2s T 2 h2Ks\n) .\nWhen using the same step size for all chains, Theorem 7 gives an optimal variance bound of O ( ( \u2211 s Ls) \u22122K/(2K+1)), i.e. a linear speedup with respect to S is achieved. In addition, Theorem 6 with \u03c4 = 0 and K = 1 provides convergence rates for the distributed SGLD algorithm in [14], i.e., improved MSE and variance bounds compared to the single-server SGLD. \u2020It means the bound does not directly relate to low-order terms of S, though constants might be improved."}, {"heading": "4 Applications to Distributed SG-MCMC Systems", "text": "Our theory for S2G-MCMC is general, serving as a basic analytic tool for distributed SG-MCMC systems. We propose two simple Bayesian distributed systems with S2G-MCMC in the following.\nSingle-chain distributed SG-MCMC Perhaps the simplest architecture is an asynchronous distributed SG-MCMC system, where a server runs an S2G-MCMC algorithm, with stale gradients computed asynchronously from W workers. The detailed operations of the server and workers are described in Appendix A.\nWith our theory, now we explain the convergence property of this simple distributed system with SG-MCMC, i.e., a linear speedup w.r.t. the number of workers on the decrease of variance, while maintaining the same bias level. To this end, rewrite L = WL\u0304 from Theorems 2 and 3, where L\u0304 is the average number of iterations on each worker. We can observe from the theorems that when M1\u03c4h > M2h\nK in the bias and M\u03031\u03c42h2 > M\u03032h2K in the MSE, the terms with \u03c4 dominate. Optimizing the bounds with respect to h yields a bound of O((\u03c4/WL\u0304)1/2) for the bias, and O((\u03c4/WL\u0304)2/3) for the MSE. In practice, we usually observe \u03c4 \u2248 W , making W in the optimal bounds cancels, i.e., the same optimal bias and MSE bounds as standard SG-MCMC are obtained, no theoretical speedup is achieved when increasing W . However, from Corollary 5, the variance is independent of \u03c4 , thus a linear speedup on the variance bound can be always obtained when increasing the number of workers, i.e., the distributed SG-MCMC system convergences a factor of W faster than standard SG-MCMC with a single machine. We are not aware of similar conclusions from optimization, because most of the research focuses on the convex setting, thus only variance (equivalent to MSE) is studied.\nMultiple-chain distributed SG-MCMC We can also adopt multiple servers based on the multiplechain setup in Section 3.3, where each chain corresponds to one server. The detailed architecture is described in Appendix A. This architecture trades off communication cost with convergence rates. As indicated by Theorems 6 and 7, the MSE and variance bounds can be improved with more servers. Note that when only one worker is associated with one server, we recover the setting of S independent servers. Compared to the single-server architecture described above with S workers, from Theorems 2\u20137, while the variance bound is the same, the single-server arthitecture improves the bias and MSE bounds by a factor of S.\nMore advanced architectures More complex architectures could also be designed to reduce communication cost, for example, by extending the downpour [7] and elastic SGD [29] architectures to the SG-MCMC setting. Their convergence properties can also be analyzed with our theory since they are essentially using stale gradients. We leave the detailed analysis for future work."}, {"heading": "5 Experiments", "text": "Our primal goal is to validate the theory, comparing with different distributed architectures and algorithms, such as [30, 31], is beyond the scope of this paper. We first use two synthetic experiments to validate the theory, then apply the distributed architecture described in Section 4 for Bayesian deep learning. To quantitatively describe the speedup property, we adopt the the iteration speedup [12], defined as: iteration speedup , #iterations with a single workeraverage #iterations on a worker , where # is the iteration count when the same level of precision is achieved. This speedup best matches with the theory. We also consider the time speedup, defined as: running time for a single workerrunning time forW worker , where the running time is recorded at the same accuracy. It is affected significantly by hardware, thus is not accurately consistent with the theory."}, {"heading": "5.1 Synthetic experiments", "text": "Impact of stale gradients A simple Gaussian model is used to verify the impact of stale gradients on the convergence accuracy, with di \u223c N (\u03b8, 1), \u03b8 \u223c N (0, 1). 1000 data samples {di} are generated, with minibatches of size 10 to calculate stochastic gradients. The test function is \u03c6(\u03b8) , \u03b82. The distributed SGLD algorithm is adopted in this experiment. We aim to verify that the optimal MSE bound \u221d \u03c42/3L\u22122/3, derived from Theorem 3 and discussed in Section 4 (with W = 1). The optimal stepsize is h = C\u03c4\u22122/3L\u22121/3 for some constant C. Based on the optimal bound, setting\nL = L0 \u00d7 \u03c4 for some fixed L0 and varying \u03c4 \u2019s would result in the same MSE, which is \u221d L\u22122/30 . In the experiments we set C = 1/30, L0 = 500, \u03c4 = {1, 2, 5, 10, 15, 20}, and average over 200 runs to approximate the expectations in the MSE formula. As indicated in Figure 1, approximately the same MSE\u2019s are obtained after L0\u03c4 iterations for different \u03c4 values, consistent with the theory. Note since the stepsizes are set to make end points of the curves reach the optimal MSE\u2019s, the curves would not match the optimal MSE curves of \u03c42/3L\u22122/3 in general, except for the end points, i.e., they are lower bounded by \u03c42/3L\u22122/3.\nConvergence speedup of the variance A Bayesian logistic regression model (BLR) is adopted to verify the variance convergence properties. We use the Adult dataset\u2021, a9a, with 32,561 training samples and 16,281 test samples. The test function is defined as the standard logistic loss. We average over 10 runs to estimate the expectation E\u03c6\u0302L in the variance. We use the single-server distributed architecture in Section 4, with multiple workers computing stale gradients in parallel. We plot the variance versus the average number of iterations on the workers (L\u0304) and the running time in Figure 2 (a) and (b), respectively. We can see that the variance drops faster with increasing number of workers. To quantitatively relate these results to the theory, Corollary 5 indicates that L1L2 = W1 W2\n, where (Wi, Li)2i=1 means the number of workers and iterations at the same variance, i.e., a linear speedup is achieved. The iteration speedup and time speedup are plotted in Figure 2 (c), showing that the iteration speedup approximately scales linearly worker numbers, consistent with Corollary 5; whereas the time speedup deteriorates when the worker number is large due to high system latency."}, {"heading": "5.2 Applications to deep learning", "text": "We further test S2G-MCMC on Bayesian learning of deep neural networks. The distributed system is developed based on an MPI (message passing interface) extension of the popular Caffe package for deep learning [32]. We implement the SGHMC algorithm, with the point-to-point communications between servers and workers handled by the MPICH library.The algorithm is run on a cluster of five machines. Each machine is equipped with eight 3.60GHz Intel(R) Core(TM) i7-4790 CPU cores.\nWe evaluate S2G-MCMC on the above BLR model and two deep convolutional neural networks (CNN). In all these models, zero mean and unit variance Gaussian priors are employed for the weights to capture weight uncertainties, an effective way to deal with overfitting [33]. We vary the number of servers S among {1, 3, 5, 7}, and the number of workers for each server from 1 to 9.\nLeNet for MNIST We modify the standard LeNet to a Bayesian setting for the MNIST dataset.LeNet consists of 2 convolutional layers, 2 max pool layers and 2 ReLU nonlinear layers, followed by 2 fully connected layers [34]. The detailed specification can be found in Caffe. For simplicity, we use the default parameter setting specified in Caffe, with the additional parameter B in SGHMC (Algorithm 1) set to (1\u2212m), where m is the moment variable defined in the SGD algorithm in Caffe.\n\u2021http://www.csie.ntu.edu.tw/ cjlin/libsvmtools/datasets/binary.html.\nCifar10-Quick net for CIFAR10 The Cifar10-Quick net consists of 3 convolutional layers, 3 max pool layers and 3 ReLU nonlinear layers, followed by 2 fully connected layers. The CIFAR-10 dataset consists of 60,000 color images of size 32\u00d732 in 10 classes, with 50,000 for training and 10,000 for testing.Similar to LeNet, default parameter setting specified in Caffe is used.\nIn these models, the test function is defined as the cross entropy of the softmax outputs {o1, \u00b7 \u00b7 \u00b7 ,oN} for test data {(d1, y1), \u00b7 \u00b7 \u00b7 , (dN , yN )} with C classes, i.e., loss = \u2212 \u2211N i=1 oyi +N log \u2211C c=1 e\noc . Since the theory indicates a linear speedup on the decrease of variance w.r.t. the number of workers, this means for a single run of the models, the loss would converge faster to its expectation with increasing number of workers. The following experiments verify this intuition."}, {"heading": "5.2.1 Single-server experiments", "text": "We first test the single-server architecture in Section 4 on the three models. Because the expectations in the bias, MSE or variance are not analytically available in these complex models, we instead plot the loss versus average number of iterations (L\u0304 defined in Section 4) on each worker and the running time in Figure 3. As mentioned above, faster decrease of the loss with more workers is expected.\nFor the ease of visualization, we only plot the results with {1, 2, 4, 6, 9} workers; more detailed results are provided in Appendix I. We can see that generally the loss decreases faster with increasing number of workers. In the CIFAR-10 dataset, the final losses of 6 and 9 workers are worst than the one with 4 workers. It shows that the accuracy of the sample average suffers from the increased staleness due to the increased number of workers. Therefore a smaller step size h should be considered to maintain high accuracy when using a large number of workers. Note the 1-worker curves correspond to the standard SG-MCMC, whose loss decreases much slower due to high estimation variance, though in theory it has the same level of bias as the single-server architecture for a given number of iterations (they will converge to the same accuracy)."}, {"heading": "5.2.2 Multiple-server experiments", "text": "Finally, we test the multiple-servers architecture on the same models. We use the same criterion as the single-server setting to measure the convergence behavior. The loss versus average number of iterations on each worker (L\u0304 defined in Section 4) for the three datasets are plotted in Figure 4, where we vary the number of servers among {1, 3, 5, 7}, and use 2 workers for each server. The plots of loss versus time and using different number of workers for each server are provided in the Appendix. We can see that in the simple BLR model, multiple servers do not seem to show significant speedup, probably due to the simplicity of the posterior, where the sample variance is too small for multiple\nservers to take effect; while in the more complicated deep neural networks, using more servers results in a faster decrease of the loss, especially in the MNIST dataset."}, {"heading": "6 Conclusion", "text": "We extend theory from standard SG-MCMC to the stale stochastic gradient setting, and analyze the impacts of the staleness to the convergence behavior of an S2G-MCMC algorithm. Our theory reveals that the estimation variance is independent of the staleness, leading to a linear speedup w.r.t. the number of workers, although in practice little speedup in terms of optimal bias and MSE might be achieved due to their dependence on the staleness. We test our theory on a simple asynchronous distributed SG-MCMC system with two simulated examples and several deep neural network models. Experimental results verify the effectiveness and scalability of the proposed S2G-MCMC framework.\nAcknowledgements Supported in part by ARO, DARPA, DOE, NGA, ONR and NSF."}, {"heading": "B Assumptions", "text": "First, following [25], we will need to assume the corresponding SDE of SG-MCMC to be either elliptic or hypoelliptic. The ellipticity/hypoellipticity describes whether the Brownian motion is able to spread over the whole parameter space. The SDE of the SGLD is elliptic, while for other SGMCMC algorithms such as the SGHMC, the hypoellipticity assumption is usually reasonable. When the domain x is on the torus, the ellipticity and hypoellipticity of an SDE guarantees the existence of a nice solution for the Poisson equation (5). The assumption is summarized in Assumption 2.\nAssumption 2. The corresponding SDE of a SG-MCMC algorithm is either elliptic or hypoelliptic\u2016.\nWhen x is extended to the domain of Rp for some integer p > 0, we need some assumptions on the solution of the Poisson equation (5). Note (5) can be equivalently written in an integration form [35] using It\u00f4\u2019s formula:\n1\nt \u222b t 0 \u03c6(xs)ds\u2212 \u03c6\u0304 (6)\n= 1\nt (\u03c8(xt)\u2212 \u03c8(x0))\u2212\n1\nt \u222b t 0 \u2207\u03c8(xs) \u00b7 g(xs)dws .\nIntuitively, \u03c8 needs to be bounded if the discrepancy between \u03c6\u0302L and \u03c6\u0304 were to be bounded. This is satisfied if the SDE is defined in a bounded domain [25]. In the unbounded domain as for SG-MCMC algorithms, it turns out the following boundedness assumptions on \u03c8 suffice [17]. Assumption 3. 1) \u03c8 and its up to 3rd-order derivatives, Dk\u03c8, are bounded by a function V , i.e., \u2016Dk\u03c8\u2016 \u2264 CkVpk for k = (0, 1, 2, 3), Ck, pk > 0. 2) the expectation of V on {xlh} is bounded: supl EVp(xlh) < \u221e. 3) V is smooth such that sups\u2208(0,1) Vp (sx + (1\u2212 s) y) \u2264 C (Vp (x) + Vp (y)), \u2200x,y, p \u2264 max{2pk} for some C > 0.\nFurthermore, in our proofs the expectation of a function under a diffusion needs to be expanded in a Taylor expansion style, e.g., E\u03c6(xt) = \u2211` i=0 ti i!L i\u03c6(x0) + t `+1r`,F,\u03c6(x0) by using Kolmogorov\u2019s\n\u2016The SDE of the SGLD can be verified to be elliptic. For other SG-MCMC algorithms such as the SGHMC, the hypoellipticity assumption is usually reasonable, see [25] on how to verify hypoellipticity of an SDE.\nbackward equation. To ensure the remainder term r`,F,\u03c6(x0) to be bounded, it suffices to make the following assumption on the smoothness and boundedness of F (x) [35, 17].\nAssumption 4. F (x) is infinitely differentiable with bounded derivatives of any order; and |F (x)| \u2264 A(1 + |x |s) for some integer s > 0 and A > 0."}, {"heading": "C Notation", "text": "For simplicity, we will simplify some notation used in the proof as follows:\n\u2207\u03b8U\u0303l(\u03b8lh) , \u2207\u03b8U\u0303lh , G\u0303lh \u2207\u03b8Ul(\u03b8lh) , \u2207\u03b8Ulh , Glh \u03c8(Xlh) , \u03c8lh"}, {"heading": "D Proof of Theorem 2", "text": "In S2G-MCMC, for the l-th iteration, suppose a stochastic gradient with a staleness \u03c4l is used, e.g., G\u0303(l\u2212\u03c4l)h. First, we will bound the difference between G\u0303(l\u2212\u03c4l)h and the stochastic gradient at the l-th iteration G\u0303lh, by using the Lipschitz property of G\u0303lh, with the following lemma.\nLemma 8. Let flh , \u2225\u2225xlh\u2212x(l\u22121)h\u2225\u2225, the expected difference between G\u0303(l\u2212\u03c4l)h and G\u0303lh is bounded by: \u2225\u2225\u2225E(G\u0303(l\u2212\u03c4l)h \u2212 G\u0303lh)\u2225\u2225\u2225 = l\u22121max i=l\u2212\u03c4l |Lifih|C\u03c4h+O(h2), (7)\nwhere the expectation is taken over the randomness of the SG-MCMC algorithm, e.g., the randomness from stochastic gradients and the injected Gaussian noise.\nProof. Note the randomness of G\u0303lh comes from two sources, the injected Gaussian noise and the stochastic gradient noise. We denote the expectations with respect to these two randomness as E\u03b6 and Eg , respectively. The whole expectation thus can be decomposed as E = E\u03b6Eg .\nApplying the Lipschitz property of G\u0303lh, we have\u2225\u2225\u2225E(G\u0303(l\u2212\u03c4l)h \u2212 G\u0303lh)\u2225\u2225\u2225 = \u2225\u2225E\u03b6 (G(l\u2212\u03c4l)h \u2212Glh)\u2225\u2225 \u2264 E\u03b6\n\u2225\u2225(G(l\u2212\u03c4l)h \u2212Glh)\u2225\u2225 \u2264 CE\u03b6\n\u2225\u2225(\u03b8(l\u2212\u03c4l)h \u2212 \u03b8lh)\u2225\u2225 \u2264 CE\u03b6 \u2225\u2225\u2225\u2225\u2225 l\u22121\u2211\ni=l\u2212\u03c4l\n( \u03b8(ih) \u2212 \u03b8(i+1)h )\u2225\u2225\u2225\u2225\u2225 \u2264 C\nl\u22121\u2211 i=l\u2212\u03c4l E\u03b6 \u2225\u2225(\u03b8(ih) \u2212 \u03b8(i+1)h)\u2225\u2225\n\u2264 C l\u22121\u2211\ni=l\u2212\u03c4l\nE\u03b6 \u2225\u2225x(i+1)h\u2212xih\u2225\u2225\nFrom the definition of Kth-order integrator, i.e., E\u03b6f(xlh) = eL\u0303lhf(x(l\u22121)h) +O(hK+1), if we let\nf(xlh) = \u2225\u2225xlh\u2212x(l\u22121)h\u2225\u2225 , flh ,\nwhere x(l\u22121)h is the starting point in the l-th iteration, and note that\nf(x(l\u22121)h) = 0 .\nWe have\nC l\u22121\u2211 i=l\u2212\u03c4l E\u03b6 \u2225\u2225x(i+1)h\u2212xih\u2225\u2225 , C l\u22121\u2211 i=l\u2212\u03c4l E\u03b6f(xlh) (8)\n\u2264C l\u22121\u2211\ni=l\u2212\u03c4l\n( eLihf(x(i\u22121)h) +O(h K+1) )\n(9)\n\u2264C l\u22121\u2211\ni=l\u2212\u03c4l\n|Lifih|h+O(h2) (10)\n\u2264 l\u22121max i=l\u2212\u03c4l |Lifih|C\u03c4h+O(h2) ,\nwhere (10) is obtained by expanding the exponential operator and the assumption that the high order terms are bounded.\nNow we proceed to prove Theorem 2. The basic technique follows [17], thus we skip some derivations for some steps.\nProof of Theorem 2. Before the proof, let us first define some notation. First, define the operator \u2206Vl for each l as a differential operator as for any function \u03c8:\n\u2206Vl\u03c8 , ( G\u0303l\u2212\u03c4l \u2212Gl ) \u00b7 \u2207p\u03c8 .\nSecond, define the local generator, L\u0303l, for an It\u00f4 diffusion, where the true gradient in (1) is replaced with the stochastic gradient from the l-th iteration, i.e., L\u0303lf(Xt) ,(\nF\u0303l(xt) \u00b7 \u2207+ 1\n2\n( \u03c3(xt)\u03c3(xt) T ) :\u2207\u2207T ) f(xt) ,\nfor a compactly supported twice differentiable function f , where F\u0303l is the same as F but with the full gradient Glh replaced with the stochastic gradient G\u0303lh. Based on these definitions, we have\nL\u0303l = L+ \u2206Vl .\nFollowing [17], for an SG-MCMC with a Kth-order integrator, and a test function \u03c6, we have: E[\u03c8(xlh)] = ( I + hL\u0303l ) \u03c8(x(l\u22121)h) (11)\n+ K\u2211 k=2 hk k! L\u0303kl \u03c8(x(l\u22121)h) +O ( hK+1 (K + 1)! L\u0303K+1l \u03c8(l\u22121)h ) ,\nwhere I is the identity map. Sum over l = 1, \u00b7 \u00b7 \u00b7 , L in (11), take expectation on both sides, and use the relation L\u0303l = L+\u2206Vl to expand the first order term. We obtain\nL\u2211 l=1 E[\u03c8(xlh)] = \u03c8(x0) + L\u22121\u2211 l=1 E[\u03c8(xlh)]\n+ h L\u2211 l=1 E[L\u03c8(x(l\u22121)h)] + h L\u2211 l=1 E[\u2206Vl\u03c8(x(l\u22121)h)]\n+ K\u2211 k=2 hk k! L\u2211 l=1 E[L\u0303kl \u03c8(x(l\u22121)h)]\n+O\n( hK+1\n(K + 1)! \u2211 l EL\u0303K+1l \u03c8(l\u22121)h\n) .\nDivide both sides by Lh, use the Poisson equation (5), and reorganize terms. We have:\nE[ 1\nL \u2211 l \u03c6(xlh)\u2212 \u03c6\u0304] = 1 L L\u2211 l=1 E[L\u03c8(x(l\u22121)h)] (12)\n= 1\nLh (E[\u03c8(xlh)]\u2212 \u03c8(x0))\u2212\n1\nL \u2211 l E[\u2206Vl\u03c8(x(l\u22121)h)]\n\u2212 K\u2211 k=2 hk\u22121 k!L L\u2211 l=1 E[L\u0303kl \u03c8(x(l\u22121)h)] +O\n( hK\n(K + 1)!L \u2211 l EL\u0303K+1l \u03c8(l\u22121)h\n)\nAccording to [17], the term \u2211 l E[L\u0303 k l \u03c8(x(l\u22121)h)] is bounded by \u2211 l E[L\u0303 k l \u03c8(X(l\u22121)h)]\n= O\n( 1\nh + hK\u2212k+1 \u2211 l EL\u0303K+1l \u03c8(l\u22121)h\n) , (13)\nSubstituting (13) into (12), after simplification, we have: E ( 1 L \u2211 l \u03c6(xlh)\u2212 \u03c6\u0304 ) = 1\nLh (E[\u03c8(xlh)]\u2212 \u03c8(x0))\ufe38 \ufe37\ufe37 \ufe38\nC1\n\u2212 1 L \u2211 l\nE[\u2206Vl\u03c8(x(l\u22121)h)]\ufe38 \ufe37\ufe37 \ufe38 C2\n\u2212 K\u2211 k=2 O\n( hk\u22121\nLh + hK L \u2211 l 1 k! EL\u0303Kl \u03c8(l\u22121)h\n) +\nhK\n(K + 1)!L \u2211 l EL\u0303K+1l \u03c8(l\u22121)h ,\nAccording to the assumption, the term C1 is bounded. For term C2, according to the Cauchy\u2013Schwarz inequality, we have\n|C2| = 1\nL \u2223\u2223\u2223\u2223\u2223\u2211 l E ( G\u0303(l\u2212\u03c4l)h \u2212Glh ) \u00b7 E\u2207\u03c8(l\u22121)h \u2223\u2223\u2223\u2223\u2223 \u2264 1 L \u2211 l\n\u2223\u2223\u2223E(G\u0303(l\u2212\u03c4l)h \u2212Glh) \u00b7 E\u2207\u03c8(l\u22121)h\u2223\u2223\u2223 \u2264 1 L \u2211 l\n\u2225\u2225\u2225E(G\u0303(l\u2212\u03c4l)h \u2212Glh)\u2225\u2225\u2225\u2225\u2225E\u2207\u03c8(l\u22121)h\u2225\u2225 \u2264 1 L \u2211 l\n(\u2225\u2225\u2225E(G\u0303(l\u2212\u03c4l)h \u2212 G\u0303lh)\u2225\u2225\u2225+ \u2225\u2225\u2225E(G\u0303lh \u2212Glh)\u2225\u2225\u2225)\u2225\u2225E\u2207\u03c8(l\u22121)h\u2225\u2225 = 1\nL \u2211 l \u2225\u2225\u2225E(G\u0303(l\u2212\u03c4l)h \u2212 G\u0303lh)\u2225\u2225\u2225\u2225\u2225E\u2207\u03c8(l\u22121)h\u2225\u2225 Applying (7) from Lemma 8, we have\n|C2| \u2264 1\nL \u2211 l ( l max i=l\u2212\u03c4l \u2016Li\u2016 \u2016E\u2207\u03c8lh\u2016C\u03c4lh )\n\u2264 max l \u2016Ll\u2016max l \u2016E\u2207\u03c8lh\u2016C\u03c4h .\nAs a result, collecting low order terms, the bias can be expressed as:\u2223\u2223\u2223E\u03c6\u0302\u2212 \u03c6\u0304\u2223\u2223\u2223 = \u2223\u2223\u2223\u2223\u2223E ( 1 L \u2211 l \u03c6(xlh)\u2212 \u03c6\u0304 )\u2223\u2223\u2223\u2223\u2223 =\n\u2223\u2223\u2223\u2223\u2223C1Lh \u2212 C2 + hK K\u2211 k=1\n1\n(k + 1)!L \u2211 l EL\u0303k+1l \u03c8(l\u22121)h \u2223\u2223\u2223\u2223\u2223 . (14)\nAs a result, there exists some constant D1 independent of (L, h, \u03c4), such that\u2223\u2223\u2223E\u03c6\u0302\u2212 \u03c6\u0304\u2223\u2223\u2223 \u2264 D1 \u2223\u2223\u2223\u2223 1Lh \u2223\u2223\u2223\u2223+ |C2|+ \u2223\u2223M1\u03c4h+ \u2223\u2223M2hK\u2223\u2223\u2223\u2223 (15)\n=D1\n( 1\nLh +M1\u03c4h+M2h\nK ) ,\nwhere M1 , maxl \u2016Ll\u2016maxl \u2016E\u2207\u03c8lh\u2016C, M2 , \u2211K k=1 1 (k+1)!L \u2211 l EL\u0303 k+1\nl \u03c8(l\u22121)h. (15) follows by substituting the inequality for C2 above. This completes the proof."}, {"heading": "E Proof of Theorem 3", "text": "Proof. Similar to the proof of Theorem 2, we first expand E\u03c8lh using the property of Kth-order integrator as\nL\u2211 l=1 E (\u03c8(xlh)) = L\u2211 l=1 \u03c8(x(l\u22121)h) + h L\u2211 l=1 L\u03c8(x(l\u22121)h)\n+ h L\u2211 l=1 \u2206Vl\u03c8(x(l\u22121)h) + K\u2211 k=2 hk k! L\u2211 l=1 L\u0303kl \u03c8(x(l\u22121)h)\n+O\n( hK+1\n(K + 1)! \u2211 l L\u0303K+1l \u03c8(l\u22121)h\n) .\nSubstituting the Poisson equation (5) into the above equation, dividing both sides by Lh and rearranging related terms arrives\n\u03c6\u0302\u2212\u03c6\u0304 = 1 Lh (E\u03c8(xLh)\u2212 \u03c8(x0)) (16)\n\u2212 1 Lh L\u2211 l=1 ( E\u03c8(l\u22121)h \u2212 \u03c8(l\u22121)h ) \u2212 1 L L\u2211 l=1 \u2206Vl\u03c8(l\u22121)h\n\u2212 K\u2211 k=2 hk\u22121 2L L\u2211 l=1 L\u0303kl \u03c8(x(l\u22121)h) +O\n( hK\nL(K + 1)! \u2211 l L\u0303K+1l \u03c8(l\u22121)h ) Taking square on both sides, we have there exists some positive constant D, such that\n( \u03c6\u0302\u2212 \u03c6\u0304 )2 \u2264 D  (E\u03c8Lh \u2212 \u03c80) 2\nL2h2\ufe38 \ufe37\ufe37 \ufe38 A1\n+ 1\nL2h2 L\u2211 l=1 ( E\u03c8(l\u22121)h \u2212 \u03c8(l\u22121)h )2 \ufe38 \ufe37\ufe37 \ufe38\nA2\n+\n( 1\nL L\u2211 l=1 \u2206Vl\u03c8(l\u22121)h )2 \ufe38 \ufe37\ufe37 \ufe38\nA3\n+ K\u2211 k=2 h2(k\u22121) k!L2 ( L\u2211 l=1 L\u0303kl \u03c8(l\u22121)h )2 \ufe38 \ufe37\ufe37 \ufe38\nA4\n+\n(\u2211 l L\u0303 K+1 l \u03c8(l\u22121)h\nL(K + 1)! )2 h2K\ufe38 \ufe37\ufe37 \ufe38\nA5\n (17)\nAfter taking expectation, we have E ( \u03c6\u0302\u2212 \u03c6\u0304 )2 \u2264 C (EA1 + EA2 + EA3 + EA4 + EA5)\nA1 is easily bounded by the assumption that \u2016\u03c8\u2016 \u2264 V p0 <\u221e. From the proof of Theorem 3 in [17], A2 and A4 are also bounded, which are summarized in Lemma 9.\nLemma 9. The terms EA2 and EA4 are bounded by: EA2 = O ( 1\nLh ) EA4 = O ( 1\nLh + h2K K\u2211 k=2 1 Lk! \u2211 l L\u0303k+1l \u03c8(l\u22121)h\n) .\nWe are left to show a bound for EA3. First we have\nEA3 = E\n( 1\nL L\u2211 l=1 \u2206Vl\u03c8(l\u22121)h\n)2\n=E\n( 1\nL L\u2211 l=1 ( G\u0303(l\u2212\u03c4l)h \u2212Glh ) \u00b7 \u2207p\u03c8(l\u22121)h\n)2\n= 1\nL2 L\u2211 i=1 L\u2211 j=1 E [( G\u0303(i\u2212\u03c4i)h \u2212Gih ) \u00b7 \u2207p\u03c8(i\u22121)h ( G\u0303(j\u2212\u03c4j)h \u2212Gjh ) \u00b7 \u2207p\u03c8(j\u22121)h ] Using the Cauchy\u2013Schwartz inequality, we have\n\u2264 1 L2 L\u2211 i=1 L\u2211 j=1 \u2225\u2225\u2225E(G\u0303(i\u2212\u03c4i)h \u2212Gih)\u2225\u2225\u2225\u2225\u2225\u2225E(G\u0303(j\u2212\u03c4j)h \u2212Gjh)\u2225\u2225\u2225\u2225\u2225E\u2207\u03c8(i\u22121)h\u2225\u2225 \u2225\u2225E\u2207\u03c8(j\u22121)h\u2225\u2225 \u2264 1 L2 L\u2211 i=1 L\u2211 j=1\n(\u2225\u2225\u2225E(G\u0303(i\u2212\u03c4i)h \u2212 G\u0303ih)\u2225\u2225\u2225+ \u2225\u2225\u2225E(G\u0303ih \u2212Gih)\u2225\u2225\u2225)(\u2225\u2225\u2225E(G\u0303(j\u2212\u03c4j)h \u2212 G\u0303jh)\u2225\u2225\u2225+ \u2225\u2225\u2225E(G\u0303jh \u2212Gjh)\u2225\u2225\u2225)\u2225\u2225E\u2207\u03c8(i\u22121)h\u2225\u2225 \u2225\u2225E\u2207\u03c8(j\u22121)h\u2225\u2225 = 1\nL2 L\u2211 i=1 L\u2211 j=1 \u2225\u2225\u2225E(G\u0303(i\u2212\u03c4i)h \u2212 G\u0303ih)\u2225\u2225\u2225\u2225\u2225\u2225E(G\u0303(j\u2212\u03c4j)h \u2212 G\u0303jh)\u2225\u2225\u2225\u2225\u2225E\u2207\u03c8(i\u22121)h\u2225\u2225 \u2225\u2225E\u2207\u03c8(j\u22121)h\u2225\u2225 Applying (7) from Lemma 8, we have\nEA3 \u2264 max l \u2016E\u2207\u03c8lh\u20162 max l (Llflh)2 C2\u03c42h2 .\nCollecting low order terms from the above bounds, we have there exists some constantD2 independent of (L, h, \u03c4), such that\nE ( \u03c6\u0302\u2212 \u03c6\u0304 )2 \u2264C1 Lh + C2h 2K + max l \u2016E\u2207\u03c8lh\u20162 max l \u2016Ll\u20162 C2\u03c42h2\n\u2264D2 ( 1\nLh + M\u03031\u03c4\n2h2 + M\u03032h 2K ) ,\nwhere M\u03031 , maxl \u2016E\u2207\u03c8lh\u20162 maxl (Llflh)2 C2, M\u03032 , E ( 1 L(K+1)! \u2211 l L\u0303 K+1 l \u03c8(l\u22121)h )2 . This completes the proof."}, {"heading": "F Proof of Theorem 4", "text": "In the proof, we will use the following simple result stated Lemma 10. Lemma 10. Let (M1, \u00b7 \u00b7 \u00b7 ,MN ) be a set of independent martingale, i.e, E [Mn|F ] = 0, where F is the filtration generated byMn. Then we have\nE ( N\u2211 n=1 Mn )2 |F  = N\u2211 n=1 E [ M2n|F ] . (18)\nProof.\nE ( N\u2211 n=1 Mn )2 |F  = E  N\u2211 i=1 N\u2211 j=1 MiMj |F  =E\n[ N\u2211 i=1 M2i |F ] + \u2211 i 6=j E [Mi|F ]E [Mj |F ]\n= N\u2211 i=1 E [ M2i |F ] .\nIn the following we will omitted the filtration F in the expectation for simplicity. We we now ready to prove Theorem 4.\nProof. By definition, we have Var ( \u03c6\u0302L ) = E ( \u03c6\u0302L \u2212 \u03c6\u0304\u2212 ( E\u03c6\u0302L \u2212 \u03c6\u0304 ))2 Substitute (12) and (16) into the above equation, we have\n\u03c6\u0302L \u2212 E\u03c6\u0304 = \u2212 1\nLh \u2211 l ( E\u03c8(l\u22121)h \u2212 \u03c8(l\u22121)h ) \u2212 1 L \u2211 l (A1 \u2212 EA1)\u2212 \u2211 k hk\u22121 k!L \u2211 l (A2 \u2212 EA2)\u2212 hK (K + 1)!L \u2211 l (A3 \u2212 EA3) ,\nwhere\nA1 , \u2206Vl\u03c8(l\u22121)h\nA2 , L\u0303kl \u03c8(l\u22121)h A3 , L\u0303K+1l \u03c8(l\u22121)h .\nTake square on both sides, following by expectation, and note that all (Ai \u2212 EAi) are martingale for i = 1, 2, 3, which allows us to use (18) from Lemma 10. We have there exists a constant D independent of (L, h, \u03c4), such that\nVar ( \u03c6\u0302L ) \u2264 D  1 L2h2 E (\u2211 l ( E\u03c8(l\u22121)h \u2212 \u03c8(l\u22121)h ))2\n+ 1\nL2 \u2211 l E (A1 \u2212 EA1)2 + \u2211 k h2(k\u22121) (k!L)2 \u2211 l E (A2 \u2212 EA2)2\n+ h2K\n((K + 1)!L)2 \u2211 l\nE (A3 \u2212 EA3)2 )\n\u2264 D  1L2h2E (\u2211\nl\n( E\u03c8(l\u22121)h \u2212 \u03c8(l\u22121)h ))2 \ufe38 \ufe37\ufe37 \ufe38\nB1\n+ 1\nL2 \u2211 l E (A1 \u2212 EA1)2 + K\u2211 k=2 h2(k\u22121) (k!L)2 \u2211 l EA22 + h2K ((K + 1)!L)2 \u2211 l EA23\n) .\nAccording to Lemma 9, B1 is bounded by\nB1 = O\n( 1\nLh\n) .\nFurthermore, according to the assumptions, both EA22 and EA23 are bounded. The delayed parameter \u03c4 exists in E (A1 \u2212 EA1)2, we have\nE (A1 \u2212 EA1)2 =E ( \u2206Vl\u03c8(l\u22121)h \u2212 E\u2206Vl\u03c8(l\u22121)h )2 =E (( G\u0303(l\u2212\u03c4l)h \u2212Glh ) \u00b7 \u2207p\u03c8(l\u22121)h \u2212 E ( G\u0303(l\u2212\u03c4l)h \u2212Glh ) \u00b7 \u2207p\u03c8(l\u22121)h\n)2 Expanding the terms, we have there exists a constant D1 such that\nE (A1 \u2212 EA1)2 \u2264D1E ( G\u0303(l\u2212\u03c4l)h \u00b7 \u2207p\u03c8(l\u22121)h \u2212 EG\u0303(l\u2212\u03c4l)h \u00b7 \u2207p\u03c8(l\u22121)h )2 +D1E ( Glh \u00b7 \u2207p\u03c8(l\u22121)h \u2212 EGlh \u00b7 \u2207p\u03c8(l\u22121)h\n)2 =D1E ( G\u0303(l\u2212\u03c4l)h \u00b7 \u2207p\u03c8(l\u22121)h )2 +D1E ( Glh \u00b7 ( \u2207p\u03c8(l\u22121)h \u2212\u2207p\u03c8(l\u22121)h\n))2 \u2264D1 ( E \u2225\u2225\u2225G\u0303(l\u2212\u03c4l)h\u2225\u2225\u22252 E\u2225\u2225\u2207p\u03c8(l\u22121)h\u2225\u22252 + E \u2016Glh\u20162 E\u2225\u2225\u2207p\u03c8(l\u22121)h \u2212\u2207p\u03c8(l\u22121)h\u2225\u22252)\n\u2264D1 sup l\n{ E \u2225\u2225\u2225G\u0303lh\u2225\u2225\u22252 E \u2016\u2207p\u03c8lh\u20162 + E \u2016Glh\u20162 E \u2016\u2207p\u03c8lh\u20162} .\nAccording to the assumptions, the above bound is bounded, and does not depend on \u03c4 . As a result,\n1\nL2 \u2211 l E (A1 \u2212 EA1)2 \u2264 D1 L .\nIn addition, the bounds for both EA22 and EA23 are given in Lemma 9, which are higher-order terms with respect to h, i.e., O ( h2K ) .\nCollecting low order terms, we have there exists a constant D independent of (L, h, \u03c4), such that the variance is bounded by:\nVar ( \u03c6\u0302L ) \u2264 D ( 1\nLh + h2K\n) = D ( 1\nWL\u0304h + h2K\n) ."}, {"heading": "G Proof of Theorem 6", "text": "We separate the proof for the bias and MSE, respectively.\nProof for the bias. According to the definition of \u03c6\u0302SL, we have\n\u2223\u2223\u2223E\u03c6\u0302SL \u2212 \u03c6\u0304\u2223\u2223\u2223 = \u2223\u2223\u2223\u2223\u2223E S\u2211 s=1 Ts T \u03c6\u0302Ls \u2212 \u03c6\u0304 \u2223\u2223\u2223\u2223\u2223 =\n\u2223\u2223\u2223\u2223\u2223 S\u2211 s=1 Ts T E ( \u03c6\u0302Ls \u2212 \u03c6\u0304 )\u2223\u2223\u2223\u2223\u2223 \u2264\nS\u2211 s=1 Ts T \u2223\u2223\u2223E\u03c6\u0302Ls \u2212 \u03c6\u0304\u2223\u2223\u2223 =\nS\u2211 s=1 Ts T D1 ( 1 Lshs + ( M1\u03c4hs +M2h K s )) (19)\n=D1\n( S\nT + S\u2211 s=1 Ts T ( M1\u03c4hs +M2h K s\n))\n\u2264D1 ( S\nT + STm T\n( M1\u03c4hm +M2h K m )) , (20)\nwhere Tm , maxl Tl, hm , maxl hl, (19) follows by substituting the bias from Theorem 2 for each server into the formula.\nSimilarly, for the MSE bound, we have\nE ( \u03c6\u0302SL \u2212 \u03c6\u0304 )2 = E ( S\u2211 s=1 Ts T ( \u03c6\u0302Ls \u2212 \u03c6\u0304 ))2\n= S\u2211 s=1 T 2s T 2 E ( \u03c6\u0302Ls \u2212 \u03c6\u0304 )2 + \u2211 i 6=j TiTj T2 E [ \u03c6\u0302Li \u2212 \u03c6\u0304 ] E [ \u03c6\u0302Lj \u2212 \u03c6\u0304 ] \u2264 S\u2211 s=1 T 2s T 2 E ( \u03c6\u0302Ls \u2212 \u03c6\u0304 )2 + \u2211 i 6=j TiTj T 2\n\u2223\u2223\u2223E\u03c6\u0302Li \u2212 \u03c6\u0304\u2223\u2223\u2223 \u2223\u2223\u2223E\u03c6\u0302Lj \u2212 \u03c6\u0304\u2223\u2223\u2223 . Substituting the bounds for single chain bias and MSE from Theorem 2 and Theorem 3, respectively, we have\n\u2264 S\u2211 s=1 T 2s T 2 D\u20322 ( 1 Ts + ( M\u03031\u03c4 2h2s + M\u03032h 2K s )) + \u2211 i 6=j TiTj T 2 D1 ( 1 Ti + ( M1\u03c4hi +M2h K i )) D1 ( 1 Tj + ( M1\u03c4hj +M2h K j ))\n\u2264D2  1 T + S2 \u2212 S T 2 + \u2211 i,j TiTj T 2 ( M21 \u03c4 2h2m +M 2 2h 2K m ) \u2264D2 ( 1\nT + S2 \u2212 S T 2 + S2T 2m T 2\n( M21 \u03c4 2h2m +M 2 2h 2K m )) ,\nwhere D2 = max{D\u20322, D21}, Tm , maxl Tl, hm , maxl hl, the last equality collects the low order terms. This completes the proof."}, {"heading": "H Proof of Theorem 7", "text": "Proof. Following the proof of Theorem 6, for the variance, we have\nE ( \u03c6\u0302SL \u2212 E\u03c6\u0302 )2 = E ( S\u2211 s=1 Ts T ( \u03c6\u0302Ls \u2212 E\u03c6\u0302Ls ))2\n= S\u2211 s=1 T 2s T 2 E ( \u03c6\u0302Ls \u2212 \u03c6\u0304Ls )2 + \u2211 i 6=j TiTj T2 E [ \u03c6\u0302Li \u2212 E\u03c6\u0302Li ] E [ \u03c6\u0302Lj \u2212 E\u03c6\u0302Lj ]\n= S\u2211 s=1 T 2s T 2 E ( \u03c6\u0302Ls \u2212 \u03c6\u0304Ls )2 .\nSubstituting the variance bound in Theorem 4 for each server, we have\nE ( \u03c6\u0302SL \u2212 E\u03c6\u0302 )2 \u2264 D S\u2211 s=1 T 2s T 2 ( 1 Lshs + h2Ks )\n=D S\u2211 s=1 ( Ts T 2 + T 2s T 2 h2Ks )\n=D\n( 1\nT + S\u2211 s=1 T 2s T 2 h2Ks\n)"}, {"heading": "I Additional Results", "text": "See Figure 6 7 8 9 10 11. The content of the figures is described in the titles."}], "references": [{"title": "Online algorithms and stochastic approximations", "author": ["L. Bottou", "editor"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1998}, {"title": "Stochastic gradient descent tricks", "author": ["L. Bottou"], "venue": "Technical report, Microsoft Research, Redmond, WA,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Bayesian learning via stochastic gradient Langevin dynamics", "author": ["M. Welling", "Y.W. Teh"], "venue": "ICML,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Stochastic gradient Hamiltonian Monte Carlo", "author": ["T. Chen", "E.B. Fox", "C. Guestrin"], "venue": "ICML,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "Bayesian sampling using stochastic gradient thermostats", "author": ["N. Ding", "Y. Fang", "R. Babbush", "C. Chen", "R.D. Skeel", "H. Neven"], "venue": "NIPS,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2014}, {"title": "Distributed delayed stochastic optimization", "author": ["A. Agarwal", "J.C. Duchi"], "venue": "NIPS,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Large scale distributed deep networks", "author": ["J. Dean"], "venue": "In NIPS,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "MXNet: A flexible and efficient machine learning library for heterogeneous distributed systems", "author": ["T. Chen"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2015}, {"title": "TensorFlow: Large-scale machine learning", "author": ["M. Abadi"], "venue": "on heterogeneous systems,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "More effective distributed ML via a stale synchronous parallel parameter server", "author": ["Q. Ho", "J. Cipar", "H. Cui", "J.K. Kim", "S. Lee", "P.B. Gibbons", "G.A. Gibbons", "G.R. Ganger", "E.P. Xing"], "venue": "NIPS,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "Communication efficient distributed machine learning with the parameter server", "author": ["M. Li", "D. Andersen", "A. Smola", "K. Yu"], "venue": "NIPS,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Asynchronous parallel stochastic gradient for nonconvex optimization", "author": ["X. Lian", "Y. Huang", "Y. Li", "J. Liu"], "venue": "NIPS,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "Scalable inference in latent variable models", "author": ["A. Ahmed", "M. Aly", "J. Gonzalez", "S. Narayanamurthy", "A.J. Smola"], "venue": "WSDM,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Distributed stochastic gradient MCMC", "author": ["S. Ahn", "B. Shahbaba", "M. Welling"], "venue": "ICML,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2014}, {"title": "Large-scale distributed Bayesian matrix factorization using stochastic gradient MCMC", "author": ["S. Ahn", "A. Korattikara", "N. Liu", "S. Rajan", "M. Welling"], "venue": "KDD,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2015}, {"title": "Parallel stochastic gradient Markov chain Monte Carlo for matrix factorisation models", "author": ["U. Simsekli", "H. Koptagel", "Guldas H", "A.Y. Cemgil", "F. Oztoprak", "S. Birbil"], "venue": "Technical report,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2015}, {"title": "On the convergence of stochastic gradient MCMC algorithms with high-order integrators", "author": ["C. Chen", "N. Ding", "L. Carin"], "venue": "NIPS,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "Hogwild!: A lock-free approach to parallelizing stochastic gradient descent", "author": ["F. Niu", "B. Recht", "C. R\u00e9", "S.J. Wright"], "venue": "NIPS,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2011}, {"title": "An asynchronous mini-batch algorithm for regularised stochastic optimization", "author": ["H.R. Feyzmahdavian", "A. Aytekin", "M. Johansson"], "venue": "Technical Report arXiv:1505.04824, May", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2015}, {"title": "Asynchronous stochastic convex optimization: the noise is in the noise and SGD don\u2019t care", "author": ["S. Chaturapruek", "J.C. Duchi", "C. R\u00e9"], "venue": "NIPS,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Bayes and big data: The consensus Monte Carlo algorithm", "author": ["S.L. Scott", "A.W. Blocker", "F.V. Bonassi"], "venue": "Bayes 250,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2013}, {"title": "Variational consensus Monte Carlo", "author": ["M. Rabinovich", "E. Angelino", "M.I. Jordan"], "venue": "NIPS,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2015}, {"title": "Asymptotically exact, embarrassingly parallel MCMC", "author": ["W. Neiswanger", "C. Wang", "E.P. Xing"], "venue": "UAI,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2014}, {"title": "Parallelizing MCMC with random partition trees", "author": ["X. Wang", "F. Guo", "K. Heller", "D. Dunson"], "venue": "NIPS,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2015}, {"title": "Construction of numerical time-average and stationary measures via Poisson equations", "author": ["J.C. Mattingly", "A.M. Stuart", "M.V. Tretyakov"], "venue": "SIAM Journal on Numerical Analysis, 48(2):552\u2013577,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2010}, {"title": "A complete recipe for stochastic gradient MCMC", "author": ["Y.A. Ma", "T. Chen", "E.B. Fox"], "venue": "NIPS,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2015}, {"title": "Stochastic gradient Riemannian Langevin dynamics on the probability simplex", "author": ["S. Patterson", "Y.W. Teh"], "venue": "NIPS,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2013}, {"title": "Preconditioned stochastic gradient Langevin dynamics for deep neural networks", "author": ["C. Li", "C. Chen", "D. Carlson", "L. Carin"], "venue": "AAAI,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2016}, {"title": "Deep learning with elastic averaging SGD", "author": ["S. Zhang", "A.E. Choromanska", "Y. Lecun"], "venue": "NIPS,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2015}, {"title": "Distributed Bayesian learning with stochastic natural-gradient expectation propagation and the posterior server", "author": ["Y.W. Teh", "L. Hasenclever", "T. Lienart", "S. Vollmer", "S. Webb", "B. Lakshminarayanan", "C. Blundell"], "venue": "Technical Report arXiv:1512.09327v1, December", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2015}, {"title": "On Markov chain Monte Carlo methods for tall data", "author": ["R. Bardenet", "A. Doucet", "C. Holmes"], "venue": "Technical Report arXiv:1505.02827, May", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2015}, {"title": "Caffe: Convolutional architecture for fast feature embedding", "author": ["T. Jia", "E. Shelhamer", "J. Donahue", "S. Karayev", "J. Long", "R. Girshick", "S. Guadarrama", "T. Darrell"], "venue": "arXiv preprint arXiv:1408.5093,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2014}, {"title": "Weight uncertainty in neural networks", "author": ["C. Blundell", "J. Cornebise", "K. Kavukcuoglu", "D. Wierstra"], "venue": "ICML,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2015}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevshy", "I. Sutskever", "G.E. Hinton"], "venue": "NIPS,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2012}, {"title": "Non-)asymptotic properties of stochastic gradient Langevin dynamics", "author": ["S.J. Vollmer", "K.C. Zygalakis", "Y.W. Teh"], "venue": "Technical Report arXiv:1501.00438, University of Oxford, UK, January", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": "A basic technique is to adopt stochastic optimization algorithms [1], e.", "startOffset": 65, "endOffset": 68}, {"referenceID": 1, "context": ", stochastic gradient descent and its extensions [2].", "startOffset": 49, "endOffset": 52}, {"referenceID": 0, "context": "Under certain conditions, stochastic optimization is guaranteed to converge to a (local) optima [1].", "startOffset": 96, "endOffset": 99}, {"referenceID": 2, "context": "Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].", "startOffset": 157, "endOffset": 166}, {"referenceID": 3, "context": "Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].", "startOffset": 157, "endOffset": 166}, {"referenceID": 4, "context": "Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].", "startOffset": 157, "endOffset": 166}, {"referenceID": 5, "context": "In order to handle large-scale data, distributed stochastic optimization algorithms have been developed, for example [6], to further improve scalability.", "startOffset": 117, "endOffset": 120}, {"referenceID": 6, "context": "In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9].", "startOffset": 153, "endOffset": 162}, {"referenceID": 7, "context": "In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9].", "startOffset": 153, "endOffset": 162}, {"referenceID": 8, "context": "In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9].", "startOffset": 153, "endOffset": 162}, {"referenceID": 9, "context": "While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied.", "startOffset": 114, "endOffset": 126}, {"referenceID": 10, "context": "While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied.", "startOffset": 114, "endOffset": 126}, {"referenceID": 11, "context": "While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied.", "startOffset": 114, "endOffset": 126}, {"referenceID": 12, "context": "methods, such as [13], usually employ stale statistics instead of stale gradients, where stale statistics are summarized based on outdated parameters, e.", "startOffset": 17, "endOffset": 21}, {"referenceID": 12, "context": ", outdated topic distributions in distributed Gibbs sampling [13].", "startOffset": 61, "endOffset": 65}, {"referenceID": 13, "context": "For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].", "startOffset": 184, "endOffset": 196}, {"referenceID": 14, "context": "For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].", "startOffset": 184, "endOffset": 196}, {"referenceID": 15, "context": "For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].", "startOffset": 184, "endOffset": 196}, {"referenceID": 16, "context": "In this paper, by extending techniques from standard SG-MCMC [17], we develop theory to study the convergence behavior of SG-MCMC with Stale gradients (SG-MCMC).", "startOffset": 61, "endOffset": 65}, {"referenceID": 5, "context": "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].", "startOffset": 73, "endOffset": 76}, {"referenceID": 17, "context": "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].", "startOffset": 101, "endOffset": 105}, {"referenceID": 18, "context": "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].", "startOffset": 141, "endOffset": 149}, {"referenceID": 19, "context": "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].", "startOffset": 141, "endOffset": 149}, {"referenceID": 11, "context": "Furthermore, recent research on stochastic optimization has been extended to non-convex problems with provable convergence rates [12].", "startOffset": 129, "endOffset": 133}, {"referenceID": 20, "context": "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.", "startOffset": 104, "endOffset": 120}, {"referenceID": 21, "context": "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.", "startOffset": 104, "endOffset": 120}, {"referenceID": 22, "context": "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.", "startOffset": 104, "endOffset": 120}, {"referenceID": 23, "context": "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.", "startOffset": 104, "endOffset": 120}, {"referenceID": 16, "context": "In the analysis we consider algorithms with fixed-stepsizes for simplicity; decreasingstepsize variants can be addressed similarly as in [17].", "startOffset": 137, "endOffset": 141}, {"referenceID": 24, "context": "SG-MCMC algorithms are based on a class of stochastic differential equations, called It\u00f4 diffusion, defined as d xt = F (xt)dt+ g(xt)dwt , (1) where x \u2208 R represents the model states, typically x augments \u03b8 such that \u03b8 \u2286 x and n \u2264 m; t is the time index, wt \u2208 R is m-dimensional Brownian motion, functions F : R \u2192 R and g : R \u2192 Rm\u00d7m are assumed to satisfy the usual Lipschitz continuity condition [25].", "startOffset": 397, "endOffset": 401}, {"referenceID": 25, "context": "For appropriate functions F and g, the stationary distribution, \u03c1(x), of the It\u00f4 diffusion (1) has a marginal distribution equal to the posterior distribution p(\u03b8|D) [26].", "startOffset": 166, "endOffset": 170}, {"referenceID": 2, "context": "For example, denoting the unnormalized negative log-posterior as U(\u03b8) , \u2212 log p(\u03b8) \u2212 \u2211N i=1 log p(di |\u03b8), the stochastic gradient Langevin dynamic (SGLD) method [3] is based on 1st-order Langevin dynamics, with x = \u03b8, and F (xt) = \u2212\u2207\u03b8U(\u03b8), g(xt) = \u221a 2 In, where In is the n \u00d7 n identity matrix.", "startOffset": 161, "endOffset": 164}, {"referenceID": 3, "context": "The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin dynamics, with x = (\u03b8,q), and F (xt) = ( q \u2212B q\u2212\u2207\u03b8U(\u03b8) ) , g(xt) = \u221a 2B ( 0 0 0 In ) for a scalar B > 0; q is an auxiliary variable known as the momentum [4, 5].", "startOffset": 63, "endOffset": 66}, {"referenceID": 3, "context": "The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin dynamics, with x = (\u03b8,q), and F (xt) = ( q \u2212B q\u2212\u2207\u03b8U(\u03b8) ) , g(xt) = \u221a 2B ( 0 0 0 In ) for a scalar B > 0; q is an auxiliary variable known as the momentum [4, 5].", "startOffset": 252, "endOffset": 258}, {"referenceID": 4, "context": "The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin dynamics, with x = (\u03b8,q), and F (xt) = ( q \u2212B q\u2212\u2207\u03b8U(\u03b8) ) , g(xt) = \u221a 2B ( 0 0 0 In ) for a scalar B > 0; q is an auxiliary variable known as the momentum [4, 5].", "startOffset": 252, "endOffset": 258}, {"referenceID": 4, "context": "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.", "startOffset": 63, "endOffset": 66}, {"referenceID": 26, "context": "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.", "startOffset": 117, "endOffset": 129}, {"referenceID": 25, "context": "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.", "startOffset": 117, "endOffset": 129}, {"referenceID": 27, "context": "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.", "startOffset": 117, "endOffset": 129}, {"referenceID": 6, "context": "3 Stochastic Gradient MCMC with Stale Gradients In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.", "startOffset": 163, "endOffset": 172}, {"referenceID": 7, "context": "3 Stochastic Gradient MCMC with Stale Gradients In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.", "startOffset": 163, "endOffset": 172}, {"referenceID": 8, "context": "3 Stochastic Gradient MCMC with Stale Gradients In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.", "startOffset": 163, "endOffset": 172}, {"referenceID": 16, "context": "Bias and MSE In [17], the bias and MSE of the standard SG-MCMC algorithms with a Kth order integrator were analyzed, where the order of an integrator reflects how accurately an SG-MCMC algorithm approximates the corresponding continuous diffusion.", "startOffset": 16, "endOffset": 20}, {"referenceID": 2, "context": ", the popular Euler method used in SGLD [3] is a 1st-order integrator.", "startOffset": 40, "endOffset": 43}, {"referenceID": 16, "context": "In particular, [17] proved the bounds stated in Lemma 1.", "startOffset": 15, "endOffset": 19}, {"referenceID": 16, "context": "Lemma 1 ([17]).", "startOffset": 9, "endOffset": 13}, {"referenceID": 16, "context": "In addition to the assumptions in SG-MCMC [17] (see details in Appendix B), the following additional assumption is imposed.", "startOffset": 42, "endOffset": 46}, {"referenceID": 24, "context": "\u2217The existence of a nice \u03c8 is guaranteed in the elliptic/hypoelliptic SDE settings when x is on a torus [25].", "startOffset": 104, "endOffset": 108}, {"referenceID": 13, "context": "In addition, Theorem 6 with \u03c4 = 0 and K = 1 provides convergence rates for the distributed SGLD algorithm in [14], i.", "startOffset": 109, "endOffset": 113}, {"referenceID": 6, "context": "More advanced architectures More complex architectures could also be designed to reduce communication cost, for example, by extending the downpour [7] and elastic SGD [29] architectures to the SG-MCMC setting.", "startOffset": 147, "endOffset": 150}, {"referenceID": 28, "context": "More advanced architectures More complex architectures could also be designed to reduce communication cost, for example, by extending the downpour [7] and elastic SGD [29] architectures to the SG-MCMC setting.", "startOffset": 167, "endOffset": 171}, {"referenceID": 29, "context": "5 Experiments Our primal goal is to validate the theory, comparing with different distributed architectures and algorithms, such as [30, 31], is beyond the scope of this paper.", "startOffset": 132, "endOffset": 140}, {"referenceID": 30, "context": "5 Experiments Our primal goal is to validate the theory, comparing with different distributed architectures and algorithms, such as [30, 31], is beyond the scope of this paper.", "startOffset": 132, "endOffset": 140}, {"referenceID": 11, "context": "To quantitatively describe the speedup property, we adopt the the iteration speedup [12], defined as: iteration speedup , #iterations with a single worker average #iterations on a worker , where # is the iteration count when the same level of precision is achieved.", "startOffset": 84, "endOffset": 88}, {"referenceID": 31, "context": "The distributed system is developed based on an MPI (message passing interface) extension of the popular Caffe package for deep learning [32].", "startOffset": 137, "endOffset": 141}, {"referenceID": 32, "context": "In all these models, zero mean and unit variance Gaussian priors are employed for the weights to capture weight uncertainties, an effective way to deal with overfitting [33].", "startOffset": 169, "endOffset": 173}, {"referenceID": 33, "context": "LeNet consists of 2 convolutional layers, 2 max pool layers and 2 ReLU nonlinear layers, followed by 2 fully connected layers [34].", "startOffset": 126, "endOffset": 130}, {"referenceID": 0, "context": "References [1] L.", "startOffset": 11, "endOffset": 14}, {"referenceID": 1, "context": "[2] L.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] M.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[4] T.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5] N.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6] A.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7] J.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] T.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9] M.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[10] Q.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] M.", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12] X.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[14] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16] U.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "[17] C.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18] F.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19] H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[20] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[21] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[22] M.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[23] W.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[24] X.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "[25] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "[26] Y.", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "[27] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "[28] C.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "[29] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": "[30] Y.", "startOffset": 0, "endOffset": 4}, {"referenceID": 30, "context": "[31] R.", "startOffset": 0, "endOffset": 4}, {"referenceID": 31, "context": "[32] T.", "startOffset": 0, "endOffset": 4}, {"referenceID": 32, "context": "[33] C.", "startOffset": 0, "endOffset": 4}, {"referenceID": 33, "context": "[34] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 34, "context": "[35] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "B Assumptions First, following [25], we will need to assume the corresponding SDE of SG-MCMC to be either elliptic or hypoelliptic.", "startOffset": 31, "endOffset": 35}, {"referenceID": 34, "context": "Note (5) can be equivalently written in an integration form [35] using It\u00f4\u2019s formula: 1 t \u222b t", "startOffset": 60, "endOffset": 64}, {"referenceID": 24, "context": "This is satisfied if the SDE is defined in a bounded domain [25].", "startOffset": 60, "endOffset": 64}, {"referenceID": 16, "context": "In the unbounded domain as for SG-MCMC algorithms, it turns out the following boundedness assumptions on \u03c8 suffice [17].", "startOffset": 115, "endOffset": 119}, {"referenceID": 24, "context": "For other SG-MCMC algorithms such as the SGHMC, the hypoellipticity assumption is usually reasonable, see [25] on how to verify hypoellipticity of an SDE.", "startOffset": 106, "endOffset": 110}, {"referenceID": 34, "context": "To ensure the remainder term r`,F,\u03c6(x0) to be bounded, it suffices to make the following assumption on the smoothness and boundedness of F (x) [35, 17].", "startOffset": 143, "endOffset": 151}, {"referenceID": 16, "context": "To ensure the remainder term r`,F,\u03c6(x0) to be bounded, it suffices to make the following assumption on the smoothness and boundedness of F (x) [35, 17].", "startOffset": 143, "endOffset": 151}, {"referenceID": 16, "context": "The basic technique follows [17], thus we skip some derivations for some steps.", "startOffset": 28, "endOffset": 32}, {"referenceID": 16, "context": "Following [17], for an SG-MCMC with a Kth-order integrator, and a test function \u03c6, we have: E[\u03c8(xlh)] = ( I + hL\u0303l ) \u03c8(x(l\u22121)h) (11)", "startOffset": 10, "endOffset": 14}, {"referenceID": 16, "context": "According to [17], the term \u2211 l E[L\u0303 k l \u03c8(x(l\u22121)h)] is bounded by \u2211 l E[L\u0303 k l \u03c8(X(l\u22121)h)]", "startOffset": 13, "endOffset": 17}, {"referenceID": 16, "context": "From the proof of Theorem 3 in [17], A2 and A4 are also bounded, which are summarized in Lemma 9.", "startOffset": 31, "endOffset": 35}], "year": 2016, "abstractText": "Stochastic gradient MCMC (SG-MCMC) has played an important role in largescale Bayesian learning, with well-developed theoretical convergence properties. In such applications of SG-MCMC, it is becoming increasingly popular to employ distributed systems, where stochastic gradients are computed based on some outdated parameters, yielding what are termed stale gradients. While stale gradients could be directly used in SG-MCMC, their impact on convergence properties has not been well studied. In this paper we develop theory to show that while the bias and MSE of an SG-MCMC algorithm depend on the staleness of stochastic gradients, its estimation variance (relative to the expected estimate, based on a prescribed number of samples) is independent of it. In a simple Bayesian distributed system with SG-MCMC, where stale gradients are computed asynchronously by a set of workers, our theory indicates a linear speedup on the decrease of estimation variance w.r.t. the number of workers. Experiments on synthetic data and deep neural networks validate our theory, demonstrating the effectiveness and scalability of SG-MCMC with stale gradients.", "creator": "LaTeX with hyperref package"}}}