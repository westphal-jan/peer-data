{"id": "1611.04358", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Nov-2016", "title": "Character-level Convolutional Network for Text Classification Applied to Chinese Corpus", "abstract": "this article provides an interesting exploration of different character - level convolutional neural network solving chinese corpus mathematical text classification problem. we constructed a large - scale chinese language dataset, modeling and the result shows that character - level convolutional neural telegraph network works remarkably better on chinese corpus than its projected corresponding pinyin format dataset. this procedure is the first time using that character - level convolutional neural network applied to text classification problem.", "histories": [["v1", "Mon, 14 Nov 2016 12:24:27 GMT  (1953kb,D)", "https://arxiv.org/abs/1611.04358v1", null], ["v2", "Tue, 15 Nov 2016 14:41:23 GMT  (1953kb,D)", "http://arxiv.org/abs/1611.04358v2", "MSc Thesis, 44 pages"]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["weijie huang", "jun wang"], "accepted": false, "id": "1611.04358"}, "pdf": {"name": "1611.04358.pdf", "metadata": {"source": "CRF", "title": "Character-level Convolutional Network for Text Classification Applied to Chinese Corpus", "authors": ["Weijie Huang", "Jun Wang", "Yixin Wu", "Rui Luo"], "emails": [], "sections": [{"heading": null, "text": "Character-level Convolutional Network for Text Classification\nApplied to Chinese Corpus\nWeijie Huang\nA dissertation submitted in partial fulfillment\nof the requirements for the degree of\nMaster of Science\nin\nWeb Science & Big Data Analytics\nUniversity College London.\nSupervisor: Dr. Jun Wang\nDepartment of Computer Science\nUniversity College London\nNovember 16, 2016\nar X\niv :1\n61 1.\n04 35\n8v 2\n[ cs\n.C L\n] 1\n5 N\nov 2\n01 6\n2 I, Weijie Huang, confirm that the work presented in this thesis is my own.\nWhere information has been derived from other sources, I confirm that this has been indicated in the work.\nAbstract\nCompared with word-level and sentence-level convolutional neural networks (ConvNets), the character-level ConvNets has a better applicability for misspellings and typos input. Due to this, recent researches for text classification mainly focus on character-level ConvNets. However, while the majority of these researches employ English corpus for the character-level text classification, few researches have been done using Chinese corpus. This research hopes to bridge this gap, exploring character-level ConvNets for Chinese corpus test classification. We have constructed a large-scale Chinese dataset, and the result shows that character-level ConvNets works better on Chinese character dataset than its corresponding pinyin format dataset, which is the general solution in previous researches. This is the first time that character-level ConvNets has been applied to Chinese character dataset for text classification problem."}, {"heading": "Acknowledgements", "text": "I gratefully acknowledge the support of my family. My mom and dad have provided me with the chance to study aboard, and I applicate it. I would like to thank Supervisor Dr. Jun Wang, Ph.D. student Yixin Wu, Rui Luo for their helpful feedback and advice. I have learned a lot from them during the meeting every week. Their enthusiasm for the research encourages me to finish this thesis. And also I would like to thank Institute of Education student, my roommate, Qing Xiang. She corrects lots of grammar mistakes that I did not realize in her spare time. Finally, I would like to thank Arsene Wenger that brings several new players from transfer market this two months, so that I can mainly focus on my thesis with an optimistic attitude.\nContents"}, {"heading": "1 Introduction 9", "text": "1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n1.2 Previous solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n1.3 Research problems . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.4 Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.5 Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14"}, {"heading": "2 Related work 15", "text": "2.1 Traditional models . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.1.1 Bag of Words . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.1.2 N-gram . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n2.1.3 Bag of tricks . . . . . . . . . . . . . . . . . . . . . . . . . 16\n2.1.4 Graph representation classification . . . . . . . . . . . . . . 17\n2.2 Neural Network models . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.2.1 Recrusive Neural Network . . . . . . . . . . . . . . . . . . 17\n2.2.2 Recurrent Neural Network . . . . . . . . . . . . . . . . . . 17\n2.2.3 Convolutional Neural Network . . . . . . . . . . . . . . . . 17\n2.2.4 Convolutional Neural Network and Recurrent Neural Network 20"}, {"heading": "3 Proposed solution 22", "text": "3.1 Data preprocessed . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n3.2 Embedding Layer . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n3.3 Convolutional Layer . . . . . . . . . . . . . . . . . . . . . . . . . 25\nContents 6\n3.4 Fully-Connected Layer . . . . . . . . . . . . . . . . . . . . . . . . 26"}, {"heading": "4 Results and Discussion 27", "text": "4.1 The factors that influenced the ConvNets when applied to pinyin\nformat dataset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 4.1.1 Task description . . . . . . . . . . . . . . . . . . . . . . . 27 4.1.2 Dataset Description . . . . . . . . . . . . . . . . . . . . . . 27 4.1.3 Model setting . . . . . . . . . . . . . . . . . . . . . . . . . 28 4.1.4 Result and Discussion . . . . . . . . . . . . . . . . . . . . 29\n4.2 The comparison between Chinese character and its corresponding\npinyin format dataset . . . . . . . . . . . . . . . . . . . . . . . . . 31 4.2.1 Task description . . . . . . . . . . . . . . . . . . . . . . . 31 4.2.2 Dataset Description . . . . . . . . . . . . . . . . . . . . . . 32 4.2.3 Model setting . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.2.4 Result and Discussion . . . . . . . . . . . . . . . . . . . . 33"}, {"heading": "5 Conclusion 37", "text": "Appendices 38"}, {"heading": "A User Manual 38", "text": "A.1 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 A.2 Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 A.3 Example Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 A.4 Licence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\nBibliography 40\nList of Figures\n1.1 The relation between Chinese character and its pinyin format.\nListed in the figure are two types of pinyin encoding format A and B. Type A combines the tone and character, while type B separate the tone and character. . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.1 The architecture of proposed model. The number \u20183, 128\u2019 in the\nconvolutional layer represents the kernel size and feature maps number respectively. The \u2018100\u2019 in the fully-connected layer represent the output dimension. The \u20185\u2019 in the output layer indicates that there are five pre-defined labels. . . . . . . . . . . . . . . . . . 23\n3.2 Two kinds of encoding. The input characters are a, b, c, and d, while\nthe encoding matrix can represent the characters respectively. . . . . 24\n4.1 The dictionary of pinyin format encoding dataset (including a blank\ncharacter). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n4.2 The comparison between different models\u0301 dictionary. . . . . . . . . 30 4.3 A misunderstanding example indicates the importance of word seg-\nmentation in Chinese language. . . . . . . . . . . . . . . . . . . . . 33\n4.4 For the same length, Chinese characters contain more information. . 35\nList of Tables\n2.1 The comparison between different related work models. . . . . . . . 15\n4.1 The comparison between previous models and various proposed\nmodels. The table including parameters, error rate, network structure, and the feature maps hyper-parameters. The best models\u0301 error rate is in bold. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n4.2 The comparison between different datasets, including the Chinese\ncharacter and pinyin format. The star indicates that dataset expand by data augmentation. . . . . . . . . . . . . . . . . . . . . . . . . . 32\n4.3 The comparison between different setting and encoding dataset.\nThe results show that Chinese character works better than pinyin format. The result of Bag of Words and N-gram came from Zhang[41], which are the references of this task. The ConvNets with star means the dataset are expanded via data augmentation. . . 34\nChapter 1\nIntroduction"}, {"heading": "1.1 Background", "text": "Natural language processing (NLP) is the field in which through analysing data, the machine can extract information from contexts and represent the input information in a different way[6]. Generally speaking, NLP involves the following three tasks. Part-Of-Speech tagging (POS), such as text or image classification, to classify the data with different categories; Chunking (CHUNK), to label the segment of a given sentence by using syntactic and semantic relations; and Named Entity Recognition (NER), to tag named entities in text[5]. These tasks are varied, ranging from character-level to word-level and even to sentence-level. Nevertheless, they have the same purpose of finding out the hierarchical representations of the context[6].\nOne of the classic tasks for NLP is text classification, also known as document\nclassification[4]. This task aims to assign a pre-defined label to the document. Usually, two stages are involved in the process which are feature extraction and labels classification. In the first stage, some particular word combinations such as bigram, trigram, term frequency, and inverse document frequency of the phrase can be used as features.[5] Take BBC sports website for example, in its content, there are many specific Premier League team names, which can serve as corresponding features for the following classification. These features can then, in the second stage, help to maximise the accuracy of the task.\n1.2. Previous solutions 10"}, {"heading": "1.2 Previous solutions", "text": "A common approach to text classification is to use Bag of Words[8] , N-gram[2], and their term frequency-inverse document frequency (TF-IDF)[33] as features, and traditional models such as SVM[14], Naive Bayes[25] as classifiers. However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1]. ConvNets, originally invented by LeCun[20] for computer vision, refers to the model that uses convolution kernels to extract local features. Analyses have shown that ConvNets is effective for NLP tasks[40][30], and the convolution filter can be utilised in the feature extraction stages. Compared with the model listed above, ConvNets, when applied to text classification has shown rather competitive results[41][5][16][6]. The theory behind is quite similar to that of computer vision and speech recognition task. During the process in the convolutional layers, convolutional kernels would first treat the input text as a 1D-image. Then by using a fixed size convolution kernel, it can extract the most significant word combination such as the English Premier League in the sports topics. After hierarchical representations of the context are constructed, these features are then fed into a max-pooling layer for feature extraction, and the output result can represent the most important feature on this topic. In other words, the 1D-ConvNets can be regarded as a high-level N-grams feature classifier. With the help of ConvNets, we can classify the unlabelled document without using syntactic or semantic structures of a particular language. This is unusual in most of the large-scale dataset. Also, since the ConvNets method can handle the misspelling problem, it works well for user-generated data[41].\nRecent approach of using ConvNets on text classification mainly works at the\nword-level [5] [16]. In Kims\u0301 research, he found that pre-trained words embedding could gain a slight improvement on performances. Also, the multi-channel model allows the randomly initialised tokens to learn more accurate representations during the task. When different regularisers are applied, dropout layer proved to work well in the task, increasing by 4% in relative performance. Although this\n1.3. Research problems 11\napproach has achieved great success, some limitations remain. Firstly, when wordlevel ConvNets is applied in the classification task, the words sharing a common root, prefix or suffix tend to be treated as separate words. For instance, the words \u201csurprise\u201d and \u201csurprisingly\u201d are treated as two words without any relation in the model, which is counterintuitive. Secondly, the dimension of the input layer is related to the dictionary of the words. Due to the common root issue, the dimension up to 6,000 may lead to a sparse problem, which will significantly influence the performance. Thirdly, the words which are not presented in the training set will be marked as out-of-vocabulary words (OOV) and then simply replaced with a blank character. This problem frequently occurs in our test corpus, which may lead to serious consequences. Also, since some of the classification datasets are postings directly collected from the social network, these corpora are mixed with typos and abbreviations. This may diminish the classification accuracy of the task[37].\nIn the last few years, many researchers found that it is also likely to train a\nConvNets at the character-level[41][37][6]. The researchers still used one-hot or one-of-m encoding, and the vectors are transformed from the raw character to the dense vectors. Kim used a character sequence as an input in his language model[17], and Dhingra applied this idea to predict the hashtags[7]. The character-level ConvNets can avoid the problems as mentioned earlier from word-level. Firstly, since the units in the model are now the character, we can prevent the problem that some words sharing the same prefix or suffix do not show any relations. Secondly, the dictionary of character-level ConvNets are the size of the alphabet plus some symbols, and the dimension is around 70 in most of the character-level model. Due to this small dimension, the sparse problem can now be solved. Thirdly, since the choice of the alphabet is the same in both the training set and the test set, no more OOV appears in the test dataset. A significant improvement can be observed in which the model can better handle the typos with fewer parameters."}, {"heading": "1.3 Research problems", "text": "In this area, some research problems remain.\n1.3. Research problems 12\nFirst of all, after a thorough search of relevant literature, it seems that no re-\nsearchers have yet applied the character-level convolutional network to the Chinese character. Only some of the NLP tasks are based on pinyin encoding. Pinyin input is one of the most popular forms of text input in the Chinese language[3]. This method represents the Chinese characters in an alphabetic way according to its pronunciation (See Figure 1.1). Previous researchers such as Mathew used pinyin format dataset as input to detect spam in mobile text message[24] and Liu, similarly, using pinyin format dataset for feature selection[23], proved that pinyin format dataset could be utilised as an efficient method to solve the NLP problems. Unlike the English language, there is no gap between the characters in the Chinese language. However, the word segmentation still plays a significant role in understanding the sentence meaning.\nSecondly, how can the Chinese corpus gain benefit from the ConvNets when\nnot only the pinyin encoding but also the Chinese character lack language root? As we observed, the previous datasets mainly involve English corpus, language roots such as prefix and suffix are indicated to contribute to ConvNets s\u0301 ability to solve the typo problem in NLP.\n1.4. Contribution 13\nThirdly, the information compression among pinyin format, Chinese charac-\nters, and English may lead to different performances. For example, in the Chinese language, there are only 406 syllable combinations can be found in pinyin format representation among more than 6,000 commonly used Chinese characters, which means that some information is compressed during the transforming[3]. Another example is between English and Chinese, Twitter and Weibo, two popular online social networks, have a 140-word limit for each posting. However, since two different language systems, Roman alphabet and Chinese character alphabet, are mainly used respectively on Twitter and Weibo. Twitter can only provide titles and short web links while Weibo can afford more detailed information. Moreover, since more than 100 possibilities of word or character choice are available for the same pronunciation, it remains unclear whether the ConvNets can gain a representation from pinyin dataset in text classification task.\nThe tasks are yet to be solved due to the lack of large-scale Chinese charac-\nter dataset, and we believe that by concentrating on the following three parts, we can solve these tasks. Firstly, we will compare our proposed model with previous models on the pinyin format dataset. In this particular task, pinyin encoding on text classification task, we will find out the most important factors according to different experiments such as various depth and choice of alphabet. Secondly, the neural network model often requires a large-scale dataset so that the model can better extract features for classifying. To solve the problem of missing Chinese character dataset, an entirely new Chinese character dataset and its corresponding pinyin encoding dataset will be constructed. Finally, we will evaluate our models on these two datasets to find out the better solution."}, {"heading": "1.4 Contribution", "text": "Firstly, this thesis applies the character-level convolutional neural network to Chinese character dataset, which is rarely researched in this NLP area. The result shows that Chinese character dataset has generated a better result than its corresponding pinyin encoding. Secondly, we have reached the state-of-the-art in this specific task\n1.5. Structure 14\namong all the other narrow character-level convolutional neural network. Besides, we are the first one who constructed a large-scale Chinese character dataset. Moreover, we have extended the pinyin format that reached millions level compared with the previous one."}, {"heading": "1.5 Structure", "text": "In this chapter, we have provided some background information concerning natural language processing, deep learning models, and Chinese language. Also, we have outlined the research questions and fundamental information about our model. Following this, Chapter 2 discusses and compares related work of text classification. Then in Chapter 3, we describe the architecture of our model. Next, in Chapter 4, we show the details of experimental results and hyper-parameter settings during the process. We also introduce our latest constructed datasets. After this, some observation is discussed. Finally, in Chapter 5, we conclude the work that has been done so far and forecast the future directions.\nChapter 2\nRelated work\nIn terms of text classification, various researchers employ different algorithms.\nThese approaches follow the same scheme, which is feature extraction followed by classification. Traditional models include SVM [14], Naive Bayes [25], Bag of Words [8], N-gram[2], and their TF-IDF [33] version. In previous researches, these algorithms have been evaluated, and most of them provide a competitive result."}, {"heading": "2.1 Traditional models", "text": ""}, {"heading": "2.1.1 Bag of Words", "text": "The early references of Bag of Words concept can be found in \u201cDistributional structure\u201d by Harris. This model uses the counts of the most common words that appear in the training set as the feature[8]. This model can classify the topics with the help of these keywords. For example, the three keywords \u201cDow\u201d \u201cJones\u201d \u201cIndexes\u201d may have a much more frequent appearance in the articles of the stock topic than sports\n2.1. Traditional models 16\ntopic. However, since some of the words appear in each of these topics, this may influence the result. That is why the TF-IDF version Bag of Words add one extra feature, the inverse document frequency, to diminish this influences. This model is also based on the word-level, which means many words that share the same word stem but not the same count. In some way, by using the stemming technique, we can avoid this problem, yet not all the words containing same word stem have approximative meaning, which may lead to another problem. The result in Zhangs\u0301 paper[41] shows that Bag of Words model and its TF-IDF version can achieve great performances in most of the tasks."}, {"heading": "2.1.2 N-gram", "text": "The N-gram model in text classification task can be seen as an extension of the Bag of Word model[2]. An N-gram model is commonly used in the language model. Unlike the Bag of Word model above, the N-gram model uses the most frequent N-continuous word combinations selected from the dataset as the features. For instance, the model would calculate the appearance of word combination \u201cDow Jones Indexes\u201d in all of the topics before applying the predefined class that ranks the most. TF-IDF version also adds the inverse document frequency to avoid the common words problem. This model is widely used in NLP area because of its trait, simplicity, and scalability. Zhangs\u0301 result shows that N-gram model achieved excellent performances in the small dataset, especially the TF-IDF version, ranking the first in three of the dataset."}, {"heading": "2.1.3 Bag of tricks", "text": "Bag of tricks is a straightforward and efficient approach for text classification. This algorithm can train the model in no more than ten minutes on one billion words, and classify a large number of datasets among millions of classes within a minute[15]. It is one of the greatest models so far as a traditional model in this area. In one hand, this model can be trained in a fast speed. On the other hand, the result is quite close compared with the state-of-the-art that using character-level ConvNets.\n2.2. Neural Network models 17"}, {"heading": "2.1.4 Graph representation classification", "text": "Yoshikawa[38] proposed a fast training method for text classification which is based on graph classification. This method treats the input text as a graph, and the graph structure can better represent the text structure. The result shows that graph representation can exploit rich structural information of texts, and this is the key to improving their accuracy."}, {"heading": "2.2 Neural Network models", "text": "There is also a large amount of research using deep learning methods to solve the text classification problem."}, {"heading": "2.2.1 Recrusive Neural Network", "text": "A recursive neural network often comes with a parser. In Socher\u2019s[32] work, a parse tree is being used in the feature extraction stage. However, most of the dataset will not come with a parser, which means this kind of model is not general enough. As we observed, no related models are being released these two years."}, {"heading": "2.2.2 Recurrent Neural Network", "text": "A recurrent neural network is like a particular recursive neural network. This model brings in the data sequentially, mostly from left to right, sometimes it may be bidirectional. Liu [22] solved the sentiment analytics task using this model. An embedding layer followed by a recurrent layer is used to extract feature and then fed into the classification layer."}, {"heading": "2.2.3 Convolutional Neural Network", "text": "Research has also shown that ConvNets is effective for NLP tasks [5][4], and the convolutional filter can be utilised in the feature extraction stages.\nKim was one of the earliest researchers who used convolutional neural net-\nworks (ConvNets) for sentence classification[16].\nIn this paper, Kim[16] proposed a word-level shallow neural network with one\nconvolutional layer using multiple widths and filters followed by a max-pooling layer over time. The fully-connected layer with drop-out layer can then combine\n2.2. Neural Network models 18\nfeatures and send to the output layer. The word vectors in this model were initialised using the publicly available word2vec, which was trained on 100 billion words from Google News[26]. The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32]. The classes of those datasets are between two to six, and the dataset size is from 3,775 to 11,855. Kim selected the stochastic gradient descent (SGD) and Ada-delta update rule[39] for his model.\nThe paper shows that the unsupervised pre-training of word vectors is an im-\nportant part of word-level ConvNets for NLP. Also, the temporal k-max pooling layer can capture and provide much more capacity because of the multiple filter widths and feature maps. Finally, dropout layer proved to be a good regulariser that adds performance. However, there are still some ways to explore. Only one convolutional layer was constructed in this ConvNets, while the trend in computer vision where significant improvements have been reported using much deeper networks, 19 layers[31], or even up to 152 layers[9]. Also, due to the small size of the dataset, the word-level ConvNets for NLP is yet to prove.\nZhang was the first one who proposed an entirely character-level convolutional\nnetworks for text classification[41].\nThere are two different ConvNets illustrated in this paper and the difference\nbetween them is the feature map size. Both of their depth are eight, consists of six convolutional layers and two fully-connected layers. The pooling layers follow the convolutional layers. Convolutional kernels of size seven are used in the first two layers, and the rest of the four layersk\u0301ernel size are three. There are also two dropout layers between the three fully-connected layer to regularise the loss. The input of this model is a sequence of encoding vectors, which is done by \u2018applied an alphabet of size n for the input documents, and then quantise each character using one-hot encoding[41]\u2019. However, Zhang did not use any pre-trained method\n2.2. Neural Network models 19\nsuch as word2vec[26] for the input word vectors in the model. By Contrast, Zhang used data augmentation techniques to enhance their performances by an English thesaurus. Also, they distinguish the upper-case and lower-case letters. However, the results show that worse result when such distinction is made. Moreover, Zhang constructed eight large-scale datasets to fill the vacancy in this NLP task. The eight large-scale datasets are Ags\u0301 News, Sogou News corpus, DBPedia, Yelp Reviews, Yahoo Answers, and Amazon Reviews. Their size is from 120,000 to 3,600,000, and the classes are between two and fourteen. A comparison was made among traditional models such as SVM[14], Naive Bayes [25], Bag of Words, N-grams[2], and their TF-IDF version[33], also among deep learning models such as word-level ConvNets and long-short-term memory model(LSTM)[11]. The result shows that Bag-of-Means were the worst models among all 22 different models\u0301 setting, and their testing error is the highest among all the dataset. N-gram model gained the lowest error rate in Yelp Review Polarity, and its TF-IDF version reached the best result in AGs\u0301 News, Sogou News, DBPedia. Different settings of the ConvNets attained the lowest error rate in the rest of four datasets.\nThe paper shows that character-level ConvNets is an efficient and potential\nmethod due to their performance mentioned above. As we can observe in the result, when the dataset size comes large, the ConvNets models can do better than traditional models. Also, ConvNets work well for user-generated data, which means the ConvNets may be suitable in real-world scenarios. Then, for large-scale datasets, the distinction between the selection of upper letters and lower letters may lead to a worse result. However, the result is varied indicates that no single model works for all of the tasks or datasets.\nConneau[6] was the first one who implemented a very deep convolutional ar-\nchitecture which is up to 29 convolutional layers (9, 17, 29, 49 respectively) and applied to sentence classification.\nThere is a look-up table creating vectorial representations fed into the model,\nwith a convolutional layer behind. Then a stack of temporal \u201cConvolutional blocks\u201d which are a sequence of two convolutional layers, each one followed by a temporal\n2.2. Neural Network models 20\nbatch-normalization layer and a ReLU activation function. Different depths of the overall architecture are obtained by varying the number of convolutional blocks in between the pooling layers. The k-max pooling layer is followed to obtained the most important features of the stack of convolutional blocks[6]. Finally, the fullyconnected layers output the classification result. In this model, Conneau did not use \u2018Thesaurus data augmentation\u2019 or any other preprocessing, except lower-case the texts. The datasets in this paper are the same corpora of Zhang and Xiao [37], and the best results of them are the baseline in this article. The results show that the deep architecture works well when the depth increased, and the improvements are significant especially on large data sets compared with Zhangs\u0301 convolutional models.\nMost of the previous application of shallow ConvNets to NLP tasks combin-\ning different filter size together. They indicate that the convolution layers can extract N-gram features over tokens. However, in this work, Conneau [6] created an architecture which used many layers of small convolutional kernel, which is size three. Compared with Zhangs ConvNets architecture, Conneau[6] found that better not to use dropout layer with the fully-connected layers, but only temporal batch normalization[13] after convolutional layers. At the same time, Conneau evaluates the impact of shortcut connections by increasing the number of convolution to 49 layers. As described in He[9], the gain in accuracy due to the increase of the depth is limited when using standard ConvNets. To overcome the degradation problem, He introduced ResNet model that allow gradients to flow more easily in the network. Moreover, as Conneau observed, they found improvement results when the network has 49 layers. However, they did not reach state-of-the-art results under this setting."}, {"heading": "2.2.4 Convolutional Neural Network and Recurrent Neural Net-", "text": "work\nThere are also some researches that combine both ConvNets and Recurrent Neural Network[37][34].\nXiao[37] combined both convolutional network and recurrent network to ex-\ntract the features and applied to sentence classification.\n2.2. Neural Network models 21\nThe following model contains embedding layer, convolutional layers, recur-\nrent layers and the classification layers which are one, three, one, and one layers respectively. The convolutional network with up to five layers is used to extract hierarchical representations of features which serve as input for an LSTM. The word vectors were not pre-trained, while there is an embedding layer to transform the \u201cone-hot vectors\u201d into a sequence of dense vectors. The eight datasets in this paper are the same as Zhang, and Xiao, show that it is possible the use a much smaller model to achieve the same level performance when a recurrent layer is added on top of the convolution layers. There are five datasets that Xiao reached a better result than Zhang, which is AGs News, Sogou, DBPedia, Yelp Review full and Yahoo Answers. The rest of the result are closed. However, the parameters in Xiaos model are much less than Zhangs\u0301 model.\nCompared with the character-level convolutional neural network model, this\nmodel achieved comparable performances for all the eight datasets. By reducing the number of convolutional layers and fully-connected layers, this model is with significantly fewer parameters, up to 50 times less, which means that they generalised better when the training size is limited. Also, this paper shows that the recurrent layer can capture long-term dependencies to solve the problem that convolutional layers usually require many layers due to the locality of the convolution and pooling. Moreover, the model achieves a better result when the number of classes increases compared with ConvNets models. It is mainly because the less pooling layer in hybrid models can preserve more detailed and complete information. Finally, there is an optimal level of local features to be fed into the recurrent layer, because Xiao noticed that the model accuracy does not always increase with the depth of convolutional layers[37].\nIn summary, all of the related work models are based on Roman alphabet cor-\npus. In this paper, we will describe our character-level convolutional neural network model applied to both Chinese character and its pinyin format and report the result on the latest large-scale dataset.\nChapter 3\nProposed solution\nIn this chapter, we present the model architecture in detail. There are four components in our model, which are data preprocessed, embedding layer, convolutional layers and fully-connected layers."}, {"heading": "3.1 Data preprocessed", "text": "Our model begins with a data preprocessed stage. This stage is used for transforming the original characters to encoded characters. There are two types of the encoding method (See Figure 3.1) which are one-hot encoding and one of m encoding (Sparse coding). For the one-hot encoding, each word in the sentence is represented as a one-hot vector. The i-th symbol in this vector is set to one if it is the i-th element, while the rest of the symbol are remain zero[41]. However, we use the one of m encoding in our model. For the input corpus, we firstly construct an alphabet size equal to S, then used this dictionary to quantise each character, and the characters which are not in the alphabet will be replaced by a blank. Also, we set the maximum length of each sequence to L, and the exceeding part will be ignored, and the missing part will be replaced by zero, using zero-padding. Therefore, we can get a dense S sized vector with solid size L.\nAccording to previous researches, the quantisation order will be reversed. Usu-\nally, when we receive the information, the latest content will leave a deeper impression compared with the early one. According to this assumption, by reversing the encoding order, the most recent content can help the fully-connected layer to gain a\n3.1. Data preprocessed 23\nbetter result[41].\nDue to the differences between English and pinyin, the alphabet for pinyin in-\nput are different. In previous researches[41][6], the alphabet size are 71 and 72 characters respectively. However, according to our experiment result, some trait of\n3.2. Embedding Layer 24\npinyin encodings such as no uppercase letter in the alphabet and not all 26 Roman letters included in the pinyin alphabet, therefore, we picked 42 characters to construct our dictionary. The smaller alphabet size efficiently decreases the parameters and improves the performances. For the Chinese character input, the dictionary is much larger than the pinyin input, reached to 6,653 characters, which are the words that appears in the dataset. The different size of dictionary between pinyin and Chinese character can help us understand how the dimension influences the result."}, {"heading": "3.2 Embedding Layer", "text": "As we can see from the Fig 3.2, embedding Layer accepts a two-dimensional tensor of size S * L which is the encoded character sequence. Usually, the embedding layer is used for decreasing the dimension of the input tensor. Also, the zero-padding help to transform the input tensor into a fixed size. However, as we have finished these two process in the previous stages, we can naturally treat the embedding layer as a look-up table. After the processed in embedding layer, the output shape can be treated as an image of size S * L, while the S is like the \u2018RGB\u2019 dimension in computer vision. By converting the input character into the one-dimension vector, the ConvNets can then extract the feature by the convolutional kernel.\n3.3. Convolutional Layer 25"}, {"heading": "3.3 Convolutional Layer", "text": "In convolutional layers, we apply up to three 1D-Convolution layers which have kernel size equal to three and feature map equal to 128. The operation of convolution is widely used in signal and image processing. For the 1D-Convolution we used, there are two signals which are text vector and kernel. After the process, the convolutional operation created a third signal which is the output. The text vector f is the output from the embedding layer, and the g is the kernel. For the text vector f, its length is n equal to 1,000 in our setting (for Chinese character is 300) while kernel g has length m which is 3. Here is the definition of the operation between f and g (The formula is also refer to Cornell University CS1114 courses, section6) :\n( f \u2217g)(i) = m\n\u2211 j=1 g( j)\u2217 f (i\u2212 j+m/2)[41]\nWe can imagine the calculation is the kernel slides from the very beginning to\nthe end (including the zero-padding part), so that the 1D-convolution can extract features from the text input. Every kernel will be represented as a specific feature.\nAlso, each layer is initialised by henormal[10], and the border mode is same,\nwhich means the length remains 1,000 during this stages. In previous researches such as N-gram language model, researchers combine a different kind of N-gram such as bigram and trigram as the features, to extract multiple combinations of words from the dataset. The results show this setting can decrease the perplexity in the language model. However, latest work suppose that we can use deeper model and unify kernel size to extract features efficiently. Encouraged by Conneaus work[6], we only used the kernel size equal to three, so that during this period, the layers can automatically best combine these different \u201ctrigram\u201d features in various layers.\nWe used the ReLU[27] as our nonlinear activation function, which is widely\nemployed in recent researches. Unlike the \u2018sigmoid function, this activation function can better handle the gradient vanishing problem. Also, the threshold in ReLU can better simulate the brain mechanism of human. L2 regulation is being used in all these layers because it is quite efficient for solving the overfitting problem. The\n3.4. Fully-Connected Layer 26\noutput of the convolutional layer is a tensor of size 128 * 1000. They are the hierarchical representations of the input text. The convolutional layers can automatically extract N-gram features from the padded text, and these features can represent the hidden long short term relation in the text. In computer vision area, convolutional kernels are able to construct the pattern from the very beginning units, such as pixel, line, and shape. Meanwhile, the structure in NLP is similar, including character, word, and sentence. The similar properties in these two areas make the ConvNets interpretable.\nFinally, the max-pooling layer followed by the convolutional layer is necessary.\nThere are varies types of pooling layers such as max-pooling layer and average pooling layer[6]. The pooling layer can select the most important features from the output of 1D-convolution. Also, it can diminish the parameters to accelerate the training speed. We chose the temporal max-pooling with kernel size equal to the feature maps number, which means only the most important feature remains in this stage. At last, by using the flatten function, these features will be sent to the fully-connected layer with size 128 * 1 as a 1D tensor."}, {"heading": "3.4 Fully-Connected Layer", "text": "The fully-connected layer also knows as the dense layer. At this stage, all the resulting features that selected from the max-pooling layer are combining. As we mention earlier, the max-pooling layer selects the k-most feature from each convolutional kernel. The fully-connected layer can combine most of the useful assemble and then construct a hierarchical representation for the final stage, the output layer.\nThe output layer used \u2018softmax\u2019 as the nonlinear activation function, and there\nis five neurones because of the number of the target classes. Unlike the current state of the art, Conneau did not use any dropout layers between the fully-connected layers. For a very deep architecture model, the batch normalization layer may be a better choice. However, because our model is not that deep, we still apply the dropout layer and set the dropout rate to \u20180.1\u2019.\nChapter 4\nResults and Discussion\nIn this chapter, we will present our results and findings from the following two tasks. The first task is about the factors that may influence the ConvNets when the dataset is pinyin format. Compared with the previous models, we can find out the best setting for pinyin format. Following this, we evaluated our model on pinyin format dataset with task 1 setting and Chinese character dataset in task 2. The detail information is as follow."}, {"heading": "4.1 The factors that influenced the ConvNets when", "text": "applied to pinyin format dataset"}, {"heading": "4.1.1 Task description", "text": "In this task, we validated our models on one of the eight datasets in Zhang[41] s research. This dataset aiming to solve the news categorisation problem is widely used in different researches. The dataset was collected from Sogou[35], and the encoding is pinyin format. By comparing our models with previous researches on the same dataset, we prove that our model can achieve state-of-the-art result with fewer parameters and faster training speed among all the narrow ConvNets."}, {"heading": "4.1.2 Dataset Description", "text": "In computer vision area, there are many large datasets used for image classification or object detection, such as ImageNet[29], CIFAR[19] and their size are millions level with more than 1,000 classes. In text classification area, the Sogou pinyin"}, {"heading": "4.1. The factors that influenced the ConvNets when applied to pinyin format dataset28", "text": "dataset is one of the eight large-scale datasets that Zhang constructed. All the dataset are character level, and the pinyin one contains five classes, with all equal size."}, {"heading": "4.1.3 Model setting", "text": "Here are the settings that have been used in our experiments. By comparing among different hyper parameters, these settings were found to be best for this specific task.\nThe dictionary for the ConvNets needs to adjust to the certain context although\npinyin format encoding and English corpus are both based on the Roman alphabet. In previous researches, researchers need to distinguish between upper-case and lower-case letters[41][37][6], which means the dimension of the dataset is at least fifty-two due to the Roman alphabet size. The worse result has been found when such distinction is made. Zhang explained that the differences between letter cases might affect the semantics, and that may lead to a regularisation problem[41]. However, in pinyin format encoding dataset, there is no distinction between the uppercase and lower-case letters. Furthermore, we only added four basic punctuations into the dictionary to lower the dimension. Figure 4.1 shows the dictionary:\nAs we observed from the original news article statistics, most of the content\nare no more than one thousand characters. Therefore, during the data preprocessed stage, all of the input text padded to a fixed size equal to 1000, and the following embedding layer convert them into a dense vector with dimension 16. Every convolutional layer applies to the same setting. The convolutional kernel size is three, and there is two zero-padding part located two sides. With this two zero-padding part, the length among the convolutional layers remains the same (length = 1000), which is useful for stacked layer structure. We initialised the convolutional layers"}, {"heading": "4.1. The factors that influenced the ConvNets when applied to pinyin format dataset29", "text": "using Gaussian initialisation scaled [10]. We did not use any pre-trained method because our model is entirely based on character level, while the word-level are usually required the pre-trained method to avoid the local optimum problem. We set the dropout rate to \u20180.1\u2019 between the fully-connected layers. The dropout layers are proved to be useful to avoid the overfitting problem so that we can gain a similar result in both training set and test set. The batch size is 128, which means every time the model updated the parameters after 128 data trained via the back propagation process. Training performed with optimiser \u2018Adam\u2019[18], and the loss functions is \u2018categorical cross-entropy\u2019. Compared with other optimisers such as SGD, the \u2018Adam\u2019 can converge faster and guide to a better result. Also, because of the model is a multi-class classification problem, we used the \u2018categorical cross-entropy\u2019 and \u2018softmax\u2019 activation in our output layer. All the rest of the hyper-parameters are configured to default in the model. The implementation is done via Tensorflow and Keras on a single NVIDIA GeForce GTX TITAN X GPU."}, {"heading": "4.1.4 Result and Discussion", "text": "Our ConvNets reached the state-of-the-art in narrow convolutional network. According to our comparison between different models, the proposed model reached state-of-the-art when the convolutional layers are restricted to seven layers. Meanwhile, the parameters of our model are up to 190 times less than the other models. The detailed information about result and discussion are listed below.\nChoice of dictionary is important\nThe result in Figure 4.2 shows that the chosen of the dictionary is one of the\nmost important factors in character-level ConvNets. With the help of an appropriate dictionary, we achieved state-of-the-art in narrow convolutional network. Two reasons may lead to this result.\nFirstly, in previous researches, the dictionary is not suitable for pinyin format\nencoding dataset. In English corpus, 26 Roman letters are being used in all of the English articles. However, there are still differences between pinyin alphabet and English alphabet. For instance, the letter \u2018v\u2019 are not included in pinyin alphabet. Also, there are no upper letters in pinyin format alphabet. These different rules may"}, {"heading": "4.1. The factors that influenced the ConvNets when applied to pinyin format dataset30", "text": "lead to various ways to construct the dictionary, and it will influence the performance.\nSecondly, the dictionary may affect the replacement operation in pre-processed\nstage. During the pre-processed stage, we need to use the \u2018regular expressions\u2019 to replace the word to a blank character if they are not in the dictionary. With an adjusted dictionary, the useless characters will be replaced by a blank character. This stage can be seen as we removed the noise from an original song which can help to extract the features from the dataset.\nFinally, the appropriate dictionary can significantly decrease the parameters\nand improve the speed. Fewer parameters mean that we can train the model not only on some specifically graphic card such as TITAN X with 12 GB memory, also on some other graphic card with 4 or 8 GB memory.\nConvNets need stacked layers with proper hyper-parameters\nThe result in Table 4.1 shows that with fine-tuning parameters, we can reach\nstate-of-the-art with fewer parameters. The best model for the proposed one demonstrates that we can use deeper layers with smaller feature maps rather than a single layer with a large feature maps size. It is because the trait of ConvNets is to extract"}, {"heading": "4.2. The comparison between Chinese character and its corresponding pinyin format dataset31", "text": "the features in a partial space. By combining the hierarchical representations in the fully-connected layer, we can let the model choose appropriate features automatically. For instance, three convolutional layers with feature maps number equal to 128, the parameters are about two times large than one convolution layers with feature maps number equals to 350. After all, the stacked one provides a better result and requires fewer parameters.\nThe result in Table 4.1 also shows that the depth of our character-level Con-\nvNets influences the performances. The output pf convolutional layers are the most important part of this model because they can gain the hierarchical representations of the context, and this is the key for following layer to classify the classes."}, {"heading": "4.2 The comparison between Chinese character and", "text": "its corresponding pinyin format dataset"}, {"heading": "4.2.1 Task description", "text": "In this task, we validated our models on two large-scale datasets. The first one is pinyin format encoding dataset, and another one is Chinese character dataset. These datasets are collected by Sogou[35] and then reallocate and transformed for this paper. By comparing their performances, we can prove that character-level ConvNets works better on Chinese character dataset. Also, we will discuss the theory behind this model."}, {"heading": "4.2. The comparison between Chinese character and its corresponding pinyin format dataset32", "text": ""}, {"heading": "4.2.2 Dataset Description", "text": "In text classification area, there are not any large-scale Chinese character dataset exist. Therefore, we decided to create a new dataset with Chinese character and its corresponding pinyin version. The size of the dataset is up to 1,150,000 by using the data augmentation.\nWe combine the news corpus SogouCA and SogouCS from Sogou Lab[35],\nwhich is more than 3 million news articles and at least twenty categories. We labeled the dataset by their domain names, which is part of their URL link. Also, our dataset only contains five categories, which are sports, finance, alternating, automobile, and technology, because of not all the categories have enough data. These datasets are range from 50,000 to 20,000, which are the top five classes in the original news article. If the length of any news content is less than 20 words, the corresponding data will be removed. After all the pre-processing work, there are five classes in the dataset, with about 1200k training set and 200k test set. In Zhangs\u0301 dataset, the size of each class is equal, while our latest dataset has different size in each category so that we can observe whether the ConvNets can extract the feature correctly.\nThe data augmentation is useful for deep learning models to enhance their per-\nformances. This technique is widely used in computer vision [9] and speech recognition [1], to increase the size of the dataset by transforming the signals or rotating the image. In our dataset, the original corpus is the Chinese character. We used the Python library pypinyin and jieba library to transform the dataset from original Chinese character to pinyin format encoding. Then, we used two different pinyin format which is provided by the Python library pypinyin, to enlarge the dataset, and the experiment shows it helps in some ways."}, {"heading": "4.2. The comparison between Chinese character and its corresponding pinyin format dataset33", "text": ""}, {"heading": "4.2.3 Model setting", "text": "The dictionary of Chinese character is distinct from the pinyin format. There are more than six thousand common used Chinese characters which means the dimension of the dictionary is quite large. In this task, we used all of the Chinese character that appears in both training set and test set to construct the dictionary, and the dictionary size is equal to 6,653. Usually, we need more than one characters in pinyin format to represent a Chinese character (See Figure 4.4), so that we changed the input length to 250 according to the statistics of the training set. The remain setting of the model is the same as the model of pinyin format dataset."}, {"heading": "4.2.4 Result and Discussion", "text": "We compared the result of Chinese corpus and pinyin format encoding. To the best of our knowledge, this is the first time that character-level convolutional network applied to Chinese characters. We discussed our potential finding below.\nThe character-level ConvNets solved the word segmentation problem in\nChinese\nThe Table 4.3 shows that Character-level ConvNets works well on both pinyin\nformat encoding and Chinese character corpus. The error rate of pinyin encoding is between 8.41% and 8.87%, while the Chinese character corpus reached 5.47%. The results are impressive, which shows the character-level ConvNets can extract the features from the Chinese character dataset efficiently. We believe that this is the first work that shows character-level ConvNets can be applied to Chinese character"}, {"heading": "4.2. The comparison between Chinese character and its corresponding pinyin format dataset34", "text": "in text classification task.\nWe assume that character-level ConvNets works well on Chinese character due\nto the solved of word segmentation problem. The word segmentation plays a major role in the Chinese language because different segmentation indicates varied meaning. The Figure 4.3 shows that for the same sentence, different word segmentation may lead to a different meaning. In character-level ConvNets, the unit is character level, which means convolutional layers extract the character combination as a feature and ignore the segmentation among the words. In previous researches, character-level ConvNets has already proved that they can better handle the misspelling problem and typo problem in the Roman alphabet. The researchers assume that the convolutional kernel can ignore the differences between two words shared same language roots such as suffix and prefix[41]. However, the pinyin format dataset is based on pronunciation. The dataset can not gain benefit from the language root, also need to suffer from the information compressed during the transforming process, and that is why the Chinese character dataset performs better than the pinyin one in our model.\nChinese character dataset suffers from overfitting problem\nThe Chinese character can hold more information than pinyin format. As Fig-"}, {"heading": "4.2. The comparison between Chinese character and its corresponding pinyin format dataset35", "text": "ure 4.4 shows, a Chinese character requires several Roman characters to represent. That means under the same convolutional kernel size, feature maps setting; the Chinese character dataset can storage more information than the pinyin encoding one. Moreover, this is the main reason as stacked layers increased, the error rate raised from 5.47% to 6.88% due to the overfitting problem. We assume that there are potential to decrease the error rate with fine-tuning parameters. Also, the characterlevel ConvNets may perform better when the Chinese character dataset become larger.\nThe pinyin format dataset increases the information in some way\nAs we mentioned in the introduction chapter, with more than six thousand\ncommon used Chinese characters, there are only four hundred and six syllable combinations, which means there is some information compressed during the process. However, the results show that pinyin format dataset presents competitive result, and this leads to a question, how does it happen?\nHere are the reasons we have found in the analytics. Firstly, the word segmen-\ntation helps. Unlike the western language, there is no gap between each Chinese words, so during the transforming process, the pypinyin python library required another python library jieba to assist the word segmentation. That means the blank character between each word can provide a more accurate meaning that helps both human and computer to understand. Secondly, the words represent different meanings according to the context, sometimes even native speaker can misunderstand the actual meaning. However, the pinyin format encoding can handle this problem with the help of pronunciation annotation so that the human can now precisely get the meaning via its pronunciation, so does the computer."}, {"heading": "4.2. The comparison between Chinese character and its corresponding pinyin format dataset36", "text": "To some extent, data augmentation helps to improve the performances In our dataset, we use two different ways to construct the pinyin encoding\nformat dataset, and the combined dataset size reached about 1.15 million. The error rate seems increased with this combined dataset. However, to some extent, it helps improve the performances. As the Table 4.2 shows, the dataset is combined with two different encoding. If the convolutional neural network extract one specific feature that comes from pinyin encoding type A, this feature can not be used in the test set with pinyin encoding type B, even they represent the same meaning in this context. Moreover, we assume this will cause a significant decrease in the accuracy. Nevertheless, the result remains almost the same, which means the data augmentation do improve the results in some way. In the future, we can refer to computer vision area, to extend the dataset via some appropriate transformations, such as synonyms and paraphrasing, so that the data augmentation technique can efficiently control generalisation error because of the model can better handle the overfitting problem.\nChapter 5\nConclusion\nWe have presented a character-level convolutional neural network that is focusing on solving text classification problem in Chinese corpus. This model has been evaluated on brand new datasets which are consists of Chinese characters and its corresponding pinyin format, and the sizes are up to 600 thousand and 1.15 million respectively. The evaluation between Chinese characters and its corresponding pinyin format dataset shows that character-level ConvNets can works better with Chinese character dataset. We believe that the main reasons are due to the success of solving the word segmentation problem and the information storage capacity of Chinese corpus. To the best of our knowledge, this is the first time that the character-level ConvNets applied to Chinese corpus to solve the text classification task. Also, the validation on Zhangs\u0301 dataset[41] show that proper dictionary and hyper-parameters play a major role in pinyin format text classification task.\nIn the future, we believe that the similar ideas can apply to the other NLP tasks\nsuch as reading comprehension, machine translation. With the help of characterlevel ConvNets, we may fulfil the full potential of Chinese language in NLP. Also, it will be interesting to apply a pre-trained method to character-level ConvNets when applied to Chinese character. Because the character in Chinese are meaningful as a word, while the character in English is meaningless. Finally, we hope that there will be more large-scaled Chinese dataset contains more classes in NLP area, in order to increase the difficulty of the task."}, {"heading": "Appendix A", "text": "User Manual\nThe source code and dataset are all available from Github link:\nhttps://github.com/koalaGreener/Character-level-Convolutional-Network-for-\nText-Classification-Applied-to-Chinese-Corpus\nA.1 Requirements Python2 / Python3\nKeras\nTensorflow\n(Run this model under CUDA will significantly increase the training speed,\nNvidia graphic card required.)\nA.2 Components This repository contains the following components:\nModels: Different model settings for the various dataset. There are four\ndifferent folders, which are 2008 models, Chinese character, pinyin formatA, pinyin formatB. 2008 models represents the task 1 m\u0301odel which is applied to Zhangs\u0301 dataset. The other models are all for task 2, and the datasets are constructed for this paper.\nDataset: The dataset for proposed model. The 2008 dataset is constructed by\nZhang in his paper, while the 2012 dataset is constructed for this paper, including pinyin format and Chinese character dataset.\nA.3. Example Usage 39\nData Preprocessing: Some source code for data preprocessing, and it can be\nused to reproduce the dataset using Sogou news articles.\nA.3 Example Usage 1.Install the Keras and switched the backend to Tensorflow.\n2.Download the dataset from Google drive and put both the training set and\ntest set into the data folder.\n3.Import the ipynb files into the IPython Notebook and start to train the models.\nA.4 Licence MIT"}], "references": [{"title": "Applying convolutional neural networks concepts to hybrid nn-hmm model for speech recognition", "author": ["O. ABDEL-HAMID", "MOHAMED", "A.-R", "H. JIANG", "G. PENN"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2012}, {"title": "N-gram-based text categorization", "author": ["W.B. CAVNAR", "TRENKLE", "J. M"], "venue": "Ann Arbor MI 48113,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1994}, {"title": "A new statistical approach to chinese pinyin input", "author": ["Z. CHEN", "LEE", "K.-F"], "venue": "In Proceedings of the 38th Annual Meeting on Association for Computational Linguistics (Stroudsburg, PA, USA,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2000}, {"title": "A unified architecture for natural language processing: Deep neural networks with multitask learning", "author": ["R. COLLOBERT", "J. WESTON"], "venue": "In Proceedings of the 25th international conference on Machine learning (2008),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "Natural language processing (almost) from scratch", "author": ["R. COLLOBERT", "J. WESTON", "L. BOTTOU", "M. KARLEN", "K. KAVUKCUOGLU", "P. KUKSA"], "venue": "Journal of Machine Learning Research 12,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Very deep convolutional networks for natural language processing", "author": ["A. CONNEAU", "H. SCHWENK", "L. BARRAULT", "Y. LECUN"], "venue": "arXiv preprint arXiv:1606.01781", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2016}, {"title": "Tweet2vec: Character-based distributed representations for social media", "author": ["B. DHINGRA", "Z. ZHOU", "D. FITZPATRICK", "M. MUEHL", "W.W. COHEN"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2016}, {"title": "Deep residual learning for image recognition", "author": ["HE K", "ZHANG X", "REN S", "SUN"], "venue": "arXiv preprint arXiv:1512.03385", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification", "author": ["HE K", "ZHANG X", "REN S", "SUN"], "venue": "In Proceedings of the IEEE International Conference on Computer Vision", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2015}, {"title": "Mining and summarizing customer reviews", "author": ["HU M", "LIU"], "venue": "In Proceedings of the tenth ACM SIGKDD international conference on Knowledge discovery and data mining (2004),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2004}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["S. IOFFE", "C. SZEGEDY"], "venue": "arXiv preprint arXiv:1502.03167", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2015}, {"title": "Text categorization with support vector machines: Learning with many relevant features", "author": ["T. JOACHIMS"], "venue": "In European conference on machine learning", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1998}, {"title": "Bag of tricks for efficient text classification", "author": ["A. JOULIN", "E. GRAVE", "P. BOJANOWSKI", "T. MIKOLOV"], "venue": "arXiv preprint arXiv:1607.01759", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2016}, {"title": "Convolutional neural networks for sentence classification", "author": ["KIM Y"], "venue": "arXiv preprint arXiv:1408.5882", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2014}, {"title": "Character-aware neural language models", "author": ["Y. KIM", "Y. JERNITE", "D. SONTAG", "A.M. RUSH"], "venue": "arXiv preprint arXiv:1508.06615", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2015}, {"title": "Adam: A method for stochastic optimization", "author": ["KINGMA D", "BA"], "venue": "arXiv preprint arXiv:1412.6980", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2014}, {"title": "Gradient-based learning applied to document recognition", "author": ["Y. LECUN", "L. BOTTOU", "Y. BENGIO", "P. HAFFNER"], "venue": "Proceedings of the IEEE 86,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1998}, {"title": "Learning question classifiers", "author": ["X. LI", "D. ROTH"], "venue": "In Proceedings of the 19th international conference on Computational linguistics-Volume", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2002}, {"title": "Sentiment analysis and opinion mining", "author": ["LIU B"], "venue": "Synthesis lectures on human language technologies 5,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2012}, {"title": "Short text feature selection for micro-blog mining", "author": ["LIU Z", "YU W", "CHEN W", "WANG S", "WU"], "venue": "In Computational Intelligence and Software Engineering (CiSE),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2010}, {"title": "Intelligent spam classification for mobile text message", "author": ["K. MATHEW", "B. ISSAC"], "venue": "In Computer Science and Network Technology (ICCSNT),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2011}, {"title": "A comparison of event models for naive bayes text classification. In AAAI-98 workshop on learning for text categorization", "author": ["A. MCCALLUM", "K NIGAM"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1998}, {"title": "Efficient estimation of word representations in vector space", "author": ["T. MIKOLOV", "K. CHEN", "G. CORRADO", "J. DEAN"], "venue": "arXiv preprint arXiv:1301.3781", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2013}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["V. NAIR", "G.E. HINTON"], "venue": "In Proceedings of the 27th International Conference on Machine Learning", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2010}, {"title": "Seeing stars: Exploiting class relationships for sentiment categorization with respect to rating scales. In Proceedings of the 43rd annual meeting on association for computational linguistics", "author": ["PANG B", "LEE"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2005}, {"title": "Unitn: Training deep convolutional neural network for twitter sentiment classification", "author": ["A. SEVERYN", "A. MOSCHITTI"], "venue": "In Proceedings of the 9th International Workshop on Semantic Evaluation (SemEval", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2015}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["K. SIMONYAN", "A. ZISSERMAN"], "venue": "arXiv preprint arXiv:1409.1556", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2014}, {"title": "Recursive deep models for semantic compositionality over a sentiment treebank. In Proceedings of the conference on empirical methods in natural language processing", "author": ["R. SOCHER", "A. PERELYGIN", "J.Y. WU", "J. CHUANG", "C.D. MANNING", "A.Y. NG", "C. POTTS"], "venue": null, "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2013}, {"title": "A statistical interpretation of term specificity and its application in retrieval", "author": ["K. SPARCK JONES"], "venue": "Journal of documentation 28,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1972}, {"title": "Document modeling with gated recurrent neural network for sentiment classification", "author": ["TANG D", "QIN B", "LIU"], "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2015}, {"title": "Automatic online news issue construction in web environment", "author": ["WANG C", "ZHANG M", "MA S", "RU"], "venue": "In Proceedings of the 17th international conference on World Wide Web (2008),", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2008}, {"title": "Annotating expressions of opinions and emotions in language. Language resources and evaluation", "author": ["J. WIEBE", "T. WILSON", "C. CARDIE"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2005}, {"title": "Efficient character-level document classification by combining convolution and recurrent layers", "author": ["XIAO Y", "CHO"], "venue": "arXiv preprint arXiv:1602.00367", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2016}, {"title": "Fast training of a graph boosting for large-scale text classification", "author": ["H. YOSHIKAWA", "T. IWAKURA"], "venue": "In Pacific Rim International Conference on Artificial Intelligence", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2016}, {"title": "Adadelta: an adaptive learning rate method", "author": ["M.D. ZEILER"], "venue": "arXiv preprint arXiv:1212.5701", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2012}, {"title": "Shallow convolutional neural network for implicit discourse relation recognition", "author": ["ZHANG B", "SU J", "XIONG D", "LU Y", "DUAN H", "YAO"], "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2015}, {"title": "Character-level convolutional networks for text classification", "author": ["X. ZHANG", "J. ZHAO", "Y. LECUN"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2015}], "referenceMentions": [{"referenceID": 36, "context": "The result of Bag of Words and N-gram came from Zhang[41], which are the references of this task.", "startOffset": 53, "endOffset": 57}, {"referenceID": 5, "context": "Natural language processing (NLP) is the field in which through analysing data, the machine can extract information from contexts and represent the input information in a different way[6].", "startOffset": 184, "endOffset": 187}, {"referenceID": 4, "context": "Part-Of-Speech tagging (POS), such as text or image classification, to classify the data with different categories; Chunking (CHUNK), to label the segment of a given sentence by using syntactic and semantic relations; and Named Entity Recognition (NER), to tag named entities in text[5].", "startOffset": 283, "endOffset": 286}, {"referenceID": 5, "context": "Nevertheless, they have the same purpose of finding out the hierarchical representations of the context[6].", "startOffset": 103, "endOffset": 106}, {"referenceID": 3, "context": "One of the classic tasks for NLP is text classification, also known as document classification[4].", "startOffset": 94, "endOffset": 97}, {"referenceID": 4, "context": "[5] Take BBC sports website for example, in its content, there are many specific Premier League team names, which can serve as corresponding features for the following classification.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "A common approach to text classification is to use Bag of Words[8] , N-gram[2], and their term frequency-inverse document frequency (TF-IDF)[33] as features, and traditional models such as SVM[14], Naive Bayes[25] as classifiers.", "startOffset": 75, "endOffset": 78}, {"referenceID": 28, "context": "A common approach to text classification is to use Bag of Words[8] , N-gram[2], and their term frequency-inverse document frequency (TF-IDF)[33] as features, and traditional models such as SVM[14], Naive Bayes[25] as classifiers.", "startOffset": 140, "endOffset": 144}, {"referenceID": 11, "context": "A common approach to text classification is to use Bag of Words[8] , N-gram[2], and their term frequency-inverse document frequency (TF-IDF)[33] as features, and traditional models such as SVM[14], Naive Bayes[25] as classifiers.", "startOffset": 192, "endOffset": 196}, {"referenceID": 21, "context": "A common approach to text classification is to use Bag of Words[8] , N-gram[2], and their term frequency-inverse document frequency (TF-IDF)[33] as features, and traditional models such as SVM[14], Naive Bayes[25] as classifiers.", "startOffset": 209, "endOffset": 213}, {"referenceID": 36, "context": "However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1].", "startOffset": 35, "endOffset": 39}, {"referenceID": 4, "context": "However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1].", "startOffset": 39, "endOffset": 42}, {"referenceID": 13, "context": "However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1].", "startOffset": 42, "endOffset": 46}, {"referenceID": 5, "context": "However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1].", "startOffset": 46, "endOffset": 49}, {"referenceID": 7, "context": "However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1].", "startOffset": 186, "endOffset": 189}, {"referenceID": 0, "context": "However, recently, many researchers[41][5][16][6], using deep learning model, particularly the convolutional neural networks (ConvNets), have made significant progress in computer vision[9] and speech recognition[1].", "startOffset": 212, "endOffset": 215}, {"referenceID": 16, "context": "ConvNets, originally invented by LeCun[20] for computer vision, refers to the model that uses convolution kernels to extract local features.", "startOffset": 38, "endOffset": 42}, {"referenceID": 35, "context": "Analyses have shown that ConvNets is effective for NLP tasks[40][30], and the convolution filter can be utilised in the feature extraction stages.", "startOffset": 60, "endOffset": 64}, {"referenceID": 25, "context": "Analyses have shown that ConvNets is effective for NLP tasks[40][30], and the convolution filter can be utilised in the feature extraction stages.", "startOffset": 64, "endOffset": 68}, {"referenceID": 36, "context": "Compared with the model listed above, ConvNets, when applied to text classification has shown rather competitive results[41][5][16][6].", "startOffset": 120, "endOffset": 124}, {"referenceID": 4, "context": "Compared with the model listed above, ConvNets, when applied to text classification has shown rather competitive results[41][5][16][6].", "startOffset": 124, "endOffset": 127}, {"referenceID": 13, "context": "Compared with the model listed above, ConvNets, when applied to text classification has shown rather competitive results[41][5][16][6].", "startOffset": 127, "endOffset": 131}, {"referenceID": 5, "context": "Compared with the model listed above, ConvNets, when applied to text classification has shown rather competitive results[41][5][16][6].", "startOffset": 131, "endOffset": 134}, {"referenceID": 36, "context": "Also, since the ConvNets method can handle the misspelling problem, it works well for user-generated data[41].", "startOffset": 105, "endOffset": 109}, {"referenceID": 4, "context": "Recent approach of using ConvNets on text classification mainly works at the word-level [5] [16].", "startOffset": 88, "endOffset": 91}, {"referenceID": 13, "context": "Recent approach of using ConvNets on text classification mainly works at the word-level [5] [16].", "startOffset": 92, "endOffset": 96}, {"referenceID": 32, "context": "This may diminish the classification accuracy of the task[37].", "startOffset": 57, "endOffset": 61}, {"referenceID": 36, "context": "In the last few years, many researchers found that it is also likely to train a ConvNets at the character-level[41][37][6].", "startOffset": 111, "endOffset": 115}, {"referenceID": 32, "context": "In the last few years, many researchers found that it is also likely to train a ConvNets at the character-level[41][37][6].", "startOffset": 115, "endOffset": 119}, {"referenceID": 5, "context": "In the last few years, many researchers found that it is also likely to train a ConvNets at the character-level[41][37][6].", "startOffset": 119, "endOffset": 122}, {"referenceID": 14, "context": "Kim used a character sequence as an input in his language model[17], and Dhingra applied this idea to predict the hashtags[7].", "startOffset": 63, "endOffset": 67}, {"referenceID": 6, "context": "Kim used a character sequence as an input in his language model[17], and Dhingra applied this idea to predict the hashtags[7].", "startOffset": 122, "endOffset": 125}, {"referenceID": 2, "context": "Pinyin input is one of the most popular forms of text input in the Chinese language[3].", "startOffset": 83, "endOffset": 86}, {"referenceID": 20, "context": "Previous researchers such as Mathew used pinyin format dataset as input to detect spam in mobile text message[24] and Liu, similarly, using pinyin format dataset for feature selection[23], proved that pinyin format dataset could be utilised as an efficient method to solve the NLP problems.", "startOffset": 109, "endOffset": 113}, {"referenceID": 19, "context": "Previous researchers such as Mathew used pinyin format dataset as input to detect spam in mobile text message[24] and Liu, similarly, using pinyin format dataset for feature selection[23], proved that pinyin format dataset could be utilised as an efficient method to solve the NLP problems.", "startOffset": 183, "endOffset": 187}, {"referenceID": 2, "context": "For example, in the Chinese language, there are only 406 syllable combinations can be found in pinyin format representation among more than 6,000 commonly used Chinese characters, which means that some information is compressed during the transforming[3].", "startOffset": 251, "endOffset": 254}, {"referenceID": 11, "context": "Traditional models include SVM [14], Naive Bayes [25], Bag of Words [8], N-gram[2], and their TF-IDF [33] version.", "startOffset": 31, "endOffset": 35}, {"referenceID": 21, "context": "Traditional models include SVM [14], Naive Bayes [25], Bag of Words [8], N-gram[2], and their TF-IDF [33] version.", "startOffset": 49, "endOffset": 53}, {"referenceID": 1, "context": "Traditional models include SVM [14], Naive Bayes [25], Bag of Words [8], N-gram[2], and their TF-IDF [33] version.", "startOffset": 79, "endOffset": 82}, {"referenceID": 28, "context": "Traditional models include SVM [14], Naive Bayes [25], Bag of Words [8], N-gram[2], and their TF-IDF [33] version.", "startOffset": 101, "endOffset": 105}, {"referenceID": 36, "context": "The result in Zhang\u015b paper[41] shows that Bag of Words model and its TF-IDF version can achieve great performances in most of the tasks.", "startOffset": 26, "endOffset": 30}, {"referenceID": 1, "context": "The N-gram model in text classification task can be seen as an extension of the Bag of Word model[2].", "startOffset": 97, "endOffset": 100}, {"referenceID": 12, "context": "This algorithm can train the model in no more than ten minutes on one billion words, and classify a large number of datasets among millions of classes within a minute[15].", "startOffset": 166, "endOffset": 170}, {"referenceID": 33, "context": "Yoshikawa[38] proposed a fast training method for text classification which is based on graph classification.", "startOffset": 9, "endOffset": 13}, {"referenceID": 27, "context": "In Socher\u2019s[32] work, a parse tree is being used in the feature extraction stage.", "startOffset": 11, "endOffset": 15}, {"referenceID": 18, "context": "Liu [22] solved the sentiment analytics task using this model.", "startOffset": 4, "endOffset": 8}, {"referenceID": 4, "context": "Research has also shown that ConvNets is effective for NLP tasks [5][4], and the convolutional filter can be utilised in the feature extraction stages.", "startOffset": 65, "endOffset": 68}, {"referenceID": 3, "context": "Research has also shown that ConvNets is effective for NLP tasks [5][4], and the convolutional filter can be utilised in the feature extraction stages.", "startOffset": 68, "endOffset": 71}, {"referenceID": 13, "context": "Kim was one of the earliest researchers who used convolutional neural networks (ConvNets) for sentence classification[16].", "startOffset": 117, "endOffset": 121}, {"referenceID": 13, "context": "In this paper, Kim[16] proposed a word-level shallow neural network with one convolutional layer using multiple widths and filters followed by a max-pooling layer over time.", "startOffset": 18, "endOffset": 22}, {"referenceID": 22, "context": "The word vectors in this model were initialised using the publicly available word2vec, which was trained on 100 billion words from Google News[26].", "startOffset": 142, "endOffset": 146}, {"referenceID": 24, "context": "The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32].", "startOffset": 167, "endOffset": 171}, {"referenceID": 17, "context": "The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32].", "startOffset": 195, "endOffset": 199}, {"referenceID": 24, "context": "The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32].", "startOffset": 271, "endOffset": 275}, {"referenceID": 9, "context": "The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32].", "startOffset": 314, "endOffset": 318}, {"referenceID": 31, "context": "The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32].", "startOffset": 375, "endOffset": 379}, {"referenceID": 27, "context": "The comparison between several variants and traditional models applied on six datasets are reported in this paper, they are movie reviews with one sentence per review [28], TREC question dataset [21], a dataset for classifying the sentence whether subjective or objective[28], customer reviews of various products [12], opinion polarity detection subtask of the MPQA dataset [36], in particular, Stanford Sentiment Treebank [32].", "startOffset": 424, "endOffset": 428}, {"referenceID": 34, "context": "Kim selected the stochastic gradient descent (SGD) and Ada-delta update rule[39] for his model.", "startOffset": 76, "endOffset": 80}, {"referenceID": 26, "context": "Only one convolutional layer was constructed in this ConvNets, while the trend in computer vision where significant improvements have been reported using much deeper networks, 19 layers[31], or even up to 152 layers[9].", "startOffset": 185, "endOffset": 189}, {"referenceID": 7, "context": "Only one convolutional layer was constructed in this ConvNets, while the trend in computer vision where significant improvements have been reported using much deeper networks, 19 layers[31], or even up to 152 layers[9].", "startOffset": 215, "endOffset": 218}, {"referenceID": 36, "context": "Zhang was the first one who proposed an entirely character-level convolutional networks for text classification[41].", "startOffset": 111, "endOffset": 115}, {"referenceID": 36, "context": "The input of this model is a sequence of encoding vectors, which is done by \u2018applied an alphabet of size n for the input documents, and then quantise each character using one-hot encoding[41]\u2019.", "startOffset": 187, "endOffset": 191}, {"referenceID": 22, "context": "such as word2vec[26] for the input word vectors in the model.", "startOffset": 16, "endOffset": 20}, {"referenceID": 11, "context": "A comparison was made among traditional models such as SVM[14], Naive Bayes [25], Bag of Words, N-grams[2], and their TF-IDF version[33], also among deep learning models such as word-level ConvNets and long-short-term memory model(LSTM)[11].", "startOffset": 58, "endOffset": 62}, {"referenceID": 21, "context": "A comparison was made among traditional models such as SVM[14], Naive Bayes [25], Bag of Words, N-grams[2], and their TF-IDF version[33], also among deep learning models such as word-level ConvNets and long-short-term memory model(LSTM)[11].", "startOffset": 76, "endOffset": 80}, {"referenceID": 1, "context": "A comparison was made among traditional models such as SVM[14], Naive Bayes [25], Bag of Words, N-grams[2], and their TF-IDF version[33], also among deep learning models such as word-level ConvNets and long-short-term memory model(LSTM)[11].", "startOffset": 103, "endOffset": 106}, {"referenceID": 28, "context": "A comparison was made among traditional models such as SVM[14], Naive Bayes [25], Bag of Words, N-grams[2], and their TF-IDF version[33], also among deep learning models such as word-level ConvNets and long-short-term memory model(LSTM)[11].", "startOffset": 132, "endOffset": 136}, {"referenceID": 5, "context": "Conneau[6] was the first one who implemented a very deep convolutional architecture which is up to 29 convolutional layers (9, 17, 29, 49 respectively) and applied to sentence classification.", "startOffset": 7, "endOffset": 10}, {"referenceID": 5, "context": "The k-max pooling layer is followed to obtained the most important features of the stack of convolutional blocks[6].", "startOffset": 112, "endOffset": 115}, {"referenceID": 32, "context": "The datasets in this paper are the same corpora of Zhang and Xiao [37], and the best results of them are the baseline in this article.", "startOffset": 66, "endOffset": 70}, {"referenceID": 5, "context": "However, in this work, Conneau [6] created an architecture which used many layers of small convolutional kernel, which is size three.", "startOffset": 31, "endOffset": 34}, {"referenceID": 5, "context": "Compared with Zhangs ConvNets architecture, Conneau[6] found that better not to use dropout layer with the fully-connected layers, but only temporal batch normalization[13] after convolutional layers.", "startOffset": 51, "endOffset": 54}, {"referenceID": 10, "context": "Compared with Zhangs ConvNets architecture, Conneau[6] found that better not to use dropout layer with the fully-connected layers, but only temporal batch normalization[13] after convolutional layers.", "startOffset": 168, "endOffset": 172}, {"referenceID": 7, "context": "As described in He[9], the gain in accuracy due to the increase of the depth is limited when using standard ConvNets.", "startOffset": 18, "endOffset": 21}, {"referenceID": 32, "context": "There are also some researches that combine both ConvNets and Recurrent Neural Network[37][34].", "startOffset": 86, "endOffset": 90}, {"referenceID": 29, "context": "There are also some researches that combine both ConvNets and Recurrent Neural Network[37][34].", "startOffset": 90, "endOffset": 94}, {"referenceID": 32, "context": "Xiao[37] combined both convolutional network and recurrent network to extract the features and applied to sentence classification.", "startOffset": 4, "endOffset": 8}, {"referenceID": 32, "context": "Finally, there is an optimal level of local features to be fed into the recurrent layer, because Xiao noticed that the model accuracy does not always increase with the depth of convolutional layers[37].", "startOffset": 197, "endOffset": 201}, {"referenceID": 36, "context": "The i-th symbol in this vector is set to one if it is the i-th element, while the rest of the symbol are remain zero[41].", "startOffset": 116, "endOffset": 120}, {"referenceID": 36, "context": "better result[41].", "startOffset": 13, "endOffset": 17}, {"referenceID": 36, "context": "In previous researches[41][6], the alphabet size are 71 and 72 characters respectively.", "startOffset": 22, "endOffset": 26}, {"referenceID": 5, "context": "In previous researches[41][6], the alphabet size are 71 and 72 characters respectively.", "startOffset": 26, "endOffset": 29}, {"referenceID": 36, "context": "( f \u2217g)(i) = m \u2211 j=1 g( j)\u2217 f (i\u2212 j+m/2)[41]", "startOffset": 40, "endOffset": 44}, {"referenceID": 8, "context": "Also, each layer is initialised by henormal[10], and the border mode is same, which means the length remains 1,000 during this stages.", "startOffset": 43, "endOffset": 47}, {"referenceID": 5, "context": "Encouraged by Conneaus work[6], we only used the kernel size equal to three, so that during this period, the layers can automatically best combine these different \u201ctrigram\u201d features in various layers.", "startOffset": 27, "endOffset": 30}, {"referenceID": 23, "context": "We used the ReLU[27] as our nonlinear activation function, which is widely employed in recent researches.", "startOffset": 16, "endOffset": 20}, {"referenceID": 5, "context": "There are varies types of pooling layers such as max-pooling layer and average pooling layer[6].", "startOffset": 92, "endOffset": 95}, {"referenceID": 36, "context": "In this task, we validated our models on one of the eight datasets in Zhang[41] s research.", "startOffset": 75, "endOffset": 79}, {"referenceID": 30, "context": "The dataset was collected from Sogou[35], and the encoding is pinyin format.", "startOffset": 36, "endOffset": 40}, {"referenceID": 36, "context": "In previous researches, researchers need to distinguish between upper-case and lower-case letters[41][37][6], which means the dimension of the dataset is at least fifty-two due to the Roman alphabet size.", "startOffset": 97, "endOffset": 101}, {"referenceID": 32, "context": "In previous researches, researchers need to distinguish between upper-case and lower-case letters[41][37][6], which means the dimension of the dataset is at least fifty-two due to the Roman alphabet size.", "startOffset": 101, "endOffset": 105}, {"referenceID": 5, "context": "In previous researches, researchers need to distinguish between upper-case and lower-case letters[41][37][6], which means the dimension of the dataset is at least fifty-two due to the Roman alphabet size.", "startOffset": 105, "endOffset": 108}, {"referenceID": 36, "context": "Zhang explained that the differences between letter cases might affect the semantics, and that may lead to a regularisation problem[41].", "startOffset": 131, "endOffset": 135}, {"referenceID": 8, "context": "using Gaussian initialisation scaled [10].", "startOffset": 37, "endOffset": 41}, {"referenceID": 15, "context": "Training performed with optimiser \u2018Adam\u2019[18], and the loss functions is \u2018categorical cross-entropy\u2019.", "startOffset": 40, "endOffset": 44}, {"referenceID": 30, "context": "These datasets are collected by Sogou[35] and then reallocate and transformed for this paper.", "startOffset": 37, "endOffset": 41}, {"referenceID": 30, "context": "We combine the news corpus SogouCA and SogouCS from Sogou Lab[35], which is more than 3 million news articles and at least twenty categories.", "startOffset": 61, "endOffset": 65}, {"referenceID": 7, "context": "This technique is widely used in computer vision [9] and speech recognition [1], to increase the size of the dataset by transforming the signals or rotating the image.", "startOffset": 49, "endOffset": 52}, {"referenceID": 0, "context": "This technique is widely used in computer vision [9] and speech recognition [1], to increase the size of the dataset by transforming the signals or rotating the image.", "startOffset": 76, "endOffset": 79}, {"referenceID": 36, "context": "The result of Bag of Words and N-gram came from Zhang[41], which are the references of this task.", "startOffset": 53, "endOffset": 57}, {"referenceID": 36, "context": "The researchers assume that the convolutional kernel can ignore the differences between two words shared same language roots such as suffix and prefix[41].", "startOffset": 150, "endOffset": 154}, {"referenceID": 36, "context": "Also, the validation on Zhang\u015b dataset[41] show that proper dictionary and hyper-parameters play a major role in pinyin format text classification task.", "startOffset": 38, "endOffset": 42}], "year": 2016, "abstractText": "Compared with word-level and sentence-level convolutional neural networks (ConvNets), the character-level ConvNets has a better applicability for misspellings and typos input. Due to this, recent researches for text classification mainly focus on character-level ConvNets. However, while the majority of these researches employ English corpus for the character-level text classification, few researches have been done using Chinese corpus. This research hopes to bridge this gap, exploring character-level ConvNets for Chinese corpus test classification. We have constructed a large-scale Chinese dataset, and the result shows that character-level ConvNets works better on Chinese character dataset than its corresponding pinyin format dataset, which is the general solution in previous researches. This is the first time that character-level ConvNets has been applied to Chinese character dataset for text classification problem.", "creator": "LaTeX with hyperref package"}}}