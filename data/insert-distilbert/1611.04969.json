{"id": "1611.04969", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Nov-2016", "title": "An integrated Graphical User Interface for Debugging Answer Set Programs", "abstract": "answer set programming ( stylized asp ) is an expressive knowledge representation and reasoning framework. due to its rather simple syntax paired programming with high - performance solvers, asp is interesting for industrial applications. however, to err is human and thus debugging is an important activity during the development process. therefore, tools exist for developing debugging non - ground answer set set programs are needed. \" in announcing this paper, we present a new graphical debugging interface for describing non - ground answer source set programs. the tool is partially based on the recently - realized introduced dwasp approach for debugging and ultimately it simplifies the interaction interfaces with the debugger. furthermore, the generalized debugging interface is integrated in aspide, a rich ide for answer set programs. as with our extension developed aspide turns into a full - fledged ide by default offering debugging support.", "histories": [["v1", "Tue, 15 Nov 2016 18:11:43 GMT  (190kb,D)", "http://arxiv.org/abs/1611.04969v1", "Paper presented at the 1st Workshop on Trends and Applications of Answer Set Programming (TAASP 2016), Klagenfurt, Austria, 26 September 2016, 15 pages, LaTeX, 5 figures"]], "COMMENTS": "Paper presented at the 1st Workshop on Trends and Applications of Answer Set Programming (TAASP 2016), Klagenfurt, Austria, 26 September 2016, 15 pages, LaTeX, 5 figures", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["philip gasteiger", "carmine dodaro", "benjamin musitsch", "kristian reale", "francesco ricca", "konstantin schekotihin"], "accepted": false, "id": "1611.04969"}, "pdf": {"name": "1611.04969.pdf", "metadata": {"source": "CRF", "title": "An integrated Graphical User Interface for Debugging Answer Set Programs", "authors": ["Philip Gasteiger", "Carmine Dodaro", "Benjamin Musitsch", "Kristian Reale", "Francesco Ricca", "Konstantin Schekotihin"], "emails": ["firstname.lastname@aau.at", "lastname@mat.unical.it"], "sections": [{"heading": null, "text": "Keywords: Answer Set Programming, ASP, debugging, graphical debugging"}, {"heading": "1 Introduction", "text": "Answer Set Programming (ASP) [5] is a declarative programming paradigm proposed in the area of logic programming and non-monotonic reasoning. Computational problems of comparatively high complexity can be modeled in the expressive language of ASP [13], which provides a clear separation between the specification of a problem and the computation of its solutions by an ASP solver. The rather simple syntax of ASP paired with high-performance solvers makes ASP a valuable tool for developing complex research and industrial applications [2,7,11,18]. Especially real-world applications outlined the advantages of ASP from a software engineering viewpoint. Namely, ASP programs are flexible, intuitive, extensible and easy to maintain [18].\nAlthough the basic syntax of ASP is not particularly difficult, one of the most tedious and time-consuming programming tasks is the identification of (even trivial) faults in a program. For this reason, several methodologies and tools have been proposed in the last few years for debugging ASP programs [4,17,22,21,26], with the goal of making the development process faster and more comfortable.\nWe have recently proposed a new debugging technique in [10] that can be applied to non-ground ASP programs, and that allows to single out the rules causing a bug. This\nar X\niv :1\n61 1.\n04 96\n9v 1\n[ cs\n.A I]\n1 5\nN ov\nnew approach overcomes the limits [22] of state-of-the-art debuggers based on metaprogramming [17,22], which suffer from a grounding blow-up problem. Nonetheless the new technique was implemented a as a command line tool only, called DWASP, that extends the WASP solver [1].\nIt is nowadays recognized that the development of programs can be made easier by development tools and graphic environments. Indeed, the most diffused programming languages always come with the support of graphical debugging tools that are integrated in rich IDEs. As an example consider one of the most diffused debugging tools for C++, called gdb. Despite gdb being shipped with g++ as a command line tool, given the complex nature of debugging, serious program inspections are often done by means of user friendly graphical tools (provided by IDEs such as Eclipse or Netbeans) that wrap the gdb command. Following this trend, the debugging approaches for ASP have been usually integrated in programming environment such as ASPIDE [15] or SeaLion [6,23]. However, initially DWASP was not integrated in a graphic environment, and also ASPIDE featured only a limited support for debugging, which was restricted to ground programs. In this paper we provide two contributions in this context:\n1. A graphical user interface, called DWASP-GUI, for DWASP that improves the userexperience of the debugger. 2. A plug-in connector for ASPIDE, which integrates DWASP-GUI within the IDE.\nThe graphical user interface provides a more intuitive user-experience during the debugging process with DWASP. Furthermore, the integration in ASPIDE brings additional advantages to the users of DWASP. Indeed ASPIDE provides a unit-testing framework [14] that was connected with DWASP to automatically generate failing test cases for the debugger. The integration is thus synergistic, as it simplifies the usage of the debugger and turns ASPIDE into a full-fledged IDE by offering a more advanced debugging tool."}, {"heading": "2 Answer Set Programming", "text": "In this section we recall the syntax and semantics of answer set programming. Furthermore, some properties of answer set programs that are required for our debugging methodology are presented briefly."}, {"heading": "2.1 Syntax.", "text": "A disjunctive logic program (DLP) \u03a0 is a finite set of rules of the form\na1 \u2228 . . . \u2228 am \u2190 l1, . . . , ln (1)\nwhere a1, . . . , am are atoms and l1, . . . , ln are literals for m,n \u2265 0. A literal is an atom ai (positive) or its negation \u223cai (negative), where \u223cdenotes the negation as failure. The complement of a literal l and a set of literals L is denoted by l and L := {l | l \u2208 L}, respectively, where a =\u223ca and \u223ca = a for an atom a. An atom is an expression of the form p(t1, . . . , tk), where p is a predicate symbol and t1, . . . , tk are terms, i.e. variables or constants. An atom, literal, or rule is called ground, if it is variable-free. Given a rule\nr of the form (1), the set of atoms H(r) = {a1, . . . , am} is called head and the set of literals B(r) = {l1, . . . , ln} is called body. Moreover, B(r) can be partitioned into the sets B+(r) and B\u2212(r) comprising the positive and negative body literals, respectively. A rule r is called fact if |H(r)| = 1 and B(r) = \u2205; constraint if H(r) = \u2205; and normal rule if |H(r)| = 1 and B(r) 6= \u2205. For a fact a \u2190 we omit the\u2190 symbol and write a instead. Every rule r \u2208 \u03a0 must be safe, i.e. each variable of r must occur in at least one positive literal of B+(r)."}, {"heading": "2.2 Semantics.", "text": "Let \u03a0 be an ASP program, U\u03a0 be the Herbrand universe and B\u03a0 be the Herbrand base of \u03a0 . Let \u03a0G be the ground instantiation of \u03a0 that is obtained by substituting variables with elements of U\u03a0 . An interpretation is a set of ground atoms I \u2286 B\u03a0 . Given an interpretation I a positive literal l (its complement l) is true in I iff l \u2208 I (l 6\u2208 I). An interpretation M is a model for \u03a0G if for each rule r \u2208 \u03a0G having B(r) \u2286M it holds that H(r) \u2229M 6= \u2205. Let I1 and I2 be two interpretations, then I1 \u2286+ I2 if and only if for each atom a \u2208 I1 it holds that a \u2208 I2.\nGiven the ground instantiation \u03a0G of a DLP \u03a0 and an interpretation I , a reduct of \u03a0G w.r.t. I is a ground program \u03a0GI obtained from \u03a0\nG by: (i) deleting all rules r \u2208 \u03a0G whose negative body is false w.r.t to I and (ii) deleting the negative body from the remaining rules. An answer set of \u03a0 is a model M of \u03a0G that is a \u2286+-minimal model of \u03a0GM . Given the set of answer sets AS(\u03a0) of \u03a0 , the program \u03a0 is called incoherent, if AS(\u03a0) = \u2205, and coherent otherwise."}, {"heading": "3 Debugging Approach", "text": "In this section we present the debugging approach proposed in [10] which is implemented inside the ASP solver WASP [1]. First, the key idea behind the approach is presented on an abstract level in Section 3.1. Afterwards, a way to integrate the approach inside an ASP solver is outlined in Section 3.2."}, {"heading": "3.1 Idea", "text": "When developing a program, the user commonly uses a small instance to test it. In order to verify the correctness of the results obtained from the ASP solver, the expected solution of the sample instance is determined by hand. That is, at least one answer set of an intended program for the given instance is known to the user. A bug in the answer set program under test is then revealed when:\n(a) there are no answer sets (i.e. the program is incoherent), or (b) the known answer set is not among the computed ones or there are answer sets\ncorresponding to non-solutions of the sample instance.\nExample 1 (ASP conference system [23]). The DLP \u03a0 \u2032 below models a conference system that assigns papers to program committee members. The assignment is done\naccording to bids (ranging from 0 to 3) expressing a degree of preference on the papers. If no explicit bid is placed, a default value of 1 is assumed.\n\u03a0 \u2032 = {pc(m1), pc(m2), paper(p1), bid(m1, p1, 2), some\u2212bid(M,P )\u2190 bid(M,P,X), bid(M,P, 1)\u2190\u223csome\u2212bid(M,P ), pc(M), paper(P )}\nWe expect a solution containing bid(m1, p1, 2) and bid(m2, p1, 1), but \u03a0 \u2032 is incoherent. Therefore, a bug of type (a) is revealed.\nAs illustrated by the example above, bugs of type (a) are revealed when the ASP solver finds that the program is incoherent. In order to reveal a bug of type (b), additional information about the expected answer set is required. This information is given in the form of a test case, which intuitively asserts a set of literals to be true in some answer set of the faulty program \u03a0 . Whenever there exists an answer set of \u03a0 such that all asserted literals are true, the test case passes. If no such answer set exists, the test case fails since no answer set models all asserted literals and a bug is revealed.\nExample 2. Consider a program \u03a0 \u2032\u2032 consisting of the following rules:\nwet \u2228 dry \u2190 umbrella \u2228 no_umbrella\u2190\n\u2190 wet, umbrella \u2190 rainy, dry \u2190 wet, \u223crainy\nrainy\nThe user expects an answer set of \u03a0 \u2032\u2032 where dry and umbrella are true. However, \u03a0 \u2032\u2032 has only one answer set {rainy, wet, no_umbrella}, thus, intuitively, we have a test case that fails.\nDefinition 1 (Test Case). A test case for a program \u03a0 is a set of literals T asserted to be true in some answer set. A test case fails, if the program\n\u03a0T = \u03a0 \u222a {\u2190 l | l \u2208 T} (2)\nis incoherent.\nExample 3. Consider the program \u03a0 \u2032\u2032 from Example 2. According to Definition 1, the test case is represented by the set T = {dry, umbrella}. The program \u03a0 \u2032\u2032T extends \u03a0 \u2032\u2032 by the constraints\u2190\u223cdry, and\u2190\u223cumbrella. Since dry cannot be derived in \u03a0 \u2032\u2032T , the program is incoherent.\nWe model assertions by constraints that forbid any answer set containing the complement of the asserted literals. As a result, checking whether a test case T of a program \u03a0 passes or not is reduced to checking whether \u03a0T is coherent, as illustrated in Example 3. Hence the second case (b) of when a bug is revealed is reduced to the first case of\nincoherent programs. Therefore, it is sufficient to focus on debugging of incoherent programs only.\nGiven an incoherent program \u03a0 and a test case T , the goal is to highlight a set of rules of \u03a0T that cause the incoherence. Intuitively, not all rules of \u03a0 contribute to its incoherence.\nExample 4. Consider the program \u03a0 \u2032\u2032 and a test case T = {dry, umbrella} from Example 3. A debugger should identify the buggy rule:\n\u2190 rainy, dry .\nIndeed, given the rule \u2190\u223c dry and the fact rainy, the above constraint cannot be satisfied. In that case the buggy constraint should be replaced by:\n\u2190 rainy, dry, \u223cumbrella .\nUnfortunately, the set of buggy rules might be large, thus not helping the user to localize the fault. Therefore, in our approach the user is queried (in a smart and nonoverwhelming way) to retrieve further information about the expected solution. Every query allows the debugger to exclude irrelevant rules and identify the buggy ones more precisely. We implement this debugging strategy by using the concepts of solving under assumption and unsatisfiable cores [32] as described in the next section."}, {"heading": "3.2 The DWASP Strategy", "text": "In this section, we focus on how to integrate the debugging approach inside an ASP solver. The task of debugging an incoherent answer set program is computationally hard. Thus, integrating the approach inside an ASP solver aims to speed-up the debugging process. For instance, the solving-under-assumptions feature [12] implemented in modern ASP solvers [1,16] is used to compute an unsatisfiable core. In a nutshell, assumptions correspond to a set of literals A considered as true during the solving process. Whenever some of the assumptions are violated during the solving process, the conflicting set of literals C \u2286 A, called unsatisfiable core, is computed.\nIn order to utilize the solving-under-assumptions interface, a fresh debug atom is introduced to the body of each rule of \u03a0 , as defined in Definition 2. Furthermore, users can specify a set of rules B \u2286 \u03a0 called background knowledge that are considered to be correct. In the following, we assume B to comprise all facts of a logic program \u03a0 .\nDefinition 2 (Debugging Program). Let\u03a0 be an incoherent DLP, B be the background knowledge, and id : (\u03a0 \\ B) \u2192 N be an assignment of unique identifiers to the nonbackground knowledge rules of \u03a0 . Then, the debugging program \u2206\u03a0 of \u03a0 with respect to the background knowledge B is defined as\n\u2206\u03a0 = {a1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 am \u2190 l1, . . . ,ln, _debug(id(r), vars) | r \u2208 (\u03a0 \\ B), H(r) = {a1, . . . , am}, B(r) = {l1, . . . , ln}} , (3)\nwhere _debug(id(r), vars) is a fresh debug atom and vars is a tuple comprising all variables of B(r).\nExample 5. Consider the program \u03a0 \u2032 from Example 1. The corresponding debugging program is given as follows:\n\u2206\u03a0\u2032 = {pc(m1), pc(m2), paper(p1), bid(m1, p1, 2), some\u2212bid(M,P )\u2190 bid(M,P,X), _debug(1,M, P,X), bid(M,P, 1)\u2190\u223csome\u2212bid(M,P ), pc(M), paper(P ), _debug(2,M, P )}\nDebugging incoherent programs. Algorithm 1 depicts the implementation of the debugging strategy inside the solver. We consider an incoherent program \u03a0 for debugging and input its ground debugging program \u2206G\u03a0 to the debugger. First, we gather all debug atoms in the set A (line 2). Solving under the assumption that all debug atoms A are true causes the solver to return a minimal unsatisfiable core C containing debug atoms only (line 4). Debug atoms with the same identifier idr correspond to the (non-ground) rule r \u2208 \u03a0 , while a ground debug atom corresponds to exactly one ground rule of \u03a0 . Thus, the atoms inside the minimized unsatisfiable core uniquely identify the set of ground and non-ground rules of\u03a0 that cause the incoherence. We notify the user interface with these rules, which in turn highlights the rules to the user (line 5). Finally, we compute a query and issue it to the user, in order to add additional information to the set of assumptions A (lines 6-10) and start a new debugging iteration.\nAlgorithm 1: Debugging an incoherent logic program \u03a0 input: A ground debugging program \u2206G\u03a0 1 begin 2 A := {d | d is a debug atom of \u2206G\u03a0} 3 while user continues debugging session do 4 C := compute minimal unsatisfiable core under assumptions A 5 notify user interface with the rules corresponding to C 6 q := compute query atom using C and A 7 if user answers that q is expected to be true then 8 A := A \u222a {q} 9 else\n10 A := A \u222a {\u223cq}\nExample 6. Consider the debugging program \u2206\u03a0\u2032 from Example 5. The ground instantiation of the debugging program is:\n\u2206G\u03a0\u2032 = {pc(m1), pc(m2), paper(p1), bid(m1, p1, 2), some\u2212bid(m1, p1)\u2190 bid(m1, p1, 1), _debug(1,m1, p1, 1), some\u2212bid(m1, p1)\u2190 bid(m1, p1, 2), _debug(1,m1, p1, 2), some\u2212bid(m2, p1)\u2190 bid(m2, p1, 1), _debug(1,m2, p1, 1), bid(m1, p1, 1)\u2190\u223csome\u2212bid(m1, p1), pc(m1), paper(p1), _debug(2,m1, p1), bid(m2, p1, 1)\u2190\u223csome\u2212bid(m2, p1), pc(m2), paper(p1), _debug(2,m2, p1)}\nIn line 2, we add to the set of assumptions A all debugging atoms:\nA = {_debug(1,m1, p1, 1), _debug(1,m1, p1, 2), _debug(1,m1, p1, 1), _debug(2,m1, p1), _debug(2,m2, p1)}\nThe solver computes the minimal unsatisfiable core using A in line 4:\nC = {_debug(1,m2, p1, 1), _debug(2,m2, p1)}\nThe debugging atoms in C correspond to the ground rules\nsome\u2212bid(m2, p1)\u2190 bid(m2, p1, 1), _debug(1,m2, p1, 1) bid(m2, p1, 1)\u2190\u223csome\u2212bid(m2, p1), pc(m2), paper(p1), _debug(2,m2, p1)\nwhich in turn correspond to the following non-ground rules of \u03a0:\nsome\u2212bid(M,P )\u2190 bid(M,P,X), bid(M,P, 1)\u2190\u223csome\u2212bid(M,P ), pc(M), paper(P )\nIn line 6, the debugger determines q = bid(m2, p1, 1) as query atom. As we expect a solution containing bid(m2, p1, 1), we answer that q is expected to be true, which causes the solver to extend the set of assumptions A by bid(m2, p1, 1). In the next iteration, a new unsatisfiable core C is returned (line 4):\nC = {_debug(1,m2, p1, 1)}\nThe core C corresponds to following ground and non-ground rules\nsome\u2212bid(m2, p1)\u2190 bid(m2, p1, 1) some\u2212bid(M,P )\u2190 bid(M,P,X)\nof the faulty program \u03a0 \u2032. We now see that the bug is caused by the outlined rule, as it derives some\u2212bid(m2, p1) given bid(m2, p1, 1), which in turn is derived as default by the last rules of \u03a0 \u2032.\nQuery computation. In order to narrow the source of the incoherence, queries are used, as pointed out in the previous section. The computation of the queries is done by relaxing the unsatisfiable core, that is by removing some debugging atom from the set of assumptions until an answer set is found. A diagnosis is a set of debug atoms such that when they are removed from the set of assumptions, the relaxed program is coherent. The goal is to present the correct diagnosis to the user, however many diagnoses might exist. Ideally, a query is asked in a way that, regardless the answer to the query, the number of diagnosis is cut in half. Therefore, we choose the query atom as the atom q occurring in a half of the answer sets of the relaxed programs. If the user considers q to be true in the expected answer set, q is added to the assumptions and \u223cq otherwise.\nMissing support. Recall that an atom u is unsupported w.r.t. an interpretation I , if no rule derives the atom. Thus, if a supported atom u is true in an interpretation I , then I cannot be an answer set. Consider the case when the user asserts an atom u to be true in a test case T of \u03a0 , i.e. u \u2208 T , and u is unsupported in any answer set \u03a0 . The debugger will compute an unsatisfiable core of \u03a0T consisting of the rule\u2190\u223cu only. However, when there is no assertion\u2190\u223cu available, the computed core will be empty. Therefore, an additional way of detecting unsupported atoms is required. We extend the debugging program \u2206\u03a0 by the set of rules\n{a\u2190 _support(a) | a is an atom of \u03a0G} ,\nwhere _support(a) is a fresh atom called supporting atom of a. Assuming that the supporting atoms are false does not alter the semantics of the program. However, the solver will now include the supporting atoms inside the unsatisfiable core, allowing the identification of unfounded atoms inside the core. Therefore, during the debugging process depicted in Algorithm 1, we extend the set of assumptions A by the set of literals\n{\u223cs | s is a supporting atom of \u2206G\u03a0} .\nWe now identify an unsupported atom u \u2208 \u03a0 by having the atom _support(u) inside an unsatisfiable core C during the debugging process. Intuitively, the fault is rooted in some rule r failing to derive u, because (i) the body of r is not satisfied, or (ii) the body of r is satisfied but another atom of the head of r is chosen. Therefore, we select a query atom out of the set of atoms\nQ = \u22c3\nr\u2208{r|u\u2208H(r)}\n(H(r) \\ {u}) \u222aB+(r) \u222a { a |\u223ca \u2208 B\u2212(r) } . (4)"}, {"heading": "4 The DWASP System", "text": "In this section, we first give an overview of the debugging system and how the components interact with each other. Afterwards, we describe the graphical user interface DWASP-GUI in detail. Furthermore, we present the communication protocol between the GUI and the debugger. Finally, the integration with an integrated development environment for ASP, called ASPIDE [15], is presented.\nOur system consists of three components: GRINGO-WRAPPER \u2013 the debugging grounder, the solver DWASP, and the graphical user interface DWASP-GUI, as depicted in Fig. 1. The user interacts with DWASP-GUI and provides a program \u03a0 and some test case T . If the test case fails, i.e. \u03a0T is incoherent, a new debugging session is started. First, GRINGO-WRAPPER transforms\u03a0T to the debugging program\u2206\u03a0T . Then, the debugging program is passed to GRINGO3 in order to obtained the ground debugging program \u2206G\u03a0T . Afterwards, the debugger DWASP is started with \u2206G\u03a0T as input. Unsatisfiable cores and queries are computed and displayed to the user, until the fault is localized, as described in Section 3."}, {"heading": "4.1 User Interface DWASP-GUI", "text": "A screenshot of DWASP-GUI is depicted in Fig. 2. The workspace-view and test casesview list all files that contain the program encodings and test cases, respectively. Furthermore, the queries-view contains at most nine atoms (due to space restrictions of the GUI), whose truth-values are requested to be asserted by the user. The user answers a query by selecting either the button with the check-mark or with the cross and clicking on send. Afterwards, DWASP re-computes the unsatisfiable core and presents the results to the user. While debugging a program, all rules that are contained in the current unsatisfiable core are highlighted in red. When hovering over such a rule with the cursor, all substitutions as well as ground versions of the rules are displayed in a pop-up.\n3 Note that simplifications of GRINGO are disabled [10]"}, {"heading": "4.2 Integration with ASPIDE", "text": "We integrated the graphical user interface DWASP-GUI inside the integrated development environment ASPIDE [15]. The work-flow for testing and debugging is illustrated using the program presented in Example 1.\nIn Fig. 3, we present a screen-shot of ASPIDE with a workspace that has the program \u03a0 \u2032 loaded. The test case some_model.test uses an assertion of ASPIDE [14] that checks whether some answer set exists. On executing the test case some_model.test, the IDE tells us that the test case failed, as depicted in figure 4. In order to start the DWASP-system, we click on the Debug button. We are now presented with the interface DWASP-GUI as shown in figure 5, where we debug the faulty program as described in the previous section. Finally, we click on the Back to ASPIDE button, which returns us to ASPIDE, having the faulty rule highlighted as well."}, {"heading": "5 Related Work", "text": "Modern ASP debugging approaches can be mainly separated into integrated and declarative approaches. The first approaches are based on a tight integration with the solver, whereas the second ones are solver independent and are based on meta-programming.\nThe DLV debugger developed in [24] is an example of an integrated approach. It uses the reason calculus to detect and store the choices made by the solver during the backtracking phases in a reasons table. The table can be queried to justify the presence/absence of a literal in an answer set or to explain the incoherency of the program. This debugging system is however very limited, since it uses specific features\nof the DLV system and can only provide a partial interpretation justifying the lack of a model. IDEAS [4] is another procedural approach aiming at two types of problems: (a) why a set of atoms S is in an answer set M and (b) why S is not in any answer set. Both IDEAS algorithms are similar to the ones implemented in ASP solvers and try to decide which rules are responsible for derivation or non-derivation of atoms in S. The interactivity of IDEAS, as well as of all other modern debuggers allows a programmer: (1) to query a system for an explanation of an observed fault, (2) analyze the obtained results and (3) reformulate the query to make it more precise. In our approach we reuse the algorithms implemented in a solver and are able to find required refinements automatically, thus, making the steps (2) and (3) obsolete.\nThe declarative debuggers use a program over a meta language \u2013 a kind of ASP solver simulation \u2013 to manipulate a program over an object language \u2013 the faulty program. Each answer set of a meta-program comprises a diagnosis, which is a set of meta-atoms describing the cause why some interpretation of the faulty program is not its answer set. An approach used in SMDEBUG [31] addresses debugging of incoherent non-disjunctive ASP programs by adaption of model-based diagnosis [27]. Similarly to our approach the debugger focuses on detection of odd loops, but cannot detect problems arising due to unfounded sets. The SPOCK [17] and OUROBOROS [22,25] debuggers extend SMDEBUG by enabling identification of problems connected with unfounded sets. Both approaches represent the input program in a reified form allowing application of a debugging metaprogram. In case of SPOCK the debugging can be applied only to grounded programs, whereas OUROBOROS can tackle non-grounded programs as well. The main problem of meta-programming approaches is that often the grounding of the debugging metaprogram explodes. This is due to the fact that the ground debugging program has to comprise all atoms explaining all possible faults in an input faulty program, which is not the case in our approach. Moreover, our approach generalizes the interactive query-based method built on top of SPOCK [30] by enabling its application to non-ground programs.\nThere are other approaches enabling faults localization in ASP, but not directly comparable with DWASP, include Consistency-Restoring Prolog [3], translation of ASP programs to natural language [20], visualization of justifications for an answer set [26] as well as stepping thought an ASP program [21]. Combining these approaches with ideas implemented in DWASP is a part of our future work.\nIn [9] a web-based programming environment for the IDP system is presented. The IDE also provides a graphical interface for a debugging approach based on assumptions and core-detection. However, [9] applies it to a different language and it does feature a question-answering schema that is fundamental for reducing the set of buggy rules.\nIn [19], the authors present a debugging technique for normal ASP programs that is based on inductive logic programming (ILP) and test cases. The idea is to allow the programmer to specify test cases modeling features that are expected to appear in some solution and those that should not. These are used to to revise the original program semi-automatically so that it satisfies the stated properties. The implementation of the theory revision is done in ASP using an abductive logic programming technique. This approach can complement our debugging approach since it has the possibility to learn rules (and modifications of rules), whereas we focus on finding errors assuming the program is a complete specification.\nIn [28] a different approach to debugging ASP programs is presented, and the reason of an incoherence is studied in terms of a set of culprits (atoms) using semantics which are weaker than the answer set semantics. They also provide a technique for explaining the set of culprits in terms of derivations. This idea is further extended in [29], where argumentation theory is used to explain why a literal is or is not contained in a given answer set, and providing a means for studying relationships among literals. These approaches see the reason of a bug in the truth of a set of atoms, thus are, in a sense, complementary to our approach (we identify the rules involved in a conflict)."}, {"heading": "6 Conclusion", "text": "In this paper a new graphical interface for the DWASP debugger has been presented. The new interface improves the user-experience of debugging ASP programs with DWASP, a process that was possible before only trough a command line interface. Indeed, besides the usual advantages provided by visual tools, the new interface simplifies two tasks that are not easy to carry out in the command line interface, namely: the definition of test cases and the interactive query answering. The query answering feature is much more user friendly, since the user can simply select answers by clicking on dedicated buttons, and several possible answers are presented to the user in a convenient list. Several test cases can be easily loaded in the interface, and several debugging session can be seamlessly run on the same cases if needed. Also problematic rules are outlined immediately in the text editor so the user is pointed immediately from the interface to sources of bugs. DWASP-GUI has also been integrated in ASPIDE, which was missing a complete debugger interface supporting non ground ASP programs. The integration includes specific support for creating failing test cases to debug directly from the unit test framework provided by ASPIDE. With our extension ASPIDE turns into a full-fledged IDE by offering complete debugging support.\nAcknowledgments. The authors are grateful to Marc Deneker and Ingmar Dasseville for the fruitful discussions about debugging ASP programs, and in particular for the useful comments regarding the case of missing support.\nThis work was partially supported by the Austrian Science Fund (FWF) contract number I 2144 N-15, the Carinthian Science Fund (KWF) contract KWF-3520/26767/38701, the Italian Ministry of University, Research under PON project \u201cBa2Know (Business Analytics to Know) Service Innovation \u2013 LAB\u201d, No. PON03PE_00001_1, and by the Italian Ministry of Economic Development under project \u201cPIUCultura (Paradigmi Innovativi per l\u2019Utilizzo della Cultura)\u201d n. F/020016/01\u201302/X27."}], "references": [{"title": "Optimization Methods for the Partner Units Problem", "author": ["M. Aschinger", "C. Drescher", "G. Friedrich", "G. Gottlob", "P. Jeavons", "A. Ryabokon", "E. Thorstensen"], "venue": "CPAIOR. pp. 4\u201319", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Logic programs with consistency-restoring rules", "author": ["M. Balduccini", "M. Gelfond"], "venue": "AAAI Spring Symposium. pp. 9\u201318", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "Debugging Logic Programs under the Answer Set Semantics", "author": ["M. Brain", "M.D. Vos"], "venue": "Workshop on ASP. pp. 141\u2013152", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2005}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczynski"], "venue": "Commun. ACM 54(12), 92\u2013103", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Sealion: An eclipse-based IDE for answer-set programming with advanced debugging support", "author": ["P. Busoniu", "J. Oetsch", "J. P\u00fchrer", "P. Skocovsky", "H. Tompits"], "venue": "TPLP 13(4-5),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2013}, {"title": "Design and results of the fifth answer set programming competition", "author": ["F. Calimeri", "M. Gebser", "M. Maratea", "F. Ricca"], "venue": "Artif. Intell. 231, 151\u2013181", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2016}, {"title": "Logic Programming and Nonmonotonic Reasoning - 13th International Conference, LPNMR 2015, Lexington, KY, USA, September 27-30, 2015", "author": ["F. Calimeri", "G. Ianni", "Truszczynski", "M. (eds."], "venue": "Proceedings, Lecture Notes in Computer Science, vol. 9345. Springer", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "A web-based ide for idp", "author": ["I. Dasseville", "G. Janssens"], "venue": "International Workshop on User-Oriented Logic Programming (IULP 2015), Proceedings. http://iulp2015.unileipzig.de/#papers", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2015}, {"title": "Allotment problem in travel industry: A solution based on ASP", "author": ["C. Dodaro", "N. Leone", "B. Nardi", "F. Ricca"], "venue": "ten Cate, B., Mileo, A. (eds.) Web Reasoning and Rule Systems - 9th International Conference, RR 2015, Berlin, Germany, August 4-5, 2015, Proceedings. Lecture Notes in Computer Science, vol. 9209, pp. 77\u201392. Springer", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2015}, {"title": "Temporal induction by incremental SAT solving", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "Electr. Notes Theor. Comput. Sci. 89(4), 543\u2013560", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2003}, {"title": "Disjunctive datalog", "author": ["T. Eiter", "G. Gottlob", "H. Mannila"], "venue": "ACM TODS 22(3), 364\u2013418", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1997}, {"title": "Unit testing in ASPIDE", "author": ["O. Febbraro", "N. Leone", "K. Reale", "F. Ricca"], "venue": "Tompits, H., Abreu, S., Oetsch, J., P\u00fchrer, J., Seipel, D., Umeda, M., Wolf, A. (eds.) Applications of Declarative Programming and Knowledge Management - 19th International Conference, INAP 2011, and 25th Workshop on Logic Programming, WLP 2011, Vienna, Austria, September 28-30, 2011, Revised Selected Papers. Lecture Notes in Computer Science, vol. 7773, pp. 345\u2013364. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "ASPIDE: integrated development environment for answer set programming", "author": ["O. Febbraro", "K. Reale", "F. Ricca"], "venue": "Delgrande, J.P., Faber, W. (eds.) Logic Programming and Nonmonotonic Reasoning - 11th International Conference, LPNMR 2011, Vancouver, Canada, May 16-19, 2011. Proceedings. Lecture Notes in Computer Science, vol. 6645, pp. 317\u2013330. Springer", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan & Claypool Publishers", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "A meta-programming technique for debugging answer-set programs", "author": ["M. Gebser", "J. P\u00fchrer", "T. Schaub", "H. Tompits"], "venue": "AAAI. pp. 448\u2013453", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2008}, {"title": "ASP at work: Spin-off and applications of the DLV system", "author": ["G. Grasso", "N. Leone", "M. Manna", "F. Ricca"], "venue": "LNCS. vol. 6565, pp. 432\u2013451", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2011}, {"title": "Debugging ASP using ILP", "author": ["T. Li", "M.D. Vos", "J. Padget", "K. Satoh", "T. Balke"], "venue": "Proceedings of the Technical Communications of the 31st International Conference on Logic Programming (ICLP 2015), Cork, Ireland, August 31 - September 4, 2015. CEUR Workshop Proceedings, vol. 1433. CEUR-WS.org", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2015}, {"title": "Towards Debugging of Answer-Set Programs in the Language PSpb", "author": ["A. Mikitiuk", "E. Moseley", "M. Truszczynski"], "venue": "IC-AI. pp. 635\u2013640", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2007}, {"title": "Stepping through an Answer-Set Program", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "LPNMR. pp. 134\u2013147", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Catching the Ouroboros: On Debugging Non-ground Answer-Set Programs", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "TPLP 10(4-6), 2010", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2010}, {"title": "Catching the ouroboros: On debugging non-ground answerset programs", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "TPLP 10(4-6), 513\u2013529", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2010}, {"title": "An integrated graphic tool for developing and testing dlv programs", "author": ["S. Perri", "F. Ricca", "G. Terracina", "D. Cianni", "P. Veltri"], "venue": "SEA Workshop. pp. 86\u2013100", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2007}, {"title": "Debugging Non-ground ASP Programs with Choice Rules, Cardinality and Weight Constraints", "author": ["A. Polleres", "M. Fr\u00fchst\u00fcck", "G. Schenner", "G. Friedrich"], "venue": "LPNMR, pp. 452\u2013464", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. Pontelli", "T.C. Son", "O. El-Khatib"], "venue": "TPLP 9(1), 1\u201356", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2009}, {"title": "A Theory of Diagnosis from First Principles", "author": ["R. Reiter"], "venue": "Artif. Intell. 32(1), 57\u201395", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1987}, {"title": "Characterising and explaining inconsistency in logic programs", "author": ["C. Schulz", "K. Satoh", "F. Toni"], "venue": "Logic Programming and Nonmonotonic Reasoning - 13th International Conference, LPNMR 2015, Lexington, KY, USA, September 27-30, 2015. Proceedings. Lecture Notes in Computer Science, vol. 9345, pp. 467\u2013479. Springer", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2015}, {"title": "Interactive query-based debugging of ASP programs", "author": ["K. Shchekotykhin"], "venue": "AAAI. pp. 1597\u20131603", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2015}, {"title": "Debugging Inconsistent Answer Set Programs", "author": ["T. Syrj\u00e4nen"], "venue": "NMR. pp. 77\u201384", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2006}, {"title": "Validating SAT solvers using an independent resolution-based checker: Practical implementations and other applications", "author": ["L. Zhang", "S. Malik"], "venue": "2003 Design, Automation and Test in Europe Conference and Exposition (DATE 2003), 3-7 March 2003, Munich, Germany. pp. 10880\u201310885. IEEE Computer Society", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 3, "context": "Answer Set Programming (ASP) [5] is a declarative programming paradigm proposed in the area of logic programming and non-monotonic reasoning.", "startOffset": 29, "endOffset": 32}, {"referenceID": 10, "context": "Computational problems of comparatively high complexity can be modeled in the expressive language of ASP [13], which provides a clear separation between the specification of a problem and the computation of its solutions by an ASP solver.", "startOffset": 105, "endOffset": 109}, {"referenceID": 0, "context": "The rather simple syntax of ASP paired with high-performance solvers makes ASP a valuable tool for developing complex research and industrial applications [2,7,11,18].", "startOffset": 155, "endOffset": 166}, {"referenceID": 5, "context": "The rather simple syntax of ASP paired with high-performance solvers makes ASP a valuable tool for developing complex research and industrial applications [2,7,11,18].", "startOffset": 155, "endOffset": 166}, {"referenceID": 8, "context": "The rather simple syntax of ASP paired with high-performance solvers makes ASP a valuable tool for developing complex research and industrial applications [2,7,11,18].", "startOffset": 155, "endOffset": 166}, {"referenceID": 15, "context": "The rather simple syntax of ASP paired with high-performance solvers makes ASP a valuable tool for developing complex research and industrial applications [2,7,11,18].", "startOffset": 155, "endOffset": 166}, {"referenceID": 15, "context": "Namely, ASP programs are flexible, intuitive, extensible and easy to maintain [18].", "startOffset": 78, "endOffset": 82}, {"referenceID": 2, "context": "For this reason, several methodologies and tools have been proposed in the last few years for debugging ASP programs [4,17,22,21,26], with the goal of making the development process faster and more comfortable.", "startOffset": 117, "endOffset": 132}, {"referenceID": 14, "context": "For this reason, several methodologies and tools have been proposed in the last few years for debugging ASP programs [4,17,22,21,26], with the goal of making the development process faster and more comfortable.", "startOffset": 117, "endOffset": 132}, {"referenceID": 19, "context": "For this reason, several methodologies and tools have been proposed in the last few years for debugging ASP programs [4,17,22,21,26], with the goal of making the development process faster and more comfortable.", "startOffset": 117, "endOffset": 132}, {"referenceID": 18, "context": "For this reason, several methodologies and tools have been proposed in the last few years for debugging ASP programs [4,17,22,21,26], with the goal of making the development process faster and more comfortable.", "startOffset": 117, "endOffset": 132}, {"referenceID": 23, "context": "For this reason, several methodologies and tools have been proposed in the last few years for debugging ASP programs [4,17,22,21,26], with the goal of making the development process faster and more comfortable.", "startOffset": 117, "endOffset": 132}, {"referenceID": 19, "context": "new approach overcomes the limits [22] of state-of-the-art debuggers based on metaprogramming [17,22], which suffer from a grounding blow-up problem.", "startOffset": 34, "endOffset": 38}, {"referenceID": 14, "context": "new approach overcomes the limits [22] of state-of-the-art debuggers based on metaprogramming [17,22], which suffer from a grounding blow-up problem.", "startOffset": 94, "endOffset": 101}, {"referenceID": 19, "context": "new approach overcomes the limits [22] of state-of-the-art debuggers based on metaprogramming [17,22], which suffer from a grounding blow-up problem.", "startOffset": 94, "endOffset": 101}, {"referenceID": 12, "context": "Following this trend, the debugging approaches for ASP have been usually integrated in programming environment such as ASPIDE [15] or SeaLion [6,23].", "startOffset": 126, "endOffset": 130}, {"referenceID": 4, "context": "Following this trend, the debugging approaches for ASP have been usually integrated in programming environment such as ASPIDE [15] or SeaLion [6,23].", "startOffset": 142, "endOffset": 148}, {"referenceID": 20, "context": "Following this trend, the debugging approaches for ASP have been usually integrated in programming environment such as ASPIDE [15] or SeaLion [6,23].", "startOffset": 142, "endOffset": 148}, {"referenceID": 11, "context": "Indeed ASPIDE provides a unit-testing framework [14] that was connected with DWASP to automatically generate failing test cases for the debugger.", "startOffset": 48, "endOffset": 52}, {"referenceID": 20, "context": "Example 1 (ASP conference system [23]).", "startOffset": 33, "endOffset": 37}, {"referenceID": 28, "context": "We implement this debugging strategy by using the concepts of solving under assumption and unsatisfiable cores [32] as described in the next section.", "startOffset": 111, "endOffset": 115}, {"referenceID": 9, "context": "For instance, the solving-under-assumptions feature [12] implemented in modern ASP solvers [1,16] is used to compute an unsatisfiable core.", "startOffset": 52, "endOffset": 56}, {"referenceID": 13, "context": "For instance, the solving-under-assumptions feature [12] implemented in modern ASP solvers [1,16] is used to compute an unsatisfiable core.", "startOffset": 91, "endOffset": 97}, {"referenceID": 12, "context": "Finally, the integration with an integrated development environment for ASP, called ASPIDE [15], is presented.", "startOffset": 91, "endOffset": 95}, {"referenceID": 12, "context": "We integrated the graphical user interface DWASP-GUI inside the integrated development environment ASPIDE [15].", "startOffset": 106, "endOffset": 110}, {"referenceID": 11, "context": "test uses an assertion of ASPIDE [14] that checks whether some answer set exists.", "startOffset": 33, "endOffset": 37}, {"referenceID": 21, "context": "The DLV debugger developed in [24] is an example of an integrated approach.", "startOffset": 30, "endOffset": 34}, {"referenceID": 2, "context": "IDEAS [4] is another procedural approach aiming at two types of problems: (a) why a set of atoms S is in an answer set M and (b) why S is not in any answer set.", "startOffset": 6, "endOffset": 9}, {"referenceID": 27, "context": "An approach used in SMDEBUG [31] addresses debugging of incoherent non-disjunctive ASP programs by adaption of model-based diagnosis [27].", "startOffset": 28, "endOffset": 32}, {"referenceID": 24, "context": "An approach used in SMDEBUG [31] addresses debugging of incoherent non-disjunctive ASP programs by adaption of model-based diagnosis [27].", "startOffset": 133, "endOffset": 137}, {"referenceID": 14, "context": "The SPOCK [17] and OUROBOROS [22,25] debuggers extend SMDEBUG by enabling identification of problems connected with unfounded sets.", "startOffset": 10, "endOffset": 14}, {"referenceID": 19, "context": "The SPOCK [17] and OUROBOROS [22,25] debuggers extend SMDEBUG by enabling identification of problems connected with unfounded sets.", "startOffset": 29, "endOffset": 36}, {"referenceID": 22, "context": "The SPOCK [17] and OUROBOROS [22,25] debuggers extend SMDEBUG by enabling identification of problems connected with unfounded sets.", "startOffset": 29, "endOffset": 36}, {"referenceID": 26, "context": "Moreover, our approach generalizes the interactive query-based method built on top of SPOCK [30] by enabling its application to non-ground programs.", "startOffset": 92, "endOffset": 96}, {"referenceID": 1, "context": "There are other approaches enabling faults localization in ASP, but not directly comparable with DWASP, include Consistency-Restoring Prolog [3], translation of ASP programs to natural language [20], visualization of justifications for an answer set [26] as well as stepping thought an ASP program [21].", "startOffset": 141, "endOffset": 144}, {"referenceID": 17, "context": "There are other approaches enabling faults localization in ASP, but not directly comparable with DWASP, include Consistency-Restoring Prolog [3], translation of ASP programs to natural language [20], visualization of justifications for an answer set [26] as well as stepping thought an ASP program [21].", "startOffset": 194, "endOffset": 198}, {"referenceID": 23, "context": "There are other approaches enabling faults localization in ASP, but not directly comparable with DWASP, include Consistency-Restoring Prolog [3], translation of ASP programs to natural language [20], visualization of justifications for an answer set [26] as well as stepping thought an ASP program [21].", "startOffset": 250, "endOffset": 254}, {"referenceID": 18, "context": "There are other approaches enabling faults localization in ASP, but not directly comparable with DWASP, include Consistency-Restoring Prolog [3], translation of ASP programs to natural language [20], visualization of justifications for an answer set [26] as well as stepping thought an ASP program [21].", "startOffset": 298, "endOffset": 302}, {"referenceID": 7, "context": "In [9] a web-based programming environment for the IDP system is presented.", "startOffset": 3, "endOffset": 6}, {"referenceID": 7, "context": "However, [9] applies it to a different language and it does feature a question-answering schema that is fundamental for reducing the set of buggy rules.", "startOffset": 9, "endOffset": 12}, {"referenceID": 16, "context": "In [19], the authors present a debugging technique for normal ASP programs that is based on inductive logic programming (ILP) and test cases.", "startOffset": 3, "endOffset": 7}, {"referenceID": 25, "context": "In [28] a different approach to debugging ASP programs is presented, and the reason of an incoherence is studied in terms of a set of culprits (atoms) using semantics which are weaker than the answer set semantics.", "startOffset": 3, "endOffset": 7}], "year": 2016, "abstractText": "Answer Set Programming (ASP) is an expressive knowledge representation and reasoning framework. Due to its rather simple syntax paired with high-performance solvers, ASP is interesting for industrial applications. However, to err is human and thus debugging is an important activity during the development process. Therefore, tools for debugging non-ground answer set programs are needed. In this paper, we present a new graphical debugging interface for non-ground answer set programs. The tool is based on the recently-introduced DWASP approach for debugging and it simplifies the interaction with the debugger. Furthermore, the debugging interface is integrated in ASPIDE, a rich IDE for answer set programs. With our extension ASPIDE turns into a full-fledged IDE by offering debugging support.", "creator": "LaTeX with hyperref package"}}}