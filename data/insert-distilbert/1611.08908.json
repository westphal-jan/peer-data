{"id": "1611.08908", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Nov-2016", "title": "\"Model and Run\" Constraint Networks with a MILP Engine", "abstract": "constraint programming ( cp ) method users need significant expertise in order to smoothly model their problems appropriately, notably to select propagators and search strategies. this puts the brakes on a broader uptake of 2d cp. in this paper, we introduce mice, a complete java cp modeler family that can use any dedicated mixed integer linear program programming ( milp ) solver as a solution layout technique. our aim is to easily provide an alternative tool for democratizing back the \" cp - style \" modeling thanks to its simplicity of use, and with reasonable solving capabilities. our supporting contributions include new decompositions capabilities of ( reified ) constraints and constraints on numerical variables.", "histories": [["v1", "Sun, 27 Nov 2016 20:43:27 GMT  (34kb)", "http://arxiv.org/abs/1611.08908v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["thierry petit"], "accepted": false, "id": "1611.08908"}, "pdf": {"name": "1611.08908.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Thierry Petit"], "emails": ["tpetit@{wpi.edu,"], "sections": [{"heading": null, "text": "ar X\niv :1\n61 1.\n08 90\n8v 1\n[ cs\n.A I]\n2 7\nN ov"}, {"heading": "1 Introduction", "text": "Modern MILP solvers, e.g., IBM CPLEX or Gurobi, can be defined as \u201cmodel and run\u201d systems [20]. They embed dynamic procedures so as to to make simple models solved efficiently [2]. Conversely, despite CP is a declarative technology, CP users need significant expertise in order to model their problems appropriately. This expertise is required to select propagators and to state a search strategy, which are main components of the modeling phase. This may put the brakes on a broader uptake of CP.\nIn this paper, we present MICE, a simple API to solve CP models, which may use any MILP engine called from Java. Our objective is not to design a winner between classical, propagation-based CP solvers and MILP engines. Obviously, some problems are best solved by CP and other best solved using MILP; and other require hybridization. Our aim is to help democratizing the \u201cCP-style\u201d modeling standards by providing a black-box tool where models are just variables plus constraints, with solving capabilities good enough for prototyping and teaching. This first step might convince practitioners who are not researchers in optimization or just discover the existence of CP to further increase their expertise. Without such initiation, some developers may not spend time in learning complex concepts, even less a language specifically dedicated to highlevel CP-style modeling. MICE is thus not a competitor to such languages anymore. This idea motivates the design of an API in a popular programming language, where a model just consists of method calls for stating variables and constraints.\nAs CP toolkits are not restricted to a list of linearized global constraints, we provide new theoretical contributions regarding non linear constraints with arithmetic operators (e.g., z = xi \u00d7 xj or z = xki ), negative and positive tables, and reification. We propose extensions of the CP constraints Deviation and InterDistance to numerical variables. Such case studies show the benefits of the approach for tackling\nproblems that usually require to hybridize discrete and continuous solvers, providing that real constraints can be linearized. Efficiency of solving may then be very good when MICE is associated with a commercial MILP solver. A result of our research is that all new decompositions useful to design MICE revealed to be quite simple."}, {"heading": "2 Tables, Arithmetic Constraints and Logical Operators", "text": "MILP models support linear constraints, objectives and linearized logical constraints. CP models make no restriction about the constraints. On the other hand, CP variables must range over a finite domain of values. This domain constraint can be encoded by linear constraints, which permitted to linearize many CP global constraints [25,22,6].\nLemma 1 (Domain linearization (from Refalo\u2019s statement [22])). Let D = {v1, . . . , vm} be the domain union of a model. All the domains {d1, . . . , dn} of variables in X can be stated using a set B of O( \u2211 i\u2208{1,...,n} |di|) binary variables and O(n) inequalities. \u2200vj \u2208 D, \u2200xi \u2208 X , if vj \u2208 di state a binary variable bij . \u2200xi, state: (\n\u2211 vj\u2208di vjbij)\u2212 xi = 0 and \u2211 bij :vj\u2208di bij = 1.\nDomains and table constraints can be represented by linear constraints. As tables are generic and domain are finite, there is no theoretical dominance property between MILP and CP concerning modeling capabilities. CP models are generally more concise than linear models with (global) constraint decompositions. However, some problems require table constraints (without semantics), e.g., in computational biology [18]. Some constraint checkers may not be tractable, even for a ground solution (for instance, min. overlapping variable given a set of rectangles in a fixed plane, stated by length and width variables). At last, it is probably easier to efficiently extend a model with numerical variables using MILP, without the need to discretize space. Modeling in CP and MILP is therefore more complex to compare than it at first seems, which also justifies to investigate how a MILP solver performs as a solution technique for a CP modeler.\nA CP model is not restricted to a set of global constraints whose linear formulations are found in the literature. We need (non linear) constraints built from arithmetic operators, negative and positive tables, and efficient reification. We investigate appropriate solutions to these issues. Especially, we show that table constraints provide a good way to deal with arithmetic operators and can compactly be reified using linear constraints.\nA decomposition of positive table constraints is introduced in [6]: add one binary variable b\u03c4k per tuple \u03c4k, and state that each variable xi should be constrained by xi =\u2211|T |\nk=1 b\u03c4k .\u03c4k[xi]. This formulation needs two additional constraints: (1) \u2211|T |\nk=1 b\u03c4k \u2264 1. If not, a constraint on {x1, x2, x3} with T = {(1, 1, 1), (3, 3, 3)} would be considered as satisfied if x1 = x2 = x3 = 4. (2) \u2211|T |\nk=1 b\u03c4k \u2265 1, to have at least one tuple satisfied. As the domain constraint (Lemma 1) ensures unicity of values assigned to variables through some binary variables, we can suppress the first one using a different decomposition. Our new linearization is exclusively stated on binary variables and can be naturally modified to encode negative tables and/or compact reified tables.\nLemma 2 (Positive table linearization). Let c be a constraint defined on var(c) \u2286 X by a set T = {\u03c41, . . . , \u03c4|T |} of positive tuples. We introduce a set of binary variables\nBT , one-to-one mapped with tuples in T . c can be represented by the domain decomposition of X and O(|T |) inequalities and binary variables. For each tuple \u03c4k \u2208 T and its corresponding variable b\u03c4k \u2208 BT state: |var(c)|b\u03c4k \u2212( \u2211 i,vj\u2208di:vj=\u03c4k[xi] bij) \u2264 0. (1) In addition, state once the constraint: \u2211|T |\nk=1 b\u03c4k \u2265 1.\nProof. For each tuple, constraint (1) ensures that if b\u03c4k = 1 then any variable xi \u2208 var(c) takes the value \u03c4k[xi]. From such tuple constraints and Lemma 1, \u2211 k\u2208{a,...,|T |} b\u03c4k is at most equal to 1, otherwise two tuples in T would be equal. The last inequality constrains \u2211 k\u2208{a,...,|T |} b\u03c4k to be at least equal to 1, i.e., the assignment of var(c) corresponds to one tuple of T .\nLemma 3 (Negative table linearization). Let c be a constraint defined on var(c) \u2286 X by a set T = {\u03c41, . . . , \u03c4|T |} of forbidden tuples. c can be represented by the domain decomposition of X and O(|T |) inequalities. \u2200\u03c4k \u2208 T state: ( \u2211 i,vj\u2208di:vj=\u03c4k[xi] bij) \u2264 |var(c)| \u2212 1.\nProof. For c to be satisfied, \u2200\u03c4k \u2208 T at least one variable xi \u2208 var(c) should take a value vj 6= \u03c4k[xi]. From Lemma 1, if xi = vj then bij = 1, otherwise bij = 0.\u2211\ni,vj\u2208di:vj=\u03c4k[xi] bij must be < |var(c)|.\nSome constraints can be concisely and thus quite efficiently represented by tables, e.g., arithmetic operators. For instance, constraint z = xki where z and xi are integer domain variables and k a positive integer can be stated using |di| allowed tuples. The constraint z = xi \u00d7 xj requires |di| \u00d7 |dj | allowed tuples to be stated. Many other constraints are also appropriate for table-based linear representation. The Element constraint can be represented using Lemma 2, thanks to its positive tuples. This formulation is distinct from the existing ones [14,22] and does not add integer variables for indexes.\nLemma 4 (Element linearization). Let xi and xj be two integer domain variables and t an array of integers, not necessarily all distinct. Element is statisfied if an only if xj is equal to the xthi value in the array t. From Lemma 2, Element on (xi, xj) can be decomposed using O(min(|t|, |di|, |dj |)) inequalities and binary variables.\nProof. \u2200t[k] \u2208 t, add the tuple (k, t[k]) in the table if k \u2208 D(xi) and t[k] \u2208 D(xj).\nFor sake of space, we do not provide a broader list of constraints that would likely be represented by tables. In some cases, however, the number of tuples may be prohibitive. Let us consider one noticeable case against tables: Alldifferent, that holds iff \u2200(xi, xj) \u2208 var(c), xi 6= xj . A concise ad-hoc linearization exists [25,22]. In contrast, a positive table would have a number of tuples of the order of magnitude of the number of permutations of the values in domains. The case of a negative table is worst. As some constraints may be difficult to linearize in an ad hoc fashion, we consider two classical CP notions that may help for using tables: decompositions and implied constraints.\nAd Hoc CP Decompositions. In the CP literature, many papers put the focus on decomposing constraints not only using linear equations, but using other (simpler) constraints standardly provided by CP solvers (see, e.g., [9]). In MILP there is no obvious link between the use of global constraints [8] and solving process efficiency, as such constraints must be expressed through linear equations. In the case of Alldifferent, a well-known decomposition is to state for each variable pair a binary inequality. Although representing a binary inequality through table constraints is, to say the least, convoluted, we may note that decomposing makes possible a table-based formulation (using O(d) negative tuples per inequality). Concerning systematic decomposition schemes, the generic automaton based decomposition of the global constraint catalog [4] is well suited to table constraint based linearization, as transition and signature constraints often correspond to positive tables with small scopes. It can be applied on those constraints that can be checked by scanning once through their variables. For instance, using Lemmas 2 and 3, Example 2 of section 3 in [3] provides an exploitable linear decomposition for lexicographical constraints.\nImplied Constraints. The Gcc [23] would likely be implied to any other one, as it refers to occurrences of values in solutions. The Gcc has some particular properties that make it easy to learn from a model [7]. Therefore, it can be an efficient tool for reducing tuples of a negative table (all tuples violating the Gcc are not added to the table).\nDefinition 1 (Gcc). Let X = {x1, . . . , xn} be a set of variables, t an array of values. Each t[k] \u2208 t is associated with two integers t[k] and t[k], 0 \u2264 t[k] \u2264 t[k]. Gcc holds\nif and only if for all indexes k: t[k] \u2264 |{i : xi = t[k]}| \u2264 t[k].\nThe next Lemma provides a linear formulation of Gcc that adds O(|t|) binary inequalities to the model. It differs from the existing one [22] because it is related to a simpler version of the Gcc. In Definition 1, bounds on value occurrences are stated using integer values, not variables. In our context variables are useless.\nLemma 5 (Gcc linearization). We use the notations of Lemma 1 and Definition 1. For all t[k] \u2208 t, Bt[k] = {bij \u2208 B : vj = t[k]}. Gcc can be represented by the domain decomposition of X and O(|t|) inequalities. \u2200t[k] \u2208 t state: (\n\u2211 b\u2208Bt[k] b) \u2265\nt[k] and ( \u2211\nb\u2208Bt[k] b) \u2264 t[k].\nProof. From Lemma 1, \u2200bij \u2208 B, bij = 1 if and only if xi = vj .\nUsing a Gcc as an implied constraint introduces only O(|t|) inequalities and no additional variable. Let\u2019s come back to the Alldifferent example. It is worthwhile to notice that adding the implied Gcc eliminates all the tuples of an Alldifferent decomposed by a negative table. We obtain the ad hoc Alldifferent Refalo\u2019s linearization from Lemma 5. This is an extreme case but, more generally, in practical problems implied Gcc\u2019s can have shrink bounds [7].\nReification. Instead of merely posting a constraint c it is often useful to reflect its truth value into a binary variable rc. This process is called reification. It permits to express logical constraints such as ci \u2228 cj , or \u00acc. Table constraints reification relies to\nideas of Koster\u2019s partial constraint satisfaction formulation in the context of frequency assignment problems [15]. Basically, we can extend the table with variable rc. Naively one may state that rc is equal to 1 for allowed tuples and 0 for forbidden ones. The number of tuples would be all the combinations of values of the cartesian product of |var(c)|. We propose a decomposition that does not increase the number of tuples of c.\nLemma 6 (Table constraint reification). We keep the notations of Lemma 2. The set T can either represent allowed or forbidden tuples. The reification of a table constraint c can be represented by the domain decomposition of X , the binary variable rc used to express the truth value of c and O(|T |) inequalities and binary variables. (1) \u2200\u03c4k \u2208 T state: |var(c)|b\u03c4k \u2212 ( \u2211 i,vj\u2208di:vj=\u03c4k[xi] bij) \u2264 0, and: ( \u2211 i,vj\u2208di:vj=\u03c4k[xi] bij) \u2212 |var(c)|b\u03c4k \u2264 |var(c)| \u2212 1. (2) In addition, if tuples in T are allowed tuples state: ( \u2211 k\u2208{a,...,|T |} b\u03c4k)\u2212 rc = 0, otherwise state: ( \u2211 k\u2208{a,...,|T |} b\u03c4k) + rc = 1.\nProof. \u2200\u03c4k \u2208 T the first inequality ensures that if b\u03c4k = 1 then all xi \u2208 var(c) take the value \u03c4k[xi]. If b\u03c4k = 0 it is always satisfied. The second one ensures that if b\u03c4k = 0 not all the variables xi \u2208 var(c) take the value \u03c4k[xi]. If b\u03c4k = 1 it is always satisfied. From Lemma 1, \u2211 k\u2208{a,...,|T |} b\u03c4k \u2264 1. From (2), rc = 1 if and only if the variables in var(c) are fixed with a tuple of T (positive table) or not in T (negative table).\nIf the Gcc is added to the model as an implied constraint related to a reified table, we also need to reify it. For this purpose, or simply as this may be useful in models, we introduce a new linear decomposition.\nLemma 7 (Gcc reification). We use Lemma 5 notations. Let rc be the binary variable for the truth value of the Gcc to be reified. We create O(|t|) binary variables rk+c , mapped with values in t and O(|t|) binary variables rk\u2212c , also mapped. R is the set of all rk\u2212c and all r k+ c variables, of size 2|t|. The reifed Gcc is obtained by the domain decomposition of X . In addition, \u2200t[k] \u2208 t state:\n( \u2211\nb\u2208Bt[k]\nb)\u2212t[k]rk\u2212c \u2265 0. (1) ( \u2211\nb\u2208Bt[k]\nb)\u2212rk\u2212c (n+1) \u2264 t[k]\u22121. (2)\n( \u2211\nb\u2208Bt[k]\nb) + (t[k] + 1)rk+c \u2265 t[k] + 1 ( \u2211\nb\u2208Bt[k]\nb) + nrk+c \u2264 t[k] + n.\nMoreover, state once: ( \u2211 r\u2208R r)\u2212rc \u2264 2|t|\u22121. (3) ( \u2211 r\u2208R r)\u22122|t|rc \u2265 0. (4)\nProof. We first consider the case of one value t[k] \u2208 t. Without loss of generality we restrict to t[k] (the case of maximum occurence is symmetrical). If r\u2212kc = 0 then (1) is always satisfied and (2) is satisfied if and only if\n\u2211 b\u2208Bt[k] \u2264 t[k]\u22121, i.e., the minimum\nrequired number of occurrences of t[k] is not reached. If rk\u2212c = 1 then (2) is always satisfied and (1) is satisfied if and only if (\n\u2211 b\u2208Bt[k] b) \u2265 t[k]. Then, consider all values.\nIf \u2211\nr\u2208R r = 2|t| then all lower and upper cardinalities are in the request bounds, rc = 1 to satisfy constraint (3). Otherwise, (3) is always satisfied. If \u2211 r\u2208R r < 2|t| then rc = 0 to satisfy constraint (4). Otherwise, (4) is always satisfied. The Lemma holds.\nFor sake of space we do not provide a broader list of reified global constraints. It is worth saying that the general idea behind reification is generic: isolate a satisfaction property and then use the \u201cBig-M\u201d principle to obtain the boolean value. This general principle can also be used for the constraints on numerical variables presented in next section. We claim that its simplicity is a valuable result.\n3 The MICE modeler\nMICE is a Java modeler devoted to solve CP models using any MILP engine that can be called from Java. MICE embeds predefined global constraints1, tables, arithmetic and logical operators. The two central ideas of MICE design are the following. 1. Simplicity of use. MICE is primarily designed to provide users who are not expert in optimization with an autonomous tool for solving CP models. A MICE model is just defined by stating variables and high-level constraints, set on integer or numerical variables, to tackle also discrete-continuous problems. 2. Modular design. MICE provides its own API for stating linear constraints. Therefore, all predefined constraints as well as user decompositions are stated using MICE objects. To plug MICE to a new MILP solver, the main class, called Solver, should be augmented by a call to the method creating a new model in the MILP solver. In addition, a unique new class must be created. This class implements an interface that states the methods used to create mathematical variables and linear constraints within the MILP engine (this makes the link with MICE linear expressions), to call specific methods for running the MILP solver, limiting time, and some getters (value of a mathematical variable, solver statistics, etc.). MICE can solve satisfaction and optimization problems. Logical constraints are set through tables on reification variables. Given any two reified constraints c1 and c2, ReifOR is a table2 on the truth variables r1 and r2 and a new variable r: the allowed tuples on {r1, r2, r} are {(0, 0, 0), (0, 1, 1), (1, 0, 1), (1, 1, 1)}. Stating OR is then r = 1. The cases of AND, \u00ac and \u2192 (implication) are similar. There is no limitation about the number of logical operator combinations on reified constraints.\nMICE permits to use in the same model global constraints on integer and numerical variables. Consider that every variable x comes up with a lower bound x and an upper bound x (without loss of generality, these values can be the minimum and maximum value encodable by the computer). Next definition (derived from the Santa Claus benchmark [12]) generalizes the Deviation constraint [26], stated to obtain balanced solutions to combinatorial problems, by considering a numerical variable for the mean instead of an (arbitrary) integer value.\nDefinition 2 (Extended Deviation). Let X = {x1, . . . , xn} be a set of variables (integer or numerical). Let z and s be numerical variables. Deviation holds if and only if: nz = ( \u2211n i=1 xi) and s = ( \u2211n i=1 |xi \u2212 z|).\nTo linearize Deviationwe first need to linearize the constraint abs = |x\u2212 y|, where x, y and abs are mathematical variables of any type.\n1 A set of global constraints similar to existing CP solvers such as Choco or OR-Tools. 2 To simplify the description we do not use Lemma 6, although the two formulations can obvi-\nously be considered.\nLemma 8 (abs = |x\u2212y| linearization). We use the following notations: Given x, x, y, and y, a is the minimum possible value of |x \u2212 y| and A the maximum possible value. d is the minimum possible value of x \u2212 y and D the maximum possible value. We then distinguish three cases.\n1. D \u2264 0. Add abs \u2212 y + x = 0. 2. d \u2265 0. Add abs \u2212 x+ y = 0. 3. d < 0 < D. Add a \u2264 abs and abs \u2264 A, define three variables dif , difp and difn ,\na binary variable b and state:\ndif \u2212 x+ y = 0. (1) 0 \u2264 difp and difp \u2264 D. (2)\n0 \u2264 difn and difn \u2264 |d|. (3) d \u2264 dif and dif \u2264 D. (4)\ndif \u2212 difp + difn = 0. (5) difp \u2212Db \u2264 0. (6)\ndifn + |d|b \u2264 |d|. (7) abs \u2212 difp \u2212 difn = 0. (8)\nProof. Cases 1 and 2 are obvious. If d < 0 < D, constraints (2) (3) and (4) state the bounds of difp , difn and dif . From (1), dif = x \u2212 y. (5) states x \u2212 y = difp \u2212 difn . From (2) and (3) difp \u2265 0 and difn \u2265 0. We have: either difp > 0, then from (6) b = 1, and from (7) difn = 0: from (8), abs = x \u2212 y; or difn > 0, from (7) b = 0, from (6) difp = 0: from (8), abs = y \u2212 x; otherwise, abs = difp = difn = 0.\nFrom Lemma 8 and Definition 2, we decompose Deviation.\nLemma 9 (Deviation linearization). We denote by DistanceXYZ(x, y, abs) the linearization of constraint abs = |x \u2212 y| of Lemma 8. Let Z = {abs1, . . . , absn} be numerical variables. Deviation (Definition 2) can be represented by the following set of linear constraints: \u2200xi \u2208 X,DistanceXYZ(xi, z, abs i). In addition state once: nz \u2212 ( \u2211n i=1 xi) = 0 and s\u2212 ( \u2211n i=1 abs i) = 0.\nThe InterDistance constraint [24,21] holds on integer variables {x1, . . . , xn} and a constant p if and only if |xi \u2212 xj | \u2265 p for all i 6= j. Our decomposition extends it to variables of any type and a numerical variable for p: \u2200xi, xj , i < j, state DistanceXYZ(xi, xj , abs ij) and abs ij \u2265 p."}, {"heading": "4 Experiments and Conclusion", "text": "In our experiments MICE is coupled with Gurobi [13] on a I7 with 8GB of RAM. We consider CP solvers that can be called from Java, and, to truly compare with classical CP, with an API for stating advanced search strategies. In this paper our goal is to compare with CP, not with hybrid techniques or systems adding implicit constraints to the model, even less to solvers specific to one particular problem. We consider solver hybridization in the discrete-continuous case, because discrete-continuous models can directly be stated using MICE providing that real constraints can be linearized.\nTable 1 focuses on satisfaction problems stem from Choco 3.3.3 [19] and OR-Tools [17] sample directories (see CSPlib 3 for descriptions) that use\n3 http://www.csplib.org/\nProblem Ad hoc Bin. tables CP CP Alldifferent (Lemma 3) default best found\nstrategy strategy Sudoku 1 to 6 0 sec. 0 sec. 0 sec. 0 sec.\nprob03-10 0.1 sec. 0.1 sec. 0 sec. 0 sec. prob03-20 1.5 sec. 2.1 sec. 0.2 sec. 0.2 sec. prob07-12 0.1 sec. 0.1 sec. 0.2 sec. 0 sec. prob07-14 0.3 sec. 0.3 sec. 0.7 sec. 0.1 sec. prob07-16 0.4 sec. 0.4 sec. 20 sec. 0.1 sec. prob07-18 0.6 sec. 0.6 sec. > 1 min. 0.1 sec. prob019-5 0 sec. 0.1 sec. 0 sec. 0 sec. prob019-6 1 sec. 9.8 sec. 1.7 sec. 1.7 sec. prob019-7 3.5 sec. 3.1 sec. > 1 min. 6.4 sec.\nTable 1. MICE with Gurobi: satisfaction problems. The CP best strategies include specific static orders and more advanced techniques, such as impact based search with parameter values specific to a given instance (prob19-7).\nSeries MICE MICE av. MICE av.CP CP av. CP av. (10 instances) optimal proofs obj. value time (sec.) optimal proofs obj. value time (sec.) bqp50 100% 1926.8 60.1 60% 1903.9 447.3 g05 20 100% 64.9 1.9 100 % 64.9 3.6 g05 30 100% 138.8 40.1 0 % 137.1 600 g05 40 40% 244.9 (3.2%) 549.1 0 % 228.2 600\nTable 2. MICE with Gurobi vs CP: maximization problems.\nthe Alldifferent global constraint (we report the best result among the two solvers/different propagator options). We compare linear decompositions of Alldifferent through negative binary tables and Refalo\u2019s formulation. Surprisingly, the results are quite similar using tables or not on this set of instances. We do not consider, in a short paper, reproducing known results on optimization problems with ad hoc global constraint formulations [25,22,6] that are also implemented in MICE. Using MICE in this context would lead to the same conclusions. Rather, Table 2 reports results about the CP-style modeling features of MICE to solve the Max-Cut nonlinear (quadratic) optimization problem that occurs in physics applications [16], without any handcrafted model transformation. Given an undirected graph with weighted edges Gw = (V,Ew), Max-Cut is the problem of finding a cut in G of maximum weight. A variable xi is stated for each vertex in V . xi = 1 if vertex vi is in S and xi = \u22121 otherwise. We maximize 12 \u2211 i<j wij(1\u2212xixj). We encoded this problem in Choco 3.3.3 and MICE. In MICE, the default product constraint corresponds to a positive table. In CP, the best strategy we found is DomOverWdeg [10] and first assign vertices.We used Beasley instances from the OR-Libary and problems from g05 60 Rudy instances4, with a 10 min. time-limit. Graphs have respectively 50 nodes and weights in [\u2212100, 100], and 30- 50 nodes unweighted. At last, we evaluated our modeler on the Santa Claus benchmark, recently solved by hybridizing discrete and continuous CP solvers, namely Choco 3.3.3 and Ibex 2.3.1 [11]. We use the model provided in [12], with Alldifferent and Element on integer variables and Deviation with a continuous variable for the mean. Table 3 shows time for proving the optimal solution, with a 10 minutes limit.\nThroughout the development of MICE, we revisited linear formulations of global and table constraints and their reification, non linear constraints built from arithmetic/logical operators, and extensions of Deviation and InterDistance to numerical variables. New integer constraint decompositions exclusively involve new binary variables. An interesting result is that all linear formulations in MICE are simple. We do not claim that any problem can be tackled using a black-box MILP-based CP\n4 See http://biqmac.uni-klu.ac.at/biqmaclib.html\nmodeler (scalability issues may even occur with the best ad hoc MILP models). Our results are good in the context of promoting the CP-style modeling with a simple library, implemented in a popular programming language. Future work includes implementing most recent advances in CP models linearization, e.g., domain refinement [6], and link MICE with model acquisition systems [5,1]."}], "references": [{"title": "Multiple constraint acquisition", "author": ["R. Arcangioli", "C. Bessiere", "N. Lazaar"], "venue": "Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016, New York, NY, USA, 9-15 July 2016. pp. 698\u2013704", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2016}, {"title": "Scheduling and (integer) linear programming", "author": ["C. Artigues"], "venue": "CPAIOR 2012 international master class", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Reformulation of global constraints based on constraints checkers. Constraints", "author": ["N. Beldiceanu", "M. Carlsson", "R. Debruyne", "T. Petit"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Global constraint catalogue: Past, present and future", "author": ["N. Beldiceanu", "M. Carlsson", "S. Demassey", "T. Petit"], "venue": "Constraints 12(1), 21\u201362", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "A model seeker: Extracting global constraint models from positive examples", "author": ["N. Beldiceanu", "H. Simonis"], "venue": "Principles and Practice of Constraint Programming - 18th International Conference, CP 2012, Qu\u00e9bec City, QC, Canada, October 8-12, 2012. Proceedings. pp. 141\u2013 157", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2012}, {"title": "Improved linearization of constraint programming models", "author": ["G. Belov", "P.J. Stuckey", "G. Tack", "M. Wallace"], "venue": "Principles and Practice of Constraint Programming - CP 2016, 22nd International Conference, CP 2016, Toulouse, France, September 5 - 9, 2016, Proceedings. vol. 9392", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning implied global constraints", "author": ["C. Bessiere", "R. Coletta", "T. Petit"], "venue": "IJCAI 2007, Proceedings of the 20th International Joint Conference on Artificial Intelligence, Hyderabad, India, January 6-12, 2007. pp. 44\u201349", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "To be or not to be ... a global constraint. In: Principles and Practice of Constraint Programming - CP", "author": ["C. Bessiere", "P.V. Hentenryck"], "venue": "9th International Conference,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2003}, {"title": "Decompositions of all different, global cardinality and related constraints", "author": ["C. Bessiere", "G. Katsirelos", "N. Narodytska", "C. Quimper", "T. Walsh"], "venue": "IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence, Pasadena, California, USA, July 11-17, 2009. pp. 419\u2013424", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "Boosting systematic search by weighting constraints", "author": ["F. Boussemart", "F. Hemery", "C. Lecoutre", "L. Sais"], "venue": "Proceedings of the 16th Eureopean Conference on Artificial Intelligence, ECAI\u20192004, Valencia, Spain, August 22-27, 2004. pp. 146\u2013150", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2004}, {"title": "Ibex. Mines Nantes, ENPC Paris, ENSTA Brest, Univ", "author": ["G. Chabert", "B. Neveu", "J. Ninin", "L. Jaulin", "G. Trombettoni"], "venue": "http://www.ibex-lib.org", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2016}, {"title": "Combining finite and continuous solvers", "author": ["J. Fages", "G. Chabert", "C. Prud\u2019homme"], "venue": "CoRR abs/1402.1361", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2014}, {"title": "On integrating constraint propagation and linear programming for combinatorial optimization", "author": ["J.N. Hooker", "G. Ottosson", "E.S. Thorsteinsson", "H. Kim"], "venue": "Proceedings of the Sixteenth National Conference on Artificial Intelligence and Eleventh Conference on Innovative Applications of Artificial Intelligence, July 18-22, 1999, Orlando, Florida, USA. pp. 136\u2013141", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1999}, {"title": "Frequency assignment: models and algorithms", "author": ["A. Koster"], "venue": "Ph.D. thesis, Maastricht University", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}, {"title": "Contributions to Determining Exact Ground-States of Ising Spin-Glasses and to their Physics", "author": ["F. Liers"], "venue": "Ph.D. thesis, Universitat zu Koln", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2004}, {"title": "OR-Tools users manual", "author": ["N. van Omme", "L. Perron", "V. Furnon"], "venue": "Tech. rep., Google", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "Optimizing molecular cloning of multiple plasmids", "author": ["T. Petit", "L. Petit"], "venue": "Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016, New York, NY, USA, 9-15 July 2016. pp. 773\u2013779", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2016}, {"title": "Choco3 Documentation. TASC, INRIA Rennes, LINA CNRS UMR 6241", "author": ["C. Prud\u2019homme", "J.G. Fages", "X. Lorca"], "venue": "COSLING S.A.S", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2014}, {"title": "Constraint programming next challenge: Simplicity of use", "author": ["J. Puget"], "venue": "Principles and Practice of Constraint Programming - CP 2004, 10th International Conference, CP 2004, Toronto, Canada, September 27 - October 1, 2004, Proceedings. pp. 5\u20138", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2004}, {"title": "A quadratic propagator for the inter-distance constraint", "author": ["C. Quimper", "A. L\u00f3pez-Ortiz", "G. Pesant"], "venue": "Proceedings, The Twenty-First National Conference on Artificial Intelligence and the Eighteenth Innovative Applications of Artificial Intelligence Conference, July 16-20, 2006, Boston, Massachusetts, USA. pp. 123\u2013128", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2006}, {"title": "Linear formulation of constraint programming models and hybrid solvers", "author": ["P. Refalo"], "venue": "Principles and Practice of Constraint Programming - CP 2000, 6th International Conference, Singapore, September 18-21, 2000, Proceedings. pp. 369\u2013383", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2000}, {"title": "Generalized arc consistency for global cardinality constraint", "author": ["J. R\u00e9gin"], "venue": "Proceedings of the Thirteenth National Conference on Artificial Intelligence and Eighth Innovative Applications of Artificial Intelligence Conference, AAAI 96, IAAI 96, Portland, Oregon, August 4-8, 1996, Volume 1. pp. 209\u2013215", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1996}, {"title": "The global minimum distance constraint", "author": ["J. R\u00e9gin"], "venue": "Tech. rep., ILOG (IBM)", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1997}, {"title": "A new approach to integrating mixed integer programming and constraint logic programming", "author": ["R. Rodosek", "M. Wallace", "M. Hajian"], "venue": "Annals of Operational Research. Recent Advances in Combinatorial Optimization", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1997}, {"title": "The deviation constraint", "author": ["P. Schaus", "Y. Deville", "P. Dupont", "J. R\u00e9gin"], "venue": "Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, 4th International Conference, CPAIOR 2007, Brussels, Belgium, May 23-26, 2007, Proceedings. pp. 260\u2013274", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2007}], "referenceMentions": [{"referenceID": 18, "context": ", IBM CPLEX or Gurobi, can be defined as \u201cmodel and run\u201d systems [20].", "startOffset": 65, "endOffset": 69}, {"referenceID": 1, "context": "They embed dynamic procedures so as to to make simple models solved efficiently [2].", "startOffset": 80, "endOffset": 83}, {"referenceID": 23, "context": "This domain constraint can be encoded by linear constraints, which permitted to linearize many CP global constraints [25,22,6].", "startOffset": 117, "endOffset": 126}, {"referenceID": 20, "context": "This domain constraint can be encoded by linear constraints, which permitted to linearize many CP global constraints [25,22,6].", "startOffset": 117, "endOffset": 126}, {"referenceID": 5, "context": "This domain constraint can be encoded by linear constraints, which permitted to linearize many CP global constraints [25,22,6].", "startOffset": 117, "endOffset": 126}, {"referenceID": 20, "context": "Lemma 1 (Domain linearization (from Refalo\u2019s statement [22])).", "startOffset": 55, "endOffset": 59}, {"referenceID": 16, "context": ", in computational biology [18].", "startOffset": 27, "endOffset": 31}, {"referenceID": 5, "context": "A decomposition of positive table constraints is introduced in [6]: add one binary variable b\u03c4k per tuple \u03c4k, and state that each variable xi should be constrained by xi = \u2211|T | k=1 b\u03c4k .", "startOffset": 63, "endOffset": 66}, {"referenceID": 12, "context": "This formulation is distinct from the existing ones [14,22] and does not add integer variables for indexes.", "startOffset": 52, "endOffset": 59}, {"referenceID": 20, "context": "This formulation is distinct from the existing ones [14,22] and does not add integer variables for indexes.", "startOffset": 52, "endOffset": 59}, {"referenceID": 23, "context": "A concise ad-hoc linearization exists [25,22].", "startOffset": 38, "endOffset": 45}, {"referenceID": 20, "context": "A concise ad-hoc linearization exists [25,22].", "startOffset": 38, "endOffset": 45}, {"referenceID": 8, "context": ", [9]).", "startOffset": 2, "endOffset": 5}, {"referenceID": 7, "context": "In MILP there is no obvious link between the use of global constraints [8] and solving process efficiency, as such constraints must be expressed through linear equations.", "startOffset": 71, "endOffset": 74}, {"referenceID": 3, "context": "Concerning systematic decomposition schemes, the generic automaton based decomposition of the global constraint catalog [4] is well suited to table constraint based linearization, as transition and signature constraints often correspond to positive tables with small scopes.", "startOffset": 120, "endOffset": 123}, {"referenceID": 2, "context": "For instance, using Lemmas 2 and 3, Example 2 of section 3 in [3] provides an exploitable linear decomposition for lexicographical constraints.", "startOffset": 62, "endOffset": 65}, {"referenceID": 21, "context": "The Gcc [23] would likely be implied to any other one, as it refers to occurrences of values in solutions.", "startOffset": 8, "endOffset": 12}, {"referenceID": 6, "context": "The Gcc has some particular properties that make it easy to learn from a model [7].", "startOffset": 79, "endOffset": 82}, {"referenceID": 20, "context": "It differs from the existing one [22] because it is related to a simpler version of the Gcc.", "startOffset": 33, "endOffset": 37}, {"referenceID": 6, "context": "This is an extreme case but, more generally, in practical problems implied Gcc\u2019s can have shrink bounds [7].", "startOffset": 104, "endOffset": 107}, {"referenceID": 13, "context": "ideas of Koster\u2019s partial constraint satisfaction formulation in the context of frequency assignment problems [15].", "startOffset": 110, "endOffset": 114}, {"referenceID": 11, "context": "Next definition (derived from the Santa Claus benchmark [12]) generalizes the Deviation constraint [26], stated to obtain balanced solutions to combinatorial problems, by considering a numerical variable for the mean instead of an (arbitrary) integer value.", "startOffset": 56, "endOffset": 60}, {"referenceID": 24, "context": "Next definition (derived from the Santa Claus benchmark [12]) generalizes the Deviation constraint [26], stated to obtain balanced solutions to combinatorial problems, by considering a numerical variable for the mean instead of an (arbitrary) integer value.", "startOffset": 99, "endOffset": 103}, {"referenceID": 22, "context": "The InterDistance constraint [24,21] holds on integer variables {x1, .", "startOffset": 29, "endOffset": 36}, {"referenceID": 19, "context": "The InterDistance constraint [24,21] holds on integer variables {x1, .", "startOffset": 29, "endOffset": 36}, {"referenceID": 17, "context": "3 [19] and OR-Tools [17] sample directories (see CSPlib 3 for descriptions) that use", "startOffset": 2, "endOffset": 6}, {"referenceID": 15, "context": "3 [19] and OR-Tools [17] sample directories (see CSPlib 3 for descriptions) that use", "startOffset": 20, "endOffset": 24}, {"referenceID": 23, "context": "We do not consider, in a short paper, reproducing known results on optimization problems with ad hoc global constraint formulations [25,22,6] that are also implemented in MICE.", "startOffset": 132, "endOffset": 141}, {"referenceID": 20, "context": "We do not consider, in a short paper, reproducing known results on optimization problems with ad hoc global constraint formulations [25,22,6] that are also implemented in MICE.", "startOffset": 132, "endOffset": 141}, {"referenceID": 5, "context": "We do not consider, in a short paper, reproducing known results on optimization problems with ad hoc global constraint formulations [25,22,6] that are also implemented in MICE.", "startOffset": 132, "endOffset": 141}, {"referenceID": 14, "context": "Rather, Table 2 reports results about the CP-style modeling features of MICE to solve the Max-Cut nonlinear (quadratic) optimization problem that occurs in physics applications [16], without any handcrafted model transformation.", "startOffset": 177, "endOffset": 181}, {"referenceID": 9, "context": "In CP, the best strategy we found is DomOverWdeg [10] and first assign vertices.", "startOffset": 49, "endOffset": 53}, {"referenceID": 10, "context": "1 [11].", "startOffset": 2, "endOffset": 6}, {"referenceID": 11, "context": "We use the model provided in [12], with Alldifferent and Element on integer variables and Deviation with a continuous variable for the mean.", "startOffset": 29, "endOffset": 33}, {"referenceID": 5, "context": ", domain refinement [6], and link MICE with model acquisition systems [5,1].", "startOffset": 20, "endOffset": 23}, {"referenceID": 4, "context": ", domain refinement [6], and link MICE with model acquisition systems [5,1].", "startOffset": 70, "endOffset": 75}, {"referenceID": 0, "context": ", domain refinement [6], and link MICE with model acquisition systems [5,1].", "startOffset": 70, "endOffset": 75}], "year": 2016, "abstractText": "Constraint Programming (CP) users need significant expertise in order to model their problems appropriately, notably to select propagators and search strategies. This puts the brakes on a broader uptake of CP. In this paper, we introduce MICE, a complete Java CP modeler that can use any Mixed Integer Linear Programming (MILP) solver as a solution technique. Our aim is to provide an alternative tool for democratizing the \u201cCP-style\u201d modeling thanks to its simplicity of use, with reasonable solving capabilities. Our contributions include new decompositions of (reified) constraints and constraints on numerical variables.", "creator": "LaTeX with hyperref package"}}}