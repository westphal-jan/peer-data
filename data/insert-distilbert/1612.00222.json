{"id": "1612.00222", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Dec-2016", "title": "Interaction Networks for Learning about Objects, Relations and Physics", "abstract": "reasoning about objects, relations, and physics is central to human intelligence, sciences and a key goal of artificial intelligence. here we introduce the interaction network, a model which can reason about how objects in complex systems interact, supporting dynamical predictions, as well as inferences about the abstract properties of the system. our model takes graphs intended as automatic input, performs object - and inverse relation - centric synthetic reasoning in a way that is analogous to a simulation, implements and is completely implemented using sophisticated deep neural networks. we evaluate its physical ability to reason about several economically challenging physical domains : n - fold body problems, rigid - body collision, symmetric and non - rigid dynamics. our results show it can could be trained to accurately simulate the physical trajectories of dozens of objects over thousands events of time steps, partially estimate abstract quantities \u2013 such as energy, and generalize automatically to systems with different numbers and configurations of objects and relations. our interaction learning network implementation is the first general - purpose, learnable physics engine, and a powerful fully general framework for reasoning about object and relations in a wide variety of entirely complex real - world application domains.", "histories": [["v1", "Thu, 1 Dec 2016 12:34:54 GMT  (1488kb,D)", "http://arxiv.org/abs/1612.00222v1", "Published in NIPS 2016"]], "COMMENTS": "Published in NIPS 2016", "reviews": [], "SUBJECTS": "cs.AI cs.LG", "authors": ["peter w battaglia", "razvan pascanu", "matthew lai", "danilo jimenez rezende", "koray kavukcuoglu"], "accepted": true, "id": "1612.00222"}, "pdf": {"name": "1612.00222.pdf", "metadata": {"source": "CRF", "title": "Interaction Networks for Learning about Objects, Relations and Physics", "authors": ["Peter W. Battaglia", "Razvan Pascanu"], "emails": ["peterbattaglia@google.com", "razp@google.com", "matthewlai@google.com", "danilor@google.com", "korayk@google.com"], "sections": [{"heading": "1 Introduction", "text": "Representing and reasoning about objects, relations and physics is a \u201ccore\u201d domain of human common sense knowledge [26], and among the most basic and important aspects of intelligence [28, 15]. Many everyday problems, such as predicting what will happen next in physical environments or inferring underlying properties of complex scenes, are challenging because their elements can be composed in combinatorially many possible arrangements. People can nevertheless solve such problems by decomposing the scenario into distinct objects and relations, and reasoning about the consequences of their interactions and dynamics. Here we introduce the interaction network \u2013 a model that can perform an analogous form of reasoning about objects and relations in complex systems.\nInteraction networks combine three powerful approaches: structured models, simulation, and deep learning. Structured models [7] can exploit rich, explicit knowledge of relations among objects, independent of the objects themselves, which supports general-purpose reasoning across diverse contexts. Simulation is an effective method for approximating dynamical systems, predicting how the elements in a complex system are influenced by interactions with one another, and by the dynamics of the system. Deep learning [24, 16] couples generic architectures with efficient optimization algorithms to provide highly scalable learning and inference in challenging real-world settings.\nar X\niv :1\n61 2.\n00 22\n2v 1\n[ cs\n.A I]\nInteraction networks explicitly separate how they reason about relations from how they reason about objects, assigning each task to distinct models which are: fundamentally object- and relation-centric; and independent of the observation modality and task specification (see Model section 2 below and Fig. 1a). This lets interaction networks automatically generalize their learning across variable numbers of arbitrarily ordered objects and relations, and also recompose their knowledge of entities and interactions in novel and combinatorially many ways. They take relations as explicit input, allowing them to selectively process different potential interactions for different input data, rather than being forced to consider every possible interaction or those imposed by a fixed architecture.\nWe evaluate interaction networks by testing their ability to make predictions and inferences about various physical systems, including n-body problems, and rigid-body collision, and non-rigid dynamics. Our interaction networks learn to capture the complex interactions that can be used to predict future states and abstract physical properties, such as energy. We show that they can roll out thousands of realistic future state predictions, even when trained only on single-step predictions. We also explore how they generalize to novel systems with different numbers and configurations of elements. Though they are not restricted to physical reasoning, the interaction networks used here represent the first general-purpose learnable physics engine, and even have the potential to learn novel physical systems for which no physics engines currently exist.\nRelated work Our model draws inspiration from previous work that reasons about graphs and relations using neural networks. The \u201cgraph neural network\u201d [23, 19] is a framework that shares learning across nodes and edges, the \u201crecursive autoencoder\u201d [25] adapts its processing architecture to exploit an input parse tree, the \u201cneural programmer-interpreter\u201d [22] is a composable network that mimics the execution trace of a program, and the \u201cspatial transformer\u201d [11] learns to dynamically modify network connectivity to capture certain types of interactions. Others have explored deep learning of logical and arithmetic relations [27], and relations suitable for visual question-answering [1].\nThe behavior of our model is similar in spirit to a physical simulation engine [2], which generates sequences of states by repeatedly applying rules that approximate the effects of physical interactions and dynamics on objects over time. The interaction rules are relation-centric, operating on two or more objects that are interacting, and the dynamics rules are object-centric, operating on individual objects and the aggregated effects of the interactions they participate in. A similar approach has been developed independently by Chang et al. [4].\nPrevious AI work on physical reasoning explored commonsense knowledge, qualitative representations, and simulation techniques for approximating physical prediction and inference [29, 9] . The \u201cNeuroAnimator\u201d [8] was perhaps the first quantitative approach to learning physical dynamics, by training neural networks to predict and control the state of articulated bodies. Ladick\u00fd et al. [14] recently used regression forests to learn fluid dynamics. Recent advances in convolutional neural networks (CNNs) have led to efforts that learn to predict coarse-grained physical dynamics from\nimages [20, 17, 18]. Notably, Fragkiadaki et al. [6] used CNNs to predict and control a moving ball from an image centered at its coordinates. Mottaghi et al. [21] trained CNNs to predict the 3D trajectory of an object after an external impulse is applied. Wu et al. [30] used CNNs to parse objects from images, which were then input to a physics engine that supported prediction and inference."}, {"heading": "2 Model", "text": "Definition To describe our model, we use physical reasoning as an example (Fig. 1a), and build from a simple model to the full interaction network (abbreviated IN). To predict the dynamics of a single object, one might use an object-centric function, fO, which inputs the object\u2019s state, ot, at time t, and outputs a future state, ot+1. If two or more objects are governed by the same dynamics, fO could be applied to each, independently, to predict their respective future states. But if the objects interact with one another, then fO is insufficient because it does not capture their relationship. Assuming two objects and one directed relationship, e.g., a fixed object attached by a spring to a freely moving mass, the first (the sender, o1) influences the second (the receiver, o2) via their interaction. The effect of this interaction, et+1, can be predicted by a relation-centric function, fR. The fR takes as input o1, o2, as well as attributes of their relationship, r, e.g., the spring constant. The fO is modified so it can input both et+1 and the receiver\u2019s current state, o2,t, enabling the interaction to influence its future state, o2,t+1,\net+1 = fR(o1,t, o2,t, r) o2,t+1 = fO(o2,t, et+1)\nThe above formulation can be expanded to larger and more complex systems by representing them as a graph, G = \u3008O,R\u3009, where the nodes, O, correspond to the objects, and the edges, R, to the relations (see Fig. 1b). We assume an attributed, directed multigraph because the relations have attributes, and there can be multiple distinct relations between two objects (e.g., rigid and magnetic interactions). For a system with NO objects and NR relations, the inputs to the IN are,\nO = {oj}j=1...NO , R = {\u3008i, j, rk\u3009k}k=1...NR where i 6= j, 1 \u2264 i, j \u2264 NO , X = {xj}j=1...NO The O represents the states of each object. The triplet, \u3008i, j, rk\u3009k, represents the k-th relation in the system, from sender, oi, to receiver, oj , with relation attribute, rk. The X represents external effects, such as active control inputs or gravitational acceleration, which we define as not being part of the system, and which are applied to each object separately.\nThe basic IN is defined as,\nIN(G) = \u03c6O(a(G, X, \u03c6R( m(G) ) )) (1)\nm(G) = B = {bk}k=1...NR fR(bk) = ek \u03c6R(B) = E = {ek}k=1...NR\na(G,X,E) = C = {cj}j=1...NO fO(cj) = pj \u03c6O(C) = P = {pj}j=1...NO\n(2)\nThe marshalling function, m, rearranges the objects and relations into interaction terms, bk = \u3008oi, oj , rk\u3009 \u2208 B, one per relation, which correspond to each interaction\u2019s receiver, sender, and relation attributes. The relational model, \u03c6R, predicts the effect of each interaction, ek \u2208 E, by applying fR to each bk. The aggregation function, a, collects all effects, ek \u2208 E, that apply to each receiver object, merges them, and combines them with O and X to form a set of object model inputs, cj \u2208 C, one per object. The object model, \u03c6O, predicts how the interactions and dynamics influence the objects by applying fO to each cj , and returning the results, pj \u2208 P . This basic IN can predict the evolution of states in a dynamical system \u2013 for physical simulation, P may equal the future states of the objects, Ot+1.\nThe IN can also be augmented with an additional component to make abstract inferences about the system. The pj \u2208 P , rather than serving as output, can be combined by another aggregation function, g, and input to an abstraction model, \u03c6A, which returns a single output, q, for the whole system. We explore this variant in our final experiments that use the IN to predict potential energy.\nAn IN applies the same fR and fO to every bk and cj , respectively, which makes their relational and object reasoning able to handle variable numbers of arbitrarily ordered objects and relations. But one additional constraint must be satisfied to maintain this: the a function must be commutative and\nassociative over the objects and relations. Using summation within a to merge the elements of E into C satisfies this, but division would not.\nHere we focus on binary relations, which means there is one interaction term per relation, but another option is to have the interactions correspond to n-th order relations by combining n senders in each bk. The interactions could even have variable order, where each bk includes all sender objects that interact with a receiver, but would require a fR than can handle variable-length inputs. These possibilities are beyond the scope of this work, but are interesting future directions.\nImplementation The general definition of the IN in the previous section is agnostic to the choice of functions and algorithms, but we now outline a learnable implementation capable of reasoning about complex systems with nonlinear relations and dynamics. We use standard deep neural network building blocks, multilayer perceptrons (MLP), matrix operations, etc., which can be trained efficiently from data using gradient-based optimization, such as stochastic gradient descent.\nWe defineO as aDS\u00d7NO matrix, whose columns correspond to the objects\u2019DS-length state vectors. The relations are a triplet, R = \u3008Rr, Rs, Ra\u3009, where Rr and Rs are NO \u00d7NR binary matrices which index the receiver and sender objects, respectively, and Ra is a DR \u00d7NR matrix whose DR-length columns represent the NR relations\u2019 attributes. The j-th column of Rr is a one-hot vector which indicates the receiver object\u2019s index; Rs indicates the sender similarly. For the graph in Fig. 1b, Rr = [ 0 0 1 1 0 0 ] and Rs = [ 1 0 0 0 0 1 ] . The X is a DX \u00d7NO matrix, whose columns are DX -length vectors that represent the external effect applied each of the NO objects.\nThe marshalling function, m, computes the matrix products, ORr and ORs, and concatenates them with Ra: m(G) = [ORr;ORs;Ra] = B . The resulting B is a (2DS +DR)\u00d7NR matrix, whose columns represent the interaction terms, bk, for the NR relations (we denote vertical and horizontal matrix concatenation with a semicolon and comma, respectively). The way m constructs interaction terms can be modified, as described in our Experiments section (3).\nThe B is input to \u03c6R, which applies fR, an MLP, to each column. The output of fR is a DE-length vector, ek, a distributed representation of the effects. The \u03c6R concatenates the NR effects to form the DE \u00d7NR effect matrix, E. The G, X , and E are input to a, which computes the DE \u00d7NO matrix product, E\u0304 = ERTr , whose j-th column is equivalent to the elementwise sum across all ek whose corresponding relation has receiver object, j. The E\u0304 is concatenated with O and X: a(G,X,E) = [O;X; E\u0304] = C. The resulting C is a (DS +DX +DE)\u00d7NO matrix, whose NO columns represent the object states, external effects, and per-object aggregate interaction effects.\nThe C is input to \u03c6O, which applies fO, another MLP, to each of the NO columns. The output of fO is a DP -length vector, pj , and \u03c6O concatenates them to form the output matrix, P .\nTo infer abstract properties of a system, an additional \u03c6A is appended and takes P as input. The g aggregation function performs an elementwise sum across the columns of P to return a DP -length vector, P\u0304 . The P\u0304 is input to \u03c6A, another MLP, which returns a DA-length vector, q, that represents an abstract, global property of the system.\nTraining an IN requires optimizing an objective function over the learnable parameters of \u03c6R and \u03c6O. Note, m and a involve matrix operations that do not contain learnable parameters.\nBecause \u03c6R and \u03c6O are shared across all relations and objects, respectively, training them is statistically efficient. This is similar to CNNs, which are very efficient due to their weight-sharing scheme. A CNN treats a local neighborhood of pixels as related, interacting entities: each pixel is effectively a receiver object and its neighboring pixels are senders. The convolution operator is analogous to \u03c6R, where fR is the local linear/nonlinear kernel applied to each neighborhood. Skip connections, recently popularized by residual networks, are loosely analogous to how the IN inputs O to both \u03c6R and \u03c6O, though in CNNs relation- and object-centric reasoning are not delineated. But because CNNs exploit local interactions in a fixed way which is well-suited to the specific topology of images, capturing longer-range dependencies requires either broad, insensitive convolution kernels, or deep stacks of layers, in order to implement sufficiently large receptive fields. The IN avoids this restriction by being able to process arbitrary neighborhoods that are explicitly specified by the R input."}, {"heading": "3 Experiments", "text": "Physical reasoning tasks Our experiments explored two types of physical reasoning tasks: predicting future states of a system, and estimating their abstract properties, specifically potential energy. We evaluated the IN\u2019s ability to learn to make these judgments in three complex physical domains: n-body systems; balls bouncing in a box; and strings composed of springs that collide with rigid objects. We simulated the 2D trajectories of the elements of these systems with a physics engine, and recorded their sequences of states. See the Supplementary Material for full details.\nIn the n-body domain, such as solar systems, all n bodies exert distance- and mass-dependent gravitational forces on each other, so there were n(n \u2212 1) relations input to our model. Across simulations, the objects\u2019 masses varied, while all other fixed attributes were held constant. The training scenes always included 6 bodies, and for testing we used 3, 6, and 12 bodies. In half of the systems, bodies were initialized with velocities that would cause stable orbits, if not for the interactions with other objects; the other half had random velocities.\nIn the bouncing balls domain, moving balls could collide with each other and with static walls. The walls were represented as objects whose shape attribute represented a rectangle, and whose inverse-mass was 0. The relations input to the model were between the n objects (which included the walls), for (n(n\u2212 1) relations). Collisions are more difficult to simulate than gravitational forces, and the data distribution was much more challenging: each ball participated in a collision on less than 1% of the steps, following straight-line motion at all other times. The model thus had to learn that despite there being a rigid relation between two objects, they only had meaningful collision interactions when they were in contact. We also varied more of the object attributes \u2013 shape, scale and mass (as before) \u2013 as well as the coefficient of restitution, which was a relation attribute. Training scenes contained 6 balls inside a box with 4 variably sized walls, and test scenes contained either 3, 6, or 9 balls.\nThe string domain used two types of relations (indicated in rk), relation structures that were more sparse and specific than all-to-all, as well as variable external effects. Each scene contained a string, comprised of masses connected by springs, and a static, rigid circle positioned below the string. The n masses had spring relations with their immediate neighbors (2(n\u2212 1)), and all masses had rigid relations with the rigid object (2n). Gravitational acceleration, with a magnitude that was varied across simulation runs, was applied so that the string always fell, usually colliding with the static object. The gravitational acceleration was an external input (not to be confused with the gravitational attraction relations in the n-body experiments). Each training scene contained a string with 15 point masses, and test scenes contained either 5, 15, or 30 mass strings. In training, one of the point masses at the end of the string, chosen at random, was always held static, as if pinned to the wall, while the other masses were free to move. In the test conditions, we also included strings that had both ends pinned, and no ends pinned, to evaluate generalization.\nOur model takes as input the state of each system, G, decomposed into the objects, O (e.g., n-body objects, balls, walls, points masses that represented string elements), and their physical relations, R (e.g., gravitational attraction, collisions, springs), as well as the external effects, X (e.g., gravitational acceleration). Each object state, oj , could be further divided into a dynamic state component (e.g., position and velocity) and a static attribute component (e.g., mass, size, shape). The relation attributes, Ra, represented quantities such as the coefficient of restitution, and spring constant. The input represented the system at the current time. The prediction experiment\u2019s target outputs were the velocities of the objects on the subsequent time step, and the energy estimation experiment\u2019s targets were the potential energies of the system on the current time step. We also generated multi-step rollouts for the prediction experiments (Fig. 2), to assess the model\u2019s effectiveness at creating visually realistic simulations. The output velocity, vt, on time step t became the input velocity on t+ 1, and the position at t+ 1 was updated by the predicted velocity at t.\nData Each of the training, validation, test data sets were generated by simulating 2000 scenes over 1000 time steps, and randomly sampling 1 million, 200k, and 200k one-step input/target pairs, respectively. The model was trained for 2000 epochs, randomly shuffling the data indices between each. We used mini-batches of 100, and balanced their data distributions so the targets had similar per-element statistics. The performance reported in the Results was measured on held-out test data.\nWe explored adding a small amount of Gaussian noise to 20% of the data\u2019s input positions and velocities during the initial phase of training, which was reduced to 0% from epochs 50 to 250. The\nnoise std. dev. was 0.05\u00d7 the std. dev. of each element\u2019s values across the dataset. It allowed the model to experience physically impossible states which could not have been generated by the physics engine, and learn to project them back to nearby, possible states. Our error measure did not reflect clear differences with or without noise, but rollouts from models trained with noise were slightly more visually realistic, and static objects were less subject to drift over many steps.\nModel architecture The fR and fO MLPs contained multiple hidden layers of linear transforms plus biases, followed by rectified linear units (ReLUs), and an output layer that was a linear transform plus bias. The best model architecture was selected by a grid search over layer sizes and depths. All inputs (except Rr and Rs) were normalized by centering at the median and rescaling the 5th and 95th percentiles to -1 and 1. All training objectives and test measures used mean squared error (MSE) between the model\u2019s prediction and the ground truth target.\nAll prediction experiments used the same architecture, with parameters selected by a hyperparameter search. The fR MLP had four, 150-length hidden layers, and output length DE = 50. The fO MLP had one, 100-length hidden layer, and output length DP = 2, which targeted the x, y-velocity. The m and a were customized so that the model was invariant to the absolute positions of objects in the scene. The m concatenated three terms for each bk: the difference vector between the dynamic states of the receiver and sender, the concatenated receiver and sender attribute vectors, and the relation attribute vector. The a only outputs the velocities, not the positions, for input to \u03c6O.\nThe energy estimation experiments used the IN from the prediction experiments with an additional \u03c6A MLP which had one, 25-length hidden layer. Its P inputs\u2019 columns were length DP = 10, and its output length was DA = 1.\nWe optimized the parameters using Adam [13], with a waterfall schedule that began with a learning rate of 0.001 and down-scaled the learning rate by 0.8 each time the validation error, estimated over a window of 40 epochs, stopped decreasing.\nTwo forms of L2 regularization were explored: one applied to the effects, E, and another to the model parameters. Regularizing E improved generalization to different numbers of objects and reduced drift over many rollout steps. It likely incentivizes sparser communication between the \u03c6R and \u03c6O, prompting them to operate more independently. Regularizing the parameters generally improved performance and reduced overfitting. Both penalty factors were selected by a grid search.\nFew competing models are available in the literature to compare our model against, but we considered several alternatives: a constant velocity baseline which output the input velocity; an MLP baseline, with two 300-length hidden layers, which took as input a flattened vector of all of the input data; and a variant of the IN with the \u03c6R component removed (the interaction effects, E, was set to a 0-matrix)."}, {"heading": "4 Results", "text": "Prediction experiments Our results show that the IN can predict the next-step dynamics of our task domains very accurately after training, with orders of magnitude lower test error than the alternative models (Fig. 3a, d and g, and Table 2). Because the dynamics of each domain depended crucially on interactions among objects, the IN was able to learn to exploit these relationships for its predictions. The dynamics-only IN had no mechanism for processing interactions, and performed similarly to the constant velocity model. The baseline MLP\u2019s connectivity makes it possible, in principle, for it to learn the interactions, but that would require learning how to use the relation indices to selectively process the interactions. It would also not benefit from sharing its learning across relations and objects, instead being forced to approximate the interactive dynamics in parallel for each objects.\nThe IN also generalized well to systems with fewer and greater numbers of objects (Figs. 3b-c, e-f and h-k, and Table SM1 in Supp. Mat.). For each domain, we selected the best IN model from the system size on which it was trained, and evaluated its MSE on a different system size. When tested on smaller n-body and spring systems from those on which it was trained, its performance actually exceeded a model trained on the smaller system. This may be due to the model\u2019s ability to exploit its greater experience with how objects and relations behave, available in the more complex system.\nWe also found that the IN trained on single-step predictions can be used to simulate trajectories over thousands of steps very effectively, often tracking the ground truth closely, especially in the n-body and string domains. When rendered into images and videos, the model-generated trajectories are\nusually visually indistinguishable from those of the ground truth physics engine (Fig. 2; see Table 1 for URLs to the full videos of each rollout). This is not to say that given the same initial conditions, they cohere perfectly: the dynamics are highly nonlinear and imperceptible prediction errors by the model can rapidly lead to large differences in the systems\u2019 states. But the incoherent rollouts do not violate people\u2019s expectations, and might be roughly on par with people\u2019s understanding of these domains.\nEstimating abstract properties We trained an abstract-estimation variant of our model to predict potential energies in the n-body and string domains (the ball domain\u2019s potential energies were always 0), and found it was much more accurate (n-body MSE 1.4, string MSE 1.1) than the MLP baseline (n-body MSE 19, string MSE 425). The IN presumably learns the gravitational and spring potential energy functions, applies them to the relations in their respective domains, and combines the results."}, {"heading": "5 Discussion", "text": "We introduced interaction networks as a flexible and efficient model for explicit reasoning about objects and relations in complex systems. Our results provide surprisingly strong evidence of their ability to learn accurate physical simulations and generalize their training to novel systems with different numbers and configurations of objects and relations. They could also learn to infer abstract properties of physical systems, such as potential energy. The alternative models we tested performed much more poorly, with orders of magnitude greater error. Simulation over rich mental models is thought to be a crucial mechanism of how humans reason about physics and other complex domains [5, 12, 10], and Battaglia et al. [3] recently posited a simulation-based \u201cintuitive physics engine\u201d model to explain human physical scene understanding. Our interaction network implementation is the first learnable physics engine that can scale up to real-world problems, and is a promising template for new AI approaches to reasoning about other physical and mechanical systems, scene understanding, social perception, hierarchical planning, and analogical reasoning.\nIn the future, it will be important to develop techniques that allow interaction networks to handle very large systems with many interactions, such as by culling interaction computations that will have\nnegligible effects. The interaction network may also serve as a powerful model for model-predictive control inputting active control signals as external effects \u2013 because it is differentiable, it naturally supports gradient-based planning. It will also be important to prepend a perceptual front-end that can infer from objects and relations raw observations, which can then be provided as input to an interaction network that can reason about the underlying structure of a scene. By adapting the interaction network into a recurrent neural network, even more accurate long-term predictions might be possible, though preliminary tests found little benefit beyond its already-strong performance. By modifying the interaction network to be a probabilistic generative model, it may also support probabilistic inference over unknown object properties and relations.\nBy combining three powerful tools from the modern machine learning toolkit \u2013 relational reasoning over structured knowledge, simulation, and deep learning \u2013 interaction networks offer flexible, accurate, and efficient learning and inference in challenging domains. Decomposing complex systems into objects and relations, and reasoning about them explicitly, provides for combinatorial generalization to novel contexts, one of the most important future challenges for AI, and a crucial step toward closing the gap between how humans and machines think."}, {"heading": "A Supplementary material", "text": ""}, {"heading": "A.1 Experimental details", "text": "A.1.1 Physics engine details\nEvery simulated trajectory contained the states of the objects in the system on each frame of a sequence of 1000 one-millisecond time steps. The parameters of each system were chosen so that a diverse set of dynamics could unfold within the trajectory. On each step, the physics engine took as input the current state of the system, calculated the forces associated with each inter-entity interaction, and applied them to the individual entities as accelerations by dividing by the entity\u2019s mass, parameterized as inverse-mass, a = Fm\u22121 in both the engine and model input. This also allows static objects to be represented as having m\u22121 = 0. The previous positions and velocities, and newly computed accelerations, were input to an Euler integrator to update the current velocities and positions of the entities. By using a custom engine we were able to have perfect control over the details of the simulation, and use one engine for all physical domains. It produced trajectory rollouts that were indistinguishable from those of an off-the-shelf simulation engine, but was highly efficient because it could perform thousands of runs in parallel on a GPU, allowing millions of simulated steps to be generated each second."}, {"heading": "A.1.2 Physical domains", "text": "n-body All objects in n-body systems exerted gravitational forces on each other, which were a function of the objects\u2019 pairwise distances and masses, giving rise to very complex dynamics that are highly sensitive to initial conditions. Across simulation runs, the objects\u2019 masses varied, while all other non-dynamic variables were held constant. The gravitational constant was set to ensure that objects could move across several hundred meters within the 1000 step rollout. The training scenes always included 6 objects, and for testing we used 3, 6, and 12 objects. The masses were uniformly sampled from [0.02, 9] kg, their shapes were points, and their initial positions were randomly sampled from all angles, with a distance in [10, 100] m. We included two classes of scenes. The first, orbit systems, had one object (the star), initialized at position (0, 0), with zero velocity and a mass of 100 kg. The planets\u2019 velocities were initialized such that they would have stable orbits around the star, if not for their interactions with other planets. The second, non-orbit systems, sampled initial x- and y-velocity components from [\u22123, 3] m/s. The objects would typically begin attracting, and gave rise to complex semi-periodic behavior.\nAn n-body system is a highly nonlinear (chaotic) dynamical system, which means they are highly sensitive to initial conditions and extended predictions of their states are not possible under even small perturbations. The relations between the objects corresponded to gravitational attraction. Between simulation runs, the masses of the objects were varied, while all other non-dynamic variables were held constant (e.g., gravitational constant) or were not meaningful (e.g., object scales and shapes). The gravitational force from object i to j was computed as, Fij =\nGmimj(xi\u2212xj) \u2016xi\u2212xj\u20163\n, where G is the gravitational constant. The denominator was clipped so that forces could not go too high as the distances between objects went to zero. All forces applied to each object were summed to yield the per-object total forces.\nBouncing balls The bouncing balls domain still had all-to-all object relations\u2013collisions\u2013and any object could collide with any other, including the walls. But colliding objects are more difficult to simulate than the gravitational interactions in n-body systems, and our bouncing balls domain also included more variability in object attributes, such as shape, scale, and mass (as before), as well as relation attributes, such as the coefficient of restitution. The data distribution was much more challenging: for more than 99% of the time steps, a ball was not in contact with any others, and its next-step velocity equaled its current velocity. For the remaining steps, however, collisions caused next-step velocities that was a complex function of its state and the state of the object it collides with. The training scene contained 6 balls inside a box with 4 walls, and test scenes contained either 3, 6, or 9 balls. The balls\u2019 radii were sampled uniformly from [0.1, 0.3] m, and masses from [0.75, 1.25] kg. The walls were static rectangular boxes, positioned so that the horizontal and vertical lengths of area they enclosed varied independently between [1, 3] m. The balls\u2019 initial positions were randomly sampled so that all balls fit within the box and did not interpenetrate any other object, with initial x- and y-velocity components sampled uniformly from [\u22125, 5] m/s. The restitutions, an attribute of their collision relations, was sampled uniformly from [0.4, 1].\nRigid body collision systems are highly nonlinear (chaotic) dynamical systems, as well. Collision forces were applied between objects when they began to interpenetrate, using two-step process: collision detection between all objects, and resolution of detected collisions. A detected collision between two objects meant that their shapes overlapped and their velocities were causing them to approach each other. To resolve a partially inelastic collision, the post-collision velocities of each object were computed, and forces appropriate to effect these velocities on the subsequent time step were then calculated and applied the the objects. This resulted in realistic bouncing ball trajectories.\nString Our string domain used multiple types of relations (springs and collisions), relation structures that were more sparse and specific than all-to-all, and variable external effects. Each scene contained one string, comprised of point masses connected by springs, and one static, rigid circle positioned below the string. Gravitational acceleration, varied across simulation runs, was applied so that the string always fell, usually colliding with the static object. Each training scene contained a string with 15 point masses, and test scenes contained either 5, 15, or 30 mass strings. In training, one of the point masses at the end of the string, chosen at random, was always held static, as if pinned to the wall, while the other masses were free to move. In the test conditions, we also included strings that had both ends pinned, and no ends pinned, to evaluate generalization. The string\u2019s masses were sampled from [0.05, 0.15] kg. The springs\u2019 rest lengths were set to 0.2 m, spring constants to 100, and damping factors to 0.001. The static object\u2019s x-position was sampled from [\u22120.5, 0.5] m, y-position was sampled from [\u22121,\u22120.5] m, and radius from [0.2, 0.4] m. The string mass-rigid object coefficient of restitution was sampled from [0, 1]. The gravitational acceleration applied to all non-static objects was sampled from [\u221230,\u22125] m/s2.\nThe spring force from object i to j was computed using Hooke\u2019s law as, F = Cs(1 \u2212 L\u2016xi\u2212xj\u2016 )(xi \u2212 xj), where Cs is the spring constant and L is the spring\u2019s rest length. A damping factor, which was proportional to the difference in the objects\u2019 velocities, was also applied. Collision forces between the string\u2019s masses and the static, rigid object were calculated as described in the bouncing balls section above."}, {"heading": "A.2 Results details", "text": "The prediction experiment\u2019s generalization performance MSEs are shown Table 3. The URL links for the videos associated with all still frames in Figure 2 are in Table 1."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "Reasoning about objects, relations, and physics is central to human intelligence, and<lb>a key goal of artificial intelligence. Here we introduce the interaction network, a<lb>model which can reason about how objects in complex systems interact, supporting<lb>dynamical predictions, as well as inferences about the abstract properties of the<lb>system. Our model takes graphs as input, performs objectand relation-centric<lb>reasoning in a way that is analogous to a simulation, and is implemented using<lb>deep neural networks. We evaluate its ability to reason about several challenging<lb>physical domains: n-body problems, rigid-body collision, and non-rigid dynamics.<lb>Our results show it can be trained to accurately simulate the physical trajectories of<lb>dozens of objects over thousands of time steps, estimate abstract quantities such<lb>as energy, and generalize automatically to systems with different numbers and<lb>configurations of objects and relations. Our interaction network implementation<lb>is the first general-purpose, learnable physics engine, and a powerful general<lb>framework for reasoning about object and relations in a wide variety of complex<lb>real-world domains.", "creator": "LaTeX with hyperref package"}}}