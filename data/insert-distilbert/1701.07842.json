{"id": "1701.07842", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Jan-2017", "title": "Learning Asynchronous Typestates for Android Classes", "abstract": "written in event - driven programming frameworks, such as android, the client and extension the framework interact significantly using callins ( framework methods that the relevant client invokes ) and callbacks ( client methods that utilize the framework invokes ). the protocols metaphor for interacting with these frameworks can often be simultaneously described by finite - state machines why we dub * asynchronous typestates *. asynchronous semantic typestates are akin analogy to more classical typestates, with the key difference that their outputs ( callbacks ) are produced asynchronously.", "histories": [["v1", "Thu, 26 Jan 2017 19:06:45 GMT  (81kb,D)", "http://arxiv.org/abs/1701.07842v1", "Submitted to CAV 2017"]], "COMMENTS": "Submitted to CAV 2017", "reviews": [], "SUBJECTS": "cs.LO cs.LG cs.PL", "authors": ["arjun radhakrishna", "nicholas lewchenko", "shawn meier", "sergio mover", "krishna chaitanya sripada", "damien zufferey", "bor-yuh evan chang", "pavol \\v{c}ern\\'y"], "accepted": false, "id": "1701.07842"}, "pdf": {"name": "1701.07842.pdf", "metadata": {"source": "CRF", "title": "Learning Asynchronous Typestates for Android Classes", "authors": ["Arjun Radhakrishna", "Nicholas Lewchenko", "Shawn Meier", "Sergio Mover", "Krishna Chaitanya Sripada", "Damien Zufferey", "Bor-Yuh Evan Chang", "Pavol \u010cern\u00fd"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Event-driven programming frameworks interact with client code using callins and callbacks. Callins are framework methods that the client invokes and callbacks are client methods that the framework invokes. The client-framework interaction is often governed by a protocol that can be described by a finite-state machine.\nFor example, consider a typical interaction between a client application and the framework when the client wants to use a particular service. The client asks for the service to be started by invoking a startService() callin. After the framework receives the callin, it asynchronously starts initializing the\nar X\niv :1\n70 1.\n07 84\n2v 1\n[ cs\n.L O\n] 2\n6 Ja\nservice. When the service is started and ready to be used, the framework notifies the client by invoking a onServiceStarted() callback. The client can then use the service. After the client finishes using the service, it invokes a shutdownService() callin to ask the framework to stop the service.\nThe protocol for the interaction in the example can be described by a finitestate machine we call asynchronous typestate. Typestates [32] were introduced to describe synchronous interfaces that specify order of method calls. As they are synchronous, typestates involve only callins (which can return output values). In contrast, asynchronous typestates have both inputs (corresponding to callins) and outputs (corresponding to callbacks). In automata theory, asynchronous typestates can be seen as interface automata. Interface automata [12] are a wellstudied model of automata that can receive outputs asynchronously w.r.t. inputs. We choose to use the name asynchronous typestates to emphasize that they are a generalization of typestates as used in the programming languages literature. Problem. We consider the problem of inferring asynchronous typestates from framework code, in particular in the Android framework. Asynchronous typestates are useful in a number of ways. First, asynchronous typestates are a form of documentation. They tell client application programmers in what order to invoke callins and which callback to expect. Some Android framework documentation already uses pictures very similar to asynchronous typestates (Figure 1). Second, asynchronous typestates are also useful in verification of client code. They enable checking that a client uses the framework correctly. Third, even though we infer the asynchronous typestates from framework code, they can be used for certain forms of framework verification. For instance, one can infer typestates for different versions of the framework, and check if the interface has changed. Method. We present a method for inferring typestates for Android classes. However, our method is equally applicable in other contexts. The core algorithm is based on Angluin\u2019s L\u2217 algorithm [5] adapted to Mealy machines [28]. a learner tries to learn a finite-state machine \u2014 in our case an asynchronous typestate \u2014 by asking a teacher membership and equivalence queries. We note that the teacher does not need to know the solution, but only how to answer the queries. Membership and equivalence oracles. The key question we answer is how to implement oracles for the membership and equivalence queries. The membership query asks whether a given sequence of callins is legal, i.e., it does not raise an exception when invoked on the class C, and, if so, what sequence of callbacks C generates in response. We implement the membership oracle by testing. The equivalence query asks whether the current hypothesis H is a typestate for C. If not, the teacher provides a counterexample: a sequence of callins and callbacks allowed by H which does not arise when a client interacts with C, or vice versa. Answering the equivalence query requires checking language inclusion for two programs (C and H). This is an undecidable problem in general.\nHowever, under realistic assumptions, the equivalence oracle can be implemented on top of the membership oracle. This follows from an automatatheoretic result on the length of the longest minimal counterexample for equivalence of two automata. The equivalence oracle uses the following boundedness\nassumption: if C has an asynchronous typestate, then its number of states is less than a constant k. Unfortunately, the equivalence check implemented in this way (as is done in previous algorithms [10,14] for conformance testing) is exponential in k. Therefore, we introduce the notion of a distinguisher bound. A distinguisher bound limits the size of a witness word that differentiates two states. Intuitively, a distinguisher bound quantifies how states are locally different. The distinguisher bound is always smaller than the state bound; for Android classes, we found empirically that the distinguisher bound is significantly smaller than the state bound. The largest asynchronous typestates of an Android class we found have at most 10 states and a distinguisher bound of 2. Implementing membership oracle on Android. We implement the membership oracle using testing. Concretely, we run the sequence of callins, and log exceptions, errors, and callbacks that occur. Since testing might not expose all the framework\u2019s behaviors, the oracle can return incorrect results. We explain in detail the assumptions under which we learn the correct typestate in Section 3.2 and how our implementation deals with them in Section 5. Empirical evaluation. We implemented our approach in a tool called Starling. We use Starling to synthesize asynchronous typestates for Android framework classes. The results show that Starling learns asynchronous typestates accurately and efficiently. This is confirmed by documentation, code inspection, and manual comparison to simple Android applications. The small bound hypothesis is also confirmed. Furthermore, by inspecting our typestates, we uncovered corner cases with surprising behavior that are undocumented and might even be considered as bugs. Section 6 presents our results in more detail. Contributions. The contributions of this paper are: (a) We introduce the notion of asynchronous typestates and develop an approach, based on the L\u2217 algorithm, to infer them. (b) We show how to implement efficiently membership and equivalence oracles required by the L\u2217 algorithm. (c) We evaluate our approach on examples from the Android framework, and show its accuracy and effectiveness."}, {"heading": "2 Illustrative Example", "text": "Let us consider the asynchronous typestate in Figure 1, taken from the documentation for the Android class called MediaPlayer. Callins are represented by single arrows and callbacks by double arrows. Let us look at one part of the protocol that governs the client-framework interaction. The client first invokes the callin setDataSource(), and the protocol transitions to the Initialized state. In this state, the client can invoke the callin prepareAsync(), and the protocol transitions to the Preparing state. In the Preparing state, the client cannot invoke any callins, but the framework can invoke the onPrepared() callback, and then the protocol transitions to the Prepared state. Only at this point, the client can invoke the start() callin, and the media starts playing.\nOur approach follows the structure of the L\u2217 algorithm. A learner asks membership queries, until she can form a hypothesis automaton and ask an equivalence query. If a counterexample is returned, the algorithm learns from it. This process repeats until the hypothesis is correct. For the MediaPlayer, the first set\nof membership queries each invoke a different callin. Of these, only the query containing setDataSource() succeeds. The testing-based membership oracle raises an exception on all the other callins. The learner continues with longer membership queries while building the hypothesis automaton. For instance, it learns that prepareAsync() and prepare() cannot lead to the same state: it is possible to invoke the start() after prepare(), but not after prepareAsync(). Once the client receives the callback onPrepared(), start() may be called. The learner thus hypothesizes a transition from the Preparing to the Prepared on onPrepared(). Once the hypothesis is complete, the learner asks the equivalence query. In this example, the solution is found after 5 equivalence queries.\nandroid/media/MediaPlayer.html\ntions. Therefore, two states are easy to distinguish. In Section 4.3, we explain how we use the distinguisher bound to implement equivalence queries and discuss why distinguisher bounds are small in practice."}, {"heading": "3 The Asynchronous Typestate Learning Problem", "text": "We introduce models of interfaces, define the asynchronous typestate learning problem, and present an impossibility result about learning typestates."}, {"heading": "3.1 Definitions and Problem Statement", "text": "Asynchronous interfaces. Let \u03a3i and \u03a3o be the set of callins and callbacks of an asynchronous interface. We abstract away parameter and return values of callins and callbacks, and model a behavior of the interface as a trace \u03c4i =\n\u03c30 . . . \u03c3n \u2208 (\u03a3i \u222a \u03a3o)\u2217. The interface I is given by \u3008\u03a3i, \u03a3o, \u03a0i\u3009 where \u03a0i \u2286 {\u03a3i \u222a\u03a3o}\u2217 is the prefix-closed set of all feasible traces of the interface. Interface automata. We use interface automata [12] to represent asynchronous interfaces. An interface automaton A is given by \u3008Q, q\u03b9, \u03a3i, \u03a3o, \u2206A\u3009 where: (a) Q is a finite set of states, (b) q\u03b9 \u2208 Q is the initial state, (c)\u03a3i and\u03a3o are finite sets of input and output symbols, and (d) \u2206A \u2286 Q\u00d7{\u03a3i\u222a\u03a3o}\u00d7Q are a set of transitions. A trace \u03c4a of A is given by \u03c30 . . . \u03c3n if \u2203q0 . . . qn+1 : q0 = q\u03b9\u2227\u2200i.(qi, \u03c3i, qi+1) \u2208 \u2206A. We denote by Traces(A) the set of all traces of A. Problem statement. Given an interface I = \u3008\u03a3i, \u03a3o, \u03a0i\u3009, the asynchronous typestate learning problem is to learn an interface automaton A such that \u03a0i = Traces(A). We allow the learner to ask a membership oracle MOracle[I] membership queries. For a membership query, the learner picks mQuery = i0i1 . . . in \u2208 \u03a3\u2217i and the membership oracle MOracle[I] returns either: (a) a trace \u03c4a \u2208 \u03a0i whose sequence of callins is exactly mQuery, or (b) \u22a5 if no such trace exists."}, {"heading": "3.2 The Theory and Practice of Learning Typestates", "text": "In general, it is impossible to learn asynchronous typestates using only membership queries; no finite set of membership queries fixes a unique interface automaton (see Appendix B for a formal statement). However, asynchronous typestates can be effectively learned given extra assumptions. Below, we analyze the causes behind the impossibility and highlight the assumption necessary to overcome it. Unbounded asynchrony. Membership queries alone do not tell us if the interface will emit more outputs (callbacks) at any point in time. Hence, we assume: Assumption 1: Quiescence is observable. This assumption is commonly used in ioco-testing frameworks [33]. In our setting, we add an input wait and an output quiet, where quiet is returned after a wait only if there are no other pending callbacks. In practice, quiet can be implemented using timeouts, i.e., pending callbacks are assumed to arrive within a fixed amount of time. If no callbacks are seen within the timeout, quiet is output.\nExample 1. Using wait and quiet, in the MediaPlayer example, we have that setDataSource() \u00b7 prepareAsync() \u00b7 onPrepared() \u00b7 wait \u00b7 quiet is a valid trace, but setDataSource() \u00b7 prepareAsync() \u00b7 wait \u00b7 quiet is not.\nBehavior unboundedness. For any set of membership queries, let k be the length of the longest query. It is not possible to find out if the interface exhibits significantly different behavior for input sequences much longer than k. While this is a theoretical limitation, it is not a problem in practice as most asynchronous typestates are rather small (\u2264 10 states).\nAssumption 2: An upper bound on the size of the typestate being learned is known.\nNon-determinism. We need to be able to observe the systems\u2019 behaviors to learn them and non-determinism can prevent that. Therefore, we assume: Assumption 3: The interface is deterministic. We assume that for every trace \u03c4a of the interface, there is at most one output o \u2208\n\u03a3o such that \u03c4a \u00b7 o \u2208 \u03a0i. In practice, the non-determinism problem is somewhat alleviated due to the nature of asynchronous typestates (see Section 5). See [1] for a detailed theoretical discussion of how non-determinism affects learnability.\nExample 2. Consider an interface with traces given by (input \u00b7 (out1 | out2))\u2217. All membership queries are a sequence of input\u2019s; however, it is possible that the membership oracle never returns any trace containing out2. In that case, no learner will be able to learn the interface exactly."}, {"heading": "4 Learning Asynchronous Typestates using L\u2217", "text": "Given Assumption 1 and Assumption 3, we first build a \u201csynchronous closure\u201d of an asynchronous interface (Section 4.1). Then, we show how to learn the synchronous closure effectively given Assumption 2 (Section 4.2 and 4.3)."}, {"heading": "4.1 From Asynchronous to Synchronous Interfaces", "text": "Using Assumption 1 and 3, we build a synchronous version of an interface in which inputs and outputs strictly alternate following [1]. For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].\nDefine \u03a3\u0303i = \u03a3i \u222a {wait} and \u03a3\u0303o = \u03a3o \u222a {quiet, , err}. The purpose of the additional inputs and outputs is discussed below. For any \u03c4s \u2208 (\u03a3\u0303i \u00b7 \u03a3\u0303o)\u2217, we define async(\u03c4s) = \u03c4a \u2208 (\u03a3i \u222a \u03a3o)\u2217 where \u03c4a is obtained from \u03c4s by erasing all occurrences of wait, quiet, , and err. Synchronous closures. The synchronous closure Is of an asynchronous interface I = \u3008\u03a3i, \u03a3o, \u03a0i\u3009 is given by \u3008\u03a3\u0303i, \u03a3\u0303o, \u03a0s\u3009 where \u03a3\u0303i and \u03a3\u0303o are as above, and \u03a0s \u2286 (\u03a3\u0303i \u00b7 \u03a3\u0303o)\u2217 is defined as the smallest set satisfying the following:\n( \u2208 \u03a0s) \u2227 \u2227 \u03c4s \u2208 \u03a0s  async(\u03c4s) \u00b7 i \u2208 \u03a0i =\u21d2 \u03c4s \u00b7 i \u00b7 \u2208 \u03a0s async(\u03c4s) \u00b7 o \u2208 \u03a0i =\u21d2 \u03c4s \u00b7wait \u00b7 o \u2208 \u03a0s async(\u03c4s) \u00b7 i 6\u2208 \u03a0i =\u21d2 \u03c4s \u00b7 i \u00b7 err \u2208 \u03a0s\n\u2200o \u2208 \u03a3o : async(\u03c4s) \u00b7 o 6\u2208 \u03a0i =\u21d2 \u03c4s \u00b7wait \u00b7 quiet \u2208 \u03a0s \u03c4s ends in err =\u21d2 \u03c4s \u00b7 i \u00b7 err \u2208 \u03a0s  Informally, in Is: (a) Each input is immediately followed by a dummy output ; (b) Each output is immediately preceded by a wait input wait; (c) Any call to an input disabled in I is immediately followed by an err. Further, all outputs after an err are err\u2019s. (d) Any call to wait in a quiescent state is followed by quiet.\nGiven MOracle[I] and Assumption 1, it is easy to construct the membership MOracle[Is]. Note that due to Assumption 3, there is exactly one possible reply MOracle[Is](mQuery) for each query mQuery. Further, by the construction of the synchronous closure, the inputs and outputs in MOracle[Is](mQuery) alternate. Mealy machines. We model synchronous interfaces using the simpler formalism of Mealy machines rather than interface automata. A Mealy machine M is a tuple \u3008Q, q\u03b9, \u03a3\u0303i, \u03a3\u0303o, \u03b4,Out\u3009 where: (a) Q, q\u03b9, \u03a3\u0303i, and \u03a3\u0303o are states, initial state, inputs and outputs, respectively, (b) \u03b4 : Q \u00d7 \u03a3\u0303i \u2192 Q is a transition function, and (c) Out : Q \u00d7 \u03a3\u0303i \u2192 \u03a3\u0303o is an output function. We abuse notation and write Out(q, i0 . . . in) = o1 . . . on and \u03b4(q, i0 . . . in) = q\u2032 if \u2203q0, . . . , qn+1 : q0 = q \u2227 qn+1 = q\u2032 \u2227 \u22000 \u2264 i \u2264 n : \u03b4(qi, ii) = qi+1 \u2227 Out(qi, ii) = oi. A sequence\ni0o0 . . . inon \u2208 (\u03a3\u0303i \u00b7 \u03a3\u0303o)\u2217 is a trace of M if Out(q\u03b9, i0 . . . in) = o0 . . . on. We often abuse notation and write M(i0 . . . in) instead of Out(q\u03b9, i0 . . . in). We denote by Traces(M) the set of all traces of M."}, {"heading": "4.2 L\u2217: Learning Mealy Machines", "text": "For the sake of completeness, we describe the classical L\u2217 learning algorithm by Angluin [5] as adapted to Mealy machines in [28]. A reader familiar with the literature on inference of finite-state machines may safely skip this subsection.\nFix an asynchronous interfaces I and its synchronous closure Is. In the L\u2217 algorithm, in addition to a membership oracle MOracle[Is], the learner has access to an equivalence oracle EOracle[Is]. For an equivalence query, the learner passes a Mealy machine M to EOracle[Is], and is in turn returned: (a) A counterexample input cex = i0 . . . in such that M(cex) = o0 . . . on and MOracle[Is](cex) 6= i0o0 . . . inon, or (b) Correct if no such cex exists.\nThe full L\u2217 algorithm is in Algorithm 1. In Algorithm 1, the learner maintains: (a) a set SQ \u2286 \u03a3\u0303\u2217i of state-representatives (initially set to { }), (b) a set E \u2286 \u03a3\u0303\u2217i of experiments (initially set to \u03a3\u0303i), and (c) an observation table T : (SQ \u222a SQ \u00b7 \u03a3\u0303i)\u2192 (E \u2192 \u03a3\u0303\u2217o ). The observation table maps each prefix wi and suffix e to T (wi)(e), where T (wi)(e) is the suffix of the output sequence of MOracle(wi \u00b7 e) of length |e|. The entries are computed by the sub-procedure FillTable.\nIntuitively, SQ represent Myhill-Nerode equivalence classes of the Mealy machine the learner is constructing, and E distinguish between the different classes. For SQ to form valid set of Myhill-Nerode classes, each state representative extended with an input, should be equivalent to some state representative. Hence, the algorithm checks if each wi \u00b7 i \u2208 SQ \u00b7 \u03a3\u0303i is equivalent to some w\u2032i \u2208 SQ (line 3) under E, and if not, adds wi \u00b7 i to SQ. If no such wi \u00b7 i exists, the learner constructs a Mealy machine M using the Myhill-Nerode equivalence classes, and queries the equivalence oracle (line 5). If the equivalence oracle returns a counterexample, the learner adds a suffix of the counterexample to E; otherwise, it returns M. For the full description of the choice of suffix, see [26,28]. Theorem 1 ([28]). Let there exist a Mealy machine M with n states such that Traces(M) is the set of traces of Is. Then, given MOracle[Is] and EOracle[Is], Algorithm 1 returns M making at most |\u03a3\u0303i|2n + |\u03a3\u0303i|n2m membership and n equivalence queries, where m is the maximum length of counterexamples returned by EOracle[Is]. If EOracle[Is] returns minimal counterexamples, m \u2264 O(n)."}, {"heading": "4.3 An Equivalence Oracle using Membership Queries", "text": "Given a black-box interface in practice, it is not feasible to directly implement the equivalence oracle required for the L\u2217 algorithm. Here, we demonstrate a method of implementing an equivalence oracle using the membership oracle using the boundedness assumption (Assumption 2). As before fix an asynchronous interface I and its synchronous closure Is. Further, fix a target Mealy machine M\u2217 such that Traces(M\u2217) is the set of traces of Is. State bounds. A state bound of BState implies that the target Mealy machine M\u2217 has at most BState states. Given a state bound, we can replace an equivalence check with a number of membership queries using the following theorem.\nAlgorithm 1 L\u2217 for Mealy machines Input: Membership oracle MOracle, Equivalence oracle EOracle Output: Mealy machine M\n1: SQ \u2190 { }; E \u2190 \u03a3\u0303i; T \u2190 FillTable(SQ, \u03a3\u0303i, E, T ) 2: while True do 3: while \u2203wi \u2208 SQ, i \u2208 \u03a3\u0303i : 6 \u2203w\u2032i \u2208 SQ : T (wi \u00b7 i) = T (w\u2032i) do 4: SQ \u2190 SQ \u222a {wi \u00b7 i}; FillTable(SQ, \u03a3\u0303i, E, T ) 5: M\u2190 BuildMM(SQ, \u03a3\u0303i, T ); cex \u2190 EOracle(M) 6: if cex = Correct then return M 7: E \u2190 E \u222a AnalyzeCex(cex,M); FillTable(SQ, \u03a3\u0303i, E, T ) 8: function BuildMM(SQ,\u03a3\u0303i,\u03a3\u0303o,T ) 9: Q\u2190 {[wi] | wi \u2208 SQ}; q\u03b9 \u2190 [ ]\n10: \u2200wi, i : \u03b4([wi], i)\u2190 [w\u2032i] if T (wi \u00b7 i) = T (w\u2032i) 11: \u2200wi, i : Out([wi], i)\u2190 o if T (wi)(i) = o 12: return \u3008Q, q\u03b9, \u03a3\u0303i, \u03a3\u0303o, \u03b4,Out\u3009 13: function AnalyzeCex(M,cex) 14: for all 0 \u2264 i \u2264 |cex| and wpi , w s i such that wpi \u00b7w s i = cex \u2227 |wpi | = 1 do 15: wpo \u2190 M(wpi ); [w p\u2032 i ]\u2190 \u03b4([ ], w p o) 16: wso \u2190 last |wsi | output symbols of MOracle(wp \u2032 i \u00b7w s i ) 17: if wpo \u00b7wso 6= output symbols of MOracle(cex) then return wsi 18: procedure FillTable(SQ,\u03a3\u0303i,E,T ) 19: for all wi \u2208 SQ \u222a SQ \u00b7 \u03a3\u0303i, e \u2208 E do 20: T (wi)(e)\u2190 Suffix of output sequence of MOracle(wi \u00b7 e) of length |e|\nTheorem 2. Let M and M\u2032 be Mealy machines having k and k\u2032 states, respectively, such that \u2203wi \u2208 \u03a3\u0303\u2217i : M(wi) 6= M\u2032(w\u2032i). Then, there exists an input word w\u2032i of length at most k + k\u2032 \u2212 1 such that M(w\u2032i) 6= M\u2032(w\u2032i).\nThe proof is similar to the proof of the bound k + k\u2032 \u2212 2 for finite automata (see [29, Theorem 3.10.5]). We can check equivalence of M\u2217 and any given M by testing that they have equal outputs on all inputs of length at most kM+BState\u22121, i.e., using O(|\u03a3\u0303i|BState+k\u22121) membership queries. While this simple algorithm is easy to implement, it is inefficient and the number of required membership queries make it infeasible to implement in practice. Other algorithms based on state bounds have a similar problems with efficiency (see Remark 2). Further, the algorithm does not take advantage of the structure of M. The following discussion and algorithm rectifies these short-comings. Distinguisher bounds. A distinguisher bound of BDist \u2208 N implies that for each pair of states q\u22171 , q\u22172 in the target Mealy machine M\u2217 can be distinguished by an input word wi of length at most BDist, i.e., Out\u2217(q\u22171 , wi) 6= Out\n\u2217(q\u22172 , wi). Intuitively, a small distinguisher bound implies that each state is \u201clocally\u201d different, i.e., can be distinguished from others using small inputs. The following theorem shows that a state bound implies a comparable distinguisher bound.\nTheorem 3. A state bound of k implies a distinguisher bound of k \u2212 1.\nSmall distinguisher bound. In practice, distinguishers are much smaller than the bound implied by the state bound. For the media-player, the number of\nstates is 10, but only distinguishers of length 1 are required. This pattern tends to hold in general due to the following principles of good interface design: \u2013 Clear separation of the interface functions. Each state in the interface has\na specific function and a specific set of callins and callbacks. There is little reuse of names across state. The typestate\u2019s alphabet is roughly the same size as the number of states. \u2013 Fail-fast. Incorrect usage of the interface is not silently ignored but reported as soon as possible. This makes it easier to distinguish states as unexpected callins directly leads to errors. \u2013 No buffering. More than just fail-fast, a good interface is interactive and the effect of callins must be immediately visible rather than hidden. A good interface is not a combination lock that requires a long sequence on input that get stored and only at the end of the sequence the result is communicated.\nEquivalence algorithm. Algorithm 2 is an equivalence oracle for Mealy machines using the membership oracle, given a distinguisher bound. First, it computes state representatives R : Q\u2192 \u03a3\u0303\u2217i : for each q \u2208 Q, \u03b4(q\u03b9, R(q)) = q (line 1). Then, for each transition in M, the algorithm first checks whether the output symbol is correct (line 4). Then, the algorithm checks the \u201cfidelity\u201d of the transition up to the distinguisher bound, i.e., whether the representative of the previous state followed by the transition input, and the representative of the next state can be distinguished using a suffix of length at most BDist. If so, the algorithm returns a counterexample. If no transition shows a different result, the algorithm returns Correct.\nTwo optimizations further reduce the number of membership queries: (a) Quiescence transitions. Transitions with input wait and output quiet need not be checked at line 6; it is a no-op at the interface level. (b) Error transitions. Similarly, transition with the output err need not be checked as any extension of an error trace can only have error outputs.\nRemark 1. Note that if Algorithm 2 is being called from Algorithm 1, the state representatives from L\u2217 can be used instead of recomputing R in line 1. Similarly, the counterexample analysis stage can be skipped in the L\u2217 algorithm, and the relevant suffix can be directly returned (suffix in lines 9 and 10; and i in line 4).\nTheorem 4. Assuming the distinguisher bound of BDist for the target Mealy machine M\u2217, either (a) Algorithm 2 returns Correct and \u2200wi \u2208 \u03a3\u0303\u2217i : M(wi) = M\u2217(wi), or (b) Algorithm 2 returns a counterexample cex and M(cex) 6= M\u2217(cex). Further, it performs at most |Q| \u00b7 |\u03a3\u0303i|BDist+1 membership queries.\nRemark 2 (Relation to conformance testing algorithms). Note that the problem being addressed here, i.e., testing the equivalence of a given finite-state machine and a system whose behavior can be observed, is equivalent to the conformance testing problem from the model-based testing literature. However, several points make the existing conformance testing algorithms unsuitable in our setting.\nPopular conformance testing algorithms, like the W-method [10] and the Wpmethod [14], are based on state bounds and have an unavoidable O(|\u03a3\u0303i|BState)\nAlgorithm 2 Equivalence oracle with distinguisher bound Input: Mealy machine M = \u3008Q, q\u03b9, \u03a3\u0303i, \u03a3\u0303o, \u03b4,Out\u3009, Distinguisher bound BDist, and\nMembership oracle MOracle Output: Correct if M = M\u2217, and cex \u2208 \u03a3\u0303\u2217i such that M(cex) 6= M\u2217(cex) otherwise\n1: for all q \u2208 Q do R(q)\u2190 wi | \u03b4(q\u03b9, wi) = q such that length of wi is minimal 2: for all q \u2208 Q, i \u2208 \u03a3\u0303i do 3: wi \u2190 R(q) \u00b7 i 4: if Out(q, i) 6= last output symbol of MOracle(wi \u00b7 i) then return R(q) \u00b7 i 5: q\u2032 \u2190 \u03b4(q, i); w\u2032i \u2190 R(q\u2032) 6: suffix \u2190 check(wi, w\u2032i) 7: if suffix 6= Correct then 8: if M(R(q) \u00b7 i \u00b7 suffix) 6= output symbols of MOracle(R(q) \u00b7 i \u00b7 suffix) then 9: return R(q) \u00b7 i \u00b7 suffix\n10: else return R(q\u2032) \u00b7 suffix 11: return Correct 12: function check(wi, w\u2032i) 13: for all suffix \u2208 \u03a3\u0303\u2264BDisti do 14: wo \u2190 output symbols of MOracle(wi \u00b7 suffix) 15: w\u2032o \u2190 output symbols of MOracle(w\u2032i \u00b7 suffix) 16: if the last |suffix| symbols of wo and w\u2032o differ then return suffix 17: return Correct\nfactor in the complexity. In our experiments, the largest typestate had 10 states and 7 inputs. The O(|\u03a3\u0303i|BState) factor leads to an infeasible (i.e., > 108) number of membership queries. However, since distinguisher bounds are often much smaller than state bounds, O(|\u03a3\u0303i|BDist) membership queries are feasible (i.e., 103). The W- and Wp-methods cannot be directly adapted to use distinguisher bounds.\nThe other common algorithm, the D-method [19,17], does not apply in our setting either. The D-method is based on building a distinguishing sequence, i.e., an input sequence which produces a different sequence of outputs from every single state in the machine. However, for asynchronous typestates, such single distinguishing sequences do not exist in practice. For similar reasons, conformance testing algorithms such as the UIO-method [27] do not apply either.\nIn this light, we believe that Algorithm 2 is a novel conformance testing algorithm useful in specific settings where resets are inexpensive and implementations are designed to have small distinguisher bounds."}, {"heading": "4.4 Putting it all together", "text": "We now present the full solution to the asynchronous typestate learning problem.\nTheorem 5. Given a deterministic interface I with observable quiescence and the membership oracle MOracle[I]. Assume there exists an interface automaton A with n states with distinguisher bound BDist modeling the typestate of I. Interface automaton A can be learned with O(|\u03a3i| \u00b7n3 + n \u00b7 |\u03a3i|BDist) membership queries.\nProof sketch. Starting with an asynchronous interface I and a membership oracle MOracle[I], using Assumption 1 and Assumption 3 we can construct\nthe membership oracle MOracle[Is] for the synchronous closure Is of I. Given the distinguisher bound (or a state bound using Assumption 2 and Theorem 3), we can construct an equivalence oracle EOracle[Is] using Algorithm 2. Oracles MOracle[Is] and EOracle[Is] can then be used to learn a Mealy machine M with the same set of traces as Is. This Mealy machine can be converted into the interface automata representing the asynchronous typestate of I by: (a) Deleting all transitions with output err and all self-loop transitions with output quiet, and (b) Replacing all transitions with input wait with the output of the transition."}, {"heading": "5 Applying Active Learning to Android", "text": "We implemented our method in a tool called Starling. In this section we describe how it works, the practical challenges we faced when working with Android, and our solutions to overcome them. Starling is implemented as an Android application and learns asynchronous typestates from within Android."}, {"heading": "5.1 Designing an Experiment", "text": "To learn a typestate, a Starling user creates an experiment. An experiment is a small code harness that covers the usual inputs of an active learning algorithm, as well as the inputs specific to learning on Android. The main components are: Class of Study. Starling learns the typestate of Java classes. The user speci-\nfies this class of study and provides a constructor and optionally a destructor which are used to reset the environment and isolate membership queries Distinguisher Bound. If known, the distinguisher bound can be provided directly. Otherwise, it can be obtained from Assumption 2 by Theorem 3. Instrumented Alphabet. The instrumented alphabet specifies an abstract alphabet for the learning algorithm and translation between the abstract alphabet and concrete callins/callbacks of the class of study. Query Filter. The user can restict the sequence of symbols in the alphabet with a filter for sequences already known to be illegal or uninteresting. The Query Filter and the Instrumented Alphabet together comprise a Learning Purpose [1], i.e., a predefined automata that constrains the behavior to learn. Platform Specific Parameters. Several more options are available for adjusting the learning. The most important is the quiescence timeout which specifies the duration before a state is considered as quiescent. The choice of this timeout corresponds to Assumption 1."}, {"heading": "5.2 Observing Asynchronous Callbacks", "text": "In our approach we assume bounded asynchrony (Assumption 1) and, therefore, we can observe when the interface does not produce any new output (quiescence). We enforce this assumption on a real system with timeouts: the membership query algorithm waits for a new output for a fixed amount of time tmax, assuming that quiescence is reached when this time is elapsed. However, Android does not provide any worst case execution time for the asynchronous operations and we rely on the user to choose a large enough tmax. The membership query also assumes the existence of a minimum time tmin before a callback occurs. This ensures that we can issue a membership query with two consecutive callins (so,\nwithout a wait input in between), i.e., we have the time to execute the second callin before the output of the first callin.\nConsider the MediaPlayer example from Section 2. The membership query setDataSource(URL) \u00b7wait \u00b7 prepareAsync() \u00b7wait may not return the onPrepared() if tmax is violated, i.e., if the callback does not arrive before the timeout. On the other hand, while testing, it is possible that the prepareAsync() \u00b7 start() might not return an error as expected if the lower bound tmin is violated. To avoid such issues we try to reliably control the execution environment and parameters to ensure that callbacks occurred between tmin and tmax. For the MediaPlayer case, we need to pick the right media source file."}, {"heading": "5.3 Checking and Enforcing our Assumptions", "text": "The simplest experiment to learn a class\u2019s asynchronous typestate ties a single input symbol to each of its callins and a single output symbol to each of its callbacks. However, many Android classes have behaviors which cause this simple experiment to fail and require more detailed experiments to succeed.\nThe main challenges when designing an experiment are (a) Non-deterministic behaviors, i.e., the state of the device and external events may influence an application. These elements are inherently non-deterministic; however, nondeterminism violates Assumption 3. (b) The parameter space required to drive concrete test cases to witness a membership query is potentially infinite. Though we have ignored callin parameters till now, they are a crucial issue for testing. (c) The implementation of the protocol we are learning may not be a regular language. Note that this is a violation of Assumption 2. Non-Deterministic Behavior. Non-deterministic behavior is disallowed by our Assumption 3. However, to make this assumption reasonable we must make non-determinism straightforward to eliminate when it arises. We explain two primary classes of non-deterministic behaviors and strategies to eliminate these behaviors. The first class is related to the state of the environment before a callin and the second is environment changes during an asynchronous computation.\nBecause the learning algorithm cannot learn from non-deterministic systems, Starling will terminate if a non-deterministic behavior is detected. In such case, Starling reports the causing input sequence and disagreeing output sequences. It detects this behavior by caching all membership queries as input/output sequence pairs. When a new trace is explored, Starling checks that the trace prefixes are compatible with the previously seen traces.\nIn the first case, the state of the environment prior to a callin influences the output. We resolve this non-determinism by manually modeling how the environment may affect the callbacks and create a finer input alphabet that explicate the previously hidden state of the environment. For example, in the class SQLiteOpenHelper, the getReadableDatabase() may either trigger a onCreate() callback or not, depending on the parameter value to a previous callin (constructor)was the name of an existing database file. Hence, the behavior of the callin is non-deterministic, depending on the status of the database on disk. In the SQLiteOpenHelper example, we split the constructor callin into constructor/fileExists and constructor/noFileExists and pass the right\nparameter values in each case. With this extra modeling we can learn the interface automaton, since the execution getReadableDatabase() ends in two different states of the automaton (see Figure 2).\nThe second class is the effect of the environment on asynchronous computations. Such effects, by definition, cannot be controlled or made explicit prior to the call. We choose to ignore this non-determinism by merging different outputs, considering them to be the same. This is the dual of the previous solution.\nAn example is the SpeechRecognizer, for which calling startListening() produces different callbacks depending on the environment. As the environment cannot be reasonably controlled, we merge outputs to go to the same state. If outputs are erroneously merged, the non-determinism will propagate and continue to manifest. Therefore, there is no risk when merging outputs.\nHandling Callin Parameters. While parameter-less callins such as start() and stop() are common in Android classes, many parameterized callins exist. Because input symbols need to be listed in the experiment definition, the full range of parameter values cannot be explored. In practice, we found that parameters often have little effect on the typestate automaton. In cases where they do affect the automaton, multiple input symbols can be defined to represent the same method called with several different parameters. This solution is similar to splitting on environmental effects when dealing with non-determinism.\nLearning from Non-Regular Languages. An intrinsic limitation of L\u2217 is that it learns only regular languages. However, some classes expose non-regular protocols. Common cases include situations where a request callin may be called an unbounded number of times, and a response callback is called exactly the same number of times. For example, in the SpellCheckerSession class, callin getSuggestion() and callback onGetSuggestions() follow this pattern.\nHowever, even in such cases, it can be useful to build a regular approximation of the typestate. For example, restricting the typestate to behaviors where there is at most one pending request (a regular subset) provides all the information a programmer would need. Hence, in such cases, we use the technique of learning purposes [1] to learn a regular approximations of the infinite typestate."}, {"heading": "6 Empirical Evaluation", "text": "Implementation. We implemented the typestate learning algorithm, along with the membership oracle for the Android framework, in a tool called Starling. Starling is implemented in Java and can be run on both emulators and physical devices. We run the experiments on a LG Nexus 5 running the Android framework version 23. The major challenge during the development of Star-\nling was not in the implementation of the learning algorithm, but instead in interfacing the algorithm, specifically the membership oracle, with Android. Goals. Our experiments were designed to empirically evaluate the following: Question 1. Does our technique learn typestates efficiently? Question 2. What is the size of distinguisher bounds that occur in practice?\nDoes they support the small distinguisher bound hypothesis? Question 3. Do the asynchronous typestates learned reveal interesting or unin-\ntended behavior in the interfaces? Methodology. We sampled 10 classes from the Android framework and ran Starling on it. For each class, the relevant callins and callbacks were identified manually, and a test harness was written to connect inputs and outputs symbols to the corresponding callins and callbacks of the class. Each test harness consisted of 100\u2212 200 lines of, mostly boiler-plate, Java code. In addition, for some classes, we provided a query filter to restrict the learning purpose (see Section 5).\nTo evaluate efficiency, we measure the overall time taken for learning, as well as the number of membership (MQ) and equivalence queries (EQ). The number of queries is likely a better measure of performance than running time: the running time depends on external factors. For example, in the media player the running time depends on play-length of the media file chosen during testing.\nWe validate the accuracy of learned asynchronous typestates using two approaches. First, for classes whose documentation contains a picture or a description of what effectively is an asynchronous typestate, we compare our result to the documentation. Second, for all the other classes we perform manual code inspection and run test apps to evaluate correctness of the produced typestates.\nWe used a distinguisher bound of 2 for our experiments; further, we manually examined the learned typestate and recorded the actual distinguisher bound. For our third question, i.e., does the learned asynchronous typestate reveal interesting behaviors, we manually examined the learned typestate, compared it against the official Android documentation, and recorded discrepancies. Results. We discuss the results (in Table 1) with respect to our three questions. Question 1: Efficiency. The table shows that the learning algorithm runs reasonably fast: most typestates learned within a few minutes. The longest one takes 71 minutes, still applicable to nightly testing. The numbers for membership queries\nare reported as X(Y )\u2014X is the number of membership queries asked by the algorithm, while Y is the number actually executed by the membership oracle. This number is lower as the same query may be asked multiple times, but is executed only once and the result is cached. For each benchmark, the accuracy validation showed that the produced typestate matched the actual behavior. Question 2: Distinguisher Bounds. As mentioned before, we used a distinguisher bound of 2 for all experiments. However, a manual examination of the learned asynchronous typestates showed that a distinguisher bound of 1 would be sufficient in all cases except the SQLiteOpenHelper where a bound of 2 is necessary. This supports our conjecture that, in practice, interfaces are designed with each state having a unique functionality (see Section 4.3). Question 3: Interesting Learned Behavior. Of the three questions, our experiments to examine the learned asynchronous typestate for interesting behavior turned out to be the most fruitful, uncovering several discrepancies, including corner cases, unintended behavior and likely bugs, in the Android framework. These results reaffirm the utility of our main goal of automatically learning asynchronous typestate, and suggest that learning typestate can serve valuable roles in documentation and validation of asynchronous interfaces.\nIn 2 cases, the learned typestate and documented behavior differed in certain corner cases. We carefully examined the differences, by framework source examination and manually writing test applications, and found that the learned typestate was correct and the documentation was faulty. In 3 other cases, we believe the implemented behavior is not the intended behavior, i.e., these are likely bugs in the Android implementation. Further, in 1 additional case, we found that the typestate learned on different versions of the Android framework were different. These discrepancies mostly fall into two separate categories: Incorrect documentation. In such cases, it turned out that the discrepancy is minor and unlikely to cause erroneous behavior in client programs. Race conditions. Several likely bugs were due to a specific category of race conditions. These interfaces have (a) a callin to start an action and a corresponding callback which is invoked when the action is successfully completed; (b) a callin to cancel an already started action and a corresponding callback which is invoked if the action is successfully cancelled. When the start action and cancel action callins are called in sequence, the expectation is that exactly one of the two callbacks are called. However, when the time between the two callins is small, we were able to observe unexpected behaviors, including neither or both callbacks being invoked, and even the interface showing arbitrary further behavior.\nThe second category indicates a common implementation issue, and suggests potential avenues for introducing system or language features to avoid this issue.\nCase studies. Of 10 benchmarks, we pick 3 and briefly explain them here. Full details of all benchmarks are in the appendix.\nMediaPlayer. This is the class from the example in Section 2. The learned typestate differs from the existing documentation. The learned typestate: (a) has the pause() callin enabled in the \u201cplayback completed\u201d state, and (b) shows that\nonPrepared() is invoked even after the synchronous callin prepare(). Though undocumented, these behaviors are unlikely to cause any issues. SpellCheckerSession. This class provides an interface to request spelling suggestions on text fragments. A client requests suggestions via getSentenceSuggestions() and the suggestions are delivered via onGetSentenceSuggestions() unless cancel() or close() is called. The full interface is non-regular; the number of callbacks is equal to the number of callins. We used a query filter to restrict learning to the fragment with at most one call to getSentenceSuggestions(). For this fragment, the resulting typestate shows that calling cancel() does not prevent receiving callbacks with results, potentially leading to errors in applications that rely on this guarantee. MediaRecorder. The MediaRecorder class provides a single interface to recording audio and video various sources such as the microphone, camera, and voice calls. The learned typestate differs from the documentation in one aspect and reveals a problematic behavior: calling start() followed immediately by stop() in the \u201cprepared\u201d state throws an exception. However, calling start(), waiting for a short time (wait), followed by stop() is not an error. Note that the interface does not perform any callback after start() (i.e., we get quiet on wait). This behavior is not documented, and also, is completely unexpected, as the client program has no indication of whether it is safe to call stop(). Apart from this behavior, the typestate is equivalent to the one shown in the documentation.\nThe unexpected behavior could be fixed either by: (a) adding a callback onStart() to inform the client that it is safe to call stop(), or (b) modifying the implementation of start() to only return after the task is truly completed."}, {"heading": "7 Related Work", "text": "Works which automatically synthesize specifications of the valid sequences of method calls (e.g. [3,30,4,16]) typically ignore the asynchronous callbacks.\nStatic analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30]. The work in [3] infers interfaces for Java classes using L\u2217. In contrast, our approach is based on testing. Therefore, we avoid the practical problem of abstracting the framework code. On the other hand, the use of testing makes our L\u2217 oracles sound only under assumptions.\nInferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25]. In contrast to dynamic mining, we do not rely on the availability of client applications or a set of execution traces. The L\u2217 algorithm drives the testing.\nThe analysis of event-driven programming framework has recently gained a lot of attention (e.g. [6,8,9,23]). However, none of the existing works provide an automatic approach to synthesize interface specifications. Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7]. These approaches manually hard-code the behavior of the framework to increase the precision of the analysis. The asynchronous typestate specifications that we synthesize can be used here, avoiding the manual specification process.\nOur work builds on the seminal paper of Angluin [5] and the subsequent extensions and optimizations. In particular, we build on L\u2217 for I/O automata [1,28]. The optimizations we use include the counterexample suffix analysis from [26] and the optimizations for prefix-closed languages from [22]. The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2."}, {"heading": "36. John Whaley, Michael C. Martin, and Monica S. Lam. Automatic extraction of", "text": "object-oriented component interfaces. In Proceedings of the 2002 ACM SIGSOFT International Symposium on Software Testing and Analysis, ISSTA \u201902, pages 218\u2013 228, New York, NY, USA, 2002. ACM. 37. Jinlin Yang, David Evans, Deepali Bhardwaj, Thirumalesh Bhat, and Manuvir Das. Perracotta: Mining temporal api rules from imperfect traces. In Proceedings of the 28th International Conference on Software Engineering, ICSE \u201906, pages 282\u2013291, New York, NY, USA, 2006. ACM."}, {"heading": "A Detailed Descriptions of the Results", "text": "AsyncTask. The AsyncTask class turns arbitrary computations into asynchronous operations with progress tracking and results are delivered via callbacks. For our experiment, the computation is a simple timer. A constructed AsyncTask object performs its task when it receives the execute() callin, and then either returns the results when they are available with the onPostExecute() callback, or returns an onCancelled() if cancel() is called first. The object is single-use; after it has returned a callback it will accept no further execute() commands.\nIn order to test this class, the get() input had to be dismissed (i.e., we did not include get() in our learning purpose, see Section 5) because its results were non-deterministic when called directly after the onPostExecute() callback. Our experiment revealed an unexpected edge-case: if execute() is after cancel() but before the onCancelled() callback is received, it will not throw an exception but will never cause the asynchronous task to be run.\nSpeechRecognizer. The SpeechRecognizer is a simple interface to the speechto-text services provided in the Android framework, and is necessarily asynchronous due to the time spent waiting for speech and communicating with remote speech-to-text services over the network. An application constructs a SpeechRecognizer with a listener for various errors and result callbacks. The process is set off with a call to startListening(). The SpeechRecognizer calls onReadyForSpeech() and then either returns the recognized speech results with onResults() or one of several error cases with onError().\nLike the SQLiteOpenHelper, this class provides another case of environmental non-determinism. The particular callback that signals the end of the speech session\u2014either an onResults() or an onError()\u2014is determined by the environment (in particular, the sound around the phone during the test). In this case, to reduce the system to a deterministic one we can learn, we supposed that the state after an onResults() or onError() is the same and merged the two\ncallbacks into a single onFinished() symbol. The determinism observed in the resulting typestate confirmed this assumption.\nOur results revealed two interesting corner cases for the ordering of inputs. First, if an app calls cancel() between calling startListening() and receiving the onReadyForSpeech() callback (represented by our \u201cstarting\u201d output symbol), calling startListening() again will have no effect until after a certain amount of time, as shown by the wait transition from state \u201cCancelling\u201d to \u201cFinished\u201d. Delays in readiness like this can be generally considered bugs; if a system will not be ready immediately for inputs it should provide a callback to announce when the preparations are complete, so as not to invite race conditions.\nOur second corner case is where the app calls stopListening() as the very first input on a fresh SpeechRecognizer. This will not throw an exception, but calling startListening() at any point after will fail, making the object effectively dead.\nWhile we performed all other tests on an Android 5.1.1 system, the SpeechRecognizer\u2019s callback behavior was so buggy\u2014callbacks would repeat themselves several times, sometimes interleaving with later callbacks\u2014that we could not learn a consistent automaton. We therefore performed this experiment on an Android 6.0.1 system, where this behavior is fixed. CountDownTimer. The CountDownTimer is an asynchronous timer that is initialized with a period of time and then invokes the onFinish() callback when the time is up, unless a cancel() method is called in the meantime.\nThis class is not a regular language; calling start() multiple times will result in that same number of onFinish() callbacks. In order to learn a regular language subset, we used the learning purpose approach to limit the number of start() inputs in a valid query to one. FileObserver. The FileObserver is a listener class that tracks changes to a file or directory, making callbacks as they occur. The class itself has only two input\nmethods\u2014startWatching() and stopWatching()\u2014so for our experiment we considered the environmental actions of modifying (and possibly creating) and deleting the watched file as additional inputs. An onEvent() callback returns with various event types; the ones we track are MODIFY and DELETE SELF. One interesting bit of behavior we correctly observe (which is in the documentation for the class) is that if the file is deleted while being watched, no further callbacks will be made even if it is recreated. MediaPlayer. This is the class from the introductory example in Section 2. There are two interesting aspects about the run of Starling on MediaPlayer and the learned typestate: \u2013 The learned typestate has the pause() callin is enabled in the \u201cpaused\u201d\nstate. Though undocumented, we do not believe this behavior is a bug. \u2013 The class returns the onPrepared() callback even after the synchronous\nprepare() callin \u2014 this callback is unnecessary as it is not necessary to wait for it after calling prepare. However, this unnecessary callback leads to Starling generating many more states than necessary; every state after prepare() is called has an \u201cequivalent\u201d duplicate there: one where the unnecessary onPrepared() is pending, and one where it is not. In the table, the number of states reported in brackets is the number including the duplicate states. We believe that these states can be eliminated automatically; however, this is not implemented currently.\nMediaCodec. The MediaCodec class provides an interface for decoding encoded media files (audio and video) in a continuous manner, i.e., audio and video data is continuously passed into the interface, and the interface passes the results back as soon as they are ready. The interaction with this interface is done fully asynchronously: the interface calls the onInputBufferAvailable() callback whenever it is ready to accept input, and onOutputBufferAvailable() callback when results are ready. The interaction is started and stopped using the start() and stop() callins; and further, the flush() callin invalidates all available buffers. The typestate of MediaCodec is described with a high-level diagram in the documentation: https://developer.android.com/reference/ android/media/MediaCodec.html. Starling is able to learn the typestate of the interface exactly in this case, and the learned typestate matches the description in the documentation. MediaRecorder. The MediaRecorder class provides a single interface to recording audio and video various sources such as the microphone, camera, and voice calls. The typestate for this class is present in the documentation at https://developer.android.com/reference/android/media/ MediaRecorder.html. Of our benchmarks, the MediaRecorder is particularly unique, as the interface has no callbacks related to starting or stopping, i.e., at looks like a standard (not event-driven asynchronous) interface. The callbacks which do exist are for receiving updates or exceptions during recording. However, internally, the implementation of the class is asynchronous. This can be seen as follows: calling start() followed immediately by stop() in the \u201cprepared\u201d state throws an exception. However, calling start(), waiting for a short time (wait),\nfollowed by stop() is not an error. Note that the interface does not perform any callback on wait (i.e., we get quiet). This behavior is not documented, and also, completely unexpected from the client programmer point of view. Other than this behavior, the typestate is equivalent to the one shown in the documentation.\nThe unexpected behavior can be fixed in one of two ways: (a) Expose the asynchronous nature of the class, i.e., add a callback onStart(),\nand make calling stop() legal only after onStart() is called back. (b) Modify the implementation of the start() callin to wait and only return\nafter the task is truly completed, i.e., do not let the asynchronous nature of the implementation leak to the client.\nMediaScannerConnection. The MediaScannerConnection class implements an interface that applications may use to inform the standard android media services about new media files that the application has created. For example, an application may download an image, and then scan it using MediaScannerConnection: after the scan, the new image will be available through the standard image handling services (for example, the media gallery).\nThe MediaScannerConnection interface itself is simple with 3 relevant callins: connect(), disconnect(), and scanFile(). Further, it has 1 callback important to the typestate: onMediaScannerConnected(). The protocol for using the interface is as follows: (a) connect() is called to establish connection with the media scanner service; (b) the onMediaScannerConnected() callback is called by the interface to inform the client that the connection has been established; (c) the client may scan any number of files through the scanFile() callin; and (d) the client finally calls disconnect() to disconnect from the media scanner service. Starling was able to learn this typestate exactly. The only point of note is that the onMediaScannerConnected() callback will be called even if disconnect() is called immediately after connect() before the callback; however, the interface is in the disconnected state. SpellCheckerSession. This class provides a high-level interface for apps to request spelling suggestions on text fragments. An app can request suggestions for\na particular sentence (via getSentenceSuggestions()) which will be delivered via callback (onGetSentenceSuggestions()) unless a cancel() or close() is called. The interface is asynchronous due to the computational intensity of the text-processing involved.\nThe full interface is non-regular; the number of callbacks with results is equal to the number of request callins. We therefore used the learning purpose approach to restrict learning to the fragment with at most one call to getSentenceSuggestions(). For this fragment, the resulting asynchronous typestate showed that calling cancel() will not prevent receiving callback with results. This might hurt applications that rely on a guarantee that the callback does not arrive after cancel(). SQLiteOpenHelper. This class provides a more structured interface for apps to open and set up SQLite databases. It has callbacks for different stages of database initialization, allowing apps to perform setup operations only as they are needed. When a database is opened with getWritableDatabase(), a callback onConfigure() is called, followed by an onCreate() if the database didn\u2019t exist yet or an onUpgrade() if the database had a lower version number than was passed to the SQLiteOpenHelper constructor, all followed finally by an onOpen() when the database is ready for reading. The database can then be closed with a close().\nOur experiment observed the callbacks received when opening databases in different states (normal, non-existent, and out of date) and performing the close() operation at different points in the sequence. We found that once the getWritableDatabase() method is called, calling close() will not prevent the callbacks from being run.\nB Impossibility result for the asynchronous typestate learning problem from Section 3.2\nWe say that an interface automaton A is compatible with a membership query mQuery and its result MOracle[I](mQuery) if: (a) MOracle[I](mQuery) is a trace of A, or (b) MOracle[I](mQuery) = \u22a5 and there is no trace of A whose sequence of inputs is to mQuery. The following impossibility theorem shows that membership queries are not sufficient to effectively learn typestates.\nTheorem 6. There exists an interface I and an MOracle[I] such that: \u2013 There exists an interface automaton A that models the typestate of I, and \u2013 For every finite set of pairs (mQuery,MOracle[I](mQuery)) of membership\nqueries and corresponding results, there exist interface automata A\u2032 and A\u2032\u2032, with different sets of traces, compatible with each pair."}, {"heading": "C Proofs for theorems in Section 4", "text": "A run segment \u03c0 of M is given by q0 \u2192i0o0 . . . \u2192 in on qn+1 where \u22000 \u2264 i \u2264 n : \u03b4M(qi, ii) = qi+1 \u2227 Out(qi, ii) = oi. We use the following shorthands: (a) \u03b4(q0, i0 . . . in) for qn+1, and (b) Out(q0, i0 . . . in) for o0 . . . on. If q0 = q\u03b9, then we say that i0o0 . . . inon is a trace of M. Further, if q0 = q\u03b9, we write\nM(i0 . . . in) = o0 . . . on. A Mealy machine M is the asynchronous typestate of Is if every trace of M is a trace of Is, and vice versa.\nProof of Theorem 2. Let M = \u3008Q, q\u03b9, \u03a3\u0303i, \u03a3\u0303o, \u03b4,Out\u3009 and M\u2032 = \u3008Q\u2032, q\u2032\u03b9, \u03a3\u0303i, \u03a3\u0303o, \u03b4\u2032,Out\n\u2032\u3009. Let Out : Q \u222a Q\u2032 \u00d7 \u03a3\u0303i \u2192 \u03a3\u0303o (resp. \u03b4 : Q \u222a Q\u2032 \u00d7 \u03a3\u0303i \u2192 Q \u222a Q\u2032) be a unified output (resp. transition) function that applies either Out or Out\u2032 (resp. \u03b4 or \u03b4\u2032) depending on if the first input is in Q or Q\u2032.\nWe first define a sequence of equivalence relations \u2261m on Q \u222a Q\u2032 for each m > 0. For each m, we say q1 \u2261m q2 if for all input words wi of length at most m, we have that Out(q1, wi) = Out(q2, wi). Note that each \u2261m+1 is a refinement of \u2261m. As we have that M(wi) 6= M\u2032(wi), we get q\u03b9 6\u2261m q\u2032\u03b9 for some m. Further, we have that \u22611 is not universal, i.e., \u2203q1, q2 : q1 6\u22611 q2; otherwise, we will have Out(q1, wi) = Out(q2, wi) for every wi, q1, and q2, contradicting the premise of the theorem statement.\nBelow, we show that q1 6\u2261m+1 q2 if and only if q1 6\u2261m q2 or \u2203i \u2208 \u03a3\u0303i : \u03b4(q1, i) 6\u2261m \u03b4(q2, i). Hence, each \u2261m+1 is uniquely determined by \u2261m and \u03b4 giving us that \u2261m=\u2261m+1 =\u21d2 \u2261m+1=\u2261m+2. Further, since all \u2261m are successive refinements defined on a finite set, we can only have \u2261m+1 6=\u2261m for a finite number of m. Let m\u2217 be the least m such that \u2261m\u2217+1 6=\u2261m\u2217 . By the two statements above, we get that\n\u22611 6= \u22612 6= . . . 6= \u2261m\u2217 = \u2261m\u2217+1 = \u2261m\u2217+2 = . . .\nHence, for every pair of states q1 and q2, if \u2203wi : Out(q1, wi) 6= Out(q2, wi), then there exists a word w\u2032i of length at most m\u2217 such that Out(q1, w\u2032i) 6= Out(q2, w\u2032i).\nNow, by the non-universality of \u22611 and the fact that each \u2261m is a strict refinement of the previous for m \u2264 m\u2217, we have that m\u2217 can at most be |Q| + |Q\u2032| \u2212 1. This gives us the required result.\nNow, to show that q1 6\u2261m+1 q2 if and only if q1 6\u2261m q2 or \u2203i \u2208 \u03a3\u0303i : \u03b4(q1, i) 6\u2261m \u03b4(q2, i). \u2013 Assume q1 6\u2261m q2 or \u2203i \u2208 \u03a3\u0303i : \u03b4(q1, i) 6\u2261m \u03b4(q2, i). If q1 6\u2261m q2, we have that q1 6\u2261m+1 q2 as each \u2261m+1 is a refinement of \u2261m. Otherwise, assume \u2203i \u2208 \u03a3\u0303i : \u03b4(q1, i) 6\u2261m \u03b4(q2, i). Now, there exists a wi such that Out(\u03b4(q1, i), wi) 6= Out(\u03b4(q2, i), wi). It is easy to show that Out(q1, i \u00b7wi) and Out(q2, i \u00b7wi). Further, |i \u00b7wi| is at most m+ 1 giving us q1 6\u2261m+1 q2.\n\u2013 Assume q1 6\u2261m+1 q2. There exists a word wi of length at most m + 1 such that Out(q1, wi) 6= Out(q2, wi). If |wi| \u2264 m, we get that q1 6\u2261m q2. Otherwise, let wi = i \u00b7w\u2032i. If Out(q1, i) 6= Out(q2, i), we have that q1 6\u22611 q2, and hence, q1 6\u2261m q2. In the remaining case, we have that Out(q1, i) = Out(q2, i) and Out(q1, i \u00b7w\u2032i) 6= Out(q2, i \u00b7w\u2032i). From these, it is easy to show that Out(\u03b4(q1, i), w\u2032i) 6= Out(\u03b4(q2, i), w\u2032i). This gives us that \u03b4(q1, i) 6\u2261m \u03b4(q2, i).\nThis completes the proof.\nProof of Theorem 3. Let M\u2217 have |Q\u2217| \u2264 BState states. Define a series of equivalence functions \u2261m on Q such that q1 \u2261m q2 if and only if q1 can be distinguished from q2 by words of length > m. The remainder of the proof is exactly similar\nto the proof of Theorem 2. Again, the final bound obtained on the length of distinguishers is one less than the size of the domain of the equivalence relations. Here, the bound is |Q\u2217| \u2212 1 \u2264 k \u2212 1, giving us the theorem.\nProof of Theorem 4. The complexity bound is easy to show. For part (a), assume towards a contradiction that Algorithm 2 returns Correct, but there exists an input word cex = i0i1 . . . in such that M(cex) 6= M\u2217(cex). Let pre(k) and suf(k) be the prefix of length k and suffix of length n+ 1\u2212 k of cex.\nLet q0 \u2192i0o0 q1 . . . qn \u2192 in on qn+1 be the run of M on cex. Define the function P (k) for 0 \u2264 k \u2264 n + 1 as follows: P (k) = o0 . . . ok\u22121 \u00b7Out\u2217(\u03b4\u2217(q\u2217\u03b9 , R(qk))), suf(k)). The value of P (k) is given by the first k symbols of o0 . . . on and concatenated with the last n + 1 \u2212 k symbols of M\u2217(R(qk) \u00b7 suf(k)). Informally, we run pre(k) on M and suf(k) of M\u2217, with R(qk) acting as the link between the two machines.\nAs R(q\u03b9) = , we can derive that P (0) = M\u2217(cex) and P (n + 1) = M(cex). Since, by assumption, P (0) 6= P (n + 1), we have \u2203k : P (k) 6= P (k + 1). Now, denoting \u03b4\u2217(q\u2217\u03b9 , R(qk)) as q\u2217k and \u03b4\u2217(q\u2217\u03b9 , R(qk+1)) as q\u2217k+1, we have\no1 . . . ok\u22121 \u00b7Out\u2217(q\u2217k, suf(k)) 6= o1 . . . ok\u22121ok \u00b7Out \u2217(q\u2217k+1, suf(k + 1))\nOut\u2217(q\u2217k, suf(k)) 6= ok \u00b7Out \u2217(q\u2217k+1, suf(k + 1))\nOut\u2217(q\u2217k, ik \u00b7 suf(k + 1)) 6= Out(qk, ik) \u00b7Out \u2217(q\u2217k+1, suf(k + 1))\nThe first symbol on the left is Out\u2217(\u03b4\u2217(q\u2217\u03b9 , R(qk)), ik) and on the right is Out(qk, ik). If these were not equal, on line 4, the algorithm would have returned a counterexample\u2014giving us a contradiction. On the other hand, if they were equal, removing the first symbol on both sides leaves us with:\nOut\u2217(\u03b4\u2217(q\u2217k, ik), suf(k + 1)) 6= Out \u2217(q\u2217k+1, suf(k + 1))\nHence, \u03b4\u2217(q\u2217k, ik) and q\u2217k+1 are distinguishable in M\u2217. Therefore, there exists a suffix of length at most BDist such that Out\u2217(\u03b4\u2217(q\u2217k, ik), suffix) 6= Out\u2217(q\u2217k+1, suffix). However, by definition of q\u2217k and q\u2217k+1, the left and right hand sides are equal to the output symbols of MOracle(R(qk) \u00b7 ik \u00b7 suffix) and MOracle(R(\u03b4(qk, ik)) \u00b7 suffix), respectively. Hence, when check was called at line 6 with the state qk and input ik, a counterexample would have been returned\u2014this leads to a contradiction again.\nFor part (b), assume that Algorithm 2 return a counterexample. If the counterexample is returned at line 4, then it is easy to see that the last output symbol of M(R(q) \u00b7 i) and M\u2217(R(q) \u00b7 i) differ. On the other hand, if the counterexample is returned at lines 9 and 10, we have that M\u2217(R(q) \u00b7 i \u00b7 suffix) and M\u2217(R(q\u2032) \u00b7 suffix) differ in the last |suffix| positions. However, M(R(q) \u00b7 i \u00b7 suffix) and M(R(q\u2032) \u00b7 suffix) are equal in the last |suffix| positions. Hence, we cannot have both M(R(q) \u00b7 i \u00b7 suffix) = M\u2217(R(q) \u00b7 i \u00b7 suffix) and M(R(q\u2032) \u00b7 suffix) = M\u2217(R(q\u2032) \u00b7 suffix). This implies at least one of R(q) \u00b7 i \u00b7 suffix and R(q\u2032) \u00b7 suffix is a counterexample, which is returned."}], "references": [{"title": "Learning I/O automata", "author": ["F. Aarts", "F. Vaandrager"], "venue": "CONCUR", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "Mining interface specifications for generating checkable robustness properties", "author": ["M. Acharya", "T. Xie", "J. Xu"], "venue": "In Software Reliability Engineering,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Synthesis of interface specifications for Java classes", "author": ["R. Alur", "P. \u010cern\u00fd", "P. Madhusudan", "W. Nam"], "venue": "In POPL,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Mining specifications", "author": ["Glenn Ammons", "Rastislav Bod\u0301\u0131k", "James R. Larus"], "venue": "In POPL,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2002}, {"title": "Learning regular sets from queries and counterexamples", "author": ["Dana Angluin"], "venue": "Inf. Comput.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1987}, {"title": "FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps", "author": ["Steven Arzt", "Siegfried Rasthofer", "Christian Fritz", "Eric Bodden", "Alexandre Bartel", "Jacques Klein", "Yves Le Traon", "Damien Octeau", "Patrick McDaniel"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2014}, {"title": "Scalable race detection for android applications", "author": ["Pavol Bielik", "Veselin Raychev", "Martin T. Vechev"], "venue": "In OOPSLA,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2015}, {"title": "Selective control-flow abstraction via jumping", "author": ["Sam Blackshear", "Bor-Yuh Evan Chang", "Manu Sridharan"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2015}, {"title": "Edgeminer: Automatically detecting implicit control flow transitions through the android framework", "author": ["Yinzhi Cao", "Yanick Fratantonio", "Antonio Bianchi", "Manuel Egele", "Christopher Kruegel", "Giovanni Vigna", "Yan Chen"], "venue": "In NDSS,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Testing software design modeled by finite-state machines", "author": ["T.S. Chow"], "venue": "IEEE Transactions on Software Engineering,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1978}, {"title": "Mining object behavior with adabu", "author": ["Valentin Dallmeier", "Christian Lindig", "Andrzej Wasylkowski", "Andreas Zeller"], "venue": "In Proceedings of the 2006 International Workshop on Dynamic Systems Analysis,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "Apposcopy: Semantics-based detection of Android malware through static analysis", "author": ["Yu Feng", "Saswat Anand", "Isil Dillig", "Alex Aiken"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2014}, {"title": "Ghedamsi. Test selection based on finite state models", "author": ["S. Fujiwara", "G. v. Bochmann", "F. Khendek", "M. Amalou"], "venue": "IEEE Transactions on Software Engineering,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1991}, {"title": "Javert: Fully automatic mining of general temporal properties from dynamic traces", "author": ["Mark Gabel", "Zhendong Su"], "venue": "In Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering, SIGSOFT \u201908/FSE16,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Online inference and enforcement of temporal properties", "author": ["Mark Gabel", "Zhendong Su"], "venue": "In ICSE,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "A method for the design of fault detection experiments", "author": ["Guney Gonenc"], "venue": "IEEE Trans. Computers,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1970}, {"title": "Information-flow analysis of Android applications in DroidSafe", "author": ["Michael I. Gordon", "Deokhwan Kim", "Jeff Perkins", "Limei Gilham", "Nguyen Nguyen", "Martin Rinard"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Fault detecting experiments for sequential circuits", "author": ["F.C. Hennie"], "venue": "In 5th Annual Symposium on Switching Circuit Theory and Logical Design, Princeton,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1964}, {"title": "Permissive interfaces", "author": ["Thomas A. Henzinger", "Ranjit Jhala", "Rupak Majumdar"], "venue": "In Proceedings of the 10th European Software Engineering Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2005}, {"title": "Race detection for event-driven mobile applications", "author": ["Chun-Hung Hsiao", "Jie Yu", "Satish Narayanasamy", "Ziyun Kong", "Cristiano L. Pereira", "Gilles A. Pokam", "Peter M. Chen", "Jason Flinn"], "venue": "In PLDI,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2014}, {"title": "Domain-specific optimization in automata learning", "author": ["H. Hungar", "O. Niese", "B. Steffen"], "venue": "In CAV,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2003}, {"title": "Static analysis of event-driven node.js javascript applications", "author": ["Magnus Madsen", "Frank Tip", "Ond\u0159ej Lhot\u00e1k"], "venue": "In OOPSLA,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2015}, {"title": "Race detection for android applications", "author": ["Pallavi Maiya", "Aditya Kanade", "Rupak Majumdar"], "venue": "PLDI", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2014}, {"title": "Automatic generation of object usage specifications from large method traces", "author": ["Michael Pradel", "Thomas R. Gross"], "venue": "In ASE,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2009}, {"title": "Inference of finite automata using homing sequences", "author": ["Ronald L. Rivest", "Robert E. Schapire"], "venue": "Inf. Comput.,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1993}, {"title": "A new technique for generating protocol test", "author": ["Krishan K. Sabnani", "Anton T. Dahbura"], "venue": "Proceedings of the Ninth Symposium on Data Communications, British Columbia,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1985}, {"title": "Inferring mealy machines. In FM 2009: Formal Methods, Second World Congress, Eindhoven, The Netherlands, November", "author": ["Muzammil Shahbaz", "Roland Groz"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "A Second Course in Formal Languages and Automata Theory", "author": ["J. Shallit"], "venue": null, "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}, {"title": "Static specification mining using automata-based abstractions", "author": ["Sharon Shoham", "Eran Yahav", "Stephen Fink", "Marco Pistoia"], "venue": "In ISSTA,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2007}, {"title": "Fail fast [software debugging", "author": ["J. Shore"], "venue": "IEEE Software,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2004}, {"title": "Typestate: A programming language concept for enhancing software reliability", "author": ["R. Strom", "S. Yemini"], "venue": "IEEE Trans. Software Eng.,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1986}, {"title": "On the relationship between process algebra and input/output automata", "author": ["Frits W. Vaandrager"], "venue": "In Proceedings of the Sixth Annual Symposium on Logic in Computer Science (LICS \u201991),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1991}, {"title": "Inferring finite-state models with temporal constraints", "author": ["N. Walkinshaw", "K. Bogdanov"], "venue": "In Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2008}, {"title": "Amandroid: A precise and general inter-component data flow analysis framework for security vetting of android apps", "author": ["Fengguo Wei", "Sankardas Roy", "Xinming Ou", "Robby"], "venue": "In SIGSAC,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2014}, {"title": "Automatic extraction of object-oriented component interfaces", "author": ["John Whaley", "Michael C. Martin", "Monica S. Lam"], "venue": "In Proceedings of the 2002 ACM SIGSOFT International Symposium on Software Testing and Analysis,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2002}], "referenceMentions": [{"referenceID": 30, "context": "Typestates [32] were introduced to describe synchronous interfaces that specify order of method calls.", "startOffset": 11, "endOffset": 15}, {"referenceID": 4, "context": "The core algorithm is based on Angluin\u2019s L\u2217 algorithm [5] adapted to Mealy machines [28].", "startOffset": 54, "endOffset": 57}, {"referenceID": 26, "context": "The core algorithm is based on Angluin\u2019s L\u2217 algorithm [5] adapted to Mealy machines [28].", "startOffset": 84, "endOffset": 88}, {"referenceID": 9, "context": "Unfortunately, the equivalence check implemented in this way (as is done in previous algorithms [10,14] for conformance testing) is exponential in k.", "startOffset": 96, "endOffset": 103}, {"referenceID": 12, "context": "Unfortunately, the equivalence check implemented in this way (as is done in previous algorithms [10,14] for conformance testing) is exponential in k.", "startOffset": 96, "endOffset": 103}, {"referenceID": 29, "context": "Such APIs are coded defensively and are fail-fast [31], i.", "startOffset": 50, "endOffset": 54}, {"referenceID": 31, "context": "This assumption is commonly used in ioco-testing frameworks [33].", "startOffset": 60, "endOffset": 64}, {"referenceID": 0, "context": "See [1] for a detailed theoretical discussion of how non-determinism affects learnability.", "startOffset": 4, "endOffset": 7}, {"referenceID": 0, "context": "Using Assumption 1 and 3, we build a synchronous version of an interface in which inputs and outputs strictly alternate following [1].", "startOffset": 130, "endOffset": 133}, {"referenceID": 4, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 0, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 20, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 26, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 4, "context": "For the sake of completeness, we describe the classical L\u2217 learning algorithm by Angluin [5] as adapted to Mealy machines in [28].", "startOffset": 89, "endOffset": 92}, {"referenceID": 26, "context": "For the sake of completeness, we describe the classical L\u2217 learning algorithm by Angluin [5] as adapted to Mealy machines in [28].", "startOffset": 125, "endOffset": 129}, {"referenceID": 24, "context": "For the full description of the choice of suffix, see [26,28].", "startOffset": 54, "endOffset": 61}, {"referenceID": 26, "context": "For the full description of the choice of suffix, see [26,28].", "startOffset": 54, "endOffset": 61}, {"referenceID": 26, "context": "Theorem 1 ([28]).", "startOffset": 11, "endOffset": 15}, {"referenceID": 9, "context": "Popular conformance testing algorithms, like the W-method [10] and the Wpmethod [14], are based on state bounds and have an unavoidable O(|\u03a3\u0303i|State)", "startOffset": 58, "endOffset": 62}, {"referenceID": 12, "context": "Popular conformance testing algorithms, like the W-method [10] and the Wpmethod [14], are based on state bounds and have an unavoidable O(|\u03a3\u0303i|State)", "startOffset": 80, "endOffset": 84}, {"referenceID": 17, "context": "The other common algorithm, the D-method [19,17], does not apply in our setting either.", "startOffset": 41, "endOffset": 48}, {"referenceID": 15, "context": "The other common algorithm, the D-method [19,17], does not apply in our setting either.", "startOffset": 41, "endOffset": 48}, {"referenceID": 25, "context": "For similar reasons, conformance testing algorithms such as the UIO-method [27] do not apply either.", "startOffset": 75, "endOffset": 79}, {"referenceID": 0, "context": "The Query Filter and the Instrumented Alphabet together comprise a Learning Purpose [1], i.", "startOffset": 84, "endOffset": 87}, {"referenceID": 0, "context": "Hence, in such cases, we use the technique of learning purposes [1] to learn a regular approximations of the infinite typestate.", "startOffset": 64, "endOffset": 67}, {"referenceID": 2, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 28, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 3, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 14, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 2, "context": "Static analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30].", "startOffset": 111, "endOffset": 120}, {"referenceID": 18, "context": "Static analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30].", "startOffset": 111, "endOffset": 120}, {"referenceID": 28, "context": "Static analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30].", "startOffset": 111, "endOffset": 120}, {"referenceID": 2, "context": "The work in [3] infers interfaces for Java classes using L\u2217.", "startOffset": 12, "endOffset": 15}, {"referenceID": 3, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 34, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 1, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 10, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 13, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 32, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 23, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 5, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 7, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 8, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 21, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 5, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 7, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 16, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 33, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 11, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 22, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 174, "endOffset": 183}, {"referenceID": 19, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 174, "endOffset": 183}, {"referenceID": 6, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 174, "endOffset": 183}, {"referenceID": 4, "context": "Our work builds on the seminal paper of Angluin [5] and the subsequent extensions and optimizations.", "startOffset": 48, "endOffset": 51}, {"referenceID": 0, "context": "In particular, we build on L\u2217 for I/O automata [1,28].", "startOffset": 47, "endOffset": 53}, {"referenceID": 26, "context": "In particular, we build on L\u2217 for I/O automata [1,28].", "startOffset": 47, "endOffset": 53}, {"referenceID": 24, "context": "The optimizations we use include the counterexample suffix analysis from [26] and the optimizations for prefix-closed languages from [22].", "startOffset": 73, "endOffset": 77}, {"referenceID": 20, "context": "The optimizations we use include the counterexample suffix analysis from [26] and the optimizations for prefix-closed languages from [22].", "startOffset": 133, "endOffset": 137}, {"referenceID": 9, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 12, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 17, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 15, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 25, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}], "year": 2017, "abstractText": "In event-driven programming frameworks, such as Android, the client and the framework interact using callins (framework methods that the client invokes) and callbacks (client methods that the framework invokes). The protocols for interacting with these frameworks can often be described by finite-state machines we dub asynchronous typestates. Asynchronous typestates are akin to classical typestates, with the key difference that their outputs (callbacks) are produced asynchronously. We present an algorithm to infer asynchronous typestates for Android framework classes. It is based on the L\u2217 algorithm that uses membership and equivalence queries. We show how to implement these queries for Android classes. Membership queries are implemented using testing. Under realistic assumptions, equivalence queries can be implemented using membership queries. We provide an improved algorithm for equivalence queries that is better suited for our application than the algorithms from literature. Instead of using a bound on the size of the typestate to be learned, our algorithm uses a distinguisher bound. The distinguisher bound quantifies how two states in the typestate are locally different. We implement our approach and evaluate it empirically. We use our tool, Starling, to learn asynchronous typestates for Android classes both for cases where one is already provided by the documentation, and for cases where the documentation is unclear. The results show that Starling learns asynchronous typestates accurately and efficiently. Additionally, in several cases, the synthesized asynchronous typestates uncovered surprising and undocumented behaviors.", "creator": "TeX"}}}