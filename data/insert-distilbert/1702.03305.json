{"id": "1702.03305", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Feb-2017", "title": "Universal Dependencies to Logical Forms with Negation Scope", "abstract": "many language technology applications would benefit from the ability to represent negation and its scope on my top of both widely - used generic linguistic resources. in this paper, we investigate the possibility emerging of obtaining a first - order logic representation with negation scope marked using universal dependencies. to do so, we enhance udeplambda, a framework that converts dependency graphs to logical symbol forms. the resulting udeplambda $ \\ lnot $ is able to handle phenomena related to scope patterns by means of an higher - order type theory, relevant not only to negation but also to universal quantification and other complex semantic data phenomena. the initial conversion we did for english is promising, in that any one interpreter can represent the scope of negation also in the implied presence of more complex phenomena such as universal quantifiers.", "histories": [["v1", "Fri, 10 Feb 2017 19:16:40 GMT  (27kb)", "http://arxiv.org/abs/1702.03305v1", "This a draft version of the paper. We welcome any comments you may have regarding the content and presentation"]], "COMMENTS": "This a draft version of the paper. We welcome any comments you may have regarding the content and presentation", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["federico fancellu", "siva reddy", "adam lopez", "bonnie webber"], "accepted": false, "id": "1702.03305"}, "pdf": {"name": "1702.03305.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["f.fancellu@sms.ed.ac.uk,", "siva.reddy@ed.ac.uk,", "bonnie}@inf.ed.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 2.\n03 30\n5v 1\n[ cs\n.C L\n] 1\n0 Fe\nb 20 17 D raft\nwould benefit from the ability to represent negation and its scope on top of widelyused linguistic resources. In this paper, we investigate the possibility of obtaining a first-order logic representation with negation scope marked using Universal Dependencies. To do so, we enhance UDepLambda, a framework that converts dependency graphs to logical forms. The resulting UDepLambda\u00ac is able to handle phenomena related to scope by means of an higher-order type theory, relevant not only to negation but also to universal quantification and other complex semantic phenomena. The initial conversion we did for English is promising, in that one can represent the scope of negation also in the presence of more complex phenomena such as universal quantifiers."}, {"heading": "1 Introduction", "text": "Amongst the different challenges around the topic of negation, detecting and representing its scope is one that has been extensively researched in different sub-fields of NLP (e.g. Information Extraction (Velldal et al., 2012; Fancellu et al., 2016)). In particular, recent work have acknowledged the value of representing the scope of negation on top of existing linguistic resources (e.g. AMR \u2013 Bos (2016)). Manually annotating the scope of negation is however a time-consuming process, requiring annotators to have some expertise of formal semantics.\nOur solution to this problem is to automatically convert an available representation that captures negation into a framework that allows a rich variety of semantic phenomena to be represented, in-\nMalta borders no country\nROOT\nNUSBJ NEG\nDOBJ\n(a) UD Dependency Tree\n\u03bbe.\u2203x\u2203y.borders(e) \u2227 country(x) \u2227 no(x)\u2227\nMalta(y) \u2227 arg1(e, y) \u2227 arg2(e, x)\n(b) UDepLambda Logical Form\n\u2200x.country(x) \u2192 \u00ac\u2203e\u2203y.borders(e)\u2227\nMalta(y) \u2227 arg1(e, y) \u2227 arg2(e, x)\n(c) Desired Logical Form\nFigure 1: The dependency tree for \u2018Malta borders no country\u2019 and its logical forms\ncluding scope. That is, given an input sentence, we show how its universal dependency (UD) parse can be converted into a representation in first-order logic (FOL) with lambda terms that captures both predicate\u2013argument relations and scope.\nOur approach is based on UDepLambda\n(Reddy et al., 2017; Reddy et al., 2016), a constraint framework that converts dependency graphs into logical forms, by reducing the lambda expressions assigned to the dependency edges using the lambda expressions of the connected head and child nodes. The edge labels in the input UD graph are only edited minimally so to yield a more fine-grained description on the phenomena they describe, while lexical information is used only for a very restricted class of lexical items, such as negation cues. A FOL representation of the entire input graph can be then obtained by traversing the edges in a given order and combining their semantics.\nHowever, in its original formulation, UDe-\nD raft\npLambda does not handle either universal quantifiers or other scope phenomena. For example, the sentence \u2018Malta borders no country\u2019 has the UD graph shown in Figure 1(a). When compared to the correct representation given in Figure 1(c), the UDepLambda output shown in Figure 1(b) shows the absence of universal quantification, which in turn leads negation scope to be misrepresented.\nFor this reason, we set the foundation of UDepLambda\u00ac (UDepLambda-not), an enhanced version of the original framework, whose type theory allows us to jointly handle negation and universal quantification. Moreover, unlike its predecessor, the logical forms are based on the one used in the \u2018Groeningen Meaning Bank\u2019 (GMB; (Basile et al., 2012)), so to allow future comparison to a manually annotated semantic bank.\nAlthough the present work shows the conversion process for English, given that the edge labels are universal, our framework could be used to explore the problem of representing the scope of negation in the other 40+ languages universal dependencies are available in. This could also address the problem that all existing resources to represent negation scope as a logical form are limited to English (e.g. GMB and \u2018DeepBank\u2019 (Flickinger et al., 2012)) or only to a few other languages (e.g. \u2018The Spanish Resource Grammar\u2019 (Marimon, 2010)).\nIn the reminder of this paper, after introducing the formalism we will be working in (\u00a72), we will work the theory behind some of the conversion rules, from basic verbal negation to some of the more complex phenomena related to negation scope, such as the determiner \u2018no\u2019(\u00a73.1), the interaction between the negation operator and the universal classifier (\u00a73.2) and non-adverbial or lexicalized negation cues such as \u2018nobody\u2019, \u2018nothing\u2019 and \u2018nowhere\u2019 (\u00a73.3). Limitations, where present, will be highlighted.\nContribution. The main contribution of the paper is UDepLambda\u00ac, a UD-to-FOL conversion framework, whose type theory is able to handle scope related phenomena, which we show here in the case of negation.\nFuture work. UDepLambda\u00ac can serve as a basis for further extensions that could apply to other complex semantic phenomena and be learned automatically, given the link to a manually annotated semantic bank."}, {"heading": "NUSBJ", "text": "2 UDepLambda\u00ac\nWe introduce here the foundations of UDepLambda\u00ac, an enhancement to the UDepLambda framework to convert a UD graph into its correspondent logical form. As its predecessor, the conversion takes place in four different steps: enhancement, binarization, substitution and composition. Whereas binarization and composition are the same as UDepLambda, substitution differs in:\n\u2022 using a higher order type-theory to deal with universal quantification, which can interact\nwith other scope operator such as negation;\n\u2022 using FOL expressions based on those used in the Groeningen Meaning Bank (GMB), so\nas to link to a manually\u2013annotated semantic bank which can be leveraged for future work.1\nThe details of the four steps are as follows:\nEnhancement. In this step, we first convert a dependency tree to a dependency graph using existing existing enhancements in UDepLambda. The enhanced dependency labels are represented in red color. In future, we will replace this step with existing enhancements (Schuster and Manning, 2016).\nBinarization. The dependency graph is mapped to a LISP-style s-expression, where the order of the edge traversal is specified. For instance, the expression (nsubj (aux (neg eat not) does) John) indicates that the semantic representation of the sentence in Figure (2) is derived by composing the semantics of the edge nsubj with the logic form of \u2018John\u2019 and of the phrase \u2019does\n1The current study ignores certain aspects of Discourse Representation Theory (Kamp et al., 2011) on which the GMB is based, which are secondary to the issues we are focussed on.\nD raft\nnot eat\u2019. The semantics of the phrase \u2018does not eat\u2019 is in turn derived by composing the edge aux with the phrase \u2018not eat\u2019 and the auxiliary \u2018does\u2019. Finally \u2018not\u2019 and \u2018eat\u2019 are composed along the edge neg.\nThe order of traversal follows an obliqueness hierarchy which defines a strict ordering of the modifiers of a given head traversed during composition. This hierarchy is reminiscent of bottom-up traversal in a binarized constituency tree (where for instance the direct object is always visited before the subject). Furthermore, for a head to be further composed, all its modifiers needs to be composed first. In the sentence in Figure (2), this hierarchy is defined as neg > aux > nusbj, where the semantics of the subject can be applied only when the other modifiers to the verb-head have been already composed.\nSubstitution. The substitution step assigns a lambda expression to each edge and vertex (i.e. word) in the graph. The lambda expressions of the edges are manually crafted to match the semantics of the edge labels while no assumption is made on the semantics of the word-vertices which are always introduced as existentially bound variables. This allows usnot to rely for most part on any language-specific lexical information. These expressions follows recent work on semantic compositionality of complex phenomena in event semantics (Champollion, 2011). In doing this, we generalize our type theory as follows:\n\u2022 Each word-vertex is assigned a semantic type \u3008\u3008v, t\u3009, t\u3009 or \u3008\u3008v, t\u3009, t\u3009 (here shortened in \u3008vt, t\u3009), where v stands for either a paired variable of type Event \u00d7 Individual. This is in contrast with the type assigned to words\nin the original UDepLambda \u3008v, t\u3009. The result of this type-raising operation is clear when we compare the following lambda expressions:\nUDepLambda: \u03bbx.man(xa) UDepLambda\u00ac: \u03bbf.\u2203x.man(xa) \u2227 f(x)\nwhere the \u2018handle\u2019 f allows for complex types to be added inside another lambda expression. Following the GMB, proper nouns are treated like indefinite nouns, being linked to a existentially-bound variable (e.g. John := \u03bbf.\u2203x.named(xa, John, PER) \u2227 f(x)).\n\u2022 Each edge is assigned the semantic type \u3008\u3008vt, t\u3009, \u3008\u3008vt, t\u3009, \u3008vt, t\u3009\u3009\u3009 where we combine a generalized quantifier over the parent word\n(P) with the one over the child word (Q) to return another generalized quantifier (f). For instance, when reducing the sub-expression (nsubj eat John), we first reduce the parent vertex \u2018eat\u2019 (P) and then the child vertex \u2018John\u2019(Q) using the semantics of the subject (\u2018Actor\u2019 in the GMB).\nnsubj:= \u03bbP.\u03bbQ.\u03bbf.P (\u03bbx.f(x) \u2227Q(\u03bby. Actor(xe, ya)))\nWhen compared to the original UDepLambda expression (of type \u3008\u3008v, t\u3009, \u3008\u3008v, t\u3009, \u3008v, t\u3009\u3009\u3009):\n\u03bbf.\u03bbg.\u03bbx.\u2203y.f(xe) \u2227 g(ya) \u2227 arg1(xe, ya)\nunlike its predecessor, UDepLambda\u00ac allows for nested dependencies between parent and child node which is necessary to model scope phenomena.\n\u2022 In cases such as the sub-expression (neg \u2018John does eat\u2019 not), the edge label neg and\nthe word \u2018not\u2019 carry the exact same semantics (i.e. the negation operator \u00ac). For these functional words we try to define semantics on the dependency edges only rather than on the word. As shown below, reducing Q does not impact the semantic composition of the edge neg:\nneg:= \u03bbP.\u03bbQ.\u03bbf.\u00acP (\u03bbx.f(x))\nnot:= \u03bbf.TRUE\nComposition. The lambda expressions are reduced by following the traversal order decided during the binarization step. Let\u2019s exemplify the composition step by showing at the same time how simple verbal negation composes semantically, where the input s-expression is (neg (aux (nsubj eat John) does) not). The substitution step assigns vertices and edges the following semantics:\n\u2018eat\u2019 := \u03bbf.\u2203x.eat(xe) \u2227 f(x) \u2018not\u2019 := \u03bbf.TRUE \u2018John\u2019 := \u03bbf.\u2203x.named(xa, John, PER)\u2227 f(x) \u2018does\u2019 := \u03bbf.TRUE\nnsubj:= \u03bbP.\u03bbQ.\u03bbf.P (\u03bbx.f(x) \u2227Q(\u03bby.Actor(xe, ya))) aux := \u03bbP.\u03bbQ.\u03bbf.P (\u03bbx.f(x)) neg:= \u03bbP.\u03bbQ.\u03bbf.\u00acP (\u03bbx.f(x)) ex-closure:= \u03bbx.TRUE\nwhere the subscripts e and a stands for the event-type and the individual-type existential variable respectively. As for the edge neg, the child of a aux edge is ignored because not contributing to the overall semantics of the sentence.2 We start by reducing (neg eat not), where P is the parent vertex \u2018eat\u2019 and Q the child vertex \u2018not\u2019. This yields the expression:3\n\u03bbf.\u00ac\u2203x.eat(xe) \u2227 f(x)\nWe then use this logic form to first reduce the lambda expression on the edge aux, which outputs the same input representation, and then compose this with the semantics of the edge nsubj. The final representation of the sentence (after we apply existential closure) is as follows:\n\u00ac\u2203x.\u2203y.eat(xe) \u2227 named(ya, John, PER) \u2227 Actor(xe, ya)\nGiven the resulting logical form we consider as part of negation scope all the material under the negation operator \u00ac."}, {"heading": "3 Analysis of negative constructions", "text": ""}, {"heading": "3.1 The quantifier \u2018no\u2019", "text": "Let\u2019s consider the sentence \u2018No man came\u2019 along with its dependency trees and logical form, shown in Figure 3.\nAs shown in Figure 3(b), one shortcoming of the original UDepLambda is that it doesn\u2019t cover universal quantification. However, even if we were to assign any of the following lambda expressions containing material implication to the neg edge connecting parent-\u03bbf (\u2018man\u2019) and child-\u03bbg (\u2018no\u2019):\n?\u03bbf.\u03bbg.\u03bbx.f(x) \u2192 \u00acf(x) ?\u03bbf.\u03bbg.\u03bbx.f(x) \u2192 g(x)\nthe resulting expressions would have no means of later accommodating the event \u2018came\u2019 in the consequent of the material implication:\n*\u03bbx.man(x) \u2192 \u00acman(x) *\u03bbx.man(x) \u2192 no(x)\n2The present work does not consider the semantics of time the word \u2018does\u2019 might contribute to.\n3Step-by-step derivations are shown in Appendix A.\nThe higher-order type theory of UDepLambda\u00ac solves this problem by ensuring that a) there is a universal quantified variable along with material implication and b) the entity bound to it (man(x)) is introduced only in the antecedent, whereas the negated event (along with other arguments) only in the consequent. The lambda expression assigned to the neg edge is the following\n\u03bbP.\u03bbQ.\u03bbf.\u2200x.(P (\u03bby.EQ(x, y)) \u2192 \u00acf(x))\nwhere f allows to leave a \u2018handle\u2019 for the event \u2018came\u2019 to be further composed in the subsequent only, whereas the two-place function EQ(x,y) as argument of P binds the word in the parent node with the universally quantified variable x. It is worth mentioning at this point that although the universal quantifier \u2018no\u2019 is parsed as depending from an edge neg, it possesses a semantics that distinguishes it from other negative adverbs such as \u2018not\u2019 or \u2018never\u2019, in the fact that they bind their head to a universally quantifiable\nD raft\nvariable. In these cases we also enhance the label on the dependency edge to reflect this more fine-grained distinction. In the presence of \u2018no\u2019 the neg edge becomes neg:univ if its child vertex is a universal quantifier. This edit operation relies on having a list of lexical items for both universal quantifiers and negation cues in a language, which is easily obtainable given that these items form a small, closed class.\nA further edit operation is needed to make sure that the quantifier always outscopes the negation operator; to do so, we modify the semantics of the edge that connects the head of the edge neg:univ (\u2018man\u2019) with its parent (\u2018came\u2019), nsubj, by inverting the order of the Q and P, so that the former outscopes the latter. We call this enhanced edge an \u2018edge-name:inv.\u2019 edge. Compared to nsubj, the semantics of nsubj:inv would be as follows:\nnsubj :=\n\u03bbP.\u03bbQ.\u03bbf.P (\u03bbx.f(x) \u2227Q(\u03bby.Actor(xe, ya))) nsubj-inv := \u03bbP.\u03bbQ.\u03bbf.Q(\u03bby.P (\u03bbx.Actor(xe, ya) \u2227 f(x)))\nUsing the edited input UD graph, the hierarchy we follow during composition is neg:univ > nsubj:inv to yield the s-expression (nsubj:inv (neg:univ no man) came). Given the following input semantics:\nman:= \u03bbf.\u2203x.man(xa) \u2227 f(x) came:= \u03bbf.\u2203x.came(xe) \u2227 f(x)\nneg:univ:=\n\u03bbP.\u03bbQ.\u03bbf.\u2200x.(P (\u03bby.EQ(x, y)) \u2192 \u00acf(x)) nsubj:inv :=\n\u03bbP.\u03bbQ.\u03bbf.Q(\u03bby.P (\u03bbx.Actor(xe, ya) \u2227 f(x)))\nwe first reduce the lambda expression on the edge neg:univ. to yield the expression \u03bbf.\u2200x.(man(xa) \u2192 \u00acf(x)) and then combine it along the edge nsubj:inv to yield the following representation:\n\u2200y.(man(ya) \u2192 \u00ac\u2203x.came(xe)\u2227Actor(xe, ya))\n, where the scope of negation is correctly converted as inside the universal quantifier.\nInverting the order of the parent and child nodes in the semantics of the :inv. edge always allows to represent the universally quantified element as outscoping the event it depends on. At the same time, all other arguments and modifiers of the parent event will always compose inside the consequent. This applies to our initial example in Figure 1, where composing the s-expression (dobj:inv. borders \u2018no country\u2019) to yield the expression:\n\u03bbf.\u2200y.(country(ya) \u2192 \u00ac\u2203x.borders(xe) \u2227 Theme(xe, ya) \u2227 f(x))\n, makes sure that further material can only be added in place of f(e), which is inside the scope of \u00ac, in turn in the scope of \u2200. So when composing the semantics of the subject \u2018Malta\u2019 (:= \u03bbf.\u2203x.named(xa,Malta,ORG)\u2227 f(x)), the universal will still have wide-scope, as shown below:\n\u2200y.(country(ya) \u2192 \u00ac\u2203x.\u2203z.named(za,Malta, PER) \u2227\nborders(xez) \u2227 Theme(xe, ya)\u2227Actor(xe, za))"}, {"heading": "3.2 Negation and universal quantifier", "text": "Alongside quantifiers inherently expressing negation, as the one shown in the previous section, another challenging scope representation arises during the interaction between a negation cue and a non-negative universal quantifier, such \u2018every\u2019. Let\u2019s take as example the sentences \u2018Not every man came\u2019, shown in Figure 4 alongside its FOL representation.\nIf compared to the representation of the\nsentence \u2018No man came\u2019, where the universal quantifier outscopes the negation operator, the construction \u2018not every\u2019 yields the opposite interaction where the quantifier is in the scope of \u00ac (correspondent to the meaning \u2018there exists some man who came\u2019).\nAs shown in the previous section and here in Figure 4(b), UDepLambda cannot deal with such constructions, yielding a meaning where there exists and event but there doesn\u2019t exists the entity that performs it. On the other hand, UDepLambda\u00ac can easily derive the correct representation by applying the same edits to the UD graph shown in the previous section. First, we enhance the det edge to become a more finegrained det:univ in the presence of the child node \u2018every\u2019. Second, we change nsubj into nsubj-inv., since a universal quantifier is in its yield. The lambda expression assigned to the edge det:univ is as follows:\ndet:univ:=\u03bbP.\u03bbQ.\u03bbf.\u2200x.(P (\u03bby.EQ(x, y)) \u2192 f(x))\nOnce again, we deploy the usual bottomup binarization hierarchy where all modifiers of a head need to be composed before the head itself can be used for further composition. In the case of \u2018not every...\u2019, we start from the modifiers \u2018every\u2019\nD raft\nand \u2018not\u2019 and compose the edges following the order det:univ \u3009 neg so to make sure that negation operator \u00ac outscopes the universal quantifier \u2200. After the modifiers of the head \u2018man\u2019 are composed, we can then move on to compose the head itself with its governor node, the event \u2018came\u2019. The nsubj:inv. edge ensures that the subject scopes over the event and not the other way around. Following this, we are able to obtain the final representation:\n\u00ac\u2200y.(man(ya) \u2192 \u2203x.came(xe)\u2227Actor(xe, ya))"}, {"heading": "3.3 Nobody/nothing/nowhere", "text": "As shown in Table 1, \u2018nobody\u2019, \u2018nothing\u2019 and \u2018nowhere\u2019 belong to that class of negation cues whose parent edge do not mark them as inherently expressing negation. However using an handcrafted list of negation cues for English, we can detect and assign them the semantic representation \u03bbf.\u00ac\u2203x.thing/person/location(xa)\u2227f(x), where the negation operator scopes over an existentially bound entity.\nBinarization and composition vary according to\nwhether these elements are arguments or adjuncts. If an argument, the scope of negation includes also the event, otherwise the latter is excluded. To this end, let\u2019s compare the sentences \u2018Nobody came\u2019 and \u2018John came with nothing\u2019, along with their dependency graphs and logic forms (Figure 5).\nThe argument \u2018nobody\u2019 in \u2018Nobody came\u2019\nyields a scope reading where the negation operator scopes over the existential. To achieve such reading we once again convert the nsubj (or any argument edge for that matter) into a nsubj:inv. edge. This is reminiscent of how we handled universal quantification when we introduced the quantifier \u2018no\u2019, which is in fact integral part of such lexical elements (the semantics of \u2018no-body came\u2019 can be in fact read as \u2018for all x such that x is a person that x did not come\u2019). Also, the fact that the semantics of these elements is represented through an existential and not a universal bound variable is no problem since we are working under the equivalence \u2200x.P (x) \u2192 \u00acQ(x) \u2261 \u00ac\u2203x.P (x) \u2227Q(x). Given the s-expression (nsubj:inv. came nobody) the composition is then as follows:\n\u00ac\u2203x.\u2203y.person(ya) \u2227 f(x) \u2227Actor(xe, ya) \u2227 came(xe)\nOn the other hand, when the negated lexical element is embedded in an adjunct, as in \u2018with nothing\u2019, no enhancement of the original dependency edges takes place since we want to preserve negation scope inside the phrase (so to yield a reading where the event \u2018John came\u2019 did indeed take place). By substituting and combining the semantics of the s-expression (nmod:with came nothing), where the edge nmod:with is assigned the lambda expression \u03bbP.\u03bbQ.\u03bbf.P (\u03bbx.f(x) \u2227\nD raft\nQ(\u03bby.with(xe, ya))), we obtain the following logic form:\n\u03bbf.\u2203x.came(xe) \u2227 f(x) \u2227 \u00ac\u2203y.(thing(ya) \u2227 with(xe, ya))\n, where we can the scope of negation is limited to the propositional phrase. Given that the f is outside the scope of negation, further compositions (in the case along the edge nsubj.) will also compose outside it, yielding the correct form in Figure (5).\nThe only limitation we have observed so far concerns \u2018nowhere\u2019 (:= \u03bbf.\u2203x.location(xa) \u2227 f(x)) and the fact it is always associated with a dependency tag advmod. The tag advmod describes however the manner an action is carried out and has the logical form \u03bbP.\u03bbQ.\u03bbf.P (\u03bbx.f(x) \u2227 Q(\u03bby.Manner(xe, ya))). This is however different from how \u2018nowhere\u2019 is treated in the Groeningen Meaning Bank, where it is described as where and not how the event takes place. That is, our framework would assign a sentence like \u2018They got nowhere near the money\u2019 the logical form \u2203x.got(xe) \u2227 \u00ac\u2203y.(location(ya) \u2227 Manner(xe, ya)), whereas the one contained in the GMB is: \u2203x.got(xe) \u2227 \u00ac\u2203ya.(location(ya) \u2227 in(xe, ya))"}, {"heading": "4 Conclusion and future work", "text": "This paper addressed the problem of representing negation scope from universal dependencies by setting the foundations of UDepLambda\u00ac, a conversion framework whose high-order type theory is able to deal with complex semantic phenomena related to scope. The conversion processes we presented show that it is possible to rely on dependency edges and additionally to minimal language-dependent lexical information to compose the semantics of negation scope. The fact that this formalism is able to correctly compose the scope for many complex phenomena related to negation scope is promising.\nWe are currently working on extending this\nwork in two directions: 1. Automatic framework evaluation: given the conversion rules presented in this paper, we are planning to automatically convert the UD graphs for the sentences in the GMB so to compare the graph we automatically generate with a goldstandard representation. This would also to identify and quantify the errors of our framework. 2. Automatic semantic parsing: given the connection between this framework and the GMB, we would like to explore the possibility of learning the conversion automatically, so not to rely on an hand-crafted hierarchy to decide the order of edge traversal."}, {"heading": "A Step-by-step \u03bb-reductions", "text": "*Throughout the derivations, we are going to use the variable e in place of xe and z,y or x in place of xa. Due to space restrictions, we skip reduction for existential closure (\u2192ex\u2212clos)."}, {"heading": "A.1 \u2018John does not eat\u2019", "text": "\u03bbP.\u03bbQ.\u03bbf.P (\u03bbe.f(e) \u2227Q(\u03bbx.Actor(e, x)))(\u03bbf.\u2203e.eat(e) \u2227 f(e)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.P (\u03bbe.f(e) \u2227Q(\u03bbx.Actor(e, x)))(\u03bbg.\u2203e\n\u2032 .eat(e\u2032) \u2227 g(e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.\u03bbg.[\u2203e\n\u2032.eat(e\u2032) \u2227 g(e\u2032)](\u03bbe.f(e) \u2227Q(\u03bbx.Actor(e, x))) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.eat(e\u2032) \u2227 \u03bbe.[f(e) \u2227Q(\u03bbx.Actor(e, x))](e\u2032) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.eat(e\u2032) \u2227 f(e\u2032) \u2227Q(\u03bbx.Actor(e\u2032, x)) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.eat(e\u2032) \u2227 f(e\u2032) \u2227Q[\u03bbx.Actor(e\u2032, x)](\u03bbf.\u2203x.named(x, John, PER) \u2227 f(x)) \u2192\u03b1 \u03bbQ.\u03bbf.\u2203e\n\u2032.eat(e\u2032) \u2227 f(e\u2032) \u2227Q[\u03bbx.Actor(e\u2032, x)](\u03bbg.\u2203z.named(z, John, PER) \u2227 g(z)) \u2192\u03b2 \u03bbf.\u2203e\n\u2032.eat(e\u2032) \u2227 f(e\u2032) \u2227 \u03bbg.[\u2203z.named(z, John, PER) \u2227 g(z)](\u03bbx.Actor(e\u2032, x)) \u2192\u03b2 \u03bbf.\u2203e\n\u2032.eat(e\u2032) \u2227 f(e\u2032) \u2227 \u2203z.named(z, John, PER) \u2227 \u03bbx.[Actor(e\u2032, x)](z) \u2192\u03b2 \u03bbf.\u2203e \u2032.eat(e\u2032) \u2227 f(e\u2032) \u2227 \u2203z.named(z, John, PER) \u2227Actor(e\u2032, z)\n\u03bbP.\u03bbQ.\u03bbf.\u00acP (\u03bbe.f(e))(\u03bbf.\u2203e\u2032.\u2203z.eat(e\u2032) \u2227 f(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.\u00acP (\u03bbe.f(e))(\u03bbg.\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 g(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z)) \u2192\u03b2 \u03bbQ.\u03bbf.\u00ac\u03bbg.[\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 g(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z)](\u03bbe.f(e)) \u2192\u03b2 \u03bbQ.\u03bbf.\u00ac\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 \u03bbe.[f(e)](e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z) \u2192\u03b2 \u03bbQ.\u03bbf.\u00ac\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 f(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z) \u2192\u03b2 \u03bbf.\u00ac\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 f(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z) \u2192\u03b2 \u03bbf.[\u00ac\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z) \u2227 f(e\u2032)](\u03bbx.TRUE) \u2192\u03b2 \u00ac\u2203e\n\u2032.\u2203z.eat(e\u2032) \u2227 named(z, John, PER) \u2227Actor(e\u2032, z) \u2227 \u03bbx.[TRUE](e\u2032) \u2192\u03b2 \u00ac\u2203e \u2032.\u2203z.eat(e\u2032) \u2227 named(z,John,PER) \u2227Actor(e\u2032, z)"}, {"heading": "A.2 \u2018No man came\u2019", "text": "\u03bbP.\u03bbQ.\u03bbf.\u2200x.(P (\u03bby.EQ(x, y)) \u2192 \u00acf(x))(\u03bbf.\u2203x.man(x) \u2227 f(x)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.\u2200x.(P (\u03bby.EQ(x, y)) \u2192 \u00acf(x))(\u03bbf\n\u2032.\u2203z.man(z) \u2227 f \u2032(z)) \u2192\u03b2 \u03bbQ.\u03bbf.\u2200x.(\u03bbf\n\u2032.[\u2203z.man(z) \u2227 f \u2032(z)](\u03bby.EQ(x, y)) \u2192 \u00acf(x)) \u2192\u03b2 \u03bbQ.\u03bbf.\u2200x.(\u2203z.man(z) \u2227 \u03bby.[EQ(x, y)](z) \u2192 \u00acf(x)) \u2192\u03b2 \u03bbQ.\u03bbf.\u2200x.(\u2203z.man(z) \u2227 EQ(x, z) \u2192 \u00acf(x)) \u2192EQ \u03bbQ.\u03bbf.\u2200x.(man(x) \u2192 \u00acf(x)) \u2192\u03b2 \u03bbf.\u2200x.(man(x) \u2192 \u00acf(x))\n\u03bbP.\u03bbQ.\u03bbf.Q(\u03bbx.P (\u03bbe.Actor(e, x) \u2227 f(e)))(\u03bbf.\u2203e.came(e) \u2227 f(e)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.Q(\u03bbx.P (\u03bbe.Actor(e, x) \u2227 f(e)))(\u03bbg.\u2203e\n\u2032.came(e\u2032) \u2227 g(e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u03bbg.[\u2203e\n\u2032.came(e\u2032) \u2227 g(e\u2032))](\u03bbe.Actor(e, x) \u2227 f(e))) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\n\u2032.came(e\u2032) \u2227 \u03bbe.[Actor(e, x) \u2227 f(e)](e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\n\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032)) \u2192\u03b1 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\n\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032))(\u03bbf \u2032.\u2200x\u2032.(man(x\u2032) \u2192 \u00acf \u2032(x\u2032)) \u2192\u03b2 \u03bbf.\u03bbf\n\u2032.[\u2200x\u2032.(man(x\u2032) \u2192 \u00acf \u2032(x\u2032))](\u03bbx.\u2203e\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032)) \u2192\u03b2 \u03bbf.\u2200x\n\u2032.(man(x\u2032) \u2192 \u00ac\u03bbx.[\u2203e\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032)](x\u2032)) \u2192\u03b2 \u03bbf.\u2200x\n\u2032.(man(x\u2032) \u2192 \u00ac\u2203e\u2032.came(e\u2032) \u2227Actor(e\u2032, x\u2032) \u2227 f(e\u2032)) \u2192ex\u2212clos. \u2200x \u2032.(man(x\u2032) \u2192 \u00ac\u2203e\u2032.came(e\u2032) \u2227Actor(e\u2032,x\u2032))"}, {"heading": "A.3 \u2018Not every man came\u2019", "text": "\u2192\u2200 \u03bbf.\u2200x.(man(x) \u2192 f(x)) \u2192\u00ac \u03bbf.\u00ac\u2200z.(man(z) \u2192 f(z))\n\u03bbP.\u03bbQ.\u03bbf.Q(\u03bbx.P (\u03bbe.Actor(e, x) \u2227 f(e)))(\u03bbf.\u2203e.came(e) \u2227 f(e))\nD raft\n\u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.Q(\u03bbx.P (\u03bbe.Actor(e, x) \u2227 f(e)))(\u03bbg.\u2203e \u2032.came(e\u2032) \u2227 g(e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u03bbg.[\u2203e \u2032.came(e\u2032) \u2227 g(e\u2032))](\u03bbe.Actor(e, x) \u2227 f(e))) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e \u2032.came(e\u2032) \u2227 \u03bbe.[Actor(e, x) \u2227 f(e)](e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e \u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032))\n\u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032))(\u03bbf.\u00ac\u2200z.(man(z) \u2192 f(z)) \u2192\u03b1 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\n\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032))(\u03bbf \u2032.\u00ac\u2200z.(man(z) \u2192 f \u2032(z)) \u2192\u03b2 \u03bbf.\u03bbf\n\u2032.[\u00ac\u2200z.(man(z) \u2192 f \u2032(z))](\u03bbx.\u2203e\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032)) \u2192\u03b2 \u03bbf.\u00ac\u2200z.(man(z) \u2192 \u03bbx.[\u2203e\n\u2032.came(e\u2032) \u2227Actor(e\u2032, x) \u2227 f(e\u2032)](z)) \u2192\u03b2 \u03bbf.\u00ac\u2200z.(man(z) \u2192 \u2203e\n\u2032.came(e\u2032) \u2227Actor(e\u2032, z) \u2227 f(e\u2032)) \u2192ex\u2212clos. \u00ac\u2200z.(man(z) \u2192 \u2203e \u2032.came(e\u2032) \u2227Actor(e\u2032, z))"}, {"heading": "A.4 \u2018Nobody came\u2019", "text": "\u03bbP.\u03bbQ.\u03bbf.Q(\u03bbx.P (\u03bbe.f(e) \u2227Actor(e, x)))(\u03bbf.\u2203e.f(e) \u2227 came(e)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.Q(\u03bbx.P (\u03bbe.f(e) \u2227Actor(e, x)))(\u03bbg.\u2203e\n\u2032 .g(e\u2032) \u2227 came(e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u03bbg.[\u2203e\n\u2032.g(e\u2032) \u2227 came(e\u2032)](\u03bbe.f(e) \u2227Actor(e, x))) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\n\u2032.\u03bbe.[f(e) \u2227Actor(e, x)](e\u2032) \u2227 came(e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e \u2032.f(e\u2032) \u2227Actor(e\u2032, x) \u2227 came(e\u2032))\n\u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\u2032.f(e\u2032) \u2227Actor(e\u2032, x) \u2227 came(e\u2032))(\u03bbf.\u00ac\u2203x.person(x) \u2227 f(x)) \u2192\u03b1 \u03bbQ.\u03bbf.Q(\u03bbx.\u2203e\n\u2032.f(e\u2032) \u2227Actor(e\u2032, x) \u2227 came(e\u2032))(\u03bbg.\u00ac\u2203z.person(z) \u2227 g(z)) \u2192\u03b2 \u03bbf.\u03bbg.[\u00ac\u2203z.person(z) \u2227 g(z)](\u03bbx.\u2203e\n\u2032.f(e\u2032) \u2227Actor(e\u2032, x) \u2227 came(e\u2032)) \u2192\u03b2 \u03bbf.\u00ac\u2203z.person(z) \u2227 \u03bbx.[\u2203e\n\u2032.f(e\u2032) \u2227Actor(e\u2032, x) \u2227 came(e\u2032)](z) \u2192\u03b2 \u03bbf.\u00ac\u2203z.\u2203e\n\u2032.person(z) \u2227 f(e\u2032) \u2227Actor(e\u2032, z) \u2227 came(e\u2032) \u2192ex\u2212clos. \u00ac\u2203z.\u2203e \u2032.person(z) \u2227Actor(e\u2032, z) \u2227 came(e\u2032)"}, {"heading": "A.5 \u2018John came with nothing\u2019", "text": "\u03bbP.\u03bbQ.\u03bbf.P (\u03bbe.f(e) \u2227Q(\u03bbx.with(e, x)))(\u03bbf.\u2203e.came(e) \u2227 f(e)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.P (\u03bbe.f(e) \u2227Q(\u03bbx.with(e, x)))(\u03bbg.\u2203e\n\u2032 .came(e\u2032) \u2227 g(e\u2032)) \u2192\u03b2 \u03bbQ.\u03bbf.\u03bbg.[\u2203e\n\u2032.came(e\u2032) \u2227 g(e\u2032)](\u03bbe.f(e) \u2227Q(\u03bbx.with(e, x))) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u03bbe.[Q(\u03bbx.with(e, x))](e\u2032) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227Q(\u03bbx.with(e\u2032, x)) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227Q[\u03bbx.with(e\u2032, x)](\u03bbf.\u00ac\u2203x.thing(x) \u2227 f(x)) \u2192\u03b1 \u03bbQ.\u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227Q[\u03bbx.with(e\u2032, x)](\u03bbg.\u00ac\u2203z.thing(z) \u2227 g(z)) \u2192\u03b2 \u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u03bbg.[\u00ac\u2203z.thing(z) \u2227 g(z)](\u03bbx.with(e\u2032 , x)) \u2192\u03b2 \u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u00ac\u2203z.thing(z) \u2227 \u03bbx.[with(e\u2032, x)](z) \u2192\u03b2 \u03bbf.\u2203e \u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u00ac\u2203z.thing(z) \u2227 with(e\u2032, z)\n\u03bbP.\u03bbQ.\u03bbf.P (\u03bbe.f(e) \u2227Q(\u03bbx.Actor(e, x)))(\u03bbf.\u2203e\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u00ac\u2203z.thing(z) \u2227 with(e\u2032, z)) \u2192\u03b1 \u03bbP.\u03bbQ.\u03bbf.P (\u03bbe.f(e)\u2227Q(\u03bbx.Actor(e, x)))(\u03bbg.\u2203e\n\u2032.came(e\u2032)\u2227g(e\u2032)\u2227\u00ac\u2203z.thing(z)\u2227with(e\u2032, z)) \u2192\u03b2 \u03bbQ.\u03bbf.\u03bbg.[\u2203e\n\u2032.came(e\u2032) \u2227 g(e\u2032) \u2227 \u00ac\u2203z.thing(z) \u2227 with(e\u2032, z)](\u03bbe.f(e) \u2227Q(\u03bbx.Actor(e, x))) \u2192\u03b2 \u03bbQ.\u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 \u03bbe.[f(e) \u2227Q(\u03bbx.Actor(e, x))](e\u2032) \u2227 \u00ac\u2203z.thing(z) \u2227 with(e\u2032, z) \u2192\u03b2 \u03bbQ.[\u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227Q(\u03bbx.Actor(e\u2032, x)) \u2227 \u00ac\u2203z.thing(z) \u2227 with(e\u2032, z)] (\u03bbg.\u2203y.named(y, John, PER) \u2227 g(y)) \u2192\u03b2 \u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u03bbg.[\u2203y.named(y, John, PER) \u2227 g(y)](\u03bbx.Actor(e\u2032, x)) \u2227 \u00ac\u2203z.thing(z) \u2227with(e\u2032, z)] \u2192\u03b2 \u03bbf.\u2203e\n\u2032.came(e\u2032) \u2227 f(e\u2032) \u2227 \u2203y.named(y, John, PER) \u2227 \u03bbx.[Actor(e\u2032, x)](y) \u2227 \u00ac\u2203z.thing(z) \u2227 with(e\u2032, z) \u2192\u03b2 \u03bbf.\u2203e\n\u2032.came(e\u2032)\u2227\u2203y.named(y, John, PER)\u2227f(e\u2032)\u2227Actor(e\u2032, y)\u2227\u00ac\u2203z.thing(z)\u2227with(e\u2032 , z) \u2192ex\u2212clos. \u2203e \u2032.\u2203y.came(e\u2032) \u2227 named(y,John,PER) \u2227Actor(e\u2032,y) \u2227 \u00ac\u2203z.thing(z) \u2227with(e\u2032, z)"}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "Many language technology applications would benefit from the ability to represent negation and its scope on top of widelyused linguistic resources. In this paper, we investigate the possibility of obtaining a first-order logic representation with negation scope marked using Universal Dependencies. To do so, we enhance UDepLambda, a framework that converts dependency graphs to logical forms. The resulting UDepLambda\u00ac is able to handle phenomena related to scope by means of an higher-order type theory, relevant not only to negation but also to universal quantification and other complex semantic phenomena. The initial conversion we did for English is promising, in that one can represent the scope of negation also in the presence of more complex phenomena such as universal quantifiers.", "creator": "dvips(k) 5.996 Copyright 2016 Radical Eye Software"}}}