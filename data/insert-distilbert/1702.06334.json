{"id": "1702.06334", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Feb-2017", "title": "Synthesizing Imperative Programs from Examples Guided by Static Analysis", "abstract": "we present a novel algorithm problem that synthesizes imperative software programs for introductory programming courses. given a set of input - output examples and a partial program, our algorithm generates a complete program that is consistent with every example. our key idea is to combine enumerative program synthesis and static analysis, which aggressively prunes carry out a large search space while guaranteeing to find, if any, a correct solution. though we collectively have historically implemented our algorithm in composing a tool, called simpl, and evaluated as it on 30 problems used in introductory programming courses. the results show that simpl is able to solve absolutely the benchmark problems in 6. 6 seconds on on average.", "histories": [["v1", "Tue, 21 Feb 2017 11:29:28 GMT  (35kb)", "https://arxiv.org/abs/1702.06334v1", null], ["v2", "Tue, 13 Jun 2017 09:13:33 GMT  (35kb)", "http://arxiv.org/abs/1702.06334v2", "The paper is accepted in Static Analysis Symposium (SAS) '17. The submission version is somewhat different from the version in arxiv. The final version will be uploaded after the camera-ready version is ready"]], "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["sunbeom so", "hakjoo oh"], "accepted": false, "id": "1702.06334"}, "pdf": {"name": "1702.06334.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["so@korea.ac.kr", "oh@korea.ac.kr"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 2.\n06 33\n4v 2\n[ cs\n.P L\n] 1\n3 Ju\nn 20"}, {"heading": "1 Introduction", "text": "Our long-term goal is to build an intelligent tutoring system that helps students to improve their programming skills. Our experience in introductory programming courses is that students, who learn programming for the first time, often struggle with solving programming problems for themselves. Manually providing guidance simply does not scale for the increasingly large number of students. To make matters worse, we found that even instructors sometimes make mistake and shy students are reluctant to ask questions. Motivated by this experience, we aim to build an automatic system that helps students to improve their skills without human teachers. In this paper, we present a key component of the system, which automatically generates complete programs from students\u2019 incomplete programs. The inputs of the algorithm are a partial program with constraints on variables and constants, and input-output examples that specify the program\u2019s behavior. The output is a complete program whose behavior matches all of the given input-output examples. The key novelty of our algorithm is to combine enumerative program synthesis and program analysis techniques. It basically enumerates every possible candidate program in increasing size until it finds a solution. This algorithm, however, is too slow to be interactively used with students due to the huge search space of programs. Our key idea to accelerate the speed is to perform static analysis alongside the enumerative search, in order to \u201cstatically\u201d identify and prune\nout interim programs that eventually fail to be a solution. We formalize our pruning technique and its safety property.\nThe experimental results show that our algorithm is remarkably effective to synthesize introductory imperative programs. We have implemented the algorithm in a tool, SIMPL, and evaluated its performance on 30 programming tasks used in introductory courses. With our pruning technique, SIMPL is fast enough to solve each problem in 6.6 seconds on average. However, without the pruning, the baseline algorithm, which already adopts well-known optimization techniques, takes 165.5 seconds (25x slowdown) on average.\nWe summarize our contributions below:\n\u2022 We present a new algorithm for synthesizing imperative programs from examples. To our knowledge, our work is the first to combine enumerative program synthesis and static analysis technologies.\n\u2022 We prove the effectiveness of our algorithm on 30 real programming problems used in introductory courses. The results show that our algorithm quickly solves the problems, including ones that most beginner-level students have hard times to solve.\n\u2022 We provide a tool, SIMPL, which is publicly available and open-sourced.1"}, {"heading": "2 Showcase", "text": "In this section, we showcase SIMPL with four programming problems that most beginners feel difficult to solve. To use SIMPL, students need to provide (1) a partial program, (2) a set of input-output examples, and (3) resources that SIMPL can use. The resources consist of a set of integers, a set of integer-type variables, and a set of array-type variables. The goal of SIMPL is to complete the partial program w.r.t. the input-output examples, using only the given resources.\nProblem 1 (Reversing integer) The first problem is to write a function that reverses a given integer. For example, given integer 12, the function should return 21. Suppose a partial program is given as\nreverse (n){ r := 0; while(?){?}; return r;}\n1Hidden for double-blind reviewing.\nreverse(n){\nr := 0;\nwhile ( n > 0 ){\nx := n % 10; r := r * 10; r := r + x; n := n / 10;\n}; return r;\n}\ncount(n,a){\nwhile ( n > 0 ){\nt := n % 10; a[t] := a[t] + 1; n := n / 10;\n}; return a;\n}\n(a) Problem1 (b) Problem 2\nwhere ? denotes holes that need to be completed. Suppose further SIMPL is provided with input-output examples {1 7\u2192 1, 12 7\u2192 21, 123 7\u2192 321}, integers {0, 1, 10}, and integer variables {n,r,x}. Given this problem, SIMPL produces the solution in Figure 1(a) in 2.5 seconds. Note that, SIMPL finds out that the integer \u20181\u2019 is unnecessary and the final program does not contain it. Also, SIMPL does not require sophisticated examples, so that SIMPL can be easily used by inexperienced students.\nProblem 2 (Counting) The next problem is to write a function that counts the number of each digit in an integer. The program takes an integer and an array as inputs, where each element of the array is initially 0. As output, the program returns that array but now each array element at index i stores the number of is that occur in the given integer. For example, when a tuple (220, \u30080, 0, 0\u3009) is given, the function should output \u30081, 0, 2\u3009; 0 occurs once, 1 does not occur, and 2 occurs twice in \u2018220\u2019. Suppose the partial program is given as\ncount(n,a){ while(?){?}; return a;}\nwith examples {(11, \u30080, 0\u3009) 7\u2192 \u30080, 2\u3009, (220, \u30080, 0, 0\u3009) 7\u2192 \u30081, 0, 2\u3009}, integers {0, 1, 10}, integer variables {i,n,t}, and an array variable {a}. For this problem, SIMPL produces the program in Figure 1(b) in 0.2 seconds. Note that SIMPL uses a minimal set of resources; i is not used though it is given as usable.\nProblem 3 (Sum of sum) The third problem is to compute 1 + (1 + 2) + ... + (1 + 2 + ... + n) for a given integer n. Suppose the partial program\nsum(n){ r := 0; while(?){?}; return r;}\nis given with examples {1 7\u2192 1, 2 7\u2192 4, 3 7\u2192 10, 4 7\u2192 20}, integers {0, 1}, and integer-type variables {n,t,r}. Then, SIMPL produces the program in Figure 1(c) in 37.6 seconds. Note that SIMPL newly introduced a nested loop, which is absent in the partial program.\nProblem 4 (Absolute sum) The last problem is to sum the absolute values of all the elements in a given array. We provide the partial program:\nabssum(a, len){ r := 0; i := 0;\nwhile(i < len){ if(?){?} else{?}; i:=i+1;};\nreturn r;}\nwhere the goal is to complete the condition and bodies of the if-statement. Given a set of input-output examples {(\u3008\u22121,\u22122\u3009, 2) 7\u2192 3, (\u30082, 3,\u22124\u3009, 3) 7\u2192 9}, an integer {0}, integer variables {r,i}, and an array variable {a}, SIMPL produces the program in Figure 1(d) in 12.1 seconds."}, {"heading": "3 Problem Definition", "text": "Language We designed an imperative language that is small yet expressive enough to deal with various programming problems in introductory courses. The syntax of the language is defined by the following grammar:\n\u2295 \u2192 + | \u2212 | \u2217 | / | %, \u227a\u2192 =|>|<\nl \u2192 x | x[y], a \u2192 n | l | l1 \u2295 l2 | l \u2295 n | \u2666 b \u2192 true | false | l1 \u227a l2 | l \u227a n | b1 \u2227 b2 | b1 \u2228 b2 | \u00acb | \u25b3 c \u2192 l := a | skip | c1; c2 | if b c1 c2 | while b c |\nAn l-value (l) is a variable (x) or an array reference (x[y]). An arithmetic expression (a) is an integer constant (n), an l-value (l), or a binary operation (\u2295). A boolean expression (b) is a boolean constant (true, false), a binary relation (\u227a), a negation (\u00acb), or a logical conjunction (\u2227) and disjunction (\u2228). Commands include assignment (l := a), skip (skip), sequence (c1; c2), conditional statement (if b c1 c2), and whileloop (while b c). A program P = (x, c, y) is a command with input and output variables, where x is the input variable, c is the command, and y is the output variable. The input and output variables x and y can be either of integer or array types. For presentation brevity, we assume that the program takes a single input, but our implementation supports multiple input variables as well. An unusual feature of the language is that it allows to write incomplete programs. Whenever uncertain, any arithmetic expressions, boolean expressions, and commands can be left out with holes (\u2666,\u25b3, ). The goal of our synthesis algorithm is to automatically complete such partial programs. The semantics of the language is defined for programs without holes. Let X be the set of program variables, which is partitioned into integer and array types, i.e., X = Xi \u228eXa . A memory state\nm \u2208 M = X \u2192 V, v \u2208 V = Z+ Z\u2217\nis a partial function from variables to values (V). A value is either an integer or an array of integers. An array a \u2208 Z\u2217 is a sequence of integers. For instance, we write \u30081, 2, 3\u3009\nfor the array of integers 1, 2, and 3. We write |a|, ai, and aki for the length of a, the element at index i, and the array a0 . . . ai\u22121kai+1 . . . a|a|\u22121, respectively. The semantics of the language is defined by the functions:\nA[[a]] : M \u2192 V, B[[b]] : M \u2192 B, C[[c]] : M \u2192 M\nwhere A[[a]], B[[b]], and C[[c]] denote the semantics of arithmetic expressions, boolean expressions, and commands, respectively. Figure 2 presents the denotational semantics, where fix is a fixed point operator. Note that the semantics for holes is undefined.\nSynthesis Problem A synthesis task is defined by the five components:\n((x, c, y), E ,\u0393,Xi ,Xa)\nwhere (x, c, y) is an incomplete program with holes, E \u2286 V \u00d7 V is a set of input-output examples. \u0393 \u2286 Z is a set of integers, Xi is a set of integer-type variables, and Xa is a set of array-type variables. The goal of our synthesis algorithm is to produce a complete command c without holes such that\n\u2022 c uses constants and variables in \u0393 and Xi \u222a Xa , and\n\u2022 c is consistent with every input-output example:\n\u2200(vi, vo) \u2208 E . ( C[[c]]([x 7\u2192 vi]) ) (y) = vo."}, {"heading": "4 Synthesis Algorithm", "text": "In this section, we present our synthesis algorithm that combines enumerative search with static analysis."}, {"heading": "4.1 Synthesis as State-Search", "text": "We first reduce the synthesis task into a state-search problem. Consider a synthesis task ((x, c, y), E ,\u0393,Xi ,Xa). The corresponding search problem is defined by the transition system (S,\u2192, s0, F ) where S is a set of states, (\u2192) \u2286 S \u00d7 S is a transition relation, s0 \u2208 S is an initial state, and F \u2286 S is a set of solution states.\nAlgorithm 1 Synthesis Algorithm\nInput: A synthesis problem ((x, c0, r), E ,\u0393,Xi ,Xa ) Output: A complete program consistent with E 1: W \u2190 {c0} 2: repeat 3: Pick the smallest state s fromW 4: if s is a terminal state then 5: if solution(s) then return s 6: else 7: if \u00acprune(s) then W \u2190 W \u222a next(s)\n8: until W 6= \u2205\n\u2022 States : A state s \u2208 S is a command possibly with holes, which is defined by the grammar in Section 3.\n\u2022 Initial state : An initial state s0 is a partial command c0.\n\u2022 Transition relation : Transition relation (\u2192) \u2286 S \u00d7 S determines the state that is immediately reachable from a state. The relation is defined as a set of inference rules in Figure 3. Intuitively, a hole can be replaced by an arbitrary expression (or command) of the same type. Given a state s, we write next(s) for the set of all immediate next states, i.e., next(s) = {s\u2032 | s \u2192 s\u2032}. We write s 6\u2192 for terminal states, i.e., states with no holes.\n\u2022 Solution states : A state s is a solution iff s is a terminal state and it is consistent with all input-output examples:\nsolution(s) \u21d0\u21d2 s 6\u2192 \u2227 \u2200(vi, vo) \u2208 E . ( C[[s]]([x 7\u2192 vi]) ) (y) = vo."}, {"heading": "4.2 Baseline Search Algorithm", "text": "Algorithm 1 shows the basic architecture of our enumerative search algorithm. The algorithm initializes the workset W with c0 (line 1). Then, it picks a state s with the smallest size and removes the state from the workset (line 3). If s is a solution state, the algorithm terminates and s is returned (line 5). For a non-terminal state, the algorithm attempts to prune the state by invoking the function prune (line 7). If pruning fails, the next states of s are added into the workset and the loop repeats. The details of our pruning technique is described in Section 4.3. At the moment, assume prune always fails. The baseline algorithm implicitly performs two wellknown optimization techniques. First, it maintains previously explored states and never reconsider them. Second, more importantly, it normalizes states so that semantically-equivalent programs are also syntactically the same. For instance, suppose (r := 0; r := x \u2217 0; ) is the current state. Before pushing it to the workset, we first normalize it to (r := 0; ). To do so, we use four code optimization techniques: constant propagation, copy propagation, dead code elimination, and expression simplification [Aho et al., 1986]. These two techniques significantly improve the speed of enumerative search. In addition, the algorithm considers terminating programs only. Our language has unrestricted loops, so the basic algorithm may synthesize non-terminating programs. To exclude them from the search space, we use syntactic heuristics to detect potentially non-terminating loops. The heuristics are: 1)\nwe only allow boolean expressions of the form x < y (or x > n) in loop conditions, 2) the last statement of the loop bodymust increase (or decrease) the induction variable x, and 3) x and y are not defined elsewhere in the loop."}, {"heading": "4.3 Pruning with Static Analysis", "text": "Now we present the main contribution of this paper, pruning with static analysis. Static analysis allows to safely identify states that eventually fail to be a solution. We first define the notion of failure states.\nDefinition 1. A state s is a failure state, denoted fail(s), iff every terminal state s\u2032 reachable from s is not a solution, i.e.,\nfail(s) \u21d0\u21d2 ((s \u2192\u2217 s\u2032) \u2227 s\u2032 6\u2192 =\u21d2 \u00acsolution(s\u2032)).\nOur goal is to detect as many failure states as possible. We observed two typical cases of failure states that often show up during the baseline search algorithm.\nExample 1. Consider the program in Figure 4(a) and inputoutput example (1, 1). When the program is executed with n = 1, no matter how the hole (\u2666) gets instantiated, the output value r is no less than 2 at the return statement. Therefore, the program cannot but fail to satisfy the example (1, 1).\nExample 2. Consider the program in Figure 4(b) and inputoutput example (1, 1). Here, we do not know the exact values of x and r, but we know that 10 \u2217 x = 1 must hold at the end of the program. However, there exists no such integer x, and we conclude the partial program is a failure state.\nStatic Analysis We designed a static analysis that aims to effectively identify these two types of failure states. To do so, our analysis combines numeric and symbolic analyses; the numeric analysis is designed to detect the cases of Example 1\nand the symbolic analysis for the cases of Example 2. The abstract domain of the analysis is defined as follows:\nm\u0302 \u2208 M\u0302 = X \u2192 V\u0302, v\u0302 \u2208 V\u0302 = I\u00d7 S\nAn abstract memory state m\u0302 maps variables to abstract\nvalues (V\u0302). An abstract value is a pair of intervals (I) and symbolic values (S). The domain of intervals is standard [Cousot and Cousot, 1977]:\nI = ({\u22a5} \u222a {[l, u] | l, u \u2208 Z \u222a {\u2212\u221e,+\u221e}\u2227 l \u2264 u},\u2291I).\nFor symbolic analysis, we define the following flat domain:\nS = (SE\u22a4\u22a5,\u2291S) where SE \u2192 n | \u03b2x (x \u2208 Xi) | SE\u2295 SE\nA symbolic expression se \u2208 SE is a constant (n), a symbol (\u03b2x), or a binary operation with symbolic expressions. We introduce symbols one for each integer-type variable in the program. The symbolic domain is flat and has the partial order: s1 \u2291S s2 \u21d0\u21d2 (s1 = \u22a5) \u2228 (s1 = s2) \u2228 (s2 = \u22a4). We define the abstraction function \u03b1 : V \u2192 V\u0302 that transforms concrete values to abstract values:\n\u03b1(n) = ([n, n], n) \u03b1(n1 . . . nk) = ([min{n1, . . . , nk},max{n1, . . . , nk}],\u22a4).\nThe abstract semantics is defined in Figure 5 by the functions:\nA\u0302[[a]] : M\u0302 \u2192 V\u0302, B\u0302[[b]] : M\u0302 \u2192 B\u0302, C\u0302[[c]] : M\u0302 \u2192 M\u0302\nwhere B\u0302 = {t\u0302rue, f\u0302alse}\u22a4\u22a5 is the abstract boolean lattice. Intuitively, the abstract semantics over-approximates the concrete semantics of all terminal states that are reachable from the current state. This is done by defining the sound\nsemantics for holes: A\u0302[[\u2666]](m\u0302), B\u0302[[\u25b3]](m\u0302), and C\u0302[[ ]](m\u0302). An exception is that integer variables get assigned symbols, rather than \u22a4, in order to generate symbolic constraints on integer variables. In our analysis, array elements are abstracted into a single\nelement. Hence, the definitions of A\u0302[[x[y]]] and C\u0302[[x[y] := a]] do not involve y. Because an abstract array cell may represent multiple concrete cells, arrays are weakly updated by joining (\u2294) old and new values. For example, in memory state m\u0302 =\n[x 7\u2192 ([5, 5],\u22a4), ...], C\u0302[[x[y] := 1]](m\u0302) evaluates to [x 7\u2192 ([1, 5],\u22a4), ...]. For while-loops, the analysis performs a sound fixed point computation. If the computation does not reach a fixed point after a fixed number of iterations, we apply widening for\ninfinite interval domain, in order to guarantee the termination of the analysis. We use the standard widening operator\nin [Cousot and Cousot, 1977]. The function fi\u0302x and c\u0302ond in Figure 5 denote a post-fixed point operator and a sound abstraction of cond, respectively.\nPruning Next we describe how we do pruning with the static analysis. Suppose we are given examples E \u2286 V \u00d7 V and a state s with input (x) and output (y) variables. For each example (vi, vo) \u2208 E , we first run the static analysis with the input \u03b1(vi) and obtain the analysis result (itvs, ses) :\n(itvs, ses) = (C\u0302[[s]]([x 7\u2192 \u03b1(vi)])(y).\nWe only consider the case when itvs = [ls, us] (when itvs = \u22a5, the program is semantically ill-formed and therefore we just prune out the state). Then, we obtain the interval abstraction [lo, uo] of the output vo, i.e., ([lo, uo],\u2212) = \u03b1(vo), and generate the constraints Cs(vi,vo):\nCs(vi,vo) = (ls \u2264 lo \u2227 uo \u2264 us) \u2227 (se \u2208 SE =\u21d2 lo \u2264 se \u2264 uo).\nThe first (resp., second) conjunct means that the interval (resp., symbolic) analysis result must over-approximate the output example. We prune out a state s iff Cs(vi,vo) is unsatisfiable for some example (vi, vo) \u2208 E :\nDefinition 2. The predicate prune is defined as follows:\nprune(s) \u21d0\u21d2 Cs(vi,vo) is unsatisfiable for some (vi, vo) \u2208 E .\nThe unsatisfiability can be easily checked, for instance, with an off-the-shelf SMT solver. Our pruning is safe:\nTheorem 1 (Safety). \u2200s \u2208 S. prune(s) =\u21d2 fail(s).\nThat is, we prune out a state only when it is a failure state, which formally guarantees that the search algorithm with our pruning finds a solution if and only if the baseline algorithm (Section 4.2) does so."}, {"heading": "5 Evaluation", "text": "Experimental setup To evaluate our synthesis algorithm, we gathered 30 introductory level problems from several online forums (Table 1).2 The problems consist of tasks manipulating integers and arrays. Some problems are non-trivial for novice students to solve; they require students to come up with various control structures such as nested loops and combinations of loops and conditional statements. The partial programs we used are similar to those shown in Section 2; they have one boolean expression hole (\u25b3), and one or two command holes ( ). For each benchmark, we report the number of integer variables (IVars), array variables (AVars), integer constants (Ints), and examples (Exs) provided, respectively. All benchmark problems are publicly available with our tool. Experiments were conducted on MacBook Pro with Intel Core i7 and 16GB of memory. Baseline Algorithm Table 1 shows the performance of our algorithm. The column \u201cBase\u201d shows the running time of our baseline algorithm that performs enumerative search without state normalization. In that case, the average runtime was longer than 616 seconds, and three of the benchmarks timed out (> 1 hour). The column \u201cBase+Opt\u201d reports the performance of the baseline with normalization. It shows that normalizing states succeeds to solve all benchmark problems and improves the speed by more than 3.7 times on average, although it degrades the speed for some cases due to runtime normalization overhead. Pruning Effectiveness On top of \u201cBase+Opt\u201d, we applied our static-analysis-guided pruning technique (the column \u201cOurs\u201d). The results show that our pruning technique is remarkably effective. It reduces the average time to 6.6 seconds, improving the speed of \u201cBase+Opt\u201d by 25 times. Note that SIMPL is able to synthesize the desired programs from a few examples (Exs), requiring up to 4 examples."}, {"heading": "6 Related Work", "text": "Computer-aided education Recently, program synthesis technology has revolutionized computer-aided education. For instance, the technology has been used in automatic problem generation [Singh et al., 2012; Ahmed et al., 2013; Alvin et al., 2014; Polozov et al., 2015], automatic grading [Alur et al., 2013], and automatic solution generation [Gulwani et al., 2011]. Our work is to use program synthesis for automated programming education system. A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses\n2E.g., http://www.codeforwin.in\nprimarily on providing feedback on students\u2019 programming submissions. Our system, SIMPL, has the following advantages over prior works:\n\u2022 Feedback on incomplete programs: Existing systems produce feedback only for complete programs; they cannot help students who do not know how to proceed further. In this case, SIMPL can help by automatically generating solutions starting from incomplete solutions.\n\u2022 No burden on instructor: Existing systems require instructor\u2019s manual effort. For example, the system in [Singh et al., 2013] needs a correct implementation and a set of correction rules manually designed by the instructor. On the other hand, SIMPL does not require anything from the instructor.\nAn exception is [Farrell et al., 1984], where an automatic LISP feedback system is presented. However, the system produces feedback by relying on ad-hoc rules.\nProgramming by example Our work differs from prior programming-by-example (PBE) techniques in two ways. First, to our knowledge, our work is the first to synthesize imperative programs with loops. Most of the PBE approaches focus on domain-specific\nlanguages for string transformation [Gulwani, 2011; Kini and Gulwani, 2015; Raza et al., 2015; Manshadi et al., 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al., 2014], and extracting relational data [Le and Gulwani, 2014], etc. Several others have studied synthesis of functional programs [Albarghouthi et al., 2013; Osera and Zdancewic, 2015; Frankle et al., 2016]. Second, our algorithm differs from prior work in that we combine semantic-based static analysis technology with enumerative program synthesis. Existing enumerative synthesis technology used pruning techniques such as type systems [Osera and Zdancewic, 2015; Frankle et al., 2016] and deductions [Feser et al., 2015], which are not applicable to our setting."}, {"heading": "7 Conclusion", "text": "In this paper, we have shown that combining enumerative synthesis and static analysis is a promising way of synthesizing introductory imperative programs. The enumerative search allows us to find the smallest possible, therefore general, program while the semantics-based static analysis dra-\nmatically accelerates the process in a safe way. We demonstrated the effectiveness on 30 real programming problems gathered from online forums."}], "references": [{"title": "a system to debug student programs", "author": ["Anne Adam", "Jean-Pierre Laurent. Laura"], "venue": "Artificial Intelligence, 15(1-2), November", "citeRegEx": "Adam and Laurent. 1980", "shortCiteRegEx": null, "year": 1980}, {"title": "Automatically generating problems and solutions for natural deduction", "author": ["Umair Z. Ahmed", "Sumit Gulwani", "Amey Karkare"], "venue": "IJCAI,", "citeRegEx": "Ahmed et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Compilers: Principles", "author": ["Alfred V. Aho", "Ravi Sethi", "Jeffrey D. Ullman"], "venue": "Techniques, and Tools. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA,", "citeRegEx": "Aho et al.. 1986", "shortCiteRegEx": null, "year": 1986}, {"title": "Recursive program synthesis", "author": ["Aws Albarghouthi", "Sumit Gulwani", "Zachary Kincaid"], "venue": "CAV,", "citeRegEx": "Albarghouthi et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Loris D\u2019Antoni", "author": ["Rajeev Alur"], "venue": "Sumit Gulwani, Dileep Kini, and Mahesh Viswanathan. Automated grading of dfa constructions. In IJCAI,", "citeRegEx": "Alur et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Synthesis of geometry proof problems", "author": ["Chris Alvin", "Sumit Gulwani", "Rupak Majumdar", "Supratik Mukhopadhyay"], "venue": "AAAI,", "citeRegEx": "Alvin et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints", "author": ["Patrick Cousot", "Radhia Cousot"], "venue": "POPL,", "citeRegEx": "Cousot and Cousot. 1977", "shortCiteRegEx": null, "year": 1977}, {"title": "An interactive computer-based tutor for lisp", "author": ["Robert G. Farrell", "John R. Anderson", "Brian J. Reiser"], "venue": "AAAI,", "citeRegEx": "Farrell et al.. 1984", "shortCiteRegEx": null, "year": 1984}, {"title": "Synthesizing data structure transformations from input-output examples", "author": ["John K. Feser", "Swarat Chaudhuri", "Isil Dillig"], "venue": "PLDI,", "citeRegEx": "Feser et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Exampledirected synthesis: A type-theoretic interpretation", "author": ["Jonathan Frankle", "Peter-Michael Osera", "David Walker", "Steve Zdancewic"], "venue": "POPL,", "citeRegEx": "Frankle et al.. 2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Synthesizing geometry constructions", "author": ["Sumit Gulwani", "Vijay Anand Korthikanti", "Ashish Tiwari"], "venue": "PLDI,", "citeRegEx": "Gulwani et al.. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Feedback generation for performance problems in introductory programming assignments", "author": ["Sumit Gulwani", "Ivan Radi\u010dek", "Florian Zuleger"], "venue": "FSE,", "citeRegEx": "Gulwani et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["Sumit Gulwani"], "venue": "POPL,", "citeRegEx": "Gulwani. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Proust: Knowledge-based program understanding", "author": ["W. Lewis Johnson", "Elliot Soloway"], "venue": "ICSE,", "citeRegEx": "Johnson and Soloway. 1984", "shortCiteRegEx": null, "year": 1984}, {"title": "Semisupervised verified feedback generation", "author": ["Shalini Kaleeswaran", "Anirudh Santhiar", "Aditya Kanade", "Sumit Gulwani"], "venue": "FSE,", "citeRegEx": "Kaleeswaran et al.. 2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Apex: Automatic programming assignment error explanation", "author": ["Dohyeong Kim", "Yonghwi Kwon", "Peng Liu", "I. Luk Kim", "DavidMitchel Perry", "Xiangyu Zhang", "Gustavo Rodriguez-Rivera"], "venue": "OOPSLA,", "citeRegEx": "Kim et al.. 2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Flashnormalize: Programming by examples for text normalization", "author": ["Dileep Kini", "Sumit Gulwani"], "venue": "IJCAI,", "citeRegEx": "Kini and Gulwani. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Flashextract: A framework for data extraction by examples", "author": ["Vu Le", "Sumit Gulwani"], "venue": "PLDI,", "citeRegEx": "Le and Gulwani. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Integrating programming by example and natural language programming", "author": ["Mehdi Manshadi", "Daniel Gildea", "James Allen"], "venue": "AAAI,", "citeRegEx": "Manshadi et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Automatic Program DeBugging for Intelligent Tutoring Systems", "author": ["William R. Murray"], "venue": "Morgan Kaufmann Publishers Inc.,", "citeRegEx": "Murray. 1989", "shortCiteRegEx": null, "year": 1989}, {"title": "Type-and-example-directed program synthesis", "author": ["Peter-Michael Osera", "Steve Zdancewic"], "venue": "PLDI,", "citeRegEx": "Osera and Zdancewic. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Eleanor O\u2019Rourke", "author": ["Oleksandr Polozov"], "venue": "Adam M. Smith, Luke Zettlemoyer, Sumit Gulwani, and Zoran Popovic. Personalized mathematical word problem generation. In IJCAI,", "citeRegEx": "Polozov et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Programming by example using least general generalizations", "author": ["Mohammad Raza", "Sumit Gulwani", "Natasa Milic-Frayling"], "venue": "AAAI,", "citeRegEx": "Raza et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Compositional program synthesis from natural language and examples", "author": ["Mohammad Raza", "Sumit Gulwani", "Natasa Milic-Frayling"], "venue": "IJCAI,", "citeRegEx": "Raza et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Synthesizing number transformations from inputoutput examples", "author": ["Rishabh Singh", "Sumit Gulwani"], "venue": "CAV,", "citeRegEx": "Singh and Gulwani. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Automatically generating algebra problems", "author": ["Rohit Singh", "Sumit Gulwani", "Sriram Rajamani"], "venue": "AAAI,", "citeRegEx": "Singh et al.. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Automated feedback generation for introductory programming assignments", "author": ["Rishabh Singh", "Sumit Gulwani", "Armando Solar-Lezama"], "venue": "PLDI,", "citeRegEx": "Singh et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Meno-ii: An intelligent tutoring system for novice programmers", "author": ["Elliot M. Soloway", "Beverly Woolf", "Eric Rubin", "Paul Barth"], "venue": "IJCAI. Morgan Kaufmann Publishers Inc.,", "citeRegEx": "Soloway et al.. 1981", "shortCiteRegEx": null, "year": 1981}, {"title": "An iterative approach to synthesize data transformation programs", "author": ["Bo Wu", "Craig A. Knoblock"], "venue": "IJCAI,", "citeRegEx": "Wu and Knoblock. 2015", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 2, "context": "To do so, we use four code optimization techniques: constant propagation, copy propagation, dead code elimination, and expression simplification [Aho et al., 1986].", "startOffset": 145, "endOffset": 163}, {"referenceID": 6, "context": "The domain of intervals is standard [Cousot and Cousot, 1977]:", "startOffset": 36, "endOffset": 61}, {"referenceID": 6, "context": "We use the standard widening operator in [Cousot and Cousot, 1977].", "startOffset": 41, "endOffset": 66}, {"referenceID": 25, "context": "For instance, the technology has been used in automatic problem generation [Singh et al., 2012; Ahmed et al., 2013; Alvin et al., 2014; Polozov et al., 2015], automatic grading [Alur et al.", "startOffset": 75, "endOffset": 157}, {"referenceID": 1, "context": "For instance, the technology has been used in automatic problem generation [Singh et al., 2012; Ahmed et al., 2013; Alvin et al., 2014; Polozov et al., 2015], automatic grading [Alur et al.", "startOffset": 75, "endOffset": 157}, {"referenceID": 5, "context": "For instance, the technology has been used in automatic problem generation [Singh et al., 2012; Ahmed et al., 2013; Alvin et al., 2014; Polozov et al., 2015], automatic grading [Alur et al.", "startOffset": 75, "endOffset": 157}, {"referenceID": 21, "context": "For instance, the technology has been used in automatic problem generation [Singh et al., 2012; Ahmed et al., 2013; Alvin et al., 2014; Polozov et al., 2015], automatic grading [Alur et al.", "startOffset": 75, "endOffset": 157}, {"referenceID": 4, "context": ", 2015], automatic grading [Alur et al., 2013], and automatic solution generation [Gulwani et al.", "startOffset": 27, "endOffset": 46}, {"referenceID": 10, "context": ", 2013], and automatic solution generation [Gulwani et al., 2011].", "startOffset": 43, "endOffset": 65}, {"referenceID": 0, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 27, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 7, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 13, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 19, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 26, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 11, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 14, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 15, "context": "A large amount of work has been done to automate programming education [Adam and Laurent, 1980; Soloway et al., 1981; Farrell et al., 1984; Johnson and Soloway, 1984; Murray, 1989; Singh et al., 2013; Gulwani et al., 2014; Kaleeswaran et al., 2016; Kim et al., 2016], which focuses", "startOffset": 71, "endOffset": 266}, {"referenceID": 26, "context": "For example, the system in [Singh et al., 2013] needs a correct implementation and a set of correction rules manually designed by the instructor.", "startOffset": 27, "endOffset": 47}, {"referenceID": 7, "context": "An exception is [Farrell et al., 1984], where an automatic LISP feedback system is presented.", "startOffset": 16, "endOffset": 38}, {"referenceID": 12, "context": "Most of the PBE approaches focus on domain-specific languages for string transformation [Gulwani, 2011; Kini and Gulwani, 2015; Raza et al., 2015; Manshadi et al., 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al.", "startOffset": 88, "endOffset": 192}, {"referenceID": 16, "context": "Most of the PBE approaches focus on domain-specific languages for string transformation [Gulwani, 2011; Kini and Gulwani, 2015; Raza et al., 2015; Manshadi et al., 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al.", "startOffset": 88, "endOffset": 192}, {"referenceID": 23, "context": "Most of the PBE approaches focus on domain-specific languages for string transformation [Gulwani, 2011; Kini and Gulwani, 2015; Raza et al., 2015; Manshadi et al., 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al.", "startOffset": 88, "endOffset": 192}, {"referenceID": 18, "context": "Most of the PBE approaches focus on domain-specific languages for string transformation [Gulwani, 2011; Kini and Gulwani, 2015; Raza et al., 2015; Manshadi et al., 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al.", "startOffset": 88, "endOffset": 192}, {"referenceID": 28, "context": "Most of the PBE approaches focus on domain-specific languages for string transformation [Gulwani, 2011; Kini and Gulwani, 2015; Raza et al., 2015; Manshadi et al., 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al.", "startOffset": 88, "endOffset": 192}, {"referenceID": 24, "context": ", 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al.", "startOffset": 54, "endOffset": 79}, {"referenceID": 22, "context": ", 2013; Wu and Knoblock, 2015], number transformation [Singh and Gulwani, 2012], XML transformation [Raza et al., 2014], and extracting relational data [Le and Gulwani, 2014], etc.", "startOffset": 100, "endOffset": 119}, {"referenceID": 17, "context": ", 2014], and extracting relational data [Le and Gulwani, 2014], etc.", "startOffset": 40, "endOffset": 62}, {"referenceID": 3, "context": "Several others have studied synthesis of functional programs [Albarghouthi et al., 2013; Osera and Zdancewic, 2015; Frankle et al., 2016].", "startOffset": 61, "endOffset": 137}, {"referenceID": 20, "context": "Several others have studied synthesis of functional programs [Albarghouthi et al., 2013; Osera and Zdancewic, 2015; Frankle et al., 2016].", "startOffset": 61, "endOffset": 137}, {"referenceID": 9, "context": "Several others have studied synthesis of functional programs [Albarghouthi et al., 2013; Osera and Zdancewic, 2015; Frankle et al., 2016].", "startOffset": 61, "endOffset": 137}, {"referenceID": 20, "context": "Existing enumerative synthesis technology used pruning techniques such as type systems [Osera and Zdancewic, 2015; Frankle et al., 2016] and deductions [Feser et al.", "startOffset": 87, "endOffset": 136}, {"referenceID": 9, "context": "Existing enumerative synthesis technology used pruning techniques such as type systems [Osera and Zdancewic, 2015; Frankle et al., 2016] and deductions [Feser et al.", "startOffset": 87, "endOffset": 136}, {"referenceID": 8, "context": ", 2016] and deductions [Feser et al., 2015], which are not applicable to our setting.", "startOffset": 23, "endOffset": 43}], "year": 2017, "abstractText": "We present a novel algorithm that synthesizes imperative programs for introductory programming courses. Given a set of input-output examples and a partial program, our algorithm generates a complete program that is consistent with every example. Our key idea is to combine enumerative program synthesis and static analysis, which aggressively prunes out a large search space while guaranteeing to find, if any, a correct solution. We have implemented our algorithm in a tool, called SIMPL, and evaluated it on 30 problems used in introductory programming courses. The results show that SIMPL is able to solve the benchmark problems in 6.6 seconds on average.", "creator": "LaTeX with hyperref package"}}}