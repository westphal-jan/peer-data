{"id": "1703.00050", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Feb-2017", "title": "SceneSeer: 3D Scene Design with Natural Language", "abstract": "designing 3d scenes is currently a creative discovery task that requires significant expertise and effort in using complex 3d image design interfaces. this effortful design process starts evolving in stark contrast to the easiness with which people can now use language to describe real and imaginary environments. we present sceneseer : an interactive text to 3d scene generation system that allows a user to design 3d scenes using natural language. a simulation user provides input text from which we continuously extract explicit constraints on the objects that should appear in the scene. given these explicit constraints, the system operator then periodically uses a spatial knowledge base learned primarily from extending an existing database of 3d scenes and 3d object presentation models to infer an arrangement of the objects forming out a natural space scene matching the input description. using textual commands the user can then iteratively refine the appropriately created scene by adding, removing, replacing, and manipulating objects. we evaluate the comparative quality of 3d scenes generated by sceneseer in a perceptual evaluation or experiment where we thoroughly compare against manually designed scenes and simpler baselines for simplified 3d scene generation. we demonstrate how the generated scenes can finally be iteratively refined through simple natural languages language manipulation commands.", "histories": [["v1", "Tue, 28 Feb 2017 20:47:47 GMT  (7392kb,D)", "http://arxiv.org/abs/1703.00050v1", null]], "reviews": [], "SUBJECTS": "cs.GR cs.CL cs.HC", "authors": ["angel x chang", "mihail eric", "manolis savva", "christopher d manning"], "accepted": false, "id": "1703.00050"}, "pdf": {"name": "1703.00050.pdf", "metadata": {"source": "META", "title": "SceneSeer: 3D Scene Design with Natural Language", "authors": ["Angel X. Chang", "Mihail Eric", "Manolis Savva", "Christopher D. Manning"], "emails": ["manning}@cs.stanford.edu"], "sections": [{"heading": "INTRODUCTION", "text": "Designing 3D scenes is a challenging creative task. Expert users expend considerable effort in learning how to use complex 3D scene design tools. Still, immense manual effort is required, leading to high costs for producing 3D content in video games, films, interior design, and architectural visualization. Despite the conceptual simplicity of generating pictures from descriptions, systems for text-to-scene generation have only achieved limited success. How might we allow people to create 3D scenes using simple natural language?\nCurrent 3D design tools provide a great amount of control over the construction and precise positioning of geometry within 3D scenes. However, most of these tools do not allow for intuitively assembling a scene from existing objects which is critical for non-professional users. As an analogue, in real life few people are carpenters, but most of us have bought and arranged furniture. For the purposes of defining how to compose and arrange objects into scenes, natural language is an obvious interface. It is much easier to say \u201cPut a blue bowl on the dining table\u201d rather than retrieving, inserting and orienting a 3D model of a bowl. Text to 3D scene interfaces can empower a broader demographic to create 3D scenes for games, interior design, and virtual storyboarding.\nText to 3D scene systems face several technical challenges. Firstly, natural language is typically terse and incomplete. People rarely mention many facts about the world since these facts can often be safely assumed. Most desks are upright and on the floor but few people would mention this explicitly. This implicit spatial knowledge is critical for scene generation but hard to extract. Secondly, people reason about the\nar X\niv :1\n70 3.\n00 05\n0v 1\n[ cs\nworld at a much higher level than typical representations of 3D scenes (using the descriptive phrase table against wall vs a 3D transformation matrix). The semantics of objects and their approximate arrangement are typically more important than the precise and abstract properties of geometry. Most 3D scene design tools grew out of the traditions of Computer Aided Design and architecture where precision of control and specification is much more important than for casual users. Traditional interfaces allow for comprehensive control but are typically not concerned with high level semantics.\nSCENESEER allows users to generate and manipulate 3D scenes at the level of everyday semantics through simple natural language. It leverages spatial knowledge priors learned from existing 3D scene data to infer implicit, unmentioned constraints and resolve view-dependent spatial relations in a natural way. For instance, given the sentence \u201cthere is a dining table with a cake\u201d, we can infer that the cake is most likely on a plate and that the plate is most likely on the table. This elevation of 3D scene design to the level of everyday semantics is critical for enabling intuitive design interfaces, rapid prototyping, and coarse-to-fine refinements.\nIn this paper, we present a framework for the text to 3D scene task and use it to motivate the design of the SCENESEER system. We demonstrate that SCENESEER can be used to generate 3D scenes from terse, natural language descriptions. We empirically evaluate the quality of the generated scenes with a human judgment experiment and find that SCENESEER can generate high quality scenes matching the input text. We show how textual commands can be used interactively in SCENESEER to manipulate generated 3D scenes."}, {"heading": "BACKGROUND", "text": ""}, {"heading": "3D Design Interfaces", "text": "Current research typically focuses on low-level interfaces for 3D modeling. There is much work on input methodologies and schemes for easing navigation in 3D [14, 15] and manipulation of primitives such as curves [17]. However, there is little work on 3D scene manipulation at a semantic level. Recent work has explored the avenue of parsing natural language for design problem definitions in the context of mechanical computer-aided design software [5]. Our motivation is similar, but we focus on the more open-ended setting of natural language 3D scene generation and manipulation.\nAnother line of work focuses on defining higher-level semantic APIs for scripting 3D animations and storyboards [7, 13]. This prior work finds that people overwhelmingly prefer higher-level manipulation and specification in terms of semantic concepts such as \u201cin front\u201d, \u201cto the left\u201d and \u201con top of\u201d rather than low level manipulation. The focus of this work was on defining simple APIs for designing animated stories, whereas we focus on demonstrating a natural language interface for static 3D scene design. We are closer to early seminal work in placing simple geometric objects in 3D through textual commands [6].\nMore recently, Chaudhuri et al. [4] have demonstrated a novel 3D model design interface where users can control the desired values of high-level semantic attributes (e.g., \u201caerodynamic\u201d,\n\u201cscary\u201d) to interactively combine object parts. We similarly allow users high-level semantic control but our focus is on 3D scenes where manipulating the layout of objects comes with a different set of challenges compared to object assembly."}, {"heading": "Automatic Scene Layout", "text": "Recent research in computer graphics has focused on learning how to automatically lay out 3D scenes given training data. Prior work on scene layout has focused largely on room interiors and determining good furniture layouts by optimizing energy functions that capture the quality of a proposed layout. These energy functions are encoded from interior design guidelines [16] or learned from input scene data [10]. Knowledge of object co-occurrences and spatial relations is represented by simple models such as mixtures of Gaussians on pairwise object positions and orientations. Methods to learn scene structure have been demonstrated using various data sources including simulation of human agents in 3D scenes [11, 12], and analysis of supporting contact points in scanned environments [18]. Though SCENESEER is also a system for generating 3D scenes, it focuses on providing an interactive natural language interface for this task."}, {"heading": "Text to Scene Systems", "text": "Early work in textual interfaces for 3D scene manipulation has addressed simplified scenarios with micro-worlds consisting of simple geometric shapes. The SHRDLU [20] and PUT [6] systems were pioneers in parsing natural language instructions, but generalization of their approach to more realistic scenarios similar to the real world is challenging. More recent work on the WordsEye system [8, 9] and other similar approaches [19] has demonstrated more general text-driven 3D scene generation that can handle complex scenes. The authors compellingly show the benefit of text to scene generation but note that their systems are restricted due to a lack of implicit spatial knowledge. As a result, unnatural language, such as \u201cthe stool is 1 feet to the south of the table\u2019,\u2019 must be used to fully specify the scene.\nMost recently, Chang et al. [3] have demonstrated how linguistic and non-linguistic spatial knowledge can be learned directly from existing scene data and leveraged when parsing natural language. We build upon this prior work and focus on interactive scene design where the user does not have to specify all details of the scene at once, in contrast to prior text to scene systems such as WordsEye. With SCENESEER the user can dynamically manipulate a 3D scene with simple textual commands resembling dialogue systems."}, {"heading": "APPROACH OVERVIEW", "text": "How might we create an interactive text to 3D scene system? The user should be able to describe and manipulate a scene with concise natural language. To make this possible, we need to parse the input text to a set of explicitly provided constraints on objects and their arrangement. We also need to expand these constraints with implicit \u201ccommon sense\u201d facts (e.g., most of the time plates go on tables, not on the floor). Once we\u2019ve inferred implicit constraints, we can generate a candidate scene that can be rendered and viewed by\nthe user for further interactive refinement with textual commands. Based on the systems presented in [2, 3], we frame the interactive text-to-scene problem in a probabilistic formulation that covers both scene generation and interactive scene operations. We show how these two previous systems can be viewed as specific instantiations of our framework.\nSCENESEER relies on a spatial knowledge base that is learned from a corpus of 3D scenes and 3D models (see Figure 1). The learning procedure and components of this spatial knowledge base are based on the prior work of Chang et al. [3] and we use the same corpus of 3D scenes and component 3D models, consisting of about 12,490 mostly indoor objects with associated textual categories and tags. Our approach for extracting object relative positions, support hierarchies, support surfaces, and spatial relations is also based on that of Chang et al., and is described in more detail in the appendix.\nWe define our problem as the task of taking text describing a scene as input, and generating a plausible 3D scene described by that text as output. More concretely, based on the input text, we select objects from a dataset of 3D models and arrange them to generate output scenes. See Figure 1 for an illustration of the system architecture. We break the system down into several subtasks:\nSemantic Parsing: Parse the input textual description of a concrete scene into a scene template consisting of constraints on the objects present and spatial relations between them.\nScene Inference: Automatically expand the scene template to account for implicit constraints not specified in the text.\nScene Generation: Using the above scene template and prior knowledge on the spatial arrangement of objects, sample the template, select a set of objects to be instantiated, and optimize their arrangement into a scene.\nScene Interaction: Allow user to interactively adjust the scene through direct manipulation and textual commands.\nThis breakdown is useful for tackling the hard problem of text-to-scene and allows us to address subproblems independently or jointly. We choose this breakdown as it provides a separation between subproblems that fall within the graphics, NLP, and interaction design communities."}, {"heading": "Representation", "text": "There is a big gap between the representations typically used for 3D object and scene rendering, and the high-level semantics that people assign to scenes. Here we define a scene template representation following Chang et al. [3]\u2019s approach to make explicit the information necessary for connecting higher-level semantics to the lower-level geometric representations. Since natural language usually expresses high-level semantics, we can view the text-to-scene task as a problem of first extracting a higher-level scene template representation and then mapping into a concrete geometric representation."}, {"heading": "Scene Template", "text": "A scene template t = (O, C, Cs) consists of a set of object descriptions O = {o1, . . . , on} and constraints C = {c1, . . . , ck} on the relationships between the objects. A\nscene template also has a scene type Cs. This provides a high-level yet unambiguous representation of scene structure.\nEach object oi, has properties associated with it such as category label, basic attributes such as color and material, and number of occurrences in the scene. For constraints, we focus on spatial relations between objects, expressed as predicates of the form supported by(oi, oj) or left(oi, oj) where oi and oj are recognized objects."}, {"heading": "Geometric Scene", "text": "We refer to the concrete geometric representation of a scene as a \u201cgeometric scene\u201d. A geometric scene s consists of a set of 3D model instances {i1, . . . , in} where each model instance ij = (mj , Tj) is represented by model mj in the model database and the transformation matrix Tj . The model represents the physical appearance (geometry and texture) of the object while the transformation matrix encodes the position, orientation, and scaling of the object. Working directly with such low-level representations of scenes is unnatural for people, which is a factor in the difficulty of learning current 3D scene design interfaces. We generate a geometric scene from a scene template by selecting appropriate models from a 3D model database and determining transformations that optimize their layout to satisfy spatial constraints."}, {"heading": "Model Formulation", "text": "We take a probabilistic view and model the task as that of estimating the distribution of possible scenes P (s|u) given the input utterance u. This allows us to incorporate prior knowledge to perform inference, and to leverage recent advances in machine learning for learning from data. The distribution P (s|u) can be sampled from to generate plausible scenes to present to the user.\nWe can further decompose P (s|u) into:\nP (s|u) = P (t|u)P (t\u2032|t, u)P (s|t\u2032, t, u)\nwhere P (t|u) is the probability of a scene template t given a utterance u, and t\u2032 is a completed scene template. In our pipelined system, we will assume that s is independent of t, u and that t\u2032 is independent of u to get\nP (s|u) = P (t|u)P (t\u2032|t)P (s|t\u2032)\nA more sophisticated system would jointly estimate P (s|u). In our framework, Semantic Parsing corresponds to estimating P (t|u), Scene Inference to estimating P (t\u2032|t), and Scene Generation to estimating P (s|t\u2032). The deterministic parsing model of Chang et al. [3] represents P (t|u) as a delta probability at the selected t.\nWe decompose scene generation into two parts: Object Selection and Scene Layout. Object selection consists of identifying a likely set of models {mj} from our model database given a complete scene template t. Scene layout is the problem of arranging the objects and finding appropriate transforms {Tj} for the models {mj} and scene template t.\nP (s|t) = P ({mj}|t)P ({mj , Tj}|{mj}, t)\nAgain, a more sophisticated system may choose to estimate P (s|t) jointly. Note that in the equation above, {mj} denotes the set of all models and {mj , Tj} denotes the set of all model, transformation matrix tuples (mj , Tj).\nTo further simplify the problem, we assume that we can select the model for each object independently. Thus, we have\nP ({mj}|t) = \u220f j P (mj |oj)\nThis assumption clearly does not hold for many scenes and scene templates (e.g., matching furniture sets).\nFor scene layout, we estimate P ({mj , Tj}|{mj}, t) using a layout score L described in more detail in the Appendix. To support Scene Interactions, we follow a similar model, except now we are given a starting scene s and an utterance u, and we want to determine the desired scene s\u2032. We can model this as estimating P (s\u2032|s, u). For simplicity, we will assume that the utterance consist of one scene operationO that takes s and transforms it to s\u2032. Thus we can break down P (s\u2032|s, u) = P (s\u2032|O, s, u)P (O|s, u). Here, given a specific starting scene s and the utterance u expressing a desired operation, we want to find the operation O that can be applied on s to yield s\u2032. This problem can be decomposed into parsing, inference and generation steps that we use for regular scene generation as well. The difference is that we now estimate an operation O."}, {"heading": "SEMANTIC PARSING", "text": "During semantic parsing we take the input text and create a scene template that identifies the objects and the relations between them. We follow the approach of Chang et al. [3] to process the input text using the Stanford CoreNLP pipeline1, identify visualizable objects, physical properties of the objects, and extract dependency patterns for spatial relations between the objects. The parsed text is then deterministically mapped to the scene template or scene operations. An interesting avenue for future research is to automatically learn how to map text using more advanced semantic parsing methods.\nSCENE INFERENCE After we obtain a scene template with the explicitly stated constraints, we expand it to include inferred objects and implicit constraints. As an example, for each object in the scene, we use the support hierarchy prior Psupport to find the most likely supporting parent object category. If there is no such parent object already in the scene, we add it to the scene. For instance, given the objects \u201ccomputer\u201d and \u201croom\u201d, we infer that there should also be a \u201cdesk\u201d supporting the \u201ccomputer\u201d.\nIn addition to inferring missing objects, we infer the static support hierarchy for the objects in the scene. For each object, we first identify support constraints that must exist based on the scene template. For any objects that do not have a supporting parent, we sample Psupport(Cp|Cc) restricted to the set of available object categories. In addition, we can infer missing objects based on the location (for instance, a bedroom typically contains a bed and a dresser). Future work would 1http://nlp.stanford.edu/software/corenlp.shtml\ninvolve enhancing this component with improved inference by identifying what objects must exist for each location, instead of sampling a random selection of objects. We can also consider additional contextual details such as the distinction between a messy desk with a variety of items versus a tidy desk with few items."}, {"heading": "SCENE GENERATION", "text": "Once we have a complete scene template we need to select 3D models to represent the objects trying to match any described attributes, and to arrange the models in the scene based on constraints. During this step we aim to find the most likely scene given the scene template and prior spatial knowledge.\nObject Selection We use the keywords associated with each object to query the model database. We select randomly from the top 10 results for variety and to allow the user to regenerate the scene with different models. This step can be enhanced to take into account correlations between objects (e.g., a lamp on a table should not be a floor lamp model).\nObject Layout Given the selected models, the source scene template, and priors on spatial relations, we find an arrangement of the objects within the scene that maximizes the probability of the layout under the given scene template.\nIn order to compute how well the layout satisfies the constraints given by the scene template, we parameterize the layout of each object using semantically meaningful attributes: support parent parentsup, support surface surfsup, attachment surface surfatt, position on support surface possup, orientation \u03b8, size \u03c3. These semantic attributes allow us to do higher level reasoning and interactions with the object.\nWe use a sampling approach to determine the position, orientation, and size of objects within the scene. We first traverse the support hierarchy in depth-first order, positioning the largest available child node and recursing. Child nodes are positioned by first selecting a supporting surface surfsup on a candidate parent object through sampling of Psurfsup . Using Psurfatt , we find the most appropriate child attachment sur-\nface surfatt and orient the child node accordingly. We then sample possible placements (possup, \u03b8, \u03c3) on surfsup, ensuring that the node is not overhanging and there are no collisions with other objects. Each sampled placement is scored with L. The resulting scene is rendered and presented to the user. Figure 2 shows a generated scene along with the support hierarchy and input text. Even though the room, table, and other objects were not explicitly mentioned in the input, we infer that the plate is likely to be supported by a table and that there likely to be other objects on the table. Without this inference, the user would need to be much more verbose with text such as \u201cThere is a room with a table, a plate, and a sandwich. The sandwich is on the plate, and the plate is on the table.\u201d\nFigure 3 shows several examples illustrating how we can generate many 3D scenes for the user to select from. Our system can infer many unstated but implicitly present objects (e.g., monitors are placed on the desks for functional computer setups). We can generate high quality scenes for localized arrangements such as the computer desks, for which there are many examples in the training 3D scene corpus. However, more complex scenes such as the living rooms exhibit some unnatural object positioning (e.g., TV does not face the couch). For such cases, it is important to allow users to iteratively refine the generated scene.\nSCENE INTERACTIONS Once a scene is generated, the user can view the scene and manipulate it using both textual commands and mouse interaction. The system supports traditional 3D scene interaction mechanisms such as navigating the viewpoint with mouse and keyboard, and selection and movement of object models by\nclicking. In addition, a user can give simple textual commands to select and modify objects, or to refine the scene.\nTo allow the user to interact with a generated scene via text, we define a set of high-level semantic operations for scene manipulation. These are higher level operations than typically found in traditional scene editing software. Again, the text is treated as a set of constraints that we want the revised scene to satisfy, while trying to keep the revised scene as similar to the original scene as possible. More formally, given the original scene S and a scene operation O, we want to find the scene S\u2032 which is most similar to S, while still satisfying the constraints imposed by O.\nTo track the other elements of the scene, we maintain a scene state Z = (S, Sel,Cam) that consists of the scene S, the set of selected objects Sel, and the camera position Cam. Each operation can be defined as a function O : Z \u2192 Z \u2032. We support several basic operations: Select changes the set of selected objects, Insert adds objects into the scene, Delete removes objects from the scene, Replace replaces objects in the scene with new objects, operations such as Move and Scale modify constraints on existing objects without changing the set of objects in the scene. LookAt repositions the camera to focus on the selected objects. Table 1 summarizes the operations supported by our system. These basic operations demonstrate some simple scene manipulations through natural language. This set of operations can be extended, for example, to cover manipulation of parts of objects (\u201cmake the seat of the chair red\u201d).\nTo interpret a textual scene interaction command, the system first parses the input text u into sequence of scene operations (O1, . . . , Ok), identifying the resulting set of constraints that should hold. For each parsed scene operation Oi, the system\nthen executes the scene operation by resolving the set of objects on which the operation should be performed and then modifying the scene state accordingly.\nCommand Parsing We deterministically map verbs to possible actions as shown in Table 1. Multiple actions are possible for some verbs (e.g., \u201cplace\u201d and \u201cput\u201d can refer to either Move or Insert). To differentiate, we assume new objects are introduced with the indefinite article \u201ca\u201d whereas old ones are modified with the definite article \u201cthe\u201d.\nObject Resolution To allow interaction with the scene, we must resolve references to objects within a scene. Objects are disambiguated by category and view-centric spatial relations. In addition to matching objects by their categories, we use the WordNet hierarchy to handle hyponym or hypernym referents. Depending on the current view, spatial relations such as \u201cleft\u201d or \u201cright\u201d can refer to different objects.\nCamera Positioning For the LookAt command, we first identify the set of objects being referred to. Given an utterance u of the form \u201clook at X\u201d, we get the set of objects that are the most likely referent Sel = argmaxo\u2208S P (o|X). We perform a simple viewpoint optimization where we sample camera positions c and find the position that maximizes a view function f(c), giving us Campos = argmaxc f(c).\nCamera positions are sampled from 12 equally spaced points around the up-axis of the selected objects and at a fixed height slightly above the bounding box of the objects. The camera is targeted at the centroid point of the selected objects. The view function we use is: f(c) = visSel(c) + b(scrSel(c)) + visall(c) where visSel is the number of selected objects visible, visall is the percentage of all objects visible, and b is a function of scrSel2, the percent of the screen that is taken up by the selected objects.\nThis is a simple approach for camera positioning which is challenging to perform manually for novice users of 3D design software and yet critical for navigating and interacting with the environment.\nScene Modification Based on the operation, we modify the scene by maximizing the probability of a new scene template given the requested action and previous scene template.\nThe set of objects in the scene is modified according to the operation:\n2linear ramp from b(0.2) = 0 to b(0.4) = 1\n\u2022 Insert: Select a new object that satisfies the constraints from the model database and place it in the scene. \u2022 Replace: Select a new object that satisfies the constraints\nfrom the model database and replace the objects to be replaced with the new object. \u2022 Delete: Remove the old objects from the scene. After the set of objects is determined, relayout is performed on the scene by attempting to satisfy the constraints while minimizing the change in position for all unmodified objects. For operations such as Move and Scale the set of objects remain the same but their position or size will need to change to satisfy the new constraints. When doing relayout, we do not vary all parameters, but just the set of influenced parameters for the operation (see Table 1).\nDepending on the operation, operand objects, and their scene context, the resulting changes in the scene vary in complexity. The simplest operations only influence the target objects while more complex operations require adjustment of supported objects or even surrounding objects. Figure 5 shows examples of the Replace operation with varying complexity. Replacing the bowl on the table with a table lamp is relatively easy since the system only needs to ensure the attachment point remains the same. However, when we replace the table with a coffee table in Figure 5 (middle), the bowl needs to be repositioned. In the bottom row of the figure we see a failure case due to the layout algorithm since the chairs are not repositioned to accommodate the bigger round table. Instead the table is pushed to the side to avoid collisions. Manually performing a replace operation can be extremely tedious due to such object position dependencies, thus making this a valuable high-level operation. This illustrates how our approach attempts to bridge the semantic gap between high-level intent and low-level geometric manipulation. In our implementation, the scene operations are initiated by the user using text commands. It is also possible to incorporate these operations into a graphical user interface. For instance, Replace can be implemented in a GUI as a sequence of clicks to select an ob-\nject, search from a model database, select a desired model to use as a replacement."}, {"heading": "Scene Refinement", "text": "With the set of high-level operations that we defined, a user can progressively refine a generated scene. Figure 6 shows a sequence of operations for adding a rug to the living room we generated earlier. Combined with traditional mouse and keyboard navigation, these textual interactions allow high-level scene editing operations that are interpreted within the current viewing context (e.g., moving the rug to the back of the room from the viewer\u2019s perspective in the third panel). Without such high-level operations, the necessary interaction would include several steps to find a rug model, place it, orient it, and manually adjust its position."}, {"heading": "GENERATED SCENE EVALUATION", "text": "We evaluate the output of our system by asking people to judge how well generated scenes match given input descriptions. This is an appropriate initial evaluation since in a practical usage scenario, a scene matching the input description well would provide a good starting point for further refinement. We compare versions of our system contrasting the benefit of different components. We also establish an upperbound baseline by asking people to manually design scenes corresponding to the same descriptions, using a simple scene design interface used in prior work [10]."}, {"heading": "Conditions", "text": "We compare seven conditions: basic, +sup, +sup+spat, +sup+prior, full, full+infer, and human. The basic condition is a simple layout approach which does not use any learned support, spatial relation, or placement priors.\nThe conditions +sup, +sup+spat, and +sup+prior, and full (which includes all three priors) test the benefit of adding these learned priors to the system. Finally, full+infer performs implicit inference for selecting and laying out additional objects, while human consists of the manually designed 3D scenes that people created given the descriptions. For each of these conditions we create a set of 50 scenes, one for each of the input textual descriptions. In total, we have 350 stimulus scene-description pairs to be rated by people during our experiment (see Figure 8 for example descriptions and scenes)."}, {"heading": "Participants", "text": "Participants were recruited online on Amazon Mechanical Turk and were required to be fluent speakers of English. We recruited a total of 97 participants for evaluating the quality of generated scenes with respect to reference textual descriptions. For the human condition, the scenes were created by a different set of 50 participants who were given the textual descriptions and asked to create a corresponding scene (see last column of Figure 8)."}, {"heading": "Procedure", "text": "During the experiment, a randomly sampled set of 30 pairs of generated scene and input textual descriptions were shown to each participant. The pairs were drawn from all conditions and present in randomized order. The participants were asked to rate each pair on a 7-point Likert scale to indicate \u201chow well the scene matches the description\u201d, with a score of 1 indicating a very bad match, and 7 indicating a very good match. The participants were instructed to consider three points in particular: (1) Are the objects mentioned in the description included in the scene? (2) Are the described relationships between the objects correct in the scene? and (3) Overall, does the scene fit the description? Figure 7 shows a screenshot of the UI that we used to carry out the experiment."}, {"heading": "Design", "text": "The experiment was a within-subjects factorial design with the condition {basic, +sup, +sup+spat, +sup+prior,\nfull, full+infer, human}, description {1...50}, and participant {1...97} as factors. The Likert rating for description-to-scene match was the dependent measure."}, {"heading": "Results", "text": "In total the 97 participants gave 2910 scene ratings for the 350 stimulus scene-description pairs with 8.39 ratings on average per pair (standard deviation was 3.56 ratings)."}, {"heading": "Generated scene ratings", "text": "The mean ratings for each condition in our experiment are summarized in Table 2 and the rating distributions are plotted in Figure 9. We see that the basic condition receives the lowest average rating, while predictably the scenes designed by people receive the highest rating. Adding learned support, spatial relation parsing, and priors for relative position improve the rating for the scenes generated by our system, and the full combined condition receives the highest average rating. We note that the scenes generated with additional inferred objects (full+infer) actually receive a lower rating. We hypothesize that two factors may contribute to the lower rating for full+infer. Firstly, adding extra objects makes the scene layout more complicated and prone to exhibiting object selection or spatial relation errors. Secondly, inferred objects are not explicitly mentioned in the description so participants may not have viewed them as significantly improving the quality of the scene (though they were instructed to consider additional objects positively if they add naturally to the appearance of the scene)."}, {"heading": "Statistical analysis", "text": "The statistical significance of the effect of the condition factor on the ratings was determined using a mixed effects model, with the condition as a fixed effect and the participant and description as random effects, since the latter two are drawn randomly from a large pool of potential participants and descriptions3. Most pairwise differences between conditions for mean scene rating were significant under Wilcoxon ranksum tests with the Bonferroni-Holm correction (p<0.05). The exceptions are the comparisons between +sup+spat, +sup+prior and full which were not significant."}, {"heading": "Summary", "text": "The experimental results show that SCENESEER can generate plausible 3D scenes given input descriptions. The different components of the system that leverage learned support relations, spatial relationship parsing, and relative position priors all contribute towards improving the quality of the generated scenes. Implicitly inferred additional objects do not improve the scene-to-description match ratings given by people."}, {"heading": "DISCUSSION", "text": ""}, {"heading": "Limitations", "text": "The unoptimized implementation of our system takes several seconds to parse, infer and generate a scene, depending 3We used the lme4 R package and optimized for maximum loglikelihood [1].\nmostly on the number of objects and relations expressed in the input. Unfortunately, this makes interactive use slow in practical settings. However, the system can be easily optimized to within the range of real-time editing. A more important limitation, is that we currently handle a limited domain of scenes. Parsing of scene descriptions with existing natural language processing methods is error-prone even for simple, everyday language, and the publicly available 3D model datasets are biased towards furniture and electronics, limiting the types of potential output scenes (e.g., \u201cthe flower garden outside the window\u201d is a challenging case). Furthermore, generation of scenes with more organic, complex object geometry is challenging for our simplistic layout approach, and we have ignored the importance of stylistic consistency in object selection (e.g., different styles of chairs selected for same table).\nThe current set of operations that we presented is constrained to fairly simple manipulations of the scene. An improved system would be able to process more complex interactions that require a deeper semantic understanding of the world. For example: \u201cmove the TV to face the couch\u201d (requires knowledge of front sides and facing orientations), and \u201cput a bowl of fruit on the second shelf of the bookcase\u201d (requires knowledge of object parts and relative ordering from bottom).\nWe have not explored the design choices in combining a highlevel natural language interface such as SCENESEER with direct manipulation is an interesting avenue for future research. Different operations might be more efficient to perform in one modality or the other, depending also on the particular scene context and viewpoint. Measuring the relative benefits of different combination strategies in specific tasks is an interesting avenue for future research."}, {"heading": "Future Work", "text": "A promising direction for future work is to integrate systems such as SCENESEER with speech to text systems allowing for voice-driven and more natural dialogue interactions. This could be particularly relevant in the context of increasingly popular virtual and augmented reality systems where text input is more cumbersome.\nLeveraging the interactive nature of the system to improve spatial knowledge is an exciting avenue for future work. For instance, by observing where the user decides to manually place objects, we can improve our placement priors. A natural way for the user to provide feedback and corrections to system errors is through a dialogue-based interaction extending the imperative textual commands.\nAnother exciting direction for future work is to crowdsource the accumulation of spatial knowledge by scaling the system on web-based platforms. This will also provide an opportunity for broader user studies that can give insight into contextspecific preferences for text versus direct manipulation interactions, and provide useful data for informing the design of future text-to-scene systems."}, {"heading": "CONCLUSION", "text": "We presented SCENESEER, a text to 3D scene generation system with semantically-aware textual interactions for iter-\native 3D scene design. We evaluated the scenes generated by our system through a human judgment experiment and confirmed that we can generate scenes that match the input textual descriptions and approach the quality of manually designed scenes. We demonstrated that automatically generated 3D scenes can be used as starting points for iterative refinement through a set of high-level textual commands. Natural language commands are a promising mode of interaction for 3D scene design tasks since they abstract much of the tedium of low level manipulation. In this way, we can bridge the semantic gap between high-level user intent and low-level geometric operations for 3D scene design.\nWe believe that the domain of text to 3D scene design presents many challenging research problems at the intersection of computer graphics, HCI, and natural language processing. Our system presents a small step in the direction of enabling natural language interfaces for scene design. We believe that in the future, dialogue-based systems will make the scene design process as effortless as telling a story."}, {"heading": "APPENDIX Scene Layout Score", "text": "The scene layout score is given by L = \u03bbobjLobj + \u03bbrelLrel, a weighted sum of object arrangement Lobj score and constraint satisfaction Lrel score following from Chang et al. [3]\u2019s definition:\nLobj = \u2211 oi Psurf(Sn|Coi) \u2211 oj\u2208F (oi) Prelpos(\u00b7)\nLrel = \u2211 ci Prel(ci)\nwhere F (oi) are the sibling objects and parent object of oi. We use \u03bbobj = 0.25 and \u03bbrel = 0.75 for the results we present."}, {"heading": "Spatial Knowledge Priors", "text": "We use similar definitions for spatial knowledge priors as those presented by Chang et al. [3] with updated support and attachment surface priors. Spatial knowledge priors are estimated using observations in scenes. To handle data sparsity we utilize our category taxonomy. If there are fewer than k = 5 support observations we back off to a parent category in the taxonomy for more informative priors."}, {"heading": "Object Occurrence Priors", "text": "Occurrence priors are given by simple Bayesian statistics of objects occurring in scenes: Pocc(Co|Cs) = count(Co in Cs)count(Cs)"}, {"heading": "Support Hierarchy Priors", "text": "We estimate the probability of a parent category Cp supporting a given child category Cc as a simple conditional probability based on normalized observation counts: Psupport(Cp|Cc) = count(Cc on Cp)count(Cc)"}, {"heading": "Support and Attachment Surface Priors", "text": "Similarly, the parent support surface priors are given by: Psurfsup(s|Cc) = count(Cc on surface with s) count(Cc)\nThe parent supporting surface is featurized using the surface normal (up, down, horizontally) and whether the surface is interior (facing in) or exterior (facing out). For instance, a room has a floor which is an upwards interior supporting surface:\nThe child attachment surface priors are given by: Psurfatt(s|Cc) = count(Cc attached at surface s) count(Cc)\nObject attachment surfaces are featurized using the bounding box side: top, bottom, front, back, left, or right. For instance, posters are attached on their back side to walls, rugs are attached on their bottom side to floors.\nIf there are no observations available we use the model geometry to determine the support and attachment surface. For support surfaces we pick only upward facing surfaces, while for attachment we assume 3D (blocky) objects are attached on the bottom, flat objects are attached on their back or bottom, and thin objects are attached on their side."}, {"heading": "Relative Position Priors", "text": "We model the relative positions of objects based on their object categories and current scene type: i.e., the relative position of an object of category Cobj is with respect to another object of category Cref and for a scene type Cs. We condition on the relationship R between the two objects, whether they are siblings (R = Sibling) or child-parent (R = ChildParent), and define the relative position prior as: Prelpos(x, y, \u03b8|Cobj, Cref, Cs, R) which we estimate using kernel density estimation."}], "references": [{"title": "Mixed-effects modeling with crossed random effects for subjects and items", "author": ["R.H. Baayen", "D.J. Davidson", "D.M. Bates"], "venue": "Journal of memory and language", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "Interactive learning of spatial knowledge for text to 3D scene generation", "author": ["A.X. Chang", "M. Savva", "C.D. Manning"], "venue": "In Proceedings of the ACL 2014 Workshop on Interactive Language Learning,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Learning spatial knowledge for text to 3D scene generation", "author": ["A.X. Chang", "M. Savva", "C.D. Manning"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "Content Creation with Semantic Attributes", "author": ["S. Chaudhuri", "E. Kalogerakis", "S. Giguere", "Funkhouser", "T. AttribIt"], "venue": "In UIST", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2013}, {"title": "Natural language problem definition for computer-aided mechanical design", "author": ["H. Cheong", "W. Li", "L. Shu", "A. Tessier", "E. Bradner", "F. Iorio"], "venue": "In CHI-DSLI Workshop 2014 Conference Proceedings", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Language-based interactive manipulation of objects", "author": ["S.R. Clay", "Wilhelms", "J. Put"], "venue": "Computer Graphics and Applications", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1996}, {"title": "Alice: lessons learned from building a 3D system for novices", "author": ["M. Conway", "S. Audia", "T. Burnette", "D. Cosgrove", "K. Christiansen"], "venue": "In Proceedings of the SIGCHI conference on Human Factors in Computing Systems,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2000}, {"title": "an automatic text-to-scene conversion system", "author": ["B. Coyne", "Sproat", "R. WordsEye"], "venue": "In SIGGRAPH", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2001}, {"title": "Example-based synthesis of 3D object arrangements", "author": ["M. Fisher", "D. Ritchie", "M. Savva", "T. Funkhouser", "P. Hanrahan"], "venue": "SIGGRAPH Asia", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Learning object arrangements in 3D scenes using human context", "author": ["Y. Jiang", "M. Lim", "A. Saxena"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Infinite latent conditional random fields for modeling environments through humans", "author": ["Y. Jiang", "A. Saxena"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Lessons learned from designing a programming system to support middle school girls creating animated stories", "author": ["C. Kelleher", "R. Pausch"], "venue": "In Visual Languages and Human-Centric Computing,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2006}, {"title": "Viewcube: a 3D orientation indicator and controller", "author": ["A. Khan", "I. Mordatch", "G. Fitzmaurice", "J. Matejka", "G. Kurtenbach"], "venue": "In Proceedings of the 2008 symposium on Interactive 3D graphics and games,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2008}, {"title": "Multiscale 3D navigation", "author": ["J. McCrae", "I. Mordatch", "M. Glueck", "A. Khan"], "venue": "In Proceedings of the 2009 symposium on Interactive 3D graphics and games,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2009}, {"title": "Interactive furniture layout using interior design guidelines", "author": ["P. Merrell", "E. Schkufza", "Z. Li", "M. Agrawala", "V. Koltun"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2011}, {"title": "When it gets more difficult, use both hands: exploring bimanual curve manipulation", "author": ["R. Owen", "G. Kurtenbach", "G. Fitzmaurice", "T. Baudel", "B. Buxton"], "venue": "In Proceedings of Graphics Interface", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2005}, {"title": "Learning spatial relationships between objects", "author": ["B. Rosman", "S. Ramamoorthy"], "venue": "IJRR", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "Real-time automatic 3D scene generation from natural language voice and text descriptions", "author": ["L.M. Seversky", "L. Yin"], "venue": "In Proceedings of the 14th annual ACM international conference on Multimedia", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2006}], "referenceMentions": [{"referenceID": 12, "context": "There is much work on input methodologies and schemes for easing navigation in 3D [14, 15] and manipulation of primitives such as curves [17].", "startOffset": 82, "endOffset": 90}, {"referenceID": 13, "context": "There is much work on input methodologies and schemes for easing navigation in 3D [14, 15] and manipulation of primitives such as curves [17].", "startOffset": 82, "endOffset": 90}, {"referenceID": 15, "context": "There is much work on input methodologies and schemes for easing navigation in 3D [14, 15] and manipulation of primitives such as curves [17].", "startOffset": 137, "endOffset": 141}, {"referenceID": 4, "context": "Recent work has explored the avenue of parsing natural language for design problem definitions in the context of mechanical computer-aided design software [5].", "startOffset": 155, "endOffset": 158}, {"referenceID": 6, "context": "Another line of work focuses on defining higher-level semantic APIs for scripting 3D animations and storyboards [7, 13].", "startOffset": 112, "endOffset": 119}, {"referenceID": 11, "context": "Another line of work focuses on defining higher-level semantic APIs for scripting 3D animations and storyboards [7, 13].", "startOffset": 112, "endOffset": 119}, {"referenceID": 5, "context": "We are closer to early seminal work in placing simple geometric objects in 3D through textual commands [6].", "startOffset": 103, "endOffset": 106}, {"referenceID": 3, "context": "[4] have demonstrated a novel 3D model design interface where users can control the desired values of high-level semantic attributes (e.", "startOffset": 0, "endOffset": 3}, {"referenceID": 14, "context": "These energy functions are encoded from interior design guidelines [16] or learned from input scene data [10].", "startOffset": 67, "endOffset": 71}, {"referenceID": 8, "context": "These energy functions are encoded from interior design guidelines [16] or learned from input scene data [10].", "startOffset": 105, "endOffset": 109}, {"referenceID": 9, "context": "Methods to learn scene structure have been demonstrated using various data sources including simulation of human agents in 3D scenes [11, 12], and analysis of supporting contact points in scanned environments [18].", "startOffset": 133, "endOffset": 141}, {"referenceID": 10, "context": "Methods to learn scene structure have been demonstrated using various data sources including simulation of human agents in 3D scenes [11, 12], and analysis of supporting contact points in scanned environments [18].", "startOffset": 133, "endOffset": 141}, {"referenceID": 16, "context": "Methods to learn scene structure have been demonstrated using various data sources including simulation of human agents in 3D scenes [11, 12], and analysis of supporting contact points in scanned environments [18].", "startOffset": 209, "endOffset": 213}, {"referenceID": 5, "context": "The SHRDLU [20] and PUT [6] systems were pioneers in parsing natural language instructions, but generalization of their approach to more realistic scenarios similar to the real world is challenging.", "startOffset": 24, "endOffset": 27}, {"referenceID": 7, "context": "More recent work on the WordsEye system [8, 9] and other similar approaches [19] has demonstrated more general text-driven 3D scene generation that can handle complex scenes.", "startOffset": 40, "endOffset": 46}, {"referenceID": 17, "context": "More recent work on the WordsEye system [8, 9] and other similar approaches [19] has demonstrated more general text-driven 3D scene generation that can handle complex scenes.", "startOffset": 76, "endOffset": 80}, {"referenceID": 2, "context": "[3] have demonstrated how linguistic and non-linguistic spatial knowledge can be learned directly from existing scene data and leveraged when parsing natural language.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "Based on the systems presented in [2, 3], we frame the interactive text-to-scene problem in a probabilistic formulation that covers both scene generation and interactive scene operations.", "startOffset": 34, "endOffset": 40}, {"referenceID": 2, "context": "Based on the systems presented in [2, 3], we frame the interactive text-to-scene problem in a probabilistic formulation that covers both scene generation and interactive scene operations.", "startOffset": 34, "endOffset": 40}, {"referenceID": 2, "context": "[3] and we use the same corpus of 3D scenes and component 3D models, consisting of about 12,490 mostly indoor objects with associated textual categories and tags.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3]\u2019s approach to make explicit the information necessary for connecting higher-level semantics to the lower-level geometric representations.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] represents P (t|u) as a delta probability at the selected t.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] to process the input text using the Stanford CoreNLP pipeline1, identify visualizable objects, physical properties of the objects, and extract dependency patterns for spatial relations between the objects.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "We also establish an upperbound baseline by asking people to manually design scenes corresponding to the same descriptions, using a simple scene design interface used in prior work [10].", "startOffset": 181, "endOffset": 185}, {"referenceID": 0, "context": "We used the lme4 R package and optimized for maximum loglikelihood [1].", "startOffset": 67, "endOffset": 70}], "year": 2017, "abstractText": "Designing 3D scenes is currently a creative task that requires significant expertise and effort in using complex 3D design interfaces. This effortful design process starts in stark contrast to the easiness with which people can use language to describe real and imaginary environments. We present SCENESEER: an interactive text to 3D scene generation system that allows a user to design 3D scenes using natural language. A user provides input text from which we extract explicit constraints on the objects that should appear in the scene. Given these explicit constraints, the system then uses a spatial knowledge base learned from an existing database of 3D scenes and 3D object models to infer an arrangement of the objects forming a natural scene matching the input description. Using textual commands the user can then iteratively refine the created scene by adding, removing, replacing, and manipulating objects. We evaluate the quality of 3D scenes generated by SCENESEER in a perceptual evaluation experiment where we compare against manually designed scenes and simpler baselines for 3D scene generation. We demonstrate how the generated scenes can be iteratively refined through simple natural language commands. INTRODUCTION Designing 3D scenes is a challenging creative task. Expert users expend considerable effort in learning how to use complex 3D scene design tools. Still, immense manual effort is required, leading to high costs for producing 3D content in video games, films, interior design, and architectural visualization. Despite the conceptual simplicity of generating pictures from descriptions, systems for text-to-scene generation have only achieved limited success. How might we allow people to create 3D scenes using simple natural language? Current 3D design tools provide a great amount of control over the construction and precise positioning of geometry within 3D scenes. However, most of these tools do not allow for intuitively assembling a scene from existing objects which is critical for non-professional users. As an analogue, in real life few people are carpenters, but most of us have bought and arranged furniture. For the purposes of defining how to compose and arrange objects into scenes, natural language is an obvious interface. It is much easier to say \u201cPut a blue bowl on the dining table\u201d rather than retrieving, inserting and orienting a 3D model of a bowl. Text to 3D scene interfaces can empower a broader demographic to create 3D scenes for games, interior design, and virtual storyboarding. Text to 3D scene systems face several technical challenges. Firstly, natural language is typically terse and incomplete. People rarely mention many facts about the world since these facts can often be safely assumed. Most desks are upright and on the floor but few people would mention this explicitly. This implicit spatial knowledge is critical for scene generation but hard to extract. Secondly, people reason about the 1 ar X iv :1 70 3. 00 05 0v 1 [ cs .G R ] 2 8 Fe b 20 17 world at a much higher level than typical representations of 3D scenes (using the descriptive phrase table against wall vs a 3D transformation matrix). The semantics of objects and their approximate arrangement are typically more important than the precise and abstract properties of geometry. Most 3D scene design tools grew out of the traditions of Computer Aided Design and architecture where precision of control and specification is much more important than for casual users. Traditional interfaces allow for comprehensive control but are typically not concerned with high level semantics. SCENESEER allows users to generate and manipulate 3D scenes at the level of everyday semantics through simple natural language. It leverages spatial knowledge priors learned from existing 3D scene data to infer implicit, unmentioned constraints and resolve view-dependent spatial relations in a natural way. For instance, given the sentence \u201cthere is a dining table with a cake\u201d, we can infer that the cake is most likely on a plate and that the plate is most likely on the table. This elevation of 3D scene design to the level of everyday semantics is critical for enabling intuitive design interfaces, rapid prototyping, and coarse-to-fine refinements. In this paper, we present a framework for the text to 3D scene task and use it to motivate the design of the SCENESEER system. We demonstrate that SCENESEER can be used to generate 3D scenes from terse, natural language descriptions. We empirically evaluate the quality of the generated scenes with a human judgment experiment and find that SCENESEER can generate high quality scenes matching the input text. We show how textual commands can be used interactively in SCENESEER to manipulate generated 3D scenes.", "creator": "LaTeX with hyperref package"}}}