{"id": "1703.00391", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Mar-2017", "title": "A Hypercat-enabled Semantic Internet of Things Data Hub: Technical Report", "abstract": "an increasing weekly amount of information internally is generated from the rapidly increasing number of sensor networks and smart devices. a wide variety of sources could generate and publish information in different formats, thus highlighting interoperability as one of the key prerequisites for the success of internet of things ( iot ). the bt uk hypercat resource data hub provides a focal point goal for the sharing and consumption of available datasets from a wide range of sources. later in this work, we propose a semantic enrichment of the bt hypercat data hub, using well - accepted semantic web standards and tools. we secondly propose an ontology that captures the semantics of the imported data and present the bt sparql endpoint by means of creating a mapping between sparql and sql queries. furthermore, federated sparql queries allow queries over multiple hub - based and external data sources. finally, we provide two use cases in order to illustrate the advantages sometimes afforded by our semantic approach.", "histories": [["v1", "Wed, 1 Mar 2017 17:10:27 GMT  (424kb,D)", "https://arxiv.org/abs/1703.00391v1", "Technical report of an accepted ESWC-2017 paper"], ["v2", "Sun, 12 Mar 2017 13:18:29 GMT  (573kb,D)", "http://arxiv.org/abs/1703.00391v2", "Technical report of an accepted ESWC-2017 paper"]], "COMMENTS": "Technical report of an accepted ESWC-2017 paper", "reviews": [], "SUBJECTS": "cs.AI cs.DB", "authors": ["ilias tachmazidis", "sotiris batsakis", "john davies", "alistair duke", "mauro vallati", "grigoris antoniou", "sandra stincic clarke"], "accepted": false, "id": "1703.00391"}, "pdf": {"name": "1703.00391.pdf", "metadata": {"source": "CRF", "title": "A Hypercat-enabled Semantic Internet of Things Data Hub: Technical Report", "authors": ["Ilias Tachmazidis", "Sotiris Batsakis", "John Davies", "Alistair Duke", "Mauro Vallati", "Grigoris Antoniou", "Sandra Stincic Clarke"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The emerging notion of a smart city is based on the use of technology in order to improve the efficiency, effectiveness and capability of various city services, thus improving the quality of the inhabitants\u2019 lives [14]. A fundamental difference between smart cities and similar uses of technology in other areas, such as business, government or education, is the vast variety of the technologies used, the types and volumes of data, and the services and applications targeted [5]. Thus, developing successful smart city solutions requires the collection and maintenance of relevant data in the form of IoT data.\nOver the past few years, eight industry-led projects were funded by Innovate UK3 (the UK\u2019s innovation agency) to deliver IoT \u2018clusters\u2019, each centred around a data hub to aggregate and expose data feeds from multiple sensor types. The system that has come to be known as the BT\n3 https://www.gov.uk/government/organisations/innovate-uk\nar X\niv :1\n70 3.\n00 39\n1v 2\n[ cs\n.A I]\n1 2\nM ar\n2 01\n7\nHypercat Data Hub was part of the Internet of Things Ecosystem Demonstrator4 programme.\nAddressing interoperability by focusing on how interoperability could be achieved between data hubs in different domains was a major objective of the programme. Hence, Hypercat [1] was developed, which is a standard for representing and exposing Internet of Things data hub catalogues [6] over web technologies, to improve data discoverability and interoperability. Recent work [13], proposed a semantic enrichment for the core of the Hypercat specification, namely an RDF-based [8] equivalent for a JSON-based catalogue. Other IoT / smart city projects include Barcelona5, MK:Smart6 which uses the BT Hypercat Data Hub that is Hypercat-enabled but not semantically enriched, and the D-CAT7 catalogue approach from W3C.\nThe main objective of this work is to achieve the semantic enrichment [2] of the data in the BT Hypercat Data Hub and to provide access to the enriched data through a SPARQL endpoint [11]. Furthermore, adding reasoning capabilities and the ability to combine external data sources using federated queries are important aspects of the implemented system.\nThe BT Hypercat Data Hub provides a focal point for the sharing and consumption of available datasets from a wide range of sources. In order to enable rapid responses, data in the BT Hypercat Data Hub is stored in relational databases. In this work, sensor, event, and location databases, i.e., databases containing information about sensor readings, events and locations are used. In order to provide a semantically richer mechanism of accessing the available datasets, the BT Hypercat Ontology was developed in order to lift semantically data stored within the relational databases. In addition, data translation through output adapters and SPARQL endpoints was defined. Thus, the semantically enriched data can be queried by accessing the developed BT SPARQL Endpoint.\nTriplestores contain the information in RDF format combined with a built-in SPARQL endpoint. Thus, triplestores are commonly used for providing SPARQL endpoints. However, as data in the BT Hypercat Data Hub is stored in relational databases and this data is frequently updated, a more dynamic solution has been adopted. Thus, instead of copying\n4 https://connect.innovateuk.org/web/internet-of-things-ecosystem-demonstrator/\noverview 5 http://ibarcelona.bcn.cat/en/smart-cities 6 http://www.mksmart.org 7 https://www.w3.org/TR/vocab-dcat/\nthe existing data into a triplestore, submitted SPARQL queries are dynamically translated into a set of SQL queries on top of the existing relational databases. In this way, a fully functioning SPARQL endpoint is provided, while during query execution, not only the SPARQL query itself is taken into consideration, but also the implicit information that is derived through reasoning over the developed ontology.\nThis work is organized as follows: Section 2 contains background information about the BT Hypercat Data Hub prior to its semantic enrichment. Section 3 contains a description of the BT Hypercat Ontology which was developted in this work in order to define the semantic representation of existing data. The corresponding mapping of data from a relational database to the semantic representation is described in Section 4. The BT SPARQL Endpoint is presented in Section 5 and the capability to combine information from external data sources by means of federated queries is presented in Section 6. Example use cases for the BT Hypercat Data Hub are illustrated in Section 7, while conclusions and future work are discussed in Section 8."}, {"heading": "2 Background", "text": "The role of the BT Hypercat Data Hub is to enable information from a wide range of sources to be brought onto a common platform and presented to users and developers in a consistent way. Its portal provides a direct interface through which data consumers, such as app developers, can browse a data catalogue and select and subscribe to data feeds that they want to use. In addition, a JSON-based Hypercat [1] machinereadable catalogue, described further below, is also provided (as well as a recently proposed RDF-based Hypercat [13] catalogue). An API enables access to data feeds, secured by API keys, from browsers or within computer programs, while a relational, GIS capable, database enables complex queries that data can be filtered according to a wide range of criteria.\nA set of edge adapters enables information coming onto the hub to be converted to a standard format for use inside the platform\u2019s core. It also provides a consistent API to end users and developers. The hub provides a consistent approach to integration between data exposed by sensors, systems and individuals via communication networks and the applications that can use derived information to improve decision making, e.g., in control systems. It includes a set of adapters for ingress (input) and egress (output). These are potentially specific to each data source or\napplication feed and may be implemented on a case by case basis. There is therefore a need to translate data between arbitrary external formats and the data formats used internally.\nIn addition, as mentioned above, a Hypercat catalogue is implemented which is included via the Hypercat API. Hypercat is in essence a standard for representing and exposing Internet of Things data hub catalogues over web technologies, to improve data discoverability and interoperability. The idea is to enable distributed data repositories (data hubs) to be used jointly by applications through making it possible to query their catalogues in a uniform machine readable format. This enables the creation of knowledge graphs of available datasets across multiple hubs that applications can exploit and query to identify and access the data they need, whatever the data hub in which they are held.\nFrom this perspective, Hypercat represents a pragmatic starting point to solving the issues of managing multiple data sources, aggregated into multiple data hubs, through linked data and semantic web approaches. It incorporates a lightweight, JSON-based approach based on a technology stack used by a large population of web developers and as such offers a low barrier to entry. Hypercat allows a server (IoT hub) to provide a set of resources to a client, each with a set of metadata annotations. There are a small set of core mandatory metadata relations which a valid Hypercat catalogue must include; beyond this, implementers are free to use any set of annotations to suit their needs."}, {"heading": "3 BT Hypercat Ontology", "text": "In our previous work [13], we proposed a semantic enrichment for the core of the Hypercat specification, namely an RDF-based equivalent for a JSON-based catalogue. While Hypercat offers a syntactic first step, providing semantically enriched data goes further by allowing the unique identification of existing resources, interoperability across various domains and further enrichment by combining internally stored data with the Linked Open Data (LOD) cloud8. Data enrichment in the BT Hypercat Data Hub is achieved by representing data in RDF using concepts and properties defined in an OWL ontology [9]. Figure 1 shows the top level concepts of the BT Hypercat Ontology and how the BT Hypercat Ontology extends the core of the Hypercat specification, following the proposed guidelines in [13].\n8 http://lod-cloud.net/\nFeed is the top level class for any data feed that is asserted in the knowledge base. It contains the semantic properties of feeds. These include the feed id, creator, update date, title, url, status, description, location name, domain and disposition. There are also subclasses of class Feed, namely: SensorFeed, EventFeed and LocationFeed representing feeds for sensors, events and locations respectively.\nThe modelled data has been incorporated in the BT Hypercat Data Hub as one of the following feed types: (a) SensorFeed, (b) EventFeed, and (c) LocationFeed. Practically, each data source can advertise available information through the BT Hypercat Data Hub by providing a feed. A feed should be understood as a source of sensor readings, events or locations. Within each feed, data is available through datastreams (a class Datastream is defined, which has two subclasses namely: SensorStream and EventStream representing datastreams for sensors and events respectively). Thus, a given feed may provide a range of datastreams that are closely related e.g., for a weather data feed, different datastreams may provide sensor readings for temperature, humidity and visibility. Considering information about locations, a feed (of type LocationFeed) provides\ninformation directly by returning locations, namely locations are attached to and provided by a given feed.\nA Hypercat online catalogue9,10 contains details of feeds and information sources along with additional metadata such as tags, which allow improved search and discovery. The developed semantic model enables a semantic annotation and linkage of available feeds and datastreams. Thus, both classes Feed and Datastream are modelled as subclasses of class Item (which belongs to the core specification of Hypercat), namely feeds and datastreams are advertised as items of a given catalogue. The BT Hypercat Ontology has been developed and made available with the uri:\nhttp://portal.bt-hypercat.com/ontologies/bt-hypercat"}, {"heading": "4 Data Translation", "text": "In this section we describe how data that is stored in a relational database within the BT Hypercat Data Hub, is made available in RDF."}, {"heading": "4.1 RDF Adapter", "text": "By defining an ontology, semantically enriched data can be provided in RDF format. Note that prior to the semantic enrichment only XML and JSON formats were available. RDF data is represented in N-Triples format since such a format facilitates both storage and processing of data. Thus, each RDF triple is provided within a single line, in the following format: \u201c<subject> <predicate> <object> .\u201d, while a collection of RDF triples is stored as a collection of lines. Note that N-Triples format can easily be transformed into other valid RDF formats, such as RDF/XML. In addition, the generated knowledge base can also be loaded in any given triplestore, namely any given RDF knowledge base, in order to facilitate operations such as query answering. Thus, by following W3C standards interoperability is ensured and the utilization of existing tools and applications is enabled.\nThe BT Hypercat Data Hub includes additional adapters for egress (output) in order to provide data in RDF format. In the following, examples of how subject, predicate and object are generated for feeds and datastreams, are presented. Initially, the URI of each SensorFeed is generated, namely:\n9 http://portal.bt-hypercat.com/cat 10 http://portal.bt-hypercat.com/cat-rdf\n<http://api.bt-hypercat.com/sensors/feeds/feedID>\nNote that \u201chttp://api.bt-hypercat.com/\u201d is the prefix URI for any data provided by the BT Hypercat Data Hub. In addition, \u201c/sensors\u201d provides information about the type of the feed (here SensorFeed), followed by \u201c/feeds\u201d, which indicates that this URI belongs to a resource describing a feed, and finally \u201c/feedID\u201d is an id that uniquely identifies the given feed. For each SensorFeed, the BT Hypercat Data Hub provides its type, namely:\nSubject <http://api.bt-hypercat.com/sensors/feeds/feedID> Predicate <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> Object <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#SensorFeed>\nEach data property of SensorFeed provides information in the following form (here is an example for property feed id, other data properties are modelled in a similar fashion):\nSubject <http://api.bt-hypercat.com/sensors/feeds/feedID> Predicate <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#feed id> Object \u201cfeedID\u201d\u2227\u2227<http://www.w3.org/2001/ XMLSchema#string>\nThe URI of a given SensorStream is generated as an extension of the URI of the SensorFeed it belongs to, namely:\n<http://api.bt-hypercat.com/sensors/feeds/feedID/datastreams/datastreamID>\nHere, \u201c/datastreams\u201d indicates that this URI belongs to a resource describing a datastream, and \u201c/datastreamID\u201d is the identifier of the given datastream. Thus, for each SensorStream, the BT Hypercat Data Hub provides its type, namely:\nSubject <http://api.bt-hypercat.com/sensors/feeds/feedID/ datastreams/datastreamID> Predicate <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> Object <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#SensorStream>\nIn addition, the fact that a given feed has a given datastream needs to be semantically annotated, namely the relation between SensorFeed and SensorStream is defined as follows:\nSubject <http://api.bt-hypercat.com/sensors/feeds/feedID> Predicate <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#hasSensorStream> Object <http://api.bt-hypercat.com/sensors/feeds/feedID/ datastreams/datastreamID>\nIn a similar way as for SensorFeed, SensorStream provides additional information through data properties (here is an example for property datastream id, other data properties are modelled in a similar fashion):\nSubject <http://api.bt-hypercat.com/sensors/feeds/feedID/ datastreams/datastreamID> Predicate <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#datastream id> Object \u201cdatastreamID\u201d\u2227\u2227<http://www.w3.org/2001/ XMLSchema#string>\nA URI for EventFeed is generated in a similar way as a URI for SensorFeed, namely:\n<http://api.bt-hypercat.com/events/feeds/feedID>\nNote that the main difference is that \u201c/sensors\u201d is substituted by \u201c/events\u201d. Thus, for each EventFeed, the BT Hypercat Data Hub provides its type, namely:\nSubject <http://api.bt-hypercat.com/events/feeds/feedID> Predicate <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> Object <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#EventFeed>\nEach data property of EventFeed provides information in the following form (here is an example for property feed id, other data properties are modelled in a similar fashion):\nSubject <http://api.bt-hypercat.com/events/feeds/feedID> Predicate <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#feed id> Object \u201cfeedID\u201d\u2227\u2227<http://www.w3.org/2001/ XMLSchema#string>\nA URI for EventStream is generated in a similar way as a URI for SensorStream. The URI of a given EventStream is generated as an extension of the URI of the EventFeed it belongs to, namely:\n<http://api.bt-hypercat.com/events/feeds/feedID/datastreams/datastreamID>\nThus, for each EventStream, the BT Hypercat Data Hub provides its type, namely:\nSubject <http://api.bt-hypercat.com/events/feeds/feedID/ datastreams/datastreamID> Predicate <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> Object <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#EventStream>\nIn addition, the fact that a given feed has a given datastream needs to be semantically annotated, namely the relation between EventFeed and EventStream is defined as follows:\nSubject <http://api.bt-hypercat.com/events/feeds/feedID> Predicate <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#hasEventStream> Object <http://api.bt-hypercat.com/events/feeds/feedID/ datastreams/datastreamID>\nIn a similar way as for EventFeed, EventStream provides additional information through data properties (here is an example for property datastream id, other data properties are modelled in a similar fashion):\nSubject <http://api.bt-hypercat.com/events/feeds/feedID/ datastreams/datastreamID> Predicate <http://portal.bt-hypercat.com/ontologies/ bt-hypercat#datastream id> Object \u201cdatastreamID\u201d\u2227\u2227<http://www.w3.org/2001/ XMLSchema#string>"}, {"heading": "4.2 SPARQL to SQL", "text": "In order to develop a SPARQL to SQL endpoint, Ontop11 [3] was used as an external library. Ontop comes with a Protege12 plug-in that allows the creation of mappings of SPARQL patterns to SQL queries (described below), see Figure 2. In addition, it provides a reasoner that parses the mappings and the ontology, and handles the translation of SPARQL queries into a set of SQL queries in order to return the corresponding results (for\n11 http://ontop.inf.unibz.it/ 12 http://protege.stanford.edu/\nthe SPARQL query). A key advantage of using Ontop is that implicit information that is extracted from the ontology through reasoning is taken into consideration. In this way, semantically richer information compared to the knowledge that is stored in the relational database is provided. A description of how mappings can be created is presented below.\nIn the following, an example of how a SPARQL triple pattern is mapped into a corresponding SQL query is described, and how the retrieved SQL results are used in order to construct RDF triples. Mapping ID corresponds to a unique id for a given mapping, Target (Triple Template) is the RDF triple pattern to be generated (note that SQL variables are given in braces, such as {feed.id}), and Source (SQL Query) is the SQL query to be submitted to the database.\nFirst, the prefixes that are used are defined in order to shorten URIs, for example:\nbt-sensors: http://api.bt-hypercat.com/sensors/ bt-hypercat: http://portal.bt-hypercat.com/ontologies/bt-hypercat#\nThen mappings are defined. For example, the following mapping maps the class SensorFeed. Note that class SensorFeed is subclass of Feed, and thus is a valid assertion, while providing semantically richer information:\nMapping ID mapping:SensorFeed Target (Triple Template) bt-sensors:feeds/{feed.id} a bt-hypercat:SensorFeed . Source (SQL Query) SELECT feed.id FROM feed\nThe following query can be submitted to a SPARQL to SQL endpoint in order to retrieve Feeds:\nPREFIX hypercat: <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}> SELECT DISTINCT ?s WHERE{ ?s a hypercat:Feed . }\nThus, Ontop will match the triple pattern \u201c?s a hypercat:Feed\u201d with the mapping \u201cmapping:SensorFeed\u201d since class SensorFeed is subclass of Feed. An SQL query (see Source) will be submitted to the relational database, while the retrieved ids (feed.id) will be used in order to generate RDF triples following the triple template (see Target).\nThe reader is referred to [3] for more details on the internal functionality of Ontop. Note that the generation of other triples follows a similar rational, while a detailed description of triple generation for a given concept or property can be found in Appendix A."}, {"heading": "5 BT SPARQL Endpoint", "text": "In the following, a description of the high level architecture for the developed BT SPARQL Endpoint is presented. As shown in Figure 3, two levels of abstraction are applied. At the lower level, there is a SPARQL to SQL endpoint for each relational database in the system, namely each SPARQL to SQL endpoint provides a SPARQL endpoint on top of the given relational database. In this way, the system administrator can add or remove a SPARQL to SQL endpoint at any time.\nAt the moment, a SPARQL to SQL component is supporting the translation of SPARQL queries to PostgreSQL13 relational databases that contain information about sensors or events. At the higher level, there is\n13 https://www.postgresql.org/\nonly one SPARQL to SPARQL component (based on the query engine of Apache Jena14 [4]), which is made available to end users. The underlying functionality indicates that end users submit SPARQL queries to the SPARQL to SPARQL endpoint, while the system queries internally all available SPARQL to SQL endpoints in order to extract the relevant information from existing relational databases. At any given point, the system administrator can add or remove a SPARQL to SQL endpoint depending on the available PostgreSQL databases.\nBoth SPARQL to SPARQL and SPARQL to SQL endpoints can be accessed using the BT SPARQL Query Editor, which is available for each endpoint. Users can provide the query text, namely the SPARQL query, as shown in Figure 4. In addition, the BT SPARQL Query Editor supports five results formats: HTML, XML, JSON, CSV and TSV.\nOne of the key advantages of SPARQL queries over SQL queries is that SPARQL queries incorporate semantic reasoning within the returned results. For example, classes EventStream and SensorStream are subclasses of class Datastream. Thus, the reasoner classifies all objects that belong to either EventStream or SensorStream as Datastream. The following query can be submitted to a SPARQL to SPARQL endpoint in order to retrieve Datastreams:\nPREFIX hypercat: <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}> SELECT DISTINCT ?s WHERE{ ?s a hypercat:Datastream . }\n14 https://jena.apache.org/index.html\nNote that Ontop supports reasoning over RDFS15 and OWL 2 QL16."}, {"heading": "6 Federated Querying", "text": "As described above, a Federated SPARQL endpoint has been added in order to enable federated queries over both the BT SPARQL Endpoint and other external SPARQL endpoints that are available through the LOD cloud. Such external SPARQL endpoints that are part of the LOD cloud are for example: DBPedia17, FactForge18, OpenUpLabs19 and the European Environment Agency20.\nThe LOD cloud is expanding and new SPARQL endpoints are added (and removed) allowing for access to new data. Since the Federated SPARQL endpoint does not contain any information itself, it serves as a middle-\n15 http://www.w3.org/TR/rdf-schema/ 16 https://www.w3.org/TR/owl-profiles/#OWL_2_QL 17 http://dbpedia.org/sparql 18 http://factforge.net/sparql 19 http://gov.tso.co.uk/transport/sparql 20 http://semantic.eea.europa.eu/sparql\nware that combines information coming from other SPARQL endpoints, as depicted in Figure 5.\nThe Federated SPARQL endpoint extends further the functionality of the BT SPARQL Endpoint since external SPARQL endpoints can be used in order to retrieve information about events or social and economic information that can be combined with data from the BT SPARQL Endpoint for complex data analytics. Examples can be the extraction of data about natural disasters from external datasets combined with related sensor and event data from the BT SPARQL Endpoint. Other types of data extracted from external datasets can be, for example, social data related to housing projects and their correlation with sensor and event data from the BT SPARQL Endpoint.\nReasoning capabilities and spatiotemporal queries can be combined with external datasets (LOD) in order to retrieve information which is not directly represented in the BT Hypercat Data Hub. This can be achieved by means of federated queries spanning over different internal and external SPARQL endpoints.\nFor example, the following federated query retrieves sensor measurements from the BT Hypercat Data Hub related to a specific active bus stop, extracted from an external SPARQL endpoint (OpenUpLabs):\nPREFIX geo: <\\protect\\vrule width0pt\\protect\\href{http://www.w3.org/2003/01/geo/wgs84_pos#}{http://www.w3.org/2003/01/geo/wgs84_pos#}> PREFIX hypercat: <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}> PREFIX naptan: <\\protect\\vrule width0pt\\protect\\href{http://transport.data.gov.uk/def/naptan/}{http://transport.data.gov.uk/def/naptan/}> PREFIX skos: <\\protect\\vrule width0pt\\protect\\href{http://www.w3.org/2004/02/skos/core#}{http://www.w3.org/2004/02/skos/core#}>\nSELECT distinct ?d ?at_time ?western_longitude ?southern_latitude\n?eastern_longitude ?northern_latitude ?stop ?lat ?long\nWHERE {\nSERVICE <\\protect\\vrule width0pt\\protect\\href{http://gov.tso.co.uk/transport/sparql}{http://gov.tso.co.uk/transport/sparql}> {\n?stop a naptan:CustomBusStop;\nnaptan:naptanCode ?naptanCode; naptan:stopValidity ?stopValidity;\nnaptan:street \"Kingswood Road\"; geo:lat ?lat; geo:long ?long.\n?stopValidity naptan:stopStatus ?stopStatus. ?stopStatus skos:prefLabel \"Active\"@en.\n} SERVICE <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/BT-SPARQL-Endpoint/sparql}{http://portal.bt-hypercat.com/BT-SPARQL-Endpoint/sparql}>\n{\n?d a hypercat:Datapoint. ?d hypercat:datapoint_at_time ?at_time. ?d hypercat:datapoint_western_longitude ?western_longitude. ?d hypercat:datapoint_southern_latitude ?southern_latitude. ?d hypercat:datapoint_eastern_longitude ?eastern_longitude. ?d hypercat:datapoint_northern_latitude ?northern_latitude. FILTER (?western_longitude > ?long - 0.1) FILTER (?southern_latitude > ?lat - 0.1) FILTER (?eastern_longitude < ?long + 0.1) FILTER (?northern_latitude < ?lat + 0.1)\n} FILTER(BOUND(?d))\n}\nThe following federated query retrieves events from the BT Hypercat Data Hub that took place close to an airport near London, extracted from an external SPARQL endpoint (FactForge):\nPREFIX geo: <\\protect\\vrule width0pt\\protect\\href{http://www.w3.org/2003/01/geo/wgs84_pos#}{http://www.w3.org/2003/01/geo/wgs84_pos#}> PREFIX prop: <\\protect\\vrule width0pt\\protect\\href{http://dbpedia.org/property/}{http://dbpedia.org/property/}> PREFIX hypercat: <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}> PREFIX omgeo: <\\protect\\vrule width0pt\\protect\\href{http://www.ontotext.com/owlim/geo#}{http://www.ontotext.com/owlim/geo#}> PREFIX dbpediar: <\\protect\\vrule width0pt\\protect\\href{http://dbpedia.org/resource/}{http://dbpedia.org/resource/}> PREFIX dbp-ont: <\\protect\\vrule width0pt\\protect\\href{http://dbpedia.org/ontology/}{http://dbpedia.org/ontology/}> PREFIX ff: <\\protect\\vrule width0pt\\protect\\href{http://factforge.net/}{http://factforge.net/}> PREFIX om: <\\protect\\vrule width0pt\\protect\\href{http://www.ontotext.com/owlim/}{http://www.ontotext.com/owlim/}>\nSELECT distinct ?e ?event_date ?western_longitude ?southern_latitude\n?eastern_longitude ?northern_latitude ?label ?lat ?long\nWHERE {\nSERVICE <\\protect\\vrule width0pt\\protect\\href{http://factforge.net/sparql}{http://factforge.net/sparql}> {\ndbpediar:London geo:lat ?latBase;\ngeo:long ?longBase. ?airport omgeo:nearby(?latBase ?longBase \"50mi\");\na dbp-ont:Airport; ff:preferredLabel ?label; om:hasRDFRank ?RR; geo:lat ?lat; geo:long ?long.\n} SERVICE <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/BT-SPARQL-Endpoint/sparql}{http://portal.bt-hypercat.com/BT-SPARQL-Endpoint/sparql}> {\n?e a hypercat:Event. ?e hypercat:event_sent ?event_date. ?e hypercat:event_western_longitude ?western_longitude. ?e hypercat:event_southern_latitude ?southern_latitude. ?e hypercat:event_eastern_longitude ?eastern_longitude. ?e hypercat:event_northern_latitude ?northern_latitude. FILTER (?western_longitude > ?long - 0.5) FILTER (?southern_latitude > ?lat - 0.5) FILTER (?eastern_longitude < ?long + 0.5) FILTER (?northern_latitude < ?lat + 0.5)\n} FILTER(BOUND(?e))\n}\nThe following federated query retrieves events from the BT Hypercat Data Hub that took place before a pollutant release, extracted from an external SPARQL endpoint (European Environment Agency):\nPREFIX hypercat: <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}{http://portal.bt-hypercat.com/ontologies/bt-hypercat#}> PREFIX xsd: <\\protect\\vrule width0pt\\protect\\href{http://www.w3.org/2001/XMLSchema#}{http://www.w3.org/2001/XMLSchema#}> PREFIX purl: <\\protect\\vrule width0pt\\protect\\href{http://purl.org/dc/terms/}{http://purl.org/dc/terms/}>\nSELECT distinct ?e ?event_date ?western_longitude ?southern_latitude\n?eastern_longitude ?northern_latitude ?t ?date\nWHERE {\nSERVICE <\\protect\\vrule width0pt\\protect\\href{http://semantic.eea.europa.eu/sparql}{http://semantic.eea.europa.eu/sparql}> {\n?s purl:title ?t. ?s purl:issued ?date FILTER(regex(str(?t),\" Pollutant \"))\n}\nSERVICE <\\protect\\vrule width0pt\\protect\\href{http://portal.bt-hypercat.com/BT-SPARQL-Endpoint/sparql}{http://portal.bt-hypercat.com/BT-SPARQL-Endpoint/sparql}> {\n?e a hypercat:Event. ?e hypercat:event_sent ?event_date. ?e hypercat:event_western_longitude ?western_longitude. ?e hypercat:event_southern_latitude ?southern_latitude. ?e hypercat:event_eastern_longitude ?eastern_longitude. ?e hypercat:event_northern_latitude ?northern_latitude. FILTER(BOUND(?e))\n} FILTER(xsd:integer(year(xsd:dateTime(?date))) >\nxsd:integer(year(xsd:dateTime(?event_date))))\n}"}, {"heading": "7 Use Cases", "text": "This section is devoted to the description of two example use cases of the BT Hypercat Data Hub."}, {"heading": "7.1 The SimplifAI Project", "text": "Urban traffic management and control is a primary concern of any city, and urban traffic transport operators often have at their disposal a disparate variety of real time and historical data, traffic controls (the most common of which are traffic signals) and controlling software. Software systems used for traffic management have a vertical design: they are not integrated at a horizontal level and cannot therefore easily share their data, or exploit data provided from other software/sources.\nFor achieving a higher level of data integration, and to better capture and exploit real-time and historical urban data sources, the SimplifAI project was carried out by a consortium consisting of the University of Huddersfield, British Telecommunications, Transport for Greater Manchester, and two other SMEs. In particular, the project focussed on exploiting the real-time and historical data sources to pursue better congestion control. As study area, a region of greater Manchester, UK was selected.\nThe overall concept in the improvement of traffic management was to utilise the semantically enriched data to enable the use of an intelligent function which requires both the integration of traffic data from disparate sources, and the transformation of the data into a predicate logic level, in order to operate. The intelligent function was to create traffic signal\nstrategies in real time to solve challenges caused by exceptional or unexpected conditions.\nThe initial steps of the SimplifAI project concentrated on the semantic enrichment of traffic data. The raw data was taken from a large number of transport and environment sources and integrated into the BT Hypercat Data Hub, using the mapping of Section 4. After that, the focus was put on the utilisation of semantic data for generating traffic control strategies.\nBy enriching semantically the imported data, the unique identification of imported data is enabled. This is orthogonal to the problem solved by planning, as planning can also deal with ad hoc data. However, once the study area expands, using semantically enriched data will allow a systematic way of identifying resources that are mentioned in the generated plans. In addition, federated queries allow the developed system to extract data from the LOD cloud and combine it with data stored in the BT Hypercat Data Hub (e.g., the federated query of Section 6 combines bus stop information from an external source with internally stored data).\nThe intelligent function was based on an Automated Planning [7] approach [15], that is able to generate traffic control strategies (actions which change signals at a specified time) to alleviate traffic congestion caused by exceptional circumstances. The initial state of the modelled urban area, and information about available traffic lights and the struc-\nture of the network, were provided to the planning approach by the BT Hypercat Data Hub. Figure 6 shows the map of the modelled area, in terms of junctions controlled by the planner (red points), links between junctions, and the boundaries of the area (blue dots). Boundaries are sources (destination) of incoming (outcoming) traffic flows. The planner was then executed in order to generate control strategies for a number of test scenarios, which were focussed on handling unexpected events.\nThe quality of the strategies output from the planner was evaluated firstly by hand, inspecting the strategies to check that they were sensible, and by simulating their execution using traffic simulation software. Experts verified that strategies are sensible, and follow what would be expected when using \u201ccommon sense\u201d. Simulations confirmed that generated strategies can effectively deal with unexpected conditions better than standard urban traffic control approaches: on average, the area is de-congested 20% faster, and tail-pipe emissions are reduced by 2.5%."}, {"heading": "7.2 City Concierge", "text": "CityVerve is a Manchester, UK based IoT Demonstrator project, established in July 2016 with a two-year focus on demonstrating the capability of IoT applications for smart cities. One of the use cases of the CityVerve project, City Concierge, is aiming to increase uptake of walking and cycling as a preferred travel mode in Greater Manchester. Currently, Greater Manchester lacks integrated, consistent wayfinding services that can be accessed through a variety of media, including digital and print.\nThe City Concierge aims to develop a city user interface for the city region, integrating transportation and visitor services, allowing users to make informed choices regarding the way they travel. The scope of the use case includes improvements in the way people navigate around the\ncity with a digital solution in conjunction with physical wayfinding assets, see Figures 7 and 8.\nCurrently, it has been established that the BT Hypercat Data Hub provides the required infrastructure and functionality in order to enable the City Concierge. Translating data into RDF enables additional query capabilities such as SPARQL queries on top of the developed system and its combination with the LOD cloud through federated queries. Such queries are vital in order to achieve project\u2019s objectives, which include the deployment of IoT and digital software solutions that seek to address current challenges, while having the flexibility for future solutions to be developed on the network deployed as part of the CityVerve project.\nThe City Concierge use case could be enhanced by the use of SPARQL queries that allow data to be integrated into the application in a much more flexible way. One aim of the City Concierge is to inform travellers about cultural events that are happening in the city. This can be supported by a SPARQL query that queries for events and relies on an ontological reasoning to discover concerts, performances, art shows, exhibitions, etc. which can all be modelled as a subclass of Event in a domain ontology. New types of event would be discovered without knowing in advance what type of event they are. Furthermore a federated SPARQL query could be used to discover local events that are described in a number of different SPARQL endpoints."}, {"heading": "8 Conclusion", "text": "In this work, the semantic enrichment of the BT Hypercat Data Hub has been presented. More specifically, the BT Hypercat Ontology has been introduced, which is the basis for the translation of existing data into an RDF representation. In addition, the BT SPARQL Endpoint has been implemented as a set of SPARQL endpoints and an additional endpoint, called Federated SPARQL endpoint, has been provided in order to allow the execution of federated queries. Moreover, several example federated queries illustrate how the BT Hypercat Data Hub can be connected to the LOD cloud. Finally, two use cases are illustrating the extended functionality of the system, thus highlighting the benefits of the semantic enrichment.\nFuture work includes further semantic enrichment of the implemented system. Specifically, current support for SPARQL queries can be extended in order to enable GeoSPARQL queries [10] so as to provide direct access to spatial information that is currently available in the BT Hypercat Data\nHub. In addition, spatiotemporal reasoning [12] is a prominent direction that could provide richer knowledge by reasoning over data that is coming from both the BT Hypercat Data Hub and the LOD cloud."}, {"heading": "A Appendix", "text": "Here we provide a detailed description of mappings for Feeds and Datastreams. Note that in the developed system, mappings for sensors and events are implemented separately. The following prefixes are used in order to shorten URIs:\nbt-sensors: http://api.bt-hypercat.com/sensors/ bt-events: http://api.bt-hypercat.com/events/ bt-hypercat: http://portal.bt-hypercat.com/ontologies/bt-hypercat# wgs84 pos: http://www.w3.org/2003/01/geo/wgs84 pos#\nThe following mapping maps the class SensorFeed. Note that class SensorFeed is subclass of Feed, and thus is a valid assertion, while providing semantically richer information:\nMapping ID mapping:SensorFeed Target (Triple Template) bt-sensors:feeds/{feed.id} a bt-hypercat:SensorFeed . Source (SQL Query) SELECT feed.id FROM feed\nThe following mapping maps the class EventFeed. Note that class EventFeed is subclass of Feed, and thus is a valid assertion, while providing semantically richer information:\nMapping ID mapping:EventFeed Target (Triple Template) bt-events:feeds/{feed.id} a bt-hypercat:EventFeed . Source (SQL Query) SELECT feed.id FROM feed\nAll data properties of both classes SensorFeed and EventFeed belong to their superclass, namely class Feed. Thus, the mappings for class SensorFeed are provided, while the corresponding mappings for class EventFeed can be defined by substituting the prefix \u201cbt-sensors:\u201d with the prefix \u201cbt-events:\u201d.\nThe following mapping maps the data property feed id of class Feed :\nMapping ID mapping:feed id Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed id {feed.id} . Source (SQL Query) SELECT feed.id FROM feed\nThe following mapping maps the data property feed creator of class Feed :\nMapping ID mapping:feed creator Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed creator {feed.creator} . Source (SQL Query) SELECT feed.id, feed.creator FROM feed\nThe following mapping maps the data property feed updated of class Feed :\nMapping ID mapping:feed updated Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed updated {updated} . Source (SQL Query) SELECT feed.id, TO TIMESTAMP(feed.updated) AS updated FROM feed\nThe following mapping maps the data property feed title of class Feed :\nMapping ID mapping:feed title Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed title {feed.title} . Source (SQL Query) SELECT feed.id, feed.title FROM feed\nThe following mapping maps the data property feed url of class Feed :\nMapping ID mapping:feed url Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed url {feed.url} . Source (SQL Query) SELECT feed.id, feed.url FROM feed\nThe following mapping maps the data property feed status of class Feed :\nMapping ID mapping:feed status Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed status {feed.status} . Source (SQL Query) SELECT feed.id, feed.status FROM feed\nThe following mapping maps the data property feed private of class Feed :\nMapping ID mapping:feed private Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed private {feed.private} . Source (SQL Query) SELECT feed.id, feed.private FROM feed\nThe following mapping maps the data property feed description of class Feed :\nMapping ID mapping:feed description Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed description {feed.description} . Source (SQL Query) SELECT feed.id, feed.description FROM feed\nThe following mapping maps the data property feed icon of class Feed :\nMapping ID mapping:feed icon Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed icon {feed.icon} . Source (SQL Query) SELECT feed.id, feed.icon FROM feed\nThe following mapping maps the data property feed website of class Feed :\nMapping ID mapping:feed website Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed website {feed.website} . Source (SQL Query) SELECT feed.id, feed.website FROM feed\nThe following mapping maps the data property feed email of class Feed :\nMapping ID mapping:feed email Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed email {feed.email} . Source (SQL Query) SELECT feed.id, feed.email FROM feed\nThe following mapping maps the data property feed tag of class Feed :\nMapping ID mapping:feed tag Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed tag {tag} . Source (SQL Query) SELECT feed.id, unnest(feed.tag) AS tag FROM feed\nThe following mapping maps the data property feed location name of class Feed :\nMapping ID mapping:feed location name Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed location name {feed.location name} . Source (SQL Query) SELECT feed.id, feed.location name FROM feed\nThe following mapping maps the data property feed exposure of class Feed :\nMapping ID mapping:feed exposure Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed exposure {feed.exposure} . Source (SQL Query) SELECT feed.id, feed.exposure FROM feed\nThe following mapping maps the data property feed domain of class Feed :\nMapping ID mapping:feed domain Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed domain {feed.dom} . Source (SQL Query) SELECT feed.id, feed.dom FROM feed\nThe following mapping maps the data property feed disposition of class Feed :\nMapping ID mapping:feed disposition Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed disposition {feed.disposition} . Source (SQL Query) SELECT feed.id, feed.disposition FROM feed\nThe following mapping maps the data property feed lat of class Feed as wgs84 pos:lat :\nMapping ID mapping:feed lat Target (Triple Template) bt-sensors:feeds/{feed.id} wgs84 pos:lat {feed.lat} . Source (SQL Query) SELECT feed.id, feed.lat FROM feed\nThe following mapping maps the data property feed lon of class Feed as wgs84 pos:long :\nMapping ID mapping:feed lon Target (Triple Template) bt-sensors:feeds/{feed.id} wgs84 pos:long {feed.lon} . Source (SQL Query) SELECT feed.id, feed.lon FROM feed\nThe following mapping maps the data property feed ele of class Feed as wgs84 pos:alt :\nMapping ID mapping:feed ele Target (Triple Template) bt-sensors:feeds/{feed.id} wgs84 pos:alt {feed.ele} . Source (SQL Query) SELECT feed.id, feed.ele FROM feed\nThe following mapping maps the data property feed the geom of class Feed :\nMapping ID mapping:feed the geom Target (Triple Template) bt-sensors:feeds/{feed.id} bt-hypercat:feed the geom {the geom} . Source (SQL Query) SELECT feed.id, ST AsText(feed.the geom) AS the geom FROM feed\nThe following mapping maps the object property hasSensorStream of class SensorFeed :\nMapping ID mapping:hasSensorStream Target (Triple Template) bt-sensors:feeds/{datastream.feed} bt-hypercat:hasSensorStream bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} . Source (SQL Query) SELECT datastream.feed, datastream.id FROM datastream\nThe following mapping maps the data property hasEventStream of class EventFeed :\nMapping ID mapping:hasEventStream Target (Triple Template) bt-events:feeds/{datastream.feed} bt-hypercat:hasEventStream bt-events:feeds/{datastream.feed}/datastreams/{datastream.id} . Source (SQL Query) SELECT datastream.feed, datastream.id FROM datastream\nThe following mapping maps the class SensorStream. Note that class SensorStream is subclass of Datastream, and thus is a valid assertion, while providing semantically richer information:\nMapping ID mapping:SensorStream Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} a bt-hypercat:SensorStream . Source (SQL Query) SELECT datastream.feed, datastream.id FROM datastream\nThe following mapping maps the class EventStream. Note that class EventStream is subclass of Datastream, and thus is a valid assertion, while providing semantically richer information:\nMapping ID mapping:EventStream Target (Triple Template) bt-events:feeds/{datastream.feed}/datastreams/{datastream.id} a bt-hypercat:EventStream . Source (SQL Query) SELECT datastream.feed, datastream.id FROM datastream\nAll data properties of class EventStream are contained in class SensorStream as well. Thus, these data properties belong to their superclass, namely class Datastream. However, class SensorStream contains additional data properties that do not belong to class EventStream.\nFor data properties datastream id, datastream tag, datastream current time and datastream current value, the mappings for class SensorFeed are provided, while the corresponding mappings for class EventFeed can be defined by substituting the prefix \u201cbt-sensors:\u201d with the prefix \u201cbt-events:\u201d. On the other hand, for data properties datastream max value, datastream min value, datastream unit symbol, datastream unit type and datastream unit text the mappings are provided only for class SensorFeed (these data properties do not belong to class EventStream).\nThe following mapping maps the data property datastream id of class Datastream:\nMapping ID mapping:datastream id Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream id {datastream.id} . Source (SQL Query) SELECT datastream.feed, datastream.id FROM datastream\nThe following mapping maps the data property datastream tag of class Datastream:\nMapping ID mapping:datastream tag Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream tag {tag} . Source (SQL Query) SELECT datastream.feed, datastream.id, unnest(datastream.tag) AS tag FROM datastream\nThe following mapping maps the data property datastream current time of class Datastream:\nMapping ID mapping:datastream current time Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream current time {current time} . Source (SQL Query) SELECT datastream.feed, datastream.id, TO TIMESTAMP(datastream.c time) AS current time FROM datastream\nThe following mapping maps the data property datastream current value of class Datastream:\nMapping ID mapping:datastream current value Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream current value {datastream.c value} . Source (SQL Query) SELECT datastream.feed, datastream.id, datastream.c value FROM datastream\nThe following mapping maps the data property datastream max value of class SensorStream:\nMapping ID mapping:datastream max value Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream max value {datastream.max value} . Source (SQL Query) SELECT datastream.feed, datastream.id, datastream.max value FROM datastream\nThe following mapping maps the data property datastream min value of class SensorStream:\nMapping ID mapping:datastream min value Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream min value {datastream.min value} . Source (SQL Query) SELECT datastream.feed, datastream.id, datastream.min value FROM datastream\nThe following mapping maps the data property datastream unit symbol of class SensorStream:\nMapping ID mapping:datastream unit symbol Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream unit symbol {datastream.unit symbol} . Source (SQL Query) SELECT datastream.feed, datastream.id, datastream.unit symbol FROM datastream\nThe following mapping maps the data property datastream unit type of class SensorStream:\nMapping ID mapping:datastream unit type Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream unit type {datastream.unit type} . Source (SQL Query) SELECT datastream.feed, datastream.id, datastream.unit type FROM datastream\nThe following mapping maps the data property datastream unit text of class SensorStream:\nMapping ID mapping:datastream unit text Target (Triple Template) bt-sensors:feeds/{datastream.feed}/datastreams/{datastream.id} bt-hypercat:datastream unit text {datastream.unit text} . Source (SQL Query) SELECT datastream.feed, datastream.id, datastream.unit text FROM datastream"}], "references": [{"title": "Hypercat 3.00 Specification, 2016", "author": ["Pilgrim Beart"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2016}, {"title": "The Semantic Web", "author": ["Tim Berners-Lee", "James Hendler", "Ora Lassila"], "venue": "Scientific American,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2001}, {"title": "Ontop: Answering SPARQL queries over relational databases", "author": ["Diego Calvanese", "Benjamin Cogrel", "Sarah Komla-Ebri", "Roman Kontchakov", "Davide Lanti", "Martin Rezk", "Mariano Rodriguez-Muro", "Guohui Xiao"], "venue": "Semantic Web,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2017}, {"title": "Jena: implementing the semantic web recommendations", "author": ["Jeremy J Carroll", "Ian Dickinson", "Chris Dollin", "Dave Reynolds", "Andy Seaborne", "Kevin Wilkinson"], "venue": "In Proceedings of the 13th international World Wide Web conference on Alternate track papers & posters,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2004}, {"title": "Smart cities\u2019 data: Challenges and opportunities for semantic technologies", "author": ["Mathieu d\u2019Aquin", "John Davies", "Enrico Motta"], "venue": "IEEE Internet Computing,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "Internet of Things - Why Now", "author": ["John Davies", "Mike Fisher"], "venue": "Jnl Institute of Telecommunications Professionals,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2015}, {"title": "RDF Semantics", "author": ["Patrick Hayes"], "venue": "In W3C Recommendation,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2004}, {"title": "OWL 2 Web Ontology Language: Primer", "author": ["Pascal Hitzler", "Markus Kr\u00f6tzsch", "Bijan Parsia", "Peter F. Patel-Schneider", "Sebastian Rudolph", "editors"], "venue": "W3C Recommendation,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2009}, {"title": "OGC GeoSPARQL-A geographic query language for RDF data", "author": ["Matthew Perry", "John Herring"], "venue": "OGC Implementation Standard. Sept,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "SPARQL query language for RDF", "author": ["Eric PrudHommeaux", "Andy Seaborne"], "venue": "W3C recommendation,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2008}, {"title": "SOWL QL: Querying Spatio-Temporal Ontologies in OWL", "author": ["Konstantinos Stravoskoufos", "Euripides GM Petrakis", "Nikolaos Mainas", "Sotirios Batsakis", "Vasilis Samoladas"], "venue": "Journal on Data Semantics,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2016}, {"title": "Hypercat RDF: Semantic Enrichment for IoT", "author": ["Ilias Tachmazidis", "John Davies", "Sotiris Batsakis", "Grigoris Antoniou", "Alistair Duke", "Sandra Stincic Clarke"], "venue": "In Semantic Technology - 6th Joint International Conference,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2016}, {"title": "Smart Cities: Big Data, Civic Hackers, and the Quest for a New Utopia", "author": ["A.M. Townsend"], "venue": "WW Norton & Company,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2013}], "referenceMentions": [{"referenceID": 12, "context": "The emerging notion of a smart city is based on the use of technology in order to improve the efficiency, effectiveness and capability of various city services, thus improving the quality of the inhabitants\u2019 lives [14].", "startOffset": 214, "endOffset": 218}, {"referenceID": 4, "context": "A fundamental difference between smart cities and similar uses of technology in other areas, such as business, government or education, is the vast variety of the technologies used, the types and volumes of data, and the services and applications targeted [5].", "startOffset": 256, "endOffset": 259}, {"referenceID": 0, "context": "Hence, Hypercat [1] was developed, which is a standard for representing and exposing Internet of Things data hub catalogues [6] over web technologies, to improve data discoverability and interoperability.", "startOffset": 16, "endOffset": 19}, {"referenceID": 5, "context": "Hence, Hypercat [1] was developed, which is a standard for representing and exposing Internet of Things data hub catalogues [6] over web technologies, to improve data discoverability and interoperability.", "startOffset": 124, "endOffset": 127}, {"referenceID": 11, "context": "Recent work [13], proposed a semantic enrichment for the core of the Hypercat specification, namely an RDF-based [8] equivalent for a JSON-based catalogue.", "startOffset": 12, "endOffset": 16}, {"referenceID": 6, "context": "Recent work [13], proposed a semantic enrichment for the core of the Hypercat specification, namely an RDF-based [8] equivalent for a JSON-based catalogue.", "startOffset": 113, "endOffset": 116}, {"referenceID": 1, "context": "The main objective of this work is to achieve the semantic enrichment [2] of the data in the BT Hypercat Data Hub and to provide access to the enriched data through a SPARQL endpoint [11].", "startOffset": 70, "endOffset": 73}, {"referenceID": 9, "context": "The main objective of this work is to achieve the semantic enrichment [2] of the data in the BT Hypercat Data Hub and to provide access to the enriched data through a SPARQL endpoint [11].", "startOffset": 183, "endOffset": 187}, {"referenceID": 0, "context": "In addition, a JSON-based Hypercat [1] machinereadable catalogue, described further below, is also provided (as well as a recently proposed RDF-based Hypercat [13] catalogue).", "startOffset": 35, "endOffset": 38}, {"referenceID": 11, "context": "In addition, a JSON-based Hypercat [1] machinereadable catalogue, described further below, is also provided (as well as a recently proposed RDF-based Hypercat [13] catalogue).", "startOffset": 159, "endOffset": 163}, {"referenceID": 11, "context": "In our previous work [13], we proposed a semantic enrichment for the core of the Hypercat specification, namely an RDF-based equivalent for a JSON-based catalogue.", "startOffset": 21, "endOffset": 25}, {"referenceID": 7, "context": "Data enrichment in the BT Hypercat Data Hub is achieved by representing data in RDF using concepts and properties defined in an OWL ontology [9].", "startOffset": 141, "endOffset": 144}, {"referenceID": 11, "context": "Figure 1 shows the top level concepts of the BT Hypercat Ontology and how the BT Hypercat Ontology extends the core of the Hypercat specification, following the proposed guidelines in [13].", "startOffset": 184, "endOffset": 188}, {"referenceID": 2, "context": "In order to develop a SPARQL to SQL endpoint, Ontop11 [3] was used as an external library.", "startOffset": 54, "endOffset": 57}, {"referenceID": 2, "context": "The reader is referred to [3] for more details on the internal functionality of Ontop.", "startOffset": 26, "endOffset": 29}, {"referenceID": 3, "context": "only one SPARQL to SPARQL component (based on the query engine of Apache Jena14 [4]), which is made available to end users.", "startOffset": 80, "endOffset": 83}, {"referenceID": 8, "context": "Specifically, current support for SPARQL queries can be extended in order to enable GeoSPARQL queries [10] so as to provide direct access to spatial information that is currently available in the BT Hypercat Data", "startOffset": 102, "endOffset": 106}, {"referenceID": 10, "context": "In addition, spatiotemporal reasoning [12] is a prominent direction that could provide richer knowledge by reasoning over data that is coming from both the BT Hypercat Data Hub and the LOD cloud.", "startOffset": 38, "endOffset": 42}], "year": 2017, "abstractText": "An increasing amount of information is generated from the rapidly increasing number of sensor networks and smart devices. A wide variety of sources generate and publish information in different formats, thus highlighting interoperability as one of the key prerequisites for the success of Internet of Things (IoT). The BT Hypercat Data Hub provides a focal point for the sharing and consumption of available datasets from a wide range of sources. In this work, we propose a semantic enrichment of the BT Hypercat Data Hub, using well-accepted Semantic Web standards and tools. We propose an ontology that captures the semantics of the imported data and present the BT SPARQL Endpoint by means of a mapping between SPARQL and SQL queries. Furthermore, federated SPARQL queries allow queries over multiple hub-based and external data sources. Finally, we provide two use cases in order to illustrate the advantages afforded by our semantic approach.", "creator": "LaTeX with hyperref package"}}}