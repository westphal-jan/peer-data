{"id": "1703.04912", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Mar-2017", "title": "Syntax-Preserving Belief Change Operators for Logic Programs", "abstract": "recent methods have adapted the well - established agm and belief difference base frameworks for belief change foundations to cover the belief revision in logic programs. in this study here, we present two new sets of associated belief change operators for logic r programs. they focus on preserving understanding the explicit relationships expressed in the rules of a program, a feature mechanism that is missing in purely semantic approaches that consider programs only in their entirety. secondly in particular, operators of the latter class fail to satisfy preservation and intuitive support, two important inherent properties for belief change in logic programs required to ensure intuitive results.", "histories": [["v1", "Wed, 15 Mar 2017 03:53:25 GMT  (93kb)", "https://arxiv.org/abs/1703.04912v1", "44 pages, submitted to ACM Transactions on Computational Logic"], ["v2", "Fri, 17 Mar 2017 00:56:18 GMT  (93kb)", "http://arxiv.org/abs/1703.04912v2", "44 pages, submitted to ACM Transactions on Computational Logic"]], "COMMENTS": "44 pages, submitted to ACM Transactions on Computational Logic", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["sebastian binnewies", "zhiqiang zhuang", "kewen wang", "bela stantic"], "accepted": false, "id": "1703.04912"}, "pdf": {"name": "1703.04912.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["ZHIQIANG ZHUANG", "KEWEN WANG", "Sebastian Binnewies", "Zhiqiang Zhuang", "Kewen Wang"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n70 3.\n04 91\n2v 2\n[ cs\n.A I]\n1 7\nM ar\n2 01\n7\n00\nSyntax-Preserving Belief Change Operators for Logic Programs\nSEBASTIAN BINNEWIES, Griffith University ZHIQIANG ZHUANG, Griffith University KEWEN WANG, Griffith University BELA STANTIC, Griffith University\nRecent methods have adapted the well-established AGM and belief base frameworks for belief change to cover belief revision in logic programs. In this study here, we present two new sets of belief change operators for logic programs. They focus on preserving the explicit relationships expressed in the rules of a program, a feature that is missing in purely semantic approaches that consider programs only in their entirety. In particular, operators of the latter class fail to satisfy preservation and support, two important properties for belief change in logic programs required to ensure intuitive results.\nWe address this shortcoming of existing approaches by introducing partial meet and ensconcement constructions for logic program belief change, which allow us to define syntax-preserving operators that satisfy preservation and support. Our work is novel in that our constructions not only preserve more information from a logic program during a change operation than existing ones, but they also facilitate natural definitions of contraction operators, the first in the field to the best of our knowledge.\nIn order to evaluate the rationality of our operators, we translate the revision and contraction postulates from the AGM and belief base frameworks to the logic programming setting. We show that our operators fully comply with the belief base framework and formally state the interdefinability between our operators. We further propose an algorithm that is based on modularising a logic program to reduce partial meet and ensconcement revisions or contractions to performing the operation only on the relevant modules of that program. Finally, we compare our approach to two state-of-the-art logic program revision methods and demonstrate that our operators address the shortcomings of one and generalise the other method.\nCCS Concepts: rComputing methodologies \u2192 Logic programming and answer set programming; Nonmonotonic, default reasoning and belief revision; rTheory of computation \u2192 Constraint and logic programming;\nAdditional Key Words and Phrases: Logic Program, Belief Change, Strong Equivalence, Answer Set\nACM Reference Format: Sebastian Binnewies, Zhiqiang Zhuang, Kewen Wang, and Bela Stantic 2017. Syntax-Preserving Belief Change Operators for Logic Programs. ACM Trans. Embedd. Comput. Syst. 0, 0, Article 00 (March 2000), 44 pages. DOI: 0000001.0000001"}, {"heading": "1. INTRODUCTION", "text": "A key ingredient for any machine to be considered \u2018artificially intelligent\u2019 is a system to represent and reason about knowledge in the application domain of interest [McCarthy 1958]. In analogy to a human brain, such a system should be capable of storing information in some knowledge base and reasoning over existing information to deduce new information. Moreover, information in a knowledge base should be amenable to change, whether it be adding, deleting, or modifying information. The study of belief\nAuthor\u2019s addresses: Sebastian Binnewies and Zhiqiang Zhuang and Kewen Wang and Bela Stantic, School of Information and Communication Technology, Griffith University, Australia; Email: s.binnewies@griffith.edu.au, z.zhuang@griffith.edu.au, k.wang@griffith.edu.au, b.stantic@griffith.edu.au. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. c\u00a9 2000 ACM. 1539-9087/2000/03-ART00 $15.00 DOI: 0000001.0000001\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nchange [Doyle 1979; Fagin et al. 1983; Ga\u0308rdenfors 1988; Hansson 1999; Harper 1976; Levi 1980] concerns itself exactly with these kinds of dynamics in knowledge bases. It aims at providing mechanisms to change a knowledge base whenever new information is acquired. The majority of these mechanisms rely on two fundamental principles: the principle of primacy of new information, stating that new information should be treated with priority over existing information in the knowledge base, and the principle of minimal change, stating that as much existing information as possible should be preserved during a change operation [Dalal 1988]. An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourro\u0301n et al. 1985]. It classifies the possible changes to a knowledge base as expansion, revision, and contraction operations. In an expansion, new information is incorporated into a knowledge base, regardless of any inconsistencies that may arise. A revision operation also incorporates new information into a knowledge base, but in such a way that the resulting knowledge base is consistent. This is achieved by discarding some existing information. During a contraction, no new information is added to a knowledge base but some existing information is removed from it. On the one hand, the framework provides a set of postulates that each rational change operator should satisfy, and, on the other hand, defines specific constructions of expansion, revision, and contraction that satisfy these criteria. While the underlying assumption of the AGM framework is that any information implied by a knowledge base is represented explicitly in the knowledge base, the belief base framework of belief change [Fuhrmann 1991; Hansson 1989; Rott 1992] does not require this assumption. Postulates and constructions for expansion, revision, and contraction operators in the belief base framework have been defined to complement those from the AGM model (Hansson [1999] provides a summary). While the AGM and belief base frameworks have been applied to a variety of knowledge representation formalisms (an overview is given by Wassermann [2011]), work on an adaptation to knowledge representation in the form of logic programs [Colmerauer and Roussel 1996; Kowalski 1974; Lloyd 1987] has been slow to progress. A major challenge in the adaptation of the AGM and belief base frameworks to logic programming lies in the semantics of logic programs. While the frameworks and their previous adaptations are based on monotonic semantics, the standard answer set semantics [Gelfond and Lifschitz 1988] of logic programs is nonmonotonic. Only recently have operators been proposed for belief revision in logic programs. Program-level revision [Delgrande 2010] and screened semi-revision [Kru\u0308mpelmann and Kern-Isberner 2012] are initial approaches to logic program revision, yet have strict limitations in their expressiveness due to the nonmonotonicity of the underlying answer set semantics. A breakthrough arrived with the distance-based approach [Delgrande et al. 2013] to logic program revision, which rests upon characterising an agent\u2019s beliefs in terms of the set of SE (strong equivalence) models [Lifschitz et al. 2001; Turner 2003] of a logic program. A logic program P has the same set of SE models as a program Q if and only if, for any programR, the answer sets of P combinedwith R are exactly the same as the answer sets of Q combined with R. SE model semantics provides an alternative, monotonic characterisation for logic programs and thus circumvents obstacles presented by nonmonotonicity. To revise a program P by a program Q, the distance-based revision operator determines those SE models from the set of SE models of Q that are closest to the SE models of P . Even though the distance-based approach is a major milestone for logic program revision, it has some critical shortcomings. Firstly, as it relies on the set of SE models of an entire program as the representation of beliefs expressed by the program, it operates on the program-level only. This means that a program may freely be substituted\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nwith any other that has the same set of SE models and the revision output will remain the same. However, the information expressed by a program is more than just its set of SE models \u2013 a program also encodes relationships between the atoms occurring in it [Leite and Pereira 1998]. Such relationships are expressed on the rule-level, by the individual rules contained in a program. By neglecting information expressed on the rule-level, the distance-based approach fails to satisfy the property of preservation [Inoue and Sakama 2004] and the property of support [Inoue and Sakama 2004; Slota and Leite 2013]. This leads to some highly unintuitive results, as illustrated by the following two examples.\nIt is the 31st of December and I plan to drive from San Jose to San Francisco to see the New Year fireworks. Due to previous experience I believe that if there is heavy fog in San Francisco, then the city will cancel the fireworks. It has been clear and sunny for the last days, so I believe that it will not be foggy today either. I decide to check the weather forecast nonetheless, which says that there will be heavy fog tonight in San Francisco. Since I trust the forecast more than my own meteorological skills, I have to revise my beliefs. By employing the distance-based revision method, I would end up believing that it will be foggy, while being undecided whether the fireworks will be cancelled. Formally, let P1 = {\u22a5 \u2190 fog., no fireworks \u2190 fog. } and Q1 = { fog. }. Then the distance-based revision of P1 by Q1 would return { fog. }.\nI drive from San Jose to San Francisco every morning for work. I can use the 101 highway or the 280 freeway, but neither is particularly quicker. However, I believe that if there are roadworks on the 101, then the 280 is quicker. I was told by a friend that there are roadworks on the 101 currently, so I have been travelling on the 280. Now I hear on the radio that the roadworks finished and revise my beliefs. Using the distance-based revision method, I would end up with the belief that there are no roadworks on the 101, while still keeping the belief that the 280 is quicker. Formally, let P2 = { 101 roadworks., 280 quicker \u2190 101 roadworks. } and Q2 = {\u22a5 \u2190 101 roadworks. }. Then the distance-based revision of P2 by Q2 would return {\u22a5 \u2190 101 roadworks., 280 quicker. }.\nThe first example demonstrates that the distance-based approach does not satisfy the preservation property. I do not conclude that the fireworks will be cancelled, even though I know now that it will be foggy. The revision operation simply disregards the second rule of P1, which expresses the relationship between fog and fireworks cancellation. The reason for this is that the set of SE models of the first rule of P1 is a proper subset of the set of SE models of the second rule. Thus, the set of SE models of P1 is exactly the set of SE models of the first rule, which means that the second rule is invisible in the program-level view. The second example demonstrates that the distance-based approach does not satisfy the support property. I keep believing that the 280 is quicker, although the grounds to believe so do not hold any longer. The problem is that the dependency relationship between 280 quicker and 101 roadworks is captured on the rule-level, by the set of SE models of the second rule of P2, but not on the program-level, by the set of SE models of the entire program P2. A second shortcoming is that the distance-based approach makes the definition of a corresponding contraction operator difficult to come by. In classical logic, contraction can be defined in terms of revision by using the negation of a sentence. However, in logic programswe do not have the luxury of negation of a program. A workaround could be to use the complement of the set of SE models of the contracting program Q and\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nselect from this set the SE models that are closest to the ones of the initial program P . Yet, such a method may return SE models that are somewhat unrelated to P or Q, especially when the complement consists of a large number of SE models. Themotivation for this work is to address these limitations. In particular, we propose here, on the one hand, revision operators that take into account information expressed by a program on the program-level and the rule-level in order to avoid such unintuitive results as just shown. On the other hand, we present corresponding contraction operators with similar properties. The main contributions of this work can be summarised as follows.\n\u2014We provide new translations of the AGM and belief base revision and contraction postulates to the logic programming setting and establish formal relationships between these postulates and to previous translations. \u2014We introduce two sets of belief change operators for logic programs \u2013 partial meet revision and contraction operators and ensconcement revision and contraction operators \u2013 and show that each operator satisfies the relevant belief base revision or contraction postulates as well as the majority of AGM revision or contraction postulates. We also demonstrate that our partial meet and ensconcement revision operators address the shortcomings of the distance-based approach to logic program revision and that they are generalisations of the screened semi-revision approach for logic programs. \u2014We establish that our ensconcement operators are generalisations of our partial meet operators and that the Levi and Harper identities hold for our operators. We further show that the outcome of a revision or contraction operation remains unaffected whether an ensconcement is defined over rules or subsets of a program. \u2014We propose an algorithm to optimise the operations of partial meet and ensconcement revision or contraction of a logic program. \u2014We connect our results to the classic belief change frameworks by showing that our operators possess similar properties as their counterparts in propositional logic, that they conform fully to the belief base framework, and that they align more closely to the AGM and belief base frameworks than the distance-based revision operators.\nThe remainder of this paper is organised as follows. We first provide the preliminaries in Section 2 and review related work in Section 3. We then present new translations of the AGM and belief base revision and contraction postulates to logic programs in Section 4. In Sections 5 and 6, we propose partial meet and ensconcement belief change operators for logic programs, respectively, and evaluate their suitability with respect to the relevant postulates and existing operators. We establish the formal relationships between our operators in Section 7. In Section 8, we present an algorithm to optimise the operations of revision or contraction on a logic program. We finally discuss our findings in relation to the classic belief change frameworks in Section 9 and conclude with a summary in Section 10. Preliminary results from Sections 5 and 8 were presented in a conference paper [Binnewies et al. 2015]."}, {"heading": "2. PRELIMINARIES", "text": "We first briefly recall syntax and semantics of logic programs and then review the foundations of belief change."}, {"heading": "2.1. Logic Programming", "text": "Let A be a finite vocabulary of propositional atoms. A rule r over A has the form\na1; . . . ; ak;not b1; . . . ;not bl \u2190 c1, . . . , cm, not d1, . . . , not dn. (1)\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nHere, all ai, bi, ci, di \u2208 A and k, l,m, n \u2265 0. The operators \u2018not\u2019, \u2018;\u2019, and \u2018,\u2019 stand for default negation, disjunction, and conjunction, respectively. For convenience, letH+(r) = {a1, . . . , ak}, H\u2212(r) = {b1, . . . , bl}, B+(r) = {c1, . . . , cm}, and B\u2212(r) = {d1, . . . , dn}. If k = 1 and l = m = n = 0, then r is called a fact and we omit \u2018\u2190\u2019; if k = l = 0, then r is a constraint and we denote the empty disjunction by \u22a5. Let At(r) and At(R) denote the set of all atoms that occur in a rule of the form (1) and in a set of rules R, respectively. A (generalised) logic program is a finite set of rules of the form (1). We write LPA for the class of all logic programs that can be constructed from A. An interpretation Y \u2286 A satisfies a program P , denoted by Y |= P , if and only if (iff) it is a model of all rules under the standard definition for propositional logic such that each rule represents a conditional and default negation is transcribed to classical negation. Let Mod(P ) = { Y | Y |= P }. An answer set [Gelfond and Lifschitz 1988] of a program P is any subset-minimal interpretation Y that satisfies the reduct of P with respect to Y , denoted by P Y and defined as:\nP Y = {H+(r) \u2190 B+(r) | r \u2208 P,H\u2212(r) \u2286 Y, and B\u2212(r) \u2229 Y = \u2205 }.\nThe set of all answer sets of P is denoted by AS(P ). An SE interpretation is a tuple (X,Y ) of interpretations withX \u2286 Y \u2286 A. We usually write, e.g., (ab, ab) instead of ({a, b}, {a, b}) for legibility. Let SE be the set of all SE interpretations over A. For any set S of SE interpretations, by S we denote the complement of S with respect to SE , that is, S = SE \\S. An SE interpretation (X,Y ) is an SE model [Turner 2003] of a program P iff Y |= P and X |= P Y . The set of all SE models of P is denoted by SE(P ) and P is satisfiable iff SE(P ) 6= \u2205. An interpretation Y is an answer set of P iff (Y, Y ) \u2208 SE(P ) and, for any X \u2282 Y , (X,Y ) 6\u2208 SE(P ). Often we drop explicit set notation for rules and their union, e.g., for rules r, r\u2032 \u2208 P , we use SE(r) to denote SE({r}) and write SE(r\u222ar\u2032) instead of SE({r}\u222a{r\u2032}). Note that SE(P ) = \u22c2\nr\u2208P SE(r). Given two programs P andQ, we say that P is strongly equivalent [Lifschitz et al. 2001] to Q, denoted by P \u2261s Q, iff SE(P ) = SE(Q), and P implies Q, denoted by P |=s Q, iff SE(P ) \u2286 SE(Q). In the particular case of SE(P ) \u2282 SE(Q), we say that P strictly implies Q. The relation |=s is antitonic with respect to the program subset relation, i.e., Q \u2286 P implies P |=s Q. Furthermore, we write |=s P to express SE(P ) = SE . SE models are a refinement of answer sets as they provide more information about the atoms in a program and their dependencies. For example, each of the following programs P1, P2, . . . , P9 over A = {a, b} has {\u2205} as the only answer set but the sets of SE models are different for each program:\nP1 = {\u22a5 \u2190 a. } SE(P1) = {(\u2205, \u2205), (\u2205, b), (b, b)}\nP2 = {\u22a5 \u2190 b. } SE(P2) = {(\u2205, \u2205), (\u2205, a), (a, a)}\nP3 = { a \u2190 b. } SE(P3) = {(\u2205, \u2205), (\u2205, a), (a, a), (\u2205, ab), (a, ab), (ab, ab)}\nP4 = { b \u2190 a. } SE(P4) = {(\u2205, \u2205), (\u2205, b), (b, b), (\u2205, ab), (b, ab), (ab, ab)}\nP5 = {\u22a5 \u2190 a, b. } SE(P5) = {(\u2205, \u2205), (\u2205, a), (a, a), (\u2205, b), (b, b)}\nP6 = {\u22a5 \u2190 not a, b. } SE(P6) = {(\u2205, \u2205), (\u2205, a), (a, a), (\u2205, ab), (a, ab), (b, ab), (ab, ab)}\nP7 = {\u22a5 \u2190 a, not b. } SE(P7) = {(\u2205, \u2205), (\u2205, b), (b, b), (\u2205, ab), (a, ab), (b, ab), (ab, ab)}\nP8 = { a;not b. } SE(P8) = {(\u2205, \u2205), (\u2205, a), (a, a), (a, ab), (ab, ab)}\nP9 = {not a; b. } SE(P9) = {(\u2205, \u2205), (\u2205, b), (b, b), (b, ab), (ab, ab)}\nInformally, we can interpret the content of an SE model (X,Y ) on a three-valued scale. Any atoms in X are true, any atoms not in Y are false, and any atoms in Y but not in X are undefined.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."}, {"heading": "2.2. Belief Change", "text": "The AGM framework [Alchourro\u0301n et al. 1985; Ga\u0308rdenfors 1988] defines expansion, revision, and contraction as the change operations on a body of beliefs held by an agent, called a belief state henceforth, in light of some new information. In an expansion, new beliefs are incorporated into a belief state, regardless of any inconsistencies that may arise. A revision operation also incorporates new beliefs into a belief state, but in such a way that the resulting belief state is consistent. This is achieved by discarding some existing beliefs. During a contraction, some beliefs in a belief state are removed without adding new beliefs. In the AGM framework, a belief state is modelled as a belief set, defined as a set of sentences from some logic-based language L that is closed under logical consequence, i.e., when all beliefs implied by a knowledge base are explicitly represented in the knowledge base. Let K be a belief set, \u03c6 and \u03c8 sentences, K\u22a5 denote the inconsistent belief set, and Cn(\u00b7) stand for a logical consequence function. By \u03c6 \u2261 \u03c8 we mean Cn(\u03c6) = Cn(\u03c8). The expansion of K by \u03c6, written K \u2295 \u03c6, is defined as K \u2295 \u03c6 = Cn(K \u222a {\u03c6}). The AGM framework provides a set of postulates that any rational revision operator should satisfy. The postulates are listed as follows, where \u229b represents a revision operator.\n(\u229b1) K \u229b \u03c6 is a belief set (\u229b2) \u03c6 \u2208 K \u229b \u03c6 (\u229b3) K \u229b \u03c6 \u2286 K \u2295 \u03c6 (\u229b4) If \u00ac\u03c6 6\u2208 K, then K \u2295 \u03c6 \u2286 K \u229b \u03c6 (\u229b5) K \u229b \u03c6 = K\u22a5 iff \u22a2 \u00ac\u03c6 (\u229b6) If \u03c61 \u2261 \u03c62, then K \u229b \u03c61 = K \u229b \u03c62 (\u229b7) K \u229b (\u03c6 \u2227 \u03c8) \u2286 (K \u229b \u03c6)\u2295 \u03c8 (\u229b8) If \u00ac\u03c8 6\u2208 K \u229b \u03c6, then (K \u229b \u03c6)\u2295 \u03c8 \u2286 K \u229b (\u03c6 \u2227 \u03c8)\n(\u229b1) requires that the outcome of a revision is a belief set. (\u229b2) states that the revising sentence is contained in the revised belief set. (\u229b3) asserts that a belief set revised by a sentence is always a subset of the belief set expanded by that sentence. (\u229b3) and (\u229b4) together state that revision coincides with expansion in cases when the revising sentence is consistent with the initial belief set. (\u229b5) guarantees that a revision outcome is consistent, unless the revising sentence is logically impossible. (\u229b6) ensures that logically equivalent sentences lead to the same revision outcomes. (\u229b7) and (\u229b8) together enforce K to be minimally changed in a revision by both \u03c6 and \u03c8, such that the outcome is the same as the expansion of K \u229b \u03c6 by \u03c8, provided that \u03c8 is consistent with K \u229b \u03c6. In the concrete case that a belief state is represented as a finite set of propositional formulas, the following set of postulates is equivalent to the set (\u229b1)\u2013(\u229b8) [Katsuno and Mendelzon 1991]. Let \u03c6, \u03c8, \u00b5 be propositional formulas.\n(\u229b1KM) \u03c6\u229b \u03c8 implies \u03c8 (\u229b2KM) If \u03c6 \u2227 \u03c8 is satisfiable, then \u03c6\u229b \u03c8 \u2261 \u03c6 \u2227 \u03c8 (\u229b3KM) If \u03c8 is satisfiable, then \u03c6\u229b \u03c8 is satisfiable (\u229b4KM) If \u03c61 \u2261 \u03c62 and \u03c81 \u2261 \u03c82, then \u03c61 \u229b \u03c81 \u2261 \u03c62 \u229b \u03c82 (\u229b5KM) (\u03c6 \u229b \u03c8) \u2227 \u00b5 implies \u03c6\u229b (\u03c8 \u2227 \u00b5) (\u229b6KM) If (\u03c6\u229b \u03c8) \u2227 \u00b5 is satisfiable, then \u03c6\u229b (\u03c8 \u2227 \u00b5) implies (\u03c6 \u229b \u03c8) \u2227 \u00b5\n(\u229b1KM) requires that the revising formula can be derived from the revision outcome. (\u229b2KM) specifies that revision corresponds to conjunction whenever the revising formula is consistent with the formula to be revised. (\u229b3KM) guarantees consistency of a revision outcome whenever the revising formula is consistent. (\u229b4KM) states that\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nrevising logically equivalent formulas by logically equivalent formulas leads to logically equivalent results. (\u229b5KM) and (\u229b6KM) together stipulate that the revision by a conjunction leads to the same outcome as revising by one conjunct and then forming the conjunction with the other conjunct, provided that the conjunction thus formed is satisfiable. The AGM framework also provides a set of postulates that any rational contraction operator should satisfy. The postulates are given below, where \u2296 represents a contraction operator.\n(\u22961) K \u2296 \u03c6 is a belief set (\u22962) K \u2296 \u03c6 \u2286 K (\u22963) If \u03c6 6\u2208 K, then K \u2296 \u03c6 = K (\u22964) If 6\u22a2 \u03c6, then \u03c6 6\u2208 K \u2296 \u03c6 (\u22965) K \u2286 (K \u2296 \u03c6) \u2295 \u03c6 (\u22966) If \u03c61 \u2261 \u03c62, then K \u2296 \u03c61 = K \u2296 \u03c62 (\u22967) K \u2296 \u03c6 \u2229K \u2296 \u03c8 \u2286 K \u2296 \u03c6 \u2227 \u03c8 (\u22968) If \u03c6 6\u2208 K \u2296 \u03c6 \u2227 \u03c8, then K \u2296 \u03c6 \u2227 \u03c8 \u2286 K \u2296 \u03c6\n(\u22961) requires that the outcome of a contraction is a belief set. (\u22962) ensures that no new beliefs are introduced during a contraction. (\u22963) stipulates that the belief set remains unchanged during a contraction operation whenever the sentence to be contracted is not contained in it. (\u22964) states that a contracting sentence is not a logical consequence of the contracted belief set, unless the sentence is a tautology. (\u22965) requires that the original belief set can be recovered by expanding a contracted belief set by the sentence that was contracted. (\u22966) ensures that logically equivalent sentences lead to the same contraction outcomes. (\u22967) guarantees that any beliefs retained in a contraction by \u03c6 and in a contraction by \u03c8 are also retained in a contraction by both \u03c6 and \u03c8. (\u22968) specifies that any beliefs retained in a contraction by both \u03c6 and \u03c8 are also retained in a contraction by \u03c6, whenever \u03c6 itself is not retained. The appropriateness of the Recovery postulate (\u22965) within this set of contraction postulates has been discussed intensively [Fuhrmann 1991; Hansson 1991; Makinson 1987; Nayak 1994; Niedere\u0301e 1991]. To replace the Recovery postulate in expressing that no beliefs should be retracted unduly during a contraction operation, alternative postulates were proposed. Hansson [1991] offered the following postulate:\n(\u22965r) If \u03c8 \u2208 K \\ (K \u2296 \u03c6), then there is a set K \u2032 such that K \u2296 \u03c6 \u2286 K \u2032 \u2282 K and \u03c6 6\u2208 Cn(K \u2032) but \u03c6 \u2208 Cn(K \u2032 \u222a {\u03c8}).\nThe Relevance postulate (\u22965r) states that a sentence \u03c8 should only be removed during the contraction of a sentence \u03c6 from K if \u03c8 is relevant for implying \u03c6. In the presence of (\u22961)\u2013(\u22963), (\u22965) is equivalent to (\u22965r) in propositional logic [Hansson 1991]. More recently, Ferme\u0301 et al. [2008] presented the following Disjunctive Elimination postulate (\u22965de):\n(\u22965de) If \u03c8 \u2208 K \\ (K \u2296 \u03c6), then K \u2296 \u03c6 6\u22a2 \u03c6 \u2228 \u03c8.\nAccording to (\u22965de), a sentence \u03c8 should only be removed during the contraction of a sentence \u03c6 fromK if the contraction result does not imply the disjuntion of \u03c6 and \u03c8. In the presence of (\u22962)\u2013(\u22963), (\u22965r) is equivalent to (\u22965de) in propositional logic [Ferme\u0301 et al. 2008]. One of the classic constructions to implement belief change is partial meet contraction [Alchourro\u0301n et al. 1985], which we recapitulate here. A set K \u2032 is a remainder set of a set K \u2286 L with respect to a sentence \u03c6 iff\na) K \u2032 \u2286 K,\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nb) K \u2032 6\u22a2 \u03c6, and c) for any K \u2032\u2032 with K \u2032 \u2282 K \u2032\u2032 \u2286 K : K \u2032\u2032 \u22a2 \u03c6.\nThe set of all remainder sets of K with respect to \u03c6 is denoted by K\u22a5\u03c6. A selection function \u03b3 for a belief set K is a function such that (i) if K\u22a5\u03c6 6= \u2205, then \u2205 6= \u03b3(K\u22a5\u03c6) \u2286 K\u22a5\u03c6 and (ii) \u03b3(K\u22a5\u03c6) = {K} otherwise. A partial meet contraction operator\u2296\u03b3 forK is defined as: K \u2296\u03b3 \u03c6 = \u22c2\n\u03b3(K\u22a5\u03c6). The following representation theorem shows that the set of postulates (\u22961)\u2013(\u22966) exactly characterises the class of partial meet contraction operators.\nTHEOREM 2.1. [Alchourro\u0301n et al. 1985] For any belief set K, \u2296\u03b3 is a partial meet contraction operator for K iff \u2296\u03b3 satisfies (\u22961)\u2013(\u22966).\nBy placing further restrictions on the selection function, the representation theorem can be extended to the full set of postulates. A transitively relational selection function \u03b3\u2032 for K is determined by a transitive relation \u2702 over 2K such that \u03b3\u2032(K\u22a5\u03c6) = {K \u2032 \u2208 K\u22a5\u03c6 | K \u2032\u2032 \u2702 K \u2032 for all K \u2032\u2032 \u2208 K\u22a5\u03c6 }. A partial meet contraction operator \u2296\u03b3\u2032 determined by a transitively relational selection function \u03b3\u2032 is called a transitively relational partial meet contraction operator.\nTHEOREM 2.2. [Alchourro\u0301n et al. 1985] For any belief set K, \u2296\u03b3\u2032 is a transitively relational partial meet contraction operator for K iff \u2296\u03b3\u2032 satisfies (\u22961)\u2013(\u22968).\nA corresponding (transitively relational) partial meet revision operator \u229b\u03b3 (\u229b\u03b3\u2032) that satisfies (\u229b1)\u2013(\u229b6) ((\u229b1)\u2013(\u229b8)) can be obtained from a (transitively relational) partial meet contraction operator via the Levi identity: K \u229b \u03c6 = (K \u2296 \u00ac\u03c6) \u2295 \u03c6 [Ga\u0308rdenfors 1981; Levi 1977]. The inverse identity, which constructs a contraction operator from a revision operator, is due to Harper [1976]: K \u2296 \u03c6 = K \u2229 (K \u229b \u00ac\u03c6). While the AGM approach provides an effective framework to conduct belief change, the representation of belief states in the form of belief sets has some shortcomings (see [Hansson 1999] for a detailed discussion). From a practical perspective, main drawbacks of belief sets are that they are generally large objects, since all logical consequences of all beliefs are contained, and that it is impossible to distinguish between inconsistent belief sets, as inconsistent belief sets consist of the entire language. Belief bases [Fuhrmann 1991; Hansson 1989; Rott 1992] are an alternative representation of belief states. A belief base is a set of sentences from L that is not necessarily closed under logical consequence. Hansson [1993] defined a partial meet base contraction operator \u2212\u03b3 for a belief base B as B \u2212\u03b3 \u03c6 = \u22c2\n\u03b3(B\u22a5\u03c6) and showed that the following set of postulates exactly characterises the class of partial meet base contraction operators.\n(\u22121) B \u2212 \u03c6 \u2286 B (\u22122) If 6\u22a2 \u03c6, then \u03c6 6\u2208 Cn(B \u2212 \u03c6) (\u22123) If \u03c8 \u2208 B \\ (B\u2212\u03c6), then there is a set B\u2032 such that B\u2212\u03c6 \u2286 B\u2032 \u2282 B and \u03c6 6\u2208 Cn(B\u2032) but \u03c6 \u2208 Cn(B\u2032 \u222a {\u03c8}) (\u22124) If it holds for all B\u2032 \u2286 B that \u03c6 \u2208 Cn(B\u2032) iff \u03c8 \u2208 Cn(B\u2032), then B \u2212 \u03c6 = B \u2212 \u03c8\nTHEOREM 2.3. [Hansson 1993] For any belief base B, \u2212\u03b3 is a partial meet base contraction operator for B iff \u2212\u03b3 satisfies (\u22121)\u2013(\u22124).\nNote that (\u22121), (\u22122), and (\u22123) in the belief base setting correspond directly to (\u22962), (\u22964), and (\u22965r) in the AGM setting, respectively. (\u22124) states that if any parts of B which imply \u03c6 also imply \u03c8, then the same parts of B will be retained in a contraction by \u03c6 as in a contraction by \u03c8.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nHe also defined a corresponding partial meet base revision operator >\u03b3 for a belief base B as B >\u03b3 \u03c6 = (B \u2212\u03b3 \u00ac\u03c6) \u222a {\u03c6} and showed that the following set of postulates exactly characterises the class of partial meet base revision operators.\n(>1) \u03c6 \u2208 B > \u03c6 (>2) B > \u03c6 \u2286 B \u222a {\u03c6} (>3) If \u03c8 \u2208 B \\ (B > \u03c6), then there is a set B\u2032 such that B > \u03c6 \u2286 B\u2032 \u2282 B \u222a {\u03c6} and \u00ac\u03c6 6\u2208 Cn(B\u2032) but \u00ac\u03c6 \u2208 Cn(B\u2032 \u222a {\u03c8}) (>4) If it holds for all B\u2032 \u2286 B that B\u2032 \u222a {\u03c6} is consistent iff B\u2032 \u222a {\u03c8} is consistent, then B \u2229 (B > \u03c6) = B \u2229 (B > \u03c8) (>5) If 6\u22a2 \u00ac\u03c6, then \u00ac\u03c6 6\u2208 Cn(B > \u03c6)\nTHEOREM 2.4. [Hansson 1993] For any belief base B, >\u03b3 is a partial meet base revision operator for B iff >\u03b3 satisfies (>1)\u2013(>5).\nThe pendants to (>1) and (>2) in the AGM framework are (\u229b2) and (\u229b3), respectively. (>3) requires \u03c8 to only be removed from B if it would otherwise make the revision outcome inconsistent. (>4) mandates that if any parts of B which are consistent with \u03c6 are also consistent with \u03c8, then the same parts of B will be retained in a revision by \u03c6 as in a revision by \u03c8. (>5) is a weaker version of (\u229b5). Williams [1994] proposed further belief change operators for belief bases, which rely on an ordering over the sentences contained in a belief base, called ensconcement. An ensconcement associated with a belief base B is any total preorder4 on B that satisfies the following conditions.\n(41) For all \u03c6 \u2208 B : {\u03c8 \u2208 B | \u03c6 \u227a \u03c8 } 6\u22a2 \u03c6 (42) For all \u03c6, \u03c8 \u2208 B : \u03c6 4 \u03c8 iff \u22a2 \u03c8\nA sentence \u03c8 is at least as ensconced as a sentence \u03c6 iff \u03c6 4 \u03c8, and \u03c8 is strictly more ensconced than \u03c6 iff \u03c6 \u227a \u03c8. Condition (41) states that sentences which are strictly more ensconced than a sentence \u03c6 do not entail \u03c6. Condition (42) requires any tautologies in the belief base to be most ensconced. The proper cut of B for \u03c6 is cut\u227a(\u03c6) = {\u03c8 \u2208 B | {\u03c7 \u2208 B | \u03c8 4 \u03c7 } 6\u22a2 \u03c6 }. An ensconcement contraction operator \u22964 for B is defined as: \u03c8 \u2208 B \u22964 \u03c6 iff \u03c8 \u2208 B and either \u22a2 \u03c6 or cut\u227a(\u03c6) \u222a {\u00ac\u03c6} \u22a2 \u03c8. An ensconcement revision operator \u229b4 for B is defined as: \u03c8 \u2208 B \u229b4 \u03c6 iff (i) \u03c8 = \u03c6 or (ii) \u03c8 \u2208 B and either \u22a2 \u00ac\u03c6 or cut\u227a(\u00ac\u03c6) \u222a {\u03c6} \u22a2 \u03c8. An ensconcement contraction operator \u22964 satisfies (\u22121), (\u22122), and\n(\u22125) If \u03c6 6\u2208 Cn(B), then B \u2212 \u03c6 = B (\u22126) If \u03c61 \u2261 \u03c62, then B \u2212 \u03c61 = B \u2212 \u03c62 (\u22127) B \u2212 \u03c6 \u2227 \u03c8 = B \u2212 \u03c6 or B \u2212 \u03c6 \u2227 \u03c8 = B \u2212 \u03c8 or B \u2212 \u03c6 \u2227 \u03c8 = B \u2212 \u03c6 \u2229B \u2212 \u03c8 (\u22128) If \u03c8 \u2208 B \\ (B \u2212 \u03c6), then B \u2212 \u03c6 6\u22a2 \u03c6 \u2228 \u03c8\nTHEOREM 2.5. [Ferme\u0301 et al. 2008] Let B be a belief base and \u22964 an ensconcement contraction operator for B. Then \u22964 satisfies (\u22121), (\u22122), and (\u22125)\u2013(\u22128).1\nPostulates (\u22125), (\u22126), and (\u22128) correspond directly to (\u22963), (\u22966), and (\u22965de) in the AGM setting, respectively. (\u22127) states that a contraction by a conjuntion is the result of contracting by the first of the conjuncts, the result of contracting by the second of the conjuncts, or the common part of these two results. In the belief base framework, the relationship between (\u22123) and (\u22128) is different to the one between (\u22965r) and (\u22965de) in the AGM framework: (\u22123) implies (\u22128) but not vice versa [Ferme\u0301 et al. 2008].\n1Please note that the proof of the representation theorem (Theorem 14 in [Ferme\u0301 et al. 2008]) contains an error, as acknowledged by the authors. The theorem only holds in the direction from operator to postulates as stated above.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."}, {"heading": "3. RELATED WORK", "text": "One of the key developments for adapting the AGM framework of belief change to logic programs came with the distance-based approach to logic program revision [Delgrande et al. 2013]. It is built on the monotonic SE semantics for logic programs and understands a belief state as the set of SE models of a program. In that work, the formula-based revision postulates (\u229b1KM)\u2013(\u229b6KM) are translated to logic programs as follows, where a revision operator \u2217 is a function from LPA \u00d7 LPA to LPA and the expansion of P by Q, denoted P \u2214 Q, is understood as P \u2214 Q = R such that R \u2208 LPA and SE(R) = SE(P ) \u2229 SE(Q).\n(\u22171m) P \u2217Q |=s Q (\u22172m) If P \u2214Q is satisfiable, then P \u2217Q \u2261s P \u2214Q (\u22173m) If Q is satisfiable, then P \u2217Q is satisfiable (\u22174m) If P1 \u2261s P2 and Q1 \u2261s Q2, then P1 \u2217Q1 \u2261s P2 \u2217Q2 (\u22175m) (P \u2217Q)\u2214R |=s P \u2217 (Q \u2214R) (\u22176m) If (P \u2217Q)\u2214R is satisfiable, then P \u2217 (Q \u2214R) |=s (P \u2217Q)\u2214R\nThe approach adapts two revision operators from classic belief change to logic programs, namely, Dalal\u2019s revision operator [Dalal 1988] and Satoh\u2019s revision operator [Satoh 1988]. Informally, to revise a program P by a program Q, the operators return those SE models from the set of SE models of Q that are closest to the SE models of P , where closeness is determined by Dalal\u2019s or Satoh\u2019s notion of distance. Delgrande et al. [2013] identified that the adaptation of Satoh\u2019s revision operator gives more intuitive results than the adaptation of Dalal\u2019s revision operator, so we will focus on the former here. This restriction has no effect on our later discussions. We briefly restate the definition and main result of the distance-based approach. Let \u2206 stand for the symmetric difference between two sets X,Y , that is, X\u2206Y = (X \\ Y ) \u222a (Y \\X). For any two pairs of sets (X,X \u2032), (Y, Y \u2032), let\n(X,X \u2032)\u2206(Y, Y \u2032) = (X\u2206Y,X \u2032\u2206Y \u2032);\n(X,X \u2032) \u2286 (Y, Y \u2032) iff X \u2032 \u2286 Y \u2032, and if X \u2032 = Y \u2032, then X \u2286 Y ;\n(X,X \u2032) \u2282 (Y, Y \u2032) iff (X,X \u2032) \u2286 (Y, Y \u2032) and (Y, Y \u2032) * (X,X \u2032).\nFor any two sets E,E\u2032, let\n\u03c3(E,E\u2032) = {A1 \u2208 E | there exists a B1 \u2208 E \u2032 such that for all A2 \u2208 E\nand for all B2 \u2208 E \u2032 it holds that A1\u2206B1 \u2286 A2\u2206B2 }.\nDEFINITION 3.1. [Delgrande et al. 2013] Let P,Q \u2208 LPA. The revision of P by Q, denoted P \u22c6 Q, is defined as P \u22c6 Q = R such that R \u2208 LPA and SE(R) = SE(Q) if SE(P ) = \u2205, and otherwise\nSE(R) = { (X,Y ) | Y \u2208 \u03c3(Mod(Q),Mod(P )), X \u2286 Y,\nand if X \u2282 Y, then (X,Y ) \u2208 \u03c3(SE(Q), SE(P )) }.\nTHEOREM 3.1. [Delgrande et al. 2013] The revision operator \u22c6 satisfies (\u22171m)\u2013(\u22175m).\nThe distance-based approach was extended by two representation theorems [Delgrande et al. 2013; Schwind and Inoue 2013], stating that any logic program revision operator satisfying (\u22171m)\u2013(\u22176m) plus some additional conditions can be characterised by some preorder over a set of SE models. Besides the distance-based approach, few other methods for logic program revision have been proposed. The screened semi-revision approach for logic programs [Kru\u0308mpelmann and Kern-Isberner 2012] is based on answer set semantics and aligns itself with the belief base framework. The approach assumes a belief state to be the\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nset of rules belonging to a program and combines adaptations of the constructions of semi-revision [Hansson 1997] and screened revision [Makinson 1997] into a screened consolidation operation for logic programs. The consolidation operator first finds all maximal subsets of one program that are consistent with a second program under answer set semantics, then selects exactly one of these subsets, and returns this subset together with the second program as the outcome. We review the formal definitions of the screened consolidation operator and the main result here. Let P \u2208 LPA and Q \u2286 P . The set of screened remainder sets of P with respect to Q is\nP\u22a5!Q = {R | Q \u2286 R \u2286 P,AS(R) 6= \u2205 and for all R \u2032 with R \u2282 R\u2032 \u2286 P : AS(R\u2032) = \u2205 }.\nA maxichoice selection function \u03b3P for P is a function such that for any Q \u2208 LPA: (i) if P\u22a5!Q 6= \u2205, then \u03b3P (P\u22a5!Q) = R for some R \u2208 P\u22a5!Q, and (ii) if P\u22a5!Q = \u2205, then \u03b3P (P\u22a5!Q) = P .\nDEFINITION 3.2. [Kru\u0308mpelmann and Kern-Isberner 2012] Let P,Q \u2208 LPA and \u03b3P be a maxichoice selection function for P . A screened consolidation operator !\u03b3P for P is defined as P !\u03b3PQ = \u03b3P (P\u22a5!Q).\nThe authors propose the following adaptation of partial meet base revision postulates that any screened consolidation operator ! should satisfy, where ! is a function from LPA \u00d7 LPA to LPA, and show that !\u03b3P is exactly characterised by these postulates.\n(!1) Q \u2286 P !Q (!2) P !Q \u2286 P (!3) If r \u2208 P \\ (P !Q), then AS(P !Q) 6= \u2205 and AS(P !Q \u222a {r}) = \u2205 (!4) If it holds for all P \u2032 \u2286 P that AS(P \u2032 \u222a Q) 6= \u2205 iff AS(P \u2032 \u222a R) 6= \u2205, then P \u2229 ((P \u222a Q) !Q) = P \u2229 ((P \u222aR) !R) (!5) If there exists some P \u2032 such that Q \u2286 P \u2032 \u2286 P and AS(P \u2032) 6= \u2205, then AS(P !Q) 6= \u2205\nTHEOREM 3.2. [Kru\u0308mpelmann and Kern-Isberner 2012] For any P \u2208 LPA, !\u03b3P is a screened consolidation operator for P iff !\u03b3P satisfies (!1)\u2013(!5).\nThe program-level approach to logic program revision [Delgrande 2010] is also based on answer set semantics and assumes the beliefs that make up a belief state to be the answer sets of a program. The revision operation relies on extending the standard answer set semantics to three-valued answer set semantics for determining the outcome. To revise a program P by a program Q, for each three-valued answer set X of Q, all maximal subsets R of P are selected such that X is a subset of each three-valued answer set X \u2032 of R \u222aQ. The revision operation returns a set of answer sets that correspond to each X \u2032 as the result. In the author\u2019s view, the AGM revision postulates (\u229b3), (\u229b4), (\u229b7), and (\u229b8) are inappropriate in the context of nonmonotonic semantics. An adaptation of the remaining postulates is fulfilled by the revision operation. The work of Zhuang et al. [2016] concerns itself with the revision of a disjunctive logic program by another. The authors observed that for a belief revision operator in a nonmonotonic setting, the task of inconsistency resolving can be done not only by removing old beliefs but also by adding new beliefs. Based on this observation, they proposed a variant of partial meet revision. For resolving the inconsistency between the original and the new beliefs, the variant obtains not only maximal subsets of the initial program that are consistent with the new one, but also minimal supersets of the initial program that are consistent with the new one. A representation theorem is provided. Since the idea of resolving inconsistency by adding new beliefs is beyond the classic AGM approach, some extra postulates are required to characterise the variant.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nInoue and Sakama [2004] argue that neither the set of answer sets nor the set of SE models of a program provide enough detail to revise a program. They illustrate that while two programs { a., b \u2190 not a. } and { a. } have the same set of SE models, and thus the same set of answer sets, they should be treated differently during a revision operation, since b should be derived from the first program whenever the rule a. is discarded. We call this property preservation here. They further argue that revision operations should distinguish between two programs { a., b. } and { a., b \u2190 a. }. While these two programs again share the same set of SE models, they too should not be interchangeable, since after a removal of the rule a., b should not be derived from the latter program any more. This property has become known as support [Slota and Leite 2013]. To address these two issues, Inoue and Sakama [2004] introduced a new notion of program equivalence that is stricter than strong equivalence, called C-update equivalence: any two programs P1, P2 \u2208 LPA are C-update equivalent iff P1 \\ P2 \u2261s P2 \\ P1. A relative of belief revision is belief update [Katsuno and Mendelzon 1992]. The difference between these two is usually understood in the way that belief revision addresses changes to a belief state brought about by some new information about a static world, whereas belief update covers changes to a belief state due to dynamics in the world described by the belief state. Similar to belief revision, the belief update framework prescribes a set of postulates that each rational update operator should satisfy and provides a construction that complies with it. A number of update operators for logic programs have been proposed, which differ greatly in the degree of alignment to the classic belief update framework. On the whole, these approaches rely predominantly on syntactic transformations of programs and return a set of answer sets instead of an updated program as the outcome. The landscape of update operators has already been reviewed exhaustively in other places, for example, detailed overviews are given by Delgrande et al. [2004] and Slota [2012]. Of interest in the current context is the exception-based update approach [Slota and Leite 2012], which introduces RE (robust equivalence) models as an extension of SE models. An RE model of a program P is any SE interpretation (X,Y ) such that X |= P Y . The authors regard a belief state as the collection of the sets of RE models of the rules in a program. In the update operation, exceptions in the form of RE models are added to those sets of RE models of the initial program that are incompatible with the RE models of the updating program. Incompatibilities between two sets of RE models are determined by differences in the truth values of atoms occurring in both sets. The update operator satisfies the majority of the update postulates adapted to logic programs. An ordered logic program is a tuple (P,<) such that P is a logic program and < is a preference ordering over the rules in P . Thus, it is conceivable to express the revision of P by Q as (P \u222a Q,<), where < is some appropriate preference ordering on P \u222a Q (from [Delgrande et al. 2007], for example), and employ one of the different semantics proposed [Brewka and Eiter 1999; Delgrande et al. 2003; Schaub and Wang 2003] to obtain the preferred answer sets of this ordered logic program. An ordered logic program can be transformed into a standard logic program, so that the preferred answer sets of the former are exactly the answer sets of the latter [Delgrande et al. 2003]. Yet, the transformed program may bear no syntactic relation to the original program. More importantly, an ordered logic program (P \u222a Q,<) may be inconsistent, i.e., may have no answer sets, even if P and Q themselves are consistent [Delgrande et al. 2004]. These characteristics make ordered logic programs rather unsuitable as a methodology for logic program belief change in general.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."}, {"heading": "4. ADAPTING THE BELIEF CHANGE FRAMEWORKS", "text": "Before we set out to define new constructions of logic program belief change, we translate the ideas of the classic belief change frameworks to the logic programming setting. We assume that a belief state is represented in the form of a program from LPA and new information to expand/revise/contract this program comes in the form of another program from LPA. Even though a consequence relation for logic programs under SE semantics exists [Eiter et al. 2004; Wong 2008], logic programs are per se not closed under logical consequence. Thus, it seems natural to align logic program belief change with the belief base framework. However, as the majority of previous approaches to logic program revision have focussed on adapting the AGM framework, we will consider it here as well to enable us to draw proper comparisons. As pointed out above, in the case of propositional knowledge bases the set of formulabased revision postulates (\u229b1KM)\u2013(\u229b6KM) is equivalent to the set (\u229b1)\u2013(\u229b8). However, in the context of logic programs, it is worth having a closer look at the relationship between these two sets. Besides adaptations for the purpose of logic program \u2018update\u2019 operations under answer set semantics [Eiter et al. 2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (\u229b1KM)\u2013(\u229b6KM) until now [Delgrande et al. 2013; Delgrande et al. 2013; Schwind and Inoue 2013]. They are given in the form of (\u22171m)\u2013(\u22176m) (see Section 3). We will now present a new set of postulates for logic program revision operators, based on the original AGM postulates (\u229b1)\u2013(\u229b8), and then explain their relationship to (\u22171m)\u2013(\u22176m). We will discover that the equivalence of the two sets of postulates under propositional logic does not carry over to logic programs, that, in fact, the adaptation of (\u229b1)\u2013(\u229b8) to logic programs leads to postulates that are in most cases stricter than (\u22171m)\u2013(\u22176m), since Q \u2286 P implies P |=s Q but the converse does not hold. Let P,Q,R \u2208 LPA and a revision operator \u2217 be a function from LPA\u00d7LPA to LPA. In the following, we understand expansion, denoted by the operator +, as P +Q = P \u222aQ.\n(\u22171) P \u2217Q \u2208 LPA (\u22172) Q \u2286 P \u2217Q (\u22173) P \u2217Q \u2286 P +Q (\u22174) If P +Q is satisfiable, then P +Q \u2286 P \u2217Q (\u22175) P \u2217Q is satisfiable iff Q is satisfiable (\u22176) If Q \u2261s R, then P \u2217Q \u2261s P \u2217R (\u22177) P \u2217 (Q +R) \u2286 (P \u2217Q) +R (\u22178) If (P \u2217Q) +R is satisfiable, then (P \u2217Q) +R \u2286 P \u2217 (Q+R)\n(\u22171) is a basic but nonetheless crucial condition that is included in previous adaptations by the requirement that \u2217 is a function from LPA \u00d7 LPA to LPA. (\u22172) stipulates that the revising program is always included in a revision outcome and is a stronger version of (\u22171m) since (\u22172) implies (\u22171m) but not vice versa. (\u22173) requires that a revision outcome never contains elements not in P or Q. This condition is covered by previous adaptations only for the case that P +Q is satisfiable in (\u22172m). Together, (\u22173) and (\u22174) state that revision coincides with expansion if P+Q is satisfiable and thus imply (\u22172m) but not vice versa. (\u22175) is the stricter, biconditional version of (\u22173m) emphasising the consistency of a revision outcome. (\u22176) guarantees that revision by strongly equivalent programs leads to strongly equivalent results. Unlike belief sets, logic programs are not closed under logical consequence, so that we cannot expect from two different bodies of information that are merely strongly equivalent to be equal after a revision. Thus, the consequent is translated as \u201cP \u2217Q \u2261s P \u2217R\u201d from the original postulate (\u229b6). (\u22174m) is stricter than (\u22176). (\u22177) and (\u22178) capture the minimal change condition by re-\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nquiring that the revision of P by the expansion of Q with R has the same outcome as P \u2217 Q expanded with R, whenever the latter is satisfiable. (\u22177) and (\u22178) imply (\u22175m) and (\u22176m) but not vice versa, respectively. A translation of the AGM contraction postulates to logic programs is listed below, where P,Q,R \u2208 LPA and a contraction operator .\u2212 is a function from LPA \u00d7 LPA to LPA.\n( .\u22121) P .\u2212Q \u2208 LPA ( .\u22122) P .\u2212Q \u2286 P ( .\u22123) If P 6|=s Q, then P\n.\u2212Q = P ( .\u22124) If 6|=s Q, then P\n.\u2212Q 6|=s Q ( .\u22125) P \u2286 (P .\u2212Q) +Q ( .\u22126) If Q \u2261s R, then P\n.\u2212Q = P .\u2212R ( .\u22127) (P .\u2212Q) \u2229 (P .\u2212R) \u2286 P .\u2212 (Q+R) ( .\u22128) If P .\u2212 (Q +R) 6|=s Q, then P .\u2212 (Q +R) \u2286 P .\u2212Q\nAny contraction outcome is required to be a logic program by ( .\u22121) and a subset of the initial program by ( .\u22122). According to ( .\u22123), if the beliefs to be contracted are not implied by the initial belief state, then nothing is to be retracted. ( .\u22124) requires that the beliefs to be contracted are not implied by the contracted belief state, unless they are tautologies. ( .\u22125) states that all parts of the initial program P that are discarded in a contraction by Q can be recovered by a subsequent expansion with Q. ( .\u22126) ensures that contraction by strongly equivalent programs leads to the same outcomes. ( .\u22127) demands that any parts retained in both P .\u2212Q and P .\u2212R are also retained in P .\u2212(Q+R). Whenever Q is not implied by the result of a contraction by Q + R, then ( .\u22128) states that this result is also retained in a contraction by Q alone. ( .\u22121), ( .\u22122), ( .\u22125), ( .\u22126), and ( .\u22127) are direct translations of (\u22961), (\u22962), (\u22965), (\u22966), and (\u22967), respectively. In the adaptation of (\u22963) to ( .\u22123), we use \u201cP 6|=s Q\u201d instead of \u201cQ * P \u201d. Belief sets are closed under logical consequence, which means K \u22a2 \u03c6 iff \u03c6 \u2208 K, so that either can be used as the condition in (\u22963). However, for logic programs under SE semantics, we can conclude P |=s Q from Q \u2286 P but not Q \u2286 P from P |=s Q. Therefore, it is more appropriate to use \u201cP 6|=s Q\u201d than \u201cQ * P \u201d, as P 6|=s Q implies Q * P . For the same reason is \u201cP .\u2212Q 6|=s Q\u201d used instead of \u201cQ * P\n.\u2212Q\u201d in ( .\u22124), and \u201cP .\u2212 (Q +R) 6|=s Q\u201d instead of \u201cQ * P\n.\u2212 (Q +R)\u201d in ( .\u22128). We now adapt the belief base revision postulates (>1)\u2013(>5) to logic programs, where\nagain P,Q,R \u2208 LPA and a revision operator \u2217 is a function from LPA \u00d7 LPA to LPA.\n(\u22171b) Q \u2286 P \u2217Q (\u22172b) P \u2217Q \u2286 P +Q (\u22173b) If r \u2208 P \\ (P \u2217Q), then there exists a program P \u2032 such that P \u2217Q \u2286 P \u2032 \u2282 P +Q and P \u2032 is satisfiable but P \u2032 \u222a {r} is not satisfiable (\u22174b) If it holds for all P \u2032 \u2286 P that P \u2032 + Q is satisfiable iff P \u2032 + R is satisfiable, then P \u2229 (P \u2217Q) = P \u2229 (P \u2217R) (\u22175b) If Q is satisfiable, then P \u2217Q is satisfiable\nAll five postulates are direct translations of (>1)\u2013(>5). We have (\u22171b) = (\u22172) and (\u22172b) = (\u22173). (\u22173b) requires a rule r to be removed during a revision of P by Q if r contributes to making P irreconcilable with Q. (\u22174b) states that if all subsets of P that agree with Q also agree with R, then the same elements of P will be retained in a revision by Q as in a revision by R. (\u22175b) guarantees satisfiability of the revision result whenever the revising program itself is satisfiable. (\u22174b) is a stronger version of (\u22176) and (\u22175b) is a weaker version of (\u22175).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nFinally, we translate the belief base contraction postulates (\u22121)\u2013(\u22128) to logic programs, where P,Q,R \u2208 LPA and a contraction operator\n.\u2212 is a function from LPA \u00d7 LPA to LPA. ( .\u22121b) P .\u2212Q \u2286 P ( .\u22122b) If 6|=s Q, then P\n.\u2212Q 6|=s Q ( .\u22123b) If r \u2208 P \\ (P .\u2212Q), then there exists a program P \u2032 such that P .\u2212Q \u2286 P \u2032 \u2282 P and P \u2032 6|=s Q but P \u2032 \u222a {r} |=s Q ( .\u22124b) If it holds for all P \u2032 \u2286 P that P \u2032 6|=s Q iff P \u2032 6|=s R, then P\n.\u2212Q = P .\u2212R ( .\u22125b) If P 6|=s Q, then P\n.\u2212Q = P ( .\u22126b) If Q \u2261s R, then P\n.\u2212Q = P .\u2212R ( .\u22127b) P .\u2212 (Q+R) = P .\u2212Q or P .\u2212 (Q+R) = P .\u2212R or P .\u2212 (Q+R) = (P .\u2212Q)\u2229 (P .\u2212R) ( .\u22128b) If r \u2208 P \\ (P .\u2212Q), then SE(P .\u2212Q) * SE(Q) \u222a SE(r)\nThese postulates are direct translations of (\u22121)\u2013(\u22128). We have ( .\u22121b) = ( .\u22122), ( .\u22122b) = ( .\u22124), ( .\u22125b) = ( .\u22123), and ( .\u22126b) = ( .\u22126). ( .\u22123b) requires a rule r to only be removed during the contraction of P by Q if r somehow contributes to implying Q. ( .\u22124b) states that if exactly those subsets of P that do not imply Q also do not imply R, then the same elements of P will be retained in a contraction by Q as in a contraction by R. As for revision, ( .\u22124b) is again a stronger version of ( .\u22126). ( .\u22127b) specifies that a contraction by two programs is the outcome of contracting the first program, the outcome of contracting the second program, or the intersection of these two outcomes. ( .\u22128b) stipulates that r should only be removed if the contracted program has at least one SE model that is not an SE model of Q or r. While the postulates (\u22965r) and (\u22965de) are equivalent in the presence of certain other postulates in the AGM framework for propositional logic, the relationship between the postulates ( .\u22123b) and ( .\u22128b) for logic programs is hierarchical, similar as in the belief base framework. Satisfaction of ( .\u22123b) implies satisfaction of ( .\u22128b) but not vice versa.\nPROPOSITION 4.1. Let .\u2212 be a contraction operator on LPA. If .\u2212 satisfies ( .\u22123b),\nthen it satisfies ( .\u22128b).\nThe other direction does not hold as evidenced later by Example 6.6. The Levi identity [Ga\u0308rdenfors 1981; Levi 1977] allows us to construct a revision from a contraction and the Harper identity [Harper 1976] a contraction from a revision. In their propositional form, they use the classical negation of a sentence \u03b1 to construct a revision/contraction by \u03b1. For logic programs, we do not have the classical negation of a program at at our disposal. However, we can abstractly represent the Levi and Harper identities for logic programs as follows, where Q \u2208 LPA iff Q \u2208 LPA and SE(Q) = SE(Q).\nDEFINITION 4.1. Let P,Q \u2208 LPA. If \u2217 is a revision operator for P and .\u2212 a contrac-\ntion operator for P , then\nP \u2217Q = (P .\u2212Q) +Q (Levi identity),\nP .\u2212Q = P \u2229 (P \u2217Q) (Harper identity).\nWe adapted the AGM and belief base postulates to logic programs in such a way that the revising or contracting beliefs are entire programs, not just individual rules. We have thus essentially defined conditions for what is known in classic belief change as choice contraction [Fuhrmann andHansson 1994] and revision. In a choice contraction, a set of sentences may be contracted by either a single sentence or a set of sentences, for example, K \u2296 {\u03c6, \u03c8}. Yet, since adapting the postulates that exactly characterise partial meet choice contractions would yield the postulates ( .\u22121b)\u2013( .\u22123b) and ( .\u22126b), we do not have to pursue this distinction here further.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."}, {"heading": "5. PARTIAL MEET BELIEF CHANGE", "text": "Inspired by our motivation, we begin in this section with defining belief change operators for logic programs that preserve syntactic information, in order to take into account information on the program-level as well as on the rule-level. We first adapt the idea of a partial meet construction from classic belief change and formulate revision and contraction operators for logic programs. We utilise the translations of the AGM and belief base revision and contraction postulates from the previous section to test the rationality of our operators."}, {"heading": "5.1. Partial Meet Revision", "text": "As the basis for our construction of partial meet revision, we define a compatible set of some program with respect to another program as the dual of a remainder set [Alchourro\u0301n et al. 1985].\nDEFINITION 5.1 (COMPATIBLE SET). Let P,Q \u2208 LPA. The set of compatible sets of P with respect to Q is\nPQ = {R \u2286 P |SE(R) \u2229 SE(Q) 6= \u2205 and, for all R \u2032,\nR \u2282 R\u2032 \u2286 P implies SE(R\u2032) \u2229 SE(Q) = \u2205 }.\nEach compatible set is a maximal subset of P that is consistent with Q under SE semantics. Each is thus a candidate to be returned together with Q as the outcome of a revision. To determine exactly which candidate(s) to choose, we employ a selection function. In the classic case, a selection function for a belief set is defined only over a set of remainder sets of that belief set (see Section 2.2). Since we plan to use our selection function for different types of sets, we define it freely with respect to an arbitrary set as follows.\nDEFINITION 5.2 (SELECTION FUNCTION). A selection function \u03b3 for a set S is a function such that:\n(1) S \u2286 2S, (2) \u03b3(S) \u2286 S, and (3) if S 6= \u2205, then \u03b3(S) 6= \u2205.\nA special case of our selection function is the following single-choice selection function, which restricts the selection function \u03b3 to select at most one element of a set.\nDEFINITION 5.3 (SINGLE-CHOICE SELECTION FUNCTION). A single-choice selection function \u03b31 for a set S is a function such that:\n(1) S \u2286 2S, (2) \u03b31(S) = R for some R \u2208 S, and (3) if S 6= \u2205, then \u03b31(S) 6= \u2205.\nWe can now define partial meet revision for logic programs as the intersection of the selected compatible sets added to Q.\nDEFINITION 5.4 (PARTIAL MEET REVISION). Let P \u2208 LPA and \u03b3 be a selection function for P . A partial meet revision operator \u2217\u03b3 for P is defined such that for any Q \u2208 LPA:\nP \u2217\u03b3 Q =\n{\nP +Q if Q is not satisfiable, \u22c2\n\u03b3(PQ) +Q otherwise.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nWe illustrate the revision operation by an example. In the examples throughout this paper, we assume that the underlying language contains only the symbols that occur in the programs or that are otherwise mentioned explicitly.\nEXAMPLE 5.1. Let P = { a., b \u2190 a. } and Q = {\u22a5 \u2190 a. }. We have PQ = { { b \u2190 a. } } = \u03b3(PQ), for any selection function \u03b3, and thus P \u2217\u03b3 Q = { b \u2190 a., \u22a5 \u2190 a. }.\nThe following theorem states which translated AGM revision postulates the revision operator \u2217\u03b3 satisfies.\nTHEOREM 5.1. The revision operator \u2217\u03b3 satisfies (\u22171)\u2013(\u22176).\nAs in the classic case, to satisfy the supplementary revision postulates (\u22177)\u2013(\u22178) we would need to place further restrictions on the selection function.\nDEFINITION 5.5 (RELATIONAL SELECTION FUNCTION). A transitively relational selection function \u03b3\u2032 for a set S is a selection function for S such that S \u2286 2S and:\n\u03b3\u2032(S) =\n{\n\u2205 if S = \u2205, {R \u2208 S | R\u2032 \u2702R for all R\u2032 \u2208 S } otherwise,\nwhere \u2702 is a transitive relation over 2S . The relation \u2702 is maximised iff R \u2282 R\u2032 implies R\u2701R\u2032 for all R,R\u2032 \u2208 2S .\nYet, even if we make these additional restrictions on a selection function \u03b3\u2032 for P , postulates (\u22177) and (\u22178) are not satisfied by \u2217\u03b3\u2032, as shown respectively in the next two examples. For legibility, we confine the examples to abstract notation. Corresponding canonical logic programs can be constructed via the method provided by Eiter et al. [2013].\nEXAMPLE 5.2. Let P = {r1, r2, r3}with SE(r1) = {B,C}, SE(r2) = {A,C}, SE(r3) = {A,B,C}, and {r1, r3} \u2702 {r2, r3} \u2702 {r1, r3}. If SE(Q) = {A,B} and SE(Q + R) = {A}, then PQ = {{r1, r3}, {r2, r3}} and thus \u22c2\n\u03b3\u2032(PQ) = {r3}. On the other hand, we have PQ+R = {{r2, r3}} = \u22c2\n\u03b3\u2032(PQ+R). This means (P \u2217\u03b3\u2032 Q) + R = {r3} \u222a Q \u222a R while P \u2217\u03b3\u2032 (Q+R) = {r2, r3} \u222aQ \u222aR.\nEXAMPLE 5.3. Let P = {r1, r2, r3, r4, r5} with SE(r1) = {A,B,C,D,E}, SE(r2) = {A,B,C,E}, SE(r3) = {A,E}, SE(r4) = {B,E}, SE(r5) = {D,E}, and {r1, r2} \u2701 {r1, r5} \u2701 {r1, r2, r3}, {r1, r2, r4}. If SE(Q) = {A,B,C,D} and SE(Q + R) = {C,D}, then PQ = {{r1, r2, r3}, {r1, r2, r4}, {r1, r5}} and PQ+R = {{r1, r2}, {r1, r5}}. It follows from \u03b3\u2032(PQ) = {{r1, r2, r3}, {r1, r2, r4}} that \u22c2\n\u03b3\u2032(PQ) = {r1, r2}, while \u03b3\u2032(PQ+R) = {{r1, r5}} = \u22c2\n\u03b3\u2032(PQ+R). Therefore, (P \u2217\u03b3\u2032 Q) +R = {r1, r2} \u222aQ\u222aR * {r1, r5} \u222aQ\u222aR = P \u2217\u03b3\u2032 (Q+R). Note that SE((P \u2217\u03b3\u2032 Q)+R) = SE( \u22c2\n\u03b3\u2032(PQ))\u2229SE(Q+R) = {A,B,C,E}\u2229 {C,D} = {C} 6= \u2205.\nOur partial meet revision operator does not satisfy the entire set of AGM revision postulates, only the subset of basic postulates (\u22171)\u2013(\u22176). This stands in contrast to the result in classical logics, according to which any partial meet revision operator is characterised by the set of basic and supplementary revision postulates. However, that result holds for logically closed belief sets, and when we consider our partial meet revision operator \u2217\u03b3 in the light of the belief base framework, we obtain the following representation theorem.\nTHEOREM 5.2. An operator \u2217\u03b3 is a partial meet revision operator for P \u2208 LPA determined by a selection function \u03b3 for P iff \u2217\u03b3 satisfies (\u22171b)\u2013(\u22175b).\nReturning to our motivation, we now give some formal examples to highlight the drawbacks of the distance-based revision operator and then show how our partial meet\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\noperator addresses these. Recall that the distance-based revision operator \u22c6 does not specify the structure of the revised program. For convenience, we provide a possible program that corresponds to the revision outcome for each example below, which we denote by P \u22c6 Q.\n1) P = { a., b \u2190 a. } P \u22c6 Q = {\u22a5 \u2190 a., b. }\nQ = {\u22a5 \u2190 a. } SE(P \u22c6 Q) = {(b, b)}\n2) P = {\u22a5 \u2190 a., b \u2190 not a. } P \u22c6 Q = { a., b. }\nQ = { a. } SE(P \u22c6 Q) = {(ab, ab)}\n3) P = {\u22a5 \u2190 a., b \u2190 a. } P \u22c6 Q = { a. }\nQ = { a. } SE(P \u22c6 Q) = {(a, a), (a, ab), (ab, ab)}\n4) P = { a., b \u2190 not a. } P \u22c6 Q = {\u22a5 \u2190 a. }\nQ = {\u22a5 \u2190 a. } SE(P \u22c6 Q) = {(\u2205, \u2205), (\u2205, b), (b, b)}\n5) P = { a., b \u2190 not c. } P \u22c6 Q = { a., b., \u22a5 \u2190 c. }\nQ = {\u22a5 \u2190 c. } SE(P \u22c6 Q) = {(ab, ab)} Examples 1) and 2) demonstrate that the revision operator \u22c6 does not satisfy the support property. In Example 1), the initial belief state expressed by program P consists of a and b. In fact, the second rule in P says that we believe b if we believe a. After revising by the program Q, which simply states that we do not believe a, we still believe b even though the reason to believe b is not given any more. The explanation for this is that the revision operator acts on a program-level, not on a rule-level, as it considers just the SE models of the program in its entirety. However, the dependency of b on a is not captured by the SE models of the program, only by the SE models of the second rule. Therefore, b is treated as an independent fact during the revision process. The situation is similar in Example 2). Here, we initially believe b due to the absence of belief a. After the revision, we continue to believe b even though the grounds for b do not exist any more. Examples 3) and 4) demonstrate that the revision operator \u22c6 does not satisfy the preservation property. In Example 3), according to our initial belief state expressed by program P , we believe b whenever we believe a, but since we do not believe a currently, we are indifferent with respect to b at the moment. After revising by programQ, which states that we now believe a, we are still indifferentwith respect to b. In Example 4), we initially believe a and would believe b whenever we do not believe a or are indifferent with respect to a. After revising by Q, which carries the information that we do not believe a any longer, we are still indifferent with respect to b. In both examples, the revision operation effectively disregards the second rule in P . However, there is no justification for such behaviour, as the information in Q only conflicts with the first rule in P , so that the second rule in P can safely be retained and thus b should be derived in both examples. This behaviour is due to the fact that the set of SE models of P is exactly the set of SE models of the first rule. The second rule is invisible in the program-level view. Consequently, the revision operator returns a result as if P had consisted merely of the first rule. Finally, Example 4) stands in stark contrast to Example 5), where the revision operation coincides with expansion. In Example 5), we are indifferent with respect to b initially and should believe b when we do not believe c or are indifferent with respect to c. The revising program Q contains information that c indeed does not hold. Thus, b is incorporated into the new belief state. Yet, Example 4) described a similar scenario in which b is not included in the resulting belief state, thereby showing a clear discrep-\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nancy to the behaviour of the revision operator in Example 5). Since the set of SE models of the first rule of P in Example 5) is not a subset of the set of SE models of the second rule, the latter is preserved during the revision operation. It becomes apparent from this comparison that some dependencies between atoms expressed in P are respected by the revision operator \u22c6, while others are not. We now show that our partial meet revision operator \u2217\u03b3 addresses these shortcomings of the distance-based revision method. Below are the results of our partial meet revision operator for the five examples above. In each example, the result is independent of the choice of selection function.\n1) P \u2217\u03b3 Q = {\u22a5 \u2190 a., b \u2190 a. }\nSE(P \u2217\u03b3 Q) = {(\u2205, \u2205), (\u2205, b), (b, b)}\n2) P \u2217\u03b3 Q = { a., b \u2190 not a. }\nSE(P \u2217\u03b3 Q) = {(a, a), (a, ab), (ab, ab)}\n3) P \u2217\u03b3 Q = { a., b \u2190 a. }\nSE(P \u2217\u03b3 Q) = {(ab, ab)}\n4) P \u2217\u03b3 Q = {\u22a5 \u2190 a., b \u2190 not a. }\nSE(P \u2217\u03b3 Q) = {(b, b)}\n5) P \u2217\u03b3 Q = { a., b \u2190 not c., \u22a5 \u2190 c. }\nSE(P \u2217\u03b3 Q) = {(ab, ab)} In Examples 1) and 2), the partial meet revision operator preserves the dependency of b on a and not a, respectively. This is expressed on the syntactic level by the revised program P \u2217\u03b3Q and on the semantic level by SE(P \u2217\u03b3Q). In Examples 3) and 4), our partial meet revision operator takes into account all rules in a program, even those that may be \u201cinvisible\u201d from a purely model-based perspective, as shown by the respective revision outcomes. Finally, regarding Examples 4) and 5), our partial meet revision operator treats the dependency of b on not a and not c, respectively, in the same manner and adds b to the belief state uniformly in both examples. The reason for this behaviour is that our partial meet construction enables us to preserve information expressed on the rule-level by the individual rules in a program. Revisiting our two real-life examples from the introduction, we can see that our partial meet revision operator returns the desired results. The first example (\u201cfireworks\u201d) was formalised as Example 3) above, where a = fog and b = no fireworks. Applying the revision operator \u2217\u03b3 returns { fog., no fireworks \u2190 fog. }, that is, it leaves us with the beliefs that it will be foggy and that there are no fireworks whenever it is foggy, from which we can derive that the fireworks will be cancelled. The second example (\u201c101 or 280\u201d) was formalised as Example 1), where a = 101 roadworks and b = 280 quicker. Applying the revision operator \u2217\u03b3 to this example returns {\u22a5 \u2190 101 roadworks., 280 quicker \u2190 101 roadworks. }, that is, we believe that there are no roadworks on the 101 and that the 280 is quicker whenever there are roadworks on the 101, but not that the 280 is still the better choice. Regarding the screened semi-revision approach by Kru\u0308mpelmann and KernIsberner [2012] (see Section 3), we can show that our partial meet revision operator \u2217\u03b3 is a generalisation of their screened consolidation operator !\u03b3P . For any P,Q \u2208 LPA with Q \u2286 P , let\nP\u22a5SE! Q = {R |Q \u2286 R \u2286 P, SE(R) 6= \u2205, and, for all R \u2032,\nR \u2282 R\u2032 \u2286 P implies SE(R\u2032) = \u2205 },\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nand P !SE\u03b3P Q = \u03b3P (P\u22a5 SE ! Q).\nPROPOSITION 5.1. Let P,Q \u2208 LPA. For any maxichoice selection function \u03b3P for P , there exists a selection function \u03b3 for P such that (P \u222aQ)!SE\u03b3P Q = P \u2217\u03b3 Q.\nConversely, if we translate our partial meet revision operator \u2217\u03b3 to answer set semantics and restrict our selection function to be single-choice, then it will coincide with the screened consolidation operator !\u03b3P . Before we can do so, we need to translate our definition of compatible sets to answer set semantics. For any P,Q \u2208 LPA, let\nPASQ = {R \u2286 P |AS(R \u222aQ) 6= \u2205 and, for all R \u2032,\nR \u2282 R\u2032 \u2286 P implies AS(R\u2032 \u222aQ) = \u2205 }.\nDEFINITION 5.6 (PARTIAL MEET REVISION UNDER ANSWER SET SEMANTICS). Let P \u2208 LPA and \u03b3\n1 be a single-choice selection function for P . A partial meet revision operator \u2217AS\u03b31 for P under answer set semantics is defined such that for any Q \u2208 LPA:\nP \u2217AS\u03b31 Q =\n{\nP \u222aQ if AS(Q) = \u2205 and PASQ = \u2205, \u03b31(PASQ ) \u222aQ otherwise.\nPROPOSITION 5.2. Let P,Q \u2208 LPA and \u03b31, \u03b3P be single-choice and maxichoice selection functions, respectively, for P such that \u03b31(2P ) \u222a Q = \u03b3P ({R \u222a Q | R \u2208 2\nP }). Then P \u2217AS\u03b31 Q = (P \u222aQ)!\u03b3P Q."}, {"heading": "5.2. Partial Meet Contraction", "text": "Having defined a revision operator, we now turn to the case of belief contraction. In line with classic belief change, the contraction of a program P by a program Q should eliminate from P all those beliefs from which Q can be derived. We use the complement of SE(Q), denoted by SE(Q), to determine all maximal subsets of P that do not imply Q, called remainder sets.\nDEFINITION 5.7 (REMAINDER SET). Let P,Q \u2208 LPA. The set of remainder sets of P with respect to Q is\nP\u2212Q = {R \u2286 P |SE(R) \u2229 SE(Q) 6= \u2205 and, for all R \u2032,\nR \u2282 R\u2032 \u2286 P implies SE(R\u2032) \u2229 SE(Q) = \u2205 }.\nDEFINITION 5.8 (PARTIAL MEET CONTRACTION). Let P \u2208 LPA and \u03b3 be a selection function for P . A partial meet contraction operator .\u2212\u03b3 for P is defined such that for any Q \u2208 LPA:\nP .\u2212\u03b3 Q =\n{\nP if |=s Q, \u22c2\n\u03b3(P\u2212Q) otherwise.\nThe following example demonstrates the contraction operation.\nEXAMPLE 5.4. Let P = { a., b \u2190 a. } and Q = { a \u2190 b. }. Since SE(Q) = {(\u2205, b), (b, b), (b, ab)}, SE({ a. }) = {(a, a), (a, ab), (ab, ab)}, and SE({ b \u2190 a. }) = {(\u2205, \u2205), (\u2205, b), (b, b), (\u2205, ab), (b, ab), (ab, ab)}, it follows that P\u2212Q = { { b \u2190 a. } } = \u03b3(P \u2212 Q), for any selection function \u03b3, and thus we obtain P .\u2212\u03b3 Q = { b \u2190 a. }.\nThe next theorem lists the translated AGM contraction postulates that are fulfilled by .\u2212\u03b3 .\nTHEOREM 5.3. The contraction operator .\u2212\u03b3 satisfies ( .\u22121)\u2013( .\u22124) and ( .\u22126).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nIt is easy to see from Example 5.4 above that .\u2212\u03b3 does indeed not satisfy ( .\u22125).\nIn the AGM framework, it is sufficient that the selection function \u03b3 is determined by a transitive relation so that \u2296 satisfies (\u22967). Here, we require the relation \u2702 to be maximised as well to guarantee satisfaction of ( .\u22127). This is in line with the result for partial meet base contractions, which also require the underlying selection function to be determined by a maximised transitive relation in order to satisfy such a property [Hansson 1993].\nTHEOREM 5.4. Let \u03b3\u2032 be determined by a maximised transitive relation. The contraction operator .\u2212\u03b3\u2032 satisfies ( .\u22127).\nThe following example demonstrates that .\u2212\u03b3\u2032 does not satisfy ( .\u22128).\nEXAMPLE 5.5. Consider again P and \u2702 from Example 5.3. If SE(Q) = {A,B,E}\nand SE(Q + R) = {E}, then SE(Q) = {C,D} and SE(Q+R) = {A,B,C,D}. We obtain P\u2212Q+R = {{r1, r2, r3}, {r1, r2, r4}, {r1, r5}} and P \u2212 Q = {{r1, r2}, {r1, r5}}. It follows from \u03b3\u2032(P\u2212Q+R) = {{r1, r2, r3}, {r1, r2, r4}} that \u22c2 \u03b3\u2032(P\u2212Q+R) = {r1, r2}, while \u03b3 \u2032(P\u2212Q) = {{r1, r5}} and thus \u22c2 \u03b3\u2032(P\u2212Q) = {r1, r5}. Therefore, P .\u2212\u03b3\u2032 (Q + R) = {r1, r2} * {r1, r5} = P .\u2212\u03b3\u2032 Q. Note that SE(P .\u2212\u03b3\u2032 (Q +R)) = SE( \u22c2\n\u03b3\u2032(P\u2212Q+R)) = {A,B,C,E} * {A,B,E} = SE(Q).\nAs in the case of our revision operator earlier, our partial meet contraction operator does not properly align with the AGM framework, but the following representation theorem holds for the contraction operator .\u2212\u03b3 with respect to the belief base postulates.\nTHEOREM 5.5. An operator .\u2212\u03b3 is a partial meet contraction operator for P \u2208 LPA determined by a selection function \u03b3 for P iff .\u2212\u03b3 satisfies ( .\u22121b)\u2013( .\u22124b).\nBesides the representation theorem above via ( .\u22121b)\u2013( .\u22124b), we have the following additional properties of .\u2212\u03b3 regarding the remaining belief base contraction postulates ( .\u22125b)\u2013( .\u22128b).\nPROPOSITION 5.3. The contraction operator .\u2212\u03b3 satisfies ( .\u22125b), ( .\u22126b), and ( .\u22128b).\nThe next example illustrates that .\u2212\u03b3 does not satisfy ( .\u22127b).\nEXAMPLE 5.6. Let P = {r1, r2, r3, r4} with SE(r1) = {A,B,C,D,E}, SE(r2) = {A,B,E}, SE(r3) = {A,C,E}, and SE(r4) = {C,D,E}. If SE(Q) = {A,D,E} and\nSE(R) = {B,C,E}, then SE(Q) = {B,C}, SE(R) = {A,D}, and SE(Q+R) = {A,B,C,D}. We thus have P\u2212Q = {{r1, r2}, {r1, r3, r4}}, P \u2212 R = {{r1, r2, r3}, {r1, r4}}, and P\u2212Q+R = {{r1, r2, r3}, {r1, r3, r4}}. Let \u03b3(P \u2212 Q) = P \u2212 Q, \u03b3(P \u2212 R) = P \u2212 R, and \u03b3(P \u2212 Q+R) = P \u2212 Q+R. It then follows that \u22c2\n\u03b3(P\u2212Q) = {r1}, \u22c2 \u03b3(P\u2212R) = {r1}, and \u22c2 \u03b3(P\u2212Q+R) = {r1, r3}. Therefore, P .\u2212\u03b3 (Q +R) 6= P .\u2212\u03b3 Q = P .\u2212\u03b3 R = (P .\u2212\u03b3 Q) \u2229 (P .\u2212\u03b3 R)."}, {"heading": "6. ENSCONCEMENT BELIEF CHANGE", "text": "In this section, we will introduce further belief revision and contraction operators for logic programs, which are based on an ordering over the beliefs contained in a program. We begin by defining an ensconcement relation for logic programs as follows.\nDEFINITION 6.1 (ENSCONCEMENT). Let P \u2208 LPA. An ensconcement associated with P is any total preorder on P that satisfies the following conditions:\n( 1) For any r \u2208 P : SE({ r\u2032 \u2208 P \\ {r} | r r\u2032 }) 6\u2282 SE(r) ( 2) For any r, r\u2032 \u2208 P : r r\u2032 r iff {r} \u2261s {r\u2032}\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPer this definition, an ensconcement associated with a logic program P is simply an ordering over the rules occurring in P . With P representing our entire set of beliefs, an ensconcement enables us to sort rules of P , which form our individual beliefs, hierarchically by their epistemic importance, or in other words, by how willing we are to give up one belief over another. Informally, r \u227a r\u2032 means that the beliefs represented by r\u2032 are more important to us than the beliefs represented by r. Condition ( 1) states that the set of SE models of any rule or combination of rules at least as ensconced as a given rule r may not be a proper subset of the set of SE models of r. Condition ( 2) requires that strongly equivalent rules are equally ensconced. Condition ( 1) is formulated slightly stronger than Condition (41) (see Section 2.2) from the original definition [Williams 1994]. Condition (41) allows a sentence \u03c8, that implies a sentence \u03c6 without being equivalent to \u03c6, to be placed on the same ensconcement level as \u03c6. In contrast, Condition ( 1) prohibits strict implication on the same ensconcement level. For instance, given rules a., a \u2190 b., and a; b. contained in some program, both a \u2190 b. and a; b. must be strictly more ensconced than a. according to Condition ( 1), whereas in a direct adaptation of Condition (41) at least one of the two rules a \u2190 b. and a; b. would have to be equally ensconced as a.. The merit of this additional restriction will become evident shortly, when we show some examples of applying an ensconcement to perform revision operations in Section 6.1. The idea behind Condition (42) of the original definition is that any tautologies must be most ensconced, a requirement that is automatically captured in our Condition ( 1). Using the concept of logic program ensconcements, we now go on to define logic program revision and contraction operators and investigate their properties."}, {"heading": "6.1. Ensconcement Revision", "text": "During a revision operation, new information from a program Q is added to an initial belief state in the form of a program P , and some beliefs from P have to be given up to achieve a consistent outcome. When the beliefs in P are ordered by an ensconcement, we can introduce the notion of a cut to determine the specific level in the ensconcement where all beliefs on and above this level are consistent with the revising program. Since an ensconcement associated with P is a relation over all rules of P , when we write r r\u2032, we implicitly mean r \u2208 P and r\u2032 \u2208 P .\nDEFINITION 6.2 (CUT). Let P,Q \u2208 LPA and be an ensconcement associated with P . The (proper) cut of P for Q, written cut (Q), is defined as\ncut (Q) = { r \u2208 P | SE ({ r \u2032 \u2208 P | r r\u2032 }) \u2229 SE(Q) 6= \u2205 } .\nSome interesting properties of the cut are listed below.\nLEMMA 6.1. Let P,Q,R \u2208 LPA and be an ensconcement associated with P .\na) If P +Q is satisfiable, then cut (Q) = P . b) If Q is satisfiable, then cut (Q) +Q is satisfiable. c) If Q is not satisfiable, then cut (Q) = \u2205. d) If Q |=s R, then cut (Q) \u2286 cut (R). e) cut (Q+R) \u2286 cut (Q). f) If cut (Q) |=s R, then cut (Q+R) = cut (Q).\nA cut is the principal element for the following definition of an ensconcement revision operator.\nDEFINITION 6.3 (ENSCONCEMENT REVISION). Let P \u2208 LPA and be an ensconcement associated with P . An ensconcement revision operator \u2217 for P is defined such\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nthat for any Q \u2208 LPA:\nP \u2217 Q =\n{\nP +Q if Q is not satisfiable,\n{ r \u2208 P | SE(cut (Q)) \u2229 SE(Q) \u2286 SE(r) } +Q otherwise.\nThe revision operator \u2217 retains all elements of the cut. This is an obvious requirement since the cut contains our most firmly held beliefs which are entirely consistent withQ. In addition, any rule of P not in the cut that shares the same SEmodels withQ as the cut is retained as well. The example below illustrates the operation.\nEXAMPLE 6.1. Let P = { a., a \u2190 b., b \u2190 a. } and Q = {\u22a5 \u2190 b. }. Figure 1 shows all possible ensconcements associated with P , with rules displayed at the top being more ensconced than rules at the bottom. We have the following results:\n1. cut 1(Q) = { a \u2190 b., b \u2190 a. } and P \u2217 1 Q = { a \u2190 b., b \u2190 a., \u22a5 \u2190 b. } 2. cut 2(Q) = { a \u2190 b., b \u2190 a. } and P \u2217 2 Q = { a \u2190 b., b \u2190 a., \u22a5 \u2190 b. } 3. cut 3(Q) = { a \u2190 b., b \u2190 a. } and P \u2217 3 Q = { a \u2190 b., b \u2190 a., \u22a5 \u2190 b. } 4. cut 4(Q) = { a \u2190 b. } and P \u2217 4 Q = { a \u2190 b., \u22a5 \u2190 b. } 5. cut 5(Q) = { a \u2190 b., a. } and P \u2217 5 Q = { a \u2190 b., a., \u22a5 \u2190 b. }\nIn Example 6.1, the belief expressed by the combination of rules { a. } and { b \u2190 a. } is inconsistent with the new information {\u22a5 \u2190 b. }. Thus, at least one of these two rules must be discarded to reach a consistent belief state, while the rule { a \u2190 b. } can be safely retained. The example shows that the revision operator \u2217 indeed retains { a \u2190 b. } in all cases and discards one or both other rules depending on their ensconcement level. Whenever { b \u2190 a. } is more ensconced than { a. }, the latter is discarded and vice versa. Only when both rules are equally ensconced, that is, when we cannot make up our mind which the two beliefs we hold more firmly, the revision operator discards both. We can see from the definition of \u2217 that the set of SE models of P \u2217 Q is exactly the set of SE models that are shared by cut (Q) and Q.\nPROPOSITION 6.1. Let P,Q \u2208 LPA and be an ensconcement associated with P . Then SE(P \u2217 Q) = SE(cut (Q) +Q).\nThe next theorem states which of the adapted AGM revision postulates the revision operator \u2217 satisfies.\nTHEOREM 6.1. The revision operator \u2217 satisfies (\u22171)\u2013(\u22176) and (\u22178).\nThe revision operator \u2217 does not satisfy (\u22177), as shown in the next example.\nEXAMPLE 6.2. Let P = {r1, r2, r3}with SE(r1) = {B,C}, SE(r2) = {A,C}, SE(r3) = {A,B,C}, and be an ensconcement associated with P such that r1 r2 r1 \u227a r3. If SE(Q) = {A,B} and SE(Q + R) = {A}, then cut (Q) = cut (Q + R) = {r3}, yet (P \u2217 Q) +R = {r3} \u222aQ \u222aR while P \u2217 (Q +R) = {r2, r3} \u222aQ \u222aR.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nEven though ensconcement revision was originally defined for belief bases, our ensconcement revision operator \u2217 satisfies the majority of AGM revision postulates for belief sets. Our operator does not satisfy any of the postulates that are unique to the belief base framework, as stated in the next theorem.\nTHEOREM 6.2. The revision operator \u2217 satisfies (\u22171b), (\u22172b), and (\u22175b).\nIn the following two examples, we illustrate that \u2217 does indeed not satisfy (\u22173b) and (\u22174b), respectively.\nEXAMPLE 6.3. Let SE = {A,B,C,D}, SE(Q) = {A,B}, and P = {r1, r2, r3} with SE(r1) = {C,D}, SE(r2) = {B,C}, and SE(r3) = {A,B,C}. If is an ensconcement associated with P such that r1 r2 r1 \u227a r3, then cut (Q) = {r3} and P \u2217 Q = {r3}+Q. While r2 \u2208 P\\(P\u2217 Q), there exists no program P \u2032 such that P\u2217 Q \u2286 P \u2032 \u2286 P+Q and P \u2032 is satisfiable but P \u2032 \u222a {r2} is not satisfiable.\nEXAMPLE 6.4. Let SE = {A,B,C,D}, SE(Q) = {A,B}, SE(R) = {A}, and P = {r1, r2, r3} with SE(r1) = {C,D}, SE(r2) = {A,C}, and SE(r3) = {A,B,C}. If is an ensconcement associated with P such that r1 r2 r1 \u227a r3, then it holds for any P \u2032 \u2286 P that P \u2032+Q is satisfiable iff P \u2032+R is satisfiable. However, we have cut (Q) = {r3} and P \u2229 (P \u2217 Q) = {r3}, while cut (R) = {r3} and P \u2229 (P \u2217 R) = {r2, r3}.\nWe will now examine the behaviour of our ensconcement revision operator with respect to the set of five examples from Section 5.1. In each example, the revision outcome is independent of the possible ensconcements that can be associated with P .\n1) P \u2217 Q = {\u22a5 \u2190 a., b \u2190 a. }\nSE(P \u2217 Q) = {(\u2205, \u2205), (\u2205, b), (b, b)}\n2) P \u2217 Q = { a., b \u2190 not a. }\nSE(P \u2217 Q) = {(a, a), (a, ab), (ab, ab)}\n3) P \u2217 Q = { a., b \u2190 a. }\nSE(P \u2217 Q) = {(ab, ab)}\n4) P \u2217 Q = {\u22a5 \u2190 a., b \u2190 not a. }\nSE(P \u2217 Q) = {(b, b)}\n5) P \u2217 Q = { a., b \u2190 not c., \u22a5 \u2190 c. }\nSE(P \u2217 Q) = {(ab, ab)} For all five examples, the ensconcement revision operator \u2217 returns the same desired results as the partial meet revision operator \u2217\u03b3 . Examining in particular Examples 3) and 4), it now becomes evident why we diverted in our formulation of Condition ( 1) from the classic definition. Condition ( 1) prohibits strict implication on the same ensconcement level. Without this refined requirement, for Example 3) we could construct an ensconcement associated with P such that \u22a5 \u2190 a. b \u2190 a. \u22a5 \u2190 a., which would give us the outcome P \u2217 Q = { a. }. For Example 4), we could construct an ensconcement associated with P such that a. b \u2190 not a. a., which would lead to the outcome P \u2217 Q = {\u22a5 \u2190 a. }. These revision outcomes would correspond exactly to the undesired results of the distance-based revision operator \u22c6, which we set out to avoid because they disrespect the preservation property."}, {"heading": "6.2. Ensconcement Contraction", "text": "We now use the concept of an ensconcement to present another contraction operator for logic programs. Analogous to revision, we first define for some P,Q \u2208 LPA and an\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nensconcement associated with P that\ncut\u2212 (Q) = { r \u2208 P | SE ({ r \u2032 \u2208 P | r r\u2032 }) \u2229 SE(Q) 6= \u2205 }.\nSome useful properties of cut\u2212 (Q) are listed here.\nLEMMA 6.2. Let P,Q,R \u2208 LPA.\na) If P 6|=s Q, then cut \u2212 (Q) = P . b) If 6|=s Q, then cut \u2212 (Q) 6|=s Q. c) If |=s Q, then cut \u2212 (Q) = \u2205. d) If Q |=s R, then cut \u2212 (R) \u2286 cut \u2212 (Q). e) cut\u2212 (Q) \u2286 cut \u2212 (Q+R).\nf) If cut\u2212 (Q) |=s R, then cut \u2212 (Q+R) = cut \u2212 (Q).\ng) If cut\u2212 (Q) 6|=s R, then cut \u2212 (Q+R) = cut \u2212 (R).\nDEFINITION 6.4 (ENSCONCEMENT CONTRACTION). Let P \u2208 LPA and be an ensconcement associated with P . An ensconcement contraction operator .\u2212 for P is defined such that for any Q \u2208 LPA:\nP .\u2212 Q =\n{\nP if |=s Q, { r \u2208 P | SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) } otherwise.\nThe contraction operator .\u2212 works in a dual way to the revision operator \u2217 . It relies on cut\u2212 (Q) to determine from which level upward in the ensconcement associated\nwith P elements are retained in the operation, and adds any further parts of P that do not compromise the set of SE models of cut\u2212 (Q) inconsistent with Q.\nWe can formalise the relationship between the SE models of P .\u2212 Q and cut \u2212 (Q) as\nfollows.\nPROPOSITION 6.2. Let P,Q \u2208 LPA and be an ensconcement associated with P . Then SE(P .\u2212 Q) \u2229 SE(Q) = SE(cut \u2212 (Q)) \u2229 SE(Q).\nThe contraction operator .\u2212 satisfies all AGM contraction postulates except Recovery.\nTHEOREM 6.3. The contraction operator .\u2212 satisfies ( .\u22121)\u2013( .\u22124) and ( .\u22126)\u2013( .\u22128).\nThe next example shows why .\u2212 does not satisfy the Recovery postulate ( .\u22125).\nEXAMPLE 6.5. Consider again P and Q from Example 5.4. For any ensconcement associated with P , it holds that P\n.\u2212 Q = { b \u2190 a. }. Thus, P = { a., b \u2190 a. } * { b \u2190 a., a \u2190 b. } = (P .\u2212 Q) +Q.\nThe main reason for non-satisfaction of Recovery is that our ensconcement contraction operator .\u2212 operates on programs that are not logically closed, and Recovery is a key AGM postulate that characterises contractions of logically closed belief sets. On the other hand, our ensconcement contraction operator satisfies the same set of belief base postulates as its classic counterpart.\nTHEOREM 6.4. The contraction operator .\u2212 satisfies (\u22121b), (\u22122b) and (\u22125b)\u2013(\u22128b).\nThe following two examples demonstrate that the contraction operator .\u2212 does not satisfy ( .\u22123b) and ( .\u22124b), respectively.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nEXAMPLE 6.6. Let SE = {A,B,C,D}, SE(Q) = {C}, and consider again P and from Example 6.3. Then cut\u2212 (Q) = {r3} = P .\u2212 Q. While r2 \u2208 P \\ (P .\u2212 Q), there exists no program P \u2032 such that P .\u2212 Q \u2286 P \u2032 \u2286 P and P \u2032 6|=s Q but P \u2032 \u222a {r2} |=s Q.\nEXAMPLE 6.7. Let SE = {A,B,C,D}, SE(Q) = {C}, SE(R) = {B,C}, and consider again P and from Example 6.4. Then it holds for any P \u2032 \u2286 P that P \u2032 6|=s Q iff P \u2032 6|=s R. However, we have cut \u2212 (Q) = {r3} and P .\u2212 Q = {r3}, while cut \u2212 (R) = {r3} and P .\u2212 R = {r2, r3}."}, {"heading": "7. CONNECTIONS BETWEEN THE OPERATORS", "text": "Having defined partial meet revision and contraction operators and ensconcement revision and contraction operators in the previous sections, we now establish the formal connections between them. We first relate partial meet revision to ensconcement revision and partial meet contraction to ensconcement contraction. We then investigate whether the granularity of ensconcements, that is, whether an ensconcement is defined over rules or subsets of a program, influences that relationship. Finally, we connect partial meet revision to partial meet contraction and ensconcement revision to ensconcement contraction via the Levi and Harper identities."}, {"heading": "7.1. Relating Partial Meet Operators to Ensconcement Operators", "text": "We already saw from the set of postulates that \u2217 and \u2217\u03b3 satisfy, that partial meet revision and ensconcement revision share similar properties. In the following characterisation theorem we state the exact relationship between the two.\nTHEOREM 7.1. Let P,Q \u2208 LPA. For any selection function \u03b3, there exists an ensconcement associated with P such that P \u2217\u03b3 Q = P \u2217 Q.\nTheorem 7.1 asserts that \u2217\u03b3 can be characterised in terms of \u2217 . The other direction is not possible, as shown in the example below.\nEXAMPLE 7.1. Let P = { a., b., c. }, Q = {\u22a5 \u2190 a. }, and be the ensconcement associated with P as shown in Figure 2. It follows that cut (Q) = { c. } and P \u2217 Q = { c., \u22a5 \u2190 a. }. Yet PQ = { { b., c. } } = \u03b3(PQ), for any selection function \u03b3, so that P \u2217\u03b3Q = { b., c., \u22a5 \u2190 a. }. We have P \u2217 Q 6= P \u2217\u03b3 Q.\nOn the one hand, the requirement SE(cut (Q)) \u2229 SE(Q) \u2286 SE(R) in Definition 6.3 requires any subset R of P that is not part of the cut to have all SE models shared by the cut and Q, in order to be included in the revision outcome. In the previous example, the SE models shared by the cut and Q are (c, c), (c, bc), and (bc, bc). Since (c, c) 6\u2208 SE({ b. }) (and also (c, bc) 6\u2208 SE({ b. })), it follows that { b. } * P \u2217 Q. On the other hand, the definition of partial meet revision is based on compatible sets, which are required to be maximal and to share only a minimum of one SE model with Q (Definition 5.1). This requirement limits the result of a partial meet revision for this example to the one above, regardless of the the type of selection function employed. We also find that the partial meet contraction operator .\u2212\u03b3 can be characterised in terms of the ensconcement contraction operator .\u2212 , formalised in the next theorem.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nTHEOREM 7.2. Let P,Q \u2208 LPA. For any selection function \u03b3, there exists an ensconcement associated with P such that P .\u2212\u03b3 Q = P .\u2212 Q.\nThe other direction of this theorem does not hold. Consider again P and from Example 7.1 and let Q = { a. }. It is easy to see that P .\u2212\u03b3 Q 6= P\n.\u2212 Q, for any selection function \u03b3."}, {"heading": "7.2. Granularity of Ensconcements", "text": "For our partial meet construction, we determined the outcome of a revision or contraction operation by employing a function that selects among subsets of a program. For our ensconcement construction, we then used an ordering over individual rules of a program to select the rules to retain during a revision or contraction operation. Given the Characterisation Theorems 7.1 and 7.2 that hold only in one direction, it is worth investigating whether this difference in granularity, subsets or rules, plays a critical role in determining revision or contraction outcomes. To do so, we will now consider program subsets as the objects of change for our ensconcement revision and contraction operators. We begin with the definition of an ensconcement over subsets of a program.\nDEFINITION 7.1 (ENSCONCEMENT OVER SUBSETS). Given P \u2208 LPA, a subsetensconcement associated with P is any total preorder R on 2P that satisfies the following conditions:\n( R1) For any R \u2286 P : SE({R\u2032 \u2286 P \\R | R R\u2032 }) 6\u2282 SE(R) ( R2) For any R,R\u2032 \u2286 P : R R\u2032 R iff R \u2261s R\u2032\nWe define revision and contraction operators based on R as follows.\nDEFINITION 7.2 (SUBSET-ENSCONCEMENT REVISION). Let P \u2208 LPA and R be a subset-ensconcement associated with P . A subset-ensconcement revision operator \u2217 R for P is defined such that for any Q \u2208 LPA:\nP \u2217 R Q =\n{\nP +Q if Q is not satisfiable,\n{R \u2286 P | SE(cut R(Q)) \u2229 SE(Q) \u2286 SE(R) }+Q otherwise,\nwhere cut R(Q) = {R \u2286 P | SE ({R \u2032 \u2286 P | R R\u2032 }) \u2229 SE(Q) 6= \u2205 }.\nDEFINITION 7.3 (SUBSET-ENSCONCEMENT CONTRACTION). Let P \u2208 LPA and R be a subset-ensconcement associated with P . A subset-ensconcement contraction operator .\u2212 R for P is defined such that for any Q \u2208 LPA:\nP .\u2212 R Q =\n{\nP if |=s Q, {R \u2286 P | SE(cut\u2212 R (Q)) \u2229 SE(Q) \u2286 SE(R) } otherwise,\nwhere cut\u2212 R(Q) = {R \u2286 P | SE ({R \u2032 \u2286 P | R R\u2032 }) \u2229 SE(Q) 6= \u2205 }.\nIt turns out that it does not matter whether an ensconcement over subsets of a program or only over the individual rules is used to determine a revision or contraction outcome, provided that the individual rules are ordered in the same way in both ensconcements, as stated in the following theorem.\nTHEOREM 7.3. Let P,Q \u2208 LPA, be an ensconcement associated with P , and R a subset-ensconcement associated with P such that {r} R {r\u2032} iff r r\u2032 for all r, r\u2032 \u2208 P . Then P \u2217 Q = P \u2217 R Q (or P .\u2212 Q = P .\u2212 R Q, alternatively).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."}, {"heading": "7.3. Relating Revision Operators to Contraction Operators", "text": "We now formalise the connection between partial meet revision and partial meet contraction with the help of the Levi and Harper identities as given in Definition 4.1.\nPROPOSITION 7.1. Let P \u2208 LPA, \u03b3 be a selection function for P , and \u2217 an operator for P such that for any Q \u2208 LPA: P \u2217Q = (P .\u2212\u03b3 Q) +Q. Then P \u2217Q = P \u2217\u03b3 Q.\nPROPOSITION 7.2. Let P \u2208 LPA, \u03b3 be a selection function for P , and .\u2212 an operator\nfor P such that for any Q \u2208 LPA: P .\u2212Q = P \u2229 (P \u2217\u03b3 Q). Then P .\u2212Q = P .\u2212\u03b3 Q.\nThe characterisation via Levi and Harper identities also holds for ensconcement revision and ensconcement contraction.\nPROPOSITION 7.3. Let P \u2208 LPA, be an ensconcement associated with P , and \u2217 an operator for P such that for anyQ \u2208 LPA: P \u2217Q = (P .\u2212 Q)+Q. Then P \u2217Q = P \u2217 Q.\nPROPOSITION 7.4. Let P \u2208 LPA, be an ensconcement associated with P , and .\u2212\nan operator for P such that for anyQ \u2208 LPA: P .\u2212Q = P\u2229(P \u2217 Q). Then P .\u2212Q = P .\u2212 Q."}, {"heading": "8. LOCALISED BELIEF CHANGE", "text": "In Sections 5 and 6, we introduced two new sets of belief change operators for logic programs. While the definitions of our operators are based on classic declarative constructions, such formulations may not be optimal for practical implementations. In particular, the formation of a set of compatible sets to conduct a partial meet revision or contraction requires that all possible combinations of all rules in a program are evaluated with respect to their sets of SE models. When dealing with logic programs that contain a large number of rules, where only a small number of them are actually affected by the change operation, this procedure entails unreasonable costs. In this section, we present an algorithm to minimise these costs. We begin by identifying the subsets of a program, called modules, relevant to another program.\nDEFINITION 8.1 (MODULE). Let P \u2208 LPA and a \u2208 A. For any rule r \u2208 P with a \u2208 At(r), we recursively construct M(P )ri |a as\n{r} \u222a { r\u2032 \u2208 P | At(r\u2032) \u2229 ( At(r) \u222aAt(M(P )ri\u22121|a) ) \\ {a} 6= \u2205 }\nfor i > 0 and M(P )r0|a = \u2205. Since P is finite and M(P )ri |a is monotonic with respect to i, the sequence \u22c3\u221e i=0 M(P ) r i |a will reach a fixpoint. We denote the fixpoint by M(P )\nr|a and call it the module of P related to r including a (or the r-module including a, if P is clear from the context).\nEXAMPLE 8.1. Let r1: a., r2: b \u2190 a., r3: c \u2190 not b., and P = {r1, r2, r3}. The modules that can be constructed from P are: M(P )r1 |a = {r1},M(P )r2 |a = {r2, r3},M(P )r2|b = {r1, r2},M(P )r3|b = {r3}, and M(P )r3 |c = {r1, r2, r3}.\nStarting with a given atom a and a given rule r from P , the recursive definition first finds all rules in P that share atoms with r except for a. Then it finds all rules in P that share atoms with r or any of the rules found in the first step except for a, and so on. It does not matter whether atoms appear in the head or the body of a rule, or whether they occur with or without default negation. The resulting module is the collection of rules in P that are related to r through shared atoms. The reason for excluding a will become clear after the following definition of a set of relevant modules.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nDEFINITION 8.2 (RELEVANT MODULE). Let P \u2208 LPA. Given an atom a \u2208 A, we define the set of all modules of P including a as:\nM(P )|a = {M(P ) r|a | r \u2208 P and a \u2208 At(r) }.\nGiven Q \u2208 LPA, we define the set of all modules of P relevant to Q as:\nM(P )|Q = {M(P ) r|a | r \u2208 P and a \u2208 At(r) \u2229 At(Q) }.\nEssentially, the definition of a set of modules extracts those rules from a program that may be affected during a revision or contraction by another program. It thus aims for the same goal as the language-splitting technique in propositional logic [Parikh 1999], which splits a knowledge base into several partitions either relevant or irrelevant to a belief change. However, a distinct feature in the previous definitions is the construction of a module based on each rule in which a certain atom occurs. This feature allows us to get a closer look at which rules may conflict with some given information. Consider the program { a \u2190 b., \u22a5 \u2190 b. }. If we were to add the information that \u201cb holds\u201d to this program, it would conflict with the latter rule but not with the first one. By creating a module for each occurrence of b, we split the program into two modules (one for each rule) and can assess the compatibility of each module with the new information separately. This also separates our approach from the method to compute compartments [Hansson and Wassermann 2002; Wassermann 2000]. That method assumes a graph representation of a belief base, where each sentence of the belief base is a node and edges connect sentences that share at least one atom. The parts of a belief base relevant to a given sentence \u03c6 for a change operation are the sentences that can be reached from \u03c6. Thus, it does not distinguish between occurrences of \u03c6 as in our method. Furthermore, our method constructs modules for each individual atom occurring in Q and thus ensures that we are dealing with minimal units of P in a change operation. Obviously, a module may not be unique to a certain rule or a certain given atom so that modules may overlap or coincide. We say that a set of rules R conflicts with some program Q if SE(R)\u2229SE(Q) = \u2205. All rules of P that conflict with Q are included in some module or combination of modules from M(P )|Q.\nPROPOSITION 8.1. Let P,Q \u2208 LPA and SE(P ) 6= \u2205 6= SE(Q). For any R \u2286 P , if SE(R) \u2229 SE(Q) = \u2205 and for all R\u2032 \u2282 R it holds that SE(R\u2032) \u2229 SE(Q) 6= \u2205, then there exists M \u2208 2M(P )|Q such that R \u2286 \u22c3 M.\nCOROLLARY 8.1. Let P,Q \u2208 LPA and SE(P ) 6= \u2205. Then SE(P ) \u2229 SE(Q) = \u2205 if and only if SE ( \u22c3\nM(P )|Q) \u2229 SE(Q) = \u2205.\nWe are now ready to introduce an optimisation algorithm for logic program revision and contraction based on modules. Algorithm 1 resolves potential conflicts for all possible combinations of modules by applying revision or contraction on a modular level. It performs a bottom-up construction by first taking all 1-combinations (singleton sets of modules) of M and substituting a module with its changed version if they are not the same. It then takes all 2-combinations of M, which may now contain some changed modules, and replaces each module of the combination with the changed version of the combination if required. Replacing each module of a combination with the outcome guarantees that the algorithm considers all possible combinations. The algorithm terminates after handling the combination of all modules in M. The algorithm performs |M||M|/2 operations in the worst case, so its complexity is exponential. Since the formation of PQ or P \u2212 Q requires |2 P ||2 P |/2 operations in the worst case, the algorithm performs better whenever |M| is less than |2P |.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nALGORITHM 1: MODCHANGE\nInput: a set M of modules, an operator \u25e6, a program Q Output: the set M of changed modules n \u2190 1; while n \u2264 |M| do\nforeach M \u2286 M such that |M| = n do if \u25e6 is a revision operator and SE( \u22c3 M) \u2229 SE(Q) = \u2205 then\nforeach M \u2208 M do replace M with ( \u22c3 M \u25e6Q) \\Q in M; end\nelse if \u25e6 is a contraction operator and SE( \u22c3\nM) \u2229 SE(Q) = \u2205 then foreach M \u2208 M do\nreplace M with \u22c3\nM \u25e6Q in M; end\nend n \u2190 n+ 1;\nend return M;\nThe next theorem states that the algorithm MODCHANGE reduces a partial meet revision or contraction operation on a logic program to the revision or contraction operation on the relevant subsets of that program, given a suitable selection function \u03b3. In the following, let P \\M(P )|Q = { r \u2208 P | for all M \u2208 M(P )|Q : r 6\u2208 M } and M(P )|\u25e6Q denote the output of Algorithm 1 for the inputs M(P )|Q, \u25e6 \u2208 {\u2217\u03b3 , .\u2212\u03b3 , \u2217 , .\u2212 }, and Q.\nTHEOREM 8.1. For any P,Q \u2208 LPA, there exists a selection function \u03b3 for P such that P \u2217\u03b3 Q = P \\M(P )|Q + \u22c3 M(P )| \u2217\u03b3 Q + Q (or P .\u2212\u03b3 Q = P \\M(P )|Q + \u22c3 M(P )| .\u2212\u03b3 Q , respectively).\nThe reason why Theorem 8.1 does not hold for any arbitrary selection function is that during the operation of MODCHANGE a selection function chooses from subsets of modules, while it chooses from subsets of a program during the operation of \u2217\u03b3 per Definition 5.4 ( .\u2212\u03b3 per Definition 5.8, respectively). Consequently, the result of the former operation may not in all cases correspond to the result of the latter operation. We have already established in Theorems 7.1 and 7.2 that \u2217\u03b3 and\n.\u2212\u03b3 can be characterised in terms of \u2217 and\n.\u2212 , respectively. Therefore, we can directly extend Theorem 8.1 to ensconcement revision and contraction.\nCOROLLARY 8.2. For any P,Q \u2208 LPA, there exists an ensconcement associated with P such that P \u2217 Q = P \\M(P )|Q + \u22c3 M(P )| \u2217 Q +Q (or P\n.\u2212 Q = P \\M(P )|Q + \u22c3\nM(P )| .\u2212 Q , respectively)."}, {"heading": "9. DISCUSSION", "text": "From our investigations in the previous sections, we can extract two main findings. Firstly, the belief change operators for logic programs that we proposed here are able to address the unintuitive behaviour of the distance-based approach. The latter takes a holistic, program-level view on logic programs and their revisions, by assuming a belief state to be the set of SE models of the entire program. Due to its focus on the program-level, the distance-based approach neglects information about relationships between atoms that is only captured on the rule-level, by the individual rules of a program, and therefore violates the properties of preservation and support.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nFor our approach, we adapted partial meet and ensconcement constructions, which allowed us to define operators that are more sensitive with respect to the information expressed by the individual rules of a program. In particular, we considered the rules of a program in their syntactic form as a belief state and thus as the objects of change, which made it possible to preserve necessary information on the syntactic level during a change operation. This characteristic turned out to be key for satisfying the preservation and support properties. It should be noted, however, that our operators are still model-based and not purely syntactic operators. Our operators rely on satisfaction defined under SE model semantics to determine compatible sets, remainder sets, ensconcements, and cuts, not on syntactic transformations of program components. Rather, our operators bridge the gap between purely semantic and purely syntactic methods, which is why we call them syntax-preserving. Secondly, we found that our operators fit properly into the belief base framework for belief change. Tables I, II, III, and IV provide an overview of the postulates that are satisfied by each operator. Our partial meet revision operator \u2217\u03b3 satisfies all basic AGM revision postulates (\u22171)\u2013(\u22176). However, the partial meet revision operator does not satisfy the supplementary postulates (\u22177)\u2013(\u22178), even with further restrictions on the selection function, which allow operators under propositional logic to satisfy the supplementary postulates. A similar situation exists for our partial meet contraction operator .\u2212\u03b3 . The partial meet contraction operator satisfies all basic postulates (\n.\u22121)\u2013 ( .\u22126) with the exception of the controversial Recovery postulate ( .\u22125). It satisfies ( .\u22127) but not ( .\u22128) of the supplementary postulates when the selection function is restricted to be determined by a maximised transitive relation. On the other hand, evaluating our partial meet revision and contraction operators with respect to the belief base postulates showed that they exhibit the same characteristics as the partial meet base revision and contraction operators for propositional logic [Hansson 1993]. The partial meet revision operator is represented by (\u22171b)\u2013(\u22175b) (Theorem 5.2) and the partial meet contraction operator by ( .\u22121b)\u2013( .\u22124b) (Theorem 5.5), and thus both operators fit neatly into the belief base framework.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nOur ensconcement revision operator .\u2212 satisfies the same basic AGM postulates (\u22171)\u2013(\u22176) as our partial meet revision operator and in addition (\u22178), but also disrespects (\u22177). Our ensconcement contraction operator .\u2212 satisfies all AGM postulates ( .\u22121)\u2013( .\u22128) with the exception of ( .\u22125). Since an ensconcement-based construction is essentially geared towards belief bases [Williams 1994], our ensconcement operators should align well with the belief base framework. Indeed, our ensconcement contraction operator .\u2212 satisfies the same set of belief base postulates as its counterpart for propositional logic [Ferme\u0301 et al. 2008], that is, ( .\u22121b), ( .\u22122b), and ( .\u22125b)\u2013( .\u22128b). As the classic belief base revision postulates (>1)\u2013(>5) have originally been proposed to characterise partial meet base revision operations, their applicability to characterise ensconcement revision operations is limited. It would be interesting for future work to define a set of belief base revision postulates that can exactly characterise ensconcement revision operations. Until then, we can use our adaptation of the Harper identity to show that any ensconcement contraction operator determined by our ensconcement revision operator \u2217 satisfies (\n.\u22121b), ( .\u22122b), and ( .\u22125b)\u2013( .\u22128b). It is now left to examine how our operators compare to the distance-based operator in terms of the AGM and belief base postulates. Tables V and VI display the postulates satisfied by the distance-based operator \u22c6. We can see that both our partial meet revision operator \u2217\u03b3 and our ensconcement revision operator \u2217 are better-behaved than \u22c6 on the scale of AGM postulates as well as on the scale of belief base postulates. It should be noted, however, that \u22c6 satisfies (\u22174m), which has a stricter antecedent than (\u22176), but neither \u2217\u03b3 nor \u2217 satisfies (\u22174m)."}, {"heading": "10. CONCLUSION", "text": "In this work, we presented two new constructions of belief change in logic programs. Our specific aim was to overcome the drawbacks of existing semantic revision operators, namely, that they do not satisfy the properties of preservation and support. These are fundamental properties for a logic program belief change operator to return intuitive results. For this purpose, we chose to adapt partial meet and ensconcement constructions from classic belief change, which allowed us to define syntax-preserving belief change operators for logic programs that satisfy preservation and support. Our approach is novel in that the partial meet and ensconcement constructions not only enabled our operators to preserve more information from a logic program during a change operation than purely semantic operators, but they also facilitated natural definitions of contraction operators for logic programs, the first in the field to the best of our knowledge. In order to evaluate the rationality of our operators, we translated the revision and contraction postulates from the classic AGM and belief base frameworks to logic programs. We established that our operators fit properly within the belief base framework and showed their interdefinability. We also demonstrated that our operators align more closely to the AGM and belief base frameworks than the distance-based revision operators and that they generalise the screened semi-revision operator. We further presented an algorithm to optimise our revision and contraction operations.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nIn future work, we aim to develop and implement an algorithm for constructing the relevant modules of a program. While our partial meet and ensconcement operators specify how a program changes during a revision or contraction operation, they do not specify how the associated selection function or ensconcement relation changes. A selection function or ensconcement is associated with a program before the change operation. During the change operation, some rules may be discarded from the program and some new rules may be added to it in the case of revision, and any effects on the initial selection function or ensconcement or entrenchment should be taken into consideration. Such an extension to our approach would be worthwhile to pursue in the future."}, {"heading": "APPENDIX: PROOFS", "text": "PROPOSITION 4.1: Let .\u2212 be a contraction operator on LPA. If .\u2212 satisfies ( .\u22123b), then it satisfies ( .\u22128b).\nPROOF. Proof by contrapositive: Let r \u2208 P \\ (P .\u2212Q). Assume SE(P .\u2212Q) \u2286 SE(Q)\u222a SE(r). Then for all P \u2032 such that P .\u2212 Q \u2286 P \u2032 \u2286 P with SE(P \u2032) * SE(Q): SE(P \u2032) \u2229 SE(r) * SE(Q), due to the assumption and due to SE(P \u2032) \u2286 SE(P .\u2212Q).\nTHEOREM 5.1: The revision operator \u2217\u03b3 satisfies (\u22171)\u2013(\u22176).\nPROOF. (\u22171): Follows directly from Definition 5.4. (\u22172): Follows directly from Definition 5.4. (\u22173): If Q is not satisfiable, then P \u2217\u03b3 Q = P +Q. Otherwise, since \u22c2\n\u03b3(PQ) \u2286 P we have \u22c2\n\u03b3(PQ) +Q \u2286 P +Q. (\u22174): If P + Q is satisfiable, then PQ = {P} = \u03b3(PQ), for any selection function \u03b3, and thus P \u2217\u03b3 Q = P +Q. (\u22175): If Q is not satisfiable, then P \u2217\u03b3 Q = P + Q is not satisfiable. If Q is satisfiable, then for any R \u2208 PQ, R+Q is satisfiable, which implies P \u2217\u03b3 Q is satisfiable. (\u22176): Follows directly from Definition 5.4.\nLEMMA A.1. Let P,Q \u2208 LPA and \u03b3 be a selection function for P . If r \u2208 P \u2229Q, then r \u2208 \u22c2\n\u03b3(PQ).\nPROOF. Let P,Q \u2208 LPA. Assume there exists r \u2208 (P \u2229 Q) \\ ( \u22c2\n\u03b3(PQ)). Then there existsR \u2208 \u03b3(PQ) : r 6\u2208 R. It follows that SE(R\u222a{r})\u2229SE(Q) 6= \u2205 since SE(R)\u2229SE(Q) 6= \u2205 by Definition 5.1 and r \u2208 Q implies SE(Q) \u2286 SE(r). This is a contradiction because R is maximal by Definition 5.1.\nTHEOREM 5.2: An operator \u2217\u03b3 is a partial meet revision operator for P \u2208 LPA determined by a selection function \u03b3 for P iff \u2217\u03b3 satisfies (\u22171b)\u2013(\u22175b).\nPROOF. We first show that a partial meet revision operator \u2217\u03b3 for P determined by a given selection function \u03b3 for P satisfies (\u22171b)\u2013(\u22175b). (\u22171b): Since (\u22171b) = (\u22172) and \u2217\u03b3 satisfies (\u22172), \u2217\u03b3 also satisfies (\u22171b). (\u22172b): Since (\u22172b) = (\u22173) and \u2217\u03b3 satisfies (\u22173), \u2217\u03b3 also satisfies (\u22172b). (\u22173b): Let r \u2208 P . Assume that for all P \u2032 with P \u2217\u03b3 Q \u2286 P \u2032 \u2282 P + Q and P \u2032 being satisfiable, it holds that P \u2032 \u222a {r} is satisfiable. In particular, for each R \u2208 PQ with P \u2217\u03b3 Q \u2286 R \u222a Q, this implies R \u222a Q \u222a {r} is satisfiable. As each R is subset-maximal, it follows that r \u2208 R and thus r \u2208 \u22c2\n\u03b3(PQ). From Definition 5.4 we can then conclude r 6\u2208 P \\ (P \u2217\u03b3 Q). (\u22174b): For all P \u2032 \u2286 P , let P \u2032 + Q be satisfiable iff P \u2032 + R is satisfiable. Then PQ = PR by Definition 5.1 and so \u22c2 \u03b3(PQ) = \u22c2 \u03b3(PR) as well as P \u2229 \u22c2 \u03b3(PQ) = P \u2229 \u22c2\n\u03b3(PR). By Lemma A.1 we obtain (P \u2229 \u22c2 \u03b3(PQ)) \u222a (P \u2229 Q) = (P \u2229 \u22c2 \u03b3(PR)) \u222a (P \u2229 R). This means\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nP \u2229 ( \u22c2 \u03b3(PQ) \u222aQ) = P \u2229 ( \u22c2\n\u03b3(PR) \u222aR). Thus, P \u2229 (P \u2217\u03b3 Q) = P \u2229 (P \u2217\u03b3 R). (\u22175b): If Q is satisfiable, then for any R \u2208 PQ, R+Q is satisfiable, which implies P \u2217\u03b3 Q is satisfiable. We now show that any operator \u25e6\u03b3 for P satisfying (\u22171b)\u2013(\u22175b) is a partial meet revision operator for P determined by some selection function for P . We first find a selection function \u03b3 for P . Let \u03b3 be such that (i) if PQ = \u2205, then \u03b3(PQ) = \u2205 and (ii) \u03b3(PQ) = {R \u2208 PQ | P \u2229 (P \u25e6\u03b3 Q) \u2286 R } otherwise. We begin by showing that \u03b3 is a function. If PQ = PR, then P \u2229(P \u25e6\u03b3Q) = P \u2229(P \u25e6\u03b3R) by (\u22174b). This means \u03b3(PQ) = \u03b3(PR) according to our definition of \u03b3. We next show that \u03b3 is a selection function. Clearly, \u03b3(PQ) \u2286 PQ by our definition of \u03b3. If PQ 6= \u2205, thenQ is satisfiable by Definition 5.1 and thus P \u25e6\u03b3Q is satisfiable by (\u22175b). Since Q \u2286 P \u25e6\u03b3 Q by (\u22171b) and P \u25e6\u03b3 Q \u2286 P \u222aQ by (\u22172b), it follows that (P \u2229 (P \u25e6\u03b3 Q))\u222aQ is satisfiable. This means that there exists R \u2208 PQ such that P \u2229 (P \u25e6\u03b3 Q) \u2286 R. From our definition of \u03b3 we therefore obtain that \u03b3(PQ) 6= \u2205. Finally, we show that \u25e6\u03b3 is a partial meet revision operator for P , that is, P \u25e6\u03b3 Q = P \u222a Q if Q is not satisfiable and P \u25e6\u03b3 Q = \u22c2\n\u03b3(PQ) \u222a Q otherwise. Consider first the limiting case that Q is not satisfiable. If r \u2208 P \\ (P \u25e6\u03b3 Q), then there exists P \u2032 such that P \u25e6\u03b3 Q \u2286 P \u2032 \u2282 P \u222aQ and P \u2032 is satisfiable but P \u2032 \u222a {r} is not satisfiable by (\u22173b). This is a contradiction since Q \u2286 P \u2032 by (\u22171b). Therefore, it holds for all r \u2208 P that r \u2208 P \u25e6\u03b3 Q, that is, P \u2286 P \u25e6\u03b3 Q. Since Q \u2286 P \u25e6\u03b3 Q by (\u22171b) and P \u25e6\u03b3 Q \u2286 P \u222a Q by (\u22172b), we can conclude P \u25e6\u03b3 Q = P \u222aQ. Assume now that Q is satisfiable. Let r \u2208 P \\ (P \u25e6\u03b3 Q). If PQ = \u2205, then it follows from (\u22171b) and (\u22173b) that P \u25e6\u03b3 Q = Q. Since \u03b3(PQ) = \u2205 by our definition of \u03b3, we thus have P \u25e6\u03b3 Q = Q = \u22c2\n\u03b3(PQ) \u222a Q. If PQ 6= \u2205, then it follows directly from our definition of \u03b3 that P \u2229 (P \u25e6\u03b3Q) \u2286 \u22c2 \u03b3(PQ). From (\u22171b) and (\u22172b) we then obtain P \u25e6\u03b3Q \u2286 \u22c2\n\u03b3(PQ)\u222aQ. To show the converse inclusion, first assume the case that P \u222a Q is satisfiable. This implies that for any P \u2032 \u2286 P \u222aQ it holds that P \u2032 is satisfiable. Applying (\u22173b), we obtain P \\(P \u25e6\u03b3Q) = \u2205 and thus P \u2286 P \u25e6\u03b3Q. From (\u22171b) and (\u22172b) it follows that P \u25e6\u03b3Q = P \u222aQ. Moreover, due to the assumption that P \u222a Q is satisfiable and Definition 5.1, we have PQ = {P}. By our definition of \u03b3, we obtain \u03b3(PQ) = {P} and thus \u22c2\n\u03b3(PQ) = P and can conclude P \u25e6\u03b3Q = \u22c2\n\u03b3(PQ)\u222aQ. Lastly, assume the case that P \u222aQ is not satisfiable. We will show that r 6\u2208 P \u25e6\u03b3 Q implies r 6\u2208 \u22c2\n\u03b3(PQ) \u222a Q. If r 6\u2208 P , then r 6\u2208 (P \u25e6\u03b3 Q) \\ Q by (\u22171b) and (\u22172b) and r 6\u2208 \u22c2\n\u03b3(PQ) by Definition 5.1. Since r 6\u2208 P \u25e6\u03b3 Q implies r 6\u2208 Q by (\u22171b), it follows that r 6\u2208 ((P \u25e6\u03b3 Q) \\Q)\u222aQ) = P \u25e6\u03b3 Q and r \u2208 \u22c2\n\u03b3(PQ)\u222aQ. Now assume r \u2208 P \\ (P \u25e6\u03b3 Q). According to (\u22173b), then there exists P \u2032 such that P \u25e6\u03b3 Q \u2286 P \u2032 \u2282 P \u222aQ and P \u2032 is satisfiable but P \u2032\u222a{r} is not satisfiable. This means that there exists R \u2208 PQ such that P \u2229 P \u2032 \u2286 R and r 6\u2208 R. Since P \u2229 (P \u25e6\u03b3 Q) \u2286 P \u2229 P \u2032 \u2286 R, we obtain from our definition of \u03b3 that R \u2208 \u03b3(PQ). We can thus conclude from r 6\u2208 R that r 6\u2208 \u22c2 \u03b3(PQ).\nPROPOSITION 5.1: Let P,Q \u2208 LPA. For any maxichoice selection function \u03b3P for P , there exists a selection function \u03b3 for P such that (P \u222aQ)!SE\u03b3P Q = P \u2217\u03b3 Q.\nPROOF. Let P,Q \u2208 LPA and \u03b3P be a maxichoice selection function for P . We will prove by cases. Case 1: Q is not satisfiable. This means (P \u222a Q)\u22a5SE! Q = \u2205 by definition of P\u22a5 SE ! Q. Then \u03b3P ((P \u222a Q)\u22a5SE! Q) = P \u222a Q by definition of \u03b3P . It follows that (P \u222a Q)! SE \u03b3P Q = P \u222aQ = P \u2217\u03b3 Q by definition of !SE\u03b3P and Definition 5.4.\nCase 2: Q is satisfiable and for all R \u2286 P : SE(R \u222a Q) = \u2205. Then (P \u222a Q)\u22a5SE! Q = {Q} by definition of \u22a5SE! and PQ = \u2205 = \u22c2\n\u03b3(PQ) by Definition 5.1. It follows that (P \u222aQ)!SE\u03b3P Q = \u03b3P ((P \u222aQ)\u22a5 SE ! Q) = Q = P \u2217\u03b3 Q by definition of ! SE \u03b3P and Definition 5.4.\nCase 3: Q is satisfiable and there exists R \u2286 P : SE(R \u222a Q) 6= \u2205 such that for all R\u2032 with R \u2282 R\u2032 \u2286 P : SE(R\u2032) = \u2205. Then R \u222a Q \u2208 (P \u222a Q)\u22a5SE! Q by definition of \u22a5 SE !\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nand R \u2208 PQ by Definition 5.1. Let \u03b3 be a maxichoice selection function for P such that \u03b3(2P ) \u222a Q = \u03b3P ({R \u222a Q | R \u2208 2P }). This implies \u03b3P ((P \u222a Q)\u22a5SE! Q) = \u03b3(PQ) \u222a Q = \u22c2\n\u03b3(PQ) \u222aQ. Thus, (P \u222aQ)!SE\u03b3P Q = P \u2217\u03b3 Q by definition of ! SE \u03b3P and Definition 5.4.\nPROPOSITION 5.2: Let P,Q \u2208 LPA and \u03b3 1, \u03b3P be single-choice and maxichoice selection functions, respectively, for P . If \u03b31(2P ) \u222aQ = \u03b3P ({R \u222aQ | R \u2208 2P }) for any \u03b3P , then P \u2217AS\u03b31 Q = (P \u222aQ)!\u03b3P Q.\nPROOF. Let P,Q \u2208 LPA and \u03b3 1, \u03b3P be single-choice and maxichoice selection functions, respectively, for P . Assume that \u03b31(2P ) \u222a Q = \u03b3P ({R \u222a Q | R \u2208 2P }) for any \u03b3P . We will prove by cases. Case 1: AS(Q) = \u2205 and for all R \u2286 P : AS(R \u222a Q) = \u2205. This implies PASQ = \u2205 by definition of PASQ and thus P \u2217\u03b3Q = P \u222aQ by Definition 5.6. It also implies (P \u222aQ)\u22a5!Q = \u2205 by definition of P\u22a5!Q and therefore \u03b3P ((P \u222a Q)\u22a5!Q) = P \u222aQ by definition of \u03b3P . We can conclude (P \u222aQ)!\u03b3P Q = P \u222aQ by Definition 3.2. Case 2: AS(Q) 6= \u2205 and for all R \u2286 P : AS(R \u222a Q) = \u2205. Then PASQ = \u2205 = \u03b3\n1(PASQ ) by definitions of PASQ and \u03b3 1. We also have (P \u222a Q)\u22a5!Q = {Q} = \u03b3P ((P \u222a Q)\u22a5!Q) by definitions of \u22a5! and \u03b3P . It follows that P \u2217AS\u03b31 Q = Q = (P \u222a Q)!\u03b3PQ by Definitions 5.6 and 3.2. Case 3: There exists R \u2286 P : AS(R \u222a Q) 6= \u2205 and for all R\u2032 with R \u2282 R\u2032 \u2286 P : AS(R\u2032 \u222a Q) = \u2205. Then R \u2208 PASQ by definition of P AS Q and R \u222a Q \u2208 (P \u222a Q)\u22a5!Q by definition of \u22a5!. Due to the assumption, it holds that \u03b31(PASQ ) \u222a Q = \u03b3P ((P \u222a Q)\u22a5!Q). Thus, P \u2217AS\u03b31 Q = (P \u222aQ)!\u03b3P Q by Definitions 5.6 and 3.2.\nTHEOREM 5.3: The contraction operator .\u2212\u03b3 satisfies ( .\u22121)\u2013( .\u22124) and ( .\u22126).\nPROOF. ( .\u22121): Follows directly from Definition 5.8. ( .\u22122): Follows directly from Definition 5.8. ( .\u22123): If P 6|=s Q, then P \u2212 Q = {P} = \u03b3(P \u2212 Q), for any selection function \u03b3, and thus P\n.\u2212\u03b3Q = P . ( .\u22124): Let 6|=s Q. For any R \u2208 P \u2212 Q, R 6|=s Q, which implies P\n.\u2212\u03b3 Q 6|=s Q. ( .\u22126): Follows directly from Definition 5.8.\nLEMMA A.2. Let P \u2208 LPA. For any Q,R \u2208 LPA, it holds that P \u2212 Q+R \u2286 P \u2212 Q \u222a P \u2212 R.\nPROOF. Let P,Q,R \u2208 LPA. It follows from SE(Q+R) = SE(Q) \u222a SE(R) and the definition of P\u2212Q+R that P \u2212 Q+R = {S \u2208 P \u2212 Q \u222a P \u2212 R | S 6\u2282 S \u2032 for any S\u2032 \u2208 P\u2212Q \u222a P \u2212 R }. Thus, P\u2212Q+R \u2286 P \u2212 Q \u222a P \u2212 R.\nLEMMA A.3. Let P \u2208 LPA and \u03b3 \u2032 be determined by a maximised transitive relation.\nFor any Q,R \u2208 LPA, it holds that \u03b3\u2032(P \u2212 Q+R) \u2286 \u03b3 \u2032(P\u2212Q) \u222a \u03b3 \u2032(P\u2212R).\nPROOF. Let P,Q,R \u2208 LPA. Assume there exists S \u2208 \u03b3\u2032(P \u2212 Q+R) : S 6\u2208 \u03b3 \u2032(P\u2212Q) \u222a \u03b3 \u2032(P\u2212R).\nThen S 6\u2208 \u03b3\u2032(P\u2212Q) and S 6\u2208 \u03b3 \u2032(P\u2212R). Case 1: If S 6\u2208 P \u2212 Q, this means that S \u2208 P \u2212 R by Lemma A.2. From Definition 5.5 it follows that there exists S\u2032 \u2208 P\u2212R : S \u2282 S \u2032, a contradiction since S \u2208 P\u2212Q+R. Case 2: S \u2208 P \u2212 Q. Follows analogously as Case 1.\nTHEOREM 5.4: Let \u03b3\u2032 be determined by a maximised transitive relation. The contraction operator .\u2212\u03b3\u2032 satisfies ( .\u22127).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPROOF. Let P,Q,R \u2208 LPA and r \u2208 (P .\u2212\u03b3\u2032Q)\u2229(P .\u2212\u03b3\u2032R). This means that r \u2208 \u22c2 \u03b3\u2032(P\u2212Q)\nand r \u2208 \u22c2 \u03b3\u2032(P\u2212R). By Lemma A.3, we have for all S \u2208 \u03b3 \u2032(P\u2212Q+R) : r \u2208 S, so that r \u2208 \u22c2\n\u03b3\u2032(P\u2212Q+R). Thus, (P .\u2212\u03b3\u2032 Q) \u2229 (P .\u2212\u03b3\u2032 R) \u2286 P .\u2212\u03b3\u2032 (Q+R).\nTHEOREM 5.5: An operator .\u2212\u03b3 is a partial meet contraction operator for P \u2208 LPA determined by a selection function \u03b3 for P iff .\u2212\u03b3 satisfies ( .\u22121b)\u2013( .\u22124b).\nPROOF. We first show that a partial meet contraction operator .\u2212\u03b3 for P determined by a given selection function \u03b3 for P satisfies ( .\u22121b)\u2013( .\u22124b). ( .\u22121b): Follows from ( .\u22121b) = ( .\u22122) and satisfaction of ( .\u22122). ( .\u22122b): Follows from ( .\u22122b) = ( .\u22124) and satisfaction of ( .\u22124). ( .\u22123b): Let r \u2208 P . Assume that for all P \u2032 with P .\u2212\u03b3 Q \u2286 P \u2032 \u2282 P and P \u2032 6|=s Q, it holds that P \u2032 \u222a {r} 6|=s Q. In particular, for each R \u2208 P \u2212 Q with P\n.\u2212\u03b3 Q \u2286 R, this implies R \u222a {r} 6|=s Q. As each R is subset-maximal by Definition 5.7, it follows that r \u2208 R and thus r \u2208 P .\u2212\u03b3 Q. ( .\u22124b): For all P \u2032 \u2286 P , let P \u2032 6|=s Q iff P \u2032 6|=s R. Then P \u2212 Q = P \u2212 R by Definition 5.7 and so \u03b3(P\u2212Q) = \u03b3(P \u2212 R) as well as \u22c2 \u03b3(P\u2212Q) = \u22c2 \u03b3(P\u2212R). Thus, P .\u2212\u03b3 Q = P\n.\u2212\u03b3 R by Definition 5.8. We now show that any operator \u25e6\u03b3 for P satisfying (\n.\u22121b)\u2013( .\u22124b) is a partial meet contraction operator for P determined by some selection function for P . We first find a selection function \u03b3 for P. Let \u03b3 be such that (i) if P\u2212Q = \u2205, then \u03b3(P \u2212 Q) = \u2205 and (ii) \u03b3(P\u2212Q) = {R \u2208 P \u2212 Q | P \u25e6\u03b3 Q \u2286 R } otherwise.\nWe begin by showing that \u03b3 is a function. If P\u2212Q = P \u2212 R, then P \u25e6\u03b3 Q = P \u25e6\u03b3 R by ( .\u22124b).\nThis means \u03b3(P\u2212Q) = \u03b3(P \u2212 R) according to our definition of \u03b3.\nWe next show that \u03b3 is a selection function. Clearly, \u03b3(P\u2212Q) \u2286 P \u2212 Q by our definition of \u03b3. If P\u2212Q 6= \u2205, then 6|=s Q by Definition 5.7 and thus P \u25e6\u03b3 Q 6|=s Q by ( .\u22122b). It follows from P \u25e6\u03b3 Q \u2286 P due to ( .\u22121b) that there exists R \u2208 P\u2212Q such that P \u25e6\u03b3 Q \u2286 R. From our definition of \u03b3 we therefore obtain that \u03b3(P\u2212Q) 6= \u2205. Finally, we show that \u25e6\u03b3 is a partial meet contraction operator for P , that is, P \u25e6\u03b3Q = P if |=s Q and P \u25e6\u03b3 Q = \u22c2\n\u03b3(P\u2212Q) otherwise. Consider first the limiting case that |=s Q. If r \u2208 P \\ (P \u25e6\u03b3 Q), then there exists P \u2032 such that P \u25e6\u03b3 Q \u2286 P \u2032 \u2282 P and P \u2032 6|=s Q but P \u2032 \u222a {r} |=s Q by (\n.\u22123b). This is a contradiction since |=s Q. Therefore, it holds for all r \u2208 P that r \u2208 P \u25e6\u03b3 Q, that is, P \u2286 P \u25e6\u03b3 Q. Since P \u25e6\u03b3 Q \u2286 P by (\n.\u22121b), we can conclude P \u25e6\u03b3 Q = P . Assume now that 6|=s Q. Let r \u2208 P \\ (P \u25e6\u03b3 Q). If P \u2212 Q = \u2205, then it follows from ( .\u22122b) and ( .\u22123b) that P \u25e6\u03b3 Q = \u2205. Since \u03b3(P \u2212 Q) = \u2205 by our definition of \u03b3, we thus have P \u25e6\u03b3 Q = \u22c2 \u03b3(P\u2212Q). If P \u2212 Q 6= \u2205, then it follows directly from our definition of \u03b3 that P \u25e6\u03b3 Q \u2286 \u22c2\n\u03b3(P\u2212Q). To show the converse inclusion, first assume the case that P 6|=s Q. This implies that for any P \u2032 \u2286 P it holds that P \u2032 6|=s Q. Applying (\n.\u22123b), we obtain"}, {"heading": "P \\ (P \u25e6\u03b3 Q) = \u2205 and thus P \u2286 P \u25e6\u03b3 Q. From (", "text": ".\u22121b) it follows that P \u25e6\u03b3 Q = P . Moreover, due to the assumption that P 6|=s Q and Definition 5.7, we have P \u2212 Q = {P}. By our definition of \u03b3, we obtain \u03b3(P\u2212Q) = {P} and thus \u22c2\n\u03b3(P\u2212Q) = P and can conclude P \u25e6\u03b3Q = \u22c2\n\u03b3(P\u2212Q). Lastly, assume the case that P |=s Q. We will show that r 6\u2208 P \u25e6\u03b3 Q implies\nr 6\u2208 \u22c2 \u03b3(P\u2212Q). If r 6\u2208 P , then r 6\u2208 P \u25e6\u03b3 Q by ( .\u22121b) and r 6\u2208 \u22c2 \u03b3(P\u2212Q) by Definition 5.7. Now assume r \u2208 P \\ (P \u25e6\u03b3 Q). According to (\n.\u22123b), then there exists P \u2032 such that P \u25e6\u03b3 Q \u2286 P \u2032 \u2282 P and P \u2032 6|=s Q but P \u2032 \u222a {r} |=s Q. This means that there exists R \u2208 P \u2212 Q\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nsuch that P \u2032 \u2286 R and r 6\u2208 R. Since P \u25e6\u03b3 Q \u2286 P \u2032 \u2286 R, we obtain from our definition of \u03b3 that R \u2208 \u03b3(P\u2212Q). We can thus conclude from r 6\u2208 R that r 6\u2208 \u22c2 \u03b3(P\u2212Q).\nPROPOSITION 5.3: The contraction operator .\u2212\u03b3 satisfies ( .\u22125b), ( .\u22126b), and ( .\u22128b).\nPROOF. ( .\u22125b): Since ( .\u22125b) = ( .\u22123) and .\u2212\u03b3 satisfies ( .\u22123), .\u2212\u03b3 also satisfies ( .\u22125b). ( .\u22126b): Since ( .\u22126b) = ( .\u22126) and .\u2212\u03b3 satisfies ( .\u22126), .\u2212\u03b3 also satisfies (\n.\u22126b). ( .\u22128b): Follows from satisfaction of ( .\u22123b) and Proposition 4.1.\nLEMMA 6.1: Let P,Q,R \u2208 LPA and be an ensconcement associated with P .\na) If P +Q is satisfiable, then cut (Q) = P . b) If Q is satisfiable, then cut (Q) +Q is satisfiable. c) If Q is not satisfiable, then cut (Q) = \u2205. d) If Q |=s R, then cut (Q) \u2286 cut (R). e) cut (Q+R) \u2286 cut (Q). f) If cut (Q) |=s R, then cut (Q +R) = cut (Q).\nPROOF. a) \u2013 d) Follow directly from Definition 6.2. e) Follows directly from d). f) Let cut (Q) |=s R. It follows that SE(cut (Q)) \u2229 SE(Q) \u2286 SE(R), which implies SE(cut (Q)) \u2229 SE(Q) \u2229 SE(R) 6= \u2205 since SE(cut (Q)) \u2229 SE(Q) 6= \u2205 by Definition 6.2. We can rewrite this as SE(cut (Q)) \u2229 SE(Q+R) 6= \u2205. Thus, cut (Q) \u2286 cut (Q+R) by Definition 6.2. By Lemma 6.1 e), we obtain cut (Q) = cut (Q+R).\nPROPOSITION 6.1: Let P,Q \u2208 LPA and be an ensconcement associated with P . Then SE(P \u2217 Q) = SE(cut (Q) +Q).\nPROOF. Let P,Q \u2208 LPA and be an ensconcement associated with P . If Q is not satisfiable, then by Definition 6.3 we have SE(P \u2217 Q) = SE(P + Q) = \u2205 and by Lemma 6.1 c) we also have SE(cut (Q)+Q) = SE(Q) = \u2205. Otherwise, by Definition 6.3, P \u2217 Q = cut (Q)\u222a(P \u2217 Q)\\(cut (Q)+Q)\u222aQ, which means SE(P \u2217 Q) = SE(cut (Q))\u2229 SE((P \u2217 Q) \\ (cut (Q) + Q)) \u2229 SE(Q). Since for any r \u2208 (P \u2217 Q) \\ (cut (Q) + Q) : SE(cut (Q)) \u2229 SE(Q) \u2286 SE(r), we obtain SE(P \u2217 Q) = SE(cut (Q)) \u2229 SE(Q).\nTHEOREM 6.1: The revision operator \u2217 satisfies (\u22171)\u2013(\u22176) and (\u22178).\nPROOF. (\u22171): Follows directly from Definition 6.3. (\u22172): Follows directly from Definition 6.3. (\u22173): If Q is not satisfiable, then P \u2217 Q = P +Q by Definition 6.3. Otherwise, for any r \u2208 P \u2217 Q it holds that r \u2208 P \u222aQ, which implies P \u2217 Q \u2286 P +Q. (\u22174): If P +Q is satisfiable, then cut (Q) = P by Lemma 6.1 a). Since SE(P ) \u2286 SE(r) for all r \u2208 P , it follows from Definition 6.3 that P \u2217 Q = P +Q. (\u22175): If Q is not satisfiable, then P \u2217 Q = P + Q is not satisfiable. Now assume Q is satisfiable. By Lemma 6.1 b) it holds that cut (Q) + Q is satisfiable. Since P \u2217 Q \u2261s cut (Q) +Q by Proposition 6.1, it follows that P \u2217 Q is satisfiable. (\u22176): Follows directly from Definition 6.3. (\u22178): Let (P \u2217 Q) + R be satisfiable. By Definition 6.3, this means SE(cut (Q)) \u2229 SE((P \u2217 Q)\\cut (Q))\u2229SE(Q)\u2229SE(R) 6= \u2205 and thus SE(cut (Q))\u2229SE(Q)\u2229SE(R) 6= \u2205. From Lemma 6.1 e) and Definition 6.2 it follows that cut (Q + R) = cut (Q). Then obviously SE(cut (Q + R)) \u2229 SE(Q) = SE(cut (Q)) \u2229 SE(Q), which implies SE(cut (Q + R)) \u2229 SE(Q) \u2229 SE(R) \u2286 SE(cut (Q)) \u2229 SE(Q). It thus also holds that\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\n{ r \u2208 P | SE(cut (Q)) \u2229 SE(Q) \u2286 SE(r) } \u2286 { r \u2208 P | SE(cut (Q + R)) \u2229 SE(Q + R) \u2286 SE(r) }, from which we can conclude that (P \u2217 Q) +R \u2286 P \u2217 (Q+R).\nTHEOREM 6.2: The revision operator \u2217 satisfies (\u22171b), (\u22172b), and (\u22175b).\nPROOF. (\u22171b): Since (\u22171b) = (\u22172) and \u2217 satisfies (\u22172), \u2217 also satisfies (\u22171b). (\u22172b): Since (\u22172b) = (\u22173) and \u2217 satisfies (\u22173), \u2217 also satisfies (\u22172b). (\u22175b): If Q is satisfiable, then by Lemma 6.1 b) it holds that cut (Q) +Q is satisfiable. Since P \u2217 Q \u2261s cut (Q)+Q by Proposition 6.1, it follows that P \u2217 Q is satisfiable.\nLEMMA 6.2: Let P,Q,R \u2208 LPA.\na) If P 6|=s Q, then cut \u2212 (Q) = P . b) If 6|=s Q, then cut \u2212 (Q) 6|=s Q. c) If |=s Q, then cut \u2212 (Q) = \u2205. d) If Q |=s R, then cut \u2212 (R) \u2286 cut \u2212 (Q). e) cut\u2212 (Q) \u2286 cut \u2212 (Q +R).\nf) If cut\u2212 (Q) |=s R, then cut \u2212 (Q+R) = cut \u2212 (Q).\ng) If cut\u2212 (Q) 6|=s R, then cut \u2212 (Q+R) = cut \u2212 (R).\nPROOF. a) \u2013 d) Follow directly from the definition of cut\u2212 (Q).\ne) Follows directly from d). f) Assume cut\u2212 (Q + R) 6= cut \u2212 (Q). Then cut \u2212 (Q) \u2282 cut \u2212 (Q + R) by Lemma 6.2 e). Let\nr \u2208 cut\u2212 (Q + R) \\ cut \u2212 (Q). This means SE({ r \u2032 \u2208 P | r r\u2032 }) \u2229 SE(Q+R) 6= \u2205 and\nSE({ r\u2032 \u2208 P | r r\u2032 }) \u2229 SE(Q) = \u2205 by Definition of cut\u2212 (Q). Thus, SE({ r \u2032 \u2208 P | r\nr\u2032 }) \u2229 SE(R) 6= \u2205. Furthermore, cut\u2212 (Q) \u2286 { r \u2032 \u2208 P | r r\u2032 } by Definition of cut\u2212 (Q).\nWe therefore obtain SE(cut\u2212 (Q)) \u2229 SE(R) 6= \u2205, which implies cut \u2212 (Q) 6|=s R. g) Assume cut\u2212 (Q +R) 6= cut \u2212 (R). Then cut \u2212 (R) \u2282 cut \u2212 (Q + R) by Lemma 6.2 e). Let\nr \u2208 cut\u2212 (Q + R) \\ cut \u2212 (R). This means SE({ r \u2032 \u2208 P | r r\u2032 }) \u2229 SE(Q+R) 6= \u2205 and\nSE({ r\u2032 \u2208 P | r r\u2032 }) \u2229 SE(R) = \u2205 by Definition of cut\u2212 (R). Thus, SE({ r \u2032 \u2208 P | r\nr\u2032 }) \u2229 SE(Q) 6= \u2205 and so { r\u2032 \u2208 P | r r\u2032 } \u2286 cut\u2212 (Q) by Definition of cut \u2212 (Q). We\ntherefore obtain SE(cut\u2212 (Q)) \u2229 SE(R) = \u2205, which implies cut \u2212 (Q) |=s R.\nPROPOSITION 6.2: Let P,Q \u2208 LPA and be an ensconcement associated with P . Then SE(P .\u2212 Q) \u2229 SE(Q) = SE(cut \u2212 (Q)) \u2229 SE(Q).\nPROOF. If |=s Q, then SE(Q) = \u2205 and SE(P .\u2212 Q)\u2229SE(Q) = SE(cut \u2212 (Q))\u2229SE(Q).\nOtherwise, by Definition 6.4, P .\u2212 Q = cut \u2212 (Q) \u222a (P .\u2212 Q) \\ cut \u2212 (Q), which means SE(P .\u2212 Q) \u2229 SE(Q) = SE(cut \u2212 (Q)) \u2229 SE((P .\u2212 Q) \\ cut \u2212 (Q)) \u2229 SE(Q). For all r \u2208 (P .\u2212 Q) \\ cut \u2212 (Q) we have SE(cut \u2212 (Q))\u2229SE(Q) \u2286 SE(r), so that we obtain SE(P .\u2212\nQ) \u2229 SE(Q) = SE(cut\u2212 (Q)) \u2229 SE(Q).\nTHEOREM 6.3: The contraction operator .\u2212 satisfies ( .\u22121)\u2013( .\u22124) and ( .\u22126)\u2013( .\u22128).\nPROOF. ( .\u22121): Follows directly from Definition 6.4. ( .\u22122): Follows directly from Definition 6.4.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\n( .\u22123): If P 6|=s Q, then cut \u2212 (Q) = P by Lemma 6.2 a). Since SE(P ) \u2286 SE(r) for all r \u2208 P , this means SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) for all r \u2208 P and by Definition 6.4 we thus have P .\u2212 Q = P . ( .\u22124): Let 6|=s Q. If P 6|=s Q, then P .\u2212 Q = P 6|=s Q by ( .\u22123). Now assume P |=s Q and let S = SE(cut\u2212 (Q)) \u2229 SE(Q). For each r \u2208 P , if r \u2208 P .\u2212 Q, then S \u2286 SE(r) by Definition 6.4, and thus S \u2286 SE(P .\u2212 Q). Since S\u2229SE(Q) = \u2205, we obtain P .\u2212 Q 6|=s Q. ( .\u22126): Follows directly from Definition 6.4. ( .\u22127): For all r \u2208 (P .\u2212 Q) \u2229 (P .\u2212 R) : SE(cut \u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) and\nSE(cut\u2212 (R)) \u2229 SE(R) \u2286 SE(r). This implies SE(cut \u2212 (Q + R)) \u2229 SE(Q) \u2286 SE(r) since\ncut\u2212 (Q) \u2286 cut \u2212 (Q + R) by Lemma 6.2 e) and SE(cut \u2212 (Q + R)) \u2229 SE(R) \u2286 SE(r) since\ncut\u2212 (R) \u2286 cut \u2212 (Q+R) by Lemma 6.2 e). From SE(Q+R) = SE(Q)\u222aSE(R) we obtain SE(cut\u2212 (Q+R)) \u2229 SE(Q+R) \u2286 SE(r) and thus r \u2208 P .\u2212 (Q +R) by Definition 6.4. ( .\u22128): Assume SE(P .\u2212 (Q + R)) * SE(Q). Then, SE(cut \u2212 (Q + R)) \u2229 SE((P .\u2212 (Q +\nR)) \\ cut\u2212 (Q + R)) * SE(Q), which means SE(cut \u2212 (Q + R)) \u2229 SE(Q) 6= \u2205 (i). Recall that cut\u2212 (Q) is maximal and cut \u2212 (Q) \u2286 cut \u2212 (Q + R) (ii) by Lemma 6.2 e). From (i)\nand (ii) it follows that cut\u2212 (Q) = cut \u2212 (Q + R). Since SE(Q) \u2286 SE(Q+R), we have\nSE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(cut \u2212 (Q+R)) \u2229 SE(Q+R), which implies P .\u2212 (Q+R) \u2286 P .\u2212 Q by Definition 6.4.\nTHEOREM 6.4: The contraction operator .\u2212 satisfies (\u22121b), (\u22122b) and (\u22125b)\u2013(\u22128b).\nPROOF. ( .\u22121b): Follows from ( .\u22121b) = ( .\u22122) and satisfaction of ( .\u22122). ( .\u22122b): Follows from ( .\u22122b) = ( .\u22124) and satisfaction of ( .\u22124). ( .\u22125b): Follows from ( .\u22125b) = ( .\u22123) and satisfaction of ( .\u22123). ( .\u22126b): Follows from ( .\u22126b) = ( .\u22126) and satisfaction of ( .\u22126). ( .\u22127b): If |=s Q+R, then P\n.\u2212 (Q+R) = P by Definition 6.4 and |=s Q and |=s R, which means P .\u2212 Q = P and P\n.\u2212 R = P by Definition 6.4. Now let 6|=s Q+ R. We proceed by cases. Case 1: cut\u2212 (Q) |=s R. Then cut \u2212 (Q + R) = cut \u2212 (Q) by Lemma 6.2 f). Let r \u2208 P .\u2212 (Q+R). This means r \u2208 P by ( .\u22122) and SE(cut\u2212 (Q+R))\u2229SE(Q+R) \u2286 SE(r) by Defi-\nnition 6.4. It follows that SE(cut\u2212 (Q +R)) \u2229 SE(Q) \u2286 SE(r). Due to the case assumption, we obtain SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) and thus r \u2208 P .\u2212 Q by Definition 6.4. Now let r \u2208 P .\u2212 Q. This means r \u2208 P by ( .\u22122) and SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r)\nby Definition 6.4. Then SE(cut\u2212 (Q + R)) \u2229 SE(Q) \u2286 SE(r) due to the case assump-\ntion. It also follows from the case assumption that SE(cut\u2212 (Q)) \u2229 SE(R) = \u2205 and\nSE(cut\u2212 (Q + R)) \u2229 SE(R) = \u2205. We thus have SE(cut \u2212 (Q + R)) \u2229 (SE(Q) \u222a SE(R)) \u2286 SE(r), that is, SE(cut\u2212 (Q+R)) \u2229 SE(Q+R) \u2286 SE(r). Therefore, r \u2208 P .\u2212 (Q+R) by\nDefinition 6.4. Case 2: cut\u2212 (R) |=s Q. Follows analogous to Case 1 so that P .\u2212 (Q +R) = P .\u2212 R.\nCase 3: cut\u2212 (Q) 6|=s R and cut \u2212 (R) 6|=s Q. Then cut \u2212 (Q + R) = cut \u2212 (Q) = cut \u2212 (R) by Lemma 6.2 g). Let r \u2208 P .\u2212 (Q + R). This means r \u2208 P by ( .\u22122) and SE(cut\u2212 (Q +\nR))\u2229 SE(Q+R) \u2286 SE(r) by Definition 6.4. We thus have SE(cut\u2212 (Q+R)) \u2229 SE(Q) \u2286\nSE(r) and SE(cut\u2212 (Q + R)) \u2229 SE(R) \u2286 SE(r). From the case assumption it follows\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nthat SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) and SE(cut \u2212 (R)) \u2229 SE(R) \u2286 SE(r). This means r \u2208 P .\u2212 Q and r \u2208 P .\u2212 R by Definition 6.4 and therefore r \u2208 (P .\u2212 Q) \u2229 (P .\u2212 R). ( .\u22128b): Assume SE(P .\u2212 Q) \u2286 SE(Q) \u222a SE(r), that is, SE(P .\u2212 Q) \u2229 SE(Q) \u2286 SE(r). By Proposition 6.2, SE(P .\u2212 Q) \u2229 SE(Q) = SE(cut \u2212 (Q)) \u2229 SE(Q), so that we obtain SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r). This implies r \u2208 P .\u2212 Q by Definition 6.4. We can conclude r \u2208 P by ( .\u22122).\nTHEOREM 7.1: Let P,Q \u2208 LPA. For any selection function \u03b3, there exists an ensconcement associated with P such that P \u2217\u03b3 Q = P \u2217 Q.\nPROOF. Let P,Q \u2208 LPA and \u03b3 be a selection function that determines the outcome of P \u2217\u03b3 Q. By S = (P \u2217\u03b3 Q) \u2229 P = \u22c2\n\u03b3(PQ) we denote the subset of P that is retained in the revision and by S\u2032 = P \\ S the subset of P that is discarded. We can then create an ensconcement associated with P that has a minimal number of levels, such that for all r \u2208 S and for all r\u2032 \u2208 S\u2032: r\u2032 \u227a r. We now show that (P \u2217 Q) \u2229 P = S. Clearly, cut (Q) = S by Definition 6.2, which implies S \u2286 (P \u2217 Q)\u2229P . Assume that there exists an r\u2032 \u2208 S\u2032 with SE(cut (Q)) \u2229 SE(Q) \u2286 SE(r\u2032). Then for each selected compatible set R \u2208 \u03b3(PQ) it would hold that r\u2032 \u2208 R because R is maximal by the definition of PQ. Yet this implies r\u2032 \u2208 S, a contradiction.\nTHEOREM 7.2: Let P,Q \u2208 LPA. For any selection function \u03b3, there exists an ensconcement associated with P such that P .\u2212\u03b3 Q = P .\u2212 Q.\nPROOF. Follows analogously to the proof of Theorem 7.1.\nLEMMA A.4. Let R be a subset-ensconcement associated with some P \u2208 LPA and R \u2286 P . For any rule r \u2208 R, it holds that R R {r}.\nPROOF. Since R |=s {r}, it follows from Conditions ( R1) and ( R2) that {r} 6\u227aR\nR.\nTHEOREM 7.3: Let P,Q \u2208 LPA, be an ensconcement associated with P , and R a subset-ensconcement associated with P such that {r} R {r\u2032} iff r r\u2032 for all r, r\u2032 \u2208 P . Then P \u2217 Q = P \u2217 R Q (or P .\u2212 Q = P .\u2212 R Q, alternatively).\nPROOF. Let P,Q \u2208 LPA, an ensconcement associated with P , and R a subsetensconcement associated with P . Assume that {r} R {r\u2032} iff r r\u2032 for all r, r\u2032 \u2208 P . From LemmaA.4 it is clear that cut (Q) = cut R(Q), which implies for all r \u2208 (P \u2217 Q)\\ Q : SE(cut R(Q))\u2229SE(Q) \u2286 SE({r}), and thus P \u2217 Q \u2286 P \u2217 RQ. Since SE(R) \u2286 SE(r) for any R \u2286 P and each r \u2208 R, we also have P \u2217 R Q \u2286 P \u2217 Q. Analogous for contraction.\nPROPOSITION 7.1: Let P \u2208 LPA, \u03b3 be a selection function for P , and \u2217 an operator for P such that for any Q \u2208 LPA: P \u2217Q = (P .\u2212\u03b3 Q) +Q. Then P \u2217Q = P \u2217\u03b3 Q.\nPROOF. Let SE(Q) = SE . Then P .\u2212\u03b3 Q = P by Definition 5.8 and thus P \u2217 Q = (P .\u2212\u03b3 Q) + Q = P + Q = P \u2217\u03b3 Q by Definition 5.4. Otherwise, SE(Q) 6= SE such that P\u2212 Q = {R \u2286 P | SE(R)\u2229SE(Q) 6= \u2205 and for all R\u2032 with R \u2282 R\u2032 \u2286 P : SE(R\u2032)\u2229SE(Q) = \u2205 } = PQ by Definition 5.1. It follows that P \u2217Q = (P .\u2212\u03b3 Q)+Q = \u22c2\n\u03b3(PQ)+Q = P \u2217\u03b3 Q by Definitions 5.4 and 5.8.\nPROPOSITION 7.2: Let P \u2208 LPA, \u03b3 be a selection function for P , and .\u2212 an operator\nfor P such that for any Q \u2208 LPA: P .\u2212Q = P \u2229 (P \u2217\u03b3 Q). Then P .\u2212Q = P .\u2212\u03b3 Q.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPROOF. Let SE(Q) = \u2205. Then P \u2217\u03b3 Q = P + Q by Definition 5.4 and thus P .\u2212 Q = P \u2229 (P \u2217\u03b3 Q) = P = P .\u2212\u03b3 Q by Definition 5.8. Otherwise, SE(Q) 6= \u2205 such that"}, {"heading": "PQ = {R \u2286 P | SE(R)\u2229SE(Q) 6= \u2205 and for all R", "text": "\u2032 with R \u2282 R\u2032 \u2286 P : SE(R\u2032)\u2229SE(Q) = \u2205 } = P\u2212Q by Definition 5.7. It follows that P .\u2212 Q = P \u2229 (P \u2217\u03b3 Q) = P \u2229 ( \u22c2 \u03b3(P\u2212Q) + Q) by Definition 5.4. Assume there exists a rule r \u2208 Q with r \u2208 P \\ \u22c2\n\u03b3(P\u2212Q). Then there\nexists an R \u2208 \u03b3(P\u2212Q) : r 6\u2208 R, a contradiction since SE(Q) = SE(Q) \u2286 SE(r) and R is maximal. We therefore obtain P .\u2212Q = P .\u2212\u03b3 Q by Definition 5.8.\nPROPOSITION 7.3: Let P \u2208 LPA, be an ensconcement associated with P , and \u2217 an operator for P such that for any Q \u2208 LPA: P \u2217Q = (P .\u2212 Q)+Q. Then P \u2217Q = P \u2217 Q.\nPROOF. Let SE(Q) = SE . Then P .\u2212 Q = P by Definition 6.4 and thus P \u2217 Q = (P .\u2212 Q) +Q = P +Q = P \u2217 Q by Definition 6.3. Otherwise, SE(Q) 6= SE such that cut\u2212 (Q) = { r \u2208 P | SE ({ r \u2032 \u2208 P | r r\u2032 })\u2229SE(Q) 6= \u2205 } = cut (Q) by Definition 6.2. It follows that P\u2217Q = (P .\u2212 Q)+Q = { r \u2208 P | SE(cut (Q))\u2229SE(Q) \u2286 SE(r) }+Q = P\u2217 Q by Definitions 6.3 and 6.4.\nPROPOSITION 7.4: Let P \u2208 LPA, be an ensconcement associated with P , and .\u2212 an\noperator for P such that for any Q \u2208 LPA: P .\u2212Q = P \u2229 (P \u2217 Q). Then P .\u2212Q = P .\u2212 Q.\nPROOF. Let SE(Q) = \u2205. Then P \u2217 Q = P + Q by Definition 6.3 and thus P .\u2212 Q = P \u2229 (P \u2217 Q) = P = P .\u2212 Q by Definition 6.4. Otherwise, SE(Q) 6= \u2205 such that cut (Q) = { r \u2208 P | SE ({ r\u2032 \u2208 P | r r\u2032 }) \u2229 SE(Q) 6= \u2205 } = cut \u2212 (Q) by definition of cut\u2212 (Q). It follows that P .\u2212Q = P \u2229 (P \u2217 Q) = P \u2229 ({ r \u2208 P | SE(cut \u2212 (Q)) \u2229 SE(Q) \u2286\nSE(r) } + Q) by Definition 6.3. Assume there exists a rule r\u2032 \u2208 Q with r\u2032 \u2208 P \\ { r \u2208 P | SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) }. Since SE(Q) = SE(Q) \u2286 SE(r \u2032), it holds that\nSE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r \u2032). This implies r\u2032 \u2208 { r \u2208 P | SE(cut\u2212 (Q)) \u2229 SE(Q) \u2286 SE(r) }, a contradiction. We therefore obtain P .\u2212Q = P .\u2212 Q by Definition 6.4.\nPROPOSITION 8.1: Let P,Q \u2208 LPA and SE(P ) 6= \u2205 6= SE(Q). For any R \u2286 P , if SE(R) \u2229 SE(Q) = \u2205 and for all R\u2032 \u2282 R : SE(R\u2032) \u2229 SE(Q) 6= \u2205, then there exists M \u2208 2M(P )|Q such that R \u2286 \u22c3 M.\nPROOF. Let P,Q be satisfiable logic programs andR \u2286 P such that SE(R)\u2229SE(Q) = \u2205 and for each R\u2032 \u2282 R : SE(R\u2032) \u2229 SE(Q) 6= \u2205. Then there exists some aj \u2208 A such that aj \u2208 At(Q) and there exist one or more rules ri \u2208 R for each aj such that aj \u2208 At(ri). For each ri, there exists a corresponding ri-module M(P )\nri |aj including aj , such that ri \u2208 M(P )ri |aj . It follows from Definition 8.1 that for all remaining rules r\n\u2032 \u2208 R \\ ri : r\u2032 \u2208 \u22c3\ni,j M(P ) ri |aj .\nCOROLLARY 8.1: Let P,Q \u2208 LPA and SE(P ) 6= \u2205. Then SE(P ) \u2229 SE(Q) = \u2205 if and only if SE ( \u22c3\nM(P )|Q) \u2229 SE(Q) = \u2205.\nPROOF. \u201cIf\u201d: Since SE(P ) \u2286 SE ( \u22c3 M(P )|Q), if SE ( \u22c3\nM(P )|Q) \u2229 SE(Q) = \u2205, then also SE(P ) \u2229 SE(Q) = \u2205. \u201cOnly if\u201d: Follows from Proposition 8.1 if Q is satisfiable. Trivial if Q is not satisfiable.\nTHEOREM 8.1: For any P,Q \u2208 LPA, there exists a selection function \u03b3 for P such that P \u2217\u03b3 Q = P \\M(P )|Q + \u22c3 M(P )| \u2217\u03b3 Q + Q (or P .\u2212\u03b3 Q = P \\M(P )|Q + \u22c3 M(P )| .\u2212\u03b3 Q , respectively).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPROOF. To prove the equation for revision, we need to show that P \\ M(P )|Q + \u22c3\nM(P )| \u2217\u03b3 Q = \u22c2\n\u03b3(PQ) for some \u03b3. Let Z \u2286 P be the set of rules that are eliminated during the operation of \u2217\u03b3 per Definition 5.4, i.e., P \u2217\u03b3 Q = \u22c2\n\u03b3(PQ) +Q = P \\ Z + Q, and let Z \u2032 \u2286 P be the set of rules that are eliminated by MODCHANGE. We first show that Z \u2286 Z \u2032. Assume that Z \u2032 = \u2205 until the last iteration of the while-loop. In the last iteration, we have n = |M(P )|Q| and MODCHANGE computes \u22c3\nM(P )|Q \u2217\u03b3 Q = \u22c3 M(P )| \u2217\u03b3 Q . Thus, P \\ M(P )|Q + \u22c3 M(P )| \u2217\u03b3 Q = P \\ M(P )|Q +\n( \u22c3 M(P )|Q \u2217\u03b3 Q). Let MQ denote the set {R \u2286 \u22c3\nM(P )|Q | SE(R) \u2229 SE(Q) 6= \u2205 and, for all R\u2032, R \u2282 R\u2032 \u2286 P implies SE(R\u2032) \u2229 SE(Q) = \u2205 }. If it holds for all R \u2208 \u03b3(PQ) that R \u2229 \u22c3 M(P )|Q \u2208 \u03b3(MQ), then P \\M(P )|Q + ( \u22c3\nM(P )|Q \u2217\u03b3 Q) = ((P \\M(P )|Q) \u222a \u22c3\nM(P )|Q) \u2217\u03b3 Q = P \u2217\u03b3 Q, which implies Z = Z \u2032. We now show that Z \u2032 \u2286 Z. Assume that each revision operation in the following is\nthe most restrictive type, that is, for any set M , \u03b3(M) = M . Thus, if r \u2208 \u22c2\n\u03b3(PQ), then r \u2208 R for allR \u2208 PQ. For eachM as specified in the outer foreach loop of MODCHANGE, let z\u2032 be the set of rules eliminated during the revision of \u22c3 M by Q: z\u2032 = \u22c3 M\\ (( \u22c3\nM\u2217\u03b3 Q) \\Q). From SE(P ) \u2286 SE( \u22c3 M) it then follows that z\u2032 \u2229 \u22c2 \u03b3(PQ) = \u2205. Since \u22c3\nz\u2032 = Z \u2032, we obtain Z \u2032 \u2229 \u22c2\n\u03b3(PQ) = \u2205. Analogous for contraction.\nCOROLLARY 8.2: For any P,Q \u2208 LPA, let P \\ M(P )|Q = { r \u2208 P | for all M \u2208 M(P )|Q : r 6\u2208 M } andM(P )|\u25e6Q denote the output of Algorithm 1 for the inputsM(P )|Q, \u25e6 \u2208 {\u2217 , .\u2212 }, and Q. Then P \u2217 Q = P \\ M(P )|Q + \u22c3 M(P )| \u2217 Q + Q (or P .\u2212 Q = P \\M(P )|Q + \u22c3 M(P )| .\u2212 Q , respectively) for some ensconcement associated with P .\nPROOF. Follows directly from Theorems 7.1, 7.2, and 8.1."}], "references": [{"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["Carlos E. Alchourr\u00f3n", "Peter G\u00e4rdenfors", "David Makinson."], "venue": "Journal of Symbolic Logic 50, 2 (1985), 510\u2013530.", "citeRegEx": "Alchourr\u00f3n et al\\.,? 1985", "shortCiteRegEx": "Alchourr\u00f3n et al\\.", "year": 1985}, {"title": "Partial meet revision and contraction in logic programs", "author": ["Sebastian Binnewies", "Zhiqiang Zhuang", "Kewen Wang."], "venue": "Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, AAAI 2015. 1439\u20131445.", "citeRegEx": "Binnewies et al\\.,? 2015", "shortCiteRegEx": "Binnewies et al\\.", "year": 2015}, {"title": "Preferred answer sets for extended logic programs", "author": ["Gerhard Brewka", "Thomas Eiter."], "venue": "Artificial Intelligence 109, 1\u20132 (1999), 297\u2013356.", "citeRegEx": "Brewka and Eiter.,? 1999", "shortCiteRegEx": "Brewka and Eiter.", "year": 1999}, {"title": "The Birth of Prolog", "author": ["Alain Colmerauer", "Philippe Roussel."], "venue": "History of Programming languages\u2014 II. 331\u2013367.", "citeRegEx": "Colmerauer and Roussel.,? 1996", "shortCiteRegEx": "Colmerauer and Roussel.", "year": 1996}, {"title": "Investigations into a theory of knowledge base revision: Preliminary report", "author": ["Mukesh Dalal."], "venue": "Proceedings of the Seventh National Conference on Artificial Intelligence. 475\u2013479.", "citeRegEx": "Dalal.,? 1988", "shortCiteRegEx": "Dalal.", "year": 1988}, {"title": "A program-level approach to revising logic programs under the answer set semantics", "author": ["James P. Delgrande."], "venue": "Theory and Practice of Logic Programming 10, Special Issue 4\u20136 (2010), 565\u2013580.", "citeRegEx": "Delgrande.,? 2010", "shortCiteRegEx": "Delgrande.", "year": 2010}, {"title": "AGM-style belief revision of logic programs under answer set semantics", "author": ["James P. Delgrande", "Pavlos Peppas", "Stefan Woltran."], "venue": "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 8148. 264\u2013276.", "citeRegEx": "Delgrande et al\\.,? 2013", "shortCiteRegEx": "Delgrande et al\\.", "year": 2013}, {"title": "A framework for compiling preferences in logic programs", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits."], "venue": "Theory and Practice of Logic Programming 3, 2 (2003), 129\u2013187.", "citeRegEx": "Delgrande et al\\.,? 2003", "shortCiteRegEx": "Delgrande et al\\.", "year": 2003}, {"title": "A preference-based framework for updating logic programs", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits."], "venue": "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 4483. 71\u201383.", "citeRegEx": "Delgrande et al\\.,? 2007", "shortCiteRegEx": "Delgrande et al\\.", "year": 2007}, {"title": "A classification and survey of preference handling approaches in nonmonotonic reasoning", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Kewen Wang."], "venue": "Computational Intelligence 20, 2 (2004), 308\u2013334.", "citeRegEx": "Delgrande et al\\.,? 2004", "shortCiteRegEx": "Delgrande et al\\.", "year": 2004}, {"title": "A model-theoretic approach to belief change in answer set programming", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Stefan Woltran."], "venue": "ACM Transactions on Computational Logic 14, 2 (2013), 14:1\u201314:46.", "citeRegEx": "Delgrande et al\\.,? 2013", "shortCiteRegEx": "Delgrande et al\\.", "year": 2013}, {"title": "A truth maintenance system", "author": ["Jon Doyle."], "venue": "Artificial Intelligence 12, 3 (1979), 231\u2013272.", "citeRegEx": "Doyle.,? 1979", "shortCiteRegEx": "Doyle.", "year": 1979}, {"title": "Model-based recasting in answer-set programming", "author": ["Thomas Eiter", "Michael Fink", "J\u00f6rg P\u00fchrer", "Hans Tompits", "Stefan Woltran."], "venue": "Journal of Applied Non-Classical Logics 23, 1\u20132 (2013), 75\u2013104.", "citeRegEx": "Eiter et al\\.,? 2013", "shortCiteRegEx": "Eiter et al\\.", "year": 2013}, {"title": "On properties of update sequences based on causal rejection", "author": ["Thomas Eiter", "Michael Fink", "Giuliana Sabbatini", "Hans Tompits."], "venue": "Theory and Practice of Logic Programming 2, 6 (2002), 711\u2013767.", "citeRegEx": "Eiter et al\\.,? 2002", "shortCiteRegEx": "Eiter et al\\.", "year": 2002}, {"title": "Simplifying logic programs under uniform and strong equivalence", "author": ["Thomas Eiter", "Michael Fink", "Hans Tompits", "Stefan Woltran."], "venue": "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 2923. 87\u201399.", "citeRegEx": "Eiter et al\\.,? 2004", "shortCiteRegEx": "Eiter et al\\.", "year": 2004}, {"title": "On the semantics of updates in databases", "author": ["Ronald Fagin", "Jeffrey D. Ullman", "Moshe Y. Vardi."], "venue": "Proceedings of the 2nd ACM SIGACT-SIGMOD Symposium on Principles of Database Systems (PODS \u201983). 352\u2013365.", "citeRegEx": "Fagin et al\\.,? 1983", "shortCiteRegEx": "Fagin et al\\.", "year": 1983}, {"title": "An axiomatic characterization of ensconcement-based contraction", "author": ["Eduardo Ferm\u00e9", "Mart\u0131\u0301n Krevneris", "Maur\u0131\u0301cio Reis"], "venue": "Journal of Logic and Computation 18,", "citeRegEx": "Ferm\u00e9 et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ferm\u00e9 et al\\.", "year": 2008}, {"title": "Theory contraction through base contraction", "author": ["Andr\u00e9 Fuhrmann."], "venue": "Journal of Philosophical Logic 20, 2 (1991), 175\u2013203.", "citeRegEx": "Fuhrmann.,? 1991", "shortCiteRegEx": "Fuhrmann.", "year": 1991}, {"title": "A survey of multiple contractions", "author": ["Andr\u00e9 Fuhrmann", "Sven Ove Hansson."], "venue": "Journal of Logic, Language and Information 3, 1 (1994), 39\u201375.", "citeRegEx": "Fuhrmann and Hansson.,? 1994", "shortCiteRegEx": "Fuhrmann and Hansson.", "year": 1994}, {"title": "An epistemic approach to conditionals", "author": ["Peter G\u00e4rdenfors."], "venue": "American Philosophical Quarterly 18, 3 (1981), 203\u2013211.", "citeRegEx": "G\u00e4rdenfors.,? 1981", "shortCiteRegEx": "G\u00e4rdenfors.", "year": 1981}, {"title": "Knowledge in Flux: Modeling the Dynamics of Epistemic States", "author": ["Peter G\u00e4rdenfors."], "venue": "MIT Press.", "citeRegEx": "G\u00e4rdenfors.,? 1988", "shortCiteRegEx": "G\u00e4rdenfors.", "year": 1988}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz."], "venue": "Proceedings of the Fifth International Conference on Logic Programming. 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz.,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz.", "year": 1988}, {"title": "New operators for theory change", "author": ["Sven Ove Hansson."], "venue": "Theoria 55, 2 (1989), 114\u2013132.", "citeRegEx": "Hansson.,? 1989", "shortCiteRegEx": "Hansson.", "year": 1989}, {"title": "Belief contraction without recovery", "author": ["Sven Ove Hansson."], "venue": "Studia Logica 50, 2 (1991), 251\u2013260.", "citeRegEx": "Hansson.,? 1991", "shortCiteRegEx": "Hansson.", "year": 1991}, {"title": "Reversing the Levi identity", "author": ["Sven Ove Hansson."], "venue": "Journal of Philosophical Logic 22, 6 (1993), 637\u2013669.", "citeRegEx": "Hansson.,? 1993", "shortCiteRegEx": "Hansson.", "year": 1993}, {"title": "Semi-revision", "author": ["Sven Ove Hansson."], "venue": "Journal of Applied Non-Classical Logics 7, 1\u20132 (1997), 151\u2013175.", "citeRegEx": "Hansson.,? 1997", "shortCiteRegEx": "Hansson.", "year": 1997}, {"title": "A Textbook of Belief Dynamics", "author": ["Sven Ove Hansson."], "venue": "Theory Change and Database Updating. Kluwer.", "citeRegEx": "Hansson.,? 1999", "shortCiteRegEx": "Hansson.", "year": 1999}, {"title": "Local change", "author": ["Sven Ove Hansson", "Renata Wassermann."], "venue": "Studia Logica 70, 1 (2002), 49\u201376.", "citeRegEx": "Hansson and Wassermann.,? 2002", "shortCiteRegEx": "Hansson and Wassermann.", "year": 2002}, {"title": "Rational conceptual change", "author": ["William L. Harper."], "venue": "PSA: Proceedings of the Biennial Meeting of the Philosophy of Science Association Two: Symposia and Invited Papers (1976), 462\u2013494.", "citeRegEx": "Harper.,? 1976", "shortCiteRegEx": "Harper.", "year": 1976}, {"title": "Equivalence of logic programs under updates", "author": ["Katsumi Inoue", "Chiaki Sakama."], "venue": "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 3229. 174\u2013186.", "citeRegEx": "Inoue and Sakama.,? 2004", "shortCiteRegEx": "Inoue and Sakama.", "year": 2004}, {"title": "Propositional knowledge base revision and minimal change", "author": ["Hirofumi Katsuno", "Alberto O. Mendelzon."], "venue": "Artificial Intelligence 52, 3 (1991), 263\u2013294.", "citeRegEx": "Katsuno and Mendelzon.,? 1991", "shortCiteRegEx": "Katsuno and Mendelzon.", "year": 1991}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["Hirofumi Katsuno", "Alberto O. Mendelzon."], "venue": "Belief revision, Peter G\u00e4rdenfors (Ed.). Chapter 7, 183\u2013203.", "citeRegEx": "Katsuno and Mendelzon.,? 1992", "shortCiteRegEx": "Katsuno and Mendelzon.", "year": 1992}, {"title": "Predicate logic as a programming language", "author": ["Robert Kowalski."], "venue": "Proceedings of the IFIP Congress. 569\u2013574.", "citeRegEx": "Kowalski.,? 1974", "shortCiteRegEx": "Kowalski.", "year": 1974}, {"title": "Belief base change operations for answer set programming", "author": ["Patrick Kr\u00fcmpelmann", "Gabriele Kern-Isberner."], "venue": "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 7519. 294\u2013306.", "citeRegEx": "Kr\u00fcmpelmann and Kern.Isberner.,? 2012", "shortCiteRegEx": "Kr\u00fcmpelmann and Kern.Isberner.", "year": 2012}, {"title": "Generalizing updates: From models to programs", "author": ["Jo\u00e3o Alexandre Leite", "Lu\u0131\u0301s Moniz Pereira"], "venue": "In Logic Programming and Knowledge Representation. Lecture Notes in Computer Science,", "citeRegEx": "Leite and Pereira.,? \\Q1998\\E", "shortCiteRegEx": "Leite and Pereira.", "year": 1998}, {"title": "Subjunctives, dispositions and chances", "author": ["Isaac Levi."], "venue": "Dispositions. Synthese Library, Vol. 113. 303\u2013 335.", "citeRegEx": "Levi.,? 1977", "shortCiteRegEx": "Levi.", "year": 1977}, {"title": "The Enterprise of Knowledge: An Essay on Knowledge, Credal Probability, and Chance", "author": ["Isaac Levi."], "venue": "MIT Press.", "citeRegEx": "Levi.,? 1980", "shortCiteRegEx": "Levi.", "year": 1980}, {"title": "Strongly equivalent logic programs", "author": ["Vladimir Lifschitz", "David Pearce", "Agust\u0131\u0301n Valverde"], "venue": "ACM Transactions on Computational Logic 2,", "citeRegEx": "Lifschitz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "Foundations of Logic Programming", "author": ["John W. Lloyd."], "venue": "Springer-Verlag New York.", "citeRegEx": "Lloyd.,? 1987", "shortCiteRegEx": "Lloyd.", "year": 1987}, {"title": "On the status of the postulate of recovery in the logic of theory change", "author": ["David Makinson."], "venue": "Journal of Philosophical Logic 16, 4 (1987), 383\u2013394.", "citeRegEx": "Makinson.,? 1987", "shortCiteRegEx": "Makinson.", "year": 1987}, {"title": "Screened revision", "author": ["David Makinson."], "venue": "Theoria 63, 1\u20132 (1997), 14\u201323.", "citeRegEx": "Makinson.,? 1997", "shortCiteRegEx": "Makinson.", "year": 1997}, {"title": "Programs with common sense", "author": ["John McCarthy."], "venue": "Proceedings of the Symposium on Mechanisation of Thought Processes. 77\u201384.", "citeRegEx": "McCarthy.,? 1958", "shortCiteRegEx": "McCarthy.", "year": 1958}, {"title": "Foundational belief change", "author": ["Abhaya C. Nayak."], "venue": "Journal of Philosophical Logic 23, 5 (1994), 495\u2013533.", "citeRegEx": "Nayak.,? 1994", "shortCiteRegEx": "Nayak.", "year": 1994}, {"title": "Multiple contraction", "author": ["Reinhard Nieder\u00e9e."], "venue": "A further case against G\u00e4rdenfors\u2019 principle of recovery. In The Logic of Theory Change. Lecture Notes in Computer Science, Vol. 465. 322\u2013334.", "citeRegEx": "Nieder\u00e9e.,? 1991", "shortCiteRegEx": "Nieder\u00e9e.", "year": 1991}, {"title": "Updates in answer set programming: An approach based on basic structural properties", "author": ["Mauricio Osorio", "V\u0131\u0301ctor Cuevas"], "venue": "Theory and Practice of Logic Programming 7,", "citeRegEx": "Osorio and Cuevas.,? \\Q2007\\E", "shortCiteRegEx": "Osorio and Cuevas.", "year": 2007}, {"title": "Beliefs, Belief Revision, and Splitting Languages", "author": ["Rohit Parikh."], "venue": "Logic, Language and Computation 2 (1999), 266\u2013278.", "citeRegEx": "Parikh.,? 1999", "shortCiteRegEx": "Parikh.", "year": 1999}, {"title": "Modellings for belief change: Base contraction, multiple contraction, and epistemic entrenchment (Preliminary report)", "author": ["Hans Rott."], "venue": "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 633. 139\u2013153.", "citeRegEx": "Rott.,? 1992", "shortCiteRegEx": "Rott.", "year": 1992}, {"title": "Nonmonotonic reasoning by minimal belief revision", "author": ["Ken Satoh."], "venue": "Proceedings of the International Conference on Fifth Generation Computer Systems. 455\u2013462.", "citeRegEx": "Satoh.,? 1988", "shortCiteRegEx": "Satoh.", "year": 1988}, {"title": "A semantic framework for preference handling in answer set programming", "author": ["Torsten Schaub", "Kewen Wang."], "venue": "Theory and Practice of Logic Programming 3, 4\u20135 (2003), 569\u2013607.", "citeRegEx": "Schaub and Wang.,? 2003", "shortCiteRegEx": "Schaub and Wang.", "year": 2003}, {"title": "Characterization theorems for revision of logic programs", "author": ["Nicolas Schwind", "Katsumi Inoue."], "venue": "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 8148. 485\u2013 498.", "citeRegEx": "Schwind and Inoue.,? 2013", "shortCiteRegEx": "Schwind and Inoue.", "year": 2013}, {"title": "Updates of hybrid knowledge bases", "author": ["Martin Slota."], "venue": "Ph.D. Dissertation. Universidade Nova de Lisboa.", "citeRegEx": "Slota.,? 2012", "shortCiteRegEx": "Slota.", "year": 2012}, {"title": "Robust equivalence models for semantic updates of answer-set programs", "author": ["Martin Slota", "Jo\u00e3o Leite."], "venue": "Principles of Knowledge Representation and Reasoning: Proceedings of the Thirteenth International Conference, KR 2012. 158\u2013168.", "citeRegEx": "Slota and Leite.,? 2012", "shortCiteRegEx": "Slota and Leite.", "year": 2012}, {"title": "The rise and fall of semantic rule updates based on SE-models", "author": ["Martin Slota", "Jo\u00e3o Leite."], "venue": "Theory and Practice of Logic Programming FirstView (2013), 1\u201339.", "citeRegEx": "Slota and Leite.,? 2013", "shortCiteRegEx": "Slota and Leite.", "year": 2013}, {"title": "Strong equivalence made easy: Nested expressions and weight constraints", "author": ["Hudson Turner."], "venue": "Theory and Practice of Logic Programming 3, 4 (2003), 609\u2013622.", "citeRegEx": "Turner.,? 2003", "shortCiteRegEx": "Turner.", "year": 2003}, {"title": "Resource-bounded belief revision", "author": ["Renata Wassermann."], "venue": "Ph.D. Dissertation. Universiteit van Amsterdam.", "citeRegEx": "Wassermann.,? 2000", "shortCiteRegEx": "Wassermann.", "year": 2000}, {"title": "On AGM for non-classical logics", "author": ["Renata Wassermann."], "venue": "Journal of Philosophical Logic 40, 2 (2011), 271\u2013294.", "citeRegEx": "Wassermann.,? 2011", "shortCiteRegEx": "Wassermann.", "year": 2011}, {"title": "On the logic of theory base change", "author": ["Mary-Anne Williams."], "venue": "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 838. 86\u2013105.", "citeRegEx": "Williams.,? 1994", "shortCiteRegEx": "Williams.", "year": 1994}, {"title": "Sound and complete inference rules for SE-consequence", "author": ["Ka-Shu Wong."], "venue": "Journal of Artificial Intelligence Research 31 (2008), 205\u2013216.", "citeRegEx": "Wong.,? 2008", "shortCiteRegEx": "Wong.", "year": 2008}, {"title": "Reconsidering AGMstyle belief revision in the context of logic programs", "author": ["Zhiqiang Zhuang", "James P. Delgrande", "Abhaya C. Nayak", "Abdul Sattar."], "venue": "Proceedings of the 22nd European Conference on Artificial Intelligence, ECAI 2016. 671\u2013679.", "citeRegEx": "Zhuang et al\\.,? 2016", "shortCiteRegEx": "Zhuang et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 15, "context": "change [Doyle 1979; Fagin et al. 1983; G\u00e4rdenfors 1988; Hansson 1999; Harper 1976; Levi 1980] concerns itself exactly with these kinds of dynamics in knowledge bases.", "startOffset": 7, "endOffset": 93}, {"referenceID": 0, "context": "An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourr\u00f3n et al. 1985].", "startOffset": 204, "endOffset": 228}, {"referenceID": 6, "context": "A breakthrough arrived with the distance-based approach [Delgrande et al. 2013] to logic program revision, which rests upon characterising an agent\u2019s beliefs in terms of the set of SE (strong equivalence) models [Lifschitz et al.", "startOffset": 56, "endOffset": 79}, {"referenceID": 37, "context": "2013] to logic program revision, which rests upon characterising an agent\u2019s beliefs in terms of the set of SE (strong equivalence) models [Lifschitz et al. 2001; Turner 2003] of a logic program.", "startOffset": 138, "endOffset": 174}, {"referenceID": 0, "context": "An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourr\u00f3n et al. 1985]. It classifies the possible changes to a knowledge base as expansion, revision, and contraction operations. In an expansion, new information is incorporated into a knowledge base, regardless of any inconsistencies that may arise. A revision operation also incorporates new information into a knowledge base, but in such a way that the resulting knowledge base is consistent. This is achieved by discarding some existing information. During a contraction, no new information is added to a knowledge base but some existing information is removed from it. On the one hand, the framework provides a set of postulates that each rational change operator should satisfy, and, on the other hand, defines specific constructions of expansion, revision, and contraction that satisfy these criteria. While the underlying assumption of the AGM framework is that any information implied by a knowledge base is represented explicitly in the knowledge base, the belief base framework of belief change [Fuhrmann 1991; Hansson 1989; Rott 1992] does not require this assumption. Postulates and constructions for expansion, revision, and contraction operators in the belief base framework have been defined to complement those from the AGM model (Hansson [1999] provides a summary).", "startOffset": 205, "endOffset": 1471}, {"referenceID": 0, "context": "An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourr\u00f3n et al. 1985]. It classifies the possible changes to a knowledge base as expansion, revision, and contraction operations. In an expansion, new information is incorporated into a knowledge base, regardless of any inconsistencies that may arise. A revision operation also incorporates new information into a knowledge base, but in such a way that the resulting knowledge base is consistent. This is achieved by discarding some existing information. During a contraction, no new information is added to a knowledge base but some existing information is removed from it. On the one hand, the framework provides a set of postulates that each rational change operator should satisfy, and, on the other hand, defines specific constructions of expansion, revision, and contraction that satisfy these criteria. While the underlying assumption of the AGM framework is that any information implied by a knowledge base is represented explicitly in the knowledge base, the belief base framework of belief change [Fuhrmann 1991; Hansson 1989; Rott 1992] does not require this assumption. Postulates and constructions for expansion, revision, and contraction operators in the belief base framework have been defined to complement those from the AGM model (Hansson [1999] provides a summary). While the AGM and belief base frameworks have been applied to a variety of knowledge representation formalisms (an overview is given by Wassermann [2011]), work on an adaptation to knowledge representation in the form of logic programs [Colmerauer and Roussel 1996; Kowalski 1974; Lloyd 1987] has been slow to progress.", "startOffset": 205, "endOffset": 1646}, {"referenceID": 1, "context": "Preliminary results from Sections 5 and 8 were presented in a conference paper [Binnewies et al. 2015].", "startOffset": 79, "endOffset": 102}, {"referenceID": 37, "context": "Given two programs P andQ, we say that P is strongly equivalent [Lifschitz et al. 2001] to Q, denoted by P \u2261s Q, iff SE(P ) = SE(Q), and P implies Q, denoted by P |=s Q, iff SE(P ) \u2286 SE(Q).", "startOffset": 64, "endOffset": 87}, {"referenceID": 0, "context": "The AGM framework [Alchourr\u00f3n et al. 1985; G\u00e4rdenfors 1988] defines expansion, revision, and contraction as the change operations on a body of beliefs held by an agent, called a belief state henceforth, in light of some new information.", "startOffset": 18, "endOffset": 59}, {"referenceID": 17, "context": "The appropriateness of the Recovery postulate (\u22965) within this set of contraction postulates has been discussed intensively [Fuhrmann 1991; Hansson 1991; Makinson 1987; Nayak 1994; Nieder\u00e9e 1991]. To replace the Recovery postulate in expressing that no beliefs should be retracted unduly during a contraction operation, alternative postulates were proposed. Hansson [1991] offered the following postulate:", "startOffset": 125, "endOffset": 373}, {"referenceID": 16, "context": "More recently, Ferm\u00e9 et al. [2008] presented the following Disjunctive Elimination postulate (\u22965de):", "startOffset": 15, "endOffset": 35}, {"referenceID": 16, "context": "In the presence of (\u22962)\u2013(\u22963), (\u22965r) is equivalent to (\u22965de) in propositional logic [Ferm\u00e9 et al. 2008].", "startOffset": 83, "endOffset": 102}, {"referenceID": 0, "context": "One of the classic constructions to implement belief change is partial meet contraction [Alchourr\u00f3n et al. 1985], which we recapitulate here.", "startOffset": 88, "endOffset": 112}, {"referenceID": 0, "context": "[Alchourr\u00f3n et al. 1985] For any belief set K, \u2296\u03b3 is a partial meet contraction operator for K iff \u2296\u03b3 satisfies (\u22961)\u2013(\u22966).", "startOffset": 0, "endOffset": 24}, {"referenceID": 0, "context": "[Alchourr\u00f3n et al. 1985] For any belief set K, \u2296\u03b3\u2032 is a transitively relational partial meet contraction operator for K iff \u2296\u03b3\u2032 satisfies (\u22961)\u2013(\u22968).", "startOffset": 0, "endOffset": 24}, {"referenceID": 18, "context": "A corresponding (transitively relational) partial meet revision operator \u229b\u03b3 (\u229b\u03b3\u2032) that satisfies (\u229b1)\u2013(\u229b6) ((\u229b1)\u2013(\u229b8)) can be obtained from a (transitively relational) partial meet contraction operator via the Levi identity: K \u229b \u03c6 = (K \u2296 \u00ac\u03c6) \u2295 \u03c6 [G\u00e4rdenfors 1981; Levi 1977]. The inverse identity, which constructs a contraction operator from a revision operator, is due to Harper [1976]: K \u2296 \u03c6 = K \u2229 (K \u229b \u00ac\u03c6).", "startOffset": 247, "endOffset": 388}, {"referenceID": 17, "context": "Belief bases [Fuhrmann 1991; Hansson 1989; Rott 1992] are an alternative representation of belief states. A belief base is a set of sentences from L that is not necessarily closed under logical consequence. Hansson [1993] defined a partial meet base contraction operator \u2212\u03b3 for a belief base B as B \u2212\u03b3 \u03c6 = \u22c2", "startOffset": 14, "endOffset": 222}, {"referenceID": 22, "context": "[Hansson 1993] For any belief base B, >\u03b3 is a partial meet base revision operator for B iff >\u03b3 satisfies (>1)\u2013(>5). The pendants to (>1) and (>2) in the AGM framework are (\u229b2) and (\u229b3), respectively. (>3) requires \u03c8 to only be removed from B if it would otherwise make the revision outcome inconsistent. (>4) mandates that if any parts of B which are consistent with \u03c6 are also consistent with \u03c8, then the same parts of B will be retained in a revision by \u03c6 as in a revision by \u03c8. (>5) is a weaker version of (\u229b5). Williams [1994] proposed further belief change operators for belief bases, which rely on an ordering over the sentences contained in a belief base, called ensconcement.", "startOffset": 1, "endOffset": 531}, {"referenceID": 16, "context": "[Ferm\u00e9 et al. 2008] Let B be a belief base and \u22964 an ensconcement contraction operator for B.", "startOffset": 0, "endOffset": 19}, {"referenceID": 16, "context": "In the belief base framework, the relationship between (\u22123) and (\u22128) is different to the one between (\u22965r) and (\u22965de) in the AGM framework: (\u22123) implies (\u22128) but not vice versa [Ferm\u00e9 et al. 2008].", "startOffset": 177, "endOffset": 196}, {"referenceID": 16, "context": "Please note that the proof of the representation theorem (Theorem 14 in [Ferm\u00e9 et al. 2008]) contains an error, as acknowledged by the authors.", "startOffset": 72, "endOffset": 91}, {"referenceID": 6, "context": "One of the key developments for adapting the AGM framework of belief change to logic programs came with the distance-based approach to logic program revision [Delgrande et al. 2013].", "startOffset": 158, "endOffset": 181}, {"referenceID": 6, "context": "[Delgrande et al. 2013] Let P,Q \u2208 LPA.", "startOffset": 0, "endOffset": 23}, {"referenceID": 4, "context": "The approach adapts two revision operators from classic belief change to logic programs, namely, Dalal\u2019s revision operator [Dalal 1988] and Satoh\u2019s revision operator [Satoh 1988]. Informally, to revise a program P by a program Q, the operators return those SE models from the set of SE models of Q that are closest to the SE models of P , where closeness is determined by Dalal\u2019s or Satoh\u2019s notion of distance. Delgrande et al. [2013] identified that the adaptation of Satoh\u2019s revision operator gives more intuitive results than the adaptation of Dalal\u2019s revision operator, so we will focus on the former here.", "startOffset": 97, "endOffset": 435}, {"referenceID": 6, "context": "[Delgrande et al. 2013] The revision operator \u22c6 satisfies (\u22171m)\u2013(\u22175m).", "startOffset": 0, "endOffset": 23}, {"referenceID": 6, "context": "The distance-based approach was extended by two representation theorems [Delgrande et al. 2013; Schwind and Inoue 2013], stating that any logic program revision operator satisfying (\u22171m)\u2013(\u22176m) plus some additional conditions can be characterised by some preorder over a set of SE models.", "startOffset": 72, "endOffset": 119}, {"referenceID": 5, "context": "The program-level approach to logic program revision [Delgrande 2010] is also based on answer set semantics and assumes the beliefs that make up a belief state to be the answer sets of a program. The revision operation relies on extending the standard answer set semantics to three-valued answer set semantics for determining the outcome. To revise a program P by a program Q, for each three-valued answer set X of Q, all maximal subsets R of P are selected such that X is a subset of each three-valued answer set X \u2032 of R \u222aQ. The revision operation returns a set of answer sets that correspond to each X \u2032 as the result. In the author\u2019s view, the AGM revision postulates (\u229b3), (\u229b4), (\u229b7), and (\u229b8) are inappropriate in the context of nonmonotonic semantics. An adaptation of the remaining postulates is fulfilled by the revision operation. The work of Zhuang et al. [2016] concerns itself with the revision of a disjunctive logic program by another.", "startOffset": 54, "endOffset": 874}, {"referenceID": 8, "context": "Thus, it is conceivable to express the revision of P by Q as (P \u222a Q,<), where < is some appropriate preference ordering on P \u222a Q (from [Delgrande et al. 2007], for example), and employ one of the different semantics proposed [Brewka and Eiter 1999; Delgrande et al.", "startOffset": 135, "endOffset": 158}, {"referenceID": 7, "context": "2007], for example), and employ one of the different semantics proposed [Brewka and Eiter 1999; Delgrande et al. 2003; Schaub and Wang 2003] to obtain the preferred answer sets of this ordered logic program.", "startOffset": 72, "endOffset": 140}, {"referenceID": 7, "context": "An ordered logic program can be transformed into a standard logic program, so that the preferred answer sets of the former are exactly the answer sets of the latter [Delgrande et al. 2003].", "startOffset": 165, "endOffset": 188}, {"referenceID": 9, "context": ", may have no answer sets, even if P and Q themselves are consistent [Delgrande et al. 2004].", "startOffset": 69, "endOffset": 92}, {"referenceID": 4, "context": "The landscape of update operators has already been reviewed exhaustively in other places, for example, detailed overviews are given by Delgrande et al. [2004] and Slota [2012].", "startOffset": 135, "endOffset": 159}, {"referenceID": 4, "context": "The landscape of update operators has already been reviewed exhaustively in other places, for example, detailed overviews are given by Delgrande et al. [2004] and Slota [2012]. Of interest in the current context is the exception-based update approach [Slota and Leite 2012], which introduces RE (robust equivalence) models as an extension of SE models.", "startOffset": 135, "endOffset": 176}, {"referenceID": 14, "context": "Even though a consequence relation for logic programs under SE semantics exists [Eiter et al. 2004; Wong 2008], logic programs are per se not closed under logical consequence.", "startOffset": 80, "endOffset": 110}, {"referenceID": 13, "context": "Besides adaptations for the purpose of logic program \u2018update\u2019 operations under answer set semantics [Eiter et al. 2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (\u229b1KM)\u2013(\u229b6KM) until now [Delgrande et al.", "startOffset": 100, "endOffset": 119}, {"referenceID": 6, "context": "2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (\u229b1KM)\u2013(\u229b6KM) until now [Delgrande et al. 2013; Delgrande et al. 2013; Schwind and Inoue 2013].", "startOffset": 184, "endOffset": 254}, {"referenceID": 6, "context": "2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (\u229b1KM)\u2013(\u229b6KM) until now [Delgrande et al. 2013; Delgrande et al. 2013; Schwind and Inoue 2013].", "startOffset": 184, "endOffset": 254}, {"referenceID": 0, "context": "As the basis for our construction of partial meet revision, we define a compatible set of some program with respect to another program as the dual of a remainder set [Alchourr\u00f3n et al. 1985].", "startOffset": 166, "endOffset": 190}, {"referenceID": 12, "context": "Corresponding canonical logic programs can be constructed via the method provided by Eiter et al. [2013].", "startOffset": 85, "endOffset": 105}, {"referenceID": 16, "context": "\u2212 satisfies the same set of belief base postulates as its counterpart for propositional logic [Ferm\u00e9 et al. 2008], that is, ( .", "startOffset": 94, "endOffset": 113}], "year": 2017, "abstractText": "Recent methods have adapted the well-established AGM and belief base frameworks for belief change to cover belief revision in logic programs. In this study here, we present two new sets of belief change operators for logic programs. They focus on preserving the explicit relationships expressed in the rules of a program, a feature that is missing in purely semantic approaches that consider programs only in their entirety. In particular, operators of the latter class fail to satisfy preservation and support, two important properties for belief change in logic programs required to ensure intuitive results. We address this shortcoming of existing approaches by introducing partial meet and ensconcement constructions for logic program belief change, which allow us to define syntax-preserving operators that satisfy preservation and support. Our work is novel in that our constructions not only preserve more information from a logic program during a change operation than existing ones, but they also facilitate natural definitions of contraction operators, the first in the field to the best of our knowledge. In order to evaluate the rationality of our operators, we translate the revision and contraction postulates from the AGM and belief base frameworks to the logic programming setting. We show that our operators fully comply with the belief base framework and formally state the interdefinability between our operators. We further propose an algorithm that is based on modularising a logic program to reduce partial meet and ensconcement revisions or contractions to performing the operation only on the relevant modules of that program. Finally, we compare our approach to two state-of-the-art logic program revision methods and demonstrate that our operators address the shortcomings of one and generalise the other method.", "creator": "dvips(k) 5.996 Copyright 2016 Radical Eye Software"}}}