{"id": "1703.08397", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Mar-2017", "title": "Reasoning by Cases in Structured Argumentation", "abstract": "we extend the $ % aspic ^ + $ i framework for structured argumentation so as to allow immediate applications of the reasoning by cases employing inference scheme techniques for defeasible arguments. given statements an argument with conclusion ` $ a $ or $ b $ ', an argument based on $ a $ with conclusion $ c $, and an argument clause based on $ ~ b $ with conclusion $ c $, we allow the construction of an argument made with conclusion $? c $. we show how our framework leads to different results than other approaches in non - monotonic logic for dealing with disjunctive information, such as disjunctive default theory rules or approaches based usually on the word or - binary rule ( which allows to derive a defeasible truth rule ` @ if ( $ a $ or $ b $ ) then $ c $ ', given two defeasible rules ` if $ a $ then $ ^ c $'and ` if $ b $ then $ c $'). eventually we raise new questions regarding the subtleties of reasoning defeasibly with disjunctive information, further and also show that how its formalization is more intricate than one would later presume.", "histories": [["v1", "Fri, 24 Mar 2017 13:00:52 GMT  (19kb)", "http://arxiv.org/abs/1703.08397v1", "Proceedings of SAC/KRR 2017"]], "COMMENTS": "Proceedings of SAC/KRR 2017", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["mathieu beirlaen", "jesse heyninck", "christian stra{\\ss}er"], "accepted": false, "id": "1703.08397"}, "pdf": {"name": "1703.08397.pdf", "metadata": {"source": "CRF", "title": "Reasoning by Cases in Structured Argumentation", "authors": ["Mathieu Beirlaen", "Jesse Heyninck"], "emails": ["mathieubeirlaen@gmail.com,", "jesse.heyninck@gmail.com,", "christian.strasser@rub.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 3.\n08 39\n7v 1\n[ cs\n.A I]"}, {"heading": "1 Introduction", "text": "When formulated in terms of the material implication connective \u2018\u2283\u2019, the pattern of reasoning by cases is valid in classical logic:\n\u03d51 \u2228 . . . \u2228 \u03d5n, \u03d51 \u2283 \u03c8, . . . , \u03d5n \u2283 \u03c8 \u22a2 \u03c8 (RBC\u2283)\nMany formalisms of non-monotonic logic likewise allow defeasible applications of reasoning by cases, where a formula \u2018\u03d5 \u21d2 \u03c8\u2019 reads \u2018If \u03d5, then normally/usually/probably \u03c8\u2019:\n\u03d51 \u2228 . . . \u2228 \u03d5n, \u03d51 \u21d2 \u03c8, . . . , \u03d5n \u21d2 \u03c8 |\u223c\u03c8 (RBC\u21d2)\n\u2217Research for this article was sponsored by a Sofja Kovalevskaja award of the Alexander von Humboldt Foundation, funded by the German Ministry for Education and Research. We are indebted to Leon van der Torre and Emil Weydert for helpful comments and suggestions.\nIn the context of formal argumentation, it is natural to include a more general argumentative version of the RBC rule. Relative to a knowledge base this rule would allow the construction of an rbc- argument C with conclusion \u03c8 given (i) an argument A with the disjunctive conclusion \u03d51 \u2228 . . . \u2228 \u03d5n, and (ii) for each i \u2208 {1, . . . , n}, an argument Bi with conclusion \u03c8 based on an extended knowledge base including \u03d5i. To the best of our knowledge, no such rule has yet been introduced and studied in the context of formal argumentation. The aim of this paper is to do exactly this, and to investigate the nature of \u2018argumentation by cases\u2019.\nFor defining rbc-arguments and attacks on rbc-arguments, we will extend the ASPIC+ framework [8]. ASPIC+ is a framework for instantiating abstract argumentation frameworks as conceptualized by Dung [4]. We introduce abstract argumentation frameworks in Section 2, and define our formalism in Section 3. Our approach is limited in at least two ways. First, we do not allow for nested or iterated rbc-arguments. Second, we do not yet take into account priorities assigned to arguments, nor do we include undercutting attacks. The removal of these limitations is left for future work.\nThe present approach raises new questions regarding the nature of arguing by cases. For instance, what happens if in the rbc-argument C one of the arguments Bi is rebutted by an independent argument? Is this a sufficient condition for rejecting argument C? After all, there are n\u2212 1 other defeasible \u2018paths\u2019 leading to C\u2019s conclusion. Our formalism implements a cautious rationale according to which a successful rebut on one of its paths is indeed sufficient for rejecting an rbc-argument. In Section 4 we show how this approach leads to intuitive outcomes different from those obtained by other formalisms in non-monotonic logic."}, {"heading": "2 Abstract argumentation", "text": "A Dung-style abstract argumentation framework (AF) is a pair (Arg, Att) where Arg is a set of arguments and Att \u2286 Arg \u00d7 Arg is a binary relation of attack. Relative to an AF, Dung defines a number of extensions \u2013 subsets of Arg \u2013 on the basis of which we can evaluate the arguments in Arg.\nDefinition 1 (Defense). A set of arguments X defends an argument A iff every attacker of A is attacked by some B \u2208 X .\nDefinition 2 (Extensions). Let (Arg, Att) be an AF. If E \u2286 Arg is conflictfree, i.e. there are no A,B \u2208 E for which (A,B) \u2208 Att, then (i) E is a complete extension iff A \u2208 E whenever E defends A; (ii) E is a preferred extension iff it is a set inclusion maximal complete extension; and (iii) E is the grounded extension iff it is the set inclusion minimal complete extension.\nDung [4] showed that for every AF there is a unique grounded extension. On Dung\u2019s abstract approach from [4], arguments are basic units of analysis the internal structure of which is not represented. In what follows we will instantiate\nabstract arguments by allowing for the representation of their internal logical structure."}, {"heading": "3 Argumentation by cases", "text": "In this section we define structured argumentation frameworks (SAFs) for reasoning by cases. Our point of departure is an instantiation of the ASPIC+ framework (without priorities, without defeasible premises and without undercuts).\nWe adjust ASPIC+ in the following ways. (i) We define a new type of argument called an rbc-argument (see point 4 in Definition 4). By means of rbc-arguments, we can argue by cases in an argumentation formalism (Section 3.1). (ii) We generalize the attack relation so as to include argumentation by cases, using the concept of a hypothetical argument (Section 3.2), and we define a logical consequence relation for the resulting SAFs (Section 3.3). We briefly discuss the meta-theoretical properties of our framework (Section 3.4)."}, {"heading": "3.1 Arguments", "text": "We illustrate our framework using the propositional fragment of classical logic (CL) as our core logic. We denote the consequence relation of CL by \u22a2. To obtain the formal language L ofCL, we close a denumerable stock P = {p, q, r, . . .} of propositional letters under the usual CL-connectives \u00ac,\u2228,\u2227,\u2283,\u2261. We also add the verum constant \u22a4 and the falsum constant \u22a5 to L. For reasons of transparency we will sometimes use subscripted letters p1, p2, q1, q2, . . . as names for propositional letters.\nDefinition 3 (Argumentation theory). An argumentation theory (AT) is a triple AT = (L,R,F) where:\n\u2022 L is our formal language defined above;\n\u2022 R = S \u222aD is a set of strict (S) and defeasible (D) inference rules of the form \u03d51, . . . , \u03d5n \u2192 \u03c8 and \u03d51, . . . , \u03d5n \u21d2 \u03c8 respectively (where \u03d51, . . . , \u03d5n, \u03c8 \u2208 L); and\n\u2022 F \u2286 L is a CL-consistent knowledge base.1\nWe assume in addition that \u03d51, . . . , \u03d5n \u2192 \u03c8 \u2208 S iff {\u03d51, . . . , \u03d5n} \u22a2 \u03c8. Since we keep L and S fixed, we will in the remainder refer to ATs as pairs (D,F).\nDefinition 4 (Arguments). Given an argumentation theory AT = (D,F), the set of arguments Arg\u22a5(AT) contains:"}, {"heading": "1. A = \u3008\u03c6\u3009 where \u03c6 \u2208 F", "text": "\u2022 Conc(A) = \u03c6\n\u2022 Sub(A) = {A}\n1F \u2286 L is CL-consistent iff F 6\u22a2 \u22a5.\n\u2022 HSub(A) = \u2205\n2. A = \u3008A1, . . . , An \u2192 \u03c6\u3009 where A1, . . . , An \u2208 Arg\u22a5(AT) and Conc(A1), . . . , Conc(An) \u2192 \u03c6 \u2208 S\n\u2022 Conc(A) = \u03c6\n\u2022 Sub(A) = {A} \u222a Sub(A1) \u222a . . . \u222a Sub(An)\n\u2022 HSub(A) = HSub(A1) \u222a . . . \u222a HSub(An)\n3. A = \u3008A1, . . . , An \u21d2 \u03c6\u3009 where A1, . . . , An \u2208 Arg\u22a5(AT) and Conc(A1), . . . , Conc(An) \u21d2 \u03c6 \u2208 D\n\u2022 Conc(A) = \u03c6\n\u2022 Sub(A) = {A} \u222a Sub(A1) \u222a . . . \u222a Sub(An)\n\u2022 HSub(A) = HSub(A1) \u222a . . . \u222a HSub(An)\n4. A = \u3008A1, [A2], . . . , [An] \u03c6\u3009 where n \u2265 3\n\u2022 \u03c6 = \u2228\n{Conc(A2), . . . , Conc(An)},\n\u2022 Conc(A1) = \u2228n i=2 \u03c8i, Ai \u2208 Arg \u22a5((D,F \u222a {\u03c8i})), \u2022 and HSub(Ai) = \u2205 for all 2 \u2264 i \u2264 n.\nWe have:\n\u2022 Conc(A) = \u03c6\n\u2022 Sub(A) = {A} \u222a Sub(A1)\n\u2022 HSub(A) = HSub(A1) \u222a {(A2, \u03c82), . . . , (An, \u03c8n)}\nDefinition 4 departs in two respects from the way arguments are usually defined in ASPIC+. First, there is a new class of arguments constructed by means of rule 4: these arguments are called rbc-arguments. They correspond to applications of the reasoning by cases scheme outlined in Section 1.\nExample 1. Let D = {\u22a4 \u21d2 p\u2228 q; p\u21d2 p1; p1 \u21d2 p2; p2 \u21d2 r; q \u21d2 q1; q1 \u21d2 r} and AT = (D, {\u22a4}). The following are arguments in Arg\u22a5(AT):\nA1 = \u3008\u3008\u22a4\u3009 \u21d2 p \u2228 q\u3009\nA2 = \u3008A1, [\u3008\u3008\u3008p\u3009 \u21d2 p1\u3009 \u21d2 p2\u3009 \u21d2 r], [\u3008\u3008q\u3009 \u21d2 q1\u3009 \u21d2 r] r\u3009\nA3 = \u3008A1, [\u3008p\u3009 \u21d2 p1], [\u3008q\u3009 \u21d2 q1] p1 \u2228 q1\u3009\nA2 and A3 are rbc-arguments constructed on the basis of the \u2018cases\u2019 p and q in the disjunctive conclusion of A1. Argument A2 concludes that r, while A3 concludes that p1 \u2228 q1.\nThe second novel feature of Definition 4 is that we not only keep track of an argument A\u2019s conclusion (Conc(A)) and its sub-arguments (Sub(A)), but also of its hypothetical sub-arguments (HSub(A)). These are pairs consisting of an argument B and a formula \u03c6, where B is constructible on the basis of the extended AT obtained by adding \u03c6 to the knowledge base of the original AT. For instance, HSub(A2) = {( \u3008\u3008\u3008\u3008p\u3009 \u21d2 p1\u3009 \u21d2 p2\u3009 \u21d2 r\u3009, p ) , ( \u3008\u3008\u3008q\u3009 \u21d2 q1\u3009 \u21d2 r\u3009, q )} .\nA2\u2019s hypothetical sub-argument (\u3008\u3008\u3008\u3008p\u3009 \u21d2 p1\u3009 \u21d2 p2\u3009 \u21d2 r\u3009, p) contains the argument \u3008\u3008\u3008\u3008p\u3009 \u21d2 p1\u3009 \u21d2 p2\u3009 \u21d2 r\u3009 constructible on the basis of the AT (D, {\u22a4, p}).\nRemark 1. If one is interested in reducing the size of Arg\u22a5(AT), one may only allow for minimal disjunctions when generating arguments of type 4. More precisely, where A1 is of the form \u3008B1, . . . , Bm \u2192 \u2228n\ni=1 \u03c8i\u3009 or \u3008B1, . . . , Bm \u21d2 \u2228n\ni=1 \u03c8i\u3009, A = \u3008A1, [A2], . . . , [An] \u03c6\u3009 \u2208 Arg \u22a5(AT) only if there is no\n\u2228\nj\u2208J \u03c8j where J \u2282 {2, . . . , n} for which Conc(B1), . . . , Conc(Bm) \u2192 \u2228 j\u2208J \u03c8j \u2208 S.\nDefinition 4 allows for the construction of arguments containing subarguments the conclusions of which are jointly inconsistent, such as arguments A1 and A2 in the following example, both of which rely on both p and \u00acp in their construction.\nExample 2. Let AT = ({\u22a4 \u21d2 s,\u22a4 \u21d2 p, p\u21d2 \u00acp}, {\u22a4}).\nA0 = \u3008\u3008\u22a4\u3009 \u21d2 p\u3009 A2 = \u3008A0, A1 \u2192 \u00acs\u3009\nA1 = \u3008A0 \u21d2 \u00acp\u3009 A3 = \u3008\u3008\u22a4\u3009 \u21d2 s\u3009\nWhen CL is used as the underlying logic, inconsistent arguments like A1 and A2 may contaminate our formalism by blocking intuitively acceptable arguments like A3. (This is because the conclusions of A2 and A3 are conflicting, causing A2 to attack and exclude A3, cfr. infra.) Contamination problems of this kind have been studied and tackled in ASPIC+ [3, 10]. We can avoid them by filtering out inconsistent arguments.\nDefinition 5. We define \u2020A for an argument A recursively as follows:\n\u2022 \u2020\u3008\u03c6\u3009 = \u03c6\n\u2022 \u2020A = \u03c6 \u2227 \u2020B1 \u2227 . . . \u2227 \u2020Bn where A = \u3008B1, . . . , Bn \u2192 \u03c6\u3009\n\u2022 \u2020A = \u03c6 \u2227 \u2020B1 \u2227 . . . \u2227 \u2020Bn where A = \u3008B1, . . . , Bn \u21d2 \u03c6\u3009\n\u2022 \u2020A = \u03c6 \u2227 \u2020B1 \u2227 (\u2020B2 \u2228 . . . \u2228 \u2020Bn) where A = \u3008B1, [B2], . . . [Bn] \u03c6\u3009.\nDefinition 6. An argument A is inconsistent iff \u2020A \u22a2 \u22a5. Otherwise A is consistent. Relative to AT = (D,F), Arg(AT) is Arg\u22a5(AT) without inconsistent arguments.\nFor arguments without occurrences of our definition of inconsistent arguments is equivalent to that of [10]. In the remainder we will focus on the set Arg(AT) rather than Arg\u22a5(AT), avoiding contamination problems."}, {"heading": "3.2 Attacks", "text": "In ASPIC+, attacks are defined in terms of a generic contrariness operator. We define them in terms of \u2018\u00ac\u2019, so that arguments the conclusions of which are classical contradictories attack each other. We have to be careful when defining argumentative attacks when rbc-arguments are involved, since we must\ntake into account the hypothetical sub-arguments of an rbc-argument. New questions arise here. For instance, an argument\u2019s hypothetical sub-argument may conflict with a non-hypothetical argument.\nExample 3. Let AT = (D,F), with D = {p \u21d2 q \u2228 r; q \u21d2 s; s \u21d2 v; r \u21d2 v; t\u21d2 \u00acs} and F = {p, t}.\nA1 = \u2329 \u3008\u3008p\u3009 \u21d2 q \u2228 r\u3009, [\u3008\u3008q\u3009 \u21d2 s\u3009 \u21d2 v], [\u3008r\u3009 \u21d2 v] v \u232a\nA2 = \u2329 \u3008t\u3009 \u21d2 \u00acs \u232a\nIn Example 3, the non-hypothetical argument A2 is in conflict with the argument \u3008\u3008q\u3009 \u21d2 s\u3009 \u21d2 v, which belongs to A1\u2019s hypothetical sub-argument (\u3008\u3008\u3008q\u3009 \u21d2 s\u3009 \u21d2 v\u3009, q). The desirable outcome in this example is that A2 attacks A1, but not vice versa.\nAs a further illustration, consider the following scenario.\nExample 4. AT = (D,F), with D = {p \u21d2 (q \u2228 r); q \u21d2 s1; s1 \u21d2 s2; s2 \u21d2 v; r \u21d2 v; q \u21d2 \u00acs1} and F = {p}.\nA0 = \u3008\u3008p\u3009 \u21d2 q \u2228 r\u3009\nA1 = \u3008A0, [\u3008\u3008\u3008q\u3009 \u21d2 s1\u3009 \u21d2 s2\u3009 \u21d2 v], [\u3008r\u3009 \u21d2 v] v\u3009\nThe following argument is constructible on the basis of the extended theory AT\u2032 = (D,F \u222a {q}):\nA2 = \u3008\u3008q\u3009 \u21d2 \u00acs1\u3009.\nA1 contains the intermediate conclusion s2 based on the assumption q. However, A2 concludes that \u00acs2 on the basis of the same assumption, q. The desirable outcome in this example is to let A1 and A2 attack each other, since these arguments were both constructed on the basis of our knowledge base plus the assumption that q, and since their conclusions are contradictories.\nTo handle examples like these, we introduce the set HArg(D,F) of all arguments that can be constructed on the basis of some disjunct used in the construction of an rbc-argument in Arg(D,F).\nWhere A is an argument and \u03c6 a formula, \u03c01(A, \u03c6) = A and \u03c02(A, \u03c6) = \u03c6. We lift the definition as usual: where i \u2208 {1, 2}, \u03c0i(\u2206) = {\u03c0i(A, \u03c6) | (A, \u03c6) \u2208 \u2206}.\nWhere \u03c6 \u2208 L\\F , AT = (D,F) and AT\u2032 = (D,F\u222a{\u03c6}), we denote Arg(AT\u2032)\\ Arg(AT) by Arg\u03c6(AT).\nDefinition 7 (Hypothetical Arguments). Where AT = (D,F), HArg(AT) is the set of all A \u2208 Arg\u03c6(AT) such that \u03c6 \u2208 \u03c02(HSub(B)) for some B \u2208 Arg(AT).\nDefinition 8 (Attacks, Rebuts). For a given theory AT, we define a direct attack relation\nAtt(AT) \u2286 (Arg(AT)\u00d7 Arg(AT))\n\u222a (Arg(AT)\u00d7 HArg(AT))\n\u222a (HArg(AT)\u00d7 HArg(AT))\nas follows: A directly attacks B iff B is of the form \u3008. . . \u21d2 Conc(B)\u3009, (Conc(A) = \u00acConc(B) or Conc(B) = \u00acConc(A)), and\n\u2022 A \u2208 Arg(AT) and B \u2208 Arg(AT) or\n\u2022 A \u2208 Arg(AT) and B \u2208 HArg(AT) or\n\u2022 A \u2208 Arg\u03c6(AT) and B \u2208 Arg\u03c6(AT) for some \u03c6 \u2208 L \\ F .\nWe lift the definition recursively in the following way: A attacks B if A directly attacks B or it attacks some C \u2208 (Sub(B) \\ {B}) \u222a \u22c3\n\u03c01(HSub(B)).\nFor an argument A to directly attack an argument B, the following requirements need to be fulfilled: The conclusion of A conflicts with the conclusion of B and (either A is non-hypothetical, or A and B are hypothetical arguments based on the same assumption \u03c6).\nTo illustrate how this works, reconsider our examples. In Example 3, \u3008\u3008q\u3009 \u21d2 s\u3009 \u2208 HArg(AT) and A2 directly attacks \u3008\u3008q\u3009 \u21d2 s\u3009, so A2 attacks A1 (but not vice versa). In Example 4 the arguments \u3008\u3008q\u3009 \u21d2 s1\u3009 and A2 are in Argq(AT), so these arguments directly attack each other. Consequently, A2 also attacks A1."}, {"heading": "3.3 Consequence relations", "text": "Definition 9. The structured argumentation framework (in short, SAF) defined by the theory AT is the pair (Arg(AT) \u222a HArg(AT), Att(AT)).\nGiven a SAF, we can use the argumentation semantics from Section 2 to define consequence relations:\nDefinition 10. Let SAF = (Arg(AT) \u222a HArg(AT), Att(AT)), let sem \u2208 {Cmp,Prf,Grd}, and let Cmp(SAF), Prf(SAF), and Grd(SAF) denote the sets of SAF\u2019s complete extensions, SAF\u2019s preferred extensions, and SAF\u2019s grounded extension respectively. \u2022 SAF |\u223c\u2229 sem\n\u03c6 iff for every B \u2208 sem(SAF) there is an A \u2208 B \u2229 Arg(AT) with conc(A) = \u03c6.\n\u2022 SAF |\u223c\u22d3 sem \u03c6 iff there is a B \u2208 \u22c2 sem(SAF) \u2229 Arg(AT) with conc(A) = \u03c6. Since the grounded extension is unique both definitions coincide for sem = Grd.\nRelative to a theory AT, the \u2018virtual\u2019 arguments in HArg(AT) are capable of attacking arguments in Arg(AT) (in their hypothetical subarguments), and consequently of preventing the derivability of conclusions of arguments in Arg(AT). However, the conclusions of virtual arguments are never themselves derivable from AT."}, {"heading": "3.4 Rationality postulates", "text": "In [2, 3] several postulates were proposed to evaluate formalisms for structured argumentation. In the present context these postulates read as follows. Given a SAF (Arg(AT) \u222a HArg(AT), Att(AT)) where E \u2208 Cmp(SAF):2\n2The proofs of these properties are to be found in the technical appendix as indicated below, except for te proof of non-interference which we omit due to space restrictions. The authors in [2] distinguish between direct and indirect consistency: in our framework these definitions are equivalent since our strict rules are closed under CL.\nSub-argument closure: where A \u2208 E , Sub(A) \u2286 E (immediate in view of Theorem 1)\nClosure under strict rules: where A1, . . . , An \u2208 E \u2229 Arg(AT) and Conc(A1), . . . ,Conc(An) \u22a2 B also \u3008A1, . . . , An \u2192 B\u3009 \u2208 E \u2229 Arg(AT) (see Theorem 2),\nConsistency: {Conc(A) | A \u2208 E \u2229 Arg(AT)} is consistent (see Theorem 3),\nNon-interference: Let Atoms(F) [Atoms(D)] be the set of all atoms occurring in F [D]. Where AT = (D,F), AT\u2032 = (D \u222a D\u2032,F \u222a F \u2032), SAF = (Arg(AT) \u222a HArg(AT), Att(AT)), SAF\u2032 = (Arg(AT\u2032) \u222a HArg(AT), Att(AT\u2032)), |\u223c \u2208 {|\u223c\u2229\nGrd , |\u223c\u22d3 Grd , |\u223c\u2229 Prf , |\u223c\u22d3 Prf }, Atoms(\u03c6) \u2286 Atoms(D) \u222a Atoms(F), and\n(Atoms(D) \u222a Atoms(F)) \u2229 (Atoms(D\u2032) \u222a Atoms(F \u2032)) = \u2205, we have:\nSAF |\u223c\u03c6 iff SAF\u2032 |\u223c\u03c6.\nThe property of non-interference can be used to show that the present framework avoids contamination problems of the kind discussed in Section 3.1 (see [3, 10])."}, {"heading": "4 Related work", "text": ""}, {"heading": "4.1 Disjunctive Defaults", "text": "In [5] a generalization of default logic, disjunctive default logic, is proposed that is more apt to deal with disjunctions than Reiter\u2019s original approach. For instance, given the default theory with p\u2228 q and the defaults p\u21d2 r and q \u21d2 r, r is not a default consequence in Reiter\u2019s approach since the only extension of this theory is Cn(p \u2228 q). In disjunctive default logic, an alternative disjunction | is available: p | q enforces that p or q is in any extension of the theory. So, for the default theory consisting of p | q, and the defaults p\u21d2 r and q \u21d2 r we have two extensions, Cn({p, r}) and Cn({q, r}). Now r is a skeptical consequence. Default consequents can also make use of |: a disjunctive default is of the form:\n\u03c6 : \u03c81, . . . , \u03c8n \u03b31 | . . . | \u03b3m\nwhere \u03c6 is the prerequisite, \u03c81, . . . , \u03c8n are justifications, and \u03b31, . . . , \u03b3m are consequents of the default. A set of formulas \u039e is an extension of a disjunctive default theory consisting of the disjunctive defaults in \u2206 (we here follow the convention in [5] according to which \u2019facts\u2019 are considered as disjunctive defaults with empty prerequisite and empty justification) if it satisfies the following requirements: (i) for any \u03c6:\u03c81,...,\u03c8n\n\u03b31|...|\u03b3m \u2208 \u2206, if \u03c6 \u2208 \u039e and \u00ac\u03c81, . . . ,\u00ac\u03c8n /\u2208 \u039e then\n\u03b3i \u2208 \u039e for some 1 \u2264 i \u2264 m, (ii) Cn(\u039e) = \u039e, and (iii) \u039e is minimal with properties (i) and (ii).3\n3This definition in [5] is suboptimal in that it gives undesired results: e.g. for the theory\n\u2206 = {\u22a4 : \u00acp \u00acp } also Cn(p) will form an extension. The problem can easily be fixed though by defining extensions analogous to Reiter.\nWe compare our approach to disjunctive default logic by thinking of \u21d2 as a default conditional: \u03c8 \u21d2 \u03c6 encodes the normal default \u03c8:\u03c6\n\u03c6 . We start\nour comparison with the example given above. Let \u22061 = {p | q, p \u21d2 r, q \u21d2 r}. \u22061 has two extensions, Cn({p, r}) and Cn({q, r}) and so r is a skeptical consequence. This outcome corresponds to our approach for the theory AT1 = ({p \u21d2 r, q \u21d2 r}, {p \u2228 q}): the argument \u3008\u3008p \u2228 q\u3009, [\u3008p\u3009 \u21d2 r], [\u3008q\u3009 \u21d2 r] r\u3009 is in all complete extensions of AT1.\nNext, consider Poole\u2019s broken arm example [9]. Let l be \u201chaving a left broken arm\u201d, r \u201chaving a right broken arm\u201d, w \u201cwriting legibly\u201d. On our approach, the theory ATarm = ({w \u21d2 \u00acr}, {l\u2228r, w}) gives rise to the argument \u3008\u3008\u3008w\u3009 \u21d2 \u00acr\u3009, \u3008l \u2228 r\u3009 \u2192 l\u3009, which is in all complete extensions of ATarm. In contrast, the disjunctive default theory \u2206arm = {l | r, w, w \u21d2 \u00acr} has two extensions Cn({l, w,\u00acr}) and Cn({r, w}). Since l /\u2208 Cn({r, w}), l is not a skeptical consequence in disjunctive default logic.\nFinally, reconsider the AT from Example 3. There are various ways in which we can translate this AT into a disjunctive default theory, e.g.4\n\u22063 =\n{\np : q \u2228 r q | r , q : s s , s : v v , r : v v , t : \u00acs \u00acs , p, t\n}\nFor \u22063 we have the extensions Cn({p, t, q, s, v}), Cn({p, t, q,\u00acs}), and Cn({p, t,\u00acs, r, v}), so v is not a skeptical consequence. This corresponds to our approach in which the argument A1 from Example 3 is excluded due to the attack by A2. However, on our approach A2 is in all complete extensions, so contrary to disjunctive default logic we obtain \u00acs as a skeptical consequence."}, {"heading": "4.2 The OR meta-rule", "text": "A different approach for dealing with disjunctive information is to allow for inference rules that produce new conditionals from given conditionals. We, for instance, find the following rule in system P [6] and in several Input/Output logics [7]:\n\u03c8 \u21d2 \u03c6 \u03c8\u2032 \u21d2 \u03c6\n\u03c8 \u2228 \u03c8\u2032 \u21d2 \u03c6 [OR]\nOne could define an ASPIC+-like system where arguments are constructed as in rules 1\u20133 in Definition 4, and in which the defeasible rules are closed under OR. For instance, given AT1 from Section 4.1 this allows to derive p \u2228 q \u21d2 r from p\u21d2 r and q \u21d2 r, so that we can construct the argument \u3008p \u2228 q\u3009 \u21d2 r and obtain r as a consequence.\nAdding OR is not sufficient to always get the intuitive outcome. Let AT4 = ({p \u21d2 q \u2228 r, q \u21d2 s, s \u21d2 v, r \u21d2 u, u \u21d2 v}, {p}). One would want to build an argument for v, but we cannot put OR to much use (except for deriving s \u2228 u \u21d2 v). We would have to combine OR with e.g. right-weakening (RW:\n4Our discussion also applies if we translate p \u21d2 q \u2228 r by p : q\u2227r q|r .\n\u03c8\u22a2\u03c6 \u03c8\u2032\u21d2\u03c8 \u03c8\u2032\u21d2\u03c6 ), or generalize OR to\n\u03c8 \u21d2 \u03c6 \u03c8\u2032 \u21d2 \u03c6\u2032 \u03c8 \u2228 \u03c8\u2032 \u21d2 \u03c6 \u2228 \u03c6\u2032 [gOR]\nin order to produce q \u2228 r \u21d2 s \u2228 u. Since also s \u2228 u \u21d2 v \u2228 v can be derived, we now have the means to construct the argument \u3008\u3008\u3008p \u21d2 q \u2228 r\u3009 \u21d2 s \u2228 u\u3009 \u21d2 v \u2228 v\u3009 \u2192 v. In many systems of nonmonotonic logic, e.g. in system P and in many Input/Output logics, OR and RW are available (and thus gOR is a derived rule). We now contrast our approach with such (g)OR-based approaches.\nA striking difference concerns the handling of Example 3. In the gOR-based system we can construct:\nA3 = \u3008\u3008\u3008p\u21d2 q \u2228 r\u3009 \u21d2 s \u2228 v\u3009 \u21d2 v \u2228 v\u3009 \u2192 v\nThis argument is not attacked by the argument t \u21d2 \u00acs. An alternative argument for v is given by \u3008t\u21d2 \u00acs\u3009, \u3008\u3008p \u21d2 q\u2228r\u3009 \u21d2 s\u2228v\u3009 \u2192 v. Recall that neither in our approach nor in disjunctive default logic v is a skeptical consequence. Even if we add \u00acr to the knowledge base F in Example 3, v remains derivable in the gOR-based approach since A3 remains unchallenged. This is counter-intuitive: both the argumentative path via q \u21d2 s\u21d2 v and the path via r \u21d2 v are barred in view of the unchallenged arguments t \u21d2 \u00acs and \u00acr. An advantage of using the reasoning-by-cases rule 4 in Definition 4 is that it provides more fine-grained ways of tracking commitments in sub-arguments. This enables us to block the undesired consequence v in this example.5"}, {"heading": "5 Conclusion and outlook", "text": "The ideas developed in this paper offer many interesting avenues for further work, partially consisting of the removal of the limitations assumed in this paper. For example, we did not consider nested rbc-arguments or various components that can be modelled in the ASPIC+-framework such as defeasible premises, undermining or undercut attacks. We also plan to present a less cautious variation of this framework where an attack on an rbc-argument A, [B1], . . . , [Bn] \u03c8 succeeds only if each of the Bi\u2019s is attacked. In addition we will investigate prioritized default rules in this framework. Here too, new questions arise. Consider, for instance, an argument \u3008p \u2228 q\u3009, [\u3008\u3008p\u3009 \u21d2 s\u3009 \u21d2 t], [\u3008q\u3009 \u21d2 t] t. If in addition there is an argument \u3008\u22a4\u3009 \u21d2 \u00acs which is preferred over \u3008p\u3009 \u21d2 s, then it seems intuitive to let the former attack the latter argument. But what if the hypothetical argument \u3008p\u3009 \u21d2 s has a higher degree of priority than the non-hypothetical \u3008\u22a4\u3009 \u21d2 \u00acs? Should we decide in favor of the highest priority assigned, or should we never let a hypothetical argument attack a non-hypothetical one? More generally, how do we lift the priorities assigned to the (hypothetical and non-hypothetical) constituents of an rbc-argument? Difficult questions like\n5An additional advantage is that argument strength can be tracked in a more fine-grained way when using RbC in contrast to OR-based approaches. See also Section 5.\nthese will have to be answered in order to resolve conflicts between prioritized rbc-arguments.\nIn future work we also plan to investigate the use of an ordered disjunction \u2190\u2212 \u2228 (see, e.g., [1]). For instance, a rule p \u21d2 q \u2190\u2212 \u2228 r can be read as: \u2018If p then plausibly q or r, where q is more plausible than r\u2019. This is especially interesting when measures of argument strength are considered and when thinking about defeat of rbc-arguments based on ordered disjunctions such as \u3008\u3008q \u2190\u2212 \u2228 r\u3009, [q \u21d2 s], [r \u21d2 s] s\u3009."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "We extend the ASPIC framework for structured argumentation so<lb>as to allow applications of the reasoning by cases inference scheme for<lb>defeasible arguments. Given an argument with conclusion \u2018A or B\u2019, an<lb>argument based on A with conclusion C, and an argument based on B<lb>with conclusion C, we allow the construction of an argument with con-<lb>clusion C. We show how our framework leads to different results than<lb>other approaches in non-monotonic logic for dealing with disjunctive in-<lb>formation, such as disjunctive default theory or approaches based on the<lb>OR-rule (which allows to derive a defeasible rule \u2018If (A or B) then C\u2019,<lb>given two defeasible rules \u2018If A then C\u2019 and \u2018If B then C\u2019). We raise new<lb>questions regarding the subtleties of reasoning defeasibly with disjunctive<lb>information, and show that its formalization is more intricate than one<lb>would presume.", "creator": "LaTeX with hyperref package"}}}