{"id": "1704.06036", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Apr-2017", "title": "End-to-end representation learning for Correlation Filter based tracking", "abstract": "the weighted correlation filter is an algorithm mechanic that trains a linear function template to discriminate between images and their intrinsic translations. it consequently is well suited to object tracking because its formulation in the fourier domain provides a fast solution, enabling the detector to be re - trained once per frame. our previous works that use the correlation filter, however, have adopted features that were either manually designed or trained for a different task. this work is the first to overcome this limitation by interpreting the correlation filter learner, which has a closed - form solution, as a differentiable layer in a deep neural network. this capability enables intuitive learning deep mathematical features that are tightly coupled to the correlation filter. experiments illustrate that our intrinsic method has the important practical benefit of allowing lightweight architectures to achieve state - of - the - art performance at high framerates.", "histories": [["v1", "Thu, 20 Apr 2017 07:51:27 GMT  (2976kb,D)", "http://arxiv.org/abs/1704.06036v1", "To appear at CVPR 2017"]], "COMMENTS": "To appear at CVPR 2017", "reviews": [], "SUBJECTS": "cs.CV cs.LG", "authors": ["jack valmadre", "luca bertinetto", "jo\\~ao f henriques", "rea vedaldi", "philip h s torr"], "accepted": false, "id": "1704.06036"}, "pdf": {"name": "1704.06036.pdf", "metadata": {"source": "CRF", "title": "End-to-end representation learning for Correlation Filter based tracking", "authors": ["Jack Valmadre", "Luca Bertinetto", "Jo\u00e3o F. Henriques", "Andrea Vedaldi", "Philip H. S. Torr"], "emails": ["name.surname@eng.ox.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "Deep neural networks are a powerful tool for learning image representations in computer vision applications. However, training deep networks online, in order to capture previously unseen object classes from one or few examples,\n\u2217Equal first authorship.\nis challenging. This problem emerges naturally in applications such as visual object tracking, where the goal is to re-detect an object over a video with the sole supervision of a bounding box at the beginning of the sequence. The main challenge is the lack of a-priori knowledge of the target object, which can be of any class.\nThe simplest approach is to disregard the lack of a-priori knowledge and adapt a pre-trained deep convolutional neural network (CNN) to the target, for example by using stochastic gradient descent (SGD), the workhorse of deep network optimization [32, 26, 36]. The extremely limited training data and large number of parameters make this a difficult learning problem. Furthermore, SGD is quite expensive for online adaptation [32, 26].\nA possible answer to these shortcomings is to have no online adaptation of the network. Recent works have focused on learning deep embeddings that can be used as universal object descriptors [3, 13, 29, 18, 5]. These methods use a Siamese CNN, trained offline to discriminate whether two image patches contain the same object or not. The idea is that a powerful embedding will allow the detection (and thus tracking) of objects via similarity, bypassing the online learning problem. However, using a fixed metric to compare appearance prevents the learning algorithm from exploiting any video-specific cues that could be helpful for discrimination.\nAn alternative strategy is to use instead an online learn-\nar X\niv :1\n70 4.\n06 03\n6v 1\n[ cs\ning method such as the Correlation Filter (CF). The CF is an efficient algorithm that learns to discriminate an image patch from the surrounding patches by solving a large ridge regression problem extremely efficiently [4, 14]. It has proved to be highly successful in object tracking (e.g. [6, 19, 23, 2]), where its efficiency enables a tracker to adapt its internal model of the object on the fly at every frame. It owes its speed to a Fourier domain formulation, which allows the ridge regression problem to be solved with only a few applications of the Fast Fourier Transform (FFT) and cheap element-wise operations. Such a solution is, by design, much more efficient than an iterative solver like SGD, and still allows the discriminator to be tailored to a specific video, contrary to the embedding methods.\nThe challenge, then, is to combine the online learning efficiency of the CF with the discriminative power of CNN features trained offline. This has been done in several works (e.g. [22, 7, 9, 32]), which have shown that CNNs and CFs are complementary and their combination results in improved performance.\nHowever, in the aforementioned works, the CF is simply applied on top of pre-trained CNN features, without any deep integration of the two methods. End-to-end training of deep architectures is generally preferable to training individual components separately. The reason is that in this manner the free parameters in all components can co-adapt and cooperate to achieve a single objective. Thus it is natural to ask whether a CNN-CF combination can also be trained end-to-end with similar benefits.\nThe key step in achieving such integration is to interpret the CF as a differentiable CNN layer, so that errors can be propagated through the CF back to the CNN features. This is challenging, because the CF itself is the solution of a learning problem. Hence, this requires to differentiate the solution of a large linear system of equations. This paper provides a closed-form expression for the derivative of the Correlation Filter. Moreover, we demonstrate the practical utility of our approach in training CNN architectures endto-end.\nWe present an extensive investigation into the effect of incorporating the CF into the fully-convolutional Siamese framework of Bertinetto et al. [3]. We find that the CF does not improve results for networks that are sufficiently deep. However, our method enables ultra-lightweight networks of a few thousand parameters to achieve state-of-theart performance on multiple benchmarks while running at high framerates.\nCode and results are available online 1.\n1www.robots.ox.ac.uk/\u02dcluca/cfnet.html"}, {"heading": "2. Related work", "text": "Since the seminal work of Bolme et al. [4], the Correlation Filter has enjoyed great popularity within the tracking community. Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27]. For the sake of simplicity, in this work we adopt the basic formulation of the Correlation Filter.\nRecently, several methods based on Siamese networks have been introduced [29, 13, 3], raising interest in the tracking community for their simplicity and competitive performance. For our method, we prefer to build upon the fully-convolutional Siamese architecture [3], as it enforces the prior that the appearance similarity function should commute with translation.\nAt its core, the Correlation Filter layer that we introduce amounts to computing the solution to a regularized deconvolution problem, not to be confused with upsampling convolution layers that are sometimes referred to as \u201cdeconvolution layers\u201d [21]. Before it became apparent that algorithms such as SGD are sufficient for training deep networks, Zeiler et al. [35] introduced a deep architecture in which each layer solves a convolutional sparse coding problem. In contrast, our problem has a closed-form solution since the Correlation Filter employs quadratic regularization rather than 1-norm regularization.\nThe idea of back-propagating gradients through the solution to an optimization problem during training has been previously investigated. Ionescu et al. [15] and Murray [25] have presented back-propagation forms for the SVD and Cholesky decomposition respectively, enabling gradient descent to be applied to a network that computes the solution to either a system of linear equations or an eigenvalue problem. Our work can be understood as an efficient backpropagation procedure through the solution to a system of linear equations, where the matrix has circulant structure.\nWhen the solution to the optimization problem is obtained iteratively, an alternative is to treat the iterations as a Recurrent Neural Network, and to explicitly unroll a fixed number of iterations [37]. Maclaurin et al. [24] go further and back-propagate gradients through an entire SGD learning procedure, although this is computationally demanding and requires judicious bookkeeping. Gould et al. [11] have recently considered differentiating the solution to general argmin problems without restricting themselves to iterative procedures. However, these methods are unnecessary in the case of the Correlation Filter, as it has a closed-form solution.\nBack-propagating through a learning algorithm invites a comparison to meta-learning. Recent works [31, 1] have proposed feed-forward architectures that can be interpreted as learning algorithms, enabling optimization by gradient\ndescent. Rather than adopt an abstract definition of learning, this paper propagates gradients through a conventional learning problem that is already widely used."}, {"heading": "3. Method", "text": "We briefly introduce a framework for learning embeddings with Siamese networks (Section 3.1) and the use of such an embedding for object tracking (Section 3.2) before presenting the CFNet architecture (Section 3.3). We subsequently derive the expressions for evaluation and backpropagation of the main new ingredient in our networks, the Correlation Filter layer, which performs online learning in the forward pass (Section 3.4)."}, {"heading": "3.1. Fully-convolutional Siamese networks", "text": "Our starting point is a network similar to that of [3], which we later modify in order to allow the model to be interpreted as a Correlation Filter tracker. The fullyconvolutional Siamese framework considers pairs (x\u2032, z\u2032) comprising a training image x\u2032 and a test image z\u20322. The image x\u2032 represents the object of interest (e.g. an image patch centered on the target object in the first video frame), while z\u2032 is typically larger and represents the search area (e.g. the next video frame).\nBoth inputs are processed by a CNN f\u03c1 with learnable parameters \u03c1. This yields two feature maps, which are then cross-correlated:\ng\u03c1(x \u2032, z\u2032) = f\u03c1(x \u2032) ? f\u03c1(z \u2032) . (1)\nEq. 1 amounts to performing an exhaustive search of the pattern x\u2032 over the test image z\u2032. The goal is for the maximum value of the response map (left-hand side of eq. 1) to correspond to the target location.\nTo achieve this goal, the network is trained offline with millions of random pairs (x\u2032i, z \u2032 i) taken from a collection of videos. Each example has a spatial map of labels ci with values in {\u22121, 1}, with the true object location belonging to the positive class and all others to the negative class. Training proceeds by minimizing an element-wise logistic loss ` over the training set:\nargmin \u03c1 \u2211 i ` (g\u03c1(x \u2032 i, z \u2032 i), ci) . (2)"}, {"heading": "3.2. Tracking algorithm", "text": "The network itself only provides a function to measure the similarity of two image patches. To apply this network to object tracking, it is necessary to combine this with a procedure that describes the logic of the tracker. Similar\n2Note that this differs from [3], in which the target object and search area were instead denoted z and x respectively.\nto [3], we employ a simplistic tracking algorithm to assess the utility of the similarity function.\nOnline tracking is performed by simply evaluating the network in forward-mode. The feature representation of the target object is compared to that of the search region, which is obtained in each new frame by extracting a window centred at the previously estimated position, with an area that is four times the size of the object. The new position of the object is taken to be the location with the highest score.\nThe original fully-convolutional Siamese network simply compared every frame to the initial appearance of the object. In contrast, we compute a new template in each frame and then combine this with the previous template in a moving average."}, {"heading": "3.3. Correlation Filter networks", "text": "We propose to modify the baseline Siamese network of eq. 1 with a Correlation Filter block between x and the cross-correlation operator. The resulting architecture is illustrated in Figure 1. This change can be formalized as:\nh\u03c1,s,b(x \u2032, z\u2032) = s \u03c9 (f\u03c1(x \u2032)) ? f\u03c1(z \u2032) + b (3)\nThe CF block w = \u03c9(x) computes a standard CF template w from the training feature map x = f\u03c1(x\u2032) by solving a ridge regression problem in the Fourier domain [14]. Its effect can be understood as crafting a discriminative template that is robust against translations. It is necessary to introduce scalar parameters s and b (scale and bias) to make the score range suitable for logistic regression. Offline training is then performed in the same way as for a Siamese network (Section 3.1), replacing g with h in eq. 2.\nWe found that it was important to provide the Correlation Filter with a large region of context in the training image, which is consistent with the findings of Danelljan et al. [8] and Kiani et al. [16]. To reduce the effect of circular boundaries, the feature map x is pre-multiplied by a cosine window [4] and the final template is cropped [30].\nNotice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7]. However, these earlier networks were not trained end-to-end. The novelty is to compute the derivative of the CF template with respect to its input so that a network incorporating a CF can be trained end-to-end."}, {"heading": "3.4. Correlation Filter", "text": "We now show how to back-propagate gradients through the Correlation Filter solution efficiently and in closed form via the Fourier domain.\nFormulation. Given a scalar-valued image x \u2208 Rm\u00d7m, the Correlation Filter is the template w \u2208 Rm\u00d7m whose inner product with each circular shift of the image x \u2217 \u03b4\u2212u is\nas close as possible to a desired response y[u] [14], minimizing\u2211\nu\u2208U (\u3008x \u2217 \u03b4\u2212u, w\u3009 \u2212 y[u])2 = \u2016w ? x\u2212 y\u20162 . (4)\nHere, U = {0, . . . ,m \u2212 1}2 is the domain of the image, y \u2208 Rm\u00d7m is a signal whose u-th element is y[u], and \u03b4\u03c4 is the translated Dirac delta function \u03b4\u03c4 [t] = \u03b4[t \u2212 \u03c4 ]. In this section, we use \u2217 to denote circular convolution and ? to denote circular cross-correlation. Recall that convolution with the translated \u03b4 function is equivalent to translation (x \u2217 \u03b4\u03c4 )[t] = x[t\u2212 \u03c4 mod m]. Incorporating quadratic regularization to prevent overfitting, the problem is to find\nargmin w\n1 2n \u2016w ? x\u2212 y\u20162 + \u03bb 2 \u2016w\u20162 (5)\nwhere n = |U| is the effective number of examples. The optimal template w must satisfy the system of equations (obtained via the Lagrangian dual, see Appendix C, supplementary material) k = 1n (x ? x) + \u03bb\u03b4\nk \u2217 \u03b1 = 1ny w = \u03b1 ? x\n(6)\nwhere k can be interpreted as the signal that defines a circulant linear kernel matrix, and \u03b1 is a signal comprised of the Lagrange multipliers of a constrained optimization problem that is equivalent to eq. 5. The solution to eq. 6 can be computed efficiently in the Fourier domain [14], k\u0302 = 1n (x\u0302 \u2217 \u25e6 x\u0302) + \u03bb1 \u03b1\u0302 = 1n k\u0302 \u22121 \u25e6 y\u0302\nw\u0302 = \u03b1\u0302\u2217 \u25e6 x\u0302\n(7a)\n(7b) (7c)\nwhere we use x\u0302 = Fx to denote the Discrete Fourier Transform of a variable, x\u2217 to denote the complex conjugate, \u25e6 to denote element-wise multiplication and 1 to denote a signal of ones. The inverse of element-wise multiplication is element-wise scalar inversion. Notice that the operations in eq. 7 are more efficiently computed in the Fourier domain, since they involve element-wise operations instead of more expensive convolutions or matrix operators (eq. 6). Moreover, the inverse convolution problem (to find \u03b1 such that k \u2217 \u03b1 = 1ny) is the solution to a diagonal system of equations in the Fourier domain (eq. 7b).\nBack-propagation. We adopt the notation that if x \u2208 X = Rn is a variable in a computational graph that computes a final scalar loss ` \u2208 R, then \u2207x` \u2208 X denotes the vector of partial derivatives (\u2207x`)i = \u2202`/\u2202xi. If y \u2208 Y = Rm is another variable in the graph, which is\ncomputed directly from x according to y = f(x), then the so-called back-propagation map for the function f is a linear map from\u2207y` \u2208 Y to\u2207x` \u2208 X .\nAppendix D gives a tutorial review of the mathematical background. In short, the back-propagation map is the linear map which is the adjoint of the differential. This property was used by Ionescu et al. [15] to compute backpropagation maps using matrix differential calculus. While they used the matrix inner product \u3008X,Y \u3009 = tr(XTY ) to find the adjoint, we use Parseval\u2019s theorem, which states that the Fourier transform is unitary (except for a scale factor) and therefore preserves inner products \u3008x, y\u3009 \u221d \u3008x\u0302, y\u0302\u3009.\nTo find the linear map for back-propagation through the Correlation Filter, we first take the differentials of the system of equations in eq. 6 that defines the template w dk = 1n (dx ? x+ x ? dx)\ndk \u2217 \u03b1+ k \u2217 d\u03b1 = 1ndy dw = d\u03b1 ? x+ \u03b1 ? dx\n(8)\nand then take the Fourier transform of each equation and rearrange to give the differential of each dependent variable in Figure 2 as a linear function (in the Fourier domain) of the differentials of its input variables d\u0302k = 1n (d\u0302x \u2217 \u25e6 x\u0302+ x\u0302\u2217 \u25e6 d\u0302x) d\u0302\u03b1 = k\u0302\u22121 \u25e6 [ 1 n d\u0302y \u2212 d\u0302k \u25e6 \u03b1\u0302 ] d\u0302w = d\u0302\u03b1 \u2217 \u25e6 x\u0302+ \u03b1\u0302\u2217 \u25e6 d\u0302x . (9a) (9b) (9c)\nNote that while these are complex equations, that is simply because they are the Fourier transforms of real equations. The derivatives themselves are all computed with respect to real variables.\nThe adjoints of these linear maps define the overall backpropagation map from \u2207w` to \u2207x` and \u2207y`. We defer the derivation to Appendix B and present here the final result, \u2207\u0302\u03b1` = x\u0302 \u25e6 (\u2207\u0302w`)\u2217 \u2207\u0302y` = 1n k\u0302 \u2212\u2217 \u25e6 \u2207\u0302\u03b1` \u2207\u0302k` = \u2212k\u0302\u2212\u2217 \u25e6 \u03b1\u0302\u2217 \u25e6 \u2207\u0302\u03b1`\n\u2207\u0302x` = \u03b1\u0302 \u25e6 \u2207\u0302w`+ 2n x\u0302 \u25e6 Re{\u2207\u0302k`} .\n(10)\nIt is necessary to compute forward Fourier transforms at the start and inverse transforms at the end. The extension to multi-channel images is trivial and given in Appendix E (supplementary material).\nAs an interesting aside, we remark that, since we have the gradient of the loss with respect to the \u201cdesired\u201d response y, it is actually possible to optimize for this parameter rather than specify it manually. However, in practice we did not find learning this parameter to improve the tracking accuracy compared to the conventional choice of a fixed Gaussian response [4, 14]."}, {"heading": "4. Experiments", "text": "The principal aim of our experiments is to investigate the effect of incorporating the Correlation Filter during training. We first compare against the symmetric Siamese architecture of Bertinetto et al. [3]. We then compare the endto-end trained CFNet to a variant where the features are replaced with features that were trained for a different task. Finally, we demonstrate that our method achieves state-ofthe-art results."}, {"heading": "4.1. Evaluation criteria", "text": "Popular tracking benchmarks like VOT [17] and OTB [33, 34] have made all ground truth annotations available and do not enforce a validation/test split. However, in order to avoid overfitting to the test set in design choices and hyperparameter selection, we consider OTB-2013, OTB-50 and OTB-100 as our test set and 129 videos from VOT2014, VOT-2016 and Temple-Color [20] as our validation set, excluding any videos which were already assigned to the test set. We perform all of our tracking experiments in Sections 4.2, 4.3 and 4.4 on the validation set with the same set of \u201cnatural\u201d hyperparameters, which are reasonable for all methods and not tuned for any particular method.\nAs in the OTB benchmark [33, 34], we quantify the performance of the tracker on a sequence in terms of the average overlap (intersection over union) of the predicted and ground truth rectangles in all frames. The success rate of a tracker at a given threshold \u03c4 corresponds to the fraction of frames in which the overlap with the ground truth is at least \u03c4 . This is computed for a uniform range of 100 thresholds between 0 and 1, effectively constructing the cumulative distribution function. Trackers are compared using the area under this curve.\nMimicking the TRE (Temporal Robustness Evaluation) mode of OTB, we choose three equispaced points per sequence and run the tracker from each until the end. Differently from the OTB evaluation, when the target is lost (i.e. the overlap with the ground truth becomes zero) the tracker is terminated and an overlap of zero is reported for all remaining frames.\nDespite the large number of videos, we still find that the performance of similarity networks varies considerably as training progresses. To mitigate this effect, we average the final tracking results that are obtained using the parameters of the network at epochs 55, 60, . . . , 95, 100 (the final epoch) to reduce the variance. These ten results are used to estimate the standard deviation of the distribution of results, providing error bars for most figures in this section. While it would be preferable to train all networks to convergence multiple times with different random seeds, this would require significantly more resources."}, {"heading": "4.2. Comparison to Siamese baseline", "text": "Figures 3 and 4 compare the accuracy of both methods on the validation set for networks of varying depth. The feature extraction network of depth n is terminated after the n-th linear layer, including the following ReLU but not the following pooling layer (if any).\nOur baseline diverges slightly from [3] in two ways. Firstly, we reduce the total stride of the network from 8 to 4 (2 at conv1, 2 at pool1) to avoid training Correlation Filters with small feature maps. Secondly, we always restrict the final layer to 32 output channels in order to preserve the high speed of the method with larger feature maps. These changes did not have a negative effect on the tracking performance of SiamFC.\nThe results show that CFNet is significantly better than the baseline when shallow networks are used to compute features. Specifically, it brings a relative improvement of 31% and 13% for networks of depth one and two respectively. At depths three, four and five, the difference is much less meaningful. CFNet is relatively unaffected by the depth of the network, whereas the performance of the baseline increases steadily and significantly with depth. It seems that the ability of the Correlation Filter to adapt the distance\nmetric to the content of the training image is less important given a sufficiently expressive embedding function.\nThe CF layer can be understood to encode prior knowledge of the test-time procedure. This prior may become redundant or even overly restrictive when enough model capacity and data are available. We believe this explains the saturation of CFNet performance when more than two convolutional layers are used.\nFigure 4 additionally shows that updating the template is always helpful, for both Baseline and CFNet architectures, at any depth."}, {"heading": "4.3. Feature transfer experiment", "text": "The motivation for this work was the hypothesis that incorporating the CF during training will result in features that are better suited to tracking with a CF. We now compare our end-to-end trained CFNet to variants that use features from alternative sources: Baseline+CF and ImageNet+CF. The results are presented in Figure 5.\nTo obtain the curve Baseline+CF we trained a baseline Siamese network of the desired depth and then combined\nthose features with a CF during tracking. Results show that taking the CF into account during offline training is critical at depth one and two. However, it seems redundant when more convolutional layers are added, since using features from the Baseline in conjunction with the CF achieves similar performance.\nThe ImageNet+CF variant employs features taken from a network trained to solve the ImageNet classification challenge [28]. The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment. The particularly poor performance of these features at deeper layers is somewhat unsurprising, since these layers are expected to have greater invariance to position when trained for classification."}, {"heading": "4.4. Importance of adaptation", "text": "For a multi-channel CF, each channel p of the templatew can be obtained as wp = \u03b1?xp, where \u03b1 is itself a function of the exemplar x (Appendix C, supplementary material). To verify the importance of the online adaptation that solv-\ning a ridge regression problem at test time should provide, we propose a \u201cconstant\u201d version of the Correlation Filter (CFNet-const) where the vector of Lagrange multipliers \u03b1 is instead a parameter of the network that is learned offline and remains fixed at test time.\nFigure 6 compares CFNet to its constant variant. CFNet is consistently better, demonstrating that in order to improve over the baseline Siamese network it is paramount to backpropagate through the solution to the inverse convolution problem that defines the Lagrange multipliers."}, {"heading": "4.5. Comparison with the state-of-the-art", "text": "We use the OTB-2013/50/100 benchmarks to confirm that our results are on par with the state-of-theart. All numbers in this section are obtained using the OTB toolkit [33]. We report the results for the three best instantiations of CFNet from Figure 5 (CFNet-conv2, CFNet-conv5, Baseline+CF-conv3), the best variant of the baseline (Baseline-conv5) and the most promising singlelayer network (CFNet-conv1). We compare our methods against state-of-the-art trackers that can operate in realtime: SiamFC-3s [3], Staple [2] and LCT [23]. We also include the recent SAMF [19] and DSST [6] for reference.\nFor the evaluation of this section, we use a different set of tracking hyperparameters per architecture, chosen to maximize the performance on the validation set after a random search of 300 iterations. More details are provided in the supplementary material. For the few greyscale sequences present in OTB, we re-train each architecture using exclusively greyscale images.\nBoth overlap (IoU) and precision scores [34] are reported for OPE (one pass) and TRE (temporal robustness) evaluations. For OPE, the tracker is simply run once on each sequence, from the start to the end. For TRE, the tracker is instead started from twenty different starting points, and run until the end from each. We observed that this ensures more robust and reliable results compared to OPE.\nSimilarly to the analysis on the validation set, CFNetconv2 is among the top performers and its accuracy rivals that of Baseline-conv5, which possesses approximately 30\u00d7 as many parameters. In general, our best proposed CFNet variants are superior (albeit modestly) to the state-of-theart. In order to focus on the impact of our contribution, we decided to avoid including orthogonal improvements which can often be found in the tracking literature (e.g. bounding box regression [26], ensembling of multiple cues [23, 2], optical flow [29])."}, {"heading": "4.6. Speed and practical benefits", "text": "The previous sections have demonstrated that there is a clear benefit to integrating Correlation Filters into Siamese networks when the feature extraction network is relatively\nshallow. Shallow networks are practically advantageous in that they require fewer operations and less memory to evaluate and store. To understand the trade-off, Figure 7 reports the speed and accuracy of both CFNet and the baseline for varying network depth3.\nThis plot suggests that the two-layer CFNet could be the most interesting variant for practitioners requiring an accurate tracking algorithm that operates at high framerates. It runs at 75 frames per second and has less than 4% of the parameters of the five-layer baseline, requiring only 600kB to store. This may be of particular interest for embedded devices with limited memory. In contrast, methods like DeepSRDCF [7] and C-COT [9], which use out-of-the-box deep features for the Correlation Filter, run orders of magnitude slower. Even the one-layer CFNet remains competitive despite having less than 1% of the parameters of the five-layer baseline and requiring under 100kB to store."}, {"heading": "5. Conclusion", "text": "This work proposes the Correlation Filter network, an asymmetric architecture that back-propagates gradients through an online learning algorithm to optimize the underlying feature representation. This is made feasible by establishing an efficient back-propagation map for the solution to a system of circulant equations.\nOur empirical investigation reveals that, for a sufficiently deep Siamese network, adding a Correlation Filter layer does not significantly improve the tracking accuracy. We believe this is testament to the power of deep learning given sufficient training data. However, incorporating the Correlation Filter into a similarity network during training does enable shallow networks to rival their slower, deeper counterparts.\nFuture research may include extensions to account for adaptation over time, and back-propagating gradients through learning problems for related tasks such as one-shot learning and domain adaptation.\nA. Implementation details We follow the procedure of [3] to minimize the loss (equation 2) through SGD, with the Xavier-improved parameters initialization and using mini-batches of size 8. We use all the 3862 training videos of ImageNet Video [28], containing more than 1 million annotated frames, with multiple objects per frame. Training is conducted for 100 epochs, each sampling approximately 12 pairs (x\u2032i, z \u2032 i) from each video, randomly extracted so that they are at most 100 frames apart.\nDuring tracking, a spatial cosine window is multiplied with the score map to penalize large displacements. Track-\n3The speed was measured using a 4.0GHz Intel i7 CPU and an NVIDIA Titan X GPU.\ning in scale space is achieved by evaluating the network at the scale of the previous object and at one adjacent scale on either side, with a geometric step of 1.04. Updating the scale is discouraged by multiplying the responses of the scaled object by 0.97. To avoid abrupt transitions of object size, scale is updated using a rolling average with learning rate 0.6."}, {"heading": "B. Back-propagation for the Correlation Filter", "text": "As described in Appendix D (supplementary material), the back-propagation map is the adjoint of the linear maps that is the differential. These linear maps for the Correlation Filter are presented in eq. 9. We are free to obtain these adjoint maps in the Fourier domain since Parseval\u2019s theorem provides the preservation of inner products. Let J1 denote the map dx 7\u2192 dk in eq. 9a. Hence manipulation of the inner product\n\u3008Fdk, FJ1(dx)\u3009 = \u2329 d\u0302k, 1n (d\u0302x \u2217 \u25e6 x\u0302+ x\u0302\u2217 \u25e6 d\u0302x) \u232a = 1n [ \u3008d\u0302x, d\u0302k \u2217 \u25e6 x\u0302\u3009+ \u3008d\u0302k \u25e6 x\u0302, d\u0302x\u3009\n] = \u2329 d\u0302x, 2n Re{d\u0302k} \u25e6 x\u0302 \u232a (11)\ngives the back-propagation map\n\u2207\u0302x` = 2n x\u0302 \u25e6 Re{\u2207\u0302k`} . (12)\nSimilarly, for the linear map dk, dy 7\u2192 d\u03b1 in eq. 9b,\n\u3008Fd\u03b1, FJ2(dk, dy)\u3009 = \u2329 d\u0302\u03b1, k\u0302\u22121[ 1n d\u0302y \u2212 d\u0302k \u25e6 \u03b1\u0302] \u232a = \u2329\n1 n k\u0302 \u2212\u2217 \u25e6 d\u0302\u03b1, d\u0302y\n\u232a + \u2329 \u2212k\u0302\u2212\u2217 \u25e6 \u03b1\u0302\u2217 \u25e6 d\u0302\u03b1, d\u0302k \u232a , (13)\nthe back-propagation maps are\n\u2207\u0302y` = 1n k\u0302 \u2212\u2217 \u25e6 \u2207\u0302\u03b1` (14) \u2207\u0302k` = \u2212k\u0302\u2212\u2217 \u25e6 \u03b1\u0302\u2217 \u25e6 \u2207\u0302\u03b1` , (15)\nand for the linear map dx, d\u03b1 7\u2192 dw in eq. 9c,\n\u3008Fdw, FJ3(dx, d\u03b1)\u3009 = \u3008d\u0302w, d\u0302\u03b1 \u2217 \u25e6 x\u0302+ \u03b1\u0302\u2217 \u25e6 d\u0302x\u3009\n= \u3008d\u0302\u03b1, d\u0302w \u2217 \u25e6 x\u0302\u3009+ \u3008d\u0302w \u25e6 \u03b1\u0302, d\u0302x\u3009 , (16)\nthe back-propagation maps are\n\u2207\u0302\u03b1` = x\u0302 \u25e6 (\u2207\u0302w`)\u2217 , (17)\n\u2207\u0302x` = \u03b1\u0302 \u25e6 \u2207\u0302w` . (18)\nThe two expressions for \u2207x` above are combined to give the back-propagation map for the entire Correlation Filter block in eq. 10."}, {"heading": "C. Correlation Filter formulation", "text": "C.1. Kernel linear regression\nFirst, consider the general linear regression problem of learning the weight vector w that best maps each of n example input vectors xi \u2208 Rd to their target yi \u2208 R. The squared error can be expressed\n1\n2n n\u2211 i=1 (xTi w \u2212 yi)2 = 1 2n \u2016XTw \u2212 y\u20162 (19)\nwhere X \u2208 Rd\u00d7n is a matrix whose columns are the example vectors and y \u2208 Rn is a vector of the targets. Incorporating regularization, the problem is\nargmin w\n1 2n\u2016X Tw \u2212 y\u20162 + \u03bb2 \u2016w\u2016 2 . (20)\nKernel linear regression can be developed by writing this as a constrained optimization problem\nargmin w,r\n1 2n\u2016r\u2016 2 + \u03bb2 \u2016w\u2016 2\nsubject to r = XTw \u2212 y (21)\nand then finding a saddle point of the Lagrangian\nL(w, r, \u03c5) = 12n\u2016r\u2016 2+ \u03bb2 \u2016w\u2016 2+\u03c5T (r\u2212XTw+y) . (22)\nThe final solution can be obtained from the dual variable\nw = 1\u03bbX\u03c5 (23)\nand the solution to the dual problem is\n\u03c5 = \u03bbnK \u22121y (24)\nwhere K = 1nX TX + \u03bbI is the regularized kernel matrix. It is standard to introduce a scaled dual variable \u03b1 = 1\u03bbv that defines w as a weighted combination of examples\nw = X\u03b1 = n\u2211 i=1 \u03b1ixi with \u03b1 = 1 n K\u22121y . (25)\nThe kernel matrix is n \u00d7 n and therefore the dual solution is more efficient than the primal solution, which requires inversion of a d \u00d7 d matrix, when the number of features d exceeds the number of examples n.\nC.2. Single-channel Correlation Filter\nGiven a scalar-valued example signal x with domain U and corresponding target signal y, the Correlation Filter w is the scalar-valued signal\nargmin w\n1 2n \u2016w ? x\u2212 y\u20162 + \u03bb 2 \u2016w\u20162 (26)\nwhere signals are treated as vectors in RU and the circular cross-correlation of two signals w ? x is defined\n(w ? x)[u] = \u2211 t\u2208U w[t]x[u+ t mod m] \u2200u \u2208 U . (27)\nThe solution from the previous section can then be used by defining X to be the matrix in RU\u00d7U such that XTw = w ? x. It follows that the kernel matrix K belongs to RU\u00d7U and the dual variable \u03b1 is a signal in RU .\nThe key to the correlation filter is that the circulant structure of X enables the solution to be computed efficiently in the Fourier domain. The matrix X has elements X[u, t] = x[u+ t mod m]. Since the matrix X is symmetric, the template w is obtained as cross-correlation\nw = X\u03b1 = \u03b1 ? x . (28)\nThe linear map defined by the kernel matrixK is equivalent to convolution with a signal k\nKz = k \u2217 z \u2200z (29)\nwhich is defined k = 1nx ? x+ \u03bb\u03b4, since\n\u2200z : FXTXz = F ((z ? x) ? x) = z\u0302 \u25e6 x\u0302\u2217 \u25e6 x\u0302 = F (z \u2217 (x ? x)) . (30)\nTherefore the solution is defined by the equations k = 1nx ? x+ \u03bb\u03b4\nk \u2217 \u03b1 = 1ny w = \u03b1 ? x\n(31)\nand the template can be computed efficiently in the Fourier domain  k\u0302 = 1n x\u0302 \u2217 \u25e6 x\u0302+ \u03bb1 \u03b1\u0302 = 1n k\u0302 \u22121 \u25e6 y\u0302\nw\u0302 = \u03b1\u0302\u2217 \u25e6 x\u0302 . (32)\nC.3. Multi-channel Correlation Filter\nThere is little advantage to the dual solution when training a single-channel Correlation Filter from the circular shifts of a single base example. However, the dual formulation is much more efficient in the multi-channel case [14].\nFor signals with k channels, each multi-channel signal is a collection of scalar-valued signals x = (x1, . . . , xk), and the data term becomes\n\u2016 \u2211 p wp ? xp \u2212 y\u2016 2 = \u2016 \u2211 pX T p wp \u2212 y\u20162 (33)\nand each channel of the template is obtained from the dual variables\nwp = Xp\u03b1 = \u03b1 ? xp (34)\nThe solution to the dual problem is still \u03b1 = 1nK \u22121y, however the kernel matrix is now given\nK = 1n \u2211 pX T p Xp + \u03bbI (35)\nand the linear map defined by this matrix is equivalent to convolution with the signal\nk = 1n \u2211 p xp ? xp + \u03bb\u03b4 . (36)\nTherefore the solution is defined by the equations k = 1n \u2211 p xp ? xp + \u03bb\u03b4\nk \u2217 \u03b1 = 1ny wp = \u03b1 ? xp \u2200p\n(37)\nand the template can be computed efficiently in the Fourier domain  k\u0302 = 1n \u2211 p x\u0302 \u2217 p \u25e6 x\u0302p + \u03bb1 \u03b1\u0302 = 1n k\u0302 \u22121 \u25e6 y\u0302\nw\u0302p = \u03b1\u0302 \u2217 \u25e6 x\u0302p \u2200p .\n(38)\nIt is critical that the computation scales only linearly with the number of channels."}, {"heading": "D. Adjoint of the differential", "text": "Consider a computational graph that computes a scalar loss ` \u2208 R. Within this network, consider an intermediate function that computes y = f(x) where x \u2208 X = Rm and y \u2208 Y = Rn. Back-propagation computes the gradient with respect to the input\u2207x` \u2208 X from the gradient with respect to the output\u2207y` \u2208 Y .\nThe derivative \u2202f(x)/\u2202x is a matrix in Rn\u00d7m whose ijth element is the partial derivative \u2202fi(x)/\u2202xj . This matrix relates the gradients according to\n(\u2207x`)T = \u2202` \u2202x = \u2202` \u2202y \u2202y \u2202x = (\u2207y`)T \u2202f(x) \u2202x (39)\nFrom this it is evident that the back-propagation map is the linear map which is the adjoint of that defined by the derivative. That is, if the derivative defines the linear map\nJ(u) = \u2202f(x)\n\u2202x u (40)\nthen the back-propagation map is the unique linear map J\u2217 that satisfies\n\u3008J\u2217(v), u\u3009 = \u3008v, J(u)\u3009 \u2200u \u2208 X , v \u2208 Y (41)\nand the gradient with respect to the input is obtained\u2207x` = J\u2217(\u2207y`). This is the core of reverse-mode differentiation [12].\nAn alternative way to obtain the linear map defined by the derivative is to use differential calculus. Whereas the\nderivative represents this linear map as a matrix with respect to the standard bases, the differential represents the linear map as an expression df(x; dx). This is valuable for working with variables that possess more interesting structure than simple vectors. This technique has previously been used for matrix structured back-propagation [15]. In this paper, we use it for circulant structured back-propagation."}, {"heading": "E. Back-propagation for multi-channel case", "text": "The differentials of the equations that define the multichannel CF in eq. 37 are dk = 1n \u2211 p(dxp ? xp + xp ? dxp)\ndk \u2217 \u03b1+ k \u2217 d\u03b1 = 1ndy dwp = d\u03b1 ? xp + \u03b1 ? dxp \u2200p ,\n(42)\nand taking the Fourier transforms of these equations gives d\u0302k = 1n \u2211 p ( d\u0302x \u2217 p \u25e6 x\u0302p + x\u0302\u2217p \u25e6 d\u0302xp ) d\u0302\u03b1 = k\u0302\u22121 \u25e6 [ 1 n d\u0302y \u2212 d\u0302k \u25e6 \u03b1\u0302 ] d\u0302wp = d\u0302\u03b1 \u2217 \u25e6 x\u0302p + \u03b1\u0302\u2217 \u25e6 d\u0302xp \u2200p . (43)\nNow, to find the adjoint of the map dx 7\u2192 dk, we rearrange the inner product\n\u3008Fdk, FJ1(dx)\u3009 = \u2329 d\u0302k, 1n \u2211 p ( d\u0302x \u2217 p \u25e6 x\u0302p + x\u0302\u2217p \u25e6 d\u0302xp )\u232a = 1n \u2211 p [ \u3008d\u0302xp, d\u0302k \u2217 \u25e6 x\u0302p\u3009+ \u3008d\u0302k \u25e6 x\u0302p, d\u0302xp\u3009\n] = \u2211 p\u3008d\u0302xp, 2 n Re{d\u0302k} \u25e6 x\u0302p\u3009 (44)\nto give the back-propagation map\n\u2207\u0302xp` = 2n x\u0302p \u25e6 Re{\u2207\u0302k`} \u2200p . (45)\nThe linear map dk, dy 7\u2192 d\u03b1 is identical to the singlechannel case. To find the adjoint of the map dx, d\u03b1 7\u2192 dw, we examine the inner-product\n\u3008dw, J3(dx, d\u03b1)\u3009 = \u2211 p\u3008d\u0302wp, d\u0302\u03b1 \u2217 \u25e6 x\u0302p + \u03b1\u0302\u2217 \u25e6 d\u0302xp\u3009\n= \u2329 d\u0302\u03b1, \u2211 p d\u0302w \u2217 p \u25e6 x\u0302p \u232a + \u2211 p\u3008d\u0302wp \u25e6 \u03b1\u0302, d\u0302xp\u3009 , (46)\ngiving the back-propagation maps \u2207\u0302\u03b1` = \u2211 p x\u0302p \u25e6 (\u2207\u0302wp`)\u2217 , (47)\n\u2207\u0302xp` = \u03b1\u0302 \u25e6 \u2207\u0302wp` \u2200p . (48)\nFinally, combining these results gives the procedure for back-propagation in the multi-channel case \u2207\u0302\u03b1` = \u2211 p x\u0302p \u25e6 (\u2207\u0302wp`)\u2217 \u2207\u0302y` = 1n k\u0302 \u2212\u2217 \u25e6 \u2207\u0302\u03b1` \u2207\u0302k` = \u2212k\u0302\u2212\u2217 \u25e6 \u03b1\u0302\u2217 \u25e6 \u2207\u0302\u03b1`\n\u2207\u0302xp` = \u03b1\u0302 \u25e6 \u2207\u0302wp`+ 2n x\u0302p \u25e6 Re{\u2207\u0302k`} \u2200p .\n(49)\nAgain, it is important that the computation scales only linearly with the number of channels."}, {"heading": "F. Hyperparameter optimization", "text": "The hyperparameters that define the simplistic tracking algorithm have a significant impact on the tracking accuracy. These include parameters such as the penalty for changes in scale and position and the learning rate of the template average. Choosing hyperparameters is a difficult optimization problem: we cannot use gradient descent because the function is highly discontinuous, and each function evaluation is expensive because it involves running a tracker on every sequence from multiple starting points.\nFor the experiments of the main paper, where we sought to make a fair comparison of different architectures, we therefore used a natural choice of hyperparameters that were not optimized for any particular architecture. Ideally, we would use the optimal hyperparameters for each variant, except it would have been computationally prohibitive to perform this optimization for every point in every graph in the main paper (multiple times for the points with error bars).\nTo achieve results that are competitive with the state-ofthe-art, however, it is necessary to optimize the parameters of the tracking algorithm (on a held-out validation set).\nTo find optimal hyperparameters, we use random search with a uniform distribution on a reasonable range for each parameter. Specifically, we sample 300 random vectors of hyperparameters and run the evaluation described in Section 4.1 on the 129 videos of our validation set. Each method is then evaluated once on the test sets (OTB-2013, OTB-50 and OTB-100) using the hyperparameter vector which gave the best results on the validation set (specified in Table 2). We emphasize that, even though the ground-truth labels are available for the videos in the benchmarks, we do not choose hyperparameters to optimize the results on the\nbenchmarks, as this would not give a meaningful estimate of the generalization ability of the method.\nNote that this random search is performed after training and is only used to choose parameters for the online tracking algorithm. The same network is used for all random samples. The training epoch with the best tracking results on the validation set (with natural tracking parameters) is chosen.\nFigure 8 shows, for each method, the empirical distribution of results (in terms of average overlap) that is induced by the distribution of tracking parameters in random search."}, {"heading": "G. Detailed results on the OTB benchmarks", "text": "Figures 9 to 14 show the curves produced by the OTB toolkit4 for OTB-2013/50/100, of which we presented a summary in the main paper.\nAcknowledgements. This research was supported by Apical Ltd., EPSRC grant Seebibyte EP/M013774/1 and ERC grants ERC-2012-AdG 321162-HELIOS, HELIOSDFR00200, \u201cIntegrated and Detailed Image Understanding\u201d (EP/L024683/1) and ERC 677195-IDIU."}], "references": [{"title": "Learning feed-forward one-shot learners", "author": ["L. Bertinetto", "J.F. Henriques", "J. Valmadre", "P.H.S. Torr", "A. Vedaldi"], "venue": "NIPS, pages 523\u2013531,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2016}, {"title": "Staple: Complementary learners for real-time tracking", "author": ["L. Bertinetto", "J. Valmadre", "S. Golodetz", "O. Miksik", "P.H.S. Torr"], "venue": "CVPR, pages 1401\u20131409,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2016}, {"title": "Fully-convolutional Siamese networks for object tracking", "author": ["L. Bertinetto", "J. Valmadre", "J.F. Henriques", "A. Vedaldi", "P.H.S. Torr"], "venue": "ECCV Workshops, pages 850\u2013865,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2016}, {"title": "Visual object tracking using adaptive correlation filters", "author": ["D.S. Bolme", "J.R. Beveridge", "B.A. Draper", "Y.M. Lui"], "venue": "CVPR,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2010}, {"title": "Once for all: A two-flow convolutional neural network for visual tracking", "author": ["K. Chen", "W. Tao"], "venue": "arXiv preprint arXiv:1604.07507,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2016}, {"title": "Accurate scale estimation for robust visual tracking", "author": ["M. Danelljan", "G. H\u00e4ger", "F. Khan", "M. Felsberg"], "venue": "BMVC,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2014}, {"title": "Convolutional features for correlation filter based visual tracking", "author": ["M. Danelljan", "G. Hager", "F. Shahbaz Khan", "M. Felsberg"], "venue": "ICCV Workshops, pages 58\u201366,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2015}, {"title": "Learning spatially regularized correlation filters for visual tracking", "author": ["M. Danelljan", "G. Hager", "F. Shahbaz Khan", "M. Felsberg"], "venue": "ICCV, pages 4310\u20134318,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "Beyond correlation filters: Learning continuous convolution operators for visual tracking", "author": ["M. Danelljan", "A. Robinson", "F.S. Khan", "M. Felsberg"], "venue": "ECCV, pages 472\u2013488,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2016}, {"title": "Zero-aliasing correlation filters", "author": ["J.A. Fernandez", "B. Vijayakumar"], "venue": "International Symposium on Image and Signal Processing and Analysis 2013, pages 101\u2013106,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "On differentiating parameterized argmin and argmax problems with application to bi-level optimization", "author": ["S. Gould", "B. Fernando", "A. Cherian", "P. Anderson", "R.S. Cruz", "E. Guo"], "venue": "arXiv preprint arXiv:1607.05447,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2016}, {"title": "Evaluating derivatives: Principles and techniques of algorithmic differentiation", "author": ["A. Griewank", "A. Walther"], "venue": "SIAM,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2008}, {"title": "Learning to track at 100 fps with deep regression networks", "author": ["D. Held", "S. Thrun", "S. Savarese"], "venue": "ECCV, pages 749\u2013765. Springer,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2016}, {"title": "Highspeed tracking with kernelized correlation filters", "author": ["J.F. Henriques", "R. Caseiro", "P. Martins", "J. Batista"], "venue": "IEEE TPAMI, 37(3):583\u2013596,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2015}, {"title": "Matrix backpropagation for deep networks with structured layers", "author": ["C. Ionescu", "O. Vantzos", "C. Sminchisescu"], "venue": "ICCV, pages 2965\u20132973,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2015}, {"title": "Correlation filters with limited boundaries", "author": ["H. Kiani Galoogahi", "T. Sim", "S. Lucey"], "venue": "CVPR, pages 4630\u20134638,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2015}, {"title": "The Visual Object Tracking VOT2016 challenge results", "author": ["M. Kristan", "A. Leonardis", "J. Matas", "M. Felsberg", "R. Pflugfelder", "L. \u010cehovin", "T. Voj\u0131\u0301r", "G. H\u00e4ger", "A. Luke\u017ei\u010d", "G. Fern\u00e1ndez"], "venue": "In ECCV Workshops. Springer,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2016}, {"title": "Learning by tracking: Siamese CNN for robust target association", "author": ["L. Leal-Taix\u00e9", "C. Canton-Ferrer", "K. Schindler"], "venue": "CVPR Workshops, pages 33\u201340,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2016}, {"title": "A scale adaptive kernel correlation filter tracker with feature integration", "author": ["Y. Li", "J. Zhu"], "venue": "ECCV, pages 254\u2013265,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "Encoding color information for visual tracking: Algorithms and benchmark", "author": ["P. Liang", "E. Blasch", "H. Ling"], "venue": "IEEE Transactions on Image Processing, 24(12):5630\u20135644,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Fully convolutional networks for semantic segmentation", "author": ["J. Long", "E. Shelhamer", "T. Darrell"], "venue": "CVPR, pages 3431\u2013 3440,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2015}, {"title": "Hierarchical convolutional features for visual tracking", "author": ["C. Ma", "J.-B. Huang", "X. Yang", "M.-H. Yang"], "venue": "ICCV, pages 3074\u20133082,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2015}, {"title": "Long-term correlation tracking", "author": ["C. Ma", "X. Yang", "C. Zhang", "M.-H. Yang"], "venue": "CVPR, pages 5388\u20135396,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2015}, {"title": "Gradientbased hyperparameter optimization through reversible learning", "author": ["D. Maclaurin", "D. Duvenaud", "R.P. Adams"], "venue": "ICML,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2015}, {"title": "Differentiation of the Cholesky decomposition", "author": ["I. Murray"], "venue": "arXiv preprint arXiv:1602.07527,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning multi-domain convolutional neural networks for visual tracking", "author": ["H. Nam", "B. Han"], "venue": "CVPR 2016, pages 4293\u20134302,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2016}, {"title": "Maximum margin correlation filter: A new approach for localization and classification", "author": ["A. Rodriguez", "V.N. Boddeti", "B.V.K.V. Kumar", "A. Mahalanobis"], "venue": "IEEE Transactions on Image Processing, 22(2):631\u2013643,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2013}, {"title": "ImageNet Large Scale Visual Recognition Challenge", "author": ["O. Russakovsky", "J. Deng", "H. Su", "J. Krause", "S. Satheesh", "S. Ma", "Z. Huang", "A. Karpathy", "A. Khosla", "M. Bernstein", "A.C. Berg", "L. Fei-Fei"], "venue": "International Journal of Computer Vision (IJCV), 115(3):211\u2013252,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2015}, {"title": "Siamese instance search for tracking", "author": ["R. Tao", "E. Gavves", "A.W.M. Smeulders"], "venue": "CVPR, pages 1420\u20131429,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning detectors quickly with stationary statistics", "author": ["J. Valmadre", "S. Sridharan", "S. Lucey"], "venue": "ACCV, pages 99\u2013114. Springer,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2014}, {"title": "Matching networks for one shot learning", "author": ["O. Vinyals", "C. Blundell", "T. Lillicrap", "D. Wierstra"], "venue": "In NIPS,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2016}, {"title": "Transferring rich feature hierarchies for robust visual tracking", "author": ["N. Wang", "S. Li", "A. Gupta", "D.-Y. Yeung"], "venue": "arXiv preprint arXiv:1501.04587,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2015}, {"title": "Online object tracking: A benchmark", "author": ["Y. Wu", "J. Lim", "M.-H. Yang"], "venue": "CVPR, pages 2411\u20132418,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2013}, {"title": "Object tracking benchmark", "author": ["Y. Wu", "J. Lim", "M.-H. Yang"], "venue": "TPAMI, 37(9):1834\u20131848,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2015}, {"title": "Deconvolutional networks", "author": ["M.D. Zeiler", "D. Krishnan", "G.W. Taylor", "R. Fergus"], "venue": "CVPR, pages 2528\u20132535,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2010}, {"title": "Deep learning of appearance models for online object tracking", "author": ["M. Zhai", "M.J. Roshtkhari", "G. Mori"], "venue": "arXiv preprint arXiv:1607.02568,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2016}, {"title": "Conditional random fields as recurrent neural networks", "author": ["S. Zheng", "S. Jayasumana", "B. Romera-Paredes", "V. Vineet", "Z. Su", "D. Du", "C. Huang", "P.H.S. Torr"], "venue": "ICCV, pages 1529\u20131537,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 31, "context": "The simplest approach is to disregard the lack of a-priori knowledge and adapt a pre-trained deep convolutional neural network (CNN) to the target, for example by using stochastic gradient descent (SGD), the workhorse of deep network optimization [32, 26, 36].", "startOffset": 247, "endOffset": 259}, {"referenceID": 25, "context": "The simplest approach is to disregard the lack of a-priori knowledge and adapt a pre-trained deep convolutional neural network (CNN) to the target, for example by using stochastic gradient descent (SGD), the workhorse of deep network optimization [32, 26, 36].", "startOffset": 247, "endOffset": 259}, {"referenceID": 35, "context": "The simplest approach is to disregard the lack of a-priori knowledge and adapt a pre-trained deep convolutional neural network (CNN) to the target, for example by using stochastic gradient descent (SGD), the workhorse of deep network optimization [32, 26, 36].", "startOffset": 247, "endOffset": 259}, {"referenceID": 31, "context": "Furthermore, SGD is quite expensive for online adaptation [32, 26].", "startOffset": 58, "endOffset": 66}, {"referenceID": 25, "context": "Furthermore, SGD is quite expensive for online adaptation [32, 26].", "startOffset": 58, "endOffset": 66}, {"referenceID": 2, "context": "Recent works have focused on learning deep embeddings that can be used as universal object descriptors [3, 13, 29, 18, 5].", "startOffset": 103, "endOffset": 121}, {"referenceID": 12, "context": "Recent works have focused on learning deep embeddings that can be used as universal object descriptors [3, 13, 29, 18, 5].", "startOffset": 103, "endOffset": 121}, {"referenceID": 28, "context": "Recent works have focused on learning deep embeddings that can be used as universal object descriptors [3, 13, 29, 18, 5].", "startOffset": 103, "endOffset": 121}, {"referenceID": 17, "context": "Recent works have focused on learning deep embeddings that can be used as universal object descriptors [3, 13, 29, 18, 5].", "startOffset": 103, "endOffset": 121}, {"referenceID": 4, "context": "Recent works have focused on learning deep embeddings that can be used as universal object descriptors [3, 13, 29, 18, 5].", "startOffset": 103, "endOffset": 121}, {"referenceID": 3, "context": "The CF is an efficient algorithm that learns to discriminate an image patch from the surrounding patches by solving a large ridge regression problem extremely efficiently [4, 14].", "startOffset": 171, "endOffset": 178}, {"referenceID": 13, "context": "The CF is an efficient algorithm that learns to discriminate an image patch from the surrounding patches by solving a large ridge regression problem extremely efficiently [4, 14].", "startOffset": 171, "endOffset": 178}, {"referenceID": 5, "context": "[6, 19, 23, 2]), where its efficiency enables a tracker to adapt its internal model of the object on the fly at every frame.", "startOffset": 0, "endOffset": 14}, {"referenceID": 18, "context": "[6, 19, 23, 2]), where its efficiency enables a tracker to adapt its internal model of the object on the fly at every frame.", "startOffset": 0, "endOffset": 14}, {"referenceID": 22, "context": "[6, 19, 23, 2]), where its efficiency enables a tracker to adapt its internal model of the object on the fly at every frame.", "startOffset": 0, "endOffset": 14}, {"referenceID": 1, "context": "[6, 19, 23, 2]), where its efficiency enables a tracker to adapt its internal model of the object on the fly at every frame.", "startOffset": 0, "endOffset": 14}, {"referenceID": 21, "context": "[22, 7, 9, 32]), which have shown that CNNs and CFs are complementary and their combination results in improved performance.", "startOffset": 0, "endOffset": 14}, {"referenceID": 6, "context": "[22, 7, 9, 32]), which have shown that CNNs and CFs are complementary and their combination results in improved performance.", "startOffset": 0, "endOffset": 14}, {"referenceID": 8, "context": "[22, 7, 9, 32]), which have shown that CNNs and CFs are complementary and their combination results in improved performance.", "startOffset": 0, "endOffset": 14}, {"referenceID": 31, "context": "[22, 7, 9, 32]), which have shown that CNNs and CFs are complementary and their combination results in improved performance.", "startOffset": 0, "endOffset": 14}, {"referenceID": 2, "context": "[3].", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[4], the Correlation Filter has enjoyed great popularity within the tracking community.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27].", "startOffset": 114, "endOffset": 125}, {"referenceID": 15, "context": "Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27].", "startOffset": 114, "endOffset": 125}, {"referenceID": 7, "context": "Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27].", "startOffset": 114, "endOffset": 125}, {"referenceID": 21, "context": "Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27].", "startOffset": 171, "endOffset": 178}, {"referenceID": 8, "context": "Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27].", "startOffset": 171, "endOffset": 178}, {"referenceID": 26, "context": "Notable efforts have been devoted to its improvement, for example by mitigating the effect of periodic boundaries [10, 16, 8], incorporating multi-resolution feature maps [22, 9] and augmenting the objective with a more robust loss [27].", "startOffset": 232, "endOffset": 236}, {"referenceID": 28, "context": "Recently, several methods based on Siamese networks have been introduced [29, 13, 3], raising interest in the tracking community for their simplicity and competitive performance.", "startOffset": 73, "endOffset": 84}, {"referenceID": 12, "context": "Recently, several methods based on Siamese networks have been introduced [29, 13, 3], raising interest in the tracking community for their simplicity and competitive performance.", "startOffset": 73, "endOffset": 84}, {"referenceID": 2, "context": "Recently, several methods based on Siamese networks have been introduced [29, 13, 3], raising interest in the tracking community for their simplicity and competitive performance.", "startOffset": 73, "endOffset": 84}, {"referenceID": 2, "context": "For our method, we prefer to build upon the fully-convolutional Siamese architecture [3], as it enforces the prior that the appearance similarity function should commute with translation.", "startOffset": 85, "endOffset": 88}, {"referenceID": 20, "context": "At its core, the Correlation Filter layer that we introduce amounts to computing the solution to a regularized deconvolution problem, not to be confused with upsampling convolution layers that are sometimes referred to as \u201cdeconvolution layers\u201d [21].", "startOffset": 245, "endOffset": 249}, {"referenceID": 34, "context": "[35] introduced a deep architecture in which each layer solves a convolutional sparse coding problem.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15] and Murray [25] have presented back-propagation forms for the SVD and Cholesky decomposition respectively, enabling gradient descent to be applied to a network that computes the solution to either a system of linear equations or an eigenvalue problem.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "[15] and Murray [25] have presented back-propagation forms for the SVD and Cholesky decomposition respectively, enabling gradient descent to be applied to a network that computes the solution to either a system of linear equations or an eigenvalue problem.", "startOffset": 16, "endOffset": 20}, {"referenceID": 36, "context": "When the solution to the optimization problem is obtained iteratively, an alternative is to treat the iterations as a Recurrent Neural Network, and to explicitly unroll a fixed number of iterations [37].", "startOffset": 198, "endOffset": 202}, {"referenceID": 23, "context": "[24] go further and back-propagate gradients through an entire SGD learning procedure, although this is computationally demanding and requires judicious bookkeeping.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] have recently considered differentiating the solution to general argmin problems without restricting themselves to iterative procedures.", "startOffset": 0, "endOffset": 4}, {"referenceID": 30, "context": "Recent works [31, 1] have proposed feed-forward architectures that can be interpreted as learning algorithms, enabling optimization by gradient", "startOffset": 13, "endOffset": 20}, {"referenceID": 0, "context": "Recent works [31, 1] have proposed feed-forward architectures that can be interpreted as learning algorithms, enabling optimization by gradient", "startOffset": 13, "endOffset": 20}, {"referenceID": 2, "context": "Our starting point is a network similar to that of [3], which we later modify in order to allow the model to be interpreted as a Correlation Filter tracker.", "startOffset": 51, "endOffset": 54}, {"referenceID": 2, "context": "2Note that this differs from [3], in which the target object and search area were instead denoted z and x respectively.", "startOffset": 29, "endOffset": 32}, {"referenceID": 2, "context": "to [3], we employ a simplistic tracking algorithm to assess the utility of the similarity function.", "startOffset": 3, "endOffset": 6}, {"referenceID": 13, "context": "The CF block w = \u03c9(x) computes a standard CF template w from the training feature map x = f\u03c1(x) by solving a ridge regression problem in the Fourier domain [14].", "startOffset": 156, "endOffset": 160}, {"referenceID": 7, "context": "[8] and Kiani et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 15, "context": "[16].", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "To reduce the effect of circular boundaries, the feature map x is pre-multiplied by a cosine window [4] and the final template is cropped [30].", "startOffset": 100, "endOffset": 103}, {"referenceID": 29, "context": "To reduce the effect of circular boundaries, the feature map x is pre-multiplied by a cosine window [4] and the final template is cropped [30].", "startOffset": 138, "endOffset": 142}, {"referenceID": 13, "context": "Notice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7].", "startOffset": 123, "endOffset": 137}, {"referenceID": 5, "context": "Notice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7].", "startOffset": 123, "endOffset": 137}, {"referenceID": 22, "context": "Notice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7].", "startOffset": 123, "endOffset": 137}, {"referenceID": 2, "context": "Notice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7].", "startOffset": 123, "endOffset": 137}, {"referenceID": 21, "context": "Notice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7].", "startOffset": 186, "endOffset": 193}, {"referenceID": 6, "context": "Notice that the forward pass of the architecture in Figure 1 corresponds exactly to the operation of a standard CF tracker [14, 6, 23, 3] with CNN features, as proposed in previous work [22, 7].", "startOffset": 186, "endOffset": 193}, {"referenceID": 13, "context": "as close as possible to a desired response y[u] [14], minimizing\u2211", "startOffset": 48, "endOffset": 52}, {"referenceID": 13, "context": "6 can be computed efficiently in the Fourier domain [14], \uf8f4\uf8f2\uf8f4\uf8f3 k\u0302 = 1 n (x\u0302 \u2217 \u25e6 x\u0302) + \u03bb1 \u03b1\u0302 = 1 n k\u0302 \u22121 \u25e6 \u0177 \u0175 = \u03b1\u0302\u2217 \u25e6 x\u0302 (7a)", "startOffset": 52, "endOffset": 56}, {"referenceID": 14, "context": "[15] to compute backpropagation maps using matrix differential calculus.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "However, in practice we did not find learning this parameter to improve the tracking accuracy compared to the conventional choice of a fixed Gaussian response [4, 14].", "startOffset": 159, "endOffset": 166}, {"referenceID": 13, "context": "However, in practice we did not find learning this parameter to improve the tracking accuracy compared to the conventional choice of a fixed Gaussian response [4, 14].", "startOffset": 159, "endOffset": 166}, {"referenceID": 2, "context": "[3].", "startOffset": 0, "endOffset": 3}, {"referenceID": 16, "context": "Popular tracking benchmarks like VOT [17] and OTB [33, 34] have made all ground truth annotations available and do not enforce a validation/test split.", "startOffset": 37, "endOffset": 41}, {"referenceID": 32, "context": "Popular tracking benchmarks like VOT [17] and OTB [33, 34] have made all ground truth annotations available and do not enforce a validation/test split.", "startOffset": 50, "endOffset": 58}, {"referenceID": 33, "context": "Popular tracking benchmarks like VOT [17] and OTB [33, 34] have made all ground truth annotations available and do not enforce a validation/test split.", "startOffset": 50, "endOffset": 58}, {"referenceID": 19, "context": "However, in order to avoid overfitting to the test set in design choices and hyperparameter selection, we consider OTB-2013, OTB-50 and OTB-100 as our test set and 129 videos from VOT2014, VOT-2016 and Temple-Color [20] as our validation set, excluding any videos which were already assigned to the test set.", "startOffset": 215, "endOffset": 219}, {"referenceID": 32, "context": "As in the OTB benchmark [33, 34], we quantify the performance of the tracker on a sequence in terms of the average overlap (intersection over union) of the predicted and ground truth rectangles in all frames.", "startOffset": 24, "endOffset": 32}, {"referenceID": 33, "context": "As in the OTB benchmark [33, 34], we quantify the performance of the tracker on a sequence in terms of the average overlap (intersection over union) of the predicted and ground truth rectangles in all frames.", "startOffset": 24, "endOffset": 32}, {"referenceID": 2, "context": "Our baseline diverges slightly from [3] in two ways.", "startOffset": 36, "endOffset": 39}, {"referenceID": 27, "context": "The ImageNet+CF variant employs features taken from a network trained to solve the ImageNet classification challenge [28].", "startOffset": 117, "endOffset": 121}, {"referenceID": 6, "context": "The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment.", "startOffset": 99, "endOffset": 121}, {"referenceID": 8, "context": "The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment.", "startOffset": 99, "endOffset": 121}, {"referenceID": 21, "context": "The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment.", "startOffset": 99, "endOffset": 121}, {"referenceID": 25, "context": "The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment.", "startOffset": 99, "endOffset": 121}, {"referenceID": 31, "context": "The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment.", "startOffset": 99, "endOffset": 121}, {"referenceID": 35, "context": "The results show that these features, which are often the first choice for combining CFs with CNNs [7, 9, 22, 26, 32, 36], are significantly worse than those learned by CFNet and the Baseline experiment.", "startOffset": 99, "endOffset": 121}, {"referenceID": 2, "context": "SiamFC-3s [3] 60.", "startOffset": 10, "endOffset": 13}, {"referenceID": 1, "context": "5 Staple [2] 60.", "startOffset": 9, "endOffset": 12}, {"referenceID": 22, "context": "9 LCT [23] 61.", "startOffset": 6, "endOffset": 10}, {"referenceID": 18, "context": "5 SAMF [19] \u2013 \u2013 \u2013 \u2013 46.", "startOffset": 7, "endOffset": 11}, {"referenceID": 5, "context": "6 DSST [6] 55.", "startOffset": 7, "endOffset": 10}, {"referenceID": 32, "context": "All numbers in this section are obtained using the OTB toolkit [33].", "startOffset": 63, "endOffset": 67}, {"referenceID": 2, "context": "We compare our methods against state-of-the-art trackers that can operate in realtime: SiamFC-3s [3], Staple [2] and LCT [23].", "startOffset": 97, "endOffset": 100}, {"referenceID": 1, "context": "We compare our methods against state-of-the-art trackers that can operate in realtime: SiamFC-3s [3], Staple [2] and LCT [23].", "startOffset": 109, "endOffset": 112}, {"referenceID": 22, "context": "We compare our methods against state-of-the-art trackers that can operate in realtime: SiamFC-3s [3], Staple [2] and LCT [23].", "startOffset": 121, "endOffset": 125}, {"referenceID": 18, "context": "We also include the recent SAMF [19] and DSST [6] for reference.", "startOffset": 32, "endOffset": 36}, {"referenceID": 5, "context": "We also include the recent SAMF [19] and DSST [6] for reference.", "startOffset": 46, "endOffset": 49}, {"referenceID": 33, "context": "Both overlap (IoU) and precision scores [34] are reported for OPE (one pass) and TRE (temporal robustness) evaluations.", "startOffset": 40, "endOffset": 44}, {"referenceID": 25, "context": "bounding box regression [26], ensembling of multiple cues [23, 2], optical flow [29]).", "startOffset": 24, "endOffset": 28}, {"referenceID": 22, "context": "bounding box regression [26], ensembling of multiple cues [23, 2], optical flow [29]).", "startOffset": 58, "endOffset": 65}, {"referenceID": 1, "context": "bounding box regression [26], ensembling of multiple cues [23, 2], optical flow [29]).", "startOffset": 58, "endOffset": 65}, {"referenceID": 28, "context": "bounding box regression [26], ensembling of multiple cues [23, 2], optical flow [29]).", "startOffset": 80, "endOffset": 84}, {"referenceID": 6, "context": "In contrast, methods like DeepSRDCF [7] and C-COT [9], which use out-of-the-box deep features for the Correlation Filter, run orders of magnitude slower.", "startOffset": 36, "endOffset": 39}, {"referenceID": 8, "context": "In contrast, methods like DeepSRDCF [7] and C-COT [9], which use out-of-the-box deep features for the Correlation Filter, run orders of magnitude slower.", "startOffset": 50, "endOffset": 53}, {"referenceID": 2, "context": "We follow the procedure of [3] to minimize the loss (equation 2) through SGD, with the Xavier-improved parameters initialization and using mini-batches of size 8.", "startOffset": 27, "endOffset": 30}, {"referenceID": 27, "context": "We use all the 3862 training videos of ImageNet Video [28], containing more than 1 million annotated frames, with multiple objects per frame.", "startOffset": 54, "endOffset": 58}, {"referenceID": 13, "context": "However, the dual formulation is much more efficient in the multi-channel case [14].", "startOffset": 79, "endOffset": 83}, {"referenceID": 11, "context": "This is the core of reverse-mode differentiation [12].", "startOffset": 49, "endOffset": 53}, {"referenceID": 14, "context": "This technique has previously been used for matrix structured back-propagation [15].", "startOffset": 79, "endOffset": 83}], "year": 2017, "abstractText": "The Correlation Filter is an algorithm that trains a linear template to discriminate between images and their translations. It is well suited to object tracking because its formulation in the Fourier domain provides a fast solution, enabling the detector to be re-trained once per frame. Previous works that use the Correlation Filter, however, have adopted features that were either manually designed or trained for a different task. This work is the first to overcome this limitation by interpreting the Correlation Filter learner, which has a closed-form solution, as a differentiable layer in a deep neural network. This enables learning deep features that are tightly coupled to the Correlation Filter. Experiments illustrate that our method has the important practical benefit of allowing lightweight architectures to achieve state-of-the-art performance at high framerates.", "creator": "LaTeX with hyperref package"}}}