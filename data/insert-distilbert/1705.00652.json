{"id": "1705.00652", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-May-2017", "title": "Efficient Natural Language Response Suggestion for Smart Reply", "abstract": "this reference paper presents a computationally \u2010 efficient machine - switched learned method for natural language response suggestion. feed - forward neural networks using n - gram dot embedding features encode messages into vectors which are optimized together to give message - response pairs a high dot - product value. an optimized search finds response suggestions. the initial method is evaluated in reviewing a large - scale commercial e - mail application, inbox by gmail. compared to a sequence - to - sequence analysis approach, the new system actually achieves the same quality at a small absolute fraction of the computational requirements and latency.", "histories": [["v1", "Mon, 1 May 2017 18:24:15 GMT  (431kb,D)", "http://arxiv.org/abs/1705.00652v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["matthew henderson", "rami al-rfou", "brian strope", "yun-hsuan sung", "laszlo lukacs", "ruiqi guo", "sanjiv kumar", "balint miklos", "ray kurzweil"], "accepted": false, "id": "1705.00652"}, "pdf": {"name": "1705.00652.pdf", "metadata": {"source": "CRF", "title": "Efficient Natural Language Response Suggestion for Smart Reply", "authors": ["MATTHEW HENDERSON", "RAMI AL-RFOU", "BRIAN STROPE", "YUN-HSUAN SUNG", "L\u00c1SZL\u00d3 LUK\u00c1CS", "RUIQI GUO", "SANJIV KUMAR", "BALINT MIKLOS"], "emails": ["bps}@google.com."], "sections": [{"heading": null, "text": "Efficient Natural Language Response Suggestion for Smart Reply\nMATTHEW HENDERSON, RAMI AL-RFOU, BRIAN STROPE, YUN-HSUAN SUNG, LA\u0301SZLO\u0301 LUKA\u0301CS, RUIQI GUO, SANJIV KUMAR, BALINT MIKLOS, and RAY KURZWEIL, Google\nThis paper presents a computationally efficient machine-learned method for natural language response suggestion. Feed-forward neural networks using n-gram embedding features encode messages into vectors which are optimized to give message-response pairs a high dot-product value. An optimized search finds response suggestions. The method is evaluated in a large-scale commercial e-mail application, Inbox by Gmail. Compared to a sequence-to-sequence approach, the new system achieves the same quality at a small fraction of the computational requirements and latency.\nAdditional Key Words and Phrases: Natural Language Understanding; Deep Learning; Semantics; Email"}, {"heading": "1 INTRODUCTION", "text": "Applications of natural language understanding (NLU) are becoming increasingly interesting with scalable machine learning, web-scale training datasets, and applications that enable fast and nuanced quality evaluations with large numbers of user interactions.\nEarly NLU systems parsed natural language with hand-crafted rules to explicit semantic representations, and used manually written state machines to generate specific responses from the output of parsing [18]. Such systems are generally limited to the situations imagined by the designer, and much of the development work involves writing more rules to improve the robustness of semantic parsing and the coverage of the state machines. These systems are brittle, and progress is slow [31]. Eventually adding more parsing rules and response strategies becomes too complicated for a single designer to manage, and dependencies between the rules become challenging to coordinate across larger teams. Often the best solution is to keep the domains decidedly narrow.\nStatistical systems can offer a more forgiving path by learning implicit trade-offs, generalizations, and robust behaviors from data. For example, neural network models have been used to learn more robust parsers [14, 24, 29]. In recent work, the components of task-oriented dialog systems have been implemented as neural networks, enabling joint learning of robust models [7, 26, 27]. However these methods all rely on either an explicit semantic representation or an explicit representation of the task, always hand-crafted.\nEnd-to-end systems avoid using hand-crafted explicit representations, by learning to map to and from natural language via implicit internal vector representations [19, 25]. Such systems avoid the unnecessary contraints and bottlenecks inevitably imposed by the system designer. In that context, natural language understanding might be evaluated less in terms of an explicit semantic representation, and more by the utility of the system itself. The system shows evidence of understanding when it offers useful responses.\nSuch end-to-end tasks are difficult: systems not only need to learn language but also must learn to do something useful with it. This paper addresses the task of suggesting responses in human-tohuman conversations. There are further challenges that arise when building an end-to-end dialog\nCorresponding authors: {matthen, rmyeid, bps}@google.com. \u00a9 2017 Copyright held by the owner/author(s). Publication rights licensed to ACM.\nar X\niv :1\n70 5.\n00 65\n2v 1\n[ cs\n.C L\n] 1\nM ay\n2 01\n7\nsystem, i.e. a computer agent that interacts directly with a human user. Dialog systems must learn effective and robust interaction strategies, and goal-oriented systems may need to interact with discrete external databases. Dialog systems must also learn to be consistent throughout the course of a dialog, maintaining some kind of memory from turn to turn.\nMachine learning requires huge amounts of data, and lots of helpful users to guide development through live interactions, but we also need to make some architectural decisions, in particular how to represent natural language text.\nNeural natural language understanding models typically represent words, and possibly phrases, sentences, and documents as implicit vectors. Vector representations of words, or word embeddings, have been widely adopted, particularly since the introduction of efficient computational learning algorithms that can derive meaningful embeddings from unlabeled text [15, 17, 20].\nThough a simple representation of a sequence of words can be obtained by summing the individual word embeddings, this discards information about the word ordering. The sequence-to-sequence (Seq2Seq) framework uses recurrent neural networks (RNNs), typically long short-term memory (LSTM) networks, to encode sequences of word embeddings into representations that depend on the order, and uses a decoder RNN to generate output sequences word by word. This framework provides a direct path for end-to-end learning [23]. With attention mechanisms and more layers, these systems are revolutionizing the field of machine translation [28]. A similar system was initially used to deployed Google\u2019s Smart Reply system for Inbox by Gmail [11].\nWhile Seq2Seq models provide a generalized solution, it is not obvious that they are maximally efficient, and training these systems can be slow and complicated. Also they are derived as a generative model, and so using them to rank a fixed set of responses (as in the context of Smart Reply) requires extra normalization to bias the system away from common responses.\nIn a broader context, Kurzweil\u2019s work outlines a path to create a simulation of the human neocortex (the outer layer of the brain where we do much of our thinking) by building a hierarchy of similarly structured components that encode increasingly abstract ideas as sequences [12]. Kurzweil provides evidence that the neocortex is a self-organizing hierarchy of modules, each of which can learn, remember, recognize and/or generate a sequence, in which each sequence consists of a sequential pattern from lower-level modules. Longer relationships (between elements that are far away in time or spatial distance) are modeled by the hierarchy itself. In this work we adopt such a hierarchical structure, representing each sequential model as a feed-forward vector computation (with underlying sequences implicitly represented using n-grams). Whereas a long short-term memory (LSTM) network could also model such sequences, we don\u2019t need an LSTM\u2019s ability to directly encode long-term relationships (since the hierarchy does that) and LSTMs are much slower than feed-forward networks for training and inference since the computation scales with the length of the sequence.\nSimilarly, the work on paragraph vectors shows that word embeddings can be back-propagated to arbitrary levels in a contextual hierarchy [13]. Machines can optimize sentence vectors, paragraph vectors, chapter vectors, book vectors, author vectors, and so on, with simple back-propagation and computationally efficient feed-forward networks.\nPutting a few of these ideas together, we wondered if we could predict a sentence using only the sum of its n-gram embeddings. Without the ordering of the words, can we use the limited sequence information from the n-grams, and the redundancy of language, to recreate the original word sequence? With a simple RNN as a decoder, our preliminary experiments showed perplexities of around 1.2 over a vocabulary of hundreds of thousands of words. A lot of the sequence information remains in this simple n-gram sentence representation. As a corollary, a hierarchy built on top of n-gram representations could indeed adequately represent the increasingly abstract sequences underlying natural language. Networks built on n-gram embeddings such as those presented in this\npaper (see section 4) are computationally inexpensive relative to RNN and convolutional network [6, 30] encoders.\nTo make sure there is enough data and the necessary live feedback from users, we train on the anonymized Gmail data that was used in Kannan et al. [11], and use our models to give Smart Reply response suggestions to users of Inbox by Gmail (see figure 1). Smart Reply provides a real world application in which we can measure the quality of our response suggestion models.\nJust as in Kannan et al. [11], we consider natural language response suggestion from a fixed set of candidates. For efficiency, we frame this as a search problem. Inputs are combined with potential responses using final dot products to enable precomputation of the \u201cresponse side\u201d of the system. Adding deep layers and delaying combination between input and responses encourages the network to derive implicit semantic representations of the input and responses\u2013 if we assume that the best way to predict their relationships is to understand them.\nWe precompute a minimal hierarchy of deep feed-forward networks for all potential responses, and at runtime propagate only the input through the hierarchical network. We use an efficient nearest-neighbor search of the hierarchical embeddings of the responses to find the best suggestions."}, {"heading": "2 PROBLEM DEFINITION", "text": "The Smart Reply system gives short response suggestions to help users respond quickly to emails. Emails are processed by the system according to the pipeline detailed in figure 2.\nThe decision of whether to give suggestions is made by a deep neural network classifier, called the triggering model. This model takes various features of the received email, including a word n-gram representation, and is trained to estimate the probability that the user would type a short reply to the input email, see Kannan et al. [11]. If the output of the triggering model is above a threshold, then Smart Reply will give m (typically 3) short response suggestions for the email. Otherwise no suggestions are given. As a result, suggestions are not shown for emails where a response is not likely (e.g. spam, news letters, and promotional emails), reducing clutter in the user interface and saving unnecessary computation.\nThe system is restricted to a fixed set of response suggestions, R, selected from millions of common messages. The response selection step involves searching for the top N (typically around 100) scoring responses in R according to a response selection model P (y | x). The output of response selection is a list of suggestions (y1, y2, . . . , yN ) with yi \u2208 R ordered by their probability. Kannan et al. [11] used a sequence-to-sequence model for P (y | x) and used a beam search over the\nprefices in R (see section 3). This paper presents a feed-forward neural network model for P (y | x), including a factorized dot-product model where selection can be performed using a highly efficient and accurate approximate search over a precomputed set of vectors, see section 4.\nFinally the diversification stage ensures diversity in the final m response suggestions. A clustering algorithm is used to omit redundant suggestions, and a labeling of R is used to ensure a negative suggestion is given if the other two are affirmative and vice-versa. Full details are given in Kannan et al. [11]."}, {"heading": "3 BASELINE SEQUENCE-TO-SEQUENCE SCORING", "text": "The response selection model presented in Kannan et al. [11] is a long short-term memory (LSTM) recurrent neural network [8] \u2013 an application of the sequence-to-sequence learning framework (Seq2Seq) [23].\nThe input email x is tokenized into a word sequence (x1, . . . , xm) and the LSTM computes the conditional probability over a response sequence y = (y1, . . . , yn) as:\nP (y | x) = P (y1, . . . , yn | x1, . . . , xm) = \u220fn i=1 PLSTM(yi | x1, . . . , xm, y1, . . . , yi\u22121)\nwhere PLSTM is the output of the word-level LSTM. The LSTM is trained to maximize the logprobability according to P (y | x) of the training data (a large collection of emails and responses, see section 5.1). At inference time, likely responses from the candidate set R are found using a beam search that is restricted to the prefix trie of R. The time complexity of this search is O(|x|+ b|y|) where b is the beam width and should be scaled appropriately with |R|. This search dominates the computation of the original Smart Reply system."}, {"heading": "4 FEEDFORWARD APPROACH", "text": "Rather than learning a generative model, we investigate learning a feedforward network to score potential responses.\nRecall the goal of response selection is to model P (y | x), which is used to rank possible responses y given an input email x. This probability distribution can be written as:\nP (y | x) = P (x, y)\u2211 k P (x, yk)\n(1)\nThe joint probability of P (x, y) is estimated using a learned neural network scoring function, S such that:\nP (x, y) \u221d eS(x,y) (2) Note that the calculation of equation 1 requires summing over the neural network outputs for all possible responses yk. (This is only an issue for training, and not inference since the denominator is a constant for any given x and so does not affect the arg max over y). This is prohibitively expensive to calculate, so we will approximate P (x) by sampling K responses including y uniformly from our corpus during training:\nPapprox(y | x) = P (x, y)\n\u2211K k=1 P (x, yk)\n(3)\nCombining equations 2 and 3 gives the approximate probability of the training data used to train the neural networks:\nPapprox(y | x) = eS(x,y)\n\u2211K k=1 e S(x,yk) (4)\nThe following subsections show several scoring models; how to extend the models to multiple features; how to overcome bias introduced by the sampling procedure; and an efficient search algorithm for response selection."}, {"heading": "4.1 N-gram Representation", "text": "To represent input emails x and responses y as fixed-dimensional input features, we extract ngram features from each. During training, we learn a d-dimensional embedding for each n-gram jointly with the other neural network parameters. To represent sequences of words, we combine n-gram embeddings by summing their values. We will denote this bag of n-grams representation as \u03a8(x) \u2208 Rd. This representation is quick to compute and captures basic semantic and word ordering information."}, {"heading": "4.2 Joint Scoring Model", "text": "Figure 3a shows the joint scoring neural network model that takes the bag of n-gram representations of the input email x and the response y, and produces a scalar score S(x, y). This deep neural network can model complex joint interactions between input and responses in its computation of the score."}, {"heading": "4.3 Dot-Product Scoring Model", "text": "Figure 3b shows the structure of the dot-product scoring model, where S(x, y) is factorized as a dot-product between a vector hx that depends only on x and a vector hy that depends only on y. This is similar to Deep Structured Semantic Models, which use feedforward networks to project queries and documents into a common space where the relevance of a document given a query is computed as the cosine distance between them [9].\nWhile the interaction between features is not as direct as the joint scoring model (see section 4.2), this factorization allows us to calculate the representation of the input x and possible responses y\nindependently. In particular, the representations of the response set R can be precomputed. Then searching for response suggestions reduces to encoding a new email x in a simple feed-forward step to the vector hx, and then searching for high dot-product scoring responses in the precomputed set (see section 4.7).\nIt is also efficient to compute the scores S(xi, yj) for all pairs of inputs and responses in a training batch of n examples, as that requires only an additional matrix multiplication after computing the hxi and hyi vectors. This leads to vastly more efficient training with multiple negatives (see section 4.4) than is possible with the joint scoring model."}, {"heading": "4.4 Multiple Negatives", "text": "Recall from section 4 that a set of K possible responses is used to approximate P (y | x) \u2013 one correct response and K \u2212 1 random negatives. For efficiency and simplicity we use the responses of other examples in a training batch of stochastic gradient descent as negative responses. For a batch of size K, there will be K input emails x = (x1, . . . , xK) and their corresponding responses y = (y1, . . . , yK). Every reply yj is effectively treated as a negative candidate for xi if i 6= j. The K \u2212 1 negative examples for each x are different at each pass through the data due to shuffling in stochastic gradient descent.\nThe goal of training is to minimize the approximated mean negative log probability of the data. For a single batch this is:\nJ (x,y, \u03b8)\n= \u2212 1 K\nK\u2211\ni=1\nlogPapprox(yi | xi)\n= \u2212 1 K\nK\u2211\ni=1\n S(xi, yi)\u2212 log K\u2211\nj=1\neS(xi,yj)\n \n(5)\nusing equation 4, where \u03b8 represents the word embeddings and neural network parameters used to calculate S. Note that this loss function is invariant to adding any function f(x) to S(x, y), so\nS(x, y) is learned up to an additive term that does not affect the arg max over y performed in the inference time search."}, {"heading": "4.5 Incorporating Multiple Features", "text": "There is structure in emails that can be used to improve the accuracy of scoring models. We follow the multi-loss architecture of Al-Rfou et al. [2] to incorporate additional features beyond the message body, for example the subject line. Figure 4 shows the multi-loss architecture applied to both the joint and dot-product scoring models.\nThe multi-loss networks have a sub-network for each feature of the email, which are trained to independently score candidate responses using that feature alone. The highest level hidden layer of the sub-network is used in a final sub-network that is trained to combine the information from all the features and give a final score. This hierarchical structure results in models that learn how to use each feature faster than a network that sees all the features at once, and also allows for learning deeper networks than is otherwise possible [2].\nFormally, denote the M features of an input email x as x1, . . . , xM . Then for each i, a subnetwork produces a hidden vector representation hi, and a score of the response y using only xi, S(xi, y). Denoting (xi1, . . . , x i K) as x i, a loss function J (xi,y, \u03b8) encourages S(xi, y) to be high\nfor corresponding pairs in the training batch, and low for the random pairs. The second stage of the network produces a final score S(x, y) that is a function of all of the hi vectors. The network is trained end-to-end with a single loss:\nJ (x,y, \u03b8) + M\u2211\ni=1\nJ (xi,y, \u03b8)\nNote that the final score produced by the multi-loss dot-product model (figure 4b) is a dot-product of a vector hx that depends only on the input x, and a vector hy that depends only on the response y, as in the single-feature case. As a result, it can still be used for the fast vector search algorithm described in section 4.7, and training with multiple negatives remains efficient.\nFor the multi-loss joint scoring model, the input feature vector for the final sub-network is the concatenation of the hi vectors and therefore scales with the number of features, leading to a computational bottleneck. For the dot-product scoring model, the hidden layer representations are learned such that they are meaningful vectors when compared using a dot product. This motivates combining the representations for the final sub-network using vector arithmetic. The features extracted from the input email, xi, are averaged (1/M \u2211M i=1 h i x), as are the response representations\nlearned from different sub-networks (1/M \u2211M\ni=1 h i y), before being passed to the final neural network\nlayers. While this choice may constrain the representations learned by each sub-network, and may limit the ability of the final sub-network to differentiate information from different features, it also encourages them to exist in the same semantic space."}, {"heading": "4.6 Response Biasing", "text": "The discriminative objective function introduced in section 4.4 leads to a biased estimation of the denominator in equation (1). Since our negative examples are sampled from the training data distribution, common responses with high prior likelihood appear more often as negative examples. In practice, we observed that this bias leads to models that favor specific and long responses instead of short and generic ones. To encourage more generic responses, we bias the responses in R using a score derived from the log likelihood of the response as estimated using a language model. Our final score Sf (x, y) of any input email response pair is calculated as:\nSf (x, y) = Sm(x, y) + \u03b1 logPLM(y) (6)\nwhere Sm is the score calculated by our trained scoring model, PLM(y) is the probability of y according to the language model, and \u03b1 is tuned with online experiments. Note that the additional term is dependent only on y, and so can be precomputed for every response in R prior to inference time.\nTable 1 demonstrates the effect of including the response bias using an example email."}, {"heading": "4.7 Hierarchical Quantization for Efficient Search", "text": "At inference time, given an input email x, we use the dot-product scoring model to find response suggestions y \u2208 R with the highest scores S(x, y), where the scoring function is the dot-product: S(x, y) = hTxhy\n1. The problem of finding datapoints with the largest dot-product values is sometimes called Maximum Inner Product Search (MIPS). This is a research topic of its own and is also useful for inference in neural networks with a large number of output classes.\nMaximum Inner Product Search is related to nearest neighbor search (NNS) in Euclidean space, but comes with its own challenges because the dot-product \u201cdistance\u201d is non-metric and many classical approaches such as KD-trees cannot be applied directly. For more background, we refer readers to the relevant works of [3, 5, 21, 22]. In the Smart Reply system, we need to keep very high retrieval recall (for example > 99% in top-30 retrieval). However, many of the existing methods are not designed to work well in the high recall regime without slowing down the search considerably. To achieve such high recall, hashing methods often require a large number of hash bits and tree methods often need to search a large number of leaves.\nIn this work, we use a hierarchical quantization approach to solve the search problem. For our use case, the responses y come from a fixed setR and thus the hy vectors are computed ahead of inference time. Unlike the previous work in [5], we propose a hierarchical combination of vector quantization, orthogonal transformation and product quantization of the transformed vector quantization residuals. Our hierarchical model is based on the intuition that data in DNN hidden layers often resemble low dimensional signal with high dimensional residuals. Vector quantization is good at capturing low dimensional signals. Product quantization works by decomposing the high-dimensional vectors into low-dimensional subspaces and then quantizing them separately [4]. We use a learned rotation before product quantization as it has been shown to improve quantization error [16].\nSpecifically, hy is approximated by a hierarchical quantization HQ(hy), which is the sum of the vector quantization component V Q(hy) and the residuals. A learned orthogonal transformation R is applied to the residual, followed by product quantization.\nhy \u2248 HQ(hy) = V Q(hy) + RTPQ(ry), where ry = R(hy \u2212 V Q(hy))\nHere, given a vector quantization codebook CVQ, product quantization codebooks of {CPQ(k)} for each of the subspaces k, and the learned orthogonal matrix R \u2208 Rd\u00d7d, the vector quantization of hy is V Q(hy) = arg minc\u2208CVQ ||hy \u2212 c||2. The product quantization of the rotated residual ry is computed by first dividing the rotated residuals ry into K subvectors r(k)y , k = 1, 2, \u00b7 \u00b7 \u00b7 ,K, and then quantizing the subvectors independently by vector quantizers C(k)PQ:\nPQ(k)(r(k)y ) = arg min s\u2208{CPQ(k)} ||s\u2212 r(k)y ||2.\nFinally the full product quantization PQ(ry) is given by the concatenation of the quantization in each subspace:\nPQ(ry) =   PQ(1)(r (1) y ) PQ(2)(r (2) y )\n... PQ(K)(r(K)y )\n  , ry =   r (1) y r (2) y\n... r (K) y\n \n1 The bias term, \u03b1 logPLM(y), can be included in the dot product e.g. by extending the hx vector with {\u03b1} and the hy vector with {logPLM(y)}\nAt training time, the codebook for vector quantization, CVQ, codebooks for product quantization C\n(\u00b7) PQ, and the rotation matrix R are jointly learned by minimizing the reconstruction error of hy \u2212 HQ(hy) with stochastic gradient descent (SGD). At inference time, prediction is made by taking the candidates with the highest quantized dot product, i.e.\nhTx V Q(hy) + (Rhx) TPQ(ry)\nThe distance computation can be performed very efficiently without reconstructing HQ(hy), instead utilizing a lookup table for asymmetric distance computation [10]. Furthermore, the lookup operation is carried out in register using SIMD (single instruction, multiple data) instructions in our implementation, providing a further speed improvement.\n1 5 10 15 20 25 30\nSpeed up over exhaustive search\n0.84\n0.86\n0.88\n0.90\n0.92\n0.94\n0.96\n0.98\n1.00\nT o p\n-3 0\nr e ca\nll\nHierarchical Quantization Clustering [3] ALSH [20]\nFig. 5. Evaluation of retrieval speed vs. recall of top-30 neighbors with maximum dot product. The curve is produced by varying the number of approximate neighbors retrieved by our hierarchical quantization method and by Asymmetric LSH [22], and varying the number of leaves searched by the clustering algorithm of [3].\nWe summarize the speed-recall evaluation of using different approximate MIPS algorithms in figure 5. The y-axis shows the recall of the top-30 retrieved responses, where the ground truth is computed by exhaustive search. The x-axis shows the speed up factor with respect to exhaustive search. Therefore, exhaustive search achieves a recall of 100% with a speed up factor of 1. Our algorithm achieves 99.89% recall with a speed-up factor over 10, outperforming the baselines of [3, 22]."}, {"heading": "5 EVALUATION", "text": ""}, {"heading": "5.1 Experimental Setup", "text": "Data. Pairs of emails and their responses are sampled from user data to create datasets for training and testing the feedforward response scoring models. In total around 300M pairs are collected. The data is split uniformly at random into two disjoint sets of 95% and 5%, which constitute the training and test sets respectively.\nAll email data (raw data, preprocessed data and training/evaluation data) is encrypted. Engineers can only inspect aggregated statistics on anonymized sentences that occurred across many users and do not identify any user.\nLanguage identification is run on the emails, and only English language emails are kept. The subject lines and message bodies are tokenized into word sequences, from which n-gram features are extracted. Infrequent words, URLs, email addresses, phone numbers etc. are replaced with special\ntokens. Quoted text arising from replying and forwarding is also removed. We used hundreds of thousands of the most frequent n-grams as features to represent the text.\nTraining. Each of our DNN sub-networks consists of 3 hidden layers of sizes 500, 300, 100 in the case of the joint scoring models and 300, 300, 500 for the dot-product models . The embedding dimensionality d of our n-grams is 320. We train each model for at least 10 epochs. We set the learning rate to 0.01 during the first 40 million batches, after which it is reduced to 0.001. The models are trained on CPUs across 50 machines using a distributed implementation of TensorFlow [1]."}, {"heading": "5.2 Offline Evaluation", "text": "Our models are evaluated offline on their ability to identify the true response to an email in the test data against a set of randomly selected competing responses. In this paper, we score a set of 100 responses that includes the correct response and 99 randomly selected incorrect competitors. We rank responses according to their scores, and report precision at 1 (P@1) as a metric of evaluation. We found that P@1 correlates with the quality of our models as measured in online experiments with users (see section 5.3).\nBatch Size Scoring Model P@1\nTable 2 presents the results of the offline evaluation for joint and dot-product scoring models. The joint scoring model outperforms the dot-product model trained on the same batch size. This model learns complex cross-features between the input email and the response leading to a better scoring. However, the joint scoring model does not scale well to larger batches, since each possible pairing of input email and response requires a full forward pass through the network. The number of forward passes through the joint scoring model grows quadratically with the batch size. Recall the dot-product scoring model is a lot faster to train with multiple negatives than the joint scoring models since it requires a linear number of forward passes followed by a single K by K matrix multiply to score all possible pairings, where K is the batch size. As a result, the multi-loss dot-product models can be trained on larger batches to produce more accurate models.\nNote that the models in table 2 are trained with the multiple negatives training loss of section 4.4. It is also possible to train the models as a classifier with a sigmoid loss. We find that multiple negative training results in a consistent 20% reduction in error rate for P@1 relative to training as a classifier across all of our conversational datasets. For example, in a different version of the Smart Reply data it improved the P@1 of a dot-product model from 47% to 58%."}, {"heading": "5.3 Online Evaluation", "text": "Though the offline ranking metric gives a useful signal during development, the ultimate proof of a response selection model is how it affects the quality of the suggestions that users see in the end-to-end Smart Reply system. Suggestion quality or usefulness is approximated here by the observed conversion rate, i.e. the percentage of times users click on one of the suggestions when they are shown.\nThis section describes the evolution of our system and shows the effect of each iteration on latency and quality relative to the baseline Seq2Seq system. An outline of this series of online experiments is presented in table 3.\n5.3.1 Exhaustive Search. Our initial system scored the input email against every response in the response set R using the joint scoring model and the Email body feature alone (see figure 6a). Given that the joint scoring model requires a forward pass for each response in R, this approach is too computationally expensive for an online experiment, see row 1 of table 3.\n5.3.2 Two pass. The computational expense of the initial exhaustive search system motivated the design of a two-stage approach where the first stage is fast and the second is more accurate, as shown in figure 6b.\nThe first stage consists of a dot-product scoring model utilizing the text of the email body alone. As a pre-processing step, all of the responses in the response set R = {y1, . . . , yn} are encoded to their vector representations to give a matrix R = [hy1 , . . . ,hyn ] (see figure 3b). At inference time, a new input email is encoded to its representation hx, and the vector of all scores is calculated as the dot product with the precomputed matrix: Rhx. A heap is then used to find the M highest scoring responses. The second stage uses the joint scoring model to score the candidates from the first stage. Row 2 of table 3, shows the 50x speedup improvement from using this two pass system.\nThe system tended to suggest overly specific and often long responses because of the biased negative sampling procedure, see section 4.6. Therefore, we added an extra score to boost the scores of more likely responses using a language model. This change significantly improved the quality of\nthe suggestions, see row 3 of table 3, moving the systems toward shorter and more generic responses that users were more likely to find appropriate and click.\nImproving our dataset sampling, and using the multi-loss structure brought the conversion rate of the system above that of the Seq2Seq system, see row 4 of table 3).\n5.3.3 Single pass. To improve the latency, we removed the second pass step and relied solely on the responses found by the first pass dot-product step (see figure 6c). However, to maintain the quality, we had to improve the quality of the dot-product model.\nSince the dot-product scoring model scales better with more negatives during training, we doubled the number of negatives for training the first pass system. We also applied the multi-loss architecture to the first pass dot-product model, using additional input features (see figure 4b). Together these changes made the dot-product model slightly more accurate than the joint model (see table 2). As a result, the system quality stayed the same while the speed increased 5 times, as shown in row 5 of table 3.\nSo far, we have been computing the dot-product between the new email representation and all the precomputed representations of the responses in the response set, and searching the entire list to find high scoring responses. Switching from this exhaustive search to the hierarchical quantization search described in section 4.7 doubles the speed of the system without compromising quality (see row 6 of table 3).\nAs a result, our final system produces better quality suggestions than the baseline Seq2Seq system with a small percentage of the computation and latency."}, {"heading": "6 CONCLUSIONS", "text": "This paper presents a feed-forward approach for scoring the consistency between input messages and potential responses. A hierarchy of deep networks on top of simple n-gram representations is shown to outperform competitive sequence-to-sequence models in this context.\nThe deep networks use different components for reading inputs and precomputing the representation of possible responses. That architecture enables a highly efficient runtime search.\nWe evaluate the models with the Smart Reply application. Live experiments with production traffic enabled a series of improvements that resulted in a system of higher quality than the original sequence-to-sequence system and a small fraction of the computation and latency.\nWithout addressing the generation of novel responses, this paper suggests a minimal, efficient, and scalable implementation that enables many ranking-based applications."}, {"heading": "ACKNOWLEDGMENTS", "text": "Thanks to Fernando Pereira, Corinna Cortes, Anjuli Kannan, Dilek Hakkani-Tu\u0308r and Larry Heck for their valuable input to this paper. We would also like to acknowledge the many engineers at Google whose work on the tools and infrastructure made these experiments possible. Thanks especially to the users of Smart Reply."}], "references": [{"title": "et al", "author": ["M. Abadi", "P. Barham", "J. Chen", "Z. Chen", "A. Davis", "J. Dean", "M. Devin", "S. Ghemawat", "G. Irving", "M. Isard"], "venue": "Tensorflow: A system for large-scale machine learning. In USENIX Symposium on Operating Systems Design and Implementation (OSDI)", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2016}, {"title": "Conversational contextual cues: The case of personalization and history for response ranking", "author": ["R. Al-Rfou", "M. Pickett", "J. Snaider", "Y. Sung", "B. Strope", "R. Kurzweil"], "venue": "arXiv preprint arXiv:1606.00372", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2016}, {"title": "Clustering is efficient for approximate maximum inner product search", "author": ["A. Auvolat", "S. Chandar", "P. Vincent", "H. Larochelle", "Y. Bengio"], "venue": "arXiv preprint arXiv:1507.05910", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Vector quantization", "author": ["R.M. Gray"], "venue": "ASSP Magazine, IEEE, 1(2):4\u201329", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1984}, {"title": "Quantization based fast inner product search", "author": ["R. Guo", "S. Kumar", "K. Choromanski", "D. Simcha"], "venue": "International Conference on Artificial Intelligence and Statistics", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2016}, {"title": "Multi-perspective sentence similarity modeling with convolutional neural networks", "author": ["H. He", "K. Gimpel", "J.J. Lin"], "venue": "Empirical Methods on Natural Language Processing (EMNLP)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2015}, {"title": "Word-based dialog state tracking with recurrent neural networks", "author": ["M. Henderson", "B. Thomson", "S. Young"], "venue": "Special Interest Group on Discourse and Dialogue (SIGDIAL)", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "Long short-term memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural Computation,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1997}, {"title": "Learning deep structured semantic models for web search using clickthrough data", "author": ["P.-S. Huang", "X. He", "J. Gao", "L. Deng", "A. Acero", "L. Heck"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "Product quantization for nearest neighbor search", "author": ["H. Jegou", "M. Douze", "C. Schmid"], "venue": "Pattern Analysis and Machine Intelligence, 33(1)", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2011}, {"title": "Smart Reply: Automated response suggestion for email", "author": ["A. Kannan", "K. Kurach", "S. Ravi", "T. Kaufman", "B. Miklos", "G. Corrado", "A. Tomkins", "L. Luk\u00e1cs", "M. Ganea", "P. Young", "V. Ramavajjala"], "venue": "Conference on Knowledge Discovery and Data Mining (KDD). ACM", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2016}, {"title": "How to Create a Mind: The Secret of Human Thought Revealed", "author": ["R. Kurzweil"], "venue": "Penguin Books, New York, NY, USA", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "Distributed representations of sentences and documents", "author": ["Q.V. Le", "T. Mikolov"], "venue": "International Conference on Machine Learning (ICML)", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Using recurrent neural networks for slot filling in spoken language understanding", "author": ["G. Mesnil", "Y. Dauphin", "K. Yao", "Y. Bengio", "L. Deng", "X. He", "L. Heck", "G. Tur", "D. Hakkani-T\u00fcr", "D. Yu", "G. Zweig"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2015}, {"title": "Efficient estimation of word representations in vector space", "author": ["T. Mikolov", "K. Chen", "G. Corrado", "J. Dean"], "venue": "arXiv preprint arXiv:1301.3781", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2013}, {"title": "Cartesian k-means", "author": ["M. Norouzi", "D.J. Fleet"], "venue": "Conference on Computer Vision and Pattern Recognition, pages 3017\u20133024. IEEE", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "Glove: Global vectors for word representation", "author": ["J. Pennington", "R. Socher", "C.D. Manning"], "venue": "Empirical Methods on Natural Language Processing (EMNLP)", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "Evaluation of spoken language systems: The ATIS domain", "author": ["P.J. Price"], "venue": "Workshop on Speech and Natural Language, HLT \u201990. Association for Computational Linguistics", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1990}, {"title": "Building end-to-end dialogue systems using generative hierarchical neural network models", "author": ["I.V. Serban", "A. Sordoni", "Y. Bengio", "A. Courville", "J. Pineau"], "venue": "Conference on Artificial Intelligence. AAAI", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2016}, {"title": "Swivel: Improving embeddings by noticing what\u2019s missing", "author": ["N. Shazeer", "R. Doherty", "C. Evans", "C. Waterson"], "venue": "arXiv preprint arXiv:1602.02215", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning binary codes for maximum inner product search", "author": ["F. Shen", "W. Liu", "S. Zhang", "Y. Yang", "H. Tao Shen"], "venue": "International Conference on Computer Vision. IEEE", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2015}, {"title": "Asymmetric LSH (ALSH) for sublinear time maximum inner product search (MIPS)", "author": ["A. Shrivastava", "P. Li"], "venue": "Advances in neural information processing systems (NIPS)", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Sequence to sequence learning with neural networks", "author": ["I. Sutskever", "O. Vinyals", "Q.V. Le"], "venue": "Advances in neural information processing systems (NIPS)", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2014}, {"title": "Grammar as a foreign language", "author": ["O. Vinyals", "L. Kaiser", "T. Koo", "S. Petrov", "I. Sutskever", "G. Hinton"], "venue": "Advances in neural information processing systems (NIPS)", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2015}, {"title": "A neural conversational model", "author": ["O. Vinyals", "Q.V. Le"], "venue": "International Conference on Machine Learning (ICML)", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2015}, {"title": "A network-based end-to-end trainable task-oriented dialogue system", "author": ["T.-H. Wen", "D. Vandyke", "N. Mrksic", "M. Gasic", "L.M. Rojas-Barahona", "P.-H. Su", "S. Ultes", "S. Young"], "venue": "arXiv preprint arXiv:1604.04562", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2016}, {"title": "End-to-end LSTM-based dialog control optimized with supervised and reinforcement learning", "author": ["J.D. Williams", "G. Zweig"], "venue": "arXiv preprint arXiv:1606.01269", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2016}, {"title": "Google\u2019s neural machine translation system: Bridging the gap between human and machine translation", "author": ["Y. Wu", "M. Schuster", "Z. Chen", "Q.V. Le", "M. Norouzi", "W. Macherey", "M. Krikun", "Y. Cao", "Q. Gao", "K. Macherey", "J. Klingner", "A. Shah", "M. Johnson", "X. Liu", "L. Kaiser", "S. Gouws", "Y. Kato", "T. Kudo", "H. Kazawa", "K. Stevens", "G. Kurian", "N. Patil", "W. Wang", "C. Young", "J. Smith", "J. Riesa", "A. Rudnick", "O. Vinyals", "G. Corrado", "M. Hughes", "J. Dean"], "venue": "arXiv preprint arXiv:1609.08144", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2016}, {"title": "Recurrent neural networks for language understanding", "author": ["K. Yao", "G. Zweig", "M.-Y. Hwang", "Y. Shi", "D. Yu"], "venue": "Interspeech", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2013}, {"title": "ABCNN: Attention-based convolutional neural network for modeling sentence pairs", "author": ["W. Yin", "H. Sch\u00fctze", "B. Xiang", "B. Zhou"], "venue": "Transactions of the Association for Computational Linguistics, 4", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2016}, {"title": "Talking to machines (statistically speaking)", "author": ["S. Young"], "venue": "Interspeech", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2002}], "referenceMentions": [{"referenceID": 17, "context": "Early NLU systems parsed natural language with hand-crafted rules to explicit semantic representations, and used manually written state machines to generate specific responses from the output of parsing [18].", "startOffset": 203, "endOffset": 207}, {"referenceID": 30, "context": "These systems are brittle, and progress is slow [31].", "startOffset": 48, "endOffset": 52}, {"referenceID": 13, "context": "For example, neural network models have been used to learn more robust parsers [14, 24, 29].", "startOffset": 79, "endOffset": 91}, {"referenceID": 23, "context": "For example, neural network models have been used to learn more robust parsers [14, 24, 29].", "startOffset": 79, "endOffset": 91}, {"referenceID": 28, "context": "For example, neural network models have been used to learn more robust parsers [14, 24, 29].", "startOffset": 79, "endOffset": 91}, {"referenceID": 6, "context": "In recent work, the components of task-oriented dialog systems have been implemented as neural networks, enabling joint learning of robust models [7, 26, 27].", "startOffset": 146, "endOffset": 157}, {"referenceID": 25, "context": "In recent work, the components of task-oriented dialog systems have been implemented as neural networks, enabling joint learning of robust models [7, 26, 27].", "startOffset": 146, "endOffset": 157}, {"referenceID": 26, "context": "In recent work, the components of task-oriented dialog systems have been implemented as neural networks, enabling joint learning of robust models [7, 26, 27].", "startOffset": 146, "endOffset": 157}, {"referenceID": 18, "context": "End-to-end systems avoid using hand-crafted explicit representations, by learning to map to and from natural language via implicit internal vector representations [19, 25].", "startOffset": 163, "endOffset": 171}, {"referenceID": 24, "context": "End-to-end systems avoid using hand-crafted explicit representations, by learning to map to and from natural language via implicit internal vector representations [19, 25].", "startOffset": 163, "endOffset": 171}, {"referenceID": 14, "context": "Vector representations of words, or word embeddings, have been widely adopted, particularly since the introduction of efficient computational learning algorithms that can derive meaningful embeddings from unlabeled text [15, 17, 20].", "startOffset": 220, "endOffset": 232}, {"referenceID": 16, "context": "Vector representations of words, or word embeddings, have been widely adopted, particularly since the introduction of efficient computational learning algorithms that can derive meaningful embeddings from unlabeled text [15, 17, 20].", "startOffset": 220, "endOffset": 232}, {"referenceID": 19, "context": "Vector representations of words, or word embeddings, have been widely adopted, particularly since the introduction of efficient computational learning algorithms that can derive meaningful embeddings from unlabeled text [15, 17, 20].", "startOffset": 220, "endOffset": 232}, {"referenceID": 22, "context": "This framework provides a direct path for end-to-end learning [23].", "startOffset": 62, "endOffset": 66}, {"referenceID": 27, "context": "With attention mechanisms and more layers, these systems are revolutionizing the field of machine translation [28].", "startOffset": 110, "endOffset": 114}, {"referenceID": 10, "context": "A similar system was initially used to deployed Google\u2019s Smart Reply system for Inbox by Gmail [11].", "startOffset": 95, "endOffset": 99}, {"referenceID": 11, "context": "In a broader context, Kurzweil\u2019s work outlines a path to create a simulation of the human neocortex (the outer layer of the brain where we do much of our thinking) by building a hierarchy of similarly structured components that encode increasingly abstract ideas as sequences [12].", "startOffset": 276, "endOffset": 280}, {"referenceID": 12, "context": "Similarly, the work on paragraph vectors shows that word embeddings can be back-propagated to arbitrary levels in a contextual hierarchy [13].", "startOffset": 137, "endOffset": 141}, {"referenceID": 5, "context": "paper (see section 4) are computationally inexpensive relative to RNN and convolutional network [6, 30] encoders.", "startOffset": 96, "endOffset": 103}, {"referenceID": 29, "context": "paper (see section 4) are computationally inexpensive relative to RNN and convolutional network [6, 30] encoders.", "startOffset": 96, "endOffset": 103}, {"referenceID": 10, "context": "[11], and use our models to give Smart Reply response suggestions to users of Inbox by Gmail (see figure 1).", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11], we consider natural language response suggestion from a fixed set of candidates.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11].", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] used a sequence-to-sequence model for P (y | x) and used a beam search over the", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11].", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] is a long short-term memory (LSTM) recurrent neural network [8] \u2013 an application of the sequence-to-sequence learning framework (Seq2Seq) [23].", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "[11] is a long short-term memory (LSTM) recurrent neural network [8] \u2013 an application of the sequence-to-sequence learning framework (Seq2Seq) [23].", "startOffset": 65, "endOffset": 68}, {"referenceID": 22, "context": "[11] is a long short-term memory (LSTM) recurrent neural network [8] \u2013 an application of the sequence-to-sequence learning framework (Seq2Seq) [23].", "startOffset": 143, "endOffset": 147}, {"referenceID": 8, "context": "This is similar to Deep Structured Semantic Models, which use feedforward networks to project queries and documents into a common space where the relevance of a document given a query is computed as the cosine distance between them [9].", "startOffset": 232, "endOffset": 235}, {"referenceID": 1, "context": "[2].", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[2] to incorporate additional features beyond the message body, for example the subject line.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "This hierarchical structure results in models that learn how to use each feature faster than a network that sees all the features at once, and also allows for learning deeper networks than is otherwise possible [2].", "startOffset": 211, "endOffset": 214}, {"referenceID": 2, "context": "For more background, we refer readers to the relevant works of [3, 5, 21, 22].", "startOffset": 63, "endOffset": 77}, {"referenceID": 4, "context": "For more background, we refer readers to the relevant works of [3, 5, 21, 22].", "startOffset": 63, "endOffset": 77}, {"referenceID": 20, "context": "For more background, we refer readers to the relevant works of [3, 5, 21, 22].", "startOffset": 63, "endOffset": 77}, {"referenceID": 21, "context": "For more background, we refer readers to the relevant works of [3, 5, 21, 22].", "startOffset": 63, "endOffset": 77}, {"referenceID": 4, "context": "Unlike the previous work in [5], we propose a hierarchical combination of vector quantization, orthogonal transformation and product quantization of the transformed vector quantization residuals.", "startOffset": 28, "endOffset": 31}, {"referenceID": 3, "context": "Product quantization works by decomposing the high-dimensional vectors into low-dimensional subspaces and then quantizing them separately [4].", "startOffset": 138, "endOffset": 141}, {"referenceID": 15, "context": "We use a learned rotation before product quantization as it has been shown to improve quantization error [16].", "startOffset": 105, "endOffset": 109}, {"referenceID": 9, "context": "hx V Q(hy) + (Rhx) PQ(ry) The distance computation can be performed very efficiently without reconstructing HQ(hy), instead utilizing a lookup table for asymmetric distance computation [10].", "startOffset": 185, "endOffset": 189}, {"referenceID": 2, "context": "Clustering [3]", "startOffset": 11, "endOffset": 14}, {"referenceID": 19, "context": "ALSH [20]", "startOffset": 5, "endOffset": 9}, {"referenceID": 21, "context": "The curve is produced by varying the number of approximate neighbors retrieved by our hierarchical quantization method and by Asymmetric LSH [22], and varying the number of leaves searched by the clustering algorithm of [3].", "startOffset": 141, "endOffset": 145}, {"referenceID": 2, "context": "The curve is produced by varying the number of approximate neighbors retrieved by our hierarchical quantization method and by Asymmetric LSH [22], and varying the number of leaves searched by the clustering algorithm of [3].", "startOffset": 220, "endOffset": 223}, {"referenceID": 2, "context": "89% recall with a speed-up factor over 10, outperforming the baselines of [3, 22].", "startOffset": 74, "endOffset": 81}, {"referenceID": 21, "context": "89% recall with a speed-up factor over 10, outperforming the baselines of [3, 22].", "startOffset": 74, "endOffset": 81}, {"referenceID": 0, "context": "The models are trained on CPUs across 50 machines using a distributed implementation of TensorFlow [1].", "startOffset": 99, "endOffset": 102}, {"referenceID": 10, "context": "[11].", "startOffset": 0, "endOffset": 4}], "year": 2017, "abstractText": "This paper presents a computationally efficient machine-learned method for natural language response suggestion. Feed-forward neural networks using n-gram embedding features encode messages into vectors which are optimized to give message-response pairs a high dot-product value. An optimized search finds response suggestions. The method is evaluated in a large-scale commercial e-mail application, Inbox by Gmail. Compared to a sequence-to-sequence approach, the new system achieves the same quality at a small fraction of the computational requirements and latency.", "creator": "LaTeX with hyperref package"}}}