{"id": "1705.04665", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-May-2017", "title": "A Formal Characterization of the Local Search Topology of the Gap Heuristic", "abstract": "the pancake puzzle is a classic optimization problem that has become a standard benchmark for heuristic search algorithms. in this paper, we provide full proofs regarding the standardized local search topology of the gap heuristic for the pancake space puzzle. first, we show that after in any non - goal closed state in positions which there is no move that will decrease the number of gaps, there is a move that strictly will keep the number of gaps constant. we then classify any state in which the number of gaps cannot be decreased separately in a single action into two groups : those requiring 2 actions ( to decrease the finite number ahead of gaps, and to those which will require 3 random actions to decrease the number of gaps.", "histories": [["v1", "Fri, 12 May 2017 17:28:43 GMT  (13kb)", "http://arxiv.org/abs/1705.04665v1", "Technical report providing proofs of statements appearing in a \"An Analysis and Enhancement of the Gap Heuristic for the Pancake Puzzle\" by Richard Anthony Valenzano and Danniel Yang. This paper appeared at the 2017 Symposium on Combinatorial Search"]], "COMMENTS": "Technical report providing proofs of statements appearing in a \"An Analysis and Enhancement of the Gap Heuristic for the Pancake Puzzle\" by Richard Anthony Valenzano and Danniel Yang. This paper appeared at the 2017 Symposium on Combinatorial Search", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["richard anthony valenzano", "danniel sihui yang"], "accepted": false, "id": "1705.04665"}, "pdf": {"name": "1705.04665.pdf", "metadata": {"source": "CRF", "title": "A Formal Characterization of the Local Search Topology of the Gap Heuristic", "authors": ["Richard Valenzano", "Danniel Sihui Yang"], "emails": ["rvalenzano@cs.toronto.edu", "dannielyang1996@gmail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 5.\n04 66\n5v 1\n[ cs\n.A I]\n1 2\nM ay\nThe pancake puzzle is a classic optimization problem that has become a standard benchmark for heuristic search algorithms. In this paper, we provide full proofs regarding the local search topology of the gap heuristic for the pancake puzzle. First, we show that in any non-goal state in which there is no move that will decrease the number of gaps, there is a move that will keep the number of gaps constant. We then classify any state in which the number of gaps cannot be decreased in a single action into two groups: those requiring 2 actions to decrease the number of gaps, and those which require 3 actions to decrease the number of gaps."}, {"heading": "1 Background", "text": "In this section, we provide background on the pancake problem and define the notation used in the rest of the paper."}, {"heading": "1.1 Sequences and Permutations", "text": "In this paper, we represent a sequence \u03c3 of k elements from some set as \u03c3 = \u3008e1, ..., ek\u3009, where \u03c3[i] then refers to the i-th element of \u03c3 (i.e. \u03c3[i] = ei) 1. If \u03c3\u2032 = \u3008g1, ..., gk\u2032\u3009, we use \u03c3 \u25e6 \u03c3 \u2032 to denote the concatenation of these sequences: \u3008e1, ..., ek, g1, ..., gk\u2032\u3009. A permutation \u03c0 of size N is a sequence of the natural numbers from 1 to N , such that each element in the sequence is unique."}, {"heading": "1.2 The Pancake Puzzle Problem", "text": "An N -pancake puzzle state is a stack of N different sized pancakes. We represent this stack with a permutation of size N , where entry i refers to the i-th smallest pancake and the order of the numbers in the permutation corresponds to the order of the pancakes in the stack from top to bottom. For example, \u30082, 1, 4, 3\u3009 represents a 4-pancake stack in which the second smallest pancake is at the top of the stack.\nIn any N -pancake state, there are N \u2212 1 applicable actions or moves, denoted by M2, M3, ..., MN . Action Mk, called a k-flip, reverses the order of the first k values in the stack. Where Mk(\u03c0) denotes the permutation that is the result of applying action Mk to \u03c0, this means that Mk(\u03c0)[1] = \u03c0[k], Mk(\u03c0)[2] = \u03c0[k \u2212 1], and so on. For example, M3(\u30082, 1, 4, 3\u3009) = \u30084, 1, 2, 3\u3009.\nDefinition 1. Given N -pancake state \u03c0init, the N -pancake puzzle task is to find the shortest or optimal sequence of flips that transforms \u03c0init into state \u03c0goal = \u30081, 2, ..., N\u3009.\n1As is convention in the pancake puzzle literature, the first element of the permutation is at location 1."}, {"heading": "1.3 The Gap Heuristic", "text": "A heuristic function h is a function from the set of states to the set of non-negative real numbers, where h(\u03c0) is referred to as the heuristic value of \u03c0. A heuristic h is said to be admissible if for every state \u03c0, h(\u03c0) \u2264 h\u2217(\u03c0).\nThe gap heuristic (Helmert 2010), which we denote by hG, is most easily formally defined using the extended permutation \u03c0e of \u03c0. \u03c0e is defined as \u03c0 \u25e6 \u3008N + 1\u3009. The valueN + 1 can be thought of as the plate below the pancake stack, though we often refer to it as theN +1-st pancake. Moreover, due to the one-to-one correspondence between \u03c0 and \u03c0e we often refer to \u03c0[N + 1], the \u201cN + 1-st pancake\u201d of \u03c0, or \u201clocationN + 1\u201d in \u03c0.\nFor any j where 1 \u2264 j \u2264 N , an adjacency is said to occur in \u03c0e between locations j and j + 1, or between pancakes \u03c0e[j] and \u03c0e[j + 1], if |\u03c0e[j] \u2212 \u03c0e[j + 1]| = 1. A gap is said to occur between those locations (or those pancakes) if an adjacency does not occur. hG(\u03c0), is then given by the count of the number of gaps in \u03c0e:\nhG(\u03c0) = |{j | 1 \u2264 j \u2264 N, |\u03c0e[j]\u2212 \u03c0e[j + 1]| > 1}|\nSince any action can only add or remove at most one gap and there are no gaps in \u03c0goal, h G is admissible.\nIf action Mi removes a gap when applied to state \u03c0 (i.e. h G(Mi(\u03c0)) = h G(\u03c0) \u2212 1), then Mi is called a gap decreasing move in \u03c0. Similarly,Mi is a gap increasing move if it introduces a gap, while if it replaces one gap with another or one adjacency with another,Mi is a gap neutral move.\nWe observe that there are always at most two gap decreasing moves in any state. This is because Mi can only resolve a gap (if one exists) between locations i and i+1, if \u03c0[1] is adjacent to \u03c0[i+1] in \u03c0goal, and this is only true if \u03c0[i + 1] = \u03c0[1] + 1 or \u03c0[i + 1] = \u03c0[1]\u2212 1. However, in many states there are no gap decreasing moves. These states are said to be locked."}, {"heading": "2 Locked States and Gap Neutral Moves", "text": "In this section, we formally prove that there is a gap neutral move in every non-goal locked state. We begin by showing that there is at least one gap in any non-goal state.\nLemma 2.1. \u03c0 is a goal state if and only if hG(\u03c0) = 0.\nProof. The fact that if \u03c0 is a goal state, then hG(\u03c0) = 0 is obvious. As such, let us assume that hG(\u03c0) = 0 Then there is no gap between locations N and N + 1 of \u03c0, which ensures that \u03c0[N ] = N . Similarly, there is no gap between locationsN \u2212 1 and N of \u03c0, which ensures that \u03c0[N \u2212 1] = N \u2212 1. This argument can be extended to show that for any 1 \u2264 i \u2264 N , \u03c0[i] = i. As such, \u03c0 is the goal state.\nWe will now use this lemma to show that there is always a gap neutral move in any non-goal locked state.\nTheorem 2.2. If \u03c0 is a locked state that is not the goal, then there is a gap neutral move in \u03c0.\nProof. Let \u03c0 be a locked state that is not the goal. First, we note that \u03c0[1] 6= N . This is because if \u03c0[N ] = N , then \u03c0[N ] 6= N , and so there is a gap between locations N and N + 1. Thus, MN is a gap decreasing move which contradicts the assumption that \u03c0 is locked. There are now two cases to consider.\nCase 1: \u03c0[1] > 1. Since \u03c0[1] > 1, \u03c0[1] < N since otherwise \u03c0 is not locked by the argument above. As such, let e and e\u2032 be the two pancakes that should be beside \u03c0[1] in the goal state (i.e. |\u03c0[1]\u2212 e| = |\u03c0[1]\u2212 e\u2032| = 1). If \u03c0[\u2113] = e and \u03c0[\u2113\u2032] = e\u2032, we can assume that \u2113 > \u2113\u2032 without loss of generality. Since 1 < \u2113\u2032 < \u2113, \u2113 > 2.\nNow because \u03c0 is locked, there is an adjacency between locations \u2113\u2212 1 and \u2113. Since \u2113 > 2,M\u2113\u22121 is a valid action. Moreover, M\u2113\u22121 will move \u03c0[1] on top of e, thereby replacing one adjacency with another. As such, M\u2113\u22121 is a gap neutral move, thus guaranteeing that one such gap neutral move exists in \u03c0 in this case.\nCase 2: \u03c0[1] = 1. There are now two subcases to consider. First, \u03c0[2] 6= 2. This means that \u03c0[\u2113] = 2 for some \u2113 > 2 and so M\u2113\u22121 is a valid action. This action will simply replace one adjacency with another by the same argument as in Case 1, and so the statement holds in this case.\nNow suppose that \u03c0[2] = 2. Since \u03c0 is not a goal state, there must exist a gap between some two locations \u2113 and \u2113 + 1 by Theorem 2.1. Because there \u03c0[1] = 1 and \u03c0[2] = 2, there is no gap between locations 1 and 2 in \u03c0, and so \u2113 \u2265 2. Thus, M\u2113 is a valid move. Since \u03c0[2] = 2, this means that \u03c0[\u2113 + 1] 6= 2 and so M\u2113(\u03c0) will also have a gap between locations \u2113 and \u2113 + 1. Thus, M\u2113 is a gap neutral move in \u03c0 which replaces one gap with another. As such, there is a gap neutral move in \u03c0 in this case.\nHaving handled all cases, the statement holds."}, {"heading": "3 Topology of the Gap Heuristic", "text": "In this section, we extend the work of Fischer and Ginzinger (2005) and provide a classification of states according to the size of the plateaus around them. To simplify this analysis, we assume that in all states, there is gap between locations N and N + 1. Doing so removes the postfix of a state if it is already sorted, since this portion of the state will have no impact on the number of gaps or the optimal solution cost. For example, where \u03c0 = \u30082, 1, 4, 3\u3009 and \u03c0\u2032 = \u30082, 1, 4, 3, 5, 6, 7\u3009, clearly hG(\u03c0) = hG(\u03c0\u2032) and h\u2217(\u03c0) = h\u2217(\u03c0\u2032).\nWe begin with some additional notation. Following Hoffmann (2005), a plateau for h is a connected set of one or more states that all have the same heuristic value. An exit from a plateau with heuristic value \u2113 is a state \u03c0 such that h(\u03c0) = \u2113 and there is some neighbour \u03c0\u2032 of \u03c0 such that h(\u03c0\u2032) < h(\u03c0). The exit distance of h from a state \u03c0 is the minimum number of actions needed to reach an exit. Note that this means than any exit has an exit distance of 0.\nWe also say that consecutive locations i, i + 1, ..., i + j in a permutation \u03c0 is a strip of size j + 1 if there are no gaps between the pancakes in those locations, and that sequence of locations is maximal (i.e. on either side of the strip there is a gap or the end of the permutation). A strip of size 2 or more is descending if \u03c0[i] > \u03c0[i+1] > ... > \u03c0[i+ j], and ascending otherwise. Two strips from i to i + j and i\u2032 to i\u2032 + j\u2032 where i \u2264 i + j < i\u2032 \u2264 i\u2032 + j\u2032 are in order if the pancakes in the strip from i to j are smaller than the pancakes in the strip from i\u2032 to j\u2032. The first strip is the one starting at location 1, and the rightmost strip is the one ending at locationN . Where \u2113 is the size of the first strip of a state \u03c0 that has at least two strips, the second strip starts at location \u2113 + 1. The remaining strips are named similarly. For example, \u30081, 2, 3, 5, 4\u3009 has two strips: the first strip is an ascending strip of size 3 from locations 1 to 3, and a descending strip of size 2 from location 4 to 5. The latter strip is the second or rightmost one, and the two strips are in order.\nWe now define the following family of states:\nDefinition 2. \u03c0 is a Fischer-Ginzinger (FG) state if and only if \u03c0 has at least two strips, and all strips in \u03c0 are\ndescending, have a size of at least two, and are in order.\nFor example, \u30083, 2, 1, 5, 4\u3009 is an FG state, while \u30081, 2, 4, 3\u3009 and \u30082, 1, 3, 5, 4\u3009 are not FG states since they have an ascending strip and strip of size 1, respectively.\nWe can now characterize states according to their exit distance. First, we notice that any state in which there is a gap decreasing move has an exit distance of 0 by definition. For locked states, consider the following corollary of Lemma 5 from Fischer and Ginzinger (2005):\nCorollary 3.1. The exit distance of hG for any locked state that is not an FG state is 1.\nFischer and Ginzinger proved this by providing appropriate sequences of actions that could decrease the number of gaps for all possible cases of non-FG locked states. Fischer and Ginzinger also provided a method for sorting any FG state \u03c0 using at most 2 \u00b7 hG(\u03c0) actions. This method always decreases the number of gaps in \u03c0 in 3 actions, thus guaranteeing that the exit distance of any FG state is at most 2. However, this method does not show that this is always necessary, and thus does not provide a characterization of FG states according to their exit distance.\nTo provide such a characterization, we define an easy FG state as an FG state with exactly 2 strips such that the rightmost strip has a size of 2. We can now show the following:\nTheorem 3.2. If \u03c0 is an easy FG state, then the exit distance of hG for \u03c0 is 1 and h\u2217(\u03c0) = 3.\nProof. Let \u03c0 be an easy FG state. Since all FG states are locked, the exit distance of \u03c0 is at least 1. \u03c0 will also necessarily have the following form \u3008N \u2212 2, ..., 1, N,N \u2212 1\u3009. As such, \u03c0 has two gaps, one of which can be removed\nby applying MN\u22121 and then MN to reach state \u03c0 \u2032 = \u3008N \u2212 1, N \u2212 2, ..., 1, N\u3009. Applying MN\u22121 and then MN will lead to state \u03c0\u2032 = \u3008N \u2212 1, N \u2212 2, ..., 1, N\u3009. Since \u03c0\u2032 has a single gap, the exit distance of \u03c0 is 1. ApplyingMN\u22121 to \u03c0\n\u2032 completes the sort of \u03c0, for a solution to \u03c0 with cost 3. Since the fact that \u03c0 is locked means that h\u2217(\u03c0) \u2265 hG(\u03c0) + 1 \u2265 3, this solution is optimal.\nLet us now contain the remaining FG states, which we call hard FG states. We now show the following:\nTheorem 3.3. The exit distance of hG is 2 for any hard FG state.\nProof. Let \u03c0 be a hard FG state, and let \u2113 \u2265 2 be the size of the rightmost strip of \u03c0. Then \u03c0 is of the form \u3008e1, ..., eN\u2212\u2113, N,N \u2212 1, ..., N \u2212 \u2113 + 1\u3009, where e1 to eN\u2212\u2113 are pancakes in the range from 1 to N \u2212 \u2113. Consider following sequence of moves:MN ,M\u2113, and thenMN . The result ofMN will be \u3008N \u2212 \u2113+1, ..., N \u2212 1, N, eN\u2212\u2113, ..., e1\u3009. M\u2113(MN (\u03c0)) will then be \u3008N,N \u2212 1, ..., N \u2212 \u21131, eN\u2212\u2113, ..., e1\u3009. The final application of MN will lead to the state \u3008e1, ..., eN\u2212\u2113, N \u2212 \u2113 + 1, ..., N \u2212 1, N\u3009. The gap between locations N and N + 1 in \u03c0 is now gone, while all other gaps remain. Thus, hG(MN (MN\u22121(MN (\u03c0)))) = h\nG(\u03c0) \u2212 1, and so the exit distance of \u03c0 is at most 2. Let us now show that the exit distance of \u03c0 is greater than 1. Since \u03c0 is locked, the exit distance is at least 1. We\nwill now show that for anyMi,Mi(\u03c0) cannot be an exit. There are three main cases to consider.\nCase 1:Mi is a gap increasing move.\nBecause of the consistency of hF and hG(Mi(\u03c0)) = h G(\u03c0) + 1, no neighbour of Mi(\u03c0) can have fewer than\nhG(\u03c0) gaps. As such,Mi(\u03c0) cannot be an exit in this case.\nCase 2:Mi is a gap neutral move that replaces one gap with another.\nSince the only gaps are between the strips, this means that location i must be the end of some strip. Suppose that it is at the end of the first strip (i.e. i is the length of the first strip). In this case, \u03c0 is of the form \u3008i, i\u2212 1, ..., 1, ...\u3009 and Mi(\u03c0) will be \u30081, 2, ..., i...\u3009. Pancake 1 is already on top of 2, and soMi(\u03c0) is locked and thus cannot be an exit.\nNow suppose that the size of the first strip is smaller than i. Let \u2113 be the size of the strip ending at location i and\nlet \u2113\u2032 be the size of the strip right before that strip. Then \u03c0 is of the following form:\n\u3008..., i \u2212 \u2113, i\u2212 \u2113\u2212 1, ..., i\u2212 \u2113\u2212 \u2113\u2032 + 1, i, ..., i\u2212 \u2113+ 2, i\u2212 \u2113+ 1...\u3009\nIn this state, pancake i\u2212 \u2113+ 1 is in location i. ThenMi(\u03c0) will be as follows:\n\u3008i\u2212 \u2113+ 1, i\u2212 \u2113+ 2, ..., i, i\u2212 \u2113\u2212 \u2113\u2032 + 1, ..., i\u2212 \u2113\u2212 1, i\u2212 \u2113, ...\u3009\nSinze i \u2212 \u2113 + 1 is the top pancake, the only possible locations for gaps that can be removed in Mi(\u03c0) are above pancakes i\u2212 \u2113+ 2 and i\u2212 \u2113. However, these pancakes do not have gaps above them. As such,Mi(\u03c0) is locked and is not an exit. Therefore,Mi(\u03c0) cannot be an exit ifMi is a gap neutral move that replaces one gap with another.\nCase 3:Mi is a gap neutral move that replaces one adjacency with another.\nLet \u2113 and \u2113\u2032 be the sizes of the first and second strips in \u03c0. By the definition of an FG state, \u03c0 is of the following\nform:\n\u3008\u2113, \u2113\u2212 1, ..., 1, \u2113+ \u2113\u2032, .., \u2113+ 2, \u2113+ 1, ...\u3009\nIn this state, \u2113 + 1 is in location \u2113 + \u2113\u2032. Since the top pancake \u2113 is already adjacent to pancake \u2113 \u2212 1, the only gap decreasing move that replaces one adjacency with another is M\u2113+\u2113\u2032\u22121 (i.e i = \u2113 + \u2113\n\u2032 \u2212 1). Applying this action to \u03c0 results in the following:\n\u3008\u2113+ 2, ...\u2113+ \u2113\u2032, 1, ...\u2113\u2212 1, \u2113, \u2113+ 1, ...\u3009\nBecause \u03c0 is a hard FG state, it is guaranteed to have at least 3 strips or a second strip with a size at least 3. If the second strip has a size of at least 3, then the second strip in \u03c0 ends in \u2113+3, \u2113+2, \u2113+1 and soMi(\u03c0) has the following form:\n\u3008\u2113+ 2, \u2113+ 3, ...\u2113+ \u2113\u2032, 1, ...\u2113\u2212 1, \u2113, \u2113+ 1, ...\u3009\nSince \u2113+2 is already beside \u2113+3 and \u2113 is on top of \u2113+1, there is no gap decreasing move inMi(\u03c0). As such,Mi(\u03c0) is locked and so it cannot be an exit.\nIf the second strip of \u03c0 is of size 2 (i.e. \u2113\u2032 = 2), then there are at least 3 strips. Let \u2113\u2032\u2032 be the size of the third strip. \u03c0 will necessarily have the following form:\n\u3008\u2113, \u2113\u2212 1, ..., 1, \u2113+ 2, \u2113+ 1, \u2113+ 2 + \u2113\u2032\u2032, ..., \u2113+ 4, \u2113+ 3, ...\u3009\nWe can now see thatM\u2113+\u2113\u2032\u22121(\u03c0) has the following form:\n\u3008\u2113 + 2, 1, ..., \u2113\u2212 1, \u2113, \u2113+ 1, \u2113+ 2 + \u2113\u2032\u2032, ..., \u2113+ 4, \u2113+ 3, ...\u3009\n\u2113 + 1 and \u2113 + 3 are both below pancakes that they should be adjacent to, so this state remains locked and thus cannot be an exit. Thus,Mi(\u03c0) is not an exit wheneverMi is a gap neutral move that replaces one adjacency with another.\nSinceMi(\u03c0) cannot be an exit in all cases, the exit distance of \u03c0 is at least 2. This completes the proof.\nThe results above show that the exit distance of any pancake state is at most 2."}, {"heading": "4 Conclusion", "text": "In this work, we have provided the complete proofs underlying a characterization of the topology of the gap heuristic. First, we showed that there is a gap neutral move in any non-goal locked state. Then, we provided a classification that organizes states into whether the number of gaps can be decreased in 1, 2, or 3 actions."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "The pancake puzzle is a classic optimization problem that has become a standard benchmark for heuristic search algorithms. In this paper, we provide full proofs regarding the local search topology of the gap heuristic for the pancake puzzle. First, we show that in any non-goal state in which there is no move that will decrease the number of gaps, there is a move that will keep the number of gaps constant. We then classify any state in which the number of gaps cannot be decreased in a single action into two groups: those requiring 2 actions to decrease the number of gaps, and those which require 3 actions to decrease the number of gaps.", "creator": "LaTeX with hyperref package"}}}