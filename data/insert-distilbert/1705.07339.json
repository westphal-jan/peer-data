{"id": "1705.07339", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2017", "title": "Combining tabu search and graph reduction to solve the maximum balanced biclique problem", "abstract": "the maximum balanced biclique problem is a well - sought known graph model with increasingly relevant applications in diverse domains. this paper introduces a novel algorithm, which combines an effective constraint - based tabu search procedure and two additional dedicated graph reduction validation techniques. we verify the effectiveness of the algorithm on 30 classical random benchmark graphs and 25 equally very large real - life sparse graphs from constructing the popular koblenz network entropy collection ( konect ). the results show that the algorithm improves the best - known results ( new york lower bounds ) for 10 weighted classical benchmarks and obtains the optimal solutions for 14 specific konect instances.", "histories": [["v1", "Sat, 20 May 2017 17:47:31 GMT  (109kb)", "http://arxiv.org/abs/1705.07339v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["yi zhou", "jin-kao hao"], "accepted": false, "id": "1705.07339"}, "pdf": {"name": "1705.07339.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Yi Zhou", "Jin-Kao Hao"], "emails": ["zhou@info.univ-angers.fr", "jin-kao.hao@univ-angers.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 5.\n07 33\n9v 1\n[ cs\n.A I]\n2 0\nM ay\nThe Maximum Balanced Biclique Problem is a well-known graph model with relevant applications in diverse domains. This paper introduces a novel algorithm, which combines an effective constraint-based tabu search procedure and two dedicated graph reduction techniques. We verify the effectiveness of the algorithm on 30 classical random benchmark graphs and 25 very large real-life sparse graphs from the popular Koblenz Network Collection (KONECT). The results show that the algorithm improves the best-known results (new lower bounds) for 10 classical benchmarks and obtains the optimal solutions for 14 KONECT instances. Keywords: Heuristics; clique problems; graph reduction; tabu search; large graphs."}, {"heading": "1. Introduction", "text": "Given a bipartite graph G = (U, V,E) with two disjoint vertex sets U , V and an edge set E \u2286 U \u00d7 V , a biclique (X,Y ) = X \u222a Y is the union of two subsets of vertices X \u2286 U , Y \u2286 V such that u \u2208 X, v \u2208 Y implies that {u, v} \u2208 E. In other words, the subgraph induced by the set of vertices X \u222a Y is a complete bipartite graph. If |X | = |Y |, then (X,Y ) is called a balanced biclique. The Maximum Balanced Biclique Problem (MBBP) is to find a balanced biclique (X\u2217, Y \u2217) of maximum cardinality of G, (X\u2217, Y \u2217) being the maximum balanced biclique of size |X\u2217| (or |Y \u2217|) (Garey & Johnson, 1979).\nAs shown in (Dawande et al., 2001), by following a well-known integer linear programming model of the more general maximum vertex weight biclique problem, MBBP can be formulated as a binary linear program as follows.\nmax \u03c9(G) =\n|U| \u2211\ni=1\nxi (1)\n\u2217Corresponding author Email addresses: zhou@info.univ-angers.fr (Yi Zhou), jin-kao.hao@univ-angers.fr\n(Jin-Kao Hao)\nPreprint submitted to Elsevier May 23, 2017\nsubject to: xi + xj \u2264 1, \u2200{i, j} \u2208 E\u0304 (2)\n|U| \u2211\ni=1\nxi \u2212\n|U|+|V | \u2211\nj=|U|+1\nxj = 0 (3)\nxi, xj \u2208 {0, 1} (4)\nwhere each vertex of U \u222a V is associated to a binary variable xi indicating whether the vertex is part of the biclique, E\u0304 is the set of edges in the bipartite complement of G. Objective (1) maximizes the size of the biclique. Constraint (2) ensures that each pair of non-adjacent vertices cannot be selected at the same time (i.e., the solution must be a clique). Equation (3) enforces that the returned biclique is balanced.\nIn terms of computational complexity, the decision version of MBBP is NPcomplete in the general case (Garey & Johnson, 1979; Alon et al., 1994), even though the maximum biclique problem without the balance constraint (Eq. (3)) is polynomially solvable by the maximum matching algorithm (Cheng and Church, 2000).\nMBBP is a prominent model with many applications. For example, in nanoelectronic system design, MBBP is used to identify the maximum defect-free crossbar from a partially fabricated defective crossbar represented by a bipartite graph (Tahoori, 2006; Yamani et al., 2007). In computational biology, MBBP is applied to simultaneously group genes and their expressions under different conditions (called biclustering) (Cheng and Church, 2000). Another application can be found in the field of VLSI for PLA-folding (Ravi & Lloyd, 1988). Generally, the clique and biclique models are also popular tools for winner determination in combinatorial auctions (Wu & Hao, 2015a), tail dependence structure analysis of the foreign exchange market (Wang & Xie, 2016), co-location feature pattern mining in space (Yan et al., 2015).\nGiven the significance of MBBP as a NP-hard problem and its relevance in practice, a number of methods, including approximate, exact and heuristic algorithms have been proposed and investigated in the literature. For example, in (Feige & Kogan, 2004), the relations between the approximate hardness of MBBP and 3-SAT as well as the maximum clique problem were established. In (Mubayi & G. Tura\u0301n, 2010), despite the NP-hardness of MBBP, a polynomial algorithm was given to find a balanced biclique with size \u230a lnnln (2en2/m)\u230b (the cardinality of |X | or |Y |) for a graph with n vertices and m edges. In (Tahoori, 2006), a recursive exact algorithm for searching a maximum balanced biclique with a given size was proposed. However, the computational time of this algorithm becomes prohibitive when the number of vertices of the graph exceeds (32, 32). In (McCreesh & McCreesh, 2014), another exact approach for MBBP for general (non-bipartite) graphs was studied. This algorithm follows the classical branch and bound framework for the popular maximum clique problem (Wu & Hao, 2015b) with additional symmetry breaking techniques.\nTo cope with the computational challenge of MBBP, heuristic methods constitute an interesting approach. These methods aim to obtain satisfactory solutions in an acceptable time frame without guaranteeing the optimality of the attained solutions. From an algorithmic point of view, rather than directly seeking the maximum balanced biclique in the given graph, the majority of existing heuristic algorithms solved the equivalent maximum balanced independent set problem for the bipartite complement. For example, Tahoori (2006) proposed a greedy heuristic algorithm based on vertex-deletion, which iteratively removes vertices with maximum degree from the bipartite complement until the set of remaining vertices forms an independent set (i.e., a set of vertices such that no edge exists between any pair of vertices in the graph). Yamani et al. (2007) presented an improved greedy heuristic, in which the vertex connecting the maximum number of vertices of minimum degree is removed. Yuan & Li (2011) introduced another greedy heuristic algorithm, which iteratively deletes vertices adjacent to the maximum number of vertices in a restricted set. Then Yuan & Li (2014) accelerated this algorithm by removing multiple vertices at each iteration. Recently, Yuan et al. (2015) proposed a powerful (and rather complex) evolutionary algorithm combining structure mutation and repair-assisted restart. The computational results showed that this algorithm performed very well on random dense graphs, which represent one type of the most challenging instances for MBBP. We will use this algorithm as one of the main references for our comparative studies.\nOn the other hand, graphs from real-life applications like social networks and biological networks are usually very large with millions even billions of vertices, rendering most existing approaches unpractical. In this study, we aim to fill the gap by developing improved methods for MBBP, which should be able to handle both random dense graphs and very large real-life networks. Based on an analysis of the studied problem and existing algorithms (Section 3.1), we introduce a new and effective algorithm named tabu search with graph reduction for MBBP (TSGR-MBBP), which combines an original Constraint-Based Tabu Search (CBTS) and two dedicated graph reduction techniques. We identify the main contributions of this study as follows.\n1. From an algorithmic perspective, the proposed TSGR-MBBP algorithm seeks maximum balanced bicliques directly on the given graph. Compared to the existing approaches which search for balanced independent sets on the complement, operating on the given graph has an advantage of requiring less memory for large sparse graphs. More importantly, TSGR-MBBP employs the Constraint-Balanced Tabu Search algorithm to effectively explore the search space (Section 3.4) and two bound-based dedicated reduction techniques to shrink progressively the given graph (Sections 3.5 and 3.6). This is the first study combining local optimization and graph reduction within the iterated search framework for MBBP.\n2. We demonstrate the effectiveness of the proposed algorithm on two sets of 55 MBBP benchmark instances (Section 4). For the set of 30 random\nchallenging instances, the algorithm dominates state-of-the-art algorithms including the current best-performing algorithm presented in (Yuan et al., 2015) and the powerful mixed integer programming solver CPLEX. The algorithm also obtains 10 improved best solutions (i.e., new lower bounds) and matches the best-known results for the remaining 20 instances. For the 25 very large real-life instances from the well-known Koblenz Network Collection, the algorithm proves, for the first time, the optimal solutions for 14 instances (by obtaining the same upper and lower bounds) and obtains tight lower bounds (better than those of CPLEX) for the remaining instances. We also show an analysis of key components (CBTS and the reduction methods) to get insight of their usefulness (Section 5).\nThe remainder of the paper is organized as follows. Section 2 provides some useful notations. Section 3 introduces the proposed algorithm. Computational results on benchmark instances are presented in Section 4. Section 5 shows an analysis of the key components of the proposed algorithm, followed by conclusions in the final section."}, {"heading": "2. Preliminary definitions", "text": "Let G = (U, V,E) be a bipartite graph, we introduce the following notations and definitions which are needed for the description of the proposed approach.\n- Given a vertex v \u2208 U \u222a V , N(v) denotes the set of vertices adjacent to v, i.e., N(v) = {u : {v, u} \u2208 E}. Clearly, if v \u2208 U , then N(v) \u2286 V , otherwise, N(v) \u2286 U .\n- Given S \u2286 U \u222a V , N(S) denotes the subset of vertices from (U \u222a V ) \\ S that are adjacent to at least one vertex in S, i.e., N(S) = ( \u22c3\ni\u2208S\nN(i)) \\ S.\n- Given X \u2286 U , Y \u2286 V , G[X \u222a Y ] = (X,Y,E(X \u222a Y )) denotes the subgraph induced by X \u222a Y . If G[X \u222a Y ] is a complete bipartite graph, i.e., E(X,Y ) = X \u00d7 Y , then X \u222a Y is a biclique, which is also denoted by (X,Y ).\n- Given a biclique (X,Y ), the balanced size of (X,Y ) is min(|X |, |Y |), and the balance deviation is ||X | \u2212 |Y ||. If the balance deviation is 0, (X,Y ) is a balanced biclique of size |X | (or |Y |).\nFigure 1 illustrates the above definitions with a bipartie graph composed of 8 vertices and 13 edges.\nLet \u2126(G) denote the search space composed of all balanced bicliques in G, \u2126k be the relaxed search space including all bicliques with a balance deviation no more than k (k \u2265 0), i.e., \u2126k = {(X,Y ) : X \u2286 U, Y \u2286 V,E(X,Y ) = X \u00d7 Y, ||X | \u2212 |Y || \u2264 k}, then, as explained in the next section, our algorithm explores bicliques in the (slightly) relaxed search space \u21262 (i.e., with a balance\ndeviation limited to 2) rather than the search space of strictly balanced bicliques \u2126(G) (i.e., \u21260).\nFinally, the quality of a biclique (X,Y ) in \u2126k is measured by its balanced size min(|X |, |Y |). Given two bicliques (X1, Y1) and (X2, Y2), (X1, Y1) is better than (X2, Y2) if min(|X1|, |Y1|) > min(|X2|, |Y2|)."}, {"heading": "3. Tabu search with graph reduction", "text": "This section introduces our proposed TSGR-MBBP algorithm for solving the maximum balanced biclique problem. TSGR-MBBP is based on the wellknown tabu search metaheuristic (Glover & Laguna, 1997), which is specifically adapted to the MBBP problem. Indeed, tabu search being a general method, it is critical to find a suitable adaptation of the method to the considered problem (e.g., (D\u0131\u0301az et al., 2017; Elhedhli et al., 2014; Ma et al., 2017)). For our MBBP problem, we proposed the constraint-based tabu search (Section 3.4), which is able to effectively explore the search space of slightly unbalanced bi-cliques. In order to help tabu search to avoid non-promising search regions, we introduce two bound-based graph reduction techniques to shrink progressively the given graph (Sections 3.5 and 3.6)."}, {"heading": "3.1. Rationale of the proposed approach", "text": "Many real-life networks have millions or even billions of vertices with a very low edge density. Existing approaches for solving MBBP rely heavily on the complement and the adjacent matrix representation. Unfortunately, the complement of such a massive graph usually results in very high memory consumption, making most of existing MBBP approaches unpractical. To avoid this difficulty, the proposed algorithm operates directly on the given graph, implying that much less memory is required for processing very large real-life sparse networks. From an algorithmic perspective, our algorithm iteratively seeks improved solutions by local search combined with graph reduction strategies. Specifically, the algorithm starts from an initial solution (a slightly relaxed balanced biclique) and uses move operators to improve the solution iteratively. However, we still\nneed to answer a crucial question: how to improve the solution effectively while maintaining the two main constraints of a solution (balanced and biclique)?\nIntuitively, local search operators that are successful for the maximum clique problem (Wu & Hao, 2015b) can be applied to MBBP, such as \u201cadd\u201d (adding a vertex to the solution), \u201cswap\u201d (exchanging a vertex in the solution with another vertex out of the solution) or still \u201cdrop\u201d (dropping a vertex from the solution). However, given a balanced biclique, an application of any of these operators results in an unbalanced biclique. To cope with this difficulty, we propose to (slightly) relax the balance requirement of the solution and allow the algorithm to explore both balanced and slightly unbalanced bicliques. For this purpose, we adopt the generalized \u201cpush\u201d operator initially designed for the maximum vertex weight clique problem (Zhou et al., 2017) to explore solutions within the relaxed search space \u21262 rather than \u21260.\nAnother key idea we used is graph reduction. Given a bipartite graph G and a known best balanced size \u03c9 (a lower bound), it is clear that to further improve \u03c9, it is useless to consider any vertex whose degree is smaller than or equal to \u03c9 since such a vertex can in no way extend the best solution found so far. Consequently, these vertices (with a degree smaller than or equal to \u03c9) along with the incident edges can be safely removed from the graph. Our algorithm integrates this idea to dynamically prune the graph under consideration, which proves to be highly effective on massive sparse graphs.\nFinally, applying the pruning techniques can disconnect the original graph into several connected subgraphs. This observation can be explored advantageously to further prune the graph in combination with an exact algorithm. Indeed, if a subgraph is small enough such that an exact algorithm can identify the maximum balanced biclique quickly, then the subgraph can be definitively removed since the subproblem (associated to the subgraph) is optimally solved. Moreover, the optimal solution of this subgraph can also be used to update the current best balanced biclique (and the lower bound bound), which can lead to additional reduction of the graph."}, {"heading": "3.2. General procedure", "text": "Based on the rationale presented in Section 3.1, we introduce Tabu Search with Graph Reduction for MBBP (TSGR-MBBP) (Algorithm 1). TSGR-MBBP is an iterated two phase algorithm and includes two main components: the Constraint-Based Tabu Search (CBTS) procedure and the graph reducing procedure. The CBTS procedure is used to find high quality bicliques in the relaxed search space \u21262, while the graph reducing procedure aims to shrink progressively the current graph without losing optimal solutions.\nAfter setting the best biclique (Xb, Y b) to (\u2205, \u2205) and the best balanced size \u03c9 to 0 (lines 2 and 3), the algorithm repeats the main \u2018while\u2019 loop (lines 4-20) until a stopping condition is met. For each \u2018while\u2019 loop, an initial biclique, which is not necessarily balanced, is first generated by Random Init Solution() (line 5, see Section 3.3), and then further improved by the CBTS procedure (Constraint Tabu Improve(), line 6, see Section 3.4). If the resulting biclique\nhas a balanced size larger than the current best balanced size \u03c9, the best biclique (Xb, Y b) and the best balanced size are updated (lines 7-9).\nAlgorithm 1: Main framework of TSGR-MBBP\nInput: Graph instance G = (U, V,E), tabu search depth L, cardinality threshold K for graph reduction with exact algorithm, tabu tenure parameter \u03b1.\nOutput: The maximum balanced biclique. begin1 (Xb, Y b) \u2190 (\u2205, \u2205); /* The largest balanced biclique found so far */2 \u03c9 = 0 ; /* The largest balanced size found so far */3 while stopping condition is not met do4\n// Find an improved biclique from a new initial biclique\n(X,Y ) \u2190 Random Init Solution(G) ; /* Section 3.3 */5 (X,Y ) \u2190 Constraint Tabu Improve(G, (X,Y ), L, \u03b1) ; /* Section 3.46 */ if min(|X|, |Y |) > \u03c9 then7 (Xb, Y b) \u2190 (X,Y );8 \u03c9 \u2190 min(|X|, |Y |)9\n// Graph reduction procedure using improved balanced size \u03c9\nwhile \u03c9 \u2265 minv\u2208U\u222aV {|N(v)|} do10 // The first graph reduction G \u2190 Peel(G,\u03c9) ; /* Section 3.5 */11 // The second graph reduction for each connected subgraph Gi[Ui \u222a Vi] in G do12 if |Ui|+ |Vi| \u2264 K then13 (X,Y ) \u2190 Exact Search(Gi, \u03c9) ; /* Section 3.6 */14 if min(|X|, |Y |) > \u03c9 then15 (Xb, Y b) \u2190 (X, Y );16 \u03c9 \u2190 min(|X|, |Y |)17\nG \u2190 G[(U \\ Ui) \u222a (V \\ Vi)]18\nif |U | \u2264 \u03c9 \u2228 |V | \u2264 \u03c9 then19 return Make Balance(Xb, Y b) ; /* (Xb, Y b) is an optimum20 solution */\nend21 return Make Balance(Xb, Y b)22\nNow, if the current best balanced size is greater than or equal to the degree of any vertex in the current graph, the graph reduction procedure is activated (lines 10-18). This procedure includes two phases: first, reducing the current graph by the Peel procedure to remove fruitless vertices and their incident edges (line 11, see Section 3.5); second, determining the maximum balanced size of each connected subgraphs with up to K (a predefined parameter) vertices by a branch-and-bound (B&B) exact algorithm (Exact Search(), line 14, see Section 3.6) and then deleting these subgraphs from the current graph (line 18). The optimal solution found by exact search can also be used to update the current\nbest solution found so far (lines 15-17). Finally, though TSGR-MBBP is a heuristic algorithm, thanks to the graph reduction procedure, \u03c9 is proven to be the optimal balanced size when the cardinality of any partition (|U | or |V |, which is a upper bound of the maximum biclique) in the current graph is no more than \u03c9 (which is a lower bound) (lines 19-20).\nAs explained in Section 2, the proposed algorithm operates on the relaxed biclique space \u21262. As a result, the current solution (X,Y ) and the best biclique found so far (Xb, Y b) are not necessarily balanced with nevertheless a balance deviation limited to 2. Actually, the three procedures: Random Init Solution(), Constraint Tabu Improve() and Exact Search() generate or return a biclique with a balance deviation no more than 2. The procedure of retrieving a strict balanced biclique of size \u03c9 from an unbalanced biclique is accomplished by Make Balance(). This procedure simply removes vertices from the larger set Xb or Y b until a balanced biclique of size \u03c9 is obtained. Obviously, no more than 2 vertices will be removed by Make Balance()."}, {"heading": "3.3. Construct random initial solutions", "text": "The Random Init Solution() procedure is invoked to initialize each restart of TSGR-MBBP with a new biclique. This procedure starts from a trivial solution formed by a random vertex from U \u222a V , say (X,Y ) = ({1}, \u2205) (without loss of generality). Then, it iteratively expands the current solution by alternatively adding one vertex v to the set X or Y , v being necessarily connected to all vertices of the other set. Specifically, in the first iteration, a vertex is selected randomly from the candidate set \u2229i\u2208XN(i) \\Y . Then, in the next iteration, we switch to the candidate set \u2229i\u2208Y N(i) \\ X . The procedure continues until the current candidate set becomes empty. The time complexity of this procedure is bounded by O(|U \u222a V | \u00d7 |E|).\nConsider Figure 1 as an example and suppose that we start from solution (X,Y ) = ({1}, \u2205), the algorithm expands the solution by selecting an arbitrary vertex from N(1) \\ \u2205 = {5, 6, 8} (say 5) in the first iteration. In the second iteration, the algorithm expands Y by adding a vertex from N(5) \\ {1} = {2, 3, 4}. Suppose that the algorithm goes on likewise to achieve a solution (X,Y ) = ({1, 2, 3}, {5, 6}) after four iterations. Then in the fifth iteration, we try to expand Y by adding a vertex from the candidate set \u2229i\u2208N(X) \\ Y . However, since this candidate becomes empty, the Random Init Solution() procedure stops and returns (X,Y ) = ({1, 2, 3}, {5, 6}) as its output.\nThe biclique (X,Y ) returned by this procedure may not be strictly balanced, but the balance deviation can never exceed 1. This biclique is served as the starting solution for the tabu search procedure which is explained below."}, {"heading": "3.4. Constraint-Based Tabu Search", "text": "The CBTS procedure (Algorithm 2) is the main search component of the proposed algorithm. CBTS iteratively transforms the current solution (biclique) to a neighbor solution while respecting the unbalance limit of 2. The parameter L (a positive integer) is called tabu search depth, which defines the total number\nof iterations of tabu search. The other parameter, \u03b1 \u2208 R+ \u222a{0}, is a coefficient of tabu tenure (see Section 3.4.2). In each iteration, CBTS applies the \u201cpush\u201d operator (lines 5-14, see Section 3.4.1), which either adds a vertex to the current solution or swaps a vertex of the biclique against a vertex outside of the biclique. Whenever the balance deviation exceeds 2 after an application of \u201cpush\u201d, a repairing procedure is followed to recover the balance of the current biclique (lines 15-23, see Section 3.4.2). The repairing procedure simply drops vertices from the larger partition of the biclique until the cardinality of both partitions becomes equal. CBTS terminates after L such \u201cpush\u201d and \u201crepair\u201d iterations."}, {"heading": "3.4.1. The push operator", "text": "The \u201cpush\u201d operator was first proposed for the maximum weight clique problem in (Zhou et al., 2017) where each application of \u201cpush\u201d adds a vertex (taken from a candidate set) in the clique and expels p \u2265 0 vertices from the clique to maintain the feasibility of the transformed clique. In the context of MBBP, given a biclique (X,Y ) with X \u2286 U and Y \u2286 V , and without loss of generality, suppose that a vertex v \u2208 N(Y ) \\X (i.e., N(Y ) \\X is the candidate set for \u201cpush\u201d) is chosen. The \u201cpush\u201d operator adds vertex v to X and expels from Y the vertices that are not adjacent to v. Let (X \u2032, Y \u2032) denotes the new biclique after the \u201cpush\u201d operation, then we represent this transformation by (X \u2032, Y \u2032) \u2190 (X,Y )\u2295 push(v).\nSimilarly, if v \u2208 N(X) \\ Y , (X \u2032, Y \u2032) = (X \u2229 N(v), Y \u222a {v}), \u03b4v is updated by the same rule except that the roles of X and Y are exchanged.\nThe \u201cpush\u201d operator can be explained as a generalization of the conventional (1, p)-swap (p \u2208 Z0) operator. For example, if we restrict the candidate vertex v with property N(v) \u2229 X = X or N(v) \u2229 Y = Y , push(v) is equivalent to adding v without expelling any vertex (i.e., (1, 0)-swap); if we restrict v with property |X \\ N(v)| = 1 or |Y \\ N(v)| = 1, push(v) exchanges v with another vertex in X or Y that is not adjacent to v (i.e., (1, 1)-swap). Actually, the two restrictions are employed in our CBTS algorithm to customize the \u201cpush\u201d operator, as explained in the next section.\nLet \u03b4v = min(|X \u2032|, |Y \u2032|)\u2212min(|X |, |Y |) be the change of the balanced sizes between (X \u2032, Y \u2032) and (X,Y ), then \u03b4v can be calculated by the following rule.\n\u03b4v \u2190\n{\n\u2212|Y \\N(v)| , if |X | > |Y | min(1, |Y | \u2212 |X | \u2212 |Y \\N(v)|) , otherwise\n(5)\nAlgorithm 2: Constraint-Based Tabu Search\nInput: Graph instance G = (U, V,E), starting solution (X,Y ), tabu search depth L, tabu tenure parameter \u03b1.\nOutput: The best biclique (X\u2217, Y \u2217) found. begin1 I \u2190 0, (X\u2217, Y \u2217) \u2190 (X,Y ); /* I is the iteration counter, (X\u2217, Y \u2217)2 keeps the best biclique found so far */ T [1...n] \u2190 [0...0]n ; /* initiate tabu list, each vertex v being3 marked tabu for the next T [v]th iterations; n = |U |+ |V | */ while I \u2264 L do4\n// Explore the neighbor solutions\nBuild Cexpand \u2286 C and Cplateau \u2286 C ; /* Decompose candidate set,5 see Section 3.4.2 */ v \u2190 null;6 if Cexpand 6= \u2205 then7 v \u2190 random(Cexpand) ;8\nelse if Cplateau 6= \u2205 then9 v \u2190 random(Cplateau) ;10\nif v 6= null then11 (X,Y ) \u2190 (X,Y )\u2295 push(v) ;12 // Set tabu tenure for each vertex expelled by push. for u \u2190 expelled vertex do13 T [u] \u2190 I + tt(\u03b1, |S|) ; /* S = X if u \u2208 X, otherwise S = Y14 */\n// Recover balance when the balance deviation exceeds 2\nif ||X| \u2212 |Y || > 2 then15 while |X| > |Y | do16 u \u2190 random(X) ;17 (X,Y ) \u2190 (X,Y )\u2295 drop(u) ;18 T [u] \u2190 I + tt(\u03b1, |X|) ; /* Set tabu tenure for the dropped19 vertex */\nwhile |X| < |Y | do20 u \u2190 random(Y ) ;21 (X,Y ) \u2190 (X,Y )\u2295 drop(u) ;22 T [u] \u2190 I + tt(\u03b1, |Y |) ;23\n// update the best solution\nif min(|X|, |Y |) > min(|X\u2217|, |Y \u2217|) then24 (X\u2217, Y \u2217) \u2190 (X,Y )25\nI \u2190 I + 126\nend27 return (X\u2217, Y \u2217)28"}, {"heading": "3.4.2. Explore the neighbor solutions", "text": "The general \u201cpush\u201d operator applied to MBBP can add an arbitrary vertex from the candidate set N(X \u222a Y ) into one set X or Y , and then expel p \u2265 0\nvertices from the other set. However, for the reason of computational efficiency, only a subset of N(X \u222aY ) is considered for each \u201cpush\u201d operation. Specifically, we add restrictions on the candidate vertices for the \u201cpush\u201d operation so that it adds one vertex to the current solution and at the same time, no more than one vertex from the current solution will be expelled. These restrictions lead exactly to the two cases that were introduced at the end of Section 3.4.1. In Algorithm 2, set C (line 5) includes the restricted candidate vertices for \u201cpush\u201d. Every vertex in C is adjacent to all the vertices of X (or Y ), or all but one vertex of X (or Y ).\nMoreover, Cexpand is a subset of C such that applying \u201cpush\u201d to any vertex (say v) of this subset always results in a solution of better quality (i.e., \u03b4v > 0). Similarly, Cplateau \u2286 C includes the vertices that can be exchanged by \u201cpush\u201d to obtain solutions of equal quality (i.e., \u03b4v = 0).\nTo prevent CBTS from revisiting recently examined solutions, a tabu list (Glover & Laguna, 1997) is considered when we construct Cexpand and Cplateau from candidate set C: a vertex which is marked tabu in the current iteration will not be included in Cexpand or Cplateau unless pushing the vertex into the solution leads to a solution better than the best solution ever found (this is called aspiration rule in tabu search terminology). To sum up, let (X,Y ) and (X\u2217, Y \u2217) be respectively the current solution and the best solution found so far during the current CBTS run, I the current iteration number, T [v] the tabu tenure of vertex v (see below), then the restricted candidate set C, and sets Cexpand, Cplateau are defined as follows.\nC = {v \u2208 N(X \u222a Y ) : v \u2208 U \u2227 |N(v) \u2229 Y | \u2265 |Y | \u2212 1, v \u2208 V \u2227 |N(v) \u2229X | \u2265 |X | \u2212 1} Cexpand = {v \u2208 C : \u03b4v > 1, T [v] \u2264 I \u2228min(|X |, |Y |) + 1 > min(|X \u2217|, |Y \u2217|)}\nCplateau = {v \u2208 C : \u03b4v = 0, T [v] \u2264 I}\n(6)\nwhere T [v] \u2264 I indicates that vertex v is no more forbidden by the tabu list for the current iteration and can take part in a future \u201cpush\u201d operation.\nGiven the subsets Cexpand, Cplateau as two alternative candidate sets for \u201cpush\u201d, CBTS gives priority to Cexpand since pushing vertices of this set always improves the current biclique. Only when Cexpand is empty, set Cplateau is explored by the \u201cpush\u201d operator (lines 6-14). After each \u201cpush\u201d application with Cplateau, the vertex expelled by \u201cpush\u201d (u in line 13) is marked tabu for the following tt(\u03b1, |A|) (A = X if u \u2208 X , otherwise A = Y ) consecutive iterations. According to (Zhou et al., 2017), tt(\u03b1, l) (called tabu tenure) is defined by the function: tt(\u03b1, l) = max(7, \u03b1 \u2217 random(l)) where \u03b1 \u2208 R+ \u222a {0} is a predefined parameter and random(l) returns a random integer in [0, l]."}, {"heading": "3.4.3. Recover biclique balance", "text": "Recall that with the restrictions on candidate vertices, the number of vertices expelled by \u201cpush\u201d in each iteration is either zero or one. As a result, if the balance deviation of the current biclique is greater than 2 (i.e., ||X |\u2212 |Y || > 2),\nit is impossible to make the biclique strictly balanced with one application of the \u201cpush\u201d operator. Consequently, each time the balance deviation of the solution exceeds 2, we restore the balance property by applying a repair procedure (lines 15-23). This repair procedure simply drops vertices from the larger set (X or Y ) of the biclique until the solution becomes strictly balanced (denoted as (X,Y ) \u2190 (X,Y ) \u2295 drop(u) at lines 18 and 22). Again, each dropped vertex u is forbidden to rejoin the solution during the period fixed by its tabu tenure (tt(\u03b1, |X |) if u \u2208 U , tt(\u03b1, |Y |) if u \u2208 V ). In general, CBTS utilizes the \u201cpush\u201d operator to explore the space \u21262 rather than \u21260 by constraining the balance deviation of the visited solutions. In Section 5.1, we further investigate the effectiveness of this strategy."}, {"heading": "3.4.4. Time complexity", "text": "CBTS operates directly on the input graph and uses the adjacent list representation to store the graph. Given a solution (X,Y ), by our implementation, the time complexity of constructing Cexpand and Cplateau is bounded by O(|N(X\u222aY )|). The time complexity of moving one vertex (outside the solution or into the solution) is bounded by O(M) (M = maxv\u2208U\u222aV {|N(v)|}). Hence, the time complexity of one iteration in CBTS is bounded by O(|N(X \u222a Y )| + 2 \u00d7 M). Though |N(X \u222a Y )| is almost equal to |U | + |V | in dense graphs, in very large real-life networks, both |N(X \u222a Y )| and M are very limited due to the sparsity of the graphs.\n3.5. Reduction by the Peel procedure\nOur TSGR-MBBP algorithm employs the Peel(G,w) procedure (Algorithm 1, line 11) to recursively delete all vertices whose degrees are smaller than or equal to \u03c9 until no such vertex exists. Obviously, if the cardinality of one vertex set of the reduced bipartite graph (which is a upper bound of the maximum biclique) is less than or equal to \u03c9 (which is a lower bound), then \u03c9 must be the optimal objective value because no better solution can exist in the reduced graph (Algorithm 1, lines 19-20).\nThe peeling procedure is triggered each time the balanced size of the largest biclique discovered so far (lower bound) is larger than or equal to the minimum degree of the current graph. This procedure is effective on large sparse graphs but may not reduce a dense graph much. The experiments reported in Section 4 confirm that, with a high quality lower bound, large real-life bipartite graphs can be significantly reduced.\nWe note that the idea of reducing a graph by removing unpromising vertices was previously used in a GRASP heuristic for detecting dense subgraphs (quasi-cliques) in massive sparse graphs (Abello et al., 2002). We adapted this technique for solving MBBP for the first time."}, {"heading": "3.6. Reduction by exact search", "text": "Exact search algorithms guarantee the optimality of the solution found, but may require prohibitive computing time on large instances. However, since exact\nsearch algorithms are able to prove optimality on small graphs rapidly, they can still be used as a basis for graph reduction. In Algorithm 1 (lines 12-18), we show such an approach of using exact search for MBBP. If a solution has been confirmed to be optimal for a subgraph of the current graph, this subgraph can be safely eliminated from the current graph. Moreover, since the optimal value of the subgraph is a lower bound of the initial graph, we can use the optimal solution of the subgraph to update the current best balanced biclique, which in turn can further reduce the current graph. The exact algorithm used by TSGRMBBP was adapted from a well-known B&B algorithm for the maximum clique problem (Carraghan & Pardalos, 1990) and described in Appendix Appendix A. This exact algorithm is only applied to solve a subgraph with K vertices at most (K being the largest subgraph that is estimated to be solved in reasonable time by the algorithm). It is clear that K depends on the adopted exact algorithm and target subgraph. According to our experiments, we set K to 100 for random dense graphs and 500 for sparse real-life networks."}, {"heading": "4. Computational assessment", "text": "To comprehensively evaluate the proposed TSGR-MBBP algorithm as well as its components, we tested our algorithm on two sets of benchmark instances including both (dense) random graphs and massive real-life networks."}, {"heading": "4.1. Benchmark", "text": "\u2022 Random Graphs: This set of benchmark instances includes 30 randomly generated dense graphs. In each graph, the two vertex sets U and V have an equal cardinality (i.e., |U | = |V |) and an edge between a pair of vertices (u, v) \u2208 U \u00d7 V exists with uniform probability p (0 < p < 1) which defines the edge density of the graph. For our study, we used random graphs generated by the same rule of (Yuan et al., 2015) so that the performances of different algorithms can be compared. For each combination of n \u2208 {250, 500} and p \u2208 {0.85, 0.90, 0.95} (n = |U | = |V |), 5 instances were generated (30 in total). These instances are thus very dense and named as \u201cG <n> <p> <id>\u201d where id \u2208 {1, 2, 3, 4, 5}. A theoretical analysis in (Dawande et al., 2001) showed that the maximum balanced size \u03c9 in random graphs locates in range [ lnnln(1/p) , 2\u2217lnn ln(1/p) ] with high prob-\nability (when n is sufficiently large).\n\u2022 The Koblenz Network Collection (KONECT) (Kunegis, 2013): The entire collection contains hundreds of networks derived from different real-life applications, including social networks, hyperlink networks, authorship networks, physical networks, interaction networks and communication networks. Though KONECT dataset was originally designed for network analysis, these large bipartite networks are also suitable for testing TSGRMBBP. We used 25 bipartite graphs varying from smaller ones (829 + 551\nvertices and 1476 edges) to very large ones (1,425,813 + 4,000,150 vertices and 8,649,016 edges). Irrelevant graph information for MBBP like multiple edges, vertex or edge weight in some graphs is ignored."}, {"heading": "4.2. Parameter tuning and experimental protocol", "text": "The TSGR-MBBP algorithm has three parameters: L - the tabu search depth; \u03b1 - the coefficient for tabu tenure required by the Constraint Tabu Improve() procedure (Section 3.4); K - the threshold on the number of vertices of the subgraph for graph reduction with the exact algorithm (Section 3.6).\nSince the first two parameters (L and \u03b1) are independent from the reduction procedure, we tuned them on a simplified version of TSGR-MBBP without the graph reduction procedure (i.e., by disabling lines 10-20 in Algorithm 1). We used the automatic parameter configuration package iRace (Lo\u0301pezIba\u0301nez et al., 2011), which implements the Iterated F-Race (IFR) method. Given L \u2208 {10, 100, 1000, 5000, 10000}, and \u03b1 \u2208 [0, 2], for each parameter configuration, we used a tuning budget of 500 hook-runs, each of which representing 10 independent calls of TSGR-MBBP. The training set for random graphs included 6 challenging instances, i.e., GraphU 500 XXX 1.clq and GraphU 500 XXX 2.clq (XXX can be replaced by 0.95, 0.90, 0.85). The experiments suggested that the combination (L = 1000, \u03b1 = 0.30) was a suitable configuration for random graphs. As for KONECT graphs, the training set included \u201cactor-movie\u201d, \u201cbookcrossing full-rating\u201d, \u201cdbpedia-genre\u201d, \u201cdbpediateam\u201d, \u201cgithub\u201d, \u201cstackexchange-stackoverflow\u201d. The final choice of parameters was L = 100 and \u03b1 = 1.74.\nThe use of two different settings for (L, \u03b1) is mainly due to the graph structures which vary much. According to our observations, for random dense graphs, a more intensified search is needed to find quality solutions. This is achieved with a large tabu search depth (L = 1000) and a short tabu tenure (with \u03b1 = 0.30). On the contrary, for large real-life sparse instances, the tabu search component is able to reach local optima very quickly. As a result, it is preferable to restart more frequently the tabu search component (with L = 100) and diversify more strongly the search during the optimization process (using a larger tabu tenure with \u03b1 = 1.74).\nThe third parameter K indicates the largest subgraph that can be solved in reasonable time by the exact algorithm described in Section 3.6. We set K = 100 for random graphs and 500 for KONECT graphs. In effect, since the random graphs we tested are very dense, they cannot be reduced by the reduction procedure, implying that no connected subgraph with less than 100 vertices exists in this set of benchmarks. A very large K is not acceptable, otherwise the computing time for exact search becomes prohibitive according to our observations for random graphs. Preliminary experiments also confirmed that the time consumption was normally insignificant (less than 2 seconds) for connected subgraphs with less than 500 vertices for sparse KONECT graphs. As the vertex number is just a rough estimation of the hardness of the subgraph for our exact algorithm, we terminate the exact algorithm if it does not finish during 10 seconds. This additional cutting-off condition prevents the algorithm\nfrom spending too much effort in searching optimal solutions for some potential hard subgraphs. If the exact search stops without giving an optimal solution, the corresponding subgraph will not be removed.\nTSGR-MBBP was implemented in C++ and compiled with g++ v4.4.7 with optimization flag -o3. Our experiments were performed on a computer with an AMD Opteron 4184 processor (2.8GHz and 2GB RAM) running Linux 2.6.32. When solving the DIMACS machine benchmark procedure \u2018dfmax.c\u20191 without compilation optimization flag, the run time on our machine is 0.40, 2.50 and 9.55 seconds for graphs r300.5, r400.5 and r500.5 respectively.\nConsidering the stochastic nature of TSGR-MBBP, we ran TSGR-MBBP 20 independent times to solve each instance. For the random graphs of 250 vertices, the time limit of each run was 30 seconds, while for the random graphs of 500 vertices, 60 seconds were allowed. As for the KONECT instances, we prolong this limitation to 360 seconds (6 minutes) since these instances are much larger than the random graphs."}, {"heading": "4.3. Computational results", "text": ""}, {"heading": "4.3.1. Random graphs", "text": "To evaluate the performance of TSGR-MBBP, we show computational results relative to three state-of-the-art MBBP approaches:\n- EA/SM (Yuan et al., 2015): This is a hybrid algorithmmixing local search, structure mutation and repair-assisted restart. EA/SM is the most recent heuristic algorithm and outperforms the precedent algorithms like in (Yuan & Li, 2011, 2014). For our comparative experiment, we ran 20 times the source code of EA/SM (provided by its authors) to solve each instance, each run being limited to 200,000 fitness evaluations according to (Yuan et al., 2015). We observed that to attain its best solutions, EA/SM needed a run time ranging from 42 to 50 seconds for instances of 250 vertices and 75 to 94 seconds for instances of 500 vertices (see Table 1). Consequently, the stopping condition of EA/SM can be considered to be more favorable than that used to run our algorithm (a cut off time of 30 seconds for instances of 250 vertices and and 60 seconds for instances of 500 vertices).\n- IBM CPLEX: CPLEX is one of the most popular commercial optimization software. We ran CPLEX (version 12.6.1) 2 hours (7200 seconds) on each instance with the binary linear formulation provided in Section 1. Obviously, the total time given to TSGR-MBBP for 20 runs (60*20 = 1200 seconds for the random instances and 360*20 = 7200 seconds for the KONECT instances) is no more than 2 hours.\n- AL Greedy (Yamani et al., 2007). This is a (fast) greedy algorithm which solves the equivalent maximum balanced independent set problem for the\n1dfmax:ftp://dimacs.rutgers.edu/pub/dsj/clique/\nTable 1 reports the computational results of TSGR-MBBP together with the results of the reference approaches (EA/SM, CPLEX and AL Greedy) on the 30 random dense graphs. Column \u201cinstance\u201d shows the name of each instance. Column \u201cBKV\u201d presents the best known values reported in (Yuan et al., 2015). For TSGR-MBBP and EA/SM, column \u201cbest(ave)\u201d indicates the maximum value of the 20 best balanced sizes found in 20 runs, the average size is given between parentheses if the 20 runs do not lead to an identical balanced size; column \u201ctime\u201d reports the average time (in seconds) of first hitting the best balanced size in 20 runs; column \u201creduce\u201d (only for TSGR-MBBP) reports the number of vertices removed by the two reduction methods in one of the runs where we find the best balanced size. For CPLEX, we report the best lower bounds and the time needed to complete the search. If CPLEX fails to report a feasible solution for an instance due to memory limitation, \u201c-\u201d is used in the\ncorresponding entries of columns \u201cbest\u201d and \u201ctime\u201d. For AL Greedy, since its run time is negligible (shorter than 0.01 second for all instances), we only report the best biclique values.\nFrom Table 1, we first observe that in terms of solution quality, TSGRMBBP competes very favorably with the reference approaches. In particular, TSGR-MBBP improves the best-known results reported in (Yuan et al., 2015) for 10 instances (marked in bold font). For the 20 remaining instances, the best objective values found by TSGR-MBBP are always as good as or better than those of the reference algorithms. The average objective values of the 20 runs of TSGR-MBBP are also better than that of EA/SM. Moreover, the performance of TSGR-MBBP is quite stable across the whole set of tested instances. In terms of computational efficiency, TSGR-MBBP is very competitive \u2013 it hits its best result within no more than one and 22 seconds for the instances of 250 and 500 vertices respectively, against up to 50 and 94 seconds for the best reference algorithm EA/SM. As for CPLEX, it cannot complete its search within a duration of 2 hours and thus fails to find the optimal solution for any instance (still CPLEX finds some solutions better than those of AL Greedy). Unsurprisingly, the greedy algorithm AL Greedy leads to solutions of very poor quality. Finally, as expected, neither reduction method is successful on these very dense graphs as the degree of any vertex is much larger than the best balanced size. For example, the vertex degree of \u201cG 500 0.85 X\u201d is closely around 425 while the optimal balanced size is estimated to be between 39 and 76 by the theorem given in (Dawande et al., 2001). However, as we show in the next section, the reduction procedure becomes extremely effective when large sparse graphs are considered."}, {"heading": "4.3.2. KONECT networks", "text": "We report in Table 2 the computational results of TSGR-MBBP and CPLEX on the set of 25 KONECT instances. For this study, we ignore EA/SM and AL Greedy since the EA/SM code cannot be run on these graphs (EA/SM imposes the input graph to be balanced, which is not the case for KONECT instances), while AL Greedy performs very poorly (see Table 1). Columns \u201cname\u201d, \u201c(|U |, |V |)\u201d, \u201c|E|\u201d show the basic information of the original instances. For TSGR-MBBP, columns \u201cbest(ave)\u201d and \u201ctime\u201d report the same information as in Table 1. Columns \u201cred 1\u201d and \u201cred 2\u201d indicate the total number of vertices that are removed from the original graph by the two reduction methods (the Peel procedure and the exact search procedure) in one of the runs where we find the best balanced size. To enable CPLEX to load large graphs, each original graph was pre-reduced by applying Peel(G, best) before starting CPLEX. Column \u201c(|U \u2032|, |V \u2032|)\u201d reports the number of vertices after applying Peel(G, best) while columns \u201cbest\u201d and \u201ctime\u201d report the best balanced size reached as well as the total consumed time. Symbol \u201c*\u201d indicates that the solution has been proven to be optimal by the corresponding algorithm, while symbol \u201c-\u201d means that the initial (and Peel pre-reduced) graph cannot be loaded into CPLEX.\nAs explained in Section 3.2, when either of the two vertex sets of the current bipartite graph contains less than \u03c9 (the best balanced size found so far) vertices,\n\u03c9 is proven to be the optimal maximum balanced size. From Table 2, we observe that TSGR-MBBP proves optimality for 14 out of the 25 instances (indicated by \u201c*\u201d), even though these real-world instances are significantly larger than the random instances. Also, TSGR-MBBP achieves the same best balanced size in all 20 runs for all but 5 instances (whose average objective values are reported in the table). Observing the number of vertices that has been reduced, we find that the first reduction method (the Peel method) prunes more than half or even all of the vertices during the search procedure. As for the second reduction method (which is based on exact search), though the vertices removed by this method are fewer than the first method, we cannot neglect its significance. For 5 instances \u201cbibsonomy-2ui\u201d,\u201cdpedia-genre\u201d,\u201cdbpedia-starring\u201d, \u201cmoreno crime\u201d and \u201cwiki-en-cat\u201d, the Peel procedure fails to reduce these graphs to small enough subgraphs such that optimality can be proven (one vertex set of the subgraph includes fewer than \u03c9 vertices, see column \u201c(|U \u2032|, |V \u2032|)\u201d), TSGR-MBBP directly finds the optimal solution for the resulting subgraphs with less than K vertices. The CPLEX solver, unfortunately, is unable to load some of these massive graphs even after reducing these graphs significantly by applying Peel(G, best) in the pre-processing step. For instances for which CPLEX finds a feasible solution, like \u201cdiscogs style\u201d, \u201cedit-frwiktionary\u201d, \u201cstackexchange-stackoverflow\u201d and \u201cyoutube-groupmemberships\u201d, the results are still worse than those achieved by TSGR-MBBP. Besides, CPLEX always requires a longer time than TSGR-MBBP to attain the best solution."}, {"heading": "5. Analysis", "text": "This section presents an empirical analysis of the restricted unbalance constraint related to the Constraint-Based Tabu Search procedure (Section 3.4) and the merit of the graph reduction procedure (Section 3.5)."}, {"heading": "5.1. Unbalance constraint of Constraint-Based Tabu Search", "text": "The Constraint-Based Tabu Search procedure (Algorithm 1, line 6) is one key component of the proposed TSGR-MBBP algorithm. One of the main features of CBTS is that while unbalanced bicliques are allowed, the balance deviation of the explored bicliques must be no more than 2 (see Sections 2 and 3.4) (this constraint is called unbalance constraint). To justify this specific unbalance constraint, we compare CBTS with two CBTS versions with different unbalance constraints. The first version (called \u201cCBTS\u2126\u221e\u201d) removes the unbalance constraint and allows the procedure to visit any bicliques (lines 15-23 are removed from Algorithm 2). The second version (named as \u201cCBTS\u21261\u201d) introduces a more restrictive unbalance constraint \u2013 the balance deviation is required to be no more than 1 after each iteration (i.e., change the repairing condition in line 15 to |X | \u2212 |Y | > 1). We also used \u201cCBTS\u21262\u201d to denote the original CBTS procedure. As such, these three CBTS versions correspond to three restart algorithms searching within the solution spaces \u21262, \u2126\u221e, and \u21261 respectively. Note that the version with absolute balanced constraint is not considered. In effect, if we repair the solution whenever |X | \u2212 |Y | 6= 0, the current\nsolution can never be improved because the \u201cpush\u201d operator only imports one vertex to one vertex set in each iteration.\nFor this study, we used 13 instances selected from the two benchmark sets. We ran each CBTS version 20 trials to solve each instance under the same configuration mentioned in Section 4.2. Each trial was given a time limit of 60 seconds. The comparative results of this study are summarized in Table 3. We denote one restart of CBTS as one iteration here (one \u2018while\u2019 loop, lines 10-20 in Algorithm 1). Column \u201cbest(ave)\u201d indicates the best and average balanced biclique size found by each algorithm over 20 runs. Column \u201ctime\u201d reports the average time to achieve the best balanced biclique size in all 20 runs. Column \u201citer\u201d reports the average number of restarts for 20 runs.\nAs for the solution quality, the original Constraint-Based Tabu Search (CBTS\u21262) procedure dominates the other variants both in terms of best and average values. CBTS\u21262 also performs the best concerning the average time of attaining the best solution for random graphs. As for the total number of iterations (column \u201citer\u201d), CBTS\u2126\u221e restarts more often than CBTS\u21262 which on the other hand restarts more often than CBTS\u21261 . Obviously, a tighter unbalance constraint leads to more frequent calls to the repair procedure, thus less iterations under the same time limitation. Meanwhile, the results suggest that the strategy of incorporating unbalance constraint is a good trade-off between solution quality and number of iterations."}, {"heading": "5.2. Effectiveness of reduction methods", "text": "To gain a comprehensive understanding of the run-time behavior and efficiency of the two reduction methods, we show in this section an analysis of the convergence rate of three variants of the TSGR-MBBP algorithm:\n\u2022 No Reduction: The reduction procedure is disabled, i.e., lines 10-18 are removed from Algorithm 1.\n\u2022 Reduction 1: Only the first reduction method (the Peel method) is used. i.e., lines 12-18 are removed from Algorithm 1.\n\u2022 Reduction 1&2: Both reduction methods are used, i.e., the original TSGRMBBP algorithm.\nThe variant with only the second reduction is not considered as the exact search will never be triggered without the Peel procedure.\nThis study was based on 6 KONECT instances, \u201cdblp-author\u201d, \u201cdbpediagenre\u201d, \u201cdbpedia-team\u201d, \u201cdiscog style\u201d, \u201cedit-frwikitionary\u201d and \u201cwiki-en-cat\u201d which are large enough with different levels of difficulty for TSGR-MBBP (the difficulty is estimated by the time consumption of TSGR-MBBP in Table 2). We ran each algorithm variant 20 times to solve each instance with a time limit of 6 minutes per run. Again, we denote one restart of CBTS as one iteration. Figure 2 reports the relation between the number of iterations and the average best balanced size reached by each variant in 20 runs (abbreviated as \u2018average size\u2019). Considering the two variants with reduction can stop before reaching the time limit when the optimum is proven, we assume that the best size after termination is constantly the optimal size in this case.\nAccording to Figure 2, in terms of the average result after the same number of iterations, the two variants using reduction always dominate the variant without reduction. Actually, \u201cNo Reduction\u201d converges so slowly that it even has difficulties in reaching half of the best-known size in the given time limit. Comparing \u201cReduction 1\u201d and \u201cReduction 1&2\u201d, for \u201cdblp-author\u201d, \u201cdbpediagenre\u201d, \u201cdbpedia-team\u201d, \u201cedit fiwikitionaryand\u201d and \u201cwiki-en-cat\u201d, \u201cReduction 1&2\u201d always discovers solutions of high quality earlier. In particular, for two instances, \u201cdblp-author\u201d and \u201cwiki-en-cat\u201d, \u201cReduction 1&2\u201d reaches the optimal solution in the very first iteration. This is because for these graphs, the exact algorithm discovered the optimal solution in some of the connected subgraphs at the beginning of the search, which in turn enabled the peel procedure to prune the graph to trivial size and thus proves the global optimality. Nevertheless, for \u201cdiscogs style\u201d, \u201cReduction 1&2\u201d and \u201cReduction 1\u201d perform similarly. We also notice that the curves of \u201cReduction 1\u201d and \u201cReduction 1&2\u201d meet sooner or later for all the instances. In a nutshell, the convergence rate is highly related to the instance under consideration, but in any case, both reduction methods accelerate the search procedure."}, {"heading": "6. Conclusions and perspectives", "text": "The Maximum Balanced Biclique Problem is of great interest both theoretically and practically. We have presented an original tabu search combined with two dedicated graph reduction techniques for solving MBBP approximately. The proposed TSGR-MBBP algorithm is driven by a Constraint-Based Tabu Search (CBTS) procedure to retrieve high quality solutions from the current graph. CBTS employs the \u201cpush\u201d operator to explore relaxed search space including both balanced and unbalanced bicliques and imposes a specific unbalance constraint on explored solutions. Moreover, each time the lower bound is updated\nby CBTS, two reduction rules are used to prune the graph, which leads to a reduced search space for the following iterations. Specifically, the first reduction rule is based on removing unpromising vertices according to their degrees, while the second reduction rule removes small subgraphs using an exact search procedure.\nThe TSGR-MBBP algorithm has been assessed on two benchmark sets: 30 random dense instances and 25 real-life large instances from the KONECT collection. For the random instances, TSGR-MBBP dominates existing state-ofthe-art approaches EA/SM (Yuan et al., 2015), GL Greedy (Yamani et al., 2007) and CPLEX (version 12.6.1). Besides, new improved solutions (new lower bounds) were found by TSGR-MBBP for 10 out of the 30 instances. For the KONECT instances, TSGR-MBBP proved optimal solutions for 14 instances for the first time and found high quality solutions for the other instances. Experiments have also indicated that TSGR-MBBP performs better than CPLEX both in terms of solution quality and computational time. Besides, we have also noticed that the two reduction methods are able to prune a significant number of vertices for large sparse graphs. Additional experiments have demonstrated the effectiveness of the adopted unbalance constraint used by tabu search and confirmed that the combination of two reduction methods significantly accelerates the convergence of the search procedure.\nThis study can be extended in several directions. First, we only investigated two typical cases of the general \u201cpush\u201d operator which correspond to the \u201cadd\u201d and \u201cswap\u201d moves. It would be interesting to study other customized moves based on the \u201cpush\u201d operator. Second, as shown in our literature review, there are few exact algorithms for MBBP. It would be useful to design more elaborated exact algorithms. For this purpose, the exact algorithm introduced in this work (for the purpose of graph reduction) could be served as a base version for further improvement. It is also appealing to adapt more advanced exact clique algorithms like (Pattabiraman et al., 2013; Segundo et al., 2016) to MBBP. Finally, given the effectiveness of the reduction techniques on large-scale instances for MBBP, it would be interesting to investigate similar techniques in the context of other clique related problems like the maximum clique problem Wu & Hao (2015b) and the maximum k-plex problem (Balasundaram et al., 2011) for massive graphs."}, {"heading": "Acknowledgment", "text": "We\u2019d like to thank the authors of (Yuan et al., 2015) for sharing the code of their EA/SM algorithm. The work was partially supported by the PGMO (2014- 0024H) project from the Jacques Hadamard Mathematical Foundation (Paris, France). Support for the first author of this work from the China Scholarship Council (2013-2017) is also acknowledged.\nJ. Abello, M.G. Resende, S. Sudarsky, Massive quasi-clique detection, in: Latin American Symposium on Theoretical Informatics, Springer, 2002, pp. 598\u2013 612.\nA.A. Al-Yamani, S. Ramsundar, D. K. Pradhan, A defect tolerance scheme for nanotechnology circuits, Circuits and Systems I: Regular Papers, IEEE Transactions on 54 (11) (2007) 2402\u20132409.\nN. Alon, R.A. Duke, H. Lefmann, V. Rodl, R. Yuster, The algorithmic aspects of the regularity lemma, Journal of Algorithms 16 (1) (1994) 80\u2013109.\nB. Balasundaram, S. Butenko, I.V. Hicks, Clique relaxations in social network analysis: The maximum k-plex problem, Operations Research 59 (1) (2011) 133\u2013142.\nR. Carraghan, P.M. Pardalos, An exact algorithm for the maximum clique problem, Operations Research Letters 9 (6) (1990) 375\u2013382.\nY. Cheng, G.M. Church, Biclustering of expression data., in: Ismb, vol. 8, 2000, pp. 93\u2013103.\nM. Dawande, P. Keskinocak, J.M. Swaminathan, S. Tayur, On bipartite and multipartite clique problems, Journal of Algorithms 41 (2) (2001) 388\u2013403.\nJ.A. D\u0131\u0301az, D.E. Luna, J.F. Camacho-Vallejo, M.S. Casas-Ramrez, GRASP and Hybrid GRASP-Tabu Heuristics to Solve a Maximal Covering Location Problem with Customer Preference, Expert Systems with Applications, (2017) In Press.\nS. Elhedhli, C. Akdemir, T. A\u030astebro, Classification models via Tabu search: An application to early stage venture classification, Expert Systems with Applications, 41 (18) (2014) 8085\u20138091.\nU. Feige, S. Kogan, Hardness of approximation of the balanced complete bipartite subgraph problem, Tech. rep., Weizmann Inst. Sci (2004).\nM.R. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W. H. Freeman & Co., New York, NY, USA, 1979.\nF. Glover, M. Laguna, Tabu Search, Kluwer Academic Publishers, Norwell, MA, USA, 1997.\nJ. Kunegis, Konect: the koblenz network collection, in: Proceedings of the 22nd international conference on World Wide Web companion, International World Wide Web Conferences Steering Committee, 2013, pp. 1343\u20131350.\nM. Lo\u0301pez-Iba\u0301nez, J. Dubois-Lacoste, T. Stu\u0308tzle, M. Birattari, The irace package, iterated race for automatic algorithm configuration, Tech. rep., Citeseer (2011).\nF. Ma, Y. Wang, J.K. Hao, Path relinking for the vertex separator problem, Expert Systems with Applications, In Press, doi: 10.1016/j.eswa.2017.03.064.\nC. McCreesh, P. McCreesh, An exact branch and bound algorithm with symmetry breaking for the maximum balanced induced biclique problem, in: International Conference on AI and OR Techniques in Constriant Programming for Combinatorial Optimization Problems, Springer, 2014, pp. 226\u2013234.\nD. Mubayi, G. Tura\u0301n, Finding bipartite subgraphs efficiently, Information Processing Letters 110 (5) (2010) 174\u2013177.\nB. Pattabiraman, M. Ali Patwary, A.H. Gebremedhin, W. Liao, A. Choudhary, Fast algorithms for the maximum clique problem on massive sparse graphs, in: International Workshop on Algorithms and Models for the Web-Graph, Springer, 2013, pp. 156\u2013169.\nS. Ravi, E.L. Lloyd, The complexity of near-optimal programmable logic array folding, SIAM Journal on Computing 17 (4) (1988) 696\u2013710.\nP. San Segundo, A. Lopez, P. M. Pardalos, A new exact maximum clique algorithm for large and massive sparse graphs, Computers & Operations Research 66 (2016) 81\u201394.\nM. B. Tahoori, Application-independent defect tolerance of reconfigurable nanoarchitectures, ACM Journal on Emerging Technologies in Computing Systems (JETC) 2 (3) (2006) 197\u2013218.\nM. B. Tahoori, Low-overhead defect tolerance in crossbar nanoarchitectures, ACM Journal on Emerging Technologies in Computing Systems (JETC) 5 (2) (2009) 11.\nG.J. Wang, C. Xie, Tail dependence structure of the foreign exchange market: A network view, Expert Systems with Applications, 46 (2016) 164\u2013179.\nQ. Wu, J.K. Hao, Solving the winner determination problem via a weighted maximum clique heuristic, Expert Systems with Applications, 42 (1) (2015) 355\u2013365.\nQ. Wu, J.K. Hao, A review on algorithms for maximum clique problems, European Journal of Operational Research 242 (3) (2015) 693\u2013709.\nX. Yao, L. Peng, L. Yang, T. Chi, A fast space-saving algorithm for maximal co-location pattern mining, Expert Systems with Applications, 63 (3) (2015) 310\u2013323\nB. Yuan, B. Li, A low time complexity defect-tolerance algorithm for nanoelectronic crossbar, in: Information Science and Technology (ICIST), 2011 International Conference on, IEEE, 2011, pp. 143\u2013148.\nB. Yuan, B. Li, A fast extraction algorithm for defect-free subcrossbar in nanoelectronic crossbar, ACM Journal on Emerging Technologies in Computing Systems (JETC) 10 (3) (2014) 25.\nB. Yuan, B. Li, H. Chen, X. Yao, A new evolutionary algorithm with structure mutation for the maximum balanced biclique problem, Cybernetics, IEEE Transactions on 45 (5) (2015) 1040\u20131053.\nY. Zhou, J.K. Hao, A. Goe\u0308ffon, Push: A generalized operator for the maximum vertex weight clique problem, European Journal of Operational Research 257 (1) (2017) 41\u201354."}, {"heading": "Appendix A. The exact search algorithm", "text": "The exact algorithm (Algorithm 3 and Proc. 4) used in TSGR-MBBP is adapted from the classical B&B algorithm for the maximum clique problem Carraghan & Pardalos (1990). Instead of starting from the trivial lower bound 0, our exact algorithm receives an initial lower bound \u03c9 (Algorithm 3, line 2), which is the best balanced size ever found in TSGR-MBBP. (X\u2217, Y \u2217), the best biclique found by the exact algorithm, is initialized as a tuple of two empty sets (Algorithm 3, line 3). If there is no solution better than \u03c9 in the current subgraph, (X\u2217, Y \u2217) remains empty even after the exact search. In such a case, the real optimal solution is discarded as we are only interested in solutions better than \u03c9. The exact algorithm calls a recursive procedure bbexpand (Proc. 4) to start the branch and bound search.\nUnlike the original algorithm in Carraghan & Pardalos (1990), which only builds one set that forms a clique, the bbexpand procedure alternatively builds two sets A and B (|A| = |B| or |A| + 1 = |B| ) such that A and B form a biclique. Sets CA and CB contain the candidate vertices that may be added to A and B respectively, i.e., (CA = \u22c2 i\u2208B N(i) and CB = \u22c2\ni\u2208A N(i)). Each invocation of bbexpand recursively traversals the feasible bicliques containing A and B with all possible combinations of CA and CB examined. The procedure works as follow:\nFirstly, if candidate set CA is empty, bbexpand tries to update the current lower bound lb (lines 1-5, Proc. 4). As the cardinality of set A is equal to or one less than that of B in the input of bbexpand, |A| is always the balanced size of biclique (A,B) (or (B,A)). Then, if CA is not empty, bbexpand enters a while loop (lines 6-14), where in each iteration, a vertex i with minimum index is picked from CA (lines 9-10) to form a new solution with A\u222a {i} and B while removing i from CA at the same time. In the end of the iteration, bbexpand is recursively called to enumerate all the feasible bicliques with the new sets of solution and new candidate sets (CA and CB \u2229N(i)). Note that the roles of A and B as well as CA and CB in the next level of recursive call (lines 11-14) are exchanged. This is because that, to meet the balance constraint, the biclique is built by alternatively introducing a vertex from U and V . The if part in lines 7-8 prunes the unnecessary expanding since, when |A| + |CA| is smaller than the current lower bound, there is no possibility to discover a better solution based on the given solution and candidate sets. This simple rule of pruning unnecessary enumeration is similar to the one used in Carraghan & Pardalos\n(1990). In brief, every loop from line 6 to line 14 enumerates possible bicliques involving set A with a newly selected vertex i and set B.\nAlgorithm 3: Exact search algorithm\nInput: Graph instance G(U,V, E), initial lower bound \u03c9 Output: A biclique (X\u2217, Y \u2217) with maximum balanced size begin1 lb \u2190 \u03c9 ; /* Initialize the lower bound as \u03c9 */2 (X\u2217, Y \u2217) \u2190 (\u2205, \u2205) ; /* Initialize the best solution as empty sets */3 bbexpand(G, \u2205, \u2205, U , V );4\nend5 return (X\u2217, Y \u2217)6\nProcedure bbexpand(G, A, B, CA, CB )\nInput: Graph instance G = (U,V, E), A, B - current sets that forms a biclique, CA, CB - the sets of eligible vertices that can be added to A and B respectively. Output: The maximum balanced size \u03c9 in G, the biclique (X\u2217, Y \u2217) with balanced size \u03c9.\nif |CA| = 0 then1 if |A| > \u03c9 then2 lb \u2190 |A| ;3 Record current solution (A,B) in (X\u2217, Y \u2217);4 return5\nwhile CA 6= \u2205 do6 if |A|+ |CA| \u2264 lb then7 return8\ni \u2190 min{i|i \u2208 CA};9 CA \u2190 CA \\ {i};10 if |A| < |B| then11 bbexpand(G,A \u222a {i}, B, CA, CB \u2229N(i))12\nelse13 bbexpand(G,B, A \u222a {i}, CB \u2229N(i), CA)14\nreturn15"}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "The Maximum Balanced Biclique Problem is a well-known graph model with relevant applications in diverse domains. This paper introduces a novel algorithm, which combines an effective constraint-based tabu search procedure and two dedicated graph reduction techniques. We verify the effectiveness of the algorithm on 30 classical random benchmark graphs and 25 very large real-life sparse graphs from the popular Koblenz Network Collection (KONECT). The results show that the algorithm improves the best-known results (new lower bounds) for 10 classical benchmarks and obtains the optimal solutions for 14 KONECT instances.", "creator": "dvips(k) 5.996 Copyright 2016 Radical Eye Software"}}}