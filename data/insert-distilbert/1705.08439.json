{"id": "1705.08439", "review": {"conference": "nips", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-May-2017", "title": "Thinking Fast and Slow with Deep Learning and Tree Search", "abstract": "solving sequential decision making problems, such as text parsing, robotic control, and game data playing, requires a discrete combination of planning policies and generalisation of those plans. in this paper, we present gnu expert iteration, a novel greedy algorithm which decomposes the problem into separate planning and generalisation tasks. partially planning new policies is performed by tree search, while a deep neural network generalises those plans. in contrast, using standard deep reinforcement learning utility algorithms rely on a neural network explicitly not only to generalise plans, but to discover them too. we show that our chosen method substantially markedly outperforms policy comparison gradients in the board game hex, winning over 84. 4 % of games against it when trained for basically equal time.", "histories": [["v1", "Tue, 23 May 2017 17:48:51 GMT  (650kb,D)", "http://arxiv.org/abs/1705.08439v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["thomas anthony", "zheng tian", "david barber"], "accepted": true, "id": "1705.08439"}, "pdf": {"name": "1705.08439.pdf", "metadata": {"source": "CRF", "title": "Thinking Fast and Slow with Deep Learning and Tree Search", "authors": ["Thomas W. Anthony"], "emails": ["thomas.anthony.14@ucl.ac.uk"], "sections": [{"heading": "1 Introduction", "text": "According to dual-process theory [1, 2], human reasoning consists of two different kinds of thinking. System 1, is a fast, unconscious and automatic mode of thought, also known as intuition or heuristic process. System 2, an evolutionarily recent process unique to humans, is a slow, conscious, explicit and rule-based mode of reasoning.\nWhen learning to complete a challenging planning task, such as playing a board game, humans exploit both processes: strong intuitions allow for more effective analytic reasoning by rapidly selecting interesting lines of play for consideration. Repeated\nar X\niv :1\n70 5.\n08 43\n9v 1\ndeep study gradually improves intuitions. Stronger intuitions feedback to stronger analysis, creating a closed learning loop. In other words humans combine thinking fast and slow.\nIn Deep Reinforcement Learning algorithms such as Policy Gradients [3] and DQN [4], neural networks make action selections with no lookahead; this is analogous to System 1. Unlike human intuition, their training does not benefit from a \u2018System 2\u2019 to suggest strong policies. In this paper, we present Expert Iteration (ExIt), which uses a Tree Search as an analogue of System 2: this assists the training of the neural network. In turn, the neural network is used to improve the performance of the Tree Search by providing fast \u2018intuitions\u2019 to guide search.\nAt a low level, ExIt can be viewed as an extension of Imitation Learning (IL) methods to domains where the best known experts are unable to achieve satisfactory performance. In IL an apprentice is trained to imitate the behaviour of an expert policy. Within ExIt, we iteratively resolve the IL problem. Between each iteration, we perform an Expert Improvement step, where we bootstrap the (fast) apprentice policy to increase the performance of the (comparatively slow) expert.\nIn a typical implementation of ExIt, the apprentice is implemented as a deep neural network, and the expert by a Tree Search algorithm. Expert Improvement can be achieved by using the apprentice as an initial bias in the search direction, or to assist in quickly estimating the value of states encountered in the search tree.\nWe proceed as follows: in section 2, we cover some preliminaries. Section 3 describes the general form of the Expert Iteration algorithm, and discusses the roles performed by expert and apprentice.\nSections 4 and 5 dive into the implementation details of the Imitation Learning step and Expert Improvement step of ExIt. The performance of the resultant ExIt algorithm is reported in section 6. Sections 7 and 8 discuss our findings and relate the algorithm to previous works."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Markov Decision Processes", "text": "We consider sequential decision making in a Markov Decision Process (MDP). At each timestep t, an agent observes a state st and chooses an action at to take. In a terminal state sT , an episodic reward R is observed, which we intend to maximise.1 We can easily extend to two-player, perfect information, zero-sum games by learning policies for both players simultaneously, which aim to maximise the reward for the respective player.\nWe call a distribution over the actions a available in state s a policy, and denote it \u03c0(a|s). The value function V \u03c0(s) is the mean reward from following \u03c0 starting in state s. By Q\u03c0(s, a) we mean the expected reward from taking action a in state s, and following policy \u03c0 thereafter. The advantage function A\u03c0(s, a) = Q\u03c0(s, a) \u2212 maxa\u2032 Q \u03c0(s, a\u2032) represents the value of an action relative to the best action available.\n1This reward may be decomposed as a sum of intermediate rewards (i.e. R = \u2211T\nt=0 rt)"}, {"heading": "2.2 Imitation Learning", "text": "In Imitation Learning, we attempt to solve the MDP by mimicking an expert policy \u03c0\u2217 that has been provided. Such an expert can arise from observing humans completing a task, or, in the context of structured prediction, calculated from labelled training data. The policy we learn through this mimicry is referred to as the apprentice policy.\nWe create a dataset of states of expert play, along with some target data drawn from the expert, which we attempt to predict. Several choices of target data have been used. The simplest approach is simply to ask the expert to name an optimal move \u03c0\u2217(a|s) [5]. Once we can predict expert moves, we can take the action we think the expert would have most probably taken. Another approach is to estimate the action-value function Q\u03c0 \u2217 (s, a) [6]. We can then predict that function, and act greedily with respect to it. In contrast to the first method, this target is cost-sensitive, meaning the apprentice can trade-off prediction errors against how costly they are."}, {"heading": "3 Expert iteration", "text": "Compared to IL techniques, Expert Iteration (ExIt) is enriched by an Expert Improvement step. Improving the expert player, and then resolving the Imitation Learning problem, allows us to exploit the fast convergence properties of Imitation Learning even in contexts where no strong player was originally known. Previously, to solve such problems researchers have fallen back on RL algorithms that often suffer from slow convergence, high variance, and can struggle with local minima.\nAt each iteration i, the algorithm proceeds as follows: we create a set Si of states by self play of the apprentice \u03c0\u0302i\u22121. In each of these states, we calculate an expert move \u03c0\u2217i\u22121(a|s); the pairs (s, \u03c0\u2217i\u22121(a|s)) form our dataset Di . We train a new apprentice \u03c0\u0302i on Di (Imitation Learning). Then, we use our new apprentice to update our expert \u03c0\u2217i = \u03c0\n\u2217(a|s; \u03c0\u0302i) (Expert Improvement). See Algorithm 1 for pseudo-code. To achieve Expert Improvement, we bootstrap the most recent apprentice policy learned in the Imitation Learning. This allows the expert to find improvements to the current policy. If the expert is able to find policies much stronger than the bootstrapped apprentice policy, each iteration will result in a large improvement in the apprentice\u2019s play strength. Mathematically, we express our experts as a class parametrised by a policy: \u03c0\u2217(a|s;\u03c0).\nInput: An initial apprentice \u03c0\u03020, an expert class \u03c0\u2217 Output: A neural network policy \u03c0i i := 0; while Time remaining do\nSample states: Si := Sample States (\u03c0\u0302i\u22121); Create dataset: Di := {(s,Targets(s, \u03c0\u2217i\u22121)) : s \u2208 Si}; Train apprentice \u03c0\u0302i on Di; Update Expert: \u03c0\u2217i := \u03c0\n\u2217(\u03c0\u0302i); end return \u03c0i\nAlgorithm 1: Expert Iteration\nThe Imitation Learning step is analogous to a human improving their intuition for the task by studying example problems, while the Expert Improvement step is analogous to a human using the their improved intuition to guide future analysis."}, {"heading": "3.1 Choice of expert and apprentice", "text": "The learning rate of ExIt is controlled by two factors: the size of the performance gap between the apprentice policy and the improved expert; and how close the performance of the new apprentice is to the expert it learns from. The former induces an upper bound on the new apprentice\u2019s performance at each iteration, while the latter describes how closely we approach that upper bound. The choice of both expert and apprentice can have a significant impact on both these factors, so must be considered together.\nThe role of the expert is to perform exploration, and thereby to accurately determine strong move sequences, from a single position. The role of the apprentice is to generalise the policies that the expert discovers across the whole state space, and to provide rapid access to that strong policy for bootstrapping.\nThe canonical choice of expert is a tree search algorithm. Search considers the exact dynamics of the game tree local to the state under consideration, and can be considered analogous to the lookahead human games players engage in when planning their moves. The bootstrap policy can be used to bias search towards promising moves, aid node evaluation, or both. By employing search, we can find promising sequences potentially far away from the bootstrap policy, accelerating learning in complex scenarios. Possible tree search algorithms include Monte Carlo Tree Search [7], \u03b1-\u03b2 Search, and Greedy Search [6]\nThe canonical apprentice is a deep neural network parametrisation of the policy. Such deep networks are known to be able to efficiently generalise across large state spaces, and can be evaluated rapidly on a GPU. The precise parametrisation of the apprentice should also be informed by what data would be useful for the expert. For example, if state value approximations are required, the policy might be expressed implicitly through a Q function, as this can accelerate lookup."}, {"heading": "3.2 Distributed Expert Iteration", "text": "ExIt spends the majority of run time generating a large dataset of expert plans, because our tree search is orders of magnitude slower than neural network evaluations (In our example, the \u223c 250, 000 samples created per iteration are responsible for 98% of run time). Creating this dataset is an embarassingly parallel task, and the plans made can be summarised by a target measuring well under 1KB. This means that ExIt can be trivially parallelised across distributed architectures, even with very low bandwidth."}, {"heading": "3.3 Online expert iteration", "text": "In each step of ExIt, Imitation Learning is restarted from scratch. This throws away our entire dataset. Since creating our datasets is computationally intensive this can add substantially to algorithm run time.\nThe online version of ExIt mitigates this by aggregating all datasets generated so far at each iteration. In other words, instead of training \u03c0\u0302i on Di, we train it on D = \u222aj\u2264iDj . Such dataset aggregation is similar to the DAgger algorithm [5]. Indeed, removing the Expert Improvement step from online ExIt reduces it to DAgger.\nDataset aggregation in online ExIt allows us to request fewer move choices from the expert at each iteration, while still maintaining a large dataset. By increasing the frequency at which improvements can be made, the apprentice in online ExIt can generalise the expert moves sooner, and hence the expert improves sooner also, which should result in higher quality play appearing in the dataset."}, {"heading": "4 Imitation Learning in the game Hex", "text": "The algorithmic requirements of the ExIt algorithm are an Imitation Learning procedure and an Expert Improvement procedure. In this section, we develop the techniques for our Imitation Learning step, and test them for Imitation Learning of Monte Carlo Tree Search (MCTS). We use this test because our intended Expert in ExIt is a version of Neural-MCTS, which will be described in section 5."}, {"heading": "4.1 Preliminaries", "text": "Hex\nHex is a two-player connection-based game played on an n \u00d7 n hexagonal grid. The players, denoted by colours black and white, alternate placing stones of their colour in empty cells. The black player wins if there is a sequence of adjacent black stones connecting the North edge of the board to the South edge. White wins if he achieves a sequence of adjacent white stones running from the West edge to the East edge. (See figure 1).\nHex has deep strategy, making it challenging for Deep Reinforcement Learning algorithms; its large action set and connection-based rules means it shares similar challenges for AI to Go. Furthermore, because the win condition is mutually exclusive (e.g. if black has a winning path, white cannot have one), its rules are simple, and permutations of move order are irrelevant to the outcome of a game, games can be simulated efficiently, which makes it an ideal test-bed for Reinforcement Learning. All our experiments are on a 9\u00d7 9 board size.\nMonte Carlo Tree Search\nMonte Carlo Tree Search is an any-time tree-search algorithm. It uses repeated game simulations to estimate the value of states, and expands the tree further in more promising lines. It is behind the leading algorithms in the AAAI general game playing competition [9]. As such, it is the best known algorithm for general game playing without a long RL training procedure.\nEach simulation consists of two parts. First, a tree phase, where the tree is traversed by taking actions according to a tree policy. Second, a rollout phase, where some default policy is followed until the simulation reaches a terminal game state. The result returned by this simulation can then be used to update estimates of the value of each node traversed in the tree during the first phase.\nEach node of the search tree corresponds to a possible state s in the game. The root node corresponds to the current state, its children correspond to the states resulting from a single move from the current state, etc. The edge from state s1 to s2 represents the action a taken in s1 to reach s2, and is identified by the pair (s1, a).\nAt each node we store, n(s), the number of iterations in which the node has been visited so far. Each edge stores both n(s, a), the number of times it has been traversed, and r(s, a) the sum of all rewards obtained in simulations that passed through the edge. The Tree Policy depends on these statistics. The most commonly used tree policy is to act greedily with respect to the Upper Confidence Bounds for Trees formula [7]:\nUCT(s, a) = r(s, a)\nn(s, a) + cb\n\u221a log n(s)\nn(s, a) (1)\nWhen an action a in state sL is chosen that takes us to a position s\u2032 not yet in the search tree, the rollout phase begins. In the absence of domain-specific information, the default policy used is simply to choose actions uniformly from those available.\nTo build up the search tree, when the simulation moves from tree phase to rollout phase, we perform an expansion, adding s\u2032 to the tree as a child of sL2. Once a rollout is complete, the reward signal is propagated through the tree (a backup), with each node and edge updating statistics for visit counts n(s), n(s, a) and total returns r(s, a).\nIn this work, all MCTS agents use 10,000 simulations per move, unless stated otherwise. We also use RAVE [10]"}, {"heading": "4.2 Imitation Learning from Monte Carlo Tree Search", "text": "In this section, we train a standard convolutional neural network to imitate an MCTS expert. Guo et al. [11] used a similar set up on Atari games. However, their results showed that the performance of the learned neural network fell well short of the MCTS expert, even with a large dataset of 800,000 MCTS moves. Our methodology described here improves substantially on this performance.3\n2Sometimes multiple nodes are added to the tree per iteration, adding children to s\u2032 also. Conversely, sometimes an expansion threshold is used, so sL is only expanded after multiple visits.\n3Our network architecture is described in the appendix. We use ADAM [12] as our optimiser\nLearning Targets\nIn Guo et al. [11], the learning target used was simply the move chosen by MCTS. We refer to this as chosen-action targets (CAT), and optimise the KullbackLeibler divergence between the output distribution of the network and this target. So the loss at position s is given by the formula:\nLCAT = \u2212 log[\u03c0(a\u2217|s)] where a\u2217 = argmaxa(n(s, a)) is the move selected by MCTS. We test an alternative target, which we call tree-policy targets (TPT). The Tree Policy Target is the average tree policy of the MCTS at the root. In other words, we try to match the network output to the distribution over actions given by n(s, a)/n(s) where s is the position we are scoring (so n(s) = 10, 000 in our experiments). This gives the loss:\nLTPT = \u2212 \u2211 a n(s, a) n(s) log[\u03c0(a|s)]\nIn MCTS, we select the action most explored, not the action with the highest average simulation score; because empirically this leads to stronger play. This subtlety is particularly important when the Tree Policy has been biased by some heuristic not measured by the average simulation score (e.g. by RAVE, or a Neural Network \u2018prior\u2019). Greedy selection of the most explored action suggests that MCTS actually uses its average tree policy as an approximation to Q(s, a) (or rather, some monotonic transformation thereof). Since the sum of the Tree Policy Targets is constrained to be 1, we slightly abuse the terminology by referring to it as an advantage function A(s, a), to emphasise that V (s) 6= maxa(n(s, a)/n(s)).\nThis means that Tree Policy Targets, although formally representing a policy, are actually cost-sensitive. Cost-sensitivity is a desirable property for an imitation learning target, as it induces the IL agent to trade off accuracy on less important decisions for greater accuracy on critical decisions.\nIn the setting of ExIt, there is additional motivation for such cost-sensitive targets, as our initial networks will be used to bias future searches. Accurate evaluations of the relative strength of actions not ever selected by the current expert are still important, since future experts will use the evaluations of all available moves to guide their search.\nSampling the position set\nCorrelations between the states in our dataset may reduce the effective dataset size, harming learning. Therefore, we construct all our datasets to consist of uncorrelated positions sampled using an exploration policy. To do this, we play multiple games with the exploration policy, and select a single state from each game, as in Silver et al. [13]. For the initial dataset, the exploration policy is MCTS, with the number of iterations reduced to 1,000 to reduce computation time and encourage a wider distribution of positions.\nWe then followed the DAgger procedure, expanding our dataset by using the apprentice policy to sample 100,000 more positions, again sampling one position per\ngame to ensure that there were no correlations in the dataset. This has two advantages over sampling more positions in the same way: firstly, selecting positions with the apprentice is faster, and secondly, doing so results in positions closer to the distribution that the apprentice network visits at test time."}, {"heading": "4.3 Results of Imitation Learning", "text": "Based on our initial dataset of 100,000 MCTS moves, CAT marginally outperforms TPT in the task of predicting the move selected by MCTS, with top-1 prediction errors of 52.2% and 50.0% and top-3 prediction errors of 70.9% and 69.1%, respectively. However, despite the similar prediction errors, the TPT network wins 93% of games vs the CAT network, confirming that the cost-awareness of TPT gives a significant performance improvement.\nWe continued training of the TPT network with the DAgger algorithm, iteratively creating 3 more batches of 100,000 moves. This additional data resulted in an improvement of 120 Elo over the first TPT network. Our final DAgger TPT-network achieved similar performance to the MCTS it was trained to emulate, winning just over half of games played between them (87/162)."}, {"heading": "5 Expert Improvement in Hex", "text": "We now have an Imitation Learning procedure which can train a strong apprentice network from MCTS. In this section, we describe our Neural-MCTS (N-MCTS) algorithm, which uses such apprentice networks to improve search quality. Because the apprentice network has effectively generalised our policy, it gives us fast evaluations of action plausibility at the start of search. As search progresses, we discover improvements on this apprentice policy, just has human players can correct inaccurate intuitions through lookahead.\nAs discussed in section 4.2, Tree Policy Targets can be viewed as a monotonic transformation of the advantage function. This insight informs the decision of how we use the neural network to improve our tree policy. When a node is expanded, we use the neural network to estimate A(s, a) for each action available, and add the estimates to the UCT formula, to give our neural net-assisted UCT formula:\nUCTNN(s, a) = UCT(s, a) + wa A(s, a)\nn(s, a) + 1\nWhere wa weighs the Neural Network against the simulations. This formula is closely related to one found in Gelly & Silver [10].\nTuning of hyperparameters found that wa = 100 was a good choice for this parameter, which is close to the average number of simulations per action at the root when using 10k iterations in the MCTS. Since this advantage function was trained using 10k iterations too, we would expect that the optimal weight should be close to this average.\nThe TPT network\u2019s final layer uses a softmax output. The TPT are a monotonic transformation of the advantage function, which may be non-linear. To allow correc-\ntion for this, we view the temperature of the TPT network\u2019s output layer as a hyperparameter for the N-MCTS, and tune it to maximise the performance of the N-MCTS.\nWhen using the strongest TPT network from section 4, N-MCTS significantly outperforms our baseline MCTS, winning 97% of games. This represents a performance improvement of \u223c 600 Elo. By contrast, a doubling of the number of iterations results in an improvement of just 115 Elo."}, {"heading": "6 Performance of Expert Iteration in Hex", "text": "In sections 4 and 5, we have developed the two major processes required by the ExIt algorithm. In this section we present the performance of the resultant algorithm."}, {"heading": "6.1 ExIt parameters", "text": "We test both the batched version of the ExIt algorithm, and the online version.\nIn the batched version, we perform two iterations. In each iteration, we spend the same processing time creating our data. Our first iteration created a dataset of 291276 expert moves, and the second created 231012 moves. The smaller number of moves was because the second iteration expert performed a deeper search, and therefore reached the expansion threshold slightly more often. Between the 1st and 2nd iteration, we also retuned parameters of the N-MCTS expert to best exploit the new NN. N-MCTS parameters are in the appendix.\nIn the online version, we begin by creating a dataset of 40176 expert moves. At each iteration, we increase the size of this dataset by 3240 moves of the latest expert. We resolve the supervised learning problem from scratch in each iteration. As a result, much more of runtime is spent on the Imitation Learning step."}, {"heading": "6.2 Benchmark algorithm", "text": "We compare ExIt to the Policy Gradient algorithm found in Silver et al. [13], which achieved state-of-the-art performance for a neural network player in the board game Go. In Silver et al. [13], the algorithm was initialised by network trained to predict human expert moves from a corpus of 30 million positions, and then REINFORCE [3] was used. Such a scheme, Imitation Learning initialisation followed by Reinforcement Learning improvement, is a common approach when known experts are not sufficiently strong.\nFor our tests, both the REINFORCE algorithm and ExIt are initialised to the strongest TPT network learnt in section 4. For REINFORCE, the network weights were saved after each training epoch, and after completing training, we searched for the best performing network among those learnt, which corrects for the high-variance updates from which Policy Gradient algorithms suffer."}, {"heading": "6.3 Results", "text": "Because Hex has a strong first player advantage, we measure performance between a pair of networks by playing 2 games starting from each possible opening move, with each player playing once as black, and once as white.\nOur results are shown in figure 2. They show that Expert Iteration significantly outperforms policy gradients. In a direct match against the strongest policy gradient network, batched ExIt won 74.7% of the games. Online ExIt beat the strongest policy gradient network in 84.4% of games.\nThe results show that ExIt is a far stronger learning algorithm than policy gradients. Initially, online exit is able to rapidly learn strong play, suggesting an advantage over the batched mode. However, as the number of iterations grows, so does the dataset size for the online algorithm. Training on that large dataset begins to take a long time, so improvements become flatter. Warm starting the trainings in online ExIt with the most recent network could remove the effect of slowing supervised learning.\nIt is also not clear that the reason online ExIt outperforms batch ExIt isn\u2019t that the batch mode had iterations that were too long. In particular, we can see that the first iteration in the batch mode gives a considerable improvement. As such, more work is needed to determine whether online or batch ExIt is the better algorithm."}, {"heading": "7 Related work", "text": "ExIt has several connections to existing RL algorithms, resulting from different choices of expert class. For example DQN [4] can be seen as a special case of ExIt where the\nexpert performs a single-sample single-step lookahead. The apprentice is represented by the function Qi(s, a) = Q\u03b8(s, a), and the imitation learning targets at iteration i + 1 are given by Q\u03c0 \u2217 i (st, a) = rt + Qi(st+1, a) (rt denotes the sampled immediate reward). We can also recover a version of Policy Iteration [14] by using Monte Carlo Search as our expert; in this case it is easy to see that Monte Carlo Tree Search gives stronger plan than does Monte Carlo Search.\nPrevious works have also attempted to achieve Imitation Learning that outperforms the original expert. Silver et al. [13] use Imitation Learning followed by Reinforcement Learning. Kai-Wei, et al. [15] use an iterative scheme with some similarity to ExIt. Their Imitation Learning algorithm is to use Monte Carlo estimates to calculate Q\u2217(s, a), and train an apprentice \u03c0 to maximise \u2211 a \u03c0(a|s)Q\u2217(s, a). At each iteration after the first, the rollout policy is changed to a mixture of the most recent apprentice and the original expert. This too can be seen as blending an RL algorithm with Imitation Learning: it combines Policy Iteration and Imitation Learning.\nNeither of these approaches is able to improve the original expert policy. They are useful when strong experts exist, but only at the beginning of training. In contrast, because ExIt creates stronger experts for itself, it is able to use experts throughout the training process.\nUnlike standard Imitation Learning methods, ExIt can be applied to the Reinforcement Learning problem: it makes no assumptions about the existence of a satisfactory expert. ExIt can be applied with no domain specific heuristics available, as we demonstrate in our experiment, where we used a general purpose search algorithm as our expert class."}, {"heading": "8 Conclusion and Future Work", "text": "We have introduced a new Reinforcement Learning algorithm, Expert Iteration, motivated by the dual process theory of human thought. ExIt decomposes the Reinforcement Learning problem by separating the problems of generalisation and planning. Planning is performed on a case-by-case basis, and only once a strong plan is found is the resultant policy generalised. This allows for long-term planning, and results in faster learning, particularly for challenging problems.\nExIt is almost embarassingly parallelisable, even for distributed systems with low network bandwidth. In contrast, standard Reinforcement Learning methods must frequently communicate weight updates in order to be parallelised, and these communications are usually limited by network bandwidth.\nWe show that this algorithm significantly outperforms a variant of the REINFORCE algorithm in learning to play the board game Hex; this version of REINFORCE has recently achieved state-of-the-art play in the related board game Go.\nThe ExIt framework, by explicitly separating the RL task into its subtasks, also makes identifying ways of improving performance clear. For example, the NeuralMCTS we used only uses the neural network to aid comparisons of sibling nodes. We do not learn a Value network, and we do not change from a default rollout policy. Incorporating these into our Neural-MCTS could significantly increase its performance, and therefore allow for much faster learning."}, {"heading": "A Fast calculation of expert moves", "text": "Because calculation of Neural Networks is faster when done in batch, and is performed on a GPU, most implementations of Neural-MCTS calculate their Neural Networks asynchronously: when a node is expanded, the position is added to a GPU calculation queue, but search continues. Once the queue length reaches the desired batch size B, the Neural Network policy can be calculated for the first B states on the queue, and the information is added to the appropriate nodes.\nCompared to waiting until the evaluation has taken place, this asynchronous neural net calculation substantially increases the rate at which MCTS iterations can take place: batching neural net calculations improves GPU throughput, and the CPU never sits idle waiting for evaluations. However, because search continues before evaluations are returned, suboptimal moves are made in the tree where prior information has not yet been calculated.\nIn the ExIt setting, we can avoid asynchronous N-MCTS, CPU idle time and small calculation batches on our GPU. This is because we are creating a large dataset of NMCTS moves, and can calculate multiple moves simultaneously. Suppose we have a set P of positions to search from, and that |P | > 2B . Each CPU thread gets a position p1 from P , and continues search from that position until a NN evaluation is needed. It then saves the current search state (which can be expressed as a single pointer to the current tree node), and submits the necessary calculation to the GPU queue. It then moves on to another position p2 from P , which isn\u2019t awaiting a neural net evaluation."}, {"heading": "B Monte Carlo Tree Search Parameters and Rapid Action Value Estimation (RAVE)", "text": "RAVE is a technique for providing estimates of the values of moves in the search tree more rapidly in the early stages of exploring a state than is achieved with UCT alone.\nThis is important, because the Monte Carlo value heuristic requires multiple samples to achieve a low variance estimate of the value, which is particularly problematic when there are many actions available.\nA common property of many games is that a move that is strong at time t2 is likely to have also been strong at time t1 < t2. For instance, in stone placing games such as Go and Hex, if claiming a cell is useful, it may also have been advantageous to claim it earlier. RAVE attempts to exploit this heuristic to harness estimates for many actions from a single rollout.\nRAVE statistics nRAVE(s), nRAVE(s, a) and rRAVE(s, a) are stored that correspond to the statistics used in normal UCT. After a simulation s1, a1, s2, a2, ..., sT , with result R, RAVE statistics are updated as follows:\nnRAVE(sti , atj ) := nRAVE(sti , atj ) + 1 \u2200 ti < tj rRAVE(sti , atj ) := rRAVE(sti , atj ) +R \u2200 ti < tj\nnRAVE(sti) := \u2211 a nRAVE(sti , a) \u2200 ti\nIn other words, the statistics for state sti are updated for each action that came subsequently as if the action were taken first. This is also known as the all-moves-asfirst heuristic, and is applicable in any domain where actions can often be transposed.\nTo use the statistics a UCTRAVE is calculated, and averaged with the standard UCT into the tree policy to give UCTUR, which then chooses the action. Specifically:\nUCTRAVE(s, a) = rRAVE(s, a)\nnRAVE(s, a) + cb\n\u221a log nRAVE(s)\nnRAVE(s, a)\n\u03b2(s, a) =\n\u221a cRAVE\n3n(s) + cRAVE\nUCTUR =\u03b2(s, a)UCTRAVE(s, a)\n+ (1\u2212 \u03b2(s, a))UCT(s, a)\nThe weight factor \u03b2(s, a) trades the low variance values given by RAVE with the bias of that estimate. As the number of normal samples n(s) increases, the weight given to the RAVE samples tends to 0. cRAVE governs how quickly the RAVE values are down-weighted as the number of samples increases.\nWhen using priors, we define UCTNN,RAVE in a similar way (i.e. replacing the statistics n(s), n(s, a) and r(s, a) with their RAVE counterparts), and average this with UCTNN with the same weight factor \u03b2(s, a).\nParameters for our Monte Carlo Tree Search, including for RAVE, are in table 1"}, {"heading": "C Neural Network Architecture", "text": "Input Features. We use the same state representation as Young et al. [16]: a twodimensional state of 9 \u00d7 9 Hex board is extend to a 6 channel input. The 6 channels\nrepresent: black stone locations, white stone locations, black stones connected to the north edge, black stones connected to the south edge, white stones connected to the west edge and white stones connected to the east edge.\nIn line with Young et al. [16], to help with the use of convolutions up to the board edge, we also expand the board, adding two extra rows or columns to each side. On the extra cells thus created, we add dummy stones: along the North and South edges, black stones, along the East and West edges, White stones. In each corner of the padding, we \u2018place both a black and a white stone\u2019. The resultant encoding of the board is shown in figure 3.\nPlaying Hex on this expanded board, with the dummy stones providing connections in the same way as stones played by players does not change the game, but it means that convolutions centred at the edge of the board have more meaningful input than would be provided by zero-padding these cells.\nNeural network architecture. Our network has 13 convolution layers followed by 2 parallel fully connected softmax output layers.\nThe parallel softmax outputs represent the move probabilities if it is white to move, and the move probabilities if it is black to move. Before applying the softmax function, a mask is used to remove those moves which are invalid in the current position (i.e. those cells that already have a stone in them).\nBecause the board topology is a hexagonal grid, we use hexagonal filters for our convolutional layers. A 3\u00d7 3 hexagonal filter centred on a cell covers that cell, and the 6 adjacent cells; a 5\u00d7 5 hexagonal filter covers the central cell, and all 18 cells within distance two of it.\nIn convolution layers 1-8 and layer 12, the layer input is first zero padded and then convolved with 64 3 \u00d7 3 hexagonal filters with stride 1. Thus the shape of the layer\u2019s output is the same as its input. Layers 9 and 10 do not pad their input, and layers 11 and 13 do not pad, and have 1\u00d7 1 filters\nOur convolution layers use Exponential linear unit (ELU) [19] nonlinearities. Different biases are used in each position for all convolution layers and normalisation propagation [18] is applied in layers 1-12.\nThis architecture is illustrated in figure 4.\nTraining details. At each training step, a randomly selected mini batch of 250 samples is selected from the training data set and adam [12] is used as optimiser. We regularise the network with early stopping. The early stopping point is the first epoch after which the validation errors increase 3 times consecutively. An epoch length is one iteration over each data point in the data set."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "Solving sequential decision making problems, such as text parsing, robotic<lb>control, and game playing, requires a combination of planning policies and gen-<lb>eralisation of those plans. In this paper, we present Expert Iteration, a novel al-<lb>gorithm which decomposes the problem into separate planning and generalisation<lb>tasks. Planning new policies is performed by tree search, while a deep neural net-<lb>work generalises those plans. In contrast, standard Deep Reinforcement Learning<lb>algorithms rely on a neural network not only to generalise plans, but to discover<lb>them too. We show that our method substantially outperforms Policy Gradients in<lb>the board game Hex, winning 84.4% of games against it when trained for equal<lb>time.", "creator": "LaTeX with hyperref package"}}}