{"id": "1705.09970", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-May-2017", "title": "Probabilistic Program Abstractions", "abstract": "abstraction is a fundamental tool for reasoning about complex systems. program abstraction has been utilized as to great effect for analyzing structured deterministic programs. at the heart of pro - gram abstraction is the relationship between a concrete program, type which is difficult to well analyze, and an abstraction, formula which is yet more tractable. and we generalize non - logical deterministic program experience abstractions essentially to probabilistic program concept abstractions by explicitly quantifying the non - deterministic choices made by traditional program abstractions. we upgrade key theoretical program abstraction insights to the probabilistic context. probabilistic program evaluation abstractions provide avenues for utilizing abstraction techniques collected from the programming languages community to improve the analysis of probabilistic complex programs.", "histories": [["v1", "Sun, 28 May 2017 17:53:01 GMT  (24kb)", "https://arxiv.org/abs/1705.09970v1", null], ["v2", "Fri, 14 Jul 2017 15:46:25 GMT  (26kb)", "http://arxiv.org/abs/1705.09970v2", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["steven holtzen", "todd millstein", "guy van den broeck"], "accepted": false, "id": "1705.09970"}, "pdf": {"name": "1705.09970.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["sholtzen@cs.ucla.edu", "todd@cs.ucla.edu", "guyvdb@cs.ucla.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 5.\n09 97\n0v 2\n[ cs\n.A I]\n1 4\nJu l 2\nAbstraction is a fundamental tool for reasoning about complex systems. Program abstraction has been utilized to great effect for analyzing deterministic programs. At the heart of program abstraction is the relationship between a concrete program, which is difficult to analyze, and an abstract program, which is more tractable. Program abstractions, however, are typically not probabilistic. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying the non-deterministic choices. Our framework upgrades key definitions and properties of abstractions to the probabilistic context. We also discuss preliminary ideas for performing inference on probabilistic abstractions and general probabilistic programs."}, {"heading": "1 INTRODUCTION & MOTIVATION", "text": "Program abstractions are a richly studied method from the programming languages community for reasoning about intractably complex programs (Cousot and Cousot, 1977). An abstraction is typically an over-approximation to a program: any execution that is possible in the original program is contained within the abstraction. Over-approximation allows abstractions to be used to prove program invariants: any property of all executions in the abstraction is also true of all executions in the original program. To achieve this goal while being more tractable than the concrete program, abstractions work on a simplified domain. The abstraction selectively models particular aspects of the original program while utilizing non-determinism to conservatively model the rest.\nNon-deterministic abstractions are useful for verifying\nproperties such as reachability in a concrete program. However, abstractions are decidedly not probabilistic: they are concerned with the possible, not the probable. Therefore, they fail to support more nuanced queries such as probabilistic reachability, or probabilistic program inference. We seek to enhance the program abstraction framework by explicitly quantifying the non-deterministic choices made in the abstraction, turning the program abstraction into a probabilistic model. That is, our probabilistic abstractions are themselves probabilistic programs, which have been the subject of intense study recently (e.g., Goodman et al. (2008); Fierens et al. (2013); Wood et al. (2014); Carpenter et al. (2016)).\nThe key contribution of this paper is the development of a foundational theory for probabilistic program abstractions. We define probabilistic abstractions as a natural generalization of traditional abstractions, using random variables as the abstraction mechanism instead of nondeterminism. We also formalize the relationship between a probabilistic abstraction and a concrete program, again generalizing from the non-deterministic setting. This includes semantics in both the concrete and abstract domain, the connection between these semantics, and the notion of a sound probabilistic over-approximation.\nA well-known construction of non-deterministic program abstractions is that of a predicate abstraction (Graf and Sa\u00efdi, 1997; Ball et al., 2001). It induces an abstraction relative to a given set of Boolean predicates about the program state. We define probabilistic predicate abstractions, which are represented by a simple Bernoulli probabilistic program, as an instance of our framework, and a generalization of classical predicate abstraction.\nWe conclude with a discussion of ideas for performing inference in probabilistic predicate abstractions, building on model checking techniques from the programming languages community and weighted model count-\ning from the artificial intelligence community. We then discuss how probabilistic abstractions could be used to simplify inference in probabilistic concrete programs."}, {"heading": "2 NON-DETERMINISTIC PROGRAM ABSTRACTION", "text": "In this section we provide the semantics and properties of an over-approximate non-deterministic abstraction and provide an example of a particular class of overapproximations known as predicate abstractions."}, {"heading": "2.1 SEMANTICS AND PROPERTIES", "text": "A concrete program is a syntactic object written C. The semantics of a concrete program,which for simplicity we also denote C, is a function from input states to output states over some concrete domain DC . Concrete states are total assignments to all variables in the concrete domain, which we denote z \u2208 DC .\nIn general, the problem of proving that a given program satisfies a desired invariant is undecidable. Advances in theorem proving techniques such as Satisfiability Modulo Theory (SMT) solvers (e.g., De Moura and Bj\u00f8rner (2008)) render reasoning in many useful theories tractable, yet there exist common program structures that lie outside of supported theories.\nThe framework of abstract interpretation (Cousot and Cousot, 1977) provides a general technique for relating a concrete program C to another program A which we refer to as an abstraction. We describe a specialization of the abstract interpretation framework.\nDefinition 2.1. Abstract semantics of an abstraction. The abstract semantics of an abstraction A, which for simplicity we also denote A, is a function from input states to sets of output states over an abstract domainDA,\nwritten A : DA \u2192 2DA .\nIntuitively, the nondeterminism in the abstract semantics of an abstraction represents uncertainty due to the loss of information in abstracting C to A. We represent this non-determinism as a set of possible abstract states, denoted a \u2208 DA. To relate concrete programswith abstractions we introduce two mappings between concrete and abstract states.\nDefinition 2.2. Abstraction and concretization functions. An abstraction function for DC and DA is a function \u03b1 : DC \u2192 DA that maps each concrete state to its abstract representative. A concretization function for DC and DA is a function \u03b3 : DA \u2192 2DC that maps each abstract state to a set of concrete states. When applied to sets, \u03b3 and \u03b1 respectively concretize or abstract each element of the set.\nAbstraction and concretization functions are related.\nDefinition 2.3. Compatibility. An abstraction function \u03b1 and concretization function \u03b3 are compatible if z \u2208 \u03b3(\u03b1(z)) for all z \u2208 DC . As an extension, the two functions are strongly compatible if they are compatible and for any a and z \u2208 \u03b3(a), we have that z /\u2208 \u03b3(a\u2032) for any a\u2032 6= a.\nA predicate domain is a well-studied abstract domain induced by a given sequence of predicates (p1, . . . , pn) about the concrete state. The abstract domain DA consists of n Boolean variables (b1, . . . , bn) and so has 2 n possible elements, one for each valuation to the n variables. For instance, suppose DC consists of a single integer variable x whose value is in the range [\u22122, 2]. The single predicate (x < 0) induces an abstract domain with two possible states, representing the concrete states where (x < 0) is true and false. See Figure 1 for a visualization. The abstraction function \u03b1 maps each concrete state z to the abstract state (p1(z), . . . , pn(z)), and the concretization function \u03b3 maps each abstract state a to the set of concrete states consistent with it: {z \u2208 DC | (p1(z), . . . , pn(z)) = a}. The functions \u03b1 and \u03b3 are strongly compatible for predicate domains.\nIntuitively, an abstraction represents a set of possible concrete programs, which is formalized as follows:\nDefinition 2.4. Concrete semantics of an abstraction. The concrete semantics of an abstraction A, given compatible abstraction and concretization functions \u03b1 and \u03b3, is a function [[A]] : DC \u2192 2DC defined as follows:\n[[A]](z) = \u03b3 ( A(\u03b1(z)) ) ,\nwhere \u03b3 is applied to each element of A(\u03b1(z)).\nUltimately we wish to prove properties about a particular concrete program C by reasoning about some simpler\nabstract programA. From the above definition of an abstraction\u2019s concrete semantics we immediately obtain the following criterion for relating a specific concrete program C to A:\nDefinition 2.5. Sound over-approximation. Let A be some abstract program with compatible abstraction and concretization functions \u03b1 and \u03b3. The tuple (A, \u03b1, \u03b3) is a sound over-approximation of C if for all z \u2208 DC , C(z) \u2208 [[A]](z).\nIn other words, A is sound for C if the result of any concrete execution of C is contained within the possible concretizations of the result of A executed on the abstracted input. Sound over-approximations can be used to verify safety properties of programs, which intuitively express the fact that certain \u201cbad\u201d things never happen (e.g., no null dereferences will occur). Every safety property can be formalized as a requirement that some set B of \u201cbad\u201d states in the concrete program never be reached. To prove that C(z) 6\u2208 B for each concrete state z, it suffices to prove that \u03b3([[A]](a)) \u2229 B = \u2205 for each abstract state a \u2208 DA, where A is a sound over-approximation of C.\nIn general, the construction of an abstraction is a careful balance between precision, the fidelity of the abstraction to the original concrete program, and tractability, how difficult the abstraction is to construct and reason about. For abstract predicate domains, adding more predicates to the domain increases precision but also makes the abstraction more costly to produce and analyze.\nThe semantics above treats programs C and A as blackbox input-output functions. Nevertheless, the semantics straightforwardly generalizes to assign meaning to every single line of code in the programs, allowing us to establish a sound over-approximation throughout."}, {"heading": "2.2 PREDICATE ABSTRACTION", "text": "A predicate abstraction is a well-studied program abstraction whose abstract domain is a predicate domain (Graf and Sa\u00efdi, 1997; Ball et al., 2001) (see the previous section for the definition of a predicate domain). Predicate abstractions are known as Boolean programs: the domain DA = {T, F}n. Safety checking in Boolean programs is decidable: a Boolean program has a finite set of states over a fixed number of Boolean variables, making it decidable to obtain the set of reachable states. Given a concrete program C and a set of n predicates (p1, . . . , pn) over the concrete domainDC , the goal of the predicate abstraction process is to construct an abstract Boolean programA that forms a sound overapproximation of C and is as precise as possible relative to the given predicates.\nWe use the simple program in Figure 2 as an exam-\n1 if(x<0) { 2 x = 0 3 } else { 4 x = x + 1 5 }\nFigure 2: A simple concrete program over an integer variable x.\n1 if(*) { 2 assume({x<3}) 3 {x<-4}, {x<3} = F, T 4 } else { 5 assume(!{x<-4}) 6 {x<-4}, {x<3} = 7 choose(F, !{x<3} \u2228 !{x<-4}), 8 choose({x<-4}, !{x<3}) 9 }\nFigure 3: A predicate abstraction of the program in Figure 2 induced by the predicatesx<-4 and x<3. Note that predicate updates that are abstractions of the same concrete assignment statement are updated simultaneously.\nple to illustrate the predicate abstraction process. The Boolean program induced by the predicates x<-4 and x<3 is shown in Figure 3. Following the notation of Ball et al. (2001), the * operator represents nondeterministic choice, and the Boolean variable associated with predicate p is denoted {p}. We describe the predicate abstraction process for branches and assignments in turn."}, {"heading": "2.2.1 Abstracting Branches", "text": "Consider a conditional statement of the form\nif (p) {\u00b7 \u00b7 \u00b7} else {\u00b7 \u00b7 \u00b7}\nin the concrete program. Let pT denote the strongest propositional formula over the predicates p1, . . . , pn that is implied by p and pF denote the strongest propositional formula over the predicates p1, . . . , pn that is implied by !p. These formulas represent the most precise information we can know inside the then and else branches respectively, given the predicates in the abstraction. They can be obtained through queries to an SMT solver, assuming that p and the n predicates are all in decidable logical theories; see Ball et al. (2001) for details. The predicate abstraction process translates the above conditional as follows in the Boolean program:\nif (*) {\nassume({p T }) ...\n} else {\nassume({p F }) ...\n}\nHere {pT} is pT but with each predicate pi replaced by its Boolean counterpart {pi}, and similarly for {p F}. The statement assume(\u03d5), which is standard in the programming languages community, silently ignores execu-\ntions which do not satisfy \u03d5. Note that {pT} and {pF} can simultaneously be true, which allows the execution to nondeterministically take either branch of the conditional.\nIn the program of Figure 2, we know that x<0 is true in the then clause. In Figure 3, the strongest information our abstraction can know at that point is that (the Boolean variable corresponding to) x<3 is true. Similarly, x<0 is false in the else branch in Figure 2, while the abstraction in Figure 3 only knows that x<-4 is false."}, {"heading": "2.2.2 Abstracting Assignment Statements", "text": "Consider an assignment statement of the form x = e in the concrete program. In the corresponding point of the abstract program we must simultaneously update the values of all Boolean variables to reflect the update to the value of x. Suppose we want to update the variable {pi}. Let pTi denote the weakest propositional formula over the predicates p1, . . . , pn such that p T i holding before the assignment x = e suffices to ensure that pi will be true after the assignment. Similarly let pFi denote the weakest propositional formula over the predicates p1, . . . , pn such that pFi holding before the assignment x = e suffices to ensure that pi will be false after the assignment. Again an SMT solver can be used to obtain these formulas, leveraging the standard notion of the weakest precondition of an assignment statement with respect to a predicate (Dijkstra, 1976). The predicate abstraction process updates the Boolean variable {pi} as follows in the Boolean program:\n{pi} = choose({p T i }, {p F i })\nHere choose(\u03d51, \u03d52) returns T if \u03d51 is satisfied, otherwise returns F if \u03d52 is satisfied, and otherwise chooses nondeterministically between T and F .\nConsider the assignment statement x = 0 in Figure 2. The abstraction process described above will assign {x<3} in the Boolean program to choose(T, F), which simplifies to just T as shown in Figure 3. More interestingly, consider the assignment statement x = x + 1 in Figure 2. If x<-4 is true before the assignment, then we can be sure that x<3 is true afterward. If x<3 is false before the assignment, then we can be sure that x<3 is false afterward. If neither of these is the case, then the abstraction does not have enough information to know the value of x<3 after the assignment. Hence in the Boolean program {x<3} is assigned to choose({x<-4}, !{x<3}).\nInvariants Multiple predicates that involve the same variable are typically constrained in some way. For example, the predicates {{x<3}, {x<-4}} are con-\nstrained due to the relationship {x<-4}\u21d2{x<3}. This constraint is an invariant which increases the precision of the abstraction with minimal decrease in tractability. We call this constraint I, and we can enforce it simply by inserting an assume(I) statement after each set of assignments."}, {"heading": "2.2.3 Proving Program Invariants", "text": "A predicate abstraction is a sound over-approximation of the original concrete program. Further, because a Boolean program has a finite set of possible states at each point in the program, it can be exhaustively explored via a form of model checking, which conceptually executes the program in all possible ways (Ball and Rajamani, 2000). Model checking produces the set of reachable states at each point in the program, and this information can be used to verify invariants of the original program.\nConsider the Boolean program in Figure 3. All executions of this program end in a state where the Boolean variable {x<-4} has the value F . This implies that x always ends in a value greater than or equal to -4 in the original program in Figure 2. On the other hand, our predicate abstraction is not precise enough to verify that x always ends in a nonnegative value, though that is true of the original program. A different choice of predicates would enable such reasoning in the abstraction.\nSelecting predicates The selection of predicates is clearly a critical component of an effective predicate abstraction. In this work we focus on the definition and construction of probabilistic predicate abstractions given a fixed set of predicates, leaving automated selection of predicates for future work. The programming languages community has developed several approaches to the problem of predicate selection. A common approach is to use a form of counterexample-driven refinement, which iteratively adds predicates until the abstraction is precise enough to prove or disprove the desired property of the concrete program (e.g., Ball and Rajamani (2002)). Extending these techniques to the probabilistic context is a challenging and exciting research problem."}, {"heading": "3 PROBABILISTIC PROGRAM ABSTRACTION", "text": "The primary contribution of this paper is the extension of the non-deterministic program abstractions of the previous section to the probabilistic context. We begin by defining a simple probabilistic programming language. Syntactically, our probabilistic predicate abstractions will simply be probabilistic programs in this language. Next, we generalize the abstraction semantics\nof Section 2.1 to the probabilistic context, and define soundness criteria for probabilistic program abstractions. Finally, we generalize the predicate abstraction process from Section 2.2 to the probabilistic context by placing distributions on the non-deterministic choices."}, {"heading": "3.1 PROBABILISTIC PROGRAMMING", "text": "We define a simple probabilistic programming language, BERN, which contains only (1) Boolean variables; (2) Boolean operators; (3) Boolean assignments; (4) if statements; (5) a flip(\u03b8) operator, which is a Bernoulli random variable with parameter \u03b8; and (6) an observe(\u03d5) statement, which ignores executions that do not satisfy some condition \u03d5. Note that observe statements can also be captured by a conditional probability query on the distribution.\nAn extension to BERN is to introduce a goto construct, which would allow it to reason about underlying concrete programs with arbitrary control flow. The predicate abstraction framework makes reasoning about loopy concrete programs tractable (Ball et al., 2001); however, we defer generalizing the semantics of loopy probabilistic predicate abstractions to future work. As an example of a BERN program, one can construct a program that encodes a Bayesian network a\u00a9 \u2192 b\u00a9:\na = flip(\u03b81) if(a) { b = flip(\u03b82)} else { b = flip(\u03b83)} observe(b)\nThis probabilistic program defines the conditional probability of each event by utilizing the control-flow features of BERN. For example,Pr(b | \u00aca) = \u03b83. The observe statement conditions the Bayesian network on some evidence: thus, queries about a in this program correspond to Pr(a | b).\nProbabilistic programming has proven a natural tool for the construction of generative statistical models. As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013)."}, {"heading": "3.2 PROBABILISTIC SEMANTICS", "text": "Section 2.1 identifies both the abstract and concrete semantics of a program abstraction. We generalize these non-deterministic semantics to probabilistic semantics by producing families of compatible probability distributions described by constraints on their support.\nSince syntactically abstractions will be probabilistic pro-\ngrams, the abstract semantics of a probabilistic abstraction are simply the semantics of that program, broadly defined.\nDefinition 3.1. Abstract semantics. Let ai, ao \u2208 DA. The abstract semantics of a probabilistic abstraction A, denoted PrA(ao | ai), is a conditional probability distribution over abstract domain DA, which describes the probability of transitioning from an initial set of states ai to an output state ao under the abstractionA.\nTo define the concrete semantics of a probabilistic abstraction, we first need to generalize the concretization function \u03b3 to the probabilistic context.\nDefinition 3.2. Concretization distribution. Let z \u2208 DC and a \u2208 DA. A concretization distribution is a conditional probability distributionPr\u03b3(z | a) that describes the probability of concretizing an abstract state a to some concrete state z.\nIn the non-deterministic setting, we were concerned only with membership in the set \u03b3. Here, we generalized \u03b3 to the probabilistic context by placing a distribution over possible concretizations.1 Concretization distributions and abstraction functions are related as follows:\nDefinition 3.3. Compatibility. An abstraction function \u03b1 and concretization distributionPr\u03b3 are compatible when, for all z \u2208 DC , Pr\u03b3(z | \u03b1(z)) > 0. Furthermore, these functions are strongly compatible if they are compatible and for any a and z such that Pr\u03b3(z | a) > 0, we have that Pr\u03b3(z | a \u2032) = 0 for all a\u2032 6= a.\nWe are now in a position to define the concrete semantics of a probabilistic abstraction.\nDefinition 3.4. Concrete semantics. Let zi, zo \u2208 DC be some input and output concrete states. The concrete semantics of an abstraction A given a compatible abstraction function \u03b1 and concretization distribution Pr\u03b3 is a conditional probability distribution describing the probability of transitioning from zi to zo:\nPr[[A]](zo | zi) = \u2211\nao\u2208DA\nPr\u03b3(zo | ao) PrA(ao | \u03b1(zi)).\nIn the case when \u03b1 and Pr\u03b3 are strongly compatible, we can refine the above definition:\nProposition 3.1. Let zo, zi \u2208 DC . For strongly compatible \u03b1 and Pr\u03b3 , there exists a single ao for which Pr\u03b3(zo | ao) > 0. Thus the sum may be collapsed:\nPr[[A]](zo | zi) = Pr\u03b3(zo | ao) PrA(ao | \u03b1(zi)).\n1For continuous concrete domains, concretization distributions directly generalize to concretization densities.\nAs an example, we saw previously that predicate domains allow for strongly compatible concretization and abstraction functions. We see in Figure 4 a probabilistic extension to non-deterministic predicate abstraction.\nUnder the probabilistic semantics, we can define a probabilistic analog of the over-approximation property of A as a constraint on the support of Pr[[A]].\nDefinition 3.5. Sound probabilistic overapproximation. Let A be a probabilistic program abstraction with compatible abstraction function \u03b1 and concretization distribution Pr\u03b3 . Then the tuple (A, \u03b1, Pr\u03b3) is a sound probabilistic over-approximation of concrete program C if for all z \u2208 DC , Pr[[A]](C(z) | z) > 0."}, {"heading": "3.2.1 Non-Deterministic Semantics", "text": "A sound probabilistic over-approximation is a generalization of a sound non-deterministic over-approximation in the sense that it provides a distribution over feasible states. Thus a sound probabilistic over-approximation has a corresponding sound non-deterministic overapproximation, which we make precise in the following definitions:\nDefinition 3.6. Non-deterministic semantics. Let A be a probabilistic program abstraction with compatible concretization distribution Pr\u03b3 and abstraction function \u03b1. Then there is a corresonding non-deterministic concretization function \u03b3(a)\u2193 = {z | Pr\u03b3(z | a) > 0)} and abstract non-deterministic program A(a)\u2193 = {a\u2032 | PrA(a \u2032 | a) > 0)}.\nWe observe that \u03b3(a)\u2193 is compatible with \u03b1 if Pr\u03b3 is compatible with \u03b1. Further, soundness of a probabilistic abstraction implies soundness of its corresponding nondeterministic abstraction, and vice versa:\nTheorem 3.1. Non-deterministic sound overapproximation. For any probabilistic program abstraction A with compatible concretization distribution Pr\u03b3 and abstraction function \u03b1, the tuple (A, \u03b1,Pr\u03b3) is a sound probabilistic over-approximation to concrete program C if and only if the tuple (A(\u00b7)\u2193, \u03b1, \u03b3(\u00b7)\u2193) is a sound non-deterministic over-approximation to C."}, {"heading": "3.2.2 Concretization Invariance", "text": "The concrete semantics Pr[[A]] are necessary for reasoning about the concrete domain. However, directly analyzing Pr[[A]] is made difficult by the necessity of selecting some compatible concretization distribution Pr\u03b3 . Significantly, in the case when a concrete query can be precisely represented using a set of abstract states, A alone provides sufficient structure to compute a probability in Pr[[A]] independent of the choice of Pr\u03b3 :\nTheorem 3.2. Concretization distribution invariance. Let A be a probabilistic program abstraction with strongly compatible concretization distribution Pr\u03b3 and abstraction function \u03b1. For any zi \u2208 DC and ao \u2208 DA,\nPr[[A]](ao|zi) def =\n\u2211\nzo\u2208\u03b3(ao)\u2193\nPr[[A]](zo|zi) = PrA(ao|\u03b1(zi)).\nIn other words, the probability of an abstracted event occurring in the concrete semantics is equivalent to the probability of that event in the abstract semantics, regardless of the concretization distribution.\nWe see a visualization of this theorem in Figure 4. Regardless of whether Pr1\u03b3 or Pr 2 \u03b3 are chosen,\nPr[[A]] ( \u03b3(\u03b1(x = \u22121))\u2193 )) = Pr[[A]]({\u22121,\u22122})\n= PrA({x < 0}).\nAs a consequence, queries performed on the abstraction A represent queries performed on the set of all possible strongly-compatible concretization distributions. Thus, even though in the probabilistic setting we must reason about a distribution over concrete states, we can still lift our analyses to the abstract domain, similar to the benefits of non-deterministic abstraction in Section 2.2.3."}, {"heading": "3.3 PROBABILISTIC PREDICATE ABSTRACTIONS", "text": "Thus far we have seen a semantics for a probabilistic program abstraction, but we do not yet have a way to generate one for a particular program. In this section, we seek to generalize predicate abstraction to the probabilistic domain, and show that in general a probabilistic predicate abstraction is a family of Boolean probabilistic programs with Bernoulli flip parameters."}, {"heading": "3.3.1 Branch Statements", "text": "We saw in Section 2.2.1 that a predicate abstraction of an if statement is of the form\nif(*) {assume(\u03b1) . . . } else {assume(\u03b2) . . .}\nwhere \u03b1 and \u03b2 represent the most precise information we can know about the state of predicates at the then and else branches of the program. The behavior of the abstraction is non-deterministic in the case when both \u03b1 and \u03b2 hold. A probabilistic predicate abstraction of this statement should explicitly quantify the probability of choosing a particular path when either path is possible in the abstraction.\nTo do so, we first rewrite the predicate abstraction\u2019s if statement equivalently as follows:\nif(\u00ac\u03b2 \u2228 (\u03b1 \u2227 \u2217)) { . . . } else { . . . }\nAs in the original formulation, this version ensures that the then clause will not be taken if \u03b1 is false and the else clause will not be taken if \u03b2 is false.2 The nondeterministic choice * then determines which path to take when both predicates are true.\nA probabilistic predicate abstraction must represent a distribution over paths when \u03b1 and \u03b2 both hold. Under the semantics of BERN, we may do so simply by replacing the non-deterministic choice with a flip:\nif(\u00ac\u03b2 \u2228 (\u03b1\u2227flip(\u03b8))) { ... } else { ... }\nThus a probabilistic version of the predicate abstraction in Figure 3 would have an if statement with guard {x<-4}\u2228({x<3}\u2227flip(\u03b8)), where \u03b8 represents the conditional probability that the branch is taken given -4 \u2264 x < 3. As long as 0 < \u03b8 < 1, all concrete executions are contained within the support of this probabilistic program abstraction, implying that it is a sound probabilistic over-approximation."}, {"heading": "3.3.2 Assignment Statements", "text": "Section 2.2.2 showed that a concrete assignment is abstracted to a set of predicate assignments of the form \u03b3 = choose(\u03b1, \u03b2), where \u03b3 is a predicate and \u03b1 and \u03b2 encode the most precise update we can make to \u03b3. The abstraction behaves non-deterministically: it may assign \u03b3 to either true or false when neither \u03b1 nor \u03b2 holds. Thus, the probabilistic generalization of an assignment statement needs to represent the conditional probability of \u03b3 given \u00ac\u03b1 \u2227 \u00ac\u03b2.\nFirst, we re-write the choose statement, introducing a non-deterministic * operator similar to the previous section. We may write an equivalent update to \u03b3:\n2Note that by construction \u03b1 and \u03b2 cannot both be false.\n\u03b3 = \u03b1 \u2228 (\u00ac\u03b2 \u2227*)\nAs above, in BERN we then replace * with a Bernoulli random variable:\n\u03b3 = \u03b1 \u2228 (\u00ac\u03b2 \u2227flip(\u03b8))\nFor example, under this strategy the assignment statement x=x+1 from Figure 3 would be abstracted to the following BERN program statements, given predicates {x<-3} and {x<4} :\n{x<-4}, {x<3} =\n({x<-4} \u2227 {x<3} \u2227 flip(\u03b81)), ({x<-4} \u2228 ({x<3} \u2227 flip(\u03b82)))"}, {"heading": "3.4 INVARIANTS", "text": "In the non-deterministic case, enforcing invariants among predicates is a lightweight procedure of inserting assume statements in order to increase the precision of the abstraction. Analogously, in the probabilistic case, we wish to represent distributions over predicates while disallowing inconsistent predicate states. In this section we explore the consequences of enforcing invariants on the abstraction.\nAn initial approach to enforcing invariants is to straightforwardly generalize the non-deterministic procedure by inserting observe(I) statements between each assignment, where I is the invariant which must hold over the predicates. For example, for the concrete program x=x+10 with the predicates {x<-4} and {x<3}, we generate the following abstraction:\n{x<-4}, {x<3} =\n({x<-4} \u2227 {x<3} \u2227 flip(\u03b81)), ({x<-4} \u2227 {x<3} \u2227 flip(\u03b82))\nobserve({x<-4}\u21d2{x<3})\nA key downside is that the parameters no longer have a local semantics: conditioning correlates the otherwise independent flips. This complicates the probability computation, which now involves a partition function.\nTherefore we present an alternative abstraction construction procedure which preserves the local semantics of the parameters of the abstraction while enforcing invariants over predicates. Consider again the concrete program x=x+10. We generate an abstraction using the same predicates as before. However, instead of simply inserting observe statements, we utilize control flow in order to effectively condition on the previously assigned value:\n{x<3} = {x<3} \u2227 {x<-4} \u2227 flip(\u03b81) if({x<3}) {\n{x<-4} = {x<-4} \u2227 flip(\u03b82) } else {\n{x<-4} = F }\nThis abstraction, which we call structurally dependent, updates each predicate sequentially, considering all previous decisions. Each concrete statement is abstracted to several abstract statements which utilize control flow to disallow invalid states. The state {x<-4}\u2227!{x<3} is guaranteed to have 0 probability without the use of observe statements. Further, the parameters have a local interpretation as a conditional probability: it is not necessary to compute a partition function to compute the probability of a particular predicate configuration.\nFundamentally, these two methods of constructing the abstraction represent different factorizations of the distribution. In the non-deterministic context with invariant enforcement, these two abstractions are equivalent."}, {"heading": "4 DISCUSSION", "text": "This paper focuses on the definition and key properties of probabilistic program abstractions. In this section we discuss natural next steps for the work. Traditional nondeterministic program abstractions are typically used to produce the set of reachable program states, in order to verify invariants. The analogous operation on a probabilistic program abstraction is inference. First we discuss possible approaches to inference for probabilistic predicate abstractions, by leveraging both model checking and weighted model counting. Second, we discuss how the ability to perform inference on a probabilistic abstraction could be a key enabler for a new approach to performing inference on more general probabilistic programs. The main idea is to reduce inference on a probabilistic program to the task of choosing particular flip probabilities for a corresponding probabilistic abstraction."}, {"heading": "4.1 INFERENCE FOR PROBABILISTIC PREDICATE ABSTRACTIONS", "text": "We believe that existing techniques from the programming languages literature which are designed for working with non-deterministic Boolean programs can be extended to perform inference on BERN programs. We can then use weighted model counting to evaluate queries. We note that abstractions allow one to query the marginal probability of an event at any point in the program, not merely upon program termination.\nProbabilistic Model Checking The problem of computing the set of reachable states in a Boolean program is known as the model checking problem and has been extensively studied by the programming languages community. Commonly one represents the set of reachable states at any point in the program as some Boolean knowledge base \u2206. In many existing\ntools, \u2206 is represented using a binary decision diagram (Ball and Rajamani, 2000). Inference in BERN is thus an extension to the traditional model checking paradigm in which we introduce weighted variables for the state of each flip. During model checking, we treat each flip as an unconstrained Boolean variable.\nFor example, consider the probabilistic predicate abstraction statement {x<4} = {x<4} \u2227 flip(\u03b8). We assume \u2206 = {x<4} prior to execution of statement. Following this statement, \u2206\u2032 = ({x<4}\u2227flip(\u03b8)) \u2228 (!{x<4} \u2227 !flip(\u03b8)). See Ball and Rajamani (2000) for more details.\nWeighted Model Counting Whereas model checking is usually concerned with determining whether A can reach a particular state, in probabilistic program inference we are concerned with the weighted sum of reachable states, where the weights are induced by the parameters of the flips in each model. The programming languages community has two primary methodologies for computing the set of reachable states in a Boolean program: (1) knowledge compilation to binary decision diagrams (Ball and Rajamani, 2000), and (2) satisfiability methods (Donaldson et al., 2011). Both of these approaches can be generalized to perform weighted model counting for inference in BERN.\nThe knowledge compilation approach to model checking is already capable of performing weighted model counting due to the nature of the queries efficiently supported by a binary decision diagram (Darwiche and Marquis, 2001), and is used for inference in discrete probabilistic programs (Fierens et al., 2013) and Bayesian networks (Chavira and Darwiche, 2008). The satisfiability approach to model checking can be extended to perform weighted model counting. This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al., 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al. (2009) for a survey of the subject."}, {"heading": "4.2 INFERENCE FOR GENERAL PROBABILISTIC PROGRAMS", "text": "Consider the probabilistic program in Figure 5a and suppose we want to evaluate Pr[[C]](c < 5). We will sketch an approach to doing so using probabilistic predicate abstractions.\nFigure 5b shows a probabilistic predicate abstraction for our original probabilistic program, induced by the predicates {a<5}, {b<5}, and {c<5}. Initially each flip has its own parameter to represent its probability. In\nthe figure, we show particular values for each parameter, which were computed by performing queries on fragments of the original concrete program. For example, the concrete assignment a = unif[0, 10) is abstracted to {a<5} = flip(1/2) by computingPr(a < 5) on this single statement of the concrete program. The other parameters can be learned similarly. The key point is that each of these queries is much easier to evaluate in the original program than the actual query of interest, as they are over smaller fragments of the program.\nNow we show that the abstraction captures enough detail to answer our query precisely. Computing the weighted model count using the approach described in the previous subsection, we see that:\nPrA({c<5}) =\n{a<5},{b<5},{c<5} \ufe37 \ufe38\ufe38 \ufe37\n0.5 \u00b7 0.5 \u00b7 0.5 +\n{a<5},!{b<5},{c<5} \ufe37 \ufe38\ufe38 \ufe37\n0.5 \u00b7 0.5 \u00b7 0.25\n+ 0.5 \u00b7 0.25 \u00b7 0.5 \ufe38 \ufe37\ufe37 \ufe38\n!{a<5},{b<5},{c<5}\n+ 0.5 \u00b7 0.75 \u00b7 0.25 \ufe38 \ufe37\ufe37 \ufe38\n!{a<5},!{b<5},{c<5}\n= 11\n32 .\nThe result is in fact the answer to the original query.\nIn this way, the inference problem on C is decomposed into two, potentially much simpler, problems: (i) fixing the parameters of an abstraction, and (ii) weighted model counting on the abstraction. There remains considerable theoretical work to formally connect the semantics of the probabilistic abstraction with a probabilistic concrete program, as well as practical work to realize the benefits of the approach on desired applications."}, {"heading": "5 RELATED WORK", "text": "Probabilistic reasoning and static analysis. Several recent works leverage a probabilistic model to guide refinements of a program abstraction (Grigore and Yang, 2016; Zhang et al., 2017). However, the abstractions\nthemselves are not probabilistic. Gehr et al. (2016) use static analysis of a probabilistic program to decompose the problem of inference along paths, which are then dispatched to specialized integration tools depending on the constraints of each path; this work analyzes the original concrete program and does not rely on abstractions.\nProbabilistic abstract interpretation. Probabilistic abstract interpretation is used to reason about programs with probabilistic semantics, for example to place upper bounds on the probability of a particular path (Monniaux, 2000) or construct Monte-Carlo methods (Monniaux, 2001); this line of work does not explore the connections between abstractions and probabilistic programs, nor does it model concrete programmarginals. However, our work does not reason about unbounded loops. The framework of Cousot and Monerau (2012) is a highly general framework for reasoning about programs using probabilistic abstract interpretation; however, they do not consider the abstraction itself to be a statistical model.\nProbabilistic programming systems. Many systems have been developed within the AI and programming languages communities that tackle the problem of probabilistic program inference, but few utilize abstractions. Systems such as Church (Goodman et al., 2008), Anglican (Wood et al., 2014), Stan (Carpenter et al., 2016), BLOG (Milch et al., 2005), and others directly analyze the concrete program. Weighted model counting and knowledge compilation have been used to perform probabilistic program inference (Fierens et al., 2013); they also do not leverage program abstractions. Several probabilistic inference approaches capture distributions in continuous domains by using Boolean predicates, either as an approximation (Michels et al., 2016) or as an exact representation (Belle et al., 2015a). Finally, program abstraction with the purpose of inference is an instance of approximate lifted inference (Kersting, 2012): the abstract domain groups together sets of concrete states, with the aim of reasoning at the higher level."}, {"heading": "6 CONCLUSION", "text": "Probabilistic program abstractions are currently unexplored territory for aiding in the analysis of programs, despite the popularity of probabilistic programming. We provided a formal framework, derived useful properties, and described probabilistic predicate abstractions techniques. Much theoretical and practical work remains to be done in exploring alternative characterizations, showing relationships between concrete programs and their abstractions, and building practical probabilistic abstraction tools. We hope our framework provides the foundational theory to enable these advances in the future."}, {"heading": "Acknowledgements", "text": "This work is partially supported by NSF grants #CCF1527923, #IIS-1657613, and #IIS-1633857, and by DARPA grant #N66001-17-2-4032. S.H. is supported by a National Physical Sciences Consortium Fellowship."}], "references": [{"title": "Bebop: A symbolic model checker for boolean programs", "author": ["T. Ball", "S.K. Rajamani"], "venue": "In SPIN Model Checking and Software Verification,", "citeRegEx": "Ball and Rajamani.,? \\Q2000\\E", "shortCiteRegEx": "Ball and Rajamani.", "year": 2000}, {"title": "The SLAM project: Debugging system software via static analysis", "author": ["T. Ball", "S.K. Rajamani"], "venue": "In Proc. of POPL,", "citeRegEx": "Ball and Rajamani.,? \\Q2002\\E", "shortCiteRegEx": "Ball and Rajamani.", "year": 2002}, {"title": "Automatic predicate abstraction of c programs", "author": ["T. Ball", "R. Majumdar", "T. Millstein", "S.K. Rajamani"], "venue": "In Proc. of PLDI,", "citeRegEx": "Ball et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Ball et al\\.", "year": 2001}, {"title": "Probabilistic inference in hybrid domains by weighted model integration", "author": ["V. Belle", "A. Passerini", "G. Van den Broeck"], "venue": "In Proc. of IJCAI,", "citeRegEx": "Belle et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Belle et al\\.", "year": 2015}, {"title": "Hashingbased approximate probabilistic inference in hybrid domains", "author": ["V. Belle", "G. Van den Broeck", "A. Passerini"], "venue": "In Proc. of UAI,", "citeRegEx": "Belle et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Belle et al\\.", "year": 2015}, {"title": "Stan: A probabilistic programming language", "author": ["B. Carpenter", "A. Gelman", "M. Hoffman", "D. Lee", "B. Goodrich", "M. Betancourt", "M.A. Brubaker", "P. Li", "A. Riddell"], "venue": "J. Statistical Software,", "citeRegEx": "Carpenter et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Carpenter et al\\.", "year": 2016}, {"title": "A scalable approximatemodel counter", "author": ["S. Chakraborty", "K.S. Meel", "M.Y. Vardi"], "venue": "In Proc. of CP,", "citeRegEx": "Chakraborty et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Chakraborty et al\\.", "year": 2013}, {"title": "On probabilistic inference by weighted model counting", "author": ["M. Chavira", "A. Darwiche"], "venue": "J. Artificial Intelligence,", "citeRegEx": "Chavira and Darwiche.,? \\Q2008\\E", "shortCiteRegEx": "Chavira and Darwiche.", "year": 2008}, {"title": "Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints", "author": ["P. Cousot", "R. Cousot"], "venue": "In Proc. of POPL,", "citeRegEx": "Cousot and Cousot.,? \\Q1977\\E", "shortCiteRegEx": "Cousot and Cousot.", "year": 1977}, {"title": "Probabilistic abstract interpretation", "author": ["P. Cousot", "M. Monerau"], "venue": "In Proc. of ESOP,", "citeRegEx": "Cousot and Monerau.,? \\Q2012\\E", "shortCiteRegEx": "Cousot and Monerau.", "year": 2012}, {"title": "A Knowledge Compilation Map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Proc. of IJCAI,", "citeRegEx": "Darwiche and Marquis.,? \\Q2001\\E", "shortCiteRegEx": "Darwiche and Marquis.", "year": 2001}, {"title": "An efficient smt solver", "author": ["L. De Moura", "N. Bj\u00f8rner. Z"], "venue": "In Proc. of TACAS/ETAPS,", "citeRegEx": "Moura and Z3,? \\Q2008\\E", "shortCiteRegEx": "Moura and Z3", "year": 2008}, {"title": "A Discipline of Programming", "author": ["E.W. Dijkstra"], "venue": "PrenticeHall, Englewood Cliffs, New Jersey,", "citeRegEx": "Dijkstra.,? \\Q1976\\E", "shortCiteRegEx": "Dijkstra.", "year": 1976}, {"title": "Psi: Exact symbolic inference for probabilistic programs", "author": ["T. Gehr", "S. Misailovic", "M. Vechev"], "venue": "Proc. of ESOP/ETAPS,", "citeRegEx": "Gehr et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Gehr et al\\.", "year": 2016}, {"title": "Model counting", "author": ["C.P. Gomes", "A. Sabharwal", "B. Selman"], "venue": "Handbook of Satisfiability,", "citeRegEx": "Gomes et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Gomes et al\\.", "year": 2009}, {"title": "A language for generative models", "author": ["N.D. Goodman", "V.K. Mansinghka", "D.M. Roy", "K. Bonawitz", "J.B. Tenenbaum. Church"], "venue": "In Proc. of UAI,", "citeRegEx": "Goodman et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Goodman et al\\.", "year": 2008}, {"title": "Construction of abstract state graphs with PVS", "author": ["S. Graf", "H. Sa\u00efdi"], "venue": "In Proc. of CAV,", "citeRegEx": "Graf and Sa\u00efdi.,? \\Q1997\\E", "shortCiteRegEx": "Graf and Sa\u00efdi.", "year": 1997}, {"title": "Abstraction Refinement Guided by a Learnt ProbabilisticModel", "author": ["R. Grigore", "H. Yang"], "venue": "Proc. of POPL,", "citeRegEx": "Grigore and Yang.,? \\Q2016\\E", "shortCiteRegEx": "Grigore and Yang.", "year": 2016}, {"title": "Lifted probabilistic inference", "author": ["K. Kersting"], "venue": "In Proc. of ECAI, pages 33\u201338,", "citeRegEx": "Kersting.,? \\Q2012\\E", "shortCiteRegEx": "Kersting.", "year": 2012}, {"title": "Approximate probabilistic inference with bounded error for hybrid probabilistic logic programming", "author": ["S. Michels", "A. Hommersom", "P.J.F. Lucas"], "venue": "In Proc. of IJCAI,", "citeRegEx": "Michels et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Michels et al\\.", "year": 2016}, {"title": "Blog: Probabilistic models with unknown objects", "author": ["B. Milch", "B. Marthi", "S. Russell", "D. Sontag", "D.L. Ong", "A. Kolobov"], "venue": "In Proc. of IJCAI,", "citeRegEx": "Milch et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Milch et al\\.", "year": 2005}, {"title": "Abstract interpretation of probabilistic semantics", "author": ["D. Monniaux"], "venue": "In International Symposium on Static Analysis,", "citeRegEx": "Monniaux.,? \\Q2000\\E", "shortCiteRegEx": "Monniaux.", "year": 2000}, {"title": "An abstract monte-carlo method for the analysis of probabilistic programs", "author": ["D. Monniaux"], "venue": "SIGPLAN Not.,", "citeRegEx": "Monniaux.,? \\Q2001\\E", "shortCiteRegEx": "Monniaux.", "year": 2001}, {"title": "The complexity of computing the permanent", "author": ["L.G. Valiant"], "venue": "J. Theoretical Computer Science,", "citeRegEx": "Valiant.,? \\Q1979\\E", "shortCiteRegEx": "Valiant.", "year": 1979}, {"title": "A new approach to probabilistic programming inference", "author": ["F. Wood", "J.W. van de Meent", "V. Mansinghka"], "venue": "In Proc. of AISTATS,", "citeRegEx": "Wood et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Wood et al\\.", "year": 2014}, {"title": "Closing the gap between short and long xors for model counting", "author": ["S. Zhao", "S. Chaturapruek", "A. Sabharwal", "S. Ermon"], "venue": "In Proc. of AAAI,", "citeRegEx": "Zhao et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zhao et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 8, "context": "Program abstractions are a richly studied method from the programming languages community for reasoning about intractably complex programs (Cousot and Cousot, 1977).", "startOffset": 139, "endOffset": 164}, {"referenceID": 14, "context": ", Goodman et al. (2008); Fierens et al.", "startOffset": 2, "endOffset": 24}, {"referenceID": 14, "context": ", Goodman et al. (2008); Fierens et al. (2013); Wood et al.", "startOffset": 2, "endOffset": 47}, {"referenceID": 14, "context": ", Goodman et al. (2008); Fierens et al. (2013); Wood et al. (2014); Carpenter et al.", "startOffset": 2, "endOffset": 67}, {"referenceID": 5, "context": "(2014); Carpenter et al. (2016)).", "startOffset": 8, "endOffset": 32}, {"referenceID": 16, "context": "A well-known construction of non-deterministic program abstractions is that of a predicate abstraction (Graf and Sa\u00efdi, 1997; Ball et al., 2001).", "startOffset": 103, "endOffset": 144}, {"referenceID": 2, "context": "A well-known construction of non-deterministic program abstractions is that of a predicate abstraction (Graf and Sa\u00efdi, 1997; Ball et al., 2001).", "startOffset": 103, "endOffset": 144}, {"referenceID": 8, "context": "The framework of abstract interpretation (Cousot and Cousot, 1977) provides a general technique for relating a concrete program C to another program A which we refer to as an abstraction.", "startOffset": 41, "endOffset": 66}, {"referenceID": 16, "context": "A predicate abstraction is a well-studied program abstraction whose abstract domain is a predicate domain (Graf and Sa\u00efdi, 1997; Ball et al., 2001) (see the previous section for the definition of a predicate domain).", "startOffset": 106, "endOffset": 147}, {"referenceID": 2, "context": "A predicate abstraction is a well-studied program abstraction whose abstract domain is a predicate domain (Graf and Sa\u00efdi, 1997; Ball et al., 2001) (see the previous section for the definition of a predicate domain).", "startOffset": 106, "endOffset": 147}, {"referenceID": 2, "context": "Following the notation of Ball et al. (2001), the * operator represents nondeterministic choice, and the Boolean variable associated with predicate p is denoted {p}.", "startOffset": 26, "endOffset": 45}, {"referenceID": 2, "context": "They can be obtained through queries to an SMT solver, assuming that p and the n predicates are all in decidable logical theories; see Ball et al. (2001) for details.", "startOffset": 135, "endOffset": 154}, {"referenceID": 12, "context": "Again an SMT solver can be used to obtain these formulas, leveraging the standard notion of the weakest precondition of an assignment statement with respect to a predicate (Dijkstra, 1976).", "startOffset": 172, "endOffset": 188}, {"referenceID": 0, "context": "Further, because a Boolean program has a finite set of possible states at each point in the program, it can be exhaustively explored via a form of model checking, which conceptually executes the program in all possible ways (Ball and Rajamani, 2000).", "startOffset": 224, "endOffset": 249}, {"referenceID": 0, "context": ", Ball and Rajamani (2002)).", "startOffset": 2, "endOffset": 27}, {"referenceID": 2, "context": "The predicate abstraction framework makes reasoning about loopy concrete programs tractable (Ball et al., 2001); however, we defer generalizing the semantics of loopy probabilistic predicate abstractions to future work.", "startOffset": 92, "endOffset": 111}, {"referenceID": 5, "context": "As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013).", "startOffset": 141, "endOffset": 228}, {"referenceID": 15, "context": "As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013).", "startOffset": 141, "endOffset": 228}, {"referenceID": 24, "context": "As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013).", "startOffset": 141, "endOffset": 228}, {"referenceID": 0, "context": "In many existing tools, \u2206 is represented using a binary decision diagram (Ball and Rajamani, 2000).", "startOffset": 73, "endOffset": 98}, {"referenceID": 0, "context": "See Ball and Rajamani (2000) for more details.", "startOffset": 4, "endOffset": 29}, {"referenceID": 0, "context": "The programming languages community has two primary methodologies for computing the set of reachable states in a Boolean program: (1) knowledge compilation to binary decision diagrams (Ball and Rajamani, 2000), and (2) satisfiability methods (Donaldson et al.", "startOffset": 184, "endOffset": 209}, {"referenceID": 10, "context": "The knowledge compilation approach to model checking is already capable of performing weighted model counting due to the nature of the queries efficiently supported by a binary decision diagram (Darwiche and Marquis, 2001), and is used for inference in discrete probabilistic programs (Fierens et al.", "startOffset": 194, "endOffset": 222}, {"referenceID": 7, "context": ", 2013) and Bayesian networks (Chavira and Darwiche, 2008).", "startOffset": 30, "endOffset": 58}, {"referenceID": 23, "context": "This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al.", "startOffset": 24, "endOffset": 39}, {"referenceID": 6, "context": "This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al., 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al.", "startOffset": 105, "endOffset": 171}, {"referenceID": 25, "context": "This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al., 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al.", "startOffset": 105, "endOffset": 171}, {"referenceID": 3, "context": ", 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al. (2009) for a survey of the subject.", "startOffset": 8, "endOffset": 73}, {"referenceID": 17, "context": "Several recent works leverage a probabilistic model to guide refinements of a program abstraction (Grigore and Yang, 2016; Zhang et al., 2017).", "startOffset": 98, "endOffset": 142}, {"referenceID": 13, "context": "Gehr et al. (2016) use static analysis of a probabilistic program to decompose the problem of inference along paths, which are then dispatched to specialized integration tools depending on the constraints of each path; this work analyzes the original concrete program and does not rely on abstractions.", "startOffset": 0, "endOffset": 19}, {"referenceID": 21, "context": "Probabilistic abstract interpretation is used to reason about programs with probabilistic semantics, for example to place upper bounds on the probability of a particular path (Monniaux, 2000) or construct Monte-Carlo methods (Monniaux, 2001); this line of work does not explore the connections between abstractions and probabilistic programs, nor does it model concrete programmarginals.", "startOffset": 175, "endOffset": 191}, {"referenceID": 22, "context": "Probabilistic abstract interpretation is used to reason about programs with probabilistic semantics, for example to place upper bounds on the probability of a particular path (Monniaux, 2000) or construct Monte-Carlo methods (Monniaux, 2001); this line of work does not explore the connections between abstractions and probabilistic programs, nor does it model concrete programmarginals.", "startOffset": 225, "endOffset": 241}, {"referenceID": 9, "context": "The framework of Cousot and Monerau (2012) is a highly general framework for reasoning about programs using probabilistic abstract interpretation; however, they do not consider the abstraction itself to be a statistical model.", "startOffset": 17, "endOffset": 43}, {"referenceID": 15, "context": "Systems such as Church (Goodman et al., 2008), Anglican (Wood et al.", "startOffset": 23, "endOffset": 45}, {"referenceID": 24, "context": ", 2008), Anglican (Wood et al., 2014), Stan (Carpenter et al.", "startOffset": 18, "endOffset": 37}, {"referenceID": 5, "context": ", 2014), Stan (Carpenter et al., 2016), BLOG (Milch et al.", "startOffset": 14, "endOffset": 38}, {"referenceID": 20, "context": ", 2016), BLOG (Milch et al., 2005), and others directly analyze the concrete program.", "startOffset": 14, "endOffset": 34}, {"referenceID": 19, "context": "Several probabilistic inference approaches capture distributions in continuous domains by using Boolean predicates, either as an approximation (Michels et al., 2016) or as an exact representation (Belle et al.", "startOffset": 143, "endOffset": 165}, {"referenceID": 18, "context": "Finally, program abstraction with the purpose of inference is an instance of approximate lifted inference (Kersting, 2012): the abstract domain groups together sets of concrete states, with the aim of reasoning at the higher level.", "startOffset": 106, "endOffset": 122}], "year": 2017, "abstractText": "Abstraction is a fundamental tool for reasoning about complex systems. Program abstraction has been utilized to great effect for analyzing deterministic programs. At the heart of program abstraction is the relationship between a concrete program, which is difficult to analyze, and an abstract program, which is more tractable. Program abstractions, however, are typically not probabilistic. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying the non-deterministic choices. Our framework upgrades key definitions and properties of abstractions to the probabilistic context. We also discuss preliminary ideas for performing inference on probabilistic abstractions and general probabilistic programs.ion is a fundamental tool for reasoning about complex systems. Program abstraction has been utilized to great effect for analyzing deterministic programs. At the heart of program abstraction is the relationship between a concrete program, which is difficult to analyze, and an abstract program, which is more tractable. Program abstractions, however, are typically not probabilistic. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying the non-deterministic choices. Our framework upgrades key definitions and properties of abstractions to the probabilistic context. We also discuss preliminary ideas for performing inference on probabilistic abstractions and general probabilistic programs.", "creator": "LaTeX with hyperref package"}}}