{"id": "1706.05070", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jun-2017", "title": "Learning Disjunctions of Predicates", "abstract": "let $ f $ be a variable set of boolean functions. we present an algorithm useful for learning $ f _ \\ vee : = \\ { \\ vee _ { u f \\ in s } f \\ mid s \\ subseteq f \\ } $ differs from membership queries. our algorithm design asks at most $ | f | \\ cdot opt ( f _ \\ vee ) $ membership queries where $ com opt ( f _ \\ vee ) $ is choosing the minimum worst case number function of membership queries created for learning $ f _ \\ vee $. when $ f $ is a set of halfspaces over a constant dimension : space or a set of variable inequalities, our algorithm runs in polynomial time.", "histories": [["v1", "Thu, 15 Jun 2017 20:21:38 GMT  (652kb,D)", "http://arxiv.org/abs/1706.05070v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["nader h bshouty", "dana drachsler-cohen", "martin vechev", "eran yahav"], "accepted": false, "id": "1706.05070"}, "pdf": {"name": "1706.05070.pdf", "metadata": {"source": "CRF", "title": "Learning Disjunctions of Predicates", "authors": ["Nader H. Bshouty", "Dana Drachsler-Cohen", "Martin Vechev", "Eran Yahav", "BSHOUTY DRACHSLER-COHEN", "VECHEV YAHAV"], "emails": ["BSHOUTY@CS.TECHNION.AC.IL", "DDANA@CS.TECHNION.AC.IL", "MARTIN.VECHEV@INF.ETHZ.CH", "YAHAVE@CS.TECHNION.AC.IL"], "sections": [{"heading": null, "text": "The problem we address has practical importance in the field of program synthesis, where the goal is to synthesize a program that meets some requirements. Program synthesis has become popular especially in settings aiming to help end users. In such settings, the requirements are not provided upfront and the synthesizer can only learn them by posing membership queries to the end user. Our work enables such synthesizers to learn the exact requirements while bounding the number of membership queries."}, {"heading": "1. Introduction", "text": "Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007). Many of the new applications present new models and new problems. One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010). PBE has gained popularity because it enables end users to describe their intent to a program synthesizer via the intuitive means of input\u2013output examples. The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011). As a result, the synthesized program is not guaranteed to fully capture the user\u2019s intent. Another (less popular) PBE approach is to limit the program space to a\ncchar\u221e3 2017 N.H. Bshouty, D. Drachsler-Cohen, M. Vechev & E. Yahav.\nar X\niv :1\n70 6.\n05 07\n0v 1\n[ cs\n.L G\n] 1\n5 Ju\nsmall (finite) set of programs and ask the user membership queries while there are non-equivalent programs in the search space (Jha et al., 2010). A natural question is whether one can do better than the latter approach without sacrificing the correctness guaranteed by the former approach. In this paper, we answer this question for a class of specifications (i.e., formulas) that captures a wide range of programs.\nWe study the problem of learning a disjunctive (or dually, a conjunctive) formula describing the user intent through membership queries. To capture a wide range of program specifications, the formulas are over arbitrary, predefined predicates. In our setting, the end user is the teacher that can answer membership queries. This work enables PBE synthesizers to guarantee to the user that they have synthesized the correct program, while bounding the number of membership queries they pose, thus reducing the burden on the user.\nMore formally, let F be a set of predicates (i.e., boolean functions). Our goal is to learn the class F\u2228 of any disjunction of predicates in F . We present a learning algorithm SPEX, which learns any function in F\u2228 with polynomially many queries. We then show that given some computational complexity conditions on the set of predicates, SPEX runs in polynomial time.\nWe demonstrate the above on two classes. The first is the class of disjunctions (or conjunctions, whose learning is the dual problem) over any set H of halfspaces over a constant dimension. For this class, we show that SPEX runs in polynomial time. In particular, this shows that learning any convex polytope over a constant dimension when the sides are from a given set H can be done in polynomial time. For the case where the dimension is not constant, we show that learning this class implies P=NP. We note that there are other applications for learning halfspaces; for example, Hegedu\u030bs (1995); Zolotykh and Shevchenko (1995); Abboud et al. (1999); Abasi et al. (2014).\nThe second class we consider is conjunctions over F , where F is the set of variable inequalities, i.e., predicates of the form [xi > xj ] over n variables. If the set is acyclic (\u2227F 6= 0), we show that learning can be done in polynomial time. If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).\nThe second class has practical importance because it consists of formulas that can be used to describe time-series charts. Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al., 2010). Experts use these charts to predict important events (e.g., trend changes in a stock price) by looking for patterns in the charts. A lot of research has focused on common patterns and many platforms enable these experts to write a program that upon detecting a specific pattern alerts the user (e.g., some platforms for finance analysts are MetaTrader, MetaStock, Amibroker). Unfortunately, writing programs is a complex task for these experts, as they are not programmers. To help such experts, we integrated SPEX in a synthesizer that interacts with a user to learn a pattern (i.e., a conjunctive formula over variable inequalities). SPEX enables the synthesizer to guarantee that the synthesized program captures the user intent, while interacting with him only through membership queries that are visualized in charts.\nThe paper is organized as follows. Section 2 describes the model and class we consider. Section 3 provides the main definitions we require for the algorithm. Section 4 presents the SPEX algorithm, discusses its complexity, and describes conditions under which SPEX is polynomial. Sections 5 and 6 discuss the two classes we consider: halfspaces and variable inequalities. Finally, Section 7 shows the practical application of SPEX in program synthesis."}, {"heading": "2. The Model and Class", "text": "Let F be a finite set of boolean functions over a domain X (possibly infinite). We consider the class of functions F\u2228 := {\u2228f\u2208Sf | S \u2286 F}. Our model assumes a teacher that has a target function F \u2208 F\u2228 and a learner that knowsF but not the target function. The teacher can answer membership queries for the target function \u2013 that is, given x \u2208 X (from the learner), the teacher returns F (x). The goal of the learner (the learning algorithm) is to find the target function with a minimum number of membership queries.\nNotations Following are a few notations used throughout the paper. OPT(F\u2228) denotes the minimum worst case number of membership queries required to learn a function F in F\u2228. Given F \u2208 F\u2228, we denote by S(F ) the set that consists of all the functions in F . Formally, we define S(F ) = S, where S is the unique subset of F such that F = \u2228 f\u2208S f . For example, S(f1 \u2228 f2) = {f1, f2}. From this, it immediately follows that F1 \u2261 F2 if and only if S(F1) = S(F2). For a set of functions S \u2286 F , we denote \u2228S := \u2228f\u2208Sf . Lastly, [S(x)] denotes the boolean value of a logical statement. Namely, given a statement S(x) : X \u2192 {T, F}with a free variable x, its boolean function [S(x)] : X \u2192 {0, 1} is defined as [S(x)] = 1 if S(x) = T , and [S(x)] = 0 otherwise. For example, [x \u2265 2] = 1 if and only if the interpretation of x is greater than 2."}, {"heading": "3. Definitions and Preliminary Results", "text": "In this section, we provide the definitions used in this paper and show preliminary results. We begin by defining an equivalence relation over the set of disjunctions and defining the representatives of the equivalence classes. Thereafter, we define a partial order over the disjunctions and related notions (descendant, ascendant, and lowest/greatest common descendant/ascendant). We complete this section with the notion of a witness, which is central to our algorithm."}, {"heading": "3.1. An Equivalence Relation Over F\u2228", "text": "In this section, we present an equivalence relation over F\u2228 and define the representatives of the equivalence classes. This enables us in later sections to focus on the representative elements from F\u2228. Let F be a set of boolean functions over the domain X . The equivalence relation = over F\u2228 is defined as follows: two disjunctions F1, F2 \u2208 F\u2228 are equivalent (F1 = F2) if F1 is logically equal to F2. In other words, they represent the same function (from X to {0, 1}). We write F1 \u2261 F2 to denote that F1 and F2 are identical; that is, they have the same representation. For example, consider f1, f2 : {0, 1} \u2192 {0, 1} where f1(x) = 1 and f2(x) = x. Then, f1 \u2228 f2 = f1 but f1 \u2228 f2 6\u2261 f1.\nWe denote by F\u2217\u2228 the set of equivalence classes of = and write each equivalence class as [F ], where F \u2208 F\u2228. Notice that if [F1] = [F2], then [F1 \u2228 F2] = [F1] = [F2]. Therefore, for every [F ], we can choose the representative element to be GF := \u2228F \u2032\u2208SF \u2032 where S \u2286 F is the maximum size set that satisfies \u2228S = F . We denote by G(F\u2228) the set of all representative elements. Accordingly, G(F\u2228) = {GF | F \u2208 F\u2228}. As an example, consider the set F consisting of four functions f11, f12, f21, f22 : {1, 2}2 \u2192 {0, 1} where fij(x1, x2) = [xi \u2265 j]. There are 24 = 16 elements in Ray22 := F\u2228 and five representative functions in G(F\u2228): G(F\u2228) = {f11\u2228f12\u2228f21\u2228f22, f12\u2228f22, f12, f22, 0} (where 0 is the zero function).\nThe below listed facts follow immediately from the above definitions:\nLemma 1 Let F be a set of boolean functions. Then,\n1. The number of logically non-equivalent boolean functions in F\u2228 is |G(F\u2228)|. 2. For every F \u2208 F\u2228, GF = F . 3. For every G \u2208 G(F\u2228) and f \u2208 F\\S(G), G \u2228 f 6= G. 4. For every F \u2208 F\u2228, \u2228S(F ) \u2261 F . 5. If G1, G2 \u2208 G(F\u2228), then G1 = G2 if and only if G1 \u2261 G2."}, {"heading": "3.2. A Partial Order Over F\u2228", "text": "In this section, we define a partial order over F\u2228 and present related definitions. The partial order, denoted by \u21d2, is defined as follows: F1\u21d2F2 if F1 logically implies F2. Consider the Hasse diagram H(F\u2228) of G(F\u2228) for this partial order. The maximum (top) element in the diagram is Gmax := \u2228f\u2208F f . The minimum (bottom) element is Gmin := \u2228f\u2208\u00d8f , i.e., the zero function. Figure 4 shows an illustration of the Hasse diagram of Ray22 (from Section 3.1). Figures 5 and 6 show other examples of Hasse diagrams: Figure 5 shows the Hasse diagram of boolean variables, while Figure 6 shows an example that extends the example of Ray22.\nIn a Hasse diagram, G1 is a descendant (resp., ascendent) of G2 if there is a (nonempty) downward path from G2 to G1 (resp., from G1 to G2), i.e., G1\u21d2G2 (resp., G2\u21d2G1) and G1 6= G2. G1 is an immediate descendant of G2 in H(F\u2228) if G1\u21d2G2, G1 6= G2 and there is no G such that G 6= G1, G 6= G2 and G1\u21d2G\u21d2G2. G1 is an immediate ascendant of G2 if G2 is an immediate descendant of G1. We now show (all proofs for this section appear in Appendix B):\nLemma 2 Let G1 be an immediate descendant of G2 and F \u2208 F\u2228. If G1\u21d2F\u21d2G2, then G1 = F or G2 = F .\nWe denote by De(G) and As(G) the sets of all the immediate descendants and immediate ascendants of G, respectively. We further denote by DE(G) and AS(G) the sets of all G\u2019s descendants and ascendants, respectively. For G1 and G2, we define their lowest common ascendent (resp., greatest common descendant) G = lca(G1, G2) (resp., G = gcd(G1, G2)) to be the boolean function G \u2208 G(F\u2228) \u2013 that is, the minimum (resp., maximum) element in AS(G1) \u2229 AS(G2) (resp., DE(G1)\u2229DE(G2)). Therefore, we can show Lemma 3. Lemma 3 abbreviates (G1\u21d2G and G2\u21d2G) to G1, G2\u21d2G and (G\u21d2G1 and G\u21d2G2) to G\u21d2G1, G2.\nLemma 3 Let G1, G2 \u2208 G(F\u2228) and F \u2208 F\u2228. 1. If G1, G2\u21d2F\u21d2lca(G1, G2), then F = lca(G1, G2). 2. If gcd(G1, G2)\u21d2F\u21d2G1, G2, then F = gcd(G1, G2).\nLemma 3 leads us to Lemma 4:\nLemma 4 Let G1, G2 \u2208 G(F\u2228). Then, lca(G1, G2) = G1 \u2228G2. In particular, if G1, G2 are two distinct immediate descendants of G, then G1 \u2228G2 = G.\nNote that this does not imply that S(G1 \u2228G2) = S(G1) \u222a S(G2) = S(lca(G1, G2)). In particular, G1 \u2228G2 is not necessarily in G(F\u2228); see, for example, Figure 5 (right).\nLemma 5 follows from the fact that if G1 is a descendant of G2, then G1\u21d2G2, and therefore, G1 \u2228G2 = G2.\nLemma 5 If G1 is a descendant of G2, then S(G1) ( S(G2).\nLemma 5 enables us to show the following.\nLemma 6 Let G1, G2 \u2208 G(F\u2228). Then, S(G1) \u2229 S(G2) = S(gcd(G1, G2)). In particular, if G1, G2 \u2208 G(F\u2228), then \u2228(S(G1) \u2229 S(G2)) \u2208 G(F\u2228). Also, if G1, G2 are two distinct immediate ascendants of G, then S(G1) \u2229 S(G2) = S(G).\nNote that this does not imply that G1 \u2227G2 = gcd(G1, G2); see, for example, Figure 5 (right)."}, {"heading": "3.3. Witnesses", "text": "Finally, we define the term witness. Let G1 and G2 be elements in G(F\u2228). An element a \u2208 X is a witness for G1 and G2 if G1(a) 6= G2(a). We now show two central lemmas.\nLemma 7 Let G1 be an immediate descendant of G2. If a \u2208 X is a witness for G1 and G2, then: 1. G1(a) = 0 and G2(a) = 1. 2. For every f \u2208 S(G1), f(a) = 0. 3. For every f \u2208 S(G2)\\S(G1), f(a) = 1.\nProof Since G1\u21d2G2, it must be that G2(a) = 1 and G1(a) = 0. Namely, for every f \u2208 S(G1), f(a) = 0. Let f \u2208 S(G2)\\S(G1). Consider F = G1 \u2228 f . By bullet 3 in Lemma 1, F 6= G1. Since G1\u21d2F\u21d2G2, by Lemma 2, F = G2. Therefore, f(a) = G1(a) \u2228 f(a) = F (a) = G2(a) = 1.\nLemma 8 Let De(G) = {G1, G2, . . . , Gt} be the set of immediate descendants of G. If a is a witness for G1 and G, then a is not a witness for Gi and G for all i > 1. That is, G1(a) = 0, G(a) = 1, and G2(1) = \u00b7 \u00b7 \u00b7 = Gt(a) = 1.\nProof By Lemma 7, G(a) = 1 and G1(a) = 0. By Lemma 4, for any Gi, i \u2265 2, we have G = G1 \u2228Gi. Therefore, 1 = G(a) = G1(a) \u2228Gi(a) = Gi(a)."}, {"heading": "4. The Algorithm", "text": "In this section, we present our algorithm to learn a target disjunction over F , called SPEX (short for specifications from examples). Our algorithm relies on the following results.\nLemma 9 Let G\u2032 be an immediate descendant of G, a \u2208 X be a witness for G and G\u2032, and G\u2032\u2032 be a descendant of G.\n1. If G\u2032\u2032(a)=0, G\u2032\u2032 is a descendant of G\u2032 or equal to G\u2032. In particular, S(G\u2032\u2032) \u2286 S(G\u2032). 2. If G\u2032\u2032(a)=1, G\u2032\u2032 is neither a descendant of G\u2032 nor equal to G\u2032. In particular, S(G\u2032\u2032) 6\u2282 S(G\u2032).\nProof Since G\u2032\u2032 is a descendant of G, we have S(G\u2032\u2032) ( S(G). By Lemma 7, for every f \u2208 S(G\u2032), we have f(a) = 0, and for every f \u2208 S(G)\\S(G\u2032), we have f(a) = 1. Thus, if G\u2032\u2032(a) = 0, then no f \u2208 S(G)\\S(G\u2032) is in S(G\u2032\u2032) (otherwise, G\u2032\u2032(a) = 1). Therefore, S(G\u2032\u2032) \u2286 S(G\u2032) and G\u2032\u2032 is a descendant of G\u2032 or equal to G\u2032. Otherwise, if G\u2032\u2032(a) = 1 , then since G\u2032(a) = 0, for every descendant G0 of G\u2032 we have G0(a) = 0 and thus G\u2032\u2032 is neither a descendant of G\u2032 nor equal to G\u2032.\nLemma 9 drives the operation of SPEX. To find F (more precisely, GF ), SPEX starts from the maximal element in G(F\u2228) and traverses downwards through the Hasse diagram. At each step,\nSPEX considers an element G, checks its witnesses against its immediate descendants, and poses a membership query for each. If F and G agree on the witness of G and G\u2032, then by Lemma 9, F cannot be G\u2032 or its descendant, and thus these are pruned from the search space. Otherwise, if F and G\u2032 agree on the witness, then F must be G\u2032 or its descendant, and thus all other elements in G(F\u2228) are pruned.\nThe SPEX algorithm is depicted in Figure 1. SPEX calls the recursive algorithm Learn, which takes a candidate G and a set of subsets of F , T , which stores the elements already eliminated from F\u2228. Learn also relies on S, a set of functions over which F (i.e., GF ) is defined (i.e., S(GF ) \u2286 S). During the execution, S may be reduced. If not, then \u2228S = F . Learn begins by initializing S to S(G). Then, it examines the immediate descendants of G whose ancestors have not been eliminated. When considering G\u2032, a witness a is obtained and Learn poses a membership query to learn F (a). If F (a) = 0 (recall that G(a) = 1 since a is a witness), then G 6= F and F is inferred to be a descendant of G\u2032 and is thus over the functions in S(G\u2032). Accordingly, S is reduced. Otherwise, F is not a descendant of G\u2032, and G\u2032 and its descendants are eliminated from the search space by adding S(G\u2032) to T . Finally, if G and F agreed on all the witnesses (evident by the Flag variable), then \u2228S is returned (since G = F ). Otherwise, Learn is invoked on \u2228S and T .\nTheorem 10 If the witnesses and the descendants of any G can be found in time t, then SPEX (Algorithm 1) learns the target function in time t \u00b7 |F| and at most |F| \u00b7 maxG\u2208G(F\u2228) |De(G)| membership queries.\nThe complexity proof follows from the following arguments. First, every invocation of SPEX presents a membership query for every immediate descendant of G, and thus the number of membership queries of a single invocation is at most the maximal number of immediate descendants, maxG\u2208G(F\u2228) |De(G)|. Second, recursive invocations always consider a descendant of the currently inspected candidate. Thus, the recursion depth is bounded by the height of the Hasse diagram, |F|.\nThis implies the total bound of |F| \u00b7maxG\u2208G(F\u2228) |De(G)|membership queries. The fact that SPEX learns the target function follows from Lemma 11.\nLemma 11 Let F be the target function. If Learn returns \u2228S, then GF = \u2228S (?). Otherwise, if Learn(Gmax,\u00d8) calls Learn(\u2228S, T ), then:\n1. S(GF ) \u2286 S. That is, GF is a descendant of \u2228S or equal to \u2228S. 2. S(GF ) 6\u2282 R for all R \u2208 T . That is, GF is not a descendant of any \u2228R, for R \u2208 T or equal\nto \u2228R.\nProof The proof is by induction. Obviously, the induction hypothesis is true for (Gmax,\u00d8). Assume the induction hypothesis is true for (\u2228S, T ). That is, S(GF ) \u2286 S and S(GF ) 6\u2282 R for all R \u2208 T . Let G\u20321, . . . , G \u2032 ` be all the immediate descendants of \u2228S. If S(G\u2032i) \u2286 R for some R \u2208 T , G\u2032i and all its descendants G\u2032\u2032 satisfy S(G\u2032\u2032) \u2286 S(G\u2032i) \u2286 R and thus GF is not G\u2032i or a descendant of G\u2032i. Assume now that S(G\u2032i) 6\u2282 R for all R \u2208 T . Let a(i) be a witness for \u2228S and G\u2032i. If F (a(i)) = 1, then by Lemma 9 GF is not a descendant of G\u2032i and not equal to G \u2032 i. This implies that S(GF ) 6\u2282 S(G\u2032i), which is why S(G \u2032 i) is added to T (Line 6 in the Algorithm). This proves bullet 2.\nIf F (a(i)) = 1 for all i, then GF = \u2228S. This follows since by Lemma 9, F is not any of \u2228S descendants; thus by the induction hypothesis, it must be \u2228S. This is the case when the Flag variable does not change to 0 and the algorithm outputs \u2228S. This proves (?).\nIf F (a(i)) = 0, then by Lemma 9, GF is a descendant of G\u2032i or equal to G \u2032 i. Let I be the set of all indices i for which F (a(i)) = 0. Then, GF is a descendant of (or equal to) all G\u2032i, i \u2208 I , and therefore, GF is a descendant of or equal to gcd({G\u2032i}i\u2208I). By Lemma 6, S(gcd({G\u2032i}i\u2208I)) = \u2229i\u2208IS(Gi). Thus, the algorithm in Line 5 takes the new S to be \u2229i\u2208IS(Gi). This proves bullet 1."}, {"heading": "4.1. Lower Bound", "text": "The number of different boolean functions in F\u2228 is |G(F\u2228)|, and therefore, from the information theoretic lower bound we get: OPT(F\u2228) \u2265 dlog |G(F\u2228)|e. We now prove the lower bound.\nTheorem 12 Any learning algorithm that learns F\u2228 must ask at least max(log |G(F\u2228)|,maxG\u2208G(F\u2228) |De(G)|) membership queries. In particular, SPEX (Algorithm 1) asks at most |F| \u00b7OPT(F\u2228) membership queries.\nProof Let G\u2032 be such that m = |De(G\u2032)| = maxG\u2208G(F\u2228) |De(G)|. Let G1, . . . , Gm be the immediate descendants of G\u2032. If the target function is either G\u2032 or one of its immediate descendants, then any learning algorithm must ask a membership query a(i) such that G\u2032(a(i)) = 1 and Gi(a(i)) = 0. Without such an assignment, the algorithm cannot distinguish between G\u2032 and Gi. By Lemma 8, a(i) is a witness only to Gi, and therefore, we need at least m membership queries."}, {"heading": "4.2. Finding All Immediate Descendants of G", "text": "A missing detail in our algorithm is how to find the immediate descendants of G in the Hasse diagram H(S(G)). In this section, we explain how to obtain them. We first characterize the elements in H(S(G)) (compared to the other elements in F\u2228), which is necessary because the immediate\ndescendants are part of H(S(G)). We then give a characterization of the immediate descendants (compared to other descendants), which leads to an operation that computes an immediate descendant from a descendant. We finally show how to compute descendants that lead to obtaining different immediate descendants. This completes the description of how SPEX can obtain all immediate descendants.\nBy the definition of a representative, for every F \u2208 F\u2228, GF = \u2228f\u21d2F f. To decide whether F \u2208 F\u2228 is a representative, i.e., whether F \u2208 G(F\u2228), we use Lemma 13 (whose proof directly follows from the definition of G(F\u2228)).\nLemma 13 Let F \u2208 F\u2228. F \u2208 G(F\u2228) if and only if for every f \u2208 F\\S(F ) we have F \u2228 f 6= F .\nLemma 14 shows how to decide whether G\u2032 is an immediate descendant of G.\nLemma 14 Let G,G\u2032 \u2208 G(F\u2228). G\u2032 is an immediate descendant of G if and only if G\u2032 6= G, S(G\u2032) \u2282 S(G) and for every f \u2208 S(G)\\S(G\u2032) we have G\u2032 \u2228 f = G.\nIf G\u2032 6= G, S(G\u2032) \u2282 S(G) and for some f \u2208 S(G)\\S(G\u2032) we have G\u2032 \u2228 f 6= G, then GG\u2032\u2228f is a descendant of G and an ascendant of G\u2032.\nProof Only if: Let G\u2032 be an immediate descendant of G, i.e., G\u2032 6= G, G\u2032\u21d2G and S(G\u2032) \u2282 S(G). Let f \u2208 S(G)\\S(G\u2032). Since G\u2032\u21d2(G\u2032 \u2228 f)\u21d2G and G\u2032 6= G\u2032 \u2228 f , we get G\u2032 \u2228 f = G.\nIf: Suppose G\u2032 6= G, G\u2032\u21d2G and for every f \u2208 S(G)\\S(G\u2032), we have G\u2032 \u2228 f = G. If G\u2032 is not an immediate descendant of G, then let G\u2032\u2032 be a descendant of G and an immediate ascendant of G\u2032\u2032. Take any f \u2208 S(G\u2032\u2032)\\S(G\u2032) \u2282 S(G)\\S(G\u2032). Then, G\u2032 \u2228 f = G\u2032\u2032 6= G \u2013 a contradiction. This also proves the last statement of Lemma 14.\nLemma 14 shows how to compute an immediate descendant from a descendant, which we phrase in an operation called GetImmDe (Figure 2, left). GetImmDe takes G and a descendant G\u2032\u2032 of G (which can even be the zero function), initializes S = S(G\u2032\u2032), and as long as possible, repeatedly extends S as follows: for f \u2208 S(G)\\S if (\u2228S) \u2228 f 6= G, f is added to S.\nGetImmDe can be used to obtain the first immediate descendant by calling it with G\u2032\u2032 = 0. We next show how to obtain a descendant for which GetImmDe will return a different immediate descendant. To this end, we define the following: For G \u2208 G(F\u2228) and a set X \u2032 \u2286 X , Z(G,X \u2032) = {f \u2208 S(G) | f(X \u2032) = 0}, where f(X \u2032) = \u2228x\u2208X\u2032f(x). When X \u2032 = {x}, we abbreviate to Z(G, x). Obviously,\nZ(G,X \u2032) = \u22c2\nx\u2208X\u2032 Z(G, x). (1)\nLemma 15 relates this new definition to the descendants of G.\nLemma 15 Let G \u2208 G(F\u2228) and X \u2032 \u2286 G\u22121(1) be a nonempty set. Then, G\u2032 = \u2228Z(G,X \u2032) \u2208 G(F\u2228) and G\u2032 is a descendant of G.\nFor every immediate descendant G\u2032 of G, there is X \u2032 \u2286 G\u22121(1) such that \u2228Z(G,X \u2032) = G\u2032.\nProof First notice that G\u2032(X \u2032) = 0. Suppose on the contrary that G\u2032 6\u2208 G(F\u2228). Then, there is f \u2208 S(G)\\Z(G,X \u2032) such that G\u2032 \u2228 f = G\u2032. Since f 6\u2208 Z(G,X \u2032), there is z \u2208 X \u2032 such that f(z) = 1 and then G\u2032(X \u2032) = (G\u2032 \u2228 f)(X \u2032) 6= 0 \u2013 a contradiction. Therefore, G\u2032 \u2208 G(F\u2228). By the definition of Z, S(G\u2032) \u2286 S(G) and thus G\u2032 is a descendant of G.\nLet G\u2032 be an immediate descendant of G and let X \u2032 = {x \u2208 X | G\u2032(x) = 0 and G(x) = 1}. Then, X \u2032 \u2286 G\u22121(1). We now show Z(G,X \u2032) = S(G\u2032). S(G\u2032) \u2286 Z(G,X \u2032) because if f \u2208 S(G\u2032), then for all x \u2208 X \u2032, f(x) = 0 and thus f \u2208 Z(G,X \u2032). We next prove that Z(G,X \u2032) \u2286 S(G\u2032). Let f \u2208 Z(G,X \u2032) and x0 be a witness for G and G\u2032, i.e., G(x0) = 1 and G\u2032(x0) = 0. Therefore, x0 \u2208 X \u2032 and f(x0) = 0 by the definition of Z. By Lemma 7, for every f \u2208 S(G)\\S(G\u2032), we have f(a) = 1. Since f \u2208 S(G), it must be that f \u2208 S(G\u2032).\nLemma 15 shows how to construct descendants from elements in X . Lemma 16 determines when all immediate descendants of G were obtained, and if not, how to obtain a new element in X that leads to a new immediate descendant. The algorithm that finds all immediate descendants (Figure 2, right) follows directly from this lemma. In the following we denote \u2227 S = \u2227 f\u2208S f .\nLemma 16 Let G1, . . . , Gm be immediate descendants of G. There is no other immediate descendant for G if and only if\nG = m\u2228 i=1 \u2227 (S(G)\\S(Gi)). (2)\nIf (2) does not hold, then for any counterexample a for (2), we have \u2228Z(G, a) is a descendant of G but not equal to and not a descendant of any Gi, i = 1, . . . ,m.\nProof Only if: Suppose G 6= \u2228mi=1 \u2227 (S(G)\\S(Gi)) and let a be a counterexample. Since for all i, S(G)\\S(Gi) \u2286 S(G), we have \u2228mi=1 \u2227 (S(G)\\S(Gi))\u21d2G. Therefore, G(a) = 1 and for every i there is fi \u2208 S(G)\\S(Gi) such that fi(a) = 0. Consider G\u2032 = Z(G, a). Since fi(a) = 0, we have fi \u2208 S(G\u2032). Since fi 6\u2208 S(Gi), G\u2032 is not a descendant of Gi. Since G\u2032 is a descendant of G and not a descendant of any Gi, there must be another immediate descendant of G.\nIf: Denote W = \u2228m\ni=1\n\u2227 (S(G)\\S(Gi)). Let G\u2032 be another immediate descendant of G. Let\na be a witness for G and G\u2032. Then G(a) = 1 and, by Lemma 7, for every f \u2208 S(G)\\S(G\u2032), we have f(a) = 1 and for every f \u2208 S(G\u2032), we have f(a) = 0. Since S(G\u2032) 6\u2282 S(Gi), we have S(G)\\S(Gi) 6\u2282 S(G)\\S(G\u2032), and therefore, (S(G)\\S(Gi)) \u2229 S(G\u2032) is not empty. Choose fi \u2208 (S(G)\\S(Gi))\u2229S(G\u2032). Then, fi \u2208 S(G)\\S(Gi) and since fi \u2208 S(G\u2032), fi(a) = 0. Therefore, W (a) = 0. Since G(a) = 1, we get G 6= W ."}, {"heading": "4.3. Critical Points", "text": "In this section, we show that if one can find certain points (the critical points), then the immediate descendants can be computed in polynomial time (in the number of these points) and thus SPEX runs\nin polynomial time. In particular, if the number of points is polynomial and they can be obtained in polynomial time, then SPEX runs in polynomial time. A set of points C \u2286 X is called a critical point set for F if for every S \u2286 F and if H =\u2227 f\u2208S f \u2227 \u2227 f\u2208F\\S f\u0304 6= 0, then there is a point in c \u2208 C such that H(c) = 1.\nWe now show how to use the critical points to find the immediate descendants.\nLemma 17 Let C \u2286 X be a set of points. If C is a set of critical points for F , then all the immediate descendants of G \u2208 G(F\u2228) can be found in time |C| \u00b7 |S(G)|.\nProof Let G1, . . . , Gm be some of the immediate descendants of G. To find another immediate descendant we look for a point a such that G(a) = 1, and for every i, there is fi \u2208 S(G)\\S(Gi) such that fi(a) = 0. Let a be such point. Consider S = {f \u2208 F | f(a) = 1} and let H = \u2227 f\u2208S f \u2227 \u2227 f\u2208F\\S f\u0304 . Since H(a) 6= 0, there is a critical point b \u2208 C such that H(b) = 1. By the definition of b, G(b) = 1 and for every i there is fi \u2208 S(G)\\S(Gi) such that fi(b) = 0. Therefore, b can be used to find a new descendant of G. To find the descendants we need, in the worst case, to substitute all the assignments of C in all the descendants G1, . . . , Gm and G. For all the descendants, this takes at most |C| \u00b7 |S(G)| steps, which implies the time complexity.\nWe now show how to generate the set of critical points. Lemma 18 If for every S,R \u2286 F one can decide whether HS,R = \u2227 f\u2208S f \u2227 \u2227\nf\u2208R f\u0304 6= 0 in time T and if so, find a \u2208 X such that HR,S(a) = 1, then a set of critical points C can be found in time |C| \u00b7 T \u00b7 |F|.\nProof The set is constructed inductively, in stages. Let F = {f1, . . . , ft} and denote Fi = {f1, . . . , fi}. Suppose we have a set Ki = {S \u2286 [i] | \u2227 f\u2208S f \u2227 \u2227 f\u2208[i]\\S f\u0304 6= 0}; then we define Ki+1 = {g \u2227 fi+1 | g \u2208 Ki and g \u2227 fi+1 6= 0} \u222a{g \u2227 fi+1 | g \u2208 Ki and g \u2227 fi+1 6= 0}."}, {"heading": "5. A Polynomial Time Algorithm for Halfspaces in a Constant Dimension", "text": "In this section, we show two results. The first is that when F is a set of halfspaces over a constant dimension, one can find a polynomial-sized critical point set in polynomial time, and therefore, SPEX can run in polynomial time. We then show that unless P = NP , this result cannot be extended to non-constant dimensions.\nA halfspace of dimension d is a boolean function of the form:\nf(x1, . . . , xd) = [a1x1 + \u00b7 \u00b7 \u00b7+ adxd \u2265 b] = {\n1 if a1x1 + \u00b7 \u00b7 \u00b7+ adxd \u2265 b 0 otherwise\nwhere (x1, . . . , xd) \u2208 <d and a1, . . . , ad, b are real numbers. Therefore, f : <d \u2192 {0, 1}. We now prove that the set of critical points is of a polynomial size.\nLemma 19 Let F be a set of halfspaces in dimension d. There is a set of critical points C for F of size |F|d+1.\nProof Define the dual set of halfspaces. That is, for every x \u2208 <d, the dual function x\u22a5 : F \u2192 {0, 1} where x\u22a5(f) = f(x). It is well known that the VC-dimension of this set is at most d + 1. By the Sauer-Shelah lemma, the result follows.\nNext, we prove that the set of critical points can be computed in polynomial time.\nLemma 20 Let F be a set of halfspaces in dimension d. A set of critical points C for F of size |F|d+1 can be found in time poly(|F|d).\nProof Follows from Lemma 18 and the fact that linear programming (required to check whether g \u2227 fi 6= 0) takes polynomial time.\nBy the above results, we conclude:\nTheorem 21 Let F be a set of halfspaces in dimension d. There is a learning algorithm for F\u2228 that runs in time |F|O(d) and asks at most |F| \u00b7OPT(F\u2228) membership queries.\nIn particular, when the dimension d is constant, the algorithm runs in polynomial time.\nNext, we show that the above cannot be extended to a non-constant dimension:\nTheorem 22 If every set F of halfspaces deciding whether F \u2208 F\u2228 is a descendant of \u2228F can be done in polynomial time, then P = NP .\nProof The reduction is from the problem of dual 3SAT \u2013 that is, given the literals {x1, . . . , xn, x\u03041, . . . , x\u0304n} and the terms T1, . . . , Tm where each Ti is a conjunction of three literals, decide whether T1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Tm = 1.\nGiven the terms T1, . . . , Tm, each can be translated into a halfspace. For example, the term x1 \u2227 x\u03042 \u2227 x3 corresponds to the halfspace [x1 + (1\u2212 x2) + x3 \u2265 3] = [x1 \u2212 x2 + x3 \u2265 2]. Now, consider F = {T1, . . . , Tm, 1}. Then Gmax = 1 and T1 \u2228 . . .\u2228Tm 6= 1 if and only if T1 \u2228 \u00b7 \u00b7 \u00b7 \u2228Tm is the only immediate descendant of Gmax."}, {"heading": "6. Duality and a Polynomial Time Algorithm for Variable Inequality Predicates", "text": "In this section, we study the learnability of conjunctions over variable inequality predicates. In the acyclic case, we provide a polynomial time learning algorithm. In the general case, we show that the learning problem is equivalent to the open problem of enumerating all the maximal acyclic subgraphs of a given directed graph.\nConsider the set of boolean functions FI := {[xi > xj ] |(i, j) \u2208 I} for some I \u2286 [n]2 where [n] = {1, 2, . . . , n} and the variables xi are interpreted as real numbers. We define [xi > xj ] = 1 if xi > xj ; and 0 otherwise. We assume throughout this section that (i, i) 6\u2208 I for all i.\nWe consider the dual class F\u2227 := {\u2227f\u2208Sf | S \u2286 F}. By duality (De Morgan\u2019s law), all our results are true for learning F\u2227 (after swapping \u2228 with \u2227). The dual SPEX algorithm is depicted in Figure 3.\nFor a set J \u2286 I , we define FJ = \u2227(i,j)\u2208J [xi > xj ]. For F \u2208 FI\u2227 we define I(F ) = {(i, j) | [xi > xj ] is in F}. Note that I(FJ) = J . For example, I([x1 > x2]\u2227 [x3 > x1]) = {(1, 2), (3, 1)}.\nThe directed graph of I \u2286 [n]2 is GI = ([n], I). The reachability matrix of I , denoted by R(I), is an n \u00d7 n matrix where R(I)i,j = 1 if there is a (directed) path from i to j in GI ; otherwise, R(I)i,j = 0. We say that I is acyclic (resp., cyclic) if the graph GI is acyclic (resp., cyclic). We say that an assignment to the variables a \u2208 [n]n is a topological sorting of I if for every (i, j) \u2208 I , we have ai > aj . It is known that I has a topological sorting if and only if I is acyclic. Also, it is known that a topological sorting for an acyclic set can be found in linear time (see Knuth (1997), Volume 1, Section 2.2.3 and Cormen et al. (2001)). Next, we study the learnability of FI\u2227 when I is acyclic and following this, we discuss the general case."}, {"heading": "6.1. Acyclic Sets", "text": "We now examine the case when I is acyclic. Here, the number of critical points of FI where I = {(1, 2), (2, 3), \u00b7 \u00b7 \u00b7 , (n \u2212 1, n)} is 2n\u22121. Therefore, using Lemma 17 does not enable us to obtain a polynomial time algorithm. Accordingly, we show a different way to determine whether a function is a representative (i.e., in G(F\u2227)), and then show how to obtain the immediate descendants in quadratic time (in n) and the witnesses in linear time. As a result, SPEX can run in polynomial time. Finally, we show that the number of membership queries is at most |I|.\nBefore we show the main lemma, Lemma 24, we present Lemma 23, a trivial lemma that we use to prove Lemma 24.\nLemma 23 Let I \u2286 [n]2 be an acyclic set, F \u2208 FI\u2227, and a \u2208 [n]n. Then, F (a) = 1 if and only if a is a topological sorting of GI(F ).\nIn particular, F is satisfiable and a satisfying assignment a \u2208 [n]n can be found in linear time.\nNext we show our main lemma that enables us to determine the representative elements and the immediate descendants (in Lemmas 25\u201327). The proof is provided in Appendix C.\nLemma 24 Let I be acyclic and F1, F2 \u2208 FI\u2227. Then, F1 = F2 if and only if R(I(F2))=R(I(F1)).\nWe now show how to decide whether F \u2208 G(FI\u2227) \u2013 that is, whether F is a representative.\nLemma 25 Let I be an acyclic set and F \u2208 FI\u2227. F \u2208 G(FI\u2227) if and only if for every (i, j) \u2208 I\\I(F ) there is no path from i to j in GI(F ).\nProof If: If for every (i, j) \u2208 I\\I(F ) there is no path from i to j in GI(F ), then for every (i, j) \u2208 I\\I(F ), R(I(F )\u222a {(i, j)}) 6= R(I(F )) . By Lemma 24, this implies that F \u2227 [xi > xj ] 6= F . By (the dual result of) Lemma 13, the result follows.\nOnly if: Now let F \u2208 G(FI\u2227). By Lemma 13, for every [xi > xj ] 6\u2208 F , we have F \u2227 [xi > xj ] 6= F . Therefore, there is an assignment a that satisfies ai \u2264 aj and F (a) = 1. As before, if there is a path in GI(F ) from i to j, then we get a contradiction.\nWe now show how to determine the immediate descendants of G in polynomial time.\nLemma 26 Let I be acyclic. The immediate descendants of G \u2208 G(FI\u2227) are all Gr,s := FI(G)\\{(r,s)} where (r, s) \u2208 I(G) and there is no path from r to s in GI(G)\\{(r,s)}.\nIn particular, for all G \u2208 G(FI\u2227), we have |De(G)| \u2264 |I(G)| \u2264 |I|.\nThe proof is in Appendix C. We now show how to find a witness.\nLemma 27 Let I be acyclic, G \u2208 G(FI\u2227), and Gr,s := FI(G)\\{(r,s)} be an immediate descendant of G. A witness for G and Gr,s can be found in linear time.\nProof By Lemma 26, (r, s) \u2208 I(G) and there is no path from r to s in GI(G)\\{(r,s)}. Therefore, if we match vertices r and s in GI(G)\\{(r,s)} we get an acyclic graph G\u2032. Then, a topological sorting a for G\u2032 is a satisfying assignment for Gr,s that satisfies ar = as. Since [xr > xs] \u2208 S(G), we get G(a) = 0. Therefore, a is a witness for G and Gr,s.\nTo learn a function in FI\u2227, SPEX needs to find the immediate descendants of G and a witness for each immediate descendant and G. By Lemma 26, this involves finding a path between every two nodes in the directed graph GI(G), which can be done in polynomial time. By Lemma 27, to find a witness, SPEX needs a topological sorting, which can be done in linear time. Therefore, SPEX runs in polynomial time. Therefore, by Theorem 10 and Lemma 26, the class FI\u2227 is learnable in polynomial time with at most |I|2 membership queries. We now show that the number of membership queries is actually lower and equal to |I|.\nTheorem 28 Let I \u2286 [n]2 be acyclic. The class FI\u2227 is learnable in polynomial time with at most |I| membership queries.\nProof Consider the (dual) Algorithm SPEX in Figure 3 in Appendix A. Let F be the target function. Let Gmax = f1 \u2227 f2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 ft where fi \u2208 FI . By Lemma 26, we may assume w.l.o.g. that G(i) = f1 \u2227 f2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 fi\u22121 \u2227 fi+1 \u2227 \u00b7 \u00b7 \u00b7 ft where i = 1, . . . , ` are all the immediate descendants of G. Let a(i) be the witness for G and G(i), i = 1, . . . , `.\nIn the algorithm, S = {fi | i = 1, . . . , t}. If F (a(i)) = 1, then Line 5 in the algorithm removes fi from S and fi never returns to S. If F (a(i)) = 0, then the set {f1, f2, . . . , fi\u22121, fi+1, \u00b7 \u00b7 \u00b7 ft} is added to T , which means (see Line 3) that SPEX never considers a descendant that does not contain fi. Namely, for every fi, SPEX makes at most one membership query.\nWe conclude this section by illustrating SPEX on an example, depicted in Figure 7. Assume the set of boolean functions is FI , where I = {(1, 2), (1, 4), (1, 3), (3, 4), (2, 4), (3, 2)}, and the target is Gmin = 1. The graph in Figure 7 shows the Hasse diagram (in white and gray nodes) and the candidates that SPEX considers (in gray). The figure demonstrates that the number of membership queries is equal to |I|."}, {"heading": "6.2. Cyclic Sets", "text": "In this section, we consider the general case, where I \u2286 [n]2 can be any set. Lemma 29 shows a few results when I is cyclic.\nLemma 29 Let I \u2286 [n]2 be any set with cycles. Then: 1. Gmax = 0 is in FI\u2227. 2. The immediate descendants of Gmax are all \u2227(i,j)\u2208J [xi > xj ] where GJ is a maximal acyclic\nsubgraph of GI . In particular,\n3. Finding all the immediate descendants of Gmax is equivalent to enumerating all the maximal acyclic subgraphs of GI .\nProof If i1 \u2192 i2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 ic \u2192 i1 is a cycle, then Gmax\u21d2[xi1 > xi1 ] = 0 and thus Gmax = 0. If GJ is a maximal acyclic subgraph of GI , then adding any edge in I\\J to GJ creates a cycle. This implies that for any [xi > xj ] \u2208 S(FI)\\S(FJ), we have FJ \u2227 [xi > xj ] = 0 = Gmax. By Lemma 14, FJ is an immediate descendant of Gmax.\nNow, if FJ is an immediate descendant of Gmax, then J is acyclic because otherwise FJ = 0 = Gmax. If GJ is not a maximal acyclic subgraph of GI , then there is an edge (i, j) such that J \u222a{(i, j)} is acyclic and then either FJ\u222a{(i,j)} = FJ \u2013 in which case FJ is not a representative and thus not an immediate descendant \u2013 or FJ\u222a{(i,j)} 6= FJ \u2013 in which case Gmax\u21d2FJ\u222a{(i,j)}\u21d2FJ and Gmax 6= FJ\u222a{(i,j)} 6= FJ , and therefore, FJ is not an immediate descendant of Gmax.\nLet G be any directed graph and denote by N(G) the number of the maximal acyclic subgraphs of G. Lemma 30 follows immediately from Theorem 12 and Lemma 29.\nLemma 30 OPT(FI\u2227) \u2265 N(GI).\nThe problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016). We show that learning a function in FI\u2227 (where I \u2286 [n]2) in polynomial time is possible if and only if the enumeration problem can be done in polynomial time (the proof is in Appendix C).\nTheorem 31 There is a polynomial time learning algorithm (poly(OPT(FI\u2227), n, |I|)), which for an input I \u2286 [n]2, learns F \u2208 FI\u2227 if and only if there is an algorithm that for an input G, which is a directed graph, enumerates all the maximal acyclic subgraphs of G(V,E) in polynomial time (poly(N(G), |V |, |E|))."}, {"heading": "7. Application to Program Synthesis", "text": "In this section, we explain the natural integration of SPEX into program synthesis. We then demonstrate this on a synthesizer that synthesizes programs that detect patterns in time-series charts. These programs meet specifications that belong to the class of variable inequalities I (for acyclic I).\nProgram synthesizers are defined over an input domain Xin, an output domain Xout, and a domain-specific language D. Given a specification, the goal of a synthesizer is to generate a corresponding program. A specification is a set of formulas \u03d5(xin, xout) where xin is interpreted over Xin and xout is interpreted over Xout. Given a specification Y , a synthesizer returns a program P : Xin \u2192 Xout over D such that for all in \u2208 Xin: (in, P (in)) |= Y (i.e., all formulas are satisfied for xin = in and xout = out). Roughly speaking, there are two types of synthesizers: \u2022 Synthesizers that assume that Y describes a full specification. Namely, for all in \u2208 Xin, there\nexists a single out \u2208 Xout such that (in, out) |= Y (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE syn-\nthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al. (2015)). The typical setting of a PBE synthesizer is that an end user (that acts as the teacher) knows a target program f and he or she provides the synthesizer with some initial examples and can interact with the synthesizer through membership queries (we note that most synthesizers do not interact).\nEach approach has its advantages and disadvantages. The first approach guarantees correctness on all inputs, but requires a full specification, which is complex to provide, especially by end users unfamiliar with formulas. On the other hand, PBE synthesizers are user-friendly as they interact through examples; however, generally they do not guarantee correctness on all inputs.\nWe next define the class of programs that are F-describable. For such programs, SPEX can be leveraged by both approaches to eliminate their disadvantage. Let F be a set of predicates over Xin \u222a Xout. A synthesizer is F-describable if every program that can be synthesized meets a specification F \u2208 F\u2228 (or dually, F\u2227). A synthesizer that assumes that Y is a full specification and is F-describable can release the user from having to provide the full specification by first running SPEX and then synthesizing a program from the formula returned by SPEX. A PBE synthesizer that is F-describable can be extended to guarantee correctness on all inputs by first running SPEX and then synthesizing the program from the set of membership queries posed by SPEX. Theorem 32 follows immediately from Theorem 10.\nTheorem 32 LetF be a set of predicates andA be anF-describable synthesizer. Then,A extended with SPEX returns the target program with at most |F| \u00b7maxG\u2208G(F\u2228) |De(G)| membership queries."}, {"heading": "7.1. Example: Synthesis of Time-series Patterns", "text": "In this section, we consider the setting of synthesizing programs that detect time-series patterns. The specifications of these programs are over FI\u2227 for some I \u2286 [n]2 and thus the synthesizer learns the target program within |I| membership queries. Time-series are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (MoralesEsteban et al., 2010). Experts use these charts to predict important events (e.g., trend changes in stock prices) by looking for patterns in the charts. There are a variety of platforms that enable users to write programs to detect a pattern in a time-series chart. In this work, we consider a domainspecific language (DSL) of a popular trading platform, AmiBroker. Our synthesizer can easily be extended to other DSLs.\nA time-series chart c : N \u2192 R maps points in time to real values (e.g., stock prices). A timeseries pattern is a conjunction FI for acyclic I . The size of FI is the maximal natural number it contains, i.e., the size of FI is argmaxi{i | \u2203j.(i, j) \u2208 I or (j, i) \u2208 I}. A program detects a pattern FI of size k in a time-series chart c if it alerts upon every t \u2208 N for which the t1, ..., tk\u22121 preceding extreme points satisfy FI(c(t1), ..., c(tk\u22121), c(t)) = 1.\nIn this setting, Xin is a set of charts over a fixed k \u2208 N, that is f : {1, ..., k} \u2192 R, and Xout = {0, 1}. The DSL D is the DSL of the trading platform AmiBroker. We built a synthesizer that not only interacts with the end user through membership queries, but also displays them as charts (of size k). Thereby, our synthesizer communicates with the end user in his language of expertise. The synthesizer takes as input an initial chart example c\u2032 : {1, ..., k} \u2192 R and initializes I to {(i, j) \u2208 [k]2 | c\u2032(i) \u2265 c\u2032(j)} and sets FI := {[xi \u2265 xj ] |(i, j) \u2208 I} (our results are true also for these kinds of predicates). It then executes SPEX to learn F . During the execution, every witness is translated into a chart (the translation is immediate since each witness is an assignment to k points). Finally, our synthesizer synthesizes a program by synthesizing instructions that detect the k extreme points in the chart, followed by an instruction that checks whether these points satisfy the formula F and alerts the end user if so (the technical details are beyond the scope of this paper). Namely, for the end user, our synthesizer acts as a PBE synthesizer, but internally it takes the first synthesis approach and assumes it is given a full specification (which is obtained by running SPEX).\nThe complexity of the overall synthesis algorithm is determined by SPEX (as the synthesis merely synthesizes the instructions according to the specification F ), and thus from Theorem 28, we infer the following theorem.\nTheorem 33 The pattern synthesizer returns a program that detects the target pattern in polynomial time with at most k2 membership queries, where k is the target pattern size."}, {"heading": "8. Related Work", "text": "Program Synthesis Program synthesis has drawn a lot of attention over the last decade, especially in the setting of synthesis from examples, known as PBE (e.g., Gulwani (2010); Lau et al. (2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al. (2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)).\nQueries over Streams Several works aim to help analysts. Many trading software platforms provide domain-specific languages for writing queries where the user defines the query and the system is responsible for the sliding window mechanism, e.g., MetaTrader, MetaStock, NinjaTrader, and Microsoft\u2019s StreamInsight (Chandramouli et al., 2010). Another tool designed to help analysts is Stat! (Barnett et al., 2013), an interactive tool enabling analysts to write queries in StreamInsight. TimeFork (Badam et al., 2016) is an interactive tool that helps analysts with predictions based on automatic analysis of the past stock price. CPL (Anand et al., 2001) is a Haskell-based high-level language designed for chart pattern queries. Many other languages support queries for streams. SASE (Wu et al., 2006) is a system designed for RFID (radio frequency identification) streams that offers a user-friendly language and can handle large volumes of data. Cayuga (Brenna et al., 2007) is a system for detecting complex patterns in streams, whose language is based on Cayuga algebra. SPL (Hirzel et al., 2013) is IBM\u2019s stream processing language supporting pattern detections. ActiveSheets (Vaziri et al., 2014) is a platform that enables Microsoft Excel to process real-time streams from within spreadsheets."}, {"heading": "9. Conclusion", "text": "In this paper, we have studied the learnability of disjunctions F\u2228 (and conjunctions) over a set of boolean functions F . We have shown an algorithm SPEX that asks at most |F| \u00b7 OPT (F\u2228) membership queries. We further showed two classes that SPEX can learn in polynomial time. We then showed a practical application of SPEX that augments PBE synthesizers, giving them the ability to guarantee to output the target program as the end user intended. Lastly, we showed a\nsynthesizer that learns time-series patterns in polynomial time and outputs an executable program, while interacting with the end user through visual charts.\nAcknowledgements The research leading to these results has received funding from the European Union\u2019s - Seventh Framework Programme (FP7) under grant agreement no 615688\u2013ERC-COGPRIME."}, {"heading": "Appendix A. The Dual SPEX Algorithm", "text": "Figure 3 shows the dual SPEX algorithm for learning functions in F\u2227."}, {"heading": "Appendix B. Proofs for Section 3.2", "text": "Proof of Lemma 2 Consider GF . Since F = GF , G1\u21d2GF\u21d2G2. By the definition of immediate descendants, we get the result. Proof of Lemma 3 Bullet 1: Consider GF . Then GF = F and GF \u2208 G(F\u2228). Since G1, G2\u21d2GF\u21d2 lca(G1, G2), by the definition of LCA we must have GF = lca(G1, G2). The proof of 2 is similar. Proof of Lemma 4 Since G1, G2\u21d2lca(G1, G2), we get G1 \u2228 G2\u21d2lca(G1, G2). Since G1, G2\u21d2(G1 \u2228G2)\u21d2lca(G1, G2), by Lemma 3, we get G1 \u2228G2 = lca(G1, G2). Proof of Lemma 6 Let G = gcd(G1, G2). We show that S(G) \u2286 S(G1) \u2229 S(G2) and S(G1)\u2229S(G2) \u2286 S(G). By Lemma 5, S(G) \u2286 S(G1) and S(G) \u2286 S(G2), and therefore, S(G) \u2286 S(G1)\u2229S(G2). Since S(G) \u2286 S(G1)\u2229S(G2), we also have G = \u2228S(G)\u21d2\u2228(S(G1)\u2229S(G2))\u21d2 G1, G2. Therefore, by Lemma 3, we get G = \u2228(S(G1) \u2229 S(G2)). Thus, S(G1) \u2229 S(G2) \u2286 S(G)."}, {"heading": "Appendix C. Additional Proofs for Section 6", "text": "Proof of Lemma 24 Only if: Assume F1 = F2. Suppose, on the contrary, that there are i, j such that w.l.o.g. R(I(F1))i,j = 0 and R(I(F2))i,j = 1. Since I is acyclic and R(I(F2))i,j = 1, there is no path from j to i in GI (and therefore, in GI(F1)). Since R(I(F1))i,j = 0, there is also no path from i to j in GI(F1). Therefore, we can match the vertices i and j in GI(F1) (unify them into a single vertex) and get an acyclic graph G\u2032. Using the topological sorting of G\u2032, we get a satisfying assignment a for F1 that satisfies ai = aj . We now show that F2(a) = 0 and thus get a contradiction. Since R(I(F2))i,j = 1, there is a path i = i1 \u2192 i2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 i` = j from i to j in GI(F2). Therefore, F2 contains F \u2032 := [xi1 > xi2 ] \u2227 [xi2 > xi3 ] \u2227 \u00b7 \u00b7 \u00b7 \u2227 [xi`\u22121 > xi` ]. Since F2\u21d2F \u2032\u21d2[xi1 > xi` ] = [xi > xj ] and our assignment satisfies [ai > aj ] = 0, we get F2(a) = 0.\nIf: Assume R(I(F2)) = R(I(F1)). Suppose, on the contrary, that F2 6= F1. Then, there is an assignment a such that F2(a) = 1 and F1(a) = 0 (or vice versa). Since F1(a) = 0, a is not a topological sorting of GI(F1). Therefore, there is an edge i \u2192 j in GI(F1) such that ai \u2264 aj . Since R(I(F2))i,j=R(I(F1))i,j=1, there is a path from i to j in GI(F2). As before, we get a contradiction. Proof of Lemma 26 Since (r, s) \u2208 I(G), we have R(I(G))r,s=1. On the other hand, since there is no path from r to s in GI(G)\\{(r,s)}, we have R(I(Gr,s))r,s = 0. Therefore, R(I(G)) 6= R(I(Gr,s)) and by Lemma 24, we get G 6= Gr,s. By Lemma 14, Gr,s is an immediate descendant of G.\nTo show that there is no other immediate descendant, we use (the dual result of) Lemma 16. Note that S(G)\\S(Gr,s) = {[xr > xs]} and thus, by Lemma 16, it is sufficient to prove that G = G\u2032 := \u2227(i,j)\u2208J [xi > xj ], where J = {(i, j) \u2208 I(G) | there is no path from i to j in GI(G)\\{(i,j)}}. To prove it, we show R(I(G\u2032)) = R(J), and then the result follows from Lemma 24.\nIf R(J)i,j = 1, then R(I(G\u2032))i,j = 1 since GI(G\u2032) is a subgraph of GI(G). If R(I(G\u2032))i,j = 1, then there is a path from i to j in GI(G\u2032), and therefore, there is a path from i to j in GI(G), and thus R(I(G))i,j = 1. Since R(I(G))i,j = 1, there is a path p from i to j in GI(G). Let (r, s) 6\u2208 I(G)\\J . Then, (r, s) \u2208 I(G) and there is a path (other than r \u2192 s) r \u2192 v1 \u2192 v2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 v` = s in GI(G). We now show that there is a path from i to j in GI(G)\\{(r,s)}. This is true because if the path p (in GI(G)) contains the edge r \u2192 s, then we can replace this edge with the path r \u2192 v1 \u2192 v2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 v` = s and get a new path from i to j in GI(G)\\{(r,s)}. Therefore, R(I(G)\\{(r, s)})i,j = 1. By repeating this on the other edges in I(G)\\J , we get R(J)i,j = 1. Proof of Theorem 31: If: Let A be an algorithm that for an input G, which is a directed graph, enumerates all the maximal acyclic subgraphs in polynomial time (poly(N(G), |V |, |E|)). The first step of SPEX (in Figure 3) finds all the immediate descendants of Gmax. By Lemma 29, this is equivalent to enumerating all the maximal acyclic subgraphs of GI . This can be done by A in time poly(N(GI), n, |I|). For every immediate descendant G\u2032 of Gmax = 0, any topological sorting of G\u2032 is a witness for G\u2032 and G. Once SPEX calls Learn on one of the immediate descendants of Gmax, the algorithm proceeds as in the acyclic case. This algorithm runs in time poly(N(GI), n, |I|) time and asks at most N(GI) + |I| membership queries. By Lemma 30, the algorithm runs in time poly(OPT(FI\u2227), n, |I|) and asks at most OPT(FI\u2227) + |I| queries. Only if: Let B be a learning algorithm that runs in poly(OPT(FI\u2227), n, |I|). By the above argument:\nOPT(FI\u2227) \u2264 N(GI) + |I|. (3)\nLet G = ([n], E) be any directed graph. We run the learning algorithm with the target FI where I = E. For any membership query asked by the algorithm, we answer 0 until the algorithm outputs the hypothesis Gmax = 0. Suppose A is the set of all membership queries that are asked by the algorithm. We now claim that:\n1. |A| = poly(N(G), n, |E|). 2. If G\u2032 is a maximal acyclic subgraph of G, then there is an assignment a \u2208 A such that\nE(G\u2032) = {(i, j) \u2208 E | ai > aj}, where E(G\u2032) is the set of edges of G\u2032. Bullet 1 follows since B runs in time poly(OPT(FI\u2227), n, |I|) and by (3) this is poly(N(G), n, |E|). So the number of membership queries cannot be more than poly(N(G), n, |E|) time.\nWe now prove bullet 2. There is an assignment a \u2208 A that satisfies FE(G\u2032)(a) = 1, because otherwise the algorithm cannot distinguish between FE(G\u2032) and Gmax, which violates the correctness of the algorithm. Now, since FE(G\u2032)(a) = 1, we must have E(G\u2032) \u2286 {(i, j) \u2208 E | ai > aj}. Since E(G\u2032) is maximal (adding another edge will create a cycle), we get E(G\u2032) = {(i, j) \u2208 E | ai > aj}.\nThe algorithm that enumerates all the maximal acyclic subgraphs of G(V,E) continues to run as follows: for each a \u2208 A, it defines Ea := {(i, j) \u2208 E | ai > aj}. If Ga := ([n], Ea) is a maximal cyclic subgraph, then it lists Ga. Testing whether Ga := ([n], Ea) is maximal can be done in polynomial time (e.g., by checking edge-by-edge in E). It is easy to verify that the algorithm runs in poly(N(G), |V |, |E|) time."}, {"heading": "Appendix D. Additional Figures", "text": "Here, we provide Figures 4, 5, 6, and 7."}], "references": [{"title": "Learning boolean halfspaces with small weights from membership queries", "author": ["Hasan Abasi", "Ali Z. Abdi", "Nader H. Bshouty"], "venue": "In Algorithmic Learning Theory: 25th International Conference,", "citeRegEx": "Abasi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Abasi et al\\.", "year": 2014}, {"title": "Learning threshold functions with small weights using membership queries", "author": ["Elias Abboud", "Nader Agha", "Nader H. Bshouty", "Nizar Radwan", "Fathi Saleh"], "venue": "In Proceedings of the Twelfth Annual Conference on Computational Learning Theory,", "citeRegEx": "Abboud et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Abboud et al\\.", "year": 1999}, {"title": "Telling stories: Enumerating maximal directed acyclic graphs with a constrained set of sources and targets", "author": ["Vicente Acua", "Etienne Birmel", "Ludovic Cottret", "Pierluigi Crescenzi", "Fabien Jourdan", "Vincent Lacroix", "Alberto Marchetti-Spaccamela", "Andrea Marino", "Paulo Vieira Milreu", "Marie-France Sagot", "Leen Stougie"], "venue": "Theoretical Computer Science,", "citeRegEx": "Acua et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Acua et al\\.", "year": 2012}, {"title": "Recursive program synthesis", "author": ["Aws Albarghouthi", "Sumit Gulwani", "Zachary Kincaid"], "venue": "In Computer Aided Verification - 25th International Conference,", "citeRegEx": "Albarghouthi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Albarghouthi et al\\.", "year": 2013}, {"title": "Learning a hidden matching", "author": ["Noga Alon", "Richard Beigel", "Simon Kasif", "Steven Rudich", "Benny Sudakov"], "venue": "In Proceedings of the 43rd Symposium on Foundations of Computer Science, FOCS \u201902,", "citeRegEx": "Alon et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Alon et al\\.", "year": 2002}, {"title": "Syntaxguided synthesis", "author": ["Rajeev Alur", "Rastislav Bodik", "Garvit Juniwal", "Milo M.K. Martin", "Mukund Raghothaman", "Sanjit A. Seshia", "Rishabh Singh", "Armando Solar-Lezama", "Emina Torlak", "Abhishek Udupa"], "venue": "In Formal Methods in Computer-Aided Design,", "citeRegEx": "Alur et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Alur et al\\.", "year": 2013}, {"title": "Charting patterns on price history", "author": ["Saswat Anand", "Wei-Ngan Chin", "Siau-Cheng Khoo"], "venue": "In Proceedings of the Sixth ACM SIGPLAN International Conference on Functional Programming (ICFP", "citeRegEx": "Anand et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Anand et al\\.", "year": 2001}, {"title": "Queries and concept learning", "author": ["Dana Angluin"], "venue": "Machine Learning,", "citeRegEx": "Angluin.,? \\Q1988\\E", "shortCiteRegEx": "Angluin.", "year": 1988}, {"title": "Learning a hidden graph using queries per edge", "author": ["Dana Angluin", "Jiang Chen"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Angluin and Chen.,? \\Q2008\\E", "shortCiteRegEx": "Angluin and Chen.", "year": 2008}, {"title": "Timefork: Interactive prediction of time series", "author": ["Sriram Karthik Badam", "Jieqiong Zhao", "Shivalik Sen", "Niklas Elmqvist", "David S. Ebert"], "venue": "In Proceedings of the 2016 CHI Conference on Human Factors in Computing Systems,", "citeRegEx": "Badam et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Badam et al\\.", "year": 2016}, {"title": "Stat!: An interactive analytics environment for big data", "author": ["Mike Barnett", "Badrish Chandramouli", "Robert DeLine", "Steven Drucker", "Danyel Fisher", "Jonathan Goldstein", "Patrick Morrison", "John Platt"], "venue": "In Proceedings of the ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "Barnett et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Barnett et al\\.", "year": 2013}, {"title": "Flashrelate: Extracting relational data from semi-structured spreadsheets using examples", "author": ["Daniel W. Barowy", "Sumit Gulwani", "Ted Hart", "Benjamin Zorn"], "venue": "In Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Barowy et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Barowy et al\\.", "year": 2015}, {"title": "Multiple Access Channels: Theory and Practice", "author": ["E. Biglieri", "L. Gyrfi"], "venue": null, "citeRegEx": "Biglieri and Gyrfi.,? \\Q2007\\E", "shortCiteRegEx": "Biglieri and Gyrfi.", "year": 2007}, {"title": "Optimal two-stage algorithms for group testing problems", "author": ["Annalisa De Bonis", "Leszek Gasieniec", "Ugo Vaccaro"], "venue": null, "citeRegEx": "Bonis et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bonis et al\\.", "year": 2005}, {"title": "Telling stories fast", "author": ["Michele Borassi", "Pierluigi Crescenzi", "Vincent Lacroix", "Andrea Marino", "Marie-France Sagot", "Paulo Vieira Milreu"], "venue": "Experimental Algorithms: 12th International Symposium,", "citeRegEx": "Borassi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Borassi et al\\.", "year": 2013}, {"title": "Optimizing synthesis with metasketches", "author": ["James Bornholt", "Emina Torlak", "Dan Grossman", "Luis Ceze"], "venue": "In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,", "citeRegEx": "Bornholt et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bornholt et al\\.", "year": 2016}, {"title": "Cayuga: A high-performance event processing engine", "author": ["Lars Brenna", "Alan Demers", "Johannes Gehrke", "Mingsheng Hong", "Joel Ossher", "Biswanath Panda", "Mirek Riedewald", "Mohit Thatte", "Walker White"], "venue": "In Proceedings of the ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "Brenna et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Brenna et al\\.", "year": 2007}, {"title": "Encyclopedia of Chart Patterns", "author": ["Thomas N. Bulkowski"], "venue": "Wiley, 2nd edition,", "citeRegEx": "Bulkowski.,? \\Q2005\\E", "shortCiteRegEx": "Bulkowski.", "year": 2005}, {"title": "High-performance dynamic pattern matching over disordered streams", "author": ["Badrish Chandramouli", "Jonathan Goldstein", "David Maier"], "venue": "In PVLDB,", "citeRegEx": "Chandramouli et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Chandramouli et al\\.", "year": 2010}, {"title": "Ecg anomaly detection via time series analysis", "author": ["Mooi Choo Chuah", "Fen Fu"], "venue": "In Frontiers of High Performance Computing and Networking ISPA 2007 Workshops: ISPA 2007 International Workshops SSDSN,", "citeRegEx": "Chuah and Fu.,? \\Q2007\\E", "shortCiteRegEx": "Chuah and Fu.", "year": 2007}, {"title": "Group testing. In Fault-Tolerant Search Algorithms, pages 139\u2013173", "author": ["Ferdinando Cicalese"], "venue": null, "citeRegEx": "Cicalese.,? \\Q2013\\E", "shortCiteRegEx": "Cicalese.", "year": 2013}, {"title": "Introduction to Algorithms", "author": ["Thomas H. Cormen", "Clifford Stein", "Ronald L. Rivest", "Charles E. Leiserson"], "venue": "McGraw-Hill Higher Education,", "citeRegEx": "Cormen et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Cormen et al\\.", "year": 2001}, {"title": "Synthesizing view definitions from data", "author": ["Anish Das Sarma", "Aditya Parameswaran", "Hector Garcia-Molina", "Jennifer Widom"], "venue": "In Database Theory - ICDT \u201910, 13th International Conference,", "citeRegEx": "Sarma et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Sarma et al\\.", "year": 2010}, {"title": "The detection of defective members of large populations", "author": ["Robert Dorfman"], "venue": "The Annals of Mathematical Statistics,", "citeRegEx": "Dorfman.,? \\Q1943\\E", "shortCiteRegEx": "Dorfman.", "year": 1943}, {"title": "Combinatorial Group Testing and Its Applications", "author": ["D. Du", "F. Hwang"], "venue": "Applied Mathematics. World Scientific,", "citeRegEx": "Du and Hwang.,? \\Q2000\\E", "shortCiteRegEx": "Du and Hwang.", "year": 2000}, {"title": "Pooling Designs and Nonadaptive Group Testing: Important Tools for DNA Sequencing", "author": ["D. Du", "F. Hwang"], "venue": "Series on applied mathematics. World Scientific,", "citeRegEx": "Du and Hwang.,? \\Q2006\\E", "shortCiteRegEx": "Du and Hwang.", "year": 2006}, {"title": "Reconstructing a hamiltonian cycle by querying the graph: Application to DNA physical mapping", "author": ["Vladimir Grebinski", "Gregory Kucherov"], "venue": "Discrete Appl. Math.,", "citeRegEx": "Grebinski and Kucherov.,? \\Q1998\\E", "shortCiteRegEx": "Grebinski and Kucherov.", "year": 1998}, {"title": "Dimensions in program synthesis", "author": ["Sumit Gulwani"], "venue": "In Proceedings of the 12th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming,", "citeRegEx": "Gulwani.,? \\Q2010\\E", "shortCiteRegEx": "Gulwani.", "year": 2010}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["Sumit Gulwani"], "venue": "In Proceedings of the 38th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,", "citeRegEx": "Gulwani.,? \\Q2011\\E", "shortCiteRegEx": "Gulwani.", "year": 2011}, {"title": "Spreadsheet data manipulation using examples", "author": ["Sumit Gulwani", "William R. Harris", "Rishabh Singh"], "venue": "Commun. ACM,", "citeRegEx": "Gulwani et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Gulwani et al\\.", "year": 2012}, {"title": "Spreadsheet table transformations from examples", "author": ["William R. Harris", "Sumit Gulwani"], "venue": "In Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Harris and Gulwani.,? \\Q2011\\E", "shortCiteRegEx": "Harris and Gulwani.", "year": 2011}, {"title": "Generalized teaching dimensions and the query complexity of learning", "author": ["Tibor Heged\u0171s"], "venue": "In Proceedings of the Eighth Annual Conference on Computational Learning Theory, COLT", "citeRegEx": "Heged\u0171s.,? \\Q1995\\E", "shortCiteRegEx": "Heged\u0171s.", "year": 1995}, {"title": "IBM streams processing language: Analyzing big data in motion", "author": ["M. Hirzel", "H. Andrade", "B. Gedik", "G. Jacques-Silva", "R. Khandekar", "V. Kumar", "M. Mendell", "H. Nasgaard", "S. Schneider", "R. Soul\u00e9", "K.-L. Wu"], "venue": "IBM J. Res. Dev.,", "citeRegEx": "Hirzel et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hirzel et al\\.", "year": 2013}, {"title": "Oracle-guided component-based program synthesis", "author": ["Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari"], "venue": "In Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1,", "citeRegEx": "Jha et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jha et al\\.", "year": 2010}, {"title": "The Art of Computer Programming, Volume 1 (3rd Ed.)", "author": ["Donald E. Knuth"], "venue": null, "citeRegEx": "Knuth.,? \\Q1997\\E", "shortCiteRegEx": "Knuth.", "year": 1997}, {"title": "Programming by demonstration using version space algebra", "author": ["Tessa A. Lau", "Steven A. Wolfman", "Pedro Domingos", "Daniel S. Weld"], "venue": "Machine Learning,", "citeRegEx": "Lau et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lau et al\\.", "year": 2003}, {"title": "Flashextract: A framework for data extraction by examples", "author": ["Vu Le", "Sumit Gulwani"], "venue": "In ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Le and Gulwani.,? \\Q2014\\E", "shortCiteRegEx": "Le and Gulwani.", "year": 2014}, {"title": "A machine learning framework for programming by example", "author": ["Aditya Krishna Menon", "Omer Tamuz", "Sumit Gulwani", "Butler W. Lampson", "Adam Kalai"], "venue": "In Proceedings of the 30th International Conference on Machine Learning,", "citeRegEx": "Menon et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Menon et al\\.", "year": 2013}, {"title": "Pattern recognition to forecast seismic time series", "author": ["A. Morales-Esteban", "F. Martnez-lvarez", "A. Troncoso", "J.L. Justo", "C. Rubio-Escudero"], "venue": "Expert Systems with Applications,", "citeRegEx": "Morales.Esteban et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Morales.Esteban et al\\.", "year": 2010}, {"title": "A survey on combinatorial group testing algorithms with applications to DNA library screening", "author": ["Hung Q Ngo", "Ding-Zhu Du"], "venue": "DIMACS Series in Discrete Mathematics and Theoretical Computer Science,", "citeRegEx": "Ngo and Du.,? \\Q2000\\E", "shortCiteRegEx": "Ngo and Du.", "year": 2000}, {"title": "Searching games with errors\u2014fifty years of coping with liars", "author": ["Andrzej Pelc"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Pelc.,? \\Q2002\\E", "shortCiteRegEx": "Pelc.", "year": 2002}, {"title": "Learning semantic string transformations from examples", "author": ["Rishabh Singh", "Sumit Gulwani"], "venue": "PVLDB, 5(8):740\u2013751,", "citeRegEx": "Singh and Gulwani.,? \\Q2012\\E", "shortCiteRegEx": "Singh and Gulwani.", "year": 2012}, {"title": "Synthesizing data structure manipulations from storyboards", "author": ["Rishabh Singh", "Armando Solar-Lezama"], "venue": "In SIGSOFT/FSE\u201911 19th ACM SIGSOFT Symposium on the Foundations of Software Engineering (FSE-19) and ESEC\u201911: 13th European Software Engineering Conference", "citeRegEx": "Singh and Solar.Lezama.,? \\Q2011\\E", "shortCiteRegEx": "Singh and Solar.Lezama.", "year": 2011}, {"title": "Program synthesis by sketching", "author": ["Armando Solar-Lezama"], "venue": "ProQuest,", "citeRegEx": "Solar.Lezama.,? \\Q2008\\E", "shortCiteRegEx": "Solar.Lezama.", "year": 2008}, {"title": "Sketching concurrent data structures", "author": ["Armando Solar-Lezama", "Christopher Grant Jones", "Rastislav Bodik"], "venue": "In Proceedings of the ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation,", "citeRegEx": "Solar.Lezama et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Solar.Lezama et al\\.", "year": 2008}, {"title": "Stream processing with a spreadsheet", "author": ["Mandana Vaziri", "Olivier Tardieu", "Rodric Rabbah", "Philippe Suter", "Martin Hirzel"], "venue": "In ECOOP 2014 - Object-Oriented Programming - 28th European Conference,", "citeRegEx": "Vaziri et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Vaziri et al\\.", "year": 2014}, {"title": "Enumeration of enumeration algorithms", "author": ["Kunihiro Wasa"], "venue": "CoRR, abs/1605.05102,", "citeRegEx": "Wasa.,? \\Q2016\\E", "shortCiteRegEx": "Wasa.", "year": 2016}, {"title": "High-performance complex event processing over streams", "author": ["Eugene Wu", "Yanlei Diao", "Shariq Rizvi"], "venue": "In Proceedings of the ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "Wu et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2006}, {"title": "A colorful approach to text processing by example", "author": ["Kuat Yessenov", "Shubham Tulsiani", "Aditya Krishna Menon", "Robert C. Miller", "Sumit Gulwani", "Butler W. Lampson", "Adam Kalai"], "venue": "In The 26th Annual ACM Symposium on User Interface Software and Technology,", "citeRegEx": "Yessenov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Yessenov et al\\.", "year": 2013}, {"title": "Automatically synthesizing sql queries from input-output examples", "author": ["Sai Zhang", "Yuyin Sun"], "venue": "In 2013 28th IEEE/ACM International Conference on Automated Software Engineering,", "citeRegEx": "Zhang and Sun.,? \\Q2013\\E", "shortCiteRegEx": "Zhang and Sun.", "year": 2013}, {"title": "Deciphering threshold functions of k-valued logic. In Discrete Analysis and Operations Research", "author": ["N. Yu. Zolotykh", "V.N. Shevchenko"], "venue": "Novosibirsk 2(3),", "citeRegEx": "Zolotykh and Shevchenko.,? \\Q1997\\E", "shortCiteRegEx": "Zolotykh and Shevchenko.", "year": 1997}], "referenceMentions": [{"referenceID": 7, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 46, "endOffset": 61}, {"referenceID": 23, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 165, "endOffset": 180}, {"referenceID": 8, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 224, "endOffset": 248}, {"referenceID": 12, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 321, "endOffset": 347}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002).", "startOffset": 430, "endOffset": 449}, {"referenceID": 26, "context": ", 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002).", "startOffset": 30, "endOffset": 60}, {"referenceID": 40, "context": ", 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002).", "startOffset": 77, "endOffset": 89}, {"referenceID": 11, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 36, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 28, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 33, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 11, "context": "The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011).", "startOffset": 172, "endOffset": 257}, {"referenceID": 36, "context": "The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011).", "startOffset": 172, "endOffset": 257}, {"referenceID": 28, "context": "The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011).", "startOffset": 172, "endOffset": 257}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al.", "startOffset": 431, "endOffset": 596}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al.", "startOffset": 431, "endOffset": 615}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007).", "startOffset": 431, "endOffset": 636}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007).", "startOffset": 431, "endOffset": 657}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007).", "startOffset": 431, "endOffset": 674}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007). Many of the new applications present new models and new problems.", "startOffset": 431, "endOffset": 701}, {"referenceID": 33, "context": "small (finite) set of programs and ask the user membership queries while there are non-equivalent programs in the search space (Jha et al., 2010).", "startOffset": 127, "endOffset": 145}, {"referenceID": 2, "context": "If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 183, "endOffset": 236}, {"referenceID": 14, "context": "If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 183, "endOffset": 236}, {"referenceID": 46, "context": "If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 183, "endOffset": 236}, {"referenceID": 17, "context": "Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al.", "startOffset": 66, "endOffset": 83}, {"referenceID": 19, "context": "Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al.", "startOffset": 94, "endOffset": 114}, {"referenceID": 38, "context": "Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al., 2010).", "startOffset": 131, "endOffset": 161}, {"referenceID": 25, "context": "We note that there are other applications for learning halfspaces; for example, Heged\u0171s (1995); Zolotykh and Shevchenko (1995); Abboud et al.", "startOffset": 80, "endOffset": 95}, {"referenceID": 25, "context": "We note that there are other applications for learning halfspaces; for example, Heged\u0171s (1995); Zolotykh and Shevchenko (1995); Abboud et al.", "startOffset": 80, "endOffset": 127}, {"referenceID": 0, "context": "We note that there are other applications for learning halfspaces; for example, Heged\u0171s (1995); Zolotykh and Shevchenko (1995); Abboud et al. (1999); Abasi et al.", "startOffset": 128, "endOffset": 149}, {"referenceID": 0, "context": "(1999); Abasi et al. (2014). The second class we consider is conjunctions over F , where F is the set of variable inequalities, i.", "startOffset": 8, "endOffset": 28}, {"referenceID": 33, "context": "Also, it is known that a topological sorting for an acyclic set can be found in linear time (see Knuth (1997), Volume 1, Section 2.", "startOffset": 97, "endOffset": 110}, {"referenceID": 21, "context": "3 and Cormen et al. (2001)).", "startOffset": 6, "endOffset": 27}, {"referenceID": 2, "context": "The problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 106, "endOffset": 159}, {"referenceID": 14, "context": "The problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 106, "endOffset": 159}, {"referenceID": 46, "context": "The problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 106, "endOffset": 159}, {"referenceID": 37, "context": ", Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 2, "endOffset": 29}, {"referenceID": 37, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 8, "endOffset": 38}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al.", "startOffset": 39, "endOffset": 58}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)).", "startOffset": 39, "endOffset": 82}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE synthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al.", "startOffset": 39, "endOffset": 285}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE synthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al.", "startOffset": 39, "endOffset": 313}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE synthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al. (2015)).", "startOffset": 39, "endOffset": 335}, {"referenceID": 17, "context": "Time-series are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (MoralesEsteban et al.", "startOffset": 66, "endOffset": 83}, {"referenceID": 19, "context": "Time-series are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (MoralesEsteban et al.", "startOffset": 94, "endOffset": 114}, {"referenceID": 43, "context": "For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al.", "startOffset": 19, "endOffset": 39}, {"referenceID": 33, "context": "For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.", "startOffset": 109, "endOffset": 127}, {"referenceID": 18, "context": ", MetaTrader, MetaStock, NinjaTrader, and Microsoft\u2019s StreamInsight (Chandramouli et al., 2010).", "startOffset": 68, "endOffset": 95}, {"referenceID": 10, "context": "Another tool designed to help analysts is Stat! (Barnett et al., 2013), an interactive tool enabling analysts to write queries in StreamInsight.", "startOffset": 48, "endOffset": 70}, {"referenceID": 9, "context": "TimeFork (Badam et al., 2016) is an interactive tool that helps analysts with predictions based on automatic analysis of the past stock price.", "startOffset": 9, "endOffset": 29}, {"referenceID": 6, "context": "CPL (Anand et al., 2001) is a Haskell-based high-level language designed for chart pattern queries.", "startOffset": 4, "endOffset": 24}, {"referenceID": 47, "context": "SASE (Wu et al., 2006) is a system designed for RFID (radio frequency identification) streams that offers a user-friendly language and can handle large volumes of data.", "startOffset": 5, "endOffset": 22}, {"referenceID": 16, "context": "Cayuga (Brenna et al., 2007) is a system for detecting complex patterns in streams, whose language is based on Cayuga algebra.", "startOffset": 7, "endOffset": 28}, {"referenceID": 32, "context": "SPL (Hirzel et al., 2013) is IBM\u2019s stream processing language supporting pattern detections.", "startOffset": 4, "endOffset": 25}, {"referenceID": 45, "context": "ActiveSheets (Vaziri et al., 2014) is a platform that enables Microsoft Excel to process real-time streams from within spreadsheets.", "startOffset": 13, "endOffset": 34}, {"referenceID": 17, "context": ", Gulwani (2010); Lau et al.", "startOffset": 2, "endOffset": 17}, {"referenceID": 17, "context": ", Gulwani (2010); Lau et al. (2003); Das Sarma et al.", "startOffset": 2, "endOffset": 36}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al.", "startOffset": 12, "endOffset": 32}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al.", "startOffset": 12, "endOffset": 59}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al.", "startOffset": 12, "endOffset": 75}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al.", "startOffset": 12, "endOffset": 98}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al.", "startOffset": 12, "endOffset": 124}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al. (2013); Albarghouthi et al.", "startOffset": 12, "endOffset": 148}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al.", "startOffset": 8, "endOffset": 35}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al.", "startOffset": 8, "endOffset": 57}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al.", "startOffset": 8, "endOffset": 78}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al.", "startOffset": 8, "endOffset": 101}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)).", "startOffset": 8, "endOffset": 123}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)).", "startOffset": 8, "endOffset": 151}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 8, "endOffset": 810}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 8, "endOffset": 841}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al.", "startOffset": 8, "endOffset": 861}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)).", "startOffset": 8, "endOffset": 885}], "year": 2017, "abstractText": "LetF be a set of boolean functions. We present an algorithm for learningF\u2228 := {\u2228f\u2208Sf | S \u2286 F} from membership queries. Our algorithm asks at most |F| \u00b7OPT(F\u2228) membership queries where OPT(F\u2228) is the minimum worst case number of membership queries for learning F\u2228. When F is a set of halfspaces over a constant dimension space or a set of variable inequalities, our algorithm runs in polynomial time. The problem we address has practical importance in the field of program synthesis, where the goal is to synthesize a program that meets some requirements. Program synthesis has become popular especially in settings aiming to help end users. In such settings, the requirements are not provided upfront and the synthesizer can only learn them by posing membership queries to the end user. Our work enables such synthesizers to learn the exact requirements while bounding the number of membership queries.", "creator": "LaTeX with hyperref package"}}}