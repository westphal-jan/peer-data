{"id": "1106.2692", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2011", "title": "Generating Schemata of Resolution Proofs", "abstract": "Two dhalla distinct philippensis algorithms metlika are lumpen presented harthi to agouti extract (gahsh schemata usl-2 of) resolution cheerfulness proofs from buspar closed 2425 tableaux for stabbing propositional horrida schemata. rothwax The first one maiffret handles the macap\u00e1 most s.league efficient cuteness version of the emptiest tableau wojnar calculus guattari but generates very chirbury complex dater derivations (denoted undefended by 0300gmt rather elaborate tyrosinase rewrite systems ). The genkai second gullible one has the advantage that much simpler kurylenko systems can voigt be graflex obtained, however the penal considered megaman proof wyck procedure is less efficient.", "histories": [["v1", "Tue, 14 Jun 2011 12:40:07 GMT  (101kb,S)", "http://arxiv.org/abs/1106.2692v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["vincent aravantinos", "nicolas peltier"], "accepted": false, "id": "1106.2692"}, "pdf": {"name": "1106.2692.pdf", "metadata": {"source": "CRF", "title": "Generating Schemata of Resolution Proofs", "authors": ["Vincent Aravantinos", "Nicolas Peltier"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n10 6.\n26 92\nv1 [\ncs .A\nI] 1\n4 Ju\nIn [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems. This proof procedure is able to test the validity of logical formul\u00e6 built on a set of indexed propositional symbols, using generalized connectives such as \u2228 n i=1 or \u2227 n\ni=1, where i, n are part of the language (n denotes a parameter, i.e. an existentially quantified variable). A schema is unsatisfiable iff it is unsatisfiable for every value of n. Stab combines the usual expansion rules of propositional logic with some delayed instantiation schemes that perform a case-analysis on the value of the parameter n. Termination is ensured for a specific class of schemata, called regular, thanks to a loop detection rule which is able to prune infinite tableaux into finite ones, by encoding a form a mathematical induction (by \u201cdescente infinie\u201d). A related algorithm, called Dpll\u2217 and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3].\nIn the present work, we show that resolution proofs can be automatically extracted from the closed tableaux constructed by Stab or Dpll\u2217 on unsatisfiable schemata. More precisely, we present an algorithm that, given a closed tableau T for a schema \u03c6n, returns a schema of a refutation of \u03c6n in the resolution calculus [9]. In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6]. The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8]. The present paper extends these techniques to propositional schemata. Beside the previously mentioned applications, this turned out to be particularly important in the context of the ASAP project [1] in which schemata calculi are applied to the formalisation and analysis of mathematical proofs via cut-elimination. Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies\non the existence of a resolution proof of the so-called characteristic clause set extracted from the initial proof. The cut-free proof is reconstructed from this refutation, by replacing the clauses occurring in this set by some \u201cprojections\u201d of the original proof. While Stab and Dpll\u2217 are able to detect the unsatisfiability of characteristic clause sets, as such this is completely useless since actually it is known that those sets are always unsatisfiable (see Proposition 3.2 in [5]). It is thus essential to be able to generate explicitly a representation of the resolution proof. This is precisely the aim of the present paper. Since the initial formula depends on a parameter n, its proof will also depend on n (except in very particular and trivial cases), i.e. it must be a schema of resolution proof (which will be encoded by recursive definitions).\nThe rest of the paper is structured as follows. In Section 1 we introduce the basic notions and notations used throughout our work, in particular the logic of propositional schemata (syntax and semantics). In Section 2 we define a tableau-based proof procedure for this logic. This calculus simulates both Stab and Dpll\u2217 (for the specific class of schemata considered in the present paper). In Section 3 we provide an algorithm to extract resolution proofs from closed tableaux. Similarly to the formul\u00e6 themselves, the constructed derivations are represented by rewrite systems. In Section 4 we introduce a second algorithm which generates simpler derivations but that requires that one of the closure rules defined in Section 2 (the so-called Loop Detection rule) be replaced by a less powerful rule, called the Global Loop Detection rule. Section 5 briefly concludes our work."}, {"heading": "1 Propositional schemata", "text": "The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable). We consider three disjoint sets of symbols: a set of arithmetic variables V , a set of propositional variables \u2126 and a set of defined symbols \u03a5. Let \u227a be a total well-founded ordering on the symbols in \u03a5. An index expression is either a natural number or of the form n + k, where n is an arithmetic variable and k is a natural number. Let I be a set of index expressions. The set F(I) of formul\u00e6 built on I is inductively defined as follows: if p \u2208 \u2126 \u222a \u03a5 and \u03b1 \u2208 I then p\u03b1 \u2208 F(I); \u22a4,\u22a5 \u2208 F(I); and if \u03c6, \u03c8 \u2208 F(I) then \u00ac\u03c6, \u03c6 \u2228 \u03c8, \u03c6 \u2227 \u03c8, \u03c6 \u21d2 \u03c8 and \u03c6 \u21d4 \u03c8 are in F(I).\nDefinition 1 We assume that each element \u03c5 \u2208 \u03a5 is mapped to two rewrite rules \u03c11\u03c5 and \u03c1 0 \u03c5 that are respectively of the form \u03c5i+1 \u2192 \u03c6 (inductive case) and \u03c50 \u2192 \u03c8 (base case), where \u03c6 \u2208 F({i+ 1, i, 0}), \u03c8 \u2208 F({0}) and:\n1. For every atom \u03c4\u03b1 occurring in \u03c6 such that \u03c4 \u2208 \u03a5 we have either \u03c4 \u227a \u03c5 and \u03b1 \u2208 {i+ 1, i, 0} or \u03c4 = \u03c5 and \u03b1 \u2208 {0, i}.\n2. For every atom \u03c4\u03b1 occurring in \u03c8 such that \u03c4 \u2208 \u03a5 we have \u03c4 \u227a \u03c5 and \u03b1 = 0. \u2738\nWe denote by R the rewrite system: {\u03c11\u03c5, \u03c1 0 \u03c5 | \u03c5 \u2208 \u03a5}. The rules \u03c1 1 \u03c5 and \u03c1 0 \u03c5\nare provided by the user, they encode the semantics of the defined symbols.\nProposition 2 R is convergent.\nProof. By Conditions 1 and 2 in Definition 1, the rules in R either strictly decrease the values of the defined symbols occurring in the formula w.r.t. \u227a or do not increase the value of these symbols but strictly decreases the value of their indices. Thus termination is obvious. Confluence is then immediate since the system is orthogonal.\nFor every formula \u03c6, we denote by \u03c6\u2193R the unique normal form of \u03c6. A schema (of parameter n) is an element of F({0, n, n+ 1}). We denote by \u03c6{n \u2190 k} the formula obtained from \u03c6 by replacing every occurrence of n by k. Obviously for any schema \u03c6, \u03c6{n \u2190 k} \u2208 F({0, k, k + 1}). A propositional formula is a formula \u03c6 \u2208 F(N) containing no defined symbols. Notice that if \u03c6 \u2208 F(N) then \u03c6\u2193R is a propositional formula.\nProposition 3 If \u03c6 \u2208 F(N) then \u03c6\u2193R is a propositional formula.\nProof. By definition ofR, \u03c6\u2193R\u2208 F(N). Furthermore, if \u03c6\u2193R contains a defined symbol \u03c5 then either \u03c11\u03c5 or \u03c1 0 \u03c5 applies, which is impossible.\nAn interpretation is a function mapping every arithmetic variable n to a natural number and every atom of the form pk (where k \u2208 N) to a truth value true or false. An interpretation I validates a propositional formula \u03c6 iff one of the following conditions holds: \u03c6 is of the form pk and I(pk) = true; \u03c6 is of the form \u00ac\u03c8 and I does not validate \u03c8; or \u03c6 is of the form \u03c81 \u2228 \u03c82 (resp. \u03c81 \u2227 \u03c82) and I validates \u03c81 or \u03c82 (resp. \u03c81 and \u03c82). I validates a schema \u03c6 (written I |= \u03c6) iff I validates \u03c6{n \u2190 I(n)}\u2193R. We write \u03c6 |= \u03c8 if every interpretation I validating \u03c6 also validates \u03c8 and \u03c6 \u2261 \u03c8 if \u03c6 |= \u03c8 and \u03c8 |= \u03c6. Example 4 The schema p0\u2227 \u2227 n\ni=1(pi\u22121 \u21d2 pi)\u2227\u00acpn is encoded by p0\u2227\u03c5n\u2227\u00acpn, where \u03c5 is defined by the rules: \u03c5i+1 \u2192 (\u00acpi \u2228 pi+1) \u2227 \u03c5i and \u03c50 \u2192 \u22a4.\nThe schema \u2228 n i=1 pi \u2227 \u2227 n i=1 \u00acpi is encoded by \u03c4n \u2227 \u03c4 \u2032 n , where \u03c4 and \u03c4 \u2032 are\ndefined by the rules: \u03c4i+1 \u2192 pi+1 \u2228 \u03c4i, \u03c40 \u2192 \u22a5, \u03c4 \u2032 i+1 \u2192 \u00acpi+1 \u2227 \u03c4 \u2032 i and \u03c4 \u20320 \u2192 \u22a4.\nBoth schemata are obviously unsatisfiable. The schema (pn \u21d4 (pn\u22121 \u21d4 (. . . (p1 \u21d4 p0) . . .))) is defined by \u03c5 \u2032 n , where:\n\u03c5\u2032 i+1 \u2192 (pi+1 \u21d4 \u03c5 \u2032 i ) and \u03c5\u20320 \u2192 p0. \u2663"}, {"heading": "2 Proof procedure", "text": "In this section we define the proof procedure used to decide the validity of propositional schemata. We assume for simplicity that the considered schemata are in negative normal form and that the defined symbols occur only positively1.\n1If a defined symbol \u03c5 occurs negatively then it is easy to replace every literal of the form \u00ac\u03c5\u03b1 by an atom \u03c5\u03b1 where \u03c5 denotes the complementary of \u03c5. The rewrite rules for \u03c5 are obtained by negating the right-hand side of the rules of \u03c5, e.g. the atom \u03c5 corresponding to the symbol \u03c5 in Example 4 is defined by the rewrite rules \u03c5i+1 \u2192 (pi \u2227 \u00acpi+1) \u2228 \u03c5i and \u03c50 \u2192 \u22a5.\nThe procedure is similar to the one presented in [2] and based on propositional block tableaux [12]. It constructs a tree labeled by finite sets of schemata, using expansion rules of the form: \u03a6\n\u03a81 . . . \u03a8k , meaning that a leaf whose label\nis of the form \u03a6\u222a\u03a6\u2032 (and does not already contain \u22a5) is expanded by adding k children labeled by \u03a6\u2032 \u222a\u03a81, . . . , \u03a6\n\u2032 \u222a\u03a8k respectively. If \u03b1 is a node in T , then T (\u03b1) denotes the label of \u03b1. The expansion rules are defined as follows:\nNormalisation: \u03c5\u03b1\n\u03c5\u03b1\u2193R if \u03c5\u03b1 is reducible w.r.t. R\n\u2228-Decomposition \u2227-Decomposition Closure \u03c6 \u2228 \u03c8 \u03c6 \u03c8 \u03c6 \u2227 \u03c8 \u03c6, \u03c8 \u03c6,\u00ac\u03c6 \u22a5\nPurity rule: pn+k \u22a4\n\u00acpn+k \u22a4\nif k > 0 and the previous rules do not apply\nNote that the notion of pure literal is much simpler here than in [2]. This is due to the fact that no constant index distinct from 0 and no index of the form i+ k where k > 1 are allowed.\nA node that is irreducible w.r.t. all the previous rules is called a layer. The Loop Detection rule applies to nodes containing previously generated layers:\nLoop Detection: \u03a6 \u22a5\nif a non leaf layer labeled by \u03a6 exists in the tree\nNote that the layer does not necessarily occur in the same branch as the one on which the rule is applied. The essential point is that the set of schemata \u03a6 has already been considered somewhere - consequently if it has a model then an open branch necessarily exists elsewhere in the tree.\nFinally, the last rule performs a case analysis on n (in this particular rule, \u03a6 denotes the whole label of the considered node):\nExplosion: \u03a6 \u03a6{n \u2190 0} \u03a6{n \u2190 n+ 1} if no other rule applies and n occurs in \u03a6\nA tableau is closed if the labels of all leaves contain \u22a5.\nTheorem 5 The tableau expansion rules are terminating, i.e. there is no infinite sequence (Ti)i\u2208N such that for every i \u2208 N, Ti+1 is obtained from Ti by applying one of the previous rules.\nProof. The termination of the rules Normalisation, Decomposition, Closure and Loop Detection is obvious: indeed, the Normalisation rule strictly decreases the value of the indices occurring in the formul\u00e6, whereas the other rules cannot increase these indices and strictly reduces the size of the label (i.e. the number of symbols). Thus we only have to show that the number of layers is finite. Let\nS be the set of layers generated by the expansion rule on a given set of schemata of some parameter n. By definition, a layer is irreducible by the Decomposition rules, thus every formula occurring in T (\u03b1) where \u03b1 \u2208 S must be a literal. By irreducibility w.r.t. the Normalisation and Purity rules, the indices of these literals must be either n or 0. Since \u227a is well-founded, and since all labels are finite, the number of symbols occurring in the tableau must be finite, hence the set {T (\u03b1) | \u03b1 \u2208 S} is finite. By the order of application of the expansion rules, the Explosion rule cannot be applied on two layers labeled by the same set of formul\u00e6. Thus S is finite.\nThe next theorem states that the calculus is correct:\nTheorem 6 If T contains an irreducible leaf not containing \u22a5, then the label of the root of T is satisfiable.\nProof. Let \u03b1 be the root of T . The proof is by induction on the depth of the irreducible node in T .\n\u2022 Assume that \u03b1 is irreducible. \u03b1 must be a layer, thus T (\u03b1) is a set of literals, indexed by the parameter n or by 0 (as shown in the proof of Theorem 5). By irreducibility w.r.t. the Explosion rule, n cannot occur in the label. Thus T (\u03b1) is a set of literals indexed by 0. Furthermore, T (\u03b1) cannot contain two complementary literals, hence must be satisfiable.\n\u2022 If \u03b1 is not irreducible, then some expansion rule must be applied on \u03b1. The rule cannot be the Closure rule, nor the Loop Detection rule (otherwise \u03b1 would necessarily contain \u22a5). We distinguish several cases:\n\u2013 If the \u2227-decomposition rule is applied on \u03b1 then \u03b1 has one child \u03b2. By the induction hypothesis T (\u03b2) is satisfiable. By definition of the rule, we have T (\u03b1) \u2261 T (\u03b2) hence T (\u03b1) is satisfiable.\n\u2013 If the \u2228-decomposition rule is applied on \u03b1 then \u03b1 has two children \u03b21 and \u03b22. By definition, the irreducible node must occur in the branch of \u03b21 or \u03b22, say \u03b21. By the induction hypothesis T (\u03b21) is satisfiable. By definition of the rule, we have T (\u03b21) |= T (\u03b1) hence T (\u03b1) is satisfiable.\n\u2013 If the Explosion rule is applied on \u03b1 then \u03b1 has two children \u03b21 and \u03b22 corresponding to the case n \u2190 0 and n \u2190 n + 1 respectively. By definition, the irreducible node must occur in the branch of \u03b21 or \u03b22. If it occurs in the branch of \u03b21, then by the induction hypothesis \u03b21 has a model I. Moreover, by definition of the rule T (\u03b21) contains no occurrence of n (since n is replaced by 0), thus the truth value of T (\u03b21) is independent of the value of n. We may thus assume that I(n) = 0. Then I |= T (\u03b1) iff I |= T (\u03b1){n \u2190 0}, i.e. iff I |= T (\u03b21). Therefore, I is a model of \u03b1.\nIf the irreducible node is a descendant of \u03b22, then by the induction hypothesis \u03b22 has a model I. Let J be an interpretation coinciding\nwith I except that J(n) def\n= I(n)+1. By definition, we have J |= T (\u03b1) iff I |= T (\u03b1){n \u2190 n+ 1}, i.e. if I |= T (\u03b22). Therefore, J is a model of \u03b1.\n\u2013 If the Purity rule is applied on \u03b1, then \u03b1 has one child \u03b2. We have T (\u03b1) = T (\u03b2) \u222a {pn+k} (resp. T (\u03b2) \u222a {\u00acpn+k}), where k > 0. By the induction hypothesis, T (\u03b2) has a model I. We remark that the truth value of T (\u03b2) does not depend on the value of pn+k. Indeed, pn+k cannot occur in T (\u03b2) (otherwise the Closure rule would be applicable on T (\u03b1) which is impossible). Furthermore, by irreducibility w.r.t. the Normalisation rule, the indices of the defined symbols occurring in \u03b1 must be 0 or n. Since the rewrite rules in R cannot increase the value of the these indices, the truth value of these indexed defined symbols depends only of the values of the atoms indexed by I(n), I(n \u2212 1), . . . , I(0). Thus we may assume that I(pn+k) = true (resp. I(pn+k) = false). Hence I |= T (\u03b1).\nWe will not prove the converse (namely that the root of every closed tableau is unsatisfiable), because this is subsumed by Theorem 18 in Section 3 (ensuring the existence of a resolution proof for every instance of the root schema).\nExample 7 The schema \u03c6 : p0 \u2227 \u00acpn \u2227 \u03c5n, where \u03c5 is defined as in Example 4 is unsatisfiable. For instance, \u03c6{n \u2190 2} is p0 \u2227 \u00acp2 \u2227 (\u00acp0 \u2228 p1) \u2227 (\u00acp1 \u2228 p2). The reader can check that the expansion rules construct the following tableau. The root is actually a layer, hence the Explosion rule is applied on it. The node (3) is deduced by the Purity rule and closed by applying the Loop Detection rule (with the root). The other rule applications are straightforward.\n\u03c6 (7)\np0,\u00acp0, \u03c50 (1)\n\u22a5\np0,\u00acpn+1\u03c5n+1 (6)\np0,\u00acpn+1, \u03c5n, (\u00acpn \u2228 pn+1) (5)\np0,\u00acpn+1, \u03c5n, pn+1 (2)\n\u22a5\np0,\u00acpn+1, \u03c5n,\u00acpn (4)\np0, \u03c5n,\u00acpn (3)\n\u22a5 \u2663\nThe Dpll\u2217 procedure in [3] can be simulated by the previous expansion rules, simply by adding for each propositional symbol p \u2208 \u2126, a defined symbol \u03c5p with two rules: \u03c5p\ni+1 \u2192 ((pi\u2228\u00acpi)\u2227\u03c5 p i ) and \u03c5p0 \u2192 \u22a4. Then the case splitting\nrule of the DPLL procedure on a variable p corresponds to an application of the \u2227-rule on \u03c5p\nn+1\u2193R (yielding pn\u2228\u00acpn) followed by an application of the \u2228-rule on pn \u2228 \u00acpn. The propagation rule is then simulated by combining the \u2228-rule and the closure rule2."}, {"heading": "3 Constructing resolution proofs", "text": ""}, {"heading": "3.1 Propositional resolution calculus", "text": "We first briefly recall the notion of resolution inference (in propositional logic). A literal is either an atom pk or the negation of an atom \u00acpk (where p \u2208 \u2126 and k \u2208 N). A clause is a (possibly empty) disjunction (or set) of literals. A derivation from a set of clauses S is a finite sequence C1, . . . , Cm such that for every i \u2208 [1,m], Ci is either an element of S or obtained from C1, . . . , Cm\u22121 by applying the resolution rule, defined as follows: pk \u2228X \u00acpk \u2228 Y\nX \u2228 Y A refutation is a derivation containing\u22a5 (the empty clause). For any formula \u03c6, \u2206 is a derivation from \u03c6 if it is a derivation from a clausal form of \u03c6. It is well-known [9] that every unsatisfiable set of (propositional) clauses has a refutation. In the context of propositional schemata, this means that every instance \u03c6{n \u2190 k}\u2193R of an unsatisfiable propositional schema \u03c6 of parameter n has a refutation \u2206k (which in general depends on k). The problem is then to construct a representation of the sequence of refutations \u22060,\u22061, . . . ,\u2206k, . . . This sequence may be seen as a schema of refutation which (similarly to the semantics of the defined symbols) will be denoted by a system of rewrite rules. From now, we assume that the considered schema is in conjunctive normal form (i.e. it contains no conjunctions inside disjunctions, even if these conjunctions are \u201chidden\u201d in the inductive definitions of the defined symbols, e.g. the schema pn \u2228 \u03c5n, where \u03c5 is defined as in Example 4 is forbidden)."}, {"heading": "3.2 A language for representing refutations", "text": "Additional definitions are needed to provide suitable formal languages for denoting such schemata of derivations. Let D and X be two disjoint sets of symbols (disjoint from V , \u2126 and \u03a5). The symbols in D are the \u2206-symbols and the ones in X are the \u2206-variables. The symbols in X are intended to be instantiated by schemata, whereas the symbols d \u2208 D will denote schemata of refutations, defined by induction (and possibly depending on an additional argument \u2206 denoting a formula). We assume that \u227a is extended into a well-founded ordering on D.\nFormally, the set of \u2206-expressions is inductively defined as follows:\n\u2022 All schemata and all \u2206-variables are \u2206-expressions.\n2This \u201ctrick\u201d does not actually simulate the full procedure in [3], because the latter handles schemata that are more complex than the ones considered in the present paper, possibly containing nested iterations.\n\u2022 If d \u2208 D, \u03b1 is an index expression and \u2206 is a \u2206-expression, then d\u03b1 and d\u03b1(\u2206) are \u2206-expressions.\n\u2022 If \u2206 and \u0393 are \u2206-expressions then \u2206\u2228\u0393, \u2206\u2227\u0393 and \u2206\u00b7\u0393 are \u2206-expressions.\nThe expression \u2206\u00b7\u0393 is to be interpreted as the concatenation of two sequences \u2206 and \u0393. Note that \u2206-expressions can represent uniformly schemata of clauses, schemata of clause sets, or schemata of derivations (i.e. schemata of sequences of clauses). For the sake of conciseness and simplicity, the previous definition does not ensure that the constructions are well-typed, e.g. we can consider \u2206- expressions of the form \u2206\u2228\u0393 where \u2206 and \u0393 are two sequences of clauses (which obviously does not make sense: \u2206 and \u0393 should rather be clauses). But in the forthcoming definitions we will ensure that all the considered \u2206-expressions are well-typed.\nExample 8 Let d \u2208 D. Then (p2 \u2228 q0) \u00b7 d2(q0) \u00b7 \u00acq0 \u00b7 \u22a5 is a \u2206-expression. \u2663\nA \u2206-expression is ground if it contains no index variable and no \u2206-variable. In order to interpret (ground) \u2206-expressions, the value of the \u2206-symbols is specified using a rewrite system, exactly as schemata can be transformed into propositional formul\u00e6 by interpreting the defined symbols (using the rewrite system R). The rewrite systems used in this section are more complicated than in the previous one, since the symbols in D may have an additional argument.\nA \u2206-substitution is a function mapping every arithmetic variable to an index expression and every \u2206-variable to a \u2206-expression. If \u2206 is a \u2206-expression and \u03c3 is a \u2206-substitution, then \u2206\u03c3 denotes the \u2206-expression obtained from \u2206 by replacing every variable x \u2208 V \u222a X by \u03c3(x).\nDefinition 9 A D-system is a set of rewrite rules of the form \u2206 \u2192 \u0393, where \u2206,\u0393 are two \u2206-expressions such that every arithmetic variable and every \u2206- variable occurring in \u0393 also occurs in \u2206. A D-system is propositional if it contains no \u2206-variables (it may contain arithmetic variables).\nGiven two \u2206-expressions \u2206 and \u0393 and a D-system R, we write \u2206 \u2192R \u0393 if there exists a rule \u2206\u2032 \u2192 \u0393\u2032 in R and a \u2206-substitution \u03c3 such that \u0393 is obtained from \u2206 by replacing an occurrence of an expression \u2206\u2032\u03c3 by \u0393\u2032\u03c3. \u2738\nFor matching, the associativity and commutativity of logical symbols are not taken into account in general, except for conjunctions occurring at the root level (this rather unusual convention is needed to ensure confluence without having to bother on the order of the schemata at the root level). For instance the rule d(p \u2227 ((r \u2227 q) \u2228 \u00acr)) \u2192 p does not apply on d(p \u2227 (\u00acr \u2228 (r \u2227 q))) nor on d(p\u2227((q\u2227r)\u2228\u00acr)), but it applies on d(((r\u2227q)\u2228\u00acr)\u2227p). Similarly, d(p\u2227q) \u2192 p applies on d(p) by assuming q = \u22a4.\nExample 10 Consider the following rewrite system (Z is a \u2206-variable).\n{di+1(Z) \u2192 (\u00acpi+1 \u2228 pi) \u00b7 (pi \u2228 Z) \u00b7 di(Z), d0(Z) \u2192 \u00acp0 \u00b7 Z}\nThe reader can check that it reduces the \u2206-expression of Example 8 to:\n(p2 \u2228 q0) \u00b7 (\u00acp2 \u2228 p1) \u00b7 (p1 \u2228 q0) \u00b7 (\u00acp1 \u2228 p0) \u00b7 (p0 \u2228 q0) \u00b7 \u00acp0 \u00b7 q0 \u00b7 \u00acq0 \u00b7 \u22a5\nThis last expression is a refutation. \u2663"}, {"heading": "3.3 From closed tableaux to resolution proofs", "text": "Let T be a closed tableau of a schema \u03c6. The general idea is to construct, from T , a D-system R(T ) representing a schema of refutation for \u03c6. Obviously, R(T ) represents an inductive proof of the assertion: \u201cfor every n \u2208 N, the corresponding instance of \u03c6 is unsatisfiable\u201d. Ideally, we would just refute the base case, and then build a refutation of \u03c6 at n+ 1 from a refutation of \u03c6 at n. However, as often in inductive reasoning, we need to generalize the conjecture in order to refute it properly. This is done as follows: recall that our aim is to construct a refutation of \u03c6, i.e. a derivation of \u22a5 from \u03c6; instead, however, R(T ) will describe how to build a derivation of X from \u03c6 \u2228 X , for any X (formally, X will be a \u2206-variable). Then, our original goal will be reached by just substituting \u22a5 to X . In practice, we need to generalize even more this reasoning since the construction of R(T ) is done by mapping every node \u03b1 of T to some rewrite rules. So, instead of considering only the root schema \u03c6, we need to consider all the formul\u00e6 {\u03c61, . . . , \u03c6k} that occur in T (\u03b1). And, instead of building a derivation of X from \u03c6\u2228X , we build a derivation of X1 \u2228 \u00b7 \u00b7 \u00b7 \u2228Xk from (\u03c61\u2228X1)\u2227\u00b7 \u00b7 \u00b7\u2227(\u03c6k\u2228Xk), for some \u2206-variablesX1, . . . , Xk. More precisely we build a derivation of a clause C \u2286 X1 \u2228 . . .\u2228Xk, since some formul\u00e6 \u03c6i \u2228Xi may be useless. We retrieve our original goal when we just substitute the root of T to \u03b1.\nThe following definition constructs a D-system R(T ) and two \u2206-symbols \u03bd\u03b1 and \u00b5\u03b1 such that, if T (\u03b1) = {\u03c61, . . . , \u03c6k} and U denotes the formula (\u03c61\u2228X1)\u2227 \u00b7 \u00b7 \u00b7 \u2227 (\u03c6k \u2228 Xk) then \u00b5 \u03b1 n (U) denotes the above clause C and \u03bd\u03b1 n (U) denotes a derivation of C from U . This system is constructed by induction on the tableau.\nDefinition 11 Let T be a tableau. We map every node \u03b1 in T to two \u2206- symbols \u03bd\u03b1 and \u00b5\u03b1. We assume that the symbols \u03bd\u03b1 and \u00b5\u03b1 are pairwise distinct. The system of rules R(T ) is defined by the rules in R and the following rules, for every node \u03b1 in T (we distinguish several cases, according to the rule applied on \u03b1):\n\u2022 If no rule is applied on \u03b1: \u03bd\u03b1 n ((\u22a5\u2228X)\u2227Y ) \u2192 X \u00b5\u03b1 n ((\u22a5\u2228X)\u2227Y ) \u2192 X\n\u2022 If the Normalisation rule is applied on \u03b1, using a formula \u03c6, yielding a node \u03b2:\n\u03bd\u03b1 n ((\u03c6 \u2228X) \u2227 Y ) \u2192 \u03bd\u03b2 n ((\u03c6\u2193R \u2228X) \u2227 Y ) \u00b5\u03b1 n ((\u03c6 \u2228X) \u2227 Y ) \u2192 \u00b5\u03b2 n ((\u03c6\u2193R \u2228X) \u2227 Y )\n\u2022 If the Closure rule is applied on \u03b1, using \u03c6 and \u00ac\u03c6:\n\u03bd\u03b1 n ((\u03c6 \u2228X) \u2227 (\u00ac\u03c6 \u2228 Y ) \u2227 Z) \u2192 (\u00ac\u03c6 \u2228 Y ) \u00b7 (\u03c6 \u2228X) \u00b7 (X \u2228 Y )\n\u00b5\u03b1 n ((\u03c6 \u2228X) \u2227 (\u00ac\u03c6 \u2228 Y ) \u2227 Z) \u2192 (X \u2228 Y )\n\u2022 If \u2227-Decomposition is applied on \u03b1, yielding a child \u03b2:\n\u03bd\u03b1 n (((\u03c61 \u2227 \u03c62) \u2228X) \u2227 Y ) \u2192 \u03bd \u03b2 n ((\u03c61 \u2228X) \u2227 (\u03c62 \u2228X) \u2227 Y )\n\u00b5\u03b1 n (((\u03c61 \u2227 \u03c62) \u2228X) \u2227 Y ) \u2192 \u00b5 \u03b2 n ((\u03c61 \u2228X) \u2227 (\u03c62 \u2228X) \u2227 Y )\n\u2022 If \u2228-Decomposition is applied on \u03b1 using a formula \u03c6\u2228\u03c8 and yielding two children \u03b21 and \u03b22:\n\u03bd\u03b1 n (((\u03c61\u2228\u03c62)\u2228X)\u2227Y ) \u2192 \u03bd \u03b21 n ((\u03c61\u2228(\u03c62\u2228X))\u2227Y )\u00b7\u03bd \u03b22 n (\u00b5\u03b21 n ((\u03c61\u2228(\u03c62\u2228X))\u2227Y )\u2227Y )\n\u00b5\u03b1 n (((\u03c61 \u2228 \u03c62) \u2228X) \u2227 Y ) \u2192 \u00b5 \u03b22 n (\u00b5\u03b21 n ((\u03c61 \u2228 (\u03c62 \u2228X)) \u2227 Y ) \u2227 Y )\n\u2022 If the Purity rule is applied on \u03b1, on a formula \u03c6, yielding a node \u03b2:\n\u03bd\u03b1 n ((\u03c6 \u2228X) \u2227 Y ) \u2192 \u03bd\u03b2 n (Y ) \u00b5\u03b1 n ((\u03c6 \u2228X) \u2227 Y ) \u2192 \u00b5\u03b2 n (Y )\n\u2022 If the Loop Detection rule is applied on \u03b1, using a layer \u03b2:\n\u03bd\u03b1 n (X) \u2192 \u03bd\u03b2 n (X) \u00b5\u03b1 n (X) \u2192 \u00b5\u03b1 n (X)\n\u2022 If the Explosion rule is applied on \u03b1, yielding two children \u03b21 and \u03b22, corresponding to the cases n \u2190 0 and n \u2190 n+ 1 respectively:\n\u03bd\u03b10 (X) \u2192 \u03bd \u03b21 0 (X) \u03bd \u03b1 n+1(X) \u2192 \u03bd \u03b21 n (X) \u00b5 \u03b1 0 (X) \u2192 \u00b5 \u03b22 0 (X) \u00b5 \u03b1 n+1(X) \u2192 \u00b5 \u03b22 n (X)\n\u2738\nNote that all the symbols \u03c6, \u03c61,\u03c62 denote meta-variables, and not \u2206- variables (hence they cannot be instantiated during rewriting, in contrast to X , Y ,. . . ).\nBefore establishing the properties of R(T ), we show an example of application:\nExample 12 Consider the proof tree of Example 7. The reader can check that R(T ) contains the following rules:\n\u03bd1n ((p0 \u2228X) \u2227 (\u00acp0 \u2228 Y ) \u2227 Z) \u2192 (p0 \u2228X) \u00b7 (\u00acp0 \u2228 Y ) \u00b7 (X \u2228 Y ) \u00b51n((p0 \u2228X) \u2227 (\u00acp0 \u2228 Y ) \u2227 Z) \u2192 X \u2228 Y \u03bd2n ((pn+1 \u2228X) \u2227 (\u00acpn+1 \u2228 Y ) \u2227 Z) \u2192 (pn+1 \u2228X) \u00b7 (\u00acpn+1 \u2228 Y ) \u00b7 (X \u2228 Y ) \u00b52n((pn+1 \u2228X) \u2227 (\u00acpn+1 \u2228 Y ) \u2227 Z) \u2192 X \u2228 Y \u03bd3n (X) \u2192 \u03bd 7 n (X) \u00b53n(X) \u2192 \u00b5 7 n(X) \u03bd4n ((\u00acpn+1 \u2228X) \u2227 Y ) \u2192 \u03bd 3 n (Y ) \u00b54n((\u00acpn+1 \u2228X) \u2227 Y ) \u2192 \u00b5 3 n(Y ) \u03bd5n (((\u00acpn \u2228 pn+1) \u2228X) \u2227 Y ) \u2192 \u03bd 2 n (((pn+1) \u2228 (\u00acpn \u2228X)) \u2227 Y )\n\u00b7\u03bd4n (\u00b5 2 n((pn+1 \u2228 (\u00acpn \u2228X)) \u2227 Y ) \u2227 Y )\n\u00b55n(((\u00acpn \u2228 pn+1) \u2228X) \u2227 Y ) \u2192 \u00b5 4 n(\u00b5 2 n((pn+1 \u2228 (\u00acpn \u2228X)) \u2227 Y ) \u2227 Y ) \u03bd6n ((\u03c5n+1 \u2228X) \u2227 Y ) \u2192 \u03bd 5 n (((\u00acpn \u2228 pn+1) \u2228X) \u2227 \u03c5n \u2227 Y ) \u00b56n((\u03c5n+1 \u2228X) \u2227 Y ) \u2192 \u00b5 5 n(((\u00acpn \u2228 pn+1) \u2228X) \u2227 \u03c5n \u2227 Y ) \u03bd70(X) \u2192 \u03bd 1 0(X) \u00b570(X) \u2192 \u00b5 1 0(X) \u03bd7n+1(X) \u2192 \u03bd 6 n (X) \u00b57n+1(X) \u2192 \u00b5 6 n(X)\nThe \u2206-expression \u03bd7 n ((p0 \u2228\u22a5)\u2227 (\u00acpn \u2228\u22a5)\u2227 (\u03c5n \u2228\u22a5)) denotes a refutation of p0\u2227\u00acpn\u2227\u03c5n. This rewrite system is complex and hardly readable, fortunately it can be simplified by instantiating the arguments when possible and by statically evaluating the derivations that do no depend on the value of the parameter n. For instance the \u2206-symbol \u03bd7\nn is only called on the formula Tn = (p0 \u2228 \u22a5) \u2227\n(\u00acpn \u2228 \u22a5) \u2227 (\u03c5n \u2228 \u22a5). Thus the rule \u03bd 7 n (X) \u2192 \u03bd10(X) may be simplified by instantiating X by T0 and evaluating the right-hand side: \u03bd 7 0(T0) \u2192 p0 \u00b7 \u00acp0 \u00b7 \u22a5\nSimilarly, the rule \u03bd7 n+1(X) \u2192 \u03bd 6 n (X) can be replaced by the following rule (in this case only a partial evaluation is possible since some parts of the derivation depend on the value of n): \u03bd7\nn+1(Tn+1) \u2192 (\u00acpn \u2228 pn+1) \u00b7 \u00acpn+1 \u00b7 \u00acpn \u00b7 \u03bd 7 n (Tn)\nThe obtained system (only containing the two previous rules) is obviously much simpler than the original one, in particular it is propositional (no schema variables occur in it). To improve readability, the expression \u03bd7\nn (Tn) could be\nsimply replaced by a fresh symbol \u03bd7 \u2032\nn (with no argument). \u2663\nWe define the following relation \u227aT on the nodes in a tableau T .\nDefinition 13 Let T be a tableau. \u227aT is the least transitive relation such that \u03b1 \u227aT \u03b2 if one of the following conditions hold:\n1. Either \u03b1 is a child of \u03b2, but \u03b1 does not correspond to the \u201cn \u2190 n + 1\u201d branch of an Explosion rule. This is written \u03b1 \u227a1T \u03b2.\n2. Or the Loop Detection rule has been applied on the node \u03b2, using the layer \u03b1. This is written \u03b1 \u227a2T \u03b2. \u2738\nProposition 14 Let T be a tableau. \u227aT is a strict partial order.\nProof. By definition, T has been obtained by a sequence of application of the Expansion rules in Section 2. If \u03b1 and \u03b2 are two non-leaf nodes in T , we write \u03b1\u2701\u03b2 if the expansion rule on \u03b1 has been applied before the one of \u03b2 during this derivation, in chronological order (of course several derivations are possible, we choose one of them arbitrarily). \u2701 is obviously an ordering. Furthermore, if we have \u03b1 \u227a2T \u03b2 then by the application condition of the Loop Detection rule we must have \u03b1 \u2701 \u03b2, since when the rule is applied on \u03b2 the node \u03b1 cannot be a leaf, thus an expansion rule must already have been applied on it.\nAssume that \u227aT is not an ordering. By definition \u227aT is transitive, thus it must be reflexive, i.e. there is a node \u03b1 such that \u03b1 \u227aT \u03b1. By definition of \u227aT this means that there exists a sequence of nodes \u03b21, . . . , \u03b2k such that \u03b21 = \u03b2k = \u03b1 and for every i \u2208 [1, k\u2212 1], \u03b2i \u227a \u01eb T \u03b2i+1 (with \u01eb = 1, 2). If for every i \u2208 [1, k \u2212 1] we have \u03b2i \u227a 1 T \u03b2i+1 then for all i \u2208 [1, k \u2212 1] \u03b2i is a child of \u03b2i+1 which implies that there is a (non trivial) path in the tableau from \u03b1 to \u03b1. This is impossible. Thus there is at least one node \u03b2i+1 such that the Loop Detection rule is applied on \u03b2i+1. W.l.o.g. we can assume that i + 1 = k. If for every i \u2208 [1, k\u2212 1] we have \u03b2i \u227a 2 T \u03b2i+1 we have \u03b2i\u2701\u03b2i+1, hence by transitivity \u03b1\u2701\u03b1, which is impossible. Let j the greatest index in [1, k\u2212 1] such that \u03b2j 6\u227a 2 T \u03b2j+1. We have \u03b2j \u227a 1 T \u03b2j+1 \u227a 2 T \u03b2j+2 \u227a 2 T . . . \u227a 2 T \u03b2k.\nSince \u03b2j+1 \u227a 2 T \u03b2j+2, \u03b2j+1 must be a layer, thus the only rule that can be applied on \u03b2j+1 is the Explosion rule. Since \u03b2j \u227a 1 T \u03b2j+1 \u03b2j cannot correspond to the branch n \u2190 n + 1 of the Explosion rule. Thus it corresponds to the branch n \u2190 0. But then the nodes \u03b2j , \u03b2j\u22121, . . . , \u03b21 cannot possibly contain n (since no rule can introduce an occurrence of n in the tableau, and since by the application condition, the Loop Detection rule cannot be applied between a leaf not containing n and a layer containing n). Since \u03b21 = \u03b2k this means that \u03b2k, . . . , \u03b2j+1 contains no occurrence of n. But in this case the Explosion rule cannot be applied on \u03b2j+1, a contradiction.\nLemma 15 Let T be a tableau. R(T ) is convergent.\nProof. We extend the ordering \u227aT to the \u2206-symbols as follows: \u03bd \u03b1 \u227aT \u03bd \u03b2 and \u00b5\u03b1 \u227aT \u00b5 \u03b2 if \u03b1 \u227aT \u03b2. By definition of \u227aT , it is easy to check that all the rules above \u2013 except the n+1-rewrite rule corresponding to the Explosion rule \u2013 strictly decrease the value of the symbols \u03bd\u03b1 and \u00b5\u03b1. Furthermore, they do not increase the value of the indices. The Explosion rule may increase the value of these symbols but strictly decreases their indices. Thus termination is obvious. Confluence is immediate: indeed, since each node is labeled by a set (and not a multiset), the system is necessarily orthogonal (note that we assume that the semantic properties of the logical connectives are not taken into account for the matching, except the AC-properties of the \u2227 occurring at root level).\nFor any \u2206-expression T , we denote by T \u2193R(T ) the normal form of T . We now state the soundness of our algorithm.\nLemma 16 states that the rewrite system R(T ) indeed fulfils the desired property.\nLemma 16 Let T be a closed tableau. Let \u03b1 be a node in T . Let k \u2208 N. Let T (\u03b1) = {\u03c61, . . . , \u03c6n}. Let X1,. . . ,Xn be a set of pairwise distinct variables in V. Let U = (\u03c61 \u2228X1)\u2227 . . .\u2227 (\u03c6n \u2228Xn). Then \u03bd \u03b1 k (U)\u2193R(T ) is a derivation from U\u2193R of \u00b5 \u03b1(U)\u2193R(T ).\nProof. The proof is by induction on the pair (\u03b1, k), using the lexicographic extension of the ordering \u227aT on the nodes in T and of the usual ordering on natural numbers (this ordering is obviously well-founded since T is finite). We distinguish several cases, according to the expansion rule that is applied on \u03b1.\n\u2022 If no rule is applied on \u03b1 then T (\u03b1) must contain \u22a5. W.l.o.g., we assume that \u03c61 = \u22a5. By Definition 11, we have \u03bd \u03b1 k (U) \u2193R(T )= X1 and\n\u00b5\u03b1(U)\u2193R(T )= X1, thus the proof is immediate (since X1 is obviously a derivation of X1).\n\u2022 If the closure rule is applied on \u03b1 then T (\u03b1) must contain two schemata \u03c8 and \u00ac\u03c8. W.l.o.g., we assume that \u03c61 = \u03c8 and \u03c62 = \u00ac\u03c8. By Definition 11, we have \u03bd\u03b1k (U)\u2193R(T )= (\u03c8 \u2228X1) \u00b7 (\u00ac\u03c8 \u2228X2) \u00b7 (X1 \u2228X2) and \u00b5\n\u03b1(U)\u2193R(T )= (X1\u2228X2) hence the proof is completed, since (\u03c8\u2228X1)\u00b7(\u00ac\u03c8\u2228X2)\u00b7(X1\u2228X2) is a derivation of X1 \u2228X2.\n\u2022 Assume that \u2227-Decomposition is applied on a schema \u03c81 \u2227 \u03c82. W.l.o.g., we assume that \u03c61 = (\u03c81 \u2227 \u03c82). Let \u03b2 be the child of \u03b1. Let U\n\u2032 = (\u03c62 \u2228X2) \u2227 . . . \u2227 (\u03c6n \u2228Xn), i.e. we have U = ((\u03c81 \u2227 \u03c82) \u2228X1) \u2227 U \u2032. By Definition 11, we have \u03bd\u03b1k (U)\u2193R(T )= \u03bd \u03b2 k ((\u03c81 \u2228X1)\u2227 (\u03c82 \u2227X2)\u2227U\n\u2032)\u2193R(T ) and \u00b5\u03b1(U)\u2193R(T )= \u00b5 \u03b2((\u03c81 \u2228 X1) \u2227 (\u03c82 \u2227 X2) \u2227 U \u2032)\u2193R(T ). Thus, by the induction hypothesis, \u03bd\u03b1k ((\u03c81 \u2228X1) \u2227 (\u03c82 \u2228X2) \u2227 U)\u2193R(T ) is a derivation from (\u03c81 \u2228X1) \u2227 (\u03c82 \u2227X2) \u2227 U \u2032\u2193R of \u00b5 \u03b2(U)\u2193R(T )= \u00b5 \u03b1(U)\u2193R(T ). Hence it is also a derivation from U\u2193R since U and (\u03c81 \u2228X1) \u2227 (\u03c82 \u2227X2) \u2227 U \u2032 share the same clausal forms.\n\u2022 Assume that \u2228-Decomposition is applied on a schema \u03c81 \u2228 \u03c82. W.l.o.g., we assume that \u03c61 = (\u03c81 \u2228 \u03c82). Let \u03b21 and \u03b22 be the children of \u03b1 (corresponding to the schemata \u03c81 and \u03c82 respectively). Let U\n\u2032 = (\u03c62 \u2228 X2) \u2227 . . . \u2227 (\u03c6n \u2228 Xn), i.e. we have U = ((\u03c81 \u2228 \u03c82) \u2228 X1) \u2227 U \u2032. By Definition 11, we have \u03bd\u03b1k (U)\u2193R(T )= \u03bd \u03b21 k (U)\u2193R(T ) \u00b7\u03bd \u03b22 k (\u00b5 \u03b21 k (U)\u2227U\n\u2032)\u2193R(T ) and \u00b5\u03b1k (U)\u2193R(T )= \u00b5 \u03b22 k (\u00b5 \u03b21 k (U) \u2227 U \u2032)\u2193R(T ). By the induction hypothesis, \u03bd\u03b21k (U)\u2193R(T ) is a derivation from U \u2193R of \u00b5 \u03b21 k (U) \u2193R(T ). Then, again by the induction hypothesis, \u03bd \u03b22 k (\u00b5 \u03b21 k (U) \u2227 U \u2032)\u2193R(T ) is a derivation from \u00b5 \u03b21 k (U) \u2227 U \u2032\u2193R of \u00b5 \u03b22(\u00b5\u03b21k (U) \u2227 U\n\u2032)\u2193R(T ) i.e. of \u00b5\u03b1k (U)\u2193R(T ). Consequently, \u03bd \u03b1 k (U)\u2193R(T ) is a derivation from U\u2193R of \u00b5\u03b1k (U)\u2193R(T ).\n\u2022 Assume that the Loop Detection rule is applied on \u03b1, using a node \u03b2. R(T ) contains the rule \u03bd\u03b1\nn (X) \u2192 \u03bd\u03b2 n (X) and \u00b5\u03b1 n (X) \u2192 \u00b5\u03b1 n (X). Then the\nproof is straightforward, by the induction hypothesis.\n\u2022 Assume that the Purity rule is applied on \u03b1, yielding a node \u03b2. Since T (\u03b1) \u2283 T (\u03b2), the proof is immediate (a derivation from a set S is also a derivation from S \u222a S\u2032).\n\u2022 Assume that Explosion is applied on \u03b1, yielding two nodes \u03b21 and \u03b22 (corresponding respectively to the case n \u2190 0 and n \u2190 n + 1). We distinguish two cases, according to the value of k.\n\u2013 If k = 0 then we have \u03bd\u03b1k (U)\u2193R(T )= \u03bd \u03b21 0 (U)\u2193R(T ) and \u00b5 \u03b1 k (U)\u2193R(T )=\n\u00b5 \u03b21 0 (U)\u2193R(T ). By the induction hypothesis, \u03bd \u03b21 0 (U)\u2193R(T ) is a derivation from U of \u00b5\u03b210 (U)\u2193R(T ) hence the proof is completed.\n\u2013 If k > 0 then \u03bd\u03b1k (U) \u2193R(T )= \u03bd \u03b21 k\u22121(U) \u2193R(T ) and \u00b5 \u03b1 k (U) \u2193R(T )=\n\u00b5 \u03b21 k\u22121(U) \u2193R(T ). By the induction hypothesis, \u03bd \u03b21 k\u22121(U) \u2193R(T ) is a derivation from U of \u00b5\u03b21k\u22121(U)\u2193R(T ) hence the proof is completed.\nNote that (contrarily to all the other cases) we may have \u03b21 \u227bT \u03b1, but we are using the induction hypothesis on \u03bd\u03b21k\u22121. This is possible since k \u2212 1 < k.\nFurthermore, we have the following:\nLemma 17 Let T be a closed tableau. Let \u03b1 be a node in T . Let T (\u03b1) = {\u03c61, . . . , \u03c6n}. \u00b5\n\u03b1((\u03c61 \u2228X1)\u2227 . . .\u2227 (\u03c6n \u2228Xn))\u2193R(T ) is a disjunction of formul\u00e6 in X1, . . . , Xn.\nProof. By an immediate induction on \u00b5\u03b1k .\nThus in the case in which X1 = . . . Xn = \u22a5, \u03bd \u03b1 k (\u03a6) denotes a refutation of T (\u03b1), which entails the following theorem, showing the soundness of our algorithm (and entailing in particular the completeness of the tableau calculus).\nTheorem 18 Let T be a closed tableau containing a node \u03b1. Let n be the parameter of T (\u03b1). Let T (\u03b1) = {\u03c61, . . . , \u03c6n} and let \u03a6 = (\u03c61\u2228\u22a5)\u2227. . .\u2227(\u03c6n\u2228\u22a5).\nFor any k \u2208 N, \u03bd\u03b1k (\u03a6{n \u2190 k})\u2193R(T ) is a refutation of \u03a6{n \u2190 k}\u2193R. Thus T (\u03b1) is unsatisfiable.\nProof. By Lemma 16, \u03bd\u03b1k (\u03a6{n \u2190 k})\u2193R(T ) is a derivation from \u03a6{n \u2190 k}\u2193R (hence also from \u03a6{n \u2190 k} \u2193R) of \u00b5 \u03b1 k (\u03a6{n \u2190 k}) \u2193R(T ). By Lemma 17, \u00b5\u03b1k (\u03a6{n \u2190 k})\u2193R(T )= \u22a5.\nNote that the size of the rewrite system R(T ) is clearly linear w.r.t. the one of the tableau T .\nThe simplification phase used in Example 12 can be applied in a systematic way. However, it is not always sufficient to reduce the rewrite system into a propositional one. Actually, it is not difficult to see that as soon as a node \u03b1 exists in the tableau on which the \u2228-Decomposition rule is applied, yielding two branches \u03b21 and \u03b22 that are both looping on an ascendant of \u03b1, then the use of schema variables cannot be avoided.\nExample 19 Consider for instance the schema: \u03c6 : \u00acp0 \u2227 \u00acq0 \u2227 (pn \u2228 qn) \u2227 \u03c5n, where \u03c5 is defined by the rules: \u03c5i+1 \u2192 (qi \u2228 \u00acpi+1) \u2227 (pi \u2228 \u00acqi+1) \u2227 \u03c5i and \u03c50 \u2192 \u22a4. The following tableau is constructed:\n\u03c6\npn\np0\n\u22a5\npn+1\nqn\n\u22a5 (loop)\n\u00acpn+1\n\u22a5\nqn\nq0\n\u22a5\nqn+1\npn\n\u22a5 (loop)\n\u00acqn+1\n\u22a5\nThe corresponding rewrite system (after partial evaluation and simplification) is the following (\u03bd1\nn corresponds to the refutation of \u03c6):\n\u03bd1n (\u00acp0 \u2227 \u00acq0 \u2227 (pn \u2228 qn) \u2227 \u03c5n) \u2192 \u03bd2n (\u00acp0 \u2227 \u00acq0 \u2227 (pn \u2228 qn) \u2227 \u03c5n) \u00b7 \u03bd 3 n (\u00acp0 \u2227 \u00acq0 \u2227 qn \u2227 \u03c5n) \u03bd20(\u00acp0 \u2227 (p0 \u2228X) \u2227 Y ) \u2192 \u00acp0 \u00b7 (p0 \u2228X) \u00b7X \u03bd2n+1(\u00acp0 \u2227 \u00acq0 \u2227 (pn+1 \u2228X) \u2227 \u03c5n+1) \u2192\n(pn+1 \u2228X) \u00b7 (qn \u2228 \u00acpn+1) \u00b7 (qn \u2228X) \u00b7 \u03bd 3 n (\u00acp0 \u2227 \u00acq0 \u2227 (qn \u2228X) \u2227 \u03c5n)\n\u03bd30(\u00acp0 \u2227 (q0 \u2228X) \u2227 Y ) \u2192 \u00acq0 \u00b7 (q0 \u2228X) \u00b7X \u03bd3n+1(\u00acp0 \u2227 \u00acq0 \u2227 (qn+1 \u2228X) \u2227 \u03c5n+1) \u2192\n(qn+1 \u2228X) \u00b7 (pn \u2228 \u00acqn+1) \u00b7 (pn \u2228X) \u00b7 \u03bd 2 n (\u00acp0 \u2227 \u00acq0 \u2227 (pn \u2228X) \u2227 \u03c5n)\nThe system still contains \u2206-variables, although some of them have been removed by static evaluation. Note that it could be further simplified (for instance by moving the axioms such as \u00acp0 outside the inductive definitions), but the use of \u2206-variables cannot be avoided. \u2663\nWe now focus on an alternative approach that has the advantage that only propositional rewrite systems are generated."}, {"heading": "4 Globally looping tableaux", "text": "Compared to the previous approach, the second algorithm generates much simpler rewrite systems, but it has the drawback that a more restrictive version of the Loop Detection rule must be used to prune the tableaux into finite ones. At a very high and informal level: in the first approach, we were building mutually inductive proofs of several lemmata, whereas, in the second approach, we manage to have one single invariant proved by a single induction.\nWe first need to introduce some additional terminology. A node \u03b1 is of rank k in a tableau T of root \u03b2 if there are exactly k applications of the Explosion rule between \u03b2 and \u03b1 (including \u03b2, but not \u03b1). Leaves(T , \u03b1) denotes the set of non-closed leaves below \u03b1 in T , Layers(T , k) denotes the set of layers of rank k\nin T and Layers(T , k, \u03b1) denotes the set of layers of rank k in T that occur below \u03b1. For any set of formul\u00e6 \u03a6, we denote by \u2227 \u03a6 the conjunction \u2227 \u03c6\u2208\u03a6 \u03c6. If T is a tableau and N is a set of nodes in T , then T [N ] denotes the disjunction\u2228 \u03b1\u2208N \u2227 T (\u03b1). We write cnf(\u03c6) for a (subsumption-minimal) clausal form of \u03c6\u2193R.\nDefinition 20 A tableau T is globally looping (w.r.t. two natural numbers k and n) iff the following conditions hold:\n1. n < k.\n2. T [Layers(T , k)] = T [Layers(T , n)] (modulo AC and idempotence).\n3. All non-closed leaves in T are of a rank greater or equal to k.\nThen the Global Loop Detection rule closes every node in Layers(T , k). \u2738\nBy definition, after the Global Loop Detection rule is applied, all branches containing the parameter n are closed and the construction of the tableau is over (since no leaf can be expanded anymore). Note that the Global Loop Detection rule can be simulated by several applications of the Loop Detection rule introduced in Section 2. Indeed, assume that a pair of natural numbers (k, n) satisfying the conditions of Definition 20 exists. Then, by Condition 2, for every layer \u03b1 of rank k, there exists a layer \u03b2 of rank n such that T (\u03b1) = T (\u03b2). Thus the Loop Detection rule applies on \u03b1 (w.l.o.g. we assume that the layers of rank n are constructed before those of rank k in all parallel branches, which is possible since n < k). However, it is easy to see that the converse does not hold: the Global Loop Detection rule is strictly less general than the looping rule. It is, however, powerful enough to ensure termination, provided that a fair strategy is used to expand the tableau, as stated by the following theorem:\nTheorem 21 Let (Ti)i\u2208N be an infinite sequence of tableaux such that, for every i \u2208 N, Ti+1 is obtained from Ti by applying one of the Expansion rules of Section 2, other than the Loop Detection rule. Assume, moreover, that for every k \u2208 N, there exists n \u2208 N such that every non-closed leaf in Tn is of a rank greater than k (i.e. no branch is indefinitely \u201cfrozen\u201d, the rank of the leaves increases indefinitely). There exists n \u2208 N such that Tn is globally looping.\nProof. We have shown (see the proof of Theorem 5) that the number of sets Ti(\u03b1) where \u03b1 is a leaf in Ti is finite. Thus the set of sets of nodes {Ti(\u03b1) | \u03b1 \u2208 Layers(Ti, n)} is also finite. Let k be a natural number that is strictly greater than the cardinality of this set. By the hypothesis of the theorem, there exists n \u2208 N such that every leaf in Tn is of a rank greater than k. By the pigeonhole argument, there exist two natural numbers n\u2032 < k\u2032 such that T [Layers(Tn, n \u2032)] = T [Layers(Tn, k \u2032)]. Then Tn is globally looping.\nWe now show that from every tableau T , one can extract a resolution derivation from the root of T of the disjunction of the leaves of T . We first restrict ourselves to tableaux built without the Explosion and Loop Detection rules. We\nfocus on such tableaux because they correspond to the subtrees that are found \u201cbetween\u201d two layers in an tableau built without restriction on the rules. More precisely, take a layer \u03b1 of some rank m in a tableau T (built without restriction on the rules). Then the subtree of T of root \u03b1 and whose leaves are the layers of rank m+1 below \u03b1 is indeed a tree built without Explosion nor Loop Detection (by definition of a layer).\nWe first build derivations for such subtrees, those derivations will then be used as the base elements for building the final schema of refutation. For such a tree T and a node \u03b1 of T , the next definition introduces \u2206(T , \u03b1), which is intended to be a derivation of cnf(T [Leaves(T , \u03b1)]) from cnf(T (\u03b1)).\nDefinition 22 Let T be a tableau constructed using the Expansion rules, except the Explosion and Loop Detection rules. Let \u03b1 be a node in T . We define a derivation \u2206(T , \u03b1) inductively, according to the rule that is applied on \u03b1:\n\u2022 If \u03b1 is a leaf, then \u2206(T , \u03b1) is defined as the sequence of clauses in cnf(T (\u03b1)).\n\u2022 If the Closure rule is applied on \u03b1, using two formul\u00e6 \u03c6 and \u00ac\u03c6, then\n\u2206(T , \u03b1) def\n= \u03c6 \u00b7 \u00ac\u03c6 \u00b7 \u22a5 (notice that since the formul\u00e6 are in NNF, \u03c6 must be an atom).\n\u2022 If the Normalisation, Purity or \u2227-Decomposition rule is applied on \u03b1,\nyielding a node \u03b2 then \u2206(T , \u03b1) def = \u2206(T , \u03b2).\n\u2022 Finally, assume that the \u2228-Decomposition rule is applied on \u03b1 yielding two nodes \u03b21 and \u03b22. Let \u03a61 and \u03a62 be the clausal forms of \u03c61 and \u03c62 respectively. For any C \u2208 \u03a62, let \u039b\n\u2032(C) be the derivation obtained from \u2206(T , \u03b21) by replacing every occurrence of a clause D \u2208 \u03a61 by D\u2228C (and by adding the disjunction \u2228C to every descendant of D).\nFor any clause C\u2032 in cnf(T [Leaves(T , \u03b21)]), we construct a derivation \u039b\u2032\u2032(C\u2032) from \u2206(T , \u03b22) by replacing every occurrence of a clause D \u2208 \u03a62 by D \u2228C\u2032 (and by adding the disjunction \u2228C\u2032 to every descendant of D). Then \u2206(T , \u03b1) is the concatenation of all the derivations \u039b\u2032(C) and \u039b\u2032\u2032(C\u2032) (with C \u2208 \u03a62 and C \u2032 \u2208 cnf(T [Leaves(T , \u03b21)])).\nOnly the case of disjunction is non-trivial. Informally, it does nothing more than building, for two sets of clauses S1 and S2, a derivation of cnf(S1 \u2228 S2) from two derivations of S1 and S2.\nThe following lemma states that \u2206(T , \u03b1) satisfies the desired property:\nLemma 23 Let T be a tableau, constructed by using the previous expansion rules, except the Explosion and Loop Detection rules. For all nodes \u03b1 in T , \u2206(T , \u03b1) is a derivation of cnf(T [Leaves(T , \u03b1)]) from cnf(T (\u03b1)).\nProof. The proof is by induction on the depth of T . We distinguish several cases, according to the rule applied on \u03b1.\n\u2022 If \u03b1 is a leaf then Leaves(T , \u03b1) = {\u03b1}. Moreover, according to Definition 22, \u2206(T , \u03b1) is the sequence of formul\u00e6 in cnf(T (\u03b1)), thus the proof is completed.\n\u2022 If the Normalisation or \u2227-Decomposition rule is applied on \u03b1, yielding a node \u03b2, then we have cnf(T (\u03b1)) = cnf(T (\u03b2)). Moreover, since \u03b1 has only one child, cnf(T [Leaves(T , \u03b1)]) = cnf(T [Leaves(T , \u03b2)]). Hence the proof is immediate, by the induction hypothesis.\n\u2022 If the Purity rule is applied on \u03b1, using a formula \u03c6, yielding a node \u03b2, then by the induction hypothesis, \u2206(T , \u03b2) is a derivation of cnf(T [Leaves(T , \u03b2)]) from cnf(T (\u03b2)). Since \u03b1 has only one child, cnf(T [Leaves(T , \u03b1)]) = cnf(T [Leaves(T , \u03b2)]). Furthermore, cnf(T (\u03b1)) is of the form \u03c6\u2227cnf(T (\u03b2)) thus \u2206(T , \u03b2) is also a derivation from cnf(T (\u03b1)). Since, by Definition 22, \u2206(T , \u03b1) = \u2206(T , \u03b2), the proof is completed.\n\u2022 Finally, assume that the Disjunction rule is applied on \u03b1, using a formula \u03c61\u2228\u03c62. This yields two nodes \u03b21 and \u03b22, corresponding respectively to \u03c61 and \u03c62. Let \u03a61 and \u03a62 be a cnf of \u03c61 and \u03c62 respectively. By definition, cnf(T [Leaves(T , \u03b1)]) is the clausal form of the disjunction of cnf(T [Leaves(T , \u03b21)]) and cnf(T [Leaves(T , \u03b22)]), hence every clause occurring in cnf(T [Leaves(T , \u03b1)]) is of the form C1 \u2228 C2 where Ci occurs in cnf(T [Leaves(T , \u03b2i)]) (i = 1, 2). By the induction hypothesis \u2206(T , \u03b21) is a derivation of cnf(T [Leaves(T , \u03b21)]) from cnf(T (\u03b21)). Thus in particular, for every C \u2208 \u03a62, \u039b\n\u2032(C) (see Definition 22 for the notations) is a derivation from cnf(T (\u03b1)) of either C1 or C1 \u2228 C. In the first case, the formula \u03c61 is not needed for deriving C1, thus actually, C1 also occurs in cnf(T [Leaves(T , \u03b22)]). Since C1 \u2228 C2 is subsumption-minimal, we must have actually C1 = C2 and the proof is completed. In the second case, by the induction hypothesis \u2206(T , \u03b22) is a derivation of C2 from cnf(T (\u03b22)), thus \u039b\u2032\u2032(C1) is a derivation of C1\u2228C2 from cnf(T (\u03b1))\u222a{C1\u2228D | D \u2208 \u03a62}. Hence \u2206(T , \u03b1) is a derivation of C1 \u2228 C2 from cnf(T (\u03b1)).\nThus the function T (\u03b1) \u2192 \u2206(T , \u03b1) allows us to build derivations from subtrees of a whole tableau. Intuitively, the next step is to put together those derivations according to the positions of the corresponding subtrees in the main tableau. Consider a rank m in a tableau T . One can apply the function \u2206 to all the (parallel) subtrees whose root is a layer of rank m. Then we can do the same at rank m + 1, append every resulting derivation to the derivation obtained from the parent tree, and go on at rank m + 2, etc. This intuitively gives the structure of a rewrite system where n decreases each time we go to the next rank. However this gives us a tree-like structure (to every derivation corresponding to a subtree U we append the derivations corresponding to all the leaves of U , and go on with the trees below those leaves) similar to the rewrite systems presented in Section 3. Instead we would like a more linear structure. So we will consider at once all the layers of a given rank and get only\none derivation corresponding to those nodes. For this, we need a way to apply \u2206 to all the subtrees at once. This is actually done by building a new tableau from the subtrees.\nLet T be a tableau of root \u03b1. Assume that T is globally looping w.r.t. n and k, with n < k. Let m < k. We denote by U(T ,m) a tableau whose root is labeled by a formula T [Layers(T ,m)] (note that we take all the layers of rankm at a time), and obtained by applying the \u2228 and \u2227-Decomposition and Closure rules (and only these rules) until irreducibility. By definition, since the root formula of U(T ,m) is the disjunction of the labels of the layers in Layers(T ,m), every non-closed leaf \u03b2 of U(T ,m) is labeled by a set of formul\u00e6 of the form T (\u03b3\u03b2), where \u03b3\u03b2 \u2208 Layers(T ,m). Furthermore, for every \u03b3 \u2208 Layers(T ,m), there exists a leaf \u03b2 of U(T ,m) such that \u03b3\u03b2 = \u03b3. Since m < k and since by Definition 20 the leaves of T must be of a rank greater or equal to k, the node \u03b3\u03b2 cannot be a leaf of T . This implies that some rule is applied on \u03b3\u03b2 . But the only rule that is applicable on a layer (beside the Global Loop Detection rule that cannot be applied on layers of a rank distinct from k) is the Explosion rule. Hence T necessarily contains two subtableaux, written T 0\u03b2 and T 1 \u03b2 , of roots T (\u03b3\u03b2){n \u2190 0} and T (\u03b3\u03b2){n \u2190 n + 1} respectively. Then V 0(T ,m) and V1(T ,m) denote respectively the tableaux obtained from U(T ,m){n \u2190 0} and U(T ,m){n \u2190 n+ 1} by:\n\u2022 Replacing every leaf \u03b2 by T 0\u03b2 and T 1 \u03b2 respectively.\n\u2022 Removing, in the obtained tableau, all applications of the Explosion rule3\n(and all the nodes that occur below such an application).\nBy definition, the leaves of V0(T ,m) and V1(T ,m) are layers. They correspond either to the leaves of T or to the nodes in T on which Explosion is applied (these nodes are of rank m+ 1 in T ).\nProposition 24 Let T be a tableau that is globally looping w.r.t. two numbers n < k. Let m < k. For any non closed leaf \u03b2 of U(T ,m), T 0\u03b2 is closed and Layers(T 1\u03b2 , 0) = Layers(T ,m+ 1, \u03b3\u03b2).\nProof. By definition, all leaves not containing n in T must be closed. Thus T 0\u03b2 is closed. Furthermore, by definition, the layers of rank 0 in T 1 \u03b2 are the first layers of every branch, i.e. the first layer after \u03b3\u03b2 in T . Since \u03b3\u03b2 is a layer of rank m in T , such layers are of rank m+ 1.\nCorollary 25 Let T be a tableau that is globally looping w.r.t. two numbers n < k. Let m < k. Let \u03b2 and \u03b2\u2032 be the roots of V0(T ,m) and V1(T ,m) respectively. cnf(T [Leaves(V0(T ,m), \u03b2)]) = \u22a5 and cnf(T [Leaves(V1(T ,m), \u03b2)]) = cnf(T [Layers(T ,m+ 1)]).\n3Note that, although no application of the Explosion rule occurs in U(T , m), some applications of this rule may occur in T 1\n\u03b2 .\nProof. The first point stems directly from Proposition 24. For the second point, we only have to remark that by definition a node occurs in Layers(T ,m+ 1) iff it occurs in some set Layers(T ,m + 1, \u03b3\u03b2), where \u03b2 is a leaf of U(T ,m) (since the leaves of U(T ,m) are exactly the layers of rank m in T ).\nBy applying the above function \u2206(T , \u03b1) on the two tableaux V1(T ,m) and V0(T ,m), we define the following derivations (where \u03b1 denotes the root of V1(T ,m) and V0(T ,m)):\n\u039b1(T ,m) def = \u2206(V1(T ,m), \u03b1) \u039b0(T ,m) def = \u2206(V0(T ,m), \u03b1)\nThe following lemma states essential properties of \u039b1(T ,m) and \u039b0(T ,m):\nLemma 26 Let T be a tableau that is globally looping w.r.t. two numbers n < k. Let m < k.\n\u2022 \u039b0(T ,m) is a refutation of cnf(T [Layers(T ,m)]){n \u2190 0}.\n\u2022 If m < k\u22121 then \u039b1(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n \u2190 n+ 1} of cnf(T [Layers(T ,m+ 1)]).\n\u2022 \u039b1(T , k \u2212 1) is a derivation from cnf(T [Layers(T ,m)]){n \u2190 n + 1} of cnf(T [Layers(T , n)]).\nProof. Let \u03b2 and \u03b2\u2032 be the roots of V1(T , k) and V0(T , k) respectively. By Lemma 23, \u039b1(T ,m) is a derivation from cnf(V1(T ,m)(\u03b2)) of cnf(T [Leaves(V1(T ,m), \u03b2)]). By definition of V1(T ,m), the root of V1(T ,m) is labeled by \u03a6{n \u2190 n + 1}, where \u03a6 is the root of U(T ,m). By definition of U(T ,m), \u03a6 = T [Layers(T ,m)]. Hence \u039b1(T , k) is a derivation from cnf(T [Layers(T ,m)]){n \u2190 n + 1}. Similarly, \u039b0(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n \u2190 0}.\nBy Corollary 25, cnf(T [Leaves(V1(T ,m), \u03b2)]) = cnf(T [Layers(T ,m + 1)]). Furthermore, if m = k \u2212 1, then since T is globally looping we have cnf(T [Layers(T ,m+ 1)]) = cnf(T [Layers(T , n)]).\nSimilarly, cnf(T [Leaves(V1(T ,m), \u03b2)]) = \u22a5.\nLet T be a tableau that is globally looping w.r.t. two numbers n < k. We associate to each natural number m < k a symbol \u03b3m. Let R\u22c6(T ) the system containing the following rules. Note that V0(T ,m) and V1(T ,m) are defined only w.r.t. the rank m, but not w.r.t. a particular node. Thus, contrarily to the transformation of Section 3, there is not one derivation per node, but rather one derivation per rank.\n\u03b3m0 \u2192 \u039b 0(T ,m) \u03b3mn+1 \u2192 \u039b 1(T ,m) \u00b7 \u03b3m+1n (if m+ 1 < k) \u03b3 k\u22121 n+1 \u2192 \u039b 1(T , k) \u00b7 \u03b3nn\nIntuitively, we are appending the derivations, rank after rank, until we reach the rank k where the Global Loop Detection applies. In this case we get back at\nthe rank of looping n. Thus we can see the use of grouping the derivations by rank (instead of node) as it allows to benefit from the simplified form of looping induced by the Global Loop Detection rule. In the end, the resulting rewrite system is indeed much simpler.\nProposition 27 R\u22c6(T ) is convergent.\nProof. Termination is easy to obtain since the rules inR\u22c6(T ) strictly decreases the value of the indices of the symbols \u03b3k. Furthermore, R\u22c6(T ) is obviously orthogonal.\nNote that, by definition, R\u22c6(T ) is always propositional (unlike R(T )).\nTheorem 28 Let T be a tableau of root \u03b1 that is globally looping w.r.t. two numbers n, k, with n < k. Let m < k. For all i \u2208 N, \u03b3mi \u2193R\u22c6(T ) is a refutation of cnf(T [Layers(T ,m)]){n \u2190 i}\u2193R. Thus in particular, if \u03b1 is a layer, \u03b3 0 i \u2193R\u22c6(T ) is a refutation of T (\u03b1){n \u2190 i}\u2193R.\nProof. This follows by induction on i. If i = 0 then we have, by definition of the rules in R\u22c6(T ): \u03b3mi \u2193R\u22c6(T )= \u039b\n0(T ,m)\u2193R. By Lemma 26 (first point), \u039b0(T ,m)\u2193R is a refutation of cnf(T [Layers(T ,m)]){n \u2190 0}\u2193R.\nIf i > 0 then we have \u03b3mi \u2193R\u22c6(T )= \u039b 1(T ,m) \u2193R {n \u2190 i} \u00b7 \u03b3 m+1 i\u22121 \u2193R\u22c6(T ). If m < k \u2212 1, then by Lemma 26 (second point), \u039b1(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n \u2190 n + 1} of cnf(T [Layers(T ,m + 1)]), hence \u039b1(T , i \u2212 1) \u2193R is a derivation from cnf(T [Layers(T ,m)]){n \u2190 i} \u2193R of cnf(T [Layers(T ,m + 1)]){n \u2190 i \u2212 1} \u2193R. Then by the induction hypothesis, \u03b3m+1i\u22121 \u2193R\u22c6(T ) is a refutation of cnf(T [Layers(T ,m+ 1)])\u03b1{n \u2190 i\u2212 1}\u2193R.\nIfm = k\u22121, then by Lemma 26 (second point), \u039b1(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n \u2190 n+1} of cnf(T [Layers(T , n)]), hence \u039b1(T , i\u22121)\u2193R is a derivation from cnf(T [Layers(T ,m)]){n \u2190 i}\u2193R of cnf(T [Layers(T , n)]){n \u2190 i \u2212 1} \u2193R. Then by the induction hypothesis, \u03b3 n i\u22121 \u2193R\u22c6(T ) is a refutation of cnf(T [Layers(T , n)])\u03b1{n \u2190 i\u2212 1}\u2193R.\nWhen \u03b1 is not a layer, the rewrite system is easily adapted by prepending the derivation obtained by applying \u2206 to the subtree of T whose leaves are the layers of rank 0.\nExample 29 Consider the tableau of Example 19. This tableau is actually globally looping. The following rewrite system is constructed (after partial evaluation and simplification):\n\u03b30 \u2192 p0 \u2228 q0 \u00b7 \u00acp0 \u00b7 q0 \u00b7 \u00acq0 \u00b7 \u22a5 \u03b3n+1 \u2192 (pn+1 \u2228 qn+1) \u00b7 (qn \u2228 \u00acpn+1) \u00b7 (qn \u2228 qn+1) \u00b7 (pn \u2228 \u00acqn+1) \u00b7 (qn \u2228 pn) \u00b7 \u03b3n\nCompared with the system produced by the previous method (see Example 19), these rules are obviously simpler (no schema variable are needed, and only linear recursion is used). Furthermore, it is easy to check that they generate much shorter derivations. \u2663"}, {"heading": "5 Conclusion", "text": "Two distinct algorithms have been designed for extracting schemata of resolution proofs from closed tableaux. This work is motivated by the fact that such refutations are needed for some natural applications of schemata calculus (unsatisfiability detection is not always sufficient). In particular, the explicit generation of the proofs (even in the form of proof schemata) makes possible the certification of the results produced by the provers. The first algorithm tackles the tableau calculus in its full generality, but it yields very complex representations of the derivations (which will make them less usable in practice, in particular they are not very informative for a human user). The second one uses a less powerful calculus, but it generates schemata of refutations in a much simpler format (propositional rewrite systems are obtained).\nThere is thus a natural trade-off between the two presented methods: none of them is uniformly superior to the other. The choice between the two algorithms should be made according to the considered applications, and/or to the form of the constructed tableaux. In some cases, as shown by the examples in Section 3, the first approach generates a propositional rewrite system. In this case it should of course be preferred. Future work includes the implementation of the two methods and the precise evaluation of the complexity of the second algorithm. One could also wonder whether a polynomial algorithm generating propositional derivations exists for the general case. We conjecture that the use of \u2206-variables cannot be avoided in general."}], "references": [{"title": "A schemata calculus for propositional logic", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "TABLEAUX 09 (International Conference on Automated Reasoning with Analytic Tableaux and Related Methods), volume 5607 of LNCS, pages 32\u2013 46. Springer", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2009}, {"title": "A Decidable Class of Nested Iterated Schemata", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "IJCAR 2010 (International Joint Conference on Automated Reasoning), LNCS, pages 293\u2013308. Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Decidability and undecidability results for propositional schemata", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "Journal of Artificial Intelligence Research, 40:599\u2013 656", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Cut-elimination and Redundancy-elimination by Resolution", "author": ["M. Baaz", "A. Leitsch"], "venue": "Journal of Symbolic Computation, 29(2):149\u2013176", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Towards understanding and harnessing the potential of clause learning", "author": ["P. Beame", "H. Kautz", "A. Sabharwal"], "venue": "Journal of Artificial Intelligence Research, 22:319\u2013351", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2004}, {"title": "A simple and flexible way of computing small unsatisfiable cores in SAT modulo theories", "author": ["A. Cimatti", "A. Griggio", "R. Sebastiani"], "venue": "SAT, LNCS, pages 334\u2013339. Springer", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "The resolution calculus", "author": ["A. Leitsch"], "venue": "Springer. Texts in Theoretical Computer Science", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1997}, {"title": "Automatic abstraction without counterexamples", "author": ["K.L. McMillan", "N. Amla"], "venue": "Proceedings of TACAS\u201903, pages 2\u201317. Springer-Verlag", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "Proof theory in the USSR 1925-1969", "author": ["G. Mints"], "venue": "J. Symb. Log., 56(2):385\u2013424", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1991}, {"title": "First-Order Logic", "author": ["R.M. Smullyan"], "venue": "Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1968}, {"title": "Optimization and translation of tableau-proofs into resolution", "author": ["A. Wolf"], "venue": "Journal of Information Processing and Cybernetics, 30(5/6):311\u2013325", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1994}, {"title": "Validating SAT Solvers Using an Independent Resolution- Based Checker: Practical Implementations and Other Applications", "author": ["L. Zhang", "S. Malik"], "venue": "DATE, pages 10880\u201310885. IEEE Computer Society", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 2, "context": "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata [4].", "startOffset": 129, "endOffset": 132}, {"referenceID": 0, "context": "In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems.", "startOffset": 3, "endOffset": 9}, {"referenceID": 2, "context": "In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems.", "startOffset": 3, "endOffset": 9}, {"referenceID": 1, "context": "A related algorithm, called Dpll and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3].", "startOffset": 124, "endOffset": 127}, {"referenceID": 6, "context": "More precisely, we present an algorithm that, given a closed tableau T for a schema \u03c6n, returns a schema of a refutation of \u03c6n in the resolution calculus [9].", "startOffset": 154, "endOffset": 157}, {"referenceID": 8, "context": "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].", "startOffset": 171, "endOffset": 179}, {"referenceID": 10, "context": "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].", "startOffset": 171, "endOffset": 179}, {"referenceID": 4, "context": "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].", "startOffset": 205, "endOffset": 211}, {"referenceID": 11, "context": "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].", "startOffset": 87, "endOffset": 91}, {"referenceID": 7, "context": "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].", "startOffset": 120, "endOffset": 124}, {"referenceID": 5, "context": "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].", "startOffset": 156, "endOffset": 159}, {"referenceID": 3, "context": "Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies", "startOffset": 61, "endOffset": 64}, {"referenceID": 3, "context": "2 in [5]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable).", "startOffset": 159, "endOffset": 162}, {"referenceID": 0, "context": "The procedure is similar to the one presented in [2] and based on propositional block tableaux [12].", "startOffset": 49, "endOffset": 52}, {"referenceID": 9, "context": "The procedure is similar to the one presented in [2] and based on propositional block tableaux [12].", "startOffset": 95, "endOffset": 99}, {"referenceID": 0, "context": "Note that the notion of pure literal is much simpler here than in [2].", "startOffset": 66, "endOffset": 69}, {"referenceID": 1, "context": "The Dpll procedure in [3] can be simulated by the previous expansion rules, simply by adding for each propositional symbol p \u2208 \u03a9, a defined symbol \u03c5 with two rules: \u03c5 i+1 \u2192 ((pi\u2228\u00acpi)\u2227\u03c5 p i ) and \u03c5 0 \u2192 \u22a4.", "startOffset": 22, "endOffset": 25}, {"referenceID": 6, "context": "It is well-known [9] that every unsatisfiable set of (propositional) clauses has a refutation.", "startOffset": 17, "endOffset": 20}, {"referenceID": 1, "context": "This \u201ctrick\u201d does not actually simulate the full procedure in [3], because the latter handles schemata that are more complex than the ones considered in the present paper, possibly containing nested iterations.", "startOffset": 62, "endOffset": 65}], "year": 2017, "abstractText": "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata [4]. The first one handles the most efficient version of the tableau calculus but generates very complex derivations (denoted by rather elaborate rewrite systems). The second one has the advantage that much simpler systems can be obtained, however the considered proof procedure is less efficient. In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems. This proof procedure is able to test the validity of logical formul\u00e6 built on a set of indexed propositional symbols, using generalized connectives such as \u2228 n i=1 or \u2227 n i=1, where i, n are part of the language (n denotes a parameter, i.e. an existentially quantified variable). A schema is unsatisfiable iff it is unsatisfiable for every value of n. Stab combines the usual expansion rules of propositional logic with some delayed instantiation schemes that perform a case-analysis on the value of the parameter n. Termination is ensured for a specific class of schemata, called regular, thanks to a loop detection rule which is able to prune infinite tableaux into finite ones, by encoding a form a mathematical induction (by \u201cdescente infinie\u201d). A related algorithm, called Dpll and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3]. In the present work, we show that resolution proofs can be automatically extracted from the closed tableaux constructed by Stab or Dpll on unsatisfiable schemata. More precisely, we present an algorithm that, given a closed tableau T for a schema \u03c6n, returns a schema of a refutation of \u03c6n in the resolution calculus [9]. In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6]. The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8]. The present paper extends these techniques to propositional schemata. Beside the previously mentioned applications, this turned out to be particularly important in the context of the ASAP project [1] in which schemata calculi are applied to the formalisation and analysis of mathematical proofs via cut-elimination. Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies on the existence of a resolution proof of the so-called characteristic clause set extracted from the initial proof. The cut-free proof is reconstructed from this refutation, by replacing the clauses occurring in this set by some \u201cprojections\u201d of the original proof. While Stab and Dpll are able to detect the unsatisfiability of characteristic clause sets, as such this is completely useless since actually it is known that those sets are always unsatisfiable (see Proposition 3.2 in [5]). It is thus essential to be able to generate explicitly a representation of the resolution proof. This is precisely the aim of the present paper. Since the initial formula depends on a parameter n, its proof will also depend on n (except in very particular and trivial cases), i.e. it must be a schema of resolution proof (which will be encoded by recursive definitions). The rest of the paper is structured as follows. In Section 1 we introduce the basic notions and notations used throughout our work, in particular the logic of propositional schemata (syntax and semantics). In Section 2 we define a tableau-based proof procedure for this logic. This calculus simulates both Stab and Dpll (for the specific class of schemata considered in the present paper). In Section 3 we provide an algorithm to extract resolution proofs from closed tableaux. Similarly to the formul\u00e6 themselves, the constructed derivations are represented by rewrite systems. In Section 4 we introduce a second algorithm which generates simpler derivations but that requires that one of the closure rules defined in Section 2 (the so-called Loop Detection rule) be replaced by a less powerful rule, called the Global Loop Detection rule. Section 5 briefly concludes our work. 1 Propositional schemata The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable). We consider three disjoint sets of symbols: a set of arithmetic variables V , a set of propositional variables \u03a9 and a set of defined symbols \u03a5. Let \u227a be a total well-founded ordering on the symbols in \u03a5. An index expression is either a natural number or of the form n + k, where n is an arithmetic variable and k is a natural number. Let I be a set of index expressions. The set F(I) of formul\u00e6 built on I is inductively defined as follows: if p \u2208 \u03a9 \u222a \u03a5 and \u03b1 \u2208 I then p\u03b1 \u2208 F(I); \u22a4,\u22a5 \u2208 F(I); and if \u03c6, \u03c8 \u2208 F(I) then \u00ac\u03c6, \u03c6 \u2228 \u03c8, \u03c6 \u2227 \u03c8, \u03c6 \u21d2 \u03c8 and \u03c6 \u21d4 \u03c8 are in F(I). Definition 1 We assume that each element \u03c5 \u2208 \u03a5 is mapped to two rewrite rules \u03c1\u03c5 and \u03c1 0 \u03c5 that are respectively of the form \u03c5i+1 \u2192 \u03c6 (inductive case) and \u03c50 \u2192 \u03c8 (base case), where \u03c6 \u2208 F({i+ 1, i, 0}), \u03c8 \u2208 F({0}) and: 1. For every atom \u03c4\u03b1 occurring in \u03c6 such that \u03c4 \u2208 \u03a5 we have either \u03c4 \u227a \u03c5 and \u03b1 \u2208 {i+ 1, i, 0} or \u03c4 = \u03c5 and \u03b1 \u2208 {0, i}. 2. For every atom \u03c4\u03b1 occurring in \u03c8 such that \u03c4 \u2208 \u03a5 we have \u03c4 \u227a \u03c5 and \u03b1 = 0. \u2738 We denote by R the rewrite system: {\u03c1\u03c5, \u03c1 0 \u03c5 | \u03c5 \u2208 \u03a5}. The rules \u03c1 1 \u03c5 and \u03c1 0 \u03c5 are provided by the user, they encode the semantics of the defined symbols. Proposition 2 R is convergent. Proof. By Conditions 1 and 2 in Definition 1, the rules in R either strictly decrease the values of the defined symbols occurring in the formula w.r.t. \u227a or do not increase the value of these symbols but strictly decreases the value of their indices. Thus termination is obvious. Confluence is then immediate since the system is orthogonal. For every formula \u03c6, we denote by \u03c6\u2193R the unique normal form of \u03c6. A schema (of parameter n) is an element of F({0, n, n+ 1}). We denote by \u03c6{n \u2190 k} the formula obtained from \u03c6 by replacing every occurrence of n by k. Obviously for any schema \u03c6, \u03c6{n \u2190 k} \u2208 F({0, k, k + 1}). A propositional formula is a formula \u03c6 \u2208 F(N) containing no defined symbols. Notice that if \u03c6 \u2208 F(N) then \u03c6\u2193R is a propositional formula. Proposition 3 If \u03c6 \u2208 F(N) then \u03c6\u2193R is a propositional formula. Proof. By definition ofR, \u03c6\u2193R\u2208 F(N). Furthermore, if \u03c6\u2193R contains a defined symbol \u03c5 then either \u03c1\u03c5 or \u03c1 0 \u03c5 applies, which is impossible. An interpretation is a function mapping every arithmetic variable n to a natural number and every atom of the form pk (where k \u2208 N) to a truth value true or false. An interpretation I validates a propositional formula \u03c6 iff one of the following conditions holds: \u03c6 is of the form pk and I(pk) = true; \u03c6 is of the form \u00ac\u03c8 and I does not validate \u03c8; or \u03c6 is of the form \u03c81 \u2228 \u03c82 (resp. \u03c81 \u2227 \u03c82) and I validates \u03c81 or \u03c82 (resp. \u03c81 and \u03c82). I validates a schema \u03c6 (written I |= \u03c6) iff I validates \u03c6{n \u2190 I(n)}\u2193R. We write \u03c6 |= \u03c8 if every interpretation I validating \u03c6 also validates \u03c8 and \u03c6 \u2261 \u03c8 if \u03c6 |= \u03c8 and \u03c8 |= \u03c6. Example 4 The schema p0\u2227 \u2227 n i=1(pi\u22121 \u21d2 pi)\u2227\u00acpn is encoded by p0\u2227\u03c5n\u2227\u00acpn, where \u03c5 is defined by the rules: \u03c5i+1 \u2192 (\u00acpi \u2228 pi+1) \u2227 \u03c5i and \u03c50 \u2192 \u22a4. The schema \u2228 n i=1 pi \u2227 \u2227 n i=1 \u00acpi is encoded by \u03c4n \u2227 \u03c4 \u2032 n , where \u03c4 and \u03c4 \u2032 are defined by the rules: \u03c4i+1 \u2192 pi+1 \u2228 \u03c4i, \u03c40 \u2192 \u22a5, \u03c4 \u2032 i+1 \u2192 \u00acpi+1 \u2227 \u03c4 \u2032 i and \u03c4 \u2032 0 \u2192 \u22a4. Both schemata are obviously unsatisfiable. The schema (pn \u21d4 (pn\u22121 \u21d4 (. . . (p1 \u21d4 p0) . . .))) is defined by \u03c5 \u2032 n , where: \u03c5 i+1 \u2192 (pi+1 \u21d4 \u03c5 \u2032 i ) and \u03c5 0 \u2192 p0. \u2663", "creator": "LaTeX with hyperref package"}}}