{"id": "1109.6841", "review": {"conference": "ACL", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Sep-2011", "title": "Learning Dependency-Based Compositional Semantics", "abstract": "Suppose we want rapanos to 0:0 build a moine system wyrd that frankley answers ickleton a natural investigatory language hengyuan question mcqueary by poots representing its pousadas semantics as a logical form qu\u00ea and computing siyi the rna-seq answer mitt given lindheim a stoneflies structured database of 69.27 facts. d'enghien The erikson core part krulewitz of such a kokernag system wismer is rothstein the semantic parser 1q that maps questions adrenocorticotropic to logical forms. weerstandsbeweging Semantic parsers are typically greyfriars trained 71.36 from examples of questions annotated with dillenburg their 20v target family-friendly logical forms, a.b but toontown this type of nu\u00f1ez annotation avenches is iln expensive.", "histories": [["v1", "Fri, 30 Sep 2011 14:49:30 GMT  (1688kb,D)", "http://arxiv.org/abs/1109.6841v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["percy liang", "michael i jordan", "dan klein"], "accepted": true, "id": "1109.6841"}, "pdf": {"name": "1109.6841.pdf", "metadata": {"source": "CRF", "title": "Learning Dependency-Based Compositional Semantics", "authors": ["Percy Liang", "Michael I. Jordan"], "emails": ["pliang@cs.berkeley.edu", "jordan@cs.berkeley.edu", "klein@cs.berkeley.edu"], "sections": [{"heading": null, "text": "Our goal is to learn a semantic parser from question-answer pairs instead, where the logical form is modeled as a latent variable. Motivated by this challenging learning problem, we develop a new semantic formalism, dependency-based compositional semantics (DCS), which has favorable linguistic, statistical, and computational properties. We define a log-linear distribution over DCS logical forms and estimate the parameters using a simple procedure that alternates between beam search and numerical optimization. On two standard semantic parsing benchmarks, our system outperforms all existing stateof-the-art systems, despite using no annotated logical forms."}, {"heading": "1 Introduction", "text": "One of the major challenges in NLP is building systems that both handle complex linguistic phenomena and require minimal human effort. The difficulty of achieving both criteria is particularly evident in training semantic parsers, where annotating linguistic expressions with their associated logical forms is expensive but seemingly unavoidable. In this article, we overcome these limitations by developing new techniques that can learn rich semantic representations from weak supervision.\nWhat is the total population of the ten largest cities in California?\ncity\nSan Francisco Chicago Boston \u00b7 \u00b7 \u00b7\nloc\nMount Shasta California San Francisco California Boston Massachusetts \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\n>\n7 3 5 0 18 2 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\nstate\nAlabama Alaska Arizona \u00b7 \u00b7 \u00b7\npopulation\nLos Angeles 3.8 million San Francisco 805,000 Boston 617,000 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\ncount\n{} 0 {1,4} 2 {2,5,6} 3 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\nSystem\n?\nFigure 1: The concrete objective: a system that answers natural language questions given a structured database of facts. An example is shown in the domain of US geography.\nWe demonstrate our techniques on the concrete task of building a system to answer questions given a structured database of facts\u2013see Figure 1 for an example in the domain of US geography. The problem of\nar X\niv :1\n10 9.\n68 41\nv1 [\ncs .A\nI] 3\n0 Se\np 20\n11\nbuilding natural language interfaces to databases (NLIDBs) has a long history in NLP, starting from the early days of AI with systems such as Lunar (Woods et al., 1972), Chat-80 (Warren and Pereira, 1982), and many others (see Androutsopoulos et al. (1995) for an overview). While quite successful in their respective limited domains, because these systems were constructed from manually-built rules, they became difficult to scale up, both to other domains and to more complex utterances. In response, against the backdrop of a statistical revolution in NLP during the 1990s, researchers began to build systems that could learn from examples, with the hope of overcoming the limitations of rule-based methods. One of the earliest statistical efforts was the Chill system (Zelle and Mooney, 1996), which learned a shift-reduce semantic parser. Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).\nHowever, while statistical methods provided advantages such as robustness and portability, their application in semantic parsing achieved only limited success. One of the main obstacles was that these methods depended crucially on having examples of utterances paired with logical forms, and this requires substantial human effort to obtain. Furthermore, the annotators must be proficient in some formal language, which drastically reduces the size of the annotator pool, dampening any hope of acquiring enough data to fulfill the vision of learning highly accurate systems.\nIn response to these concerns, researchers have recently begun to explore the possibility of learning a semantic parser without any annotated logical forms (Clarke et al., 2010; Liang et al., 2011; Goldwasser et al., 2011; Artzi and Zettlemoyer, 2011). It is in this vein that we develop our present work. Specifically, given a set of (x, y) example pairs, where x is an utterance (e.g., a question) and y is the corresponding answer, we wish to learn a mapping from x to y. What makes this mapping particularly interesting is it passes through a latent logical form z, which is necessary to capture the semantic complexities of natural language. Also note that while the logical form z was the end goal in past work on semantic parsing, for us, it is just an intermediate variable\u2014a means towards an end. Figure 2 shows the graphical model which captures the learning setting we just described: The question x, answer y, and world/database w are all observed. We want to infer the logical forms z and the parameters \u03b8 of the semantic parser, which are unknown quantities.\nWhile liberating ourselves from annotated logical forms reduces cost, it does increase the difficulty of the learning problem. The core challenge here is program induction: on each example (x, y), we need to efficiently search over the exponential space of possible logical forms z and find ones that produces the target answer y, a computationally daunting task. There is also a statistical challenge: how do we parametrize the mapping from utterance x to logical form z so that it can be learned from only the indirect signal y? To address these two challenges, we must first discuss the issue of semantic representation. There are two basic questions here: (i) what should the formal language for the logical forms z be, and (ii) what are the compositional mechanisms for constructing those logical forms?\nThe semantic parsing literature is quite multilingual with respect to the formal language used for the logical form: Researchers have used SQL (Giordani and Moschitti, 2009), Prolog (Zelle and Mooney, 1996; Tang and Mooney, 2001), a simple functional query language called FunQL (Kate et al., 2005), and lambda calculus (Zettlemoyer and Collins, 2005), just to name a few. The construction mechanisms are equally diverse, including synchronous grammars (Wong and Mooney, 2007), hybrid trees (Lu et al., 2008), Combinatorial Categorial Grammars (CCG) (Zettlemoyer and Collins, 2005), and shift-reduce derivations (Zelle and Mooney, 1996). It is worth pointing out that the choice of formal language and the construction mechanism are decisions which are really more orthogonal than is often assumed\u2014the former is concerned with what the logical forms look like; the latter, with how to generate a set of possible logical forms compositionally given an utterance. (How to score these logical forms is yet another dimension.)\nExisting systems are rarely based on the joint design of the formal language and the construction mechanism; one or the other is often chosen for convenience from existing implementations. For example, Prolog and SQL have often been chosen as formal languages for convenience in end applications, but they were not designed for representing the semantics of natural language, and, as a result, the construction mechanism\n[0.3,\u22120.7, 4.5, 1.2, . . . ]\ncity\nSan Francisco Chicago Boston \u00b7 \u00b7 \u00b7\nloc\nMount Shasta California San Francisco California Boston Massachusetts \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\n>\n7 3 5 0 18 2 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\nstate Alabama Alaska Arizona \u00b7 \u00b7 \u00b7\npopulation\nLos Angeles 3.8 million San Francisco 805,000 Boston 617,000 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\ncount\n{} 0 {1,4} 2 {2,5,6} 3 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\n(parameters) (world)\nthat bridges the gap between natural language and formal language is generally complex and difficult to learn. CCG (Steedman, 2000) and more generally, categorial grammar, is the de facto standard in linguistics. In CCG, logical forms are constructed compositionally using a small handful of combinators (function application, function composition, and type raising). For a wide range of canonical examples, CCG produces elegant, streamlined analyses, but its success really depends on having a good, clean lexicon. During learning, there is often large amounts of uncertainty over the lexical entries, which makes CCG more cumbersome. Furthermore, in real-world applications, we would like to handle disfluent utterances, and this further strains CCG by demanding either extra type-raising rules and disharmonic combinators (Zettlemoyer and Collins, 2007) or a proliferation of redundant lexical entries for each word (Kwiatkowski et al., 2010).\nTo cope with the challenging demands of program induction, we break away from tradition in favor of a new formal language and construction mechanism, which we call dependency-based compositional semantics (DCS). The guiding principle behind DCS is to provide a simple and intuitive framework for constructing and representing logical forms. Logical forms in DCS are tree structures called DCS trees. The motivation is two-fold: (i) DCS trees are meant to parallel syntactic dependency trees, which facilitates parsing; and (ii) a DCS tree essentially encodes a constraint satisfaction problem, which can be solved efficiently using dynamic programming. In addition, DCS provides a mark-execute construct, which provides a uniform way of dealing with scope variation, a major source of trouble in any semantic formalism. The construction mechanism in DCS is a generalization of labeled dependency parsing, which leads to simple and natural algorithms. To a linguist, DCS might appear unorthodox, but it is important to keep in mind that our primary goal is effective program induction, not necessarily to model new linguistic phenomena in the tradition of formal semantics.\nArmed with our new semantic formalism, DCS, we then define a discriminative probabilistic model, which\nis depicted in Figure 2. The semantic parser is a log-linear distribution over DCS trees z given an utterance x. Notably, z is unobserved, and we instead observe only the answer y, which is obtained by evaluating z on a world/database w. There are an exponential number of possible trees z, and usually dynamic programming is employed for efficiently searching over the space of these combinatorial objects. However, in our case, we must enforce the global constraint that the tree generates the correct answer y, which makes dynamic programming infeasible. Therefore, we resort to beam search and learn our model with a simple procedure which alternates between beam search and optimizing a likelihood objective restricted to those beams. This yields a natural bootstrapping procedure in which learning and search are integrated.\nWe evaluated our DCS-based approach on two standard benchmarks, Geo, a US geography domain (Zelle and Mooney, 1996) and Jobs, a job queries domain (Tang and Mooney, 2001). On Geo, we found that our system significantly outperforms previous work that also learns from answers instead of logical forms (Clarke et al., 2010). What is perhaps a more significant result is that our system even outperforms state-of-the-art systems that do rely on annotated logical forms. This demonstrates that the viability of training accurate systems with much less supervision than before.\nThe rest of this article is organized as follows: Section 2 introduces dependency-based compositional semantics (DCS), our new semantic formalism. Section 3 presents our probabilistic model and learning algorithm. Section 4 provides an empirical evaluation of our methods. Finally, Section 5 situates this work in a broader context."}, {"heading": "2 Representation", "text": "In this section, we present the main conceptual contribution of this work, dependency-based compositional semantics (DCS), using the US geography domain (Zelle and Mooney, 1996) as a running example. To do this, we need to define the syntax and semantics of the formal language. The syntax is defined in Section 2.2 and is quite straightforward: The logical forms in the formal language are simply trees, which we call DCS trees. In Section 2.3, we give a type-theoretic definition of worlds (also known as databases or models) with respect to which we can define the semantics of DCS trees.\nThe semantics, which is the heart of this article, contains two main ideas: (i) using trees to represent logical forms as constraint satisfaction problems or extensions thereof, and (ii) dealing with cases when syntactic and semantic scope diverge (e.g., for generalized quantification and superlative constructions) using a new construct which we call mark-execute. We start in Section 2.4 by introducing the semantics of a basic version of DCS which focuses only on (i) and then extend it to the full version (Section 2.5) to account for (ii).\nFinally, having fully specified the formal language, we describe a construction mechanism for mapping a natural language utterance to a set of candidate DCS trees (Section 2.6)."}, {"heading": "2.1 Notation", "text": "Operations on tuples will play a prominent role in this article. For a sequence1 v = (v1, . . . , vk), we use |v| = k to denote the length of the sequence. For two sequences u and v, we use u + v = (u1, . . . , u|u|, v1, . . . , v|v|) to denote their concatenation.\nFor a sequence of positive indices i = (i1, . . . , im), let vi = (vi1 , . . . , vim) consist of the components of v specified by i; we call vi the projection of v onto i. We use negative indices to exclude components: v\u2212i = (v(1,...,|v|)\\i). We can also combine sequences of indices by concatenation: vi,j = vi + vj. Some examples: if v = (a, b, c, d), then v2 = b, v3,1 = (c, a), v\u22123 = (a, b, d), v3,\u22123 = (c, a, b, d)."}, {"heading": "2.2 Syntax of DCS Trees", "text": "The syntax of the DCS formal language is built from two ingredients, predicates and relations:\n1We use the sequence to include both tuples (v1, . . . , vk) and arrays [v1, . . . , vk]. For our purposes, there is no functional difference between tuples and arrays; the distinction is convenient when we start to talk about arrays of tuples.\n\u2022 Let P be a set of predicates. We assume that P always contains a special null predicate \u00f8 and several domain-independent predicates (e.g., count, <, >, and =). In addition, P contains domain-specific predicates. For example, for the US geography domain, P would include state, river, border, etc. Right now, think of predicates as just labels, which have yet to receive formal semantics.\n\u2022 Let R be the set of relations. The full set of relations are shown in Table 1; note that unlike the predicates P, the relations R are fixed.\nThe logical forms in DCS are called DCS trees. A DCS tree is a directed rooted tree in which nodes are labeled with predicates and edges are labeled with relations; each node also maintains an ordering over its children. Formally:\nDefinition 1 (DCS trees) Let Z be the set of DCS trees, where each z \u2208 Z consists of (i) a predicate z.p \u2208 P and (ii) a sequence of edges z.e = (z.e1, . . . , z.em). Each edge e consists of a relation e.r \u2208 R (see Table 1) and a child tree e.c \u2208 Z.\nWe will either draw a DCS tree graphically or write it compactly as \u3008p; r1 : c1; . . . ; rm : cm\u3009 where p is the predicate at the root node and c1, . . . , cm are its m children connected via edges labeled with relations r1, . . . , rm, respectively. Figure 4(a) shows an example of a DCS tree expressed using both graphical and compact formats.\nA DCS tree is a logical form, but it is designed to look like a syntactic dependency tree, only with predicates in place of words. As we\u2019ll see over the course of this section, it is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction."}, {"heading": "2.3 Worlds", "text": "In the context of question answering, the DCS tree is a formal specification of the question. To obtain an answer, we still need to evaluate the DCS tree with respect to a database of facts (see Figure 3 for an example). We will use the term world to refer to this database (it is sometimes also called model, but we avoid this term to avoid confusion with the probabilistic model for learning that we will present in Section 3.1)."}, {"heading": "2.3.1 Types and Values", "text": "To define a world, we start by constructing a set of values V. The exact set of values depend on the domain (we will continue to use US geography as a running example). Briefly, V contains numbers (e.g., 3 \u2208 V), strings (e.g., Washington \u2208 V), tuples (e.g., (3,Washington) \u2208 V), sets (e.g., {3,Washington} \u2208 V), and other higher-order entities.\nTo be more precise, we construct V recursively. First, define a set of primitive values V?, which includes the following:\n\u2022 Numeric values: each value has the form x : t \u2208 V?, where x \u2208 R is a real number and t \u2208 {number, ordinal, percent, length, . . . } is a tag. The tag allows us to differentiate 3, 3rd, 3%, and 3 miles\u2014this will be important in Section 2.6.3. We simply write x for the value x :number.\n\u2022 Symbolic values: each value has the form x : t \u2208 V?, where x is a string (e.g., Washington) and t \u2208 {string, city, state, river, . . . } is a tag. Again, the tag allows us to differentiate, for example, the entities Washington :city and Washington :state.\nNow we build the full set of values V from the primitive values V?. To define V, we need a bit more machinery: To avoid logical paradoxes, we construct V in increasing order of complexity using types (see Carpenter (1998) for a similar construction). The casual reader can skip this construction without losing any intuition.\nDefine the set of types T to be the smallest set that satisfies the following properties:\n1. The primitive type ? \u2208 T ;\n2. The tuple type (t1, . . . , tk) \u2208 T for each k \u2265 0 and each non-tuple type ti \u2208 T for i = 1, . . . , k; and\n3. The set type {t} \u2208 T for each tuple type t \u2208 T .\nNote that {?}, {{?}}, and ((?)) are not valid types. For each type t \u2208 T , we construct a corresponding set of values Vt:\n1. For the primitive type t = ?, the primitive values V? have already been specified. Note that these types are rather coarse: Primitive values with different tags are considered to have the same type ?.\n2. For a tuple type t = (t1, . . . , tk), Vt is the cross product of the values of its component types:\nVt = {(v1, . . . , vk) : \u2200i, vi \u2208 Vti}. (1)\n3. For a set type t = {t\u2032}, Vt contains all subsets of its element type t\u2032:\nVt = {s : s \u2282 Vt\u2032}. (2)\nNote that all elements of the set must have the same type.\nLet V = \u222at\u2208T Vt be the set of all possible values. A world maps each predicate to its semantics, which is a set of tuples (see Figure 3 for an example). First, let Ttuple \u2282 T be the tuple types, which are the ones of the form (t1, . . . , tk). Let V{tuple} denote all the sets of tuples (with the same type):\nV{tuple} def = \u22c3 t\u2208Ttuple V{t}. (3)\nNow we define a world formally:\nDefinition 2 (World) A world w : P 7\u2192 V{tuple} \u222a {V} is a function that maps each non-null predicate p \u2208 P\\{\u00f8} to a set of tuples w(p) \u2208 V{tuple} and maps the null predicate \u00f8 to the set of all values (w(\u00f8) = V).\nFor a set of tuples A with the same arity, let Arity(A) = |x|, where x \u2208 A is arbitrary; if A is empty, then Arity(A) is undefined. Now for a predicate p \u2208 P and world w, define Arityw(p), the arity of predicate p with respect to w, as follows:\nArityw(p) =\n{ 1 if p = \u00f8,\nArity(w(p)) if p 6= \u00f8. (4)\nThe null predicate has arity 1 by fiat; the arity of a non-null predicate p is inherited from the tuples in w(p).\nRemarks In higher-order logic and lambda calculus, we construct function types and values, whereas in DCS, we construct tuple types and values. The two are equivalent in representational power, but this discrepancy does point at the fact that lambda calculus is based on function application, whereas DCS, as we will see, is based on declarative constraints. The set type {(?, ?)} in DCS corresponds to the function type ?\u2192 (?\u2192 bool). In DCS, there is no explicit bool type\u2014it is implicitly represented by using sets."}, {"heading": "2.3.2 Examples", "text": "The world w maps each domain-specific predicate to a finite set of tuples. For the US geography domain, w has a predicate that maps to the set of US states (state), another predicate that maps to the set of pairs of entities and where they are located (loc), and so on:\nw(state) = {(California :state), (Oregon :state), . . . }, (5) w(loc) = {(San Francisco :city,California :state), . . . } (6)\n. . . (7)\nTo shorten notation, we use state abbreviations (e.g., CA = California :state). The world w also specifies the semantics of several domain-independent predicates (think of these as helper functions), which usually correspond to an infinite set of tuples. Functions are represented in DCS by a set of input-output pairs. For example, the semantics of the countt predicate (for each type t \u2208 T ) contains pairs of sets S and their cardinalities |S|:\nw(countt) = {(S, |S|) : S \u2208 V{(t)}} \u2208 V{({(t)},?)}. (8)\nAs another example, consider the predicate averaget (for each t \u2208 T ), which takes a set of key-value pairs (with keys of type t) and returns the average value. For notational convenience, we treat an arbitrary set of pairs S as a set-valued function: We let S1 = {x : (x, y) \u2208 S} denote the domain of the function, and abusing notation slightly, we define the function S(x) = {y : (x, y) \u2208 S} to be the set of values y that co-occur with the given x. The semantics of averaget contains pairs of sets and their averages:\nw(averaget) = (S, z) : S \u2208 V{(t,?)}, z = |S1|\u22121 \u2211 x\u2208S1 |S(x)|\u22121 \u2211 y\u2208S(x) y  \u2208 V{({(t,?)},?)}. (9)\nSimilarly, we can define the semantics of argmint and argmaxt, which each takes a set of key-value pairs and returns the keys that attain the smallest (largest) value:\nw(argmint) = { (S, z) : S \u2208 V{(t,?)}, z \u2208 argmin\nx\u2208S1 minS(x)\n} \u2208 V{({(t,?)},t)}, (10)\nw(argmaxt) = { (S, z) : S \u2208 V{(t,?)}, z \u2208 argmax\nx\u2208S1 maxS(x)\n} \u2208 V{({(t,?)},t)}. (11)\nThese helper functions are monomorphic: For example, countt only computes cardinalities of sets of type {(t)}. In practice, we mostly operate on sets of primitives (t = ?). To reduce notation, we omit t to refer to this version: count = count?, average = average?, etc."}, {"heading": "2.4 Semantics of DCS Trees: Basic Version", "text": "The semantics or denotation of a DCS tree z with respect to a world w is denoted JzKw. First, we define the semantics of DCS trees with only join relations (Section 2.4.1). In this case, a DCS tree encodes a constraint satisfaction problem (CSP); this is important because it highlights the constraint-based nature of DCS and also naturally leads to a computationally efficient way of computing denotations (Section 2.4.2). We then allow DCS trees to have aggregate relations (Section 2.4.3). The fragment of DCS which has only join and aggregate relations is called basic DCS."}, {"heading": "2.4.1 DCS Trees as Constraint Satisfaction Problems", "text": "Let z be a DCS tree with only join relations on its edges. In this case, z encodes a constraint satisfaction problem (CSP) as follows: For each node x in z, the CSP has a variable a(x); the collection of these variables is referred to as an assignment a. The predicates and relations of z introduce constraints:\n1. a(x) \u2208 w(p) for each node x labeled with predicate p \u2208 P; and\n2. a(x)j = a(y)j\u2032 for each edge (x, y) labeled with j j\u2032 \u2208 R, which says that the j-th component of a(x)\nmust equal the j\u2032-th component of a(y).\nWe say that an assignment a is feasible if it satisfies all the above constraints. Next, for a node x, define V (x) = {a(x) : assignment a is feasible} as the set of feasible values for x\u2014these are the ones which are consistent with at least one feasible assignment. Finally, we define the denotation of the DCS tree z with respect to the world w to be JzKw = V (x0), where x0 is the root node of z.\nFigure 4(a) shows an example of a DCS tree. The corresponding CSP has four variables c,m, `, s.2 In Figure 4(b), we have written the equivalent lambda calculus formula. The non-root nodes are existentially quantified, the root node c is \u03bb-abstracted, and all constraints introduced by predicates and relations are conjoined. The \u03bb-abstraction of c represents the fact that the denotation is the set of feasible values for c (note the equivalence between the boolean function \u03bbc.p(c) and the set {c : p(c)}).\nRemarks Note that CSPs only allow existential quantification and conjunction. Why did we choose this particular logical subset as a starting point, rather than allowing universal quantification, negation, or disjunction? There seems to be something fundamental about this subset, which also appears in Discourse Representation Theory (DRT) (Kamp and Reyle, 1993; Kamp et al., 2005). Briefly, logical forms in DRT are called Discourse Representation Structures (DRSes), each of which contains (i) a set of existentiallyquantified discourse referents (variables), (ii) a set of conjoined discourse conditions (constraints), and (iii) nested DRSes. If we exclude nested DRSes, a DRS is exactly a CSP.3 The default existential quantification and conjunction are quite natural for modeling cross-sentential anaphora: New variables can be added to\n2Technically, the node is c and the variable is a(c), but we use c to denote the variable to simplify notation. 3DRSes are not necessarily tree-structured, though economical DRT (Bos, 2009) imposes a tree-like restriction on DRSes\nfor computational reasons.\na DRS and connected to other variables. Indeed, DRT was originally motivated by these phenomena (see Kamp and Reyle (1993) for more details).\nTree-structured CSPs can capture unboundedly complex recursive structures\u2014such as cities in states that border states that have rivers that. . . . Trees are limited, however, in that they are unable to capture long-distance dependencies such as those arising from anaphora. For example, consider the phrase a state with a river that traverses its capital. Here, its binds to state, but this dependence cannot be captured in a tree structure. A solution to this problem can be pursued within the fuller formalism of CSPs and their realization as graphical models; we simply introduce an edge between the its node and the state node which introduces a CSP constraint that the two nodes must be equal. We will not pursue an exploration of non-tree structures in the current article, but it should be noted that such an extension is possible and quite natural."}, {"heading": "2.4.2 Computation", "text": "So far, we have given a declarative definition of the denotation JzKw of a DCS tree z with only join relations. Now we will show how to compute JzKw efficiently. Recall that the denotation is the set of feasible values for the root node. In general, finding the solution to a CSP is NP-hard, but for trees, we can exploit dynamic programming (Dechter, 2003). The key is that the denotation of a tree depends on its subtrees only through their denotations:\nJ \u2329 p; j1 j\u20321 :c1; \u00b7 \u00b7 \u00b7 ; jmj\u2032m :cm \u232a K w = w(p) \u2229 m\u22c2 i=1 {v : vji = tj\u2032i , t \u2208 JciKw}. (12)\nOn the right-hand side of (12), the first term w(p) is the set of values that satisfy the node constraint, and the second term consists of an intersection across all m edges of {v : vji = tj\u2032i , t \u2208 JciKw}, which is the set of values v which satisfy the edge constraint with respect to some value t for the child ci.\nTo further flesh out this computation, we express (12) in terms of two operations: join and project. Join takes a cross product of two sets of tuples and retains the resulting tuples that match the join constraint:\nA ./j,j\u2032 B = {u+ v : u \u2208 A, v \u2208 B, uj = v\u2032j}. (13)\nProject takes a set of tuples and retains a fixed subset of the components:\nA[i] = {vi : v \u2208 A}. (14)\nThe denotation in (12) can now be expressed in terms of these join and project operations: J \u2329 p; j1 j\u20321 :c1; \u00b7 \u00b7 \u00b7 ; jmj\u2032m :cm \u232a K w = ((w(p) ./j1,j\u20321 Jc1Kw)[i] \u00b7 \u00b7 \u00b7 ./jm,j\u2032m JcmKw)[i], (15)\nwhere i = (1, . . . ,Arityw(p)). Projecting onto i retains only components corresponding to p. The time complexity for computing the denotation of a DCS tree JzKw scales linearly with the number of nodes, but there is also a dependence on the cost of performing the join and project operations. For details on how we optimize these operations and handle infinite sets of tuples, see Liang (2011) .\nThe denotation of DCS trees is defined in terms of the feasible values of a CSP, and the recurrence in (12) is only one way of computing this denotation. However, in light of the extensions to come, we now consider (12) as the actual definition rather than just a computational mechanism. It will still be useful to refer to the CSP in order to access the intuition of using declarative constraints."}, {"heading": "2.4.3 Aggregate Relation", "text": "Thus far, we have focused on DCS trees that only use join relations, which are insufficient for capturing higher-order phenomena in language. For example, consider the phrase number of major cities. Suppose that number corresponds to the count predicate, and that major cities maps to the DCS tree \u3008city; 11 :\u3008major\u3009\u3009. We cannot simply join count with the root of this DCS tree because count needs to be joined with the set of major cities (the denotation of \u3008city; 11 :\u3008major\u3009\u3009), not just a single city.\nWe therefore introduce the aggregate relation (\u03a3) that takes a DCS subtree and reifies its denotation so that it can be accessed by other nodes in its entirety. Consider a tree \u3008\u03a3:c\u3009, where the root is connected to a child c via \u03a3. The denotation of the root is simply the singleton set containing the denotation of c:\nJ\u3008\u03a3:c\u3009Kw = {(JcKw)}. (16)\nFigure 5(a) shows the DCS tree for our running example. The denotation of the middle node is {(s)}, where s is all major cities. Everything above this node is an ordinary CSP: s constrains the count node, which in turns constrains the root node to |s|. Figure 5(b) shows another example of using the aggregate relation \u03a3. Here, the node right above \u03a3 is constrained to be a set of pairs of major cities and their populations. The average predicate then computes the desired answer.\nExample: most populous city\nTo represent logical disjunction in natural language, we use the aggregate relation and two predicates, union and contains, which are defined in the expected way:\nw(union) = {(S,B,C) : C = A \u222aB}, (17) w(contains) = {(A, x) : x \u2208 A}. (18)\nFigure 5(c) shows an example of a disjunctive construction: We use the aggregate relations to construct two sets, one containing Oregon, and the other containing states bordering Oregon. We take the union of these two sets; contains takes the set and reads out an element, which then constrains the city node.\nRemarks A DCS tree that contains only join and aggregate relations can be viewed as a collection of tree-structured CSPs connected via aggregate relations. The tree structure still enables us to compute denotations efficiently based on the recurrences in (15) and (16).\nRecall that a DCS tree with only join relations is a DRS without nested DRSes. The aggregate relation corresponds to the abstraction operator in DRT and is one way of making nested DRSes. It turns out that the abstraction operator is sufficient to obtain the full representational power of DRT, and subsumes generalized quantification and disjunction constructs in DRT. By analogy, we use the aggregate relation to handle disjunction (Figure 5(c)) and generalized quantification (Section 2.5.6).\nDCS restricted to join relations is less expressive than first-order logic because it does not have universal quantification, negation, and disjunction. The aggregate relation is analogous to lambda abstraction, and in basic DCS we use the aggregate relation to implement those basic constructs using higher-order predicates such as not,every, and union. We can also express logical statements such as generalized quantification, which go beyond first-order logic."}, {"heading": "2.5 Semantics of DCS Trees: Full Version", "text": "Basic DCS allows only join and aggregate relations, but is already quite expressive. However, it is not enough to simply express a denotation using an arbitrary logical form; one logical form can be better than another even if the two are semantically equivalent. For example, consider the superlative construction most populous city, which has a basic syntactic dependency structure shown in Figure 6(a). Figure 6(b)\nshows a DCS tree with only join and aggregate relations that expresses the correct semantics. However, the two structures are quite divergent\u2014the syntactic head is city and the semantic head is argmax. This divergence runs counter to a principal desideratum of DCS, which is to create a transparent interface between syntax and semantics.\nIn this section, we resolve this dilemma by introducing mark and execute relations, which will allow us to use the DCS tree in Figure 6(c) to represent the semantics associated with Figure 6(a). The focus of this section is on this mark-execute construct\u2014using mark and execute relations to give proper semanticallyscoped denotations to syntactically-scoped tree structures.\nThe basic intuition of the mark-execute construct is as follows: We mark a node low in the tree with a mark relation; then, higher up in the tree, we invoke it with a corresponding execute relation (Figure 7). For our example in Figure 6(c), we mark the population node, which puts the child argmax in a temporary store; when we execute the city node, we fetch the superlative predicate argmax from the store and invoke it.\nThis divergence between syntactic and semantic scope arises in other linguistic contexts besides superlatives such as quantification and negation. In each of these cases, the general template is the same: a syntactic modifier low in the tree needs to have semantic force higher in the tree. A particularly compelling case of this divergence happens with quantifier scope ambiguity (e.g., Some river traverses every city.), where the quantifiers appear in fixed syntactic positions, but the wide or narrow reading correspond to different semanticallyscoped denotations. Analogously, a single syntactic structure involving superlatives can also yield two different semantically-scoped denotations\u2014the absolute and relative readings (e.g., state bordering the largest state). The mark-execute construct provides a unified framework for dealing all these forms of divergence between syntactic and semantic scope. See Figure 8 for concrete examples of this construct."}, {"heading": "2.5.1 Denotations", "text": "We now formalize the mark-execute construct. We saw that the mark-execute construct appears to act non-locally, putting things in a store and retrieving them later. This means that if we want the denotation of a DCS tree to only depend on the denotations of its subtrees, the denotations need to contain more than the set of feasible values for the root node, as was the case for basic DCS. We need to augment denotations to include information about all marked nodes, since these can be accessed by an execute relation higher up in the tree.\nMore specifically, let z be a DCS tree and d = JzKw be its denotation. The denotation d consists of n columns, where each column is either the root node of z or a non-executed marked node in z. In the example in Figure 9, there are two columns, one for the root state node and the other for size node, which is marked by c. The columns are ordered according to a pre-order traversal of z, so column 1 always corresponds to the root node. The denotation d contains a set of arrays d.A, where each array represents a feasible assignment of values to the columns of d. For example, in Figure 9, the first array in d.A corresponds to assigning (OK)\nCalifornia borders which states?\nx1\n2\n1\n1\n1 CA\ne \u2217\u2217\nstate\nborder\n\u2217\u2217 Alaska borders no states.\nx1\n2\n1\n1\n1 AK\nq\nno\nstate\nborder\n\u2217\u2217 Some river traverses every city.\nx12\n2\n1\n1\n1\nq\nsome\nriver\nq\nevery\ncity\ntraverse\n\u2217\u2217 x21\n2\n1\n1\n1\nq\nsome\nriver\nq\nevery\ncity\ntraverse\n\u2217\u2217\n(narrow) (wide)\n(a) Extraction (e) (b) Quantification (q) (c) Quantifier scope ambiguity (q,q)\nto the state node (column 1) and (TX, 2.7e5) to the size node (column 2). If there are no marked nodes, d.A is basically a set of tuples, which corresponds to a denotation in basic DCS. For each marked node, the denotation d also maintains a store with information to be retrieved when that marked node is executed. A store \u03c3 for a marked node contains the following: (i) the mark relation \u03c3.r (c in the example), (ii) the base denotation \u03c3.b which essentially corresponds to denotation of the subtree rooted at the marked node excluding the mark relation and its subtree (J\u3008size\u3009Kw in the example), and (iii) the denotation of the child of the mark relation (J\u3008argmax\u3009Kw in the example). The store of any non-marked nodes (e.g., the root) is\nempty (\u03c3 = \u00f8).\nDefinition 3 (Denotations) Let D be the set of denotations, where each denotation d \u2208 D consists of\n\u2022 a set of arrays d.A, where each array a = [a1, . . . , an] \u2208 d.A is a sequence of n tuples; and\n\u2022 a sequence of n stores d.\u03c3 = (d.\u03c31, . . . , d.\u03c3n), where each store \u03c3 contains a mark relation \u03c3.r \u2208 {e,q,c, \u00f8}, a base denotation \u03c3.b \u2208 D \u222a {\u00f8}, and a child denotation \u03c3.c \u2208 D \u222a {\u00f8}.\nNote that denotations are formally defined without reference to DCS trees (just as sets of tuples were in basic DCS), but it is sometimes useful to refer to the DCS tree that generates that denotation.\nFor notational convenience, we write d as \u3008\u3008A; (r1, b1, c1); . . . ; (rn, bn, cn)\u3009\u3009. Also let d.ri = d.\u03c3i.r, d.bi = d.\u03c3i.b, and d.ci = d.\u03c3i.c. Let d{\u03c3i = x} be the denotation which is identical to d, except with d.\u03c3i = x; d{ri = x}, d{bi = x}, and d{ci = x} are defined analogously. We also define a project operation for denotations: \u3008\u3008A;\u03c3\u3009\u3009[i] def= \u3008\u3008{ai : a \u2208 A};\u03c3i\u3009\u3009. Extending this notation further, we use \u00f8 to denote the indices of the non-initial columns with empty stores (i > 1 such that d.\u03c3i = \u00f8). We can then use d[\u2212\u00f8] to represent projecting away the non-initial columns with empty stores. For the denotation d in Figure 9, d[1] keeps column 1, d[\u2212\u00f8] keeps both columns, and d[2,\u22122] swaps the two columns.\nIn basic DCS, denotations are sets of tuples, which works quite well for representing the semantics of whquestions such as What states border Texas? But what about polar questions such as Does Louisiana border Texas? The denotation should be a simple boolean value, which basic DCS does not represent explicitly. Using our new denotations, we can represent boolean values explicitly using zero-column structures: true corresponds to a singleton set containing just the empty array (dt = \u3008\u3008{[ ]}\u3009\u3009) and false is the empty set (df = \u3008\u3008\u2205\u3009\u3009).\nHaving described denotations as n-column structures, we now give the formal mapping from DCS trees to these structures. As in basic DCS, this mapping is defined recursively over the structure of the tree. We have a recurrence for each case (the first line is the base case, and each of the others handles a different edge relation):\nJ\u3008p\u3009Kw = \u3008\u3008{[v] : v \u2208 w(p)}; \u00f8\u3009\u3009, [base case] (19) J \u2329 p; e; jj\u2032 :c \u232a K w = J\u3008p; e\u3009Kw ./\u2212\u00f8j,j\u2032 JcKw, [join] (20)\nJ\u3008p; e; \u03a3:c\u3009Kw = J\u3008p; e\u3009Kw ./\u2212\u00f8\u2217,\u2217 \u03a3 (JcKw) , [aggregate] (21) J\u3008p; e;xi :c\u3009Kw = J\u3008p; e\u3009Kw ./\u2212\u00f8\u2217,\u2217 Xi(JcKw), [execute] (22) J\u3008p; e;e :c\u3009Kw = M(J\u3008p; e\u3009Kw,e, JcKw), [extract] (23) J\u3008p; e;c :c\u3009Kw = M(J\u3008p; e\u3009Kw,c, JcKw), [compare] (24) J\u3008p;q :c; e\u3009Kw = M(J\u3008p; e\u3009Kw,q, JcKw). [quantify] (25)\nWe define the operations ./\u2212\u00f8j,j\u2032 ,\u03a3,Xi,M in the remainder of this section."}, {"heading": "2.5.2 Base Case", "text": "(19) defines the denotation for a DCS tree z with a single node with predicate p. The denotation of z has one column whose arrays correspond to the tuples w(p); the store for that column is empty."}, {"heading": "2.5.3 Join Relations", "text": "(20) defines the recurrence for join relations. On the left-hand side, \u2329 p; e; jj\u2032 :c \u232a is a DCS tree with p at the root, a sequence of edges e followed by a final edge with relation jj\u2032 connected to a child DCS tree c. On the right-hand side, we take the recursively computed denotation of \u3008p; e\u3009, the DCS tree without the final edge, and perform a join-project-inactive operation (notated ./\u2212\u00f8j,j\u2032) with the denotation of the child DCS tree c.\nThe join-project-inactive operation joins the arrays of the two denotations (this is the core of the join operation in basic DCS\u2014see (13)), and then projects away the non-initial empty columns:\n\u3008\u3008A;\u03c3\u3009\u3009 ./\u2212\u00f8j,j\u2032 \u3008\u3008A \u2032;\u03c3\u2032\u3009\u3009 = \u3008\u3008A\u2032\u2032;\u03c3 + \u03c3\u2032\u3009\u3009[\u2212\u00f8],where (26) A\u2032\u2032 = {a + a\u2032 : a \u2208 A,a\u2032 \u2208 A\u2032, a1j = a\u20321j\u2032}.\nWe concatenate all arrays a \u2208 A with all arrays a\u2032 \u2208 A\u2032 that satisfy the join condition a1j = a\u20321j\u2032 . The sequences of stores are simply concatenated: (\u03c3 + \u03c3\u2032). Finally, any non-initial columns with empty stores are projected away by applying \u00b7[\u2212\u00f8].\nNote that the join works on column 1; the other columns are carried along for the ride. As another piece of convenient notation, we use \u2217 to represent all components, so ./\u2212\u00f8\u2217,\u2217 imposes the join condition that the entire tuple has to agree (a1 = a \u2032 1)."}, {"heading": "2.5.4 Aggregate Relations", "text": "(21) defines the recurrence for aggregate relations. Recall that in basic DCS, aggregate (16) simply takes the denotation (a set of tuples) and puts it into a set. Now, the denotation is not just a set, so we need to generalize this operation. Specifically, the aggregate operation applied to a denotation forms a set out of the tuples in the first column for each setting of the rest of the columns:\n\u03a3 (\u3008\u3008A;\u03c3\u3009\u3009) = \u3008\u3008A\u2032 \u222aA\u2032\u2032;\u03c3\u3009\u3009, (27) A\u2032 = {[S(a), a2, . . . , an] : a \u2208 A},\nS(a) = {a\u20321 : [a\u20321, a2, . . . , an] \u2208 A}, A\u2032\u2032 = {[\u2205, a2, . . . , an] : \u2200i \u2208 {2, . . . , n}, [ai] \u2208 \u03c3i.b.A[1],\u00ac\u2203a1,a \u2208 A}.\nThe aggregate operation takes the set of arrays A and produces two sets of arrays, A\u2032 and A\u2032\u2032, which are unioned (note that the stores do not change). The set A\u2032 is the one that first comes to mind: For every setting of a2, . . . , an, we construct S(a), the set of tuples a \u2032 1 in the first column which co-occur with a2, . . . , an in A.\nHowever, there is another case: what happens to settings of a2, . . . , an that do not co-occur with any value of a\u20321 in A? Then, S(a) = \u2205, but note that A\u2032 by construction will not have the desired array [\u2205, a2, . . . , an]. As a concrete example, suppose A = \u2205 and we have one column (n = 1). Then A\u2032 = \u2205, rather than the desired {[\u2205]}.\nFixing this problem is slightly tricky. There are an infinite number of a2, . . . , an which do not co-occur with any a\u20321 in A, so for which ones do we actually include [\u2205, a2, . . . , an]? Certainly, the answer to this question cannot come from A, so it must come from the stores. In particular, for each column i \u2208 {2, . . . , n}, we have conveniently stored a base denotation \u03c3i.b. We consider any ai that occurs in column 1 of the arrays of this base denotation ([ai] \u2208 \u03c3i.b.A[1]). For this a2, . . . , an, we include [\u2205, a2, . . . , an] in A\u2032\u2032 as long as a2, . . . , an does not co-occur with any a1. An example is given in Figure 10.\nThe reason for storing base denotations is thus partially revealed: The arrays represent feasible values of a CSP and can only contain positive information. When we aggregate, we need to access possibly empty sets of feasible values\u2014a kind of negative information, which can only be recovered from the base denotations."}, {"heading": "2.5.5 Mark Relations", "text": "(23), (24), and (25) each processes a different mark relation. We define a general mark operation, M(d, r, c) which takes a denotation d, a mark relation r \u2208 {e,q,c} and a child denotation c, and sets the store of d in column 1 to be (r, d, c):\nM(d, r, c) = d{r1 = r, b1 = d, c1 = c}. (28)\nThe base denotation of the first column b1 is set to the current denotation d. This, in some sense, creates a snapshot of the current denotation. Figure 11 shows an example of the mark operation."}, {"heading": "2.5.6 Execute Relations", "text": "(22) defines the denotation of a DCS tree where the last edge of the root is an execute relation. Similar to the aggregate case (21), we recurse on the DCS tree without the last edge (\u3008p; e\u3009) and then join it to the result of applying the execute operation Xi to the denotation of the child (JcKw).\nThe execute operation Xi is the most intricate part of DCS and is what does the heavy lifting. The operation is parametrized by a sequence of distinct indices i which specifies the order in which the columns should be processed. Specifically, i indexes into the subsequence of columns with non-empty stores. We then process this subsequence of columns in reverse order, where processing a column means performing some operations depending on the stored relation in that column. For example, suppose that columns 2 and 3 are the only non-empty columns. Then X12 processes column 3 before column 2. On the other hand, X21 processes column 2 before column 3. We first define the execute operation Xi for a single column i. There are three distinct cases, depending on the relation stored in column i:\nExtraction For a denotation d with the extract relation e in column i, executing Xi(d) involves three steps: (i) moving column i to before column 1 (\u00b7[i,\u2212i]), (ii) projecting away non-initial empty columns (\u00b7[\u2212\u00f8]), and (iii) removing the store (\u00b7{\u03c31 = \u00f8}):\nXi(d) = d[i,\u2212i][\u2212\u00f8]{\u03c31 = \u00f8} if d.ri = e. (29)\nAn example is given in Figure 12. There are two main uses of extraction:\n1. By default, the denotation of a DCS tree is the set of feasible values of the root node (which occupies column 1). To return the set of feasible values of another node, we mark that node with e. Upon execution, the feasible values of that node move into column 1. See Figure 8(a) for an example.\n2. Unmarked nodes are existentially quantified and have narrower scope than all marked nodes. Therefore, we can make a node x have wider scope than another node y by marking x (with e) and executing y before x (see Figure 8(d,e) for examples). The extract relation e (in fact, any mark relation) signifies that we want to control the scope of a node, and the execute relation allows us to set that scope.\nGeneralized Quantification Generalized quantifiers (including negation) are predicates on two sets, a restrictor A and a nuclear scope B. For example,\nw(some) = {(A,B) : A \u2229B > 0}, (30) w(every) = {(A,B) : A \u2282 B}, (31)\nw(no) = {(A,B) : A \u2229B = \u2205}, (32)\nw(most) = {(A,B) : |A \u2229B| > 1 2 |A|}. (33)\nWe think of the quantifier as a modifier which always appears as the child of a q relation; the restrictor is the parent. For example, in Figure 8(b), no corresponds to the quantifier and state corresponds to the restrictor. The nuclear scope should be the set of all states that Alaska borders. More generally, the nuclear scope is the set of feasible values of the restrictor node with respect to the CSP that includes all nodes\nbetween the mark and execute relations. The restrictor is also the set of feasible values of the restrictor node, but with respect to the CSP corresponding to the subtree rooted at that node.4\nWe implement generalized quantifiers as follows: Let d be a denotation and suppose we are executing column i. We first construct a denotation for the restrictor dA and a denotation for the nuclear scope dB . For the restrictor, we take the base denotation in column i (d.bi)\u2014remember that the base denotation represents a snapshot of the restrictor node before the nuclear scope constraints are added. For the nuclear scope, we take the complete denotation d (which includes the nuclear scope constraints) and extract column i (d[i,\u2212i][\u2212\u00f8]{\u03c31 = \u00f8}\u2014see (29)). We then construct dA and dB by applying the aggregate operation to each. Finally, we join these sets with the quantifier denotation, stored in d.ci:\nXi(d) = (( d.ci ./ \u2212\u00f8 1,1 dA ) ./\u2212\u00f82,1 dB ) [\u22121] if d.ri = q,where (34)\ndA = \u03a3 (d.bi) , (35) dB = \u03a3 (d[i,\u2212i][\u2212\u00f8]{\u03c31 = \u00f8}) . (36)\nWhen there is one quantifier, think of the execute relation as performing a syntactic rewriting operation, as shown in Figure 13(b). For more complex cases, we must defer to (34).\nFigure 8(c) shows an example with two interacting quantifiers. The denotation of the DCS tree before execution is the same in both readings, as shown in Figure 14. The quantifier scope ambiguity is resolved by the choice of execute relation: x12 gives the narrow reading, x21 gives the wide reading.\nFigure 8(d) shows how extraction and quantification work together. First, the no quantifier is processed for each city, which is an unprocessed marked node. Here, the extract relation is a technical trick to give city wider scope.\nComparatives and Superlatives Comparative and superlative constructions involve comparing entities, and for this, we rely on a set S of entity-degree pairs (x, y), where x is an entity and y is a numeric degree. Recall that we can treat S as a function, which maps an entity x to the set of degrees S(x) associated with x. Note that this set can contain multiple degrees. For example, in the relative reading of state bordering the largest state, we would have a degree for the size of each neighboring state.\nSuperlatives use the argmax and argmin predicates, which are defined in Section 2.3. Comparatives use the more and less predicates: w(more) contains triples (S, x, y), where x is \u201cmore than\u201d y as measured by S; w(less) is defined analogously:\nw(more) = {(S, x, y) : maxS(x) > maxS(y)}, (37) w(less) = {(S, x, y) : minS(x) < minS(y)}. (38)\n4 Defined this way, we can only handle conservative quantifiers, since the nuclear scope will always be a subset of the restrictor. This design decision is inspired by DRT, where it provides a way of modeling donkey anaphora. We are not treating anaphora in this work, but we can handle it by allowing pronouns in the nuclear scope to create anaphoric edges into nodes in the restrictor. These constraints naturally propagate through the nuclear scope\u2019s CSP without affecting the restrictor.\nWe use the same mark relation c for both comparative and superlative constructions. In terms of the DCS tree, there are three key parts: (i) the root x, which corresponds to the entity to be compared, (ii) the child c of a c relation, which corresponds to the comparative or superlative predicate, and (iii) c\u2019s parent p, which contains the \u201cdegree information\u201d (which will be described later) used for comparison. We assume that the root is marked (usually with a relation e). This forces us to compute a comparison degree for each value of the root node. In terms of the denotation d corresponding to the DCS tree prior to execution, the entity to be compared occurs in column 1 of the arrays d.A, the degree information occurs in column i of the arrays d.A, and the denotation of the comparative or superlative predicate itself is the child denotation at column i (d.ci).\nFirst, we define a concatenating function +i (d), which combines the columns i of d by concatenating the\ncorresponding tuples of each array in d.A:\n+i (\u3008\u3008A;\u03c3\u3009\u3009) = \u3008\u3008A\u2032;\u03c3\u2032\u3009\u3009,where (39) A\u2032 = {a(1...i1)\\i + [ai1 + \u00b7 \u00b7 \u00b7+ ai|i| ] + a(i1...n)\\i : a \u2208 A} \u03c3\u2032 = \u03c3(1...i1)\\i + [\u03c3i1 ] + \u03c3(i1...n)\\i.\nNote that the store of column i1 is kept and the others are discarded. As an example:\n+2,1 (\u3008\u3008{[(1), (2), (3)], [(4), (5), (6)]};\u03c31, \u03c32, \u03c33\u3009\u3009) = \u3008\u3008{[(2, 1), (3)], [(5, 4), (6)]};\u03c32, \u03c33\u3009\u3009. (40)\nWe first create a denotation d\u2032 where column i, which contains the degree information, is extracted to column 1 (and thus column 2 corresponds to the entity to be compared). Next, we create a denotation dS whose column 1 contains a set of entity-degree pairs. There are two types of degree information:\n1. Suppose the degree information has arity 2 (Arity(d.A[i]) = 2). This occurs, for example, in most populous city (see Figure 8(f)), where column i is the population node. In this case, we simply set the degree to the second component of population by projection (J\u3008\u00f8\u3009Kw ./\u2212\u00f81,2 d\u2032). Now columns 1 and 2 contain the degrees and entities, respectively. We concatenate columns 2 and 1 (+2,1 (\u00b7)) and aggregate to produce a denotation dS which contains the set of entity-degree pairs in column 1.\n2. Suppose the degree information has arity 1 (Arity(d.A[i]) = 1). This occurs, for example, in state bordering the most states (see Figure 8(e)), where column i is the lower marked state node. In this case, the degree of an entity from column 2 is the number of different values that column 1 can take. To compute this, aggregate the set of values (\u03a3 (d\u2032)) and apply the count predicate. Now with the degrees and entities in columns 1 and 2, respectively, we concatenate the columns and aggregate again to obtain dS .\nHaving constructed dS , we simply apply the comparative/superlative predicate which has been patiently waiting in d.ci. Finally, the store of d\u2019s column 1 was destroyed by the concatenation operation +2,1 (() \u00b7), so we must restore it with \u00b7{\u03c31 = d.\u03c31}. The complete operation is as follows:\nXi(d) = ( J\u3008\u00f8\u3009Kw ./\u2212\u00f81,2 ( d.ci ./ \u2212\u00f8 1,1 dS )) {\u03c31 = d.\u03c31} if d.\u03c3i = c, d.\u03c31 6= \u00f8, where (41)\ndS =\n{ \u03a3 ( +2,1 ( J\u3008\u00f8\u3009Kw ./\u2212\u00f81,2 d\u2032 )) if Arity(d.A[i]) = 2\n\u03a3 ( +2,1 ( J\u3008\u00f8\u3009Kw ./\u2212\u00f81,2 ( J\u3008count\u3009Kw ./\u2212\u00f81,1 \u03a3 (d\u2032) ))) if Arity(d.A[i]) = 1,\n(42)\nd\u2032 = d[i,\u2212i][\u2212\u00f8]{\u03c31 = \u00f8}. (43)\nAn example of executing the c relation is shown in Figure 15(a). As with executing a q relation, for simple cases, we can think of executing a c relation as expanding a DCS tree, as shown in Figure 15(b).\nFigure 8(e) and Figure 8(f) show examples of superlative constructions with the arity 1 and arity 2 types of degree information, respectively. Figure 8(g) shows an example of an comparative construction. Comparatives and superlatives use the same machinery, differing only in the predicate: argmax versus \u3008more; 31 :TX\u3009 (more than Texas). But both predicates have the same template behavior: Each takes a set of entity-degree pairs and returns any entity satisfying some property. For argmax, the property is obtaining the highest degree; for more, it is having a degree higher than a threshold. We can handle generalized superlatives (the five largest or the fifth largest or the 5% largest) as well by swapping in a different predicate; the execution mechanisms defined in (41) remain the same.\nWe saw that the mark-execute machinery allows decisions regarding quantifier scope to made in a clean and modular fashion. Superlatives also have scope ambiguities in the form of absolute versus relative readings. Consider the example in Figure 8(g). In the absolute reading, we first compute the superlative in a narrow scope (the largest state is Alaska), and then connect it with the rest of the phrase, resulting in the empty set (since no states border Alaska). In the relative reading, we consider the first state as the entity we want to compare, and its degree is the size of a neighboring state. In this case, the lower state node cannot be\nset to Alaska because there are no states bordering it. The result is therefore any state that borders Texas (the largest state that does have neighbors). The two DCS trees in Figure 8(g) show that we can naturally account for this form of superlative ambiguity based on where the scope-determining execute relation is placed without drastically changing the underlying tree structure.\nRemarks All these issues are not specific to DCS; every serious semantic formalism must address them as well. Not surprisingly then, the mark-execute construct bears some resemblance to other mechanisms that operate on categorial grammar and lambda calculus, such as quantifier raising, Montague\u2019s quantifying in, Cooper storage, and Carpenter\u2019s scoping constructor (Carpenter, 1998). Very broadly speaking, these mechanisms delay application of the divergent element (usually a quantifier), \u201cmarking\u201d its spot with a dummy pronoun (as in Montague\u2019s quantifying in) or in a store (as in Cooper storage), and then \u201cexecuting\u201d the quantifier at a later point in the derivation. One subtle but important difference between mark-execute in DCS and the others is that a DCS tree (which contains the mark and execute relations) is the final logical form, and all the action happens in the computing of the denotation of this logical form. In more traditional approaches, the action happens in the construction mechanism for building the logical form; the actually logical form produced at the end of the day is quite simple. In other words, we have pushed the inevitable complexity from the construction mechanism into the semantics of the logical from. This refactoring is important because we want our construction mechanism to focus not on linguistic issues, but on purely computational and statistical ones, which ultimately determine the practical success of our system."}, {"heading": "2.6 Construction Mechanism", "text": "We have thus far defined the syntax (Section 2.2) and semantics (Section 2.5) of DCS trees, but we have only vaguely hinted at how these DCS trees might be connected to natural language utterances by appealing to idealized examples. In this section, we formally define the construction mechanism for DCS, which takes an utterance x and produces a set of DCS trees ZL(x).\nSince we motivated DCS trees based on dependency syntax, it might be tempting to take a dependency parse tree of the utterance, replace the words with predicates, and attach some relations on the edges to produce a DCS tree. To a first approximation, this is what we will do, but we need to be a bit more flexible for several reasons: (i) some nodes in the DCS tree do not have predicates (e.g., children of a e relation or parent of an xi relation); (ii) nodes have predicates that do not correspond to words (e.g., in California cities, there is a implicit loc predicate that bridges CA and city); (iii) some words might not correspond to any predicates in our world (e.g., please); and (iv) the DCS tree might not always be aligned with the syntactic structure depending on which syntactic formalism one ascribes to. While syntax was the inspiration for the DCS formalism, we will not actually use it in construction.\nIt is also worth stressing the purpose of the construction mechanism. In linguistics, the purpose of the construction mechanism is to try to generate the exact set of valid logical forms for a sentence. We view the construction mechanism instead as simply a way of creating a set of candidate logical forms. A separate step defines a distribution over this set to favor certain logical forms over others. The construction mechanism should therefore overapproximate the set of logical forms. Settling for an overapproximation allows us to simplify the construction mechanism."}, {"heading": "2.6.1 Lexical Triggers", "text": "The construction mechanism assumes a fixed set of lexical triggers L. Each trigger is a pair (s, p), where s is a sequence of words (usually one) and p is a predicate (e.g., s = California and p = CA). We use L(s) to denote the set of predicates p triggered by s ((s, p) \u2208 L). We also define a set of trace predicates, denoted by L( ), which can be introduced without an overt lexical trigger.\nIt is important to think of the lexical triggers L not as pinning down the precise predicate for each word. For example, L might contain {(city, city), (city, state), (city, river), . . . }. Section 4.1.3 describes the lexical triggers that we use in our experiments."}, {"heading": "2.6.2 Recursive Construction of DCS Trees", "text": "Given a set of lexical triggers L, we will now describe a recursive mechanism for mapping an utterance x = (x1, . . . , xn) to ZL(x), a set of candidate DCS trees for x. The basic approach is reminiscent of projective labeled dependency parsing: For each span i..j of the utterance, we build a set of trees Ci,j(x). The set of trees for the span 0..n is the final result:\nZL(x) = C0,n(x). (44)\nEach set of DCS trees Ci,j(x) is constructed recursively by combining the trees of its subspans Ci,k(x) and Ck\u2032,j(x) for each pair of split points k, k\n\u2032 (words between k and k\u2032 are ignored). These combinations are then augmented via a function A and filtered via a function F ; these functions will be specified later. Formally, Ci,j(x) is defined recursively as follows:\nCi,j(x) = F ( A ( {\u3008p\u3009i..j : p \u2208 L(xi+1..j)} \u222a \u22c3 i\u2264k\u2264k\u2032<j a\u2208Ci,k(x) b\u2208Ck\u2032,j(x) T1(a, b)) )) . (45)\nThis recurrence has two parts:\n\u2022 The base case: we take the phrase (sequence of words) over span i..j and look up the set of predicates p in the set of lexical triggers. For each predicate, we construct a one-node DCS tree. We also extend the definition of DCS trees in Section 2.2 to allow each node to store the indices of the span i..j that triggered the predicate at that node; this is denoted by \u3008p\u3009i..j . This span information will be useful in Section 3.1.1, where we will need to talk about how an utterance x is aligned with a DCS tree z.\n\u2022 The recursive case: T1(a, b), which we will define shortly, that takes two DCS trees, a and b, and returns a set of new DCS trees formed by combining a and b. Figure 16 shows this recurrence graphically.\nWe now focus on how to combine two DCS trees. Define Td(a, b) as the set of DCS trees that result by making either a or b the root and connecting the other via a chain of relations and at most d trace predicates:\nTd(a, b) = T \u2198 d (a, b) \u222a T \u2199 d (b, a), (46)\nHere, T\u2198d (a, b) is the set of DCS trees where a is the root; for T \u2199 d (a, b), b is the root. The former is defined recursively as follows:\nT\u21980 (a, b) = \u2205, (47) T\u2198d (a, b) = \u22c3 r\u2208R p\u2208L( ) {\u3008a; r :b\u3009 , \u3008a; r :\u3008\u03a3:b\u3009\u3009} \u222a T\u2198d\u22121(a, \u3008p; r :b\u3009).\nFirst, we consider all possible relations r \u2208 R and try putting r between a and b (\u3008a; r :b\u3009), possibly with an additional aggregate relation (\u3008a; r :\u3008\u03a3:b\u3009\u3009). Of course, R contains an infinite number of join and execute relations, but only a small finite number of them make sense: we consider join relations jj\u2032 only for j \u2208 {1, . . . ,Arity(a.p)} and j\u2032 \u2208 {1, . . . ,Arity(b.p)}, and execute relations xi for which i does not contain indices larger than the number of columns of JbKw. Next, we further consider all possible trace predicates p \u2208 L( ), and recursively try to connect a with the intermediate \u3008p; r :b\u3009, now allowing d \u2212 1 additional predicates. See Figure 17 for an example. In the other direction, T\u2199d is defined similarly:\nT\u21990 (a, b) = \u2205, (48) T\u2199d (a, b) = \u22c3 r\u2208R p\u2208L( ) {\u3008b.p; r :a; b.e\u3009 , \u3008b.p; r :\u3008\u03a3:a\u3009 ; b.e\u3009} \u222a T\u2198d\u22121(a, \u3008p; r :b\u3009).\nInserting trace predicates allows us to build logical forms with more predicates than are explicitly triggered by the words. This ability is useful for several reasons. Sometimes, there is a predicate not overtly expressed, especially in noun compounds (e.g., California cities). For semantically light words such as prepositions (e.g., for) it is difficult to enumerate all the possible predicates that it might trigger; it is simpler computationally to try to insert trace predicates. We can even omit lexical triggers for transitive verbs such as border because the corresponding predicate border can be inserted as a trace predicate.\nThe function T1(a, b) connects two DCS trees via a path of relations and trace predicates. The augmentation function A adds additional relations (specifically, e and/or xi) on a single DCS tree:\nA(Z) = \u22c3 z\u2208Z xi\u2208R {z, \u3008z;e :\u3008\u00f8\u3009\u3009 , \u3008xi :z\u3009 , \u3008xi :\u3008z;e :\u3008\u00f8\u3009\u3009\u3009}, (49)"}, {"heading": "2.6.3 Filtering using Abstract Interpretation", "text": "The construction procedure as described thus far is extremely permissive, generating many DCS trees which are obviously wrong\u2014for example, \u3008state; 11 :\u3008>; 21 \u30083\u3009\u3009\u3009, which tries to compare a state with the number 3.\nThere is nothing wrong this expression syntactically: its denotation will simply be empty (with respect to the world). But semantically, this DCS tree is anomalous.\nWe cannot simply just discard DCS trees with empty denotations, because we would incorrectly rule out \u3008state; 11 :\u3008border; 21 \u3008AK\u3009\u3009\u3009. The difference here is that even though the denotation is empty in this world, it is possible that it might not be empty in a different world where history and geology took another turn, whereas it is simply impossible to compare cities and numbers.\nNow let us quickly flesh out this intuition before falling into a philosophical discussion about possible worlds. Given a world w, we define an abstract world \u03b1(w), to be described shortly. We compute the denotation of a DCS tree z with respect to this abstract world. If at any point in the computation we create an empty denotation, we judge z to be impossible and throw it away. The filtering function F is defined as follows:5\nF (Z) = {z \u2208 Z : \u2200z\u2032 subtree of z , Jz\u2032K\u03b1(w).A 6= \u2205}. (50)\nNow we need to define the abstract world \u03b1(w). The intuition is to map concrete values to abstract values: 3 : length becomes length, Oregon : state becomes \u2217 : state, and in general, primitive value x : t becomes \u2217 : t. We perform abstraction on tuples componentwise, so that (Oregon :state, 3:length) becomes (\u2217 :state, \u2217 :length). Our abstraction of sets is slightly more complex: the empty set maps to the empty set, a set containing values all with the same abstract value a maps to {a}, and a set containing values with more than one abstract value maps to a {mixed}. Finally, a world maps each predicate onto a set of (concrete) tuples; the corresponding abstract world maps each predicate onto the set of abstract tuples. Formally, the abstraction function is defined as follows:\n\u03b1(x : t) = \u2217 : t, [primitive values] (51) \u03b1((v1, . . . , vn)) = (\u03b1(v1), . . . , \u03b1(vn)), [tuples] (52)\n\u03b1(A) =  \u2205 if A = \u2205, {\u03b1(x) : x \u2208 A} if |{\u03b1(x) : x \u2208 A}| = 1, {mixed} otherwise.\n[sets] (53)\n\u03b1(w) = \u03bbp.{\u03b1(x) : x \u2208 w(p)}. [worlds] (54)\nAs an example, the abstract world might look like this:\n\u03b1(w)(>) = {(\u2217 :number, \u2217 :number, \u2217 :number), (\u2217 :length, \u2217 :length, \u2217 :length), . . . }, (55) \u03b1(w)(state) = {(\u2217 :state)}, (56)\n\u03b1(w)(AK) = {(\u2217 :state)}, (57) \u03b1(w)(border) = {(\u2217 :state, \u2217 :state)}. (58)\nNow returning our motivating example at the beginning of this section, we see that the bad DCS tree has an empty abstract denotation J\u3008state; 11 :\u3008>; 21 \u30083\u3009\u3009\u3009K\u03b1(w) = \u3008\u3008\u2205; \u00f8\u3009\u3009. The good DCS tree has an non-empty abstract denotation: J\u3008state; 11 :\u3008border; 21 \u3008AK\u3009\u3009\u3009K\u03b1(w) = \u3008\u3008{(\u2217 :state)}; \u00f8\u3009\u3009, as desired.\nRemarks Computing denotations on an abstract world is called abstract interpretation (Cousot and Cousot, 1977) and is very powerful framework commonly used in the programming languages community. The idea is to obtain information about a program (in our case, a DCS tree) without running it concretely, but rather just by running it abstractly. It is closely related to type systems, but the type of abstractions one uses is often much richer than standard type systems."}, {"heading": "2.6.4 Comparison with CCG", "text": "We now compare our construction mechanism with CCG (see Figure 18 for an example). The main difference is that our lexical triggers contain less information than a lexicon in a CCG. In CCG, the lexicon would have an entry such as\nmajor ` n/n : \u03bbf.\u03bbx.major(x) \u2227 f(x), (59)\nwhich gives detailed information about how this word should interact with its context. However, in DCS construction, each lexical trigger only has the minimal amount of information:\nmajor ` major. (60)\nA lexical trigger specifies a pre-theoretic \u201cmeaning\u201d of a word which does not commit to any formalisms. One advantage of this minimality is that lexical triggers could be easily obtained from non-expert supervision: One would only have to associate words with database table names (predicates).\nIn some sense, the DCS construction mechanism pushes the complexity out of the lexicon. In linguistics, this complexity usually would end up in the grammar, which would be undesirable. However, we do not have to respect this tradeoff, because the construction mechanism only produces an overapproximation, which means it is possible to have both a simple \u201clexicon\u201d and a simple \u201cgrammar.\u201d\nThere is an important but subtle rationale for this design decision. During learning, we never just have one clean lexical entry per word (as is typically assumed in formal linguistics). Rather, there are often many possible lexical entries (and to handle disfluent utterances or utterances in free word-order languages, we might actually need many of them (Kwiatkowski et al., 2010, 2011)):\nmajor ` n : \u03bbx.major(x) (61) major ` n/n : \u03bbf.\u03bbx.major(x) \u2227 f(x) (62) major ` n\\n : \u03bbf.\u03bbx.major(x) \u2227 f(x) (63) . . . (64)\n5 To further reduce the search space, F imposes a few additional constraints, e.g., limiting the number of columns to 2, and only allowing trace predicates between arity 1 predicates.\nNow think of a DCS lexical trigger major ` major as simply a compact representation for a set of CCG lexical entries. Furthermore, the choice of the lexical entry is made not at the initial lexical base case, but rather during the recursive construction by inserting relations between DCS subtrees. It is exactly at this point that the choice can be made, because after all, the choice is one that depends on context. The general principle is to compactly represent the indeterminacy until one can resolve it.\nType raising is a combinator in CCG that turns one logical form into another. It can be used to turn one entity into a related entity (a kind of generalized metonymy). For example, Zettlemoyer and Collins (2007) used it to allow conversion from Boston to \u03bbx.from(x, Boston). Type raising in CCG is analogous to inserting trace predicates in DCS, but there is an important distinction: Type raising is a unary operation and is unconstrained in that it changes logical forms into new ones without regard for how they will interact with the context. Inserting trace predicates is a binary operation which is constrained by the two predicates that it is mediating. In the example, from would only be inserted to combine Boston with flight. This is another instance of the general principle of delaying uncertain decisions until there is more information."}, {"heading": "3 Learning", "text": "In Section 2, we defined DCS trees and a construction mechanism for producing a set of candidate DCS trees given an utterance. We now define a probability distribution over that set (Section 3.1) and an algorithm for estimating the parameters (Section 3.2). The number of candidate DCS trees grows exponentially, so we use beam search to control this growth. The final learning algorithm alternates between beam search and optimization of the parameters, leading to a natural bootstrapping procedure which integrates learning and search."}, {"heading": "3.1 Semantic Parsing Model", "text": "The semantic parsing model specifies a conditional distribution over a set of candidate DCS trees C(x) given an utterance x. This distribution depends on a function \u03c6(x, z) \u2208 Rd, which takes a (x, z) pair and extracts a set of local features (see Section 3.1.1 for a full specification). Associated with this feature vector is a parameter vector \u03b8 \u2208 Rd. The inner product between the two vectors, \u03c6(x, z)>\u03b8, yields a numerical score, which intuitively measures the compatibility of the utterance x with the DCS tree z. We exponentiate the score and normalize over C(x) to obtain a proper probability distribution:\np(z | x;C, \u03b8) = exp{\u03c6(x, z)>\u03b8 \u2212A(\u03b8; x, C)}, (65) A(\u03b8; x, C) = log \u2211\nz\u2208C(x)\nexp{\u03c6(x, z)>\u03b8}, (66)\nwhere A(\u03b8; x, C) is the log-partition function with respect to the candidate set function C(x)."}, {"heading": "3.1.1 Features", "text": "We now define the feature vector \u03c6(x, z) \u2208 Rd, the core part of the semantic parsing model. Each component j = 1, . . . , d of this vector is a feature, and \u03c6(x, z)j is the number of times that feature occurs in (x, z). Rather than working with indices, we treat features as symbols (e.g., TriggerPred[states, state]). Each feature captures some property about (x, z) which abstracts away from the details of the specific instance and allow us to generalize to new instances that share common features.\nThe features are organized into feature templates, where each feature template instantiates a set of features. Figure 19 shows all the feature templates for a concrete example. The feature templates are as follows:\n\u2022 PredHit contains the single feature PredHit, which fires for each predicate in z.\n\u2022 Pred contains features {Pred[\u03b1(p)] : p \u2208 P}, each of which fires on \u03b1(p), the abstraction of predicate p, where\n\u03b1(p) = { \u2217 : t if p = x : t p otherwise.\n(67)\nThe purpose of the abstraction is to abstract away the details of concrete values such as TX = Texas : state.\n\u2022 PredRel contains features {PredRel[\u03b1(p),q] : p \u2208 P,q \u2208 ({\u2199,\u2198} \u00d7 R)\u2217}. A feature fires when a node x has predicate p and is connected via some path q = (d1, r1), . . . , (dm, rm) to the lowest\ndescendant node y with the property that each node between x and y has a null predicate. Each (d, r) on the path represents an edge labeled with relation r connecting to a left (d =\u2199) or right (d =\u2198) child. If x has no children, then m = 0. The most common case is when m = 1, but m = 2 also occurs with the aggregate and execute relations (e.g., PredRel[count,\u2198 11\u2198 \u03a3] fires for Figure 5(a)).\n\u2022 PredRelPred contains features {PredRelPred[\u03b1(p),q, \u03b1(p\u2032)] : p, p\u2032 \u2208 P,q \u2208 ({\u2199,\u2198} \u00d7 R)\u2217}, which are the same as PredRel, except that we include both the predicate p of x and the predicate p\u2032 of the descendant node y. These features do not fire if m = 0.\n\u2022 TriggerPred contains features {TriggerPred[s, p] : s \u2208W \u2217, p \u2208 P}, where W = {it,Texas, . . . } is the set of words. Each of these features fires when a span of the utterance with words s triggers the predicate p\u2014more precisely, when a subtree \u3008p; e\u3009i..j exists with s = xi+1..j . Note that these lexicalized features use the predicate p rather than the abstracted version \u03b1(p).\n\u2022 TracePred contains features {TracePred[s, p, d] : s \u2208W \u2217, p \u2208 P, d \u2208 {\u2199,\u2198}}, each of which fires when a trace predicate p has been inserted over a word s. The situation is the following: Suppose we have a subtree a that ends at position k (there is a predicate in a that is triggered by a phrase with right endpoint k) and another subtree b that begins at k\u2032. Recall that in the construction mechanism (46), we can insert a trace predicate p \u2208 L( ) between the roots of a and b. Then, for every word xj in between the spans of the two subtrees (j = {k + 1, . . . , k\u2032}), the feature TracePred[xj , p, d] fires (d =\u2199 if b dominates a and d =\u2198 if a dominates b).\n\u2022 TraceRel contains features {TraceRel[s, d, r] : s \u2208 W \u2217, d \u2208 {\u2199,\u2198}, r \u2208 R}, each of which fires when some trace predicate with parent relation r has been inserted over a word s.\n\u2022 TracePredRel contains features {TracePredRel[s, p, d, r] : s \u2208 W \u2217, p \u2208 P, d \u2208 {\u2199,\u2198}, r \u2208 R}, each of which fires when a predicate p is connected via child relation r to some trace predicate over a word s.\nThese features are simple generic patterns which can be applied for modeling essentially any distribution over sequences and labeled trees\u2014there is nothing specific to DCS at all. The first half of the feature templates (PredHit, Pred, PredRel, PredRelPred) capture properties of the tree independent of the utterance, and are similar to ones used for syntactic dependency parsing. The other feature templates (TriggerPred, TracePred, TraceRel, TracePredRel) connect predicates in the DCS tree with words in the utterance, similar to those in a model of machine translation."}, {"heading": "3.2 Parameter Estimation", "text": "We have now fully specified the details of the graphical model in Figure 2: Section 3.1 described semantic parsing and Section 2 described semantic evaluation. Next, we focus on the inferential problem of estimating the parameters \u03b8 of the model from data."}, {"heading": "3.2.1 Objective Function", "text": "We assume that our learning algorithm is given a training dataset D containing question-answer pairs (x, y). Because the logical forms are unobserved, we work with log p(y | x;C, \u03b8), the marginal log-likelihood of obtaining the correct answer y given an utterance x. This marginal log-likelihood sums over all z \u2208 C(x) that evaluate to y:\nlog p(y | x;C, \u03b8) = log p(z \u2208 Cy(x) | x;C, \u03b8) (68) = A(\u03b8; x, Cy)\u2212A(\u03b8,x, C), where (69)\nCy(x) def = {z \u2208 C(x) : JzKw = y}. (70)\nHere, Cy(x) is the set of DCS trees z with denotation y.\nWe call an example (x, y) \u2208 D feasible if the candidate set of x contains a DCS tree that evaluates to y (Cy(x) 6= \u2205). Define an objective function O(\u03b8, C) containing two terms: The first term is the sum of the marginal log-likelihood over all feasible training examples. The second term is a quadratic penalty on the parameters \u03b8 with regularization parameter \u03bb. Formally:\nO(\u03b8, C) def= \u2211\n(x,y)\u2208D Cy(x)6=\u2205\nlog p(y | x;C, \u03b8)\u2212 \u03bb 2 \u2016\u03b8\u201622 (71)\n= \u2211\n(x,y)\u2208D Cy(x) 6=\u2205\n(A(\u03b8; x, Cy)\u2212A(\u03b8; x, C))\u2212 \u03bb 2 \u2016\u03b8\u201622.\nWe would like to maximize O(\u03b8, C). The log-partition function A(\u03b8; \u00b7, \u00b7) is convex, but O(\u03b8, C) is the difference of two log-partition functions and hence is not concave (nor convex). Thus we resort to gradientbased optimization. A standard result is that the derivative of the log-partition function is the expected feature vector (Wainwright and Jordan, 2008). Using this, we obtain the gradient of our objective function:\n\u2202O(\u03b8, C) \u2202\u03b8\n= \u2211\n(x,y)\u2208D Cy(x) 6=\u2205\n( Ep(z|x;Cy,\u03b8)[\u03c6(x, z)]\u2212 Ep(z|x;C,\u03b8)[\u03c6(x, z)] ) \u2212 \u03bb\u03b8. (72)\nUpdating the parameters in the direction of the gradient would move the parameters towards the DCS trees that yield the correct answer (Cy) and away from over all candidate DCS trees (C). We can use any standard numerical optimization algorithm that requires only black-box access to a gradient. Section 4.3.4 will discuss the empirical ramifications of the choice of optimization algorithm."}, {"heading": "3.2.2 Algorithm", "text": "Given a candidate set function C(x), we can optimize (71) to obtain estimates of the parameters \u03b8. Ideally, we would use C(x) = ZL(x), the candidate sets from our construction mechanism in Section 2.6, but we quickly run into the problem of computing (72) efficiently. Note that ZL(x) (defined in (44)) grows exponentially with the length of x. This by itself is not a show stopper. Our features (Section 3.1.1) decompose along the edges of the DCS tree, so it is possible to use dynamic programming6 to compute the second expectation Ep(z|x;ZL,\u03b8)[\u03c6(x, z)] of (72). The problem is computing the first expectation Ep(z|x;ZyL,\u03b8)[\u03c6(x, z)], which sums over the subset of candidate DCS trees z satisfying the constraint JzKw = y. Though this is a smaller set, there is no efficient dynamic program for this set since the constraint does not decompose along the structure of the DCS tree. Therefore, we need to approximate ZyL, and in fact, we will approximate ZL as well so that the two expectations in (72) are coherent.\nRecall that ZL(x) was built by recursively constructing a set of DCS trees Ci,j(x) for each span i..j. In our approximation, we simply use beam search, which truncates each Ci,j(x) to include the (at most) K DCS trees with the highest score \u03c6(x, z)>\u03b8. We let C\u0303i,j,\u03b8(x) denote this approximation and define the set of candidate DCS trees with respect to the beam search:\nZ\u0303L,\u03b8(x) = C\u03030,n,\u03b8(x). (73)\nWe now have a chicken-and-egg problem: If we had good parameters \u03b8, we could generate good candidate sets C(x) using beam search Z\u0303L,\u03b8(x). If we had good candidate sets C(x), we could generate good parameters by optimizing our objective O(\u03b8, C) in (71). This problem leads to a natural solution: simply alternate between the two steps (Figure 20). This procedure is not guaranteed to converge, due to the heuristic nature of the beam search, but we have found it to be convergent in practice.\n6 The state of the dynamic program would be the span i..j and the head predicate over that span.\nFinally, we use the trained model with parameters \u03b8 to answer new questions x by choosing the most likely answer y, summing out the latent logical form z:\nF\u03b8(x) def = argmax\ny p(y | x; \u03b8, Z\u0303L,\u03b8) (74)\n= argmax y \u2211 z\u2208Z\u0303L,\u03b8(x)\nJzKw=y\np(z | x; \u03b8, Z\u0303L,\u03b8). (75)"}, {"heading": "4 Experiments", "text": "We have now completed the conceptual part of this article\u2014using DCS trees to represent logical forms (Section 2), and learning a probabilistic model over these trees (Section 3). In this section, we evaluate and study our approach empirically. Our main result is that our system obtains higher accuracies than existing systems, despite requiring no annotated logical forms."}, {"heading": "4.1 Experimental Setup", "text": "We first describe the datasets (Section 4.1.1) that we use to train and evaluate our system. We then mention various choices in the model and learning algorithm (Section 4.1.2). One of these choices is the lexical triggers, which is further discussed in Section 4.1.3."}, {"heading": "4.1.1 Datasets", "text": "We tested our methods on two standard datasets, referred to in this article as Geo and Jobs. These datasets were created by Ray Mooney\u2019s group during the 1990s and have been used to evaluate semantic parsers for over a decade.\nUS Geography The Geo dataset, originally created by Zelle and Mooney (1996), contains 880 questions about US Geography and a database of facts encoded in Prolog. The questions in Geo ask about general properties (e.g., area, elevation, population) of geographical entities (e.g., cities, states, rivers, mountains). Across all the questions, there are 280 word types, and the length of an utterance ranges from 4 to 19 words, with an average of 8.5 words. The questions involve conjunctions, superlatives, negation, but no generalized quantification. Each question is annotated with a logical form in Prolog, for example:\nUtterance: What is the highest point in Florida? Logical form: answer(A,highest(A,(place(A),loc(A,B),const(B,stateid(florida)))))\nSince our approach learns from answers, not logical forms, we evaluated the annotated logical forms on the provided database to obtain the correct answers.\nRecall that a world/database w maps each predicate p \u2208 P to a set of tuples w(p). Some predicates contain the set of tuples explicitly (e.g., mountain); others can be derived (e.g., higher takes two entities x and y\nand returns true if elevation(x) > elevation(y)). Other predicates are higher-order (e.g., sum, highest) in that they take other predicates as arguments. We do not use the provided domain-specific higher-order predicates (e.g., highest), but rather provide domain-independent higher-order predicates (e.g., argmax) and the ordinary domain-specific predicates (e.g., elevation). This provides more compositionality and therefore better generalization. Similarly, we use more and elevation instead of higher. Altogether, P contains 43 predicates plus one predicate for each value (e.g., CA).\nJob Queries The Jobs dataset (Tang and Mooney, 2001) contains 640 natural language queries about job postings. Most of the questions ask for jobs matching various criteria: job title, company, recruiter, location, salary, languages and platforms used, areas of expertise, required/desired degrees, and required/desired years of experience. Across all utterances, there are 388 word types, and the length of an utterance ranges from 2 to 23 words, with an average of 9.8 words. The utterances are mostly based on conjunctions of criteria, with a sprinkling of negation and disjunction. Here is an example:\nUtterance: Are there any jobs using Java that are not with IBM? Logical form: answer(A,(job(A),language(A,\u2019java\u2019),\u00accompany(A,\u2019IBM\u2019)))\nThe Jobs dataset comes with a database, which we can use as the world w. However, when the logical forms are evaluated on this database, close to half of the answers are empty (no jobs match the requested criteria). Therefore, there is a large discrepancy between obtaining the correct logical form (which has been the focus of most work on semantic parsing) and obtaining the correct answer (our focus).\nTo bring these two into better alignment, we generated a random database as follows: We created m = 100 jobs. For each job j, we go through each predicate p (e.g., company) that takes two arguments, a job and a target value. For each of the possible target values v, we add (j, v) to w(p) independently with probability \u03b1 = 0.8. For example, for p = company, j = job37, we might add (job37, IBM) to w(company). The result is a database with a total of 23 predicates (which includes the domain-independent ones) in addition to the value predicates (e.g., IBM).\nThe goal of using randomness is to ensure that two different logical forms will most likely yield different answers. For example, consider two logical forms:\nz1 = \u03bbj.job(j) \u2227 company(j, IBM), (76) z2 = \u03bbj.job(j) \u2227 language(j, Java). (77)\nUnder the random construction, the denotation of z1 is S1, a random subset of the jobs, where each job is included in S1 independently with probability \u03b1, and the denotation of z2 is S2, which has the same distribution as S1 but importantly is independent of S1. Therefore, the probability that S1 = S2 is [\u03b1\n2 + (1\u2212\u03b1)2]m, which is exponentially small in m. This construction yields a world that is not entirely \u201crealistic\u201d (a job might have multiple employers), but it ensures that if we get the correct answer, we probably also obtain the correct logical form."}, {"heading": "4.1.2 Settings", "text": "There are a number of settings which control the tradeoffs between computation, expressiveness, and generalization power of our model, shown below. For now, we will use generic settings chosen rather crudely; Section 4.3.4 will explore the effect of changing these settings.\nLexical Triggers The lexical triggers L (Section 2.6.1) define the set of candidate DCS trees for each utterance. There is a tradeoff between expressiveness and computational complexity: The more triggers we have, the more DCS trees we can consider for a given utterance, but then either the candidate sets become too large or beam search starts dropping the good DCS trees. Choosing lexical triggers is important and requires additional supervision (Section 4.1.3).\nFeatures Our probabilistic semantic parsing model is defined in terms of feature templates (Section 3.1.1). Richer features increase expressiveness but also might lead to overfitting. By default, we include all the feature templates.\nNumber of training examples (n) An important property of any learning algorithm is its sample complexity\u2014 how many training examples are required to obtain a certain level of accuracy? By default, all training examples are used.\nNumber of training iterations (T ) Our learning algorithm (Figure 20) alternates between updating candidate sets and updating parameters for T iterations. We use T = 5 as the default value.\nBeam size (K) The computation of the candidate sets in Figure 20 is based on beam search where each intermediate state keeps at most K DCS trees. The default value is K = 100.\nOptimization algorithm To optimize an the objective function O(\u03b8, C) our default is to use the standard L-BFGS algorithm (Nocedal, 1980) with a backtracking line search for choosing the step size.\nRegularization (\u03bb) The regularization parameter \u03bb > 0 in the objective function O(\u03b8, C) is another knob for controlling the tradeoff between fitting and overfitting. The default is \u03bb = 0.01."}, {"heading": "4.1.3 Lexical Triggers", "text": "The lexical trigger set L (Section 2.6.1) is a set of entries (s, p), where s is a sequence of words and p is a predicate. We run experiments on two sets of lexical triggers: base triggers Lb and augmented triggers Lb+p.\nBase Triggers The base trigger set Lb includes three types of entries:\n\u2022 Domain-independent triggers: For each domain-independent predicate (e.g., argmax), we manually specify a few words associated with that predicate (e.g., most). The full list is shown at the top of Figure 21.\n\u2022 Values: For each value x that appears in the world (specifically, x \u2208 vj \u2208 w(p) for some tuple v, index j, and predicate p), Lb contains an entry (x, x) (e.g., (Boston,Boston : city)). Note that this rule implicitly specifies an infinite number of triggers.\nRegarding predicate names, we do not add entries such as (city, city), because we want our system to be language-independent. In Turkish, for instance, we would not have the luxury of lexicographical cues that associate city with ehir. So we should think of the predicates as just symbols predicate1, predicate2, etc. On the other hand, values in the database are generally proper nouns (e.g., city names) for which there are generally strong cross-linguistic lexicographic similarities.\n\u2022 Part-of-speech (POS) triggers:7 For each domain-specific predicate p, we specify a set of part-of-speech tags T . Implicitly, Lb contains all pairs (x, p) where the word x has a POS tag t \u2208 T . For example, for city, we would specify nn and nns, which means that any word which is a singular or plural common noun triggers the predicate city. Note that city triggers city as desired, but state also triggers city.\nThe POS triggers for Geo and Jobs domains are shown in the left side of Figure 21. Note that that some predicates such as traverse and loc are not associated with any POS tags. Predicates corresponding to verbs and prepositions are not included as overt lexical triggers, but rather included as trace predicates L( ). In constructing the logical forms, nouns and adjectives serve as anchor points. Trace predicates can be inserted in between these anchors. This strategy is more flexible than requiring each predicate to spring from some word.\n7 To perform POS tagging, we used the Berkeley Parser (Petrov et al., 2006), trained on the WSJ Treebank (Marcus et al., 1993) and the Question Treebank (Judge et al., 2006)\u2014thanks to Slav Petrov for providing the trained grammar.\nAugmented Triggers We now define the augmented trigger set Lb+p, which contains more domainspecific information than Lb. Specifically, for each domain-specific predicate (e.g., city), we manually specify a single prototype word (e.g., city) associated with that predicate. Under Lb+p, city would trigger only city because city is a prototype word, but town would trigger all the nn predicates (city, state, country, etc.) because it is not a prototype word.\nPrototype triggers require only a modest amount of domain-specific supervision (see the right side of Figure 21 for the entire list for Geo and Jobs). In fact, as we\u2019ll see in Section 4.2, prototype triggers are not absolutely required to obtain good accuracies, but they give an extra boost and also improve computational efficiency by reducing the set of candidate DCS trees.\nFinally, we use a small set of rules that expand morphology (e.g., largest is mapped to most large). To determine triggering, we stem all words using the Porter stemmer Porter (1980), so that mountains triggers the same predicates as mountain."}, {"heading": "4.2 Comparison with Other Systems", "text": "We now compare our approach with existing methods (Section 4.2). We used the same training-test splits as Zettlemoyer and Collins (2005) (600 training and 280 test examples for Geo, 500 training and 140 test examples for Jobs). For development, we created five random splits of the training data. For each split, we\nput 70% of the examples into a development training set and the remaining 30% into a development test set. The actual test set was only used for obtaining final numbers."}, {"heading": "4.2.1 Systems that Learn from Question-Answer Pairs", "text": "We first compare our system (henceforth, LJK11) with Clarke et al. (2010) (henceforth, CGCR10), which is most similar to our work in that it also learns from question-answer pairs without using annotated logical forms. CGCR10 works with the FunQL language and casts semantic parsing as integer linear programming (ILP). In each iteration, the learning algorithm solves the ILP to predict the logical form for each training example. The examples with correct predictions are fed to a structural SVM and the model parameters are updated.\nThough similar in spirit, there are some important differences between CGCR10 and our approach. They use ILP instead of beam search and structural SVM instead of log-linear models, but the main difference is which examples are used for learning. Our approach learns on any feasible example (Section 3.2.1), one where the candidate set contains a logical form that evaluates to the correct answer. CGCR10 uses a much more stringent criterion: the highest scoring logical form must evaluate to the correct answer. Therefore, for their algorithm to progress, the model already must be non-trivially good before learning even starts. This is reflected in the amount of prior knowledge and initialization that CGCR10 employs before learning starts: WordNet features, and syntactic parse trees, and a set of lexical triggers with 1.42 words per non-value predicate. Our system with base triggers requires only simple indicator features, POS tags, and 0.5 words per non-value predicate.\nCGCR10 created a version of Geo which contains 250 training and 250 test examples. Table 2 compares the empirical results on this split. We see that our system (LJK11) with base triggers significantly outperforms CGCR10 (84% over 73.2%), and it even outperforms the version of CGCR10 that is trained using logical forms (84.0% over 80.4%). If we use augmented triggers, we widen the gap by another 3.6%.8"}, {"heading": "4.2.2 State-of-the-Art Systems", "text": "We now compare our system (LJK11) with state-of-the-art systems, which all require annotated logical forms (except Precise). Here is a brief overview of the systems:\n\u2022 Cocktail (Tang and Mooney, 2001) uses inductive logic programming to learn rules for driving the decisions of a shift-reduce semantic parser. It assumes that a lexicon (mapping from words to predicates) is provided.\n\u2022 Precise (Popescu et al., 2003) does not use learning, but instead relies on matching words to strings in the database using various heuristics based on WordNet and the Charniak parser. Like our work, it also uses database type constraints to rule out spurious logical forms. One of the unique features of Precise is that it has 100% precision\u2014it refuses to parse an utterance which it deems semantically intractable.\n8Note that the numbers for LJK11 differ from those presented in Liang et al. (2011), which reports results based on 10 different splits rather than the setup used by CGCR10.\n\u2022 Scissor (Ge and Mooney, 2005) learns a generative probabilistic model that extends the Collins models (Collins, 1999) with semantic labels, so that syntactic and semantic parsing can be done jointly.\n\u2022 Silt (Kate et al., 2005) learns a set of transformation rules for mapping utterances to logical forms.\n\u2022 Krisp (Kate and Mooney, 2006) uses SVMs with string kernels to drive the local decisions of a chartbased semantic parser.\n\u2022 Wasp (Wong and Mooney, 2006) uses log-linear synchronous grammars to transform utterances into logical forms, starting with word alignments obtained from the IBM models.\n\u2022 \u03bb-Wasp (Wong and Mooney, 2007) extends Wasp to work with logical forms that contain bound variables (lambda abstraction).\n\u2022 LNLZ08 (Lu et al., 2008) learns a generative model over hybrid trees, which are logical forms augmented with natural language words. IBM model 1 is used to initialize the parameters, and a discriminative reranking step works on top of the generative model.\n\u2022 ZC05 (Zettlemoyer and Collins, 2005) learns a discriminative log-linear model over CCG derivations. Starting with a manually-constructed domain-independent lexicon, the training procedure grows the lexicon by adding lexical entries derived from associating parts of an utterance with parts of the annotated logical form.\n\u2022 ZC07 (Zettlemoyer and Collins, 2007) extends ZC05 with extra (disharmonic) combinators to increase the expressive power of the model.\n\u2022 KZGS10 (Kwiatkowski et al., 2010) uses a restricted higher-order unification procedure, which iteratively breaks up a logical form into smaller pieces. This approach gradually adds lexical entries of increasing generality, thus obviating the need for the manually-specified templates used by ZC05 and ZC07 for growing the lexicon. IBM model 1 is used to initialize the parameters.\n\u2022 KZGS11 (Kwiatkowski et al., 2011) extends KZGS10 by factoring lexical entries into a template plus a sequence of predicates which fill the slots of the template. This factorization improves generalization.\nWith the exception of Precise, all other systems require annotated logical forms, whereas our system learns from annotated answers. On the other hand, many of the later systems require essentially no manually-crafted lexicon and instead rely on unsupervised word alignment (e.g., Wong and Mooney (2006, 2007); Kwiatkowski et al. (2010, 2011)) and/or lexicon learning (e.g., Zettlemoyer and Collins (2005, 2007); Kwiatkowski et al. (2010, 2011)). We cannot use these automatic techniques because they require annotated logical forms. Our system instead relies on lexical triggers, which does require some manual effort. These lexical triggers play a crucial role in the initial stages of learning, because they constrain the set of candidate DCS trees; otherwise we would face a hopelessly intractable search problem.\nTable 3 shows the results for Geo. Semantic parsers are typically evaluated on the accuracy of the logical forms: precision (the accuracy on utterances which are successfully parsed) and recall (the accuracy on all utterances). We only focus on recall (a lower bound on precision) and simply use the word accuracy to refer to recall.9 Our system is evaluated only on answer accuracy because our model marginalizes out the latent logical form. All other systems are evaluated on the accuracy of logical forms. To calibrate, we also evaluated KZGS10 on answer accuracy and found that it was quite similar to its logical form accuracy (88.9% versus 88.2%).10 This does not imply that our system would necessarily have a high logical form accuracy because multiple logical forms can produce the same answer, and our system does not receive a training signal to tease them apart. Even with only base triggers, our system (LJK11) outperforms all but two of the systems,\n9 Our system produces a logical form for every utterance, and thus our precision is the same as our recall. 10The 88.2% corresponds to 87.9% in Kwiatkowski et al. (2010). The difference is due to using a slightly newer version of\nthe code.\nfalling short of KZGS10 by only one point (87.9% versus 88.9%).11 With augmented triggers, our system takes the lead (91.4% over 88.9%).\nTable 4 shows the results for Jobs. The two learning-based systems (Cocktail and ZC05) are actually outperformed by Precise, which is able to use strong database type constraints. By exploiting this information and doing learning, we obtain the best results."}, {"heading": "4.3 Empirical Properties", "text": "In this section, we try to gain intuition into properties of our approach. All experiments in this section are performed on random development splits. Throughout this section, \u201caccuracy\u201d means development test accuracy."}, {"heading": "4.3.1 Error Analysis", "text": "To understand the type of errors our system makes, we examined one of the development runs, which had 34 errors on the test set. We classified these errors into the following categories (the number of errors in each category is shown in parentheses):\n11The 87.9% and 91.4% correspond to 88.6% and 91.1% in Liang et al. (2011). These differences are due to minor differences in the code.\n\u2022 Incorrect POS tags (8): Geo is out-of-domain for our POS tagger, so the tagger makes some basic errors which adversely affect the predicates that can be lexically triggered. For example, the question What states border states . . . is tagged as wp vbz nn nns . . . , which means that the first states cannot trigger state. In another example, major river is tagged as nnp nnp, so these cannot trigger the appropriate predicates either, and thus the desired DCS tree cannot even be constructed.\n\u2022 Non-projectivity (3): The candidate DCS trees are defined by a projective construction mechanism (Section 2.6) that prohibits edges in the DCS tree from crossing. This means we cannot handle utterances such as largest city by area, since the desired DCS tree would have city dominating area dominating argmax. To construct this DCS tree, we could allow local reordering of the words.\n\u2022 Unseen words (2): We never saw at least or sea level at training time. The former has the correct lexical trigger, but not a sufficiently large feature weight (0) to encourage its use. For the latter, the problem is more structural: We have no lexical triggers for 0 : length, and only adding more lexical triggers can solve this problem.\n\u2022 Wrong lexical triggers (7): Sometimes the error is localized to a single lexical trigger. For example, the model incorrectly thinks Mississippi is the state rather than the river, and that Rochester is the city in New York rather than the name, even though there are contextual cues to disambiguate in these cases.\n\u2022 Extra words (5): Sometimes, words trigger predicates that should be ignored. For example, for population density, the first word triggers population, which is used rather than density.\n\u2022 Over-smoothing of DCS tree (9): The first half of our features (Figure 19) are defined on the DCS tree alone; these produce a form of smoothing that encourages DCS trees to look alike regardless of the words. We found several instances where this essential tool for generalization went too far. For example, in state of Nevada, the trace predicate border is inserted between the two nouns, because it creates a structure more similar to that of the common question what states border Nevada?"}, {"heading": "4.3.2 Visualization of Features", "text": "Having analyzed the behavior of our system for individual utterances, let us move from the token level to the type level and analyze the learned parameters of our model. We do not look at raw feature weights, because there are complex interactions between them not represented by examining individual weights. Instead, we look at expected feature counts, which we think are more interpretable.\nConsider a group of \u201ccompeting\u201d features J , for example J = {TriggerPred[city, p] : p \u2208 P}. We define a distribution q(\u00b7) over J as follows:\nq(j) = Nj\u2211\nj\u2032\u2208J Nj\u2032 , where (78) Nj = \u2211\n(x,y)\u2208D\nEp(z|x,Z\u0303L,\u03b8,\u03b8)[\u03c6(x, z)].\nThink of q(j) as a marginal distribution (since all our features are positive) which represents the relative frequencies with which the features j \u2208 J fire with respect to our training dataset D and trained model p(z | x, Z\u0303L,\u03b8, \u03b8). To appreciate the difference between what this distribution and raw feature weights capture, suppose we had two features, j1 and j2, which are identical (\u03c6(x, z)j1 \u2261 \u03c6(x, z)j2). The weights would be split across the two features, but the features would have the same marginal distribution (q(j1) = q(j2)). Figure 22 shows some of the feature distributions learned."}, {"heading": "4.3.3 Learning, Search, Bootstrapping", "text": "Recall from Section 3.2.1 that a training example is feasible (with respect to our beam search) if the resulting candidate set contains a DCS tree with the correct answer. Infeasible examples are skipped, but an example\nmay become feasible in a later iteration. A natural question is how many training examples are feasible in each iteration. Figure 23 shows the answer: Initially, only around 30% of the training examples are feasible; this is not surprising given that all the parameters are zero, so our beam search is essentially unguided. However, training on just these examples improves the parameters, and over the next few iterations, the number of feasible examples steadily increases to around 97%.\nIn our algorithm, learning and search are deeply intertwined. Search is of course needed to learn, but learning also improves search. The general approach is similar in spirit to Searn (Daume et al., 2009), although we do not have any formal guarantees at this point.\nOur algorithm also has a bootstrapping flavor. The \u201ceasy\u201d examples are processed first, where easy is defined by the ability of beam search to generate the correct answer. This bootstrapping occurs quite naturally: Unlike most bootstrapping algorithms, we do not have to set a confidence threshold for accepting new training examples, something that can be quite tricky to do. Instead, our threshold falls out of the discrete nature of the beam search."}, {"heading": "4.3.4 Effect of Various Settings", "text": "So far, we have used our approach with default settings (Section 4.1.2). How sensitive is the approach to these choices? Table 5 shows the impact of the feature templates. Figure 24 shows the effect of the number of training examples, number of training iterations, beam size, and regularization parameter. The overall conclusion is that there are no big surprises: Our default settings could be improved on slightly, but these differences are often smaller than the variation across different development splits.\nWe now consider the choice of optimization algorithm to update the parameters given candidate sets (see Figure 20). Thus far, we have been using L-BFGS (Nocedal, 1980), which is a batch algorithm: Each iteration, we construct the candidate sets C(t)(x) for all the training examples before solving the optimization problem argmax\u03b8O(\u03b8, C(t)). We now consider an online algorithm, stochastic gradient descent (SGD) (Robbins and Monro, 1951), which updates the parameters after computing the candidate set for each example. In particular, we iteratively scan through the training examples in a random order. For each example (x, y), we compute the candidate set using beam search. We then update the parameters in the direction of the gradient of the marginal log-likelihood for that example (see (72)) with step size t\u2212\u03b1:\n\u03b8(t+1) \u2190 \u03b8(t) + t\u2212\u03b1 ( \u2202 log p(y | x; Z\u0303L,\u03b8(t) , \u03b8)\n\u2202\u03b8\n\u2223\u2223\u2223 \u03b8=\u03b8(t) ) . (79)\nThe trickiest aspect of using SGD is selecting the correct step size: a small \u03b1 leads to quick progress but also instability; a large \u03b1 leads to the opposite. We let L-BFGS and SGD both take the same number of iterations (passes over the training set). Figure 25 shows that a very small value of \u03b1 (less than 0.2) is best for our task, even though only values between 0.5 and 1 guarantee convergence. Our setting is slightly different since we are interleaving the SGD updates with beam search, which might also lead to unpredictable consequences. Furthermore, the non-convexity of the objective function exacerbates the unpredictability (Liang and Klein, 2009). Nonetheless, with a proper \u03b1, SGD converges much faster than L-BFGS and even to a slightly better solution."}, {"heading": "5 Discussion", "text": "The work we have presented in this article addresses three important themes. The first theme is semantic representation (Section 5.1): How do we parametrize the mapping from utterances to their meanings? The second theme is program induction (Section 5.2): How do we efficiently search through the space of logical structures given a weak feedback signal? Finally, the last theme is grounded language (Section 5.3): How do we use constraints from the world to guide learning of language and conversely use language to interact with the world?"}, {"heading": "5.1 Semantic Representation", "text": "Since the late nineteenth century, philosophers and linguists have worked on elucidating the relationship between an utterance and its meaning. One of the pillars of formal semantics is Frege\u2019s principle of compositionality, that the meaning of an utterance is built by composing the meaning of its parts. What these parts are and how they are composed is the main question. The dominant paradigm, which stems from the seminal work of Richard Montague in the early 1970s (Montague, 1973), states that parts are lambda calculus expressions that correspond to syntactic constituents, and composition is function application.\nConsider the compositionality principle from a statistical point of view, where we construe compositionality as factorization. Factorization, the way a statistical model breaks into features, is necessary for generalization: It enables us to learn from previously seen examples and interpret new utterances. Projecting back to Frege\u2019s original principle, the parts are the features (Section 3.1.1), and composition is the DCS construction mechanism (Section 2.6) driven by parameters learned from training examples.\nTaking the statistical view of compositionality, finding a good semantic representation becomes designing a good statistical model. But statistical modeling must also deal with the additional issue of language acquisition or learning, which presents complications: In absorbing training examples, our learning algorithm must inevitably traverse through intermediate models that are wrong or incomplete. The algorithms must therefore tolerate this degradation, and do so in a computationally efficient way. For example, in the line of work on learning probabilistic CCGs (Zettlemoyer and Collins, 2005, 2007; Kwiatkowski et al., 2010), many candidate lexical entries must be entertained for each word even when polysemy does not actually exist (Section 2.6.4).\nTo improve generalization, the lexicon can be further factorized (Kwiatkowski et al., 2011), but this is all done within the constraints of CCG. DCS represents a departure from this tradition, which replaces a heavily-lexicalized constituency-based formalism with a lightly-lexicalized dependency-based formalism. We can think of DCS as a shift in linguistic coordinate systems, which makes certain factorizations or features more accessible. For example, we can define features on paths between predicates in a DCS tree which capture certain lexical patterns much more easily than in a lambda calculus expression or a CCG derivation.\nDCS has a family resemblance to a semantic representation called natural logic form (Alshawi et al., 2011), which is also motivated by the benefits of working with dependency-based logical forms. The goals and the detailed structure of the two semantic formalisms are different, however. Alshawi et al. (2011) focuses on parsing complex sentences in an open domain where a structured database or world does not\nexist. While they do equip their logical forms with a full model-theoretic semantics, the logical forms are actually closer to dependency trees: quantifier scope is left unspecified, and the predicates are simply the words.\nPerhaps not immediately apparent is the fact that DCS draws an important idea from Discourse Representation Theory (DRT) (Kamp and Reyle, 1993)\u2014not from the treatment of anaphora and presupposition which it is known for, but something closer to its core. This is the idea of having a logical form where all variables are existentially quantified and constraints are combined via conjunction\u2014a Discourse Representation Structure (DRS) in DRT, or a basic DCS tree with only join relations. Computationally, these logical structures conveniently encode CSPs. Linguistically, it appears that existential quantifiers play an important role and should be treated specially (Kamp and Reyle, 1993). DCS takes this core and focuses on semantic compositionality and computation, while DRT focuses more on discourse and pragmatics.\nIn addition to the statistical view of DCS as a semantic representation, it is useful to think about DCS from the perspective of programming language design. Two programming languages can be equally expressive, but what matters is how simple it is to express a desired type of computation in a given language. In some sense, we designed the DCS formal language to make it easy to represent computations expressed by natural language. An important part of DCS is the mark-execute construct, a uniform framework for dealing with the divergence between syntactic and semantic scope. This construct allows us to build simple DCS tree structures and still handle the complexities of phenomena such as quantifier scope variation. Compared to lambda calculus, think of DCS as a higher-level programming language tailored to natural language, which results in simpler programs (DCS trees). Simpler programs are easier for us to work with and easier for an algorithm to learn."}, {"heading": "5.2 Program Induction", "text": "Searching over the space of programs is challenging. This is the central computational challenge of program induction, that of inferring programs (logical forms) from their behavior (denotations). This problem has been tackled by different communities in various forms: program induction in AI, programming by demonstration in HCI, and program synthesis in programming languages. The core computational difficulty is that the supervision signal\u2014the behavior\u2014is a complex function of the program which cannot be easily inverted. What program generated the output Arizona, Nevada, and Oregon?\nPerhaps somewhat counterintuitively, program induction is easier if we infer programs for not a single task but for multiple tasks. The intuition is that when the tasks are related, the solution to one task can help another task, both computationally in navigating the program space and statistically in choosing the appropriate program if there are multiple feasible possibilities (Liang et al., 2010). In our semantic parsing work, we want to infer a logical form for each utterance (task). Clearly the tasks are related because they use the same vocabulary to talk about the same domain.\nNatural language also makes program induction easier by providing side information (words) which can be used to guide the search. There have been several papers that induce programs in this setting: Eisenstein et al. (2009) induces conjunctive formulae from natural language instructions, Piantadosi et al. (2008) induces first-order logic formulae using CCG in a small domain assuming observed lexical semantics, and Clarke et al. (2010) induces logical forms in semantic parsing. In the ideal case, the words would determine the program predicates, and the utterance would determine the entire program compositionally. But of course, this mapping is not given and must be learned."}, {"heading": "5.3 Grounded Language", "text": "In recent years, there has been an increased interest in connecting language with the world.12 One of the primary issues in grounded language is alignment\u2014figuring out what fragments of utterances refer to what aspects of the world. In fact, semantic parsers trained on examples of utterances and annotated logical form\n12Here, world need not refer to the physical world, but could be any virtual world. The point is that the world has non-trivial structure and exists extra-linguistically.\n(those discussed in Section 4.2.2) need to solve the task of aligning words to predicates. Some can learn from utterances paired with a set of logical forms, one of which is correct (Kate and Mooney, 2007; Chen and Mooney, 2008). Liang et al. (2009) tackles the even more difficult alignment problem of segmenting and aligning a discourse to a database of facts, where many parts on either side are irrelevant.\nIf we know how the world relates to language, we can leverage structure in the world to guide the learning and interpretation of language. We saw that type constraints from the database/world reduces the set of candidate logical forms and lead to more accurate systems (Popescu et al., 2003; Liang et al., 2011). Even for syntactic parsing, information from the denotation of an utterance can be helpful (Schuler, 2003).\nOne of the exciting aspects about using the world for learning language is that it opens the door to many new types of supervision. We can obtain answers given a world, which are cheaper to obtain than logical forms (Clarke et al., 2010; Liang et al., 2011). Goldwasser et al. (2011) learns a semantic parser based on bootstrapping and estimating the confidence of its own predictions. Artzi and Zettlemoyer (2011) learns a semantic parser not from annotated logical forms, but from user interactions with a dialog system. Branavan et al. (2009, 2010, 2011) use reinforcement learning to follow natural language instructions from a reward signal. In general, supervision from the world is indirectly related to the learning task, but it is often much more plentiful and natural to obtain.\nThe benefits can also flow from language to the world. For example, previous work learned to interpret language to troubleshoot a Windows machine (Branavan et al., 2009, 2010), win a game of Civilization (Branavan et al., 2011), play a legal game of solitaire (Eisenstein et al., 2009; Goldwasser and Roth, 2011), and navigate a map by following directions (Vogel and Jurafsky, 2010; Chen and Mooney, 2011). Even when the objective in the world is defined independently of language (e.g., in Civilization), language can provide a useful bias towards the non-linguistic end goal."}, {"heading": "5.4 Conclusions", "text": "The main conceptual contribution of this article is a new semantic formalism, dependency-based compositional semantics (DCS), which has favorable linguistic, statistical, and computational properties. This enabled us to learn a semantic parser from question-answer pairs where the intermediate logical form (a DCS tree) is induced in an unsupervised manner. Our final question-answering system was able to outperform current state-of-the-art systems despite requiring no annotated logical forms.\nThere is currently a significant conceptual gap between our question-answering system (which are natural language interfaces to databases) and open-domain question-answering systems. The former focuses on understanding a question compositionally and computing the answer compositionally, while the latter focuses on retrieving and ranking answers from a large unstructured textual corpus. The former has depth; the latter has breadth. Developing methods that can both model the semantic richness of language and scale up to an open-domain setting remains an open challenge.\nWe believe that it is possible to push our approach in the open-domain direction. Neither DCS nor the learning algorithm is tied to having a clean rigid database, which could instead be a database generated from a noisy information extraction process. The key is to drive the learning with the desired behavior, the question-answer pairs. The latent variable is the logical form or program, which just tries to compute the desired answer by piecing together whatever information is available. Of course, there are many open challenges ahead, but with the proper combination of linguistic, statistical, and computational insight, we hope to eventually build systems with both breadth and depth.\nAcknowledgments We thank Luke Zettlemoyer and Tom Kwiatkowski for providing us with data and answering questions. The first author was supported by an NSF Graduate Research Fellowship."}], "references": [{"title": "Deterministic statistical mapping of sentences to underspecified semantics", "author": ["H. Alshawi", "P. Chang", "M. Ringgaard"], "venue": "In International Conference on Compositional Semantics (IWCS),", "citeRegEx": "Alshawi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Alshawi et al\\.", "year": 2011}, {"title": "Natural language interfaces to databases an introduction", "author": ["I. Androutsopoulos", "G.D. Ritchie", "P. Thanisch"], "venue": "Journal of Natural Language Engineering,", "citeRegEx": "Androutsopoulos et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Androutsopoulos et al\\.", "year": 1995}, {"title": "Bootstrapping semantic parsers from conversations", "author": ["Y. Artzi", "L. Zettlemoyer"], "venue": "In Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Artzi and Zettlemoyer.,? \\Q2011\\E", "shortCiteRegEx": "Artzi and Zettlemoyer.", "year": 2011}, {"title": "A controlled fragment of DRT", "author": ["J. Bos"], "venue": "In Workshop on Controlled Natural Language,", "citeRegEx": "Bos.,? \\Q2009\\E", "shortCiteRegEx": "Bos.", "year": 2009}, {"title": "Reinforcement learning for mapping instructions to actions", "author": ["S. Branavan", "H. Chen", "L.S. Zettlemoyer", "R. Barzilay"], "venue": "In Association for Computational Linguistics and International Joint Conference on Natural Language Processing (ACL-IJCNLP), Singapore,", "citeRegEx": "Branavan et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Branavan et al\\.", "year": 2009}, {"title": "Reading between the lines: Learning to map high-level instructions to commands. In Association for Computational Linguistics (ACL)", "author": ["S. Branavan", "L. Zettlemoyer", "R. Barzilay"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Branavan et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Branavan et al\\.", "year": 2010}, {"title": "Learning to win by reading manuals in a Monte-Carlo framework. In Association for Computational Linguistics (ACL)", "author": ["S. Branavan", "D. Silver", "R. Barzilay"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Branavan et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Branavan et al\\.", "year": 2011}, {"title": "Type-Logical Semantics", "author": ["B. Carpenter"], "venue": null, "citeRegEx": "Carpenter.,? \\Q1998\\E", "shortCiteRegEx": "Carpenter.", "year": 1998}, {"title": "Learning to sportscast: A test of grounded language acquisition", "author": ["D.L. Chen", "R.J. Mooney"], "venue": "In International Conference on Machine Learning (ICML),", "citeRegEx": "Chen and Mooney.,? \\Q2008\\E", "shortCiteRegEx": "Chen and Mooney.", "year": 2008}, {"title": "Learning to interpret natural language navigation instructions from observations", "author": ["D.L. Chen", "R.J. Mooney"], "venue": "In Association for the Advancement of Artificial Intelligence (AAAI),", "citeRegEx": "Chen and Mooney.,? \\Q2011\\E", "shortCiteRegEx": "Chen and Mooney.", "year": 2011}, {"title": "Driving semantic parsing from the world\u2019s response", "author": ["J. Clarke", "D. Goldwasser", "M. Chang", "D. Roth"], "venue": "In Computational Natural Language Learning (CoNLL),", "citeRegEx": "Clarke et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Clarke et al\\.", "year": 2010}, {"title": "Head-Driven Statistical Models for Natural Language Parsing", "author": ["M. Collins"], "venue": "PhD thesis, University of Pennsylvania,", "citeRegEx": "Collins.,? \\Q1999\\E", "shortCiteRegEx": "Collins.", "year": 1999}, {"title": "Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints", "author": ["P. Cousot", "R. Cousot"], "venue": "In Principles of Programming Languages (POPL),", "citeRegEx": "Cousot and Cousot.,? \\Q1977\\E", "shortCiteRegEx": "Cousot and Cousot.", "year": 1977}, {"title": "Search-based structured prediction", "author": ["H. Daume", "J. Langford", "D. Marcu"], "venue": "Machine Learning Journal (MLJ),", "citeRegEx": "Daume et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Daume et al\\.", "year": 2009}, {"title": "Constraint Processing", "author": ["R. Dechter"], "venue": null, "citeRegEx": "Dechter.,? \\Q2003\\E", "shortCiteRegEx": "Dechter.", "year": 2003}, {"title": "Reading to learn: Constructing features from semantic abstracts", "author": ["J. Eisenstein", "J. Clarke", "D. Goldwasser", "D. Roth"], "venue": "In Empirical Methods in Natural Language Processing (EMNLP), Singapore,", "citeRegEx": "Eisenstein et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Eisenstein et al\\.", "year": 2009}, {"title": "A statistical semantic parser that integrates syntax and semantics", "author": ["R. Ge", "R.J. Mooney"], "venue": "In Computational Natural Language Learning (CoNLL),", "citeRegEx": "Ge and Mooney.,? \\Q2005\\E", "shortCiteRegEx": "Ge and Mooney.", "year": 2005}, {"title": "Semantic mapping between natural language questions and SQL queries via syntactic pairing", "author": ["A. Giordani", "A. Moschitti"], "venue": "In International Conference on Applications of Natural Language to Information Systems,", "citeRegEx": "Giordani and Moschitti.,? \\Q2009\\E", "shortCiteRegEx": "Giordani and Moschitti.", "year": 2009}, {"title": "Learning from natural instructions", "author": ["D. Goldwasser", "D. Roth"], "venue": "In International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Goldwasser and Roth.,? \\Q2011\\E", "shortCiteRegEx": "Goldwasser and Roth.", "year": 2011}, {"title": "Confidence driven unsupervised semantic parsing. In Association for Computational Linguistics (ACL)", "author": ["D. Goldwasser", "R. Reichart", "J. Clarke", "D. Roth"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Goldwasser et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Goldwasser et al\\.", "year": 2011}, {"title": "Question-bank: creating a corpus of parse-annotated questions", "author": ["J. Judge", "A. Cahill", "J. v. Genabith"], "venue": "In International Conference on Computational Linguistics and Association for Computational Linguistics (COLING/ACL), Sydney, Australia,", "citeRegEx": "Judge et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Judge et al\\.", "year": 2006}, {"title": "From Discourse to Logic: An Introduction to the Model-theoretic Semantics of Natural Language, Formal Logic and Discourse", "author": ["H. Kamp", "U. Reyle"], "venue": "Representation Theory. Kluwer,", "citeRegEx": "Kamp and Reyle.,? \\Q1993\\E", "shortCiteRegEx": "Kamp and Reyle.", "year": 1993}, {"title": "Discourse representation theory", "author": ["H. Kamp", "J. v. Genabith", "U. Reyle"], "venue": "In Handbook of Philosophical Logic", "citeRegEx": "Kamp et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kamp et al\\.", "year": 2005}, {"title": "Using string-kernels for learning semantic parsers", "author": ["R.J. Kate", "R.J. Mooney"], "venue": "In International Conference on Computational Linguistics and Association for Computational Linguistics (COLING/ACL),", "citeRegEx": "Kate and Mooney.,? \\Q2006\\E", "shortCiteRegEx": "Kate and Mooney.", "year": 2006}, {"title": "Learning language semantics from ambiguous supervision", "author": ["R.J. Kate", "R.J. Mooney"], "venue": "In Association for the Advancement of Artificial Intelligence (AAAI),", "citeRegEx": "Kate and Mooney.,? \\Q2007\\E", "shortCiteRegEx": "Kate and Mooney.", "year": 2007}, {"title": "Learning to transform natural to formal languages", "author": ["R.J. Kate", "Y.W. Wong", "R.J. Mooney"], "venue": "In Association for the Advancement of Artificial Intelligence (AAAI),", "citeRegEx": "Kate et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kate et al\\.", "year": 2005}, {"title": "Inducing probabilistic CCG grammars from logical form with higher-order unification", "author": ["T. Kwiatkowski", "L. Zettlemoyer", "S. Goldwater", "M. Steedman"], "venue": "In Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Kwiatkowski et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kwiatkowski et al\\.", "year": 2010}, {"title": "Lexical generalization in CCG grammar induction for semantic parsing", "author": ["T. Kwiatkowski", "L. Zettlemoyer", "S. Goldwater", "M. Steedman"], "venue": "In Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Kwiatkowski et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Kwiatkowski et al\\.", "year": 2011}, {"title": "Learning Dependency-Based Compositional Semantics", "author": ["P. Liang"], "venue": "PhD thesis, University of California Berkeley at Berkeley,", "citeRegEx": "Liang.,? \\Q2011\\E", "shortCiteRegEx": "Liang.", "year": 2011}, {"title": "Online EM for unsupervised models. In North American Association for Computational Linguistics (NAACL)", "author": ["P. Liang", "D. Klein"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Liang and Klein.,? \\Q2009\\E", "shortCiteRegEx": "Liang and Klein.", "year": 2009}, {"title": "Learning semantic correspondences with less supervision", "author": ["P. Liang", "M.I. Jordan", "D. Klein"], "venue": "In Association for Computational Linguistics and International Joint Conference on Natural Language Processing (ACLIJCNLP), Singapore,", "citeRegEx": "Liang et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Liang et al\\.", "year": 2009}, {"title": "Learning programs: A hierarchical Bayesian approach", "author": ["P. Liang", "M.I. Jordan", "D. Klein"], "venue": "In International Conference on Machine Learning (ICML). Omnipress,", "citeRegEx": "Liang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Liang et al\\.", "year": 2010}, {"title": "Learning dependency-based compositional semantics. In Association for Computational Linguistics (ACL)", "author": ["P. Liang", "M.I. Jordan", "D. Klein"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Liang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Liang et al\\.", "year": 2011}, {"title": "A generative model for parsing natural language to meaning representations", "author": ["W. Lu", "H.T. Ng", "W.S. Lee", "L.S. Zettlemoyer"], "venue": "In Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Lu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lu et al\\.", "year": 2008}, {"title": "Building a large annotated corpus of English: the Penn Treebank", "author": ["M.P. Marcus", "M.A. Marcinkiewicz", "B. Santorini"], "venue": "Computational Linguistics,", "citeRegEx": "Marcus et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Marcus et al\\.", "year": 1993}, {"title": "A fully statistical approach to natural language interfaces. In Association for Computational Linguistics (ACL)", "author": ["S. Miller", "D. Stallard", "R. Bobrow", "R. Schwartz"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Miller et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Miller et al\\.", "year": 1996}, {"title": "The proper treatment of quantification in ordinary English", "author": ["R. Montague"], "venue": "In Approaches to Natural Language,", "citeRegEx": "Montague.,? \\Q1973\\E", "shortCiteRegEx": "Montague.", "year": 1973}, {"title": "Updating quasi-newton matrices with limited storage", "author": ["J. Nocedal"], "venue": "Mathematics of Computation,", "citeRegEx": "Nocedal.,? \\Q1980\\E", "shortCiteRegEx": "Nocedal.", "year": 1980}, {"title": "Learning accurate, compact, and interpretable tree annotation. In International Conference on Computational Linguistics and Association for Computational Linguistics (COLING/ACL), pages 433\u2013440", "author": ["S. Petrov", "L. Barrett", "R. Thibaux", "D. Klein"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Petrov et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Petrov et al\\.", "year": 2006}, {"title": "A Bayesian model of the acquisition of compositional semantics", "author": ["S.T. Piantadosi", "N.D. Goodman", "B.A. Ellis", "J.B. Tenenbaum"], "venue": "In Proceedings of the Thirtieth Annual Conference of the Cognitive Science Society,", "citeRegEx": "Piantadosi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Piantadosi et al\\.", "year": 2008}, {"title": "Towards a theory of natural language interfaces to databases", "author": ["A. Popescu", "O. Etzioni", "H. Kautz"], "venue": "In International Conference on Intelligent User Interfaces (IUI),", "citeRegEx": "Popescu et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Popescu et al\\.", "year": 2003}, {"title": "An algorithm for suffix stripping", "author": ["M.F. Porter"], "venue": "Program, 14:130\u2013137,", "citeRegEx": "Porter.,? \\Q1980\\E", "shortCiteRegEx": "Porter.", "year": 1980}, {"title": "A stochastic approximation method", "author": ["H. Robbins", "S. Monro"], "venue": "Annals of Mathematical Statistics,", "citeRegEx": "Robbins and Monro.,? \\Q1951\\E", "shortCiteRegEx": "Robbins and Monro.", "year": 1951}, {"title": "Using model-theoretic semantic interpretation to guide statistical parsing and word recognition in a spoken language interface. In Association for Computational Linguistics (ACL)", "author": ["W. Schuler"], "venue": "Association for Computational Linguistics,", "citeRegEx": "Schuler.,? \\Q2003\\E", "shortCiteRegEx": "Schuler.", "year": 2003}, {"title": "The Syntactic Process", "author": ["M. Steedman"], "venue": null, "citeRegEx": "Steedman.,? \\Q2000\\E", "shortCiteRegEx": "Steedman.", "year": 2000}, {"title": "Using multiple clause constructors in inductive logic programming for semantic parsing", "author": ["L.R. Tang", "R.J. Mooney"], "venue": "In European Conference on Machine Learning,", "citeRegEx": "Tang and Mooney.,? \\Q2001\\E", "shortCiteRegEx": "Tang and Mooney.", "year": 2001}, {"title": "Learning to follow navigational directions", "author": ["A. Vogel", "D. Jurafsky"], "venue": "In Association for Computational Linguistics (ACL). Association for Computational Linguistics,", "citeRegEx": "Vogel and Jurafsky.,? \\Q2010\\E", "shortCiteRegEx": "Vogel and Jurafsky.", "year": 2010}, {"title": "Graphical models, exponential families, and variational inference", "author": ["M. Wainwright", "M.I. Jordan"], "venue": "Foundations and Trends in Machine Learning,", "citeRegEx": "Wainwright and Jordan.,? \\Q2008\\E", "shortCiteRegEx": "Wainwright and Jordan.", "year": 2008}, {"title": "An efficient easily adaptable system for interpreting natural language queries", "author": ["D. Warren", "F. Pereira"], "venue": "Computational Linguistics,", "citeRegEx": "Warren and Pereira.,? \\Q1982\\E", "shortCiteRegEx": "Warren and Pereira.", "year": 1982}, {"title": "Learning for semantic parsing with statistical machine translation", "author": ["Y.W. Wong", "R.J. Mooney"], "venue": "In North American Association for Computational Linguistics (NAACL),", "citeRegEx": "Wong and Mooney.,? \\Q2006\\E", "shortCiteRegEx": "Wong and Mooney.", "year": 2006}, {"title": "Learning synchronous grammars for semantic parsing with lambda calculus. In Association for Computational Linguistics (ACL), pages 960\u2013967", "author": ["Y.W. Wong", "R.J. Mooney"], "venue": "Prague, Czech Republic,", "citeRegEx": "Wong and Mooney.,? \\Q2007\\E", "shortCiteRegEx": "Wong and Mooney.", "year": 2007}, {"title": "The lunar sciences natural language information system: Final report", "author": ["W.A. Woods", "R.M. Kaplan", "B.N. Webber"], "venue": "Technical report, BBN Report", "citeRegEx": "Woods et al\\.,? \\Q1972\\E", "shortCiteRegEx": "Woods et al\\.", "year": 1972}, {"title": "Learning to parse database queries using inductive logic proramming", "author": ["M. Zelle", "R.J. Mooney"], "venue": "In Association for the Advancement of Artificial Intelligence (AAAI),", "citeRegEx": "Zelle and Mooney.,? \\Q1996\\E", "shortCiteRegEx": "Zelle and Mooney.", "year": 1996}, {"title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars", "author": ["L.S. Zettlemoyer", "M. Collins"], "venue": "In Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Zettlemoyer and Collins.,? \\Q2005\\E", "shortCiteRegEx": "Zettlemoyer and Collins.", "year": 2005}, {"title": "Online learning of relaxed CCG grammars for parsing to logical form", "author": ["L.S. Zettlemoyer", "M. Collins"], "venue": "In Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP/CoNLL),", "citeRegEx": "Zettlemoyer and Collins.,? \\Q2007\\E", "shortCiteRegEx": "Zettlemoyer and Collins.", "year": 2007}], "referenceMentions": [{"referenceID": 51, "context": "building natural language interfaces to databases (NLIDBs) has a long history in NLP, starting from the early days of AI with systems such as Lunar (Woods et al., 1972), Chat-80 (Warren and Pereira, 1982), and many others (see Androutsopoulos et al.", "startOffset": 148, "endOffset": 168}, {"referenceID": 48, "context": ", 1972), Chat-80 (Warren and Pereira, 1982), and many others (see Androutsopoulos et al.", "startOffset": 17, "endOffset": 43}, {"referenceID": 52, "context": "One of the earliest statistical efforts was the Chill system (Zelle and Mooney, 1996), which learned a shift-reduce semantic parser.", "startOffset": 61, "endOffset": 85}, {"referenceID": 52, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 35, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 45, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 16, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 25, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 53, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 23, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 49, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 24, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 54, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 50, "context": "Since then, there has been a healthy line of work yielding increasingly more accurate semantic parsers by using new semantic representations and machine learning techniques (Zelle and Mooney, 1996; Miller et al., 1996; Tang and Mooney, 2001; Ge and Mooney, 2005; Kate et al., 2005; Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2006; Kate and Mooney, 2007; Zettlemoyer and Collins, 2007; Wong and Mooney, 2007; Kwiatkowski et al., 2010, 2011).", "startOffset": 173, "endOffset": 467}, {"referenceID": 10, "context": "In response to these concerns, researchers have recently begun to explore the possibility of learning a semantic parser without any annotated logical forms (Clarke et al., 2010; Liang et al., 2011; Goldwasser et al., 2011; Artzi and Zettlemoyer, 2011).", "startOffset": 156, "endOffset": 251}, {"referenceID": 32, "context": "In response to these concerns, researchers have recently begun to explore the possibility of learning a semantic parser without any annotated logical forms (Clarke et al., 2010; Liang et al., 2011; Goldwasser et al., 2011; Artzi and Zettlemoyer, 2011).", "startOffset": 156, "endOffset": 251}, {"referenceID": 19, "context": "In response to these concerns, researchers have recently begun to explore the possibility of learning a semantic parser without any annotated logical forms (Clarke et al., 2010; Liang et al., 2011; Goldwasser et al., 2011; Artzi and Zettlemoyer, 2011).", "startOffset": 156, "endOffset": 251}, {"referenceID": 2, "context": "In response to these concerns, researchers have recently begun to explore the possibility of learning a semantic parser without any annotated logical forms (Clarke et al., 2010; Liang et al., 2011; Goldwasser et al., 2011; Artzi and Zettlemoyer, 2011).", "startOffset": 156, "endOffset": 251}, {"referenceID": 17, "context": "There are two basic questions here: (i) what should the formal language for the logical forms z be, and (ii) what are the compositional mechanisms for constructing those logical forms? The semantic parsing literature is quite multilingual with respect to the formal language used for the logical form: Researchers have used SQL (Giordani and Moschitti, 2009), Prolog (Zelle and Mooney, 1996; Tang and Mooney, 2001), a simple functional query language called FunQL (Kate et al.", "startOffset": 328, "endOffset": 358}, {"referenceID": 52, "context": "There are two basic questions here: (i) what should the formal language for the logical forms z be, and (ii) what are the compositional mechanisms for constructing those logical forms? The semantic parsing literature is quite multilingual with respect to the formal language used for the logical form: Researchers have used SQL (Giordani and Moschitti, 2009), Prolog (Zelle and Mooney, 1996; Tang and Mooney, 2001), a simple functional query language called FunQL (Kate et al.", "startOffset": 367, "endOffset": 414}, {"referenceID": 45, "context": "There are two basic questions here: (i) what should the formal language for the logical forms z be, and (ii) what are the compositional mechanisms for constructing those logical forms? The semantic parsing literature is quite multilingual with respect to the formal language used for the logical form: Researchers have used SQL (Giordani and Moschitti, 2009), Prolog (Zelle and Mooney, 1996; Tang and Mooney, 2001), a simple functional query language called FunQL (Kate et al.", "startOffset": 367, "endOffset": 414}, {"referenceID": 25, "context": "There are two basic questions here: (i) what should the formal language for the logical forms z be, and (ii) what are the compositional mechanisms for constructing those logical forms? The semantic parsing literature is quite multilingual with respect to the formal language used for the logical form: Researchers have used SQL (Giordani and Moschitti, 2009), Prolog (Zelle and Mooney, 1996; Tang and Mooney, 2001), a simple functional query language called FunQL (Kate et al., 2005), and lambda calculus (Zettlemoyer and Collins, 2005), just to name a few.", "startOffset": 464, "endOffset": 483}, {"referenceID": 53, "context": ", 2005), and lambda calculus (Zettlemoyer and Collins, 2005), just to name a few.", "startOffset": 29, "endOffset": 60}, {"referenceID": 50, "context": "The construction mechanisms are equally diverse, including synchronous grammars (Wong and Mooney, 2007), hybrid trees (Lu et al.", "startOffset": 80, "endOffset": 103}, {"referenceID": 33, "context": "The construction mechanisms are equally diverse, including synchronous grammars (Wong and Mooney, 2007), hybrid trees (Lu et al., 2008), Combinatorial Categorial Grammars (CCG) (Zettlemoyer and Collins, 2005), and shift-reduce derivations (Zelle and Mooney, 1996).", "startOffset": 118, "endOffset": 135}, {"referenceID": 53, "context": ", 2008), Combinatorial Categorial Grammars (CCG) (Zettlemoyer and Collins, 2005), and shift-reduce derivations (Zelle and Mooney, 1996).", "startOffset": 49, "endOffset": 80}, {"referenceID": 52, "context": ", 2008), Combinatorial Categorial Grammars (CCG) (Zettlemoyer and Collins, 2005), and shift-reduce derivations (Zelle and Mooney, 1996).", "startOffset": 111, "endOffset": 135}, {"referenceID": 1, "context": ", 1972), Chat-80 (Warren and Pereira, 1982), and many others (see Androutsopoulos et al. (1995) for an overview).", "startOffset": 66, "endOffset": 96}, {"referenceID": 44, "context": "CCG (Steedman, 2000) and more generally, categorial grammar, is the de facto standard in linguistics.", "startOffset": 4, "endOffset": 20}, {"referenceID": 54, "context": "Furthermore, in real-world applications, we would like to handle disfluent utterances, and this further strains CCG by demanding either extra type-raising rules and disharmonic combinators (Zettlemoyer and Collins, 2007) or a proliferation of redundant lexical entries for each word (Kwiatkowski et al.", "startOffset": 189, "endOffset": 220}, {"referenceID": 26, "context": "Furthermore, in real-world applications, we would like to handle disfluent utterances, and this further strains CCG by demanding either extra type-raising rules and disharmonic combinators (Zettlemoyer and Collins, 2007) or a proliferation of redundant lexical entries for each word (Kwiatkowski et al., 2010).", "startOffset": 283, "endOffset": 309}, {"referenceID": 52, "context": "We evaluated our DCS-based approach on two standard benchmarks, Geo, a US geography domain (Zelle and Mooney, 1996) and Jobs, a job queries domain (Tang and Mooney, 2001).", "startOffset": 91, "endOffset": 115}, {"referenceID": 45, "context": "We evaluated our DCS-based approach on two standard benchmarks, Geo, a US geography domain (Zelle and Mooney, 1996) and Jobs, a job queries domain (Tang and Mooney, 2001).", "startOffset": 147, "endOffset": 170}, {"referenceID": 10, "context": "On Geo, we found that our system significantly outperforms previous work that also learns from answers instead of logical forms (Clarke et al., 2010).", "startOffset": 128, "endOffset": 149}, {"referenceID": 52, "context": "In this section, we present the main conceptual contribution of this work, dependency-based compositional semantics (DCS), using the US geography domain (Zelle and Mooney, 1996) as a running example.", "startOffset": 153, "endOffset": 177}, {"referenceID": 7, "context": "To define V, we need a bit more machinery: To avoid logical paradoxes, we construct V in increasing order of complexity using types (see Carpenter (1998) for a similar construction).", "startOffset": 137, "endOffset": 154}, {"referenceID": 21, "context": "Why did we choose this particular logical subset as a starting point, rather than allowing universal quantification, negation, or disjunction? There seems to be something fundamental about this subset, which also appears in Discourse Representation Theory (DRT) (Kamp and Reyle, 1993; Kamp et al., 2005).", "startOffset": 262, "endOffset": 303}, {"referenceID": 22, "context": "Why did we choose this particular logical subset as a starting point, rather than allowing universal quantification, negation, or disjunction? There seems to be something fundamental about this subset, which also appears in Discourse Representation Theory (DRT) (Kamp and Reyle, 1993; Kamp et al., 2005).", "startOffset": 262, "endOffset": 303}, {"referenceID": 3, "context": "3DRSes are not necessarily tree-structured, though economical DRT (Bos, 2009) imposes a tree-like restriction on DRSes for computational reasons.", "startOffset": 66, "endOffset": 77}, {"referenceID": 21, "context": "Indeed, DRT was originally motivated by these phenomena (see Kamp and Reyle (1993) for more details).", "startOffset": 61, "endOffset": 83}, {"referenceID": 14, "context": "In general, finding the solution to a CSP is NP-hard, but for trees, we can exploit dynamic programming (Dechter, 2003).", "startOffset": 104, "endOffset": 119}, {"referenceID": 28, "context": "For details on how we optimize these operations and handle infinite sets of tuples, see Liang (2011) .", "startOffset": 88, "endOffset": 101}, {"referenceID": 7, "context": "Not surprisingly then, the mark-execute construct bears some resemblance to other mechanisms that operate on categorial grammar and lambda calculus, such as quantifier raising, Montague\u2019s quantifying in, Cooper storage, and Carpenter\u2019s scoping constructor (Carpenter, 1998).", "startOffset": 256, "endOffset": 273}, {"referenceID": 12, "context": "Remarks Computing denotations on an abstract world is called abstract interpretation (Cousot and Cousot, 1977) and is very powerful framework commonly used in the programming languages community.", "startOffset": 85, "endOffset": 110}, {"referenceID": 10, "context": "For example, Zettlemoyer and Collins (2007) used it to allow conversion from Boston to \u03bbx.", "startOffset": 29, "endOffset": 44}, {"referenceID": 47, "context": "A standard result is that the derivative of the log-partition function is the expected feature vector (Wainwright and Jordan, 2008).", "startOffset": 102, "endOffset": 131}, {"referenceID": 52, "context": "US Geography The Geo dataset, originally created by Zelle and Mooney (1996), contains 880 questions about US Geography and a database of facts encoded in Prolog.", "startOffset": 52, "endOffset": 76}, {"referenceID": 45, "context": "Job Queries The Jobs dataset (Tang and Mooney, 2001) contains 640 natural language queries about job postings.", "startOffset": 29, "endOffset": 52}, {"referenceID": 37, "context": "Optimization algorithm To optimize an the objective function O(\u03b8, C) our default is to use the standard L-BFGS algorithm (Nocedal, 1980) with a backtracking line search for choosing the step size.", "startOffset": 121, "endOffset": 136}, {"referenceID": 38, "context": "7 To perform POS tagging, we used the Berkeley Parser (Petrov et al., 2006), trained on the WSJ Treebank (Marcus et al.", "startOffset": 54, "endOffset": 75}, {"referenceID": 34, "context": ", 2006), trained on the WSJ Treebank (Marcus et al., 1993) and the Question Treebank (Judge et al.", "startOffset": 37, "endOffset": 58}, {"referenceID": 20, "context": ", 1993) and the Question Treebank (Judge et al., 2006)\u2014thanks to Slav Petrov for providing the trained grammar.", "startOffset": 34, "endOffset": 54}, {"referenceID": 41, "context": "To determine triggering, we stem all words using the Porter stemmer Porter (1980), so that mountains triggers the same predicates as mountain.", "startOffset": 53, "endOffset": 82}, {"referenceID": 11, "context": "We used the same training-test splits as Zettlemoyer and Collins (2005) (600 training and 280 test examples for Geo, 500 training and 140 test examples for Jobs).", "startOffset": 57, "endOffset": 72}, {"referenceID": 10, "context": "System Accuracy CGCR10 w/answers (Clarke et al., 2010) 73.", "startOffset": 33, "endOffset": 54}, {"referenceID": 10, "context": "2 CGCR10 w/logical forms (Clarke et al., 2010) 80.", "startOffset": 25, "endOffset": 46}, {"referenceID": 32, "context": "4 LJK11 w/base triggers (Liang et al., 2011) 84.", "startOffset": 24, "endOffset": 44}, {"referenceID": 32, "context": "0 LJK11 w/augmented triggers (Liang et al., 2011) 87.", "startOffset": 29, "endOffset": 49}, {"referenceID": 10, "context": "1 Systems that Learn from Question-Answer Pairs We first compare our system (henceforth, LJK11) with Clarke et al. (2010) (henceforth, CGCR10), which is most similar to our work in that it also learns from question-answer pairs without using annotated logical forms.", "startOffset": 101, "endOffset": 122}, {"referenceID": 45, "context": "Here is a brief overview of the systems: \u2022 Cocktail (Tang and Mooney, 2001) uses inductive logic programming to learn rules for driving the decisions of a shift-reduce semantic parser.", "startOffset": 52, "endOffset": 75}, {"referenceID": 40, "context": "\u2022 Precise (Popescu et al., 2003) does not use learning, but instead relies on matching words to strings in the database using various heuristics based on WordNet and the Charniak parser.", "startOffset": 10, "endOffset": 32}, {"referenceID": 28, "context": "8Note that the numbers for LJK11 differ from those presented in Liang et al. (2011), which reports results based on 10 different splits rather than the setup used by CGCR10.", "startOffset": 64, "endOffset": 84}, {"referenceID": 16, "context": "\u2022 Scissor (Ge and Mooney, 2005) learns a generative probabilistic model that extends the Collins models (Collins, 1999) with semantic labels, so that syntactic and semantic parsing can be done jointly.", "startOffset": 10, "endOffset": 31}, {"referenceID": 11, "context": "\u2022 Scissor (Ge and Mooney, 2005) learns a generative probabilistic model that extends the Collins models (Collins, 1999) with semantic labels, so that syntactic and semantic parsing can be done jointly.", "startOffset": 104, "endOffset": 119}, {"referenceID": 25, "context": "\u2022 Silt (Kate et al., 2005) learns a set of transformation rules for mapping utterances to logical forms.", "startOffset": 7, "endOffset": 26}, {"referenceID": 23, "context": "\u2022 Krisp (Kate and Mooney, 2006) uses SVMs with string kernels to drive the local decisions of a chartbased semantic parser.", "startOffset": 8, "endOffset": 31}, {"referenceID": 49, "context": "\u2022 Wasp (Wong and Mooney, 2006) uses log-linear synchronous grammars to transform utterances into logical forms, starting with word alignments obtained from the IBM models.", "startOffset": 7, "endOffset": 30}, {"referenceID": 50, "context": "\u2022 \u03bb-Wasp (Wong and Mooney, 2007) extends Wasp to work with logical forms that contain bound variables (lambda abstraction).", "startOffset": 9, "endOffset": 32}, {"referenceID": 33, "context": "\u2022 LNLZ08 (Lu et al., 2008) learns a generative model over hybrid trees, which are logical forms augmented with natural language words.", "startOffset": 9, "endOffset": 26}, {"referenceID": 53, "context": "\u2022 ZC05 (Zettlemoyer and Collins, 2005) learns a discriminative log-linear model over CCG derivations.", "startOffset": 7, "endOffset": 38}, {"referenceID": 54, "context": "\u2022 ZC07 (Zettlemoyer and Collins, 2007) extends ZC05 with extra (disharmonic) combinators to increase the expressive power of the model.", "startOffset": 7, "endOffset": 38}, {"referenceID": 26, "context": "\u2022 KZGS10 (Kwiatkowski et al., 2010) uses a restricted higher-order unification procedure, which iteratively breaks up a logical form into smaller pieces.", "startOffset": 9, "endOffset": 35}, {"referenceID": 27, "context": "\u2022 KZGS11 (Kwiatkowski et al., 2011) extends KZGS10 by factoring lexical entries into a template plus a sequence of predicates which fill the slots of the template.", "startOffset": 9, "endOffset": 35}, {"referenceID": 11, "context": ", Zettlemoyer and Collins (2005, 2007); Kwiatkowski et al. (2010, 2011)). We cannot use these automatic techniques because they require annotated logical forms. Our system instead relies on lexical triggers, which does require some manual effort. These lexical triggers play a crucial role in the initial stages of learning, because they constrain the set of candidate DCS trees; otherwise we would face a hopelessly intractable search problem. Table 3 shows the results for Geo. Semantic parsers are typically evaluated on the accuracy of the logical forms: precision (the accuracy on utterances which are successfully parsed) and recall (the accuracy on all utterances). We only focus on recall (a lower bound on precision) and simply use the word accuracy to refer to recall. Our system is evaluated only on answer accuracy because our model marginalizes out the latent logical form. All other systems are evaluated on the accuracy of logical forms. To calibrate, we also evaluated KZGS10 on answer accuracy and found that it was quite similar to its logical form accuracy (88.9% versus 88.2%). This does not imply that our system would necessarily have a high logical form accuracy because multiple logical forms can produce the same answer, and our system does not receive a training signal to tease them apart. Even with only base triggers, our system (LJK11) outperforms all but two of the systems, 9 Our system produces a logical form for every utterance, and thus our precision is the same as our recall. 10The 88.2% corresponds to 87.9% in Kwiatkowski et al. (2010). The difference is due to using a slightly newer version of the code.", "startOffset": 18, "endOffset": 1576}, {"referenceID": 45, "context": "System LF Answer Cocktail (Tang and Mooney, 2001) 79.", "startOffset": 26, "endOffset": 49}, {"referenceID": 40, "context": "4 \u2013 Precise (Popescu et al., 2003) 77.", "startOffset": 12, "endOffset": 34}, {"referenceID": 16, "context": "5 Scissor (Ge and Mooney, 2005) 72.", "startOffset": 10, "endOffset": 31}, {"referenceID": 25, "context": "3 \u2013 Silt (Kate et al., 2005) 54.", "startOffset": 9, "endOffset": 28}, {"referenceID": 23, "context": "1 \u2013 Krisp (Kate and Mooney, 2006) 71.", "startOffset": 10, "endOffset": 33}, {"referenceID": 49, "context": "7 \u2013 Wasp (Wong and Mooney, 2006) 74.", "startOffset": 9, "endOffset": 32}, {"referenceID": 50, "context": "8 \u2013 \u03bb-Wasp (Wong and Mooney, 2007) 86.", "startOffset": 11, "endOffset": 34}, {"referenceID": 33, "context": "6 \u2013 LNLZ08 (Lu et al., 2008) 81.", "startOffset": 11, "endOffset": 28}, {"referenceID": 53, "context": "8 \u2013 ZC05 (Zettlemoyer and Collins, 2005) 79.", "startOffset": 9, "endOffset": 40}, {"referenceID": 54, "context": "3 \u2013 ZC07 (Zettlemoyer and Collins, 2007) 86.", "startOffset": 9, "endOffset": 40}, {"referenceID": 26, "context": "1 \u2013 KZGS10 (Kwiatkowski et al., 2010) 88.", "startOffset": 11, "endOffset": 37}, {"referenceID": 26, "context": "9 KZGS11 (Kwiatkowski et al., 2010) 88.", "startOffset": 9, "endOffset": 35}, {"referenceID": 32, "context": "6 \u2013 LJK11 w/base triggers (Liang et al., 2011) \u2013 87.", "startOffset": 26, "endOffset": 46}, {"referenceID": 32, "context": "9 LJK11 w/augmented triggers (Liang et al., 2011) \u2013 91.", "startOffset": 29, "endOffset": 49}, {"referenceID": 11, "context": "The first group of systems are evaluated using 10-fold cross-validation on all 880 examples; the second are evaluated on the 680 + 200 split of Zettlemoyer and Collins (2005). Our system (LJK11) with base triggers obtains comparable accuracy to past work, while with augmented triggers, our system obtains the highest overall accuracy.", "startOffset": 160, "endOffset": 175}, {"referenceID": 45, "context": "System LF Answer Cocktail (Tang and Mooney, 2001) 79.", "startOffset": 26, "endOffset": 49}, {"referenceID": 40, "context": "4 \u2013 Precise (Popescu et al., 2003) 88.", "startOffset": 12, "endOffset": 34}, {"referenceID": 53, "context": "0 ZC05 (Zettlemoyer and Collins, 2005) 79.", "startOffset": 7, "endOffset": 38}, {"referenceID": 32, "context": "3 \u2013 LJK11 w/base triggers (Liang et al., 2011) \u2013 90.", "startOffset": 26, "endOffset": 46}, {"referenceID": 32, "context": "7 LJK11 w/augmented triggers (Liang et al., 2011) \u2013 95.", "startOffset": 29, "endOffset": 49}, {"referenceID": 28, "context": "1% in Liang et al. (2011). These differences are due to minor differences in the code.", "startOffset": 6, "endOffset": 26}, {"referenceID": 13, "context": "The general approach is similar in spirit to Searn (Daume et al., 2009), although we do not have any formal guarantees at this point.", "startOffset": 51, "endOffset": 71}, {"referenceID": 37, "context": "Thus far, we have been using L-BFGS (Nocedal, 1980), which is a batch algorithm: Each iteration, we construct the candidate sets C(x) for all the training examples before solving the optimization problem argmax\u03b8O(\u03b8, C).", "startOffset": 36, "endOffset": 51}, {"referenceID": 42, "context": "We now consider an online algorithm, stochastic gradient descent (SGD) (Robbins and Monro, 1951), which updates the parameters after computing the candidate set for each example.", "startOffset": 71, "endOffset": 96}, {"referenceID": 29, "context": "Furthermore, the non-convexity of the objective function exacerbates the unpredictability (Liang and Klein, 2009).", "startOffset": 90, "endOffset": 113}, {"referenceID": 36, "context": "The dominant paradigm, which stems from the seminal work of Richard Montague in the early 1970s (Montague, 1973), states that parts are lambda calculus expressions that correspond to syntactic constituents, and composition is function application.", "startOffset": 96, "endOffset": 112}, {"referenceID": 26, "context": "For example, in the line of work on learning probabilistic CCGs (Zettlemoyer and Collins, 2005, 2007; Kwiatkowski et al., 2010), many candidate lexical entries must be entertained for each word even when polysemy does not actually exist (Section 2.", "startOffset": 64, "endOffset": 127}, {"referenceID": 27, "context": "To improve generalization, the lexicon can be further factorized (Kwiatkowski et al., 2011), but this is all done within the constraints of CCG.", "startOffset": 65, "endOffset": 91}, {"referenceID": 0, "context": "DCS has a family resemblance to a semantic representation called natural logic form (Alshawi et al., 2011), which is also motivated by the benefits of working with dependency-based logical forms.", "startOffset": 84, "endOffset": 106}, {"referenceID": 0, "context": "DCS has a family resemblance to a semantic representation called natural logic form (Alshawi et al., 2011), which is also motivated by the benefits of working with dependency-based logical forms. The goals and the detailed structure of the two semantic formalisms are different, however. Alshawi et al. (2011) focuses on parsing complex sentences in an open domain where a structured database or world does not", "startOffset": 85, "endOffset": 310}, {"referenceID": 21, "context": "Perhaps not immediately apparent is the fact that DCS draws an important idea from Discourse Representation Theory (DRT) (Kamp and Reyle, 1993)\u2014not from the treatment of anaphora and presupposition which it is known for, but something closer to its core.", "startOffset": 121, "endOffset": 143}, {"referenceID": 21, "context": "Linguistically, it appears that existential quantifiers play an important role and should be treated specially (Kamp and Reyle, 1993).", "startOffset": 111, "endOffset": 133}, {"referenceID": 31, "context": "The intuition is that when the tasks are related, the solution to one task can help another task, both computationally in navigating the program space and statistically in choosing the appropriate program if there are multiple feasible possibilities (Liang et al., 2010).", "startOffset": 250, "endOffset": 270}, {"referenceID": 14, "context": "There have been several papers that induce programs in this setting: Eisenstein et al. (2009) induces conjunctive formulae from natural language instructions, Piantadosi et al.", "startOffset": 69, "endOffset": 94}, {"referenceID": 14, "context": "There have been several papers that induce programs in this setting: Eisenstein et al. (2009) induces conjunctive formulae from natural language instructions, Piantadosi et al. (2008) induces first-order logic formulae using CCG in a small domain assuming observed lexical semantics, and Clarke et al.", "startOffset": 69, "endOffset": 184}, {"referenceID": 10, "context": "(2008) induces first-order logic formulae using CCG in a small domain assuming observed lexical semantics, and Clarke et al. (2010) induces logical forms in semantic parsing.", "startOffset": 111, "endOffset": 132}, {"referenceID": 24, "context": "Some can learn from utterances paired with a set of logical forms, one of which is correct (Kate and Mooney, 2007; Chen and Mooney, 2008).", "startOffset": 91, "endOffset": 137}, {"referenceID": 8, "context": "Some can learn from utterances paired with a set of logical forms, one of which is correct (Kate and Mooney, 2007; Chen and Mooney, 2008).", "startOffset": 91, "endOffset": 137}, {"referenceID": 40, "context": "We saw that type constraints from the database/world reduces the set of candidate logical forms and lead to more accurate systems (Popescu et al., 2003; Liang et al., 2011).", "startOffset": 130, "endOffset": 172}, {"referenceID": 32, "context": "We saw that type constraints from the database/world reduces the set of candidate logical forms and lead to more accurate systems (Popescu et al., 2003; Liang et al., 2011).", "startOffset": 130, "endOffset": 172}, {"referenceID": 43, "context": "Even for syntactic parsing, information from the denotation of an utterance can be helpful (Schuler, 2003).", "startOffset": 91, "endOffset": 106}, {"referenceID": 10, "context": "We can obtain answers given a world, which are cheaper to obtain than logical forms (Clarke et al., 2010; Liang et al., 2011).", "startOffset": 84, "endOffset": 125}, {"referenceID": 32, "context": "We can obtain answers given a world, which are cheaper to obtain than logical forms (Clarke et al., 2010; Liang et al., 2011).", "startOffset": 84, "endOffset": 125}, {"referenceID": 6, "context": ", 2009, 2010), win a game of Civilization (Branavan et al., 2011), play a legal game of solitaire (Eisenstein et al.", "startOffset": 42, "endOffset": 65}, {"referenceID": 15, "context": ", 2011), play a legal game of solitaire (Eisenstein et al., 2009; Goldwasser and Roth, 2011), and navigate a map by following directions (Vogel and Jurafsky, 2010; Chen and Mooney, 2011).", "startOffset": 40, "endOffset": 92}, {"referenceID": 18, "context": ", 2011), play a legal game of solitaire (Eisenstein et al., 2009; Goldwasser and Roth, 2011), and navigate a map by following directions (Vogel and Jurafsky, 2010; Chen and Mooney, 2011).", "startOffset": 40, "endOffset": 92}, {"referenceID": 46, "context": ", 2009; Goldwasser and Roth, 2011), and navigate a map by following directions (Vogel and Jurafsky, 2010; Chen and Mooney, 2011).", "startOffset": 79, "endOffset": 128}, {"referenceID": 9, "context": ", 2009; Goldwasser and Roth, 2011), and navigate a map by following directions (Vogel and Jurafsky, 2010; Chen and Mooney, 2011).", "startOffset": 79, "endOffset": 128}, {"referenceID": 4, "context": "Some can learn from utterances paired with a set of logical forms, one of which is correct (Kate and Mooney, 2007; Chen and Mooney, 2008). Liang et al. (2009) tackles the even more difficult alignment problem of segmenting and aligning a discourse to a database of facts, where many parts on either side are irrelevant.", "startOffset": 115, "endOffset": 159}, {"referenceID": 4, "context": "Some can learn from utterances paired with a set of logical forms, one of which is correct (Kate and Mooney, 2007; Chen and Mooney, 2008). Liang et al. (2009) tackles the even more difficult alignment problem of segmenting and aligning a discourse to a database of facts, where many parts on either side are irrelevant. If we know how the world relates to language, we can leverage structure in the world to guide the learning and interpretation of language. We saw that type constraints from the database/world reduces the set of candidate logical forms and lead to more accurate systems (Popescu et al., 2003; Liang et al., 2011). Even for syntactic parsing, information from the denotation of an utterance can be helpful (Schuler, 2003). One of the exciting aspects about using the world for learning language is that it opens the door to many new types of supervision. We can obtain answers given a world, which are cheaper to obtain than logical forms (Clarke et al., 2010; Liang et al., 2011). Goldwasser et al. (2011) learns a semantic parser based on bootstrapping and estimating the confidence of its own predictions.", "startOffset": 115, "endOffset": 1025}, {"referenceID": 2, "context": "Artzi and Zettlemoyer (2011) learns a semantic parser not from annotated logical forms, but from user interactions with a dialog system.", "startOffset": 0, "endOffset": 29}], "year": 2011, "abstractText": "Suppose we want to build a system that answers a natural language question by representing its semantics as a logical form and computing the answer given a structured database of facts. The core part of such a system is the semantic parser that maps questions to logical forms. Semantic parsers are typically trained from examples of questions annotated with their target logical forms, but this type of annotation is expensive. Our goal is to learn a semantic parser from question-answer pairs instead, where the logical form is modeled as a latent variable. Motivated by this challenging learning problem, we develop a new semantic formalism, dependency-based compositional semantics (DCS), which has favorable linguistic, statistical, and computational properties. We define a log-linear distribution over DCS logical forms and estimate the parameters using a simple procedure that alternates between beam search and numerical optimization. On two standard semantic parsing benchmarks, our system outperforms all existing stateof-the-art systems, despite using no annotated logical forms.", "creator": "LaTeX with hyperref package"}}}