{"id": "1203.3466", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Mar-2012", "title": "Possibilistic Answer Set Programming Revisited", "abstract": "diaeresis Possibilistic brecken answer ruckauf set programming (PASP) wakehurst extends potamkin answer set vaidi programming (ASP) pandan by motional attaching to each rule nephrite a shougang degree haid of certainty. counterchanged While 1807 such an extension longest-tenured is important from 95.93 an tumorigenesis application cvl point 80-point of view, pery existing semantics are not u201che well - motivated, and ostrov do musselshell not 94.07 always gudermes yield intuitive results. To tachypnea develop a militias more energysolutions suitable leflore semantics, br\u00f8ndby we munny first introduce wiu a emanual characterization reye of piv answer doctrina sets of baras classical ASP moku programs in kausar terms of amietophrynus possibilistic deceptively logic where saher an galeras ASP program specifies a set priscilla of constraints euro367 on komala possibility distributions. This luber characterization mezger is sophy then zosterops naturally jared generalized to define answer daleh sets of afrocentric PASP programs. ccj We black-eared furthermore provide a syntactic theoktistos counterpart, leading kahlah to lovins a 10m possibilistic apocalypso generalization of the well - known tiffert Gelfond - photorealistic Lifschitz needles reduct, and we 22-9 show how pamunkey our xor framework heinz-harald can readily be election-related implemented viglen using potentiometer standard ASP intermarket solvers.", "histories": [["v1", "Thu, 15 Mar 2012 11:17:56 GMT  (252kb)", "http://arxiv.org/abs/1203.3466v1", "Appears in Proceedings of the Twenty-Sixth Conference on Uncertainty in Artificial Intelligence (UAI2010)"]], "COMMENTS": "Appears in Proceedings of the Twenty-Sixth Conference on Uncertainty in Artificial Intelligence (UAI2010)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["kim bauters", "steven schockaert", "martine de cock", "dirk vermeir"], "accepted": false, "id": "1203.3466"}, "pdf": {"name": "1203.3466.pdf", "metadata": {"source": "CRF", "title": "Possibilistic Answer Set Programming Revisited", "authors": ["Kim Bauters", "Steven Schockaert", "Martine De Cock"], "emails": [], "sections": [{"heading": null, "text": "Possibilistic answer set programming (PASP) extends answer set programming (ASP) by attaching to each rule a degree of certainty. While such an extension is important from an application point of view, existing semantics are not well-motivated, and do not always yield intuitive results. To develop a more suitable semantics, we first introduce a characterization of answer sets of classical ASP programs in terms of possibilistic logic where an ASP program specifies a set of constraints on possibility distributions. This characterization is then naturally generalized to define answer sets of PASP programs. We furthermore provide a syntactic counterpart, leading to a possibilistic generalization of the well-known Gelfond-Lifschitz reduct, and we show how our framework can readily be implemented using standard ASP solvers."}, {"heading": "1 Introduction", "text": "Answer set programming (ASP) is a form of declarative programming based on the stable model semantics (Gelfond and Lifzchitz, 1988). ASP has proven successful as an elegant formalism for commonsense reasoning in discrete domains and to encode combinatorial problems in a purely declarative way. Possibilistic logic (PL), introduced in (Dubois et al., 1994), emanated from possibility theory (Zadeh, 1978) and offers a sound and complete logic system for representing (partial) ignorance or uncertainty in a nonprobabilistic way.\nPossibilistic answer set programming (PASP) (Nicolas et al., 2006) unites ASP and PL and provides a single\n\u2217Funded by a joint FWO project. \u2020Postdoctoral fellow of the FWO. \u2021On leave from Universiteit Gent.\nframework that supports declarative programming under uncertainty. In PASP, a certainty value is attached to each rule of an ASP program. The certainty of a particular conclusion of that program is then given by the lowest certainty of the rules that were used, i.e. the strength of a conclusion is determined by the weakest piece of information involved. However, for programs containing negation-as-failure, the semantics proposed in (Nicolas et al., 2006) often lead to counterintuitive results. For example, consider the PASP program P1:\n1: concertBooked \u2190 (1) 1: longDrive \u2190 concertBooked ,not canceled (2)\n0.2: canceled \u2190 . (3)\nThis program encodes that we are certain that we booked a concert and we are certain that we have a long drive ahead of us, unless the concert is canceled. The last rule encodes that the concert is indeed cancelled, although this information comes from an unreliable source, hence a low certainty degree is attached to this rule.\nThe approach from (Nicolas et al., 2006) consists of first determining the classical answer sets, ignoring the certainty values, and subsequently adding certainties to atoms in these answer sets based on which rules are needed to support them. The program above only has one classical answer set, namely {concertBooked, canceled}. After adding the certainty degrees, we find the possibilistic answer set{\nconcertBooked1 , canceled0 .2 }\nindicating that we are entirely certain that we booked the concert and that we are somewhat certain that the concert is canceled. As such, we lose the valuable information that the certainty of the third rule is limited, and thus completely ignore the second rule. Nonetheless, it seems desirable to derive that longDrive may hold, with some limited certainty, unless it is completely certain that we can prove canceled. The intuitive meaning of \u2018not a\u2019 is then given by \u201cunless it is\ncertain that \u2018a\u2019 holds\u201d. However, this behavior cannot be obtained by adding weights to classical answer sets.\nIn this paper we take a principled approach to uncover an appropriate semantics for PASP. To this end, we first reveal an important link between ASP and PL, leading to a novel characterization of the stable model semantics. In this characterization, the rules of an ASP program impose constraints on possibility distributions. The possibility distributions that satisfy all these constraints then correspond with the answer sets of the original ASP program. This characterization is then extended in a natural way to cover PASP programs. The resulting semantics will be such that the unique possibilistic answer set of Pintro is given by{\nconcertBooked1 , longDrive0 .8 , canceled0 .2 } .\nBecause our certainty that the concert is canceled is so low, i.e. because we have failed to prove with a high certainty that the concert is canceled, we still derive with a reasonably high certainty that we have a long drive ahead of us.\nThe remainder of this paper is structured as follows. In Section 2 we start by introducing some background on ASP, PL and PASP. Subsequently, in Section 3 we investigate the links between ASP and PL, leading to an alternative definition of answer sets, in terms of possibilistic logic. Next, we extend this definition in Section 4 to the general case of possibilistic ASP. Because these definitions are formulated at the semantic level, they cannot readily be implemented. To cope with this, we present a syntactic counterpart in Section 5, introducing a possibilistic generalization of the Gelfond-Lifschitz reduct. In Section 6 we then demonstrate how possibilistic answer sets can be computed using existing ASP solvers, thus verifying the applicability of our new approach. Finally, we provide an overview of related work and present some conclusions."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Answer Set Programs (ASP)", "text": "Let A be a finite set of atoms. We also consider the special atom > (or true). A naf-atom is an atom preceded by not which we call negation-as-failure. Intuitively, not a is true when we cannot prove a.\nA normal rule is an expression of the form a0 \u2190 a1, ..., am, not am+1, ..., not an with ai, 0 \u2264 i \u2264 n, an atom of A. We call a0 the head of the rule and a1, ..., am, not am+1, ..., not an the body of the rule. If no occurrences of not appear in a rule (i.e. m = n), the rule is called definite. A normal (resp. definite) program P is a finite set of normal (resp. definite) rules. A rule of the form a0 \u2190 is called a fact and is used as\na shorthand for a0 \u2190 >. The Herbrand base BP of a normal program P is the set of atoms appearing in P . An interpretation I of P is any set of atoms I \u2286 BP . The set of interpretations \u2126 of a normal program P is given by 2BP .\nThe satisfaction relation |= is defined for an interpretation I as I |= a iff a = > or a \u2208 I. For an interpretation I and A a set of atoms, we define I |= A iff \u2200a \u2208 A \u00b7 I |= a. An interpretation I is a model of a definite rule r = a0 \u2190 a1, ..., am, denoted I |= r, if I |= a0 or I 6|= {a1, ..., am}. An interpretation I of a definite program P is a model of P iff \u2200r \u2208 P \u00b7 I |= r.\nAnswer sets are defined using the immediate consequence operator TP of a definite program P , defined for a set of atoms I as:\nTP (I) = I \u222a {a0 | (a0 \u2190 a1, ..., am) \u2208 P \u2227 (I |= {a1, ..., am})}\nWe use P ? to denote the fixpoint which is obtained by repeatedly applying TP starting from the empty interpretation, i.e. the least fixpoint of TP w.r.t. set inclusion. An interpretation I is called an answer set of a definite program P iff I = P ?. Answer sets of normal programs are defined using the Gelfond-Lifschitz reduct P I of a normal program P and interpretation I, defined as\nP I ={a0 \u2190 a1, ..., am | ({am+1, ..., an} \u2229 I = \u2205) \u2227 (a0 \u2190 a1, ..., am, not am+1, ..., not an) \u2208 P}.\nAn interpretation I is then called an answer set of the normal program P iff ( P I )? = I, i.e. if I is the answer set of the reduct P I ."}, {"heading": "2.2 Possibilistic Logic", "text": "At the semantic level, possibilistic logic is defined in terms of a possibility distribution \u03c0 on the universe of interpretations, i.e. an \u2126 \u2192 [0, 1] mapping which encodes for each interpretation, or possible world, I to what extent it is plausible that I is the actual world. Intuitively, \u03c0(I) represents the compatibility of the interpretation I with available information. By convention, \u03c0(I) = 0 means that I is impossible and \u03c0(I) = 1 means that nothing prevents I from being true in the real world. Note that possibility degrees are mainly interpreted qualitatively: when \u03c0(I) > \u03c0(I \u2032), I is considered more plausible than I \u2032.\nA possibility distribution \u03c0 induces two uncertainty measures. The possibility measure \u03a0 is defined by\n\u03a0(p) = max {\u03c0(I) | I |= p}\nand evaluates the extent to which a proposition p is consistent with the beliefs expressed by \u03c0. The dual\nnecessity measure N is defined by\nN(p) = 1\u2212\u03a0(\u00acp)\nand evaluates the extent to which a proposition p is entailed by the available beliefs (Dubois et al., 1994). An important property of necessity measures is mindecomposability: N(p \u2227 q) = min(N(p), N(q)) for all propositions p and q.\nAt the syntactic level, a possibilistic knowledge base consists of pairs (p, c) where p is a proposition and c \u2208 [0, 1] expresses the certainty that p is the case. A formula (p, c) is interpreted as the constraintN(p) \u2265 c. A possibilistic knowledge base \u03a3 thus corresponds to a set of constraints on possibility distributions. Typically, there will be many possibility distributions that satisfy these constraints. In practice, we are usually only interested in those that make minimal commitments, called the least specific possibility distributions. Formally, a possibility distribution \u03c0 is a least specific possibility distribution compatible with \u03a3 if there is no possibility distribution \u03c0\u2032 with \u03c0\u2032 6= \u03c0 compatible with \u03a3, such that \u2200I \u2208 \u2126 \u00b7\u03c0\u2032(I) \u2265 \u03c0(I). Thus the least specific possibility distribution is the least informative possibility distribution.\nIn the remainder of this paper, we assume that all certainty weights are taken from a finite subset C of [0, 1]."}, {"heading": "2.3 Possibilistic ASP (PASP)", "text": "PASP combines ASP and possibility theory by associating a necessity value with atoms and rules. A valuation is a function V : A \u2192 C. The intuition is that for an atom a \u2208 A, V (a) = c means that we can derive with certainty c that is a is true. For notational convenience, we also use the set notation V = {ac , . . .}. In accordance with this set notation, we write V = \u2205 to denote the valuation in which each atom is mapped to 0. For c \u2208 C and a valuation V , we use V c to denote the classical interpretation V c = {a | a \u2208 A, V (a) \u2265 c}. We use V c to denote the classical interpretation V c = {a | a \u2208 A, V (a) > c}, i.e. those atoms for which we can derive with certainty strictly greater than c that they are true. A possibilistic normal (resp. definite) program is a set of pairs p = (r, n(r)) with r a normal (resp. definite) rule and n(r) \u2208 C a certainty associated with r. We write a pair p = (r, n(r)) with r = a0 \u2190 a1, ..., am, not am+1, ..., not an as:\nn(r): a0 \u2190 a1, ..., am, not am+1, ..., not an.\nThe c-cut Pc of a possibilistic normal program P with c \u2208 C is defined as\nPc = {(r, n(r)) | (r, n(r)) \u2208 P ;n(r) \u2265 c} .\nSimilar as for classical definite programs, the unique answer set of a possibilistic definite program can be found using a syntactic transformation based on a fixpoint operator.\nDefinition 1. Let P be a possibilistic definite program and V a valuation. The immediate consequence operator TP is defined for c \u2208 C as:\nTP (V )(a0) = max{c |V c |= a1, ..., am \u2227 (a0 \u2190 a1, ..., am) \u2208 Pc}\nThe immediate consequence operator from Definition 1 is equivalent to the one proposed in (Nicolas et al., 2006), although our formulation is slightly different.\nWe use P ? to denote the fixpoint obtained by repeatedly applying TP starting from the minimal valuation V = \u2205, i.e. the least fixpoint of TP w.r.t. set inclusion. A valuation V is called an answer set of a possibilistic definite program if V = P ?.\nAnswer sets of possibilistic normal programs are defined using a reduct. In (Nicolas et al., 2006) the reduct PA of a possibilistic normal program P and a set of atoms A is defined as\nPA ={((a0 \u2190 a1, ..., am), n(r)) | (r, n(r)) \u2208 P \u2227 r = a0 \u2190 a1, ..., am, not am+1, ..., not an \u2227 {am+1, ..., an} \u2229A = \u2205}. (4)\nA valuation V is then called an answer set of the possibilistic normal program P iff ( P (V 0) )? = V , i.e. if V\nis the answer set of the reduct P (V 0)."}, {"heading": "3 Possibilistic semantics of ASP", "text": "In this section we introduce a new characterization of classical answer sets using possibility theory. Although many equivalent definitions have already been proposed (Lifschitz, 2008), studying alternative definitions often leads to new insights. In particular, as we will see in the next section, our possibilistic approach to ASP can be naturally generalized to PASP.\nThe core of our idea is to translate a normal program to a set of constraints on possibility distributions. The least specific possibility distributions that are compatible with these constraints will then correspond to the answer sets of the program. For example, a fact of the form \u2018a0 \u2190\u2019 expresses the constraint that only interpretations in which \u2018a0\u2019 is true should be possible. More precisely, the rule \u2018a0 \u2190\u2019 imposes the constraint N(a0) \u2265 N(>) where N(>) = 1 by definition, i.e. it is necessarily the case that a0 is true. Similarly, a rule such as \u2018a0 \u2190 a1\u2019 translates\nto the constraint N(a0) \u2265 N(a1): a0 is at least as certain as a1. Finally, a rule \u2018a0 \u2190 a1, ..., am\u2019 translates to N(a0) \u2265 N(a1 \u2227 ... \u2227 am) which is equivalent to N(a0) \u2265 min(N(a1), ..., N(am)) due to the mindecomposability property of necessity measures.\nDefinition 2. Let P be a definite program and \u03c0 : \u2126 \u2192 [0, 1] a possibility distribution. For every r \u2208 P , the constraint \u03b3(r) imposed by r = (a0 \u2190 a1, ..., am) is given by\nN(a0) \u2265 min(N(a1), ..., N(am)).\nLet CP = {\u03b3(r) | r \u2208 P} be the set of constraints imposed by program P . If \u03c0 satisfies the constraints in CP , \u03c0 is said to be a possibilistic model of CP , written \u03c0 |= CP . A possibilistic model of CP will also be called a possibilistic model of P . We write SP for the set of all least specific possibilistic models of P , i.e. for \u03c0 \u2208 SP there is no possibilistic model \u03c0\u2032 6= \u03c0 of P such that \u2200I \u2208 \u2126 \u00b7 \u03c0\u2032(I) \u2265 \u03c0(I). Proposition 1. Let P be a definite program. If \u03c0 \u2208 SP then M = {a | N(a) = 1, a \u2208 BP } is an answer set of P .\nProposition 2. Let P be a definite program. If M is an answer set of P then the possibility distribution \u03c0 defined by \u03c0(I) = 1 iff M \u2286 I and \u03c0(I) = 0 otherwise is contained in SP .\nNote that because definite programs always have exactly one answer set, it follows that SP is a singleton.\nNow we take a closer look at programs with negationas-failure. Intuitively not b is true if we have no proof for b. However, the proof for b may depend on other naf-atoms whose truth value, in turn, depends on b. To cope with this, the characterization of answer sets in terms of the Gelfond-Lifschitz reduct involves a guess: first, we guess for each naf-atom not b whether a proof for b will be found and subsequently we verify whether our guess was correct. In our possibilistic approach, a similar strategy is possible. Specifically, for each naf-atom not b we guess with what certainty we will not find a proof for b, i.e. we guess the value of 1\u2212N(b) = \u03a0(\u00acb), for N and \u03a0 the necessity and possibility measures induced by a least specific possibilistic model of P . Intuitively, g(b) reflects the certainty that \u201cit is consistent to assume that b is not true\u2019.\nDefinition 3. Let P be a normal program and let g be a mapping from BP to [0, 1]. For every r \u2208 P , the constraint \u03b3g(r) induced by r = (a0 \u2190 a1, ..., am, not am+1, ..., not an) and g is given by\nN(a0) \u2265 min (N(a1), ..., N(am), g(am+1), ..., g(an)) . (5) C(P,g) = {\u03b3g(r) | r \u2208 P} is the set of constraints imposed by program P and g, and S(P,g) is the set of all least specific possibilistic models of C(P,g).\nBefore we prove the correspondence between the answer sets of P and the possibility distributions in S(P,g), we illustrate the intuition in the following example.\nExample 1. Consider the program P with the rules\na\u2190 b\u2190 b c\u2190 a, not b.\nThe set of constraints C(P,g) is given by\nN(a) \u2265 N(>) = 1 N(b) \u2265 N(b) N(c) \u2265 min (N(a), g(b)) .\nWe can rewrite the first constraint as 1 \u2212 \u03a0(\u00aca) \u2265 1 and thus \u03a0(\u00aca) = 0. The second constraint is always satisfied and can be dropped. The last constraint can be rewritten as \u03a0(\u00acc) \u2264 1\u2212min(1\u2212 \u03a0(\u00aca), g(b)), which imposes an upper bound on the value that \u03a0(\u00acc) can assume. This inequality can be further simplified since we already concluded that \u03a0(\u00aca) = 0. Hence we have \u03a0(\u00acc) \u2264 1\u2212min(1\u22120, g(b)) = 1\u2212g(b). In conclusion, the program imposes the constraints\n\u03a0(\u00aca) = 0 \u03a0(\u00acc) \u2264 1\u2212 g(b).\nThe set S(P,g) contains exactly one element, which is defined by\n\u03c0({a, b, c}) = 1 \u03c0({b, c}) = 0 \u03c0({a, b}) = 1\u2212 g(b) \u03c0({b}) = 0 \u03c0({a, c}) = 1 \u03c0({c}) = 0 \u03c0({a}) = 1\u2212 g(b) \u03c0({}) = 0.\nNote that this possibility distribution is independent of the choice for g(a) and g(c) since there are no occurrences of not a and not c in P . In particular, we can now establish for which choices of g(b) it holds that g(b) = \u03a0(\u00acb):\ng(b) = \u03a0(\u00acb) = max {\u03c0(I) | I |= \u00acb} = 1\nand thus we have that \u03c0({a, b}) = \u03c0({a}) = 0.\nTo find out whether a, b and c are necessarily true (i.e. belong to the corresponding answer set), we need to verify whether N(a) = 1, for N the necessity measure induced by this particular least specific possibility distribution \u03c0. We have N(a) = 1 \u2212 \u03a0(\u00aca) = 1, N(c) = 1\u2212\u03a0(\u00acc) = 1 and N(b) = 1\u2212\u03a0(\u00acb) = 0. The unique answer set of P is therefore {a, c}. Proposition 3. Let P be a normal program and let g be a mapping from BP to [0, 1]. Let \u03c0 \u2208 S(P,g) be such that\n\u2200a \u2208 BP \u00b7 g(a) = \u03a0(\u00aca) (6)\nand that\n\u2200a \u2208 BP \u00b7N(a) \u2208 {0, 1} (7)\nthen M = {a | N(a) = 1, a \u2208 BP } is an answer set of the normal program P .\nProposition 4. Let P be a normal program. If M is an answer set of P , there is a mapping g from BP to [0, 1] and a possibility distribution \u03c0 \u2208 S(P,g) such that \u2200a \u2208 BP \u00b7 g(a) = \u03a0(\u00aca), \u2200a \u2208 M \u00b7N(a) = 1 and \u2200a \u2208 (BP \\M) \u00b7N(a) = 0."}, {"heading": "4 Semantics of possibilistic ASP", "text": "In the previous section we have introduced a possibilistic semantics for ASP. These semantics can easily be extended to the case of PASP. Consider a rule of the form\nn(r): a0 \u2190 a1 , ..., am ,not am+1 , ...,not an\nwe have already discussed that a0 \u2190 a1, ..., am, not am+1, ..., not an imposes a set of restrictions on the possibility distribution. Intuitively, the certainty of the head a0 depends both on the certainty that the body is true and the certainty that the rule is actually valid. The former certainty can be calculated as for normal rules, and is given by the right-hand side of (5). The latter certainty is explicitly asserted to be n(r). Because the necessity of a conjunctive statement is equal to the minimum of the necessities of its conjuncts, we arrive at the following semantics.\nDefinition 4. Let P be a possibilistic normal program and g a mapping from BP to [0, 1]. For every p \u2208 P , the constraint \u03b3g(p) induced by p = (r, n(r)) with r = (a0 \u2190 a1, ..., am, not am+1, ..., not an) and g is given by\nN(a0) \u2265 min(N(a1), ..., N(am), g(am+1), ..., g(an), n(r)).\nC(P,g) = {\u03b3g(p) | p \u2208 P} is the set of constraints imposed by program P , and S(P,g) is the set of all least specific possibilistic models of C(P,g).\nWe can now easily generalize the characterization from Section 3 to define the semantics of possibilistic normal programs.\nDefinition 5. Let P be a possibilistic normal program and let g be a mapping from BP to [0, 1]. Let \u03c0 \u2208 S(P,g) be such that\n\u2200a \u2208 BP \u00b7 g(a) = \u03a0(\u00aca) then V = { aN (a) | a \u2208 BP } is called a possibilistic answer set of P .\nThis natural generalization of our characterization of classical answer sets precisely captures the intuition that \u2018not a\u2019 should be interpreted as \u201cit cannot be established that a is certain\u201d, as illustrated in the next example.\nExample 2. Consider program P1 from Section 1. For compactness, we use cB to denote concertBooked, lD to denote longDrive and can to denote canceled. The set of constraints C(P1,g) is given by\nN(cB) \u2265 min (N(>), 1) N(lD) \u2265 min (N(cB), g(can), 1) N(can) \u2265 min (N(>), 0.2) .\nWe know that N(>) = 1. Hence the first constraint can be rewritten as N(cB) = 1 or equivalently \u03a0(\u00accB) = 0. Since N(cB) = 1, the second constraint can be simplified to \u03a0(\u00aclD) \u2264 1 \u2212 g(can). The last constraint can be simplified to \u03a0(\u00accan) \u2264 0.8. The program thus imposes the constraints\n\u03a0(\u00accB) = 0 \u03a0(\u00aclD) \u2264 1\u2212 g(can) \u03a0(\u00accan) \u2264 0.8.\nThe set S(P1,g) contains just one element defined by\n\u03c0({cB, lD, can}) = 1 \u03c0({lD, can}) = 0 \u03c0({cB, lD}) = 0.8 \u03c0({lD}) = 0 \u03c0({cB, can}) = 1\u2212 g(can) \u03c0({can}) = 0 \u03c0({cB}) = min (0.8, 1\u2212 g(can)) \u03c0({}) = 0.\nWe can now establish for which choices of g(can) it holds that g(can) = \u03a0(\u00accan) :\ng(can) = \u03a0(\u00accan) = max {\u03c0(I) | I |= \u00accan} = 0.8\nand thus we have \u03c0({cB, can}) = \u03c0({cB}) = 0.2. We have N(cB) = 1 \u2212 \u03a0(\u00accB) = 1, N(lD) = 1 \u2212 \u03a0(\u00aclD) = 1\u2212 0.2 = 0.8 and N(can) = 1\u2212\u03a0(\u00accan) = 1 \u2212 0.8 = 0.2. The unique possibilistic answer set of P1 is therefore { cB1 , lD0 .8 , can0 .2 } .\nIt is important to note that under the semantics proposed in this paper there is no longer a 1-on-1 mapping between the classical answer sets of a normal program and the possibilistic answer sets of that same normal program with certainty 1 attached to each of the rules. Indeed, comparing Definition 5 with Proposition 3, we can see that no equivalent to (7) is imposed for possibilistic answer sets.\nExample 3. Consider the normal program with the single rule a \u2190 not a. This program has no classical answer sets. Now consider the possibilistic normal program P with the rule\n1: a \u2190 not a.\nThe set of constraints C(P,g) is given by\nN(a) \u2265 min(g(a), 1).\nThis constraint can be rewritten as \u03a0(\u00aca) \u2264 1\u2212 g(a). The set S(P,g) contains just a single element defined by \u03c0({a}) = 1 and \u03c0({}) = 1\u2212g(a). We can now establish for which choices of g(a) it holds that g(a) = \u03a0(\u00aca):\ng(a) = \u03a0(\u00aca) = 1\u2212 g(a)\nand thus \u03c0({}) = 0.5. The unique possibilistic answer set of P is therefore { a0 .5 } . This should come as no surprise. In classical ASP we are limited to conclusions with absolute certainty, a limitation that we do not have in PASP. In the same way, one may verify that the program\n1: a \u2190 not b 1: b \u2190 not a\nhas an infinite number of possibilistic answer sets, i.e.{ ac, b1\u2212c } for every c \u2208 [0, 1]."}, {"heading": "5 Possibilistic reduct", "text": "In the previous section, we have defined answer sets for PASP at the semantic level, in terms of possibility distributions satisfying certain constraints. This definition is a natural generalization of the characterization of answer sets in ASP from Section 3, but quite different from how answer sets are traditionally defined, namely through the Gelfond-Lifschitz reduct. In this section, we close this gap by introducing a generalization of the Gelfond-Lifschitz reduct, leading to a purely syntactic procedure for finding possibilistic answer sets. In contrast to (4), our reduct is defined w.r.t. a valuation and not simply a set of atoms. Hence, the certainty weights are taken into account when determining the reduct of a possibilistic normal program.\nDefinition 6. Let V be a valuation. The reduct PV of a possibilistic normal program P is defined as:\nPV ={((a0 \u2190 a1, ..., am),min(c1, c2)) | min(c1, c2) > 0 \u2227 c2 = max{c | {am+1, ..., an} \u2229 V 1\u2212c = \u2205, c \u2208 [0, 1]} \u2227 ((a0 \u2190 a1, ..., am, not am+1, ..., not an), c1) \u2208 P}.\nNote that PV is a possibilistic definite program.\nExample 4. Consider the program P1. Let V be a valuation such that V = { cB1 , lD0 .8 , can0 .2 } . The first rule of P1 is found unchanged in (P1) V\nsince we only need to consider the body > which clearly has no nafatoms. Hence min(c1, c2) = 1 with c1 = c2 = 1 and thus (cB \u2190, 1) \u2208 (P1)V . A similar line of though can be followed for the last rule, though this rule can only\nbe found as (can\u2190, 0.2) \u2208 P . Hence min(0.2, 1) = 0.2 and we have that (can \u2190, 0.2) \u2208 (P1)V . For the second rule, which has a non-empty body, we find that {can} \u2229 V 1\u2212c = \u2205 for c \u2264 0.8. We obtain that min(1, 0.8) = 0.8 and thus that (lD \u2190 cB, 0.8) \u2208 (P1) V .\nInterestingly, the reduct we obtain here is equivalent to the reduct that has been proposed in (Madrida\u0301s and Aciego, 2008) for residuated logic programs, in the special case where conjunction is modeled using the minimum. Both approaches are different in spirit, however, in the same way that possibilistic logic (which deals with uncertainty or priority) is different from Go\u0308del logic (which deals with graded truth). This formal correspondence with residuated logic programs is due to the fact that necessity measures are min-decomposable. As possibilistic logic is not truthfunctional in general, it is easy to see that possibilistic ASP diverges from residuated logic programming as soon as disjunction and strict negation are considered.\nBefore we can show how to find possibilistic answer sets using this reduct, we need to determine the syntactic least fixpoint operator that corresponds with our proposed semantics. For definite programs, it is easy to see that our semantics is equivalent to the one from (Nicolas et al., 2006), hence the least fixpoint operator from Definition 1 can be used to this end.\nProposition 5. Let P be a possibilistic normal program. If V is an answer set of P then V = ( PV )? .\nProposition 6. Let P be a possibilistic normal program and V a valuation. If V = ( PV )? then V is an answer set of P .\nExample 5. Once again consider the possibilistic program P1 from Section 1. Let V be a valuation such that V = { cB1 , lD0 .8 , can0 .2 } . We can now easily verify that V is an answer set of P1. From Example 4 we know that\n(P1) V = {(cB \u2190, 1), (lD \u2190 cB, 0.8), (can\u2190, 0.2)}\nfor which it is easy to verify that ( (P1) V )? = V . We\ncan also easily verify that V \u2032 = { cB1 , can0 .2 } is not an answer set. We obtain the same reduct as before\nand clearly ( (P1) V \u2032 )? = ( (P1) V )? 6= V \u2032."}, {"heading": "6 Simulation with classical ASP", "text": "The definition of the reduct from the previous section suggests a technique to simulate PASP using classical ASP. This is important, as it allows to straightforwardly implement PASP using existing ASP solvers.\nSpecifically, a possibilistic normal program P is simulated by the normal program Q containing the rules\n{a0c\u2032 \u2190 a1c\u2032, ..., amc\u2032, not am+1c\u2032\u2032, ..., not anc\u2032\u2032 | ((a0 \u2190 a1, ..., am, not am+1, ..., not an), c) \u2208 P, 0 < c\u2032 \u2264 c, c\u2032 \u2208 C, c\u2032\u2032 = min {d | d > 1\u2212 c\u2032, d \u2208 C}}\nwhere we introduce a fresh atom ac for each a in the original program and c \u2208 C. Example 6. Consider P1 from Section 1. For compactness, let C = {0, 0.2, 0.4, 0.6, 0.8, 1}. The classical normal program Q1 that simulates P1 contains the rules\ncB(1)\u2190 cB(0.8)\u2190 cB(0.6)\u2190 cB(0.4)\u2190 cB(0.2)\u2190 can(0.2)\u2190\nlD(1)\u2190 cB(1), not can(0.2) lD(0.8)\u2190 cB(0.8), not can(0.4) lD(0.6)\u2190 cB(0.6), not can(0.6) lD(0.4)\u2190 cB(0.4), not can(0.8) lD(0.2)\u2190 cB(0.2), not can(1.0).\nQ1 has the answer set\nM = {cB(1), cB(0.8), cB(0.6), cB(0.4), cB(0.2)} \u222a {lD(0.8), lD(0.6), lD(0.4), lD(0.2)} \u222a {can(0.2)} which indeed corresponds to the possibilistic answer set{ cB1 , lD0 .8 , can0 .2 } of P1.\nThe next two propositions confirm that this simulation is indeed correct and that we can use a classical normal program to obtain the possibilistic answer sets of our possibilistic normal program.\nProposition 7. Let P be a possibilistic normal program and Q the simulation of P defined above. Let V be the valuation defined by V (a) = max {c | ac \u2208M}. If M is a classical answer set of Q, then V is a possibilistic answer set of P .\nProposition 8. Let P be a possibilistic normal program and Q the simulation of P defined above, and M = {ac | c \u2264 V (a) = c\u2032, c \u2208 C}. If V is a possibilistic answer set of P such that V (a) \u2208 C for all a \u2208 BP , then M is a classical answer set of Q.\nOnly those possibilistic answer sets for which V (a) \u2208 C are found using our simulation. In particular, thus only a finite number of answer sets can be found."}, {"heading": "7 Related Work", "text": "A large body of research has been devoted to combining ASP with uncertainty. This uncertainty can\neither be interpreted in a qualitative or in a quantitative way. In the latter case, probability theory is most often used. For example, in (Baral et al., 2009) uncertainty is encoded by means of probability atoms. Intuitively, a probability atom describes the probability that the atom will take on a certain value in some random selection given other known evidence.\nInstead of probability theory, some approaches use evidence theory as the underlying model of uncertainty. For instance, (Wan, 2009) uses belief functions to allow intervals of certainty degrees to be attached to rules, instead of a single value. A similar approach can already be found in Fril (Baldwin et al., 1995) where fuzzy set theory is employed to derive certainty degrees from linguistic variables.\nThe most popular approach to deal with uncertainties in a qualitative fashion is possibility theory. Adopting possibility theory in logic programming was an idea pioneered in (Dubois et al., 1991), although default negation was not considered in this early work. One of the first papers to explore this idea in the context of ASP was (Nicolas et al., 2006) in which the authors present a framework that combines possibility theory with ASP. This approach was later extended to disjunctive programs (Nieves et al., 2007). Alternative semantics for PASP have been proposed based on pstable models (Confalonieri et al., 2009). However, pstable models (Osorio et al., 2006) are closer to classical models than they are to stable models, i.e. answer sets. The semantics based on pstable models capture a different intuition, focusing more on finding reasonable results in the face of inconsistency. For instance, the program containing the rule c: a \u2190 not a has (a, c) as its unique possibilistic pstable model, which is not compatible with a reading of \u2018not a\u2019 as \u201cit cannot be established that a is certain\u201d.\nThe constraint-based view on ASP we take in this paper is somewhat reminiscent of the idea of using SAT-based solvers to find answer sets (Lin and Zhao, 2002). Our approach also has some similarities to the one presented in (Benferhat et al., 1997) where default rules induce constraints on the possibility distribution. Specifically, a default rule \u201cif a then b\u201d is interpreted as \u03a0(a \u2227 b) > \u03a0(a \u2227 \u00acb), which captures the intuition that when a is known to hold, b is more plausible than \u00acb, unless information to the contrary becomes available. Similarly, they define entailment by looking at the least specific possibility distributions (although the notion of least specific possibility distribution is defined, in this context, w.r.t. the plausibility ordering on interpretations induced by the possibility degrees). Our approach also has some resemblance with the characterization of answer sets in auto-epistemic logic. Indeed, an ASP rule such as a \u2190 not b can be\ninterpreted by the formula \u00acLb\u2192 a in auto-epistemic logic, where Lb reflects the intuition \u201cit is not believed (certain) that b\u201d underlying our semantics.\nFrom an applications perspective, the purpose of combining ASP with uncertainty theories is often to deal with inconsistencies. Handling inconsistencies is by itself a well-studied field within the ASP community. Of particular interest are approaches that deal with preferences. Indeed, in possibilistic logic necessity degrees are commonly interpreted as preferences between rules. One example of preferences in classical ASP is (Nieuwenborgh and Vermeir, 2002), where ordered logic programs are used. Ordered logic programs assume a partial order among rules, allowing less important rules to be violated in order to satisfy rules with higher importance. In some sense, the use of such preferences among rules is related to using certainty weights, although the resulting semantics is closer in spirit to the approach from (Nicolas et al., 2006) than to the semantics we have developed in this paper. Quite a number of other works also deal with preference handling in non-monotonic reasoning; we refer to (Delgrande et al., 2004) for a good overview."}, {"heading": "8 Conclusions", "text": "We have introduced a new characterization of classical answer sets using possibility theory. Under these semantics, rules in a classical normal program impose a set of constraints on possibility distributions. The classical answer sets then correspond with the least specific possibilistic distributions that satisfy these constraints and adhere to some general restrictions. Subsequently, we have extended this idea to cover possibilistic ASP. The central observation was that the certainty of the conclusion of a rule should be given by the certainty that both the body of the rule is valid and that the rule itself is valid. We have also introduced a syntactic reduct that precisely corresponds to the proposed semantics for PASP. Finally, to demonstrate the applicability of our approach, we have shown how possibilistic normal programs can be simulated by classical normal programs."}, {"heading": "Acknowledgements", "text": "The authors would like to thank the anonymous reviewers for their useful comments, in particular for pointing out the link between our work and residuated logic programs."}], "references": [{"title": "Probabilistic reasoning with answer sets", "author": ["C. Baral", "M. Gelfond", "N. Rushton"], "venue": "Theory and Practice of Logic Programming, 9(1):57\u2013144.", "citeRegEx": "Baral et al\\.,? 2009", "shortCiteRegEx": "Baral et al\\.", "year": 2009}, {"title": "Nonmonotonic reasoning, conditional objects and possibility theory", "author": ["S. Benferhat", "D. Dubois", "H. Prade"], "venue": "Artif. Intell., 92(1\u20132):259\u2013276.", "citeRegEx": "Benferhat et al\\.,? 1997", "shortCiteRegEx": "Benferhat et al\\.", "year": 1997}, {"title": "Pstable semantics for logic programs with possibilistic ordered disjunction", "author": ["R. Confalonieri", "J.C. Nieves", "J. V\u00e1zquez-Salceda"], "venue": "Conference of AI*IA, pages 52\u201361.", "citeRegEx": "Confalonieri et al\\.,? 2009", "shortCiteRegEx": "Confalonieri et al\\.", "year": 2009}, {"title": "A classification and survey of preference handling approaches in nonmonotonic reasoning", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "K. Wang"], "venue": "Computational Intelligence, 20(2):308\u2013334.", "citeRegEx": "Delgrande et al\\.,? 2004", "shortCiteRegEx": "Delgrande et al\\.", "year": 2004}, {"title": "Towards possibilistic logic programming", "author": ["D. Dubois", "J. Lang", "H. Prade"], "venue": "Proc. of ICLP, pages 581\u2013595.", "citeRegEx": "Dubois et al\\.,? 1991", "shortCiteRegEx": "Dubois et al\\.", "year": 1991}, {"title": "Possibilistic logic", "author": ["D. Dubois", "J. Lang", "H. Prade"], "venue": "Handbook of Logic for Artificial Intelligence and Logic Programming, pages 439\u2013513.", "citeRegEx": "Dubois et al\\.,? 1994", "shortCiteRegEx": "Dubois et al\\.", "year": 1994}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifzchitz"], "venue": "Proc. of ICLP, pages 1081\u20131086.", "citeRegEx": "Gelfond and Lifzchitz,? 1988", "shortCiteRegEx": "Gelfond and Lifzchitz", "year": 1988}, {"title": "Twelve definitions of a stable model", "author": ["V. Lifschitz"], "venue": "Proc. of ICLP, pages 37\u201351.", "citeRegEx": "Lifschitz,? 2008", "shortCiteRegEx": "Lifschitz", "year": 2008}, {"title": "Assat: computing answer sets of a logic program by sat solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Proc. 18th AAAI conf., pages 112\u2013117.", "citeRegEx": "Lin and Zhao,? 2002", "shortCiteRegEx": "Lin and Zhao", "year": 2002}, {"title": "Towards a fuzzy answer set semantics for residuated logic programs", "author": ["N. Madrid\u00e1s", "Aciego", "O.-M."], "venue": "Proc. of WI-IAT \u201908, pages 260\u2013264.", "citeRegEx": "Madrid\u00e1s et al\\.,? 2008", "shortCiteRegEx": "Madrid\u00e1s et al\\.", "year": 2008}, {"title": "Possibilistic uncertainty handling for answer set programming", "author": ["P. Nicolas", "L. Garcia", "I. St\u00e9phan", "C. Lef\u00e8vre"], "venue": "Annals of Mathematics and Artificial Intelligence, 47(1\u20132):139\u2013181.", "citeRegEx": "Nicolas et al\\.,? 2006", "shortCiteRegEx": "Nicolas et al\\.", "year": 2006}, {"title": "Preferred answer sets for ordered logic programs", "author": ["D.V. Nieuwenborgh", "D. Vermeir"], "venue": "Proc. of JELIA, pages 432\u2013443.", "citeRegEx": "Nieuwenborgh and Vermeir,? 2002", "shortCiteRegEx": "Nieuwenborgh and Vermeir", "year": 2002}, {"title": "Semantics for possibilistic disjunctive programs", "author": ["J.C. Nieves", "M. Osorio", "U. Cort\u00e9s"], "venue": "Proc. of LPNMR, pages 315\u2013320.", "citeRegEx": "Nieves et al\\.,? 2007", "shortCiteRegEx": "Nieves et al\\.", "year": 2007}, {"title": "Logics with common weak completions", "author": ["M. Osorio", "J.A.N. P\u00e9rez", "J.R.A. Ram\u0131\u0301rez", "V.B. Ma\u0107\u0131as"], "venue": "J. of Logic and Comp.,", "citeRegEx": "Osorio et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Osorio et al\\.", "year": 2006}, {"title": "Belief logic programming", "author": ["H. Wan"], "venue": "Proc. of ICLP, pages 547\u2013548.", "citeRegEx": "Wan,? 2009", "shortCiteRegEx": "Wan", "year": 2009}, {"title": "Fuzzy sets as a basis for a theory of possibility", "author": ["L.A. Zadeh"], "venue": "Fuzzy Sets and Systems, pages 3\u201328.", "citeRegEx": "Zadeh,? 1978", "shortCiteRegEx": "Zadeh", "year": 1978}], "referenceMentions": [{"referenceID": 6, "context": "Answer set programming (ASP) is a form of declarative programming based on the stable model semantics (Gelfond and Lifzchitz, 1988).", "startOffset": 102, "endOffset": 131}, {"referenceID": 5, "context": "Possibilistic logic (PL), introduced in (Dubois et al., 1994), emanated from possibility theory (Zadeh, 1978) and offers a sound and complete logic system for representing (partial) ignorance or uncertainty in a nonprobabilistic way.", "startOffset": 40, "endOffset": 61}, {"referenceID": 15, "context": ", 1994), emanated from possibility theory (Zadeh, 1978) and offers a sound and complete logic system for representing (partial) ignorance or uncertainty in a nonprobabilistic way.", "startOffset": 42, "endOffset": 55}, {"referenceID": 10, "context": "Possibilistic answer set programming (PASP) (Nicolas et al., 2006) unites ASP and PL and provides a single", "startOffset": 44, "endOffset": 66}, {"referenceID": 10, "context": "However, for programs containing negation-as-failure, the semantics proposed in (Nicolas et al., 2006) often lead to counterintuitive results.", "startOffset": 80, "endOffset": 102}, {"referenceID": 10, "context": "The approach from (Nicolas et al., 2006) consists of first determining the classical answer sets, ignoring the certainty values, and subsequently adding certainties to atoms in these answer sets based on which rules are needed to support them.", "startOffset": 18, "endOffset": 40}, {"referenceID": 5, "context": "and evaluates the extent to which a proposition p is entailed by the available beliefs (Dubois et al., 1994).", "startOffset": 87, "endOffset": 108}, {"referenceID": 10, "context": "The immediate consequence operator from Definition 1 is equivalent to the one proposed in (Nicolas et al., 2006), although our formulation is slightly different.", "startOffset": 90, "endOffset": 112}, {"referenceID": 10, "context": "In (Nicolas et al., 2006) the reduct P of a possibilistic normal program P and a set of atoms A is defined as", "startOffset": 3, "endOffset": 25}, {"referenceID": 7, "context": "Although many equivalent definitions have already been proposed (Lifschitz, 2008), studying alternative definitions often leads to new insights.", "startOffset": 64, "endOffset": 81}, {"referenceID": 10, "context": "For definite programs, it is easy to see that our semantics is equivalent to the one from (Nicolas et al., 2006), hence the least fixpoint operator from Definition 1 can be used to this end.", "startOffset": 90, "endOffset": 112}, {"referenceID": 0, "context": "For example, in (Baral et al., 2009) uncertainty is encoded by means of probability atoms.", "startOffset": 16, "endOffset": 36}, {"referenceID": 14, "context": "For instance, (Wan, 2009) uses belief functions to allow intervals of certainty degrees to be attached to rules, instead of a single value.", "startOffset": 14, "endOffset": 25}, {"referenceID": 4, "context": "Adopting possibility theory in logic programming was an idea pioneered in (Dubois et al., 1991), although default negation was not considered in this early work.", "startOffset": 74, "endOffset": 95}, {"referenceID": 10, "context": "One of the first papers to explore this idea in the context of ASP was (Nicolas et al., 2006) in which the authors present a framework that combines possibility theory with ASP.", "startOffset": 71, "endOffset": 93}, {"referenceID": 12, "context": "This approach was later extended to disjunctive programs (Nieves et al., 2007).", "startOffset": 57, "endOffset": 78}, {"referenceID": 2, "context": "Alternative semantics for PASP have been proposed based on pstable models (Confalonieri et al., 2009).", "startOffset": 74, "endOffset": 101}, {"referenceID": 13, "context": "However, pstable models (Osorio et al., 2006) are closer to classical models than they are to stable models, i.", "startOffset": 24, "endOffset": 45}, {"referenceID": 8, "context": "The constraint-based view on ASP we take in this paper is somewhat reminiscent of the idea of using SAT-based solvers to find answer sets (Lin and Zhao, 2002).", "startOffset": 138, "endOffset": 158}, {"referenceID": 1, "context": "Our approach also has some similarities to the one presented in (Benferhat et al., 1997) where default rules induce constraints on the possibility distribution.", "startOffset": 64, "endOffset": 88}, {"referenceID": 11, "context": "One example of preferences in classical ASP is (Nieuwenborgh and Vermeir, 2002), where ordered logic programs are used.", "startOffset": 47, "endOffset": 79}, {"referenceID": 10, "context": "In some sense, the use of such preferences among rules is related to using certainty weights, although the resulting semantics is closer in spirit to the approach from (Nicolas et al., 2006) than to the semantics we have developed in this paper.", "startOffset": 168, "endOffset": 190}, {"referenceID": 3, "context": "Quite a number of other works also deal with preference handling in non-monotonic reasoning; we refer to (Delgrande et al., 2004) for a good overview.", "startOffset": 105, "endOffset": 129}], "year": 2010, "abstractText": "Possibilistic answer set programming (PASP) extends answer set programming (ASP) by attaching to each rule a degree of certainty. While such an extension is important from an application point of view, existing semantics are not well-motivated, and do not always yield intuitive results. To develop a more suitable semantics, we first introduce a characterization of answer sets of classical ASP programs in terms of possibilistic logic where an ASP program specifies a set of constraints on possibility distributions. This characterization is then naturally generalized to define answer sets of PASP programs. We furthermore provide a syntactic counterpart, leading to a possibilistic generalization of the well-known Gelfond-Lifschitz reduct, and we show how our framework can readily be implemented using standard ASP solvers.", "creator": "TeX"}}}