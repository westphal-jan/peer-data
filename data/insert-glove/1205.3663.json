{"id": "1205.3663", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Feb-2012", "title": "The Good, the Bad, and the Odd: Cycles in Answer-Set Programs", "abstract": "badal Backdoors of maziarz answer - posterity set .919 programs esmark are sets stolon of dinizulu atoms schroen that kuprin represent seventy-nine clever reasoning shortcuts through ferne the majdanek search space. soung Assignments to backdoor atoms maserati reduce the given program formula to kjemperud several hungtu programs that belong encouraging to a alchemy tractable heilbrun target class. ochida Previous huskey research accosting has 367,000 considered target classes moorland based on dafeng notions squatters of c17 acyclicity where various types mgt of cycles (good communicating and rudovsky bad cycles) 18,850 are excluded from graph .259 representations of lastra programs. We generalize b93 the resveratrol target classes by taking novelli the parity lexie of state-controlled the number omnitrix of counter-attacking negative 43.46 edges wallington on buttercup bad bnl cycles into iashvili account 25.83 and sergente consider backdoors burma for carsdirect.com such classes. bersama We bogza establish finch-hatton new yudina hardness results chunar and non - uniform conveyance polynomial - time educational tractability relative chough to directed or undirected cycles.", "histories": [["v1", "Wed, 15 Feb 2012 20:19:57 GMT  (15kb)", "http://arxiv.org/abs/1205.3663v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["johannes klaus fichte"], "accepted": false, "id": "1205.3663"}, "pdf": {"name": "1205.3663.pdf", "metadata": {"source": "CRF", "title": "The Good, the Bad, and the Odd: Cycles in Answer-Set Programs", "authors": ["Johannes Klaus Fichte"], "emails": ["fichte@kr.tuwien.ac.at"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 5.\n36 63\nv1 [\ncs .A\nI] 1"}, {"heading": "1 Introduction", "text": "Answer-set programming (ASP) is a popular framework to describe concisely search and combinatorial problems [14, 16]. It has been successfully applied in crypto-analysis, code optimization, the semantic web, and several other fields [18]. Problems are encoded by rules and constraints into disjunctive logic programs whose solutions are answer-sets (stable models). The complexity of finding an answer-set for a disjunctive logic program is \u03a3P2 -complete [4]. However this hardness result does not exclude quick solutions for large instances if we can exploit structural properties that might be present in real-world instances.\nRecently, Fichte and Szeider [5] have established a new approach to ASP based on the idea of backdoors, a concept that originates from the area of satisfiability [20]. Backdoors exploit the structure of instances by identifying sets of atoms that are important for reasoning. A backdoor of a disjunctive logic program is a set of variables such that any instantiation of the variables yields a simplified logic program that lies in a class of programs where the decision problem we are interested in is tractable. By means of a backdoor of size k for a disjunctive logic program we can solve the program by solving all the\n2k tractable programs that correspond to the truth assignments of the atoms in the backdoor. For each answer set of each of the 2k tractable programs we need to check whether it gives rise to an answer set of the given program. In order to do this efficiently we consider tractable programs that have a small number of answer sets (e.g., stratified programs [9]).\nWe consider target classes based on various notions of acyclicity on the directed/undirected dependency graph of the disjunctive logic program. A cycle is bad if it contains an edge that represents an atom from a negative body of a rule. Since larger target classes facilitate smaller backdoors, we are interested in large target classes that allow small backdoors and efficient algorithms for finding the backdoors.\nContribution\nIn this paper, we extend the backdoor approach of [5] using ideas from Zhao [23]. We enlarge the target classes by taking the parity of the number of negative edges or vertices on bad cycles into account and consider backdoors with respect to such classes. This allows us to consider larger classes that also contain nonstratified programs. Our main results are as follows:\n1. For target classes based on directed bad even cycles, the detection of backdoors of bounded size is intractable (Theorem 1).\n2. For target classes based on undirected bad even cycles, the detection of backdoors is polynomial-time tractable (Theorem 3).\nThe result (2) is a non-uniform polynomial-time result since the order of the polynomial depends on the backdoor size. An algorithm is uniform polynomialtime tractable if it runs in timeO(f(k)\u00b7nc) where f is an arbitrary function and c is a constant independent from k. Uniform polynomial-time tractable problems are also known as fixed-parameter tractable problems [3]. We provide strong theoretical evidence that result (2) cannot be extended to uniform polynomialtime tractability. Further, we establish that result (2) generalizes a result of Lin and Zhao [13]."}, {"heading": "2 Formal Background", "text": "We consider a universe U of propositional atoms. A literal is an atom a \u2208 U or its negation \u00aca. A disjunctive logic program (or simply a program) P is a set of rules of the following form\nx1 \u2228 . . . \u2228 xl \u2190 y1, . . . , yn,\u00acz1, . . . ,\u00aczm. (1)\nwhere x1, . . . , xl, y1, . . . , yn, z1, . . . , zm are atoms and l, n,m are non-negative integers. Let r be a rule. We write {x1, . . . , xl} = H(r) (the head of r) and {y1, . . . , yn, z1, . . . , zm} = B(r) (the body of r). We abbreviate the positive literals of the body by B+(r) = {y1, . . . , yn} and the negative literals by\nB\u2212(r) = {z1, . . . , zm}. We denote the sets of atoms occurring in a rule r or in a program P by at(r) = H(r) \u222a B(r) and at(P ) = \u22c3\nr\u2208P at(r), respectively. A rule r is normal if |H(r)| = 1. A rule is Horn if normal and |B\u2212(r)| = 0. We say that a program has a certain property if all its rules have the property. Horn refers to the class of all Horn programs.\nA setM of atoms satisfies a rule r if (H(r) \u222aB\u2212(r)) \u2229M 6= \u2205 or B+(r)\\M 6= \u2205. M is a model of P if it satisfies all rules of P . The Gelfond-Lifschitz (GL) reduct of a program P under a set M of atoms is the program PM obtained from P by first removing all rules r with B\u2212(r) \u2229M 6= \u2205 and second removing all \u00acz where z \u2208 B\u2212(r) from the remaining rules r [10]. M is an answer-set (or stable set) of a program P if M is a minimal model of PM . We denote by AS(P ) the set of all answer-sets of P . The main computational problems in ASP are:\n\u2022 Consistency: given a program P , does P have an answer-set?\n\u2022 Credulous/Skeptical Reasoning: given a program P and an atom a \u2208 at(P ), is a contained in some/all answer-set(s) of P?\n\u2022 AS Counting: how many answer-sets does P have?\n\u2022 AS Enumeration: list all answer-sets of P .\nA truth assignment is a mapping \u03c4 : X \u2192 {0, 1} defined for a set X \u2286 U of atoms. For x \u2208 X we put \u03c4(\u00acx) = 1\u2212 \u03c4(x). By ta(X) we denote the set of all truth assignments \u03c4 : X \u2192 {0, 1}. Let \u03c4 \u2208 ta(X) and P be a program."}, {"heading": "2.1 Strong Backdoors", "text": "Backdoors are small sets of atoms which can be used to simplify the considered computational problems in ASP. They have originally been introduced by Williams, Gomes, and Selman [20, 21] as a concept to the analysis of decision heuristics in propositional satisfiability [6]. Fichte and Szeider [5] have recently adapted backdoors to the field of ASP. First, we define a reduct of a program with respect to a given set of atoms. Subsequently, we give the notion of strong backdoors. In the following we refer to C as the target class of the backdoor.\nDefinition 1. Let P be a program, X a set of atoms, and \u03c4 \u2208 ta(X). The truth assignment reduct of P under \u03c4 is the logic program P\u03c4 obtained by\n1. removing all rules r with H(r) \u2229 \u03c4\u22121(1) 6= \u2205 or H(r) \u2286 X;\n2. removing all rules r with B+(r) \u2229 \u03c4\u22121(0) 6= \u2205;\n3. removing all rules r with B\u2212(r) \u2229 \u03c4\u22121(1) 6= \u2205;\n4. removing from the heads and bodies of the remaining rules all literals v,\u00acv with v \u2208 X.\nDefinition 2. A set X of atoms is a strong C-backdoor of a program P if P\u03c4 \u2208 C for all truth assignments \u03c4 \u2208 ta(X). We define the problem of finding strong backdoors as follows: k-Strong C-Backdoor Detection: given a program P , find a strong C-backdoor X of P of size at most k, or report that such X does not exist.\nExample 1. Consider the program P = {b \u2190 a; d \u2190 a; b \u2190 \u00acc; a \u2190 d,\u00acc; a\u2228 c \u2190 d,\u00acb; d}. The set X = {b, c} is a strong Horn-backdoor since the truth assignment reducts Pb=0,c=0 = P00 = {\u2190 a; d \u2190 a; a \u2190 d; d}, P01 = {\u2190 a; d \u2190 a; d}, P10 = {d \u2190 a; a \u2190 d; d}, and P11 = {d \u2190 a; d} are in the target class Horn.\nDefinition 3. Let P be a program and X a set of atoms. We define\nAS(P,X) = {M \u222a \u03c4\u22121(1) : \u03c4 \u2208 ta(X \u2229 at(P )),M \u2208 AS(P\u03c4 ) } .\nLemma 1 ([5]). AS(P ) \u2286 AS(P,X) holds for every program P and every set X of atoms.\nFigure 1 illustrates how we can exploit backdoors to find answer sets of a program. Once we have found a strong C-backdoor X , we can simplify the program P to programs which belong to the target class C. Then we consider all |ta(X)| truth assignments to the atoms in the backdoor X . We compute the answer sets AS(P\u03c4 ) for all \u03c4 \u2208 ta(X). Finally, we obtain the answer set AS(P ) by checking for each M \u2208 AS(P\u03c4 ) whether it gives rise to an answer-set of P .\nExample 2. We consider the program of Example 1. The answer-sets of P\u03c4 are AS(P00) = {{a, d}}, AS(P01) = {{d}}, AS(P10) = {{a, d}}, and AS(P11) = {{d}}. Thus AS(P,X) = {{a, d}, {c, d}, {a, b, d}, {b, c, d}}, and since {c, d} and {a, b, d} are answer-sets of P , we obtain AS(P ) = {{a, b, d}, {c, d}}.\nDefinition 4. A class C of programs is enumerable if for each P \u2208 C we can compute AS(P ) in polynomial time."}, {"heading": "2.2 Deletion Backdoors", "text": "For a program P and a set X of atoms we define P \u2212X as the program obtained from P by deleting all atoms contained in X from the heads and bodies of all the rules of P and their negations. The definition gives rise to deletion backdoors and the problem of finding deletion backdoors, which is in some cases easier to solve than the problem of finding strong backdoors.\nDefinition 5 (Deletion C-backdoor). Let C be a class of programs. A set X of atoms is a deletion C-backdoor of a program P if P \u2212 X \u2208 C. We define the problem k-Deletion C-Backdoor Detection as follows: given a program P , find a deletion C-backdoor X of P of size at most k, or report that such X does not exist."}, {"heading": "2.3 Target Classes", "text": "As explained above, we need to consider target classes of programs that only have a small number of answer sets. There are two causes for a program to have a large number of answer sets: (i) disjunctions in the heads of rules, and (ii) certain cyclic dependencies between rules. Disallowing both causes yields socalled stratified programs [9]. In the following we require normality and consider various types of acyclicity to describe target classes. In order to define acyclicity we associate with each normal program P its directed dependency graph DP [1], and its undirected dependency graph UP [11]. DP has as vertices the atoms of P and a directed edge (x, y) between any two atoms x, y for which there is a rule r \u2208 P with x \u2208 H(r) and y \u2208 B(r); if there is a rule r \u2208 P with x \u2208 H(r) and y \u2208 B\u2212(r), then the edge (x, y) is called a negative edge. UP is obtained from Dp by replacing each negative edge e = (x, y) with two undirected edges {x, ve}, {ve, y} where ve is a new negative vertex, and by replacing each remaining directed edge (u, v) with an undirected edge {u, v}. By an (un)directed cycle of P we mean an (un)directed cycle in DP (UP ). An (un)directed cycle is bad if it contains a negative edge (a negative vertex), otherwise it is good.\nIn recent research, Fichte and Szeider [5] have considered target classes that consist of normal programs without directed bad cycles (no-DBC), without undirected bad cycles (no-BC), without directed cycles (no-DC), and without undirected cycles (no-C). no-DBC is exactly the class that contains all stratified programs [1]. Fichte and Szeider have examined the problems k-Strong C-Backdoor Detection and k-Deletion C-Backdoor Detection on the target classes C \u2208 {no-C,no-BC,no-DC,no-DBC}.\nExample 3. The set X = {a, b} is a deletion no-DBEC-backdoor of the program P of Example 1, since the simplification P \u2212X = {d; \u2190 \u00acc; \u2190 d,\u00acc} is in the target class no-DBEC. We observe easily that there exists no deletion no-DBEC-backdoor of size 1."}, {"heading": "3 Parity Cycles", "text": "In this section, we generalize the acyclicity based target classes by taking the parity of the number of negative edges (vertices) into account and consider backdoors for such classes. We say that an (un)directed cycle in a given program P is even if the cycle has an even number of negative edges (vertices). The definition gives rise to the new target classes of all normal programs without directed bad even cycles (no-DBEC), without undirected bad even cycles (no-BEC), without directed even cycles (no-DEC), and without even cycles (no-EC)."}, {"heading": "3.1 Computing Answer-Sets", "text": "First, we discuss the connection between the problem of finding bad even cycles in signed graphs and even cycles in graphs. A signed (directed) graph is a graph whose edges are either positive (unlabeled) or negative. We construct the unlabeled directed graph G\u2032 of a signed directed graph G = (V,E) as follows: we replace in G each positive edge e = (u, v) \u2208 E by two edges (u, ve), (ve, v) where ve is a new vertex. Then we remove the labels from the negative edges. Analogously, we construct the unlabeled undirected graph where we ignore the direction of the edges. The following connection was already observed by Aracena, Gajardo, and Montalva [15].\nLemma 2 ([15]). A signed (un)directed graph G has an even cycle if and only if its unlabeled (un)directed graph G\u2032 has a cycle of even length.\nProof. Let G = (V,E) be the signed directed graph and G\u2032 = (V \u2032, E\u2032) its unlabeled directed graph. Since every positive edge e \u2208 E corresponds to two edges e1, e2 \u2208 E\u2032 and every negative edge e \u2208 E corresponds to one edge e \u2208 E\u2032, a cycle in G with an even number of negative edges gives a cycle of even length in G\u2032. Conversely, let G\u2032 = (V \u2032, E\u2032) be an unlabeled directed graph that contains a cycle of even length. Then G contains an even cycle since every two edges e1, e2 \u2208 E\u2032 correspond either to two negative edges or no negative edge. The proof works analogously for undirected graphs.\nThe well-founded reduct of a program P under an interpretation \u03c4 is the logic program PWF\u03c4 we obtain by removing all rules r \u2208 P where some at(r) \u2208 \u03c4\n\u22121(0), and removing from all rules r \u2208 P all literals x \u2208 at(r) where x \u2208 \u03c4\u22121(1). We obtain the program P+ (P\u2212) by removing all rules from P where B+(r) 6= \u2205 (B\u2212(r) 6= \u2205 respectively). The well-founded model WFM(P ) of a program P is the least fixed point of the sequence of interpretations where \u03c40 := \u2205, \u03c4 \u22121 k+1(1) consists of the least model of P+(PWF\u03c4 ) and \u03c4 \u22121 k+1(0) consists of the atoms of P+(PWF\u03c4 ) that are not in the least model.\nLemma 3. The target classes no-DBEC,no-BEC,no-DEC,no-EC are enumerable.\nProof. Zhao [23] has shown that a program without a bad even cycle has either no answer-set or the well-founded model is its answer-set. Since in the definition of the well-founded model the sequence of \u03c40, \u03c41, . . . is monotone for a normal program, there is a least fixed point and it can be computed in polynomial time [7, 8]. Thus the answer sets can be computed in polynomial time. Let P be a program and DP (UP ) its (un)directed dependency graph. Since every bad even cycle in DP is also a bad even cycle in UP , this holds for the undirected case. Considering the fact that every bad even cycle in DP is also an even cycle in DP , the lemma sustains for the target class no-DEC. Since every bad even cycle in DP is also an even cycle UP , it prevails for the remaining target class no-EC.\nProposition 1. The problems Consistency, Credulous and Skeptical Reasoning, AS Counting and AS Enumeration are all polynomial-time solvable for programs with strong C-backdoor of bounded size, C \u2208 {no-DBEC, no-BEC,no-DEC,no-EC}, assuming that the backdoor is given as an input.\nProof. Let X be the given backdoor. By Lemma 3 each target class C is enumerable. Since we have |AS(P,X)| \u2264 2|X|, we can solve each listed problem by making at most 2|X| polynomial checks.\nIf the problem of determining backdoors is also polynomial-time solvable with respect to the fixed size of a smallest strong C-backdoor, then the ASP problems are polynomial-time solvable.\nLemma 4. For all target classes C \u2208 {no-DBEC,no-BEC,no-DEC,no-EC} every deletion C-backdoor is also a strong C-backdoor.\nProof. We show the statement by proving that P\u03c4 \u2286 P \u2212X for every \u03c4 \u2208 ta(X) and for every program P \u2208 C. Let P be a program and X a set of atoms of P . We choose arbitrarily a truth assignment \u03c4 \u2208 ta(X). For a rule r \u2208 P if H(r) \u2229 \u03c4\u22121(1) 6= \u2205 or H(r) \u2286 X or B+(r) \u2229 \u03c4\u22121(0) 6= \u2205 or B\u2212(r) \u2229 \u03c4\u22121(1) 6= \u2205, then r is removed from P by the truth assignment reduct of P under \u03c4 . However removing all literals x,\u00acx with x \u2208 X from the head H(r) and the body B(r) yields a new rule r\u2032 \u2208 P \u2212 X . Thus r\u2032 /\u2208 P\u03c4 and r\u2032 \u2208 P \u2212 X where r\u2032 \u2286 r. If the conditions (1), (2), and (3) of Definition 1 above do not apply, then all literals v,\u00acv with v \u2208 X are removed from the heads H(r) and bodies B(r) by the truth assignment reduct of P under \u03c4 . This is also done by P \u2212X . Hence P\u03c4 \u2286 P \u2212X ."}, {"heading": "3.2 Backdoor Detection for Directed Target Classes", "text": "In order to apply backdoors we need to find them first. In this section we consider the problems k-Strong C-Backdoor Detection and k-Deletion C-Backdoor Detection for the target classes C \u2208 {no-DEC,no-DBEC}.\nFor an unlabeled directed graph G = (V,E) and fixed vertices s,m, t \u2208 V we define the program Ps,m,t(G) as follows: For each edge e = (v, w) \u2208 E where v, w \u2208 V and w 6= m we construct a rule re: v \u2190 w. For the edges e\u2032 = (v\u2032,m) where v\u2032 \u2208 V we construct a rule re\u2032 : v\u2032 \u2190 \u00acm. Then we add the rule rs,t: t \u2190 \u00acs.\nLemma 5. Let G = (V,E) be a directed graph and s,m, t three distinct vertices of G. Then G has a simple path from s to t via m if and only if Ps,m,t(G) /\u2208 no-DBEC.\nProof. Let G be a graph and and p = (s, s1, . . . , sk,m, t1, . . . , tl, t) a path in G where s 6= m,m 6= t, s 6= t. The construction Ps,m,t gives rules {s \u2190 s1; s1 \u2190 s2; . . . sk \u2190 \u00acm; m \u2190 t1; t1 \u2190 t2; . . . t \u2190 t; t \u2190 \u00acs} \u2208 Ps,m,t(G). Since DP contains the cycle c = (s, s1, . . . , sk,m, t1, . . . , t, s) and c contains an even number of negative edges, the program Ps,m,t(G) /\u2208 no-DBEC.\nConversely, let Ps,m,t(G) \u2208 no-DBEC, then Ps,m,t(G) contains a bad even cycle c. Since the construction of Ps,m,t(G) gives only negative edges (t, s) \u2208 DPs,m,t(G) and (v,m) \u2208 DPs,m,t(G) where v \u2208 at(Ps,m,t(G)), the cycle c must have the vertices s,m, and t. Further every rule re \u2208 Ps,m,t(G) corresponds to an edge e \u2208 E. It follows that there is a simple path s, . . . ,m, . . . , t.\nTheorem 1. The problems k-Strong no-DBEC-Backdoor Detection and k-Deletion no-DBEC-Backdoor Detection are co-NP-hard for every constant k \u2265 0.\nProof. Let k \u2265 0. Let G be a given directed graph and t,m, s vertices of G. It was shown by Lapaugh and Papadimitriou [12] that deciding whether G contains a simple path from s to t via m is NP-complete. By Lemma 5, such a path exists if and only if Ps,m,t(G) /\u2208 no-DBEC, hence recognizing no-DBEC is co-NPhard. Let Gk denote the graph obtained from G by adding k disjoint bad even cycles. Clearly Gk has a deletion no-DBEC-Backdoor of size \u2264 k if and only if Ps,m,t(Gk) \u2208 no-DBEC, hence k-Deletion no-DBEC-Backdoor Detection is co-NP-hard. Similarly, Gk has a strong no-DBEC-Backdoor of size \u2264 k if and only if Ps,m,t(Gk) \u2208 no-DBEC, and so k-Strong no-DBECBackdoor Detection is co-NP-hard as well.\nTheorem 2. Let k > 0 be a constant. The problems k-Deletion no-DECBackdoor Detection and k-Strong no-DEC-Backdoor Detection are polynomial-time tractable.\nProof. By Lemma 2, we can reduce to the problem of finding a cycle of even length in the unlabeled dependency graph. Vazirani and Yannakakis [19] have shown that finding a cycle of even length in a directed graph is equivalent to finding a Pfaffian orientation of a graph. Since Robertson, Seymour, and Thomas [17] have shown that a Pfaffian orientation can be found in polynomial time. For each possible backdoor of size k we need to test ( n\nk\n)\n\u2264 nk subsets S \u2286 V of size k whether DP \u2212 S contains a cycle of even length, respectively DP\u03c4 for \u03c4 \u2208 ta(S). Since we can do this in polynomial time for each fixed k, the theorem follows.\nIn Theorem 2 we consider k as a constant. In the following proposition we show that if k is considered as part of the input, then the problem k-Strong no-DEC-Backdoor Detection is polynomial-time equivalent to the problem Hitting Set and k is preserved. An instance of this problem is a pair (S, k) where S = {S1, . . . , Sm} is a family of sets and k is an integer. The question is whether there exists a set H of size at most k which intersects with all the Si; such H is a hitting set. Note that there is strong theoretical evidence that the problem Hitting Set does not admit uniform polynomial-time tractability [3].\nProposition 2. The problem k-Strong no-DEC-Backdoor Detection is polynomial-time equivalent to the problem Hitting Set.\nProof. The proof is very similar to the proof for target classes without respecting the parity by Fichte and Szeider [5]. We construct a program P as follows. As atoms we take the elements of S = \u22c3m\ni=1 Si and new atoms a j i and b j i for\n1 \u2264 i \u2264 m, 1 \u2264 j \u2264 k + 1. For each 1 \u2264 i \u2264 m and 1 \u2264 j \u2264 k + 1 we take two rules rji , s j i where H(r j i ) = {a j i}, B \u2212(rji ) = Si\u222a{b j i}, B +(rji ) = \u2205; H(s j i ) = {b j i}, B\u2212(sji ) = {a j i}, B\n+(sji ) = S. We show that S has a hitting set of size at most k if and only if P has a strong no-DEC-backdoor of size at most k. Let S be a family of sets and H an hitting set of S of size at most k. Choose arbitrarily an atom si \u2208 at(P ) \u2229S and a truth assignment \u03c4 \u2208 ta(H). If si \u2208 \u03c4\u22121(0), then B+(s j i ) \u2229 \u03c4 \u22121(0) 6= \u2205\nfor 1 \u2264 j \u2264 k + 1. Thus sji /\u2208 P\u03c4 . If si \u2208 \u03c4 \u22121(1), then B\u2212(rji ) \u2229 \u03c4 \u22121(1) 6= \u2205 for 1 \u2264 j \u2264 k+ 1. Thus rji /\u2208 P\u03c4 . Since H contains at least one element e \u2208 S from each set S \u2208 S, the truth assignment reduct P\u03c4 \u2208 no-DEC. We conclude that H is a strong no-DEC-backdoor of P of size at most k.\nConversely, letX be a strong no-DEC-backdoor of P of size at most k. Since the directed dependency graphDP contains k+1 directed even cycles (a j i , b j i , a j i ) and aji (respectively b j i ) is contained in exactly one rule r j i (respectively s j i ), | \u22c3\naji | > k and | \u22c3 bji | > k. Hence we have to select atoms from Si. Since Si \u2286 B\u2212(r j i ) for 1 \u2264 i \u2264 m and 1 \u2264 j \u2264 k + 1, we have to select at least one element from each Si into the backdoor X . Thus we have established that X is a hitting set of S, and so the theorem follows."}, {"heading": "3.3 Backdoor Detection for Undirected Target Classes", "text": "The results of Theorem 1 suggest to consider the backdoor detection on the weaker target classes based on undirected even acyclicity.\nLemma 6. Let P be a program, P \u2208 no-EC can be decided in polynomial time.\nProof. Let P be a program and G its dependency graph UP . Lemma 2 allows to consider the problem of finding an even cycle in the unlabeled version of UP . Since Yuster and Zwick [22] have shown that finding an even cycle in an undirected graph is polynomial-time solvable, the lemma holds.\nLemma 7. Let P be a program. The problem of deciding whether P \u2208 no-BEC can be solved in polynomial time.\nProof. Let P be a program and G its dependency graph UP . For a negative edge e of G we define Ge to be the unlabeled graph of G\u2212 e. Now G contains a bad even cycle if and only if G has an edge e = {s, t} such that Ge contains an odd path from s to t. Since Arikati and Peled [2] have shown that finding an odd path in an undirected graph is polynomial-time solvable, the lemma follows.\nTheorem 3. Let k > 0 be a constant. For the target classes C \u2208 {no-EC, no-BEC} the problems k-Deletion C-Backdoor Detection and k-Strong C-Backdoor Detection are non-uniform polynomial-time tractable.\nProof. Let P be a program and UP = (V,E) its undirected dependency graph. Let n be the size of V . For each possible backdoor of size k we need to test (\nn k\n)\n\u2264 nk subsets S \u2286 V of size k whether UP \u2212 S contains a (bad) cycle of even length, respectively UP\u03c4 for \u03c4 \u2208 ta(S). Since we can do this in polynomial time for each fixed k, the problems k-Deletion C-Backdoor and k-Strong C-Backdoor Detection are non-uniform polynomial-time tractable.\nIn Theorem 3 we consider k as a constant. If k is considered as part of the input we can show that for each class C \u2208 {no-EC,no-BEC} the problem k-Strong C-Backdoor Detection is polynomial-time equivalent to Hitting Set [5]. As mentioned before for no-DEC there is strong theoretical\nevidence that k-Strong C-Backdoor Detection does not admit a uniform polynomial-time tractability result.\nProposition 3. The problem k-Strong C-Backdoor Detection is polynomial-time equivalent to the problem Hitting Set for each class C \u2208 {no-EC, no-BEC}.\nProof. Wemodify the above reduction fromHitting Set by redefining the rules rji , s j i . We put H(r j i ) = {a j i}, B \u2212(rji ) = Si \u222a {b j i}, B +(rji ) = Si; H(s j i ) = {b j i}, B\u2212(sji ) = {a j i}, B +(sji ) = \u2205."}, {"heading": "4 Relationship between Target Classes", "text": "In this section, we compare ASP parameters in terms of their generality. We have already observed that every deletion C-backdoor is a strong C-backdoor for a target class C \u2208 {no-EC,no-DEC,no-BEC,no-DBEC}. For the considered target classes it is easy to see that if C \u2286 C\u2032, then every C\u2032 backdoor of a program P is also a C-backdoor, but there might exist smaller C\u2032-backdoors. Thus we compare the target classes among each other instead of the backdoors. By definition we have no-DBC ( no-DBEC, no-DEC ( no-DBEC, no-EC ( no-BEC, no-C ( no-EC, and no-DC ( no-DEC. The diagram in Fig. 3 shows the relationship between the various classes, an arrow from C to C\u2032 indicates that C is a proper subset of C\u2032. If there is no arrow between two classes (or the arrow does not follow by transitivity of set inclusion), then the two classes are incomparable.\nLin and Zhao [13] have studied even cycles as a parameter to ASP. They have proved that for fixed k the main reasoning problems are polynomial-time solvable if the number of the shortest even cycles is bounded. The following proposition states that size of no-DBEC-backdoors is a more general parameter than the number of even cycles.\nProposition 4. There is a function f such that k \u2264 f(l) and no function g such that l < g(k) for all programs P where k is the size of the smallest deletion-no-DBEC-backdoor of P and l is the number of even cycles in DP .\nProof. Let P be some program. If P has at most k bad even cycles, we can construct a no-DBEC-backdoor X for P by taking one element from each bad even cycle into X . Thus there is a function f such that k \u2264 f(l). If a program P has a no-DBEC-backdoor of size 1, it can have arbitrary many even cycles that run through the atom in the backdoor. It follows that there is no function g such that l < g(k) and the proposition holds."}, {"heading": "5 Conclusion", "text": "We have extended the backdoor approach of [5] by taking the parity of the number of negative edges on bad cycles into account. In particular, this allowed us to consider target classes that contain non-stratified programs. We have established new hardness results and non-uniform polynomial-time tractability depending on whether we consider directed or undirected even cycles. We have shown that the backdoor approach with parity target classes generalize a result of Lin and Zhao [13]. Since Theorem 1 states that target classes based on directed even cycles are intractable, we think these target classes are of limited practical interest. The results of this paper give rise to research questions that are of theoretical interest. For instance, it would be stimulating to find out whether the problem k-Strong C-Backdoor Detection is uniform polynomial-time solvable (fixed-parameter tractable) for the classes no-BC and no-BEC, which is related to the problems parity feedback vertex set and parity subset feedback vertex set."}, {"heading": "Acknowledgement", "text": "The author would like to thank Stefan Szeider for suggesting the new target class that takes the parity of the number of negative edges into account, for many helpful comments, and his valuable advice. Serge Gaspers for pointing out the result of Arikati and Peled on finding odd paths in polynomial time and many helpful comments and to the anonymous referees for their helpful comments. The author was supported by the European Research Council (ERC), Grant COMPLEX REASON 239962."}], "references": [{"title": "Towards a theory of declarative knowledge, 89\u2013148", "author": ["K.R. Apt", "H.A. Blair", "A. Walker"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1988}, {"title": "U.N.: A polynomial algorithm for the parity path problem on perfectly orientable graphs", "author": ["S.R. Arikati", "Peled"], "venue": "Discrete Applied Mathematics 65(1-", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1996}, {"title": "Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Monographs in Computer Science,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1999}, {"title": "On the computational cost of disjunctive logic programming: Propositional case", "author": ["T. Eiter", "G. Gottlob"], "venue": "Annals of Mathematics and AI 15(3-4),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1995}, {"title": "Backdoors to tractable answer-set programming", "author": ["J.K. Fichte", "S. Szeider"], "venue": "Twenty-Second International Joint Conference on AI (IJCAI)", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Backdoors to Satisfaction", "author": ["S. Gaspers", "S. Szeider"], "venue": "CoRR abs/1110.6387,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "The alternating fixpoint of logic programs with negation", "author": ["A. Van Gelder"], "venue": "Proceedings of the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1989}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "J. ACM 38(3),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1991}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the Fifth International Conference and Symposium (ICLP/SLP)", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Comput. 9(3/4),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1991}, {"title": "Fixed-parameter complexity in AI and nonmonotonic reasoning", "author": ["G. Gottlob", "F. Scarcello", "M. Sideri"], "venue": "AI 138(1-2),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2002}, {"title": "The even-path problem for graphs and digraphs", "author": ["A.S. Lapaugh", "C.H. Papadimitriou"], "venue": "Networks 14(4),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1984}, {"title": "On odd and even cycles in normal logic programs", "author": ["F. Lin", "X. Zhao"], "venue": "Proceedings of the 19th national conference on AI (AAAI). 80\u201385", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2004}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V.W. Marek", "M. Truszczynski"], "venue": "The Logic Programming Paradigm", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1999}, {"title": "On the complexity of feedback set problems in signed digraphs", "author": ["M. Montalva", "J. Aracena", "A. Gajardo"], "venue": "Electronic Notes in Discrete Mathematics", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and AI 25(3),", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1999}, {"title": "Permanents, Pfaffian orientations, and even directed circuits", "author": ["N. Robertson", "P. Seymour", "R. Thomas"], "venue": "Annals of Mathematics 150(3),", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1999}, {"title": "Collection on answer set programming (ASP) and more", "author": ["T. Schaub"], "venue": "Tech. rep.,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "Pfaffian orientations, 0/1 permanents, and even cycles in directed graphs", "author": ["V. Vazirani", "M. Yannakakis"], "venue": "Automata, Languages and Programming, LNCS", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1988}, {"title": "Backdoors to typical case complexity", "author": ["R. Williams", "C. Gomes", "B. Selman"], "venue": "Proceedings of the Eighteenth International Joint Conference on AI (IJCAI)", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2003}, {"title": "On the connections between backdoors, restarts, and heavy-tailedness in combinatorial search", "author": ["R. Williams", "C. Gomes", "B. Selman"], "venue": "Proceedings of the Sixth International Conference on Theory and Applications of Satisfiability Testing (SAT)", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2003}, {"title": "Finding even cycles even faster", "author": ["R. Yuster", "U. Zwick"], "venue": "Automata, Languages and Programming, LNCS", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1994}, {"title": "A Study of Answer set Programming", "author": ["J. Zhao"], "venue": "Mphil thesis, The Hong Kong University of Science and Technology, Dept. of Computer Science", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2002}], "referenceMentions": [{"referenceID": 13, "context": "Answer-set programming (ASP) is a popular framework to describe concisely search and combinatorial problems [14, 16].", "startOffset": 108, "endOffset": 116}, {"referenceID": 15, "context": "Answer-set programming (ASP) is a popular framework to describe concisely search and combinatorial problems [14, 16].", "startOffset": 108, "endOffset": 116}, {"referenceID": 17, "context": "It has been successfully applied in crypto-analysis, code optimization, the semantic web, and several other fields [18].", "startOffset": 115, "endOffset": 119}, {"referenceID": 3, "context": "The complexity of finding an answer-set for a disjunctive logic program is \u03a32 -complete [4].", "startOffset": 88, "endOffset": 91}, {"referenceID": 4, "context": "Recently, Fichte and Szeider [5] have established a new approach to ASP based on the idea of backdoors, a concept that originates from the area of satisfiability [20].", "startOffset": 29, "endOffset": 32}, {"referenceID": 19, "context": "Recently, Fichte and Szeider [5] have established a new approach to ASP based on the idea of backdoors, a concept that originates from the area of satisfiability [20].", "startOffset": 162, "endOffset": 166}, {"referenceID": 8, "context": ", stratified programs [9]).", "startOffset": 22, "endOffset": 25}, {"referenceID": 4, "context": "Contribution In this paper, we extend the backdoor approach of [5] using ideas from Zhao [23].", "startOffset": 63, "endOffset": 66}, {"referenceID": 22, "context": "Contribution In this paper, we extend the backdoor approach of [5] using ideas from Zhao [23].", "startOffset": 89, "endOffset": 93}, {"referenceID": 2, "context": "Uniform polynomial-time tractable problems are also known as fixed-parameter tractable problems [3].", "startOffset": 96, "endOffset": 99}, {"referenceID": 12, "context": "Further, we establish that result (2) generalizes a result of Lin and Zhao [13].", "startOffset": 75, "endOffset": 79}, {"referenceID": 9, "context": "The Gelfond-Lifschitz (GL) reduct of a program P under a set M of atoms is the program P obtained from P by first removing all rules r with B(r) \u2229M 6= \u2205 and second removing all \u00acz where z \u2208 B(r) from the remaining rules r [10].", "startOffset": 222, "endOffset": 226}, {"referenceID": 19, "context": "They have originally been introduced by Williams, Gomes, and Selman [20, 21] as a concept to the analysis of decision heuristics in propositional satisfiability [6].", "startOffset": 68, "endOffset": 76}, {"referenceID": 20, "context": "They have originally been introduced by Williams, Gomes, and Selman [20, 21] as a concept to the analysis of decision heuristics in propositional satisfiability [6].", "startOffset": 68, "endOffset": 76}, {"referenceID": 5, "context": "They have originally been introduced by Williams, Gomes, and Selman [20, 21] as a concept to the analysis of decision heuristics in propositional satisfiability [6].", "startOffset": 161, "endOffset": 164}, {"referenceID": 4, "context": "Fichte and Szeider [5] have recently adapted backdoors to the field of ASP.", "startOffset": 19, "endOffset": 22}, {"referenceID": 4, "context": "Lemma 1 ([5]).", "startOffset": 9, "endOffset": 12}, {"referenceID": 8, "context": "Disallowing both causes yields socalled stratified programs [9].", "startOffset": 60, "endOffset": 63}, {"referenceID": 0, "context": "In order to define acyclicity we associate with each normal program P its directed dependency graph DP [1], and its undirected dependency graph UP [11].", "startOffset": 103, "endOffset": 106}, {"referenceID": 10, "context": "In order to define acyclicity we associate with each normal program P its directed dependency graph DP [1], and its undirected dependency graph UP [11].", "startOffset": 147, "endOffset": 151}, {"referenceID": 4, "context": "In recent research, Fichte and Szeider [5] have considered target classes that consist of normal programs without directed bad cycles (no-DBC), without undirected bad cycles (no-BC), without directed cycles (no-DC), and without undirected cycles (no-C).", "startOffset": 39, "endOffset": 42}, {"referenceID": 0, "context": "no-DBC is exactly the class that contains all stratified programs [1].", "startOffset": 66, "endOffset": 69}, {"referenceID": 14, "context": "The following connection was already observed by Aracena, Gajardo, and Montalva [15].", "startOffset": 80, "endOffset": 84}, {"referenceID": 14, "context": "Lemma 2 ([15]).", "startOffset": 9, "endOffset": 13}, {"referenceID": 22, "context": "Zhao [23] has shown that a program without a bad even cycle has either no answer-set or the well-founded model is its answer-set.", "startOffset": 5, "endOffset": 9}, {"referenceID": 6, "context": "is monotone for a normal program, there is a least fixed point and it can be computed in polynomial time [7, 8].", "startOffset": 105, "endOffset": 111}, {"referenceID": 7, "context": "is monotone for a normal program, there is a least fixed point and it can be computed in polynomial time [7, 8].", "startOffset": 105, "endOffset": 111}, {"referenceID": 11, "context": "It was shown by Lapaugh and Papadimitriou [12] that deciding whether G contains a simple path from s to t via m is NP-complete.", "startOffset": 42, "endOffset": 46}, {"referenceID": 18, "context": "Vazirani and Yannakakis [19] have shown that finding a cycle of even length in a directed graph is equivalent to finding a Pfaffian orientation of a graph.", "startOffset": 24, "endOffset": 28}, {"referenceID": 16, "context": "Since Robertson, Seymour, and Thomas [17] have shown that a Pfaffian orientation can be found in polynomial time.", "startOffset": 37, "endOffset": 41}, {"referenceID": 2, "context": "Note that there is strong theoretical evidence that the problem Hitting Set does not admit uniform polynomial-time tractability [3].", "startOffset": 128, "endOffset": 131}, {"referenceID": 4, "context": "The proof is very similar to the proof for target classes without respecting the parity by Fichte and Szeider [5].", "startOffset": 110, "endOffset": 113}, {"referenceID": 21, "context": "Since Yuster and Zwick [22] have shown that finding an even cycle in an undirected graph is polynomial-time solvable, the lemma holds.", "startOffset": 23, "endOffset": 27}, {"referenceID": 1, "context": "Since Arikati and Peled [2] have shown that finding an odd path in an undirected graph is polynomial-time solvable, the lemma follows.", "startOffset": 24, "endOffset": 27}, {"referenceID": 4, "context": "If k is considered as part of the input we can show that for each class C \u2208 {no-EC,no-BEC} the problem k-Strong C-Backdoor Detection is polynomial-time equivalent to Hitting Set [5].", "startOffset": 178, "endOffset": 181}, {"referenceID": 12, "context": "Lin and Zhao [13] have studied even cycles as a parameter to ASP.", "startOffset": 13, "endOffset": 17}, {"referenceID": 4, "context": "We have extended the backdoor approach of [5] by taking the parity of the number of negative edges on bad cycles into account.", "startOffset": 42, "endOffset": 45}, {"referenceID": 12, "context": "We have shown that the backdoor approach with parity target classes generalize a result of Lin and Zhao [13].", "startOffset": 104, "endOffset": 108}], "year": 2012, "abstractText": "Backdoors of answer-set programs are sets of atoms that represent \u201cclever reasoning shortcuts\u201d through the search space. Assignments to backdoor atoms reduce the given program to several programs that belong to a tractable target class. Previous research has considered target classes based on notions of acyclicity where various types of cycles (good and bad cycles) are excluded from graph representations of programs. We generalize the target classes by taking the parity of the number of negative edges on bad cycles into account and consider backdoors for such classes. We establish new hardness results and non-uniform polynomialtime tractability relative to directed or undirected cycles.", "creator": "LaTeX with hyperref package"}}}