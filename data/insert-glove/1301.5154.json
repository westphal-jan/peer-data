{"id": "1301.5154", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Jan-2013", "title": "A Rational and Efficient Algorithm for View Revision in Databases", "abstract": "gripper The 133.17 dynamics jahangir of belief and newey knowledge is 40-50 one of the miloje major components 46-47 of 5.09 any mccausland autonomous system jannaram that amino-terminal should monroig be icade able to incorporate new pieces self-selected of euro693 information. urfa In orlen this paper, pomona we argue that to apply rationality result sandomierz of clouded belief dynamics theory to gastel various practical problems, r&aw it should be generalized in benga two smadar respects: first lavendar of moskvin all, rodolphe it lowestoffe should alluding allow desktop a part-2-the certain 5-fluorouracil part of belief to 2,013 be declared as immutable; yono and wortley second, the belief lidell state need normanni not gilibert be deductively cosying closed. 96.09 Such a idee generalization of complexity belief dynamics, blasphemer referred to as c\u1ea9n base dynamics, lyonel is presented, threepence along with the ugine concept of miep a yale-new generalized waterboy revision leite algorithm for Horn atrophies knowledge 2061 bases. gimn\u00e0stic We anguillara show kyansittha that Horn s550 knowledge base 84-80 dynamics has interesting kopeck\u00fd connection espinoza with kernel change permiten and abduction. disagreements Finally, we 222.6 also merryl show expeditions that bakrie both variants are rational in baretto the sense kuol that l!ve they 59.77 satisfy algimouss certain confidante rationality omeprazole postulates b5000 stemming pardede from philosophical eskan works f3000 on four-turn belief vincenzi dynamics.", "histories": [["v1", "Tue, 22 Jan 2013 11:30:37 GMT  (24kb)", "http://arxiv.org/abs/1301.5154v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.DB", "authors": ["radhakrishnan delhibabu", "gerhard lakemeyer"], "accepted": false, "id": "1301.5154"}, "pdf": {"name": "1301.5154.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Radhakrishnan Delhibabu", "Gerhard Lakemeyer"], "emails": ["delhibabur@ssn.edu.in", "gerhard@kbsg.rwth-aachen.de", "delhibabu@kbsg.rwth-aachen.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 1.\n51 54\nv1 [\ncs .L\nO ]\n2 2\nKeyword: AGM, Belief Update, Horn Knowledge Base Dynamics, Kernel Change, Abduction, View update."}, {"heading": "1 Introduction", "text": "Modeling intelligent agents\u2019 reasoning requires designing knowledge bases for the purpose of performing symbolic reasoning. Among the different types of knowledge representations in the domain of artificial intelligence, logical representations stem from classical logic. However, this is not suitable for representing or treating items of information containing vagueness, incompleteness or uncertainty, or Horn knowledge base evolution that leads the agent to change his beliefs about the world.\nWhen a new item of information is added to a Horn knowledge base, inconsistency can result. Revision means modifying the Horn knowledge base in order\n\u22c6 This work extends from Chanderbose\u2019s [7]. \u22c6\u22c6 The author acknowledges the support of RWTH Aachen, where he is visiting scholar\nwith an Erasmus Mundus External Cooperation Window India4EU by the European Commission when the paper was written.\nto maintain consistency, while keeping the new information and removing (contraction) or not removing the least possible previous information. In our case, update means revision and contraction, that is insertion and deletion in database perspective. Our previous work [7,8] makes connections with contraction from knowledge base dynamics.\nOur Horn knowledge base dynamics, is defined in two parts: an immutable part (Horn formulae) and updatable part (literals) (for definition and properties see works of Nebel [41] and Segerberg [45]). Knowledge bases have a set of integrity constraints (see the definitions in later section). In the case of finite knowledge bases, it is sometimes hard to see how the update relations should be modified to accomplish certain Horn knowledge base updates.\nExample 1. Consider a database with an (immutable) rule that a staff member is a person who is currently working in the research group under the chair. Additional (updatable) facts are that matthias and gerhard are group chairs, and delhibabu and aravindan are staff members. We restricted that staff and chair names are taken by her/his email id, and our integrity constraint is that each research group has only one chair ie. \u2200x, y, z (y=x) \u2190 group chair(x,y) \u2227 group chair(x,z).\nImmutable part: staff chair(X,Y)\u2190 staff group(X,Z),group chair(Z,Y).\nUpdatable part: group chair(infor1,matthias)\u2190 group chair(infor2,gerhard)\u2190 staff group(delhibabu,infor1)\u2190 staff group(aravindan,infor2)\u2190\nSuppose we want to update this database with the information, staff chair(delhibabu,aravindan), that is\nstaff chair(delhibabu,aravindan)\u2190 staff group(delhibabu,Z) \u2227\ngroup chair(Z,aravindan)\nIf we are restricted to definite clauses, there is only one plausible way to do this: delhibabu and aravindan belong to groups infor1 and infor2, respectively, this updating means that we need to delete (remove) matthias from the database and newly add (insert) aravindan to the database (aravindan got promoted to the chair of the research group infor1 and he was removed from research group infor2). This results in an update that is too strong. If we allow disjunctive information into the database, however, we can accomplish the update by minimal adding wrt consistency\nstaff group(delhibabu,infor1) \u2228 group chair(infor1,aravindan)\nand this option appears intuitively to be correct. When adding new beliefs to the Horn knowledge base, if the new belief is violating integrity constraints then belief revision needs to be performed, otherwise, it is simply added. As we will see, in these cases abduction can be used in\norder to compute all the possibilities and it is not up to user or system to choose among them.\nWhen dealing with the revision of a Horn knowledge base (both insertions and deletions), there are other ways to change a Horn knowledge base and it has to be performed automatically also. Considering the information, change is precious and must be preserved as much as possible. The principle of minimal change [22,44] can provide a reasonable strategy. On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of AGM [1]; what result has to be chosen [27,32,39]; and finally, according to a practical point of view, what computational model to support for Horn knowledge base revision has to be provided?\nThe rest of paper is organized as follows: First we start with preliminaries in Section 2. In Section 3, we introduce knowledge base dynamics along with the concept of generalized revision, and revision operator for knowledge base. Section 4 studies the relationship between knowledge base dynamics and abduction. In Section 5, we discuss an important application of knowledge base dynamics in providing an axiomatic characterization for insertion view atoms to databases; and brief summary of the related works nature of view update problem for incomplete to complete information. In Section 6 we give brief overview of related works. In Section 7 we make conclusions with a summary of our contribution as well as a discussion of future directions of investigation. All proofs can be found in the Appendix."}, {"heading": "2 Preliminaries", "text": "We consider a propositional languageLP defined from a finite set of propositional variables P and the standard connectives. We use lower case Roman letters a, b, x, y, ... to range over elementary letters and the Greek letters \u03d5, \u03c6, \u03c8, ... for propositional formulae. Sets of formulae are denoted by upper case Roman letters A,B, F,K, ..... A literal is an atom (positive literal), or a negation of an atom (negative literal).\nFor any formula \u03d5, we write E(\u03d5) to mean the set of the elementary letters that occur in \u03d5. The same notation also applies to a set of formulae. For any set F of formulae, L(F ) represents the sub-language generated by E(F ), i.e. the set of all formulae \u03d5 with E(\u03d5) \u2286 E(F ).\nHorn formulae are defined [15] as follows:\n1. Every a \u2208 \u03a6, a and \u00aca are Horn clauses. 2. a\u2190 a1 \u2227a2 \u2227 ...\u2227an is a Horn clause, where n \u2265 0 and a, ai \u2208 \u03a6 (1 \u2264 i \u2264 n). 3. Every Horn clause is a Horn formula, a is called head and ai is body of the\nHorn formula. 4. If \u03d5 and \u03c8 are Horn formulae, so is \u03d5 \u2227 \u03c8.\nA definite Horn clause is a finite set of literals (atoms) that contains exactly one positive literal which is called the head of the clause. The set of negative\nliterals of this definite Horn clause is called the body of the clause. A Horn clause is non-recursive, if the head literal does not occur in its body. We usually denote a Horn clause as head\u2190body. Let LH be the set of all Horn formulae with respect to LP .\nFormally, a finite Horn knowledge baseKB is defined as a finite set of formula from language LH, and divided into three parts: an immutable theory KBI is an Horn formulae (head\u2190body), which is the fixed part of the knowledge; updatable theoryKBU is Horn clause (head\u2190); and an integrity constraintsKBIC is Horn clause (\u2190body).\nDefinition 1 (Knowledge Base). Let KB be a finite set of Horn formulae from language LH called a Horn knowledge base with, KB = KBI \u222a KBU \u222a KBIC, KB = KBI \u2229KBU = \u2205 and KB = KBU \u2229KBIC = \u2205.\nWorking with deductively closed, infinite belief sets is not very attractive from a computational point of view. The AGM approach to belief dynamics is very attractive in its capturing the rationality of change, but it is not always easy to implement either Horn formula based partial meet revision, or modeltheoretical revision. In real application from artificial intelligence and database, what is required is to represent the knowledge using a finite Horn knowledge base. Further, a certain part of the knowledge is treated as immutable and should not be changed.\nKnowledge base change deals with situations in which an agent has to modify its beliefs about the world, usually due to new or previously unknown incoming information, also represented as formulae of the language. Common operations of interest in Horn knowledge base change are the expansion of an agent\u2019s current Horn knowledge base KB by a given Horn clause \u03d5 (usually denoted as KB+\u03d5), where the basic idea is to add regardless of the consequences, and the revision of its current beliefs by \u03d5 (denoted as KB * \u03d5), where the intuition is to incorporate \u03d5 into the current beliefs in some way while ensuring consistency of the resulting theory at the same time. Perhaps the most basic operation in Horn knowledge base change, like belief change, is that of contraction (AGM [1]), which is intended to represent situations in which an agent has to give up \u03d5 from its current stock of beliefs (denoted as KB-\u03d5).\nDefinition 2 (Levi Identity). Let - be an AGM contraction operator for KB."}, {"heading": "A way to define a revision is by using Generalized Levi Identity:", "text": "KB \u2217 \u03b1 = (KB \u2212 \u00ac\u03b1) \u222a \u03b1\nThen, the revision can be trivially achieved by expansion, and the axiomatic characterization could be straightforwardly obtained from the corresponding characterizations of the traditional models [17]. The aim of our work is not to define revision from contraction, but rather to construct and axiomatically characterize revision operators in a direct way."}, {"heading": "3 Knowledge base dynamics", "text": "AGM [1] proposed a formal framework in which revision(contraction) is interpreted as belief change. Focusing on the logical structure of beliefs, they formulate eight postulates which a revision knowledge base (contraction knowledge base was discussed in [8]) has to verify.\nDefinition 3. Let KB be a Horn knowledge base with an immutable part KBI. Let \u03b1 and \u03b2 be any two Horn clauses from LH. Then, \u03b1 and \u03b2 are said to be KB-equivalent iff the following condition is satisfied: \u2200 set of Horn clauses E \u2286 LH: KBI \u222a E \u22a2 \u03b1 iff KBI \u222a E \u22a2 \u03b2.\nThese postulates stem from three main principles: the new item of information has to appear in the revised Horn knowledge base, the revised base has to be consistent and revision operation has to change the least possible beliefs. Now we consider the revision of a Horn clause \u03b1 wrt KB, written as KB \u2217 \u03b1. The rationality postulates for revising \u03b1 from KB can be formulated.\nDefinition 4 (Rationality postulates for Horn knowledge base revision).\n(KB*1) Closure: KB \u2217 \u03b1 is a Horn knowledge base. (KB*2) Weak Success: if \u03b1 is consistent with KBI \u222aKBIC then \u03b1 \u2286 KB \u2217 \u03b1. (KB*3.1) Inclusion: KB \u2217 \u03b1 \u2286 Cn(KB \u222a \u03b1). (KB*3.2) Immutable-inclusion: KBI \u2286 Cn(KB \u2217 \u03b1). (KB*4.1) Vacuity 1: if \u03b1 is inconsistent with KBI \u222aKBIC then KB \u2217\u03b1 = KB. (KB*4.2) Vacuity 2: if KB \u222a \u03b1 0\u22a5 then KB \u2217 \u03b1 = KB \u222a \u03b1. (KB*5) Consistency: if \u03b1 is consistent with KBI \u222aKBIC then KB \u2217 \u03b1 con-\nsistent with KBI \u222aKBIC . (KB*6) Preservation: If \u03b1 and \u03b2 are KB-equivalent, then KB \u2217 \u03b1\u2194 KB \u2217 \u03b2. (KB*7.1) Strong relevance: KB \u2217 \u03b1 \u22a2 \u03b1 If KBI 0 \u00ac\u03b1 (KB*7.2) Relevance: If \u03b2 \u2208 KB\\KB \u2217 \u03b1, then there is a set KB\u2032 such that\nKB \u2217 \u03b1 \u2286 KB\u2032 \u2286 KB \u222a \u03b1, KB\u2032 is consistent KBI \u222a KBIC with \u03b1, but KB\u2032 \u222a {\u03b2} is inconsistent KBI \u222aKBIC with \u03b1. (KB*7.3) Weak relevance: If \u03b2 \u2208 KB\\KB \u2217\u03b1, then there is a set KB\u2032 such that KB\u2032 \u2286 KB \u222a \u03b1, KB\u2032 is consistent KBI \u222aKBIC with \u03b1, but KB\u2032 \u222a {\u03b2} is inconsistent KBI \u222aKBIC with \u03b1.\nTo revise \u03b1 from KB, only those informations that are relevant to \u03b1 in some sense can be added (as example in the introduction illustrates). (KB \u2217 7.1) is very strong axiom allowing only minimum changes, and certain rational revision can not be carried out. So, relaxing this condition (example with more details can be found in [8]), this can be weakened to relevance. (KB \u2217 7.2) is relevance policy that still can not permit rational revisions, so we need to go next step. With (KB \u2217 7.3) the relevance axiom is further weakened and it is referred to as \u201dcore-retainment\u201d."}, {"heading": "3.1 Principle of minimal change", "text": "Let a Horn knowledge base KB be a set of Horn formulae and \u03c8 is a Horn clause such that KB = {\u03c6 | \u03c8 \u22a2 \u03c6} is derived by \u03c6. Now we consider the revision of a Horn clause \u03b1 wrt KB, that is KB \u2217 \u03b1.\nThe principle of minimal change (PMC) leads to the definition of orders between interpretations. Let I be the set of all the interpretations and Mod(\u03c8) be the set of models of \u03c8. A pre-order on I, denoted \u2264\u03c8 is linked with \u03c8. The relation <\u03c8 is defined from \u2264\u03c8 as usual:\nI <\u03c8 I \u2032 iff I \u2264\u03c8 I \u2032 and I \u2032 \u03c8 I.\nThe pre-order \u2264\u03c8 is faithful to \u03c8 if it verifies the following conditions:\n1) If I, I \u2032 \u2208Mod(\u03c8) then I <\u03c8 I \u2032 does not hold; 2) If I \u2208Mod(\u03c8) and I \u2032 <Mod(\u03c8) then I <\u03c8 I \u2032 holds; 3) if \u03c8 \u2261 \u03c6 then \u2264\u03c8=\u2264\u03c6.\nA minimal interpretation may thus be defined by: M \u2286 I, the set of minimal interpretations in M according to \u2264\u03c8 is denoted Min(M,\u2264\u03c8). And I is minimal in M according to \u2264\u03c8, if I \u2208 M and there is no I \u2032 \u2208 M such that I \u2032 <\u03c8 I.\nRevision operation * satisfies the postulates (KB*1) to (KB*6) and (KB*7.3) if and only if there exists a total pre-order \u2264\u03c8 such that:\nMod(\u03c8 \u2217 \u03c6) =Min(Mod(\u03c6),\u2264\u03c8)."}, {"heading": "4 Knowledge base dynamics and abduction", "text": "We study the relationship between Horn knowledge base dynamics (discussed in the previous section) and abduction, a well-known from reasoning. This study helps to bring these two fields together, so that abductive logic grammar procedure could be used to implement revision. For this purpose, we use the concepts of generalized kernel change (revision and contraction), an extension of kernel contraction and revision introduced for belief bases. We first observe that generalized kernel change coincides with that of Horn knowledge base change (revision and contraction), and then we process to show its relationship with abduction."}, {"heading": "4.1 Kernel revision system", "text": "To revise a Horn formula \u03b1 from a Horn knowledge base KB, the idea of kernel revision is to keep at least one element from every inclusion-minimal subset of KB that derives \u03b1. Because of the immutable-inclusion postulate, no Horn formula from KBI can be deleted.\nDefinition 5 (Kernel sets). Let a Horn knowledge base KB be a set of Horn formulae, where \u03b1 is Horn clause. The \u03b1-inconsistent kernel of KB, noted by KB\u22a5\u22a5\u03b1, is the set of KB\u2032 such that:\n1. KB\u2032 \u2286 KB ensuring that KBI \u2286 KB\u2032 and KBIC \u2286 KB\u2032. 2. KB\u2032 \u222a \u03b1 is inconsistent with KBI \u222aKBIC . 3. For any KB\u201d such that KB\u2032\u2032 \u2282 KB\u2032 \u2286 KB then KB\u2032\u2032\u222a\u03b1 is consistent with\nKBI \u222aKBIC.\nThat is, given a consistent \u03b1, KB\u22a5\u22a5\u03b1 is the set of minimal KB-subsets inconsistent with \u03b1.\nExample 2. Suppose that KB={KBI : p\u2190 a \u2227 b, p\u2190 a, q \u2190 a \u2227 b; KBU : a\u2190 , b\u2190; KBIC : \u00f8} and \u03b1= \u2190 p. Then we have that:\nKB\u22a5\u22a5\u03b1= {{p\u2190 a \u2227 b}, {p\u2190 a}}.\nRevision by a Horn clause is based on the concept of a \u03b1-inconsistent-kernels. In order to complete the construction, we must define a incision function that cuts in each inconsistent-kernel.\nDefinition 6 (Incision function). Let KB be a set of Horn formulae. \u03c3 is a incision function for KB if and only if, for all consistent Horn clauses \u03b1\n1. \u03c3(KB\u22a5\u22a5\u03b1) \u2286 \u22c3\nKB\u22a5\u22a5\u03b1 2. If KB\u2032 \u2208 KB\u22a5\u22a5\u03b1 then KB\u2032 \u2229 (\u03c3(KB\u22a5\u22a5\u03b1)) , 0\nDefinition 7 (Hitting set). A hitting set H for KB\u22a5\u22a5\u03b1 is defined as a set s.t. (i) H \u2286 \u22c3\n(KB\u22a5\u22a5\u03b1), (ii) H\u2229KBI is empty and (iii) \u2200X \u2208 KB\u22a5\u22a5\u03b1, X , \u2205 and X \u2229KBU is not empty, then X \u2229H , \u2205.\nA hitting set is said to be maximal when H consists of all updatable statements from \u22c3\n(KB\u22a5\u22a5\u03b1) and minimal if no proper subset of H is a hitting set for KB\u22a5\u22a5\u03b1.\nDefinition 8 (Generalized Kernel revision). An incision function for KB is a function s.t. for all \u03b1, \u03c3(KB\u22a5\u22a5\u03b1) is a hitting set for KB\u22a5\u22a5\u03b1. An operator \u2217\u03c3 for KB is a generalized kernel revision defined as follows:\nKB \u2217\u03c3 \u03b1 =\n{\n(KB\\\u03c3(KB\u22a5\u22a5\u03b1) \u222a \u03b1 if \u03b1 is consistent KBI \u222aKBIC KB otherwise.\nAn operator \u2217\u03c3 for KB is a generalized kernel revision iff there is an incision function \u03c3 for KB such that KB \u2217 \u03b1 = KB \u2217\u03c3 \u03b1 for all beliefs \u03b1.\nFrom the definition of hitting set, it is clear that when KB \u22a2 \u00ac\u03b1, \u03b1 is the hitting set ofKB\u22a5\u22a5\u03b1. On the other hand, whenKBI \u22a2 \u03b1, the definition ensures that only updatable elements are inserted, and \u03b1 does follow from the revision. Thus, week success (KB*2), immutable-inclusion(KB*3.2) and vacuity (KB*4.1) are satisfied by generalized kernel revision of \u03b1 from KB.\nExample 3. Given KB={KBI : p \u2190 a \u2227 b, p \u2190 a, q \u2190 a \u2227 b; KBU : a \u2190, b \u2190 ; KBIC : \u00f8 }, \u03b1= \u2190 p and KB\u22a5\u22a5\u03b1 = {{p \u2190 a \u2227 b}, {p \u2190 a}}. We have\ntwo possible results for the incision function and its associated kernel revision operator:\n\u03c31(KB\u22a5\u22a5\u03b1) = {p\u2190 a \u2227 b} and KB \u2217\u03c31 \u03b1 = {{\u2190 a}, {\u2190 b}}, \u03c32(KB\u22a5\u22a5\u03b1) = {p\u2190 a} and KB \u2217\u03c32 \u03b1 = {{\u2190 a}}.\nIncision function \u03c32 produces minimal hitting set for KB\u22a5\u22a5\u03b1.\nTheorem 1. For every Horn knowledge base KB, \u2217\u03c3 is a generalized kernel revision function iff it satisfies the postulates (KB*1) to (KB*6) and (KB*7.3)."}, {"heading": "4.2 Relationship with abduction", "text": "The relationship between Horn knowledge base dynamics and abduction was introduced by the philosopher Pierce (see [2]). We show how abduction grammar could be used to realize revision with immutability condition. A special subset of literal (atoms) of language LH, abducibles Ab, are designated for abductive reasoning. An abductive framework \u3008P,Ab\u3009 stands for a theory P, which is a set of Horn formulae from LH, with possible hypotheses Ab. An abductive framework for a knowledge base KB = KBI \u222aKBU \u222aKBIC can be given as follows:\nP = KBI \u222a {\u03b1\u2194 \u03b2|\u03b1 is a Horn clause in KBU and \u03b2 is an abducible\nfrom Ab that does not appear in KB}.\nDefinition 9 (Minimal abductive explanation). Let KB be a Horn knowledge base and \u03b1 an observation to be explained. Then, for a set of abducibles (KBU ), \u2206 is said to be an abductive explanation wrt KBI iff KBI \u222a\u2206 \u22a2 \u03b1. \u2206 is said to be minimal wrt KBI \u222aKBIC iff no proper subset of \u2206 is an abductive explanation for \u03b1, i.e. \u2204\u2206 \u2032 s.t. KBI \u222a\u2206 \u2032 \u22a2 \u03b1.\nSince an incision function is adding and removing only updatable elements from each member of the kernel set, to compute a generalized revision of \u03b1 from KB, we need to compute only the abduction in every \u03b1-kernel of KB. So, it is now necessary to characterize precisely the abducibles present in every \u03b1-kernel of KB. The notion of minimal abductive explanation is not enough to capture this, and we introduce locally minimal and KB-closed abductive explanations.\nDefinition 10 (Local minimal abductive explanations). Let (KBI\u222aKB\u2032U ) be a smallest subset of KBU , s.t \u2206 an minimal abductive explanation of \u03b1 wrt (KBI \u222aKB\u2032U ) (for some \u2206). Then \u2206 is called local minimal for \u03b1 wrt KBU .\nNote 1. Let (KBI \u222a KBU ) \u2208 ({\u2206+, \u2206\u2212}). Here \u2206+ refers to admission Horn knowledge base (positive atoms) and\u2206\u2212 refers to denial Horn knowledge base(negative atoms) wrt given \u03b1. Then problem of abduction is to explain \u2206 with abducibles (KBU ), s.t. (KBI \u222aKBU ) \u222a\u2206+ \u222a\u2206\u2212 \u22a2 \u03b1 and (KBI \u222aKBU ) \u222a\u2206+ |= \u03b1 \u222a\u2206\u2212 are both consistent with IC."}, {"heading": "4.3 Generalized revision algorithm", "text": "The problem of Horn knowledge base revision is concerned with determining how a request to change can be appropriately translated into one or more atoms or literals. We give new generalized revision algorithm. It is enough to compute all the KB-locally minimal abduction explanations for \u03b1 wrt KBI \u222aKBU \u222aKBIC . If \u03b1 is consistent with KB then well-known abductive procedure to compute an abductive explanation for \u03b1 wrt KBI could be used to compute kernel revision\nReasoning about Abduction and Deduction\nDefinition 11 ([51]). Let KB=(KBI ,KBU ,KBIC) be a knowledge base, T is updatable part from KB. We define abduction framework \u3008KBBG,KBAb, IC\u3009. After Algorithm 1 is executed, u is derived part from KB\u2032. The abduction explanation for u in \u3008KBI \u222aKB\u2217U ,KBIC\u3009 is any set Ti, where Ti \u2286 KB\nAb such that: KBI \u222aKB \u2217 U \u222a T |= u.\nAn explanation Ti is minimal if no proper subset of Ti is also an explanation, i.e. if it does not exist any explanation Tj for u such that Tj \u2282 Ti\nDefinition 12 ([51]). Let KB=(KBI ,KBU ,KBIC) be a knowledge base, T is updatable part from KB. After Algorithm 1 is executed, u is derived part from KB\u2032. The deduction consequence on u due to the application of T , KBI\u222aKB\u2217U \u222a T \u222a u is the answer to any question.\nAlgorithm 1 Generalized revision algorithm Input : A Horn knowledge base KB = KBI \u222aKBU \u222aKBIC\nand a Horn clause \u03b1 to be revised. Output: A new Horn knowledge base KB\u2032 = KBI \u222aKB\u2217U \u222aKBIC ,\ns.t. KB\u2032is a generalized revision \u03b1 to KB. Procedure KB(KB,\u03b1)\nbegin 1. Let V:= {c \u2208 KBIC | KBI \u222aKBIC inconsistent with \u03b1 wrt c}\nP := N := 0 and KB\u2032 = KB 2. While (V , 0)\nselect a subset V \u2032 \u2286 V For each v \u2208 V \u2032, select a literal to be\nremove (add to N) or a literal to be added(add to P) Let KB := KR(KB,P,N) Let V:= {c \u2208 KBIC | KBI inconsistent with \u03b1 wrt c} return\n3. Produce a new Horn knowledge base KB\u2032\nend.\nAlgorithm 2 Procedure KR(KB,\u2206+, \u2206\u2212)\nbegin 1. Let P := {e \u2208 \u2206+| KBI 6|= e} and N := {e \u2208 \u2206\u2212| KBI |= e} 2. While (P , 0) or (N , 0)\nselect a subset P \u2032 \u2286 P or N \u2032 \u2286 N Construct a set S1 = {X | X is a KB-closed locally\nminimal abductive wrt P explanation for \u03b1 wrt KBI}. Construct a set S2 = {X | X is a KB-closed locally\nminimal abductive wrt N explanation for \u03b1 wrt KBI}. 3. Determine a hitting set \u03c3(S1) and \u03c3(S2)\nIf ((N = 0) and (P , 0)) Produce KB\u2032 = KBI \u222a {(KBU \u222a \u03c3(S1)} else Produce KB\u2032 = KBI \u222a {(KBU\\\u03c3(S2) \u222a \u03c3(S1)} end if If ((N , 0) and (P = 0)) Produce KB\u2032 = KBI \u222a {(KBU\\\u03c3(S2)} else Produce KB\u2032 = KBI \u222a {(KBU\\\u03c3(S2) \u222a \u03c3(S1)} end if\n4. return KB\u2032\nend.\nTheorem 2. Let KB be a Horn knowledge base and \u03b1 is Horn formula.\n1. If Algorithm 1 produced KB\u2019as a result of revising \u03b1 from KB, then KB\u2019 satisfies all the rationality postulates (KB*1) to (KB*6) and (KB*7.3). 2. Suppose KB\u2032\u2032 satisfies all these rationality postulates for revising \u03b1 from KB, then KB\u2032\u2032 can be produced by Algorithm 1."}, {"heading": "5 Application: View updates in database", "text": "An important application of knowledge base dynamics, discussed in the previous section, is in providing an axiomatic characterization of view updates in deductive and relational databases. A definite deductive database DDB consists of two parts: an intensional database IDB (KBI), a set of definite program clauses; and an extensional database EDB (KBU ), a set of ground facts. The intuitive meaning of DDB is provided by the Least Herbrand model semantics and all the inferences are carried out through SLD-derivation. All the predicates that are defined in IDB are referred to as view predicatesand those defined in EDB are referred to as base predicates. Extending this notion, an atom(literals) with a view predicate is said to be a view atom(literals), and similarly an atom(literals) with base predicate is a base atom(literals). Further, we assume that IDB does\nnot contain any unit clauses and that predicates defined in a given DDB are both view and base predicates.\nTwo kinds of view updates can be carried out on a DDB: An atom(literals), that does not currently follow from DDB, can be inserted; or an atom(literals), that currently follows from DDB, can be deleted [7,8]. In this paper, we consider only insertion an atom(literals) from a DDB. When an atom(literals) A is to be inserted, the view update problem is to delete only some relevant EDB facts and then to insert, so that the modified EDB together with IDB will satisfy the insertion of A from DDB. As motivated in the introduction, our concern now is to discuss the rationality of view update, and provide an axiomatic characterization for it. This axiomatic characterization can be seen as a declarative semantics for view updates in deductive databases.\nNote that DDB can be considered [37,46] as a knowledge base to be revised. The IDB is the immutable part of the knowledge database, while the EDB forms the updatable part. Every base literal is an abducible, but since we deal only with definite databases, we require only positive abducibles. In general, it is assumed that a language underlying a DDB is fixed and the semantics of DDB is the least Herbrand model over this fixed language. Therefore, the DDB is practically a shorthand of its ground instantiation3, written as IDBG. Thus, a DDB represent a knowledge base where the immutable part is given by IDBG and updatable part is EDB. Hence, the rationality postulates (KB*1) to (KB*6) and (KB*7.3) provide an axiomatic characterization for inserting a view atom(literals) A to a definite database DDB, and a generalized insertion of A to DDB achieves deletion of A from DDB.\nAs observed by Kowalski [26], logic can provide a conceptual level of understanding of relational databases, and hence rationality postulates (KB*1) to (KB*6) and (KB*7.3)can provide an axiomatic characterization for view insertion in relational databases too. A relational database together with its view definitions can be represented by a definite deductive database (EDB representing tuples in the database and IDB representing the view definitions), and so same algorithm can be used to insert view extensions from relational and deductive databases.\nBut before discussing the rationality postulates and algorithm, we want to make it precise, how a relational database, along with operations on relations, can be represented by definite deductive database. We assume the reader is familiar with relational database concepts. A relation scheme R can be thought of as a base predicate whose arguments define the attributes A of the scheme. Its relational extension r, is a finite set of base atoms R(A) containing the predicate R. A database schema consists of finite collection of relational schemes < R1, . . . , Rn >, and a relational database is a specific extension of database schema, denoted as < r1, . . . , rn >. In our context, relational database can be represented by EDB = \u22c3\ni=1,...,nRi(Ai).\n3 a ground instantiation of a definite program P is the set of clauses obtained by substituting terms in the Herbrand Universe for variables in P in all possible ways\nJoin is a binary operator for combining two relations. Let r and s be two relational extensions of schema R (with attributes R) and S (with attributes S), respectively. Let T = R \u222a S. The join of r and s, written as r \u2297 s, is the relational extension q(T) of all tuples t over T such that there are tr \u2208 r and ts \u2208 s, with tr = t(R) and ts = t(S). Join can be captured by a constraint clause Q(T) \u2190 R(R), S(S). Our integrity constraint (IC) is that each research group has only one chair i.e. \u2200x, y, z (y=x) \u2190 group chair(x,y) \u2227 group chair(x,z) (see definition and properties of similarity in works of Christiansen [11] and Godfrey [19]).\nExample 4. Let us consider two relational schemes R and S from Example 1, with attributes R = {Group,Chair} and S = {Staff,Group}.Consider the following extensions r and s:\ns Staff Group delhibabu infor1 aravindan infor2\nr Group Chair infor1 matthias infor2 gerhard\nTab. 1. Base table for s and r\nThe following rule, T (Staff,Group, Chair) \u2190 S(Staff,Group), R(Group,Chair)\nrepresents the join of s and r, which is given as:\ns\u2297 r Staff Group Chair delhibabu infor1 matthias aravindan infor2 gerhard\nTab. 2. s\u2297 r\nTo sum up, we showed how relational database and operators on relations can be conceptually captured by definite deductive databases. All solutions translate [38] a view update request into a transaction combining insertions and deletions of base relations for satisfying the request. Further, a definite deductive database can be considered as a knowledge base, and thus rationality postulates and insertion algorithm of the previous section can be applied for view updates in database."}, {"heading": "5.1 View insertion algorithm", "text": "Since relational and definite deductive databases can be considered as knowledge bases, and inserting a view atom(literals) (tuple) A can be considered as revision of A, a specific instance of Algorithm 1 can be used to compute insertion of a view atom(literals) to a database. In fact, we have to discuss how to compute all DDB-closed locally minimal abductive explanations for A wrt IDBG. As expected, these abductive explanations can be computed using deduction trees, and the process is discussed in the sequel.\nAlgorithm 3 Algorithm to compute all DDB-closed locally minimal abductive explanation of an atom(literals)\nInput : A definite deductive database DDB = IDB \u222a EDB \u222a IC an literals A\nOutput : Set of all DDB-closed locally minimal abductive explanations for A wrt IDBG\nbegin 1. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c }\nWhile (V , 0) Construct a complete SLD-tree for \u2190 A wrt DDB.\nFor every successful branch i: construct \u2206i = {D | D \u2208 EDB and D is used as an input clause in branch i} For every unsuccessful branch j: construct \u2206j = {D | D \u2208 EDB and D is used as an input clause in branch j}\nProduce set of all \u2206i and \u2206j computed in the previous step as the result. return\n2. Produce all DDB-closed locally minimal abductive explanations in \u2206i and \u2206j\nend.\nAlgorithm 4 Algorithm to compute all DDB-closed locally minimal abductive explanation of an atom(literals)\nInput : A definite deductive database DDB = IDB \u222a EDB \u222a IC an literals A\nOutput : Set of all DDB-closed locally minimal abductive explanations for A wrt IDBG\nbegin 1. Construct a complete SLD-tree for \u2190 A wrt DDB.\nFor every successful branch i: construct \u2206i = {D | D \u2208 EDB and D is used as an input clause in branch i} For every unsuccessful branch j: construct \u2206j = {D | D \u2208 EDB and D is used as an input clause in branch j}\n2. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c } While (V , 0)\nProduce set of all \u2206i and \u2206j is consistent with IC as the result. return Produce all DDB-closed locally minimal abductive explanations in \u2206i and \u2206j\nend.\nAn update request U = B, where B is a set of base facts, is not true in KB. Then, we need to find a transaction T = Tins \u222a Tdel, where Tins(\u2206i) (resp.\nTdel(\u2206j)) is the set of facts, such that U is true in DDB \u2032 = ((EDB \u2212 Tdel \u222a Tins)\u222aIDB\u222aIC). Since we consider definite deductive databases, SLD-tree can be used to compute the required abductive explanations. The idea is to get all EDB facts used in a SLD-derivation of A wrt DDB, and construct that as an abductive explanation for A wrt IDBG.\nThere are two ways to find minimal elements (insertion and deletion) with integrity constraints. Algorithm 3 first checks consistency with integrity constraints and then reduces steps with abductive explanation for A . Algorithm 4 is doing vice versa, but both algorithm outputs are similar.\nUnfortunately, this algorithm does not work as intended for any deductive database, and a counter example is produced below. Thus, general algorithms 3 and 4 produced some unexpected sets in addition to locally minimal abductive explanations.\nExample 5. Consider a deductive database DDB as follows:\nIDB : p\u2190 a \u2227 e EDB : a\u2190 IC : \u2190 b q \u2190 a \u2227 f e\u2190 p\u2190 b \u2227 f f \u2190 q \u2190 b \u2227 e p\u2190 q q \u2190 a\nWe need to insert p. First, we check consistency with IC and after we find \u2206i and \u2206j via tree deduction.\n\u2190 p\n\u2190 a, e\n\u2190 q\n\u2190 a, f \u2190 a \u2190 b, e\n\u2190 b, f\nFrom Algorithm 3 it is easy to conclude which branches are consistent wrt IC (shown on tree by ). For the next step, we need to find minimal accommodate and denial literal with wrt to p. The subgoals of the tree are \u2190 a, e and \u2190 a, f , which are minimal tree deductions of only facts. Clearly, \u2206i = {a, e, f} and \u2206j = {b} with respect to IC, are the only locally minimal abductive explanations for p wrt IDBG, but they are not locally minimal explanations.\nFrom Algorithm 4, the subgoals of the tree are \u2190 a, e, \u2190 a, f , \u2190 b, f and \u2190 b, e. Clearly, \u2206i = {a, b, e, f} and \u2206j = {a, e, f}. In the next step, we check consistency with IC. \u2206i and \u2206j are only locally minimal abductive explanations for p wrt IDBG, but they are not locally minimal explanations (more explanations can be found in [33]).\nThe program is clear due to the unwanted recursion p \u2190 a \u2227 b, p \u2190 a. Will the algorithm work as intended if we restrict ourselves to acyclic program [8]\nthat excludes such loop? One would expect a positive answer, but unfortunately still some unwanted sets may be produced as the following example highlights.\nSo, even for acyclic program, algorithms 3 and 4 do not work as intended (that is to generate all and only the DDB-close locally minimal abductive explanations). Does this mean that generalized revision can not be carried out for database in general?. Probably we should approach the problem from different perspective. We have seen that algorithms 3 and 4 may compute some unwanted sets in addition to the required ones. What exactly are those sets? Is it possible to characterize them? The following lemma answers these questions.\nLemma 1. Let DDB = IDB\u222aEDB\u222aIC be a definite deductive database and A an atom(literals). Let S be the set of all DDB-closed locally minimal abductive explanations for A wrt IDBG. Let S\n\u2032 be the set of explanations returned by algorithms 3 and 4 given DDB and A as inputs. Then, the following propositions hold:\n1. S \u2286 S\u2032.\n2. \u2200\u2206\u2032(\u2206\u2032 \u2208 \u2206i \u222a\u2206j) \u2208 S\u2032: \u2203\u2206 \u2208 S s.t. \u2206 \u2282 \u2206\u2032.\n3. Suppose DDB is resticted to be acyclic then: \u2200\u2206\u2032 \u2208 S\u2032: \u2206\u2032 \u2282 \u22c3 S.\nHaving characterized what exactly is computed by algorithms 3 and 4, we now proceed to show that algorithms 5 and 6 are useful for view insertion. The key to the solution is the following lemma, which established the preservable of hitting set computation among two sets.\nLemma 2. 1. Let S be a set of sets, and S\u2032 another set s.t. S \u2286 S\u2032 and every member of S\u2032\\S contains an element of S. Then, a set H is minimal hitting set for S iff it is a minimal hitting set for S\u2032.\n2. Let S be a set of sets, and S\u2032 another set s.t. S \u2286 S\u2032 and for every member X of S\u2032\\S: X contains a member of S and X is contained in \u22c3\nS. Then, a set H is a hitting set for S iff it is a hitting set for S\u2032.\nThus algorithms 3 and 4 in conjunction with an algorithm to compute minimal hitting set can be used to compute partial meet revision (defined in section 4.1) of A from DDB.\nAlgorithm 5 Partial meet revision for definite deductive database Input : A definite deductive database DDB = IDB \u222a EDB \u222a IC an literals A Output: A Partial meet revision of A from DDB. begin\n1. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c } While (V , 0) 2. Construct a complete SLD-tree for \u2190 A wrt DDB. 3. For every successful branch i:construct \u2206i = {D | D \u2208 EDB}\nand D is used as an input clause in branch i. Let there be m such sets.\nLet E\u2217 = {{D1, . . . , Dm}|Di \u2208 \u2206i} Let E be a inclusion-minimal set among E\u2217, i.e. \u2204E\u2032 \u2208 E\u2217\ns.t. E\u2032 \u2282 E. 4. For every unsuccessful branch j:construct \u2206j = {D | D \u2208 EDB}\nand D is used as an input clause in branch j. Let there be m such sets.\nLet F \u2217 = {{D1, . . . , Dm}|Dj \u2208 \u2206j} Let F be a inclusion-maximum set among F\u2217, i.e. \u2204F \u2032 \u2208 F \u2217\ns.t. F \u2032 \u2286 F. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c }\nreturn 5. Produce DDB\\F \u222a E as the result.\nend.\nAlgorithm 6 Generalized revision for acyclic definite deductive database\nInput : An acyclic definite deductive database DDB = IDB \u222a EDB \u222a IC an literals A\nOutput: A generalized revision of A from DDB. begin\n1. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c } While (V , 0) 2. Construct a complete SLD-tree for \u2190 A wrt DDB. 3. For every successful branch i:construct \u2206i = {D | D \u2208 EDB}\nand D is used as an input clause in branch i. Construct a hitting set D for all \u2206i\u2019s computed in the previous step.\n4. For every unsuccessful branch j:construct \u2206j = {D | D \u2208 EDB} and D is used as an input clause in branch j.\nConstruct a hitting set D for all \u2206j \u2019s computed in the previous step. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c }\nreturn 5. Produce DDB\\F \u222aE as the result.\nend.\nWhen DDB is acyclic, generalized revision of A from DDB can be obtained by Algorithm 6. Observe that the first two steps of Algorithm 5 are same as those of algorithms 3 and 4, and we have already established what exactly are computed by them. Steps 3 and 4 clearly compute a minimal hitting set and as established by lemma 1 and lemma 2, this algorithm produces a partial meet contraction of A from DDB. This result is formalized below.\nTheorem 3. Let DDB be a definite deductive database and A an atom(literals) to be inserted. Then DDB\u2019 is a result of algorithm 5 given DDB and A as inputs, iff DDB\u2019 is a partial meet revision of A from DDB, satisfying the postulates (KB*1) to (KB*6) and (KB*7.1).\nWe proceed to present Algorithm 6 to compute generalized revision for definite deductive database. As observed before, this is not possible in general, but for a restricted case of acyclic program.\nTheorem 4. Let DDB be a definite deductive database and A an atom(literals) to be inserted. Then DDB\u2019 is a result of algorithm 6 given DDB and A as inputs, iff DDB\u2019 is a generalized revision of A from DDB, satisfying the postulates (KB*1) to (KB*6) and (KB*7.3).\nAlgorithms 5 and 6 are inefficient, as they need to build a complete SLD-tree. Unfortunately, any rational algorithm for insertion can not avoid constructing complete SLD-trees. If these algorithms are changed to extract input clauses from incomplete SLD-derivation, then the new algorithm should check the derivability of an atom(literals) from a deductive database, before any insertion is carried out(otherwise, success can not be satisfied). Checking derivability is also computationally expensive and more then that, weak relevance policy (KB*7.3) will not be satisfied in general. Finally, any rational algorithm must construct a complete SLD-tree."}, {"heading": "5.2 Incomplete to Complete Information", "text": "Many of the proposals in the literature on incomplete databases have focussed on the extension of the relational model by the introduction of null values. In this section, we show how view update provides completion of incomplete information. More detailed surveys of this area can be found in [36].\nThe earliest extension of the relational model to incomplete information was that of Codd [13] who suggested that missing values should be represented in tables by placing a special null value symbol \u2032\u2217\u2032 at any table location for which the value is unknown. Table 3, shows an example of a database using this convention. Codd proposed an extension to the relational algebra for tables containing such nulls, based on three valued logic and a null substitution principle.\nIn terms of our general semantic scheme, the intended semantics of a database D consisting of Codd tables can be described by defining Mod(D) to be the set of structures MD\u2032 , where D \u2032 ranges over the relational databases obtained\nby replacing each occurrence of \u2032\u2217\u2032 in the database D by some domain value. Different values may be substituted for different occurrences.\nA plausible integrity constraint on the meaning of a relational operator on tables in T is that the result should be a table that represents the set of relations obtained by pointwise application of the operator on the models of these tables. For example, if R and S are tables in T then the result of the join R Z S should be equal to a table T in T such that\nMod(T ) = {r Z t | r \u2208Mod(R), s \u2208Mod(S)}\nIn case the definitions of the operators satisfy this integrity constraint (with respect to the definition of the semantics Mod on T ).\nLet us consider what above equation requires if we take R and S to be the Codd Tables 3. First of all, note that in each model, if we take the value of the null in the tuple (delhibabu,*) to be v, then the join will contain one tuples (delhibabu, v), which include the value v. If T is to be a Codd table, it will need to contain tuples (delhibabu,X) to generate each of these tuples, where X are either constants or \u2019*\u2019. We now face a problem. First, X cannot be a constant c, for whatever the choice of c we can find an instance r \u2208Mod(R) and s \u2208Mod(S) for which the tuple (delhibabu, c) does not occur in r Z s. If they were, X would have their values in models of T assigned independently.\nHere the repetition of \u2217 indicates that the same value is to be occurrence of the null in constructing a model of the table. Unfortunately, this extension does not suffice to satisfy the integrity constraint (\u2200x, y, z (y=x) \u2190 group chair(x,y) \u2227 group chair(x,z)).\nStaff Group delhibabu infor1 delhibabu *\nGroup Chair infor1 mattias\n* aravindan\nTab. 3. Base Table after Transaction\nIn the model of these tables in which \u2217 = infor1, the join contains the tuple (delhibabu, infor1) and (infor1, aravindan).\nIf \u22171 = infor1 then (delhibabu, infor1) \u2208 R Z S\nIf \u22172 = infor1 then (infor1, aravindan) \u2208 R Z S\nThe following table shows when transaction is made to base table:\nStaff Group Chair delhibabu infor1 mattias delhibabu * aravindan\nTab. 4. s\u2297 r after Transaction\nThe following table shows completion of incomplete information with application of integrity constraint and redundancy:\nStaff Group Chair delhibabu infor1 aravindan\nTab. 5. Redundant Table"}, {"heading": "6 Related Works", "text": "We begin by recalling previous work on view deletion. Chandrabose [7,8], defines a contraction operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [21] belief change. Similar to our approach, he focused on set of formulae or sentences in knowledge base revision for view update wrt. insertion and deletion and formulae are considered at the same level. Chandrabose proposed different ways to change knowledge base via only database deletion, devising particular postulate which is shown to be necessary and sufficient for such an update process.\nOur Horn knowledge base consists of two parts, immutable part and updatable part , but focus is on principle of minimal change. There are more related works on that topic. Eiter [16], Langlois[28], and Delgrande [15] are focusing on Horn revision with different perspectives like prime implication, logical closure and belief level. Segerberg [45] defined new modeling for belief revision in terms of irrevocability on prioritized revision. Hansson [21], constructed five types of non-prioritized belief revision. Makinson [34] developed dialogue form of revision AGM. Papini[42] defined a new version of knowledge base revision. Here, we consider immutable part as a Horn clause and updatable part as an atom(literals).\nWe are bridging gap between philosophical work, paying little attention to computational aspects of database work. In such a case, Hansson\u2019s[21] kernel change is related with abductive method. Aliseda\u2019s [2] book on abductive reasoning is one of the motivation keys. Christiansen\u2019s [12] work on dynamics of abductive logic grammars exactly fits our minimal change (insertion and deletion). Wrobel\u2019s [48] definition of first order theory revision was helpful to frame our algorithm.\nOn other hand, we are dealing with view update problem. Keller\u2019s [23] thesis is motivation for view update problem. There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[10] and survey paper on view algorithm by Mayol and Teniente [35]. More similar to our work is paper presented by Bessant et al. [4] , local search-based heuristic technique that empirically proves to be often viable, even in the context of very large propositional applications. Laurent et al.[29], parented updating deductive databases in which every insertion or deletion of a fact can be performed in a deterministic way.\nFurthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [43], and\nKogalovsky [24]). Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [30,31], Caroprese [6], Calvanese\u2019s [9], and Cong [14]).\nThe significance of our work can be summarized in the following:\n- We have defined new kind of revision operator on knowledge base and obtained axiomatic characterization for it. This operator of change is based on \u03b1 consistent-remainder set. Thus, we have presented a way to construct revision operator without need to make use of the generalized Levi\u2019s identity nor of a previously defined contraction operator. - We have defined new way of insertion and deletion of an atom(literals) as per norm of principle of minimal change. - We have proposed new generalized revision algorithm for knowledge base dynamics, interesting connections with kernel change and abduction procedure. - We have written new view insertion algorithm for DDB, and we provided Horn knowledge base revision, using our axiomatic method. - Finally, we shown connection between belief update versus database update."}, {"heading": "7 Conclusion and remarks", "text": "The main contribution of this research is to provide a link between theory of belief dynamics and concrete applications such as view updates in databases. We argued for generalization of belief dynamics theory in two respects: to handle certain part of knowledge as immutable; and dropping the requirement that belief state be deductively closed. The intended generalization was achieved by introducing the concept of knowledge base dynamics and generalized contraction for the same. Further, we also studied the relationship between knowledge base dynamics and abduction resulting in a generalized algorithm for revision based on abductive procedures. We also successfully demonstrated how knowledge base dynamics can provide an axiomatic characterization for insertion an atom(literals) to a definite deductive database. Finally, we give a quick overview of the main operators for belief change, in particular, belief update versus database update.\nIn bridging the gap between belief dynamics and view updates, we have observed that a balance has to be achieved between computational efficiency and rationality. While rationally attractive notions of generalized revision prove to be computationally inefficient, the rationality behind efficient algorithms based on incomplete trees is not clear at all. From the belief dynamics point of view, we may have to sacrifice some postulates, vacuity for example, to gain computational efficiency. Further weakening of relevance has to be explored, to provide declarative semantics for algorithms based on incomplete trees.\nOn the other hand, from the database side, we should explore various ways of optimizing the algorithms that would comply with the proposed declarative semantics. We believe that partial deduction and loop detection techniques, will play an important role in optimizing algorithms of the previous section. Note\nthat, loop detection could be carried out during partial deduction, and complete SLD-trees can be effectively constructed wrt a partial deduction (with loop check) of a database, rather than wrt database itself. Moreover, we would anyway need a partial deduction for optimization of query evaluation.\nThough we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [6] and [5]). It would also be interesting to study how results using soft stratification [3] with belief dynamics, especially the relational approach, could be applied in real world problems. Still, a lot of developments are possible, for improving existing operators or for defining new classes of change operators. As immediate extension, question raises: is there any real life application for AGM in 25 year theory? [18]. The revision and update are more challenging in logical view update problem(database theory), so we can extend the theory to combine results similar to Hansson\u2019s [20], Konieczny\u2019s [25]and Nayak, [40].\nAppendix\nProof of Theorem 1. (If part) * satisfies (KB*1) to (KB*6) and (KB*7.3). We must show that \u2217 is a generalized kernel revision. Let \u03c3 be a incision function such that for \u03b1. When KBI \u22a2 \u03b1, (KB*1) to (KB*6) and (KB*7.3) imply that KB \u2217 \u03b1 = KB coincides with generalized revision and follow PMC.\nWhen KBI \u22a2 \u00ac\u03b1, the required result follows from the two observations:\n1. \u2203KB\u2032 \u2208 KB\u22a5\u22a5\u03b1 s.t.KB \u2217 \u03b1 \u2286 KB\u2032 (when KBI \u22a2 \u03b1) Let \u03c3 be an incision function for KB and \u2217\u03c3 be the generalized revision on KB that is generated by \u03c3. Since * satisfies closure (KB*1), KB \u2217\u03c3 \u03b1 is KB contained in \u03b1. Also, satisfaction of weak success postulate (KB*2) ensures that \u03b1 \u2286 KB \u2217\u03c3 \u03b1. Every element of KB\u22a5\u22a5\u03b1 is a inclusion minimal subset that does derive \u03b1, and so any subset of KB that does derive \u03b1 must be contained in a member of KB\u22a5\u22a5\u03b1. 2. \u22c2\n(KB\u22a5\u22a5\u03b1) \u2286 KB \u2217\u03c3 \u03b1 (when KBI \u22a2 \u03b1) Consider any \u03b2 \u2208 \u22c2\n(KB\u22a5\u22a5\u03b1). Assume that \u03b2 < KB \u2217 \u03b1. Since * satisfies weak relevance postulate (KB*7.3), it follows that there exists a set KB\u2019 s.t. KB\u2032 \u2286 KB \u222a \u03b1; KB\u2032 is a consistent with \u03b1; and KB\u2032 \u222a {\u03b2} is inconsistent with \u03b1. But this contradicts that \u03b2 is present in every minimal subset of KB that does derive \u03b1. Hence \u03b2 must not be in KB \u2217\u03c3 \u03b1.\n(Only if part) Let KB \u2217 \u03b1 be a generalized revision of \u03b1 for KB. We have to show that KB \u2217 \u03b1 satisfies the postulate (KB*1) to (KB*6) and (KB*7.3).\nLet \u03c3 be an incision function for KB and \u2217\u03c3 be the generalized revision on KB that is generated by \u03c3.\nClosure Since KB \u2217\u03c3 \u03b1 is a Horn knowledge base, this postulate is trivially shown. Weak Success Suppose that \u03b1 is consistent. Then it is trivial by definition that \u03b1 \u2286 KB \u2217\u03c3 \u03b1.\nInclusion Trivial by definition.\nImmutable-inclusion Since every X \u2208 KB\u22a5\u22a5\u03b1 is such that X \u2286 KBI then this postulate is trivially shown.\nVacuity 1 Trivial by definition. Vacuity 2 If KB \u222a{\u03b1} is consistent then KB\u22a5\u22a5\u03b1 = {{KB}}. Hence KB \u2217\u03c3 \u03b1 = KB \u222a {\u03b1}. Consistency Suppose that \u03b1 is consistent. Then KB\u22a5\u22a5\u03b1 ,= \u2205 and by definition, every X \u2208 KB\u22a5\u22a5\u03b1 is consistent with \u03b1. Therefore, the intersection of any subset of KB\u22a5\u22a5\u03b1 is consistent with \u03b1. Finally, KB \u2217\u03c3 \u03b1 is consistent. Uniformity If \u03b1 and \u03b2 are KB-equivalent, then KB\u22a5\u22a5\u03b1 = KB\u22a5\u22a5\u03b2 Weak relevance Let \u03b2 \u2208 KB and \u03b2 < KB \u2217\u03c3 \u03b1. Then KB \u2217\u03c3 \u03b1 , KB and,\nfrom the definition of \u2217\u03c3,it follows that:\nKB \u2217\u03c3 \u03b1=(KB\\\u03c3(KB\u22a5\u22a5\u03b1)) \u222a \u03b1\nTherefore, from \u03b2 < (KB\\\u03c3(KB\u22a5\u22a5\u03b1)) \u222a \u03b1 and \u03b2 \u2208 KB, we can conclude that \u03b2 \u2208 \u03c3(KB\u22a5\u22a5\u03b1). By definition \u03c3(KB\u22a5\u22a5\u03b1) \u2286 \u22c3\nKB\u22a5\u22a5\u03b1, and it follows that there is some X \u2208 KB\u22a5\u22a5\u03b1 such that \u03b2 \u2208 X . X is a minimal KB-subset inconsistent with \u03b1. Let Y = X\\{\u03b2}. Then Y is such that Y \u2282 X \u2286 KB \u2286 KB \u222a \u03b1. Y is consistent with \u03b1 but Y \u222a {\u03b2} is consistent with \u03b1.\nProof of Theorem 2. Follows from Theorem 1 and Definition 10.\nProof of Lemma 1.\n1. Consider a \u2206(\u2206 \u2208 \u2206i \u222a\u2206j) \u2208 S. We need to show that \u2206 is generated by algorithm 3 at step 2. From lemma 1, it is clear that there exists a A-kernel X of DDBG s.t. X \u2229 EDB = \u2206j and X \u222a EDB = \u2206i. Since X \u22a2 A, there must exist a successful derivation for A using only the elements ofX as input clauses and similarly X 0 A. Consequently \u2206 must have been constructed at step 2. 2. Consider a \u2206\u2032((\u2206\u2032 \u2208 \u2206i \u222a\u2206j) \u2208 S\u2032. Let \u2206\u2032 be constructed from a successful(unsuccessful) branch i via \u2206i(\u2206j). Let X be the set of all input clauses used in the refutation i. Clearly X \u22a2 A(X 0 A). Further, there exists a minimal (wrt set-inclusion) subset Y of X that derives A (i.e. no proper subset of Y derives A). Let \u2206 = Y \u2229EDB (Y \u222aEDB). Since IDB does not(does) have any unit clauses, Y must contain some EDB facts, and so \u2206 is not empty (empty) and obviously \u2206 \u2286 \u2206\u2032. But, Y need not (need) be a A-kernel for IDBG since Y is not ground in general. But it stands for several A-kernels with the same (different) EDB facts \u2206 in them. Thus, from lemma 1, \u2206 is a DDB-closed locally minimal abductive explanation for A wrt IDBG and is contained in \u2206\u2032.\n3. Since this proof requires some details of acyclic programs that are not directly related to our discussion here, it is relegated [9].\nProof of Lemma 2.\n1. (Only if part) Suppose H is a minimal hitting set for S. Since S \u2286 S\u2032 , it follows that H \u2286 \u22c3\nS\u2032 . Further, H hits every element of S\u2032 , which is evident from the fact that every element of S\u2032 contains an element of S. Hence H is a hitting set for S\u2032 . By the same arguments, it is not difficult to see that H is minimal for S\u2032 too.\n(If part) Given that H is a minimal hitting set for S\u2032 , we have to show that it is a minimal hitting set for S too. Assume that there is an element E \u2208 H that is not in \u22c3\nS. This means that E is selected from some Y \u2208 S\u2032\\S. But Y contains an element of S, say X . Since X is also a member of S\u2032 , one member of X must appear in H . This implies that two elements have been selected from Y and hence H is not minimal. This is a contradiction and hence H \u2286 \u22c3\nS. Since S \u2286 S\u2032 , it is clear that H hits every element in S, and so H is a hitting set for S. It remains to be shown that H is minimal. Assume the contrary, that a proper subset H \u2032 of H is a hitting set for S. Then from the proof of the only if part, it follows that H \u2032 is a hitting set for S\u2032 too, and contradicts the fact that H is a minimal hitting set for S\u2032 . Hence, H must be a minimal hitting set for S.\n2. (If part) Given that H is a hitting set for S\u2032 , we have to show that it is a hitting set for S too. First of all, observe that \u22c3 S = \u22c3\nS\u2032 , and so H \u2286 \u22c3\nS. Moreover, by definition, for every non-empty member X of S\u2032 , H\u2229X is not empty. Since S \u2286 S\u2032 , it follows that H is a hitting set for S too.\n(Only if part) Suppose H is a hitting set for S. As observed above, H \u2286 \u22c3\nS\u2032 . By definition, for every non-empty member X \u2208 S, X \u2229 H is not empty. Since every member of S\u2032 contains a member of S, it is clear that H hits every member of S\u2032 , and hence a hitting set for S\u2032 .\nProof of Theorem 3. From Lemma 1, it is clear that step 1 and 2 generate all DDB-closed locally minimum abductive explanation for A wrt IDBG and some additional sets that contain a DDB-closed local minimal abductive explanation for A wrt IDBG. Step 3 and 4 clearly computes an inclusion-minimal hitting set for this. This required now following Lemma 2 and Theorem 2.\nProof of Theorem 4. Follows from Lemma 1, Lemma 2, and Theorem 2."}, {"heading": "5. Biskup, J. (2012). Inference-usability confinement by maintaining inference-proof", "text": "views of an information system. IJCSE. 7 (1), 17-37. 6. Caroprese, L., et al.(2012). The View-Update Problem for Indefinite Databases. JELIA. 7. Chandrabose, A.,& Dung, P.M.(1994). Belief Dynamics, Abduction, and Database. JELIA, 66-85. 8. Chandrabose A.(1995), Dynamics of Belief: Epistmology, Abduction and Database Update. Phd Thesis, AIT. 9. Calvanese, D., et al. (2012). View-based query answering in Description Logics Semantics and complexity. J. Comput. Syst. Sci 78(1), 26-46. 10. Chen, H., & Liao, H. (2010). A Comparative Study of View Update Problem. DSDE, 83-89. 11. Christiansen, H., & Martinenghi, D. (2006) On Simplification of Database Integrity Constraints. Fundam. Inform. 71 (4), 371-417. 12. Christiansen, H., & Dahl,V. (2009). Abductive Logic Grammars. WoLLIC, 170- 181. 13. Codd, E.F. (1979). Extending the Database Relational Model to Capture More Meaning. ACM Trans. Database Syst. 4(4), 397-434. 14. Cong, G., et al. (2012). On the Complexity of View Update Analysis and Its Application to Annotation Propagation. IEEE Trans. Knowl. Data Eng.24(3), 506-519. 15. Delgrande, J.P, & Peppas, P. (2011). Revising Horn Theories. IJCAI, 839-844. 16. Eiter, T., & Makino,K. (2007). On computing all abductive explanations from a\npropositional Horn theory. J. ACM 54 (5). 17. Falappa, M.A., et al.(2012). Prioritized and Non-prioritized Multiple Change on\nBelief Bases. J. Philosophical Logic 41 (1), 77-113. 18. Ferm\u00e9, E.L., & Hansson, S.O. (2011). AGM 25 Years - Twenty-Five Years of Re-\nsearch in Belief Change. J. Philosophical Logic 40 (2),295-331. 19. Godfrey, P., & et al. (1998). Integrity Constraints: Semantics and Applications.\nLogics for Databases and Information Systems, 265-306. 20. Hansson, S.O. (1996). A Test Battery for Rational Database Updating. Artif. In-\ntell82 (1-2), 341-352. 21. Hansson, S.O. (1997).A Textbook of Belief Dynamics. Kluwer Academic Publishers,\nDordrecht. 22. Herzig, A. & Rifi,O. (1999). Propositional Belief Base Update and Minimal Change.\nArtif. Intell. 115(1), 107-138. 23. Keller, A. (1985).Updating Relational Databases Through Views. Phd Thesis. 24. Kogalovsky, M.R. (2012). Ontology-based data access systems. Programming and\nComputer Software 38(4), 167-182. 25. Konieczny, S. (2011). Dynamics of Beliefs. SUM, 61-74. 26. Kowalski, R. (1994). Logic without model theory. Technical Report, Department of\nComputing, Imperial College, London, U.K. 27. Lakemeyer, G. (1995). A Logical Account of Relevance. IJCAI (1), 853-861. 28. Langlois, M., et al. (2008). Horn Complements: Towards Horn-to-Horn Belief Re-\nvision. AAAI, 466-471. 29. Laurent, D., et al. (1998). Updating Intensional Predicates in Deductive Databases.\nData Knowl. Eng. 26(1), 37-70. 30. Liberatore, P. (1997). The Complexity of Belief Update (Extended in 2003). IJ-\nCAI (1), 68-73. 31. Liberatore, P., & Schaerf, M. (2004). The Compactness of Belief Revision and\nUpdate Operators. Fundam. Inform. 62(3-4), 377-393."}, {"heading": "32. Lobo, J., & Trajcevski, G. (1997). Minimal and Consistent Evolution of Knowledge", "text": "Bases, Journal of Applied Non-Classical Logics 7(1). 33. Lu, W. (1999). View Updates in Disjunctive Deductive Databases Based on SLDResolution. KRDB, 31-35. 34. Makinson, D. (1997). Screened Revision, Theoria 63, 14-23. 35. Mayol, E., & Teniente, E. (1999). A Survey of Current Methods for Integrity Con-\nstraint Maintenance and View Updating. ER (Workshops), 62-73. 36. Meyden, R. (1998). Logical Approaches to Incomplete Information: A Survey. Log-\nics for Databases and Information Systems, 307-356. 37. Minker, J. (1996). Logic and Databases: A 20 Year Retrospective. Logic in\nDatabases, 3-57. 38. Mota-Herranz, L., et al. (2000). Transaction Trees for Knowledge Revision, FQAS,\n182-191. 39. Nayak, A., et al. (2006). Forgetting and Knowledge Update. Australian Conference\non Artificial Intelligence, 131-140. 40. Nayak, A. (2011). Is Revision a Special Kind of Update? Australasian Conference\non Artificial Intelligence, 432-441. 41. Nebel, B. (1998). How Hard is it to Revise a Belief Base? Handbook of Defeasible\nReasoning and Uncertainty Management Systems, 77-145. 42. Papini, O.(2000). Knowledge-base revision. The Knowledge Engineering Review\n15(4), 339 - 370. 43. Qi, G., & Yang, F. (2008). A Survey of Revision Approaches in Description Logics.\nDescription Logics. 44. Schulte, O. (1999). Minimal Belief Change and Pareto-Optimality. Australian\nJoint Conference on Artificial Intelligence, 144-155. 45. Segerberg, K. (1998). Irrevocable Belief Revision in Dynamic Doxastic Logic. Notre\nDame Journal of Formal Logic 39(3), 287-306. 46. Siebes, A., et al. (1996). Deductive Databases: Challenges, Opportunities and Fu-\nture Directions (Panel Discussion). Logic in Databases, 225-229. 47. Teniente, E., & Urp\u0301\u0131, T. (2003). On the abductive or deductive nature of database\nschema validation and update processing problems. TPLP 3 (3), 287-327. 48. Wrobel, S. (1995). First order Theory Refinement. IOS Frontier in AI and Appli-\ncation Series."}], "references": [{"title": "On the logic of theory change: Partial meet con- traction and revision functions", "author": ["C.E. Alchourron"], "venue": "Journal of Symbolic Logic 50,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1985}, {"title": "Abductive Resoning Logic Investigations into Discovery and Explanation", "author": ["A. Aliseda"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "A Transformation-Based Approach to View Updating in Stratifiable Deductive Databases", "author": ["A. Behrend", "R. Manthey"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Combining Nonmonotonic Reasoning and Belief Revision: A Practical Approach", "author": ["B. Bessant"], "venue": "AIMSA,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1998}, {"title": "Inference-usability confinement by maintaining inference-proof views of an information system. IJCSE", "author": ["J. Biskup"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "The View-Update Problem for Indefinite Databases. JELIA", "author": ["L. Caroprese"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Belief Dynamics, Abduction, and Database", "author": ["A. Chandrabose", "Dung", "P.M"], "venue": "JELIA,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1994}, {"title": "Dynamics of Belief: Epistmology, Abduction and Database Update", "author": ["Chandrabose A"], "venue": "Phd Thesis,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1995}, {"title": "View-based query answering in Description Logics Semantics and complexity", "author": ["D Calvanese"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "A Comparative Study of View Update Problem", "author": ["H. Chen", "H. Liao"], "venue": "DSDE,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "On Simplification of Database Integrity Constraints", "author": ["H. Christiansen", "D. Martinenghi"], "venue": "Fundam. Inform", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "Extending the Database Relational Model to Capture More Meaning", "author": ["E.F. Codd"], "venue": "ACM Trans. Database Syst", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1979}, {"title": "On the Complexity of View Update Analysis and Its Application to Annotation Propagation", "author": ["G Cong"], "venue": "IEEE Trans. Knowl. Data", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "On computing all abductive explanations from a propositional Horn theory", "author": ["T. Eiter", "K. Makino"], "venue": "J. ACM", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Prioritized and Non-prioritized", "author": ["M.A. Falappa"], "venue": "Multiple Change on Belief Bases. J. Philosophical Logic", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "AGM 25 Years - Twenty-Five Years of Research in Belief Change", "author": ["E.L. Ferm\u00e9", "S.O. Hansson"], "venue": "J. Philosophical Logic", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "Integrity Constraints: Semantics and Applications", "author": ["P Godfrey"], "venue": "Logics for Databases and Information Systems,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1998}, {"title": "A Test Battery for Rational Database Updating", "author": ["S.O. Hansson"], "venue": "Artif. Intell82", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1996}, {"title": "Textbook of Belief Dynamics", "author": ["S.O. Hansson"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1997}, {"title": "Propositional Belief Base Update and Minimal Change", "author": ["A. Herzig", "O. Rifi"], "venue": "Artif. Intell", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1999}, {"title": "Relational Databases Through Views", "author": ["A. Keller"], "venue": "Phd Thesis", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1985}, {"title": "Ontology-based data access systems", "author": ["M.R. Kogalovsky"], "venue": "Programming and Computer Software", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Dynamics of Beliefs", "author": ["S. Konieczny"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2011}, {"title": "Logic without model theory", "author": ["R. Kowalski"], "venue": "Technical Report,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1994}, {"title": "Horn Complements: Towards Horn-to-Horn Belief Revision", "author": ["M Langlois"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2008}, {"title": "Updating Intensional Predicates in Deductive Databases", "author": ["D Laurent"], "venue": "Data Knowl. Eng", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1998}, {"title": "The Complexity of Belief Update (Extended", "author": ["P. Liberatore"], "venue": "IJCAI", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1997}, {"title": "The Compactness of Belief Revision and Update Operators", "author": ["P. Liberatore", "M. Schaerf"], "venue": "Fundam. Inform", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2004}, {"title": "Minimal and Consistent Evolution of Knowledge Bases, Journal of Applied Non-Classical Logics 7(1)", "author": ["J. Lobo", "G. Trajcevski"], "venue": null, "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1997}, {"title": "View Updates in Disjunctive Deductive Databases Based on SLD- Resolution", "author": ["W. Lu"], "venue": "KRDB,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1999}, {"title": "A Survey of Current Methods for Integrity Con- straint Maintenance and View Updating", "author": ["E. Mayol", "E. Teniente"], "venue": "ER (Workshops),", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 1999}, {"title": "Logical Approaches to Incomplete Information: A Survey", "author": ["R. Meyden"], "venue": "Log- ics for Databases and Information Systems,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 1998}, {"title": "Logic and Databases: A 20 Year Retrospective", "author": ["J. Minker"], "venue": "Logic in Databases,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1996}, {"title": "Transaction Trees for Knowledge Revision", "author": ["L Mota-Herranz"], "venue": "FQAS,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2000}, {"title": "Forgetting and Knowledge Update", "author": ["A Nayak"], "venue": "Australian Conference on Artificial Intelligence,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2006}, {"title": "Is Revision a Special Kind of Update", "author": ["A. Nayak"], "venue": "Australasian Conference on Artificial Intelligence,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2011}, {"title": "How Hard is it to Revise a Belief Base", "author": ["B. Nebel"], "venue": "Handbook of Defeasible Reasoning and Uncertainty Management Systems,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1998}, {"title": "Knowledge-base revision. The Knowledge Engineering", "author": ["Papini"], "venue": "Review 15(4),", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2000}, {"title": "A Survey of Revision Approaches in Description Logics. Description Logics", "author": ["G. Qi", "F. Yang"], "venue": null, "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2008}, {"title": "Minimal Belief Change and Pareto-Optimality", "author": ["O. Schulte"], "venue": "Australian Joint Conference on Artificial Intelligence,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1999}, {"title": "Irrevocable Belief Revision in Dynamic Doxastic Logic", "author": ["K. Segerberg"], "venue": "Notre Dame Journal of Formal Logic", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 1998}, {"title": "Deductive Databases: Challenges, Opportunities and Fu- ture Directions (Panel Discussion)", "author": ["A Siebes"], "venue": "Logic in Databases,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 1996}, {"title": "On the abductive or deductive nature of database schema validation and update processing problems", "author": ["E. Teniente", "T. Ur\u1e55\u0131"], "venue": "TPLP", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2003}, {"title": "First order Theory Refinement", "author": ["S. Wrobel"], "venue": "IOS Frontier in AI and Appli- cation Series", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1995}], "referenceMentions": [{"referenceID": 6, "context": "\u22c6 This work extends from Chanderbose\u2019s [7].", "startOffset": 39, "endOffset": 42}, {"referenceID": 6, "context": "Our previous work [7,8] makes connections with contraction from knowledge base dynamics.", "startOffset": 18, "endOffset": 23}, {"referenceID": 7, "context": "Our previous work [7,8] makes connections with contraction from knowledge base dynamics.", "startOffset": 18, "endOffset": 23}, {"referenceID": 36, "context": "Our Horn knowledge base dynamics, is defined in two parts: an immutable part (Horn formulae) and updatable part (literals) (for definition and properties see works of Nebel [41] and Segerberg [45]).", "startOffset": 173, "endOffset": 177}, {"referenceID": 40, "context": "Our Horn knowledge base dynamics, is defined in two parts: an immutable part (Horn formulae) and updatable part (literals) (for definition and properties see works of Nebel [41] and Segerberg [45]).", "startOffset": 192, "endOffset": 196}, {"referenceID": 19, "context": "The principle of minimal change [22,44] can provide a reasonable strategy.", "startOffset": 32, "endOffset": 39}, {"referenceID": 39, "context": "The principle of minimal change [22,44] can provide a reasonable strategy.", "startOffset": 32, "endOffset": 39}, {"referenceID": 0, "context": "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of AGM [1]; what result has to be chosen [27,32,39]; and finally, according to a practical point of view, what computational model to support for Horn knowledge base revision has to be provided? The rest of paper is organized as follows: First we start with preliminaries in Section 2.", "startOffset": 194, "endOffset": 197}, {"referenceID": 28, "context": "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of AGM [1]; what result has to be chosen [27,32,39]; and finally, according to a practical point of view, what computational model to support for Horn knowledge base revision has to be provided? The rest of paper is organized as follows: First we start with preliminaries in Section 2.", "startOffset": 228, "endOffset": 238}, {"referenceID": 34, "context": "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of AGM [1]; what result has to be chosen [27,32,39]; and finally, according to a practical point of view, what computational model to support for Horn knowledge base revision has to be provided? The rest of paper is organized as follows: First we start with preliminaries in Section 2.", "startOffset": 228, "endOffset": 238}, {"referenceID": 0, "context": "Perhaps the most basic operation in Horn knowledge base change, like belief change, is that of contraction (AGM [1]), which is intended to represent situations in which an agent has to give up \u03c6 from its current stock of beliefs (denoted as KB-\u03c6).", "startOffset": 112, "endOffset": 115}, {"referenceID": 14, "context": "Then, the revision can be trivially achieved by expansion, and the axiomatic characterization could be straightforwardly obtained from the corresponding characterizations of the traditional models [17].", "startOffset": 197, "endOffset": 201}, {"referenceID": 0, "context": "AGM [1] proposed a formal framework in which revision(contraction) is interpreted as belief change.", "startOffset": 4, "endOffset": 7}, {"referenceID": 7, "context": "Focusing on the logical structure of beliefs, they formulate eight postulates which a revision knowledge base (contraction knowledge base was discussed in [8]) has to verify.", "startOffset": 155, "endOffset": 158}, {"referenceID": 7, "context": "So, relaxing this condition (example with more details can be found in [8]), this can be weakened to relevance.", "startOffset": 71, "endOffset": 74}, {"referenceID": 1, "context": "The relationship between Horn knowledge base dynamics and abduction was introduced by the philosopher Pierce (see [2]).", "startOffset": 114, "endOffset": 117}, {"referenceID": 6, "context": "Two kinds of view updates can be carried out on a DDB: An atom(literals), that does not currently follow from DDB, can be inserted; or an atom(literals), that currently follows from DDB, can be deleted [7,8].", "startOffset": 202, "endOffset": 207}, {"referenceID": 7, "context": "Two kinds of view updates can be carried out on a DDB: An atom(literals), that does not currently follow from DDB, can be inserted; or an atom(literals), that currently follows from DDB, can be deleted [7,8].", "startOffset": 202, "endOffset": 207}, {"referenceID": 32, "context": "Note that DDB can be considered [37,46] as a knowledge base to be revised.", "startOffset": 32, "endOffset": 39}, {"referenceID": 41, "context": "Note that DDB can be considered [37,46] as a knowledge base to be revised.", "startOffset": 32, "endOffset": 39}, {"referenceID": 23, "context": "As observed by Kowalski [26], logic can provide a conceptual level of understanding of relational databases, and hence rationality postulates (KB*1) to (KB*6) and (KB*7.", "startOffset": 24, "endOffset": 28}, {"referenceID": 10, "context": "\u2200x, y, z (y=x) \u2190 group chair(x,y) \u2227 group chair(x,z) (see definition and properties of similarity in works of Christiansen [11] and Godfrey [19]).", "startOffset": 123, "endOffset": 127}, {"referenceID": 16, "context": "\u2200x, y, z (y=x) \u2190 group chair(x,y) \u2227 group chair(x,z) (see definition and properties of similarity in works of Christiansen [11] and Godfrey [19]).", "startOffset": 140, "endOffset": 144}, {"referenceID": 33, "context": "All solutions translate [38] a view update request into a transaction combining insertions and deletions of base relations for satisfying the request.", "startOffset": 24, "endOffset": 28}, {"referenceID": 29, "context": "\u2206i and \u2206j are only locally minimal abductive explanations for p wrt IDBG, but they are not locally minimal explanations (more explanations can be found in [33]).", "startOffset": 155, "endOffset": 159}, {"referenceID": 7, "context": "Will the algorithm work as intended if we restrict ourselves to acyclic program [8]", "startOffset": 80, "endOffset": 83}, {"referenceID": 31, "context": "More detailed surveys of this area can be found in [36].", "startOffset": 51, "endOffset": 55}, {"referenceID": 11, "context": "The earliest extension of the relational model to incomplete information was that of Codd [13] who suggested that missing values should be represented in tables by placing a special null value symbol \u2217 at any table location for which the value is unknown.", "startOffset": 90, "endOffset": 94}, {"referenceID": 6, "context": "Chandrabose [7,8], defines a contraction operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [21] belief change.", "startOffset": 12, "endOffset": 17}, {"referenceID": 7, "context": "Chandrabose [7,8], defines a contraction operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [21] belief change.", "startOffset": 12, "endOffset": 17}, {"referenceID": 18, "context": "Chandrabose [7,8], defines a contraction operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [21] belief change.", "startOffset": 130, "endOffset": 134}, {"referenceID": 13, "context": "Eiter [16], Langlois[28], and Delgrande [15] are focusing on Horn revision with different perspectives like prime implication, logical closure and belief level.", "startOffset": 6, "endOffset": 10}, {"referenceID": 24, "context": "Eiter [16], Langlois[28], and Delgrande [15] are focusing on Horn revision with different perspectives like prime implication, logical closure and belief level.", "startOffset": 20, "endOffset": 24}, {"referenceID": 40, "context": "Segerberg [45] defined new modeling for belief revision in terms of irrevocability on prioritized revision.", "startOffset": 10, "endOffset": 14}, {"referenceID": 18, "context": "Hansson [21], constructed five types of non-prioritized belief revision.", "startOffset": 8, "endOffset": 12}, {"referenceID": 37, "context": "Papini[42] defined a new version of knowledge base revision.", "startOffset": 6, "endOffset": 10}, {"referenceID": 18, "context": "In such a case, Hansson\u2019s[21] kernel change is related with abductive method.", "startOffset": 25, "endOffset": 29}, {"referenceID": 1, "context": "Aliseda\u2019s [2] book on abductive reasoning is one of the motivation keys.", "startOffset": 10, "endOffset": 13}, {"referenceID": 43, "context": "Wrobel\u2019s [48] definition of first order theory revision was helpful to frame our algorithm.", "startOffset": 9, "endOffset": 13}, {"referenceID": 20, "context": "Keller\u2019s [23] thesis is motivation for view update problem.", "startOffset": 9, "endOffset": 13}, {"referenceID": 9, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[10] and survey paper on view algorithm by Mayol and Teniente [35].", "startOffset": 113, "endOffset": 117}, {"referenceID": 30, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[10] and survey paper on view algorithm by Mayol and Teniente [35].", "startOffset": 175, "endOffset": 179}, {"referenceID": 3, "context": "[4] , local search-based heuristic technique that empirically proves to be often viable, even in the context of very large propositional applications.", "startOffset": 0, "endOffset": 3}, {"referenceID": 25, "context": "[29], parented updating deductive databases in which every insertion or deletion of a fact can be performed in a deterministic way.", "startOffset": 0, "endOffset": 4}, {"referenceID": 38, "context": "Furthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [43], and", "startOffset": 140, "endOffset": 144}, {"referenceID": 21, "context": "Kogalovsky [24]).", "startOffset": 11, "endOffset": 15}, {"referenceID": 26, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [30,31], Caroprese [6], Calvanese\u2019s [9], and Cong [14]).", "startOffset": 146, "endOffset": 153}, {"referenceID": 27, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [30,31], Caroprese [6], Calvanese\u2019s [9], and Cong [14]).", "startOffset": 146, "endOffset": 153}, {"referenceID": 5, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [30,31], Caroprese [6], Calvanese\u2019s [9], and Cong [14]).", "startOffset": 165, "endOffset": 168}, {"referenceID": 8, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [30,31], Caroprese [6], Calvanese\u2019s [9], and Cong [14]).", "startOffset": 182, "endOffset": 185}, {"referenceID": 12, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [30,31], Caroprese [6], Calvanese\u2019s [9], and Cong [14]).", "startOffset": 196, "endOffset": 200}, {"referenceID": 5, "context": "Though we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [6] and [5]).", "startOffset": 214, "endOffset": 217}, {"referenceID": 4, "context": "Though we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [6] and [5]).", "startOffset": 222, "endOffset": 225}, {"referenceID": 2, "context": "It would also be interesting to study how results using soft stratification [3] with belief dynamics, especially the relational approach, could be applied in real world problems.", "startOffset": 76, "endOffset": 79}, {"referenceID": 15, "context": "As immediate extension, question raises: is there any real life application for AGM in 25 year theory? [18].", "startOffset": 103, "endOffset": 107}, {"referenceID": 17, "context": "The revision and update are more challenging in logical view update problem(database theory), so we can extend the theory to combine results similar to Hansson\u2019s [20], Konieczny\u2019s [25]and Nayak, [40].", "startOffset": 162, "endOffset": 166}, {"referenceID": 22, "context": "The revision and update are more challenging in logical view update problem(database theory), so we can extend the theory to combine results similar to Hansson\u2019s [20], Konieczny\u2019s [25]and Nayak, [40].", "startOffset": 180, "endOffset": 184}, {"referenceID": 35, "context": "The revision and update are more challenging in logical view update problem(database theory), so we can extend the theory to combine results similar to Hansson\u2019s [20], Konieczny\u2019s [25]and Nayak, [40].", "startOffset": 195, "endOffset": 199}, {"referenceID": 8, "context": "Since this proof requires some details of acyclic programs that are not directly related to our discussion here, it is relegated [9].", "startOffset": 129, "endOffset": 132}], "year": 2013, "abstractText": "The dynamics of belief and knowledge is one of the major components of any autonomous system that should be able to incorporate new pieces of information. In this paper, we argue that to apply rationality result of belief dynamics theory to various practical problems, it should be generalized in two respects: first of all, it should allow a certain part of belief to be declared as immutable; and second, the belief state need not be deductively closed. Such a generalization of belief dynamics, referred to as base dynamics, is presented, along with the concept of a generalized revision algorithm for Horn knowledge bases. We show that Horn knowledge base dynamics has interesting connection with kernel change and abduction. Finally, we also show that both variants are rational in the sense that they satisfy certain rationality postulates stemming from philosophical works on belief dynamics. Keyword: AGM, Belief Update, Horn Knowledge Base Dynamics, Kernel Change, Abduction, View update.", "creator": "LaTeX with hyperref package"}}}