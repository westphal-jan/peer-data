{"id": "1305.2581", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-May-2013", "title": "Accelerated Mini-Batch Stochastic Dual Coordinate Ascent", "abstract": "anaplastic Stochastic boutris dual wire-to-wire coordinate ascent (SDCA) 100.45 is an axmann effective technique dierk for muffet solving regularized loss lattices minimization problems in recused machine reinvasion learning. 1980-2000 This bricklayer paper manoel considers an grenier extension (615) of midcap50 SDCA aloof under the genndy mini - j\u00e4mtland batch setting aeryn that atheer is dire often used rehires in practice. Our main allanon contribution hirudin is ouachita to mummery introduce an fortul accelerated mini - clinkscales batch tr\u01b0\u1edfng version of berlian SDCA bengali-language and prove chisels a fast convergence rate anupama for this 2217 method. We 5,120 discuss whedon an khentkaus implementation merima of our method over a sobbing parallel acpc computing 1992-96 system, and wittow compare helidon the results 130.0 to both the vanilla worldpartners stochastic noncanonical dual :02 coordinate ascent and to caprock the accelerated deterministic gradient bushier descent trai method newly-wed of \\ cite {nesterov2007gradient }.", "histories": [["v1", "Sun, 12 May 2013 12:46:25 GMT  (105kb,D)", "http://arxiv.org/abs/1305.2581v1", null]], "reviews": [], "SUBJECTS": "stat.ML cs.LG", "authors": ["shai shalev-shwartz", "tong zhang 0001"], "accepted": true, "id": "1305.2581"}, "pdf": {"name": "1305.2581.pdf", "metadata": {"source": "CRF", "title": "Accelerated Mini-Batch Stochastic Dual Coordinate Ascent", "authors": ["Shai Shalev-Shwartz", "Tong Zhang"], "emails": [], "sections": [{"heading": null, "text": "imization problems in machine learning. This paper considers an extension of SDCA under the minibatch setting that is often used in practice. Our main contribution is to introduce an accelerated minibatch version of SDCA and prove a fast convergence rate for this method. We discuss an implementation of our method over a parallel computing system, and compare the results to both the vanilla stochastic dual coordinate ascent and to the accelerated deterministic gradient descent method of Nesterov [2007]."}, {"heading": "1 Introduction", "text": "We consider the following generic optimization problem. Let \u03c61, . . . , \u03c6n be a sequence of vector convex functions from Rd to R, and let g : Rd \u2192 R be a strongly convex regularization function. Our goal is to solve minx\u2208Rd P (x) where\nP (x) =\n[ 1\nn n\u2211 i=1 \u03c6i(x) + g(x)\n] . (1)\nFor example, given a sequence of n training examples (v1, y1), . . . , (vn, yn), where vi \u2208 Rd and yi \u2208 R, ridge regression is obtained by setting g(x) = \u03bb2\u2016x\u2016\n2 and \u03c6i(x) = (x>vi \u2212 yi)2. Regularized logistic regression is obtained by setting \u03c6i(x) = log(1 + exp(\u2212yix>vi)).\nThe dual problem of (1) is defined as follows: For each i, let \u03c6\u2217i : Rd \u2192 R be the convex conjugate of \u03c6i, namely, \u03c6\u2217i (u) = maxz\u2208Rd(z\n>u \u2212 \u03c6i(z)). Similarly, let g\u2217 be the convex conjugate of g. The dual problem is:\nmax \u03b1\u2208Rd\u00d7n D(\u03b1) where D(\u03b1) =\n[ 1\nn n\u2211 i=1 \u2212\u03c6\u2217i (\u2212\u03b1i)\u2212 g\u2217 ( 1 n n\u2211 i=1 \u03b1i )] , (2)\nwhere for each i, \u03b1i is the i\u2019th column of the matrix \u03b1. The dual objective has a different dual vector associated with each primal function. Dual Coordinate Ascent (DCA) methods solve the dual problem iteratively, where at each iteration of DCA, the dual objective is optimized with respect to a single dual vector, while the rest of the dual vectors are kept in tact. Recently, Shalev-Shwartz and Zhang [2013] analyzed a stochastic version of dual coordinate ascent, abbreviated by SDCA, in which at each round we choose which dual vector to optimize uniformly at random. In particular, let x\u2217 be the optimum of (1). We say that a solution x is -accurate if P (x) \u2212 P (x\u2217) \u2264 . Shalev-Shwartz and Zhang [2013] have derived the following convergence guarantee for SDCA: If g(x) = \u03bb2\u2016x\u2016 2 2 and each \u03c6i is \u03b3-smooth, then for every > 0, if we run SDCA for at least( n+ 1\u03bb\u03b3 ) log((n+ 1\u03bb\u03b3 ) \u00b7 1 )\nar X\niv :1\n30 5.\n25 81\nv1 [\nst at\n.M L\n] 1\n2 M\nay 2\n01 3\niterations, then the solution of the SDCA algorithm will be -accurate (in expectation). This convergence rate is significantly better than the more commonly studied stochastic gradient descent (SGD) methods that are related to SDCA1.\nAnother approach to solving (1) is deterministic gradient descent methods. In particular, Nesterov [2007] proposed an accelerated gradient descent (AGD) method for solving (1). Under the same conditions mentioned above, AGD finds an -accurate solution after performing\nO ( 1\u221a \u03bb\u03b3 log(1 ) ) iterations.\nThe advantage of SDCA over AGD is that each iteration involves only a single dual vector and in general costs O(d). In contrast, each iteration of AGD requires \u2126(nd) operations. On the other hand, AGD has a better dependence on the condition number of the problem \u2014 the iteration bound of AGD scales with 1/ \u221a \u03bb\u03b3 while the iteration bound of SDCA scales with 1/(\u03bb\u03b3).\nIn this paper we describe and analyze a new algorithm that interpolates between SDCA and AGD. At each iteration of the algorithm, we randomly pick a subset of m indices from {1, . . . , n} and update the dual vectors corresponding to this subset. This subset is often called a mini-batch. The use of mini-batches is common with SGD optimization, and it is beneficial when the processing time of a mini-batch of size m is much smaller than m times the processing time of one example (mini-batch of size 1). For example, in the practical training of neural networks with SGD, one is always advised to use mini-batches because it is more efficient to perform matrix-matrix multiplications over a mini-batch than an equivalent amount of matrix-vector multiplication operations (each over a single training example). This is especially noticeable when GPU is used: in some cases the processing time of a mini-batch of size 100 may be the same as that of a mini-batch of size 10. Another typical use of mini-batch is for parallel computing, which was studied by various authors for stochastic gradient descent (e.g., Dekel et al. [2012]). This is also the application scenario we have in mind, and will be discussed in greater details in Section 3.\nRecently, Tak\u00e1c et al. [2013] studied mini-batch variants of SDCA in the context of the Support Vector Machine (SVM) problem. They have shown that the naive mini-batching method, in whichm dual variables are optimized in parallel, might actually increase the number of iterations required. They then describe several \u201csafe\u201d mini-batching schemes, and based on the analysis of Shalev-Shwartz and Zhang [2013], have shown several speed-up results. However, their results are for the non-smooth case and hence they do not obtain linear convergence rate. In addition, the speed-up they obtain requires some spectral properties of the training examples. We take a different approach and employ Nesterov\u2019s acceleration method, which has previously been applied to mini-batch SGD optimization. This paper shows how to achieve acceleration for SDCA in the mini-batch setting. The pseudo code of our Accelerated Mini-Batch SDCA, abbreviated by ASDCA, is presented below.\n1An exception is the recent analysis given in Le Roux et al. [2012] for a variant of SGD.\nProcedure Accelerated Mini-Batch SDCA\nParameters scalars \u03bb, \u03b3 and \u03b8 \u2208 [0, 1] ; mini-batch size m Initialize \u03b1(0)1 = \u00b7 \u00b7 \u00b7 = \u03b1 (0) n = \u03b1\u0304(t) = 0, x(0) = 0 Iterate: for t = 1, 2, . . . u(t\u22121) = (1\u2212 \u03b8)x(t\u22121) + \u03b8\u2207g\u2217(\u03b1\u0304(t\u22121)) Randomly pick subset I \u2282 {1, . . . , n} of size m and update the dual variables in I\n\u03b1 (t) i = (1\u2212 \u03b8)\u03b1 (t\u22121) i \u2212 \u03b8\u2207\u03c6i(u(t\u22121)) for i \u2208 I \u03b1 (t) j = \u03b1 (t\u22121) j for j /\u2208 I\n\u03b1\u0304(t) = \u03b1\u0304(t\u22121) + n\u22121 \u2211\ni\u2208I(\u03b1 (t) i \u2212 \u03b1 (t\u22121) i )\nx(t) = (1\u2212 \u03b8)x(t\u22121) + \u03b8\u2207g\u2217(\u03b1\u0304(t)) end\nIn the next section we present our main result \u2014 an analysis of the number of iterations required by ASDCA. We focus on the case of Euclidean regularization, namely, g(x) = \u03bb2\u2016x\u2016\n2. Analyzing more general strongly convex regularization functions is left for future work. In Section 3 we discuss parallel implementations of ASDCA and compare it to parallel implementations of AGD and SDCA. In particular, we explain in which regimes ASDCA can be better than both AGD and SDCA. In Section 4 we present some experimental results, demonstrating how ASDCA interpolates between AGD and SDCA. The proof of our main theorem is presented in Section 5. We conclude with a discussion of our work in light of related works in Section 6."}, {"heading": "2 Main Results", "text": "Our main result is a bound on the number of iterations required by ASDCA to find an -accurate solution. In our analysis, we only consider the squared Euclidean norm regularization,\ng(x) = \u03bb\n2 \u2016x\u20162,\nwhere \u2016\u00b7\u2016 is the Euclidean norm and \u03bb > 0 is a regularization parameter. The analysis for general \u03bb-strongly convex regularizers is left for future work. For the squared Euclidean norm we have\ng\u2217(\u03b1) = 1\n2\u03bb \u2016\u03b1\u20162,\nand \u2207g\u2217(\u03b1) = 1\n\u03bb \u03b1 .\nWe further assume that each \u03c6i is 1/\u03b3-smooth with respect to \u2016 \u00b7 \u2016, namely,\n\u2200x, z, \u03c6i(x) \u2264 \u03c6i(z) +\u2207\u03c6i(z)>(x\u2212 z) + 1\n2\u03b3 \u2016x\u2212 z\u20162.\nFor example, if \u03c6i(x) = (x>vi \u2212 yi)2, then it is \u2016vi\u20162-smooth. The smoothness of \u03c6i also implies that \u03c6\u2217i (\u03b1) is \u03b3-strongly convex:\n\u2200\u03b8 \u2208 [0, 1], \u03c6\u2217i ((1\u2212 \u03b8)\u03b1+ \u03b8\u03b2) \u2264 (1\u2212 \u03b8)\u03c6\u2217i (\u03b1) + \u03b8\u03c6\u2217i (\u03b2)\u2212 \u03b8(1\u2212 \u03b8)\u03b3\n2 \u2016\u03b1\u2212 \u03b2\u20162,\nTheorem 1. Assume that g(x) = 12\u03bb\u2016x\u2016 2 2 and for each i, \u03c6i is (1/\u03b3)-smooth w.r.t. the Euclidean norm. Suppose that the ASDCA algorithm is run with parameters \u03bb, \u03b3,m, \u03b8, where\n\u03b8 \u2264 1 4 min\n{ 1 , \u221a \u03b3\u03bbn\nm , \u03b3\u03bbn ,\n(\u03b3\u03bbn)2/3\nm1/3\n} . (3)\nDefine the dual sub-optimality by \u2206D(\u03b1) = D(\u03b1\u2217)\u2212D(\u03b1), where \u03b1\u2217 is the optimal dual solution, and the primal sub-optimality by \u2206P (x) = P (x)\u2212D(\u03b1\u2217). Then,\nmE\u2206P (x(t)) + nE\u2206D(\u03b1(t)) \u2264 (1\u2212 \u03b8m/n)t[m\u2206P (x(0)) + n\u2206D(\u03b1(0))]."}, {"heading": "It follows that after performing", "text": "t \u2265 n/m \u03b8 log\n( m\u2206P (x(0)) + n\u2206D(\u03b1(0))\nm\n)\niterations, we have that E[P (x(t))\u2212D(\u03b1(t))] \u2264 .\nLet us now discuss the bound, assuming \u03b8 is taken to be the right-hand side of (3). The dominating factor of the bound on t becomes\nn\nm\u03b8 =\nn m \u00b7max\n{ 1 , \u221a m\n\u03b3\u03bbn ,\n1\n\u03b3\u03bbn ,\nm1/3\n(\u03b3\u03bbn)2/3\n} (4)\n= max\n{ n\nm ,\n\u221a n/m\n\u03b3\u03bb ,\n1/m\n\u03b3\u03bb ,\nn1/3\n(\u03b3\u03bbm)2/3\n} . (5)\nTable 1 summarizes several interesting cases, and compares the iteration bound of ASDCA to the iteration bound of the vanilla SDCA algorithm (as analyzed in Shalev-Shwartz and Zhang [2013]) and the Accelerated Gradient Descent (AGD) algorithm of Nesterov [2007]. In the table, we ignore constants and logarithmic factors.\nAs can be seen in the table, the ASDCA algorithm interpolates between SDCA and AGD. In particular, ASDCA has the same bound as SDCA when m = 1 and the same bound as AGD when m = n. Recall that the cost of each iteration of AGD scales with n while the cost of each iteration of SDCA does not scale with n. The cost of each iteration of ASDCA scales with m. To compensate for the difference cost per iteration for different algorithms, we may also compare the complexity in terms of the number of examples processed in Table 2. This is also what we will study in our empirical experiments. It should be mentioned that this comparison is meaningful in a single processor environment, but not in a parallel computing environment when multiple examples can be processed simultaneiously in a minibatch. In the next section we discuss under what conditions the overall runtime of ASDCA is better than both AGD and SDCA."}, {"heading": "3 Parallel Implementation", "text": "In recent years, there has been a lot of interest in implementing optimization algorithms using a parallel computing architecture (see Section 6). We now discuss how to implement AGD, SDCA, and ASDCA when having a computing machine with s parallel computing nodes.\nIn the calculations below, we use the following facts:\n\u2022 If each node holds a d-dimensional vector, we can compute the sum of these vectors in timeO(d log(s)) by applying a \u201ctree-structure\u201d summation (see for example the All-Reduce architecture in Agarwal et al. [2011]).\n\u2022 A node can broadcast a message with c bits to all other nodes in time O(c log2(s)). To see this, order nodes on the corners of the log2(s)-dimensional hypercube. Then, at each iteration, each node sends the message to its log(s) neighbors (namely, the nodes whose code word is at a hamming distance of 1 from the node). The message between the furthest away nodes will pass after log(s) iterations. Overall, we perform log(s) iterations and each iteration requires transmitting c log(s) bits.\n\u2022 All nodes can broadcast a message with c bits to all other nodes in time O(cs log2(s)). To see this, simply apply the broadcasting of the different nodes mentioned above in parallel. The number of iterations will still be the same, but now, at each iteration, each node should transmit cs bits to its log(s) neighbors. Therefore, it takes O(cs log2(s)) time.\nFor concreteness of the discussion, we consider problems in which \u03c6i(x) takes the form of `(x>vi, yi), where yi is a scalar and vi \u2208 Rd. This is the case in supervised learning of linear predictors (e.g. logistic regression or ridge regression). We further assume that the average number of non-zero elements of vi is d\u0304. In very large-scale problems, a single machine cannot hold all of the data in its memory. However, we assume that a single node can hold a fraction of 1/s of the data in its memory.\nLet us now discuss parallel implementations of the different algorithms starting with deterministic gradient algorithms (such as AGD). The bottleneck operation of deterministic gradient algorithms is the calculation of the gradient. In the notation mentioned above, this amounts to performing order of nd\u0304 operations. If the data is distributed over s computing nodes, where each node holds n/s examples, we can calculate the gradient in time O(nd\u0304/s + d log(s)) as follows. First, each node calculates the gradient over its own n/s examples (which takes time O(nd\u0304/s)). Then, the s resulting vectors in Rd are summed up in time O(d log(s)).\nNext, let us consider the SDCA algorithm. On a single computing node, it was observed that SDCA is much more efficient than deterministic gradient descent methods, since each iteration of SDCA costs only \u0398(d\u0304) while each iteration of AGD costs \u0398(nd\u0304). When we have s nodes, for the SDCA algorithm, dividing the examples into s computing nodes does not yield any speed-up. However, we can divide the features into the s nodes (that is, each node will hold d/s of the features for all of the examples). This enables the computation of x>vi in (expected) time of O(d\u0304/s+ s log2(s)). Indeed, node t will calculate \u2211 j\u2208Jt xjvi,j ,\nwhere Jt is the set of features stored in node t (namely, |Jt| = d/s). Then, each node broadcasts the resulting scalar to all the other nodes. Note that we will obtain a speed-up over the naive implementation only if s log2(s) d\u0304.\nFor the ASDCA algorithm, each iteration involves the computation of the gradient over m examples. We can choose to implement it by dividing the examples to the s nodes (as we did for AGD) or by dividing the features into the s nodes (as we did for SDCA). In the first case, the cost of each iteration is O(md\u0304/s+ d log(s)) while in the latter case, the cost of each iteration is O(md\u0304/s + ms log2(s)). We will choose between these two implementations based on the relation between d,m, and s.\nThe runtime and communication time of each iteration is summarized in the table below.\nAlgorithm partition type runtime communication time\nSDCA features d\u0304/s s log2(s)\nASDCA features d\u0304m/s ms log2(s)\nASDCA examples d\u0304m/s d log(s)\nAGD examples d\u0304n/s d log(s)\nWe again see that ASDCA nicely interpolates between SDCA and AGD. In practice, it is usually the case that there is a non-negligible cost of opening communication channels between nodes. In that case, it will be better to apply the ASDCA with a value of m that reflects an adequate tradeoff between the runtime of each node and the communication time. With the appropriate value of m (which depends on constants like the cost of opening communication channels and sending packets of bits between nodes), ASDCA may outperform both SDCA and AGD."}, {"heading": "4 Experimental Results", "text": "In this section we demonstrate how ASDCA interpolates between SDCA and AGD. All of our experiments are performed for the task of binary classification with a smooth variant of the hinge-loss (see ShalevShwartz and Zhang [2013]). Specifically, let (v1, y1), . . . , (vm, ym) be a set of labeled examples, where for every i, vi \u2208 Rd and yi \u2208 {\u00b11}. Define \u03c6i(x) to be\n\u03c6i(x) =  0 yix >vi > 1\n1/2\u2212 yix>vi yix>vi < 0 1 2(1\u2212 yix >vi) 2 o.w.\nWe also set the regularization function to be g(x) = \u03bb2\u2016x\u2016 2 2 where \u03bb = 1/n. This is the default value for the regularization parameter taken in several optimization packages. Following Shalev-Shwartz and Zhang [2013], the experiments were performed on three large datasets with very different feature counts and sparsity. The astro-ph dataset classifies abstracts of papers from the physics ArXiv according to whether they belong in the astro-physics section; CCAT is a classification task taken from the Reuters RCV1 collection; and cov1 is class 1 of the covertype dataset of Blackard, Jock & Dean. The following table provides details of the dataset characteristics.\nDataset Training Size Testing Size Features Sparsity astro-ph 29882 32487 99757 0.08%\nCCAT 781265 23149 47236 0.16% cov1 522911 58101 54 22.22%\nWe ran ASDCA with values of m from the set {10\u22124n, 10\u22123n, 10\u22122n}. We also ran the SDCA algorithm and the AGD algorithm. In Figure 1 we depict the primal sub-optimality of the different algorithms as a function of the number of examples processed. Note that each iteration of SDCA processes a single example, each iteration of ASDCA processes m examples, and each iteration of AGD processes n examples. As can be seen from the graphs, ASDCA indeed interpolates between SDCA and AGD. It is clear from the graphs that SDCA is much better than AGD when we have a single computing node. ASDCA performance is quite similar to SDCA when m is not very large. As discussed in Section 3, when we have parallel computing nodes and there is a non-negligible cost of opening communication channels between nodes, running ASDCA with an appropriate value ofm (which depends on constants like the cost of opening communication channels) may yield the best performance."}, {"heading": "5 Proof", "text": "We use the following notation:\nf(x) = 1\nn n\u2211 i=1 \u03c6i(x) ,\n\u2206\u03b1\u0304(t) = \u03b1\u0304(t) \u2212 \u03b1\u0304(t\u22121) .\nIn addition, we use the notation Et to denote the expectation over the choice of the set I at iteration t, conditioned on the values of x(t\u22121) and \u03b1(t\u22121).\nOur first lemma calculates the expected value of \u2206\u03b1\u0304(t).\nLemma 1. At each round t, we have\nEt[\u2206\u03b1\u0304(t)] = \u2212 \u03b8m\nn\n( \u03b1\u0304(t\u22121) +\u2207f(u(t\u22121)) ) .\nProof. By the definition of the update,\n\u2206\u03b1\u0304(t) = 1\nn \u2211 i\u2208I (\u03b1 (t) i \u2212\u03b1 (t\u22121) i ) = \u2212\u03b8 n \u2211 i\u2208I (\u03b1 (t\u22121) i +\u2207\u03c6i(u (t\u22121))) = \u2212\u03b8 n n\u2211 i=1 1[i \u2208 I](\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))) .\nTaking expectation w.r.t. the choice of I and noting that Et[1[i \u2208 I]] = m/n we obtain that\nEt[\u2206\u03b1\u0304(t)] = \u2212\u03b8m n2 n\u2211 i=1 (\u03b1 (t\u22121) i +\u2207\u03c6i(u (t\u22121))) = \u2212\u03b8m n ( \u03b1\u0304(t\u22121) +\u2207f(u(t\u22121)) ) .\nNext, we upper bound the \u201cvariance\u201d of \u2206\u03b1\u0304(t), in the sense of the expected squared norm of the difference between \u2206\u03b1\u0304(t) and its expectation.\nLemma 2. At each round t, we have\nEt\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 \u2264 m\u03b82\nn3 n\u2211 i=1 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162.\nProof. We introduce the simplified notation \u03b2i = \u2212\u03b8(\u03b1(t\u22121)i + \u2207\u03c6i(u(t\u22121))) and \u00b5 = n mEt\u2206\u03b1\u0304\n(t). Note that \u03b2i is independent of the choice of I (thus can be considered as a deterministic number). Then \u03b2i = \u03b1 (t) i \u2212 \u03b1 (t\u22121) i when i \u2208 I , and n\u22121 \u2211n i=1 \u03b2i = \u00b5. We thus have\nEt\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 = Et\u2016n\u22121 \u2211 i\u2208I (\u03b2i \u2212 \u00b5)\u20162\n=n\u22122Et \u2211 i,j\u2208I (\u03b2i \u2212 \u00b5)>(\u03b2j \u2212 \u00b5)\n=n\u22122Et \u2211 i\u2208I \u2016\u03b2i \u2212 \u00b5\u20162 + n\u22122Et \u2211 i 6=j\u2208I (\u03b2i \u2212 \u00b5)>(\u03b2j \u2212 \u00b5).\nNote that for any i 6= j \u2208 I: \u03b2i\u2212\u00b5 and \u03b2j \u2212\u00b5 can be regarded as zero-mean random vectors that are drawn uniformly at random from the same distribution without replacement. Therefore they are not positively correlated when i 6= j. That is, we have\nEt \u2211 i 6=j\u2208I (\u03b2i \u2212 \u00b5)>(\u03b2j \u2212 \u00b5) \u2264 0.\nTherefore\nEt\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 \u2264 1 n2 Et \u2211 i\u2208I \u2016\u03b2i \u2212 \u00b5\u20162 = m n3 n\u2211 i=1 \u2016\u03b2i \u2212 \u00b5\u20162\n\u2264m n3 n\u2211 i=1 \u2016\u03b2i\u20162 = m\u03b82 n3 n\u2211 i=1 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162.\nRecall that the theorem upper bounds the expected value of m\u2206P (x(t)) + n\u2206D(\u03b1(t)), which in turns upper bound the duality gap at round t. The following lemma derives an upper bound on this quantity that depends on the value of this quantity at the previous iteration and three additional terms. We will later show that the sum of the additional terms is negative in expectation. The lemma uses standard algebraic manipulations as well as the assumptions on g and \u03c6i.\nLemma 3. For each round t we have[ m\u2206P (x(t)) + n\u2206D(\u03b1(t)) ] \u2212 (\n1\u2212 \u03b8m n\n)[ m\u2206P (x(t\u22121)) + n\u2206D(\u03b1(t\u22121)) ] \u2264 a(t)I + b (t) I + c (t) I ,\nwhere\na (t) I =\nm 2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162 \u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 \u2211 i\u2208I \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 ,\nb (t) I = \u03b8mf(u\n(t\u22121)) + m\u03b8\nn n\u2211 i=1 \u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) +m\u2207f(u (t\u22121))>(\u2212\u03b8u(t\u22121))\n+ \u2211 i\u2208I [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))] ] ,\nc (t) I = m\u2207f(u (t\u22121))>(x(t) \u2212 (1\u2212 \u03b8)x(t\u22121)) + n+m\u03b8 2\u03bb \u2016\u03b1\u0304(t)\u20162 \u2212 n\u2212m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162 .\nProof. Since m/n \u2264 1 we have[ m\u2206P (x(t)) + n\u2206D(\u03b1(t)) ] \u2212 (\n1\u2212 \u03b8m n\n)[ m\u2206P (x(t\u22121)) + n\u2206D(\u03b1(t\u22121)) ] \u2264 [ m\u2206P (x(t)) + n\u2206D(\u03b1(t)) ] \u2212 [ (m\u2212 \u03b8m)\u2206P (x(t\u22121)) + (n\u2212 \u03b8m)\u2206D(\u03b1(t\u22121))\n] = m[\u2206P (x(t))\u2212\u2206P (x(t\u22121))] + n[\u2206D(\u03b1(t))\u2212\u2206D(\u03b1(t\u22121))] + \u03b8m[\u2206P (x(t\u22121)) + \u2206D(\u03b1(t\u22121))] = m[P (x(t))\u2212 P (x(t\u22121))]\u2212 n[D(\u03b1(t))\u2212D(\u03b1(t\u22121))] + \u03b8m[P (x(t\u22121))\u2212D(\u03b1(t\u22121))] = m[P (x(t))\u2212 (1\u2212 \u03b8)P (x(t\u22121))]\u2212 n[D(\u03b1(t))\u2212D(\u03b1(t\u22121))]\u2212 \u03b8mD(\u03b1(t\u22121)) .\nTherefore, we need to show that the right-hand side of the above is upper bounded by a(t)I + b (t) I + c (t) I .\nStep 1: We first bound m[P (x(t))\u2212 (1\u2212 \u03b8)P (x(t\u22121))]. Using the smoothness of f we have\nf(x(t)) \u2264 f(u(t\u22121)) +\u2207f(u(t\u22121))>(x(t) \u2212 u(t\u22121)) + 1 2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162\n= (1\u2212 \u03b8)f(u(t\u22121)) + \u03b8f(u(t\u22121)) +\u2207f(u(t\u22121))>(x(t) \u2212 u(t\u22121)) + 1 2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162\nand using the convexity of f we also have (1\u2212 \u03b8)f(u(t\u22121)) \u2264 (1\u2212 \u03b8) [ f(x(t\u22121))\u2212\u2207f(u(t\u22121))>(x(t\u22121) \u2212 u(t\u22121)) ] .\nCombining the above two inequalities and rearranging terms we obtain\nf(x(t)) \u2264 (1\u2212 \u03b8)f(x(t\u22121)) + \u03b8f(u(t\u22121)) (6) +\u2207f(u(t\u22121))> ( x(t) \u2212 \u03b8u(t\u22121) \u2212 (1\u2212 \u03b8)x(t\u22121) ) + 1\n2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162 .\nNext, using the convexity of g we have\ng(x(t)) = \u03bb 2 \u2016x(t)\u20162 = \u03bb 2 \u2225\u2225\u2225\u2225(1\u2212 \u03b8)x(t\u22121) + \u03b8\u03bb\u03b1\u0304(t) \u2225\u2225\u2225\u22252 \u2264 \u03bb(1\u2212 \u03b8)2 \u2016x(t\u22121)\u20162 + \u03b82\u03bb\u2016\u03b1\u0304(t)\u20162 .\nCombining this with (6) we obtain\nP (x(t)) = f(x(t)) + g(x(t)) \u2264 (1\u2212 \u03b8) ( f(x(t\u22121)) + \u03bb2\u2016x (t\u22121)\u20162 ) + \u03b8f(u(t\u22121))\n+\u2207f(u(t\u22121))> ( x(t) \u2212 \u03b8u(t\u22121) \u2212 (1\u2212 \u03b8)x(t\u22121) ) + 1\n2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162 + \u03b8 2\u03bb \u2016\u03b1\u0304(t)\u20162 ,\nwhich yields m [ P (x(t))\u2212 (1\u2212 \u03b8)P (x(t\u22121)) ] \u2264 m\u03b8f(u(t\u22121)) +m\u2207f(u(t\u22121))> ( x(t) \u2212 \u03b8u(t\u22121) \u2212 (1\u2212 \u03b8)x(t\u22121) ) + m\n2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162 + \u03b8m 2\u03bb \u2016\u03b1\u0304(t)\u20162 . (7)\nStep 2: Next, we bound \u2212n[D(\u03b1(t))\u2212D(\u03b1(t\u22121))]. Using the definition of the dual update we have\n\u2212 n[D(\u03b1(t))\u2212D(\u03b1(t\u22121))] = \u2211 i\u2208I [ \u03c6\u2217i (\u2212\u03b1 (t) i )\u2212 \u03c6 \u2217 i (\u2212\u03b1 (t\u22121) i ) ] + n 2\u03bb [ \u2016\u03b1\u0304(t)\u20162 \u2212 \u2016\u03b1\u0304(t\u22121)\u20162 ] . (8)\nFor all i \u2208 I , we may use the definition of the update of \u03b1(t)i in the algorithm, the strong-convexity of \u03c6\u2217i , and the equality in Fenchel-Young for gradients to obtain:\n\u03c6\u2217i (\u2212\u03b1 (t) i ) \u2264 (1\u2212 \u03b8)\u03c6 \u2217 i (\u2212\u03b1 (t\u22121) i ) + \u03b8\u03c6 \u2217 i (\u2207\u03c6i(u(t\u22121)))\u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162\n= (1\u2212 \u03b8)\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))]\u2212 \u03b8(1\u2212 \u03b8)\u03b3\n2 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 .\nCombining this with (8) we get\n\u2212 n[D(\u03b1(t))\u2212D(\u03b1(t\u22121))] \u2264 (9)\u2211 i\u2208I [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))]\u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 ] + n\n2\u03bb\n[ \u2016\u03b1\u0304(t)\u20162 \u2212 \u2016\u03b1\u0304(t\u22121)\u20162 ] .\nStep 3: Summing (9), (7), and the equation\n\u2212m\u03b8D(\u03b1(t\u22121)) = m\u03b8 n \u2211 i \u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162\nwe obtain that\nm[P (x(t))\u2212 (1\u2212 \u03b8)P (x(t\u22121))]\u2212 n[D(\u03b1(t))\u2212D(\u03b1(t\u22121))]\u2212 \u03b8mD(\u03b1(t\u22121)) \u2264 m\u03b8f(u(t\u22121)) +m\u2207f(u(t\u22121))> ( x(t) \u2212 \u03b8u(t\u22121) \u2212 (1\u2212 \u03b8)x(t\u22121) ) + m\n2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162 + \u03b8m 2\u03bb \u2016\u03b1\u0304(t)\u20162\n+ \u2211 i\u2208I [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))]\u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 ] + n\n2\u03bb\n[ \u2016\u03b1\u0304(t)\u20162 \u2212 \u2016\u03b1\u0304(t\u22121)\u20162 ] + m\u03b8\nn \u2211 i \u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162\n= a (t) I + b (t) I + c (t) I .\nLemma 4. At each round t, let a(t)I , b (t) I , c (t) I be as defined in Lemma 3. Then,\nEt[a (t) I + b (t) I + c (t) I ] \u2264 0 .\nProof. Recall,\na (t) I =\nm 2\u03b3 \u2016x(t) \u2212 u(t\u22121)\u20162 \u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 \u2211 i\u2208I \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 ,\nb (t) I = \u03b8mf(u\n(t\u22121)) + m\u03b8\nn n\u2211 i=1 \u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) +m\u2207f(u (t\u22121))>(\u2212\u03b8u(t\u22121))\n+ \u2211 i\u2208I [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))] ] ,\nc (t) I = m\u2207f(u (t\u22121))>(x(t) \u2212 (1\u2212 \u03b8)x(t\u22121)) + n+m\u03b8 2\u03bb \u2016\u03b1\u0304(t)\u20162 \u2212 n\u2212m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162 .\nStep 1: We first show that Et[b (t) I ] = 0. Indeed,\nEt [\u2211 i\u2208I [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))] ]]\n= Et [ n\u2211 i=1 1[i \u2208 I] [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))] ]]\n= n\u2211 i=1 [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))] ] Et [1[i \u2208 I]]\n= m\nn n\u2211 i=1 [ \u2212\u03b8\u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) + \u03b8[\u2207\u03c6i(u (t\u22121))>u(t\u22121) \u2212 \u03c6i(u(t\u22121))] ]\n= \u2212 [ \u03b8mf(u(t\u22121)) + m\u03b8\nn n\u2211 i=1 \u03c6\u2217i (\u2212\u03b1 (t\u22121) i ) +m\u2207f(u (t\u22121))>(\u2212\u03b8u(t\u22121))\n] .\nStep 2: We next show that\nEt[c (t) I ] =\nn+m\u03b8 2\u03bb Et [ \u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 ] \u2212 n\u2212m\u03b8 2\u03bb \u2225\u2225\u2225Et\u2206\u03b1\u0304(t)\u2225\u2225\u22252 . Indeed, using Lemma 1 we know that\n\u2207f(u(t\u22121)) = \u2212\u03b1\u0304(t\u22121) \u2212 n \u03b8m Et[\u2206\u03b1\u0304(t)] ,\nand by the definition of the update,\nx(t) \u2212 (1\u2212 \u03b8)x(t\u22121) = \u03b8 \u03bb \u03b1\u0304(t) .\nTherefore,\nEtc (t) I = m\u2207f(u (t\u22121))>Et[x(t) \u2212 (1\u2212 \u03b8)x(t\u22121)] + n+m\u03b8\n2\u03bb Et\u2016\u03b1\u0304(t)\u20162 \u2212 n\u2212m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162\n= \u2212m [ \u03b1\u0304(t\u22121) + n\n\u03b8m Et[\u2206\u03b1\u0304(t)] ]> [ \u03b8 \u03bb Et\u03b1\u0304(t) ] + n+m\u03b8 2\u03bb Et\u2016\u03b1\u0304(t)\u20162 \u2212 n\u2212m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162\n= \u2212m [ \u03b1\u0304(t\u22121) + n\n\u03b8m Et[\u2206\u03b1\u0304(t)] ]> [ \u03b8 \u03bb [Et\u2206\u03b1\u0304(t) + \u03b1\u0304(t\u22121)] ]\n+ n+m\u03b8\n2\u03bb Et\u2016\u2206\u03b1\u0304(t) + \u03b1\u0304(t\u22121)\u20162 \u2212 n\u2212m\u03b8 2\u03bb \u2016\u03b1\u0304(t\u22121)\u20162\n= \u2212n \u03bb \u2016Et\u2206\u03b1\u0304(t)\u20162 + n+m\u03b8 2\u03bb Et\u2016\u2206\u03b1\u0304(t)\u20162 = n+m\u03b8\n2\u03bb\n[ Et\u2016\u2206\u03b1\u0304(t)\u20162 \u2212 \u2016Et\u2206\u03b1\u0304(t)\u20162 ] \u2212 n\u2212m\u03b8\n2\u03bb \u2016Et\u2206\u03b1\u0304(t)\u20162\n= n+m\u03b8 2\u03bb Et [ \u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 ] \u2212 n\u2212m\u03b8 2\u03bb \u2016Et\u2206\u03b1\u0304(t)\u20162 .\nStep 3: Next, we upper bound Et[a (t) I ].\nUsing the definitions of x(t) and u(t\u22121) and the smoothness of g\u2217 we have\n\u2016x(t) \u2212 u(t\u22121)\u2016 = \u03b8\u2016\u2207g\u2217(\u03b1\u0304(t))\u2212\u2207g\u2217(\u03b1\u0304(t\u22121))\u2016 = \u03b8 \u03bb \u2016\u03b1\u0304(t) \u2212 \u03b1\u0304(t\u22121)\u2016 .\nTherefore,\na (t) I =\nm\u03b82 2\u03b3\u03bb2 \u2016\u2206\u03b1\u0304(t)\u20162 \u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 \u2211 i\u2208I \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 .\nTaking expectation we obtain\nEta (t) I =\nm\u03b82 2\u03b3\u03bb2 Et\u2016\u2206\u03b1\u0304(t)\u20162 \u2212 \u03b8(1\u2212 \u03b8)\u03b3 2 n\u2211 i=1 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162 Et[1[i \u2208 I]]\n= m\u03b82\n2\u03b3\u03bb2 Et\u2016\u2206\u03b1\u0304(t)\u20162 \u2212 \u03b8(1\u2212 \u03b8)\u03b3m 2n n\u2211 i=1 \u2016\u03b1(t\u22121)i +\u2207\u03c6i(u (t\u22121))\u20162\n\u2264 m\u03b8 2\n2\u03b3\u03bb2 Et\u2016\u2206\u03b1\u0304(t)\u20162 \u2212 \u03b8(1\u2212 \u03b8)\u03b3m 2n \u00b7 n 3 m\u03b82 Et\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 ,\nwhere the last inequality follows from Lemma 2. Using the equality\nEt\u2016\u2206\u03b1\u0304(t)\u20162 = Et\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 + \u2016Et\u2206\u03b1\u0304(t)\u20162\nwe obtain that\nEta (t) I \u2264\nm\u03b82 2\u03b3\u03bb2 \u2016Et\u2206\u03b1\u0304(t)\u20162 \u2212\n( (1\u2212 \u03b8)\u03b3n2\n2\u03b8 \u2212 m\u03b8\n2\n2\u03b3\u03bb2\n) Et\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 .\nStep 4: To conclude the proof, we combine the bounds derived in the three steps above and get that\nEt[a (t) I + b (t) I + c (t) I ] \u2264(\nm\u03b82 2\u03b3\u03bb2 \u2212 n\u2212m\u03b8 2\u03bb\n) \u2016Et\u2206\u03b1\u0304(t)\u20162 + ( m\u03b82\n2\u03b3\u03bb2 + n+m\u03b8 2\u03bb \u2212 (1\u2212 \u03b8)\u03b3n 2 2\u03b8\n) Et\u2016\u2206\u03b1\u0304(t) \u2212 Et\u2206\u03b1\u0304(t)\u20162 .\nA sufficient condition for the above to be non-positive is that\n1. m\u03b82 +m\u03b8\u03b3\u03bb\u2212 \u03b3\u03bbn \u2264 0 2. m\u03b83 + \u03b3\u03bb\u03b8(n+m\u03b8)\u2212 (1\u2212 \u03b8)(\u03b3\u03bbn)2 \u2264 0\nLet us require the stronger conditions 1.1 m\u03b82 \u2212 \u03b3\u03bbn/2 \u2264 0\u21d2 \u03b8 \u2264 \u221a 0.5 \u03b3\u03bbn/(m)\n1.2 m\u03b8\u03b3\u03bb\u2212 \u03b3\u03bbn/2 \u2264 0\u21d2 \u03b8 \u2264 0.5 (n/m) 2.1 m\u03b83 \u2212 (\u03b3\u03bbn)2/4 \u2264 0\u21d2 \u03b8 \u2264 ( (\u03b3\u03bbn)2\n4m )1/3 2.2 \u03b3\u03bb\u03b8n\u2212 (\u03b3\u03bbn)2/4 \u2264 0\u21d2 \u03b8 \u2264 \u03b3\u03bbn/4\n2.3 \u03b3\u03bb\u03b82m\u2212 (\u03b3\u03bbn)2/4 \u2264 0\u21d2 \u03b8 \u2264 \u03b3\u03bbn/2\u221a \u03b3\u03bbm = 0.5\n\u221a \u03b3\u03bbn \u00b7 n\nm\n2.4 \u03b8(\u03b3\u03bbn)2 \u2212 (\u03b3\u03bbn)2/4 \u2264 0\u21d2 \u03b8 \u2264 1/4\nAn even strong condition is\n\u03b8 \u2264 1 4 min\n{ 1 , \u221a \u03b3\u03bbn\nm , \u03b3\u03bbn ,\n(\u03b3\u03bbn)2/3\nm1/3\n} . (10)\nProof of Theorem 1. Combining Lemma 3 and Lemma 4 yields\nEt [ m\u2206P (x(t)) + n\u2206D(\u03b1(t)) ] \u2264 (\n1\u2212 \u03b8m n\n) Et [ m\u2206P (x(t\u22121)) + n\u2206D(\u03b1(t\u22121)) ] .\nTaking expectation with respect to the randomness in previous rounds, using the law of total probability, and applying the above inequality recursively, we conclude our proof."}, {"heading": "6 Discussion and Related Work", "text": "We have introduced an accelerated version of stochastic dual coordinate ascent with mini-batches. We have shown, both theoretically and empirically, that the resulting algorithm interpolates between the vanilla stochastic coordinate descent algorithm and the accelerated gradient descent algorithm.\nUsing mini-batches in stochastic learning has received a lot of attention in recent years. E.g. ShalevShwartz et al. [2007] reported experiments showing that applying small mini-batches in Stochastic Gradient Descent (SGD) decreases the required number of iterations. Dekel et al. [2012] and Agarwal and Duchi [2012] gave an analysis of SGD with mini-batches for smooth loss functions. Cotter et al. [2011] studied SGD and accelerated versions of SGD with mini-batches and Tak\u00e1c et al. [2013] studied SDCA with minibatches for SVMs. Duchi et al. [2010] studied dual averaging in distributed networks as a function of spectral properties of the underlying graph. However, all of these methods have a polynomial dependence on 1/ , while we consider the strongly convex and smooth case in which a log(1/ ) rate is achievable.2\nIt is interesting to note that most3 of these papers focus on mini-batches as the method of choice for distributing SGD or SDCA, while ignoring the option to divide the data by features instead of by examples. A possible reason is the cost of opening communication sockets as discussed in Section 3.\nThere are various practical considerations that one should take into account when designing a practical system for distributed optimization. We refer the reader, for example, to Dekel [2010], Low et al. [2010, 2012], Agarwal et al. [2011], Niu et al. [2011].\nThe more general problem of distributed PAC learning has been studied recently in Daume III et al. [2012], Balcan et al. [2012]. See also Long and Servedio [2011]. In particular, they obtain algorithm with O(log(1/ )) communication complexity. However, these works consider efficient algorithms only in the realizable case."}], "references": [{"title": "A reliable effective terascale linear learning system", "author": ["Alekh Agarwal", "Olivier Chapelle", "Miroslav Dud\u00edk", "John Langford"], "venue": "arXiv preprint arXiv:1110.4198,", "citeRegEx": "Agarwal et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Agarwal et al\\.", "year": 2011}, {"title": "Distributed learning, communication complexity and privacy", "author": ["Maria-Florina Balcan", "Avrim Blum", "Shai Fine", "Yishay Mansour"], "venue": "arXiv preprint arXiv:1204.3514,", "citeRegEx": "Balcan et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Balcan et al\\.", "year": 2012}, {"title": "Parallel coordinate descent for l1regularized loss minimization", "author": ["Joseph K Bradley", "Aapo Kyrola", "Danny Bickson", "Carlos Guestrin"], "venue": "In ICML,", "citeRegEx": "Bradley et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bradley et al\\.", "year": 2011}, {"title": "Better mini-batch algorithms via accelerated gradient methods", "author": ["Andrew Cotter", "Ohad Shamir", "Nathan Srebro", "Karthik Sridharan"], "venue": "arXiv preprint arXiv:1106.4574,", "citeRegEx": "Cotter et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Cotter et al\\.", "year": 2011}, {"title": "Protocols for learning classifiers on distributed data", "author": ["Hal Daume III", "Jeff M Phillips", "Avishek Saha", "Suresh Venkatasubramanian"], "venue": "arXiv preprint arXiv:1202.6078,", "citeRegEx": "III et al\\.,? \\Q2012\\E", "shortCiteRegEx": "III et al\\.", "year": 2012}, {"title": "Distribution-calibrated hierarchical classification", "author": ["Ofer Dekel"], "venue": "In NIPS,", "citeRegEx": "Dekel.,? \\Q2010\\E", "shortCiteRegEx": "Dekel.", "year": 2010}, {"title": "Optimal distributed online prediction using mini-batches", "author": ["Ofer Dekel", "Ran Gilad-Bachrach", "Ohad Shamir", "Lin Xiao"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Dekel et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dekel et al\\.", "year": 2012}, {"title": "Distributed dual averaging in networks", "author": ["John Duchi", "Alekh Agarwal", "Martin J Wainwright"], "venue": "Advances in Neural Information Processing Systems,", "citeRegEx": "Duchi et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2010}, {"title": "A Stochastic Gradient Method with an Exponential Convergence Rate for Strongly-Convex Optimization with Finite Training Sets", "author": ["Nicolas Le Roux", "Mark Schmidt", "Francis Bach"], "venue": "arXiv preprint arXiv:1202.6258,", "citeRegEx": "Roux et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Roux et al\\.", "year": 2012}, {"title": "Algorithms and hardness results for parallel large margin learning", "author": ["Phil Long", "Rocco Servedio"], "venue": "In NIPS,", "citeRegEx": "Long and Servedio.,? \\Q2011\\E", "shortCiteRegEx": "Long and Servedio.", "year": 2011}, {"title": "Graphlab: A new framework for parallel machine learning", "author": ["Yucheng Low", "Joseph Gonzalez", "Aapo Kyrola", "Danny Bickson", "Carlos Guestrin", "Joseph M Hellerstein"], "venue": "arXiv preprint arXiv:1006.4990,", "citeRegEx": "Low et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Low et al\\.", "year": 2010}, {"title": "Distributed graphlab: A framework for machine learning and data mining in the cloud", "author": ["Yucheng Low", "Danny Bickson", "Joseph Gonzalez", "Carlos Guestrin", "Aapo Kyrola", "Joseph M Hellerstein"], "venue": "Proceedings of the VLDB Endowment,", "citeRegEx": "Low et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Low et al\\.", "year": 2012}, {"title": "Smooth minimization of non-smooth functions", "author": ["Yurii Nesterov"], "venue": "Mathematical Programming,", "citeRegEx": "Nesterov.,? \\Q2005\\E", "shortCiteRegEx": "Nesterov.", "year": 2005}, {"title": "Gradient methods for minimizing composite objective function", "author": ["Yurii Nesterov"], "venue": null, "citeRegEx": "Nesterov.,? \\Q2007\\E", "shortCiteRegEx": "Nesterov.", "year": 2007}, {"title": "Hogwild!: A lock-free approach to parallelizing stochastic gradient descent", "author": ["Feng Niu", "Benjamin Recht", "Christopher R\u00e9", "Stephen J Wright"], "venue": "arXiv preprint arXiv:1106.5730,", "citeRegEx": "Niu et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Niu et al\\.", "year": 2011}, {"title": "Parallel coordinate descent methods for big data optimization", "author": ["Peter Richt\u00e1rik", "Martin Tak\u00e1\u010d"], "venue": "arXiv preprint arXiv:1212.0873,", "citeRegEx": "Richt\u00e1rik and Tak\u00e1\u010d.,? \\Q2012\\E", "shortCiteRegEx": "Richt\u00e1rik and Tak\u00e1\u010d.", "year": 2012}, {"title": "Pegasos: Primal Estimated sub-GrAdient SOlver for SVM", "author": ["S. Shalev-Shwartz", "Y. Singer", "N. Srebro"], "venue": "In INTERNATIONAL CONFERENCE ON MACHINE LEARNING,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2007}, {"title": "Mini-batch primal and dual methods", "author": ["Martin Tak\u00e1c", "Avleen Bijral", "Peter Richt\u00e1rik", "Nathan Srebro"], "venue": "mization. Journal of Machine Learning Research,", "citeRegEx": "Tak\u00e1c et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Tak\u00e1c et al\\.", "year": 2013}], "referenceMentions": [{"referenceID": 12, "context": "We discuss an implementation of our method over a parallel computing system, and compare the results to both the vanilla stochastic dual coordinate ascent and to the accelerated deterministic gradient descent method of Nesterov [2007].", "startOffset": 219, "endOffset": 235}, {"referenceID": 12, "context": "In particular, Nesterov [2007] proposed an accelerated gradient descent (AGD) method for solving (1).", "startOffset": 15, "endOffset": 31}, {"referenceID": 5, "context": ", Dekel et al. [2012]).", "startOffset": 2, "endOffset": 22}, {"referenceID": 5, "context": ", Dekel et al. [2012]). This is also the application scenario we have in mind, and will be discussed in greater details in Section 3. Recently, Tak\u00e1c et al. [2013] studied mini-batch variants of SDCA in the context of the Support Vector Machine (SVM) problem.", "startOffset": 2, "endOffset": 164}, {"referenceID": 5, "context": ", Dekel et al. [2012]). This is also the application scenario we have in mind, and will be discussed in greater details in Section 3. Recently, Tak\u00e1c et al. [2013] studied mini-batch variants of SDCA in the context of the Support Vector Machine (SVM) problem. They have shown that the naive mini-batching method, in whichm dual variables are optimized in parallel, might actually increase the number of iterations required. They then describe several \u201csafe\u201d mini-batching schemes, and based on the analysis of Shalev-Shwartz and Zhang [2013], have shown several speed-up results.", "startOffset": 2, "endOffset": 542}, {"referenceID": 5, "context": ", Dekel et al. [2012]). This is also the application scenario we have in mind, and will be discussed in greater details in Section 3. Recently, Tak\u00e1c et al. [2013] studied mini-batch variants of SDCA in the context of the Support Vector Machine (SVM) problem. They have shown that the naive mini-batching method, in whichm dual variables are optimized in parallel, might actually increase the number of iterations required. They then describe several \u201csafe\u201d mini-batching schemes, and based on the analysis of Shalev-Shwartz and Zhang [2013], have shown several speed-up results. However, their results are for the non-smooth case and hence they do not obtain linear convergence rate. In addition, the speed-up they obtain requires some spectral properties of the training examples. We take a different approach and employ Nesterov\u2019s acceleration method, which has previously been applied to mini-batch SGD optimization. This paper shows how to achieve acceleration for SDCA in the mini-batch setting. The pseudo code of our Accelerated Mini-Batch SDCA, abbreviated by ASDCA, is presented below. An exception is the recent analysis given in Le Roux et al. [2012] for a variant of SGD.", "startOffset": 2, "endOffset": 1163}, {"referenceID": 12, "context": "Table 1 summarizes several interesting cases, and compares the iteration bound of ASDCA to the iteration bound of the vanilla SDCA algorithm (as analyzed in Shalev-Shwartz and Zhang [2013]) and the Accelerated Gradient Descent (AGD) algorithm of Nesterov [2007]. In the table, we ignore constants and logarithmic factors.", "startOffset": 246, "endOffset": 262}, {"referenceID": 0, "context": "In the calculations below, we use the following facts: \u2022 If each node holds a d-dimensional vector, we can compute the sum of these vectors in timeO(d log(s)) by applying a \u201ctree-structure\u201d summation (see for example the All-Reduce architecture in Agarwal et al. [2011]).", "startOffset": 248, "endOffset": 270}, {"referenceID": 1, "context": "Dekel et al. [2012] and Agarwal and Duchi [2012] gave an analysis of SGD with mini-batches for smooth loss functions.", "startOffset": 0, "endOffset": 20}, {"referenceID": 1, "context": "Dekel et al. [2012] and Agarwal and Duchi [2012] gave an analysis of SGD with mini-batches for smooth loss functions.", "startOffset": 0, "endOffset": 49}, {"referenceID": 1, "context": "Cotter et al. [2011] studied SGD and accelerated versions of SGD with mini-batches and Tak\u00e1c et al.", "startOffset": 0, "endOffset": 21}, {"referenceID": 1, "context": "Cotter et al. [2011] studied SGD and accelerated versions of SGD with mini-batches and Tak\u00e1c et al. [2013] studied SDCA with minibatches for SVMs.", "startOffset": 0, "endOffset": 107}, {"referenceID": 1, "context": "Cotter et al. [2011] studied SGD and accelerated versions of SGD with mini-batches and Tak\u00e1c et al. [2013] studied SDCA with minibatches for SVMs. Duchi et al. [2010] studied dual averaging in distributed networks as a function of spectral properties of the underlying graph.", "startOffset": 0, "endOffset": 167}, {"referenceID": 1, "context": "Cotter et al. [2011] studied SGD and accelerated versions of SGD with mini-batches and Tak\u00e1c et al. [2013] studied SDCA with minibatches for SVMs. Duchi et al. [2010] studied dual averaging in distributed networks as a function of spectral properties of the underlying graph. However, all of these methods have a polynomial dependence on 1/ , while we consider the strongly convex and smooth case in which a log(1/ ) rate is achievable.2 It is interesting to note that most3 of these papers focus on mini-batches as the method of choice for distributing SGD or SDCA, while ignoring the option to divide the data by features instead of by examples. A possible reason is the cost of opening communication sockets as discussed in Section 3. There are various practical considerations that one should take into account when designing a practical system for distributed optimization. We refer the reader, for example, to Dekel [2010], Low et al.", "startOffset": 0, "endOffset": 929}, {"referenceID": 0, "context": "[2010, 2012], Agarwal et al. [2011], Niu et al.", "startOffset": 14, "endOffset": 36}, {"referenceID": 0, "context": "[2010, 2012], Agarwal et al. [2011], Niu et al. [2011]. The more general problem of distributed PAC learning has been studied recently in Daume III et al.", "startOffset": 14, "endOffset": 55}, {"referenceID": 0, "context": "[2010, 2012], Agarwal et al. [2011], Niu et al. [2011]. The more general problem of distributed PAC learning has been studied recently in Daume III et al. [2012], Balcan et al.", "startOffset": 14, "endOffset": 162}, {"referenceID": 0, "context": "[2010, 2012], Agarwal et al. [2011], Niu et al. [2011]. The more general problem of distributed PAC learning has been studied recently in Daume III et al. [2012], Balcan et al. [2012]. See also Long and Servedio [2011].", "startOffset": 14, "endOffset": 184}, {"referenceID": 0, "context": "[2010, 2012], Agarwal et al. [2011], Niu et al. [2011]. The more general problem of distributed PAC learning has been studied recently in Daume III et al. [2012], Balcan et al. [2012]. See also Long and Servedio [2011]. In particular, they obtain algorithm with O(log(1/ )) communication complexity.", "startOffset": 14, "endOffset": 219}], "year": 2013, "abstractText": "Stochastic dual coordinate ascent (SDCA) is an effective technique for solving regularized loss minimization problems in machine learning. This paper considers an extension of SDCA under the minibatch setting that is often used in practice. Our main contribution is to introduce an accelerated minibatch version of SDCA and prove a fast convergence rate for this method. We discuss an implementation of our method over a parallel computing system, and compare the results to both the vanilla stochastic dual coordinate ascent and to the accelerated deterministic gradient descent method of Nesterov [2007].", "creator": "LaTeX with hyperref package"}}}