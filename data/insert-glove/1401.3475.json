{"id": "1401.3475", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Prime Implicates and Prime Implicants: From Propositional to Modal Logic", "abstract": "Prime implicates janowo and jothi prime nari implicants 24.35 have tarikh proven relevant to mullinahone a number 8-under of shoplifter areas of sucks artificial tiruttani intelligence, most leefbaar notably zits abductive reasoning and forbidden knowledge compilation. The horse-drawn purpose of this contextualized paper camaj is boardgame to examine how trade-unions these interglacial notions stansky might be cytidylyltransferase appropriately 61.13 extended from propositional toker logic frayne to lojze the pelizzoli modal logic K. aipac We tallinna begin parvomay the 1863-64 paper blousy by considering a raswan number 57.64 of potential definitions euro380 of clauses gongyi and terms antiinflammatory for culross K. 45.03 The signa different definitions are 120-meter evaluated pufnstuf with ubaidah respect 52-member to quarterly a set 3-all of clubbing syntactic, coren semantic, and complexity - dismasted theoretic krym properties characteristic abg of the half-mast propositional definition. sequenom We then cosplay compare ghasoub the 272,000 definitions with disbanded respect to centralizes the properties lat of banyat the notions of kronen prime implicates and strine prime implicants marquand that additive they induce. odey While there is no droxford definition that motagua perfectly generalizes cost-sharing the wafangdian propositional agiesta notions, we 3.518 show gotthold that there does exist one definition marcopolo which carbines satisfies many of hechtel the desirable hypergraphs properties of descriptions the propositional demokrasi case. In the swinem\u00fcnde second half of the twra paper, 5.79 we constant-speed consider erixon the goettel computational properties of the 10:22 selected pl\u00e1cido definition. 65.7 To this end, we adlan provide nebb sound yia and complete pagones algorithms for generating and recognizing prime kastav implicates, usme and we armorer show the oribi prime implicate medium-wave recognition task hemophilia to 568,000 be prudentius PSPACE - complete. We barwa also iih prove kukors upper and lower bounds on cab the sachsenlb size cover-dated and av number of emde prime implicates. symbolism While the chemie paper c14 focuses monumentality on the logic update5 K, ayler all batbold of our results photoreceptors hold venugopal equally well for talent multi - kallinikos modal K and for 140s concept hemocyanin expressions formula in icings the description logic kyriakides ALC.", "histories": [["v1", "Wed, 15 Jan 2014 05:31:28 GMT  (516kb)", "http://arxiv.org/abs/1401.3475v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["meghyn bienvenu"], "accepted": false, "id": "1401.3475"}, "pdf": {"name": "1401.3475.pdf", "metadata": {"source": "CRF", "title": "Prime Implicates and Prime Implicants: From Propositional to Modal Logic", "authors": ["Meghyn Bienvenu"], "emails": ["meghyn@informatik.uni-bremen.de"], "sections": [{"heading": "1. Introduction", "text": "Prime implicates and prime implicants are important notions in artificial intelligence. They have given rise to a significant body of work in automated reasoning and have been applied to a number of different sub-areas in AI. Traditionally, these concepts have been studied in the context of propositional logic, but they have also been considered for many-valued (Ramesh & Murray, 1994) and first-order logic (Marquis, 1991a, 1991b). Not much is known, however, about prime implicates and prime implicants in other logics. In particular, no definition of prime implicate or prime implicant has ever been proposed for a modal or description logic, nor has it been shown that no reasonable definition can be provided. Given the increasing interest in modal and description logics as knowledge representation languages, one naturally wonders whether these notions can be suitably generalized to these more expressive logics.\nWe recall that in propositional logic the prime implicates of a formula are defined to be its logically strongest clausal consequences. The restriction to clauses is made in order to reduce redundant elements from a formula\u2019s set of consequences: there is no use in keeping around the consequence a\u2227 b when one already has the consequences a and b. The decision to consider only the logically strongest clausal consequences is motivated by a desire to eliminate irrelevant weaker consequences: if we already have the consequence a, there is\nc\u00a92009 AI Access Foundation. All rights reserved.\nno point in retaining the consequences a \u2228 b or a \u2228 \u00acb. Prime implicates thus provide a complete yet compact representation of the set of logical consequences of a formula. What is particularly nice about this representation is that it makes many computational tasks simpler: satisfiability, tautology, entailment, and equivalence queries and the conditioning and forgetting transformations are all tractable for formulae represented by their prime implicates (Darwiche & Marquis, 2002). This is why prime implicates are considered an interesting target language for knowledge compilation (Cadoli & Donini, 1997; Darwiche & Marquis, 2002). Prime implicates have also proved relevant to other sub-areas of AI, like distributed reasoning (Adjiman, Chatalic, Goasdoue\u0301, Rousset, & Simon, 2006), belief revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf. Przymusinski, 1989), and characterizations of relevance (Lakemeyer, 1995; Lang, Liberatore, & Marquis, 2003).\nThe dual notion to prime implicates is prime implicants, which are defined to be the logically weakest terms (= conjunctions of literals) which imply a given formula. The main application domain for prime implicants is in abduction and diagnosis. We recall that in abduction, one is given a background theory and an observation, and the objective is to find an explanation for the observation. In logical terms, an explanation is a formula which logically entails the observation when taken together with the background theory. As the set of explanations for an abduction problem can be very large, an important question is how to select a representative subset of explanations. One very common approach is to use prime implicants: the relevant explanations for an observation o with respect to a background theory t are taken to be the prime implicants of t \u2192 o (de Kleer, Mackworth, & Reiter, 1992; Eiter & Makino, 2002).\nFor many applications in AI, the expressive power of propositional logic proves insufficient. First-order logic provides a much greater level of expressivity, but at the price of undecidability. Modal and description logics offer an interesting trade-off between expressivity and complexity, as they are generally more expressive than propositional logic yet are better-behaved computationally than first-order logic. This explains the growing trend towards using such languages for knowledge representation.\nA prototypical description logic isALC, which extends propositional logic with restricted forms of universal and existential quantification. An example expression in ALC is\nFemale \u2293 \u2203hasChild.Female \u2293 \u2200hasChild.(Doctor \u2294 Professor)\u2293 \u2203hasPet.Dog\nwhich describes the set of individuals who are female, have at least one daughter and one pet dog, and are such that all of their children are either doctors or professors. The above concept expression can be represented equally well in the modal logic K2 by the formula:\nFemale \u2227 31Female \u2227 21(Doctor \u2228 Professor)\u2227 32Dog\nSchild (1991) proved a general result which showed that the description logic ALC with n binary relations is in fact a notational variant of the multi-modal logic Kn. This means that results concerning Kn can be transferred to ALC, and vice-versa.\nIn this paper, we investigate the notions of prime implicates and prime implicants for the modal logic K = K1, but actually all of our results hold for formulae in Kn, and hence also for concept expressions in ALC. The decision to present our results in terms of K\nrather than in terms of Kn or ALC was motivated solely by a desire to simplify notation and increase the readability of the proofs.\nThe question of how the notions of prime implicates and prime implicants can be suitably defined for the logic K is clearly of interest from a theoretical point of view. We argue, however, that this question is also practically relevant. To support this claim, we briefly discuss two application areas in which the study of prime implicates and prime implicants in K might prove useful.\nThe first domain of application we will consider is abductive reasoning in K. As noted above, one of the key foundational issues in abductive reasoning is the selection of an interesting subset of explanations. This issue is especially crucial for logics like K which allow for an infinite number of non-equivalent formulae, since this means that the number of non-equivalent explanations for an abduction problem is not just large but in fact infinite, making it simply impossible to enumerate the entire set of explanations. As prime implicants are a widely-accepted means of characterizing relevant explanations in propositional logic, a reasonable starting point for research into abductive reasoning in the logic K is the study of different possible definitions of prime implicant in K and their properties.\nThe investigation of prime implicates in K is also relevant to the development of knowledge compilation procedures for K. We recall that knowledge compilation (cf. Darwiche & Marquis, 2002) is a general technique for coping with the intractability of reasoning which consists in an off-line phase in which a knowledge base is rewritten as an equivalent knowledge base which allows for tractable reasoning, followed by an online phase in which reasoning is performed on the compiled knowledge base. The idea is that the initial cost of compiling the knowledge base will be offset by computational savings on later queries. Currently, most work on knowledge compilation is restricted to propositional logic, even though this technique could prove highly relevant for modal and description logics, which generally suffer from an even higher computational complexity than propositional logic. As prime implicates are one of the better-known mechanisms for compiling formulae in propositional logic, it certainly makes sense to investigate whether this approach to knowledge compilation can be fruitfully extended to logics like K.\nOur paper is organized as follows. After some preliminaries, we consider how to appropriately generalize the notions of clauses and terms to K. As there is no obvious definition, we enumerate a list of syntactic, semantic, and complexity-theoretic properties of the propositional definitions, which we then use to compare the different candidate definitions. We next consider the different definitions in light of the notions of prime implicate and prime implicant they induce. Once again, we list some basic properties from the propositional case that we would like to satisfy, and we see how the different definitions measure up. In the second half of the paper, we investigate the computational properties of the most satisfactory definition of prime implicates. We consider the problems of prime implicate generation and recognition, and we provide sound and complete algorithms for both tasks. We also study the complexity of the prime implicate recognition problem, showing it to be Pspace-complete and thus of the same complexity as satisfiability and deduction in K. We conclude the paper with a discussion of the relevance of our results to the two application areas cited above and some directions for future research. In order to enhance the readability of the paper, proofs have been omitted from the body of the text. Full proofs can be found in the appendix."}, {"heading": "2. Preliminary Definitions and Notation", "text": "We briefly recall the basics of the modal logic K (refer to Blackburn, de Rijke, & Venema, 2001; Blackburn, van Benthem, & Wolter, 2006, for good introductions to modal logic). Formulae in K are built up from a set of propositional variables V, the standard logical connectives (\u00ac, \u2227, and \u2228), and the modal operators 2 and 3. We will call a formula of the form 2\u03d5 (resp. 3\u03d5) a 2-formula (resp. 3-formula). Where convenient we will use \u03d5 \u2192 \u03c8 as an abbreviation for \u00ac\u03d5\u2228\u03c8. We adopt the shorthand 2k\u03d5 (resp. 3k\u03d5) to refer to the formula consisting of \u03d5 preceded by k copies of 2 (resp. 3), with the convention that 2\n0\u03d5 = 30\u03d5 = \u03d5. We will use var(\u03d5) to refer to the set of propositional variables appearing in a formula \u03d5. The modal depth of a formula \u03d5, written \u03b4(\u03d5), is defined as the maximal number of nested modal operators appearing in \u03d5, e.g. \u03b4(3(a\u22272a)\u2228a) = 2. We define the length of a formula \u03d5, written |\u03d5|, to be the number of occurrences of propositional variables, logical connectives, and modal operators in \u03d5. For example, we would have |(a \u2227 \u00acb)| = 4 and |3(a \u2228 b) \u2227 2\u00aca| = 8.\nNegation normal form (NNF) is defined just as in propositional logic: a formula is said to be in NNF if negation only appears directly before propositional variables. Every formula \u03d5 in K can be transformed into an equivalent formula in NNF using the recursive procedure Nnf defined as follows:\nNnf(l)=l (for propositional literals l) Nnf(2\u03c8)=2Nnf(\u03c8) Nnf(\u03c81 \u2227 \u03c82)=Nnf(\u03c81)\u2227Nnf(\u03c82) Nnf(\u00ac2\u03c8)=3Nnf(\u00ac\u03c8) Nnf(\u00ac(\u03c81 \u2227 \u03c82))=Nnf(\u00ac\u03c81)\u2228Nnf(\u00ac\u03c82) Nnf(3\u03c8)=3Nnf(\u03c8) Nnf(\u03c81 \u2228 \u03c82)=Nnf(\u03c81)\u2228Nnf(\u03c82) Nnf(\u00ac3\u03c8)=2Nnf(\u00ac\u03c8) Nnf(\u00ac(\u03c81 \u2228 \u03c82))=Nnf(\u00ac\u03c81)\u2227Nnf(\u00ac\u03c82) Nnf(\u00ac\u00ac\u03c8)=Nnf(\u03c8)\nFor example, applying Nnf to the formula \u00ac2(a\u22273(\u00acb\u2228 c)) results in the formula 3(\u00aca\u2228 2(b\u2227\u00acc)) which is in NNF. The transformation Nnf takes linear time, and yields a formula which is no more than double the size of the original formula and has the same modal depth and propositional variables as the original.\nA model for K is a tuple M = \u3008W,R, v\u3009, where W is a non-empty set of possible worlds, R \u2286 W \u00d7W is a binary relation over worlds, and v : W \u00d7V \u2192 {true, false} is a valuation of the propositional variables at each world. Models can be understood as labelled directed graphs, in which the vertices correspond to the elements of W, the directed edges represent the binary relation R, and the vertices are labeled by propositional valuations which specify the propositional variables which are true in the corresponding possible world.\nSatisfaction of a formula \u03d5 in a model M at the world w (written M, w |= \u03d5) is defined inductively as follows:\n\u2022 M, w |= a if and only if v(w, a) = true\n\u2022 M, w |= \u00ac\u03d5 if and only if M, w 6|= \u03d5\n\u2022 M, w |= \u03d5 \u2227 \u03c8 if and only if M, w |= \u03d5 and M, w |= \u03c8\n\u2022 M, w |= \u03d5 \u2228 \u03c8 if and only if M, w |= \u03d5 or M, w |= \u03c8\n\u2022 M, w |= 2\u03d5 if and only if M, w\u2032 |= \u03d5 for all w\u2032 such that wRw\u2032\n\u2022 M, w |= 3\u03d5 if and only if M, w\u2032 |= \u03d5 for some w\u2032 such that wRw\u2032\nIf we think of models as labeled directed graphs, then determining the satisfaction of a formula 2\u03d5 at vertex w consists in evaluating \u03d5 at all of the vertices which can be reached from w via an edge; 2\u03d5 is satisfied at w just in the case that \u03d5 holds in each of these successor vertices. Similarly, in order to decide whether a formula 3\u03d5 holds at a vertex w, we consider each of the successors of w in the graph and check whether at least one of these vertices satisfies \u03d5.\nA formula \u03d5 is said to be a tautology, written |= \u03d5, if M, w |= \u03d5 for every model M and world w. A formula \u03d5 is satisfiable if there is some model M and some world w such that M, w |= \u03d5. If there is no M and w for which M, w |= \u03d5, then \u03d5 is called unsatisfiable, and we write \u03d5 |= \u22a5.\nLadner (1977) showed that satisfiability and unsatisfiability in K are Pspace-complete. For Pspace membership, Ladner exhibited a polynomial space tableaux-style algorithm for deciding satisfiability of K formulae. Pspace-hardness was proven by means of a reduction from QBF validity (the canonical Pspace-complete problem).\nIn modal logic, the notion of logical consequence (or entailment) can be defined in one of two ways:\n\u2022 a formula \u03c8 is a global consequence of \u03d5 if whenever M, w |= \u03d5 for every world w of a model M, then M, w |= \u03c8 for every world w of M\n\u2022 a formula \u03c8 is a local consequence of \u03d5 if M, w |= \u03d5 implies M, w |= \u03c8 for every model M and world w\nIn this paper, we will only consider the notion of local consequence, and we will take \u03d5 |= \u03c8 to mean that \u03c8 is a local consequence of \u03d5. When \u03d5 |= \u03c8, we will say that \u03d5 entails \u03c8. Two formulae \u03d5 and \u03c8 will be called equivalent, written \u03d5 \u2261 \u03c8, if both \u03d5 |= \u03c8 and \u03c8 |= \u03d5. A formula \u03d5 is said to be logically stronger than \u03c8 if \u03d5 |= \u03c8 and \u03c8 6|= \u03d5.\nWe now highlight some basic properties of logical consequence and equivalence in K which will play an important role in the proofs of our results.\nTheorem 1. Let \u03c8, \u03c81, ..., \u03c8m, \u03c7, \u03c71, ..., \u03c7n be formulae in K, and let \u03b3 be a propositional formula. Then\n1. \u03c8 |= \u03c7 \u21d4|= \u00ac\u03c8 \u2228 \u03c7 \u21d4 \u03c8 \u2227 \u00ac\u03c7 |= \u22a5\n2. \u03c8 |= \u03c7 \u21d4 3\u03c8 |= 3\u03c7 \u21d4 2\u03c8 |= 2\u03c7\n3. \u03b3\u22273\u03c81\u2227...\u22273\u03c8m\u22272\u03c71\u2227...\u22272\u03c7n |= \u22a5 \u21d4 (\u03b3 |= \u22a5 or \u03c8i\u2227\u03c71\u2227...\u2227\u03c7n |= \u22a5 for some i)\n4. |= \u03b3 \u22283\u03c81 \u2228 ... \u22283\u03c8m \u22282\u03c71 \u2228 ... \u2228 2\u03c7n \u21d4 (|= \u03b3 or |= \u03c81 \u2228 ... \u2228 \u03c8m \u2228 \u03c7i for some i)\n5. 2\u03c7 |= 2\u03c71 \u2228 ... \u2228 2\u03c7n \u21d4 \u03c7 |= \u03c7i for some i\n6. 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2\u03c71 \u2228 ... \u2228 2\u03c7n \u2261 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m)\nStatement 1 of Theorem 1 shows how the three reasoning tasks of entailment, unsatisfiability, and tautology-testing can be rephrased in terms of one another. Statement 2 tells us how entailment between two 2- or 3-formulae can be reduced to entailment between those formulae with the first modality removed. Statements 3 and 4 define the conditions under which a conjunction (resp. disjunction) of propositional literals and 2- and 3-formulae is unsatisfiable (resp. a tautology). Statement 5 gives us the conditions under which a 2-formula implies a disjunction of 2-formulae. Statement 6 demonstrates the interaction between 2- and 3-formulae in a disjunction.\nTheorem 2. Let \u03bb be a disjunction of propositional literals and 2- and 3-formulae. Then each of the following statements holds:\n1. If \u03bb |= \u03b3 for some non-tautological propositional clause \u03b3, then every disjunct of \u03bb is either a propositional literal or an unsatisfiable 3-formula\n2. If \u03bb |= 3\u03c81 \u2228 ... \u2228 3\u03c8n, then every disjunct of \u03bb is a 3-formula\n3. If \u03bb |= 2\u03c71 \u2228 ... \u2228 2\u03c7n and 6|= 2\u03c71 \u2228 ... \u2228 2\u03c7n, then every disjunct of \u03bb is either a 2-formula or an unsatisfiable 3-formula\nTheorem 3. Let \u03bb = \u03b3 \u22283\u03c81 \u2228 ...\u22283\u03c8m \u22282\u03c71 \u2228 ...\u22282\u03c7n and \u03bb \u2032 = \u03b3\u2032 \u22283\u03c8\u20321 \u2228 ...\u22283\u03c8 \u2032 p \u2228 2\u03c7\u20321 \u2228 ... \u2228 2\u03c7 \u2032 q be formulae in K. If \u03b3 and \u03b3 \u2032 are both propositional and 6|= \u03bb\u2032, then\n\u03bb |= \u03bb\u2032 \u21d4\n \n\n\u03b3 |= \u03b3\u2032 and \u03c81 \u2228 ... \u2228 \u03c8m |= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p and for every \u03c7i there is some \u03c7 \u2032 j such that \u03c7i |= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u03c7 \u2032 j\nTheorems 2 and 3 concern entailment relations between formulae which are disjunctions of propositional literals and 2- and 3-formulae. Theorem 2 tells us what kinds of formulae of this type can entail a propositional clause, a disjunction of 3-formulae, or a disjunction of 2-formulae, while Theorem 3 outlines the conditions under which two formulae of this type can be related to each other by the entailment relation. We illustrate Theorem 3 on a small example.\nExample 4. Consider the formula \u03bb = \u00acb \u2228 3(a \u2227 3c) \u2228 3(d \u2227 2a) \u2228 2(c \u2228 d). Then according to Theorem 3, we have:\n\u2022 \u03bb |= \u00acb\u2228\u00acd\u22283(a\u2228 d)\u22282c, since \u00acb |= \u00acb\u2228\u00acd and (a\u22273c)\u2228 (d\u22272a) |= a\u2228 d and c \u2228 d |= c \u2228 (a \u2228 d)\n\u2022 \u03bb 6|= a \u2228 3c, since \u00acb 6|= a\n\u2022 \u03bb 6|= a \u2228 \u00acb \u2228 3(a \u2227 c), since (a \u2227 3c) \u2228 (d \u2227 2a) 6|= a \u2227 c\n\u2022 \u03bb 6|= \u00acb \u2228 3(a \u2228 2a) \u2228 2c, since c \u2228 d 6|= c \u2228 (a \u2228 2a)"}, {"heading": "3. Literals, Clauses, and Terms in K", "text": "As we have seen in the introduction, the notions of prime implicates and implicants are straightforwardly defined using the notions of clauses and terms. Thus, if we aim to provide suitable definitions of prime implicates and implicants for the logic K, we first need to decide upon a suitable definition of clauses and terms in K. Unfortunately, whereas clauses and terms are standard notions in both propositional and first-order logic1, there is no generally accepted definition of clauses and terms in K. Indeed, several quite different notions of clauses and terms have been proposed in the literature for different purposes.\nInstead of blindly picking a definition and hoping that it is appropriate, we prefer to list a number of characteristics of literals, clauses, and terms in propositional logic, giving us a principled means of comparing different candidate definitions. Each of the properties below describes something of what it is to be a literal, clause, or term in propositional logic. Although our list cannot be considered exhaustive, we do believe that it covers the principal syntactic, semantic, and complexity-theoretic properties of the propositional definition.\nP1 Literals, clauses, and terms are in negation normal form.\nP2 Clauses do not contain \u2227, terms do not contain \u2228, and literals contain neither \u2227 nor \u2228.\nP3 Clauses (resp. terms) are disjunctions (resp. conjunctions) of literals.\nP4 The negation of a literal is equivalent to another literal. Negations of clauses (resp. terms) are equivalent to terms (resp. clauses).\nP5 Every formula is equivalent to a finite conjunction of clauses. Likewise, every formula is equivalent to a finite disjunction of terms.\nP6 The task of deciding whether a given formula is a literal, term, or clause can be accomplished in polynomial-time.\nP7 The task of deciding whether a clause (resp. term) entails another clause (resp. term) can be accomplished in polynomial-time.\nOne may wonder whether there exist definitions of literals, clauses, and terms for K satisfying all of these properties. Unfortunately, we can show this to be impossible.\nTheorem 5. Any definition of literals, clause, and terms for K that satisfies properties P1 and P2 cannot satisfy P5.\nThe proof of Theorem 5 only makes use of the fact that \u2227 does not distribute over 3 and \u2228 does not distribute over 2, which means that our impossibility result holds equally well for most standard modal and description logics.\nWe will now consider a variety of possible definitions and evaluate them with respect to the above criteria. The first definition that we will consider is that proposed by Cialdea\n1. One might wonder why we do not simply translate our formulae in K into first-order formulae and then put them into clausal form. The reason is simple: we are looking to define clauses and terms within the language of K, and the clauses we obtain on passing by first-order logic are generally not expressible in K. Moreover, if we were to define clauses in K as those first-order clauses which are representable in K, we would obtain a set of clauses containing no 3 modalities, thereby losing much of the expressivity of K.\nMayer and Pirri (1995) in a paper on abductive reasoning in modal logic. They define terms to be the formulae which can be constructed from the propositional literals using only \u2227, 2, and 3. Modal clauses and literals are not used in the paper but can be defined analogously, yielding the following definition2:\nL ::= a | \u00aca |2L |3L D1 C ::= a | \u00aca |2C |3C |C \u2228 C\nT ::= a | \u00aca |2T |3T |T \u2227 T\nIt is easy to see by inspection that this definition satisfies properties P1-P2, P4, and P6. Property P3 is not satisfied, however, since there are clauses that are not disjunctions of literals \u2013 take for instance 2(a\u2228 b). From Theorem 5 and the fact that both P1 and P2 are satisfied, we can conclude that property P5 cannot hold. At first glance, it may seem that entailment between clauses or terms could be accomplished in polynomial time, but this is not the case. In fact, we can show this problem to be NP-complete. The proof relies on the very strong resemblance between terms of D1 and concept expressions in the description logic ALE (for which both unsatisfiability and deduction are known to be NP-complete).\nBy using a slightly different definition, we can gain P3:\nL ::= a | \u00aca |2L |3L D2 C ::= L |C \u2228 C\nT ::= L |T \u2227 T\nIt can be easily verified that definition D2 satisfies properties P1-P4 and P6. As definition D1 does not satisfy P5, and definitionD2 is even less expressive, it follows thatD2 does not satisfy P5 either. This reduced expressiveness does not however improve its computational complexity: property P7 is still not satisfied as we can show that entailment between clauses or terms is NP-complete using the same reduction as was used for definition D1. The fact that even an extremely inexpressive definition likeD2 does not allow for polynomial entailment between clauses and terms suggests that property P7 cannot be satisfied by any reasonable definition of clauses and terms for K.\nLet us now consider some more expressive options. We begin with the following definition of clauses that was proposed by Enjalbert and Farin\u0303as del Cerro (1989) for the purpose of modal resolution:\nD3 C ::= a | \u00aca |2C |3ConjC |C \u2228C ConjC ::= C |ConjC \u2227ConjC\nThis definition of clauses can be extended to a definition of terms and literals which satisfies P3 or P4, but there is no extension which satisfies both properties. Let us first consider one of the possible extensions which satisfies P4 and a maximal subset of P1-P7:\nL ::= a | \u00aca |2L |3L D3a C ::= a | \u00aca |2C |3ConjC |C \u2228 C\nConjC ::= C |ConjC \u2227 ConjC T ::= a | \u00aca |2DisjT |3T |T \u2227 T DisjT ::= T |DisjT \u2228DisjT\n2. Note that here and in what follows, we let a range over propositional variables and L, C, and T range over the sets of literals, clauses, and terms, respectively.\nThis definition satisfies P1 and P4-P6 (satisfaction of P5 was shown in Enjalbert & Farin\u0303as del Cerro, 1989). It does not satisfy P3 as there are clauses that are not disjunctions of literals \u2013 take for example 2(a \u2228 b). Given that definition D3a is strictly more expressive than definitions D1 and D2, it follows that entailment between clauses or terms must be NP-hard, which means that D3a does not satisfy P7. In fact, we can show that entailment between clauses or terms of definition D3a is Pspace-complete. To do so, we modify the polynomial translation of QBF into K used to prove Pspace-hardness of K so that the translated formula is a conjunction of clauses with respect to D3a. We then notice that a formula \u03d5 is unsatisfiable if and only if 3\u03d5 entails 3(a \u2227 \u00aca). We thus reduce QBF validity to entailment between clauses, making this task Pspace-hard, and hence (being a subproblem of entailment in K) Pspace-complete. This same idea is used to show Pspacecompleteness for definitions D3b and D5 below.\nIf instead we extend D3 so as to enforce property P3, we obtain the following definition:\nL ::= a | \u00aca |2C |3ConjC D3b C ::= a | \u00aca |2C |3ConjC |C \u2228 C\nConjC ::= C |ConjC \u2227 ConjC T ::= L |T \u2227 T\nThis definition satisfies all of the properties except P2, P4, and P7. Property P4 fails to hold because the negation of the literal 3(a \u2228 b) is not equivalent to any literal. The proof that P5 holds is constructive: we use standard logical equivalences to rewrite formulae as equivalent conjunctions of clauses and disjunctions of terms (this is also what we do for definitions D4 and D5 below).\nWe now consider two rather simple definitions that satisfy properties P3, P4, and P5. The first definition, which is inspired by the notion of modal atom proposed by Giunchiglia and Sebastiani (1996), defines literals as the set of formulae in NNF that cannot be decomposed propositionally.\nL ::= a | \u00aca |2F |3F D4 C ::= L |C \u2228 C\nT ::= L |T \u2227 T F ::= a | \u00aca |F \u2227 F |F \u2228 F |2F |3F\nD4 satisfies all of the properties except P2 and P7. For P7, we note that an arbitrary formula \u03d5 in NNF is unsatisfiable (a Pspace-complete problem) if and only if 3\u03d5 |= 3(a \u2227 \u00aca).\nDefinition D4 is very liberal, imposing no structure on the formulae behind modal operators. If we define literals to be the formulae in NNF that cannot be decomposed modally (instead of propositionally), we obtain a much stricter definition which satisfies exactly the same properties as D4.\nL ::= a | \u00aca |2C |3T D5 C ::= L |C \u2228 C\nT ::= L |T \u2227 T\nA summary of our analysis of the different definitions with respect to properties P1-P7 is provided in the following table.\nTheorem 6. The results in Figure 1 hold.\nClearly deciding between different candidate definitions is more complicated than counting up the number of properties that the definitions satisfy, the simple reason being that some properties are more important than others. Take for instance property P5 which requires clauses and terms to be expressive enough to represent all of the formulae in K. If we just use the standard propositional definition of clauses and terms (thereby disregarding the modal operators), then we find that it satisfies every property except P5, and hence more properties than any of the definitions considered in this section, and yet we would be hard-pressed to find someone who considers the propositional definition an appropriate definition for K. This demonstrates that expressiveness is a particularly important property, so important in fact that we should be willing to sacrifice properties P2 and P7 to keep it. Among the definitions that satisfy P5, we prefer definitions D4 and D5 to definitions D3a and D3b, as the latter definitions have less in common with the propositional definition and present no advantages over D4 and D5.\nOf course, when it comes down to it, the choice of a definition must depend on the particular application in mind. There may very well be circumstances in which a less expressive or less elegant definition may prove to be the most suitable. In this paper we are using clauses and terms to define prime implicates and prime implicants, so for us the most important criteria for choosing a definition will be the quality of the notions of prime implicates and prime implicants that the definition induces."}, {"heading": "4. Prime Implicates/Implicants in K", "text": "Once a definition of clauses and terms has been fixed, we can define prime implicates and prime implicants in exactly the same manner as in propositional logic:\nDefinition 7. A clause \u03bb is an implicate of a formula \u03d5 if and only if \u03d5 |= \u03bb. \u03bb is a prime implicate of \u03d5 if and only if:\n1. \u03bb is an implicate of \u03d5\n2. If \u03bb\u2032 is an implicate of \u03d5 such that \u03bb\u2032 |= \u03bb, then \u03bb |= \u03bb\u2032\nDefinition 8. A term \u03ba is an implicant of the formula \u03d5 if and only if \u03ba |= \u03d5. \u03ba is a prime implicant of \u03d5 if and only if:\n1. \u03ba is an implicant of \u03d5\n2. If \u03ba\u2032 is an implicant of \u03d5 such that \u03ba |= \u03ba\u2032, then \u03ba\u2032 |= \u03ba\nOf course, the notion of prime implicate (resp. implicant) that we get will be determined by the definition of clause (resp. term) that we have chosen. We will compare different definitions using the following well-known properties of prime implicates/implicants in propositional logic:\nFiniteness The number of prime implicates (resp. prime implicants) of a formula is finite modulo logical equivalence.\nCovering Every implicate of a formula is entailed by some prime implicate of the formula. Conversely, every implicant of a formula entails some prime implicant of the formula.\nEquivalence A model M is a model of \u03d5 if and only if M is a model of all the prime implicates of \u03d5 if and only if M is a model of some prime implicant of \u03d53.\nImplicant-Implicate Duality Every prime implicant of a formula is equivalent to the negation of some prime implicate of the negated formula. Conversely, every prime implicate of a formula is equivalent to the negation of a prime implicant of the negated formula.\nDistribution If \u03bb is a prime implicate of \u03d51 \u2228 ... \u2228 \u03d5n, then there exist prime implicates \u03bb1, ..., \u03bbn of \u03d51, ..., \u03d5n such that \u03bb \u2261 \u03bb1 \u2228 ... \u2228 \u03bbn. Likewise, if \u03ba is a prime implicant of \u03d51 \u2227 ... \u2227 \u03d5n, then there exist prime implicants \u03ba1, ..., \u03ban of \u03d51, ..., \u03d5n such that \u03ba \u2261 \u03ba1 \u2227 ... \u2227 \u03ban\nFiniteness ensures that the prime implicates/implicants of a formula can be finitely represented, while Covering means the prime implicates provide a complete representation of the formula\u2019s implicates. Equivalence guarantees that no information is lost in replacing a formula by its prime implicates/implicants, whereas Implicant-Implicate Duality allows us to transfer results and algorithms for prime implicates to prime implicants, and vice-versa. Finally, Distribution relates the prime implicates/implicants of a formula to the prime implicates/implicants of its sub-formulae. This property will play a key role in the prime implicate generation algorithm presented in the next section.\nWe can show that definition D4 satisfies all five properties. For Finiteness and Covering, we first demonstrate that every implicate \u03bb of a formula \u03d5 is entailed by some implicate \u03bb\u2032 of \u03d5 with var(\u03bb\u2032) \u2286 var(\u03d5) and having depth at most \u03b4(\u03d5) + 1 (and similarly for implicants). As there are only finitely many non-equivalent formulae on a finite language and with bounded depth, it follows that there are only finitely many prime implicates/implicants of a given formula, and that there can be no infinite chains of increasingly stronger implicates (or increasingly weaker implicants). Equivalence follows directly from Covering and the property P5 of the previous section: we use P5 to rewrite \u03d5 as a conjunction of clauses, each of which is implied by some prime implicate of \u03d5 because of Covering. The property Implicant-Implicate Duality is an immediate consequence of the duality\n3. The property Equivalence is more commonly taken to mean that a formula is equivalent to the conjunction of its prime implicates and the disjunction of its prime implicants. We have chosen a model-theoretic formulation in order to allow for the possibility that the set of prime implicates/implicants is infinite.\nbetween clauses and terms (P4). Distribution can be shown using Covering plus the fact that a disjunction of clauses is a clause and a conjunction of terms is a term (P3).\nTheorem 9. The notions of prime implicates and prime implicants induced by definition D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality, and Distribution.\nWe remark by way of contrast that in first-order logic the notion of prime implicate induced by the standard definition of clauses has been shown to falsify Finiteness, Covering, and Equivalence (Marquis, 1991a, 1991b).\nWe now show that definition D4 is the only one of our definitions to satisfy all five properties. For definitions D1 and D2, we show that Equivalence does not hold. This is a fairly straightforward consequence of the fact that these definitions do not satisfy property P5.\nTheorem 10. The notions of prime implicates and prime implicants induced by definitions D1 and D2 do not satisfy Equivalence.\nFor the notions of prime implicates induced by definitions D3a, D3b, and D5, we show in the appendix that the clause 23ka \u2228 3(a \u2227 b \u2227 2k\u00aca) is a prime implicate of 2(a \u2227 b) for every k \u2265 14. We thereby demonstrate not only that these definitions admit formulae with infinitely many distinct prime implicates but also that they allow seemingly irrelevant clauses to be counted as prime implicates. This gives us strong grounds for dismissing these definitions as much of the utility of prime implicates in applications comes from their ability to eliminate such irrelevant consequences.\nTheorem 11. The notions of prime implicates and prime implicants induced by D3a, D3b, and D5 falsify Finiteness.\nWhile the comparison in the last section suggested that D5 was at least as suitable as D4 as a definition of clauses and terms, the results of this section rule out D5 as a suitable definition for prime implicates and prime implicants. In the remainder of the paper, we will concentrate our attention on the notions of prime implicates and prime implicants induced by definition D4, as these have been shown to be the most satisfactory generalizations of the propositional case."}, {"heading": "5. Prime Implicate Generation and Recognition", "text": "In this section, we investigate the computational aspects of modal prime implicates. As we will be primarily focusing on the notion of prime implicate induced by definition D4, for the remainder of the paper we will use the words \u201cclause\u201d, \u201cterm\u201d, and \u201cprime implicate\u201d to mean clause, term, and prime implicate with respect to definition D4, except where explicitly stated otherwise.\nWe remark that, without loss of generality, we can restrict our attention to prime implicates since by Implicant-Implicate Duality (Theorem 9) any algorithm for generating or recognizing prime implicates can be easily adapted into an algorithm for generating or recognizing prime implicants.\n4. For D4, the only prime implicate of 2(a \u2227 b) is itself."}, {"heading": "5.1 Generating Prime Implicates", "text": "We start by considering the problem of generating the set of prime implicates of a given formula. This task is important if we want to produce abductive explanations, or if we want to compile a formula into its set of prime implicates.\nFor our generation algorithm, we will require a means of transforming the input formula into an equivalent disjunction of \u201csimpler\u201d formulae. To this end, we introduce in Figure 2 the helper function Dnf-4(\u03d5) which returns a set of satisfiable terms with respect to D4 whose disjunction is equivalent to \u03d5. The function Dnf-4 is defined in terms of another function Iter-Dnf-4 which takes an input a set S of formulae in NNF and returns in an iterative fashion a set of satisfiable terms whose disjunction is equivalent to S. The following lemmas highlight some important properties of these functions.\nLemma 12. Iter-Dnf-4 terminates and requires only polynomial space in the size of its input.\nLemma 13. The output of Dnf-4 on input \u03d5 is a set of satisfiable terms with respect to D4 whose disjunction is equivalent to \u03d5.\nLemma 14. There are at most 2|\u03d5| terms in Dnf-4(\u03d5). Each of the terms has length at most 2|\u03d5|, depth at most \u03b4(\u03d5), and contains only those propositional variables appearing in var(\u03d5).\nWe present in Figure 3 the algorithm GenPI which computes the set of prime implicates of a given formula. Our algorithm works as follows: in Step 1, we check whether \u03d5 is unsatisfiable, outputting a contradictory clause if this is the case. For satisfiable \u03d5, we set T equal to a set of satisfiable terms whose disjunction is equivalent to \u03d5. Because of Distribution, we know that every prime implicate of \u03d5 is equivalent to some disjunction of prime implicates of the terms in T . In Step 2, we set \u2206(T ) equal to the propositional\nliterals in T (LT ) plus the strongest 2-literal implied by T (2\u03b2T ) plus the strongest 3- literals implied by T ({3(\u03b6 \u2227 \u03b2T ) | \u03b6 \u2208 DT }). It is not too hard to see that every prime implicate of T must be equivalent to one of the elements in \u2206(T ). This means that in Step 3 we are guaranteed that every prime implicate of the input formula is equivalent to some candidate prime implicate in Candidates. During the comparison phase in Step 4, non-prime candidates are eliminated, and exactly one prime implicate of each equivalence class will be retained.\nWe illustrate the behavior of GenPI on an example:\nExample 15. We run GenPI on input \u03d5 = a\u2227((3(b\u2227c)\u22273b)\u2228(3b\u22273(c\u2228d)\u22272e\u22272f)).\nStep 1: As \u03d5 is satisfiable, we call the function Dnf-4 on \u03d5, and it returns the two terms T1 = a \u2227 3(b \u2227 c) \u2227 3b and T2 = a \u2227 3b \u2227 3(c \u2228 d) \u2227 2e \u2227 2f .\nStep 2: We have LT1 = {a}, DT1 = {b \u2227 c, b}, and there are no 2-literals in T1, so we get \u2206(T1) = {a,3(b \u2227 c),3b}. For T2, we have LT2 = {a}, DT2 = {b, c \u2228 d}, and \u03b2T2 = e \u2227 f , giving us \u2206(T2) = {a,2(e \u2227 f),3(b \u2227 e \u2227 f),3((c \u2228 d) \u2227 e \u2227 f)}.\nStep 3: The set Candidates will contain all the different possible disjunctions of elements in \u2206(T1) with elements in \u2206(T2), of which there are 12: a\u2228a, a\u22282(e\u2227f), a\u22283(b\u2227e\u2227f), a \u2228 3((c \u2228 d) \u2227 e \u2227 f), 3(b \u2227 c) \u2228 a, 3(b \u2227 c) \u2228 2(e \u2227 f), 3(b \u2227 c) \u2228 3(b \u2227 e \u2227 f), 3(b\u2227c)\u22283((c\u2228d)\u2227e\u2227f), 3b\u2228a, 3b\u22282(e\u2227f), 3b\u22283(b\u2227e\u2227f), and 3b\u22283((c\u2228d)\u2227e\u2227f).\nStep 4: We will remove from Candidates the clauses a \u2228 2(e \u2227 f), a \u2228 3(b \u2227 e \u2227 f), a \u2228 3((c \u2228 d) \u2227 e \u2227 f), 3(b \u2227 c) \u2228 a, and 3b \u2228 a since they are strictly weaker than a \u2228 a. We will also eliminate the clauses 3b \u2228 2(e \u2227 f), 3b \u2228 3(b \u2227 e \u2227 f), and\n3b \u2228 3((c \u2228 d) \u2227 e \u2227 f) since they are weaker than the clauses 3(b \u2227 c) \u2228 2(e \u2227 f), 3(b \u2227 c) \u2228 3(b \u2227 e \u2227 f), 3(b \u2227 c) \u2228 3((c \u2228 d) \u2227 e \u2227 f).\nStep 5: GenPI will return the four remaining clauses in Candidates, which are a \u2228 a, 3(b \u2227 c) \u2228 2(e \u2227 f), 3(b \u2227 c) \u2228 3(b \u2227 e \u2227 f), and 3(b \u2227 c) \u2228 3((c \u2228 d) \u2227 e \u2227 f).\nOur algorithm can be shown to be a sound and complete procedure for generating prime implicates.\nTheorem 16. The algorithm GenPI always terminates and outputs exactly the set of prime implicates of the input formula.\nBy examining the prime implicates produced by the algorithm, we can place an upper bound on the length of a formula\u2019s prime implicates.\nTheorem 17. The length of the smallest clausal representation of a prime implicate of a formula is at most single exponential in the length of the formula.\nThis upper bound is optimal as we can find formulae with exponentially large prime implicates. This situation contrasts with propositional logic, where the length of prime implicates is linearly bounded by the number of propositional variables in the formula.\nTheorem 18. The length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nIt is interesting to note that the formula used in the proof of Theorem 18 has a depth of 1, which means that we cannot avoid this worst-case spatial complexity by restricting our attention to formulae of shallow depth. Nor can we escape this exponential worst-case spatial complexity by dropping down to one of the less expressive notions of prime implicates examined in the previous section, as the following theorem attests.\nTheorem 19. If prime implicates are defined using either D1 or D2, then the length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nAn examination of the set of candidate prime implicates constructed by our algorithm allows us to place a bound on the maximal number of non-equivalent prime implicates a formula can possess.\nTheorem 20. The number of non-equivalent prime implicates of a formula is at most double exponential in the length of the formula.\nThis bound can also be shown to be optimal. This situation contrasts with propositional logic, where there can be at most single exponentially many non-equivalent prime implicates of a given formula.\nTheorem 21. The number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nAgain, this worst-case result is robust in that it can be improved neither by restricting the depth of formulae, nor by using less expressive notions of prime implicate, as the following theorem demonstrates.\nTheorem 22. If prime implicates are defined using either D1 or D2, then the number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nTheorems 19 and 22 together suggest that definitions D1 or D2 do not yield especially interesting approximate notions of prime implicate, as they induce a significant loss of expressivity without any improvement in the size or number of prime implicates in the worst-case.\nOur generation algorithm GenPI corresponds to the simplest possible implementation of the distribution property, and it is quite clear that it does not represent a practicable way for producing prime implicates. One major source of inefficiency is the large number of clauses that are generated, so if we want to design a more efficient algorithm, we need to find ways to generate fewer candidate clauses. There are a couple of different techniques that could be used. One very simple method which could yield a smaller number of clauses is to eliminate from \u2206(T ) those elements which are not prime implicates of T , thereby decreasing the cardinalities of the \u2206(T ) and hence of Candidates. To do this, we simply test whether \u03b2T is a tautology (and remove it if it is) and then compare the 3-literals in \u2206(T ), discarding any weaker elements. If we apply this technique to Example 15, we would remove 3b from \u2206(T1), thereby reducing the cardinality of Candidates from 12 to 8.\nMore substantial savings could be achieved by using a technique developed in the framework of propositional logic (cf. Marquis, 2000) which consists in calculating the prime implicates of T1, then the prime implicates of T1\u2228T2, then those of T1\u2228T2\u2228T3, and so on until we get the prime implicates of the full disjunction of terms. By interleaving comparison and construction, we can eliminate early on a partial clause that cannot give rise to prime implicates instead of producing all of the extensions of the partial clause and then deleting them one by one during the comparison phase. In our example, there were only two terms, but imagine that there was a third term T3. Then by applying this technique, we would first produce the 4 prime implicates of T1 \u2228 T2 and then we would compare the 4|\u2206(T3)| candidate clauses of T1 \u2228T2\u2228T3. Compare this with the current algorithm which generates and then compares 12|\u2206(T3)| candidate clauses.\nGiven that the number of elements in Candidates can be double exponential in the length of the input, cutting down on the size of the input to GenPI could yield significant savings. One obvious idea would be to break conjunctions of formulae into their conjuncts, and then calculate the prime implicates of each of the conjuncts. Unfortunately, however, we cannot apply this method to every formula as the prime implicates of the conjuncts are not necessarily prime implicates of the full conjunction. One solution which was proposed in the context of approximation of description logic concepts (cf. Brandt & Turhan, 2002) is to identify simple syntactic conditions that guarantee that we will get the same result if we break the formula into its conjuncts. For instance, one possible condition is that the conjuncts do not share any propositional variables. The formula \u03d5 in our example satisfies this condition since the variables in a and ((3(b\u2227 c)\u22273b)\u2228 (3b\u22273(c\u2228 d)\u22272e\u22272f)) are disjoint. By generating the prime implicates of the conjuncts separately, we can directly identify the prime implicate a, and we only have 6 candidate clauses of ((3(b \u2227 c) \u2227 3b) \u2228 (3b\u22273(c\u2228d)\u22272e\u22272f)) to compare. If we also remove weaker elements from the \u2206(Ti) as\nsuggested above, we get only 3 candidate clauses for ((3(b\u2227c)\u22273b)\u2228(3b\u22273(c\u2228d)\u22272e\u22272f)), all of which are prime implicates of \u03d5.\nAnother important source of inefficiency in our algorithm is the comparison phase in which we compare all candidate clauses one-by-one in order to identify the strongest ones. The problem with this is of course that in the worst-case there can be a double exponential number of candidate clauses, simply because there may be double exponentially many distinct prime implicates, and each prime implicate must be equivalent to some candidate clause. Keeping all of these double exponentially many clauses in memory will generally not be feasible. Fortunately, however, it is not necessary to keep all of the candidate clauses in memory at once since we can generate them on demand from the sets \u2206(T ). Indeed, as we demonstrate in the appendix, by implementing our algorithm in a more clever fashion, we obtain an algorithm which outputs the prime implicates iteratively while requiring only single-exponential space (the output of the algorithm could of course be double exponentially large because of Theorem 21).\nTheorem 23. There exists an algorithm which runs in single-exponential space in the size of the input and incrementally outputs, without duplicates, the set of prime implicates of the input formula.\nAlthough our modified algorithm has a much better spatial complexity than the original, it still does not yield a practicable means for generating prime implicates. The reason is that we still need to compare each of the candidate clauses against all the other candidate clauses in order to decide whether a candidate is a prime implicate or not. Given that the set of candidate clauses may be double exponential in number, this means that our algorithm may need to perform double exponentially many entailment tests before producing even a single prime implicate. A much more promising approach would be to test directly whether or not a candidate clause is a prime implicate without considering all of the other candidate clauses. In order to implement such an approach, we must of course come up with a procedure for determining whether or not a given clause is a prime implicate. This will be our objective in the following section."}, {"heading": "5.2 Recognizing Prime Implicates", "text": "The focus of this section is the problem of recognizing prime implicates, that is, the problem of deciding whether a clause \u03bb is a prime implicate of a formula \u03d5. As has been discussed in the previous subsection, this problem is of central importance, as any algorithm for generating prime implicates must contain (implicitly or explicitly) some mechanism for ensuring that the generated clauses are indeed prime implicates.\nIn propositional logic, prime implicate recognition is BH2-complete (Marquis, 2000), being as hard as both satisfiability and deduction. In K, satisfiability and unsatisfiability are both Pspace-complete, so we cannot hope to find a prime implicate recognition algorithm with a complexity of less than Pspace.\nTheorem 24. Prime implicate recognition is Pspace-hard.\nIn order to obtain a first upper bound, we can exploit Theorem 17 which tells us that there exists a polynomial function f such that every prime implicate of a formula \u03d5 is\nequivalent to some clauses of length at most 2f(|\u03d5|). This leads to a simple procedure for determining if a clause \u03bb is a prime implicate of a formula \u03d5. We simply check for every clause \u03bb\u2032 of length at most 2f(|\u03d5|) whether \u03bb\u2032 is an implicate of \u03d5 which implies \u03bb but is not implied by \u03bb. If this is the case, then \u03bb is not a prime implicate (we have found a logically stronger implicate of \u03d5), otherwise, there exists no stronger implicate, so \u03bb is a prime implicate. It is not too hard to see that this algorithm can be carried out in exponential space, which gives us an Expspace upper bound.\nOf course, the problem with this naive approach is that it does not at all take into account the structure of \u03bb, so we end up comparing a huge amount of irrelevant clauses, which is exactly what we were hoping to avoid. The algorithm that we propose later in this section avoids this problem by exploiting the information in the input formula and clause in order to cut down on the number of clauses to test. The key to our algorithm is the following theorem which shows how the general problem of prime implicate recognition can be reduced to the more specialized tasks of prime implicate recognition for propositional formulae, 2-formulae, and 3-formulae. To simplify the presentation of the theorem, we let \u03a0(\u03d5) refer to the set of prime implicates of \u03d5, and we use the notation \u03bb \\ {l1, ..., ln} to refer to the clause obtained by removing each of the literals li from \u03bb. For example (a \u2228 b \u2228 3c) \\ {a,3c} refers to the clause b.\nTheorem 25. Let \u03d5 be a formula of K, and let \u03bb = \u03b31\u2228 ...\u2228\u03b3k\u22283\u03c81\u2228 ...\u22283\u03c8n\u22282\u03c71\u2228 ...\u2228 2\u03c7m (\u03b3j propositional literals) be a non-tautologous clause such that (a) \u03c7i \u2261 \u03c7i\u2228\u03c81\u2228...\u2228\u03c8n for all i, and (b) there is no literal l in \u03bb such that \u03bb \u2261 \u03bb \\ {l}. Then \u03bb \u2208 \u03a0(\u03d5) if and only if the following conditions hold:\n1. \u03b31 \u2228 ... \u2228 \u03b3k \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}))\n2. 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8n) \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})) for every i\n3. 3(\u03c81 \u2228 ... \u2228 \u03c8n) \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8n}))\nWe remark that the restriction to clauses for which \u03c7i \u2261 \u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m for all i and for which \u03bb 6\u2261 \u03bb \\ {l} for all l is required. If we drop the first requirement, then there are some non-prime implicates that satisfy all three conditions, and if we drop the second, there are prime implicates which fail to satisfy one of the conditions5. These restrictions are without loss of generality however since every clause can be transformed into an equivalent clause satisfying them. For the first condition, we replace each 2\u03c7i by 2(\u03c7i\u2228\u03c81\u2228 ...\u2228\u03c8m), thereby transforming a clause \u03b31\u2228 ...\u2228\u03b3k\u22283\u03c81\u2228 ...3\u03c8m\u22282\u03c71\u2228 ...\u22282\u03c7n into the equivalent \u03b31\u2228 ...\u2228\u03b3k \u22283\u03c81\u2228 ...3\u03c8m \u22282(\u03c71\u2228\u03c81 \u2228 ...\u2228\u03c8m)\u2228 ...\u22282(\u03c7n \u2228\u03c81\u2228 ...\u2228\u03c8m). Then to make the clause satisfy the second condition, we simply remove from \u03bb those literals for which \u03bb \u2261 \u03bb \\ {l} until no such literal remains.\nTheorem 25 shows how prime implicate recognition can be split into three more specialized sub-tasks, but it does not tell us how to carry out these tasks. Thus, in order to turn\n5. For the first restriction, consider the formula \u03d5 = 3(a\u2227b\u2227c)\u22282a and the clause \u03bb = 3(a\u2227b)\u22282(a\u2227\u00acb). It can be easily shown that \u03bb is an implicate of \u03d5, but \u03bb is not a prime implicate of \u03d5 since there exist stronger implicates (e.g. \u03d5 itself). Nonetheless, it can be verified that both 2(a \u2227 \u00acb \u2227 \u00ac(a \u2227 b)) \u2208 \u03a0(\u03d5\u2227\u00ac(\u03bb\\{2(a\u2227\u00acb)})) and 3(a\u2227b) \u2208 \u03a0(\u03d5\u2227\u00ac(\u03bb\\{3(a\u2227b)})). For the second restriction, consider the formula 2a and the clause 2a\u22282(a\u2227b). We have 2(a\u2227b) 6\u2208 \u03a0(2a\u2227\u00ac(2a)) even though 2a\u22282(a\u2227b) \u2261 2a is a prime implicate of 2a.\nthis theorem into an algorithm for prime implicate recognition, we need to figure out how to test whether a propositional clause, a 2-formula, or a 3-formula is a prime implicate of a formula.\nDetermining whether a propositional clause is a prime implicate of a formula in K is conceptually no more difficult than determining whether a propositional clause is a prime implicate of a propositional formula. We first ensure that the clause is an implicate of the formula and then make sure that all literals appearing in the clause are necessary.\nTheorem 26. Let \u03d5 be a formula of K, and let \u03b3 be a non-tautologous propositional clause such that \u03d5 |= \u03b3 and such that there is no literal l in \u03b3 such that \u03b3 \u2261 \u03b3 \\{l}. Then \u03b3 \u2208 \u03a0(\u03d5) if and only if \u03d5 6|= \u03b3 \\ {l} for all l in \u03b3.\nWe now move on to the problem of deciding whether a clause of the form 2\u03c7 is a prime implicate of a formula \u03d5. We remark that if 2\u03c7 is implied by \u03d5, then it must also be implied by each of the terms Ti \u2208Dnf-4(\u03d5). But if Ti |= 2\u03c7, then by Theorem 1, it must be the case that the conjunction of the 2-literals in Ti implies 2\u03c7. This means that the formula 2\u03b21 \u2228 ... \u2228 2\u03b2n (where \u03b2i is the conjunction of the formulae \u03b6 such that 2\u03b6 is in Ti) is an implicate of \u03d5 which implies 2\u03c7, and moreover it is the strongest such implicate. It follows then that 2\u03c7 is a prime implicate of \u03d5 just in the case that 2\u03c7 |= 2\u03b21 \u2228 ... \u2228 2\u03b2n, which is true if and only if \u03c7 |= \u03b2i for some i (by Theorem 1). Thus, by comparing the formula \u03c7 with the formulae \u03b2i associated with the terms of \u03d5, we can decide whether or not 2\u03c7 is a prime implicate of \u03d5.\nTheorem 27. Let \u03d5 be a formula of K, and let \u03bb = 2\u03c7 be a non-tautologous clause such that \u03d5 |= \u03bb. Then \u03bb \u2208 \u03a0(\u03d5) if and only if there exists some term T \u2208Dnf-4(\u03d5) such that \u03c7 |= \u03b2T , where \u03b2T is the conjunction of formulae \u03c8 such that 2\u03c8 is in T .\nFinally let us turn to the problem of deciding whether a clause 3\u03c8 is a prime implicate of a formula \u03d5. Now we know by Covering that if 3\u03c8 is an implicate of \u03d5, then there must be some prime implicate \u03c0 of \u03d5 which implies 3\u03c8. It follows from Theorem 2 that \u03c0 must be a disjunction of 3-literals, and from Theorem 16 that \u03c0 is equivalent to a disjunction \u2228\nT\u2208Dnf-4(\u03d5) 3dT where 3dT is an element of \u2206(T ) for every T (refer back to Figure 3 for the definition of \u2206(T )). According to Definition 7, 3\u03c8 is a prime implicate of \u03d5 just in the case that 3\u03c8 |= \u2228\nT\u2208Dnf-4(\u03d5) 3dT , or equivalently \u03c8 |= \u2228\nT\u2208Dnf-4(\u03d5) dT . Thus, 3\u03c8 is not a prime implicate of \u03d5 just in the case that there is a choice of 3dT \u2208 \u2206(T ) for each T \u2208 Dnf-4(\u03d5) such that \u2228\nT\u2208Dnf-4(\u03d5) dT |= \u03c8 and \u03c8 6|= \u2228\nT\u2208Dnf-4(\u03d5) dT . Testing directly whether \u03c8 entails some formula \u2228\nT\u2208Dnf-4(\u03d5) dT could take exponential space in the worst case since there may be exponentially many terms in Dnf-4(\u03d5). Luckily, however, we can get around this problem by exploiting the structure of the formula \u2228\nT\u2208Dnf-4(\u03d5) dT . We remark that because of the way \u2206(T ) is defined the formula dT must be a conjunction of formulae \u03b6 such that 2\u03b6 or 3\u03b6 appears in Nnf(\u03d5) outside the scope of modal operators \u2013 we will use X to denote the set of formulae \u03b6 satisfying this condition. We show in the appendix that \u03c8 6|= \u2228\nT\u2208Dnf-4(\u03d5) dT implies the existence of a subset S \u2286 X such that (a) \u03c8 6|= \u2228\n\u03bb\u2208S \u03bb and (b) every dT has at least one conjunct from the set S. Conversely, the existence of such a subset of X implies \u03c8 6|= \u2228\nT\u2208Dnf-4(\u03d5) dT . This observation is the basis for the algorithm Test3PI given in Figure 4. The basic idea behind the algorithm is to try out each of the different subsets of X in order to see whether some subset satisfies the\naforementioned conditions. If we find a suitable subset, this proves that 3\u03c8 is not a prime implicate, and if no such subset exists, then we can be sure there is no stronger implicate than 3\u03c8. The algorithm can be shown to run in polynomial space since there can be at most |\u03d5| elements in X , and we can consider the terms in Dnf-4(\u03d5) one at a time.\nTheorem 28. Let \u03d5 be a formula, and let 3\u03c8 be an implicate of \u03d5. Then the algorithm Test3PI returns yes on input (3\u03c8, \u03d5) if and only if 3\u03c8 is a prime implicate of \u03d5.\nTheorem 29. The algorithm Test3PI runs in polynomial space.\nWe now illustrate the algorithm Test3PI with two examples.\nExample 30. We use Test3PI to test whether the clause \u03bb = 3(a\u2227b) is a prime implicate of \u03d5 = a \u2227 (2(b \u2227 c) \u2228 2(e \u2228 f)) \u2227 3(a \u2227 b).\nStep 1: As \u03d5 is satisfiable, we pass directly to Step 2.\nStep 2: We set X equal to the set of formulae \u03b6 such that 2\u03b6 or 3\u03b6 appears in Nnf(\u03d5) outside the scope of modal operators. In our case, we set X = {b \u2227 c, e \u2228 f, a \u2227 b} since \u03d5 =Nnf(\u03d5) and b \u2227 c, e \u2228 f , and a \u2227 b are the only formulae satisfying the requirements.\nStep 3: We examine each of the different subsets of X to determine whether they satisfy conditions (a) and (b). In particular, we consider the subset S = {b \u2227 c, e \u2228 f}. We remark that this subset satisfies condition (a) since a \u2227 b 6|= (b \u2227 c) \u2228 (e \u2228 f). In order to check condition (b), we first call the function Dnf-4 on \u03d5 which returns the two terms T1 = a \u2227 2(b \u2227 c) \u2227 3(a \u2227 b) and T2 = a \u2227 2(e \u2228 f) \u2227 3(a \u2227 b). We notice that the conjuncts 3(a\u2227 b) and 2(b\u2227 c) of T1 satisfy conditions (i) and (ii) since b\u2227 c \u2208 S and 3(a\u2227 b\u2227 (b\u2227 c)) |= \u03bb. We then notice that the conjuncts 3(a\u2227 b) and 2(e\u2228 f) of T2 also satisfy conditions (i) and (ii) since e\u2228 f \u2208 S and 3(a\u2227 b\u2227 (e\u2228 f)) |= \u03bb. That\nmeans that we have found a subset S of X which satisfies conditions (a) and (b), so the algorithm returns no. This is the correct output since 3(a\u2227 b\u2227 ((b\u2227 c)\u2228 (e\u2228 f))) is an implicate of \u03d5 which is strictly stronger than \u03bb.\nExample 31. We use Test3PI to test whether the clause \u03bb = 3(a \u2227 b \u2227 c) is a prime implicate of \u03d5 = a \u2227 (2(b \u2227 c) \u2228 2(e \u2228 f)) \u2227 3(a \u2227 b) \u2227 \u00ac2(e \u2228 f \u2228 (a \u2227 b \u2227 c)).\nStep 1: We proceed directly to Step 2 since \u03d5 is satisfiable.\nStep 2: We set X = {b\u2227 c, e\u2228 f, a\u2227 b,\u00ace\u2227\u00acf \u2227 (\u00aca\u2228\u00acb\u2228\u00acc))} since Nnf(\u03d5)=a\u2227 (2(b\u2227 c) \u2228 2(e \u2228 f)) \u2227 3(a \u2227 b) \u2227 3(\u00ace \u2227 \u00acf \u2227 (\u00aca \u2228 \u00acb \u2228 \u00acc)).\nStep 3: We check whether there is some subset of X satisfying conditions (a) and (b). We claim that there is no such subset. To see why, notice that a \u2227 2(b \u2227 c) \u2227 3(a \u2227 b) \u2227 3(\u00ace\u2227\u00acf \u2227 (\u00aca\u2228\u00acb\u2228\u00acc)) is the only term in Dnf-4(\u03d5). Moreover, there is only one set of conjuncts of this term which implies 3(a \u2227 b \u2227 c), namely {3(a \u2227 b),2(b \u2227 c)}. But that means that S must contain either a \u2227 b or b \u2227 c in order to satisfy condition (b)(i). As a \u2227 b \u2227 c implies both a \u2227 b and b \u2227 c, we are guaranteed that a \u2227 b \u2227 c will imply the disjunction of elements in S, thereby falsifying condition (a). It follows that there is no subset of X satisfying the necessary conditions, so Test3PI returns yes, which is the desired result.\nIn Figure 5, we present our algorithm for testing whether a clause \u03bb is a prime implicate of a formula \u03d5. The first two steps of the algorithm treat the limit cases where \u03bb is not an implicate or where one or both of \u03d5 and \u03bb is a tautology or contradiction. In Step 3,\nwe apply equivalence-preserving transformations to \u03bb to make it satisfy the requirements of Theorem 25. Then in Steps 4, 5, and 6 we use the procedures from Theorems 26, 27, and 28 to test whether the three conditions in Theorem 25 are verified. If the three tests succeed, then by Theorem 25, the clause is a prime implicate, so we return yes. If some test fails, we return no as the clause has been shown not to be a prime implicate.\nTheorem 32. The algorithm TestPI always terminates, and it returns yes on input (\u03bb, \u03d5) if and only if \u03bb is a prime implicate of \u03d5.\nWe demonstrate the use of TestPI on an example.\nExample 33. We use TestPI to test if the clauses \u03bb1 = b, \u03bb2 = 2b\u22282(e\u2228f), \u03bb3 = a\u22283c, \u03bb4 = 3(a \u2227 b), and \u03bb5 = 3(a \u2227 b \u2227 c) \u2228 3(a \u2227 b \u2227 c \u2227 f) \u2228 2(e \u2228 f) are prime implicates of \u03d5 = a \u2227 (2(b \u2227 c) \u2228 2(e \u2228 f)) \u2227 3(a \u2227 b).\n\u03bb1: We output no in Step 1 since \u03d5 6|= \u03bb1.\n\u03bb2: We skip Steps 1 and 2 since \u03bb |= \u03bb2 and neither \u03d5 |= \u22a5 nor |= \u03bb2. In Step 3, we make no changes to \u03bb2 since it contains no redundant literals nor any 3-literals. We skip Step 4 since \u03bb2 has no propositional disjuncts. In Step 5, we return no since Dnf-4(\u03d5\u2227\u00ac(\u03bb2 \\ {2b})) = {a\u22272(b\u2227 c)\u22273(a\u2227 b)\u22273(\u00ace\u2227\u00acf)} and 2b 6|= 2(b\u2227 c).\n\u03bb3: We proceed directly to Step 3 since \u03bb |= \u03bb3, \u03d5 6|= \u22a5, and 6|= \u03bb3. No modifications are made to \u03bb3 in Step 3 as it does not contain any redundant literals or 2-literals. In Step 4, we test whether or not \u03d5 |= \u03bb3 \\ {a}. As \u03d5 6|= 3c, we proceed on to Step 5, and then directly on to Step 6 since \u03bb3 contains no 2-literals. In Step 6, we call Test3PI(3c, \u03d5 \u2227 \u00ac(\u03bb3 \\ {3c})), which outputs no since \u03d5 \u2227 \u00ac(\u03bb3 \\ {3c}) |= \u22a5 and c 6|= \u22a5.\n\u03bb4: Steps 1-5 are all inapplicable, so we skip directly to Step 6. In this step, we call Test3PI with as input the clause 3(a\u2227b) and the formula \u03d5\u2227\u00ac(\u03bb4\\{3(a\u2227b)}) = \u03d5. We have already seen in Example 30 above that Test3PI returns no on this input, which means that TestPI also returns no.\n\u03bb5: We proceed directly to Step 3, where we delete the redundant literal 3(a \u2227 b \u2227 c \u2227 f) and then modify the literal 2(e\u2228f). At the end of this step, we have \u03bb5 = 3(a\u2227b\u2227c)\u2228 2((e\u2228f)\u2228(a\u2227b\u2227c)). Step 4 is not applicable since there are no propositional disjuncts in \u03bb5. In Step 5, we continue since Dnf-4(\u03d5 \u2227 \u00ac(\u03bb5 \\ {2((e \u2228 f \u2228 (a \u2227 b \u2227 c))})) = {a\u22272(e\u2228f)\u22273(a\u2227b)\u22272(\u00aca\u2228\u00acb\u2228\u00acc)}, and 2(((e\u2228f \u2228(a\u2227b\u2227c))\u2227(\u00aca\u2228\u00acb\u2228\u00acc)) |= 2(e\u2228 f)\u22272(\u00aca\u2228\u00acb\u2228\u00acc). In Step 6, we return yes since we call Test3PI on input (3(a \u2227 b \u2227 c), \u03d5 \u2227 \u00ac(\u03bb5 \\ {3(a \u2227 b \u2227 c)})), and we have previously shown in Example 31 that Test3PI returns yes on this input.\nWe show in the appendix that the algorithm TestPI runs in polynomial space. As we have already shown that TestPI decides prime implicate recognition, it follows that this problem is in Pspace:\nTheorem 34. Prime implicate recognition is in Pspace.\nBy putting together Theorems 24 and 34, we obtain a tight complexity bound for the prime implicate recognition task.\nCorollary 35. Prime implicate recognition is Pspace-complete."}, {"heading": "6. Conclusion and Future Work", "text": "The first contribution of this work is a detailed comparison of several different possible definitions of clauses, terms, prime implicates, and prime implicants for the modal logic K. The results of this investigation were largely positive: although we have shown that no perfect definition exists, we did exhibit a very simple definition (D4) which satisfies most of the desirable properties of the propositional case. The second contribution of our work is a thorough investigation of the computational aspects of the selected definition D4. To this end, we presented a sound and complete algorithm for generating prime implicates, as well as a number of optimizations to improve the efficiency of the algorithm. An examination of the structure of the prime implicates generated by our algorithm allowed us to place upper bounds on the length of prime implicates and on the number of prime implicates a formula can possess. We showed these bounds to be optimal by exhibiting matching lower bounds, and we further proved that the lower bounds hold even for some much less expressive notions of prime implicates. Finally, we constructed a polynomial-space algorithm for deciding prime implicate recognition, thereby showing this problem to be Pspace-complete, which is the lowest complexity that could reasonably be expected. Although the focus of the paper was on the logic K, all of our results can be easily lifted to multi-modal K and to concept expressions in the well-known description logic ALC.\nAs was mentioned in the introduction, one of the main applications of prime implicants in propositional logic is to the area of abductive reasoning, where prime implicants play the role of abductive explanations. The results of our paper can be directly applied to the problem of abduction in K: our notion of prime implicants can be used as a definition of abductive explanations in K, and our prime implicate generation algorithm provides a means of producing all of the abductive explanations to a given abduction problem. Moreover, because the notion of term underlying our definition of abductive explanations is more expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations which are overlooked by their method. For instance, if we look for an explanation of the observation c given the background information 2(a \u2228 b) \u2192 c, we obtain 2(a \u2228 b), whereas their framework yields 2a and 2b. This is an argument in favor of our approach since generally in abduction one is looking to find the weakest conditions guaranteeing the truth of the observation given the background information.\nAlso of interest are our results on the size and number of prime implicates, as these yield corresponding lower bounds on the size and number of abductive explanations. In particular, our results imply that the abductive explanations of Cialdea Mayer and Pirri (1995) can have exponential size and be double exponentially many in number in the worst case, and thus behave no better in these respects than the notion of abductive explanation induced by our preferred definition D4. Moreover, the fact that these lower bounds hold even in the case of the extremely inexpressive notion of abductive explanations induced by definition D2 suggests that these high worst-case complexity results really cannot be\navoided. In light of these intractability results, an interesting question for future research would be to study the problem of generating a single prime implicate, since in some applications it may prove sufficient to produce a single minimal explanation for an observation. Another interesting subject for future work which is relevant from the point of view of abduction is the investigation of the notion of prime implicate over a fixed vocabulary. The development of generation algorithms for this more refined notion of prime implicate would allow one to generate only those abductive explanations which are built up from a given set of propositional variables.\nThe second domain of application which was mentioned in the introduction was the area of knowledge compilation. In propositional logic, one well-known target language for knowledge compilation is prime implicate normal form, in which a formula is represented as the conjunction of its prime implicates. A natural idea would be to use our selected definition of prime implicate to define in an analogous manner a notion of prime implicate normal form for K formulae. Unfortunately, the normal form we obtain satisfies few of the nice properties of the propositional case. For instance, we find that entailment between two formulae in prime implicate normal form is no easier than between arbitrary K formulae. To see why, consider any pair of formulae \u03d5 and \u03c8 in negation normal form. The formulae 3\u03d5 and 3\u03c8 are their own prime implicates and hence are in prime implicate normal form according to the naive definition. As \u03d5 |= \u03c8 just in the case that 3\u03d5 |= 3\u03c8, we can reduce entailment between arbitrary K formulae in NNF to entailment between formulae in prime implicate normal form. As the former problem is known to be Pspace-complete, it follows that the latter is Pspace-complete as well.\nAt first sight, this appears to be quite a disappointing result as one would hope that the computational difficulty of representing a formula by its prime implicates would be offset by some good computational properties of the resulting formula. As it turns out, however, the problem lies not in our definition of prime implicates but rather in the naive way of defining prime implicate normal form. Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form, in which we specify which of the many different clausal representations of a prime implicate should be used. This normal form was shown to enjoy a number of desirable properties which make it interesting from the viewpoint of knowledge compilation. Most notably, it was proven that entailment between formulae in K in our prime implicate normal form can be carried out in polynomial time using a simple structural comparison algorithm which is reminiscent of the structural subsumption algorithms used in subpropositional description logics. It should be noted that the proof of this and other results by Bienvenu (2008) make ample use of the material presented in the current paper.\nIn this work, we studied prime implicates with respect to the local consequence relation, so a natural direction for future work would be the investigation of prime implicates with respect to the global consequence relation. This question is particularly interesting given that global consequence is the type of consequence used in description logic ontologies. Unfortunately, our preliminary investigations suggest that defining and generating prime implicates with respect to the global consequence relation will likely prove more difficult than for the local consequence relation. For one thing, if we use a definition of clause which is reasonably\nexpressive, then the notion of prime implicate we obtain does not satisfy Covering since we can construct infinite sequences of stronger and stronger implicates. Take for instance the formula (\u00aca \u2228 b) \u2227 (\u00acb \u2228 3b) which implies (using the global consequence relation) each of the increasingly stronger clauses in the infinite sequence \u00aca \u2228 3b, \u00aca \u2228 3(b \u2227 3b), \u00aca\u22283(b\u22273(b\u22273b)), ... This is a familiar situation for description logic practitioners since these infinite sequences are responsible for the non-existence of most specific concepts in many common DLs (cf. Ku\u0308sters & Molitor, 2002) and the lack of uniform interpolation for ALC TBoxes (Ghilardi, Lutz, & Wolter, 2006). A standard solution to this problem is to simply place a bound on the depth of formulae to be considered, effectively blocking these problematic infinite sequences. This will not allow us to regain Covering, but it will give us a weaker version of this property, which should be sufficient for most applications. The development of generation algorithms for the global consequence relation may also prove challenging, since it is unclear at this point whether we will be able to draw inspiration from pre-existing methods. Despite these potential difficulties, we feel that this subject is worth exploring since it could contribute to the development of more flexible ways of accessing and structuring information in description logic ontologies.\nFinally, another natural direction for future research would be to extend our investigation of prime implicates and prime implicants to other popular modal and description logics. Particularly of interest are modal logics of knowledge and belief and expressive description logics used for the semantic web. We are confident that the experience gained from our investigation of prime implicates and prime implicants in K will prove a valuable asset in the exploration of other modal and description logics."}, {"heading": "Acknowledgments", "text": "This paper corrects and significantly extends an earlier conference publication (Bienvenu, 2007). This paper was written while the author was a PhD student working at IRIT, Universite\u0301 Paul Sabatier, France. The author would like to thank her thesis supervisors Andreas Herzig, Je\u0301ro\u0302me Lang, and Je\u0301ro\u0302me Mengin, as well as the anonymous reviewers for very helpful feedback."}, {"heading": "Appendix A. Proofs", "text": "Theorem 1 Let \u03c8, \u03c81, ..., \u03c8m, \u03c7, \u03c71, ..., \u03c7n be formulae in K, and let \u03b3 be a propositional formula. Then\n1. \u03c8 |= \u03c7 \u21d4|= \u00ac\u03c8 \u2228 \u03c7 \u21d4 \u03c8 \u2227 \u00ac\u03c7 |= \u22a5\n2. \u03c8 |= \u03c7 \u21d4 3\u03c8 |= 3\u03c7 \u21d4 2\u03c8 |= 2\u03c7\n3. \u03b3\u22273\u03c81\u2227...\u22273\u03c8m\u22272\u03c71\u2227...\u22272\u03c7n |= \u22a5 \u21d4 (\u03b3 |= \u22a5 or \u03c8i\u2227\u03c71\u2227...\u2227\u03c7n |= \u22a5 for some i)\n4. |= \u03b3 \u22283\u03c81 \u2228 ... \u22283\u03c8m \u22282\u03c71 \u2228 ... \u2228 2\u03c7n \u21d4 (|= \u03b3 or |= \u03c81 \u2228 ... \u2228 \u03c8m \u2228 \u03c7i for some i)\n5. 2\u03c7 |= 2\u03c71 \u2228 ... \u2228 2\u03c7n \u21d4 \u03c7 |= \u03c7i for some i\n6. 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2\u03c71 \u2228 ... \u2228 2\u03c7n \u2261 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m)\nProof. The first statement is a well-known property of local consequence, but we prove it here for completeness:\n\u03c8 |= \u03c7 \u21d4 M, w |= \u03c8 implies M, w |= \u03c7 for all M, w \u21d4 M, w 6|= \u03c8 or M, w |= \u03c7 for all M, w \u21d4 M, w |= \u00ac\u03c8 or M, w |= \u03c7 for all M, w \u21d4 |= \u00ac\u03c8 \u2228 \u03c7 \u21d4 M, w 6|= \u03c8 \u2227 \u00ac\u03c7 for all M, w \u21d4 \u03c8 \u2227 \u00ac\u03c7 |= \u22a5\nFor the second statement, if \u03c8 6|= \u03c7, then there is some M, w such that M, w |= \u03c8 \u2227\u00ac\u03c7. Create a new model M\u2032 from M by adding a new world w\u2032 and placing a single arc from w\u2032 to w. Then M\u2032, w\u2032 |= 3\u03c8 \u2227 2\u00ac\u03c7, which means that 3\u03c8 \u2227 2\u00ac\u03c7 is satisfiable and hence 3\u03c8 6|= 3\u03c7 (since \u00ac2\u00ac\u03c7 \u2261 3\u03c7). For the other direction, suppose 3\u03c8 6|= 3\u03c7. Then there exists M, w such that M, w |= 3\u03c8 \u2227 \u00ac3\u03c7 \u2261 3\u03c8 \u2227 2\u00ac\u03c7. But this means that there is some w\u2032 for which \u03c8 \u2227 \u00ac\u03c7, hence \u03c8 6|= \u03c7. To complete the proof, we use the following chain of equivalences: 2\u03c8 |= 2\u03c7 \u21d4 \u00ac2\u03c7 |= \u00ac2\u03c8 \u21d4 3\u00ac\u03c7 |= 3\u00ac\u03c8 \u21d4 \u00ac\u03c7 |= \u00ac\u03c8 \u21d4 \u03c8 |= \u03c7.\nFor 3, suppose that \u03b3 \u2227 3\u03c81 \u2227 ... \u22273\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n 6|= \u22a5. Then there exist M, w such that M, w |= \u03b3 \u2227 3\u03c81 \u2227 ...3\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n. As M, w |= \u03b3, we cannot have \u03b3 |= \u22a5, nor can we have \u03c8i \u2227 \u03c71 \u2227 ... \u2227 \u03c7n |= \u22a5 since for each i there is some w\n\u2032 such that M, w\u2032 |= \u03c8i \u2227 \u03c71 \u2227 ... \u2227 \u03c7n. Now for the other direction suppose that \u03b3 and all of the \u03c8i \u2227 \u03c71 \u2227 ... \u2227 \u03c7n are satisfiable. Then there is some propositional model w of \u03b3, and for each i, we can find Mi, wi such that Mi, wi |= \u03c8i \u2227 \u03c71 \u2227 ... \u2227 \u03c7n. Now we construct a new Kripke structure which contains the models Mi and the world w and in which there are arcs going from w to each of the wi. It is not hard to see that in this new model Mnew we have Mnew, w |= \u03b3 \u2227 3\u03c81 \u2227 ...3\u03c8m \u2227 2\u03c71 \u2227 ...2\u03c7n, so \u03b3 \u2227 3\u03c81 \u2227 ...3\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n 6|= \u22a5.\nStatement 4 follows easily from the third statement. We simply notice that \u03b3 \u2228 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2\u03c71 \u2228 ... \u2228 2\u03c7n is a tautology just in the case that its negation \u00ac\u03b3 \u2227 3\u00ac\u03c71 \u2227 ... \u2227 3\u00ac\u03c7n \u2227 2\u00ac\u03c81 \u2227 ... \u2227 2\u00ac\u03c8m is unsatisfiable.\nFor 5, we use statements 1 and 4 to get the following chain of equivalences:\n2\u03c7 |= 2\u03c71 \u2228 ... \u2228 2\u03c7n \u21d4 |= 3\u00ac\u03c7 \u2228 2\u03c71 \u2228 ... \u2228 2\u03c7n \u21d4 |= \u00ac\u03c7 \u2228 \u03c7i for some i \u21d4 \u03c7 |= \u03c7i for some i\nThe first implication of the equivalence in 6 is immediate since 3\u03c81 \u2228 ... \u2228 3\u03c8m |= 3\u03c81\u2228 ...\u22283\u03c8m and 2\u03c7i |= 2(\u03c7i\u2228\u03c81\u2228 ...\u2228\u03c8m) for all i. For the other direction, we remark that by using statements 1 and 3, we get the following equivalences:\n2(\u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) |= 2\u03c7i \u2228 3\u03c81 \u2228 ... \u2228 3\u03c8m \u21d4 2(\u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2227 \u00ac(2\u03c7i \u2228 3\u03c81 \u2228 ... \u2228 3\u03c8m) |= \u22a5 \u21d4 2(\u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2227 3\u00ac\u03c7i \u2227 2\u00ac\u03c81 \u2227 ... \u2227 2\u00ac\u03c8m |= \u22a5 \u21d4 (\u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2227 \u00ac\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m |= \u22a5\nAs (\u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2227 \u00ac\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m is clearly unsatisfiable, it follows that 2(\u03c7i \u2228\u03c81 \u2228 ...\u2228\u03c8m) |= 2\u03c7i \u22283\u03c81 \u2228 ...\u22283\u03c8m for every i and hence that 3\u03c81 \u2228 ...\u22283\u03c8m \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) |= 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2\u03c71 \u2228 ... \u2228 2\u03c7n, completing the proof.\nTheorem 2 Let \u03bb be a disjunction of propositional literals and 2- and 3-formulae. Then each of the following statements holds:\n1. If \u03bb |= \u03b3 for some non-tautological propositional clause \u03b3, then every disjunct of \u03bb is either a propositional literal or an unsatisfiable 3-formula\n2. If \u03bb |= 3\u03c81 \u2228 ... \u2228 3\u03c8n, then every disjunct of \u03bb is a 3-formula\n3. If \u03bb |= 2\u03c71 \u2228 ... \u2228 2\u03c7n and 6|= 2\u03c71 \u2228 ... \u2228 2\u03c7n, then every disjunct of \u03bb is either a 2-formula or an unsatisfiable 3-formula\nProof. For (1), let \u03b3 be a non-tautologous propositional clause such that \u03bb |= \u03b3, and suppose for a contradiction that \u03bb contains a disjunct 2\u03c7 or a disjunct 3\u03c8 where \u03c8 6|= \u22a5. In the first case, we have 2\u03c7 |= \u03b3, and hence |= 3\u00ac\u03c7 \u2228 \u03b3. It follows from Theorem 1 that |= \u03b3, contradicting our assumption that \u03b3 is not a tautology. In the second case, we have 3\u03c8 |= \u03b3, and thus |= 2\u00ac\u03c8 \u2228 \u03b3. By Theorem 1, either |= \u00ac\u03c8 or |= \u03b3. In both cases, we reach a contradiction since we have assumed that \u03c8 6|= \u22a5 and 6|= \u03b3. It follows then that \u03bb cannot have any 2-formulae or satisfiable 3-formulae as disjuncts.\nThe proofs of (2) and (3) proceed similarly.\nTheorem 3 Let \u03bb = \u03b3 \u22283\u03c81 \u2228 ... \u22283\u03c8m \u22282\u03c71 \u2228 ...\u22282\u03c7n and \u03bb \u2032 = \u03b3\u2032 \u22283\u03c8\u20321 \u2228 ... \u22283\u03c8 \u2032 p \u2228 2\u03c7\u20321 \u2228 ... \u2228 2\u03c7 \u2032 q be formulae in K. If \u03b3 are \u03b3 \u2032 are both propositional and 6|= \u03bb\u2032, then\n\u03bb |= \u03bb\u2032 \u21d4\n \n\n\u03b3 |= \u03b3\u2032 and \u03c81 \u2228 ... \u2228 \u03c8m |= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p and for every \u03c7i there is some \u03c7 \u2032 j such that \u03c7i |= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u03c7 \u2032 j\nProof. Since we have 6|= \u03bb\u2032, we know that 6|= \u03b3\u2032 and 6|= \u03c8\u20321 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u03c7 \u2032 i for all i. Using this information together with Theorem 1, we get the following equivalences:\n\u03b3 |= \u03bb\u2032 \u21d4 |= \u00ac\u03b3 \u2228 \u03b3\u2032 \u2228 3\u03c8\u20321 \u2228 ... \u2228 3\u03c8 \u2032 p \u2228 2\u03c7 \u2032 1 \u2228 ... \u2228 2\u03c7 \u2032 m\n\u21d4 |= \u00ac\u03b3 \u2228 \u03b3\u2032 \u21d4 \u03b3 |= \u03b3\u2032\n3\u03c81 \u2228 ... \u2228 3\u03c8m |= \u03bb \u2032 \u21d4 3(\u03c81 \u2228 ... \u2228 \u03c8m) |= \u03bb \u2032\n\u21d4 |= \u03b3\u2032 \u2228 3\u03c8\u20321 \u2228 ... \u2228 3\u03c8 \u2032 p \u2228 2\u00ac(\u03c81 \u2228 ... \u2228 \u03c8m) \u2228 2\u03c7 \u2032 1 \u2228 ... \u2228 2\u03c7 \u2032 q \u21d4 |= \u03c8\u20321 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u00ac(\u03c81 \u2228 ... \u2228 \u03c8m) \u21d4 \u03c81 \u2228 ... \u2228 \u03c8m |= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p\n2\u03c7i |= \u03bb \u2032 \u21d4 |= \u03b3\u2032 \u2228 3(\u03c8\u20321 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u00ac\u03c7i) \u2228 2\u03c7 \u2032 1 \u2228 ... \u2228 2\u03c7 \u2032 q\n\u21d4 there is some j such that |= \u03c8\u20321 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u00ac\u03c7i \u2228 \u03c7 \u2032 j \u21d4 there is some j such that \u03c7i |= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p \u2228 \u03c7 \u2032 j\nTo complete the proof, we use the fact \u03bb |= \u03bb\u2032 if and only if \u03b3 |= \u03bb\u2032, 3\u03c81 \u2228 ... \u2228 3\u03c8m |= \u03bb \u2032, and 2\u03c7i |= \u03bb \u2032 for every i.\nTheorem 5 Any definition of literals, clause, and terms for K that satisfies properties P1 and P2 cannot satisfy P5.\nProof. We remark that the set of clauses (resp. terms) with respect to definition D1 is precisely the set of formulae in NNF which do not contain \u2227 (resp. \u2228), i.e. D1 is the most expressive definition satisfying both P1 and P2. Thus, to show the result, it suffices to show that D1 does not satisfy P5.\nSuppose for a contradiction thatD1 does satisfy P5. Then there must exist clauses \u03bb1, ..., \u03bbn such that 3(a\u2227 b) \u2261 \u03bb1 \u2227 ...\u2227 \u03bbn. Each of the clauses \u03bbi is a disjunction li,1 \u2228 ....\u2228 li,pi . By distributing \u2227 over \u2228, we obtain the following:\n3(a \u2227 b) \u2261 \u2228\n(j1,...,jn)\u2208{1,...,p1}\u00d7...\u00d7{1,...,pn}\nn\u2227\ni=1\nli,ji\nfrom which we can infer that for each (j1, ..., jn) \u2208 {1, ..., p1} \u00d7 ...\u00d7 {1, ..., pn} we have\nn\u2227\ni=1\nli,ji |= 3(a \u2227 b)\nConsider some (j1, ..., jn) such that \u2227n\ni=1 li,ji is consistent (there must be at least one such tuple, otherwise we would have 3(a \u2227 b) \u2261 \u22a5). The formulae li,ji are either propositional literals or formulae of the form 2\u03ba or 3\u03ba for some clause \u03ba. It follows that\n\u2227n i=1 li,ji must\nhave the following form:\n\u03b31 \u2227 ... \u2227 \u03b3k \u2227 3\u03c81 \u2227 ... \u2227 3\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n\nwhere \u03b31, ..., \u03b3k are propositional literals and \u03c81, ..., \u03c8m, \u03c71, ..., \u03c7n are clauses with respect to D1. As we know that\n\u2227n i=1 li,ji |= 3(a\u2227 b) and \u2227n i=1 li,ji 6|= \u22a5, by Theorem 1, there must\nbe some 3\u03c8q such that 3\u03c8q \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n |= 3(a \u2227 b)\nWe now show that 3\u03c8q 6|= 3(a \u2227 b) (and hence that 6|= \u03c71 \u2227 ... \u2227 \u03c7n). Suppose for a contradiction that this is not the case. Then we must have \u03c8q |= a and \u03c8q |= b. But by Theorem 1, every disjunct of \u03c8q (which we recall is a D1-clause) must either be unsatisfiable or equal to both a and b. As the latter is impossible, it follows that \u03c8q |= \u22a5, which is a contradiction since we assumed that\n\u2227n i=1 li,ji is satisfiable. It follows then that in order to\nget 3\u03c8q \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n |= 3(a \u2227 b), there must be some \u03c7r which is not a tautology. Now let us consider the formula\n\u03c4 = \u2228\n{(j1,...,jn)| Vn\ni=1 li,ji 6\u2261\u22a5}\n2\u03c7j1,...,jn\nwhere 2\u03c7j1,...,jn is a non-tautological 2-formula appearing in \u2227n\ni=1 li,ji (we have just shown that such a formula must exist). Clearly it must be the case that\n\u2228\n(j1,...,jn)\u2208{1,...,p1}\u00d7...\u00d7{1,...,pn}\nn\u2227\ni=1\nli,ji |= \u03c4\nfrom which we get:\n3(a \u2227 b) |= \u03c4\nBut according to Theorem 2, a satisfiable 3-formula cannot imply a disjunction of 2- formulae unless that disjunction is a tautology, so we must have |= \u03c4 . However, this is impossible since it would imply (Theorem 1) that there is some \u03c7j1,...,jn which is a tautology, contradicting our earlier assumption to the contrary. We can thus conclude that there is no set of clauses \u03bb1, ..., \u03bbn with respect to D1 such that 3(a\u2227 b) \u2261 \u03bb1 \u2227 ... \u2227 \u03bbn, and hence that any definition which satisfies P1 and P2 cannot satisfy P5.\nIn order to prove Theorem 6, we will make use of the following lemmas:\nLemma 6.1 Definition D5 satisfies P5.\nProof. We demonstrate that any formula in K in NNF is equivalent to a conjunction of clauses with respect to definition D5. The restriction to formulae in NNF is without loss of generality as every formula is equivalent to a formula in NNF. The proof proceeds by induction on the structural complexity of formulae. The base case is propositional literals, which are already conjunctions of clauses since every propositional literal is a clause with respect to D5. We now suppose that the statement holds for formulae \u03c81 and \u03c82 and show that it holds for more complex formulae.\nWe first consider \u03d5 = \u03c81 \u2227 \u03c82. By assumption, we can find clauses \u03c1i and \u03b6j such that \u03c81 \u2261 \u03c11 \u2227 ... \u2227 \u03c1n and \u03c82 \u2261 \u03b61 \u2227 ... \u2227 \u03b6m. Thus, \u03d5 is equivalent to the formula \u03c11 \u2227 ... \u2227 \u03c1n \u2227 \u03b61 \u2227 ... \u2227 \u03b6m, which is a conjunction of clauses with respect to D5.\nNext we consider \u03d5 = \u03c81 \u2228 \u03c82. By the induction hypothesis, we have \u03c81 \u2261 \u03c11 \u2227 ... \u2227 \u03c1n and \u03c82 \u2261 \u03b61 \u2227 ... \u2227 \u03b6m for some clauses \u03c1i and \u03b6j. Thus, \u03d5 \u2261 (\u03c11 \u2227 ... \u2227 \u03c1n) \u2228 (\u03b61 \u2227 ... \u2227 \u03b6m), which can be written equivalently as \u03d5 \u2261 \u2227(i,j)\u2208{1,...,n}\u00d7{1,...,m}(\u03c1i \u2228 \u03b6j). Since the union of two clauses produces another clause, all of the \u03c1i \u2228 \u03b6j are clauses, completing the proof.\nWe now consider the case where \u03d5 = 2\u03c81. By assumption, \u03c81 \u2261 \u03c11\u2227 ...\u2227\u03c1n, where each \u03c1i is a clause. So \u03d5 \u2261 2(\u03c11\u2227...\u2227\u03c1n). But we also know that 2(\u03c11\u2227...\u2227\u03c1n) \u2261 2\u03c11\u2227...\u22272\u03c1n. It follows that \u03d5 is equivalent to 2\u03c11 \u2227 ...\u22272\u03c1n, which is a conjunction of clauses since the 2\u03c1i are all clauses.\nFinally, we consider \u03d5 = 3\u03c81. Using the induction hypothesis, we have \u03d5 \u2261 3(\u03c11 \u2227 ... \u2227 \u03c1n) for clauses \u03c1i. But since the \u03c1i are clauses, each \u03c1i is a disjunction of literals li,1 \u2228 ...\u2228 li,pi . After distributing \u2227 over \u2228 and \u2228 over 3, we find that \u03d5 is equivalent to the formula\n\u2228\n(j1,...,jn)\u2208{1,...,p1}\u00d7...\u00d7{1,...,pn}\n3(l1,j1 \u2227 l2,j2 \u2227 ... \u2227 ln,jn)\nwhich is a clause with respect to D5.\nThe proof that every formula is equivalent to a disjunction of terms with respect to D5 proceeds analogously.\nLemma 6.2 Every clause (resp. term) with respect to D5 is a clause (resp. term) with respect to definitions D3a, D3b, and D4.\nProof. We will show by induction on the structural complexity of formulae that:\n1. every clause C with respect to D5 is a clause with respect to definitions D3a, D3b, and D4 and a disjunction of terms with respect to D3a\n2. every term T with respect to D5 is a term with respect to definitions D3a, D3b, and D4 and a conjunction of clauses with respect to D3a and D3b\nWe require this stronger formulation of the statement to prove some of the sub-cases.\nThe base case for our induction is propositional literals, which are both clauses and terms with respect to D5. It is easy to see that (1) and (2) are verified since propositional literals are both clauses and terms with respect to definitions D3a, D3b, and D4 (and hence they are also disjunctions of terms with respect to D3a and conjunctions of clauses with respect to D3a and D3b).\nFor the induction step, we will show that the above statements hold for arbitrary clauses or terms with respect to D5 under the assumption that the statments hold for all of their proper sub-clauses and sub-terms.\nWe begin with clauses. Let C be a D5-clause such that all proper sub-clauses and subterms of C satisfy (1) and (2). Now since C is a clause with respect to D5, it can either be a propositional literal or a formula of the form C1 \u2228 C2 for clauses C1 and C2, 2C1 for some clause C1, or 3T1 for some term T1. The case where C is a propositional literal has already been treated in the base case. Let us thus consider the case where C = C1 \u2228 C2. The first part of (1) holds since by the induction hypothesis both C1 and C2 are clauses with respect to definitions D3a, D3b, and D4, and for all three definitions the disjunction of two clauses is a clause. The second half of (1) is also verified since both C1 and C2 are disjunctions of terms with respect to D3a, and thus so is their disjunction C1 \u2228 C2. We next consider the case where C = 2C1 for some clause C1 with respect to D5. The first part of (1) follows easily as we know that C1 must also be a clause with respect to D3a, D3b, and D4, and for all of these definitions putting a 2 before a clause yields another clause. The second part of (1) holds as well since C1 is a disjunction of terms with respect to D3a and thus 2C1 is a term with respect to this same definition. We now suppose that C = 3T1 for some term T1 with respect to D5. For definitions D3a and D3b, we know from the induction hypothesis that T1 is a conjunction of clauses with respect to D3a and D3b and hence that 3T1 is a clause with respect to these definitions. For D4, the result obviously holds since we are allowed to put any formula in NNF behind 3. The second part of (1) holds since by the induction hypothesis T1 is a term with respect to D3a and hence 3T1 is also a term with respect to this definition.\nWe next consider terms. Let T be a D5-term such that all proper sub-clauses and subterms of T satisfy (1) and (2). Then T must be either a propositional literal or a formula of the form T1 \u2227 T2 for terms T1 and T2, 2C1 for some clause C1, or 3T1 for some term T1. If T = T1 \u2227T2, the first half of (2) holds since we know T1 and T2 to be terms with respect to D3a, D3b, and D4, and conjunctions of terms are also terms for all three definitions. The second half is also verified since both T1 and T2 are assumed to be conjunctions of clauses with respect to D3a and D3b, which means that T is also a conjunction of clauses with respect to these definitions. Next suppose that T = 2C1. For definitions D3b and D4, it is easy to see that T is a literal and hence a term. For D3a, the induction hypothesis tells us that C1 is a disjunction of terms, from which we can deduce that 2C1 is a term. Moreover, since C1 is known to be a clause with respect to D3a and D3b, then 2C1 must also be a\nclause with respect to these definitions, so T is a conjunction of clauses with respect to both D3a and D3b. Finally, we treat the case where T = 3T1. For D3a, we use the fact that T1 is a term with respect to D3a, which means that 3T1 must also be a term. For D3b, we use the supposition that T1 is a conjunction of clauses with respect to D3b, from which we get that 3T1 is a literal and hence a term. The first part of (2) clearly also holds for D4 since any formula behind 3 yields a literal and thus a term. The second half of (2) follows from the fact that by the induction hypothesis T1 is a conjunction of clauses with respect to D3a and D3b, so 3T1 is a clause (and hence a conjunction of clauses) with respect to these definitions.\nLemma 6.3 Entailment between terms or clauses is NP-complete for both definitions D1 and D2.\nProof. In the proofs of both NP-membership and NP-hardness, we will exploit the relationship between terms with respect to definitions D1 and D2 and concept expressions in the description logic ALE (cf. Baader, McGuiness, Nardi, & Patel-Schneider, 2003). We recall that concept expressions in this logic are constructed as follows (we use a modal logic syntax and assume a single modal operator in order to facilitate comparison between the formalisms):\n\u03d5 ::= \u22a4 |\u22a5 | a | \u00aca |\u03d5 \u2227 \u03d5 |2\u03d5 |3\u03d5\nThe semantics of the symbols \u22a4 and \u22a5 is as one would expect: M, w |= \u22a4 and M, w 6|= \u22a5 for every model M and world w. The semantics of atomic literals, conjunctions, and universal and existential modalities is exactly the same as for K.\nIt is not hard to see that every term with respect to D1 or D2 is a concept expression in ALE. As entailment between ALE expressions is decidable in nondeterministic polynomial time (cf. Donini, Lenzerini, Nardi, Hollunder, Nutt, & Marchetti Spaccamela, 1992), it follows that deciding entailment between terms with respect to either D1 or D2 can also be accomplished in nondeterministic polynomial time, i.e. these problems belong to NP.\nIt remains to be shown that these problems are NP-hard. To prove this, we show how the polynomial-time reduction of Donini (2003) (adapted from the original NP-hardness proof by Donini et al., 1992) of the NP-complete exact cover (XC) problem (Garey &\nJohnson, 1979) to unsatisfiability in ALE can be modified so as to give a polynomial-time reduction from XC to entailment between terms with respect to D1 or D2.\nThe exact cover problem is the following: given a set U = {u1, ..., un} and a set S = {S1, ..., Sm} of subsets of U , determine whether there exists an exact cover, that is, a subset {Si1 , ..., Siq} of S such that Sih \u2229 Sik = \u2205 for h 6= k and \u22c3q k=1 Sik = U . Donini has proven (2003) that U ,S has an exact cover if and only if the formula \u03d5U ,S pictured in Figure 6 is unsatisfiable. Notice that \u03d5U ,S is not a term with respect to either D1 and D2 as it uses the symbols \u22a4 and \u22a5. We would like to find a similar formula which is a term with respect to our definitions and which is satisfiable if and only if \u03d5U ,S is. Consider the formula\n\u03d5\u2032U ,S = \u03d5 \u2032 1,1 \u2227 ... \u2227 \u03d5 \u2032 1,m \u2227 \u03c8 \u2032\nwhere \u03d5\u2032i,j and \u03c8 \u2032 are defined exactly like \u03d5i,j and \u03c8 except that we replace \u22a4 by a and \u22a5 by \u00aca. It is easy to verify that \u03d5\u2032U ,S is indeed a term with respect to both D1 and D2. Moreover, it is not too hard to see that \u03d51,1 \u2227 ... \u2227 \u03d51,m |= 3 2n\u22a4 if and only if \u03d5\u20321,1 \u2227 ... \u2227 \u03d5 \u2032 1,m |= 3 2na and hence that \u03d5U ,S and \u03d5 \u2032 U ,S are equisatisfiable. As U ,S has an exact cover if and only if \u03d5U ,S is unsatisfiable, and \u03d5U ,S is unsatisfiable just in the case that \u03d5\u2032U ,S is, it follows that U ,S has an exact cover if and only if \u03d5 \u2032 U ,S is unsatisfiable. Moreover, \u03d5\u2032U ,S can be produced in linear time from \u03d5U ,S , so we have a polynomial-time reduction from XC to unsatisfiability of terms in D1 or D2. But a formula is unsatisfiable just in the case that it entails the term a\u2227\u00aca. So, XC can be polynomially-reduced to entailment between terms with respect to either D1 or D2, making these problems NP-hard and hence NP-complete.\nIn order to show the NP-completeness of clausal entailment, we remark that for both definitions D1 and D2, the function Nnf transforms negations of clauses into terms and negations of terms into clauses. This means that we can test whether a clause \u03bb entails a clause \u03bb\u2032 by testing whether the term Nnf(\u00ac\u03bb\u2032) entails the term Nnf(\u00ac\u03bb). Likewise, we can test whether a term \u03ba entails another term \u03ba\u2032 by testing whether the clause Nnf(\u00ac\u03ba\u2032) entails the clause Nnf(\u00ac\u03ba). As the NNF transformation is polynomial, it follows that entailment between clauses is exactly as difficult as entailment between terms, so clausal entailment is NP-complete.\nLemma 6.4 For definition D5, entailment between clauses or terms is Pspace-complete.\nProof. Membership in Pspace is immediate since entailment between arbitrary formulae in K can be decided in polynomial space. To prove Pspace-hardness, we adapt an existing proof of Pspace-hardness of K.\nFigure 7 presents an encoding of a QBF \u03b2 = Q1p1...Qmpm\u03b8 in a K-formula f(\u03b2) that is used in section 6.7 of (Blackburn et al., 2001) to demonstrate the Pspace-hardness of K. The formula f(\u03b2) has the property that it is satisfiable just in the case that \u03b2 is a QBF-validity. As the formula f(\u03b2) can be generated in polynomial-time from \u03b2, and the QBF-validity problem is known to be Pspace-hard, it follows that satisfiability of formulae in K is Pspace-hard as well.\nIn Figure 8, we show a modified encoding. We claim the following:\n(1) f(\u03b2) and f \u2032(\u03b2) are logically equivalent\n(2) if \u03b8 is in CNF, then f \u2032(\u03b2) is a conjunction of clauses with respect to D5\n(3) if \u03b8 is in CNF, then f \u2032(\u03b2) can be generated in polynomial time from f(\u03b2)\nTo show (1), it suffices to show that (i)\u2261(i\u2019), (ii)\u2261(ii\u2019), (iiia)\u2261(iiia\u2019), (iiib)\u2261(iiib\u2019), (iv)\u2261(iv\u2019), and (v)\u2261(v\u2019). The first equivalence is immediate since (i) and (i\u2019) are identical. (ii)\u2261(ii\u2019) follows from the fact that 2k(qi \u2192 \u2227j 6=i\u00acqj) \u2261 \u2227j 6=i2\nk(\u00acqi \u2228 \u00acqj). (iiia)\u2261(iiia\u2019) holds since (iiia\u2019) is just (iiia) with qi \u2192 3qi+1 replaced with \u00acqi \u2228 3qi+1. We have (iiib)\u2261(iiib\u2019) since 2i(qi \u2192 (3(qi+1 \u2227 pi+1) \u2227 3(qi+1 \u2227 \u00acpi+1))) \u2261 2 i(\u00acqi \u2228 3(qi+1 \u2227 pi+1)) \u2227 2 i(\u00acqi \u2228 3(qi+1 \u2227 \u00acpi+1)). The equivalence (iv)\u2261(iv\u2019) holds as 2 j((pi \u2192 2pi) \u2227 (\u00acpi \u2192 2\u00acpi)) \u2261 2 j(\u00acpi \u22282pi) \u22272\nj(pi \u22282\u00acpi). Finally, we have (v)\u2261(v\u2019) since \u03b8 \u2261 \u03b81 \u2227 ... \u2227 \u03b8l. Thus, f(\u03b2) and f \u2032(\u03b2) are logically equivalent.\nTo prove (2), we show that each of the component formulae in f \u2032(\u03b2) is a conjunction of clauses with respect to D5, provided that \u03b8 is in CNF. Clearly this is the case for (i\u2019) as (i\u2019) is a propositional literal. The formula (ii\u2019) is also a conjunction of clauses with respect to D5 since it is a conjunction formulae of the form 2k(\u00acqi \u2228 \u00acqj). Similarly, (iiia\u2019), (iiib\u2019), and (iv\u2019) are all conjunctions of clauses since the formulae 2k(\u00acqi \u2228 3qi+1), 2 i(\u00acqi \u2228 3(qi+1 \u2227 pi+1)), 2 i(\u00acqi \u2228 3(qi+1 \u2227 \u00acpi+1)), 2 k(\u00acpi \u2228 2pi), and 2 k(pi \u2228 2\u00acpi) are all clauses with respect to D5. The formula (v\u2019) must also be a conjunction of clauses since the \u03b8i are assumed to be propositional clauses, making each 2\nm(\u00acqm \u2228 \u03b8i) a clause with respect to D5, and (v\u2019) a conjunction of clauses with respect to D5.\nFor (3), it is clear that we can transform (i), (iiia), (iiib), and (iv) into (i\u2019), (iiia\u2019), (iiib\u2019), and (iv\u2019) in polynomial time as the transformations involve only simple syntactic operations and the resulting formulae are at most twice as large. The transformation from (ii) to (ii\u2019) is very slightly more involved, but it is not too hard to see the resulting formula is at most m times as large as the original (and m can be no greater than the length of f(\u03b2)). The only step which could potentially result in an exponential blow-up is the transformation from (v) to (v\u2019), as we put \u03b8 into CNF. But under the assumption that \u03b8 is already in CNF, the transformation can be executed in polynomial time and space, as all we have to do is separate \u03b8 into its conjuncts and rewrite the (qm \u2192 \u03b8i) as (\u00acqm \u2228 \u03b8i).\nNow let \u03b2 = Q1p1...Qmpm\u03b8 be a QBF such that \u03b8 = \u03b81 \u2227 ... \u2227 \u03b8l for some propositional clauses \u03b8i. Let f\n\u2032(\u03b2) be the formula as defined in Figure 8. By (2) above, we know that f \u2032(\u03b2) = \u03bb1 \u2227 ... \u2227 \u03bbp for some clauses \u03bbi with respect to D5. Now consider the following formula\n\u03b6 = 3(2\u03bb1 \u2227 ... \u2227 2\u03bbp \u2227 32(a \u2228 \u00aca))\nWe can show that f \u2032(\u03b2) is satisfiable if and only if \u03b6 is satisfiable as follows:\n\u03b6 is unsatisfiable\n\u21d4 2\u03bb1 \u2227 ... \u2227 2\u03bbp \u2227 32(a \u2228 \u00aca) is unsatisfiable\n\u21d4 \u03bb1 \u2227 ... \u2227 \u03bbp \u2227 2(a \u2228 \u00aca) is unsatisfiable\n\u21d4 \u03bb1 \u2227 ... \u2227 \u03bbp is unsatisfiable \u21d4 f \u2032(\u03b2) is unsatisfiable\nBut we also know from (1) above that f \u2032(\u03b2) \u2261 f(\u03b2), and from (Blackburn et al., 2001) that f(\u03b2) is satisfiable just in the case that \u03b2 is a QBF validity. It is also easy to see that \u03b6 is satisfiable if and only if \u03b6 does not entail the contradiction 3(a \u2227 \u00aca). Putting this altogether, we find that \u03b2 is valid just in the case that \u03b6 does not entail 3(a \u2227 \u00aca). As \u03b6 and 3(a \u2227 \u00aca) are both clauses and terms with respect to D5, we have shown that the QBF-validity problem for QBF with propositional formulae in CNF can be reduced to the problems of entailment of clauses or terms with respect to D5. Moreover, this is a polynomial time reduction since it follows from (3) that the transformation from \u03b2 to \u03b6 can be accomplished in polynomial time. This suffices to show Pspace-hardness, since it is well-known that QBF-validity remains Pspace-hard even when we restrict the propositional part \u03b8 to be a formula in CNF (cf. Papadimitriou, 1994).\nTheorem 6 The results in Figure 1 hold.\nProof. The satisfaction or dissatisfaction of properties P1 and P2 can be immediately determined by inspection of the definitions, as can the satisfaction of P3 by definitions D2, D3b, D4, and D5. Counterexamples to P3 for definitions D1 and D3a were provided in body of the paper: the formula 2(a \u2228 b) is a clause but not a disjunction of literals with respect to both definitions.\nIn order to show that definition D3b does not satisfy P4, we remark that the negation of the literal 3(a \u2228 b) is equivalent to 2(\u00aca \u2227 \u00acb) which cannot be expressed as a literal in D3b. For each of the other definitions, it can be shown (by a straightforward inductive proof) that Nnf(\u00acL) is a literal whenever L is a literal, that Nnf(\u00acC) is a term whenever\nC is a clause, and that Nnf(\u00acT ) is a clause whenever T is a term. This is enough to prove that these definitions satisfy P4 since Nnf(\u03d5) is equivalent to \u03d5.\nSince we know that definitions D1 and D2 satisfy both properties P1 and P2, it follows by Theorem 5 that these definitions do not satisfy P5. We have seen in Lemma 6.1 that definition D5 does satisfy P5, i.e. that every formula is equivalent to some conjunction of clauses with respect to D5 and some disjunction of terms with respect to D5. As every clause (resp. term) of D5 is also a clause (resp. term) with respect to definitionsD3a, D3b, and D4 (by Lemma 6.2), it follows that every formula is equivalent to some conjunction of clauses and some disjunction of terms with respect to these definitions, which means they all satisfy P5.\nIt is easy to see that property P6 is satisfied by all of the definitions since all of our definitions are context-free grammars, and it is well-known that deciding membership for context-free grammars can be accomplished in polynomial time (cf. Younger, 1967).\nFrom Lemma 6.3, we know that deciding entailment between clauses or terms with respect to either D1 or D2 is NP-complete (and hence not in P, unless P=NP). Entailment between clauses/terms is Pspace-complete for D5 (Lemma 6.4). As every clause (resp. term) of D5 is also a clause (resp. term) with respect to definitions D3a, D3b, and D4 (from Lemma 6.2), it follows that entailment between clauses or terms is Pspace-hard for these definitions. Membership in Pspace is immediate since entailment between arbitary K formulae is in Pspace.\nWe prove Theorem 9 in several steps:\nLemma 9.1 The notions of prime implicates and prime implicants induced by D4 satisfy Implicant-Implicate Duality.\nProof. Suppose for a contradiction that we have a prime implicant \u03ba of some formula \u03d5 which is not equivalent to the negation of a prime implicate of \u00ac\u03d5. Let \u03bb be a clause which is equivalent to \u00ac\u03ba (there must exist such a clause because of property P4, cf. Theorem 6). The clause \u03bb is an implicate of \u00ac\u03d5 since \u03ba |= \u03d5 and \u03bb \u2261 \u00ac\u03ba. As we have assumed that \u03bb is not a prime implicate, there must be some implicate \u03bb\u2032 of \u00ac\u03d5 such that \u03bb\u2032 |= \u03bb and \u03bb 6|= \u03bb\u2032. But then let \u03ba\u2032 be a term equivalent to \u00ac\u03bb\u2032 (here again we use P4). Now \u03ba\u2032 must be an implicant of \u03d5 since \u00ac\u03d5 |= \u00ac\u03ba\u2032. Moreover, \u03ba\u2032 is strictly weaker than \u03ba since \u03bb\u2032 |= \u03bb and \u03bb 6|= \u03bb\u2032 and \u03ba \u2261 \u00ac\u03bb and \u03ba\u2032 \u2261 \u00ac\u03bb\u2032. But this means that \u03ba cannot be a prime implicant, contradicting our earlier assumption. Hence, we can conclude that every prime implicant of a formula \u03d5 is equivalent to the negation of some prime implicate of \u00ac\u03d5. The proof that every prime implicate of a formula \u03d5 is equivalent to the negation of a prime implicant of \u00ac\u03d5 proceeds analogously.\nLemma 9.2 If clauses and terms are defined according to definition D4, then every implicate \u03bb of a formula \u03d5 is entailed by some implicate \u03bb\u2032 of \u03d5 with var(\u03bb\u2032) \u2286 var(\u03d5) and with depth at most \u03b4(\u03d5) + 1, and every implicant \u03ba of \u03d5 entails an implicant \u03ba\u2032 of \u03d5 with var(\u03ba\u2032) \u2286 var(\u03d5) and depth at most \u03b4(\u03d5) + 1.\nProof. We intend to show that the following statement holds: for any formula \u03d5 and any implicate \u03bb of \u03d5, there exists a clause \u03bb\u2032 such that \u03d5 |= \u03bb\u2032 |= \u03bb and var(\u03bb\u2032) \u2286 var(\u03d5) and\n\u03b4(\u03bb) \u2264 \u03b4(\u03d5) + 1. So let \u03d5 be an arbitrary formula, and let \u03bb be some implicate of \u03d5. If \u03d5 is a tautology, then we can set \u03bb\u2032 = a \u2228 \u00aca (where a \u2208 var(\u03d5)). If \u03bb \u2261 \u22a5, then we can set \u03bb\u2032 = 3(a \u2227 \u00aca) (where a \u2208 var(\u03d5)), as this clause verifies all of the necessary conditions. Now we consider the case where neither \u03d5 nor \u03bb is a tautology or a falsehood, and we show how to construct the clause \u03bb\u2032. The first thing we do is use Dnf-4 to rewrite \u03d5 as a disjunction of satisfiable terms Ti with respect to D4 such that the Ti contain only the variables appearing in \u03d5 and have depth at most \u03b4(\u03d5):\n\u03d5 = T1 \u2228 ... \u2228 Tz\nAs \u03d5 |= \u03bb, it must be the case that Ti |= \u03bb for every Ti. Our aim is to find a clause \u03bbi for each of the terms Ti such that Ti |= \u03bbi |= \u03bb and var(\u03bbi) \u2286 var(Ti) and \u03b4(\u03bbi) \u2264 \u03b4(Ti). So consider some Ti. Since Ti is a term, it has the form \u03b31 \u2227 ...\u2227 \u03b3k \u22273\u03c81 \u2227 ...\u22273\u03c8m \u22272\u03c71 \u2227 ...\u22272\u03c7n, where \u03b31, ..., \u03b3k are propositional literals. As \u03bb is a clause, it must be of the form \u03c11 \u2228 ... \u2228 \u03c1p \u22283\u01eb1 \u2228 ... \u22283\u01ebq \u22282\u03b61 \u2228 ... \u22282\u03b6r, where \u03c11, ..., \u03c1p are propositional literals. As Ti |= \u03bb, it must be the case that the formula\n\u03b31 \u2227 ... \u2227 \u03b3k \u2227 3\u03c81 \u2227 ... \u2227 3\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n\u2227 \u00ac\u03c11 \u2227 ... \u2227 \u00ac\u03c1p \u2227 2\u00ac\u01eb1 \u2227 ... \u2227 2\u00ac\u01ebq \u2227 3\u00ac\u03b61 \u2227 ... \u2227 3\u00ac\u03b6r\nis unsatisfiable. By Theorem 1, one of the following must hold:\n(a) there exists \u03b3u and \u03c1v such that \u03b3u \u2261 \u03c1v\n(b) there exists \u03c8u such that \u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n \u2227 \u00ac\u01eb1 \u2227 ... \u2227 \u00ac\u01ebq |= \u22a5\n(c) there exists \u03b6u such that \u00ac\u03b6u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n \u2227 \u00ac\u01eb1 \u2227 ... \u2227 \u00ac\u01ebq |= \u22a5\nNow if (a) holds, we can set \u03bbi = \u03b3u since Ti |= \u03b3u |= \u03bb, \u03b4(\u03b3u) = 0 \u2264 \u03b4(Ti), and var(\u03b3u) \u2286 var(Ti). If it is (b) that holds, then it must be the case that\n\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n |= \u01eb1 \u2228 ... \u2228 \u01ebq\nand hence that 3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n) |= 3\u01eb1 \u2228 ... \u2228 3\u01ebq |= \u03bb\nWe can set \u03bbi = 3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n), since Ti |= 3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n) |= \u03bb, \u03b4(3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n)) \u2264 \u03b4(Ti), and var(3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n)) \u2286 var(Ti). Finally, if (c) holds, then it must be the case that\n\u03c71 \u2227 ... \u2227 \u03c7n |= \u01eb1 \u2228 ... \u2228 \u01ebq \u2228 \u03b6u\nand hence that 2(\u03c71 \u2227 ... \u2227 \u03c7n) |= 3\u01eb1 \u2228 ... \u2228 3\u01ebq \u2228 2\u03b6u |= \u03bb\nSo we can set \u03bbi = 2(\u03c71 \u2227 ...\u2227\u03c7n), as Ti |= 2(\u03c71\u2227 ...\u2227\u03c7n) |= \u03bb, \u03b4(2(\u03c71 \u2227 ...\u2227\u03c7n)) \u2264 \u03b4(Ti), and var(2(\u03c71 \u2227 ... \u2227 \u03c7n)) \u2286 var(Ti). Thus, we have shown that for every Ti, there is some \u03bbi such that Ti |= \u03bbi |= \u03bb and var(\u03bbi) \u2286 var(Ti) and \u03b4(\u03bbi) \u2264 \u03b4(Ti). But then \u03bb1 \u2228 ...\u2228 \u03bbz is a clause implied by every Ti, and hence by \u03d5, and such that var(\u03bbi) \u2286 \u222aivar(Ti) \u2286 var(\u03d5) and \u03b4(\u03bbi) \u2264 maxi \u03b4(Ti) \u2264 \u03b4(\u03d5).\nNow let \u03ba be an implicant of \u03d5, and let \u03bb be the formula Nnf(\u00ac\u03ba). We know that the NNF transformation is equivalence-preserving, hence \u03bb \u2261 \u00ac\u03ba, and it is straightforward\nto show that \u03bb must be a clause with respect to D4. But then \u03bb is an implicate of \u00ac\u03d5, so there must be some clause \u03bb\u2032 with var(\u03bb\u2032) \u2286 var(\u00ac\u03d5) = var(\u03d5) and depth at most \u03b4(\u00ac\u03d5) + 1 = \u03b4(\u03d5) + 1 such that \u00ac\u03d5 |= \u03bb\u2032 |= \u03bb. Let \u03ba\u2032 be Nnf(\u00ac\u03bb\u2032). It can be easily verified that \u03ba\u2032 is a term. Moreover, by properties of the NNF transformation, we have \u03ba\u2032 \u2261 \u00ac\u03bb\u2032, var(\u03ba\u2032) = var(\u00ac\u03bb\u2032) = var(\u03bb\u2032), and \u03b4(\u03ba\u2032) = \u03b4(\u00ac\u03bb\u2032) = \u03b4(\u03bb\u2032). But then \u03ba\u2032 is a term such that var(\u03ba\u2032) \u2286 var(\u03d5), \u03b4(\u03ba\u2032) \u2264 \u03b4(\u03d5) + 1, and \u03ba |= \u03ba\u2032 |= \u03d5.\nLemma 9.3 The notions of prime implicates and prime implicants induced by D4 satisfy Finiteness.\nProof. Consider an arbitrary formula \u03d5. From Lemma 9.2, we know that for each prime implicate \u03bb of \u03d5, there must be an implicate \u03bb\u2032 of \u03d5 containing only those propositional atoms appearing in \u03d5 and such that \u03b4(\u03bb\u2032) \u2264 \u03b4(\u03d5) + 1 and \u03bb\u2032 |= \u03bb. But since \u03bb is a prime implicate, we must also have \u03bb |= \u03bb\u2032 and hence \u03bb \u2261 \u03bb\u2032. Thus, every prime implicate of \u03d5 is equivalent to some clause built from the finite set of propositional symbols in \u03d5 and having depth at most \u03b4(\u03d5) + 1. As there are only finitely many non-equivalent formulae on a finite alphabet and with fixed depth, it follows that there can be only finitely many distinct prime implicates. By Lemma 9.1, every prime implicant of \u03d5 is equivalent to the negation of some prime implicate of \u00ac\u03d5. It follows then that every formula can only have finitely many distinct prime implicants.\nLemma 9.4 The notions of prime implicates and prime implicants induced by D4 satisfy Covering.\nProof. Let \u03d5 be an arbitrary formula. From Lemma 9.2, we know that every implicate of \u03d5 is entailed by some implicate of \u03d5 whose propositional variables are contained in var(\u03d5) and whose depth is at most \u03b4(\u03d5) + 1. Now consider the following set\n\u03a3 = {\u03c3 |\u03d5 |= \u03c3, \u03c3 is a clause, var(\u03c3) \u2286 var(\u03d5), \u03b4(\u03c3) \u2264 \u03b4(\u03d5) + 1}\nand define another set \u03a0 from \u03a3 as follows:\n\u03a0 = {\u03c3 \u2208 \u03a3 | 6 \u2203\u03c3\u2032 \u2208 \u03a3. \u03c3\u2032 |= \u03c3 and \u03c3 6|= \u03c3\u2032}\nIn other words, \u03a0 is the set of all of the logically strongest implicates of \u03d5 having depth at most \u03b4(\u03d5) + 1 and built from the propositional letters in \u03d5. We claim the following:\n(1) every \u03c0 \u2208 \u03a0 is a prime implicate of \u03d5\n(2) for every implicate \u03bb of \u03d5, there is some \u03c0 \u2208 \u03a0 such that \u03c0 |= \u03bb\nWe begin by proving (1). Suppose that (1) does not hold, that is, that there is some \u03c0 \u2208 \u03a0 which is not a prime implicate of \u03d5. Since \u03c0 is by definition an implicate of \u03d5, it follows that there must be some implicate \u03bb of \u03d5 such that \u03bb |= \u03c0 and \u03c0 6|= \u03bb. But by Lemma 9.2, there is some implicate \u03bb\u2032 of \u03d5 such that \u03b4(\u03bb\u2032) \u2264 \u03b4(\u03d5) + 1, var(\u03bb\u2032) \u2286 var(\u03d5), and \u03bb\u2032 |= \u03bb. But that means that \u03bb\u2032 is an element of \u03a3 which implies but is not implied by \u03c0, contradicting the assumption that \u03c0 is in \u03a0. We can thus conclude that every element of \u03a0 must be a prime implicate of \u03d5.\nFor (2): let \u03bb be some implicate of \u03d5. Then by Lemma 9.2, there exists some clause \u03bb\u2032 \u2208 \u03a3 such that \u03bb\u2032 |= \u03bb. If \u03bb\u2032 \u2208 \u03a0, we are done. Otherwise, there must exist some \u03c3 \u2208 \u03a3 such that \u03c3 |= \u03bb\u2032 and \u03bb\u2032 6|= \u03c3. If \u03c3 \u2208 \u03a0, we are done, otherwise, we find another stronger member of \u03a3. But as \u03a3 has finitely many elements modulo equivalence, after a finite number of steps, we will find some element which is in \u03a0 and which implies \u03bb. Since we have just seen that all members of \u03a0 are prime implicates of \u03d5, it follows that every implicate of \u03d5 is implied by some prime implicate of \u03d5.\nFor the second part of Covering, let \u03ba be an implicant of \u03d5, and let \u03bb be a clause equivalent to \u00ac\u03ba (there must be one because D4 satisfies P4). Now since \u03ba |= \u03d5, we must also have \u00ac\u03d5 |= \u03bb. According to what we have just shown, there must be some prime implicate \u03c0 of \u00ac\u03d5 such that \u00ac\u03d5 |= \u03c0 |= \u03bb. By Lemma 9.1, \u03c0 must be equivalent to the negation of some prime implicant \u03c1 of \u03d5. But since \u03c1 \u2261 \u00ac\u03c0 and \u03c0 |= \u03bb and \u03bb \u2261 \u00ac\u03ba, it follows that \u03ba |= \u03c1, completing the proof.\nLemma 9.5 The notions of prime implicates and prime implicants induced by D4 satisfy Equivalence.\nProof. Let \u03d5 be some formula in K, and suppose that M is a model of every prime implicate of \u03d5. As D4 is known to satisfy property P5 (by Theorem 6), we can find a conjunction of clauses which is equivalent to \u03d5. By Covering (Lemma 9.3), each of these clauses is implied by some prime implicate of \u03d5, so M must be a model of each of these clauses. It follows that M is a model of \u03d5. For the other direction, we simply note that by the definition of prime implicates if M is a model of \u03d5, then it must also be a model of every prime implicate of \u03d5. We have thus shown that M is a model of \u03d5 if and only if it is a model of every prime implicate of \u03d5. Using a similar argument, we can show that M is a model of \u03d5 if and only if it is a model of some prime implicant of \u03d5.\nLemma 9.6 The notions of prime implicates and prime implicants induced by D4 satisfy Distribution.\nProof. Let \u03bb be a prime implicate of \u03d51 \u2228 ... \u2228 \u03d5n. Now for each \u03d5i, we must have \u03d5i |= \u03bb. From Covering, we know that there must exist some prime implicate \u03bbi for each \u03d5i such that \u03bbi |= \u03bb. This means that the formula \u03bb1 \u2228 ... \u2228 \u03bbn (which is a clause because it is a disjunction of clauses) entails \u03bb. But since \u03bb is a prime implicate, it must also be the case that \u03bb |= \u03bb1\u2228 ...\u2228\u03bbn, and hence \u03bb \u2261 \u03bb1\u2228 ...\u2228\u03bbn. The proof for prime implicants is entirely similar.\nTheorem 9 The notions of prime implicates and prime implicants induced by definition D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality, and Distribution.\nProof. Follows directly from Lemmas 9.1-9.6.\nTheorem 10 The notions of prime implicates and prime implicants induced by definitions D1 and D2 do not satisfy Equivalence.\nProof. The proof is the same for both definitions. Suppose that Equivalence holds. Then for every formula \u03d5, the set \u03a0 of prime implicates of \u03d5 is equivalent to \u03d5. But this means that the set \u03a0\u222a {\u00ac\u03d5} is inconsistent, and hence by compactness of K (cf. Blackburn et al., 2001, p. 86) that there is some finite subset S \u2286 \u03a0 \u222a {\u00ac\u03d5} which is inconsistent. If \u03d5 6\u2261 \u22a5, then we know that the set S must contain \u00ac\u03d5 because the set of prime implicates of \u03d5 cannot be inconsistent. But then the conjunction of elements in S \\ {\u00ac\u03d5} is a conjunction of clauses which is equivalent to \u03d5. It follows that every formula \u03d5 is equivalent to some conjunction of clauses. As we have shown earlier in the proof of Theorem 5 that there are formulae which are not equivalent to a conjunction of clauses with respect to D1 or D2, it follows that Equivalence cannot hold for these definitions.\nTheorem 11 The notions of prime implicates and prime implicants induced by definitions D3a, D3b, and D5 do not satisfy Finiteness.\nProof. Suppose that clauses are defined with respect to definition D3a, D3b, or D5 (the proof is the same for all three definitions). Consider the formula \u03d5 = 2(a \u2227 b). It follows from Theorem 3 that \u03d5 implies \u03bbk = 2(3\nka) \u2228 3(a \u2227 b \u2227 2k\u00aca) for every k \u2265 1. As the formulae \u03bbk are clauses (with respect to D3a, D3b, and D5), the \u03bbk are all implicates of \u03d5. To complete the proof, we show that every \u03bbk is a prime implicate of \u03d5. Since the \u03bbk are mutually non-equivalent (because 2p\u00aca 6|= 2q\u00aca whenever p 6= q), it follows that \u03d5 has infinitely many prime implicates modulo equivalence.\nConsider some \u03bbk and some implicate \u00b5 = 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2\u03c71 \u2228 ... \u2228 2\u03c7n of \u03d5 that implies it (by Theorem 2 there cannot be any propositional literals in \u00b5). Using Theorem 3 and the fact that \u03d5 |= \u00b5 |= \u03bbk, we get the following:\n(a) a \u2227 b |= \u03c7i \u2228 \u03c8i \u2228 ... \u2228 \u03c8m for some \u03c7i\n(b) \u03c7i |= (3 ka) \u2228 (a \u2227 b \u2227 2k\u00aca) for every \u03c7i\n(c) \u03c81 \u2228 ... \u2228 \u03c8m |= a \u2227 b \u2227 2 k\u00aca\nLet \u03c7i be such that a \u2227 b |= \u03c7i \u2228 \u03c8i \u2228 ... \u2228 \u03c8m. We remark that \u03c7i must be satisfiable since otherwise we can combine (a) and (c) to get a\u2227b |= a\u2227b\u22272k\u00aca. Now by (b), we know that \u03c7i |= (3 ka)\u2228 (a\u2227 b\u22272k\u00aca) and hence that \u03c7i\u2227 (2 k\u00aca)\u2227 (\u00aca\u2228\u00acb\u22283ka) is inconsistent. It follows that both \u03c7i\u2227 (2 k\u00aca)\u2227\u00aca and \u03c7i\u2227 (2\nk\u00aca)\u2227\u00acb are inconsistent. Using Theorem 1, we find that either \u03c7i |= 3\nka or \u03c7i |= a \u2227 b. As \u03c7i is a satisfiable clause with respect to definitions D3a, D3b, and D5, it cannot imply a \u2227 b, so we must have \u03c7i |= 3\nka. By putting (a) and (c) together, we find that\na \u2227 b \u2227 \u00ac\u03c7i |= \u03c81 \u2228 ... \u2228 \u03c8m |= a \u2227 b \u2227 2 k\u00aca\nIt follows that \u00ac\u03c7i |= 2 k\u00aca, i.e. 3ka |= \u03c7i. We thus have \u03c7i \u2261 3 ka and \u03c81 \u2228 ... \u2228 \u03c8m \u2261 a \u2227 b \u2227 2k\u00aca. As 3ka |= \u03c7i and a \u2227 b \u2227 2\nk\u00aca |= \u03c81 \u2228 ... \u2228 \u03c8m, by Theorem 3 we get 2(3ka) \u2228 3(a \u2227 b \u2227 2k\u00aca) |= 2\u03c7i \u2228 3\u03c8i \u2228 ... \u2228 3\u03c8m |= \u00b5 and hence \u03bbk \u2261 \u00b5. We have thus shown that any implicate of \u03d5 which implies \u03bbk must be equivalent to \u03bbk. This means that each \u03bbk is a prime implicate of \u03d5, completing the proof.\nLemmas 12, 13, and 14 follow easily from known properties of the disjunctive normal form transformation in propositional logic (cf. Bienvenu, 2009, ch. 2).\nIn the proof of Theorem 16, we will make use of the following lemmas:\nLemma 16.1 The algorithm GenPI always terminates.\nProof. We know from Lemma 12 that the algorithm Dnf-4 always terminates and returns a finite set of formulae. This means that there are only finitely many terms T to consider. For each T , the set \u2206(T ) contains only finitely many elements (this is immediate given the definition of \u2206(T )), which means that the set Candidates also has finite cardinality. In the final step, we compare at most once each pair of elements in Candidates. As the comparison always terminates, and there are only finitely many pairs to check, it follows that the algorithm GenPI terminates.\nLemma 16.2 The algorithm GenPI outputs exactly the set of prime implicates of the input formula.\nProof. We first prove that every prime implicate of a satisfiable term T is equivalent to some element in \u2206(T ). Let T = \u03b31 \u2227 ... \u2227 \u03b3k \u2227 3\u03c81 \u2227 ... \u2227 3\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n be some satisfiable term, and let \u03bb = \u03c11 \u2228 ... \u2228 \u03c1p \u2228 3\u01eb1 \u2228 ... \u2228 3\u01ebq \u2228 2\u03b61 \u2228 ... \u2228 2\u03b6r be one of its prime implicates. We restrict our attention to the interesting case in which both T and \u03bb are non-tautologous. As T |= \u03bb, it must be the case that\n\u03b31 \u2227 ... \u2227 \u03b3k \u2227 3\u03c81 \u2227 ... \u2227 3\u03c8m \u2227 2\u03c71 \u2227 ... \u2227 2\u03c7n\u2227 \u00ac\u03c11 \u2227 ... \u2227 \u00ac\u03c1p \u2227 2\u00ac\u01eb1 \u2227 ... \u2227 2\u00ac\u01ebq \u2227 3\u00ac\u03b61 \u2227 ... \u2227 3\u00ac\u03b6r\nis unsatisfiable. By Theorem 1, one of the following must hold:\n(a) there exists \u03b3u and \u03c1v such that \u03b3u \u2261 \u03c1v\n(b) there exists \u03c8u such that \u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n |= \u01eb1 \u2228 ... \u2228 \u01ebq\n(c) there exists \u03b6u such that \u03c71 \u2227 ... \u2227 \u03c7n |= \u03b6u \u2228 \u01eb1 \u2228 ... \u2228 \u01ebq\nIf (a) holds, then \u03b3u |= \u03bb, so \u03bb must be equivalent to \u03b3u or else we would have found a stronger implicate, contradicting our assumption that \u03bb is a prime implicate of T . But then the result holds since \u03b3u is in \u2206(T ). If (b) holds, then the formula 3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n) is an implicate of T which implies \u03bb, so \u03bb \u2261 3(\u03c8u \u2227 \u03c71 \u2227 ... \u2227 \u03c7n). We are done since 3(\u03c8u \u2227\u03c71 \u2227 ...\u2227\u03c7r) is a member of \u2206(T ). Finally we consider the case where (c) holds. In this case, 2(\u03c71 \u2227 ...\u2227\u03c7n) is an implicate of T which implies \u03bb, and so is equivalent to \u03bb (as \u03bb is a prime implicate). But then we have the desired result since 2(\u03c71 \u2227 ... \u2227 \u03c7n) is one of the elements in \u2206(T ). Thus we can conclude that every prime implicate of a term T is equivalent to some element in \u2206(T ). By Lemma 13, the elements in Dnf-4(\u03d5) are terms, and their disjunction is equivalent to \u03d5. As D4 satisfies Distribution, it follows that every prime implicate of the input \u03d5 is equivalent to some element in Candidates. This means that if an element \u03bbi in Candidates is not a prime implicate of \u03d5, then there is some prime implicate \u03c0 of \u03d5 that implies but is not implied by \u03bbi, and hence some \u03bbj \u2208 Candidates such that \u03bbj |= \u03bbi and \u03bbi 6|= \u03bbj. Thus, during the comparison phase, this clause will be removed from Candidates. Now suppose that the clause \u03bb is a prime implicate of \u03d5. Then\nwe know that there must be some \u03bbi \u2208 Candidates such that \u03bbi \u2261 \u03bb, and moreover, we can choose \u03bbi so that there is no \u03bbj with j < i such that \u03bbj |= \u03bbi. When in the final step we compare \u03bbi with all the clauses \u03bbj with j 6= i, we will never find that \u03bbj |= \u03bbi for j < i, nor that \u03bbj |= \u03bbi 6|= \u03bbj for some j > i, otherwise \u03bb would not be a prime implicate. It follows then that \u03bbi remains in the set Candidates which is returned by the algorithm. We have thus shown that the set of formulae output by GenPI on input \u03d5 is precisely the set of prime implicates of \u03d5.\nTheorem 16 The algorithm GenPI always terminates and outputs exactly the set of prime implicates of the input formula.\nProof. Follows directly from Lemmas 16.1 and 16.2.\nTheorem 17 The length of the smallest clausal representation of a prime implicate of a formula is at most single exponential in the length of the formula.\nProof. Prime implicates generated by GenPI can have at most 2|\u03d5| disjuncts as there are at most 2|\u03d5| terms in Dnf-4(\u03d5) by Lemma 14. Moreover, each disjunct has length at most 2|\u03d5| (also by Lemma 14). This gives us a total of 2|\u03d5| \u2217 2|\u03d5| symbols, to which we must add the at most 2|\u03d5| \u2212 1 disjunction symbols connecting the disjuncts. We thus find that the length of the smallest representation of a prime implicate of a formula \u03d5 is at most 2|\u03d5| \u2217 2|\u03d5| + (2|\u03d5| \u2212 1).\nTheorem 18 The length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nProof. Consider the formula\n\u03d5 =\nn\u2227\ni=1\n(2ai,1 \u2228 2ai,2)\nand the clause\n\u03bb = \u2228\n(j1,...,jn)\u2208{1,2}n\n2(a1,j1 \u2227 a2,j2 \u2227 ... \u2227 an,jn)\nwhere ak,l 6= am,p whenever k 6= m or l 6= p. It is not difficult to see that \u03d5 and \u03bb are equivalent, which means that \u03bb must be a prime implicate of \u03d5. All that remains to be shown is that any clause equivalent to \u03bb must have length at least |\u03bb|. This yields the result since \u03bb clearly has size exponential in n, whereas the length of \u03d5 is only linear in n.\nLet \u03bb\u2032 be a shortest clause which is equivalent to \u03bb. As \u03bb\u2032 is equivalent to \u03bb, it follows from Theorem 2 that \u03bb\u2032 is a disjunction of 2-literals and of inconsistent 3-literals. But since \u03bb\u2032 is assumed to be a shortest representation of \u03bb, it cannot contain any inconsistent 3-literals or any redundant 2-literals, since we could remove them to find an equivalent shorter clause. So \u03bb\u2032 must be of the form 2\u03c71 \u2228 ... \u2228 2\u03c7m, where \u03c7l 6|= \u03c7k whenever l 6= k. Now since \u03bb\u2032 |= \u03bb, every disjunct 2\u03c7p must also imply \u03bb. As \u03bb is a disjunction of 2-literals, it follows from Theorem 3 that every disjunct 2\u03c7p of \u03bb\n\u2032 implies some disjunct 2\u03b4q of \u03bb. But that means that every 2\u03c7p must have length at least 2n + 1, since each \u03c7p is a satisfiable formula which implies a conjunction of n distinct propositional variables. We also know that every disjunct 2\u03b4q of \u03bb implies some disjunct 2\u03c7p of \u03bb \u2032 since \u03bb |= \u03bb\u2032. We now wish\nto show that no two disjuncts of \u03bb imply the same disjunct of \u03bb\u2032. Suppose that this is not the case, that is, that there are distinct disjuncts 2\u03b41 and 2\u03b42 of \u03bb and some disjunct 2\u03c7p of \u03bb\u2032 such that 2\u03b41 |= 2\u03c7p and 2\u03b42 |= 2\u03c7p. Now since 2\u03b41 and 2\u03b42 are distinct disjuncts, there must be some i such that 2\u03b41 |= ai,1 and 2\u03b42 |= ai,2 or 2\u03b41 |= ai,2 and 2\u03b42 |= ai,1. We know that 2\u03c7p |= 2\u03b4q for some \u03b4q, and that every \u03b4q implies either ai1 or ai2, so either 2\u03c7p |= 2ai1 or 2\u03c7p |= 2ai2. But we know that the 2\u03b4q each imply either 2ai,1 or 2ai,2 but not both, so one of 2\u03b41 and 2\u03b42 must not imply 2\u03c7p. This contradicts our earlier assumption that 2\u03b41 |= 2\u03c7p and 2\u03b42 |= 2\u03c7p, so each disjunct of \u03bb must imply a distinct disjunct of \u03bb\u2032. We have thus demonstrated that \u03bb\u2032 contains just as many disjuncts as \u03bb. As we have already shown that the disjuncts of \u03bb\u2032 are no shorter than the disjuncts of \u03bb, it follows that |\u03bb\u2032| \u2265 |\u03bb|, and hence |\u03bb\u2032| = |\u03bb|. We conclude that every clause equivalent to \u03bb has length at least |\u03bb|, completing the proof.\nFor Theorem 19, we will prove that the following clause\n\u03bb = \u2228\n(q1,...,qn)\u2208{3,2}n\n2q1...qn c\nis a prime implicate (with respect to both D1 and D2) of the formula\n\u03d5 = (23(b0 \u2227 b1) \u2228 22(b0 \u2227 b1) ) \u2227 n\u2227\ni=2\n(2i3bi \u2228 2 i 2bi )\n\u2227 n\u22121\u2227\ni=1\n2 i+1 ( (bi\u22121 \u2227 bi) \u2192 2bi ) \u2227 2 n+1 ( (bn\u22121 \u2227 bn) \u2192 c )\nand moreover that there is no shorter way to represent \u03bb.\nThe proof of Theorem 19 makes use of the following lemmas.\nLemma 19.1 Let l1 \u2228 ...\u2228 lm be a D1-clause which implies q1...qna, where qi \u2208 {2,3} and a is a propositional variable. Then l1 \u2228 ... \u2228 lm \u2261 q1...qna.\nProof. In the proof, we will make use of the fact that every D1-clause is satisfiable. This is very straightforwardly shown by structural induction. The base case is propositional literals, which are clearly satisfiable. For the induction step, we consider a D1-clause \u03bb such that all its proper sub-clauses are satisfiable. There are three possibilities: either \u03bb is of the form 2\u03c8 or 3\u03c8 where \u03c8 is a satisfiable D1-clause, or a disjunction \u03c81 \u2228 \u03c82 of satisfiable D1-clauses \u03c81 and \u03c82. In all three cases, we find that \u03bb must also be satisfiable.\nThe proof of the lemma is by induction on n. When n = 0, we have just l1\u2228 ...\u2228 lm |= a. According to Theorem 2, every disjunct of l1\u2228 ...\u2228 lm must be either a or some unsatisfiable formula. But we have shown in the previous paragraph that every D1-clause is satisfiable, so l1 \u2228 ... \u2228 lm \u2261 a.\nNow suppose the result holds whenever n \u2264 k, and suppose that we have l1 \u2228 ... \u2228 lm |= q1...qk+1a. For every li, we must have li |= q1...qk+1a, and hence |= \u00acli \u2228 q1...qk+1a. Using Theorem 1, we arrive at the following four possibilities:\n(a) |= q1...qk+1a\n(b) li \u2261 \u22a5\n(c) q1 = 3 and li \u2261 3l \u2032 i and l \u2032 i |= q2...qk+1a\n(d) q1 = 2 and li \u2261 2l \u2032 i and l \u2032 i |= q2...qk+1a\nWe can eliminate case (a) since 6|= q1...qk+1a for every string of modalities q1...qk+1. We can also eliminate (b) since all of the li must be satisfiable as they are D1-clauses. We remark that if (c) holds, then according to the induction hypothesis, li \u2261 3q2...qk+1a. Similarly, if (d) holds, then li \u2261 2q2...qk+1a. It follows then that each li is equivalent to q1...qk+1a, and so l1 \u2228 ... \u2228 lm \u2261 q1...qk+1a.\nLemma 19.2 Fix (q1, ..., qn) \u2208 {2,3} n, and let T = 2q1(b0 \u2227 b1) \u2227 ( \u2227n k=2 2\nkqkbk) \u2227\u2227n\u22121 k=1 2 k+1 ( (bk\u22121 \u2227 bk) \u2192 2bk ) \u2227 2 n+1 ( (bn\u22121 \u2227 bn) \u2192 c ). Then T |= 2r1...rnc if and only if rk = qk for all 1 \u2264 k \u2264 n.\nProof. We begin by showing that for all 1 \u2264 i \u2264 n\u2212 1 the formula\nbi\u22121 \u2227 bi \u2227 ( n\u2227\nk=i+1\n2 k\u2212i\u22121qkbk ) \u2227 (\nn\u22121\u2227\nk=i\n2 k\u2212i((bk\u22121 \u2227 bk) \u2192 2 bk) ) \u2227 2 n\u2212i((bn\u22121 \u2227 bn) \u2192 c)\nentails the formula ri+1...rnc just in the case that qi+1...qn = ri+1...rn.\nThe proof is by induction on i. The base case is i = n\u2212 1. We have\nbn\u22122 \u2227 bn\u22121 \u2227 qnbn \u2227 ((bn\u22122 \u2227 bn\u22121) \u2192 2bn\u22121) \u2227 2((bn\u22121 \u2227 bn) \u2192 c) |= rnc (1)\nif and only if\nbn\u22122 \u2227 bn\u22121 \u2227 qnbn \u2227 2bn\u22121 \u2227 2((bn\u22121 \u2227 bn) \u2192 c) |= rnc\nif and only if (Theorem 1) either\nqn = 3 and rn = 2 and bn\u22121 \u2227 ((bn\u22121 \u2227 bn) \u2192 c) |= c\nor\nqn = rn and bn\u22121 \u2227 bn \u2227 ((bn\u22121 \u2227 bn) \u2192 c) |= c\nAs bn\u22121 \u2227 ((bn\u22121 \u2227 bn) \u2192 c) 6|= c, we cannot have the first alternative. It follows then that if Equation (1) holds, then the second alternative must hold, in which case we get qn = rn, as desired. For the other direction, we simply note that bn\u22121 \u2227 bn \u2227 ((bn\u22121 \u2227 bn) \u2192 c) |= c is a valid entailment, which means qn = rn implies Equation (1).\nNext let us suppose that the above statement holds for all 1 < j \u2264 i \u2264 n\u2212 1, and let us prove the statement holds when i = j \u2212 1. Then\nbj\u22122 \u2227 bj\u22121 \u2227 ( n\u2227\nk=j\n2 k\u2212jqk bk) \u2227 (\nn\u22121\u2227\nk=j\u22121\n2 k\u2212j+1(bk\u22121 \u2227 bk \u2192 2bk) )\n\u2227 2n\u2212j+1((bn\u22121 \u2227 bn) \u2192 c) |= rj ...rnc (2)\nif and only if one of the following holds:\n(a) qj = 3 and rj = 2 and\nbj\u22121 \u2227 ( n\u2227\nk=j+1\n2 k\u2212j\u22121qk bk) \u2227 (\nn\u22121\u2227\nk=j\n2 k\u2212j((bk\u22121 \u2227 bk) \u2192 2bk) ) \u2227 2 n\u2212j((bn\u22121 \u2227 bn) \u2192 c)\n|= rj+1...rnc\n(b) qj = rj and\nbj\u22121 \u2227 bj \u2227 ( n\u2227\nk=j+1\n2 k\u2212j\u22121qkbk) \u2227 (\nn\u22121\u2227\nk=j\n2 k\u2212j((bk\u22121 \u2227 bk) \u2192 2bk)) \u2227 2 n\u2212j((bn\u22121 \u2227 bn) \u2192 c)\n|= rj+1...rnc\nWe will first show that the entailment in (a) does not hold. Consider the model M = \u3008W,R, v\u3009 defined as follows:\n\u2022 W = {wj , ..., wn}\n\u2022 R = {(wj , wj+1), ..., (wn\u22121, wn)}\n\u2022 v(c, w) = false for all w \u2208 W\n\u2022 for w 6= wj : v(bk, w) = true if and only if w = wk\n\u2022 v(bk, wj) = true if and only if k = j \u2212 1\nNotice that since each world (excepting wn) has exactly one successor, the 2- and 3- quantifiers have the same behaviour (except at wn). It can easily be verified that M, wj satisfies the left-hand side of the above entailment for any tuple qj+1...qn: we have M, wj |= bj\u22121 by definition, we have M, wj |= \u2227n k=j+1 2 k\u2212j\u22121qk bk because M, wk |= bk for k 6= j, we have M, wj |= \u2227n\u22121 k=j 2 k\u2212j((bk\u22121 \u2227 bk) \u2192 2bk) ) since M, wj 6|= bj and M, wk 6|= bk\u22121 for k 6= j, and finally we have M, wj |= 2 n\u2212j((bn\u22121 \u2227 bn) \u2192 c) since wn 6|= bn\u22121. However, the right-hand side rj+1...rnc is not satisfied at wj: the only world accessible from wj in n\u2212 j steps is wn which does not satisfy c.\nWe have just shown that case (a) cannot hold, which means that Equation (2) holds if and only if (b) does. But if we apply the induction hypothesis to the entailment in (b), we find that it holds just in the case that qj+1...qn = rj+1...rn. It follows then that Equation (2) if and only if qj...qn = rj...rn, as desired. This completes our proof of the above statement.\nWe now proceed to the proof of the lemma. By Theorem 1,\n2q1(b0 \u2227 b1) \u2227 ( n\u2227\nk=2\n2 kqkbk) \u2227 (\nn\u22121\u2227\nk=1\n2 k+1 ( (bk\u22121 \u2227 bk) \u2192 2bk ) \u2227 2 n+1 ( (bn\u22121 \u2227 bn) \u2192 c )\n|= 2r1...rnc\nholds just in the case that\nq1(b0 \u2227 b1) \u2227 ( n\u2227\nk=2\n2 k\u22121qkbk) \u2227\nn\u22121\u2227\nk=1\n2 k ( (bk\u22121 \u2227 bk) \u2192 2bk ) \u2227 2 n ( (bn\u22121 \u2227 bn) \u2192 c )\n|= r1...rnc\nwhich in turn holds if and only if one of the following statements holds:\n(i) q1 = 3 and r1 = 2 and\n(\nn\u2227\nk=2\n2 k\u22122qkbk ) \u2227 (\nn\u22121\u2227\nk=1\n2 k\u22121((bk\u22121 \u2227 bk) \u2192 2bk) ) \u2227 2 n\u22121((bn\u22121 \u2227 bn) \u2192 c) |= r2...rnc\n(ii) q1 = r1 and\nb0 \u2227 b1 \u2227 ( n\u2227\nk=2\n2 k\u22122qkbk ) \u2227 (\nn\u22121\u2227\nk=1\n2 k\u22121((bk\u22121 \u2227 bk) \u2192 2bk) ) \u2227 2 n\u22121((bn\u22121 \u2227 bn) \u2192 c)\n|= r2...rnc\nWe remark that if we set j = 1 in (a) above, then the left-hand side of the entailment in (i) is logically weaker than that in (a), and the right-hand side matches that in (a). As we have already shown that the entailment in (a) does not hold, it follows that the entailment in (i) cannot hold either. Thus, we find that the desired entailment relation in the statement of the lemma holds if and only if (ii) does. This completes the proof since we have already shown in the induction above that the entailment in (ii) holds if and only if q2...qn = r2...rn, i.e. (ii) is true just in the case that q1...qn = r1 = rn.\nLemma 19.3 There is no D1-clause equivalent to \u03bb and with strictly smaller size than \u03bb.\nProof. Let \u03bb\u2032 be a D1-clause which is equivalent to \u03bb. Suppose furthermore that \u03bb\u2032 is a shortest such clause. As \u03bb is non-tautologous and contains only 2-literals as disjuncts, it follows that every disjunct of \u03bb\u2032 must be either unsatisfiable or a 2-literal (cf. Theorem 2). But D1-clauses are always satisfiable (cf. proof of Lemma 19.1), so \u03bb\u2032 must contain only 2-literals.\nSince \u03bb\u2032 |= \u03bb, every disjunct 2l of \u03bb\u2032 must imply some disjunct 2q1...qnc of \u03bb. Also, every disjunct 2l of \u03bb\u2032 must be implied by some disjunct 2q1...qnc of \u03bb, since otherwise we could remove 2l from \u03bb\u2032 while preserving the equivalence between \u03bb and \u03bb\u2032.\nIt follows then that each disjunct of \u03bb\u2032 is implied by some disjunct of \u03bb and implies some disjunct of \u03bb. But since the disjuncts of \u03bb do not imply each other (because of Lemma 19.1), it follows that each disjunct of \u03bb\u2032 is equivalent to some disjunct of \u03bb, and moreover that every disjunct of \u03bb is equivalent to some disjunct of \u03bb\u2032.\nThis completes the proof since it is clear that the disjuncts 2q1...qnc of \u03bb cannot be more compactly represented.\nOur proof works equally well for D2, since every D2-clause is also a D1-clause.\nTheorem 19 If prime implicates are defined using either D1 or D2, then the length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nProof. We begin with definition D1. Let \u03bb and \u03d5 be as defined on page 112. We begin by distributing \u2228 over \u2227 in order to transform \u03d5 into an equivalent disjunction of D4-terms:\n\u03d5 \u2261 \u2228\n(q1,...,qn)\u2208{2,3}n\nTq1,...,qn\nwhere Tq1,...,qn is equal to\n2q1(b0 \u2227 b1) \u2227 ( n\u2227\ni=2\n2 iqibi) \u2227\nn\u22121\u2227\ni=1\n2 i+1 ( (bi\u22121 \u2227 bi) \u2192 2bi ) \u2227 2 n+1 ( (bn\u22121 \u2227 bn) \u2192 c )\nBy Lemma 19.2, Tq1,...,qn |= 2q1...qnc, and hence Tq1,...,qn |= \u03bb. We thus have \u03d5 |= \u03bb. We now show that there is no stronger clause with respect to D1 which is implied by \u03d5. Let \u03bb\u2032 be a D1-clause such that \u03d5 |= \u03bb\u2032 |= \u03bb. As \u03bb is a non-tautologous disjunction of 2-literals, we know from Lemma 2 that every disjunct of \u03bb\u2032 must be of the form 2l where l is a D1-clause such that l |= r1...rnc for some quantifier string r1...rn. But according to Lemma 19.1, if l |= r1...rnc, then l is equivalent to r1...rnc. It follows that \u03bb\n\u2032 is equivalent to a clause having only disjuncts of the forms 2r1...rnc.\nAs \u03d5 |= \u03bb\u2032, it must be the case that each of the terms Tq1,...,qn implies \u03bb \u2032, or equivalently Tq1,...,qn \u2227 \u00ac\u03bb \u2032 |= \u22a5. As we have shown above that the disjuncts of \u03bb\u2032 are all 2-literals, it follows from Theorem 1 that each term implies some disjunct of \u03bb\u2032. Moreover, we know from the preceding paragraph that each of the disjuncts of \u03bb\u2032 is equivalent to some formula of the form 2r1...rnc. By Lemma 19.2, the only formula of this type which is implied by Tq1,...,qn is the formula 2q1...qnc. This means that for every tuple of quantifiers (q1, ..., qn), there is a disjunct of \u03bb\u2032 which is equivalent to 2q1...qnc. It follows that every disjunct of \u03bb is equivalent to some disjunct of \u03bb\u2032, giving us \u03bb |= \u03bb\u2032. We can thus conclude that \u03bb is a prime implicate of \u03d5.\nThis completes the proof, since we have already shown in Lemma 19.3 that there is no shorter D1-clause which is equivalent to \u03bb than \u03bb itself.\nThe above proof also works for definition D2 since every D2-clause is also a D1-clause. In particular this means that any D2-clause which is a prime implicate with respect to D1 is also a prime implicate with respect to D2, and that any D2-clause which is shortest among all equivalent D1-clauses is also shortest among D2-clauses.\nTheorem 20 The number of non-equivalent prime implicates of a formula is at most double exponential in the length of the formula.\nProof. We know from Theorem 16 that every prime implicate of \u03d5 is equivalent to some clause returned by GenPI. Every such clause is of the form \u2228\nT\u2208Dnf-4(\u03d5) \u03b8T where \u03b8T \u2208\n\u2206(T ). As there can be at most 2|\u03d5| terms in Dnf-4(\u03d5) by Lemma 14, these clauses can have no more than 2|\u03d5| disjuncts. Moreover, there are at most 2|\u03d5| choices for each disjunct \u03b8T since the cardinality of \u2206(T ) is bounded above by the size of T , which we know from Lemma 1.3 to be no more than 2|\u03d5|. It follows then that there are at most (2|\u03d5|)2 |\u03d5| clauses returned by GenPI, hence at most (2|\u03d5|)2 |\u03d5| non-equivalent prime implicates of \u03d5.\nTheorem 21 The number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nProof. Let n be some natural number, and let a11, a12, ..., an1, an2, b11, b12, b12, ..., bn1, bn2 be 4n distinct propositional variables. Consider the formula \u03d5 defined as\nn\u2227\ni=1\n((3ai1 \u2227 2bi1) \u2228 (3ai2 \u2227 2bi2))\nIt is not hard to see that there will be 2n terms in Dnf-4(\u03d5), corresponding to the 2n ways of deciding for each i \u2208 {1, ..., n} whether to take the first or second disjunct. Each term T \u2208 Dnf-4(\u03d5) will be of the form\nn\u2227\ni=1\n(3ai f(i,T ) \u2227 2bi f(i,T ))\nwhere f(i, T ) \u2208 {1, 2} for all i. For each T , denote by D(T ) the set of formulae {3(a f(i,T )\u2227 b1 f(1,T ) \u2227 ... \u2227 bnf(n,T ))) | 1 \u2264 i \u2264 n}. Now consider the set of clauses C defined as\n{ \u2228\nT\u2208Dnf-4(\u03d5)\ndT | dT \u2208 D(T )}\nNotice that there are n2 n clauses in C since each clause corresponds to a choice of one of the n elements in D(T ) for each of the 2n terms T in Dnf-4(\u03d5). This number is double exponential in |\u03d5| since the length of \u03d5 is linear in n. In order to complete the proof, we show that (i) all of the clauses in C are prime implicates of \u03d5 and (ii) that the clauses in C are mutually non-equivalent.\nWe begin by showing that \u03bb1 6|= \u03bb2 for every pair of distinct elements \u03bb1 and \u03bb2 in C. This immediately gives us (ii) and will prove useful in the proof of (i). Let \u03bb1 and \u03bb2 be distinct clauses in C. As \u03bb1 and \u03bb2 are distinct, there must be some term T \u2208 Dnf-4(\u03d5) for which \u03bb1 and \u03bb2 choose different elements from D(T ). Let d1 be the element from D(T ) appearing as a disjunct in \u03bb1, let d2 be the element in D(T ) which is a disjunct in \u03bb2, and let aj,k be the a-literal which appears in d2 (and hence not in d1). Consider the formula \u03c1 = 2(\u00acaj,k \u2227\u00acb1,k1 \u2227 ...\u2227\u00acbn,kn), where the tuple (k1, ..., kn) is just like the tuple associated with T except that the 1\u2019s and 2\u2019s are inversed. Clearly d1 \u2227 \u03c1 is consistent, since the variables in \u03c1 do not appear in d1. But \u03c1 is inconsistent with every disjunct in \u03bb2, since by construction every disjunct in \u03bb2 contains a literal whose negation appears in \u03c1. It follows that \u03bb2 |= \u00ac\u03c1 but \u03bb1 6|= \u00ac\u03c1, and hence \u03bb1 6|= \u03bb2.\nWe now prove (i). Let \u03bb be a clause in C, and let \u03c0 be a prime implicate of \u03d5 which implies \u03bb. By Theorem 16, we know that \u03c0 must be equivalent to one of the clauses output by GenPI, and more specifically to a clause output by GenPI which is a disjunction of 3-literals (because of Theorem 2). We remark that the set C is composed of exactly those candidate clauses which are disjunctions of 3-literals, so \u03c0 must be equivalent to some clause in C. But we have just shown that the only element in C which implies \u03bb is \u03bb itself. It follows that \u03c0 \u2261 \u03bb, which means that \u03bb is a prime implicate of \u03d5.\nTheorem 22 If prime implicates are defined using either D1 or D2, then the number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nProof. Let \u03bb and \u03d5 be as defined on page 112. Set \u03d5\u2032 equal to the formula obtained from \u03d5 by replacing c in the last conjunct of \u03d5 by c \u2227 d. Set \u03a3 equal to the set of clauses that can be obtained from \u03bb by replacing zero or more occurrences of c by d. For example, if n = 1, then \u03a3 = {23c \u2228 22c,23d \u2228 22c,23c \u2228 22d,23d \u2228 22d}. There are 22 n elements in \u03a3 since we choose for each of the 2n disjuncts of \u03bb whether to change c into d. We intend\nto show that the clauses in \u03a3 are all pairwise non-equivalent prime implicates of \u03d5\u2032. The proof that every element in \u03a3 is indeed a prime implicate of \u03d5\u2032 (with respect to both D1 and D2) proceeds quite similarly to the proof that \u03bb is a prime implicate of \u03d5 (see proof of Theorem 19), so we will not repeat it here. Instead we will show that all of the elements in \u03a3 are pairwise non-equivalent. To do so, we consider any two distinct elements \u03b1 and \u03b2 of \u03a3. Since \u03b1 and \u03b2 are distinct, there must be some string of quantifiers q1...qn such that \u03b1 has a disjunct 2q1...qn\u03b3 (\u03b3 \u2208 {c, d}) which is not a disjunct of \u03b2. Now if \u03b1 |= \u03b2, then we would have 2q1...qn\u03b3 |= \u03b2, and hence 2q1...qn\u03b3 |= 2r1...rn\u03b6 for some disjunct r1...rn\u03b6 of \u03b2. But by using Lemma 19.1, we see that this can only happen if r1...rn = q1...qn and \u03b3 = \u03b6 , i.e. if 2q1...qn is a disjunct of \u03b2. This is a contradiction, so we must have \u03b1 6|= \u03b2. It follows that the elements of \u03a3 are pairwise non-equivalent, and hence that \u03d5\u2032 possesses a double exponential number of prime implicates.\nTheorem 23 There exists an algorithm which runs in single-exponential space in the size of the input and incrementally outputs, without duplicates, the set of prime implicates of the input formula.\nProof. Let the sets T and Candidates and the function \u2206 be defined as in Figure 3. We assume that T is ordered: T = {T1, ..., Tn}. For each Ti \u2208 T , we let max i denote the number of elements in \u2206(Ti), and we assume an ordering on the elements of \u2206(Ti): \u2206(Ti) = {\u03c4i,1, ..., \u03c4i,max i}. Notice that the tuples in {1, ..,max 1}\u00d7 ...\u00d7{1, ...,max n} can be ordered using the standard lexicographic ordering <lex: (a1, ..., an) <lex (b1, ..., bn) if and only if there is some 1 \u2264 j \u2264 n such that aj < bj and ak \u2264 bk for all 1 \u2264 k \u2264 j \u2212 1. Now set maxindex = \u03a0ni=1maxi, and let f : {1, ..,max 1}\u00d7 ...\u00d7{1, ...,maxn} \u2192 {1, ...,maxindex } be the bijection defined as follows: f(a1, ..., an) = m if and only if (a1, ..., an) is the m-th tuple in the lexicographic ordering of {1, ..,max 1} \u00d7 ... \u00d7 {1, ...,max n}. We will denote by \u03bbm the unique clause of form \u03c41,a1 \u2228 ... \u2228 \u03c4n,an such that f(a1, ..., an) = m. We remark that given an index m \u2208 {1, ...,maxindex } and the sets \u2206(T1), ..., \u2206(Tn), it is possible to generate in polynomial space (in the size of the sets \u2206(T1), ..., \u2206(Tn)) the clause \u03bbm. We make use of this fact in our modified version of algorithm GenPI, which is defined as follows:\nFunction IterGenPI(\u03d5) (1) Same as in GenPI. (2) Same as in GenPI. (3) For i = 1 to maxindex : if \u03bbj 6|= \u03bbi for all j < i and either \u03bbj 6|= \u03bbi or \u03bbi |= \u03bbj\nfor every i < j \u2264 maxindex , then output \u03bbi.\nThe proofs of termination, correctness, and completeness of IterGenPI are very similar to corresponding results for GenPI (Theorem 16), so we will omit the details. We will instead focus on the spatial complexity of IterGenPI. The first step of IterGenPI clearly runs in single-exponential space in |\u03d5|, since deciding the satisfiability of \u03d5 takes only polynomial space in |\u03d5|, and generating the elements in Dnf-4(\u03d5) takes at most single-exponential space in |\u03d5| (refer to Lemma 14). Step 2 also uses no more than singleexponential space in |\u03d5|, since each of the sets \u2206(T ) associated with a term Ti \u2208 T has polynomial size in Ti. Finally, for Step 3, we use the above observation that the generation of a given \u03bbi from its index i can be done in polynomial space in the size of the sets\n\u2206(T1), ..., \u2206(Tn), and hence in single-exponential space in |\u03d5|. This is sufficient since for the comparisons in Step 3, we only need to keep two candidate clauses in memory at any one time, and deciding whether one candidate clause entails another can be accomplished in single-exponential space (since both clauses have single-exponential size in |\u03d5|).\nTheorem 24 Prime implicate recognition is Pspace-hard.\nProof. The reduction is simple: a formula \u03d5 is unsatisfiable if and only if 3(a \u2227 \u00aca) is a prime implicate of \u03d5. This suffices as the problem of checking the unsatisfiability of formulae in K is known to be Pspace-complete.\nWe will need the following two lemmas for Theorem 25:\nLemma 25.1 Let \u03d5 be a formula from K, and let \u03bb = \u03b31 \u2228 ... \u2228 \u03b3k \u2228 3\u03c81 \u2228 ... \u2228 3\u03c8m \u2228 2\u03c71 \u2228 ...\u22282\u03c7n (\u03b3j propositional literals) be a non-tautologous clause. Suppose furthermore that there is no literal l in \u03bb such that \u03bb \u2261 \u03bb \\ {l}. If \u03bb \u2208 \u03a0(\u03d5), then \u03b31 \u2228 ... \u2228 \u03b3k \u2208 \u03a0(\u03d5\u2227\u00ac(\u03bb \\{\u03b31, ..., \u03b3k})) and 3(\u03c81 \u2228 ...\u2228\u03c8n) \u2208 \u03a0(\u03d5\u2227\u00ac(\u03bb \\{3\u03c81, ...,3\u03c8m})) and for every i, 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})).\nProof. We will prove the contrapositive: if \u03b31 \u2228 ... \u2228 \u03b3k 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k})) or 3(\u03c81 \u2228 ... \u2228 \u03c8n) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m})) or there is some i for which 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})), then \u03bb 6\u2208 \u03a0(\u03d5). We will only consider the case where \u03d5 |= \u03bb because if \u03d5 6|= \u03bb then we immediately get \u03bb 6\u2208 \u03a0(\u03d5).\nLet us first suppose that \u03b31\u2228...\u2228\u03b3k 6\u2208 \u03a0(\u03d5\u2227\u00ac(\u03bb\\{\u03b31, ..., \u03b3k})). Since \u03d5 |= \u03bb, we must also have \u03d5\u2227\u00ac(\u03bb\\{\u03b31, ..., \u03b3k}) |= \u03b31\u2228...\u2228\u03b3k, so \u03b31\u2228...\u2228\u03b3k is an implicate of \u03d5\u2227\u00ac(\u03bb\\{\u03b31, ..., \u03b3k}). As \u03b31 \u2228 ...\u2228 \u03b3k is known not to be a prime implicate of \u03d5\u2227\u00ac(\u03bb \\{\u03b31, ..., \u03b3k}), it follows that there must be some clause \u03bb\u2032 such that \u03d5\u2227\u00ac(\u03bb\\{\u03b31, ..., \u03b3k}) |= \u03bb \u2032 |= \u03b31\u2228 ...\u2228\u03b3k 6|= \u03bb \u2032. Now consider the clause \u03bb\u2032\u2032 = \u03bb\u2032\u22283\u03c81\u2228 ...\u22283\u03c8m\u22282\u03c71\u2228 ...\u22282\u03c7n. We know that \u03d5 |= \u03bb \u2032\u2032 since \u03d5\u2227\u00ac(\u03bb\\{\u03b31, ..., \u03b3k}) |= \u03bb \u2032, and that \u03bb\u2032\u2032 |= \u03bb because \u03bb\u2032 |= \u03b31\u2228 ...\u2228\u03b3k. We also have \u03bb 6|= \u03bb \u2032\u2032 since \u03bb\u2032 must be equivalent to a propositional clause (by Theorem 2) and the propositional part of \u03bb (namely \u03b31 \u2228 ... \u2228 \u03b3k) does not imply \u03bb\n\u2032. It follows then that \u03d5 |= \u03bb\u2032\u2032 |= \u03bb 6|= \u03bb\u2032\u2032, so \u03bb 6\u2208 \u03a0(\u03d5).\nNext suppose that 3(\u03c81\u2228 ...\u2228\u03c8n) 6\u2208 \u03a0(\u03d5\u2227\u00ac(\u03bb\\{3\u03c81, ...,3\u03c8m})). Now 3(\u03c81\u2228 ...\u2228\u03c8n) must be an implicate of \u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m}) since we have assumed that \u03d5 |= \u03bb. As 3(\u03c81 \u2228 ... \u2228 \u03c8n) is not a prime implicate of \u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m}), it follows that there is some \u03bb\u2032 such that \u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m}) |= \u03bb \u2032 |= 3(\u03c81 \u2228 ... \u2228 \u03c8n) 6|= \u03bb \u2032. Let \u03bb\u2032\u2032 = \u03b31\u2228...\u2228\u03b3k\u2228\u03bb \u2032\u22282\u03c71\u2228...\u22282\u03c7n. Because of Theorem 2, we know that \u03bb\n\u2032 is a disjunction of 3-literals, so according to Theorem 3 we must have \u03bb 6|= \u03bb\u2032\u2032 since 3(\u03c81 \u2228 ... \u2228 \u03c8n) 6|= \u03bb\n\u2032. We also know that \u03d5 |= \u03bb\u2032\u2032 since \u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m}) |= \u03bb\n\u2032 and that \u03bb\u2032\u2032 |= \u03bb since \u03bb\u2032 |= 3(\u03c81 \u2228 ... \u2228 \u03c8n). That means that \u03d5 |= \u03bb\n\u2032\u2032 |= \u03bb 6|= \u03bb\u2032\u2032, so \u03bb 6\u2208 \u03a0(\u03d5). Finally consider the case where there is some i for which 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})). We know that \u03d5 |= \u03bb and hence that \u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i}) |= 2\u03c7i. Moreover, since \u00ac(\u03bb \\ {2\u03c7i}) |= \u00ac3\u03c8j for all j, we have \u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i}) |= 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m). Thus, if 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})), it must mean that there is some \u03bb\u2032 such that \u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i}) |= \u03bb \u2032 |= 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6|= \u03bb \u2032. By assumption, \u03bb is not a tautology, so 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) cannot be a tautology\neither. As \u03bb\u2032 |= 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) and 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) is not a tautology, it follows from Theorem 2 that \u03bb\u2032 is equivalent to some formula 2\u03b61 \u2228 ... \u2228 2\u03b6p. Let \u03bb\u2032\u2032 = \u03b31\u2228 ...\u2228 \u03b3k \u22283\u03c81 \u2228 ...\u22283\u03c8m \u22282\u03c71 \u2228 ...\u22282\u03c7i\u22121 \u2228 (2\u03b61\u2228 ...\u22282\u03b6p)\u22282\u03c7i+1 \u2228 ...\u22282\u03c7n. As \u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i}) |= 2\u03b61 \u2228 ... \u2228 2\u03b6p, it must be the case that \u03d5 |= \u03bb\n\u2032\u2032. Also, we know that there can be no j such that \u03c7i |= \u03b6j \u2228 \u03c81 \u2228 ... \u2228 \u03c8m because otherwise we would have \u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m |= \u03b6j and hence 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) |= 2\u03b61 \u2228 ... \u2228 2\u03b6p. Similarly, there can be no k 6= i such that 2\u03c7i |= 2(\u03c7k \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) because this would mean that \u03bb \u2261 \u03bb \\ {2\u03c7i}, contradicting our assumption that there are no superfluous disjuncts in \u03bb. It follows then by Theorem 3 that \u03bb 6|= \u03bb\u2032\u2032. Thus, \u03d5 |= \u03bb\u2032\u2032 |= \u03bb 6|= \u03bb\u2032\u2032, which means \u03bb 6\u2208 \u03a0(\u03d5).\nLemma 25.2 Let \u03d5 be a formula of K, and let \u03bb = \u03b31\u2228...\u2228\u03b3k\u22283\u03c81\u2228...\u22283\u03c8m\u22282\u03c71\u2228...\u22282\u03c7n (\u03b3j propositional literals) be a non-tautologous clause. Suppose furthermore that there is no literal l in \u03bb such that \u03bb \u2261 \u03bb \\ {l}. Then if \u03bb 6\u2208 \u03a0(\u03d5), either \u03b31 \u2228 ... \u2228 \u03b3k 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k})) or 3(\u03c81 \u2228 ...\u2228\u03c8m) 6\u2208 \u03a0(\u03d5\u2227\u00ac(\u03b31 \u2228 ...\u2228 \u03b3k \u22282(\u03c71 \u2228\u03c81 \u2228 ...\u2228\u03c8m)\u2228 ...\u22282(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m))) or 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})) for some i.\nProof. We will only consider the case where \u03d5 |= \u03bb because if \u03d5 6|= \u03bb then we immediately get the result. Suppose then that \u03bb 6\u2208 \u03a0(\u03d5) and \u03d5 |= \u03bb. By Definition 7, there must be some \u03bb\u2032 = \u03b3\u20321 \u2228 ...\u03b3 \u2032 o \u22283\u03c8 \u2032 1 \u2228 ...\u22283\u03c8 \u2032 p \u22282\u03c7 \u2032 1 \u2228 ...\u22282\u03c7 \u2032 q such that \u03d5 |= \u03bb\n\u2032 |= \u03bb 6|= \u03bb\u2032. Since \u03bb 6|= \u03bb\u2032, by Proposition 3 we know that either \u03b31\u2228 ...\u2228\u03b3k 6|= \u03b3 \u2032 1\u2228 ...\u2228\u03b3 \u2032 o or \u03c81\u2228 ...\u2228\u03c8m 6|= \u03c8 \u2032 1\u2228 ...\u2228\u03c8 \u2032 p or there is some i for which \u03c7i 6|= \u03c7 \u2032 j \u2228 \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p for all j.\nWe begin with the case where \u03b31 \u2228 ... \u2228 \u03b3k 6|= \u03b3 \u2032 1 \u2228 ... \u2228 \u03b3 \u2032 o. As \u03bb \u2032 |= \u03bb, by Theorem 3, \u03c8\u20321\u2228 ...\u2228\u03c8 \u2032 p |= \u03c81\u2228 ...\u2228\u03c8m and for every i there is some j such that \u03c7 \u2032 i |= \u03c81\u2228 ...\u2228\u03c8m\u2228\u03c7j. It follows then (also by Theorem 3) that \u03d5 |= \u03bb\u2032 |= \u03b3\u20321\u2228...\u2228\u03b3 \u2032 o\u22283\u03c81\u2228...\u22283\u03c8m\u22282\u03c71\u2228...\u22282\u03c7n, and hence that \u03d5\u2227\u00ac(\u03bb\\{\u03b31, ..., \u03b3k}) |= \u03b3 \u2032 1\u2228...\u2228\u03b3 \u2032 o. As \u03b3 \u2032 1\u2228...\u2228\u03b3 \u2032 o |= \u03b31\u2228...\u2228\u03b3k 6|= \u03b3 \u2032 1\u2228...\u2228\u03b3 \u2032 o, we have found an implicate of \u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}) which is stronger than \u03b31 \u2228 ... \u2228 \u03b3k, so \u03b31 \u2228 ... \u2228 \u03b3k 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k})).\nNext suppose that \u03c81\u2228 ...\u2228\u03c8m 6|= \u03c8 \u2032 1\u2228 ...\u2228\u03c8 \u2032 p. As \u03bb \u2032 |= \u03bb, it follows from Theorem 3 that \u03b3\u20321\u2228 ...\u2228\u03b3 \u2032 o |= \u03b31\u2228 ...\u2228\u03b3k and that for every i there is some j such that \u03c7 \u2032 i |= \u03c81\u2228 ...\u2228\u03c8m\u2228\u03c7j. We thereby obtain \u03d5 |= \u03bb\u2032 |= \u03b31 \u2228 ... \u2228 \u03b3k \u2228 3\u03c8 \u2032 1 \u2228 ... \u2228 3\u03c8 \u2032 p \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m). From this, we can infer that \u03d5 \u2227 \u00ac(\u03b31 \u2228 ... \u2228 \u03b3k \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m)) |= 3\u03c8 \u2032 1 \u2228 ... \u2228 3\u03c8 \u2032 p |= 3\u03c81 \u2228 ... \u2228 3\u03c8m 6|= 3\u03c8 \u2032 1 \u2228 ... \u2228 3\u03c8 \u2032 p. As 3\u03c81 \u2228 ...\u22283\u03c8m \u2261 3(\u03c81 \u2228 ... \u2228\u03c8m), it follows that 3(\u03c81 \u2228 ... \u2228\u03c8m) 6\u2208 \u03a0(\u03d5 \u2227\u00ac(\u03b31 \u2228 ...\u2228 \u03b3k \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m))).\nFinally suppose that \u03c7i 6|= \u03c7 \u2032 j \u2228\u03c8 \u2032 1\u2228 ...\u2228\u03c8 \u2032 p for all j and furthermore that \u03c81\u2228 ...\u2228\u03c8m |=\n\u03c8\u20321 \u2228 ... \u2228 \u03c8 \u2032 p (we have already shown the result holds when \u03c81 \u2228 ... \u2228 \u03c8m 6|= \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8\u2032p). Now 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) is an implicate of \u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})) so to show that 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) is not a prime implicate of \u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})), we must find some stronger implicate. Consider the set S = {s \u2208 {1, ..., q} : \u03c7\u2032s |= \u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m and \u03c7 \u2032 s 6|= \u03c7k\u2228\u03c81\u2228...\u2228\u03c8m for k 6= i}. We note that there must be at least one element in S as we have assumed \u03d5 6|= \u03bb\\{2\u03c7i}. Now since \u03b3 \u2032 1\u2228 ...\u2228\u03b3 \u2032 o |= \u03b31\u2228 ...\u2228\u03b3k, \u03c8 \u2032 1\u2228 ...\u2228\u03c8 \u2032 p |= \u03c81\u2228 ...\u2228\u03c8m, for every s 6\u2208 S there is some r 6= i such that \u03c7\u2032s |= \u03c7r \u2228\u03c81\u2228 ...\u2228\u03c8m, and \u03c7 \u2032 s |= \u03c7 \u2032 s for s \u2208 S, we get \u03d5 |= \u03bb\u2032 |= \u03b31\u2228...\u2228\u03b3k\u22283\u03c81\u2228...\u22283\u03c8m\u2228( \u2228 j 6=i 2\u03c7j)\u2228( \u2228 s\u2208S 2\u03c7 \u2032 s). It follows that \u03d5\u2227\u00ac(\u03bb\\ {2\u03c7i}) |= \u2228 s\u2208S 2(\u03c7 \u2032 s\u2227\u00ac\u03c81\u2227 ...\u2227\u00ac\u03c8m), which means that \u2228 s\u2208S 2(\u03c7 \u2032 s\u2227\u00ac\u03c81\u2227 ...\u2227\u00ac\u03c8m) is an\nimplicate of \u03d5\u2227\u00ac(\u03bb\\{2\u03c7i}). Moreover, \u2228 s\u2208S 2(\u03c7 \u2032 s\u2227\u00ac\u03c81\u2227...\u2227\u00ac\u03c8m) |= 2(\u03c7i\u2227\u00ac\u03c81\u2227...\u2227\u00ac\u03c8m) since by construction \u03c7\u2032s |= \u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8m for every s \u2208 S. It remains to be shown that 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6|= \u2228 s\u2208S 2(\u03c7 \u2032 s \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m). Suppose for a contradiction that the contrary holds. Then 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) |=\u2228 s\u2208S 2(\u03c7 \u2032 s \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m), so by Theorem 1, there must be some s \u2208 S for which \u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m |= \u03c7 \u2032 s \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m. But then \u03c7i |= \u03c7 \u2032 s \u2228 \u03c81 \u2228 ... \u2228 \u03c8m, and thus \u03c7i |= \u03c7 \u2032 s \u2228\u03c8 \u2032 1 \u2228 ...\u2228\u03c8 \u2032 p since we have assumed \u03c81 \u2228 ...\u2228\u03c8m |= \u03c8 \u2032 1 \u2228 ...\u2228\u03c8 \u2032 p. This contradicts our earlier assumption that \u03c7i 6|= \u03c7 \u2032 j \u2228 \u03c8 \u2032 1 \u2228 ... \u2228 \u03c8 \u2032 p for all j. Thus, we have shown that 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6|= \u2228 s\u2208S 2(\u03c7 \u2032 s \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m), so 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8m) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})).\nTheorem 25 Let \u03d5 be a formula of K, and let \u03bb = \u03b31\u2228...\u2228\u03b3k\u22283\u03c81\u2228...\u22283\u03c8n\u22282\u03c71\u2228...\u22282\u03c7m (\u03b3j propositional literals) be a non-tautologous clause such that (a) \u03c7i \u2261 \u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8n for all i, and (b) there is no literal l in \u03bb such that \u03bb \u2261 \u03bb \\ {l}. Then \u03bb \u2208 \u03a0(\u03d5) if and only if the following conditions hold:\n1. \u03b31 \u2228 ... \u2228 \u03b3k \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}))\n2. 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8n) \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})) for every i\n3. 3(\u03c81 \u2228 ... \u2228 \u03c8n) \u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8n}))\nProof. The forward direction was shown in Lemma 25.1. The other direction follows from Lemma 25.2 together with the hypothesis that \u03c7i \u2261 \u03c7i \u2228 \u03c81 \u2228 ... \u2228 \u03c8n for all i (which ensures that \u03d5 \u2227 \u00ac(\u03b31 \u2228 ... \u2228 \u03b3k \u2228 2(\u03c71 \u2228 \u03c81 \u2228 ... \u2228 \u03c8m) \u2228 ... \u2228 2(\u03c7n \u2228 \u03c81 \u2228 ... \u2228 \u03c8m)) \u2261 \u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8n})).\nTheorem 26 Let \u03d5 be a formula of K, and let \u03b3 be a non-tautologous propositional clause such that \u03d5 |= \u03b3 and such that there is no literal l in \u03b3 such that \u03b3 \u2261 \u03b3 \\{l}. Then \u03b3 \u2208 \u03a0(\u03d5) if and only if \u03d5 6|= \u03b3 \\ {l} for all l in \u03b3.\nProof. Consider a formula \u03d5 and a non-tautologous propositional clause \u03bb such that \u03d5 |= \u03bb and such that there is no literal l in \u03bb such that \u03bb \u2261 \u03bb \\ {l}. Suppose that \u03d5 |= \u03bb \\ {l} for some l in \u03bb. As we know that \u03bb 6\u2261 \u03bb \\ {l}, it follows that \u03bb \\ {l} is an implicate of \u03d5 which is strictly stronger than \u03bb, so \u03bb is not a prime implicate of \u03d5. For the other direction, suppose that \u03bb 6\u2208 \u03a0(\u03d5). Then it must be the case that there is some clause \u03c1 such that \u03d5 |= \u03c1 |= \u03bb 6|= \u03c1. Since \u03c1 |= \u03bb, it follows from Theorem 2 that each literal in \u03c1 is a propositional literal of \u03bb or is inconsistent. If all of the literals in \u03c1 are inconsistent, then both \u03c1 and \u03d5 must be inconsistent, so clearly \u03d5 |= \u03b3 \\ {l} for every l in \u03b3. Otherwise, \u03c1 is equivalent to a propositional clause, and more specifically to a propositional clause containing only those literals appearing in \u03bb (since \u03c1 |= \u03bb). As \u03c1 is strictly stronger than \u03bb, there must be some literal l in \u03bb which does not appear in \u03c1. But that means \u03c1 |= \u03bb \\ {l} and so \u03d5 |= \u03bb \\ {l}, completing the proof.\nTheorem 27 Let \u03d5 be a formula of K, and let \u03bb = 2\u03c7 be a non-tautologous clause such that \u03d5 |= \u03bb. Then \u03bb \u2208 \u03a0(\u03d5) if and only if there exists some term T \u2208Dnf-4(\u03d5) such that \u03c7 |= \u03b2T , where \u03b2T is the conjunction of formulae \u03c8 such that 2\u03c8 is in T .\nProof. Let \u03d5 be some formula, and let \u03bb = 2\u03c7 be a non-tautologous clause such that \u03d5 |= \u03bb. For the first direction, suppose that there is no term T \u2208Dnf-4(\u03d5) such that \u03c7 |= \u03b2T , where \u03b2T is the conjunction of formulae \u03c8 such that 2\u03c8 is in T . There are two cases: either there are no terms in Dnf-4(\u03d5) because \u03d5 is unsatisfiable, or there are terms but none satisfy the condition. In the first case, 2\u03c7 is not a prime implicate of \u03d5, since any contradictory clause (e.g. 3(a \u2227 \u00aca)) is stronger. In the second case, consider the clause \u03bb\u2032 = \u2228\nT 2\u03b2T , where \u03b2T is the conjunction of formulae \u03c8 such that 2\u03c8 is in T . Now for every T we must have 2\u03b2T |= 2\u03c7, otherwise we would have T 6|= 2\u03c7, and hence \u03d5 6|= 2\u03c7. Moreover, \u03d5 |= \u2228\nT 2\u03b2T since T |= 2\u03b2T for every T . But by Theorem 1, 2\u03c7 6|= \u2228\nT 2\u03b2T since \u03c7 6|= \u03b2T for all T . So we have \u03d5 |= \u03bb\u2032 |= \u03bb 6|= \u03bb\u2032, which means that \u03bb is not a prime implicate of \u03d5.\nFor the other direction, suppose that 2\u03c7 is not a prime implicate of \u03d5 and that \u03d5 6|= \u22a5. Then Dnf-4(\u03d5) is non-empty. As \u03d5 |= 2\u03c7, we must have T |= 2\u03c7 for all T \u2208Dnf-4(\u03d5), so \u2228\nT 2\u03b2T also implies 2\u03c7. We now show that \u2228\nT 2\u03b2T is a prime implicate of \u03d5. We let \u03ba be some implicate of \u03d5 which implies \u2228\nT 2\u03b2T . Now since \u03ba |= \u2228 T 2\u03b2T and \u2228\nT 2\u03b2T is non-tautologous, it follows from Theorem 2 that \u03ba \u2261 2\u03b61 \u2228 ... \u2228 2\u03b6n for some formulae \u03b6i. As \u03d5 |= \u03ba, we must have T |= 2\u03b61\u2228 ...\u22282\u03b6n for all T \u2208Dnf-4(\u03d5). But that can only be the case if 2\u03b2T |= 2\u03b61 \u2228 ...\u22282\u03b6n for all T , which means \u2228 T 2\u03b2T |= 2\u03b61 \u2228 ...\u22282\u03b6n. As \u2228\nT 2\u03b2T implies every implicate of \u03d5 that implies it, \u2228\nT 2\u03b2T must be a prime implicate of \u03d5. But this means that 2\u03c7 6|= \u2228\nT 2\u03b2T , since we have assumed that 2\u03c7 is not a prime implicate of \u03d5. It follows from Theorem 1 that \u03c7 6|= \u03b2T for all T \u2208Dnf-4(\u03d5).\nIn order to show Theorem 28 we will need the following lemmas:\nLemma 28.1 If 3\u03c8 is an implicate of \u03d5 which is not a prime implicate, the algorithm Test3PI returns no on input (3\u03c8, \u03d5).\nProof. Suppose that 3\u03c8 is not a prime implicate of \u03d5. If \u03d5 is unsatisfiable, then \u03c8 must be satisfiable, so we will return no in the first step. If \u03d5 is satisfiable, then since we have assumed that 3\u03c8 is an implicate of \u03d5, there must be some clause \u03bb such that \u03d5 |= \u03bb |= 3\u03c8 but 3\u03c8 6|= \u03bb. As \u03bb |= 3\u03c8, it follows from Theorem 2 that \u03bb is equivalent to a disjunction of 3-formulae, and hence to some clause 3\u03c8\u2032.\nWe know from Lemma 13 that \u03d5 is equivalent to the disjunction of terms in Dnf-4(\u03d5). It must thus be the case that Ti |= 3\u03c8\n\u2032 for all Ti \u2208 Dnf-4(\u03d5). Since each Ti is a satisfiable conjunction of propositional literals and 2- and 3-formulae, it follows that there exists a set {3\u03b7i,2\u00b5i,1, ...,2\u00b5i,k(i)} of conjuncts of Ti such that 3(\u03b7i\u2227\u00b5i,1\u2227...\u2227\u00b5i,k(i)) |= 3\u03c8\n\u2032, otherwise Ti would fail to imply 3\u03c8\n\u2032. Moreover, all of the elements of {3\u03b7i,2\u00b5i,1, ...,2\u00b5i,k(i)} must appear in the NNF of \u03d5 outside modal operators, so the formulae \u03b7i, \u00b5i,1, ..., \u00b5i,k(i) must all be elements of the set X . It is immediate that both\n3\n\u2228\ni\n(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i)) |= 3\u03c8 \u2032 |= 3\u03c8 (3)\nand\n3\u03c8 6|= 3 \u2228\ni\n(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i))\nThe latter implies that the formula 3\u03c8\u2227\u00ac(3 \u2228\ni(\u03b7i \u2227\u00b5i,1\u2227 ...\u2227\u00b5i,k(i))) must be consistent, which means that\n\u03c8 \u2227 \u00ac( \u2228\ni\n(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i))) \u2261 \u03c8 \u2227 \u2227\ni\n(\u00ac\u03b7i \u2228 \u00ac\u00b5i,1 \u2228 ... \u2228 \u00ac\u00b5i,k(i))\nmust be consistent as well. But then it must be the case that we can select for each i some \u03c3i \u2208 {\u03b7i, \u00b5i,1, ..., \u00b5i,k(i)} such that \u03c8 \u2227 \u2227\ni \u00ac\u03c3i is consistent. Let S be the set of \u03c3i. The set S satisfies the condition of the algorithm since:\n\u2022 S \u2286 X\n\u2022 \u03c8 6|= \u2228 \u03c3\u2208S \u03c3 (because we know \u03c8 \u2227 \u2227 i \u00ac\u03c3i to be consistent)\n\u2022 for each Ti \u2208 Dnf-4(\u03d5), the conjuncts 3\u03b7i,2\u00b5i,1, ...,2\u00b5i,k(i) of Ti are such that:\n\u2013 {\u03b7i, \u00b5i,1, ..., \u00b5i,k(i)} \u2229 S 6= \u2205 (since S contains \u03c3i \u2208 {\u03b7i, \u00b5i,1, ..., \u00b5i,k(i)})\n\u2013 3(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i)) |= 3\u03c8 (follows from (3) above)\nSince there exists a set S \u2286 X satisfying these conditions, the algorithm returns no.\nLemma 28.2 If the algorithm Test3PI returns no on input (3\u03c8, \u03d5), then 3\u03c8 is not a prime implicate of \u03d5.\nProof. Suppose Test3PI returns no on input (3\u03c8, \u03d5). If this happens during the first step, it must be the case that \u03d5 is unsatisfiable and 3\u03c8 is unsatisfiable, in which case 3\u03c8 is not a prime implicate of \u03d5. The other possibility is that the algorithm returns no in Step 3, which means there must be some S \u2286 X satisfying:\n(a) \u03c8 6|= \u2228\n\u03bb\u2208S \u03bb\n(b) for each Ti \u2208 Dnf-4(\u03d5), there exist conjuncts 3\u03b7i,2\u00b5i,1, ...,2\u00b5i,k(i) of Ti such that: (i) {\u03b7i, \u00b5i,1, ..., \u00b5i,k(i)} \u2229 S 6= \u2205 (ii) 3(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i)) |= 3\u03c8\nLet \u03b1 be the clause \u2228\ni 3(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i)). We remark that for each Ti, we have Ti |= 3(\u03b7i\u2227\u00b5i,1\u2227 ...\u2227\u00b5i,k(i)), and hence \u2228 i Ti |= \u2228\ni 3(\u03b7i\u2227\u00b5i,1\u2227 ...\u2227\u00b5i,k(i)). From the definition of Dnf-4(\u03d5), we also have \u03d5 \u2261 \u2228\ni Ti. It immediately follows that \u03d5 |= \u2228\ni 3(\u03b7i\u2227\u00b5i,1\u2227...\u2227\u00b5i,k(i)) and hence \u03d5 |= \u03b1. From 2 (b) (ii), we have that 3(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i)) |= 3\u03c8 for every i, and hence \u2228\ni 3(\u03b7i \u2227 \u00b5i,1 \u2227 ...\u2227 \u00b5i,k(i)) |= 3\u03c8 which yields \u03b1 |= 3\u03c8. From 2 (b) (i), we have that {\u03b7i, \u00b5i,1, ..., \u00b5i,k(i)} \u2229 S 6= \u2205 and hence that for every i there is some \u03bb \u2208 S such that \u03b7i\u2227\u00b5i,1\u2227 ...\u2227\u00b5i,k(i) |= \u03bb. From this we can infer that \u2228 i 3(\u03b7i\u2227\u00b5i,1\u2227 ...\u2227\u00b5i,k(i)) |= \u2228\n\u03bb\u2208S 3\u03bb, and hence \u03b1 |= 3 \u2228\n\u03bb\u2208S \u03bb. But we know from 2 (a) and Theorem 1 that 3\u03c8 6|= 3 \u2228\n\u03bb\u2208S \u03bb. It follows then that 3\u03c8 6|= \u03b1. Putting all this together, we see that there exists a clause \u03b1 such that \u03d5 |= \u03b1 |= 3\u03c8 but 3\u03c8 6|= \u03b1, and hence that 3\u03c8 is not a prime implicate of \u03d5.\nTheorem 28 Let \u03d5 be a formula, and let 3\u03c8 be an implicate of \u03d5. Then the algorithm Test3PI returns yes on input (3\u03c8, \u03d5) if and only if 3\u03c8 is a prime implicate of \u03d5.\nProof. It is clear that Test3PI terminates since unsatisfiability testing and the NNF transformation always terminate, and there are only finitely many S and Ti. Lemmas 28.1 and 28.2 show us that the algorithm always gives the correct response.\nTheorem 29 The algorithm Test3PI runs in polynomial space.\nProof. We remark that the sum of the lengths of the elements in X is bounded by the length of the formula Nnf(\u03d5), and hence by Lemma 14 the sum of the lengths of the elements of a particular S \u2286 X cannot exceed 2|\u03d5|. Testing whether \u03c8 6|= \u2228\n\u03bb\u2208S \u03bb can thus be accomplished in polynomial space in the length of \u03d5 and \u03c8 as it involves testing the satisfiability of the formula \u03c8 \u2227 \u2227\n\u03bb\u2208S \u00ac\u03bb whose length is clearly polynomial in \u03d5 and \u03c8.\nNow let us turn to Step 3 (b). We notice that it is not necessary to keep all of the Ti in memory at once, since we can generate the terms Ti one at a time using only polynomial space by Lemma 12. By Lemma 14, the length of any Ti in Dnf-4(\u03d5) can be at most 2|\u03d5|. It follows that checking whether {\u03b7i, \u00b5i,1, ..., \u00b5i,k(i)} \u2229 S 6= \u2205, or whether 3(\u03b7i \u2227 \u00b5i,1 \u2227 ... \u2227 \u00b5i,k(i)) |= 3\u03c8 can both be accomplished in polynomial space in the length of \u03d5 and \u03c8. We conclude that the algorithm Test3PI runs in polynomial space.\nIn order to show Theorem 32, we use the following lemmas:\nLemma 32.1 If \u03bb is a clause that is not a prime implicate of \u03d5, then TestPI outputs no on this input.\nProof. Let us begin by considering a formula \u03bb which is a clause but that is not a prime implicate of \u03d5. There are two possible reasons for this: either \u03bb is not an implicate of \u03d5, or it is an implicate but there exists some stronger implicate. In the first case, TestPI returns no in Step 1, as desired. We will now focus on the case where \u03bb is an implicate but not a prime implicate. We begin by treating the limit cases where one or both of \u03d5 and \u03bb is a tautology or contradiction. Given that we know \u03bb to be a non-prime implicate of \u03d5, there are only two possible scenarios: either 6|= \u03d5 and |= \u03bb, or \u03d5 |= \u22a5 and \u03bb 6|= \u22a5. In both cases, the algorithm returns no in Step 2.\nIf \u03bb is an implicate of \u03d5, and neither \u03d5 nor \u03bb is a tautology or contradiction, then the algorithm will continue on to Step 3. In this step, any redundant literals will be deleted from \u03bb, and if \u03bb contains 3-literals, we add an extra disjunct to the 2-literals so that \u03bb satisfies the syntactic requirements of Theorem 25. Let \u03b31 \u2228 ...\u03b3k \u22283\u03c81 \u2228 ...\u22283\u03c8m \u22282\u03c71 \u2228 ... \u2228 2\u03c7n be the clause \u03bb at the end of Step 3 once all modifications have been made. As the transformations in Step 3 are equivalence-preserving (Theorem 1), the modified \u03bb is equivalent to the original, so \u03bb is still a non-tautologous non-prime implicate of \u03d5. This means \u03d5 and \u03bb now satisfy all of the conditions of Theorem 25. It follows then that one of the following holds:\n(a) \u03b31 \u2228 ... \u2228 \u03b3k 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k})\n(b) 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8n) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})) for some i\n(c) 3(\u03c81 \u2228 ... \u2228 \u03c8n) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8n}))\nSuppose that (a) holds. Now \u03b31 \u2228 ... \u2228 \u03b3k is a non-tautologous propositional clause implied by \u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}) which contains no redundant literals. This means that \u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}) and \u03b31\u2228...\u2228\u03b3k satisfy the conditions of Theorem 26. According to this theorem, as \u03b31 \u2228 ... \u2228 \u03b3k 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}), then there must be some \u03b3j such that \u03d5 \u2227 \u00ac(\u03bb \\ {\u03b31, ..., \u03b3k}) |= \u03b31\u2228 ...\u2228\u03b3j\u22121\u2228\u03b3j+1\u2228 ...\u2228\u03b3k . This means that \u03d5 |= \u03bb\\{\u03b3j}, so the algorithm returns no in Step 4.\nSuppose next that (b) holds, and let i be such that 2(\u03c7i \u2227 \u00ac\u03c81 \u2227 ... \u2227 \u00ac\u03c8n) 6\u2208 \u03a0(\u03d5 \u2227 \u00ac(\u03bb \\ {2\u03c7i})). By Theorem 27, this means that there is no T \u2208Dnf-4(\u03d5) such that 2(\u03c7i\u2227\u00ac\u03c81\u2227 ...\u2227\u00ac\u03c8n) entails the conjunction of 2-formulae conjuncts of T . It follows that the algorithm returns no in Step 5.\nFinally consider the case where neither (a) nor (b) holds but (c) does. Then in Step 6, we will call Test3PI(3(\n\u2228m i=1 \u03c8i), \u03d5\u2227\u00ac(\u03bb\\{3\u03c81 , ...,3\u03c8m})). As 3( \u2228m i=1 \u03c8i) is not a prime\nimplicate of \u03d5\u2227\u00ac(\u03bb\\{3\u03c81, ...,3\u03c8m})) and we have shown Test3PI to be correct (Theorem 28), Test3PI will return no, so TestPI will return no as well. As we have covered each of the possible cases, we can conclude that if \u03bb is a clause that is not a prime implicate of \u03d5, then TestPI outputs no.\nLemma 32.2 If TestPI outputs no with input (\u03bb, \u03d5) and \u03bb is a clause, then \u03bb is not a prime implicate of \u03d5.\nProof. There are 5 different ways for TestPI to return no (these occur in Steps 1, 2, 4, 5, and 6). Let us consider each of these in turn. The first way that the algorithm can return no is in Step 1 if we find that \u03d5 6|= \u03bb. This is correct since \u03bb cannot be a prime implicate if it is not a consequence of \u03d5. In Step 2, we return no if \u03d5 is unsatisfiable but \u03bb is not, or if \u03bb is a tautology but \u03d5 is not. This is also correct since in both cases \u03bb cannot be a prime implicate since there exist stronger implicates (any contradictory clause if \u03d5 \u2261 \u22a5, and any non-tautologous implicate of \u03d5 if \u03bb \u2261 \u22a4). In Step 3, we may modify \u03bb, but the resulting formula is equivalent to the original, and so it is a prime implicate just in the case that the original clause was. Let \u03b31\u2228 ...\u03b3k\u22283\u03c81\u2228 ...\u22283\u03c8m\u22282\u03c71\u2228 ...\u22282\u03c7n be the clause at the end of Step 3. Now in Step 4, we return no if we find some propositional literal l in \u03bb for which \u03d5 |= \u03bb\\{l}. Now since in Step 3, we have removed redundant literals from \u03bb, we can be sure that \u03bb \\ {l} is strictly stronger than \u03bb. So we have \u03d5 |= \u03bb \\ {l} |= \u03bb and \u03bb 6|= \u03bb \\ {l}, which means that \u03bb is not a prime implicate of \u03d5. We now consider Step 5 of TestPI. In this step, we return no if for some disjunct 2\u03c7i there is no term T inDnf-4(\u03d5\u2227\u00ac(\u03bb\\{2\u03c7i})) for which 2(\u03c7i\u2227\u00ac\u03c81\u2227 ...\u2227\u00ac\u03c8m) entails the conjunction of 2-literals in T . According to Theorem 27, this means that 2(\u03c7i \u2227\u00ac\u03c81 \u2227 ...\u2227\u00ac\u03c8m) is not a prime implicate of \u03d5\u2227\u00ac(\u03bb \\ {2\u03c7i}), which means that \u03bb is not a prime implicate of \u03d5 by Theorem 25. . In this step, we return no if Test3PI returns no on input (3(\n\u2228k i=1 \u03c8i), \u03d5\u2227\u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m})). By Theorem 28,\nwe know that this happens just in the case that 3( \u2228k\ni=1 \u03c8i) is not a prime implicate of \u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m}). It follows from Theorem 25 that \u03bb is not a prime implicate of \u03d5.\nTheorem 32 The algorithm TestPI always terminates, and it returns yes on input (\u03bb, \u03d5) if and only if \u03bb is a prime implicate of \u03d5.\nProof. The algorithm TestPI clearly terminates because Steps 1 to 5 involve a finite number of syntactic operations on \u03bb and a finite number of entailment checks. Moreover, the call to Test3PI in Step 6 is known to terminate (Theorem 28). Correctness and completeness have already been shown in Lemmas 32.1 and 32.2.\nWe make use of the following lemma in the proof of Theorem 34:\nLemma 34.1 The algorithm TestPI provided in Figure 5 runs in polynomial space in the length of the input.\nProof. It is clear that steps 1 through 5 can be carried out in polynomial space in the length of the input, since they simply involve testing the satisfiability of formulae whose lengths are polynomial in |\u03bb|+ |\u03d5|. Step 6 can also be carried out in polynomial space since by Theorem 29 deciding whether the formula 3(\n\u2228m i=1 \u03c8i) is a prime implicate of \u03d5\u2227\u00ac(\u03bb \\ {\u03c81, ..., \u03c8m}))\ntakes only polynomial space in |3( \u2228m\ni=1 \u03c8i)| + |\u03d5 \u2227 \u00ac(\u03bb \\ {3\u03c81, ...,3\u03c8m}))|, and hence in |\u03bb|+ |\u03d5|. We can thus conclude that the algorithm TestPI runs in polynomial space in the length of the input.\nTheorem 34 Prime implicate recognition is in Pspace.\nProof. We have show in Theorem 32 that TestPI always terminates and returns yes whenever the clause is a prime implicate and no otherwise. This means that TestPI is a decision procedure for prime implicate recognition. Since the algorithm has been shown to run in polynomial space (Lemma 34.1), we can conclude that prime implicate recognition is in Pspace.\nCorollary 35 Prime implicate recognition is Pspace-complete.\nProof. Follows directly from Theorems 24 and 34."}], "references": [{"title": "Distributed reasoning in a peer-to-peer setting: Application to the semantic web", "author": ["P. Adjiman", "P. Chatalic", "F. Goasdou\u00e9", "Rousset", "M.-C", "L. Simon"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Adjiman et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Adjiman et al\\.", "year": 2006}, {"title": "The Description Logic Handbook", "author": ["F. Baader", "D.L. McGuiness", "D. Nardi", "P. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2003}, {"title": "Prime implicates and prime implicants in modal logic", "author": ["M. Bienvenu"], "venue": "Proceedings of the Twenty-Second Conference on Artificial Intelligence (AAAI\u201907), pp. 397\u2013384.", "citeRegEx": "Bienvenu,? 2007", "shortCiteRegEx": "Bienvenu", "year": 2007}, {"title": "Prime implicate normal form for ALC concepts", "author": ["M. Bienvenu"], "venue": "Proceedings of the Twenty-Third Conference on Artificial Intelligence (AAAI\u201908), pp. 412\u2013417.", "citeRegEx": "Bienvenu,? 2008", "shortCiteRegEx": "Bienvenu", "year": 2008}, {"title": "Consequence Finding in Modal Logic", "author": ["M. Bienvenu"], "venue": "Ph.D. thesis, Universit\u00e9 de Toulouse.", "citeRegEx": "Bienvenu,? 2009", "shortCiteRegEx": "Bienvenu", "year": 2009}, {"title": "Combining syntax and semantics through prime form representation", "author": ["G. Bittencourt"], "venue": "Journal of Logic and Computation, 18 (1), 13\u201333.", "citeRegEx": "Bittencourt,? 2007", "shortCiteRegEx": "Bittencourt", "year": 2007}, {"title": "An approach for optimized approximation", "author": ["S. Brandt", "A. Turhan"], "venue": "In Proceedings of the KI-2002 Workshop on Applications of Description Logics (KIDLWS\u201901)", "citeRegEx": "Brandt and Turhan,? \\Q2002\\E", "shortCiteRegEx": "Brandt and Turhan", "year": 2002}, {"title": "A survey on knowledge compilation", "author": ["M. Cadoli", "F.M. Donini"], "venue": "AI Communications,", "citeRegEx": "Cadoli and Donini,? \\Q1997\\E", "shortCiteRegEx": "Cadoli and Donini", "year": 1997}, {"title": "Propositional abduction in modal logic", "author": ["M. Cialdea Mayer", "F. Pirri"], "venue": "Logic Journal of the IGPL,", "citeRegEx": "Mayer and Pirri,? \\Q1995\\E", "shortCiteRegEx": "Mayer and Pirri", "year": 1995}, {"title": "A knowledge compilation map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Darwiche and Marquis,? \\Q2002\\E", "shortCiteRegEx": "Darwiche and Marquis", "year": 2002}, {"title": "Characterizing diagnoses and systems", "author": ["J. de Kleer", "A.K. Mackworth", "R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "Kleer et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Kleer et al\\.", "year": 1992}, {"title": "The Description Logic Handbook, chap", "author": ["F.M. Donini"], "venue": "Complexity of Reasoning. Cambridge University Press.", "citeRegEx": "Donini,? 2003", "shortCiteRegEx": "Donini", "year": 2003}, {"title": "The complexity of existential qualification in concept languages", "author": ["F.M. Donini", "M. Lenzerini", "D. Nardi", "B. Hollunder", "W. Nutt", "A. Marchetti Spaccamela"], "venue": "Artificial Intelligence,", "citeRegEx": "Donini et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Donini et al\\.", "year": 1992}, {"title": "On computing all abductive explanations", "author": ["T. Eiter", "K. Makino"], "venue": "In Proceedings of the Eighteenth National Conference on Artificial Intelligence", "citeRegEx": "Eiter and Makino,? \\Q2002\\E", "shortCiteRegEx": "Eiter and Makino", "year": 2002}, {"title": "Modal resolution in clausal form", "author": ["P. Enjalbert", "L. Fari\u00f1as del Cerro"], "venue": "Theoretical Computer Science,", "citeRegEx": "Enjalbert and Cerro,? \\Q1989\\E", "shortCiteRegEx": "Enjalbert and Cerro", "year": 1989}, {"title": "Computers and intractability. A guide to the theory of NP-completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": null, "citeRegEx": "Garey and Johnson,? \\Q1979\\E", "shortCiteRegEx": "Garey and Johnson", "year": 1979}, {"title": "Did I damage my ontology? A case for conservative extensions in description logics", "author": ["S. Ghilardi", "C. Lutz", "F. Wolter"], "venue": "In Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Ghilardi et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ghilardi et al\\.", "year": 2006}, {"title": "A SAT-based decision procedure for ALC", "author": ["F. Giunchiglia", "R. Sebastiani"], "venue": "In Proceedings of the Fifth International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Giunchiglia and Sebastiani,? \\Q1996\\E", "shortCiteRegEx": "Giunchiglia and Sebastiani", "year": 1996}, {"title": "Approximating most specific concepts in logics with existential restrictions", "author": ["R. K\u00fcsters", "R. Molitor"], "venue": "AI Communications,", "citeRegEx": "K\u00fcsters and Molitor,? \\Q2002\\E", "shortCiteRegEx": "K\u00fcsters and Molitor", "year": 2002}, {"title": "The computational complexity of provability in systems of modal propositional logic", "author": ["R. Ladner"], "venue": "SIAM Journal of Computing, 6 (3), 467\u2013480.", "citeRegEx": "Ladner,? 1977", "shortCiteRegEx": "Ladner", "year": 1977}, {"title": "A logical account of relevance", "author": ["G. Lakemeyer"], "venue": "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI\u201995), pp. 853\u2013861.", "citeRegEx": "Lakemeyer,? 1995", "shortCiteRegEx": "Lakemeyer", "year": 1995}, {"title": "Propositional independence: Formulavariable independence and forgetting", "author": ["J. Lang", "P. Liberatore", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Lang et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lang et al\\.", "year": 2003}, {"title": "Contribution \u00e1 l\u2019\u00e9tude des m\u00e9thodes de construction d\u2019hypoth\u00e8ses en intelligence artificielle", "author": ["P. Marquis"], "venue": "french, Universit\u00e9 de Nancy I.", "citeRegEx": "Marquis,? 1991a", "shortCiteRegEx": "Marquis", "year": 1991}, {"title": "Extending abduction from propositional to first-order logic", "author": ["P. Marquis"], "venue": "Proceedings of Fundamentals of Artificial Intelligence Research Workshop, pp. 141\u2013155.", "citeRegEx": "Marquis,? 1991b", "shortCiteRegEx": "Marquis", "year": 1991}, {"title": "Handbook on Defeasible Reasoning and Uncertainty Management Systems, Vol", "author": ["P. Marquis"], "venue": "5, chap. Consequence Finding Algorithms, pp. 41\u2013145. Kluwer.", "citeRegEx": "Marquis,? 2000", "shortCiteRegEx": "Marquis", "year": 2000}, {"title": "Knowledge compilation for belief change", "author": ["M. Pagnucco"], "venue": "Proceedings of the Nineteenth Australian Conference on Artificial Intelligence (AI\u201906), pp. 90\u201399.", "citeRegEx": "Pagnucco,? 2006", "shortCiteRegEx": "Pagnucco", "year": 2006}, {"title": "Computational Complexity", "author": ["C. Papadimitriou"], "venue": "Addison Welsey.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "An algorithm to compute circumscription", "author": ["T. Przymusinski"], "venue": "Artificial Intelligence, 38 (1), 49\u201373.", "citeRegEx": "Przymusinski,? 1989", "shortCiteRegEx": "Przymusinski", "year": 1989}, {"title": "Computing prime implicants/implicates for regular logics", "author": ["A. Ramesh", "N. Murray"], "venue": "In Proceedings of the Twenty-Fourth IEEE International Symposium on MultipleValued Logic,", "citeRegEx": "Ramesh and Murray,? \\Q1994\\E", "shortCiteRegEx": "Ramesh and Murray", "year": 1994}, {"title": "A correspondence theory for terminological logics: Preliminary report", "author": ["K. Schild"], "venue": "Proceedings of the Twelth International Joint Conference on Artificial Intelligence (IJCAI\u201991), pp. 466\u2013471. Younger, D. H. (1967). Recognition and parsing of context-free languages in time n3. Information and Control, 10 (2), 189\u2013208.", "citeRegEx": "Schild,? 1991", "shortCiteRegEx": "Schild", "year": 1991}], "referenceMentions": [{"referenceID": 5, "context": "Prime implicates have also proved relevant to other sub-areas of AI, like distributed reasoning (Adjiman, Chatalic, Goasdou\u00e9, Rousset, & Simon, 2006), belief revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf.", "startOffset": 167, "endOffset": 202}, {"referenceID": 25, "context": "Prime implicates have also proved relevant to other sub-areas of AI, like distributed reasoning (Adjiman, Chatalic, Goasdou\u00e9, Rousset, & Simon, 2006), belief revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf.", "startOffset": 167, "endOffset": 202}, {"referenceID": 20, "context": "Przymusinski, 1989), and characterizations of relevance (Lakemeyer, 1995; Lang, Liberatore, & Marquis, 2003).", "startOffset": 56, "endOffset": 108}, {"referenceID": 19, "context": "Ladner (1977) showed that satisfiability and unsatisfiability in K are Pspace-complete.", "startOffset": 0, "endOffset": 14}, {"referenceID": 17, "context": "The first definition, which is inspired by the notion of modal atom proposed by Giunchiglia and Sebastiani (1996), defines literals as the set of formulae in NNF that cannot be decomposed propositionally.", "startOffset": 80, "endOffset": 114}, {"referenceID": 24, "context": "In propositional logic, prime implicate recognition is BH2-complete (Marquis, 2000), being as hard as both satisfiability and deduction.", "startOffset": 68, "endOffset": 83}, {"referenceID": 8, "context": "Moreover, because the notion of term underlying our definition of abductive explanations is more expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations which are overlooked by their method.", "startOffset": 134, "endOffset": 157}, {"referenceID": 8, "context": "Moreover, because the notion of term underlying our definition of abductive explanations is more expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations which are overlooked by their method. For instance, if we look for an explanation of the observation c given the background information 2(a \u2228 b) \u2192 c, we obtain 2(a \u2228 b), whereas their framework yields 2a and 2b. This is an argument in favor of our approach since generally in abduction one is looking to find the weakest conditions guaranteeing the truth of the observation given the background information. Also of interest are our results on the size and number of prime implicates, as these yield corresponding lower bounds on the size and number of abductive explanations. In particular, our results imply that the abductive explanations of Cialdea Mayer and Pirri (1995) can have exponential size and be double exponentially many in number in the worst case, and thus behave no better in these respects than the notion of abductive explanation induced by our preferred definition D4.", "startOffset": 134, "endOffset": 867}, {"referenceID": 3, "context": "Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form, in which we specify which of the many different clausal representations of a prime implicate should be used.", "startOffset": 46, "endOffset": 62}, {"referenceID": 2, "context": "Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form, in which we specify which of the many different clausal representations of a prime implicate should be used. This normal form was shown to enjoy a number of desirable properties which make it interesting from the viewpoint of knowledge compilation. Most notably, it was proven that entailment between formulae in K in our prime implicate normal form can be carried out in polynomial time using a simple structural comparison algorithm which is reminiscent of the structural subsumption algorithms used in subpropositional description logics. It should be noted that the proof of this and other results by Bienvenu (2008) make ample use of the material presented in the current paper.", "startOffset": 47, "endOffset": 761}, {"referenceID": 2, "context": "This paper corrects and significantly extends an earlier conference publication (Bienvenu, 2007).", "startOffset": 80, "endOffset": 96}, {"referenceID": 11, "context": "Donini, Lenzerini, Nardi, Hollunder, Nutt, & Marchetti Spaccamela, 1992), it follows that deciding entailment between terms with respect to either D1 or D2 can also be accomplished in nondeterministic polynomial time, i.e. these problems belong to NP. It remains to be shown that these problems are NP-hard. To prove this, we show how the polynomial-time reduction of Donini (2003) (adapted from the original NP-hardness proof by Donini et al.", "startOffset": 0, "endOffset": 382}, {"referenceID": 11, "context": "Donini has proven (2003) that U ,S has an exact cover if and only if the formula \u03c6U ,S pictured in Figure 6 is unsatisfiable.", "startOffset": 0, "endOffset": 25}], "year": 2009, "abstractText": "Prime implicates and prime implicants have proven relevant to a number of areas of artificial intelligence, most notably abductive reasoning and knowledge compilation. The purpose of this paper is to examine how these notions might be appropriately extended from propositional logic to the modal logic K. We begin the paper by considering a number of potential definitions of clauses and terms for K. The different definitions are evaluated with respect to a set of syntactic, semantic, and complexity-theoretic properties characteristic of the propositional definition. We then compare the definitions with respect to the properties of the notions of prime implicates and prime implicants that they induce. While there is no definition that perfectly generalizes the propositional notions, we show that there does exist one definition which satisfies many of the desirable properties of the propositional case. In the second half of the paper, we consider the computational properties of the selected definition. To this end, we provide sound and complete algorithms for generating and recognizing prime implicates, and we show the prime implicate recognition task to be Pspace-complete. We also prove upper and lower bounds on the size and number of prime implicates. While the paper focuses on the logic K, all of our results hold equally well for multi-modal K and for concept expressions in the description logic ALC.", "creator": "dvips(k) 5.97 Copyright 2008 Radical Eye Software"}}}