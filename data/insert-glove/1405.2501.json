{"id": "1405.2501", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-May-2014", "title": "Using Tabled Logic Programming to Solve the Petrobras Planning Problem", "abstract": "Tabling hymnlike has been used seiwert for some droutsas time to improve efficiency humaniores of tachycardia Prolog programs by memorizing oskaloosa answered queries. The air-to-surface same idea can mpas be naturally eddies used pinnae to conca memorize visited states during balkariya search for planning. In pelado this nyundo paper we present kluivert a planner pontotoc developed olesz in the tuchola Picat penannular language misezhnikov to multi-award-winning solve 1-aug the veldkamp Petrobras planning kedarnath problem. 11-seat Picat is a novel pust Prolog - stegosaurs like shoul language arachidonic that provides kazmierczak pattern cesenatico matching, deterministic rufina and non - 92-90 deterministic zacar\u00edas rules, ministerio and tabling as 55.64 its core modelling and gooseberry solving features. We sikov demonstrate these boyana capabilities using grieg the Petrobras karademir problem, where landmines the everage goal is dolce to plan d. transport 2-33 of cargo items staverton from 1,000-metre ports rotoscoped to platforms t-norm using struve vessels 9.712 with crittendon limited shantaram capacity. studentenverbindungen Monte kolyma Carlo Tree 170m Search has lindsey been so esquilache far the talton best kuraki technique to tackle stahl this 5:3 problem kanang and washburne we will trali show kristiansson that by using milawa tabling devco we can achieve much artek better rosensweig runtime efficiency gherman and woodie better plan quality.", "histories": [["v1", "Sun, 11 May 2014 06:38:25 GMT  (465kb,D)", "http://arxiv.org/abs/1405.2501v1", "To appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["roman bart\\'ak", "neng-fa zhou"], "accepted": false, "id": "1405.2501"}, "pdf": {"name": "1405.2501.pdf", "metadata": {"source": "CRF", "title": "Using Tabled Logic Programming to Solve the Petrobras Planning Problem", "authors": ["ROMAN BART\u00c1K", "NENG-FA ZHOU"], "emails": ["bartak@ktiml.mff.cuni.cz)", "nzhou@acm.org)"], "sections": [{"heading": null, "text": "KEYWORDS: tabling, resource-bounded search, symmetry breaking, planning, logistics"}, {"heading": "1 Introduction", "text": "Prolog and other logic programming languages are usually not assumed as the first-choice programming language for developing real-life planning applications. In this paper we shall demonstrate that Picat, a novel Prolog-like language, provides strong support to solve hard and realistic planning problems. In particular, we will propose a method to solve the Petrobras logistic problem introduced in the Fourth International Competition on Knowledge Engineering for Planning and Scheduling (ICKEPS 2012). Picat allowed us to develop a declarative model of the problem. We exploited Picat tabling as a mechanism to help the classical depth-first search to resolve non-deterministic decisions. We will experimentally show that the proposed model beats the existing techniques both in runtime and in generating plans with lower fuel consumption.\nThe paper is organized as follows. We will first describe the Petrobras planning problem and survey existing techniques applied to this problem. After that we will introduce our solving approach which is based on decomposition of the problem and on tabling-friendly representation of search states. This allowed us to exploit tabling to remove re-exploration of already visited search states. Finally, we will present experimental comparison of our method with existing techniques.\nar X\niv :1\n40 5.\n25 01\nv1 [\ncs .A\nI] 1"}, {"heading": "2 Petrobras Problem", "text": "The Petrobras problem has been introduced in the Fourth International Competition on Knowledge Engineering for Planning and Scheduling (ICKEPS 2012) as one of reallife challenge problems. The major task of the competition was to model the problems formally as well as to solve them. In this section we will first give some details of the Petrobras problem and then we will survey the techniques that have been applied to solve the problem."}, {"heading": "2.1 Problem Specification", "text": "The Petrobras problem is a logistic problem of planning cargo deliveries from ports to oil platforms. This problem is motivated by a real-life problem of the Brazilian oil company Petrobras. A complete description of the problem including example data can be found in (Vaquero et al. 2012).\nThe problem can be described as follows. There are several identical vessels with limited cargo capacity and initial fuel levels. At the beginning each vessel is in one of two waiting areas (marked A1 and A2 in Figure 1). A set of cargo items is prepared in two ports (marked P1 and P2 in Figure 1). Each cargo item has a specific weight and a destination where the item should be delivered. Vessels navigate to ports where they can load cargo items while respecting the vessels\u2019 capacity limits. Then the vessels navigate to platforms where they unload the cargo. After entering a port or a platform (and before loading and unloading), each vessel must dock. The vessel must undock before leaving the port and the platform. At most two vessels can be docked simultaneously in ports and at most one vessel can be docked at a platform. If a port or a platform is occupied then the next vessel must wait before docking. Docking and undocking operations take a constant time while the durations of loading and unloading operations depend linearly on the weight of cargo. Vessels consume fuel when they navigate between waiting areas, ports, and platforms. The quantity of consumed fuel and the time necessary to travel depend linearly on the distance between the locations and also on the load of the vessel. Only two levels of load, loaded and empty, are distinguished. Vessels have limited-capacity fuel tanks; the fuel tanks can be refilled in ports and in some platforms. It is important to ensure that at any time, each vessel has enough fuel to go to the nearest refueling station. At the end, the vessels are supposed to be back in one of the waiting areas.\nSummarizing the above text, there are six operations, navigate, dock, undock, load, unload, and refuel, that each vessel can do. Only refueling can run in parallel with loading or unloading, while any other pair of operations for a single vessel cannot overlap in time. The vessel must be docked before loading, unloading, and refueling, and it must be undocked before navigating. We are given the initial locations and fuel levels of vessels and the initial location, weight, and destination of each cargo item. The task is to plan operations for vessels in such a way that all cargo items are delivered.\nThe problem formulation contains several metrics, namely the total consumed fuel, the number of vessels used to solve the problem, the size of waiting queues, the total amount of time (makespan), and the docking cost. All these metrics are supposed to be minimized."}, {"heading": "2.2 Existing Solving Approaches", "text": "Several techniques have been tried to tackle the Petrobras challenge. The first three approaches, namely classical planning, temporal planning, and Monte Carlo Tree Search were introduced in (Toropila et al. 2012), while the forth approach based on finite state automata and macro actions is described in (Barta\u0301k and Zhou 2013).\nThe classical planning approach modeled the problem in PDDL 3.0 (Gerevini and Long 2005) with numerical fluents describing the restricted resource capacities (fuel tank, cargo capacity). This model used actions as specified in the problem formulation, namely: navigate-empty-vessel, navigate-nonempty-vessel, load-cargo, unload-cargo, refuel-vesselplatform, refuel-vessel-port, dock-vessel, undock-vessel. SGPlan 6.0 (Hsu and Wah 2008) was used to solve the problem while optimizing fuel consumption. Action durations were added to the solution in the post-processing stage.\nThe temporal planning approach modeled the problem in PDDL 3.1 (Kovacs 2011) with fluents and durative actions. Basically the same set of actions as in the classical planning approach was used with added durations. This model supports concurrency of actions directly. The Filuta planner (Dvor\u030ca\u0301k and Barta\u0301k 2010) was used to solve the problem while optimizing makespan. Filuta uses ad-hoc solvers to handle resources, namely unary, consumable, and reservoir resources are supported.\nThe third approach exploited Monte Carlo Tree Search (MCTS) techniques that become recently popular in computer Go. To allow using MCTS, a different action model was applied to obtain finite plans in search branches. This model is based on four abstract actions: Load, Unload, Refuel, GoToWaitingArea. These actions describe \u201cintentions\u201d and they are decomposed to primitive actions based on situation (state). The MCTS solver used a specific objective function combining several metrics: usedFuel + 10 \u2217 numActions + 5 \u2217makespan. Among the above three approaches, the MCTS was the clear winner as it generated\nplans with both smallest makespan and smallest total fuel consumption. The Filuta planner was also able to solve all benchmark problems (up to 10 vessels and up to 15 cargo items) but the generated plans were consistently worse than the plans obtained by MCTS (about 30% longer makespan and 130 % more fuel). This motivated another approach whose goal was to explain the good performance of MCTS. This last approach was again based on grouping sequences of actions into macro-actions similar to those in the MCTS method. The allowed sequences of macro-actions were described by a finite state automaton (Barta\u0301k and Zhou 2013) which guides the planner. Straightforward leftto-right integrated planning and scheduling was used with simple heuristic estimating makespan, which was the primary objective. This solver was implemented in B-Prolog and it was the first attempt to exploit a tabling mechanism in the Petrobras problem. Unfortunately, due to involvement of time variables, the number of states was too large for tabling when more than six cargo items were assumed. This approach generated plans with makespan smaller or comparable to MCTS, but with the total fuel consumption closer to the Filuta planner (see Figure 4)."}, {"heading": "3 Motivation for Tabling in Planning", "text": "Though the first logic programming language PLANNER (Hewitt 1969) was designed as \u201ca language for proving theorems and manipulating models in a robot\u201d and planning has been an important problem domain for Prolog (Warren 1974), there has been little success in applying Prolog to planning. One of the reasons is the built-in computation mechanism based on depth-first search where all information collected in one search branch is forgotten when backtracking and exploring a parallel search branch. Hence straightforward Prolog-based planners are prone to revisiting already explored states and to looping. Tabling (Warren 1992) is a mechanism that can help there without sacrificing the declarative nature of Prolog programs.\nThough planning techniques made a great leap in recent years, there are still many problems where classical planning approaches fail. One of such problems is Sokoban that has been adopted for ASP and IPC competitions (Faber 2013). The early B-Prolog program with tabling showed the capabilities of tabling by providing a nice declarative model of the Sokoban problem that lead to a very good performance (Zhou and Dovier 2011). However, the direct motivation for our research of exploiting tabling in the Petrobras domain was the famous Nomystery domain used in IPC 2011 and ASP 2013 (Nakhost and Hoffmann 2013). Nomystery is a transportation planning problem that can be described as follows. Given a weighted directed graph modeling a network of locations, a truck that is located initially at a location, and a set of packages each of which has an initial location and a destination, the objective of the problem is to find a plan for the truck to transport the packages from their initial locations to their destinations. The truck has some initial fuel and each transportation action (moving from location to another location) consumes some fuel defined by the weight of the edge in the graph. An optimization version of the problem can be defined as finding a plan with the minimal total fuel consumption.\nWe solved the Nomystery problem in B-Prolog (B-Prolog 2014) and later in Picat (Picat 2014) in a straightforward way as finding a path in the state space. We modeled the state as a current location of truck, its fuel level, a set of loaded cargo, and a set of cargoes to be delivered. Three types of state transitions were assumed, namely moving\nbetween two connected locations, loading cargo, and unloading cargo. A non-negative fuel level was required in each state. The only non-determinism to be explored by the search algorithm was moving between locations as we handled loading and unloading cargo deterministically using the following rules:\n\u2022 if the truck is in a location where some cargo to deliver is placed then the cargo is always loaded to the truck, and \u2022 if the truck is at a location where some loaded cargo should be delivered then the cargo is always unloaded from the truck.\nThis approach was possible as there is no capacity limit for cargo in the truck and hence we can load as many cargo items as we need, move them together, and unload them only in their destinations. This simple declarative model in Picat performed surprisingly well and it solved all of the Nomystery instances (in less than one minute per instance) used in IPC 2011, including the hardest instance which was not solved by any of the participating planners.\nThe Nomystery domain is very close to the Petrobras problem which motivated us to explore a similar modelling technique to solve the Petrobras problem. The previous attempt using B-Prolog (Barta\u0301k and Zhou 2013) was promising but the results regarding total fuel consumption were not as good as those from the MCTS approach. Hence we focus on minimizing the fuel consumption which is also the major metric in the Nomystery domain. There are following major differences of the Petrobras problem from the Nomystery domain (assuming vessels as straightforward counterparts for trucks):\n\u2022 the capacity of a vessel to transport cargo is limited (hence it is not possible to load all cargo to a single vessel), \u2022 the fuel capacity of a vessel is limited (hence refueling may be necessary to visit required destinations), \u2022 there are more than one vessel."}, {"heading": "4 A Solving Approach", "text": "To solve the Petrobras problem we decomposed the problem into sub-problems solved separately. If the decomposition is done right then it significantly increases efficiency of the solver as the sub-problems can be solved independently. On the other hand, using decomposition may hamper solution quality as the combination of optimal solutions of sub-problems may not be the optimal solution of the original problem. We focus on optimizing fuel consumption in the Petrobras problem and we will discuss how our decomposition decisions influence feasibility and optimality of solutions.\nWe first decomposed the problem into planning and scheduling parts. The planning task consists of deciding which actions are necessary to deliver all cargo. Fuel consumption and limited fuel and cargo capacities of vessels are assumed during planning, while actions\u2019 durations and port and platform docking capacities are left to scheduling. The scheduling task then consists of allocating actions to particular times. One should realize that a feasible plan can always be scheduled. The plan describes causal relations between the actions so we can allocate the actions to earliest possible start times while respecting these causal (precedence) relations. The port and platform docking capacity constraints\ncan also be easily satisfied as the vessel can wait when the port or platform is occupied by another vessel. Hence for any feasible plan we can find a feasible schedule.\nFuel consumption depends only on the plan and it is independent of particular time allocation (fuel is consumed by the navigation actions and these actions are decided during the planning stage). Hence optimizing fuel consumption can be done during planning without being influenced by the scheduling decisions. In the rest of the paper, we will focus on the planning task with the main objective to minimize consumed fuel.\nSplitting the Petrobras problem to planning and scheduling stages has already been applied in the classical planning approach that we described above (Toropila et al. 2012). That approach was not successful because the planner was not able to generate the plans for larger problems. Hence proposing an efficient planner is an interesting task itself. The tabled approach to solve the Nomystery domain demonstrated that using tabling is a promising direction to solve logistic problems.\nThe classical planning task is basically about finding a sequence of transitions in the state space. Using a straightforward model with world states and transitions defined by the primitive actions would not work (this is what the classical planning approach tried). Tabling itself converts tree search to graph search so it can only remove repeated exploration of already visited states. However, if there are many reachable states then tabling fills up memory very fast. Hence, we decided for further problem decomposition with a careful definition of search states and transitions to remove symmetries."}, {"heading": "4.1 Symmetries and Representation of States", "text": "There are many symmetries in the Petrobras problem. First, all vessels in the problem are identical, meaning they have exactly the same weight capacity and fuel capacity limits and the same speed and fuel consumption that only depends on whether any cargo is loaded or not. If two vessels with identical fuel levels are located at the same place then these vessels are indistinguishable in the plan. Hence we identify vessels by location and fuel level (see below) so we can easily recognize such symmetries and select the first vessel from the set of identical vessels deterministically during planning. There is a similar symmetry of cargo items. Two cargo items located in the same port with identical weights and destinations are indistinguishable. Though this situation is rare, we handle it in the procedure for selecting cargo for transport (see below).\nBased on above observations, we represent the main search states as positions of cargo items and vessels. We completely omit identifications of vessels and cargo items in this representation. A vessel is identified by its location and a fuel level, while the cargo item is identified by its origin, destination and weight. We group the vessels based on their location and similarly we group the cargo items first based on their origin and then by their destination. In particular, we represent the set of cargo items using a list of lists:\n[[OriginLoc, [DestinationLoc, Weight1,Weight2,...]], ...]\nwhere the list of cargo weights is sorted downward to remove symmetrical list representations of the same set. Similarly, we represent the set of vessels as the following list of lists:\n[[Location, FuelLevel1, FuelLevel2,...], ...]\nThe list of fuel levels is sorted upward to remove symmetries. For example, the initial state of the Petrobras problem (Vaquero et al. 2012) is represented as follows:\nCargo = [[p1,[f1,20],[f2,30,15],[f3,10],[f4,15],[f5,25],[f6,5]],\n[p2,[f1,40],[f2,30],[f3,20],[g1,20,15],[g2,30,20],[g4,8]]]\nVessels = [[a1,400,400,400,400,400,400],\n[a2,400,400,400,400]]"}, {"heading": "4.2 Representation of Transitions", "text": "In the cargo and vessel representations, we do not model states where cargo is loaded to vessels. Motivated by successful MCTS and B-Prolog approaches, we define the state transition as a sequence of following operations:\n1. (if necessary) move an empty vessel to a port with cargo waiting to delivery, 2. dock the vessel, refuel it (ports are among the refueling stations), load selected\ncargo, and undock the vessel,\n3. as an option, move the vessel to another port with some cargo waiting and repeat\nstep (2) or continue with the next step,\n4. transport the loaded cargo to required destinations and finish with an empty vessel\neither in a port with some cargo waiting or at the waiting area.\nAfter performing the above steps, the selected vessel will be empty again located in a waiting area or at a port with cargo to deliver. Basically, there are following branching decisions in steps (1)-(3):\n1. select a port, 2. select a vessel for delivery, 3. select cargo in the port while respecting capacity limit of the vessel (note that all\nvessels have the same capacity limit),\n4. plan delivery of cargo items.\nWe explore all ports with some undelivered cargo. For the selected port we deterministically select a vessel closest to that port (if there are more vessels at the closest location then the vessel with the lowest fuel level is selected). Then we explore all subsets of cargo items in the port such that the weight of selected cargo is below the vessel weight limit. From these cargo sets we exclude the sets that can be \u201cimproved\u201d by adding a cargo item going to a destination that is already included in the set. For example, if the cargo set Cargo contains items going to destinations {f1, f3, g2} and there is another cargo item C going to destination f3 such that C can be added to Cargo while respecting the weight capacity limit, then the set Cargo is not assumed as a viable set for delivery (Cargo \u222a {C} can be delivered using the same fuel consumption as Cargo, see the explanation below). If cargo in the first port is decided, we use the same process to decide if some cargo will be loaded in another port (now, the vessel is known so we only decide the cargo set and move the vessel to the next port). The exploration of alternatives is done using standard backtracking with tabling.\nThe Picat encoding of the above decision sequence is given in Figure 2. Picat uses similar programming principles as Prolog with some extensions such as functions (e.g.\naddCargo, addVessel) and possibility to denote deterministic rules (=>) with guards describing when the rule can be selected (see the second rule in Figure 3). The keyword tabling denotes that the next predicate will be tabled. The \u2019+\u2019 arguments are input, the \u2019-\u2019 arguments are output, and the \u2019min\u2019 argument is being minimized. Briefly speaking, for all input arguments of a query, the tabling mechanism remembers the computed outputs so the next time when a query with the same input is asked, the answer is recovered from memory rather than recomputed. If there is a minimization parameter then the tabling mechanism remembers only those answers with the smallest value of this argument. In our particular example, for each state (cargo items to deliver and vessels\u2019 locations) we remember the plan with the smallest fuel consumption. The details of Picat syntax and semantics are described in (Picat 2014).\nIt remains to describe how to find a plan to deliver loaded cargo items. First, one should realize that this plan does not depend on cargo weights, but the plan depends on the delivery locations only. This observation is very important because it allows us to define the search space with states identified with the location of vessel, its fuel level, and a set of destinations to visit. We can again use tabling to find a plan with minimal fuel consumption as Figure 3 shows. Note that refueling is hidden in navigation between two delivery locations. If there is not enough fuel then a refueling station is visited in the route. Moreover when the vessel visits a platform with a refueling station, we always plan a refueling operation there.\nThe global plan is combined from partial plans to deliver sets of cargo items. This way we significantly reduced the search space, but obviously there is no guarantee to find the globally optimal plan. Nevertheless as the experimental evaluation showed, this approach can still find plans better than the existing approaches."}, {"heading": "4.3 Branch and Bound", "text": "One of the disadvantages of pure tabling when applied to optimization problems is exploration of solutions that are known to be worse than a solution found so far. If the solution cost is not decreasing when continuing search, one can use some form of resourcebounded search to remove this deficiency. This is for example the case of path finding with non-negative-cost arcs. Fuel consumption is another example of non-decreasing cost as delivering more cargo items will never require less fuel.\nIn our approach we suggest using branch-and-bound in the top search procedure plan. The method works as follows. We keep the quantity of already consumed fuel as an extra non-tabled parameter of the plan procedure. To estimate the quantity of fuel required to deliver the remaining cargo we can use the procedure path_plan applied to a relaxed problem. We relax the weight limit of vessels and we assume that an empty vessel is ready in each port. Using path_plan we compute the optimal path to deliver that cargo. We relax the weight capacity limit of the vessel but we assume the fuel tank capacity limit in this computation. If the sum of already consumed fuel and expected fuel exceeds the bound then we cut search and backtrack. This is a form of look-ahead and it is used in all modern search algorithms including the famous A*. The bound is stored on a blackboard as the fuel consumption of the best plan found so far. The initial bound is set to a large-enough number."}, {"heading": "5 Experimental Results", "text": "We first experimentally compare our system with the Filuta planner and the MCTS solver from (Toropila et al. 2012) and with the B-Prolog system from (Barta\u0301k and Zhou 2013). We omit the SGPlan (classical planning) from the comparison as it was not competitive and cannot solve problems with more than six cargo items. We re-use here the results reported in (Toropila et al. 2012), where the experiments were run on the Ubuntu Linux machine equipped with Intel Core i7-2600 CPU @ 3.40GHz and 4GB of memory and the planners were allowed to use approximately 10 minutes of runtime. For the B-Prolog\nimplementation we re-use the results reported in (Barta\u0301k and Zhou 2013), where the experiments run on the MacOS X 10.7.5 (Lion) machine with 1.8 GHz Intel Core i7 CPU and 4GB of memory and the best results found within one minute of runtime were presented. Our Picat implementation runs under MacOS X 10.9.1 (Mavericks) machine with 1.7 GHz Intel Core i7 CPU and 8GB of memory.\nThe original specification of the Petrobras problem (Vaquero et al. 2012) contains just one set of real-life motivated data. This set consists of two waiting areas, two ports, ten platforms, ten vessels, and fifteen cargo items. Table 1 shows the comparison of major metrics for all tested solvers for the Petrobras problem. The Picat-based planner improved the already very good fuel consumption of the MCTS solution. Moreover, the Picat-based planner proved optimality taking into account the assumptions restricting allowed plans and it run orders of magnitude faster than all other approaches. Makespan is not that good which is caused by using only three vessels (to get good fuel efficiency) while the other approaches used more vessels in parallel. In fact, the Picat-generated plan can use two vessels to decrease the docking cost to 311k while preserving the values of other metrics (a different schedule is used).\nTo understand better the behavior of the planners, we re-used the benchmark problems suggested in (Toropila et al. 2012). These problems use the same network of waiting areas, ports, and platforms taken from the Petrobras problem. Two scenarios were proposed in (Toropila et al. 2012), one with 3 vessels (Group A) and one with 10 vessels (Group B). For each scenario, we varied the number of cargo items from 1 to 15. Figure 4 shows the comparison of various metrics for the discussed approaches (some data for the B-Prolog were not available). The experiment confirmed that the Picat-based planner finds the best plans regarding fuel consumption. Again, in all problems, the Picat-based planner run in less than one second (see Figure 5) and it proved optimality taking in account the assumptions restricting allowed plans. This comparison also clearly shows the effect of using more vessels in parallel. To achieve the smallest fuel consumption Picat usually used less vessels than Filuta and MCTS. When more vessels are used to deliver more cargo, the makespan goes down even if more cargo is to deliver. Docking cost is basically the same for all approaches as it is mainly determined by the time to load cargo and by the number of visits in ports (this cost depends on the time spent in ports).\nTo see the contribution of various Picat solving approaches we compared them using the benchmark set with 10 vessels. We used the Picat code as introduced in this paper, but we modified the solving mechanism. In particular, we compared the following approaches to solve the problem:\n\u2022 using branch-and-bound with look-ahead but no tabling, \u2022 using tabling only without branch-and-bound, \u2022 using tabling with branch-and-bound but with no look-ahead \u2022 using tabling with branch-and-bound including look-ahead (this is the method that\nwe used to compare with other approaches).\nFigure 5 shows the comparison of runtimes in milliseconds (a logarithmic scale). The conclusion from this experiment is obvious. Tabling is critical to solve the problem especially for route optimization as implemented using the procedure path_plan. Without tabling, we cannot solve the problem with 12 cargo items within the limit of one hour. The reason is that path planning is done frequently in alternative top search branches (called in plan), but with the same set of locations to visit. By using tabling the system stores the found optimal paths so the next time, it can re-use them rather than finding them again. Still, tabling alone is not enough and it runs our of memory for problems with 15\ncargo items. Adding branch-and-bound is useful as it prevents exploring plans that are already worse than the best-so-far plan, but it decreases the runtime little. Branch-andbound pays-off especially if we can estimate the \u201cfuture\u201d cost. Then the runtime is orders of magnitude smaller in comparison with individual solving techniques. In our case we estimated the fuel consumption to deliver not-yet delivered cargo."}, {"heading": "6 Conclusions", "text": "In this paper we proposed to use tabling as the core technique for solving a real-life motivated Petrobras planning problem (Vaquero et al. 2012). Proper representation of search states as well as the definition of the search space are important for tabling and so we discussed possible restrictions on the plans to be explored during search to make tabling a viable approach. We also implemented a form of resource-bounded search by adding ideas of branch-and-bound with simple look-ahead to tabling. We experimentally showed that the proposed method achieves best-so-far results regarding the quality of plans measured by total fuel consumption. Moreover, the runtime of the proposed planner is the lowest among all methods applied to this problem so far. The planner was implemented in Picat, but similar results can be achieved when using other Prolog-like languages with tabling such as B-Prolog.\nWe applied the ideas presented in this paper to other planning problems namely the Nomystery domain (Nakhost and Hoffmann 2013) and Sokoban (Zhou and Dovier 2011). It seems that tabling is an appropriate method to solve such planning problems. Nevertheless, this paper also showed that tabling alone is not enough for optimization problems and that adding branch-and-bound with estimate of future cost is critical for runtime efficiency. We have implemented the branch-and-bound procedure aside tabling (using the blackboard mechanism) but the paper shows a direction for possible future improvements of the tabling mechanism to handle optimization problems better.\nThe Petrobras problem belongs among multi-criteria optimization problems. Optimizing fuel consumption seems to minimize the number of vessels used, but the negative consequence is increasing makespan. However adding time among the tabled arguments\nhampers performance as the B-Prolog planner showed (Barta\u0301k and Zhou 2013) and so the open question is how to handle such multi-criteria optimization. Though makespan is one of the metrics of the Petrobras problem, we understood that it is less important than fuel consumption and the number of vessels used. Practically, among the time-based criteria, it seems that delivering cargo by specified deadlines is more critical and this is the direction of our future extension towards a time-aware planner."}, {"heading": "7 Acknowledgements", "text": "Roman Barta\u0301k is supported by the Czech Science Foundation under the project PlanEx (P103-10-1287)."}], "references": [{"title": "On Modeling Planning Problems: Experience From The Petrobras Challenge", "author": ["R. Bart\u00e1k", "N.F. Zhou"], "venue": "Proceedings of MICAI 2013, Part II,", "citeRegEx": "Bart\u00e1k and Zhou,? \\Q2013\\E", "shortCiteRegEx": "Bart\u00e1k and Zhou", "year": 2013}, {"title": "Integrating time and resources into planning", "author": ["Dvo\u0159\u00e1k F", "R. Bart\u00e1k"], "venue": "Proceedings of ICTAI 2010,", "citeRegEx": "F. and Bart\u00e1k,? \\Q2010\\E", "shortCiteRegEx": "F. and Bart\u00e1k", "year": 2010}, {"title": "BNF description of PDDL 3.0, http://cs-www.cs.yale.edu/ homes/dvm/papers/pddl-bnf.pdf", "author": ["A. Gerevini", "D. Long"], "venue": null, "citeRegEx": "Gerevini and Long,? \\Q2005\\E", "shortCiteRegEx": "Gerevini and Long", "year": 2005}, {"title": "Planner: A language for proving theorems in robots", "author": ["C. Hewitt"], "venue": "In IJCAI,", "citeRegEx": "Hewitt,? \\Q1969\\E", "shortCiteRegEx": "Hewitt", "year": 1969}, {"title": "The SGPlan planning system in IPC-6, http://wah.cse.cuhk. edu.hk/wah/Wah/papers/C168/C168.pdf", "author": ["C. Hsu", "B.W. Wah"], "venue": null, "citeRegEx": "Hsu and Wah,? \\Q2008\\E", "shortCiteRegEx": "Hsu and Wah", "year": 2008}, {"title": "BNF definition of PDDL 3.1, http://www.plg.inf.uc3m.es/ ipc2011-deterministic/OtherContributions?action=AttachFile&do=view&target= kovacs-pddl-3.1-2011.pdf", "author": ["D.L. Kovacs"], "venue": null, "citeRegEx": "Kovacs,? \\Q2011\\E", "shortCiteRegEx": "Kovacs", "year": 2011}, {"title": "Nomystery. https://www.mat.unical.it/aspcomp2013/ Nomystery", "author": ["H. Nakhost", "J. Hoffmann"], "venue": null, "citeRegEx": "Nakhost and Hoffmann,? \\Q2013\\E", "shortCiteRegEx": "Nakhost and Hoffmann", "year": 2013}, {"title": "Three Approaches to Solve the Petrobras Challenge: Exploiting Planning Techniques for Solving Real-Life Logistics Problems", "author": ["D. Toropila", "F. Dvo\u0159\u00e1k", "O. Trunda", "M. Hanes", "R. Bart\u00e1k"], "venue": "Proceedings of ICTAI", "citeRegEx": "Toropila et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Toropila et al\\.", "year": 2012}, {"title": "Planning and scheduling ship operations on petroleum ports and platform", "author": ["T.S. Vaquero", "G. Costa", "F. Tonidandel", "H. Igreja", "Silva J. R", "C. Beck"], "venue": "Proceedings of the Scheduling and Planning Applications Workshop,", "citeRegEx": "Vaquero et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Vaquero et al\\.", "year": 2012}, {"title": "WARPLAN: A system for generating plans", "author": ["D. Warren D. H"], "venue": "Technical Report DCL Memo 76,", "citeRegEx": "H.,? \\Q1974\\E", "shortCiteRegEx": "H.", "year": 1974}, {"title": "Memoing for Logic", "author": ["D.S. Warren"], "venue": "Programs, CACM,", "citeRegEx": "Warren.,? \\Q1992\\E", "shortCiteRegEx": "Warren.", "year": 1992}, {"title": "A Tabled Prolog Program for Solving Sokoban", "author": ["Zhou", "N.-F", "A. Dovier"], "venue": "Proceedings of the 26th Italian Conference on Computational Logic (CILC", "citeRegEx": "Zhou et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhou et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 8, "context": "A complete description of the problem including example data can be found in (Vaquero et al. 2012).", "startOffset": 77, "endOffset": 98}, {"referenceID": 8, "context": "Position of ports and waiting areas in the Petrobras problem (Vaquero et al. 2012).", "startOffset": 61, "endOffset": 82}, {"referenceID": 7, "context": "The first three approaches, namely classical planning, temporal planning, and Monte Carlo Tree Search were introduced in (Toropila et al. 2012), while the forth approach based on finite state automata and macro actions is described in (Bart\u00e1k and Zhou 2013).", "startOffset": 121, "endOffset": 143}, {"referenceID": 0, "context": "2012), while the forth approach based on finite state automata and macro actions is described in (Bart\u00e1k and Zhou 2013).", "startOffset": 97, "endOffset": 119}, {"referenceID": 2, "context": "0 (Gerevini and Long 2005) with numerical fluents describing the restricted resource capacities (fuel tank, cargo capacity).", "startOffset": 2, "endOffset": 26}, {"referenceID": 4, "context": "0 (Hsu and Wah 2008) was used to solve the problem while optimizing fuel consumption.", "startOffset": 2, "endOffset": 20}, {"referenceID": 5, "context": "1 (Kovacs 2011) with fluents and durative actions.", "startOffset": 2, "endOffset": 15}, {"referenceID": 0, "context": "The allowed sequences of macro-actions were described by a finite state automaton (Bart\u00e1k and Zhou 2013) which guides the planner.", "startOffset": 82, "endOffset": 104}, {"referenceID": 3, "context": "Though the first logic programming language PLANNER (Hewitt 1969) was designed as \u201ca language for proving theorems and manipulating models in a robot\u201d and planning has been an important problem domain for Prolog (Warren 1974), there has been little success in applying Prolog to planning.", "startOffset": 52, "endOffset": 65}, {"referenceID": 6, "context": "However, the direct motivation for our research of exploiting tabling in the Petrobras domain was the famous Nomystery domain used in IPC 2011 and ASP 2013 (Nakhost and Hoffmann 2013).", "startOffset": 156, "endOffset": 183}, {"referenceID": 0, "context": "The previous attempt using B-Prolog (Bart\u00e1k and Zhou 2013) was promising but the results regarding total fuel consumption were not as good as those from the MCTS approach.", "startOffset": 36, "endOffset": 58}, {"referenceID": 7, "context": "Splitting the Petrobras problem to planning and scheduling stages has already been applied in the classical planning approach that we described above (Toropila et al. 2012).", "startOffset": 150, "endOffset": 172}, {"referenceID": 8, "context": "For example, the initial state of the Petrobras problem (Vaquero et al. 2012) is represented as follows:", "startOffset": 56, "endOffset": 77}, {"referenceID": 7, "context": "We first experimentally compare our system with the Filuta planner and the MCTS solver from (Toropila et al. 2012) and with the B-Prolog system from (Bart\u00e1k and Zhou 2013).", "startOffset": 92, "endOffset": 114}, {"referenceID": 0, "context": "2012) and with the B-Prolog system from (Bart\u00e1k and Zhou 2013).", "startOffset": 40, "endOffset": 62}, {"referenceID": 7, "context": "We re-use here the results reported in (Toropila et al. 2012), where the experiments were run on the Ubuntu Linux machine equipped with Intel Core i7-2600 CPU @ 3.", "startOffset": 39, "endOffset": 61}, {"referenceID": 8, "context": "The results for the Petrobras problem (Vaquero et al. 2012).", "startOffset": 38, "endOffset": 59}, {"referenceID": 0, "context": "implementation we re-use the results reported in (Bart\u00e1k and Zhou 2013), where the experiments run on the MacOS X 10.", "startOffset": 49, "endOffset": 71}, {"referenceID": 8, "context": "The original specification of the Petrobras problem (Vaquero et al. 2012) contains just one set of real-life motivated data.", "startOffset": 52, "endOffset": 73}, {"referenceID": 7, "context": "To understand better the behavior of the planners, we re-used the benchmark problems suggested in (Toropila et al. 2012).", "startOffset": 98, "endOffset": 120}, {"referenceID": 7, "context": "Two scenarios were proposed in (Toropila et al. 2012), one with 3 vessels (Group A) and one with 10 vessels (Group B).", "startOffset": 31, "endOffset": 53}, {"referenceID": 8, "context": "In this paper we proposed to use tabling as the core technique for solving a real-life motivated Petrobras planning problem (Vaquero et al. 2012).", "startOffset": 124, "endOffset": 145}, {"referenceID": 6, "context": "We applied the ideas presented in this paper to other planning problems namely the Nomystery domain (Nakhost and Hoffmann 2013) and Sokoban (Zhou and Dovier 2011).", "startOffset": 100, "endOffset": 127}, {"referenceID": 0, "context": "hampers performance as the B-Prolog planner showed (Bart\u00e1k and Zhou 2013) and so the open question is how to handle such multi-criteria optimization.", "startOffset": 51, "endOffset": 73}], "year": 2014, "abstractText": "Tabling has been used for some time to improve efficiency of Prolog programs by memorizing answered queries. The same idea can be naturally used to memorize visited states during search for planning. In this paper we present a planner developed in the Picat language to solve the Petrobras planning problem. Picat is a novel Prolog-like language that provides pattern matching, deterministic and non-deterministic rules, and tabling as its core modelling and solving features. We demonstrate these capabilities using the Petrobras problem, where the goal is to plan transport of cargo items from ports to platforms using vessels with limited capacity. Monte Carlo Tree Search has been so far the best technique to tackle this problem and we will show that by using tabling we can achieve much better runtime efficiency and better plan quality.", "creator": "LaTeX with hyperref package"}}}