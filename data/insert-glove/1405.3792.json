{"id": "1405.3792", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-May-2014", "title": "Minimum Model Semantics for Extensional Higher-order Logic Programming with Negation", "abstract": "maximianus Extensional higher - ziganda order prewitt logic dorado programming victual has been introduced baja as sugath a generalization 45.89 of motilal classical logic 1.528 programming. voyeur An important giacoletti characteristic seems of sivivatu this gotthard paradigm is sesiidae that it preserves all the joshed well - known escapism properties minoans of traditional logic programming. In 9.55 this paper selayang we consider the calthrop semantics of allene negation airness in the vergallo context svedka of classiques the scheibner new relaunched paradigm. botin Using yura some recent komatipoort results dearmond from k.s.k. non - monotonic printings fixed - point sacro theory, kamajor we demonstrate that sketches every 118.32 higher - denied order logic 13:47 program with 1960-70s negation ffrench has panova a unique evidentiality minimum infinite - robs valued 1939-1942 model. In moretz this santero way we obtain aa-12 the heffelfinger first purely model - f.o.b theoretic semantics upregulation for hughleys negation in extensional 71s higher - order logic brooks programming. Using synopsys our approach, we resolve matilde an old paradox racz that was introduced yulara by occhipinti W. kawhia W. siple Wadge harleston in amboseli order licensure to demonstrate the shengyang semantic difficulties limbert of harakat higher - order meningitidis logic drakh programming.", "histories": [["v1", "Thu, 15 May 2014 10:37:42 GMT  (52kb)", "http://arxiv.org/abs/1405.3792v1", null]], "reviews": [], "SUBJECTS": "cs.PL cs.AI cs.LO", "authors": ["angelos charalambidis", "zolt\\'an \\'esik", "panos rondogiannis"], "accepted": false, "id": "1405.3792"}, "pdf": {"name": "1405.3792.pdf", "metadata": {"source": "CRF", "title": "Minimum Model Semantics for Extensional Higher-order Logic Programming with Negation\u2217", "authors": ["Angelos Charalambidis", "Zolt\u00e1n \u00c9sik", "Panos Rondogiannis"], "emails": ["a.charalambidis@di.uoa.gr)", "ze@inf.u-szeged.hu)", "prondo@di.uoa.gr)"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n37 92\nv1 [\nlogic programming. An important characteristic of this paradigm is that it preserves all the well-known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. Using some recent results from non-monotonic fixed-point theory, we demonstrate that every higher-order logic program with negation has a unique minimum infinite-valued model. In this way we obtain the first purely model-theoretic semantics for negation in extensional higher-order logic programming. Using our approach, we resolve an old paradox that was introduced by W. W. Wadge in order to demonstrate the semantic difficulties of higher-order logic programming."}, {"heading": "1 Introduction", "text": "Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming. The key idea behind this paradigm is that all predicates defined in a program denote sets and therefore one can use standard extensional set theory in order to understand their meaning and to reason about them. For example, consider the following simple extensional higher-order program (Charalambidis et al. 2013) stating that a band (musical ensemble) is a group that has at least a singer and a guitarist:\nband(B):-singer(S),B(S),guitarist(G),B(G).\n\u2217 This research is being supported by the Greek General Secretariat for Research and Technology, the National Development Agency of Hungary, and the European Commission (European Regional Development Fund) under a Greek-Hungarian intergovernmental programme of Scientific and Technological collaboration. Project title: \u201cExtensions and Applications of Fixed Point Theory for Non-Monotonic Formalisms\u201d. It is also supported by grant no. ANN 110883 from the National Foundation of Hungary for Scientific Research.\nSuppose that we also have a database of musicians:\nsinger(sally).\nsinger(steve).\nguitarist(george).\nguitarist(grace).\nWe can then ask the query ?-band(B). Since predicates denote sets, an extensional higher-order language will return answers such as B = {sally, george} \u222a L, having the meaning that every set that contains at least sally and george is a potential band.\nA consequence of the set-theoretic nature of extensional higher-order logic programming is the fact that its semantics and its proof theory smoothly extend the corresponding ones for traditional (ie., first-order) logic programming. In particular, every program has a unique minimum Herbrand model which is the greatest lower bound of all Herbrand models of the program and the least fixed-point of an immediate consequence operator associated with the program; moreover, there exists an SLD resolution proof-procedure which is sound and complete with respect to the minimum model semantics.\nOne basic property of all the higher-order predicates that can be defined in the language of (Charalambidis et al. 2013) is that they are monotonic. Intuitively, the monotonicity property states that if a predicate is true of a relation R then it is also true of every superset of R. In the above example, it is clear that if band is true of a relation B then it is also true of any band that is a superset of B. However, there are many natural higher-order predicates that are non-monotonic. Consider for example a predicate single singer band which (apparently) defines a band that has a unique singer:\nsingle singer band(B):-band(B),not two singers(B).\ntwo singers(B):-B(S1),B(S2),singer(S1),singer(S2),not(S1=S2).\nThe predicate single singer band is obviously non-monotonic since it is satisfied by the set {sally, george} but not by the set {sally, steve, george}. In other words, the semantics of (Charalambidis et al. 2013) is not applicable to this extended higher-order language. We are therefore facing the same problem that researchers faced more than twenty years ago when they attempted to provide a sensible semantics to classical logic programs with negation; the only difference is that the problem now reappears in a much more general context, namely in the context of higher-order logic programming.\nThe solution we adopt is relatively simple to state (but non-trivial to materialize): it suffices to generalize the well-founded construction (van Gelder et al. 1991; Przymusinski 1989) to higher-order programs. For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (E\u0301sik and Rondogiannis 2013; E\u0301sik and Rondogiannis 2014). This brings us to the two main contributions of the present paper:\n\u2022 We provide the first model-theoretic semantics for extensional higher-order logic\nprogramming with negation. In this way we initiate the study of a non-monotonic formalism that is much broader than classical logic programming with negation. \u2022 We provide further evidence that extensional higher-order logic programming is\na natural generalization of classical logic programming, by showing that all the well-known properties of the latter also hold for the new paradigm.\nIn the next section we provide an introduction to the proposed semantics for higherorder logic programming and the remaining sections provide the formal development of this semantics. The proofs of all the results have been moved to corresponding appendices."}, {"heading": "2 An Intuitive Overview of the Proposed Semantics", "text": "The starting point for the semantics proposed in this paper is the infinite-valued semantics for ordinary logic programs with negation, as introduced in (Rondogiannis andWadge 2005). In this section we give an intuitive introduction to the infinite-valued approach and discuss how it can be extended to the higher-order case.\nThe infinite-valued approach was introduced in order to provide a minimum model semantics to logic programs with negation. As we are going to see shortly, it is compatible with the well-founded semantics but it is purely model-theoretic1. The main idea of this approach can be explained with a simple example. Consider the program:\np \u2190 r \u2190 \u223cp s \u2190 \u223cq\nUnder the well-founded semantics both p and s receive the value True. However, p is in some sense \u201ctruer\u201d than s. Namely, p is true because there is a rule which says so, whereas s is true only because we are never obliged to make q true. In a sense, s is true only by default. This gave the idea of adding a \u201cdefault\u201d truth value T1 just below the \u201creal\u201d truth T0, and (by symmetry) a weaker false value F1 just above (\u201cnot as false as\u201d) the real false F0. We can then understand negation-as-failure as combining ordinary negation with a weakening. Thus \u223c F0 = T1 and \u223c T0 = F1. Since negations can effectively be iterated, the infinite-valued approach requires a whole sequence . . . , T3, T2, T1 of weaker and weaker truth values below T0 but above the neutral value 0; and a mirror image sequence F1, F2, F3, . . . above F0 and below 0. In fact, to capture the well-founded model in full generality, we need a T\u03b1 and a F\u03b1 for every countable ordinal \u03b1. In other words, the underlying truth domain of the infinite-valued approach is:\nF0 < F1 < \u00b7 \u00b7 \u00b7< F\u03c9 < \u00b7 \u00b7 \u00b7< F\u03b1 < \u00b7 \u00b7 \u00b7< 0 < \u00b7 \u00b7 \u00b7< T\u03b1 < \u00b7 \u00b7 \u00b7< T\u03c9 < \u00b7 \u00b7 \u00b7< T1 < T0\nAs shown in (Rondogiannis and Wadge 2005), every logic program P with negation has a unique minimum infinite-valued model MP. Notice that MP is minimum with respect to a relation\u2291 which compares interpretations in a stage-by-stage manner (see (Rondogiannis andWadge 2005) for details). As it is proven in (Rondogiannis andWadge 2005), if we collapse all the T\u03b1 and F\u03b1 to True and False respectively, we get the well-founded model. For the example program above, the minimum model is {(p, T0), (q, F0), (r, F1), (s, T1)}. This collapses to {(p,True), (q,False), (r,False), (s,True)}, which is the well-founded model of the program.\nAs shown in (Rondogiannis and Wadge 2005), one can compute the minimum infinitevalued model as the least fixed point of an operator TP. It can easily be seen that TP is not monotonic with respect to the ordering relation \u2291 and therefore one can not obtain\n1 In the same way that the equilibrium logic approach of (Pearce 1996) gives a purely logical reconstruction of the stable model semantics.\nthe least fixed point using the classical Knaster-Tarski theorem. However, TP possesses some form of partial monotonicity. More specifically, as it is shown in (Rondogiannis and Wadge 2005; E\u0301sik and Rondogiannis 2014), TP is \u03b1-monotonic for all countable ordinals \u03b1, a property that guarantees the existence of the least fixed point. Loosely speaking, the property of TP being \u03b1-monotonic means that the operator is monotonic when we restrict attention to interpretations that are equal for all levels of truth values that are less than \u03b1. In other words, TP is monotonic in stages (but not overall monotonic).\nThe TP operator is a higher-order function since it takes as argument an interpretation and returns an interpretation as the result. This observation leads us to the main concept that helps us extend the infinite-valued semantics to the higher-order case. The key idea is to demonstrate that the denotation of every expression of predicate type in our higherorder language, is \u03b1-monotonic for all ordinals \u03b1 (see Lemma 5). This property ensures that the immediate consequence operator of every program is also \u03b1-monotonic for all \u03b1 (see Lemma 7), and therefore it has a least fixed-point which is a model of the program. Actually, this same model can also be obtained as the greatest lower bound of all the Herbrand models of the program (see Theorem 2, the model intersection theorem). In other words, the semantics of extensional higher-order logic programming with negation preserves all the familiar properties of classical logic programming and can therefore be considered as a natural generalization of the latter."}, {"heading": "3 Non-Monotonic Fixed Point Theory", "text": "The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (E\u0301sik and Rondogiannis 2013; E\u0301sik and Rondogiannis 2014). The key objective of this area of research is to obtain novel fixed point results regarding functions that are not necessarily monotonic. In particular, the results obtained in (E\u0301sik and Rondogiannis 2013; E\u0301sik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene\u2019s theorem and also the Knaster-Tarski theorem). In this section we provide the necessary material from (E\u0301sik and Rondogiannis 2013; E\u0301sik and Rondogiannis 2014) that will be needed in the next sections.\nSuppose that (L,\u2264) is a complete lattice in which the least upper bound operation is\ndenoted by \u2228 and the least element is denoted by \u22a5. Let \u03ba > 0 be a fixed ordinal. We assume that for each ordinal \u03b1 < \u03ba, there exists a preordering \u2291\u03b1 on L. We write x =\u03b1 y iff x \u2291\u03b1 y and y \u2291\u03b1 x. We define x \u2741\u03b1 y iff x \u2291\u03b1 y but x =\u03b1 y does not hold. Moreover, we write x \u2741 y iff x \u2741\u03b1 y for some \u03b1 < \u03ba. Finally, we define x \u2291 y iff x \u2741 y or x = y.\nLet x \u2208 L and \u03b1 < \u03ba. We define (x]\u03b1 = {y : \u2200\u03b2 < \u03b1 x =\u03b2 y}. A key property that will be used throughout the paper is that if the above preordering relations satisfy certain simple axioms, then the structure (L,\u2291) is a complete lattice; moreover, every function f : L \u2192 L that satisfies some restricted form of monotonicity, has a least fixed point. These ideas are formalized by the following definitions and results.\nDefinition 1 Let (L,\u2264) be a complete lattice equipped with preorderings \u2291\u03b1 for all \u03b1 < \u03ba. Then, L will be called a basic model if and only if it satisfies the following axioms:\n1. For all x, y \u2208 L and all \u03b1 < \u03b2 < \u03ba, if x \u2291\u03b2 y then x =\u03b1 y.\n2. For all x, y \u2208 L, if x =\u03b1 y for all \u03b1 < \u03ba then x = y. 3. Let x \u2208 L and \u03b1 < \u03ba. Let X \u2286 (x]\u03b1. Then, there exists y (denoted by \u2294 \u03b1 X)\nsuch that X \u2291\u03b1 y2 and for all z \u2208 (x]\u03b1 such that X \u2291\u03b1 z, it holds y \u2291\u03b1 z\nand y \u2264 z. 4. If xj , yj \u2208 L and xj \u2291\u03b1 yj for all j \u2208 J then \u2228 {xj : j \u2208 J} \u2291\u03b1 \u2228 {yj : j \u2208 J}.\nLemma 1 Let L be a basic model. Then, (L,\u2291) is a complete lattice.\nDefinition 2 Let A,B be basic models and let \u03b1 < \u03ba. A function f : A \u2192 B is called \u03b1-monotonic if for all x, y \u2208 A if x \u2291\u03b1 y then f(x) \u2291\u03b1 f(y).\nIt should be noted that even if a function f is \u03b1-monotonic for all \u03b1 < \u03ba, then it need not be necessarily monotonic with respect to the relation \u2291 (for a counterexample, see (Rondogiannis and Wadge 2005, Example 5.7, pages 453\u2013454)). Therefore, the standard tools of classical fixed point theory (such as the Knaster-Tarski theorem), do not suffice in order to find the least fixed point of f with respect to the relation \u2291.\nLet us denote by [A m \u2192 B] the set of functions from A to B that are \u03b1-monotonic for\nall \u03b1 < \u03ba.\nTheorem 1 Let L be a basic model and assume that f \u2208 [L m \u2192 L]. Then, f has a \u2291-least pre-fixed point, which is also the \u2291-least fixed point of f .\nThe above theorem will be our main tool for establishing the fact that the immediate consequence operator of any extensional higher order logic program, always has a least fixed point, which is a model of the program."}, {"heading": "4 The Syntax of the Higher-Order Language H", "text": "In this section we introduce the higher-order language H, which extends classical firstorder logic programming to a higher-order setting. The language H is based on a simple type system that supports two base types: o, the boolean domain, and \u03b9, the domain of individuals (data objects). The composite types are partitioned into three classes: functional (assigned to individual constants, individual variables and function symbols), predicate (assigned to predicate constants and variables) and argument (assigned to parameters of predicates).\nDefinition 3 A type can either be functional, predicate, argument, denoted by \u03c3, \u03c0 and \u03c1 respectively and defined as:\n\u03c3 := \u03b9 | \u03b9 \u2192 \u03c3\n\u03c0 := o | \u03c1 \u2192 \u03c0\n\u03c1 := \u03b9 | \u03c0\nWe will use \u03c4 to denote an arbitrary type (either functional, predicate or argument one).\n2 We write X \u2291\u03b1 y iff forall x \u2208 X it holds x \u2291\u03b1 y.\nAs usual, the binary operator \u2192 is right-associative. A functional type that is different than \u03b9 will often be written in the form \u03b9n \u2192 \u03b9, n \u2265 1 (which stands for \u03b9 \u2192 \u03b9 \u2192 \u00b7 \u00b7 \u00b7 \u2192 \u03b9 (n+1)-times). Moreover, it can be easily seen that every predicate type \u03c0 can be written uniquely in the form \u03c11 \u2192 \u00b7 \u00b7 \u00b7 \u2192 \u03c1n \u2192 o, n \u2265 0 (for n = 0 we assume that \u03c0 = o). We can now proceed to the definition of H, starting from its alphabet and continuing with expressions and program clauses:\nDefinition 4 The alphabet of the higher-order language H consists of the following:\n1. Predicate variables of every predicate type \u03c0 (denoted by capital letters such\nas P,Q,R, . . .).\n2. Predicate constants of every predicate type \u03c0 (denoted by lowercase letters\nsuch as p, q, r, . . .).\n3. Individual variables of type \u03b9 (denoted by capital letters such as X,Y,Z, . . .). 4. Individual constants of type \u03b9 (denoted by lowercase letters such as a, b, c, . . .). 5. Function symbols of every functional type \u03c3 6= \u03b9 (denoted by lowercase letters\nsuch as f, g, h, . . .).\n6. The following logical constant symbols: the constants false and true of type o;\nthe equality constant \u2248 of type \u03b9 \u2192 \u03b9 \u2192 o; the generalized disjunction and conjunction constants \u2228\n\u03c0 and \u2227 \u03c0 of type \u03c0 \u2192 \u03c0 \u2192 \u03c0, for every predicate\ntype \u03c0; the generalized inverse implication constants \u2190\u03c0, of type \u03c0 \u2192 \u03c0 \u2192 o, for every predicate type \u03c0; the existential quantifier \u2203\u03c1, of type (\u03c1 \u2192 o) \u2192 o, for every argument type \u03c1; the negation constant \u223c of type o \u2192 o.\n7. The abstractor \u03bb and the parentheses \u201c(\u201d and \u201c)\u201d.\nThe set consisting of the predicate variables and the individual variables of H will be called the set of argument variables of H. Argument variables will be usually denoted by V and its subscripted versions.\nDefinition 5 The set of expressions of the higher-order language H is defined as follows:\n1. Every predicate variable (respectively, predicate constant) of type \u03c0 is an\nexpression of type \u03c0; every individual variable (respectively, individual constant) of type \u03b9 is an expression of type \u03b9; the propositional constants false and true are expressions of type o. 2. If f is an n-ary function symbol and E1, . . . ,En are expressions of type \u03b9, then\n(f E1 \u00b7 \u00b7 \u00b7En) is an expression of type \u03b9.\n3. If E1 is an expression of type \u03c1 \u2192 \u03c0 and E2 is an expression of type \u03c1, then\n(E1 E2) is an expression of type \u03c0.\n4. If V is an argument variable of type \u03c1 and E is an expression of type \u03c0, then\n(\u03bbV.E) is an expression of type \u03c1 \u2192 \u03c0.\n5. If E1,E2 are expressions of type \u03c0, then (E1 \u2227 \u03c0 E2) and (E1 \u2228 \u03c0 E2) are ex-\npressions of type \u03c0.\n6. If E is an expression of type o, then (\u223cE) is an expression of type o. 7. If E1,E2 are expressions of type \u03b9, then (E1 \u2248 E2) is an expression of type o.\n8. If E is an expression of type o and V is a variable of type \u03c1 then (\u2203\u03c1VE) is\nan expression of type o.\nTo denote that an expression E has type \u03c4 we will write E : \u03c4 . The notions of free and bound variables of an expression are defined as usual. An expression is called closed if it does not contain any free variables.\nDefinition 6\nA program clause is a clause p \u2190\u03c0 E where p is a predicate constant of type \u03c0 and E is a closed expression of type \u03c0. A program is a finite set of program clauses.\nExample 1\nThe subset predicate can be defined in H as follows:\nsubset \u2190\u03c0\u2192\u03c0\u2192o \u03bbP.\u03bbQ. \u223c\u2203X((P X)\u2227 \u223c(Q X))\nThe subset predicate is defined by a \u03bb-expression (which obviates the need to have the formal parameters of the predicate in the left-hand side of the definition). Moreover, in the right-hand side we have an explicit existential quantifier for the variable X (in Prolog, if a variable appears in the body of a clause but not in the head, then it is implicitly existentially quantified)."}, {"heading": "5 The Semantics of the Higher-Order Language H", "text": "In this section we specify the semantics of H. We start with the semantics of types and proceed to the semantics of expressions.\nThe meaning of the boolean type o is equal to a partially ordered set (V,\u2264) of truth values. The number of truth values of V will be specified with respect to an ordinal \u03ba > 0. All the results of the paper hold for every initial selection of \u03ba. The set (V,\u2264) is therefore\nF0 < F1 < \u00b7 \u00b7 \u00b7< F\u03b1 < \u00b7 \u00b7 \u00b7< 0 < \u00b7 \u00b7 \u00b7< T\u03b1 < \u00b7 \u00b7 \u00b7< T1 < T0\nwhere \u03b1 < \u03ba.\nDefinition 7\nThe order of a truth value is defined as follows: order(T\u03b1) = \u03b1, order(F\u03b1) = \u03b1 and order(0) = +\u221e.\nWe can now define the meaning of all the types of our language as well as the corre-\nsponding relations \u2264 and \u2291\u03b1. This is performed in the following definitions:\nDefinition 8\nWe define the relation \u2291\u03b1 on the set V for each \u03b1 < \u03ba as follows:\n1. x \u2291\u03b1 x if order(x) < \u03b1; 2. F\u03b1 \u2291\u03b1 x and x \u2291\u03b1 T\u03b1 if order(x) \u2265 \u03b1; 3. x \u2291\u03b1 y if order(x), order(y) > \u03b1.\nNotice that x =\u03b1 y iff either x = y or order(x) > \u03b1 and order(y) > \u03b1.\nDefinition 9 Let D be a nonempty set. Then:\n\u2022 [[\u03b9]]D = D, and \u2264\u03b9 is the trivial partial order such that d \u2264\u03b9 d, for all d \u2208 D; \u2022 [[\u03b9n \u2192 \u03b9]]D = D n \u2192 D. A partial order in this case will not be needed; \u2022 [[o]]D = V , and \u2264o is the partial order of V ; \u2022 [[\u03b9 \u2192 \u03c0]]D = D \u2192 [[\u03c0]]D, and \u2264\u03b9\u2192\u03c0 is the partial order defined as follows: for all\nf, g \u2208 [[\u03b9 \u2192 \u03c0]]D, f \u2264\u03b9\u2192\u03c0 g iff f(d) \u2264\u03c0 g(d) for all d \u2208 D;\n\u2022 [[\u03c01 \u2192 \u03c02]]D = [[[\u03c01]]D m \u2192 [[\u03c02]]D], and \u2264\u03c01\u2192\u03c02 is the partial order defined as follows:\nfor all f, g \u2208 [[\u03c01 \u2192 \u03c02]]D, f \u2264\u03c01\u2192\u03c02 g iff f(d) \u2264\u03c02 g(d) for all d \u2208 [[\u03c01]]D.\nThe subscripts in the above partial orders will often be omitted when they are obvious\nfrom context.\nDefinition 10 Let D be a nonempty set and \u03b1 < \u03ba. Then:\n\u2022 The relation \u2291\u03b1 on [[o]]D is the relation \u2291\u03b1 on V . \u2022 The relation \u2291\u03b1 on [[\u03c1 \u2192 \u03c0]]D is defined as follows: f \u2291\u03b1 g iff f(d) \u2291\u03b1 g(d) for all\nd \u2208 [[\u03c1]]D. Moreover, f \u2741\u03b1 g iff f \u2291\u03b1 g and f(d) \u2741\u03b1 g(d) for some d \u2208 [[\u03c1]]D.\nThe following lemma expresses the fact that all the predicate types correspond to\nsemantic domains that are both complete lattices and basic models:\nLemma 2 Let D be a nonempty set and \u03c0 be a predicate type. Then, ([[\u03c0]]D,\u2264\u03c0) is a complete lattice and a basic model.\nWe now proceed to formally define the semantics of H:\nDefinition 11 An intepretation I of H consists of:\n1. a nonempty set D called the domain of I; 2. an assignment to each individual constant symbol c, of an element I(c) \u2208 D; 3. an assignment to each predicate constant p : \u03c0 of an element I(p) \u2208 [[\u03c0]]D; 4. an assignment to each function symbol f : \u03b9n \u2192 \u03b9 of a function I(f) \u2208 Dn\u2192 D.\nDefinition 12 Let D be a nonempty set. A state s of H over D is a function that assigns to each argument variable V of type \u03c1 of H, of an element s(V) \u2208 [[\u03c1]]D.\nDefinition 13 Let I be an interpretation of H, let D be the domain of I, and let s be a state over D. Then, the semantics of expressions of H with respect to I and s, is defined as follows:\n1. [[false]]s(I) = F0 2. [[true]]s(I) = T0 3. [[c]]s(I) = I(c), for every individual constant c 4. [[p]]s(I) = I(p), for every predicate constant p 5. [[V]]s(I) = s(V), for every argument variable V\n6. [[(f E1 \u00b7 \u00b7 \u00b7En)]]s(I) = I(f) [[E1]]s(I) \u00b7 \u00b7 \u00b7 [[En]]s(I), for every n-ary function sym-\nbol f\n7. [[(E1E2)]]s(I) = [[E1]]s(I)([[E2]]s(I)) 8. [[(\u03bbV.E)]]s(I) = \u03bbd.[[E]]s[V/d](I), where d ranges over [[type(V)]]D 9. [[(E1 \u2228 \u03c0 E2)]]s(I) = \u2228 \u03c0{[[E1]]s(I), [[E2]]s(I)}, where \u2228 \u03c0 is the least upper bound\nfunction on [[\u03c0]]D 10. [[(E1 \u2227 \u03c0 E2)]]s(I) = \u2227 \u03c0{[[E1]]s(I), [[E2]]s(I)}, where \u2227 \u03c0 is the greatest lower\nbound function on [[\u03c0]]D\n11. [[(\u223cE)]]s(I) =\n\n  \n  \nT\u03b1+1 if [[E]]s(I) = F\u03b1 F\u03b1+1 if [[E]]s(I) = T\u03b1 0 if [[E]]s(I) = 0\n12. [[(E1 \u2248E2)]]s(I) =\n{\nT0, if [[E1]]s(I) = [[E2]]s(I) F0, otherwise\n13. [[(\u2203VE)]]s(I) = \u2228\nd\u2208[[type(V)]] D\n[[E]]s[V/d](I)\nFor closed expressions E we will often write [[E]](I) instead of [[E]]s(I) (since, in this\ncase, the meaning of E is independent of s).\nLemma 3 Let E : \u03c1 be an expression and let D be a nonempty set. Moreover, let s be a state over D and let I be an interpretation over D. Then, [[E]]s(I) \u2208 [[\u03c1]]D.\nDefinition 14 Let P be a program and let M be an interpretation over a nonempty set D. Then M will be called a model of P iff for all clauses p \u2190\u03c0 E of P, it holds [[E]](M) \u2264\u03c0 M(p), where M(p) \u2208 [[\u03c0]]D."}, {"heading": "6 Minimum Herbrand Model Semantics for H", "text": "In this section we demonstrate that every program of H has a unique minimum Herbrand model which is the greatest lower bound of all the Herbrand models of the program, and also the least fixed point of the immediate consequence operator of the program. We start with the relevant definitions.\nDefinition 15 Let P be a program. The Herbrand universe UP of P is the set of all terms that can be formed out of the individual constants3 and the function symbols of P.\nDefinition 16 A Herbrand interpretation I of a program P is an interpretation such that:\n1. the domain of I is the Herbrand universe UP of P; 2. for every individual constant c of P, I(c) = c; 3. for every predicate constant p : \u03c0 of P, I(p) \u2208 [[\u03c0]]UP ;\n3 As usual, if P has no constants, we assume the existence of an arbitrary one.\n4. for every n-ary function symbol f of P and for all t1, . . . , tn \u2208 UP, I(f) t1 \u00b7 \u00b7 \u00b7 tn =\nf t1 \u00b7 \u00b7 \u00b7 tn.\nA Herbrand state of a program P is a state whose underlying domain is UP. We denote\nthe set of Herbrand interpretations of a program P by IP.\nDefinition 17 A Herbrand model of a program P is a Herbrand interpretation that is a model of P.\nDefinition 18 Let P be a program. We define the following partial order on IP: for all I, J \u2208 IP, I \u2264IP J iff for every \u03c0 and for every predicate constant p : \u03c0 of P, I(p) \u2264\u03c0 J(p).\nDefinition 19 Let P be a program. We define the following preorder on IP for all \u03b1 < \u03ba: for all I, J \u2208 IP, I \u2291\u03b1 J iff for every \u03c0 and for every predicate constant p : \u03c0 of P, I(p) \u2291\u03b1 J(p).\nThe following two lemmas play a main role in establishing the two central theorems.\nLemma 4 Let P be a program. Then, IP is a complete lattice and a basic model.\nLemma 5 (\u03b1-Monotonicity of Semantics) Let P be a program and let E : \u03c0 be an expression. Let I, J be Herbrand interpretations and s be a Herbrand state of P. For all \u03b1 < \u03ba, if I \u2291\u03b1 J then [[E]]s(I) \u2291\u03b1 [[E]]s(J).\nSince by Lemma 4 the set IP is a basic model (and thus by Lemma 1 is a complete lattice with respect to \u2291), everyM \u2286 IP has a greatest lower bound d M with respect to \u2291. We have the following theorem which generalizes the familiar model intersection theorem for definite first-order logic programs (Lloyd 1987), the model intersection theorem for normal first-order logic programs (Rondogiannis and Wadge 2005, Theorem 8.6) and the model intersection theorem for definite higher-order logic programs (Charalambidis et al. 2013, Theorem 6.8).\nTheorem 2 (Model Intersection Theorem) Let P be a program and M be a nonempty set of Herbrand models of P. Then, d M is also a Herbrand model of P.\nDefinition 20 Let P be a program. The mapping TP : IP \u2192 IP is defined for every p : \u03c0 and for every I \u2208 IP as TP(I)(p) = \u2228 {[[E]](I) : (p \u2190\u03c0 E) \u2208 P}. The mapping TP will be called the immediate consequence operator for P.\nThe following two lemmas are crucial in establishing the least fixed point theorem.\nLemma 6 Let P be a program. For every predicate constant p : \u03c0 in P and I \u2208 IP, TP (I)(p) \u2208 [[\u03c0]]UP .\nLemma 7 Let P be a program. Then, TP is \u03b1-monotonic for all \u03b1 < \u03ba.\nTheorem 3 (Least Fixed Point Theorem) Let P be a program and let M be the set of all its Herbrand models. Then, TP has a least fixed point MP. Moreover, MP = d M.\nThe construction of the least fixed point in the above theorem is similar to the one given for (potentially infinite) propositional programs in (Rondogiannis and Wadge 2005, Section 6). Due to space limitations, we provide a short outline of this procedure. In order to calculate the least fixed point, we start with an interpretation, say I0, which for every predicate constant p of type \u03c11 \u2192 \u00b7 \u00b7 \u00b7 \u03c1n \u2192 o, and for all d1 \u2208 [[\u03c11]]UP , . . . , dn \u2208 [[\u03c1n]]UP , I0(p) d1 \u00b7 \u00b7 \u00b7 dn = F0. We start iterating TP on this interpretation until we get to a point where the additional iterations do not affect the F0 and T0 values. At this point, we reset all the remaining values (regarding predicate constants and arguments that have not stabilized) to F1, getting an interpretation I1. We start iterating TP on I1, until we get to a point where the additional iterations do not affect the F1 and T1 values. We repeat this process for higher ordinals. In particular, when we get to a limit ordinal, say \u03b1, we reset all the values that have not stabilized to a truth value of order less than \u03b1, to F\u03b1. The whole process is repeated for \u03ba times. If the value of certain predicate constants applied to certain arguments has not stabilized after the \u03ba iterations, we assign to them the intermediate value 0. The resulting interpretation is the least fixed point MP."}, {"heading": "7 Resolving a Semantic Paradox of Higher-Order Logic Programming", "text": "One deficiency of extensional higher-order logic programming is the inability to define rules (or facts) that have predicate constants in their heads. The reason of this restriction is a semantic one and will be explained shortly. However, not all programs that use predicate constants in the heads of clauses are problematic. For example, the program\ncomputer scientist(john).\ngood profession(computer scientist).\nhas a clear declarative reading: the denotation of the computer scientist predicate is the relation {john}, while the denotation of good profession is the relation {{john}}.\nIn (Wadge 1991), W. W. Wadge argued that allowing rules to have predicate constants in their heads, creates tricky semantic problems to. Wadge gave a simple example (duplicated below) that revealed these problems; the example has since been used in other studies of higher-order logic programming (such as for example in (Bezem 2001)). We present the example in almost identical phrasing as it initially appeared.\nExample 2 Consider the program:\np(a).\nq(a).\nphi(p).\nq(b):-phi(q).\nOne candidate for minimum Herbrand model is the one in which p and q are true only of a, and phi is true only of p. However, this means that p and q have the same extension, and so themselves are equal. But since p and q are equal, and phi holds for p, it must also hold for q. The fourth rule forces us to add q(b), so that the model becomes\n{p(a), phi(p), q(a), q(b)} (in ad hoc notation). But this is problematic because p and q are no longer equal and q(b) has lost its justification.\nProblems such as the above led Wadge to disallow such clauses from the syntax of the language proposed in (Wadge 1991). Similarly, the higher-order language introduced in (Charalambidis et al. 2013) also disallows this kind of clauses.\nHowever, under the semantics presented in this paper, we can now assign a proper meaning to programs such as the above. Actually, higher order facts such as phi(p). above, can be seen as syntactic sugar in our fragment. A fact of this form simply states that phi is true of a relation if this relation is equal to p. This can simply be written as:\nphi(P):-equal(P,p).\nwhere equal is a higher-order equality relation that can easily be axiomatized in H using the subset predicate (see Example 1):\nequal \u2190 \u03bbP.\u03bbQ.(subset P Q) \u2227 (subset Q P).\nOne can compute the minimum model of the resulting program using the techniques presented in this paper. The paradox of Example 2 is no longer valid since in the minimum infinite-valued model the atom q(b) has value 0. Intuitively, this means that it is not possible to decide whether q(b) should be true or false.\nThe above discussion leads to an easy way of handling rules with predicate constants in their heads. The predicate constants are replaced with predicate variables and higherorder equality atoms are added in the bodies of clauses. Then, appropriate clauses defining the equal predicates for all necessary types, are added to the program. The infinite valued semantics of the resulting program is taken as the meaning of the initial program."}, {"heading": "8 Future Work", "text": "We have presented the first, to our knowledge, formal semantics for negation in extensional higher-order logic programming. The results we have obtained generalize the semantics of classical logic programming to the higher order setting. We believe that the most interesting direction for future work is the investigation of implementation techniques for (fragments of) H, based on the semantics introduced in this paper. One possible option would be to examine the implementation of a higher order extension of Datalog with negation. We are currently examining these possibilities."}, {"heading": "Appendix A Proof of Lemma 2", "text": "We will make use of certain facts established in (E\u0301sik and Rondogiannis 2014).\nSuppose that L is a basic model. For each x \u2208 L and \u03b1 < \u03ba, we define x|\u03b1 = \u2294 \u03b1{x}. It was shown in (E\u0301sik and Rondogiannis 2014) that x =\u03b1 x|\u03b1 and x|\u03b1 =\u03b1 x|\u03b2 , x|\u03b1 \u2264 x|\u03b2 for all \u03b1 < \u03b2 < \u03ba. Moreover, x = \u2228\n\u03b1<\u03ba x|\u03b1. Also, for all x, y \u2208 L and \u03b1 < \u03ba, it holds x =\u03b1 y\niff x|\u03b1 =\u03b1 y|\u03b1 iff x|\u03b1 = y|\u03b1, and x \u2291\u03b1 y iff x|\u03b1 \u2291\u03b1 y|\u03b1. And if x \u2291\u03b1 y, then x|\u03b1 \u2264 y|\u03b1. It is also not difficult to prove that for all x \u2208 L and \u03b1, \u03b2 < \u03ba, (x|\u03b1)|\u03b2 = x|min{\u03b1,\u03b2}. More generally, whenever X \u2286 (z]\u03b1 and \u03b2 \u2264 \u03b1 < \u03ba, it holds ( \u2294 \u03b1 X)|\u03b2 = \u2294 \u03b2 X . And if \u03b1 < \u03b2, then ( \u2294\n\u03b1 X)|\u03b2 = \u2294 \u03b1 X . Finally, we will make use of the following two results from (E\u0301sik\nand Rondogiannis 2014):\nProposition 8 Let A,B be basic models and let \u03b1 < \u03ba. If fj : A \u2192 B is an \u03b1-monotonic function for each j \u2208 J , then so is f = \u2228\nj\u2208J fj defined by f(x) = \u2228 j\u2208J fj(x).\nLemma 9 Let Z be an arbitrary set and L be a basic model. Then, Z \u2192 L is a basic model with the pointwise definition of the order of relations \u2264 and \u2291\u03b1 for all \u03b1 < \u03ba.\nSuppose that A,B are basic models. By Lemma 9 the set A \u2192 B is also a model, where the relations \u2264 and \u2291\u03b1, \u03b1 < \u03ba, are defined in a pointwise way (see (E\u0301sik and Rondogiannis 2014, Subsection 5.3) for details). It follows that for any set F of functions A \u2192 B, \u2228\nF can be computed pointwisely. Also, when F \u2286 (f ]\u03b1 for some f : A \u2192 B, \u2294\n\u03b1 F for \u03b1 < \u03ba can be computed pointwisely. We want to show that whenever f : A \u2192 B, \u03b2 < \u03ba and F \u2286 (f ]\u03b2 is a set of functions\nsuch that F \u2286 [A m \u2192 B], then \u2294 \u03b2 F \u2208 [A m \u2192 B]. We will make use of a lemma.\nLemma 10 Let L be a basic model. For all x, y \u2208 L and \u03b1, \u03b2 < \u03ba with \u03b1 6= \u03b2, x|\u03b2 \u2291\u03b1 y|\u03b2 iff either \u03b2 < \u03b1 and x|\u03b2 = y|\u03b2 (or equivalently, x =\u03b2 y), or \u03b2 > \u03b1 and x|\u03b1 \u2291\u03b1 y|\u03b1."}, {"heading": "Proof", "text": "Let x|\u03b2 \u2291\u03b1 y|\u03b2 . If \u03b2 < \u03b1 then x|\u03b2 = (x|\u03b2)|\u03b2 = (y|\u03b2)|\u03b2 = y|\u03b2 . If \u03b2 > \u03b1 then x|\u03b1 = (x|\u03b2)|\u03b1 \u2291\u03b1 (y|\u03b2)|\u03b1 = y|\u03b1.\nSuppose now that \u03b2 < \u03b1 and x|\u03b2 = y|\u03b2 . Then (x|\u03b2)|\u03b1 = x|\u03b2 = y|\u03b2 = (y|\u03b2)|\u03b1 and thus x|\u03b2 =\u03b1 y|\u03b2 . Finally, let \u03b2 > \u03b1 and x|\u03b1 \u2291\u03b1 y|\u03b1. Then (x|\u03b2)|\u03b1 = x|\u03b1 \u2291\u03b1 y|\u03b1 = (y|\u03b2)|\u03b1 and thus x|\u03b2 \u2291\u03b1 y|\u03b2.\nRemark 1 Under the above assumptions, if \u03b2 < \u03b1, then x|\u03b2 \u2291\u03b1 y|\u03b2 iff x|\u03b2 =\u03b1 y|\u03b2 iff x|\u03b2 = y|\u03b2 .\nCorollary 1 For all X,Y \u2286 L and \u03b1 6= \u03b2, \u2294\n\u03b2 X \u2291\u03b1 \u2294 \u03b2 Y iff \u03b2 < \u03b1 and \u2294 \u03b2 X = \u2294\n\u03b2 Y , or \u03b2 > \u03b1 and \u2294\n\u03b1 X \u2291\u03b1 \u2294 \u03b1 Y ."}, {"heading": "Proof", "text": "Let x = \u2294\n\u03b2 X and y = \u2294 \u03b2 Y . Then x = \u2294 \u03b2 X = \u2294 \u03b2{ \u2294 \u03b2 X} = x|\u03b2 and y = y|\u03b2 .\nLet \u03b2 < \u03b1. Then x \u2291\u03b1 y iff x = y. Let \u03b2 > \u03b1. Then x \u2291\u03b1 y iff x|\u03b1 \u2291\u03b1 y|\u03b1. But x|\u03b1 = \u2294 \u03b1{ \u2294 \u03b2 X} = \u2294 \u03b1 X and similarly for Y .\nLemma 11 Let A and B be basic models. Suppose that f : A \u2192 B and F \u2286 (f ]\u03b2 (where \u03b2 < \u03ba) is a set of functions in [A m \u2192 B]. Then \u2294\n\u03b2 F is also \u03b1-monotonic for all \u03b1 < \u03ba."}, {"heading": "Proof", "text": "Suppose that \u03b1, \u03b2 < \u03ba and x \u2291\u03b1 y in A. Then ( \u2294 \u03b2 F )(x) = \u2294 \u03b2{f(x) : f \u2208 F} and ( \u2294\n\u03b2 F )(y) = \u2294 \u03b2{f(y) : f \u2208 F}. We have that f(x) \u2291\u03b1 f(y) for all f \u2208 F . Thus, if\n\u03b1 = \u03b2, then clearly ( \u2294 \u03b2 F )(x) \u2291\u03b1 ( \u2294 \u03b2 F )(y).\nSuppose that \u03b2 < \u03b1. Then \u2294 \u03b2{f(x) : f \u2208 F} = \u2294 \u03b2{f(y) : f \u2208 F} since f(x) =\u03b2 f(y)\nfor all f \u2208 F . Thus, by Corollary 1, ( \u2294 \u03b2 F )(x) \u2291\u03b1 ( \u2294 \u03b2 F )(y).\nSuppose that \u03b2 > \u03b1. Then ( \u2294 \u03b2 F )(x) \u2291\u03b1 ( \u2294\n\u03b2 F )(y) follows by Corollary 1 from \u2294\n\u03b1{f(x) : f \u2208 F} \u2291\u03b1 \u2294 \u03b1{f(y) : f \u2208 F}. We equip [A m \u2192 B] with the order relations \u2264 and \u2291\u03b1 inherited from A \u2192 B. We have\nthe following lemma:\nLemma 12 If A and B are basic models, then so is [A m \u2192 B] with the pointwise definition of the order of relations \u2264 and \u2291\u03b1 for all \u03b1 < \u03ba."}, {"heading": "Proof", "text": "It is proved in (E\u0301sik and Rondogiannis 2014) that the set of functions A \u2192 B is a basic model with the pointwise definition of the relations \u2264 and \u2291\u03b1, so that for all f, g : A \u2192 B and \u03b1 < \u03ba, f \u2264 g iff f(x) \u2264 g(x) for all x \u2208 A and f \u2291\u03b1 g iff f(x) \u2291\u03b1 g(x) for all x \u2208 A. It follows that for any F \u2286 BA and \u03b1 < \u03ba, \u2228 F and \u2294\n\u03b1 F can also be computed pointwise:\n( \u2228 F )(x) = \u2228 {f(x) : x \u2208 A} and ( \u2294 \u03b1 F )(x) = \u2294 \u03b1{f(x) : f \u2208 F}. By Proposition 8 and Lemma 11, for all F \u2286 BA, if F is a set of functions \u03b1-monotonic for all \u03b1, then \u2228\nF and \u2294\n\u03b2 F are also \u03b1-monotonic for all \u03b1. Since the relations \u2264 and \u2291\u03b1, \u03b1 < \u03ba on [A m \u2192 B] are the restrictions of the corresponding relations on BA, in view of Proposition 8 and Lemma 11, [A m \u2192 B] also satisfies the axioms in Definition 1, so that [A m \u2192 B] is a basic model.\nThe following lemma is shown in (E\u0301sik and Rondogiannis 2014, Subsection 5.2) and\nwill be used in the proof of the basis case of the next lemma:\nLemma 13 (V,\u2264) is a complete lattice and a basic model.\nLemma 2 Let D be a nonempty set and \u03c0 be a predicate type. Then, ([[\u03c0]]D,\u2264\u03c0) is a complete lattice and a basic model."}, {"heading": "Proof", "text": "Let \u03c0 be a predicate type. We prove that [[\u03c0]]D is a basic model by induction on the structure of \u03c0. When \u03c0 = o, [[\u03c0]]D = V , a basic model. Suppose that \u03c0 is of the sort \u03b9 \u2192 \u03c0\u2032. Then [[\u03c0]]D = D \u2192 [[\u03c0 \u2032]]D, which is a basic model, since [[\u03c0 \u2032]]D is a model by the induction hypothesis. Finally, let \u03c0 be of the sort \u03c01 \u2192 \u03c02. By the induction hypothesis, [[\u03c0i]]D is a model for i = 1, 2. Thus, by Lemma 12, [[\u03c0]]D = [[[\u03c01]]D m \u2192 [[\u03c02]]D] is also a basic model.\nRemark 2 Let C denote the category of all basic models and \u03b1-monotonic functions. The above results show that C is cartesian closed, since for all basic models A,B, the evaluation function eval : (A\u00d7B)\u00d7A \u2192 B is \u03b1-monotonic (in both arguments) for all \u03b1 < \u03ba.\nIndeed, suppose that f, g \u2208 [A m \u2192 B] and x, y \u2208 A with f \u2291\u03b1 g and x \u2291\u03b1 y. Then eval(f, x) = f(x) \u2291\u03b1 g(x) = eval(g, x) by the pointwise definition of f \u2291\u03b1 g. Also, eval(f, x) = f(x) \u2291\u03b1 f(y) = eval(f, y) since f is \u03b1-monotonic.\nSince C is cartesian closed, for all f \u2208 [B\u00d7A m \u2192 C] there is a unique \u039bf \u2208 [B m \u2192 [A m \u2192C]]\nin with f(y, x) = eval(\u039bf(y), x) for all x \u2208 A and y \u2208 B."}, {"heading": "Appendix B Proofs of Lemmas 3, 4 and 5", "text": "Lemma 3 Let E : \u03c1 be an expression and let D be a nonempty set. Moreover, let s be a state over D and let I be an interpretation over D. Then, [[E]]s(I) \u2208 [[\u03c1]]D."}, {"heading": "Proof", "text": "If \u03c1 = \u03b9 then the claim is clear. Let E be of a predicate type \u03c0. We prove simultaneously the following auxiliary statement. Let \u03b1 < \u03ba, V : \u03c0, x, y \u2208 [[\u03c0\u2032]]D. If x \u2291\u03b1 y then [[E]]s[V/x](I) \u2291\u03b1 [[E]]s[V/y](I). The proof is by structural induction on E. We will cover only the nontrivial cases.\nCase (E1 E2): The main statement follows directly by the induction hypothesis of E1 and E2. There are two cases. Suppose that E1 : \u03c01 \u2192 \u03c0 and E2 : \u03c01. Then [[E1]]s(I) \u2208 [[\u03c01 \u2192 \u03c0]]D = [[[\u03c01]]D m \u2192 [[\u03c0]]D] and [[E2]]s(I) \u2208 [[\u03c01]]D by the induction hypothesis. Thus, [[E1]]s(I) ([[E]]s(I)) \u2208 [[\u03c0]]D. Suppose now that E1 : \u03b9 \u2192 \u03c0 and E2 : \u03b9. Then [[E1]]s(I) \u2208 [[\u03b9 \u2192 \u03c0]]D = D \u2192 [[\u03c0]]D by the induction hypothesis and [[E2]]s(I) \u2208 [[\u03b9]]D = D. It follows again that [[E1]]s(I) ([[E]]s(I)) \u2208 [[\u03c0]]D. Auxiliary statement: Let x, y \u2208 [[\u03c0\u2032]]D and assume x \u2291\u03b1 y. We have by definition\n[[(E1 E2)]]s[V/x](I) = [[E1]]s[V/x](I) ([[E2]]s[V/x](I)), and similarly for [[(E1 E2)]]s[V/y](I). We have E1 : \u03c01 \u2192 \u03c0 and E2 : \u03c01 or E1 : \u03b9 \u2192 \u03c0 and E2 : \u03b9. In the first case, by induction hypothesis [[E1]]s[V/x](I) \u2208 [[\u03c01 \u2192 \u03c0]]D, and thus is \u03b1-monotonic. Also, [[E1]]s[V/x](I) \u2291\u03b1 [[E1]]s[V/y](I) and [[E2]]s[V/x](I) \u2291\u03b1 [[E2]]s[V/y](I) by the induction hypothesis. It follows that\n[[E1]]s[V/x](I) ([[E2]]s[V/x](I)) \u2291\u03b1 [[E1]]s[V/x](I) ([[E2]]s[V/y](I)) \u2291\u03b1 [[E1]]s[V/y](I) ([[E2]]s[V/y](I)).\nThe second case is similar. We have [[E1]]s[V/x](I) \u2291\u03b1 [[E1]]s[V/y](I) by the induction hypothesis, moreover, [[E2]]s[V/x](I) = [[E2]]s[V/y](I). Therefore, [[E1]]s[V/x](I) ([[E2]]s[V/x](I)) \u2291\u03b1 [[E1]]s[V/y](I) ([[E2]]s[V/y](I)). Case (\u03bbV.E): Assume V : \u03c11 and E : \u03c02. We will show that [[\u03bbV.E]]s(I) \u2208 [[\u03c11 \u2192 \u03c02]]D. If \u03c11 = \u03b9 then the result follows easily from the induction hypothesis of the first statement. Assume \u03c11 = \u03c01. We show that [[\u03bbV.E]]s(I) \u2208 [[\u03c01 \u2192 \u03c02]]D, that is, \u03bbd.[[E]]s[V/d](I) is \u03b1-monotonic for all \u03b1 < \u03ba. That follows directly by the induction hypothesis of the auxiliary statement.\nAuxiliary statement: It suffices to show that [[(\u03bbU.E)]]s[V/x](I) \u2291\u03b1 [[(\u03bbU.E)]]s[V/y](I) and equivalently for every d, [[E]]s[V/x][U/d](I) \u2291\u03b1 [[E]]s[V/y][U/d](I) which follows from induction hypothesis.\nLemma 4 Let P be a program. Then, IP is a complete lattice and a basic model."}, {"heading": "Proof", "text": "From Lemma 2 we have that for all predicate types \u03c0, [[\u03c0]]UP is a complete lattice and a basic model. It follows, by Lemma 9, that for all predicate types \u03c0, P\u03c0 \u2192 [[\u03c0]]UP is also a complete lattice and a model, where P\u03c0 is the set of predicate constants of type \u03c0. Then, IP is \u220f\n\u03c0 P\u03c0 \u2192 [[\u03c0]]UP which is also a basic model (proved in (E\u0301sik and Rondogiannis\n2014)).\nLemma 5 (\u03b1-Monotonicity of Semantics) Let P be a program and let E : \u03c0 be an expression. Let I, J be Herbrand interpretations and s be a Herbrand state of P. For all \u03b1 < \u03ba, if I \u2291\u03b1 J then [[E]]s(I) \u2291\u03b1 [[E]]s(J)."}, {"heading": "Proof", "text": "The proof is by structural induction on E.\nInduction Base: The cases V, false, true are straightforward since their meanings do not depend on I. Let I \u2291\u03b1 J . If E is a predicate constant p then we have I(p) \u2291\u03b1 J(p).\nInduction Step: Assume that the statement holds for expressions E1 and E2 and let I \u2291\u03b1 J .\nCase (E1 E2): It holds [[(E1 E2)]]s(I) = [[E1]]s(I)([[E2]]s(I)). By induction hypothesis we have [[E1]]s(I) \u2291\u03b1 [[E1]]s(J) and therefore [[E1]]s(I)([[E2]]s(I)) \u2291\u03b1 [[E1]]s(J)([[E2]]s(I)). We perform a case analysis on the type of E2. If E2 is of type \u03b9 and since I, J are Herbrand interpretations, it is clear that [[E2]]s(I) = [[E2]]s(J) and therefore [[E1]]s(I)([[E2]]s(I)) \u2291\u03b1 [[E1]]s(J)([[E2]]s(J)). By definition of application we get [[(E1 E2)]]s(I) \u2291\u03b1 [[(E1 E2)]]s(J). If E2 is of type \u03c0 then by induction hypothesis we have [[E2]]s(I) \u2291\u03b1 [[E2]]s(J) and since\n[[E1]]s(J) is \u03b1-monotonic we get that [[E1]]s(J)([[E2]]s(I)) \u2291\u03b1 [[E1]]s(J)([[E2]]s(J)). By transitivity of \u2291\u03b1 and by the definition of application we conclude that [[(E1 E2)]]s(I) \u2291\u03b1 [[(E1 E2)]]s(J). Case (\u03bbV.E1): It holds by definition that [[(\u03bbV.E1)]]s(I) = \u03bbd.[[E1]]s[V/d](I). It suffices to show that \u03bbd.[[E1]]s[V/d](I) \u2291\u03b1 \u03bbd.[[E1]]s[V/d](J) and equivalently that for every d, [[E1]]s[V/d](I) \u2291\u03b1 [[E1]]s[V/d](J) which holds by induction hypothesis. Case (E1 \u2228 \u03c0 E2): It holds [[(E1 \u2228 \u03c0 E2)]]s(I) = \u2228 {[[E1]]s(I), [[E2]]s(I)}. It suffices to show that \u2228\n{[[E1]]s(I), [[E2]]s(I)} \u2291\u03b1 \u2228 {[[E1]]s(J), [[E2]]s(J)} which holds by induction hypoth-\nesis and Axiom 4. Case (E1 \u2227 \u03c0 E2): It holds [[(E1 \u2227 \u03c0 E2)]]s(I) = \u2227 {[[E1]]s(I), [[E2]]s(I)}. Let \u03c0 = \u03c11 \u2192 \u00b7 \u00b7 \u00b7 \u2192 \u03c1n \u2192 o, it suffices to show for all di \u2208 [[\u03c1i]]UP , \u2227 {[[E1]]s(I) d1 \u00b7 \u00b7 \u00b7 dn, [[E2]]s(I) d1 \u00b7 \u00b7 \u00b7 dn} \u2291\u03b1 \u2227\n{[[E1]]s(J) d1 \u00b7 \u00b7 \u00b7 dn, [[E2]]s(J) d1 \u00b7 \u00b7 \u00b7 dn}. We define xi = [[Ei]]s(I) d1 \u00b7 \u00b7 \u00b7 dn and yi =\n[[Ei]]s(J) d1 \u00b7 \u00b7 \u00b7 dn for i \u2208 {1, 2}. We perform a case analysis on v = \u2227\n{x1, x2}. If v < F\u03b1 or v > T\u03b1 then \u2227 {x1, x2} = \u2227 {y1, y2} and thus \u2227 {x1, x2} \u2291\u03b1 \u2227 {y1, y2}. If v = F\u03b1 then F\u03b1 \u2264 \u2227 {y1, y2} \u2264 T\u03b1 and therefore \u2227 {x1, x2} \u2291\u03b1 \u2227 {y1, y2}. If v = T\u03b1 then \u2227 {y1, y2} = T\u03b1 and thus \u2227 {x1, x2} \u2291\u03b1 \u2227 {y1, y2}. If F\u03b1 < v < T\u03b1 then F\u03b1 < \u2227 {y1, y2} \u2264 T\u03b1 and therefore \u2227 {x1, x2} \u2291\u03b1 \u2227 {y1, y2}.\nCase (\u223c E1): Assume order([[E1]]s(I)) = \u03b1. Then, by induction hypothesis [[E1]]s(I) \u2291\u03b1 [[E1]]s(J) and thus order([[E1]]s(J)) \u2265 \u03b1. It follows that order([[(\u223c E1)]]s(I)) > \u03b1 and order([[(\u223cE1)]]s(J)) > \u03b1 and therefore [[(\u223cE1)]]s(I) \u2291\u03b1 [[(\u223cE1)]]s(J). Case (\u2203V.E1): Assume V is of type \u03c1. It holds [[(\u2203V.E1)]]s(I) = \u2228\nd\u2208[[\u03c1]] UP\n[[E1]]s[V/d](I). It\nsuffices to show \u2228\nd\u2208[[\u03c1]] UP\n[[E1]]s[V/d](I) \u2291\u03b1 \u2228\nd\u2208[[\u03c1]] UP\n[[E1]]s[V/d](J) which holds by induc-\ntion hypothesis and Axiom 4."}, {"heading": "Appendix C Proof of Theorem 2", "text": "We start by providing some necessary background material from (E\u0301sik and Rondogiannis 2014) on how the d operation on a set of interpretations is actually defined.\nLet x \u2208 V . For every X \u2286 (x]\u03b1 we define d \u03b1 X as follows: if X = \u2205 then d \u03b1 X = T\u03b1,\notherwise\nl \u03b1 X =\n{\n\u2227 X order( \u2227 X) \u2264 \u03b1\nT\u03b1+1 otherwise\nLet P be a program, I \u2208 IP be a Herbrand interpretation of P and X \u2286 (I]\u03b1. For all predicate constants p in P of type \u03c11 \u2192 \u00b7 \u00b7 \u00b7 \u2192 \u03c1n \u2192 o and di \u2208 [[\u03c1i]]UP and for all\ni = {1, . . . , n}, it holds d \u03b1 X as ( d \u03b1 X)(p) d1 \u00b7 \u00b7 \u00b7 dn = d \u03b1{I(p) d1 \u00b7 \u00b7 \u00b7 dn : I \u2208 X}.\nLet X be a nonempty set of Herbrand interpretations. By Lemma 4 we have that IP is a complete lattice with respect to \u2264 and a basic model. Moreover, by Lemma 1 it follows that IP is also a complete lattice with respect to \u2291. Thus, there exist the least upper bound and greatest lower bound of X for both \u2264 and \u2291. We denote the greatest lower bound of X as \u2227 X and d X with respect to relations \u2264 and \u2291 respectively. Then, d X can be constructed in an symmetric way to the least upper bound construction described in (E\u0301sik and Rondogiannis 2014). More specifically, for each ordinal \u03b1 < \u03ba we define the sets X\u03b1, Y\u03b1 \u2286 X and x\u03b1 \u2208 IP, which are then used in order to obtain d X .\nLet Y0 = X and x0 = d 0 Y0. For every \u03b1, with 0 < \u03b1 < \u03ba we define X\u03b1 = {x \u2208\nX : \u2200\u03b2 \u2264 \u03b1 x =\u03b1 x\u03b1}, Y\u03b1 = \u22c2 \u03b2<\u03b1X\u03b2 ; moreover, x\u03b1 = d \u03b1 Y\u03b1 if Y\u03b1 is nonempty and x\u03b1 = \u2227 \u03b2<\u03b1 x\u03b2 if Y\u03b1 is empty.\nFinally, we define x\u221e = \u2227 \u03b1<\u03ba x\u03b1. In analogy to the proof of (E\u0301sik and Rondogiannis 2014) for the least upper bound it can be shown that x\u221e = d X with respect to the relation \u2291. Moreover, it is easy to prove that by construction it holds x\u03b1 =\u03b1 x\u03b2 and x\u03b2 \u2265 x\u03b1 for all \u03b2 < \u03b1.\nLemma 14\nLet P be a program, \u03b1 < \u03ba and M\u03b1 be a Herbrand model of P. Let M \u2286 (M\u03b1]\u03b1 be a nonempty set of Herbrand models of P. Then, d\n\u03b1 M is also a Herbrand model of P."}, {"heading": "Proof", "text": "Assume d\n\u03b1 M is not a model. Then, there exists a clause p \u2190 E in P and di \u2208\n[[\u03c1i]]D such that [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn > ( d \u03b1 M)(p) d1 \u00b7 \u00b7 \u00b7 dn. Since for every N \u2208 M\nwe have d \u03b1 M \u2291\u03b1 N , using Lemma 5 we conclude [[E]]( d\n\u03b1 M) \u2291\u03b1 [[E]](N). Let x =d \u03b1{N(p) d1 \u00b7 \u00b7 \u00b7 dn : N \u2208 M}. By definition, x = ( d \u03b1 M)(p) d1 \u00b7 \u00b7 \u00b7 dn.\nIf order(x) = \u03b1 then x = \u2227\n{N(p) d1 \u00b7 \u00b7 \u00b7 dn : N \u2208 M}. If x = T\u03b1 then for all N \u2208 M\nwe have N(p) d1 \u00b7 \u00b7 \u00b7 dn = T\u03b1. Moreover, [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn > T\u03b1 and by \u03b1-monotonicity we have [[E]](N) d1 \u00b7 \u00b7 \u00b7 dn > T\u03b1 for all N \u2208 M. Then, N(p) d1 \u00b7 \u00b7 \u00b7 dn < [[E]](N) d1 \u00b7 \u00b7 \u00b7 dn and therefore N is not a model (contradiction). If x = F\u03b1 then there exists N \u2208 M such that N(p) d1 \u00b7 \u00b7 \u00b7 dn = F\u03b1 and since N is a model we have [[E]](N) d1 \u00b7 \u00b7 \u00b7 dn \u2264 F\u03b1. But then, it follows [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn \u2264 F\u03b1 and [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn \u2264 x (contradiction).\nIf order(x) < \u03b1 then x = M\u03b1(p) d1 \u00b7 \u00b7 \u00b7 dn. If x = T\u03b2 then [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn > T\u03b2 and [[E]](M\u03b1) d1 \u00b7 \u00b7 \u00b7 dn > T\u03b2 . Then, we have M\u03b1(p) d1 \u00b7 \u00b7 \u00b7 dn < [[E]](M\u03b1) and thus M\u03b1 is not a model of P (contradiction). If x = F\u03b2 then [[E]](M\u03b1) d1 \u00b7 \u00b7 \u00b7 dn \u2264 F\u03b2 and by \u03b1-monotonicity [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn \u2264 F\u03b2 . Therefore, [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn \u2264 x (contradiction).\nIf order(x) > \u03b1 then x = T\u03b1+1 and there exists modelN \u2208 M such thatN(p) d1 \u00b7 \u00b7 \u00b7 dn <\nT\u03b1. Moreover, we have [[E]]( d \u03b1 M) d1 \u00b7 \u00b7 \u00b7 dn \u2265 T\u03b1 and by \u03b1-monotonicity we conclude [[E]](N) d1 \u00b7 \u00b7 \u00b7 dn \u2265 T\u03b1. But then, [[E]](N) d1 \u00b7 \u00b7 \u00b7 dn > N(p) d1 \u00b7 \u00b7 \u00b7 dn and therefore N is not a model of P (contradiction).\nIn the following, we will make use of the following lemma that has been shown in (E\u0301sik\nand Rondogiannis 2014, Lemma 3.18):\nLemma 15\nIf \u03b1 \u2264 \u03ba is an ordinal and (x\u03b2)\u03b2<\u03b1 is a sequence of elements of L such that x\u03b2 =\u03b2 x\u03b3 and x\u03b2 \u2264 x\u03b3 (x\u03b2 \u2265 x\u03b3) whenever \u03b2 < \u03b3 < \u03b1, and if x = \u2228 \u03b2<\u03b1 x\u03b2 (x = \u2227 \u03b2<\u03b1 x\u03b2), then x\u03b2 =\u03b2 x holds for all \u03b2 < \u03b1.\nLemma 16\nLet (M\u03b1)\u03b1<\u03ba be a sequence of Herbrand models of P such that M\u03b1 =\u03b1 M\u03b2 and M\u03b2 \u2264 M\u03b1 for all \u03b1 < \u03b2 < \u03ba. Then, \u2227\n\u03b1<\u03ba M\u03b1 is also a Herbrand model of P."}, {"heading": "Proof", "text": "Let M\u221e = \u2227 \u03b1<\u03ba M\u03b1 and assume M\u221e is not a model of P. Then, there is a clause p \u2190 E and di \u2208 [[\u03c1i]]D such that [[E]](M\u221e) d1 \u00b7 \u00b7 \u00b7 dn > M\u221e(p) d1 \u00b7 \u00b7 \u00b7 dn. We define x\u03b1 = M\u03b1(p) d1 \u00b7 \u00b7 \u00b7 dn, x\u221e = M\u221e(p) d1 \u00b7 \u00b7 \u00b7 dn, y\u03b1 = [[E]](M\u03b1) d1 \u00b7 \u00b7 \u00b7 dn and y\u221e = [[E]](M\u221e) d1 \u00b7 \u00b7 \u00b7 dn for all \u03b1 < \u03ba. It follows from Lemma 15 that M\u221e =\u03b1 M\u03b1 and thus x\u221e =\u03b1 x\u03b1 for all \u03b1 < \u03ba. Moreover, using \u03b1-monotonicity we also have [[E]](M\u221e) =\u03b1 [[E]](M\u03b1) and thus y\u221e =\u03b1 y\u03b1 for all \u03b1 < \u03ba. We distinguish cases based on the value of x\u221e.\nAssume x\u221e = T\u03b4 for some \u03b4 < \u03ba. It follows by assumption that y\u221e > T\u03b4. Then, since x\u221e =\u03b4 x\u03b4 it follows x\u03b4 = T\u03b4. Moreover, since y\u221e =\u03b4 y\u03b4 and order(y\u221e) < \u03b4 it follows y\u03b4 = y\u221e > T\u03b4. But then, y\u03b4 > x\u03b4 (contradiction since M\u03b4 is a model by assumption).\nAssume x\u221e = F\u03b4 for some \u03b4 < \u03ba. Then, since x\u221e =\u03b4 x\u03b4 it follows x\u03b4 = F\u03b4. Then, since M\u03b4 is a model it follows y\u03b4 \u2264 x\u03b4 and thus y\u03b4 \u2264 F\u03b4. But then, since y\u221e =\u03b4 y\u03b4 it follows y\u03b4 = y\u221e \u2264 F\u03b4. Therefore, y\u221e \u2264 x\u221e that is a contradiction to our assumption that y\u221e > x\u221e.\nAssume x\u221e = 0. Then, y\u221e > x\u221e = 0. Let y\u221e = T\u03b2 for some \u03b2 < \u03ba. Then, since y\u03b2 =\u03b2 y\u221e it follows y\u03b2 = T\u03b2 . Since M\u03b2 is a model of P it holds T\u03b2 = y\u03b2 \u2264 x\u03b2 , that is x\u03b2 = T\u03b3 for some \u03b3 \u2264 \u03b2. Moreover, since x\u221e =\u03b2 x\u03b2 it follows that x\u221e = T\u03b3 that is a contradiction to our assumption that x\u221e = 0.\nTheorem 2 (Model Intersection Theorem) Let P be a program and M be a nonempty set of Herbrand models of P. Then, d M is also a Herbrand model of P."}, {"heading": "Proof", "text": "We use the construction for d M described in the beginning of this appendix. More specifically, we define sets M\u03b1, Y\u03b1 \u2286 M and M\u03b1 \u2208 IP. Let Y0 = M and M0 = d 0 Y0. For every \u03b1 > 0, let M\u03b1 = {M \u2208 M : \u2200\u03b2 \u2264 \u03b1 M =\u03b1 M\u03b1} and Y\u03b1 = \u22c2 \u03b2<\u03b1 M\u03b2 ;\nmoreover, M\u03b1 = d \u03b1 Y\u03b1 if Y\u03b1 is nonempty and M\u03b1 = \u2227\n\u03b2<\u03b1 M\u03b2 if Y\u03b1 is empty. Then,d M = \u2227\n\u03b1<\u03ba M\u03b1. It is easy to see that M\u03b1 =\u03b1 M\u03b2 and M\u03b2 \u2287 M\u03b1 for all \u03b2 < \u03b1.\nWe distinguish two cases. First, consider the case when Y\u03b1 is nonempty for all \u03b1 < \u03ba.\nThen, M\u03b1 = d \u03b1 Y\u03b1 and by Lemma 14 it follows that M\u03b1 is a model of P. Moreover, by Lemma 16 we get that M\u221e = \u2227 \u03b1<\u03ba M\u03b1 is also a model of P.\nConsider now the case that there exists a least ordinal \u03b4 < \u03ba such that Y\u03b4 is empty.\nIt holds (see (E\u0301sik and Rondogiannis 2014)) that M\u221e = \u2227 \u03b1<\u03b4 M\u03b4. Suppose M\u221e is not a model of P. Then, there is a clause p \u2190 E, a Herbrand state s and di \u2208 [[\u03c1i]]D such that [[E]](M\u221e) d1 \u00b7 \u00b7 \u00b7 dn > M\u221e(p) d1 \u00b7 \u00b7 \u00b7 dn. We define x\u03b1 = M\u03b1(p) d1 \u00b7 \u00b7 \u00b7 dn, x\u221e = M\u221e(p) d1 \u00b7 \u00b7 \u00b7 dn, y\u03b1 = [[E]](M\u03b1) d1 \u00b7 \u00b7 \u00b7 dn, and y\u221e = [[E]](M\u221e) d1 \u00b7 \u00b7 \u00b7 dn for all \u03b2 \u2264 \u03b1. We distinguish cases based on the value of x\u221e.\nAssume x\u221e = T\u03b2 for some \u03b2 < \u03b4. It follows by assumption that y\u221e > x\u221e = T\u03b2 . Then, by Lemma 15 it holds that M\u221e =\u03b2 M\u03b2 and we get x\u221e =\u03b2 x\u03b2 and therefore x\u03b2 = T\u03b2. Moreover, by \u03b1-monotonicity we get [[E]](M\u221e) d1 \u00b7 \u00b7 \u00b7 dn =\u03b2 [[E]](M\u03b2) d1 \u00b7 \u00b7 \u00b7 dn and it follows that y\u221e =\u03b2 y\u03b2 . Moreover, since y\u221e > T\u03b2 it follows y\u03b2 = y\u221e > T\u03b2 and y\u03b2 > x\u03b2 . Since Y\u03b2 is not empty by assumption we have that M\u03b2 = d \u03b2 Y\u03b2 and by Lemma 14 we get that M\u03b2 is a model of P (contradiction since y\u03b2 > x\u03b2).\nAssume x\u221e = F\u03b2 for some \u03b2 < \u03b4. Then, by Lemma 15 it holds M\u221e =\u03b2 M\u03b2 and therefore x\u221e =\u03b2 x\u03b2 . It follows x\u03b2 = F\u03b2 . Moreover, since Y\u03b2 is nonempty by assumption\nand by Lemma 14 it follows that M\u03b2 = d \u03b2 Y\u03b2 is a model of P and thus y\u03b2 \u2264 x\u03b2 = F\u03b2 . By \u03b1-monotonicity we get [[E]](M\u221e) =\u03b2 [[E]](M\u03b2) and therefore y\u221e =\u03b2 y\u03b2 \u2264 F\u03b2 . It follows y\u221e \u2264 F\u03b2 = x\u221e (contradiction to the initial assumption y\u221e > x\u221e).\nAssume x\u221e = T\u03b4. By assumption we have y\u221e > x\u221e = T\u03b4. Then, let y\u221e = T\u03b3 for some \u03b3 < \u03b4. By Lemma 15 it holds M\u221e =\u03b3 M\u03b3 and by \u03b1-monotonicity it follows [[E]](M\u221e) =\u03b3 [[E]](M\u03b3) and thus y\u221e =\u03b3 y\u03b3 . It follows that y\u03b3 = T\u03b3 . Moreover, since \u03b3 < \u03b4 we know by assumption that Y\u03b3 is nonempty and therefore M\u03b3 = d Y\u03b3 and by Lemma 14 M\u03b3 is a model of P. It follows T\u03b3 = y\u03b3 \u2264 x\u03b3 , that is, x\u03b3 = T\u03b2 for some \u03b2 \u2264 \u03b3 < \u03b4. Moreover, since x\u221e =\u03b3 x\u03b3 it follows x\u221e = T\u03b2 that is a contradiction (since by assumption x\u221e = T\u03b4).\nAssume x\u221e = F\u03b4. This case is not possible. Recall that Y\u03b1 is not empty for all \u03b1 < \u03b4\nand thus M\u03b1 = d Y\u03b1. By the definition of d \u03b1 we observe that either d \u03b1 Y\u03b1 \u2264 F\u03b1 ord\n\u03b1 Y\u03b1 \u2265 T\u03b1+1. Then, since M\u221e = \u2227 \u03b1<\u03b4 M\u03b1 it is not possible to have x\u221e = F\u03b4. Assume x\u221e = 0. This case does not arise. Again, Y\u03b1 is not empty for all \u03b1 < \u03b4 and\nthus M\u03b1 = d \u03b1 Y\u03b1. Moreover, by definition of d \u03b1, x\u03b1 6= 0 for all \u03b1 < \u03b4. Moreover, since M\u221e = \u2227 \u03b1<\u03b4 M\u03b1 and since \u03b4 < \u03ba it follows that the limit can be at most T\u03b4."}, {"heading": "Appendix D Proofs of Lemmas 6, 7 and Theorem 3", "text": "Lemma 6\nLet P be a program. For every predicate constant p : \u03c0 in P and I \u2208 IP, TP (I)(p) \u2208 [[\u03c0]]UP ."}, {"heading": "Proof", "text": "It follows from the fact that [[\u03c0]]UP is a complete lattice (Lemma 2).\nLemma 7\nLet P be a program. Then, TP is \u03b1-monotonic for all \u03b1 < \u03ba."}, {"heading": "Proof", "text": "Follows directly from Lemma 5 and Proposition 8.\nLemma 17\nLet P be a program. Then, M \u2208 IP is a model of P if and only if TP(M) \u2264IP M ."}, {"heading": "Proof", "text": "An interpretation I \u2208 IP is a model of P iff [[E]](I) \u2264\u03c0 I(p) for all clauses p \u2190\u03c0 E in P iff \u2228\n(p\u2190E)\u2208P [[E]](I) \u2264IP I(p) iff TP(I) \u2264IP I.\nProposition 18\nLet D be a nonempty set, \u03c0 be a predicate type and x, y \u2208 [[\u03c0]]D. If x \u2264\u03c0 y and x =\u03b2 y for all \u03b2 < \u03b1 then x \u2291\u03b1 y."}, {"heading": "Proof", "text": "The proof is by structural induction on \u03c0.\nInduction Basis: If x =\u03b2 y for all \u03b2 < \u03b1 then either x = y or order(x), order(y) \u2265 \u03b1. If x = y then x \u2291\u03b1 y. Suppose x 6= y. If order(x), order(y) > \u03b1 then x =\u03b1 y. If x = F\u03b1 then clearly x \u2291\u03b1 y. If x = T\u03b1 then T\u03b1 \u2264 y and therefore y = T\u03b1. The case analysis for y is similar.\nInduction Step: Assume that the statement holds for \u03c0. Let f, g \u2208 [[\u03c1 \u2192 \u03c0]]D and \u03b1 < \u03ba. For all x \u2208 [[\u03c1]]D and \u03b2 < \u03b1, f(x) \u2264 g(x) and f(x) =\u03b2 g(x). It follows that f(x) \u2291\u03b1 g(x). Therefore, f \u2291\u03b1 g.\nProposition 19 Let P be a program and I, J be Herbrand interpretations of P . If I \u2264IP J and I =\u03b2 J for all \u03b2 < \u03b1 then I \u2291\u03b1 J ."}, {"heading": "Proof", "text": "Let I, J \u2208 IP and \u03b1 < \u03ba. For all predicate constants p and \u03b2 < \u03b1, I(p) \u2264 J(p) and I(p) =\u03b2 J(p). It follows by Proposition 18 that I(p) \u2291\u03b1 J(p) and therefore, I \u2291\u03b1 J .\nLemma 20 Let P be a program. If M is a model of P then TP(M) \u2291 M ."}, {"heading": "Proof", "text": "It follows from Lemma 17 that if M is a Herbrand model of P then TP(M) \u2264IP M . If TP(M) = M then the statement is immediate. Suppose TP(M) <IP M and let \u03b1 denote the least ordinal such that TP(M) =\u03b1 M does not hold. Then, TP(M) =\u03b2 M for all \u03b2 < \u03b1. Since TP(M) <IP M , by Proposition 19 it follows that TP(M) \u2291\u03b1 M . Since TP(M) =\u03b1 M does not hold, it follows that TP(M) \u2741\u03b1 M . Therefore TP(M) \u2291 M .\nTheorem 3 (Least Fixed Point Theorem) Let P be a program and let M be the set of all its Herbrand models. Then, TP has a least fixed point MP. Moreover, MP = d M."}, {"heading": "Proof", "text": "It follows from Lemma 7 and Theorem 1 that TP has a least pre-fixed point with respect to \u2291 that is also a least fixed point. Let MP be that least fixed point of TP, i.e., TP(MP) = MP. It is clear from Lemma 17 that MP is a model of P, i.e., MP \u2208 M. Then, it followsd M \u2291 MP. Moreover, from Theorem 2 it is implied that d M is a model and thus from Lemma 20, d M is a pre-fixed point of TP with respect to \u2291. Since MP is the least pre-fixed point of P, MP \u2291 d M and thus MP = d M."}], "references": [{"title": "An improved extensionality criterion for higher-order logic programs", "author": ["M. Bezem"], "venue": "Proceedings of the 15th International Workshop on Computer Science Logic (CSL). SpringerVerlag, London, UK, 203\u2013216.", "citeRegEx": "Bezem,? 2001", "shortCiteRegEx": "Bezem", "year": 2001}, {"title": "Extensional higher-order logic programming", "author": ["A. Charalambidis", "K. Handjopoulos", "P. Rondogiannis", "W.W. Wadge"], "venue": "JELIA, T. Janhunen and I. Niemel\u00e4, Eds. Lecture Notes in Computer Science, vol. 6341. Springer, 91\u2013103.", "citeRegEx": "Charalambidis et al\\.,? 2010", "shortCiteRegEx": "Charalambidis et al\\.", "year": 2010}, {"title": "Extensional higher-order logic programming", "author": ["A. Charalambidis", "K. Handjopoulos", "P. Rondogiannis", "W.W. Wadge"], "venue": "ACM Transactions on Computational Logic 14, 3, 21:1\u201321:40.", "citeRegEx": "Charalambidis et al\\.,? 2013", "shortCiteRegEx": "Charalambidis et al\\.", "year": 2013}, {"title": "A fixed point theorem for non-monotonic functions", "author": ["Z. \u00c9sik", "P. Rondogiannis"], "venue": "Proceedings of 13th Panhellenic Logic Symposium, Athens, Greece.", "citeRegEx": "\u00c9sik and Rondogiannis,? 2013", "shortCiteRegEx": "\u00c9sik and Rondogiannis", "year": 2013}, {"title": "A fixed point theorem for non-monotonic functions", "author": ["Z. \u00c9sik", "P. Rondogiannis"], "venue": "CoRR abs/1402.0299. Lloyd, J. W. 1987. Foundations of Logic Programming. Springer Verlag. Pearce, D. 1996. A new logical characterisation of stable models and answer sets. In NMELP, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol.", "citeRegEx": "\u00c9sik and Rondogiannis,? 2014", "shortCiteRegEx": "\u00c9sik and Rondogiannis", "year": 2014}, {"title": "Every logic program has a natural stratification and an iterated least fixed point model", "author": ["T.C. Przymusinski"], "venue": "PODS, A. Silberschatz, Ed. ACM Press, 11\u201321.", "citeRegEx": "Przymusinski,? 1989", "shortCiteRegEx": "Przymusinski", "year": 1989}, {"title": "Minimum model semantics for logic programs with negation-as-failure", "author": ["P. Rondogiannis", "W.W. Wadge"], "venue": "ACM Transactions on Computational Logic 6, 2, 441\u2013467.", "citeRegEx": "Rondogiannis and Wadge,? 2005", "shortCiteRegEx": "Rondogiannis and Wadge", "year": 2005}, {"title": "The well-founded semantics for general logic programs", "author": ["A. van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "J. ACM 38,", "citeRegEx": "Gelder et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}], "referenceMentions": [{"referenceID": 1, "context": "1 Introduction Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming.", "startOffset": 76, "endOffset": 142}, {"referenceID": 2, "context": "1 Introduction Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming.", "startOffset": 76, "endOffset": 142}, {"referenceID": 2, "context": "For example, consider the following simple extensional higher-order program (Charalambidis et al. 2013) stating that a band (musical ensemble) is a group that has at least a singer and a guitarist: band(B):-singer(S),B(S),guitarist(G),B(G).", "startOffset": 76, "endOffset": 103}, {"referenceID": 2, "context": "One basic property of all the higher-order predicates that can be defined in the language of (Charalambidis et al. 2013) is that they are monotonic.", "startOffset": 93, "endOffset": 120}, {"referenceID": 2, "context": "In other words, the semantics of (Charalambidis et al. 2013) is not applicable to this extended higher-order language.", "startOffset": 33, "endOffset": 60}, {"referenceID": 5, "context": "The solution we adopt is relatively simple to state (but non-trivial to materialize): it suffices to generalize the well-founded construction (van Gelder et al. 1991; Przymusinski 1989) to higher-order programs.", "startOffset": 142, "endOffset": 185}, {"referenceID": 6, "context": "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 157, "endOffset": 186}, {"referenceID": 3, "context": "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 276, "endOffset": 332}, {"referenceID": 4, "context": "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 276, "endOffset": 332}, {"referenceID": 6, "context": "In other words, the underlying truth domain of the infinite-valued approach is: F0 < F1 < \u00b7 \u00b7 \u00b7< F\u03c9 < \u00b7 \u00b7 \u00b7< F\u03b1 < \u00b7 \u00b7 \u00b7< 0 < \u00b7 \u00b7 \u00b7< T\u03b1 < \u00b7 \u00b7 \u00b7< T\u03c9 < \u00b7 \u00b7 \u00b7< T1 < T0 As shown in (Rondogiannis and Wadge 2005), every logic program P with negation has a unique minimum infinite-valued model MP.", "startOffset": 176, "endOffset": 205}, {"referenceID": 6, "context": "As shown in (Rondogiannis and Wadge 2005), one can compute the minimum infinitevalued model as the least fixed point of an operator TP.", "startOffset": 12, "endOffset": 41}, {"referenceID": 6, "context": "More specifically, as it is shown in (Rondogiannis and Wadge 2005; \u00c9sik and Rondogiannis 2014), TP is \u03b1-monotonic for all countable ordinals \u03b1, a property that guarantees the existence of the least fixed point.", "startOffset": 37, "endOffset": 94}, {"referenceID": 4, "context": "More specifically, as it is shown in (Rondogiannis and Wadge 2005; \u00c9sik and Rondogiannis 2014), TP is \u03b1-monotonic for all countable ordinals \u03b1, a property that guarantees the existence of the least fixed point.", "startOffset": 37, "endOffset": 94}, {"referenceID": 3, "context": "3 Non-Monotonic Fixed Point Theory The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 145, "endOffset": 201}, {"referenceID": 4, "context": "3 Non-Monotonic Fixed Point Theory The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 145, "endOffset": 201}, {"referenceID": 3, "context": "In particular, the results obtained in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene\u2019s theorem and also the Knaster-Tarski theorem).", "startOffset": 39, "endOffset": 95}, {"referenceID": 4, "context": "In particular, the results obtained in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene\u2019s theorem and also the Knaster-Tarski theorem).", "startOffset": 39, "endOffset": 95}, {"referenceID": 3, "context": "In this section we provide the necessary material from (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) that will be needed in the next sections.", "startOffset": 55, "endOffset": 111}, {"referenceID": 4, "context": "In this section we provide the necessary material from (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) that will be needed in the next sections.", "startOffset": 55, "endOffset": 111}, {"referenceID": 0, "context": "Wadge gave a simple example (duplicated below) that revealed these problems; the example has since been used in other studies of higher-order logic programming (such as for example in (Bezem 2001)).", "startOffset": 184, "endOffset": 196}, {"referenceID": 2, "context": "Similarly, the higher-order language introduced in (Charalambidis et al. 2013) also disallows this kind of clauses.", "startOffset": 51, "endOffset": 78}], "year": 2014, "abstractText": "Extensional higher-order logic programming has been introduced as a generalization of classical logic programming. An important characteristic of this paradigm is that it preserves all the well-known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. Using some recent results from non-monotonic fixed-point theory, we demonstrate that every higher-order logic program with negation has a unique minimum infinite-valued model. In this way we obtain the first purely model-theoretic semantics for negation in extensional higher-order logic programming. Using our approach, we resolve an old paradox that was introduced by W. W. Wadge in order to demonstrate the semantic difficulties of higher-order logic programming.", "creator": "LaTeX with hyperref package"}}}