{"id": "1406.0893", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Jun-2014", "title": "Query Answering over Contextualized RDF/OWL Knowledge with Forall-Existential Bridge Rules: Attaining Decidability using Acyclicity (full version)", "abstract": "The recent outburst 3,433 of petronia context - dependent mopping-up knowledge on the Semantic Web (stankevicius SW) has 8.22 led to the realization of holley the importance stewards of the hereditary quads infomedia in imbali the wetting SW 33.76 community. katzenberger Quads, which extend ricaurte a standard 2,000-page RDF tailback triple, medically by adding bj\u00f6rling a lappland new damask parameter aleijadinho of uams the ` jamoat context ' palash of incredibly an RDF basel-country triple, altamirano thus mirzadeh informs a araujo reasoner commital to westers distinguish cockenzie between temirkanov the knowledge in various swayze contexts. munhall Although brazos this distinction schwarzwald separates mirto the langoliers triples tallas in otec an toroid RDF graph into various 70.13 contexts, iied and malifa allows cik the reasoning to be mtel decoupled across radiolabeled various contexts, 1,211 bridge mukilteo rules need to target be unstudied provided bedposts for inter - operating the knowledge across these pesado contexts. vaisseau We call a set of photton@globe.com quads 38.5 together with 38,250 the spatafora bridge rules, a quad - system. pismo In oenanthe this carnarvonshire paper, zahira we seabiscuit discuss emmerdale the problem mirv of maccabi query destructing answering wohlgemuth over quad - systems with expressive 43.86 forall - existential bridge badertscher rules. 52.04 It konowalchuk turns abish out the rowles query answering 67.45 over quad - scream systems is shead undecidable, prabuty in tie-breaking general. hispana We cadenhead derive fereira a aynsley decidable 12345 class verena of quad - systems, seim namely context - acyclic ahcccs quad - systems, for chikhli which stigmatizing query answering dropbox can andover.net be odoacer done using vipul forward accomplish chaining. Tight 1.017 bounds tallest for wuxing data gabba and brazauskas combined complexity of query harborlights entailment dilcher has danican been wapack established for the chown derived darting class.", "histories": [["v1", "Tue, 3 Jun 2014 22:20:05 GMT  (249kb)", "http://arxiv.org/abs/1406.0893v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["mathew joseph", "gabriel kuper", "luciano serafini"], "accepted": false, "id": "1406.0893"}, "pdf": {"name": "1406.0893.pdf", "metadata": {"source": "CRF", "title": "Query Answering over Contextualized RDF Knowledge with Forall-Existential Bridge Rules: Attaining Decidability using Acyclicity (full version)", "authors": ["Mathew Joseph", "Gabriel Kuper", "Luciano Serafini"], "emails": ["mathew@fbk.eu,", "serafini@fbk.eu,", "kuper@disi.unitn.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 6.\n08 93\nv1 [\ncs .L\nO ]\n3 J\nKeywords: Contextualized RDF/OWL knowledge, Contextualized Query Answering, Quads, Forall-Existential Rules, Semantic Web, Knowledge Representation."}, {"heading": "1 Introduction", "text": "One of the major recent changes in the SW community is the transformation from a triple to a quad as its primary knowledge carrier. As a consequence, more and more triple stores are becoming quad stores. Some of the popular quad-stores are 4store1, Openlink Virtuoso2, and some of the current popular triple stores like Sesame3 internally keep track of the context by storing arrays of four names (c, s, p, o) (further denoted as c : (s, p, o)), where c is an identifier that stands for the context of the triple (s, p, o). Some of the recent initiatives in this direction have also extended existing formats like N-Triples to N-Quads. The latest Billion triples challenge datasets (BTC 2012) have all been released in the N-Quads format.\n1 http://4store.org 2 http://virtuoso.openlinksw.com/rdf-quad-store/ 3 http://www.openrdf.org/\nOne of the main benefits of quads over triples are that they allow users to specify various attributes of meta-knowledge that further qualify knowledge [8], and also allow users to query for this meta knowledge [29]. Examples of these attributes, which are also called context dimensions [12], are provenance, creator, intended user, creation time, validity time, geo-location, and topic. Having defined various contexts in which triples are dispersed, one can declare in another meta-context mc, statements such as mc : (c1, creator, John), mc : (c1, expiryTime, \u201cjun-2013\u201d) that talk about the knowledge in context c1, in this case its creator and expiry time. Another benefit of such a contextualized approach is that it opens possibilities of interesting ways for querying a contextualized knowledge base. For instance, if context c1 contains knowledge about Football World Cup 2014 and context c2 about Football Euro Cup 2012. Then the query \u201cwho beat Italy in both Euro Cup 2012 and World Cup 2014\u201d can be formalized as the conjunctive query:\nc1: (x, beat, Italy) \u2227 c2: (x, beat, Italy),where x is a variable.\nAs the knowledge can be separated context wise and simultaneously be fed to separate reasoning engines, this approach increases both efficiency and scalability. Besides the above flexibility, bridge rules [4] can be provided for inter-interoperating the knowledge in different contexts. Such rules are primarily of the form:\nc : \u03c6(x) \u2192 c\u2032 : \u03c6\u2032(x)\nwhere \u03c6, \u03c6\u2032 are both atomic concept (role) symbols, c, c\u2032 are contexts. The semantics of such a rule is that if, for any a, \u03c6(a) holds in context c, then \u03c6\u2032(a) should hold in context c\u2032, wherea is a unary/binary vector dependending on whether \u03c6, \u03c6\u2032 are concept/role symbols. Although such bridge rules serve the purpose of specifying knowledge interoperability from a source context c to a target context c\u2032, in many practical situations there is the need of interoperating multiple source contexts with multiple target targets, for which the bridge rules of the form (1) is inadequate. Besides, one would also want the ability of creating new values in target contexts for the bridge rules.\nIn this work, we consider forall-existential bridge rules that allows conjunctions and existential quantifiers in them, and hence is more expressive than those, in DDL [4] and McCarthy et al. [27]. A set of quads together with such bridge rules is called a quad-system. The main contributions of this work can be summarized as:\n1. We provide a basic semantics for contextual reasoning over quad-systems, and study contextualized conjunctive query answering over them. For query answering, we use the notion of a distributed chase, which is an extension of a standard chase [22, 1] that is widely used in databases and KR for the same. 2. We show that conjunctive query answering over quad-systems, in general, is undecidable. We derive a class of quad-systems called context acyclic quad-systems, for which query answering is decidable and can be done by forward chaining. We give both data and combined complexity of conjunctive query entailment for the same.\nThe paper is structured as follows: In section 2, we formalize the idea of contextualized quad-systems, giving various definitions and notations for setting the background.\nIn section 3, we formalize the query answering on quad-systems, define notions such as distributed chase that is further used for query answering, and give the undecidability results of query entailment for unrestricted quad-systems. In section 4, we present context acyclic quad-systems and its properties. We give an account of relevant related works in section 5, and conclude in section 6."}, {"heading": "2 Contextualized Quad-Systems", "text": "In this section, we formalize the notion of a quad-system and its semantics. For any vector or sequence x, we denote by \u2016x\u2016 the number of symbols in x, and by {x} the set of symbols in x. For any sets A and B, A \u2192 B denotes the set of all functions from set A to set B. Given the set of URIs U, the set of blank nodes B, and the set of literals L, the set C = U \u228e B \u228e L are called the set of (RDF) constants. Any (s, p, o) \u2208 C \u00d7 C \u00d7 C is called a generalized RDF triple (from now on, just triple). A graph is defined as a set of triples. A Quad is a tuple of the form c : (s, p, o), where (s, p, o) is a triple and c is a URI4, called the context identifier that denotes the context of the RDF triple. A quad-graph is defined as a set of quads. For any quad-graphQ and any context identifier c, we denote by graphQ(c) the set {(s, p, o)|c : (s, p, o) \u2208 Q}. We denote by QC the quad-graph whose set of context identifiers is C. Let V be the set of variables, any element of the set CV = V\u222aC is a term. Any (s, p, o) \u2208 CV\u00d7CV\u00d7CV is called a triple pattern, and an expression of the form c : (s, p, o), where (s, p, o) is a triple pattern, c a context identifier, is called a quad pattern. A triple pattern t, whose variables are elements of the vector x or elements of the vector y is written as t(x,y). For any function f : A \u2192 B, the restriction of f to a set A\u2032, is the mapping f |A\u2032 from A\u2032\u2229A to B s.t. f |A\u2032(a) = f(a), for each a \u2208 A\u2229A\u2032. For any triple pattern t = (s, p, o) and a function \u00b5 from V to a set A, t[\u00b5] denotes (\u00b5\u2032(s), \u00b5\u2032(p), \u00b5\u2032(o)), where \u00b5\u2032 is an extension of \u00b5 to C s.t. \u00b5\u2032|C is the identity function. For any set of triple patterns G, G[\u00b5] denotes \u22c3\nt\u2208G t[\u00b5]. For any vector of constants a = \u3008a1, . . . , a\u2016a\u2016\u3009, and vector of variables x of the same length, x/a is the function \u00b5 s.t. \u00b5(xi) = ai, for 1 \u2264 i \u2264 \u2016a\u2016. We use the notation t(a,y) to denote t(x,y)[x/a]. Bridge rules (BRs) Bridge rules (BR) enables knowledge propagation across contexts. Formally, a BR is an expression of the form:\n\u2200x\u2200z [c1: t1(x, z) \u2227 ... \u2227 cn: tn(x, z) \u2192 \u2203y c\u20321: t \u2032 1(x,y) \u2227 ... \u2227 c \u2032 m: t \u2032 m(x,y)] (1)\nwhere c1, ..., cn, c\u20321, ..., c \u2032 m are context identifiers, x,y, z are vectors of variables s.t. {x}, {y}, and {z} are pairwise disjoint. t1(x, z), ..., tn(x, z) are triple patterns which do not contain blank-nodes, and whose set of variables are from x or z. t\u20321(x, y), ...,t\u2032m(x,y) are triple patterns, whose set of variables are from x or y, and also does not contain blank-nodes. For any BR, r, of the form (1), body(r) is the set of quad patterns {c1: t1(x, z),...,cn: tn(x, z)}, and head(r) is the set of quad patterns {c\u20321: t \u2032 1(x,y), ... c\u2032m: t \u2032 m(x, y)}.\nDefinition 1 (Quad-System). A quad-system QSC is defined as a pair \u3008QC , R\u3009, where QC is a quad-graph, whose set of context identifiers is C, and R is a set of BRs.\n4 Although, in general a context identifier can be a constant, for the ease of notation, we restrict them to be a URI\nFor any quad-graph QC (BR r), its symbols size \u2016QC\u2016 (\u2016r\u2016) is the number of symbols required to print QC (r). Hence, \u2016QC\u2016 \u2248 4\u2217|QC|, where |QC| denotes the cardinality of the set QC . Note that |QC| equals the number of quads in QC . For a BR r, \u2016r\u2016 \u2248 4 \u2217 k, where k is the number of quad-patterns in r. For a set of BRs R, its size \u2016R\u2016 is given as \u03a3r\u2208R\u2016r\u2016. For any quad-system QSC = \u3008QC , R\u3009, its size \u2016QSC\u2016 = \u2016QC\u2016+ \u2016R\u2016.\nSemantics In order to provide a semantics for enabling reasoning over a quad-system, we need to use a local semantics for each context to interpret the knowledge pertaining to it. Since the primary goal of this paper is a decision procedure for query answering over quad-systems based on forward chaining, we consider the following desiderata for the choice of the local semantics:\n\u2013 there exists a set of inference rules and an operation lclosure() that computes the deductive closure of a graph w.r.t to the local semantics using the inference rules. \u2013 given a finite graph as input, the lclosure() operation, terminates with a finite graph as output in polynomial time whose size is polynomial w.r.t. to the input set.\nSome of the alternatives for the local semantics satisfying the above mentioned criterion are Simple, RDF, RDFS [19], OWL-Horst [20] etc. Assuming that a local semantics has been fixed, for any context c, we denote by Ic = \u3008\u2206c, \u00b7c\u3009 an interpretation structure for the local semantics, where \u2206c is the interpretation domain, \u00b7c the corresponding interpretation function. Also |=local denotes the local satisfaction relation between a local interpretation structure and a graph. Given a quad graphQC , a distributed interpretation structure is an indexed set IC = {Ic}c\u2208C, where Ic is a local interpretation structure, for each c \u2208 C. We define the satisfaction relation |= between a distributed interpretation structure IC and a quad-system QSC as:\nDefinition 2 (Model of a Quad-System). A distributed interpretation structure IC = {Ic}c\u2208C satisfies a quad-system QSC = \u3008QC , R\u3009, in symbols IC |= QSC, iff all the following conditions are satisfied: 1. Ic |=local graphQC (c), for each c \u2208 C; 2. aci = acj , for any a \u2208 C, ci, cj \u2208 C; 3. for each BR r \u2208 R of the form (1) and for each \u03c3 \u2208 V \u2192 \u2206C , where \u2206C =\n\u22c3\nc\u2208C \u2206 c, if\nIc1 |=local t1(x, z)[\u03c3], ..., I cn |=local tn(x, z)[\u03c3],\nthen there exists function \u03c3\u2032 \u2287 \u03c3, s.t.\nIc \u2032 1 |=local t \u2032 1(x,y)[\u03c3 \u2032], ..., Ic \u2032 m |=local t \u2032 m(x,y)[\u03c3 \u2032].\nCondition 1 in the above definition ensures that for any model IC of a quad-graph, each Ic \u2208 IC is a local model of the set of triples in context c. Condition 2 ensures that any constant c is rigid, i.e. represents the same resource across a quad-graph, irrespective of the context in which it occurs. Condition 3 ensure that any model of a quad-system satisfies each BR in it. Any IC s.t. IC |= QSC is said to be a model of QSC. A quadsystem QSC is said to be consistent if there exists a model IC , s.t. IC |= QSC , and otherwise said to be inconsistent. For any quad-system QSC = \u3008QC , R\u3009, it can be the case that graphQC(c) is locally consistent, for each c \u2208 C, whereas QSC is not consistent. This is because the set of BRs R adds more knowledge to the quad-system, and restricts the set of models that satisfy the quad-system.\nDefinition 3 (Quad-system entailment). (a) A quad-system QSC entails a quad c : (s, p, o), in symbols QSC |= c : (s, p, o), iff for any distributed interpretation structure IC , if IC |= QSC then IC |= \u3008{c : (s, p, o)}, \u2205\u3009. (b) A quad-system QSC entails a quadgraph Q\u2032C\u2032 , in symbols QSC |= Q \u2032 C\u2032 iff QSC |= c : (s, p, o) for any c : (s, p, o) \u2208 Q \u2032 C\u2032 . (c) A quad-system QSC entails a BR r iff for any IC , if IC |= QSC then IC |= \u3008\u2205, {r}\u3009. (d) For a set of BRs R, QSC |= R iff QSC |= r, for every r \u2208 R. (e) Finally, a quadsystem QSC entails another quad-system QS\u2032C\u2032 = \u3008Q \u2032 C\u2032 , R\n\u2032\u3009, in symbols QSC |= QS\u2032C\u2032 iff QSC |= Q\u2032C\u2032 and QSC |= R \u2032. We call the decision problems (DPs) corresponding to the entailment problems (EPs) in (a), (b), (c), (d), and (e) as quad EP, quad-graph EP, BR EP, BRs EP, and quad-system EP, respectively."}, {"heading": "3 Query Answering on Quad-Systems", "text": "In the realm of quad-systems, the classical conjunctive queries or select-project-join queries are slightly extended to what we call Contextualized Conjunctive Queries (CCQs). A CCQ CQ(x) is an expression of the form:\n\u2203y q1(x,y) \u2227 ... \u2227 qp(x,y) (2)\nwhere qi, for i = 1, ..., p are quad patterns over vectors of free variables x and quantified variables y. A CCQ is called a boolean CCQ if it does not have any free variables. For any CCQ CQ(x) and a vector a of constants s.t. \u2016x\u2016 = \u2016a\u2016, CQ(a) is boolean. A vector a is an answer for a CCQ CQ(x) w.r.t. structure IC , in symbols IC |= CQ(a), iff there exists assignment \u00b5 : {y} \u2192 B s.t. IC |= \u22c3\ni=1,...,p qi(a,y)[\u00b5]. A vector a is a certain answer for a CCQ CQ(x) over a quad-system QSC, iff IC |= CQ(a), for every model IC of QSC. Given a quad-system QSC, a CCQ CQ(x), and a vector a, DP of determining whether QSC |= CQ(a) is called the CCQ EP. It can be noted that the other DPs over quad-systems that we have seen are reducible to CCQ EP. Hence, in this paper, we primarily focus on the CCQ EP.\ndChase of a Quad-System In order to do query answering over a quad-system, we employ what has been called in the literature, a chase [22, 1], specifically, we adopt notion of the skolem chase given in Marnette [26] and Cuenca Grau et al [9]. In order to fit the framework of quad-systems, we extend the standard notion of chase to a distributed chase, abbreviated dChase. In the following, we show how the dChase of a quad-system can be constructed.\nFor any BR r of the form (1), the skolemization sk(r) is the result of replacing each yi \u2208 {y} with a globally unique Skolem function f ri , s.t. f r i : C\n\u2016x\u2016 \u2192Bsk, where Bsk is a fresh set of blank nodes called skolem blank nodes. Intuitively, for every distinct vector a of constants, with \u2016a\u2016 = \u2016x\u2016, f ri (a) is a fresh blank node, whose node id is a hash of a. Let fr = \u3008f r1 , ..., f r \u2016y\u2016\u3009 be a vector of distinct Skolem functions; for any BR r the form (1), with slight abuse (Datalog notation) we write its skolemization sk(r) as follows:\nc1 : t1(x, z), ..., cn : tn(x, z) \u2192 c \u2032 1 : t \u2032 1(x,f r), ..., c\u2032m : t \u2032 m(x,f r) (3)\nMoreover, a skolemized BR r of the form (3) can be replaced by the following semantically equivalent set of formulas, whose symbol size is worst case quadratic w.r.t \u2016r\u2016:\n{c1 : t1(x, z), ..., cn : tn(x, z) \u2192 c \u2032 1 : t \u2032 1(x,f r), (4)\n...,\nc1 : t1(x, z), ..., cn : tn(x, z) \u2192 c \u2032 m : t \u2032 m(x,f r)}\nNote that each BR in the above set has exactly one quad pattern with optional function symbols in its head part. Also note that a BR with out function symbols can be replaced with a set of BRs with single quad-pattern heads. Hence, w.l.o.g, we assume that any BR in a skolemized set sk(R) of BRs is of the form (4). For any quad-graph QC and a skolemized BR r of the form (4), application of r on QC , denoted by r(QC), is given as: r(QC) = \u22c3\n\u00b5\u2208V\u2192C\n{\nc\u20321 : t \u2032 1(x,f r)[\u00b5] | c1 : t1(x, z)[\u00b5] \u2208 QC , ..., cn : tn(x, z)[\u00b5] \u2208 QC }\nFor any set of skolemized BRs R, application of R on QC is given by: R(QC) = \u22c3\nr\u2208R r(QC). For any quad-graph QC, we define:\nlclosure(QC) = \u22c3\nc\u2208C\n{c : (s, p, o) |(s, p, o) \u2208 lclosure(graphQC (c))}\nFor any quad-system QSC = \u3008QC , R\u3009, generating BRs RF is the set of BRs in sk(R) with function symbols, and the non-generating BRs is the set RI = sk(R) \\RF . Let dChase0(QSC) = lclosure(QC); for i \u2208 N, dChasei+1(QSC) =\nlclosure(dChasei(QSC) \u222aRI(dChasei(QSC))), if RI(dChasei(QSC)) 6\u2286 dChasei(QSC); lclosure(dChasei(QSC) \u222aRF (dChasei(QSC))), otherwise;\nThe dChase of QSC , denoted dChase(QSC), is given as:\ndChase(QSC) = \u22c3\ni\u2208N\ndChasei(QSC)\nIntuitively, dChasei(QSC) can be thought of as the state of dChase(QSC) at the end of iteration i. It can be noted that, if there exists i s.t. dChasei(QSC) = dChasei+1(QSC), then dChase(QSC) = dChasei(QSC). An iteration i, s.t. dChasei(QSC) is computed by the application of the set of (resp. non-)generating BRs RF (resp. RI ), on dChasei\u22121(QSC) is called a (resp. non-)generating iteration. The dChase dChase(QSC) of a consistent quad-system QSC is a universal model [10] of the quad-system, i.e. it is a model of QSC, and for any model IC of QSC, there is a homomorphism from dChase(QSC) to IC . Hence, for any boolean CCQ CQ(), QSC |= CQ() iff there exists a map \u00b5 : V(CQ) \u2192 C s.t. {CQ()}[\u00b5] \u2286 dChase(QSC). We call the sequence dChase0(QSC), dChase1(QSC), ..., the dChase sequence of QSC. The following lemma shows that in a dChase sequence of a quad-system, the result of a single generating iteration and a subsequent number of non-generating iterations causes only an exponential blow up in size.\nLemma 1. For a quad-system QSC = \u3008QC , R\u3009, the following holds: (i) if i \u2208 N is a generating iteration, then \u2016dChasei(QSC)\u2016 = O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016), (ii) suppose i \u2208 N is a generating iteration, and for any j \u2265 1, i+1, ..., i+j are non-generating iterations, then \u2016dChasei+j(QSC)\u2016 = O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016), (iii) for any iteration k, dChasek(QSC) can be computed in time O(\u2016dChasek\u22121(QSC)\u2016\u2016R\u2016).\nProof (sketch). (i) R can be applied on dChasei\u22121(QSC) by grounding R to the set of constants in dChasei\u22121(QSC), the number of such groundings is of the order O( \u2016dChasei\u22121(QSC)\u2016\u2016R\u2016), \u2016R(dChasei\u22121(QSC))\u2016=O(\u2016R\u2016\u2217\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016). Since lclosure only increases the size polynomially,\u2016dChasei(QSC)\u2016=O( \u2016dChasei\u22121( QSC)\u2016\u2016R\u2016).\n(ii) From (i) we know that \u2016R(dChasei\u22121(QSC))\u2016=O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016). Since, no new constant is introduced in any subsequent non-generating iterations, and since any quad contains only four constants, the set of constants in any subsequent dChase iteration is O(4 \u2217 \u2016dChasei\u22121(QSC)\u2016\u2016R\u2016). Since only these many constants can appear in positions c, s, p, o of any quad generated in the subsequent iterations, the size of dChasei+j(QSC) can only increase polynomially, which means that \u2016dChasei+j( QSC)\u2016 = O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016).\n(iii) Since any dChase iteration k involves the following two operations: (a) lclosure(), and (b) computing R(dChasek\u22121(QSC)). (a) can be done in PTIME w.r.t to its input. (b) can be done in the following manner: ground R to the set of constants in dChasei\u22121(QSC); then for each grounding g, if body(g) \u2286 dChasei\u22121(QSC), then add head(g) to R(dChasek\u22121(QSC)). Since, the number of such groundings is of the order O(\u2016dChasek\u22121(QSC)\u2016\u2016R\u2016), and checking if each grounding is contained in dChasek\u22121(QSC), can be done in time polynomial in \u2016dChasek\u22121(QSC)\u2016, the time taken for (b) is O(\u2016dChasek\u22121(QSC)\u2016\u2016R\u2016). Hence, any iteration k can be done in time O(\u2016dChasek\u22121(QSC)\u2016\u2016R\u2016). \u2293\u2294\nAlthough, we now know how to compute the dChase of a quad-system, which can be used for deciding CCQ EP, it turns out that for the class of quad-systems whose BRs are of the form (1), which we call unrestricted quad-systems, the dChase can be infinite. This raises the question if there are other approaches that can be used, for instance similar problem arises in DLs with value creation, due to the presence of existential quantifiers, whereas the approaches like the one in Glim et al. [16] provides an algorithm for CQ entailment based on query rewriting.\nTheorem 1. The CCQ EP over unrestricted quad-systems is undecidable.\nProof (sketch). We show that the well known undecidable problem of non-emptiness of intersection of context-free grammars (CFGs) is reducible to the CCQ entailment problem. Given two CFGs, G1 = \u3008V1, T, S1, P1\u3009 and G2 = \u3008V2, T, S2, P2\u3009, where V1, V2 are the set of variables, T s.t. T \u2229 (V1 \u222a V2) = \u2205 is the set of terminals. S1 \u2208 V1 is the start symbol of G1, and P1 are the set of PRs of the form v \u2192 w, where v \u2208 V , w is a sequence of the form w1...wn, where wi \u2208 V1 \u222a T . Similarly s2, P2 is defined. Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [18].\nGiven two CFGs G1 = \u3008V1, T, S1, P1\u3009 and G2 = \u3008V2, T, S2, P2\u3009, we encode grammars G1, G2 into a quad-system QSc = \u3008Qc, R\u3009, with only a single context identifier c. Each PR r = v \u2192 w \u2208 P1 \u222a P2, with w = w1w2w3..wn, is encoded as a BR of the form: c : (x1, w1, x2), c : (x2, w2, x3), ..., c : (xn, wn, xn+1) \u2192 c : (x1, v, xn+1), where x1, .., xn+1 are variables. For each terminal symbol ti \u2208 T , R contains a BR of the form: c : (x,rdf:type, C) \u2192 \u2203y c : (x, ti, y), c : (y,rdf:type, C) and Qc is the singleton: {c : (a,rdf:type, C)}. It can be observed that:\nQSc |= \u2203y c : (a, S1, y) \u2227 c : (a, S2, y) \u21d4 L(G1) \u2229 L(G2) 6= \u2205\nWe refer the reader to Appendix for the complete proof. \u2293\u2294"}, {"heading": "4 Context Acyclic Quad-Systems: A decidable class", "text": "In the previous section, we saw that query answering on unrestricted quad-systems is undecidable, in general. We in the following define a class of quad-systems for which query entailment is decidable. The class has the property that algorithms based on forward chaining, for deciding query entailment, can straightforwardly be implemented (by minor extensions) on existing quad stores. It should be noted that the technique we propose is reminiscent of the Weak acyclicity [13, 11] technique used in the realm of Datalog+-.\nConsider a BR r of the form: c1 : t1(x, z), c2 : t2(x, z) \u2192 \u2203y c3 : t3(x,y), c4 : t4(x, y). Since such a rule triggers propagation of knowledge in a quad-system, specifically triples from the source contexts c1, c2 to the target contexts c3, c4 in a quad-system.\nAs shown in Fig. 1, we can view a BR as a propagation rule across distinct compartments of knowledge, divided as contexts. For any BR of the form (1), each context in the set {c\u20321, ..., c \u2032 m} is said to depend on the set of contexts {c1, ..., cn}. In a quadsystem QSC = \u3008QC , R\u3009, for any r \u2208 R, of the form (1), any context whose identifier is in the set\n{c | c : (s, p, o) \u2208 head(r), s or p or o is an existentially quantified variable}, is called a triple generating context (TGC). One can analyze the set of BRs in a quad-system QSC using a context dependency graph, which is a directed graph, whose nodes are context identifiers in C, s.t. the nodes corresponding to TGCs are marked with a \u2217, and whose edges are constructed as follows: for each BR of the form (1), there exists an edge from each ci to c\u2032j , for i = 1, ..., n, j = 1, ...,m. A quad-system is said to be context acyclic, iff its context dependency graph does not contain cycles involving TGCs.\nExample 1. Consider a quad-system, whose set of BRs R are:\nc1 : (x1, x2,U1) \u2192 \u2203y1 c2 : (x1, x2, y1), c3 : (x2,rdf:type,rdf:Property) (5)\nc2 : (x1, x2, z1) \u2192 c1 : (x1, x2,U1) (6)\nc3 : (x1, x2, x3) \u2192 c1 : (x1, x2, x3)\nwhere U1 be a URI, whose corresponding dependency graph is shown in Fig. 2. Note that the node corresponding to the triple generating context c2 is marked with a \u2018\u2217\u2019 symbol. Since the cycle (c1, c2, c1) in the quad-system contains c2 which is a TGC, the quad-system is not context acyclic.\nIn a context acyclic quad-system QSC, since there exists no cyclic path through any TGC node in the context dependency graph, there exists a set of TGCs C\u2032 \u2286 C s.t. for any c \u2208 C\u2032, there exists no incoming path5 from a TGC to c. We call such TGCs, level-1 TGCs. In other words, a TGC c is a level-1 TGC, if for any c\u2032 \u2208 C, there exists an incoming path from c\u2032 to c, implies c\u2032 is not a TGC. For l \u2265 1, a level-l+1 TGC c is a TGC that has an incoming path from a level-l TGC, and for any incoming path from a level-l\u2032 TGC to c, is s.t. l\u2032 \u2264 l. Extending the notion of level also to the nonTGCs, we say that any non-TGC that does not have any incoming paths from a TGC\nc1\nc2\n\u2217\nc3\nFig. 2: Context Dependency graph\nis at level-0; we say that any non-TGC c \u2208 C is at level-l, if there exists an incoming path from a level-l TGC to c, and for any incoming path from a level-l\u2032 TGC to c, is s.t. l\u2032 \u2264 l. Hence, the set of contexts in a context acyclic quad-system can be partitioned using the above notion of levels.\nDefinition 4. For a quad-system QSC, a context c \u2208 C is said to be saturated in an iteration i, iff for any quad of the form c : (s, p, o), c : (s, p, o) \u2208 dChase(QSC) implies c : (s, p, o) \u2208 dChasei(QSC).\nIntuitively, context c is saturated in the dChase iteration i, if no new quad of the form c : (s, p, o) will be generated in any dChasek(QSC), for any k > i. The following lemma gives the relation between the saturation of a context and the required number of dChase iterations, for a context acyclic quad-system.\nLemma 2. For any context acyclic quad-system, the following holds: (i) any level-0 context is saturated before the first generating iteration, (ii) any level-1 TGC is saturated after the first generating iteration, (iii) any level-k context is saturated before the k + 1th generating iteration.\nProof. Let QSC = \u3008QC , R\u3009 be the quad-system, whose first generating iteration is i. (i) for any level-0 context c, any BR r \u2208 R, and any quad-pattern of the form c : (s, p, o), if c : (s, p, o) \u2208 head(r), then for any c\u2032 s.t. c\u2032 : (s\u2032, p\u2032, o\u2032) occurs in body(r)\n5 assume that paths have at least one edge\nimplies that c\u2032 is a level-0 context and r is a non-generating BR. Also, since c\u2032 is a level0 context, the same applies to c\u2032. Hence, it turns out that only non-generating BRs can bring triples to any level-0 context. Since at the end of iteration i\u22121, dChasei\u22121(QSC) is closed w.r.t. the set of non-generating BRs (otherwise, by construction of dChase, i would not be a generating iteration). This implies that c is saturated before the first generating iteration i.\n(ii) for any level-1 TGC c, any BR r \u2208 R, and any quad-pattern c : (s, p, o), if c : (s, p, o) \u2208 head(r), then for any c\u2032 s.t. c\u2032 : (s\u2032, p\u2032, o\u2032) occurs in body(r) implies that c\u2032 is a level-0 context (Otherwise level of c would be greater than 1). This means that only contexts from which triples get propagated to c are level-0 contexts. From (i) we know that all the level-0 contexts are saturated before ith iteration, and since during the ith iteration RF is applied followed by the lclosure() operation (RI need not be applied, since dChasei\u22121(QSC) is closed w.r.t. RI ), c is saturated after iteration i, the 1st generating iteration.\n(iii) can be obtained from generalization of (i) and (ii), and from the fact that any level-k context can only have incoming paths from contexts whose levels are less than or equal to k. \u2293\u2294\nExample 2. Consider the dependency graph in Fig. 3a, where .. indicates part of the graph that is not under the scope of our discussion. The TGCs nodes c1 and c3 are marked with a \u2217. It can be seen that both c2 and c4 are level-0 contexts, since they do not have any incoming paths from TGCs. Since the only incoming paths to context c1 are from c2 and c4, which are not TGCs, c1 is a level-1 TGC. Context c3 is a level-2 TGC, since it has an incoming path from the level-1 TGC c1, and has no incoming path\nfrom a TGC whose level is greater than 1. Since the level-0 contexts only have incoming paths from level-0 contexts and only appear on the head part of non-generating BRs, before first generating iteration, all the level-0 TGCs becomes saturated, as the set of non-generating BRs RI has been exhaustively applied. This situation is reflected in Fig. 3b, where the saturated nodes are shaded with gray. Note that after the first and second generating iterations c1 and c3 also become saturated, respectively.\nThe following lemma shows that for context acyclic quad-systems, there exists a finite bound on the size and computation time of its dChase.\nLemma 3. For any context acyclic quad-system QSC = \u3008QC , R\u3009, the following holds: (i) the number of dChase iterations is finite, (ii) size of the dChase \u2016dChase(QSC)\u2016 = O(22 \u2016QSC\u2016), (iii) computing dChase(QSC) is in 2EXPTIME, (iv) if R and the set of schema triples in QC is fixed, then \u2016dChase(QSC)\u2016 is a polynomial in \u2016QSC\u2016, and computing dChase(QSC) is in PTIME.\nProof. (i) Since QSC is context-acyclic, all the contexts can be partitioned according to their levels. Also, the number of levels k is s.t. k \u2264 |C|. Hence, applying lemma 1, before the k + 1th generating iteration all the contexts becomes saturated, and k + 1th generating iteration do not produce any new quads, terminating the dChase computation process.\n(ii) In the dChase computation process, since by lemma 1, any generating iteration and a sequence of non-generating iterations can only increase the dChase size exponentially in \u2016R\u2016, the size of the dChase before k + 1 th generating iteration is O(\u2016dChase0(QSC)\u2016\u2016R\u2016 k ), which can be written as O(\u2016QSC\u2016\u2016R\u2016 k\n) (\u2020). As seen in (i), there can only be |C| generating iterations, and a sequence of non-generating iterations. Hence, applying k = |C| to (\u2020), and taking into account the fact that |C| \u2264 \u2016QSC\u2016, the size of the dChase \u2016dChase(QSC)\u2016 = O(22\n\u2016QSC\u2016). (iii) Since in any dChase iteration except the final one, atleast one new quad should be produced and the final dChase can have at most O(22 \u2016QSC\u2016) quads (by ii), the total number of iterations are bounded by O(22 \u2016QSC\u2016\n) (\u2020). Since from lemma 1, we know that for any iteration i, computing dChasei(QSC) is of the order O(\u2016dChasei\u22121(QSC )\u2016\u2016R\u2016). Since, \u2016dChasei\u22121(QSC)\u2016 can at most be O(22 \u2016QSC\u2016\n), computing dChasei( QSC) is of the orderO(2\u2016R\u2016\u22172\n\u2016QSC\u2016)). Also since \u2016R\u2016 \u2264 \u2016QSC\u2016, any iteration requires O(22\n\u2016QSC\u2016) time (\u2021). From (\u2020) and (\u2021), we can conclude that the time required for computing dChase is in 2EXPTIME.\n(iv) In (ii) we saw that the size of the dChase before k + 1th generating iteration is given by O(\u2016QSC\u2016\u2016R\u2016 k\n) (\u22c4). Since by hypothesis \u2016R\u2016 is a constant and also the size of the dependency graph and the levels in it. Hence, the expression \u2016R\u2016k in (\u22c4) amounts to a constant z. Hence, \u2016dChase(QSC)\u2016 = O(\u2016QSC\u2016z). Hence, the size of dChase(QSC) is a polynomial in \u2016QSC\u2016.\nAlso, since in any dChase iteration except the final one, atleast one quad should be produced and the final dChase can have at most O(\u2016QSC\u2016z) quads, the total number of iterations are bounded by O(\u2016QSC\u2016z) (\u2020). Also from lemma 1, we know that any dChase iteration i, computing dChasei(QSC) involves two steps: (a) computing R(dChasei\u22121(QSC)), and (b) computing lclosure(), which can be done in\nPTIME in the size of its input. Since computing R(dChasei\u22121(QSC)) is of the order O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016), where |R| is a constant and \u2016dChasei\u22121(QSC)\u2016 is a polynomial is \u2016QSC\u2016, each iteration can be done in time polynomial in \u2016QSC\u2016 (\u2021). From (\u2020) and (\u2021), it can be concluded that dChase can be computed in PTIME. \u2293\u2294\nLemma 4. For any context acyclic quad-system, the following holds: (i) data complexity of CCQ entailment is in PTIME (ii) combined complexity of CCQ entailment is in 2EXPTIME.\nProof. For a context acyclic quad-system QSC = \u3008QC , R\u3009, since dChase(QSC) is finite, a boolean CCQ CQ() can naively be evaluated by grounding the set of constants in the chase to the variables in the CQ(), and then checking if any of these groundings are contained in dChase(QSC). The number of such groundings can at most be \u2016dChase(QSC)\u2016\u2016CQ()\u2016 (\u2020).\n(i) Since for data complexity, the size of the BRs \u2016R\u2016, the set of schema triples, and \u2016CQ()\u2016 is fixed to constant. From lemma 3 (iv), we know that under the above mentioned settings the dChase can be computed in PTIME and is polynomial in the size of QSC . Since \u2016CQ()\u2016 is fixed to a constant, and from (\u2020), binding the set of constants in dChase(QSC) on CQ() still gives a number of bindings that is worst case polynomial in the size of QSC. Since membership of these bindings can checked in the polynomially sized dChase in PTIME, the time required for CCQ evaluation is in PTIME.\n(ii) Since in this case \u2016dChase(QSC)\u2016 = O(22 \u2016QSC\u2016) (\u2021), from (\u2020) and (\u2021), binding\nthe set of constants in \u2016dChase(QSC\u2016 to variables inCQ() amounts to O(2\u2016CQ()\u2016\u22172 \u2016QSC\u2016) bindings. Since the size of dChase is double exponential in \u2016QSC\u2016, checking the membership of each of these bindings can be done in 2EXPTIME. Hence, the combined complexity is in 2EXPTIME. \u2293\u2294\nTheorem 2. For any context acyclic quad-system, the following holds: (i) The data complexity of CCQ entailment is PTIME-complete, (ii) The combined complexity of CCQ entailment is 2EXPTIME-complete.\nFor PTIME-hardness of data complexity, it can be shown that the well known problem of 3HornSat, the satisfiability of propositional Horn formulas with atmost 3 literals, and for 2EXPTIME-hardness for the combined complexity, it can be shown that the word problem of a double exponentially time bounded deterministic turing machine, which is a well known 2EXPTIME-hard problem, is reducible to the CCQ entailment problem (see appendix for detailed proof).\nReconsidering the quad-system in example 1, which is not context acyclic. Suppose that the contexts are enabled with RDFS inferencing, i.e lclosure() = rdfsclosure(). During dChase construction, since any application of rule (5) can only create a triple in c2 in which the skolem blank node is in the object position, where as the application of rule (6), does not propogate constants in object postion to c1. Although at a first look, the dChase might seem to terminate, but since the application of the following RDFS inference rule in c2: (s, p, o) \u2192 (o ,rdf:type, rdfs:Resource), derives a quad of the form c2 : ( :b, rdf:type, rdfs:Resource), where :b is the skolem blank-node created by the application of rule (5). Now by application of rule (6) leads\nto c1 : ( :b,rdf:type, U1). Since rule (5) is applicable on c1 : ( :b,rdf:type, U1), which again brings a new skolem blank node to c2, and hence the dChase construction doesn\u2019t terminate. Hence, as seen above the notion of context acyclicity can alarm us about such infinite cases."}, {"heading": "5 Related Work", "text": "Contexts and Distributed Logics The work on contexts began in the 80s when McCarthy [21] proposed context as a solution to the generality problem in AI. After this various studies about logics of contexts mainly in the field of KR was done by Guha [28], Distributed First Order Logics by Ghidini et al. [14] and Local Model Semantics by Giunchiglia et al. [15]. Primarily in these works contexts are formalized as a first order/propositional theories, and bridge rules were provided to inter-operate the various contexts. Some of the initial works on contexts relevant to semantic web were the ones like Distributed Description Logics [4] by Borgida et al., E-connections [25] by Kutz et al., Context-OWL [5] by Bouqet et al., and the work of CKR [30, 23] by Serafini et al. These were mainly logics based on DLs, which formalized contexts as OWL KBs, whose semantics is given using a distributed interpretation structure with additional semantic conditions that suits varying requirements. Compared to these works, the bridge rules we consider are much more expressive with conjunctions and existential variables that supports value/blank-node creation.\n\u2200\u2203 rules, TGDs, Datalog+- rules Query answering over rules with universal existential quantifiers in the context of databases/KR, where these rules are called tuple generating dependencies (TGDs)/Datalog+- rules, was done by Beeri and Vardi [3] even in the early 80s, where the authors show that the query entailment problem in general is undecidable. However, recently many classes of such rules have been identified for which query answering is decidable. These includes (a) fragments s.t. the resulting models have bounded tree widths, called bounded treewidth sets (BTS), such as Weakly guarded rules [7], Frontier guarded rules [2], (b) fragments called finite unification sets (FUS), such as \u2018sticky\u2019 rules [6, 17], and (c) fragments called finite extension sets (FES), where sufficient conditions are enforced to ensure finiteness of the chase and its termination. The approach used for query answering in FUS is to rewrite the input query w.r.t. to the TGDs to another query that can be evaluated directly on the set of instances, s.t. the answers for the former query and latter query coincides. The approach is called the query rewriting approach. FES classes uses certain termination guarantying tests that check whether certain sufficient conditions are satisfied by the structure of TGDs. A large number of classes in FES are based on tests that detects \u2018acyclicity conditions\u2019 by analyzing the information flow between the TGD rules. Weak acyclicity [13, 11], was one of the first such notions, and was extended to joint acyclicity [24], super weak acyclicity [26], and model faithful acyclicity [9]. The most similar approach to ours is the weak acyclicity technique, where the structure of the rules is analyzed using a dependency graph that models the propagation of constants across various predicates positions, and restricting the dependency graph to be acyclic. Although this technique can be used in our scenario by translating a quad-system to a set of TGDs; if the obtained translation is weakly acyclic, then one could use existing algorithms for\nchase computation for the TGDs to compute the chase, the query entailment check can be done by querying the obtained chase. However, our approach has the advantage of straightforward implementability on existing quad-stores."}, {"heading": "6 Summary and Conclusion", "text": "In this paper, we study the problem of query answering over contextualized RDF knowledge. We show that the problem in general is undecidable, and present a decidable class called context acyclic quad-systems. Table 1 summarizes the main results obtained. We can show that the notion of context acyclicity, introduced in section 4 can be used to extend the currently established tools for contextual reasoning to give support for expressive BRs with conjuction and existentials with decidability guarantees. We view the results obtained in this paper as a general foundation for contextual reasoning and query answering over contextualized RDF knowledge formats such as Quads, and can straightforwardly be used to extend existing Quad stores to encorporate for-all existential BRs of the form (1)."}, {"heading": "A Proofs of Section 3", "text": "Proof (Theorem 1). We show that CCQ entailment is undecidable for unrestricted quadsystems, by showing that the well known undecidable problem of \u201cnon-emptiness of intersection of context-free grammars\u201d is reducible to the CCQ entailment problem.\nGiven an alphabet \u03a3, string w is a sequence of symbols from \u03a3. A language L is a subset of \u03a3\u2217, where \u03a3\u2217 is the set of all strings that can be constructed from the alphabet \u03a3, and also includes the empty string \u01eb. Grammars are machineries that generate a particular language. A grammar G is a quadruple \u3008V, T, S, P \u3009, where V is the set of variables, T , the set of terminals, S \u2208 V is the start symbol, and P is a set of production rules (PR), in which each PR r \u2208 P , is of the form:\nw \u2192 w\u2032\nwhere w,w\u2032 \u2208 {T \u222a V }\u2217. Intuitively application of a PR r of the form above on a string w1, replaces every occurrence of the sequence w in w1 with w\u2032. PRs are applied starting from the start symbol S until it results in a string w, with w \u2208 \u03a3\u2217 or no more production rules can be applied on w. In the former case, we say that w \u2208 L(G), the language generated by grammar G. For a detailed review of grammars, we refer the reader to Harrison et al. [18]. A context-free grammar (CFG) is a grammar, whose set of PRs P , have the following property:\nProperty 1. For a CFG, every PR is of the form v \u2192 w, where v \u2208 V , w \u2208 {T \u222a V }\u2217.\nGiven two CFGs, G1 = \u3008V1, T, S1, P1\u3009 and G2 = \u3008V2, T, S2, P2\u3009, where V1, V2 are the set of variables, T s.t. T \u2229 (V1 \u222a V2) = \u2205 is the set of terminals. S1 \u2208 V1 is the start symbol of G1, and P1 are the set of PRs of the form v \u2192 w, where v \u2208 V , w is a sequence of the form w1...wn, where wi \u2208 V1\u222aT . Similarly s2, P2 is defined. Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [18].\nGiven two CFGs, G1 = \u3008V1, T, S1, P1\u3009 andG2 = \u3008V2, T, S2, P2\u3009, we encode grammars G1, G2 into a quad-system of the form QSc = \u3008Qc, R\u3009, with a single context identifier c. Each PR r = v \u2192 w \u2208 P1 \u222a P2, with w = w1w2w3..wn, is encoded as a BR of the form:\nc : (x1, w1, x2), c : (x2, w2, x3), ..., c : (xn, wn, xn+1) \u2192 c : (x1, v, xn+1) (7)\nwhere x1, .., xn+1 are variables. W.l.o.g. we assume that the set of terminal symbols T is equal to the set of terminal symbols occurring in P1 \u222a P2. For each terminal symbol ti \u2208 T , R contains a BR of the form:\nc : (x,rdf:type, C) \u2192 \u2203y c : (x, ti, y), c : (y,rdf:type, C) (8)\nand Qc contains only the triple:\nc : (a,rdf:type, C)\nWe in the following show that:\nQSc |= \u2203y c : (a, S1, y) \u2227 c : (a, S2, y) \u21d4 L(G1) \u2229 L(G2) 6= \u2205\nClaim. (1) For anyw = t1, ..., tp \u2208 T \u2217, there exists b1, ...bp, s.t. c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp\u22121, tp, bp), c : (bp,rdf:type, C) \u2208 dChase( QSc).\nwe proceed by induction on the \u2016w\u2016.\nbase case suppose if \u2016w\u2016 = 1, then w = ti, for some ti \u2208 T . But Since by construction c : (a, rdf:type, C) \u2208 dChase0(QSc), on which rules of the form (8) is applicable. Hence, there exists an i s.t. dChasei(QSc) contains c : (a, ti, bi), c : (bi,rdf:type, C), for each ti \u2208 T . Hence, the base case. hypothesis for anyw = t1...tp, if \u2016w\u2016 \u2264 p\u2032, then there exists b1, ..., bp, s.t. c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp\u22121, tp, bp), c : (bp, rdf:type, C) \u2208 dChase(QSc). inductive step suppose w = t1...tp+1, with \u2016w\u2016 \u2264 p\u2032 + 1. Since w can be written as w\u2032tp+1, where w\u2032 = t1...tp, and by hypothesis, there exists b1, ..., bp such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp\u22121, tp, bp), c : (bp,rdf:type, C) \u2208 dChase(QSc). Also since rules of the form (8) are applicable on c : (bp, rdf:type, C), and hence produces triples of the form c : (bp, ti, bip+1), c : (b i p+1), rdf:type,\nC), for each ti \u2208 T . Since tp+1 \u2208 T , the claim follows.\nFor a grammar G = \u3008V, T, S, P \u3009, whose start symbol is S, and for any w \u2208 {V \u222a T }\u2217, for some Vj \u2208 V , we denote by Vj \u2192i w, the fact that w was derived from Vj by i production steps, i.e. there exists steps Vj \u2192 r1, ..., ri \u2192 w, which lead to the production of w. For any w, w \u2208 L(G), iff there exists an i s.t. S \u2192i w. For any Vj \u2208 V , we use Vj \u2192\u2217 w to denote the fact that there exists an arbitrary i, s.t. Vj \u2192i w.\nClaim. (2) For any w = t1...tp \u2208 {V \u222a T }\u2217, and for any Vj \u2208 V , if Vj \u2192\u2217 w and there exists b1, ..., bp+1, with c : (b1, t1, b2), ..., c : (bp, tp, bp+1) \u2208 dChase(QSc), then c : (b1, Vj , bp+1) \u2208 dChase(QSc).\nWe prove this by induction on the size of w.\nbase case Suppose \u2016w\u2016 = 1, then w = tk, for some tk \u2208 T . If there exists b1, b2 s.t. c : (b1, tk, b2). But since there exists a PR Vj \u2192 tk, by transformation given in (7), there exists a BR c : (x1, tk, x2) \u2192 c : (x1, Vj , x2) \u2208 R, which is applicable on c : (b1, tk, b2) and hence the quad c : (b1, Vj , b2) \u2208 dChase(QSc). hypothesis For any w = t1...tp, with \u2016w\u2016 \u2264 p\u2032, and for any Vj \u2208 V , if Vj \u2192\u2217 w and there exists b1, ...bp, bp+1, s.t. c : (b1, t1, b2), ..., c : (bp, tp, bp+1) \u2208 dChase(QSc), then c : (b1, Vj , bp+1) \u2208 dChase(QSc). inductive step Suppose if w = t1...tp+1, with \u2016w\u2016 \u2264 p\u2032 +1, and Vj \u2192i w, and there exists b1, ...bp+1, bp+2, s.t. c : (b1, t1, b2), ..., c : (bp+1, tp+1, bp+2) \u2208 dChase(Qc). Also, one of the following holds (i) i = 1, or (ii) i > 1. Suppose (i) is the case, then it is trivially the case that c : (b1, Vj , bp+2) \u2208 dChase(QSc). Suppose if (ii) is the case, one of the two sub cases holds (a) Vj \u2192i\u22121 Vk, for some Vk \u2208 V and Vk \u21921 w or (b) there exist a Vk \u2208 V , s.t. Vk \u2192\u2217 tq+1...tq+l, with 2 \u2264 l \u2264 p, where Vj \u2192\u2217 t1...tqVktp\u2212l+1...tp+1. If (a) is the case, trivially then c : (b1, Vk, bq+2) \u2208 dChase(QSc), and since by construction there exists c : (x0, Vk, x1) \u2192 c : (x0, Vk+1, x1), ..., c : (x0, Vk+i, x1) \u2192 c : (x0, Vj , x1) \u2208 R, c : (b1, Vj , bq+2) \u2208 dChase(QSc). If (b) is the case, then since \u2016tq+1...tq+l\u2016 \u2265 2, \u2016t1...tqV2tp\u2212l+1...tp+1\u2016 \u2264 p\u2032. This implies that c : (b1, Vj , bp+2) \u2208 dChase(QSc).\nSimilarly, by construction of dChase(QSc), the following claim can straightforwardly be shown to hold:\nClaim. (3) For any w = t1...tp \u2208 {V \u222a T }\u2217, and for any Vj \u2208 V , if there exists b1, ..., bp, bp+1, with c : (b1, t1, b2), ..., c : (bp, tp, bp+1) \u2208 dChase(QSc) and c : (b1, Vj , bp+1) \u2208 dChase(QSc), then Vj \u2192\u2217 w.\n(a) For any w = t1...tp \u2208 T \u2217, if w \u2208 L(G1) \u2229 L(G2), then by claim 1, since there exists b1, ..., bp, s.t. c : (a, t1, b1), ..., c : (bp\u22121, tp, bp) \u2208 dChase(QSc). But since w \u2208 L(G1) andw \u2208 L(G2), S1 \u2192 w and S2 \u2192 w. Hence by claim 2, c : (a, S1, bp), c : (a, S2, bp) \u2208 dChase(QSc), which implies that dChase(QSc) |= \u2203y c : (a, s1, y) \u2227 c : (a, s2, y). Hence, QSc |= \u2203y c : (a, s1, y) \u2227 c : (a, s2, y). (b) Suppose if QSc |= \u2203y c : (a, S1, y) \u2227 c : (a, S2, y), then this implies that there exists bp s.t. c : (a, S1, bp), c : (a, S2, bp) \u2208 dChase(QSC). Then it is the case that there exists w = t1...tp \u2208 T \u2217, and b1, ..., bp s.t. c : (a, t1, b1), ..., c : (bp\u22121, tp, bp), c : (a, S1, bp), c : (a, S2, bp) \u2208 dChase(QSc). Then by claim 3, S1 \u2192\u2217 w, S2 \u2192\u2217 w. Hence, w \u2208 L(G1) \u2229 L(G2).\nBy (a),(b) it follows that there exists w \u2208 L(G1)\u2229L(G2) iffQSc |= \u2203y c : (a, s1, y)\u2227 c : (a, s2, y). As we have shown that the intersection of CFGs, which is an undecidable problem, is reducible to the problem of query entailment on unrestricted quad-system, the latter is undecidable."}, {"heading": "B Proofs of Section 4", "text": "Proof (Theorem 2). (i) (Membership) See lemma 4 for the membership in PTIME. (Hardness) In order to prove P-hardness, we reduce a well known P-complete problem, 3HornSat, i.e. the satisfiability of propositional Horn formulas with at most 3 literals. Note that a (propositional) Horn formula is formula of the form:\nP1 \u2227 . . . \u2227 Pn \u2192 Pn+1 (9)\nwhere Pi, for 1 \u2264 i \u2264 n + 1, are either propositional variables or constants t, f , that represents true and false, respectively. Note that for any propositional variable P , the fact that \u201cP holds\u201d is represented by the formula t \u2192 P , and \u201cP does not hold\u201d is represented by the formula P \u2192 f . A 3Horn formula is a formula of the form (9), where 1 \u2264 n \u2264 2. Note that any (set of) Horn formula(s) \u03a6 can be transformed in polynomial time to a polynomially sized set \u03a6\u2032 of 3Horn formulas, by introducing auxiliary propositional variables s.t. \u03a6 is satisfiable iff \u03a6\u2032 is satisfiable. A pure 3Horn formula is 3Horn formula of the form 9, where n = 2. Any 3Horn formula \u03c6 that is not pure can be trivially converted to equivalent pure form by appending a \u2227 t on the head part of \u03c6. For instance, P \u2192 Q, can be converted to P \u2227 t \u2192 Q. Hence, w.l.o.g. we assume that any set of 3Horn formulas is pure, and is of the form:\nP1 \u2227 P2 \u2192 P3 (10)\nWe, in the following, reduce the satisfiability problem of pure 3Horn formulas to CCQ entailment problem over a quad-system whose set of schema triples, the set of BRs, and the CCQ CQ are all fixed.\nFor any set of pure Horn formulas\u03a6, we construct the quad-systemQSC = \u3008QC , R\u3009, where C = {ct, cf}. For any formula \u03c6 \u2208 \u03a6 of the form (10), QC contains a quad cf : (P1, P2, P3). In addition QC contains a quad ct : (t, rdf:type, T ). R is the singleton that contains only the following fixed BR:\nct : (x1,rdf:type, T ), ct : (x2,rdf:type, T ), cf : (x1, x2, x3) \u2192 ct : (x3,\nrdf:type, T )\nLet the CQ be the fixed query ct(f,rdf:type, T ). Now, it is easy to see that QSC |= CQ, iff \u03a6 is not satisfiable. (ii) (Membership) See lemma 4. (Hardness) See following heading. \u2293\u2294\n2EXPTIME-Hardness of CCQ Entailment In this subsection, we show that the combined complexity of the decision problem of CCQ entailment for context acyclic quadsystems is 2EXPTIME-hard. We show this by reduction of the word-problem of a 2EXPTIME deterministic turing machine (DTM) to the CCQ entailment problem. A DTM M is a tuple M = \u3008Q,\u03a3,\u2206, q0, qA\u3009, where\n\u2013 Q is a set of states, \u2013 \u03a3 is a finite alphabet that includes the blank symbol , \u2013 \u2206 : (Q \u00d7\u03a3) \u2192 (Q\u00d7\u03a3 \u00d7 {+1,\u22121}) is the transition function, \u2013 q0 \u2208 Q is the initial state. \u2013 qA \u2208 Q is the accepting state.\nW.l.o.g. we assume that there exists exactly one accepting state, which is also a halting state. A configuration is a word \u03b1 \u2208 \u03a3\u2217Q\u03a3\u2217. A configuration \u03b12 is a successor of the configuration \u03b11, iff one of the following holds:\n1. \u03b11 = wlq\u03c3\u03c3rwr and \u03b12 = wl\u03c3\u2032q\u2032\u03c3rwr, if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, R), or 2. \u03b11 = wlq\u03c3 and \u03b12 = wl\u03c3\u2032q\u2032 , if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, R), or 3. \u03b11 = wl\u03c3lq\u03c3wr and \u03b12 = wlq\u2032\u03c3l\u03c3\u2032wr, if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, L).\nwhere q, q\u2032 \u2208 Q, \u03c3, \u03c3\u2032, \u03c3l, \u03c3r \u2208 \u03a3, and wl,wr \u2208 \u03a3\u2217. Since number of configurations can at most be doubly exponential in the size of the input string, the number of tape cells traversed by the DTM tape head is also bounded double exponentially. A configuration c = wlqwr is an accepting configuration iff q = qA. A language L \u2286 \u03a3\u2217 is accepted by a 2EXPTIME bounded DTM M , iff for every w \u2208 L, M accepts w in time O(22 \u2016w\u2016 ).\nSimulating DTMs using Context Acyclic Quad-Systems Consider a DTM M = \u3008Q,\u03a3,\u2206, q0, qA\u3009, and a string w, with \u2016w\u2016 = n. Since the number of storage cells is double exponentially bounded, we first construct a quad-system QSMC = \u3008Q M C , R\u3009,\nwhere C = {c1, ..., cn}, with n = \u2016w\u2016. We follow the technique in works such as [6, 24] to iteratively generate a doubly exponential number of objects that represent the cells of the tape of the DTM. Let QMC be initialized with the following quads:\nc0 : (k0,rdf:type, R), c0 : (k1,rdf:type, R),\nc0 : (k0,rdf:type,min0), c0 : (k1,rdf:type,max0), c0 : (k0, succ0, k1)\nNow for each pair of elements of type R in ci, a skolem blank-node is generated in ci+1, and hence follows the recurrence relation r(m + 1) = [r(m)]2, with seed r(1) = 2, which after n iterations yields 22 n\n. In this way, a doubly exponential long chain of elements is created in cn using the following set of rules:\nci : (x0,rdf:type, R), ci : (x1,rdf:type, R) \u2192\n\u2203y ci+1 : (x0, x1, y), ci+1 : (y,rdf:type, R)\nThe combination of minimal element with the minimal element (elements of typemini) in ci create the minimal element in ci+1, and similarly the combination of maximal element with the maximal element (elements of type maxi) in ci create the maximal element of ci+1\nci+1 : (x0, x0, x1), ci : (x0,rdf:type,mini) \u2192 ci+1 : (x1,rdf:type,mini+1)\nci+1 : (x0, x0, x1), ci : (x0,rdf:type,maxi) \u2192 ci+1 : (x1,rdf:type,maxi+1)\nSuccessor relation succi+1 is created in ci+1 using the following set of rules, using the well-known, integer counting technique:\nci : (x1, succi, x2), ci+1 : (x0, x1, x3), ci+1 : (x0, x2, x4) \u2192 ci+1 : (x3, succi+1, x4)\nci : (x1, succi, x2), ci+1 : (x1, x3, x5), ci+1 : (x2, x4, x6), ci : (x3,rdf:type,maxi),\nci : (x4,rdf:type,mini) \u2192 ci+1 : (x5, succi+1, x6)\nEach of the above set rules are instantiated for 0 \u2264 i < n, and in this way after n generating dChase iterations, cn has doubly exponential number of elements of type R, that are ordered linearly using the relation succn. By virtue of the first rule below, each of the objects representing the cells of the DTM are linearly ordered by the relation succ. Also the transitive closure of succ is defined as the relation relation succt\ncn : (x0, succn, x1) \u2192 cn : (x0, succ, x1)\ncn : (x0, succ, x1) \u2192 cn : (x0, succt, x1)\ncn : (x0, succt, x1), cn : (x1, succt, x2) \u2192 cn : (x0, succt, x2)\nAlso using a similar construction, we could create a linearly ordered chain of double exponential number of objects in cn that represents configurations of M , whose minimal element is of type conInit, and the linear order relation being conSucc.\nVarious triple patterns that are used to encode the possible configurations, runs and their relations in M are:\n(x0, head, x1) denotes the fact that in configuration x0, the head of the DTM is at cell x1. (x0, state, x1) denotes the fact that in configuration x0, the DTM is in state x1. (x0, \u03c3, x1) where \u03c3 \u2208 \u03a3, denotes the fact that in configuration x0, the cell x1 contains\n\u03c3. (x0, succ, x1) denotes the linear order between cells of the tape. (x0, succt, x1) denotes the transitive closure of succ. (x0, conSucc, x1) to denote the fact that x1 is a successor configuration of x0. (x0,rdf:type, Accept) denotes the fact that the configuration x0 is an accepting\nconfiguration.\nSince in our construction, each \u03c3 \u2208 \u03a3 is represented as relation, we could constrain that no two alphabets \u03c3 6= \u03c3\u2032 are on the same cell using the following axiom:\ncn : (z1, \u03c3, z2), cn : (z1, \u03c3 \u2032, z2) \u2192\nfor each \u03c3 6= \u03c3\u2032 \u2208 \u03a3. Note that the above BR has an empty head, is equivalent to asserting the negation of its body.\nInitialization Suppose the initial configuration is q0w , where w = \u03c30...\u03c3n\u22121, then we enforce this using the following BRs in our quad-system QSMC as:\ncn : (x0,rdf:type, conInit), cn : (x1,rdf:type,minn) \u2192 cn : (x0, head, x1),\ncn : (x0, state, q0)\ncn : (x0,rdf:type,minn) \u2227 n\u22121 \u2227\ni=0\ncn : (xi, succ, xi+1) \u2227 cn : (xj ,rdf:type,\nconInit) \u2192 n\u22121 \u2227\ni=0\ncn : (xj , \u03c3i, xi) \u2227 cn : (xj , , xn)\ncn : (xj ,rdf:type, conInit), cn : (xj , , x0), cn : (x0, succt, x1) \u2192 cn : (xj , , x1)\nThe last BR copies the to every succeeding cell in the initial configuration.\nTransitions For every left transition \u2206(q, \u03c3) = (qj , \u03c3\u2032,\u22121), the following BR:\ncn : (x0, head, xi), cn : (x0, \u03c3, xi), cn : (x0, state, q), cn : (xj , succ, xi), cn : (x0, conSucc, x1) \u2192 cn : (x1, head, xj), cn : (x1, \u03c3 \u2032, xi), cn : (x1, state, qj)\nFor every right transition \u2206(q, \u03c3) = (qj , \u03c3\u2032,+1), the following BR:\ncn : (x0, head, xi), cn : (x0, \u03c3, xi), cn : (x0, state, q), cn : (xi, succ, xj), cn : (x0, conSucc, x1),\u2192 cn : (x1, head, xj), cn : (x1, \u03c3 \u2032, xi), cn : (x1, state, qj)\nInertia If in any configuration the head is at cell i of the tape, then in every successor configuration, elements in preceding and following cells of i in the tape are retained. The following two BRs ensures this:\ncn : (x0, head, xi), cn : (x0, conSucc, x1), cn : (xj , succt, xi), cn : (x0, \u03c3, xj)\n\u2192 cn : (x1, \u03c3, xj)\ncn : (x0, head, xi), cn : (x0, conSucc, x1), cn : (xi, succt, xj), cn : (x0, \u03c3, xj)\n\u2192 cn : (x1, \u03c3, xj)\nThe rules above are instantiated for every \u03c3 \u2208 \u03a3.\nAcceptance An configuration whose state is qA is accepting:\ncn : (x0, state, qA) \u2192 cn : (x0,rdf:type, Accept)\nIf a configuration of accepting type is reached, then it can be back propagated to the initial configuration, using the following BR:\ncn : (x0, conSucc, x1), cn : (x1,rdf:type, Accept) \u2192 cn : (x0,rdf:type, Accept)\nFinally since M accepts w iff the initial configuration is an accepting configuration, i.e. QSMC |= \u2203y cn : (y,rdf:type, conInit), cn : (y,rdf:type, Accept). Since there is no edge from any cj to ci, for each 1 \u2264 i < j \u2264 n, the context dependency graph for QSMC is acyclic, and hence QS M C is context acyclic. Since we reduced the word problem of 2EXPTIME DTM, which is a 2EXPTIME-hard problem, to CCQ entailment problem over context acyclic quad-systems, it immediately follows that CCQ entailment problem over context acyclic quad-systems is 2EXPTIME-hard. \u2293\u2294"}], "references": [{"title": "Foundations of Databases", "author": ["S. Abiteboul", "R. Hull", "V. Vianu"], "venue": "Addison-Wesley", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "Walking the Complexity Lines for Generalized Guarded Existential Rules", "author": ["J. Baget", "M. Mugnier", "S. Rudolph", "M. Thomazo"], "venue": "IJCAI. pp. 712\u2013717", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "The Implication Problem for Data Dependencies", "author": ["C. Beeri", "M.Y. Vardi"], "venue": "ICALP. pp. 73\u201385", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1981}, {"title": "Distributed Description Logics: Assimilating Information from Peer Sources", "author": ["A. Borgida", "L. Serafini"], "venue": "J. Data Semantics 1, 153\u2013184", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "C-OWL: Contextualizing Ontologies", "author": ["P. Bouquet", "F. Giunchiglia", "F. van Harmelen", "L. Serafini", "H. Stuckenschmidt"], "venue": "ISWC. pp. 164\u2013179", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2003}, {"title": "Query Answering under Non-guarded Rules in Datalog+/", "author": ["A. Cal\u0131\u0300", "G. Gottlob", "A. Pieris"], "venue": "Hitzler, P., Lukasiewicz, T. (eds.) RR. Lecture Notes in Computer Science, vol. 6333, pp. 1\u201317. Springer", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "Datalog+/-: A Family of Logical Knowledge Representation and Query Languages for New Applications", "author": ["A. Cali", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris"], "venue": "Logic in Computer Science (LICS), 2010 25th Annual IEEE Symposium on. pp. 228 \u2013242", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2010}, {"title": "Named graphs, provenance and trust", "author": ["J. Carroll", "C. Bizer", "P. Hayes", "P. Stickler"], "venue": "Proc. of the 14th int.l. conf. on WWW. pp. 613\u2013622. ACM, New York, NY, USA", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "Acyclicity Conditions and their Application to Query Answering in Description Logics", "author": ["B. Cuenca Grau", "I. Horrocks", "M. Kr\u00f6tzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang"], "venue": "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201912). pp. 243\u2013253. AAAI Press", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "The chase revisited", "author": ["A. Deutsch", "A. Nash", "J. Remmel"], "venue": "Proceedings of the twentyseventh ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems. pp. 149\u2013158. PODS \u201908", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2008}, {"title": "Reformulation of XML Queries and Constraints", "author": ["A. Deutsch", "V. Tannen"], "venue": "In ICDT. pp. 225\u2013241", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2003}, {"title": "Data Exchange: Semantics and Query Answering", "author": ["R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa"], "venue": "Theoretical Computer Science. pp. 28(1):89\u2013124", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "Distributed first order logics", "author": ["C. Ghidini", "L. Serafini"], "venue": "Frontiers Of Combining Systems 2, Studies in Logic and Computation. pp. 121\u2013140. Research Studies Press", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1998}, {"title": "Local models semantics, or contextual reasoning = locality + compatibility", "author": ["F. Giunchiglia", "C. Ghidini"], "venue": "Artificial Intelligence 127", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2001}, {"title": "Answering conjunctive queries in the SHIQ description logic", "author": ["B. Glimm", "C. Lutz", "I. Horrocks", "U. Sattler"], "venue": "Proceedings of the IJCAI\u201907. pp. 299\u2013404. AAAI Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2007}, {"title": "Polynomial Combined Rewritings for Existential Rules", "author": ["G. Gottlob", "M. Manna", "A. Pieris"], "venue": "KR\u201914: International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "Introduction to Formal Language Theory", "author": ["M.A. Harrison"], "venue": "Addison-Wesley Longman Publishing Company, Inc., Boston, MA, USA, 1st edn.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1978}, {"title": "Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary", "author": ["H.J. ter Horst"], "venue": "Web Semantics: Science, Services and Agents on the WWW 3(2-3), 79\u2013115", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2005}, {"title": "Generality in AI", "author": ["J.McCarthy"], "venue": "Comm. of the ACM 30(12), 1029\u20131035", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1987}, {"title": "Testing containment of conjunctive queries under functional and inclusion dependencies", "author": ["D.S. Johnson", "A.C. Klug"], "venue": "Computer and System Sciences 28, 167\u2013189", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1984}, {"title": "Simple reasoning for contextualized RDF knowledge", "author": ["M. Joseph", "L. Serafini"], "venue": "Proc. of Workshop on Modular Ontologies (WOMO-2011)", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "Extending decidable existential rules by joining acyclicity and guardedness", "author": ["M. Kr\u00f6tzsch", "S. Rudolph"], "venue": "Walsh, T. (ed.) Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI\u201911). pp. 963\u2013968. AAAI Press/IJCAI", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2011}, {"title": "E-Connections of Abstract Description Systems", "author": ["O. Kutz", "C. Lutz", "F. Wolter", "M. Zakharyaschev"], "venue": "Artificial Intelligence 156(1), 1\u201373", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2004}, {"title": "Generalized schema-mappings: from termination to tractability", "author": ["B. Marnette"], "venue": "Proceedings of the twenty-eighth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems. pp. 13\u201322. PODS \u201909, ACM, New York, NY, USA", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2009}, {"title": "Formalizing Context (Expanded Notes", "author": ["J. McCarthy", "S. Buvac", "T. Costello", "R. Fikes", "M. Genesereth", "F. Giunchiglia"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1995}, {"title": "Contexts: a Formalization and some Applications", "author": ["R.Guha"], "venue": "Ph.D. thesis, Stanford", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1992}, {"title": "Contextualized knowledge repositories for the semantic web", "author": ["L. Serafini", "M. Homola"], "venue": "Web Semantics: Science, Services and Agents on the World Wide Web", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 7, "context": "One of the main benefits of quads over triples are that they allow users to specify various attributes of meta-knowledge that further qualify knowledge [8], and also allow users to query for this meta knowledge [29].", "startOffset": 152, "endOffset": 155}, {"referenceID": 3, "context": "Besides the above flexibility, bridge rules [4] can be provided for inter-interoperating the knowledge in different contexts.", "startOffset": 44, "endOffset": 47}, {"referenceID": 3, "context": "In this work, we consider forall-existential bridge rules that allows conjunctions and existential quantifiers in them, and hence is more expressive than those, in DDL [4] and McCarthy et al.", "startOffset": 168, "endOffset": 171}, {"referenceID": 24, "context": "[27].", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "For query answering, we use the notion of a distributed chase, which is an extension of a standard chase [22, 1] that is widely used in databases and KR for the same.", "startOffset": 105, "endOffset": 112}, {"referenceID": 0, "context": "For query answering, we use the notion of a distributed chase, which is an extension of a standard chase [22, 1] that is widely used in databases and KR for the same.", "startOffset": 105, "endOffset": 112}, {"referenceID": 17, "context": "Some of the alternatives for the local semantics satisfying the above mentioned criterion are Simple, RDF, RDFS [19], OWL-Horst [20] etc.", "startOffset": 128, "endOffset": 132}, {"referenceID": 19, "context": "dChase of a Quad-System In order to do query answering over a quad-system, we employ what has been called in the literature, a chase [22, 1], specifically, we adopt notion of the skolem chase given in Marnette [26] and Cuenca Grau et al [9].", "startOffset": 133, "endOffset": 140}, {"referenceID": 0, "context": "dChase of a Quad-System In order to do query answering over a quad-system, we employ what has been called in the literature, a chase [22, 1], specifically, we adopt notion of the skolem chase given in Marnette [26] and Cuenca Grau et al [9].", "startOffset": 133, "endOffset": 140}, {"referenceID": 23, "context": "dChase of a Quad-System In order to do query answering over a quad-system, we employ what has been called in the literature, a chase [22, 1], specifically, we adopt notion of the skolem chase given in Marnette [26] and Cuenca Grau et al [9].", "startOffset": 210, "endOffset": 214}, {"referenceID": 8, "context": "dChase of a Quad-System In order to do query answering over a quad-system, we employ what has been called in the literature, a chase [22, 1], specifically, we adopt notion of the skolem chase given in Marnette [26] and Cuenca Grau et al [9].", "startOffset": 237, "endOffset": 240}, {"referenceID": 9, "context": "The dChase dChase(QSC) of a consistent quad-system QSC is a universal model [10] of the quad-system, i.", "startOffset": 76, "endOffset": 80}, {"referenceID": 14, "context": "[16] provides an algorithm for CQ entailment based on query rewriting.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [18].", "startOffset": 127, "endOffset": 131}, {"referenceID": 11, "context": "It should be noted that the technique we propose is reminiscent of the Weak acyclicity [13, 11] technique used in the realm of Datalog+-.", "startOffset": 87, "endOffset": 95}, {"referenceID": 10, "context": "It should be noted that the technique we propose is reminiscent of the Weak acyclicity [13, 11] technique used in the realm of Datalog+-.", "startOffset": 87, "endOffset": 95}, {"referenceID": 18, "context": "Contexts and Distributed Logics The work on contexts began in the 80s when McCarthy [21] proposed context as a solution to the generality problem in AI.", "startOffset": 84, "endOffset": 88}, {"referenceID": 25, "context": "After this various studies about logics of contexts mainly in the field of KR was done by Guha [28], Distributed First Order Logics by Ghidini et al.", "startOffset": 95, "endOffset": 99}, {"referenceID": 12, "context": "[14] and Local Model Semantics by Giunchiglia et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[15].", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "Some of the initial works on contexts relevant to semantic web were the ones like Distributed Description Logics [4] by Borgida et al.", "startOffset": 113, "endOffset": 116}, {"referenceID": 22, "context": ", E-connections [25] by Kutz et al.", "startOffset": 16, "endOffset": 20}, {"referenceID": 4, "context": ", Context-OWL [5] by Bouqet et al.", "startOffset": 14, "endOffset": 17}, {"referenceID": 26, "context": ", and the work of CKR [30, 23] by Serafini et al.", "startOffset": 22, "endOffset": 30}, {"referenceID": 20, "context": ", and the work of CKR [30, 23] by Serafini et al.", "startOffset": 22, "endOffset": 30}, {"referenceID": 2, "context": "\u2200\u2203 rules, TGDs, Datalog+- rules Query answering over rules with universal existential quantifiers in the context of databases/KR, where these rules are called tuple generating dependencies (TGDs)/Datalog+- rules, was done by Beeri and Vardi [3] even in the early 80s, where the authors show that the query entailment problem in general is undecidable.", "startOffset": 241, "endOffset": 244}, {"referenceID": 6, "context": "the resulting models have bounded tree widths, called bounded treewidth sets (BTS), such as Weakly guarded rules [7], Frontier guarded rules [2], (b) fragments called finite unification sets (FUS), such as \u2018sticky\u2019 rules [6, 17], and (c) fragments called finite extension sets (FES), where sufficient conditions are enforced to ensure finiteness of the chase and its termination.", "startOffset": 113, "endOffset": 116}, {"referenceID": 1, "context": "the resulting models have bounded tree widths, called bounded treewidth sets (BTS), such as Weakly guarded rules [7], Frontier guarded rules [2], (b) fragments called finite unification sets (FUS), such as \u2018sticky\u2019 rules [6, 17], and (c) fragments called finite extension sets (FES), where sufficient conditions are enforced to ensure finiteness of the chase and its termination.", "startOffset": 141, "endOffset": 144}, {"referenceID": 5, "context": "the resulting models have bounded tree widths, called bounded treewidth sets (BTS), such as Weakly guarded rules [7], Frontier guarded rules [2], (b) fragments called finite unification sets (FUS), such as \u2018sticky\u2019 rules [6, 17], and (c) fragments called finite extension sets (FES), where sufficient conditions are enforced to ensure finiteness of the chase and its termination.", "startOffset": 221, "endOffset": 228}, {"referenceID": 15, "context": "the resulting models have bounded tree widths, called bounded treewidth sets (BTS), such as Weakly guarded rules [7], Frontier guarded rules [2], (b) fragments called finite unification sets (FUS), such as \u2018sticky\u2019 rules [6, 17], and (c) fragments called finite extension sets (FES), where sufficient conditions are enforced to ensure finiteness of the chase and its termination.", "startOffset": 221, "endOffset": 228}, {"referenceID": 11, "context": "Weak acyclicity [13, 11], was one of the first such notions, and was extended to joint acyclicity [24], super weak acyclicity [26], and model faithful acyclicity [9].", "startOffset": 16, "endOffset": 24}, {"referenceID": 10, "context": "Weak acyclicity [13, 11], was one of the first such notions, and was extended to joint acyclicity [24], super weak acyclicity [26], and model faithful acyclicity [9].", "startOffset": 16, "endOffset": 24}, {"referenceID": 21, "context": "Weak acyclicity [13, 11], was one of the first such notions, and was extended to joint acyclicity [24], super weak acyclicity [26], and model faithful acyclicity [9].", "startOffset": 98, "endOffset": 102}, {"referenceID": 23, "context": "Weak acyclicity [13, 11], was one of the first such notions, and was extended to joint acyclicity [24], super weak acyclicity [26], and model faithful acyclicity [9].", "startOffset": 126, "endOffset": 130}, {"referenceID": 8, "context": "Weak acyclicity [13, 11], was one of the first such notions, and was extended to joint acyclicity [24], super weak acyclicity [26], and model faithful acyclicity [9].", "startOffset": 162, "endOffset": 165}], "year": 2014, "abstractText": "The recent outburst of context-dependent knowledge on the Semantic Web (SW) has led to the realization of the importance of the quads in the SW community. Quads, which extend a standard RDF triple, by adding a new parameter of the \u2018context\u2019 of an RDF triple, thus informs a reasoner to distinguish between the knowledge in various contexts. Although this distinction separates the triples in an RDF graph into various contexts, and allows the reasoning to be decoupled across various contexts, bridge rules need to be provided for inter-operating the knowledge across these contexts. We call a set of quads together with the bridge rules, a quad-system. In this paper, we discuss the problem of query answering over quad-systems with expressive forall-existential bridge rules. It turns out the query answering over quad-systems is undecidable, in general. We derive a decidable class of quad-systems, namely context-acyclic quadsystems, for which query answering can be done using forward chaining. Tight bounds for data and combined complexity of query entailment has been established for the derived class.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}