{"id": "1411.1490", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Nov-2014", "title": "Efficient Representations for Life-Long Learning and Autoencoding", "abstract": "catchall It has pouted been a long - aidarov standing amphipods goal brenda in machine learning, riess as well poundstone as 108.48 in AI more higher-ups generally, to develop dadi life - memorializing long iambic learning patterned systems tahreek that counter-intuitive learn illustre many different euptera tasks beatdown over sophistic time, zarzis and reuse kreeger insights from tasks 1936-37 learned, \" learning to kajura learn \" as they do so. In brookner this work 1,041 we l'\u00e9nergie pose and provide vitantonio efficient algorithms for several natural nalapat theoretical formulations of costcutter this amethysts goal. vaguest Specifically, we helicia consider 300,000-plus the nbc-affiliated problem of .604 learning many different target functions over air-to-air time, yeronga that lonna share 1.286 certain commonalities that zainuri are stann initially unknown to thumbed the 6-55 learning voltage-gated algorithm. saharicus Our aim is to learn sedova new internal representations as aktar the gastroliths algorithm freewheel learns new metromix target functions, kulwicki that yalda capture 68-69 this waives commonality menk and allow minamoto subsequent learning prosthetic tasks to 1939-1942 be formicinae solved bumpers more hauke efficiently and condescending from columellar less data. gptv We semmangudi develop r36 efficient sedat algorithms for two halman very oppositionists different marians kinds op\u00e9ra of commonalities ciccio that genge target 3.64 functions plexicushion might jacq share: one based on badang learning wateringbury common low - dimensional bienveillantes and inattentiveness unions of lizza low - dimensional subspaces trinitarianism and one based forgetting on shockwaves learning nonlinear satyanarayan Boolean co-existed combinations universiades of baripada features. headcovering Our hubie algorithms for habibiya learning katra Boolean feature gyeongsangnam-do combinations pistolero additionally 39.16 have 46sec a sannidhi dual interpretation, and can natan be viewed as whiteness giving an zu efficient procedure ooty for eychaner constructing near - originations optimal tzur sparse single-tier Boolean pangaribuan autoencoders wicklow under a natural \" anchor - fernet set \" assumption.", "histories": [["v1", "Thu, 6 Nov 2014 03:51:39 GMT  (24kb)", "https://arxiv.org/abs/1411.1490v1", null], ["v2", "Thu, 4 Dec 2014 22:59:04 GMT  (51kb,D)", "http://arxiv.org/abs/1411.1490v2", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["maria-florina balcan", "avrim blum", "santosh vempala"], "accepted": false, "id": "1411.1490"}, "pdf": {"name": "1411.1490.pdf", "metadata": {"source": "CRF", "title": "Efficient Representations for Life-Long Learning and Autoencoding", "authors": ["Maria-Florina Balcan", "Avrim Blum"], "emails": ["ninamf@cs.cmu.edu", "avrim@cs.cmu.edu", "vempala@cc.gatech.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 1.\n14 90\nv2 [\ncs .L\nG ]\n4 D\nec 2\n01 4"}, {"heading": "1 Introduction", "text": "Machine learning has developed a deep mathematical understanding as well as powerful practical methods for the problem of learning a single target function from large amounts of labeled data. Yet if we wish to produce machine learning systems that persist in the world, we need methods for continually learning many tasks over time and that, like humans [13], improve their ability to learn as they do so, needing less data (per task) as they learn more. A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist. These commonalities could be a single low-dimensional or sparse representation, a collection of multiple low-dimensional or sparse representations, or some combination or hierarchy, such as in Deep Learning [9, 10]. In this paper, we develop algorithms with provable efficiency and sample size guarantees for several interesting categories of commonalities, considering both linear and Boolean transfer functions, under natural distributions on the data points.\nSpecifically, we consider a setting where we are trying to solve a large number of binary classification problems that arrive one at a time. Each classification problem will individually be learnable from a polynomialsize sample,1 but our goal will be to learn new internal representations that will allow us to learn new target functions faster and from less data. We will furthermore aim to do this in a streaming setting in which we cannot keep the labeled data for problem t in memory when we move on to problem t+ 1, only the learned hypotheses (which will be required to have a compact description) and the current internal representation.\nWe start by considering a conceptually simple case that each classification problem is a linear separator, and that what their associated target vectors share in common is they lie in a low k dimensional subspace of the ambient space <n (equivalently, there exist a small number of hidden linear metafeatures and each target is a linear separator over these metafeatures). This case has been considered in the \u201cbatch\u201d setting in which one has data available for all target functions at the same time and therefore can solve a joint optimization problem [1, 19]. However, for the online setting, a key challenge is that we won\u2019t have perfectly learned the previous target functions when we set out to learn our next one.2 For this problem we provide a sampleefficient polynomial time algorithm that, when the underlying data distributions for ourm learning problems are log-concave, has labeled sample complexity much better than the \u2126(nm/ ) sample complexity required for learning the tasks separately.\nWe then consider scenarios where the commonalities require a representation with more than one level of metafeatures and provide efficient algorithms for these settings as well. For linear metafeatures, we provide a natural framework where two levels of metafeatures can be efficiently extracted and provide substantial benefit: specifically, we analyze a scenario where the target functions all lie in a k dimensional space and furthermore within that k-dimensional space, each target lies in one of r different constant dimensional spaces, where r could be large. This models situations where there are really r different types of learning problems but they do share some commonalities across types (given by a low k-dimensional subspace).\nIn Section 4 we develop algorithms for a scenario where the metafeatures are non-linear, in particular where features are boolean and the metafeatures are products. We give an efficient algorithm for finding the fewest product-based metafeatures for a given set of target monomials under an \u201canchor-variable\u201d assumption analogous to the anchor-word assumption of [2], and prove bounds on its performance for learning a series of target functions arriving online. We then give an extension that learns an approximately-optimal overcomplete sparse representation (we may have more metafeatures than input features, but each target should have a sparse representation) under a weaker form of assumption we call the \u201canchor-set\u201d assumption (anchor\n1Except in Section 5 where we consider learning multivariate polynomials and allow membership queries. 2In particular, because of this we will need to be particularly careful with which targets we use in constructing our metafeatures,\nas well as in controlling the propagation of errors. See, e.g., Lemma 3 and Figure 1.\nvariables no longer make sense in the overcomplete case). These results can be viewed as giving efficient algorithms for a Boolean autoencoding where given a set of black-and-white pixel images (vectors in {0, 1}n) we want to find either (a) the fewest \u201cbasic objects\u201d (also vectors in {0, 1}n) such that each given image can be reconstructed by superimposing some subset of them (taking their bitwise-OR), or (b) a larger number of such objects such that each image can be reconstructed by superimposing only a few of them. In the first case our algorithm finds the optimal solution under the anchor-variable assumption (the problem is NP-hard in general) and in the second case it finds a bicriteria approximation (for a given sparsity level, approximates both the number and the sparsity to logarithmic factors) under the weaker anchor-set assumption.\nIn Section 5 we show how our results can be applied to the case that target functions are polynomials of low L1 norm whose terms share pieces in common (within and across polynomials), a scenario that can be expressed via two levels of product-based metafeatures. Interestingly, as opposed to the algorithms for linear metafeatures, this algorithm periodically re-compactifies its current representation. In particular, whenever a new polynomial cannot be learned using the current representation and must be learned from scratch, we then revisit the previously-learned polynomials and optimally \u201ccompactify\u201d them into the fewest number of (possibly overlapping) conjunctive metafeatures that can be used to recreate all their monomials."}, {"heading": "1.1 Related Work", "text": "Most related work in multi-task or transfer learning considers the case that all target functions are present simultaneously or that target functions are drawn from some easily learnable distribution. Baxter [7, 6] developed some of the earliest foundations for transfer learning, by providing sample complexity results for achieving low average error in such settings. Other related sample complexity results appear in [8].\nRecent work of [19, 16] considers the problem of learning multiple linear separators that share a common low-dimensional subspace in the batch setting where all tasks are given up front. They specifically provide guarantees for a natural ERM algorithm with trace norm regularization. There has also been work on applying the Group Lasso method to batch multi-task learning which solves a specific multi-task optimization problem [20]. By contrast with these results, our setting is more demanding since we aim to achieve small error on all tasks and to do so online without keeping all training data from past learning tasks in memory.\n[11] considers multi-task learning where explicit known relationships among tasks are exploited for faster learning. In their setting each learning problem is an online problem but the collection of learning problems are all occurring simultaneously. Discussion in [26] hints toward the type of the algorithms we analyze in Section 3, but without formal analysis about how the error accumulation could harm the sample complexity (which, as we will see, is one of the central challenges in this setting).\nThe problem of trying to learn invariants or other commonalities when faced with a series of learning tasks arriving over time has a long history in applied machine learning (e.g., [23, 25]). Our work is the first to give provable efficiency guarantees for learning multi-layer representations in this life-long learning setting."}, {"heading": "2 Preliminaries", "text": "We assume we have m learning (binary classification) problems that arrive online over time. The learning problems are all over a common instance space X of dimension n (e.g., we will consider X = <n and X = {0, 1}n) but each has its own target function and potentially its own distribution Di over X . Formally, learning problem i is defined by a distribution Pi over X \u00d7 Y where Y = {\u22121, 1} is the label space and Di is the marginal over X of Pi, and the goal of the learning algorithm on problem i is to produce a hypothesis function hi of small error, where err(hi) = errPi(hi) = P(x,y)\u223cPi [hi(x) 6= y]."}, {"heading": "3 Life-long Learning of Halfspaces", "text": "We consider here the natural case that X = <n and each target function is a linear separator going through the origin; that is, for all i there exists ai of unit length such that for all (x, y) drawn from Pi we have sign(ai \u00b7 x) = y. To begin, we will assume that what the target functions have in common is that they all lie in some common k-dimensional subspace of <n for k min(n,m). In particular, let A be a m by n matrix whose rows are a1, . . . , am; then our assumption is that A has rank k. This implies that there exist a decomposition A = CW , where W is a k \u00d7 n matrix and C is a m \u00d7 k matrix. The rows w1, . . . , wk of W can be viewed as k linear metafeatures that are sufficient to describe all m learning problems, or equivalently we can view this as a network with one middle layer of k hidden linear units. In fact, our algorithms will work under a more robust condition that allows for the ai to be \u201cnear\u201d to a low-dimensional subspace (see Theorem 1).\nIn this section we analyze the following online algorithm for this setting; note, the algorithm is very natural but the challenge will be to analyze it and control the propagation of error at reasonable sample sizes. Let \u03b5acc be a quantity to be determined later. For the first learning problem we just learn it to error \u03b5acc using the original input features and let the resulting weight vector be w\u03031. Suppose now we have produced weight vectors w\u03031, . . . , w\u0303k\u2032 and we are considering problem i. We will first see if we can learn problem i well (to error ) as a linear combination of the w\u0303j . If so, then we mark this as a success and go on to problem i+ 1. If not, then we will learn it to error \u03b5acc using the input features and add the hypothesis weight vector as w\u0303k\u2032+1. (See Algorithm 1 for formal details). The challenge is how small \u03b5acc needs to be for this to succeed.\nWe show in the following that if theDi are isotropic log-concave (which includes many distributions such as Gaussian and uniform, see, e.g., [18]), the above procedure will be successful and learn the target functions with much fewer labeled examples in total than by learning each function separately. We start with some useful facts and present a lemma (Lemma 3) that is crucial for our analysis.\nGiven two vectors a and b and a distribution D\u0303, let dD\u0303(a, b) = Px\u223cD\u0303(sign(u \u00b7 x) 6= sign(v \u00b7 x)). Let \u03b8(a, b) be the angle between two vectors a and b. For a vector a and a subspace V , let \u03b8(a, V ) = minb\u2208V \u03b8(a, b) be the angle between a and its closest vector in V (in angle). For subspaces U and V , let \u03b8(U, V ) = maxu\u2208U \u03b8(u, V ). That is, \u03b8(U, V ) \u2264 \u03b1 iff for all u \u2208 U there exists v \u2208 V such that \u03b8(u, v) \u2264 \u03b1.\nLemma 1 Assume D is an isotropic log-concave in Rn. Then there exist constants c and c\u2032 such that for any two unit vectors u and v in Rd we have c\u03b8(v, u) \u2264 dD(u, v) \u2264 c\u2032\u03b8(v, u).\nProof: The proof of the lower bound appears in [5]. The proof of the upper bound is implicit in the earlier work of [27] \u2013 we provide it here for completeness. The key idea is to project the region of disagreement in the space given by the two normal vectors, and then using properties of log-concave distributions in 2- dimensions. Specifically, consider the plane determined by u and v, and let g be the 2-dimensional marginal of the density function over this plane. Then g is an isotropic and log-concave density function over R2.\nIt is known [15] that for some constants k3, k4 we have g(z) \u2264 k3e\u2212k4||z||. Given this fact, we just need to show that the integral of k3e\u2212k4||z|| over the region {z : u \u00b7 z \u2265 0, v \u00b7 z \u2264 0} is at most c\u2032\u03b1 for some constant c\u2032, where \u03b1 is the angle between u and v (the integral over {z : u \u00b7 z \u2264 0, v \u00b7 z \u2265 0} is analogous). In particular, using polar coordinates, we can write the integral as:\u222b \u03b1\n\u03b8=0 \u222b \u221e r=0 f(r cos \u03b8, r sin \u03b8) r drd\u03b8 \u2264 \u222b \u03b1 \u03b8=0 \u222b \u221e r=0 rk3e \u2212k4rdrd\u03b8.\nThe inner integral evaluates to a constant and therefore the entire integral is bounded by c\u2032\u03b1 for some constant c\u2032 as desired.\nLemma 1 implies that if we learn some target ai to error acc, then the angle between our learned vector and the target will be O( acc). In the other direction, if the target lies in subspace W and we have learned a subspace W\u0303 such that \u03b8(W, W\u0303 ) is small, then there will exist a low-error weight vector in W\u0303 . Ideally, we would therefore like to say that if we construct a subspace W\u0303 out of vectors w\u0303i that individually are close to their associated targets wi, then W\u0303 is close to the spanW of the wi. Unfortunately, this is not in general true if the targets are close to each other, e.g., see Figure 1(a). We will address this by using the fact that each w\u0303i was not learnable using the span of the previous w\u0303j . We begin with a helper lemma (Lemma 2), which can be viewed as addressing the special case that all previous targets have been learned perfectly, and then present our main lemma (Lemma 3).\nLemma 2 Let U = span{a1, . . . , ak\u22121}, V = span{a1, a2, . . . , ak\u22121, b} and V\u0303 = span{a1, . . . , ak\u22121, b\u0303} be sets of vectors in <n. Then,\n\u03b8(V, V\u0303 ) \u2264 \u03c0 2 \u03b8(b\u0303, b) \u03b8(b\u0303, U) .\nProof: (For intuition, see Figure 1(b).) First, we may assume b, b\u0303 6\u2208 U because if b \u2208 U then \u03b8(V, V\u0303 ) = 0 and if b\u0303 \u2208 U then \u03b8(b\u0303, U) = 0. Additionally we may assume b and b\u0303 are unit-length vectors since we are interested only in angles. Next, let u \u2208 V be the unit-length vector in V of farthest angle from V\u0303 , i.e., \u03b8(u, V\u0303 ) = \u03b8(V, V\u0303 ). We can write u as a linear combination of b and some vector u1 \u2208 U , and will prove the lemma by showing there must be some nearby vector in the span of u1 and b\u0303. Specifically, using the fact that \u03b8(V, V\u0303 ) = \u03b8(u, V\u0303 ) \u2264 \u03b8(span(u1, b), span(u1, b\u0303)) and the fact that \u03b8(b\u0303, U) \u2264 \u03b8(b\u0303, u1), it is sufficient to prove that:\n\u03b8(span(u1, b), span(u1, b\u0303)) \u2264 \u03c0\n2\n\u03b8(b, b\u0303)\n\u03b8(b\u0303, u1) ,\nwhich is just a statement about 3-d space. Let \u03b1 = \u03b8(span(u1, b), span(u1, b\u0303)) and \u03b2 = \u03b8(b\u0303, u1). We can wlog write u1 = (1, 0, 0) and assume span(u1, b) is the x-y plane. Since span(u1, b\u0303) has angle \u03b1 with the x-y plane and intersects the x-axis, we can write b\u0303 = cos(\u03b2)u1 + sin(\u03b2)u2 for u2 = (0, cos(\u03b1), sin(\u03b1)). Now, \u03b8(b, b\u0303) is at least sin\u22121 of the Euclidean distance of b\u0303 to the x-y plane, which is sin(\u03b1) sin(\u03b2). The lemma then follows from the fact that \u03b1\u03b2 \u2264 \u03c02 sin\n\u22121(sin(\u03b1) sin(\u03b2)) for 0 \u2264 \u03b1, \u03b2 \u2264 \u03c02 . The key point of the next lemma is that the errors (angles between ai and a\u0303i) only contribute additively to the overall angle gap between subspaces so long as each new learned vector is sufficiently far from the previously-learned subspace. In contrast, a difficulty with the usual analysis of perturbation of matrices is that while we can assume that each new a\u0303i is far from the span of the previous a\u03031, . . . , a\u0303i\u22121, we do\nnot have control over its distance to the span of the past and future vectors {a\u03031, . . . , a\u0303i\u22121, a\u0303i+1, . . . , a\u0303k} as in the definition of the height of a matrix (e.g., [22]). Note also that even adding the same vector to two different subspaces can potentially increase their angle (e.g., in Figure 1(a), \u03b8(w1, w\u03031) < 0.11 but \u03b8(span(w1, w2), span(w\u03031, w2) = \u03c0/2).\nLemma 3 Let Vk = span{a1, . . . , ak} and V\u0303k = span{a\u03031, . . . , a\u0303k}. Let acc, \u03b3 \u2265 0 and acc \u2264 \u03b32/(10k). Assume for i = 2, . . . , k that \u03b8(a\u0303i, V\u0303i\u22121) \u2265 \u03b3, and for i = 1, . . . , n, \u03b8(ai, a\u0303i) \u2264 acc. Then\n\u03b8(Vk, V\u0303k) \u2264 2k acc \u03b3 .\nProof: The proof is by induction on k, on the stronger hypothesis that the conclusion holds for Vk = span{W,a1, . . . , ak} and V\u0303k = span{W, a\u03031, . . . , a\u0303k} for any fixed subspace W . Note that the base case (k = 1), follows directly from Lemma 2, using W = V\u0303k\u22121 = U , a\u03031 = b\u0303, and a1 = b. Now, let V \u2032k = span(Vk\u22121, a\u0303k). Then we have:\n\u03b8(Vk, V\u0303k) \u2264 \u03b8(Vk, V \u2032k) + \u03b8(V \u2032k, V\u0303k) [by triangle inequality]\n\u2264 \u03c0 2 \u03b8(a\u0303k, ak) \u03b8(a\u0303k, Vk\u22121) + 2(k \u2212 1) acc \u03b3\n[the first term is by Lemma 2, and the second term is by induction using W = span(a\u0303k)]\n\u2264 \u03c0 2\nacc\n\u03b8(a\u0303k, V\u0303k\u22121)\u2212 \u03b8(Vk\u22121, V\u0303k\u22121) + 2(k \u2212 1) acc \u03b3\n[by triangle inequality: \u03b8(a\u0303k, V\u0303k\u22121) \u2264 \u03b8(a\u0303k, Vk\u22121) + \u03b8(Vk\u22121, V\u0303k\u22121)]\n\u2264 \u03c0 2\nacc\n\u03b3 \u2212 2(k\u22121) acc\u03b3 +\n2(k \u2212 1) acc \u03b3\n[by assumption and by induction]\n\u2264 acc \u03b3\n( \u03c0\n2\n\u03b32\n\u03b32 \u2212 2(k \u2212 1) acc + 2(k \u2212 1) ) \u2264 2k acc/\u03b3,\nwhere the last step comes from using acc \u2264 \u03b32/(10(k \u2212 1)). We now put these together to analyze Algorithm 1 when target functions lie on, or close to, a low-dimensional subspace. Specifically, say that a subsequence of target functions ai1 , ai2 , . . . is \u03b3-separated if each aij has angle greater than \u03b3 from the span of the previous ai1 , . . . , aij\u22121 . Define the \u03b3-effective dimension of targets a1, a2, . . . , am as the size of the largest \u03b3-separated subsequence. Our assumption will be that the \u03b3-effective dimension of the targets is at most k for \u03b3 = c for some absolute constant c > 0, where is our desired error rate per target. Note that for \u03b3 = 0, \u03b3-effective dimension equals the dimension of the subspace spanned, and for \u03b3 > 0 this allows the targets to just be \u201cnear\u201d to a low-dimensional subspace.\nTheorem 1 Assume that all marginals Di are isotropic log-concave. Choose \u03b3 = c1 and acc s.t. 2k \u03b5acc\u03b3 + \u03b3 = c2 for sufficiently small constants c1, c2 > 0. Consider running Algorithm 1 with parameters and acc on any sequence of targets whose \u03b3-effective dimension is at most k. Then k\u0303 \u2264 k (the rank of A\u0303 is at most k). Moreover the total number of labeled examples needed to learn all the problems to error is O\u0303(nk/ acc + km/ ) = O\u0303(nk 2/ 2 + km/ ).\nProof: We divide problems in two types: problems of type (a) are those for which we can learn a classifier of error at most by using the previously learnt problems; the rest are of type (b).\nAlgorithm 1 Life-long learning of halfspaces sharing a common low-dimensional subspace Input: n,m,k, access to labeled examples for problems i \u2208 {1, . . . ,m}, parameters and acc.\n1. Learn the first target to error acc to get an n-dimensional vector \u03b11. Set w\u03031 = \u03b11; k\u0303 = 1 and i1 = 1.\n2. For the learning problem i = 2 to m \u2022 Attempt to learn using the representation v \u2192 (w\u03031 \u00b7 v, ..., w\u0303k\u0303 \u00b7 v). I.e., check if for learning\nproblem i there exists a hypothesis sign(\u03b1i,1(w\u03031 \u00b7 v) + \u00b7 \u00b7 \u00b7+ \u03b1i,k\u0303(w\u0303k\u0303 \u00b7 v)) of error at most . (a) If yes, set c\u0303i = (\u03b1i,1, . . . , \u03b1i,k\u0303, 0, . . . , 0). (b) If not, learn a classifier \u03b1i for problem i of accuracy acc by using the original features. Set\nk\u0303 = k\u0303 + 1, ik\u0303 = i , w\u0303k\u0303 = \u03b1i, and c\u0303i = ek\u0303.\n3. Let W\u0303 be an k\u0303 \u00d7 n matrix whose rows are w\u03031, . . . , w\u0303k\u0303 and let C\u0303 be the matrix m \u00d7 k\u0303 matrix whose rows are c\u03031, . . . , c\u0303k\u0303. Compute A\u0303 = C\u0303W\u0303 .\nOutput: m predictors; predictor i is v \u2192 sign(A\u0303i \u00b7 v)\nFor problems of type (a) we achieve error by design. For each problem i of type (b) we open a new row in W\u0303 , and set w\u0303k\u0302 = \u03b1i, where k\u0302 is such that ik\u0302 = i. We also set c\u0303i = ek\u0302, so a\u0303i = \u03b1i. Since \u03b1i has error at most acc, we have \u03b8(w\u0303k\u0302, aik\u0302) \u2264 acc/c for some absolute constant c (by Lemma 1).\nWe next show that k\u0303 \u2264 k. We prove by induction that for each w\u0303k\u0302 we create for a problem i = ik\u0302, we have both (1) aik\u0302 is \u03b3-far from span{ai1 , \u00b7 \u00b7 \u00b7 , aik\u0302\u22121} and (2) w\u0303k\u0302 is \u03b3-far from span(w\u03031, ..., w\u0303k\u0302\u22121).\nStep k\u0302 = 1 follows immediately. For the inductive step k\u0302 > 1: if we create w\u0303k\u0302 for a problem i = ik\u0302, this only happens if there is no vector in the span of the previous metafeatures w\u0303j , j < i that has error less than for problem ik\u0302. 3 That is aik\u0302 is at least /c \u2032-far from the span{w\u03031, ..., w\u0303k\u0302\u22121} for some absolute constant c \u2032 (by Lemma 1). We also have \u03b8(w\u0303k\u0302, aik\u0302) \u2264 \u03b5acc/c, therefore, by triangle-inequality, we obtain\n\u03b8(w\u0303k\u0302, span(w\u03031, ...w\u0303k\u0302\u22121)) \u2265 /c \u2032 \u2212 \u03b5acc/c \u2265 \u03b3.\nThus w\u0303k\u0302 is \u03b3-far from span{w\u03031, ..., w\u0303k\u0302\u22121}. It remains to show that aik\u0302 is \u03b3-far from the span of {ai1 , \u00b7 \u00b7 \u00b7 , aik\u0302\u22121}. Suppose for contradiction that \u03b8(aik\u0302 , {ai1 , \u00b7 \u00b7 \u00b7 , aik\u0302\u22121}) \u2264 \u03b3. We will show that this implies there exists b\u0303ik\u0302 \u2208 span{w\u03031, \u00b7 \u00b7 \u00b7 , w\u0303k\u0302\u22121} with error at most , contradicting the fact that no such vector exists.\nBy construction we have \u03b8(aij , w\u0303j) \u2264 acc/c for j \u2208 {1, . . . , k\u0302 \u2212 1}; also by induction we have w\u0303j is \u03b3-far from the span of {w\u03031, \u00b7 \u00b7 \u00b7 , w\u0303j\u22121} for j \u2208 {1, . . . , k\u0302 \u2212 1}. By Lemma 3 we obtain that\n\u03b8(span{ai1 , \u00b7 \u00b7 \u00b7 , aik\u0302\u22121}, span{w\u03031, \u00b7 \u00b7 \u00b7 , w\u0303k\u0302\u22121}) \u2264 2k\u03b5acc/(c\u03b3).\nThese together with triangle inequality imply that\n\u03b8(aik\u0302 , span{w\u03031, \u00b7 \u00b7 \u00b7 , w\u0303k\u0302\u22121}) \u2264 \u03b3 + 2k \u03b5acc c\u03b3 \u2264 /c\u2032.\nSo by Lemma 1 there exist b\u0303ik\u0302 \u2208 span{w\u03031, \u00b7 \u00b7 \u00b7 , w\u0303k\u0302\u22121} of error at most , which contradicts our assumption. Therefore, our induction is maintained (by condition (2)) and so we have k\u0303 \u2264 k (by condition (1) and our assumption on the \u03b3-effective dimension of the targets).\nBy setting \u03b3 = O( ) and acc = O( 2/k) the total number of labeled examples needed to learn all the problems to error is O\u0303(nk2/ 2 + km/ ), which could be significantly lower than learning each problem separately. In this case the sample complexity would be \u2126(mn/ ) even under log-concave distributions [5].\n3Technically, since we are learning over a finite sample, we can only be confident that there is no vector in the span of error at most /2. However, we can absorb these factors of 2 into the constants c, c\u2032.\nNote 1 As stated, Algorithm 1 is not efficient because it requires finding an optimal linear separator in Step 2, which in general is hard. However, for log-concave distributions, there exist algorithms running in time poly(k, 1/ ) that find a near-optimal linear separator: in particular, one of error under the assumption that the optimal separator has error \u03b7 = / log2(1/ ) [4], and with near-optimal sample complexity [14, 28]. Thus, by reducing \u03b5acc by an O(log2(1/ )) factor, one can achieve the bounds of Theorem 1 efficiently."}, {"heading": "3.1 Halfspaces with more complex common structure", "text": "In this section we consider life-long learning of halfspaces with more complex common structure, corresponding to a multi-layer network of linear metafeatures. It is at first not obvious how multiple levels of linear nodes could help: if the target vectors span a k-dimensional subspace, then to represent them with a multi-layer linear network, each layer would need to have at least k nodes. However, the numbers of nodes in the network do not tell the whole story: sample complexity of learning can also be reduced via sparsity.\nSpecifically, we assume now that the target functions all lie in a k dimensional space and that furthermore within that k-dimensional space, each target lies in one of r different \u03c4 -dimensional spaces. This naturally models settings where there are really r different types of learning problems but they share some commonality across type (given by the common k-dimensional subspace).4 We can view this as a network with two hidden layers: the first layer given by vectors w1, w2, . . . , wk, and the second layer given by r \u03c4 -tuples of vectors, u11, . . . , u \u03c4 1 , ..., u 1 r , . . . , u \u03c4 r , where u 1 i , . . . , u \u03c4 i span one of \u03c4 -dimensional spaces. In other words, the first hidden layer captures the overall low dimensionality and the second hidden layer captures sparsity. We assume r m and k n and that \u03c4 is a constant. Algorithmically, given a new problem we first try to learn well via a sparse linear combination of only \u03c4 second level metafeatures If we fail, we try to learn based on the first level metafeatures and if successful we add a new second level metafeature corresponding to this target. If that fails, we learn using the input features and then we add both a first and second level metafeature corresponding to this target. For logconcave distributions, by using the subspace lemma and an error analysis similar to that for Theorem 1 we can show we have k\u0303 \u2264 k and r\u0303 \u2264 \u03c4r. Formally:\nTheorem 2 Assume all marginals Di are isotropic log-concave and the target functions satisfy the above conditions. Consider \u03b3\u0303 \u2264 c , \u0303acc \u2264 c \u03b3\u0303 \u03c4 , \u03b3 \u2264 c\u0303acc, and acc \u2264 c \u03b3\u0303acc k for (sufficiently small) constant c > 0. Consider running Algorithm 2 (see appendix) with parameters , acc, and \u0303acc. Then k\u0303 \u2264 k and r\u0303 \u2264 \u03c4r. Moreover the total number of examples needed to learn all the problems to error is O\u0303(nk/ acc + kr/\u0303acc +m log(r)/ ).\n(Proof in appendix). By setting \u03b3\u0303 = /2, \u0303acc = \u0398( 2/\u03c4), \u03b3 = \u0398( 2/\u03c4), acc = \u0398( 4/\u03c42k) we get that the total number of labeled examples needed to learn all the problems to error is O\u0303(nk2\u03c42/ 4 + kr\u03c42/ 2 + m\u03c4 log(r)/ ). This could be significantly lower than learning each problem separately or by learning the problems together but only using one layer of metafeatures. Specifically, if we used one layer of metafeatures as in Theorem 1 (corresponding to the k-dimensional subspace) the sample complexity would be O(nk2/ 2 + mk/ ). Alternatively we could have just one middle layer of size r\u03c4 and learn sparsely within that, but this would also give worse bounds if r is large. As a concrete example, if is constant,\n4For instance, imagine a job-placement company whose goal is to decide which people would do well in which job. In this setting, we can measure a large number of features for each person (e.g., based on how well they do on various tests). There are then k \u201cintrinsic qualities\u201d that are linear combinations of these features. E.g., \u201cquantitative reasoning\u201d might be one linear combination, \u201cpeople skills\u201d and \u201ctime management\u201d might be others, etc., and really what is important about each person is where they sit in this k-dimensional subspace. Then, different jobs might belong in different low-dimensional spaces within this k-dimensional space, based on what is important for that job. I.e., there are r \u201ckinds\u201d of jobs, each of which has a \u03c4 -dimensional subspace that is relevant for it.\nk = \u221a n, r = n2 and m = n2.5, we get that the two-layer algorithm requires only O(\u03c42/ 2 + \u03c4 log(r)/ ) examples per target. On the other hand, the other two options require at least O(k/ ) examples per target, which could be much worse."}, {"heading": "4 Life-long Learning of Monomials", "text": "We now consider a nonlinear case where the metafeatures will be products and combined via products. Specifically, we assume that the instance space is X = {0, 1}n, that the m target functions are conjunctions (i.e., products) of features, and that there exist k monomial metafeatures such that all the target functions can be expressed as conjunctions (products) over them. Our goal will be to learn them efficiently.\nIf the metafeatures do not overlap, then this can be viewed as an instance of the linear case. Each target function can be described by an indicator vector with coefficients in {0, 1} (plus a threshold that can be converted to an integer weight for a dummy variable x0). More importantly, if the metafeatures do not overlap, then the indicator vectors for all the targets are in a space of rank k with basis given by the indicator vectors of the metafeatures. If furthermore the underlying distribution is one for which, when learning from scratch, we can learn the target functions exactly (e.g., a product distribution where each variable is set to 0 some non-negligible fraction of the time) then we can directly apply the analysis for linear case. In fact, the overall analysis is much simpler since we have the targets exactly that were learned from scratch.\nSo, the interesting case is when metafeatures may overlap (it is easy to construct examples where this produces a space of dimension \u0398(2k)). Unfortunately, without any additional assumptions, even just the consistency problem is now NP-hard. That is, given a collection of conjunctions, it is NP-hard to determine whether there exist k monomials such that each can be written as a product of subsets of those monomials (it is called the \u201cset-basis problem\u201d [12]). For this reason, we will make a natural anchor-variable assumption that each metafeature mi has at least one variable (call it yi) that is not in any other metafeature mj . So this is a generalization of the disjoint case where every variable in mi is not inside any other mj . We can think of yi as an \u201canchor variable\u201d for metafeature mi.\nWe now show how with this assumption we can efficiently solve the consistency problem (and find the smallest set of monomials for which one can reconstruct each target). Using this as a subroutine, we then show how to solve an abstract online learning problem where at each stage we must propose a set of at most k monomial metafeatures and then pay a cost of 1 if the next target cannot be written as a product over them. This can then be applied to give efficient life-long learning of related conjunctions over product distributions. In Section 4.4 we give an application to constructing Boolean superimposition-based autoencoders. We then relax the anchor-variable assumption and show how under this relaxed condition we can solve for near-optimal sparse autoencoders as well as life-long learning of conjunctions under relaxed conditions. In Section 5, we build on some of these results to give an algorithm for life-long learning of polynomials."}, {"heading": "4.1 Solving the Consistency Problem", "text": "We now show that we can use Algorithm 3 (below) for solving the consistency problem under the anchor variable assumption. That is, given a collection of conjunctions, the goal is to find the fewest monomial metafeatures needed to reconstruct all of them as products of subsets of the metafeatures. Given a conjunction T we denote by vars(T ) the variables appearing in T . Given a variable z and a set of conjunctions TS we denote by N(TS, z) the set of conjunctions in TS that contain z.\nLemma 4 Let TS be a set of conjunctions such that each of them is a conjunction of some subset of metafeatures m1, . . . ,mk satisfying the anchor variable condition. We can use Algorithm 3 to find m\u03031, . . . , m\u0303i,\nAlgorithm 3 Consistency problem for monomial metafeatures with anchor variables Input: set TS = {T1, . . . , Tr} of conjunctions.\n1. Let i = 0. 2. Let h(T ) denote the conjunction of all metafeatures m\u0303j produced so far that are fully contained in T .\nI.e., vars(h(T )) = \u222a{vars(m\u0303j) : vars(m\u0303j) \u2286 vars(T )}. 3. While there exists T \u2208 TS s.t. vars(T ) 6= vars(h(T )) do:\n(1) Let T be the target of least index in TS s.t. vars(T ) 6= vars(h(T )). (2) Choose zi+1 to be a minimal variable in vars(T ) \\ vars(h(T )); that is, there is no other variable\nz\u2032 \u2208 vars(T ) \\ vars(h(T )) s.t. N(TS, z\u2032) \u2282 N(TS, z). If there are multiple options, choose zi+1 to be the option of least index.\n(3) Let vars(m\u0303i+1) be the intersection of vars(T ) for all T in TS that contain zi+1. That is vars(m\u0303i+1) = \u22c2 T\u2208TS,zi+1\u2208vars(T ) vars(T ).\n(4) i=i+1\nOutput: Conjunctions m\u03031, . . . , m\u0303i s.t. each Tj is a conjunction of a subset of them.\ni \u2264 k s.t. each Tj \u2208 TS is a conjunction of a subset of them. Moreover each m\u0303i is associated to a metafeature mti s.t. the following conditions are satisfied:\n(a) vars(mti) \u2286 vars(m\u0303i); that is, m\u0303i is more specific than mti . (b) For all targets T in TS such that vars(mti) \u2286 vars(T ) we have vars(m\u0303i) \u2286 vars(T ); that is, m\u0303i is\nnot too specific. (c) For any j, if yj \u2208 vars(m\u0303i) then vars(mj) \u2286 vars(m\u0303i).\nProof: Note that for any i for any T \u2208 TS we have vars(h(T )) = \u222a{vars(m\u0303j) : j \u2264 i, vars(m\u0303j) \u2286 vars(T )}; that is, vars(h(T )) represents all variables from T that are already used by the previous hypothesized metafeatures m\u0303j whose relevant variables are contained in T .\nWe prove the desired statement by induction. Assume inductively that m\u03031, . . . , m\u0303i satisfy conditions (a),(b),(c). We show that m\u0303i+1 satisfies these conditions as well.\nConsider the target T we choose in step 3(1) in round i+ 1. We know zi+1 \u2208 vars(T )\\vars(h(T )) and that T is a conjunction of the true metafeatures. So zi+1 belongs to some metafeature mti+1 s.t. vars(mti+1) \u2286 vars(T ) . From the induction hypothesis, by conditions (a),(b) we know that mti+1 6= mti\u2032 for i\n\u2032 \u2264 i. To see this assume by contradiction that mti+1 = mti\u2032 for i\n\u2032 \u2264 i; so zi+1 \u2208 mti\u2032 . By condition (a) we know vars(mti\u2032 ) \u2286 vars(m\u0303ti\u2032 ) and since vars(mti\u2032 ) \u2286 vars(T ) by condition (b) we have vars(m\u0303ti\u2032 ) \u2286 vars(T ), so zi+1 \u2208 vars(h(T )), contradiction. Consider T \u2208 TS such that vars(mti+1) \u2286 vars(T ). Since zi+1 \u2208 vars(mti+1) and we create m\u0303i+1 by intersecting the variables in every target T containing zi+1, we clearly have vars(m\u0303i+1) \u2286 vars(T ), satisfying condition (b). Also if any target T contains an anchor variable yj , then it must contain mj , so condition (c) is satisfied as well.\nWe now show that (a) is satisfied, namely that vars(mti+1) \u2286 vars(m\u0303i+1). This could only fail if zi+1 is not an anchor for mti+1 , so in step 2 of the algorithm we intersected some target T that contains zi+1 but does not contain mti+1 . This can only happen if zi+1 also belongs to some other mj . But then zi+1 is not minimal since yti+1 (the true anchor variable for mti+1 , which is also contained in vars(T ) \\ vars(h(T )) by (c)) satisfies N(TS, yti+1) \u2282 N(TS, zi+1), and so would have been chosen instead of zi+1 in step 3(1)."}, {"heading": "4.2 An Abstract Online Problem", "text": "Building on Algorithm 3 and Lemma 4, we now describe an algorithm for the following abstract online setting. At each time-step r we propose a set M\u0303 of at most k hypothesized metafeatures and are provided with a target conjunction Tr. If Tr can be written as a conjunction of metafeatures in M\u0303 then we pay 0. If not, then we pay 1 and may update our set M\u0303 using Tr (this corresponds to the case of learning Tr from scratch). Our goal is to bound our total cost, under the assumption that there exists a set of k metafeatures for all targets. To do so we need to argue that each time we pay 1, we can use Tr to make progress.\nAlgorithm 4 Lifelong Learning of Conjunctions with Monomial Metafeatures Input: Targets T1, T2, . . . , Tm provided online.\n1. Initialize TS = \u2205 and M\u0303 = \u2205. 2. For r = 1 to m do:\n\u2022 If we cannot represent Tr as conjunction of hypothesized metafeatures M\u0303 then \u2022 Add Tr to TS. \u2022 Run Algorithm 3 with input TS to produce hypothesized metafeatures M\u0303 .\nOutput: Hypothesized metafeatures M\u0303 .\nTheorem 3 The number of targets that need to be learned from scratch in in Algorithm 4 is at most n2 + k.\nProof: For any given set of targets TS learnt from scratch, we define a directed graph GTS on the variables, by adding an edge (xi, xj) if every target in TS that has xi also has xj . Note that if TS \u2286 T\u0303S we have E(GTS) \u2286 E(GT\u0303S). We start with the complete directed graph (corresponding to TS = \u2205), and then we argue that each time we are forced to learn a new target from scratch and increase TS we either delete at least one edge from the graph or we increment the number of hypothesized metafeatures by 1.\nSuppose the new target Tr cannot be represented using the current hypothesis metafeatures. So we add Tr into TS and re-run Algorithm 3 . Let us look at the first time the new run differs from the old run. There are three possibilities for this difference.\n(1) It could be that we choose a different zi+1 in step 3(2) of Algorithm 3. There are two ways this can happen: (a) the old zi+1 is not minimal any more or (b) it could be some z\u2032 (of lower index than the old zi+1) was not minimal before but is minimal now. In case (a) we have some z\u2032 is now in a strict subset of the targets in TS that contain zi+1 but this was not the case before adding Tr. This means the new target Tr must contain the old zi+1 but not z\u2032, and all previous targets that contained either z\u2032 or zi+1 contained both of them. That means we cut the edge (zi+1, z\u2032). In case (b), some z\u2032 (of lower index than the old zi+1) was not minimal before but is minimal now. This means that before there was some z\u2032\u2032 that was in a strict subset of the targets as z\u2032, but it is not anymore. Now, z\u2032 is minimal, z\u2032\u2032 is no longer in a strict subset of the targets containing z\u2032; so the new target contains z\u2032\u2032 but not z\u2032. So we cut the edge (z\u2032\u2032, z\u2032).\n(2) It could be that we get the same zi+1 but different m\u0303i+1 in step 3(3); this means vars(m\u0303i+1) is smaller. Thus we cut the edges between zi+1 and all the variables in the old m\u0303i+1 that are not in the new m\u0303i+1.\n(3) It could be that we use the new target Tr in step 3(1). Since we go through the targets in order, the only way that the first difference can be when the new target is used in 3(1) is if every previous metafeature is created the same as before. Therefore, in this case we create a new metafeature. So, the number of metafeatures is increasing and we make progress as desired."}, {"heading": "4.3 Applications", "text": "As one immediate application of the above abstract online problem, since conjunctions over {0, 1}n can be exactly learned in the Equivalence Query model with at most n equivalence queries (and conjunctions over {0, 1}k can be learned from at most k equivalence queries), we immediately have the following:\nCorollary 1 Let TS be a sequence of m conjunctions such that each is a conjunction of some subset of metafeatures m1, . . . ,mk satisfying the anchor variable condition. Then this sequence can be learned using only O(mk + n3) equivalence queries total.\nAs another application of the above abstract online problem, we now show we can learn with good sample complexity over any product distribution D.\nTheorem 4 Assume that all Dr = D which is a product distribution, that the metafeatures mi satisfy the anchor variable assumption and all the target functions cr are balanced. We can learn hypotheses h1, . . . , hm of error at most by using Algorithm 5 with parameters s1(n, , \u03b4) = O(n/ log(n/\u03b4)), s2(n, , \u03b4) = k/ log(m/\u03b4), and s3(n, , \u03b4) = n/ log(nk/\u03b4). The total number of labeled examples needed is O\u0303((n2 + k)n/ log(n/\u03b4) + km/ ).\nProof: Let us call a variable i insignificant if over a sample of size \u0398((n/ ) log(n/\u03b4)) appears set to 0 less than /4n fraction of the time. Let I be the set of insignificant variables and let S be the set of significant variables. Let DS be the distribution D restricted to examples that are set to 1 on all variables in I . We can show that error at most /2 over DS implies error at most over D. This is true, since by Chernoff bounds for every variable i we have Px\u223cD[xi = 0] \u2264 /2n if i appears set to 0 less than /4n fraction of the time over a sample of size \u0398(n log(n)/\u03b4) . So, by union bound Px\u223cD[\u2203i \u2208 I, xi = 0] \u2264 /2. It remains to show that hypotheses h1, . . . , hm have error at most /2 over DS . First note that for any label r if xi /\u2208 cr and i \u2208 S, then Px\u223cDS [xi = 0|cr(x) = 1] = Px\u223cDS [xi = 0]. This follows from two facts. First, since the target cr is a conjunction we have Px\u223cDS [xi = 0|cr(x) = 1] = Px\u223cDS [xi = 0|xj = 1\u2200xj \u2208 cr]. Second, because D is a product distribution and DS be the distribution D restricted to examples that are set to 1 on all variables in I , we have Px\u223cDS [xi = 0|xj = 1\u2200xj \u2208 cr] = Px\u223cDS [xi = 0]. Furthermore since cr is balanced over D and so over DS we get Px\u223cDS [xi = 0, cr(x) = 1] \u2265 c /n. Note that every time we learn we learn a problem from scratch (by using the original variables), we get n/ log(n/\u03b4) labeled examples from DS . Therefore significant variables that are not in the target will appear set to 0 in at least one positive example. Therefore for every problem i learned based on the original features (via case 1 or 3(b)), we learn the target, that is hi = ci.\nThese together with the argument in the Theorem 3 gives the desired result."}, {"heading": "4.4 Sparse Boolean Autoencoders and Relaxing the Anchor-Variable Assumption", "text": "The above results (and in particular, Lemma 4) have an interesting interpretation as constructing a minimal feature space for Boolean, or superimposition-based, autoencoding.\nSpecifically, consider a collection of black-and-while pixel images {Tr} where each Tr \u2208 {0, 1}n. Our goal is to contruct a 2-level auto-encoder A (for each r, we want A(Tr) = Tr) with as few nodes in the middle (hidden) level as possible, such that nodes in the hidden level compute the AND of their inputs, and nodes in the output level compute the OR of their inputs. We can view each hidden node in such a network as representing a \u201cpiece\u201d of an image, with the autoencoding property requiring that each Tr should be equal to the bitwise-OR of all pieces contained within it (i.e., superimposing them together). Formally, for each\nAlgorithm 5 Transfer Learning of Conjunctions with Monomial Metafeatures Input: parameters n,m,k, , \u03b4; s1(n, , \u03b4), s2(n, , \u03b4), s3(n, , \u03b4), access to unlabeled examples fromDi and label oracles for problems r \u2208 {1, . . . ,m}, .\n1. Draw s1(n, , \u03b4) unlabeled examples and identify the set of variables I that are set to 0 less than /4n fraction of the times.\n2. Draw a set S1 of s1(n, , \u03b4) examples from D1, remove from S1 those examples for which not all features in I are set to 1. Label S1 according to problem 1. Find a conjunction h1 consistent with S1. Initialize TS = {h1}.\n3. Run Algorithm 3 with input TS to produce hypothesized metafeatures M\u0303 .\n4. For the learning problem r = 2 to m\n\u2022 Draw a set Sr of s2(n, , \u03b4), examples from Dr, remove from Sr those examples in Sr for which not all features in I is set to 1; re-represent each example in Sr using meta-features in M\u0303 and check if we can find a conjunction consistent with Sr,\n(a) If yes, let hr be its representation over the original features and record it. (b) If not, draw a set Sr of s3(n, , \u03b4), examples from Dr, remove from Sr those examples for\nwhich a feature in I is set to 1; find a conjunction mhr consistent with Sr. \u2022 Add hr to TS. \u2022 Run Algorithm 3 with input TS to produce hypothesized metafeatures M\u0303 .\nOutput: Conjunctions h1, . . . , hm.\nhidden node j, let mj \u2208 {0, 1}n denote the indicator vector for the set of inputs to that node (which without loss of generality will also be the set of outputs of that node), and say that mj Tr if each bit set to 1 in mj is also set to 1 in Tr; we then require Tr to be the bitwise-OR of all mj Tr. Lemma 4 then shows that given a collection of images {Tr}, Algorithm 3 finds the smallest number of hidden nodes needed to perform this autoencoding, under the assumption that each metafeature mj contains some anchor-variable (some pixel set to 1 that no other metafeature sets to 1).\nWe now consider the problem of sparse Boolean autoencoding. That is, given a set TS = {Tr}, with each Tr \u2208 {0, 1}n, our goal is to find a collection of metafeatures m\u0303j (perhaps more than n of them) such that each Tr \u2208 TS can be written as the bitwise-OR of at most k of the m\u0303j (where k n). Clearly this is trivial by having one metafeature m\u0303j for each Tr, so our goal will be to have the (approximately) fewest of them subject to this condition. Additionally, because we want sparse reconstruction, we want for each Tr that |{j : m\u0303j Tr}| should be small as well. This problem has two motivations. From the perspective of autoencoding, this corresponds to finding a sparse autoencoder (viewing the Tr as pixel images). From the perspective of life-long learning, if this can be done online then (viewing the Tr as conjunctions) it will allow for fast learning, since conjunctions of k out of N variables can be learned with sample complexity (or equivalence queries) only O(k logN); in this case we would actually not need the additional \u201csparse reconstruction\u201d property above.\nTo solve this problem, we make a relaxed version of the anchor-variable assumption (anchor-variables no longer make sense once the number of metafeatures exceeds the number of input features n) which is that each metafeature should have a set of \u2264 c variables (for some constant c) such that any Tr containing that set should have the metafeature as one of its k \u201crelevant metafeatures\u201d. We call this the c-anchor-set\nassumption. Note that metafeatures satisfying the anchor-variable assumption will also satisfy the c-anchorset assumption for c = 1. Note also that in general the c-anchor-set assumption is a requirement on both the metafeatures and on the set TS. Formally, we make the following definition:\nDefinition 1 A set of metafeatures M = {mj} and set of targets TS = {Tr} satisfy the c-anchor-set assumption at sparsity level k if\n1. for each Tr \u2208 TS there exists a set Rr of at most k \u201crelevant\u201d metafeatures in M such that Tr is the bitwise-OR of the metafeatures in Rr, and\n2. For each mj \u2208 M there exists yj mj of Hamming weight at most c such that for all r, if yj Tr then mj \u2208 Rr. Note that in particular this implies that |{j : mj Tr}| \u2264 k.\nWe now prove that under this assumption, we can solve for a near-optimal set of metafeatures {m\u0303j}.\nTheorem 5 Given a set of targets TS = {Tr} in {0, 1}n, suppose there exists a set of metafeatures M satisfying the c-anchor-set assumption at sparsity level k. Then in time poly(nc) we can:\n1. Find a set of O(nc) metafeatures such that each Tr \u2208 TS can be written as the bitwise-OR of at most k of them, and\n2. Find a set of O(|M | log(n|TS|)) metafeatures that satisfy the c-anchor-set assumption with respect to TS at sparsity level O(k log(n|TS|)).\nProof: Item (1) is the easier of the two. For each y \u2208 {0, 1}n of Hamming weight at most c, define m\u0303y to be the bitwise-AND of all Tr \u2208 TS such that y Tr. By definition of the anchor-set assumption, for each mj \u2208 M there exists yj mj of Hamming weight at most c such that for all r, if yj Tr then mj \u2208 Rr. Therefore we have both (a) mj m\u0303yj and (b) m\u0303yj Tr for all r such that mj \u2208 Rr. Therefore each Tr is the bitwise-OR of the (at most k) metafeatures m\u0303yj such that mj \u2208 Rr. For item (2), we begin by creating O(nc) metafeatures m\u0303y as above. We next set up a linear program to find an optimal fractional subset of these metafeatures, and then round this fractional solution to a set of metafeatures M\u0303 satisfying (2). Specifically, the LP has one variable Zy for each m\u0303y with objective\nMinimize: \u2211 y Zy,\nSubject to : (1) for all y: 0 \u2264 Zy \u2264 1 (2) for all r, i: \u2211 y:ei m\u0303y Tr Zy \u2265 1 (ei is the unit vector in coordinate i)\n(3) for all r: \u2211\ny:m\u0303y Tr Zy \u2264 k\nHere, constraint (2) ensures that each Tr is fractionally covered by all the metafeatures contained inside it, and constraint (3) ensures that each Tr fractionally contains at most k metafeatures. Note also that setting Zyj = 1 for each mj \u2208M (and setting all other Zy = 0) satisfies all constraints at objective value |M |.\nWe now produce our output set of metafeatures M\u0303 by independently rounding each Zy to 1 with probability min[1, Zy ln(n\n2|TS|)]. Clearly E[|M\u0303 |] = O(|M | log(n|TS|)) so the key issue is the coverage of each Tr and the size of the set R\u0303r = {m\u0303y \u2208 M\u0303 : m\u0303y Tr}. Note that item (2) of Definition 1 will be satisfied by how the m\u0303y were constructed (taking the bitwise-AND of all Tr such that y Tr). First, for coverage, for each r and i such that variable i is set to 1 by Tr, the probability that M\u0303 does not contain some m\u0303y such that ei m\u0303y Tr is maximized when constraint (2) is satisfied at equality and all associated Zy are equal (by concavity). This in turn is at most lim \u21920(1 \u2212 ln(n2|TS|))1/\u03b5 = 1/(n2|TS|). Thus, by the union bound, the probability that any Tr fails to be completely covered by R\u0303r is at most 1/n. Now, to\naddress the size of the sets R\u0303r, the expected size of each R\u0303r by constraint (3) and the rounding step is at most k ln(n2|TS|) \u2264 max[k, 3] ln(n2|TS|). By Chernoff bounds, the probability any given R\u0303r has size more than twice this value is at most e\u2212max[k,3] ln(n\n2|TS|)/3 \u2264 1/(n2|TS|). So, by the union bound, the probability that any R\u0303r is too large is at most 1/n2.\nTheorem 5 shows that we can efficiently find a near-optimal sparse autoencoder for any set of targets in {0, 1}n having an optimal encoder satisfying the c-anchor-set assumption for constant c. Theorem 5 also has the following corollary for online learning from equivalence queries, similar to Corollary 1.\nCorollary 2 Let TS be a sequence ofm conjunctions for which there exists a setM of conjunctive metafeatures satisfying the c-anchor-set assumption at sparsity-level k for some constant c. Then this sequence can be efficiently learned using only O(mk log(n) + n2|M |) equivalence queries total.\nProof: We instantiate O(nc) metafeatures m\u0303y, one for each y \u2208 {0, 1}n of Hamming weight at most c, setting each m\u0303y initially to the conjunction of all variables. Given a new target Tr, we try to learn it as a conjunction of at most k of these metafeatures using at most O(k log nc) equivalence queries using the Winnow algorithm. If we are unsuccessful, we learn Tr from scratch using at most n equivalence queries. We then (viewing Tr and the m\u0303y as their indicator vectors) let m\u0303y \u2190 m\u0303y & Tr (where \u201c&\u201d denotes bitwiseAND) for all m\u0303y such that y Tr. This maintains the invariant that for each mj \u2208M , we have mj m\u0303yj , which implies that each time we learn some Tr from scratch we shrink at least one m\u0303yj by at least one variable. This can happen at most n|M | times."}, {"heading": "5 Life-long Learning of Polynomials", "text": "We now show an application of the results in Section 4 to the case where the target functions are polynomials from {0, 1}n to R, whose terms \u201cshare\u201d a not too large number of pieces. Specifically, we assume there exist k distinguished monomials (which might overlap) such that each monomial in each target polynomial can be written as a product of some subset of them. For example, if our distinguished monomials are {x1x2x3, x3x4x5, x5x6x7, x7x8x1} then we might have polynomials such as 4x3x4x5x6x7\u22122x5x6x7x8x1 and 3x1x2x3x4x5 + 3x1x2x3x7x8. If the target polynomials use r distinct monomials in total, then viewed as a network we have k nodes in a first hidden layer, where each is a product of some of the inputs, r nodes in a second hidden layer, where each is a product of outputs of the first hidden layer, and then the final outputs (our target functions) are weighted linear functions of the second hidden layer. Efficiently learning polynomials requires membership queries (under the assumption that juntas are hard to learn) in addition to equivalence queries or random examples even in the single task setting [21]. So we will assume access to membership queries as well. However, our goal will be to use these sparingly, only when we need to learn a new function from scratch. When learning from scratch we use an algorithm of Schapire and Sellie [21] that learns polynomials exactly. Any function from {0, 1}n to R has a unique representation as a polynomial over {0, 1}n, so learning exactly means learning the exact functional form of the target function as a polynomial. As a warmup, let\u2019s first consider a simple case. Assume that the target functions are polynomials that simply use at most k distinct monomials in total. This corresponds to a network with with only one hidden layer of k nodes. In this case, there is a very simple algorithm that exploits the structure of the problem. Let M\u0303 be the set of hypothesized monomials. Given a new target function, we try to learn a linear function over the monomials in M\u0303 . If we succeed, we are done and move on to the next problem. If not, we learn from scratch using queries; we will clearly get at least one new monomial we have not seen, and add it to the set M\u0303 . So, we only need to learn k problems from scratch.\nWe now provide an algorithm for the general, more interesting case. Our theoretical guarantees are under the assumptions that each polynomial in our family has L1 norm bounded by B and the number of terms in\neach is bounded by t. If the target function has an L1 norm bounded by B and its monomials can indeed be written as products of our metafeatures, then by considering all products of metafeatures and running an L1-based algorithm for learning linear functions [17], we can achieve low mean squared error using only O(B2 log(2k)) = O(B2k) examples.\nAlgorithm 6 Multi-task learning for polynomial target functions Input: n,m.\n1. Let M\u0303 = \u2205. M\u0303 is the set of hypothesized metafeatures for the first hidden layer. Let TS = \u2205. TS is the set of terms used to create the hypothesized metafeatures in M\u0303 .\n2. For the learning problem r = 1 to m\n(a) Create the set conj(M\u0303) of terms obtained by taking all possible conjunctions of the hypothesized metafeatures in M\u0303 .\n(b) Attempt to learn problem r as a linear function over the terms in conj(M\u0303) to low mean squared error (quadratic loss) using O(B2k) examples.\n\u2022 If we succeed, record the hypothesis. \u2022 Otherwise, run the algorithm of Schapire and Sellie [21] to learn the target Tr for problem\nr exactly based on the original feature representation with equivalence and membership queries.\ni. Expand TS by adding any term in Tr that was not in TS. ii. Run Algorithm 3 with input TS to \u201ccompactify\u201d it into the fewest number of (possibly\noverlapping) conjunctive metafeatures that can be used to recreate all the terms in TS. Let M\u0303 be the resulting metafeatures.\nOutput: Hypothesis functions of low error for each learning task.\nTheorem 6 Assume that the monomials corresponding to the first network layer satisfy the anchor assumption and the L1 norm of the target polynomials is bounded byB. Consider running Algorithm 6. The number of targets needed to learn from scratch is n2 + k. Furthermore the number of hypothesized metafeatures satisfies |M\u0303 | \u2264 k at any time, thus the sample complexity of learning problems in Step 2(b) is O(B2k) per problem.\nProof: In Algorithm 6, M\u0303 represents the set of hypothesized metafeatures for the first hidden layer \u2013 they are learned using Algorithm 3; let k\u2032 = |M\u0303 |. Let conj(M\u0303)=all possible conjunctions of hypothesized metafeatures in M\u0303 ; so TS \u2286 conj(M\u0303), |conj(M\u0303)| = 2k\u2032 . We know that in the true underlying network the metafeatures in the first middle layer are monomials satisfying the anchor assumption and the metafeatures in the second middle layer are monomials of meta-features in the first layer. Note that every time we fail to learn in Step 2(b) we know that at least one of the monomials that can make up the target polynomial (which is a metafeature second level of the true network) cannot be written as a conjunction of hypothesized first level metafeatures M\u0303 . Since we create M\u0303 by using Algorithm 3, by Theorem 3 we only need to learn at most n2 + k problems from from scratch (that is |TS| \u2264 n2 + k), and furthermore, k\u2032 \u2264 k. Note that while the sample complexity of Algorithm 6 is linear in k for problems learned from scratch, its running time is exponential in k, due to the work in creating the set conj(M\u0303). However, a poly(k) bound seems unachievable because it would require solving the junta learning problem. In particular, the problem of learning polynomials over k metafeatures is at least as hard as learning polynomials over {0, 1}k (because\neven if the true metafeatures were given to us in advance, one possibility is that the targets could be arbitrary polynomials over x1, . . . , xk). Thus, for this problem one should think of k as small."}, {"heading": "6 Discussion and Open Problems", "text": "In this work we present algorithms for learning new internal representations when presented with a series of learning problems arriving online that share different types of commonalities. For the case of linear threshold functions sharing linear subspaces, we require log-concave distributions to ensure that error can be both upper-bounded and lower-bounded by some \u201cnice\u201d function of angle: the lower bound helps to ensure that the span of accurate hypotheses is close to the span of their corresponding true targets (though one must be careful with error accumulation), and the upper-bound ensures that a sufficiently-close approximation to the span of the true targets is nearly as good as the span itself. It is an interesting question whether one can extend these results to distributions that do not have such properties while still maintaining the streaming nature of the algorithms (i.e., remembering only the learned rules and not the data from which they were generated). For the case of product metafeatures, our results have natural interpretations as autoencoders, which interestingly do not require assumptions such as the problem matrix being incoherent or a generative model, only the anchor-variable or anchor-set assumption. It would be interesting to see whether an analog of the anchor-set assumption could be applied to dictionary learning problems such as in [3].\nAcknowledgements This work was supported in part by NSF grants CCF-0953192, CCF-1451177, CCF1422910, IIS-1065251, ONR grant N00014-09-1-0751, AFOSR grant FA9550-09-1-0538, and a Microsoft Research Faculty Fellowship."}, {"heading": "A Proofs for halfspaces with more complex common structure", "text": "We now provide the algorithm and proof for Theorem 2.\nTheorem 2 Assume all marginals Di are isotropic log-concave and the target functions satisfy the above conditions. Consider \u03b3\u0303 \u2264 c , \u0303acc \u2264 c \u03b3\u0303 \u03c4 , \u03b3 \u2264 c\u0303acc, and acc \u2264 c \u03b3\u0303acc k for (sufficiently small) constant c > 0. Consider running Algorithm 2 with parameters , acc, and \u0303acc. Then k\u0303 \u2264 k and r\u0303 \u2264 \u03c4r. Moreover the total number of examples needed to learn all the problems to error is O\u0303(nk/ acc+kr/\u0303acc+m log(r)/ ).\nProof: We divide problems in two types: problems of type (a) are those for which we can learn a classifier of desired error at most by using the previously learnt metafeatures at the second middle level; the rest are of type (b).\nFor problems of type (a) we achieve error at most by design. For each problem i of type (b) we have either opened a new row in U\u0303 , and we have set w\u0303r\u0302 = \u03b1i, where r\u0302 is such that jr\u0302 = i or we have opened both a new row in r\u0302 in U\u0303 and a new row k\u0302 in W\u0303 , and set jr\u0302 = i and ik\u0302 = i. In both cases, by design and Lemma 1 (and the fact that acc \u2264 \u0303acc) we have \u03b8(u\u0303r\u0302W\u0303 , ajr\u0302) = O(\u0303acc); furthermore since c\u0303i = er\u0302 we also have \u03b8(a\u0303i, ai) = O(\u0303acc). Furthermore, for each u\u0303r\u0302 we create for a problem jr\u0302 we have that u\u0303r\u0302W\u0303 is \u03b3\u0303-far from the span of those vectors in {u\u03031, ..., u\u0303jr\u0302\u22121} whose corresponding targets lie in space Us, where Us is one of the r \u03c4 -dimensional subspaces that ajr\u0302 belongs to. (Otherwise if u\u0303r\u0302 is \u03b3\u0303-close we would have been able to learn sparsely to error based on the second level metafeatures.)\nUsing this together with the fact that \u0303acc = O( \u03b3\u0303 \u03c4 ), we obtain (by Lemma 3) that once we have \u03c4 second level meta-features u\u0303jl1 , . . . , u\u0303jl\u03c4 whose corresponding targets al1 , . . . , al\u03c4 lie in the same \u03c4 -dimensional\nspace Us, we have \u03b8(Us, span(u\u0303jl1W\u0303 , . . . , u\u0303jl\u03c4 W\u0303 )) = O(\u03c4 \u0303acc/\u03b3\u0303) \u2264 .\nTherefore we will be able to learn based on second level metafeatures any future target belonging to that subspace. This implies r\u0303 \u2264 \u03c4r. Using the fact that acc \u2264 c\u03b3\u0303acck , as in the proof of Theorem 1, we can prove by induction that for each w\u0303k\u0302 we create for a problem ik\u0302, we have aik\u0302 is \u03b3-far from span{ai1 , \u00b7 \u00b7 \u00b7 , aik\u0302\u22121} and w\u0303k\u0302 is \u03b3-far from span(w\u03031, ..., w\u0303k\u0302\u22121); this implies k\u0303 \u2264 k."}], "references": [{"title": "Convex multi-task feature learning", "author": ["A. Argyriou", "T. Evgeniou", "M. Pontil"], "venue": "Machine Learning Journal", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2008}, {"title": "Learning topic models - going beyond SVD", "author": ["Sanjeev Arora", "Rong Ge", "Ankur Moitra"], "venue": "In 53rd Annual IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "New algorithms for learning incoherent and overcomplete dictionaries", "author": ["Sanjeev Arora", "Rong Ge", "Ankur Moitra"], "venue": "In Proceedings of The 27th Conference on Learning Theory (COLT),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "The power of localization for efficiently learning linear separators with noise", "author": ["Pranjal Awasthi", "Maria-Florina Balcan", "Philip M. Long"], "venue": "In Symposium on Theory of Computing (STOC),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "Active and passive learning of linear separators under log-concave distributions", "author": ["M.-F. Balcan", "P.M. Long"], "venue": "Proceedings of the 26th Annual Conference on Learning Theory", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2013}, {"title": "A model of inductive bias learning", "author": ["J. Baxter"], "venue": "Journal of Artificial Intelligence Research", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2000}, {"title": "A bayesian/information theoretic model of learning to learn via multiple task sampling", "author": ["Jonathan Baxter"], "venue": "Machine Learning,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1997}, {"title": "Exploiting task relatedness for multiple task learning", "author": ["S. Ben-David", "R. Schuller"], "venue": "COLT", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}, {"title": "Deep learning of representations", "author": ["Y. Bengio"], "venue": "Looking forward,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "On the expressive power of deep architectures", "author": ["Y. Bengio", "O. Delalleau"], "venue": "ALT", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2011}, {"title": "Linear algorithms for online multitask classification", "author": ["G. Cavallanti", "N. Cesa-Bianchi", "C. Gentile"], "venue": "Journal of Machine Learning Research", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2010}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completeness", "author": ["Michael R. Garey", "David S. Johnson"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1979}, {"title": "How babies think", "author": ["A. Gopnik", "A. Meltzoff", "P. Kuhl"], "venue": "Orion", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2001}, {"title": "Baum\u2019s algorithm learns intersections of halfspaces with respect to log-concave distributions", "author": ["A.R. Klivans", "P.M. Long", "A. Tang"], "venue": "RANDOM", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "Learning task grouping and overlap in multi-task learning", "author": ["A. Kumar", "H. Daume III"], "venue": "NIPS", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "On-line learning of linear functions", "author": ["Nick Littlestone", "Philip M. Long", "Manfred K. Warmuth"], "venue": "Computational Complexity,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1995}, {"title": "The geometry of logconcave functions and sampling algorithms", "author": ["L\u00e1szl\u00f3 Lov\u00e1sz", "Santosh Vempala"], "venue": "Random Structures & Algorithms,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}, {"title": "Excess risk bounds for multitask learning with trace norm regularization", "author": ["A. Maurer", "M. Pontil"], "venue": "Proceedings of the 26th Annual Conference on Learning Theory", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2013}, {"title": "A complete analysis of the l 1, p group-lasso", "author": ["Volker Roth", "Julia E Vogt"], "venue": "In Proceedings of the 29th International Conference on Machine Learning", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2012}, {"title": "Learning sparse multivariate polynomials over a field with queries and counterexamples", "author": ["R.E. Schapire", "L.M. Sellie"], "venue": "Proceedings of the 6th Annual Conference on Computational Learning Theory", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1993}, {"title": "Lecture notes for 18.409: The behavior of algorithms in practice. Lecture 2: On the condition", "author": ["D. Spielman"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2002}, {"title": "Explanation-Based Neural Network Learning: A Lifelong Learning Approach", "author": ["S. Thrun"], "venue": "Kluwer Academic Publishers, Boston, MA", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1996}, {"title": "editors", "author": ["S. Thrun", "L.Y. Pratt"], "venue": "Learning To Learn. Kluwer Academic Publishers, Boston, MA", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1997}, {"title": "Lifelong robot learning", "author": ["Sebastian Thrun", "Tom M. Mitchell"], "venue": "Robotics and Autonomous Systems,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1995}, {"title": "A neuroidal architecture for cognitive computation", "author": ["L.G. Valiant"], "venue": "Journal of the ACM", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2000}, {"title": "A random-sampling-based algorithm for learning intersections of halfspaces", "author": ["S. Vempala"], "venue": "JACM, 57(6)", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2010}, {"title": "Mathematical Theories of Interaction with Oracles", "author": ["L. Yang"], "venue": "PhD thesis, CMU Dept. Machine Learning", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2013}], "referenceMentions": [{"referenceID": 12, "context": "Yet if we wish to produce machine learning systems that persist in the world, we need methods for continually learning many tasks over time and that, like humans [13], improve their ability to learn as they do so, needing less data (per task) as they learn more.", "startOffset": 162, "endOffset": 166}, {"referenceID": 21, "context": "A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist.", "startOffset": 71, "endOffset": 79}, {"referenceID": 23, "context": "A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist.", "startOffset": 71, "endOffset": 79}, {"referenceID": 0, "context": "A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist.", "startOffset": 103, "endOffset": 110}, {"referenceID": 17, "context": "A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist.", "startOffset": 103, "endOffset": 110}, {"referenceID": 6, "context": "A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist.", "startOffset": 134, "endOffset": 141}, {"referenceID": 22, "context": "A natural approach for tackling this goal (called \u201clife-long learning\u201d [23, 25] or \u201ctransfer learning\u201d [1, 19] or \u201clearning to learn\u201d [7, 24]) is to use information from previously-learned tasks to improve the underlying representation used by the learning algorithm, under the hope or belief that some kinds of commonalities across tasks exist.", "startOffset": 134, "endOffset": 141}, {"referenceID": 8, "context": "These commonalities could be a single low-dimensional or sparse representation, a collection of multiple low-dimensional or sparse representations, or some combination or hierarchy, such as in Deep Learning [9, 10].", "startOffset": 207, "endOffset": 214}, {"referenceID": 9, "context": "These commonalities could be a single low-dimensional or sparse representation, a collection of multiple low-dimensional or sparse representations, or some combination or hierarchy, such as in Deep Learning [9, 10].", "startOffset": 207, "endOffset": 214}, {"referenceID": 0, "context": "This case has been considered in the \u201cbatch\u201d setting in which one has data available for all target functions at the same time and therefore can solve a joint optimization problem [1, 19].", "startOffset": 180, "endOffset": 187}, {"referenceID": 17, "context": "This case has been considered in the \u201cbatch\u201d setting in which one has data available for all target functions at the same time and therefore can solve a joint optimization problem [1, 19].", "startOffset": 180, "endOffset": 187}, {"referenceID": 1, "context": "We give an efficient algorithm for finding the fewest product-based metafeatures for a given set of target monomials under an \u201canchor-variable\u201d assumption analogous to the anchor-word assumption of [2], and prove bounds on its performance for learning a series of target functions arriving online.", "startOffset": 198, "endOffset": 201}, {"referenceID": 6, "context": "Baxter [7, 6] developed some of the earliest foundations for transfer learning, by providing sample complexity results for achieving low average error in such settings.", "startOffset": 7, "endOffset": 13}, {"referenceID": 5, "context": "Baxter [7, 6] developed some of the earliest foundations for transfer learning, by providing sample complexity results for achieving low average error in such settings.", "startOffset": 7, "endOffset": 13}, {"referenceID": 7, "context": "Other related sample complexity results appear in [8].", "startOffset": 50, "endOffset": 53}, {"referenceID": 17, "context": "Recent work of [19, 16] considers the problem of learning multiple linear separators that share a common low-dimensional subspace in the batch setting where all tasks are given up front.", "startOffset": 15, "endOffset": 23}, {"referenceID": 14, "context": "Recent work of [19, 16] considers the problem of learning multiple linear separators that share a common low-dimensional subspace in the batch setting where all tasks are given up front.", "startOffset": 15, "endOffset": 23}, {"referenceID": 18, "context": "There has also been work on applying the Group Lasso method to batch multi-task learning which solves a specific multi-task optimization problem [20].", "startOffset": 145, "endOffset": 149}, {"referenceID": 10, "context": "[11] considers multi-task learning where explicit known relationships among tasks are exploited for faster learning.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "Discussion in [26] hints toward the type of the algorithms we analyze in Section 3, but without formal analysis about how the error accumulation could harm the sample complexity (which, as we will see, is one of the central challenges in this setting).", "startOffset": 14, "endOffset": 18}, {"referenceID": 21, "context": ", [23, 25]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 23, "context": ", [23, 25]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 16, "context": ", [18]), the above procedure will be successful and learn the target functions with much fewer labeled examples in total than by learning each function separately.", "startOffset": 2, "endOffset": 6}, {"referenceID": 4, "context": "Proof: The proof of the lower bound appears in [5].", "startOffset": 47, "endOffset": 50}, {"referenceID": 25, "context": "The proof of the upper bound is implicit in the earlier work of [27] \u2013 we provide it here for completeness.", "startOffset": 64, "endOffset": 68}, {"referenceID": 13, "context": "It is known [15] that for some constants k3, k4 we have g(z) \u2264 k3e4.", "startOffset": 12, "endOffset": 16}, {"referenceID": 20, "context": ", [22]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 4, "context": "In this case the sample complexity would be \u03a9(mn/ ) even under log-concave distributions [5].", "startOffset": 89, "endOffset": 92}, {"referenceID": 3, "context": "However, for log-concave distributions, there exist algorithms running in time poly(k, 1/ ) that find a near-optimal linear separator: in particular, one of error under the assumption that the optimal separator has error \u03b7 = / log(1/ ) [4], and with near-optimal sample complexity [14, 28].", "startOffset": 236, "endOffset": 239}, {"referenceID": 26, "context": "However, for log-concave distributions, there exist algorithms running in time poly(k, 1/ ) that find a near-optimal linear separator: in particular, one of error under the assumption that the optimal separator has error \u03b7 = / log(1/ ) [4], and with near-optimal sample complexity [14, 28].", "startOffset": 281, "endOffset": 289}, {"referenceID": 11, "context": "That is, given a collection of conjunctions, it is NP-hard to determine whether there exist k monomials such that each can be written as a product of subsets of those monomials (it is called the \u201cset-basis problem\u201d [12]).", "startOffset": 215, "endOffset": 219}, {"referenceID": 19, "context": "Efficiently learning polynomials requires membership queries (under the assumption that juntas are hard to learn) in addition to equivalence queries or random examples even in the single task setting [21].", "startOffset": 200, "endOffset": 204}, {"referenceID": 19, "context": "When learning from scratch we use an algorithm of Schapire and Sellie [21] that learns polynomials exactly.", "startOffset": 70, "endOffset": 74}, {"referenceID": 15, "context": "If the target function has an L1 norm bounded by B and its monomials can indeed be written as products of our metafeatures, then by considering all products of metafeatures and running an L1-based algorithm for learning linear functions [17], we can achieve low mean squared error using only O(B2 log(2k)) = O(B2k) examples.", "startOffset": 237, "endOffset": 241}, {"referenceID": 19, "context": "\u2022 Otherwise, run the algorithm of Schapire and Sellie [21] to learn the target Tr for problem r exactly based on the original feature representation with equivalence and membership queries.", "startOffset": 54, "endOffset": 58}, {"referenceID": 2, "context": "It would be interesting to see whether an analog of the anchor-set assumption could be applied to dictionary learning problems such as in [3].", "startOffset": 138, "endOffset": 141}], "year": 2014, "abstractText": "It has been a long-standing goal in machine learning, as well as in AI more generally, to develop lifelong learning systems that learn many different tasks over time, and reuse insights from tasks learned, \u201clearning to learn\u201d as they do so. In this work we pose and provide efficient algorithms for several natural theoretical formulations of this goal. Specifically, we consider the problem of learning many different target functions over time, that share certain commonalities that are initially unknown to the learning algorithm. Our aim is to learn new internal representations as the algorithm learns new target functions, that capture this commonality and allow subsequent learning tasks to be solved more efficiently and from less data. We develop efficient algorithms for two very different kinds of commonalities that target functions might share: one based on learning common low-dimensional and unions of low-dimensional subspaces and one based on learning nonlinear Boolean combinations of features. Our algorithms for learning Boolean feature combinations additionally have a dual interpretation, and can be viewed as giving an efficient procedure for constructing near-optimal sparse Boolean autoencoders under a natural \u201canchor-set\u201d assumption. ar X iv :1 41 1. 14 90 v2 [ cs .L G ] 4 D ec 2 01 4", "creator": "LaTeX with hyperref package"}}}