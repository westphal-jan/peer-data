{"id": "1505.03463", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-May-2015", "title": "Exploring Strategy-Proofness, Uniqueness, and Pareto Optimality for the Stable Matching Problem with Couples", "abstract": "millhouses The keratitis Stable munteanu Matching sarka Problem schill with Couples (SMP - C) xerez is upei a ubiquitous recitatives real - danshaku world yuraszeck extension teleomorph of bantered the stable matching problem (ceaseless SMP) airdropping involving dryvax complementarities. Although asakusa SMP can be solved in bunnicula polynomial 19xx time, 25-40 SMP - pleas C is campfire NP - #a Complete. zx81 Hence, horr it is ilbe not rastelli clear which, if lookups any, landberg of bronis the theoretical results 4,888 surrounding the canonical 67.27 SMP problem alcione apply radio-tv in seceding this syron setting. 29.15 In aguilas this freewheeling paper, alao we lingkaran use a hef recently - developed taketa SAT rechtsstaat encoding michigan to solve SMP - C sea-water exactly. nn This 48-7 allows grenda us to enumerate jenness all stable kisa matchings werk for any 22.13 given ata\u00edde instance jord\u00e1n of 42,083 SMP - omirou C. niggling With this tool, kurzem we empirically 1461 evaluate some unabridged of jeserich the triloba properties that have 29.62 been hypothesized to hold for n\u00e6stved SMP - C.", "histories": [["v1", "Wed, 13 May 2015 17:25:56 GMT  (555kb,D)", "http://arxiv.org/abs/1505.03463v1", null]], "reviews": [], "SUBJECTS": "cs.GT cs.AI", "authors": ["andrew perrault", "joanna drummond", "fahiem bacchus"], "accepted": false, "id": "1505.03463"}, "pdf": {"name": "1505.03463.pdf", "metadata": {"source": "CRF", "title": "Exploring Strategy-Proofness, Uniqueness, and Pareto Optimality for the Stable Matching Problem with Couples", "authors": ["Andrew Perrault"], "emails": ["perrault@cs.toronto.edu", "jdrummond@cs.toronto.edu", "fbacchus@cs.toronto.edu"], "sections": [{"heading": "1 Introduction", "text": "Stable matching problems are ubiquitous, with many realworld applications, ranging from dating markets, to labour markets, to the school choice problem. Arguably the most well-known of these applications is the residency matching problem [Niederle et al., 2008; Roth, 1984; Abdulkadiroglu et al., 2005], instantiated in the large National Resident Matching Program (NRMP), among others. Impor-\ntantly, these markets have adapted to the needs of their participants over the years, allowing them to more richly express their preferences, or guarantee certain properties of the match valuable to participants [NRMP, 2013]. To address the problem of couples wanting to coordinate their placements, the NRMP began allowing couples to jointly express their preferences over residency programs. We call the resulting matching problem the Stable Matching Problem with Couples (SMP-C).\nAs with the standard SMP, the goal of SMP-C is to find a matching such that no pair (one from each side of the market) has an incentive to defect from their assigned placement. Such a matching is called stable. In their seminal paper on stable matching, Gale and Shapley provide a polytime Deferred Acceptance (DA) algorithm guaranteed to find a stable, male-optimal (resident-optimal) matching [1962]. They also proved many useful properties of SMP; e.g., a unique stable matching always exists, and a stable resident-optimal matching always exists (a matching is resident-optimal if no resident is better off in any other stable matching).\nHowever, when a pair of doctors are allowed to jointly specify their rankings, many of these desirable properties no longer hold. In particular, SMP-C is NP-complete [Ronn, 1990]. Also, a stable matching might not exist. Even when it does exist a resident-optimal matching might not exist. SMP-C is not the only NP-complete extension of SMP. Previous literature on these other NP-complete extensions has investigated techniques that are not guaranteed to return stable matchings, such as local search techniques (e.g., [Marx and Schlotter, 2011; Gelain et al., 2010]). Another approach has entailed encoding these NP-complete stable matching problems (e.g., the stable matching problem with incomplete lists and ties) into other NP-complete formalisms such as constraint satisfaction problems (CSP) or satisfiability (SAT) (e.g., [Gent and Prosser, 2002; Gent et al., 2001; Unsworth and Prosser, 2005]). The advantage of such encodings is that effective solvers exist for CSP and SAT. However, these works do not address SMP-C.\nPrevious work on SMP-C has mainly focused on providing sound but not complete algorithms that extend the DA algorithm to deal with couples [Roth and Peranson, 1999; Kojima et al., 2013]. A new SAT encoding for SMP-C was recently developed [Drummond et al., 2015], showing very promising results when run on a competitive SAT solver\nar X\niv :1\n50 5.\n03 46\n3v 1\n[ cs\n.G T\n] 1\n3 M\nay 2\n01 5\n[Biere, 2013]. This encoding, SAT-E, scales fairly well, and is sometimes able find stable matchings for problems on which the DA-style algorithms cannot find any. Importantly, this new SAT encoding allows for flexibility unavailable in DAstyle algorithms: adding new constraints and objectives can be as simple as adding another constraint to the encoding.\nIn this paper, we use this flexibility to allow us to enumerate all possible stable matches of an instance of SMP-C. We also introduce a constraint that allows us to, given a stable solution to SMP-C, determine if that matching is resident Pareto optimal, and if it is not, find a resident Pareto optimal matching. This new machinery allows us to empirically evaluate interesting properties of SMP-C. In particular, we are interested in the following properties: when do instances of SMP-C have a unique matching? If an instance has multiple stable matchings, when is there a resident optimal matching? How does the existence of a stable matching change as the percentage of couples in the market increases?\nPrevious theoretical work has addressed some of these questions; Ashlagi et al. and Kojima et al. proved theoretical results regarding the guaranteed existence of a stable matching, if the size of the market grows sufficiently faster than the percentage of couples in the matching [2014; 2013]. Immorlica and Mahdian proved that, for SMP, and a fixed length ROL (with everyone drawing from some given distribution), the chance of drawing a problem with a unique stable matching goes to 1 as the size of the market goes to infinity. However, to our knowledge, no analogous results exist for SMP-C. We thus create our experiments in an attempt to simulate the settings in these papers.\nAlso, previous work has conjectured that some of the properties present in SMP may carry over to SMP-C. Roth and Peranson hypothesized that the reason that they see few opportunities for strategic behaviour in their data is that there are few stable matchings in large SMP-C markets [1999]. Furthermore, Roth and Peranson cite that strategy-proofness and resident optimality are desirable properties for stable matchings.\nIn this paper, we first provide a theoretical contribution, showing that, for SMP-C, we are not guaranteed resident strategy-proofness, even in a problem with a unique stable matching. We do show, however, when a matching has resident optimal solution, residents cannot manipulate via truncation; they must manipulate via reordering their preferences. We thus show that, for SMP-C, uniqueness and resident optimality are both insufficient for strategy-proofness, but, in certain situations, it is \u201charder\u201d for the residents to manipulate. We then provide two extensions to the already existing SAT-E encoding for SMP-C, allowing us to enumerate all stable matches and find a resident Pareto optimal match. We use these tools to empirically explore the space of SMP-C solutions. Our experiments suggest that Roth and Peranson\u2019s observation that there were few instances where residents could improve by truncation is due to the high fraction of instances that have a resident optimal matching, a fraction that appears to increase with instance size."}, {"heading": "2 Background", "text": "We cast our formalization of SMP-C (stable matching problem with couples) in terms of the well known residency matching problem, a labour market where doctors are placed into hospital residency programs [Roth and Peranson, 1999].\nInformally, doctors wish to be placed into (matched with) some hospital program, and programs wish to accept some number of doctors. Both doctors and hospitals have preferences over who they are matched with; expressed as ranked order lists (ROLs). Some doctors are paired into couples, and these couples provide a joint ROL specifying their joint preferences. Both doctors and hospitals can provide incomplete lists, any alternative not listed is considered to be unacceptable. That is, they would rather not be matched at all than matched to an alternative not on their ROL. The SMP-C problem to find a stable matching, such that no doctor-hospital pair has an incentive to defect from the assigned matching."}, {"heading": "2.1 SMP-C", "text": "More formally, let D be a set of doctors and P be a set of programs. Since there is a preference to be unmatched over an unacceptable match, we use nil to denote this \u201cdoctor\u201d or \u201cprogram\u201d alternative: matching a program p to nil indicates that p has an unfilled slot while matching a doctor d to nil indicates that d was not placed into any program. We use D+ and P+ to denote the sets D \u222a {nil} and P \u222a {nil} respectively.\nThe doctors are divided into two disjoint subsets, S \u2286 D and D \\ S . S is the set of single doctors and D \\ S is the set of doctors that are in couple relationships. We specify the couples by a set of pairs C \u2286 (D \\ S ) \u00d7 (D \\ S ). If (d1, d2) \u2208 C we say that d1 and d2 are each other\u2019s partner. We require that every doctor who is not single (i.e., every doctor in D \\ S ) have one and only one partner in C .\nEach program p \u2208 P has an integer quota capp > 0. This quota determines the maximum number of doctors p can accept (i.e., p\u2019s capacity).\nEveryone participating in the matching market has preferences over their alternatives. Each participant a specifies their preferences in a ROL which lists a\u2019s preferred matches from most preferred to least preferred. The ROLs of single doctors d \u2208 S contain programs from P+; the ROLs of couples c \u2208 C contain pairs of programs from P+ \u00d7 P+; and the ROLs of programs p \u2208 P contain doctors from D+. Every ROL is terminated by nil (couple ROLS are terminated by (nil ,nil)) since being unmatched is always the least preferred option, but is preferred to any option not on participant\u2019s a\u2019s ROL.\nThe order of items on a\u2019s ROL defines a partial ordering relation where x a y indicates that x appears before y on a\u2019s ROL or x = y. We define a, a, and a in terms of a and equality in the standard way. We say that x is acceptable to a if x a nil . (Note that unacceptable matches are not ordered by a.)\nWe define a choice function Chp() for programs p \u2208 P . Given a set of doctors R, Chp(R) returns the subset of R that p would prefer to accept. Chp(R) is the maximal subset of R such that for all d \u2208 Chp(R), d p nil , for all\nd\u2032 \u2208 R\u2212Chp(R), d p d\u2032, and |Chp(R)| \u2264 capp . It is convenient to give the null program a choice function as well: Chnil(O) = O, i.e., nil will accept any and all matches.\nWe use the notation ranked(a) to denote the set of options that a could potentially be matched with. For single doctors d and programs p this is simply the ROLs of d (rold) and p (rolp). For a doctor that is part of a couple (d1, d2), ranked(d1 ) = {p1|\u2203p2.(p1, p2) \u2208 rol (d1,d2)} \u222a {nil} and similarly for d2. Note that nil \u2208 ranked(a).\nFinally, we use the function ranka(x) to find the index of match x in a\u2019s rol : ranka(x) = i iff x appears at index i (zero-based) on a\u2019s ROL, rola, or |rola| if x does not appear on rola. Also we use rola as an indexable vector, e.g., if x is acceptable to a then rola[ranka(x)] = x."}, {"heading": "2.2 Stable Matchings", "text": "Definition 1 (Matching). A matching \u00b5 is a mapping from D to P+. We say that a doctor d is matched to a program p under \u00b5 if \u00b5(d) = p, and that p is matched to d if d \u2208 \u00b5\u22121(p).\nWe want to find a matching where no doctor-program pair has an incentive to defect. We call the pairs that do have an incentive to defect blocking pairs. First we define the condition willAccept(p,R, \u00b5) to mean that program p would prefer to accept a set of doctorsR over its current match \u00b5\u22121(p): willAccept(p,R, \u00b5) \u2261 R \u2286 Chp(\u00b5\u22121(p) \u222a R). Note that if p is already matched to R under \u00b5 then p will accept R. Definition 2 (Blocking Pairs for a Matching \u00b5). 1. A sin-\ngle doctor d \u2208 S and a program p \u2208 P is a blocking pair for \u00b5 if and only if p d \u00b5(d) and willAccept(p, {d}, \u00b5)\n2. A couple c = (d1, d2) \u2208 C and a program pair (p1, p2) \u2208 P+ \u00d7 P+ with p1 6= p2 is a blocking pair for \u00b5 if and only if (p1, p2) (d1,d2) (\u00b5(d1), \u00b5(d2)), willAccept(p1, {d1}, \u00b5), and willAccept(p2, {d2}, \u00b5).\n3. A couple c = (d1, d2) and a program p \u2208 P is a blocking pair for \u00b5 if and only if (p, p) (d1,d2) (\u00b5(d1), \u00b5(d2)) and willAccept(p, {d1, d2}, \u00b5).\nDefinition 3 (Individually Rational Matching). A matching \u00b5 is individually rational if and only if (a) for all d \u2208 S , \u00b5(d) d nil , (b) for all c = (d1, d2) \u2208 C , (\u00b5(d1), \u00b5(d2)) c (nil ,nil), and (c) for all p \u2208 P , |\u00b5\u22121(p)| \u2264 capp and for all d \u2208 \u00b5\u22121(p) we have that d p nil . Definition 4 (Stable Matching). A matching \u00b5 is stable if and only if it is individually rational and no blocking pairs for it exist."}, {"heading": "2.3 Residence Preferred Matchings", "text": "The set of stable matchings can be quite large. When there are no couples (i.e., in SMP) this set is always non-empty [Gale and Shapley, 1962] and has a nice structure: it forms a lattice under the partial order R defined below [Knuth, 1976]. Definition 5 (Residence Preferred Matchings). A matching \u00b51 is resident preferred to another \u00b52 when for all a \u2208 S \u222aC we have that \u00b51(a) a \u00b52(a). We denote this relationship as \u00b51 R \u00b52. We also define R, \u227aR, and R in terms of R and equality in the standard way. When \u00b51 R \u00b52 we say that \u00b51 dominates \u00b52.\nIn other words, \u00b5i R \u00b52 if every doctor and couple gets the same or a better match in \u00b51 as in \u00b53 and at least one doctor or couple gets a better match.\nThe lattice structure and the fact there can only be a finite number of matchings means that for SMP there is always a resident-optimal matching.\nDefinition 6 (Resident Optimal Matching). We say that a matching \u00b5 is resident optimal, written Ropt(\u00b5) when \u00b5 is stable and \u00b5 R \u00b5\u2032 for all other stable matchings \u00b5\u2032 (\u00b5 dominates all other stable matchings).\nNote that, we restrict the resident-optimal matching to be stable. It can be observed that for any resident r (couple (r1, r2)) \u00b5(r) ((\u00b5(r1), \u00b5(r2)) is the best match offered by any stable matching whenRopt(\u00b5).\nResident-optimality is generally cited as an important property for stable matching algorithms (e.g., [Gale and Shapley, 1962; Roth and Peranson, 1999]). In the presence of couples however, stable matchings might not exist and even when they do there have no lattice structure under R. However, the R is still well defined and for SMP-C leads to potentially multiple Pareto optimal matchings.\nDefinition 7 (Resident Pareto Optimal Matchings). We say that a matching \u00b5 is resident Pareto optimal, written RPopt(\u00b5) when \u00b5 is stable and there does not exist another stable matching \u00b5\u2032 such that \u00b5\u2032 R \u00b5\u2032.\nIt is easy to see that in SMP-C every stable matching \u00b5 either is an RPopt or is dominated by an RPopt matching. This means that an SMP-C instance has an Ropt matching if and only if it has a uniqueRPopt matching. As we will see in Section 5 it is often the case that SMP-C instances have more than oneRPopt matching (and thus noRopt matching).\n3 Strategy-Proofness andRopt Existence for SMP-C\nFor an SMP instance the mechanism that returns the Ropt matching in response to the stated preferences is strategyproof with respect to the residents. That is, it is a dominant strategy for each resident to state their true preferences [Roth and Sotomayor, 1992].\nTo our knowledge, no strategy-proofness results exist for SMP-C. However, this result for SMP leads us to hypothesize that if we restrict our attention to SMP instances in which an Ropt matching exists, then a mechanism that returns the Ropt matching is strategy-proof. Unfortunately, this is not true; furthermore, the even stronger condition of there being a unique stable matching for a problem instance doesn\u2019t guarantee strategy-proofness for the residents (let alone the hospitals). However, we do show that when there is an Ropt matching, residents have no incentive to misreport their preferences via truncation.\nTheorem 1. Restricting to instances of SMP-C in which an Ropt matching exists, let y() be a mechanism that maps from such an instance to the Ropt matching. Then y is strategyproof for residents if residents are only allowed to manipulate via truncations. However, y might not be strategy-proof if residents are allowed to manipulate via reordering.\nProof. Let \u00b5\u2217 be theRopt matching. Part I: Truncations are strategy-proof. Suppose resident or couple d truncates its preferences at program or pair of programs p. Let \u2126 be the set of stable matchings before the truncation and let \u2126\u2032 be the set of stable matchings after the truncation. Because d\u2019s preferences above the truncation point are the same after truncation, any matching \u00b5 \u2208 \u2126\u2032 where \u00b5(d) 6= nil (resp. \u00b5(d) 6= (nil ,nil) for a couple d) is in \u2126: the stability conditions contributed by other residents and couples are the same after d\u2019s truncation. However, \u2126\u2032 may contain stable matchings where d is matched to nil that are not in \u2126. Thus {\u00b5 \u2208 \u2126\u2032 : \u00b5(d) 6= nil} \u2286 \u2126.\nThere are two cases: either 1) d truncates below \u00b5\u2217(d) or 2) d truncates at or above \u00b5\u2217(d). In the former, it can be seen that \u00b5\u2217 is a stable matching of \u2126\u2032 and the only matches in \u2126\u2032 not in \u2126 have d matched to nil . Hence, \u00b5\u2217 is an Ropt matching for \u2126\u2032 and d cannot improve. In the latter, \u2126\u2032 consists of matchings where d is matched to nil because any \u00b5 \u2208 \u2126\u2032 such that \u00b5(d) d \u00b5\u2217(d) would be in \u2126 and would contradict \u00b5\u2217\u2019sRopt status. Hence, d cannot improve in this case either.\nPart II: Reordering is not strategy-proof. We provide a counterexample. See Figure 1. The preferences provided above the line show doctors\u2019 and programs\u2019 true preferences. Couples are identified by their doctor-doctor pair, and give joint preferences as expected. Given these true preferences, only one stable matching exists (shown in the third column above the line). However, even though only one stable matching exists (and thus this matching is Ropt ), the single doctor r0 has incentive to misreport preferences via reordering. Instead of reporting a b c d (r0\u2019s true preferences) r0 can be matched to b instead of c by reporting b d c a. (All other participants in the market report their true preferences.) This results in the matching seen in the third column below the line, a matching that is not stable under the original preferences, where single doctor r0 is better off than when they reported their true preferences.\nRoth and Peranson investigate strategy-proofness for both residents and hospitals empirically in the NRMP setting [1999]. They do this via truncations. In their setting, they do find that residents can benefit (albeit minimally) from truncating their true preferences. We then hypothesize that this is due either: i) the instances in their setting frequently do not contain an Ropt matching, or ii) their algorithm (RP99) does not find the Ropt matching even when it does exist. In Section 5 we will see that both of these situations can occur. That is, on many problems noRopt matching exists (the best one can do is an RPopt matching). And even when an Ropt matching does exist, their algorithm might not find it, reporting some other stable matching instead."}, {"heading": "4 Solving SMP-C", "text": "In this section we examine solution methods for finding stable matchings for SMP-C. The standard approach has been to find an extension of the deferred acceptance algorithm that can handle couples. However, these extensions are incomplete: they are unable to determine whether or not a stable matching exists, and even when a stable matching does exist they might not be able to find one.\nSince SMP-C is known to be NP-Complete [Ronn, 1990] it is also possible to encode it as another NP-Complete problem. In particular, it can be encoded as a SAT (satisfiability) problem. The advantage of doing this is that there has been a great deal of work on SAT solvers and state-of-the-art SAT solvers are routinely able to solve SAT problems involving millions of clauses.1 The advantage of encoding SMP-C to SAT and then using a SAT solver is that this approach is complete: given sufficient compute resources it will either find a stable matching or prove that none exists."}, {"heading": "4.1 Existing DA Algorithms for SMP-C", "text": "The basic principle of DA algorithms [Gale and Shapley, 1962] is that members of one side of the market propose down their ROLs while the other side either rejects those proposals or holds them until they see a better proposal: once all proposals have been made that side accepts the proposal they have not rejected (acceptance of proposals is deferred until the end).\nRoth and Peranson develop a DA algorithm, RP99, capable of dealing with couples [1999]. This well known algorithm has been used with considerable success in practice, including most famously for finding matches for the NRMP which typically involves about 30,000 doctors [NRMP, 2013]. Using the description in [Roth and Peranson, 1999] we have implemented RP99. RP99 employs an iterative scheme. After computing a stable matching for all single doctors, couples are added one at a time and a new stable matching computed after each addition. The algorithm uses DA at each stage to find these stable matchings. Matching a couple can make previously made matches unstable and in redoing these matches the algorithm might start to cycle. Hence, cycle checking (or a timeout) is sometimes needed to terminate the algorithm.\nKojima et al. develop a simple \u201csequential couples algorithm\u201d [2013]. This algorithm is analyzed to prove that the probability of a stable matchings existing goes to one under certain assumptions. However, this simple algorithm is not useful in practice as it declares failure under very simple conditions. Kojima et al. also provide a more practical DA algorithm, KPR, that they use in their experiments. We have implemented KPR. The main difference between KPR and RP99 is that KPR deals with all couples at the same time\u2014it does not attempt to compute intermediate stable matchings. Interestingly, this makes KPR much more successful (and efficient) in our experiments.\nFinally, Ashlagi et al. extend the analysis of Kojima et al., developing a more sophisticated \u201cSorted Deferred Acceptance Algorithm\u201d and analyzing its behaviour [2014]. This algorithm is designed mainly to be amenable to theoretical analysis rather than for practical application. We have not implemented this algorithm so we do not include any empirical results about its performance."}, {"heading": "4.2 Solving SMP via SAT", "text": "We have developed an effective encoding of SMP-C into SAT. This encoding and its performance is reported on in [Drum-\n1Of course, since SAT is NP-Complete these solvers can also be foiled by small SAT instances. Nevertheless, they often exhibit very good performance on instances that arise from real world problems.\nmond et al., 2015].2 We call this encoding SAT-E, and given an SMP-C instance \u3008D ,C ,P ,ROLs\u3009, where ROLs is the set of all participant ROLs, SAT-E(\u3008D ,C ,P ,ROLs\u3009) can be viewed as a function that returns a SAT encoding in CNF (conjunctive normal form), which is the input format taken by modern SAT solvers.\nThere are three things to know about SAT-E. 1. For any SMP-C instance I = \u3008D ,C ,P ,ROLs\u3009, the\nsatisfying models of SAT-E stand in a one-to-one correspondence with the stable models of I. This allows us to enumerate all stable models (see below).\n2. SAT-E includes the set of propositional variables md[p] one for each d \u2208 D and p \u2208 D such that p d nil . In any satisfying model, \u03c0, md[p] is true if and only if \u00b5(d) = p in the stable matching \u00b5 corresponding to \u03c0.\n3. SAT-E also includes the set of propositional variables mc[i] for each c \u2208 C and i in the range [0, |rolc \u2212 1|] where rolc is c\u2019s ROL. In any satisfying model, \u03c0, mc[i] is true if and only if in \u00b5, the stable matching corresponding to \u03c0, c is matched to a program pair they rank i or above in their ROL.\nGiven SAT-E and the above three facts we can develop two simple yet powerful algorithms: one for enumerating all stable models and the other for finding a Pareto Optimal matching, an RPopt matching, that dominates a stable matching \u00b5.\nAlgorithm 1 is our algorithm for enumerating all stable models. It uses a sequence of calls to a SAT solver to do this. It first constructs the SAT-E encoding of the SMP-C instance then enters a loop. Each time through the loop a new stable model is found by the SAT solver, and a blocking clause c\n2For the reader\u2019s convenience we have included a description of this encoding in the appendix. See [Drummond et al., 2015] for full details.\nALGORITHM 1: Enumerate all stable models of an inputted SMP-C instance Input: I = \u3008D ,C ,P ,ROLs\u3009 an SMP-C instance Output: Enumerate all stable models of a I\n1 CNF \u2190 SAT-E(I) 2 while true do 3 (sat?,\u03c0) \u2190 SatSolve(CNF)\n/* SatSolve returns the status (sat or unsat) and a satisfying model \u03c0 if sat */\n4 if sat? then 5 \u00b5\u2190 stable matching corresponding to \u03c0 6 c\u2190 {\u00acmd[p] |\u00b5(d) = p} 7 CNF \u2190 CNF \u222a {c} 8 enumerate(\u00b5) 9 else\n10 return // All stable matchings enumerated.\nis added to the SAT-E encoding. This clause c is a disjunction that says that no future solution is allowed to return the same stable model (one of the mappings \u00b5(d) = p of the corresponding stable model must be different, i.e., one of the variables md[p] made true by \u00b5 must be false in every future matching).\nAlgorithm 2 is our algorithm for finding aRPopt matching that dominates an inputted stable matching \u00b5. The algorithm takes an SMP-C instances as input and constructs the SAT-E encoding for that instance. It then blocks the match \u00b5 from being a satisfying solution (using the same kind of clause as Algo. 1) and also forces the next match found to be R the current match. It accomplishes this by adding a clause for each single doctor d that says that d must be matched to a program it ranks at least as high as \u00b5(d), and for every couple c a (unit) clause that says that c must be matched to a pair of programs it ranks at least as highly as \u00b5(c). This causes the new match to be R to the current match, and since the new match cannot be equal it must be R the current match. That\nALGORITHM 2: Given an SMP-C instance and a stable matching \u00b5 find a dominatingRPopt matching. Input: I = \u3008D ,C ,P ,ROLs\u3009 an SMP-C instance and \u00b5 a stable matching for I Output: AnRPopt matching for I that dominates \u00b5\n1 while true do 2 CNF \u2190 SAT-E(I) 3 c\u2190 {\u00acmd[p] |\u00b5(d) = p} 4 CNF \u2190 CNF \u222a {c} 5 for d \u2208 S do 6 cd \u2190 {md[p] | p d \u00b5(d)} 7 CNF \u2190 CNF \u222a {cd} 8 for c \u2208 C do 9 cc \u2190 {mc[i] | i = rankc(\u00b5(c))}\n10 CNF \u2190 CNF \u222a {cd} 11 (sat?,\u03c0) \u2190 SatSolve(CNF) 12 if sat? then 13 \u00b5\u2190 stable matching corresponding to \u03c0 14 else 15 return \u00b5 // Return last match found.\nis, the new match must dominate the current match. If no dominating match can be found, the current match is RPopt and we return it."}, {"heading": "5 Empirical Results", "text": "In this section we report on various experiments we performed. We used the state-of-the art SAT solver LingeLing [Biere, 2013] to solve our encoding SAT-E; Algorithm 1 to find all stable matches; and our implementation of the two DA algorithms RP99 and KPR, described in Section 4.1, when testing the effectiveness of DA algorithms."}, {"heading": "5.1 Statistical models", "text": "We experiment with randomly generated SMP-C instances. In our experiments we confine our attention to instances in which all program quotas are 1. So these are one-to-one matching problems with couples.\nWe generate ordered lists from sets using a common random sampling procedure. To obtain an ordered list L of size k from a set S, given that we already generated the first i items, we draw elements from S independently and uniformly at random until we find an element e that does not already appear in L. Once we have selected such an e it becomes the i+ 1\u2019th item of L. This process stops when L has k items.\nWe use market sizes of size n where n ranges from 200 to 20,000, and varying percentages x of couples. For each n we include n doctors in D and n programs in P . Among the doctors we mark 1 \u2212 x percent as being singles and the remaining x percent are paired into couples. (Thus we have x \u2217 n/2 couples and n \u2212 x \u2217 n singles). For each single we randomly generate an ordered ROL of length 5 from P (using the procedure described above), each couple has an ROL of length 15 randomly generated from P+\u00d7P+\u2212{(nil ,nil)}, and each program has an ROL that includes all doctors that ranked it (including one member of a couple) and is randomly generated from that same set. For each setting of the parameters, we drew 50 problem instances."}, {"heading": "5.2 Experiments", "text": "Existence of a Stable Matching in SMP-C Our first experiment involves running a SAT solver on each SMP-C instance. This allows us to determine how often these instances had a stable match. Figure 2 shows the trend. We see that as the fraction of residents who are in couples increases, the fraction of satisfiable instances drops fairly rapidly. Interestingly, it appears as though this effect is independent of the size of the market; for all market sizes drawn, the fraction of satisfiable instances is fairly consistent, and follows the same trend. These results agree with the predictions of Ashlagi et al. who showed that in a random model similar but not identical to ours whenever the number of couples grows linearly with market size, the probability of no stable matching existing is a constant. This agrees with our data that market size has little effect. There model was not, however, able to predict what that probability might be, nor how it might change as the percentage of couples increases.\nIt can also be noted that the results presented here (20,000 couples with an average single\u2019s ROL of size 5) are of a size comparable to the NRMP, where there are 34,355 residents with an average single\u2019s ROL of size 11 [NRMP, 2013]. On NRMP Roth and Peranson [1999] remark that historically no instance was found not to have a stable matching. This might arise from (a) the percentage of couples being very small for NRMP, or (b) extra structure in this real problem not present in our random problems. If the cause is (a) there might be practical concerns for the ability of clearinghouse mechanisms to find stable matchings if the percentage of couples rises.\nExistence of a Unique Stable Matching in SMP-C Figure 3 shows the fraction of instances that had a unique stable matchings as the size of the market increases, and as the percentage of the couples in the market increases. Importantly, this figure only counts the fraction of instances with a unique matching among those instances that have at least one matching. This data was generated by running Algo. 1.\nAs shown in Figure 2, the fraction of instances where a stable matching exists changes as the percentage of couples in the market changes. So to remove that underlying trend, we only look instances where a stable matching is known to exist.\nNote that, while these curves generally mimic the pattern we\u2019d expect to see (the fraction of unique matchings tends to increase as the market size gets larger), the curve appears to level out and reach an asymptote much earlier than expected. In our experiments, no setting reached more than 84% unique matchings.\nImmorlica and Mahdian proved that, for SMP (where at least one stable matching is always true) with fixed length ROLs (and everyone drawing from some given distribution), the chance of drawing a problem with only one stable matching goes to 1 as the size of the market goes to infinity [2005].\nOur trends for SMP-C, however, appear somewhat asymptotic, especially when the percentage of couples is low. It thus appears that, at least for the size of problems relative to the size of ROL investigated here, that the Immorlica and Mahdian results do not apply. This could be because their results give very large bounds that require the size of the problems to be much larger than drawn here. So our results might not be on sufficiently large markets to capture the phenomenon they describe. Alternately, this could be because their results do not hold for SMP-C.\nAs an aside, when comparing the fraction of unique satisfiable instances out of all problem instances drawn, the numbers look even worse; with a market size of 20,000 and 20% couples, the percentage of problems drawn with only one stable matching drops to 50%.\nProperties of the Set of Matchings for SMP-C We next investigate the properties of the set of matchings of each SMP-C instance as generated by Algorithm 1. We have shown that, at least under the settings explored in this paper, unique stable matches are not as common as we may have hypothesized. We also have proven that, even if a unique\nmatching exists (and hence it is an Ropt matching), that is no guarantee of strategy-proofness on either the residents\u2019 or programs\u2019 side for SMP-C.\nNevertheless, we have also shown that if residents are only allowed to truncate their preferences (which is arguably the easiest misreporting strategy), then they have no incentive to misreport if an Ropt matching exists. Since an Ropt matching can exist even when there more than one stable matching, this can be a useful situation that covers more cases than having only one stable matching.\nFigure 4 shows our results about this question. The boxes in this plot represents the average number of stable matches for different problem parameters; the whisker represents one standard deviation. For the problems we investigated, the average number of stable matchings was quite low (1.30), and did not seem to be affected much by either the size of the market, or the percentage of couples involved in the market. Note that exceedingly few problem instances have more than 3 stable matches, no matter how the parameters are set. Also, in each setting of the parameters, problem instances with one and two stable matchings are very common. Note that, unlike the previous analysis presented in Figure 2, we are looking at all problem instances, not just the satisfiable ones.\nIn the problems we investigated, 10.63% had no stable matching, 61.91% had a unique stable matching, 21.89% had two stable matchings, 0.31% had three stable matchings, 4.69% had four stable matchings, 0.13% had six stable matchings, and 0.44% had eight stable matchings.\nWhen a problem instance has more than one stable matching, we are particularly interested in how many RPopt matchings exist. If only one RPopt matching exists this matching is also an Ropt matching, and our theoretical result applies: residents have no incentive to misreport their preferences by truncation. 78.5% of all problem instances drawn had an Ropt matching, which is many more instances than simply had a single stable matching (61.91%). Addition-\nally, if we again look at the Immorlica and Mahdian results, but with respect to fraction of satisfiable instance that had an Ropt matching instead of the more restrictive condition of having only one stable matchings, we see a trend much closer to what we might expect. See Figure 5. Furthermore, many instances with a low percentage of couples almost always had an Ropt matching; when the market had 1% couples, 98.5% of all satisfiable instances had an Ropt matching; with 5%, 92.7% had anRopt matching. Importantly, this means that for many of the problem instances that we drew, residents have no incentive to misreport their preferences via truncation. However, further investigation is required to ascertain the relationship between the percentage of couples in a matching and the fraction of instances that have an Ropt matching.\nFinally, looked at those instances with more than one stable matching to see how many, on average, RPopt matchings they contain. We found that in some cases RPopt matchings are quite common. When there are two stable matchings for a given problem instance, there were an average of 1.36RPopt matchings per problem. Instances with 3 stable matchings always had 3 RPopt matchings per problem. Instances with 4 stable matchings had an average of 1.69 RPopt matchings per problem, and instances with 8 stable matchings had an average of 4RPopt per problem."}, {"heading": "5.3 Structure of SMP-C Problem Instances", "text": "In this section we examine some finer grained structure among the set of stable matchings. We examined the stable matchings and a basis for the set of Pareto improving moves. A Pareto improving move is the set of resident transfers needed to transform matching \u00b52 to matching \u00b51 when \u00b51 R \u00b52 (i.e., the transfers improve the match). Improving moves that are the result of combining other improving are not counted as part of the basis.\nWe show this structure as a directed graph, where nodes are stable matchings for a given instance, and an edge goes from node a to b if there is a Pareto improving move transforming\na to b. (Note this implies that b R a. Note this graph is not guaranteed to be connected, and in practice, many of these graphs have multiple components. By definition, each component will contain at least one RPopt matching. While it appears to be exceedingly rare for any component to contain more than one component (at least in the problems we generated), we did find one component with twoRPopt matchings.\nFor an illustration of what these components and the possible Pareto improving moves may look like, see Figure 6. For the problem instance chosen, there were 8 stable matchings, 2 of which were RPopt matchings. Each node in the graph contains a tuple of the singles\u2019 and couples\u2019 average rank; each edge on the graph is the maximum improvement for any single and any couple from the previous match to the new Pareto improved match.\nAlso note that in this problem instance, on average, one of these RPopt matchings is better for couples (by 0.03 positions on average) and one of theseRPopt matchings is better for singles (by 0.0002 positions on average). Interestingly, there are very few unique Pareto optimal moves in this graph; there are only two. This tends to hold in general; when there are two stable matchings, there are an average of 0.64 unique Pareto moves per problem. With 4 stable matchings, there are an average of 1.48 Pareto moves.\nNote that, for the single that has the greatest incentive to go from one matching to another, they have quite a high incentive\u2014almost their entire ROL. (Remember, singles give a ROL of size 5.) Note that Figure 6 shows a case where only single residents improve; this is not true in the general case. Couples, likewise, can greatly benefit from moving from a non-Pareto optimal matching to a RPopt matching. Additionally, some singles and couples will strongly prefer one RPopt matching over another; in this example, the maximum incentive for any single to switch from the RPopt matching on the left to the one on the right is moving up their ROL 3 positions. In this example, there is no incentive for couples to switch from theRPopt matching on the left to the one on the right. For switching from the RPopt matching on the right to the one on the left, the maximum incentive for any single to move is one position in their ROL, and 3 positions for any couple. In this instance, both of the DA algorithms KPR and RP99 found the sameRPopt matching, denoted by the square node in the graph. While KPR and RP99 are not guaranteed to find anRPopt matching, they did in this instance.\nWhile in this example, there is little incentive to switch from one RPopt matching to another, there were instances\nin the data where at least one single could move up their entire preference list by switching from one RPopt matching to another, and at least one couple could move up their entire preference list by switching from one RPopt matching to another."}, {"heading": "5.4 The Performance of DA Algorithms for SMP-C", "text": "We are also interested in how the standard DA-style algorithms perform with respect to findingRPopt matchings. As Roth and Peranson mention that resident optimality is an important design aspect for stable matching algorithms, we investigate how frequently the DA algorithms find a RPopt matching. We do this by using Algo 1 to enumerate all possible stable matchings for each problem instance. We then identify all RPopt matchings, and then see if the DA algorithms find a RPopt matching for that instance. Table 5.4 shows these results. We did not find much of a relationship between the size of the problem and how frequently the DA algorithms found anRPopt matching, so we combine all problem sizes for this analysis. Note that, when analyzing the % of times the DA algorithm found an RPopt matching, we only look at problems where (a) more than one stable matching exists (if only one stable matching exists, that solution is automatically anRPopt matching) and (b) the DA algorithm found a matching (the DA algorithms have different failure rates and we wanted to directly compare only when they succeed.) Table 5.4 also shows the general failure rate for the DA algorithms (i.e., when at least one stable matching exists, but the algorithm fails to find one).\nCritically, note that even though the DA algorithms were designed to be as resident favoring as possible, they do not find an RPopt matching in a large percentage of problems with multiple stable matchings. When the percentage of couples is low, the DA algorithms\u2019 performance is either perfect, or fairly good (with about a 5% failure rate). For problems with roughly the same percentage of couples as the NRMP (roughly 6%) the failure rate of KPR and RP99 to find a RPopt matching is fairly low, at 5% (though KPR\u2019s failure rate is slightly higher.) However, with more couples in the match, the failure rate jumps to roughly 10%. Again, in all of these settings, SAT-E with the additional constraints was able to enumerate all stable matchings, including all RPopt matchings.\nIt appears as though RP99 finds an RPopt matching with\na slightly higher rate than KPR when it finishes. These two algorithms deal with couples fairly differently (as RP99 has couples propose individually, and couples propose in-batch in KPR), which could account for the difference in performance. However, KPR outperforms RP99 by a large margin with respect to the percentage of problem instances solved. KPR\u2019s failure rate is less than 0.25% for all problems with 10% or less couples, and only 5.75% when the match has 20% couples. RP99\u2019s failure rate grows quickly, reaching 36.25% by the time couples consist of 20% of the market. Therefore, it seems as though there is a slight benefit to using RP99 to find RPopt matchings, but its large failure rate may negate this benefit."}, {"heading": "6 Discussion and Future Work", "text": "In this paper, we have provided new theoretical results on strategy-proofness for SMP-C, and new extensions to an existing SAT encoding for SMP-C that allows us to both enumerate every stable matching for a given problem instance, and guarantee that we\u2019ve found aRPopt matching if we don\u2019t have the resources to enumerate all instances. We then used these techniques to explore properties of SMP-C instances.\nWe used these tools to empirically investigate previous theoretical results. Interesting, and perhaps unexpectedly, the Immorlica and Mahdian results (given a constant list size, the probability of a unique stable matching goes to one as the market size increases) did not seem to hold. However, we empirically found evidence for a related phenomenon for SMP-C, leading us to the following conjecture: for problem instances drawn from the same distribution with a fixed ROL size of k, the probability of a resident optimal stable matching goes to one as the size of the market goes to infinity.\nWe also empirically evaluated RP99 and KPR, two DAstyle algorithms for SMP-C that do not have any theoretical guarantees. While they frequently perform well on the problem instances we drew, we found many problem instances where they either did not find a stable matching at all even though one existed, or if they did find one, they did not find a RPopt matching. In practice, it would be a simple to use our algorithm 2 to improve the matching found by these algorithms.\nBy enumerating all possible stable matchings (and thus all resident Pareto optimal matchings for a given matching), we can now pick stable matchings based on certain properties. Enumerating the set of all stable matchings allows us to pick the matching with the best average rank for all singles and couples (a sort of resident social-welfare optimal matching), or the stable matching that places the worst-off individual as high in their preference rankings as possible. While we did not empirically evaluate this in this paper, being able to enumerate all stable matchings allows for a rich investigation into this problem.\nOur overall conclusion is that encoding to SAT is a powerful tool for further empirical analysis of stable matching problems. The research question that arises is how best to use this tool and how this tool can be adapted to obtain insight into other important open questions about NP-complete stable matching problems. The current paper has shown that\nthis tool has already exposed some interesting theoretical questions. For example, what can be proved about the frequency in which resident-optimal matchings appear in randomly drawn SMP-C instances as the market size increases; is there further structure to the set of RPopt solutions; can the existence of a resident-optimal matching or conditions on the set of RPopt solutions be used to prove further strategyproof results for SMP-C.\nIn addition to theoretical results, there is considerable potential for practical computation of stable matchings. For example, using both DA algorithms, and algorithm 2 to improve the resulting matching might have some very useful applications. It might also be the case that solving SAT-E with additional constraints might be applicable to some currently unsolved practical matching problems. Acknowledgements. This work is supported by the Natural Sciences and Engineering Research Council of Canada. Perrault and Drummond are additionally supported by an Ontario Graduate Scholarship."}, {"heading": "A SAT Encoding for the Stable Matching Problem with Couples", "text": "In this appendix we provide an encoding of SMP-C into SAT. SMP-C was shown to be an NP-Complete problem by Ronn [Ronn, 1990]. Hence, it can be encoded and solved as a satisfiability problem (SAT). This is an attractive approach for solving SMP-C due to the recent tremendous advances in SAT solvers.\nThe encoding of SMP-C we give here forms the basis of Drummond et al. [2015]. Nevertheless, since we extend this SAT encoding in order to find Pareto optimal matchings and to find all stable matchings, we provide its details in this appendix (which will only be available on-line).\nFirst we assume that the doctor (singles and couples) rols have been preprocessed so as to remove from them any program that does not find that doctor acceptable. For d \u2208 S we remove p from rold if d /\u2208 rolp. For couple (d1, d2) \u2208 C we remove (p1, p2) from rol (d1,d2) if d1 /\u2208 rolp1 or d2 /\u2208 rolp2 . This ensures that in any matching found by solving the SAT encoding no doctor d can be matched into a program that does not rank d.\nA SAT encoding consists of a set of Boolean variables and a collection of clauses over these variables. We first describe the set of variables and their intended meaning, and then we present the clauses which enforce the conditions required for a stable matching.\nA.1 Variables We utilize three sets of Boolean variables. 1. Doctor Matching Variables:\n{md[p] | d \u2208 D \u2227 p \u2208 rold} md[p] is true iff d is matched into program p. Note that md[nil ] is true if d is unmatched. 2. Couple Matching Variables:\n{mc[i] | c \u2208 C \u2227 (0 \u2264 i < |rolc|)} mc[i] is true iff couple c is matched into a program pair (p, p\u2032) that it ranks between 0 and i, i.e., 0 \u2264 rank c((p, p\u2032)) \u2264 i. (Lower ranks are more preferred). 3. Program Matching Variables: {mp[i, s] | p \u2208 P \u2227 (0 \u2264 i \u2264 |rolp| \u2212 2)\n\u2227 (0 \u2264 s \u2264 min(i+ 1, capp + 1))} mp[i, s] is true iff s of the doctors in rolp[0] to rolp[i] have been matched into p. Note that i ranges up to |rolp|\u22122 which is the index the last non-nil doctors on rolp (rolp is terminated by nil ).\nThe program matching variables are the main innovation of our encoding. These variables are especially designed to allow us express more efficiently the constraints a stable matching must satisfy.\nA.2 Clauses Now we give the clauses of the encoding. Rather than give the more lengthy clauses directly, we often give higher level constraints whose CNF encoding is straightforward.\nUnique Match A doctor must be matched into exactly one program (possibly the nil program). For all d \u2208 D 1a at-most-one({md[p]|p \u2208 ranked(d)}) 1b \u2228\np\u2208ranked(d)md[p]\nThe at-most-one constraint simply states that at most one of a set of Boolean variables is allowed to be true. It can be converted to CNF in a number of different ways. 1b ensures that some match (possibly to the nil program) is made.\nCouple Match The mc[\u2217] variables must have their intended meaning. For all couples c \u2208 C , for all k such that 1 \u2264 k \u2264 |rolc|, letting c = (d1, d2) and (p1[i], p2[i]) = rolc[i], 2a mc[0] \u2261 md1 [p1[0]] \u2227md2 [p2[0]] 2b mc[k] \u2261 (md1 [p1[k]] \u2227md2 [p2[k]]) \u2228mc[k \u2212 1] 2c mc[|rolc|] The final condition ensures that c is matched to some program pair on its rol (possibly nil ), and the at-most-one constraint for d1 and d2 ensures that c is uniquely matched.\nProgram Match The mp[\u2217, \u2217] variables must have their intended meaning. For all programs p \u2208 P , for all i such that 1 \u2264 i \u2264 |rolp| \u2212 2, and for all s such that 0 \u2264 s \u2264 min(i+ 1, capp + 1), letting di = rolp[i] (the i-th doctor on p\u2019s rol ), 3a ( mp[0, 0] \u2261 \u00acmd0 [p] ) \u2227 ( mp[0, 1] \u2261 md0 [p]\n) 3b mp[i, s] \u2261 (mp[i\u22121, s]\u2227\u00acmdi [p]) \u2228\n(mp[i\u22121, s\u22121]\u2227mdi [p]) 3c \u00acmp[i, capp + 1] The last condition, captured by a set of unit clauses, ensures that p\u2019s quota is not exceeded at any stage. Falsifying these variables along with the other clauses ensures that no more matches can be made into p once p hits its quota. Note that i only indexes up to the last non-nil doctor on rolp since nil does not use up any program capacity.\nStability for Singles For each single doctor, d \u2208 S and for each p \u2208 rold 4 (\u2228 p\u2032 dpmd[p \u2032] ) \u2228mp[rankp(d)\u2212 1, capp ]\nThis clause says that if d has not been matched into a program preferred to or equal to p, then it must be the case that p will not accept d. Note that mp[rankp(d)\u2212 1, capp ] means that p has been filled to capacity with doctors coming before d on its rol .\nStability for Couples (A) For each couple c = (d1, d2) \u2208 C and for each (p1, p2) \u2208 rolc with p1 6= p2 5a1 md1 [p1] \u2227 \u00acmc[rankc((p1, p2))]\n=\u21d2 mp2 [rankp2(d2)\u2212 1, capp2 ] 5a2 md2 [p2] \u2227 \u00acmc[rankc((p1, p2))]\n=\u21d2 mp1 [rankp1(d1)\u2212 1, capp1 ] 5b \u00acmd1 [p1] \u2227 \u00acmd2 [p2] \u2227 \u00acmc[rankc((p1, p2))] =\u21d2\nmp1 [rankp1(d1)\u2212 1, capp1 ] \u2228mp2 [rankp2(d2)\u2212 1, capp2 ]\nClause 5a1 says that when d1 is already matched to p1 but c has not been matched into (p1, p2) or into a more preferred program pair, then it must be the case that p2 will not accept d2. 5a2 is analogous.\nClause 5b says that if neither d1 nor d2 is matched into p1 or p2 and c has not been matched into (p1, p2) or into a more preferred program pair, then either p1 will not accept d1 or p2 will not accept d2.\nStability for Couples (B) For each couple c = (d1, d2) \u2208 C and for each (p, p) \u2208 rolc we have one of constraint 6a1 or 6b1. 6a1 is needed when d1 p d2, while 6b1 is needed when d2 p d1. 6a1 md1 [p] \u2227 \u00acmc[rankc((p, p))] =\u21d2\nmp[rankp(d2)\u2212 1, capp ] 6b1 md1 [p] \u2227 \u00acmc[rankc((p, p))] =\u21d2\nmp[rankp(d1)\u2212 1, capp \u2212 1] 6c \u00acmd1 [p] \u2227 \u00acmd2 [p] \u2227 \u00acmc[rankc((p, p))] =\u21d2\nmp[rankp(d1)\u22121, capp ] \u2228mp[rankp(d1)\u22121, capp\u22121] \u2228mp[rankp(d2)\u22121, capp ] \u2228mp[rankp(d2)\u22121, capp\u22121]\nClauses 6a1 or 6b1 say that if d1 is already in p and c is not matched to (p, p) or into a more preferred program pair, then p will not accept d2. 6b1 differs because when d2 p d1 and d1 is already in p, p will definitely accept d2. In this case, however, the couple is not accepted into (p, p) if accepting d2 causes d1 to be bumped. That is, when mp[rankp(d1) \u2212 1, capp \u2212 1] is true (adding d2 will cause mp[rankp(d1) \u2212 1, capp ] to become true).\nThere are also analogous clauses 6a2 and 6b2 (one of which is used) to deal with the case when d2 is already in p and we need to ensure that p won\u2019t accept d1. Clause 6c handles the case when neither member of the couple is currently matched into p.\nLet P = \u3008D ,C ,P , \u3009 be a matching problem. We say that a matching \u00b5 for P and a truth assignment \u03c0 for SAT-E of P are corresponding when \u03c0 |= md[p] iff \u00b5(d) = p.\nWe provide a full proof of the following theorem in Drummond et al. [2015]. Theorem 2. If \u00b5 and \u03c0 are corresponding, then \u00b5 is stable if and only if \u03c0 is satisfying.\nThis theorem shows that the satisfying assignments of SAT-E are in a 1-1 relationship with the stable models."}], "references": [{"title": "American Economic Review", "author": ["Atila Abdulkadiroglu", "P.A. Pathak", "Alvin E. Roth", "Tayfun S\u00f6nmez. The Boston public school match"], "venue": "95(2):368\u2013371,", "citeRegEx": "Abdulkadiroglu et al.. 2005", "shortCiteRegEx": null, "year": 2005}, {"title": "Stability in large matching markets with complementarities", "author": ["I. Ashlagi", "M. Braverman", "A. Hassidim"], "venue": "Operations Research, 62(4):713\u2013732", "citeRegEx": "Ashlagi et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "plingeling and treengeling entering the sat competition 2013", "author": ["Armin Biere. Lingeling"], "venue": "Proceedings of the SAT Competition 2013, pages 51\u2013 52,", "citeRegEx": "Biere. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "In Proc", "author": ["Joanna Drummond", "Andrew Perrault", "Fahiem Bacchus. SAT is an effective", "complete method for solving stable matching problems with couples"], "venue": "of the Twenty-fourth International Joint Conference on Artificial Intelligence (IJCAI-15),", "citeRegEx": "Drummond et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "69(1):9\u201315", "author": ["D. Gale", "L.S. Shapley. College admissions", "the stability of marriage. American Mathematical Monthly"], "venue": "Jan", "citeRegEx": "Gale and Shapley. 1962", "shortCiteRegEx": null, "year": 1962}, {"title": "Local search for stable marriage problems with ties and incomplete lists", "author": ["Gelain et al", "2010] Mirco Gelain", "Maria Silvia Pini", "Francesca Rossi", "Kristen Brent Venable", "Toby Walsh"], "venue": "In Proceedings of the 11th Pacific Rim International Conference on Trends in Artificial", "citeRegEx": "al. et al\\.,? \\Q2010\\E", "shortCiteRegEx": "al. et al\\.", "year": 2010}, {"title": "SAT encodings of the stable marriage problem with ties and incomplete lists", "author": ["Ian P Gent", "Patrick Prosser"], "venue": "Proceedings of Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Gent and Prosser. 2002", "shortCiteRegEx": null, "year": 2002}, {"title": "A constraint programming approach to the stable marriage", "author": ["Gent et al", "2001] Ian P Gent", "Robert W Irving", "David F Manlove", "Patrick Prosser", "Barbara M Smith"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2001\\E", "shortCiteRegEx": "al. et al\\.", "year": 2001}, {"title": "honesty", "author": ["Nicole Immorlica", "Mohammad Mahdian. Marriage"], "venue": "and stability. In Proceedings of the sixteenth annual ACM-SIAM symposium on Discrete algorithms, pages 53\u201362,", "citeRegEx": "Immorlica and Mahdian. 2005", "shortCiteRegEx": null, "year": 2005}, {"title": "Marriages stables", "author": ["Donald E. Knuth"], "venue": "Les Presses de I\u2019Universite de Montreal,", "citeRegEx": "Knuth. 1976", "shortCiteRegEx": null, "year": 1976}, {"title": "Matching with couples: Stability and incentives in large markets", "author": ["F. Kojima", "P. Pathak", "A.E. Roth"], "venue": "Quarterly Journal of Economics, 128(4):1585\u2013 1632", "citeRegEx": "Kojima et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Stable assignment with couples: Parameterized complexity and local search", "author": ["D\u00e1niel Marx", "Ildik\u00f3 Schlotter"], "venue": "Discrete Optimization, 8(1):25\u2013 40,", "citeRegEx": "Marx and Schlotter. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Matching and market design", "author": ["Niederle et al", "2008] Muriel Niederle", "Alvin E. Roth", "Tayfun Sonmez"], "venue": "The New Palgrave Dictionary of Economics (2nd Ed.),", "citeRegEx": "al. et al\\.,? \\Q2008\\E", "shortCiteRegEx": "al. et al\\.", "year": 2008}, {"title": "National resident matching program", "author": ["NRMP"], "venue": "results and data: 2013 main residency match,", "citeRegEx": "NRMP. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Journal of Algorithms", "author": ["Eytan Ronn. NP-complete stable matching problems"], "venue": "11(2):285\u2013304,", "citeRegEx": "Ronn. 1990", "shortCiteRegEx": null, "year": 1990}, {"title": "The redesign of the matching market for American physicians: Some engineering aspects of economic design", "author": ["A.E. Roth", "E. Peranson"], "venue": "The American Economic Review, 89(1):748\u2013780, September", "citeRegEx": "Roth and Peranson. 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "Chapter 16", "author": ["Alvin E. Roth", "Marilda Sotomayor"], "venue": "two-sided matching. In R. J. Aumann and S. Hart, editors, Handbook of Game Theory Volume 1, pages 485\u2013541. Elsevier,", "citeRegEx": "Roth and Sotomayor. 1992", "shortCiteRegEx": null, "year": 1992}, {"title": "The evolution of the labor market for medical interns and residents: A case study in game theory", "author": ["Alvin E. Roth"], "venue": "Journal of Political Economy, 92(6):991\u20131016,", "citeRegEx": "Roth. 1984", "shortCiteRegEx": null, "year": 1984}, {"title": "Reformulation and Approximation (SARA)", "author": ["Chris Unsworth", "Patrick Prosser. A specialised binary constraint for the stable marriage problem. In Abstraction"], "venue": "pages 218\u2013233,", "citeRegEx": "Unsworth and Prosser. 2005", "shortCiteRegEx": null, "year": 2005}], "referenceMentions": [{"referenceID": 17, "context": "Arguably the most well-known of these applications is the residency matching problem [Niederle et al., 2008; Roth, 1984; Abdulkadiroglu et al., 2005], instantiated in the large National Resident Matching Program (NRMP), among others.", "startOffset": 85, "endOffset": 149}, {"referenceID": 0, "context": "Arguably the most well-known of these applications is the residency matching problem [Niederle et al., 2008; Roth, 1984; Abdulkadiroglu et al., 2005], instantiated in the large National Resident Matching Program (NRMP), among others.", "startOffset": 85, "endOffset": 149}, {"referenceID": 13, "context": "Importantly, these markets have adapted to the needs of their participants over the years, allowing them to more richly express their preferences, or guarantee certain properties of the match valuable to participants [NRMP, 2013].", "startOffset": 217, "endOffset": 229}, {"referenceID": 14, "context": "In particular, SMP-C is NP-complete [Ronn, 1990].", "startOffset": 36, "endOffset": 48}, {"referenceID": 11, "context": ", [Marx and Schlotter, 2011; Gelain et al., 2010]).", "startOffset": 2, "endOffset": 49}, {"referenceID": 6, "context": ", [Gent and Prosser, 2002; Gent et al., 2001; Unsworth and Prosser, 2005]).", "startOffset": 2, "endOffset": 73}, {"referenceID": 18, "context": ", [Gent and Prosser, 2002; Gent et al., 2001; Unsworth and Prosser, 2005]).", "startOffset": 2, "endOffset": 73}, {"referenceID": 15, "context": "Previous work on SMP-C has mainly focused on providing sound but not complete algorithms that extend the DA algorithm to deal with couples [Roth and Peranson, 1999; Kojima et al., 2013].", "startOffset": 139, "endOffset": 185}, {"referenceID": 10, "context": "Previous work on SMP-C has mainly focused on providing sound but not complete algorithms that extend the DA algorithm to deal with couples [Roth and Peranson, 1999; Kojima et al., 2013].", "startOffset": 139, "endOffset": 185}, {"referenceID": 3, "context": "A new SAT encoding for SMP-C was recently developed [Drummond et al., 2015], showing very promising results when run on a competitive SAT solver ar X iv :1 50 5.", "startOffset": 52, "endOffset": 75}, {"referenceID": 2, "context": "[Biere, 2013].", "startOffset": 0, "endOffset": 13}, {"referenceID": 15, "context": "We cast our formalization of SMP-C (stable matching problem with couples) in terms of the well known residency matching problem, a labour market where doctors are placed into hospital residency programs [Roth and Peranson, 1999].", "startOffset": 203, "endOffset": 228}, {"referenceID": 4, "context": ", in SMP) this set is always non-empty [Gale and Shapley, 1962] and has a nice structure: it forms a lattice under the partial order R defined below [Knuth, 1976].", "startOffset": 39, "endOffset": 63}, {"referenceID": 9, "context": ", in SMP) this set is always non-empty [Gale and Shapley, 1962] and has a nice structure: it forms a lattice under the partial order R defined below [Knuth, 1976].", "startOffset": 149, "endOffset": 162}, {"referenceID": 4, "context": ", [Gale and Shapley, 1962; Roth and Peranson, 1999]).", "startOffset": 2, "endOffset": 51}, {"referenceID": 15, "context": ", [Gale and Shapley, 1962; Roth and Peranson, 1999]).", "startOffset": 2, "endOffset": 51}, {"referenceID": 16, "context": "That is, it is a dominant strategy for each resident to state their true preferences [Roth and Sotomayor, 1992].", "startOffset": 85, "endOffset": 111}, {"referenceID": 14, "context": "Since SMP-C is known to be NP-Complete [Ronn, 1990] it is also possible to encode it as another NP-Complete problem.", "startOffset": 39, "endOffset": 51}, {"referenceID": 4, "context": "The basic principle of DA algorithms [Gale and Shapley, 1962] is that members of one side of the market propose down their ROLs while the other side either rejects those proposals or holds them until they see a better proposal: once all proposals have been made that side accepts the proposal they have not rejected (acceptance of proposals is deferred until the end).", "startOffset": 37, "endOffset": 61}, {"referenceID": 13, "context": "This well known algorithm has been used with considerable success in practice, including most famously for finding matches for the NRMP which typically involves about 30,000 doctors [NRMP, 2013].", "startOffset": 182, "endOffset": 194}, {"referenceID": 15, "context": "Using the description in [Roth and Peranson, 1999] we have implemented RP99.", "startOffset": 25, "endOffset": 50}, {"referenceID": 3, "context": "See [Drummond et al., 2015] for full", "startOffset": 4, "endOffset": 27}, {"referenceID": 2, "context": "We used the state-of-the art SAT solver LingeLing [Biere, 2013] to solve our encoding SAT-E; Algorithm 1 to find all stable matches; and our implementation of the two DA algorithms RP99 and KPR, described in Section 4.", "startOffset": 50, "endOffset": 63}, {"referenceID": 13, "context": "It can also be noted that the results presented here (20,000 couples with an average single\u2019s ROL of size 5) are of a size comparable to the NRMP, where there are 34,355 residents with an average single\u2019s ROL of size 11 [NRMP, 2013].", "startOffset": 220, "endOffset": 232}], "year": 2015, "abstractText": "The Stable Matching Problem with Couples (SMP-C) is a ubiquitous real-world extension of the stable matching problem (SMP) involving complementarities. Although SMP can be solved in polynomial time, SMP-C is NP-Complete. Hence, it is not clear which, if any, of the theoretical results surrounding the canonical SMP problem apply in this setting. In this paper, we use a recently-developed SAT encoding to solve SMP-C exactly. This allows us to enumerate all stable matchings for any given instance of SMP-C. With this tool, we empirically evaluate some of the properties that have been hypothesized to hold for SMP-C. We take particular interest in investigating if, as the size of the market grows, the percentage of instances with unique stable matchings also grows. While we did not find this trend among the random problem instances we sampled, we did find that the percentage of instances with an resident optimal matching seems to more closely follow the trends predicted by previous conjectures. We also define and investigate resident Pareto optimal stable matchings, finding that, even though this is important desideratum for the deferred acceptance style algorithms previously designed to solve SMP-C, they do not always find one. We also investigate strategy-proofness for SMP-C, showing that even if only one stable matching exists, residents still have incentive to misreport their preferences. However, if a problem has a resident optimal stable matching, we show that residents cannot manipulate via truncation.", "creator": "TeX"}}}