{"id": "1506.08919", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2015", "title": "Characterization of Logic Program Revision as an Extension of Propositional Revision", "abstract": "We 23-day address the riz problem geringer of belief revision 867-5309 of logic programs, i. smerick e. , wahls how to coucil incorporate 1369 to vez a logic zipf program mamma.com P 3,671 a bachri new guolla logic ropley program Q. Based on the trans-border structure cosmogenic of cuneo SE donar interpretations, changzhou Delgrande et perdue al. tif adapted spilt the fourth-largest well - known udd AGM redact framework cabanne to logic program (LP) kleinert revision. They 428 identified the rational behavior of 98fm LP disasters revision korsholm and uhmwpe introduced newmaker some specific operators. In this trijntje paper, a constructive sarcelles characterization euro475 of all rational 3,871 LP revision operators puzzled is gandhism given in 292.3 terms comtec of akhlaq orderings defict over postulating propositional shatrughna interpretations with some further jibjab conditions specific 36,200 to tayseer SE hame interpretations. It qe provides an nmbs intuitive, golczewo complete razzia procedure flojo for damnable the 2,292 construction of outlined all jawhara rational LP olomana revision operators 86.16 and mokri makes nirupama easier the comprehension comano of their semantic and re-activated computational properties. We give a cleef particular consideration to logic 1939-40 programs powiats of withholding very general medallists form, reliving i. e. , the penetrates generalized keker logic programs (prohm GLPs ). decarlo We show wettlaufer that every castilla-la rational GLP revision julietta operator is merivel derived from a propositional barud revision kopechne operator fert satisfying the tordesillas original double-strand AGM biswajeet postulates. shojaei Interestingly, santer\u00eda the birker further charak conditions specific to GLP licciardello revision isas are gwangmyeong independent 14,285 from the propositional 20.15 revision bryophyte operator on kaposv\u00e1ri which koumei a GLP 170-run revision unicron operator longhurst is nodaway based. tu\u0111man Taking satloff advantage aubrey of our characterization superhighway result, bocce we 2502 embed palembang the ayudhaya GLP revision suchart operators 42.94 into structures nonmagnetic of viadero Boolean lattices, ponzu that allow kellye us to gillman bring characterised to light v some pres. potential weaknesses dunphy in the okies adapted AGM kamotho postulates. tpr To mergers illustrate our compositionality claim, we introduce 9-member and characterize bouknight axiomatically 86.0 two judenburg specific hans-peter classes delays of (dirkie rational) fiachrach GLP pordoi revision operators macroprudential which elkem arguably wandesforde have hrg a drastic behavior. We additionally consider two shoven more metoyer restricted sonorous forms taiz\u00e9 of logic programs, re-imagining i. cstc e. , the disjunctive 312,000 logic programs (farace DLPs) tros and 62.69 the normal logic acps programs (NLPs) kunishige and adapt eight-way our characterization result gowerton to DLP env and NLP revision operators.", "histories": [["v1", "Tue, 30 Jun 2015 02:09:02 GMT  (83kb)", "http://arxiv.org/abs/1506.08919v1", "42 pages, 5 figures, to appear in Theory and Practice of Logic Programming (accepted in June 2015)"]], "COMMENTS": "42 pages, 5 figures, to appear in Theory and Practice of Logic Programming (accepted in June 2015)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["nicolas schwind", "katsumi inoue"], "accepted": false, "id": "1506.08919"}, "pdf": {"name": "1506.08919.pdf", "metadata": {"source": "CRF", "title": "Characterization of Logic Program Revision as an Extension of Propositional Revision\u2217", "authors": ["Nicolas Schwind", "Katsumi Inoue"], "emails": ["schwind@nii.ac.jp", "inoue@nii.ac.jp"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 6.\n\u2217 This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013).\nand the normal logic programs (NLPs) and adapt our characterization result to DLP and NLP revision operators."}, {"heading": "1 Introduction", "text": "Logic programs (LPs) under the answer set semantics are well-suited for modeling problems which involve common sense reasoning (e.g., biological networks, diagnosis, planning, etc.) Due to the dynamic nature of our environment, beliefs represented through an LP P are subject to change, i.e., because one wants to incorporate to it a new LP Q. Since there is no unique, consensual procedure to revise a set of beliefs, Alchourro\u0301n, Ga\u0308rdenfors and Makinson (1985) introduced a set of desirable principles w.r.t. belief change called AGM postulates. Katsuno and Mendelzon (1992) adapted these principles to the case of propositional logic, distinguished two kind of change operations, i.e., revision and update (Katsuno and Mendelzon 1991), and characterized axiomatically each one of these change operations by a set of socalled KM postulates. Revision consists in incorporating a new information into a database that represents a static world, i.e., new and old beliefs describe the same situation but new ones are more reliable. In the case of update, the underlying world evolves with respect to the occurence of some events i.e., new and old beliefs describe two different states of the world.\nOur interests focus here on the problem of revision of logic programs. Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.\nIndeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002). However, the notion of SE models introduced by Turner (2003) provided a monotonic semantical characterization of LPs, which is more expressive than the answer set semantics. Initially, SE models were used to characterize the strong equivalence between logic programs (Lifschitz et al. 2001): precisely, two LPs have the same set of SE models if and only if they are strongly equivalent, that is to say, they admit the same answer sets, and will still do even after adding any arbitrary set of rules to them.\nBased on these structures, Delgrande et al. (2008; 2013b) adapted the AGM/KM postulates in the context of logic programming. They focused on the revision of logic programs, i.e., they proposed several revision operators and investigated their properties w.r.t. the adapted postulates. Slota and Leite (2010; 2013) exploited the same idea for update of logic programs by adapting the KM postulates in a similar way. These semantical-based belief change operations (revision and update) changed the focus from the dynamic evolution of a syntactic, rule-based representation of beliefs previously proposed in the literature to the evolution of its semantic content; these works covered a serious drawback in the field of belief revision in logic programming. In the context of update, Slota and Leite also proposed a constructive representation of such update operators. Such a result provides a sound and complete model-theoretic construction of the rational LP update operators, i.e., a\n\u201cgeneric recipe\u201d to construct all operators that fully satisfy the adaptation of the AGM/KM postulates to logic programs. It is indeed crucial when defining a logical operator in an axiomatic way to give an intuitive constructive characterization of it in order to aid the analysis of its semantic and computational properties.\nIn this paper, we give a particular consideration to the revision of generalized logic programs (GLPs) (Inoue and Sakama 1998) which are of very general form. Revising a GLP P by an other GLPQ should result in a new GLP that satisfy the adapted set of AGM postulates. We provide a characterization of the set of all GLP revision operators by associating each GLP with a certain structure, called GLP parted assignment, which consists of a pair of assignments that are independent from each other. Interestingly, the first one, called here LP faithful assignment, is similar to the structure of faithful assignment defined in (Katsuno and Mendelzon 1992) and used to characterize the (rational) KM revision operators in the propositional setting; the second one, called here well-defined assignment, can be defined independently from the first one. As a consequence, the benefit of our approach is that:\n(i) every rational LP revision operator \u22c6 can be derived from a propositional revi-\nsion operator \u25e6 satisfying the KM postulates, with some additional conditions that are independent from \u25e6;\n(ii) there is a one-to-one correspondence between the set of rational LP revision\noperators and the set of all pairs of such assignments.\nOur characterization makes the refined analysis of LP revision operators easier. Indeed, we can embed the GLP revision operators into structures of Boolean lattices, that allows us to bring out some potential weaknesses in the original postulates and pave the way for the discrimination of some rational GLP revision operators.\nThe next section introduces some preliminaries about belief revision in propositional logic. We provide in Section 3 some necessary background on generalized logic programs, and we also introduce the notion on logic program revision, an axiomatic characterization of generalized logic program revision operators, and some preliminary results. Section 4 provides our main result, i.e., a constructive characterization of the axiomatic description of the GLP revision operators. We formally compare our characterization result with another recent one proposed in (Delgrande et al. 2013a); the benefit of our approach is that our construction is one-to-one, as opposite to Delgrande et al.\u2019s one. In Section 5 we partition the class of GLP revision operators into subclasses of Boolean lattices, then we introduce and axiomatically characterize two specific classes of (rational) GLP revision operators, i.e., the skeptical and brave GLP revision operators, and lastly we provide some complexity results which are direct consequences of existing results in the propositional case. In Section 6 we consider the revision of more restricted forms of logic programs, i.e., the disjunctive logic programs (DLPs) and normal logic programs (NLPs). We adapt our characterization result to DLP revision operators and NLP revision operators. Though DLP revision operators and NLP revision operators can also be viewed as extensions of propositional revision operators, in constrast with GLP revision operators their construction does not provide us with two indepen-\ndent structures. We conclude in Section 7. The proofs of propositions are provided in an appendix.\nThis version of the paper is a revised and extended version of a published LPNMR\u201913 paper (Schwind and Inoue 2013). The main extensions include a comparison of our main characterization result with the one proposed in (Delgrande et al. 2013a), some complexity results, characterization results for DLP and NLP revision operators and the proofs of propositions."}, {"heading": "2 Belief revision in propositional logic", "text": ""}, {"heading": "2.1 Formal preliminaries", "text": "We consider a propositional language L defined from a finite set of propositional variables (also called atoms)A and the usual connectives.\u22a5 (resp.\u22a4) is the Boolean constant always false (resp. true). A (classical) interpretation over A is a total function from A to {0, 1}. To avoid heavy expressions, an interpretation I is also viewed as the subset of atoms from A that are true in I . For instance, if A = {p, q}, then the interpretation over A such that I (p) = 1 and I (q) = 0 is also represented as the set {p}. For the sake of simplicity, set-notations will be dropped within interpretations (except for the case where the interpretation is the empty set), e.g., the interpretation {p, q} will be simply denoted pq. The set of all interpretations is denoted \u2126. An interpretation I is a model of a formula \u03c6 \u2208 L, denoted I |= \u03c6, if it makes it true in the usual truth functional way. A consistent formula is a formula that admits a model. The set mod(\u03c6) denotes the set of models of the formula \u03c6, i.e., mod(\u03c6) = {I \u2208 \u2126 | I |= \u03c6}. Two formulae \u03c6, \u03c8 are said to be equivalent, denoted by \u03c6 \u2261 \u03c8 if and only if mod(\u03c6) = mod(\u03c8)."}, {"heading": "2.2 Propositional revision operators", "text": "We now introduce some background on propositional belief revision. We start by introducing a revision operator as a simple function, that considers two formulae (the original formula and the new one) and that returns the revised formula:\nDefinition 1 (Propositional revision operator, equivalence between operators) A (propositional) revision operator \u25e6 is a mapping associating two formulae \u03c6, \u03c8 with a new formula, denoted \u03c6 \u25e6 \u03c8. Two revision operators \u25e6, \u25e6\u2032 are said to be equivalent (denoted \u25e6 \u2261 \u25e6\u2032) when for all formulae \u03c6, \u03c8, \u03c6 \u25e6 \u03c8 \u2261 \u03c6 \u25e6\u2032 \u03c8.\nThe AGM framework (Alchourro\u0301n et al. 1985) describes the standard principles for belief revision (e.g., consistency preservation and minimality of change), which capture changes occuring in a static domain. Katsuno and Mendelzon (1991) equivalently rephrased the AGM postulates as follows:\nDefinition 2 (KM revision operator) A KM revision operator \u25e6 is a propositional revision operator that satisfies the following postulates, for all formulae \u03c6, \u03c61, \u03c62, \u03c8, \u03c81, \u03c82:\n(R1) \u03c6 \u25e6 \u03c8 |= \u03c8; (R2) If \u03c6 \u2227 \u03c8 is consistent, then \u03c6 \u25e6 \u03c8 \u2261 \u03c6 \u2227 \u03c8; (R3) If \u03c8 is consistent, then \u03c6 \u25e6 \u03c8 is consistent;\n(R4) If \u03c61 \u2261 \u03c62 and \u03c81 \u2261 \u03c82, then \u03c61 \u25e6 \u03c81 \u2261 \u03c62 \u25e6 \u03c82; (R5) (\u03c6 \u25e6 \u03c81) \u2227 \u03c82 |= \u03c6 \u25e6 (\u03c81 \u2227 \u03c82); (R6) If (\u03c6 \u25e6 \u03c81) \u2227 \u03c82 is consistent, then \u03c6 \u25e6 (\u03c81 \u2227 \u03c82) |= (\u03c6 \u25e6 \u03c81) \u2227 \u03c82.\nThese so-called KM postulates capture the desired behavior of a revision operator, e.g., in terms of consistency preservation and minimality of change. We now draw the reader\u2019s attention to the following important detail. The KM postulates also tell us that the outcome of a revision operator relies on an arbitrary syntactic distinction: one can see that a revision operator \u25e6 is a KM revision operator (i.e., it satisfies postulates (R1 - R6)) if and only if any revision operator equivalent to \u25e6 is also a KM revision operator. In this paper, since we are only interested in whether an operator satisfies a set of rationality postulates or not, only the semantic contents of the revised base play a role, that is, relevance is considered only within the models of a revised base rather than on its explicit representation. This is why from now on, abusing terms we identify a revision operator modulo equivalence, that is, we actually refer to any revision operator equivalent to it. It becomes then harmless to define the resulting revised base in a modelwise fashion, as a set of models implicitely interpreted disjunctively. As a consequence, given two propositional revision operators \u25e6, \u25e6\u2032, one can switch between the notations \u25e6 \u2261 \u25e6\u2032 and \u25e6 = \u25e6\u2032 since there is no longer danger of confusion.\nKM revision operators can be represented in terms of total preorders over interpretations. Indeed, each KM revision operator is associated with some faithful assignment (Katsuno and Mendelzon 1991). For each preorder \u2264, \u2243 denotes the corresponding indifference relation, and < denotes the corresponding strict ordering; given a binary relation \u2264 over a set E and any set F \u2286 E , the set min(F ,\u2264) denotes the subset of \u201cminimal\u201d elements from F w.r.t. \u2264, i.e., min(F ,\u2264) = {a \u2208 F | \u2200b \u2208 F , b \u2264 a \u21d2 a \u2264 b}.\nDefinition 3 (Faithful assignment)\nA faithful assignment is a mapping which associates with every formula \u03c6 a preorder \u2264\u03c6 over interpretations such that for all interpretations I , J and all formulae \u03c6, \u03c61, \u03c62, the following conditions hold:\n(a) If I |= \u03c6 and J |= \u03c6, then I \u2243\u03c6 J ; (b) If I |= \u03c6 and J 6|= \u03c6, then I <\u03c6 J ; (c) If \u03c61 \u2261 \u03c62, then \u2264\u03c61=\u2264\u03c62.\nTheorem 1 (Katsuno and Mendelzon 1992 ) A revision operator \u25e6 is a KM revision operator if and only if there exists a faithful assignment associating every formula \u03c6 with a total preorder \u2264\u03c6 such that for all formulae \u03c6, \u03c8, mod(\u03c6 \u25e6 \u03c8) = min(mod(\u03c8),\u2264\u03c6).\nExample 1 Consider the propositional language defined from the set of atoms A = {p, q}. Let \u03c6 = p \u21d4 \u00acq. Consider the total preorder \u2264\u03c6 defined as p \u2243\u03c6 q <\u03c6 pq <\u03c6 \u2205. It can be easily checked that the conditions of a faithful assignment are satisfied by \u2264\u03c6. Then denote by \u25e6 the corresponding KM revision operator. Now, let \u03c81 = \u00acp \u2227 q and \u03c82 = p \u21d4 q. Figure 1 illustrates the total preorder\u2264\u03c6 and graphically identifies the models of \u03c81 and \u03c82. We get that:\n\u2022 mod(\u03c6 \u25e6 \u03c81) = min(mod(\u03c81),\u2264\u03c6) = mod(\u03c81). Hence, \u03c6 \u25e6 \u03c81 \u2261 \u03c81; \u2022 mod(\u03c6 \u25e6 \u03c82) = min(mod(\u03c82),\u2264\u03c6) = {pq}. Hence, \u03c6 \u25e6 \u03c82 \u2261 p \u2227 q.\nIn fact, an implicit consequence of Theorem 1 is that every KM revision operator is represented by a unique faithful assignment, and conversely, every faithful assignment represents a unique KM revision operator (modulo equivalence):\nProposition 1\nThere is a one-to-one correspondence between the KM revision operators and the set of all faithful assignments.\nKM revision operators include the class of distance-based revision operators (see, for instance, (Dalal 1988)), i.e., those operators characterized by a distance between interpretations:\nDefinition 4 (Distance-based revision operators) Let d be a distance between interpretations1, extended to a distance between every interpretation I and every formula \u03c6 by\nd(I , \u03c6) =\n{\nmin{d(I , J ) | J |= \u03c6} if \u03c6 is consistent, 0 otherwise.\nThe revision operator based on the distance d is the operator \u25e6d satisfying for all formulae \u03c6, \u03c8, mod(\u03c6 \u25e6d \u03c8) = min(mod(\u03c8),\u2264d\u03c6) where the preorder \u2264 d \u03c6 induced by \u03c6 is defined for all interpretations I , J by I \u2264d\u03c6 J if and only if d(I , \u03c6) \u2264 d(J , \u03c6).\nThe following result is a direct consequence of Theorem 1:\n1 Actually, a pseudo-distance is enough, i.e., triangular inequality is not mandatory.\nCorollary 1 Every distance-based revision operator is a KM revision operator, i.e., it satisfies the postulates (R1 - R6).\nThe result of revising old beliefs (a propositional formula \u03c6) by new beliefs (a propositional formula \u03c8) is any propositional formula whose models are models of \u03c8 having a distance to a model of \u03c6 which is minimal among all models of \u03c8.\nIt is clear from Definition 4 that a distance fully characterizes the induced revision operator, that is, different choices for the distance induce different revision operators. Usual distances are dD , the drastic distance (dD (I , J ) = 1 if and only if I 6= J ), and dH the Hamming distance (dH (I , J ) = n if I and J differ on n variables). One can remark that when the drastic distance dD is used, the induced faithful assignment associates with every formula \u03c6 a two-level preorder\u2264\u03c6; indeed, it can be easily verified that the revision operator based on the drastic distance dD is equivalent to the so-called drastic revision operator, which is defined syntactically as follows:\nDefinition 5 (Drastic revision operator) The drastic revision operator, denoted \u25e6D , is the revision operator defined for all formulae \u03c6, \u03c8 as\n\u03c6 \u25e6D \u03c8 =\n{\n\u03c6 \u2227 \u03c8 if \u03c6 \u2227 \u03c8 is consistent, \u03c8 otherwise.\nThis operator was first introduced in (Alchourro\u0301n et al. 1985) under the name of full meet revision function. Though \u201cfully rational\u201d in the sense that it satisfies all the KM rationality postulates (i.e., all AGM postulates in (Alchourro\u0301n et al. 1985)), it is often considered as unreasonable because it throws away all the old beliefs if the new formula is inconsistent with them.\nLikewise, the revision operator based on Hamming distance dH is equivalent to the well-known Dalal revision operator (Dalal 1988). In fact, in (Dalal 1988) the Dalal revision is also defined in a modelwise fashion, i.e., there is no syntactic definition of it (as opposite to the drastic revision operator, cf. Definition 5):\nDefinition 6 (Dalal revision operator) A Dalal revision operator, denoted \u25e6Dal , is any revision operator based on the Hamming distance.\nFrom now on, the revision operator based on the Hamming distance (i.e., the revision operator \u25e6dH ) will simply be referred as the Dalal revision operator, and thus will be denoted \u25e6Dal .\nExample 2 Let A = {p, q, r}, \u03c6 = p \u2227 q \u2227 \u00acr , and \u03c8 = r . We have\n\u2022 \u03c6 \u25e6D \u03c8 = r . \u2022 \u03c6 \u25e6Dal \u03c8 \u2261 p \u2227 q \u2227 r .\nIt is clear from Example 2 that the Dalal revision operator has a more parsimonious behavior than the drastic revision operator, because it integrates the new information while keeping as much previous beliefs as possible.\nBefore concluding this section, let us remark that distance-based revision operators as defined above do not fully characterize KM revision operators: this comes from the fact that given two formulae \u03c6, \u03c6\u2032 such that \u03c6 6\u2261 \u03c6\u2032, one can associate within the same faithful assignment two preorders \u2264\u03c6,\u2264\u03c6\u2032 in an independent way; given that observation, one can easily build \u2264\u03c6,\u2264\u03c6\u2032 using two different distances, whereas Definition 4 requires that the same distance is used to define the total preorder \u2264\u03c6 associated with any formula. However, as far as we know there does not exist in the literature any \u201cfully rational\u201d (with respect to postulates (R1 - R6)) revision operator of interest that is not distance-based."}, {"heading": "3 Belief revision in Logic Programming", "text": ""}, {"heading": "3.1 Preliminaries on Logic Programming", "text": "We define the syntax and semantics of generalized logic programs. We use the same notations as in (Delgrande et al. 2008). A generalized logic program (GLP) is a finite set of rules of the form\na1; . . . ; ak ;\u223c b1; . . . ;\u223c bl \u2190 c1, . . . , cm ,\u223c d1, . . . ,\u223c dn ,\nwhere k , l ,m, n \u2265 0.\nEach ai , bi , ci , di is either one of the constant symbols \u22a5, \u22a4, or an atom from A; \u223c is the negation by failure; \u201c;\u201d is the disjunctive connective, \u201c,\u201d is the conjunctive connective of atoms. The right-hand and left-hand sides of r are respectively called the head and body of r . For each rule r , we define H (r)+ = {a1, . . . , ak}, H (r)\u2212 = {b1, . . . , bl}, B(r)+ = {c1, . . . , cm}, and B(r)\u2212 = {d1, . . . , dn}. For the sake of simplicity, a rule r is also expressed as follows:\nH (r)+;\u223c H (r)\u2212 \u2190 B(r)+,\u223c B(r)\u2212\u00b7\nA logic program is interpreted through its preferred models based on the answer set semantics. A (classical) model X of a GLP P (written X |= P) is an interpretation from \u2126 that satisfies all rules from P according to the classical definition of truth in propositional logic. mod(P) will denote the set of all models of a GLP P . An answer set X of a GLP P is a minimal (w.r.t. set inclusion) set of atoms from A that is a model of the program PX , where PX is called the reduct of P relative to X and is defined as PX = {H (r)+ \u2190 B(r)+ | r \u2208 P ,H (r)\u2212 \u2286 X ,B(r)\u2212 \u2229X = \u2205}. The classical notion of equivalence between programs corresponds to the correspondence of their answer sets. Recall that we denote an interpretation by dropping set-notations except for the case of the interpretation corresponding to the empty set; for instance, the set of interpretations {\u2205, {p}, {pq}} will be simply denoted {\u2205, p, pq}.\nExample 3\nConsider the logic program P =\n{\np \u2190\u223c q, \u22a5 \u2190 p, q\n}\n. To determine AS (P), the set of\nanswer sets of P , we need to check for each interpretation X whether X is a minimal (w.r.t. set inclusion) model of PX , the reduct of P relative to X :\n\u2022 P\u2205 =\n{\np \u2190 \u22a4, \u22a5 \u2190 p, q\n}\n, and mod(P\u2205) = {p}. Since \u2205 is not a model of P\u2205, we\nget that \u2205 /\u2208 AS (P);\n\u2022 Pp = P\u2205, so mod(Pp) = {p}. Since p is a minimal (w.r.t. set inclusion) model\nof Pp , we get that p \u2208 AS (P);\n\u2022 Pq = {\u22a5 \u2190 p, q}, so mod(Pq) = {\u2205, p, q}. Hence, q is a model of Pq but is\nnot minimal w.r.t. set inclusion, since \u2205 \u2208 mod(Pq). Thus q /\u2208 AS (P); \u2022 lastly, Ppq = Pq , so mod(Ppq) = {\u2205, p, q}. Hence, pq is a not a model of Ppq ,\nso we get that pq /\u2208 AS (P);\nTherefore, AS (P) = {p}.\nSE interpretations are semantic structures characterizing strong equivalence between logic programs (Turner 2003), they provide a monotonic semantic foundation of logic programs under answer set semantics. An SE interpretation over A is a pair (X ,Y ) of interpretations over A such that X \u2286 Y . An SE model (X ,Y ) of a logic program P is an SE interpretation over A that satisfies Y |= P and X |= PY , where PY is the reduct of P relative to Y . The set SE denotes the set of all SE interpretations over A; given a logic program P , the set SE(P) denotes the set of SE models of P .\nExample 4 Consider again the logic program P defined in Example 3. We have mod(P) = {p, q}. Hence,\nSE(P) = {(X , p) \u2208 SE | X \u2208 mod(Pp)} \u222a {(X , q) \u2208 SE | X \u2208 mod(Pq)}\n= {(X , p) \u2208 SE | X \u2208 {p}} \u222a {(X , q) \u2208 SE | X \u2208 {\u2205, p, q}} = {(p, p), (\u2205, q), (q, q)}\u00b7\nThrough their SE models, logic programs are semantically described in a stronger\nway than through their answer sets, as shown in the following example.\nExample 5\nLet P1 = {p \u2190\u223c q} and P2 =\n{\np \u2190\u223c q, p; q \u2190 \u22a4\n}\n, and consider again the logic program\nP defined in Example 3. Then we get that\nAS (P) = AS (P1) = AS (P2) = {p},\nthat is, P , P1 and P2 admit the same answer sets. However their SE models differ:\nSE(P) = {(p, p), (\u2205, q), (q, q)} (cf. Example 3), SE(P1) = {(p, p), (\u2205, q), (q, q), (\u2205, pq), (p, pq), (q, pq), (pq, pq)}, SE(P2) = {(p, p), (p, pq), (q, pq), (pq, pq)},\nA program P is consistent if SE(P) 6= \u2205. Two programs P and Q are said to be strongly equivalent, denoted P \u2261s Q, whenever SE(P) = SE(Q). We also write P \u2286s Q if SE(P) \u2286 SE(Q). Two programs are equivalent if they are strongly equivalent, but the other direction does not hold in general (cf. Example 5). Note that Y is an answer set of P if and only if (Y ,Y ) \u2208 SE(P) and no (X ,Y ) \u2208 SE(P) with X ( Y exists. We also have (Y ,Y ) \u2208 SE(P) if and only if Y \u2208 mod(P). A set of SE interpretations S is well-defined if for every interpretation X ,Y with X \u2286 Y , if (X ,Y ) \u2208 S then (Y ,Y ) \u2208 S . Every GLP has a well-defined set of SE models. Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).\nWe close this section by introducing two further notations. For every GLP P ,\n\u03b12P is any propositional formula satisfying mod(\u03b1 2 P ) = mod(P), and \u03b1 1 P is any propositional formula satisfying mod(\u03b11P ) = {X \u2208 \u2126 | (X ,Y ) \u2208 SE(P)}."}, {"heading": "3.2 Logic program revision operators", "text": "We now consider belief revision in the context of logic programs. Given two programs P ,Q the goal is to define a program P \u22c6 Q which is the revision of P by Q. Delgrande et al. (2008; 2013b) proposed an adaptation of the KM postulates (cf. Definition 2) in the context of logic programming; this can be done using the monotonic characterization of logic programs through their SE models. First, they considered the operation of expansion of two logic programs:\nDefinition 7 (Expansion operator (Delgrande et al. 2008)) Given two programs P ,Q, the expansion of P by Q, denoted P+Q is any program R such that SE(R) = SE(P) \u2229 SE(Q).\nThough the expansion of logic programs trivializes the result whenever the two input logic programs admit no common SE models, this operation is of interest in its own right. For instance, it can be observed that the intersection of two welldefined sets of SE interpretations leads to a well-defined set of SE interpretations, and thus the expansion of two GLPs is always defined as a GLP.\nExample 6 Consider again the program P from Example 3, and recall that SE(P) = {(p, p), (\u2205, q), (q, q)}. Let Q be the GLP Q = {q \u2190 \u22a4}, we have SE(Q) = {(q, q), (q, pq),\n(pq, pq)}. Furthermore, the GLPR =\n{\nq \u2190 \u22a4, \u22a5 \u2190 p\n}\nis such that SE(R) = {(q, q)} =\nSE(P) \u2229 SE(Q). Therefore,\nP +Q =\n{\np \u2190\u223c q, \u22a5 \u2190 p, q\n}\n+ {q \u2190 \u22a4} \u2261s\n{\nq \u2190 \u22a4, \u22a5 \u2190 p\n}\n\u00b7\nWe refer the reader to (Delgrande et al. 2013b), Section 3.1 for further examples\nof the use of the expansion operator.\nExpansion of programs corresponds to the model-theoretical definition of expansion expressed through the KM postulates R2, R5 and R6. Delgrande et al.\nrephrased the full set of KM postulates (R1 - R6) in the context of GLPs. Beforehand, we define a logic program revision operator as a simple function, that considers two GLPs (the original one and the new one) and returns a revised GLP:\nDefinition 8 (LP revision operator, equivalence between LP revision operators)\nA LP revision operator \u22c6 is a mapping associating two GLPs P ,Q with a new GLP, denoted P \u22c6Q. Two LP revision operators \u22c6, \u22c6\u2032 are said to be equivalent (denoted \u22c6 \u2261 \u22c6\u2032) when for all GLPs P ,Q, P \u22c6Q \u2261s P \u22c6\u2032 Q.\nDefinition 9 (GLP revision operator (Delgrande et al. 2008))\nA GLP revision operator \u22c6 is an LP revision operator that satisfies the following postulates, for all GLPs P ,P1,P2,Q,Q1,Q2,R:\n(RA1) P \u22c6Q \u2286s Q; (RA2) If P +Q is consistent, then P \u22c6Q \u2261s P +Q; (RA3) If Q is consistent, then P \u22c6Q is consistent;\n(RA4) If P1 \u2261s P2 and Q1 \u2261s Q2, then P1 \u22c6Q1 \u2261s P2 \u22c6Q2; (RA5) (P \u22c6Q) +R \u2286s P \u22c6 (Q+R); (RA6) If (P \u22c6Q) +R is consistent, then P \u22c6 (Q+R) \u2286s (P \u22c6Q) +R.\nAs to the case of (propositional) KM revision operators, an LP revision operator \u22c6 is a GLP revision operator if and only if any LP revision operator equivalent to \u22c6 is also a GLP revision operator. This is why in the rest of the paper, as we identify a propositional revision operator modulo equivalence, we also identify an LP revision operator modulo equivalence. This allows us to define a revised program in a modelwise fashion, i.e., as its set of SE models, and given two LP revision operators \u22c6, \u22c6\u2032, the notations \u22c6 \u2261 \u22c6\u2032 and \u22c6 = \u22c6\u2032 are confunded with no harm.\nDelgrande et al. (2008) proposed a revision operator inspired from Satoh\u2019s propositional revision operator (Satoh 1988). This operator, based on the set containment of SE interpretations, satisfies postulates (RA1 - RA5). Though it seems to have a good behavior on some instances, this operator does not satisfy (RA6), so that it does not fully respect the principle of minimality of change (see (Katsuno and Mendelzon 1989), Section 3.1 for details on this postulate). However, the whole set of postulates is consistent, as they later introduce the so-called cardinality-based revision operator (Delgrande et al. 2013b) that reduces to the Dalal revision scheme over propositional models and that satisfies all the postulates (RA1 - RA6). The following definition is a concise, equivalent reformulation of the original one introduced in (Delgrande et al. 2013b), Definition 3.10:\nDefinition 10 (Cardinality-based revision operator)\nGiven a GLP P and an interpretation Y , let formY be any propositional formula satisfying mod(formY ) = {Y }, let \u03b1(P,Y ) be any propositional formula satisfying mod(\u03b1(P,Y )) = {X \u2208 \u2126 | (X ,Y \u2032) \u2208 SE(P),Y \u2032 |= formY \u25e6Dal \u03b12P}, and let \u03b1Y be any propositional formula satisfying mod(\u03b1Y ) = {X \u2208 \u2126 | X \u2286 Y }. The\ncardinality-based revision operator, denoted \u22c6c, is defined for all GLPs P ,Q by any program P \u22c6c Q satisfying\nSE(P \u22c6c Q) = {(X ,Y ) \u2208 SE(Q) | Y |= \u03b12P \u25e6Dal \u03b1 2 Q\nand if X ( Y then X |= \u03b1(P,Y ) \u25e6Dal \u03b1Y }}\u00b7\nTheorem 2 (Delgrande et al. 2013b) \u22c6c is a GLP revision operator.\nIn addition, we introduce below a simple, syntactically defined LP revision ope-\nrator which also satisfies the whole set of postulates (RA1 - RA6):\nDefinition 11 (Drastic LP revision operator) The drastic LP revision operator \u22c6D is defined for all GLPs P ,Q as\nP \u22c6D Q =\n{\nP +Q if P +Q is consistent, Q otherwise.\nProposition 2 \u22c6D is a GLP revision operator.\nNote that the drastic LP revision operator is the counterpart of the propositional drastic revision operator (cf. Definition 5) for logic programs: the old program is thrown away if the new program is inconsistent with it. The cardinality-based revision operator has a more parsimonious behavior. However, Theorem 2 and Proposition 2 show that these operators are both fully satisfactory in terms of revision principles; this raises the problem on how to discard some rational operators from others. Moreover, it is not clear whether there even exist other GLP revision operators than the cardinality-based and the drastic LP revision operators. In the next section, we fill the gap and we give a constructive, full characterization of the class of GLP revision operators, that provides us a clear and complete picture of it."}, {"heading": "4 Characterization of GLP revision operators", "text": ""}, {"heading": "4.1 Characterization result", "text": "We now provide the main result of our paper, i.e., a characterization theorem for GLP revision operators. That is, we show that each GLP revision operator (i.e., each LP revision operator satisfying the postulates (RA1 - RA6)) can be characterized in terms of preorders over the set of all classical interpretations, with some further conditions specific to SE interpretations.\nDefinition 12 (LP faithful assignment) An LP faithful assignment is a mapping which associates with every GLP P a total preorder \u2264P over interpretations such that for all GLPs P ,Q and all interpretations Y ,Y \u2032, the following conditions hold:\n(1) If Y |= P and Y \u2032 |= P , then Y \u2243P Y \u2032; (2) If Y |= P and Y \u2032 6|= P , then Y <P Y \u2032; (3) If mod(P) = mod(Q), then \u2264P=\u2264Q.\nPlease note the similarities between an LP faithful assignment and a faithful\nassignment (cf. Definition 3). That is:\nRemark 1\nLet \u03a61 be an assignment that associates with every GLP P a total preorder \u2264P over interpretations, and \u03a62 be and assignment that associates with every formula \u03c6 a total preorder \u2264\u03c6 over interpretations. If for every GLP P , we have \u03a61(P) = \u03a62(\u03b12P), then \u03a61 is an LP faithful assignment if and only if \u03a62 is a faithful assignment.\nDefinition 13 (Well-defined assignment)\nA well-defined assignment is a mapping which associates with every GLP P and every interpretation Y a set of interpretations, denoted by P(Y ), such that for all GLPs P ,Q and all interpretations X ,Y , the following conditions hold:\n(a) Y \u2208 P(Y );\n(b) If X \u2208 P(Y ), then X \u2286 Y ;\n(c) If (X ,Y ) \u2208 SE(P), then X \u2208 P(Y );\n(d) If (X ,Y ) /\u2208 SE(P) and Y |= P , then X /\u2208 P(Y );\n(e) If P \u2261s Q, then P(Y ) = Q(Y ).\nDefinition 14 (GLP parted assignment)\nA GLP parted assignment is a pair (\u03a6,\u03a8), where \u03a6 is an LP faithful assignment and \u03a8 is a well-defined assignment.\nWe are ready to bring to light our main result:\nProposition 3\nAn LP operator \u22c6 is a GLP revision operator if and only if there exists a GLP parted assignment (\u03a6,\u03a8), where \u03a6 associates with every GLP P a total preorder \u2264P , \u03a8 associates with every GLP P and every interpretation Y a set of interpretations P(Y ), and such that for all GLPs P ,Q,\nSE(P \u22c6Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P ),X \u2208 P(Y )}\u00b7\nNote that there is no relationship between the LP faithful assignment \u03a6 and the well-defined assignment \u03a8 forming a GLP parted assignment, that is, each one of these two mappings can be defined in a completely independent way.\nExample 7\nLet us consider again the GLP P =\n{\np \u2190\u223c q, \u22a5 \u2190 p, q\n}\nfrom Example 3, and recall that\nSE(P) = {(p, p), (\u2205, q), (q, q)}. Note that the (classical) models of P (i.e.,mod(P) = {p, q}) correspond to the models of the propositional formula \u03c6 given in Example 1 (i.e., mod(\u03c6) = {p, q}). Hence, due to Remark 1 the total preorder \u2264P=\u2264\u03c6, i.e., defined as p \u2243P q <P pq <P \u2205 satisfies the conditions of an LP faithful assignment (denoted \u03a6). Furthermore, let us consider the mapping \u03a8 associating with P and every interpretation Y the following sets of interpretations: P(\u2205) = {\u2205}, P(p) = {p}, P(q) = {\u2205, q} and P(pq) = {p, pq}. One can also check that \u03a8 satisfies the conditions (a - e) from Definition 13, so \u03a8 is a well-defined assignment. Hence, (\u03a6,\u03a8) is a GLP parted assignment. Figure 2 gives a graphical representation of the total preorder \u2264P and the sets P(Y ) for each Y \u2208 \u2126. In the figure, all interpretations are ordered w.r.t. \u2264P (similarly to Figure 1), and for each such interpretation Y , the set of circle interpretations next to Y corresponds to the set P(Y ).\nNow, let us denote \u22c6 the GLP revision operator corresponding to this GLP parted assignment, and let Q1 and Q2 be two GLPs defined as Q1 = {q \u2190\u223c p} and\nQ2 =\n{\n\u22a5 \u2190 p,\u223c q, \u22a5 \u2190 q,\u223c p, p;\u223c p \u2190 \u22a4, q;\u223c q \u2190 \u22a4\u00b7\n}\n\u00b7 We get that:\n\u2022 SE(Q1) = {(\u2205, p), (p, p), (q, q), (\u2205, pq), (p, pq), (q , pq), (pq, pq)}; then accor-\nding to Proposition 3, we get that SE(P \u22c6 Q1) = {(p, p), (q, q)}. Further-\nmore, the GLP R1 =\n\n\n\np \u2190\u223c q, q \u2190\u223c p, \u22a5 \u2190 p, q\n\n\n\nis such that SE(R1) = {(p, p), (q, q)} =\nSE(P \u22c6Q1). Therefore,\nP \u22c6Q1 =\n{\np \u2190\u223c q, \u22a5 \u2190 p, q\n}\n\u22c6 {q \u2190\u223c p} \u2261s\n\n\n\np \u2190\u223c q, q \u2190\u223c p, \u22a5 \u2190 p, q\n\n\n\n\u00b7\n\u2022 SE(Q2) = {(\u2205, \u2205), (pq, pq)}; then according to Proposition 3, we get that\nSE(P \u22c6 Q2) = {(pq, pq)}. Furthermore, the GLP R2 =\n{\np \u2190 \u22a4, q \u2190 \u22a4\n}\nis such\nthat SE(R2) = {(pq, pq)} = SE(P \u22c6Q2). Therefore,\nP \u22c6Q2 =\n{\np \u2190\u223c q, \u22a5 \u2190 p, q\n}\n\u22c6\n{\n\u22a5 \u2190 p,\u223c q, \u22a5 \u2190 q,\u223c p, p;\u223c p \u2190 \u22a4, q;\u223c q \u2190 \u22a4\u00b7\n}\n\u2261s\n{\np \u2190 \u22a4, q \u2190 \u22a4\n}\n\u00b7\nThe SE models of Q1 and Q2 are respectively illustrated in Figures 3(a) and 3(b).\nDue to the similarities between an LP faithful assignment (cf. Definition 12) and a faithful assignment (cf. Definition 3), an interesting consequence from Theorem 1 and Proposition 3 is that every GLP revision operator can be viewed as an extension of a (propositional) KM revision operator:\nDefinition 15 (Propositional-based LP revision operator) Let \u25e6 be a propositional revision operator and f be a mapping from \u2126 to 2\u2126 such that for every interpretation Y , Y \u2208 f (Y ) and if X \u2208 f (Y ) then X \u2286 Y . The propositional-based LP revision operator w.r.t. \u25e6 and f , denoted \u22c6\u25e6,f , is defined for all GLPs P ,Q by\nSE(P\u22c6\u25e6,fQ) =\n{\nSE(P +Q) if P +Q is consistent, {(X ,Y ) \u2208 SE(Q) | Y |= \u03b12P \u25e6 \u03b1 2 Q,X \u2208 f (Y )} otherwise.\n\u22c6\u25e6,f is said to be a propositional-based GLP revision operator if \u25e6 is a KM revision\noperator (i.e., satisfying postulates (R1 - R6)).\nProposition 4 An LP revision operator is a GLP revision operator if and only if it is a propositionalbased GLP revision operator.\nIn the previous section, we noticed that there is a one-to-one correspondence between the KM revision operators (modulo equivalence) and the set of all faithful assignments (cf. Proposition 1). Interestingly, we get a similar result in the case of GLP revision operators with respect to propositional-based GLP revision operators (cf. Corollary 2 below). Let us introduce an intermediate result:\nProposition 5 For all propositional-based GLP revision operators \u22c6\u25e61,f1 , \u22c6\u25e62,f2 , we have \u22c6\u25e61,f1 = \u22c6\u25e62,f2 if and only if \u25e61 = \u25e62 and f1 = f2.\nThis proposition tells us that if \u25e61 6= \u25e62 or f1 6= f2, then for some pair of GLPs P ,Q we will get P \u22c6\u25e61,f1 Q 6\u2261 P \u22c6\u25e62,f2 Q, that is to say, different choices of parameters for a propositional-based LP revision operator lead to different propositional-based LP revision operators. As a direct consequence of Propositions 4 and 5, we get that:\nCorollary 2 There is a one-to-one correspondence between the set of GLP revision operators and the set of propositional-based GLP revision operators.\nNote that the cardinality-based revision operator \u22c6c (cf. Definition 10) corresponds to the propositional-based GLP revision operator \u22c6\u25e6Dal ,f1 , where \u25e6Dal is the Dalal revision operator (cf. Definition 6) and f1 is defined for every interpretation Y as f1(Y ) = {X \u2208 \u2126 | X \u2286 Y and if X ( Y then X |= \u03b1(P,Y ) \u25e6Dal \u03b1Y }, where \u03b1Y is any propositional formula such that mod(\u03b1Y ) = {X \u2208 \u2126 | X \u2286 Y }, \u03b1(P,Y ) is any propositional formula satisfying mod(\u03b1(P,Y )) = {X \u2208 \u2126 | (X ,Y \u2032) \u2208 SE(P),Y \u2032 |= formY \u25e6Dal \u03b12P}, and formY is any propositional formula satisfying mod(formY ) = {Y }. In addition, the drastic GLP revision operator (cf. Definition 11) corresponds to the propositional-based GLP revision operator \u22c6\u25e6D ,f2 , where \u25e6D is the drastic revision operator (cf. Definition 5) and f2 is defined for every interpretation Y as f2(Y ) = 2 Y . Figures 4(a) and 4(b) provide the graphical representation of these two operators in terms of parted assignments similarly to Figure 2, focusing on the GLP P from Example 3.\nRemark that in the case where P and Q have no common SE models, then a (propositional-based) GLP revision operator \u22c6\u25e6,f \u201crejects\u201d as candidates for the SE models of the revised program P \u22c6\u25e6,f Q those SE interpretations whose second component is not a classical model of \u03b12P \u25e6 \u03b1 2 Q; that is to say, as an upstream selection step the potential resulting SE models are chosen with respect to their second component by the underlying propositional revision operator \u25e6. Then, one can see from Definition 15 that the function f is used as a second filtering step that is made with respect to the first component of those preselected SE interpretations,\nand that this final selection becomes independent of the underlying input program P . Then it becomes questionable whether the postulates (RA1 - RA6) sufficiently describe the rational behavior of LP revision operators. Indeed, we will show in the next section that this \u201cfreedom\u201d on the definition of the function f raises some issues for some specific subclasses of fully rational LP revision operators."}, {"heading": "4.2 Comparison with other existing works", "text": "As we already briefly mentionned in the introduction, Delgrande et al. (2013a) also recently proposed a constructive characterization of belief revision operators for logic programs that satisfy the whole set of postulates (RA1 - RA6). They considered various forms of logic programs, i.e., generalized, disjunctive, normal, positive, and Horn, so we shall now compare our characterization with the one given in (Delgrande et al. 2013a) for the case of GLPs:\nDefinition 16 (GLP compliant faithful assignment (Delgrande et al. 2013a))\nA GLP compliant faithful assignment is a mapping which associates every GLP P with a total preorder \u2264\u2217P over SE interpretations such that for all GLPs P ,Q and all SE interpretations (X ,Y ), (X \u2032,Y \u2032), the following conditions hold:\n(1) If (X ,Y ) \u2208 SE(P) and (X \u2032,Y \u2032) \u2208 SE(P), then (X ,Y ) \u2243\u2217P (X \u2032,Y \u2032); (2) If (X ,Y ) \u2208 SE(P) and (X \u2032,Y \u2032) 6\u2208 SE(P), then (X ,Y ) <\u2217P (X \u2032,Y \u2032); (3) If P \u2261s Q, then \u2264P=\u2264Q; (4) (Y ,Y ) \u2264\u2217P (X ,Y ).\nThe following theorem is expressed as a combination of Theorems 4 and 5 from\n(Delgrande et al. 2013a) applied to GLPs:\nTheorem 3 (Delgrande et al. 2013a)\nAn LP revision operator \u22c6 is a GLP revision operator (i.e., it satisfies postulates (RA1 - RA6)) if and only if there exists a GLP compliant faithful assignment associating every GLP P with a total preorder \u2264\u2217P such that for all GLPs P ,Q, SE(P \u22c6Q) = min(SE(Q),\u2264\u2217P). 2\nSince both our GLP parted assignments and Delgrande et al.\u2019s GLP compliant faithful assignments characterize the class of GLP revision operators, there must exist a relationship between the two structures. We denote by GLPpart the set of all GLP parted assignments and GLPfaith the set of all GLP compliant faithful assignments. We now formally establish a correspondence between the two sets.\n2 In (Delgrande et al. 2013a), an additional postulate is considered in the characterization theorems, namely (Acyc). However, it is harmless to omit this postulate here since (Acyc) is a logical consequence of the postulates (RA1 - RA6) in the case of generalized logic programs (cf. (Delgrande et al. 2013a), Theorem 2).\nDefinition 17 Let \u03c3part\u2192faith be a binary relation on GLPpart \u00d7 GLPfaith defined as follows. For every (\u03a6,\u03a8) \u2208 GLPpart (where \u03a6 associates every GLP P with a total preorder \u2264P , and \u03a8 associates every GLP P and every interpretation Y with a set of interpretations P(Y )), and for every \u0393 \u2208 GLPfaith (where \u0393 associates every GLP P with a total preorder \u2264\u2217P), we have ((\u03a6,\u03a8),\u0393) \u2208 \u03c3part\u2192faith if and only if for every GLP P , for all interpretations X ,Y ,Y \u2032, X \u2286 Y , the following conditions are satisfied:\n(i) (Y ,Y ) \u2264\u2217P (Y \u2032,Y \u2032) if and only if Y \u2264P Y \u2032, and\n(ii) (X ,Y ) \u2264\u2217P (Y ,Y ) if and only if X \u2208 P(Y ).\nWe show now that a pair of assignments from GLPpart \u00d7 GLPfaith satisfies the relation \u03c3part\u2192faith if and only if represent both assignments represent the same GLP revision operator:\nProposition 6 For every (\u03a6,\u03a8) \u2208 GLPpart and every \u0393 \u2208 GLPfaith , ((\u03a6,\u03a8),\u0393) \u2208 \u03c3part\u2192faith if and only if for all GLPs P ,Q, min(SE(Q),\u2264\u2217P) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q), \u2264P),X \u2208 P(Y )}.\nWhereas our GLP parted assignments are formed of two structures which are independent from each other (an LP faithful assignment used to order the second components of SE interpretations, and a well-defined assignment selecting the first component of SE interpretations), Delgrande et al.\u2019s GLP compliant faithful assignments consist of a single structure, i.e., a set of total preoders over SE interpretations. Though it may look simpler to represent a GLP revision operator through a single assignment, it turns out that the induced characterization (cf. Theorem 3) is not a one-to-one correspondence; more precisely, \u03c3part\u2192faith is not a function and as a consequence, a given GLP revision operator can be represented by different GLP compliant faithful assignments. Roughly speaking, this is due to the fact that totality required by preorders \u2264\u2217P is actually not needed. Many comparisons between pairs of SE interpretations within a total preorder \u2264\u2217P are irrelevant to the GLP revision operator they correspond to. This is illustrated in the following example:\nExample 8 Consider again the GLP P from Example 3 and the GLP parted assignment (\u03a6,\u03a8) focusing on P depicted in Figure 2. Then Figure 5 depicts three total preorders \u22641P , \u2264 2 P and \u2264 3 P induced from three different GLP compliant faithful assignments \u03931, \u03932 and \u03933 which both correspond to the GLP parted assignment (\u03a6,\u03a8), i.e., ((\u03a6,\u03a8),\u03931), ((\u03a6,\u03a8),\u03932), ((\u03a6,\u03a8),\u03933) \u2208 \u03c3part\u2192faith . It can be easily checked that for any GLP Q, min(SE(Q),\u22641P) = min(SE(Q),\u2264 2 P) = min(SE(Q),\u2264 3 P). The SE interpretations enclosed in dashed boxes correspond to those (X ,Y ) \u2208 {(\u2205, p), (\u2205, pq), (q, pq)} whose comparison with other SE interpretations is irrelevant to the represented GLP revision operator, as far as one has (Y ,Y ) <iP (X ,Y ) for i \u2208 {1, 2, 3}.\nIn fact, one can see that as soon as the language contains at least two propositional variables, e.g., {p, q} \u2286 A with p 6= q, then the GLP P satisfying (p, p), (q, q) \u2208 SE(P) and (\u2205, p), (\u2205, q) /\u2208 SE(P) can be associated through a GLP compliant faithful assignment with at least three different total preorders; an arbitrary relative ordering between the SE interpretations (\u2205, p) and (\u2205, q) will have no effect on the corresponding GLP revision operator.\nRemoving the property of totality from preorders involved in a GLP compliant faithful could be an alternative towards establishing another one-to-one correspondence with GLP revision operators. However, our GLP parted assignments make clear the different roles played by the first and second components of SE interpretations in terms of GLP revision. One the one hand the second components are totally ordered, on the other hand the first components are arbitrarily selected as possible condidates for SE interpretations. This allows us to make precise the link with propositional faithful assignments and propositional revision operators, which would not be clear with a slight adjustment of GLP compliant faithful assignments. The next section shows how our propositional-based GLP revision operator facilitate the comprehension and analysis of GLP revision."}, {"heading": "5 GLP revision operators embedded into Boolean lattices", "text": "For every propositional revision operator \u25e6, let GLP(\u25e6) denote the set of all propositional-based LP revision operators w.r.t. \u25e6. One can remark that from Proposition 5, the set {GLP(\u25e6) | \u25e6 is a KM revision operator} forms a partition of the class of all GLP revision operators. Let us now take a closer look to the set of GLP revision operators GLP(\u25e6) when we are given any specific KM revision operator \u25e6:\nDefinition 18\nLet \u25e6 be a propositional revision operator. We define the binary relation \u25e6 over GLP(\u25e6) as follows: for all propositional-based LP revision operators \u22c6\u25e6,f1 , \u22c6\u25e6,f2 , \u22c6\u25e6,f1 \u25e6 \u22c6\u25e6,f2 if and only for every interpretation Y , we have f2(Y ) \u2286 f1(Y ).\nOne can see that for each revision operator \u25e6, the set (GLP(\u25e6), \u25e6) forms a structure that is isomorphic to a Boolean lattice3, and the careful reader will notice that (GLP(\u25e6), \u25e6) precisely corresponds to the product of the Boolean lattices {(BY ,\u2286) | Y \u2208 \u2126}, where BY = {Z\u222a{Y } | Z \u2208 22 Y \\Y }. The following result shows that this lattice structure can be used to analyse the relative semantic behavior of GLP revision operators from (GLP(\u25e6), \u25e6).\nProposition 7 Let \u25e6 be a KM revision operator. It holds that for all GLP revision operators \u22c61, \u22c62 \u2208 GLP(\u25e6), \u22c61 \u25e6 \u22c62 if and only if for all GLPs P ,Q, we have AS (P \u22c61 Q) \u2286 AS (P \u22c62 Q).\nThis result paves the way for the choice of a specific GLP revision operator depending on the desired \u201camount of information\u201d provided by the revised GLP in terms of number of its answer sets. Precisely, any GLP revision operator \u22c6\u25e6,f can be specified from an answer set point of view by the following roadmap. Since in the case where P + Q is consistent, we always have P \u22c6\u25e6,f Q = P + Q, the intuition underlying this procedure only applies when the programs considered for the revision have no common SE model. First, one chooses a KM revision operator \u25e6 whose role is to filter the undesired answer sets of the resulting revised program: only the models Y of the formula resulting from the revision of P by Q in the propositional sense should be selected as \u201cpotential answer set candidates\u201d. Then, the function f plays a role in filtering those preselected candidates Y , so that f can be defined according to the following intuition: the more interpretations X ( Y are included in f (Y ), the less likely the interpretation Y will actually be an answer set of the resulting revised program. More precisely, the presence of a given interpretation X ( Y in f (Y ) is enough to discard Y as being an answer set of the resulting revised program when (X ,Y ) is an SE model of Q.\nThis brings in light that, depending on the \u201cposition\u201d of the GLP revision operator \u22c6\u25e6,f in the lattice (GLP(\u25e6), \u25e6), when revising P by Q one may expect divergent results for AS (P \u22c6\u25e6,f Q). We illustrate this claim by considering two specific classes of GLP revision operators that correspond respectively to the suprema and infima of lattices (GLP(\u25e6), \u25e6) for all KM revision operators \u25e6. The first \u201cextreme\u201d operators are defined as follows:\nDefinition 19 (Skeptical GLP revision operators) The skeptical GLP revision operators, denoted \u22c6\u25e6S are the propositional-based GLP revision operators \u22c6\u25e6,f where f is defined for every interpretation Y by f (Y ) = 2Y .\nNote that skeptical GLP revision operators include the drastic GLP revision operator \u22c6D (cf. Definition 11), i.e., \u22c6D = \u22c6 \u25e6D S where \u25e6D is the (propositional) drastic revision operator. For each propositional revision operator \u25e6, we clearly have \u22c6\u25e6S = inf (GLP(\u25e6), \u25e6). We provide now an axiomatic characterization of the\n3 A Boolean lattice is a partially ordered set (E ,\u2264E ) which is isomorphic to the set of subsets of some set F together with the usual set-inclusion operation, i.e., (2F ,\u2286).\nskeptical GLP revision operators in order to get a clearer view of their general behavior:\nProposition 8 The skeptical GLP revision operators are the only GLP revision operators \u22c6 such that for all GLPs P ,Q, whenever P+Q is inconsistent, we haveAS (P\u22c6Q) \u2286 AS (Q).\nRemark that the drastic GLP revision operator (cf. Definition 11), i.e., the skeptical GLP revision operator based on the propositional drastic revision operator \u22c6\u25e6DS , is a specific case from the result given in Proposition 8 where AS (P\u22c6\u25e6DS Q) = AS (Q) whenever P +Q is inconsistent.\nWe now introduce another class of GLP revision operators which correspond to\nthe other \u201cextreme cases\u201d with respect to lattices (GLP(\u25e6), \u25e6):\nDefinition 20 (Brave GLP revision operators) The brave GLP revision operators, denoted \u22c6\u25e6B are the propositional-based GLP revision operators \u22c6\u25e6,f where f is defined for every interpretationY by f (Y ) = {Y }.\nWe get now that for each propositional revision operator \u25e6, \u22c6\u25e6B = sup(GLP(\u25e6),\n\u25e6). The brave operators are axiomatically characterized as follows:\nProposition 9 The brave GLP revision operators are the only GLP revision operators \u22c6\u25e6,f such that for all GLPs P ,Q, whenever P + Q is inconsistent, we have AS (P \u22c6\u25e6,f Q) = mod(\u03b12P \u25e6 \u03b1 2 Q).\nLet us remark as a specific case that the brave GLP revision operator based on the propositional drastic revision operator, i.e., the operator \u22c6\u25e6DB , satisfies AS (P \u22c6 \u25e6D B Q) = mod(Q) whenever P +Q is inconsistent.\nThe following representative example illustrates how much the behavior of skep-\ntical and brave GLP revision operators diverge:\nExample 9\nConsider \u25e6D , i.e., the propositional drastic revision operator. Let P =\n\n\n\np \u2190 \u22a4, q \u2190 \u22a4, \u22a5 \u2190 r\n\n\n\nand Q = {\u22a5 \u2190 p, q,\u223c r}. We have AS (P) = {p, q}, AS (Q) = {\u2205}, and {\nAS (P \u22c6\u25e6DS Q) = {\u2205}, AS (P \u22c6\u25e6DB Q) = {\u2205, p, q, r , pr , qr , pqr}\u00b7\nThough they are rational LP revision operators w.r.t. the postulates (RA1 - RA6), skeptical and brave operators have a rather trivial, thus undesirable behavior. Consider first the case of skeptical operators and assume that the proposition p is believed to be false, then learned to be true. That is, {\u22a5 \u2190 p} \u2286 P and Q = {p \u2190 \u22a4}. Then one obtains that AS (P \u22c6\u25e6S Q) \u2286 AS (Q), that is, AS (P \u22c6 \u25e6 S Q) \u2286 {p}, i.e., for any such program P , on learning that p is true the revision states that only p may be true, which holds independently from the choice of the KM revision\noperator \u25e6. On the other hand, brave operators only focus on classical models of logic programs P ,Q to compute P \u22c6\u25e6B Q (whenever P + Q is inconsistent), thus they do not take into consideration the inherent, non-monotonic behavior of logic programs. As a consequence, programs P \u22c6\u25e6B Q will often admit many answer sets that are actually irrelevant to the input programs P and Q.\nStated otherwise, skeptical and brave GLP revision operators are dual sides of a \u201cdrastic\u201d behavior for the revision. These operators are representative examples that provide some \u201cbounds\u201d of the complete picture of GLP revision operators GLP(\u25e6), for each KM revision operator \u25e6. Discarding such drastic behaviors may call for additional postulates in order to capture more parsimonious revision procedures in logic programming, as for instance the cardinality-based revision operator (cf. Definition 10) which is neither brave nor skeptical. Then it seems necessary to refine the existing properties that every rational revision operator should satisfy so that the answer sets of the revised program P \u22c6\u25e6,f Q fall \u201cbetween\u201d these two extremes (i.e., between AS (Q) and mod(P \u25e6 Q) in the sense of set inclusion).\nAnother benefit from our characterization result is that one can easily derive computational results by exploiting existing ones from propositional revision. We assume that the reader is familiar with the basic concepts of computational complexity, in particular with the classes P, NP and coNP (see (Papadimitriou 1994) for more details). Higher complexity classes are defined using oracles. In particular PC corresponds to the class of decision problems that are solved in polynomial time by deterministic Turing machines using an oracle for C in polynomial time. For instance, \u0398p2 = P NP[O(log n)] is the class of problems that can be solved in polynomial time by a deterministic Turing machine using a number of calls to an NP oracle bounded by a logarithmic function of the size of the input representation of the problem.\nWe focus here on the the model-checking problem (Liberatore and Schaerf 2001) for LP revision operators. In the propositional case, the model-checking problem consists in deciding whether a (propositional) interpretation is supported by a revised formula:\nProblem 1 (MC(\u25e6))\n\u2022 Input: A propositional revision operator \u25e6, two formulae \u03c6, \u03c8 and an inter-\npretation I ,\n\u2022 Question: Does I |= \u03c6 \u25e6 \u03c8 hold?\nThe model-checking problem for the drastic revision operator (cf. Definition 5) is coNP-complete, while it is \u0398p2 -complete for the Dalal revision operator (cf. Definition 6):\nProposition 10 MC(\u25e6D ) is coNP-complete.\nTheorem 4 (Liberatore and Schaerf 2001 ) MC(\u25e6Dal ) is \u0398 p 2-complete.\nSimilarly one can consider the model-checking problem for LP revision operators which consists in deciding whether an SE interpretation is an SE model of a revised program:\nProblem 2 (MCSE(\u22c6))\n\u2022 Input: An LP revision operator \u22c6, two GLPs P ,Q and an SE interpretation\n(X ,Y ),\n\u2022 Question: Does (X ,Y ) belong to SE(P \u22c6Q)?\nRemark that given an SE interpretation (X ,Y ) and a logic program P , checking whether (X ,Y ) is an SE model of P is in P: computing the program PY , i.e., the reduct of P relative to Y , is performed in polynomial time; then it is enough to check whether Y |= P and X |= PY which is performed in polynomial time. Interestingly, when f is computed in polynomial time the model-checking problem for propositional-based LP revision operators \u22c6\u25e6,f is not harder than the counterpart problem for the propositional revision operator \u25e6. Obviously enough, this applies for both skeptical and brave GLP revision operators, so Proposition 10 and Theorem 4 provide us with the following complexity results:\nCorollary 3\n\u2022 MCSE(\u22c6 \u25e6D S ) and MCSE(\u22c6 \u25e6D B ) are coNP-complete; \u2022 MCSE(\u22c6 \u25e6Dal S ) and MCSE(\u22c6 \u25e6Dal B ) are \u0398 p 2-complete."}, {"heading": "6 The case of disjunctive and normal logic programs", "text": "In this section we take a look at more restrictive forms of programs, i.e., the disjunctive logic programs and the normal logic programs. A disjunctive logic program (DLP) is a GLP where rules are of the form\na1; . . . ; ak \u2190 b1, . . . , bl ,\u223c c1, . . . ,\u223c cm ,\nwhere k , l ,m \u2265 0. A normal logic program (NLP) is a DLP where k = 1.\nLet us recall that every GLP has a well-defined set S of SE models, which requires that (Y ,Y ) \u2208 S for every (X ,Y ) \u2208 S , and that conversely, for every well-defined set S of SE interpretations one can build a GLP P such that SE(P) = S . Since NLPs and DLPs are syntactically more restrictive than GLPs, these programs are characterized by sets of SE models satisfying stronger conditions. A set of SE interpretations S is said to be:\n\u2022 complete if it is well-defined and for all interpretations X ,Y ,Z , if Y \u2286 Z\nand (X ,Y ), (Z ,Z ) \u2208 S then also (X ,Z ) \u2208 S ;\n\u2022 closed under here-intersection if it is complete and for all interpretations\nX ,Y ,Z , if (X ,Z ), (Y ,Z ) \u2208 S then also (X \u2229 Y ,Z ) \u2208 S .\nEach DLP (respectively, NLP) has a complete (respectively, closed under hereintersection) set of SE models. Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007). For instance, one can easily check that:\n\u2022 the logic program P =\n{\np \u2190\u223c q, \u22a5 \u2190 p, q\n}\nfrom Example 3 is a NLP and SE(P)\nis well-defined, complete and closed under here-intersection;\n\u2022 the logic program P2 =\n{\np \u2190\u223c q, p; q \u2190 \u22a4\n}\nfrom Example 5 is a DLP and SE(P2)\nis well-defined and complete, but not closed under here-intersection;\n\u2022 the logic program Q2 =\n{\n\u22a5 \u2190 p,\u223c q, \u22a5 \u2190 q,\u223c p, p;\u223c p \u2190 \u22a4, q;\u223c q \u2190 \u22a4\u00b7\n}\nfrom Example 7 is\na GLP and SE(Q) is well-defined but not complete.\nWhen revising a logic program by another one, one expects the resulting revised\nprogram to be expressed in the same language as the input programs.\nDefinition 21 (DLP/NLP revision operator) A DLP revision operator (respectively, a NLP revision operator) \u22c6 is an LP revision operator associating two DLPs (respectively, two NLPs) P ,Q with a new DLP (respectively, a new NLP) P \u22c6Q, and which satisfies postulates (RA1 - RA6).\nWe first remark that both sets of DLP revision operators and NLP revision operators are not empty. Indeed, one can observe that the intersection of two complete sets of SE interpretations is also complete, thus the expansion of two DLPs leads to a DLP. This also applies for NLPs. As a direct consequence, the drastic LP revision operator (cf. Definition 11) is both a DLP revision operator and a NLP revision operator. In fact, we have the more general result:\nProposition 11 The skeptical GLP revision operators are both DLP revision operators and NLP revision operators.\nHowever, the above result does not apply for all GLP revision operators. That is to say, there exist some GLP revision operators which associate two NLPs with a GLP which is not a DLP. Hence, our sound and complete construction of GLP revision operators does not hold anymore for DLP and NLP revision operators. For instance, brave GLP revision operators are neither DLP revision operators nor NLP revision operators, as shown in the following example:\nExample 10\nLet P =\n\n\n\n\u22a5 \u2190\u223c p,\u223c q, \u22a5 \u2190 q,\u223c p, \u22a5 \u2190 p, q\n\n\n\nand Q = {q \u2190 \u22a4} be two NLPs. We have that\nSE(P) = {(\u2205, p), (p, p)} and SE(Q) = {(q, q), (q, pq), (pq, pq)}. Consider the brave GLP revision operator \u22c6\u25e6DB based on the propositional drastic revision operator. Then one can verify that SE(P \u22c6\u25e6DB Q) = {(q, q), (pq, pq)} is not a complete set of SE interpretations, thus P \u22c6\u25e6DB Q cannot be represented as a DLP.\nAs a consequence, our characterization result from Proposition 3 does not hold anymore for DLP/NLP revision operators. Nevertheless, we provide below a representation of both DLP and NLP revision operators in terms of two structures where the first one is an LP faithful assignment adapted to DLPs/NLPs and the second one is a well-defined assignment \u201cstrengthened\u201d by some further conditions.\nDefinition 22 (DLP/NLP faithful assignment) A DLP faithful assignment (respectively, a NLP faithful assignment) is a mapping which associates every DLP (respectively, every NLP) with a total preorder over interpretations such that conditions (1 - 3) of an LP faithful assignment are satisfied.\nDefinition 23 (Complete assignment) Let \u03a6 be a DLP faithful assignment which associates every DLP P with a total preorder \u2264P . A \u03a6-based complete assignment is a mapping which associates with every DLP P and every interpretation Y a set of interpretations denoted by P\u03a6(Y ), such that conditions (a - e) of a well-defined assignment are satisfied as well as the following further condition, for all interpretations X ,Y ,Z :\n(f) If X \u2208 P\u03a6(Y ), Y \u2243P Z and Y \u2286 Z then X \u2208 P\u03a6(Z ).\nA pair (\u03a6,\u03a8\u03a6), where \u03a6 is a DLP faithful assignment and \u03a8\u03a6 is a \u03a6-based complete assignment, is called a DLP parted assignment.\nDefinition 24 (Normal assignment) Let \u03a6 be a NLP faithful assignment. A \u03a6-based normal assignment is a mapping which associates with every NLP P and every interpretation Y a set of interpretations denoted by P\u03a6(Y ), such that conditions (a - f) of a complete assignment are satisfied as well as the following further condition, for all interpretations X ,Y ,Z :\n(g) If X ,Y \u2208 P\u03a6(Z ) then X \u2229 Y \u2208 P\u03a6(Z ).\nA pair (\u03a6,\u03a8\u03a6), where \u03a6 is a NLP faithful assignment and \u03a8\u03a6 is a \u03a6-based normal assignment, is called a NLP parted assignment.\nWe are ready to provide our characterization results for DLP revision operators\nand NLP revision operators:\nProposition 12 An LP operator \u22c6 is a DLP (resp. NLP) revision operator if and only if there exists a DLP (resp. NLP) parted assignment (\u03a6,\u03a8\u03a6), where \u03a6 associates with every DLP (resp. NLP) P a total preorder \u2264P , \u03a8\u03a6 is a \u03a6-based complete (resp. normal) assignment which associates with every DLP (resp. NLP) P and every interpretation Y a set of interpretations P\u03a6(Y ), and such that for all DLPs (resp. NLPs) P ,Q,\nSE(P \u22c6Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P\u03a6(Y )}\u00b7\nAs to the case of our characterization of GLP revision operators, Proposition 12 provides us with sound and complete constructions of DLP and NLP revision operators in terms of total preorders over propositional interpretations and some further conditions specific to SE interpretations. Furthermore, because both constructions are similar to the one of GLP revision operators, without stating it formally one\ncan straightforwardly establish a one-to-one correspondence between DLP/NLP revision operators and propositional-based LP revision operators (cf. Definition 15) satisfying some further conditions on the function f very similar to conditions (f) and (g). Indeed, one can see from Definition 23 and 24 that the two structures involved in DLP/NLP parted assignments are not independent anymore, since by condition (f) the \u03a6-based complete and normal assignments should both be aligned with the corresponding faithful assignment. As a consequence, these structures are more complex than those of GLP parted assignments and similar embeddings of DLP/NLP revision operators into Boolean lattices are no more applicable. A deeper investigation of the type of ruling structures for \u03a6-based complete and normal assignments is out of the scope of this paper, but constitutes an interesting direction to explore in a future work."}, {"heading": "7 Conclusion", "text": "In this paper, we pursued some previous work on revision of logic programs, where the adopted approach is based on a monotonic characterization of logic programs using SE interpretations. We gave a particular attention to the revision of generalized logic programs (GLPs) and characterized the class of rational GLP revision operators in terms of total orderings among classical interpretations with some further conditions specific to SE interpretations. The constructive characterization we provided facilitates the comprehension of the semantic properties of GLP revision operators by drawing a clear, complete picture of them. Interestingly, we showed that a GLP revision operator can be viewed as an extension of a rational propositional revision operator: each propositional revision operator corresponds to a specific subclass of GLP revision operators, and a GLP revision operator from a particular subclass can be specified independentely of the propositional revision operator under consideration. Moreover, we showed that each one of these subclasses can be embedded into a Boolean lattice whose infimum and supremum, the so-called skeptical and brave GLP revision operators, have some relatively drastic behavior. In addition, we adjusted our representation structures and provided sound and complete constructions for two more specific classes of logic programs, i.e., the disjunctive and normal logic programs.\nOur results make easier the improvement of the current AGM framework in the context of logic programming. Indeed, though the subclasses of skeptical and brave revision operators are fully satisfactory w.r.t. the AGM revision principles, their behavior is shown to be rather trivial. This may call for additional postulates which would aim to capture more parsimonious, \u201cbalanced\u201d classes of revision operators.\nAs to the case of update of logic programs Slota and Leite (2013) argued that semantic rule updates based on SE models seem to be inappropriate. Indeed they showed that in presence of the irrelevance-of-syntax postulate (whose counterpart in the context of revision is (RA4)), semantic rule update operators based on SE models violate some reasonable properties for rule updates, i.e., dynamic support and fact update (see (Slota and Leite 2013) for more details). The property of dynamic support can be expressed unformally as follows: an rule update operator \u2295\nsatisfies dynamic support if every atom true in an answer set from any updated program P \u2295 Q should be supported by a rule in P \u222a Q, i.e., it should have some \u201cjustification\u201d in either the original program or the new one. The property of fact update requires some notion of atom inertia when updating a consistent set of facts (i.e., a set of rules of the type p \u2190 \u22a4 where p is an atom) by a consistent set of facts. Both of these properties require rule update operators to have a reasonable \u201csyntactic\u201d behavior, away from the purely semantic approach represented by the adapted AGM postulates. In (Slota and Leite 2012) the same authors successfully reconciliate semantic-based and syntax-based approaches to updating logic programs: they considered different characterizations of logic programs in terms of RE models (standing for robust equivalence models) that proved to be a more suitable semantic fundation for rule updates than SE models. A straightforward direction of research is to investigate whether these richer characterizations of logic programs suit to revision operators.\nAdditionally, we will investigate the case of logic program merging operators (merging can be viewed as a multi-source generalization of belief revision, see for instance (Konieczny and Pino Pe\u0301rez 2002)). Indeed it is not even known whether there exists a fully rational merging operator, i.e., that satisfies the whole set of postulates proposed by Delgrande et al. (2009; 2013b) for logic program merging operators based on SE models."}, {"heading": "Appendix: Proofs of Propositions", "text": "Proposition 1 There is a one-to-one correspondence between the KM revision operators and the set of all faithful assignments."}, {"heading": "Proof", "text": "Let \u25e61, \u25e62 be two KM revision operators. From Theorem 1 one can build two faithful assignments associating respectively with every formula \u03c6 the total preorders \u22641\u03c6 (for the first faithful assignment) and \u2264 2 \u03c6 (for the second one), such that for all formulae \u03c6, \u03c8, mod(\u03c6 \u25e61 \u03c8) = min(mod(\u03c8),\u22641\u03c6) and mod(\u03c6 \u25e62 \u03c8) = min(mod(\u03c8), \u22642\u03c6). Assume now that \u25e61 6= \u25e62. This means that there exist two propositional formulae \u03c6, \u03c8 such that \u03c6 \u25e61 \u03c8 6\u2261 \u03c6 \u25e62 \u03c8, so mod(\u03c6 \u25e61 \u03c8) 6= mod(\u03c6 \u25e62 \u03c8), thus min(mod(\u03c8),\u22641\u03c6) 6= min(mod(\u03c8),\u2264 2 \u03c6). Hence, \u2264 1 \u03c6 6=\u2264 2 \u03c6, so the two faithful assignments associated respectively with \u25e61 and \u25e62 are different. Conversely, assume that the two faithful assignments associated respectively with \u25e61 and \u25e62 are different. Then, there exists a formula \u03c6 such that \u22641\u03c6 6=\u2264 2 \u03c6. This means that there exists two interpretations I , J such that I \u22641\u03c6 J and J < 2 \u03c6 I . Let \u03c8 be any formula such that mod(\u03c8) = {I , J}. We have I \u2208 min(mod(\u03c8),\u22641\u03c6) and I /\u2208 min(mod(\u03c8),\u2264 2 \u03c6). Hence, mod(\u03c6 \u25e61 \u03c8) 6= mod(\u03c6 \u25e62 \u03c8), or equivalently, \u03c6 \u25e61 \u03c8 6\u2261 \u03c6 \u25e62 \u03c8. This means that \u25e61 6= \u25e62.\nProposition 2 \u22c6D is a GLP revision operator."}, {"heading": "Proof", "text": "Let P ,Q be two logic programs. The fact that P \u22c6D Q returns a GLP when P ,Q are both GLPs is obvious from the definition. Postulates (RA1 - RA4) are directly satisfied from the definition. (RA5 - RA6) Let P ,Q,R be three GLPs. If (P\u22c6DQ)+R is not consistent then (RA5) is trivially satisfied, so assume that (P \u22c6D Q) +R is consistent. We have to show that (P\u22c6DQ)+R \u2261s P\u22c6D (Q+R). We fall now into two cases. Assume first that P+Q is consistent. By definition, (P\u22c6DQ)+R = P+Q+R. Yet since (P \u22c6D Q) + R is consistent, so is P + Q +R, thus we get by definition P \u22c6D (Q + R) = P + Q + R. Therefore, (P \u22c6D Q) + R \u2261s P \u22c6D (Q + R). Now, assume that P +Q is not consistent. By definition, (P \u22c6D Q) +R = Q+R. Since P + Q is not consistent, we also have P + Q +R not consistent. So by definition P \u22c6D (Q+R) = Q+R. Hence, (P \u22c6D Q) +R \u2261s P \u22c6D (Q+R).\nProposition 3 An LP operator \u22c6 is a GLP revision operator if and only if there exists a pair (\u03a6,\u03a8), where \u03a6 is an LP faithful assignment associating with every GLP P a total preorder \u2264P , \u03a8 is a well-defined assignment associating with every GLP P and every interpretation Y a set of interpretations P(Y ), and such that for all GLPs P ,Q,\nSE(P \u22c6Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P ),X \u2208 P(Y )}\u00b7"}, {"heading": "Proof", "text": "(Only if part) In this proof, for every well-defined set of SE interpretations S , lp(S ) denotes any GLP P such that SE(P) = S . To alleviate notations, when S is of the form {(Y ,Y ) | Y \u2208 E} for some set of interpretations E , we write lp(E ) instead of lp(S ). For instance, lp({(Y ,Y ), (Y \u2032,Y \u2032), (Y (2),Y (2))}) will simply be denoted by lp({Y ,Y \u2032,Y (2)}). The proof exploits on several occasions the following remarks:\nRemark 2 If \u22c6 is an LP revision operator satisfying the postulates (RA5) and (RA6), then for all GLPs P ,Q,R such that (P \u22c6 Q) + R is consistent, we have (P \u22c6 Q) + R \u2261s P \u22c6 (Q+R).\nRemark 3 For all sets of interpretations E ,F , lp(E ) + lp(F ) \u2261s lp(E \u2229 F ).\nRemark 4 Let \u22c6 be an LP revision operator satisfying the postulates (RA1) and (RA3). Then for any GLP P and any non-empty set of interpretations E , mod(P \u22c6 lp(E )) 6= \u2205 and mod(P \u22c6 lp(E )) \u2286 E .\nLet \u22c6 be a GLP revision operator. For every GLP P , define the relation \u2264P over interpretations such that \u2200Y ,Y \u2032 \u2208 \u2126, Y \u2264P Y \u2032 iff Y |= P \u22c6 lp({Y ,Y \u2032}). Moreover, for every GLP P , \u2200Y \u2208 \u2126, let P(Y ) = {X \u2286 Y | (X ,Y ) \u2208 SE(P \u22c6 lp({(X ,Y ), (Y ,Y )}))}. Let P be any GLP. We first show that \u2264P is a total preorder. Let Y ,Y \u2032,Y (2) \u2208 \u2126. (Totality of \u2264P): By Remark 4, Y |= P \u22c6 lp({Y ,Y \u2032}) or Y \u2032 |= P \u22c6 lp({Y ,Y \u2032}). Hence, Y \u2264P Y \u2032 or Y \u2032 \u2264P Y . (Reflexivity of \u2264P): By Remark 4, Y |= P \u22c6 lp({Y }), so Y \u2264P Y . (Transitivity of \u2264P): Assume towards a contradiction that Y \u2264P Y \u2032, Y \u2032 \u2264P Y (2) and Y 6\u2264P Y (2). We consider two cases: Case 1: (P \u22c6 lp({Y ,Y \u2032,Y (2)})) + lp({Y ,Y (2)}) is consistent. Then we have\n(P \u22c6 lp({Y ,Y \u2032,Y (2)})) + lp({Y ,Y (2)})\n\u2261s P \u22c6 (lp({Y ,Y \u2032,Y (2)}) + lp({Y ,Y (2)})) (by Remark 2) \u2261s P \u22c6 lp({Y ,Y (2)}) (by Remark 3)\u00b7\nSince Y 6\u2264P Y (2), by definition of \u2264P we get that Y 6|= P \u22c6 lp({Y ,Y (2)}), hence Y 6|= P \u22c6 lp({Y ,Y \u2032,Y (2)}). By Remark 4, there are two remaining cases:\n(i) Y \u2032 |= P \u22c6 lp({Y ,Y \u2032,Y (2)}). In this case, (P \u22c6 lp({Y ,Y \u2032,Y (2)})) + lp({Y ,Y \u2032}) is\nconsistent, so\n(P \u22c6 lp({Y ,Y \u2032,Y (2)})) + lp({Y ,Y \u2032})\n\u2261s P \u22c6 (lp({Y ,Y \u2032,Y (2)}) + lp({Y ,Y \u2032})) (by Remark 2) \u2261s P \u22c6 lp({Y ,Y \u2032}) (by Remark 3)\u00b7\nSince Y \u2264P Y \u2032, by definition of \u2264P we get that Y |= P \u22c6 lp({Y ,Y \u2032}), hence Y |= P \u22c6 lp({Y ,Y \u2032,Y (2)}). which contradicts the previous conclusion that Y 6|= P \u22c6 lp({Y ,Y \u2032,Y (2)}).\n(ii) Y \u2032 6|= P \u22c6 lp({Y ,Y \u2032,Y (2)}). Since we also have that Y 6|= P \u22c6 lp({Y ,Y \u2032,Y (2)}),\nby Remark 4 we must have that Y (2) |= P \u22c6 lp({Y ,Y \u2032,Y (2)}) In this case, (P \u22c6 lp({Y ,Y \u2032,Y (2)})) + lp({Y \u2032,Y (2)}) is consistent, so\n(P \u22c6 lp({Y ,Y \u2032,Y (2)})) + lp({Y \u2032,Y (2)})\n\u2261s P \u22c6 (lp({Y ,Y \u2032,Y (2)}) + lp({Y \u2032,Y (2)})) (by Remark 2) \u2261s P \u22c6 lp({Y \u2032,Y (2)}) (by Remark 3)\u00b7\nSince Y \u2032 \u2264P Y (2), by definition of \u2264P we get that Y \u2032 |= P \u22c6 lp({Y \u2032,Y (2)}), hence Y \u2032 |= P \u22c6 lp({Y ,Y \u2032,Y (2)}), which is a contradiction.\nCase 2: (P\u22c6lp({Y ,Y \u2032,Y (2)}))+lp({Y ,Y (2)}) is not consistent. Then by Remark 4, Y \u2032 |= P\u22c6lp({Y ,Y \u2032,Y (2)}). Then (P\u22c6lp({Y ,Y \u2032,Y (2)}))+lp({Y ,Y \u2032}) is consistent, and by using Remark 2 and 3 and following similar reasonings as in (i), we get that Y \u2032 |= P\u22c6lp({Y ,Y \u2032}) and Y 6|= P\u22c6lp({Y ,Y \u2032}). By definition of \u2264P this contradicts Y \u2264P Y \u2032 and concludes the proof that \u2264P is a total preorder.\nNow, let Q be any GLP. We have to show that SE(P \u22c6Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P(Y )}. Let us denote by S the latter set and first show the first inclusion SE(P \u22c6Q) \u2286s S. Let (X ,Y ) \u2208 SE(P \u22c6 Q) and let us show that (i) (X ,Y ) \u2208 SE(Q), (ii) \u2200Y \u2032 |= Q,Y \u2264P Y \u2032 and that (iii) X \u2208 P(Y ). (i) is direct from (RA1). For (ii), let Y \u2032 |= Q. Since \u22c6 returns a GLP, SE(P \u22c6Q) is well-defined. That is, since (X ,Y ) \u2208 SE(P \u22c6 Q), we have Y |= P \u22c6 Q. Therefore, (P \u22c6Q) + lp({Y ,Y \u2032}) is consistent. So by Remark 2 and 3, Y |= P \u22c6 lp({Y ,Y \u2032}). Hence, Y \u2264P Y \u2032. For (iii), since (X ,Y ) \u2208 SE(P\u22c6Q), (P\u22c6Q)+lp({(X ,Y ), (Y ,Y )}) is consistent, so we have (X ,Y ) \u2208 SE(P \u22c6 lp({(X ,Y ), (Y ,Y )})) by Remark 2 and 3; hence, X \u2208 P(Y ). Let us now show the other inclusion S \u2286s SE(P \u22c6 Q). Assume (X ,Y ) \u2208 S. Then \u2200Y \u2032 |= Q, Y \u2264P Y \u2032 and X \u2208 P(Y ). First, from the definition of P(Y ) we have Y \u2208 P(Y ), so also (Y ,Y ) \u2208 S. Since S 6= \u2205, Q is consistent, thus by Remark 4 there exists Y\u2217 |= Q, Y\u2217 |= P \u22c6 Q. Let R# = lp({(X ,Y ), (Y ,Y ), (Y\u2217,Y\u2217)}). Note that R# \u2286s Q and that (P \u22c6 Q) + R# is consistent since Y\u2217 is a model of both P \u22c6 Q and R#. Then by Remark 2 we get that (P \u22c6Q)+R# \u2261s P \u22c6(Q+R#) \u2261s P \u22c6R#. Since we have to show that (X ,Y ) \u2208 SE(P \u22c6Q), it comes down to show that (X ,Y ) \u2208 SE(P \u22c6R#). Assume towards a contradiction that (X ,Y ) /\u2208 SE(P \u22c6R#). By Remark 4 and since Y\u2217 |= P \u22c6R#, we have two cases: (i) Y 6|= P \u22c6 R#. Since (P \u22c6 R#) + lp({(Y ,Y ), (Y\u2217,Y\u2217)}) is consistent, by Remark 2 and 3 we get that Y 6|= P \u22c6 lp({(Y ,Y ), (Y\u2217,Y\u2217)}). This contradicts Y \u2264P Y\u2217. (ii) Y |= P \u22c6R#. Since (P \u22c6R#) + lp({(X ,Y ), (Y ,Y )}) is consistent, by Remark 2 and 3 we get that (X ,Y ) /\u2208 SE(P \u22c6 lp({(X ,Y ), (Y ,Y )})). This contradicts X \u2208 P(Y ).\nIt remains to verify that all conditions (1 - 3) of the faithful assignment and\nconditions (a - e) of the well-defined assignment are satisfied:\n(1) Assume Y |= P and Y \u2032 |= P . By (RA2), P \u22c6 lp({Y ,Y \u2032}) \u2261s P + lp({Y ,Y \u2032}). So\nY |= P \u22c6 lp({Y ,Y \u2032}) and Y \u2032 |= P \u22c6 lp({Y ,Y \u2032}), hence Y \u2243P Y \u2032;\n(2) Assume Y |= P and Y \u2032 6|= P . By (RA2), P \u22c6 lp({Y ,Y \u2032}) \u2261s P + lp({Y ,Y \u2032}). So\nY |= P \u22c6 lp({Y ,Y \u2032}) and Y \u2032 6|= P \u22c6 lp({Y ,Y \u2032}), hence Y <P Y \u2032;\n(3) Obvious from (RA4); (a) By definition of P(Y ) and by (RA1) and (RA3), we must haveY |= P\u22c6lp({(X ,Y ), (Y ,Y )}),\ni.e., Y |= P(Y ); (b) If X \u2208 P(Y ) then X \u2286 Y by definition of P(Y ); (c) Assume (X ,Y ) \u2208 SE(P). Then Y |= P . By (RA2), P\u22c6lp({(X ,Y ), (Y ,Y )}) \u2261s P+\nlp({(X ,Y ), (Y ,Y )}) \u2261s lp({(X ,Y ), (Y ,Y )}), so (X ,Y ) \u2208 SE(P\u22c6lp({(X ,Y ), (Y ,Y )})).\nTherefore, X \u2208 P(Y ). (d) Assume (X ,Y ) /\u2208 SE(P) and Y |= P . By (RA2), P \u22c6 lp({(X ,Y ), (Y ,Y )}) \u2261s\nP+lp({(X ,Y ), (Y ,Y )}) \u2261s lp({Y }), so (X ,Y ) /\u2208 lp({(X ,Y ), (Y ,Y )}). Therefore,\nX /\u2208 P(Y ). (e) Obvious from (RA4).\n(If part) We consider a faithful assignment that associates with every GLP P a total preorder \u2264P and a well-defined assignment that associates with every GLP P and every interpretation Y a set P(Y ) \u2286 \u2126. For all GLPs P ,Q, let S(P ,Q) be the set of SE interpretations defined as S(P ,Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P(Y )}. Let P ,Q be two GLPs and let us show that S(P ,Q) is well-defined. Let (X ,Y ) \u2208 S(P ,Q). By condition (a) of the well-defined assignment and since X \u2286 Y , we have Y \u2208 P(Y ), so (Y ,Y ) \u2208 S(P ,Q). Hence, S(P ,Q) is well-defined. Then let us define an operator \u22c6 associating two GLPs P ,Q with a new GLP P \u22c6Q such that for all GLPs P ,Q, SE(P \u22c6Q) = S(P ,Q).\nIt remains to show that postulates (RA1 - RA6) are satisfied. Let P ,Q bet two\nGLPs.\n(RA1) By definition, SE(P \u22c6Q) \u2286 SE(Q). (RA2) Assume that P +Q is consistent. We have to show that SE(P \u22c6Q) = SE(P +Q).\nWe first show the inclusion SE(P \u22c6 Q) \u2286 SE(P + Q). Let (X ,Y ) \u2208 SE(P \u22c6 Q). Towards a contradicton, assume that (X ,Y ) /\u2208 SE(P + Q). By definition of \u22c6 we have (X ,Y ) \u2208 SE(Q), thus (X ,Y ) /\u2208 SE(P). We fall into two cases: (i) (Y ,Y ) \u2208 SE(P). Then from condition (d), we have X /\u2208 P(Y ). This contradicts (X ,Y ) \u2208 SE(P \u22c6Q); (ii) (Y ,Y ) /\u2208 SE(P). Then from condition (2), \u2200Y \u2032 |= P , Y \u2032 <P Y . In particular, \u2200Y \u2032 |= P +Q , Y \u2032 <P Y . This contradicts (X ,Y ) \u2208 SE(P \u22c6Q). We now show the other inclusion SE(P+Q) \u2286 SE(P \u22c6Q). Let (X ,Y ) \u2208 SE(P+Q). So (X ,Y ) \u2208 SE(Q). From conditions (1) and (2), \u2200Y \u2032 \u2208 \u2126, Y <P Y \u2032. Moreover from condition (c), since (X ,Y ) \u2208 SE(P) we get that X \u2208 P(Y ). Therefore,\n(X ,Y ) \u2208 SE(P \u22c6Q). (RA3) Suppose that Q is consistent, i.e., SE(Q) 6= \u2205. As \u2126 is a finite set of interpretations,\nwe have no infinite descending chain of inequalities w.r.t. \u2264P . Moreover, \u2264P is a total relation. Hence, there is an interpretation Y\u2217 |= Q such that \u2200Y \u2032 |= Q, Y\u2217 \u2264P Y \u2032. Lastly by condition (a), Y\u2217 \u2208 PY\u2217 . Hence, Y\u2217 |= P \u22c6 Q, i.e., P \u22c6 Q is\nconsistent. (RA4) Obvious by definition of \u22c6 and from conditions (3) and (e). (RA5) Let (X ,Y ) \u2208 SE((P \u22c6 Q) + R). So by definition of \u22c6, \u2200Y \u2032 |= Q, Y \u2264P Y \u2032 and\nX \u2208 P(Y ). In particular, \u2200Y \u2032 |= Q +R, Y \u2264P Y \u2032 and X \u2208 P(Y ). So (X ,Y ) \u2208 SE(P \u22c6 (Q+R)).\n(RA6) Assume that (P \u22c6 Q) + R is consistent. Let Y\u2217 |= (P \u22c6 Q) + R. Let (X ,Y ) \u2208\nSE(P \u22c6 (Q+R)). Assume towards a contradiction that (X ,Y ) /\u2208 SE((P \u22c6Q)+R). Since (X ,Y ) \u2208 SE(R), we have (X ,Y ) /\u2208 SE(P \u22c6 Q). But (X ,Y ) \u2208 SE(Q), this means that Y\u2217 <P Y or X /\u2208 P(Y ). Yet Y\u2217 |= Q+R, so (X ,Y ) /\u2208 SE(P \u22c6(Q+R)). This leads to a contradiction.\nProposition 4 An LP revision operator is a GLP revision operator if and only if it is a propositionalbased GLP revision operator."}, {"heading": "Proof", "text": "(Only If part) Let \u22c6 be a GLP revision operator. We have to show that there exists a KM revision operator \u25e6 and a mapping f from \u2126 to 2\u2126 such that \u2200Y \u2208 \u2126, Y \u2208 f (Y ) and if X \u2208 f (Y ) then X \u2286 Y , and such that for all GLPs P ,Q, SE(P \u22c6 Q) = SE(P \u22c6\u25e6,f Q). Yet from Proposition 3 there exists a GLP parted assignment (\u03a6,\u03a8), where \u03a6 associates with every GLP P a total preorder \u2264P and \u03a8 associates with every GLP P and every interpretation Y a set of interpretations P(Y ), such that for all GLPs P ,Q, SE(P \u22c6 Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P(Y )}. Then, let \u25e6 be the KM revision operator associated with the faithful assignment (cf. Definition 3) that associates with every propositional formula \u03c6 the total preorder \u2264\u03c6=\u2264P , where P is any GLP such that \u03c6 \u2261 \u03b12P (from Remark 1, such an assignment is, indeed, faithful and unique). Then from Theorem 1, for every Y \u2208 \u2126, Y \u2208 min(mod(Q),\u2264P) if and only if Y |= \u03b12P \u25e6 \u03b1 2 Q. Then define f as the mapping from \u2126 to 2 \u2126 such that \u2200Y \u2208 \u2126, f (Y ) = P(Y ). From conditions (a) and (b) of the well-defined assignment (cf. Definition 13), f is such that \u2200Y \u2208 \u2126, Y \u2208 f (Y ) and if X \u2208 f (Y ) then X \u2286 Y . Now, given two GLPs P ,Q, if P + Q is consistent, we directly get SE(P \u22c6 Q) = SE(P \u22c6\u25e6,f Q) from Definition 15 and postulate (RA2). So assume that P + Q is inconsistent. Given an SE interpretation (X ,Y ), we have (X ,Y ) \u2208 SE(P \u22c6 Q) if and only if (X ,Y ) \u2208 SE(Q), Y \u2208 min(mod(Q),\u2264P) and X \u2208 P(Y ), if and only if (X ,Y ) \u2208 SE(Q), Y |= \u03b12P \u25e6 \u03b1 2 Q and X \u2208 f (Y ), if and only if (X ,Y ) \u2208 SE(P \u22c6\u25e6,f Q). That is to say, SE(P \u22c6Q) = SE(P \u22c6\u25e6,f Q).\n(If part) Let \u22c6\u25e6,f be a propositional-based GLP revision operator. We have to show that there exists a GLP revision operator \u22c6 such that SE(P \u22c6\u25e6,f Q) = SE(P \u22c6Q). Since \u25e6 is a KM revision operator, from Theorem 1 there is a faithful assignment associating with every propositional formula \u03c6 a total preorder \u2264\u03c6. Then using Remark 1, let \u03a6 be the LP faithful assignment associating with every GLP P the total preorder \u2264P=\u2264\u03c6, where \u03c6 is any propositional formula such that \u03b12P \u2261 \u03c6. From Theorem 1, for all GLPs P ,Q and for every Y \u2208 \u2126, Y |= \u03b12P \u25e6 \u03b1 2 Q if and only if Y \u2208 min(mod(Q),\u2264P). Now, let \u03a8 be the mapping associating with every GLP P and every interpretation Y the set of interpretations P(Y ) = {X \u2208 \u2126 | (X ,Y ) \u2208 SE(P)} \u222a {X \u2208 f (Y ) | Y 6|= P}. By definition, \u03a8 satisfies conditions (a) - (e) of a well-defined assignment (cf. Definition 13). Then, let us consider\nthe GLP revision operator \u22c6 associated with the GLP parted assignment (\u03a6,\u03a8). We need to check that for all GLPs P ,Q, SE(P \u22c6 Q) = SE(P \u22c6\u25e6,f Q). Given two GLPs P ,Q, if P + Q is consistent, we directly get SE(P \u22c6 Q) = SE(P \u22c6\u25e6,f Q) from Definition 15 and postulate (RA2). So assume that P +Q is inconsistent. We first prove that SE(P \u22c6 Q) \u2286 SE(P \u22c6\u25e6,f Q). Let (X ,Y ) \u2208 SE(P \u22c6 Q). We have (X ,Y ) \u2208 SE(Q), Y \u2208 min(mod(Q),\u2264P) and X \u2208 P(Y ). Thus (X ,Y ) \u2208 SE(Q), Y |= \u03b12P \u25e6 \u03b1 2 Q and X \u2208 P(Y ). We need to show that X \u2208 f (Y ). Yet since P + Q is inconsistent, we have (X ,Y ) 6\u2208 SE(P); and since (X ,Y ) \u2208 SE(Q), we also have (Y ,Y ) \u2208 SE(Q), so (Y ,Y ) 6\u2208 SE(P), thus Y 6|= P . By definition of P(Y ), this means that X \u2208 f (Y ). Since (X ,Y ) \u2208 SE(Q), Y |= \u03b12P \u25e6 \u03b1 2 Q and X \u2208 f (Y ), we have (X ,Y ) \u2208 SE(P \u22c6\u25e6,f Q). Therefore, SE(P \u22c6Q) \u2286 SE(P \u22c6\u25e6,f Q). We prove now that SE(P \u22c6\u25e6,f Q) \u2286 SE(P \u22c6Q). Let (X ,Y ) \u2208 SE(P \u22c6Q). We have (X ,Y ) \u2208 SE(Q), Y \u2208 \u03b12P \u25e6 \u03b1 2 Q and X \u2208 f (Y ). Thus (X ,Y ) \u2208 SE(Q), Y \u2208 min(mod(Q),\u2264P ) and X \u2208 f (Y ). We need to show that X \u2208 P(Y ). Yet since P +Q is inconsistent and since we have (X ,Y ) \u2208 SE(Q), we also have (Y ,Y ) \u2208 SE(Q), so (Y ,Y ) 6\u2208 SE(P), thus Y 6|= P . So by definition of P(Y ), we get that X \u2208 P(Y ). Since (X ,Y ) \u2208 SE(Q), Y \u2208 min(mod(Q),\u2264P) and X \u2208 P(Y ), we have (X ,Y ) \u2208 SE(P \u22c6 Q). Therefore, SE(P \u22c6\u25e6,f Q) \u2286 SE(P \u22c6Q). Hence, SE(P \u22c6\u25e6,f Q) = SE(P \u22c6Q).\nProposition 5 For all propositional-based GLP revision operators \u22c6\u25e61,f1 , \u22c6\u25e62,f2 , we have \u22c6\u25e61,f1 = \u22c6\u25e62,f2 if and only if \u25e61 = \u25e62 and f1 = f2."}, {"heading": "Proof", "text": "Let \u22c6\u25e61,f1 , \u22c6\u25e62,f2 be two propositional-based GLP revision operators. (If part) Obvious by Definition 15. (Only If part) Let us prove the contraposite, i.e., assume that \u25e61 6= \u25e62 or f1 6= f2 and let us show that \u22c6\u25e61,f1 6= \u22c6\u25e62,f2 . First, assume that \u25e61 6= \u25e62. This means that there exist two propositional formulae \u03c6, \u03c8 such that \u03c6\u25e61\u03c8 6\u2261 \u03c6\u25e62\u03c8. Then, let P ,Q be two GLPs defined such that \u03b12P \u2261 \u03c6 and \u03b1 2 Q \u2261 \u03c8. We have mod(\u03b1 2 P \u25e61 \u03b1 2 Q) 6= mod(\u03b12P \u25e62 \u03b1 2 Q). By Definition 15 since \u22c6 \u25e61,f1 , \u22c6\u25e62,f2 are both propositional-based GLP revision operators, \u25e61 and \u25e62 are both KM revision operators. This means that \u25e61 and \u25e62 satisfy the postulate (R2) (see Definition 2), but since mod(\u03b12P \u25e61 \u03b12Q) 6= mod(\u03b1 2 P \u25e62 \u03b1 2 Q), this also means that \u03b1 2 P \u2227 \u03b1 2 Q is inconsistent, i.e., P +Q is inconsistent. Hence, from Definition 15 we can see that for every propositional-based LP revision operator \u22c6\u25e6,f , we have mod(P \u22c6\u25e6,f Q) = mod(\u03b12P \u25e6 \u03b1 2 Q), This means that mod(P \u22c6\u25e61,f1 Q) 6= mod(P \u22c6\u25e62,f2 Q), thus SE(P \u22c6\u25e61,f1 Q) 6= SE(P \u22c6\u25e62,f2 Q). Therefore, \u22c6\u25e61,f1 6= \u22c6\u25e62,f2 . Now, assume that f1 6= f2. So there exists an interpretation Y such that f1(Y ) 6= f2(Y ). We fall into at least one of the two following cases: (i) there exists X \u2208 f1(Y ) such that X /\u2208 f2(Y ), or (ii) there exists X \u2208 f2(Y ) such that X /\u2208 f1(Y ). Assume that we fall into the first case (i) (the second case (ii) leads to the same result by symmetry). Now, let P ,Q be two GLPs defined such that Y 6|= P and SE(Q) = {(X ,Y ), (Y ,Y )}. P + Q is inconsistent. Then by Definition 15 we get that SE(P \u22c6\u25e61,f1 Q) = {(X ,Y ), (Y ,Y )} and SE(P \u22c6\u25e62,f2 Q) = {(Y ,Y )}, thus SE(P \u22c6\u25e61,f1 Q) 6= SE(P \u22c6\u25e62,f2 Q). Therefore, \u22c6\u25e61,f1 6= \u22c6\u25e62,f2 .\nProposition 6 For every (\u03a6,\u03a8) \u2208 GLPpart and every \u0393 \u2208 GLPfaith , ((\u03a6,\u03a8),\u0393) \u2208 \u03c3part\u2192faith if and only if for all GLPs P ,Q, min(SE(Q),\u2264\u2217P) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q), \u2264P),X \u2208 P(Y )}."}, {"heading": "Proof", "text": "In this proof, for every well-defined set of SE interpretations S , lp(S ) denotes any GLP P such that SE(P) = S . Let (\u03a6,\u03a8) \u2208 GLPpart and \u0393 \u2208 GLPfaith . We have to show that ((\u03a6,\u03a8),\u0393) \u2208 \u03c3, i.e., conditions (i) and (ii) involved in the definition of \u03c3part\u2192faith are satisfied, if and only if for all GLP P ,Q, we have min(SE(Q),\u2264\u2217P) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P(Y )}. For simplicity reasons we abuse notations and respectively denote Sfaith = min(SE(Q),\u2264\u2217P) and Spart = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P ),X \u2208 P(Y )}.\n(If part) Assume that for all GLP P ,Q, Sfaith = Spart . We have to show that conditions (i) and (ii) involved in the definition of \u03c3part\u2192faith are satisfied.\nWe first prove that (i) for every GLP P and all interpretations Y ,Y \u2032 \u2208 \u2126, (Y ,Y ) \u2264\u2217P (Y \u2032,Y \u2032) if and only if Y \u2264P Y \u2032. Let Y ,Y \u2032 \u2208 \u2126, assume that (Y ,Y ) \u2264\u2217P (Y \u2032,Y \u2032) and assume toward a contradiction that Y \u2032 <P Y . Let Q be the GLP Q = lp({Y ,Y \u2032}). Then Y /\u2208 min(mod(Q),\u2264P), thus (Y ,Y ) /\u2208 Spart . Hence, (Y ,Y ) /\u2208 Sfaith , which contradicts (Y ,Y ) \u2264\u2217P (Y \u2032,Y \u2032). The other way around, assume that Y \u2264P Y \u2032 and assume toward a contradiction that (Y \u2032,Y \u2032) <\u2217P (Y ,Y ). Let Q be the GLP Q = lp({Y ,Y \u2032}). Then Y /\u2208 Sfaith , thus Y /\u2208 Spart , which means that Y /\u2208 min(mod(Q),\u2264P ) or Y /\u2208 P(Y ). Yet the fact that Y /\u2208 min(mod(Q),\u2264P) contradicts Y \u2264P Y \u2032 and Y /\u2208 P(Y ) contradicts condition (a) required by the well-defined assignment \u03a8. This proves (i).\nWe now prove that (ii) for every GLP P , (X ,Y ) \u2264\u2217P (Y ,Y ) and all interpretations X ,Y \u2208 \u2126 s.t. X \u2286 Y , (X ,Y ) \u2264\u2217P (Y ,Y ) if and only if X \u2208 P(Y ). Let X ,Y \u2208 \u2126, X \u2286 Y , assume that (X ,Y ) \u2264\u2217P (Y ,Y ) and assume toward a contradiction that X /\u2208 P(Y ). Then for the GLP Q defined as Q = lp({(X ,Y ), (Y ,Y )}), we have (X ,Y ) /\u2208 Sfaith , so (X ,Y ) /\u2208 Spart , which contradicts (X ,Y ) \u2264\u2217P (Y ,Y ). The other way around, assume that X \u2208 P(Y ) and assume toward a contradiction that (Y ,Y ) <\u2217P (X ,Y ). Let Q be the GLP defined as Q = lp({(X ,Y ), (Y ,Y )}). On the one hand Q has the only model Y , so min(mod(Q),\u2264P) = {Y }. On the other hand, we have (X ,Y ) /\u2208 Sfaith , so (X ,Y ) /\u2208 Spart , which means that we should have Y /\u2208 min(mod(Q),\u2264P) since we assumed that X \u2208 P(Y ). This leads to a contradiction. This proves (ii).\n(Only If part) Assume that conditions (i) and (ii) involved in the definition of \u03c3part\u2192faith are satisfied. We have to show that for all GLP P ,Q, we have Sfaith = Spart . Let P ,Q be two GLPs.\nWe first prove that Sfaith \u2286 Spart . Let (X ,Y ) \u2208 Sfaith . This means that for\nevery (X \u2032,Y \u2032) \u2208 SE(Q), (X ,Y ) \u2264\u2217P (X \u2032,Y \u2032). In particular, (X ,Y ) \u2264\u2217P (Y \u2032,Y \u2032). And condition (4) required by the GLP compliant faithful assignment \u0393 states that (Y ,Y ) \u2264\u2217P (X ,Y ). Hence, (Y ,Y ) \u2264 \u2217 P (Y \u2032,Y \u2032). So by condition (i) involved in the\ndefinition of \u03c3part\u2192faith , we get that Y \u2264P Y \u2032 for every Y \u2032 \u2208 \u2126. So we showed that Y \u2208 min(mod(Q),\u2264P). Furthermore, since for all (X \u2032,Y \u2032) \u2208 SE(Q), (X ,Y ) \u2264\u2217P (X \u2032,Y \u2032), we also have that (X ,Y ) \u2264\u2217P (Y ,Y ), and condition (ii) involved in the definition of \u03c3part\u2192faith implies that X \u2208 P(Y ). Since Y \u2208 min(mod(Q),\u2264P) and X \u2208 P(Y ), we get that (X ,Y ) \u2208 Spart .\nWe prove now that Spart \u2286 Sfaith . Let (X ,Y ) \u2208 Spart . Since Y \u2208 min(mod(Q), \u2264P), condition (i) involved in the definition of \u03c3part\u2192faith implies that (Y ,Y ) \u2264 \u2217 P (Y \u2032,Y \u2032) for every Y \u2032 \u2208 \u2126. Together with condition (4) required by the GLP compliant faithful assignment \u0393, we get for all X \u2032,Y \u2032 \u2208 \u2126 s.t. X \u2032 \u2286 Y \u2032 that (Y ,Y ) \u2264\u2217P (X \u2032,Y \u2032). And since X \u2208 P(Y ), condition (ii) involved in the definition of \u03c3part\u2192faith implies that (X ,Y ) \u2264\u2217P (Y ,Y ). Therefore, for all X \u2032,Y \u2032 \u2208 \u2126 s.t. X \u2032 \u2286 Y \u2032, (X ,Y ) \u2264\u2217P (X \u2032,Y \u2032). This is true in particular for every (X \u2032,Y \u2032) \u2208 SE(Q). This means that (X ,Y ) \u2208 Sfaith , and this concludes the proof.\nProposition 7 Let \u25e6 be a KM revision operator. Then for all GLP revision operators \u22c61, \u22c62 \u2208 GLP(\u25e6), \u22c61 \u25e6 \u22c62 if and only if for all GLPs P ,Q, we have AS (P \u22c61Q) \u2286 AS (P \u22c62 Q)."}, {"heading": "Proof", "text": "Let \u25e6 be a KM revision operator and \u22c61, \u22c62 \u2208 GLP(\u25e6). (Only if part) Assume that \u22c61 \u25e6 \u22c62. By Definition 18, for every interpretation Y we have f2(Y ) \u2286 f1(Y ). Let P ,Q be two GLPs such that P + Q is inconsistent (the case where P + Q is consistent is trivial since by Definition 15, we would have P \u22c61 Q = P \u22c62 Q = P + Q) and let Y \u2208 AS (P \u22c61 Q). We need to show that Y \u2208 AS (P \u22c62 Q). We have (Y ,Y ) \u2208 SE(P \u22c61 Q) and for every X ( Y , (X ,Y ) /\u2208 SE(P \u22c61Q). Since \u22c61 is a propositional-based revision operator (cf. Proposition 4), from Definition 15 we get that Y |= \u03b12P \u25e6 \u03b1 2 Q (i) and for every X ( Y , (X ,Y ) /\u2208 SE(Q) or X /\u2208 f1(Y ), thus (X ,Y ) /\u2208 SE(Q) or X /\u2208 f2(Y ), therefore (X ,Y ) /\u2208 SE(P \u22c62 Q) (ii). By (i) we get that (Y ,Y ) \u2208 SE(P \u22c62 Q) and by (ii) we have for every X ( Y , (X ,Y ) /\u2208 SE (P \u22c62 Q). Therefore, by Definition 15 we get that Y \u2208 AS (P \u22c62 Q). Hence, AS (P \u22c61 Q) \u2286 AS (P \u22c62 Q).\n(If part) Assume that for all GLPs P ,Q, AS (P \u22c61 Q) \u2286 AS (P \u22c62 Q). Toward a contradiction, assume that \u22c61 6 \u25e6 \u22c62. This means that there exists an interpretation Y such that f2(Y ) 6\u2286 f1(Y ), that is, there exists an interpretation X ( Y such that X \u2208 f2(Y ) and X /\u2208 f1(Y ). Then, consider a GLP Q such that SE(Q) = {(X ,Y ), (Y ,Y )} and any GLP P such that Y 6|= P . Since Y is the only interpretation satisfying Y |= Q, from postulates (R1) and (R3) of a KM revision operator we have Y |= \u03b12P \u25e6 \u03b1 2 Q. Moreover X /\u2208 f1(Y ). So we get from Definition 15 that SE(P \u22c61 Q) = {(Y ,Y )}. On the other hand, since X \u2208 f2(Y ) we get that SE(P \u22c62Q) = {(X ,Y ), (Y ,Y )}. Therefore, Y \u2208 AS (P \u22c61Q) and Y /\u2208 AS (P \u22c62Q). This contradicts AS (P \u22c61 Q) \u2286 AS (P \u22c62 Q).\nProposition 8 The skeptical GLP revision operators are the only GLP revision operators \u22c6 such that for all GLPs P ,Q, whenever P+Q is inconsistent, we haveAS (P\u22c6Q) \u2286 AS (Q)."}, {"heading": "Proof", "text": "Let \u25e6 be a KM revision operator and \u22c6\u25e6S be the corresponding skeptical GLP revision operator. We first show that for all GLPs P ,Q such that P + Q is inconsistent, we have AS (P \u22c6\u25e6S Q) \u2286 AS (Q). \u22c6 \u25e6 S corresponds to the propositional-based revision GLP operator \u22c6\u25e6,f such that for every interpretation Y , f (Y ) = 2Y . Let P ,Q be two GLPs such that P + Q is inconsistent. Let Y \u2208 AS (P \u22c6\u25e6S Q). We have (Y ,Y ) \u2208 SE(P\u22c6\u25e6SQ), so by Definition 15 we get that (Y ,Y ) \u2208 SE(Q). Now, assume toward a contradiction that Y /\u2208 AS (Q). This means that there exists X ( Y such that (X ,Y ) \u2208 SE(Q). Yet f (Y ) = 2Y , so X \u2208 f (Y ), thus by Definition 15 this implies that (X ,Y ) \u2208 SE(P \u22c6\u25e6S Q), this contradicts Y \u2208 AS (P \u22c6 \u25e6 S Q). Therefore, Y \u2208 AS (Q). Hence, AS (P \u22c6\u25e6S Q) \u2286 AS (Q). We now show that for some any revision operator \u22c6\u25e6,f , if we have AS (P \u22c6 Q) \u2286 AS (Q) for all GLPs P ,Q such that P + Q is inconsistent, then \u22c6\u25e6,f corresponds to the skeptical GLP revision operator \u22c6\u25e6S . Let us show the contraposite, that is, assume that \u22c6\u25e6,f is not a skeptical GLP revision operator. This means that there exists an interpretation Y such that f (Y ) 6= 2Y , i.e., there exists X ( Y such that X /\u2208 f (Y ). Then, consider a GLP Q such that SE(Q) = {(X ,Y ), (Y ,Y )} and any GLP P such that Y 6|= P . Since Y is the only interpretation satisfying Y |= Q, from postulates (R1) and (R3) of a KM revision operator we have Y |= \u03b12P \u25e6\u03b1 2 Q. On the one hand, since SE(Q) = {(X ,Y ), (Y ,Y )} we have Y /\u2208 AS (Q). On the other hand, since X /\u2208 f (Y ) we get from Definition 15 that SE(P \u22c6\u25e6,f Q) = {(Y ,Y )}, that is, Y \u2208 AS (P \u22c6\u25e6,f Q). Therefore, AS (P \u22c6\u25e6,f Q) 6\u2286 AS (Q).\nProposition 9 The brave GLP revision operators are the only GLP revision operators \u22c6\u25e6,f such that for all GLPs P ,Q, whenever P + Q is inconsistent, we have AS (P \u22c6\u25e6,f Q) = mod(\u03b12P \u25e6 \u03b1 2 Q)."}, {"heading": "Proof", "text": "Let \u25e6 be a KM revision operator and \u22c6\u25e6B be the corresponding brave GLP revision operator. We first show that for all GLPs P ,Q such that P + Q is inconsistent, we have AS (P \u22c6\u25e6B Q) = mod(\u03b1 2 P \u25e6 \u03b1 2 Q). \u22c6 \u25e6 B corresponds to the propositional-based revision GLP operator \u22c6\u25e6,f such that for every interpretation Y , f (Y ) = {Y }. Let P ,Q be two GLPs such that P + Q is inconsistent. For every interpretation Y and every X ( Y , X /\u2208 f (Y ), thus from Definition 15 for every interpretation Y , we have Y \u2208 AS (P \u22c6\u25e6B Q) if and only if (Y ,Y ) \u2208 SE(P \u22c6 \u25e6 B Q) if and only if Y |= \u03b12P \u25e6 \u03b1 2 Q. Therefore, AS (P \u22c6 \u25e6 B Q) = mod(\u03b1 2 P \u25e6 \u03b1 2 Q). We now show that for some any revision operator \u22c6\u25e6,f , if we have AS (P \u22c6\u25e6B Q) = mod(\u03b12P \u25e6 \u03b1 2 Q) for all GLPs P ,Q such that P +Q is inconsistent, then \u22c6 \u25e6,f corresponds to the brave GLP revision operator \u22c6\u25e6B . Let us show the contraposite, that is, assume that \u22c6\u25e6,f is not a brave GLP revision operator. This means that there exists an interpretation Y such that f (Y ) 6= {Y }, i.e., there exists X ( Y such\nthat X \u2208 f (Y ). Then, consider a GLP Q such that SE(Q) = {(X ,Y ), (Y ,Y )} and any GLP P such that Y 6|= P . On the one hand, since Y is the only interpretation satisfying Y |= Q, from postulates (R1) and (R3) of a KM revision operator we have Y |= \u03b12P \u25e6 \u03b1 2 Q. On the other hand, since SE(Q) = {(X ,Y ), (Y ,Y )} and X \u2208 f (Y ), we get from Definition 15 that SE(P \u22c6\u25e6,f Q) = {(X ,Y ), (Y ,Y )}, that is, Y /\u2208 AS (P \u22c6\u25e6,f Q). Therefore, AS (P \u22c6\u25e6B Q) = mod(\u03b1 2 P \u25e6 \u03b1 2 Q).\nProposition 10 MC(\u25e6D ) is coNP-complete."}, {"heading": "Proof", "text": "Let \u03c6, \u03c8 be two formulae and I be an interpretation. In the case where I |= \u03c6 \u2227 \u03c8 or I 6|= \u03c8, to determine whether I |= \u03c6 \u25e6D \u03c8 can be checked in polynomial time (the answer is \u201cyes\u201d in the former case, \u201cno\u201d in the latter one). So let us assume that I |= \u00ac\u03c6\u2227\u03c8. Then to determine whether I |= \u03c6 \u25e6D \u03c8 comes down to determine whether \u03c6 \u2227 \u03c8 is an inconsistent formula, that can be down using one call to a coNP oracle. Hence, MC(\u25e6D ) \u2208 coNP. We prove coNP-hardness by exhibiting a polynomial reduction from the unsatisfiability problem. Consider a propositional formula \u03b1 over a set of propositional variables A, and let us associate with it in polynomial time: \u2022 the formulae \u03c6, \u03c8 defined on A \u222a {new , new \u2032} (with A \u2229 {new , new \u2032} = \u2205) as \u03c6 = \u03b1 \u2227 new and \u03c8 = new \u2032; \u2022 the interpretation I overA\u222a{new , new \u2032} defined as I (p) = 0 if p = new , otherwise I (p) = 1. If \u03b1 is inconsistent then \u03c6 is inconsistent, so \u03c6\u25e6D \u03c8 = \u03c8 = new \u2032; since I (new \u2032) = 1, we get that I |= \u03c8, so I |= \u03c6 \u25e6D \u03c8. Now, if \u03b1 is consistent then \u03c6 is consistent, so \u03c6 \u25e6D \u03c8 = \u03c6 \u2227 \u03c8 = \u03b1 \u2227 new \u2227 new \u2032; since I (new) = 0, we get that I 6|= \u03c6 \u25e6D \u03c8. We just showed that \u03b1 is inconsistent if and only if I |= \u03c6 \u25e6D \u03c8, thus MC(\u25e6D) is coNP-hard.\nProposition 11 The skeptical GLP revision operators are both DLP revision operators and NLP revision operators."}, {"heading": "Proof", "text": "We show that every skeptical GLP revision operator \u22c6\u25e6,f = \u22c6\u25e6S is a DLP revision operator. We have to prove that for all DLP P ,Q, P \u22c6\u25e6,f Q is a DLP, i.e., that SE(P \u22c6\u25e6S Q) is a complete set of SE interpretations. This is trivial when P +Q is consistent since in this case, P \u22c6\u25e6S Q = P + Q and expansion preserves completeness of SE models, so assume that P +Q is inconsistent. Let X ,Y ,Z s.t. Y \u2286 Z , (X ,Y ), (Z ,Z ) \u2208 SE(P \u22c6\u25e6,f Q), and let us show that (X ,Z ) \u2208 SE(P \u22c6\u25e6,f Q). By definition of a propositional-based LP revision operator, we know that (X ,Y ), (Z ,Z ) \u2208 SE(Q). Yet Q is a DLP, thus (X ,Z ) \u2208 SE(Q). Since (Z ,Z ) \u2208 SE(P \u22c6\u25e6,f Q), we get that Z |= \u03b12P \u25e6 \u03b1 2 Q. Moreover, X \u2208 f (Z ) since \u22c6 \u25e6 S is a skeptical GLP revision operator. Hence, by definition of a propositional-based LP revision operator we get that (X ,Z ) \u2208 SE(P \u22c6\u25e6,f Q).\nOne can prove that every skeptical GLP revision operator \u22c6\u25e6,f = \u22c6\u25e6S is a NLP revision operator is a similar way, by augmenting the above conditions of completeness on SE interpretations with the condition of closeness under hereintersection.\nProposition 12 An LP operator \u22c6 is a DLP (resp. NLP) revision operator if and only if there exists a DLP (resp. NLP) parted assignment (\u03a6,\u03a8\u03a6), where \u03a6 associates with every DLP (resp. NLP) P a total preorder \u2264P , \u03a8\u03a6 is a \u03a6-based complete (resp. normal) assignment which associates with every DLP (resp. NLP) P and every interpretation Y a set of interpretations P\u03a6(Y ), and such that for all DLPs (resp. NLPs) P ,Q,\nSE(P \u22c6Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P\u03a6(Y )}\u00b7"}, {"heading": "Proof", "text": "Let us first prove the representation of DLP revision operators. (Only if part) The proof is identical to the one of Proposition 3 (i.e., our representation theorem for GLP revision operators), except that we now consider that for every well-defined set of SE interpretations S , lp(S ) denotes any DLP R whose set of SE models is the smallest (w.r.t. the set inclusion) superset of S , i.e., S \u2286 SE(R) and there is no DLP R\u2032 such that S \u2286 SE(R\u2032) and SE(R\u2032) ( SE(R). Remark here that given some set S , the DLP lp(S ) is uniquely defined (modulo strong equivalence): to determine SE(lp(S )), it is enough to add to S all SE interpretations (X ,Z ) which are missing from S to ensure its completeness, i.e., those SE interpretations (X ,Z ) such that (X ,Y ), (Z ,Z ) \u2208 S for some interpretation Y \u2286 Z . Also when S is of the form {(Y ,Y ) | Y \u2208 E} for some set of interpretations E , we write lp(E ) instead of lp(S ).\nObviously enough, Remark 2 and 4 from the proof of Proposition 3 still hold. We show now that Remark 3 from the proof of Proposition 3 also holds, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) \u2261s lp(E \u2229 F ). First, let us show the following intermediate result, that is, for every set E of interpretations and every SE interpretation (X ,Z ),\n(X ,Z ) \u2208 SE(lp(E )) if and only if (X ,X ), (Z ,Z ) \u2208 SE(lp(E )) \u00b7 (1)\nEquation 1 trivially holds when X = Z , so assume X ( Z . The if part comes from the fact that SE(lp(E )) is complete. Let us prove the only if part. On the one hand, (Z ,Z ) \u2208 SE(lp(E )) since SE(lp(E )) is well-defined. On the other hand, SE(lp(E )) is complete and minimal w.r.t. the set inclusion, which means that there necessarily exists Y ( Z , X \u2286 Y such that (X ,Y ) \u2208 SE(lp(E )). If now X ( Y , then the reasoning can be repeated recursively (by setting Z = Y each time). Then after a finite number of steps we get that X = Y since we deal with a finite set of atoms, that is, (X ,X ) \u2208 SE(lp(E )) which proves that Equation 1 holds. Now, for every\nSE interpretation (X ,Z ), we have that\n(X ,Z ) \u2208 SE(lp(E ) + lp(F ))\nif and only if (X ,Z ) \u2208 SE(lp(E )) \u2229 SE(lp(F )) if and only if (X ,X ), (Z ,Z ) \u2208 SE(lp(E )) \u2229 SE(lp(F )) (by Equation 1) if and only if X ,Z \u2208 E \u2229 F if and only if (X ,X ), (Z ,Z ) \u2208 SE(lp(E \u2229 F )) if and only if (X ,Z ) \u2208 SE(lp(E \u2229 F )) (by Equation 1).\nThis shows that Remark 3 from the proof of Proposition 3 also holds here, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) \u2261s lp(E \u2229 F ).\nConsider now a DLP revision operator \u22c6. We associate with \u22c6 a DLP parted assignment (\u03a6,\u03a8\u03a6) which uses the same construction as for a GLP parted assignment in the proof of Proposition 3: define for every DLP P the relation \u2264P over interpretations such that \u2200Y ,Y \u2032 \u2208 \u2126, Y \u2264P Y \u2032 iff Y |= P \u22c6 lp({Y ,Y \u2032}), and by defining for every DLP P and every Y \u2208 \u2126 the set P\u03a6(Y ) as P\u03a6(Y ) = {X \u2286 Y | (X ,Y ) \u2208 SE(P \u22c6 lp({(X ,Y ), (Y ,Y )}))}. Then the same proof as for Proposition 3 can be used to show that:\n(i) for every DLP P , \u2264P is a total preorder;\n(ii) for all DLPs P ,Q, SE(P \u22c6 Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\n\u2264P),X \u2208 P\u03a6(Y )};\n(iii) conditions (1 - 3) of the faithful assignment \u03a6 and conditions (a - e) of the \u03a6-based\ncomplete assignment \u03a8\u03a6 are satisfied.\nIt remains to show that the condition (f) of \u03a8\u03a6 is satisfied. Let P be a DLP, X ,Y ,Z be interpretations such that Y \u2286 Z , Y \u2243P Z and X \u2208 P\u03a6(Y ). Assume toward a contradiction that X /\u2208 P\u03a6(Z ). By (ii) we get that SE(P \u22c6 lp({(X ,Y ), (Y ,Y ), (Z ,Z ), (X ,Z )})) = {(X ,Y ), (Y ,Y ), (Z ,Z )}, which is not a complete set of SE interpretations since (X ,Z ) does not belong to it. This contradicts the fact that P \u22c6 lp({(X ,Y ), (Y ,Y ), (Z ,Z ), (X ,Z )}) is a DLP, i.e., that \u22c6 is a DLP revision operator.\n(If part) We consider a faithful assignment \u03a6 that associates with every DLP P a total preorder \u2264P and a \u03a6-based complete assignment \u03a8\u03a6 that associates with every DLP P and every interpretation Y a set P\u03a6(Y ) \u2286 \u2126. For all DLPs P ,Q, let S(P ,Q) be the set of SE interpretations defined as S(P ,Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P ),X \u2208 P\u03a6(Y )}. Let P ,Q be two GLPs. The proof that S(P ,Q) is well-defined is given in the proof of Proposition 3, by using condition (a) of the \u03a6-based complete assignment \u03a8\u03a6. We show that S(P ,Q) is complete by using condition (f). Let (X ,Y ), (Z ,Z ) be two SE interpretations such that Y \u2286 Z and (X ,Y ), (Z ,Z ) \u2208 S(P ,Q). By definition of S(P ,Q) we get that Y ,Z \u2208 min(mod(Q),\u2264P ), which means that Y \u2243P Z , and we also get that X \u2208 P\u03a6(Y ). Thus condition (f) implies that also X \u2208 P\u03a6(Z ). Therefore, (X ,Z ) \u2208 S(P ,Q) which means that S(P ,Q) is complete. Then we define an operator \u22c6 associating two DLPs P ,Q with a new DLP P \u22c6Q such that for all DLPs P ,Q, SE(P \u22c6Q) = S(P ,Q). The proof that \u22c6 satisfies postulates (RA1 - RA6) is\nidentical to the one of Proposition 3.\nThe proof in the NLP case is very similar to the DLP one and uses the same construction, by adapting the structures accordingly and considering the additional condition (g) involved in a NLP parted assignment. (Only if part) For every well-defined set of SE interpretations S , lp(S ) denotes any NLP R (which is uniquely defined modulo equivalence) whose set of SE models is the smallest (w.r.t. the set inclusion) superset of S . And when S is of the form {(Y ,Y ) | Y \u2208 E} for some set of interpretations E , we write lp(E ) instead of lp(S ).\nRemark 2 and 4 from the proof of Proposition 3 still hold, but we need to show that Remark 3 from the proof of Proposition 3 also holds, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) \u2261s lp(E \u2229 F ). For this purpose, we prove an adaptation of Equation 1 previously given in this proof for DLPs, to the case of NLPs; that is, for every set E of interpretations and every SE interpretation (X ,Z ),\n(X ,Z ) \u2208 SE(lp(E )) if and only if one of the two following conditions holds:\n(i) (X ,X ), (Z ,Z ) \u2208 SE(lp(E )) (ii) there is a set of interpretations Y such that \u22c2\nY\u2208Y Y = X , |Y| \u2265 2,\nand \u2200Y \u2208 Y, (Y ,Y ) \u2208 SE(lp(E ))\u00b7\n(2)\nEquation 2 trivially holds when X = Z , so assume X ( Z . The if part comes from the fact that SE(lp(E )) is complete and closed under here-intersection. Let us prove the only if part. Assume that it does not hold that (X ,X ), (Z ,Z ) \u2208 SE(lp(E )). Then by Equation 1, (X ,Z ) belongs to SE(lp(E )) because its condition specific for closure under here-intersection, i.e., \u2203Y ,Y \u2032 \u2286 Z , Y \u2229Y \u2032 = X , Y 6= Y \u2032, (Y ,Z ), (Y \u2032,Z ) \u2208 SE(lp(E )). By applying this reasoning recursively, since we are dealing with a finite set of atoms there must exist a finite set Y of at least two interpretations such that \u22c2\nY\u2208Y Y = X , and such that all (Y ,Z ) such that Y \u2208 Y belong SE(lp(E )) because the condition of completeness, which means by Equation 1 that for every Y \u2208 Y, (Y ,Y ) \u2208 SE(lp(E )).\nNow, for every SE interpretation (X ,Z ), we have that\n(X ,Z ) \u2208 SE(lp(E ) + lp(F ))\nif and only if (X ,Z ) \u2208 SE(lp(E )) \u2229 SE(lp(F )) if and only either (i) or (ii) from Equation 2 holds for both E and F \u00b7\nYet on the one hand, condition (i) from Equation 2 holds for both E and F if and only if X ,Z \u2208 E \u2229 F if and only if (X ,X ), (Z ,Z ) \u2208 SE(lp(E \u2229 F )). On the other hand, condition (ii) from Equation 2 holds for both E and F if and only if there is a set of interpretations Y such that \u22c2\nY\u2208Y Y = X , |Y| \u2265 2 and\n\u2200Y \u2208 Y, (Y ,Y ) \u2208 SE(lp(E ))\u2229SE (lp(F )), if and only there is a set of interpretations Y such that \u22c2\nY\u2208Y Y = X , |Y| \u2265 2 and \u2200Y \u2208 Y, Y \u2208 E \u2229 F , if and only if there\nis a set of interpretations Y such that \u22c2\nY\u2208Y Y = X , |Y| \u2265 2 and \u2200Y \u2208 Y,\n(Y ,Y ) \u2208 SE(lp(E \u2229 F )). Therefore, by Equation 2 we get that either (i) or (ii) from Equation 2 holds for both E and F if and only if (X ,Z ) \u2208 SE(lp(E \u2229 F )).\nThis shows that Remark 3 from the proof of Proposition 3 also holds here, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) \u2261s lp(E \u2229 F ).\nConsider now a NLP revision operator \u22c6, and similarly to the case of DLPs, we associate with \u22c6 the following NLP parted assignment (\u03a6,\u03a8\u03a6): we define for every DLP P the relation \u2264P over interpretations such that \u2200Y ,Y \u2032 \u2208 \u2126, Y \u2264P Y \u2032 iff Y |= P \u22c6 lp({Y ,Y \u2032}), and for every GLP P and every Y \u2208 \u2126 the set P\u03a6(Y ) as P\u03a6(Y ) = {X \u2286 Y | (X ,Y ) \u2208 SE(P \u22c6 lp({(X ,Y ), (Y ,Y )}))}. Then the same proof as for Proposition 3 can be used to show that:\n(i) for every NLP P , \u2264P is a total preorder;\n(ii) for all NLPs P ,Q, SE(P \u22c6 Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\n\u2264P),X \u2208 P\u03a6(Y )};\n(iii) conditions (1 - 3) of the faithful assignment \u03a6 and conditions (a - e) of the \u03a6-based\ncomplete assignment \u03a8\u03a6 are satisfied.\nAdditionally, we can use the same proof as for DLPs to show that condition (f). It remains to show that the condition (g) of \u03a8\u03a6 is satisfied. Let P be a DLP,X ,Y ,Z be interpretations such that X ,Y \u2208 P\u03a6(Z ). Assume toward a contradiction that X \u2229 Y /\u2208 P\u03a6(Z ). By (ii) we get that SE(P \u22c6 lp({(X ,Z ), (Y ,Z ), (Z ,Z ), (X \u2229Y ,Z )})) = {(X ,Y ), (Y ,Y ), (Z ,Z )}, which is not closed under here-intersection since (X \u2229 Y ,Z ) does not belong to it. This contradicts the fact that P \u22c6 lp({(X ,Z ), (Y ,Z ), (Z ,Z ), (X \u2229Y ,Z )}) is a NLP, i.e., that \u22c6 is a NLP revision operator.\n(If part) We consider a NLP parted assignment (\u03a6,\u03a8\u03a6) defined as the DLP parted assignment in the if part of the proof for the DLP case. Then defined an operator \u22c6 associating two NLPs P ,Q with a new NLP P \u22c6Q such that for all NLPs P ,Q, SE(P \u22c6Q) = {(X ,Y ) | (X ,Y ) \u2208 SE(Q),Y \u2208 min(mod(Q),\u2264P),X \u2208 P\u03a6(Y )}. We already showed that SE(P \u22c6Q) is well-defined and complete, and condition (g) of the \u03a6-based normal assignment \u03a8\u03a6 directly implies that SE(P \u22c6Q) is closed under here-intersection. Therefore, P \u22c6 Q is a NLP. The proof that \u22c6 satisfies postulates (RA1 - RA6) is identical to the one of Proposition 3."}], "references": [{"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. Alchourr\u00f3n", "P. G\u00e4rdenfors", "D. Makinson"], "venue": "Journal of Symbolic Logic 50, 2, 510\u2013530.", "citeRegEx": "Alchourr\u00f3n et al\\.,? 1985", "shortCiteRegEx": "Alchourr\u00f3n et al\\.", "year": 1985}, {"title": "Dynamic updates of non-monotonic knowledge bases", "author": ["J.J. Alferes", "J.A. Leite", "L.M. Pereira", "H. Przymusinska", "T.C. Przymusinski"], "venue": "Journal of Logic Programming 45, 1-3, 43\u201370.", "citeRegEx": "Alferes et al\\.,? 2000", "shortCiteRegEx": "Alferes et al\\.", "year": 2000}, {"title": "Propositional theories are strongly equivalent to logic programs", "author": ["P. Cabalar", "P. Ferraris"], "venue": "Theory and Practice of Logic Programming 7, 6.", "citeRegEx": "Cabalar and Ferraris,? 2007", "shortCiteRegEx": "Cabalar and Ferraris", "year": 2007}, {"title": "Investigations into a theory of knowledge base revision: preliminary report", "author": ["M. Dalal"], "venue": "Proceedings of the 7th National Conference on Artificial Intelligence (AAAI\u201988). 475\u2013479.", "citeRegEx": "Dalal,? 1988", "shortCiteRegEx": "Dalal", "year": 1988}, {"title": "AGM-style belief revision of logic programs under answer set semantics", "author": ["J.P. Delgrande", "P. Peppas", "S. Woltran"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913). 264\u2013 276.", "citeRegEx": "Delgrande et al\\.,? 2013a", "shortCiteRegEx": "Delgrande et al\\.", "year": 2013}, {"title": "A preference-based framework for updating logic programs", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907). 71\u201383.", "citeRegEx": "Delgrande et al\\.,? 2007", "shortCiteRegEx": "Delgrande et al\\.", "year": 2007}, {"title": "Belief revision of logic programs under answer set semantics", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201908). 411\u2013 421.", "citeRegEx": "Delgrande et al\\.,? 2008", "shortCiteRegEx": "Delgrande et al\\.", "year": 2008}, {"title": "Merging logic programs under answer set semantics", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 25th International Conference on Logic Programming (ICLP\u201909). 160\u2013174.", "citeRegEx": "Delgrande et al\\.,? 2009", "shortCiteRegEx": "Delgrande et al\\.", "year": 2009}, {"title": "A modeltheoretic approach to belief change in answer set programming", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "ACM Transactions on Computational Logic 14, 2, 1\u201346.", "citeRegEx": "Delgrande et al\\.,? 2013b", "shortCiteRegEx": "Delgrande et al\\.", "year": 2013}, {"title": "On properties of update sequences based on causal rejection", "author": ["T. Eiter", "M. Fink", "G. Sabbatini", "H. Tompits"], "venue": "Theory and Practice of Logic Programming 2, 6, 711\u2013767.", "citeRegEx": "Eiter et al\\.,? 2002", "shortCiteRegEx": "Eiter et al\\.", "year": 2002}, {"title": "On solution correspondences in answer set programming", "author": ["T. Eiter", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI\u201905). 97\u2013102.", "citeRegEx": "Eiter et al\\.,? 2005", "shortCiteRegEx": "Eiter et al\\.", "year": 2005}, {"title": "Negation as failure in the head", "author": ["K. Inoue", "C. Sakama"], "venue": "Journal of Logic Programming 35, 1, 39\u201378.", "citeRegEx": "Inoue and Sakama,? 1998", "shortCiteRegEx": "Inoue and Sakama", "year": 1998}, {"title": "A unified view of propositional knowledge base updates", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Proceedings of the 11th International Joint Conference on Artificial Intelligence (IJCAI\u201989). 1413\u20131419.", "citeRegEx": "Katsuno and Mendelzon,? 1989", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1989}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR\u201991). 387\u2013394.", "citeRegEx": "Katsuno and Mendelzon,? 1991", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1991}, {"title": "Propositional knowledge base revision and minimal change", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Artificial Intelligence 52, 3, 263\u2013294.", "citeRegEx": "Katsuno and Mendelzon,? 1992", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1992}, {"title": "Merging information under constraints: a logical framework", "author": ["S. Konieczny", "R. Pino P\u00e9rez"], "venue": "Journal of Logic and Computation 12, 5, 773\u2013808.", "citeRegEx": "Konieczny and P\u00e9rez,? 2002", "shortCiteRegEx": "Konieczny and P\u00e9rez", "year": 2002}, {"title": "Belief revision and update: Complexity of model checking", "author": ["P. Liberatore", "M. Schaerf"], "venue": "Journal of Computer and System Sciences 62, 1, 43\u201372.", "citeRegEx": "Liberatore and Schaerf,? 2001", "shortCiteRegEx": "Liberatore and Schaerf", "year": 2001}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic 2, 4, 526\u2013541.", "citeRegEx": "Lifschitz et al\\.,? 2001", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "Computational complexity", "author": ["C.M. Papadimitriou"], "venue": "Addison-Wesley, Reading, Massachusetts.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "An abductive framework for computing knowledge base updates", "author": ["C. Sakama", "K. Inoue"], "venue": "Theory and Practice of Logic Programming 3, 6, 671\u2013713.", "citeRegEx": "Sakama and Inoue,? 2003", "shortCiteRegEx": "Sakama and Inoue", "year": 2003}, {"title": "Nonmonotonic reasoning by minimal belief revision", "author": ["K. Satoh"], "venue": "Proceedings of FGCS\u201988. 455\u2013462.", "citeRegEx": "Satoh,? 1988", "shortCiteRegEx": "Satoh", "year": 1988}, {"title": "Characterization theorems for revision of logic programs", "author": ["N. Schwind", "K. Inoue"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913). 485\u2013498.", "citeRegEx": "Schwind and Inoue,? 2013", "shortCiteRegEx": "Schwind and Inoue", "year": 2013}, {"title": "On semantic update operators for answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "Proceedings of the 19th European Conference on Artificial Intelligence (ECAI\u201910). 957\u2013962.", "citeRegEx": "Slota and Leite,? 2010", "shortCiteRegEx": "Slota and Leite", "year": 2010}, {"title": "Robust equivalence models for semantic updates of answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201912). 156\u2013168.", "citeRegEx": "Slota and Leite,? 2012", "shortCiteRegEx": "Slota and Leite", "year": 2012}, {"title": "The rise and fall of semantic rule updates based on SE-models", "author": ["M. Slota", "J. Leite"], "venue": "CoRR abs/1306.3884.", "citeRegEx": "Slota and Leite,? 2013", "shortCiteRegEx": "Slota and Leite", "year": 2013}, {"title": "Strong equivalence made easy: nested expressions and weight constraints", "author": ["H. Turner"], "venue": "Theory and Practice of Logic Programming 3, 4-5, 609\u2013622.", "citeRegEx": "Turner,? 2003", "shortCiteRegEx": "Turner", "year": 2003}, {"title": "Logic program-based updates", "author": ["Y. Zhang"], "venue": "ACM Transactions on Computational Logic 7, 3, 421\u2013472.", "citeRegEx": "Zhang,? 2006", "shortCiteRegEx": "Zhang", "year": 2006}, {"title": "Towards generalized rule-based updates", "author": ["Y. Zhang", "N.Y. Foo"], "venue": "Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI\u201997). 82\u201388.", "citeRegEx": "Zhang and Foo,? 1997", "shortCiteRegEx": "Zhang and Foo", "year": 1997}], "referenceMentions": [{"referenceID": 4, "context": "Based on the structure of SE interpretations, Delgrande et al. (2008; 2013b) adapted the well-known AGM framework (1985) to logic program (LP) revision.", "startOffset": 46, "endOffset": 121}, {"referenceID": 21, "context": "\u2217 This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013).", "startOffset": 75, "endOffset": 99}, {"referenceID": 13, "context": ", revision and update (Katsuno and Mendelzon 1991), and characterized axiomatically each one of these change operations by a set of socalled KM postulates.", "startOffset": 22, "endOffset": 50}, {"referenceID": 27, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 1, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 9, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 19, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 26, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 5, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 9, "context": "Indeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002).", "startOffset": 113, "endOffset": 132}, {"referenceID": 17, "context": "Initially, SE models were used to characterize the strong equivalence between logic programs (Lifschitz et al. 2001): precisely, two LPs have the same set of SE models if and only if they are strongly equivalent, that is to say, they admit the same answer sets, and will still do even after adding any arbitrary set of rules to them.", "startOffset": 93, "endOffset": 116}, {"referenceID": 4, "context": "Katsuno and Mendelzon (1992) adapted these principles to the case of propositional logic, distinguished two kind of change operations, i.", "startOffset": 0, "endOffset": 29}, {"referenceID": 1, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence. Indeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002). However, the notion of SE models introduced by Turner (2003) provided a monotonic semantical characterization of LPs, which is more expressive than the answer set semantics.", "startOffset": 119, "endOffset": 502}, {"referenceID": 11, "context": "In this paper, we give a particular consideration to the revision of generalized logic programs (GLPs) (Inoue and Sakama 1998) which are of very general form.", "startOffset": 103, "endOffset": 126}, {"referenceID": 14, "context": "Interestingly, the first one, called here LP faithful assignment, is similar to the structure of faithful assignment defined in (Katsuno and Mendelzon 1992) and used to characterize the (rational) KM revision operators in the propositional setting; the second one, called here well-defined assignment, can be defined independently from the first one.", "startOffset": 128, "endOffset": 156}, {"referenceID": 4, "context": "We formally compare our characterization result with another recent one proposed in (Delgrande et al. 2013a); the benefit of our approach is that our construction is one-to-one, as opposite to Delgrande et al.", "startOffset": 84, "endOffset": 108}, {"referenceID": 21, "context": "This version of the paper is a revised and extended version of a published LPNMR\u201913 paper (Schwind and Inoue 2013).", "startOffset": 90, "endOffset": 114}, {"referenceID": 4, "context": "The main extensions include a comparison of our main characterization result with the one proposed in (Delgrande et al. 2013a), some complexity results, characterization results for DLP and NLP revision operators and the proofs of propositions.", "startOffset": 102, "endOffset": 126}, {"referenceID": 0, "context": "The AGM framework (Alchourr\u00f3n et al. 1985) describes the standard principles for belief revision (e.", "startOffset": 18, "endOffset": 42}, {"referenceID": 0, "context": "The AGM framework (Alchourr\u00f3n et al. 1985) describes the standard principles for belief revision (e.g., consistency preservation and minimality of change), which capture changes occuring in a static domain. Katsuno and Mendelzon (1991) equivalently rephrased the AGM postulates as follows:", "startOffset": 19, "endOffset": 236}, {"referenceID": 13, "context": "Indeed, each KM revision operator is associated with some faithful assignment (Katsuno and Mendelzon 1991).", "startOffset": 78, "endOffset": 106}, {"referenceID": 3, "context": "KM revision operators include the class of distance-based revision operators (see, for instance, (Dalal 1988)), i.", "startOffset": 97, "endOffset": 109}, {"referenceID": 0, "context": "This operator was first introduced in (Alchourr\u00f3n et al. 1985) under the name of full meet revision function.", "startOffset": 38, "endOffset": 62}, {"referenceID": 0, "context": ", all AGM postulates in (Alchourr\u00f3n et al. 1985)), it is often considered as unreasonable because it throws away all the old beliefs if the new formula is inconsistent with them.", "startOffset": 24, "endOffset": 48}, {"referenceID": 3, "context": "Likewise, the revision operator based on Hamming distance dH is equivalent to the well-known Dalal revision operator (Dalal 1988).", "startOffset": 117, "endOffset": 129}, {"referenceID": 3, "context": "In fact, in (Dalal 1988) the Dalal revision is also defined in a modelwise fashion, i.", "startOffset": 12, "endOffset": 24}, {"referenceID": 6, "context": "We use the same notations as in (Delgrande et al. 2008).", "startOffset": 32, "endOffset": 55}, {"referenceID": 25, "context": "SE interpretations are semantic structures characterizing strong equivalence between logic programs (Turner 2003), they provide a monotonic semantic foundation of logic programs under answer set semantics.", "startOffset": 100, "endOffset": 113}, {"referenceID": 10, "context": "Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 96, "endOffset": 142}, {"referenceID": 2, "context": "Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 96, "endOffset": 142}, {"referenceID": 6, "context": "Definition 7 (Expansion operator (Delgrande et al. 2008)) Given two programs P ,Q, the expansion of P by Q, denoted P+Q is any program R such that SE(R) = SE(P) \u2229 SE(Q).", "startOffset": 33, "endOffset": 56}, {"referenceID": 8, "context": "We refer the reader to (Delgrande et al. 2013b), Section 3.", "startOffset": 23, "endOffset": 47}, {"referenceID": 6, "context": "Definition 9 (GLP revision operator (Delgrande et al. 2008)) A GLP revision operator \u22c6 is an LP revision operator that satisfies the following postulates, for all GLPs P ,P1,P2,Q,Q1,Q2,R:", "startOffset": 36, "endOffset": 59}, {"referenceID": 20, "context": "(2008) proposed a revision operator inspired from Satoh\u2019s propositional revision operator (Satoh 1988).", "startOffset": 90, "endOffset": 102}, {"referenceID": 12, "context": "Though it seems to have a good behavior on some instances, this operator does not satisfy (RA6), so that it does not fully respect the principle of minimality of change (see (Katsuno and Mendelzon 1989), Section 3.", "startOffset": 174, "endOffset": 202}, {"referenceID": 8, "context": "However, the whole set of postulates is consistent, as they later introduce the so-called cardinality-based revision operator (Delgrande et al. 2013b) that reduces to the Dalal revision scheme over propositional models and that satisfies all the postulates (RA1 - RA6).", "startOffset": 126, "endOffset": 150}, {"referenceID": 8, "context": "The following definition is a concise, equivalent reformulation of the original one introduced in (Delgrande et al. 2013b), Definition 3.", "startOffset": 98, "endOffset": 122}, {"referenceID": 3, "context": "Delgrande et al. (2008) proposed a revision operator inspired from Satoh\u2019s propositional revision operator (Satoh 1988).", "startOffset": 0, "endOffset": 24}, {"referenceID": 8, "context": "Theorem 2 (Delgrande et al. 2013b) \u22c6c is a GLP revision operator.", "startOffset": 10, "endOffset": 34}, {"referenceID": 4, "context": ", generalized, disjunctive, normal, positive, and Horn, so we shall now compare our characterization with the one given in (Delgrande et al. 2013a) for the case of GLPs:", "startOffset": 123, "endOffset": 147}, {"referenceID": 4, "context": "As we already briefly mentionned in the introduction, Delgrande et al. (2013a) also recently proposed a constructive characterization of belief revision operators for logic programs that satisfy the whole set of postulates (RA1 - RA6).", "startOffset": 54, "endOffset": 79}, {"referenceID": 4, "context": "Definition 16 (GLP compliant faithful assignment (Delgrande et al. 2013a)) A GLP compliant faithful assignment is a mapping which associates every GLP P with a total preorder \u2264P over SE interpretations such that for all GLPs P ,Q and all SE interpretations (X ,Y ), (X ,Y ), the following conditions hold:", "startOffset": 49, "endOffset": 73}, {"referenceID": 4, "context": "The following theorem is expressed as a combination of Theorems 4 and 5 from (Delgrande et al. 2013a) applied to GLPs:", "startOffset": 77, "endOffset": 101}, {"referenceID": 4, "context": "Theorem 3 (Delgrande et al. 2013a) An LP revision operator \u22c6 is a GLP revision operator (i.", "startOffset": 10, "endOffset": 34}, {"referenceID": 4, "context": "2 In (Delgrande et al. 2013a), an additional postulate is considered in the characterization theorems, namely (Acyc).", "startOffset": 5, "endOffset": 29}, {"referenceID": 4, "context": "(Delgrande et al. 2013a), Theorem 2).", "startOffset": 0, "endOffset": 24}, {"referenceID": 18, "context": "We assume that the reader is familiar with the basic concepts of computational complexity, in particular with the classes P, NP and coNP (see (Papadimitriou 1994) for more details).", "startOffset": 142, "endOffset": 162}, {"referenceID": 16, "context": "We focus here on the the model-checking problem (Liberatore and Schaerf 2001) for LP revision operators.", "startOffset": 48, "endOffset": 77}, {"referenceID": 10, "context": "Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 171, "endOffset": 217}, {"referenceID": 2, "context": "Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 171, "endOffset": 217}, {"referenceID": 24, "context": ", dynamic support and fact update (see (Slota and Leite 2013) for more details).", "startOffset": 39, "endOffset": 61}, {"referenceID": 22, "context": "As to the case of update of logic programs Slota and Leite (2013) argued that semantic rule updates based on SE models seem to be inappropriate.", "startOffset": 43, "endOffset": 66}, {"referenceID": 23, "context": "In (Slota and Leite 2012) the same authors successfully reconciliate semantic-based and syntax-based approaches to updating logic programs: they considered different characterizations of logic programs in terms of RE models (standing for robust equivalence models) that proved to be a more suitable semantic fundation for rule updates than SE models.", "startOffset": 3, "endOffset": 25}], "year": 2015, "abstractText": "We address the problem of belief revision of logic programs, i.e., how to incorporate to a logic program P a new logic program Q. Based on the structure of SE interpretations, Delgrande et al. (2008; 2013b) adapted the well-known AGM framework (1985) to logic program (LP) revision. They identified the rational behavior of LP revision and introduced some specific operators. In this paper, a constructive characterization of all rational LP revision operators is given in terms of orderings over propositional interpretations with some further conditions specific to SE interpretations. It provides an intuitive, complete procedure for the construction of all rational LP revision operators and makes easier the comprehension of their semantic and computational properties. We give a particular consideration to logic programs of very general form, i.e., the generalized logic programs (GLPs). We show that every rational GLP revision operator is derived from a propositional revision operator satisfying the original AGM postulates. Interestingly, the further conditions specific to GLP revision are independent from the propositional revision operator on which a GLP revision operator is based. Taking advantage of our characterization result, we embed the GLP revision operators into structures of Boolean lattices, that allow us to bring to light some potential weaknesses in the adapted AGM postulates. To illustrate our claim, we introduce and characterize axiomatically two specific classes of (rational) GLP revision operators which arguably have a drastic behavior. We additionally consider two more restricted forms of logic programs, i.e., the disjunctive logic programs (DLPs) \u2217 This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013). 2 N. Schwind and K. Inoue and the normal logic programs (NLPs) and adapt our characterization result to DLP and NLP revision operators.", "creator": "LaTeX with hyperref package"}}}