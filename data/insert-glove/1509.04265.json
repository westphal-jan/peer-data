{"id": "1509.04265", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Sep-2015", "title": "Double Relief with progressive weighting function", "abstract": "joyeux Feature weighting algorithms 2:18 try foxp2 to 65-mile solve a euro68 problem of korver great 4,440 importance nowadays in inked machine learning: professionalize The 11-horse search of baston a jingdezhen relevance lleida measure ellenberger for loschwitz the features of a given niarchos domain. kaiyuan This arrowood relevance jonatan is 1969-72 primarily used for boned feature 2400 selection as manhart feature weighting can briski be honke seen as sulabh a generalization lift of it, but it is two-foot also useful to pasteleria better understand a formula problem ' s domain or to guide an tarango inductor costazza in its desensitizing learning percolators process. theertham Relief goaltending family mor\u00e1n of pushtu algorithms 2:24 are disempowered proven to norrback be very 56-mile effective in this cellcom task.", "histories": [["v1", "Sat, 12 Sep 2015 15:28:08 GMT  (38kb)", "https://arxiv.org/abs/1509.04265v1", "arXiv admin note: substantial text overlap witharXiv:1509.03755"], ["v2", "Wed, 16 Sep 2015 12:09:28 GMT  (38kb)", "http://arxiv.org/abs/1509.04265v2", "arXiv admin note: substantial text overlap witharXiv:1509.03755"]], "COMMENTS": "arXiv admin note: substantial text overlap witharXiv:1509.03755", "reviews": [], "SUBJECTS": "cs.LG cs.AI", "authors": ["gabriel prat masramon", "llu\\'is a belanche mu\\~noz"], "accepted": false, "id": "1509.04265"}, "pdf": {"name": "1509.04265.pdf", "metadata": {"source": "CRF", "title": "Double Relief with progressive weighting function", "authors": ["Gabriel Prat"], "emails": ["gprat@lsi.upc.edu", "belanche@lsi.upc.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 9.\n04 26\n5v 2\n[ cs\nFeature weighting algorithms try to solve a problem of great impor-\ntance nowadays in machine learning: The search of a relevance measure\nfor the features of a given domain. This relevance is primarily used for\nfeature selection as feature weighting can be seen as a generalization of it,\nbut it is also useful to better understand a problem\u2019s domain or to guide\nan inductor in its learning process. Relief family of algorithms are proven\nto be very effective in this task.\nOn previous work, a new extension was proposed that aimed for im-\nproving the algorithm\u2019s performance and it was shown that in certain cases\nit improved the weights\u2019 estimation accuracy. However, it also seemed to\nbe sensible to some characteristics of the data. An improvement of that\npreviously presented extension is presented in this work that aims to make\nit more robust to problem specific characteristics. An experimental de-\nsign is proposed to test its performance. Results of the tests prove that it\nindeed increase the robustness of the previously proposed extension."}, {"heading": "1 Overview", "text": "Feature selection is undoubtedly one of the most important problems in machine learning, pattern recognition and information retrieval, among others. A feature selection algorithm is a computational solution that is motivated by a certain definition of relevance. However, the relevance of a feature may have several definitions depending on the objective that is looked after.\nOn the other hand, feature weighting algorithms try to estimate relevance (in the form of weights to the features) rather than binarily deciding whether a feature is either relevant or not. This is a much harder problem, but also a more flexible framework from an inductive learning perspective. This kind of\nalgorithms are confronted with the down-weighting of irrelevant features, the up-weighting of relevant ones and the problem of relevance assignment when redundancy is an issue.\nIn this work we review Relief, one of the most popular feature weighting algorithms. Original Relief and some of its variants are presented on section 2 drawing heavily on own earlier material. Next, we revisit a \"double\" or feedback extension of the algorithm, that was firstly introduced in an own previous work, that takes its own estimations into account in order to improve general performance. Finally a new version of the algorithm is presented on section 3 that uses its own estimations in a progressive manner, it initially behaves like the traditional algorithm and gradually increases the importance of its estimates to behave at the end as the \"double\" version. An experimental design is presenten in secion 4 to test the performance of the original algorithm versus the two proposed ones. Finally some results and conclusions are presented."}, {"heading": "2 Relief", "text": "Relief is a feature weighting algorithm that doesn\u2019t share one common characteristic of the feature selection and weighting methods. Most of them treat features individually assuming conditional independence of features upon the class. In the other hand, Relief takes all other features in care when evaluating a specific feature. Another interesting characteristic of Relief is that it is aware of contextual information being able to detect local correlations of feature values and their ability to discriminate from an instance of a different class.\nThe main idea behind Relief is to assign large weights to features that contribute in separating near instances of different class and joining near instances belonging to the same class. The word \"near\" in the previous sentence is of crucial importance since we mentioned that one of the main differences between Relief and the other cited methods is the ability to take local context into account. Relief does not reward features that separate (join) instances of different (same) classes in general but features that do so for near instances.\nIn Fig. 1 we can see the original algorithm presented by Kira and Rendell in [Kira and Rendell, 1992]. We maintained the original notation that slightly differs from the used above as now features (attributes) are labeled A. There we can see that in the aim of detecting whether the feature is useful to discriminate near instances it selects two nearest neighbors of the current instance Ri. One from the same class H called the nearest hit and one from the different class M (the original Relief algorithm only dealt with two class problems) called the nearest miss. With these two nearest neighbors it increases the weight ofthe feature if it has the same value for both Ri and H and decreases it otherwise. The opposite occurs with the nearest miss, Relief increases the weight of a feature if it has opposite values for Ri and M and decreases it otherwise.\nOne of the central parts of Relief is the difference function diff which is also\nInput: for each training instance a vector of feature values and the class value Output: the vector W of estimations of the qualities of features\nused to compute the distance between instances as shown in Eq. 2.1.\n\u03b4(I1, I2) = \u2211\ni\ndiff(Ai, I1, I2) (2.1)\nThe original definition of diff was an heterogeneous distance metric composed of the overlap metric in Eq. 2.2 for nominal features and the normalized Euclidean distance in Eq. 2.3 for linear features, which [Wilson and Martinez, 1997] called HEOM.\ndiff(A, I1, I2) = { 0 if value(A, I1) = value(A, I2)\n1 otherwise (2.2)\ndiff(A, I1, I2) = |value(A, I1)\u2212 value(A, I2)|\nmax(A)\u2212min(A) (2.3)\nThe difference normalization with m guarantees that the weight range is [-1,1]. In fact the algorithm tries to approximate a probability difference in Eq. 2.5.\nW [A] \u2248P (different value of A|nearest instance from different class)\u2212 (2.4) P (different value of A|nearest instance from same class) (2.5)\nWe can see that for a set of instances I having a set of features F this algorithm has cost O(m\u00d7|I|\u00d7|F|) as it has to loop over m instances. For each instance in the main loop it has to compute its distance from all other instances so we have O(m \u00d7 |I|) times the complexity of calculating DRelief and we can easily see from Eq. 2.1 that its complexity is O(|F|), so we have our complexity: O(m\u00d7 |I| \u00d7 |F|). As m is a user defined parameter we can in some measure control the cost of Relief algorithm having a tradeoff between accuracy of estimation (for large m) and low complexity of the algorithm (for small m). However m can never be greater than |I|."}, {"heading": "2.1 Extensions of Relief", "text": "The first modification proposed to the algorithm is to make it deterministic by changing the outer loop through m randomly chosen instances for a loop over all instances. This obviously increases the algorithms computation cost which becomes O(|I|2 \u00d7 |F|) but makes experiments with small datasets more reproducible. Kononenko uses this simplified version of the algorithm in its paper [Kononenko, 1994] to test his new extensions to the original Relief. This version is also used by other authors [Kohavi and John, 1997] and its given the name Relieved with the final d for \"deterministic\".\nWe can find some extensions to the original Relief algorithm proposed in [Kononenko, 1994] in order to overcome some of its limitations: It couldn\u2019t deal with incomplete datasets, it was very sensible to noisy data and it could only deal with multi-class problems by splitting the problem into series of 2-class problems.\nTo able Relief to deal with incomplete datasets, i.e. that contained missing values, a modification of the diff function is needed. The new function must be capable of calculating the difference between a value of a feature and a missing value and between two missing values in addition to the calculation of difference between two known values. Kononenko proposed various modifications of this function in its paper and found one that performed better than the others it was the one in a version of Relief he called RELIEF-D (not to be confused with Releaved mentioned above). The difference function used by RELIEF-D can be seen in Eq. 2.6.\ndiff(A, I1, I2) =\n\n\n\n1\u2212 P (value(A, I2)|class(I1)) if I1 is missing 1\u2212 \u2211\na\u2208A\n[P (a|class(I1))\u00d7 P (a|class(I2))] if both missing\n(2.6) Now we will focus on giving Relief greater robustness against noise. This robustness can be achieved by increasing the number of nearest hits and misses to look at. This mitigates the effect of choosing a neighbor that would not have been the nearest without the effect of noise. The new algorithm has a new user defined parameter k that controls the number of nearest neighbors to use. In choosing k there is a tradeoff between locality and noise robustness. [Kononenko, 1994] states that 10 is a good choice for most purposes.\nThe last limitation was that the algorithm was only designed for 2-class problems. The straightforward extension to multi-class problems would be to take as the near miss the nearest neighbor belonging to a different class. This variant of Relief is the so-called Relief-E by Kononenko. But later on he proposes another variant which gave better results: This was to take the nearest neighbor (or the k nearest) from each class and average their contribution so as to keep the contributions of hits and misses symmetric and between the interval [0,1]. That gives the Relief-F (ReliefF from now on) algorithm seen in Fig. 2.\nRelation to impurity functions, in specific with Gini-index gain can be seen in [Robnik-\u0160ikonja and Kononenko, 2003] when developing the probability difference in Eq. 2.5 in the case that the algorithm uses a large number of nearest\nInput: for each training instance a vector of feature values and the class value Output: the vector W of estimations of the qualities of features\nneighbors (i.e., when the selected instance could be anyone from the set of instances). This version of the algorithm is called myopic ReliefF as it loses its context of locality property. Rewriting Eq. 2.5 by removing the neighboring condition and by applying Bayes\u2019 rule, we obtain Eq. 2.7.\nW \u2032[A] = Psamecl|eqvalPeqval Psamecl \u2212 (1\u2212 Psamecl|eqval)Peqval 1\u2212 Psamecl (2.7)\nFor sampling with replacement we obtain we have:\nPeqval = \u2211\nc\u2208C\nP (c)2\nPsamecl|eqval = \u2211\nx\u2208X\n(\nP (x)2 \u2211\nx\u2208X P (x) 2 \u00d7\n\u2211\nc\u2208C\nP (c|x)2 )\nNow we can rewrite Eq. 2.7 to obtain the myopic Relief weight estimation:\nW \u2032[A] = Peqval \u00d7GG\u2032(X) Psamecl1\u2212 Psamecl\n(2.8)\nWhere GG\u2032(A) is a modified Gini-index gain of attribute A as seen in Eq. 2.9.\nGG\u2032(X) = \u2211\nx\u2208X\n(\nP (x)2 \u2211\nx\u2208X P (x) 2 \u00d7\n\u2211\nc\u2208C\nP (c|x)2 ) \u2212 \u2211\nc\u2208C\nP (c)2 (2.9)\nAs we can see the difference in this modified version from its original Gini-index gain is that Gini-index gain used a factor:\nP (x) \u2211\nx\u2208X P (x) = P (x)\nwhile myopic ReliefF uses: P (x)2\n\u2211\nx\u2208X P (x) 2\nSo we can see how this myopic ReliefF in Eq. 2.8 holds some kind of normalization for multi-valued attributes when using the factor Peqval. This solves the bias of impurity functions towards attributes with multiple values. Anther improvement compared with Gini-index is that Gini-index gain values decrease when the number of classes increase. The denominator of Eq. 2.8 avoids this strange behavior."}, {"heading": "3 Double Relief", "text": "When more and more irrelevant features are added to a dataset the distance calculation of Relief degrades its performance as instances may be considered neighbors when in fact they are far from each other if we compute its distance\nonly with the relevant features. In such cases the algorithm may lose its context of locality and in the end it may fail to recognize relevant features.\nThe diff(Ai, I1, I2) function calculates the difference between the values of the feature Ai for two instances I1 and I2. Sum of differences over all features is used to determine the distance between two instances in the nearest hit and miss calculation (see Eq. 2.1).\nAs seen in the k-nearest neighbors classification algorithm (kNN) many weighting schemes which assign different weights to the features in the calculation of the distance between instances (see Eq. 3.1).\n\u03b4\u2032(I1, I2) =\na \u2211\ni=1\nw(Ai) diff(Ai, I1, I2) (3.1)\nIn the same way that in [Wettschereck et al., 1997] Relief\u2019s estimates of features\u2019 quality have been used successfully as weights for the distance calculation of kNN we could use their estimation in the previous iteration to compute the distance between instances while searching the nearest hits and misses. We will refer to this version of ReliefF as double ReliefF or in short dReliefF."}, {"heading": "3.1 Progressively weighted double Relief", "text": "The problem using the weights estimates could be that in early iterations these estimations could be too biased to the first instances and could be far from the optimal weights. So, for small t, W [Ai] is very different from W [Ai]t.\nWhat we want is to begin the distance calculation without using the weight estimates and then, as Relief\u2019s weight estimates become more accurate (because more instances have been taken into account), increase the importance of these weights in the distance calculation. Lets have a distance calculation like the one in Eq. 3.2.\n\u03b4(I1, I2) =\na \u2211\ni=1\nf(W (Ai)t, t) diff(Ai, I1, I2) (3.2)\nWe would like a function f : R\u00d7 (0,\u221e) \u2192 R such that:\n\u2022 f(w, t) is increasing with respect to t\n\u2022 is continuous\n\u2022 f(w, 0) = 1\n\u2022 f(w,\u221e) = w\nOne such function could be the one in Eq. 3.3. And we will refer to the version of ReliefF using this distance equation as progressively weighted double relief or in short pdReliefF.\nf(w, t) = (w\u22121)c(t) c(t)+s + 1 (3.3)\nWhere s is a control parameter that determines the steepness and final value of the curve described by f (see Fig. 3) and c(t) is a function of the iteration number (e.g. c(t) = t). Another desirable property for our function would be that it always gives the same results regardless of the number of iterations. In other words, if m is the total number of iterations, we would like f(w,m) to be the same value whatever the value of m. To achieve that we must make c(t) depend also on the total number of iterations m so as to decrement the steepness of the function as the number of total iterations increases. A posible definition of c(t) is shown in Eq. 3.4.\nc (t) = (t/m) a (3.4)\nIn Fig. 4 we can see how f varies the influence of different weights (even a non realistic one that is greater than 1) as iterations go on. We can see that with high values of s the function converges in the first few iterations and then it stabilizes its value near w and for low values of s it\u2019s value remains near 1 till the end. To choose a value we can compute the area left over and below the function. We can see the normal ReliefF as a particular case where f(w, t) = 1 having maximum area and dReliefF as another particular case with f(w, t) = w having minimum area. We want to choose the parameters to be in between the two. Specifically we could choose the parameters so as to leave 1/3 of the area below the function. For doing this we have to solve Eq. 3.5\n\u222bm 1 f(w, t) dt\u2212 \u222bm\n1 w dt \u222bm\n1 1 dt\u2212 \u222bm 1 w dt =\n1 3 (3.5)\nA possible combination of parameters that solves the equation are: a = 2 and s = 0.0633657 \u2243 0.06. Graphicly it can be seen in Fig. 4 that those values make weights\u2019 ponderations stay near 1 for half of the iterations and then takes values near the weights\u2019 values. This value has been chosen in our experiments."}, {"heading": "4 Experimental design", "text": ""}, {"heading": "4.1 Objective", "text": "The above sections present three algorithms:\nReliefF The algorithm presented by Kononenko in [Kononenko, 1994]\ndReliefF The above algorithm using it\u2019s own partial weigts to ponderate attributes in distance calculation\npdReliefF The above using a function to progressively increment the weights ponderation effect in distance calculation\nThe objective of the experiments which will be presented is to compare performance of the three algorithms related to the factor of irrelevant attributes. The\nhypothesis is that the performance of the non-modified algorithm will be more affected by the number of irrelevant attributes increase due to their influence in distance calculation."}, {"heading": "4.2 Factors", "text": "As stated before the key factor of the experiments is the ratio of irrelevant attributes, but there are some nuisance factors which have effect on the experiments\u2019 results. The factors considered in the experiments are:\n\u2022 Problem to solve\n\u2022 Numeric vs. categoric attributes\n\u2022 Number of relevant attributes \u2022 Number of irrelevant attributes\n\u2022 Data randomization The main factor that will impact on performance results will be the problem we want to solve and in addition will be the most difficult to reduce. In order to eliminate it\u2019s influence, all the possible problems would have to be tried which is obviously impossible. Another factor that can clearly impact on performance is the type of the attributes as Relief has an heterogeneous function for distance calculation which depends on whether the attributes are numeric or categoric. So, to reduce the effect of these two factors the same experiments will be run on six different problems, three with numeric attributes and three with categoric ones. All the problems tested will be artificial to have sufficient knowledge about the data not to make performance of the weighting dependent on performance of a classifier.\nRanges for each factor have to be chosen. There has to be at least one relevant attribute and one irrelevant one in order to check whether the algorithm seems capable of distinguishing them, so both of them will start at 1 in our experiments. The number of irrelevant attributes will depend on the number of relevant ones in order to test with the same percentage of irrelevant attributes for each number of relevant attributes. A good choice could be to have at most twice the number of irrelevant attributes as the number relevant ones.\nThe upper bound for the number of relevant attributes will depend on the number of instances that are to be generated. It is interesting to test the algorithms with a wide range of attributes to instances ratios. We may arbitrarily set number of instances generated to 100. With that number of instances, it would be interesting to have at most 150 features for the ratio of attributes to instances not to get too low. If we want total features to keep below 150 with a number of irrelevant attributes of twice the number of relevant ones, we have to set upper bound to the number of relevant attributes to 50.\nFinally 10 different sets of data will be generated for each combination of other factors to reduce the possible effect of randomly generating a pathologic set of data."}, {"heading": "4.3 Design", "text": "Here we have to decide which of all the possible combinations of factors will be tried in the experiments. The better way to reduce or eliminate the contribution to experimental error of each of the factors would be to treat them as blocking factors. That is to create homogeneous blocks in which the factors are kept constant while the target factor takes all its possible values. When blocking is not possible because of limited resources a random subset of each block can be run.\nWith the ranges described above, there are a total of 3 \u00d7 I \u00d7N \u00d7 (N \u2212 1) different factor combinations for each problem as seen on Eq. 4.1, where N is the number of relevant attributes and I the number of iterations (i.e. random dataset generations) for each combination of relevant and irrelevant attribute numbers.\n\n\nN \u2211\nimp=1\n2imp\n\n\u00d7 Iiterations \u00d7 3algorithms = 3\u00d7 I \u00d7N \u00d7 (N \u2212 1) (4.1)\nThat gives a total number of 76,500 different combinations for each problem. With that number of combinations all combinations can be run. So the experimental design will be a full blocking design as shown on Fig. 5 in an algorithmic way."}, {"heading": "4.4 Problems", "text": ""}, {"heading": "4.4.1 RDG1NamedContinuous", "text": "A data generator that produces data randomly with numeric attributes by producing a decision list. The decision list consists of rules. The rules have the form cx := \u2227n\n1 t, where t is an inequality term (i.e. x < y or x \u2265 y) between some attribute and a random value. For each rule, the number n will be a random\nnumber in the range [1..10]. An example set of rules can be seen on Eq. 4.2.\nRULE 0: c0 := a1 < 0.986\u2227 a0 >= 0.65 RULE 1: c1 := a1 < 0.95 \u2227 a2 < 0.129 RULE 2: c2 := a1 >= 0.562\n(4.2)\nInstances are generated randomly one by one. The class will be determined by the first rule that is true for the current instance. If decision list fails to classify the current instance, a new rule according to this current instance is generated and added to the decision list. Irrelevant attributes are generated randomly in the range [0, 1]."}, {"heading": "4.4.2 RandomRBFRandRed1", "text": "Radial basis functions (RBF) are functions which characteristic feature is that their response decreases (or increases) monotonically with distance from a central point. There are different formulas to describe the specific shape of the function and they usually have parameters to control the center and the distance scale. In this particular case, the function f(x) used is the Gaussian which is described by Eq. 4.3 and can be seen on Fig. 6. Its parameters are its mean \u00b5 and its standard deviation \u03c3. A Gaussian RBF monotonically decreases with distance from the center.\nf(x) = 1\n\u03c3 \u221a 2\u03c0 exp\n(\n\u2212 (x\u2212 \u00b5) 2\n2\u03c32\n)\n(4.3)\nRandomRBF data is generated by first creating a random set of centers for each class. Each center is randomly assigned a weight, a central point per attribute, and a standard deviation. To generate new instances, a center is chosen at random taking the weights of each center into consideration. Attribute\nvalues are randomly generated and offset from the center, where the overall vector has been scaled so that its length equals a value sampled randomly from the Gaussian distribution of the center. The particular center chosen determines the class of the instance. RandomRBF data contains only numeric attributes as it is non-trivial to include nominal values. Irrelevant attributes are generated following the same Gaussian distribution for some random centers and standard deviation."}, {"heading": "4.4.3 NonMonotonic", "text": "Let ra be a random value in the range [0..1] to act as a ponderator for the attribute a. Now, for each instance i generate a random value ri in the rage [0..N ], where N is the number of important attributes. The value ai of the attribute a for instance i will be the one in Eq. 4.4.\nai = { ra \u00d7 ri if i mod 2 6= 0 ra \u00d7 \u221a ri if i mod 2 = 0\n(4.4)\nThe class for instance i will be the integer part of ri. Irrelevant attributes are created randomly following a uniform distribution in the range [0, 1]."}, {"heading": "4.4.4 MajorityN", "text": "Creates n binary attributes and i irrelevant attributes. The class attribute is 1 when the instance has a majority of 1s in the relevant attributes and 0 otherwise."}, {"heading": "4.4.5 ModuloP", "text": "Each Modulo-p problem is described by a set |R| = n of relevant attributes and i irrelevant attributes, both with integer values in the range [0, p). The class c can be defined as in Eq. 4.5.\nc = \u2211\nr\u2208R\nr mod p (4.5)"}, {"heading": "4.4.6 RDG1NamedCategoric", "text": "The same data generator as for RDG1NamedContinuous but this time generating boolean attributes instead of numeric ones so now the rules are boolean predicates."}, {"heading": "5 Results", "text": "In this section the results of the above described experiments are presented. Six plots are presented in Fig. 7. To clearly understand what the axes represent some notation has to be introduced. Let R = r1, r2, . . . , rn be the set relevant attributes and I = i1, i2, . . . , im the set of irrelevant ones having |R| = n and\n|I| = m. And let w(a) be the weight assigned by the algorithm to attribute a. Now, the x-axis represents the total number of attributes (m + n) and the yaxis the separability s (i.e. the maximum weight assigned to a relevant attribute minus the maximum weight assigned to an irrelevant one). Formulas are shown in Eq. 5.1.\nx-axis: m+ n\ny-axis: s = (\nmax ar\u2208R w(ar)\n) \u2212 (\nmax ai\u2208I w(ai)\n)\n(5.1)\nNow, in order to accentuate the global differences between the three algorithms six more plots are presented with the accumulated results for the y-axis. Fig. 8 shows these results. Now the x-axis keeps the same definition as before while the y-axis is the accumulated value of the separability, so now the formula for the y-axis value at point xn is the one in Eq. 5.2 knowing that si is the separability defined in Eq. 5.1 at point xi.\ny-axis: n \u2211\ni=0\nsi (5.2)\nFor this new axis definition, the slope of the function indicates positive or negative separability. If function descends at some point then separability was negative, on the other hand if function is ascending at this point then separability was positive. The steepness of the slope indicates the magnitude of the separability (either if it was positive or negative). And finally the separation between the curves for each algorithm tells about the accumulated difference of separabilities. If at the end one algorithm is above another it shows that the accumulated (and so the mean) separability is greater for this particular algorithm so one can conclude that in average this algorithm outperforms the other."}, {"heading": "6 Conclusions", "text": "By looking at the results above, it can be seen that none of the three algorithms is clearly better than another for the chosen set of problems. Looking at the first set of plots having separability is in the x-axis, we can see that the curves for three algorithms are almost the same, only when there are few attributes dReliefF seems to have different behavior.\nAn anomaly is the problem of the random RBFs, there dReliefF is clearly worse. In fatct, except for the majority problem dReliefF is always the worse algorithm and even there it is non-significantly better. A difference between dReliefF and the other two algorithms is that it uses the calculated weights as distance ponderations starting at the first iteration of the algorithm. That certainly may cause ReliefF to get stuck into a local minimum found in those first iterations because the distance function that is using does not take into account some of the relevant variables. In a section above where pdReliefF\nis introduced, we stated the hypothesis that using the weights estimates since the first iteration may cause decrease performance due to the fact that these estimations may be too biased to the first instances and, so, may be far from the optimal weights. Now the results help support this hypothesis. That could also explain why dReliefF\u2019s behavior is different from the others when few attributes are evaluated as opposed as when more attributes are present. When there are few attributes to calculate distance with, making a mistake on choosing their ponderations makes big changes in the results, so problems with few attributes are more sensible to wrong distance calculations and cause dReliefF to either have much higher or lower performance depending on how close are the early weights to the real optimal weights. If the first instances seen by the algorithm are not representative of the whole set, for example because they share some common characteristic that is rare among other instances, then the weights used will be biased; on the other hand if these first instances give more accurate weight approximates, then is possible that dReliefF\u2019s worked better than the rest.\nThere is also another characteristic of the results to be pointed out. In the second set of plots where differences among the algorithms stand out clearer, one can see differences between the behavior of the normal version of the algorithm as opposed to the modified ones. In these plots, two parallel curves for the separability of two algorithms, indicate that their performance evolves in the same way, meanwhile divergent curves indicate that the performance of one of them increases (decreases) more than the other. Having this in mind the results show that for the two first problems with numeric attributes the performance of dReliefF decreases very quick, normal ReliefF is the best of the three and pdReliefF is close to it though its performance also decreases faster than normal ReliefF\u2019s. Results for NonMonotonic are not clear as separability for that particular problem keeps very high for any number of attributes and the three algorithms perform almost identical. Some modifications could be applied to the generation of the problem to make it more difficult for ReliefF to discriminate attributes\u2019 relevance (e.g. adding more noise to the relevant ones) and compare the performance degradation for the three algorithms. The odd thing is that on the contrary of what happens with numeric problems, when we move onto the categoric ones we can see that now the algorithm which suffers the least performance decrease is dReliefF followed by pdReliefF.\nSo the final conclusion looking at these experimental results must be that although the performance of the three algorithms is frequently almost the same, the new algorithm pdReliefF introduced seems to be always in the middle of the other two quite stick to the better of the two while the other two are better or worse depending on the problem type, maybe depending on whether attributes are numeric or categoric. And also that dReliefF is very sensible to early errors on weight approximation of ReliefF so it must be used carefully.\nAs future work, more problems could be tested and specific experiments should be conducted to get deeper in the hypothesis that the different versions of ReliefF perform different on problems with numeric or categoric attributes. Also some tests on real data should be done using different classifiers to contrast\nthem to the results on artificially generated ones."}], "references": [{"title": "The feature selection problem: Traditional methods and a new algorithm", "author": ["Kira", "Rendell", "K. 1992] Kira", "L.A. Rendell"], "venue": "In AAAI,", "citeRegEx": "Kira et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Kira et al\\.", "year": 1992}, {"title": "Wrappers for feature subset selection", "author": ["Kohavi", "John", "R. 1997] Kohavi", "G.H. John"], "venue": "Artif. Intell.,", "citeRegEx": "Kohavi et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Kohavi et al\\.", "year": 1997}, {"title": "Theoretical and empirical analysis of relieff and rrelieff", "author": ["Robnik-\u0160ikonja", "Kononenko", "M. 2003] Robnik-\u0160ikonja", "I. Kononenko"], "venue": "Machine Learning,", "citeRegEx": "Robnik.\u0160ikonja et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Robnik.\u0160ikonja et al\\.", "year": 2003}, {"title": "A review and empirical evaluation of feature weighting methods for a class of lazy learning", "author": ["Wettschereck et al", "D. 1997] Wettschereck", "D.W. Aha", "T. Mohri"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q1997\\E", "shortCiteRegEx": "al. et al\\.", "year": 1997}, {"title": "Improved heterogeneous distance functions", "author": ["Wilson", "Martinez", "D.R. 1997] Wilson", "T.R. Martinez"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Wilson et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Wilson et al\\.", "year": 1997}], "referenceMentions": [], "year": 2017, "abstractText": "Feature weighting algorithms try to solve a problem of great importance nowadays in machine learning: The search of a relevance measure for the features of a given domain. This relevance is primarily used for feature selection as feature weighting can be seen as a generalization of it, but it is also useful to better understand a problem\u2019s domain or to guide an inductor in its learning process. Relief family of algorithms are proven to be very effective in this task. On previous work, a new extension was proposed that aimed for improving the algorithm\u2019s performance and it was shown that in certain cases it improved the weights\u2019 estimation accuracy. However, it also seemed to be sensible to some characteristics of the data. An improvement of that previously presented extension is presented in this work that aims to make it more robust to problem specific characteristics. An experimental design is proposed to test its performance. Results of the tests prove that it indeed increase the robustness of the previously proposed extension. 1 Overview Feature selection is undoubtedly one of the most important problems in machine learning, pattern recognition and information retrieval, among others. A feature selection algorithm is a computational solution that is motivated by a certain definition of relevance. However, the relevance of a feature may have several definitions depending on the objective that is looked after. On the other hand, feature weighting algorithms try to estimate relevance (in the form of weights to the features) rather than binarily deciding whether a feature is either relevant or not. This is a much harder problem, but also a more flexible framework from an inductive learning perspective. This kind of 1 algorithms are confronted with the down-weighting of irrelevant features, the up-weighting of relevant ones and the problem of relevance assignment when redundancy is an issue. In this work we review Relief, one of the most popular feature weighting algorithms. Original Relief and some of its variants are presented on section 2 drawing heavily on own earlier material. Next, we revisit a \"double\" or feedback extension of the algorithm, that was firstly introduced in an own previous work, that takes its own estimations into account in order to improve general performance. Finally a new version of the algorithm is presented on section 3 that uses its own estimations in a progressive manner, it initially behaves like the traditional algorithm and gradually increases the importance of its estimates to behave at the end as the \"double\" version. An experimental design is presenten in secion 4 to test the performance of the original algorithm versus the two proposed ones. Finally some results and conclusions are presented. 2 Relief Relief is a feature weighting algorithm that doesn\u2019t share one common characteristic of the feature selection and weighting methods. Most of them treat features individually assuming conditional independence of features upon the class. In the other hand, Relief takes all other features in care when evaluating a specific feature. Another interesting characteristic of Relief is that it is aware of contextual information being able to detect local correlations of feature values and their ability to discriminate from an instance of a different class. The main idea behind Relief is to assign large weights to features that contribute in separating near instances of different class and joining near instances belonging to the same class. The word \"near\" in the previous sentence is of crucial importance since we mentioned that one of the main differences between Relief and the other cited methods is the ability to take local context into account. Relief does not reward features that separate (join) instances of different (same) classes in general but features that do so for near instances. In Fig. 1 we can see the original algorithm presented by Kira and Rendell in [Kira and Rendell, 1992]. We maintained the original notation that slightly differs from the used above as now features (attributes) are labeled A. There we can see that in the aim of detecting whether the feature is useful to discriminate near instances it selects two nearest neighbors of the current instance Ri. One from the same class H called the nearest hit and one from the different class M (the original Relief algorithm only dealt with two class problems) called the nearest miss. With these two nearest neighbors it increases the weight ofthe feature if it has the same value for both Ri and H and decreases it otherwise. The opposite occurs with the nearest miss, Relief increases the weight of a feature if it has opposite values for Ri and M and decreases it otherwise. One of the central parts of Relief is the difference function diff which is also", "creator": "LaTeX with hyperref package"}}}