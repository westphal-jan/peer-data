{"id": "1512.04469", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Nov-2015", "title": "\\\"Uber die Klassifizierung von Knoten in dynamischen Netzwerken mit Inhalt", "abstract": "homonymous This 23,100 paper insular explains the DYCOS - Algorithm as homasote it teeuw was introduced postage in by Aggarwal and Li abhira in 2011. It ethernet operates on graphs fastnet whichs nodes are freeborn partially molineaux labeled cause-and-effect and automatically xray adds missing dispensation labels manzur to nodes. To 20-piece do kempsey so, the DYCOS algorithm custance makes raffel use of the hesham structure of neo-expressionism the valiantly graph as nor well mainframe as content which jacobson is bozman assigned to thirty-minute the totalitarian node. Aggarwal and Li measured in an norrmalm experimental 54-day analysis that DYCOS adds devoid the tokaido missing mariestad labels disassembled to a Graph 65.39 with huffily 19396 shemari nodes jamesway of lippo which 14814 are yeta labeled and korean-japanese another Graph dynamix with 9,720 806635 kolodin nodes of which 3.195 18999 are labeld sakhalinsk on cruellest one consol core of scruples an willsboro Intel clent Xeon 2. 105.34 5 bouabdellah GHz kungliga CPU kolodjay with 32 mahanama G 3:01 RAM crunchyroll within less uttar than a minute. garde Additionally, ebina extensions 49.04 of the DYCOS khojavend algorithm ratnavali are itz proposed.", "histories": [["v1", "Mon, 23 Nov 2015 13:28:11 GMT  (15kb,D)", "http://arxiv.org/abs/1512.04469v1", "in German. This term paper was handed in on 17.01.2014"]], "COMMENTS": "in German. This term paper was handed in on 17.01.2014", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["martin thoma"], "accepted": false, "id": "1512.04469"}, "pdf": {"name": "1512.04469.pdf", "metadata": {"source": "META", "title": "U\u0308ber die Klassifizierung von Knoten in dynamischen Netzwerken mit textuellen Inhalten", "authors": ["Martin Thoma"], "emails": [], "sections": [{"heading": null, "text": "1 \u00dcber die Klassifizierung von Knoten in dynamischen Netzwerken mit Inhalt\nMartin Thoma\nZusammenfassung\u2014In dieser Arbeit wird der DYCOSAlgorithmus, wie er in [AL11] vorgestellt wurde, erkl\u00e4rt. Er arbeitet auf Graphen, deren Knoten teilweise mit Beschriftungen versehen sind und erg\u00e4nzt automatisch Beschriftungen f\u00fcr Knoten, die bisher noch keine Beschriftung haben. Dieser Vorgang wird \u201eKlassifizierung\u201c genannt. Dazu verwendet er die Struktur des Graphen sowie textuelle Informationen, die den Knoten zugeordnet sind. Die in [AL11] beschriebene experimentelle Analyse ergab, dass er auch auf dynamischen Graphen mit 19 396 bzw. 806 635 Knoten, von denen nur 14 814 bzw. 18 999 beschriftet waren, innerhalb von weniger als einer Minute auf einem Kern einer Intel Xeon 2.5 GHz CPU mit"}, {"heading": "32 G RAM ausgef\u00fchrt werden kann. Zus\u00e4tzlich wird [AL11] kritisch Er\u00f6rtert und und es werden m\u00f6gliche Erweiterungen des DYCOS-Algorithmus vorgeschlagen.", "text": "Keywords: DYCOS, Label Propagation, Knotenklassifizierung"}, {"heading": "I. EINLEITUNG", "text": "Im Folgenden werden in Abschnitt I-A einige Beispiele, in denen der DYCOS-Algorithmus Anwendung finden k\u00f6nnte, dargelegt. In Abschnitt I-B wird die Problemstellung formal definiert und in Abschnitt I-C wird auf besondere Herausforderungen der Aufgabenstellung hingewiesen."}, {"heading": "A. Motivation", "text": "Teilweise beschriftete Graphen sind allgegenw\u00e4rtig. Publikationsdatenbanken mit Publikationen als Knoten, Literaturverweisen und Zitaten als Kanten sowie von Nutzern vergebene Beschriftungen (sog. Tags) oder Kategorien als Knotenbeschriftungen; Wikipedia mit Artikeln als Knoten, Links als Kanten und Kategorien als Knotenbeschriftungen sowie soziale Netzwerke mit Eigenschaften der Benutzer als Knotenbeschriftungen sind drei Beispiele daf\u00fcr. H\u00e4ufig sind Knotenbeschriftungen nur teilweise vorhanden und es ist w\u00fcnschenswert die fehlenden Knotenbeschriftungen automatisiert zu erg\u00e4nzen."}, {"heading": "B. Problemstellung", "text": "Gegeben ist ein Graph, dessen Knoten teilweise beschriftet sind. Zus\u00e4tzlich stehen zu einer Teilmenge der Knoten Texte bereit. Gesucht sind nun Knotenbeschriftungen f\u00fcr alle Knoten, die bisher noch nicht beschriftet sind.\nDefinition 1 (Knotenklassifierungsproblem) Sei Gt = (Vt, Et, VL,t) ein gerichteter Graph, wobei Vt die Menge aller Knoten, Et \u2286 Vt \u00d7 Vt die Kantenmenge und VL,t \u2286 Vt die Menge der beschrifteten Knoten jeweils zum Zeitpunkt t bezeichne. Au\u00dferdem sei Lt die Menge aller zum Zeitpunkt t vergebenen\nKnotenbeschriftungen und f : VL,t \u2192 Lt die Funktion, die einen Knoten auf seine Beschriftung abbildet.\nWeiter sei f\u00fcr jeden Knoten v \u2208 V eine (eventuell leere) Textmenge T (v) gegeben.\nGesucht sind nun Beschriftungen f\u00fcr Vt \\ VL,t, also f\u0303 : Vt \\ VL,t \u2192 Lt. Die Aufgabe, zu Gt die Funktion f\u0303 zu finden hei\u00dft Knotenklassifierungsproblem."}, {"heading": "C. Herausforderungen", "text": "Die Graphen, f\u00fcr die dieser Algorithmus konzipiert wurde, sind viele 10 000 Knoten gro\u00df und dynamisch. \u201eDynamisch\u201c bedeutet in diesem Kontext, dass neue Knoten und eventuell auch neue Kanten hinzu kommen bzw. Kanten oder Knoten werden entfernt werden. Au\u00dferdem stehen textuelle Inhalte zu den Knoten bereit, die bei der Klassifikation genutzt werden k\u00f6nnen. Bei kleinen \u00c4nderungen sollte nicht alles nochmals berechnen werden m\u00fcssen, sondern basierend auf zuvor berechneten Knotenbeschriftungen sollte die Klassifizierung angepasst werden."}, {"heading": "II. RELATED WORK", "text": "Sowohl das Problem der Knotenklassifikation, als auch das der Textklassifikation, wurde bereits in verschiedenen Kontexten analysiert. Jedoch scheinen bisher entweder nur die Struktur des zugrundeliegenden Graphen oder nur Eigenschaften der Texte verwendet worden zu sein.\nSo werden in [BCM11], [SJ01] unter anderem Verfahren zur Knotenklassifikation beschrieben, die wie der in [AL11] vorgestellte DYCOS-Algorithmus, um den es in dieser Ausarbeitung geht, auch auf Random Walks basieren.\nObwohl es auch zur Textklassifikation einige Paper gibt [ZG02], [JCSZ10], geht doch keines davon auf den Spezialfall der Textklassifikation mit einem zugrundeliegenden Graphen ein.\nDie vorgestellten Methoden zur Textklassifikation variieren au\u00dferdem sehr stark. Es gibt Verfahren, die auf dem bagof-words-Modell basieren [Ko12] wie es auch im DYCOSAlgorithmus verwendet wird. Aber es gibt auch Verfahren, die auf dem Expectation-Maximization-Algorithmus basieren [NMTM99] oder Support Vector Machines nutzen [Joa98].\nEs w\u00e4re also gut Vorstellbar, die Art und Weise wie die Texte in die Klassifikation des DYCOS-Algorithmus einflie\u00dfen zu variieren. Allerdings ist dabei darauf hinzuweisen, dass die im Folgenden vorgestellte Verwendung der Texte sowohl einfach zu implementieren ist und nur lineare Vorverarbeitungszeit in Anzahl der W\u00f6rter des Textes hat, als auch es erlaubt einzelne Knoten zu klassifizieren, wobei der Graph nur lokal um den zu klassifizierenden Knoten betrachten werden muss.\nar X\niv :1\n51 2.\n04 46\n9v 1\n[ cs\n.L G\n] 2\n3 N\nov 2\n01 5\n2"}, {"heading": "III. DYCOS", "text": "A. \u00dcberblick\nDYCOS (DYnamic Classification algorithm with cOntent and Structure) ist ein Knotenklassifizierungsalgorithmus, der Urspr\u00fcnglich in [AL11] vorgestellt wurde.\nEin zentrales Element des DYCOS-Algorithmus ist der sog. Random Walk: Definition 2 (Random Walk, Sprung) Sei G = (V,E) mit\nE \u2286 V \u00d7 V ein Graph und v0 \u2208 V ein Knoten des Graphen.\nEin Random Walk der L\u00e4nge l auf G, startend bei v0 ist nun der zeitdiskrete stochastische Prozess, der vi auf einen zuf\u00e4llig gew\u00e4hlten Nachbarn vi+1 abbildet (f\u00fcr i \u2208 0, . . . , l \u2212 1). Die Abbildung vi 7\u2192 vi+1 hei\u00dft ein Sprung.\nDer DYCOS-Algorithmus klassifiziert einzelne Knoten, indem r Random Walks der L\u00e4nge l, startend bei dem zu klassifizierenden Knoten v gemacht werden. Dabei werden die Beschriftungen der besuchten Knoten gez\u00e4hlt. Die Beschriftung, die am h\u00e4ufigsten vorgekommen ist, wird als Beschriftung f\u00fcr v gew\u00e4hlt. DYCOS nutzt also die sog. Homophilie, d. h. die Eigenschaft, dass Knoten, die nur wenige Hops von einander entfernt sind, h\u00e4ufig auch \u00e4hnlich sind [BCM11]. Der DYCOSAlgorithmus arbeitet jedoch nicht direkt auf dem Graphen, sondern erweitert ihn mit Hilfe der zur Verf\u00fcgung stehenden Texte. Wie diese Erweiterung erstellt wird, wird im Folgenden erkl\u00e4rt. F\u00fcr diese Erweiterung wird zuerst wird Vokabular Wt bestimmt, das charakteristisch f\u00fcr eine Knotengruppe ist. Wie das gemacht werden kann und warum nicht einfach jedes Wort in das Vokabular aufgenommen wird, wird in Abschnitt III-D erl\u00e4utert. Nach der Bestimmung des Vokabulars wird f\u00fcr jedes Wort im Vokabular ein Wortknoten zum Graphen hinzugef\u00fcgt. Alle Knoten, die der Graph zuvor hatte, werden nun \u201eStrukturknoten\u201c genannt. Ein Strukturknoten v wird genau dann mit einem Wortknoten w \u2208Wt verbunden, wenn w in einem Text von v vorkommt. Abbildung 1 zeigt beispielhaft den so entstehenden, semi-bipartiten Graphen. Der DYCOS-Algorithmus betrachtet also die Texte, die einem Knoten zugeordnet sind, als eine Multimenge von W\u00f6rtern. Das hei\u00dft, zum einen wird nicht auf die Reihenfolge der W\u00f6rter geachtet, zum anderen wird bei Texten eines Knotens nicht zwischen verschiedenen Texten unterschieden. Jedoch wird die Anzahl der Vorkommen jedes Wortes ber\u00fccksichtigt.\nEntsprechend werden zwei unterschiedliche Sprungtypen unterschieden, die strukturellen Spr\u00fcnge und inhaltliche Zweifachspr\u00fcnge: Definition 3 (struktureller Sprung) Sei GE,t = (Vt, ES,t \u222a\nEW,t, VL,t,Wt) der um die Wortknoten Wt erweiterte Graph.\nDann hei\u00dft das zuf\u00e4llige wechseln des aktuell betrachteten Knoten v \u2208 Vt zu einem benachbartem Knoten w \u2208 Vt ein struktureller Sprung.\nSturkturknoten Vt Wortknoten Wt\nAbbildung 1: Erweiterter Graph\nIm Gegensatz dazu benutzten inhaltliche Zweifachspr\u00fcnge tats\u00e4chlich die Grapherweiterung: Definition 4 (inhaltlicher Zweifachsprung) Sei\nGt = (Vt, ES,t \u222aEW,t, VL,t,Wt) der um die Wortknoten Wt erweiterte Graph.\nDann hei\u00dft das zuf\u00e4llige wechseln des aktuell betrachteten Knoten v \u2208 Vt zu einem benachbartem Knoten w \u2208 Wt und weiter zu einem zuf\u00e4lligem Nachbar v\u2032 \u2208 Vt von w ein inhaltlicher Zweifachsprung.\nJeder inhaltliche Zweifachsprung beginnt und endet also in einem Strukturknoten, springt \u00fcber einen Wortknoten und ist ein Pfad der L\u00e4nge 2.\nOb in einem Sprung der Random Walks ein struktureller Sprung oder ein inhaltlicher Zweifachsprung gemacht wird, wird jedes mal zuf\u00e4llig neu entschieden. Daf\u00fcr wird der Parameter 0 \u2264 pS \u2264 1 f\u00fcr den Algorithmus gew\u00e4hlt. Mit einer Wahrscheinlichkeit von pS wird ein struktureller Sprung durchgef\u00fchrt und mit einer Wahrscheinlichkeit von (1\u2212 pS) ein modifizierter inhaltlicher Zweifachsprung, wie er in Abschnitt III-C erkl\u00e4rt wird, gemacht. Der Parameter pS gibt an, wie wichtig die Struktur des Graphen im Verh\u00e4ltnis zu den textuellen Inhalten ist. Bei pS = 0 werden ausschlie\u00dflich die Texte betrachtet, bei pS = 1 ausschlie\u00dflich die Struktur des Graphen.\nDie Vokabularbestimmung kann zu jedem Zeitpunkt t durchgef\u00fchrt werden, muss es aber nicht.\nIn Algorithmus 1 steht der DYCOS-Algorithmus in Form von Pseudocode: In Zeile 8 wird f\u00fcr jeden unbeschrifteten Knoten durch die folgenden Zeilen eine Beschriftung gew\u00e4hlt.\nZeile 10 f\u00fchrt r Random Walks durch. In Zeile 11 wird eine tempor\u00e4re Variable f\u00fcr den aktuell betrachteten Knoten angelegt.\nIn Zeile 12 bis Zeile 21 werden einzelne Random Walks der L\u00e4nge l durchgef\u00fchrt, wobei die beobachteten Beschriftungen gez\u00e4hlt werden und mit einer Wahrscheinlichkeit von pS ein struktureller Sprung durchgef\u00fchrt wird."}, {"heading": "B. Datenstrukturen", "text": "Zus\u00e4tzlich zu dem gerichteten Graphen Gt = (Vt, Et, VL,t) verwaltet der DYCOS-Algorithmus zwei weitere Datenstruktu-\n3 Algorithmus 1 DYCOS-Algorithmus Input:\n1: GE,t = (Vt, ES,t \u222a EW,t, VL,t,Wt) (Erweiterter Graph), 2: r (Anzahl der Random Walks), 3: l (L\u00e4nge eines Random Walks), 4: ps (Wahrscheinlichkeit eines strukturellen Sprungs), 5: q (Anzahl der betrachteten Knoten in der Clusteranalyse)\nOutput: Klassifikation von Vt \\ VL,t 6: 7: 8: for each Knoten v \u2208 Vt \\ VL,t do 9: d\u2190 leeres assoziatives Array 10: for i = 1, . . . , r do 11: w \u2190 v 12: for j = 1, . . . , l do 13: sprungTyp\u2190 RANDOM(0, 1) 14: if sprungTyp \u2264 pS then 15: w \u2190 STURKTURELLERSPRUNG(w) 16: else 17: w \u2190 INHALTLICHERZWEIFACH-\nSPRUNG(w) 18: beschriftung \u2190 w.GETLABEL() 19: if !d.HASKEY(beschriftung) then 20: d[beschriftung]\u2190 0 21: d[beschriftung]\u2190 d[beschriftung] + 1 22: if d.ISEMPTY( ) then . Es wurde kein beschrifteter\nKnoten gesehen 23: MH \u2190 H\u00c4UFIGSTELABELIMGRAPH() 24: else 25: MH \u2190 MAX(d) 26: 27: . W\u00e4hle aus der Menge der h\u00e4ufigsten Beschriftungen\nMH zuf\u00e4llig eine aus 28: label\u2190 RANDOM(MH) 29: v.ADDLABEL(label) . und weise dieses v zu 30: return Beschriftungen f\u00fcr Vt \\ VL,t\nren:\n\u2022 F\u00fcr jeden Knoten v \u2208 Vt werden die vorkommenden W\u00f6rter, die auch im Vokabular Wt sind, und deren Anzahl gespeichert. Das k\u00f6nnte z. B. \u00fcber ein assoziatives Array (auch \u201edictionary\u201c oder \u201emap\u201c genannt) geschehen. W\u00f6rter, die nicht in Texten von v vorkommen, sind nicht im Array. F\u00fcr alle vorkommenden W\u00f6rter ist der gespeicherte Wert zum Schl\u00fcssel w \u2208Wt die Anzahl der Vorkommen von w in den Texten von v.\n\u2022 F\u00fcr jedes Wort des Vokabulars Wt wird eine Liste von Knoten verwaltet, in deren Texten das Wort vorkommt. Diese Liste wird bei den inhaltlichen Zweifachsprung, der in Abschnitt III-C erkl\u00e4rt wird, verwendet."}, {"heading": "C. Sprungtypen", "text": "Die beiden bereits definierten Sprungtypen, der strukturelle Sprung sowie der inhaltliche Zweifachsprung werden im Folgenden erkl\u00e4rt.\nDer strukturelle Sprung entspricht einer zuf\u00e4lligen Wahl eines Nachbarknotens, wie es in Algorithmus 2 gezeigt wird.\nAlgorithmus 2 Struktureller Sprung 1: function STURKTURELLERSPRUNG(Knoten v, Anzahl q) 2: n\u2190 v.NEIGHBORCOUNT . W\u00e4hle aus der Liste der\nNachbarknoten 3: r \u2190 RANDOMINT(0, n\u2212 1) . einen zuf\u00e4llig aus 4: v \u2190 v.NEXT(r) . Gehe zu diesem Knoten 5: return v\nBei inhaltlichen Zweifachspr\u00fcngen ist jedoch nicht sinnvoll so strikt nach der Definition vorzugehen, also direkt von einem strukturellem Knoten v \u2208 Vt zu einem mit v verbundenen Wortknoten w \u2208 Wt zu springen und von diesem wieder zu einem verbundenem strukturellem Knoten v\u2032 \u2208 Vt. W\u00fcrde dies gemacht werden, w\u00e4re zu bef\u00fcrchten, dass aufgrund von Homonymen die Qualit\u00e4t der Klassifizierung verringert wird. So hat \u201eBr\u00fccke\u201c im Deutschen viele Bedeutungen. Gemeint sein k\u00f6nnen z. B. das Bauwerk, das Entwurfsmuster der objektorientierten Programmierung oder ein Teil des Gehirns.\nDeshalb wird f\u00fcr jeden Knoten v, von dem aus ein inhaltlicher Zweifachsprung gemacht werden soll folgende Textanalyse durchgef\u00fchrt:\nC1 Gehe alle in v startenden Random Walks der L\u00e4nge 2 durch und erstelle eine Liste L der erreichbaren Knoten v\u2032. Speichere au\u00dferdem, durch wie viele Pfade diese Knoten v\u2032 jeweils erreichbar sind.\nC2 Betrachte im Folgenden nur die Top-q Knoten bzgl. der Anzahl der Pfade von v nach v\u2032, wobei q \u2208 N eine zu w\u00e4hlende Konstante des DYCOS-Algorithmus ist.1 Diese Knotenmenge hei\u00dfe im Folgenden T (v) und p(v, v\u2032) sei die Anzahl der Pfade von v \u00fcber einen Wortknoten nach v\u2032. C3 W\u00e4hle mit Wahrscheinlichkeit p(v,v \u2032)\u2211\nw\u2208T (v) p(v,w) den Knoten\nv\u2032 \u2208 T (v) als Ziel des Zweifachsprungs.\nKonkret k\u00f6nnte also ein inhaltlicher Zweifachsprung sowie wie in Algorithmus 3 beschrieben umgesetzt werden. Der Algorithmus bekommt einen Startknoten v \u2208 VT und einen q \u2208 N als Parameter. q ist ein Parameter der f\u00fcr den DYCOSAlgorithmus zu w\u00e4hlen ist. Dieser Parameter beschr\u00e4nkt die Anzahl der m\u00f6glichen Zielknoten v\u2032 \u2208 VT auf diejenigen q Knoten, die v bzgl. der Textanalyse am \u00e4hnlichsten sind.\nIn Zeile 2 bis Zeile 7 wird Punkt C1 durchgef\u00fchrt und alle erreichbaren Knoten in reachableNodes mit der Anzahl der Pfade, durch die sie erreicht werden k\u00f6nnen, gespeichert.\n1Sowohl f\u00fcr den DBLP, als auch f\u00fcr den CORA-Datensatz wurde in [AL11, S. 364] q = 10 gew\u00e4hlt.\n4 In Zeile 8 wird Punkt C2 durchgef\u00fchrt. Ab hier gilt\n|T | = { q falls |reachableNodes| \u2265 q |reachableNodes| sonst\nBei der Wahl der Datenstruktur von T ist zu beachten, dass man in Zeile 23 \u00fcber Indizes auf Elemente aus T zugreifen k\u00f6nnen muss.\nIn Zeile 10 bis 15 wird ein assoziatives Array erstellt, das von v\u2032 \u2208 T (v) auf die relative H\u00e4ufigkeit bzgl. aller Pfade von v zu Knoten aus den Top-q abbildet.\nIn allen folgenden Zeilen wird Punkt C3 durchgef\u00fchrt. In Zeile 17 bis Zeile 24 wird ein Knoten v\u2032 \u2208 T (v) mit einer Wahrscheinlichkeit, die seiner relativen H\u00e4ufigkeit am Anteil der Pfaden der L\u00e4nge 2 von v nach v\u2032 \u00fcber einen beliebigen Wortknoten entspricht ausgew\u00e4hlt und schlie\u00dflich zur\u00fcckgegeben.\nAlgorithmus 3 Inhaltlicher Zweifachsprung 1: function INHALTLICHERZWEIFACHSPRUNG(Knoten v \u2208\nVT , q \u2208 N) 2: erreichbareKnoten\u2190 leeres assoziatives Array 3: for each Wortknoten w in v.GETWORDNODES() do 4: for each Strukturknoten x in\nw.GETSTRUCTURALNODES() do 5: if !erreichbareKnoten.HASKEY(x) then 6: erreichbareKnoten[x]\u2190 0 7: erreichbareKnoten[x] \u2190\nerreichbareKnoten[x] + 1\n8: T \u2190 MAX(erreichbareKnoten, q) 9:\n10: s\u2190 0 11: for each Knoten x \u2208 T do 12: s\u2190 s+ erreichbareKnoten[x] 13: relativeHaeufigkeit\u2190 leeres assoziatives Array 14: for each Knoten x \u2208 T do 15: relativeHaeufigkeit\u2190 erreichbareKnoten[x]s 16: 17: random\u2190 RANDOM(0, 1) 18: r \u2190 0.0 19: i\u2190 0 20: while s < random do 21: r \u2190 r + relativeHaeufigkeit[i] 22: i\u2190 i+ 1 23: v \u2190 T [i\u2212 1] 24: return v\nD. Vokabularbestimmung\nDa die Gr\u00f6\u00dfe des Vokabulars die Datenmenge signifikant beeinflusst, liegt es in unserem Interesse so wenig W\u00f6rter wie m\u00f6glich ins Vokabular aufzunehmen. Insbesondere sind W\u00f6rter nicht von Interesse, die in fast allen Texten vorkommen, wie im Deutschen z. B. \u201eund\u201c, \u201emit\u201c und die Pronomen. Es ist\nw\u00fcnschenswert W\u00f6rter zu w\u00e4hlen, die die Texte m\u00f6glichst stark voneinander Unterscheiden. Der DYCOS-Algorithmus w\u00e4hlt die Top-m dieser W\u00f6rter als Vokabular, wobei m \u2208 N eine festzulegende Konstante ist. In [AL11, S. 365] wird der Einfluss von m \u2208 { 5, 10, 15, 20 } auf die Klassifikationsg\u00fcte untersucht und festgestellt, dass die Klassifikationsg\u00fcte mit gr\u00f6\u00dferem m sinkt, sie also f\u00fcr m = 5 f\u00fcr den DBLP-Datensatz am h\u00f6chsten ist. F\u00fcr den CORA-Datensatz wurde mit m \u2208 { 3, 4, 5, 6 } getestet und kein signifikanter Unterschied festgestellt.\nNun kann man manuell eine Liste von zu beachtenden W\u00f6rtern erstellen oder mit Hilfe des Gini-Koeffizienten automatisch ein Vokabular erstellen. Der Gini-Koeffizient ist ein statistisches Ma\u00df, das die Ungleichverteilung bewertet. Er ist immer im Intervall [0, 1], wobei 0 einer Gleichverteilung entspricht und 1 der gr\u00f6\u00dftm\u00f6glichen Ungleichverteilung.\nSei nun ni(w) die H\u00e4ufigkeit des Wortes w in allen Texten mit der i-ten Knotenbeschriftung.\npi(w) := ni(w)\u2211|Lt| j=1 nj(w) (Relative H\u00e4ufigkeit des Wortes w)\n(1)\nG(w) := |Lt|\u2211 j=1 pj(w) 2 (Gini-Koeffizient von w) (2)\nIn diesem Fall ist G(w) = 0 nicht m\u00f6glich, da zur Vokabularbestimmung nur W\u00f6rter betrachtet werden, die auch vorkommen.\nEin Vorschlag, wie die Vokabularbestimmung implementiert werden kann, ist als Pseudocode mit Algorithmus 4 gegeben. In Zeile 6 wird eine Teilmenge St \u2286 VL,t zum Generieren des Vokabulars gew\u00e4hlt. In Zeile 8 wird ein Array cLabelWords erstellt, das (|Lt|+ 1) Felder hat. Die Elemente dieser Felder sind jeweils assoziative Arrays, deren Schl\u00fcssel W\u00f6rter und deren Werte nat\u00fcrliche Zahlen sind. Die ersten |Lt| Elemente von cLabelWords dienen dem Z\u00e4hlen der H\u00e4ufigkeit der W\u00f6rter von Texten aus St, wobei f\u00fcr jede Beschriftung die H\u00e4ufigkeit einzeln gez\u00e4hlt wird. Das letzte Element aus cLabelWords z\u00e4hlt die Summe der W\u00f6rter. Diese Datenstruktur wird in Zeile 9 bis 15 gef\u00fcllt.\nIn Zeile 18 bis 20 wird die relative H\u00e4ufigkeit der W\u00f6rter bzgl. der Beschriftungen bestimmt. Daraus wird in Zeile 21 bis 23 der Gini-Koeffizient berechnet. Schlie\u00dflich werden in Zeile 24 bis 25 die Top-q W\u00f6rter mit den h\u00f6chsten Gini-Koeffizienten zur\u00fcckgegeben.\nDie Menge St kann aus der Menge aller Dokumente, deren Knoten beschriftet sind, mithilfe des in [Vit85] vorgestellten Algorithmus bestimmt werden."}, {"heading": "IV. ANALYSE DES DYCOS-ALGORITHMUS", "text": "F\u00fcr den DYCOS-Algorithmus wurde in [AL11] bewiesen, dass sich nach Ausf\u00fchrung von DYCOS f\u00fcr einen unbeschrifteten Knoten mit einer Wahrscheinlichkeit von h\u00f6chstens (|Lt|\u22121)\u00b7e\u2212l\u00b7b 2/2 eine Knotenbeschriftung ergibt, deren relative\n5 Algorithmus 4 Vokabularbestimmung Input:\n1: VL,t (beschriftete Knoten), 2: Lt (Menge der Beschriftungen), 3: f : VL,t \u2192 Lt (Beschriftungsfunktion), 4: m (Gew\u00fcnschte Vokabulargr\u00f6\u00dfe)\nOutput: Mt (Vokabular) 5: 6: St \u2190 SAMPLE(VL,t) . W\u00e4hle St \u2286 VL,t aus 7: Mt \u2190 \u2205 . Menge aller W\u00f6rter 8: cLabelWords\u2190 Array aus (|Lt|+1) assoziativen Arrays 9: for each v \u2208 St do 10: i\u2190 GETLABEL(v) 11: . w ist das Wort, c ist die H\u00e4ufigkeit 12: for each (w, c) \u2208 GETTEXTASMULTISET(v) do 13: cLabelWords[i][w]\u2190 cLabelWords[i][w] + c 14: cLabelWords[|Lt|][w]\u2190 cLabelWords[i][|Lt|]+\nc 15: Mt =Mt \u222a { w } 16: 17: for each Wort w \u2208Mt do 18: p\u2190 Array aus |Lt| Zahlen in [0, 1] 19: for each Label i \u2208 Lt do 20: p[i]\u2190 cLabelWords[i][w]cLabelWords[i][|Lt|] 21: w.gini \u2190 0 22: for each i \u2208 1, . . . , |Lt| do 23: w.gini \u2190 w.gini + p[i]2\n24: Mt \u2190 SORTDESCENDINGBYGINI(Mt) 25: return TOP(Mt,m)\nH\u00e4ufigkeit weniger als b der h\u00e4ufigsten Beschriftung ist. Dabei ist |Lt| die Anzahl der Beschriftungen und l die L\u00e4nge der Random-Walks.\nAu\u00dferdem wurde experimentell anhand des DBLP-Datensatzes2 und des CORA-Datensatzes3 gezeigt (vgl. Tabelle I), dass die Klassifikationsg\u00fcte nicht wesentlich von der Anzahl der W\u00f6rter mit h\u00f6chstem Gini-Koeffizient m abh\u00e4ngt. Des Weiteren betrug die Ausf\u00fchrungszeit auf einem Kern eines Intel Xeon 2.5GHz Servers mit 32GB RAM f\u00fcr den DBLP-Datensatz unter 25 s, f\u00fcr den CORA-Datensatz sogar unter 5 s. Dabei wurde eine f\u00fcr CORA eine Klassifikationsg\u00fcte von 82%\u201384% und auf den DBLP-Daten von 61%\u201366% erreicht.\nName Knoten davon beschriftet Kanten Beschriftungen CORA 19 396 14 814 75 021 5 DBLP 806 635 18 999 4 414 135 5\nTabelle I: Datens\u00e4tze, die f\u00fcr die experimentelle Analyse benutzt wurden\nObwohl es sich nicht sagen l\u00e4sst, wie genau die Ergebnisse aus [AL11] zustande gekommen sind, eignet sich das Kreuzvalidierungsverfahren zur Bestimmung der Klassifikationsg\u00fcte wie es in [Lav06], [Sto74] vorgestellt wird:\n2http://dblp.uni-trier.de/ 3http://people.cs.umass.edu/ mccallum/data/cora-classify.tar.gz\n1) Betrachte nur VL,T .\n2) Unterteile VL,T zuf\u00e4llig in k disjunkte Mengen M1, . . . ,Mk.\n3) Teste die Klassifikationsg\u00fcte, wenn die Knotenbeschriftungen aller Knoten in Mi f\u00fcr DYCOS verborgen werden f\u00fcr i = 1, . . . , k.\n4) Bilde den Durchschnitt der Klassifikationsg\u00fcten aus Punkt 3.\nEs wird k = 10 vorgeschlagen."}, {"heading": "V. PROBLEME DES DYCOS-ALGORITHMUS", "text": "Bei der Anwendung des in [AL11] vorgestellten Algorithmus auf reale Datens\u00e4tze k\u00f6nnten zwei Probleme auftreten, die im Folgenden erl\u00e4utert werden. Au\u00dferdem werden Verbesserungen vorgeschlagen, die es allerdings noch zu untersuchen gilt."}, {"heading": "A. Anzahl der Knotenbeschriftungen", "text": "So, wie der DYCOS-Algorithmus vorgestellt wurde, k\u00f6nnen nur Graphen bearbeitet werden, deren Knoten jeweils h\u00f6chstens eine Beschriftung haben. In vielen F\u00e4llen, wie z. B. Wikipedia mit Kategorien als Knotenbeschriftungen haben Knoten jedoch viele Beschriftungen.\nAuf einen ersten Blick ist diese Schw\u00e4che einfach zu beheben, indem man beim z\u00e4hlen der Knotenbeschriftungen f\u00fcr jeden Knoten jedes Beschriftung z\u00e4hlt. Dann w\u00e4re noch die Frage zu kl\u00e4ren, mit wie vielen Beschriftungen der betrachtete Knoten beschriftet werden soll.\nJedoch ist z. B. bei Wikipedia-Artikeln auf den Knoten eine Hierarchie definiert. So ist die Kategorie \u201eKlassifikationsverfahren\u201c eine Unterkategorie von \u201eKlassifikation\u201c. Bei dem Kategorisieren von Artikeln sind m\u00f6glichst spezifische Kategorien vorzuziehen, also kann man nicht einfach bei dem Auftreten der Kategorie \u201eKlassifikationsverfahren\u201c sowohl f\u00fcr diese Kategorie als auch f\u00fcr die Kategorie \u201eKlassifikation\u201c z\u00e4hlen."}, {"heading": "B. \u00dcberanpassung und Reklassifizierung", "text": "Aggarwal und Li beschreiben in [AL11] nicht, auf welche Knoten der Klassifizierungsalgorithmus angewendet werden soll. Jedoch ist die Reihenfolge der Klassifizierung relevant. Dazu folgendes Minimalbeispiel:\nGegeben sei ein dynamischer Graph ohne textuelle Inhalte. Zum Zeitpunkt t = 1 habe dieser Graph genau einen Knoten v1 und v1 sei mit dem A beschriftet. Zum Zeitpunkt t = 2 komme ein nicht beschrifteter Knoten v2 sowie die Kante (v2, v1) hinzu. Nun wird der DYCOS-Algorithmus auf diesen Knoten angewendet und v2 mit A beschriftet. Zum Zeitpunkt t = 3 komme ein Knoten v3, der mit B\n6 v1 A v2 t = 1\n(a) t = 1\nv1 A\nv2 A\nt = 2\n(b) t = 2\nv1 A\nv2 A\nv3 B\nt = 3\n(c) t = 3\nv1 A\nv2 A v3 B\nv4t = 3\n(d) t = 4\nAbbildung 2: Minimalbeispiel f\u00fcr den Einfluss fr\u00fcherer DYCOS-Anwendungen\nbeschriftet ist, und die Kante (v2, v3) hinzu. Abbildung 2 visualisiert diesen Vorgang.\nW\u00fcrde man nun den DYCOS-Algorithmus erst jetzt, also anstelle von Zeitpunkt t = 2 zum Zeitpunkt t = 3 auf den Knoten v2 anwenden, so w\u00fcrde eine 50%-Wahrscheinlichkeit bestehen, dass dieser mit B beschriftet wird. Aber in diesem Beispiel wurde der Knoten schon zum Zeitpunkt t = 2 beschriftet. Obwohl es in diesem kleinem Beispiel noch keine Rolle spielt, wird das Problem klar, wenn man weitere Knoten einf\u00fcgt:\nWird zum Zeitpunkt t = 4 ein unbeschrifteter Knoten v4 und die Kanten (v1, v4), (v2, v4), (v3, v4) hinzugef\u00fcgt, so ist die Wahrscheinlichkeit, dass v4 mit A beschriftet wird bei 23 . Werden die unbeschrifteten Knoten jedoch erst jetzt und alle gemeinsam beschriftet, so ist die Wahrscheinlichkeit f\u00fcr A als Beschriftung bei nur 50%. Bei dem DYCOS-Algorithmus findet also eine \u00dcberanpassung an vergangene Beschriftungen statt.\nDas Reklassifizieren von Knoten k\u00f6nnte eine m\u00f6gliche L\u00f6sung f\u00fcr dieses Problem sein. Knoten, die durch den DYCOSAlgorithmus beschriftet wurden k\u00f6nnten eine Lebenszeit bekommen (TTL, Time to Live). Ist diese abgelaufen, wird der DYCOS-Algorithmus erneut auf den Knoten angewendet."}, {"heading": "VI. AUSBLICK", "text": "Den DYCOS-Algorithmus kann in einigen Aspekten erweitert werden. So k\u00f6nnte man vor der Auswahl des Vokabulars jedes Wort auf den Wortstamm zur\u00fcckf\u00fchren. Daf\u00fcr k\u00f6nnte zum Beispiel der in [Por97] vorgestellte Porter-Stemming-Algorithmus verwendet werden. Durch diese Ma\u00dfnahme wird das Vokabular kleiner gehalten wodurch mehr Artikel mit einander durch Vokabular verbunden werden k\u00f6nnen. Au\u00dferdem k\u00f6nnte so der Gini-Koeffizient ein besseres Ma\u00df f\u00fcr die Gleichheit von Texten werden.\nEine weitere Verbesserungsm\u00f6glichkeit besteht in der Textanalyse. Momentan ist diese noch sehr einfach gestrickt und ignoriert die Reihenfolge von W\u00f6rtern beziehungsweise Wertungen davon. So k\u00f6nnte man den DYCOS-Algorithmus in\neinem sozialem Netzwerk verwenden wollen, in dem politische Parteiaffinit\u00e4t von einigen Mitgliedern angegeben wird um die Parteiaffinit\u00e4t der restlichen Mitglieder zu bestimmen. In diesem Fall macht es jedoch einen wichtigen Unterschied, ob jemand \u00fcber eine Partei gutes oder schlechtes schreibt.\nEine einfache Erweiterung des DYCOS-Algorithmus w\u00e4re der Umgang mit mehreren Beschriftungen.\nDYCOS beschr\u00e4nkt sich bei inhaltlichen Zweifachspr\u00fcngen auf die Top-q-Wortknoten, also die q \u00e4hnlichsten Knoten gemessen mit der Aggregatanalyse, allerdings wurde bisher noch nicht untersucht, wie der Einfluss von q \u2208 N auf die Klassifikationsg\u00fcte ist.\nLITERATUR\n[AL11] C. C. Aggarwal and N. Li, \u201cOn node classification in dynamic content-based networks,\u201d in SDM, 2011, pp. 355\u2013366.\n[BCM11] S. Bhagat, G. Cormode, and S. Muthukrishnan. (2011) Node classification in social networks.\n[JCSZ10] C. Jiang, F. Coenen, R. Sanderson, and M. Zito, \u201cText classification using graph mining-based feature extraction,\u201d Knowledge-Based Systems, vol. 23, no. 4, pp. 302 \u2013 308, 2010, artificial Intelligence 2009 AI-2009 The 29th {SGAI} International Conference on Artificial Intelligence. [Online]. Available: http://www.sciencedirect.com/science/article/ pii/S095070510900152X\n[Joa98] T. Joachims, \u201cText categorization with support vector machines: Learning with many relevant features,\u201d 1998.\n[Ko12] Y. Ko, \u201cA study of term weighting schemes using class information for text classification,\u201d in Proceedings of the 35th International ACM SIGIR Conference on Research and Development in Information Retrieval, ser. SIGIR \u201912. New York, NY, USA: ACM, 2012, pp. 1029\u20131030. [Online]. Available: http://doi.acm.org/10.1145/2348283.2348453\n[Lav06] N. Lavesson, \u201cEvaluation and analysis of supervised learning algorithms and classifiers,\u201d Diploma Thesis, Blekinge Institute of Technology, Sweden, Dec. 2006.\n[NMTM99] K. Nigam, A. K. Mccallum, S. Thrun, and T. Mitchell, \u201cText classification from labeled and unlabeled documents using em,\u201d in Machine Learning, 1999, pp. 103\u2013134.\n[Por97] M. F. Porter, \u201cReadings in information retrieval,\u201d K. Sparck Jones and P. Willett, Eds. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 1997, ch. An Algorithm for Suffix Stripping, pp. 313\u2013316. [Online]. Available: http: //dl.acm.org/citation.cfm?id=275537.275705\n[SJ01] M. Szummer and T. Jaakkola, \u201cPartially labeled classification with markov random walks,\u201d in Advances in Neural Information Processing Systems 14, T. Dietterich, S. Becker, and Z. Ghahramani, Eds., 2001, pp. 945\u2013952. [Online]. Available: http://media.nips.cc/nipsbooks/nipspapers/paper_files/ nips14/AA36.pdf\n[Sto74] M. Stone, \u201cCross-Validatory Choice and Assessment of Statistical Predictions,\u201d Journal of the Royal Statistical Society. Series B (Methodological), vol. 36, no. 2, pp. 111\u2013147, 1974. [Online]. Available: http://dx.doi.org/10.2307/2984809\n[Vit85] J. S. Vitter, \u201cRandom sampling with a reservoir,\u201d ACM Trans. Math. Softw., vol. 11, no. 1, pp. 37\u201357, 1985. [Online]. Available: http://doi.acm.org/10.1145/3147.3165\n[ZG02] X. Zhu and Z. Ghahramani, \u201cLearning from labeled and unlabeled data with label propagation,\u201d Carnegie Mellon University, Tech. Rep., 2002."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "Zusammenfassung\u2014In dieser Arbeit wird der DYCOSAlgorithmus, wie er in [AL11] vorgestellt wurde, erkl\u00e4rt. Er arbeitet auf Graphen, deren Knoten teilweise mit Beschriftungen versehen sind und erg\u00e4nzt automatisch Beschriftungen f\u00fcr Knoten, die bisher noch keine Beschriftung haben. Dieser Vorgang wird \u201eKlassifizierung\u201c genannt. Dazu verwendet er die Struktur des Graphen sowie textuelle Informationen, die den Knoten zugeordnet sind. Die in [AL11] beschriebene experimentelle Analyse ergab, dass er auch auf dynamischen Graphen mit 19 396 bzw. 806 635 Knoten, von denen nur 14 814 bzw. 18 999 beschriftet waren, innerhalb von weniger als einer Minute auf einem Kern einer Intel Xeon 2.5 GHz CPU mit 32 G RAM ausgef\u00fchrt werden kann. Zus\u00e4tzlich wird [AL11] kritisch Er\u00f6rtert und und es werden m\u00f6gliche Erweiterungen des DYCOS-Algorithmus vorgeschlagen.", "creator": "LaTeX with hyperref package"}}}