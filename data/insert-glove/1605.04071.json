{"id": "1605.04071", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-May-2016", "title": "Bayesian Network Structure Learning with Integer Programming: Polytopes, Facets, and Complexity", "abstract": "senay The hela challenging operetta task of learning neighbouring structures lumped of t\u0103riceanu probabilistic ziane graphical 761st models iers is an capehart important 89-82 problem viegas within modern foxnews AI guardalben research. Recent years ascanius have midwicket witnessed several brumos major emrys algorithmic ward advances in c\u00e9dric structure learning bauld for bri Bayesian networks - - - arguably criticism the trell most chirwa central class 78.21 of graphical models - - - ejc especially in wonks what is known disillusioned as resources the pastan score - based odeo setting. A mod\u00e8le successful generic approach maloofs to speakman optimal Bayesian mordington network structure appetite learning (iplo BNSL ), ugoh based cre on integer burin programming (comedy/variety IP ), is 7-of-13 implemented comment in beachum the langelinie GOBNILP esparragoza system. Despite the tishman recent vlastimil algorithmic chickasaw advances, current baozhen understanding of foundational aspects wangaratta underlying anthesis the interveners IP terminer based prestonwood approach to 46,800 BNSL ramqvist is still somewhat lacking. Understanding desalination fundamental atras aspects of 1994-1997 cutting planes falaj and hfn the etemadi related separation fazlic problem (euro131 is important not only \u0633\u06cc\u062f from aerin a hybrids purely theoretical perspective, midcom but also theodor since g\u00f6mb\u00f6s it holds p.d. out gurgi the sourdis promise bailey of further marxist-leninist improving pino the swan\u00f6 efficiency oddsmaker of state - swarns of - deshler the - cier art approaches to solving releaser BNSL exactly. In mccaysville this lamason paper, luka we mobtel make wuyuan several emleader theoretical paleontological contributions towards these pxfechng goals: (i) dentary we study the luapula computational complexity of 225.5 the labial separation problem, proving fast-growing that f\u00fcnf the problem is koroma NP - hard; (ii) we teodoro formalise jernigan and hxg5 analyse the relationship between three senju key correctors polytopes underlying alt-country the tilly IP - achan based kamanda approach kathgodam to BNSL; (mellowing iii) wall we jungfraujoch study psychologist the seman facets 120-member of hodgkinson the three polytopes imelda both ceolt\u00f3ir\u00ed from 3,000-room the theoretical hilltribe and practical tv/radio perspective, 1995-1999 providing, diploid via 117.89 exhaustive tanztheater computation, a vrhovnik complete umkc enumeration barmby of djamila facets karingal for low - dimensional family - hazam variable polytopes; and, naiad furthermore, (iv) we establish geller a tight connection of 26.28 the durgham BNSL qadisiya problem to 150,000-square the holit acyclic subgraph rightnow problem.", "histories": [["v1", "Fri, 13 May 2016 07:27:03 GMT  (60kb,D)", "http://arxiv.org/abs/1605.04071v1", null], ["v2", "Sun, 18 Dec 2016 17:28:15 GMT  (144kb,D)", "http://arxiv.org/abs/1605.04071v2", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["james cussens", "matti j\\\"arvisalo", "janne h korhonen", "mark bartlett"], "accepted": false, "id": "1605.04071"}, "pdf": {"name": "1605.04071.pdf", "metadata": {"source": "CRF", "title": "Bayesian Network Structure Learning with Integer Programming: Polytopes, Facets, and Complexity", "authors": ["James Cussens", "Matti J\u00e4rvisalo", "Janne H. Korhonen", "Mark Bartlett"], "emails": ["james.cussens@york.ac.uk", "matti.jarvisalo@helsinki.fi", "korhonen@ru.is", "mark.bartlett@york.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "The study of probabilistic graphical models is a central topic in modern artificial intelligence research. Bayesian networks (Koller & Friedman, 2009) form a central class of probabilistic graphical models that finds applications in various domains (Hugin, 2016; Sheehan et al., 2014). A central problem related to Bayesian networks (BNs) is that of learning them from data. An essential part of this learning problem is to learn the structure of a\nc\u00a92016 AI Access Foundation. All rights reserved.\nar X\niv :1\n60 5.\n04 07\n1v 1\n[ cs\nBayesian network\u2014represented as a directed acyclic graph\u2014that accurately represents the joint probability distribution underlying the data.\nThere are two principal approaches to Bayesian network learning: constraint-based and score-based. In the constraint-based approach (Spirtes et al., 1993; Colombo et al., 2012) the goal is to learn a network which is consistent with conditional independence relations which have been inferred from the data. The score-based approach to Bayesian network structure learning (BNSL) treats the BNSL problem as a combinatorial optimization problem of finding a BN structure that optimises a score function for given data.\nLearning an optimal BN structure is a central but computationally challenging problem. Even when the score function is restricted to be a BDe score (Heckerman et al., 1995), the BNSL problem has been shown to be NP-hard (Chickering, 1996). Due to NPhardness, much work on BNSL has focused on developing approximate, local search style algorithms (Tsamardinos et al., 2006) that most often cannot give guarantees on how close to optimal, in terms of the objective function, are the structures found. Recently, despite its complexity, several advances in exact approaches to BNSL have surfaced (Koivisto & Sood, 2004; Silander & Myllyma\u0308ki, 2006; Cussens, 2011; de Campos & Ji, 2011; Yuan & Malone, 2013; van Beek & Hoffmann, 2015), ranging from problem-specific dynamic programming branch-and-bound algorithms to approaches based on A\u2217-style state-space search, constraint programming, and integer linear programming (IP), which can, with certain restrictions, learn provably-optimal BN structures with tens to hundreds of nodes.\nAs shown in a recent study (Malone et al., 2014), perhaps the most successful exact approach to BNSL is provided by the gobnilp system (Cussens, 2011). gobnilp implements a branch-and-cut approach to BNSL, using state-of-the-art IP solving techniques together with specialised BNSL cutting planes. The focus of this work is on providing further understanding on the IP approach to BNSL from the theoretical perspective.\nViewed as a constrained optimization problem, a central source of intractability of BNSL is the acyclicity constraint imposed on BN structures. In the IP approach to BNSL\u2014 as implemented by gobnilp\u2014the acyclicity constraint is handled in the branch-and-cut framework via deriving specialised cutting planes called cluster constraints. These cutting planes are found by solving a sequence of so-called sub-IPs arising from solutions to linear relaxations of the underlying IP formulation of BNSL without the acyclicity constraint. Finding these cutting planes is an example of a separation problem for a linear relaxation solution, so called since the cutting plane will separate that solution from the set of feasible solutions to the original (unrelaxed) problem. Understanding fundamental aspects of these cutting planes and the sub-IPs used to find them is important not only from a purely theoretical perspective, but also since it holds out the promise of further improving the efficiency of state-of-the-art approaches to solving BNSL exactly. This is the focus of and underlying motivation for this article.\nThe main contributions of this article are the following.\n\u2022 We study the computational complexity of the separation problem solved via sub-IPs with connections to the general separation problem for integer programs. As a main result, in Section 5 we establish that the sub-IPs are themselves NP-hard to solve. From the practical perspective, this both gives a theoretical justification for applying an exact IP solver to solve the sub-IPs within gobnilp, as well as motivating further\nwork on improving the efficiency of the sub-IP solving via either improved exact techniques and/or further approximate algorithms.\n\u2022 We formalise and analyse the relationship between three key polytopes underlying the IP-based approach to BNSL in Section 4. Stated in generic abstract terms, starting from the digraph polytope defined by a linear relaxation of the IP formulation without the acyclicity constraint, the search progresses towards an optimal BN structure via refining the digraph polytope towards the family-variable polytope, i.e., the convex hull of acyclic digraphs over the set of nodes in question. The complete set of cluster constraints gives rise to the cluster polytope as an intermediate.\n\u2022 We study the facets of the three polytopes both from the theoretical and practical perspective (Section 6). As a key theoretical result, we show that cluster constraints are in fact facet-defining inequalities of the family-variable polytope. From the more practical perspective, achieved via exhaustive computation, we provide a complete enumeration of facets for low-dimensional family-variable polytopes. Mapping to practice, explicit knowledge of such facets has the potential for providing further speed-ups in state-of-the-art BNSL solving by integrating (some of) these facets explicitly into search.\n\u2022 In Section 7 we derive facets of polytopes corresponding to (i) BNs consistent with a given node ordering and (ii) BNs with specified sink nodes. We then use the results on sink nodes to show how a family-variable polytope for p nodes can be constructed from a family-variable polytope for p\u22121 nodes using the technique of lift-and-project.\n\u2022 Finally, in Section 8 we provide a tight connection of the BNSL problem to the acyclic subgraph problem, as well as discussing the connection of the polytope underlying this problem to the three central polytopes underlying BNSL.\nBefore detailing the main contributions, we recall the BNSL problem in Section 2 and discuss the integer programming based approach to BNSL, central to this work, in Section 3."}, {"heading": "2. Bayesian Network Structure Learning", "text": "In this section, we recall the problem of learning optimal Bayesian network structures in the central score-based setting."}, {"heading": "2.1 Bayesian Networks", "text": "A Bayesian network represents a joint probability distribution over a set of random variables V . A Bayesian network consists of a structure and parameters.\n\u2022 The structure is an acyclic digraph (V,B) over the set V with directed edges B. The structure defines the conditional dependencies between the variables in V ; for edge i\u2190 j \u2208 B we say that i is a child of j and j is a parent of i, and for a variable i \u2208 V , we denote the set of parents of i by Pa(i, B).\n\u2022 The parameters define a distribution for each of random variables i \u2208 V given the parents Pa(i, B), that is, the probabilities Pr ( i | Pa(i, B) ) .\nAs mentioned before, our focus is on learning Bayesian networks from data. Specifically, we focus on the Bayesian network structure learning (BNSL) problem, as once a BN structure has been decided, the parameters can be learned from the data in a straightforward manner."}, {"heading": "2.2 Score-based BNSL", "text": "In the integer programming based approach to BNSL which is the focus of this work, the learning problem is cast as a constrained optimisation problem: each candidate BN structure has a score measuring how well it \u2018explains\u2019 the given data and the task is to find a BN structure which maximises that score. This score function is defined in terms of the data, but for our purposes, it is sufficient to abstract away the details, see e.g. Koller and Friedman (2009).\nSpecifically, in this paper we restrict attention to decomposable score functions, where the score is defined locally by the parent set choices for each i \u2208 V . That is, for i \u2208 V and J \u2286 V \\ {i}, let i \u2190 J denote the the pair (i, J), called a family. In our framework, we assume that the score function gives a local score ci\u2190J for each family i \u2190 J . This then defines a global score z(B) for each candidate structure (V,B) as\nz(B) = \u2211 i\u2208V ci\u2190Pa(i,B) (1)\nand we want to find the digraph (V,B) maximising z(B).\nIn practice, we typically want to restrict the set of parent sets in some way, given the large number of possible parents sets and the NP-hardness of BSNL. Typically this is done by limiting the cardinality of any candidate parent set, although other restrictions, perhaps reflecting prior knowledge, are also used. To facilitate this, we assume that a BSNL instance also defines a set of permissible parent sets P(i) \u2286 2V \\{i} for each node i. For simplicity we shall only consider BNSL problems where \u2205 \u2208 P(i) for all nodes. This also ensures that the empty graph, at least, is a permitted BN structure. Thus, the full formulation of the BSNL problem is as follows.\nDefinition 1 (BSNL). A BSNL instance is a tuple (V,P, c), where\n1. V is a set of nodes;\n2. P : V \u2192 22V is a function where, for each vertex i \u2208 V , P(i) \u2286 2V \\{i} is the set of permissible parent sets for that vertex, and \u2205 \u2208 P(i); and\n3. c is a function giving the local score ci\u2190J for each i \u2208 V and J \u2208 P(i).\nGiven a BNSL instance (V,P, c), the BSNL problem is to find an edge set B \u2286 V \u00d7V which maximises (1) subject to the following two conditions.\n1. Pa(i, B) \u2208 P(i) for all i \u2208 V .\n2. (V,B) is acyclic."}, {"heading": "2.3 BNSL with Small Parent Sets", "text": "As mentioned, it is common to put an upper bound on the cardinality of permitted parent sets. More precisely, a common setting is that we have a constant \u03ba and the BSNL instances we consider are restricted so that all J \u2208 P(i) satisfy |J | \u2264 \u03ba. For the rest of the paper we use the convention that \u03ba denotes this parent set size upper bound.\nIn practice, BNSL instances with large node set size can often be solved to optimality fairly quickly when \u03ba is small. For example, with \u03ba = 2, Sheehan et al. (2014) were able to solve BNSL instances with |V | = 1614 in between 3 and 42 minutes. Even though BNSL remains NP-hard unless \u03ba = 1 (Chickering, 1996), such results suggest that in practice the value of \u03ba is an important determining factor of the hardness of a BNSL instance.\nHowever, we will show in the following that the situation is somewhat more subtle; that is, we show that any BNSL instance can be converted to a BNSL instance with \u03ba = 2 and the same set of optimal solutions without significantly increasing the total size |V |+ \u2211 i\u2208V |P(i)| of the instance. This suggests that the practical hardness of BSNL instances is in fact controlled primarily by this total instance size rather than node set size |V |; naturally, with larger \u03ba, a smaller number of nodes is required for a large total size.\nWe first introduce some useful notation identifying the set of families in a BNSL instance. For a given set of nodes V and permitted parent sets P(i), let\nF(V,P) := {i\u2190 J | i \u2208 V, J \u2208 P(i)}, so that \u2211\ni\u2208V |P(i)| = |F(V,P)| and total instance size is |V |+ |F(V,P)|.\nTheorem 2. Given a BNSL instance (V,P, c) with the property that for each i \u2208 V , P(i) is downwards-closed, that is, I \u2286 J \u2208 P(i) implies I \u2208 P(i), we can construct another BNSL instance (V \u2032,P \u2032, c\u2032) in time poly ( |V |+ |F(V,P)| ) such that\n1. |V \u2032| = O ( |V |+ |F(V,P)| ) and |F(V \u2032,P \u2032)| = O ( |F(V,P)| ) ,\n2. |J | \u2264 2 for all J \u2208 P \u2032(i) and i \u2208 V \u2032, and\n3. there is one-to-one correspondence between the optimal solutions of (V,P, c) and (V \u2032,P \u2032, c\u2032).\nMoreover, the claim holds even when (V,P, c) does not satisfy the downwards-closed property, with bounds |V \u2032| = O ( |V |+ \u03ba |F(V,P)| ) and |F(V \u2032,P \u2032)| = O ( \u03ba |F(V,P)| ) , where \u03ba is the size of the largest parent set permitted by P.\nProof. Given (V,P, c), we construct a new instance (V \u2032,P \u2032, c\u2032) as follows. As a first step, we iteratively go through the permissible parent sets J \u2208 P(i) for each i \u2208 V and add the corresponding new parent set to P \u2032(i) using the following rules.\n\u2022 If |J | \u2264 2, we add J to P \u2032(i) with score c\u2032i\u2190J = ci\u2190J .\n\u2022 If J = {j, k, l}, then we create a new node I \u2208 V \u2032 corresponding to the subset I = {k, l}, and add the set J \u2032 = {j, I \u2032} to P \u2032(i) with score c\u2032i\u2190J \u2032 = ci\u2190J .\n\u2022 If |J | \u2265 4, we partition J into two sets J1 and J2 with |J1| \u2212 |J2| \u2264 1 and create new corresponding nodes J1, J2 \u2208 V \u2032. We then add J \u2032 = {J1, J2} to P \u2032(i) with score c\u2032i\u2190J \u2032 = ci\u2190J .\nIn the above steps, new nodes corresponding to subsets of V will be created only once, re-using the same node if it is required multiple times.\nUnless all original parent sets have size at most two, this process will create new nodes J \u2208 V \u2032 corresponding to subsets J \u2286 V with |J | \u2265 2. For each such new node J , we allow exactly one permissible parent set (of size 2) besides the empty set, as follows.\n\u2022 If J = {j, k}, then set P \u2032(J) = {\u2205, {j, k}}.\n\u2022 If J = {j, k, l}, then set P \u2032(J) = { \u2205, {j, {k, l}} } , choosing j arbitrarily and creating a\nnew node {k, l} if necessary.\n\u2022 If |J | \u2265 4, then we partition J into some J1 and J2 where |J1| \u2212 |J2| \u2264 1 and set P \u2032(J) = {\u2205, {J1, J2}}, again creating new nodes J1 and J2 if necessary.\nHowever, we want to disallow the choice of \u2205 for all new nodes in all optimal solutions, so we will set c\u2032J\u2190\u2205 = min ( \u2212 |V |,M |V | ) , where M is the minimum score given to any family by c, and set the local score for the other parent set choices to 0.\nThe creation of these parent sets may require the creation of yet further new nodes. If so, we create the permissible parent sets for each of them in the same way, iterating the process as long as necessary. This will clearly terminate, and if (V,P, c) satisfies the downwards-closed property, this will create exactly one new node in V \u2032 for each original permissible parent set, implying the bounds for |V \u2032| and |F(V \u2032,P \u2032)|. If the original instance does not have the downwards-closed property, the process may create up to |J | new nodes for each original J \u2208 P(i), which in turn implies the weaker bound.\nFinally, note that any optimal solution to (V \u2032,P \u2032, c\u2032) cannot pick the empty set as a parent set for a node corresponding to a subset of V . It is now not difficult to see that, from any optimal solution to our newly created BNSL instance, we can \u2018read off\u2019 an optimal solution to the original instance."}, {"heading": "3. An Integer Programming Approach to Bayesian Network Structure", "text": "Learning\nIn this section we discuss integer programming based approaches to BNSL, focusing on the branch-and-cut approach implemented by the gobnilp system for BNSL which motivates the theoretical results presented in this article."}, {"heading": "3.1 An Integer Programming Formulation of BNSL", "text": "Recall, from Section 2, that we refer to a node i together with its parent set J as a family. In the IP formulation of BNSL we create a family variable xi\u2190J for each potential family. A family variable is a binary indicator variable: xi\u2190J = 1 if J is the parent set for i and xi\u2190J = 0 otherwise. It is not difficult to see that any digraph (acyclic or otherwise) with |V | nodes can be encoded by a zero-one vector whose components are family variables and where exactly |V | family variables are set to 1. Figure 1 and Table 1 show an example graph and its family variable encoding, respectively.\nAlthough every digraph can thus be encoded as a zero-one vector, it is clearly not the case that each zero-one vector encodes a digraph. The key to the IP approach to BNSL\nis to add appropriate linear constraints so that all and only zero-one vectors representing acyclic digraphs satisfy all the constraints.\nThe most basic constraints are illustrated by the arrangement of the example vector in Table 1 into three rows, one for each node. It is clear that exactly one family variable for each child node must equal one. So we have |V | convexity constraints\u2211\nJ\u2208P(i)\nxi\u2190J = 1 \u2200i \u2208 V. (2)\nIt is not difficult to see that any vector x that satisfies all convexity constraints encodes a digraph. However, without further constraints, the digraph need not be acyclic. There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013). In this paper we focus on cluster constraints first introduced by Jaakkola et al. (2010). A cluster is simply a subset of nodes. For each cluster C \u2286 V (|C| > 1) the associated cluster inequality is \u2211\ni\u2208C \u2211 J\u2208P(i):J\u2229C=\u2205 xi\u2190J \u2265 1. (3)\nAn alternative formulation, which exploits the convexity constraints, is\u2211 i\u2208C \u2211 J\u2208P(i):J\u2229C 6=\u2205 xi\u2190J \u2264 |C| \u2212 1. (4)\nTo see that cluster inequalities suffice to rule out cycles, suppose that the nodes in some cluster C formed a cycle; it is clear that in that case the LHS of (3) would be 0, violating the cluster constraint. On the other hand, suppose that x encodes an acyclic digraph. Since the digraph is acyclic, there is an associated total ordering in which parents precede their\nchildren. Let C \u2286 V be an arbitrary cluster. Then the earliest element of C in this ordering will have no parents in C and so the cluster constraint is satisfied.\nIt follows that any zero-one vector x that satisfies the convexity constraints (2) and cluster constraints (3) encodes an acyclic digraph. The final ingredient in the IP approach to BNSL is to specify objective coefficients for each family variable. These are simply the local scores ci\u2190J introduced in Section 2. Collecting these elements together, we can define the IP formulation of the BNSL as follows.\nMaximise \u2211\ni\u2208V,J\u2208P(i)\nci\u2190Jxi\u2190J (5)\nsubject to \u2211\nJ\u2208P(i) xi\u2190J = 1 \u2200i \u2208 V (6)\u2211 i\u2208C \u2211 J\u2208P(i):J\u2229C=\u2205 xi\u2190J \u2265 1 \u2200C \u2286 V, |C| > 1 (7)\nxi\u2190J \u2208 {0, 1} \u2200i \u2208 V, J \u2208 P(i) (8)\n3.2 The gobnilp System\nThe gobnilp system (https://www.cs.york.ac.uk/aig/sw/gobnilp/) solves the IP problem defined by (5\u20138) for a given set of objective coefficients ci\u2190J . These coefficients are either given as input to gobnilp or computed by gobnilp from a discrete dataset with no missing values. The gobnilp approach to solving this IP are fully detailed by Bartlett and Cussens (2015); here we overview the essential ideas.\nSince there are only |V | convexity constraints (6), these are added as initial constraints to the IP. The cluster constraints, in contrast, are added as cutting planes. Initially, no cluster constraints (7) are in the IP, so we have a relaxed version of the original problem. Moreover, in its initial phase gobnilp drops the integrality condition (8) on the family variables so that only linear relaxations (i.e. LPs) of IPs are solved.\nThe solution (call it x\u2217) to the initial LP will be a digraph where a highest scoring parent set for each node is chosen, a digraph which will almost certainly contain cycles. Note that this initial solution happens to be integral, even though it is the solution to an LP not an IP. gobnilp then attempts to find clusters C such that the associated cluster constraint is violated by x\u2217. These cluster constraints are added to the LP, producing a new LP which is then solved, generating a new solution x\u2217. The process of LP solving and cluster constraint adding is continued until either (i) an LP solution is produced which corresponds to an acyclic digraph or (ii) this is not the case, but no further cutting planes can be found.\nIn the first (rare) case, the BNSL instance has been solved. The objective value of each x\u2217 that is produced is an upper bound on the objective value of an optimal digraph (since it is an exact solution to a relaxed version of the original BNSL instance), so if x\u2217 corresponds to an acyclic digraph it must be optimal.\nIn the second, more typical, case gobnilp stops ignoring the integrality constraint (8) on family variables and exploits it to make progress. If no cluster constraint cutting planes can be found, and the problem has not been solved, then x\u2217, the solution to the current linear relaxation, must be fractional, i.e. there must be at least one family variable xi\u2190J\nsuch that 0 < x\u2217i\u2190J < 1. One option is then to branch on such a variable to create two sub-problems: one where xi\u2190J is fixed to 0 and one where it is fixed to 1. Note that x \u2217 is infeasible in both sub-problems but there is an optimal solution in at least one of the sub-problems. gobnilp also has the option of branching on sums of mutually exclusive family variables. For example, if we had three nodes i, j and k, gobnilp has the option of branching on xi\u2190{j} + xi\u2190{j,k} + xj\u2190{i} + xj\u2190{i,k}, a quantity which is either 0 or 1 in any acyclic digraph. gobnilp then recursively applies the cutting plane approach to both sub-problems. gobnilp is thus a branch-and-cut approach to IP solving.\nThese are the essentials of the gobnilp system but the current implementation has many other aspects. gobnilp is implemented with the help of the SCIP system (scip. zib.de) (Achterberg, 2007) and it uses SCIP to generate many other cutting planes in addition to cluster constraints. gobnilp also adds in other initial inequalities in addition to the convexity constraints. For example, if we had three nodes i, j and k the inequality xi\u2190{j,k}+xj\u2190{i,k}+xk\u2190{i,j} \u2264 1 would be added. All these extra constraints are redundant in the sense that they do not alter the set of optimal solutions to the IP (5\u20138). They do, however, have a great effect in the time taken to identify a provably optimal solution."}, {"heading": "3.3 BNSL Cutting Planes via SUB-IPs", "text": "The separation problem for an IP is the problem of finding a cutting plane which is violated by the current linear relaxation of the IP, or to show that none exists. In this paper we focus on the special case of finding a cluster constraint cutting plane for an LP solution x\u2217, or showing none exists. We call this the weak separation problem. We call it the \u2018weak\u2019 separation problem since cluster constraints are not the only possible cutting planes.\nIn gobnilp, this problem is solved via a sub-IP, as described earlier e.g. by Bartlett and Cussens (2015). Given an LP solution x\u2217 to separate, the variables of the sub-IP include binary variables yi\u2190J for each family such that x \u2217 i\u2190J > 0. In addition, binary variables yi for each i \u2208 V are created. The constraints of the sub-IP are such that yi = 1 indicates that i is a member of some cluster whose associated cluster constraint is a cutting plane for x\u2217. yi\u2190J = 1 indicates that the family variable xi\u2190J appears in the cluster constraint. The sub-IP is given by\nMaximise \u2211\ni,J : x\u2217i\u2190J>0\nx\u2217i\u2190J \u00b7 yi\u2190J \u2212 \u2211 i\u2208V yi (9)\nsubject to yi\u2190J \u21d2 yi \u2200yi\u2190J (10) yi\u2190J \u21d2 \u2228 j\u2208J\nyj \u2200yi\u2190J (11)\u2211 i,J : x\u2217i\u2190J>0 x\u2217i\u2190J \u00b7 yi\u2190J \u2212 \u2211 i\u2208V yi > \u22121 (12)\nyi\u2190J , yi \u2208 {0, 1} (13)\nThe sub-IP constraints (10\u201311) are displayed as propositional clauses for brevity, but note that these are linear constraints. They can be written as (1 \u2212 yi\u2190J) + yi \u2265 1 and (1 \u2212 yi\u2190J) + \u2211 j\u2208J yj \u2265 1, respectively. The constraint (12) dictates that only solutions\nwith objective value strictly greater than -1 are allowed. In the gobnilp implementation this constraint is effected by directly placing a lower bound on the objective rather than posting the linear constraint (12), since the former is more efficient.\nIt is not difficult to show\u2014Bartlett and Cussens (2015) provide the detail\u2014that any feasible solution to sub-IP (9\u201313) determines a cutting plane for x\u2217 and that a proof of the sub-IP\u2019s infeasibility establishes that there is no such cutting plane. Since gobnilp spends much of its time solving sub-IPs in the hunt for cluster constraint cutting planes, the issue of whether there is a better approach is important. Is it really a good idea to set up a sub-IP each time a cutting plane is sought? Is there some algorithm (perhaps a polynomial-time one) that can be directly implemented to provide a faster search for cutting planes? In Section 5 we make progress towards answering these questions. We show that the weak separation problem is NP-hard and so (assuming P 6= NP) there is no polynomial-time algorithm for weak separation."}, {"heading": "4. Three Polytopes related to the BNSL IP", "text": "As explained in Section 3.2, in the basic gobnilp algorithm one (i) first uses only the convexity constraints and then (ii) adds cluster constraints and (iii) if necessary, branches on variables to solve the IP. These three stages correspond to three different polytopes which will be defined and analyzed in Sections 4.2\u20134.4. Before providing this analysis we first give essential background on linear inequalities, polytopes and polyhedra (Conforti et al., 2014)."}, {"heading": "4.1 Linear inequalities, polytopes and polyhedra", "text": "Definition 3. A point x \u2208 Rn is a convex combination of points in S \u2286 Rn if there exists a finite set of points x1, . . . , xp \u2208 S and scalars \u03bb1, . . . , \u03bbp such that\nx = p\u2211 j=1 \u03bbjx j ,\np\u2211 j=1 \u03bbj = 1, \u03bb1, . . . , \u03bbp \u2265 0.\nDefinition 4. The convex hull conv(S) of a set S \u2286 Rn is the inclusion-wise minimal convex set containing S. Equivalently conv(S) = {x \u2208 Rn | x is a convex combination of points in S}.\nDefinition 5. A subset P of Rn is a polyhedron if there exists a positive integer m, an m\u00d7 n matrix A and a vector b \u2208 Rm such that\nP = {x \u2208 Rn | Ax \u2264 b}.\nDefinition 6. A subset Q of Rn is a polytope if Q is the convex hull of a finite set of vectors in Rn.\nTheorem 7 (Minkowski-Weyl Theorem for Polytopes). A subset Q of Rn is a polytope if and only if Q is a bounded polyhedron.\nWhat the Minkowski-Weyl Theorem for Polytopes states is that a polytope can either be described as the convex hull of a finite set of points or as the set of feasible solutions to some linear program. It follows that, for a given linear objective, an optimal point can be\nfound by solving the linear program. This is a superficially attractive prospect since linear programs can be solved in polynomial time.\nUnfortunately, for NP-hard problems (such as BNSL) it is impractical to create, let alone solve, the linear program due to the size of A and b. Fully characterising the inequalities Ax \u2264 b is also typically difficult. However, it is useful to identify at least some of these inequalities. These inequalities define facets of the polytope. A facet is a special kind of face defined as follows.\nDefinition 8. A face of a polyhedron P \u2286 Rn is a set of the form\nF := P \u2229 {x \u2208 Rn | cx = \u03b4},\nwhere cx \u2264 \u03b4 is a valid inequality for P , i.e., all points in P satisfy it. We say the inequality cx \u2264 \u03b4 defines the face. A face is proper if it is non-empty and properly contained in P . An inclusion-wise maximal proper face of P is called a facet.\nFacets are important since they are given by the \u2018strongest\u2019 inequalities defining a polyhedron: the set of all facet-defining inequalities of a polyhedron provides a minimal representation Ax \u2264 b of that polyhedron. It follows that (typically) facet-defining inequalities are the best inequalities to add as cutting planes, and so identifying them is of crucial importance for the computational efficiency of an IP approach.\nA face of an n-dimensional polytope is a facet if and only if it has dimension n\u2212 1. To prove that a face F has dimension n\u2212 1 it is enough to find n affinely independent points in F . Affine independence is defined as follows (Wolsey, 1998).\nDefinition 9. The points x1, . . . xk \u2208 Rn are affinely independent if the k\u22121 directions x2\u2212 x1, . . . , xk \u2212 x1 are linearly independent, or alternatively the k vectors (x1, 1), . . . (xk, 1) \u2208 Rn+1 are linearly independent. (Note that if x1, . . . xk \u2208 Rn are linearly independent they are also affinely independent.)\nHaving provided these basic definitions we now move on to consider three polytopes of increasing complexity: the digraph polytope (Section 4.2), the cluster polytope (Section 4.3) and finally, our main object of interest, the family variable polytope (Section 4.4)."}, {"heading": "4.2 The Digraph Polytope", "text": "The digraph polytope is simply the convex hull of all digraphs permitted by P. Before providing a formal account of this polytope we define some notation. For a given set of nodes V and permitted parent sets P(i), recall from Section 2.3 that the set of families is defined as\nF(V,P) := {i\u2190 J | i \u2208 V, J \u2208 P(i)}.\nFurthermore, we notate the set of families that remain once the empty parent set for each vertex is removed by\nF(V,P) := F(V,P) \\ {i\u2190 \u2205 | i \u2208 V }.\nIn this and subsequent sections F(V,P) and will serve as an index set. We will abbreviate F(V,P) and F(V,P) to F and F unless it is necessary or useful to identify the node set V and permitted parent sets P(i).\nFor any edge set A \u2286 V \u00d7 V , it is clear that any 0-1 vector in RA corresponds to a (possibly cyclic) subgraph of D = (V,A). However, there are many 0-1 vectors in RF (or RF) which do not correspond to digraphs, namely those where xi\u2190J = xi\u2190J \u2032 = 1 for some i \u2190 J, i \u2190 J \u2032 \u2208 F with J 6= J \u2032. So clearly inequalities other than simple variable bounds are required to define the digraph polytope.\nSince any digraph (cyclic or acyclic) satisfies the |V | convexity constraints (2), the digraph polytope if expressed using the variables in F will not be full-dimensional\u2014the dimension of the polytope will be less than the number of variables. This is inconvenient since only full-dimensional polytopes have a unique minimal description in terms of their facets.\nTo arrive at a full-dimensional polytope we remove the |V | family variables with empty parent sets and define the digraph polytope using index set F(V,P). Let PG(V,P) be the digraph polytope which is the convex hull of all points in RF(V,P) that correspond to digraphs (cyclic and acyclic).\nPG(V,P) :=conv { x \u2208 RF(V,P) \u2223\u2223\u2223 \u2203B \u2286 V \u00d7 V s.t. (14) Pa(i, B) \u2208 P(i) \u2200i \u2208 V and xi\u2190J = 1(J = Pa(i, B)) \u2200J \u2208 P(i) \\ \u2205 } .\nWe will abbreviate PG(V,P) to PG where this will not cause confusion.\nProposition 10. PG is full-dimensional.\nProof. The digraph with no edges is represented by the zero vector in RF. Each vector in RF with only one component xi\u2190J set to 1 and all others set to 0 represents an acyclic digraph (denoted ei\u2190J) and so is in PG. These vectors together with the zero vector are clearly a set of |F|+ 1 affinely independent vectors from which it follows that PG is full-dimensional in RF.\nPG is a simple polytope: it is easy to identify all its facets.\nProposition 11. The facet-defining inequalities of PG are\n1. \u2200i\u2190 J \u2208 F : xi\u2190J \u2265 0 (variable lower bounds), and 2. \u2200i \u2208 V : \u2211\ni\u2190J\u2208F(V,P) xi\u2190J \u2264 1 (\u2018modified\u2019 convexity constraints).\nProof. We use Wolsey\u2019s third approach to establishing that a set of linear inequalities define a convex hull (Wolsey, 1998, p.145). Let c \u2208 RF be an arbitrary objective coefficient vector. It is clear that the linear program maximising cx subject to the given linear inequalities has an optimal solution which is an integer vector representing a digraph: simply choose a \u2018best\u2019 parent set for each i \u2208 V . (If all coefficients are non-positive choose the empty parent set.) Moreover for any digraph x, it easy to see that there is a c such that x is an optimal solution to the LP. It is also easy to see that each of the given linear inequalities is necessary\u2014removing any one of them results in a different polytope. The result follows.\nProposition 11 establishes the unsurprising fact that the polytope defined by gobnilp\u2019s initial constraints is PG(V,P), the convex hull of all digraphs permitted by P. It follows that we will have x\u2217 \u2208 PG for any LP solution x\u2217 produced by gobnilp after adding cutting planes."}, {"heading": "4.3 The Cluster Polytope", "text": "Although gobnilp only adds those cluster constraints which are needed to separate LP solutions x\u2217, it is useful to consider the polytope which would be produced if all were added. The cluster polytope PCLUSTER(V,P) is defined by adding all cluster constraints to the facet-defining inequalities of the digraph polytope PG(V,P), thus ruling out (family variable encodings of) cyclic digraphs.\nPCLUSTER(V,P) := { x \u2208 RF(V,P) \u2223\u2223\u2223 xi\u2190J \u2265 0 \u2200i\u2190 J \u2208 F(V,P), and\u2211 i\u2190J\u2208F(V,P) xi\u2190J \u2264 1 \u2200i, and\n\u2211 i\u2208C \u2211 J\u2208P(i):J\u2229C 6=\u2205 xi\u2190J \u2264 |C| \u2212 1 \u2200C \u2286 V, |C| > 1 } .\nWe will abbreviate PCLUSTER(V,P) to PCLUSTER where this will not cause confusion.\nProposition 12. PCLUSTER is full-dimensional.\nProof. Proof is essentially the same as that for Proposition 10.\nNote that, as with the digraph polytope, we use the index set F to ensure full-dimensionality, and consequently have to use formulation (4) for cluster constraints. Clearly PCLUSTER \u2286 PG (and the inclusion is proper if |V | > 1). Since gobnilp only adds some cluster constraints, the feasible set for each LP that is solved during its cutting plane phase is a polytope P where PCLUSTER \u2286 P \u2286 PG. More important is the connection between PCLUSTER and the family variable polytope which we now introduce."}, {"heading": "4.4 The Family Variable Polytope", "text": "The family variable polytope PF(V,P) is the convex hull of acyclic digraphs with node set V which are permitted by P. To define PF(V,P) it is first useful to introduce notation for the set of acyclic subgraphs of some digraph. Let D = (V,A) be a digraph, and\nA(D) := {B \u2286 A | B is acyclic in D}. (15)\nNow consider the case where D = (V, V \u00d7 V ). The family variable polytope PF(V,P) is\nPF(V,P) := conv { x \u2208 RF(V,P) \u2223\u2223\u2223 \u2203B \u2208 A(D) s.t. Pa(i, B) \u2208 P(i) \u2200i \u2208 V and (16) xi\u2190J = 1(J = Pa(i, B)) \u2200J \u2208 P(i) \\ \u2205 } .\nWe will abbreviate PF(V,P) to PF where this will not cause confusion.\nProposition 13. PF is full-dimensional.\nProof. Proof is essentially the same as that for Proposition 10.\nIt is clear that PF \u2286 PCLUSTER \u2286 PG. We will see in Section 6 that although cluster constraints turn out to be facet-defining inequalities of PF, they are not the only facetdefining inequalities, and so (if |V | > 2) PF ( PCLUSTER. We do, however, have that Z|F| \u2229PF = Z|F| \u2229PCLUSTER, since acyclic digraphs are the only zero-one vectors to satisfy all cluster and modified convexity constraints. These facts have important consequences for the IP approach to BNSL. They show that (i) cluster constraints are a good way of ruling out cycles (since they are facet-defining inequalities of PF) and that (ii) one can solve a BNSL by just using cluster constraints and branching on variables (to enforce an integral solution). That PF ( PCLUSTER also implies that it may be worth searching for facetdefining cuts which are not cluster inequalities, for example those discovered by Studeny\u0301 (2015)."}, {"heading": "5. Computational Complexity of the BNSL Sub-IPs", "text": "In this section we focus on the computational complexity of the BNSL sub-IPs, formalized as the weak separation problem for BNSL. As the main result of this section, we show that this problem is NP-hard.\nThe weak separation problem for BNSL is as follows: given a x\u2217 \u2208 PG find a separating cluster C \u2286 V , |C| > 1, for which\u2211\ni\u2208C \u2211 J\u2208P(i):J\u2229C 6=\u2205 x\u2217i\u2190J > |C| \u2212 1, (17)\nor establish that no such C exists. We first give a simple necessary condition on separating clusters.\nDefinition 14. Given x\u2217 \u2208 PG define dDe(x\u2217), the rounding-up digraph for x\u2217, as follows: i\u2190 j is an edge in dDe(x\u2217) iff there is a family i\u2190 J such that j \u2208 J and x\u2217i\u2190J > 0.\nProposition 15. If C is a separating cluster for x\u2217 then dDe(x\u2217)C , the subgraph of the rounding-up digraph restricted to the nodes C, is cyclic.\nProof. Since x\u2217 \u2208 PG, x\u2217 is a convex combination of extreme points of PG. So we can write x\u2217 = \u2211K k=1 \u03b1kx k where each xk represents a graph and \u2211K k=1 \u03b1k = 1. For each graph x k, let xkC be the subgraph restricted to the nodes C. It is easy to see that if x k C is acyclic,\nthen \u2211 i\u2208C \u2211 J\u2208P(i):J\u2229C 6=\u2205 x k Ci\u2190J\n\u2264 |C| \u2212 1. So if xkC is acyclic for all k = 1, . . . ,K, then\u2211 i\u2208C \u2211 J\u2208P(i):J\u2229C 6=\u2205 x \u2217 Ci\u2190J\n\u2264 |C| \u2212 1. But if dDe(x\u2217)C is acyclic, then so are all the xkC . The result follows.\nProposition 15 leads to a heuristic algorithm for the weak separation problem (which is available as an option in gobnilp). Given an LP solution x\u2217, the rounding up digraph dDe(x\u2217) is constructed and cycles in that digraph are searched for using standard techniques. For each cycle found, the corresponding cluster is checked to see whether it is a separating cluster for x\u2217. We now consider the central result on weak separation.\nTheorem 16. The weak separation problem for BNSL is NP-hard, even when restricted to instances (V,P, c) where J \u2208 P(i) for all i \u2208 V only if |J | \u2264 2.\nProof. We prove the claim by reduction from vertex cover; that is, given a graph G = (V,E) and an integer k, we construct x\u2217 \u2208 PG(V \u2032,P \u2032) over a vertex set V \u2032 and permitted parent sets P \u2032 such that there is a cluster C \u2286 V \u2032 with |C| > 1 and\u2211\ni\u2208C \u2211 J\u2208P \u2032(i):J\u2229C 6=\u2205 x\u2217i\u2190J > |C| \u2212 1\nif and only if there is a vertex cover of size at most k for G. Specifically, let us denote n = |V | and m = |E|. We construct x\u2217 \u2208 PG(V \u2032,P \u2032) as follows.\n1. The vertex set is V \u2032 = V \u222a S, where S is disjoint from V and |S| = m.\n2. For s \u2208 S and {u, v} \u2208 E, we set x\u2217s\u2190{u,v} = 1/m; in particular, \u2211 {u,v}\u2208E x \u2217 s\u2190{u,v} = 1\nfor all s \u2208 S.\n3. For s \u2208 S and v \u2208 V , we set\nx\u2217v\u2190{s} = k\nm(k + 1) .\n4. x\u2217i\u2190\u2205 = 0 for all i \u2208 V \u2032.\n5. For all other choices of i \u2208 V \u2032 and J \u2286 V \u2032 \\ {i}: J 6\u2208 P(i).\nFinally, for a cluster C \u2286 V \u2032, we define the score w(C) as\nw(C) = \u2211 i\u2208C \u2211 J\u2208P \u2032(i):J\u2229C 6=\u2205 x\u2217i\u2190J \u2212 |C| .\nNow we claim that there is a set C \u2286 V \u2032 with w(C) > \u22121 if and only if G has a vertex cover of size at most k; this suffices to prove the claim.\nFirst, we observe that if U \u2286 V is a vertex cover in G, then\nw(U \u222a S) = \u2212|U |+ \u2211 v\u2208U \u2211 s\u2208S xv\u2190{s} \u2212 |S|+ \u2211 s\u2208S \u2211 e\u2208E 1 m\n= \u2212|U |+ |U | mk m(k + 1) \u2212 |S|+ |S|m m\n= \u2212|U | (\n1\u2212 k k + 1\n) = \u2212 |U |\nk + 1 ,\nwhich implies that w(U \u222a S) > \u22121 if |U | \u2264 k. Now let C \u2286 V \u2032, and let us denote CV = C \u2229 V and CS = C \u2229 S. If |CV | \u2265 k + 1, then we have\nw(C) \u2264 \u2212|CV |+ |CV | |CS |k\nm(k + 1)\n\u2264 \u2212|CV |+ |CV | k\nk + 1 = \u2212|CV | (\n1\u2212 k k + 1 ) = |CV | k + 1 \u2264 \u22121 .\nOn the other hand, let us consider the case where |CV | \u2264 k but CV is not a vertex cover for G; we may assume that CV 6= \u2205, as otherwise we would have w(C) = \u2212|C| \u2264 \u22121. Let us write H = {e \u2208 E | CV \u2229 e 6= \u2205} for the set of edges covered by CV . Since we assume that CV is not a vertex cover, we have |H| \u2264 m\u2212 1. Thus, it holds that\nw(C) = \u2212|CV |+ |CV | |CS |k\nm(k + 1) \u2212 |CS |+ |CS | |H| m\n\u2264 \u2212|CV |+ |CV | |CS |k\nm(k + 1) \u2212 |CS |+ |CS | m\u2212 1 m\n= \u2212|CV | (\n1\u2212 |CS |k m(k + 1)\n) \u2212 |CS |\nm \u2264 \u2212 (\n1\u2212 |CS |k m(k + 1)\n) \u2212 |CS |\nm = \u22121\u2212 |CS | ( 1 m \u2212 k m(k + 1) ) = \u22121\u2212 |CS | m(k + 1) < \u22121 .\nThus, if CV is not a vertex cover of size at most k, then w(C) \u2264 \u22121."}, {"heading": "6. Facets of the Family Variable Polytope", "text": "In this section a number of facets of the family variable polytope are identified and certain properties of facets are given. Section 6.1 provides simpler results, and Sections 6.2\u20136.4 more substantial ones, including a tight connection between facets and cluster constraints, liftings of facets, and the influence of restricting parent sets on facets. In Appendix A we provide a complete enumeration of the facet-defining inequalities over 2\u20134 nodes and confirm the enumeration is consistent with the theoretical results presented here."}, {"heading": "6.1 Simple Results on Facets", "text": "We start by showing that the full-dimensional family variable polytope PF is monotone via a series of lemmas. Once we have proved this result, we will use it to establish elementary properties of facets of PF and find the simple facets of the polytope.\nDefinition 17. A nonempty polyhedron P \u2286 Rn\u22650 is monotone if x \u2208 P and 0 \u2264 y \u2264 x imply y \u2208 P .\nLemma 18. Let x \u2208 PF and let the vector y be such that yi\u2032\u2190J \u2032 = 0 for some i\u2032 \u2190 J \u2032 and yi\u2190J = xi\u2190J if i\u2190 J 6= i\u2032 \u2190 J \u2032. Then y \u2208 PF.\nProof. Since x \u2208 PF, x = \u2211 \u03b1kx\nk where each xk is an extreme point of PF corresponding to an acyclic digraph. For each xk define the vector yk where yki\u2032\u2190J \u2032 = 0 and all other components of yk are equal to those of xk. Each yk is also an extreme point corresponding to an acyclic digraph (a subgraph of xk). We clearly have that y = \u2211 \u03b1ky k and so y \u2208 PF.\nLemma 19. Let x \u2208 PF and let y be any vector such that yi\u2032\u2190J \u2032 \u2264 xi\u2032\u2190J \u2032 for some i\u2032 \u2190 J \u2032 and yi\u2190J = xi\u2190J if i\u2190 J 6= i\u2032 \u2190 J \u2032. Then y \u2208 PF.\nProof. This is immediate from Lemma 18.\nProposition 20. PF(V ) is monotone.\nProof. Suppose x \u2208 PF and 0 \u2264 y \u2264 x. Construct a sequence of vectors x = y0, y1, . . . , yk, . . . , y|F| = y by replacing each component xi\u2190J by yi\u2190J one at a time (in any order). By Lemma 19 each yk \u2208 PF, so y \u2208 PF.\nHammer et al. (1975) showed that a polytope is monotone if and only if it can be described by a system x \u2265 0, Ax \u2264 b with A, b \u2265 0. This provides the following result for PF.\nTheorem 21. Each facet-defining inequality of PF(V ) is either (i) a lower bound (of zero) on a family variable, or (ii) an inequality of the form \u03c0x \u2264 \u03c00, where \u03c0 \u2265 0 and \u03c00 > 0.\nProof. From Proposition 20 and the result of Hammer et al. (1975) we have the result but with \u03c00 \u2265 0. That \u03c00 > 0 follows directly by full-dimensionality.\nProposition 22. The following hold.\n1. xi\u2190J \u2265 0 defines a facet of PF(V,P) for all families i\u2190 J \u2208 F(V,P).\n2. For all i \u2208 V , if J \u2032 \u2208 P(i\u2032) implies \u2203J 6= \u2205 \u2208 P(i) for all other i\u2032 \u2208 V , where i 6\u2208 J \u2032 or i\u2032 6\u2208 J , then \u2211 J 6=\u2205,J\u2208P(i) xi\u2190J \u2264 1 defines a facet of PF(V,P).\nProof. (1) follows from the monotonicity of PF(V,P) (Hammer et al., 1975, Proposition 2). For (2) first define, for any i\u2190 J \u2208 F(V,P) the unit vector ei\u2190J \u2208 RF(V,P), where ei\u2190Ji\u2190J = 1 and all other components of ei\u2190J are 0. For each i \u2208 V define Si = {ei\u2190J | J 6= \u2205, J \u2208 P(i)} \u222a {ei\u2032\u2190J \u2032 + ei\u2190J | i\u2032 6= i, J \u2032 6= \u2205, J \u2032 \u2208 P(i\u2032), J 6= \u2205, and either i 6\u2208 J \u2032 or i\u2032 6\u2208 J}.\nThere is an obvious bijection between family variables and the elements of Si so |Si| = |F(V,P)|. It is easy to see that the vectors in Si are linearly independent (and thus affinely independent) and that each is an acyclic digraph satisfying \u2211 J 6=\u2205,J\u2208P(i) xi\u2190J = 1. The result follows.\nRecall that we use the name modified convexity constraints to describe inequalities of the form \u2211 J 6=\u2205,J\u2208P(i) xi\u2190J \u2264 1. That each node can have exactly one parent set in any digraph is a convexity constraint. If we remove the empty parent set, this convexity constraint becomes an inequality, and is thus modified. We have now shown that each modified convexity constraint is a facet of PF(V,P) as long as a weak condition is met. In fact, we have found this weak condition to be essentially always met in practice. Note also that it is always met when all parent sets are allowed (as long as |V | > 2).\nWe now show that if \u03c0x \u2264 \u03c00 defines a facet of the family-variable polytope, then, for each family, there is an acyclic digraph \u2018containing\u2019 that family for which the facet is \u2018tight\u2019.\nProposition 23. If \u03c0x \u2264 \u03c00 is a facet of PF which is not a lower bound on a family variable, then for all families i \u2190 J \u2208 F, there exists an extreme point x of PF such that xi\u2190J = 1 and \u03c0x = \u03c00.\nProof. Recall that by definition each extreme point of PF is a zero-one vector (representing an acyclic digraph). Now suppose that there were some i\u2190 J \u2208 F such that xi\u2190J = 0 for any extreme point x of PF such that \u03c0x = \u03c00. Since \u03c0x \u2264 \u03c00 is a facet, there is a set of |F| affinely independent extreme points satisfying \u03c0x = \u03c00. By our assumption, each such extreme point will also satisfy xi\u2190J = 0. xi\u2190J \u2265 0 is a facet. However, it is not possible for a set of |F| affinely independent points to lie on two distinct facets. The result follows.\nProposition 23 helps us prove an important property of facets of PF: coefficients are non-decreasing as parent sets increase. The proof of the following proposition rests on the simple fact that removing edges from an acyclic digraph always results in another acyclic digraph.\nProposition 24. Let \u03c0x \u2264 \u03c00 be a facet of PF. Then J \u2286 J \u2032 \u21d2 \u03c0i\u2190J \u2264 \u03c0i\u2190J \u2032.\nProof. Since \u03c0x \u2264 \u03c00 is a facet, there exists an extreme point x\u2032 such that x\u2032i\u2190J \u2032 = 1 and \u03c0x\u2032 = \u03c00. Note that x \u2032 i\u2190J = 0. Since x\n\u2032 is an extreme point, it encodes an acyclic digraph. Let x be identical to x\u2032 except that xi\u2190J = 1 and xi\u2190J \u2032 = 0. Since J \u2286 J \u2032, x also encodes an acyclic digraph and so is in PF so \u03c0x \u2264 \u03c00. Thus \u03c0x\u2212 \u03c0x\u2032 \u2264 0. However, \u03c0x\u2212 \u03c0x\u2032 = \u03c0i\u2190J \u2212 \u03c0i\u2190J \u2032 , and the result follows."}, {"heading": "6.2 Cluster Constraints are Facets of the Family Variable Polytope", "text": "In this section we show that each \u03ba-cluster inequality is facet-defining for the family variable polytope in the special case where the cluster C is the entire node set V and where all parent sets are allowed for each vertex. The \u03ba-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are \u03ba-cluster inequalities for the special case of \u03ba = 1.\nIn the next section (Section 6.3) we will show how to \u2018lift\u2019 facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all \u03ba-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed.\nAn alternative proof for the fact that \u03ba-cluster inequalities are facet-defining was recently provided by Cussens et al. (2015) (see Corollary 4 of that paper). The proof establishes not only that \u03ba-cluster inequalities are facet-defining, but also that they are score-equivalent. A face of the family variable polytope is said to be score-equivalent if it is the optimal face for some score equivalent objective. An objective function is score equivalent if it gives the same value to any two acyclic digraphs which are Markov equivalent (encode the same conditional independence relations). In later work, Studeny\u0301 (2015) went further and showed that \u03ba-cluster inequalities form just part of a more general class of facet-defining inequalities which can be defined in terms of connected matroids. However, we believe that our proof, as presented in the following, is valuable since it relies only on a direct application of a standard technique for proving that an inequality is facet-defining, and does not require any connection to be made to score-equivalence, let alone matroid theory. In addition, the general result (our Theorem 29) further shows how our results on \u2018lifting\u2019 can be usefully applied.\nFirst we define \u03ba-cluster inequalities. There is a \u03ba-cluster inequality for each cluster C \u2286 V , |C| > 1 and each \u03ba < |C| which states that there can be at most |C| \u2212 \u03ba nodes in C with at least \u03ba parents in C. It is clear that such inequalities are at least valid, since all acyclic digraphs clearly satisfy them. We begin by considering the special case of C = V where the \u03ba-cluster inequality states that there can be at most |V | \u2212 \u03ba nodes with at least \u03ba parents. We first introduce some helpful notation.\nDefinition 25. PV is defined as follows: PV (i) := 2V \\{i}, for all i \u2208 V .\nWe will now show that \u03ba-cluster inequalities are facet-defining.\nTheorem 26. Recall that PV (i) := 2V \\{i} for all i \u2208 V . For any positive integer \u03ba < |V |, the following valid inequality defines a facet of the family variable polytope PF(V,PV ):\u2211\ni\u2208V \u2211 J\u2286V \\{i},|J |\u2265\u03ba xi\u2190J \u2264 |V | \u2212 \u03ba. (18)\nProof. An indirect method of establishing affine independence is used. It is given, for example, by Wolsey (1998, p.144). Let x1, . . . xt be the set of all acyclic digraphs in PF(V,PV ) satisfying \u2211\ni\u2208V \u2211 J\u2286V \\{i},|J |\u2265\u03ba xi\u2190J = |V | \u2212 \u03ba. (19)\nSuppose that all these points lie on some generic hyperplane \u00b5x = \u00b50. Now consider the system of linear equations\u2211\ni\u2208V \u2211 J 6=\u2205,J\u2286V \\{i} \u00b5i\u2190Jx \u03b9 i\u2190J = \u00b50 for \u03b9 = 1, . . . t. (20)\nNote that dim PF(V,PV ) = |F(V,PV )| = |V |(2|V |\u22121\u2212 1) and so there are the same number of \u00b5i\u2190J variables. The system (20), in the |V |(2|V |\u22121 \u2212 1) + 1 unknowns (\u00b5, \u00b50), is now solved. This is done in three stages. First we show that \u00b5i\u2190J must be zero if |J | < \u03ba. Then we show that the remaining \u00b5i\u2190J must all have the same value. Finally, we show that this common value is 1 whenever \u00b50 is |V | \u2212 \u03ba.\nTo do this it is useful to consider acyclic tournaments on V . These are acyclic digraphs where there is a directed edge between each pair of distinct nodes. It is easy to see that\n1. for any \u03ba < |V |, every acyclic tournament on V satisfies (19), and that\n2. for any xi\u2190J there is an acyclic tournament, where xi\u2190J = 1.\nLet x be an acyclic tournament on V with xi\u2190J = 1 for some i \u2208 V , |J | < \u03ba, i.e., J is the non-empty parent set for i in x. Now consider x\u2032 which is identical to x except that i has no parents, so that x \u2212 x\u2032 = ei\u2190J . Since x is an acyclic tournament it satisfies (19). But it is also easy to see that x\u2032 satisfies (19), since no parent set of size at least \u03ba has been removed. So \u00b5i\u2190J = \u00b5e\ni\u2190J = \u00b5(x \u2212 x\u2032) = \u00b5x \u2212 \u00b5x\u2032 = \u00b50 \u2212 \u00b50 = 0. \u00b5i\u2190J = 0 whenever |J | < \u03ba. Call this Result 1.\nConsider now two distinct parent sets J and J \u2032 for some i \u2208 V where J \u2265 \u03ba and J \u2032 \u2265 \u03ba. Let g be an acyclic tournament on the node set V \\ {i}. Let x be the acyclic digraph on\nnode set V obtained by adding {i} to g and drawing edges from each member of J to i. Similarly, let x\u2032 be the acyclic digraph obtained by drawing edges from J \u2032 to i instead, so that x \u2212 x\u2032 = ei\u2190J \u2212 ei\u2190J \u2032 . It is not difficult to see that both x and x\u2032 satisfy (19). So \u00b5i\u2190J \u2212 \u00b5i\u2190J \u2032 = \u00b5(ei\u2190J \u2212 ei\u2190J \u2032 ) = \u00b5(x\u2212 x\u2032) = \u00b5x\u2212 \u00b5x\u2032 = \u00b50 \u2212 \u00b50 = 0. So \u00b5i\u2190J = \u00b5i\u2190J \u2032 . Call this Result 2. Now consider variables xi\u2190J and xi\u2032\u2190J \u2032 where i 6= i\u2032, J \u222a {i} = J \u2032 \u222a {i\u2032} and |J | = |J \u2032| = \u03ba. First note that in an acyclic tournament, (i) there is exactly one parent set of each size 0, . . . , \u03ba, . . . |V | \u2212 1 and so (ii) the nodes of an acyclic tournament can be totally ordered according to parent set size, and thus (iii) any total ordering of nodes determines a unique acyclic tournament. Let x be any acyclic tournament where xi\u2190J = 1 and xi\u2032\u2190J(<\u03ba) = 1 for some parent set J\n(<\u03ba) where |J (<\u03ba)| < \u03ba. Clearly there are many such acyclic tournaments. Note that since x is an acyclic tournament, J (<\u03ba) \u2286 J \\ {i, i\u2032}. Now consider the acyclic tournament x\u2032 produced by swapping i and i\u2032 in the total order associated with x. This generates an acyclic tournament x\u2032 where x\u2032i\u2032\u2190J \u2032 = 1 and x \u2032 i\u2190J(<\u03ba) = 1. Note that components of x and x\u2032 corresponding to family variables with parent set size strictly above \u03ba are equal. Components of \u00b5 corresponding to family variables with parent set size strictly below \u03ba all equal zero. From this we have that \u00b5x \u2212 \u00b5x\u2032 = \u00b5i\u2190J \u2212 \u00b5i\u2190J \u2032 . Since \u00b5x\u2212 \u00b5x\u2032 = \u00b50 \u2212 \u00b50 = 0, this shows that \u00b5i\u2190J = \u00b5i\u2032\u2190J \u2032 Call this Result 3.\nNow consider a pair of variables \u00b5i\u2190J \u2032\u2032 and \u00b5i\u2032\u2190J \u2032\u2032\u2032 where i 6= i\u2032, and the only restriction is that |J \u2032\u2032|, |J \u2032\u2032\u2032| \u2265 \u03ba. If some other pair of variables \u00b5i\u2190J and \u00b5i\u2032\u2190J \u2032 meet the conditions of Result 3, then \u00b5i\u2190J = \u00b5i\u2032\u2190J \u2032 . However, by Result 2 \u00b5i\u2190J \u2032\u2032 = \u00b5i\u2190J and \u00b5i\u2032\u2190J \u2032\u2032\u2032 = \u00b5i\u2032\u2190J \u2032 . Thus \u00b5i\u2190J \u2032\u2032 = \u00b5i\u2032\u2190J \u2032\u2032\u2032 .\nSo by the transitivity of equality \u00b5i\u2190J = \u00b5i\u2032\u2190J \u2032 for any i, i \u2032, J, J \u2032 where |J | \u2265 \u03ba, |J \u2032| \u2265 \u03ba. Recall that we also have that \u00b5i\u2190J = 0 whenever |J | < \u03ba. Suppose that \u00b50 = 0. since all non-zero \u00b5i\u2190J are equal and thus have the same sign, the only possible solution is for all \u00b5i\u2190J = 0. Suppose then instead that \u00b50 6= 0. Then wlog we can set \u00b50 = |V | \u2212 \u03ba. In each of the t equations (20), after substituting \u00b5i\u2190J = 0 for |J | < \u03ba, we have |V | \u2212 \u03ba terms on the left hand side (LHS) which are known to be equal. On the right hand side (RHS) the value is |V | \u2212\u03ba, so all terms on the LHS must equal one. Each term \u00b5i\u2190J where |J | \u2265 \u03ba, occurs in at least one of t equations (20), so this is enough to establish that \u00b5i\u2190J = 1 whenever |J | \u2265 \u03ba. Thus, unless all \u00b5i\u2190J = 0, the only possible solution to the system of linear equations (20) with RHS |V | \u2212 \u03ba is \u2022 \u00b5i\u2190J = 0 if |J | < \u03ba, and\n\u2022 \u00b5i\u2190J = 1 if |J | \u2265 \u03ba. These values match those in (19) and so (18) is facet-defining."}, {"heading": "6.3 Lifting Facets of the Family Variable Polytope", "text": "In this section we show that if all parent sets are allowed, then facet-defining inequalities for the family variable polytope for some node set V can be \u2018lifted\u2019 to provide facets for any family variable polytope for an enlarged node set V \u2032 ) V . Lemma 27. Recall that PV (i) := 2V \\{i} for all i \u2208 V . Let\u2211\ni\u2208V \u2211 J\u2208PV (i),J 6=\u2205 \u03b1i\u2190Jxi\u2190J \u2264 \u03b2 (21)\nbe a facet-defining inequality for the family variable polytope PF(V,PV ) which is not a lower bound on a variable. Let V \u2032 = V \u222a {i\u2032} where i\u2032 6\u2208 V . Then\u2211\ni\u2208V \u2211 J\u2208PV (i),J 6=\u2205 \u03b1i\u2190J(xi\u2190J + xi\u2190J\u222a{i\u2032}) \u2264 \u03b2 (22)\nis a facet-defining inequality of PF(V \u2032,PV \u2032). Furthermore, this inequality is not a lower bound on a variable.\nProof. Since (21) is facet-defining, there is a set S0 \u2286 RF(V,PV ) of affinely independent acyclic digraphs, with node set V , lying on its hyperplane. For each acyclic digraph in S0, create an acyclic digraph with node set V \u222a {i\u2032} by adding i\u2032 as an isolated node. Let S1 \u2286 RF(V\n\u2032,PV \u2032 ) be the set of acyclic digraphs so created. Note that all members of S1 lie on the hyperplane for (22). Each vector in S1 corresponds to a vector in S0 with a zero vector of length |F(V \u2032,PV \u2032)|\u2212 |F(V,PV )| concatenated. Since S0 is an affinely independent set, so is S1.\nFor each non-empty subset J \u2286 V , construct an acyclic digraph by adding ei\u2032\u2190J to an arbitrary member of S1. Clearly the end result is an acyclic digraph lying on the hyperplane for (22). Let S2 be the set of all such acyclic digraphs.\nFor each J \u2286 V , i \u2208 V , construct an acyclic digraph by finding an acyclic digraph x \u2208 S1 such that xi\u2190J = 1 and adding an arrow from i\u2032 to i. Note that it is always possible to find an acyclic digraph with xi\u2190J = 1. If this were not the case, then (21) would be a lower bound on xi\u2190J . It is not difficult to see that any such acyclic digraph lies on the hyperplane defined by (22). Let S3 be the set of all such acyclic digraphs.\nLet S = S1 \u222a S2 \u222a S3. S2 and S3 have exactly one acyclic digraph for each component xi\u2190J involving the node i\n\u2032 (either i = i\u2032 or i\u2032 \u2208 J). S1 has an acyclic digraph for each component xi\u2190J not involving i\n\u2032. So |S| = dim PF(F(V \u2032,PV \u2032)) = |F(V \u2032,PV \u2032)|. It remains to be established that the S is a set of affinely independent vectors.\nSuppose \u2211\nxi\u2208S \u03b1ix i = 0 and \u2211 xi\u2208S \u03b1i = 0. Each component xi\u2190J involving i\n\u2032 is set to 1 in exactly one acyclic digraph in S2\u222aS3. Thus \u03b1i = 0 for xi \u2208 S2\u222aS3. So \u2211 xi\u2208S1 \u03b1ix\ni = 0 and \u2211 xi\u2208S1 \u03b1i = 0. The result then follows from the affine independence of the set S1.\nTheorem 28. Recall that PV (i) := 2V \\{i} for all i \u2208 V . Let\u2211 i\u2208V \u2211 J\u2208PV (i),J 6=\u2205 \u03b1i\u2190Jxi\u2190J \u2264 \u03b2 (23)\nbe a facet-defining inequality of the family variable polytope PF(V,PV ) which is not a lower bound on a variable. Let V \u2032 be a node set such that V \u2286 V \u2032. Then\n\u2211 i\u2208V \u2211 J\u2208PV (i),J 6=\u2205 \u03b1i\u2190J  \u2211 J \u2032:J\u2286J \u2032\u2286V \u2032\\{i} xi\u2190J \u2032  \u2264 \u03b2 (24) is facet-defining for PF(V \u2032,PV \u2032) and is not a lower bound on a variable.\nProof. Repeated application of Lemma 27.\nUsing Theorem 28, Theorem 26 can now be \u2018lifted\u2019 to establish that all k-cluster inequalities are facet-defining.\nTheorem 29. Recall that PV (i) := 2V \\{i} for all i \u2208 V . For any C \u2286 V and any positive integer \u03ba < |C|, the valid inequality\u2211\ni\u2208C \u2211 J ||J\u2229C|\u2265\u03ba xi\u2190J \u2264 |C| \u2212 \u03ba (25)\nis facet-defining for the family variable polytope PF(V,PV ).\nProof. By Theorem 26, (25) is facet-defining for the family variable polytope for node set C. By applying Theorem 28 it follows that it also facet-defining for the family variable polytope for any node set V \u2287 C."}, {"heading": "6.4 Facets when Parent Sets are Restricted", "text": "The results in the preceding sections have all been for the special case PV when all possible parent sets are allowed for each node. If some parent sets are ruled out, for example by an upper bound \u03ba on parent set cardinality, then some \u03ba-cluster inequalities and some modified convexity constraints may not be facets.\nTo see this, suppose we had V = {a, b, c}. If all parent sets are allowed, then Theorem 29 shows that this 2-cluster inequality for C = {a, b, c},\nxa\u2190{b,c} + xb\u2190{a,c} + xc\u2190{a,b} \u2264 1, (26)\nis a facet. However, if {a, b} is not allowed as a parent set for c, then the inequality becomes\nxa\u2190{b,c} + xb\u2190{a,c} \u2264 1, (27)\nwhich is not facet-defining since it is dominated by the 1-cluster inequality for C = {a, b},\nxa\u2190{b} + xa\u2190{b,c} + xb\u2190{a} + xb\u2190{a,c} \u2264 1. (28)\nAs another example, suppose {c} were removed from P(a). Then condition 2 of Proposition 22 is no longer met, and the modified convexity constraint for a becomes\nxa\u2190{b} + xa\u2190{b,c} \u2264 1, (29)\nwhich cannot be facet-defining since it is dominated by the inequality (28). For any P we have that the polytope PF(V,P) is a face of the all-parent-sets-allowed polytope PF(V,PV ) defined by the valid inequality\u2211 i\u2208V \u2211 J\u2208PV (i)\\P(i) xi\u2190J \u2265 0. (30)\nThe issue then is whether it is possible to determine when a facet of PF(V,PV ) is also a facet of this face. The issue of determining the facets of a face is of general interest. As Boyd and Pulleyblank (2009) note \u201cAs it is often technically much simpler to obtain results\nabout facets for a full dimensional polyhedron than one of lower dimension, it would be nice to . . . know under what conditions an inequality inducing a facet of P also induces a facet of a face F of P .\u201d They go on to state that \u201c. . . we know of no reasonable general result of this type\u201d.\nHowever, in the case of the the family variable polytope, there is a strong result which shows that many facets of a family variable polytope PF(V,P) induce facets of a lowerdimensional family variable polytope PF(V, P\u0306) where P\u0306(i) \u2286 P(i) for all i \u2208 V . In particular, this result shows that some facets of the all-parent-sets-allowed polytope PF(V,PV ) are also facets of the polytope that results by limiting the cardinality of parent sets. To establish this result we first prove a lemma.\nLemma 30. Let x \u2208 PF(V,P). Let i \u2208 V and let J, J \u2032 \u2208 P(i) with J ( J \u2032, J 6= \u2205. Define x\u0306 as follows: x\u0306i\u2190J = xi\u2190J +xi\u2190J \u2032, x\u0306i\u2190J \u2032 = 0, and x and x\u0306 are equal in all other components. Then x\u0306 is also in the family-variable polytope PF(V,P).\nProof. Since x \u2208 PF(V,P), x = \u2211K k=1 \u03b1kx k where each xk is an extreme point of PF(V,P) corresponding to an acyclic digraph. For each xk define x\u0306k as follows: x\u0306ki\u2190J = x k i\u2190J +x k i\u2190J \u2032 , x\u0306ki\u2190J \u2032 = 0 and x k and x\u0306k are equal in all other components. It is clear that each x\u0306 k corresponds to an acyclic digraph which differs from xk iff J \u2032 is the parent set for i in xk, in which case J becomes the parent set for i in x\u0306k. The digraph remains acyclic since J ( J \u2032. It is also clear that x\u0306 = \u2211K k=1 \u03b1kx\u0306 k and so x\u0306 \u2208 PF(V,P).\nThe main result of this section now follows. Our proof makes use of the elementary but useful fact that the number of linearly independent rows in a matrix (row rank) and the number of linearly independent columns in a matrix (column rank) are equal.\nTheorem 31. Let \u03c0x \u2264 \u03c00 define a facet for the family-variable polytope PF(V,P). Suppose that \u03c0i\u2190J = \u03c0i\u2190J \u2032 for some i \u2208 V , J, J \u2032 \u2208 P(i) with J ( J \u2032, J 6= \u2205. Let \u03c0\u0306 be \u03c0 with the component \u03c0i\u2190J \u2032 removed. Let P\u0306 be identical to P except that J \u2032 is removed from P(i). Then \u03c0\u0306x \u2264 \u03c00 defines a facet for the polytope PF(V, P\u0306).\nProof. Since \u03c0x \u2264 \u03c00 is a facet for PF(V,P) it is obvious by Theorem 21 that \u03c0\u0306x \u2264 \u03c00 is at least a valid inequality for PF(V, P\u0306). We now show that this valid inequality defines a facet by proving the existence of |F(V, P\u0306)| affinely independent points lying in the facet.\nRecall that F(V,P) is the set of families determined by vertices V and allowed parent sets P. Abbreviate |F(V,P)| to m and note that |F(V, P\u0306)| = m\u2212 1. Since \u03c0x \u2264 \u03c00 defines a facet for the family-variable polytope PF(V,P), there are m affinely independent points x1, . . . , xk, . . . , xm lying in this facet (i.e., \u03c0xk = \u03c00, x\nk \u2208 PF(V,P) for k = 1, . . . ,m). Since these points are affinely independent, the points (x1, 1), . . . , (xk, 1), . . . , (xm, 1) in Rm+1 are linearly independent.\nLet A1 be the m \u00d7 (m + 1) matrix whose rows are the (xk, 1). Since the rows are linearly independent, A1 has rank m. Construct a new matrix A2 by adding the column for family i \u2190 J \u2032 to that for i \u2190 J . Since this is an elementary operation it does not change the rank of the matrix (Cohn, 1982), and so A2 has rank m. Now construct an m \u00d7 m matrix A3 by removing the column for i \u2190 J \u2032 from A2. Denote the rows of A3 by (x\u03061, 1), . . . , (x\u0306k, 1), . . . , (x\u0306m, 1). From Lemma 30 it follows that each x\u0306k is in PF(V, P\u0306). Since \u03c0i\u2190J = \u03c0i\u2190J \u2032 , it is not difficult to see that each x\u0306 k satisfies \u03c0\u0306x = \u03c00. Since A2\nhas rank m, there are m linearly independent columns in A2 and, since A3 is A2 with one column removed, at least m \u2212 1 linearly independent columns in A3. So A3 has rank of at least m \u2212 1. But this means that there are m \u2212 1 linearly independent rows in A3, so there are m \u2212 1 points among the x\u0306k that are affinely independent. So there are m \u2212 1 affinely independent points in PF(V, P\u0306) satisfying \u03c0\u0306x = \u03c00 and thus \u03c0\u0306x \u2264 \u03c00 defines a facet of PF(V, P\u0306).\nGiven a facet-defining inequality of an all-parent-sets-allowed polytope PF(V,PV ) and a parent set cardinality limit \u03ba, Theorem 31 states that if the coefficients for all family variables xi\u2190J \u2032 with |J \u2032| > \u03ba are not strictly larger than the coefficient for some family variable xi\u2190J with J ( J \u2032 so that |J | \u2264 \u03ba, then the inequality also defines a facet for the polytope with family variables restricted by \u03ba. In Appendix A this is confirmed for the case where |V | = 4 and \u03ba = 2. It follows that a normal (k = 1) cluster constraint is a facet for any limit \u03ba on the size of parent sets. This explains why normal cluster constraints are more useful to look for than k-cluster constraints for k > 1. In gobnilp, although the user can ask the system to look for k-cluster constraints up to some defined limit k \u2264 K, the default is to only search for normal (k = 1) cluster constraints since this has been observed to lead to faster solving."}, {"heading": "7. Faces of the Family Variable Polytope defined by Orders and by Sinks", "text": "In this section we analyse faces of the all-parent-sets-allowed family variable polytope defined by total orders and sink nodes, respectively. Faces of a polytope are themselves polytopes, and in this section we establish a complete characterisation of the facets of both types of polytope. Moreover, the faces defined by sink nodes lead to a useful extended representation for the family variable polytope which can be used to relate family variable polytopes for different numbers of nodes."}, {"heading": "7.1 Order-defined Faces", "text": "Let < be some total order on the node set V . An acyclic digraph (V,B) is consistent with < if i \u2190 j \u2208 B \u21d2 j < i, so that parents come before children in the ordering. The valid inequality \u2211 i,J :(\u2203j\u2208J s.t. i<j) xi\u2190J \u2265 0 defines a face of the family variable polytope\nPF(V,<) = { x \u2208 PF(V,PV ) \u2223\u2223\u2223 \u2211 i,J :(\u2203j\u2208J :i<j) xi\u2190J = 0 } . (31)\nIn PF(V,<) each family variable inconsistent with< is set to zero. This is the only restriction on x. So clearly all acyclic digraphs consistent with < lie on the face PF(V,<) and no digraphs inconsistent with < do. It is also clear that any acyclic digraph lies on PF(V,<) for at least one choice of <.\nRemark 32. Abbreviate |V | to p. We have that dim(PF(V,<)) = 2p \u2212 p\u2212 1. If the family variables clamped to zero in PF(V,<) are removed, PF(V,<) is full-dimensional in R2\np\u2212p\u22121. (Recall that dim(PF(V,PV )) = p(2p\u22121 \u2212 1).)\nRemark 33. If x is an extreme point of PF(V,PV ), then x \u2208 \u22c3 < PF(V,<).\nNote that exactly one acyclic tournament lies on PF(V,<) for any choice of <.\nProposition 34. The facet-defining inequalities of the full-dimensional polytope PF(V,< ) \u2286 R2p\u2212p\u22121 are\n1. the variable lower bounds xi\u2190J \u2265 0, and 2. the modified convexity constraints \u2211\nJ\u2286V :J 6=\u2205,j\u2208J\u2192j<i xi\u2190J \u2264 1,\nwhere variables xi\u2190J with j \u2208 J, i < j have been removed.\nProof. Let c \u2208 R2p\u2212p\u22121 be an arbitrary objective coefficient vector. Consider solving the LP with objective c subject to the linear inequalities given above. It is clear that an optimal solution to this LP is obtained by choosing a parent set J for each i \u2208 V such that ci\u2190J is maximal (or choosing none if all ci\u2190J are negative or there are no parent sets available). This is an integer solution. The result follows."}, {"heading": "7.2 Sink-defined Faces", "text": "For some particular j \u2208 V , consider the valid inequality \u2211\ni 6=j,j\u2208J xi\u2190J \u2265 0. This defines a face PF(V, j) of the family variable polytope as\nPF(V, j) := { x \u2208 PF(V,PV ) \u2223\u2223\u2223 \u2211 j\u2208J,i6=j xi\u2190J = 0 } . (32)\nThis face contains all acyclic digraphs for which j is a sink\u2014it has no children. Since every acyclic digraph has at least one sink then each extreme point of the family variable polytope PF(V,PV ) lies on a face PF(V, j) for at least one choice of j.\nRemark 35. Abbreviate |V | to p and recall that dim(PF(V,PV )) = p(2p\u22121\u22121). dim(PF(V, j)) = dim(PF(V \\ {j},PV \\{j})) + 2p\u22121 \u2212 1 = (p \u2212 1)(2p\u22122 \u2212 1) + 2p\u22121 \u2212 1 = (p + 1)2p\u22122 \u2212 p. If the family variables clamped to zero in PF(V, j) are removed, PF(V, j) is full-dimensional in R(p+1)2p\u22122\u2212p.\nRemark 36. Every acyclic digraph contains at least one sink. So if x is an extreme point of PF(V,PV ), then x \u2208 \u22c3 j\u2208V PF(V, j).\nProposition 37. The facet-defining inequalities of the full-dimensional polytope PF(V, j) \u2286 R(p+1)2p\u22122\u2212p are\n1. the facet-defining inequalities of the polytope PF(V \\ {j},PV \\{j}), and 2. the modified convexity constraint for j, namely \u2211\nJ\u2286V \\{j},J 6=\u2205 xj\u2190J \u2264 1.\nProof. Let c \u2208 R(p+1)2p\u22122\u2212p be an arbitrary objective coefficient vector and consider solving the LP with objective c subject to the linear inequalities given above. Since j is constrained to be a sink, an optimal solution in PF(V, j) is obtained by choosing a maximally scoring parent set for j and then an optimal acyclic digraph for V \\{j}. Since we have all the facets of the polytope PF(V \\ {j}), the optimal acyclic digraph for V \\ {j} is a maximal solution to the LP restricted to the relevant variables. So the full LP has an integer solution. The result follows."}, {"heading": "7.3 A Sink-based Extended Representation for the Family Variable Polytope", "text": "Since PF(V, j) \u2286 PF(V,PV ), for each j \u2208 V we have \u22c3 j\u2208V PF(V, j) \u2286 PF(V,PV ) and\nso conv (\u22c3 j\u2208V PF(V, j) ) \u2286 conv (PF(V,PV )) = PF(V,PV ). However, as noted in Re-\nmark 36, if x is an extreme point of PF(V,PV ), then x \u2208 \u22c3 j\u2208V PF(V, j), so PF(V,PV ) \u2286\nconv (\u22c3 j\u2208V PF(V, j) ) , and thus PF(V,PV ) = conv (\u22c3 j\u2208V PF(V, j) ) . Since there are only |V | = p sink-defined faces, this leads to a compact extended representation for the family variable polytope PF(V,PV ) in terms of the polytopes PF(V, j)j\u2208V . Since by Proposition 37 each PF(V, j) can be defined using PF(V \\ {j}), this allows PF(V,PV ) to be defined by the PF(V \\ {j},PV \\{j}). In Appendix B we detail how this is done for the specific case of |V | = 4; here we describe the method for the general case.\nA union of polytopes can be modelled by introducing additional variables. We follow the (standard) approach described by Conforti et al. (2014, \u00a72.11). For each j \u2208 V , we introduce a binary variable xj and add the constraint\u2211\nj\u2208V xj = 1, (33)\nwhere xj indicates that node j is a distinguished sink. The constraint states that in each acyclic digraph we can choose exactly one sink as the distinguished sink for that digraph.\nNext, for each j \u2208 V , i\u2190 J \u2208 F(V,PV ), we introduce a new variable xj,i\u2190J indicating that i has J as its (non-empty) parent set and that j is the distinguished sink. In other words xj,i\u2190J = xjxi\u2190J . We add the following constraints linking the xj,i\u2190J to the original xi\u2190J :\nxi\u2190J = \u2211 j\u2208V xj,i\u2190J . (34)\nDenote the vector of xj,i\u2190J components for some j as x j . Then for each j \u2208 V and each facet \u03c0x \u2264 \u03c00 of PF(V, j) we add the constraint\n\u03c0jxj \u2264 \u03c00xj , (35)\nwhere \u03c0jj,i\u2190J = \u03c0i\u2190J , and also the variable bounds\n0 \u2264 xj,i\u2190J \u2264 xj . (36)\nEquations and inequalities (33\u201336) define \u22c3 j\u2208V PF(V, j). To formulate PF(V,PV ) =\nconv (\u22c3 j\u2208V PF(V, j) ) , it suffices to merely drop the integrality condition on the xj variables, thus allowing PF(V,PV ) to be defined in terms of the lower-dimensional PF(V, j)."}, {"heading": "8. Relating BNSL and the Acyclic Subgraph Problem", "text": "As the final contribution of this article, we establish a tight connection between BNSL and the acyclic subgraph problem."}, {"heading": "8.1 BSNL as the Acyclic Subgraph Problem", "text": "BNSL is closely related to the well-known acyclic subgraph problem (ASP) (Gro\u0308tschel et al., 1985). An instance of ASP is defined by digraph D = (V,A) with edge weights c(i\u2190 j) \u2208 R for every edge i \u2190 j \u2208 A, and the goal is to find an acyclic subdigraph D\u2032 = (V,B) of D which maximises \u2211\ni\u2190j\u2208B c(i\u2190 j). (37)\nIn ASP, the objective function is a linear function of (indicators for) the edges of some digraph; in BNSL, by contrast, the aim is to maximise an objective which is a linear function of (indicators for) sets of edges. As a Bayesian network structure learning instance can consist of up to \u2126(2n) input values, it is presumably in general not possible to encode a BNSL instance as a ASP instance over the same node set as the original BNSL instance, as this would require in the worst case encoding an exponential number of parent set scores into a quadratic number of edge weights. However, we will next show that we can construct a BNSL-to-ASP reduction by introducing new nodes to represent all possible parent sets of the original instances (V,P, c), similarly as in Theorem 2.\nTheorem 38. Given BNSL instance (V1,P, c), we can construct an ASP instance D = (V,A) such that\n1. |V | = O ( |V1|+ |F(V1,P)| ) , and\n2. there is one-to-one correspondence between the optimal solutions of D and (V1,P, c). Moreover, given (V1,P, c), the instance D can be constructed in time poly ( |V1|+|F(V1,P)| ) .\nProof. Define the digraph D = (V,A) where V = V1 \u222a V2 \u222a V3 and\n\u2022 V2 = {J \u2286 V1 | J \u2208 P(i) for some i \u2208 V1},\n\u2022 V3 = {i\u2190 J | i \u2208 V, J \u2208 P(i)}.\nSee Figure 2 for an example node set where V1 is on the top row, V2 the middle one and V3 the bottom row.\nThe edge set for D is the disjoint union of four (colour-coded) edge sets A = A1 \u222aA2 \u222a A3 \u222aA4 where\n\u2022 A1 = {(i, J) | i \u2208 V1, J \u2208 V2, i \u2208 J} (blue),\n\u2022 A2 = {(i\u2190 J, i) | i\u2190 J \u2208 V3, i \u2208 V1} (black),\n\u2022 A3 = {(J, i\u2190 J) | J \u2208 V2, i\u2190 J \u2208 V3} (red), and\n\u2022 A4 = {i\u2190 J, J \u2032) | i\u2190 J \u2208 V3, J \u2032 \u2208 V2, i 6\u2208 J \u2032, J 6= J \u2032} (green).\nThese four edge sets are coloured correspondingly in the example of Figure 2. Define an ASP instance for D = (V,A) where each (red) edge in A3 (J, i \u2190 J) has weight ci\u2190J ; we will assume that the scores c(i \u2190 J) are strictly positive for all feasible parent sets choices, as adding the same value to each score will not change the optimal\nstructures. All other edges receive a weight sufficiently big to ensure that they are included in any optimal acyclic edge set. For example, giving each such edge a weight equal to a sum of all ci\u2190J weights plus 1 will suffice.\nNote that (V,A\\A3) is acyclic. Recall also the objective coefficients of the ASP instance have been chosen to ensure that A \\ A3 \u2286 B for any optimal edge set B in D. Intuitively, we will thus only care about how the optimal solution looks on the edge set A3, and use this information to recover a solution to the original BSNL instance.\nLet (V,B) be an optimal solution to ASP instance D and define a digraph (V1, B \u2032) as follows: B\u2032 = {i \u2190 j | j \u2208 J and (J, i \u2190 J) \u2208 B}. We will show (i) there is exactly one edge of form (J, i \u2190 J) \u2208 A3 for each i \u2208 V1, (ii) the graph (V1, B\u2032) graph is acyclic and (iii) that it is an optimal solution to the given BNSL instance (V1,P, c).\n(i) Suppose that (J, i \u2190 J) and (J \u2032, i \u2190 J \u2032) were both in B for some i \u2208 V1 and J, J \u2032 \u2208 V2, J 6= J \u2032. This is not possible because the edges (i \u2190 J, J \u2032) and (i \u2190 J \u2032, J) are both in A4 and thus in B. Having (J, i \u2190 J) and (J \u2032, i \u2190 J \u2032) both in B would cause a cycle (i\u2190 J)\u2192 J \u2192 (i\u2190 J \u2032)\u2192 J \u2192 (i\u2190 J) in B, and so is impossible.\n(ii) For any i, j, J with i 6= j, j \u2208 J , there exist the following edges: the blue edge (j, J) \u2208 A1 and the black edge (i \u2190 J, i) \u2208 A2. Note that both of these edges will be in B. If the red edge (J, i \u2190 J) \u2208 A3 is also in B then we have the following path in B: j \u2192 J \u2192 (i\u2190 J)\u2192 i. So if j is a parent of i in B\u2032, then there is a path from j to i in B. So if there were a cycle i1 \u2192 i2 . . . in \u2192 i1 in B\u2032 there would be a cycle from i1 to i1 in B. Since B is acyclic this is a contradiction and so B\u2032 must also be acyclic.\n(iii) We first show that any feasible solution G to the BNSL instance (V1,P, c) corresponds to a feasible solution to the ASP instance D = (V,A). This feasible solution to D = (V,A) consists of the edges A1 \u222a A2 \u222a A4 together with those red edges in A3 corresponding to the parent set choices for G. We need to show that this edge set\u2014call it B(G)\u2014is acyclic in D = (V,A). Since G is acyclic there is a total order <V1 on the nodes V1 such that parents always come before children in this order. We show that <V1 determines a total order <V on the nodes V such that parents always come before children in B(G) which establishes that B(G) is acyclic.\nTo aid understanding we first do this for the case where V1 = {a, b, c} and G is such that a <V1 b <V1 c. The general result is established later. In the special case all red edges (in A3) which are inconsistent with <V1 will be absent from B(G). In particular, since a is allowed no parents, the red edges going to the nodes a\u2190 {b}, a\u2190 {c}, and a\u2190 {b, c} will be absent. This means that these nodes are source nodes in B(G), so put these as the first 3 elements of the order <V . Since a \u2208 V1 has only these 3 nodes as parents, put a as the 4th element in <V . Since the only parent for {a} is a, put {a} as the 5th element. Since c cannot be a parent of b, the red arrows going to b\u2190 {c} and b\u2190 {a, c} are absent from B(G), so these nodes are sources in B(G). Also the only arrow going to b \u2190 {a} is from {a} which is already in the order. This allows us to put b\u2190 {a}, b\u2190 {c} and b\u2190 {a, c} as the next elements in <V . Having done this b can be placed next, and then {b} and {a, b}. The final placements are c \u2190 {a}, c \u2190 {b} and c \u2190 {a, b}, then c and then the remaining nodes {c}, {a, c}, {b, c} and {a, b, c}.\nIn the general case, suppose we have G with a consistent ordering of its nodes i1 <V1 i2 \u00b7 \u00b7 \u00b7 <Vn in. We construct a total ordering of the nodes of V consistent with B(G) as follows. Start with the nodes i1 \u2190 J (in any order), and then put i and after that {i}.\nThen for k = 2, . . . , n add nodes as follows: the ik \u2190 J nodes, then ik and then each J such that ik \u2208 J and J \u2286 {i1 . . . ik}. It is not difficult to see that this total order contains all nodes of V and is consistent with B(G), so B(G) is acyclic.\nNow suppose B\u2032 were not an optimal solution to the BNSL instance (V1,P, c). In that case there would be some strictly better solution corresponding to an acyclic graph G for which B(G) would be a feasible solution to the ASP instance D = (V,A) and this solution would be strictly better than B. This is a contradiction since B is an optimal solution and so it follows that B\u2032 is an optimal solution to (V1,P, c).\nNote that, as Mart\u0301\u0131 and Reinelt (2011) show, ASP is equivalent to the linear ordering problem (LOP). This means that pure LOP approaches can be used to solve ASP and thus BNSL."}, {"heading": "8.2 Relating the BNSL and Acyclic Subgraph Problem Polytopes", "text": "There is a polytope naturally associated with any instance of ASP. Let RA be a real vector space where every component of a vector y \u2208 RA is indexed by an edge i\u2190 j \u2208 A. For every edge set B \u2286 A, the incidence vector yB \u2208 RA of B is defined by yBi\u2190j = 1 if i\u2190 j \u2208 B and yBi\u2190j = 0 if i\u2190 j 6\u2208 B. The acyclic subgraph polytope PAC(D) is\nPAC(D) := conv { yB \u2208 RA \u2223\u2223 B \u2208 A(D)}. (38) It is not difficult to see that the all-parent-sets-allowed family variable polytope PF(V,PV )\ncan be projected onto the ASP polytope where the ASP edgeset A = V \u00d7 V . Equivalently, BNSL is an extended formulation of such ASP instances. Since the ASP has been extensively studied it is important to investigate which results on ASP \u2018translate\u2019 to BNSL.\nWe can see that the ASP instance is a projection of the BNSL instance by introducing the edge indicator variables yi\u2190j into BNSL together with the \u2018linking\u2019 equations\nyi\u2190j = \u2211 J :j\u2208J xi\u2190J . (39)\nThe introduction of these variables (dimensions) and equations leaves the family variable polytope unaltered except that it now \u2018lives in\u2019 a higher-dimensional space. \u2018Projecting away\u2019 the xi\u2190J variables from this higher-dimensional family variable polytope then produces the ASP polytope.\nUsing this relationship it is easy to map any ASP instance with edgeset A = V \u00d7V into a BNSL instance: simply set ci\u2190J = \u2211 j\u2208J c(i \u2190 j). A solution to the BNSL instance so produced will be a solution to the original ASP instance with the same objective value. A direct reverse mapping is only possible if there are edge weights such that the local score for each family is the sum of the weights of the edges corresponding to that family.\nProposition 39. If \u03c0y \u2264 \u03c00 is a valid inequality for ASP, then \u03c0\u2032x \u2264 \u03c00 is a valid inequality, where \u03c0\u2032i\u2190J = \u2211 j\u2208J \u03c0i\u2190j .\nProof. Let x\u2217 \u2208 RF represent an acyclic digraph and let y\u2217 \u2208 RA represent the same digraph. We have that \u03c0y\u2217 \u2264 \u03c00. It is obvious that \u03c0y\u2217 = \u03c0\u2032x\u2217. So all acyclic digraphs represented by family variables satisfy \u03c0\u2032x \u2264 \u03c00. The result follows."}, {"heading": "9. Conclusions", "text": "Integer programming, and specifically the IP-based gobnilp system, offers a state-of-theart practical approach to the NP-hard optimization problem of learning optimal Bayesian network structures, BNSL. Thus providing fundamental insights into the IP approach to BNSL is important both from the purely scientific perspective\u2014dealing with a central class of probabilistic graphical models with various applications in AI\u2014and for developing a better understanding of the approach in the hope of further improving the current algorithmic approaches to BNSL. With these motivations, in this work we shed light on various fundamental computational and representational aspects of BNSL. From the practical perspective, many of our main contributions have tight connections to IP cutting planes derived in practice during search for optimal network structures. Specifically, our contributions include for example the following. We showed that the separation problem which in practice yields problem-specific BNSL cutting planes within gobnilp is in fact NP-hard, a previously open problem. We studied the relationship between three key polytopes underlying BNSL. We analyzed the facets of the three polytopes, and established that the so-called cluster constraints giving rise to BNSL cutting planes are in fact facet-defining inequalities of the family-variable polytope central to BNSL. We also provide (in Appendix A) a complete enumeration of facets for low-dimensional family-variable polytopes, connecting with problem-specific cutting planes ruling out all network structures with short cyclic substructures. In summary, the theoretical results presented in this work deepen the current understanding of fundamental aspects of BNSL from various perspectives."}, {"heading": "Acknowledgments", "text": "The authors gratefully acknowledge financial support from: UK Medical Research Council Grant G1002312 (JC, MB); Senior Postdoctoral Fellowship SF/14/008 from KU Leuven (JC); UK NC3RS Grant NC/K001264/1 (JC); Academy of Finland under grants 251170 COIN Centre of Excellence in Computational Inference Research, 276412, and 284591 (MJ); Research Funds of the University of Helsinki (MJ); and Icelandic Research Fund grant 152679-051 (JHK)."}, {"heading": "Appendix A. Enumeration of Facets for Low-dimensional Family", "text": "Variable Polytopes\nIn Section 6 we provided general results on the facets of the family variable polytope. In this section, we provide a complete listing of all facet-defining inequalities (i.e. a minimal description of the convex hull by inequalities) of the family variable polytope PF(V,PV ) for |V | = 2, 3, 4. We will observe that all lower bounds on variables, modified convexity constraints and \u03ba-cluster inequalities are indeed among the facets found, as predicted by our theoretical results. Proposition 24 and the lifting theorem (Theorem 28) are also consistent with the list of facets. In the case of |V | = 4, we also see that there are many facets not given in Section 6. In Section A.4 we enumerate all facet-defining inequalities for |V | = 4, where at most two parents are allowed and observe that the results are consistent with Theorem 31.\nWe use a, b, c, and d to label the nodes. To simplify notation, we abbreviate variables such as xb\u2190{a,c} to xb\u2190ac.\nA.1 Node Set of Size 2\nWhen |V | = 2, there are 3 acyclic digraphs and F(V,PV ) = {a\u2190 {b}, b\u2190 {a}}. There are three facets: the two lower bounds and the 1-cluster constraint xa\u2190b + xb\u2190a \u2264 1.\nA.2 Node Set of Size 3\nWhen |V | = 3, there are 25 acyclic digraphs and\nF(V,PV ) = {a\u2190 {b}, a\u2190 {c}, a\u2190 {b, c}, b\u2190 {a}, b\u2190 {c}, b\u2190 {a, c}, c\u2190 {a}, c\u2190 {b}, c\u2190 {a, b}}.\nUsing the cdd computer program (Fukuda, 2015), we found all the facets of the convex hull of the 25 acyclic digraphs. There are 17 facet-defining inequalities:\n\u2022 9 lower bounds on the 9 xi\u2190J family variables;\n\u2022 3 modified convexity constraints, one for each of a, b, and c;\n\u2022 4 1-cluster constraints, one for each of the clusters {a, b}, {a, c}, {b, c}, and {a, b, c}; and\n\u2022 1 2-cluster constraint for the cluster {a, b, c}.\nA.3 Node Set of Size 4\nWhen |V | = 4, there are 543 acyclic digraphs and\nF(V,PV ) = {a\u2190 {b}, a\u2190 {c}, a\u2190 {d}, a\u2190 {b, c}, a\u2190 {b, d}, a\u2190 {c, d}, a\u2190 {b, c, d}, b\u2190 {a}, b\u2190 {c}, b\u2190 {d}, b\u2190 {a, c}, b\u2190 {a, d}, b\u2190 {c, d}, b\u2190 {a, c, d}, c\u2190 {a}, c\u2190 {b}, c\u2190 {d}, c\u2190 {a, b}, c\u2190 {a, d}, c\u2190 {b, d}, c\u2190 {a, b, d}, d\u2190 {a}, d\u2190 {b}, d\u2190 {c}, d\u2190 {a, b}, d\u2190 {a, c}, d\u2190 {b, c}, d\u2190 {a, b, c}}.\nUsing cdd we discovered that there are 135 facet-defining inequalities of the family variable polytope:\n\u2022 28 lower bounds on the 28 xi\u2190J family variables;\n\u2022 4 modified convexity constraints, one for each of a, b, c, and d;\n\u2022 6 1-cluster constraints for each of the (\n4 2\n) = 6 clusters of size 2;\n\u2022 4 1-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3;\n\u2022 1 1-cluster constraint for the (\n4 4\n) = 1 cluster of size 4;\n\u2022 4 2-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3;\n\u2022 1 2-cluster constraint for the (\n4 4\n) = 1 cluster of size 4;\n\u2022 1 3-cluster constraint for the (\n4 4\n) = 1 cluster of size 4; and\n\u2022 86 other facet-defining inequalities.\nWe now list these 86 other facet-defining inequalities. These 86 inequalities fall into 9 permutation classes, and we give just one member of each of these 9 classes. By symmetry, any permutation of the 4 nodes a, b, c, and d in a facet-defining inequality will produce another facet-defining inequality. Some permutations do not change the inequality. We indicate this, for each permutation class, by showing which nodes can be permuted without changing the facet. For example, the expression ab|cd indicates that either a and b, or c and d, can be swapped without altering the inequality, so that there are 4!/(2\u00d7 2) = 6 distinct inequality in such a permutation class.\nFor each permutation class, we give the (arbitrarily chosen) name for that class that is used by the gobnilp system. The names run from 4B to 4I\u2014there is no permutation class called \u20184A\u2019, since, at one time in gobnilp, this was used to designate \u03ba-cluster inequalities. With the exception of \u20184F\u2019 and \u20184J\u2019 inequalities, if the user wants, gobnilp can search for these facets as cutting planes for a given LP solution. By default only \u20184B\u2019 cutting planes are looked for, since these cutting planes have empirically been found to perform well. Interestingly, 4B facets can be defined in terms of connected matroids, as noted by Studeny\u0301 (2015).\n4B facets ab|cd\nxa\u2190b + xa\u2190bc + xa\u2190bd + xa\u2190cd + xa\u2190bcd\n+xb\u2190a + xb\u2190ac + xb\u2190ad + xb\u2190cd + xb\u2190acd\n+xc\u2190ad + xc\u2190bd + xc\u2190abd +xd\u2190ac + xd\u2190bc + xd\u2190abc \u2264 2 (40)\n6 inequalities\n4C facets a|b|cd\nxa\u2190c + xa\u2190d + xa\u2190bc + xa\u2190bd + xa\u2190cd + xa\u2190bcd\n+xb\u2190cd + xb\u2190acd\n+xc\u2190ab + xc\u2190bd + xc\u2190abd +xd\u2190ab + xd\u2190bc + xd\u2190abc \u2264 2\n12 inequalities\n4D facets a|b|cd\nxa\u2190b + xa\u2190c + xa\u2190d + xa\u2190bc + xa\u2190bd + 2xa\u2190cd + 2xa\u2190bcd\n+xb\u2190a + xb\u2190c + xb\u2190d + xb\u2190ac + xb\u2190ad + xb\u2190cd + xb\u2190acd\n+xc\u2190a + xc\u2190ab + xc\u2190ad + xc\u2190abd +xd\u2190a + xd\u2190ab + xd\u2190ac + xd\u2190abc \u2264 3\n12 inequalities\n4E facets a|bcd\nxa\u2190bc + xa\u2190bd + xa\u2190cd + 2xa\u2190bcd\n+xb\u2190ac + xb\u2190ad + xb\u2190acd\n+xc\u2190ab + xc\u2190ad + xc\u2190abd +xd\u2190ab + xd\u2190ac + xd\u2190abc \u2264 2\n4 inequalities\n4F facets ab|cd\nxa\u2190cd + xa\u2190bcd\n+xb\u2190cd + xb\u2190acd\n+xc\u2190a + xc\u2190b + xc\u2190d + xc\u2190ab + xc\u2190ad + xc\u2190bd + 2xc\u2190abd +xd\u2190a + xd\u2190b + xd\u2190c + xd\u2190ab + xd\u2190ac + xd\u2190bc + 2xd\u2190abc \u2264 3\n6 inequalities\n4G facets a|b|c|d\nxa\u2190cd + xa\u2190bcd\n+xb\u2190c + xb\u2190ac + xb\u2190cd + xb\u2190acd\n+xc\u2190b + xc\u2190d + xc\u2190ab + xc\u2190ad + xc\u2190bd + 2xc\u2190abd +xd\u2190a + xd\u2190b + xd\u2190c + xd\u2190ab + 2xd\u2190ac + xd\u2190bc + 2xd\u2190abc \u2264 3\n24 inequalities\n4H facets a|b|cd\nxa\u2190c + xa\u2190d + xa\u2190bc + xa\u2190bd + xa\u2190cd + 2xa\u2190bcd\n+xb\u2190acd\n+xc\u2190ab + xc\u2190abd +xd\u2190ab + xd\u2190abc \u2264 2\n12 inequalities\n4I facets ab|cd\nxa\u2190c + xa\u2190d + xa\u2190bc + xa\u2190bd + xa\u2190cd + 2xa\u2190bcd\n+xb\u2190c + xb\u2190d + xb\u2190ac + xb\u2190ad + xb\u2190cd + 2xb\u2190acd\n+xc\u2190a + xc\u2190b + xc\u2190d + 2xc\u2190ab + xc\u2190ad + xc\u2190bd + 2xc\u2190abd +xd\u2190a + xd\u2190b + xd\u2190c + 2xd\u2190ab + xd\u2190ac + xd\u2190bc + 2xd\u2190abc \u2264 4\n6 inequalities\n4J facets a|bcd\nxa\u2190b + xa\u2190c + xa\u2190d + 2xa\u2190bc + 2xa\u2190bd + 2xa\u2190cd + 2xa\u2190bcd\n+xb\u2190a + xb\u2190ac + xb\u2190ad + xb\u2190cd + xb\u2190acd\n+xc\u2190a + xc\u2190ab + xc\u2190ad + xc\u2190bd + xc\u2190abd +xd\u2190a + xd\u2190ab + xd\u2190ac + xd\u2190bc + xd\u2190abc \u2264 3\n4 inequalities\nA.4 Node Set of Size 4, Parent Set Size at most 2\nBy Theorem 31, if we have 4 nodes but only allow acyclic digraphs with at most two parents, then the following facet-defining inequalities from Section A.3 (with family variables xa\u2190bcd, xb\u2190acd, xc\u2190abd, and xd\u2190abc removed) should be facet-defining inequalities of the resulting polytope.\n\u2022 24 lower bounds on the 24 xi\u2190J family variables;\n\u2022 4 modified convexity constraints, one for each of a, b, c, and d; \u2022 6 1-cluster constraints for each of the (\n4 2\n) = 6 clusters of size 2;\n\u2022 4 1-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3;\n\u2022 1 1-cluster constraint for the (\n4 4\n) = 1 cluster of size 4;\n\u2022 4 2-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3; and\n\u2022 1 2-cluster constraint for the (\n4 4\n) = 1 cluster of size 4.\nIn addition all facet-defining inequalities of types 4B, 4C, 4D, and 4J should remain facet-defining. There are 6, 12, 12, and 4 of these, respectively. This adds up to a total of 24+4+6+4+1+4+1+6+12+12+4=78 facet-defining inequalities. Using cdd we computed the facet-defining inequalities of the convex hull of the (family-variable encoded) 443 acyclic digraphs with 4 nodes and where each node has at most 2 parents. We found, as expected, that all of these 78 inequalities were included. Moreover, we found that these 78 constitute the complete set of facet-defining inequalities\u2014there are no others."}, {"heading": "Appendix B. Lift-and-Project for Family Variable Polytopes", "text": "In this appendix, we apply a \u2018lift-and-project\u2019 method based on the sink-based extended representation of Section 7.3 to derive a representation of PF({a, b, c, d},P{a,b,c,d}), whose facets are given in Section A.3, in terms of PF({b, c, d},P{b,c,d}), PF({a, c, d},P{a,c,d}), PF({a, b, d},P{a,b,d}) and PF({a, b, c},P{a,b,c}), whose facet-defining inequalities are given in Section A.2. First we have the relevant formulation of (33),\nxa + xb + xc + xd = 1, (41)\nstating that exactly one of the four nodes is the distinguished sink in any acyclic digraph using those four nodes. Recall that xj,i\u2190J indicates that j is the distinguished sink and that J is the parent set for i so that xj,i\u2190J = 0 if j \u2208 J , so that, for example, xb,a\u2190b = 0. With this observation we can write the linking equations (34) as follows.\nxa\u2190b = xa,a\u2190b + xc,a\u2190b + xd,a\u2190b (42)\nxa\u2190c = xa,a\u2190c + xb,a\u2190c + xd,a\u2190c (43)\nxa\u2190d = xa,a\u2190d + xb,a\u2190d + xc,a\u2190d (44)\nxb\u2190a = xb,b\u2190a + xc,b\u2190a + xd,b\u2190a (45)\nxb\u2190c = xa,b\u2190c + xb,b\u2190c + xd,b\u2190c (46)\nxb\u2190d = xa,b\u2190d + xb,b\u2190d + xc,b\u2190d (47)\nxc\u2190a = xb,c\u2190a + xc,c\u2190a + xd,c\u2190a (48)\nxc\u2190b = xa,c\u2190b + xc,c\u2190b + xd,c\u2190b (49)\nxc\u2190d = xa,c\u2190d + xb,c\u2190d + xc,c\u2190d (50)\nxd\u2190a = xb,d\u2190a + xc,d\u2190a + xd,d\u2190a (51)\nxd\u2190b = xa,d\u2190b + xc,d\u2190b + xd,d\u2190b (52)\nxd\u2190c = xa,d\u2190c + xb,d\u2190c + xd,d\u2190d (53)\nxa\u2190bc = xa,a\u2190bc + xd,a\u2190bc (54)\nxa\u2190bd = xa,a\u2190bd + xc,a\u2190bd (55)\nxa\u2190cd = xa,a\u2190cd + xb,a\u2190cd (56)\nxb\u2190ac = xb,b\u2190ac + xd,b\u2190ac (57)\nxb\u2190ad = xb,b\u2190ad + xc,b\u2190ad (58)\nxb\u2190cd = xb,b\u2190cd + xa,b\u2190cd (59)\nxc\u2190ab = xc,c\u2190ab + xd,c\u2190ab (60)\nxc\u2190ad = xb,c\u2190ad + xc,c\u2190ad (61)\nxc\u2190bd = xa,c\u2190bd + xc,c\u2190bd (62)\nxd\u2190ab = xc,d\u2190ab + xd,d\u2190ab (63)\nxd\u2190ac = xb,d\u2190ac + xd,d\u2190ac (64)\nxd\u2190bc = xa,d\u2190bc + xd,d\u2190bc (65)\nxa\u2190bcd = xa,a\u2190bcd (66)\nxb\u2190acd = xb,b\u2190acd (67)\nxc\u2190abd = xc,c\u2190abd (68)\nxd\u2190abc = xd,d\u2190abc (69)\nThirdly we have all equations of type (35). We label all inequalities with xa on the RHS as follows. The modified convexity constraints for a, b, c, and d are labelled a-a, a-b, a-c, and a-d, respectively. All other constraints are cluster constraints which we label as a-C, where C is the cluster and \u03ba = 1, and a-2-C, where C is the cluster and \u03ba = 2. Inequalities with xb, xc, and xd on the RHS are labelled analogously. The 36 inequalities of type (35) are now listed using this labelling convention.\nxa,b\u2190c + xa,b\u2190d + xa,b\u2190cd \u2264 xa (a-b) xa,c\u2190b + xa,c\u2190d + xa,c\u2190bd \u2264 xa (a-c) xa,d\u2190b + xa,d\u2190c + xa,d\u2190cd \u2264 xa (a-d)\nxa,b\u2190c + xa,b\u2190cd + xa,c\u2190b + xa,c\u2190bd \u2264 xa (a-bc) xa,b\u2190d + xa,b\u2190cd + xa,d\u2190b + xa,d\u2190bd \u2264 xa (a-bd) xa,c\u2190d + xa,c\u2190bd + xa,d\u2190c + xa,d\u2190cd \u2264 xa (a-cd)\nxa,b\u2190c + xa,b\u2190d + xa,b\u2190cd + xa,c\u2190b + xa,c\u2190d + xa,c\u2190bd\n+xa,d\u2190b + xa,d\u2190c + xa,d\u2190cb \u2264 2xa (a-bcd) xa,b\u2190cd + xa,c\u2190bd + xa,d\u2190bc \u2264 xa (a-2-bcd)\nxa,a\u2190b + xa,a\u2190c + xa,a\u2190d + xa,a\u2190bc\n+xa,a\u2190bd + xa,a\u2190cd + xa,a\u2190bcd \u2264 xa (a-a)\nxb,a\u2190c + xb,a\u2190c + xb,a\u2190cd \u2264 xb (b-a) xb,c\u2190a + xb,c\u2190d + xb,c\u2190ad \u2264 xb (b-c) xb,d\u2190a + xb,d\u2190c + xb,d\u2190ac \u2264 xb (b-d)\nxb,a\u2190c + xb,a\u2190cd + xb,c\u2190a + xb,c\u2190ad \u2264 xb (b-ac) xb,a\u2190d + xb,a\u2190cd + xb,d\u2190a + xb,d\u2190ac \u2264 xb (b-ad) xb,c\u2190d + xb,c\u2190bd + xb,d\u2190c + xb,d\u2190cd \u2264 xb (b-cd)\nxb,a\u2190c + xb,a\u2190d + xb,a\u2190cd + xb,c\u2190a + xb,c\u2190d + xb,c\u2190ad\n+xb,d\u2190a + xb,d\u2190c + xb,d\u2190ac \u2264 2xb (b-acd) xb,a\u2190cd + xb,c\u2190ad + xb,d\u2190ac \u2264 xb (b-2-acd)\nxb,b\u2190a + xb,b\u2190c + xb,b\u2190d + xb,b\u2190ac\n+xb,b\u2190ad + xb,b\u2190cd + xb,b\u2190acd \u2264 xb (b-b)\nxc,a\u2190b + xc,a\u2190d + xc,a\u2190bd \u2264 xc (c-a) xc,b\u2190a + xc,b\u2190d + xc,b\u2190ad \u2264 xc (c-b) xc,d\u2190a + xc,d\u2190b + xc,d\u2190ab \u2264 xc (c-d)\nxc,a\u2190b + xc,a\u2190bd + xc,b\u2190a + xc,b\u2190ad \u2264 xc (c-ab) xc,a\u2190d + xc,a\u2190bd + xc,d\u2190a + xc,d\u2190ab \u2264 xc (c-ad) xc,b\u2190d + xc,b\u2190ad + xc,d\u2190b + xc,d\u2190ab \u2264 xc (c-bd)\nxc,a\u2190b + xc,a\u2190d + xc,a\u2190bd + xc,b\u2190a + xc,b\u2190d + xc,b\u2190ad\n+xc,d\u2190a + xc,d\u2190b + xc,d\u2190ab \u2264 2xc (c-abd) xc,a\u2190bd + xc,b\u2190ad + xc,d\u2190ab \u2264 xc (c-2-abd)\nxc,c\u2190a + xc,c\u2190b + xc,c\u2190d + xc,c\u2190ab\n+xc,c\u2190ad + xc,c\u2190bd + xc,c\u2190abd \u2264 xc (c-c)\nxd,a\u2190b + xd,a\u2190c + xd,a\u2190bc \u2264 xd (d-a) xd,b\u2190a + xd,b\u2190c + xd,b\u2190ac \u2264 xd (d-b) xd,c\u2190a + xd,c\u2190a + xd,c\u2190ab \u2264 xd (d-c)\nxd,a\u2190b + xd,a\u2190bc + xd,b\u2190a + xd,b\u2190ac \u2264 xd (d-ab) xd,a\u2190c + xd,a\u2190bc + xd,c\u2190a + xd,c\u2190ab \u2264 xd (d-ac) xd,b\u2190c + xd,b\u2190ac + xd,c\u2190b + xd,c\u2190ab \u2264 xd (d-cd)\nxd,a\u2190b + xd,a\u2190c + xd,a\u2190bc + xd,b\u2190a + xd,b\u2190c + xd,b\u2190ac\n+xd,c\u2190a + xd,c\u2190b + xd,c\u2190ab \u2264 2xd (d-abc) xd,a\u2190bc + xd,b\u2190ac + xd,c\u2190ab \u2264 xd (d-2-abd)\nxd,d\u2190a + xd,d\u2190b + xd,d\u2190c + xd,d\u2190ab\n+xd,d\u2190ac + xd,d\u2190bc + xd,d\u2190abc \u2264 xd (d-d)\nUsing (66\u201369) it is possible to eliminate the variables xa,a\u2190bcd, xb,b\u2190acd, xc,c\u2190abd, and xd,d\u2190abc, and (66\u201369) from the representation. This leaves us with a representation of\nPF({a, b, c, d},P{a,b,c,d}) using 4+28+4\u00d7(9+6) = 92 variables, 25 equations, 36 inequalities of type (35), four lower bounds on the variables xj , 56 lower bounds (of 0) on the variables xi,j\u2190J where |J | < 3, and four lower bounds (of 0) on the variables xi\u2190J where |J | = 3. In total we have 100 inequalities.\nWe have given an explicit extended representation of PF({a, b, c, d},P{a,b,c,d}). Here is that representation described more briefly.\n\u2022 xa + xb + xc + xd = 1.\n\u2022 24/2 = 12 unique permutations of xa\u2190b = xa,a\u2190b + xc,a\u2190b + xd,a\u2190b.\n\u2022 24/2 = 12 unique permutations of xa\u2190bc = xa,a\u2190bc + xd,a\u2190bc.\n\u2022 24/2 = 12 unique permutations of xa,b\u2190c + xa,b\u2190d + xa,b\u2190cd \u2264 xa.\n\u2022 24/2 = 12 unique permutations of xa,b\u2190c + xa,b\u2190cd + xa,c\u2190b + xa,c\u2190bd \u2264 xa.\n\u2022 24/6 = 4 unique permutations of xa,b\u2190c+xa,b\u2190d+xa,b\u2190cd+xa,c\u2190b+xa,c\u2190d+xa,c\u2190bd+ xa,d\u2190b + xa,d\u2190c + xa,d\u2190cb \u2264 2xa.\n\u2022 24/6 = 4 unique permutations of xa,b\u2190cd + xa,c\u2190bd + xa,d\u2190bc \u2264 xa.\n\u2022 24/6 = 4 unique permutations of xa,a\u2190b+xa,a\u2190c+xa,a\u2190d+xa,a\u2190bc+xa,a\u2190bd+xa,a\u2190cd+ xa\u2190bcd \u2264 xa.\n\u2022 4 lower bounds on the variables xj .\n\u2022 56 lower bounds on variables xi,j\u2190J where |J | < 3.\n\u2022 4 lower bounds on variables xi\u2190J where |J | = 3.\nThe crucial point is that the convex hull of solutions to our extended representation can be found by simply dropping the integrality restrictions on variables. (See (Conforti et al., 2014, p. 71) for the relevant proof.) If we \u2018project away\u2019 the additional variables from this\nconvex hull we end up with PF(V,PV ) = conv (\u22c3 j\u2208V PF(V, j) ) .\nWe now show explicitly that the facet-defining inequalities of PF({a, b, c, d},P{a,b,c,d}) can be derived by projection from our extended representation. This projection is done by forming linear combinations of extended representation facet-defining inequalities which only contain \u2018normal\u2019 family variables xi\u2190J .\nFor example, consider adding the following inequalities: (a-a), (a-2-bcd), (b-b), (b-2acd), (c-c), (c-ab), (d-d) and (d-ab). Note that the RHS of this inequality is xa + xa + xb +\nxb + xc + xc + xd + xd = 2. So the result is\nxa,a\u2190b + xa,a\u2190c + xa,a\u2190d + xa,a\u2190bc + xa,a\u2190bd + xa,a\u2190cd + xa\u2190bcd\n+xa,b\u2190cd + xa,c\u2190bd + xa,d\u2190bc\n+xb,b\u2190a + xb,b\u2190c + xb,b\u2190d + xb,b\u2190ac + xb,b\u2190ad + xb,b\u2190cd + xb\u2190acd\n+xb,a\u2190cd + xb,c\u2190ad + xb,d\u2190ac\n+xc,c\u2190a + xc,c\u2190b + xc,c\u2190d + xc,c\u2190ab + xc,c\u2190ad + xc,c\u2190bd + xc\u2190abd\n+xc,a\u2190b + xc,a\u2190bd + xc,b\u2190a + xc,b\u2190ad\n+xd,d\u2190a + xd,d\u2190b + xd,d\u2190c + xd,d\u2190ab + xd,d\u2190ac + xd,d\u2190bc + xd\u2190abc +xd,a\u2190b + xd,a\u2190bc + xd,b\u2190a + xd,b\u2190ac \u2264 2.\nUsing (42-65) we can simplify this to\nxa\u2190b + xa,a\u2190c + xa,a\u2190d + xa\u2190bc + xa\u2190bd + xa\u2190cd + xa\u2190bcd\n+xa,b\u2190cd\n+xb\u2190a + xb,b\u2190c + xb,b\u2190d + xb\u2190ac + xb\u2190ad + xb,b\u2190cd + xb\u2190acd\n+\n+xc,c\u2190a + xc,c\u2190b + xc,c\u2190d + xc,c\u2190ab + xc\u2190ad + xc\u2190bd + xc\u2190abd\n+\n+xd,d\u2190a + xd,d\u2190b + xd,d\u2190c + xd,d\u2190ab + xd\u2190ac + xd\u2190bc + xd\u2190abc + \u2264 2. (70)\nThis inequality can then be weakened by adding the lower bounds for the 14 remaining extended variables (thus removing them) which results in the 4B facet (40) of PF({a, b, c, d},P{a,b,c,d}).\nWe now show how each of the facet classes 4B-4J for PF({a, b, c, d},P{a,b,c,d}) listed in Section A.3 can be derived by projection from the extended representation. Projection is achieved by multiplying each facet-defining inequality in the extended representation by a non-negative scalar. Let the vector of these scalars be denoted u \u2265 0. In the following list we only provide positive components of u and do not bother to list those components of u corresponding to variable lower bounds. (Note that since these u vectors generate facetdefining inequalities of PF({a, b, c, d},P{a,b,c,d}), they must be extreme rays of the relevant projection cone (Balas, 2005).)"}, {"heading": "4B facet", "text": "ua\u2212a = 1, ua\u22122\u2212bcd = 1, ub\u2212b = 1, ub\u22122\u2212acd = 1, uc\u2212c = 1, uc\u2212ab = 1, ud\u2212d = 1, ud\u2212ab = 1"}, {"heading": "4C facet", "text": "ua\u2212a = 1, ua\u22122\u2212bcd = 1, ub\u2212b = 1, ub\u2212a = 1, uc\u2212c = 1, uc\u2212ad = 1, ud\u2212d = 1, ud\u2212ac = 1"}, {"heading": "4D facet", "text": "ua\u2212a = 2, ua\u2212b = 1, ub\u2212b = 1, ub\u2212ac = 1, ub\u2212ad = 1, uc\u2212c = 1, uc\u2212abd = 1, ud\u2212d = 1, ud\u2212abc = 1"}, {"heading": "4E facet", "text": "ua\u2212a = 2, ub\u2212b = 1, ub\u22122\u2212acd = 1, uc\u2212c = 1, uc\u22122\u2212abd = 1, ud\u2212d = 1, ud\u22122\u2212abc = 1"}, {"heading": "4F facet", "text": "ua\u2212a = 1, ua\u2212bcd = 1, ub\u2212b = 1, ub\u2212acd = 1, uc\u2212c = 2, uc\u2212d = 1, ud\u2212d = 2, ud\u2212c = 1"}, {"heading": "4G facet", "text": "ua\u2212a = 1, ua\u2212bcd = 1, ub\u2212b = 1, ub\u2212ad = 1, ub\u2212cd = 1, uc\u2212c = 2, uc\u2212d = 1, ud\u2212d = 2, ud\u2212bc = 1"}, {"heading": "4H facet", "text": "ua\u2212a = 2, ub\u2212b = 1, ub\u2212a = 1, uc\u2212c = 1, uc\u2212ad = 1, ud\u2212d = 1, ud\u2212ac = 1"}, {"heading": "4I facet", "text": "ua\u2212a = 2, ua\u2212bcd = 1, ub\u2212b = 2, ub\u2212acd = 1, uc\u2212c = 2, uc\u2212ad = 1, uc\u2212bd = 1, ud\u2212d = 2, ud\u2212ac = 1, ud\u2212bc = 1"}, {"heading": "4J facet", "text": "ua\u2212a = 2, ua\u22122\u2212bcd = 1, ub\u2212b = 1, ub\u2212ac = 1, ub\u2212ad = 1, uc\u2212c = 1, uc\u2212ab = 1, uc\u2212ad = 1, ud\u2212d = 1, ud\u2212ab = 1, ud\u2212ac = 1\nWe have shown how to generate all facets of PF(V,PV ) for |V | = 4 from the |V | = 3 case. This was done by constructing the desired convex hull using an extended representation and then projecting away the extraneous variables. Although in this case we already had the convex hull for |V | = 4 (by direct computation using cdd) it is clear that the same technique could be used to construct the convex hull for |V | = 5 and above. The difficulty with this approach is identifying which projections u \u2265 0 generate facets. It was noted above that we can restrict attention to u which are extreme rays of the relevant projection cone. However, in general, not all extreme rays generate facets, it also necessary that the number of dimensions \u2018lost\u2019 when projecting the entire polytope matches the number lost when projecting the face whose projection is the putative facet (Balas, 2005). We do not investigate this here, leaving this issue for future work."}], "references": [{"title": "Constraint Integer Programming", "author": ["T. Achterberg"], "venue": "Ph.D. thesis, TU Berlin.", "citeRegEx": "Achterberg,? 2007", "shortCiteRegEx": "Achterberg", "year": 2007}, {"title": "Projection, lifting and extended formulation in integer and combinatorial optimization", "author": ["E. Balas"], "venue": "Annals of Operation Research, 140, 125\u2013161.", "citeRegEx": "Balas,? 2005", "shortCiteRegEx": "Balas", "year": 2005}, {"title": "Integer linear programming for the Bayesian network structure learning problem", "author": ["M. Bartlett", "J. Cussens"], "venue": null, "citeRegEx": "Bartlett and Cussens,? \\Q2015\\E", "shortCiteRegEx": "Bartlett and Cussens", "year": 2015}, {"title": "Facet generating techniques", "author": ["S. Boyd", "W.R. Pulleyblank"], "venue": "Research Trends in Combinatorial Optimization, Bonn Workshop on Combinatorial Optimization", "citeRegEx": "Boyd and Pulleyblank,? \\Q2009\\E", "shortCiteRegEx": "Boyd and Pulleyblank", "year": 2009}, {"title": "Learning Bayesian networks is NP-Complete", "author": ["D.M. Chickering"], "venue": "Fisher, D., & Lenz, H.-J. (Eds.), Learning from Data: AI & Statistics V, chap. 12, pp. 121\u2013130. Springer.", "citeRegEx": "Chickering,? 1996", "shortCiteRegEx": "Chickering", "year": 1996}, {"title": "Algebra, Vol", "author": ["P.M. Cohn"], "venue": "1. Wiley.", "citeRegEx": "Cohn,? 1982", "shortCiteRegEx": "Cohn", "year": 1982}, {"title": "Learning highdimensional directed acyclic graphs with latent and selection variables", "author": ["D. Colombo", "M.H. Maathuis", "M. Kalisch", "T.S. Richardson"], "venue": "Annals of Statistics,", "citeRegEx": "Colombo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Colombo et al\\.", "year": 2012}, {"title": "Maximum likelihood pedigree reconstruction using integer programming", "author": ["J. Cussens"], "venue": "Proceedings of the Workshop on Constraint Based Methods for Bioinformatics (WCB-10).", "citeRegEx": "Cussens,? 2010", "shortCiteRegEx": "Cussens", "year": 2010}, {"title": "Bayesian network learning with cutting planes", "author": ["J. Cussens"], "venue": "Cozman, F. G., & Pfeffer, A. (Eds.), Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence (UAI 2011), pp. 153\u2013160. AUAI Press.", "citeRegEx": "Cussens,? 2011", "shortCiteRegEx": "Cussens", "year": 2011}, {"title": "Maximum likelihood pedigree reconstruction using integer linear programming", "author": ["J. Cussens", "M. Bartlett", "E.M. Jones", "N.A. Sheehan"], "venue": "Genetic Epidemiology,", "citeRegEx": "Cussens et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Cussens et al\\.", "year": 2013}, {"title": "Polyhedral aspects of score equivalence in Bayesian network structure learning", "author": ["J. Cussens", "D. Haws", "M. Studen\u00fd"], "venue": "Submitted to Mathematical Programming", "citeRegEx": "Cussens et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Cussens et al\\.", "year": 2015}, {"title": "Efficient structure learning of Bayesian networks using constraints", "author": ["de Campos", "P. Cassio", "Q. Ji"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Campos et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Campos et al\\.", "year": 2011}, {"title": "cdd and ccdplus homepage.. https://www.inf.ethz.ch/personal/ fukudak/cdd_home", "author": ["K. Fukuda"], "venue": null, "citeRegEx": "Fukuda,? \\Q2015\\E", "shortCiteRegEx": "Fukuda", "year": 2015}, {"title": "On the acyclic subgraph polytope", "author": ["M. Gr\u00f6tschel", "M. J\u00fcnger", "G. Reinelt"], "venue": "Mathematical Programming,", "citeRegEx": "Gr\u00f6tschel et al\\.,? \\Q1985\\E", "shortCiteRegEx": "Gr\u00f6tschel et al\\.", "year": 1985}, {"title": "Facets of regular 0-1 polytopes", "author": ["P.L. Hammer", "E. Johnson", "U.N. Peled"], "venue": "Mathematical Programming,", "citeRegEx": "Hammer et al\\.,? \\Q1975\\E", "shortCiteRegEx": "Hammer et al\\.", "year": 1975}, {"title": "Learning discrete Bayesian networks", "author": ["D. Heckerman", "D. Geiger", "D.M. Chickering"], "venue": "Machine Learning,", "citeRegEx": "Heckerman et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Heckerman et al\\.", "year": 1995}, {"title": "Hugin case stories", "author": ["Hugin"], "venue": "http://www.hugin.com/case-stories/.", "citeRegEx": "Hugin,? 2016", "shortCiteRegEx": "Hugin", "year": 2016}, {"title": "Learning Bayesian network structure using LP relaxations", "author": ["T. Jaakkola", "D. Sontag", "A. Globerson", "M. Meila"], "venue": "Proceedings of 13th International Conference on Artificial Intelligence and Statistics (AISTATS 2010),", "citeRegEx": "Jaakkola et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jaakkola et al\\.", "year": 2010}, {"title": "Exact Bayesian structure discovery in Bayesian networks", "author": ["M. Koivisto", "K. Sood"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Koivisto and Sood,? \\Q2004\\E", "shortCiteRegEx": "Koivisto and Sood", "year": 2004}, {"title": "Probabilistic Graphical Models: Principles and Techniques", "author": ["D. Koller", "N. Friedman"], "venue": null, "citeRegEx": "Koller and Friedman,? \\Q2009\\E", "shortCiteRegEx": "Koller and Friedman", "year": 2009}, {"title": "Predicting the hardness of learning Bayesian networks", "author": ["B. Malone", "K. Kangas", "M. J\u00e4rvisalo", "M. Koivisto", "P. Myllym\u00e4ki"], "venue": "Proceedings of the 28th AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "Malone et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Malone et al\\.", "year": 2014}, {"title": "The Linear Ordering Problem: Exact and Heuristic Methods in Combinatorial Optimization", "author": ["R. Mart\u0301\u0131", "G. Reinelt"], "venue": null, "citeRegEx": "Mart\u0301\u0131 and Reinelt,? \\Q2011\\E", "shortCiteRegEx": "Mart\u0301\u0131 and Reinelt", "year": 2011}, {"title": "Exact maximum margin structure learning of Bayesian networks", "author": ["R. Peharz", "F. Pernkopf"], "venue": "In Proceedings of the 29th International Conference on Machine Learning (ICML", "citeRegEx": "Peharz and Pernkopf,? \\Q2012\\E", "shortCiteRegEx": "Peharz and Pernkopf", "year": 2012}, {"title": "Improved maximum likelihood reconstruction of complex multi-generational pedigrees", "author": ["N. Sheehan", "M. Bartlett", "J. Cussens"], "venue": "Theoretical Population Biology,", "citeRegEx": "Sheehan et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sheehan et al\\.", "year": 2014}, {"title": "A simple approach for finding the globally optimal Bayesian network structure", "author": ["T. Silander", "P. Myllym\u00e4ki"], "venue": "In Proceedings of the 22nd Conference on Uncertainty in Artificial Intelligence (UAI", "citeRegEx": "Silander and Myllym\u00e4ki,? \\Q2006\\E", "shortCiteRegEx": "Silander and Myllym\u00e4ki", "year": 2006}, {"title": "Causation, Prediction and Search", "author": ["P. Spirtes", "C. Glymour", "R. Scheines"], "venue": null, "citeRegEx": "Spirtes et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Spirtes et al\\.", "year": 1993}, {"title": "How matroids occur in the context of learning Bayesian network structure", "author": ["M. Studen\u00fd"], "venue": "Meila, M., & Heskes, T. (Eds.), Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence (UAI 2015), pp. 832\u2013841. AUAI Press.", "citeRegEx": "Studen\u00fd,? 2015", "shortCiteRegEx": "Studen\u00fd", "year": 2015}, {"title": "The max-min hill-climbing Bayesian network structure learning algorithm", "author": ["I. Tsamardinos", "L.E. Brown", "C.F. Aliferis"], "venue": "Machine Learning,", "citeRegEx": "Tsamardinos et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Tsamardinos et al\\.", "year": 2006}, {"title": "Machine learning of Bayesian networks using constraint programming", "author": ["P. van Beek", "H. Hoffmann"], "venue": "Proceedings of the 21st International Conference on Principles and Practice of Constraint Programming (CP 2015),", "citeRegEx": "Beek and Hoffmann,? \\Q2015\\E", "shortCiteRegEx": "Beek and Hoffmann", "year": 2015}, {"title": "Integer Programming", "author": ["L.A. Wolsey"], "venue": "John Wiley.", "citeRegEx": "Wolsey,? 1998", "shortCiteRegEx": "Wolsey", "year": 1998}, {"title": "Learning optimal Bayesian networks: A shortest path perspective", "author": ["C. Yuan", "B. Malone"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Yuan and Malone,? \\Q2013\\E", "shortCiteRegEx": "Yuan and Malone", "year": 2013}], "referenceMentions": [{"referenceID": 16, "context": "Bayesian networks (Koller & Friedman, 2009) form a central class of probabilistic graphical models that finds applications in various domains (Hugin, 2016; Sheehan et al., 2014).", "startOffset": 142, "endOffset": 177}, {"referenceID": 23, "context": "Bayesian networks (Koller & Friedman, 2009) form a central class of probabilistic graphical models that finds applications in various domains (Hugin, 2016; Sheehan et al., 2014).", "startOffset": 142, "endOffset": 177}, {"referenceID": 25, "context": "In the constraint-based approach (Spirtes et al., 1993; Colombo et al., 2012) the goal is to learn a network which is consistent with conditional independence relations which have been inferred from the data.", "startOffset": 33, "endOffset": 77}, {"referenceID": 6, "context": "In the constraint-based approach (Spirtes et al., 1993; Colombo et al., 2012) the goal is to learn a network which is consistent with conditional independence relations which have been inferred from the data.", "startOffset": 33, "endOffset": 77}, {"referenceID": 15, "context": "Even when the score function is restricted to be a BDe score (Heckerman et al., 1995), the BNSL problem has been shown to be NP-hard (Chickering, 1996).", "startOffset": 61, "endOffset": 85}, {"referenceID": 4, "context": ", 1995), the BNSL problem has been shown to be NP-hard (Chickering, 1996).", "startOffset": 55, "endOffset": 73}, {"referenceID": 27, "context": "Due to NPhardness, much work on BNSL has focused on developing approximate, local search style algorithms (Tsamardinos et al., 2006) that most often cannot give guarantees on how close to optimal, in terms of the objective function, are the structures found.", "startOffset": 106, "endOffset": 132}, {"referenceID": 8, "context": "Recently, despite its complexity, several advances in exact approaches to BNSL have surfaced (Koivisto & Sood, 2004; Silander & Myllym\u00e4ki, 2006; Cussens, 2011; de Campos & Ji, 2011; Yuan & Malone, 2013; van Beek & Hoffmann, 2015), ranging from problem-specific dynamic programming branch-and-bound algorithms to approaches based on A\u2217-style state-space search, constraint programming, and integer linear programming (IP), which can, with certain restrictions, learn provably-optimal BN structures with tens to hundreds of nodes.", "startOffset": 93, "endOffset": 229}, {"referenceID": 20, "context": "As shown in a recent study (Malone et al., 2014), perhaps the most successful exact approach to BNSL is provided by the gobnilp system (Cussens, 2011).", "startOffset": 27, "endOffset": 48}, {"referenceID": 8, "context": ", 2014), perhaps the most successful exact approach to BNSL is provided by the gobnilp system (Cussens, 2011).", "startOffset": 94, "endOffset": 109}, {"referenceID": 19, "context": "Koller and Friedman (2009). Specifically, in this paper we restrict attention to decomposable score functions, where the score is defined locally by the parent set choices for each i \u2208 V .", "startOffset": 0, "endOffset": 27}, {"referenceID": 4, "context": "Even though BNSL remains NP-hard unless \u03ba = 1 (Chickering, 1996), such results suggest that in practice the value of \u03ba is an important determining factor of the hardness of a BNSL instance.", "startOffset": 46, "endOffset": 64}, {"referenceID": 22, "context": "For example, with \u03ba = 2, Sheehan et al. (2014) were able to solve BNSL instances with |V | = 1614 in between 3 and 42 minutes.", "startOffset": 25, "endOffset": 47}, {"referenceID": 7, "context": "There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013).", "startOffset": 48, "endOffset": 110}, {"referenceID": 9, "context": "There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013).", "startOffset": 48, "endOffset": 110}, {"referenceID": 7, "context": "There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013). In this paper we focus on cluster constraints first introduced by Jaakkola et al. (2010). A cluster is simply a subset of nodes.", "startOffset": 49, "endOffset": 201}, {"referenceID": 2, "context": "The gobnilp approach to solving this IP are fully detailed by Bartlett and Cussens (2015); here we overview the essential ideas.", "startOffset": 62, "endOffset": 90}, {"referenceID": 0, "context": "de) (Achterberg, 2007) and it uses SCIP to generate many other cutting planes in addition to cluster constraints.", "startOffset": 4, "endOffset": 22}, {"referenceID": 2, "context": "by Bartlett and Cussens (2015). Given an LP solution x\u2217 to separate, the variables of the sub-IP include binary variables yi\u2190J for each family such that x \u2217 i\u2190J > 0.", "startOffset": 3, "endOffset": 31}, {"referenceID": 2, "context": "It is not difficult to show\u2014Bartlett and Cussens (2015) provide the detail\u2014that any feasible solution to sub-IP (9\u201313) determines a cutting plane for x\u2217 and that a proof of the sub-IP\u2019s infeasibility establishes that there is no such cutting plane.", "startOffset": 28, "endOffset": 56}, {"referenceID": 29, "context": "Affine independence is defined as follows (Wolsey, 1998).", "startOffset": 42, "endOffset": 56}, {"referenceID": 26, "context": "That PF ( PCLUSTER also implies that it may be worth searching for facetdefining cuts which are not cluster inequalities, for example those discovered by Studen\u00fd (2015).", "startOffset": 154, "endOffset": 169}, {"referenceID": 14, "context": "From Proposition 20 and the result of Hammer et al. (1975) we have the result but with \u03c00 \u2265 0.", "startOffset": 38, "endOffset": 59}, {"referenceID": 8, "context": "The \u03ba-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3).", "startOffset": 27, "endOffset": 42}, {"referenceID": 7, "context": "The \u03ba-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are \u03ba-cluster inequalities for the special case of \u03ba = 1. In the next section (Section 6.3) we will show how to \u2018lift\u2019 facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all \u03ba-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed.", "startOffset": 28, "endOffset": 570}, {"referenceID": 7, "context": "The \u03ba-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are \u03ba-cluster inequalities for the special case of \u03ba = 1. In the next section (Section 6.3) we will show how to \u2018lift\u2019 facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all \u03ba-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed. An alternative proof for the fact that \u03ba-cluster inequalities are facet-defining was recently provided by Cussens et al. (2015) (see Corollary 4 of that paper).", "startOffset": 28, "endOffset": 776}, {"referenceID": 7, "context": "The \u03ba-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are \u03ba-cluster inequalities for the special case of \u03ba = 1. In the next section (Section 6.3) we will show how to \u2018lift\u2019 facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all \u03ba-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed. An alternative proof for the fact that \u03ba-cluster inequalities are facet-defining was recently provided by Cussens et al. (2015) (see Corollary 4 of that paper). The proof establishes not only that \u03ba-cluster inequalities are facet-defining, but also that they are score-equivalent. A face of the family variable polytope is said to be score-equivalent if it is the optimal face for some score equivalent objective. An objective function is score equivalent if it gives the same value to any two acyclic digraphs which are Markov equivalent (encode the same conditional independence relations). In later work, Studen\u00fd (2015) went further and showed that \u03ba-cluster inequalities form just part of a more general class of facet-defining inequalities which can be defined in terms of connected matroids.", "startOffset": 28, "endOffset": 1271}, {"referenceID": 3, "context": "As Boyd and Pulleyblank (2009) note \u201cAs it is often technically much simpler to obtain results", "startOffset": 3, "endOffset": 31}, {"referenceID": 5, "context": "Since this is an elementary operation it does not change the rank of the matrix (Cohn, 1982), and so A2 has rank m.", "startOffset": 80, "endOffset": 92}, {"referenceID": 13, "context": "1 BSNL as the Acyclic Subgraph Problem BNSL is closely related to the well-known acyclic subgraph problem (ASP) (Gr\u00f6tschel et al., 1985).", "startOffset": 112, "endOffset": 136}, {"referenceID": 21, "context": "Note that, as Mart\u0301\u0131 and Reinelt (2011) show, ASP is equivalent to the linear ordering problem (LOP).", "startOffset": 14, "endOffset": 40}], "year": 2016, "abstractText": "The challenging task of learning structures of probabilistic graphical models is an important problem within modern AI research. Recent years have witnessed several major algorithmic advances in structure learning for Bayesian networks\u2014arguably the most central class of graphical models\u2014especially in what is known as the score-based setting. A successful generic approach to optimal Bayesian network structure learning (BNSL), based on integer programming (IP), is implemented in the gobnilp system. Despite the recent algorithmic advances, current understanding of foundational aspects underlying the IP based approach to BNSL is still somewhat lacking. Understanding fundamental aspects of cutting planes and the related separation problem is important not only from a purely theoretical perspective, but also since it holds out the promise of further improving the efficiency of state-of-the-art approaches to solving BNSL exactly. In this paper, we make several theoretical contributions towards these goals: (i) we study the computational complexity of the separation problem, proving that the problem is NP-hard; (ii) we formalise and analyse the relationship between three key polytopes underlying the IP-based approach to BNSL; (iii) we study the facets of the three polytopes both from the theoretical and practical perspective, providing, via exhaustive computation, a complete enumeration of facets for low-dimensional family-variable polytopes; and, furthermore, (iv) we establish a tight connection of the BNSL problem to the acyclic subgraph problem.", "creator": "TeX"}}}