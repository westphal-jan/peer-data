{"id": "1608.08447", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Aug-2016", "title": "BreakID: Static Symmetry Breaking for ASP (System Description)", "abstract": "jean-martin Symmetry breaking saunderson has sown been 60.41 proven contratas to 3:31 be sestriere an liyun efficient preprocessing marginalism technique upperclassman for 81.20 satisfiability chicxulub solving (tamagno SAT ). In this paper, we rowboat port the state - dunkle of - the - art uprecedented SAT ellinwood symmetry breaker BreakID chilling to vechten answer 46.78 set 2-9 programming (ASP ). siv The result 738,000 is a lightweight trifonov tool interrogates that chron can jull be plugged greyson in sch\u00f6nerer between thermedics the grounding pistons and the solving swe phases that janov are partlow common when unti modelling in ASP. dagli We juncker compare hapag our landcare tool shimabukuro with g\u0142\u00f3wny sbass, the dakkak current state - cushwa of - the - calculated art symmetry breaker for azilal ASP.", "histories": [["v1", "Tue, 30 Aug 2016 13:47:41 GMT  (427kb,D)", "http://arxiv.org/abs/1608.08447v1", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"]], "COMMENTS": "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["jo devriendt", "bart bogaerts"], "accepted": false, "id": "1608.08447"}, "pdf": {"name": "1608.08447.pdf", "metadata": {"source": "CRF", "title": "BreakID: Static Symmetry Breaking for ASP (System Description)", "authors": ["Jo Devriendt", "Bart Bogaerts"], "emails": ["firstname.lastname@cs.kuleuven.be"], "sections": [{"heading": "1 Introduction", "text": "Answer set programming (ASP) has always benefited from progress in the satisfiability solving (SAT) community. In fact, many (if not all) modern ASP solvers [16, 4, 11] are based on conflict-driven clause learning (CDCL) [24], a technique first developed for SAT. Some people even go as far as to claim that ASP is just \u201ca good modelling language for SAT\u201d.\nThus, now and then it makes sense to check which developments in SAT can be transferred to ASP. In this paper, we port a recently introduced symmetry breaking preprocessor, BreakID3 [14] to ASP. A first version of BreakID was developed in 2013 [13]. This version won a gold medal on the 2013 SAT competition [7] in combination with the SAT solver Glucose 2.1 [5]. The latest version of BreakID was developed in 2015 [14] and won the gold medal in the no limit track of the 2016 SAT competition [19] in combination with the SAT solver COMiniSatPS [27].\nSymmetry breaking has been around for quite a long time. The most wellknown symmetry breaker for SAT is Shatter [2]. Shatter works by (i) transforming a SAT theory into a colored graph whose automorphisms correspond to symmetries of the theory, (ii) calling a graph automorphism detection tool such as Saucy [21] to obtain a set of generators of the symmetry group, and (iii) adding constraints that break each of the generators returned by the previous step. BreakID is based on the same ideas, but improves the last step of the symmetry breaking process. In particular, the set of symmetry breaking\n3 Pronounced \u201cbreak it\u201d.\nar X\niv :1\n60 8.\n08 44\n7v 1\n[ cs\n.A I]\n3 0\nA ug\n2 constraints is parametrized by both the chosen set of generator symmetries, as well as a chosen order on the set of propositional variables. Good choices for these two parameters strongly influence the breaking power and the size of the resulting constraints [14] . As such, BreakID \u2013 searches for more structure in the symmetry breaking group, essentially de-\ntecting subgroups of the symmetry group that can be broken completely without additional overhead,\n\u2013 reduces the size of symmetry breaking constraints, \u2013 chooses an order on the variables that \u201cmatches\u201d the generators to break, \u2013 actively searches for small (size 2) symmetry breaking clauses.\nThis resulted in significant improvements with respect to Shatter. The techniques from Shatter have been ported to ASP by the ASP symmetry breaker sbass [15]. The main contribution there was to develop an alternative for the first step in the ASP context, i.e., to transform an ASP program P into a colored graph such that graph isomorphisms correspond to symmetries of P.\nIn this paper, we show how to use BreakID as a symmetry breaker for ASP. Our implementation extends (and slightly modifies) the graph encoding used in sbass. The extensions serve to support a richer language: we provide support for so-called weight rules and minimize statements. The modification serves to ensure more effective breaking; we present several simple symmetric examples where BreakID detects the symmetry while sbass does not. For the third step (generating symmetry breaking constraints), we use all of the improvements that are already present in the SAT-version of BreakID [14].\nWe evaluate performance of BreakID and sbass on a number of benchmarks with symmetries and conclude that also in an ASP context, BreakID\u2019s improvements have a significant effect.\nThe rest of this paper is structured as follows. In Section 2 we recall preliminaries regarding answer set programming and symmetries. Afterwards, in Section 3 we present our symmetry breaker for ASP. We evaluate this tool in Section 4 and conclude in Section 5."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Answer Set Programming", "text": "A vocabulary is a set of symbols, also called atoms; vocabularies are denoted by \u03c3, \u03c4 . A literal is an atom or its negation. An interpretation I of the vocabulary \u03a3 is a subset of \u03a3. Propositional formulas and the satisfaction relation between formulas and interpretations are defined as usual. A logic program P over vocabulary \u03a3 is a set of rules r of form\nh1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 hl \u2190 a1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 an \u2227 \u00acb1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acbm, (1)\nwhere hi\u2019s, ai\u2019s, and bi\u2019s are atoms in \u03a3. The formula h1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 hl is called the head of r, denoted head(r), and the formula a1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 an \u2227 \u00acb1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acbm the body of r, denoted body(r). A program is called normal (resp. positive) if l = 1\n3 (resp. m = 0) for all rules in P. If n = m = 0, we simply write h1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 hl. If l = 0, we call r a constraint.\nAn interpretation I is a model of a logic program P if, for all rules r in P, whenever body(r) is satisfied by I, so is head(r). The reduct of P with respect to I, denoted PI , is a positive program that consists of rules h1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 hl \u2190 a1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 an for all rules of the form (1) in P such that bi 6\u2208 I for all i. An interpretation I is a stable model or an answer set of P if it is a \u2286-minimal model of PI [18]. Checking whether a logic program has a stable model is an \u03a3P2 -complete task in general and an NP-complete task for normal programs; hence, logic programs can be used to encode search problems. This observation gave birth to the field of answer set programming [23, 26, 22].\nThis paper sometimes uses syntactic sugar such as choice rules, constraints, cardinality atoms and weight atoms. A cardinality atom\ng \u2264 #{l1, . . . , lf} \u2264 k\n(with l1, . . . , lf being literals and f, g, k \u2208 N) is satisfied by I if\ng \u2264 #{i | I |= li} \u2264 k."}, {"heading": "A weight atom", "text": "g \u2264 sum{l1 = wi, . . . , lf = wf} \u2264 k\n(with l1, . . . , lf being literals and f, g, k, wi \u2208 N) is satisfied if g \u2264 \u2211 {i|I|=li} wi \u2264 k.\nSometimes, the \u201cg \u2264\u201d or \u201c\u2264 k\u201d parts of cardinality or weight atoms are dropped. In this case, the obvious semantics applies: the atom is satisfied for any lower/upper bound. For instance, the cardinality atom\ng \u2264 #{l1, . . . , lf}\nis satisfied whenever g \u2264 #{i | I |= li}.\nA choice rule is a rule with a cardinality atom in the head, i.e., a rule of the form g \u2264 #{l1, . . . , lf} \u2264 k \u2190 a1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 an \u2227 \u00acb1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acbm. I satisfies a constraint c if it does not satisfy body(c). These language constructs can all be translated to normal rules [8]."}, {"heading": "2.2 Symmetry", "text": "Let \u03c0 be a permutation of \u03a3. We extend \u03c0 to literals: \u03c0(\u00aca) = \u00ac(\u03c0(a)), to rules:\n\u03c0(h1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 hl \u2190 a1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 an \u2227 \u00acb1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acbm) = \u03c0(h1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c0(hl)\u2190 \u03c0(a1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c0(an) \u2227 \u00ac\u03c0(b1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00ac\u03c0(bm),\n4 to logic programs: \u03c0(P) = {\u03c0(r) | r \u2208 P}, and to interpretations: \u03c0(I) = {\u03c0(p) | p \u2208 I}. A symmetry of a program P is a permutation \u03c0 of \u03a3 that preserves stable models of P (i.e., \u03c0(I) is a stable model of P if and only if I is a stable model of P). A permutation of atoms for which \u03c0(P) = P is a syntactical symmetry of P.4 Typically, only syntactical symmetry is exploited, since this type of symmetry can be detected with relative ease. The practical techniques presented in this paper are no exception.\nSymmetry breaking aims at eliminating symmetry, either by statically posting a set of constraints that invalidate symmetric interpretations, or by altering the search space dynamically to avoid symmetric search paths. In this paper, we focus on static symmetry breaking. If \u03a0 is a symmetry group, then a set of constraints \u03c8 is sound if for each interpretation I there exists at least one symmetry \u03c0 \u2208 \u03a0 such that \u03c0(I) satisfies \u03c8; \u03c8 is complete if for each assignment \u03b1 there exists at most one symmetry \u03c0 \u2208 \u03a0 such that \u03c0(\u03b1) satisfies \u03c8 [34]."}, {"heading": "2.3 Graph Automorphisms", "text": "A colored graph is a tuple G = (V,E, c), where V is a set, whose elements we call nodes, E is a binary relation on V ; elements of E are called edges and c is a mapping V \u2192 C for some set C. The elements of C are called colors.\nAn automorphism of G is a mapping \u03c0 : V \u2192 V such that the following two conditions hold:\n\u2013 (u, v) \u2208 E if and only if (\u03c0(u), \u03c0(v)) \u2208 E for each u, v \u2208 V , and \u2013 c(v) = c(\u03c0(v)) for each v \u2208 V .\nThe graph automorphism problem is the task of finding all graph automorphisms of a given (colored) graph. The complexity of this problem is conjectured to be strictly in between P and NP [6]. Several tools are available to tackle this problem, including Saucy [21], nauty [25] and bliss [20]."}, {"heading": "3 Symmetry Breaking for ASP", "text": "As mentioned in the introduction, symmetry breaking typically consists of three steps.\n\u2013 First, a colored graph G is created such that the automorphisms of G correspond to symmetries of P. \u2013 Second, a set G of generators of the automorphism group of G is derived. \u2013 Third, a set of symmetry breaking constraints is added to the original prob-\nlem, based on G. As for the second step, any graph automorphism tool can be used. Shatter [2], sbass and BreakID make use of Saucy for this task. We discuss how we tackle the first and last step in the following subsections.\n4 In some texts, the term symmetry is reserved for what we call syntactical symmetry.\n5"}, {"heading": "3.1 Colored Graph Encoding", "text": "As for encoding a logic program as a colored graph, our approach is very close to the one introduced by sbass [15] (we discuss and justify the differences below). We use four colors {1, . . . , 4}; our graph consists of the following nodes: \u2013 For each atom p \u2208 \u03a3, two nodes, referred to as p and \u00acp below. Node p is\ncolored as 1, node \u00acp is colored 2. \u2013 For each rule r \u2208 P, two nodes, referred to as head(r) and body(r) below.\nNode head(r) is colored 3 and node body(r) is colored 4.\nOur graph is undirected and the edges are as follows:\n\u2013 Each node p is connected to \u00acp. \u2013 For each rule r of the form (1) in P, each node hi is connected to head(r),\neach node ai is connected to body(r) and each node \u00acbi is connected to body(r). The complete encoding of this type of rule is illustrated in Figure 1.\nIt can be seen that there is a one-to-one correspondence between automorphisms of this graph and syntactic symmetries of the logic program. Since atoms p are the only nodes colored in color 1, an automorphism induces a permutation of \u03a3. The edge between p and \u00acp guarantee that an automorphism that maps to p to q also maps \u00acp to \u00acq. Furthermore, the edges between head(r), body(r) and the various literals occurring in a rule capture the full structure of the rule. As such, it can be verified that automorphisms of this graph must map rules to \u201csyntactically symmetric\u201d rules. Vice versa, each syntactic symmetry preserves the graph structure defined above.\nAdditionally, we extend this graph encoding to capture more language extensions such as, e.g., choice rules. We only support limited forms of these rules. Actually, our tool supports exactly the Lparse-Smodels intermediate format [31], extended with support for disjuctive rules. This means for instance that in cardinality rules, we assume there is no upper. The general language can easily be transformed to this format (in fact, that is what all modern ASP grounders do). For this, we introduce two new colors, extending the set of colors to {1, . . . , 6}. In programs with these extensions, integer numbers can occur, either as bounds of\n6 cardinality or weight constraint or as weights in a weight constraint or minimize statement (see below). We assume that for each integer n that occurs in such a program, there is a unique color cn 6\u2208 {1, . . . , 6} available and extend our set of colors to\n{1, . . . , 6} \u222a {cn | n occurs as weight or bound in P}.\nCardinality rules Rules of the form\nh\u2190 g \u2264 #{a1, . . . , an,\u00acb1, . . . ,\u00acbm}\nare encoded as follows. The head of the rule is encoded as usual. The body node of the rule is colored in cg, the color associated with the bound g. The body node is connected to each of the ai and \u00acbi and to the head node, as usual.\nChoice rules Rules of the form\n#{h1, . . . , hl} \u2190 a1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 an \u2227 \u00acb1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acbm\nare encoded exactly the same as rules of form (1), except that head(r) is colored 5. This allows to differentiate between standard rules and choice rules.\nWeight rules Rules of the form\nh\u2190 g \u2264 sum{a1 = w1, . . . , an = wn,\u00acb1 = wn+1, . . . ,\u00acbm = wn+m} (2)\nare encoded as follows. The node body(r) is colored as for cardinality rules in cg. For each occurrence of an expression li = wj , we create one additional node, referred to as li = wj . This node is colored in cwj , the color associated to the integer wj and is connected to li. The body of this rule is connected to all the nodes ai = wi and \u00acbi = wn+i. body(r) is connected to head(r) and head(r) to h, as usual. A visualisation of this encoding can be found in Figure 2.\nMinimize statements Minimize statements are expressions of the form\nminimize{a1 = w1, . . . , an = wn,\u00acb1 = wn+1, . . . ,\u00acbm = wn+m} (3)\nThey are directions to the solver that the user is only interested in models such that the term \u2211\n{rules of the form (3) that occur in P } \u2211 {i|I|=li} wi.\nis minimal (among all stable models). Such a statement is encoded analogously to the body of a weight rule, except that the body node is replaced by a minimize node with color 6.\nComparison with sbass Our graph encoding differs from the one used by sbass in two respects.\nFirst of all, we added support for minimize statements and weight rules. As a result, our tool supports the full Lparse-Smodels intermediate language as documented in [31] and additionally, the rule type \u201c8\u201d used by gringo [17] to represent disjunctive rules.\nSecond, we use undirected graphs whereas sbass uses directed graphs. To be precise, when using directed graphs, all head(r) nodes can be dropped by using edges from literals ai and \u00acbi to body(r) and from body(r) to hi (the directionality thus distinguishes between head and body literals). We expect because of this that symmetry detection in BreakID takes slightly more time than symmetry detection in sbass (automorphism algorithms are sensitive to the number of nodes in the input graph). The reason why we did this is that we experimentally noticed that Saucy does not always behave well with directed graphs. On very small examples already, symmetries are missed when using the directional encoding. sbass, which uses Saucy with directed graphs, shows the same kind of behaviour, as we show in the following list of examples. The examples illustrate that BreakID is more stable than sbass with respect to symmetry detection on different encodings.\nExample 1.\nP1 = {\n0 \u2264 #{p} \u2264 1. 0 \u2264 #{q} \u2264 1.\n} .\nIt is clear that p and q are interchangeable in P1. By this we mean that the mapping \u03c3 : {p, q} \u2192 {p, q} : p 7\u2192 q, q 7\u2192 p is a symmetry of P1. BreakID detects this, while sbass detects (and breaks) no symmetry.\n8 Example 2. Consider the logic program\nP2 =  r \u2190 p \u2227 q.0 \u2264 #{p} \u2264 1. 0 \u2264 #{q} \u2264 1.  . It is clear that p and q are interchangeable in P2. In this case, both sbass and BreakID detect (and break) this interchangeability.\nExample 3. Consider the logic program\nP3 = \u2190 p \u2227 q.0 \u2264 #{p} \u2264 1. 0 \u2264 #{q} \u2264 1.  . It is clear that p and q are interchangeable in P3. BreakID detects this, while sbass detects (and breaks) no symmetry.\nExample 4. Consider the logic program\nP4 = p \u2228 q \u2190 p \u2227 q.0 \u2264 #{p} \u2264 1. 0 \u2264 #{q} \u2264 1.  . It is clear that p and q are interchangeable in P4. BreakID detects this, while sbass detects (and breaks) no symmetry.\nExample 5. Consider the logic program P5 = { p. q. } .\nIt is clear that p and q are interchangeable in P4. BreakID detects this, while sbass detects no symmetry.\nIn the last example, the fact that this symmetry is not detected does not have any practical consequences. Indeed, since these are only interchangeable facts, exploiting the symmetry will not help the solver. However, in examples such as Example 1, the difference is more important. If there are interchangeable atoms in choice rules, symmetry breaking can cut out exponentially large parts of the search space."}, {"heading": "3.2 Symmetry Breaking Constraints", "text": "A classic approach to static symmetry breaking is to construct lex-leader constraints.\nDefinition 1 (Lex-leader constraint [9]). Let \u03c6 be a formula over \u03a3, \u03c0 a symmetry of \u03c6, \u227a\u03a3 an order on \u03a3 and \u227a the induced lexicographic order on the set of interpretations over \u03a3. A formula LL\u03c0 over \u03a3\n\u2032 \u2287 \u03a3 is a lex-leader constraint for \u03c0 if for each \u03a3-interpretation I, there exists a \u03a3\u2032-extension of I that satisfies LL\u03c0 iff I \u227a \u03c0(I).\n9 In other words, each interpretation whose symmetric image under \u03c0 is smaller is invalidated by LL\u03c0. It is easy to see that the conjunction of LL\u03c0 for all \u03c0 in some \u03a0 \u2032 \u2286 \u03a0 is a sound (but not necessarily complete) symmetry breaking constraint for \u03a0.\nAn efficient encoding of the lex-leader constraint LL\u03c0 as a conjunction of propositional clauses is given by Aloul et al. [1]. Such clauses translate directly to ASP constraints. In order to make such an encoding, an order on \u03a3 needs to be chosen. The classic approach to symmetry breaking is to use the numbers as they occur in the numerical DIMACS CNF format or Lparse-Smodels intermediate format and to post for each symmetry in the set of generators a lex-leader constraint. This is the approach that is taken for instance in the SAT symmetry breaking tool Shatter and in sbass.\nThe drawback of this approach is discussed extensively in the work that introduced BreakID [14]. There, we show that this phase leaves room for several optimisations. \u2013 The set G of generators is often not good for symmetry breaking. Manipulat-\ning this set can result in symmetry breaking constraints with much stronger breaking power. \u2013 The order given by the numerical format is often suboptimal for symmetry breaking. The order should \u201cmatch\u201d the symmetries in G. \u2013 If both of the above optimisations are executed, we effectively obtain a situation in which exponentially large subgroups of the group generated by G are broken completely (without increasing the size of the symmetry breaking constraints). \u2013 Instead of breaking on the generators, one can generate a large number of very small (size 2) symmetry breaking clauses, resulting in stronger propagation power. \u2013 A slightly better encoding of the lex-leader constraints can be used [29]. All of these optimisations are used in the ASP version of BreakID as well."}, {"heading": "4 Experiments", "text": "In this section, we experimentally compare sbass and BreakID, using clasp 3.1.4 as solver and gringo 4.5.5 as grounder. We compare the number of solved instances for a set of four symmetric decision problems, and a set of two symmetric optimization problems from the 2013\u2019s ASP competition [3]."}, {"heading": "4.1 Setup", "text": "The four decision problems in our benchmark set are pigeons, crew, graceful and queens.\npigeons is a set of 16 unsatisfiable pigeonhole instances where n pigeons must be placed in n\u2212 1 different holes. n takes values from {5, 6, . . . , 14, 15, 20, 30, 50, 70, 100}. The pigeons and holes are interchangeable, leading to a large symmetry group.\n10\ncrew is a set of 42 unsatisfiable airline crew scheduling instances, where optimality has to be proven for a minimal crew assignment given a moderately complex flight plan. The instances are generated by hand, with the number of crew members ranging from 5 to 25. Crew members have different attributes, but depending in the instance, multiple crew members exist with the same exact attribute set, making these crew members interchangeable.\ngraceful consists of 60 satisfiable and unsatisfiable graceful graph instances, taken from 2013\u2019s ASP competition [3]. These instances require to label a graph\u2019s vertices and edges such that all vertices have a different label, all edges have a different label, and each edge\u2019s label is the difference of the labels of the vertices it connects. The labels used are {0, 1, . . . , n}, with n the number of edges. Any symmetry exhibited by the input graph is present, as well as a symmetry mapping each vertex\u2019 label l to n\u2212 l.\nqueens is a set of 4 large satisfiable N-Queens instances trying to fit n queens on an n by n chessboard so that no queen threatens another. n takes values from {50, 100, 150, 200}. The symmetries present in queens are the rotational and reflective symmetries of the chessboard.\nThe two optimization problems are valves and still. Both problems\u2019 models and instances are taken from 2013\u2019s ASP competition [3], but manual symmetry breaking constraints were removed from the ASP specification.\nvalves models connected pipelines in urban hydraulic networks, and features interchangeable valves. Our instance set counts 50 instances.\nstill models a fixpoint connected cell configuration in Conway\u2019s game of life. The game board exhibits rotational and reflective symmetry. Our instance set counts 21 instances.\nAll experiments were run on on an Intel R\u00a9 Xeon R\u00a9 E3-1225 CPU with Ubuntu 14.04 Linux kernel 3.13 as operating system. ASP specifications, instances, shell scripts and detailed experimental results are available online5.\nThe decision problems had 6GB RAM and 1000s timeout as resource limits, and the results exclude grounding time, as this is the same for each solving configuration, but include any time needed to detect symmetry and construct symmetry breaking constraints. By default, BreakID limits the size of the symmetry breaking formula to 50 auxiliary variables for a given symmetry. To keep the comparison as fair as possible, sbass was given the same limit.\nThe optimization problems had 8GB RAM and 50000s timeout as resource limits, and the results exclude identical grounding time and negligable symmetry breaking time. No comparison with sbass was made as sbass does not support optimization statements."}, {"heading": "4.2 Decision problem results", "text": "Table 1 summarizes the results of the decision problems. Analyzing the results on pigeons, clasp gets lost in symmetric parts of the search tree, solving only 8 instances (up to 12 pigeons). sbass can only solve three more instances (up\n5 bitbucket.org/krr/breakid_asp\n11\nto 15 pigeons), as the derived symmetry generators do not suffice to construct strong symmetry breaking constraints. These results are consistent with the results of Drescher et al. [15]. BreakID detects more structure, solving all but two instances (the largest being solved contains 50 pigeons). As far as symmetry preprocessing time goes, both sbass and BreakID spend a significant time detecting symmetry, especially on the larger instances with more than 20 pigeons. To our surprise, BreakID requires only a quarter of the symmetry preprocessing time sbass uses. This difference is entirely due to Saucy needing much more time to detect automorphisms on the graph encoding of sbass than on the graph encoding of BreakID. Recall that, compared to BreakID, sbass has the smaller encoding graph for automorphism detection due to the use of directed edges. Hence, the most plausible hypothesis to explain the difference in symmetry detection time is simply that Saucy is sensitive to differences in graph encodings, which gets magnified by large problem instances. Nonetheless, even for the largest instance with 100 pigeons, symmetry preprocessing by sbass did not reach the timeout limit.\nThe results on crew are similar to pigeons: BreakID outperforms sbass, which in turn outperforms plain clasp. On the other hand, symmetry preprocessing time is negligible for crew. This is mainly due to the sizes of the ground programs remaining relatively small; less than 3000 rules for the largest ground program in the crew instance set.\nContinuing with graceful, it is striking that the number of solved instances is reduced by symmetry breaking. Upon closer inspection, this is only the case for satisfiable instances. For unsatisfiable graceful instances, sbass and BreakID both solve four instances, two more than clasp. This discrepancy is not uncommon, as static symmetry breaking reduces the search space by sometimes removing easy-to-find solutions. These results are also consistent with those reported by Drescher et al. [15]. Focusing on symmetry preprocessing time, sbass is faster than BreakID. This is consistent with our previous findings [14], where we argued that deriving better symmetry breaking clauses incurs extra overhead.\n12\nLastly, for queens, all approaches solve all four instances easily. Again sbass is faster than BreakID, which is explained by the same reason as for graceful. However, BreakID\u2019s preprocessing time remains well within timeout bounds.\nIt is also interesting to note that on all problem families sbass and BreakID have about the same number of symmetry breaking constraints and auxiliary variables introduced, incurring roughly the same memory overhead for both approaches. However the number of symmetry generators detected by BreakID is much larger. Upon closer inspection, it turns out that BreakID often detects (trivial) interchangeability of facts in the program. There is no advantage in breaking such symmetry, but it does not hurt performance either. We are not sure why sbass does not detect this kind of symmetries. Either it is because of the directional encoding, resulting essentially in a bug similar to Example 5, or it is because of an optimisation for facts we have no knowledge of.\nWe conclude that on the decision problem benchmark set, BreakID outperforms sbass, especially for problems with interchangeable objects such as pigeons and crew. The price to be paid is a bit more symmetry preprocessing overhead, though the size of the symmetry breaking formula remains comparable between both approaches. This is to be expected, as BreakID compared similarly to Shatter for SAT problems."}, {"heading": "4.3 Optimization problem results", "text": "Figure 3 shows the relative objective value of the best solution found after 50000s of search time for still and valves. Even though BreakID detects and breaks significant symmetry for both problems, and often infers interchangeability in valves, the resulting symmetry breaking constraints do not seem to vastly improve the final objective value for these two benchmark families. For still, the resulting objective value is virtually identical. For valves, the objective value\n13\nfor BreakID\u2019s run is improved for 11 instances, while it has worsened for 5 instances, giving a small edge to BreakID compared to clasp. When looking at the number of instances for which optimality was proven, both approaches were able to prove optimality for 5 still instances and 15 valves instances.\nWe conclude that for optimization problems still and valves, our symmetry breaking approach detects and breaks symmetry, but any resulting speedups are small at best."}, {"heading": "5 Discussion and Conclusion", "text": "In this paper, we describe our system BreakID, which performs static, groundlevel symmetry breaking for ASP. This type of symmetry breaker is the \u201ceasiest\u201d type to implement. It serves merely as a preprocessor for the solver. Other types of symmetry breaking exist as well. For instance, in SAT and constraint programming, dynamic symmetry breaking is well-studied [30, 13, 28]. The disadvantage of these approaches is that they require modifying the internals of the solver at hand. The advantage, however, is that such approaches are often more memory-friendly, since they do not require to create all the symmetry breaking constraints prior to search, are not dependent on any fixed variable order chosen a priori, and do not remove easy-to-find solutions from the search space. Another line of research in symmetry breaking is first-order symmetry detection, where symmetries are detected on the predicate level. In constraint programming, work has been done on composing the symmetry properties of global constraints into a symmetry group of the original problem [33]. However, most existing symmetry detection implementations also detect symmetry on the ground level.\nRecently, we proposed first-order symmetry detection and breaking algorithms for the IDP system [10], a system whose input language relates closely to ASP. The main advantage of such an approach is that it allows to use the structure of the program to detect certain kinds of symmetries without the need for an automorphism tool. The drawbacks are that they cannot detect all types of symmetry and that they are required to interpret a much richer (first-order) language. Thus, such symmetry detection requires a significantly larger implementation effort. We believe it would definitely benefit the community to have a version of gringo, or another ASP grounder, with support for first-order symmetry detection.\nThe techniques we presented here are not bound to the stable semantics. They are equally applicable for instance to the well-founded semantics [32], and hence apply as well to the logic FO(ID) [12] (which combines logic programs under the well-founded semantics with propositional theories). The reason is that our techniques detect syntactic symmetries and hence are agnostic about the semantics at hand.\nWe presented experimental results comparing our tool to the existing ASP symmetry breaker sbass. For the employed decision problem benchmark set, BreakID outperforms sbass, with a small drawback in the form of greater\n14\nsymmetry preprocessing overhead. BreakID also detects and breaks symmetry on optimization problems, though significant speedups have yet to be observed.\nThe result of this work is an easy-to-use tool that can significantly improve performance on non-optimised encodings and works with all modern ASP solvers. It can be downloaded at bitbucket.org/krr/breakid. Our expectation is that using this tool yields no (or very little) performance gain on highly optimised encodings, crafted by experts. However, for average users of ASP tools, BreakID can cut away large parts of the search space and is an improvement to sbass, both from an applicability as well as an efficiency point-of-view."}, {"heading": "Acknowledgements", "text": "This research was supported by the project GOA 13/010 Research Fund KU Leuven and projects G.0489.10, G.0357.12 and G.0922.13 of FWO (Research Foundation - Flanders). Bart Bogaerts is supported by the Finnish Center of Excellence in Computational Inference Research (COIN) funded by the Academy of Finland (grant #251170)."}], "references": [{"title": "Solving difficult SAT instances in the presence of symmetry", "author": ["F. Aloul", "A. Ramani", "I. Markov", "K. Sakallah"], "venue": "Proceedings of DAC. pp. 731\u2013736", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2002}, {"title": "Efficient symmetry breaking for Boolean satisfiability", "author": ["F.A. Aloul", "K.A. Sakallah", "I.L. Markov"], "venue": "IEEE Transactions on Computers 55(5), 549\u2013558", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2006}, {"title": "The fourth Answer Set Programming competition: Preliminary report", "author": ["M. Alviano", "F. Calimeri", "G. Charwat", "M. Dao-Tran", "C. Dodaro", "G. Ianni", "T. Krennwallner", "M. Kronegger", "J. Oetsch", "A. Pfandler", "J. P\u00fchrer", "C. Redl", "F. Ricca", "P. Schneider", "M. Schwengerer", "L.K. Spendier", "J.P. Wallner", "G. Xiao"], "venue": "Proceedings of LPNMR. pp. 42\u201353", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "WASP: A native ASP solver based on constraint learning", "author": ["M. Alviano", "C. Dodaro", "W. Faber", "N. Leone", "F. Ricca"], "venue": "Proceedings of LPNMR. pp. 54\u201366", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2013}, {"title": "Predicting learnt clauses quality in modern SAT solvers", "author": ["G. Audemard", "L. Simon"], "venue": "Boutilier, C. (ed.) Proceedings of IJCAI. pp. 399\u2013404", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Handbook of Combinatorics, chap", "author": ["L. Babai"], "venue": "Automorphism groups, isomorphism, reconstruction, pp. 1447\u20131540. Elsevier", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1995}, {"title": "The 2013 international SAT competition", "author": ["A. Balint", "A. Belov", "M.J. Heule", "M. J\u00e4rvisalo"], "venue": "satcompetition.org/2013", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "Normalizing cardinality rules using merging and sorting constructions", "author": ["J. Bomanson", "T. Janhunen"], "venue": "Proceedings of LPNMR. pp. 187\u2013199", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "Symmetry-Breaking Predicates for Search Problems", "author": ["J.M. Crawford", "M.L. Ginsberg", "E.M. Luks", "A. Roy"], "venue": "Proceedings of KR. pp. 148\u2013159", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1996}, {"title": "Predicate logic as a modelling language: The IDP system", "author": ["B. De Cat", "B. Bogaerts", "M. Bruynooghe", "G. Janssens", "M. Denecker"], "venue": "CoRR abs/1401.6312v2", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2016}, {"title": "Model expansion in the presence of function symbols using constraint programming", "author": ["B. De Cat", "B. Bogaerts", "J. Devriendt", "M. Denecker"], "venue": "Proceedings of ICTAI. pp", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}, {"title": "A logic of nonmonotone inductive definitions", "author": ["M. Denecker", "E. Ternovska"], "venue": "ACM Trans. Comput. Log. 9(2), 14:1\u201314:52", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2008}, {"title": "BreakIDGlucose: On the importance of row symmetry in SAT", "author": ["J. Devriendt", "B. Bogaerts", "M. Bruynooghe"], "venue": "Proceedings of CSPSAT", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Improved static symmetry breaking for SAT", "author": ["J. Devriendt", "B. Bogaerts", "M. Bruynooghe", "M. Denecker"], "venue": "Proceedings of SAT. pp. 104\u2013122", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2016}, {"title": "Symmetry-breaking answer set solving", "author": ["C. Drescher", "O. Tifrea", "T. Walsh"], "venue": "AI Communications 24(2), 177\u2013194", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "AIJ 187, 52\u201389", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "GrinGo: A new grounder for Answer Set Programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele"], "venue": "Proceedings of LPNMR. pp. 266\u2013271", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2007}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of ICLP/SLP. pp. 1070\u20131080", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1988}, {"title": "The 2016 international SAT competition", "author": ["M. Heule", "M. J\u00e4rvisalo", "T. Balyo"], "venue": "http: //baldur.iti.kit.edu/sat-competition-2016", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2016}, {"title": "Engineering an efficient canonical labeling tool for large and sparse graphs", "author": ["T. Junttila", "P. Kaski"], "venue": "Proceedings of the Ninth Workshop on Algorithm Engineering and Experiments and the Fourth Workshop on Analytic Algorithms and Combinatorics. pp. 135\u2013149", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2007}, {"title": "Symmetry and satisfiability: An update", "author": ["H. Katebi", "K.A. Sakallah", "I.L. Markov"], "venue": "Proceedings of SAT. pp. 113\u2013127", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2010}, {"title": "Answer set planning", "author": ["V. Lifschitz"], "venue": "Proceedings of ICLP. pp. 23\u201337", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1999}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": "The Logic Programming Paradigm: A 25-Year Perspective, pp. 375\u2013 398. Springer-Verlag", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1999}, {"title": "GRASP: A search algorithm for propositional satisfiability", "author": ["J.P. Marques-Silva", "K.A. Sakallah"], "venue": "IEEE Transactions on Computers 48(5), 506\u2013521", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1999}, {"title": "Practical graph isomorphism, {II", "author": ["B.D. McKay", "A. Piperno"], "venue": "Journal of Symbolic Computation 60(0), 94 \u2013 112", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2014}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Ann. Math. Artif. Intell. 25(3-4), 241\u2013273", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1999}, {"title": "Improving SAT solvers by exploiting empirical characteristics of CDCL", "author": ["C. Oh"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2015}, {"title": "Symchaff: exploiting symmetry in a structure-aware satisfiability solver", "author": ["A. Sabharwal"], "venue": "Constraints 14(4), 478\u2013505", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2009}, {"title": "Symmetry and satisfiability", "author": ["K.A. Sakallah"], "venue": "Handbook of Satisfiability 185, 289\u2013 338", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2009}, {"title": "Dynamic symmetry breaking by simulating zykov contraction", "author": ["B. Schaafsma", "M.J. Heule", "H. Maaren"], "venue": "Proceedings of SAT. pp. 223\u2013236", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2009}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "J. ACM 38(3), 620\u2013650", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1991}, {"title": "Compositional derivation of symmetries for constraint satisfaction", "author": ["P. Van Hentenryck", "P. Flener", "J. Pearson", "M. \u00c5gren"], "venue": "Proceedings of SARA. pp. 234\u2013247", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2005}, {"title": "Symmetry breaking constraints: Recent results", "author": ["T. Walsh"], "venue": "CoRR abs/1204.3348", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 15, "context": "In fact, many (if not all) modern ASP solvers [16, 4, 11] are based on conflict-driven clause learning (CDCL) [24], a technique first developed for SAT.", "startOffset": 46, "endOffset": 57}, {"referenceID": 3, "context": "In fact, many (if not all) modern ASP solvers [16, 4, 11] are based on conflict-driven clause learning (CDCL) [24], a technique first developed for SAT.", "startOffset": 46, "endOffset": 57}, {"referenceID": 10, "context": "In fact, many (if not all) modern ASP solvers [16, 4, 11] are based on conflict-driven clause learning (CDCL) [24], a technique first developed for SAT.", "startOffset": 46, "endOffset": 57}, {"referenceID": 23, "context": "In fact, many (if not all) modern ASP solvers [16, 4, 11] are based on conflict-driven clause learning (CDCL) [24], a technique first developed for SAT.", "startOffset": 110, "endOffset": 114}, {"referenceID": 13, "context": "In this paper, we port a recently introduced symmetry breaking preprocessor, BreakID [14] to ASP.", "startOffset": 85, "endOffset": 89}, {"referenceID": 12, "context": "A first version of BreakID was developed in 2013 [13].", "startOffset": 49, "endOffset": 53}, {"referenceID": 6, "context": "This version won a gold medal on the 2013 SAT competition [7] in combination with the SAT solver Glucose 2.", "startOffset": 58, "endOffset": 61}, {"referenceID": 4, "context": "1 [5].", "startOffset": 2, "endOffset": 5}, {"referenceID": 13, "context": "The latest version of BreakID was developed in 2015 [14] and won the gold medal in the no limit track of the 2016 SAT competition [19] in combination with the SAT solver COMiniSatPS [27].", "startOffset": 52, "endOffset": 56}, {"referenceID": 18, "context": "The latest version of BreakID was developed in 2015 [14] and won the gold medal in the no limit track of the 2016 SAT competition [19] in combination with the SAT solver COMiniSatPS [27].", "startOffset": 130, "endOffset": 134}, {"referenceID": 26, "context": "The latest version of BreakID was developed in 2015 [14] and won the gold medal in the no limit track of the 2016 SAT competition [19] in combination with the SAT solver COMiniSatPS [27].", "startOffset": 182, "endOffset": 186}, {"referenceID": 1, "context": "The most wellknown symmetry breaker for SAT is Shatter [2].", "startOffset": 55, "endOffset": 58}, {"referenceID": 20, "context": "Shatter works by (i) transforming a SAT theory into a colored graph whose automorphisms correspond to symmetries of the theory, (ii) calling a graph automorphism detection tool such as Saucy [21] to obtain a set of generators of the symmetry group, and (iii) adding constraints that break each of the generators returned by the previous step.", "startOffset": 191, "endOffset": 195}, {"referenceID": 13, "context": "Good choices for these two parameters strongly influence the breaking power and the size of the resulting constraints [14] .", "startOffset": 118, "endOffset": 122}, {"referenceID": 14, "context": "The techniques from Shatter have been ported to ASP by the ASP symmetry breaker sbass [15].", "startOffset": 86, "endOffset": 90}, {"referenceID": 13, "context": "For the third step (generating symmetry breaking constraints), we use all of the improvements that are already present in the SAT-version of BreakID [14].", "startOffset": 149, "endOffset": 153}, {"referenceID": 17, "context": "An interpretation I is a stable model or an answer set of P if it is a \u2286-minimal model of P [18].", "startOffset": 92, "endOffset": 96}, {"referenceID": 22, "context": "This observation gave birth to the field of answer set programming [23, 26, 22].", "startOffset": 67, "endOffset": 79}, {"referenceID": 25, "context": "This observation gave birth to the field of answer set programming [23, 26, 22].", "startOffset": 67, "endOffset": 79}, {"referenceID": 21, "context": "This observation gave birth to the field of answer set programming [23, 26, 22].", "startOffset": 67, "endOffset": 79}, {"referenceID": 7, "context": "These language constructs can all be translated to normal rules [8].", "startOffset": 64, "endOffset": 67}, {"referenceID": 32, "context": "If \u03a0 is a symmetry group, then a set of constraints \u03c8 is sound if for each interpretation I there exists at least one symmetry \u03c0 \u2208 \u03a0 such that \u03c0(I) satisfies \u03c8; \u03c8 is complete if for each assignment \u03b1 there exists at most one symmetry \u03c0 \u2208 \u03a0 such that \u03c0(\u03b1) satisfies \u03c8 [34].", "startOffset": 267, "endOffset": 271}, {"referenceID": 5, "context": "The complexity of this problem is conjectured to be strictly in between P and NP [6].", "startOffset": 81, "endOffset": 84}, {"referenceID": 20, "context": "Several tools are available to tackle this problem, including Saucy [21], nauty [25] and bliss [20].", "startOffset": 68, "endOffset": 72}, {"referenceID": 24, "context": "Several tools are available to tackle this problem, including Saucy [21], nauty [25] and bliss [20].", "startOffset": 80, "endOffset": 84}, {"referenceID": 19, "context": "Several tools are available to tackle this problem, including Saucy [21], nauty [25] and bliss [20].", "startOffset": 95, "endOffset": 99}, {"referenceID": 1, "context": "Shatter [2], sbass and BreakID make use of Saucy for this task.", "startOffset": 8, "endOffset": 11}, {"referenceID": 14, "context": "As for encoding a logic program as a colored graph, our approach is very close to the one introduced by sbass [15] (we discuss and justify the differences below).", "startOffset": 110, "endOffset": 114}, {"referenceID": 16, "context": "As a result, our tool supports the full Lparse-Smodels intermediate language as documented in [31] and additionally, the rule type \u201c8\u201d used by gringo [17] to represent disjunctive rules.", "startOffset": 150, "endOffset": 154}, {"referenceID": 8, "context": "Definition 1 (Lex-leader constraint [9]).", "startOffset": 36, "endOffset": 39}, {"referenceID": 0, "context": "[1].", "startOffset": 0, "endOffset": 3}, {"referenceID": 13, "context": "The drawback of this approach is discussed extensively in the work that introduced BreakID [14].", "startOffset": 91, "endOffset": 95}, {"referenceID": 28, "context": "\u2013 A slightly better encoding of the lex-leader constraints can be used [29].", "startOffset": 71, "endOffset": 75}, {"referenceID": 2, "context": "We compare the number of solved instances for a set of four symmetric decision problems, and a set of two symmetric optimization problems from the 2013\u2019s ASP competition [3].", "startOffset": 170, "endOffset": 173}, {"referenceID": 2, "context": "graceful consists of 60 satisfiable and unsatisfiable graceful graph instances, taken from 2013\u2019s ASP competition [3].", "startOffset": 114, "endOffset": 117}, {"referenceID": 2, "context": "Both problems\u2019 models and instances are taken from 2013\u2019s ASP competition [3], but manual symmetry breaking constraints were removed from the ASP specification.", "startOffset": 74, "endOffset": 77}, {"referenceID": 14, "context": "[15].", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15].", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "This is consistent with our previous findings [14], where we argued that deriving better symmetry breaking clauses incurs extra overhead.", "startOffset": 46, "endOffset": 50}, {"referenceID": 29, "context": "For instance, in SAT and constraint programming, dynamic symmetry breaking is well-studied [30, 13, 28].", "startOffset": 91, "endOffset": 103}, {"referenceID": 12, "context": "For instance, in SAT and constraint programming, dynamic symmetry breaking is well-studied [30, 13, 28].", "startOffset": 91, "endOffset": 103}, {"referenceID": 27, "context": "For instance, in SAT and constraint programming, dynamic symmetry breaking is well-studied [30, 13, 28].", "startOffset": 91, "endOffset": 103}, {"referenceID": 31, "context": "In constraint programming, work has been done on composing the symmetry properties of global constraints into a symmetry group of the original problem [33].", "startOffset": 151, "endOffset": 155}, {"referenceID": 9, "context": "Recently, we proposed first-order symmetry detection and breaking algorithms for the IDP system [10], a system whose input language relates closely to ASP.", "startOffset": 96, "endOffset": 100}, {"referenceID": 30, "context": "They are equally applicable for instance to the well-founded semantics [32], and hence apply as well to the logic FO(ID) [12] (which combines logic programs under the well-founded semantics with propositional theories).", "startOffset": 71, "endOffset": 75}, {"referenceID": 11, "context": "They are equally applicable for instance to the well-founded semantics [32], and hence apply as well to the logic FO(ID) [12] (which combines logic programs under the well-founded semantics with propositional theories).", "startOffset": 121, "endOffset": 125}], "year": 2016, "abstractText": "Symmetry breaking has been proven to be an efficient preprocessing technique for satisfiability solving (SAT). In this paper, we port the state-of-the-art SAT symmetry breaker BreakID to answer set programming (ASP). The result is a lightweight tool that can be plugged in between the grounding and the solving phases that are common when modelling in ASP. We compare our tool with sbass, the current stateof-the-art symmetry breaker for ASP.", "creator": "TeX"}}}