{"id": "1609.00464", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Sep-2016", "title": "The Semantic Knowledge Graph: A compact, auto-generated model for real-time traversal and ranking of any relationship within a domain", "abstract": "dearness This thorbjorn paper describes 37-15 a new equalizing kind nhek of advincula knowledge \u03c4\u03bf\u1fe6 representation and 48-17 mining meridith system takashima which 202-546-4194 we side-view are pyy calling lobes the 5.54 Semantic revving Knowledge 10-k Graph. At peachcare its 150-250 heart, the earthmovers Semantic Knowledge Graph golubchikova leverages rimsza an jascha inverted bamble index, yiming along with a complementary uninverted index, to represent 623,000 nodes (spean terms) and 499 edges (the documents franzen within intersecting juicio postings lists for 41.41 multiple terms / compete.com nodes ). This goffin provides hightech a layer kumaran of dlb indirection between mccluskey each ruell pair namouchi of schering-plough nodes and havlik their corresponding semiprofessional edge, bhatt enabling edges to materialize petersfield dynamically incapacity from underlying 2-15 corpus statistics. As a iglesias result, any combination of nodes can nom-de-plume have trucklike edges to machina any arbih other 7.0 nodes cornthwaite materialize wenche and be scored to rsr reveal latent relationships ch\u00e9ri between the thoraya nodes. hine This provides luoyang numerous benefits: the d'albret knowledge safer graph yniguez can be sol built procellariids automatically http://www.barackobama.com from a real - goal-directed world transbay corpus kuchum of sofija data, new southway nodes - 23.39 along with obliquely their spinet combined banjo edges - apoptosis can be b-meg instantly materialized from any kubitschek arbitrary 95.76 combination of preexisting nodes (using tempelhof set operations ), jaranwala and paneriai a full model zaveryukha of d\u00e9p\u00f4ts the smicer semantic relationships between fortresses all euro98 entities hattusa within a ragheh domain mig-3 can be represented non-departmental and tafadzwa dynamically urticaria traversed using a highly pre-planned compact ilnur representation of the 180.6 graph. populates Such posen a 1,000-page system has waalo widespread applications ridvan in unconcious areas as nomvethe diverse non-uniformed as ackerman knowledge wils modeling milholland and reasoning, board natural entertained language processing, anomaly mimis detection, huguenots data mariellen cleansing, semantic search, gun-boats analytics, spinrad data clifftop classification, root english-french cause analysis, empidonax and recommendations systems. prieb The mutsuko main boggio contribution gooder of flourishing this paper is saa the introduction terzic of storia a charge novel antigenic system - dodonnell@nycap.rr.com the centigrade Semantic simonenko Knowledge commanders Graph - which vla\u0161i\u0107 is able diffused to dynamically igber discover and redoute score contre-amiral interesting ladiges relationships between 2152 any lagniappe arbitrary sturmabteilung combination of entities (words, phrases, chodecz or 10:05 extracted siegelman concepts) nopales through 73.93 dynamically nelissen materializing nodes and edges 29.53 from a 48.38 compact graphical representation amiriyah built automatically teardrops from worplesdon a corpus of data representative carbone of a knowledge domain.", "histories": [["v1", "Fri, 2 Sep 2016 04:26:54 GMT  (1232kb,D)", "http://arxiv.org/abs/1609.00464v1", "Accepted to be published in 2016 IEEE 3rd International Conference on Data Science and Advanced Analytics"], ["v2", "Mon, 5 Sep 2016 15:06:45 GMT  (1229kb,D)", "http://arxiv.org/abs/1609.00464v2", "Accepted for publication in 2016 IEEE 3rd International Conference on Data Science and Advanced Analytics"]], "COMMENTS": "Accepted to be published in 2016 IEEE 3rd International Conference on Data Science and Advanced Analytics", "reviews": [], "SUBJECTS": "cs.IR cs.AI cs.CL", "authors": ["trey grainger", "khalifeh aljadda", "mohammed korayem", "ries smith"], "accepted": false, "id": "1609.00464"}, "pdf": {"name": "1609.00464.pdf", "metadata": {"source": "CRF", "title": "The Semantic Knowledge Graph: A compact, auto-generated model for real-time traversal and ranking of any relationship within a domain", "authors": ["Trey Grainger", "Khalifeh AlJadda", "Mohammed Korayem", "Andries Smith"], "emails": ["andries.smith}@careerbuilder.com"], "sections": [{"heading": null, "text": "I. INTRODUCTION\nGraphs are a well-studied class of data structures used to model relationships (edges) between entities (nodes). Knowledge bases in general, and ontologies specifically, model a domain by defining how different entities within the domain are related. Such knowledge bases are most commonly represented as a graph, and both the nodes and the edge relationships between nodes in that graph must be explicitly modeled either manually by a domain expert or automatically leveraging an ontology learning system. Because building such a knowledge base typically requires explicitly modeling nodes and edges into a graph ahead of time, this unfortunately presents several limitations to the use of such a knowledge graph:\n1http://github.com/careerbuilder/semantic-knowledge-graph/tree/dsaa2016\n\u2022 Entities not modeled explicitly as nodes have no known relationships to any other entities. \u2022 Edges exist between nodes, but not between arbitrary combinations of nodes, and therefore such a graph is not ideal for representing nuanced meanings of an entity when appearing within different contexts, as is common within natural language. \u2022 Substantial meaning is encoded in the linguistic representation of the domain that is lost when the underlying textual representation is not preserved: phrases, interaction of concepts through actions (i.e. verbs), positional ordering of entities and the phrases containing those entities, variations in spelling and other representations of entities, the use of adjectives to modify entities to represent more complex concepts, and aggregate frequencies of occurrence for different representations of entities relative to other representations. \u2022 It can be an arduous process to create robust ontologies, map a domain into a graph representing those ontologies, and ensure the generated graph is compact, accurate, comprehensive, and kept up to date.\nWe propose a new system for modeling relationships between entities that overcomes these limitations. This system, which we refer to as a Semantic Knowledge Graph, is aimed at extracting and representing the knowledge of a domain automatically from a corpus of documents representative of that domain. The underlying representation ultimately encodes the semantic relationships between words, phrases, and extracted concepts in such a way that those relationships can later surface to expose new insights about the interrelationships between all entities within the domain.\nThis kind of system has numerous applications which we will explore. It can be used to automatically discover sets of related terms within a domain, to represent and disambiguate multiple meanings of the same phrases, to power semantic search by dynamically expanding user queries to conceptuallyrelated keywords/phrases, to identify trending topics across time-series data, to build a content-based recommendation engine, to perform data cleansing on lists by scoring how relevant each items is to the list, to perform document summarization by detecting the importance of each phrase and entity within a document, and to do predictive analytics on time series data.\nIn its most basic use case (a corpus of free-text documents), a Semantic Knowledge Graph can be leveraged to automat-\nar X\niv :1\n60 9.\n00 46\n4v 1\n[ cs\n.I R\n] 2\nS ep\n2 01\n6\nically discover domain-specific relationships between entities within a domain. Given a corpus of documents also containing some amount of structured information (specific fields for titles, categories, dates, or other specific kinds of entities), it will treat each of those field types as a new edge that can be traversed between any two nodes co-occurring within the same documents with some (specifiable) minimum frequency.\nOne of the novelties of the system is that a layer of indirection exists between each node and the edge connecting it to any other node. Instead of explicitly defining an edge connecting two nodes with a predetermined relationship, as most graph databases are designed, a Semantic Knowledge Graph instead materializes edges during traversal between any two nodes based upon the intersection of the document sets to which both of the nodes link. Furthermore, because the edges between nodes are dynamically materialized based upon the set of shared documents to which they both link, this means that it is also possible to dynamically materialize new nodes by combining existing nodes (through their underlying sets of documents) in any arbitrarily-complex way. This subsequently means that any arbitrarily-complex nodes (for example, any linguistic combination of character sequences, terms, and term sequences) can also be decomposed into their minimum constituent parts (terms related by position within documents) when building the graph, enabling a highly-compressed graph representation which is capable of reconstituting and traversing every existing relationship within a knowledge domain.\nAs a result of maintaining all of the corpus occurrence statistics about each node, a Semantic Knowledge graph can also dynamically discover and score interesting relationships between any nodes based upon the statistical similarity of the nodes in any given context. The Semantic Knowledge Graph represents a novel new graph model which is both auto-generated and yet able to represent, traverse, and score every relationship represented within a corpus of documents representing a knowledge domain."}, {"heading": "II. RELATED WORK", "text": "Ontologies can be defined as explicit formal specifications of the terms within a domain and the relations among them [1]. Ontologies have become common across various domains for building vocabulary to be shared and used by domain experts. Many advantages can be gained by building a common vocabulary, including improving the re-usability of domain knowledge, enabling a common understanding of the structure of information, and providing the ability to analyze domain knowledge. Ontologies can be classified into three different categories [2]: formal ontologies that have axioms and definitions in logic, terminological ontologies (e.g, WordNet [3]), and prototype-based ontologies having typical instances or prototypes instead of axioms. Recently, large-scale knowledge bases that utilize ontologies (FreeBase [4], DBpedia [5], and YAGO [6, 7]) have been constructed using structured sources such as Wikipedia infoboxes. Other approaches (DeepDive [8], Nell2RDF [9], and PROSPERA [10]) crawl the web and use machine learning and natural language processing to build web-scale knowledge graphs.\nExisting work on ontologies and knowledge bases still suffers from significant limitations. Manually-created knowledge bases are expensive and labor-intensive to build and maintain\nand are thus generally incomplete and have a tendency to grow out of date over time. While ontology learning systems are typically able to automate much of the ontology building (and sometimes maintenance) process, this comes at the expense of a loss of accuracy due to the replacement of human experts with more error-prone algorithms [11\u201315].\nCurrent ontology learning systems also throw away a substantial amount of information encoded within the textual content they are processing. For example, any entities not discovered as nodes during the ontology mining process have no known relationships to any other entities, regardless of whether those relationships were actually represented within the analyzed content (and just overlooked) during the ontology mining process. Furthermore, since most terms and phrases can take on alternate, nuanced meanings within different contexts, these nuanced meanings are often lost when representing terms and phrases as single nodes independent of the context in which they are used. Finally, a substantial amount of meaning is encoded in the nuanced linguistic representations present in a corpus of free-text content (terms, character sequences, term ordering, placement of words within phrases and paragraphs, and so on). Existing ontology creation approaches fail to adequately support the representation and scoring of relationships between these nuanced and complex interrelationships.\nOur work improves upon current ontology mining approaches by creating a knowledge graph which can fully represent the nuanced relationships between every entity (term, phrase, or other textual representation) represented within a corpus of free-text documents, as well as traverse and score the strength of those relationships or of any combination of those relationships."}, {"heading": "III. METHODOLOGY", "text": ""}, {"heading": "A. Problem Description", "text": "Technology platforms are becoming increasingly more capable every day of interpreting and responding to domainspecific and personalized questions. Search engines and recommendation engines, in particular, can barely compete unless they leverage models containing deep insights into the kinds of questions being asked and - more importantly - the kinds of answers being sought. One of the most common ways of representing a domain in order to surface these insights is through the use of ontologies - combinations of taxonomies containing known entities, their properties, and their interrelationships. These ontologies can then be integrated into a search application in order to improve its ability to meet the enduser\u2019s information need. For example, if someone searches for the term server in the information technology domain, it has a very different meaning (a computer server) than in the restaurant domain (a waiter/waitress), and if someone is using a job search engine, it could actually represent either meaning depending upon the user\u2019s context. Ontologies can help represent the relationships between entities such that they can be used to improve the accuracy of the system at meeting its users\u2019 information needs.\nOntologies are usually built manually by human experts, making them expensive to build, maintain, and update. To combat this, ontology learning systems, which attempt to automatically learn relationships from a domain and then map them into an ontology, are becoming more prevalent [16].\nWe would like to create a system that is able to automatically generate a graph representation of a knowledge domain simply from ingesting a corpus of data representing the domain, while simultaneously preserving all of the linguistic and statistical relationships between the keywords, phrases, and extracted entities from the corpus. Once a model (a graph) is built from this data, we can then leverage it to better understand the interrelationships between those words, phrases, and entities.\nNatural language, as represented in full-text documents, contains tremendous meaning compressed within its linguistic structures, represented through multiple levels of abstraction:\n\u2022 Corpus: a list of documents representative of a knowledge domain \u2022 Document: a list of fields relating to each other through some underlying entity \u2022 Field: a grouping of zero or more term sequences representative of a relationship with a document. \u2022 Term Sequence: an ordered representation of one or more terms \u2022 Term: a character sequence representing a known meaning (for example, a recognizable word) \u2022 Character Sequence: an ordered combination of one or more characters \u2022 Character: a letter or symbol used within natural language (represents no meaning by itself)\nWhile a corpus, document, and field are common concepts within the field of information retrieval, concrete examples of term sequences, terms, character sequences, and characters are presented in Figure 1 for further explication. In this figure, you can see that the term sequence software engineering is composed of the ordered sequence of the two terms software and engineer, and that the word engineering contains the character sequence engineer, which contains the characters e, en, eng, ... engineer, etc.\nOur goal is to automatically generate a knowledge graph from an underlying corpus of documents. In order to avoid the previously mentioned pitfalls with manually generated\nontologies and ontology learning systems, we need a way to fully preserve these nuanced semantic interrelationships embedded within a corpus of textual documents.\nOur overarching goal is not simply to link entities with known relationships, however, but to actually present the ability to discover any arbitrarily-complex relationship between entities within the domain. Consider a typical search engine, where a user can query any keywords, phrases, or arbitrarily-complex combinations of character sequences, terms, or term sequences. We would like to be able to traverse our automatically-generated knowledge graph and instantly understand the nuanced meaning(s) represented by these arbitrarily-complex natural language queries.\nTo understand the significance of this goal, let\u2019s consider the way in which the meaning of terms is modified given their context. The term engineer has a well-known abstract meaning, but when found inside the phase software engineer, it takes on a much more limited interpretation. Similarly, the word driver takes on two entirely different meanings when found near terms relating to computers (a hardware driver) versus in contexts related to transporting goods (truck driver or delivery driver). While we tend to think of most terms and phrases as having a limited number of meanings, it is far more accurate to think of them as having a slightly different meaning in every unique context in which they are found. While terms and phrases usually share strong similarities in their intended meanings across contexts, by allowing both those strong similarities, as well as nuanced differences to surface during node traversals, we are able to discover the most important interrelationships between entities in any given context and thus much better represent the intended knowledge domain. Our Semantic Knowledge Graph model provides a compact representation of an entire knowledge domain (as represented within a corpus of documents) which accomplishes these goals."}, {"heading": "B. Model Structure", "text": "Consider an undirected graph G = (V,E) where V and E \u2282 V \u00d7 V denote the sets of nodes and edges, respectively. We define the following:\n\u2022 D = {d1, d2, ..., dm} is a set of documents that represent a corpus that the Semantic Knowledge Graph will utilize to extract and score semantic relationships. \u2022 X = {x1, x2, ..., xk} is a set of all items stored in D. These items could be keywords, phrases, or any arbitrary linguistic representation found within D. \u2022 di = {x|x \u2208 X} where we can think of each document d \u2208 D as a set of items. \u2022 T = {t1, t2, ...tn} where ti is a tag which assigns an entity type to an item such as keyword, title, location, company, school, person, etc.\nGiven the previous notations, the set of nodes V in our graph can be defined as V = {v1, v2, .., vn} where vi stores an item xi \u2208 X tagged with tag tj \u2208 T . While Dvi = {d|xi \u2208 d, d \u2208 D} is a set of documents that contains item xi with its appropriate tag tj . Finally, we define eij as an edge between (vi, vj) with a function f(eij) = {d \u2208 Dvi \u2229 Dvj} that stores on each edge the set of documents that contain both items xi and xj with their tags. On the other hand, we define\ng(eij , vk) = {d : d \u2208 f(eij) \u2229 Dvk} that stores on the edge ejk the common set of documents between f(eij) and Dk."}, {"heading": "C. Materialization of Nodes and Edges", "text": "Core to the SKG model is the idea that a layer of indirection exists between any two nodes vi and vj and the edge eij that connects them. Specifically, instead of nodes being directly connected to each other through explicit edges, nodes are instead connected bidirectionally to documents, such that the edge eij between node vi and vj is said to materialize whenever |f(eij)| > 0.\nThus, in order to traverse the graph from source node vi to destination node vj , our system requires a lookup index linking node vi to a set of documents, as well as a separate lookup index which can map from those documents to node vj or other nodes to which a traversal may need to occur. We refer to this first index as our terms-docs inverted index, and to the second as our docs-terms uninverted index, both shown in Figure 2 (a). These two indexes enable us to model all terms as nodes within the graph and to materialize and traverse from any node to any other node through the sets of shared documents between the nodes, as shown in Figure 2 (b).\nBecause edges materialize during graph traversal based upon an intersection of documents to which both nodes are connected, this means that we can form an edge between any entity that is representable by an underlying set of documents to which it is linked. Thus, instead of being restricted to only using predefined entities from our terms-docs index, it is also possible to dynamically materialize new nodes on the fly based upon any combination of terms, as shown in Figure 2 (c).\nSince complex representations of entities can be materialized as nodes from arbitrary combinations of existing terms, this enables us to also decompose complex entities into individual terms (with positional relationships) for persistence in the underlying terms-docs inverted index. Through this process of decomposing our corpus into individual terms, the documents in which the terms appear, and the positions in those documents where the terms appear, we can thus create a highly compressed and lossless representation of every relationship within our original corpus. Then, at traversal time, we can materialize nodes representing any representation found within the original corpus, as well as edges connecting any materialized or predefined nodes to other nodes."}, {"heading": "D. Scoring Semantic Relationships", "text": "The Semantic Knowledge Graph (SKG) is able to score and represent the strength of the semantic relationship between entities on the edge connecting them. For example, if we don\u2019t know how semantically related the keyword java is to the keyword hadoop, we can utilize the SKG to score the relationship between these two terms. To score a semantic relationship between item xi and item xj using the SKG, we materialize source node vi (holding the documents linked to by xi) and destination node vj (representing the set of documents containing xj).\nThe simple use case for scoring semantic relationships is to score directly connected nodes vi and vj . In this case we query the terms-docs inverted index for item xi tagged with tj ,\nand as a result we get back Dvi. Then we query the terms-docs inverted index again for xj tagged with tk to get Dvj . An edge eij will be created between vi and vj if f(eij) 6= \u03c6. We call the Dvi our foreground document set DFG, while DBG \u2286 D is our background document set. The hypothesis behind our scoring technique is that if xi tends to be semantically related to xj , then the presence of xj in the foreground document set DFG should be above the average presence of xj in DBG. We utilize The z score to evaluate this hypothesis:\nz(vi, vj) = y \u2212 n \u2217 p\u221a n \u2217 p(1\u2212 p)\nWhere n = |DFG| is the number of documents in our foreground document set, p =\n|Dvj | |DBG| is the probability of\nfinding the term xj with tag tk in the background document set, and y = |f(eij)| is the number of documents containing both xi and xj .\nIn many cases, we will want to traverse multiple levels of depth n > 2 to find and score relationships between more than just two nodes. For example, we may traverse from the entity java to big data to hadoop, such that the weight assigned to the edge between big data and hadoop would be more meaningful if it were also conditioned upon the the path it took to arrive at big data through java. Our system accomplishes this across n nodes and a path P = v1, v2, .., vn, where each node stores an item xi with its tag tj . To apply the same z(vi, vj) between nodes, but conditioning this score based upon the entire path P , the only changes are\nDFG =  f(eij) if n = 3 { n\u22123\u22c2\ni=1,j=i+1,k=j+1\ng(eij , Dvk)} if n > 3\nwhile y = |DFG\u2229Dvn |. We normalize the z score using a sigmoid function to bring the scores in the range [\u22121, 1]. We call the normalized score the relatedness score between nodes where 1 means completely positively related (likely to always appear together), while 0 means no relatedness (just as likely as anything else to appear together), and -1 means completely negatively related (unlikely to appear together).\nWhile the relatedness score provides a weight on each edge corresponding to the strength of the semantic relationship between two nodes, since this score is calculated at traversal time, it is also possible to substitute in other scoring functions depending upon the use case at hand. Popularity (total count of overlapping documents) is another function that may be appropriate for simpler use cases, for example."}, {"heading": "E. Discovering Semantic Relationships", "text": "The SKG is very powerful at surfacing hidden relationships between nodes in real time. Furthermore, this model enables materialization of nodes and extraction of relationships using those materialized nodes. In order to discover related items with a specific tag tk to an item xi with tag tj , we start by querying the inverted index for the item xi, which we assign as node vi corresponding with document set Dvi . We query the docs-terms uninverted index for the tag tk and we store the retrieved documents as Dtk = {d|x \u2208 d, x : tk}. We define Vvi,tk = {vj |xj \u2208 d, d \u2208 Dtk \u2229 Dvi} where vj\nis a node that stores an item xj , and we define Vvi,tk as the set of nodes that stores items with potential relationship with xi of type tk (See Figure 3 (a)). Finally, we apply \u2200vj \u2208 Vvi,tk , relatedness(vi,vj) to score the relationship between vi and vj , which enables us to rank those relationships and pick the top m relationships or define a threshold t to accept only relationships with relatedness(vi, vj) > t. This operation of relationship discovery can occur recursively, as shown in Figure 3 (b), to discover and drill into multiple levels of relationships."}, {"heading": "IV. SYSTEM IMPLEMENTATION", "text": "Our implementation of the Semantic Knowledge Graph leverages the Apache Lucene/Solr search engine for many of its needed data structures. The data structures leveraged include the underlying inverted index that is used to find preexisting nodes, the document set intersection logic necessary to materialize new nodes and edges from the terms-docs inverted index, and the docs-terms uninverted index that is necessary to traverse across the edges materialized between nodes.\nSince Apache Solr serves as a web server, we leverage it as a framework to expose a RESTful API around our SKG implementation.\nIn order to build the knowledge graph, one simply needs to send a corpus of documents to the Semantic Knowledge Graph API. These documents will contain one or more fields, typically with at least one field contain raw text, and optionally with one or more additional fields containing some more structured information about the document. For the use case of employment search, for example, we could use the command in Table I to add some job postings to the SKG.\nThe most important thing to note here is that documents are added to the graph, but no explicit relationships between entities need to be modeled. Instead, the SKG will later allow us to discover relationships between entities - in this case job titles, skills, and keywords - through statistical analysis of how those entities are found together or absent across the entire\ncorpus of documents. Figure ?? (c) visually demonstrates how the underlying data structure and the intersection of sets of documents work together to form a traversable graph model.\nOnce an entire corpus of documents has been loaded into the SKG, we can now issue queries to the system to traverse and score the relationships between entities. Table II shows an example query and response from the graph.\nThis request asks the system to find the top job title associated with the phrase data science, and then to find up to three skills, including java, sorted by how similar they are to the job title data science (the previous node in the traversal).\nBy making our implementation of the SKG model a plugin for Apache Solr, we were able to leverage a pre-built inverted index, an uninverted index, as well as a rich set of text analysis libraries (tokenizers and token filters) to model documents. This allowed us to focus on the graph semantics, document set intersections, scoring models, and graph traversal API required to implement the SKG without needing to reimplement most of the already well-studied information retrieval structures upon which the SKG relies. Instead of re-implementing a query parser, this also allowed us to make full use of existing tools to map character sequences, terms, and term sequences into their underlying document set representations.\nSince an inverted index can be implemented using multiple underlying data structures, this also allows us to easily leverage highly efficient and compressed data structures, such as\nLucene\u2019s Finite State Automata/Transducers, for more efficient compression and traversal of nodes within the SKG. [17]"}, {"heading": "V. EXPERIMENTS AND RESULTS", "text": "While the SKG is a generally applicable model to any domain representable by documents with overlapping references to the same entities, we focused our testing on use cases within the job search domain, leveraging datasets provided to us by CareerBuilder, one of the largest job boards in the world.\nFor our experiments, we leveraged two datasets: 1) a collection of 3 million job postings, and 2) a collection of 1 million job seeker resumes containing a total of 3 million\nemployment history sections (representing prior jobs held by a given job seeker). While these two datasets could have been combined into a single graph, we only had the need to use a single dataset at a time and therefore maintained each dataset in a separate SKG for the following experiments. All of our experiments leveraged the SKG implementation described in the System Implementation section, which has been open sourced along with the publication of this paper.\nIn terms of performance, the SKG was able to easily traverse through and gather millions of nodes in just a few milliseconds (on commodity servers) in our experiments when the relatedness score was not needed. For most of these same queries tested utilizing the relatedness score, the SKG request completed in tens to hundreds of milliseconds, though some very intensive queries traversing multiple levels of nested-relationships were observed to take several seconds to complete. Observed times are thus quite fast considering the dynamic nature of the node and edge materialization, making the SKG suitable for integration in real-time search and natural language processing systems."}, {"heading": "A. Data Cleansing", "text": "Data Scientists spend a considerable amount of their time - 60% according to a 2016 survey - cleaning and organizing data sets [18]. Most datasets contain some dirty data, particularly when free text content is involved. While we have previously described how the SKG is able to discover relationships embedded within a corpus of documents, it is just as good at ranking user-supplied relationships.\nUse Case: As an example use case, we leveraged the SKG to clean a list of relationships mined from search engine query logs using a similar methodology to that described in [19, 20]. The idea here is that users who conduct similar searches often search for related terms and phrases. For example, someone who searches for registered nurse will often also search for RN, nurse, ER, hospital and so on. Someone who searches for java will often also search for software engineer, java developer, and so on. After obtaining a list of search terms mapped to\ntheir co-occurring terms, we decided to use the SKG to find the weight of the edge between each pair of co-occurring terms.\nSince the relatedness score is normalized between -1 (perfectly negatively related), 0 (no relationship), and 1 (perfectly positively related), we use 0.5 as our threshold between whether something is likely to have a strong relationship (0.5 to 1.0) or likely to have a weak relationship (0 to 0.5).\nExperiment Setup: To setup our experiment, we indexed 3 million job postings into an SKG. We then used this SKG to traverse 2.26 million co-term pairs, traversing across the shared has_related_term edge between the nodes for each term. For each traversal, we analyzed the weight of the edge (the relatedness score), and we added all term pairs with a relatedness score below 0.5 to a blacklist. The end result was the blacklisting of 78% of the co-term pairs (1.77 million blacklisted). Table III shows some examples of co-term pairs which were kept and which were blacklisted.\nResults: From the blacklist generated from the SKG, we asked an independent data analyst to randomly select 500 of these blacklisted pairs and tag them as either related or not related. The threshold for something being related, in this case, is whether the data analyst believed a user would wish to see the co-term suggested in a search experience when performing a search for the original term. As a result of his analysis, the Data Analyst determined that 25 of the 500 blacklisted terms were actually related, while 475 were correctly identified by the SKG as not related. The final results thus showed that the SKG removed 78% of the terms while maintaining a 95% accuracy at removing the correct noisy pairs from the input data."}, {"heading": "B. Predictive Analytics:", "text": "The SKG is also effective at performing predictive analytics in order to estimate future behavior based on analysis of past behavior.\nConcretely, given a set x1 = {x11 ...x1m} through xn of feature vectors describing a state at time t1 through tn, we would like to predict likely subsequent states at times tn + 1...tm.\nWith a modified scoring function, the SKG materializes nodes which can be interpreted as either consequent or antecedent of an association rule, with edge scores corresponding to the confidence of these rules [21].\nCareer Pathing Use Case: We used the SKG against resume data to characterize and predict employment histories. The tag types indexed include features such as extracted skills and keywords, normalized job titles, job level, location, and duration (in months) of employment. The SKG generates estimates characterizing a hypothetical next job in terms of combinations of node types indexed. For example, we can generate the maximal confidence consequent of the next job\ntitle and the skill most likely to be used at the next job. The SKG implementation also allows support and confidence thresholding through a normalized min_count parameter. Additionally, with the ability to materialize edges and nodes using query parameters, the SKG allows for much more fluid construction of antecedents and consequents.\nExperiment Setup: We tested the SKG\u2019s predictive capabilities using resumes from one million job seekers. We parsed and extracted the tag types of location, job level, job title, skills, and keywords for the most recent three employment history entries of each resume. For each tag set (corresponding to an employment history), we index each tag type appended with an index indicating recency. We additionally use consequent scoring, allowing edge scores to be interpreted as the confidence of association rules, with the new scoring function c(vi, vj) = |DFG \u22c2 Dvj | |DFG| . Prediction proceeds by materializing a node encoding the predictor features (which must be less recent than the most recent tag set), then traversing the graph through the next_most_recent_t edge for an arbitrary tag t.\nResults: Using data on what career paths thousands of other job seekers have taken, we can answer the question \"Given my current position and skills, what are my next most likely positions?\u201d Figure 4 demonstrates an example answer.\nThe most direct application of this predictive capability is in providing recommendations for job seekers looking to take the next step in their careers. As of the time of writing, such a system was still in a research phase. Our approach relies on the dynamic edge materialization of the SKG to discover viable job titles, which are then filtered by compensation (and in the future, experience) constraints to ensure recommended jobs represent a step forward.\nSearch Expansion Use Case: Recruiter search expansion represents another application of the SKG\u2019s predictive capabilities. A common problem when recruiting for high-demand jobs is a scarcity of applicants. Searching for applicants who match the skills and title of an in-demand job may be too restrictive, but recruiters don\u2019t always have the domain knowledge to expand their search for fitting candidates. A semantic search engine represents an adequate solution to this problem, but without the concept of career progression, semantic search ignores a pool of trainable candidates. Given an original candidate search, q0, we consider the problem of expanding the\nquery while retaining the highest possible probability that the additional candidates represent a \"good fit\u201d. One measure of trainability is the probability that the candidate would advance to match q0 in their next job independent of the recruiter. By this definition, our problem can be reduced to finding a maximal confidence antecedent of a given starting node.\nExperiment Setup: We tested the search expansion capabilities of the SKG using the same career path corpus containing one million resume examples. We modify our scoring function again, to an antecedent scoring function, which evaluates the confidence of a rule defined Vk \u2192 v1, where v1 is the starting node and Vk the set of nodes traversed up to the index k (excluding v1). Given a path P = v1, v2, ...vi:\na(vi, vk) =  |Dvk \u22c2 DFG| |DBG| if vi is a starting node |Dvk \u22c2 DFG|\n| j=i\u22c2 j=2 (Dvj ) \u22c2 DBG| otherwise\nIn order to isolate the effect of career progression we modified our materialized starting node by explicitly excluding examples that matched the query in earlier employment history entries. We then traverse the graph along the has_less_recent_t edge for arbitrary tag type t.\nResults: Figure 5 shows the results for an example query. Note the relatively high confidences for the distantly related job titles and skills, which are unlikely to be returned by a semantic search engine. Although applications for this use case are still in development, our approach would be to use the SKG to generate expansions, which can then be selectively applied based on confidence and support thresholds."}, {"heading": "C. Document Summarization", "text": "Another interesting application of the SKG is the identification of the most important topics within a document. In any given text document, some words are going to be highlyrelated to the topic of the document, while others will be unimportant. With the SKG, we can score every entity within a document to determine its significance to the topic of the document. This takes us from a full text document to a much more compressed summarization of the document including only its most important components.\nExperiment Setup: We indexed 3 million job posting documents into the SKG implementation discussed in the System Implementation section.\nOur goal was to then take a new document not already represented in the graph and to have the graph score how related each of the entities found within the new document is to the document itself. While we could have used the individual keywords within the document as our starting nodes, we instead employed an entity extractor on the document as a preprocessing step. The purpose of leveraging the entity extractor was so that we could work with phrases as our nodes (e.g. senior software engineer and registered nurse) as opposed to only single keywords (e.g. senior, software, engineer, registered, and nurse).\nOur next step was to specify a foreground query (which yields the set of documents DFG from our model), which in this case should represent the topic of our document. Because our corpus was composed of job posting documents, which have job titles and descriptions, we are able to simply leverage the job title of the document as our foreground query. In other scenarios where no category for the document is known a priori, it is possible to instead leverage other statistics from the terms-docs inverted index, such as tf-idf scoring of each term within the document, to find the set of most globally interesting terms within the document [22]. This list of terms can then be used to materialize a foreground query that combines the top most globally interesting terms found within the document.\nOnce we generate our foreground query (the topic of the document), we then send each of the phrases from the document to the SKG, asking the graph to score how relevant they are to the topic of the document.\nTable IV demonstrates an example document run through the SKG. While parts of the document were omitted for the sake of space, you can see that the top scoring nodes returned from the SKG are an excellent summarization representing the most important entities within the document. If someone wanted a quick overview about what this job posting is about, reviewing this ranked list of phrases would provide a very condensed summary. Furthermore, one could request additional traversals from this summary list and find the most related other nodes which were not actually present in the\noriginal documents.\nSuch document summarization has many applications. The summarized list of nodes can be sent to an information retrieval engine to build a document-based query, which creates a form of content-based recommendation engine. You could use the weights of each nodes to highlight the important sections of a document, or use the next traversal to suggest additional related terms for a document as its author is writing it."}, {"heading": "VI. FUTURE WORK", "text": "While we have designed the SKG model, created and open sourced a reference implementation, and tested several use cases, there are many extension points worthy of future research and exploration.\nOur implementation of the SKG is able to both identify predefined nodes, as well as materialize new nodes and edges on the fly. While we have implemented two general-purpose scoring mechanisms for assigning weights to edges (popularity and relatedness) and have implemented another more specialized scoring mechanism described in the career pathing use case section, each edge scoring algorithm must be coded into the system today. A future extension of our implementation is to allow users to specify functions as part of the graph query syntax such that they can apply arbitrarily complex scoring calculations without the need to write custom code.\nAdditionally, whereas today all documents matching a term or query are included in materialized nodes and edges (even if they are only tangentially related to the document in which they were found), we believe that by first scoring all documents matching each node (for example, using a tf-idf score) and only leveraging the top n documents from each node when scoring, that we could further improve the system\u2019s ability to identify highly-related nodes and to filter out noisy edges.\nSemantic Search: One of the key future use cases where we intend to apply the SKG model is for query interpretation and expansion. We have already shown that the SKG works quite well for identifying the most conceptually similar terms for a given term/phrase/entity within a domain. This can be used to automatically expand a search query to perform a conceptual search instead of an exact match search. For example, if someone searches for cdl, then the query could be automatically expanded to something like cdl OR \"truck driver\" OR freight OR \"commercial drivers license\". One particularly interesting aspect of using the SKG for this task is that not only can it identify what each individual search term means, but it can actually identify which terms are semantically-related to the entire query. Thus, if someone searches for driver AND windows, the SKG can return a different set of keyword expansions for the term driver than if the user had searched for driver AND truck. This deviates from traditional taxonomy approaches, which often rely on fixed meanings of each word, whereas the SKG can infuse nuance and contextual interpretation of search terms.\nSearch Engine Relevancy Algorithms: There are also several options for leveraging the technique mentioned in the document summarization use case to calculate and index the significance of each term in each document and use that information as part of the search engine\u2019s relevancy ranking algorithm. Such a probabilistic relevancy ranking function could\nlikely achieve measurable gains over more traditional models which only consider the number of occurrences of terms as opposed to their conceptual significance to the document.\nTrending topics (time-series): Another application of the SKG is the identification of trends over time. This could be conceptually described as doing anomaly detection where the foreground and background sets are time frames as opposed to categories or keywords. For example, if you were analyzing a news feed or stream of social media posts, you could specify a background query of \"this month\" and a foreground query of \"this week\" or \"today\" to see articles or categories which are occurring with a higher-than expected likelihood. This would allow you to identify trending topics, and is a useful additional use case for future exploration with the SKG model.\nRecommendation Systems: Most recommendation systems leverage behavioral-based collaborative filtering, which suffers from the cold-start problem (items which have not yet been reviewed by enough users will not be recommended). In order to overcome this, it is often helpful to also have a contentbased recommendations approach. The SKG can be leveraged to identify the most significant features of a document (as previously described in the document-summarization use case), in order to use those to match other documents sharing those same features. The SKG can also be leveraged to better understand the users for which recommendations are being made by inspecting the known information about them from their previous interactions with the system as compared with other users. For example, if a user ran multiple searches within a search engine before, the SKG can be used to determine the intersection and overlap between those searches (a materialized node) and to traverse to the other nodes that are most related to the combined search history of the user. Further, the SKG could be used to predict interests of users based upon how their behavior compares to other users. The career pathing use case described previously is a good example of this, where we could inspect a job seekers employment history and current job searches to determine, based upon other job seekers\u2019 typical behavior, when the user is most likely to switch jobs, and to what kind of job he/she would be willing to switch. This information could then be used as a feature in the job recommendation algorithm, and this feature would also change to more heavily favor a progression in job seniority as time progresses. Depending upon the domain, there are numerous ways to leverage the SKG by leveraging its ability to materialize and score the nuanced relationships between arbitrary entities.\nRoot Cause Analysis: The SKG is a good candidate for future research as a root cause analysis tool. Many companies maintain ticketing systems or online help forums through which they receive questions, bug reports, and/or complaints. The SKG could be used, for example, to find posts by customers matching a specific criteria (i.e. look for nodes/terms like frustrated, broken, or refund) and find out which other words or topics are most statistically related. If a company sold a software system, this would be an easy way to determine which parts of the system needed the most attention.\nAbuse Detection: Given a system where a few users partake in abusive behavior (posting spam, programmatically crawling the website, etc.), you could index the behaviors of users, find some abusive users, and use them as your foreground\nset to find other users who exhibited statistically similar behavior. In the spam use case, you could also tag your original documents with spam or not spam and set spam documents as your foreground set DFG. Assuming your documents contain textual content, you could then identify nodes/terms more commonly found among spam postings, and use this detection as the basis of a spam classifier for new postings as they are received. This is one of many forms of anomaly detection, a category of use cases for which the SKG is particularly well suited for future research and applications."}, {"heading": "VII. CONCLUSION", "text": "In this paper, we have introduced a novel kind of knowledge discovery model, which we are calling the Semantic Knowledge Graph. This system enables the automatic creation of a graph which encodes statistical relationships between all keywords, phrases and entities represented within free text and semi-structured documents, allowing those relationships to be traversed and scored based upon strength of the relationship within a specific domain. This auto-generated graph can then be queried in real time to discover the nuanced relationships between any combination of linguistic representations (keywords, phrases, etc.) or structured data (titles, categories, dates, numbers, etc.). Unlike traditional graph databases which perform either a depth-first search or a breadth-first search of all nodes, because the Semantic Knowledge Graph materializes edges between nodes and assigns their weights on the fly based upon either count of overlapping documents or relatedness of nodes within a corpus of documents, the Semantic Knowledge Graph can use these weights to only traverse the top scoring edges. This turns the graph traversal process into one index lookup and set intersection per level of depth of the traversal, making the Semantic Knowledge Graph highly efficient at traversing millions or even billions of nodes, as long as only the highest weighted nodes are collected at each level.\nThe Semantic Knowledge Graph has numerous applications, including automatically building ontologies, identification of trending topics over time, predictive analytics on timeseries data, root-cause analysis surfacing concepts related to failure scenarios from free text, data cleansing, document summarization, semantic search interpretation and expansion of queries, recommendation systems, and numerous other forms of anomaly detection. The main contribution of this paper is the introduction of the the Semantic Knowledge Graph, a novel and compact new graph model that can dynamically materialize and score the relationships between any entities represented within a corpus of documents."}, {"heading": "ACKNOWLEDGMENT", "text": "The authors would like to thank CareerBuilder for their sponsorship of this research and development. In particular, the authors thank Daniel Crouch, David Bernal, Lamar Payson, and Jacob Maggio, who also contributed their ideas and code reviews during the development of the semantic knowledge graph, as well as Colin Field, Matt McNair, Eric Presley, and Abdel Tefridj for their support of the development and open sourcing of the referenced implementation."}], "references": [{"title": "Scalable knowledge harvesting with high precision and high recall", "author": ["Ndapandula Nakashole", "Martin Theobald", "Gerhard Weikum"], "venue": "In Proceedings of WSDM", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "Algorithm and tool for automated ontology merging and alignment", "author": ["Natalya Fridman Noy", "Mark A Musen"], "venue": "In Proceedings of the AAAI 2000.,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2000}, {"title": "Development of an automated ontology generator for analyzing customer concerns", "author": ["Meghan Daly", "Fletcher Grow", "Mackenzie Peterson", "Jeremy Rhodes", "Robert L Nagel"], "venue": "In Systems and Information Engineering Design Symposium (SIEDS),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2015}, {"title": "Knowledge vault: A web-scale approach to probabilistic knowledge fusion", "author": ["Xin Dong", "Evgeniy Gabrilovich", "Geremy Heitz", "Wilko Horn", "Ni Lao", "Kevin Murphy", "Thomas Strohmann", "Shaohua Sun", "Wei Zhang"], "venue": "In Proceedings of KDD", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2014}, {"title": "Crowdsourced query augmentation through semantic discovery of domain-specific jargon", "author": ["Khalifeh AlJadda", "Mohammed Korayem", "Trey Grainger", "Chris Russell"], "venue": "In IEEE Big Data", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2014}, {"title": "Pgmhd: A scalable probabilistic graphical model for massive hierarchical data problems", "author": ["K. AlJadda", "M. Korayem", "C. Ortiz", "T. Grainger", "J.A. Miller", "W.S. York"], "venue": "In Big Data (Big Data),", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2014}, {"title": "Using tf-idf to determine word relevance in document queries", "author": ["Juan Ramos"], "venue": "In Proceedings of the first instructional conference on machine learning,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2003}], "referenceMentions": [{"referenceID": 0, "context": "Other approaches (DeepDive [8], Nell2RDF [9], and PROSPERA [10]) crawl the web and use machine learning and natural language processing to build web-scale knowledge graphs.", "startOffset": 59, "endOffset": 63}, {"referenceID": 1, "context": "While ontology learning systems are typically able to automate much of the ontology building (and sometimes maintenance) process, this comes at the expense of a loss of accuracy due to the replacement of human experts with more error-prone algorithms [11\u201315].", "startOffset": 251, "endOffset": 258}, {"referenceID": 2, "context": "While ontology learning systems are typically able to automate much of the ontology building (and sometimes maintenance) process, this comes at the expense of a loss of accuracy due to the replacement of human experts with more error-prone algorithms [11\u201315].", "startOffset": 251, "endOffset": 258}, {"referenceID": 3, "context": "While ontology learning systems are typically able to automate much of the ontology building (and sometimes maintenance) process, this comes at the expense of a loss of accuracy due to the replacement of human experts with more error-prone algorithms [11\u201315].", "startOffset": 251, "endOffset": 258}, {"referenceID": 4, "context": "Use Case: As an example use case, we leveraged the SKG to clean a list of relationships mined from search engine query logs using a similar methodology to that described in [19, 20].", "startOffset": 173, "endOffset": 181}, {"referenceID": 5, "context": "Use Case: As an example use case, we leveraged the SKG to clean a list of relationships mined from search engine query logs using a similar methodology to that described in [19, 20].", "startOffset": 173, "endOffset": 181}, {"referenceID": 6, "context": "In other scenarios where no category for the document is known a priori, it is possible to instead leverage other statistics from the terms-docs inverted index, such as tf-idf scoring of each term within the document, to find the set of most globally interesting terms within the document [22].", "startOffset": 289, "endOffset": 293}], "year": 2016, "abstractText": "This paper describes a new kind of knowledge representation and mining system which we are calling the Semantic Knowledge Graph. At its heart, the Semantic Knowledge Graph leverages an inverted index, along with a complementary uninverted index, to represent nodes (terms) and edges (the documents within intersecting postings lists for multiple terms/nodes). This provides a layer of indirection between each pair of nodes and their corresponding edge, enabling edges to materialize dynamically from underlying corpus statistics. As a result, any combination of nodes can have edges to any other nodes materialize and be scored to reveal latent relationships between the nodes. This provides numerous benefits: the knowledge graph can be built automatically from a real-world corpus of data, new nodes along with their combined edges can be instantly materialized from any arbitrary combination of preexisting nodes (using set operations), and a full model of the semantic relationships between all entities within a domain can be represented and dynamically traversed using a highly compact representation of the graph. Such a system has widespread applications in areas as diverse as knowledge modeling and reasoning, natural language processing, anomaly detection, data cleansing, semantic search, analytics, data classification, root cause analysis, and recommendations systems. The main contribution of this paper is the introduction of a novel system the Semantic Knowledge Graph which is able to dynamically discover and score interesting relationships between any arbitrary combination of entities (words, phrases, or extracted concepts) through dynamically materializing nodes and edges from a compact graphical representation built automatically from a corpus of data representative of a knowledge domain. The source code for our Semantic Knowledge Graph implementation is being published along with this paper to facilitate further research and extensions of this work.", "creator": "LaTeX with hyperref package"}}}