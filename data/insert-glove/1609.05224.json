{"id": "1609.05224", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Aug-2016", "title": "Prioritised Default Logic as Argumentation with Partial Order Default Priorities", "abstract": "We philex express heliozelidae Brewka ' -11 s prioritised default zfc logic (kostal PDL) teg as aridi argumentation using ASPIC +. By representing PDL as argumentation and ox-5 designing lead-up an argument preference .242 relation patillo that takes the trepashkin argument storani structure oldenburg into iraq account, impetigo we re-packaged prove blueliners that str95bb the chimpanzee conclusions dadayev of the leidig justified arguments shafranik correspond plugs to kobyakov the PDL tabley extensions. nyirenda We will arpe first bruguera assume that the default priority is benguet total, and then generalise 6136 to 3.6-million the rainer case where it light is .70 a djimi partial tortuously order. This mambe provides phytoseiidae a characterisation of non - 21.99 monotonic inference mahabubnagar in kari\u0107 PDL ethno-religious as an exchange of socol argument and counter - xylophanes argument, dispassion providing scepticism a kh-11 basis gillespe for curva distributed non - monotonic spawar reasoning glossaries in sharifs the sainty form bready of dialogue.", "histories": [["v1", "Thu, 25 Aug 2016 20:51:07 GMT  (51kb)", "http://arxiv.org/abs/1609.05224v1", "50 pages, 4 figures"]], "COMMENTS": "50 pages, 4 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["anthony p young", "sanjay modgil", "odinaldo rodrigues"], "accepted": false, "id": "1609.05224"}, "pdf": {"name": "1609.05224.pdf", "metadata": {"source": "CRF", "title": "Prioritised Default Logic as Argumentation with Partial Order Default Priorities", "authors": ["Anthony P. Young", "Sanjay Modgil", "Odinaldo Rodrigues"], "emails": ["peter.young@kcl.ac.uk", "sanjay.modgil@kcl.ac.uk", "odinaldo.rodrigues@kcl.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 9.\n05 22\n4v 1\n[ cs\n.A I]\nContents"}, {"heading": "1 Introduction 2", "text": ""}, {"heading": "2 Background 4", "text": "2.1 Notation Used in this Paper . . . . . . . . . . . . . . . . . . . . . 4 2.2 The ASPIC+ Framework . . . . . . . . . . . . . . . . . . . . . . . 4 2.3 Brewka\u2019s Prioritised Default Logic . . . . . . . . . . . . . . . . . 8\n3 From ASPIC+ to PDL 9\n3.1 Representing PDL in ASPIC+ . . . . . . . . . . . . . . . . . . . . 9 3.2 A Suitable Argument Preference Relation . . . . . . . . . . . . . 10 3.3 The Representation Theorem . . . . . . . . . . . . . . . . . . . . 18\n3.3.1 Non-Blocked Defaults . . . . . . . . . . . . . . . . . . . . 18 3.3.2 Existence and Uniqueness of Stable Extensions . . . . . . 21 3.3.3 The Representation Theorem: Statement and Proof . . . 24\n3.4 Satisfaction of Rationality Postulates . . . . . . . . . . . . . . . . 27 3.4.1 The Stable Extension is Grounded . . . . . . . . . . . . . 27\n1The results of Section 3 first appeared in the preprint [23] and have been published in the conference proceedings of AAMAS2016 [24]. This paper gives the full proofs of these results.\n3.4.2 The Trivialisation and Rationality Theorems . . . . . . . 31 3.4.3 Inconsistent Arguments . . . . . . . . . . . . . . . . . . . 32\n3.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32"}, {"heading": "4 On Lifting the Assumption of a Total Order Default Priority 33", "text": "4.1 The Argument Preference Relation based on Partial Order Default Priorities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.1.1 A Representation of Rules and their Ordering using Strings 33 4.1.2 Algorithm and Example Calculation . . . . . . . . . . . . 34 4.1.3 Properties of the Generalised SP Order . . . . . . . . . . 37 4.1.4 The Generalised Argument Preference Relation for <D Partial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.2 The Representation Theorem for Partial Order Default Priorities 41\n4.2.1 Linearisation of the Argument Preference Relation and Spanning Subgraphs . . . . . . . . . . . . . . . . . . . . . 41 4.2.2 Existence of Stable Extensions in the Partial Order Case 42 4.2.3 Proof of the Representation Theorem . . . . . . . . . . . 43\n4.3 Satisfaction of Rationality Postulates . . . . . . . . . . . . . . . . 46 4.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47"}, {"heading": "5 Conclusions 47", "text": "5.1 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 5.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48"}, {"heading": "1 Introduction", "text": "Dung\u2019s abstract argumentation theory [11] has become established as a means for unifying various nonmonotonic logics (NMLs) [4,20,22], where the inferences of a given NML can be interpreted as conclusions of justified arguments. Abstract argumentation defines \u201cjustified arguments\u201d by making use of principles familiar in everyday reasoning and debate. This renders the process of inference in the NML transparent and amenable to human inspection and participation, and serves as a basis for distributed reasoning and dialogue.\nMore precisely, relating NMLs and argumentation is to endow the NML with argumentation semantics. This has already been done for default logic [11], logic programming [11], defeasible logic [12] and preferred subtheories [16]. This allows the application of argument game proof theories [15] to the process of inference in these NMLs, and the generalisation of these dialectical proof theories to distributed reasoning amongst computational agents, where agents can engage in argumentation-based dialogues [1, 14, 17].\nAbstract argumentation has been upgraded to structured argumentation theory [3], one example of which is the ASPIC+ framework for structured argumentation [16]. In ASPIC+, arguments are constructed from premises and deductive or defeasible rules of inference. The conclusions of arguments can contradict each other and hence arguments can attack each other. A preference relation\nover the arguments can be used to determine which attacks succeed as defeats. The arguments and defeats instantiate an abstract argumentation framework, where the justified arguments are determined using Dung\u2019s method. The conclusions of the justified arguments are then identified with the nonmonotonic inferences from the underlying premises and rules of inference. The advantages of ASPIC+ are that the framework provides a systematic and general method of endowing non-monotonic logics with argumentation semantics, and identifies sufficient conditions on the underlying logic and preference relations that guarantee the satisfaction of various normatively rational desiderata [10].\nThis paper endows Brewka\u2019s prioritised default logic (PDL) [7] with argumentation semantics. PDL is an important NML because it upgrades default logic (DL) [19] with an explicit priority relation over defaults, so that, for example, one can account for recent information taking priority over information in the distant past. PDL has also been used to represent the (possibly conflicting) beliefs, obligations, intentions and desires (BOID) of agents, and model how these different categories of mental attitudes override each other in order to generate goals and actions that attain those goals [9].\nWe prove a correspondence between inferences in PDL and the conclusions of the justified arguments defined by the argumentation semantics. We realise these contributions by appropriately representing PDL in ASPIC+. The main challenges involve understanding how priorities over defaults in PDL can be represented as an ASPIC+ argument preference relation, and then applying the properties of this preference relation to prove that the extensions of PDL correspond to the conclusions of justified arguments.\nThis paper has five sections. In Section 2, we review ASPIC+, abstract argumentation, and PDL. In Section 3 we present an instantiation of ASPIC+ to PDL when the default priority is total. The key results are the design of an appropriate argument preference relation (Section 3.2), and showing that this argument preference relation guarantees that the conclusions of the justified arguments correspond exactly to the PDL extensions by the representation theorem (Section 3.3). We then investigate some properties and directly prove that the normative rationality postulates of [10] are satisfied (Section 3.4).2\nIn Section 4 we lift the assumption that the priority order on the defaults is total. Following the pattern of the previous section we generalise the argument preference (Section 4.1) to accommodate for partial order default priorities. We then prove a generalised representation theorem (Sections 4.2) and prove a partial result concerning the satisfaction of the rationality postulates of [10] (Section 4.3). We conclude in Section 5 with suggestions for future work.\n2But in this case we are not leveraging the properties of ASPIC+ to achieve this. We will discuss this point in Section 5."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 Notation Used in this Paper", "text": "In this paper: \u201c:=\u201d is read \u201cis defined as\u201d. WLOG stands for \u201cwithout loss of generality\u201d. N denotes the set of natural numbers. We denote set difference with \u2212. For two sets A, B, A\u2296B := (A\u2212B)\u222a(B \u2212A) denotes their symmetric difference. If f : X \u2192 Y is a function and A \u2286 X , f(A) \u2286 Y is the image set of A in Y under f . For a set X its power set is P (X) and its finite power set (set of all finite subsets) is Pfin(X). X \u2286fin Y iff X is a finite subset of Y , therefore X \u2208 Pfin(Y ) \u21d4 X \u2286fin Y . Undefined quantities are denoted by \u2217, for example 1/0 = \u2217 in the real numbers. Order isomorphism is denoted by \u223c=.\nIf \u3008P, .\u3009 is a preordered set then the strict version of the preorder is a < b \u21d4 [a . b, b 6. a], which is also a strict partial order. If < is a strict partial order on P and U \u2286 P , then we define the set max< U := {x \u2208 U (\u2200y \u2208 U)x 6< y} \u2286 U , i.e. the set of all <-maximal elements of U . We define the set min< U analogously. For a set X we define the set of possible strict partial orders on X to be PO(X) := { <\u2286 X2 < is a strict partial order } . Similarly, the set of all possible strict total orders onX is TO(X) := { <\u2286 X2 < is a strict total order }\n\u2282 PO(X). We will use the terms \u201ctotal (order)\u201d and \u201clinear (order)\u201d interchangeably. We will also call totally ordered sets either \u201ctosets\u201d or \u201cchains\u201d.\n2.2 The ASPIC+ Framework\nAbstract argumentation abstracts from the internal logical structure of arguments, the nature of defeats and how they are determined by preferences, and consideration of the conclusions of the arguments [11]. However, these features are referenced when studying whether any given logical instantiation of a framework yields complete extensions that satisfy the rationality postulates of [10]. ASPIC+ [16] provides a structured account of abstract argumentation, allowing one to reference the above features, while at the same time accommodating a wide range of instantiating logics and preference relations in a principled manner. ASPIC+ then identifies conditions under which complete extensions defined by the arguments, attacks and preferences, satisfy the rationality postulates of [10].\nIn ASPIC+, the tuple \u3008L, \u2212, Rs, Rd, n\u3009 is an argumentation system, where L is a logical language and \u2212 : L \u2192 P(L) is the contrary function \u03b8 7\u2192 \u03b8 where \u03b8 is the set of wffs that are inconsistent with \u03b8. Let \u03b81, . . . , \u03b8m, \u03c6 \u2208 L be wffs for m \u2208 N, Rs is the set of strict inference rules of the form (\u03b81, . . . , \u03b8m \u2192 \u03c6), denoting that if \u03b81, . . . , \u03b8m are true then \u03c6 is also true, and Rd is the set of defeasible inference rules of the form (\u03b81, . . . , \u03b8m \u21d2 \u03c6), denoting that if \u03b81, . . . , \u03b8m are true then \u03c6 is tentatively true. Note Rs\u2229Rd = \u2205. For a strict or defeasible rule r = (\u03b81, . . . \u03b8m \u2192 / \u21d2 \u03c6), we define Ante(r) := {\u03b81, . . . , \u03b8m} \u2286fin L,3 and Cons(r) := \u03c6 \u2208 L. Finally, n : Rd \u2192 L is a partial function that assigns a name to some of the defeasible rules. For any S \u2286 L we define the set ClRs(S) \u2286 L to be the smallest superset of S that also contains Cons(r) for\n3Note it is possible to have m = 0 and hence Ante(r) = \u2205.\nall r \u2208 Rs such that Ante(r) \u2286 ClRs(S). We call ClRs the closure under strict rules operator.\nIn ASPIC+, a knowledge base is a set K := Kn \u222a Kp \u2286 L where Kn is the set of axioms and Kp is the set of ordinary premises. Note that Kn \u2229 Kp = \u2205. Given an argumentation system and K, arguments are defined inductively:\n1. (Base) [\u03b8] is a singleton argument with \u03b8 \u2208 K, conclusion Conc([\u03b8]) := \u03b8, premise set Prem ([\u03b8]) := {\u03b8} \u2286 K, top rule TopRule([\u03b8]) := \u2217 and set of subarguments Sub ([\u03b8]) := {[\u03b8]}.\n2. (Inductive) Let A1, . . . , An be arguments with respective conclusions Conc(A1), . . . , Conc(An) and premise sets Prem(A1), . . . , P rem(An). If there is a rule r := (Conc (A1) , . . . , Conc (An) \u2192 / \u21d2 \u03c6) \u2208 R, then B := [A1, . . . , An \u2192 / \u21d2 \u03c6] is also an argument with Conc(B) = \u03c6, premises Prem(B) :=\n\u22c3n i=1 Prem(Ai), TopRule(B) = r \u2208 R and set of\nsubarguments Sub(B) := {B} \u222a \u22c3n\ni=1 Sub(Ai).\nLet A be the (unique) set of all arguments freely constructed following the above rules. It is clear that arguments are finite objects in that each argument has finitely many premises, and take finitely many rules to reach its conclusion. We define the conclusion map Conc : A \u2192 L : A 7\u2192 Conc(A). We can generalise this to arbitrary sets of arguments (abuse of notation):\nConc : P (A) \u2192 P (L) : S 7\u2192 Conc(S) := \u22c3\nA\u2208S\nConc(A). (2.1)\nTwo strict or defeasible rules are equal iff they have the same antecedent sets, consequents and name syntactically in the underlying L. Two arguments are equal iff they are constructed identically as described above. More precisely, we can define equality of arguments inductively. The base case would be two singleton arguments [\u03b8], [\u03c6] are equal iff \u03b8 and \u03c6 are syntactically the same formulae. Given n arguments A1, . . . , An and two equal rules r1 and r2 (either both strict or both defeasible) with antecedent {Conc (Ai)} n i=1, such that B1 is the rule r1 appended to the Ai\u2019s, and B2 is the rule r2 appended to the Ai\u2019s, then B1 and B2 are equal arguments.\nWe say A is a subargument of B iff A \u2208 Sub(B) and we write A \u2286arg B. We say A is a proper subargument of B iff A \u2208 Sub(B) \u2212 {B} and we write A \u2282arg B. It can be shown that \u2286arg is a preorder on Sub(B). A set of arguments is subargument closed iff it is \u2286arg-down closed. Clearly, for every defeasible rule r in an argument A, there is a subargument of A with r as its top rule, by the inductive construction of arguments.\nAn argument A \u2208 A is firm iff Prem(A) \u2286 Kn. Further, SR(A) \u2286 Rs is the set of strict rules applied in constructing A, and DR(A) \u2286 Rd is the set of defeasible rules applied in constructing A. We also define Premn(A) := Prem(A) \u2229 Kn and Premp(A) := Prem(A) \u2229 Kp. An argument A is strict iff DR(A) = \u2205, else A is defeasible. We can generalise DR ( \u00b7 ) to sets as well just like Equation 2.1 for Conc ( \u00b7 ).\nGiven R \u2286 Rd, we introduce the set of all arguments freely constructed with defeasible rules restricted to those in R as the set Args(R) \u2286 A, which are all arguments with premises in K, strict rules in Rs and defeasible rules in R. Formally, Args(R) is defined inductively just as how arguments are constructed, but with the choice of defeasible rules restricted to those in R. It is easy to show that this definition is equivalent to\nA \u2208 Args(R) \u21d4 DR(A) \u2286 R. (2.2)\nClearly, Args(Rd) = A. Given R, Args(R) exists and is unique. Let S \u2286fin A. The set of all strict extensions of S is the set StExt (S) where\nA \u2208 StExt (S) \u21d4DR(A) = DR(S), SR(A) \u2287 SR(S),\nP remp(A) = Premp(S), P remn(A) \u2287 Premn(S).\nA set S \u2286 A is closed under strict extensions iff for all T \u2286fin S, StExt (T ) \u2286 S.\nLemma 2.1. The set Args(R), for any R \u2286 Rd, is closed under strict extensions and subarguments.\nProof. If A \u2208 Args(R) and B \u2286 A, then DR(B) \u2286 DR(A) \u2286 R so DR(B) \u2286 R and hence B \u2208 Args(R), therefore Args(R) is subargument closed. Now let T \u2286fin Args(R), so for all B \u2208 T , DR(B) \u2286 R, therefore DR(T ) := \u22c3\nB\u2208T DR(B) \u2286 R. Let A \u2208 StExt (T ), then DR(A) = DR(T ) \u2286 R and hence A \u2208 Args (R). Therefore, StExt (T ) \u2286 Args (R), therefore Args(R) is closed under strict extensions.\nAn argument A attacks another argument B, denoted as A \u21c0 B, iff at least one of the following hold, where:\n1. A is said to undermine attack B on the (singleton) subargument B\u2032 = [\u03c6] iff there is some \u03c6 \u2208 Premp(B) such that Conc(A) \u2208 \u03c6.\n2. A is said to rebut attack B on the subargument B\u2032 iff there is some B\u2032 \u2286arg B such that r := TopRule (B\u2032) \u2208 Rd, \u03c6 := Cons(r) and Conc(A) \u2208 \u03c6.\n3. A is said to undercut attack B on the subargument B\u2032 iff there is some B\u2032 \u2286arg B such that r := TopRule(B \u2032) \u2208 Rd and Conc(A) \u2208 n(r).\nSee [16, Section 2] for a further discussion of why attacks are distinguished in this way. We abuse notation to define the attack relation as \u21c0\u2286 A2 such that (A, B) \u2208\u21c0\u21d4 A \u21c0 B. Notice that by the transitivity of \u2286arg, if A \u21c0 B and B \u2286arg C, then A \u21c0 C.\nA preference relation over arguments is then used to determine which attacks succeed as defeats. We denote the preference -\u2286 A2 (not necessarily a preorder for now) such that A - B \u21d4 B is at least as preferred as A. Strict preference and equivalence are, respectively, A \u227a B \u21d4 [A - B, B 6- A] and A \u2248 B \u21d4 [A - B, B - A]. We define a defeat as\nA \u2192\u0592 B \u21d4 (\u2203B\u2032 \u2286arg B) [A \u21c0 B \u2032, A 6\u227a B\u2032] . (2.3)\nThat is to say, A defeats B (on B\u2032) iff A attacks B on the subargument B\u2032, and B\u2032 is not strictly preferred to A. Notice the comparison is made at the subargument B\u2032 instead of the whole argument B. We abuse notation to define the defeat relation as \u2192\u0592 \u2286 A2 such that (A, B) \u2208 \u2192\u0592 \u21d4 A \u2192\u0592 B. A set of arguments S \u2286 A is conflict-free (cf) iff \u2192\u0592 \u2229 S2 = \u2205.4 Notice that by the transitivity of \u2286arg and that the preference comparison is made at the defeated subargument, if A \u2192\u0592 B and B \u2286arg C, then A \u2192\u0592 C. As relations, \u2192\u0592 \u2286\u21c0.\nPreferences between arguments are calculated from the argument structure by comparing arguments at their fallible components, i.e. the ordinary premises and defeasible rules. This is achieved by endowing Kp and Rd with preorders .K and .D respectively, where (e.g.) r1 .D r2 iff r2 is just as preferred or more preferred than r1 (and analogously for .K). These preorders are then aggregated to a set-comparison relation E between the sets of premises and / or defeasible rules of the arguments, and then finally to - \u2286 A2, following the method in [16, Section 5].5 We will use a modified version of this lifting, which will be explained in Section 3.2.\nGiven the preference relation - between arguments, we call the structure \u3008A, \u21c0, -\u3009 an ASPIC+ SAF (structured argumentation framework), or attack graph. Its corresponding defeat graph is \u3008A, \u2192\u0592\u3009, where \u2192\u0592 is defined in terms of \u21c0 and - as in Equation 2.3.\nGiven \u3008A, \u2192\u0592\u3009 one can then evaluate the extensions under Dung\u2019s abstract argumentation semantics, and thus identify the inferences defined by argumentation as the conclusions of the justified arguments. We now recap the key definitions of [11]. An argumentation framework is a directed graph \u3008A, \u2192\u0592\u3009, where A is the set of arguments and \u2192\u0592 \u2286 A2 is the defeat relation, such that A \u2192\u0592 B means A is a (successful) counterargument against B. The argumentation frameworks we consider are defeat graphs, but this is a general definition.\nLet S \u2286 A and A, B \u2208 A. S defeats B iff (\u2203A \u2208 S)A \u2192\u0592 B. S is conflictfree (cf) iff \u2192\u0592 \u2229S2 = \u2205. S defends A iff (\u2200B \u2208 A) [B \u2192\u0592 A \u21d2 S defeats B]. The characteristic function is \u03c7 : P (A) \u2192 P (A), such that \u03c7(S) := {A \u2208 A S defends A} \u2286 A. S is an admissible extension iff S is cf and S \u2286 \u03c7(S). An admissible extension S is: a complete extension iff S = \u03c7(S); a preferred extension iff S is a \u2286-maximal complete extension; the grounded extension iff S is the \u2286-least complete extension; a stable extension iff S is complete and defeats all arguments B \u2208 A\u2212 S.\nLet S := {complete, preferred, grounded, stable} be the set of Dung semantics. An argument A \u2208 A is sceptically (credulously) justified under the semantics s \u2208 S iff A belongs to all (at least one) of the s-extensions of \u3008A, \u2192\u0592\u3009.\nInstantiations of ASPIC+ should satisfy some properties to ensure they are rational [10]. Given an instantiation let \u3008A, \u21c0, -\u3009 be its ASPIC+ attack graph\n4Note that [16] studies two different notions of cf sets: one where no two arguments attack each other, and the other where no two arguments defeat each other. We choose the latter notion of cf as this is more commonplace in argumentation formalisms that distinguish between attacks and defeats, e.g. in [18].\n5Note there are many other ways to lift a preference < on a set of objects X to compare subsets of X in various ways that are \u201ccompatible\u201d with < [2].\nwith corresponding defeat graph \u3008A, \u2192\u0592\u3009. Let E be any complete extension. The Caminada-Amgoud rationality postulates state:\n1. (Subargument closure) E is subargument closed.\n2. (Closure under strict rules) E satisfies Conc(E) = ClRs [Conc(E)], where Conc (E) is defined in Equation 2.1.\n3. (Consistency) Conc(E) is consistent.6\nAn ASPIC+ instantiation is normatively rational iff it satisfies these rationality postulates. These postulates may be proved directly given an instantiation. ASPIC+ also identifies sufficient conditions for an instantiation to satisfy these postulates [16, Section 4], which we will discuss in Section 5."}, {"heading": "2.3 Brewka\u2019s Prioritised Default Logic", "text": "In this section we recap Brewka\u2019s prioritised default logic (PDL) [7]. We work in first order logic (FOL) of arbitrary signature where the set of first-order formulae is FL and the set of closed first order formulae7 a.k.a. sentences is SL \u2286 FL, with the usual quantifiers and connectives. Entailment is denoted by |=. Logical equivalence of formulae is denoted by \u2261. Given S \u2286 FL, the deductive closure of S is Th(S), and given \u03b8 \u2208 FL, the addition operator + : P(FL)\u00d7FL \u2192 P (FL) is defined as S + \u03b8 := Th(S \u222a {\u03b8}).\nA normal default is an expression \u03b8:\u03c6 \u03c6\nwhere \u03b8, \u03c6 \u2208 FL and read \u201cif \u03b8 is the case and \u03c6 is consistent with what we know, then jump to the conclusion \u03c6 even if it does not deductively follow\u201d. In this case we call \u03b8 the antecedent and \u03c6 the consequent. A normal default \u03b8:\u03c6\n\u03c6 is closed iff \u03b8, \u03c6 \u2208 SL. We will assume\nall defaults are closed and normal unless stated otherwise. Given S \u2286 SL, a default is active (in S) iff [\u03b8 \u2208 S, \u03c6 /\u2208 S, \u00ac\u03c6 /\u2208 S].\nA finite prioritised default theory (PDT) is a structure T := \u3008D, W, <\u3009, where the set of facts W \u2286 SL is not necessarily finite and \u3008D, <\u3009 is a finite strict partially ordered set of defaults that nonmonotonically extend W . The priority relation is such that d\u2032 < d \u21d4 d is more8 prioritised than d\u2032. All PDTs in this paper are finite.\nThe inferences of a PDT T = \u3008D,W,<\u3009 are defined by its extensions. Let <+\u2287< be a linearisation of <. A prioritised default extension (with respect to <+) (PDE) is a set E := \u22c3\ni\u2208N Ei \u2286 SL built inductively as:\n6Notice by properties 2 and 3 above ClRs (Conc (E)) is consistent. ASPIC + distinguishes this into direct and indirect consistency given that Rs is in general arbitrary and do not have to be the rules of inference of classical logic. We will not make this distinction because our underlying logic will be first order logic (FOL) (Section 3.1). Further, consistency in the abstract logic of ASPIC+ is expressed in terms of the contrary function, but since our contrary function will just be classical negation, we can take the usual meaning of consistency in FOL.\n7i.e. first order formulae without free variables 8 We have defined the order dually to [7] so as to comply with orderings over the ASPIC+ defeasible inference rules. This goes against the tradition in NML where the smaller item in < is the more preferred one.\nE0 := Th(W ) and (2.4)\nEi+1 :=\n{\nEi + \u03c6, if property 1 Ei, else (2.5)\nwhere \u201cproperty 1\u201d abbreviates \u201c\u03c6 is the consequent of the <+-greatest9 default d active in Ei\u201d. Intuitively, one first generates all classical consequences from the facts W , and then iteratively adds the nonmonotonic consequences from the highest priority default to the lowest. Notice if W is inconsistent then E0 = E = FL. For this paper we will assume W is always consistent.\nFor finite D it can be shown that the ascending chain Ei \u2286 Ei+1 stabilises at some finite i \u2208 N and that E is consistent provided that W is consistent. E does not have to be unique because there are many distinct linearisations of <. We say T sceptically infers \u03b8 \u2208 SL iff \u03b8 \u2208 E for all extensions E of T .\nA PDT T for which < is a strict total order is a linearised PDT (LPDT). If < is total then there is only one way to apply the defaults in D by Equation 2.5, hence the extension is unique. We will use the notation <+ to emphasise that the priority is total, and the notation T+ to denote an arbitrary LPDT.\nFor the rest of this paper, if we declare T to be a PDT, we mean T = \u3008D,W,<\u3009 where each component is defined above, and we make no further assumptions on each component. If we declare T+ to be an LPDT, we mean T+ = \u3008D,W,<+\u3009 where <+ is a strict total order on D.\n3 From ASPIC+ to PDL\n3.1 Representing PDL in ASPIC+\nWe now instantiate ASPIC+ to PDL. Let T+ := \u3008D, W, <+\u3009 be an LPDT.10\n1. Our arguments are expressed in FOL, so our set of wffs L is FL.\n2. The contrary function \u2212 : FL \u2192 P (FL) syntactically defines conflict in terms of classical negation. For all \u03b8 \u2208 FL, \u03b8 = {\u00ac\u03b8} unless \u03b8 has the syntactic form \u00ac\u03c6 for some \u03c6 \u2208 FL, then \u03b8 = {\u03c6}. As \u03b8 is singleton, we will abuse notation and write \u03b8 to refer to its element.\n3. The set of strict rules Rs characterises inference in FOL. Notice Rs is closed under transposition, i.e. for all 1 \u2264 i \u2264 n \u2208 N+,\n(\u03b81, \u03b82, . . . , \u03b8i\u22121, \u03b8i, \u03b8n+1, . . . , \u03b8n \u2192 \u03c6) \u2208 Rs\n\u21d2 (\u03b81, \u03b82, . . . , \u03b8i\u22121,\u2212\u03c6, \u03b8n+1, . . . , \u03b8n \u2192 \u2212\u03b8i) \u2208 Rs.\nWe leave the proof theory implicit. ClRs instantiates to deductive closure.\n9See Footnote 8. 10We will lift this assumption of a total order priority in Section 4.\n4. The set of defeasible rules Rd is defined as:\nRd :=\n{\n(\u03b8 \u21d2 \u03c6) \u03b8 : \u03c6\n\u03c6 \u2208 D\n}\n,\nwith the naming function n \u2261 \u2217. Clearly, there is a bijection f where\nf : D \u2192 Rd : \u03b8 : \u03c6\n\u03c6 7\u2192 f\n(\n\u03b8 : \u03c6\n\u03c6\n)\n:= (\u03b8 \u21d2 \u03c6) (3.1)\nand we will define the strict version of the preorder \u2264D over Rd as 11\n(\u03b8 \u21d2 \u03c6) <D (\u03b8 \u2032 \u21d2 \u03c6\u2032) \u21d4\n\u03b8 : \u03c6\n\u03c6 <+\n\u03b8\u2032 : \u03c6\u2032\n\u03c6\u2032 . (3.2)\nWe can see that the strict toset \u3008Rd, <D\u3009 is order isomorphic to \u3008D, < +\u3009.\n5. The set of axiom premises is Kn = W , because we take W to be the set of facts. Furthermore, Kp = \u2205.\nThe set A of ASPIC+ arguments are defined as in Section 2.2.12 All arguments are firm because Kp = \u2205, and so there are no undermining attacks. As n is undefined, no attack can be an undercut. Therefore, we only have rebut attacks,\nA \u21c0 B \u21d4 (\u2203B\u2032, B\u2032\u2032 \u2286arg B) B \u2032 =\n[ B\u2032\u2032 \u21d2 Conc(A) ] . (3.3)\nDefeats are defined as in Equation 2.3. In the next section, we will define the argument preference -, based on the strict total order <D over Rd."}, {"heading": "3.2 A Suitable Argument Preference Relation", "text": "We wish to define a suitable argument preference relation such that the conclusion set of the stable extension defined by \u2192\u0592 corresponds to the extension of the underlying PDT.13 The first place to look for such a relation is in the existing relations of ASPIC+ [16, Definition 19]. However, simple counterexamples can be devised to show the inferences of the PDT and its argumentation counterpart do not correspond.\nThe difference between PDL and ASPIC+ is in how blocked defaults are treated. In PDL, blocked defaults are simply excluded from the extension. In ASPIC+, it is possible to construct arguments with defeasible rules that correspond to blocked defaults. If <+ \u223c= <D such that <\n+ is arbitrary, there is no guarantee that the blocked defaults will be positioned in the chain <+ such that arguments with blocked defaults are always defeated by arguments with\n11From Footnote 8, we do not need to define <D as the order-theoretic dual to < +, avoiding potential confusion as to which item is more preferred. 12As Rs is a countably infinite set, A is also a countably infinite set. 13In Section 3.4, we will show that for the resulting defeat graphs there is only one extension in that is stable, grounded and preferred.\nonly non-blocked defaults.14 To ensure that arguments with blocked defaults are defeated and hence the conclusions of the justified arguments form the extension of the PDT, we need to rearrange the rules in Rd to take into account the structure of arguments. ASPIC+ does allow for explicit reference to argument structure, i.e. we can tell which defeasible rules preceed which within an argument.\nRearranging <D to take argument structure into account captures the PDL meaning of \u201cactive\u201d default, because defaults are added to Ei when its prerequisite is inferred. This rearrangement will mean that every defeasible rule r corresponding to a blocked default will be less preferred than the rules which make up arguments that rebut the argument with r as its top rule. We now devise a new ASPIC+ argument preference relation which incorporates the argument structure into the preorder <D.\nMore formally, given any strict total order <D on Rd, we first define a transformation <D 7\u2192 <SP , where the subscript SP stands for structure-preference. This sorts the defeasible rules in a way compatible with both the priority <D and their logical structure.\nThe set Rd is finite because we have assumed that D is finite (Sections 2.3 and 3.1). Let 1 \u2264 i \u2264 |Rd| =: N \u2208 N. We define ai \u2208 Rd to be the <D-greatest element of the following set:\n{\nr \u2208 Rd Ante(r) \u2286 Conc\n[\nArgs\n(\ni\u22121 \u22c3\nk=1\n{ak}\n)]}\n\u2212\ni\u22121 \u22c3\nj=1\n{aj} . (3.4)\nThe intuition is: a1 is the most preferred rule whose antecedent is inferred by the conclusions of all strict arguments, a2 is the next most preferred rule, whose antecedent is amongst the conclusions of all arguments having at most a1 as a defeasible rule. Similarly, a3 is the next most preferred rule, whose antecedent is amongst the conclusions of all arguments having at most a1 and a2 as defeasible rules, and so on until all of the rules ofRd are exhausted. Notice that the second union after the set difference in Equation 3.4 ensures that once a rule is applied it cannot be applied again. We then define <SP as (notice the dual order)\nai <SP aj \u21d4 j < i. (3.5)\nWe define the non-strict order to be ai \u2264SP ai \u21d4 [ai = aj or ai <SP aj]. This makes sense because i 7\u2192 ai is bijective betweenRd and {1, 2, 3, . . . , N}. Clearly <SP is a strict total order on Rd. We call this the structure preference order on Rd, which exists and is unique given <D. This means the transformation <D 7\u2192<SP is functional, where <D is total on Rd.\nNow let <D be any strict partial order on Rd. We define the strict set comparison relation on Pfin (Rd) corresponding to <D. For \u0393, \u0393\n\u2032 \u2286fin Rd, the relation \u22b3DEli, called the disjoint elitist order, is defined as follows:\n\u0393 \u22b3DEli \u0393 \u2032 \u21d4 (\u2203x \u2208 \u0393\u2212 \u0393\u2032) (\u2200y \u2208 \u0393\u2032 \u2212 \u0393)x <D y. (3.6)\n14We will see this explicitly in Example 1 later.\nThe lifting <D 7\u2192 \u22b3DEli is functional. We will focus on the following special case of \u22b3DEli, where instead of <D we have <SP :\n\u0393 \u22b3SP \u0393 \u2032 \u21d4 (\u2203x \u2208 \u0393\u2212 \u0393\u2032) (\u2200y \u2208 \u0393\u2032 \u2212 \u0393)x <SP y. (3.7)\nThe corresponding strict argument preference is, for A,B \u2208 A,\nA \u227aSP B \u21d4 DR(A) \u22b3SP DR(B). (3.8)\nWe define the corresponding non-strict preference as\nA -SP B \u21d4 [DR(A) \u22b3SP DR(B) or DR(A) = DR(B)] (3.9)\nWe now show that -SP satisfies the following properties.\nLemma 3.1. For all A,B \u2208 A, DR(A) \u2286 DR(B) \u21d2 B -SP A.\nProof. If DR(B) = DR(A) then B \u2248 A, so B -SP A. If DR(A) \u2282 DR(B), then DR(A) \u2212 DR(B) = \u2205, which means B \u227aSP A is vacuously true from Equation 3.7 so B -SP A.\nThe following result shows that larger arguments, which potentially can contain more fallible information (i.e. defeasible rules), cannot be more preferred than its (smaller) subarguments.\nCorollary 3.2. For all A,B \u2208 A, if A \u2286arg B then B -SP A.\nProof. It can be shown from how ASPIC+ arguments are constructed (Section 2.2) that A \u2286arg B \u21d2 DR(A) \u2286 DR(B), and then invoke Lemma 3.1.\nCorollary 3.3. Strict arguments are -SP -maximal.\nProof. Let A \u2208 A be strict and B \u2208 A be arbitrary. Assume for contradiction that A \u227aSP B. As DR(A) = \u2205, Equations 3.7 and 3.8 instantiate to: A \u227aSP B \u21d4 (\u2203x \u2208 \u2205) (\u2200y \u2208 DR(B))x <SP y, which is impossible by the first bounded quantifier. Therefore, if A is strict, then for all (\u2200B \u2208 A)A 6\u227aSP B.\nLemma 3.4. Let \u3008P,<\u3009 be a strict toset, then \u3008Pfin (P ) , \u22b3DEli\u3009 is also a strict toset, where \u22b3DEli is defined in Equation 3.6, here with < instead of <D.\nProof. We prove \u22b3DEli is irreflexive, transitive and total on Pfin (P ), assuming that < is a strict total order on P .15 To show irreflexivity, assume for contradiction that there is some \u0393 \u2208 Pfin (P ) such that \u0393 \u22b3DEli \u0393, which by Equation 3.6 is equivalent to a formula whose first bounded quantifier is \u201c(\u2203x \u2208 \u2205)\u201d, which\n15 More generally, it can be shown that for any strict partial order <, the relation \u22b3DEli from Equation 3.6 is acyclic, and hence irreflexive and asymmetric, but not necessarily transitive. If < is a modular order [13, Lemma 3.7], then \u22b3DEli is transitive. Further, if < total (recalling that total orders are modular), then \u22b3DEli is trichotomous, and hence a strict total order.\nis false, so \u22b3DEli is irreflexive. To show transitivity, let n1, \u00b7 \u00b7 \u00b7 , n7 \u2208 N, such that\n{a1, \u00b7 \u00b7 \u00b7 , an1} \u222a {b1, \u00b7 \u00b7 \u00b7 , bn2} \u222a {c1, \u00b7 \u00b7 \u00b7 , cn3} \u222a {d1, \u00b7 \u00b7 \u00b7 , dn4}\n\u222a {e1, \u00b7 \u00b7 \u00b7 , en5} \u222a {f1, \u00b7 \u00b7 \u00b7 , fn6} \u222a {g1, \u00b7 \u00b7 \u00b7 , gn7} \u2286 P. (3.10)\nAll of these elements a1, . . . , gn7 are distinct. If ni = 0 then the corresponding set is empty. Let \u0393, \u0393\u2032, \u0393\u2032\u2032 \u2286fin P , where\n\u0393 = {a1, \u00b7 \u00b7 \u00b7 , an1} \u222a {d1, \u00b7 \u00b7 \u00b7 , dn4} \u222a {f1, \u00b7 \u00b7 \u00b7 , fn6} \u222a {g1, \u00b7 \u00b7 \u00b7 , gn7} ,\n\u0393\u2032 = {b1, \u00b7 \u00b7 \u00b7 , bn2} \u222a {d1, \u00b7 \u00b7 \u00b7 , dn4} \u222a {e1, \u00b7 \u00b7 \u00b7 , en5} \u222a {g1, \u00b7 \u00b7 \u00b7 , gn7} and\n\u0393\u2032\u2032 = {c1, \u00b7 \u00b7 \u00b7 , cn3} \u222a {e1, \u00b7 \u00b7 \u00b7 , en5} \u222a {f1, \u00b7 \u00b7 \u00b7 , fn6} \u222a {g1, \u00b7 \u00b7 \u00b7 , gn7} .\nWe can picture these sets with the Venn diagram in Figure 3.1. The solid outer rectangle represents the set P . The three finite sets \u0393, \u0393\u2032, \u0393\u2032\u2032 are the three rectangles within. Each overlapping region has exactly the elements indicated and nothing more. This configuration exhausts all possibilities for \u0393, \u0393\u2032 and \u0393\u2032\u2032.\nNow suppose < permits \u0393\u22b3DEli\u0393 \u2032\u22b3DEli\u0393 \u2032\u2032, we write this out in terms of elements (Equations 3.11 and 3.12). \u0393 \u22b3DEli \u0393 \u2032 is equivalent to\n(\u2203x \u2208 \u0393\u2212 \u0393\u2032) (\u2200y \u2208 \u0393\u2032 \u2212 \u0393) x < y\n\u21d4 (\u2203x \u2208 {a1, \u00b7 \u00b7 \u00b7 , an1} \u222a {f1, \u00b7 \u00b7 \u00b7 , fn6}) (\u2200y \u2208 {b1, \u00b7 \u00b7 \u00b7 , bn2} \u222a {e1, \u00b7 \u00b7 \u00b7 , en5}) x < y\n\u21d4 (\u2203x \u2208 {a1, \u00b7 \u00b7 \u00b7 , an1} \u222a {f1, \u00b7 \u00b7 \u00b7 , fn6})\n\n\n(\nn2 \u2227\ni=1\nx < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nx < ej\n\n\n\n\n\u21d4\nn1 \u2228\nk=1\n\n\n(\nn2 \u2227\ni=1\nak < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nak < ej\n\n\n\n \u2228\nn6 \u2228\nl=1\n\n\n(\nn2 \u2227\ni=1\nfl < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nfl < ej\n\n\n\n .\n(3.11)\nNote that there are (n1 + n6) disjuncts in Equation 3.11. Applying the same reasoning as in Equation 3.11, we can see that \u0393\u2032 \u22b3DEli \u0393 \u2032\u2032 is equivalent to\nn2 \u2228\nk=1\n\n\n(\nn3 \u2227\ni=1\nbk < ci\n)\n\u2227\n\n\nn6 \u2227\nj=1\nbk < fj\n\n\n\n \u2228\nn4 \u2228\nl=1\n\n\n(\nn3 \u2227\ni=1\ndl < ci\n)\n\u2227\n\n\nn6 \u2227\nj=1\ndl < fj\n\n\n\n .\n(3.12)\nThere are (n2+n4) disjuncts in Equation 3.11. We need to show that \u0393\u22b3DEli\u0393 \u2032\u2032. By the same reasoning as Equations 3.11 and 3.12, this is equivalent to\nn1 \u2228\nk=1\n\n\n(\nn3 \u2227\ni=1\nak < ci\n)\n\u2227\n\n\nn5 \u2227\nj=1\nak < ej\n\n\n\n \u2228\nn4 \u2228\nl=1\n\n\n(\nn3 \u2227\ni=1\ndl < ci\n)\n\u2227\n\n\nn5 \u2227\nj=1\ndl < ej\n\n\n\n .\n(3.13)\nSo, to prove Equation 3.13, we need to show one of the disjuncts of Equation 3.13 i.e. for at least one of 1 \u2264 k \u2264 n1 or 1 \u2264 l \u2264 n4, we show either\n\n\n(\nn3 \u2227\ni=1\nak < ci\n)\n\u2227\n\n\nn5 \u2227\nj=1\nak < ej\n\n\n\n or\n\n\n(\nn3 \u2227\ni=1\ndl < ci\n)\n\u2227\n\n\nn5 \u2227\nj=1\ndl < ej\n\n\n\n\n(3.14)\nby establishing all of the conjuncts. Given \u0393 \u22b3DEli \u0393 \u2032 \u22b3DEli \u0393 \u2032\u2032, we take the conjunction of Equations 3.11 and 3.12, making (n1 + n6)(n2 + n4) disjuncts, which is equivalent to the following expression: \n\n\nn1 \u2228\nk=1\n\n\n(\nn2 \u2227\ni=1\nak < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nak < ej\n\n\n\n \u2228\nn6 \u2228\nl=1\n\n\n(\nn2 \u2227\ni=1\nfl < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nfl < ej\n\n\n\n\n\n\n\n\u2227\n\n\n\nn2 \u2228\nk=1\n\n\n(\nn3 \u2227\ni=1\nbk < ci\n)\n\u2227\n\n\nn6 \u2227\nj=1\nbk < fj\n\n\n\n \u2228\nn4 \u2228\nl=1\n\n\n(\nn3 \u2227\ni=1\ndl < ci\n)\n\u2227\n\n\nn6 \u2227\nj=1\ndl < fj\n\n\n\n\n\n\n\n.\nAs \u2227 and \u2228 bi-distribute, we have four cases:\n1. For some 1 \u2264 k \u2264 n1 and 1 \u2264 k \u2032 \u2264 n2, we have\n(\nn2 \u2227\ni=1\nak < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nak < ej\n\n \u2227\n(\nn3 \u2227\ni\u2032=1\nbk\u2032 < ci\u2032\n)\n\u2227\n\n\nn6 \u2227\nj\u2032=1\nbk\u2032 < fj\u2032\n\n .\n(3.15)\nThis means for some 1 \u2264 k \u2264 n1, we have \n\nn5 \u2227\nj=1\nak < ej\n\n , and from (3.16)\n(\nn2 \u2227\ni=1\nak < bi\n)\n\u2227\n(\nn3 \u2227\ni\u2032=1\nbk\u2032 < ci\u2032\n)\n,\nthat 1 \u2264 k\u2032 \u2264 n2, and transitivity of <, we infer (\nn3 \u2227\ni=1\nak < ci\n)\n. (3.17)\nEquations 3.16 and 3.17 imply \u0393 \u22b3DEli \u0393 \u2032\u2032.\n2. For some 1 \u2264 k \u2264 n1 and 1 \u2264 l \u2264 n4, we have\n(\nn2 \u2227\ni=1\nak < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nak < ej\n\n \u2227\n(\nn3 \u2227\ni\u2032=1\ndl < ci\u2032\n)\n\u2227\n\n\nn6 \u2227\nj\u2032=1\ndl < fj\u2032\n\n\n(3.18)\nThis case uses the assumption that < is total.16 The second and the third bracketed conjuncts in Equation 3.18 are necessary but not sufficient to lead to \u0393 \u22b3DEli \u0393\n\u2032\u2032. Let k0 be the witness to 1 \u2264 k \u2264 n1 and l0 be the witness to 1 \u2264 l0 \u2264 n4. As < is total, either ak0 < dl0 or dl0 < ak0 (remember all elements are distinct).\n\u2022 If ak0 < dl0 then ak0 < ci for all 1 \u2264 i \u2264 n3. Therefore, ( \u2227n3 i=1 ak0 < ci). \u2022 If dl0 < ak0 then dl0 < ej for all 1 \u2264 j \u2264 n5. Therefore, ( \u2227n5 j=1 dl0 < ej ) .\nIn either case, \u0393 \u22b3DEli \u0393 \u2032\u2032.\n3. For some 1 \u2264 l \u2264 n6 and 1 \u2264 k \u2264 n2, we have\n(\nn2 \u2227\ni=1\nfl < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nfl < ej\n\n \u2227\n(\nn3 \u2227\ni\u2032=1\nbk < ci\u2032\n)\n\u2227\n\n\nn6 \u2227\nj\u2032=1\nbk < fj\u2032\n\n\n(3.19)\n16It can be shown that if < is not total, \u22b3DEli is not transitive, see [23, Lemma A.2].\nThe irreflexivity of < and the first and last bracketed conjuncts gives a contradiction when you run over all indices, so this case gives a contradiction.\n4. For some 1 \u2264 l \u2264 n6 and 1 \u2264 l \u2032 \u2264 n4, we have\n(\nn2 \u2227\ni=1\nfl < bi\n)\n\u2227\n\n\nn5 \u2227\nj=1\nfl < ej\n\n \u2227\n(\nn3 \u2227\ni\u2032=1\ndl\u2032 < ci\u2032\n)\n\u2227\n\n\nn6 \u2227\nj\u2032=1\ndl\u2032 < fj\u2032\n\n\n(3.20)\nThis case is similar to the first case \u2013 we use transitivity to combine the second and last bracketed conjuncts. This infers the second conjunct of Equation 3.14, which means \u0393 \u22b3DEli \u0393 \u2032\u2032.\nTherefore, in all cases, \u0393 \u22b3DEli \u0393 \u2032\u2032. This shows \u22b3DEli is transitive on Pfin (P ).\nTo show trichotomy, let \u0393, \u0393\u2032 \u2208 Pfin(P ) be arbitrary. We start by assuming \u0393 6= \u0393\u2032 and show exactly one of \u0393 \u22b3DEli \u0393\n\u2032 or \u0393\u2032 \u22b3DEli \u0393 is true. From Equation 3.6, we consider the symmetric difference \u0393\u2296\u0393\u2032. The set \u3008\u0393\u2296 \u0393\u2032, <\u3009 \u2286 \u3008P, <\u3009 is also a finite strict toset. This means there must exist a <-least element x0 \u2208 \u0393\u2296 \u0393 \u2032, say. There are two mutually exclusive possibilities. If x0 \u2208 \u0393\u2212 \u0393 \u2032, then \u0393 \u22b3DEli \u0393 \u2032. If x0 \u2208 \u0393 \u2032 \u2212 \u0393, then \u0393\u2032 \u22b3DEli \u0393 \u2032. This establishes trichotomy. Therefore, \u3008Pfin (P ) , \u22b3DEli\u3009 is a strict chain.\nTherefore, given the strict toset \u3008Rd, <D\u3009, \u3008Pfin (Rd) , \u22b3SP \u3009 is also a strict toset.\nLemma 3.5. The argument preference -SP is a total preorder on A.\nProof. We instantiate \u3008P,<\u3009 in Lemma 3.4 to \u3008Rd, <SP \u3009. This is valid because by Equation 3.5 and the discussion aftewards, <SP is a strict total order on Rd. Further, Equation 3.7 is Equation 3.6 with <SP instead of <D. Therefore, \u3008Pfin (Rd) , \u22b3SP \u3009 is a strict toset by Lemma 3.4. By Equation 3.8, \u227aSP is a strict total order on A, and -SP (Equation 3.9) is a total preorder on A.\nBy Lemma 3.5, if two arguments A and B satisfy A 6\u227aSP B, then B -SP A. We demonstrate the features of <SP and \u227aSP with Examples 1 and 2.\nExample 1. Suppose that instead of respecting the logical structure of the defeasible rules with <SP , we use an argument preference relation \u227a based on \u22b3DEli (Equation 3.6) instead of \u22b3SP , i.e. replace \u22b3SP in Equation 3.9 with \u22b3DEli. Now consider the following LPDT. Let T+ haveW = \u2205 and D = {dk} 5 k=1 where\nd1 := : c1 c1 , d4 := c3 : c4 c4 , d3 := : c3 c3 , d2 := c1 : c2 c2 , d5 := c1 : \u00ac(c2 \u2227 c4) \u00ac(c2 \u2227 c4) ,\nsuch that d1 < + d4 < + d3 < + d2 < + d5. Our PDE is constructed in the usual manner starting from E0 = Th(\u2205) by Equation 2.4. Equation 2.5 gives the order of application of the defaults:\nE1 = E0 + c3, E2 = E1 + c4, E3 = E2 + c1, E4 = E3 + \u00ac(c2 \u2227 c4), (3.21)\nwith Ek = E4 for all k \u2265 5. As \u00ac(c2 \u2227 c4) \u2261 (\u00acc2 \u2228 \u00acc4), along with c4 (from d4), we have \u00acc2, which blocks d2. The unique PDE from this LPDT is E := Th({c1,\u00acc2, c3, c4}). Now consider the corresponding arguments following our instantiation. We have the defeasible rules17 r1 <D r4 <D r3 <D r2 <D r5. The relevant arguments and sets of defeasible rules are\nA := [[\u21d2 c1] \u21d2 c2], DR(A) = {r1, r2}\nB := [[\u21d2 c3] \u21d2 c4], DR(B) = {r3, r4}\nC := [[\u21d2 c1] \u21d2 \u00ac(c2 \u2227 c4)], DR(C) = {r1, r5} ,\nD := [B,C \u2192 \u00acc2], DR(D) = {r1, r3, r4, r5} .\nWe illustrate these arguments in Figure 3.2. Our convention for diagrams is that broken arrows represent defeasible rules, and solid arrows represent strict rules. Solid vertical lines spanning the length of arguments label those arguments. In the diagrams of this paper, defeasible rules with empty antecedent have the symbol \u22a4 as a placeholder for their antecedent.\nFor the stable extension to correspond to the PDL extension, the desired stable extension contains the argumentsD, B, C, [\u21d2 c3], [\u21d2 c1], the conclusions of which are, respectively, \u00acc2, c4, \u00ac (c2 \u2227 c4) , c3, c1, which under deductive closure, corresponds to E. However, this would require D \u2192\u0592 A, which means, by Equation 2.3, D \u21c0 A and D 6\u227a A. Clearly, D \u21c0 A on A. However, it is not the case that r2 is the <D-least defeasible rule, so D \u227a A. Therefore, this argument preference relation does not generate the corresponding stable extension to E.\nSuppose now that we do respect the logical structure of the rules and use \u227aSP as our argument preference (Equation 3.8). By applying Equations 3.4 and 3.5, we can show that a1 = r3, a2 = r4, a3 = r1, a4 = r5 and a5 = r2. The structure preference order is r2 <SP r5 <SP r1 <SP r4 <SP r3. Notice that\n17We define, for 1 \u2264 i \u2264 5, ri := f (di), by Equation 3.1.\nthis is precisely the order in which the corresponding normal defaults are added in PDL, as Equation 3.21 shows. It is easy to show that the corresponding stable extension under the argument preference \u227aSP corresponds to the PDL inference, because r2 is now <SP -least, so D 6\u227aSP A. Therefore A \u227aSP D, so A \u2192\u0592 D.\nExample 2. However, <SP does not necessarily follow the PDL order of the application of defaults. Consider \u3008{d1, d2} , {a} , < +\u3009 with d1 := a:\u00aca \u00aca\nand d2 := :b b such that d2 < + d1. We have E = Th ({a, b}), where d1 is blocked by W , so d2 is the only default added. In argumentation, we have Kn = {a}, r1 := (a \u21d2 \u00aca) and r2 := (\u21d2 b), such that r2 <D r1. The arguments are A0 := [a], A1 := [A0 \u21d2 \u00aca] and B := [\u21d2 b]. Applying Equation 3.4, we have r2 <SP r1, which clearly is not the order of how the corresponding defaults are added in PDL. Yet the correspondence still holds, since A0 \u2192\u0592 A1 because A0 is strict and strict arguments always defeat any non-strict argument they attack, so the stable extension is the strict extension of {A0, B}, the conclusion set of which (after deductive closure) is the extension of the underlying LPDT.\nWe have now defined the structure-preference argument preference relation -SP . Given an LPDT T\n+, we denote its attack graph to be AG (T+) := \u3008A,\u21c0,-SP \u3009, and its defeat graph to be DG (T\n+) := \u3008A, \u2192\u0592\u3009, where \u2192\u0592 is defined by Equation 2.3 with - equal to -SP ."}, {"heading": "3.3 The Representation Theorem", "text": "In this section we state and prove the representation theorem (Theorem 3.14), which guarantees that the inferences with argumentation semantics under the preference -SP correspond exactly to the inferences in PDL."}, {"heading": "3.3.1 Non-Blocked Defaults", "text": "We introduce some concepts to help prove the representation theorem. Let T be a PDT and E = \u22c3\ni\u2208N Ei one of its extensions generated from the linearisation <+\u2287<. The set of generating defaults (w.r.t. <+), GD(<+), is defined as\nGDi(< +) :=\n{ d \u2208 D d is <+-greatest active in Ei } ,\nGD(<+) := \u22c3\ni\u2208N\nGDi(< +) \u2286 D. (3.22)\nIntuitively, this is the set of defaults applied to calculate E following the priority <+. However, the same E can be generated by distinct total orders.\nExample 3. Consider the PDT \u2329{ a:c c , b:c c } , {a, b} , \u2205 \u232a . We have two possible linearisations a:c c <+1 b:c c and b:c c <+2 a:c c . By Footnote 8 (page 8) we have GD(<+1 ) = { b:c c } and GD(<+2 ) = { a:c c }\n, which are not equal, even though both linearisations give the same extension E = Th ({a, b, c}). In both cases, the default in D\u2212GD (\n<+i )\n(for i = 1, 2) is not active not because it is blocked by \u00acc, but rather because it adds no new information.\nWe wish to distinguish between inactive defaults that conflict with something known and inactive defaults that do not add any new information. We call a default \u03b8:\u03c6\n\u03c6 semi-active (in S \u2286 SL) iff [\u03b8 \u2208 S, \u00ac\u03c6 /\u2208 S, \u03c6 \u2208 S]. Let <+ \u2287 < be\ntotal and which generates the extension E (Equation 2.5). The set SAD (<+) of semi-active defaults with respect to the linearisation <+ is defined as\n{ d \u2208 D d is semi-active w.r.t. E, which is generated by <+ } . (3.23)\nSemi-active defaults add no new information. The set of non-blocked defaults is\nNBD(<+) := GD(<+) \u222a SAD(<+) \u2286 D. (3.24)\nLemma 3.6. If <+ generates the PDE E, then\nNBD(<+) :=\n{\n\u03b8 : \u03c6\n\u03c6 \u2208 D \u03b8 \u2208 E, \u00ac\u03c6 /\u2208 E\n}\n. (3.25)\nProof. It is sufficient to show Equation 3.24 (with Equations 3.22 and 3.23) is the same as the right hand side of Equation 3.25. Let <+ generate the extension E and, for notational convenience, we suppress the argument \u201c<+\u201d in the sets for this proof.18 (\u21d2) Case 1: Assume d \u2208 SAD, then Ante(d) \u2286 E, \u00acConc(d) /\u2208 E and Conc(d) \u2208 E.\nd \u2208{d\u2032 \u2208 D Ante(d\u2032) \u2286 E, \u00acConc(d\u2032) /\u2208 E} and hence (3.26)\nSAD \u2286{d \u2208 D Ante(d) \u2286 E, \u00acConc(d) /\u2208 E} . (3.27)\nCase 2: Now assume d \u2208 GD, which is equivalent to (\u2203i \u2208 N) d \u2208 GDi. This is equivalent to (\u2203i \u2208 N) [Ante(d) \u2286 Ei, Conc(d) /\u2208 Ei, \u00acConc(d) /\u2208 Ei], which is equivalent to\nAnte(d) \u2286 Ej0 , Conc(d) /\u2208 Ej0 , \u00acConc(d) /\u2208 Ej0 j0 witness to i. (3.28)\nThis implies Ante(d) \u2286 Ej0 , \u00acConc(d) /\u2208 Ej0 , and it follows that Ante(d) \u2286 E, \u00acConc(d) /\u2208 Ej0 . Clearly, this means Ante(d) \u2286 E. Now assume for contradiction that \u00acConc(d) \u2208 E, which means there is some i0 \u2208 N such that \u00acConc(d) \u2208 Ei0 . What is the relationship between i0 and j0? There are three possibilities:\n\u2022 i0 = j0 would mean \u00acConc(d) /\u2208 Ei0 and \u00acConc(d) \u2208 Ei0 \u2013 contradiction.\n\u2022 i0 < j0: We have \u00acConc(d) /\u2208 Ej0 and \u00acConc(d) \u2208 Ei0 , which is also impossible because the Ei\u2019s form an ascending chain, so Ei0 \u2286 Ej0 . Therefore, we get \u00acConc(d) \u2208 Ej0 and \u00acConc(d) /\u2208 Ej0 .\n\u2022 i0 > j0: We have \u00acConc(d) /\u2208 Ej0 and \u00acConc(d) \u2208 Ei0 . From Equation 3.28, we have that d is active in Ej0 , hence Conc(d) \u2208 Ej0+1 \u2286 Ei0 , which makes \u00acConc(d) \u2208 Ei0 impossible because the Ei\u2019s are consistent.\n18For example, instead of writing \u201cGD ( <+ ) \u201d we write \u201cGD\u201d.\nTherefore, \u00acConc(d) /\u2208 E. So we have Ante(d) \u2286 E and \u00acConc(d) /\u2208 E. Therefore, Equation 3.26 is true for this case and we have\nGD \u2286 {d \u2208 D Ante(d) \u2286 E, \u00acConc(d) /\u2208 E} . (3.29)\nWe can take the union of Equations 3.27 and 3.29 to get\nGD \u222a SAD \u2286 {d \u2208 D Ante(d) \u2286 E, \u00acConc(d) /\u2208 E} . (3.30)\n(\u21d0) Now assume d \u2208 {d\u2032 \u2208 D Ante(d\u2032) \u2286 E, \u00acConc(d\u2032) /\u2208 E}, which means Ante(d) \u2286 E and \u00acConc(d) /\u2208 E. We have, for some i0 \u2208 N,\n\u21d4Ante(d) \u2286 Ei0 , (\u2200j \u2208 N)\u00acConc(d) /\u2208 Ej\n\u21d4Ante(d) \u2286 Ei0 , \u00acConc(d) /\u2208 Ei0 , (\u2200j \u2208 N\u2212 {i0})\u00acConc(d) /\u2208 Ej\n\u21d4 (\u2200j \u2208 N\u2212 {i0})\u00acConc(d) /\u2208 Ej and\n[(Ante(d) \u2286 Ei0 , \u00acConc(d) /\u2208 Ei0 , Conc(d) \u2208 Ei0) or\n(Ante(d) \u2286 Ei0 , \u00acConc(d) /\u2208 Ei0 , Conc(d) /\u2208 Ei0)]\n\u21d4 (\u2200j \u2208 N\u2212 {i0})\u00acConc(d) /\u2208 Ej and\n[(Ante(d) \u2286 Ei0 , \u00acConc(d) /\u2208 Ei0 , Conc(d) \u2208 Ei0) or d \u2208 GDi0\n\u21d2 (\u2200j \u2208 N\u2212 {i0})\u00acConc(d) /\u2208 Ej and\n[(Ante(d) \u2286 Ei0 , \u00acConc(d) /\u2208 Ei0 , Conc(d) \u2208 Ei0) or d \u2208 GD\n\u21d2d \u2208 GD or [Ante(d) \u2286 Ei0 , \u00acConc(d) /\u2208 Ei0 , Conc(d) \u2208 Ei0 and\n(\u2200j \u2208 N\u2212 {i0})\u00acConc(d) /\u2208 Ej ]\n\u21d2d \u2208 GD or [Ante(d) \u2286 E and (\u2200j \u2208 N)\u00acConc(d) /\u2208 Ej ]\n\u21d2d \u2208 GD or [Ante(d) \u2286 E and \u00acConc(d) /\u2208 E] \u21d4 d \u2208 GD \u222a SAD.\nTherefore, we have\n{d \u2208 D Ante(d) \u2286 E, \u00acConc(d) /\u2208 E} \u2286 GD \u222a SAD. (3.31)\nThe result follows from Equations 3.30 and 3.31.\nGiven E, NBD(<+) is uniquely determined by Equation 3.25, so we will write NBD(E) instead. Equation 3.25 adapts Reiter\u2019s idea of a generating default [19, page 92, Definition 2] to PDL.\nWe use these concepts to show that the rearrangement of rules <D 7\u2192<SP , as defined in Equation 3.5, does not change the extension of the LPDT. This is because the manner through which <SP incorporates the argument structure captures the idea of Equation 2.5, which is the method of how PDL incorporates both structure and preference when choosing the \u201c<+-most active\u201d default.\nLemma 3.7. Let T := \u3008D,W,<+\u3009 and T \u2032 := \u2329 D,W,<+ \u2032 \u232a be two LPDTs such\nthat <+ \u223c=<D 7\u2192<SP\u223c=< +\u2032 ,19 then both T and T \u2032 have the same extension E.\nProof. Let E be the unique extension of T , and E\u2032 be the unique extension of T \u2032. To show E = E\u2032, we need to show that they have the same generating defaults, i.e. GD (<+) = GD ( <+ \u2032 ) . As <+ \u2032 \u223c=<SP , and < +\u223c=<D 7\u2192<SP , the\nrearrangement <D 7\u2192<SP will always choose the <D-greatest active defeasible rule for a1 in Equation 3.4, the second <D-greatest active defeasible rule for a2... etc. until all defeasible rules are rearranged, but the defeasible rules corresponding to the generating defaults of <+ \u2032 will always be chosen first in the rearrangement, therefore GD (<+) = GD ( <+ \u2032 ) and hence the result follows."}, {"heading": "3.3.2 Existence and Uniqueness of Stable Extensions", "text": "Let T+ be an LPDT. In this section we show that its defeat graph DG (T+) has a unique stable extension. We propose an algorithm that imitates how PDL extensions are constructed over an LPDT (Equation 2.5). Given S \u2286 A, r \u2208 Rd, the definition of Args ( \u00b7 ) (Equation 2.2) and <SP we define \u2295 as S \u2295 r := Args(DR(S) \u222a {r}), i.e. we close S under all arguments over all strict rules, all defeasible rules in S, and the addition of a new defeasible rule r.\nConsider Algorithm 1, which takes as input the attack graph AG (T+) of an LPDT T+, and the strict chain of defeasible rules under the SP order \u3008Rd, <SP \u3009. The output is a set of arguments S \u2286 A. The formal definition is:20\nAlgorithm 1 Generating a Stable Extension\n1: function GenerateStableExtension(\u3008A, \u21c0, -SP \u3009, \u3008Rd, <SP \u3009) 2: S \u2190 {all strict arguments in A} 3: for r \u2208 Rd from <SP -greatest to <SP -smallest do 4: if S \u2295 r has no attacks, (S \u2295 r) 2 \u2229 \u21c0= \u2205, then 5: S \u2190 S \u2295 r return S\nAlgorithm 1 first creates the largest possible set of undefeated arguments that do not attack each other. This includes all strict arguments as they are never defeated nor do they attack each other, and possibly some undefeated defeasible arguments. Then, the algorithm includes the defeasible rules from most to least preferred under <SP and tests whether the resulting arguments that are constructed by the inclusion of such a defeasible rule attack each other in the sense of Equation 3.3 (Lines 4\u20135). Note that the resulting attack must originate\n19This means that the chain \u2329 D,<+ \u232a\nis order isomorphic to \u3008Rd, <D\u3009 as described by Equations 3.1 and 3.2. Then we calculate <SP from <D as described in Section 3.2 and form a new chain \u2329 D,<+ \u2032 \u232a\n, which is order isomorphic to \u3008Rd, <SP \u3009. 20This is a brute-force definition used to prove that stable extensions exist and are unique\nin such defeat graphs.\nfrom the arguments having at most the defeasible rules added so far. As <SP is total, all defeasible rules are considered, and the result includes as many defeasible rules as possible such that the result has no attacks. Adding the rules in the order of <SP while ensuring no attacks mimics the condition of Equation 2.5. It is clear from the algorithm that S exists and is unique given the input, as it is of the form Args(R) for some R \u2286 Rd (Equation 2.2). We show S is a stable extension.\nLemma 3.8. The output S of Algorithm 1 is cf (conflict free).\nProof. cf is guaranteed by the consistency of Kn and that defeasible rules r \u2208 Rd are only added if the resulting arguments do not attack each other (Lines 4 - 5). Therefore, by Equation 2.3, S contains no defeats and must be cf.\nNote that the setup of the algorithm prevents not just defeats but attacks from appearing in S (Line 4). Normally, this is not sufficient to guarantee that Conc (S) is consistent in FOL.\nExample 4. Consider S = {[\u21d2 a] , [\u21d2 b] , [\u21d2 \u00ac(a \u2227 b)]} \u2286 A. There are no attacks in S because attacks are defined syntactically (Equation 3.3, page 10). However, Conc (S) = {a, b,\u00ac (a \u2227 b)} is clearly inconsistent in FOL.\nWe now show that if S has no attacks then Conc (S) is consistent in FOL.\nLemma 3.9. Let S be the output of Algorithm 1. If S2\u2229 \u21c0= \u2205 then Conc (S) is consistent.\nProof. By construction and Lemma 2.1, Conc (S) is deductively closed. Assume for contradiction that Conc (S) is inconsistent, then \u03b8, \u00ac\u03b8 \u2208 Conc (S) for some \u03b8 \u2208 SL. Hence there are A,B \u2208 S such that Conc(A) = \u03b8 and Conc(B) = \u00ac\u03b8. If at least one of TopRule(A) or TopRule(B) are defeasible then at least one of A \u21c0 B and B \u21c0 A is the case, hence S2\u2229 \u21c06= \u2205 \u2013 contradiction.\nNow consider the case where TopRule(A), T opRule(B) \u2208 Rs are both strict. As W = Kn is consistent and the rules in Rs are sound, if A and B are both strict then it cannot be the case they have contradictory conclusions. Therefore, at least one of A and B are defeasible. WLOG say A is defeasible. Suppose by construction A = [A1, A2, . . . , Ai, . . . , An \u2192 \u03b8] and B = [B1, B2, . . . , Bm \u2192 \u00ac\u03b8], where Ai \u2286arg A is defeasible with conclusion ai (Section 2.2). By closure under transposition of Rs and the properties of S, we can construct the argument B(i) := [A1, A2, . . . , Ai\u22121, B,Ai+1, . . . , An \u2192 \u00acai], and by Lemma 2.1, B\n(i) \u2208 S. If TopRule (Ai) is defeasible, then B (i) \u21c0 Ai and hence S 2\u2229 \u21c06= \u2205 \u2013 contradiction, so TopRule (Ai) is not defeasible. As Ai is defeasible we choose some subargument A\u2032i \u2286arg Ai and repeat the above line of reasoning for B (i) and A\u2032i. As all arguments are well-founded, this line of reasoning must terminate at some subargument of Ai whose top rule is defeasible, and hence S\n2\u2229 \u21c06= \u2205 \u2013 contradiction. The result follows.\nLemma 3.10. The set S defeats all arguments outside of itself.\nProof. Let R := DR(S). Let B /\u2208 S be an arbitrary argument outside of S. We show there is an A \u2208 S such that A \u2192\u0592 B. Given that B /\u2208 S, there must be some rule r \u2208 DR(B)\u2212R that causes S to attack the subargument of B with top rule r, according to Algorithm 1, Line 4. Let B\u2032 \u2286arg B such that TopRule(B \u2032) = r. Let A \u2208 S be the attacker of B\u2032 at r, such that Conc(A) = Cons(r).21 This means A \u21c0 B\u2032 and hence A \u21c0 B. There are two possibilities: either this rule r \u2208 DR(B) is <SP -greatest, or it is not.\nIf r is <SP -greatest, then Args(\u2205) \u2295 r contains attacking arguments, so A must be strict and hence A \u2192\u0592 B. If r is not <SP -greatest, then consider the strict <SP -upper-set of r in \u3008Rd, <SP \u3009, T := {r \u2032 \u2208 Rd r <SP r \u2032} 6= \u2205. There are two sub-possibilities: either T \u2229 R = \u2205 or T \u2229 R 6= \u2205. If T \u2229 R = \u2205, then adding r to S will create an attack by Algorithm 1, Line 4, and this attack must originate from some A \u2208 Args(\u2205) because no rule <SP -larger than r is used in the arguments of S, hence A \u2192\u0592 B.\nIf T \u2229 R 6= \u2205, then adding r to S means its attacker A \u21c0 B\u2032 is in Args (T \u2229R).22 Either A is strict or not strict (i.e. defeasible). If it is strict, then A \u2192\u0592 B as before. If it is not strict, i.e. \u2205 6= DR(A) \u2286 T \u2229 R, then by definition (\u2200s \u2208 T ) r <SP s. As DR(A) \u2286 T \u2229 R, we must also have (\u2200s \u2208 DR(A)) r <SP s. Therefore, there is an r \u2208 DR(B\n\u2032) \u2212DR(A) such that for all rules in DR(A), and hence DR(A)\u2212DR(B\u2032), r <SP s. By Equation 3.8, we conclude that B\u2032 \u227aSP A, and hence A \u2192\u0592 B\n\u2032. Therefore, by definition of \u2192\u0592 and \u2286arg, A \u2192\u0592 B.\nTheorem 3.11. The output of Algorithm 1, S, is a stable extension of DG (T+).\nProof. Immediate from Lemmata 3.8 and 3.10.\nWe also have a useful property relating the presence of an argument in a stable extension with its rules, which is independent of Algorithm 1.\nLemma 3.12. For a LPDT T+ and defeat graph DG (T+), if E is a stable extension of DG (T+), then A \u2208 E \u21d4 DR(A) \u2286 DR (E).\nProof. (\u21d2) If A \u2208 E then DR(A) \u2286 \u22c3\nA\u2208E DR(A) = DR(E) trivially. (\u21d0, contrapositive) If A /\u2208 E , then E \u2192\u0592 A at some A\u2032 \u2286arg A. Let r := TopRule (A\n\u2032). Assume for contradiction that r \u2208 DR(E), then (\u2203B \u2208 E) r \u2208 DR(B), so E \u2192\u0592 B \u2013 contradiction, as E is cf. Therefore, r /\u2208 DR (E). But as r \u2208 DR(A), DR(A) 6\u2286 DR (E).\n21Note that A is appropriately chosen such that Conc(A) = Cons(r) is syntactic equality. This is always possible because Rs has all rules of proof of FOL. Therefore, if an argument C concludes \u03b8, and we would want it to conclude \u03c6, where \u03c6 \u2261 \u03b8, we can just append the strict rule (\u03b8 \u2192 \u03c6) \u2208 Rs to C to create a new argument D that concludes \u03c6.\n22We have A \u2208 Args (T \u2229 R) because as Algorithm 1 adds the rules one by one according to <SP , if adding r to the rules in S and then creating all arguments (with all strict rules) creates an attack, then this attack must be due to some argument whose defeasible rules are amongst T \u2229 R. This is because at the point where the algorithm excludes r, any defeasible arguments constructed then can only have their rules from T .\nWe have shown that given T+ and AG (T+), Algorithm 1 gives a unique output that is a stable extension (Theorem 3.11). We now show that this is the only stable extension that DG (T+) can have.\nTheorem 3.13. Let E be the stable extension that is the output of Algorithm 1. This is the unique stable extension of DG (T+).\nProof. Given DG (T+) = \u3008A, \u2192\u0592\u3009, let E be the output of Algorithm 1, and assume for contradiction that E \u2032 6= E is some other stable extension of DG (T+). Let A\u20321 \u2208 E \u2032 \u2212 E . There is an argument A2 \u2208 E \u2212 E \u2032 such that A2 \u2192\u0592 A \u2032 1. There is an argument A\u20323 \u2208 E \u2032 \u2212 E such that A\u20323 \u2192\u0592 A2... and so on. We therefore construct a defeat chain of defeasible arguments\n\u00b7 \u00b7 \u00b7 \u2192\u0592 A\u20325 \u2192\u0592 A4 \u2192\u0592 A \u2032 3 \u2192\u0592 A2 \u2192\u0592 A \u2032 1, (3.32)\nwhere all primed arguments belong to E \u2032 and all unprimed arguments are in E . In general, suppose A \u2192\u0592 B, then by Equation 2.3, A \u2192\u0592 C \u2286arg B for some C, and A 6\u227aSP C. By Corollary 3.2, B -SP C. Assume for contradiction that A \u227aSP B, then by Lemma 3.5, A \u227aSP C \u2013 contradiction, so A 6\u227aSP B.\nEquation 3.32 thus becomes \u00b7 \u00b7 \u00b7 6\u227aSP A \u2032 5 6\u227aSP A4 6\u227aSP A \u2032 3 6\u227aSP A2 6\u227aSP A \u2032 1.\nBy Lemma 3.5, this is equivalent to A\u20321 -SP A2 -SP A \u2032 3 -SP A4 -SP A \u2032 5 -SP \u00b7 \u00b7 \u00b7 . By Equation 3.9 and Lemma 3.12, none of the adjacent arguments in this chain can have the same defeasible rules. This implies A\u20321 \u227aSP A2 \u227aSP A\u20323 \u227aSP A4 \u227aSP A \u2032 5 \u227aSP \u00b7 \u00b7 \u00b7 . The corresponding chain for defeasible rules is, by Equation 3.8, DR (A\u20321) \u22b3SP DR (A2) \u22b3SP DR (A \u2032 3) \u22b3SP DR (A4) \u22b3SP \u00b7 \u00b7 \u00b7 . As Rd is a finite set, there are only finitely many possible sets of defeasible rules. This strictly ascending chain must therefore be finite, say of length n. Equation 3.32 must therefore be of finite length, terminating at an undefeated argument B, which may or may not be strict.\nB \u2192\u0592 A\u2032n\u22121 \u2192\u0592 \u00b7 \u00b7 \u00b7 \u2192\u0592 A2 \u2192\u0592 A \u2032 1 or B \u2192\u0592 An\u22121 \u2192\u0592 \u00b7 \u00b7 \u00b7 \u2192\u0592 A2 \u2192\u0592 A \u2032 1,\nfor some n \u2208 N+. In the first case, B \u2208 E\u2212E \u2032 is an undefeated argument, so E \u2032 is not a stable extension \u2013 contradiction. In the second case, by similar reasoning, E is not a stable extension \u2013 contradiction. There cannot be another stable extension E \u2032 of DG (T+), so E is the unique stable extension of DG (T+).\nThe defeat graphs DG (T+) of LPDTs T+ thus have a unique stable extension."}, {"heading": "3.3.3 The Representation Theorem: Statement and Proof", "text": "In this section we state and prove the representation theorem which relates the stable extension of DG (T+) := \u3008A, \u2192\u0592\u3009 with the extension of the corresponding LPDT T+ := \u3008D, W, <+\u3009.\nTheorem 3.14. (The Representation Theorem) Let AG (T+) be the attack graph corresponding to an LPDT T+ with defeat graph DG (T+) under -SP .\n1. Let E be the extension of T+, which is unique (Section 2.3). Then there exists a unique stable extension E \u2286 A of DG (T+) such that Conc (E) = E.\n2. Let E \u2286 A be the unique stable extension of DG (T+) by Theorem 3.13, then Conc(E) is the extension of T+.\nProof. Proof of part 1: To prove the first statement we construct E in terms of E and show E is a stable extension of \u3008A, \u2192\u0592\u3009. By Theorem 3.13, this stable extension is unique. We finally show Conc(E) = E.\nGiven E, we let E := Args (f (NBD(E))) \u2286 A, where NBD(E) is defined in Equation 3.25 and Args ( \u00b7 ) is defined by Equation 2.2. This set is unique from the properties of Args. For notational convenience we let R := f (NBD(E)). We show E is a stable extension.\nAssume for contradiction that E is not cf, which means there are arguments A,B \u2208 E such that A \u2192\u0592 B, which means A \u21c0 B by Equation 2.3. Let a := Conc(A). As A \u2208 E , Equation 2.2 and the definition of E means that DR(A) \u2286 R. This means from W and the defaults of f\u22121 (DR(A)) \u2286 D (f is defined by Equation 3.1), which are non-blocked defaults in E, it follows that a \u2208 E. As E is deductively closed, this means \u00ac\u00aca \u2208 E. Now let B\u2032 \u2286arg B be the argument such that TopRule(B\u2032) = (b \u21d2 \u00aca) for some appropriate intermediate conclusion b \u2208 Conc (Sub(B)). As B \u2208 E , this means (b \u21d2 \u00aca) \u2208 R. By Equation 3.25, this means \u00ac\u00aca /\u2208 E \u2013 contradiction. Therefore, E is cf.\nTo show Args(R) defeats all other arguments, let B /\u2208 Args(R) be arbitrary. Let r \u2208 DR(B)\u2212R be some rule. Let B\u2032 \u2286arg B be such that TopRule(B \u2032) = r. The rule r corresponds to a default f\u22121(r) = \u03b8:\u03c6 \u03c6 /\u2208 NBD(E) (Equation 3.1). By Equation 3.25, we have two cases: either \u03b8 /\u2208 E or \u00ac\u03c6 \u2208 E. Case 1: If \u00ac\u03c6 \u2208 E, then we now show there exists an argument A \u2208 Args(R) such that A \u2192\u0592 B\u2032 and hence A \u2192\u0592 B, under -SP . By Equations 2.4 and 2.5, there is some i \u2208 N such that \u00ac\u03c6 \u2208 Ei. Suppose i = 0 then W |= \u00ac\u03c6. Compactness means there is some W \u2032 \u2286fin W such that W\n\u2032 |= \u00ac\u03c6. We can construct an argument A such that Prem(A) = W \u2032 and Conc(A) = \u00ac\u03c6 as there will be appropriate combinations of strict rules in Rs and premises in Kn, so A \u21c0 B. As DR(A) = \u2205 \u2286 R, we must have A \u2208 Args(R). As A is strict, A \u2192\u0592 B is guaranteed by Corollary 3.3 of -SP .\nNow suppose that i > 0, then \u00ac\u03c6 \u2208 Ej where j > 0 is the witness for i. Let dj \u2208 D be the default that is <\n+-greatest active in the layer Ej , so the set of defaults that are used in concluding \u00ac\u03c6 (up to the application of deductive rules) is S := {d0, . . . , dj\u22121} \u2286 GDj\u22121 (<\n+) \u2286 NBD(E). We can construct an argument A such that Prem(A) \u2286 W , Conc(A) = \u00ac\u03c6 and DR(A) = f(S). Clearly, DR(A) = f(S) \u2286 f (NBD(E)) =: R and hence A \u2208 Args (R). It is clear that A \u21c0 B, so we need to show A 6\u227aSP B.\nGiven that \u00ac\u03c6 \u2208 Ej , it must be the case that \u03c6 /\u2208 Ej . Therefore, f \u22121 (r) is not <+-greatest active for all extension layers E0, . . . , Ej\u22121. Suppose for contradiction that there is some rule s \u2208 DR(A) such that s <SP r. Then by Equation 3.4, r must be <+-greatest active at some Ek for k < j \u2212 1, which\nwould then result in \u03c6 in Ek+1, therefore preventing \u00ac\u03c6 \u2208 Ej \u2013 contradiction. 23 Therefore, r is <SP -smaller than all rules in DR(A). By Equation 3.8, we must have B \u227aSP A, and hence A 6\u227aSP B, so A \u2192\u0592 B. Therefore, for the case of \u00ac\u03c6 \u2208 E, Args(R) defeats all arguments outside it. Therefore, in all cases, if \u00ac\u03c6 \u2208 E, there is some argument A \u2208 E that defeats B.\nCase 2: We will assume \u03b8 /\u2208 E, and show that it leads to a contradiction with the method of infinite descent.\nIf \u03b8 /\u2208 E, then there is some proper subargument B\u2032\u2032 \u2282arg B \u2032 such that Conc(B\u2032\u2032) = \u03b8. Since \u03b8 /\u2208 E then it is the case that neither DR (B\u2032\u2032) = \u2205 nor in Args (f (NBD (E))). This is because if DR (B\u2032\u2032) = \u2205 then W \u2287 Prem(B\u2032\u2032) |= \u03b8 so \u03b8 \u2208 E0 \u2286 E by Equation 2.4. Further, if B\n\u2032\u2032 \u2208 Args (f (NBD (E))) then f\u22121 (DR(B)) \u2286 NBD(E), so by Equation 3.25, we have \u03b8 \u2208 E.\nTherefore, as B\u2032\u2032 is neither strict nor in Args (f (NBD (E))) there is some other defeasible rule s \u2208 DR (B\u2032\u2032) \u2212 f (NBD (E)). We can repeat the above reasoning with the rule s instead of r: suppose s = \u03b8 \u2032:\u03c6\u2032\n\u03c6\u2032 , then either \u03b8\u2032 /\u2208 E or\n\u00ac\u03c6\u2032 \u2208 E. In the latter case we can construct an argument A\u2032 \u2208 E concluding \u00ac\u03c6\u2032 which then defeats B\u2032\u2032 as in the case when we assumed \u00ac\u03c6 \u2208 E. In the former case we repeat the reasoning in the previous paragraph, but we cannot do this indefinitely as arguments are well-founded. We will end up with either a proper subargument of B\u2032\u2032 or an argument in Args (R) concluding \u03b8. In both cases \u03b8 \u2208 E is true, so assuming \u03b8 /\u2208 E will lead to contradiction by the method of infinite descent.\nTherefore, the only reason for r /\u2208 R is because \u00ac\u03c6 \u2208 E. We have shown there is an argument A that defeats any argument containing the rule r. As r belongs to some arbitraryB /\u2208 E , this means E := Args(R) defeats all arguments outside of it and hence it is a stable extension.\nTo show that E = Conc (E), we show E \u2286 Conc (E) and Conc (E) \u2286 E. In the first case, let \u03b8 \u2208 E so there is some i \u2208 N such that \u03b8 \u2208 Ei by Equations 2.4 and 2.5.\nIf \u03b8 \u2208 E0, we have W |= \u03b8 so by compactness there is some \u2206 \u2286fin W where \u2206 |= \u03b8. Given that Rs has all rules of proof we can construct a strict argument A such that Premn(A) = \u2206 and Conc(A) = \u03b8. As strict arguments are undefeated, A \u2208 E so \u03b8 \u2208 Conc (E).\nIf \u03b8 \u2208 Ek for some k \u2208 N +, we can construct a defeasible argument A concluding \u03b8 such that DR(A) \u2286 R and hence A \u2208 E , so \u03b8 \u2208 Conc (E). Specifically, we construct an argument whose defeasible rules correspond to the defaults added to E up to Ek.\nConversely, if \u03b8 \u2208 Conc(E) there is an argument in E concluding \u03b8. If this argument is strict then \u03b8 \u2208 E0 \u2286 E, else, as the defeasible rules are in R then \u03b8 \u2208 Ek \u2286 E for some k \u2208 N\n+ that indicates when all of the appropriate defaults needed to conclude \u03b8 are included.\nProof of part 2: We show Conc(E) \u2286 E and E \u2286 Conc(E). For the former, if \u03b8 \u2208 Conc(E) then there is some A \u2208 E concluding \u03b8. If A is strict\n23For this s \u2208 DR(A), the assumption that s <SP r means that the antecedent of f \u22121(r)\nis already in the appropriate extension layer.\nthen \u03b8 \u2208 E0 \u2286 E. If A is defeasible, then say DR(A) = {ri} k i=1 for some k \u2208 N +. These defeasible rules do not introduce any inconsistency to E by Lemma 3.9. Consider the set of corresponding defaults {di} k i=1 \u2286 D to DR(A). We can choose the smallest index j \u2208 N such that all of the conclusions of these defaults are included in Ej \u2286 E. This is because either {di} k i=1 \u2286 GD(E), or there is some di \u2208 SAD(E), but that would mean cons(di) \u2208 E so for some l \u2208 N, cons(di) \u2208 El. Therefore, under deductive closure, \u03b8 \u2208 Ej+1 \u2286 E, so \u03b8 \u2208 E. This shows that Conc (E) \u2286 E.\nConversely, let \u03b8 \u2208 E, so there is some i \u2208 N such that \u03b8 \u2208 Ei. If i = 0, then there is a strict argument A, necessarily in E as it is undefeated, that concludes \u03b8 so \u03b8 \u2208 Conc (E). If i > 0, then from \u03b8 \u2208 Ei we can consider the defaults added to Ei, and use the corresponding defeasible rules to construct an argument A such that Prem(A) \u2286 W , Conc(A) = \u03b8 and DR(A) to contain exactly those defeasible rules. By definition of <SP and Algorithm 1, these defeasible rules are all present in E , so DR(A) \u2286 DR (E). By Lemma 3.12, A \u2208 E . Therefore, \u03b8 \u2208 Conc (E). This shows that E \u2286 Conc (E).\nTheorem 3.14 means that PDL, where the default priority < is a total order, is sound and complete with respect to its argumentation semantics; the inferences of PDL can be formally seen as the conclusions of justified arguments.\nGiven the definition of \u227aSP and the translation of a LPDT to its defeat graph as described in Section 3.1, we can visualise the representation theorem in the following diagram:\nT+ DG ( T+ )\nE E\noo //\ntranslation \u2774\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\nPDE\n\u2774\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\nstable extension\noo // Conc(E)=E"}, {"heading": "3.4 Satisfaction of Rationality Postulates", "text": "In this section, we prove directly that our instantiation of ASPIC+ to PDL satisfies the Caminada-Amgoud rationality postulates and hence is normatively rational. We do this by investigating some properties of the stable extension of this defeat graph. Notice that we do not appeal to the sufficient conditions articulated by ASPIC+ that, if satisfied, will guarantee normative rationality. We will discuss why in Section 5."}, {"heading": "3.4.1 The Stable Extension is Grounded", "text": "Lemma 3.15. Let T+ be an LPDT with attack graph AG (T+) and defeat graph DG (T+). Let \u03c7 : P (A) \u2192 P (A) be the characteristic function. Let E \u2286 A be the stable extension of DG (T+). Then (\u2203n \u2208 N+) E \u2286 \u03c7n (\u2205), where \u03c7n denotes the nth iterate of \u03c7.\nBefore we prove Lemma 3.15, we first establish some notation that will be used in the proof. Recall interval notation: for any toset \u3008T,<\u3009 and a, b \u2208 T , define the subsets:\n(a, b) := {x \u2208 T a < x < b} , [a, b] := {x \u2208 T a \u2264 x \u2264 b} ,\n[a, b) := {x \u2208 T a \u2264 x < b} and (a, b] := {x \u2208 T a < x \u2264 b} .\nRecall that if b \u2264 a then (a, b) = [a, b) = (a, b] = \u2205, and if b < a then [a, b] = \u2205. As D is finite let N := |Rd|. Given the LPDT T\n+ with defeat graph DG (T+) and stable extension E , define the set, for 0 \u2264 k \u2264 N ,\nRd \u2212DR (E) =: {r1, . . . , rk} , (3.33)\nwhere k = 0 means DR (E) = Rd, and k = N means DR (E) = \u2205. WLOG, we arrange the indices for these rules such that rl+1 <SP rl, for 1 \u2264 l \u2264 k\u22121. This is the set containing the rules that do not feature in E .\nGiven the strict toset \u3008Rd, <SP \u3009, denote rmax := max<SP Rd and similarly for rmin. Both rmax and rmin are uniquely defined as <SP is total. To isolate the defeasible rules that do not make up the arguments in E , we partition Rd from smallest to largest in <SP as follows:\n[rmin, rk), {rk} , (rk, rk\u22121) , {rk\u22121} , . . . , {r2} , (r2, r1) , {r1} , (r1, rmax]. (3.34)\nThis places the defeasible rules that do not feature in E into their own singleton sets along the chain <SP . These singleton sets contain precisely the defeasible rules skipped over by Algorithm 1 when constructing E . Note the first and last of these sets may be empty, e.g. when rk = rmin. We name these sets: for 1 \u2264 i \u2264 k, Pi := {ri}. Similarly, for 2 \u2264 i \u2264 k, Ii := (ri, ri\u22121) \u2286 Rd. We also define I1 := (r1, rmax] \u2286 Rd and Ik+1 := [rmin, rk) \u2286 Rd. Equation 3.34 can be written as:\nIk+1, Pk, Ik, Pk\u22121, . . . , P2, I2, P1, I1. (3.35)\nNotice from Equation 3.34 that \u22c3k+1\nj=1 Ij = Rd\u2212{rk, rk\u22121, . . . , r2, r1} = DR (E). We define the following counterpart sets of arguments to those in Equation\n3.35. For 1 \u2264 i \u2264 k, define\nAPi := {A \u2208 A DR(A) \u2229 Pi 6= \u2205} \u2286 A. (3.36)\nThese are the sets of defeasible arguments that have at least one rule excluded from E . By Lemma 3.12 and the definition of the Pi sets, it is easily shown that for all 1 \u2264 i \u2264 k, APi \u2229 E = \u2205. Further, for 1 \u2264 i \u2264 k + 1,\nAIi :=\n\n\n\nA \u2208 A DR(A) \u2229 Ii 6= \u2205 and DR(A) \u2286\ni \u22c3\nj=1\nIj\n\n\n\n. (3.37)\nThese are the sets of defeasible arguments where the arguments only have rules from these intervals (as subsets of DR (E)), with at least one such rule from the <SP -lowest ranked interval Ii. We also define\nAI0 := {A \u2208 A DR(A) = \u2205} = Args (\u2205) , (3.38)\nwhich by Equation 2.2 is the set of all strict arguments. Clearly AI0 \u2286 \u03c7 (\u2205).\nLemma 3.16. It is the case that AI1 \u2286 \u03c7 (\u2205).\nProof. The set AI1 is cf (conflict free): assume for contradiction that A,B \u2208 AI1 such that A \u2192\u0592 B. Then as DR(A), DR(B) \u2286 I1 \u2286 DR (E), by Equations 3.33 and 3.34 and Lemma 3.12, A,B \u2208 E \u2013 contradiction, because E is cf. Now assume for contradiction that A \u2208 AI1 is defeated, so there is some B \u2208 A such that B \u2192\u0592 A. Clearly if B \u2208 E , then E is not cf because A \u2208 E . Therefore, B /\u2208 E . By Lemma 3.12, DR(B) 6\u2286 DR (E) so for some 1 \u2264 i \u2264 k, DR(B) \u2229 Pi 6= \u2205. However, by Equation 3.34, there is a rule in DR(B)\u2212DR(A), namely ri, such that it is <SP -smaller than all rules in DR(A) (and hence <SP -smaller than all rules in DR(A)\u2212DR(B)). Therefore, B \u227aSP A, and hence B cannot defeat A. Therefore, all arguments in AI1 are also undefeated, so AI1 \u2286 \u03c7 (\u2205).\nFor the purposes of the proof of Lemma 3.15, we define, for i > k + 1,\nAIi = AIk+1. (3.39)\nNote that the sets of arguments in Equation 3.35 do not partition A, as an argument can conceivably have rules from two or more of the Ij sets. We now apply these ideas to prove Lemma 3.15.\nProof. (Proof of Lemma 3.15) Given our setup, let E be the stable extension of DG (T+). By Theorem 3.13, E is unique and could only have been constructed by Algorithm 1. Algorithm 1 begins with Args (\u2205), then adds rules in Rd from <SP -largest to <SP -smallest as long as the resulting set with the rule contains no arguments attacking each other. From the above notation, it is exactly the rules in the sets Pi that, when included, create arguments that attack each other. This is why these rules in Pi do not feature in E .\nWe use strong induction to show that for i \u2208 N+, AIi \u2286 \u03c7 i (\u2205). The base case, i = 1, follows from Lemma 3.16. For the strong inductive step, assume AIj \u2286 \u03c7 j (\u2205) for all 1 \u2264 j \u2264 i. We will show that AIi+1 \u2286 \u03c7 i+1 (\u2205). Let A \u2208 AIi+1 be arbitrary. This means DR(A) \u2286 \u22c3i+1 j=1 Ij and DR(A) \u2229 Ii+1 6= \u2205 by Equation 3.37. Either A is defeated by an argument in \u22c3i\nj=1 APj or it is not, where APj is defined in Equation 3.36. If A is not defeated by an argument in \u22c3i\nj=1 APj , then A \u2208 \u03c7 (\u2205) as it is undefeated; A cannot be defeated by some argument B in APj , for j > i, because in that case B \u227aSP A. As \u03c7 is \u2286-monotonic, A \u2208 \u03c7i+1 (\u2205). Otherwise, if \u22c3i\nj=1 APj \u2192\u0592 A, then there is some 1 \u2264 j \u2264 i such that APj \u2192\u0592 A. Call the witness to j j0, so APj0 \u2192\u0592 A. Say the\ndefeating argument is C \u2208 APj0 . But by definition of APj0 , (\n\u2203B \u2208\nj0 \u22c3\ns=0\nAIs\n)\nB \u2192\u0592 C, s = 0 is included as B may be strict,\n\u21d4 (\u22030 \u2264 s \u2264 j0) (\u2203B \u2208 AIs)B \u2192\u0592 C \u21d2 (\u22030 \u2264 s \u2264 j0) (\u2203B \u2208 \u03c7 s (\u2205))B \u2192\u0592 C by our strong inductive hypothesis.\nThis means A is defended by \u03c7s (\u2205), so A \u2208 \u03c7s+1 (\u2205), for some 0 \u2264 s \u2264 j0. As s \u2264 j0 \u2264 i, this means s \u2264 i and hence s+ 1 \u2264 i + 1. By \u2286-monotonicity of \u03c7, A \u2208 \u03c7i+1 (\u2205). This establishes the inductive step.\nHowever, this proof by induction proves this for all i \u2208 N+. What happens when i > k+1? If i > k+1, then by Equation 3.39, AIi = AIk+1 \u2286 \u03c7\nk+1 (\u2205) \u2286 \u03c7i (\u2205) and we have no more defeasible rules to add. As the sequence AIi stabilises the result holds for all i \u2208 N+ trivially.\nNow, as \u2205, \u03c7 (\u2205) , \u03c72 (\u2205) . . . form an \u2286-increasing sequence in P (A), we can take the union of the equations AIi \u2286 \u03c7 i (\u2205) and invoke monotonicity of \u03c7:24\nk+1 \u22c3\ni=1\nAIi \u2286 k+1 \u22c3\ni=1\n\u03c7i (\u2205) = \u03c7k+1 (\u2205) .\nWe then take the union of both sides with the set of all strict arguments. The left hand side becomes E . This is because the union of the AIj sets from j = 0 to k + 1 means any argument in that set cannot have any rules in the Pk sets, and therefore DR(A) \u2286 DR (E) and hence A \u2208 E by Lemma 3.12.\nAs the set of all strict arguments is contained in \u03c7 (\u2205) because they are undefeated, the right hand side stays the same. Therefore, we obtain E \u2286 \u03c7k+1 (\u2205), where 0 \u2264 k \u2264 N \u2208 N is the number of defeasible rules blocked from E , which is a natural number.25 This shows the result.\nLemma 3.17. Let \u3008A,\u2192\u3009 be an abstract argumentation framework and \u03c7 its characteristic function. Let G \u2286 A be the grounded extension. Then (\u2200n \u2208 N)\u03c7n (\u2205) \u2286 G.\nProof. Immediate by induction on n: \u03c7 is \u2286-monotonic and G is complete.\nWe now instantiate the abstract framework \u3008A,\u21c0\u3009 in Lemma 3.17 to the defeat graph \u3008A, \u2192\u0592\u3009 of a LPDT.\nCorollary 3.18. Suppose we have an LPDT T+ with attack graph AG(T+) := \u3008A,\u21c0,-SP \u3009 and defeat graph DG(T\n+) := \u3008A, \u2192\u0592\u3009. The characteristic function \u03c7 is as usual. The stable extension E \u2286 A of DG(T+) is grounded.\nProof. From Lemma 3.15, there exists some n \u2208 N such that E \u2286 \u03c7n (\u2205). From Lemma 3.17, we have \u03c7n (\u2205) \u2286 G, where G \u2286 A is the grounded extension. But by definition, G \u2286 E because stable extensions are complete. Therefore, we have, for this n \u2208 N, G \u2286 E \u2286 \u03c7n (\u2205) \u2286 G, so E = G.\n24Strictly speaking the union should be over all i \u2208 N but because the AIi sequence stabilises we only have to care about 0 \u2264 i \u2264 k + 1.\n25Notice if k = 0, there is no conflict, all arguments in E are undefeated, so E \u2286 \u03c7 (\u2205)."}, {"heading": "3.4.2 The Trivialisation and Rationality Theorems", "text": "The trivialisation theorem states that if the underlying default priority is total, then all of Dung\u2019s argumentation semantics are equivalent.\nTheorem 3.19. (The Trivialisation Theorem) The defeat graph \u3008A, \u2192\u0592\u3009 of an LPDT T+ has a unique complete extension that is grounded, preferred and stable.\nProof. Let C be any complete extension of \u3008A, \u2192\u0592\u3009, which means C is cf and \u03c7 (C) = C. Let G be the grounded extension, then G \u2286 C by definition. As the (unique) stable extension E is grounded by Corollary 3.18, we have G = E , therefore E \u2286 C. This means either E = C or E \u2282 C. In the latter case, there will be some B /\u2208 E such that B \u2208 C, but as E \u2282 C is stable, we must have some A \u2208 E (so A \u2208 C) such that A \u2192\u0592 B. Therefore, C is not cf \u2013 contradiction. Therefore, C = E . As E is unique, C is unique. Therefore, \u3008A, \u2192\u0592\u3009 has a unique complete extension that is grounded, stable and hence preferred.\nWe now prove that this instantiation of ASPIC+ to PDL satisfies the requirements for normative rationality [10]. Recall that when instantiated to FOL, ClRs becomes deductive closure.\nTheorem 3.20. (The Rationality Theorem) Let \u3008A, \u21c0, -SP \u3009 be the ASPIC + attack graph of PDL and let E be any of the complete extensions of the corresponding defeat graph \u3008A, \u2192\u0592\u3009. Our instantiation satisfies the Caminada-Amgoud rationality postulates.\nProof. By Theorem 3.13, \u3008A, \u2192\u0592\u3009 has a unique stable extension E , which is a complete and an admissible extension. It is sufficient to prove the postulates for E because by Theorem 3.19, \u3008A, \u2192\u0592\u3009 only has E as its sole complete extension.\n1. To show that E is subargument closed, recall that Algorithm 1 gives an explicit construction of E , which is of the form Args(R) for some R \u2286 Rd which is subargument closed (Equation 2.2).\n2. The representation theorem states that Conc (E) = E and as E is deductively closed, Conc (E) is closed under strict rules.\n3. As W is consistent and Conc (E) is the extension, Conc (E) must also be consistent and its deductive closure is consistent.\nThis shows the result.\nThe rationality theorem establishes that this instantiation of ASPIC+ to PDL satisfies all of the Caminada-Amgoud rationality postulates and is a normatively rational instantiation of ASPIC+.\nFinally, the consistency of E on the side of PDL allows us to establish a stronger notion of cf for E on the side of argumentation. This is already implicit in Algorithm 1 Line 4.\nCorollary 3.21. Let \u3008D,W,<+\u3009 be an LPDT with attack graph \u3008A,\u21c0,-SP \u3009 and corresponding defeat graph \u3008A, \u2192\u0592\u3009 that has a unique stable extension E. We have E2\u2229 \u21c0= \u2205, i.e. no two arguments in E attack each other.\nProof. Given the hypotheses, assume for contradiction that A \u21c0 B for A,B \u2208 E . WLOGwe can assume thatConc(A) = \u03b8 and Conc(B) = \u00ac\u03b8 with TopRule(B) \u2208 Rd, by Equation 3.3 and that E is subargument closed. Therefore, Conc (E) is inconsistent, because \u03b8,\u00ac\u03b8 \u2208 Conc (E). This violates the Rationality Theorem \u2013 contradiction. Therefore, no two arguments in E attack each other."}, {"heading": "3.4.3 Inconsistent Arguments", "text": "We have stated in Section 2.2 that arguments are constrcted freely from the premises and rules. In this instantiation, it is possible to construct arguments that are inconsistent, either in their intermediate conclusions or their conclusion.\nExample 5. Consider the rules (\u21d2 a) and (\u21d2 \u00aca) and arguments A = [\u21d2 a], B = [\u21d2 \u00aca] and C = [A,B \u2192 \u22a5]. Then C is inconsistent in its conclusion. Further, for any c \u2208 SL the argument A+ := [A \u2192 (a \u2228 c)], so given that our strict rules are the rules of proof in FOL, we can construct the argument D = [A+, B \u2192 c] for any c. The intermediate conclusions of D are inconsistent.\nWe call an argument inconsistent iff Conc (Sub(A)) \u2286 FL is an inconsistent set in FOL. It is possible to construct such arguments in A. We can ignore these arguments by focussing on A\u2212{A \u2208 A A is inconsistent} and restricting \u21c0 in the usual way, but this seems inelegant especally when the process of argumentation is meant to resolve inconsistencies. If we do include inconsistent arguments, the very least is that they should not be justified. By Theorems 3.13 and 3.19, there is only one way of justifying arguments: an argument A is justified iff A \u2208 E . Lemma 3.9 and Corollary 3.21 ensure that if A is inconsistent, then A /\u2208 E .\nIn summary, although it is possible to have inconsistent arguments in A, they can never be justified and we do not need to be concerned with them."}, {"heading": "3.5 Summary", "text": "In this section, we have provided an argumentative characterisation of PDL inference that is sound, complete and normatively rational, in the case where our default priority is a strict total order. We can construct ASPIC+ arguments and attacks (Section 3.1). The structure-preference relation, -SP , takes into account both the default priority < and the logical structure of arguments. This is motivated by how PDL adds defaults when constructing extensions (Section 3.2). The representation theorem states that under -SP , the PDL extension and the conclusion set of the stable extension correspond exactly (Section 3.3, Theorem 3.14). We can prove directly that the stable extension of interest satisfies the Caminada-Amgoud rationality postulates (Section 3.4, Theorem 3.20). As this is the only complete extension of our defeat graphs, our instantiation satisfies\nthe postulates. Finally, we do not need to explicitly prevent the construction of inconsistent arguments, because they are never justified (Section 3.4.3)."}, {"heading": "4 On Lifting the Assumption of a Total Order", "text": "Default Priority\nIn Section 3, we have provided an argumentative characterisation of PDL inference where the default priority < is a strict total order. It seems that we have lost generality but this is not the case because calculating an extension in PDL always presupposes a linearisation <+ of < (Section 2.3), and Theorem 3.14 shows that for any such linearisation the correspondence of inferences between PDL and its argumentation semantics holds.\nBut argumentation can also define argument preference relations based on an underlying partial order. We now investigate how to lift the assumption that < is total for the LPDT T+, such that the resulting multiple stable extensions each correspond to an extension of the underlying PDT T . Our underlying representation of PDL in ASPIC+ is the same as in Section 3.1, but now <D is a strict partial order."}, {"heading": "4.1 The Argument Preference Relation based on Partial Order Default Priorities", "text": "In Section 3.2, we devised the structure-preference (SP) argument preference relation -SP which captures the PDL idea of adding the \u201c<\n+-greatest active\u201d default (Equation 2.5). If we translate a PDT T directly into an argument graph AG (T ) without first linearising <, the generalised version of -SP should take into account the incomparabilities of rules while still respecting their logical structure. We formalise this idea by defining a string representation of the rules that will be used in an algorithm to calculate <D 7\u2192 <SP for partial <D. We will give a variation of the Penguin Triangle (Example 8) as a running example."}, {"heading": "4.1.1 A Representation of Rules and their Ordering using Strings", "text": "Let rulenames be a set of characters, with as many characters as there are rules in Rd. Let g : Rd \u2192 rulenames be a bijection such that each r \u2208 Rd has a single-character name26 g(r). Let \u22c6 denote the Kleene star and \u2217 denote string concatenation,27 and len : rulenames\u22c6 \u2192 N returns the number of letters of the string. We will also assume that in each string \u03c3 \u2208 rulenames\u22c6 there is an index assocated with each letter starting from 0 and ending in len (\u03c3) \u2212 1. To iterate over the letters l of the string \u03c3 we will write l \u2208 \u03c3, which starts from the\n26By \u201cname\u201d we do not mean the naming function n : Rd \u2192 L in Section 2.2 (page 4), which is still undefined (n \u2261 \u2217) in this case, but just what we label the rules with, e.g. the defeasible rule r7 = (a \u21d2 b) has the label or name r7.\n27This is abuse of notation as we had earlier stated \u2217 refers to undefined quantities (Section 2.1). But there are few undefined quantities and the meaning of \u2217 will be clear from context.\nletter at index 0 and terminates at the letter at index len (\u03c3) \u2212 1. The empty string is \u03b5 := \u201c\u201d with len (\u03b5) = 0. We may put quotation marks around strings to emphasise that they are strings.\nFor R \u2286 Rd such that R := {r1, . . . , rk}, we can form the string g(r1) \u2217 g(r2)\u2217 \u00b7 \u00b7 \u00b7 \u2217g(rk), written g(r1)g(r2) \u00b7 \u00b7 \u00b7 g(rk). Notice that forming a string from a set imposes an order on the elements.\nExample 6. (Example 1 continued) Suppose we have ri := f (di) for f as in Equation 3.1. Suppose g (r1) = \u201ca\u201d, g (r2) = \u201cb\u201d, g (r3) = \u201cc\u201d, g (r4) = \u201cd\u201d and g (r5) = \u201ce\u201d. Then for the set S = {r1, r2, r5} we can form the strings (e.g.) \u201cabe\u201d or \u201cbea\u201d, depending on which order we choose the rules to be in.\nAs g is a bijection we can define the reverse process. Suppose we have a string \u03c3. We define the set of rules that are encoded by the letters of \u03c3 as follows:\n\u22c3\nl\u2208\u03c3\n{ g\u22121 (l) } . (4.1)\nNotice that we lose the information about the index, but we will see that it does not matter. Notice also that if \u03c3 = \u03b5 then we have the empty union so the set of rules encoded by \u03b5 is \u2205.\nExample 7. (Example 6 continued) Suppose we want to find the set of the string \u201cace\u201d. Applying Equation 4.1, we get the set {r1, r3, r5}.\nLastly, we can transform strings into total orders: for \u03c3 = \u03c31\u03c32 . . . \u03c3n, where for 1 \u2264 i \u2264 n the letter \u03c3i has index i\u2212 1. 28 We can transform \u03c3 to the set\n{(\u03c31, \u03c32) , (\u03c31, \u03c33) , . . . , (\u03c31, \u03c3n) , (\u03c32, \u03c33) . . . , (\u03c3n\u22121, \u03c3n)} (4.2)\nusing two nested loops ranging over the letters of \u03c3 such that the pair of letters (\u03c3i, \u03c3j) is added to the set iff i < j. Intuitively, given a selected letter \u03c3i of a string, letters to the right of \u03c3i are larger than \u03c3i, and letters to the left of \u03c3i are smaller than \u03c3i."}, {"heading": "4.1.2 Algorithm and Example Calculation", "text": "We want to generalise the mapping <D 7\u2192 <SP , defined in Section 3.2 for the case where <D is total, to arbitrary partial orders <D. Furthermore, we want to simultaneously capture all possible linearisations of <D. We now present the algorithm that calculates the generalised mapping <D 7\u2192<SP in two parts.\nThe first stage of the algorithm is a non-recursive depth first search algorithm that returns the set of all strings representing the rules chosen in accordance with both the preference and the structure as described in Section 4.1.1. This is articulated in Algorithm 2, which defines the function StructurePreference1. This function takes \u3008Rd, <D\u3009 as input and returns this set of strings.\n28Here, \u03c3i denotes one letter; the subscript i is not a separate letter to \u03c3 itself.\nThe second stage of the algorithm is to turn the output of Algorithm 2 into <SP . This is done by translating each string in the output of Algorithm 2 into a strict total order onRd, and then taking their intersection. This is articulated in Algorithm 3, which defines a function StructurePreference2, which takes as input a set of strings, and calculates <SP .\nAlgorithm 2 Calculating <SP from <D on Rd, Part 1 \u2013 generate a set of strings, each string is an order of the choice of rules from least preferred (the first letter, on the left) to the most preferred (the last letter, on the right), which essentially corrects <D for the argument structure and then linearises. Recall that in Line 11, \u2217 refers to string concatenation. As Rd is finite, Algorithm 2 terminates. Throughout, Si is a set of strings, while R \u03bb, T \u03bb \u2286 Rd.\n1: function StructurePreference1(\u3008Rd, <D\u3009) 2: S0 \u2190 {\u03b5} 3: N \u2190 |Rd| 4: for i = 0 to N do 5: Si+1 \u2190 \u2205 6: for \u03bb \u2208 Si do 7: T \u03bb \u2190 \u22c3\nl\u2208\u03bb\n{ g\u22121 (l) }\n8: R\u03bb \u2190 max<D [{ s \u2208 Rd Ante(s) \u2286 Conc ( Args ( T \u03bb ))} \u2212 T \u03bb ]\n9: if R\u03bb = \u2205 then return Si 10: for t \u2208 g ( R\u03bb ) do 11: Si+1 \u2190 Si+1 \u222a {t \u2217 \u03bb}\nThe intuition of Algorithm 2 is as follows: we initialise the algorithm (Line 2) and iterate N +1 times (Line 4), where N = |Rd| (Line 3). At each iteration Algorithm 2 chooses all of the most preferred applicable rules at that stage. Each choice may render more rules active for the next iterations. It iterates over all such possibilities and repeats this process until the N th iteration, where there are no more rules to be chosen and the algorithm terminates. The result is a set of strings, which are read from right to left, where the right-most letter is the first choice of most preferred applicable defeasible rule, and the left-most letter is the last choice, which usually corresponds to a blocked default.\nThe intuition of Algorithm 3 is that upon input of this set of strings, the algorithm turns each string into a strict total order over Rd as described in the end of Section 4.1.1 (Equation 4.2), and then takes the intersection of all such orders to return <SP . The intersection returns the \u201ccore\u201d strict partial order which is the \u201csmallest\u201d change to the original <D that is compatible with all argument structures. Given \u3008Rd, <D\u3009, we define:\n<SP :=StructurePreference2(StructurePreference1[\u3008Rd, <D\u3009])\n:=F (<D) . (4.3)\nThis is our method for calculating \u3008Rd, <SP \u3009 from \u3008Rd, <D\u3009 where <D is partial.\nAlgorithm 3 Calculating <SP from <D on Rd, Part 2 \u2013 from the set of strings generated from Algorithm 2, we turn each string into a strict total order on Rd, and then take their intersection to return <SP .\n1: function StructurePreference2(S) 2: orders \u2190 \u2205 3: for \u03bb \u2208 S do 4: <+SP\u2190 \u2205 5: for r \u2208 \u03bb do 6: for s \u2208 \u03bb do 7: if index(r) < index(s) then 8: <+SP\u2190< + SP \u222a{(r, s)} 9: orders \u2190 orders \u222a {\n<+SP }\nreturn \u22c2 orders\nExample 8. (Modified Penguin Triangle) Let W = \u2205,\nD =\n{\nd1 := : a\na , d2 :=\na : b\nb , d3 :=\n: \u00acb\n\u00acb\n}\nand consider the default priority <= {(d3, d2)}. 29 There are three possible linearisations of < giving two possible extensions:\nE1 :=Th ({a, b}) from d3 < + d2 < + d1 and d3 < + d1 < + d2, and E2 :=Th ({a,\u00acb}) from d1 < + d3 < + d2.\nLet ri := f (di) for i = 1, 2, 3 (Equation 3.1). We illustrate these arguments in Figure 4.1.\nClearly A and B attack each other at their conclusions. Putting <D= {(r3, r2)} into Equation 4.3, we get the following:\n\u2022 For Algorithm 2, we have S0 = {\u03b5}, N = 3 and i = 0, 1, 2, 3.\nWhen i = 0, S1 = \u2205, \u03bb = \u03b5, T \u03bb = \u2205 and R\u03bb = {r1, r3} 6= \u2205. Therefore, S1 = {\u201cr1\u201d, \u201cr3\u201d}. Notice r3 is a <D-maximal applicable rule, because even though r3 <D r2, r2 is not applicable until r1 is applied.\n29Notice this is not the \u201cusual\u201d partial order priority that respects the specificity principle.\nWhen i = 1, S2 = \u2205, and either \u03bb = \u201cr1\u201d or \u03bb = \u201cr3\u201d. The former gives S2 = {\u201cr2r1\u201d} and the latter gives S2 = {\u201cr2r1\u201d, \u201cr1r3\u201d}.\nWhen i = 2, S3 = \u2205, \u03bb = \u201cr2r1\u201d or \u03bb = \u201cr1r3\u201d. In the former case, S3 = {\u201cr3r2r1\u201d}, and in the latter case, S3 = {\u201cr3r2r1\u201d, \u201cr2r1r3\u201d}.\nWhen i = 3, we get T \u03bb = Rd so R \u03bb = \u2205, halting the algorithm with output S3.\n\u2022 Given S3 as input to Algorithm 3, we get the intersection of the words \u201cr3r2r1\u201d and \u201cr2r1r3\u201d when converted to chains, giving <SP= {(r2, r1)}.\nTherefore, Equation 4.3, returns <SP= F (<D) = {(r2, r1)}. If <D is arbitrary,30 we can repeat the above calculation and obtain the values of Equation 4.3,31 which are shown in Table 1."}, {"heading": "4.1.3 Properties of the Generalised SP Order", "text": "We prove some properties of F (Equation 4.3 and Algorithms 2 and 3) that will be useful in proving the representation theorem for the case where <D is a partial order (Theorem 4.11). It can easily be shown that F is a well-defined function from PO (Rd) to itself, where PO (Rd) is the set of all strict partial orders on Rd (Section 2.1). We show that the function F : PO (Rd) \u2192 PO (Rd) indeed generalises the definitions in Section 3.2. Recall that TO(X) is the set of all strict total orders on the set X .\nLemma 4.1. If <D\u2208 TO (Rd) then we recover <SP defined in Section 3.2.\nProof. If <D is total, then R \u03bb on Algorithm 2 Line 8 is singleton. This means Line 10 has only one choice in R\u03bb, so Si for all 0 \u2264 i \u2264 N is singleton. Using the notation of Equation 3.4, Algorithm 2 returns {\u201caNaN\u22121 . . . a2a1\u201d}. This gets transformed into Equation 3.5 through Algorithm 3, which is <SP for the case of <D total.\n30There are 19 partial orders on a set of three labelled elements. 31 We abbreviate the total order r3 <D r2 <D r1 as 321, <D:= {(r1, r2) , (r3, r2)} as\n(12,32), and <D= {(r1, r3)} as 13... etc. and the same applies to <SP .\nExample 9. (Example 8 continued) By restricting F to TO (Rd), we obtain the following subtable of Table 1, which indeed generalises the calculation for the case where the input <D is total.\nThe next result shows that given the input <D in Algorithm 2, each string in the output set of Algorithm 2, when transformed into its corresponding total order on Rd, is the output of Equation 4.3 for some linearisation < + D of <D.\nTheorem 4.2. Consider Algorithm 2 with input <D\u2208 PO (Rd). For each string \u03c3 in the output set of Algorithm 2, let <out denote \u03c3 transformed into a strict total order on Rd (Algorithm, 3). For each such <out there exists a linearisation <+D of <D such that <out= F ( <+D ) .\nProof. If <D is itself total, then the output of Algorithm 2 is singleton, which when converted to a chain by Algorithm 3 gives <out=<SP . Therefore, there exists a linearisation of <D, namely itself, such that <out= F (<D).\nIf <D is not total, then incomparable rules will cause R \u03bb (Algorithm 2 Line 8) to not be singleton. Each element of R\u03bb will form a distinct element of the output set of Algorithm 2. Choosing a given rule r in R\u03bb to append to the string can also be interpreted as a resolution of this incomparability of <D through a linearisation < + D of <D that ranks r higher than the alternative choices. Reasoning in this way in all cases whenever R\u03bb is not singleton, we obtain a linearisation <+D of <D such that F ( <+D )\ncorresponds to one of the elements in the output SN of Algorithm 2.\nIt follows that Equation 4.3 incorporates all possible linearisations of <D in the following manner.\nCorollary 4.3. The output of Equation 4.3 is equal to\n<SP= F (<D) = \u22c2\n< +\nD \u2287<D total\nF ( <+D ) ,\nwhere the intersection ranges over all linearisations of <D.\nProof. This is immediate from the definition of Algorithm 3 and Theorem 4.2.\nExample 10. (Example 9 continued) Consider <D= 23, which abbreviates <D= {(r2, r3)}. 23 has linearisations abbreviated as 123, 213 and 231 (see Footnote 31, page 37). By Table 2, these input linearisations returns, respectively, 213, 213 and 231. By Corollary 4.3, we get <SP to be the intersection of the sets representing the total orders 213 and 231. This gives (21, 23), which abbreviates <SP= {(r2, r1) , (r2, r3)}. This is consistent with Table 2.\nWe now relate the linearisations of the inputs and outputs of Table 1.\nTheorem 4.4. (The linearisation square) Let <D \u2208 PO (Rd) and < + D be a linearisation of <D. F ( <+D ) =:<+SP is a linearisation of F (<D) =:<SP .\nProof. Let <SP be as given. Let < + D be a linearisation of <D. Suppose < + D is the input of Algorithm 2. This will give an output set consisting of a single string that Algorithm 3 translates into some strict linear order <+SP (say), by Theorem 4.1. Upon input <D to Algorithm 2, the string corresponding to < + SP will appear in the output set of Algorithm 2, because we can choose the rules in R\u03bb (Line 8) in accordance with the ranking of <+D \u2287 <D. By Algorithm 3, <+SP \u2287 F (<D) =<SP .\nThe linearisation square can be expressed in the following commutative diagram:\n<D <+D\nF (<D) F ( <+D )\n//\nlinearisation\u2774\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\nEquation 4.3\n\u2774\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\n\u2724\nEquation 4.3\n//\nlinearisation\nThe linearisation square states that the function F : PO (Rd) \u2192 PO (Rd) preserves linearisations.\nExample 11. (Example 10 continued) Consider Table 1 again. Let <D= 31. Let <+D= 321. We know that <SP= (21, 31). We also know that < + SP= 321. Clearly, 321 is a linearisation of (21, 31)."}, {"heading": "4.1.4 The Generalised Argument Preference Relation for <D Partial", "text": "The following result states that changing the partial order PDL default priority < to respect the logical dependencies of defaults while following the preference does not change the PDL extension. This generalises Lemma 3.7 (page 21) to the case where <D is not necessarily total.\nLemma 4.5. Let T := \u3008D,W,<\u3009 and T \u2032 := \u3008D,W,<\u2032\u3009 be two PDTs such that <\u223c=<D and F (<D) \u223c=< \u2032, then both PDTs have the same extensions\nProof. Denote Ext(T ) and Ext (T \u2032) to be the sets of extensions of the respective PDTs. We show that Ext(T ) = Ext (T \u2032).\n(\u21d2) Let E \u2208 Ext (T ) be arbitrary. This means E is the unique extension of some LPDT T+ := \u3008D,W,<+\u3009, where <+\u2287< is a strict total order. Therefore, <+ \u223c= <+D \u2287 <D\n\u223c= <, where <+D is a linearisation of <D. By the linearisation square (Theorem 4.4), F (\n<+D ) =:<+SP is a linearisation of F (<D) =:<SP . As\n<\u2032 \u223c=<SP , then < + SP \u223c=< \u2032+, where < \u2032+ is some linearisation of <\u2032. By Lemma 3.7, E is also the unique extension of the LPDT \u2329 D,W,< \u2032+ \u232a , which means E\nis an extension of T \u2032 = \u3008D,W,<\u2032\u3009. Therefore, E \u2208 Ext (T \u2032). (\u21d0) Let E \u2208 Ext (T \u2032) be arbitrary. This means E is the unique extension of some LPDT T+ := \u2329 D,W,< \u2032+ \u232a , where < \u2032+ \u2287 <\u2032 is a strict total order. As\n< \u2032+ \u223c=<+SP , which is a linearistaion of <SP , then by Theorem 4.2, there exists a linearisation <+D of <D such that < + D 7\u2192 < + SP , given that <D 7\u2192 <SP . By Lemma 3.7, E is the unique extension of T+ := \u3008D,W,<+\u3009, where <+ \u223c= <+D, which means E is an extension of T . Therefore, E \u2208 Ext (T ). Therefore, Ext (T ) = Ext (T \u2032).\nExample 12. (Example 11 continued) Recall the setup of Example 8, where W = \u2205 and\nD =\n{\nd1 := : a\na , d2 :=\na : b\nb , d3 :=\n: \u00acb\n\u00acb\n}\n.\nConsider two strict partial orders on D, < and <\u2032, where d1 < d2 only and d2 < \u2032 d1 only. This gives us two PDTs T = \u3008D,W,<\u3009 and T \u2032 = \u3008D,W,<\u2032\u3009. Let <D \u223c= <. By Table 1, F (<D) = 21 so F (<D) \u223c= < \u2032. Both PDTs T and T \u2032 have the same extensions. In the case of T , we have linearisations 312, 132 and 123, with the first linearisation giving E1 := Th ({a, b}) and the latter two linearisations giving E2 := Th ({a,\u00acb}). In the case of T\n\u2032, we have linearisations 321, 231 and 213, with the first linearisation giving E1 and the latter two linearisations giving E2. Therefore, both T and T\n\u2032 have the same extensions.\nWe can now define the associated set comparison relation from this new <SP just like Equation 3.7: for \u0393, \u0393\u2032 \u2286fin Rd,\n\u0393 \u22b3SP \u0393 \u2032 \u21d4 (\u2203x \u2208 \u0393\u2212 \u0393\u2032) (\u2200y \u2208 \u0393\u2032 \u2212 \u0393)x <SP y, (4.4)\nwhere given the partial order default priority <, order isomorphic to <D (Equation 3.1), <SP= F (<D) is the output of Equation 4.3. The associated strict argument preference is, for A,B \u2208 A,\nA \u227aSP B \u21d4 DR(A) \u22b3SP DR(B). (4.5)\nThe associated non-strict argument preference is\nA -SP B \u21d4 [DR(A) \u22b3SP DR(B) or DR(A) = DR(B)] , (4.6)\nThese equations are the same as Equations 3.8 and 3.9 respectively.32\nExample 13. (Example 8 continued) Suppose we define \u227aSP by Equation 4.5 with this new <SP . We have both A 6\u227aSP B and B 6\u227aSP A. This means there are two stable extensions: E1 which contains A0 and A, and E2 which contains A0 and B. The conclusion set of these stable extensions correspond respectively to E1 and E2.\nSo given a PDT T where the default priority < is not necessarily total, we construct the set of arguments A and define the attack relation \u21c0 as in Section 4. We define the non-strict argument preference relation -SP as in Equations 4.6, 4.5, 4.4 and 4.3, given < \u223c= <D. The attack graph of the PDT T is the structure AG(T ) := \u3008A,\u21c0,-SP \u3009. The defeat graph of the PDT (T ) is the structure DG(T ) := \u3008A, \u2192\u0592\u3009, where \u2192\u0592 is defined as in Equation 2.3 under the argument preference relation -SP ."}, {"heading": "4.2 The Representation Theorem for Partial Order Default Priorities", "text": "We now generalise Theorem 3.14 to the case where <D is a partial order. Our proof strategy is to leverage as much of Theorem 3.14 as possible. The difference here is that our default priority<\u223c=<D is now partial. In the previous section, we saw how the linearisation square (Theorem 4.4) related the lift <D 7\u2192<SP to the lift <+D 7\u2192< + SP where< + D is a linearisation of <D. We now apply the linearisation square to relate partial order <D with their linearisations < + D in the case of the defeat graphs generated and their stable extensions. Specifically, if <+D is a linearisation of <D, then the defeat graph of the former is a spanning subgraph of the latter. Further, the unique stable extension in the former case is still a well-defined stable extension in the latter case. The next two sections establish these results, which will then be used to prove the generalised representation theorem."}, {"heading": "4.2.1 Linearisation of the Argument Preference Relation and Spanning Subgraphs", "text": "Recall from graph theory that G\u2032 := \u3008V,E\u2032\u3009 is a spanning subgraph of G := \u3008V,E\u3009 iff E\u2032 \u2286 E, and we write G\u2032 \u2286span G. For spanning argument subframeworks, stable extensions are preserved as long as you do not add conflicts between arguments in the stable extension.\nLemma 4.6. Let AF := \u3008A,\u2192\u3009 be an abstract argumentation framework. Let AF \u2032 := \u3008A,\u2192\u2032\u3009 be a spanning subgraph of AF . If E is a stable extension of AF \u2032 and E2\u2229 \u2192= \u2205, then E is also a stable extension of AF .\n32It can be shown that -SP in the partial order case is not transitive, unlike in the total case (Lemma 3.5, also recall Footnote 15), but is acyclic. We will discuss this in future work.\nProof. By assumption, E is cf because it is a stable extension. Let b /\u2208 E , then E \u2192\u2032 b, but as \u2192\u2032 \u2286 \u2192 by definition, we also have E \u2192 b. Therefore, E is a stable extension of AF .\nLinearising the structure preference order <SP on the rules also linearises the set comparison relation \u22b3SP and the argument preference -SP by Lemma 3.4.\nLemma 4.7. Let <SP be the output of Equation 4.3 for some input <D. Let <+SP be a linearisation of <SP . Let the binary relations on Pfin (Rd), \u22b3SP and \u22b3+SP , be obtained by applying Equation 4.4 to <SP and < + SP respectively. Then\n1. \u22b3SP \u2286 \u22b3 + SP ,\n2. \u227aSP \u2286 \u227a + SP , where \u227aSP is the strict part of Equation 4.5 on \u22b3SP and\nanalogously for \u227a+SP on \u22b3 + SP , and\n3. -SP \u2286- + SP .\nProof. (1) Let \u0393, \u0393\u2032 \u2208 Pfin (Rd) be arbitrary. Assume \u0393 \u22b3SP \u0393 \u2032. Then by Equation 4.4, this is equivalent to (\u2203x \u2208 \u0393\u2212 \u0393\u2032) (\u2200y \u2208 \u0393\u2032 \u2212 \u0393)x <SP y, which by our assumption implies that (\u2203x \u2208 \u0393\u2212 \u0393\u2032) (\u2200y \u2208 \u0393\u2032 \u2212 \u0393)x <+SP y, and hence \u0393 \u22b3+SP \u0393\n\u2032. (2) Let A,B \u2208 A be arbitrary. We have A \u227aSP B \u21d4 DR(A) \u22b3SP DR(B). From the first result, DR(A) \u22b3SP DR(B) then DR(A) \u22b3 + SP DR(B). (3) This follows trivially from Equation 4.5.\nWe now prove the converse of Lemma 4.7.\nLemma 4.8. Let T be a PDT, < \u223c= <D and <SP= F (<D). Let < + SP be a linearisation of <SP . Let -SP and - + SP be the lift of <SP and < + SP respectively from Rd to an argument preference relation on A in the usual way (Equations 4.4 and 4.5). Let DG(T ) := \u3008A, \u2192\u0592\u3009 and DG+ (T ) := \u3008A, \u2192\u0592+\u3009 be the respective defeat graphs of the attack graphs AG(T ) := \u3008A,\u21c0,-SP \u3009 and AG\n+ (T ) := \u2329\nA,\u21c0,-+SP \u232a . Then DG+ (T ) \u2286span DG(T ).\nProof. Clearly both DG(T ) and DG+(T ) have the same vertex set A. We show that \u2192\u0592+ \u2286 \u2192\u0592. Let A,B \u2208 A be arbitrary such that A \u2192\u0592+ B. Suppose B\u2032 \u2286arg B is the argument defeated by A at its top rule. By Equation 2.3, A \u21c0 B\u2032 and A 6\u227a+SP B \u2032. It is sufficient to show that A 6\u227aSP B \u2032. By Lemma 4.7, we have \u227aSP \u2286\u227a + SP meaning that if A 6\u227a + SP B \u2032 then A 6\u227aSP B \u2032. Hence, A \u2192\u0592 B\u2032 and so A \u2192\u0592 B. It follows that \u2192\u0592+ \u2286 \u2192\u0592."}, {"heading": "4.2.2 Existence of Stable Extensions in the Partial Order Case", "text": "For a PDT T , its defeat graph DG (T ) has stable extensions that do not have to be unique.\nTheorem 4.9. Let T be a PDT, with attack graph AG(T ) and defeat graph DG(T ) where, as usual, < \u223c= <D, <SP= F (<D) by Equation 4.3, and -SP is defined from <SP using Equations 4.4 and 4.5. The defeat graph DG(T ) has a stable extension that is not in general unique.\nProof. The PDT T has some extension E, which is the unique stable extension of an LPDT T+ := \u3008D,W,<+\u3009, where<+ is the linearisation of< that generates E. Given that <\u223c=<D and < +\u223c=<+D, we know that < + D is also a linearisation of <D. By the linearisation square (Theorem 4.4), F ( <+D )\n=:<+SP is a linearisation of F (<D) =:<SP .\nThe LPDT T+ has an attack graph AG (T+) := \u2329 A,\u21c0,-+SP \u232a , where -+SP is calculated from <+SP . As < + SP is a linearisation of <SP , the defeat graph of T+, DG (T+) := \u3008A, \u2192\u0592+\u3009 is a spanning subgraph of DG(T ) by Lemma 4.8. The LPDT T+ has E as its unique PDE. By the representation theorem for LPDTs (Theorem 3.14), there exists a unique stable extension E of DG (T+) such that Conc (E) = E. By Corollary 3.21, E2 \u2229 \u21c0= \u2205. DG(T ) differs from DG (T+) by their argument preference relations, as the attack relation is the same for both. As no attacks are introduced to E , E is also cf in DG(T ) by Equation 2.3. Therefore, by Lemma 4.6, E is also a stable extension of DG(T ). Therefore, DG(T ) also has E as a stable extension.\nTo show that this stable extension is not in general unique, consider the PDT \u2329{\nd1 := :a a , d2 := :\u00aca \u00aca\n} ,\u2205,\u2205 \u232a\n. We can construct the arguments A := [\u21d2 a] and B := [\u21d2 \u00aca], which symmetrically attack each other on their conclusions. As <= \u2205, we have <D=<SP= \u2205 from Equation 4.3. Therefore, A 6\u227aSP B and B 6\u227aSP A and we have two stable extensions: one where A is justified (and B is not justified), and the other where B is justified (and A is not justified)."}, {"heading": "4.2.3 Proof of the Representation Theorem", "text": "We prove the representation theorem in this section. Our technique is to relate a partial order on the defaults < with one of its possible linearisations <+, and invoke the first representation theorem (Theorem 3.14) for this linearisation. We know given an extension E of some PDT T there is a linearisation <+ of < generating E. We now establish an analogous result on the side of argumentation: for every stable extension E of DG (T ), there is a linearisation <+SP of <SP on Rd such that < + SP constructs E via Algorithm 1.\nWe show <+SP exists given <SP by construction, which will make use of a partial linearisation of an order < on P . Let \u3008P,<\u3009 be a poset and U \u2286 P . Let <U :=< \u2229U\n2 be the partial order < restricted to U . Let <+U be a linearisation of <U on U . We define\n<parU := TrCl ( <+U \u222a < ) , (4.7)\nwhere TrCl denotes the transitive closure. It can be shown that given \u3008P,<\u3009 and U , <parU is a strict partial order on P extending <, which is linear when restricted to the set U . Further, <parU is not unique because there could be many possible linearisations of < over U .\nLemma 4.10. Let T be a PDT with defeat graph DG(T ) where <SP lifts to -SP . Let E be a stable extension of DG(T ). There exists a linearisation < + SP of <SP such that E is the output of Algorithm 1 with < + SP as input.\nProof. Given E , let R+ := DR (E) and R\u2212 = Rd \u2212 R +. Define <0:=< par SP,R\u2212 , which is Equation 4.7 with \u3008P,<\u3009 = \u3008Rd, <SP \u3009 and U = R \u2212. As Rd is finite, WLOG let R\u2212 := {s1, s2, . . . , sm} for some m \u2208 N, such that i < j \u21d4 sj <0 si. so s1 is <0-greatest on R \u2212. For 1 \u2264 i \u2264 m, define the set\nnonlower<i\u22121(si) :=: Ui := {r \u2208 Rd r 6<i\u22121 si} . (4.8)\nFor 0 \u2264 i \u2264 m \u2212 1 we extend <i to a new partial order <i+1:=< par i,Ui+1 , which is Equation 4.7 with \u3008P,<\u3009 = \u3008Rd, <i\u3009 and U = Ui (Equation 4.8), such that si is the <i-least element on the set Ui. Once we reach <m we take a final linearisation of<m to get< + SP .\n33 This construction therefore gives an increasing sequence of partial orders <SP\u2286<0\u2286<1\u2286 \u00b7 \u00b7 \u00b7 \u2286<m\u2286< + SP . on Rd. Clearly, < + SP is a well-defined linearisation of <SP by construction. To show that <+SP generates E when input into Algorithm 1, consider si \u2208 R\u2212. We assume no defeasible rule is unnecessary, i.e. (\u2200r \u2208 Rd) (\u2203A \u2208 A) r \u2208 DR(A). In other words, each defeasible rule is used in some argument.34 Therefore, there is some argument Bi \u2208 A such that TopRule (Bi) = si. By how <SP is defined, si is the <SP -least rule in DR (Bi). By Lemma 3.12, Bi /\u2208 E so E \u2192\u0592 Bi. Let Ai \u2192\u0592 Bi for Ai \u2208 E . This would mean Ai 6\u227aSP Bi.\nWe show that for the set of defeasible rules Ui associated with rule si as defined in Equation 4.8, (\u2200r \u2208 DR (Ai)) r \u2208 Ui. Assume for contradiction that (\u2203r \u2208 DR (Ai)) r /\u2208 Ui, then there is some r0 \u2208 DR (Ai), r0 <i\u22121 si. By the properties of Equation 4.7, we can show that r0 <i\u22121 si <i\u22121 si\u22121 <i\u22121 \u00b7 \u00b7 \u00b7 <i\u22121 s1. Therefore, r0 cannot be in the sets Uj for any j < i, and so could not have been linearised above sj for j < i in any of the previous stages. Therefore, r0 <SP si. As si is <SP -least in DR (Bi) by being the top rule of Bi, r0 /\u2208 DR (Bi) and hence there is some rule, r0 \u2208 DR (Ai)\u2212DR (Bi), such that for all rules x \u2208 DR (Bi)\u2212DR (Ai), r0 <SP x. Therfore, Ai \u227aSP Bi \u2013 contradiction, as Ai \u2192\u0592 Bi. Therefore, all the defeasible rules of Ai are in Ui, and in the linearisation process where <i\u22121 is linearised over Ui into <i such that si is <i-minimal in Ui, we have ensured that at least one defeater of Bi will be constructed by Algorithm 1 and included in E prior to the consideration of the rule si. As i is arbitrary, we have shown that the final linearisation < + SP ensures that all arguments containing rules in R\u2212 are defeated and excluded from E . Therefore, Algorithm 1, upon input from <+SP , generates exactly E .\nWe give two concrete examples of the construction of <SP in Lemma 4.10.\nExample 14. Consider the PDT \u2329{ d1 := :a a , d2 := :\u00aca \u00aca } ,\u2205,\u2205 \u232a\nfrom the proof of Theorem 4.9. Translating to argumentation, there are two argumentsA := [\u21d2 a] and B := [\u21d2 \u00aca] which attack each other at their conclusions. Clearly, <SP= \u2205 and there are two stable extensions: E1 such that A \u2208 E1 and E2 such that B \u2208 E2. Suppose we choose the stable extension E1 and construct a linearisation of \u2205 that generates E1. We have R + = {r1} and R \u2212 = {r2}. Vacuously, <SP\n33Simple examples can be devised where <m is not a total order on Rd. 34This is a fair assumption to make given that PDTs typically do not have defaults that\nare excluded from all extensions.\nis already linear on {r2} so <0=<SP . We then consider nonlower<SP (r2) = {r1, r2}. We linearise <SP such that r2 is smaller than all other elements in nonlower<SP (r2), so r2 < + SP r1. This is indeed the linearisation of <SP that generates E1.\nExample 15. Let Kn = \u2205 and r1 := (\u21d2 \u00acb), r2 := (\u21d2 a), r3 := (a \u21d2 b), r4 := (\u21d2 c), r5 := (c \u21d2 \u00acb), r6 := (\u21d2 b). Define A := [\u21d2 \u00acb], B := [[\u21d2 a] \u21d2 b], C := [[\u21d2 c] \u21d2 \u00acb] and D := [\u21d2 b]. We illustrate these arguments in Figure 4.2.\nSuppose <SP is such that r6 <SP r5 <SP r4, r5 <SP r3 <SP r1 and r3 <SP r2. It can be shown that D \u227aSP C \u227aSP B \u227aSP A hence A \u2192\u0592 B \u2192\u0592 C \u2192\u0592 D (notice A \u2192\u0592 D as well). The stable extension therefore contains A, C and [\u21d2 a], so R\u2212 = {r3, r6}. As r6 <SP r3, <SP is already linear on R\n\u2212, so <0=<SP . Now consider nonlower<0(r3) = {r1, r2, r3, r4} and linearise <SP over this set such that r3 is the smallest element in nonlower<0(r3), so suppose <1 is r3 <1 r1 <1 r2 <1 r4. Now consider r6, but nonlower<1(r6) = Rd and is already linear, so we take <+SP to be the chain 653124 when written in abbreviated form (see Footnote 31, page 37). This <+SP , when input into Algorithm 1, will generate E .\nWe now apply Lemma 4.10 to prove a more general representation theorem.\nTheorem 4.11. (The Representation Theorem for Partial Order Default Priorities) Let AG(T ) be the attack graph corresponding to a PDT T , where the default priority < is not necessarily total, with defeat graph DG(T ) under -SP as defined by Equations 4.3, 4.4 and 4.5.\n1. Let E be an extension of T . Then there exists a corresponding stable extension E \u2286 A of DG(T ) such that Conc (E) = E.\n2. Let E \u2286 A be a stable extension of DG(T ), then Conc(E) is an extension of T .\nProof. Proof of part 1: Let E be an extension of T , then there exists a LPDT T+ := \u3008D,W,<+\u3009 where <+ is a linerisation of < that generates the extension E (Equation 2.5). Consider the defeat graph DG (T+). By Theorem 3.14, there exists a stable extension E of DG (T+) such that Conc (E) = E. Arguing as\nin the proof of Theorem 4.9 where DG (T+) \u2286span DG(T ), E is also a stable extension of DG(T ), and it satisfies Conc (E) = E.\nProof of part 2: Let E be a stable extension, which exists by Theorem 4.9. By Lemma 4.10, there is a linearisation <+SP of <SP such that Algorithm 1 returns E upon input <+SP . Consider the LPDT T + 1 := \u2329 D,W,<+1 \u232a , where <+1 \u223c=<+SP . By Section 3, this has a defeat graph DG ( T+1 ) with unique stable extension E . The set Conc (E) is an extension of T+1 by Theorem 3.14. Clearly Conc (E) is also an extension of \u3008D,W,<1\u3009, where <1 \u223c= <SP . By Lemma 4.5, Conc (E) is also an extension of \u3008D,W,<\u3009 = T .\nUnder the generalised SP argument preference-SP , this representation theorem means that PDL is also sound and complete with respect to its argumentation semantics in the case where the default priority < is not necessarily total."}, {"heading": "4.3 Satisfaction of Rationality Postulates", "text": "In this section we will state and prove a version of Theorem 3.20, which is that the rationality postulates [10] hold for the stable extensions of the defeat graph, instead for all complete extensions. We will discuss the possibility for a general proof in Section 5.\nTheorem 4.12. (Rationality Theorem for Stable Extensions) Let T := \u3008D,W,<\u3009 be a PDT. Let its corresponding attack graph be AG(T ) := \u3008A,\u21c0,-SP \u3009 where < \u223c= <D 7\u2192 <SP by Equation 4.3, and -SP is defined in terms of <SP using Equations 4.4 and 4.5. Let DG(T ) := \u3008A, \u2192\u0592\u3009 be the corresponding defeat graph. All stable extensions of DG(T ) satisfy the Caminada-Amgoud rationality postulates.\nProof. Given T , let E be any stable extension of DG(T ).\n1. To show that E is subargument closed, let A \u2208 E and let B \u2286arg A. Assume for contradiction that B /\u2208 E , then E \u2192\u0592 B and hence there is some C \u2208 E such that C \u2192\u0592 B. Therefore, C \u2192\u0592 A. This means E is not cf \u2013 contradiction. Therefore, B \u2208 E as well, and E is thus subargument closed.\n2. Theorem 4.11 states that Conc (E) is an extension of T , which is deductively closed. Therefore, Conc (E) is closed under strict rules.\n3. As W is consistent and Conc (E) is an extension of T , Conc (E) must also be consistent and its deductive closure is consistent.\nThis shows the result.\nIn conclusion, all stable extensions are normatively rational. This generalises the rationality theorem (Theorem 3.20) to the case where <D is partial, although only for stable extensions."}, {"heading": "4.4 Summary", "text": "In this section, we have generalised our sound and complete instantiation of ASPIC+ to PDL to the case where the default priority is not necessarily a total order. The main challenge is generalising the SP argument preference -SP from a total default priority to a partial default priority. We devise a sorting F (<D) =<SP such that <SP sorts <D in a way that respects the argument structure, the defeasible rule preference <D, and the incomparability of rules (Section 4.1). This preference has the correct properties to preserve the correspondence between the inferences of the underlying PDT and the conclusions of justified arguments (Section 4.2, Theorem 4.11). We have also shown that each stable extension satisfies the rationality postulates (Section 4.3, Theorem 4.12)."}, {"heading": "5 Conclusions", "text": "We have endowed Brewka\u2019s PDL [7] with argumentation semantics using ASPIC+ [16]. This is achieved by representing PDL in ASPIC+ (Sections 3.1 and 4), discussing which argument preference relations can be suitable for the correspondence of inferences (Sections 3.2 and 4.1), proving that the inferences do correspond under an appropriate preference relation -SP (Sections 3.3 and 4.2), and that this instantiation is rational (Sections 3.4 and 4.3). As explained in Section 1, this allows us to interpret the inferences of PDL as conclusions of justified arguments, clarifying the reasons for accepting or rejecting a conclusion. The argumentative characterisation of PDL provides for distributed reasoning in the course of deliberation and persuasion dialogues. This would allow BOID agents with PDL representations of mental attitudes to exchange arguments and counterarguments when deliberating about which goals to select, and thus which actions to pursue [9]."}, {"heading": "5.1 Related Work", "text": "As mentioned in Section 1, there are many existing argumentative characterisations of non-monotonic logics (e.g. [11, 12]). However, there has been relatively little work in using defeasible rules to represent defaults, because the defeasible components of arguments are often captured in the premises [5, 16]. Reiter\u2019s default logic (DL) [19], as a partial special case35 of Brewka\u2019s PDL [7, Proposition 6], has been endowed with sound and complete argumentation semantics by Dung [11, Section 4.1]. However, DL cannot handle priorities and as a result draws counter-intuitive inferences. We know that conflicts between defaults often occur and priorities are an intuitive and high-level way of resolving such conflicts [7, 8]. It is therefore important to investigate how preferences can also be incorporated into any argumentation semantics. ASPIC+ is a good framework to achieve this because it is designed to handle preferences.\n35i.e. in the case where all defaults are normal defaults."}, {"heading": "5.2 Future Work", "text": "Brewka\u2019s preferred subtheories (PS) [6] has been endowed with argumentation semantics by Modgil and Prakken using ASPIC+ [16, Section 5.3.2]. Given that PS is a special case of PDL [6], it is interesting to see how the argumentation semantics are related. It can be shown that instantiating the argumentation semantics of PDL in this paper to the case of supernormal defaults and empty facts will recover an argumentation semantics isomorphic to the argumentation semantics of Modgil and Prakken. However, whereas Modgil and Prakken assume that arguments must be consistent, the results of Section 3.4.3 lifts this assumption when we specialise our argumentation semantics. We will articulate this in future work.\nIt will also be interesting to see how an argumentation semantics for Reiter\u2019s normal DL [19, Section 3] can be recovered by setting <D= \u2205 [7, Proposition 6], and comparing this to Dung\u2019s argumentation semantics for DL. However, Dung\u2019s argumentation semantics also accommodates non-normal defaults. How would ASPIC+ incorporate non-normal defaults? At first glance it should involve the naming function and undercuts (Section 2.2), but how can soundness and completeness be proven? How can the argumentation semantics help us understand the interaction of explicit default priority relations with the implicit priority of non-normal defaults [21]? Future work will explore further properties of this argumentation semantics.\nASPIC+ can be used to generalise PDL. For example, we know that extensions do not have to exist for non-normal default logic, which corresponds to the failure for stable extensions to exist in the argumentation semantics [11, Section 4.1]. We can then consider the justified arguments under different Dung semantics, but what would these other notions of justified arguments mean for PDL?\nAnother reason for considering different Dung semantics is to show whether the rationality postualtes holds for complete extensions in general. So far we have shown a special case of rationality for the stable extensions only (Section 4.3). What would the complete extensions look like in this case? How are they related to the other Dung semantics [11, Section 2.3]? Alternatively, one can invoke the theory of ASPIC+, which states that normative rationality automatically follows if the instantiation is well-defined with a reasonable argument preference relation [16, Definitions 12 and 18]. Although it is easy to see that our instantiation is well-defined if the underlying PDT is consistent, it is not obvious whether -SP in the partial order case is reasonable. This will be the subject of future work.\nFinally, we have argued that endowing PDL with argumentation semantics provides for distributed reasoning amongst agents (in particular BOID agents for which PDL has been used to generate individual agents\u2019 goals). Such distributed reasoning in the form of dialogue can be formalised as a generalisation of argument game proof theories for Dung frameworks [15], whereby agents not only can submit arguments, but locutions that implicitly define arguments providing the reasons for a given claim. We will investigate this in future work."}], "references": [{"title": "A Dialogue Game Protocol for Multi-Agent Argument over Proposals for Action", "author": ["K. Atkinson", "T. Bench-Capon", "P. McBurney"], "venue": "Autonomous Agents and Multi-Agent Systems, 11(2):153\u2013171,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Ranking Sets of Objects", "author": ["S. Barber\u00e0", "W. Bossert", "P.K. Pattanaik"], "venue": "S. Barber\u00e0, P. J. Hammond, and C. Seidl, editors, Handbook of Utility Theory, Volume 2 \u2013 Extensions, chapter 17, pages pp. 893 \u2013 978. Springer Science + Business Media, 1st edition,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2004}, {"title": "Introduction to Structured Argumentation", "author": ["P. Besnard", "A. Garcia", "A. Hunter", "S. Modgil", "H. Prakken", "G. Simari", "F. Toni"], "venue": "Argument & Computation, 5(1):1\u20134,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "Handbook of the History of Logic, volume 8, chapter Nonmonotonic Reasoning, pages 557\u2013632", "author": ["A. Bochman"], "venue": "Elsevier,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "An abstract, argumentation-theoretic approach to default reasoning", "author": ["A. Bondarenko", "P.M. Dung", "R.A. Kowalski", "F. Toni"], "venue": "Artificial Intelligence, 93(1):63\u2013101,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1997}, {"title": "Preferred Subtheories: An Extended Logical Framework for Default Reasoning", "author": ["G. Brewka"], "venue": "IJCAI, volume 89, pages 1043\u20131048,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1989}, {"title": "Adding Priorities and Specificity to Default Logic", "author": ["G. Brewka"], "venue": "Logics in Artificial Intelligence, pages 247\u2013260. Springer,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1994}, {"title": "Prioritizing Default Logic", "author": ["G. Brewka", "T. Eiter"], "venue": "Intellectics and Computational Logic, pages 27\u201345. Springer,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2000}, {"title": "Goal Generation in the BOID Architecture", "author": ["J. Broersen", "M. Dastani", "J. Hulstijn", "L. van der Torre"], "venue": "Cognitive Science Quarterly Journal,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2002}, {"title": "On the Evaluation of Argumentation Formalisms", "author": ["M. Caminada", "L. Amgoud"], "venue": "Artificial Intelligence, 171(5):286\u2013310,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "On the Acceptability of Arguments and its Fundamental Role in Nonmonotonic Reasoning, Logic Programming and n-Person Games", "author": ["P.M. Dung"], "venue": "Artificial Intelligence, 77:321\u2013357,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1995}, {"title": "Argumentation Semantics for Defeasible Logic", "author": ["G. Governatori", "M.J. Maher", "G. Antoniou", "D. Billington"], "venue": "Journal of Logic and Computation, 14(5):675\u2013702,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "What does a conditional knowledge base entail", "author": ["D. Lehmann", "M. Magidor"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1992}, {"title": "An Argumentation Based Semantics for Agent Reasoning", "author": ["S. Modgil"], "venue": "M. Dastani, A. El Fallah Seghrouchni, J. Leite, and P. Torroni, editors, Languages, Methodologies and Development Tools for Multi-Agent Systems, volume 5118 of Lecture Notes in Computer Science, pages 37\u201353. Springer Berlin Heidelberg,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2008}, {"title": "Proof Theories and Algorithms for Abstract Argumentation Frameworks", "author": ["S. Modgil", "M. Caminada"], "venue": "Argumentation in Artificial Intelligence, pages 105\u2013129. Springer,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "A General Account of Argumentation with Preferences", "author": ["S. Modgil", "H. Prakken"], "venue": "Artificial Intelligence, 195:361\u2013397, February", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "The Added Value of Argumentation", "author": ["S. Modgil", "F. Toni"], "venue": "Agreement Technologies,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2013}, {"title": "An Abstract Framework for Argumentation with Structured Arguments", "author": ["H. Prakken"], "venue": "Argument and Computation, 1(2):93\u2013124,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2010}, {"title": "A Logic for Default Reasoning", "author": ["R. Reiter"], "venue": "Artificial Intelligence, 13:81\u2013132,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1980}, {"title": "Nonmonotonic reasoning", "author": ["R. Reiter"], "venue": "Annual Review of Computer Science, 2:147\u2013186,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1987}, {"title": "On Interacting Defaults", "author": ["R. Reiter", "G. Criscuolo"], "venue": "IJCAI, volume 81, pages 270\u2013276,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1981}, {"title": "Logic and Artificial Intelligence\u201d, The Stanford Encyclopedia of Philosophy (Winter 2013 Edition), Edward N. Zalta (ed.), forthcoming URL = \u3008http://plato.stanford.edu/archives/win2013/entries/logic-ai/", "author": ["R. Thomason"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2013}, {"title": "Argumentation Semantics for Prioritised Default Logic", "author": ["A.P. Young", "S. Modgil", "O. Rodrigues"], "venue": "arXiv preprint arXiv:1506.08813,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2015}, {"title": "Prioritised Default Logic as Rational Argumentation", "author": ["A.P. Young", "S. Modgil", "O. Rodrigues"], "venue": "J. Thangarajah, K. Tuyls, C. Jonker, and S. Marsella, editors, Proceedings of the 15th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2016),", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2016}], "referenceMentions": [{"referenceID": 22, "context": "27 The results of Section 3 first appeared in the preprint [23] and have been published in the conference proceedings of AAMAS2016 [24].", "startOffset": 59, "endOffset": 63}, {"referenceID": 23, "context": "27 The results of Section 3 first appeared in the preprint [23] and have been published in the conference proceedings of AAMAS2016 [24].", "startOffset": 131, "endOffset": 135}, {"referenceID": 10, "context": "Dung\u2019s abstract argumentation theory [11] has become established as a means for unifying various nonmonotonic logics (NMLs) [4,20,22], where the inferences of a given NML can be interpreted as conclusions of justified arguments.", "startOffset": 37, "endOffset": 41}, {"referenceID": 3, "context": "Dung\u2019s abstract argumentation theory [11] has become established as a means for unifying various nonmonotonic logics (NMLs) [4,20,22], where the inferences of a given NML can be interpreted as conclusions of justified arguments.", "startOffset": 124, "endOffset": 133}, {"referenceID": 19, "context": "Dung\u2019s abstract argumentation theory [11] has become established as a means for unifying various nonmonotonic logics (NMLs) [4,20,22], where the inferences of a given NML can be interpreted as conclusions of justified arguments.", "startOffset": 124, "endOffset": 133}, {"referenceID": 21, "context": "Dung\u2019s abstract argumentation theory [11] has become established as a means for unifying various nonmonotonic logics (NMLs) [4,20,22], where the inferences of a given NML can be interpreted as conclusions of justified arguments.", "startOffset": 124, "endOffset": 133}, {"referenceID": 10, "context": "This has already been done for default logic [11], logic programming [11], defeasible logic [12] and preferred subtheories [16].", "startOffset": 45, "endOffset": 49}, {"referenceID": 10, "context": "This has already been done for default logic [11], logic programming [11], defeasible logic [12] and preferred subtheories [16].", "startOffset": 69, "endOffset": 73}, {"referenceID": 11, "context": "This has already been done for default logic [11], logic programming [11], defeasible logic [12] and preferred subtheories [16].", "startOffset": 92, "endOffset": 96}, {"referenceID": 15, "context": "This has already been done for default logic [11], logic programming [11], defeasible logic [12] and preferred subtheories [16].", "startOffset": 123, "endOffset": 127}, {"referenceID": 14, "context": "This allows the application of argument game proof theories [15] to the process of inference in these NMLs, and the generalisation of these dialectical proof theories to distributed reasoning amongst computational agents, where agents can engage in argumentation-based dialogues [1, 14, 17].", "startOffset": 60, "endOffset": 64}, {"referenceID": 0, "context": "This allows the application of argument game proof theories [15] to the process of inference in these NMLs, and the generalisation of these dialectical proof theories to distributed reasoning amongst computational agents, where agents can engage in argumentation-based dialogues [1, 14, 17].", "startOffset": 279, "endOffset": 290}, {"referenceID": 13, "context": "This allows the application of argument game proof theories [15] to the process of inference in these NMLs, and the generalisation of these dialectical proof theories to distributed reasoning amongst computational agents, where agents can engage in argumentation-based dialogues [1, 14, 17].", "startOffset": 279, "endOffset": 290}, {"referenceID": 16, "context": "This allows the application of argument game proof theories [15] to the process of inference in these NMLs, and the generalisation of these dialectical proof theories to distributed reasoning amongst computational agents, where agents can engage in argumentation-based dialogues [1, 14, 17].", "startOffset": 279, "endOffset": 290}, {"referenceID": 2, "context": "Abstract argumentation has been upgraded to structured argumentation theory [3], one example of which is the ASPIC framework for structured argumentation [16].", "startOffset": 76, "endOffset": 79}, {"referenceID": 15, "context": "Abstract argumentation has been upgraded to structured argumentation theory [3], one example of which is the ASPIC framework for structured argumentation [16].", "startOffset": 154, "endOffset": 158}, {"referenceID": 9, "context": "The advantages of ASPIC are that the framework provides a systematic and general method of endowing non-monotonic logics with argumentation semantics, and identifies sufficient conditions on the underlying logic and preference relations that guarantee the satisfaction of various normatively rational desiderata [10].", "startOffset": 312, "endOffset": 316}, {"referenceID": 6, "context": "This paper endows Brewka\u2019s prioritised default logic (PDL) [7] with argumentation semantics.", "startOffset": 59, "endOffset": 62}, {"referenceID": 18, "context": "PDL is an important NML because it upgrades default logic (DL) [19] with an explicit priority relation over defaults, so that, for example, one can account for recent information taking priority over information in the distant past.", "startOffset": 63, "endOffset": 67}, {"referenceID": 8, "context": "PDL has also been used to represent the (possibly conflicting) beliefs, obligations, intentions and desires (BOID) of agents, and model how these different categories of mental attitudes override each other in order to generate goals and actions that attain those goals [9].", "startOffset": 270, "endOffset": 273}, {"referenceID": 9, "context": "We then investigate some properties and directly prove that the normative rationality postulates of [10] are satisfied (Section 3.", "startOffset": 100, "endOffset": 104}, {"referenceID": 9, "context": "2) and prove a partial result concerning the satisfaction of the rationality postulates of [10] (Section 4.", "startOffset": 91, "endOffset": 95}, {"referenceID": 10, "context": "2 The ASPIC Framework Abstract argumentation abstracts from the internal logical structure of arguments, the nature of defeats and how they are determined by preferences, and consideration of the conclusions of the arguments [11].", "startOffset": 225, "endOffset": 229}, {"referenceID": 9, "context": "However, these features are referenced when studying whether any given logical instantiation of a framework yields complete extensions that satisfy the rationality postulates of [10].", "startOffset": 178, "endOffset": 182}, {"referenceID": 15, "context": "ASPIC [16] provides a structured account of abstract argumentation, allowing one to reference the above features, while at the same time accommodating a wide range of instantiating logics and preference relations in a principled manner.", "startOffset": 6, "endOffset": 10}, {"referenceID": 9, "context": "ASPIC then identifies conditions under which complete extensions defined by the arguments, attacks and preferences, satisfy the rationality postulates of [10].", "startOffset": 154, "endOffset": 158}, {"referenceID": 10, "context": "We now recap the key definitions of [11].", "startOffset": 36, "endOffset": 40}, {"referenceID": 9, "context": "Instantiations of ASPIC should satisfy some properties to ensure they are rational [10].", "startOffset": 83, "endOffset": 87}, {"referenceID": 15, "context": "Given an instantiation let \u3008A, \u21c0, -\u3009 be its ASPIC attack graph Note that [16] studies two different notions of cf sets: one where no two arguments attack each other, and the other where no two arguments defeat each other.", "startOffset": 73, "endOffset": 77}, {"referenceID": 17, "context": "in [18].", "startOffset": 3, "endOffset": 7}, {"referenceID": 1, "context": "Note there are many other ways to lift a preference < on a set of objects X to compare subsets of X in various ways that are \u201ccompatible\u201d with < [2].", "startOffset": 145, "endOffset": 148}, {"referenceID": 6, "context": "3 Brewka\u2019s Prioritised Default Logic In this section we recap Brewka\u2019s prioritised default logic (PDL) [7].", "startOffset": 103, "endOffset": 106}, {"referenceID": 6, "context": "first order formulae without free variables 8 We have defined the order dually to [7] so as to comply with orderings over the ASPIC defeasible inference rules.", "startOffset": 82, "endOffset": 85}, {"referenceID": 9, "context": "We now prove that this instantiation of ASPIC to PDL satisfies the requirements for normative rationality [10].", "startOffset": 106, "endOffset": 110}, {"referenceID": 9, "context": "20, which is that the rationality postulates [10] hold for the stable extensions of the defeat graph, instead for all complete extensions.", "startOffset": 45, "endOffset": 49}, {"referenceID": 6, "context": "5 Conclusions We have endowed Brewka\u2019s PDL [7] with argumentation semantics using ASPIC [16].", "startOffset": 43, "endOffset": 46}, {"referenceID": 15, "context": "5 Conclusions We have endowed Brewka\u2019s PDL [7] with argumentation semantics using ASPIC [16].", "startOffset": 88, "endOffset": 92}, {"referenceID": 8, "context": "This would allow BOID agents with PDL representations of mental attitudes to exchange arguments and counterarguments when deliberating about which goals to select, and thus which actions to pursue [9].", "startOffset": 197, "endOffset": 200}, {"referenceID": 10, "context": "[11, 12]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 11, "context": "[11, 12]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 4, "context": "However, there has been relatively little work in using defeasible rules to represent defaults, because the defeasible components of arguments are often captured in the premises [5, 16].", "startOffset": 178, "endOffset": 185}, {"referenceID": 15, "context": "However, there has been relatively little work in using defeasible rules to represent defaults, because the defeasible components of arguments are often captured in the premises [5, 16].", "startOffset": 178, "endOffset": 185}, {"referenceID": 18, "context": "Reiter\u2019s default logic (DL) [19], as a partial special case of Brewka\u2019s PDL [7, Proposition 6], has been endowed with sound and complete argumentation semantics by Dung [11, Section 4.", "startOffset": 28, "endOffset": 32}, {"referenceID": 6, "context": "We know that conflicts between defaults often occur and priorities are an intuitive and high-level way of resolving such conflicts [7, 8].", "startOffset": 131, "endOffset": 137}, {"referenceID": 7, "context": "We know that conflicts between defaults often occur and priorities are an intuitive and high-level way of resolving such conflicts [7, 8].", "startOffset": 131, "endOffset": 137}, {"referenceID": 5, "context": "2 Future Work Brewka\u2019s preferred subtheories (PS) [6] has been endowed with argumentation semantics by Modgil and Prakken using ASPIC [16, Section 5.", "startOffset": 50, "endOffset": 53}, {"referenceID": 5, "context": "Given that PS is a special case of PDL [6], it is interesting to see how the argumentation semantics are related.", "startOffset": 39, "endOffset": 42}, {"referenceID": 20, "context": "2), but how can soundness and completeness be proven? How can the argumentation semantics help us understand the interaction of explicit default priority relations with the implicit priority of non-normal defaults [21]? Future work will explore further properties of this argumentation semantics.", "startOffset": 214, "endOffset": 218}, {"referenceID": 14, "context": "Such distributed reasoning in the form of dialogue can be formalised as a generalisation of argument game proof theories for Dung frameworks [15], whereby agents not only can submit arguments, but locutions that implicitly define arguments providing the reasons for a given claim.", "startOffset": 141, "endOffset": 145}], "year": 2016, "abstractText": "We express Brewka\u2019s prioritised default logic (PDL) as argumentation using ASPIC. By representing PDL as argumentation and designing an argument preference relation that takes the argument structure into account, we prove that the conclusions of the justified arguments correspond to the PDL extensions. We will first assume that the default priority is total, and then generalise to the case where it is a partial order. This provides a characterisation of non-monotonic inference in PDL as an exchange of argument and counter-argument, providing a basis for distributed non-monotonic reasoning in the form of dialogue.", "creator": "LaTeX with hyperref package"}}}