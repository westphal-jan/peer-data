{"id": "1611.00230", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Nov-2016", "title": "Towards Blended Reactive Planning and Acting using Behavior Trees", "abstract": "madryn In street-corner this paper, coyly we study scherzo the problem jidaigeki of using a planning algorithm 1.5420 to automatically create radel and laced update geordi a witheringly Behavior \u0111\u1ea1o Tree (bassmaster BT ), dhulikhel controlling a robot in a dynamic metes environment. Exploiting rwcl the squishing characteristic of BTs, modbury in 266th terms manmad of harshaw modularity 630,000 and reactivity, the amilcare robot continually psaki acts and minturn plans to 365.25 achieve fitfully a stinging given close-mid goal using a disbursing set of sassanid abstract actions and conditions. The construction westering of holdsclaw the wkrc BT groomsmen is based hogefeld on sasson an extension of phippen the friary Hybrid Backward - storm-petrel Forward algorithm (quadrilles HBF) gushers that allows barajneh us to refine 50-a the acting process by howerdel mapping the erick descriptive atassi models lere onto operational models arnab of actions, vitaphone thus congratulation integrating greenlighting the chodron ability of preciosa planning seibel in infinite viz. state undetermined space ctrc of cantona HBF with bings the daltry continuous modular askmen.com reactive augeri action ilinden execution 9-mile of demario BTs. ifra We believe that senj this might be amtek a ppc first ziprealty step leinsdorf to address the recently caporegime raised luthor open schwanitz challenge in automated ascaris planning: the need courting of zeltzer a chandrashekhar hierarchical cr\u00e8ches structure and a continuous datalink online 683,000 planning cibin and acting stuber framework. priske We goreme prove the convergence of herzlinger the proposed approach chowchilla as well wunderhorn as the absence of 116.33 deadlocks deactivated and livelocks, levinthal and we samakuva illustrate our garendon approach in awg two different robotics menjivar scenarios.", "histories": [["v1", "Tue, 1 Nov 2016 13:56:55 GMT  (4817kb,D)", "http://arxiv.org/abs/1611.00230v1", null]], "reviews": [], "SUBJECTS": "cs.RO cs.AI", "authors": ["michele colledanchise", "diogo almeida", "petter \\\"ogren"], "accepted": false, "id": "1611.00230"}, "pdf": {"name": "1611.00230.pdf", "metadata": {"source": "CRF", "title": "Towards Blended Reactive Planning and Acting using Behavior Trees", "authors": ["Michele Colledanchise", "Diogo Almeida", "Petter \u00d6gren"], "emails": ["miccol@kth.se", "diogoa@kth.se", "petter@kth.se"], "sections": [{"heading": null, "text": "The construction of the BT is based on an extension of the Hybrid Backward-Forward algorithm (HBF) that allows us to refine the acting process by mapping the descriptive models onto operational models of actions, thus integrating the ability of planning in infinite state space of HBF with the continuous modular reactive action execution of BTs.\nWe believe that this might be a first step to address the recently raised open challenge in automated planning: the need of a hierarchical structure and a continuous online planning and acting framework.\nWe prove the convergence of the proposed approach as well as the absence of deadlocks and livelocks, and we illustrate our approach with examples from two different robotics domains.\nI. INTRODUCTION\nTo illustrate the need for blending reactive planning and acting, we consider the following simple example, depicted in Figure 1. A robot needs to plan and execute the actions needed to pick up an object, and place it in a given location. The environment is however dynamic and unpredictable. After pickup, the object might slip out of the robot gripper, or, as shown in Figure 1, external objects might move and block the path to the goal location.\nIn this paper, we propose an approach that produces reactive execution plans in the form of Behavior Trees (BTs). The BT includes reactivity, in the sense that if the object slips out of the robot gripper, it will automatically stop and pick it up again without the need to replan or change the BT. The BT also supports iterative plan refinement, in the sense that if an object moves to block the path, the original BT is extended to include a removal of the blocking obstacle. Then, if the obstacle is removed by an external actor, the BT reactively skips the obstacle removal, and goes on to pick up the main object without having to change the BT.\nWithin the AI community, there has been an increased interest in the combination of planning and acting, [1]\u2013[3]. In particular, [1] describes two key open challenges:\n\u2022 \u201cHierarchically organized deliberation. This principle goes beyond existing hierarchical planning techniques; its requirements and scope are significantly different. The actor performs its deliberation online\u201d\nThe authors are with the Robotics, Perception and Learning Lab, School of Computer Science and Communication, The Royal Institute of Technology - KTH, Stockholm, Sweden. e-mail: {miccol|diogoa|petter}@kth.se\n\u2022 \u201cContinual planning and deliberation. The actor monitors, refines, extends, updates, changes and repairs its plans throughout the acting process, using both descriptive and operational models of actions.\u201d\nSimilarly, the recent book [2] describes the need for an agent that \u201creacts to events and extends, updates, and repairs its plan on the basis of its perception\u201d. Finally, [2] also notes that most of the current work in action planning yields a static plan, i.e., a sequence of actions that brings the system from the initial state to the goal state. Its execution is usually represented as a classical Finite State Machine (FSM). However, due to changes in the environment, the effect of an action can be unexpected. This may lead to situations where the agent replans from scratch on a regular basis, which can be expensive in terms of both time and computational load. We believe that BTs can provide an important step towards addressing these challenges.\nBTs are a graphical mathematical model for reactive fault tolerant task executions. They were first introduced in the computer gaming industry [4] to control in game opponents, and is now an established tool appearing in textbooks [5], [6] and generic game-coding software such as Pygame1, Craft AI 2, and the Unreal Engine3. BTs are appreciated for being highly modular, flexible and reusable, and have also been shown to generalize other successful control architectures such as the Subsumption architecture, Decision Trees [7] and the Teleo-reactive Paradigm [8]. So far, BTs are either created by human experts [9]\u2013[14] or automatically designed\n1http://www.pygame.org/project-owyl-1004-.html 2http://www.craft.ai/ 3https://docs.unrealengine.com/latest/INT/Engine/\nAI/BehaviorTrees/\nar X\niv :1\n61 1.\n00 23\n0v 1\n[ cs\n.R O\n] 1\nN ov\n2 01\n6\nusing machine learning techniques [15]\u2013[17] defining an objective function to maximize using heuristic methods.\nIn this paper we propose a formal automated mechanism to synthesize a BT. The construction of the tree is inspired by the Hybrid Backward-Forward algorithm (HBF), which was recently proposed as an action planner for dealing with infinite state spaces [18]. The HBF algorithm has been shown to efficiently solve problems with large state spaces. Using an HBF algorithm we can refine the acting process by mapping the descriptive model of actions, which describes what the actions do, onto an operational model, which defines how to perform an action in certain circumstances.\nThe proposed framework combines the planning capability in an infinite state space from HBF with the advantages of BTs compared to FSMs in terms of reactivity and modularity. Looking back at the example above, the reactivity of BTs enable the robot to pick up a dropped object without having to replan at all. The modularity enables extending the plan by adding actions for handling the blocking sphere, without having to replan the whole task. Finally, when the sphere moves away, once again the reactivity enables the correct execution without changing the plan. Thus, the proposed approach is indeed hierarchical and modular in its deliberation, and it does monitor, update and extend its plans while acting, addressing the needs described in [1], [2].\nThe main contribution of this paper is that we show how to use a planning algorithm (HBF) to iteratively create and refine BTs that represent reactive executions of the corresponding plans, based on abstract definitions of actions and conditions. To the best of our knowledge, this has not been done before.\nThe rest of this paper is organized as follows. In Section II we present related work, then in Section III we describe BTs and HBF. The problem formulation can be found in Section IV and the proposed approach in Section V. A theoretical analysis of the algorithm is given in Section VI. Some simulations are performed in Section VII to illustrate the approach, before concluding in Section VIII."}, {"heading": "II. RELATED WORK", "text": "In this section we briefly summarize related work and compare it with the proposed approach. We focus on Automated Planning (AP) research as no work in the literature addressed our objective of automatically generating a BT from a set of abstract actions and conditions.\nThe AP community has developed solid solutions for solving path-finding in large state spaces. Such solution have found successful applications in a wide variety of problems. Nonetheless, numerous AP problems remain open challenges [1], [19]\u2013[21]. For example, it was noted by Kaelbling et al. [22], that there is no systematic AP framework that can address an abstract goal such as \u201dwash dishes\u201d and reason on a long sequence of actions in dynamic or finite horizon environments.\nIn the robotic community most of the planners focus, without loss of generality, on manipulation planning where the objective is to have a robot operating in the environment\nwith the possibility to modify, in a limited degree, the environment\u2019s configuration.\nEarly approaches treated the configuration space as continuous for both object and robot but used discrete actions [21], [23], [24], while our approach consider a descriptive model of actions and conditions (i.e. abstract templates).\nLater work [25] proposed so-called multi-modal planning, as a generalization of manipulation planning, that is characterized by planning using different operational modes representing different constraint subspaces of the state space. These plans were characterized by switching between operating a single mode and choosing the mode. Multi-modal planning was then extended to address more complex problems combining a bidirectional search with an hierarchical strategy to determine the operational model of their actions [26]. However, in contrast with our approach, these works assume a static environment and disregard the importance of continually deliberating while acting.\nRecent approaches to robotic planning combine discrete task planning and continuous motion planning frameworks [27]\u2013[29] pre-sampling grasps and placements producing a family of possible high level plans. Despite their hierarchical architectures, those approaches do not consider the continual update of the current plan.\nHierarchical Planning in the Now (HPN) [3] works effectively in domains where planning in detail far into the future is intractable. It iteratively plans and executes actions to get closer to the goal, while avoiding to construct the whole plan in detail at once. While inspired by HPN, our approach differs from it mainly in the execution framework. The use of BTs allows the system to continually monitor the current plan and reactively preempt sub-plans when they are no longer needed due to an environmental change. Moreover if a subgoal that was previously achieved is no longer achieved, our approach does not extend the current plan. Instead, it automatically invokes the sub-routine previously computed for that particular sub-goal.\nOther approaches [30] consider two types of replanning: aggressive replanning, where replanning is done after every action; and selective replanning: where replanning is done whenever a new change in the environment is discovered or when a new path to the goal is found that is shorter than the existing plan by a given threshold. In our approach we replan only when needed. By using continual hierarchical monitoring, we are able to monitor the part of the environment that is relevant for goal satisfaction, disregarding environmental changes that do not affect our plan. This enables us to plan and act efficiently in highly dynamic environments.\nWithin the AI community, with a long history of focusing on state-space search methods, many have addressed the problem using heuristics that approximate the distance between the current and the goal configuration [31]. One approximation is characterized by the delete relaxation that assumes each sub-goal, once achieved, remains achieved for the duration of the plan [32]. This is too strict for planning in dynamic environments.\nThe work that is closest to this paper is [18] where a\nHybrid Backward Forward (HBF) algorithm was proposed as an action planner in infinite state space. HBF is a forward search in state space, starting at the initial state of the complete domain, repeatedly selecting a state that has been visited and an action that is applicable in that state, and computing the resulting state, until a state satisfying a set of goal constraints is reached. HBF was successfully used to efficiently solve the HPN. The advantage of this work lies in the restriction to the set of useful actions, building a so-called reachability graph. A backward search algorithm builds the reachability graph working backward from the goal\u2019s constraints, using them to drive sampling of actions that could result in states that satisfy them. However, even though HBF enables us to deal with infinite state space, the original formulation still derives a plan that is static. Hence it does not address the need of continually acting and planning in dynamic environments."}, {"heading": "III. BACKGROUND: BT AND HBF", "text": "In this section we briefly describe BTs and HBF. A more detailed description of BTs can be found in [7], and one of HBF can be found in [18]."}, {"heading": "A. Behavior Trees", "text": "BTs are a graphical modeling language and a representation for execution of actions based on conditions and observations in a system.\nA BT is a directed rooted tree where each node is either a control flow node or an execution node. For each connected node we define as parent the outgoing node and child the incoming node. The root is the single node without parents, whereas all other nodes have one parent. The control flow nodes have one or more children, and the execution nodes have no children. Graphically, the children of nodes are placed below it. The children nodes are executed in the order from left to right, as shown in Figures 2-3.\nThe execution of a BT begins from the root node. It sends ticks 4 with a given frequency to its child. When a parent sends a tick to a child, the execution of this is allowed. The child returns to the parent a status running if its execution has not finished yet, success if it has achieved its goal, or failure otherwise. There are four types of control flow nodes (fallback, sequence, parallel, and decorator) and two execution nodes (action and condition). Below we describe the execution of the nodes used in this paper.\nFallback: The fallback5 node ticks its children from the left, returning success (running) as soon as it finds a child that returns success (running). It returns failure only if all the children return failure. When a child returns running or success, the fallback node does not tick the next child (if any). The fallback node is graphically represented by a box with a \u201c?\u201d, as in Figure 2.\n4A tick is a signal that allows the execution of a child 5Fallbacks are sometimes also called Selectors\nSequence: The sequence node ticks its children from the left, returning failure (running) as soon as it finds a child that returns failure (running). It returns success only if all the children return success. When a child return running or failure, the sequence node does not tick the next child (if any). The sequence node is graphically represented by a box with a \u201c\u2192\u201d, as in Figure 3.\n1\nAction: The action node performs an action, returning success if the action is completed and failure if the action cannot be completed. Otherwise it returns running. An action node is shown in Figure 4(a)\nCondition: The condition node checks if a condition is satisfied or not, returning success or failure accordingly. The condition node never returns running. A condition node is shown in Figure 4(b)\nTo get familiar with BT notation, and prepare for the coming sections, we look at a BT plan addressing the simple example in Section I. The BT was created using the proposed approach as will be explained in Section V, but for now we just focus on how it is executed.\nExample 1: The robot in Figure 1 is given the task to move the green cube into the rectangle marked GOAL. Ignoring the presence of the red sphere, a reactive plan BT can be found in Figure 5(e). Each time step, the root of the BT is ticked. The root is a fallback which ticks is first child, the condition oc \u2208 GoalRect (cube on goal). If the cube is indeed in the rectangle we are done, and the BT returns Success.\nIf not, the second child, a sequence, is ticked. The sequence ticks its first child, which is a fallback, which again ticks its first child, the condition h = c (object in hand is cube). If the cube is indeed in the hand, the condition returns success, its parent, the fallback returns success, and its parent, the sequence ticks its second child, which is a different fallback, ticking its first child which is the condition or \u2208 Npg (robot in the neighborhood of pg). If the robot is in the neighborhood of the goal, the condition and its fallback parent returns success, followed by the sequence ticking its\nthird child, the action Place(c, pg) (place cube in a position pg on the goal), and we are done.\nIf or \u2208 Npg does not hold, the action MoveTo(pg, \u03c4g) (move to position pg using the trajectory \u03c4g) is executed, given that the trajectory is free \u03c4 \u2282 CollFree. Similarly, if the cube is not in the hand, the robot does a MoveTo followed by a Pick(c) after checking that the hand is empty, the robot is not in the neighborhood of c and that the corresponding trajectory is free.\nWe conclude the example by noting that the BT is ticked every timestep, e.g. every 0.1 second. Thus, when actions return running (i.e. they are not finished yet) the return status of running is progressed up the BT and the corresponding action is allowed to control the robot. However, if e.g., the cube slips out of the gripper, the condition h = c instantly returns failure, and the robot starts checking if it is in the neighborhood of the cube or if it has to move before picking it up again."}, {"heading": "B. The Hybrid Backward Forward algorithm", "text": "HBF was recently proposed in [18] as an AP for infinite state space problems. Given an initial state s0 \u2208 S, a set of action templates, and a set of goal constraints \u0393 \u2282 S (we use \u0393 to denote both the set of constraints, and the set of states that satisfy the constraints), the plan is a sequence a1, a2, . . . , am of actions such that am.eff(am\u22121.eff(. . . a1.eff(s0))) \u2208 \u0393 where ai.eff(sj) is the effect of action ai performed in state sj . This plan is static. It assumes that ai.eff(si) \u2208 ai+1.con, where ai+1.con is the set of conditions that needs to be satisfied to successfully perform the action ai+1. It uses backward search in a subspace of the problem space to efficiently create a Reachability Graph (RG). The creation of the RG starts from the goal constraint and finds a combination of valid samples for the actions templates. These valid samples are then used to identify executable actions that are not in conflict with each other (e.g. If the robot has to drop an object A to be able to pick an object B, it will not drop the object A on top of B). For a detailed description of HBF we refer to [18]."}, {"heading": "IV. PROBLEM FORMULATION", "text": "In this section we first make a set of assumptions, then state the main problem. Assumption 1: The agent can verify if an action has succeeded, failed or if it is running. Assumption 2: The agent can verify if a condition is true or false. Assumption 3: For each initial state there exists a sequence of actions that lead the system to the given goal. Assumption 4: The effect of the dynamic environment can void the satisfaction of sub-goals at most a finite number of times.\nAssumption 5: Given two actions ai and aj , if the execution of ai requires the execution of aj , aj must not require the execution of ai.\nAssumption 6: All actions are ultimately reversible. That is, each action can be undone trough a finite sequence of actions.\nAlgorithm 1: main loop 1 T \u2190 \u2205 2 for c in Cgoal do 3 T \u2190Sequence(T , c) 4 while True do 5 T \u2190RefineActions(T ) 6 do 7 r \u2190 Execute(T) 8 while r 6= FAILURE 9 cf \u2190 GetConditionToExpand(T )\n10 T , Tnew subtree \u2190 ExpandTree(T ,cf) 11 while Conflict(T ) do 12 T \u2190 IncreasePriority(Tnew subtree)\nDefinition 1: S , Rn is the system state space. It captures all relevant aspects of the overall system.\nDefinition 2: s \u2208 S is the system state. It is an element of the system state space. Each component si is a system state variable.\nDefinition 3: ci : S \u2192 {0, 1} is a simple constraint and C = {ci} is the set of all constraints.\nDefinition 4: A state s \u2208 S is said to support a constraint c \u2208 C (written s ` c) if and only if c(s) = 1.\nDefinition 5: \u03b1 is an action template. It contains the descriptive model of an action. An action template is characterized by conditions \u03b1con \u2282 C and effects \u03b1eff \u2282 C. Conditions and effect are both constraints.\nDefinition 6: a : S \u2192 S is an action primitive. It contains the operational model of an action and is executable. Assigning a value to each variable in an action template yields an action primitive.\nAssumption 7: For each action template there exists at least one corresponding action primitive.\nProblem 1: Given a set of goal constraints Cgoal \u2282 C and a set of action templates, derive a BT that leads the agent to a state sfinal such that sfinal ` c, \u2200c \u2208 Cgoal independently of the starting state."}, {"heading": "V. PROPOSED APPROACH", "text": "Formally, the proposed approach is described in Algorithms 1 and 2. First we will give an overview of the algorithms and see how they are applied to the problem described in Example 1, to iteratively create the BTs of Figure 5. We will then discuss the key steps in more detail."}, {"heading": "A. Algorithm Overview", "text": "Running Algorithm 1 we have the set of goal constraint Cgoal = {oc \u2208 {GoalRect}}, thus the initial BT is composed of a single condition T = (oc \u2208 {GoalRect}), as shown in Figure 5(a). The first iteration of the loop starting on Line 4 of Algorithm 1 now produces the next BT shown in Figure 5(b), and the second iteration produces the BT in Figure 5(c) and so on until the final BT in Figure 5(e).\nAlgorithm 2: Behavior Tree Expansion 1 Function ExpandTree(T , cf) 2 AT \u2190 GetAllActTemplatesFor(cf) 3 Tfall \u2190 cf 4 for a in AT do 5 Tseq \u2190 \u2205 6 for ca in a.con do 7 Tseq \u2190 Sequence(Tseq ,ca) 8 Tseq \u2190 Sequence(Tseq ,a) 9 Tfall \u2190 Fallback(Tfall,Tseq)\n10 T \u2190 Substitute(T ,cf ,Tfall) 11 return T , Tfall\nAlgorithm 3: Get Condition to Expand 1 Function GetConditionToExpand(T ) 2 for cnext in GetConditionsBFS() do 3 if cnext.status = FAILURE and cnext /\u2208 ExpandedNodes then 4 ExpandedNodes.push back(cnext)\nreturn cnext\n5 return None\nIn detail, running T on Line 7 returns a failure, since the cube is not in the goal area. Trivially, the GetConditionToExpand returns cf = (oc \u2208 {GoalRect}), and a call to ExpandTree (Algorithm 2) is made on Line 10. On Line 2 of Algorithm 2 we get all action templates that satisfy cf i.e. AT = Place. Then on Line 7 and 8 a sequence Tseq is created of the conditions of Place (the hand holding the cube h = c and the robot being near the goal area or \u2208 Npg ) and Place itself. On Line 9 a fallback Tseq is created of cf and the sequence above. Finally, a BT is returned where this new sub-BT is replacing cf . The resulting BT is shown in Figure 5(b).\nNote that Algorithm 2 describes the core principle of the proposed approach. A condition is replaced by a check if the condition is met, and an action to meet it that is only executed if needed. If there are several such actions, these are added as fallbacks. Finally, the action is preceded by conditions checking its own preconditions. If needed, these conditions will be expanded in the same way in the next iteration.\nRunning the next iteration of Algorithm 1, a similar expansion of the condition h = c transforms the BT in Figure 5(b) to the BT in Fig. 5(c). Then, an expansion of the condition or \u2208 Noc transforms the BT in Figure 5(c) to the BT in Figure 5(d). Finally, an expansion of the condition or \u2208 Npg transforms the BT in Figure 5(d) to the BT in Figure 5(e), and this BT is able to solve Example 1. Figure 6 shows the resulting RG used for action refinements (Algorithm 1 Line 5), see [18] for details."}, {"heading": "B. The Algorithm Steps in Detail", "text": "1) Refine Actions (Algorithm 1 Line 5): To plan in infinite state space we rely on the Reachability Graph (RG) provided by the HBF algorithm [18]. The RG provides efficient sampling for the actions in the BT, allowing us to map the descriptive model of an action into its operational model. The samples provided by the RG are not in conflict with each other, and the process implements the action refinement described in [20].\n2) Get Condition To Expand and Expand Tree (Algorithm 1 Lines 9 and 10) : If the BT returns failure, Line 9 invokes Algorithm 3, that finds the condition to expand by searching through the conditions returning failure in a Breadth First Search (BFS) fashion. If no such condition is found (Algorithm 3 Line 5) that means that an action returned failure due to an old refinement that is no longer valid. In that case, at the next loop of Algorithm 1 a new refinement is found (Algorithm 1 Line 5) and under Assumption 7 such a refinement always exists. If Algorithm 3 returns a condition, this will be expanded (Algorithm 1 Line 10), as shown in the example of Figure 5. Example 3 below highlights the BFS expansion. Thus, T is expanded until\nit can perform an action (i.e. until T contains an action template whose condition are supported by the initial state). In Section VI we will prove that T is expanded a finite number of times. If there exists more than one valid action that satisfies a condition, their respective trees (sequence composition of the action and its conditions) are collected in a fallback composition, which implements the different options the agent has to satisfy such a condition. Note that at this stage we do not investigate which action is the optimal one. As stressed in [2] the cost of minor mistakes (e.g. non optimal actions execution) is often much lower than the cost of the extensive modeling, information gathering and thorough deliberation needed to achieve optimality.\n3) Conflicts and Increases in Priority (Algorithm 1 Lines 11 and 12 ): Similar to any STRIPS-style planner, adding a new action in the plan can cause a conflict (i.e. the execution of this new action creates a mismatch between effects and preconditions in the progress of the plan). In our framework, this situation is checked in Algorithm 1 Line 11 by analyzing the conditions of the new action added with the effects of the actions that the subtree executes before executing the new action. If this effects/conditions pair is in conflict, the goal will not be reached. An example of this situation is described in Example 2 below.\nAgain, following the approach used in STRIPS-style planners, we resolve this conflict by finding the correct action order. Exploiting the structure of BTs we can do so by moving the tree composed by the new action and its condition leftward (a BT executes its children from left to right, thus moving a sub-tree leftward implies executing the new action earlier). If it is the leftmost one, is means that it must be executed before its parent (i.e. it must be placed at the same depth of the parent but to its left). This operation is done in Algorithm 1 Line 12. We incrementally increase the priority of this subtree in this way, until we find a feasible tree. In Section VI we prove that a feasible tree always exists.\nExample 2: Here we show a more complex example highlighting two main properties of our approach: the livelock freedom and the continual deliberative plan and act cycle. This example is an extension of Example 1 where, due to the dynamic environment, the robot needs to replan.\nConsider the execution of the final BT in Figure 5(e) of Example 1, where the robot is carrying the desired object to the goal location. Suddenly, as in Figure 1 (b), an object s obstructs the (only possible) path. Then the condition \u03c4 \u2282 CollFree returns failure and Algorithm 1 expands the tree accordingly (Line 10) as in Figure 7(a).\nThe new subtree has as condition h = \u2205 (no objects in hand) but the effect of the left branch (i.e. the main part in Figure 5(e)) of the BT is h = c (cube in hand) (i.e. the new subtree will be executed if and only if h = c holds). Clearly the expanded tree has a conflict (Algorithm 1 Line 11) and the priority of the new subtree is increased (Line 12), until the expanded tree is in form of Figure 7(b). Now the BT is free from conflicts as the first subtree has as effect h = \u2205 and the second subtree has a condition h = \u2205. Executing the tree the robot approaches the obstructing object, now\nthe condition h = \u2205 returns failure and the tree is expanded accordingly, letting the robot drop the current object grasped, satisfying h = \u2205, then it picks up the obstructing object and places it outside the path. Now the condition \u03c4 \u2282 CollFree finally returns success. The robot can then again approach the desired object and move to the goal region and place the object in it.\n4) Get All Action Templates: Let\u2019s look again at Example 1 and see how the BT in Figure 5(e) was created using the proposed approach.\nIn this example, the action templates are summarized below with conditions and effect:\nMoveTo(p, \u03c4) con : \u03c4 \u2282 CollFree\neff : or = p\nPick(i) con : or \u2208 Noi h = \u2205 eff : h = i\nPlace(i, p) con : or \u2208 Np\nh = i\neff : oi = p\nwhere \u03c4 is a trajectory, CollFree is the set of all collision free trajectories, or is the robot pose, p is a pose in the state space, h is the object currently in the end effector, i is the label of the i-th object in the scene, and Nx is the set of all the poses near the pose x.\nThe descriptive model of the action MoveTo is parametrized over the destination p and the trajectory \u03c4 . It\nrequires that the trajectory is collision free (\u03c4 \u2282 CollFree). As effect the action MoveTo places the robot at p (i.e. or = p); The descriptive model of the action Pick is parametrized over object i. It requires having the end effector free (i.e. h = \u2205) and the robot to be in a neighbourhood Noi of the object i. (i.e. or \u2208 Noi ). As effect the action Pick sets the object in the end effector to i (i.e h = i); Finally, the descriptive model of the action Place is parametrized over object i and final position p. It requires the robot to hold i, (i.e. h = i), and the robot to be in the neighbourhood of the final position p. As effect the action Place places the object i at p (i.e. oi = p)."}, {"heading": "C. Comments on Algorithm", "text": "It is clear that this type of continual plan and act exhibits both the important principles of deliberation stressed in [1], [2]: Hierarchically organized deliberation and Continual online deliberation. For example, if the robot drops the object then the condition h = c is no longer satisfied and the BT will execute the according subtree to pick the object. With no need for re-planning. This type of deliberative reactiveness is built into BTs. On the other hand, if during its navigation a new object pops up obstructing the robot\u2019s path, the condition \u03c4 \u2282 CollFree will no longer return success and the BT will be expanded accordingly. This case was described in Example 2. Moreover, note that we refine every time the tree returns failure. This is to encompass the case where an older refinement is no longer valid. Is such cases an action will return failure. This failure is propagated up to the root. The function ExpandTree (Algorithm 1 Line 10) will return the very same tree (the tree needs no extension as there is no failed condition of an action) which gets re-refined in the next loop (Algorithm 1 Line 5). For example, if the robot planned to place the object onto a precise position of the desk but then this position is no longer feasible (e.g. another object was placed in that position meanwhile)."}, {"heading": "D. Algorithm Execution on Graphs", "text": "Here, for illustrative purposes, we show the result of our approach when applied to a standard shortest path problem in a graph.\nExample 3: Consider an agent moving in different states modeled by the graph in Figure 8 where the initial state is s0 and the goal state is sg . Every arc represents an action that moves an agent from one state to another. The action that moves the agent from a state si to a state sj is denoted by si \u2192 sj . The initial tree, depicted in Figure 9(a), is defined as a condition node sg which returns success if and only if the robot is at the state sg in the graph. The current state is s0 (the initial state). Hence the BT returns a status of failure. Algorithm 1 invokes the BT expansion routine. The state sg can be reached from the state s5, through the action s5 \u2192 sg , or from the state s3, through the action s3 \u2192 sg . The tree is expanded accordingly as depicted in Figure 9(b). Now executing this tree, it returns a status of failure. Since the current state is neither sg nor s3 nor s5. Now the tree is expanded in a BFS fashion,\nfinding a sub-tree for condition s5 as in Figure 9(c). The process continues for two more iterations. Note that at iteration 4 (See Figure 10(b)) Algorithm 1 did not expand the condition sg as it was previously expanded (Algorithm 3 line 3) this avoids infinite loops in the search. The same argument applies for conditions s4 and sg in iteration 5 (See Figure 10(c)). The BT at iteration 5 includes the action s0 \u2192 s1 whose precondition is satisfied (the current state is s0). The action is then executed. Performing that action (and moving to s1), the condition s1 is satisfied. The BT executes the action s1 \u2192 s3 and then s3 \u2192 sg , making the agent reach the goal state.\nIt is clear that the resulting execution is the same as a BFS on the graph would have rendered. Note however that the algorithm is designed for more complex problems than graph search."}, {"heading": "VI. THEORETICAL ANALYSIS", "text": "In this section we discuss the framework from a theoretical standpoint. Since we are blending planning and acting, standard notions of correctness and completeness from planning do not hold. As in [3], our correctness criterion is that if there exist a finite sequence of operations such that the goal state is reachable from the initial state, then Algorithm 1 will execute such a sequence of operations.\nIn a discrete domain and without any hierarchical refinements, a regression planner under Assumption 3 would produce a correct plan. (See Example 3). The authors of [3] prove that the refinements do not affect the ability to achieve the global goal.\nThe correct plan of a regression planner would be executed action by action in a FSM fashion. However, the execution framework of our approach is represented by a BT. Thus we need to examine the effect of using BTs as the task execution framework. If the global goal and the preconditions for each action were described by, at most, a single condition, there would be no choice of which condition to satisfy first, and the execution of the BT would be a reactive version of the one of a FSM of a regression planner (reactive in the sense that it continually monitors the plan and executes the correct sub-tree). When an action, or the global goal, has multiple preconditions, the order in which those are satisfied must be defined. It is often the case that the satisfaction of a precondition can void the satisfaction of another precondition previously satisfied. Since BTs continually monitor the satisfaction of preconditions, and re-execute the subtree if a precondition is no longer satisfied, this could lead to a livelock (i.e. a loop in the actions to satisfy the preconditions). Thus, we need to prove that our approach is livelock free.\nLemma 1: A conflict free BT always exists under Assumptions 3, 5 and 6. Proof: Whenever the expansion of the BT adds a new action template \u03b1, this may cause a conflict. If \u03b1 causes a conflict, its refinement must be executed before another action primitive. Since this other action is not identified yet, the function increase priority (Algorithm 1 Line 12) manipulates the order in which \u03b1 is executed. Under Assumptions 5 and 3 a correct order for that action exists. Under Assumption 6 the actions previously executed that caused the conflict can be undone by a finite sequence of actions.\nLemma 2: The proposed approach is livelock free. Proof: To prove this lemma we must prove that our approach does not execute infinite loops in the system state space from scurr to any s \u2208 S reachable from scurr. Under Assumption 3, there exists a sequence of actions that moves the system state from scurr to sfinal. From Lemma 1 each action in the BT executed does not jeopardize the execution of the others, that is the satisfaction of a sub-goal (e.g. a precondition of an action) does not void the satisfaction of another sub-goal. Under Assumption 4 the environment does not force the agent to execute infinite loops of actions by keeping nullifying sub-goals.\nBefore proving that Algorithm 1 solves Problem 1 we need to prove that for each sub-goal, as well as for the global goal, Algorithm 1 finds the action to perform in finite time.\nLemma 3: For each goal, Algorithm 1 finds the action to perform in finite time. Proof: The search is done backward from the goal to a constraint that is satisfied by the current state. Under Assumption 3 the backward search finds a finite sequence of actions.\nProposition 1: Algorithm 1 solves Problem 1. Proof: If the current state s is such that s ` cgoal, then the goal is satisfied and the BT returns success, executing no action. If s 0 cgoal, then two situation may occur: T (the refined BT) returns running. This means the tree is executing an action to satisfy a sub-goal; T returns failure. This means that either a new action refinement is needed (which always exists under Assumption 7) or a new plan refinement is needed and T (the template BT) must be expanded to satisfy a sub-goal (or the global goal). Lemma 3 proves that this expansion terminates in finite time. Each sub-goal is satisfied finding a sequence of action in a BFS fashion and Lemma 2 shows that the satisfaction of a sub-goal does not void the satisfaction of another sub-goal."}, {"heading": "VII. RESULTS", "text": "In this section we show how the proposed approach scales to complex problems using two different scenarios. First, a KUKA Youbot scenario, where we show the applicability of our approach on dynamic and unpredictable environments, highlighting the importance of continually planing and acting. Second, an ABB Yumi industrial manipulator scenario, where we highlight the applicability of our approach to real world plans that require the execution of a long sequence of actions. The experiments were carried out using the physics simulator V-REP, in-house implementations of low level controllers for actions and conditions and an open source BT library6. Figures 11 and 12 show the execution of two KUKA youbot experiments and Figure 13 show the execution of one ABB Yumi robot experiment. A video showing the executions of all the experiments is publicly available7."}, {"heading": "A. KUKA Youbot experiments", "text": "In these scenarios, which are an extension of Examples 1 and 2, a KUKA Youbot has to place a green cube on a goal area, see Figures 11 and 12. The robot is equipped with a single arm with a simple parallel gripper. Additional objects may obstruct the feasible paths to the goal, and the robot has to plan when to pick and where to place to the obstructing objects. Moreover external actors may co-exist in the scene and force the robot to replan by modifying the environment (e.g. picking and placing objects around).\n6http://wiki.ros.org/behavior_tree 7https://youtu.be/b_Ug2My9_Xw"}, {"heading": "B. ABB Yumi experiments", "text": "In these scenarios, an ABB Yumi has to assemble a cellphone, whose parts are scattered across a table, see Figure 13. The robot is equipped with two arms with simple parallel grippers, which are not suitable dexterous manipulation. Some parts must be grasped in a particular position. For example the opening on the cellphone\u2019s chassis needs to face away from the robot\u2019s arm, exposing it for the assembly. However, the initial position of a part can be such that it requires multiple grasps transferring the part to the other gripper, effectively changing its orientation w.r.t the grasping gripper. See video link above."}, {"heading": "VIII. CONCLUSIONS", "text": "In this paper we proposed a framework to automatically synthesize a BT that satisfies a goal given a set of abstract action and condition nodes, to the best of our knowledge, this has not been done before. The framework combines the advantages of BTs, in terms of modularity and reactivity, with the infinite dimensional planning capability of the HBF algorithm. The resulting approach is an attempt to address the challenges regarding blending planning and acting that have been identified in the planning community. We analyzed the framework from a theoretical standpoint and showed its applicability in dynamic and unpredictable scenarios."}, {"heading": "IX. FUTURE WORK", "text": "We will investigate the integration of this type of blended planning and acting with the learning of action templates. In particular we are interested in learning the preconditions and effects for each action useful for the planning. Recent work [17] shows how BTs are suitable for reinforcement learning. Note however that the challenges we will face are slithgly different that the one addressed in [17]. We are not able to define an objective functions that is maximized when the preconditions are found. Rougly speaking [17], finds a sufficient set of preconditions of an action for a given task. We will be interested in finding necessary and sufficient set of preconditions of an action for any task. We believe that the modularity of BTs will allow us to learn individual pieces for preconditions and effects to characterize the action templates. The learning process could be supervised by a domain expert, taking inspirations from [33], [34] or carryied out by interacting with the environment, taking inspirations from [35]. The learning process can be integrated in a sequential fashion (i.e. the approach learns first the action templates and then blends planning and acting.) or in a interleaved fashion (the learning of preconditions and effects gets blended with planning and acting.). We believe that the particular structure and execution of BTs effectively allows blending learning, acting and planning."}, {"heading": "X. ACKNOWLEDGMENTS", "text": "This work has been supported by the SARAFun project, partially funded by the EU within H2020 (H2020-ICT2014/H2020-ICT-2014-1) under grant agreement no. 644938. The authors gratefully acknowledge the support.\n(a) The robot picks the desired object: a green cube.\n(b) The robot has to place the blue cube away from the path to the goal. But the robot is currently grasping the green cube. Hence the sub-tree created to place the blue cube away needs to have a higher priority.\n(c) The blue cube is placed at the side.\n(d) While the robot is reaching the goal region, the green cube slips out of the gripper. The robot reactively preempts the sub-tree to move to the goal and re-executes the sub-tree to grasp the green cube. Without replanning."}], "references": [{"title": "The actor\u2019s view of automated planning and acting: A position paper", "author": ["M. Ghallab", "D. Nau", "P. Traverso"], "venue": "Artif. Intell., vol. 208, pp. 1\u201317, Mar. 2014. [Online]. Available: http://dx.doi.org/10.1016/j.artint.2013.11.002", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2014}, {"title": "Automated Planning and Acting", "author": ["M. Ghallab", "D. Nau", "P. . Traverso"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2016}, {"title": "Hierarchical task and motion planning in the now", "author": ["L.P. Kaelbling", "T. Lozano-P\u00e9rez"], "venue": "Robotics and Automation (ICRA), 2011 IEEE International Conference on. IEEE, 2011, pp. 1470\u20131477.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Handling Complexity in the Halo 2 AI", "author": ["D. Isla"], "venue": "Game Developers Conference, 2005.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2005}, {"title": "How Behavior Trees Modularize Hybrid Control Systems and Generalize Sequential Behavior Compositions, the Subsumption Architecture and Decision Trees", "author": ["M. Colledanchise", "P. \u00d6gren"], "venue": "to appear in IEEE Transactions on Robotics, 2016. [Online]. Available: http://michelecolledanchise.com/tro16colledanchise.pdf", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2016}, {"title": "How Behavior Trees Generalize the Teleo-Reactive Paradigm and And-Or-Trees", "author": ["M. Colledanchise", "P. \u00d6gren"], "venue": "IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), October 2016.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2016}, {"title": "Increasing Modularity of UAV Control Systems using Computer Game Behavior Trees", "author": ["P. \u00d6gren"], "venue": "AIAA Guidance, Navigation and Control Conference, Minneapolis, MN, 2012.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Interfacing Behavior Trees with the World Using Description Logic", "author": ["A. Kl\u00f6kner"], "venue": "AIAA conference on Guidance, Navigation and Control, Boston, 2013.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "How Behavior Trees Modularize Robustness and Safety in Hybrid Systems", "author": ["M. Colledanchise", "P. \u00d6gren"], "venue": "IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), June 2014.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Semi-autonomous simulated brain tumor ablation with raven ii surgical robot using behavior tree", "author": ["D. Hu", "Y. Gong", "B. Hannaford", "E.J. Seibel"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), 2015.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "A framework for end-user instruction of a robot assistant for manufacturing", "author": ["K.R. Guerin", "C. Lea", "C. Paxton", "G.D. Hager"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), 2015.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2015}, {"title": "Behavior trees with stateful tasks", "author": ["A. Kl\u00f6ckner"], "venue": "Advances in Aerospace Guidance, Navigation and Control. Springer, 2015, pp. 509\u2013519.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2015}, {"title": "Learning and Evolving Combat Game Controllers", "author": ["L. Pena", "S. Ossowski", "J.M. Pena", "S.M. Lucas"], "venue": "Computational Intelligence and Games (CIG), 2012 IEEE Conference on. IEEE, 2012, pp. 195\u2013 202.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution", "author": ["D. Perez", "M. Nicolau", "M. O\u2019Neill", "A. Brabazon"], "venue": "Applications of Evolutionary Computation, 2011.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Learning of behavior trees for autonomous agents", "author": ["M. Colledanchise", "R. Parasuraman", "P. \u00d6gren"], "venue": "arXiv preprint arXiv:1504.05811, 2015.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "A review of machine learning for automated planning", "author": ["S. Jim\u00e9nez", "T. De La Rosa", "S. Fern\u00e1ndez", "F. Fern\u00e1ndez", "D. Borrajo"], "venue": "The Knowledge Engineering Review, vol. 27, no. 04, pp. 433\u2013467, 2012.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}, {"title": "Blended planning and acting: Preliminary approach, research challenges", "author": ["D.S. Nau", "M. Ghallab", "P. Traverso"], "venue": "Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, ser. AAAI\u201915. AAAI Press, 2015, pp. 4047\u20134051. [Online]. Available: http://dl.acm.org/citation.cfm?id=2888116.2888281", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Robot motion planning", "author": ["J.-C. Latombe"], "venue": "Springer Science & Business Media,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "Integrated task and motion planning in belief space", "author": ["L.P. Kaelbling", "T. Lozano-P\u00e9rez"], "venue": "Int. J. Rob. Res., vol. 32, no. 9-10, pp. 1194\u20131227, Aug. 2013. [Online]. Available: http: //dx.doi.org/10.1177/0278364913484072", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "Automatic planning of manipulator transfer movements", "author": ["T. Lozano-Perez"], "venue": "IEEE Transactions on Systems, Man, and Cybernetics, vol. 11, no. 10, pp. 681\u2013698, 1981.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1981}, {"title": "Handey: A robot system that recognizes, plans, and manipulates", "author": ["T. Lozano-Perez", "J. Jones", "E. Mazer", "P. O\u2019Donnell", "W. Grimson", "P. Tournassoud", "A. Lanusse"], "venue": "Robotics and Automation. Proceedings. 1987 IEEE International Conference on, vol. 4. IEEE, 1987, pp. 843\u2013849.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1987}, {"title": "Randomized multi-modal motion planning for a humanoid robot manipulation task", "author": ["K. Hauser", "V. Ng-Thow-Hing"], "venue": "The International Journal of Robotics Research, vol. 30, no. 6, pp. 678\u2013698, 2011.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2011}, {"title": "A hierarchical approach to manipulation with diverse actions", "author": ["J. Barry", "L.P. Kaelbling", "T. Lozano-P\u00e9rez"], "venue": "Robotics and Automation (ICRA), 2013 IEEE International Conference on. IEEE, 2013, pp. 1799\u20131806.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2013}, {"title": "Constraint propagation on interval bounds for dealing with geometric backtracking", "author": ["F. Lagriffoul", "D. Dimitrov", "A. Saffiotti", "L. Karlsson"], "venue": "2012 IEEE/RSJ International Conference on Intelligent Robots and Systems. IEEE, 2012, pp. 957\u2013964.", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2012}, {"title": "Combining high-level causal reasoning with low-level geometric reasoning and motion planning for robotic manipulation", "author": ["E. Erdem", "K. Haspalamutgil", "C. Palaz", "V. Patoglu", "T. Uras"], "venue": "Robotics and Automation (ICRA), 2011 IEEE International Conference on. IEEE, 2011, pp. 4575\u20134581.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2011}, {"title": "Combined task and motion planning through an extensible plannerindependent interface layer", "author": ["S. Srivastava", "E. Fang", "L. Riano", "R. Chitnis", "S. Russell", "P. Abbeel"], "venue": "2014 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2014, pp. 639\u2013646.", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2014}, {"title": "Foresight and reconsideration in hierarchical planning and execution", "author": ["M. Levihn", "L.P. Kaelbling", "T. Lozano-Perez", "M. Stilman"], "venue": "Intelligent Robots and Systems (IROS), 2013 IEEE/RSJ International Conference on. IEEE, 2013, pp. 224\u2013231.", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2013}, {"title": "Planning as heuristic search", "author": ["B. Bonet", "H. Geffner"], "venue": "Artificial Intelligence, vol. 129, no. 1, pp. 5\u201333, 2001.", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2001}, {"title": "The ff planning system: Fast plan generation through heuristic search", "author": ["J. Hoffmann", "B. Nebel"], "venue": "Journal of Artificial Intelligence Research, vol. 14, pp. 253\u2013302, 2001.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2001}, {"title": "Learning preconditions for planning from plan traces and htn structure", "author": ["O. Ilghami", "D.S. Nau", "H. Mu\u00f1oz-Avila", "D.W. Aha"], "venue": "Computational Intelligence, vol. 21, no. 4, pp. 388\u2013413, 2005.", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2005}, {"title": "Learning manipulation actions from a few demonstrations", "author": ["N. Abdo", "H. Kretzschmar", "L. Spinello", "C. Stachniss"], "venue": "Robotics and Automation (ICRA), 2013 IEEE International Conference on. IEEE, 2013, pp. 1268\u20131275.", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2013}, {"title": "Efficient learning of action schemas and web-service descriptions.", "author": ["T.J. Walsh", "M.L. Littman"], "venue": "in AAAI,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": "Within the AI community, there has been an increased interest in the combination of planning and acting, [1]\u2013[3].", "startOffset": 105, "endOffset": 108}, {"referenceID": 2, "context": "Within the AI community, there has been an increased interest in the combination of planning and acting, [1]\u2013[3].", "startOffset": 109, "endOffset": 112}, {"referenceID": 0, "context": "In particular, [1] describes two key open challenges: \u2022 \u201cHierarchically organized deliberation.", "startOffset": 15, "endOffset": 18}, {"referenceID": 1, "context": "\u201d Similarly, the recent book [2] describes the need for an agent that \u201creacts to events and extends, updates, and repairs its plan on the basis of its perception\u201d.", "startOffset": 29, "endOffset": 32}, {"referenceID": 1, "context": "Finally, [2] also notes that most of the current work in action planning yields a static plan, i.", "startOffset": 9, "endOffset": 12}, {"referenceID": 3, "context": "They were first introduced in the computer gaming industry [4] to control in game opponents, and is now an established tool appearing in textbooks [5], [6] and generic game-coding software such as Pygame1, Craft AI 2, and the Unreal Engine3.", "startOffset": 59, "endOffset": 62}, {"referenceID": 4, "context": "BTs are appreciated for being highly modular, flexible and reusable, and have also been shown to generalize other successful control architectures such as the Subsumption architecture, Decision Trees [7] and the Teleo-reactive Paradigm [8].", "startOffset": 200, "endOffset": 203}, {"referenceID": 5, "context": "BTs are appreciated for being highly modular, flexible and reusable, and have also been shown to generalize other successful control architectures such as the Subsumption architecture, Decision Trees [7] and the Teleo-reactive Paradigm [8].", "startOffset": 236, "endOffset": 239}, {"referenceID": 6, "context": "So far, BTs are either created by human experts [9]\u2013[14] or automatically designed", "startOffset": 48, "endOffset": 51}, {"referenceID": 11, "context": "So far, BTs are either created by human experts [9]\u2013[14] or automatically designed", "startOffset": 52, "endOffset": 56}, {"referenceID": 12, "context": "using machine learning techniques [15]\u2013[17] defining an objective function to maximize using heuristic methods.", "startOffset": 34, "endOffset": 38}, {"referenceID": 14, "context": "using machine learning techniques [15]\u2013[17] defining an objective function to maximize using heuristic methods.", "startOffset": 39, "endOffset": 43}, {"referenceID": 0, "context": "Thus, the proposed approach is indeed hierarchical and modular in its deliberation, and it does monitor, update and extend its plans while acting, addressing the needs described in [1], [2].", "startOffset": 181, "endOffset": 184}, {"referenceID": 1, "context": "Thus, the proposed approach is indeed hierarchical and modular in its deliberation, and it does monitor, update and extend its plans while acting, addressing the needs described in [1], [2].", "startOffset": 186, "endOffset": 189}, {"referenceID": 0, "context": "Nonetheless, numerous AP problems remain open challenges [1], [19]\u2013[21].", "startOffset": 57, "endOffset": 60}, {"referenceID": 15, "context": "Nonetheless, numerous AP problems remain open challenges [1], [19]\u2013[21].", "startOffset": 62, "endOffset": 66}, {"referenceID": 17, "context": "Nonetheless, numerous AP problems remain open challenges [1], [19]\u2013[21].", "startOffset": 67, "endOffset": 71}, {"referenceID": 18, "context": "[22], that there is no systematic AP framework that can address an abstract goal such as \u201dwash dishes\u201d and reason on a long sequence of actions in dynamic or finite horizon environments.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "Early approaches treated the configuration space as continuous for both object and robot but used discrete actions [21], [23], [24], while our approach consider a descriptive model of actions and conditions (i.", "startOffset": 115, "endOffset": 119}, {"referenceID": 19, "context": "Early approaches treated the configuration space as continuous for both object and robot but used discrete actions [21], [23], [24], while our approach consider a descriptive model of actions and conditions (i.", "startOffset": 121, "endOffset": 125}, {"referenceID": 20, "context": "Early approaches treated the configuration space as continuous for both object and robot but used discrete actions [21], [23], [24], while our approach consider a descriptive model of actions and conditions (i.", "startOffset": 127, "endOffset": 131}, {"referenceID": 21, "context": "Later work [25] proposed so-called multi-modal planning, as a generalization of manipulation planning, that is characterized by planning using different operational modes representing different constraint subspaces of the state space.", "startOffset": 11, "endOffset": 15}, {"referenceID": 22, "context": "Multi-modal planning was then extended to address more complex problems combining a bidirectional search with an hierarchical strategy to determine the operational model of their actions [26].", "startOffset": 187, "endOffset": 191}, {"referenceID": 23, "context": "Recent approaches to robotic planning combine discrete task planning and continuous motion planning frameworks [27]\u2013[29] pre-sampling grasps and placements producing a family of possible high level plans.", "startOffset": 111, "endOffset": 115}, {"referenceID": 25, "context": "Recent approaches to robotic planning combine discrete task planning and continuous motion planning frameworks [27]\u2013[29] pre-sampling grasps and placements producing a family of possible high level plans.", "startOffset": 116, "endOffset": 120}, {"referenceID": 2, "context": "Hierarchical Planning in the Now (HPN) [3] works effectively in domains where planning in detail far into the future is intractable.", "startOffset": 39, "endOffset": 42}, {"referenceID": 26, "context": "Other approaches [30] consider two types of replanning: aggressive replanning, where replanning is done after every action; and selective replanning: where replanning is done whenever a new change in the environment is discovered or when a new path to the goal is found that is shorter than the existing plan by a given threshold.", "startOffset": 17, "endOffset": 21}, {"referenceID": 27, "context": "Within the AI community, with a long history of focusing on state-space search methods, many have addressed the problem using heuristics that approximate the distance between the current and the goal configuration [31].", "startOffset": 214, "endOffset": 218}, {"referenceID": 28, "context": "One approximation is characterized by the delete relaxation that assumes each sub-goal, once achieved, remains achieved for the duration of the plan [32].", "startOffset": 149, "endOffset": 153}, {"referenceID": 4, "context": "A more detailed description of BTs can be found in [7], and one of HBF can be found in [18].", "startOffset": 51, "endOffset": 54}, {"referenceID": 16, "context": "The samples provided by the RG are not in conflict with each other, and the process implements the action refinement described in [20].", "startOffset": 130, "endOffset": 134}, {"referenceID": 1, "context": "As stressed in [2] the cost of minor mistakes (e.", "startOffset": 15, "endOffset": 18}, {"referenceID": 0, "context": "Comments on Algorithm It is clear that this type of continual plan and act exhibits both the important principles of deliberation stressed in [1], [2]: Hierarchically organized deliberation and Continual online deliberation.", "startOffset": 142, "endOffset": 145}, {"referenceID": 1, "context": "Comments on Algorithm It is clear that this type of continual plan and act exhibits both the important principles of deliberation stressed in [1], [2]: Hierarchically organized deliberation and Continual online deliberation.", "startOffset": 147, "endOffset": 150}, {"referenceID": 2, "context": "As in [3], our correctness criterion is that if there exist a finite sequence of operations such that the goal state is reachable from the initial state, then Algorithm 1 will execute such a sequence of operations.", "startOffset": 6, "endOffset": 9}, {"referenceID": 2, "context": "The authors of [3] prove that the refinements do not affect the ability to achieve the global goal.", "startOffset": 15, "endOffset": 18}, {"referenceID": 14, "context": "Recent work [17] shows how BTs are suitable for reinforcement learning.", "startOffset": 12, "endOffset": 16}, {"referenceID": 14, "context": "Note however that the challenges we will face are slithgly different that the one addressed in [17].", "startOffset": 95, "endOffset": 99}, {"referenceID": 14, "context": "Rougly speaking [17], finds a sufficient set of preconditions of an action for a given task.", "startOffset": 16, "endOffset": 20}, {"referenceID": 29, "context": "The learning process could be supervised by a domain expert, taking inspirations from [33], [34] or carryied out by interacting with the environment, taking inspirations from [35].", "startOffset": 86, "endOffset": 90}, {"referenceID": 30, "context": "The learning process could be supervised by a domain expert, taking inspirations from [33], [34] or carryied out by interacting with the environment, taking inspirations from [35].", "startOffset": 92, "endOffset": 96}, {"referenceID": 31, "context": "The learning process could be supervised by a domain expert, taking inspirations from [33], [34] or carryied out by interacting with the environment, taking inspirations from [35].", "startOffset": 175, "endOffset": 179}], "year": 2016, "abstractText": "In this paper, we study the problem of using a planning algorithm to automatically create and update a Behavior Tree (BT), controlling a robot in a dynamic environment. Exploiting the characteristic of BTs, in terms of modularity and reactivity, the robot continually acts and plans to achieve a given goal using a set of abstract actions and conditions. The construction of the BT is based on an extension of the Hybrid Backward-Forward algorithm (HBF) that allows us to refine the acting process by mapping the descriptive models onto operational models of actions, thus integrating the ability of planning in infinite state space of HBF with the continuous modular reactive action execution of BTs. We believe that this might be a first step to address the recently raised open challenge in automated planning: the need of a hierarchical structure and a continuous online planning and acting framework. We prove the convergence of the proposed approach as well as the absence of deadlocks and livelocks, and we illustrate our approach with examples from two different robotics domains.", "creator": "LaTeX with hyperref package"}}}