{"id": "1611.03466", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2016", "title": "Roadmap Enhanced Improvement to the VSIMM Tracker via a Constrained Stochastic Context Free Grammar", "abstract": "tigelaar The aim ranjit of syntactic cabell tracking aibos is to 169.75 classify bernales spatio - temporal 24-inch patterns unrighteous of nvg a chattier target ' s motion essjay using natural beginitalic language processing lausevic models. In sewer this paper, we 64.62 generalize earlier work mcguffin by considering tende a constrained stochastic context free grammar (ephedra CSCFG) for agila modeling 2-oxidoreductase patterns co.uk confined equating to dayro a sigillum roadmap. The constrained grammar facilitates modeling specific rawdon directions and subcostal road names in salzmann a 28.03 roadmap. We enzyme present a hanabusa novel akki particle basecamp filtering awwww algorithm improvising that standly exploits autobiographical the qa CSCFG model 2357 for estimating the formulated target ' 1.3852 s 27-point patterns. pluss This meta - embolic level tandag algorithm gheen operates in hashtrud conjunction surkis with a 112.90 base - biedziak level finance tracking staunched algorithm. harbored Extensive numerical results bajakajian using moross simulated holzhausen ground moving target indicator (makihara GMTI) nonagricultural radar rajshahi measurements show substantial improvement 90.22 in target chal tracking gynecare accuracy.", "histories": [["v1", "Thu, 10 Nov 2016 20:13:36 GMT  (1010kb,D)", "http://arxiv.org/abs/1611.03466v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["sijia gao", "vikram krishnamurthy"], "accepted": false, "id": "1611.03466"}, "pdf": {"name": "1611.03466.pdf", "metadata": {"source": "CRF", "title": "Roadmap Enhanced Improvement to the VSIMM Tracker via a Constrained Stochastic Context Free Grammar", "authors": ["Sijia Gao", "Vikram Krishnamurthy"], "emails": ["vikramk@cornell.edu"], "sections": [{"heading": null, "text": "I. INTRODUCTION Consider a moving target confined to the road network illustrated in Fig. 1. Assume that the target is being tracked by a ground moving target indicator (GMTI) radar system. At each discrete time k, let zk denote the noisy GMTI measurement and xk denote the state vector comprising position and velocity of the target as it moves in two dimensional space. Also, dk and lk denote, respectively, the direction of motion and the location (road or intersection names) of the target.\nClassical (base-level) tracking algorithms have been well studied in the literature [1] [2]. These include the variable structure interacting multiple model (VSIMM) tracker. In a VSIMM tracker, the direction sequence d1:k = (d1, . . . , dk) is modeled as a Markov chain with state space dependent on the location sequence l1:k = (l1, . . . , lk). These direction and location sequences are chosen so that the target is confined to roads and intersections in a roadmap.\nAt a higher level of abstraction (lower degree of spatial resolution and slower time scale), a moving target confined to a roadmap can be characterized by an ordered sequence of intersection names it traverses. For example, v0v2v7 in Fig. 1 indicates a target which starts at intersection v0, traverses through v2 and ends at v7. For convenience, we call an ordered sequence of intersection names as a pattern. In this paper, we consider a \u201csyntactic\u201d enhancement to the basic VSIMM setup. This syntactic enhancement operates at a higher (meta) level and models the pattern of a target. Our aim is to estimate the target\u2019s pattern r\u2217 such that\nr\u2217 = argmax \u2200r\u2208M p\u03b8(r|z1:k)\nS. Gao is with the Department of ECE, University of British Columbia, Vancouver, Canada. Vikram Krishnamurthy is with the Department of Electrical and Computer Engineering, Cornell University, N.Y., USA. vikramk@cornell.edu and is the corresponding author.\nHere, z1:k = (z1, z2, . . . , zk) is the noisy observation sequence recorded by a GMTI radar. r is a pattern, M denotes a set of patterns that a radar operator is interested in and \u03b8 denotes the roadmap statistic obtained from traffic data. Once the pattern r\u2217 is estimated, it can be used as additional information to estimate the state vector xk of the target by computing the posterior p(xk|z1:k, r\u2217).\nThe syntactic tracker we propose in this paper consists of two parts: a meta-level tracker and a base-level tracker. The meta-level tracker uses tracklets generated by the base-level tracker to model higher level patterns. The architecture of a syntactic tracker is illustrated in Fig. 2. Our key idea is to model the pattern of a target moving on a roadmap using a constrained stochastic context free grammar (CSCFG) on a weighted, directed graph. We then propose a novel particle filtering algorithm that combines the functionalities of CSCFG and VSIMM. Detailed numerical simulations show that the resulting tracker yields substantially improved estimates compared to a baseline tracker."}, {"heading": "A. Syntactic Tracker Architectures", "text": "To give insight into the main ideas of this paper, we briefly describe two architectures of the syntactic trackers, namely (i) the mode based syntactic tracker proposed in this paper and\nar X\niv :1\n61 1.\n03 46\n6v 1\n[ cs\n.C L\n] 1\n0 N\nov 2\n01 6\n2\nFigure 2. The architecture of a syntactic tracker. Pattern is an ordered sequence of intersection names discussed in Sec. I.\n(a) (b)\nFigure 3. Directions of motion are constrained by the road conditions. \u03b8(lk) is the set of possible directions of motion if a target is at lk . Black arrows denote the directions of motion. In (a), if lk is a road, \u03b8(lk) equals the angle of the road lk (with respect to a reference coordinate). In (b), if lk is an intersection, \u03b8(lk) is the set of angles of the roads that intersect at lk .\n(ii) the direction based syntactic tracker proposed in earlier works [3] [4] [5].\nThe direction based syntactic tracker in previous works [3] [4] [5] was used to classify shapes (lines, arcs or m-rectangles) of trajectories. In such a tracker, the direction sequence d1:k is modeled via a stochastic context free grammar (SCFG) at the meta-level. The architecture of the direction based syntactic tracker is illustrated in Fig. 4(a). The key new idea in this paper is to combine a Markov chain with a SCFG which results in a constrained SCFG (CSCFG). A CSCFG constitutes a model for the target\u2019s directions and locations. This is modeled by the mode\nqk = {dk, lk} with dk \u2208 \u03b8(lk) (1)\nwhere dk and lk denote the direction and location of the target. In (1), \u03b8(lk) is the set of possible directions of motion if a target is at lk (See Fig. 3). The direction sequence d1:k is modeled by a SCFG with state space dependent on the location sequence l1:k which is a Markov chain. Hence, the mode sequence q1:k = (q1, q2, . . . , qk) is a combination of a SCFG and a Markov chain which is equivalent to a CSCFG; see [6]. The architecture of the mode based syntactic tracker is illustrated in Fig. 4(b). To give further insight, we also present the classical VSIMM tracker [1] [2] which is widely used for baseline target tracking. In VSIMM, the mode sequence q1:k is modeled as a Markov chain dependent on the whole roadmap instead of patterns in a mode based syntactic tracker and there is no feedback from the base-level tracker to the upper\nmodel. The architecture of the VSIMM tracker is illustrated in Fig. 4(c)."}, {"heading": "B. Organization and Main Results", "text": "To put this paper into context, we first recall the Chomsky hierarchy of natural languages [7]. Let \u2282 denote a strict subset and \u2261 denote equivalent. Then \u2022 In the deterministic case:\nRegular Grammar \u2282 Context Free Grammar\n3 \u2022 In the stochastic case [6]:\nMarkov chain \u2282 Hidden Markov chain \u2261 Stochastic Regular Grammar \u2282 SCFG \u2282 CSCFG\n(2)\nFrom a signal processing point of view, this paper deals with Bayesian signal processing algorithms for CSCFGs; the key application being syntactic target tracking. Put simply, at a meta-level, we view the spatial trajectory of a target as a sequence of noisy alphabets generated by a CSCFG language.1 It turns out that Bayesian estimation algorithms (Earley Stolcke parser) for CSCFGs have polynomial computational cost (in the data length). Therefore, in the context of target tracking, we are able to derive a Rao-Blackwellized particle filter which uses the Earley Stolcke parser for estimating the posterior distribution of a CSCFG.\nWhy syntactic models for target tracking? As described in [4], [5], syntactic models arising in natural language processing such as SCFG and CSCFG are suitable for meta-level tracking since they form generative models for complex spatial trajectories of a target. For example, a SCFG is a generative model for a trajectory sequence anbn for an integer valued random variable n; this trajectory models a target moving n steps in direction a followed by n steps in direction b. A Markov chain cannot exclusively generate such trajectories and is therefore not a generative model. Also there are polynomial computational cost (in the data length) Bayesian signal processing parsing algorithms for SCFGs and CSCFGs which make such models practical from an engineering point of view.\nThe main results of this paper are as follows: Sec. II and Sec. III discuss a 3-level model for the roadmap syntactic tracking problem. In Sec. IV, a novel CSCFG-driven particle filtering algorithm is given for the mode based syntactic tracker. Sec. V describes two CSCFG based models on a square grid. In Sec. VI, we compare numerical results between the mode based syntactic tracker (this paper) and the baseline VSIMM tracker. For the CSCFG based round trip model on the square grid, we compare performance between the CSCFG Viterbi tracker and the hidden Markov model (HMM) Viterbi tracker."}, {"heading": "II. ROADMAP CONSTRAINED SYNTACTIC TRACKING:", "text": "A 3-LEVEL MODEL\nIn this section, we construct a model for the roadmap constrained syntactic tracking problem. The model we propose operates at three levels of abstraction. At the highest level, we have the roadmap which is modeled as a directed, weighted graph. At the second level, we model the pattern (an ordered sequence of intersection names) of a target on the roadmap as a CSCFG. Finally at the lowest level, the mode sequence q1:k drives the base-level VSIMM state space model which has measurements from a GMTI radar.\n1In simple terms, a CSCFG permits both tree dependencies and serial dependencies. For an illustrative example that shows the difference between a Markov chain, SCFG and CSCFG, please see Sec. III-A and Fig. 6.\nv0v1\nv2\nv3\nv4\nv5\nv6\nv7\nv8v9\nFigure 5. Formulation of the roadmap in Fig. 1 as a directed, weighted graph G = {V,E, L}. v0, . . . , v9 denote road intersections."}, {"heading": "A. Level 1: Roadmap as a Directed Weighted Graph", "text": "Our aim is to perform meta-level tracking of a target moving confined to a roadmap. We model the roadmap as a directed, weighted graph G with vertices V , edges E and weights L\nG = {V,E, L}\nThe set of vertices V = {v1, v2, . . . , vn} denotes the n road intersections. The set of edges E = {evivj |vi, vj \u2208 V } denotes the roads on the roadmap. The set of weights L = {l(evivj )|evivj \u2208 E} denotes lengths of the roads. Define a function \u03b8 on both vertices V and edges E. \u03b8(evivj ),\u2200evivj \u2208 E denotes the angle of road evivj with respect to a reference coordinate and \u03b8(vm),\u2200vm \u2208 V denotes the set of angles of roads that intersect at the vertex vm. The directed, weighted graph for the roadmap in Fig. 1 is presented in Fig. 5."}, {"heading": "B. Level 2: CSCFG Model on Directed Weighted Graph for Targets Constrained to a Roadmap", "text": "The second level of the syntactic tracking model is a CSCFG model that ensures the target is confined to the roadmap graph G = {V,E, L}. The model determines the target\u2019s mode sequence q1:k where\nqk = {dk, lk} with dk \u2208 \u03b8(lk), lk \u2208 V \u222a E\n(3)\nHere, dk is the direction of motion of the target at time k. lk denotes the edge (road) or vertex (intersection) where the target is located on G. \u03b8(.) is defined in (1). A CSCFG is a 5-tuple of the form\nCSCFG = {N , T , S,R,P}\nwhere N is a finite set of nonterminals and T is a finite set of terminals (also called the alphabet) such that N \u2229T = \u2205. S \u2208 N is chosen to be the start symbol. R is a set of production rules of the form\nX \u2192 \u03bb|a, X \u2208 N , X 6= S, a \u2208 T , \u03bb \u2208 {N \u222a T }\u2217\nS \u2192 \u03bb\nwhich indicates the nonterminal X can be replaced with \u03bb if the previous terminal is a. P : R \u2192 [0, 1] is a probability\n4 function over production rules in R such that\u2211 nXa\nP (X \u2192 \u03bb|a) = 1\u2211 nS P (S \u2192 \u03bb) = 1\nHere, nXa is the number of rules in R associated with the nonterminal X and the terminal a. nS is the number of rules that have the start symbol S on the left side of the arrow. Starting from S, replace the leftmost nonterminal (such deviations can be represented as a parse tree [8]) according to the production rules in R and probabilities in P , the output of a CSCFG is a string of terminals. A parsing algorithm for the CSCFG is illustrated in Appendix A.\nTypes of Target and Traffic Models: For illustrative purposes, we consider two types of target and traffic models for syntactic tracking. Let ek denote the speed of a target at time k.\n1) Constant Traffic Flow or Constant Speed Model: Assume that the traffic flow c throughout the road network is a positive random variable. Then the time taken to traverse a road segment of length l(evivj ) with speed limit \u03b6i is l(evi,vj )/(\u03b6i \u2212 c). Alternatively, if the speed on a road or an intersection is an unknown constant modeled by a random variable c, then we have\nek = c (4)\nConstant speed targets can model (approximately) pedestrians and bicycles. 2) Average Speed Model: Here the speed on a road at time k equals the speed averaged over all vehicular traffic moving on that road. Therefore, the speed on a road of vehicular traffic is location based (different roads) and time varying (peak or non-peak hours). Speed at an intersection is a known constant (denoted by c2). Then we have\nek = { \u03c0E(lk, k) lk \u2208 E c2 lk \u2208 V\n(5)\nwhere lk is defined in (3). \u03c0E(lk, k) denotes the speed averaged over all vehicular traffic moving on lk at time k."}, {"heading": "C. Level 3: GMTI Base Level Model", "text": "Here, we describe the third and final component of our 3- level tracking model. We construct a VSIMM model for the base-level target\u2019s kinematics2\nwhich are measured by a GMTI radar system. The target\u2019s state evolves as\nxk = f(xk\u22121, dk\u22121:k, ek\u22121:k) + w\u0303k(dk)\nlk = B(xk), dk \u2208 \u03b8(lk) (6)\nHere, xk = [xk, yk, x\u0307k, y\u0307k]\u2032 is the 4-dimensional state vector of the target at time k that comprises position and velocity components in the x and y directions. dk and lk are defined\n2Our setup assumes a single target with no missing measurements or data association errors. Actually, missing measurements are easily handled at both the syntactic and base-level trackers.\nin (3). ek is the speed of the target specified in (4) and (5). \u03b8(.) is defined in (1). B is the function that maps xk to lk. f is a nonlinear function and models the target\u2019s state process:\nf = { f0 if dk = dk\u22121, ek = ek\u22121 f1 otherwise\n(7)\nwhere f0 = Fxk\u22121\nF is the state matrix defined by\nF =  1 0 T 0 0 1 0 T 0 0 1 0 0 0 0 1  where T is the interval between GMTI measurements. f1 in (7) denotes transforming the velocity components of Fxk\u22121 to ek cos dk in the x direction and ek sin dk in the y direction. The state noise w\u0303k(dk) in (6) is a zero-mean white Gaussian process with covariance matrix Q\u0303k(dk) computed as\nQ\u0303k(dk) = GQk(dk)G \u2032\nG =  T 2 2 0 0 T 2\n2 T 0 0 T\n , Qk(dk) = \u03c1dk [\u03c32o 00 \u03c32a ] \u03c1\u2032dk with\n\u03c1dk = [ sin dk cos dk \u2212 cos dk sin dk ] where \u2032 denotes transpose, \u03c32a is the variance along the direction of motion indicated by dk and \u03c32o is the variance along the direction of motion orthogonal to dk.\nThe observation equation is specified by the GMTI radar:\nzk = h(xk, ck) + vk where\nh(xk, ck) =  \u221a (xk \u2212 xck)2 + (yk \u2212 yck)2 + (zck)2 (x\u0307k\u2212x\u0307ck)(xk\u2212x c k)+(y\u0307k\u2212y\u0307 c k)(yk\u2212y c k)\u221a (xk\u2212xck)2+(yk\u2212y c k) 2+(zck) 2\n180 \u03c0 atan2(yk \u2212 y c k, xk \u2212 xck)\n (8)\nHere, zk = [rk, r\u0307k, \u03b8k]\u2032 denotes the 3-dimensional noisy observation vector recorded by a GMTI radar at time k. rk, r\u0307k, \u03b8k denote, respectively, the range, range rate and azimuth (in degrees, (\u2212180\u25e6, 180\u25e6]). ck = [xck, yck, x\u0307ck, y\u0307ck]\u2032 is the 4- dimensional state vector for the phase center of the GMTI radar\u2019s antenna on the aircraft it is mounted on. It comprises position and velocity components in the x and y directions. zck is the (constant) altitude of the aircraft and the (constant) altitude of the target is assumed to be zero. atan2 denotes the four-quadrant inverse tangent (in radians). The observation noise vk in (8) is assumed to be a zero-mean white Gaussian process with covariance matrix\nR = \u03c32rk 0 00 \u03c32r\u0307k 0 0 0 \u03c32\u03b8k  where \u03c3rk , \u03c3r\u0307k and \u03c3\u03b8k are standard deviations for range, range rate and azimuth, respectively. Note that R is a diagonal\n5 matrix reflecting the assumption that the errors in the range, range rate and azimuth are uncorrelated."}, {"heading": "III. EXAMPLES OF PATTERNS", "text": "Given the three level model described in Sec. II, we now elaborate on the Level 2 CSCFG model described in Sec. II-B. In particular, we discuss the two examples of constant speed targets and vehicular traffic in more detail.\nFirst we need to define what a pattern is; recall that a pattern was defined informally in Sec. I as an ordered sequence of road intersection names. More formally, given the roadmap graph G = {V,E, L} formulated in Sec. II-A, a pattern is characterized by the sequence\nr0:n = (r0, . . . , rn)\nwhere ri \u2208 V i = 0, 1, . . . , n eriri+1 \u2208 E i = 0, 1, . . . , n\u2212 1\n(9)\nWe assume that apart from kinematic measurements obtained by the radar, the type of a target is also known. In Sec. III-B and Sec. III-C, we build CSCFG based models for constant speed targets and vehicular traffic, respectively."}, {"heading": "A. A Simple Illustrative Example", "text": "To give some intuition about the difference between a Markov chain, SCFG used in earlier work, and a CSCFG used in this paper (recall (2)), consider the following example.\nMarkov Chain. Construct a first-order Markov chain with trajectory a1, . . . , an for some fixed time n. The dependency structure, which is a chain graph, is shown in Fig. 6(a).\nSCFG and Arc Trajectory. An arc is an example of trajectory with a SCFG generative model.\n1) Generate m,n as random positive integers with a prespecified distribution. 2) Then generate the following three iid finite state sequences a1, . . . , am, b1, . . . , bn and c1, . . . , cm with specified probabilities. Concatenate these into a single string.\nThe dependency structure, which is a tree graph, is shown in Fig. 6(b). It can be verified via a pumping lemma [7] that a Markov chain is not a generative model for an arc since the integer m has an arbitrary (random) value.\nCSCFG. A CSCFG trajectory has more general dependencies as follows.\n1) Generate m,n as random positive integers with some prespecified distribution. 2) Then generate the following three Markovian finite state sequences a1, . . . , am, b1, . . . , bn and c1, . . . , cm with specified transition probabilities. Concatenate these into a single string.\nThe dependency structure, which is a tree-chain graph, is shown in Fig. 6(c). The main point is that a CSCFG model facilitates both serial and tree dependencies. We refer to [6] for a detailed discussion of CSCFGs. In the remainder of this section we describe more sophisticated examples involving constant traffic flow and average speed models."}, {"heading": "B. Constant Traffic Flow or Constant Speed Model", "text": "Here, we provide more details of the constant traffic flow or constant speed model in Sec. II-B. Given a pattern r0:n, let mriri+1 , i = 0, 1, . . . n \u2212 1, denote the sequence of vectors comprising directions and locations of a target as it traverses from vertex (intersection) ri to ri+1.\nTo provide a concrete example, consider the setup in Fig. 7(a) where a target moves from ri to ri+1. It moves in a constant direction \u03b8(eriri+1) and via the locations ri, eriri+1 , ri+1. Therefore,\nmriri+1 = {\u03b8(eriri+1), ri}i1{\u03b8(eriri+1), eriri+1}i2\n{\u03b8(eriri+1), ri+1}i3 (10)\nwhere i1, i2, i3 denote positive integers. In words: the target moving from ri to ri+1 generates vectors {\u03b8(eriri+1), ri} for i1 time instants, followed by generating vectors {\u03b8(eriri+1), eriri+1} for i2 time instants, finally followed by generating vectors {\u03b8(eriri+1), ri+1} for i3 time instants. Therefore the total amount of time taken for traversing from ri to ri+1 is |mriri+1 | = i1 + i2 + i3 Lcsr0:n is denoted as the sequence of vectors comprising directions and locations of a constant speed target as it traverses vertex r0, r1, . . . , rn. Lcsr0:n is the concatenation of mr0r1 ,mr1r2 , . . . ,mrn\u22121rn ; see Fig. 7(b). The key point is that since the target moves with constant speed, the time |mriri+1 |, i = 0, 1, . . . n\u2212 1 taken to traverse from ri to ri+1 is proportional to the length of the edge connecting ri and ri+1, namely, l(eriri+1). Therefore,\nLcsr0:n = \u2295 n\u22121 i=0 mriri+1 with |mr0r1 | : |mr1r2 | : . . . |mrn\u22121rn | = l(er0r1) : l(er1r2) : . . . l(ern\u22121rn)\n(11)\nHere, \u201c\u2295\u201d denotes concatenation. It can be shown [4] that a generative model for Lcsr0:3 and L cs r0:4 is a context sensitive grammar. In this paper, we approximate Lcsr0:3 , L cs r0:4 by\nLcsr0:3 = mr0r1mr1r2mr2r3 with |mr0r1 | : |mr2r3 | = l(er0r1) : l(er2r3)\nand Lcsr0:4 = mr0r1mr1r2mr2r3mr3r4 with |mr0r1 | : |mr2r3 | = l(er0r1) : l(er2r3)\nA CSCFG that generates Lcsr0:n (n = 1, 2, 3, 4) is given in Appendix C. The architecture of the mode based syntactic tracker for constant speed targets is given in Fig. 8(a)."}, {"heading": "C. Average Speed Model", "text": "Here, we describe the average speed model (denoted by Lvtr0:n ) described in Sec. II-B given a pattern r0:n.\nThe average speed model Lvtr0:n is the sequence of vectors comprising directions and locations of a vehicular traffic that starts from r0, traverses through r1, r2, . . . , rn\u22121 and ends at rn. From Fig. 7(b), we have\nLvtr0:n = \u2295 n\u22121 i=0 mriri+1 (12)\n6 a1 a2 . . . an\n(a)\nwhere mriri+1 , i = 0, 1, . . . n\u22121 is defined in (10) and \u201c\u2295\u201d is defined in (11). There is no additional constraint on |mriri+1 |, i = 0, 1, . . . n \u2212 1 because the speed of a vehicular traffic is location based and time varying (5). Lvtr0:n can be modeled via a stochastic regular grammar which is a strict subset of CSCFGs (2). The architecture of the mode based syntactic tracker for vehicular traffic is illustrated in Fig. 8(b)."}, {"heading": "IV. CSCFG-DRIVEN PARTICLE FILTER TRACKER", "text": "Thus far, we have discussed a 3-level model for a target confined to a roadmap. In this section, we describe a novel natural language based particle filtering algorithm for estimating the coordinates of the target.\nFor the 3-level model proposed in Sec. II and Sec. III, direct computation of the posterior distribution is computationally intractable.3 Therefore, given the noisy observation sequence z1:k, k = 1, 2, . . . , our aim is to compute the posterior distribution\np(sk|z1:k, r\u22170:n) where sk = (xk, qk, ek), r \u2217 0:n = argmax\n\u2200r0:n\u2208M p(r0:n|z1:k) (13)\n3Since the model is a grammar-driven linear system, even for simple case of a jump Markov linear system, computing the posterior is intractable\nRecall from (4), (5), that ek denotes the speed of the target at time k, xk, qk are defined in (6), (3) and r0:n denotes a pattern defined in (9). In this section, a Rao-Blackwellized CSCFGdriven particle filtering algorithm is derived (see Algorithm 1\n7 Base-level tracker\nCSCFG based meta-level tracker\nr0:n\nqk p(qk|q1:k\u22121,Lcsr0:n)\np(xk|z1:k,Lcsr0:n)\nLcsr0:n\nMode based syntactic tracker for constant speed targets\n(a)\nBase-level tracker\nStochastic regular grammar based meta-level tracker\nr0:n\nqk p(qk|q1:k\u22121,Lvtr0:n)\np(xk|z1:k,Lvtr0:n)\nLvtr0:n\nMode based syntactic tracker for vehicular traffic\n(b)\nFigure 8. Architectures of the mode based syntactic trackers for two types of targets. (a) is the architecture of the mode based syntactic tracker for constant speed targets. (b) is the architecture of the mode based syntactic tracker for vehicular traffic. r0:n is a pattern defined in (9). Lcsr0:n and L vt r0:n are, respectively, the constant speed model and the average speed model for pattern r0:n. k is the discrete time, z1:k denotes the noisy observation sequence recorded by a GMTI radar and xk is the state vector of the target. The mode qk is defined in (3).\nand Algorithm 2). The particle filtering algorithm presented below exploits the fact that given the kinematic state xk, the modes can be estimated via a finite dimensional predictor in terms of the Earley Stolcke parser.\nFor constant speed targets\np(sik|zi1:k\u22121, r0:n) = p(sik|zi1:k\u22121,Lcsr0:n)\nwhere Lcsr0:n is the constant speed model discussed in Sec. III-B. For the vehicular traffic,\np(sik|zi1:k\u22121, r0:n) = p(sik|zi1:k\u22121,Lvtr0:n)\nwhere Lvtr0:n is the average speed model discussed in Sec. III-C. The particle approximation to the full posterior distribution is\np(s1:k|z1:k, r0:n) \u2248 Np\u2211 i=1 wik\u03b4(s i 1:k)\nwhere Np is the number of particles. The particle weights wik\nare computed recursively as\nwik = p(si1:k|z1:k, r0:n) \u03c0(si1:k|z1:k, r0:n)\n\u221d p(sik|si1:k\u22121, r0:n)p(zk|sik) \u03c0(sik|si1:k\u22121, z1:k, r0:n) p(si1:k\u22121|z1:k\u22121, r0:n) \u03c0(si1:k\u22121|z1:k\u22121, r0:n) \u221d p(sik|si1:k\u22121, r0:n)p(zk|sik) \u03c0(sik|si1:k\u22121, z1:k, r0:n) wik\u22121\nChoose the bootstrap proposal distribution\n\u03c0(sik|si1:k\u22121, z1:k, r0:n) = p(sik|si1:k\u22121, r0:n) = p(xik, q i k, e i k|xi1:k\u22121, qi1:k\u22121, ei1:k\u22121, r0:n)\n= p(qik|qi1:k\u22121, r0:n)p(eik|eik\u22121, lik)p(xik|xik\u22121, dik\u22121:k, eik\u22121:k) (14)\nThe first term is the CSCFG one-step predictor in (25). The second term is computed in terms of (4) and (5). The third term in (14), according to (6) is\np(xik|xik\u22121, dik\u22121:k, eik\u22121:k) = N (f(xik\u22121, dik\u22121:k, eik\u22121:k), Q\u0303k(dik))\n(15)\nwhere f(.) and Q\u0303k(dik) are defined in (6). Recursive computation of wik before normalization is\nw\u0303ik = p(zk|sik)wik\u22121 with\np(zk|sik) = { 0 lik 6= B(xik) N (h(xik, ck), R) lik = B(xik)\n(16)\nwhere h(.), ck, R are defined in (8) and B is defined in (6). The CSCFG-driven particle filtering algorithm is illustrated in Algorithm 1.\nAlgorithm 1 CSCFG-Driven Particle Filter Tracker Function CSCFG-PF {si1:k\u22121, wik\u22121, zk, r0:n} for i=1 to Np do\nSample qik \u223c p{qk|qi1:k\u22121, r0:n} using (25) Sample eik according to (4) or (5) Sample xik according to (15) Compute w\u0303ik using (16)\nend for Wk = \u2211Np i=1 w\u0303 i k Normalize wik = w\u0303 i k/Wk,\u2200i = 1, 2, \u00b7 \u00b7 \u00b7 , Np Neffective = 1\u2211Np\ni=1(w i k) 2\nif Neffective <threshold then RESAMPLE for i=1 to Np do wik = 1 Np\nend for end if return {si1:k, wik}\n8 Decision Directed Scheme\nStrictly speaking, we should assign each particle a CSCFG parser. Here, we apply a decision-directed scheme introduced in [9], namely, Np particles drive a single parser. Denote q\u0302k the soft estimate at time k and is computed as\np(q\u0302k = m) = Np\u2211 i=1 \u03b4(qik \u2212m)wik (17)\nThe one step predictor in (14) is approximated by\np(qik|qi1:k\u22121, r0:n) \u2248 p(qik|qik\u22121, q\u03021:k\u22122, r0:n) (18)\nwhere q\u03021:k\u22122 = (q\u03021, q\u03022, . . . , q\u0302k\u22122). (18) is computed via (26) in Appendix A. A CSCFG-driven particle filtering algorithm with a decision directed scheme is presented in Algorithm 2. The posterior probability p(r0:n|z1:k) in (13) is computed\nAlgorithm 2 CSCFG-Driven Particle Filter Tracker with Decision Directed Scheme\nFunction CSCFG-PF {si1:k\u22121, wik\u22121, zk, q\u03021:k\u22122, r0:n} for i = 1 to Np do\nSample qik \u223c p{qk|qik\u22121, q\u03021:k\u22122, r0:n} using (26) Sample eik according to (4) or (5) Sample xik according to (15) Compute w\u0303ik using (16)\nend for Wk = \u2211Np i=1 w\u0303 i k Normalize wik = w\u0303 i k/Wk,\u2200i = 1, 2, \u00b7 \u00b7 \u00b7 , Np Neffective = 1\u2211Np\ni=1(w i k) 2\nif Neffective <threshold then RESAMPLE for i=1 to Np do wik = 1 Np\nend for end if Compute q\u0302k using (17) return {si1:k, wik, q\u03021:k}\nusing Bayes\u2019 formula,\np(r0:n|z1:k) = p(z1:k|r0:n)p(r0:n)\u2211\nr0:n\u2208M p(z1:k|r0:n)p(r0:n)\nHere, p(z1:k|r0:n) equals the prefix probability p(q\u03021:k|r0:n) computed by (27). M denotes a set of patterns that a radar operator is interested in. p(r0:n) is the prior probability for pattern r0:n and\n\u2211 \u2200r0:n\u2208M p(r0:n) = 1."}, {"heading": "V. EXAMPLES OF ANOMALOUS TRAJECTORIES MODELED", "text": ""}, {"heading": "BY CSCFG", "text": "In this section, we consider two detailed examples of suspicious (anomalous) trajectories of a target: (i) round trip trajectories which indicate a target circling an area of interest, and (ii) cost constrained palindrome trajectories which indicate a target re-tracing its path. In both examples, a CSCFG serves as a generative model. These examples generalize our earlier work [5] where SCFGs were used.\nIt is assumed that the target is moving confined to a square grid illustrated in Fig. 9 and is tracked by a GMTI radar. The aim is to compute the maximum a posterior sequence estimate\nx\u22171:n = argmax x1:n p(x1:n|z1:n,L) (19)\nHere, x1:n = (x1,x2, . . . ,xn) denotes the target\u2019s state sequence and z1:n = (z1, z2, . . . , zn) denotes the noisy GMTI radar measurement sequence; xk, zk, k = 1, 2, . . . , n are defined later. L is the round trip or cost constrained palindrome trajectory modeled by a CSCFG.\nLet oij denote the node with Cartesian coordinates (i, j) and Ggrid denote the set of all nodes of the square grid. Define the following relationships on nodes in Ggrid\noij up,right\u2212\u2212\u2212\u2212\u2192 oi\u2032j\u2032 if i\u2032 = i, j\u2032 \u2212 j = 1 or i\u2032 \u2212 i = 1, j\u2032 = j\noij down,left\u2212\u2212\u2212\u2212\u2212\u2192 oi\u2032j\u2032 if i = i\u2032, j\u2032 \u2212 j = \u22121 or i\u2032 \u2212 i = \u22121, j\u2032 = j\noij adjacent\u2212\u2212\u2212\u2212\u2192 oi\u2032j\u2032 if oij and oi\u2032j\u2032 are adjacent (20) At each discrete time, we assume a target can only move up, down, left, right to its adjacent nodes. xk is specified by\nxk = {xk, yk} \u2208 Ggrid (21)\nzk is the two dimensional (comprising range and azimuth components) noisy observation vector recorded by a GMTI radar and the observation function is described in (8). Note that the target\u2019s position in the x (y) direction equals the coordinate in the x (y) direction times the size of the unit grid."}, {"heading": "A. Example 1. Round Trip Model", "text": "In the round trip model, denoted by Lround, a target departs from some node A, arrives at another node B and finally returns to A. On the forward trip, it is assumed that the target can only move up and right; while on the return trip, the target can only move down and left. The resulting target\u2019s trajectory is as follows:\nDefinition 1. Lround = x1:n where{ xk\nup,right\u2212\u2212\u2212\u2212\u2192 xk+1 \u2200k = 1, 2, . . . , n\u221212 xk down,left\u2212\u2212\u2212\u2212\u2212\u2192 xk+1 \u2200k = n+12 , n+3 2 , . . . , n\u2212 1\nHere, up,right\u2212\u2212\u2212\u2212\u2192, down,left\u2212\u2212\u2212\u2212\u2212\u2192 are defined in (20) and xk is defined in (21). An example of the round trip model is presented in Fig. 9. Lround indicates a target moves to some other node and returns to the start point with minimal distance and possibly minimal probability being detected (routine of return trip is probably different from that of forward trip). From Def. 1, Lround is the concatenation of two equal length (tree dependency) Markov chains (serial dependency): x1:n+12 and xn+12 :n. The transition probability is dependent on the traffic data. Such a tree and serial combined dependency cannot be modeled via a SCFG as explained in Sec. III-A. Lround is modeled via a CSCFG and details are illustrated in Appendix B.\n9"}, {"heading": "B. Example 2. Cost Constrained Palindrome", "text": "In a palindrome trajectory model, a target starts from some node A, moves to some node B and then retraces its path to A. Several examples in surveillance involve detecting palindrome trajectories of targets.4 An example of Lpalindrome is shown in Fig. 9. It is well known that a SCFG is a generative model for a palindrome.\nHere we consider a generalization called the cost constrained palindrome which has serial dependencies and therefore requires a CSCFG model. The serial dependencies are introduced by considering the process \u2206k which denotes the cost (threat level or fuel consumption) incurred at each time k. \u2206k is modeled by a Markov chain with state space dependent on xk\u22121 and xk. Then \u2211k i=1 \u2206i denotes the cost (fuel or funds) incurred up to time k. We assume that the target can only continue moving if the total cost (threat) accrued lies within the bound: \u2211k i=1 \u2206i \u2264 C for some pre-specified constant C. The cost constrained palindrome model, denoted by Lpalindrome is formally specified as follows:\nDefinition 2. Lpalindrome = y1:n, yk = {xk,\u2206k} where\nxk adjacent\u2212\u2212\u2212\u2212\u2192 xk+1, k = 1, 2, . . . n\u2212 1\nxnxn\u22121 . . .xn+1 2 = x1x2 . . .xn+1 2 xk \u223c p(xk|xk\u22121), k = 1, 2, . . . , n+ 1 2 \u2206k \u223c p(\u2206k|\u2206k\u22121,xk,xk\u22121), k = 1, 2, . . . , n k\u2211 i=1 \u2206i \u2264 C, k = 1, 2, . . . , n\nHere, xk is defined in (21) and adjacent\u2212\u2212\u2212\u2212\u2192 is defined in (20). The third item in Def. 2 is dependent on the traffic data and the fourth item specifies the evolution of the cost process.\nNote that the second, third and fourth items in Def. 2 exhibit a combined tree and serial dependency which cannot modeled by a SCFG; recall the discussion in Sec. III-A. Details of Lpalindrome constructed as a CSCFG are given in Appendix B.\nFinally, computing the MAP sequence estimate in (19) for a round trip or a cost constrained palindrome trajectory uses a CSCFG Viterbi tracker which is illustrated in Fig. 10. The CSCFG Viterbi parsing algorithm is detailed in Appendix B."}, {"heading": "VI. NUMERICAL EXAMPLES", "text": "This section presents three detailed numerical examples involving CSCFGs for meta-level tracking. For the first two examples, the setup is as follows. The mode based syntactic tracker proposed in this paper estimates the state moving of a target that is confined to a roadmap given noisy GMTI radar observations. The main algorithm (Algorithm 2) is a Rao-Blackwellized particle filter which combines the Earley Stolcke parser with a base-level particle filter. The empirical\n4Here are three examples: (i) For a smuggler, if the forward trip from A to B is safe (e.g. , no guards), then retracing this path from B to A minimizes being captured. (ii) A vehicle (bus) transports passengers from A to B and on the return trip transports passengers from B to A via the same stops. (iii) Retracing the path also occurs when searching for a dropped or lost item.\nperformance of the mode based syntactic tracker (denoted by M in the figures below) is evaluated by simulating measurements from a GMTI radar against a target moving on the road network described by Fig. 1. See Table I for the primary properties of the radar measurements; further detail is provided in Appendix D. Note we are assuming no missing measurements (i.e. the probability of detection is unity). The aircraft where a GMTI radar is mounted starts from (-30 km,-30 km) with (constant) altitude 3000m and moves with constant velocity (100 m/s in the x direction and 20 m/s in the y direction). We also evaluate the performance of the baseline VSIMM tracker (proposed in [1] [2]) for comparison. The performance are evaluated by the simulated sample path state root mean square error averaged over 50 independent trials. Root mean square error at time k is computed as\nRMSE(k) = \u221a\u221a\u221a\u221a 1 N N\u2211 n=1 (x\u0302nk \u2212 xtk)\u2032(x\u0302nk \u2212 xtk)\nHere, x\u0302nk is the estimated target state vector at time k in the nth trial and xtk is the target\u2019s true state vector at time k."}, {"heading": "A. Example 1. Constant Speed Targets", "text": "Consider the model of Sec. III-B. The speed of a constant speed target is an unknown constant and we assume its initial\n10\ndistribution is evenly distributed on 3 states: 2 m/s, 3 m/s and 4 m/s. Performance of the mode based syntactic tracker and the baseline VSIMM tracker when tracking constant speed targets under different patterns are displayed in Table II. The \u201cimprovement\u201d in the final column is computed as\nimprovement = 1\u2212 average( RMSE M\nRMSEV SIMM )\nwhere average( RMSE M\nRMSEV SIMM ) is the average ratio between the RMSE for the mode based syntactic tracker and the RMSE for the VSIMM tracker at each discrete time. An example of RMSEs for the two trackers is illustrated in Fig. 11(a). We see that the mode based syntactic tracker performs better than the VSIMM tracker in terms of the positive \u201cimprovement\u201d which is more than 5% under 3 specific patterns: v3v0v2, v9v0v3v8, v9v0v1v4. The explanation is that the meta-level modeling in the mode based syntactic tracker is pattern based and therefore the tracker can definitely know which road to move on to\nafter passing an intersection. In addition, CSCFG at the metalevel can model longer and more complicated dependencies compared with a Markov chain such that properties of a constant speed model discussed in Sec. III-B can be well captured."}, {"heading": "B. Example 2. Average Speed Model", "text": "Next, consider the average speed model of Sec. III-C which is suitable for vehicular traffic. For vehicular traffic, the simulations assume that the speed on roads is location-based and time-varying and is a known constant at intersections (5 m/s); see Table VI in Appendix D for details. Performance of the mode based syntactic tracker and the baseline VSIMM tracker when tracking vehicular traffic are shown in Table III. An example of RMSEs for the two trackers is illustrated in Fig. 11(b). For specific patterns such as v3v0v2 and v9v0v3v8, the mode based syntactic tracker performs much better than\n11\nthe VSIMM tracker by over 8%. However, there is little difference between the two competing models for the remaining 4 patterns in Table III. Generally speaking, the mode based syntactic tracker for vehicular traffic does not show as drastic an improvement as for constant speed targets. The explanation is that the VSIMM tracker is able to infer which road the target is moving on after passing an intersection by distinct average speed which is location based (5). An example is shown in Fig. 12 where a target moves from r0 to r2. Due to uncertainties on which road the target moves on (r1 or r2) after the intersection, the VSIMM tracker propagates particles on both r1 and r2. However, particles on r1 are assigned (real time average) speed of 10 m/s which is much larger than the (real time average) speed on r2 (5 m/s) where the target is truly moving on. This may result in obvious differences on the range rate component in the observation vector in (8). Hence, particles on r1 have much lower weights compared with those on r2. In this way, (real time average) speeds for different roads give \u201chints\u201d to the VSIMM tracker on which road the target is moving on after passing an intersection and thus VSIMM tracker can improve the tracking accuracy. In addition, notice that RMSEs for both trackers (when tracking vehicular traffic) decrease faster than those for constant speed targets. The reason is that vehicular traffic have higher speeds. An example is shown in Fig. 13. At time k, particles (red arrows) moving on r1 and r2 have similar weights. However, particles (green arrow on r1) moving on r1 immediately become \u201cfar away\u201d from target\u2019s true state vector (right black arrow) after time \u2206 and therefore are assigned lower weights. Smaller \u2206 due to higher speeds of vehicular traffic results in sharp decrease in the RMSEs as shown in Fig. 11(b)."}, {"heading": "C. Example 3. Round Trip Model", "text": "The round trip model describes a target that departs from some node A, arrives at another node B and then returns to A; see Sec. V-A. The trajectory is constrained as follows: the\ntarget moves to its adjacent nodes at each discrete time; it moves up and right on the forward trip; on the return trip, it moves down and left. We present simulations on a 20\u00d720 square grid roadmap with size of the unit grid as 2 meters (m). Targets are recorded by a GMTI radar with parameters listed in Table I. The GMTI radar is mounted on an aircraft. The aircraft starts from coordinates (-300 m,-300 m) with constant velocity (100 m/s in the x direction and 20 m/s in the y direction).\nGiven noisy GMTI radar measurements, our aim is to compute the most likely state sequence x\u22171:n defined in (19) and the architecture of the CSCFG Viterbi tracker is illustrated in Fig. 10. We also illustrate a hidden Markov model (HMM) Viterbi tracker for comparison and their performance are shown in Fig. 14 evaluated by averaging error over 40 independent trials. The error for each trial is computed as\nerror = 1\nn n\u2211 k=1 \u2016x\u2217k \u2212 xtk\u20162 (22)\nwhere n is the length of observations, x\u2217k is the Viterbi estimate for time k and xtk is the true state vector.\nFig. 14 shows that the CSCFG Viterbi tracker has a significantly smaller tracking error (defined in (22)) compared to the HMM Viterbi tracker. The reason is that a CSCFG can model longer and more complicated spatial dependencies than a Markov chain so that all properties of a round trip model discussed in Sec. V-A are captured. Fig. 15 shows an example of state estimates by the CSCFG Viterbi tracker and the HMM Viterbi tracker. We can see for the HMM Viterbi tracker, there are lefts and downs in the forward trip (red) and rights and ups in the return trip (blue) which are impossible for the round trip model discussed in Sec. V-A."}, {"heading": "VII. CONCLUSION", "text": "In this paper, we constructed a 3-level model for the syntactic tracking problem of targets whose movement is confined to a roadmap by using natural language models. At the first level, the roadmap was modeled as a weighted, directed graph; at the second level, the mode sequence was modeled via a CSCFG; finally the base level kinematics of the target were modeled by a VSIMM. A novel CSCFG-driven particle filtering algorithm was devised to track a target\u2019s kinematics given GMTI measurements. Numerical studies show that compared with the classic VSIMM tracker, the mode based syntactic tracker proposed in this paper can substantially improve the tracking accuracy. We also discussed two CSCFG based models for targets moving on the square grid. A Viterbi algorithm was illustrated to compute the most likely hidden state sequence of the target given noisy GMTI radar measurements. Numerical results based on the round trip model show the CSCFG Viterbi tracker can substantially decrease the tracking error compared with a classical Viterbi tracker.\nAcknowledgement.: We gratefully acknowledge Dr. Martie Goulding of MacDonald Dettwiler Associates (MDA) for several useful technical discussions and careful comments on the paper. Parts of this research were funded by MDA via an NSERC CRD Grant.\n12\n(a)\n(b)\nFigure 14. Performance of the CSCFG Viterbi tracker (red line) and the HMM Viterbi tracker (green line). \u03c3r and \u03c3\u03b8 are defined in (8). (a) illustrates the tracking errors for the two Viterbi trackers under a range of \u03c3r (step=0.5m) and we set \u03c3\u03b8 = 0.5\u25e6. (b) illustrates the tracking errors for the two Viterbi trackers under a range of \u03c3\u03b8 (step=0.05\u25e6) and we set \u03c3r=5m."}, {"heading": "APPENDIX A", "text": ""}, {"heading": "A PARSING ALGORITHM FOR THE CONSTRAINED STOCHASTIC CONTEXT FREE GRAMMAR (CSCFG)", "text": "Here, we present a parsing algorithm (polynomial time computational cost) for the CSCFG={N , T , S,R,P} defined in Sec. II-B. The parsing algorithm is a modified version of the classic Earley Stolcke parser. This parsing algorithm computes the one step prediction probability and the prefix probability. To the best of our knowledge, this algorithm is new.\nThe classic Earley Stolcke parser is used to reconstruct parse trees that generate the input string based on a stochastic context free grammar (SCFG) [8]. It generates a sequence of Earley states by scanning, completion and prediction operations. An Earley state can be written as\nk k\u2032X \u2192 \u03bb.\u03b2\u00b5[\u03b1, \u03b3] (23)\nwhere X \u2208 N , \u03bb, \u03b2, \u00b5 \u2208 (N \u222a T )\u2217. k is the current epoch and k\u2032 is the back pointer to the epoch when this Earley state is generated by the prediction operation. The dot \u2019.\u2019 marks that the portion on its left handed side has been parsed or recognized by the parser. \u03b1 and \u03b3 are called the forward probability and the inner probability, respectively [8]. We expand the Earley state such that it can record the associated terminals\nk k\u2032X \u2192 \u03bb.\u03b2\u00b5[s, f ][\u03b1, \u03b3] (24)\nwhere k, k\u2032, X , \u03bb, \u03b2, \u00b5, \u03b1, \u03b3 are defined in (23). s is called the start symbol and denotes the previous terminal when X is rewritten by \u03bb\u03b2\u00b5 in epoch k\u2032. f is called the finish symbol and denotes the final terminal that has been parsed before the dot.\nThe probabilistic left corner relation is computed as\np(X L\u2192 Y |a) = \u2211 X\u2192Y \u03bb|a\u2208R p(X \u2192 Y \u03bb|a)\nand the probabilistic unit relation is computed as\np(X U\u2192 Y |a) = p(X \u2192 Y |a)\nwhere X , Y \u2208 N , a \u2208 T , \u03bb \u2208 {N \u222a T }\u2217. After computing the left corner and unit relations between nonterminals, we can get the reflexive, transitive left corner matrix Rl and the unit production relation matrix Ru. Details are illustrated in [8]. A parsing algorithm for the CSCFG is shown in Algorithm 3. The one step predictor is computed as\np(qk|q\u03021:k\u22121,LCSCFG) =\n\u2211 a=qk,n\u2208uk\u22121\n\u03b1(k\u22121k\u2032 X \u2192 \u03bb.a\u00b5[s, f ])\u2211 n\u2208uk\u22121 \u03b1(k\u22121k\u2032 X \u2192 \u03bb.a\u00b5[s, f ])\n(25) where qk, a \u2208 T , X \u2208 N , \u03bb, \u00b5 \u2208 (N \u222a T )\u2217. LCSCFG is the language generated by the CSCFG. q\u03021:k\u22121 is a hard or\nAlgorithm 3 Parsing Algorithm for the Constrained Stochastic Context Free Grammar (CSCFG) X , Y , \u0393 \u2208 N , \u03bb, \u00b5, \u03b2, \u03b7 \u2208 (N \u222aT )\u2217, \u03b7 /\u2208 N , a \u2208 T . n is a general denotation for an Earley state and uk is the set of all Earley states at epoch k. q\u0302k is the hard or soft estimate at time k. 1. Scanning for k\u22121k\u2032 X \u2192 \u03bb.a\u00b5[s, f ][\u03b1, \u03b3] \u2208 uk\u22121 do\nAdd kk\u2032X \u2192 \u03bba.\u00b5[s\u2032, f \u2032][\u03b1\u2032, \u03b3\u2032] to uk if p(q\u0302k|a) > 0 \u03b1\u2032 = \u03b1p(q\u0302k|a) \u03b3\u2032 = \u03b3p(q\u0302k|a) s\u2032 = s f \u2032 = a\nend for \u03b6k = \u2211 n\u2208uk \u03b1(kk\u2032X \u2192 \u03bba.\u00b5) \u2200n \u2208 uk, normalize \u03b1, \u03b3 using \u03b6k\n2. Completion for kk\u2032\u0393\u2192 \u03b7.[s, f ][\u03b1, \u03b3] \u2208 uk do\nfor k \u2032\nk\u2032\u2032X \u2192 \u03bb.Y \u00b5[s\u2032\u2032, s][\u03b1\u2032\u2032, \u03b3\u2032\u2032] \u2208 uk\u2032 do\nif Ru(Y,\u0393|s) 6= 0 then Add kk\u2032\u2032X \u2192 \u03bbY.\u00b5[s\u2032, f \u2032][\u03b1\u2032, \u03b3\u2032] to uk \u03b1\u2032+ = \u03b1\u2032\u2032\u03b3Ru(Y,\u0393|s) \u03b3\u2032+ = \u03b3\u2032\u2032\u03b3Ru(Y,\u0393|s) s\u2032 = s\u2032\u2032\nf \u2032 = f end if\nend for end for\n3. Prediction for kk\u2032X \u2192 \u03bb.Y \u00b5[s, f ][\u03b1, \u03b3] \u2208 uk do\nAdd kk\u0393\u2192 .\u03b2[s\u2032, f \u2032][\u03b1\u2032, \u03b3\u2032] to uk if Rl(Y,\u0393|f) 6= 0 \u03b1\u2032+ = \u03b1Rl(Y,\u0393|f)p(\u0393\u2192 \u03b2|f) \u03b3\u2032 = p(\u0393\u2192 \u03b2|f) s\u2032 = f f \u2032 = f\nend for\nsoft partial observation sequence. n is a general denotation for an Earley state and uk\u22121 is the set of all Earley states at epoch k \u2212 1. The modified one step predictor is computed as\np(qk|qk\u22121, q\u03021:k\u22122,LCSCFG)\n=\n\u2211 a=qk,f=qk\u22121,n\u2208uk\u22121\n\u03b1(k\u22121k\u2032 X \u2192 \u03bb.a\u00b5[s, f ])\u2211 f=qk\u22121,n\u2208uk\u22121 \u03b1(k\u22121k\u2032 X \u2192 \u03bb.a\u00b5[s, f ]) (26)\nThe prefix probability is computed as\np(q\u03021:k|LCSCFG) = \u2211 n\u2208uk \u03b1(kk\u2032X \u2192 \u03bba.\u00b5[s, a]) (27)\n14"}, {"heading": "APPENDIX B", "text": "MODEL Lround AND Lpalindrome VIA A CSCFG AND A\nVITERBI ALGORITHM FOR THE CSCFG\nHere, we give constrained stochastic context free grammar models that generate Lround and Lpalindrome discussed in Sec. V and introduce a Viterbi algorithm for the CSCFG.\nDenote CSCFGround = {N , T , S,R,P} (28)\nthe constrained stochastic context free grammar that generates Lround defined in Def. 1. N = {S,X,A,C,D} is a finite set of nonterminals and S is the start symbol. T = Ggrid is a finite set of terminals where Ggrid is the set of all nodes on the square grid discussed in Sec. V. R is a finite set of rules illustrated in Fig. 16 and P is a probability function on rules in R. Note that the production rules in Fig. 16 include a -type production rule\nX \u2192 |a,X \u2208 N , a \u2208 T\nwhich indicates the nonterminal X cannot be rewritten if the previous terminal is a. The derivation stops if a -type production rule is applied. In other words, CSCFGround cannot generate terminal strings if -type production rules are applied in one derivation.\nDenote CSCFGpalindrome the constrained stochastic context free grammar that generates Lpalindrome defined in Def. 2. The production rules are illustrated in Fig. 17.\nThe Viterbi algorithm is an offline algorithm to find the most likely terminal string (denoted by a\u22171:n) generated by a CSCFG given a noisy observation sequence (hard or soft) q\u03021:n. The aim is to compute\na\u22171:n = argmax a1:n p(a1:n|q\u03021:n,LCSCFG)\nwhere LCSCFG is the language generated by the CSCFG. In the Viterbi algorithm, we extend the Earley state to be\nk k\u2032X \u2192 \u03bb.\u03b2\u00b5[s, f ][\u03b3][str] (29)\nDefinitions except [str] are introduced in (24). [str] is a string of clean terminals xk\u2032+1 . . . xk directly or indirectly generated by the Earley state kk\u2032X \u2192 \u03bb.\u03b2\u00b5[s, f ][\u03b3]. \u2200X,Y \u2208 N (X 6= Y ), \u2200a \u2208 T , define\nRmaxu (X,Y |a) =\nmax p(X \u2192 Z1|a)p(Zn \u2192 Y |a) n\u22121\u220f i=1 p(Zi \u2192 Zi+1|a)\nand Rmaxu (X,X|a) = 1\nHere, X,Y, Z1, Z2 . . . Zn are different nonterminals. Rmaxu is computed to avoid completion loops. A Viterbi algorithm for the CSCFG is presented in Algorithm 4."}, {"heading": "APPENDIX C", "text": "MODEL Lcsr0:n VIA A CSCFG\nHere, we give production rules for the CSCFG that generates Lcsr0:n (n = 1, 2, 3, 4) defined in (11); see Fig. 18.\nAlgorithm 4 Viterbi Algorithm for the Constrained Stochastic Context Free Grammar (CSCFG) X , Y , \u0393 \u2208 N , \u03bb, \u00b5, \u03b2 \u2208 (N \u222a T )\u2217, \u03b2 /\u2208 N , a \u2208 T . n is a general denotation for an Earley state. uk is the set of all Earley states at epoch k. \u03c8k is the set of Earley states generated by the completion operation at epoch k. q\u0302k is the hard or soft estimate at time k. Set p(q\u0302k| ) = 0. 1. Scanning for k\u22121k\u2032 X \u2192 \u03bb.a\u00b5[s, f ][\u03b3][str] \u2208 uk\u22121 do\nAdd kk\u2032X \u2192 \u03bba.\u00b5[s\u2032, f \u2032][\u03b3\u2032][str\u2032] to uk if p(q\u0302k|a) > 0 \u03b3\u2032 = \u03b3p(q\u0302k|a) s\u2032 = s f \u2032 = a str\u2032 = [str; a]\nend for \u03b6k = \u2211 n\u2208uk \u03b3(kk\u2032X \u2192 \u03bba.\u00b5) \u2200n \u2208 uk, normalize \u03b3 using \u03b6k\n2. Completion for kk\u2032\u0393\u2192 \u03b2.[s, f ][\u03b3][str] \u2208 uk do\nfor k \u2032\nk\u2032\u2032X \u2192 \u03bb.Y \u00b5[s\u2032\u2032, s][\u03b3\u2032\u2032][str\u2032\u2032] \u2208 uk\u2032 do Add kk\u2032\u2032X \u2192 \u03bbY.\u00b5[s\u2032, f \u2032][\u03b3\u2032][str\u2032] to \u03c8k if Rmaxu (Y,\u0393|s) > 0 \u03b3\u2032 = \u03b3\u2032\u2032\u03b3Rmaxu (Y,\u0393|s) s\u2032 = s\u2032\u2032 f \u2032 = f str\u2032 = [str\u2032\u2032; str]\nend for end for\nAdd kk\u2032\u2032X \u2192 \u03bbY.\u00b5[s\u2032, f \u2032][\u03b3\u2032][str\u2032] = argmax k k\u2032\u2032X\u2192\u03bbY.\u00b5[s \u2032,f \u2032][\u03b3][str]\u2208\u03c8k \u03b3 to uk\n3. Prediction for kk\u2032X \u2192 \u03bb.Y \u00b5[s, f ][\u03b3][str] \u2208 uk do\nAdd kk\u0393\u2192 .\u03b2[s\u2032, f \u2032][\u03b3\u2032][str\u2032] to uk if Rl(Y,\u0393|f) 6= 0 \u03b3\u2032 = p(\u0393\u2192 \u03b2|f) s\u2032 = f f \u2032 = f str\u2032 = \u2205\nend for return\nx\u22171:n = str( n 0S. \u2217), p(x\u22171:n|q\u03021:n,CSCFG) = \u03b3( n 0S. \u2217)\nwhere n 0S. \u2217 = argmax\n\u2200n0 S.\u2208\u03c8n \u03b3\n15"}, {"heading": "APPENDIX D PARAMETERS USED IN THE SIMULATIONS", "text": "Here, we give additional parameters used in our simulations. Lengths and angles of roads on roadmap in Fig. 1 are listed in Table V. Real time speeds of vehicular traffic moving on the roadmap in Fig. 1 are listed in Table VI.\n16\nTable VI REAL TIME AVERAGE SPEEDS (m/s) OF VEHICULAR TRAFFIC ON ROADMAP IN FIG. 1\nRoad Discrete Time Intervals0-100 101-200 201-300 301-400 401-500 501-600 601-700 701-800 801-900 901-1000 s0 10 14 8 10 5 12 14 10 7 10 s1 8 10 12 5 14 7 10 10 7 13 s2 10 7 10 14 10 5 13 14 10 10 s3 12 7 8 10 5 8 12 10 7 10 s4 6 13 8 10 10 10 12 10 7 10 s5 8 13 9 9 12 7 10 10 8 10 s6 10 13 9 9 12 7 7 10 8 10 s7 10 13 13 12 12 7 7 10 8 10 s8 8 10 12 7 12 12 7 12 8 12 s9 11 10 12 7 12 12 7 12 11 12 s10 11 12 10 7 10 11 8 10 10 12"}], "references": [{"title": "Ground target tracking with variable structure imm estimator,", "author": ["T. Kirubarajan", "Y. Bar-Shalom", "K.R. Pattipati", "I. Kadar"], "venue": "IEEE Transactions on Aerospace and Electronic Systems,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "The interacting multiple model algorithm for systems with markovian switching coefficients,", "author": ["H.A.P. Blom", "Y. Bar-Shalom"], "venue": "IEEE Transactions on Automatic Control,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1988}, {"title": "Intent inference and syntactic tracking with GMTI measurements,", "author": ["A. Wang", "V. Krishnamurthy", "B. Balaji"], "venue": "IEEE Transactions on Aerospace and Electronic Systems,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "Detection of anomalous trajectory patterns in target tracking via stochastic context-free grammars and reciprocal process models,", "author": ["M. Fanaswala", "V. Krishnamurthy"], "venue": "IEEE Journal of Selected Topics in Signal Processing,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Spatiotemporal trajectory models for metalevel target tracking,", "author": ["M. Fanaswala", "V. Krishnamurthy"], "venue": "IEEE Aerospace and Electronic Systems Magazine,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "and U", "author": ["K.E. Mark", "M.I. Miller"], "venue": "Grenander, \u201cConstrained stochastic language models,\u201d in Image Models ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1996}, {"title": "The theory of parsing", "author": ["A.V. Aho", "J.D. Ullman"], "venue": "translation and compiling. Englewood Cliffs, NJ,USA: Prentice-Hall", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1972}, {"title": "An efficient probabilistic context-free parsing algorithm that computes prefix probabilities,", "author": ["A. Stolcke"], "venue": "Computational linguistics,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1995}], "referenceMentions": [{"referenceID": 0, "context": "Classical (base-level) tracking algorithms have been well studied in the literature [1] [2].", "startOffset": 84, "endOffset": 87}, {"referenceID": 1, "context": "Classical (base-level) tracking algorithms have been well studied in the literature [1] [2].", "startOffset": 88, "endOffset": 91}, {"referenceID": 2, "context": "(ii) the direction based syntactic tracker proposed in earlier works [3] [4] [5].", "startOffset": 69, "endOffset": 72}, {"referenceID": 3, "context": "(ii) the direction based syntactic tracker proposed in earlier works [3] [4] [5].", "startOffset": 73, "endOffset": 76}, {"referenceID": 4, "context": "(ii) the direction based syntactic tracker proposed in earlier works [3] [4] [5].", "startOffset": 77, "endOffset": 80}, {"referenceID": 2, "context": "The direction based syntactic tracker in previous works [3] [4] [5] was used to classify shapes (lines, arcs or m-rectangles) of trajectories.", "startOffset": 56, "endOffset": 59}, {"referenceID": 3, "context": "The direction based syntactic tracker in previous works [3] [4] [5] was used to classify shapes (lines, arcs or m-rectangles) of trajectories.", "startOffset": 60, "endOffset": 63}, {"referenceID": 4, "context": "The direction based syntactic tracker in previous works [3] [4] [5] was used to classify shapes (lines, arcs or m-rectangles) of trajectories.", "startOffset": 64, "endOffset": 67}, {"referenceID": 5, "context": ", qk) is a combination of a SCFG and a Markov chain which is equivalent to a CSCFG; see [6].", "startOffset": 88, "endOffset": 91}, {"referenceID": 0, "context": "To give further insight, we also present the classical VSIMM tracker [1] [2] which is widely used for baseline target tracking.", "startOffset": 69, "endOffset": 72}, {"referenceID": 1, "context": "To give further insight, we also present the classical VSIMM tracker [1] [2] which is widely used for baseline target tracking.", "startOffset": 73, "endOffset": 76}, {"referenceID": 2, "context": "Direction based syntactic tracker (previous works [3] [4] [5])", "startOffset": 50, "endOffset": 53}, {"referenceID": 3, "context": "Direction based syntactic tracker (previous works [3] [4] [5])", "startOffset": 54, "endOffset": 57}, {"referenceID": 4, "context": "Direction based syntactic tracker (previous works [3] [4] [5])", "startOffset": 58, "endOffset": 61}, {"referenceID": 0, "context": "Baseline VSIMM tracker (see [1] [2])", "startOffset": 28, "endOffset": 31}, {"referenceID": 1, "context": "Baseline VSIMM tracker (see [1] [2])", "startOffset": 32, "endOffset": 35}, {"referenceID": 6, "context": "To put this paper into context, we first recall the Chomsky hierarchy of natural languages [7].", "startOffset": 91, "endOffset": 94}, {"referenceID": 5, "context": "\u2022 In the stochastic case [6]:", "startOffset": 25, "endOffset": 28}, {"referenceID": 3, "context": "Why syntactic models for target tracking? As described in [4], [5], syntactic models arising in natural language processing such as SCFG and CSCFG are suitable for meta-level tracking since they form generative models for complex spatial trajectories of a target.", "startOffset": 58, "endOffset": 61}, {"referenceID": 4, "context": "Why syntactic models for target tracking? As described in [4], [5], syntactic models arising in natural language processing such as SCFG and CSCFG are suitable for meta-level tracking since they form generative models for complex spatial trajectories of a target.", "startOffset": 63, "endOffset": 66}, {"referenceID": 0, "context": "P : R \u2192 [0, 1] is a probability", "startOffset": 8, "endOffset": 14}, {"referenceID": 7, "context": "Starting from S, replace the leftmost nonterminal (such deviations can be represented as a parse tree [8]) according to the production rules in R and probabilities in P , the output of a CSCFG is a string of terminals.", "startOffset": 102, "endOffset": 105}, {"referenceID": 6, "context": "It can be verified via a pumping lemma [7] that a Markov chain is not a generative model for an arc since the integer m has an arbitrary (random) value.", "startOffset": 39, "endOffset": 42}, {"referenceID": 5, "context": "We refer to [6] for a detailed discussion of CSCFGs.", "startOffset": 12, "endOffset": 15}, {"referenceID": 3, "context": "It can be shown [4] that a generative model for L r0:3 and L cs r0:4 is a context sensitive grammar.", "startOffset": 16, "endOffset": 19}, {"referenceID": 4, "context": "These examples generalize our earlier work [5] where SCFGs were used.", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "We also evaluate the performance of the baseline VSIMM tracker (proposed in [1] [2]) for comparison.", "startOffset": 76, "endOffset": 79}, {"referenceID": 1, "context": "We also evaluate the performance of the baseline VSIMM tracker (proposed in [1] [2]) for comparison.", "startOffset": 80, "endOffset": 83}], "year": 2016, "abstractText": "The aim of syntactic tracking is to classify spatiotemporal patterns of a target\u2019s motion using natural language processing models. In this paper, we generalize earlier work by considering a constrained stochastic context free grammar (CSCFG) for modeling patterns confined to a roadmap. The constrained grammar facilitates modeling specific directions and road names in a roadmap. We present a novel particle filtering algorithm that exploits the CSCFG model for estimating the target\u2019s patterns. This meta-level algorithm operates in conjunction with a base-level tracking algorithm. Extensive numerical results using simulated ground moving target indicator (GMTI) radar measurements show substantial improvement in target tracking accuracy.", "creator": "LaTeX with hyperref package"}}}