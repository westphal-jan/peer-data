{"id": "1702.03274", "review": {"conference": "ACL", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Feb-2017", "title": "Hybrid Code Networks: practical and efficient end-to-end dialog control with supervised and reinforcement learning", "abstract": "confict End - arterial to - aaronsohn end gracht learning lotter of recurrent neural networks (RNNs) uf6 is md an khalib attractive solution mefistofele for tgvs dialog systems; prenatally however, r\u00e9gional current brackish techniques leibovich are data - 257.1 intensive supertankers and cochin require mitvol thousands shipyard of dialogs to akmal learn simple sandbrook behaviors. pashupatinath We karakuri introduce bionicle Hybrid avidyne Code folkerts Networks (HCNs ), which combine an mixology RNN with ka-shing domain - tokic specific majdalawi knowledge debrief encoded perseverance as software and system arhuaco action templates. Compared agey to 8-way existing end - dosb to - moulins end conquered approaches, HCNs eastney considerably camargue reduce the 3,852 amount of training neuner data required, while retaining the key amenia benefit of inferring phantasm a cahow latent representation of surdas dialog magyar state. In soro addition, informateur HCNs thigpen can be s-10 optimized 220-pound with square-shaped supervised pahapill learning, isn reinforcement learning, yamaoka or a stratevest mixture bleed of alven both. unger HCNs 23-footer attain state - welson of - the - www.nbc.com art performance incentivise on the farkhad bAbI remixing dialog lud\u011bk dataset, weerakkody and seniornet outperform caraballo two conjugal commercially ursule deployed us-mexico customer - facing dialog systems.", "histories": [["v1", "Fri, 10 Feb 2017 18:24:13 GMT  (1499kb,D)", "http://arxiv.org/abs/1702.03274v1", null], ["v2", "Mon, 24 Apr 2017 14:39:27 GMT  (1500kb,D)", "http://arxiv.org/abs/1702.03274v2", "Accepted as a long paper for the 55th Annual Meeting of the Association for Computational Linguistics (ACL 2017)"]], "reviews": [], "SUBJECTS": "cs.AI cs.CL", "authors": ["jason d williams", "kavosh asadi", "geoffrey zweig"], "accepted": true, "id": "1702.03274"}, "pdf": {"name": "1702.03274.pdf", "metadata": {"source": "CRF", "title": "Hybrid Code Networks: practical and efficient end-to-end dialog control with supervised and reinforcement learning", "authors": ["Jason D. Williams", "Kavosh Asadi", "Geoffrey Zweig"], "emails": ["jason.williams@microsoft.com", "kavosh@brown.edu", "g2zweig@gmail.com"], "sections": [{"heading": "1 Introduction", "text": "Task-oriented dialog systems help a user to accomplish some goal using natural language, such as making a restaurant reservation, getting technical support, or placing a phonecall. Historically, these dialog systems have been built as a pipeline, with modules for language understanding, state tracking, action selection, and language generation. However, dependencies between modules introduce considerable complexity \u2013 for example, it is often unclear how to define the dialog state and what history to maintain, yet action selection relies exclusively on the state for input. Moreover, training each module requires specialized labels.\n\u2217Currently at JPMorgan Chase\nRecently, end-to-end approaches have trained recurrent neural networks (RNNs) directly on text transcripts of dialogs. A key benefit is that the RNN infers a latent representation of state, obviating the need for state labels. However, end-to-end methods lack a general mechanism for injecting domain knowledge and constraints. For example, simple operations like sorting a list of database results or updating a dictionary of entities can expressed in a few lines of software, yet may take thousands of dialogs to learn. Moreover, in some practical settings, programmed constraints are essential \u2013 for example, a banking dialog system would require that a user is logged in before they can retrieve account information.\nThis paper presents a model for end-to-end learning, called Hybrid Code Networks (HCNs) which addresses these problems. In addition to learning an RNN, HCNs also allow a developer to express domain knowledge via software and action templates. Experiments show that, compared to existing recurrent end-to-end techniques, HCNs achieve the same performance with considerably less training data, while retaining the key benefit of end-to-end trainability. Moreover, the neural network can be trained with supervised learning or reinforcement learning, by changing the gradient update applied.\nThis paper is organized as follows. Section 2 describes the model, and Section 3 compares the model to related work. Section 4 applies HCNs to the bAbI dialog dataset (Bordes and Weston, 2016). Section 5 then applies the method to real customer support domains at our company. Section 6 illustrates how HCNs can be optimized with reinforcement learning, and Section 7 concludes.\nar X\niv :1\n70 2.\n03 27\n4v 1\n[ cs\n.A I]\n1 0\nFe b\n20 17"}, {"heading": "2 Model description", "text": "At a high level, the four components of a Hybrid Code Network are a recurrent neural network; domain-specific software; domain-specific action templates; and a conventional entity extraction module for identifying entity mentions in text. Both the RNN and the developer code maintain state. Each action template can be a textual communicative action or an API call. The HCN model is summarized in Figure 1.\nThe cycle begins when the user provides an utterance, as text (step 1). The utterance is featurized in several ways. First, a bag of words vector is formed (step 2). Second, an utterance embedding is formed, using a pre-built utterance embedding model (step 3). Third, an entity extraction module identifies entity mentions (step 4) \u2013 for example, identifying \u201cJennifer Jones\u201d as a <name> entity. The text and entity mentions are then passed to \u201cEntity tracking\u201d code provided by the developer (step 5), which grounds and maintains entities \u2013 for example, mapping the text \u201cJennifer Jones\u201d to a specific row in a database. This code can optionally return an \u201caction mask\u201d, indicating actions which are permitted at the current timestep, as a bit vector. For example, if a target phone number has not yet been identified, the API action to place a phone call may be masked. It can also optionally return \u201ccontext features\u201d which are features the developer thinks will be useful for distinguish-\ning among actions, such as which entities are currently present and which are absent.\nThe feature components from steps 1-5 are concatenated to form a feature vector (step 6). This vector is passed to an RNN, such as a long shortterm memory (LSTM) (Hochreiter and Schmidhuber, 1997) or gated recurrent unit (GRU) (Chung et al., 2014). The RNN computes a hidden state (vector), which is retained for the next timestep (step 8), and passed to a dense layer with a softmax activation, with output dimension equal to the number of distinct system action templates (step 9).1 Thus the output of step 9 is a distribution over action templates. Next, the action mask is applied as an element-wise multiplication, and the result is normalized back to a probability distribution (step 10) \u2013 this forces non-permitted actions to take on probability zero. From the resulting distribution (step 11), an action is selected (step 12). When RL is active, exploration is required, so in this case an action is sampled from the distribution; when RL is not active, the best action should be chosen, and so the action with the highest probability is always selected.\nThe selected action is next passed to \u201cEntity output\u201d developer code that can substitute in entities (step 13) and produce a fully-formed action \u2013 for example, mapping the template \u201c<city>,\n1Implementation details for the RNN such as size, loss, etc. are given with each experiment in Sections 4-6.\nright?\u201d to \u201cSeattle, right?\u201d. In step 14, control branches depending on the type of the action: if it is an API action, the corresponding API call in the developer code is invoked (step 15) \u2013 for example, to render rich content to the user. APIs can act as sensors and return features relevant to the dialog, so these can be added to the feature vector in the next timestep (step 16). If the action is text, it is rendered to the user (step 17), and cycle then repeats. The action taken is provided as a feature to the RNN in the next timestep (step 18)."}, {"heading": "3 Related work", "text": "Broadly there are two lines of work applying machine learning to dialog control. The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014). Specifically related to HCNs, past work has implemented the policy as feed-forward neural networks (Wen et al., 2016), trained with supervised learning followed by reinforcement learning (Su et al., 2016). In these works, the policy has not been recurrent \u2013 i.e., the policy depends on the state tracker to summarize observable dialog history into state features, which requires design and specialized labeling. By contrast, HCNs use an RNN which automatically infers a representation of state. For learning efficiency, HCNs use an external lightweight process for tracking entity values, but the policy is not strictly dependent on it: as an illustration, in Section 5 below, we demonstrate an HCNbased dialog system which has no external state tracker. If there is context which is not apparent in the text in the dialog, such as database status, this can be encoded as a context feature to the RNN.\nThe second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017). These systems can be applied to task-oriented domains by adding special \u201cAPI call\u201d actions, enumerating\ndatabase output as a sequence of tokens (Bordes and Weston, 2016), then learning an RNN using Memory Networks (Sukhbaatar et al., 2015), gated memory networks (Liu and Perez, 2016), query reduction networks (Seo et al., 2016), and copyaugmented networks (Eric and Manning, 2017). In each of these architectures, the RNN learns to manipulate entity values, for example by saving them in a memory. Output is produced by generating a sequence of tokens (or ranking all possible surface forms), which can also draw from this memory. HCNs also use an RNN to accumulate dialog state and choose actions. However, HCNs differ in that they use developer-provided action templates, which can contain entity references, such as \u201c<city>, right?\u201d. This design reduce learning complexity, and also enable the software to limit which actions are available via an action mask, at the expense of developer effort. To further reduce learning complexity in a practical system, entities are tracked separately, outside the the RNN, which also allows them to be substituted into action templates. Also, past end-to-end recurrent models have been trained using supervised learning, whereas we show how HCNs can also be trained with reinforcement learning."}, {"heading": "4 Supervised learning evaluation I", "text": "In this section we compare HCNs to existing approaches on the public \u201cbAbI dialog\u201d dataset (Bordes and Weston, 2016). This dataset includes two end-to-end dialog learning tasks, in the restaurant domain, called task5 and task6.2 Task5 consists of synthetic, simulated dialog data, with highly regular user behavior and constrained vocabulary. Dialogs include a database access action which retrieves relevant restaurants from a database, with results included in the dialog transcript. We test on the \u201cOOV\u201d variant of Task5, which includes entity values not observed in the training set. Task6 draws on human-computer dialog data from the second dialog state tracking challenge (DSTC2), where usability subjects (crowd-workers) interacted with several variants of a spoken dialog system (Henderson et al., 2014). Since the database from DSTC2 was not provided, database calls have been inferred from the data and inserted into the dialog transcript. Example dialogs are provided in the Appendix Sections A.2 and A.3.\nTo apply HCNs, we wrote simple domain2Tasks 1-4 are sub-tasks of Task5.\nspecific software, as follows. First, for entity extraction (step 3 in Figure 1), we used a simple string match, with a pre-defined list of entity names \u2013 i.e., the list of restaurants available in the database. Second, in the context update (step 4), we created simple rules for tracking entities, where entities recognized in the input overwrite the existing entries. Third, system actions were templatized: for example, system actions of the form \u201cprezzo is a nice restaurant in the west of town in the moderate price range\u201d all map to the template \u201c<name> is a nice restaurant in the <location> of town in the <price> price range\u201d. This results in 16 templates for Task5 and 58 for Task6.3 Fourth, when database results are received into the entity state, they sorted by rating. Finally, an action mask was created which encoded common-sense dependencies: for example, only allow an API call if pre-conditions are met; only offer a restaurant if database results have already been received; do not ask for an entity if it is already known; etc.\nFor Task6, we noticed that the system can say that no restaurants match the current query without consulting the database (for an example dialog, see Section A.3 in the Appendix). In a practical system this information would be retrieved from the database and not encoded in the RNN. So, we mined the training data and built a table of search queries known to yield no results. We also added context features that indicated the state of the database \u2013 for example, whether there were any restaurants matching the current query. The complete set of context features is given in Appendix Section A.4. Altogether this code consisted of about 250 lines of Python.\nWe then trained an HCN on the training set, employing the domain-specific software described above. We selected an LSTM for the recurrent layer (Hochreiter and Schmidhuber, 1997), with the AdaDelta optimizer (Zeiler, 2012). We used the development set to tune the number of hidden units (128), and the number of epochs (12). Utterance embeddings were formed by averaging word embeddings, using a publicly available 300- dimensional word embedding model trained using word2vec on web data (Mikolov et al., 2013).4\n3A handful of actions in Task6 seemed spurious; for these, we replaced them with a special \u201cUNK\u201d action in the training set, and masked this action at test time.\n4Google News 100B model from https://github. com/3Top/word2vec-api\nThe word embeddings were static and not updated during LSTM training. In training, each dialog formed one minibatch, and updates were done on full rollouts (i.e., non-truncated back propagation through time). The training loss was categorical cross-entropy. Further low-level implementation details are in the Appendix Section A.1.\nWe ran experiments with four variants of our model: with and without the utterance embeddings, and with and without the action mask (Figure 1, steps 2 and 5 respectively).\nFollowing past work, we report average turn accuracy \u2013 i.e., for each turn in each dialog, present the (true) history of user and system actions to the network and obtain the network\u2019s prediction as a string of characters. The turn is correct if the string matches the reference exactly, and incorrect if not. We also report dialog accuracy, which indicates if all turns in a dialog are correct.\nWe compare to four past end-to-end approaches (Bordes and Weston, 2016; Liu and Perez, 2016; Eric and Manning, 2017; Seo et al., 2016). We emphasize that past approaches have applied purely sequence-to-sequence models, or (as a baseline) purely programmed rules (Bordes and Weston, 2016). By contrast, Hybrid Code Networks are a hybrid of hand-coded rules and learned models.\nResults are shown in Table 1. Since Task5 is synthetic data generated using rules, it is possible to obtain perfect accuracy using rules (line 1). The addition of domain knowledge greatly simplifies the learning task and enables HCNs to also attain perfect accuracy. On Task6, rules alone fare poorly, whereas HCNs outperform past learned models.\nWe next examined learning curves, training with increasing numbers of dialogs. To guard against bias in the ordering of the training set, we averaged over 5 runs, randomly permuting the order of the training dialogs in each run. Results are in Figure 2. In Task5, the action mask and utterance embeddings substantially reduce the number of training dialogs required (note the horizontal axis scale is logarithmic). For Task6, the benefits of the utterance embeddings are less clear. An error analysis showed that there are several systematic differences between the training and testing sets. Indeed, DSTC2 intentionally used different dialog policies for the training and test sets, whereas our goal is to mimic the policy in the training set.\nNonetheless, these tasks are the best public benchmark we are aware of, and HCNs exceed performance of existing sequence-to-sequence models. In addition, they match performance of past models using an order of magnitude less data (200 vs. 1618 dialogs), which is crucial in practical settings where collecting realistic dialogs for a new domain can be expensive."}, {"heading": "5 Supervised learning evaluation II", "text": "We now turn to comparing with purely handcrafted approaches. To do this, we obtained logs from our company\u2019s text-based customer support dialog system, which uses a sophisticated rulebased dialog manager. Data from this system is attractive for evaluation because it is used by real\ncustomers \u2013 not usability subjects \u2013 and because its rule-based dialog manager was developed by customer support professionals at our company, and not the authors. This data is not publicly available, but we are unaware of suitable humancomputer dialog data in the public domain which uses rules.\nCustomers start using the dialog system by entering a brief description of their problem, such as \u201cI need to update my operating system\u201d. They are then routed to one of several hundred domains, where each domain attempts to resolve a particular problem. In this study, we collected humancomputer transcripts for the high-traffic domains \u201creset password\u201d and \u201ccannot access account\u201d.\nWe labeled the dialog data as follows. First,\nwe enumerated unique system actions observed in the data. Then, for each dialog, starting from the beginning, we examined each system action, and determined whether it was \u201ccorrect\u201d. Here, correct means that it was the most appropriate action among the set of existing system actions, given the history of that dialog. If multiple actions were arguably appropriate, we broke ties in favor of the existing rule-based dialog manager. Example dialogs are provided in the Appendix Sections A.5 and A.6.\nIf a system action was labeled as correct, we left it as-is and continued to the next system action. If the system action was not correct, we replaced it with the correct system action, and discarded the rest of the dialog, since we do not know how the user would have replied to this new system action. The resulting dataset contained a mixture of complete and partial dialogs, containing only correct system actions. We partitioned this set into training and test dialogs. Basic statistics of the data are shown in Table 2.\nIn this domain, no entities were relevant to the control flow, and there was no obvious mask logic since any question could follow any question. Therefore, we wrote no domain-specific software for this instance of the HCN, and relied purely on the recurrent neural network to drive the conversation. The architecture and training of the RNN was the same as in Section 4, except that here we did not have enough data for a validation set, so we instead trained until we either achieved 100% accuracy on the training set or reached 200 epochs.\nTo evaluate, we observe that conventional measures like average dialog or turn accuracy penalize the rule-based system unfairly, since when the rule-based system makes an error in turn t, the HCN is only evaluated on the subsequence ending at turn t. We therefore use a comparative measure that examines which method produces longer continuous sequences of correct system actions, starting from the beginning of the dialog. Specifically, we report \u2206P = C(HCN-win)\u2212C(rule-win)C(all) , where C(HCN-win) is the number of test dialogs where the rule-based approach output a wrong action before the HCN;C(rule-win) is the number of test dialogs where the HCN output a wrong action before the rule-based approach; and C(all) is the number of dialogs in the test set. When \u2206P > 0, HCNs more often produce continuous sequences of correct actions starting from the beginning of\nthe dialog. We run all experiments 5 times, each time shuffling the order of the training set. Results are in Figure 3. HCNs exceed performance of the existing rule-based system after about 30 dialogs.\nIn these domains, we have a further source of knowledge: the rule-based dialog managers themselves can be used to generate example \u201csunnyday\u201d dialogs, where the user provides purely expected inputs. From each rule-based controller, synthetic dialogs were sampled to cover each expected user response at least once, and added to the set of labeled real dialogs. This resulted in 75 dialogs for the \u201cForgot password\u201d domain, and 325 for the \u201cCan\u2019t access account\u201d domain. Training was repeated as described above. Results are also included in Figure 3, with the suffix \u201csampled\u201d. In the \u201cCan\u2019t access account\u201d domain, the sampled dialogs yield a large improvement, probably because the flow chart for this domain is large, so the sampled dialogs increase coverage. The gain in the \u201cforgot password\u201d domain is present but smaller.\nIn summary, HCNs can out-perform production-grade rule-based systems with a reasonable number of labeled dialogs, and adding synthetic \u201csunny-day\u201d dialogs improves performance further. Moreover, unlike existing pipelined approaches to dialog management that rely on an explicit state tracker, this HCN used no explicit state tracker, highlighting an advantage of the model."}, {"heading": "6 Reinforcement learning illustration", "text": "In the previous sections, supervised learning (SL) was applied to train the LSTM to mimic dialogs provided by the system developer. Once a system operates at scale, interacting with a large number\n\u0394P\nof users, it is desirable for the system to continue to learn autonomously using reinforcement learning (RL). With RL, each turn receives a measurement of goodness called a reward; the agent explores different sequences of actions in different situations, and makes adjustments so as to maximize the expected discounted sum of rewards, which is called the return, denoted G.\nFor optimization, we selected a policy gradient approach (Williams, 1992), which has been successfully applied to dialog systems (Jurc\u030c\u0131\u0301c\u030cek et al., 2011), robotics (Kohl and Stone, 2004), and the board game Go (Silver et al., 2016). In policy gradient-based RL, a model \u03c0 is parameterized by w and outputs a distribution from which actions are sampled at each timestep. At the end of a dialog, the return G for that dialog is computed, and the gradients of the probabilities of the actions taken with respect to the model weights are computed. The weights are then adjusted by taking a gradient step proportional to the return:\nw\u2190 w+\u03b1( \u2211 t Ow log \u03c0(at|ht;w))(G\u2212b) (1)\nwhere \u03b1 is a learning rate; at is the action taken at timestep t; ht is the dialog history at time t; G is the return of the dialog; OxF denotes the Jacobian of F with respect to x; b is a baseline described below; and \u03c0(a|h;w) is the LSTM \u2013 i.e., a stochastic policy which outputs a distribution over a given a dialog history h, parameterized by weights w. The baseline b is an estimate of the average return of the current policy, estimated on the last 100 dialogs using weighted importance sampling.5 Intuitively, \u201cbetter\u201d dialogs receive a positive gradient\n5The choice of baseline does not affect the long-term convergence of the algorithm (i.e., the bias), but can dramatically affect the speed of convergence (i.e., the variance) (Williams, 1992).\nstep, making the actions selected more likely; and \u201cworse\u201d dialogs receive a negative gradient step, making the actions selected less likely.\nSL and RL correspond to different methods of updating weights, so both can be applied to the same network. However, there is no guarantee that the optimal RL policy will agree with the SL training set; therefore, after each RL gradient step, we check whether the updated policy reconstructs the training set. If not, we re-run SL gradient steps on the training set until the model reproduces the training set. Note that this approach allows new training dialogs to be added at any time during RL optimization.\nWe illustrate RL optimization on a simulated dialog task in the name dialing domain. In this system, a contact\u2019s name may have synonyms (\u201cMichael\u201d may also be called \u201cMike\u201d), and a contact may have more than one phone number, such as \u201cwork\u201d or \u201cmobile\u201d, which may in turn have synonyms like \u201ccell\u201d for \u201cmobile\u201d. This domain has a database of names and phone numbers, 5 entities, and 14 actions, including 2 API call actions. Simple entity logic was coded, which retains the most recent copy of recognized entities. A simple action mask suppresses impossible actions, such as placing a phonecall before a phone number has been retrieved from the database. Example dialogs are provided in Appendix Section A.7.\nTo perform optimization, we created a simulated user. At the start of a dialog, the simulated user randomly selected a name and phone type, including names and phone types not covered by the dialog system. When speaking, the simulated user can use the canonical name or a nickname; usually answers questions but can ignore the system; can provide additional information not requested; and can give up. The simulated user was parameterized by around 10 probabilities, set by hand.\nWe defined the reward as being 1 for successfully completing the task, and 0 otherwise. A discount of 0.95 was used to incentivize the system to complete dialogs faster rather than slower, yielding return 0 for failed dialogs, and G = 0.95T\u22121 for successful dialogs, where T is the number of system turns in the dialog. Finally, we created a set of 21 labeled dialogs, which will be used for supervised learning.\nFor the RNN in the HCN, we again used an LSTM with AdaDelta, this time with 32 hidden units. RL policy updates are made after each dia-\nlog. Since a simulated user was employed, we did not have real user utterances, and instead relied on context features, omitting bag-of-words and utterance embedding features.\nWe first evaluate RL by randomly initializing an LSTM, and begin RL optimization. After 10 RL updates, we freeze the policy, and run 500 dialogs with the user simulation to measure task completion. We repeat all of this for 100 runs, and report average performance. In addition, we also report results by initializing the LSTM using supervised learning on the training set, consisting of 1, 2, 5, or 10 dialogs sampled randomly from the training set, then running RL as described above.\nResults are in Figure 4. Although RL alone can find a good policy, pre-training with just a handful of labeled dialogs improves learning speed dramatically. Additional experiments, not shown for space, found that ablating the action mask slowed training, agreeing with Williams (2008).\nFinally, we conduct a further experiment where we sample 10 training dialogs, then add one to the training set just before RL dialog 0, 100, 200, ... , 900. Results are shown in Figure 4. This shows that SL dialogs can be introduced as RL is in progress \u2013 i.e., that it is possible to interleave RL and SL. This is an attractive property for practical systems: if a dialog error is spotted by a developer while RL is in progress, it is natural to add a training dialog to the training set."}, {"heading": "7 Conclusion", "text": "This paper has introduced Hybrid Code Networks for end-to-end learning of task-oriented dialog systems. HCNs support a separation of concerns where procedural knowledge and constraints can be expressed in software, and the control flow is learned. Compared to existing end-to-end approaches, HCNs afford more developer control and require less training data, at the expense of a small amount of developer effort.\nResults in this paper have explored three different dialog domains. On a public benchmark in the restaurants domain, HCNs exceeded performance of purely learned models. Results in two troubleshooting domains exceeded performance of a commercially deployed rule-based system. Finally, in a name-dialing domain, results from dialog simulation show that HCNs can also be optimized with a mixture of reinforcement and supervised learning."}, {"heading": "A Supplemental Material", "text": "A.1 Model implementation details The RNN was specified using Keras version 0.3.3, with back-end computation in Theano version 0.8.0.dev0 (Theano Development Team, 2016; Chollet, 2015). The Keras model specification is given below. The input variable obs includes all features from Figure 1 step 6 except for the previous action (step 13) and the action mask (step 5).\n# Given: # obs_size, action_size, nb_hidden\ng = Graph() g.add_input( name=\u2019obs\u2019, input_shape=(None, obs_size) ) g.add_input( name=\u2019prev_action\u2019, input_shape=(None, action_size) ) g.add_input( name=\u2019avail_actions\u2019, input_shape=(None, action_size) ) g.add_node( LSTM(\nn_hidden, return_sequences=True, activation=\u2019tanh\u2019,\n), name=\u2019h1\u2019, inputs=[\n\u2019obs\u2019, \u2019prev_action\u2019, \u2019avail_actions\u2019\n] ) g.add_node( TimeDistributedDense(\naction_size,\nactivation=\u2019softmax\u2019, ), name=\u2019h2\u2019, input=\u2019h1\u2019\n) g.add_node(\nActivation( activation=normalize, ), name=\u2019action\u2019, inputs=[\u2019h2\u2019,\u2019avail_actions\u2019], merge_mode=\u2019mul\u2019, create_output=True\n) g.compile(\noptimizer=Adadelta(clipnorm=1.), sample_weight_modes={ \u2019action\u2019: \u2019temporal\u2019 }, loss={ \u2019action\u2019:\u2019categorical_crossentropy\u2019\n} )\nModel sizes are given in Table 3. Example dialogs are given below for each of the 5 dialog systems. For space and readability, the entity tags that appear in the user and system sides of the dialogs have been removed \u2013 for example, Call <name>Joan</name> is shown as Call Joan.\nA.2 bAbI Task5 example dialog\ngood morning hello what can i help you with today i\u2019d like to book a table with italian food i\u2019m on it [silence] where should it be in paris how many people would be in your party for six people please which price range are looking for in a cheap price range please ok let me look into some options for you [silence] api_call italian paris six cheap [database results returned] [silence] what do you think of this option: resto madrid cheap spanish 8stars no this does not work for me sure let me find an other option for you [silence] what do you think of this option: resto madrid cheap spanish 6stars do you have something else sure let me find an other option for you [silence] what do you think of this option: resto madrid cheap spanish 1stars it\u2019s perfect great let me do the reservation may i have the phone number of the restaurant here it is resto madrid cheap spanish 1stars phone\nthanks is there anything i can help you with no thank you you\u2019re welcome\nA.3 bAbI Task6 example dialog\nIn the system turn marked [*], the system provided venue information without first making an API call.\nHello , welcome to the Cambridge restaurant system . You can ask for restaurants by area , price range or food type . How may I help you ? im looking for canapes food in any price range I am sorry but there is no canapes restaurant that matches your request [*] how about european api_call european R_location R_price [database results returned] [silence] michaelhouse cafe is a great restaurant serving european food and it is in the expensive price range food an What part of town do you have in mind? any any part of town michaelhouse cafe serves european food . may i have the address and phone number please The phone number of michaelhouse cafe is michaelhouse cafe phone thank you good bye you are welcome\nA.4 Task5 and Task6 context features\nContext features used in Section 4 are in Table 4.\nA.5 Forgot password example dialog\nSome system actions have been shortened for space.\nHow do I recover my password Okay, you don\u2019t need to remember your password, we can reset it. Would you like to try that? Yes To reset your password, please see this URL ... Was that helpful? I don\u2019t have a flashdrive Let\u2019s connect you to a person who can help you\nA.6 Account access example dialog\nSome system actions have been shortened for space.\ncannot sign in to my email Please check caps lock is off, and that your email is spelled correctly. Are you able to access your account now?\nbAbI Task5 bAbI Task6 Reset password Account access Dialer Utterance embed. 300 300 300 300 0 Bag of words 85 523 1124 278 0 Context features 4 14 0 0 17\nobs_size 389 837 1424 578 17 action_size 16 58 7 16 14 nb_hidden 128 128 128 128 32\nA.7 Name dialing example dialogs\nHow can I help you? Call Joe There\u2019s more than one person named Joe. Can you say their full name? Call Joe Adamson SavePhonetypeavail() Calling Joe Adamson, work"}], "references": [{"title": "Learning end-to-end goal-oriented dialog", "author": ["Antoine Bordes", "Jason Weston."], "venue": "CoRR abs/1605.07683. http://arxiv.org/abs/1605.07683.", "citeRegEx": "Bordes and Weston.,? 2016", "shortCiteRegEx": "Bordes and Weston.", "year": 2016}, {"title": "Keras", "author": ["Franois Chollet."], "venue": "https://github. com/fchollet/keras.", "citeRegEx": "Chollet.,? 2015", "shortCiteRegEx": "Chollet.", "year": 2015}, {"title": "Empirical evaluation of gated recurrent neural networks on sequence modeling", "author": ["Junyoung Chung", "Caglar Gulcehre", "KyungHyun Cho", "Yoshua Bengio."], "venue": "Proc NIPS 2014 Deep Learning and Representation Learning Workshop.", "citeRegEx": "Chung et al\\.,? 2014", "shortCiteRegEx": "Chung et al\\.", "year": 2014}, {"title": "A copy-augmented sequence-to-sequence architecture gives good performance on taskoriented dialogue", "author": ["Mihail Eric", "Christopher D Manning."], "venue": "CoRR abs/1701.04024. https://arxiv.org/abs/1701.04024.", "citeRegEx": "Eric and Manning.,? 2017", "shortCiteRegEx": "Eric and Manning.", "year": 2017}, {"title": "A statistical approach to spoken dialog systems design and evaluation", "author": ["David Griol", "Llus F. Hurtado", "Encarna Segarra", "Emilio Sanchis."], "venue": "Speech Communication 50(8\u20139).", "citeRegEx": "Griol et al\\.,? 2008", "shortCiteRegEx": "Griol et al\\.", "year": 2008}, {"title": "The second dialog state tracking challenge", "author": ["Matthew Henderson", "Blaise Thomson", "Jason Williams."], "venue": "Proc SIGdial Workshop on Discourse and Dialogue, Philadelphia, USA.", "citeRegEx": "Henderson et al\\.,? 2014", "shortCiteRegEx": "Henderson et al\\.", "year": 2014}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "Jurgen Schmidhuber."], "venue": "Neural Computation 9(8):1735\u20131780.", "citeRegEx": "Hochreiter and Schmidhuber.,? 1997", "shortCiteRegEx": "Hochreiter and Schmidhuber.", "year": 1997}, {"title": "Statistical dialog management applied to WFSTbased dialog systems", "author": ["Chiori Hori", "Kiyonori Ohtake", "Teruhisa Misu", "Hideki Kashioka", "Satoshi Nakamura."], "venue": "Acoustics, Speech and Signal Processing, 2009. ICASSP 2009. IEEE", "citeRegEx": "Hori et al\\.,? 2009", "shortCiteRegEx": "Hori et al\\.", "year": 2009}, {"title": "Natural actor and belief critic: Reinforcement algorithm for learning parameters of dialogue systems modelled as pomdps", "author": ["Filip Jur\u010d\u0131\u0301\u010dek", "Blaise Thomson", "Steve Young"], "venue": "ACM Transactions on Speech and Language Processing", "citeRegEx": "Jur\u010d\u0131\u0301\u010dek et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Jur\u010d\u0131\u0301\u010dek et al\\.", "year": 2011}, {"title": "Policy gradient reinforcement learning for fast quadrupedal locomotion", "author": ["Nate Kohl", "Peter Stone."], "venue": "Robotics and Automation, 2004. Proceedings. ICRA\u201904. 2004 IEEE International Conference on. IEEE, volume 3, pages 2619\u20132624.", "citeRegEx": "Kohl and Stone.,? 2004", "shortCiteRegEx": "Kohl and Stone.", "year": 2004}, {"title": "Example-based dialog modeling for practical multi-domain dialog system", "author": ["Cheongjae Lee", "Sangkeun Jung", "Seokhwan Kim", "Gary Geunbae Lee."], "venue": "Speech Communication 51(5):466\u2013484.", "citeRegEx": "Lee et al\\.,? 2009", "shortCiteRegEx": "Lee et al\\.", "year": 2009}, {"title": "A stochastic model of human-machine interaction for learning dialogue strategies", "author": ["Esther Levin", "Roberto Pieraccini", "Wieland Eckert."], "venue": "IEEE Trans on Speech and Audio Processing 8(1):11\u201323.", "citeRegEx": "Levin et al\\.,? 2000", "shortCiteRegEx": "Levin et al\\.", "year": 2000}, {"title": "A diversity-promoting objective function for neural conversation models", "author": ["Jiwei Li", "Michel Galley", "Chris Brockett", "Jianfeng Gao", "Bill Dolan."], "venue": "Proc HLT-NAACL, San Diego, California, USA.", "citeRegEx": "Li et al\\.,? 2016a", "shortCiteRegEx": "Li et al\\.", "year": 2016}, {"title": "A persona-based neural conversation model", "author": ["Jiwei Li", "Michel Galley", "Chris Brockett", "Georgios Spithourakis", "Jianfeng Gao", "Bill Dolan."], "venue": "Proc Association for Computational Linguistics, Berlin, Germany.", "citeRegEx": "Li et al\\.,? 2016b", "shortCiteRegEx": "Li et al\\.", "year": 2016}, {"title": "Deep reinforcement learning for dialogue generation", "author": ["Jiwei Li", "Will Monroe", "Alan Ritter", "Michel Galley", "Jianfeng Gao", "Dan Jurafsky."], "venue": "Proc Conference on Empirical Methods in Natural Language Processing, Austin, Texas, USA.", "citeRegEx": "Li et al\\.,? 2016c", "shortCiteRegEx": "Li et al\\.", "year": 2016}, {"title": "Temporal supervised learning for inferring a dialog policy from example conversations", "author": ["Lihong Li", "He He", "Jason D. Williams."], "venue": "Proc IEEE Workshop on Spoken Language Technologies (SLT), South Lake Tahoe, Nevada, USA.", "citeRegEx": "Li et al\\.,? 2014", "shortCiteRegEx": "Li et al\\.", "year": 2014}, {"title": "Gated end-toend memory networks", "author": ["Fei Liu", "Julien Perez."], "venue": "CoRR abs/1610.04211. http://arxiv.org/abs/1610.04211.", "citeRegEx": "Liu and Perez.,? 2016", "shortCiteRegEx": "Liu and Perez.", "year": 2016}, {"title": "Training end-to-end dialogue systems with the ubuntu dialogue corpus", "author": ["Ryan Thomas Lowe", "Nissan Pow", "Iulian Vlad Serban", "Laurent Charlin", "Chia-Wei Liu", "Joelle Pineau."], "venue": "Dialogue and Discourse 8(1).", "citeRegEx": "Lowe et al\\.,? 2017", "shortCiteRegEx": "Lowe et al\\.", "year": 2017}, {"title": "LSTM based conversation models", "author": ["Yi Luan", "Yangfeng Ji", "Mari Ostendorf."], "venue": "CoRR abs/1603.09457. http://arxiv.org/abs/1603.09457.", "citeRegEx": "Luan et al\\.,? 2016", "shortCiteRegEx": "Luan et al\\.", "year": 2016}, {"title": "Coherent dialogue with attentionbased language models", "author": ["Hongyuan Mei", "Mohit Bansal", "Matthew R. Walter."], "venue": "CoRR abs/1611.06997. http://arxiv.org/abs/1611.06997.", "citeRegEx": "Mei et al\\.,? 2016", "shortCiteRegEx": "Mei et al\\.", "year": 2016}, {"title": "Distributed representations of words and phrases and their compositionality", "author": ["Tomas Mikolov", "Ilya Sutskever", "Kai Chen", "Greg S Corrado", "Jeff Dean."], "venue": "Proc Advances in Neural Information Processing Systems, Lake Tahoe, USA. pages 3111\u2013", "citeRegEx": "Mikolov et al\\.,? 2013", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Query-regression networks for machine comprehension", "author": ["Min Joon Seo", "Hannaneh Hajishirzi", "Ali Farhadi."], "venue": "CoRR abs/1606.04582. http://arxiv.org/abs/1606.04582.", "citeRegEx": "Seo et al\\.,? 2016", "shortCiteRegEx": "Seo et al\\.", "year": 2016}, {"title": "Building end-to-end dialogue systems using generative hierarchical neural network models", "author": ["Iulian V. Serban", "Alessandro Sordoni", "Yoshua Bengio", "Aaron Courville", "Joelle Pineau."], "venue": "Proceedings of the Thirtieth AAAI Conference on Artificial Intel-", "citeRegEx": "Serban et al\\.,? 2016", "shortCiteRegEx": "Serban et al\\.", "year": 2016}, {"title": "A hierarchical latent variable encoder-decoder model for generating dialogues", "author": ["Iulian Vlad Serban", "Alessandro Sordoni", "Ryan Lowe", "Laurent Charlin", "Joelle Pineau", "Aaron Courville", "Yoshua Bengio"], "venue": null, "citeRegEx": "Serban et al\\.,? \\Q2017\\E", "shortCiteRegEx": "Serban et al\\.", "year": 2017}, {"title": "Neural responding machine for short-text conversation", "author": ["Lifeng Shang", "Zhengdong Lu", "Hang Li"], "venue": "In Proc Association for Computational Linguistics,", "citeRegEx": "Shang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Shang et al\\.", "year": 2015}, {"title": "Mastering the game of Go with deep neural networks and tree", "author": ["David Silver", "Aja Huang", "Chris J. Maddison", "Arthur Guez", "Laurent Sifre", "George Van Den Driessche", "Julian Schrittwieser", "Ioannis Antonoglou", "Veda Panneershelvam", "Marc Lanctot"], "venue": null, "citeRegEx": "Silver et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Silver et al\\.", "year": 2016}, {"title": "Optimizing dialogue management with reinforcement leaning: experiments with the NJFun system", "author": ["Satinder Singh", "Diane J Litman", "Michael Kearns", "Marilyn A Walker."], "venue": "Journal of Artificial Intelligence 16:105\u2013133.", "citeRegEx": "Singh et al\\.,? 2002", "shortCiteRegEx": "Singh et al\\.", "year": 2002}, {"title": "A neural network approach to context-sensitive generation of conversational responses", "author": ["Alessandro Sordoni", "Michel Galley", "Michael Auli", "Chris Brockett", "Yangfeng Ji", "Meg Mitchell", "Jian-Yun Nie", "Jianfeng Gao", "Bill Dolan."], "venue": "Proc HLT-NAACL,", "citeRegEx": "Sordoni et al\\.,? 2015", "shortCiteRegEx": "Sordoni et al\\.", "year": 2015}, {"title": "Continuously learning neural dialogue management", "author": ["Pei-Hao Su", "Milica Ga\u0161i\u0107", "Nikola Mrk\u0161i\u0107", "Lina RojasBarahona", "Stefan Ultes", "David Vandyke", "TsungHsien Wen", "Steve Young."], "venue": "arXiv preprint: 1606.02689.", "citeRegEx": "Su et al\\.,? 2016", "shortCiteRegEx": "Su et al\\.", "year": 2016}, {"title": "End-to-end memory networks", "author": ["Sainbayar Sukhbaatar", "Arthur Szlam", "Jason Weston", "Rob Fergus."], "venue": "Proc Advances in Neural Information Processing Systems (NIPS), Montreal, Canada.", "citeRegEx": "Sukhbaatar et al\\.,? 2015", "shortCiteRegEx": "Sukhbaatar et al\\.", "year": 2015}, {"title": "Theano: A Python framework for fast computation of mathematical expressions", "author": ["Theano Development Team."], "venue": "arXiv e-prints abs/1605.02688. http://arxiv.org/abs/1605.02688.", "citeRegEx": "Team.,? 2016", "shortCiteRegEx": "Team.", "year": 2016}, {"title": "A neural conversational model", "author": ["Oriol Vinyals", "Quoc Le."], "venue": "Proc ICML Deep Learning Workshop.", "citeRegEx": "Vinyals and Le.,? 2015", "shortCiteRegEx": "Vinyals and Le.", "year": 2015}, {"title": "A network-based end-to-end trainable taskoriented dialogue system", "author": ["Tsung-Hsien Wen", "Milica Gasic", "Nikola Mrksic", "Lina Maria Rojas-Barahona", "Pei-Hao Su", "Stefan Ultes", "David Vandyke", "Steve J. Young."], "venue": "CoRR abs/1604.04562.", "citeRegEx": "Wen et al\\.,? 2016", "shortCiteRegEx": "Wen et al\\.", "year": 2016}, {"title": "The best of both worlds: Unifying conventional dialog systems and POMDPs", "author": ["Jason D. Williams."], "venue": "Proc Intl Conf on Spoken Language Processing (ICSLP), Brisbane, Australia.", "citeRegEx": "Williams.,? 2008", "shortCiteRegEx": "Williams.", "year": 2008}, {"title": "Partially observable Markov decision processes for spoken dialog systems", "author": ["Jason D. Williams", "Steve Young."], "venue": "Computer Speech and Language 21(2):393\u2013422.", "citeRegEx": "Williams and Young.,? 2007", "shortCiteRegEx": "Williams and Young.", "year": 2007}, {"title": "Simple statistical gradientfollowing algorithms for connectionist reinforcement learning", "author": ["Ronald J Williams."], "venue": "Machine learning 8(3-4):229\u2013256.", "citeRegEx": "Williams.,? 1992", "shortCiteRegEx": "Williams.", "year": 1992}, {"title": "Incorporating loosestructured knowledge into LSTM with recall gate for conversation modeling", "author": ["Zhen Xu", "Bingquan Liu", "Baoxun Wang", "Chengjie Sun", "Xiaolong Wang."], "venue": "CoRR abs/1605.05110. http://arxiv.org/abs/1605.05110.", "citeRegEx": "Xu et al\\.,? 2016", "shortCiteRegEx": "Xu et al\\.", "year": 2016}, {"title": "Attention with intention for a neural network conversation model", "author": ["Kaisheng Yao", "Geoffrey Zweig", "Baolin Peng."], "venue": "Proc NIPS workshop on Machine Learning for Spoken Language Understanding and Interaction.", "citeRegEx": "Yao et al\\.,? 2015", "shortCiteRegEx": "Yao et al\\.", "year": 2015}, {"title": "POMDP-based Statistical Spoken Dialogue Systems: a Review", "author": ["Steve Young", "Milica Gasic", "Blaise Thomson", "Jason D. Williams."], "venue": "Proceedings of the IEEE PP(99):1\u201320.", "citeRegEx": "Young et al\\.,? 2013", "shortCiteRegEx": "Young et al\\.", "year": 2013}, {"title": "ADADELTA: an adaptive learning rate method", "author": ["Matthew D. Zeiler."], "venue": "CoRR abs/1212.5701. http://arxiv.org/abs/1212.5701.", "citeRegEx": "Zeiler.,? 2012", "shortCiteRegEx": "Zeiler.", "year": 2012}], "referenceMentions": [{"referenceID": 0, "context": "HCNs attain stateof-the-art performance on the bAbI dialog dataset (Bordes and Weston, 2016), and outperform two commercially deployed customer-facing dialog systems.", "startOffset": 67, "endOffset": 92}, {"referenceID": 0, "context": "Section 4 applies HCNs to the bAbI dialog dataset (Bordes and Weston, 2016).", "startOffset": 50, "endOffset": 75}, {"referenceID": 6, "context": "This vector is passed to an RNN, such as a long shortterm memory (LSTM) (Hochreiter and Schmidhuber, 1997) or gated recurrent unit (GRU) (Chung et al.", "startOffset": 72, "endOffset": 106}, {"referenceID": 2, "context": "This vector is passed to an RNN, such as a long shortterm memory (LSTM) (Hochreiter and Schmidhuber, 1997) or gated recurrent unit (GRU) (Chung et al., 2014).", "startOffset": 137, "endOffset": 157}, {"referenceID": 11, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 26, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 34, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 33, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 7, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 10, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 4, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 38, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 15, "context": "The first decomposes a dialog system into a pipeline, typically including language understanding, dialog state tracking, action selection policy, and language generation (Levin et al., 2000; Singh et al., 2002; Williams and Young, 2007; Williams, 2008; Hori et al., 2009; Lee et al., 2009; Griol et al., 2008; Young et al., 2013; Li et al., 2014).", "startOffset": 170, "endOffset": 346}, {"referenceID": 32, "context": "Specifically related to HCNs, past work has implemented the policy as feed-forward neural networks (Wen et al., 2016), trained with supervised learning followed by reinforcement learning (Su et al.", "startOffset": 99, "endOffset": 117}, {"referenceID": 28, "context": ", 2016), trained with supervised learning followed by reinforcement learning (Su et al., 2016).", "startOffset": 77, "endOffset": 94}, {"referenceID": 27, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 24, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 31, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 37, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 22, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 18, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 36, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 13, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 19, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 17, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 23, "context": "The second, more recent line of work applies recurrent neural networks (RNNs) to learn \u201cendto-end\u201d models, which map from an observable dialog history directly to a sequence of output words (Sordoni et al., 2015; Shang et al., 2015; Vinyals and Le, 2015; Yao et al., 2015; Serban et al., 2016; Li et al., 2016a,c; Luan et al., 2016; Xu et al., 2016; Li et al., 2016b; Mei et al., 2016; Lowe et al., 2017; Serban et al., 2017).", "startOffset": 190, "endOffset": 425}, {"referenceID": 0, "context": "These systems can be applied to task-oriented domains by adding special \u201cAPI call\u201d actions, enumerating database output as a sequence of tokens (Bordes and Weston, 2016), then learning an RNN using Memory Networks (Sukhbaatar et al.", "startOffset": 144, "endOffset": 169}, {"referenceID": 29, "context": "These systems can be applied to task-oriented domains by adding special \u201cAPI call\u201d actions, enumerating database output as a sequence of tokens (Bordes and Weston, 2016), then learning an RNN using Memory Networks (Sukhbaatar et al., 2015), gated memory networks (Liu and Perez, 2016), query reduction networks (Seo et al.", "startOffset": 214, "endOffset": 239}, {"referenceID": 16, "context": ", 2015), gated memory networks (Liu and Perez, 2016), query reduction networks (Seo et al.", "startOffset": 31, "endOffset": 52}, {"referenceID": 21, "context": ", 2015), gated memory networks (Liu and Perez, 2016), query reduction networks (Seo et al., 2016), and copyaugmented networks (Eric and Manning, 2017).", "startOffset": 79, "endOffset": 97}, {"referenceID": 3, "context": ", 2016), and copyaugmented networks (Eric and Manning, 2017).", "startOffset": 36, "endOffset": 60}, {"referenceID": 0, "context": "In this section we compare HCNs to existing approaches on the public \u201cbAbI dialog\u201d dataset (Bordes and Weston, 2016).", "startOffset": 91, "endOffset": 116}, {"referenceID": 5, "context": "Task6 draws on human-computer dialog data from the second dialog state tracking challenge (DSTC2), where usability subjects (crowd-workers) interacted with several variants of a spoken dialog system (Henderson et al., 2014).", "startOffset": 199, "endOffset": 223}, {"referenceID": 6, "context": "We selected an LSTM for the recurrent layer (Hochreiter and Schmidhuber, 1997), with the AdaDelta optimizer (Zeiler, 2012).", "startOffset": 44, "endOffset": 78}, {"referenceID": 39, "context": "We selected an LSTM for the recurrent layer (Hochreiter and Schmidhuber, 1997), with the AdaDelta optimizer (Zeiler, 2012).", "startOffset": 108, "endOffset": 122}, {"referenceID": 20, "context": "Utterance embeddings were formed by averaging word embeddings, using a publicly available 300dimensional word embedding model trained using word2vec on web data (Mikolov et al., 2013).", "startOffset": 161, "endOffset": 183}, {"referenceID": 0, "context": "We compare to four past end-to-end approaches (Bordes and Weston, 2016; Liu and Perez, 2016; Eric and Manning, 2017; Seo et al., 2016).", "startOffset": 46, "endOffset": 134}, {"referenceID": 16, "context": "We compare to four past end-to-end approaches (Bordes and Weston, 2016; Liu and Perez, 2016; Eric and Manning, 2017; Seo et al., 2016).", "startOffset": 46, "endOffset": 134}, {"referenceID": 3, "context": "We compare to four past end-to-end approaches (Bordes and Weston, 2016; Liu and Perez, 2016; Eric and Manning, 2017; Seo et al., 2016).", "startOffset": 46, "endOffset": 134}, {"referenceID": 21, "context": "We compare to four past end-to-end approaches (Bordes and Weston, 2016; Liu and Perez, 2016; Eric and Manning, 2017; Seo et al., 2016).", "startOffset": 46, "endOffset": 134}, {"referenceID": 0, "context": "We emphasize that past approaches have applied purely sequence-to-sequence models, or (as a baseline) purely programmed rules (Bordes and Weston, 2016).", "startOffset": 126, "endOffset": 151}, {"referenceID": 0, "context": "Table 1: Results on bAbI dialog Task5-OOV and Task6 (Bordes and Weston, 2016).", "startOffset": 52, "endOffset": 77}, {"referenceID": 0, "context": "Table 1: Results on bAbI dialog Task5-OOV and Task6 (Bordes and Weston, 2016). Results for \u201cRules\u201d taken from Bordes and Weston (2016). Note that, unlike cited past work, HCNs make use of domainspecific procedural knowledge.", "startOffset": 53, "endOffset": 135}, {"referenceID": 35, "context": "For optimization, we selected a policy gradient approach (Williams, 1992), which has been successfully applied to dialog systems (Jur\u010d\u0131\u0301\u010dek et al.", "startOffset": 57, "endOffset": 73}, {"referenceID": 8, "context": "For optimization, we selected a policy gradient approach (Williams, 1992), which has been successfully applied to dialog systems (Jur\u010d\u0131\u0301\u010dek et al., 2011), robotics (Kohl and Stone, 2004), and the board game Go (Silver et al.", "startOffset": 129, "endOffset": 153}, {"referenceID": 9, "context": ", 2011), robotics (Kohl and Stone, 2004), and the board game Go (Silver et al.", "startOffset": 18, "endOffset": 40}, {"referenceID": 25, "context": ", 2011), robotics (Kohl and Stone, 2004), and the board game Go (Silver et al., 2016).", "startOffset": 64, "endOffset": 85}, {"referenceID": 35, "context": ", the variance) (Williams, 1992).", "startOffset": 16, "endOffset": 32}, {"referenceID": 33, "context": "Additional experiments, not shown for space, found that ablating the action mask slowed training, agreeing with Williams (2008).", "startOffset": 112, "endOffset": 128}], "year": 2017, "abstractText": "End-to-end learning of recurrent neural networks (RNNs) is an attractive solution for dialog systems; however, current techniques are data-intensive and require thousands of dialogs to learn simple behaviors. We introduce Hybrid Code Networks (HCNs), which combine an RNN with domain-specific knowledge encoded as software and system action templates. Compared to existing end-toend approaches, HCNs considerably reduce the amount of training data required, while retaining the key benefit of inferring a latent representation of dialog state. In addition, HCNs can be optimized with supervised learning, reinforcement learning, or a mixture of both. HCNs attain stateof-the-art performance on the bAbI dialog dataset (Bordes and Weston, 2016), and outperform two commercially deployed customer-facing dialog systems.", "creator": "LaTeX with hyperref package"}}}