{"id": "1703.00381", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Mar-2017", "title": "The Statistical Recurrent Unit", "abstract": "ls7 Sophisticated telex gated recurrent neural courted network datuk architectures like dichomeris LSTMs and feat GRUs have been o.i.c. shown girton to be highly effective veel in a xeer myriad makarem of grudgingly applications. burkholder We develop yalies an molson un - gated taihua unit, the statistical recurrent yoshizawa unit (blackmailer SRU ), that is jervey able dumler to starfruit learn lugh long cepero term swapnil dependencies tocci in data aerb by only milagros keeping perquisites moving averages phytase of statistics. babirusa The totentanz SRU ' enkidu s architecture perodua is simple, henkin un - gated, and .618 contains hue a subait comparable number of mahomes parameters hutts to LSTMs; woolstone yet, SRUs gaffe perform favorably nitijela to more sophisticated LSTM redenbaugh and libertadora GRU oarsman alternatives, 160-acre often outperforming one or behaviours both whereas in various griffey tasks. toronto-area We kusuma show the koneru efficacy lanesville of SRUs as compared computing to LSTMs cavagnari and GRUs in d'souza an unbiased tem manner d\u00f6ner by voorheesville optimizing respective chandavarkar architectures ' di-pertuan hyperparameters in a Bayesian metapopulation optimization anaya scheme 60.62 for both havret synthetic and meldola real - clitherow world stai tasks.", "histories": [["v1", "Wed, 1 Mar 2017 16:50:54 GMT  (570kb,D)", "http://arxiv.org/abs/1703.00381v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.AI stat.ML", "authors": ["junier b oliva", "barnab\u00e1s p\u00f3czos", "jeff g schneider"], "accepted": true, "id": "1703.00381"}, "pdf": {"name": "1703.00381.pdf", "metadata": {"source": "CRF", "title": "The Statistical Recurrent Unit", "authors": ["Junier B. Oliva", "Barnab\u00e1s P\u00f3czos", "Jeff Schneider"], "emails": ["liva@cs.cmu.edu>."], "sections": [{"heading": "1. Introduction", "text": "The analysis of sequential data has long been a staple in machine learning. Domain areas like natural language (Zaremba et al., 2014; Vinyals et al., 2015), speech (Graves et al., 2013; Graves & Jaitly, 2014), music (Chung et al., 2014), and video (Donahue et al., 2015) processing have recently garnered much attention. While the study of sequences itself is broad and may be extended to general functional analysis (Ramsay & Silverman, 2002), most recent success has been from neural network based models, especially from recurrent architectures.\nRecurrent networks are dynamical systems that represent time recursively. For example, the simple recurrent unit (Elman, 1990) contains a hidden state that itself depends on the previous hidden state. However, training such networks has been observed to be difficult in practice due to exploding and vanishing gradients when propagating error gradi-\n*Equal contribution 1Machine Learning Department, Carnegie Mellon University. Correspondence to: Junier B. Oliva <joliva@cs.cmu.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, 2017. JMLR: W&CP. Copyright 2017 by the author(s).\nents through time (Hochreiter et al., 2001). While exploding gradients can be mitigated with techniques like gradient clipping and normalization (Pascanu et al., 2013), vanishing gradients may be harder to deal with. As a result, sophisticated gated architectures like Long-Short Term Memory (LSTM) networks (Hochreiter & Schmidhuber, 1997) and Gated Recurrent Units (GRU) networks (Cho et al., 2014) have been developed. These gated architectures contain \u201cmemory cells\u201d along with gates to control how much they decay through time thereby aiding the networks\u2019 ability to learn long term dependencies in sequences.\nNotwithstanding, there are still challenges in capturing long term dependencies in gated architectures (Le et al., 2015). In this paper we present a simple un-gated architecture, the Statistical Recurrent Unit, that often outperforms these more complicated alternatives. Although the SRU keeps only simple moving averages of summary statistics, its novel architecture makes it more adept than previous gated units for capturing long term information in sequences and comparing them across different windows of time. For instance, the SRU, unlike traditional recurrent units, can obtain a multitude of viewpoints of the past by simple linear combinations of only a few averages. We shall illustrate the efficacy of the SRU below using both real-world and synthetic sequential data tasks.\nThe structure of the paper is as follows: first we detail the architecture of the SRU as well as provide several key intuitions and insights for its design; after, we describe our experiments comparing the SRU to popular gated alternatives, and we perform a \u201cdissective\u201d study of the SRU, gaining further understanding of the unit by exploring how various hyper-parameters affect performance; finally, we discuss conclusions from our study."}, {"heading": "2. Model", "text": "The SRU maintains long term sequential dependencies in a rather intuitive fashion\u2013through summary statistics. As the name implies, statisticians often employ summary statistics when trying to represent a dataset. Quite naturally then, we look to an algorithm that itself learns to represent data seen previously in much the same vein as a neural statistician (Edwards & Storkey, 2016).\nOf course, unlike with unordered i.i.d. samples, simply\nar X\niv :1\n70 3.\n00 38\n1v 1\n[ cs\n.L G\n] 1\nM ar\n2 01\n7\naveraging statistics of sequential points will lose valuable temporal information. The SRU maintains sequential information in two ways: first, we generate recurrent statistics that depend on a context of previously seen data; second, we generate moving averages at several scales, allowing the model to distinguish the type of data seen at different points in the past. We expound on these methods for creating temporally-aware statistics below.\nWe shall see that the statistical design of the SRU yields a powerful yet simple model that is able to analyze sequential data and, on the fly, create summary statistics for learning over sequences. Furthermore, through the use of ReLUs and exponential moving averages, the SRU is able to overcome vanishing gradient issues that are common to many recurrent units."}, {"heading": "2.1. Recurrent Statistics", "text": "We consider an input sequence of real valued points x1, x2, . . . , xT \u2208 Rd. As seen in the second row of Table 1, we can compute a vector of statistics \u03c6(xi) \u2208 RD for each point. Here, each vector \u03c6(xi) is independent of other points xj for j 6= i. One may then average these vectors as \u00b5 = 1T \u2211T i=1 \u03c6(xi) to produce summary statistics of the sequence. This approach amounts to treating the sequence as a set of i.i.d. points drawn form some distribution and marginalizing out time. Clearly, here one will lose temporal information that will be useful for many sequence related ML tasks. It is interesting to note that global average pooling operations have gained a lot of recent traction in convolutional networks (Lin et al., 2013; Iandola et al., 2016). Analogously to the i.i.d. statistic approach, global averaging will lose spatial information, yet the high-level summary statistics provide an effective representation. Still, not marginalizing out time should provide a more robust approach for sequence tasks, thus we consider the following methods for producing statistics.\nFirst, we provide temporal information whilst still utilizing averages through recurrent statistics that also depend on the values of previous points (see third row of Table 1). That is, we compute our statistics on the ith point xi not only as a function of xi, but also as a function of the previous statistics of xi\u22121, ~\u03b3i\u22121 (which itself depends on ~\u03b3i\u22122, etc.):\n~\u03b31 = \u03b3(x1, ~\u03b30), ~\u03b32 = \u03b3(x2, ~\u03b31), . . . (1)\nwhere \u03b3(\u00b7, \u00b7) is a function for producing statistics given the current point and previous statistics, and ~\u03b30 is a constant initial vector for convention. We note that from a general standpoint if given a flexible model and enough dimensions, then recurrent summary statistics like (1) can perfectly encode ones sequence. Take for instance the follow-\ning illustrative example where xi \u2208 R+ and statistics\n~\u03b3i = (0, . . . , 0, Txi, 0, . . .) (2) ~\u03b3i+1 = (0, . . . , 0, 0, Txi+1, 0, . . .). (3)\nThat is, one records the ith input in the ith index. When averaged the statistics will be 1T \u2211T i=1 ~\u03b3i = (x1, x2, . . .), i.e. the complete sequence. Such recurrent statistics will undoubtedly suffer from the curse of dimensionality. Hence, we consider a more restrictive model of recurrent statistics which we expound on below (6).\nSecond, we provide even more temporal information by considering summary statistics at multiple scales. We shed light on the dynamics of statistics through time by using several weights of the same summary statistics. As a simple hypothetical example consider taking multiple means across separate time windows (for instance taking means over indices 1-10, then over indices 11-20, etc.). Such an approach (4) will illustrate how summary statistics evolve through time.\n\u03c61, . . . , \u03c610\ufe38 \ufe37\ufe37 \ufe38 \u00b51:10 , \u03c611, . . . , \u03c620\ufe38 \ufe37\ufe37 \ufe38 \u00b511:20 , . . . . (4)\nThe SRU will use exponential moving averages \u00b5i = \u03b1~\u03b3i + (1\u2212 \u03b1)\u00b5i\u22121 to compute means; hence, we consider multiple weights by taking the exponential means at various scales \u03b11, . . . , \u03b1m as shown in the last row of Table 1. Later we show that this multi-scaled approach is capable of a combinatorial number of viewpoints of past statistics through simple linear combinations."}, {"heading": "2.2. Update Equations", "text": "We have discussed in broad terms how one may create temporally-aware summary statistics through multi-scaled recurrent statistics. Below, we cover specifically how the SRU creates and uses summary statistics for sequences.\nRecall that our input is a sequence of ordered points: {x1, x2, . . .}, xt \u2208 Rd. Throughout, we apply an element-\nwise non-linearity f (\u00b7), which we take to be the ReLU (Jarrett et al., 2009; Nair & Hinton, 2010): f (\u00b7) = max(\u00b7, 0). The SRU operates via exponential moving averages, \u00b5(\u03b1) \u2208 Rs (7), kept at various scales \u03b1 \u2208 A = {\u03b11, . . . , \u03b1m}, where \u03b1i \u2208 [0, 1). These moving averages, \u00b5(\u03b1), are of recurrent statistics \u03d5 (6) that are dependent not only on the current input but also on features of averages, r (5). The moving averages are then concatenated as \u00b5 = (\u00b5(\u03b11), . . . , \u00b5(\u03b1m)) and used to create an output o (8) that is fed upwards in the network.\nWe detail the update equations for the SRU below (and in Figure 1):\nrt = f ( W (r)\u00b5t\u22121 + b (r) )\n(5) \u03d5t = f ( W (\u03d5)rt +W (x)xt + b (\u03d5) ) (6)\n\u2200\u03b1 \u2208 A, \u00b5(\u03b1)t = \u03b1\u00b5 (\u03b1) t\u22121 + (1\u2212 \u03b1)\u03d5t (7) ot = f ( W (o)\u00b5t + b (o) ) . (8)\nIn practiced we noted that it suffices to use only a few \u03b1\u2019s such as A = {0, 0.25, 0.5, 0.9, 0.99}.\nIt is worth noting that exponential averages of inputs has been considered previously (Mikolov et al., 2015). However, that approach performs a moving average of a linear features (specifically the identity mapping) that depends only on the current observation, which is fairly inflexible. Furthermore, such work considers only one scale per feature, limiting the views available per statistic to just one. The use of ReLUs in recurrent units has also been recently explored by Le et al. (2015), however there no statistics are kept and their use is limited to the simple RNN when initialized in a special manner."}, {"heading": "2.3. Intuitions from Mean Map Embeddings", "text": "The design of the SRU is deliberately chosen to allow for long term dependencies to be learned. To better elucidate the design and its intuition, let us take a brief excursion to another use of (summary) statistics in machine learning for the representation of data: mean map embeddings (MMEs) of distributions (Smola et al., 2007). At its core, the concept of MMEs is that one may embed, and thereby represent, a distribution through statistics (such as moments). The MME for a distributionD given a positive semidefinite kernel k is: \u00b5[D] = EX\u223cD [\u03c6k(X)] , (9) where \u03c6k are the reproducing kernel Hilbert space (RKHS) features of k, which may be infinite dimensional. To represent a set Y = {y1, . . . , yn}\niid\u223c D one would use an empirical mean version of the MME:\n\u00b5[Y ] = 1\nn n\u2211 i=1 \u03c6k(yi). (10)\nNumerous works have shown success in representing distributions and sets through MMEs (Muandet et al., 2016). One interpretation for the design of SRUs is that we are modifying MME\u2019s for use on sequences. Of course, one way of applying MMEs directly on sequences is to simply ignore the non-i.i.d. nature of sequences and treat points as comprising a set. This however loses important sequential information, as previously mentioned. Below we discuss the specific modifications we make from traditional MMEs and the benefits they yield."}, {"heading": "2.3.1. DATA-DRIVEN STATISTICS", "text": "First, we note the clear analogue between the mean embedding of a set Y , \u00b5[Y ] (10), and the moving average \u00b5(\u03b1) (7). The moving averages \u00b5(\u03b1) are clearly serving as summary statistics of previously seen data. However, the statistics we are averaging for \u00b5(\u03b1), \u03d5 (6), are not comprised of apriori RKHS features as is typical with MMEs, but rather are learned non-linear features. This has the benefit of using data-driven statistics, and may be interpreted as using a linear kernel in the learned features."}, {"heading": "2.3.2. RECURSIVE STATISTICS FROM THE PAST", "text": "Second, recall that typical MMEs use statistics that depend only on a single point x, \u03c6k(x). As aforementioned this is fine for i.i.d. data, however it loses sequential information when averaged. Instead, we wish to assign statistics that depend on the data we have seen so far, since it provides context for one\u2019s current point in the sequence. For instance, one may want to have a statistic that keeps track of the difference between the current point and the mean of previous data. We provide a context based on previous data by making the statistics considered at time t, \u03d5t\n(6), a function not only of xt but also of {x1, . . . , xt\u22121} through rt (5). rt may be interpreted as a condensation of the sequence seen so far, and allows us to keep sequential information even through an averaging operation."}, {"heading": "2.3.3. MULTI-SCALED STATISTICS", "text": "Third, the use of multi-scaled moving averages of statistics gives the SRU a simple and powerful rich view of past data that is unique to this recurrent unit. In short, by keeping moving averages at different scales {\u03b11, . . . , \u03b1m}, we are able to uncover differences in statistics at various times in the past. Note that we may unroll moving averages as:\n\u00b5 (\u03b1) t = (1\u2212 \u03b1) ( \u03d5t + \u03b1\u03d5t\u22121 + \u03b1 2\u03d5t\u22122 + . . . ) (11)\nThus, a smaller \u03b1 weighs current statistics more than older statistics; hence, a concatenated vector \u00b5 = (\u00b5(\u03b11), . . . , \u00b5(\u03b1m)) itself provides a multi-scale view of statistics through time (see Figure 2). For instance, keeping statistics for short and long terms pasts already yields information on the evolution of the sequence through time."}, {"heading": "2.4. Viewpoints of the Past", "text": "An interesting and useful property of keeping multiple scales for each statistic is that one can obtain a combinatorial number of viewpoints of the past through simple linear combinations of ones statistics. For instance, for properly chosen wj , wk \u2208 R, wj\u00b5(\u03b1j)\u2212wk\u00b5(\u03b1k) provides an aggregate of statistics from the past for \u03b1j > \u03b1k (Figure 3). Of course, more complicated linear combinations may be performed to obtain richer viewpoints that are comprised of multiple windows. Furthermore, by using a linear projection of our statistics \u00b5t, as we do with ot (8), we are able to compute output features of combined viewpoints of several statistics.\nThis kind of multi-viewpoint perspective of previously seen data is difficult to produce in traditional gated recurrent units since they must encode where in the sequence they currently are and then store an activation on separate nodes\nper each viewpoint for future use. SRUs, on the other hand, only need to take simple linear combinations to capture various viewpoints in the past. For example, as shown above, statistics from just the distant past are available via a simple subtraction of two moving averages (Figure 3, row 1). Such a windowed view would require a gated unit to learn to stop averaging after a certain point in the sequence, and the corresponding statistic would not yield an information outside of this window. In contrast, each statistic kept by the SRU provides a combinatorial number of varying perspectives in the past through linear combinations and their multi-scaled nature."}, {"heading": "2.5. Vanishing Gradients", "text": "As previously mentioned, it has been shown that vanishing gradients make learning recurrent units difficult due to an inability to propagate error gradients through time. Notwithstanding its simple un-gated structure, the SRU features several safeguards against vanishing gradients. First, units and statistics are comprised of ReLUs. ReLUs have been observed to be easier to train for general deep networks (Nair & Hinton, 2010) and have had success in recurrent units (Le et al., 2015). Intuitively, ReLUs allow for the propagation on error on positive inputs without saturation and vanishing gradients as with traditional sigmoid units. The ability of the SRU to use ReLUs (without any special initialization) makes it especially adept at learning long term dependencies through time.\nFurthermore, the explicit moving average of statistics allows for longer term learning. Consider the following derivative of the error signal E w.r.t. an element [ \u00b5 (\u03b1) t\u22121 ] k\nof the unit\u2019s moving averages:\ndE d [ \u00b5 (\u03b1) t\u22121 ] k\n= d [ \u00b5 (\u03b1) t ] k\nd [ \u00b5 (\u03b1) t\u22121 ] k\ndE d [ \u00b5 (\u03b1) t ] k = \u03b1 dE d [ \u00b5 (\u03b1) t ] k .\nThat is, the factor \u03b1 directly controls the decay of the error signal through time and be be easily set to avoid vanishing gradients."}, {"heading": "3. Experiments", "text": "We compared the performance of the SRU to two popular gated recurrent units, the GRU and LSTM unit. All experiments were performed in Tensorflow (Abadi et al., 2016) and used the standard implementations of GRUCell and BasicLSTMCell for GRUs and LSTMs respectively. In order to perform a fair, unbiased comparison of the recurrent units and their hyper-parameters, which greatly affect performance (Bergstra & Bengio, 2012), we used the Hyperopt (Bergstra et al., 2015) Bayesian optimization package. We believe that such an approach gives each algorithm a fair shot to succeed without injecting biases from experimenters or imposing gross restrictions on architectures considered.\nIn all experiments we used SGD for optimization using gradient clipping (Pascanu et al., 2013) with a norm of 1 on all algorithms. Unless otherwise specified 100 trials were performed to search over the following hyper-parameters on a validation set: one, initial learning rate the initial learning rate used for SGD, in range of [exp(\u221210), 1]; two, lr decay the multiplier to multiply the learning rate by every 1k iterations, in range of [0.8, 0.999]; three, dropout keep rate, percent of output units that are kept during dropout, in range (0, 1]; four, num units number of units for recurrent unit, in {1, . . . , 256}. In addition, the following two parameters were searched over for the SRU: num stats, the dimensionality of \u03d5 (6), in {1, . . . , 256}; summary dims, the dimensionality of r (5), in {1, . . . , 64}."}, {"heading": "3.1. Synthetic Recurrent Unit Generated Data", "text": "First we provide evidence that traditional gated units have difficulties capturing the same type of multi-scale recurrent statistic based dependencies that the SRU offers. We show the relative inefficiency of traditional gated units at learning long term dependencies of statistics by considering 1d synthetic data from a ground truth SRU.\nWe begin the sequences with x1 iid\u223c N (0, 1002), and xt is the results of a projection of ot. We generate a total of 176 points per sequence for 3200 training sequences, 400 validation sequences, and 400 testing sequences.\nThe ground truth statistical recurrent unit has three statis-\ntics \u03c6t (6): the positive part of inputs (x)+, the negative part of inputs (x)\u2212, and an internal statistic, z. We use \u03b1 \u2208 {\u03b1i}5i=1 = {0.0, 0.5, 0.9, 0.99, 0.999}. Denote \u00b5 (\u03b1) + , \u00b5 (\u03b1) \u2212 , \u00b5 (\u03b1) z as the moving averages using \u03b1 for each respective statistic. The internal statistic z does not get used (through rt (5)) in updating the statistics for (x)+ or (x)\u2212. z is itself updated as:\nzt = (zt\u22121)+ + ( \u00b5 (\u03b14) + \u2212 \u00b5 (\u03b15) + \u2212 0.01 ) + \u2212 ( \u2212\u00b5(\u03b14)\u2212 + \u00b5 (\u03b15) \u2212 \u2212 0.01 ) +\n\u2212 ( \u2212\u00b5(\u03b14)+ + \u00b5 (\u03b15) + \u2212 0.05 ) + + ( \u00b5 (\u03b14) \u2212 \u2212 \u00b5 (\u03b15) \u2212 \u2212 0.05 ) + ,\nwhere each of the summands are rt features. Furthermore we have ot \u2208 R15 (8):\not = ( (xt)+, \u2212(xt)\u2212, vT1 \u00b5t, . . . , vT13\u00b5t ) ,\nwhere vj\u2019s where initialized and fixed as (vj)k iid\u223c N (0, ( 1100 ) 2). Finally the next point is generated as:\nxt+1 = (xt)+ \u2212 (xt)\u2212 + wT ot,3:,\nwhere w was initialized and fixed as (w)k iid\u223c N (0, 1), and ot,3: are the last 13 dimensions of ot.\nAfter the ground truth SRU was constructed we generated the training, validation, and testing sequences. As can be seen in Figure 4, the sequences follow a simple pattern: at the start negative values are quickly pushed to zero and positive values follow a parabolic line until hitting zero, at which point they slope downward depending on initial values. While simple, it is clear that trained recurrent units must be able to hold long-term information since all sequences converge at one point and future behaviour depends on initial values.\nWe look to minimize the mean of squared errors (MSE); that is, the loss we consider per sequence is 1 175 \u2211175 t=1 |xt+1 \u2212 pt|2, where pt is the output of the network after being fed xt. We conducted 100 trials of Bayesian optimization as described above and obtained the following results in Table 2.\nNot surprisingly, the SRU performs far better than traditional gated recurrent units. This suggests that the types\nof long-term statistical relationships captured by the SRU are indeed different than those of traditional recurrent units. As previously mentioned, the SRU is able to obtain a multitude of different views from its statistics, a task that traditional units achieve less efficiently since they must devote one whole memory cell per viewpoint and statistic. As we show below, the SRU is able to outperform traditional gated units in long term problems even for real data that is not generated from its model class."}, {"heading": "3.2. MNIST Image Classification", "text": "Next we explore the ability of recurrent units to use longterm dependencies in ones data with a synthetic task using a real dataset. It has been observed that LSTMs perform poorly in classifying a long pixel-by-pixel sequence of MNIST digits (Le et al., 2015). In this synthetic task, each 28\u00d728 gray-scale MNIST digit image is flattened and observed as a sequence {x1, . . . , x784}, where xi \u2208 [0, 1] (see Figure 5). The task is, based on the output observed after feeding x784 through the network, to classify the digit of the corresponding image in {0, . . . , 9}. Hence, we project the output after x784 of each recurrent unit to 10 dimensions and use a softmax activation.\nWe report the Bayesian optimized results below in Table 3; due to resource constraints each trial consisted only of 10K training iterations. We see that the SRU is able to outperform both GRUs and LSTMs. Given the long length and dependencies of pixel sequences in this experiment, it is not surprising that SRUs\u2019 abilities to capture long-term dependencies are aiding it to achieve a much lower error."}, {"heading": "3.2.1. DISSECTIVE STUDY", "text": "Next, we study the behavior of the statistical recurrent unit with a dissective study where we vary several parameters of the architecture. We consider variants to the base model with: num stats=200; r dims=60; num units=200. We keep the parameters initial learning rate, lr decay fixed at the the optimal values found (0.1, 0.99 respectively) unless we find no learning, in which case we also try learning rates of 0.01 and 0.001.\nThe need for multi-scaled recurrent statistics. Recall that we designed the statistics used by the SRU expressly to capture long term time dependencies in sequences. We did so both with recurrent statistics, i.e. statistics that themselves depend on previous points\u2019 statistics, and with multiscaled averages. We show below that both of these timedependent design choices are vital to capturing long term dependencies in data. Furthermore, we show that the use of ReLU statistics lends itself to better learning.\nWe explored the impact that time-dependent statistics had on learning by first considering naive i.i.d. summary statistics for sequences. This was achieved by using r dims=0 and \u03b1 \u2208 A = {0.99999}. Here no past-dependent context is used for statistics, i.e. we used i.i.d.-type statistics as is typical for unordered sets. Furthermore, the use of a single scale \u03b1 near 1 means that all of the points\u2019 statistics will be weighted nearly identically (11) regardless of index. We optimized the SRU when using no recurrent statistics and a single scale (iid), when using recurrent statistics with a single scale (recur), and when using no recurrent statistics with multiple scales (multi). We report errors below in Table 4.\nPredictably, we cannot learn by simply keeping i.i.d. type statistics of pixel values at a single scale. Furthermore, we find that only using recurrent statistics (recur) in the SRU is not enough. It is interesting to note, however, that keeping i.i.d. statistics at multiple scales is able to predict digits\nwith limited success. This lends evidence for the need of both recurrent statistics and multiple scales.\nNext, we explored the effects of the scales at which we keep our statistics by varying from \u03b1 \u2208 A = {0.0, 0.5, 0.9, 0.99, 0.999} considering \u03b1 \u2208 A = {0.0, 0.5, 0.9}, \u03b1 \u2208 A = {0.0, 0.5, 0.9, 0.99}. We see in Table 5 that additional, longer scales aid our learning for this dataset. This is not very surprising given the long term nature of the pixel sequences.\nLastly, we considered the use of non-ReLU statistics by changing the element-wise non-linearity f(\u00b7) (5)-(8) to be the hyperbolic tangent f(\u00b7) = tanh(\u00b7). We postulated that the use of ReLUs would help our learning since they have been observed to better handle the problem of vanishing gradients. We find evidence of this when swapping ReLUs for hyperbolic tangent units in SRUs: we get an error rate of 0.18 when using hyperbolic tangent units. Although the previous uses of ReLUs in RNN required careful initialization (Le et al., 2015), SRUs are able to use ReLUs for better learning without an special considerations.\nDimension of recurrent summary. Next we explore the affect of varying the number of dimensions used for the recurrent summary of statistics rt (5). We consider r dims in {5, 20, 240}. As previously discussed rt provides a context based on past data so that the SRU may produce noni.i.d. statistics as it moves along a sequences. As one would expect the dimensionality of rt will limit the information flow from the past and values that are too small will hinder performance. It is also interesting to see that after enough dimensions, there are diminishing returns to adding more.\nNumber of statistics and outputs. Finally, we vary the number of statistics num stats, and outputs units. Interestingly the SRU seems robust to the number of outputs propagated in the network. However, performance is considerably affected by the number of statistics considered."}, {"heading": "3.3. Polyphonic Music Modeling", "text": "Henceforth we consider real data and sequence learning tasks. First, we used the polyphonic music datasets from Boulanger-Lewandowski et al. (2012). Each time-step is a binary vector representing the notes played at the respective time-step. Since we were required to predict binary vectors we used the element-wise sigmoid \u03c3. I.e., the binary vector of notes xt+1 was modeled as \u03c3 (pt), where pt is the output after feeding xt (and previous values x1, . . . , xt\u22121) through the recurrent network.\nIt is interesting to note in Table 8 that the SRU is able to outperform one of the traditional gated units in every dataset and it outperforms both in two datasets."}, {"heading": "3.4. Electronica-Genre Music MFCC", "text": "In the following experiment we modeled the Mel frequency cepstrum coefficients (MFCCs) in a dataset of nearly 18 000 scraped 30s sound clips of electronica-genre songs. MFCCs are perceptually based spectral features positioned logarithmically on the mel scale, which approximates the human auditory system\u2019s response (Mu\u0308ller, 2007). We looked to model the 13 real-valued coefficients using the recurrent units, by modeling xt+1 as a projection of the output of a recurrent unit after being fed x1, . . . , xt.\nAs can be seen in Table 9, SRUs again are outperforming gated architectures and are especially beating GRUs by a wider margin."}, {"heading": "3.5. Climate Data", "text": "Next we consider weather data prediction using the North America Regional Reanalysis (NARR) Project. The dataset provides a long-term set of consistent climate data on a regional scale for the North American domain. The period of the reanalyses is from October 1978 to the present and analyses were made 8 times daily (3 hour intervals).\nWe take our input sequences to be year-long sequences of weather variables in a location for the year 2006. I.e. an input sequence will be a 2920 length sequence of weather variables at a given lat/lon coordinate. We considered the following 7 variables: pres10m, 10 m pressure (pa); tcdc, total cloud cover (%); rh2m, relative humidity 2m (%); tmpsfc, surface temperature (k); snod, snow depth surface (m); ugrd10m, u component of wind 10m above ground; vgrd10m, v component of wind 10m above ground. The variables were standardized, see Figure 6 for example sequences.\nBelow we see results using 51 200 training location sequences and 6 400 validation and testing instances. Again, we look to model the next point in a sequence as a projection of the output of the recurrent unit after feeding the previous points. One may see in Table 10 that SRUs and LSTMs perform nearly identically; perhaps the cyclical nature of climate data was beneficial to the gated units."}, {"heading": "3.6. SportVu NBA Tracking data", "text": "Finally, we look to predict the positions of National Basketball Association (NBA) players based on previous court positions during a play. Optical tracking data for this project were provided by STATS LLC from their SportVU product and obtained from (NBA). The data are composed of x and y coordinates for each of the ten players and the ball. We again minimize the squared norm of errors for predictions.\nWe observed a large margin of improvement for SRUs over gated architectures in Table 11 that is reminiscent of the synthetic data experiment in \u00a73.1. This suggests that this dataset contains long term dependencies that the SRU is able to exploit."}, {"heading": "4. Discussion", "text": "We believe that the use of summary statistics has been under-explored in modern recurrent units. Although recent studies in convolutional networks have considered global average pooling, which is essentially using high-level summary statistics to represent images, there has been little exploration of summary statistics for modern recurrent networks. To this end we introduce the Statistical Recurrent Unit, a novel architecture that seeks to capture long term dependencies in data using only simple moving averages and rectified-linear units.\nThe SRU was motivated by the success of mean-map embeddings for representing unordered datasets, and may be interpreted as an alteration of MMEs for sequential data. The main modifications are as follows: first, the SRU uses data-driven statistics unlike typical MMEs, which will use RKHS features from an a-priori selected class of kernels; second, SRUs will use recurrent statistics that dependent not only on a current point, but on previous points\u2019 statistics through a condensation of kept moving averages; third, the SRU will keep moving averages at various scales. We provide evidence that the combination of these modifications yield much better results than any one of them in isolation. The resulting recurrent unit is especially adept for capturing long term dependencies in data and readily has access to a combinatorial number of viewpoints of past windows through simple linear combinations.\nWe showed empirically that the SRU is better equipped that traditional gated units for long term dependencies via synthetic and real-world data experiments."}], "references": [{"title": "Random search for hyper-parameter optimization", "author": ["Bergstra", "James", "Bengio", "Yoshua"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Bergstra et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bergstra et al\\.", "year": 2012}, {"title": "Hyperopt: a python library for model selection and hyperparameter optimization", "author": ["Bergstra", "James", "Komer", "Brent", "Eliasmith", "Chris", "Yamins", "Dan", "Cox", "David D"], "venue": "Computational Science & Discovery,", "citeRegEx": "Bergstra et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Bergstra et al\\.", "year": 2015}, {"title": "Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription", "author": ["Boulanger-Lewandowski", "Nicolas", "Bengio", "Yoshua", "Vincent", "Pascal"], "venue": "arXiv preprint arXiv:1206.6392,", "citeRegEx": "Boulanger.Lewandowski et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Boulanger.Lewandowski et al\\.", "year": 2012}, {"title": "On the properties of neural machine translation: Encoder-decoder approaches", "author": ["Cho", "Kyunghyun", "Van Merri\u00ebnboer", "Bart", "Bahdanau", "Dzmitry", "Bengio", "Yoshua"], "venue": "arXiv preprint arXiv:1409.1259,", "citeRegEx": "Cho et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cho et al\\.", "year": 2014}, {"title": "Empirical evaluation of gated recurrent neural networks on sequence modeling", "author": ["Chung", "Junyoung", "Gulcehre", "Caglar", "Cho", "KyungHyun", "Bengio", "Yoshua"], "venue": "arXiv preprint arXiv:1412.3555,", "citeRegEx": "Chung et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Chung et al\\.", "year": 2014}, {"title": "Towards a neural statistician", "author": ["Edwards", "Harrison", "Storkey", "Amos"], "venue": "arXiv preprint arXiv:1606.02185,", "citeRegEx": "Edwards et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Edwards et al\\.", "year": 2016}, {"title": "Finding structure in time", "author": ["Elman", "Jeffrey L"], "venue": "Cognitive science,", "citeRegEx": "Elman and L.,? \\Q1990\\E", "shortCiteRegEx": "Elman and L.", "year": 1990}, {"title": "Towards end-to-end speech recognition with recurrent neural networks", "author": ["Graves", "Alex", "Jaitly", "Navdeep"], "venue": "In ICML,", "citeRegEx": "Graves et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Graves et al\\.", "year": 2014}, {"title": "Speech recognition with deep recurrent neural networks. In Acoustics, speech and signal processing", "author": ["Graves", "Alex", "Mohamed", "Abdel-rahman", "Hinton", "Geoffrey"], "venue": "(icassp), 2013 ieee international conference on,", "citeRegEx": "Graves et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Graves et al\\.", "year": 2013}, {"title": "Long shortterm memory", "author": ["Hochreiter", "Sepp", "Schmidhuber", "J\u00fcrgen"], "venue": "Neural computation,", "citeRegEx": "Hochreiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter et al\\.", "year": 1997}, {"title": "Gradient flow in recurrent nets: the difficulty of learning", "author": ["Hochreiter", "Sepp", "Bengio", "Yoshua", "Frasconi", "Paolo", "Schmidhuber", "J\u00fcrgen"], "venue": "long-term dependencies,", "citeRegEx": "Hochreiter et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Hochreiter et al\\.", "year": 2001}, {"title": "Squeezenet: Alexnet-level accuracy with 50x fewer parameters and\u00a1 0.5 mb model size", "author": ["Iandola", "Forrest N", "Han", "Song", "Moskewicz", "Matthew W", "Ashraf", "Khalid", "Dally", "William J", "Keutzer", "Kurt"], "venue": "arXiv preprint arXiv:1602.07360,", "citeRegEx": "Iandola et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Iandola et al\\.", "year": 2016}, {"title": "What is the best multi-stage architecture for object recognition", "author": ["Jarrett", "Kevin", "Kavukcuoglu", "Koray", "LeCun", "Yann"], "venue": "In Computer Vision,", "citeRegEx": "Jarrett et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Jarrett et al\\.", "year": 2009}, {"title": "A simple way to initialize recurrent networks of rectified linear units", "author": ["Le", "Quoc V", "Jaitly", "Navdeep", "Hinton", "Geoffrey E"], "venue": "arXiv preprint arXiv:1504.00941,", "citeRegEx": "Le et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Le et al\\.", "year": 2015}, {"title": "Marc\u2019Aurelio. Learning longer memory in recurrent neural networks", "author": ["Mikolov", "Tomas", "Joulin", "Armand", "Chopra", "Sumit", "Mathieu", "Michael", "Ranzato"], "venue": "arXiv preprint arXiv:1412.7753,", "citeRegEx": "Mikolov et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2015}, {"title": "Kernel mean embedding of distributions: A review and beyonds", "author": ["Muandet", "Krikamol", "Fukumizu", "Kenji", "Sriperumbudur", "Bharath", "Sch\u00f6lkopf", "Bernhard"], "venue": "arXiv preprint arXiv:1605.09522,", "citeRegEx": "Muandet et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Muandet et al\\.", "year": 2016}, {"title": "Information retrieval for music and motion, volume", "author": ["M\u00fcller", "Meinard"], "venue": null, "citeRegEx": "M\u00fcller and Meinard.,? \\Q2007\\E", "shortCiteRegEx": "M\u00fcller and Meinard.", "year": 2007}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["Nair", "Vinod", "Hinton", "Geoffrey E"], "venue": "In Proceedings of the 27th international conference on machine learning", "citeRegEx": "Nair et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2010}, {"title": "On the difficulty of training recurrent neural networks", "author": ["Pascanu", "Razvan", "Mikolov", "Tomas", "Bengio", "Yoshua"], "venue": "ICML (3),", "citeRegEx": "Pascanu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Pascanu et al\\.", "year": 2013}, {"title": "Applied functional data analysis: methods and case studies, volume 77", "author": ["J.O. Ramsay", "B.W. Silverman"], "venue": null, "citeRegEx": "Ramsay and Silverman,? \\Q2002\\E", "shortCiteRegEx": "Ramsay and Silverman", "year": 2002}, {"title": "A hilbert space embedding for distributions", "author": ["Smola", "Alex", "Gretton", "Arthur", "Song", "Le", "Sch\u00f6lkopf", "Bernhard"], "venue": "In International Conference on Algorithmic Learning Theory,", "citeRegEx": "Smola et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Smola et al\\.", "year": 2007}, {"title": "Grammar as a foreign language", "author": ["Vinyals", "Oriol", "Kaiser", "\u0141ukasz", "Koo", "Terry", "Petrov", "Slav", "Sutskever", "Ilya", "Hinton", "Geoffrey"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Vinyals et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Vinyals et al\\.", "year": 2015}, {"title": "Recurrent neural network regularization", "author": ["Zaremba", "Wojciech", "Sutskever", "Ilya", "Vinyals", "Oriol"], "venue": "arXiv preprint arXiv:1409.2329,", "citeRegEx": "Zaremba et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zaremba et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 22, "context": "Domain areas like natural language (Zaremba et al., 2014; Vinyals et al., 2015), speech (Graves et al.", "startOffset": 35, "endOffset": 79}, {"referenceID": 21, "context": "Domain areas like natural language (Zaremba et al., 2014; Vinyals et al., 2015), speech (Graves et al.", "startOffset": 35, "endOffset": 79}, {"referenceID": 8, "context": ", 2015), speech (Graves et al., 2013; Graves & Jaitly, 2014), music (Chung et al.", "startOffset": 16, "endOffset": 60}, {"referenceID": 4, "context": ", 2013; Graves & Jaitly, 2014), music (Chung et al., 2014), and video (Donahue et al.", "startOffset": 38, "endOffset": 58}, {"referenceID": 10, "context": "ents through time (Hochreiter et al., 2001).", "startOffset": 18, "endOffset": 43}, {"referenceID": 18, "context": "While exploding gradients can be mitigated with techniques like gradient clipping and normalization (Pascanu et al., 2013), vanishing gradients may be harder to deal with.", "startOffset": 100, "endOffset": 122}, {"referenceID": 3, "context": "As a result, sophisticated gated architectures like Long-Short Term Memory (LSTM) networks (Hochreiter & Schmidhuber, 1997) and Gated Recurrent Units (GRU) networks (Cho et al., 2014) have been developed.", "startOffset": 165, "endOffset": 183}, {"referenceID": 13, "context": "Notwithstanding, there are still challenges in capturing long term dependencies in gated architectures (Le et al., 2015).", "startOffset": 103, "endOffset": 120}, {"referenceID": 11, "context": "It is interesting to note that global average pooling operations have gained a lot of recent traction in convolutional networks (Lin et al., 2013; Iandola et al., 2016).", "startOffset": 128, "endOffset": 168}, {"referenceID": 12, "context": "wise non-linearity f (\u00b7), which we take to be the ReLU (Jarrett et al., 2009; Nair & Hinton, 2010): f (\u00b7) = max(\u00b7, 0).", "startOffset": 55, "endOffset": 98}, {"referenceID": 14, "context": "It is worth noting that exponential averages of inputs has been considered previously (Mikolov et al., 2015).", "startOffset": 86, "endOffset": 108}, {"referenceID": 13, "context": "The use of ReLUs in recurrent units has also been recently explored by Le et al. (2015), however there no statistics are kept and their use is limited to the simple RNN when initialized in a special manner.", "startOffset": 71, "endOffset": 88}, {"referenceID": 20, "context": "To better elucidate the design and its intuition, let us take a brief excursion to another use of (summary) statistics in machine learning for the representation of data: mean map embeddings (MMEs) of distributions (Smola et al., 2007).", "startOffset": 215, "endOffset": 235}, {"referenceID": 15, "context": "Numerous works have shown success in representing distributions and sets through MMEs (Muandet et al., 2016).", "startOffset": 86, "endOffset": 108}, {"referenceID": 13, "context": "ReLUs have been observed to be easier to train for general deep networks (Nair & Hinton, 2010) and have had success in recurrent units (Le et al., 2015).", "startOffset": 135, "endOffset": 152}, {"referenceID": 1, "context": "In order to perform a fair, unbiased comparison of the recurrent units and their hyper-parameters, which greatly affect performance (Bergstra & Bengio, 2012), we used the Hyperopt (Bergstra et al., 2015) Bayesian optimization package.", "startOffset": 180, "endOffset": 203}, {"referenceID": 18, "context": "In all experiments we used SGD for optimization using gradient clipping (Pascanu et al., 2013) with a norm of 1 on all algorithms.", "startOffset": 72, "endOffset": 94}, {"referenceID": 13, "context": "It has been observed that LSTMs perform poorly in classifying a long pixel-by-pixel sequence of MNIST digits (Le et al., 2015).", "startOffset": 109, "endOffset": 126}, {"referenceID": 13, "context": "Although the previous uses of ReLUs in RNN required careful initialization (Le et al., 2015), SRUs are able to use ReLUs for better learning without an special considerations.", "startOffset": 75, "endOffset": 92}, {"referenceID": 2, "context": "First, we used the polyphonic music datasets from Boulanger-Lewandowski et al. (2012). Each time-step is a binary vector representing the notes played at the respective time-step.", "startOffset": 50, "endOffset": 86}], "year": 2017, "abstractText": "Sophisticated gated recurrent neural network architectures like LSTMs and GRUs have been shown to be highly effective in a myriad of applications. We develop an un-gated unit, the statistical recurrent unit (SRU), that is able to learn long term dependencies in data by only keeping moving averages of statistics. The SRU\u2019s architecture is simple, un-gated, and contains a comparable number of parameters to LSTMs; yet, SRUs perform favorably to more sophisticated LSTM and GRU alternatives, often outperforming one or both in various tasks. We show the efficacy of SRUs as compared to LSTMs and GRUs in an unbiased manner by optimizing respective architectures\u2019 hyperparameters in a Bayesian optimization scheme for both synthetic and realworld tasks.", "creator": "LaTeX with hyperref package"}}}