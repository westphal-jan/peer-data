{"id": "1103.3240", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Mar-2011", "title": "Decentralized Constraint Satisfaction", "abstract": "Constraint satisfaction problems (CSPs) lie at the heart of many modern industrial and commercial tasks. An important new collection of CSPs has recently been emerging that differ from classical problems in that they impose constraints on the class of algorithms that can be used to solve them. In computer network applications, these constraints arise as the variables within the CSP are located at physically distinct devices that cannot communicate. At each instant, every variable only knows if all its constraints are met or at least one is not. Consequently, the CSP's solution must be found using a decentralized approach. Existing algorithms for solving CSPs are either centralized or distributed, both of which violate these algorithmic constraints. In this article we present the first algorithm for solving CSPs that fulfills these new requirements. It is fully decentralized, making no use of a centralized controller or message-passing between variables. We prove that this algorithm converges with probability one to a satisfying assignment whenever one exists. Surprisingly, we experimentally demonstrate that the time the algorithm takes to find a satisfying assignment is competitive with both WalkSat and Survey Propagation, two popular and efficient CSP solvers. That is, despite its decentralized nature the algorithm is remarkably fast. This raises new questions about the relationship between information sharing and algorithm performance.", "histories": [["v1", "Wed, 2 Mar 2011 15:00:09 GMT  (434kb)", "https://arxiv.org/abs/1103.3240v1", null], ["v2", "Mon, 25 Jul 2011 14:44:16 GMT  (122kb,D)", "http://arxiv.org/abs/1103.3240v2", null], ["v3", "Wed, 7 Sep 2011 11:00:47 GMT  (103kb,D)", "http://arxiv.org/abs/1103.3240v3", null], ["v4", "Tue, 9 Oct 2012 07:46:22 GMT  (105kb,D)", "http://arxiv.org/abs/1103.3240v4", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["k r duffy", "c bordenave", "d j leith"], "accepted": false, "id": "1103.3240"}, "pdf": {"name": "1103.3240.pdf", "metadata": {"source": "CRF", "title": "Decentralized Constraint Satisfaction", "authors": ["K. R. Duffy"], "emails": [], "sections": [{"heading": null, "text": "I. INTRODUCTION\nA Constraint Satisfaction Problem (CSP) consists of N variables, ~x := (x1, . . . , xN ), and M clauses, i.e. {0, 1}- valued functions, (\u03a61(~x), . . . ,\u03a6M (~x)). An assignment ~x is a solution if all clauses simultaneously evaluate to 1. In the context of wireless networks, we show that CSPs provide a unifying framework that encompasses many important resource allocation tasks. Examples include: allocation of radio channels so that transmissions by neighbouring WLANs (Wireless Local Area Networks) or mobile phone cells do not interfere; the selection of packets to be XORed on each link in network coding; and finding a non-colliding schedule of time-slots in a WLAN. Unlike in traditional CSPs, however, in network applications each constrained variable xi is typically co-located with a physically distinct device such as an access point, base-station or a link. The resulting communication constraints impose severe restrictions on the nature of the algorithm that can be used for solving the CSP. These restrictions are violated by existing CSP solvers, leading us to define a new class of algorithms that we term decentralized CSP solvers. We constructively establish the existence of decentralized solvers by introducing a family of randomized algorithms belonging to this class.\nRoughly speaking, decentralized CSP solvers must be capable of finding a satisfying assignment, ~x, while updating each variable xi based solely on knowledge of whether all of the clauses in which xi participates are satisfied or at least one\nThis material is based upon works supported by Science Foundation Ireland under Grant No. 07/IN.1/I901.\nclause is unsatisfied. The following example gives a concrete illustration of the origins of these constraints."}, {"heading": "A. Motivating example: channel allocation", "text": "802.11 WLANs are ubiquitous, but their deployments are unstructured and they operate in an unlicensed frequency band. Within this band, an 802.11 WLAN can select one of several channels, typically 11, to operate on. In the vast majority of WiFi routers channel selection is, at present, based on operator selection without any quantitative instruction from the router. Self-selection of this channel is the task we consider here. Co-ordinated selection is hampered by the fact that the interference range of a typical 802.11 device is substantially larger than its communication range. Consequently, WLANs can interfere but may be unable to decode each others messages (illustrated schematically in Fig. 1). Discovery by a WLAN of the existence of interfering WLANs via its wired back-haul may be prevented by firewalls and, in any case, these WLANs may not know their physical location. These practical restrictions mandate a decentralized channel-selection algorithm.\nWe can identify the task of each WLAN self-selecting a non-interfering channel with a CSP with communication constraints imposed by the network topology. Let xi be the channel selected by WLAN i \u2208 {1, . . . , N} and define M = N(N \u2212 1)/2 clauses, one for each pair of WLANs, that evaluates to one if the WLANs are on non-interfering channels or are out of interference range and is zero otherwise. Due to the unstructured nature of the deployment, the lack of shared administrative control and communication constraints, a WLAN cannot rely on knowing the number or the identity of interfering WLANs or the channels that they currently have selected. A practical CSP solver for this task can only rely on each WLAN being able to measure whether: (i) all of the neighbouring WLANs have selected a different channel from it; or (ii) if one or more neighbours have selected the same channel.\nIn certain settings, a limited amount of communication of variable values between the stations hosting them may be feasible. For example, it may be possible for stations hosting a link or for a WLAN to overhear beacons or traffic from a subset of its interferers, or for an access point to communicate with other, nearby access points. Algorithms for channel selection that are proposed in the literature assume the existence of end-to-end communication for centralized solutions, for message passing in decentralized or gossiping solutions, or to co-ordinate global restart in simulated annealing proposals e.g. [1], [2], [3], [4] and references therein. This\nar X\niv :1\n10 3.\n32 40\nv4 [\ncs .A\nI] 9\nO ct\n2 01\n2\n2\ninformation, however, tends to be opportunistic in nature and cannot be relied on a priori. We leave how best to exploit such partial information to future work, focusing here on the most challenging, fundamental cases where fully decentralized algorithms are required."}, {"heading": "B. Contribution", "text": "The primary contributions of this paper are fourfold. Firstly, we show that CSPs provide a unifying framework that encompasses several important problems in wireless networks, including channel selection, inter-session network coding and decentralized scheduling in a WLAN. Each of these problems is generally thought of as being distinct and requiring different solution approaches. We show that they are fundamentally related as CSPs so that the decentralized CSP solver introduced in this paper can be used for all of them. Secondly, we define a new class of CSP algorithms which we term decentralized CSP solvers and, extending our earlier approach to graph colouring [5][6], introduce a novel stochastic decentralized CSP solver proving that it will find a solution in almost surely finite time, should one exist, and showing it has many practically desirable properties. Thirdly, we benchmark the algorithm\u2019s performance on a well-studied class of application-agnostic CSPs, random k-SAT. For problems with up to a thousand variables, which are large for our motivating examples, we find that the time the algorithm takes to find a satisfying assignment is close to that of WalkSAT [7], a well regarded, efficient centralized CSP solver, while also possessing desirable features of Survey Propagation [8]. That is, despite its decentralized nature, the algorithm is fast. Fourthly, we demonstrate the solver\u2019s practical utility in a complex, wireless resource allocation case study.\nThe rest of the paper is organized as follows. In Section II we define decentralized CSP solvers and show that wellknown algorithms for solving CSPs fail to meet these criteria. In Section III we introduce a decentralized CSP solver. We prove that it finds a solution in finite time with probability one whenever a feasible solution exists, obtaining an upper bound on the algorithm\u2019s convergence rate in the process. In Section\nIV we consider its speed at identifying solutions of instances of random k-SAT. In Section V we demonstrate the algorithm\u2019s utility in solving the problems that motivated its introduction. Section VI contains discussion and closing remarks."}, {"heading": "II. DECENTRALIZED CSP SOLVERS", "text": "We begin by formalizing the criteria that CSP solvers must possess to be of use for problems with communication constraints such as those outlined above. We call algorithms that meet these criteria decentralized CSP solvers.\nDefinition 1 (CSP): A CSP with N variables, {x1, . . . , xN}, and M clauses is defined as follows. The variables each take values in a finite set D = {1, . . . , D} and ~x := (x1, . . . , xN ) \u2208 DN . Each clause m \u2208M = {1, . . . ,M} is defined by a function \u03a6m : DN 7\u2192 {0, 1} where for an assignment of variables, ~x, \u03a6m(~x) = 1 if clause m is satisfied and \u03a6m(~x) = 0 if clause m is not satisfied. An assignment ~x is a solution to the CSP if all clauses are simultaneously satisfied. That is,\n~x is a satisfying assignment iff min m\u2208M \u03a6m(~x) = 1. (1)\nThis encompasses all of our examples of interest as well as k-SAT, the most well-studied general class of CSPs.\nA CSP solver is an algorithm that can find a satisfying variable assignment for any solvable CSP.\nDefinition 2 (CSP Solver): A CSP solver takes a CSP as input and determines a sequence {~x(t)} such that for any CSP that has satisfying assignments:\n(D1) for all t sufficiently large ~x(t) = ~x for some satisfying assignment ~x; (D2) if t\u2032 is the first entry in the sequence {~x(t)} such that ~x(t\u2032) is a satisfying assignment, then ~x(t) = ~x(t\u2032) for all t > t\u2032.\nTo provide criteria that classify CSP solvers as being decentralized, we begin with the following definition.\nDefinition 3 (Clause participation): We say that variable xi participates in clause \u03a6m(~x) if the value of xi can influence the clause\u2019s satisfaction for at least one assignment of the rest of the variables in ~x.\nFor each variable xi, let Mi denote the set of clauses in which it participates:\nMi = \u22c3\nxi\u2208{1,...,d}\n\u22c3 j 6=i \u22c3 xj\u2208{1,...,d} {m : \u03a6m(xi, {xj}) = 0}\n\u22c2 \u22c3 j 6=i \u22c3 xj\u2208{1,...,d} {m : \u03a6m(xi, {xj}) = 1}  . Re-writing the left hand side of eq. (1) in a way that focuses\non the satisfaction of each variable we have:\n~x is a satisfying assignment iff min i min m\u2208Mi \u03a6m(~x) = 1. (2)\nA decentralized CSP algorithm can be thought of as having intelligence co-located with each variable. The intelligence at variable xi can only determine whether all of the clauses that xi participates in are satisfied or that at least one clause\n3 is unsatisfied and must make update decisions locally based solely on this knowledge.\nDefinition 4 (Decentralized CSP Solver): A decentralized CSP solver is a CSP solver that for each variable xi, i \u2208 {1, . . . , N}, must select its next value based only on an evaluation of\nmin m\u2208Mi \u03a6m(~x). (3)\nThat is, for each variable xi the solver must make a decision on the next value of xi based solely on knowing whether that variable is currently satisfied or not without explicitly knowing:\n(D3) the assignments of other variables, xj for any j 6= i; (D4) the set of clauses that any variable, including itself, participates in, Mj for j \u2208 {1, . . . , N}; (D5) the functions that define clauses, \u03a6m for m \u2208\n{1, . . . ,M}. Note that the properties (D1) (D2) of any CSP solver mean that a decentralized CSP solver must, without explicit communication, settle upon a satisfying assignment the first time one is found. Communication to co-ordinate global stopping or restarting of the solver would be contrary to the nature of the natural constraints of these problems and so is forbidden.\nThe stochastic algorithm we define in Section III shall provably satisfy the properties of a decentralized CSP solver with probability one. Moreover, it will also have the desirable property that it will automatically restart its search, without communication, upon any change to the clauses of a CSP that makes the current variable assignment no longer satisfying. This is significant in practical applications as, for example, the arrival of new transmitters in a wireless network would induce a change the associated CSP."}, {"heading": "A. Formulating Wireless Network Tasks As CSPs", "text": "Before proceeding, we demonstrate that several important resource allocation tasks in wireless networks fall within this CSP framework, which, therefore, provides a unifying framework for analyzing these tasks.\n1) Graph colouring. As briefly described in Section I-A, the channel assignment problem corresponds to decentralized graph colouring. In the simplest model, the network is described by an undirected interference graph G = (V,E) with vertices V and edges E. Each vertex represents a WLAN and an edge exists between two WLANs if they interfere with each other when on the same channel. Define N = |V | and M = |E| and let D denote the set of available colours (channels) and let xi be a variable with value equal to the colour selected by an intelligence co-located with each vertex i \u2208 V . Each clause m \u2208 {1, . . . , |E|}, which is an enumeration of the elements of E, can be identified with an edge (i, j) \u2208 E. We define\n\u03a6m(~x) = \u03a6m(xi, xj) = { 1 if xi 6= xj 0 otherwise.\nThe participation set, Mi, of a variable xi consists of all clauses where the vertex i is one end of the associated edge,\nMi = {m \u2261 (i, j) : (i, j) \u2208 E} .\nA variable assignment satisfies this CSP if and only if it is also a proper colouring for the graph G. Proper colourings correspond to channel assignments in which no two neighbouring WLANs in the interference graph have selected the same channel. To find a proper colouring, when one exists, a decentralized CSP solver requires only that an intelligence co-located with each vertex i can measure whether: (i) all of its neighbours are using a different colour from vertex i; or (ii) at least one neighbour has selected the same colour as vertex i. This information is sufficient to evaluate eq. (3) and, in particular, the intelligence at each vertex does not need to know: (D3) the colour selected by any other vertex; (D4) its set of neighbours; or (D5) the exact nature of the clauses \u03a6m, m \u2208 {1, . . . ,M}.\n2) Channel assignment with channel-dependent interference. Whether or not transmitters interfere in the channel assignment task may depend on the radio channel selected. This can arise due to frequency dependent radio propagation or to channel dependent spectral masks. That is, for regulatory reasons, different spectral masks are typically used when transmitting on channels at the edge and on channels in the middle of a radio band. This problem then has a collection of conflict graphs, one for each possible radio channel. This version of the channel assignment task can also be formulated as a CSP even though it is no longer a graph colouring problem. Let G(c) = (V,E(c)), c \u2208 D be a set of undirected graphs with the same vertices V but possibly differing edge sets E(c). Again each vertex represents a WLAN, but the interference graph is channel-dependent. The Graph G(c) is associated with radio channel c and an edge exists in E(c) if two WLANs interfere while on channel c. Let xi be a variable with value equal to the channel selected by each vertex i \u2208 V . Each clause m \u2208 {1, . . . , |E(1)|+ \u00b7 \u00b7 \u00b7+ |E(D)|}, which is an enumeration of all edges in all graphs, can be identified with a c \u2208 D and an edge (i, j) \u2208 E(c) and is defined by\n\u03a6m(~x) = \u03a6m(xi, xj) = { 0 if xi = xj = c 1 otherwise.\nThe collection of clauses that variable xi, associated with vertex i, participates in can be identified as\nMi = \u22c3 c\u2208D {m \u2261 (i, j, c) : (i, j) \u2208 E(c)} .\nWith xi being the current channel selection of vertex i, for all c 6= xi the clauses associated with m \u2261 (i, j, c) are automatically satisfied. Thus to evaluate eq. (3) it is sufficient for the station to measure if no neighbour coincides with its current channel selection or if at least one does. To find an interference-free channel assignment, a decentralized CSP solver requires that each vertex i can measure whether: (i) all of its neighbours on the currently selected channel are using a different channel from itself; or (ii) at least one neighbour has selected the same channel.\n3) Inter-session network coding. Network coding has been the subject of considerable interest in recent years as it offers the potential for significant increases in network capacity [9], [10], [11]. In network coding, network elements combine packets together before transmission rather than forwarding\n4 them unmodified. The combined packets can be from individual flows, known as intra-flow coding, or across multiple flows, inter-flow coding.\nWhile intra-flow coding within multicast flows has been well studied, inter-flow coding between unicast flows has received less attention, yet is, perhaps, of more immediate relevance to current Internet traffic. Inter-flow coding is known to be challenging [12]. The task of a network finding a feasible linear network code in a distributed fashion, but with some global sharing of calculations, is investigated in [13] through the use of a genetic algorithm. This task can be formulated as a CSP.\nLet G = (V,E) denote a directed acyclic multi-graph representing the network with vertices V and edges E. Each vertex represents either a source of an information flow, a destination or router in the network. Edges represent physical connections between these elements. Time is slotted and each edge can transmit a single packet per slot. We allow multiple edges between vertex pairs in order to accommodate higher rate links. It is the goal of each link beyond the source to determine a linear combination of its incoming packets to forward so that ultimately all flows get to their destinations. As the combination of packets coded by each link will take care of routing, each flow p \u2208 P is defined by its source, \u03c3(p) \u2208 V , and its destination \u03b4(p) \u2208 V . Each flow is assumed to be unit rate with higher rate flows accommodated by flows with the same source and destination vertices. We will treat the collection of source, \u22c3 p\u2208P {\u03c3(p)}, and destination vertices,\u22c3\np\u2208P {\u03b4(p)}, as special, solely having one incoming and one outgoing edge per flow respectively.\nFor each edge i \u2208 E, define s(i), s : E 7\u2192 V , to be its source vertex and t(i), t : E 7\u2192 V , to be its target vertex. For each vertex v \u2208 V we define the set of incoming edges Iv := {i \u2208 E : t(i) = v} and the set of outgoing edges Ov := {i \u2208 E : s(i) = v}. For each edge not corresponding to source, i \u2208 E\\ \u22c3 p\u2208P O\u03c3(p), we associate a variable xi \u2208 D := {1, . . . , 2|P |}, which is an enumeration of the power set of the set of flows P . We define a bijective map \u03c8 : D 7\u2192 {0, 1}|P | that determines a vector whose positive entries correspond to flows to be coded.\nIn total, we have |E \\ \u22c3 pO\u03c3(p)| clauses. One for every link that isn\u2019t an outgoing link from a source vertex. At each time slot, each link that doesn\u2019t correspond to a source or final destination link, i \u2208 E \\ \u22c3 p(O\u03c3(p) \u222a I\u03b4(p)), wishes to forward a packet consisting of XORed packets (corresponding to addition in the Galois field of two elements) from the flows indicated by \u03c8(xi). Each final link i \u2208 \u22c3 p I\u03b4(p) wishes to forward packets from p, which we indicate by the vector \u03b3p with a 1 at the location p and zeros elsewhere. A link and its immediate upstream neighbouring links will be dissatisfied if it cannot do so.\nMore formally, for each edge not corresponding to the outgoing link from a source or incoming link to a destination, i \u2208 E \\ \u22c3 p\u2208P (O\u03c3(p)\u222aI\u03b4(p)), we have a clause m \u2261 i, \u03a6m(~x), defined by\n\u03a6m(xi, xj:j\u2208Is(i)) =\n{ 1 if \u2203 \u03b8 s.t. \u03a8(Is(i))\u03b8T = \u03c8(xi)T\n0 otherwise.\nwhere \u03b8 is a binary vector and \u03a8(Is(i)) is the rectangular matrix consisting of \u03c8(xj)T for j \u2208 Is(i) \\ \u22c3 p\u2208P O\u03c3(p) and and \u03b3Tp if i \u2208 O\u03c3(p) for some p. To complete the CSP, we need to ensure that packets from flow p can be decoded at their destination \u03b4(p). For i \u2208 \u22c3 p\u2208P I\u03b4(p), then with \u03b4(p \u2032) = t(i) we introduce a clause\n\u03a6m(xj:j\u2208Is(i)) = { 1 if \u2203 \u03b8 s.t. \u03a8(Is(i))\u03b8T = \u03b3Tp\u2032 0 otherwise.\nwhere again \u03b8 is a binary vector and \u03a8 is is the rectangular matrix defined above. The set of clauses a link variable xi, i \u2208 E \\ ( \u22c3 p\u2208P O\u03c3(p) \u222a I\u03b4(p)), participates in is\nMi = {m \u2261 j : j = i or i \u2208 Is(j)}\nAny variable assignment then satisfies this CSP if and only if it is a realizable network code satisfying all flow demands.\nHence, to find a proper assignment a decentralized CSP solver requires only that each link i can determine whether: (i) its own coding is realizable and the coding of its immediately down-stream links are realizable; or (ii) if at least one of these is not realizable. This is sufficient to evaluate eq. (3). Each link does not need to explicitly know: (D3) the code selected by any other link; (D4) the network topology; (D5) any details of how code realizability is determined at any link.\n4) Decentralized transmission scheduling. In an Ethernet or WLAN it is necessary to schedule transmissions by stations. This might be achieved in a centralized manner using TDMA, but it can also be formulated as a decentralized problem. The classical CSMA/CA approach to decentralized scheduling never settles to a single schedule and some comes at a cost of the possibility of continual collisions. Recently, there has been interest in decentralized approaches for finding collisionfree schedules, see [14], [15]. This task can be formulated as a CSP as follows. Let V denote the set of transmitters in the WLAN, T denote the set of available time slots and define N = |V | and M = N(N \u2212 1)/2. Let xi be a variable with value equal to the transmission slot selected by transmitter i \u2208 V . Define a clause \u03a6m(~x) associated with each pair of transmitters m \u2261 (i, j) such that\n\u03a6m(xi, xj) = { 1 if xi 6= xj 0 otherwise.\nThe participation sets are Mi = \u22c3 j 6=i {m \u2261 (i, j)}.\nAny variable assignment satisfies this CSP if and only if it is also a collision-free time-slot schedule. To find a collision-free schedule, when one exists, a decentralized CSP solver requires only that each transmitter i can measure whether: (i) all of its neighbours are using a different time-slot from transmitter i; or (ii) at least one transmitter in the WLAN has selected the same time-slot as transmitter i. Again, this is all that is needed to evaluate eq. (3). Each transmitter does not need to know: (D3) the time-slot selected by any other transmitter; (D4) the set of transmitters; (D5) the clauses.\n5"}, {"heading": "B. Related work - existing algorithms are not decentralized", "text": "The literature on general purpose CSP solvers is vast, typically focusing on solving k-SAT problems in conjunctive normal form, but they can be broadly classified into those based on: (i) the Davis-Putnam-Logemann-Loveland (DPLL) algorithm [16], [17]; (ii) Survey Propagation [8]; and (iii) on Stochastic Local Search (SLS) [7]. Each of these approaches has experienced substantial development and has its own merits, but none were motivated by problems where variables have a geographical sense of locality.\nAlgorithms developed from the DPLL approach have proved to be the quickest at SAT-Race and SAT Competition in recent years, e.g. ManySAT [18]. The DPLL approach ultimately guarantees a complete search of the solution space and so meets the (D1) and (D2) criteria. They are, however, based on a branching rule methodology, e.g. [19], that assumes the existence of a centralized intelligence that employs a backtracking search. The implicit assumptions of the information available to this intelligence breaks the conditions (D3) (D4) (D5) and so they are not decentralized CSP solvers.\nSurvey propagation, a development of belief propagation [20] from trees to general graphs, has proved effective in graphs that do not contain small loops [21]. For a given CSP, the fundamental structure of study is a called a factor graph. In order to generate this, it is necessary to know what clauses each variable participates in and the nature of each of the clauses, breaking the (D4) and (D5) criteria and so these are not decentralized CSP solvers.\nSLS algorithms also depend fundamentally upon the exchange of information, mostly in an explicit manner breaking the (D3) condition by basing update decisions on relative rankings of the constraint variables but also in a more subtle fashion. To see this implicit requirement, consider the following algorithm for binary valued variables originally proposed by Papadimitriou [22] and developed further by Scho\u0308ning [23]. Pick a random assignment of values for the constraint variables. Repeat the following: from all of the unsatisfied clauses, pick one uniformly at random, select one of the variables participating in that clause and negate its value, breaking the (D4) and (D5) conditions. The algorithm halts when all clauses are satisfied or a specified time limit expires. Although simple, this forms the basic building block for all SLS algorithms, including the well-studied WalkSAT algorithm [7]. It is important that a single unsatisfied clause is selected at each step and that a single variable within the clause is adjusted as it is this that leads to the algorithm behaving as a random walk [23]. Thus, again, solvers in this class are not decentralized."}, {"heading": "III. A DECENTRALIZED CSP SOLVER", "text": "We now introduce an algorithm that satisfies the decentralized CSP solver criteria."}, {"heading": "A. Communication-Free Learning Algorithm", "text": "An instance of the following Communication-Free Learning (CFL) algorithm is run in parallel for every variable. For each variable, i \u2208 {1, 2, ..., N} it keeps a probability distribution,\npi,j over j \u2208 D as well as the current variable value xi. In pseudocode, the CFL algorithm is:\nALGORITHM 1: Communication-Free Learning 1: Initialize pi,j = 1/d, j \u2208 {1, ..., D}. 2: loop 3: Realize a random variable, selecting xi = j with probability\npi,j . 4: Evaluate minm\u2208Mi \u03a6m(~x), returning satisfied if its value is\n1, as this indicates all of variable i\u2019s clauses are satisfied given the present assignment, and unsatisfied otherwise.\n5: Update: If satisfied,\npi,j = { 1 if j = xi 0 otherwise.\nIf unsatisfied,\npi,j = { (1\u2212 b)pi,j + a/(D \u2212 1 + a/b) if j = xi (1\u2212 b)pi,j + b/(D \u2212 1 + a/b) otherwise,\nwhere a, b \u2208 (0, 1] are design parameters. 6: end loop\nTo understand the logic behind CFL, note that for each variable a probability distribution over all possible variablevalues is kept. The variable\u2019s value is then selected from this distribution. Should all the clauses that the variable participates in be satisfied with its current value, the associated probability distribution is updated to ensure that the variable value remains unchanged. If at least one clause is unsatisfied, then the probability distribution evolves by interpolating between it and a distribution that is uniform on all values apart from on the one that is presently generating dissatisfaction. Thus if all of a variable\u2019s clauses were once satisfied, the algorithm retains memory of this into the future. This has the effect that if a collection of variables are content, they can be resistant, but not impervious, to propagation of dissatisfaction from other variables.\nCFL possesses two parameters. The parameter b determines how quickly the past is forgotten, while a determines the algorithm\u2019s aversion to a variable value should it be found to cause dissatisfaction. Even though an instance of CFL is run for each variable, we shall show that this completely decentralized solution is a CSP solver.\nFrom here on we will assume that the update Step 5 is performed in a synchronized fashion across variables. Without synchronization, the fundamental character of the algorithm doesn\u2019t change, but the analysis becomes more involved. Synchronization solely requires that algorithm instances each have access to a shared sense of time and that this can be achieved without information-sharing or other communication between variables, i.e. between algorithm instances. A suitable clock is, for example, available to any Internet connected device via the Network Time Protocol (NTP)."}, {"heading": "B. CFL is a decentralized CSP solver", "text": "By construction, the only information used by the algorithm is minm\u2208Mi \u03a6i(~x) in Step 4 and thus it satisfies the criteria (D3) , (D4) and (D5) . That is, it only needs to know if all\n6 clauses in which variable i participates are satisfied or if one or more are not. The CFL algorithm also satisfies the (D2) criterion that it sticks with a solution from the first time one is found. To see this, note that the affect of Step 5 is that if a variable experiences success in all clauses that it participates in it continues to select the same value with probability 1. Thus if all variables are simultaneously satisfied in all clauses, i.e. if mini minm\u2208Mi \u03a6i(~x) = 1, then the same assignment will be reselected indefinitely with probability 1.\nTo establish that the CFL algorithm is a decentralized CSP solver all that remains is to show that it meets the (D1) criterion, that if the problem has a solution it will be found, which is dealt with by the the following theorem. It provides an upper bound on the distribution of the number of iterations the algorithm requires to find a solution to any solvable CSP. It\u2019s proof exploits the iterated function system structure of the algorithm and can be found in the Appendix.\nTheorem 1: For any satisfiable CSP, with probability greater than 1 \u2212 \u2208 (0, 1) the number of iterations for the CFL algorithm to find a satisfying assignment is less than\nN exp\n( N(N + 1)\n2 log(\u03b3\u22121)\n) log( \u22121),\nwhere \u03b3 = min(a, b)\nD \u2212 1 + a/b .\nFor a CSP corresponding to graph coloring, a tighter bound holds and a satisfying assignment will be found with probability greater than 1\u2212 in a number of iterations less than\nN exp(2N log(\u03b3\u22121)) log( \u22121).\nTheorem 1 proves that for fixed N the tail of the distribution of the number of iterations until the first identification of a satisfying assignment is bounded above by a geometric distribution and so all of its moments are finite. As Theorem 1 covers any arbitrary CSP that admits a solution, for any given instance these bounds are likely to be loose. They do, however, allow us to conclude the following corollary proving that if a solution exists, the CFL algorithm will almost surely find it.\nCorollary 2: For any CSP that admits a satisfying assignment, the CFL algorithm will find a satisfying assignment in almost surely finite time.\nHence the CFL algorithm satisfies all of the criteria (D1) (D2) (D3) (D4) (D5) , almost surely, and so is a decentralized CSP solver."}, {"heading": "C. Parameterization", "text": "Theorem 1 establishes that the CFL algorithm provably identifies satisfying assignments for all values of its two design parameters, a and b. The value of a determines the algorithm\u2019s aversion to variable values for which clause failure has been experienced. The value of b impacts on the speed of convergence of the algorithm. Optimal values of a and b depend upon each problem and a performance metric. For fast convergence across a broad range of CSPs with distinct structure, we have found that small values of a and b, corresponding to strong aversion to a dissatisfying variable value and reasonably long memory, work well. Thus for simplicity, we set a = b in all\nexperimental examples. We use b = 0.2 for random 3-SAT, b = 0.1 for random 4-SAT and b = 0.05 for random 5-SAT. We use b = 0.1 for our wireless networks example, a value which we have found to yield good performance across a range of k-SAT problems."}, {"heading": "IV. APPLICATION-AGNOSTIC BENCHMARKING", "text": "A CSP associated with a specific networking task will possess structure induced by its topology. Before considering practically-motivated applications in Section V, as the CFL algorithm can solve any CSP but its design was subject to restrictions not normally considered it is prudent to investigate its performance as a CSP solver in an application-agnostic setting.\nWe present simulation data evaluating the performance of the CFL algorithm for random k-SAT, a well-studied class of CSPs. A k-SAT problem is a CSP in which all variables are binary-valued and clauses consist solely of logical disjunctions of no more than k variables. In random k-SAT, an instance of k-SAT is generated by drawing M such clauses uniformly at random [22]. Our investigation surprisingly reveals that the CFL algorithm is competitive with centralized and distributed solvers on problems of reasonable size (order 1000 variables).\nBriefly, we first review current knowledge regarding random k-SAT. The behavior of random k-SAT is known to depend strongly on the parameter r = M/N with phase transitions and associated thresholds r\u00acexist,k and rexist,k. If r > r\u00acexist,k the constraint problem is unsatisfiable with high probability, while if r < rexist,k a satisfying assignments exist with high probability. Evidently, rexist,k \u2264 r\u00acexist,k and it is conjectured that rexist,k = r\u00acexist,k [25]. A simple argument gives r\u00acexist,k \u2264 2k log 2 and this upper bound can be refined to obtain the values in the second row of Table I. Also shown in row four of this table are estimated values for r\u00acexist,k derived from statistical physics considerations. These latter estimates are supported by experimental data for k = 3, e.g. [30], although there are fewer experimental studies for k > 3. It can be seen that the theoretical bound for r\u00acexist,k and the estimated values are in good agreement for k \u2265 5, and that both approach 2k log 2 for large k. Recent mathematical results have established that rexist,k \u2265 2k log 2\u2212k [24] and this lower bound can be tightened to obtain the theoretical values shown in the third row of Table I.\nThere also exists a threshold rpoly,k below which a satisfying assignment can be found in polynomial time with high probability. This threshold has been the subject of much interest and the current best analytic lower bound for rpoly,k is also indicated in Table I. Statistical physics considerations have led to the conjecture that rpoly,k is equal to the value r1RSB,k at which the one-step replica symmetry breaking (1RSB) instability occurs [31]. Current best estimates for this value are given in Table I. For k \u2265 8, it has been proven analytically that the set of satisfying assignments is grouped into widely separated clusters, which lends support to this conjecture [32]. For values of k < 8 the situation is less clear, with experimental evidence indicating that rpoly,k lies above r1RSB,k for k = 3, 4 and 5 [33].\nWe now consider the performance of the CFL algorithm. Fig. 2 gives median measurements of normalized stopping time (stopping time divided by N ) of the CFL algorithm vs r=M/N when the number of variables N = 100. Fig. 3 gives median measurements of normalized stopping time vs N with r held constant. Data is shown for random k-SAT with k = 3, 4 and 5. Observe two striking features from this data. Firstly, from Fig. 2 noting that a log scale is used on the y-axis, the median normalized stopping time increases exponentially with r when N is held constant . Secondly, from Fig. 3 the median normalized stopping time vs N , with r held constant, is upper bounded by a constant. That is, a satisfying assignment is found in a time with median value that increases no more than linearly with N . This linearity holds even when r is close to rexist,k (data is shown in Fig. 3 for 3-SAT with r = 4) and is of great practical importance as it implies that with high probability the CFL algorithm finds a satisfying assignment in polynomial time.\nComparing the performance of the CFL algorithm with the popular WalkSAT algorithm, we note that the WalkSAT algorithm also exhibits an exponential-like dependence of stopping time on r and linearity in N [30], [34], [33]. To allow comparison in more detail, median stopping time data taken from [30, Fig 2a] is marked on Fig. 2. For r < 3.9, the median stopping time is similar for CFL and WalkSAT. Above this value, however, the stopping time for WalkSAT diverges, increasing super-exponentially in r. This divergence is a feature not only of WalkSAT but also of other local search algorithms algorithms e.g. ChainSat [33]. It is not exhibited by the Survey Propagation algorithm [30], [8], which has been the subject of considerable interest as it creates the ability to operate close to the rexist,k threshold. Observe that the CFL algorithm also does not exhibit divergence as r approaches rexist,k. These comparisons are encouraging as they indicate that the CFL algorithm is competitive with some of the most efficient general-purpose k-SAT algorithms currently available. It is also unexpected as information sharing is a key component of both WalkSAT and Survey Propagation, whereas CFL makes local decisions simultaneously with no use whatsoever of information-sharing, raising fundamental questions as to the role of message passing, the relationship between information exchange and algorithm performance and, in particular, what performance cost is imposed by constraining attention to decentralized operation.\n8"}, {"heading": "V. CASE STUDY: CHANNEL ALLOCATION IN 802.11", "text": "WLANS\nHaving established general properties of CFL and determined its performance on random instances of k-SAT, we return to a problem of the sort that motivated its introduction. We consider the performance of the CFL algorithm in a realistic wireless network case study. From the online database WIGLE [35] we obtained the locations of WiFi wireless Access Points (APs) in an approximately 150m2 area at the junction of 5th Avenue and 59th Street in Manhattan1. This space contains 81 APs utilizing the IEEE 802.11 wireless standard. It can be seen from Figure 4, which plots the mean number of APs lying within distance d of an AP, that within a 15m radius an AP has on average 3 neighbours and within a 30m radius it has on average 10 neighbours. Of the 11 channels available in the 802.11 protocol, only 3 are orthogonal. Thus managing interference in this dense deployment is a challenging task.\nImagine a worst-case scenario where after a power-outage all these APs are switched back on. The aim of each AP is to select its radio channel in such a way as to ensure that it is sufficiently different from nearby WLANs. This can be written as a CSP where we have N = 81 APs and N variables xi corresponding to the channel of AP i, i = 1, 2, ..., N . As per the 802.11 standard [36] and FCC regulations, each AP can select from one of 11 radio channels in the 2.4GHz band and so the xi, i = 1, 2, .., N take values in D = {1, 2, .., 11}. To avoid excessive interference each AP requires that: (a) no other AP within a 5m distance operates closer than 3 channels away; (b) no AP within a 10m distance operates closer than 2 channels away and (c) no AP with a 30m distance operates on the same channel. We can realize this as a CSP with 3 constraint clauses per AP, giving 3N in total, \u03a6m(~x), m = 1, ..., 3N . With e(i, j) denoting the Euclidean distance between APs i and j in metres, for m = 1, ..., N\n\u03a6m(~x) = { 1 if minj:e(m,j)<5 |xm \u2212 xj | \u2265 3 0 otherwise,\nfor m = N + 1, ..., 2N\n\u03a6m(~x) = { 1 if minj:e(m\u2212N,j)<10 |xm\u2212N \u2212 xj | \u2265 2 0 otherwise,\nand for m = 2N + 1, ..., 3N\n\u03a6m(~x) = { 1 if minj:e(m\u22122N,j)<30 |xm\u22122N \u2212 xj | \u2265 1 0 otherwise,\nThe attenuation between adjacent channels is \u221228dB [36]. Taking the radio path loss with distance as d\u03b1, where d is distance in meters and \u03b1 = 4 the path loss exponent, then these constraints ensure > 60 dB attenuation between APs.\nAssuming all APs use the maximum transmit power of 18dBm allowed by the 802.11 standard, this means that the SINR is greater than 20dB within a 10m radius of each AP which is sufficient to sustain a data rate of 54Mbps when the\n1The extracted (x,y,z) coordinate data used is available online at www. hamilton.ie/net/xyz.txt\nconnection is line of sight and channel noise is Gaussian [36], [37].\nObserve that each variable xi is located at a different AP. The APs do not belong to a single administrative domain and so security measures such as firewalls prevent communication over the wired network. An AP cannot rely on decoding wireless transmissions to communicate with all of its interferers or even just to identify them. This is because interferers may be too far away to allow their transmissions to be decoded and yet still their aggregate transmission power may be sufficiently powerful to create significant interference. That is, an AP cannot know the channel selections of other APs, condition (D3) and, moreover, cannot reliably identify or enumerate the clauses in which it participates, condition (D4) . A decentralized algorithm is therefore mandated.\nFig. 5 shows an example satisfying assignment of radio channels obtained by running an instance of the CFL algorithm at all APs. The complexity of the topology generated by the physical location of the APs and the non-uniformity of the clauses it causes is apparent.\nFig. 6 shows the measured distribution of number of itera-\n9 0 50 100 150 200 250 300 350 400 450 50010 \u22124 10\u22123 10\u22122 10\u22121 100\nX\nPr ob\n(S to\npp ing\ntim e\n> X)\nFig. 6. Log of the empirical complementary cumulative distribution of convergence time in iterations, based on 12,000 runs of CFL algorithm for 5th Avenue data. The median is 21 and the 95% percentile is 98 iterations. In current hardware one iteration can readily be performed in under 10 seconds, leading to a median time to convergence of less than 4 minutes.\ntions required to find a satisfying assignment, whereupon the algorithm natural halts in a decentralized fashion. The median value is 21 iterations and the 95% centile is 98 iterations. Note that during this convergence period, although the network is operating sub-optimally, it does not cease to function. In a prototype lab set-up we have shown that a CFL update interval of less than 10 seconds is feasible on current hardware. Thus the median time to convergence is under 4 minutes. This is a reasonable time-frame for practical purposes, particularly as subparts of the network are functioning during this convergence period, and thus the CFL algorithm offers a pragmatic solution to this difficult decentralized CSP for which existing solvers could not be employed."}, {"heading": "VI. CONCLUSIONS", "text": "We have shown that apparently distinct problems in networking can be placed within the framework of CSPs, where - unlike with traditional motivating examples - the variables are co-located with devices that may not be able to communicate. We define the criteria that practical solvers must possess in order to be suitable for theses problems, labeling them decentralized CSP solvers.\nAs existing solvers fail to meet one or more of these criteria, we introduce a decentralized algorithm for solving CSPs. We prove that it will almost surely find a satisfying solution if one exists. In doing so, we generate bounds for the speed of convergence of the algorithm. We suspect, however, that our bounds for a general CSP are not tight and conjecture that the real bound should be closer to the one we have for the specific case of CSPs corresponding to graph coloring.\nGiven how much information decentralization is sacrificing, surprisingly an experimental investigation of solving random k-SAT instances suggests that the algorithm is competitive with two of the most promising centralized k-SAT solvers, WalkSAT and Survey Propagation, on instances of random kSAT with order one thousand variables. This raises the question: what is the performance cost of decentralized operation? This is particularly pertinent as the decentralized nature of the\nCFL algorithm lends itself to parallelized computation as it has a small, fixed memory requirement per variable, making it suitable for use in circumstances where a centralized algorithm could also be used but would be difficult to implement in a distributed fashion.\nAPPENDIX\nFor each i \u2208 {1, . . . , N} let ~pi(t) \u2208 [0, 1]D, t \u2208 N, be the CFL probability vector for variable i at time t and xi(t) be the variable\u2019s value selected stochastically from ~pi(t). Let P (t) = (~p1(t), . . . , ~pN (t)) and X(t) = (x1(t), . . . , xN (t)) record the overall state of the CSP-CFL system.\nThe state of the probability vectors {P (t)} forms a Markov Chain, or Iterated Function System, with place dependent probabilities [38]. The convergence time of the algorithm is the first time the chain enters an absorbing state representing a valid solution to the CSP. The absorbing states are identifiable in terms of the variable values {X(t)}:\nA = \u22c3 {~x : \u03a6m(~x) = 1 for all m \u2208M} ,\nas if X(t) \u2208 A, then P (t+1) = (\u03b4x1 , . . . , \u03b4xN ) so that X(t+ 1) = X(t) almost surely and hence a solution to the CSP has been found. The algorithm\u2019s stopping time is\n\u03c4 := inf t\u22650 {X(t) \u2208 A} .\nDefine \u03b3 = min(a, b)/(D \u2212 1 + a/b) and let S be the set of states such that for all i \u2208 N either pi = \u03b4k for some k \u2208 {1, \u00b7 \u00b7 \u00b7 , D} or (pi)k \u2265 \u03b3 for all k \u2208 {1, \u00b7 \u00b7 \u00b7 ,M}. The next lemma is obvious.\nLemma 1: For any integer t \u2265 0, P (t) \u2208 S. Theorem 1: The method of proof for both statements is similar: we create a sequence of events over N \u2212 1 iterations that, regardless of the initial configuration, lead to a satisfying assignment with a probability that we find a lower bound for. Due to the Markovian nature of the algorithm and the independence of the probability of this event on its initial conditions, if this event does not occur in N \u2212 1 iterations, it has the same probability of occurring in the next N \u2212 1 iterations. This is what leads to the geometric nature of the bounds. The difference between a general CSP and those corresponding to coloring is that for the latter the variables are ensured to experience fewer dissatisfaction events before finding a satisfying assignment.\nFirst consider a general CSP. Select an arbitrary valid solution ~a \u2208 A with components (~a)i. For each m \u2208 M define Nm to be the variables that participate in clause m. For each t \u2265 0, define the set of unsatisfied variables at time t by\nUt := \u22c3\nm\u2208M {Nm : \u03a6m(X(t)) = 0}\nand the number of unsatisfied variables to be nt = |Ut|. At time 0 assume X(0) = ~x(0), some ~x(0). If U0 = \u2205 then X(0) \u2208 A, the algorithm has found a solution and \u03c4 = 0. If\n10\nU0 6= \u2205, the algorithm has not yet found a solution. Define the components, ~x(1)i, of the vector ~x(1) by\n~x(1)i = { ~ai if i \u2208 U0 ~x(0)i if i /\u2208 U0\nand, by Lemma 1,\nP (X(1) = ~x(1)|X(0) = ~x(0)) \u2265 \u03b3n0 .\nIf U1 = \u2205 then X(1) \u2208 A, the algorithm has found a solution and \u03c4 = 1. If U1 6= \u2205, the algorithm has not yet found a solution and we proceed in an iterative fashion. For t \u2265 0, define the components, ~x(t+ 1)i, of the vector ~x(t+ 1) by\n~x(t+ 1)i = { ~ai if i \u2208 Ut ~x(t)i if i /\u2208 Ut\nand, by Lemma 1,\nP (X(t+ 1) = ~x(t+ 1)|X(t) = ~x(t)) \u2265 \u03b3nt .\nLet t\u2217 = inf{t : nt = 0} and note that\nP (X(t\u2217) \u2208 A) \u2265\nP (X(t\u2217) = ~x(t\u2217), . . . , X(0) = ~x(0)) \u2265 \u03b3 \u2211t\u2217 t=0 nt .\nWe wish, therefore, to place an upper bound on the sum in the exponent. Observe that t\u2217 \u2264 N \u2212 1, as one starts with at least one unsatisfied variable at each stage we me must include at least one new variable and, therefore, this procedure must terminate in no more than N\u22121 steps with a valid assignment.\nIn general, the {n\u2217t } sequence that maximizes this sum, even though this sequence may not be feasible for a given CSP, is\nn\u22170 = 1, n \u2217 1 = 2, . . . , n \u2217 N\u22121 = N,\nThis occurs if we start with one unsatisfied variable and, in changing to the valid solution, at each iteration one additional variable has cause to be unsatisfied. On taking its new value, the unsatisfied variable included at time t triggers the failure of t\u2212 1 clauses each of which contains 3 variables: itself, the variable included immediately previously and one of the other variables that has already experienced a failure. This gives\nt\u2217\u2211 t=0 nt \u2264 N\u2211 t=0 n\u2217t = N(N + 1) 2 .\nand therefore\nP (X(N \u2212 1) \u2208 A) \u2265 \u03b3N(N+1)/2.\nFor a CSP corresponding to graph coloring with D colours, the advantage is that variables cannot be dissatisfied indefinitely by newly dissatisfied variables. Instead this procedure generates a flame-front of dissatisfied variables where those variables sufficiently far within the interior of this flamefront can select their final value without further disturbance. For graph colouring, clauses occur only for each pair of neighbors, i and j, such that \u03a6(~x) = 0 if (~x)i = (~x)j and \u03a6(~x) = 1 otherwise. For any initial configuration ~x(0) with dissatisfaction, we must have n0 \u2265 2. In a sequence of events analogous to those in the proof of [6][Theorem 3], these two variables select their final values, ~ai and (~a)j , at the next\nround, causing their initial clause to be satisfied as ~a \u2208 A. If either of the variables taking its final value causes no further clause to be dissatisfied, then in this sequence of events it will never appear in a dissatisfied clause again and stays with its value with probability 1. If it does cause one or more clause to be triggered, once these are satisfied it will experience no more dissatisfaction. Thus each variable experiences at most 2 rounds of dissatisfaction so that for graph colouring:\nt\u2217\u2211 t=0 nt \u2264 N\u22121\u2211 t=0 n\u2217t = 2N.\nAs an example that illustrates the difference between a general CSP and graph colouring, consider an instance of 3- SAT starting with one unsatisfied variable, x1. The following sequence of clauses is possible in general, but not with graph colouring. Starting with an unsatisfied x1, changing its value to satisfy the first clause causes x2 to be dissatisfied, which in turn causes x1 and x2 and x3 to be dissatisfied:\nx1, \u00acx1 \u2228 x2 and \u00acx1 \u2228 \u00acx2 \u2228 x3.\nSatisfying these clauses for x1, x2 and x3 causes two more clauses with x4 to trigger, keeping all variables unsatisfied:\n\u00acx1 \u2228 \u00acx2 \u2228 x4 and \u00acx1 \u2228 \u00acx3 \u2228 x4.\nSatisfying these two clauses causes three further clauses involving x5 to become unsatisfied:\n\u00acx1 \u2228 \u00acx2 \u2228 x5, \u00acx1 \u2228 \u00acx3 \u2228 x5 and \u00acx1 \u2228 \u00acx4 \u2228 x5 and so forth triggering clauses with three variables at a time such that all variables are unsatisfied until a solution is found."}], "references": [{"title": "Distributed channel assignment and routing in multiradio multichannel multihop wireless networks", "author": ["H. Wu", "Fan Y. Yang", "K. Tan", "J. Chen", "Q. Zhang", "Z. Zhang"], "venue": "IEEE Trans. Wireless Commun., vol. 9, no. 10, pp. 1972\u20131983, 2006.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1972}, {"title": "Self organization of interfering 802.11 wireless access networks", "author": ["B. Kauffmann", "F. Baccelli", "A. Chaintreau", "V. Mhatre", "K. Papagiannaki", "C. Diot"], "venue": "IEEE INFOCOM, 2007.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Protocols and architectures for channel assignment in wireless mesh networks", "author": ["J. Crichigno", "M.-Y. Wu", "W. Shu"], "venue": "Ad Hoc Netw., vol. 6, no. 7, pp. 1051\u20131077, Sept. 2008.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2008}, {"title": "Minimum interference channel assignment in multiradio wireless mesh networks", "author": ["A.P. Subramanian", "H. Gupta", "S.R. Das", "J. Cao"], "venue": "IEEE Trans. Mobile Comput., vol. 7, no. 12, pp. 1459\u20131473, Dec. 2008.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "A self-managed distributed channel selection algorithm for WLANs", "author": ["D.J. Leith", "P. Clifford"], "venue": "Procedings of RAWNET, Boston, MA, 2006.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2006}, {"title": "Complexity analysis of a decentralised graph colouring algorithm", "author": ["K. Duffy", "N. O\u2019Connell", "A. Sapozhnikov"], "venue": "Inform. Process. Lett., vol. 107, no. 2, pp. 60\u201363, 2008.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2008}, {"title": "Local search strategies for satisfiability testing", "author": ["B. Selman", "H. Kautz", "B. Cohen"], "venue": "DIMACS SERIES IN DISCRETE MATHEMATICS AND THEORETICAL COMPUTER SCIENCE, 1995, pp. 521\u2013532.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1995}, {"title": "Survey propagation: An algorithm for satisfiability", "author": ["A. Braunstein", "M. Mezard", "R. Zecchina"], "venue": "Rand. Struct. Algorithms, vol. 27, no. 2, pp. 201\u2013226, 2005.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "An algebraic approach to network coding", "author": ["R. Koetter", "M. M\u00e9dard"], "venue": "IEEE/ACM Trans. Network., vol. 11, pp. 782\u2013795, 2003.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2003}, {"title": "Network coding for wireless applications: A brief tutorial", "author": ["S. Deb", "M. Effros", "T. Ho", "D.R. Karger", "R. Koetter", "D.S. Lun", "M. M\u00e9dard", "N. Ratnakar"], "venue": "IWWAN, 2005.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2005}, {"title": "XORs in the air: practical wireless network coding", "author": ["S. Katti", "H. Rahul", "W. Hu", "D. Katabi", "M. M\u00e9dard", "J. Crowcroft"], "venue": "SIGCOMM Comput. Commun. Rev., vol. 36, no. 4, pp. 243\u2013254, Aug. 2006.  11", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2006}, {"title": "Network coding-aware routing in wireless networks", "author": ["S. Sengupta", "S. Rayanchu", "S. Banerjee"], "venue": "IEEE/ACM Trans. Netw., vol. 18, no. 4, pp. 1158\u20131170, Aug. 2010.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "An evolutionary approach to inter-session network coding", "author": ["M. Kim", "M. M\u00e9dard", "U.-M. O\u2019Reilly", "D. Traskov"], "venue": "INFOCOM, 2009, pp. 450\u2013458.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Towards a collision-free WLAN: Dynamic parameter adjustment in CSMA/E2CA", "author": ["J. Barcelo", "B. Bellalta", "C. Cano", "A. Sfairopoulou", "M. Oliver", "K. Verma"], "venue": "EURASIP Journal on Wireless Communications and Networking, 2011.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "Decentralised learning MACs for collision-free access in WLANs", "author": ["M. Fang", "D. Malone", "K.R. Duffy", "D.J. Leith"], "venue": "Wirel. Netw., vol. To appear, 2012.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "J. ACM, vol. 7, pp. 201\u2013215, July 1960.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1960}, {"title": "A machine program for theorem-proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Commun. ACM, vol. 5, pp. 394\u2013397, July 1962.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1962}, {"title": "ManySAT: a parallel SAT solver", "author": ["Y. Hamadi", "S. Jabbour"], "venue": "JSAT, vol. 6, no. 4, pp. 245\u2013262, 2009.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2009}, {"title": "How good are branching rules in DPLL", "author": ["Ming Ouyang"], "venue": "Discrete Appl. Math., vol. 89, pp. 281\u2013286, December 1998.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1998}, {"title": "Reverend Bayes on inference engines: a distributed hierarchical approach", "author": ["J. Pearl"], "venue": "Procedings of American Association for Artificial Intelligence National Conference on AI, 1982, pp. 133\u2013136.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1982}, {"title": "Random k-satisfiability problem: From an analytic solution to an efficient algorithm", "author": ["M. M\u00e9zard", "R. Zecchina"], "venue": "Phys. Rev. E, vol. 66, no. 5, pp. 056126, Nov 2002.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2002}, {"title": "On selecting a satisfying truth assignment", "author": ["C.H. Papadimitriou"], "venue": "IEEE Symposium on Foundations of Computer Science (FOCS ). 1991, pp. 162\u2013169, IEEE Computer Society, New York.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1991}, {"title": "A probabilistic algorithm for k-SAT and constraint satisfaction problems", "author": ["U. Schoning"], "venue": "IEEE Symposium on Foundations of Computer Science (FOCS ). 1999, pp. 410\u2013414, IEEE Computer Society, New York.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1999}, {"title": "Rigorous location of phase transitions in hard optimization problems", "author": ["D. Achlioptas", "A. Naor", "Y. Peres"], "venue": "Nature, vol. 435, no. 9, pp. 759\u2013764, 2005.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2005}, {"title": "The threshold for random k-SAT is 2k log 2-O(k)", "author": ["D. Achlioptas", "Y. Peres"], "venue": "J. Amer. Math. Soc., vol. 17, no. 4, pp. 947\u2013973, 2004.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2004}, {"title": "The probabilistic analysis of a greedy satisfiability algorithm", "author": ["A.C. Kaporis", "L.M. Kirousis", "E.G. Lalas"], "venue": "Rand. Struct. Algorithms, vol. 28, no. 4, pp. 444\u2013480, 2006.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2006}, {"title": "Analysis of two simple heuristics on a random instance of k-SAT", "author": ["A.M. Frieze", "S. Suen"], "venue": "J. Algorithms, vol. 20, no. 2, pp. 312?355, 1996.", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1996}, {"title": "Threshold values of random k-SAT from the cavity method", "author": ["S. Mertens", "M. Mezard", "R. Zecchina"], "venue": "Rand. Struct. Algorithms, vol. 28, no. 3, pp. 340\u201337, 2005.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2005}, {"title": "Gibbs states and the set of solutions of random constraint satisfaction problems", "author": ["F Krzakala", "A. Montarani", "Ricci-Tersenghi F.", "G. Semerijan", "L. Zdeborova"], "venue": "Proc. Natl. Acad. Sci. USA, vol. 104, no. 25, pp. 10318\u201310323, 2007.", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2007}, {"title": "Comparing beliefs, surveys and random walks", "author": ["E. Aurell", "U. Gordon", "S. Kirkpatrick"], "venue": "Advances in Neural Information Processing Systems (NIPS). 2004, vol. 17, pp. 49\u201356, MIT Press, Boston.", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2004}, {"title": "Analytic and algorithmic solution of random satisfiability problems", "author": ["M. Mezard", "G. Parisi", "R. Zecchina"], "venue": "Science, vol. 297, pp. 812\u2013 815, 2002.", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2002}, {"title": "Clustering of solutions in the random satisfiability problem", "author": ["M. Mezard", "T. Mora", "R. Zecchina"], "venue": "Phys. Rev. Lett., vol. 94, pp. 197\u2013205, 2005.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2005}, {"title": "Circumspect descent prevails in solving random constraint satisfaction problems", "author": ["M. Alava", "J. Ardeliu", "E. Aurell", "P. Kaski", "S. Krishnamurthy", "P. Orponen"], "venue": "Proc. Natl. Acad. Sci. USA, vol. 105, no. 4, pp. 15253\u201315257, 2008.", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2008}, {"title": "Linear upper bounds for random walk on small density 3-CNFs", "author": ["M. Alekhnovich", "E. Ben-Sasson"], "venue": "SIAM J. Comput., vol. 36, no. 5, pp. 1248\u20131263, 2006.", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2006}, {"title": "Invariant measures for Markov processes arising from iterated function systems  with place-dependent probabilities", "author": ["M.F. Barnsley", "S.G. Demko", "J.H. Elton", "J.S. Geronimo"], "venue": "Ann. Inst. H. Poincar\u00e9 Probab. Statist., vol. 24, no. 3, pp. 367\u2013394, 1988.", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1988}], "referenceMentions": [{"referenceID": 0, "context": "[1], [2], [3], [4] and references therein.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[1], [2], [3], [4] and references therein.", "startOffset": 5, "endOffset": 8}, {"referenceID": 2, "context": "[1], [2], [3], [4] and references therein.", "startOffset": 10, "endOffset": 13}, {"referenceID": 3, "context": "[1], [2], [3], [4] and references therein.", "startOffset": 15, "endOffset": 18}, {"referenceID": 4, "context": "Secondly, we define a new class of CSP algorithms which we term decentralized CSP solvers and, extending our earlier approach to graph colouring [5][6], introduce a novel stochastic decentralized CSP solver proving that it will find a solution in almost surely finite", "startOffset": 145, "endOffset": 148}, {"referenceID": 5, "context": "Secondly, we define a new class of CSP algorithms which we term decentralized CSP solvers and, extending our earlier approach to graph colouring [5][6], introduce a novel stochastic decentralized CSP solver proving that it will find a solution in almost surely finite", "startOffset": 148, "endOffset": 151}, {"referenceID": 6, "context": "find that the time the algorithm takes to find a satisfying assignment is close to that of WalkSAT [7], a well regarded, efficient centralized CSP solver, while also possessing desirable features of Survey Propagation [8].", "startOffset": 99, "endOffset": 102}, {"referenceID": 7, "context": "find that the time the algorithm takes to find a satisfying assignment is close to that of WalkSAT [7], a well regarded, efficient centralized CSP solver, while also possessing desirable features of Survey Propagation [8].", "startOffset": 218, "endOffset": 221}, {"referenceID": 8, "context": "Network coding has been the subject of considerable interest in recent years as it offers the potential for significant increases in network capacity [9], [10], [11].", "startOffset": 150, "endOffset": 153}, {"referenceID": 9, "context": "Network coding has been the subject of considerable interest in recent years as it offers the potential for significant increases in network capacity [9], [10], [11].", "startOffset": 155, "endOffset": 159}, {"referenceID": 10, "context": "Network coding has been the subject of considerable interest in recent years as it offers the potential for significant increases in network capacity [9], [10], [11].", "startOffset": 161, "endOffset": 165}, {"referenceID": 11, "context": "Inter-flow coding is known to be challenging [12].", "startOffset": 45, "endOffset": 49}, {"referenceID": 12, "context": "The task of a network finding a feasible linear network code in a distributed fashion, but with some global sharing of calculations, is investigated in [13] through the use of a genetic algorithm.", "startOffset": 152, "endOffset": 156}, {"referenceID": 13, "context": "Recently, there has been interest in decentralized approaches for finding collisionfree schedules, see [14], [15].", "startOffset": 103, "endOffset": 107}, {"referenceID": 14, "context": "Recently, there has been interest in decentralized approaches for finding collisionfree schedules, see [14], [15].", "startOffset": 109, "endOffset": 113}, {"referenceID": 15, "context": "algorithm [16], [17]; (ii) Survey Propagation [8]; and (iii) on Stochastic Local Search (SLS) [7].", "startOffset": 10, "endOffset": 14}, {"referenceID": 16, "context": "algorithm [16], [17]; (ii) Survey Propagation [8]; and (iii) on Stochastic Local Search (SLS) [7].", "startOffset": 16, "endOffset": 20}, {"referenceID": 7, "context": "algorithm [16], [17]; (ii) Survey Propagation [8]; and (iii) on Stochastic Local Search (SLS) [7].", "startOffset": 46, "endOffset": 49}, {"referenceID": 6, "context": "algorithm [16], [17]; (ii) Survey Propagation [8]; and (iii) on Stochastic Local Search (SLS) [7].", "startOffset": 94, "endOffset": 97}, {"referenceID": 17, "context": "ManySAT [18].", "startOffset": 8, "endOffset": 12}, {"referenceID": 18, "context": "[19], that assumes the existence of a centralized intelligence that employs a backtracking search.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "Survey propagation, a development of belief propagation [20] from trees to general graphs, has proved effective in graphs that do not contain small loops [21].", "startOffset": 56, "endOffset": 60}, {"referenceID": 20, "context": "Survey propagation, a development of belief propagation [20] from trees to general graphs, has proved effective in graphs that do not contain small loops [21].", "startOffset": 154, "endOffset": 158}, {"referenceID": 21, "context": "To see this implicit requirement, consider the following algorithm for binary valued variables originally proposed by Papadimitriou [22] and developed further by Sch\u00f6ning [23].", "startOffset": 132, "endOffset": 136}, {"referenceID": 22, "context": "To see this implicit requirement, consider the following algorithm for binary valued variables originally proposed by Papadimitriou [22] and developed further by Sch\u00f6ning [23].", "startOffset": 171, "endOffset": 175}, {"referenceID": 6, "context": "Although simple, this forms the basic building block for all SLS algorithms, including the well-studied WalkSAT algorithm [7].", "startOffset": 122, "endOffset": 125}, {"referenceID": 22, "context": "It is important that a single unsatisfied clause is selected at each step and that a single variable within the clause is adjusted as it is this that leads to the algorithm behaving as a random walk [23].", "startOffset": 199, "endOffset": 203}, {"referenceID": 21, "context": "In random k-SAT, an instance of k-SAT is generated by drawing M such clauses uniformly at random [22].", "startOffset": 97, "endOffset": 101}, {"referenceID": 24, "context": "Evidently, rexist,k \u2264 r\u00acexist,k and it is conjectured that rexist,k = r\u00acexist,k [25].", "startOffset": 80, "endOffset": 84}, {"referenceID": 29, "context": "[30], although there are fewer experimental studies for k > 3.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "Recent mathematical results have established that rexist,k \u2265 2 log 2\u2212k [24] and this lower bound can be tightened to obtain the theoretical values shown", "startOffset": 71, "endOffset": 75}, {"referenceID": 30, "context": "Statistical physics considerations have led to the conjecture that rpoly,k is equal to the value r1RSB,k at which the one-step replica symmetry breaking (1RSB) instability occurs [31].", "startOffset": 179, "endOffset": 183}, {"referenceID": 31, "context": "For k \u2265 8, it has been proven analytically that the set of satisfying assignments is grouped into widely separated clusters, which lends support to this conjecture [32].", "startOffset": 164, "endOffset": 168}, {"referenceID": 32, "context": "For values of k < 8 the situation is less clear, with experimental evidence indicating that rpoly,k lies above r1RSB,k for k = 3, 4 and 5 [33].", "startOffset": 138, "endOffset": 142}, {"referenceID": 23, "context": "78 726,817 r\u00acexist,k[24] 4.", "startOffset": 20, "endOffset": 24}, {"referenceID": 24, "context": "94 726,817 rexist,k[25], [26] 3.", "startOffset": 19, "endOffset": 23}, {"referenceID": 25, "context": "94 726,817 rexist,k[25], [26] 3.", "startOffset": 25, "endOffset": 29}, {"referenceID": 26, "context": "78 706,817 rpoly,k [27], [26] 3.", "startOffset": 19, "endOffset": 23}, {"referenceID": 25, "context": "78 706,817 rpoly,k [27], [26] 3.", "startOffset": 25, "endOffset": 29}, {"referenceID": 27, "context": "65 95,263 Estimates r\u00acexist,k[28] 4.", "startOffset": 29, "endOffset": 33}, {"referenceID": 27, "context": "91 r1RSB,k[28], [29] 4.", "startOffset": 10, "endOffset": 14}, {"referenceID": 28, "context": "91 r1RSB,k[28], [29] 4.", "startOffset": 16, "endOffset": 20}, {"referenceID": 29, "context": "Comparing the performance of the CFL algorithm with the popular WalkSAT algorithm, we note that the WalkSAT algorithm also exhibits an exponential-like dependence of stopping time on r and linearity in N [30], [34], [33].", "startOffset": 204, "endOffset": 208}, {"referenceID": 33, "context": "Comparing the performance of the CFL algorithm with the popular WalkSAT algorithm, we note that the WalkSAT algorithm also exhibits an exponential-like dependence of stopping time on r and linearity in N [30], [34], [33].", "startOffset": 210, "endOffset": 214}, {"referenceID": 32, "context": "Comparing the performance of the CFL algorithm with the popular WalkSAT algorithm, we note that the WalkSAT algorithm also exhibits an exponential-like dependence of stopping time on r and linearity in N [30], [34], [33].", "startOffset": 216, "endOffset": 220}, {"referenceID": 32, "context": "ChainSat [33].", "startOffset": 9, "endOffset": 13}, {"referenceID": 29, "context": "It is not exhibited by the Survey Propagation algorithm [30], [8], which has been the subject of considerable interest as it creates the ability to operate close to the rexist,k threshold.", "startOffset": 56, "endOffset": 60}, {"referenceID": 7, "context": "It is not exhibited by the Survey Propagation algorithm [30], [8], which has been the subject of considerable interest as it creates the ability to operate close to the rexist,k threshold.", "startOffset": 62, "endOffset": 65}, {"referenceID": 0, "context": ", N} let ~ pi(t) \u2208 [0, 1], t \u2208 N, be the CFL probability vector for variable i at time t and xi(t) be the variable\u2019s value selected stochastically from ~ pi(t).", "startOffset": 19, "endOffset": 25}, {"referenceID": 34, "context": "The state of the probability vectors {P (t)} forms a Markov Chain, or Iterated Function System, with place dependent probabilities [38].", "startOffset": 131, "endOffset": 135}, {"referenceID": 5, "context": "In a sequence of events analogous to those in the proof of [6][Theorem 3], these two variables select their final values, ~ai and (~a)j , at the next round, causing their initial clause to be satisfied as ~a \u2208 A.", "startOffset": 59, "endOffset": 62}], "year": 2012, "abstractText": "We show that several important resource allocation problems in wireless networks fit within the common framework of Constraint Satisfaction Problems (CSPs). Inspired by the requirements of these applications, where variables are located at distinct network devices that may not be able to communicate but may interfere, we define natural criteria that a CSP solver must possess in order to be practical. We term these algorithms decentralized CSP solvers. The best known CSP solvers were designed for centralized problems and do not meet these criteria. We introduce a stochastic decentralized CSP solver, proving that it will find a solution in almost surely finite time, should one exist, and also showing it has many practically desirable properties. We benchmark the algorithm\u2019s performance on a well-studied class of CSPs, random k-SAT, illustrating that the time the algorithm takes to find a satisfying assignment is competitive with stochastic centralized solvers on problems with order a thousand variables despite its decentralized nature. We demonstrate the solver\u2019s practical utility for the problems that motivated its introduction by using it to find a non-interfering channel allocation for a network formed from data from downtown Manhattan.", "creator": "LaTeX with hyperref package"}}}