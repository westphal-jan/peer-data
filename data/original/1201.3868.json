{"id": "1201.3868", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jan-2012", "title": "A Dichotomy for 2-Constraint Forbidden CSP Patterns", "abstract": "Although the CSP (constraint satisfaction problem) is NP-complete, even in the case when all constraints are binary, certain classes of instances are tractable. We study classes of instances defined by excluding subproblems. This approach has recently led to the discovery of novel tractable classes. The complete characterisation of all tractable classes defined by forbidding patterns (where a pattern is simply a compact representation of a set of subproblems) is a challenging problem. We demonstrate a dichotomy in the case of forbidden patterns consisting of either one or two constraints. This has allowed us to discover new tractable classes including, for example, a novel generalisation of 2SAT.", "histories": [["v1", "Wed, 18 Jan 2012 18:09:36 GMT  (22kb)", "http://arxiv.org/abs/1201.3868v1", "19 pages"]], "COMMENTS": "19 pages", "reviews": [], "SUBJECTS": "cs.AI cs.CC", "authors": ["martin c cooper", "guillaume escamocher"], "accepted": true, "id": "1201.3868"}, "pdf": {"name": "1201.3868.pdf", "metadata": {"source": "CRF", "title": "A Dichotomy for 2-Constraint Forbidden CSP Patterns", "authors": ["Martin C. Cooper", "Guillaume Escamocher"], "emails": ["(cooper@irit.fr)"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 1.\n38 68\nv1 [\ncs .A\nI] 1\n8 Ja\nn 20\n12"}, {"heading": "1 Introduction", "text": "In this paper we study the generic combinatorial problem known as the binary constraint satisfaction problem (CSP) in which the aim is to determine the existence of an assignment of values to n variables such that a set of constraints on pairs of variables are simultaneously satisfied. The generic nature of the CSP has led to diverse applications, notably in the fields of Artificial Intelligence and Operations Research.\nA fundamental research question in complexity theory is the identification of tractable subproblems of NP-complete problems. Classical approaches have consisted in identifying types of constraints which imply the existence of a polynomial-time algorithm. Among the most wellknown examples, we can cite linear constraints and Horn clauses. In an orthogonal approach, restrictions are placed solely on the (hyper)graphof constraint scopes. In some cases, dichotomies have even been proved characterising all tractable classes definable by placing restrictions either on the constraint relations [2, 3] or on the (hyper)graph of constraint scopes [12, 13, 14].\nRecently, a new avenue of research has been investigated: the identification of tractable classes of CSP instances defined by forbidding a specific (set of) subproblems. Novel tractable classes have been discovered by forbidding simple 3-variable subproblems [8, 9]. This paper presents an essential first step towards the identification of all such tractable classes, namely a dichotomy for the special case of forbidden 2-constraint subproblems.\nWe first define the notion of a CSP pattern. A pattern can be seen as a generalisation of a binary CSP instance; it represents a set of subproblems by leaving the consistency of some tuples undefined. We use the term point to denote an assignment of a value to a variable, i.e. a pair a = \u3008v, d\u3009where d is in the domain of variable v. A pattern is a graph in which vertices correspond to points and both vertices and edges are labelled. The label of a vertex corresponding to an assignment \u3008v, d\u3009 is simply the variable v and the label of an edge between two vertices describes the compatibility of the pair of assignments corresponding to the pair of vertices.\nDefinition 1. A pattern is a quintuplet \u3008V,A, var, E, cpt\u3009 comprising:\n\u2022 a set V of variables,\n\u2022 a set A of points (assignments),\n\u2217supported by ANR Project ANR-10-BLAN-0210.\n\u2022 a variable function var : A \u2192 V ,\n\u2022 a set E \u2286 ( A 2 ) of edges (unordered pairs of elements ofA) such that {a, b} \u2208 E \u21d2 var(a) 6= var(b),\n\u2022 a Boolean-valued compatibility function cpt : E \u2192 {F, T }, where for notational simplicity, we write cpt(a, b) instead of cpt({a, b}).\nDefinition 2. A binary CSP instance is a pattern \u3008V,A, var, E, cpt\u3009 such that E = {(a, b) | var(a) 6= var(b)} (i.e. the compatibility of each pair of assignments to distinct variables is specified by the compatibility function). The question corresponding to the instance is: does there exist a consistent set of assignments to all the variables, that is a solution A \u2286 A such that |A| = |V |, (\u2200a, b \u2208 A, var(a) 6= var(b)) and (\u2200e \u2208 (\nA 2\n)\n, cpt(e) = T )?\nFor a pattern P = \u3008V,A, var, E, cpt\u3009 and a variable v \u2208 V , we use Av to denote the set of assignments {a \u2208 A | var(a) = v}. The constraint on variables v1, v2 \u2208 V is the pattern \u3008{v1, v2}, A12, var|A12 , E12, cpt|E12\u3009 where A12 = Av1 \u222a Av2 and E12 = {{a, b} | a \u2208 Av1 , b \u2208 Av2}. If cpt(a, b) = T then the two assignments (points) a, b are compatible and {a, b} is a compatibility edge; if cpt(a, b) = F then the two assignments a, b are incompatible and {a, b} is a incompatibility edge. In a pattern, the compatibility of a pair of points a, b such that var(a) 6= var(b) and (a, b) /\u2208 E is undefined. A pattern can be viewed as a means of representing the set of all instances obtained by arbitrarily specifying the compatibility of such pairs. Two patterns P and Q are isomorphic if they are identical except for a possible renaming of variables and assignments.\nIn a CSP instance \u3008V,A, var, E, cpt\u3009, we call the set {d | \u3008v, d\u3009 \u2208 A} of values that can be assigned to variable v the domain of v and the set {(a, b) \u2208 Av1 \u00d7Av2 | cpt(a, b) = T } of compatible pairs of values that can be assigned to two variables v1, v2 \u2208 V the constraint relation on v1, v2. The constraint between variables v1 and v2 in an instance is non-trivial if there is at least one incompatible pair of assignments, i.e. a \u2208 Av1 and b \u2208 Av2 such that cpt(a, b) = F . The constraint graph of an instance \u3008V,A, var, E, cpt\u3009 is \u3008V,H\u3009, where H is the set of pairs of variables v1, v2 \u2208 V such that the constraint on v1, v2 is non-trivial.\nDefinition 3. We say that a pattern P occurs in a pattern P \u2032 (or that P \u2032 contains P ) if P \u2032 is isomorphic to a pattern Q in the transitive closure of the following two operations (extension and merging) applied to P :\nextension P is a sub-pattern of Q (and Q an extension of P ): if P = \u3008VP , AP , varP , EP , cptP \u3009 and Q = \u3008VQ, AQ, varQ, EQ, cptQ\u3009, then VP \u2286 VQ, AP \u2286 AQ, varP = varQ|P , EP \u2286 EQ, cptP = cptQ|EP . Example:\nP Q\nmerging Merging two points in P transforms P into Q: if P = \u3008VP , AP , varP , EP , cptP \u3009 and Q = \u3008VQ, AQ, varQ, EQ, cptQ\u3009, then \u2203a, b \u2208 AP such that varP (a) = varP (b) and \u2200c \u2208 AP such that {a, c}, {b, c} \u2208 EP , cptP (a, c) = cptP (b, c). Furthermore, VP = VQ, AQ = AP \\ {b}, varQ = varP |AQ ,EQ = EP\u222a{{a, x} | {b, x} \u2208 EP } and cptQ(a, x) = cptQ(b, x) if {b, x} \u2208 EP , cptQ(e) = cptP (e) otherwise. Example:\nP Q\nNotation: Let P be a CSP pattern. We use CSP(P ) to denote the set of binary CSP instances Q in which P does not occur.\nDefinition 4. A patternP is intractable ifCSP(P ) is NP-complete. It is tractable if there is a polynomialtime algorithm to solve CSP(P ).\nIn this paper we characterise all tractable two-constraint patterns. It is worth observing that, in a class of CSP instances defined by forbidding a pattern, there is no bound on the size of domains. Recall, however, that CSP instances have finite domains since the set of all possible assignments is assumed to be given in extension as part of the input.\nClearly, all classes of CSP instances CSP(P ) defined by forbidding a pattern are hereditary: I \u2208 CSP(P ) and I \u2032 \u2286 I (in the sense that I is an extension of I \u2032, according to Definition 3) together imply that I \u2032 \u2208 CSP(P ). Furthermore, if I \u2208 CSP(P ) and I \u2032 is isomorphic to I , then I \u2032 \u2208 CSP(P ). Forbidding a pattern therefore only allows us to define hereditary classes closed under arbitrary permutations of variable domains."}, {"heading": "2 Preprocessing operations on CSP instances", "text": "This section describes polynomial-time simplification operations on CSP instances. Assuming that these operations have been applied facilitates the proof of tractability of many patterns.\nLet \u3008V,A, var, E, cpt\u3009 be a CSP instance. If for some variable v, Av is a singleton {a}, then the elimination of a single-valued variable corresponds to making the assignment a and consists of eliminating v from V and eliminating a from A as well as all assignments b which are incompatible with a.\nGiven a CSP instance \u3008V,A, var, E, cpt\u3009, arc consistency consists in eliminating from A all assignments a for which there is some variable v 6= var(a) in V such that \u2200b \u2208 Av , cpt(a, b) = F [1].\nGiven a CSP instance \u3008V,A, var, E, cpt\u3009, if for var(a) = var(b) and for all variables v 6= var(a), \u2200c \u2208 Av , cpt(a, c) = T \u21d2 cpt(b, c) = T , then we can eliminate a from A by neighbourhood substitution, since in any solution in which a appears, we can replace a by b [10]. Establishing arc consistency and eliminating single-valued variables until convergence produces a unique result, and the result of applying neighbourhood substitution operations until convergence is unique modulo isomorphism [5]. None of these three operations when applied to an instance in CSP(P ) can introduce the forbidden pattern P .\nWe now consider two new simplification operations. They are simplification operations that can be applied to certain CSP instances. We can always perform the fusion of two variables v1, v2 in a CSP instance into a single variable v whose set of assignments is the cartesian product of the sets of assignments to v1 and to v2. Under certain conditions, we do not need to keep all elements of this cartesian product and, indeed, the total number of assignments actually decreases.\nDefinition 5. Consider a CSP instance \u3008V,A, var, E, cpt\u3009 with v1, v2 \u2208 V . Suppose that there is a fusion function f : Av1 \u2192 Av2 , such that \u2200u \u2208 Av1 , whenever u is in a solution S, there is a solution S\u2032 containing both u and f(u). Then we can perform the simple fusion of v2 and v1 to create a new fused variable v. The resulting instance is \u3008V \u2032, A\u2032, var\u2032, E\u2032, cpt\u2032\u3009 defined by V \u2032 = (V \\ {v1, v2}) \u222a {v}, A\u2032 = A \\ Av2 , var \u2032(u) = var(u) for all u \u2208 A\u2032 \\ Av1 and var \u2032(u) = v for all u \u2208 Av1 , E\n\u2032 = {(p, q) \u2208 (\nA\u2032\n2\n)\n| var\u2032(p) 6= var\u2032(q)}, cpt\u2032(p, q) = cpt(p, q) if p, q \u2208 A\u2032 \\Av1 , cpt \u2032(u, q) = cpt(u, q) \u2227 cpt(f(u), q)\nfor all u \u2208 Av1 and all q \u2208 A \u2032 \\Av1 .\nDefinition 6. Consider a CSP instance \u3008V,A, var, E, cpt\u3009 with v1, v2 \u2208 V and a hinge value a \u2208 Av1 . Suppose that there is a fusion function f : Av1 \\ {a} \u2192 Av2 , such that \u2200u \u2208 Av1 \\ {a}, whenever u is in a solution S, there is a solution S\u2032 containing both u and f(u). Then we can perform the complex fusion of v2 and v1 to create a new fused variable v. The resulting instance is \u3008V \u2032, A\u2032, var\u2032, E\u2032, cpt\u2032\u3009 defined by V \u2032 = (V \\{v1, v2})\u222a{v},A \u2032 = A\\{a}, var\u2032(u) = var(u) for all u \u2208 A\u2032 \\ (Av1 \u222aAv2) and var \u2032(u) = v for all u \u2208 (Av1 \\ {a}) \u222a Av2 , E \u2032 = {(p, q) \u2208 ( A\u2032\n2\n)\n| var\u2032(p) 6= var\u2032(q)}, cpt\u2032(p, q) = cpt(p, q) if p, q \u2208\nA\u2032 \\ (Av1 \u222aAv2 ), cpt \u2032(u, q) = cpt(u, q)\u2227 cpt(f(u), q) for all u \u2208 Av1 \\ {a} and all q \u2208 A \u2032 \\ (Av1 \u222aAv2 ), cpt\u2032(p, q) = cpt(a, q) \u2227 cpt(p, q) for all p \u2208 Av2 and all q \u2208 A \u2032 \\ (Av1 \u222a Av2).\nLemma 1. If I is a CSP instance and I \u2032 the result of a (simple or complex) fusion of two variables in I , then I \u2032 is solvable iff I is solvable.\nProof. We give the proof only for the case of a complex fusion, since a simple fusion can be considered as a special case. Among the assignments in the cartesian product of Av1 and Av2 , it is sufficient, in order to preserve solvability, to keep only those of the form (a, q) where q \u2208 Av2 or of the form (u, f(u)) where u \u2208 Av1 \\ {a}. To complete the proof, it suffices to observe that in A\u2032 we use q \u2208 Av2 to represent the pair of assignments (a, q) and u \u2208 Av1 \\ {a} to represent (u, f(u)).\nFusion preserves solvability and the total number of assignments decreases by at least 1 (in fact, by |Av2 | in the case of a simple fusion). However, when solving instances I \u2208 CSP(P ), for some pattern P , a fusion operation will only be useful if it does not introduce the forbidden pattern P ."}, {"heading": "3 Reduction", "text": "In a pattern P , a point awhich is linked by a single compatibility edge to the rest of P is known as a dangling point. If an arc consistent instance I does not contain the pattern P then it does not contain the pattern P \u2032 which is equivalent to P in which the dangling point a and the corresponding compatibility edge have been deleted. Thus, since arc consistency is a polynomial-time operation which cannot introduce a forbidden pattern, to decide tractability we only need consider patterns without dangling points.\nDefinition 7. We say that a pattern P can be reduced to a pattern Q, and thatQ is a reduction of P , if Q is in the transitive closure of the three operations extension, merging and dp-elimination applied to P , where dp-elimination is the following operation:\ndp-elimination Eliminating a dangling point and its corresponding compatibility edge from P transforms P into Q. Example:\nP Q\nLemma 2. Let P and Q be two patterns, such that P can be reduced to Q. Let I be a CSP instance satisfying arc consistency. If Q occurs in I , then P also occurs in I .\nProof. By definition, reduction is a transitive relation. Therefore, by induction, it suffices to prove the result for each of the individual operations: extension, merging and dp-elimination. We suppose Q occurs in I . If Q is an extension of P , then P is a sub-pattern of Q and the result is immediate. If merging two points a and b in P transforms it into Q, then P actually covers two different patterns: the one where a and b are different points, and the one where a and b are the same point. The latter pattern is Q. So the set of instances containing Q is a subset of the set of instances containing (at least one of the two versions of) P and we have the result. If adding a dangling point and its corresponding compatibility edge to Q transforms it into P , then since I satisfies arc consistency P also occurs in I .\nThe following corollary follows immediately from the fact that arc consistency can be established in polynomial time.\nCorollary 1. Let P and Q be two patterns, such that P can be reduced to Q. Then\n\u2022 If Q is tractable, then P is tractable.\n\u2022 If P is intractable, then Q is intractable.\nIt follows that we only need to study those patterns that cannot be reduced to a known tractable pattern and that are not the reduction of a known intractable pattern."}, {"heading": "4 One-constraint patterns", "text": "In this section we prove a dichotomy for patterns composed of a single constraint. We also prove some results concerning 1-constraint patterns that are essential for the proof of the 2-constraint dichotomy given in Section 5.\nLemma 3. Let P be a pattern such that a constraint in P contains two distinct incompatibility edges that cannot be merged. Then P is intractable.\nProof. Let P be a pattern such that a constraint in P contains two non-mergeable incompatibility edges. Let SAT1 be the set of SAT instances with at most one occurrence of each variable in each clause. SAT1 is trivially equivalent to SAT which is well known to be NP-complete [4]. It suffices to give a polynomial reduction from SAT1 to CSP(P ). We suppose that we have a SAT1 instance I = {V, S} with V a set of variables {v1, v2, . . . , vn} and S a set of clauses {C1, C2, . . . , Ck} such that each clause Ci is a disjunction of ci literals l1i \u2228 \u00b7 \u00b7 \u00b7 \u2228 l ci i . We create the following CSP instance I \u2032:\n\u2022 n+ k variables v\u20321, . . . , v \u2032 n+k.\n\u2022 \u2200v\u2032i with 1 \u2264 i \u2264 n, two points \"vi\" and \"vi\" in Av\u2032i .\n\u2022 \u2200v\u2032i with n+ 1 \u2264 i \u2264 n+ k, ci\u2212n points l 1 i\u2212n, . . . , l ci\u2212n i\u2212n in Av\u2032i .\n\u2022 \u22001 \u2264 i \u2264 k, \u22001 \u2264 j \u2264 ci, an incompatibility edge between the point l j i \u2208 Av\u2032n+i and the\noccurrence in Av\u2032 1 , . . . , Av\u2032n of the literal l j i .\nBy construction, I \u2032 has a solution if and only if I has a solution. Furthermore, each time an incompatibility edge occurs in a constraint C, this constraint C is between a CSP variable v\u2032i representing the SAT1 variable vi and another CSP variable v\u2032n+j representing the SAT1 clause Cj . Since vi occurs at most once in Cj , then there is only one incompatibility edge in C. So I \u2032 does not contain the pattern P . So we have reduced SAT1 to CSP(P ).\nDefinition 8. Given a pattern P = \u3008V,A, var, E, cpt\u3009, a variable v \u2208 V , and a point a \u2208 Av , we say that a is explicitly compatible (respectively explicitly incompatible) if there is a point b \u2208 A such that a is compatible with b (respectively such that a is incompatible with b).\nLemma 4. Let P be a non-mergeable pattern. Then for every variable v in P , there is at most one point in Av which is not explicitly incompatible.\nProof. We suppose we have a pattern P such that there are two points a and b with var(a) = var(b) such that neither a nor b is explicitly incompatible. So no point in the pattern is incompatible with either a or b. Hence, we can merge a and b, which is a contradiction.\nLet Z be the pattern on two variables v and v\u2032, with points a, b \u2208 Av and points c, d \u2208 Av\u2032 such that a is compatible with both c and d, b is compatible with c and incompatible with d.\nLemma 5. Z is intractable.\nProof. Since 3-COLOURING is NP-complete [11], it suffices to give a polynomial reduction from 3-COLOURING to CSP(Z), the set of CSP instances in which the pattern Z does not occur.\nDefine the relation Rs,t \u2286 {1, 2, 3}2 by\nRs,t = {\u3008u, v\u3009|(u = s \u2227 v = t) \u2228 (u 6= s \u2227 v 6= t)}\nIt is easy to verify that Rs,t does not contain the pattern Z . Consider the 5-variable gadget with variables vi, vj , u1, u2, u3, each with domain {1, 2, 3}, and with constraints Rk,k on variables (vi, uk) (k = 1, 2, 3) and constraints R1+(k mod 3),k on variables (uk, vj) (k = 1, 2, 3). The joint effect of these six constraints is simply to impose the constraint vi 6= vj . Any instance \u3008V,E\u3009 of 3-COLOURING, with V = {1, . . . , n}, can be reduced to an instance of CSP(Z) with variables v1, . . . , vn by placing a copy of this gadget between every pair of variables (vi, vj) such that {i, j} \u2208 E. This reduction is clearly polynomial.\nLet 1I be the pattern on two variables v and v\u2032 with points a \u2208 Av and b \u2208 Av\u2032 such that a and b are incompatible.\nLemma 6. Let P be a pattern on one constraint. Then either P is reducible to the trivial tractable pattern 1I , and thus is tractable, or P is intractable.\nProof. Let P be a pattern on one constraint between two variables v and v\u2032. From Lemma 3, we know that if P has two distinct incompatibility edges, then P is intractable. If there is no incompatibility edge at all in P , then P is reducible by merging and/or dp-elimination to the empty pattern, which is itself reducible by sub-pattern to 1I . We suppose there is exactly one incompatibility edge in P . We label a \u2208 Av and b \u2208 Av\u2032 the points defining that edge. From Lemma 4, we know that we only need to consider at most one other point c 6= a in Av and at most one other point d 6= b in Av\u2032 . If all three edges {a, d}, {c, b} and {c, d} are compatibility edges, then P is intractable from Lemma 5. If only two or less of these edges are compatibility edges, then P is reducible by merging and/or dp-elimination to 1I . So we have the lemma.\nLemma 7. Let P be a pattern composed of two separate one-constraint patterns: P1 on variables v0, v1 and P2 on variables v2, v3, where all four variables are distinct. Then\n1. If either P1 or P2 is intractable, then P is intractable too.\n2. If both P1 and P2 are tractable, then P is tractable.\nProof. 1. P1 and P2 are sub-patterns of P , so they are both reducible to P . So if one of them is intractable, then P is intractable too, by Corollary 1.\n2. Suppose that both P1 and P2 are tractable. So there are two polynomial algorithms A1 and A2 which solve CSP(P1) and CSP(P2), respectively. Let I be a CSP instance such that P does not occur in I . So either P1 or P2 does not occur in I . So I can be solved by either A1 or A2. So any CSP instance in CSP(P ) can be solved by one of two polynomial algorithms. So P is tractable.\nThe following lemma concerns a pattern in which some structure is imposed on domain elements. It is essential for our two-constraint dichotomy.\nLet 2V be pattern on three variables v0, v1 and v2 with three points a, b, c \u2208 Av1 , three points d, e, f \u2208 Av2 and six points g, h, i, j, k, l \u2208 Av0 , such that a is compatible with h, b is compatible with g and h, c is incompatible with i, d is incompatible with j, e is compatible with k and l, f is compatible with l. The pattern 2V also has the associated structure (a 6= b or g 6= h) and (e 6= f or k 6= l). When a pattern has an associated structure given by a propertyP , the property P must be preserved by reduction operations. For example, if P is a 6= b then the points a and b cannot be merged during a reduction. It is worth pointing out that in a CSP instance, all points are assumed to be distinct and hence a property such as a 6= b is necessarily satisfied.\nLemma 8. 2V is intractable.\nProof. Let the gadget V + be the pattern on two variables v0, v1 with points a \u2208 Av0 and b, c \u2208 Av1 such that a is compatible with both b and c, together with the structure b 6= c. In the pattern 2V , either b is compatible with two different points g and h, or h is compatible with two different points a and b. So, if 2V occurs in a CSP instance on variables v\u20320, v \u2032 1, v \u2032 2, then the gadget V + necessarily occurs in the constraint between v\u20320 and v \u2032 1. By an identical argument, the gadget V + must also occur in the constraint between v\u20320 and v \u2032\n2. We define an equality constraint between two variables v and v\u2032 with the same domain as the constraint consisting of compatibility edges between identical values in Av and Av\u2032 and incompatibility edges between all other couples of points. Thus, by definition, a point in an equality constraint is compatible with one and only one point. Since the gadget V + contains a point a compatible with two different points, V + does not occur in an equality constraint.\nWe will reduce CSP to CSP(2V ). Let I be a CSP instance. For each (v, w) in I such that there is a non-trivial constraint between v and w, we introduce two new variables v\u2032 and w\u2032 such that the domain of v\u2032 is the same as the domain of v, the domain of w\u2032 is the same as the domain of w. We add equality constraints between v and v\u2032, and between w and w\u2032, and we add between v\u2032 and w\u2032 the same constraint as there was between v and w. All other constraints involving v\u2032 or w\u2032 are trivial. We also replace the constraint between v and w by a trivial constraint. After this transformation, v and w\u2032 are the only variables which share a constraint with v\u2032. Let I \u2032 be the instance obtained after all such transformations have been performed on I . By construction, I \u2032 has a solution if and only I has a solution. We now suppose that we have three variables v0, v1 and v2 in I \u2032 such that there are nontrivial constraints between v0 and v1 and between v0 and v2. By construction, at least one of these constraints is an equality constraint. Hence, the gadget V + cannot occur in both of these constraints. It follows that 2V cannot occur in I \u2032. So we have reduced I to an instance without any occurrence of the pattern 2V . This polynomial reduction from CSP to CSP(2V ) shows that 2V is intractable."}, {"heading": "5 Two-Constraint patterns", "text": "Let T be the following set {T1, T2, T3, T4, T5}:\nT1 T2 T3\nT4 T5\nNo pattern in T can be reduced to a different pattern in T . As we will show, each Ti defines a tractable class of binary CSP instances. For example, T4 defines a class of instanceswhich includes as a proper subset all instances with zero-one-all constraints [7]. Zero-one-all constraints can be seen as a generalisation of 2SAT clauses to multi-valued logics.\nLet 2I represent the pattern composed of two separate copies of 1I , i.e. four points a, b, c, d such that var(a), var(b), var(c), var(d) are all distinct and both a, b and c, d are pairs of incompatible points.\nTheorem 1. Let P be a pattern on two constraints. Then P is tractable if and only if P is reducible to one of the patterns in T \u222a {2I}.\nProof. \u21d2: A two-constraint pattern involves either three or four distinct variables. Consider first the latter case, in which P is composed of two separate one-constraint patterns P1 and P2 on four distinct variables. By Lemma 7, P is tractable if and only if both P1 and P2 are tractable. Furthermore, by Lemma 6, all tractable one-constraint patterns are reducible to 1I . Thus, if P is tractable, then it is reducible to 2I , by a combination of the two reductions of P1 and P2 to 1I . It only remains to study two-constraint patterns on three variables.\nFromLemma 3, we know that we only have to study patternswith atmost one incompatibility edge in each constraint. If one of the constraints does not contain any incompatibility edge at all, then the pattern is reducible by merging and/or dp-elimination to a pattern with only one constraint. So we can assume from now on that there is exactly one incompatibility edge (a \u2208 Av0 , b \u2208 Av1) between v0 and v1, and also exactly one incompatibility edge (c \u2208 Av0 , d \u2208 Av2) between v0 and v2. The \u201cskeleton\u201d of incompatibility edges of an irreducible tractable pattern can thus take two forms according to whether a = c or a 6= c.\nFrom Lemma 4 we know that |Av| \u2264 2 for each variable v with only one explicitly incompatible point, and that |Av| \u2264 3 for each variable v with two explicitly incompatible points. We know from Lemmas 5 and 8 that both Z and 2V are intractable, so we must look for patterns in which neither one occurs. We know that we have two possible incompatibility skeletons to study, each one implying a maximum number of points appearing in the pattern.\nFirst incompatibility skeleton:\na b c d\ne\nf\nSuppose first that a is a point in the pattern. Then there must be a compatibility edge between a and e, otherwise we could merge a and b. There also must be a compatibility edge between a and f , otherwise a would be a dangling point. Similarly, if d is a point in the pattern, then there must be compatibility edges between d and e, and between d and f . So if both a and d are points in the pattern, then the pattern 2V occurs. So a and d cannot be both points of the pattern. Since they play symmetric roles, we only have two cases to consider: either a is a point in the pattern and not d, or neither a nor d is a point in the pattern.\nIf a is a point in the pattern, then the only remaining edges are {f, b} and {f, c}. {f, b} cannot be a compatibility edge, because otherwise the pattern Z would occur. {f, c}must be a compatibility edge, otherwise we could merge f and e. On the other hand, if neither a nor d is a point in the pattern, then the only remaining edges are {f, b} and {f, c}. If one of them is a compatibility edge but not the other, then f would be a dangling point. So either both {f, b} and {f, c} are compatibility edges, or neither of them is. However, the latter case is reducible to the former one. So the only possible irreducible tractable patterns are T1 and T2.\nSecond incompatibility skeleton:\na b c d\ne f g\nIf g is a point in the pattern, then there must be a compatibility edge between g and b, otherwise we could merge g and e. There alsomust be a compatibility edge between g and c, otherwise we could merge g and f . We suppose a is a point in the pattern. Then there is a compatibility edge between a and e, otherwise we could merge a and b. There is also a compatibility edge either between a and f or between a and g, otherwise a would be a dangling point. We cannot have a compatibility edge between a and g, otherwise the pattern Z would occur. So there is a compatibility edge between a and f . There is a compatibility edge either between b and f or between c and e, otherwise we could merge e and f . We cannot have a compatibility edge between b and f , otherwise the pattern Z would occur. We cannot have a compatibility edge between c and e, otherwise the pattern 2V would occur. So a cannot be a point in the pattern. Since a and d play symmetric roles, we can also deduce that d cannot be a point in the pattern. So the only remaining edges are {b, f} and {c, e}. At least one of them is a compatibility edge, otherwise we could merge e and f . If both of them are compatibility edges, the pattern 2V occurs. So exactly one of them is a compatibility edge. Since they play symmetric roles, we can assume for instance that {b, f} is a compatibility edge while {c, e} is an unknown edge.\nIf g is not a point in the pattern, then we suppose that a is a point in the pattern. There is a compatibility edge between a and e, otherwise we could merge a and b. There is also a compatibility edge between a and f , otherwise a would be a dangling point. Similarly, if d is a point in the pattern, then there must be compatibility edges between d and e, and between d and f . So a and d cannot be both points of the pattern. Since they play symmetric roles, we only have two cases to consider: either a is a point in the pattern and not d, or neither a nor d is a point in the pattern.\nIf a is a point in the pattern, then the only remaining edges are {b, f} and {c, e}. At least one of them is a compatibility edge, otherwise we could merge e and f . There is no compatibility edge between b and f , otherwise the pattern Z would occur. So there is a compatibility edge between c and e.\nIf neither a nor d is a point in the pattern, then the only remaining edges are {b, f} and {c, e}. At least one of them is a compatibility edge, otherwise we could merge e and f . So either exactly one of them is a compatibility edge, or they both are. However, the former case is reducible to the latter. So the only possible patterns are T3, T4 or T5.\nSo if P is a tractable pattern on two constraints, then P is reducible to one of the patterns in T .\n\u21d0: We now give the tractability proofs for all patterns in T . We assume throughout that we have applied until convergence the preprocessing operations: arc consistency, neighbourhood substitution and single-valued variable elimination.\nProof of tractability of T1 : We suppose we forbid the pattern T1. Let the gadget X be the pattern on two variables v0, v1 with points a, b \u2208 Av0 and c, d \u2208 Av1 such that a is incompatible with c and compatible with d, and b is compatible with c and incompatible with d.\nSuppose that the gadget X occurs in an instance. Suppose a is in a solution S. Let e \u2208 Av2 be such that v2 6= v0, v2 6= v1 and e \u2208 S. Let f be the point of S in v1.\nIf b is incompatible with e then a, b, d and e form the forbidden pattern. So b is compatible with e. Similarly, if c is incompatible with e, then a, c, f and e form the forbidden pattern. So c is compatible with e. So if we replace a by b and f by c in S, then we have another solution. So if a is in a solution, then b is also in a solution. So we can remove a while preserving the solvability of the instance.\nSowe can assume from now on that the gadgetX doesn\u2019t occur in the instance. The following lemma indicates when we can perform fusion operations.\nLemma 9. Consider a (simple or complex) fusion of two variables v, v\u2032 in an instance in CSP(T1). Suppose that whenever (a, a\u2032) and (b, b\u2032) are pairs of fused points during this fusion, such that a 6= b \u2208 Av and a\u2032 6= b\u2032 \u2208 Av\u2032 , then either a and b\n\u2032 are incompatible or b and a\u2032 are incompatible. Then the pattern T1 cannot be introduced by this fusion.\nProof. By the definition of (simple or complex) fusion, the only way that T1 could be introduced is when the two points in the central variable of T1 are created by the fusion of pairs of points (a, a\u2032) and (b, b\u2032) such that the compatibility of the points a, b \u2208 Av and a\u2032, b\u2032 \u2208 Av\u2032 with the two other points a1, a2 of T1 are as shown:\nAv1 Av2\nAv Av\u2032\na1 a2\na a\u2032\nb b\u2032\nNow, if a and b\u2032 were incompatible, then T1 was already present on points a1, a, b, b\u2032 in the original instance, and hence cannot be introduced by the fusion. Similarly, if b and a\u2032 were incompatible, then T1 was already present on points b, a\u2032, b\u2032, a2 in the original instance.\nDefinition 9. \u2200v, v\u2032, \u2200a, b \u2208 Av , we say that b is better than a with respect to v\u2032, which we denote by a \u2264 b for (v, v\u2032) (or for v\u2032), if every point in Av\u2032 compatible with a is also compatible with b.\nIt is easy to see that \u2264 is a partial order.\nRemark 1. We also have the relations \u2265, <,> and =, derived in the obvious way from \u2264.\nLemma 10. 1. \u2200(v, v\u2032), the order \u2264 on Av with respect to v \u2032 is total.\n2. \u2200v, \u2200a, b \u2208 Av , there is v \u2032 such that a < b for v\u2032.\n3. \u2200v, \u2200a, b \u2208 Av , there is only one v \u2032 such that a < b for v\u2032.\nProof. 1. Because the gadgetX cannot occur.\n2. Otherwise b is dominated by a and we can remove it by neighbourhood substitution.\n3. Because of the initial forbidden pattern.\nLemma 11. If a < b < c for (v0, v1), then there exists v2 6= v1 such that c < b < a for (v0, v2).\nProof. Since we have a < b for (v0, v1), from Lemma 10.2 there is some v2 such that b < a for (v0, v2). Since b < c for (v0, v1), c \u2264 b for (v0, v2) by Lemma 10.3. If c < b for v2, then we have the lemma. Otherwise, we have c = b < a for v2. Since b < c for v1, there exists v3 6= v1, v2 such that c < b for v3. Since a < b for v1, b \u2264 a for v3. So c < b \u2264 a for v3. So we have c < a for both v2 and v3, which is not possible. So we must have c < b < a in v2.\nLemma 12. \u2200a, b, c, d \u2208 Av0 , for all v1 6= v0 none of the following is true:\n1. a = b < c < d for v1.\n2. a < b = c < d for v1.\n3. a < b < c = d for v1.\nProof. We give the proof only for the case 1, since the proofs of cases 2 and 3 are almost identical. Since we have a < c < d for v1, from Lemma 11 there exists v2 such that d < c < a for v2. Likewise, since b < c < d for v1, there exists v\u20322 such that d < c < b for v \u2032\n2. Since d < c for both v2 and v\u20322, v2 = v \u2032 2 by Lemma 10.3. This leaves three possibilities:\n1. d < c < b < a for v2: from Lemma 11 we know there is v3 such that a < b < c for v3. So we have a < c for both v1 and v3 with v1 6= v3 (since a = b for v1), which is not possible by Lemma 10.3. So we cannot have this possibility.\n2. d < c < b = a for v2: since a = b for both v1 and v2, by Lemma 10.2 there is a different v3 such that a < b for v3. Since c < b for v2 and v3 6= v2, b \u2264 c for v3. So a < c for v3. But we also have a < c for v1 and v1 6= v3. So by Lemma 10.3 we cannot have this possibility.\n3. d < c < a < b for v2: equivalent to the case d < c < b < a after interchanging a and b.\nCorollary 2. If for some (v0, v1), we have at least three equivalence classes in the order on Av0 with respect to v1 then:\n1. The order on Av0 with respect to v1 is strict.\n2. There is v2 such that the order on Av0 with respect to v2 is the exact opposite to the order on Av0 with respect to v1.\n3. \u2200v3 such that v3 6= v0, v1, v2, there is only one equivalence class in the order on Av0 with respect to v3.\nProof. Points 1,2 and 3 follow respectively from Lemma 12, Lemma 11 and Lemma 10.\nLemma 13. \u2200a, b, c, d \u2208 Av0 , there is no v1 such that a = b < c = d for v1.\nProof. By Lemma 10.2, we know there is some v2 such that a < b for v2. Since we have a < c and a < d for v1, by Lemma 10.3, we have c \u2264 a and d \u2264 a for v2. From Corollary 2, we cannot have c < a < b or d < a < b for v2, so we have d = c = a < b for v2. Since we have c = d for both v1 and v2, we have a different variable v3 such that c < d for v3. Since c < b for v2 and v3 6= v2, b \u2264 c for v3. So b < d for v3. But we also have b < d for v1 and v1 6= v3. So, by Lemma 10.3, we cannot have this possibility.\nLemma 14. If for some (v, v\u2032) there are at least three equivalence classes in the order on Av with respect to v\u2032, then there are the same number of points in both Av and Av\u2032 and both the order on Av with respect to v\u2032 and the order on Av\u2032 with respect to v are strict.\nProof. Let d be the number of points in Av and d\u2032 the number of points in Av\u2032 . From Lemma 12 we know that the order on Av with respect to v\u2032 is strict. So we have a1 < a2 < \u00b7 \u00b7 \u00b7 < ad for (v, v\u2032). So we have (a\u20321, a \u2032 2, . . . , a \u2032 d\u22121) such that \u22001 \u2264 i < d, ai and a \u2032\ni are incompatible but ai+1 and a\u2032i are compatible. So \u22002 \u2264 i < d we have ai and a \u2032 i which are incompatible but ai and a \u2032 i\u22121 are compatible. So, by Lemma 10.1 we have a\u20321 > a \u2032 2 > \u00b7 \u00b7 \u00b7 > a \u2032\nd\u22121 for v. Moreover, since a1 is incompatible with a\u20321, a1 is incompatible with all a \u2032 i for 1 \u2264 i < d. By arc consistency, we have a \u2032 0 such that a1 and a\u20320 are compatible. So we have a \u2032 0 > a \u2032 1 > a \u2032 2 > \u00b7 \u00b7 \u00b7 > a \u2032 d\u22121. So we have d \u2264 d \u2032 and at least three equivalence classes in the order on Av\u2032 with respect to v. By switching v and v\u2032 in the proof, we can prove the remaining claims of the Lemma.\nWe say that the pair of variables (v, v\u2032) is a 3-tiers pair if there are at least 3 classes of equivalence in the order on Av with respect to v\u2032; we say that it is a 2-tiers pair otherwise.\nWe suppose we have v and v\u2032 such that (v, v\u2032) is a 3-tiers pair. Let d be the number of points in Av. From Lemma 14 we know that the points in Av can be denoted a1 < a2 < \u00b7 \u00b7 \u00b7 < ad for v\u2032 and the points in Av\u2032 can be denoted b1 < b2 < \u00b7 \u00b7 \u00b7 < bd for v. We will show that we can perform a simple fusion of v and v\u2032 with fusion function f given by f(ai) = bd+1\u2212i (i = 1, . . . , d).\nLemma 15. \u22001 \u2264 i \u2264 d, {bd+1\u2212i, bd+1\u2212i+1, . . . , bd} is the exact set of points compatible with ai.\nProof. If we have ai < aj for v\u2032, it means ai is compatible with strictly less points in Av\u2032 than aj . By arc consistency, every point in Av is compatible with a point in Av\u2032 . So \u22001 \u2264 i \u2264 d, we have d possibilities (1, 2, . . . , d) for the number of points compatible with ai. Since we have d points in Av , it means that \u22001 \u2264 i \u2264 d, ai is compatible with i points in Av\u2032 . By definition of the order on a variable with respect to another variable, the points in Av\u2032 compatible with a point ai \u2208 Av are the greatest points for v. So we have the Lemma.\nLemma 16. \u22001 \u2264 i \u2264 d, if ai is in a solution S, then there is a solution S \u2032 such that both bd+1\u2212i and ai are in S\u2032.\nProof. Let b be the point of S in v\u2032. If bd+1\u2212i = b, then we have the result. Otherwise, let c 6= b be a point of S. If c = ai, then from Lemma 15 we know that c is compatible with bd+1\u2212i. Otherwise, let vc = var(c). So vc 6= v. From Lemma 15 we have bd+1\u2212i < b for v. So b \u2264 bd+1\u2212i for vc. So bd+1\u2212i is compatible with c. So bd+1\u2212i is compatible with all the points in S. So we have a solution S\u2032 obtained by replacing b by bd+1\u2212i in S which contains both ai and bd+1\u2212i.\nWe now perform the simple fusion of v and v\u2032 by with fusion function f(ai) = bd+1\u2212i for 1 \u2264 i \u2264 d. By Lemma 16, this is a valid simple fusion and by Lemma 1 and the following lemma the resulting instance is in CSP(T1) and solvable if and only if the original instance was solvable.\nLemma 17. The simple fusion of v and v\u2032 in an instance in CSP(T1), where (v, v \u2032) is a 3-tiers pair, does not create the forbidden pattern.\nProof. Let a, b be two distinct points in Av . Without loss of generality, suppose that a < b for v\u2032. By choice of the fusion function f , b is the smallest (according to the order < for v\u2032) of the points in Av compatible with f(b). Therefore, a and f(b) are incompatible. The result then follows from Lemma 9.\nFrom now on, \u2200(v, v\u2032), we can assume that each pair (v, v\u2032) is a 2-tiers pair. We call winner for (v, v\u2032) the points in the greater equivalence class in the order for (v, v\u2032). The other points are called losers for this order. A same point can (and actually will) be a winner for a given order and a loser for another order. If for a given order there is only one equivalence class, then all the points are considered winners.\nThe winners for (v, v\u2032) are compatible with all the points in Av\u2032 . The losers for (v, v\u2032) are only compatible with the winners for (v\u2032, v).\nWe say that a variable v is one-winner if \u2200v\u2032 6= v, either only one point of Av is a winner for (v, v\u2032) or all the points in Av are. Similarly, we say that a variable v is one-loser if \u2200v\u2032 6= v, either only one point of Av is a loser for (v, v\u2032) or all the points of Av are winners for (v, v\u2032).\nLemma 18. \u2200v, if there is v\u2032 such that there is only one winner for (v, v\u2032), then v is one-winner. Similarly, if there is v\u2032 such that there is only one loser for (v, v\u2032), then v is one-loser.\nProof. Let a, b, c, d, e, f \u2208 Av be such that there are v1 6= v2 with a = b < c for v1, d < e = f for v2, a 6= b and e 6= f . If d 6= c, then from Lemma 13, we have a = b = d < c for v1 and d < e = f = c for v2. So d < c for both v1 and v2 with v1 6= v2 (which is a contradiction by Lemma 10.3). So we cannot have d 6= c. So d = c. So we have c < e = f for v2. From Lemma 13 we have c < e = f = a = b for v2. Since we have a = b for both v1 and v2, by Lemma 10.2 there is a different variable v3 such that a < b for v3. Since a < c for v1, c \u2264 a for v3. So c < b for\nv3. So c < b for both v2 and v3 with v2 6= v3. This is impossible by Lemma 10.3. So we have the Lemma.\nCorollary 3. \u2200v, either v is one-winner or v is one-loser.\nProof. Lemma 10.2 tells us that there exists v\u2032 and a, b \u2208 Av such that a < b for v\u2032. By Lemma 13, either there is only one winner for (v, v\u2032) or only one loser. The result follows directly from Lemma 18.\nLet E be the set of one-winner variables and F = V \\E with V being the set of all variables. From Corollary 3, the variables in F are one-loser. Let va, vb \u2208 E be such that there is a non-trivial constraint between va and vb. Since va \u2208 E, there is only one winner a for vb in va. Similarly, there is only one winner b for va in vb. We can perform a complex fusion of va and vb with hinge value a and fusion function the constant function f = b.\nBy Lemma 1, the instance resulting from this fusion is solvable if and only if the original instance was solvable.\nLemma 19. The complex fusion of two one-winner variables va and vb in an instance of CSP(T1) does not create the forbidden pattern.\nProof. Suppose that (c, c\u2032) and (d, d\u2032) are corresponding pairs of points during this fusion, with c 6= d \u2208 Ava and c\n\u2032 6= d\u2032 \u2208 Avb . Since va only has one winner for vb, we know that either c or d is a loser for vb. Without loss of generality, suppose d is a loser for vb. Since vb only has one winner for va, and losers are only compatible with winners, we know that d is incompatible with c\u2032 (since it is necessarily compatible with d\u2032 for the fusion to take place). The result now follows directly from Lemma 9.\nWe have shown that we can fusion any pair of variables in E between which there is a nontrivial constraint. We now do the same for F .\nLet E be the set of one-winner variables and F = V \\E with V being the set of all variables. From Corollary 3, we know all variables in F are one-loser. Let va, vb \u2208 F be such that there is a non-trivial constraint between va and vb. Since there is a non-trivial constraint between va and vb, there is some a \u2208 Ava and some b \u2208 Avb such that a is incompatible with b.\nLemma 20. If a\u2032 \u2208 Ava is in a solution S and a \u2032 6= a, then b is in a solution S\u2032 containing a\u2032.\nProof. Let b\u2032 be the point of S in vb. If b\u2032 = b, then we have the result. Since va is a one-loser variable, we know that all points in Ava other than a are winners. Thus a\n\u2032 is compatible with b. By a symmetric argument, b\u2032 is compatible with a. If we have c \u2208 S such that b is incompatible with c, then a, b\u2032, c and b form the forbidden pattern. So b is compatible with all the points in S. So if we replace b\u2032 by b in S we get a solution S\u2032 containing both a\u2032 and b.\nIt follows from Lemma 20 that we only need to consider solutions containing a or b. We can therefore perform a complex fusion of va and vb with hinge value a and fusion function the constant function f = b.\nLemma 21. The complex fusion of va and vb in an instance of CSP(T1) does not create the forbidden pattern.\nProof. In all pairs (c, c\u2032) of corresponding points in this fusion, we must have either c = a or c\u2032 = b. Suppose that (c, c\u2032) and (d, d\u2032) are corresponding pairs of points during the fusion, with c 6= d \u2208 Ava and c \u2032 6= d\u2032 \u2208 Avb . Without loss of generality, we can assume that c = a and d \u2032 = b. But we know that awas incompatible with b. The result now follows directly from Lemma 9.\nWe say a point a is weakly incompatiblewith a variable v if there exists some b \u2208 Av such that a is incompatible with b.\nThe total number of assignments decreases when we fuse variables, so the total number of (simple or complex) fusions that can be performed is linear in the size of the original instance. After all possible fusions of pairs of variables, we have two sets of variables E and F = V \\ E such that:\n\u2022 \u2200v, v\u2032 \u2208 E, there is no non-trivial constraint between v and v\u2032.\n\u2022 \u2200v, v\u2032 \u2208 F , there is no non-trivial constraint between v and v\u2032.\n\u2022 \u2200f a point in Av for some v \u2208 F , f is weakly incompatible with one and only one variable v\u2032 \u2208 E. Furthermore, f is incompatible with all points of Av\u2032 but one (since v\u2032 \u2208 E is a one-winner variable).\n\u2022 The only possible non-trivial constraint between a variable v1 \u2208 E and another variable v2 \u2208 F is the following with d1 being the size of the domain of v1:\n\u2013 There is a point b \u2208 Av2 incompatible with exactly d1 \u2212 1 points in Av1 .\n\u2013 \u2200b\u2032 \u2208 Av2 with b \u2032 6= b, b\u2032 is compatible with all the points in Av1 .\nAv1 Av2\nb\nWe call NOOSAT (for Non-binary Only Once Sat) the following problem:\n\u2022 A set of variables V = {v1, v2, . . . , ve}.\n\u2022 A set of values A = {a1, a2, . . . , an}.\n\u2022 A set of clauses C = {C1, C2, . . . , Cf} such that:\n\u2013 Each clause is a disjunction of literals, with a literal being in this case of the form vi = aj .\n\u2013 \u2200i, j, p, q((vi = aj) \u2208 Cp) \u2227 ((vi = aj) \u2208 Cq) \u21d2 p = q.\nLemma 22. CSP(T1) can be reduced to NOOSAT in polynomial time.\nProof. We suppose we have a binary CSP instance in CSP(T1) and preprocessed as described above. We have shown that the non-trivial constraints between variables v \u2208 F and v\u2032 \u2208 E are all of the form v = b \u21d2 v\u2032 = a. Furthermore, each variable-value assignment v = b occurs in exactly one such constraint. For any v \u2208 F , we can replace the set of such constraints v = bi \u21d2 vi = ai, for all values bi in the domain of v, by the clause (v1 = a1) \u2228 . . . \u2228 (vd = ad). It only remains to\nprove that no literal appears in two distinct clauses. Suppose that we have a literal v1 = a which occurs in two distinct clauses. Then there must have been two constraints v2 = b \u21d2 v1 = a and v3 = c \u21d2 v1 = a and with v1 \u2208 E, v2 6= v3 \u2208 F . Let a\u2032 6= a be a point in Av1 . Then b and c are both incompatible with a\u2032 but compatible with a. But this is precisely the forbidden pattern. This contradiction shows that CSP(T1) can be reduced to NOOSAT.\nThe constraints in NOOSAT are convex when viewed as {0,\u221e}-valued cost functions, and the clauses are non overlapping. So, from [6], it is solvable in polynomial time. So the forbidden pattern T1 is tractable.\nProof of tractability of T2 : Let the gadgetN be the following pattern: two variables v0, v1 with points a, b \u2208 Av0 and c, d \u2208 Av1 , such that a and b compatible with d, b incompatible with c and with the structure a 6= b.\nb\ndc\na\nAv0\nAv1\nSuppose we have the gadgetN . Let v2 be a variable with v2 6= v0, v2 6= v1 and let e be a point in Av2 such that a and e are compatible. If b is incompatible with e, then we have the forbidden pattern T2 on d, c, b, a, e. So b is compatible with e. If all the points in Av1 which are compatible with a are also compatible with b, then we can remove a by neighbourhood substitution. So, assuming that neighbourhood substitution operations have been applied until convergence, if we have the gadgetN , then there is a point g \u2208 Av1 compatible with a and incompatible with b.\nLet v3 6= v1. By arc consistency, there is h \u2208 Av3 such that h is compatible with a. If b and h are incompatible, then we have the forbidden pattern T2 on d, g, b, a, h. So b and h are compatible. If there is i \u2208 Av3 such that b and i are incompatible, then we have the forbidden pattern on h, i, b, a, g. So b is compatible with all the points in Av3 . So, if we have the gadget N , then b is compatible with all the points of the instance outside v0, v1.\nDefinition 10. A constraint C between two variables v and v\u2032 is functional from v to v\u2032 if \u2200a \u2208 Av, there is one and only one point in Av\u2032 compatible with a.\nLet the gadget V \u2212 be the pattern comprising three variables v4, v5, v6 and points a \u2208 Av4 , b \u2208 Av5 , c \u2208 Av6 such that a incompatible with both b and c.\nFrom now on, since V \u2212 is a tractable pattern [9], we only need to consider the connected components of the constraint graph which contain V \u2212.\nLemma 23. If in an instance from CSP(T2), we have the gadget V \u2212, then the constraint between v5 and v4 is functional from v5 to v4 and the constraint between v4 and v6 is functional from v6 to v4.\nProof. By symmetry, it suffices to prove functionality from v5 to v4. We suppose we have the gadget V \u2212. Let d \u2208 Av5 be compatible with a. Since a is weakly incompatible with two different variables, a, b and d cannot be part of the gadgetN . So the only point in Av4 compatible with d is a. So if a point in Av4 is compatible with a, then it is only compatible with a. Likewise, if a point in Av6 is compatible with a, then it is only compatible with a.\nLet f 6= a be a point in Av4 . By arc consistency, we have d \u2208 Av5 and e \u2208 Av6 such that a is compatible with d and with e. From the previous paragraph, we know that both d and e are incompatible with f .\na\nbd\nf\nc e\nAv4\nAv5 Av6\nSo d, e and f form the gadget V \u2212. So each point in Av5 and Av6 compatible with f is compatible with only one point of Av4 . So each point in Av5 and Av6 compatible with a point in Av4 is compatible with only one point of Av4 . By arc consistency, each point of Av5 and Av6 is compatible with exactly one point of Av4 . So the constraint between v4 and v5 is functional from v5 to v4.\nLemma 24. In a connected component of the constraint graph containing V \u2212 of an instance fromCSP(T2), all constraints are either functional or trivial.\nProof. Let P (V ) be the following property: \"V is a connected subgraph of size at least two of the constraint graph and all constraints in V are either functional or trivial\".\nP ({v4, v5} is true from Lemma 23. Let Vall be the set of all variables of the connected subgraph of the constraint graph containing V \u2212. Let V be a maximum (with respect to inclusion) subset of Vall for which P (V ). Let V \u2032 = Vall\\V . Let v\u2032 \u2208 V \u2032. Let v \u2208 V be such that C(v, v\u2032) (the constraint on v, v\u2032) is non-trivial. So there is d \u2208 Av and e \u2208 Av\u2032 such that d and e are incompatible. Since V is connected and of cardinality at least two, then there is v\u2032\u2032 \u2208 V such that C(v, v\u2032\u2032) is functional. By arc consistency and elimination of single-valued variables, there is necessarily a point f \u2208 Av\u2032\u2032 such that d and f are incompatible. So d, e and f form the gadget V \u2212. From Lemma 23 we know C(v, v\u2032) is functional. So P (V ) is true for all subsets of Vall.\nLemma 25. \u2200v, all points in Av are weakly incompatible with the exact same set of variables.\nProof. Let a \u2208 Av be weakly incompatible with v\u2032. So C(v, v\u2032) is non trivial. So C(v, v\u2032) is functional.\nIf C(v, v\u2032) is functional from v to v\u2032, then a point in Av can be compatible with only one point inAv\u2032 . We can assume, by elimination of single-valued variables, that there are at least two points in Av\u2032 , so every point in Av is weakly incompatible with v\u2032.\nIf C(v, v\u2032) is functional from v\u2032 to v, then let b 6= a in v. By arc consistency, we know there is c \u2208 Av\u2032 such that a and c are compatible. Since C(v, v\u2032) is functional from v\u2032 to v, then c is compatible with only one point in Av, in that case a, so b is incompatible with c. So every point in Av is weakly incompatible with v\u2032.\nSo \u2200(v, v\u2032), a \u2208 Av weakly incompatible with v\u2032 \u21d2 \u2200b \u2208 Av, bweakly incompatible with v\u2032.\nDefinition 11. A sequence of variables (v0, v1, . . . , vk) is a path of functionality if \u22000 \u2264 i \u2264 k \u2212 1 : C(vi, vi+1) is functional from vi to vi+1.\nLemma 26. \u2200v, v\u2032, either v\u2032 is a leaf in the constraint graph, or there is a path of functionality from v to v\u2032.\nProof. Sincewe are in a connected component, there is a path of incompatibility (v0 = v, v1, v2, . . . , vk = v\u2032)with all vi different. If v\u2032 is not a leaf, thenwe have a path of incompatibility (v0, v1, v2, . . . , vk\u22121, vk, vk+1) with vk+1 6= vk\u22121. FromLemma 25we have a path of incompatibility (a0 \u2208 Av0 , a1 \u2208 Av1 , . . . , ak \u2208 Avk , ak+1 \u2208 Avk+1). So \u22001 \u2264 i \u2264 k, ai\u22121, ai and ai+1 form the gadget V\n\u2212. So from Lemma 23, \u22001 \u2264 i \u2264 k, C(vi\u22121, vi) is functional from vi\u22121 to vi. So we have a path of functionality from v to v\u2032.\nLeaves can be added to an existing solution by arc consistency. So once we have removed all the points we can (from the gadget N ) we only have to set an initial variable v0 and see if the q chains of implications (with q being the number of points inAv0 ) lead to a solution. So the pattern T2 is tractable.\nProof of tractability of T3 : Consider an instance from CSP(T3). Let N be the following gadget: two variables v0 and v1 such that we have a in Av0 , b and c in Av1 , with b 6= c, a compatible with both b and c and c incompatible with a point in Av0 . Let d be a point in Av2 , with v2 6= v0, v1. If d is compatible with c but not with b, then we have the forbidden pattern T3. So if c is compatible with a point outside of Av0 , then b is also compatible with the same point.\nLet S be a solution containing c. Let e be the point of S in Av0 . If e is compatible with b, then we can replace c by b in S while maintaining the correctness of the solution, since all the points in the instance outside of Av0 which are compatible with c are also compatible with b.\nIf e is not compatible with b, then edges {b, e}, {e, c} and {c, a} form the gadgetN . So, by our previous argument, if e is compatible with a point outside of Av1 , then a is also compatible with the same point. We can then replace c by b and e by a in S while maintaining the correctness of the solution, since all the points in the instance outside of Av0 which are compatible with c are also compatible with b and all the points in the instance outside ofAv1 which are compatible with e are also compatible with a. So if a solution contains c, then there is another solution containing b. Thus we can remove cwhile preserving solvability.\nSo each time the gadget N is present, we can remove one of its points and hence eliminate N . The gadgetN is a known tractable pattern since forbidding N is equivalent to saying that all constraints are either trivial or bijections. So if it is not present, then the instance is tractable. It follows that the pattern T3 is tractable.\nProof of tractability of T4 : Consider an instance from CSP(T4).\nLet W be the following gadget: two variables v0 and v1 such that we have a in Av0 , b and c inAv1 , with b 6= c, a compatible with both b and c, and a incompatible with a point in Av1 .\ncb\na\n6=\nAv0\nAv1\nLet f be a point in Av2 , with v2 6= v0, v1. If f is compatible with b but not with c, then we have the forbidden pattern T4. Likewise, if f is compatible with c but not with b, then we have the forbidden pattern T4. So all the points of the instance not in Av0 or Av1 have the same compatibility towards b and c.\nIf all points in Av0 compatible with b are also compatible with c, then all the points in the instance compatible with b are also compatible with c and by neighborhood substitution we can remove b. Thus we can assume there is d in Av0 such that d is compatible with b but not with c.\nLet S be a solution containing c. Let e be the point of S in v0. If e is compatible with b, then we can replace c by b in S while maintaining the correctness of the solution, since b and c have the same compatibility towards all the points in the instance outside of Av0 and Av1 . If e is not compatible with b, then edges {b, e}, {b, a} and {b, d} form the gadget W . So, by our argument above, a and d have the same compatibility towards all the points in the instance outside of Av0 and Av1 . Similarly, edges {c, d}, {c, a} and {c, e} form the gadget W . So a and e have the same compatibility towards all the points in the instance outside of Av0 and Av1 . So d and e have the same compatibility towards all the points in the instance outside of Av0 and Av1 . Thus we can replace c by b and e by d in S while maintaining the correctness of the solution, since b and c have the same compatibility towards all the points in the instance outside of Av0 and Av1 and e and d have the same compatibility towards all the points in the instance outside of Av0 and Av1 . So if a solution contains c, then there is another solution containing b. Thus we can remove c.\nTherefore, each time the gadget W is present, we can remove one of its points. The gadget W is a known tractable pattern since forbiddingW is equivalent to saying that all constraints are zero-one-all [7]. So if it is not present, the instance is tractable. Hence pattern T4 is tractable.\nProof of tractability of T5 : The pattern T5 is a sub-pattern of the broken-triangle patternBTP , a known tractable pattern [8] on three constraints. So the pattern T5 is tractable."}, {"heading": "6 Conclusion", "text": "An avenue for future research is to investigate the possible generalisations of the five tractable classes defined by forbidding patterns T1, . . . , T5. Possible generalisations include the addition of costs, replacing binary constraints by k-ary constraints (k > 2) and adding extra constraints to the patterns."}], "references": [{"title": "An optimal coarse-grained arc consistency algorithm", "author": ["C. Bessi\u00e8re", "R\u00e9gin", "J.-C", "R.H.C. Yap", "Y. Zhang"], "venue": "Artificial Intelligence,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2005}, {"title": "Classifying the complexity of constraints using finite algebras", "author": ["A. Bulatov", "P. Jeavons", "A. Krokhin"], "venue": "SIAM Journal on Computing,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2005}, {"title": "A dichotomy theorem for constraint satisfaction problems on a 3-element set", "author": ["A.A. Bulatov"], "venue": "Journal of the ACM,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "The Complexity of Theorem-Proving Procedures", "author": ["S.A. Cook"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1971}, {"title": "Fundamental properties of neighbourhood substitution in constraint satisfaction problems", "author": ["M.C. Cooper"], "venue": "Artificial Intelligence", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1997}, {"title": "Hierarchically nested convex VCSP", "author": ["M.C. Cooper", "S. Z\u0306ivn\u00fd"], "venue": "Proc. CP 2011,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Characterising tractable constraints, Artificial Intelligence", "author": ["M.C. Cooper", "D.A. Cohen", "P.G. Jeavons"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1994}, {"title": "Generalizing constraint satisfaction on trees: Hybrid tractability and variable elimination", "author": ["M.C. Cooper", "P.G. Jeavons", "A.Z. Salamon"], "venue": "Artificial Intelligence,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Hybrid tractability of valued constraint problems", "author": ["M.C. Cooper", "S. \u017divn\u00fd"], "venue": "Artificial Intelligence,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Eliminating interchangeable values in constraint satisfaction problems", "author": ["E.C. Freuder"], "venue": "Proceedings AAAI-91,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1991}, {"title": "Computers and Intractability: A Guide to the Theory of NP- Completeness, W.H", "author": ["M.R. Garey", "D.S. Johnson"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1979}, {"title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side", "author": ["M. Grohe"], "venue": "Journal of the ACM,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "Can You Beat Treewidth", "author": ["D. Marx"], "venue": "Theory of Computing,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Tractable hypergraph properties for constraint satisfaction and conjunctive queries, STOC \u201910", "author": ["D. Marx"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}], "referenceMentions": [{"referenceID": 1, "context": "In some cases, dichotomies have even been proved characterising all tractable classes definable by placing restrictions either on the constraint relations [2, 3] or on the (hyper)graph of constraint scopes [12, 13, 14].", "startOffset": 155, "endOffset": 161}, {"referenceID": 2, "context": "In some cases, dichotomies have even been proved characterising all tractable classes definable by placing restrictions either on the constraint relations [2, 3] or on the (hyper)graph of constraint scopes [12, 13, 14].", "startOffset": 155, "endOffset": 161}, {"referenceID": 11, "context": "In some cases, dichotomies have even been proved characterising all tractable classes definable by placing restrictions either on the constraint relations [2, 3] or on the (hyper)graph of constraint scopes [12, 13, 14].", "startOffset": 206, "endOffset": 218}, {"referenceID": 12, "context": "In some cases, dichotomies have even been proved characterising all tractable classes definable by placing restrictions either on the constraint relations [2, 3] or on the (hyper)graph of constraint scopes [12, 13, 14].", "startOffset": 206, "endOffset": 218}, {"referenceID": 13, "context": "In some cases, dichotomies have even been proved characterising all tractable classes definable by placing restrictions either on the constraint relations [2, 3] or on the (hyper)graph of constraint scopes [12, 13, 14].", "startOffset": 206, "endOffset": 218}, {"referenceID": 7, "context": "Novel tractable classes have been discovered by forbidding simple 3-variable subproblems [8, 9].", "startOffset": 89, "endOffset": 95}, {"referenceID": 8, "context": "Novel tractable classes have been discovered by forbidding simple 3-variable subproblems [8, 9].", "startOffset": 89, "endOffset": 95}, {"referenceID": 0, "context": "Given a CSP instance \u3008V,A, var, E, cpt\u3009, arc consistency consists in eliminating from A all assignments a for which there is some variable v 6= var(a) in V such that \u2200b \u2208 Av , cpt(a, b) = F [1].", "startOffset": 190, "endOffset": 193}, {"referenceID": 9, "context": "Given a CSP instance \u3008V,A, var, E, cpt\u3009, if for var(a) = var(b) and for all variables v 6= var(a), \u2200c \u2208 Av , cpt(a, c) = T \u21d2 cpt(b, c) = T , then we can eliminate a from A by neighbourhood substitution, since in any solution in which a appears, we can replace a by b [10].", "startOffset": 267, "endOffset": 271}, {"referenceID": 4, "context": "Establishing arc consistency and eliminating single-valued variables until convergence produces a unique result, and the result of applying neighbourhood substitution operations until convergence is unique modulo isomorphism [5].", "startOffset": 225, "endOffset": 228}, {"referenceID": 3, "context": "SAT1 is trivially equivalent to SAT which is well known to be NP-complete [4].", "startOffset": 74, "endOffset": 77}, {"referenceID": 10, "context": "Since 3-COLOURING is NP-complete [11], it suffices to give a polynomial reduction from 3-COLOURING to CSP(Z), the set of CSP instances in which the pattern Z does not occur.", "startOffset": 33, "endOffset": 37}, {"referenceID": 6, "context": "For example, T4 defines a class of instanceswhich includes as a proper subset all instances with zero-one-all constraints [7].", "startOffset": 122, "endOffset": 125}, {"referenceID": 5, "context": "So, from [6], it is solvable in polynomial time.", "startOffset": 9, "endOffset": 12}, {"referenceID": 8, "context": "From now on, since V \u2212 is a tractable pattern [9], we only need to consider the connected components of the constraint graph which contain V .", "startOffset": 46, "endOffset": 49}, {"referenceID": 6, "context": "The gadget W is a known tractable pattern since forbiddingW is equivalent to saying that all constraints are zero-one-all [7].", "startOffset": 122, "endOffset": 125}, {"referenceID": 7, "context": "Proof of tractability of T5 : The pattern T5 is a sub-pattern of the broken-triangle patternBTP , a known tractable pattern [8] on three constraints.", "startOffset": 124, "endOffset": 127}], "year": 2012, "abstractText": "Although the CSP (constraint satisfaction problem) is NP-complete, even in the case when all constraints are binary, certain classes of instances are tractable. We study classes of instances defined by excluding subproblems. This approach has recently led to the discovery of novel tractable classes. The complete characterisation of all tractable classes defined by forbidding patterns (where a pattern is simply a compact representation of a set of subproblems) is a challenging problem. We demonstrate a dichotomy in the case of forbidden patterns consisting of either one or two constraints. This has allowed us to discover new tractable classes including, for example, a novel generalisation of 2SAT.", "creator": "LaTeX with hyperref package"}}}