{"id": "1203.0220", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Mar-2012", "title": "The Equational Approach to CF2 Semantics", "abstract": "We introduce a family of new equational semantics for argumentation networks which can handle odd and even loops in a uniform manner. We offer one version of equational semantics which is equivalent to CF2 semantics, and a better version which gives the same results as traditional Dung semantics for even loops but can still handle odd loops.", "histories": [["v1", "Thu, 1 Mar 2012 15:45:31 GMT  (40kb)", "http://arxiv.org/abs/1203.0220v1", "36 pages, version dated 15 February 2012"]], "COMMENTS": "36 pages, version dated 15 February 2012", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["dov m gabbay"], "accepted": false, "id": "1203.0220"}, "pdf": {"name": "1203.0220.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n20 3.\n02 20\nv1 [\ncs .A\nI] 1\nM ar\n2 01\n2"}, {"heading": "The Equational Approach to CF2 Semantics", "text": ""}, {"heading": "Dov M. Gabbay", "text": "Bar Ilan University, Israel;"}, {"heading": "King\u2019s College London, UK; University of Luxembourg, Luxembourg", "text": "Paper 459h: DovPapers/459o/459-EACF2s.tex\nFebruary 2012; Version dated 15 February 2012\nabstract. We introduce a family of new equational semantics for argumentation networks which can handle odd and even loops in a uniform manner. We offer one version of equational semantics which is equivalent to CF2 semantics, and a better version which gives the same results as traditional Dung semantics for even loops but can still handle odd loops."}, {"heading": "1 Background and orientation", "text": "Our starting point is the important papers of Baroni, Giacomin and Guida on odd loops and SCC recursiveness [1, 6]. In their papers the authors offer the CF2 semantics in response to difficulties arising from the Dung semantics handling of odd and even loops. In our paper we outline our equational approach to argumentation networks and show how the CF2 semantics can be obtained from perturbations to the equations associated with the networks. This approach will offer additional methodological support for the CF2 semantics, while at the same time show the power of the equational approach. We offer our own loop-busting equational semantics LB, which includes CF2 as a special case.\nThe structure of this paper is as follows. Section 2 reproduces the motivating discussion from [1] for the CF2 semantics and points out its weaknesses. Section 3 introduces the equational semantics. Section 4 defines our loop busting semantics LB. Section 5 introduces our semantics LB2 and compares with CF2 on the technical level. We conclude with a general discussion in Section 6."}, {"heading": "2 CF2 semantics as introduced in the SCC paper [1]", "text": "Baroni et al. devote a long discussion about the inadequacy of the traditional semantics in handling odd and even loops. They say, and I quote:\n\u201cthe length of the leftmost cycle should not affect the justification states [of an argument]. More generally, it is counter-intuitive that different results in conceptually similar situations depend on the length of the cycle. Symmetry reasons suggest that all cycles should be treated equally and should yield the same results.\u201d\nWe now reproduce Figure 8 of [1], and discuss the problems associated with it.\nThe only preferred extension for Figure 1(a) is {\u03c6, \u03b1}, while for Figure 1(b) we have the extensions {\u03b1, \u03b2, \u03c6} and {\u03b4, \u03b3}. These two results are conceptually different, in (a) \u03c6 is not prevented from being justified while in (b) it is prevented.\nA more striking problem is the one outlined in Figure 9 of Baroni et al. [1], here reproduced as Figure 2.\nThe only extension in traditional Dung semantics is all undecided. Common sense, however, expects \u03b3 to be out and \u03b4 to be in. In [5], this is characterised as \u201cone of the main unsolved problems in argumentation-based semantics\u201d.\nThe CF2 semantics of [1] treats the loops of Figures 1(a) and 1(b) and 2 all in the same way, by taking as CF2 extensions maximal conflict-free sets. We therefore get for Figure 1(a) the CF2 extensions\n{\u03b1, \u03c6}, {\u03b2, \u03c6} and {\u03b3}\nand for Figure 1(b) we get\n{\u03b1, \u03b2, \u03c6}, {\u03b4, \u03b3} and {\u03b4, \u03c6}\nand for Figure 2 we get the extensions\n{\u03b2, \u03b4}, {\u03b1, \u03b4} and {\u03c6, \u03b4}.\nLet us put forward a figure of our own, Figure 3. This is a 9 point cycle. The CF2 semantics will take all maximal conflict free subsets as extensions, including among them {a3, a6, a9} and its cyclic translations as well as {a1, a3, a5, a7} and its cyclic translations (e.g. {a2, a4, a6, a8}, etc.).\nWe shall see later that some of our loop busting semantics LB yield only {a1, a3, a5, a7} and its cyclic translations and not {a3, a6, a9}, but other LB semantics does yield it.\nWe agree with [1] on the need for a new approach but we feel that the CF2 semantics offered as a solution requires further independent methodological justification. The notion of conflict freeness is a neutral notion and does not use the central notion of \u201cattack\u201d of the Dung semantics. When we get a loop like {\u03b1, \u03b2, \u03b3}, in a real life application as in Figure 1(a), there are good reasons for the loop in the context of the application area where it arises, and we want a decisive solution to the loop in terms of {in, out}, which makes sense in the application area. We do not want just a technical, non-decisive choice of maximal conflict free sets, a sort of compromise which involves no real decision making. Imagine we have a loop with {\u03b1, \u03b2, \u03b3}, and we go to a judge and we expect some effective decision making. We hope for something like \u201cI think \u03b3 is not serious\u201d.\nTaking the maximal conflict free sets in this case, namely {\u03b1}, {\u03b2} and {\u03b3} means nothing. We would perceive that the judge is not doing his job properly and that he is just offering us options which are obvious and non-controversial, given the geometry of the loop! See [3] for extensive examples of resolving loops in a practical realistic way.\nAnother problem, in our opinion, with the CF2 semantics is that it is an overkill as far as loop-breaking is concerned. If we look at Figures 1(a) and 1(b) and replace them by Figure 4 and 5 our loop-breaking needs are the same according to [1], but in Figure 4, we do not need the extensions {a3, a6, a9, b} from the loop-breaking point of view. In our LB semantics we do not mind if there will be less extensions than CF2, in the odd cycle case of Figure 4 but insist that there will be the same extensions as the traditional Dung semantics\nin the even cycle of Figure 5. CF2 gives more extensions then the traditional Dung extensions for Figure 5.\nWe should realise that within the context of argumentation theory alone, the maximal conflict free CF2 solution seems somewhat arbitrary, a device which is just technically successful.\nIt is also the only device available for the loop breaking in this context. The next sections will discuss the equational approach of [4], and introduce\nthe new LB semantics."}, {"heading": "3 The equational approach", "text": "Let A = (S,R) be an argumentation frame S 6= \u2205 is the set of arguments and R \u2286 S \u00d7 S is the attack relation. The equational approach views (S,R) as a bearer of equations with the elements of S as the variables ranging over [0, 1] and with R as the generator of equations. Let x \u2208 S and let y1, . . . , yk be all of its attackers. We write two types of equations Eqmax(A) and Eqinverse(A). 1\nFor Eqmax we write\n\u2022 x = 1\u2212max(y1, . . . , yk)\n\u2022 x = 1 if it has no attackers.\nFor Eqinverse we write\n\u2022 x = \u220fk\ni=1(1\u2212 yi)\n\u2022 x = 1, if it has no attackers.\n1In [4] there are more Eq options.\nWe seek solutions f for the above equations. In [4] we prove the following:\nTHEOREM 1.\n1. There is always at least one solution in [0, 1] to any system of continuous equations Eq(A).\n2. If we use Eqmax(A) then the solutions f correspond exactly to the Dung extensions of A. Namely\n\u2022 f(x) = 1 corresponds to x = in\n\u2022 f(x) = 0 corresponds to x = out\n\u2022 0 < f(x) < 1 corresponds to x = undecided.\nThe actual value in [0, 1] reflects the degree of odd looping involving x.\n3. If we use Eqinverse, we give more sensitivity to loops. For example the more undecided elements y attack x, the closer to 0 (out) its value gets.\nIn the context of equations, a very natural step to take is to look at Perturbations. If the equations describe a physical or economic system in equilibrium, we want to change the solution a bit (perturb the variables) and see how it affects the system. For example, when we go to the bank to negotiate a mortgage, we start with the amount we want to borrow and indicate for how many years we want the loan and then solve equations that tell us what the monthly payment is going to be. We then might change the amount or the number of years or even negotiate the interest rate if we find the monthly payments too high.\nIn the equational system arising from an argumentation network we can try and fix the value of some arguments and see what happens. In the equational context, this move is quite natural. We shall see later, that fixing some values to 0 in the equations of Eq(A), amounts to adopting the CF2 semantics, when done in a certain way. When done in other ways it gives the new loop-busting semantics LB.\nEXAMPLE 2. Consider Figure 2. The equations for this figure are (we use Eqinverse)\n1. \u03b1 = 1\u2212 \u03c6\n2. \u03b2 = 1\u2212 \u03b1\n3. \u03c6 = 1\u2212 \u03b2\n4. \u03b3 = (1\u2212 \u03b1)(1 \u2212 \u03b2)(1 \u2212 \u03c6)\n5. \u03b4 = 1\u2212 \u03b3\nThe solution here is\n\u03b1 = \u03b2 = \u03c6 = 12 \u03b3 = 18 \u03b4 = 78\nLet us perturb the equation by adding an external force which makes a node equal zero. The best analogy I can think of is in electrical networks where you make the voltage of a node 0 by connecting it to earth.\nLet Z(x) be the \u201cearth\u201d connection for node x. We now do several perturbations as examples\n(a). Let\u2019s choose to make \u03c6 = 0.\nWe replace equation 3 by\n3\u2217a. \u03c6 = (1\u2212 \u03b2)Z(\u03c6)\n3\u2217b. Z(\u03c6) = 0.2\nThe equations now solve to\n\u03c6 = 0, \u03b1 = 1, \u03b2 = 0\n\u03b3 = 0\n\u03b4 = 1.\nThis gives us the extension {\u03b1, \u03b4}\n(b). If we try to make \u03b1 = 0, we replace equation (1) by\n2We use Z and write 3\u2217a and 3\u2217b, rather than just writing 3\u2217 a = 0 because of algebraic considerations. The current equations can be manipulated algebraically to to prove a = b = c. By adding a fourth variable Z(\u03c6) we prevent that.\n1\u2217a. \u03b1 = (1\u2212 \u03c6)Z(\u03b1)\n1\u2217b. Z(\u03b1) = 0\nWe solve the equations and get\n\u03b1 = 0, \u03b2 = 1, \u03c6 = 0\n\u03b3 = 0\n\u03b4 = 1\nThis corresponds to the extension {\u03b2, \u03b4}.\n(c). Now let us make \u03b2 = 0. We replace equation (1) by\n2\u2217a. \u03b2 = (1\u2212 \u03b1)Z(\u03b2)\n2\u2217b. Z(\u03b2) = 0\nSolving the new equations gives us\n\u03b2 = 0, \u03c6 = 1, \u03b1 = 0\n\u03b3 = 0\n\u03b4 = 1\nThis gives us the extension {\u03c6, \u03b4}.\nIf we compare these extensions with the CF2 extensions, we see that they are the same.\nEXAMPLE 3. Let us see what happens with Figure 1(b). Here we have a well behaved even loop. Let us write the equations\n1. \u03b1 = 1\u2212 \u03b3\n2. \u03b4 = 1\u2212 \u03b1\n3. \u03b2 = 1\u2212 \u03b4\n4. \u03b3 = 1\u2212 \u03b2\n5. \u03c6 = 1\u2212 \u03b3\nLet us do some perturbations:\n(a) Let us make \u03b3 = 0. We change equation 4 to\n4\u2217a. \u03b3 = (1\u2212 \u03b2)Z(\u03b3)\n4\u2217b. Z(\u03b3) = 0\nWe solve the new equations and get\n\u03b3 = 0, \u03b1 = 1, \u03b4 = 0, \u03b2 = 1, \u03c6 = 1.\nThe extension is {\u03b1, \u03b2, \u03c6}.\n(b) Let us try \u03b1 = 0. we replace equation 1 by\n1\u2217a. \u03b1 = (1\u2212 \u03b3)Z(\u03b1)\n1\u2217b. Z(\u03b1) = 0\nWe solve the new equations and get\n\u03b1 = 0, \u03b4 = 1, \u03b2 = 0, \u03b3 = 1, \u03c6 = 0\nThe extension we get is {\u03b4, \u03b3}.\n(c) Let us make \u03b4 = 0. We replace equation 2 by\n2\u2217a. \u03b4 = (1 \u2212 \u03b1)Z(\u03b4)\n2\u2217b. Z(\u03b4) = 0\nThe solution is\n\u03b4 = 0, \u03b1 = 1, \u03b2 = 1, \u03b3 = 0 and \u03c6 = 1\nThis gives the extension {\u03b1, \u03b2, \u03c6}\n(d) Let us make \u03b2 = 0. the new equations for \u03b2 are\n3\u2217a. \u03b2 = (1\u2212 \u03b4)Z(\u03b2)\n3\u2217b. Z(\u03b2) = 0\nWe solve the new set of equations and get\n\u03b2 = 0, \u03b3 = 1, \u03c6 = 0, \u03b1 = 0, \u03b4 = 1.\nThe extension is {\u03b3, \u03b4}.\n(e) Let us make \u03c6 = 0. We change equation 5 to\n5\u2217a. \u03c6 = (1\u2212 \u03b3)Z(\u03c6)\n5\u2217b. Z(\u03c6) = 0\nWe solve the new equations.\nFrom (3) and (4) we get\n5. \u03b4 = \u03b3\nFrom (1) and (2) we get\n7. \u03b1 = \u03b2.\nLet \u03b1 = \u03b2 = x. Then \u03b3 = \u03b4 = 1\u2212 x.\nIf we want {0, 1} extensions, i.e. x \u2208 {0, 1}, then we get the extensions {\u03b1, \u03b2}, case {x = 1, \u03c6 = 0} {\u03b3, \u03b4}, case {x = 0, \u03c6 = 0}.\n(f) Let us make \u03b1 = \u03b3 = 0. The new equations are\n1\u2217a. \u03b1 = (1\u2212 \u03b3)Z(\u03b1)\n1\u2217b. Z(\u03b1) = 0\n2. \u03b4 = 1\u2212 \u03b1\n3. \u03b2 = 1\u2212 \u03b4\n4\u2217a. \u03b3 = (1\u2212 \u03b2)Z(\u03b3)\n4\u2217b. Z(\u03b3) = 0\n5. \u03c6 = 1\u2212 \u03b3.\nThe solution is\n\u03b1 = \u03b3 = 0\n\u03b4 = 1\n\u03b2 = 0\n\u03c6 = 1\nThe extension we get is {\u03b4, \u03c6}.\n(g) Let us summarise in Table 1."}, {"heading": "4 The equational loop-busting semantics LB for complete loops", "text": "We now introduce our loop busting semantics, the LB semantics for complete loops. We need a series of concepts leading up to it.\nDEFINITION 4 (Loops). Let A = (S,R) be an argumentation network.\n1. A subset E = {x1, . . . , xn} \u2286 S is a loop cycle, (or a loop set, or a loop) if we have\nx1Rx2, x2Rx3, . . . , xn\u22121Rxn, xnRx1\n(S,R) is said to be a complete loop if every element of S is an element of some loop cycle.3\n2. A set B \u2286 S is a loop-buster if for every loop set E we have E \u2229 S 6= \u2205\n3. Let B \u2286 S be a loop-buster and let M be a meta-predicate describing properties of B. We can talk about the semantics LBM, where, (when we define it later), we use only loop-busters B such that M(B) holds. Criteria for adequacy for LBM are\n(a) It busts all odd numbered loops\n(b) It busts all even numbered loops and yields all allowable Dung extensions for such loops.\n4. Our first two proposals for conditions M on loop-busters is minimality. The idea is the smaller B is, the more options we have.\nTherefore, we define: A loop-buster set B is minimal absolute if there is no loop-buster set B\u2032 with a smaller number of elements (we do not require B\u2032 \u2286 B!).\n5. A loop-buster set B is minimal relative if there does not exist a B\u2032 & B which is a loop-buster set.\nEXAMPLE 5 (Loop-buster 1). Consider Figures 6 and 7.\n1. In Figure 6 there are two loop sets, {a, b, c} and {b, x, y}. The loop-buster {b} is minimal absolute and {y, c} is minimal relative. The loop set {y, b} is not minimal absolute.\n2. Consider Figure 7. There are two loops {a, b, c} and {a, b, c, x}. The minimal absolute loop-buster sets are {c}, {a}. {x, b} is not minimal relative.\nEXAMPLE 6 (Loop-buster 2). Consider Figure 8. The loops in this figure are many. For example, we list some\n3Comparing with the terminology of [1], a complete loop is a union of disjoint strongly connected sets.\n1. {a1, a2, a3, a4, a5, a6, a7, a8, a9}\n2. {a6, a2, a3, a4, a5}\n3. {a3, a8, a9, a1, a2}\n4. {a9, a5, a6, a7, a8}\nConsider the loop-buster {a2, a5, a8}\nThis is not a minimal absolute set but if we delete one of its elements we get a minimal absolute set. No one element is a loop-buster.\nDEFINITION 7 (The loop-busting semantics LBM for complete loops). Let A = (S,R) be an argumentation network. Assume that (S,R) is a complete loop, namely that each of its elements belongs to some loop cycle, as defined in item 1 of Definition 4. We define the LBM extensions for A as follows.\n1. Let B be a loop-buster for A satisfying M.\n2. Let Eqmax(A) be the system of equations generated by A. These have the form\n(eq(x)) : x = hx(y1, . . . , yk(x))\nwhere x \u2208 S, and y1, . . . , yk(x) are all the attackers of x. If x has no attackers then hx \u2261 1.\n3. For each x \u2208 B replace the equation eq(x) by the two new equations\n\u2022 (eq\u2217a(x)) : x = hx(y1, . . . , yk(x))Z(x) \u2022 (eq\u2217b(x)) : Z(x) = 0\nwhere Z(x) is a new variable syntactically depending on x alone.\n4. Solve the equations in (3) and let fB be any solution.\nThen the set Ef ,B = {x \u2208 S|fB(x) = 1}\nis an LBM extension.\n5. Thus the set of all LBM extensions for A = (S,R) is the set\n{Ef ,B|B is as in (1), fB is as in (4) and Ef ,B is as in (4)}\nNote that our definition of extension for a general network will be given in the next section.\nBefore we prove soundness of LBM relative to the traditional Dung semantics and compare LBM with CF2 semantics, let us do some examples. We use Figures 2 and 1(b).\nEXAMPLE 8. Consider Figure 2. The only loop here is {\u03b1, \u03b2, \u03c6}. There are three minimal absolute loop-busting sets, B\u03b1 = {\u03b1}, B\u03b2 = {\u03b2} and B\u03c6 = {\u03c6}.\nFor each one of these sets we need to modify the equations of Figure 2 and solve them and see what extensions we get. This has already been done in Example 2, parts (a), (b) and (c).\nIn (a) we made \u03c6 = 0, i.e. we used the loop-busting set B\u03c6. We solved the modified equations and got the extension {\u03b1, \u03b4} = E\u03c6. In (b) we made \u03b1 = 0, i.e. we used the set B\u03b1, solved the modified equations and got the extension E\u03b1 = {\u03b2, \u03b4}.\nIn (c) we made \u03b2 = 0, i.e. we used the set B\u03b1, solved the modified equations and got the extension E\u03b2 = {\u03c6, \u03b4}.\nLet us now compare with the CF2 extensions for the figure (Figure 2). The maximal conflict free sets of the first loop {\u03b1, \u03b2, \u03c6} are C\u03b1 = {\u03b1}, C\u03b2 = {\u03b2} and C\u03c6 = {\u03c6}. They are the same as our loop-busting sets, but they are used differently. They are supposed to be in (i.e. value 1) not out (value 0). We use C\u03b1, C\u03b2 , C\u03c6 to calculate the CF2 extensions and get {\u03b1, \u03b4}, {\u03b2, \u03b4} and {\u03c6, \u03b4}, indeed the same as the LB extensions.\nEXAMPLE 9. We now consider Figure 1(b). The only minimal absolute loopbuster set here is B\u03b3 = {\u03b3}. We have three more minimal relative sets, B1 = {\u03b2, \u03c6}, B2 = {\u03b4, \u03c6} and B3 = {\u03b1, \u03c6}.\nWe refer the reader to Example 3, where some equational calculations for this figure are carried out.\n1. In (a) of Example 3, we make \u03b3 = 0, we solve the modified equation and get the extension E\u03b3 = {\u03b1, \u03b2, \u03c6}.\nThis takes care of the case B\u03b3 = {\u03b3}.\n2. Let us address the case of B3 = {\u03b1, \u03c6}. We use (b) of Example 3, where we make \u03b1 = 0. We modify the equation for \u03b1 and get a solution \u03b1 = 0, \u03b4 = 1, \u03b2 = 0, \u03b3 = 1 and \u03c6 = 0.\nWe needed to also make \u03c6 = 0 for the loop-buster set {\u03b1, \u03c6}, but as it turns out, making \u03b1 = 0 also makes \u03c6 = 0. We thus get the extension E\u03b1,\u03c6 = {\u03b4, \u03b3}.\n3. Let us address the case of B1 = {\u03b2, \u03c6}. This corresponds to case (d) \u03b2 = 0 of Example 3. We modify the equations and solve them and get \u03b2 = 0, \u03b3 = 1, \u03c6 = 0, \u03b1 = 0 and \u03b4 = 1.\nThe extension is {\u03b3, \u03b4}.\nAgain, although we did not explicitly make the requirement \u03c6 = 0, the equations obtained from the requirement \u03b1 = 0 did the job for us.\n4. We now check the case of B2 = {\u03b4, \u03c6}. Here we get a discrepancy with case (c) of Example 3.\nThere, in case (c), we only require \u03b4 = 0, solve the equations and get the extension {\u03b1, \u03b2, \u03c6}. This is not what we want, as we also require \u03c6 = 0. So let us do the calculation in detail here.\nThe modified equation system for B1 = {\u03b4, \u03c6} is the following:\n1. \u03b1 = 1\u2212 \u03b3\n2\u2217a. \u03b4 = (1\u2212 \u03b1)Z(\u03b4)\n2\u2217b. Z(\u03b4) = 0.\n3. \u03b2 = 1\u2212 \u03b4\n5. \u03b3 = 1\u2212 \u03b2\n5\u2217a. \u03b3 = \u03c6 = (1\u2212 \u03b3)Z(\u03c6)\n5\u2217b. Z(\u03c6) = 0.\nWe solve the equations and get \u03c6 = 0, \u03b4 = 0, \u03b2 = 1, \u03b3 = 0, \u03b1 = 1.\nThe extension is {\u03b1, \u03b2}.\nEXAMPLE 10 (CF2 and the LB minimal absolute semantics). The LB minimal absolute semantics does not give all the CF2 extensions in the case of even loops. Consider Figure 5. The set B = {a10} yields the extension EB = {b, a1, a3, a5, a7, a0}. B is minimal absolute. Consider now B\n\u2032 being B\u2032 = {a10, a3, a6}.\nThis yields EB\u2032 = {a1, a4, a7, a9}\nHowever, B\u2032 is not minimal absolute. EB\u2032 is a CF2 extension. B \u2032 is a minimal relative set. What happens here is that the minimal absolute semantics gives the same extensions for even loops as the traditional Dung extensions, but the CF2 semantics gives more. This is a weakness of CF2.\nREMARK 11 (CF2 and the minimal relative extensions). Let us discuss the results of Example 9 calculated for Figure 1(b) and compare them with the CF2 extensions of Figure 1(b). This will give us an idea about the relation of CF2 to the minimal relative semantics. We use Example 3, where all the extensions were calculated and especially refer to Table 1, given in item (g) of Example 3, which summarises these calculations.\n1. The CF2 extensions are all the conflict free subsets. These are {\u03b4, \u03c6}, {\u03b4, \u03b3}, {\u03b1, \u03b2, \u03c6}.\nComparing with the semantics of Table 1, we get the following: the LB minimal absolute extensions are one only, namely {\u03b4, \u03b3}. The LB minimal relative extensions are {\u03b4, \u03b3}, {\u03b1, \u03b2, \u03c6} and {\u03b1, \u03b2}, {\u03b3, \u03c6}.\nWe see that LB minimal absolute gives less extensions (but breaks loops) while LB minimal relative gives one more extension. Obviously we need to identify a policy M which will yield exactly the CF2 extensions.\n2. Let us examine case (4) of Example 9 more closely. This is the case of B2 = {\u03b4, \u03c6} of Figure 1(b). The loop-buster set B2 was introduced to bust two loops. The loop {\u03b1, \u03b2, \u03b3, \u03b4} and the loop {\u03b3, \u03c6}. \u03b4 was included to bust the first loop and \u03b3 was included to bust the second loop. Our equational computations show in case (c) of Example 3 that if we start with \u03b4 = 0 we get that it follows that \u03b3 = 0. But \u03b3 belongs also to the second loop {\u03b3, \u03c6}. So {\u03b4} on its own is a loop-buster for both loops and we do not need to include \u03c6 in the loop-buster. So B1 = {\u03b4, \u03c6}\nis not minimal relative because B\u20322 = {\u03b4} can do the job. The above considerations show that the definition of minimal relative loop-busting sets needs to be adjusted. This needs to be done in a methodologically correct manner and will be addressed in the next section.\nNote that if we accept that B\u20322 = {\u03b4} is the minimal relative loop-busting set, then the calculated extension for this case is E\u03b4 = {\u03b4, \u03c6}, in complete agreement with the CF2 semantics!\nWe now need to demonstrate the soundness of the LB semantics. The perceptive reader will ask himself, how do the LB extensions relate to the extensions of traditional Dung semantics? After all, we start with the standard equational semantics, which for the case of Eqmax is identical with the Dung semantics, but then using a loop-busting set B of one kind or another, we get a new set of equations and call the solutions LB extensions. What are these solutions and what meaning can we give them?\nObviously, we need some sort of soundness result. This is the job of the next theorem.\nTHEOREM 12 (Representation theorem for LB semantics). Let A = (S,R) be an argumentation net being a complete loop as in Definition 7 and let B be a loop-busting subset of S (of some sort M). Let E(B,A) be the family of LB extensions obtained from A and B by following the procedures of Definition 7. Then E(B,A) can be obtained also following the procedure below\n1. For each x \u2208 B, let z(x) be a new point not in S. Let z(x) be all different for different xs.\n2. Define (SB, RB) as follows:\nSB = S \u222a {z(x)|x \u2208 B}\nRB = R \u222a {(z(x), x)|x \u2208 B}.\n3. The network (SB, RB) is an ordinary Dung network and has traditional Dung extensions. We have (for Eqmax):\nE(B,A) = {E \u2229 S|E is an extension of (SB , RB)}\nProof. The new equations for each x \u2208 B in (SB, RB) are\n(eq\u2217a(x)) : x = 1\u2212max(y1, . . . , yk(x), z(x))\n(eq\u2217a(z(x))) : z(x) = 1\nwhere y1, . . . , yk(x) are all the attackers of x in (S,R). Since z(x) = 1, we get that\n1\u2212max(y2, . . . , yk(x), z(x)) = (1\u2212max(y1, . . . , yk(x))(1\u2212 z(x))\n= (1\u2212max(y1, . . . , yk(x)))Z(x)\nprovided Z(x) = 1\u2212 z(x). Of course z(x) = 1 means Z(x) = 0. So we get the same modified equations as required by the LB semantics in Definition 7.\nEXAMPLE 13. Let us represent the cases of Example 9, which dealt with Figure 1(b). See Figures 9, 10, 11, 12 corresponding to cases (1)\u2013(4) of Example 9.\nWe are also adding Figure 13, describing the situation for B\u20322 = {\u03b4} as discussed in Remark 11 in item (b)."}, {"heading": "5 The equational semantics LB and its connection with CF2", "text": "We now define the family of LB semantics and identify the loop-busting counterpart of CF2. We need to develop some concepts first. We begin with a high school example.\nEXAMPLE 14 (High school example).\n1. Solve the following equations in the unknowns x, y, z.\n(a) x\u2212 y = 1\n(b) x+ y = 5\n(c) z2 \u2212 4yz + x+ 1 = 0\nThe point I want to make is that we solve the equations directionally. We first find the values of x and y from equations (a) and (b) to be x = 3 and y = 1 and then substitute in equation (c) and solve it. We get\n(c) z2 \u2212 4z + 4 = 0 z = 2\n2. Let us change the problem a bit. We have the equations\n(a) x\u2212 sin y = 2.99\n(b) x+ sin y = 3.01\n(c) z2 \u2212 400yz + x+ 1 = 0\nHere we may again consider equations (a) and (b) first but also use the approximation y \u2248 sin y. We find x = 3, y \u2248 0.01 and solve the third to get z = 2.\n3. A third possibility is to look at equations (a) and (b) and decide to ignore them altogether,4 and substitute x = y = 0. We get\n(c\u2217). z2 + 1 = 0\n4. Another example is the equation\nx4 \u2212 2x2 + x\n1000 + 1 = 0.\nTo solve this equation we decide on the perturbation which ignores x1000 on account of it being relatively small. We solve\nx4 \u2212 2x2 + 1 = 0\nwe get x = \u00b11.\nREMARK 15. We present a perturbation protocol for solving equations of the form\nx = hx(v1, . . .).\n1. Let V be a set of variables and E be a set of equations of the form x = hx(Vx), where Vx \u2286 V are the variables appearing in hx, and x ranges over V . We seek solutions to the system E with values hopefully in {0, 1}. If hx are all continuous functions in [0, 1], then we know that there are solutions with values in [0, 1], but are there solutions with values in {0, 1}?\nEven if we are looking for and happy with any kind of solution, we may wish to shorten the computation by starting with some good guesses, or\n4Of course, ignoring (a) and (b) needs to be justified.\nsome approximation or follow any kind of protocol P which will enable us to perturb the equations and get some results which we would find satisfactory from the point of view of our application area.\nIn the case of equations arising from argumentation networks, we would like perturbations which help us overcome odd-numbered loops.\nNote that in numerical analysis such equations are well known. If x1, . . . , xm are variables in [0, 1] and h1, . . . ,hm are continuous functions in [0, 1], we want to solve the equations\nxi = hi(x1, . . . , xm), i = 1, . . . ,m.\nOne well known method is that of successive approximations. We guess a starting value\nx1 = a 0 1, . . . , xm = a 0 m\nand continue by substituting\na j+1 i = hi(a j 1, . . . , a j m).\nUnder certain conditions on the functions hi (Lipschitz condition), the values aji ,= 1, 2, . . . converge to a limit a \u221e i , i = 1, 2, . . . ,m and that would be a solution. What we are going to do in this paper is in the same spirit.\n2. Let us proceed formally adopting a purely equational point of view and take a subset B1 \u2286 V of the variables and decide for our own reasons to substitute the value 0 for all the variables in B1 in the equations E.\nHow we chooseB1 is not said here, we assume that we have some protocols for finding such a B1. In the application area of argumentation, these protocols will be different loop-busting protocols LB(M).\nFor the moment, formally from the equational point of view, we have a set of equations E with variables V and a B1 \u2286 V , which we want to make 0. How do we proceed?\nThis has to be done carefully and so we replace for each u \u2208 B1, the equation\neq(u) : u = hu(Vu)\nby the pair of equations\neq\u2217(u) :\n\n\n\nu = hu(Vu)Z(u)\nZ(u) = 0\nWe now propagate these values through the new set of equations, solve what we can solve and end up with new equations of the form\neq1(x) : x = h1x(V 1 x )\nfor x \u2208 V , where h1x is the new equation for x and V 1 x are its variables. We have V 1x \u2286 V \u2212B1.\nThe variables ofB1 get all value 0 and maybe more variables solve to some numerical values. Note that we can allow also for the case of B1 = \u2205.\nWe always have a solution because the functions involved are all continuous.\nLet U1 = {x|V 1 x = \u2205}. U1 is the set of x which get a definite numerical value, for which Vx, the set of variables they depend on, is empty. We have B1 \u2286 U1 \u2286 V . Let f1 be a function collecting these values on U1, i.e. f(x) = h 1 x, for x \u2208 U1.\n3. We refer to U1 as the set of all elements instantiated to numerical values at step 1. We declare all variables of U1 as having rank 1.\n4. Let E1 be the system of equations for the variables in V \u2212 U1.\nWe now have a new system of variables and we can repeat the procedure by using a new set B2 chosen to make 0.\nWe can carry this procedure repeatedly until we get numerical values for all variables. Say that at step n we have that the union of all sets U1, U2, . . . , Un equals V . Then also each element of V has a clear rank k, the step at which x was instantiated. Call this procedure Protocol P = (B1, B2, . . .). Note that we did not say why and how we choose the sets B1, B2, . . .. In the case of equations arising from argumentation networks, these sets Bi will be loop-busting sets.\n5. Note that the equations initially give variables either 0 or 1 and our loop busters also give variables o, and Eqmax and Eqinverse are such that they keep the variables in {0, 1}, then all the functions f involved are {0, 1} functions\nEXAMPLE 16. We now explain why we use Z in our perturbation. Consider the equations\n1. a = 1\u2212 c\n2. b = 1\u2212 a\n3. c = 1\u2212 b.\nThese equations correspond to a 3-element argumentation loop. We take the B1 = {a} and want to execute a perturbation. If we do just substitute a = 0, we get a contradiction because the equations prove algebraically through manipulation that\na = b = c = 1\u2212 a = 1\u2212 b = 1\u2212 c\nSo we need to change the equation governing a. We write\n1\u2217a. a = (1 \u2212 c)Z(a)\n1\u2217b. Z(a) = 0\nAlgebraically we now have 4 equations in 4 variables\na, b, c, Z(a)\nThe solution is Z(a) = 0, a = 0, b = 1, c = 0.\nWe cannot any more execute an algebraic manipulation to get a = b = c!\nEXAMPLE 17. Let us recall Example 2, manipulating the equations arising from Figure 2. This is an illustration of our procedure. We used the loopbusting sets B\u03b1 = {\u03b1}, B\u03b2 = {\u03b2} and B\u03c6 = {\u03c6}, and followed the procedure as described in Remark 15.\nLet us now proceed with more concepts leading the way to the full definition of our loop-busting LB semantics.\nWe saw how to get a set of equations Eq(A) from any argumentation network A. Now we want to show how to get an argumentation network BE from any set of equations E.\nFurthermore, once we have a set of equations BE, we can perturb it to get a new set of equations EB using some perturbation set B and then from the equations EB get a new argumentation network AEB . The net result of all these steps is that we start with a network B = (S,R) and a perturbation set of nodes B \u2286 S and we end up with a new network which we can denote by A = BB. If B is a loop-busting set, then A is the loop-busted result of applying B to B.\nDEFINITION 18.\n1. Let V be a set of variables and let x = hx(V ), x \u2208 V, Vx \u2286 V be a system of equations E, where Vx is the set of variables actually appearing in hx. We now define the associated argumentation network AE = (SE, RE) as follows:\n(a) Let SE = V (b) Let yREx hold iff y \u2208 Vx. 5\n5The definition of yRx as y \u2208 Vx is a very special definition, making essential use of the fact that the equation\nx = hx(Vx)\nis of a very special form of either x = 1\u2212max Vx\nor x = \u220f\ny\u2208Vx\n(1 \u2212 y)\nThe real definition, which is more general, should be\nyRx iff when we substitute y = 1 in hx, we get that hx = 0.\nThis definition is good in a more general context. Suppose y1, y2 attack x jointly. This means that x = 0 only if both y1 = y2 = 1. See [9] for a discussion of joint attacks. The equation for that is\nx = 1\u2212 y1y2\n2. Let B = (S,R) be a network and let E = Eq(B) be its system of equations.\nE is a system of equations as in (a) above. Let B \u2286 V be some of the variables in V . Let f be a function giving numerical values 0 to the variables in B.\nLet Ef be the system of equations obtained from E by substituting the values f(u) in the equations for the variables of B. The variables of Ef are V \u2212B. Consider now the argumentation network\nAEf = (SEf , REf ).\nWe say thatAEf was derived from B using f. We can also use the notation Bf or BB.\nEXAMPLE 19. Let us use the network of Figure 14 to illustrate the process outlined in Remark 15. This figure is used extensively in [2] and also quoted in [3].\nThe variables of this figure are\nV = {a, b, c, d, e, f, g, h, i}\nThe equations are, using Eqinverse as follows:\n1. a = 1\u2212 c\n2. b = 1\u2212 a\n3. c = 1\u2212 b\n4. d = 1\u2212 b\n5. e = (1\u2212 b)(1\u2212 f)\nGiven a general equation x = hx(Vx) for example x = hx(y1, y2, z) = (1\u2212 z)(1\u2212 y1, y2) We define the notion for V 0x \u2286 Vx of joint attack as follows. V 0x attack x jointly if the substitution of u = 1 for all variables in V 0 x makes hx = 0 and for no proper subset of V 0x do we have this property. So in the above example, y1, y2 attack x jointly and z attacks x singly.\n6. f = (1\u2212 e)(1\u2212 d)(1 \u2212 i)\n7. g = (1\u2212 f)\n8. h = (1\u2212 g)\n9. i = (1\u2212 h)\nLet us take B = {a} and let f be the function making a = 0 (i.e. f(a) = 0). (This is a loop-busting move, breaking the loop {a, b, c}).\nThe new equations for a are\n1\u2217a. a = (1 \u2212 c)Z(a)\n1\u2217b. Z(a) = 0\nor we can simply write\n1\u2217. a = 0\nSubstituting this value in the equations and solving we get the new system of equations for the unknown variable as follows\n1. b = 1, known value\n2. c = 0, known value\n3. d = 0, known value\n4. f = 1\u2212 i\n5. g = 1\u2212 f\n6. h = 1\u2212 g\n7. i = 1\u2212 h\nWe get the solution function f1 giving the known values to the variables a = 0, b = 1, c = 0, d = 0, e = 0 (these are the variables of rank 2) and the new system of equations (6), (7), (8), (9). Using item (1) of Definition 18, we get the derived network in Figure 15.\nWe can continue now with this loop and choose a loop-busting variable say B\u2032 = {i}. We substitute i = 0 in the equations and get f = 1, g = 0, h = 1, i =\n0 (these are the variables of rank 1). We extend the function f1 to be f2 giving these values.\nWe thus get the extension {b, f, h} (these are the variables which get value 1 from f2). We also get clear ranks for the variables for the particular protocol P = (B,B\u2032) = ({a}, {i}).\nEXAMPLE 20. Let us do another example. We use Figure 1 item b. We note that in Example 3, item (e), we make \u03c6 = 0. This means we start with B1 = {\u03c6}.\nWe manipulated the equations in item (e) of Example 3 and got the remaining equation (1)\u2013(4), namely\n1. \u03b1 = 1\u2212 \u03b3\n2. \u03b4 = 1\u2212 \u03b1\n3. \u03b2 = 1\u2212 \u03b4\n4. \u03b3 = 1\u2212 \u03b2\nWe proceeded in item (e) of Example 3 to find two solutions to these equations. However, if we follow the procedures of Remark 15, we need now to extract a new network out of equations (1)\u2013(4), and keep in mind the partial function f1(\u03c6) = 0. The new network is presented in Figure 16.\nWe can now proceed by choosing a new loop-busting set B2. We have four options here. Choosing B2 to be \u03b1 or \u03b2 will make the extension \u03b1 = \u03b2 = 0, \u03b4 = \u03b3 = 1 and choosing B2 to the \u03b3 or \u03b4 will give the extension \u03b1 = \u03b2 = 1, \u03b3 = \u03b4 = 0.\nThese are also the solutions we got in item (e) of Definition 3.\nWe now want to define procedures which will give us the CF2 extensions of Baroni et al.. We need to give a protocol of which B to use, as outlined in Definition 18.\nDEFINITION 21.\n1. Let A = (S,R) be an argumentation network. Define x \u2248 y iff x = y or for some loop u1Ru2, u2Ru3, . . . , unRu1 we have x, y \u2208 {u1, . . . , un}. This is an equivalence relation on S. Let S\u2217 be a set of equivalence\nclasses.6 Define R\u2217 on S\u2217 by x\u2217R\u2217y\u2217 iff for some x\u2032 \u2248 x, y\u2032 \u2248 y we have x\u2032Ry\u2032.\n(S\u2217, R\u2217) is an ordering without loops.\n2. Let Sx \u2286 S be an \u2248 equivalence class of x \u2208 S. We say that Sx is top-class if the following holds\n\u2022 yRz \u2227 z \u2248 x \u2192 y \u2248 x.\nThe above means that no other disjoint class Sy attacks any member of Sx.\nLet C \u2286 Sx be a maximal subset of conflict free points in Sx. Let B = Sx \u2212 C. Then using B in the protocol of Remark 15 shall be referred to as using the CF2 protocol.\nLEMMA 22. In the notation of Definition 21, if we apply the protocol of Remark 15, we get that all elements of B solve to 0 and all elements of C solve to 1.\nProof. Let x be an element of C. The equation for x is\nx = hx(Vx)\nwhere Vx = {y|y attacks x}. hx can be the expression 1\u2212max{y|y \u2208 Vx} according to Eqmax or \u220f\ny\u2208Vx (1\u2212\ny) for resp. Eqinverse or any other choice as long as the following condition holds.\n\u2022 If for all y \u2208 Vx, y = 0 then hx(Vx) = 1.\nThe important point to note is that since Sx is a top loop, all attackers of x are in Sx, and since x \u2208 C and C is a maximal conflict free set, all attackers of x are not in C, so they are in B and so they are 0. Hence x = 1.7\nThe above consideration shows that B can represent C, and so Baroni et al. conflict free choice C can be represented as our equational loop-busting set B. We now continue our protocol with B and get a new network AB (note we are using the notation of Definition 21 and our original network was A = (S,R).)\nREMARK 23. Let A = (S,R) be a network and suppose it does contain points that are not attacked. If we choose B = \u2205 and apply our procedure of Remark 15, what do we get?\nThe procedure solves the equations as much as possible to get a new network A1 and a function f1 giving numerical values nodes which are in or out in the grounded extension. In other words, they have a {0, 1} numerical value. Thus what we get is the rest of the network after the grounded extension has been eliminated.\n6These are the maximal strongly connected sets in the terminology of [1]. 7Obviously our proof does not work unless C is maximal conflict free set. So the LB semantics can yield the CF2 semantics only because Baroni et al. chose to take maximal conflict free set. I shall ask Baroni for his reasons for this choice.\nEXAMPLE 24. Consider the network of Figure 17. Begin the procedure with B1 = \u2205. We get f1(a) = 1, f1(b) = 0 and the remaining network A1 of Figure 18.\nWe can now continue with the loop-busting set B1 = {d}, follow the procedure for A1 and get d = 0, c = 1. Thus the solution with the loop buster sets B1 = \u2205, B2 = {d} yields the function f2(a) = 1, f2(b) = 0, f2(d) = 0, f2(c) = 1.\nThe corresponding extension is {a, c}.\nREMARK 25.\n1. We are now in a position to define our LBM extensions. We see from the discussions so far that we can use the following procedure to find {0, 1} functions f on an argumentation network A0 = (S0, R0).\nStep 1. Define A\u22170 = (S \u2217 0 , R \u2217 0) as in Definition 21. Choose a loop-busting subset B1 for the top loops of A \u2217 0, following some meta-level considerations, i.e. satisfying M.\nStep 2. Apply the procedure of Remark 15, using B1 and A0 and get f1 and A1.\nRecall that following the terminology of Remark 15 item 3, all elements in S0 \u2212S1 have rank 1. These are the elements instantiated to numerical values at Step 1. Furthermore f1 is a {0, 1} function. Also note that A1 = (S1, R0 \u2229 S1).\nStep 3. Choose a new loop-busting set B2 for the top loops of A1 using our metalevel considerations M.\nStep 4. Go to apply step 2 to A1 using B2 and obtain f2 and A2.\nAlso identify the elements of S2 \u2212 S1 as the elements of rank 2."}, {"heading": "Step n+ 2.", "text": "Continue until you get An+3 = \u2205.\nThe function fn+2 will be total on S0 and will give you the extension\nE(B1, B2, . . . , Bn+2) = {x|fn+2(x) = 1}.\nAll elements in the network have a clearly defined rank, it being the step in which they were instantiated to numerical value in {0, 1}.\n2. We define the semantics LBM as the family of all the extensions of the form E(B1, . . . , Bn+2), for all possible choices of Bi allowable by M.\nWe now want to proceed to define our loop-busting semantics LB1, LB2, LB3, and LB4. We want to use the notions of minimal absolute and minimal relative. We already remarked in item (2) of Remark 11 that the above notions need to be adjusted. We now have the tools to do so.\nDEFINITION 26 (Computational loop-busting set).\n1. Let (S,R) be a complete loop, as defined in Definition 4. Let B1 be a subset of S. We say that B1 is a computational loop-buster if, when we follow the procedure outlined in Remark 15, and get the function f1 as described there, we have that\nB\u20321 = {x|f1(x) = 0}\nis a loop-busting set (according to Definition 4), namely B\u20321 intersects every loop cycle in S.\nNote that what this definition says is very simple. There is no need for B1 itself to intersect every loop C. Making all points in B1 equal 0 in the equations would make more points 0, namely we get B\u20321 and B \u2032 1 does intersect every loop. If this is the case, we say that B1 is a computational loop-buster.\n2. A computational loop-buster is minimal absolute if there is no smaller computational loop buster with a smaller number of elements.\nB1 is a minimal relative computational loop-buster, if no proper subset of it is such.\nDEFINITION 27. We define the following loop-busting semantics."}, {"heading": "1. LB1", "text": "We are allowed to choose only loop-busting sets which contain elements from top loops (as defined in Definition 21, item (1)), and which are computationally minimal absolute (as defined in Definition 26).\nSo in other words, if our network is (S,R) and Sx, Sy, . . . are all the top loops then our set B is a subset of Sx \u222aSy \u222a . . . and it is a computational minimal absolute set for any loop in any top loop.\n2. LB2 (to be proved equivalent to the CF2 semantics) We are allowed to choose only loop-busting sets obtained from maximal conflict free subsets of top loops, as defined in Definition 21, item (2)."}, {"heading": "3. LB3", "text": "We are allowed to choose only loop-busting sets containing elements from top loops (as defined in Definition 21, item (1)), and which are computational minimal relative (as defined in Definition 26).\n4. LB4 (Directional Shkop semantics of [3]) We are allowed to choose loop-busting sets containing elements from top loops (as defined in Definition 21, item (1)) and which are a single loop element.\nSo this semantics busts top loops one at a time.\nNote that the LB4 semantics gives rise to the same extensions as LB3. The reason is that if we start with a computationally minimal relative set B, we can substitute its elements one by one following the protocol of LB4 semantics and we never bust all loops until we substitute the last element , because the set is minimal relative. But now we are doing an equivalent LB4 semantics!\nWe now show that our LB2 semantics is the same as CF2. The following is a definition of CF2 extensions, as given in [2, Definition 4].\nThe notion of strongly connected set used was defined in Definition 21.\nDEFINITION 28. Let A = (S,R) be an argumentation network and let E \u2286 S be a set of arguments, then E is a CF2 extension of A iff\n1. If (S,R) itself is a strongly connected set then E is a maximal conflict free subset of S.\n2. Otherwise, for every C where C is a maximal strongly connected subset of S, we have that the set C\u2229E is a CF2 extension of the network (TC1 , R1), where\nTC1 = C \u2212 {x|\u2203y \u2208 E((y, x) \u2208 R \u2227 y 6\u2208 C}\nR1 = R \u2229 (T C 1 \u00d7 T C 1 ).\nTHEOREM 29 (LB2 = CF2). The semantics CF2 is the same as the semantics LB2."}, {"heading": "Proof.", "text": "1. We start by showing that every LB2 extension E of a network A0 = (S0, R0) is also a CF2 extension as defined in Definition 28. To achieve this goal we need to follow closely how the extension E was defined in LB2 for A0.\nThe LB2 semantics was defined in Definition 27 by using the protocols of Remark 25. The loop-busting sets involved in these protocols were defined in item 2 of Definition 21.\nLet us list the way the LB2 extension E of A0 is defined.\n(a) E is defined according to item 2 of Remark 25. The extension is obtained in the form E = E(B1, . . . , Bn+2), where each Bi+1 is a loop-buster on the top loops of the network Ai = (Si, Ri).\n(b) The loop buster was chosen according to the protocol (CF2 protocol) of item 2 of Definition 21.\n(c) The elements of Si \u2212Si+1 are of rank i, where i is the step in which they got a numerical value in {0, 1} by the function fi.\nThe function fn+1 gives numerical values in {0, 1} to all the elements of S0 and we have\nE = {x \u2208 S0|fn+1(x) = 1}.\nWe are now going to use the rank i to show that E is a CF2 extension according to Definition 28. We need a bit more preparation.\n(d) LetA\u22170 = (S \u2217 0 , R \u2217 0) be the ordering without loop derived from (S0, R0)\nas in Definition 21. The element classes of S\u22170 are all the maximal strongly connected subsets of S0\nWe continue the proof by induction on n+ 2, being the number of steps required to define E.\n(e) Case n+ 2 = 2(n = 0).\nIn this case we have that (S0, R0) itself is a strongly connected set. Then E is obtained from B1 which satisfies the CF2 condition as in Step 1 of Remark 25. Using the notation of Step 1, we have E = {x|f1(x) = 1}. In this case E is also a CF2 extension.\n(f) Case n > 0 Take any strongly connected maximal subset C of (S0, R0). Let k+1 be the step at which all elements of C get a numerical value. There are two possibilities:\ni. At step k some maximal subset C\u2032 \u2286 C does not yet have numerical values. C\u2032 is a top loop in Ak. In this case Bk is a loop buster for C\u2032 and makes it get a numerical value in Ak+1.\nii. C is not a top loop in Ak, in which case Bk busts some other loops and in the process of obtaining Ak+1, C\n\u2032 disappears as all these elements get a numerical value. In fact, in this case it is Step k which gives all elements of C a numerical value.\nLet us now look at the set TC1 , as defined in item 2 of Definition 28.\nTC1 = C \u2212 {\u2203y \u2208 (E \u2212 C)((y, x) \u2208 R)}\nThe set TC1 is comprised from two parts, T C 1,k and T C 1,k+1. Part T C 1,k are all points z \u2208 TC1 that get numerical value at step k by fk and the set TC1,k+1 is the set of all points that get numerical values at step k + 1 by the function fk+1.\nIn case (i) above, TC1,k+1 is still the loop C \u2032, but still TC1,k may be 6= \u2205. In case (ii), TC1,k+1 = \u2205. We ask is E \u2229 T C 1 a CF2 extension of T C 1 according to Definition 28? The answer is yes. The part TC1,k is calculated traditionally and if there is a loop C\u2032 = TC1,k+1, it will be busted by Bk which was chosen in LB2 to yield a maximal conflict free set.\nWe thus see through considerations (a)\u2013(e) that LB2 \u2286 CF2.\nThe reader should see Remark 30, to appreciate the difference between the way LB2 and CF2 calculate their extensions.\n2. We now prove the other direction, namely that every CF2 extension is also an LB2 extension.\nLet E0 be a CF2 extension of the network A0 = (S0, R0). We would like to define a sequence of LB2 loop-busters B1, B2, . . . , Bn+2 such that E0 = E(B1, . . . , Bn+2). We choose Bi by looking at E0.\nStep 1. Look at the top loops of (S0, R0). Use E0 to choose the loop-busters.\nLet us look at top strongly connected sets of (S0, R0). These are either single unattacked points x for which the LB2 equation is x = 1 (in agreement with CF2) or a loop C, for which CF2 gives a choice of maximal conflict-free subset E0 \u2229 C. We can now choose our LB loop-buster B1 to be\nB1 = \u22c3\ntop loops C of A0\n(C \u2212 E0.\nWe now apply step 1 of the LB2 procedure and get A1 = (S1, R1). Again consider the top loops of A1. Let\nB1 = \u22c3\ntop loops C of A1\n(C \u2212 E0)\nWe carry on in this manner and get\nE(B1, B2, . . .).\nTo show that E0 = E is not difficult. This is done along the lines of the proof of (1) above.\nREMARK 30. The way we compute the extensions of LB2 are not synchronised with the way CF2 itself works. This can be seen from the network of Figure 14. In this figure the top loop is {a, b, c}. By choosing the maximal conflict free set {c}, we are led to the loop-buster B = {b}.\nIn step 1 we propagate the attacks (solve the equations) to get numerical values for as many variables as we can.\nWe get in LB2\na = 0, c = 1, b = 0, d = 1, e = 1, f = 0, g = 1, h = 0 and i = 1.\nWe get the extension in one step\nE = {c, d, e, g, i} = E({b}).\nIn comparison, when we follow the CF2 procedures, we look at two loops, the strongly connected sets, {a, b, c} and {e, f, g, h, i}.\nStep 1 of the LB2 procedure corresponds to what the CF2 definition does, namely treat the loop {a, b, c}. This we do by choosing c = 1 and calculating a = 0, b = 0 and d = 1.\nWe now look at the loop {e, f, g, h, i} and take from it the elements attacked from outside it. In this case we take the element f attacked by d. Thus we are left with S1 = {e, g, h, i} and R1 being {(g, h), (h, i)}. The CF2 extension for (S1, R1) is {e, g, i}. So the extension we get finally is E = {c, d, e, g, i}.\nThe intuition of LB2 is to solve equations and get numerical values as much as possible. In the process we bust loops, by making loop variables equal 0. Because we are dealing with equations, we can make loop variables equal 0 one by one.\nCF2 in comparison, is different.\n1. It concentrates more on loops\n2. It treats loops by choosing maximal conflict free sets and makes them 1.\n3. Since it is not dealing with equations, it must make 1 batches of variables (maximal conflict free sets) and cannot do them one by one. So LB2 has the same problem. It must make 0 batches of variables all in one go.\nSee [2] for an algorithm for CF2. I think they do it inductively as we did in this example.\nREMARK 31 (Computational complexity). The computational complexity of the LB semantics is daunting. This is because of the requirement that the loop-busting sets in LB1 and LB3 be computationally minimal. This means that we have to solve many equations before we can choose our sets. So I don\u2019t regard LB1 and LB3 as practical. In comparison, LB4 is easy, we just choose a loop element based on the geometry of the network and proceed recursively. This is simple and easy.\nTwo factors are in our favour. One mathematical and one social. The mathematical one is that since we are dealing with equation solving, there are tools available for our use such as Mathematica or Matlab or Maple or NSolve which can help.\nWe note that there is actually no need to go to equations at all, in view of the soundness results in the representation Theorem 12.\nWe can work completely with argumentation networks. On the social side, our argumentation community is blessed with many talented young researchers such as Sarah Gaggl and Stefan Woltran (see [2]) and\nWolfgang Dvorak, who write good algorithms, and who (should they take an interest in the LB semantics) would certainly find a way around complexity difficulties.\nPerhaps the comparison in Remark 30 shows the way of how the algorithms of [2] can be adapted to the LB semantics.\nREMARK 32 (Comparison of LB1 semantics with the CF2 semantics). Let us make a quick comparison.\n1. LB1 give the correct exact extension for even loops. CF2 gives more extensions.\n2. LB1 does bust odd loops but gives less extensions than CF2.\n3. LB1 remains conceptually within the attack concept framework. It has the backing of hundreds of years of experience in approximate/guess/simplification of equations. CF2 uses the slightly out of sync concept of maximal conflict free sets, and although LB2 gives it an equational flavour, it is forced and not natural (see next item 4).\n4. Most importantly, and this has been pointed out to me by Martin Caminada, CF2 is not robust against conceptual extensions, such as joint attacks. This is shown in the next remark, 33.\nWe shall also see that the LB semantics is robust.\nREMARK 33 (CF2 and joint attacks).\n1. In my paper [9] of Fibring argumentation frames, I introduced the notion of joint attack of say two arguments a and b on a third argument c. This means that c is in only when both a and b are out. I used the notation of Figure 19.\nThe equation for c is c = 1\u2212 ab.\nI also showed in the paper how to interpret joint attacks within ordinary argumentation networks, using for each node e the new auxiliary points x(e) and y(e). The joint attack of Figure 19 can be represented faithfully by Figure 20.\nIt is important to note that if we calculate the equations of Figure 20 we get for Eqinverse\nx(a) = 1\u2212 a\nx(b) = 1\u2212 b\ny(c) = ab\nc = 1\u2212 ab\nIf we use Eqmax we get\nx(a) = 1\u2212 a\nx(b) = 1\u2212 b\ny(c) = 1\u2212max(1\u2212 a, 1\u2212 b)\nc = max(1\u2212 a, 1\u2212 b) = 1\u2212min(a, b)\nIt is clear that in either case the equation for c does not depend on the auxiliary points. Therefore any equational computation to get extensions will not be affected by the auxiliary points.\n2. Let us now take a loop involving joint attacks. Suppose we have 3 items, a, b and c and enough money to buy only two. Thus buying any two items attacks jointly the buying the third item. We get the loop of Figure 21.\nThe representation of this figure using the auxiliary point into an ordinary argumentation network is presented in Figure 22.\nIn this figure, the set {a, b, c} is conflict free in the expanded network with the auxiliary points but it is not so in the original network, contrary to intuition. So CF2 messes up the concept of joint attack.\nIn comparison, the LB semantics is not affected by the auxiliary points as we have already seen from the equations. Not being affected means that if we start with a network (S,R) and move for whatever reason to an expanded network (S\u2032, R\u2032), containing additional auxiliary points , then any extension E\u2032 obtained traditionally for (S\u2032, R\u2032) will endow a correct and acceptable extension E = E\u2032 \u2229 S of (S,R), and furthermore all such correct extensions E are so obtained.\nLet us find a loop-buster for Figure 22. Note that this system is similar to Figure 8, being a 9-point loop.\nA computational loop-buster would be, for example, {y(a), y(b)}.\nThis gives a = b = 1 and c = 0. {y(a), y(b), y(c)} is not minimal so we cannot get the extension {a, b, c}.\nIt is clear that our LB machinery works correctly here."}, {"heading": "6 Discussion and conclusion", "text": "Let us summarise the progression of logical and conceptual steps involved in this paper:\n1. We saw that the equational approach allows us to associate in a one to one manner a system of equations with each argumentation network.\n2. Finding a solution to the equations corresponds to finding an extension for the argumentation network.\n3. When a system of equation is difficult to handle, there is a well known and much used methodology in the equational area of perturbing the equations to make it them more manageable, in a way compatible with one\u2019s application area.\n4. In the argumentation area odd and even loops are a bit of a problem\n5. The counterpart of loops in the equational area are cycles of variable dependencies, a well understood phenomena, traditionally handled by iterative solutions.\n6. We therefore suggest, inspired by equational thinking, the concept of loop-busting sets of variables which we perturb to be 0, and use them to modify the equations.\n7. This gives rise to the LB semantics for argumentation, which contains the CF2 semantics as a special option, which we called LB2 (= CF2).\nNote that LB2 is based on making arguments 0 , while CF2 is based on making arguments 1. So the agreement is non-trivial.\n8. We considered other options such as LB1, LB3 and LB4. We showed that they agree with traditional semantics on even loops and still repair odd loops.\n9. We compared the other LB semantics with CF2 and found them robust as far as conceptual changes such as joint attacks.\n10. The LB1, LB3 and LB4 semantics can be done by loop busting using repeatedly and recursively one element at a time. The LB2 semantics (which simulates CF2 and uses maximal conflict free sets) requires the use of all points of the loop busting set to be made 0 simulataneously.\nWe now say a few comments, comparing this paper with [3]. The Shkop semantics introduced in [3], corresponds to LB4. In [3] argumentation loops are considered as created over time, where the arguments come as a result of agents creating situations by their temporal actions. This means that when an odd loop is created, we can identify one of the members of the loop as the temporally last argument which came into existence by some action and created the loop. The Shkop principle says that in this case, this argument is rejected (in the real world the action giving rise to it is annulled). This is mathematically equivalent to using this last argument as a loop buster and making it equal 0.\nSo the Shkop principle and the Shkop semantics of [3] corresponds to LB4 semantics where the loop-busters are chosen using temporal information."}, {"heading": "Acknowledgements", "text": "I am grateful to Martin Caminada, Sarah Gaggl, and Stefan Woltran for helpful discussion.\nResearch done under ISF project: Integrating Logic and Network Reasoning."}], "references": [{"title": "SCC-Recursiveness: A General Schema for Argumentation Semantics", "author": ["P. Baroni", "M. Giacomin", "G. Guida"], "venue": "Artif. Intell., 168(1-2):162210", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "cf2 Semantics Revisited", "author": ["S.A. Gaggl", "S. Woltran"], "venue": "Computational Models of Argument: Proceedings of COMMA 2010, Desenzano del Garda, Italy, September 8-10, 2010, P. Baroni, F. Cerutti, M. Giacomin and G. Simari, eds., pp. 243\u2013254. Volume 216 of Frontiers in Artificial Intelligence and Applications, IOS Press", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2010}, {"title": "The handling of loops in Talmudic Logic, with application to odd and even loops in argumentation, Expanded Version", "author": ["M. Abraham", "D. Gabbay", "U. Schild"], "venue": "An earlier version appeared in Proceedings of Howard", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "An Equational Approach to Argumentation Networks, Feb 2011, 104 pp, to appear in Argumentation and Computation", "author": ["D. Gabbay"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2011}, {"title": "Logics for defeasible argumentation", "author": ["H. Prakken", "G.A.W. Vreeswijk"], "venue": "D. M. Gabbay, F. Guenthner (Eds.), Handbook of Philosophical Logic, Second Edition, Kluwer Academic Publishers, Dordrecht", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "Solving semantic problems with odd-length cycles in argumentation", "author": ["P. Baroni", "M. Giacomin"], "venue": "Proceedings of the 7th European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "The cf2 Argumentation Semantics Revisited", "author": ["Sarah Alice Gaggl", "Stefan Woltran"], "venue": "To appear in Journal of Logic and Computation,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "Fibring Argumentation Frames", "author": ["D. Gabbay"], "venue": "Studia Logica,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "1 Background and orientation Our starting point is the important papers of Baroni, Giacomin and Guida on odd loops and SCC recursiveness [1, 6].", "startOffset": 137, "endOffset": 143}, {"referenceID": 5, "context": "1 Background and orientation Our starting point is the important papers of Baroni, Giacomin and Guida on odd loops and SCC recursiveness [1, 6].", "startOffset": 137, "endOffset": 143}, {"referenceID": 0, "context": "Section 2 reproduces the motivating discussion from [1] for the CF2 semantics and points out its weaknesses.", "startOffset": 52, "endOffset": 55}, {"referenceID": 0, "context": "2 CF2 semantics as introduced in the SCC paper [1] Baroni et al.", "startOffset": 47, "endOffset": 50}, {"referenceID": 0, "context": "We now reproduce Figure 8 of [1], and discuss the problems associated with it.", "startOffset": 29, "endOffset": 32}, {"referenceID": 0, "context": "Figure 8 of [1].", "startOffset": 12, "endOffset": 15}, {"referenceID": 0, "context": "[1], here reproduced as Figure 2.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "Figure 9 of [1]: Floating defeat and floating acceptance", "startOffset": 12, "endOffset": 15}, {"referenceID": 4, "context": "In [5], this is characterised as \u201cone of the main unsolved problems in argumentation-based semantics\u201d.", "startOffset": 3, "endOffset": 6}, {"referenceID": 0, "context": "The CF2 semantics of [1] treats the loops of Figures 1(a) and 1(b) and 2 all in the same way, by taking as CF2 extensions maximal conflict-free sets.", "startOffset": 21, "endOffset": 24}, {"referenceID": 0, "context": "We agree with [1] on the need for a new approach but we feel that the CF2 semantics offered as a solution requires further independent methodological justification.", "startOffset": 14, "endOffset": 17}, {"referenceID": 2, "context": "We would perceive that the judge is not doing his job properly and that he is just offering us options which are obvious and non-controversial, given the geometry of the loop! See [3] for extensive examples of resolving loops in a practical realistic way.", "startOffset": 180, "endOffset": 183}, {"referenceID": 0, "context": "If we look at Figures 1(a) and 1(b) and replace them by Figure 4 and 5 our loop-breaking needs are the same according to [1], but in Figure 4, we do not need the extensions {a3, a6, a9, b} from the loop-breaking point of view.", "startOffset": 121, "endOffset": 124}, {"referenceID": 3, "context": "The next sections will discuss the equational approach of [4], and introduce the new LB semantics.", "startOffset": 58, "endOffset": 61}, {"referenceID": 0, "context": "The equational approach views (S,R) as a bearer of equations with the elements of S as the variables ranging over [0, 1] and with R as the generator of equations.", "startOffset": 114, "endOffset": 120}, {"referenceID": 3, "context": "In [4] there are more Eq options.", "startOffset": 3, "endOffset": 6}, {"referenceID": 3, "context": "In [4] we prove the following: THEOREM 1.", "startOffset": 3, "endOffset": 6}, {"referenceID": 0, "context": "There is always at least one solution in [0, 1] to any system of continuous equations Eq(A).", "startOffset": 41, "endOffset": 47}, {"referenceID": 0, "context": "The actual value in [0, 1] reflects the degree of odd looping involving x.", "startOffset": 20, "endOffset": 26}, {"referenceID": 0, "context": "For example, we list some Comparing with the terminology of [1], a complete loop is a union of disjoint strongly connected sets.", "startOffset": 60, "endOffset": 63}, {"referenceID": 0, "context": "If hx are all continuous functions in [0, 1], then we know that there are solutions with values in [0, 1], but are there solutions with values in {0, 1}? Even if we are looking for and happy with any kind of solution, we may wish to shorten the computation by starting with some good guesses, or Of course, ignoring (a) and (b) needs to be justified.", "startOffset": 38, "endOffset": 44}, {"referenceID": 0, "context": "If hx are all continuous functions in [0, 1], then we know that there are solutions with values in [0, 1], but are there solutions with values in {0, 1}? Even if we are looking for and happy with any kind of solution, we may wish to shorten the computation by starting with some good guesses, or Of course, ignoring (a) and (b) needs to be justified.", "startOffset": 99, "endOffset": 105}, {"referenceID": 0, "context": ", xm are variables in [0, 1] and h1, .", "startOffset": 22, "endOffset": 28}, {"referenceID": 0, "context": ",hm are continuous functions in [0, 1], we want to solve the equations", "startOffset": 32, "endOffset": 38}, {"referenceID": 7, "context": "See [9] for a discussion of joint attacks.", "startOffset": 4, "endOffset": 7}, {"referenceID": 1, "context": "This figure is used extensively in [2] and also quoted in [3].", "startOffset": 35, "endOffset": 38}, {"referenceID": 2, "context": "This figure is used extensively in [2] and also quoted in [3].", "startOffset": 58, "endOffset": 61}, {"referenceID": 0, "context": "These are the maximal strongly connected sets in the terminology of [1].", "startOffset": 68, "endOffset": 71}, {"referenceID": 2, "context": "LB4 (Directional Shkop semantics of [3]) We are allowed to choose loop-busting sets containing elements from top loops (as defined in Definition 21, item (1)) and which are a single loop element.", "startOffset": 36, "endOffset": 39}, {"referenceID": 1, "context": "See [2] for an algorithm for CF2.", "startOffset": 4, "endOffset": 7}, {"referenceID": 1, "context": "On the social side, our argumentation community is blessed with many talented young researchers such as Sarah Gaggl and Stefan Woltran (see [2]) and", "startOffset": 140, "endOffset": 143}, {"referenceID": 1, "context": "Perhaps the comparison in Remark 30 shows the way of how the algorithms of [2] can be adapted to the LB semantics.", "startOffset": 75, "endOffset": 78}, {"referenceID": 7, "context": "In my paper [9] of Fibring argumentation frames, I introduced the notion of joint attack of say two arguments a and b on a third argument c.", "startOffset": 12, "endOffset": 15}, {"referenceID": 2, "context": "We now say a few comments, comparing this paper with [3].", "startOffset": 53, "endOffset": 56}, {"referenceID": 2, "context": "The Shkop semantics introduced in [3], corresponds to LB4.", "startOffset": 34, "endOffset": 37}, {"referenceID": 2, "context": "In [3] argumentation loops are considered as created over time, where the arguments come as a result of agents creating situations by their temporal actions.", "startOffset": 3, "endOffset": 6}, {"referenceID": 2, "context": "So the Shkop principle and the Shkop semantics of [3] corresponds to LB4 semantics where the loop-busters are chosen using temporal information.", "startOffset": 50, "endOffset": 53}], "year": 2012, "abstractText": "We introduce a family of new equational semantics for argumentation networks which can handle odd and even loops in a uniform manner. We offer one version of equational semantics which is equivalent to CF2 semantics, and a better version which gives the same results as traditional Dung semantics for even loops but can still handle odd loops. 1 Background and orientation Our starting point is the important papers of Baroni, Giacomin and Guida on odd loops and SCC recursiveness [1, 6]. In their papers the authors offer the CF2 semantics in response to difficulties arising from the Dung semantics handling of odd and even loops. In our paper we outline our equational approach to argumentation networks and show how the CF2 semantics can be obtained from perturbations to the equations associated with the networks. This approach will offer additional methodological support for the CF2 semantics, while at the same time show the power of the equational approach. We offer our own loop-busting equational semantics LB, which includes CF2 as a special case. The structure of this paper is as follows. Section 2 reproduces the motivating discussion from [1] for the CF2 semantics and points out its weaknesses. Section 3 introduces the equational semantics. Section 4 defines our loop busting semantics LB. Section 5 introduces our semantics LB2 and compares with CF2 on the technical level. We conclude with a general discussion in Section 6. 2 CF2 semantics as introduced in the SCC paper [1] Baroni et al. devote a long discussion about the inadequacy of the traditional semantics in handling odd and even loops. They say, and I quote: \u201cthe length of the leftmost cycle should not affect the justification states [of an argument]. More generally, it is counter-intuitive that different results in conceptually similar situations depend on the length of the cycle. Symmetry reasons suggest that all cycles should be treated equally and should yield the same results.\u201d 2Dov M. GabbayBar Ilan University, Israel;King\u2019s College London, UK;University of Luxembourg, LuxembourgPaper 459h: DovP We now reproduce Figure 8 of [1], and discuss the problems associated with it.", "creator": "LaTeX with hyperref package"}}}