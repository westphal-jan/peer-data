{"id": "1204.3529", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Apr-2012", "title": "Hardness Results for Approximate Pure Horn CNF Formulae Minimization", "abstract": "For a pure Horn Boolean function on $n$ variables, we show that unless P=NP, it is not possible to approximate in polynomial time (in $n$) the minimum numbers of clauses and literals to within factors of $2^{O(\\log^{1-o(1)} n)}$ even when the inputs are restricted to 3-CNFs with $O(n^{1+\\varepsilon})$ clauses, for some small $\\varepsilon&gt;0$. Furthermore, we show that unless the Exponential Time Hypothesis is false, it is not possible to obtain constant factor approximations for these problems even having sub-exponential time (in $n$) available.", "histories": [["v1", "Mon, 16 Apr 2012 15:41:43 GMT  (23kb)", "https://arxiv.org/abs/1204.3529v1", "17 pages"], ["v2", "Mon, 17 Jun 2013 21:49:23 GMT  (31kb)", "http://arxiv.org/abs/1204.3529v2", "31 pages"], ["v3", "Tue, 11 Mar 2014 18:21:16 GMT  (41kb)", "http://arxiv.org/abs/1204.3529v3", "39 pages, 1 figure"]], "COMMENTS": "17 pages", "reviews": [], "SUBJECTS": "cs.CC cs.AI", "authors": ["endre boros", "aritanan gruber"], "accepted": false, "id": "1204.3529"}, "pdf": {"name": "1204.3529.pdf", "metadata": {"source": "CRF", "title": "Hardness Results for Approximate Pure Horn CNF Formulae Minimization", "authors": ["Endre Boros", "Aritanan Gruber"], "emails": ["agruber}@rutcor.rutgers.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 4.\n35 29\nv3 [\ncs .C\nC ]\nnumber of literals of pure Horn CNF representations to within a factor of 2log 1\u2212o(1)\nn. This is the case even when the inputs are restricted to pure Horn 3-CNFs with O(n1+\u03b5) clauses, for some small positive constant \u03b5. Furthermore, we show that even allowing sub-exponential time computation, it is still not possible to obtain constant factor approximations for such problems unless the Exponential Time Hypothesis turns out to be false.\nKeywords. Boolean Functions \u00b7 Propositional Horn Logic \u00b7 Hardness of Approximation \u00b7 Computational Complexity \u00b7 Artificial Intelligence\nMathematics Subject Classification (2010). 06E30 \u00b7 68Q17 \u00b7 68R01 \u00b7 68T01 \u00b7 68T27"}, {"heading": "1 Introduction", "text": "Horn functions constitute a rich and important subclass of Boolean functions and have many applications in artificial intelligence, combinatorics, computer science, and operations research. Furthermore, they possess some nice structural and algorithmic properties. An example of this claim is found on the satisfiability problem (SAT) of formulae in conjunctive normal form (CNF): while it is one of the most famous NP-complete problems for general Boolean CNFs (Cook [11]; see also: Arora and Barak [1], Garey and Johnson [19]), it can be solved in linear time in the number of variables plus the length of the Horn CNF formula being considered (Dowling and Gallier [16],\n\u2217To appear in the special issue of the Annals of Mathematics and Artificial Intelligence dedicated to ISAIM2012. The authors gratefully acknowledge the partial support by NSF grants IIS 0803444 and by CMMI 0856663. The second author also gratefully acknowledge the partial support by the joint CAPES (Brazil)/Fulbright (USA) fellowship process BEX-2387050/15061676.\nItai and Makowsky [23], and Minoux [26]), where length in this context means the number of literal occurrences in the formula (i.e., multiplicities are taken into account).\nThe problem of finding short Horn CNF representations of Horn functions specified through Horn CNFs has received some considerable attention in the literature since it has an intrinsic appeal stemming from both theoretical and practical standpoints. The same can be said about some special cases, including Horn 3-CNFs, i.e., the ones in which each clause has at most three literals.\nTwo of the common measures considered are the number of clauses and the number of literal occurrences (henceforth, number of literals). The NP-hardness of minimizing the number of clauses in Horn CNFs was first proved in a slightly different context of directed hypergraphs by Ausiello et al. [6]. It was later shown to also hold for the case of pure Horn 3-CNFs by Boros et al. [8]. The NP-hardness of minimizing the number of literals in Horn CNFs was shown by Maier [25]. A simpler reduction was found later by Hammer and Kogan [21]. Boros et al. [8] showed NP-hardnes for the pure Horn 3-CNFs case.\nThe attention then shifted to trying to approximate those values. Hammer and Kogan [21] showed that for a pure Horn function on n variables, it is possible to approximate the minimum number of clauses and the minimum number of literals of a pure Horn CNF formula representing it to within factors of n\u2212 1 and\n(n 2 )\n, respectively. For many years, this was the only result regarding approximations. Recently, a super-logarithmic hardness of approximation factor was shown by Bhattacharya et al. [7] for the case of minimizing the number of clauses for general Horn CNFs. We provide more details on this shortly.\nAnother measure for minimum representations of Horn functions concerns minimizing the number of source sides, grouping together all clauses with the same source set. Maier [25] and Ausiello et al. [6] showed that such minimization can be accomplished in polynomial time (see also Crama and Hammer [12]). While this measure is sometimes used in practice, providing reasonably good results, we consider it an important intelectual quest, following Bhattacharya et al. [7], to try to precisely understand the hardness of the other two measures.\nIn this work, we focus on the hardness of approximating short pure Horn CNF/3-CNF representations of pure Horn functions, where pure means that each clause has exactly one positive literal (definitions are provided in Section 2). More specifically, we study the hardness of approximating\n\u2022 the minimum number of clauses of pure Horn functions specified through pure Horn CNFs,\n\u2022 the minimum number of clauses and the minimum number literals of pure Horn functions specified through pure Horn 3-CNFs,\nwhen either polinomial or sub-exponential computational time is available.\nBelow, we present pointers to previous work on the subject, discuss our results in more details, and mention the main ideas behind them. We then close this section with the organization of the rest of the paper.\nPrevious Work\nThe first result on hardness of approximation of a shortest pure Horn CNF representations was provided in Bhattacharya et al. [7]. Specifically, it was shown that unless NP \u2286 QP = DTIME(npolylog(n)),\nthat is, unless every problem in NP can be solved in quasi-polynomial deterministic time in the size of the input\u2019s representation, the minimum number of clauses of a pure Horn function on n variables specified through a pure Horn CNF formula cannot be approximated in polynomial (depending on n) time to within a factor of 2log 1\u2212\u03b5 n, for any constant \u03b5 > 0 small enough.\nThis result is based on a gap-preserving reduction from a fairly well known network design problem introduced by Kortsarz [24], namely, MinRep and has two main components: a gadget that associates to every MinRep instance M a pure Horn CNF formula h such that the size of an optimal solution to M is related to the size of a clause minimum pure Horn CNF representation of h, and a gap amplification device that provides the referred gap. Despite being both necessary to accomplish the result, each component works in a rather independent way.\nInspired by the novelty of their result and by some characteristics of their reduction, we are able to further advance the understanding of hardness of approximation of pure Horn functions. We discuss how we strength their result below.\nOur Results and Techniques\nOur strengthening of the result of Bhattacharya et al. [7] can be summarized as follows: the hardness of approximation factor we present is stronger, the complexity theoretic assumption we use for polynomial time solvability is weaker, and the class of CNF formulae to which our results apply is smaller. We are also able to derive further non-approximability results for sub-exponential time solvability using a different complexity theoretic hypothesis.\nIn more details, for a pure Horn function h on n variables, we show that unless P = NP, the minimum number of clauses in a prime pure Horn CNF representation of h and the minimum number of clauses and literals in a prime pure Horn 3-CNF representation of h cannot be approximated in polynomial (depending on n) time to within factors of 2log 1\u2212o(1) n even when the inputs are restricted to pure Horn CNFs and pure Horn 3-CNFs with O(n1+\u03b5) clauses, for some small constant \u03b5 > 0. It is worth mentioning that o(1) \u2248 (log log n)\u2212c for some constant c \u2208 (0, 1/2) in this case.\nAfter that, we show that unless the Exponential Time Hypothesis introduced by Impagliazzo and Paturi [22] is false, it is not possible to approximate the minimum number of clauses and the minimum number of literals of a prime pure Horn 3-CNF representation of h in time exp(n\u03b4), for some \u03b4 \u2208 (0, 1), to within factors of O(log\u03b2 n) for some small constant \u03b2 > 0. Such results hold even when the inputs are restricted to pure Horn 3-CNFs with O(n1+\u03b5) clauses, for some small constant \u03b5 > 0. Furthermore, we also obtain a hardness of approximation factor of O(log n) under slightly more stringent, but still sub-exponential time constraints. We would like to point out that our techniques leave open the problem of determining hardness of approximation factors when exp(o(n)) computational time is available. We conjecture, however, that constant factor approximations are still not possible in that case.\nThe main technical component of our work is a new gap-preserving reduction1 from a graph theoretical problem called Label-Cover (see Section 3 for its definition) to the problem of determining the minimum number of clauses in a pure Horn CNF representation of a pure Horn function. We show that our reduction has two independent parts: a core piece that forms an ex-\n1Our reduction is actually approximation-preserving, but we do not need or rely on such characteristic. See Vazirani [29] or Williamson and Shmoys [30] for appropriate definitions.\nclusive component (Boros et al. [9]) of the function in question and therefore, can be minimized separately; and a gap amplification device which is used to obtain the hardness of approximation factor. It becomes clear that the same principle underlies Bhattacharya et al. [7]. The hardness of approximation factor comes (after calculations) from a result of Dinur and Safra [15] on the hardness of approximating certain Label-Cover instances.\nWe then introduce some local changes into our reduction that allow us to address the case in which the representation is restricted to be a pure Horn 3-CNF. Namely, we introduce extra variables in order to cubify clauses whose degree is larger than three, that is, to replace each of these clauses by a collection of degree two or degree three clauses that provide the same logical implications. This is done for two families of high degree clauses and for each family we use a different technique: a linked-list inspired transformation that is used on the classical reduction from SAT to 3-SAT instances (Garey and Johnson [19]), and a complete binary tree type transformation. The latter type is necessary to prevent certain shapes of prime implicates in minimum clause representations that would render the gap-amplification device innocuos. From this modified reduction, we are also able to derive in a straight-forward fashion a hardness result for determining the minimum number of literals of pure Horn functions represented by pure Horn 3-CNFs.\nAt this point we should mention that our reduction is somewhat more complicated than the one given in Bhattacharya et al. [7]. While we could adapt their reduction and obtain the same hardness of approximation factor we present in the case of pure Horn CNF representations (as based in our Lemma 14 we can argue that the Label-Cover and the MinRep problems are equivalent), the more involved gadget we use is paramount in extending the hardness result for the pure Horn 3-CNF case. Loosely speaking, the simple form of their reduction does not provide enough room to correctly shape those prime implicates in minimum pure Horn 3-CNF representations that we mentioned addressing in ours. In this way, the extra complications are justified.\nFinally, using newer and slightly different results on the hardness of approximation of certain Label-Cover instances (Moshkovitz and Raz [27], Dinur and Harsha [14]) in conjunction with the Exponential Time Hypothesis [22], we are able to show (also after calculations) that it might not be possible to obtain constant factor approximations for the minimum number of clauses and literals in pure Horn 3-CNF representations.\nOutline\nThe remainder of the text is organized as follows. We introduce some basic concepts about pure Horn functions in Section 2 and present the problem on which our reduction is based in Section 3. The reduction to pure Horn CNFs, its proof of correctness, and the polynomial time hardness of approximation result are shown in Section 4. In Section 5, we extend that result to pure Horn 3- CNF formulae and address the case of minimizing the number of literals. In Section 6 we show that sub-exponential time availability gives smaller but still super-constant hardness of approximation factors. We then offer some final thoughts in Section 7. A short conference version of this article appeared in Boros and Gruber [10]."}, {"heading": "2 Preliminaries", "text": "In this section we succinctly define the main concepts and notations we shall use later on. For an almost comprehensive exposition, consult the book on Boolean Functions by Crama and Hammer [12].\nA mapping h : {0, 1}n \u2192 {0, 1} is called a Boolean function on n propositional variables. Its set of variables is denoted by Vh := {v1, . . . , vn}. A literal is a propositional variable vi (positive literal) or its negation v\u0304i (negative literal).\nAn elementary disjunction of literals\nC = \u2228\ni\u2208I v\u0304i \u2228\n\u2228 j\u2208J vj, (1)\nwith I, J \u2286 Vh is a clause if I \u2229 J = \u2205. The set of variables it depends upon is Vars(C) := I \u222a J and its degree or size is given by deg(C) := |I \u222a J |. It is customary to identify a clause C with its set of literals.\nDefinition 1. A clause C as in (1) is called pure or definite Horn if |J | = 1. For a pure Horn clause C, the positive literal v \u2208 J is called its head and S = C \\ J is called its subgoal or body. To simplify notation, we sometimes write C simply as S\u0304 \u2228 v or as the implication S \u2212\u2192 v.\nDefinition 2. A conjunction \u03a6 of pure Horn clauses is a pure Horn formula in Conjunctive Normal Form (for short, pure Horn CNF). In case every clause in \u03a6 has degree at most three, the CNF is a 3-CNF. A Boolean function h is called pure Horn if there is a pure Horn CNF formula \u03a6 \u2261 h, that is, if \u03a6(v) = h(v) for all v \u2208 {0, 1}n.\nLet \u03a6 = \u2227m\ni=1Ci be a pure Horn CNF representing a pure Horn function h. We denote by\n|\u03a6|c := m and |\u03a6|l := m \u2211\ni=1\ndeg(C)\nthe numbers of clauses and literals of \u03a6, respectively. We say that \u03a6 is a clause (literal) minimum representation of h if |\u03a6|c \u2264 |\u03a8|c (|\u03a6|l \u2264 |\u03a8|l) for every other pure Horn CNF representation \u03a8 of h. With this in mind, we define\n\u03c4(h) := min{|\u03a6|c : \u03a6 is a pure Horn CNF representing h}, and\n\u03bb(h) := min{|\u03a6|l : \u03a6 is a pure Horn CNF representing h}.\nProblem 3. The clause (literal) pure Horn CNF minimization problem consists in determining \u03c4(h) (\u03bb(h)) when h is given as a pure Horn CNF. Similar definitions hold for the pure Horn 3-CNF case.\nA clause C as in (1) is an implicate of a Boolean function h if for all v \u2208 {0, 1}n it holds that h(v) = 0 implies C(v) = 0. An implicate is prime if it is inclusion-wise minimal with respect to its set of literals. The set of prime implicates of h is denoted by Ip(h). It is known (cf. Hammer and Kogan [20]) that prime implicates of pure Horn functions are pure Horn clauses. A pure Horn CNF \u03a6 representing h is prime if its clauses are prime and is irredundant if the pure Horn CNF obtained\nafter removing any of its clauses does not represent h anymore. Let us note that a clause minimun representation may involve non prime implicates, though it is always irredundant. As Hammer and Kogan [20] pointed out any Horn CNF can be reduced in polynomial time to an equivalent prime and irredundant CNF. In the sequel we shall assume all CNFs considered, including the clause minimum ones, to be prime and irredundant.\nLet C1 and C2 be two clauses and v be a variable such that v \u2208 C1, v\u0304 \u2208 C2, and C1 and C2 have no other complemented literals. The resolvent of C1 and C2 is the clause\nR(C1, C2) := (C1 \\ {v}) \u222a (C2 \\ {v\u0304})\nand C1 and C2 are said to be resolvable. It is known (e.g. Crama and Hammer [12]) that if C1 and C2 are resolvable implicates of a Boolean function h, then R(C1, C2) is also an implicate of h. Naturally, the resolvent of pure Horn clauses is also pure Horn.\nA set of clauses C is closed under resolution if for all C1, C2 \u2208 C, R(C1, C2) \u2208 C. The resolution closure of C, R(C), is the smallest set X \u2287 C closed under resolution. For a Boolean function h, let I(h) := R(Ip(h)).\nLet us note that the set of all implicates of a Horn function h may, in principle, contain clauses involving arbitrary other variables, not relevant for h. To formulate proper statements one would need to make sure that such redundancies are also handled, which complicates the formulations. To avoid such complications, we focus on I(h) in the sequel, which is completely enough to describe all relevant representations of h.\nDefinition 4. Let \u03a6 be a pure Horn CNF representing a pure Horn function h and let Q \u2286 Vh. The Forward Chaining of Q in \u03a6, denoted by F\u03a6(Q), is defined by the following algorithm. Initially, F\u03a6(Q) = Q. As long as there is a pure Horn clause S\u0304\u2228v in \u03a6 such that S \u2286 F\u03a6(Q) and v 6\u2208 F\u03a6(Q), add v to F\u03a6(Q). Whenever a variable v is added to F\u03a6(Q), we say that the corresponding clause S\u0304 \u2228 v was trigged.\nThe result below is pivotal in our work. It tells us that we can make inferences about a pure Horn function h using any of its pure Horn CNF representations.\nLemma 5 (Hammer and Kogan [21]). Two distinct pure Horn CNFs \u03a6 and \u03a8 represent the same pure Horn function h if and only if F\u03a6(U) = F\u03a8(U), for all U \u2286 Vh. Consequently, we can do Forward Chaining in h, which we denote by Fh(\u00b7), through the use of any of h\u2019s representations.\nThe following definitions and lemma concerning exclusive sets of clauses are useful when decomposing and studying structural properties of Boolean functions.\nDefinition 6 (Boros et al. [9]). Let h be a Boolean function and X \u2286 I(h) be a set of clauses. X is an exclusive set of clauses of h if for all resolvable clauses C1, C2 \u2208 I(h) it holds that: R(C1, C2) \u2208 X implies C1 \u2208 X and C2 \u2208 X .\nAn example of an exclusive set of clauses is given by the set of pure Horn implicates of a Horn function: it is not hard to see that if a resolvent is a pure Horn clause, then both the resolvable clauses must also be pure Horn.\nDefinition 7 (Boros et al. [9]). Let X \u2286 I(h) be an exclusive set of clauses for a Boolean function h and let C \u2286 I(h) be such that C \u2261 h. The Boolean function hX = C\u2229X is called the X -component of h.\nThe following claim justifies the use of \u201cthe\u201d in the previous definition.\nLemma 8 (Boros et al. [9]). Let C1, C2 \u2286 I(h), C1 6= C2, such that C1 \u2261 C2 \u2261 h and let X \u2286 I(h) be an exclusive set of clauses. Then C1 \u2229 X \u2261 C2 \u2229 X and in particular (C1 \\ X ) \u222a (C2 \u2229 X ) also represents h.\nThe above lemma is a particularly useful and important tool in our work. Loosely speaking, it means that once we are able to identify an exclusive component g of a function h, we can separately study g. Moreover, we can draw conclusions about g using any of its representations (even alternate between distinct representations as convenient) and then reintegrate the acquired knowledge into the analysis of h.\nThe Forward Chaining procedure provides us with a convenient way of identifying exclusive families for pure Horn functions, as stated in the next lemma. This result appeared recently in Boros et al. [8]. As we make explicit use of it in the analysis of our construction, we decided to include its proof below for completeness.\nLemma 9 (Boros et al. [8]). Let \u03a6 be a prime pure Horn CNF representing the function h, let W \u2286 Vh be such that F\u03a6(W ) = W , and define the set\nX (W ) := {C \u2208 I(h) : Vars(C) \u2286 W}.\nThen X (W ) is an exclusive family for h.\nProof. Let W be as specified in the lemma\u2019s statement and suppose there are clauses C1, C2 \u2208 I(h) such that R(C1, C2) \u2208 X (W ) but {C1, C2} 6\u2286 X (W ). By the definitions of X (W ) and of resolution, all but one of the variables in C = C1 \u222a C2 must belong to W and that variable, say v \u2208 C \\W , is precisely the variable upon which C1 and C2 are resolvable, that is, v occurs as head in one of those clauses. Now, since for the same input the forward chaining outcome is independent of the pure Horn representation of h, it follows that v \u2208 F\u03a6(W ) 6= W , a contradiction.\nWhen showing hardness results, we make use of the standard asymptotic notations: O(\u00b7), \u0398(\u00b7), \u2126(\u00b7), o(\u00b7), and \u03c9(\u00b7). Namely, big-oh, big-theta, big-omega, little-oh or omicron, and little-omega, respectively. For definitions and examples of use, consult e.g. the book by Cormen et al. [13].\nWe say a function f : N \u2192 N (or f : N \u2192 R) is quasi-linear if f \u2208 O ( n1+o(1) )\nand it is nearly linear if f \u2208 O ( n1+\u03b5 ) for some constant \u03b5 > 0 small enough; it is quasi-polynomial or super-polynomial if f \u2208 O ( npolylog(n) ) ; and it is sub-exponential if f \u2208 O ( 2o(n) ) ."}, {"heading": "3 The Label-Cover Problem", "text": "The Label-Cover problem is a graph labeling promise problem formally introduced in Arora et al. [2] as a combinatorial abstraction of interactive proof systems (two-prover one-round in Feige et al. [17] and Feige and Lova\u0301sz [18], and probabilistically checkable in Arora and Motwani [4] and Arora and Safra [5]). It comes in maximization and minimization flavors (linked by a \u201cweak duality\u201d relation) and is probably the most popular starting point for hardness of approximation reductions. In this section, we introduce a minimization version that is best suited for our polynomial time results. Later in Section 6, when dealing with sub-exponential time results, we shall mention its maximization counterpart.\nDefinition 10. A Label-Cover instance is a quadruple L0 = (G,L0, L \u2032 0,\u03a00), where G = (X,Y,E) is a bipartite graph, L0 and L \u2032 0 are disjoint sets of labels for the vertices in X and Y , respectively, and \u03a00 = (\u03a0 0 e)e\u2208E is a set of constraints with each \u03a0 0 e \u2286 L0 \u00d7 L \u2032 0 being a non-empty relation of admissible pairs of labels for the edge e. The size of L0 is equal to |X|+ |Y |+ |E|+ |L0|+ |L \u2032 0|+ |\u03a00|. Definition 11. A labeling for L0 is any function f0 : X \u2192 2 L0 , Y \u2192 2L \u2032 0 \\ {\u2205} assigning subsets of labels to vertices. A labeling f0 covers an edge (x, y) if for every label \u2113 \u2032 0 \u2208 f0(y) there is a label \u21130 \u2208 f0(x) such that (\u21130, \u2113 \u2032 0) \u2208 \u03a0 0 (x,y). A total-cover for L0 is a labeling that covers every edge in E. L0 is said to be feasible if it admits a total-cover.\nFollowing Arora and Lund [3], a way to guarantee that a Label-Cover instance is feasible is by imposing an extra condition on it, namely, that there is a label \u2113\u20320 \u2208 L \u2032 0 such that for each edge e \u2208 E, there is a label \u21130 \u2208 L0 with (\u21130, \u2113 \u2032 0) \u2208 \u03a0 0 e. In this way, a labeling assigning \u2113 \u2032 0 to each vertex in Y and the set L0 to each vertex in X is clearly a total-cover. However, all Label-Cover instances that we shall use are, by construction, guaranteed to be feasible. Therefore, we shall not dwell on such imposition and shall consider only feasible Label-Cover instances in the sequel.\nDefinition 12. For a total-cover f0 of L0, let f0(Z) := \u2211\nz\u2208Z |f0(z)| with Z \u2286 X \u222a Y . The cost of f0 is given by \u03ba(f0) := f0(X)/|X| and f0 is said to be optimal if \u03ba(f0) is minimum among the costs of all total-covers for L0. This minimum value we denote by \u03ba(L0).\nObserve that the feasibility of L0 implies that 1 \u2264 \u03ba(f0) \u2264 |L0|, for any total-cover f0. Also, without loss of generality, we can assume that G has no isolated vertices as they do not influence the cost of any labeling.\nWe now give an example of a Label-Cover instance L0. Let U := {u1, . . . , un} be a set of Boolean variables and let \u03a6 :=\n\u2227s i=1 \u03c6i be a formula in CNF such that each clause of \u03a6 depends\non k variables of U (as in a variation of the satisfiability problem in which each clause has exactly k literals). For a clause \u03c6 \u2208 \u03a6 and a variable u \u2208 U , we write u \u2208 \u03c6 whenever \u03c6 depends on u.\nThe bipartite graph G = (X,Y,E) is constructed from \u03a6 as follows. Let X := {x1, . . . , xks} have a vertex for every occurrence of a variable in \u03a6, and let Y := {1, . . . , s} have a vertex for every clause \u03c6 \u2208 \u03a6. Let X(u) \u2286 X denotes the set of vertices corresponding to the variable u, and define\nE := { (x, j) \u2208 X \u00d7 Y : x \u2208 X(u) and u \u2208 \u03c6j } ,\nthat is, each vertex j \u2208 Y is connected to all occurrences of all variables in the clause \u03c6j.\nDefine the label-sets as L0 := {0, 1} and L \u2032 0 := {0, 1} k . For an edge (x, j) \u2208 E, assume that x \u2208 X(u) and that u is the i-th variable in \u03c6j, and define\n\u03a00(x,j) := { (ai, (a1, . . . , ak)) : \u03c6j(a1, . . . , ak) = True } ,\nwhere ai \u2208 L0 and (a1, . . . , ak) \u2208 L \u2032 0.\nNow, it is not hard to see that in this case, there is a total-cover f0 with \u03ba(f0) = 1 if and only if \u03a6 is satisfiable. Notice that choosing k \u2265 3 establishes the NP-completeness of the problem of deciding if an optimal total-cover for a given Label-Cover instance has cost equal to one.\nThe above example was adapted from Dinur and Safra [15]. Their original version is used in the proof of Theorem 17. In that context however, \u03a6 is a non-Boolean satisfiability instance produced by a probabilistic checkable proof system and the label-sets involved are larger (see Remark 18 below).\nDefinition 13. A total-cover f0 is tight if f0(Y ) := \u2211\ny\u2208Y |f0(y)| = |Y |, i.e., if for every y \u2208 Y , it holds that |f0(y)| = 1.\nLemma 14. Every Label-Cover instance L0 admits a tight, optimal total-cover.\nProof. Suppose f0 as in Definition 11 is a minimally non-tight, optimal total-cover for L0. Hence, there is a y \u2208 Y such that |f0(y)| > 1. Let \u2113 \u2032 0 \u2208 f0(y) and define a new labeling g where g(z) = f0(z) for all z \u2208 X \u222a (Y \\ {y}) and g(y) = f0(y) \\ {\u2113 \u2032 0}. Note that g(y) 6= \u2205 and that every edge (x, y) for x \u2208 N(y) := {z \u2208 X : (z, y) \u2208 E} is covered (for f0 is a total-cover). Moreover, clearly \u03ba(f0) = \u03ba(g). Hence, g is an optimal total-cover for L0 in which g(Y ) = \u2211\ny\u2208Y |g(y)| < f0(Y ), contradicting the minimality of f0. The result thus follows.\nNotation 15. For L0 being a Label-Cover instance as in Definition 10, define r := |X|, s := |Y |, m := |E|, \u03bb := |L0|, \u03bb \u2032 := |L\u20320|, \u03c0e := |\u03a0 0 e| for e \u2208 E, and set \u03c0 := \u2211 e\u2208E \u03c0e.\nProblem 16. For any \u03c1 > 1, a Label-Cover instance L0 has covering promise \u03c1 if it falls in one of two cases: either there is a tight, optimal total-cover for L0 of cost 1, or every tight, optimal total-cover for L0 has cost at least \u03c1. The Label-Cover\u03c1 problem is a promise problem which receives a Label-Cover instance with covering promise \u03c1 (also known as a \u03c1-promise instance) as input and correctly classify it in one of those two cases.\nNotice the behavior of Label-Cover\u03c1 is left unspecified for non-promise instances. Therefore, any answer is acceptable in such case. Due to this characteristic, the Label-Cover\u03c1 problem is also referred as a gap-problem with gap \u03c1 in the literature.\nThe result below is the basis for the polynomial time hardness we shall exhibit.\nTheorem 17 (Dinur and Safra [15]). Let c be any constant in (0, 1/2) and \u03c1c(s) := 2 (log s)1\u22121/\u03b4c(s) with \u03b4c(s) := (log log s) c. There are Label-Cover instances L0 with covering-promise \u03c1c(s) such that it is NP-hard to distinguish between the cases in which \u03ba(L0) is equal to 1 or at least \u03c1c(s).\nThe closer to 1/2 the above constant c gets, the larger the hardness of approximation factor becomes. Therefore, from now on we shall consider that c is fixed to a value close to 1/2.\nRemark 18. Every Label-Cover instance produced by Dinur and Safra\u2019s reduction is feasible, has covering-promise \u03c1c(s), and satisfies the following relations: r = s\u230a\u03b4c(s)\u230b, \u03bb = \u0398(\u03c1c(s)), \u03bb\n\u2032 = \u0398(\u03c1c(s)\n\u03b4c(s)) = o(s), s\u230a\u03b4c(s)\u230b \u2264 m \u2264 s2\u230a\u03b4c(s)\u230b, and \u03c0 \u2264 m\u03bb\u03bb\u2032 = O(s2\u03b4c(s)\u03c1c(s)\u03b4c(s)+1) = o(s3), for s as specified in Notation 15. It is then immediate that each such instance has size o(s3).\nWe now introduce a refined version of the Label-Cover definitions, in which the vertices in the sets X and Y have their own copies of the label-sets L0 and L \u2032 0, respectively. We then show that all structural and approximation properties are preserved in this new version.\nDefinition 19. Let L0 = (G,L0, L \u2032 0,\u03a00) be a feasible Label-Cover instance and consider the sets Lx := {(x, \u21130) : \u21130 \u2208 L0} for each vertex x \u2208 X, and L \u2032 y := {(y, \u2113 \u2032 0) : \u2113 \u2032 0 \u2208 L \u2032 0} for each vertex y \u2208 Y . Also, define the sets L := \u22c3\nx\u2208X Lx, L \u2032 := \u222ay\u2208Y L \u2032 y, and \u03a0 := \u22c3 (x,y)\u2208E \u03a0(x,y), with\n\u03a0(x,y) := { ( (x, \u21130), (y, \u2113 \u2032 0) ) : (\u21130, \u2113 \u2032 0) \u2208 \u03a0 0 (x,y) } .\nThe quadruple L = (G,L,L\u2032,\u03a0) is called a refinement of L0.\nIt is clear that |Lx| = \u03bb for each vertex x \u2208 X, |Ly| = \u03bb \u2032 for each vertex y \u2208 Y , |\u03a0e| = \u03c0e for each edge e \u2208 E, |\u03a0| = \u03c0, and that a labeling for L is a mapping f such that x 7\u2192 f(x) \u2286 Lx for each vertex x \u2208 X, and y 7\u2192 f(y) \u2286 L\u2032y, f(y) 6= \u2205 for each vertex y \u2208 Y . Furthermore, the remaining definitions and concepts can be adapted in a straight forward fashion, and the size of a refined instance is also o(s3).\nLemma 20. For any \u03c1 > 0, there is a one-to-one cost preserving correspondence between solutions to the Label-Cover\u03c1 problem and to its refined version.\nProof. It is easy to see that f0 is a (tight) total-cover for the Label-Cover\u03c1 problem if and only if f is a (tight) total-cover for its refinement, where f(x) = {(x, \u21130) : \u21130 \u2208 f0(x)} for every x \u2208 X, and f(y) = {(y, \u2113\u20320) \u2208 L \u2032 y : \u2113 \u2032 0 \u2208 f0(y)} for every y \u2208 Y (or f(y) = (y, f0(y)) if the total-covers are tight). Furthermore it is clear that \u03ba(f0) = \u03ba(f), in any case.\nHenceforth, all the Label-Cover instances used are assumed to be of the refined kind. For more information on the Label-Cover problem and its applications, consult the survey by Arora and Lund [3], the article by Moshkovitz and Raz [27], and the book by Arora and Barak [1]."}, {"heading": "4 Reduction to pure Horn CNFs and a Polynomial Time Hardness", "text": "Result\nOur first reduction starts with a Label-Cover instance L as input and produces a pure Horn CNF formula \u03a6, which defines a pure Horn function h. The driving idea behind this reduction is that of tying the cost of tight, optimal total-covers of L to the size of clause minimum prime pure Horn CNF representations of h.\nWith this in mind, let L = (G = (X,Y,E), L, L\u2032,\u03a0) be a Label-Cover instance (in compliance with Theorem 17 and Definition 19), and let d and t be positive integers to be specified later. Both d and t will be used as (gap) amplification devices. For nonnegative integers n, define [n] := {1, . . . , n}.\nAssociate propositional variables u(\u2113) with every label \u2113 \u2208 L\u222aL\u2032, e(x, y, i) and e(x, y, \u2113\u2032, i) with every edge (x, y) \u2208 E, every label \u2113\u2032 \u2208 L\u2032y and every index i \u2208 [d]. Let v(j), for indices j \u2208 [t], be extra variables, and consider the following families of clauses:\n(a) u(\u2113) \u2227 u(\u2113\u2032) \u2212\u2192 e(x, y, \u2113\u2032, i) \u2200 (x, y) \u2208 E, (\u2113, \u2113\u2032) \u2208 \u03a0(x,y), i \u2208 [d];\n(b) \u2227\nz\u2208N(y)\ne(z, y, \u2113\u2032, i) \u2212\u2192 e(x, y, i) \u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d];\n(c) e(x, y, i) \u2212\u2192 e(x, y, \u2113\u2032, i) \u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d];\n(d) \u2227\ni\u2208[d]\n\u2227\n(x,y)\u2208E\ne(x, y, i) \u2212\u2192 u(\u2113) \u2200 \u2113 \u2208 L \u222a L\u2032;\n(e) v(j) \u2212\u2192 u(\u2113) \u2200 j \u2208 [t], \u2113 \u2208 L \u222a L\u2032;\nwhere as before, N(y) := {x \u2208 X : (x, y) \u2208 E} is the open neighborhood of the vertex y \u2208 Y .\nDefinition 21. Let us call \u03a8 and \u03a6 the canonical pure Horn CNF formulae defined, respectively, by the families of clauses (a) through (d) and by all the families of clauses above. Let g and h be, in that order, the pure Horn functions they represent.\nThe construction presented above can be divided into two parts. The families of clauses appearing in \u03a8, namely, clauses of type (a) through (d), form an independent core since the function g is an exclusive component of the function h (as we shall show). This core can be analysed and minimized separately from the remainder, and its role is to reproduce the structural properties of the Label-Cover instance. In more details, clauses of type\n(a) correspond to the constraints on the pairs of labels that can be assigned to each edge;\n(b) will assure that edges (x, y) \u2208 E are covered, enforcing the matching of the labels assigned to all the neighbors of vertex y;\n(c) assure that if an edge can be covered in a certain way, then it can be covered in all legal ways \u2014 thus implying that it is not necessary to keep track of more than one covering possibility for each edge in clause minimum prime representations;\n(d) translate the total-cover requirement and reintroduce all the labels available ensuring that if a total-cover is achievable, so are all the others; this reintroduction of labels is paramount to the proper functioning of the reduction as explained below.\nThe family of clauses occurring in \u03a6 \\\u03a8, namely, the clauses of type (e), constitutes the second part of the construction. These clauses have the role of introducing an initial collection of labels, which sole purpose is to help achieve the claimed hardness of approximation result. The intended behavior is as follows.\nConsider initially that d = t = 1. It is known that given any subset of the variables of h as input, the Forward Chaining procedure in any pure Horn CNF representation of h will produce the same output (cf. Lemma 5). In particular, for the singleton {v(1)}, the output in \u03a6 will be the set with all the variables of h, and so will be the output obtained in any clause minimum prime pure Horn CNF representing h.\nThe reintroduction of labels performed by the family of clauses (d) may allow for some clauses of type (e) to be dropped without incurring in any loss. In slightly more details, as long as a subset of the family of clauses (e) introduces enough labels so that the Forward Chaining procedure in \u03a6 is able to eventually trigger the family of clauses (d), the remaining clauses of type (e) can be dismissed. All the missing labels will be available by the end of the procedure\u2019s execution. It is not hard to see at this point that subsets of retained clauses of type (e) and total-covers of the Label-Cover instance in which the reduction is based are in one-to-one correspondence.\nNow, supposing that a clause minimum prime pure Horn CNF representation of h resembles the canonical form \u03a6, we just have to compensate for the number of clauses in \u03a8 to obtain a distinguishable gap that mimics the one exhibited by the Label-Cover (as a promise) problem. This is achieved by making the gap amplification parameter t which the clauses of type (e) depend upon large enough.\nHowever, in principle, there is no guarantee that a clause minimum prime pure Horn CNF representation of h, say \u03a5, resembles \u03a6 or that \u03a5 has any clause of type (e) whatsoever. It may\nbe advantageous to \u03a5 to have prime implicates where v(j), for j \u2208 [t], occurs in their subgoals or prime implicates with variables other than u(\u2113), for \u2113 \u2208 L \u222a L\u2032, occurring as heads. Furthermore, the number of prime implicates in \u03a5 involving v(j) might simply not depend on the number of labels. Indeed, if d = 1 as we are supposing, whenever the number of edges |E| turns out to be strictly smaller than \u03ba(L), the cost of an optimal total-cover for L, it would be advantageous for \u03a5 to have prime implicates of the form v(j) \u2212\u2192 e(x, y, 1), for (x, y) \u2208 E. This not only breaks the correspondence mentioned above, but it renders the gap amplification device t innocuous and the whole construction useless.\nWe manage to overcome the above difficulty throughout a second amplification device, the parameter d which the clauses of type (a) through (d) depend upon. As we shall prove in Lemma 27, setting d = 1 + r\u03bb+ s\u03bb\u2032 (which is strictly larger than the total number of labels available in L \u2014 cf. Notation 15 and Definition 19) allows us to control the shape of the prime implicates involving variables v(j) in prime pure Horn clause minimum representations of h: they will be precisely some of the clauses of type (e). Moreover, after showing that the function g is an exclusive component of the function h, we shall see that we do not need to concern ourselves with the actual form of clause minimum prime pure Horn CNF representations of g. Therefore, in a sense, the canonical form \u03a6 has indeed a good resemblance to a clause minimum prime pure Horn CNF representing h, and the intended behavior is achieved in the end."}, {"heading": "4.1 Correctness of the CNF Reduction", "text": "In this subsection, we formalize the discussion presented above. We will constantly use the canonical representations \u03a6 and \u03a8 to make inferences about the functions h and g they respectively define, and such inferences will most of the time be made throughout Forward Chaining. We start with some basic facts about \u03a6 and \u03a8.\nLemma 22. Let d and t be as above and let r, s, m, \u03bb, \u03bb\u2032, and \u03c0 be as in Notation 15. It holds that the number of clauses and variables in \u03a6 are, respectively,\n|\u03a6|c = (t+ 1)(r\u03bb+ s\u03bb \u2032) + d(\u03c0 + 2m\u03bb\u2032) and |\u03a6|v = t+ dm(\u03bb \u2032 + 1) + r\u03bb+ s\u03bb\u2032.\nIn \u03a8, those numbers are, respectively,\n|\u03a8|c = r\u03bb+ s\u03bb \u2032 + d(\u03c0 + 2m\u03bb\u2032) and |\u03a8|v = dm(\u03bb \u2032 + 1) + r\u03bb+ s\u03bb\u2032.\nProof. For #(\u03b1) denoting the number of clauses of type (\u03b1) in \u03a6, simple counting arguments show that the equalities\n#(a) = d\u03c0 #(c) = dm\u03bb\u2032 #(e) = t(r\u03bb+ s\u03bb\u2032) #(b) = dm\u03bb\u2032 #(d) = r\u03bb+ s\u03bb\u2032\nhold. For the number of variables, just notice there are r\u03bb + s\u03bb\u2032 variables u(\u2113), dm variables e(x, y, i), dm\u03bb\u2032 variables e(x, y, \u2113\u2032, i), and t variables v(j). To conclude the proof, just remember that the only difference between \u03a6 and \u03a8 is the absence of the family of clauses of type (e) in the latter.\nConsidering the bounds for r, m, \u03bb, \u03bb\u2032, and \u03c0 provided in Remark 18, the above result immediately implies that as long as the quantities d and t are polynomial in s, namely, the number\nof vertices in Y , the construction of \u03a6 from L can be carried out in polynomial time in s. More meaningfully, it can be carried out in polynomial time in n = |\u03a6|v, the number of variables of h.\nWe now establish the pure Horn function g as an exclusive component of h. This structural result allows us to handle g in a somewhat black-box fashion. Specifically, as we shall see briefly, it is not required of us to precisely know all the properties and details of a clause minimum representation of g. We can mainly concentrate on the study of the prime implicates that might involve the variables in h that are not in g, namely, the variables v(j), for j \u2208 [d].\nLemma 23. The function g is an exclusive component of the function h. Consequently, g can be analysed and minimized separately.\nProof. Let Vg be the set of variables occurring in \u03a8. By definition, these are the variables the function g depends upon. Since no clause in \u03a8 has head outside Vg, it is immediate that Vg is closed under Forward Chaining in \u03a6. As \u03a6 represents h, Lemma 9 then implies that X (Vg) := {C \u2208 I(h) : Vars(C) \u2286 Vg} is an exclusive family for h. This gives that \u03a8 = \u03a6 \u2229 X (Vg) is an X (Vg)-exclusive component of h (cf. Definition 7) and therefore, that g is an exclusive component of h. Now, using Lemma 8, we obtain a proof of the second claim as wished.\nWith some effort, it is possible to prove that \u03a8 is a clause minimum prime pure Horn CNF representation of g. For our proofs however, a weaker result suffices.\nLemma 24. Let \u0398 be a clause minimum prime pure Horn CNF representation of g. We have |\u03a8|c/(\u03bb+ \u03bb \u2032) \u2264 |\u0398|c \u2264 |\u03a8|c.\nProof. The upper bound is by construction. For the lower bound, observe that each variable of \u03a8 appears no more than \u03bb+ \u03bb\u2032 times as a head. As in any clause minimum representation of g they must appear as head at least once, the claim follows.\nThe next lemma is a useful tool in showing whether two different representations of the pure Horn function h are equivalent.\nLemma 25. For all indices j \u2208 [t], it holds that Fh({v(j)}) = Vg \u222a {v(j)}.\nProof. It is enough to show that {e(x, y, i) : (x, y) \u2208 E, i \u2208 [d]} \u2286 F\u03a6({v(j)}), for a fixed j \u2208 [t]. The inclusion would be false if there existed a label \u2113\u2032\u2032 \u2208 L \u222a L\u2032 such that u(\u2113\u2032\u2032) 6\u2208 F\u03a6({v(j)}). As for every label \u2113 \u2208 L \u222a L\u2032, v(j) \u2212\u2192 u(\u2113) is a clause in \u03a6, this cannot happen. Hence, the inclusion holds, implying the claim.\nThe next couple of lemmas deal with the structure of prime implicates involving the variables v(j), for j \u2208 [t]. The first states a simple, but useful fact which is valid in any representation of h. The second proves how the amplification device depending on the parameter d shapes those prime implicates in clause minimum representations of h to the desired form: v(j) \u2212\u2192 u(\u2113), with \u2113 \u2208 L \u222a L\u2032.\nLemma 26. A variable v(j), for some index j \u2208 [t], is never the head of an implicate of h. Moreover, every prime implicate of h involving v(j) is quadratic.\nProof. The first claim is straight forward as all implicates of h can be derived from \u03a6 by resolution, and v(j) is not the head of any clause of \u03a6. By Lemma 25, v(j) \u2212\u2192 z is an implicate of h for all z \u2208 Vg. Since h is a pure Horn function, the claim follows.\nLemma 27. Let d = 1 + r\u03bb+ s\u03bb\u2032. In any clause minimum prime pure Horn CNF representation of h, the prime implicates involving the variables v(j) have the form v(j) \u2212\u2192 u(\u2113), for all indices j \u2208 [t], and for some labels \u2113 \u2208 L \u222a L\u2032.\nProof. Let \u03a5 = \u0398 \u2227 \u0393 be a clause minimum prime pure Horn CNF representation of h, with \u0398 being a clause minimum pure Horn CNF representation of g. According to Lemma 26, all prime implicates of h involving the variables v(j) are quadratic. So, for all indices j \u2208 [t] and all indices i \u2208 [d] define the sets\n\u0393j0 := \u0393 \u2229 {v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L \u2032}, \u0393ji := \u0393 \u2229 {v(j) \u2212\u2192 e(x, y, i), v(j) \u2212\u2192 e(x, y, \u2113 \u2032, i) : (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y}.\nOur goal is to show that the chosen value for the parameter d forces all the sets \u0393ji to be simultaneously empty and consequently, that all the prime implicates involving the variables v(j) in clause minimum pure Horn CNF representations of h have the claimed form. We shall accomplish this in two steps.\nLet j \u2208 [t]. We first show that if a set \u0393ji 6= \u2205 for some index i \u2208 [d], then \u0393 j i 6= \u2205 for all indices\ni \u2208 [d], simultaneously.\nClaim 1. All clauses of type (d) have the same body. Therefore, during the execution of the Forward Chaining procedure from {v(j)}, either they all trigger simultaneously or none of them do. The reason for them not to trigger is the absence of some variable e(x, y, i), with (x, y) \u2208 E and i \u2208 [d], in the Forward Chaining closure from {v(j)}, i.e, e(x, y, i) 6\u2208 F\u03a5({v(j)}).\nProof. A simple inspection of the families of clauses shows that Claim (1) holds.\nNow, for each index i \u2208 [d], let \u039ei be the collection of clauses of types (a), (b), and (c) that depend on i.\nClaim 2. It holds that\ne(x, y, i) \u2208 F \u0393j0\u222a\u039ei ({v(j)}) if and only if e(x, y, i\u2032) \u2208 F \u0393j0\u222a\u039ei\u2032 ({v(j)}),\nfor all indices i, i\u2032 \u2208 [d], with i 6= i\u2032.\nProof. Notice that the families of clauses (a), (b), and (c) are completely symmetric with respect to the indexing variable i. Moreover, for i1 6= i2, the clauses indexed by i1 do not interfere with the clauses indexed by i2 during an execution of the Forward Chaining procedure. In other words, variables depending upon i1 do not trigger clauses indexed by i2, and vice-versa. These two properties, symmetry and non interference, proves Claim (2).\nClaim 3. If there is a variable e(x, y, i), with (x, y) \u2208 E and i \u2208 [d], such that\ne(x, y, i) 6\u2208 F \u0393j0\u222a( \u22c3 i\u2208[d] \u039ei) ({v(j)})\nthen e(x, y, i) 6\u2208 F\n\u0393j0\u222a( \u22c3 i\u2208[d] \u039ei)\u222a( \u22c3 i\u2032 6=i \u0393 j i\u2032) ({v(j)}).\nMoreover, this implies that \u0393ji 6= \u2205.\nProof. The symmetry and non interference properties of families of clauses (a), (b), and (c) also justifies the first part of Claim (3). To see it, just notice that were the claim to be false, the prime implicates in \u0393ji\u2032 would be trigging clauses involving the variable e(x, y, i) in an execution of the Forward Chaining procedure. Since i\u2032 6= i, this cannot happen. The second part follows immediately from the validity of the first part together with the fact that \u03a5 represents h.\nTo finish the first step, notice that since Claim (3) is valid for any i \u2208 [d], Claim (2) implies that if \u0393ji 6= \u2205 for some index i \u2208 [d], then \u0393 j i 6= \u2205 for all indices i \u2208 [d], simultaneously.\nFor the second step, suppose that \u0393ji 6= \u2205 for all indices i \u2208 [d]. We then have that\n\u03b3 := \u2211\ni\u2208[d]\n|\u0393ji | \u2265 d = 1 + r\u03bb+ s\u03bb \u2032 = 1 + |L \u222a L\u2032|,\nthat is, \u03b3 is strictly larger than the number of all available labels in L. This implies that the following pure Horn CNF\n\u2206j :=\n(\n\u03a5 \\ \u22c3 i\u2208d \u0393ji\n)\n\u222a { v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L\u2032 }\n= \u0398 \u222a\n((\n\u0393 \\ \u22c3 i\u2208d \u0393ji\n)\n\u222a { v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L\u2032 }\n)\n,\nhas fewer clauses than \u03a5 (or more precisely, it implies that |\u2206j |c <= |\u03a5|c \u2212 1).\nNow, since that \u0398 is a (clause minimum) representation of the exclusive component g, and that the set of clauses {v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L\u2032} makes all available labels reachable by Forward Chaining from {v(j)}, it follows that F\u2206j({v(j)}) = Vg\u222a{v(j)}. Furthermore, the change in clauses did not influence the Forward Chaining procedure from any other variable (other than v(j)), and thus F\u2206j({w}) = F\u03a5({w}) for all variables w 6= v(j). Thus, Lemma 25 implies that \u2206j is a representation of h.\nWe then have that \u2206j is a shorter representation for h, contradicting the optimality of \u03a5. Therefore, the sets \u0393ji = \u2205 for all indices i \u2208 [d]. As the above arguments do not depend on any particular value of j, they can be repeated for all of them.\nThe next property we can show more generally for any prime and irredundant CNF of h.\nDefinition 28. Let d = 1 + r\u03bb + s\u03bb\u2032 and let \u03a5 be a prime and irredundant pure Horn CNF representation of h. For each j \u2208 [t], consider the set\nSj = { \u2113 \u2208 L \u222a L\u2032 : v(j) \u2212\u2192 u(\u2113) \u2208 \u03a5 }\nand define the function fj : X \u2192 L, Y \u2192 L \u2032 given by fj(x) = Sj \u2229 Lx for vertices x \u2208 X and fj(y) = Sj \u2229 L \u2032 y for vertices y \u2208 Y .\nThe next three lemmas provide important properties of the functions fj above.\nLemma 29. Let \u03a5 be as in the above Definition. For all indices j \u2208 [t] and vertices y \u2208 Y , it holds that |fj(y)| \u2264 1.\nProof. Let \u03a5 be as in Definition 28 and suppose indirectly that the claim is false, that is, there is an index j \u2208 [t] and a vertex y \u2208 Y such that |fj(y)| > 1.\nDuring the proof, recall that the chosen value for the parameter d implies, according to Lemma 27, that all prime implicates of \u03a5 involving the variable v(j) must have the form v(j) \u2212\u2192 u(\u2113), with \u2113 \u2208 L \u222a L\u2032.\nLet \u2113\u2032 \u2208 fj(y) and define the expression\n\u03a5\u2032 := \u03a5 \\ {v(j) \u2212\u2192 u(\u2113\u2032)}.\nIt is enough to show that F\u03a5\u2032({v(j)}) = Vg \u222a {v(j)}, that is, that \u03a5 \u2032 is also a representation of h (cf. Lemma 25). Suppose that is not the case. Since \u03a5 and \u03a5\u2032 differ only in the clause v(j) \u2212\u2192 u(\u2113\u2032), it must be the case that u(\u2113\u2032) 6\u2208 F\u03a5\u2032({v(j)}). This happens if the clause of type (d) associated to u(\u2113\u2032) is not trigged. For this to occur, there must be an edge (x, y) \u2208 E and an index i \u2208 [d] such that e(x, y, i) 6\u2208 F\u03a5\u2032({v(j)}).\nNow, for y and i as above, notice that: (i) variable e(x, y, i) would be included in F\u03a5\u2032({v(j)}) as long as there were a label in L\u2032y such that the corresponding clause of type (b) were trigged; and (ii) once such clause of type (b) were trigged, the appropriated clauses of type (c) would trigger, thus making the other clauses of type (b) associated to y and i to also trigger.\nTherefore, for e(x, y, i) to not belong to F\u03a5\u2032({v(j)}), it must be the case that for every label \u2113\u2032\u2032 \u2208 fj(y) \\ {\u2113 \u2032} there exists a vertex z(\u2113\u2032\u2032) \u2208 N(y) for which\ne(z(\u2113\u2032\u2032), y, \u2113\u2032\u2032, i) 6\u2208 F\u03a5\u2032({v(j)}).\nFor this latter relation to be true, we must have that the clauses\nu(\u2113) \u2227 u(\u2113\u2032\u2032) \u2212\u2192 e(z(\u2113\u2032\u2032), y, \u2113\u2032\u2032, i) (2)\nare not trigged in the Forward Chaining procedure on \u03a5\u2032 starting with {v(j)}, for every label \u2113 \u2208 fj(z(\u2113 \u2032\u2032)) with (\u2113, \u2113\u2032\u2032) \u2208 \u03a0(z(\u2113\u2032\u2032),y).\nHowever, according to Definition 28, for each label \u2113\u2032\u2032 \u2208 fj(y)\\{\u2113 \u2032} and each label \u2113 \u2208 fj(z(\u2113 \u2032\u2032)), there are clauses v(j) \u2212\u2192 u(\u2113\u2032\u2032) and v(j) \u2212\u2192 u(\u2113), respectively, in \u03a5 and, consequently, in \u03a5\u2032. This implies that the clauses (2) are trigged, which implies that u(\u2113\u2032) \u2208 F\u03a5\u2032({v(j)}), which then implies that \u03a5\u2032 is also a representation of h. Since this contradicts the irredundancy of \u03a5, it follows that |fj(y)| \u2264 1, thus concluding the proof.\nLemma 30. Let \u03a5 be a clause minimum prime pure Horn CNF of h. Then it is prime and irredundant, so Definition 28 applies. We claim that for all indices j \u2208 [t] and vertices y \u2208 Y , it holds that |fj(y)| \u2265 1.\nProof. Suppose that the claim is false, that is, there is an index j \u2208 [t] and a vertex y \u2208 Y such that |fj(y)| = 0.\nThen clauses v(j) \u2212\u2192 u(\u2113\u2032), for all labels \u2113\u2032 \u2208 L\u2032y, are absent from \u03a5. Recall that the chosen value for the parameter d implies that all prime implicates of \u03a5 involving v(j) are quadratic (Lemma 27).\nThus, no clause of type (a) dependent on the vertex y is trigged during a Forward Chaining from {v(j)} and hence, no clauses of type (b) and of type (c) dependent on y are trigged either. This gives that the variables e(x, y, i), for all vertices x \u2208 N(y) and all indices i \u2208 [d], do not belong to the Forward Chaining closure (from {v(j)}). Therefore, no clause of type (d) is trigged and no label \u2113\u2032 \u2208 L\u2032y is reintroduced. In other words, it is the case that u(\u2113\n\u2032) 6\u2208 F\u03a5({v(j)}) and hence, that F\u03a5({v(j)}) 6= Fh({v(j)}). By Lemma 25, \u03a5 does not represent h, a contradiction. So, it must be the case that |fj(y)| \u2265 1.\nCombining the two lemmas above, we have the following tight result.\nCorollary 31. Let \u03a5 be a clause minimum prime pure Horn CNF of h. Then, for all indices j \u2208 [t] and vertices y \u2208 Y , it holds that |fj(y)| = 1.\nThe next lemma shows that the functions fj are indeed tight total-covers.\nLemma 32. Let \u03a5 be a clause minimum prime pure Horn CNF of h. For each index j \u2208 [t], the function fj is a tight total-cover for L.\nProof. Let j \u2208 [t]. By construction (cf. Definition 28), fj is a labeling for L. Suppose however, that fj is not a total-cover. Hence, there exists an edge (x, y) \u2208 E and a label \u2113\n\u2032 \u2208 fj(y) such that for all labels \u2113 \u2208 fj(x), it holds that (\u2113, \u2113\n\u2032) 6\u2208 \u03a0(x,y). Since \u03a5 is clause minimum, no variable e(x, y, \u2113\u2032, i) belongs to F\u03a5({v(j)}), for any index i \u2208 [d]. This is so because the variables e(x, y, \u2113\n\u2032, i) do not occur as heads in any clause of \u03a5 (cf. Lemma 27). Now, using Lemma 25, we obtain that \u03a5 does not represent h, a contradiction. To conclude the proof, just notice that Corollary 31 implies that fj is tight.\nIn order to relate the size of a clause minimum representation of h to the cost of an optimal solution to L, we need a comparison object. Let f be a tight total-cover for L and consider the following subfamily of clauses:\n(e\u2019) v(j) \u2212\u2192 u(\u2113) \u2200 j \u2208 [t], x \u2208 X, y \u2208 Y, \u2113 \u2208 f(x) \u222a f(y),\nwith f(x) \u2286 Lx and f(y) \u2286 L \u2032 y. Let \u03a6f be the refined canonical (with respect to f) pure Horn CNF formula resulting from the conjunction of \u03a8 with the clauses of type (e\u2019).\nLemma 33. \u03a6f represents h.\nProof. Suppose the opposite. As g is also an exclusive component of \u03a6f , that means u(\u2113 \u2032\u2032) 6\u2208 F\u03a6f ({v(j)}) for some label \u2113 \u2032\u2032 \u2208 L \u222a L\u2032 and index j \u2208 [t]. For that to happen, for any index i \u2208 [d] there must be an edge (x, y) \u2208 E such that e(x, y, i) 6\u2208 F\u03a6f ({v(j)}) and for every \u2113 \u2032 \u2208 L\u2032y there is a vertex z \u2208 N(y) such that e(z, y, \u2113\u2032, i) 6\u2208 F\u03a6f ({v(j)}) as well. But since f is a tight totalcover, there is a pair of labels (\u2113z, \u2113 \u2032 y) \u2208 \u03a0(z,y) triggering the clause u(\u2113z)\u2227 u(\u2113 \u2032 y) \u2212\u2192 e(z, y, \u2113 \u2032 y , i) as both u(\u2113z) and u(\u2113 \u2032 y) belong to F\u03a6f ({v(j)}), contradicting e(z, y, \u2113 \u2032 y , i) 6\u2208 F\u03a6f ({v(j)}). Therefore, F\u03a6f ({v(j)}) = Vg \u222a {v(j)} and the claim follows by Lemma 25.\nLemma 34. Let \u03a5 be a clause minimum prime pure Horn CNF of h, and let us define fj, for all indices j \u2208 [t], as in Definition 28. It holds that each fj is a tight, minimum cost total-cover for L.\nProof. Let \u03a5 = \u0398 \u2227 \u0393 where \u0398 is an optimal representation of g and \u0393 consists of clauses of type (e) (cf. Lemma 27). As assured by Lemma 32, fj are tight total-covers for L, for each and every index j \u2208 [t]. Notice that since \u03a5 is clause minimum, it follows that all these tight total-covers have the same cost, i.e., \u03ba(fj) = \u03ba(fk) for all j, k \u2208 [t].\nWe then have that\n\u2211\nj\u2208[t]\n(\u03ba(fj)r + s) = t(\u03ba(fj)r + s) = |\u0393|c \u2264 |\u03a6f \\\u03a8|c = t(\u03ba(f)r + s), (3)\nwhere f is any tight total-cover for L and \u03a6f is the refined canonical (w.r.t. f) formula as in Lemma 33. In particular, Equation (3) holds even when f is a tight, minimum cost total-cover, thus implying that fj is optimal as claimed.\nRemark 35. The tight, optimal total-covers fj and fk, for j, k \u2208 [t] and j 6= k, might be different. As they have the same optimal cost, any one of them can be exhibited as solution to L.\nThe following corollary summarizes the work done so far.\nCorollary 36. Let \u03a8 be as in Definitions 21 and \u03a5 be a clause minimum prime pure Horn CNF of h. It holds that\n|\u03a8|c/(\u03bb+ \u03bb \u2032) \u2264 |\u03a5|c \u2212 t(\u03ba(f)r + s) \u2264 |\u03a8|c,\nwhere \u03ba(f)r + s is the total number of labels in a tight optimal total-cover f for L."}, {"heading": "4.2 The CNF Hardness Result", "text": "We are now able to prove the main result of this section.\nTheorem 37. Let c be a fixed constant close to 1/2. Unless P = NP, the minimum number of clauses of a pure Horn function on n variables cannot be approximated in polynomial time (depending on n) to within a factor of\n\u03c1c(n \u03b5) \u2265 2\u03b5(logn) 1\u22121/\u03b4c(n) = 2log 1\u2212o(1) n,\nwhere \u03b4c(n) = (log log n) c, even when the input is restricted to CNFs with O(n1+2\u03b5) clauses, for some \u03b5 \u2208 (0, 1/4].\nProof. Let L0 be a Dinur and Safra\u2019s Label-Cover promise instance (cf. Theorem 17) and let L be its equivalent refined version (cf. Definition 19).\nLet \u03a6 be the canonical formula constructed from L with the parameter d set to d = 1+ r\u03bb+s\u03bb\u2032 (cf. Lemma 27), and let h be the pure Horn function defined by \u03a6. Let \u03a5 be a pure Horn CNF representation of h obtained by some exact clause minimization algorithm when \u03a6 is given as input.\nRecall Notation 15 and for convenience, let \u03b4 = \u03b4c(s) and \u03c1 = \u03c1c(s). Substituting the quantities established in Lemma 22 into the bounds given by Corollary 36, and applying the values given in Remark 18, we have that\n|\u03a5|c \u2265 t(\u03ba(f)r + s) + d(\u03c0 + 2m\u03bb\u2032) + r\u03bb+ s\u03bb\u2032\n\u03bb+ \u03bb\u2032\n\u2265 st(\u03ba(f)(\u03b4 \u2212 1) + 1) + \u2126(s2\u03b4\u03c1\u03b4)\n\u2265 st(\u03ba(f)(\u03b4 \u2212 1) + 1) + \u03c9(s2),\nand\n|\u03a5|c \u2264 t(\u03ba(f)r + s) + d(\u03c0 + 2m\u03bb \u2032) + r\u03bb+ s\u03bb\u2032\n\u2264 st(\u03ba(f)\u03b4 + 1) +O(s3\u03b4\u03c12\u03b4+1)\n\u2264 st(\u03ba(f)\u03b4 + 1) + o(s4).\nSimilarly, for the number of variables we have that\nt \u2264 |\u03a5|v = t+ dm(\u03bb \u2032 + 1) + r\u03bb+ s\u03bb\u2032\n\u2264 t+O(s3\u03b4\u03c12\u03b4)\n\u2264 t+ o(s4).\nNow, choosing \u03b5 > 0 such that t = s1/\u03b5 = \u2126(s4) and supposing that s \u2212\u2192 \u221e, we obtain the asymptotic expressions\n|\u03a5|c = s (1+1/\u03b5)\u03b4c(s)\u03ba(f)(1 + o(1)) and |\u03a5|v = s 1/\u03b5(1 + o(1)).\nBringing the existing gaps of the Label-Cover promise instances into play, we then obtain the following dichotomy\n\u03ba(L) = 1 =\u21d2 |\u03a5|c \u2264 s (1+1/\u03b5)\u03b4c(s)(1 + o(1)),\n\u03ba(L) \u2265 \u03c1c(s) =\u21d2 |\u03a5|c \u2265 s (1+1/\u03b5)\u03b4c(s)\u03c1c(s)(1 + o(1)).\nLetting n = |\u03a5|v and relating |\u03a5|c to the number of variables of h, the above dichotomy reads as\n\u03ba(L) = 1 =\u21d2 |\u03a5|c \u2264 n (1+\u03b5)\u03b4c(n \u03b5)(1 + o(1)),\n\u03ba(L) \u2265 \u03c1c(s) =\u21d2 |\u03a5|c \u2265 n (1+\u03b5)\u03b4c(n \u03b5)\u03c1c(n \u03b5)(1 + o(1)),\ngiving a hardness of approximation factor of \u03c1c(n \u03b5) for the pure Horn CNF minimization problem (cf. Theorem 17). That is, any polynomial time algorithm that approximates the number of clauses of a pure Horn CNF representation of h to within a factor better than \u03c1c(n\n\u03b5) can be used to solve the Label-Cover promise problem for L. This in turn would show that P = NP.\nTo conclude the proof, notice that since log \u03b5 < 0 and n \u2212\u2192 \u221e, the gap\n\u03c1c(n \u03b5) = 2(\u03b5 logn)\n1\u22121/\u03b4c(n\u03b5)\n\u2265 2\u03b5(logn) 1\u22121/\u03b4c(n) = 2(logn) 1\u22121/\u03b4c(n)+log \u03b5/ log log n = 2(logn) 1\u2212o(1) ,\nwhere the log \u03b5/ log log n in the exponent is negligible compared to 1/\u03b4c(n) as \u03b4c(n) = o(log log n), and also notice that the number of clauses\nn(1+\u03b5)\u03b4c(n \u03b5) \u2264 n1+2\u03b5."}, {"heading": "5 Pure Horn 3-CNFs and Minimizing the Number of Literals", "text": "In this section, we extend our hardness result in two ways. First, we prove that it still holds when the pure Horn function h is represented through a pure Horn 3-CNF, that is, in which each clause has at most three literals (and at least two, since h is pure Horn). Second, we build upon this first extension and prove that a similar bound holds when trying to determine a literal minimum pure Horn 3-CNF representation of h.\nLet again d = 1 + r\u03bb+ s\u03bb\u2032 and t be a positive integer to be specified later. As in the previous section, both d and t will be used as (gap) amplification devices.\nA brief inspection of our construction in Section 4 shows that the clauses of type (b) and (d) may have arbitrarily long subgoals, with long meaning strictly more than three literals. The idea is then to modify the construction locally so that each long clause is replaced by a gadget consisting of a collection of quadratic or cubic new clauses. Each gadget is designed to preserve the original logic implications of the clause it replaces.\nSpecifically, we replace the clauses of type (b) in a similar way to what is done in the reduction from SAT to 3-SAT (cf. Garey and Johnson [19]), that is, in a linked-list fashion. For each vertex y \u2208 Y , let d(y) := |N(y)| be its degree and let \u3008z1y , z 2 y , . . . , z d(y) y \u3009 be an arbitrary, but fixed ordering of its neighbors. Associate new propositional variables e(\u03b2, x, y, \u2113\u2032, i) with all edges (x, y) \u2208 E, all labels \u2113\u2032 \u2208 L\u2032y, all indices i \u2208 [d], and all indices \u03b2 \u2208 [d(y) \u2212 2]. As before, we have that d = 1 + r\u03bb+ s\u03bb\u2032. Replace the clauses of type (b) by the families of clauses below:\n(b1) \u2227\nz\u2208N(y)\ne(z, y, \u2113\u2032, i) \u2212\u2192 e(x, y, i) \u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], d(y) \u2264 2;\n(b2) e(z 1 y , y, \u2113 \u2032, i) \u2227 e(z2y , y, \u2113 \u2032, i) \u2212\u2192 e(1, x, y, \u2113\u2032, i)\n\u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], d(y) \u2265 3;\n(b3) e(z \u03b2+2 y , y, \u2113 \u2032, i) \u2227 e(\u03b2, x, y, \u2113\u2032, i) \u2212\u2192 e(\u03b2 + 1, x, y, \u2113\u2032, i)\n\u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], \u03b2 \u2208 [d(y)\u2212 3];\n(b4) e(z d(y) y , y, \u2113 \u2032, i) \u2227 e(d(y)\u2212 2, x, y, \u2113\u2032, i) \u2212\u2192 e(x, y, i)\n\u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], d(y) \u2265 3.\nThe clauses of type (b1) are exactly the quadratic and cubic clauses of type (b) in the original construction. The clauses of types (b2), (b3), and (b4) rely on the new variables e(\u03b2, x, y, \u2113\n\u2032, i) to handle the remaining original clauses of type (b) through a series of split and link operations. It is not hard to see that these new families of clauses retain the symmetry and non interference properties possessed by the original ones they replaced. Furthermore, they will be part of an\nexclusive component. These characteristics, as we shall see, contributes to the transference of most of the lemmas from the previous section in a rather verbatim fashion.\nTrying to apply the same technique to the clauses of type (d) generates the following problem. Recall that m = |E|. All the r\u03bb + s\u03bb\u2032 clauses of type (d) have the same long subgoal with dm literals; they only differ in their heads. In a first attempt to emulate what was done above to the clauses of type (b), we may decide to replace this long subgoal with a single linked list and to replicate its last node once for each label \u2113 \u2208 L \u222a L\u2032. After ordering these literals in an arbitrary, but fixed order, introducing dm\u2212 2 new variables, say e(\u03b6) for \u03b6 \u2208 [dm\u2212 2], and performing split and link operations, we obtain the linked list whose last node has subgoal e(x\u2032, y\u2032, i\u2032) \u2227 e(dm\u2212 2), for some edge (x\u2032, y\u2032) \u2208 E and some index i\u2032 \u2208 [d]. This subgoal is then replicated, thus spanning the clauses\ne(x\u2032, y\u2032, i\u2032) \u2227 e(dm\u2212 2) \u2212\u2192 u(\u2113),\nfor all labels \u2113 \u2208 L \u222a L\u2032. Now, it is not hard to see that the prime implicates v(1) \u2212\u2192 e(x\u2032, y\u2032, i\u2032) and v(1) \u2212\u2192 e(dm\u2212 2) completely bypass the amplification device dependent on the parameter d, reintroducing all the available labels. Similar to what was said before, this renders the gap amplification device dependent on parameter t innocuous and the whole construction useless. It is also not hard to see that introducing a new amplification device and recurring on the whole idea does not solve the problem as we end up in a similar situation.\nIn a second attempt to emulate what was done to the clauses of type (b), we may decide to introduce different linked lists to different clauses of type (d). Notice that this implies that each of these lists must be indexed by one of the available labels in L\u222aL\u2032. In order for this new collection of clauses to be reached in an execution of the Forward Chaining procedure, this indexing scheme must be back propagated into the clauses of types (a), (b1) through (b4), and (c). That is, every clause of the exclusive component must now be indexed by a label in L\u222aL\u2032. With some thought, it is possible to realize the following. First, this label indexing of clauses is performing a job similar to the one played by parameter d, in the sense that the latter could in principle be dropped \u2014 and replacing one scheme by the other leaves the number of clauses in the exclusive component in the same order of magnitude. Second, this operation significantly changes the meaning of the clauses being used as the labels would then be reintroduced in a somewhat independent fashion. While the high degree of symmetry guarantees that all labels would be reintroduced, the new core is not an extension of the old one: we are not extending the original function by the introduction of auxiliary variables to reduce clause degrees through new local gadgets; we are changing the function being represented, and that qualifies the process as a new construction instead of a cubification of the old one. This immediately leads us to our third point: it is not clear how or whether the proofs we presented in Section 4 would extend to this new environment. Again with some thought, it is possible to see that the use of the label indexing scheme alone does not guarantee that the prime implicates involving variables v(j) can have forms other than v(j) \u2212\u2192 u(\u2113), for j \u2208 [t] and \u2113 \u2208 L\u222aL\u2032. Moreover, the shape of these prime implicates might depend on the ordering chosen for the edges of the graph and reintroducing the amplification device based on parameter d, playing the same role as was before, does not ameliorate the situation (actually, it is completely useless). The difficulty in controlling the shape of those prime implicates tarnishes the tie established between clause minimum prime pure Horn representations and tight, optimal total-covers. It might still be possible to replace the clauses of type (d) in a linked-list fashion, but at this point is still not clear how to use such approach in a correct and not overly complicated way.\nWe shall circumvent the above problem through the use of a different structure: we shall replace the clauses of type (d) by new clauses arranged as complete binary trees, i.e., trees in which every level has all the nodes with the possible exception of the last level, where its nodes are flushed to the left; and we shall then link these trees together by their roots. The idea is as follows. For each index i \u2208 [d], we will introduce m \u2212 1 new variables and will arrange them as internal nodes in a complete binary tree, where the variables e(x, y, i) will appear as tree leaves. Notice that we will have exactly d trees. We will then associate each label from L \u222a L\u2032 with the roots of two of those trees, in an orderly fashion: the roots (namely, the variables e(1, i)) will be seen as nodes and the labels will be seen as edges of a path of length d. The path will be well defined (i.e., all labels will be reintroduced) if all nodes (root variables) are reachable through Forward Chaining from a variable v(j). It is worth noticing that since d = 1 + r\u03bb + s\u03bb\u2032 > |L \u222a L\u2032|, all prime implicates involving the variables v(j) will have the form v(j) \u2212\u2192 u(\u2113), for some label \u2113 \u2208 L \u222aL\u2032 \u2014 similarly to what happend in the pure Horn CNF case, we shall show that it is simply not advantageous for these prime implicates to have any other form in clause minimum prime pure Horn 3-CNF representations. We now formalize this idea.\nLet us rename the labels in L \u222a L\u2032 as \u2113\u03b1, \u03b1 \u2208 [d \u2212 1]. Let us also index the m edges in E as ek, k \u2208 [m]. Let us further introduce new propositional variables e(k, i), k \u2208 [m \u2212 1], i \u2208 [d], and introduce e(k, i) for k \u2208 {m,m+ 1, . . . , 2m\u2212 1} to be an alias to the variable e(x, y, i), where (x, y) = ek\u2212m+1 is an edge in E according to the indexing above. We then create d complete binary trees through the family of clauses:\n(d1) e(2k, i) \u2227 e(2k + 1, i) \u2212\u2192 e(k, i) \u2200 k \u2208 [m\u2212 1], i \u2208 [d];\n(d2) e(1, \u03b1) \u2227 e(1, \u03b1 + 1) \u2212\u2192 u(\u2113\u03b1) \u2200 \u03b1 \u2208 [d\u2212 1].\nNotice that clauses of type (d1) index the nodes of the tree in a similar way a complete binary tree is stored inside an array (cf. Cormen et al. [13]) and that the clauses of type (d2) do define the path we mentioned.\nWe shall illustrate the complete binary tree transformation through the following toy example. We start with a Label-Cover instance whose constraint graph is a claw, that is, G = ({x1, x2, x3}, {y}, {(x1, y), (x2, y), (x3, y)}), whose label sets are L0 = {\u21131, \u21132} and L \u2032 0 = {\u2113 \u2032 1, \u2113 \u2032 2}, and whose constraint set is the union of\n\u03a00(x1,y) = {(\u21131, \u2113 \u2032 1), (\u21131, \u2113 \u2032 2)}, \u03a0 0 (x2,y) = {(\u21131, \u2113 \u2032 2)}, and \u03a0 0 (x3,y) = {(\u21132, \u2113 \u2032 1), (\u21132, \u2113 \u2032 2)}.\nThe refined Label-Cover instance will then have 8 labels in total (L = {\u211311, \u2113 1 2, \u2113 2 1, \u2113 2 2, \u2113 3 1, \u2113 3 2}\nand L\u2032 = {\u2113\u20321, \u2113 \u2032 2}) 2 and our CNF construction will introduce 8\u00d7 9 = 72 clause of type (d), nine of which have the following form\ne(x1, y, i) \u2227 e(x2, y, i) \u2227 e(x3, y, i) \u2212\u2192 u(\u2113 1 1),\nas i \u2208 [d] = [9]. Clauses of type (d1) replace those subgoals above by\ne(4, i) \u2227 e(5, i) \u2212\u2192 e(2, i) and e(2, i) \u2227 e(3, i) \u2212\u2192 e(1, i), (4)\nwhere in this case, e(x1, y, i) = e(3, i), e(x2, y, i) = e(4, i), and e(x3, y, i) = e(5, i).\n2The refined label (xi, \u2113j) \u2208 L, with xi \u2208 X and \u2113j \u2208 L0, is depicted by \u2113 i j in this example.\nFinally, clauses of type (d2) link the trees in (4) together, as e.g.\ne(1, 1) \u2227 e(1, 2) \u2212\u2192 u(\u211311), e(1, 2) \u2227 e(1, 3) \u2212\u2192 u(\u2113 1 2), and so on.\nA graphical illustration of part of the above transformation is provided in Figure 1.\nNow, for clarity purposes, we present this new construction for the pure Horn 3-CNF case in\nfull form below:\n(a) u(\u2113) \u2227 u(\u2113\u2032) \u2212\u2192 e(x, y, \u2113\u2032, i) \u2200 (x, y) \u2208 E, (\u2113, \u2113\u2032) \u2208 \u03a0(x,y), i \u2208 [d];\n(b1) \u2227\nz\u2208N(y)\ne(z, y, \u2113\u2032, i) \u2212\u2192 e(x, y, i) \u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], d(y) \u2264 2;\n(b2) e(z 1 y , y, \u2113 \u2032, i) \u2227 e(z2y , y, \u2113 \u2032, i) \u2212\u2192 e(1, x, y, \u2113\u2032, i)\n\u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], d(y) \u2265 3;\n(b3) e(z \u03b2+2 y , y, \u2113 \u2032, i) \u2227 e(\u03b2, x, y, \u2113\u2032, i) \u2212\u2192 e(\u03b2 + 1, x, y, \u2113\u2032, i)\n\u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], \u03b2 \u2208 [d(y) \u2212 3];\n(b4) e(z d(y) y , y, \u2113 \u2032, i) \u2227 e(d(y)\u2212 2, x, y, \u2113\u2032, i) \u2212\u2192 e(x, y, i)\n\u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d], d(y) \u2265 3;\n(c) e(x, y, i) \u2212\u2192 e(x, y, \u2113\u2032, i) \u2200 (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, i \u2208 [d];\n(d1) e(2k, i) \u2227 e(2k + 1, i) \u2212\u2192 e(k, i) \u2200 k \u2208 [m\u2212 1], i \u2208 [d];\n(d2) e(1, \u03b1) \u2227 e(1, \u03b1 + 1) \u2212\u2192 u(\u2113\u03b1) \u2200 \u03b1 \u2208 [d\u2212 1];\n(e) v(j) \u2212\u2192 u(\u2113) \u2200 j \u2208 [t], \u2113 \u2208 L \u222a L\u2032;\nwhere as before, N(y) := {x \u2208 X : (x, y) \u2208 E} is the open neighborhood of the vertex y \u2208 Y . Recall that e(k, i) is an alias to a variable e(x, y, i), (x, y) = ek\u2212m+1 being an edge in E, if k \u2208 {m,m+ 1, . . . , 2m\u2212 1} and that it is a new variable used to build the i-th tree if k \u2208 [m\u2212 1].\nDefinition 38. Let us call \u03a8 and \u03a6 the canonical pure Horn 3-CNF formulae defined, respectively, by the families of clauses (a) through (d2) and by all the families of clauses above. Let g and h be, in that order, the pure Horn functions they represent."}, {"heading": "5.1 Correctness of the 3-CNF Reduction", "text": "We now proceed to show the correctness of the ideas discussed above. Once again, we will constantly rely on the canonical representations \u03a6 and \u03a8 to make inferences about the functions h and g they respectively define. And these inferences will most of the time be made throughout Forward Chaining. First, we present the new estimations for the number of clauses and variables in \u03a6 and \u03a8.\nLemma 39. Let d and t be positive integers (amplification parameters) and let r, s, m, \u03bb, \u03bb\u2032, and \u03c0 be as in Notation 15. We have the following relations for the number of clauses and variables in \u03a6, respectively:\nd(\u03c0 + 2m\u03bb\u2032 + 2m\u2212 1)\u2212 1 \u2264 |\u03a6|c \u2212 t(r\u03bb+ s\u03bb \u2032) \u2264 d(\u03c0 +m2\u03bb\u2032 + 4m)\nand t \u2264 |\u03a6|v \u2264 t+ dm(\u03bb \u2032 + 2) +m2\u03bb\u2032,\nIn \u03a8, those numbers are, respectively,\nd(\u03c0 + 2m\u03bb\u2032 + 2m\u2212 1)\u2212 1 \u2264 |\u03a8|c \u2264 d(\u03c0 +m 2\u03bb\u2032 + 4m)\nand 0 \u2264 |\u03a8|v \u2264 dm(\u03bb \u2032 + 2) +m2\u03bb\u2032.\nProof. Let #(b\u0303) := \u2211 i\u2208[4]#(bi) and #(d\u0303) := \u2211\ni\u2208[2]#(di), where #(\u03b1) denotes the number of clauses of type (\u03b1) in \u03a6.\nFor each edge (x, y) \u2208 E, there was a clause of type (b) whose subgoal had size equal to d(y). Each of those clauses was either maintained in case d(y) \u2264 2 (originating the new clauses (b1)) or replaced by the d(y) \u2212 1 new clauses (b2), (b3), and (b4) in a linked-list fashion. This procedure results in\ndm\u03bb\u2032 \u2264 #(b\u0303) = d\u03bb\u2032 \u2211\n(x,y)\u2208E\n(d(y)\u2212 1) \u2264 dm(m\u2212 1)\u03bb\u2032.\nThe clauses of type (d) were replaced by clauses of type (d1) and (d2). The new clauses of type (d1) describe d complete binary trees, each of which having 2m \u2212 1 nodes and hence, height \u03b7 = 1 + \u230alog(2m\u2212 1)\u230b \u2264 \u230alog 4m\u230b. Considering also the d \u2212 1 new clauses of type (d2), we then obtain that\nd(2m\u2212 1)\u2212 1 \u2264 #(d\u0303) = d\u2212 1 + d\n\u03b7\u22121 \u2211\nl=1\n2l = d\u2212 1 + d(2\u03b7 \u2212 1) \u2264 4dm.\nThe new gadgets introduces d(m \u2212 1) new variables e(k, i) (notice the aliases are not new variables) and at most dm(m\u2212 1)\u03bb\u2032 new variables e(\u03b2, x, y, \u2113\u2032, i). Now, the results follow by using the remaining estimates of Lemma 22 and by recalling that \u03a6 and \u03a8 differ only on the clauses of type (e).\nSimilarly to the pure Horn CNF case, as long as the quantities d and t are polynomial in s, namely, the number of vertices in Y , the new construction of \u03a6 from L can also be carried out in polynomial time in s or, in another way, in polynomial time in the number of variables of h (cf. Remark 18).\nThe same arguments used to prove Lemma 23 apply in this new setting as the differences introduced by the new clauses are of a local nature. Specifically, it is still immediate that no clause in \u03a8 has head outside Vg, the set of variables occurring in \u03a8, and hence, that Vg is closed under Forward Chaining in \u03a6. Thus, the set X (Vg) := {C \u2208 I(h) : Vars(C) \u2286 Vg} is still an exclusive family for h (cf. Lemma 9) and g \u2261 \u03a8 = \u03a6 \u2229 X (Vg) is an X (Vg)-exclusive component of h. We have just proved the following.\nLemma 40. The new function g is an exclusive component of the new function h. Consequently, g can be analysed and minimized separately.\nIt is not hard to see that the bounds provided by Lemma 24 are still valid in this new setting. Furthermore, Lemmas 25 and 26 transfer in an almost verbatim fashion: their proof can be quickly adapted as the new clauses and variables do not disrupt any of the conclusions obtained.\nIn the CNF construction presented in the previous section, all clauses of type (d) had the same subgoal. As explained in the beginning of this section, those clauses\u2019 subgoals were potentially long and we had to replace them by d gadgets whose structure mimics those of complete binary trees. It is still true that if one label in L \u222a L\u2032 is reintroduced by a clause of type (d2), then so are all the remaining others. Like before, the reason is the high degree of symmetry occurring inside the exclusive component of g. Nevertheless, as the 3-CNF construction is more involved, we shall still present below complete proofs for the analogues of Lemmas 27, 29, and 30.\nLemma 41 (Analogue of Lemma 27). Let d = 1 + r\u03bb+ s\u03bb\u2032. In any clause minimum prime pure Horn 3-CNF representation of h, the prime implicates involving the variables v(j) have the form v(j) \u2212\u2192 u(\u2113), for all indices j \u2208 [t], and for some labels \u2113 \u2208 L \u222a L\u2032.\nProof. Let \u03a5 = \u0398 \u2227 \u0393 be a clause minimum prime pure Horn 3-CNF representation of h, with \u0398 being a clause minimum pure Horn 3-CNF representation of g. According to an analogue of Lemma 26, all prime implicates of h involving the variables v(j) are quadratic. So, for all indices j \u2208 [t] and all indices i \u2208 [d] define the sets\n\u0393j0 := \u0393 \u2229 {v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L \u2032}, \u0393ji := \u0393 \u2229 {v(j) \u2212\u2192 e(k, i),\nv(j) \u2212\u2192 e(x, y, \u2113\u2032, i), v(j) \u2212\u2192 e(\u03b2, x, y, \u2113\u2032, i) : k \u2208 [2m\u2212 1], (x, y) \u2208 E, \u2113\u2032 \u2208 L\u2032y, \u03b2 \u2208 [d(y)\u2212 2]}.\nRecall that e(k, i) is an alias to e(x, y, i) if (x, y) = ek\u2212m+1 and k \u2208 {m,m + 1, . . . , 2m \u2212 1}. Our goal is to show that the chosen value for the parameter d forces all the sets \u0393ji to be simultaneously empty and consequently, that all the prime implicates involving the variables v(j) in clause minimum pure Horn CNF representations of h have the claimed form. We shall accomplish this in two steps.\nLet j \u2208 [t]. We first show that if a set \u0393ji 6= \u2205 for some index i \u2208 [d], then \u0393 j i 6= \u2205 for all indices\ni \u2208 [d], simultaneously.\nClaim 0. It holds that\ne(k, i) \u2208 F\u03a5({v(j)}) if and only if e(k, i \u2032) \u2208 F\u03a5({v(j)}),\nfor all indices i, i\u2032 \u2208 [d], with i 6= i\u2032.\nProof. The families of clauses (a), (b1), (b2), (b3), (b4), and (c) are completely symmetric with respect to the indexing variable i and do not interfere with each other. That is, for i1 6= i2, variables depending upon i1 do not trigger clauses indexed by i2 during Forward Chaining, and vice-versa.\nClaim 1. All clauses of type (d2) have two variables in their subgoals which are roots of different, but completely symmetric trees (the trees specified by the clauses of type (d1)). Therefore, because of this symmetry and Claim (0), during the execution of the Forward Chaining procedure from {v(j)}, either they all clauses of type (d2) trigger simultaneously or none of them do. The reason for them not to trigger is the absence of variables e(k, i), for some k \u2208 [2m\u22121] and all i \u2208 [d], in the Forward Chaining closure from {v(j)}, i.e, e(k, i) 6\u2208 F\u03a5({v(j)}).\nProof. A simple inspection of the families of clauses shows that Claim (1) holds.\nNow, for each index i \u2208 [d], let \u039ei be the collection of clauses of types (a), (b1), (b2), (b3), (b4), and (c) that depend on i.\nClaim 2. It holds that\ne(k, i) \u2208 F \u0393j0\u222a\u039ei ({v(j)}) if and only if e(k, i\u2032) \u2208 F \u0393j0\u222a\u039ei\u2032 ({v(j)}),\nfor all indices i, i\u2032 \u2208 [d], with i 6= i\u2032.\nProof. Notice that the families of clauses (a), (b1), (b2), (b3), (b4), and (c) are completely symmetric with respect to the indexing variable i. Moreover, for i1 6= i2, the clauses indexed by i1 do not interfere with the clauses indexed by i2 during an execution of the Forward Chaining procedure. In other words, variables depending upon i1 do not trigger clauses indexed by i2, and vice-versa. These two properties, symmetry and non interference, proves Claim (2).\nClaim 3. If there is a variable e(k, i), with k \u2208 [2m\u2212 1] and i \u2208 [d], such that\ne(k, i) 6\u2208 F \u0393j0\u222a( \u22c3 i\u2208[d] \u039ei) ({v(j)})\nthen e(k, i) 6\u2208 F\n\u0393j0\u222a( \u22c3 i\u2208[d] \u039ei)\u222a( \u22c3 i\u2032 6=i \u0393 j i\u2032) ({v(j)}).\nMoreover, this implies that \u0393ji 6= \u2205.\nProof. The symmetry and non interference properties of families of clauses (a), (b), and (c) also justifies the first part of Claim (3). To see it, just notice that were the claim to be false, the prime implicates in \u0393ji\u2032 would be trigging clauses involving the variable e(k, i) in an execution of the Forward Chaining procedure. Since i\u2032 6= i, this cannot happen. The second part follows immediately from the validity of the first part together with the fact that \u03a5 represents h.\nTo finish the first step, notice that since Claim (3) is valid for any i \u2208 [d], Claim (2) implies that if \u0393ji 6= \u2205 for some index i \u2208 [d], then \u0393 j i 6= \u2205 for all indices i \u2208 [d], simultaneously.\nFor the second step, suppose that \u0393ji 6= \u2205 for all indices i \u2208 [d]. We then have that\n\u03b3 := \u2211\ni\u2208[d]\n|\u0393ji | \u2265 d = 1 + r\u03bb+ s\u03bb \u2032 = 1 + |L \u222a L\u2032|,\nthat is, \u03b3 is strictly larger than the number of all available labels in L. This implies that the following pure Horn CNF\n\u2206j :=\n(\n\u03a5 \\ \u22c3 i\u2208d \u0393ji\n)\n\u222a { v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L\u2032 }\n= \u0398 \u222a\n((\n\u0393 \\ \u22c3 i\u2208d \u0393ji\n)\n\u222a { v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L\u2032 }\n)\n,\nhas fewer clauses than \u03a5 (or more precisely, it implies that |\u2206j |c <= |\u03a5|c \u2212 1).\nNow, since that \u0398 is a (clause minimum) representation of the exclusive component g, and that the set of clauses {v(j) \u2212\u2192 u(\u2113) : \u2113 \u2208 L \u222a L\u2032} makes all available labels reachable by Forward Chaining from {v(j)}, it follows that F\u2206j({v(j)}) = Vg\u222a{v(j)}. Furthermore, the change in clauses did not influence the Forward Chaining procedure from any other variable (other than v(j)), and thus F\u2206j ({w}) = F\u03a5({w}) for all variables w 6= v(j). Thus, an analogue of Lemma 25 implies that \u2206j is a representation of h.\nWe then have that \u2206j is a shorter representation for h, contradicting the optimality of \u03a5. Therefore, the sets \u0393ji = \u2205 for all indices i \u2208 [d]. As the above arguments do not depend on any particular value of j, they can be repeated for all of them.\nDefinition 42. Let d = 1 + r\u03bb + s\u03bb\u2032 and let \u03a5 be a prime and irredundant pure Horn 3-CNF representation of h. For each j \u2208 [t], consider the set\nSj = { \u2113 \u2208 L \u222a L\u2032 : v(j) \u2212\u2192 u(\u2113) \u2208 \u03a5 }\nand define the function fj : X \u2192 L, Y \u2192 L \u2032 given by fj(x) = Sj \u2229 Lx for vertices x \u2208 X and fj(y) = Sj \u2229 L \u2032 y for vertices y \u2208 Y .\nLemma 43 (Analogue of Lemma 29). Let \u03a5 be as in the above Definition. For all indices j \u2208 [t] and vertices y \u2208 Y , it holds that |fj(y)| \u2264 1.\nProof. Let \u03a5 be as in Definition 42 and suppose indirectly that the claim is false, that is, there is an index j \u2208 [t] and a vertex y \u2208 Y such that |fj(y)| > 1.\nDuring the proof, recall that the chosen value for the parameter d implies, according to Lemma 41, that all prime implicates of \u03a5 involving the variable v(j) must have the form v(j) \u2212\u2192 u(\u2113), with \u2113 \u2208 L \u222a L\u2032.\nLet \u2113\u2032 \u2208 fj(y) and define the expression\n\u03a5\u2032 := \u03a5 \\ {v(j) \u2212\u2192 u(\u2113\u2032)}.\nIt is enough to show that F\u03a5\u2032({v(j)}) = Vg \u222a {v(j)}, that is, that \u03a5 \u2032 is also a representation of h (by an analogue of Lemma 25). Suppose that is not the case. Since \u03a5 and \u03a5\u2032 differ only in the clause v(j) \u2212\u2192 u(\u2113\u2032), it must be the case that u(\u2113\u2032) 6\u2208 F\u03a5\u2032({v(j)}). This happens if the clause of type (d2) associated to u(\u2113\n\u2032) is not trigged. For this to occur, there must be an index k \u2208 [2m\u2212 1] and an index i \u2208 [d] such that e(k, i) 6\u2208 F\u03a5\u2032({v(j)}).\nNow, for y and i as above, notice that: (i) the variable e(k, i) would be included in F\u03a5\u2032({v(j)}) as long as there were a label in L\u2032y such that the corresponding clause of type (b1) or clauses of types (b2), (b3), and (b4) were trigged; and (ii) once such clauses of type (b1)\u2013(b4) were trigged, the appropriated clauses of type (c) would trigger, thus making the other clauses of type (b1)\u2013(b4) associated to y and i to also trigger.\nTherefore, for e(k, i) = e(x, y, i) to not belong to F\u03a5\u2032({v(j)}), it must be the case that for every label \u2113\u2032\u2032 \u2208 fj(y) \\ {\u2113 \u2032} there exists a vertex z(\u2113\u2032\u2032) \u2208 N(y) for which\ne(z(\u2113\u2032\u2032), y, \u2113\u2032\u2032, i) 6\u2208 F\u03a5\u2032({v(j)}).\nFor this latter relation to be true, we must have that the clauses\nu(\u2113) \u2227 u(\u2113\u2032\u2032) \u2212\u2192 e(z(\u2113\u2032\u2032), y, \u2113\u2032\u2032, i) (5)\nare not trigged in the Forward Chaining procedure on \u03a5\u2032 starting with {v(j)}, for every label \u2113 \u2208 fj(z(\u2113 \u2032\u2032)) with (\u2113, \u2113\u2032\u2032) \u2208 \u03a0(z(\u2113\u2032\u2032),y).\nHowever, according to Definition 42, for each label \u2113\u2032\u2032 \u2208 fj(y)\\{\u2113 \u2032} and each label \u2113 \u2208 fj(z(\u2113 \u2032\u2032)), there are clauses v(j) \u2212\u2192 u(\u2113\u2032\u2032) and v(j) \u2212\u2192 u(\u2113), respectively, in \u03a5 and, consequently, in \u03a5\u2032. This implies that the clauses (5) are trigged, which implies that u(\u2113\u2032) \u2208 F\u03a5\u2032({v(j)}), which then implies that \u03a5\u2032 is also a representation of h. Since this contradicts the irredundancy of \u03a5, it follows that |fj(y)| \u2264 1, thus concluding the proof.\nLemma 44 (Analogue of Lemma 30). Let \u03a5 be a clause minimum prime pure Horn 3-CNF of h. Then it is prime and irredundant, so Definition 42 applies. We claim that for all indices j \u2208 [t] and vertices y \u2208 Y , it holds that |fj(y)| \u2265 1.\nProof. Suppose that the claim is false, that is, there is an index j \u2208 [t] and a vertex y \u2208 Y such that |fj(y)| = 0.\nThen clauses v(j) \u2212\u2192 u(\u2113\u2032), for all labels \u2113\u2032 \u2208 L\u2032y, are absent from \u03a5. Recall that the chosen value for the parameter d implies that all prime implicates of \u03a5 involving v(j) are quadratic (Lemma 41).\nThus, no clause of type (a) dependent on the vertex y is trigged during a Forward Chaining from {v(j)} and hence, no clauses of type (b1), (b2), (b3), (b4), and (c) dependent on y are trigged either. This gives that the variables e(k, i), for all indices k \u2208 {m,m + 1, . . . , 2m \u2212 1} such that ek\u2212m+1 = (x, y) (recall the indexing of the edges in E) and x \u2208 N(y), and all indices i \u2208 [d], do not belong to the Forward Chaining closure (from {v(j)}). This implies further that no variables e(1, i) belong to the Forward Chaining closure. Therefore, no clause of type (d2) is trigged and no label \u2113\u2032 \u2208 L\u2032y is reintroduced. In other words, it is the case that u(\u2113\n\u2032) 6\u2208 F\u03a5({v(j)}) and hence, that F\u03a5({v(j)}) 6= Fh({v(j)}). By an analogue of Lemma 25, \u03a5 does not represent h, a contradiction. So, it must be the case that |fj(y)| \u2265 1.\nOnce again, combining the two lemmas above, gives the following tight result.\nCorollary 45. Let \u03a5 be a clause minimum prime pure Horn 3-CNF of h. Then, for all indices j \u2208 [t] and vertices y \u2208 Y , it holds that |fj(y)| = 1.\nAnalogues of Lemmas 32, 33, and 34 can also be obtained in the same semi-verbatim fashion, and Remark 35 remains valid in this context. Hence, we still obtain the following.\nCorollary 46. Let \u03a8 be as in Definitions 38 and \u03a5 be a clause minimum prime pure Horn 3-CNF of h. It holds that\n|\u03a8|c/(\u03bb+ \u03bb \u2032) \u2264 |\u03a5|c \u2212 t(\u03ba(f)r + s) \u2264 |\u03a8|c,\nwhere \u03ba(f)r + s is the total number of labels in a tight optimal total-cover f for L.\nWe are also able to claim the following result.\nTheorem 47. Let c be a fixed constant close to 1/2. Unless P = NP, the minimum number of clauses of a pure Horn function on n variables cannot be approximated in polynomial time (dependent on n) to within a factor of\n\u03c1c(n \u03b5) \u2265 2\u03b5(logn) 1\u22121/\u03b4c(n) = 2log 1\u2212o(1) n,\nwhere \u03b4c(n) = (log log n) c, even when the input is restricted to 3-CNFs with O(n1+2\u03b5) clauses, for some \u03b5 \u2208 (0, 1/6].\nProof. The proof follows closely the one given for Theorem 37, just using the estimates provided by Lemma 39 instead of the ones in Lemma 22."}, {"heading": "5.2 Number of Literals", "text": "With the exception of the variables v(j), with j \u2208 [t], that only appear as subgoals in quadratic prime implicates, every other variable appears in subgoals and heads of mostly cubic pure Horn clauses. The functions we are dealing with are pure Horn and therefore, have no unit clauses. So, it is the case that 2|\u03a6|c \u2264 |\u03a6|l \u2264 3|\u03a6|c or in other words, that |\u03a6|l = \u0398(|\u03a6|c), where \u03a6 is a pure Horn 3-CNF formula obtained from our 3-CNF construction above. We then have the following result.\nCorollary 48. Unless P = NP, the minimum number of literals of a pure Horn function on n variables cannot be approximated in polynomial time (in n) to within a factor of 2log 1\u2212o(1) n, even when the input is restricted to 3-CNFs with O(n1+2\u03b5) clauses, for some \u03b5 \u2208 (0, 1/6]."}, {"heading": "6 Sub-exponential Time Hardness Results", "text": "The hardness of approximation results of Sections 4 and 5 apply to the scenario where the amount of available computational power is polynomial in n, the number of variables of a pure Horn function. In this section, we extend those results by showing that even when the computational power available is sub-exponential in n, it still not likely to be able to obtain a constant factor approximation for such problems. The main ingredients of this section are: a stronger complexity theoretic hypothesis, a new Label-Cover result, and our pure Horn 3-CNF construction.\nRecall that k-SAT is the problem of determining if a k-CNF formula, that is, one in which each and every clause has at most k literals, has a satisfying assignment of Boolean values to it variables. The following conjecture, called Exponential Time Hypothesis (ETH), concerns the time solvability of the k-SAT problem and was introduced by Impagliazzo and Paturi [22].\nConjecture 49 (Impagliazzo and Paturi [22]). For k \u2265 3, define sk to be the infimum of the set\n{ \u03b4 : there exists an O ( 2\u03b4n ) time algorithm for solving the k-SAT problem } ,\nwith n being the number of variables of the k-SAT instance. The Exponential Time Hypothesis (ETH) states that sk > 0 for k \u2265 3.\nIn other words, if true, the ETH implies that there is no sub-exponential time algorithm for kSAT with k \u2265 3, what in turn implies that P 6= NP. The converse of this last implication however, does not hold and this establish ETH as a stronger hypothesis. It has many implications beyond search and optimization problems, e.g. in communication, proof, and structural complexity, and it is widely believed to be true.\nIn Section 3, we adressed the minimization flavor of the Label-Cover problem and briefly mentioned the existence of a maximization counterpart. Since the Label-Cover results we shall use in this section were originally obtained in the maximization setting, we introduce it below together with a \u201cweak duality\u201d type of result that binds both flavors.\nDefinition 50. Let L0 = (G,L0, L \u2032 0,\u03a00) be a Label-Cover instance and f0 be a labeling for it, as in Definitions 10 and 11, respectively. Let us call f0 packing if it assigns exactly one label per vertex of G. A packing labeling is optimal if it maximizes the fraction of covered edges of G. We denote this maximum fraction by \u00b5(L0).\nNotice that differently from a total-cover, a packing labeling does not necessarily covers all the edges of the graph G and thus, 0 < \u00b5(L0) \u2264 1. The strict lower bound is due to non-empty relations of admissible pair of labels in \u03a00 \u2014 in the maximization setting, these relations are also called projections as they can be interpreted (or redefined) as mappings L0 7\u2212\u2192 L \u2032 0.\nIn this section, we shall assume that the connected bipartite graph G = (X,Y,E) is regular, that is, each vertex x \u2208 X has degree dX \u2265 1 and each vertex y \u2208 Y has degree dY \u2265 1. This assumption is without loss of generality since Label-Cover instances can be regularized without significantly altering their sizes and promises (cf. Dinur and Harsha [14]). Moreover, the instances occurring in the hardness theorem we shall use in this section are regular.\nProblem 51. Let 0 < \u03be \u2264 1 be any fixed constant. A Label-Cover instance L0 has packingpromise \u03be if either \u00b5(L0) = 1 or \u00b5(L0) \u2264 \u03be. That is, either all edges of L0 can be covered or at most a \u03be fraction of them can. The Label-Cover-Max\u03be problem is a promise problem which receives a Label-Cover instance with packing-promise \u03be as input and correctly classify it in one of those two cases.\nThe behavior of Label-Cover-Max\u03be is left unspecified for non-promise instances and any answer is acceptable in that case. As before, the definitions above can be easily extended to refined Label-Cover instances.\nThe following result appears in Arora and Lund [3] and provides a link between the two flavors of the Label-Cover problem. In a nutshell, it implies that gap producing reductions from NP-complete problems like 3-SAT to the maximization flavor can be viewed as reductions to the minimization flavor as well. Hence, hardness of approximation results can be transfered from one flavor to the other. We decided to include its proof below for clarity reasons.\nLemma 52 (Arora and Lund [3]). \u201cWeak Duality:\u201d for any (refined) Label-Cover instance L, we have that\n\u00b5(L) \u2265 1\n\u03ba(L) .\nThat is, the reciprocal of the value of an optimal packing labeling lower bounds the cost of an optimal (tight) total-cover. Furthermore, if L has packing-promise \u03be, then it has covering-promise \u03c1 \u2265 1/\u03be.\nProof. Let f be an optimal total-cover for L of cost \u03ba(L). That is, f covers all the edges of the graph G = (X,Y,E) assigning |f(z)| labels to each vertex of z \u2208 X \u222aY . For simplicity reasons and without loss of generality, suppose that f is tight. Recall that by definition, \u03ba(L) is the average number of labels assigned by f to the vertices in X, namely,\n\u2211 x\u2208X |f(x)| = \u03ba(L) \u00b7 |X|. (6)\nConsider the following randomized procedure: for each vertex x \u2208 X, pick a label at random in f(x) and delete the remaining ones. Let f \u2032 be the resulting labeling. As |f \u2032(z)| = 1 for all vertices z \u2208 X \u222aY , f \u2032 is a packing labeling for L and the expected fraction of edges covered in f \u2032 is a lower bound for \u00b5(L).\nLet \u2113 \u2208 f(x) be a label used in f to cover an edge (x, y). The probability that \u2113 \u2208 f \u2032(x), namely, that it survived the deletion process and ended up in f \u2032 is 1/|f(x)|. The expected number of edges of G still covered in f \u2032 is then at least\n\u2211\n(x,y)\u2208E\n1\n|f(x)| = \u2211\nx\u2208X\ndX |f(x)| \u2265 dX |X|2 \u2211\nx\u2208X |f(x)|\n= dX |X|2\n\u03ba(L) \u00b7 |X| =\n|E|\n\u03ba(L) , (7)\nwhere in the first and last equalities, we used the assumption that G is regular and thus, has |E| = dX \u00b7 |X| edges; in the inequality, we used the fact that \u2211\nx 1/|f(x)| is minimized when the values |f(x)| are all equal; and in the second to last equality we used Equation (6).\nThe above randomized procedure thus gives a packing labeling whose expected fraction of edges covered is at least 1/\u03ba(L). So, there must exist a packing labeling attaining at least this fraction of edges covered and therefore, \u00b5(L) \u2265 1/\u03ba(L) as claimed. The relation on the promise bounds follows in a similar way from Equation (7).\nMoshkovitz and Raz [27], in a celebrated breakthrough, introduced a new two-query projection test Probabilistically Checkable Proof system with sub-constant error and quasi-linear size. Essentially, they started with a 3-SAT CNF instance \u03c6 of size (number of clauses) equal to \u03c3 and showed that it is NP-hard to solve Label-Cover-Max1/\u03c1, for some \u03c1 = \u03c1(\u03c3). Moreover, their reduction produces a graph of size at most \u03c31+o(1) and uses fixed label sets L and L\u2032 whose sizes depend on the value of the promise \u03c1. A simpler proof was later found by Dinur and Harsha [14] who started their reduction from a related but slightly different problem (satisfiability of circuits instead of formulas), brought different techniques to the mix, and formally stated the result as follows.\nTheorem 53 (Moshkovitz and Raz [27], Dinur and Harsha [14]). There exist constants c > 0 and 0 < \u03b2 < 1 such that for every function 1 < \u03c1(\u03c3) \u2264 2O(log \u03b2 \u03c3), the following statement holds:\nThere exists label sets L and L\u2032 of sizes exp(\u03c1(\u03c3)c) and O(\u03c1(\u03c3)c), respectively, such that it is NPhard to solve Label-Cover-Max1/\u03c1(\u03c3) over these label sets. Furthermore, the size of the constraint graph of the Label-Cover instance produced by this reduction is at most \u03c3 \u00b7 2O(log \u03b2 \u03c3) \u00b7 (\u03c1(\u03c3))c = \u03c31+o(1).\nNotice that differently to what happens in the reduction of Theorem 17 where the label sets are instance dependent, in the above theorem the label sets are fixed and their sizes depend on\nthe promise value (also called soundness value in this context). Also, the size of label set L is polynomial if 1 < \u03c1(\u03c3) \u2264 polylog(\u03c3) and super-polynomial if polylog(\u03c3) < \u03c1(\u03c3) \u2264 2O(log \u03b2 \u03c3). It is worth mentioning that these differences do not affect our constructions (as they scale up appropriately), but do require changes in the calculations when showing our hardness results.\nUsing Lemma 52, we can apply the above hardness result to the minimization flavor of the Label-Cover problem with promise \u03c1(\u03c3). While the resulting hardness factor is smaller than the one given by Dinur and Safra [15] in Theorem 17, the quasi-linear size of the constraint graph (and hence of the instance, as the label sets are fixed) allows the following:\nCorollary 54 (Moshkovitz and Raz [27]). Assuming the Exponential Time Hypothesis (cf. Conjecture 49, i.e., 3-SAT requires exp(\u2126(\u03c3)) time to be solved), quasi-polynomially sized instances of Label-Cover-Max1/\u03c1(\u03c3) and of Label-Cover\u03c1(\u03c3) cannot be solved in less than exp ( \u03c31\u2212o(1) ) time.\nThis can be used to rule out better approximations in sub-exponential time for other problems by further reductions from the Label-Cover problem.\nRemark 55. The new hardness result above brings along a new parametrization, which is slightly different from the one given in Remark 18. We now have that: s = \u03c31+o(1) with o(1) \u2248 (log log \u03c3)\u2212\u2126(1), r = \u03c32O(log \u03b2 \u03c3) = \u03c31+o(1), m = r\u03c1(\u03c3)c = \u03c31+o(1), \u03bb = O ( 2\u03c1(\u03c3) c) , and \u03bb\u2032 = O(\u03c1(\u03c3)c).\nLet \u03d1 > 0 be such that c\u03d1 \u2264 1 and take \u03c1(\u03c3) = log\u03d1 \u03c3. We then have that\n\u03bb = O ( 2(log \u03d1 \u03c3)c ) = O(\u03c3) and \u03bb\u2032 = O ( (log\u03d1 \u03c3)c ) = O(log \u03c3),\nand since m \u2264 \u03c0 \u2264 m\u03bb\u03bb\u2032, we also have that\n2O(log \u03b2 \u03c3)\u03c3 logc\u03d1 \u03c3 \u2264 \u03c0 = O\n(\n2O(log \u03b2 \u03c3)\u03c32 log2 \u03c3\n)\n.\nFurthermore, it follows that\nd = 1 + r\u03bb+ s\u03bb\u2032 = \u0398 ( 2O(log \u03b2 \u03c3)\u03c32 + \u03c31+o(1) logc\u03d1 \u03c3 ) . (8)\nCombining all the above, we obtain that as long as the (gap) amplification device t is polynomial in the number of variables of the canonical pure Horn 3-CNF \u03a6, the construction of \u03a6 can still be carried out in polynomial time in this setting.\nWe are now ready to show a hardness of approximation result for the case when sub-exponential time is allowed. The proof closely follows the one presented for the polynomial time setting.\nTheorem 56. Assuming the ETH, the minimum number of clauses and literals of pure Horn functions in n variables cannot be approximated in exp(n\u03b4) time, for some \u03b4 \u2208 (0, 1), to within factors of O(log\u03d1 n) for some \u03d1 > 0, even when the input is restricted to 3-CNFs with O(n1+\u03b5) clauses and \u03b5 > 0 some small constant.\nProof. Let L0 be a Label-Cover promise instances in compliance to Theorem 53 and let L be its refinement. Let d be as in Equation (8), \u03a6 be the canonical pure Horn 3-CNF formula constructed from L, and h be the pure Horn function it defines. Let \u03a5 be a pure Horn 3-CNF representation of h obtained by some exact clause minimization algorithm when \u03a6 is given as input.\nFor convenience, let \u03c1 = \u03c1(\u03c3) and \u03b6 = \u03b6(\u03c3) = r/s = 2O(log \u03b2 \u03c3)/\u03c3o(1) and recall Notation 15. Substituting the quantities established in Lemma 39 into the bounds given by Corollary 46 and using and the new parametrization above (cf. Remark 55), we obtain that\n|\u03a5|c \u2265 t(\u03ba(f)r + s) + d(\u03c0 + 2m\u03bb\u2032 + 2m\u2212 1)\u2212 1\n\u03bb+ \u03bb\u2032\n\u2265 st(\u03ba(f)r/s+ 1) + \u2126 ( \u03c31+o(1)2log \u03c4 \u03c3 log2c\u03d1 \u03c3 )\n\u2265 st(\u03ba(f)\u03b6 + 1) + \u03c9(s),\nand\n|\u03a5|c \u2264 t(\u03ba(f)r + s) + d(\u03c0 +m 2\u03bb\u2032 + 4m)\n\u2264 st(\u03ba(f)r/s+ 1) +O ( \u03c342log \u03c4 \u03c3 log3 \u03c3 )\n\u2264 st(\u03ba(f)\u03b6 + 1) + o(s5),\nwhere \u03c4 > 0 is some constant. Similarly, for the number of variables we have that\nt \u2264 |\u03a5|v \u2264 t+ dm(\u03bb \u2032 + 2) +m2\u03bb\u2032\n\u2264 t+O ( \u03c322log 2\u03c4 \u03c3 log2 \u03c3 )\n\u2264 t+ o(s3).\nNow, choosing \u03b5\u2032 > 0 such that t = s1/\u03b5 \u2032 = \u2126(s4) and supposing that s \u2212\u2192 \u221e, we obtain the\nasymptotic expressions\n|\u03a5|c = s (1+1/\u03b5\u2032)\u03b6(\u03c3)\u03ba(f)(1 + o(1)) and |\u03a5|v = s 1/\u03b5\u2032(1 + o(1)).\nBringing the existing gaps of the Label-Cover promise instances into play, we then obtain the following dichotomy\n\u03ba(L) = 1 =\u21d2 |\u03a5|c \u2264 s (1+1/\u03b5\u2032)\u03b6(\u03c3)(1 + o(1)),\n\u03ba(L) \u2265 \u03c1(\u03c3) =\u21d2 |\u03a5|c \u2265 s (1+1/\u03b5\u2032)\u03b6(\u03c3)\u03c1(\u03c3)(1 + o(1)),\nwith \u03c1(\u03c3) = log\u03d1 \u03c3 in this case. Let n = |\u03a5|v and let \u03b5 = \u03b5 \u2032/(1 + o(1)). Relating the number of clauses of \u03a5 to the number of variables of h, the above dichotomy reads as\n\u03ba(L) = 1 =\u21d2 |\u03a5|c \u2264 n (1+\u03b5\u2032)\u03b6(n\u03b5)(1 + o(1)),\n\u03ba(L) \u2265 \u03c1(\u03c3) =\u21d2 |\u03a5|c \u2265 n (1+\u03b5\u2032)\u03b6(n\u03b5)\u03c1(n\u03b5)(1 + o(1)),\ngiving a hardness of approximation factor of \u03c1(n\u03b5) for the pure Horn 3-CNF clause minimization problem (cf. Theorem 53). As \u03b5\u03d1 is a constant, it follows that the gap\n\u03c1(n\u03b5) = log\u03d1 n\u01eb = O(log\u03d1 n).\nAlso, the number of clauses n(1+\u03b5 \u2032)\u03b6(n\u03b5) \u2264 n1+2\u03b5 \u2032 .\nTo conclude the clause minimization part, observe that sub-exponential time in \u03c3, namely,\n2o(\u03c3) is equivalent to 2o ( n1/4\u2212o(1) ) time in n and since |\u03a5|c = O(n 1+2\u03b5\u2032), the time bound follows for \u03b4 < (1\u2212 2\u03b5\u2032)/4.\nRegarding literal minimization, the structure of \u03a6 implies its numbers of clauses and literals differ by only a constant (cf. Section 5) and therefore, similar results hold in this case as well.\nA natural next step consists in trying to push the hardness of approximation factor further by allowing super-polynomially sized constructions, that is, canonical formulae \u03a6 whose number of clauses is super-polynomial in \u03c3.\nSo let b > 1 be such that \u03b1 = bc > 1 and take \u03c1(\u03c3) = log\u03b1 \u03c3. We then have that\n\u03bb = O ( 2log \u03b1 \u03c3 ) = O ( \u03c3log \u03b1\u22121 \u03c3 )\nand \u03bb\u2032 = O(log\u03b1 \u03c3).\nAlso, we have that\n\u03c0 = O ( 2log \u03b1 \u03c3+O(log\u03b2 \u03c3)\u03c3 log\u03b1 \u03c3 ) ,\nand that we should choose the value of the parameter d such that\nd = \u0398 ( \u03c32log \u03b1 \u03c3+O(log\u03b2 \u03c3) ) .\nNotice the above values imply that \u03a6 is now super-polynomially sized in \u03c3.\nFollowing the steps of the proof of Theorem 56, we obtain that\n\u03c9(s2) \u2264 |\u03a5\u2032|c \u2212 t(\u03ba(f)r + s) \u2264 o ( \u03c34+log \u03b1\u22121 \u03c3 )\nand that t \u2264 |\u03a5\u2032|v \u2264 t+ o ( \u03c33+log \u03b1\u22121 \u03c3 ) .\nNow, choosing t = (8\u03c3)log \u03b1\u22121 8\u03c3 gives a hardness of approximation factor for pure Horn clause minimization equal to \u03c1(\u03c3). Writing \u03c3 as a function of n, we obtain that \u03c3 = (2log 1/\u03b1 n)/8 and hence, a hardness of approximation factor\n\u03c1(n) = log\u03b1\n( 2 \u03b1 \u221a logn\n8\n)\n= ( \u03b1 \u221a log n\u2212 3 )\u03b1 = O(log n).\nAs |\u03a5\u2032|c = O(n 2), sub-exponential time 2o(\u03c3) means\n\u00b5(n) := 2 o\n( (2 \u03b1\u221alog n/8) 1/2 )\n= o\n(\n2n 1/(log log n)C\n)\ntime, for any (possibly large) constant C \u2265 1. We then just proved the following theorem.\nTheorem 57. Assuming the ETH, the minimum number of clauses and literals of pure Horn functions in n variables cannot be approximated in \u00b5(n) time to within factors of O(log n), even when the input is restricted to 3-CNFs with O(n2) clauses.\nPushing the approach further, if we take \u03c1(\u03c3) = 2O(log \u03b2 \u03c3) for some 0 < \u03b2 < 1, we have that\n\u03bb = 22 O(log\u03b2 \u03c3)\nand \u03bb\u2032 = 2O(log \u03b2 \u03c3),\nthat m = \u03c32O(log \u03b2 \u03c3), and that\n\u03c0 = d = \u03c32O(log \u03b2 \u03c3)22 O(log\u03b2 \u03c3) ,\nimplying that \u03a6 is now sub-exponentially sized in \u03c3. We then have that\n\u2126 ( 22 O(log\u03b2 \u03c3) ) \u2264 |\u03a5\u2032|c \u2212 t(\u03ba(f)r + s)\n\u03c32 \u2264 O\n( \u03c322 O(log\u03b2 \u03c3) )\nand that\nt \u2264 |\u03a5\u2032|v \u2264 t+O ( \u03c3222 O(log\u03b2 \u03c3) ) .\nNow, letting n := |\u03a5\u2032|v = t = 2 21+\u03b3 log \u03b2 \u03c3 , for some constant \u03b3, it gives\n\u03c3 = 2\n(\n1 \u03b3 log log n 2\n)1/\u03b2\nand a hardness of approximation factor \u03c1(n) = (log n)/2, i.e., a similar O(log n) hardness factor under far more stringent time constraints. This last result is then rendered obsolete by Theorems 47 and 57."}, {"heading": "7 Conclusion", "text": "In the last three sections, we showed improved hardness of approximation results for the problems of determining the minimum number of clauses and the minimum number of literals in prime pure Horn CNF and 3-CNF representations of pure Horn functions. In the polynomial time setting, we obtained a hardness of approximation factor of 2log 1\u2212o(1) n and when sub-exponential computational time is available, we showed a factor of O(log\u03b2 n), where \u03b2 > 0 is some small constant and n is the number of variables of the pure Horn function. All these results hold even when the input CNF or 3-CNF formula is nearly linear, namely, when its size is O(n1+\u03b5) for some small constant \u03b5 > 0. We also managed to obtain a factor of O(log n) under more stringent, albeit sub-exponential, time constraints even when the input formula has size O(n2). In the polynomial time setting, our results are conditional on the P 6= NP hypothesis, and are conditional on the Exponential Time Hypothesis (ETH) in the sub-exponential time scenario.\nA natural question at this point concerns the tightness of our results. As mentioned in the introduction, Hammer and Kogan [21] showed that for a pure Horn function in n variables, it is possible to approximate the minimum number of clauses and the minimum number of literals of a prime pure Horn CNF formula representing it to within factors of n\u2212 1 and\n(n 2 ) , respectively.\nOur results then leave a sub-exponential gap in the polynomial time setting, and we are not aware of the existence of any sub-exponential time approximation algorithm for those problems. Naturally, narrowing or closing these gaps is highly desirable. One direction consists in designing new approximation algorithms with improved approximation guarantees. This does not seem to be an easy task to accomplish, nevertheless.\nAnother direction consists in further strengthening our hardness results. Replacing our constructions by smaller (e.g. quasi-linear) ones will allow us to extend our sub-exponential hardness result to the scenario where exp(o(n)) computational time is available \u2014 recall that our result is valid for exp(n\u03b4) time, for some constant 0 < \u03b4 < 1, and that we conjecture that no constant approximation factor is possible in the exp(o(n)) time scenario. Besides barely improving the constants in our polynomial time proofs, we believe this option has little, if anything else, to offer.\nImprovements on two-query projection test, sub-constant error Probabilistically Checkable Proof (PCP) systems (cf. Arora and Safra [5], Dinur and Safra [15], Moshkovitz and Raz [27], and Dinur and Harsha [14]) might lead to larger gaps for the Label-Cover (as a promise) problem, and as long as the Label-Cover instances are polynomially sized, our constructions would immediately imply larger hardness of approximation results for those problem. Moreover, improvements on Label-Cover might also allow one to obtain hardness results when super-polynomial time is allowed, a case we left untreated.\nAs a third possibility, notice that it might be possible to start from a different (promise) problem and provide different constructions and different proofs. At the moment, it is not clear how to pursue this venue. However, we conjecture that it is possible to improve the hardness of approximation factor for clause and literal minimization of a Horn function in n variables to at least O(n\u03b5), for some small \u03b5 > 0. This conjecture concerns the polynomial time setting. In favor of it, we point out the fact that Umans [28] showed that for general Boolean functions, the decision versions of clause and literal minimization problems are \u03a3p2-complete (namely, NP\nNP-complete) and that it is \u03a3p2-hard to approximate such quantities to within factors of N\n\u03b5, where N is the size of the input (a low-degree polynomial in the number of variables of the function in question) and \u03b5 > 0 is some small constant.\nAcknowledgements. We would like to thank O. C\u030cepek and P. Kuc\u030cera for some discussions held during an early stage of development of these results, and three anonymous referees for suggestions that improved the overall readability of this paper."}], "references": [{"title": "Computational Complexity: A modern approach", "author": ["S. Arora", "B. Barak"], "venue": "xxiv+579", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "The hardness of approximate optima in lattices, codes, and systems of linear equations", "author": ["S. Arora", "L. Babai", "J. Stern", "Z. Sweedyk"], "venue": "J. Comput. System Sci. 54(2,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1997}, {"title": "Hardness of approximations. in Approximation Algorithms for NP-Hard", "author": ["S. Arora", "C. Lund"], "venue": "ed., PWS Publishing,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1996}, {"title": "Proof verification and the hardness of approximation problems", "author": ["S. Arora", "C. Lund", "R. Motwani", "M. Sudan", "M. Szegedy"], "venue": "J. ACM 45(3),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1998}, {"title": "Probabilistic checking of proofs: a new characterization of NP", "author": ["S. Arora", "S. Safra"], "venue": "J. ACM 45(1),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1998}, {"title": "Minimal representation of directed hypergraphs", "author": ["G. Ausiello", "A. D\u2019Atri", "D. Sacc\u00e0"], "venue": "SIAM J. Comput. 15(2),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1986}, {"title": "On approximate Horn formula minimization", "author": ["A. Bhattacharya", "B. DasGupta", "D. Mubayi", "G. Tur\u00e1n"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "A decomposition method for CNF minimality proofs", "author": ["E. Boros", "O. \u010cepek", "P. Ku\u010dera"], "venue": "Theor. Comput. Sci", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Exclusive and essential sets of implicates of Boolean functions", "author": ["E. Boros", "O. \u010cepek", "A. Kogan", "P. Ku\u010dera"], "venue": "Discrete Appl. Math. 158(2),", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2010}, {"title": "Hardness results for approximate pure Horn CNF formulae minimization", "author": ["E. Boros", "A. Gruber"], "venue": "In: International Symposium on Artificial Intelligence and Mathematics (ISAIM", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "The Complexity of Theorem-Proving Procedures", "author": ["S.A. Cook"], "venue": "Proceedings of the 3rd Annual ACM Symposium on Theory of Computing (STOC), May 3-5,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1971}, {"title": "eds.): Boolean Functions: Theory, Algorithms, and Applications, Encyclopedia of Mathematics and its Applications, vol. 142", "author": ["Y. Crama", "P.L. Hammer"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Introduction to algorithms, third edition", "author": ["Cormen", "Thomas H", "Leiserson", "Charles E", "Rivest", "Ronald L", "Stein", "Clifford"], "venue": "pp. xx+1292,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "Composition of low-error 2-query PCPs using decodable PCPs", "author": ["I. Dinur", "P. Harsha"], "venue": "SIAM J. Comput", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2013}, {"title": "On the hardness of approximating label-cover", "author": ["I. Dinur", "S. Safra"], "venue": "Inform. Process. Lett. 89(5),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2004}, {"title": "Linear-time algorithms for testing the satisfiability of propositional Horn formulae", "author": ["W.F. Dowling", "J.H. Gallier"], "venue": "J. Log. Program", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1984}, {"title": "Interactive proofs and the hardness of approximating cliques", "author": ["U. Feige", "S. Goldwasser", "L. Lov\u00e1sz", "S. Safra", "M. Szegedy"], "venue": "J. ACM 43(2),", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1996}, {"title": "Two-prover one-round proof systems: Their power and their problems (extended abstract)", "author": ["U. Feige", "L. Lov\u00e1sz"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1992}, {"title": "Computers and intractability", "author": ["M.R. Garey", "D.S. Johnson"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1979}, {"title": "Horn functions and their DNFs", "author": ["P.L. Hammer", "A. Kogan"], "venue": "Inf. Process. Lett. 44(1),", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1992}, {"title": "Optimal compression of propositional Horn knowledge bases: complexity and approximation", "author": ["P.L. Hammer", "A. Kogan"], "venue": "Artificial Intelligence 64(1),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1993}, {"title": "On the complexity of k-SAT", "author": ["R. Impagliazzo", "R. Paturi"], "venue": "J. Comput. System Sci. 62(2),", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2001}, {"title": "Unification as a complexity measure for logic programming", "author": ["A. Itai", "J.A. Makowsky"], "venue": "J. Log. Program", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1987}, {"title": "On the hardness of approximating spanners", "author": ["G. Kortsarz"], "venue": "Algorithmica 30(3),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2001}, {"title": "Minimum covers in relational database model", "author": ["D. Maier"], "venue": "J. ACM 27(4),", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1980}, {"title": "Ltur: A simplified linear-time unit resolution algorithm for Horn formulae and computer implementation", "author": ["M. Minoux"], "venue": "Inf. Process. Lett. 29(1),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1988}, {"title": "Two-query PCP with subconstant error", "author": ["D. Moshkovitz", "R. Raz"], "venue": "J. ACM 57(5), Art. 29,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2010}, {"title": "Hardness of approximating  \u03a3p2 minimization problems", "author": ["C. Umans"], "venue": "Annual Symposium on Foundations of Computer Science (New York,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1999}, {"title": "The design of approximation algorithms", "author": ["D.P. Williamson", "D.B. Shmoys"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2011}], "referenceMentions": [{"referenceID": 10, "context": "An example of this claim is found on the satisfiability problem (SAT) of formulae in conjunctive normal form (CNF): while it is one of the most famous NP-complete problems for general Boolean CNFs (Cook [11]; see also: Arora and Barak [1], Garey and Johnson [19]), it can be solved in linear time in the number of variables plus the length of the Horn CNF formula being considered (Dowling and Gallier [16], \u2217To appear in the special issue of the Annals of Mathematics and Artificial Intelligence dedicated to ISAIM2012.", "startOffset": 203, "endOffset": 207}, {"referenceID": 0, "context": "An example of this claim is found on the satisfiability problem (SAT) of formulae in conjunctive normal form (CNF): while it is one of the most famous NP-complete problems for general Boolean CNFs (Cook [11]; see also: Arora and Barak [1], Garey and Johnson [19]), it can be solved in linear time in the number of variables plus the length of the Horn CNF formula being considered (Dowling and Gallier [16], \u2217To appear in the special issue of the Annals of Mathematics and Artificial Intelligence dedicated to ISAIM2012.", "startOffset": 235, "endOffset": 238}, {"referenceID": 18, "context": "An example of this claim is found on the satisfiability problem (SAT) of formulae in conjunctive normal form (CNF): while it is one of the most famous NP-complete problems for general Boolean CNFs (Cook [11]; see also: Arora and Barak [1], Garey and Johnson [19]), it can be solved in linear time in the number of variables plus the length of the Horn CNF formula being considered (Dowling and Gallier [16], \u2217To appear in the special issue of the Annals of Mathematics and Artificial Intelligence dedicated to ISAIM2012.", "startOffset": 258, "endOffset": 262}, {"referenceID": 15, "context": "An example of this claim is found on the satisfiability problem (SAT) of formulae in conjunctive normal form (CNF): while it is one of the most famous NP-complete problems for general Boolean CNFs (Cook [11]; see also: Arora and Barak [1], Garey and Johnson [19]), it can be solved in linear time in the number of variables plus the length of the Horn CNF formula being considered (Dowling and Gallier [16], \u2217To appear in the special issue of the Annals of Mathematics and Artificial Intelligence dedicated to ISAIM2012.", "startOffset": 402, "endOffset": 406}, {"referenceID": 22, "context": "Itai and Makowsky [23], and Minoux [26]), where length in this context means the number of literal occurrences in the formula (i.", "startOffset": 18, "endOffset": 22}, {"referenceID": 25, "context": "Itai and Makowsky [23], and Minoux [26]), where length in this context means the number of literal occurrences in the formula (i.", "startOffset": 35, "endOffset": 39}, {"referenceID": 5, "context": "[6].", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8].", "startOffset": 0, "endOffset": 3}, {"referenceID": 24, "context": "The NP-hardness of minimizing the number of literals in Horn CNFs was shown by Maier [25].", "startOffset": 85, "endOffset": 89}, {"referenceID": 20, "context": "A simpler reduction was found later by Hammer and Kogan [21].", "startOffset": 56, "endOffset": 60}, {"referenceID": 7, "context": "[8] showed NP-hardnes for the pure Horn 3-CNFs case.", "startOffset": 0, "endOffset": 3}, {"referenceID": 20, "context": "Hammer and Kogan [21] showed that for a pure Horn function on n variables, it is possible to approximate the minimum number of clauses and the minimum number of literals of a pure Horn CNF formula representing it to within factors of n\u2212 1 and (n 2 )", "startOffset": 17, "endOffset": 21}, {"referenceID": 6, "context": "[7] for the case of minimizing the number of clauses for general Horn CNFs.", "startOffset": 0, "endOffset": 3}, {"referenceID": 24, "context": "Maier [25] and Ausiello et al.", "startOffset": 6, "endOffset": 10}, {"referenceID": 5, "context": "[6] showed that such minimization can be accomplished in polynomial time (see also Crama and Hammer [12]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 11, "context": "[6] showed that such minimization can be accomplished in polynomial time (see also Crama and Hammer [12]).", "startOffset": 100, "endOffset": 104}, {"referenceID": 6, "context": "[7], to try to precisely understand the hardness of the other two measures.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7].", "startOffset": 0, "endOffset": 3}, {"referenceID": 23, "context": "This result is based on a gap-preserving reduction from a fairly well known network design problem introduced by Kortsarz [24], namely, MinRep and has two main components: a gadget that associates to every MinRep instance M a pure Horn CNF formula h such that the size of an optimal solution to M is related to the size of a clause minimum pure Horn CNF representation of h, and a gap amplification device that provides the referred gap.", "startOffset": 122, "endOffset": 126}, {"referenceID": 6, "context": "[7] can be summarized as follows: the hardness of approximation factor we present is stronger, the complexity theoretic assumption we use for polynomial time solvability is weaker, and the class of CNF formulae to which our results apply is smaller.", "startOffset": 0, "endOffset": 3}, {"referenceID": 21, "context": "After that, we show that unless the Exponential Time Hypothesis introduced by Impagliazzo and Paturi [22] is false, it is not possible to approximate the minimum number of clauses and the minimum number of literals of a prime pure Horn 3-CNF representation of h in time exp(n\u03b4), for some \u03b4 \u2208 (0, 1), to within factors of O(log n) for some small constant \u03b2 > 0.", "startOffset": 101, "endOffset": 105}, {"referenceID": 28, "context": "See Vazirani [29] or Williamson and Shmoys [30] for appropriate definitions.", "startOffset": 43, "endOffset": 47}, {"referenceID": 8, "context": "[9]) of the function in question and therefore, can be minimized separately; and a gap amplification device which is used to obtain the hardness of approximation factor.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7].", "startOffset": 0, "endOffset": 3}, {"referenceID": 14, "context": "The hardness of approximation factor comes (after calculations) from a result of Dinur and Safra [15] on the hardness of approximating certain Label-Cover instances.", "startOffset": 97, "endOffset": 101}, {"referenceID": 18, "context": "This is done for two families of high degree clauses and for each family we use a different technique: a linked-list inspired transformation that is used on the classical reduction from SAT to 3-SAT instances (Garey and Johnson [19]), and a complete binary tree type transformation.", "startOffset": 228, "endOffset": 232}, {"referenceID": 6, "context": "[7].", "startOffset": 0, "endOffset": 3}, {"referenceID": 26, "context": "Finally, using newer and slightly different results on the hardness of approximation of certain Label-Cover instances (Moshkovitz and Raz [27], Dinur and Harsha [14]) in conjunction with the Exponential Time Hypothesis [22], we are able to show (also after calculations) that it might not be possible to obtain constant factor approximations for the minimum number of clauses and literals in pure Horn 3-CNF representations.", "startOffset": 138, "endOffset": 142}, {"referenceID": 13, "context": "Finally, using newer and slightly different results on the hardness of approximation of certain Label-Cover instances (Moshkovitz and Raz [27], Dinur and Harsha [14]) in conjunction with the Exponential Time Hypothesis [22], we are able to show (also after calculations) that it might not be possible to obtain constant factor approximations for the minimum number of clauses and literals in pure Horn 3-CNF representations.", "startOffset": 161, "endOffset": 165}, {"referenceID": 21, "context": "Finally, using newer and slightly different results on the hardness of approximation of certain Label-Cover instances (Moshkovitz and Raz [27], Dinur and Harsha [14]) in conjunction with the Exponential Time Hypothesis [22], we are able to show (also after calculations) that it might not be possible to obtain constant factor approximations for the minimum number of clauses and literals in pure Horn 3-CNF representations.", "startOffset": 219, "endOffset": 223}, {"referenceID": 9, "context": "A short conference version of this article appeared in Boros and Gruber [10].", "startOffset": 72, "endOffset": 76}, {"referenceID": 11, "context": "For an almost comprehensive exposition, consult the book on Boolean Functions by Crama and Hammer [12].", "startOffset": 98, "endOffset": 102}, {"referenceID": 19, "context": "Hammer and Kogan [20]) that prime implicates of pure Horn functions are pure Horn clauses.", "startOffset": 17, "endOffset": 21}, {"referenceID": 19, "context": "As Hammer and Kogan [20] pointed out any Horn CNF can be reduced in polynomial time to an equivalent prime and irredundant CNF.", "startOffset": 20, "endOffset": 24}, {"referenceID": 11, "context": "Crama and Hammer [12]) that if C1 and C2 are resolvable implicates of a Boolean function h, then R(C1, C2) is also an implicate of h.", "startOffset": 17, "endOffset": 21}, {"referenceID": 20, "context": "Lemma 5 (Hammer and Kogan [21]).", "startOffset": 26, "endOffset": 30}, {"referenceID": 8, "context": "[9]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8].", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 12, "context": "[13].", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "[2] as a combinatorial abstraction of interactive proof systems (two-prover one-round in Feige et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 16, "context": "[17] and Feige and Lov\u00e1sz [18], and probabilistically checkable in Arora and Motwani [4] and Arora and Safra [5]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[17] and Feige and Lov\u00e1sz [18], and probabilistically checkable in Arora and Motwani [4] and Arora and Safra [5]).", "startOffset": 26, "endOffset": 30}, {"referenceID": 3, "context": "[17] and Feige and Lov\u00e1sz [18], and probabilistically checkable in Arora and Motwani [4] and Arora and Safra [5]).", "startOffset": 85, "endOffset": 88}, {"referenceID": 4, "context": "[17] and Feige and Lov\u00e1sz [18], and probabilistically checkable in Arora and Motwani [4] and Arora and Safra [5]).", "startOffset": 109, "endOffset": 112}, {"referenceID": 2, "context": "Following Arora and Lund [3], a way to guarantee that a Label-Cover instance is feasible is by imposing an extra condition on it, namely, that there is a label l0 \u2208 L \u2032 0 such that for each edge e \u2208 E, there is a label l0 \u2208 L0 with (l0, l \u2032 0) \u2208 \u03a0 0 e.", "startOffset": 25, "endOffset": 28}, {"referenceID": 14, "context": "The above example was adapted from Dinur and Safra [15].", "startOffset": 51, "endOffset": 55}, {"referenceID": 14, "context": "Theorem 17 (Dinur and Safra [15]).", "startOffset": 28, "endOffset": 32}, {"referenceID": 2, "context": "For more information on the Label-Cover problem and its applications, consult the survey by Arora and Lund [3], the article by Moshkovitz and Raz [27], and the book by Arora and Barak [1].", "startOffset": 107, "endOffset": 110}, {"referenceID": 26, "context": "For more information on the Label-Cover problem and its applications, consult the survey by Arora and Lund [3], the article by Moshkovitz and Raz [27], and the book by Arora and Barak [1].", "startOffset": 146, "endOffset": 150}, {"referenceID": 0, "context": "For more information on the Label-Cover problem and its applications, consult the survey by Arora and Lund [3], the article by Moshkovitz and Raz [27], and the book by Arora and Barak [1].", "startOffset": 184, "endOffset": 187}, {"referenceID": 18, "context": "Garey and Johnson [19]), that is, in a linked-list fashion.", "startOffset": 18, "endOffset": 22}, {"referenceID": 12, "context": "[13]) and that the clauses of type (d2) do define the path we mentioned.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "The refined Label-Cover instance will then have 8 labels in total (L = {l1, l 1 2, l 2 1, l 2 2, l 3 1, l 3 2} and L\u2032 = {l1, l \u2032 2}) 2 and our CNF construction will introduce 8\u00d7 9 = 72 clause of type (d), nine of which have the following form e(x1, y, i) \u2227 e(x2, y, i) \u2227 e(x3, y, i) \u2212\u2192 u(l 1 1), as i \u2208 [d] = [9].", "startOffset": 309, "endOffset": 312}, {"referenceID": 3, "context": "i\u2208[4]#(bi) and #(d\u0303) := \u2211", "startOffset": 2, "endOffset": 5}, {"referenceID": 1, "context": "i\u2208[2]#(di), where #(\u03b1) denotes the number of clauses of type (\u03b1) in \u03a6.", "startOffset": 2, "endOffset": 5}, {"referenceID": 21, "context": "The following conjecture, called Exponential Time Hypothesis (ETH), concerns the time solvability of the k-SAT problem and was introduced by Impagliazzo and Paturi [22].", "startOffset": 164, "endOffset": 168}, {"referenceID": 21, "context": "Conjecture 49 (Impagliazzo and Paturi [22]).", "startOffset": 38, "endOffset": 42}, {"referenceID": 13, "context": "Dinur and Harsha [14]).", "startOffset": 17, "endOffset": 21}, {"referenceID": 2, "context": "The following result appears in Arora and Lund [3] and provides a link between the two flavors of the Label-Cover problem.", "startOffset": 47, "endOffset": 50}, {"referenceID": 2, "context": "Lemma 52 (Arora and Lund [3]).", "startOffset": 25, "endOffset": 28}, {"referenceID": 26, "context": "Moshkovitz and Raz [27], in a celebrated breakthrough, introduced a new two-query projection test Probabilistically Checkable Proof system with sub-constant error and quasi-linear size.", "startOffset": 19, "endOffset": 23}, {"referenceID": 13, "context": "A simpler proof was later found by Dinur and Harsha [14] who started their reduction from a related but slightly different problem (satisfiability of circuits instead of formulas), brought different techniques to the mix, and formally stated the result as follows.", "startOffset": 52, "endOffset": 56}, {"referenceID": 26, "context": "Theorem 53 (Moshkovitz and Raz [27], Dinur and Harsha [14]).", "startOffset": 31, "endOffset": 35}, {"referenceID": 13, "context": "Theorem 53 (Moshkovitz and Raz [27], Dinur and Harsha [14]).", "startOffset": 54, "endOffset": 58}, {"referenceID": 14, "context": "While the resulting hardness factor is smaller than the one given by Dinur and Safra [15] in Theorem 17, the quasi-linear size of the constraint graph (and hence of the instance, as the label sets are fixed) allows the following: Corollary 54 (Moshkovitz and Raz [27]).", "startOffset": 85, "endOffset": 89}, {"referenceID": 26, "context": "While the resulting hardness factor is smaller than the one given by Dinur and Safra [15] in Theorem 17, the quasi-linear size of the constraint graph (and hence of the instance, as the label sets are fixed) allows the following: Corollary 54 (Moshkovitz and Raz [27]).", "startOffset": 263, "endOffset": 267}, {"referenceID": 20, "context": "As mentioned in the introduction, Hammer and Kogan [21] showed that for a pure Horn function in n variables, it is possible to approximate the minimum number of clauses and the minimum number of literals of a prime pure Horn CNF formula representing it to within factors of n\u2212 1 and (n 2 )", "startOffset": 51, "endOffset": 55}, {"referenceID": 4, "context": "Arora and Safra [5], Dinur and Safra [15], Moshkovitz and Raz [27], and Dinur and Harsha [14]) might lead to larger gaps for the Label-Cover (as a promise) problem, and as long as the Label-Cover instances are polynomially sized, our constructions would immediately imply larger hardness of approximation results for those problem.", "startOffset": 16, "endOffset": 19}, {"referenceID": 14, "context": "Arora and Safra [5], Dinur and Safra [15], Moshkovitz and Raz [27], and Dinur and Harsha [14]) might lead to larger gaps for the Label-Cover (as a promise) problem, and as long as the Label-Cover instances are polynomially sized, our constructions would immediately imply larger hardness of approximation results for those problem.", "startOffset": 37, "endOffset": 41}, {"referenceID": 26, "context": "Arora and Safra [5], Dinur and Safra [15], Moshkovitz and Raz [27], and Dinur and Harsha [14]) might lead to larger gaps for the Label-Cover (as a promise) problem, and as long as the Label-Cover instances are polynomially sized, our constructions would immediately imply larger hardness of approximation results for those problem.", "startOffset": 62, "endOffset": 66}, {"referenceID": 13, "context": "Arora and Safra [5], Dinur and Safra [15], Moshkovitz and Raz [27], and Dinur and Harsha [14]) might lead to larger gaps for the Label-Cover (as a promise) problem, and as long as the Label-Cover instances are polynomially sized, our constructions would immediately imply larger hardness of approximation results for those problem.", "startOffset": 89, "endOffset": 93}, {"referenceID": 27, "context": "In favor of it, we point out the fact that Umans [28] showed that for general Boolean functions, the decision versions of clause and literal minimization problems are \u03a3p2-complete (namely, NP -complete) and that it is \u03a3p2-hard to approximate such quantities to within factors of N \u03b5, where N is the size of the input (a low-degree polynomial in the number of variables of the function in question) and \u03b5 > 0 is some small constant.", "startOffset": 49, "endOffset": 53}], "year": 2014, "abstractText": "We study the hardness of approximation of clause minimum and literal minimum representations of pure Horn functions in n Boolean variables. We show that unless P = NP, it is not possible to approximate in polynomial time the minimum number of clauses and the minimum number of literals of pure Horn CNF representations to within a factor of 2 1\u2212o(1) n. This is the case even when the inputs are restricted to pure Horn 3-CNFs with O(n) clauses, for some small positive constant \u03b5. Furthermore, we show that even allowing sub-exponential time computation, it is still not possible to obtain constant factor approximations for such problems unless the Exponential Time Hypothesis turns out to be false.", "creator": "LaTeX with hyperref package"}}}