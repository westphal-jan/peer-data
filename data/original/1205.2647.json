{"id": "1205.2647", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-May-2012", "title": "Generating Optimal Plans in Highly-Dynamic Domains", "abstract": "Generating optimal plans in highly dynamic environments is challenging. Plans are predicated on an assumed initial state, but this state can change unexpectedly during plan generation, potentially invalidating the planning effort. In this paper we make three contributions: (1) We propose a novel algorithm for generating optimal plans in settings where frequent, unexpected events interfere with planning. It is able to quickly distinguish relevant from irrelevant state changes, and to update the existing planning search tree if necessary. (2) We argue for a new criterion for evaluating plan adaptation techniques: the relative running time compared to the \"size\" of changes. This is significant since during recovery more changes may occur that need to be recovered from subsequently, and in order for this process of repeated recovery to terminate, recovery time has to converge. (3) We show empirically that our approach can converge and find optimal plans in environments that would ordinarily defy planning due to their high dynamics.", "histories": [["v1", "Wed, 9 May 2012 13:51:50 GMT  (140kb)", "http://arxiv.org/abs/1205.2647v1", "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI2009)"]], "COMMENTS": "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI2009)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["christian fritz", "sheila mcilraith"], "accepted": false, "id": "1205.2647"}, "pdf": {"name": "1205.2647.pdf", "metadata": {"source": "CRF", "title": "Generating Optimal Plans in Highly-Dynamic Domains", "authors": ["Christian Fritz", "Sheila A. McIlraith"], "emails": ["sheila}@cs.toronto.edu"], "sections": [{"heading": null, "text": "Generating optimal plans in highly dynamic environments is challenging. Plans are predicated on an assumed initial state, but this state can change unexpectedly during plan generation, potentially invalidating the planning effort. In this paper we make three contributions: (1) We propose a novel algorithm for generating optimal plans in settings where frequent, unexpected events interfere with planning. It is able to quickly distinguish relevant from irrelevant state changes, and to update the existing planning search tree if necessary. (2) We argue for a new criterion for evaluating plan adaptation techniques: the relative running time compared to the \u201csize\u201d of changes. This is significant since during recovery more changes may occur that need to be recovered from subsequently, and in order for this process of repeated recovery to terminate, recovery time has to converge. (3) We show empirically that our approach can converge and find optimal plans in environments that would ordinarily defy planning due to their high dynamics."}, {"heading": "1 Introduction", "text": "A natural way for an agent to decide how to act is to exploit a policy \u2013 a function that maps each state into an action to be performed. Unfortunately, computing a policy is time intensive, so in many applications an agent plans from a known initial state instead. Unfortunately, when the application is situated within a highly dynamic environment, this initial state may rapidly change in unpredictable ways during planning, possibly invalidating the current planning effort. We argue that neither boldly ignoring such changes nor replanning from scratch is an appealing option. While the former is unlikely to produce a good plan, the latter may never be able to complete a plan when unexpected events keep interrupting. Instead we propose\nan integrated planning and recovery algorithm that explicitly reasons about the relevance and impact of discrepancies between assumed and observed initial state.\nAs a motivating example, consider a soccer playing robot in RoboCup, which, having the ball, deliberates about how to score. In RoboCup it is common to receive sensor readings 10 times per second. The game environment is very dynamic, resulting in frequent discrepancies between assumed and observed initial state. Such discrepancies may or may not affect the current planning process. But how can the robot tell? And how should the robot react when discrepancies are deemed relevant? For instance, assume that at some point during planning, the current most promising plan starts with turning slightly to face the goal and then driving there, pushing the ball. If the ball unexpectedly rolls 10 centimeters away while deliberating, the initial turn action may cause the robot to lose the ball, so this discrepancy is relevant and another plan, starting by re-approaching the ball, should be favored. But if the ball rolls closer, the original plan remains effective and the discrepancy should be ignored and planning continued.\nThe contributions of this paper are three-fold: (1) We propose a novel algorithm for plan generation that monitors the state of the world during planning and recovers from relevant unexpected state changes. The algorithm produces plans that are optimal with respect to the state where execution begins. It is able to distinguish between relevant and irrelevant discrepancies and updates the planning search tree to reflect the new initial state if necessary. This is generally much faster than replanning from scratch, but does not rely on knowledge about a predefined set of potential contingencies: we assume that the system can spontaneously assume any state. This is particularly interesting in continuous domains, where the number of possible discrepancies is infinite. Intuitively, the approach strikes a compromise between complete policies and simple sequential plans and uses relevance information, computed during plan generation, to increase the plan\u2019s robustness. (2) We introduce a new criterion for evaluating plan adaptation algorithms: their relative running time compared to the \u201csize\u201d of the\ndiscrepancy. We argue that this measure is of greater practical significance than either theoretical worst case considerations or the absolute recovery time. In highly dynamic domains unexpected state changes occur during planning as well as during plan adaptation. In order to obtain a plan that is known to be optimal when execution commences, the cycle of planning and recovery has to terminate by a completed recovery before the state changes any further. This is possible when the time for recovery is roughly proportional to the size of the change. Imagine planning takes 10 seconds and recovering from any state changes that occurred during that time takes 8 seconds. If we assume that in 8 seconds on average fewer changes happen than in 10, it seems reasonable to expect that we can recover from those in less than 8 seconds, say on average 6. This continues, until recovery has \u201ccaught up with reality\u201d. We informally call this behavior convergence. Repeated replanning from scratch does not converge, as it does not differentiate between \u201cbig\u201d and \u201csmall\u201d discrepancies. (3) We show empirically that our algorithm converges often even when unexpected state changes occur at relatively high frequency. Particularly \u201con-the-fly\u201d recovery, i.e., recovering immediately upon discrepancy detection, has a higher chance of convergence than the alternative of completing the original planning task first and recovering only afterwards.\nWe explicitly assume that the number and extent of discrepancies is on average proportional to the time interval, i.e., that greater discrepancies are incurred in longer time intervals. This seems reasonable to us and holds for many interesting application domains. This, together with the observation that our algorithm can recover from a few small changes faster than from many large ones, allows our approach to converge. We demonstrate this and the resulting convergence of our approach empirically, on domain simulations which satisfy this assumption. We further understand optimality to be defined in terms of what is currently known, and we want to execute plans only when they are considered optimal at the moment execution begins. Our working assumption is that no model of future exogenous events exists. Hence, we treat the problem as a deterministic planning problem, whose plans and planning process we aim to make robust against potential unexpected changes.\nAfter reviewing some preliminaries in the next section, we describe our approach in Section 3, followed by empirical results and a discussion including related work."}, {"heading": "2 Background", "text": "For the exposition in this paper, we use the situation calculus with a standard notion of arithmetic, but the approach works with any action specification language for which regression can be defined, including STRIPS and ADL.\nThe situation calculus is a logical language for specifying and reasoning about dynamical systems [Reiter, 2001].\nIn the situation calculus, the state of the world is expressed in terms of functions and relations, called fluents (set F), relativized to a situation s, e.g., F (~x, s). A situation is a history of the primitive actions performed from a distinguished initial situation S0. The function do(a, s) maps an action and a situation into a new situation thus inducing a tree of situations rooted in S0. For readability, action and fluent arguments are often suppressed. Also, do(an, do(an\u22121, . . . do(a1, s))) is abbreviated to do([a1, . . . , an], s) or do(~a, s) and we define do([ ], s) = s. In this paper we distinguish between a finite set of agent actions, Aagent, and a possibly infinite set of exogenous actions (or events), Aexog, (A = Aagent \u222a Aexog). The agent can only perform agent actions, and exogenous events can happen at any time, including during planning.\nA basic action theory in the situation calculus, D, comprises four domain-independent foundational axioms, and a set of domain-dependent axioms. Details of the form of these axioms can be found in [Reiter, 2001]. Included in the domain-dependent axioms are the following sets:\nInitial state: a set of first-order sentences relativized to situation S0, specifying what is true in the initial state.\nSuccessor state axioms: provide a parsimonious representation of frame and effect axioms under an assumption of the completeness of the axiomatization. There is one successor state axiom for each fluent, F , of the form F (~x, do(a, s)) \u2261 \u03a6F (~x, a, s), where \u03a6F (~x, a, s) is a formula with free variables among ~x, a, s. \u03a6F (~x, a, s) characterizes the truth value of the fluent F (~x) in the situation do(a, s) in terms of what is true in situation s. These axioms can be automatically generated from effect axioms.\nAction precondition axioms: specify the conditions under which an action is possible. There is one axiom for each a \u2208 Aagent of the form Poss(a(~x), s) \u2261 \u03a0a(~x, s) where \u03a0a(~x, s) is a formula with free variables among ~x, s. We assume exogenous events e \u2208 Aexog are always possible.\nRegression The regression of a formula \u03c8 through an action a is a formula \u03c8\u2032 that holds prior to a being performed if and only if \u03c8 holds after a is performed. In the situation calculus, one step regression is defined inductively using the successor state axiom for a fluent F (~x) as above [Reiter, 2001]:\nRegr[F (~x, do(a, s))] = \u03a6F (~x, a, s)\nRegr[\u00ac\u03c8] = \u00acRegr[\u03c8]\nRegr[\u03c81 \u2227 \u03c82] = Regr[\u03c81] \u2227 Regr[\u03c82]\nRegr[(\u2203x)\u03c8] = (\u2203x)Regr[\u03c8]\nWe use R[\u03c8(s), \u03b1] to denote Regr[\u03c8(do(\u03b1, s))], and R[\u03c8(s), ~\u03b1] to denote the repeated regression over all actions in the sequence ~\u03b1 (in reverse order). Note that the resulting formula has a free variable s of sort situation. Intuitively, it is the condition that has to hold in s in order for \u03c8 to hold after executing ~\u03b1 (i.e. in do(~\u03b1, s)). It is predominantly comprised of the fluents occurring in the conditional effects of\nthe actions in ~\u03b1. Due to the Regression Theorem [Reiter, 2001] we have that D |= \u03c8(do(~\u03b1, s)) \u2261 R[\u03c8(s), ~\u03b1] for all situations s. Regression is therefore independent from the state where the resulting formula is evaluated.\nRegression is a purely syntactic operation. Nevertheless, it is often beneficial to simplify the resulting formula for later evaluation. Regression can be defined in many action specification languages. In STRIPS, regression of a literal l over an action a is defined based on the add and delete lists of a. Regression in ADL was defined in [Pednault, 1989].\nNotation: We use \u03b1 to denote arbitrary but explicit actions and S to denote arbitrary but explicit situations, that is S = do(~\u03b1, S0) for some explicit action sequence ~\u03b1. Further ~\u03b1 \u00b7\u03b1 denotes the result of appending action \u03b1 to the sequence ~\u03b1.\nGoing back to our RoboCup example, regressing the goal \u201cball in goal\u201d over the action \u201cdrive to goal\u201d, yields a condition \u201chave ball\u201d. The further regression over a \u201cturn\u201d action states \u201cdistance to ball < 10cm\u201d as a condition for the success of the considered plan, if, e.g., the robot\u2019s 10cm long grippers enable turning with the ball."}, {"heading": "3 Planning with Unexpected Events", "text": "In this paper we consider a planner based on A\u2217 forward search that uses positive action costs as a metric, but the conceptual approach is amenable to a variety of other forward-search based planning techniques and paradigms.\nIntuitively, our approach annotates the search tree with all relevant information for determining the optimal plan. By regressing the goal, preconditions, and metric function over all considered action sequences, this information is expressed in terms of the current state. When unexpected events change the current state of the world, this allows us to reason symbolically about their relevance and their potential impact on the current search tree and choice of plan\u2014much faster than replanning from scratch.\nFor instance, our soccer robot from above knows from regressing the goal that the plan [\u201cturn\u201d, \u201cdrive to goal\u201d] will succeed whenever \u201cdistance to ball < 10cm\u201d holds. Hence it can determine the relevance of the aforementioned ball displacements, and also that, for instance, unexpected actions of its teammates can be ignored for now. A complication of this arises from our interest in optimal, rather than just valid plans, however. We will need to also consider alternative action sequences, and also handle impacts on the regressed metric function.\nAt the highest level, the approach we present here consists of two components: A regression-based A\u2217 planner, and a recovery procedure. These components, described below, can be used in at least two possible ways:\nAt-the-end: The planner generates an optimal plan for the assumed initial state. If no changes to the initial state occur,\nthe resulting plan is optimal and execution can commence. Otherwise, the recovery procedure updates the final search tree and open list (describing the search frontier) as necessary given any observed changes to the initial state. If the order of the open list does not change during the recovery, and hence still has the previously found plan as its first element, the plan is known to remain optimal and can be executed. Otherwise, the planner resumes plan generation given the updated structures.\nOn-the-fly: In the absence of any changes to the assumed initial state, the planner is proceeding in its search for an optimal plan. Whenever a change to the initial state is observed, plan generation is interrupted and the recovery procedure updates the current search tree and open list to reflect the changes. Plan generation then continues.\nIn both cases, this alternation continues until a plan generation cycle terminates without further interruptions, in which case the resulting plan is known to be optimal with respect to the currently assumed initial state. Note that the following descriptions are simplified for readability. In practice, there are various ways for increasing the efficiency of the implementation."}, {"heading": "3.1 Regression-based A\u2217 planning", "text": "In this section we present an A\u2217 planner that returns not only a plan, but also the remaining open list upon termination of search, as well as a search tree annotated with any relevant regressed formulae.\nTo provide a formal characterization, we assume that the planning domain is encoded in a basic action theory D. Given an initial situation S, a goal formula Goal(s), a formula Cost(a, c, s) defining costs c of action a, and a consistent heuristic specified as a formula Heu(h, s), A\u2217 search finds a sequence of actions ~\u03b1 such that the situation do(~\u03b1, S) satisfies the goal while minimizing the accumulated costs. Starting with an open list, Open, containing only one element representing the empty action sequence, the search proceeds by repeatedly removing and expanding the first element from the list until that element satisfies the goal, always maintaining the open list\u2019s order according to the value v defined by:\nValue ` v, do([\u03b11, . . . , \u03b1N ], s) \u00b4 def =\n(\u2203h, c1, . . . , cN ).v = h+ c1 + \u00b7 \u00b7 \u00b7+ cN \u2227Heu ` h, do([\u03b11, . . . , \u03b1N ], s) \u00b4 \u2227 Cost(\u03b11, c1, s) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Cost ` \u03b1N , cN , do([\u03b11, . . . , \u03b1N\u22121], s) \u00b4\nWe assume that the goal can only be achieved by a particular agent action finish. Any planning problem can be transformed to conform to this by defining the preconditions of finish according to the original goal.\nOur regression-based version of A\u2217 is shown in Figure 1. It interacts with the basic action theory D to reason about the truth-values of formulae. We say \u03c8 holds, to mean that it is entailed by D. The algorithm is initially invoked as\nregrA\u2217(D, S,Goal,Cost,Heu, [(0,\u221e, [ ])], nil). The last argument denotes a data structure representing the annotated search tree and is initially empty. The elements of the open list are tuples (g, h, ~\u03b1), where ~\u03b1 = [\u03b11, . . . , \u03b1n] is an action sequence, g are the costs accumulated when executing this sequence in S, and h is the value s.t. Heu(h, do(~\u03b1, S)) holds. When an element is expanded, it is removed from the open list and the following is performed for each agent action \u03b1\u2032: First, the preconditions of \u03b1\u2032 are regressed over ~\u03b1 (Line 6). If the resulting formula, stored in T (~\u03b1).P (s), holds in S according to D (Line 7), the cost formula for \u03b1\u2032 is regressed over ~\u03b1, the heuristic is regressed over ~\u03b1 \u00b7 \u03b1\u2032, and the resulting formulae are evaluated in S yielding values c\u2032 and h\u2032 (Lines 9\u201312). Intuitively, the regression of these formulae over ~\u03b1 describes, in terms of the current situation, the values they will take after performing ~\u03b1. Finally, a new tuple is inserted into the open list (Line 13) according to g+ c\u2032 + h\u2032 to maintain the open list\u2019s order according to Value(v, s).\nA\u2217 keeps expanding the first element of the open list until this element satisfies the goal, in which case the respective action sequence describes an optimal plan. This is because a consistent heuristic never over-estimates the actual remaining costs from any given state to the goal. Due to the Regression Theorem [Reiter, 2001], this known fact about A\u2217 also holds for our regression-based version. Similarly the completeness of A\u2217 is preserved.\nIn service of our recovery algorithm described below, we explicitly keep the search tree T and annotate its nodes with the regressed formulae for preconditions (T (~\u03b1).P (s)), costs (T (~\u03b1).C(c, s)), and heuristic value (T (~\u03b1).H(h, s)) and their values according to the (current) initial situation S (T (~\u03b1).p, T (~\u03b1).c, and T (~\u03b1).h). Roughly, when this state changes due to an unexpected event e, we reevaluate T (~\u03b1).P (s), T (~\u03b1).C(c, s), and T (~\u03b1).H(h, s) in s = do(e, S), and update their values and the open list accordingly. However, not all of these reevaluations are actually necessary and this is the key insight providing the speed-up of our\nalgorithm: since all formulae are regressed and hence expressed in terms of the current state, we can determine which ones are actually affected by the event, by simply considering the fluents the formulae mention. For this purpose, we maintain an index Index whose keys are ground fluents (e.g., distanceTo(ball)) and whose values are lists of pointers to all stored formulae that mention it."}, {"heading": "3.2 Recovering from Unexpected Events", "text": "While generating a plan for an assumed initial situation S, an unexpected event e, say \u201cdistanceTo(ball) \u2190 20\u201d, may occur, changing the state of the world and putting us into situation do(e, S). When this happens, the aforementioned index lets us pinpoint all formulae affected by this change (e.g., T ([turn, driveTo(goal), finish]).P (s)). After reevaluating these formulae in do(e, S) and updating their values, the search tree will be up-to-date in the sense that all contained values are with respect to do(e, S) rather than the originally assumed situation S. After propagating these changes to the open list, search can continue. We show that the resulting plan is optimal for the new situation. Note that the regressed formulae never change. Since often only very few fluents are affected by unexpected events, this relevancebased approach allows for very efficient recovery.\nThe recovery algorithm is specified in Figure 2. T denotes the annotated search tree, Open is the open list, and Index\nthe index. The latter contains entries of the form (~\u03b1, type), where ~\u03b1 is a sequence of actions and type is either of \u2018p\u2019, \u2018c\u2019, or \u2018h\u2019. The algorithm modifies the values of the tree and the open list (ll. 22 and 26) to reflect their value with respect to a new situation S2 (e.g., do(e, S1)) rather than an originally assumed initial situation S1. If the event changes the truth value of action preconditions, the content of the open list is modified accordingly (ll. 8, 17). When a previously impossible action has now become possible (Line 9) the annotation for this node is created and a new entry added to the open list (ll. 11-17). The function getGval(T, ~\u03b1) computes the sum of all costs (T (\u00b7).c) annotated in T along the branch from the root to node ~\u03b1.\nAs mentioned before, the algorithm can be used in one of at least two ways: on-the-fly, dealing with unexpected state changes immediately, or at-the-end, dealing at once with all events that occurred during planning. The former has the advantage that the planning effort is focused more tightly on what is actually relevant given everything that has happened so far. This approach can be implemented by inserting code right before Line 15 of regrA\u2217 that checks for events and invokes recover if necessary, changing S,Open\u2032, and T accordingly. The appeal of the latter stems from the fact that recovering from a bulk of events simultaneously can be more efficient than recovering from each individually. It may, however, be necessary to resume regrA\u2217 search afterwards, if, for instance, the current plan is no longer valid in the new initial state or a new opportunity exists, which may lead to a better plan. With both approaches, additional events may happen during recovery, making additional subsequent recoveries necessary.\nThe following theorem states the correctness of recover in terms of the at-the-end approach: calling recover and continuing regrA\u2217 with the new open list, produces an optimal plan and in particular the same as replanning from scratch in S2. Recall that the head of the open list contains the optimal plan. For on-the-fly, correctness can be shown analogously (cf. Lemma 1 in [Fritz, 2009, p.191]).\nTheorem 1 (Correctness). Let D be a basic action theory, Goal a goal formula, Cost(a, c) a cost formula, and Heu(h) a consistent heuristic. Then, for any two situations S1, S2 in D we have that after the sequence of invocations:\n1. (O1, T1) \u2190 regrA\u2217(D, S1,Goal,Cost,Heu, [(0,\u221e, [ ])], nil), 2. create Index from T1, 3. (O2, T2) \u2190 recover(D, S1, S2,O1, T1, Index), 4. (O3, T3) \u2190 regrA\u2217(D, S2,Goal,Cost,Heu,O2, T2),\nthe first element of O3 will be the same as in O\u2032 of (O\u2032, T \u2032) \u2190 regrA\u2217(D, S2,Goal,Cost,Heu, [(0,\u221e, [ ])], nil), or both O3 and O\u2032 are empty. Proof: [Fritz, 2009, p.190 ff.].\nAs a special case, this works for S2 = do(~e, S1), for any situation S1 and sequence of events ~e. Note that such events can produce arbitrary changes to the state of the world. The algorithm does not make any assumptions about possible\nevents. Any fluent may assume any value at any time.\nIn complex domains, many state changes are completely irrelevant to the current planning problem, overall or at the current stage of planning, and others only affect a small subset of elements in the search tree. During recovery, we exploit this structure to gain significant speed-ups compared to replanning from scratch. More importantly it allows us to recover from small perturbations faster than from large ones, where \u201clarge\u201d may refer to the number of fluents that changed or the amount by which continuous fluents changed (cf. Section 4). This way, recovery can converge, i.e., \u201ccatch up with reality\u201d, as we defined informally in the introduction. We verified this empirically."}, {"heading": "4 Empirical Results", "text": "We present empirical results obtained using a current implementation of our algorithm to generate optimal plans for differently sized problems of the metric TPP and Zenotravel domains of the International Planning Competition. We begin by showing that the time required for recovering from unexpected state changes is roughly and on average proportional to the extent of the change. We then show that our approach is able to find optimal plans even when the initial state changes frequently. We compare the two mentioned recovery strategies on-the-fly and at-the-end, showing that the former clearly outperforms the latter in terms of likelihood of convergence. Finally, and not surprisingly, we show that our approach generally outperforms replanning from scratch. All experiments were run on an Intel Xeon 2.66 GHz with 2GB RAM.\nFigure 3 plots the average time the combination of recover + continued regrA\u2217 search took to find a new optimal plan, after the value of a randomly selected continuous fluent was randomly modified after generating an optimal plan. A deviation x% means that the fluent was multiplied by 1\u00b1 x\n100 .\nNote that we used continuous fluents in our experiments only because they lend themselves better to a quantitative evaluation\u2014our approach is equally applicable to discrep-\nancies on discrete valued, including Boolean, fluents. As one can see, the time to recover from a drastic change takes on average longer than for minor deviations. While this doesn\u2019t seem surprising, it is a necessary condition for the convergence of the recovery, which we study next.\nWe assume that in shorter periods of time fewer things change or changes are less drastic than over longer periods. As we will see, recovery generally takes less time than the original planning did. Hence, we expect fewer or less drastic changes during recovery than during planning. A second recovery\u2014from the events that occurred during the first recovery\u2014is thus predicted to take less time than the first. This process often continues until convergence. We studied the conditions under which our algorithm converges by simulating domains with frequent changes to the initial state. At high frequencies during planning and subsequent recoveries, we randomly perturbed some fluent by an amount of up to a certain maximum between 5-80%. We considered the two approaches described earlier: completing the original planning task and recovering only afterwards followed by further regrA\u2217 search if needed (atthe-end), or reacting to state changes immediately pausing further regrA\u2217 expansion until recover has brought the current search tree up-to-date (on-the-fly). In both cases, several episodes of recovery and additional regrA\u2217 search were generally required before finding an optimal and up-to-date plan. Their number varied strongly, as a result of some discrepancies having larger impact than others. Table 1 shows, for different frequencies and amounts of deviation, the percentages of simulations in which an optimal plan was found, i.e., the algorithm converged within the time limit. As time limit we used 30 times the time required for solving the respective original problems, without perturbations, using a conventional A\u2217 search planner. These were 0.52s for TPP1, 2.17s for TPP2, 3.03s for TPP3, and 0.34s, 0.82s, and 1.58s for Zenotravel 1, 2, and 3 respectively. The frequencies shown in the table are relative to these as well. For instance, the value 100 for Zenotravel1 on-thefly, 5Hz, 40% states that even when every 0.34s/5 = 68 ms the value of a random fluent changed by up to 40% in the considered Zenotravel problem, the on-the-fly approach still converged 100% of the time. We believe this simulates a quite erratic environment, possibly harsher than many realistic application domains.\nThe on-the-fly recovery strategy clearly outperforms atthe-end recovery. This makes intuitive sense, as no time is wasted continuing planning for an already flawed instance. This also motivates an integrated approach, showing its benefit over the use of plan adaptation approaches which are only applicable once a first plan has been produced. The table also shows that convergence was much better on TPP than on Zenotravel. Interestingly, this was predictable given Figure 3: since the curve for Zenotravel1 intersects the y-axis at around 0.07 seconds, it seems un-\nreasonable to expect convergence on this problem when the initial state changes at intervals shorter than that. This explains the low probability of convergence when events occur at 10Hz times planning time, i.e., every 0.034s. In comparison, recovering via replanning from scratch takes the same amount of time, no matter how small the discrepancy is, unless the problem gets significantly easier due to the change. Hence, it has no chance of ever catching up with reality when events happen at time intervals shorter than the time required for plan generation.\nNot surprisingly, our approach generally outperforms replanning from scratch. To demonstrate this, we compared the times required by both approaches for recovering from a single change of the initial state. The setup was as follows: We solved a planning problem, perturbed the state of the world by randomly changing some fluent\u2019s value, and then ran both (a) recover followed by further regrA\u2217 search based on the modified open list if necessary, and (b) replanning from scratch using a conventional A\u2217 search implementation using the same heuristic. The fluent perturbations were done on continuous fluents only, and the amount of change was up to 50%.\nFigure 4 shows the time both approaches require to recover from single events on our TPP1 problem. Recall that with both approaches the resulting plan is provably optimal. We separately show the times for cases where (a) additional regrA\u2217 was necessary, and (b) where it was not. The latter is the case when following the recover, the first element of the open list satisfied the goal. The average speed-up over replanning from scratch was 10.56 in the former case, and 33.64 in the latter. In all test cases, the simulated discrepancy was relevant in the sense that at least one formula appearing in the annotation was affected. Hence, calling recover was necessary in all cases\u2014the set \u2206 of Figure 2 was never empty.\nWe performed the same experiment on the Zenotravel1 problem. It is a reasonable question to ask whether the relative speed-up of our approach is just due to the use of a comparatively slow replanner. Therefore we tested using two different, hand-coded heuristics, where the first is more informed (i.e., better) than the second. Using the first, which we also used in the earlier described experiments, the average recovery time was 0.14s, and the average replanning time was 0.51s, whereas with the second heuristic recovery time averaged to 0.35s and replanning to 1.07s. This shows that even when the planner, and thus replanner, is improved by the use of a better heuristic, our approach is still generally superior to replanning from scratch. This is because it equally benefits from a smaller search tree, resulting from the use of a better heuristic.\nUnfortunately, there are no other replanning systems we can compare our algorithm to, since no other system aims to produce optimal plans. Further, even for recent validity-\ntim e\n(s ec\non ds\n)\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\ntest case 00 10 20 30 40 50 60 70 80\n90\nreplanning\nregrA\u2217 + recover\n(a) additional planning necessary\ntim e\n(s ec\non ds\n)\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\ntest case 00 20 40 60 80 100 120 140\nreplanning\nregrA\u2217 + recover\n(b) additional planning unnecessary\nFigure 4: Run-time comparison of our approach vs. replanning from scratch on the TPP domain.\nonly replanners, we were unable to obtain implementations from the authors. In addition, such replanners could only be used for at-the-end recovery, which seems inferior to on-the-fly recovery."}, {"heading": "5 Discussion", "text": "We made three contributions: (1) We presented a novel integrated planning and recovery algorithm for generating optimal plans in environments where the state of the world frequently changes unexpectedly during planning. At its core, the algorithm reasons about the relevance and impact of discrepancies, allowing the algorithm to recover from changes more efficiently than replanning from scratch. (2) We introduced a new criterion for evaluating plan adaptation approaches, called convergence, and argued for its significance. (3) We provided empirical evidence for the convergence of our approach under high frequencies of unexpected state changes. Our experiments also show that an interleaved planning+recovery approach which recovers from discrepancies on-the-fly is superior to an approach that only recovers once planning has completed.\nIn the future, we intend to apply this work to a highly dynamic real-world domain such as the mentioned RoboCup or Unmanned Aerial Vehicles. To do so, an optimized ver-\nsion of our implementation is required. While the approach is able to handle changes in the state, which can also be used to model changes in executability and cost of actions, we would like to study changing goals as well. We also think that the ideas behind the presented approach may be beneficially applied to planning under initial state uncertainty, in particular when such uncertainty ranges over continuous domains.\nThe presented work is part of a larger body of research regarding the generation and execution of optimal plans in highly dynamic domains (cf. [Fritz, 2009]), including an approach for monitoring plan optimality during execution. This is needed since during execution the optimality of the executing plan may also be jeopardized by exogenous events.\nThe presented approach is one of the first to monitor and react to unexpected state changes during planning. The approach taken by Veloso et al. [1998] exploits the \u201crationale\u201d, the reasons for choices made during planning, to deal with discrepancies that occur during planning. They acknowledge the possibility that previously sub-optimal alternatives may become better than the current plan candidate as the world evolves during planning, but the treatment of optimality is informal and limited. No guarantees are made regarding the optimality of the resulting plan. Also, by us-\ning best-first search, our approach is compatible with many state-of-the-art planners, while the approach of Veloso et al. is particular to the PRODIGY planner.\nSeveral approaches exist for adapting a plan in response to unexpected events that occur during execution, rather than during plan generation, e.g., [Koenig et al., 2002; Hanks and Weld, 1995; Gerevini and Serina, 2000]. Arguably we could use these approaches for our purpose of recovering from discrepancies during planning by first ignoring the changes and then recovering once a plan is generated. We think this is inferior to our approach for the following reasons: (1) except for the first, the listed approaches do not guarantee optimality, (2) we have shown that an integrated approach which recovers from state changes on-the-fly has convergence advantages, and (3) it is not clear whether such a use of these replanners would at all lead to convergence.\nThe SHERPA system presented by Koenig et al. [2002] monitors the continued optimality of a plan only in a limited form. SHERPA lifts the Life-Long Planning A\u2217 (LPA\u2217) search algorithm to symbolic propositional planning. LPA\u2217 was developed for the purpose of replanning in problems like robot navigation (i.e., path replanning) with simple, unconditional actions, and only applies to replanning problems where the costs of actions have changed but the current state remains the same. Similar to our approach, SHERPA retains the search tree to determine how changes may affect the current plan. Our approach subsumes this approach and further allows for the general case where the initial (current) state may change arbitrarily and the dynamics of the domain may involve complex conditional effects. SHERPA\u2019s limitations equally apply to more recent work by Sun and Koenig [2007]. The presented Fringe-Saving A\u2217 (FSA\u2217) search algorithm, which sometimes performs better than LPA\u2217, is further limited to grid world applications and the use of the Manhattan distance heuristic. This algorithm retains the open list of previous searches as well.\nThe idea of deriving and utilizing knowledge about relevant conditions of the current state for monitoring and possibly repairing a plan, has been used before, e.g., Kambhampati [1990], and reaches back to the early work on Shakey the Robot by Fikes et al. [1972]. Fikes et al. used triangle tables to annotate the plan with the regressed goal, in order to determine whether replanning was necessary when the state of the world changed unexpectedly.\nNebel and Koehler [1995] show that plan reuse, and hence plan repair, has the same worst case complexity as planning from scratch. This result is interesting in theory, but not so relevant in the practical case of optimal plan generation in the face of frequent unexpected events. In this case, we have shown that if we want to have a plan that we know to be optimal at the start of execution, then the recovery time relative to the impact of an event is more important.\nAn important merit of our approach is its ability to handle any possible state change, rather than being limited to a predefined set of contingencies, but without paying the price of computing a complete policy. It hence explores a pragmatic middle-ground between the efficiency of deterministic planning, and the robustness of solving MDPs completely. The lack of the explicit consideration of possible contingencies during planning, distinguishes this work from related approaches for solving relational and first-order MDPs (e.g., [Boutilier et al., 2001; Ho\u0308lldobler et al., 2006]).\nAcknowledgements: We gratefully acknowledge funding from the Natural Sciences and Engineering Research Council of Canada."}], "references": [{"title": "Symbolic dynamic programming for first-order MDPs", "author": ["C. Boutilier", "R. Reiter", "B. Price"], "venue": "Proc. IJCAI\u201901, pp. 690\u2013700", "citeRegEx": "Boutilier et al.. 2001", "shortCiteRegEx": null, "year": 2001}, {"title": "Learning and executing generalized robot plans", "author": ["R. Fikes", "P. Hart", "N. Nilsson"], "venue": "Artificial Intelligence, 3:251\u2013288", "citeRegEx": "Fikes et al.. 1972", "shortCiteRegEx": null, "year": 1972}, {"title": "University of Toronto", "author": ["Christian Fritz. Monitoring the Generation", "Execution of Optimal Plans. PhD thesis"], "venue": "April", "citeRegEx": "Fritz. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Fast plan adaptation through planning graphs: Local and systematic search techniques", "author": ["A. Gerevini", "I. Serina"], "venue": "Proc. AIPS\u201900, pp. 112\u2013121", "citeRegEx": "Gerevini and Serina. 2000", "shortCiteRegEx": null, "year": 2000}, {"title": "A domainindependent algorithm for plan adaptation", "author": ["S. Hanks", "D.S. Weld"], "venue": "J. Artif. Intell. Res. (JAIR), 2:319\u2013360", "citeRegEx": "Hanks and Weld. 1995", "shortCiteRegEx": null, "year": 1995}, {"title": "Flucap: A heuristic search planner for first-order MDPs", "author": ["S. H\u00f6lldobler", "E. Karabaev", "O. Skvortsova"], "venue": "J. Artif. Intell. Res., 27:419\u2013439", "citeRegEx": "H\u00f6lldobler et al.. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "A theory of plan modification", "author": ["S. Kambhampati"], "venue": "Proc. AAAI\u201990, pp. 176\u2013182", "citeRegEx": "Kambhampati. 1990", "shortCiteRegEx": null, "year": 1990}, {"title": "Heuristic search-based replanning", "author": ["S. Koenig", "D. Furcy", "C. Bauer"], "venue": "Proc. AIPS, pp. 294\u2013301", "citeRegEx": "Koenig et al.. 2002", "shortCiteRegEx": null, "year": 2002}, {"title": "Plan reuse versus plan generation: A theoretical and empirical analysis", "author": ["B. Nebel", "J. Koehler"], "venue": "Artificial Intelligence, 76(1\u20132):427\u2013454", "citeRegEx": "Nebel and Koehler. 1995", "shortCiteRegEx": null, "year": 1995}, {"title": "ADL: Exploring the middle ground between STRIPS and the situation calculus", "author": ["E.P.D. Pednault"], "venue": "Proc. KR\u201989, pp. 324\u2013332", "citeRegEx": "Pednault. 1989", "shortCiteRegEx": null, "year": 1989}, {"title": "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems", "author": ["Ray Reiter"], "venue": "MIT Press,", "citeRegEx": "Reiter. 2001", "shortCiteRegEx": null, "year": 2001}, {"title": "The fringesaving A* search algorithm - a feasibility study", "author": ["X. Sun", "S. Koenig"], "venue": "Proc. IJCAI\u201907, pp. 2391\u20132397", "citeRegEx": "Sun and Koenig. 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "Rationale-based monitoring for continuous planning in dynamic environments", "author": ["M.M. Veloso", "M.E. Pollack", "M.T. Cox"], "venue": "Proc. AIPS\u201998, pp. 171\u2013179", "citeRegEx": "Veloso et al.. 1998", "shortCiteRegEx": null, "year": 1998}], "referenceMentions": [{"referenceID": 10, "context": "The situation calculus is a logical language for specifying and reasoning about dynamical systems [Reiter, 2001].", "startOffset": 98, "endOffset": 112}, {"referenceID": 10, "context": "Details of the form of these axioms can be found in [Reiter, 2001].", "startOffset": 52, "endOffset": 66}, {"referenceID": 10, "context": "In the situation calculus, one step regression is defined inductively using the successor state axiom for a fluent F (~x) as above [Reiter, 2001]:", "startOffset": 131, "endOffset": 145}, {"referenceID": 10, "context": "Due to the Regression Theorem [Reiter, 2001] we have that D |= \u03c8(do(~ \u03b1, s)) \u2261 R[\u03c8(s), ~ \u03b1] for all", "startOffset": 30, "endOffset": 44}, {"referenceID": 9, "context": "Regression in ADL was defined in [Pednault, 1989].", "startOffset": 33, "endOffset": 49}, {"referenceID": 10, "context": "Due to the Regression Theorem [Reiter, 2001], this known fact about A also holds for our regression-based version.", "startOffset": 30, "endOffset": 44}, {"referenceID": 2, "context": "[Fritz, 2009]), including an approach for monitoring plan optimality during execution.", "startOffset": 0, "endOffset": 13}, {"referenceID": 7, "context": ", [Koenig et al., 2002; Hanks and Weld, 1995; Gerevini and Serina, 2000].", "startOffset": 2, "endOffset": 72}, {"referenceID": 4, "context": ", [Koenig et al., 2002; Hanks and Weld, 1995; Gerevini and Serina, 2000].", "startOffset": 2, "endOffset": 72}, {"referenceID": 3, "context": ", [Koenig et al., 2002; Hanks and Weld, 1995; Gerevini and Serina, 2000].", "startOffset": 2, "endOffset": 72}, {"referenceID": 0, "context": ", [Boutilier et al., 2001; H\u00f6lldobler et al., 2006]).", "startOffset": 2, "endOffset": 51}, {"referenceID": 5, "context": ", [Boutilier et al., 2001; H\u00f6lldobler et al., 2006]).", "startOffset": 2, "endOffset": 51}], "year": 2009, "abstractText": "Generating optimal plans in highly dynamic environments is challenging. Plans are predicated on an assumed initial state, but this state can change unexpectedly during plan generation, potentially invalidating the planning effort. In this paper we make three contributions: (1) We propose a novel algorithm for generating optimal plans in settings where frequent, unexpected events interfere with planning. It is able to quickly distinguish relevant from irrelevant state changes, and to update the existing planning search tree if necessary. (2) We argue for a new criterion for evaluating plan adaptation techniques: the relative running time compared to the \u201csize\u201d of changes. This is significant since during recovery more changes may occur that need to be recovered from subsequently, and in order for this process of repeated recovery to terminate, recovery time has to converge. (3) We show empirically that our approach can converge and find optimal plans in environments that would ordinarily defy planning due to their high dynamics.", "creator": "gnuplot 4.2 patchlevel 3 "}}}