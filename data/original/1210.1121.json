{"id": "1210.1121", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Oct-2012", "title": "Smooth Sparse Coding via Marginal Regression for Learning Sparse Representations", "abstract": "We propose and analyze a novel framework for learning sparse representations, based on two statistical techniques: kernel smoothing and marginal regression. The proposed approach provides a flexible framework for incorporating feature similarity or temporal information present in data sets, via non-parametric kernel smoothing. We provide generalization bounds for dictionary learning using smooth sparse coding and show how the sample complexity depends on the L1 norm of kernel function used. Furthermore, we propose using marginal regression for obtaining sparse codes, which significantly improves the speed and allows one to scale to large dictionary sizes easily. We demonstrate the advantages of the proposed approach, both in terms of accuracy and speed by extensive experimentation on several real data sets. In addition, we demonstrate how the proposed approach could be used for improving semi-supervised sparse coding.", "histories": [["v1", "Wed, 3 Oct 2012 14:26:59 GMT  (28kb)", "http://arxiv.org/abs/1210.1121v1", null]], "reviews": [], "SUBJECTS": "stat.ML cs.LG", "authors": ["krishnakumar balasubramanian", "kai yu", "guy lebanon"], "accepted": true, "id": "1210.1121"}, "pdf": {"name": "1210.1121.pdf", "metadata": {"source": "CRF", "title": "Smooth Sparse Coding via Marginal Regression for Learning Sparse Representations", "authors": ["Krishnakumar Balasubramanian", "Kai Yu"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n21 0.\n11 21\nv1 [\nst at\n.M L\n] 3\nO ct\nWe propose and analyze a novel framework for learning sparse representations, based on two statistical techniques: kernel smoothing and marginal regression. The proposed approach provides a flexible framework for incorporating feature similarity or temporal information present in data sets, via non-parametric kernel smoothing. We provide generalization bounds for dictionary learning using smooth sparse coding and show how the sample complexity depends on the L1 norm of kernel function used. Furthermore, we propose using marginal regression for obtaining sparse codes, which significantly improves the speed and allows one to scale to large dictionary sizes easily. We demonstrate the advantages of the proposed approach, both in terms of accuracy and speed by extensive experimentation on several real data sets. In addition, we demonstrate how the proposed approach could be used for improving semi-supervised sparse coding."}, {"heading": "1 Introduction", "text": "Sparse coding is a popular unsupervised paradigm for learning sparse representations of data samples, that are subsequently used in classification tasks. In standard sparse coding, each data sample is coded independently with respect to the dictionary. We propose a smooth alternative to traditional sparse coding that incorporates feature similarity, temporal or other user-specified domain information between the samples, into the coding process.\nThe idea of smooth sparse coding is motivated by the relevance weighted likelihood principle. Our approach constructs a code that is efficient in a smooth sense and as a result leads to improved statistical accuracy over traditional sparse coding. The smoothing operation, which could be expressed as non-parametric kernel smoothing, provides a flexible framework for incorporating several types of domain information that might be available for the user. For example, for image classification task, one could use: (1) kernels in feature space for encoding similarity information for images and videos, (2) kernels in time space in case of videos for incorporating temporal relationship, and (3) kernels on unlabeled image in the semi-supervised learning and transfer learning settings.\nMost sparse coding training algorithms fall under the general category of alternating procedures with a convex lasso regression sub-problem. While efficient algorithms for such cases exist [22, 11], their scalability for large dictionaries remains a challenge. We propose a novel training method for sparse coding based on marginal regression, rather than solving the traditional alternating method with lasso sub-problem. Marginal regression corresponds to several univariate linear regression followed by a thresholding step to promote sparsity. For large dictionary sizes, this leads to a dramatic speedup compared to traditional sparse coding methods (up to two orders of magnitude) without sacrificing statistical accuracy.\nWe further develop theory that extends the sample complexity result of [20] for dictionary learning using standard sparse coding to the smooth sparse coding case. We specifically show how the sample complexity depends on the L1 norm of the kernel function used.\n\u2217krishnakumar3@gatech.edu \u2020yukai@baidu.com \u2021lebanon@cc.gatech.edu\nOur main contributions are: (1) proposing a framework based on kernel-smoothing for incorporating feature, time or other similarity information between the samples into sparse coding, (2) providing sample complexity results for dictionary learning using smooth sparse coding, (3) proposing an efficient marginal regression training procedure for sparse coding, and (4) successful application of the proposed method in various classification tasks. Our contributions lead to improved classification accuracy in conjunction with computational speedup of two orders of magnitude."}, {"heading": "2 Related work", "text": "Our approach is related to the local regression method [13, 7]. More recent related work is [15] that uses smoothing techniques in high-dimensional lasso regression in the context of temporal data. Another recent approach proposed by [26] achieves code locality by approximating data points using a linear combination of nearby basis points. The main difference is that traditional local regression techniques do not involve basis learning. In this work, we propose to learn the basis or dictionary along with the regression coefficients locally.\nIn contrast to previous sparse coding papers we propose to use marginal regression for learning the regression coefficients, which results in a significant computational speedup with no loss of accuracy. Marginal regression is a relatively old technique that has recently reemerged as a computationally faster alternative to lasso regression [5]. See also [6] for a statistical comparison of lasso regression and marginal regression."}, {"heading": "3 Smooth Sparse Coding", "text": "Notations: The notations x and X correspond to vectors and matrices respectively, in appropriately defined dimensions; the notation \u2016\u00b7\u2016p corresponds to the Lp norm of a vector (we use mostly use p = 1, 2 in this paper); the notation \u2016 \u00b7 \u2016F corresponds to the Frobenius norm of a matrix; the notation |f |p corresponds to the Lp norm of the function f : ( \u222b\n|f |p d\u00b5)1/p; the notation xi, i = 1, . . . , n corresponds to the data samples, where we assume that each sample xi is a d-dimensional vector. The explanation below uses L1 norm for sparsity for simplicity. But the method applies more generally to any structured regularizers, for e.g., [3, 8].\nThe standard sparse coding problem consists of solving the following optimization problem,\nmin D\u2208Rd\u00d7K \u03b2i\u2208RK ,i=1,...,n\nn \u2211\ni=1\n\u2016xi \u2212D\u03b2i\u201622\nsubject to \u2016dj\u20162 \u2264 1 j = 1, . . .K \u2016\u03b2i\u20161 \u2264 \u03bb i = 1, . . . n.\nwhere \u03b2i \u2208 RK corresponds to the encoding of sample xi with respected to the dictionary D \u2208 Rd\u00d7K and dj \u2208 Rd denotes the j-column of the dictionary matrix D. The dictionary is typically over-complete, implying that K > d.\nObject recognition is a common sparse coding application where xi corresponds to a set of features obtained from a collection of image patches, for example SIFT features [14]. The dictionary D corresponds to an alternative coding scheme that is higher dimensional than the original feature representation. The L1 constraint promotes sparsity of the new encoding with respect to D. Thus, every sample is now encoded as a sparse vector that is of higher dimensionality than the original representation.\nIn some cases the data exhibits a structure that is not captured by the above sparse coding setting. For example, SIFT features corresponding to samples from the same class are presumably closer to each other compared to SIFT features from other classes. Similarly in video, neighboring frames are presumably more related to each other than frames that are farther apart. In this paper we propose a mechanism to incorporate such feature similarity and temporal information into sparse coding, leading to a sparse representation with an improved statistical accuracy (for example as measured by classification accuracy).\nWe consider the following smooth version of the sparse coding problem above:\nmin D\u2208Rd\u00d7K \u03b2i\u2208RK ,i=1,...,n\nn \u2211\ni=1\nn \u2211\nj=1\nw(xj , xi)\u2016xj \u2212D\u03b2i\u201622 (1)\nsubject to \u2016dj\u20162 \u2264 1 j = 1, . . .K (2) \u2016\u03b2i\u20161 \u2264 \u03bb i = 1, . . . n. (3)\nwhere \u2211n\nj=1 w(xj , xi) = 1 for all i. It is convenient to define the weight function through a smoothing kernel\nw(xj , xi) = 1 h1 K1 ( \u03c1(xj , xi) h1 )\nwhere \u03c1(\u00b7, \u00b7) is a distance function that captures the feature similarity, h1 is the bandwidth, and K1 is a smoothing kernel. Traditional sparse coding minimizes the reconstruction error of the encoded samples. Smooth sparse coding, on the other hand, minimizes the reconstruction of encoded samples with respect to their neighbors (weighted by the amount of similarity).\nThe smooth sparse coding setting leads to codes that represent a neighborhood rather than an individual sample and that have lower mean square reconstruction error (with respect to a given dictionary), due to lower estimation variance (see for example the standard theory of smoothed empirical process [4])."}, {"heading": "3.1 The choice of smoothing kernel", "text": "There are several possible ways to determine the weight function w. One common choice for the kernel function is the Gaussian kernel whose bandwidth is selected using cross-validation. Other common choices for the kernel are the triangular, uniform, and tricube kernels. The bandwidth may be fixed throughout the input space, or may vary in order to take advantage of non-uniform samples. We use in our experiment the tricube kernel with a constant bandwidth.\nThe distance function \u03c1(\u00b7, \u00b7) may be one of the standard distance functions (for example based on the Lp norm). Alternatively, \u03c1(\u00b7, \u00b7) may be expressed by domain experts, learned from data before the sparse coding training, or learned jointly with the dictionary and codes during the sparse coding training."}, {"heading": "3.2 Spatio-Temporal smoothing", "text": "In spatio-temporal applications we can extend the kernel to include also a term reflecting the distance between the corresponding time or space\nw(xj , xi) = 1 h1 K1 ( \u03c1(xj , xi) h1 ) 1 h2 K2 ( j \u2212 i h2 ) .\nAbove, K2 is a univariate symmetric kernel with bandwidth parameter h2. One example is video sequences, where the kernel above combines similarity of the frame features and the time-stamp.\nAlternatively, the weight function can feature only the temporal component and omit the first term containing the distance function between the feature representation. A related approach for that situation, is based on the Fused lasso which penalizes the absolute difference between codes for neighboring points. The main drawback of that approach is that one needs to fit all the data points simultaneously whereas in smooth sparse coding, the coefficient learning step decomposes as n separate problems which provides a computational advantage (see Section 9.1.5 for more details). Also, while fused Lasso penalty is suitable for time-series data to capture relatedness between neighboring frames, it may not be immediately suitable for other situations that the proposed smooth sparse coding method could handle."}, {"heading": "4 Marginal Regression for Smooth Sparse Coding", "text": "A standard algorithm for sparse coding is the alternating bi-convex minimization procedure, where one alternates between (i) optimizing for codes (with a fixed dictionary) and (ii) optimizing for dictionary (with fixed codes). Note that step (i) corresponds to regression with L1 constraints and step (ii) corresponds to least squares with L2 constraints. In this section we show how marginal regression could be used to obtain better codes faster (step (i)). In order to do so, we first give a brief description of the marginal regression procedure.\nMarginal Regression: Consider a regression model y = X\u03b2 + z where y \u2208 Rn, \u03b2 \u2208 Rp, X \u2208 Rn\u00d7p with L2 normalized columns (denoted by xj), and z is the noise vector. Marginal regression proceeds as follows:\n\u2022 Calculate the least squares solution \u03b1\u0302(j) = xTj y.\n\u2022 Threshold the least-square coefficients \u03b2\u0302(j) = \u03b1\u0302(j)1{|\u03b1\u0302(j)|>t}, j = 1, . . . , p.\nMarginal regression requires just O(np) operations compared to O(p3 + np2), the typical complexity of lasso algorithms. When p is much larger than n, marginal regression provides two orders of magnitude over Lasso based formulations. Note that in sparse coding, the above speedup occurs for each iteration of the outer loop, thus enabling sparse coding for significantly larger dictionary sizes. Recent studies have suggested that marginal regression is a viable alternative for Lasso given its computational advantage over lasso. A comparison of the statistical properties of marginal regression and lasso is available in [5, 6].\nApplying marginal regression to smooth sparse coding, we obtain the following scheme. The marginal least squares coefficients are\n\u03b1\u0302 (k) i =\nn \u2211\nj=1\nw(xj , xi)\n\u2016dk\u20162 dTk xj .\nWe sort these coefficient in terms of their absolute values, and select the top s coefficients whose L1 norm is bounded by \u03bb:\n\u03b2\u0302 (k) i =\n{\n\u03b1\u0302 (k) i k \u2208 S 0 k /\u2208 S , where\nS =\n{\n1, . . . , s : s \u2264 d : s \u2211\nk=1\n|\u03b1\u0302(k)i | \u2264 \u03bb }\nWe select the thresholding parameter using cross validation in each of the sparse coding iterations. Note that the same approach could be used with structured regularizers too, for example [3, 8].\nMarginal regression works well when there is minimal correlation between the different dictionary atoms. In the linear regression setting, marginal regression performs much better with orthogonal data [6]. In the context of sparse coding, this corresponds to having uncorrelated or incoherent dictionaries [19]. One way to measure such incoherence is using the babel function, which bounds the maximum inner product between two different columns di, dj :\n\u00b5s(D) = max i\u2208{1,...,d} max \u039b\u2282{1,...,d}\\{i};|\u039b|=s\n\u2211 j\u2208\u039b |d\u22a4j di|.\nAn alternative, which leads to easier computation is enforcing the constraint \u2016DTD \u2212 IK\u00d7K\u20162F when optimizing over the dictionary matrix D\nD\u0302 = argmin D\u2208D\nn \u2211\ni=1\n\u2016xi \u2212D\u03b2\u0302i\u201622, where\nD = {D \u2208 Rd\u00d7K : \u2016dj\u201622 \u2264 1, \u2016D\u22a4D \u2212 I\u20162F \u2264 \u03b3}. We use the method of optimal directions update [17] to solve the above optimization problem. Specifically, representing the constraints using the Lagrangian and setting the derivative with respect to D to zero, we get the following update rule\nD\u0302(t+1) = ( B\u0302(t+1)B\u0302 \u22a4 (t+1) + 2\u03baD\u0302 \u22a4 t D\u0302t + 2\u03b7diag(D\u0302 \u22a4 t D\u0302t) )\n( XB\u0302\u22a4(t+1) + 2(\u03ba+ \u03b7)D\u0302t ) .\nAbove, B\u0302t = [\u03b2\u03021(t), . . . , \u03b2\u0302n(t)] is the matrix of data codes obtained in iteration t, X \u2208 Rp\u00d7n is the data in matrix format, \u03ba is a regularization parameter corresponding to the incoherence constraints, and \u03b7 is a regularization parameter corresponding to the normalization constraints. Note that if \u03ba = \u03b7 = 0, the update reduces to standard least squares update with no constraints.\nA sequence of such updates corresponding to step (i) and step (ii) converges to a stationary point of the optimization problem (this can be shown using Zangwill\u2019s theorem [27]). But no provable algorithm that converges to the global minimum of the smooth sparse coding (or standard sparse coding) exists yet. Nevertheless, the main idea of this section is to speed-up the existing alternating bi-convex minimization procedure for obtaining sparse representations, by using marginal regression.\nAlgorithm 1 Smooth Sparse Coding via Marginal Regression\nInput: Data {(x1, y1), . . . , (xn, yn)} and kernel/similarity measure K1 and d1. Precompute: Compute the weight matrix w(i, j) using the kernel/similarity measure and Initialize: Set the dictionary at time zero to be D0. Algorithm: repeat Step (i): For all i = 1, . . . , n, solve marginal regression:\n\u03b1\u0302 (k) i =\nn \u2211\nj=1\nw(xj , xi)\n\u2016dk\u20162 dTk xj\n\u03b2\u0302 (k) j =\n{\n\u03b1\u0302 (k) j j \u2208 S 0 j /\u2208 S ,\nS = {1, . . . , s; s \u2264 d : s \u2211\nk=1\n|\u03b1\u0302(k)i | \u2264 \u03bb}.\nStep (ii): Update the dictionary based on codes from previous step.\nD\u0302t = argmin D\u2208D\nn \u2211\ni=1\n\u2016xi \u2212D\u03b2\u0302i(t)\u201622, where\nD = {D \u2208 Rd\u00d7K : \u2016dj\u201622 \u2264 1, \u2016D\u22a4D \u2212 I\u20162F \u2264 \u03b3}\nuntil convergence Output: Return the learned codes and dictionary."}, {"heading": "5 Sample Complexity of Smooth sparse coding", "text": "In this section, we analyze the sample complexity of the proposed smooth sparse coding framework. Specifically, since there does not exist a provable algorithm that converges to the global minimum of the optimization problem in Equation (1), we provide uniform convergence bounds over the dictionary space and thereby prove a sample complexity result for dictionary learning under smooth spare coding setting. We leverage the analysis for dictionary learning in the standard sparse coding setting by [20] and extend it to the smooth sparse coding setting. The main difficulty for the smooth sparse coding setting is obtaining a covering number bound for an appropriately defined class of functions (see Theorem 1 for more details).\nWe begin by re-representing the smooth sparse coding problem in a convenient format for analysis. Let x1, . . . , xn be independent random variables with a common probability measure P with a density p. We denote by Pn the empirical measure over the n samples, and the kernel density estimate of p is defined by\npn,h(x) = 1\nnh\nn \u2211\ni=1\nK (\u2016x\u2212Xi\u20162\nh\n)\n.\nLet Kh1(\u00b7) = 1h1K1( \u00b7 h ). With the above notations, the reconstruction error at the point x is given by\nr\u03bb(x) =\n\u222b\nmin \u03b2\u2208S\u03bb\n\u2016x\u2032 \u2212D\u03b2\u20162Kh1(\u03c1(x, x\u2032)) dPn(x\u2032)\nwhere S\u03bb = {\u03b2 : \u2016\u03b2\u20161 \u2264 \u03bb}.\nThe empirical reconstruction error is\nE Pn(r) =\n\u222b\u222b\nmin \u03b2\u2208S\u03bb\n\u2016x\u2032 \u2212D\u03b2\u20162Kh1(\u03c1(x, x\u2032)) dPn(x\u2032) dx\nand its population version is\nE P(r) =\n\u222b\u222b\nmin \u03b2\u2208S\u03bb\n\u2016x\u2032 \u2212D\u03b2\u20162Kh1(\u03c1(x, x\u2032)) dP(x\u2032) dx.\nOur goal is to show that the sample reconstruction error is close to the true reconstruction error. Specifically, to show E P(r\u03bb) \u2264 (1+\u03ba)E Pn(r\u03bb)+\u01eb where \u01eb, \u03ba \u2265 0, we bound the covering number of the class of functions corresponding to the reconstruction error. We assume a dictionary of bounded babel function, which holds as a result of the relaxed orthogonality constraint used in the Algorithm 1 (see also [17]). We define the set of r functions with respect the the dictionary D (assuming data lies in the unit d-dimensional ball Sd\u22121) by\nF\u03bb = {r\u03bb : Sd\u22121 \u2192 R : D \u2208 Rd\u00d7K , \u2016di\u20162 \u2264 1, \u00b5s(D) \u2264 \u03b3}.\nThe following theorem bounds the covering number of the above function class.\nTheorem 5.1. For every \u01eb > 0, the metric space (F\u03bb, | \u00b7 |\u221e) has a subset of cardinality at most ( 4\u03bb|Kh1 (\u00b7)|1 \u01eb(1\u2212\u03b3)\n)dK\n, such\nthat every element from the class is at a distance of at most \u01eb from the subset, where |Kh1(\u00b7)|1 = \u222b |Kh1(x)| dP.\nProof. Let F \u2032\u03bb = {r\u2032\u03bb : Sd\u22121 \u2192 R : D \u2208 d\u00d7K, \u2016di\u20162 \u2264 1}, where r\u2032\u03bb(x) = min\u03b2\u2208S\u03bb \u2016D\u03b2 \u2212 x\u2016. With this definition we note that F\u03bb is just F \u2032\u03bb convolved with the kernel Kh1(\u00b7). By Young\u2019s inequality [4] we have,\n|Kh1 \u2217 (s1 \u2212 s2)|p \u2264 |Kh1 |1|s1 \u2212 s2|p, 1 \u2264 p \u2264 \u221e\nfor any Lp integrable functions s1 and s2. Using this fact, we see that convolution mapping between metric spaces F \u2032 and F converts \u01eb|Kh1(\u00b7)|1 covers into \u01eb covers. From [20], we have that the the class F \u2032 \u03bb has \u01eb covers of size at most ( 4\u03bb\u01eb(1\u2212\u03b3)) dK . This proves the the statement of the theorem.\nThis leads to the following generalization bound for the smooth sparse coding.\nTheorem 5.2. Let \u03b3 < 1, \u03bb > e/4 with distribution P on Sd\u22121. Then with probability at least 1 \u2212 e\u2212t over the n samples drawn according to P, for all the D with unit length columns and \u00b5s(D) \u2264 \u03b3, we have:\nE P(r\u03bb) \u2264 E Pn(r\u03bb) +\n\u221a \u221a \u221a \u221a dK ln ( 4 \u221a n\u03bb|Kh1 (\u00b7)|1 (1\u2212\u03b3) )\n2n +\n\u221a\nt\n2n +\n\u221a\n4\nn\nThe above theorem follows from the previous covering number bound and the following lemma for generalization bound that is based on the result in [20] concerning | \u00b7 |\u221e covering numbers.\nLemma 1. Let Q be a function class of [0, B] functions with covering number (C\u01eb )d > eB2 under | \u00b7 |\u221e norm. Then for every t > 0 with probability at least 1\u2212 e\u2212t, for all q \u2208 Q, we have:\nE f \u2264 Enf +B ( \u221a\nd ln(C \u221a n)\n2n +\nt\n2n\n)\n+\n\u221a\n4 n .\nThe above theorem, shows that the generalization error scales as O(n\u22121/2) (assuming the other problem parameters fixed). In the case of \u03ba > 0, it is possible to obtain faster rates of O(n\u22121) for smooth sparse coding, similar to derivations in [1]. The following theorem gives the precise statement.\nTheorem 5.3. Let \u03b3 < 1, \u03bb > e/4, dK > 20 and n \u2265 5000. Then with probability at least 1\u2212 e\u2212t, we have for all D with unit length and \u00b5s(D) \u2264 \u03b3,\nE P(r\u03bb) \u2264 1.1E Pn(r\u03bb) + 9 dK ln\n(\n4n\u03bb|Kh1(\u00b7)|1 (1\u2212\u03b3)\n)\n+ t\nn .\nThe above theorem follows from the covering number bound above and Proposition 22 from [20]. The definition of r\u03bb(x) differs from (1) by a square term, but it could easily be incorporated into the above bounds resulting in an additive factor of 2 inside the logarithm term."}, {"heading": "6 Experiments", "text": "We demonstrate the advantage of the proposed approach both in terms of speed-up and accuracy, over standard sparse coding. A detailed description of all real-world data sets used in the experiments are given in the appendix."}, {"heading": "6.1 Speed comparison", "text": "We conducted synthetic experiments to examine the speed-up provided by sparse coding with marginal regression. The data was generated from a a 100 dimensional mixture of two Gaussian distribution that satisfies \u2016\u00b51 \u2212 \u00b52\u20162 = 3 (with identity covariance matrices). The dictionary size was fixed at 1024.\nWe compare the proposed smooth sparse coding algorithm, standard sparse coding with lasso [11] and marginal regression updates respectively, with a relative reconstruction error \u2016X \u2212 D\u0302B\u0302\u2016F /\u2016X\u2016F convergence criterion. We experimented with different values of the relative reconstruction error (less than 10%) and report the average time. From Table 1, we see that smooth sparse coding with marginal regression takes significantly less time to achieve a fixed reconstruction error. This is due to the fact that it takes advantage of the spatial structure and use marginal regression updates. It is worth mentioning that standard sparse coding with marginal regression updates performs faster compared to the other two methods that uses lasso updates, as expected (but does not take into account the spatial structure)."}, {"heading": "6.2 Experiments with Kernel in Feature space", "text": "We conducted several experiments demonstrating the advantage of the proposed coding scheme in different settings. Concentrating on face and object recognition from static images, we evaluated the performance of the proposed approach along with standard sparse coding and LLC [26], another method for obtaining sparse features based on locality. Also, we performed experiments on activity recognition from videos based on both space and time based kernels. As mentioned before all results are reported using tricube kernel."}, {"heading": "6.2.1 Image classification", "text": "We conducted image classification experiments on CMU-multipie, 15 Scene and Caltech-101 data sets. Following [24] , we used the following approach for generating sparse image representation: we densely sampled 16 \u00d7 16 patches from images at the pixel level on a gird with step size 8 pixels, computed SIFT features, and then computed the corresponding sparse codes over a 1024-size dictionary. We used max pooling to get the final representation of the image based on the codes for the patches. The process was repeated with different randomly selected training and testing images and we report the average per-class recognition rates (together with its standard deviation estimate) based on one-vs-all SVM classification. We used cross validation to select the regularization and bandwidth parameters.\nAs Table 2 indicates, our smooth sparse coding algorihtm resulted in significantly higher classification accuracy than standard sparse coding and LLC. In fact, the reported performance is better than previous reported results using unsupervised sparse coding techniques [24].\nDictionary size: In order to demonstrate the use of scalability of the proposed method with respect to dictionary size, we report classification accuracy with increasing dictionary sizes using smooth sparse coding. The main advantage of the proposed marginal regression training method is that one could easily run experiments with larger dictionary sizes, which typically takes a significantly longer time for other algorithms. For both the Caltech-101 and 15-scene data set, classification accuracy increases significantly with increasing dictionary sizes as seen in Table 3."}, {"heading": "6.2.2 Action recognition:", "text": "We further conducted an experiment on activity recognition from videos with KTH action and YouTube data set (see Appendix). Similar to the static image case, we follow the standard approach for generating sparse representations for videos as in [21]. We densely sample 16\u00d7 16\u00d7 10 blocks from the video and extract HoG-3d [10] features from the sampled blocks. We then use smooth sparse coding and max-pooling to generate the video representation (dictionary size was fixed at 1024 and cross-validation was used to select the regularization and bandwidth parameters). Previous approaches include sparse coding, vector quantization, and k-means on top of the HoG-3d feature set (see [21] for a comprehensive evaluation). As indicated by Table 4, smooth sparse coding results in higher classification accuracy than previously reported state-of-the-art and standard sparse coding on both datasets (see [21, 12] for a description of the alternative techniques)."}, {"heading": "6.2.3 Discriminatory power", "text": "In this section, we describe another experiment that contrasts the codes obtained by sparse coding and smooth sparse coding in the context of a subsequent classification task. As in [25], we first compute the codes in both case based on patches and combine it with max-pooling to obtain the image level representation. We then compute the fisher discriminant score (ratio of within-class variance to between-class variance) for each dimension as measures of the discrimination power realized by the representations.\nFigure 1, graphs a histogram of the ratio of smooth sparse coding Fisher score over standard sparse coding Fisher score R(d) = F1(d)/F2(d) for 15-scene dataset (left) and Youtube dataset (right). Both histograms demonstrate the improved discriminatory power of smooth sparse coding over regular sparse coding."}, {"heading": "6.3 Experiments using Temporal Smoothing", "text": "In this section we describe an experiment conducted using the temporal smoothing kernel on the Youtube persons dataset. We extracted SIFT descriptors for every 16 \u00d7 16 patches sampled on a grid of step size 8 and used smooth sparse coding with time kernel to learn the codes and max pooling to get the final video representation. We avoided pre-processing steps such as face extraction or face tracking. Note that in the previous action recognition video experiment, video blocks were densely sampled and used for extracting HoG-3d features. In this experiment, on the other hand, we extracted SIFT features from individual frames and used the time kernels to incorporate the temporal information into the sparse coding process.\nFor this case, we also compared to the more standard fused-lasso based approach [18]. Note that in fused Lasso based approach, in addition to the standard L1 penalty, an additional L1 penalty on the difference between the neighboring frames for each dimensions is used. This tries to enforce the assumption that in a video sequence, neighboring frames are more related to one another as compared to frames that are farther apart.\nTable 5 shows that smooth sparse coding achieved higher accuracy than fused lasso and standard sparse coding. Smooth sparse coding has comparable accuracy on person recognition tasks to other methods that use face-tracking,\nfor example [9]. Another advantage of smooth sparse coding is that it is significantly faster than sparse coding and the used lasso."}, {"heading": "7 Semi-supervised smooth sparse coding", "text": "One of the primary difficulties in some image classification tasks is the lack of availability of labeled data and in some cases, both labeled and unlabeled data (for particular domains). This motivated semi-supervised learning and transfer learning without labels [16] respectively. The motivation for such approaches is that data from a related domain might have some visual patterns that might be similar to the problem at hand. Hence, learning a high-level dictionary based on data from a different domains aids the classification task of interest.\nWe propose that the smooth sparse coding approach might be useful in this setting. The motivation is as follows: in semi-supervised, typically not all samples from a different data set might be useful for the task at hand. Using smooth sparse coding, one can weigh the useful points more than the other points (the weights being calculated based on feature/time similarity kernel) to obtain better dictionaries and sparse representations. Other approach to handle a lower number of labeled samples include collaborative modeling or multi-task approaches which impose a shared structure on the codes for several tasks and use data from all the tasks simultaneously, for example group sparse coding [2]. The proposed approach provides an alternative when such collaborative modeling assumptions do not hold, by using relevant unlabeled data samples that might help the task at hand via appropriate weighting.\nWe now describe an experiment that examines the proposed smoothed sparse coding approach in the context of semi-supervised dictionary learning. We use data from both CMU multi-pie dataset (session 1) and faces-on-tv dataset (treated as frames) to learn a dictionary using a feature similarity kernel. We follow the same procedure described in the previous experiments to construct the dictionary. In the test stage we use the obtained dictionary for coding data from sessions 2, 3, 4 of CMU-multipie data set, using smooth sparse coding. Note that semi-supervision was used only in the dictionary learning stage (the classification stage used supervised SVM).\nTable 6 shows the test set error rate and compares it to standard sparse coding and LLC [26]. Smooth sparse coding achieves significantly lower test error rate than the two alternative techniques. We conclude that the smoothing approach described in this paper may be useful in cases where there is a small set of labeled data, such as semisupervised\nlearning and transfer learning."}, {"heading": "8 Discussion and Future work", "text": "We proposed a simple framework for incorporating similarity in feature space and space or time into sparse coding. The codes obtained by smooth sparse coding are significantly more discriminatory than traditional sparse coding, and lead to substantially improved classification accuracy as measured on several different image and video classification tasks.\nWe also propose in this paper modifying sparse coding by replacing the lasso optimization stage by marginal regression and adding a constraint to enforce incoherent dictionaries. The resulting algorithm is significantly faster (speedup of about two-orders of magnitude over standard sparse coding). This facilitates scaling up the sparse coding framework to large dictionaries, an area which is usually restricted due to intractable computation. We also explore promising extensions to temporal smoothing, semi-supervised learning and transfer learning. We provide bounds on the covering numbers that lead to generalization bounds for the smooth sparse coding dictionary learning problem.\nThere are several ways in which the proposed approach can be extended. First, using an adaptive or non-constant kernel bandwidth should lead to higher accuracy. It is also interesting to explore tighter generalization error bounds by directly analyzing the solutions of the marginal regression iterative algorithm. Another potentially useful direction is to explore alternative incoherence constraints that lead to easier optimization and scaling up."}, {"heading": "9 Appendix", "text": ""}, {"heading": "9.1 Data set Description", "text": ""}, {"heading": "9.1.1 CMU Multi-pie face recognition:", "text": "The face recognition experiment was conducted on the CMU Multi-PIE dataset. The dataset is challenging due to the large number of subjects and is one of the standard data sets used for face recognition experiments. The data set contains 337 subjects across simultaneous variations in pose, expression, and illumination. We ignore the 88 subjects that were considered as outliers in [24] and used the rest of the images for our face recognition experiments. We follow [24] and use the 7 frontal extreme illuminations from session one as train set and use other 20 illuminations from Sessions 2-4 as test set."}, {"heading": "9.1.2 15 Scenes Categorization:", "text": "We also conducted scene classification experiments on the 15-Scenes data set. This data set consist of 4485 images from 15 categories, with the number of images each category ranging from 200 to 400. The categories corresponds to scenes from various settings like kitchen, living room etc. Similar to the previous experiment, we extracted patches from the images and computed the SIFT features corresponding to the patches."}, {"heading": "9.1.3 Caltech-101 Data set:", "text": "The Caltech-101 data set consists of images from 101 classes like animals, vehicles, flowers, etc. The number of images per category varies from 30 to 800. Most images are of medium resolution (300\u00d7300). All images are used a gray-scale images. Following previous standard experimental settings for Caltech-101 data set, we use 30 images per category and test on the rest. Average classification accuracy normalized by class frequency is used for evaluation."}, {"heading": "9.1.4 Activity recognition", "text": "The KTH action dataset consists of 6 human action classes. Each action is performed several times by 25 subjects and is recorded in four different scenarios. In total, the data consists of 2391 video samples. The YouTube actions data set has 11 action categories and is more complex and challenging [12]. It has 1168 video sequences of varied illumination, background, resolution etc. We randomly densely sample blocks (400 cuboids) of video from the data sample and extract HOG-3d features and constructed the video features as described above."}, {"heading": "9.1.5 Youtube person data set", "text": "Similar to the experiments using the feature smoothing kernel, in this section we report results on experiment conducted using the time smoothed kernel. Specifically, we used the YouTube person data set [9] in order to recognize people, based on time-based kernel smooth sparse coding. The dataset contains 1910 sequences of 47 subjects. The architecture for this dataset is similar to [23]."}], "references": [{"title": "Local rademacher complexities", "author": ["P.L. Bartlett", "O. Bousquet", "S. Mendelson"], "venue": "The Annals of Statistics,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2005}, {"title": "Group sparse coding", "author": ["S. Bengio", "F. Pereira", "Y. Singer", "D. Strelow"], "venue": "In NIPS,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Learning efficient structured sparse models", "author": ["A. Bronstein", "P. Sprechmann", "G. Sapiro"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "Combinatorial methods in density estimation", "author": ["L. Devroye", "G. Lugosi"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2001}, {"title": "Sure independence screening for ultrahigh dimensional feature space", "author": ["J. Fan", "J. Lv"], "venue": "JRSS: B(Statistical Methodology),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "A comparison of the lasso and marginal regression", "author": ["C.R. Genovese", "J. Jin", "L. Wasserman", "Z. Yao"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Local regression: Automatic kernel carpentry", "author": ["T. Hastie", "C. Loader"], "venue": "Statistical Science,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1993}, {"title": "Proximal methods for sparse hierarchical dictionary learning", "author": ["R. Jenatton", "J. Mairal", "G. Obozinski", "F. Bach"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Face tracking and recognition with visual constraints in real-world videos", "author": ["M. Kim", "S. Kumar", "V. Pavlovic", "H. Rowley"], "venue": "In CVPR,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2008}, {"title": "A spatio-temporal descriptor based on 3d-gradients", "author": ["A. Kl\u00e4ser", "M. Marsza lek", "C. Schmid"], "venue": "In BMVC,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "Efficient sparse coding algorithms", "author": ["H. Lee", "A. Battle", "R. Raina", "A.Y. Ng"], "venue": "In NIPS,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2007}, {"title": "Recognizing realistic actions from videos in the wild", "author": ["J. Liu", "J. Luo", "M. Shah"], "venue": "In CVPR,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2009}, {"title": "Local regression and likelihood", "author": ["C. Loader"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1999}, {"title": "Smoothing l1-penalized estimators for high-dimensional time-course data", "author": ["L. Meier", "P. B\u00fchlmann"], "venue": "Electronic Journal of Statistics,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2007}, {"title": "Self-taught learning: transfer learning from unlabeled data", "author": ["R. Raina", "A. Battle", "H. Lee", "B. Packer", "A.Y. Ng"], "venue": "In ICML,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Sparse modeling with universal priors and learned incoherent dictionaries", "author": ["I. Ram\u0131rez", "F. Lecumberry", "G. Sapiro"], "venue": "Tech Report, IMA, University of Minnesota,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "Sparsity and smoothness via the fused lasso", "author": ["R. Tibshirani", "M. Saunders", "S. Rosset", "J. Zhu", "K. Knight"], "venue": "JRSS:B,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2005}, {"title": "Greed is good: Algorithmic results for sparse approximation", "author": ["J.A. Tropp"], "venue": "Information Theory, IEEE,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2004}, {"title": "The sample complexity of dictionary learning", "author": ["D. Vainsencher", "S. Mannor", "A.M. Bruckstein"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2011}, {"title": "Evaluation of local spatio-temporal features for action recognition", "author": ["H. Wang", "M.M. Ullah", "A. Klaser", "I. Laptev", "C. Schmid"], "venue": "In BMVC,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2009}, {"title": "Robust face recognition via sparse representation", "author": ["J. Wright", "A.Y. Yang", "A. Ganesh", "S.S. Sastry", "Y. Ma"], "venue": "IEEE PAMI,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2008}, {"title": "Linear spatial pyramid matching using sparse coding for image classification", "author": ["J. Yang", "K. Yu", "Y. Gong", "T. Huang"], "venue": "In CVPR,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2009}, {"title": "Supervised translation-invariant sparse coding", "author": ["J. Yang", "K. Yu", "T. Huang"], "venue": "In CVPR. IEEE,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2010}, {"title": "Learning image representations from the pixel level via hierarchical sparse coding", "author": ["K. Yu", "Y. Lin", "J. Lafferty"], "venue": "In CVPR,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2011}, {"title": "Nonlinear learning using local coordinate coding", "author": ["K. Yu", "T. Zhang", "Y. Gong"], "venue": null, "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2009}, {"title": "Nonlinear programming: a unified approach", "author": ["W.I. Zangwill"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1969}], "referenceMentions": [{"referenceID": 20, "context": "While efficient algorithms for such cases exist [22, 11], their scalability for large dictionaries remains a challenge.", "startOffset": 48, "endOffset": 56}, {"referenceID": 10, "context": "While efficient algorithms for such cases exist [22, 11], their scalability for large dictionaries remains a challenge.", "startOffset": 48, "endOffset": 56}, {"referenceID": 18, "context": "We further develop theory that extends the sample complexity result of [20] for dictionary learning using standard sparse coding to the smooth sparse coding case.", "startOffset": 71, "endOffset": 75}, {"referenceID": 12, "context": "2 Related work Our approach is related to the local regression method [13, 7].", "startOffset": 70, "endOffset": 77}, {"referenceID": 6, "context": "2 Related work Our approach is related to the local regression method [13, 7].", "startOffset": 70, "endOffset": 77}, {"referenceID": 13, "context": "More recent related work is [15] that uses smoothing techniques in high-dimensional lasso regression in the context of temporal data.", "startOffset": 28, "endOffset": 32}, {"referenceID": 24, "context": "Another recent approach proposed by [26] achieves code locality by approximating data points using a linear combination of nearby basis points.", "startOffset": 36, "endOffset": 40}, {"referenceID": 4, "context": "Marginal regression is a relatively old technique that has recently reemerged as a computationally faster alternative to lasso regression [5].", "startOffset": 138, "endOffset": 141}, {"referenceID": 5, "context": "See also [6] for a statistical comparison of lasso regression and marginal regression.", "startOffset": 9, "endOffset": 12}, {"referenceID": 2, "context": ", [3, 8].", "startOffset": 2, "endOffset": 8}, {"referenceID": 7, "context": ", [3, 8].", "startOffset": 2, "endOffset": 8}, {"referenceID": 3, "context": "The smooth sparse coding setting leads to codes that represent a neighborhood rather than an individual sample and that have lower mean square reconstruction error (with respect to a given dictionary), due to lower estimation variance (see for example the standard theory of smoothed empirical process [4]).", "startOffset": 302, "endOffset": 305}, {"referenceID": 4, "context": "A comparison of the statistical properties of marginal regression and lasso is available in [5, 6].", "startOffset": 92, "endOffset": 98}, {"referenceID": 5, "context": "A comparison of the statistical properties of marginal regression and lasso is available in [5, 6].", "startOffset": 92, "endOffset": 98}, {"referenceID": 2, "context": "Note that the same approach could be used with structured regularizers too, for example [3, 8].", "startOffset": 88, "endOffset": 94}, {"referenceID": 7, "context": "Note that the same approach could be used with structured regularizers too, for example [3, 8].", "startOffset": 88, "endOffset": 94}, {"referenceID": 5, "context": "In the linear regression setting, marginal regression performs much better with orthogonal data [6].", "startOffset": 96, "endOffset": 99}, {"referenceID": 17, "context": "In the context of sparse coding, this corresponds to having uncorrelated or incoherent dictionaries [19].", "startOffset": 100, "endOffset": 104}, {"referenceID": 15, "context": "We use the method of optimal directions update [17] to solve the above optimization problem.", "startOffset": 47, "endOffset": 51}, {"referenceID": 25, "context": "A sequence of such updates corresponding to step (i) and step (ii) converges to a stationary point of the optimization problem (this can be shown using Zangwill\u2019s theorem [27]).", "startOffset": 171, "endOffset": 175}, {"referenceID": 18, "context": "We leverage the analysis for dictionary learning in the standard sparse coding setting by [20] and extend it to the smooth sparse coding setting.", "startOffset": 90, "endOffset": 94}, {"referenceID": 15, "context": "We assume a dictionary of bounded babel function, which holds as a result of the relaxed orthogonality constraint used in the Algorithm 1 (see also [17]).", "startOffset": 148, "endOffset": 152}, {"referenceID": 3, "context": "By Young\u2019s inequality [4] we have, |Kh1 \u2217 (s1 \u2212 s2)|p \u2264 |Kh1 |1|s1 \u2212 s2|p, 1 \u2264 p \u2264 \u221e for any Lp integrable functions s1 and s2.", "startOffset": 22, "endOffset": 25}, {"referenceID": 18, "context": "From [20], we have that the the class F \u2032 \u03bb has \u01eb covers of size at most ( 4\u03bb \u01eb(1\u2212\u03b3)) dK .", "startOffset": 5, "endOffset": 9}, {"referenceID": 18, "context": "4 n The above theorem follows from the previous covering number bound and the following lemma for generalization bound that is based on the result in [20] concerning | \u00b7 |\u221e covering numbers.", "startOffset": 150, "endOffset": 154}, {"referenceID": 0, "context": "In the case of \u03ba > 0, it is possible to obtain faster rates of O(n\u22121) for smooth sparse coding, similar to derivations in [1].", "startOffset": 122, "endOffset": 125}, {"referenceID": 18, "context": "The above theorem follows from the covering number bound above and Proposition 22 from [20].", "startOffset": 87, "endOffset": 91}, {"referenceID": 10, "context": "We compare the proposed smooth sparse coding algorithm, standard sparse coding with lasso [11] and marginal regression updates respectively, with a relative reconstruction error \u2016X \u2212 D\u0302B\u0302\u2016F /\u2016X\u2016F convergence criterion.", "startOffset": 90, "endOffset": 94}, {"referenceID": 24, "context": "Concentrating on face and object recognition from static images, we evaluated the performance of the proposed approach along with standard sparse coding and LLC [26], another method for obtaining sparse features based on locality.", "startOffset": 161, "endOffset": 165}, {"referenceID": 22, "context": "Following [24] , we used the following approach for generating sparse image representation: we densely sampled 16 \u00d7 16 patches from images at the pixel level on a gird with step size 8 pixels, computed SIFT features, and then computed the corresponding sparse codes over a 1024-size dictionary.", "startOffset": 10, "endOffset": 14}, {"referenceID": 22, "context": "In fact, the reported performance is better than previous reported results using unsupervised sparse coding techniques [24].", "startOffset": 119, "endOffset": 123}, {"referenceID": 19, "context": "Similar to the static image case, we follow the standard approach for generating sparse representations for videos as in [21].", "startOffset": 121, "endOffset": 125}, {"referenceID": 9, "context": "We densely sample 16\u00d7 16\u00d7 10 blocks from the video and extract HoG-3d [10] features from the sampled blocks.", "startOffset": 70, "endOffset": 74}, {"referenceID": 19, "context": "Previous approaches include sparse coding, vector quantization, and k-means on top of the HoG-3d feature set (see [21] for a comprehensive evaluation).", "startOffset": 114, "endOffset": 118}, {"referenceID": 19, "context": "As indicated by Table 4, smooth sparse coding results in higher classification accuracy than previously reported state-of-the-art and standard sparse coding on both datasets (see [21, 12] for a description of the alternative techniques).", "startOffset": 179, "endOffset": 187}, {"referenceID": 11, "context": "As indicated by Table 4, smooth sparse coding results in higher classification accuracy than previously reported state-of-the-art and standard sparse coding on both datasets (see [21, 12] for a description of the alternative techniques).", "startOffset": 179, "endOffset": 187}, {"referenceID": 23, "context": "As in [25], we first compute the codes in both case based on patches and combine it with max-pooling to obtain the image level representation.", "startOffset": 6, "endOffset": 10}, {"referenceID": 16, "context": "For this case, we also compared to the more standard fused-lasso based approach [18].", "startOffset": 80, "endOffset": 84}, {"referenceID": 19, "context": "10 [21] 92.", "startOffset": 3, "endOffset": 7}, {"referenceID": 11, "context": "2 [12] 72.", "startOffset": 2, "endOffset": 6}, {"referenceID": 8, "context": "for example [9].", "startOffset": 12, "endOffset": 15}, {"referenceID": 14, "context": "This motivated semi-supervised learning and transfer learning without labels [16] respectively.", "startOffset": 77, "endOffset": 81}, {"referenceID": 1, "context": "Other approach to handle a lower number of labeled samples include collaborative modeling or multi-task approaches which impose a shared structure on the codes for several tasks and use data from all the tasks simultaneously, for example group sparse coding [2].", "startOffset": 258, "endOffset": 261}, {"referenceID": 24, "context": "Table 6 shows the test set error rate and compares it to standard sparse coding and LLC [26].", "startOffset": 88, "endOffset": 92}], "year": 2012, "abstractText": "We propose and analyze a novel framework for learning sparse representations, based on two statistical techniques: kernel smoothing and marginal regression. The proposed approach provides a flexible framework for incorporating feature similarity or temporal information present in data sets, via non-parametric kernel smoothing. We provide generalization bounds for dictionary learning using smooth sparse coding and show how the sample complexity depends on the L1 norm of kernel function used. Furthermore, we propose using marginal regression for obtaining sparse codes, which significantly improves the speed and allows one to scale to large dictionary sizes easily. We demonstrate the advantages of the proposed approach, both in terms of accuracy and speed by extensive experimentation on several real data sets. In addition, we demonstrate how the proposed approach could be used for improving semi-supervised sparse coding.", "creator": "LaTeX with hyperref package"}}}