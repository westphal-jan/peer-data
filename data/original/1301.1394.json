{"id": "1301.1394", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Lloyd-Topor Completion and General Stable Models", "abstract": "We investigate the relationship between the generalization of program completion defined in 1984 by Lloyd and Topor and the generalization of the stable model semantics introduced recently by Ferraris et al. The main theorem can be used to characterize, in some cases, the general stable models of a logic program by a first-order formula. The proof uses Truszczynski's stable model semantics of infinitary propositional formulas.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:55 GMT  (27kb,D)", "http://arxiv.org/abs/1301.1394v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["vladimir lifschitz", "fangkai yang"], "accepted": false, "id": "1301.1394"}, "pdf": {"name": "1301.1394.pdf", "metadata": {"source": "CRF", "title": "Lloyd-Topor Completion and General Stable Models", "authors": ["Vladimir Lifschitz", "Fangkai Yang"], "emails": ["vl@cs.utexas.edu", "fkyang@cs.utexas.edu"], "sections": [{"heading": "1 Introduction", "text": "The theorem by Franc\u0327ois Fages [1] describing a case when the stable model semantics is equivalent to program completion is one of the most important results in the theory of stable models. It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.\nThe general stable model semantics defined in [6] characterizes the stable models of a first-order sentence F as arbitrary models of a certain second-order sentence, denoted by SM[F ];1 logic programs are viewed there as first-order sentences written in \u201clogic programming notation.\u201d In this note we define an extension of Fages\u2019 theorem that can be used as a tool for transforming SM[F ], in some cases, into an equivalent first-order formula. That extension refers to the version of program completion introduced by John Lloyd and Rodney Topor in [7]. Their definition allows the body of a rule to contain propositional connectives and quantifiers.\nEarlier work in this direction is reported in [6] and [8]. These papers do not mention completion in the sense of Lloyd and Topor explicitly. Instead, they discuss ways to convert a logic program to \u201cClark normal form\u201d by strongly equivalent transformations [9,10] and completing programs in this normal form by replacing implications with equivalences. But this is essentially what Lloyd-Topor completion does.\nThe following examples illustrate some of the issues involved. Let F be the program\np(a), q(b), p(x)\u2190 q(x),\n(1)\n1 To be precise, the definition of SM in that paper requires that a set of \u201cintensional predicates\u201d be specified. In the examples below, we assume that all predicate symbols occurring in F are intensional.\nar X\niv :1\n30 1.\n13 94\nv1 [\ncs .L\nO ]\n8 J\nan 2\n01 3\nor, in other words, the sentence\np(a) \u2227 q(b) \u2227 \u2200x(q(x)\u2192 p(x)).\nThe Clark normal form of (1) is tight in the sense of [6], and Theorem 11 from that paper shows that SM[F ] in this case is equivalent to the conjunction of the completed definitions of p and q:\n\u2200x(p(x)\u2194 x = a \u2228 q(x)), \u2200x(q(x)\u2194 x = b). (2)\nLet now F be the program p(x)\u2190 q(x), q(a)\u2190 p(b). (3)\nThis program is not tight in the sense of [6], so that the above-mentioned theorem is not applicable. In fact, SM[F ] is stronger in this case than the conjunction of the completed definitions\n\u2200x(p(x)\u2194 q(x)), \u2200x(q(x)\u2194 x = a \u2227 p(b)). (4)\nA counterexample is provided by any interpretation that treats each of the symbols p, q as a singleton such that its element is equal to both a and b. Such a (non-Herbrand) interpretation satisfies (4), but it is not a stable model of (3). (In stable models of (3) both p and q are empty.)\nProgram (3) is, however, atomic-tight in the sense of [8, Section 5.1.1]. Corollary 5 from that paper allows us to conclude that the equivalence between SM[F ] and (4) is entailed by the unique name assumption a 6= b. It follows that the result of applying SM to the program obtained from (4) by adding the constraint\n\u2190 a = b\nis equivalent to the conjunction of the completion sentences (4) with a 6= b. This example illustrates the role of a property more general than the logical equivalence between SM[F ] and the completion of F : it may be useful to know when the equivalence between these two formulas is entailed by a certain set of assumptions. This information may be relevant if we are interested in a logic program obtained from F by adding constraints.\nThe result of applying SM to the program\np(a)\u2190 p(b), q(c)\u2190 q(d), \u2190 a = b, \u2190 c = d\n(5)\nis equivalent to the conjunction of the formulas\n\u2200x(p(x)\u2194 x = a \u2227 p(b)), \u2200x(q(x)\u2194 x = c \u2227 q(d)),\na 6= b, c 6= d.\n(6)\nThis claim cannot be justified, however, by a reference to Corollary 5 from [8]. The program in this example is atomic-tight, but it does not contain constraints corresponding to some of the unique name axioms, for instance a 6= c. We will show how our claim follows from the main theorem stated below.\nWe will discuss also an example illustrating limitations of earlier work that is related to describing dynamic domains in answer set programming (ASP). The program in that example is not atomic-tight because of rules expressing the commonsense law of inertia. We will show nevertheless that the process of completion can be used to characterize its stable models by a first-order formula.\nThe class of tight programs is defined in [6] in terms of predicate dependency graphs; that definition is reproduced in Section 3 below. The definition of an atomictight program in [8] refers to more informative \u201cfirst-order dependency graphs.\u201d Our approach is based on an alternative solution to the problem of making predicate dependency graphs more informative, \u201crule dependency graphs.\u201d\nAfter reviewing some background material in Sections 2 and 3, we define rule dependency graphs in Section 4, state the main theorem and give examples of its use in Sections 5 and 6, and outline its proof in Sections 7 and 8."}, {"heading": "2 Review: Operator SM, Lloyd-Topor Programs, and Completion", "text": "In this paper, a formula is a first-order formula that may contain the propositional connectives\u22a5 (logical falsity), \u2227, \u2228, and\u2192, and the quantifiers \u2200, \u2203. We treat \u00acF as an abbreviation for F \u2192 \u22a5; > stands for \u22a5 \u2192 \u22a5; F \u2194 G stands for (F \u2192 G)\u2227 (G\u2192 F ).\nFor any first-order sentence F and any tuple p of distinct predicate constants (other than equality) SMp[F ] is the conjunction of F with a second-order \u201dstability condition\u201d; see [6, Section 2] for details. The members of p are called intensional, and the other predicate constants are extensional. We will drop the subscript in the symbol SMp when p is the list of all predicate symbols occurring in F . For any sentence F , a p-stable (or simply stable) model of F is an interpretation of the underlying signature that satisfies SMp[F ].\nA Lloyd-Topor program is a finite set of rules of the form\np(t)\u2190 G, (7)\nwhere t is a tuple of terms, and G is a formula. We will identify a program with the sentence obtained by conjoining the formulas\n\u2200\u0303(G\u2192 p(t))\nfor all its rules (7). (\u2200\u0303F stands for the universal closure of F .) Let \u03a0 be a Lloyd-Topor program, and p a predicate constant (other than equality). Let p(ti)\u2190 Gi (i = 1, 2, . . . ) (8)\nbe all rules of \u03a0 that contain p in the head. The definition of p in \u03a0 is the rule p(x)\u2190 \u2228 i \u2203yi(x = ti \u2227Gi), (9)\nwhere x is a list of distinct variables not appearing in any of the rules (8), and yi is the list of free variables of (8).2 The completed definition of p in \u03a0 is the formula\n\u2200x ( p(x)\u2194\n\u2228 i \u2203yi(x = ti \u2227Gi)\n) . (10)\nFor instance, the completed definitions of p and q in program (1) are the formulas\n\u2200x1(p(x1)\u2194 x1 = a \u2228 \u2203x(x1 = x \u2227 q(x))), \u2200x1(q(x1)\u2194 x1 = b),\nwhich can be equivalently rewritten as (2). By Comp[\u03a0] we denote the conjunction of the completed definitions of all predicate constants p in \u03a0 . This sentence is similar to the completion of \u03a0 in the sense of [7, Section 2], except that it does not include Clark equality axioms."}, {"heading": "3 Review: Tight Programs", "text": "We will review now the definition of tightness from [6, Section 7.3]. In application to a Lloyd-Topor program \u03a0 , when all predicate constants occurring in \u03a0 are treated as intensional, that definition can be stated as follows.\nAn occurrence of an expression in a first-order formula is negated if it belongs to a subformula of the form \u00acF (that is, F \u2192 \u22a5), and nonnegated otherwise. The predicate dependency graph of \u03a0 is the directed graph that has\n\u2013 all predicate constants occurring in \u03a0 as its vertices, and \u2013 an edge from p to q whenever \u03a0 contains a rule (7) with p in the head such that its\nbody G has a positive3 nonnegated occurrence of q.\nWe say that \u03a0 is tight if the predicate dependency graph of \u03a0 is acyclic. For example, the predicate dependency graph of program (1) has a single edge, from p to q. The predicate dependency graph of program (3) has two edges, from p to q and from q to p. The predicate dependency graph of the program\np(a, b) q(x, y)\u2190 p(y, x) \u2227 \u00acp(x, y) (11)\nhas a single edge, from q to p (because one of the occurrences of p in the body of the second rule is nonnegated). The predicate dependency graph of the program\np(x)\u2190 q(x), q(x)\u2190 r(x), r(x)\u2190 s(x)\n(12)\n2 By x = ti we denote the conjunction of the equalities between members of the tuple x and the corresponding members of the tuple ti. 3 Recall that an occurrence of an expression in a first-order formula is called positive if the number of implications containing that occurrence in the antecedent is even.\nhas 3 edges: p \u2212\u2192 q \u2212\u2192 r \u2212\u2192 s.\nPrograms (1), (11) and (12) are tight; program (3) is not.\nProposition 1. If a Lloyd-Topor program \u03a0 is tight then SM[\u03a0] is equivalent to Comp[\u03a0].\nThis is an easy corollary to the theorem from [6] mentioned in the introduction. Indeed, consider the set\u03a0 \u2032 of the definitions (9) of all predicate constants p in\u03a0 . It can be viewed as a formula in Clark normal form in the sense of [6, Section 6.1]. It is tight, because it has the same predicate dependency graph as \u03a0 . By Theorem 11 from [6], SM[\u03a0 \u2032] is equivalent to the completion of \u03a0 \u2032 in the sense of [6, Section 6.1], which is identical to Comp[\u03a0]. It remains to observe that\u03a0 is intuitionistically equivalent to\u03a0 \u2032, so that SM[\u03a0] is equivalent to SM[\u03a0 \u2032] [6, Section 5.1]."}, {"heading": "4 Rule Dependency Graph", "text": "We are interested in conditions on a Lloyd-Topor program \u03a0 ensuring that the equivalence\nSM[\u03a0]\u2194 Comp[\u03a0]\nis entailed by a given set of assumptions \u0393 . Proposition 1 gives a solution for the special case when \u0393 is empty. The following definition will help us answer the more general question.\nThe rule dependency graph of a Lloyd-Topor program \u03a0 is the directed graph that has\n\u2013 rules of \u03a0 , with variables (both free and bound) renamed arbitrarily, as its vertices, and \u2013 an edge from a rule p(t)\u2190 G to a rule p\u2032(t\u2032)\u2190 G\u2032, labeled by an atomic formula p\u2032(s), if p\u2032(s) has a positive nonnegated occurrence in G.\nUnlike the predicate dependency graph, the rule dependency graph of a program is usually infinite. For example, the rule dependency graph of program (11) has the vertices p(a, b) and\nq(x1, y1)\u2190 p(y1, x1) \u2227 \u00acp(x1, y1) (13)\nfor arbitrary pairs of distinct variables x1, y1. It has an edge from each vertex (13) to p(a, b), labeled p(y1, x1). The rule dependency graph of program (12) has edges of two kinds:\n\u2013 from p(x1)\u2190 q(x1) to q(x2)\u2190 r(x2), labeled q(x1), and \u2013 from q(x1)\u2190 r(x1) to r(x2)\u2190 s(x2), labeled r(x1)\nfor arbitrary variables x1, x2. The rule dependency graph of a program is \u201cdual\u201d to its predicate dependency graph, in the following sense. The vertices of the predicate dependency graph are predicate symbols, and the presence of an edge from p to q is determined by the existence\nof a rule that contains certain occurrences of p and q. The vertices of the rule dependency graph are rules, and the presence of an edge from R1 to R2 is determined by the existence of a predicate symbol with certain occurrences in R1 and R2.\nThere is a simple characterization of tightness in terms of rule dependency graphs:\nProposition 2. A Lloyd-Topor program \u03a0 is tight iff there exists n such that the rule dependency graph of \u03a0 has no paths of length n.\nProof. Assume that \u03a0 is tight, and let n be the number of predicate symbols occurring in\u03a0 . Then the rule dependency graph of\u03a0 has no paths of length n+1. Indeed, assume that such a path exists:\nR0 p1(. . . )\u2192 R1 p2(. . . )\u2192 R2 p3(. . . )\u2192 \u00b7 \u00b7 \u00b7 pn+1(. . . )\u2192 Rn+1.\nEach of the rules Ri (1 \u2264 i \u2264 n) contains pi in the head and a positive nonnegated occurrence of pi+1 in the body. Consequently the predicate dependency graph of \u03a0 has an edge from pi to pi+1, so that p1, . . . , pn+1 is a path in that graph; contradiction. Now assume that\u03a0 is not tight. Then there is an infinite path p1, p2, . . . in the predicate dependency graph of \u03a0 . Let Ri be a rule of \u03a0 that has pi in the head and a positive nonnegated occurrence of pi+1 in the body. Then the rule dependency graph of \u03a0 has an infinite path of the form\nR1 p2(. . . )\u2192 R2 p3(. . . )\u2192 \u00b7 \u00b7 \u00b7 .\nThe main theorem, stated in the next section, refers to finite paths in the rule dependency graph of a program \u03a0 that satisfy an additional condition: the rules at their vertices have no common variables (neither free nor bound). Such paths will be called chains.\nCorollary 1. A Lloyd-Topor program \u03a0 is tight iff there exists n such that \u03a0 has no chains of length n.\nIndeed, any finite path in the rule dependency graph of \u03a0 can be converted into a chain of the same length by renaming variables."}, {"heading": "5 Main Theorem", "text": "Let C be a chain p0(t\n0)\u2190 \u0131Body0 \u2193p1(s1) p1(t 1)\u2190 \u0131Body1 \u2193p2(s2)\n. . . . . . . . . . .\n\u2193pn(sn) pn(t n)\u2190 \u0131Bodyn\n(14)\nin a Lloyd-Topor program \u03a0 . The corresponding chain formula FC is the conjunction\nn\u2227 i=1 si = ti \u2227 n\u2227 i=0 \u0131Bodyi.\nFor instance, if C is the chain\nq(x1, y1)\u2190 p(y1, x1) \u2227 \u00acp(x1, y1) \u2193p(y1, x1)\np(a, b)\nin program (11) then FC is\ny1 = a \u2227 x1 = b \u2227 p(y1, x1) \u2227 \u00acp(x1, y1).\nLet \u0393 be a set of sentences. About a Lloyd-Topor program \u03a0 we will say that it is tight relative to \u0393 , or \u0393 -tight, if there exists a positive integer n such that, for every chain C in \u03a0 of length n,\n\u0393,Comp[\u03a0] |= \u2200\u0303\u00acFC .\nMain Theorem. If a Lloyd-Topor program \u03a0 is \u0393 -tight then\n\u0393 |= SM[\u03a0]\u2194 Comp[\u03a0].\nCorollary 1 shows that every tight program is trivially \u0393 -tight even when \u0393 is empty. Consequently the main theorem can be viewed as a generalization of Proposition 1.\nTightness in the sense of Section 3 is a syntactic condition that is easy to verify; \u0393 -tightness is not. Nevertheless, the main theorem is useful because it may allow us to reduce the problem of characterizing the stable models of a program by a first-order formula to verifying an entailment in first-order logic.\nHere are some examples. In each case, to verify \u0393 -tightness we take n = 1. We will check the entailment in the definition of \u0393 -tightness by deriving a contradiction from (some subset of) the assumptions \u0393 , Comp[\u03a0], and FC .\nExample 1. The one-rule program\np(a)\u2190 p(x) \u2227 x 6= a\nis tight relative to \u2205. Indeed, any chain of length 1 has the form\np(a)\u2190 p(x1) \u2227 x1 6= a \u2193p(x1) p(a)\u2190 p(x2) \u2227 x2 6= a.\nThe corresponding chain formula\nx1 = a \u2227 p(x1) \u2227 x1 6= a \u2227 p(x2) \u2227 x2 6= a.\nis contradictory. Thus the stable models of this program are described by its completion, even though the program is not tight (and not even atomic-tight).\nExample 2. Let \u03a0 be the program consisting of the first 2 rules of (5):\np(a)\u2190 p(b), q(c)\u2190 q(d).\nTo justify the claim about (5) made in the introduction, we will check that \u03a0 is tight relative to {a 6= b, c 6= d}. There are two chains of length 1:\np(a)\u2190 p(b) \u2193p(b) p(a)\u2190 p(b)\nand q(c)\u2190 q(d) \u2193q(d) q(c)\u2190 q(d). The corresponding chain formulas are\nb = a \u2227 p(b) \u2227 p(b)\nand d = c \u2227 q(d) \u2227 q(d).\nEach of them contradicts \u0393 .\nExample 3. Let us check that program (3) is tight relative to {a 6= b}. Its chains of length 1 are\np(x1)\u2190 q(x1) \u2193q(x1)\nq(a)\u2190 p(b) and\nq(a)\u2190 p(b) \u2193q(b)\np(x1)\u2190 q(x1) for an arbitrary variable x1. The corresponding chain formulas include the conjunctive term p(b). Using the completion (4) of the program, we derive b = a, which contradicts \u0393 ."}, {"heading": "6 A Larger Example", "text": "Programs found in actual applications of ASP usually involve constructs that are not allowed in Lloyd-Topor programs, such as choice rules and constraints. Choice rules have the form\n{p(t)} \u2190 G.\nWe view this expression as shorthand for the sentence\n\u2200\u0303(G\u2192 p(t) \u2228 \u00acp(t)).\nA constraint\u2190 G is shorthand for the sentence \u2200\u0303\u00acG. Such sentences do not correspond to any rules in the sense of Section 2.\nNevertheless, the main theorem stated above can sometimes help us characterize the stable models of a \u201crealistic\u201d program by a first-order formula. In this section we discuss an example of this kind.\nThe logic program M described below encodes commonsense knowledge about moving objects from one location to another. Its signature consists of\n\u2013 the object constants 0\u0302, . . . , k\u0302, where k is a fixed nonnegative integer; \u2013 the unary predicate constants \u0131object, \u0131place, and \u0131step; they correspond to the three\ntypes of individuals under consideration; \u2013 the binary predicate constant \u0131next; it describes the temporal order of steps; \u2013 the ternary predicate constants \u0131at and \u0131move; they represent the fluents and actions\nthat we are interested in.\nThe predicate constants \u0131step, \u0131next, and \u0131at are intensional; the other three are not. (The fact that some predicates are extensional is the first sign that M is not a Lloyd-Topor program.) The program consists of the following rules:\n(i) the facts \u0131step(0\u0302), \u0131step(1\u0302), . . . \u0131step(k\u0302);\n\u0131next(0\u0302, 1\u0302), \u0131next(1\u0302, 2\u0302), . . . , \u0131next(k\u0302\u22121, k\u0302);\n(ii) the unique name constraints\n\u2190 i\u0302 = j\u0302 (1 \u2264 i < j \u2264 k);\n(iii) the constraints describing the arguments of \u0131at and \u0131move:\n\u2190 \u0131at(x, y, z) \u2227 \u00ac(\u0131object(x) \u2227 \u0131place(y) \u2227 \u0131step(z))\nand \u2190 \u0131move(x, y, z) \u2227 \u00ac(\u0131object(x) \u2227 \u0131place(y) \u2227 \u0131step(z));\n(iv) the uniqueness of location constraint\n\u2190 \u0131at(x, y1, z) \u2227 \u0131at(x, y2, z) \u2227 y1 6= y2;\n(v) the existence of location constraint\n\u2190 \u0131object(x) \u2227 \u0131step(z) \u2227 \u00ac\u2203y \u0131at(x, y, z);\n(vi) the rule expressing the effect of moving an object:\n\u0131at(x, y, u)\u2190 \u0131move(x, y, z) \u2227 \u0131next(z, u);\n(vii) the choice rule expressing that initially an object can be anywhere:\n{\u0131at(x, y, 0)} \u2190 \u0131object(x) \u2227 \u0131place(y);\n(viii) the choice rule expressing the commonsense law of inertia:4\n{\u0131at(x, y, u)} \u2190 \u0131at(x, y, z) \u2227 \u0131next(z, u).\nProgram M is not atomic-tight, so that methods of [8] are not directly applicable to it. Nevertheless, we can describe the stable models of this program without the use of second-order quantifiers. In the statement of the proposition below, p stands for the list of intensional predicates \u0131step, \u0131next and \u0131at, and H is the conjunction of the universal closures of the formulas\ni\u0302 6= j\u0302 (1 \u2264 i < j \u2264 k), \u0131at(x, y, z)\u2192 \u0131object(x) \u2227 \u0131place(y) \u2227 \u0131step(z), \u0131move(x, y, z)\u2192 \u0131object(x) \u2227 \u0131place(y) \u2227 \u0131step(z), \u0131at(x, y1, z) \u2227 \u0131at(x, y2, z)\u2192 y1 = y2, \u0131object(x) \u2227 \u0131step(z)\u2192 \u2203y \u0131at(x, y, z).\nProposition 3. SMp[M ] is equivalent to the conjunction of H with the universal closures of the formulas\n\u0131step(z)\u2194 k\u2228\ni=0\nz = i\u0302, (15)\n\u0131next(z, u)\u2194 k\u22121\u2228 i=0 (z = i\u0302 \u2227 u = i\u0302+1), (16)\n\u0131at(x, y, i\u0302+1)\u2194 (\u0131move(x, y, i\u0302) \u2228 (\u0131at(x, y, i\u0302) \u2227 \u00ac\u2203w move(x,w, i\u0302))) (i = 0, . . . , k \u2212 1). (17)\nRecall that the effect of adding a constraint to a logic program is to eliminate its stable models that violate that constraint [6, Theorem 3]. An interpretation satisfies H iff it does not violate any of the constraints (ii)\u2013(v). So the statement of Proposition 3 can be summarized as follows: the contribution of rules (i) and (vi)\u2013(viii), under the stable model semantics, amounts to providing explicit definitions for \u0131step and \u0131next, and \u201csuccessor state formulas\u201d for \u0131at.\nThe proof of Proposition 3 refers to the Lloyd-Topor program \u03a0 consisting of rules (i), (vi),\n(vii\u2032) \u0131at(x, y, 0)\u2190 \u0131object(x) \u2227 \u0131place(y) \u2227 \u00ac\u00ac\u0131at(x, y, 0), (viii\u2032) \u0131at(x, y, u)\u2190 \u0131at(x, y, z) \u2227 \u0131next(z, u) \u2227 \u00ac\u00ac\u0131at(x, y, t2),\nand \u0131object(x)\u2190 \u00ac\u00ac\u0131object(x), \u0131place(y)\u2190 \u00ac\u00ac\u0131place(y),\n\u0131move(x, y, z)\u2190 \u00ac\u00ac\u0131move(x, y, z). (18)\n4 This representation of inertia follows the example of [?, Figure 1].\nIt is easy to see that SMp[M ] is equivalent to SM[\u03a0] \u2227 H . Indeed, consider the program M \u2032 obtained from M by adding rules (18). These rules are strongly equivalent to the choice rules\n{\u0131object(x)}, {\u0131place(y)}, {\u0131move(x, y, z)}.\nConsequently SMp[M ] is equivalent to SM[M \u2032] [6, Theorem 2]. It remains to notice that (vii) is strongly equivalent to (vii\u2032), and (viii) is strongly equivalent to (viii\u2032).\nFurthermore\u2014and this is the key step in the proof of Proposition 3\u2014the secondorder formula SM[\u03a0] \u2227 H is equivalent to the first-order formula Comp[\u03a0] \u2227 H , in view of our main theorem and the following fact:\nLemma 1. Program \u03a0 is H-tight.\nTo derive Proposition 3 from the lemma, we only need to observe that (15) and (16) are the completed definitions of \u0131step and \u0131next in \u03a0 , and that the completed definition of \u0131at can be transformed into (17) under assumptions (15), (16), and H .\nProof of Lemma 1. Consider a chain in \u03a0 of length k + 2:\nR0 p1(. . . )\u2192 R1 p2(. . . )\u2192 \u00b7 \u00b7 \u00b7 pk+1(. . . )\u2192 Rk+1 pk+2(. . . )\u2192 Rk+2. (19)\nEach Ri is obtained from one of the rules (i), (vi), (vii\u2032), (viii\u2032), (18) by renaming variables. Each pi occurs in the head of Ri and has a positive nonnegated occurrence in Ri\u22121. Since there are no nonnegated predicate symbols in the bodies of rules (i) and (18), we conclude that R0, . . . , Rk+1 are obtained from other rules of \u03a0 , that is, from (vi), (vii\u2032), and (viii\u2032). Since the predicate constant in the head of each of these three rules is \u0131at, each of p1, . . . , pk+1 is the symbol \u0131at. Since there are no nonnegated occurrences of \u0131at in the bodies of (vi) and (vii\u2032), we conclude that R0, . . . , Rk are obtained by renaming variables in (viii\u2032). This means that chain (18) has the form\n\u0131at(x0, y0, u0)\u2190 \u0131at(x0, y0, z0) \u2227 \u0131next(z0, u0) \u2227 \u00ac\u00ac\u0131at(x0, y0, u0) \u2193\u0131at(x0, y0, z0) \u0131at(x1, y1, u1)\u2190 \u0131at(x1, y1, z1) \u2227 \u0131next(z1, u1) \u2227 \u00ac\u00ac\u0131at(x1, y1, u1) \u2193\u0131at(x1, y1, z1) . . .\n\u2193\u0131at(xk\u22121, yk\u22121, zk\u22121) \u0131at(xk, yk, uk)\u2190 \u0131at(xk, yk, zk) \u2227 \u0131next(zk, uk) \u2227 \u00ac\u00ac\u0131at(xk, yk, uk)\n\u2193\u0131at(xk, yk, zk) Rk+1 \u2193 \u00b7 \u00b7 \u00b7 Rk+2.\nThe corresponding chain formula contains the conjunctive terms\nz0 = u1, z1 = u2, . . . , zk\u22121 = uk\nand \u0131next(z0, u0), \u0131next(z1, u1), . . . , \u0131next(zk, uk).\nFrom these formulas we derive\n\u0131next(u1, u0), \u0131next(u2, u1), . . . , \u0131next(uk+1, uk), (20)\nwhere uk+1 stands for zk. Using the completed definition of \u0131next, we conclude:\nui = 0\u0302 \u2228 \u00b7 \u00b7 \u00b7 \u2228 ui = k\u0302 (0 \u2264 i \u2264 k + 1).\nConsider the case when ui = j\u0302i (0 \u2264 i \u2264 k + 1)\nfor some numbers j0, . . . , jk+1 \u2208 {0, . . . , k}. There exists at least one subscript i such that ji 6= ji+1 + 1, because otherwise we would have\nj0 = j1 + 1 = j2 + 2 = \u00b7 \u00b7 \u00b7 = jk+1 + k + 1,\nwhich is impossible because j0, jk+1 \u2208 {0, . . . , k}. By the choice of i, from the completed definition of \u0131next and the unique name assumption (included inH) we can derive \u00ac\u0131next(j\u0302i+1, j\u0302i). Consequently \u00ac\u0131next(ui+1, ui), which contradicts (20)."}, {"heading": "7 Review: Stable Models of Infinitary Formulas", "text": "Our proof of the main theorem employs the method proposed (for a different purpose) by Miroslaw Truszczynski [11], and in this section we review some of the definitions and results of that paper. The stable model semantics of propositional formulas due to Paolo Ferraris [12] is extended there to formulas with infinitely long conjunctions and disjunctions, and that generalization is related to the operator SM.\nLet A be a set of propositional atoms. The sets F0,F1, . . . are defined as follows:\n\u2013 F0 = A \u222a {\u22a5}; \u2013 Fi+1 consists of expressions H\u2228 and H\u2227, for all subsets H of F0 \u222a . . . \u222a Fi, and\nof expressions F \u2192 G, where F,G \u2208 F0 \u222a . . . \u222a Fi. An infinitary formula (over A) is an element of \u22c3\u221e\ni=0 Fi. A (propositional) interpretation is a subset of A. The satisfaction relation between an interpretation and an infinitary formula is defined in a natural way. The definition of the reduct F I of a formula F relative to an interpretation I proposed in [12] is extended to infinitary formulas as follows:\n\u2013 \u22a5I = \u22a5. \u2013 For A \u2208 A, AI = \u22a5 if I 6|= A; otherwise AI = A. \u2013 (H\u2227)I = \u22a5 if I 6|= H\u2227; otherwise (H\u2227)I = {GI |G \u2208 H}\u2227. \u2013 (H\u2228)I = \u22a5 if I 6|= H\u2228; otherwise (H\u2228)I = {GI |G \u2208 H}\u2228. \u2013 (G\u2192 H)I = \u22a5 if I 6|= G\u2192 H; otherwise (G\u2192 H)I = GI \u2192 HI .\nAn interpretation I is a stable model of an infinitary formula F if I is a minimal model of F I . An interpretation I satisfies F I iff it satisfies F [11, Proposition 1], so that stable models of F are models of F .\nInfinitary formulas are used to encode first-order sentences as follows. For any interpretation I in the sense of first-order logic, letA be the set of ground atoms formed from the predicate constants of the underlying signature and the \u201cnames\u201d \u03be\u2217 of elements \u03be of the universe |I| of I\u2014new objects constants that are in a 1\u20131 correspondence with elements of |I|. By Ir we denote the set of atoms from A that are satisfied by I . In the definition below, tI stands for the value assigned to the ground term t by the interpretation I . The grounding of a first-order sentence F relative to I (symbolically, \u0131grI(F )) is the infinitary formula over A constructed as follows:\n\u2013 \u0131grI(\u22a5) = \u22a5. \u2013 \u0131grI(p(t1, . . . , tk)) = p((tI1)\u2217, . . . , (tIk)\u2217). \u2013 \u0131grI(t1 = t2) = >, if tI1 = tI2, and \u22a5 otherwise. \u2013 If F = G \u2228H , \u0131grI(F ) = \u0131grI(G) \u2228 \u0131grI(H) (the case of \u2227 is analogous). \u2013 If F = G\u2192 H , \u0131grI(F ) = \u0131grI(G)\u2192 \u0131grI(H). \u2013 If F = \u2203xG(x), \u0131grI(F ) = {\u0131grI(G(u\u2217))|u \u2208 |I|}\u2228. \u2013 If F = \u2200xG(x), \u0131grI(F ) = {\u0131grI(G(u\u2217))|u \u2208 |I|}\u2227.\nIt is easy to check that \u0131grI is a faithful translation in the following sense: I satisfies a first-order sentence F iff Ir satisfies \u0131grI(F ).\nThis transformation is also faithful in the sense of the stable model semantics: I satisfies SM[F ] iff Ir is a stable model of \u0131grI(F ) [11, Theorem 5]. This is why infinitary formulas can be used for proving properties of the operator SM."}, {"heading": "8 Proof Outline", "text": "In the statement of the main theorem, the implication left-to-right\nSM[\u03a0]\u2192 Comp[\u03a0]\nis logically valid for any Lloyd-Topor program \u03a0 . This fact follows from [6, Theorem 11] by the argument used in the proof of Proposition 1 above. In this section we outline the proof in the other direction:"}, {"heading": "If a Lloyd-Topor program \u03a0 is \u0393 -tight, and an interpretation I satisfies both \u0393 and Comp[\u03a0], then I satisfies SM[\u03a0].", "text": "This assertion follows from three lemmas. The first of them expresses a Fagesstyle property of infinitary formulas similar to Theorem 1 from [3]. It deals with infinitary programs\u2014conjunctions of (possibly infinitely many) implications G \u2192 A with A \u2208 A. Such an implication will be called an (infinitary) rule with the head A and body G, and we will write it as A \u2190 G. For instance, if \u03a0 is a Lloyd-Topor program\nthen, for any interpretation I , \u0131grI(\u03a0) is an infinitary program. We say that an interpretation I is supported by an infinitary program \u03a0 if each atom A \u2208 I is the head of a rule A \u2190 G of \u03a0 such that I |= G. The lemma shows that under some condition the stable models of an infinitary program \u03a0 can be characterized as the interpretations that satisfy \u03a0 and are supported by \u03a0 .\nThe condition refers to the set of positive nonnegated atoms of an infinitary formula. This set, denoted by Pnn(F ), and the set of negative nonnegated atoms of F , denoted by Nnn(F ), are defined recursively, as follows:\n\u2013 Pnn(\u22a5) = \u2205. \u2013 For A \u2208 A, Pnn(A) = {A}. \u2013 Pnn(H\u2227) = Pnn(H\u2228) = \u22c3 H\u2208H Pnn(H).\n\u2013 Pnn(G\u2192 H) = { \u2205 if H = \u22a5, Nnn(G) \u222a Pnn(H) otherwise.\n\u2013 Nnn(\u22a5) = \u2205, \u2013 For A \u2208 A, Nnn(A) = \u2205. \u2013 Nnn(H\u2227) = Nnn(H\u2228) = \u22c3 H\u2208H Nnn(H).\n\u2013 Nnn(G\u2192 H) = { \u2205 if H = \u22a5, Pnn(G) \u222a Nnn(H) otherwise.\nLet \u03a0 be an infinitary program, and I a propositional interpretation. About atoms A,A\u2032 \u2208 I we say that A\u2032 is a parent of A relative to \u03a0 and I if \u03a0 has a rule A \u2190 G with the head A such that I |= G and A\u2032 is a positive nonnegated atom of G. We say that\u03a0 is tight on I if there is no infinite sequenceA0, A1, . . . of elements of I such that for every i, Ai+1 is a parent of Ai relative to F and I .\nLemma 2. For any model I of an infinitary program \u03a0 such that \u03a0 is tight on I , I is stable iff I is supported by \u03a0 .\nThe next lemma relates the \u0393 -tightness condition from the statement of the main theorem to tightness on an interpretation defined above.\nLemma 3. If a Lloyd-Topor program \u03a0 is \u0393 -tight, and an interpretation I satisfies both \u0393 and Comp[\u03a0], then \u0131grI(\u03a0) is tight on I r.\nFinally, models of Comp[\u03a0] can be characterized in terms of satisfaction and supportedness:\nLemma 4. For any Lloyd-Topor program \u03a0 , an interpretation I satisfies Comp[\u03a0] iff Ir satisfies \u0131grI(\u03a0) and is supported by \u0131grI(\u03a0).\nProofs of Lemmas 2\u20134 can be found in the longer version of the paper, posted at http://www.cs.utexas.edu/users/vl/papers/ltc-long.pdf."}, {"heading": "9 Conclusion", "text": "We proposed a new method for representing SM[F ] in the language of first-order logic. It is more general than the approach of [6]. Its relationship with the ideas of [8] requires further study. This method allows us, in particular, to prove the equivalence of some ASP descriptions of dynamic domains to axiomatizations based on successor state axioms.\nThe use of the stable model semantics of infinitary formulas [11] in the proof of the main theorem illustrates the potential of that semantics as a tool for the study of the operator SM."}, {"heading": "Acknowledgements", "text": "We are grateful to Joohyung Lee and to the anonymous referees for useful comments."}], "references": [{"title": "Consistency of Clark\u2019s completion and existence of stable models", "author": ["F. Fages"], "venue": "Journal of Methods of Logic in Computer Science 1", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1994}, {"title": "Foundations of logic programming", "author": ["V. Lifschitz"], "venue": "In Brewka, G., ed.: Principles of Knowledge Representation. CSLI Publications", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1996}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming 3", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "On tight logic programs and yet another translation from normal logic programs to propositional logic", "author": ["F. Lin", "J. Zhao"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI).", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2004}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Making Prolog more expressive", "author": ["J. Lloyd", "R. Topor"], "venue": "Journal of Logic Programming 3", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1984}, {"title": "First-order stable model semantics and first-order loop formulas", "author": ["J. Lee", "Y. Meng"], "venue": "J. Artif. Intell. Res. (JAIR) 42", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic 2", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2001}, {"title": "A characterization of strong equivalence for logic programs with variables", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Connecting first-order asp and the logic fo(id) through reducts", "author": ["M. Truszczynski"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2005}], "referenceMentions": [{"referenceID": 0, "context": "The theorem by Fran\u00e7ois Fages [1] describing a case when the stable model semantics is equivalent to program completion is one of the most important results in the theory of stable models.", "startOffset": 30, "endOffset": 33}, {"referenceID": 1, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 22, "endOffset": 29}, {"referenceID": 2, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 22, "endOffset": 29}, {"referenceID": 3, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 22, "endOffset": 29}, {"referenceID": 4, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "The general stable model semantics defined in [6] characterizes the stable models of a first-order sentence F as arbitrary models of a certain second-order sentence, denoted by SM[F ];1 logic programs are viewed there as first-order sentences written in \u201clogic programming notation.", "startOffset": 46, "endOffset": 49}, {"referenceID": 6, "context": "That extension refers to the version of program completion introduced by John Lloyd and Rodney Topor in [7].", "startOffset": 104, "endOffset": 107}, {"referenceID": 5, "context": "Earlier work in this direction is reported in [6] and [8].", "startOffset": 46, "endOffset": 49}, {"referenceID": 7, "context": "Earlier work in this direction is reported in [6] and [8].", "startOffset": 54, "endOffset": 57}, {"referenceID": 8, "context": "Instead, they discuss ways to convert a logic program to \u201cClark normal form\u201d by strongly equivalent transformations [9,10] and completing programs in this normal form by replacing implications with equivalences.", "startOffset": 116, "endOffset": 122}, {"referenceID": 9, "context": "Instead, they discuss ways to convert a logic program to \u201cClark normal form\u201d by strongly equivalent transformations [9,10] and completing programs in this normal form by replacing implications with equivalences.", "startOffset": 116, "endOffset": 122}, {"referenceID": 5, "context": "The Clark normal form of (1) is tight in the sense of [6], and Theorem 11 from that paper shows that SM[F ] in this case is equivalent to the conjunction of the completed definitions of p and q: \u2200x(p(x)\u2194 x = a \u2228 q(x)), \u2200x(q(x)\u2194 x = b).", "startOffset": 54, "endOffset": 57}, {"referenceID": 5, "context": "This program is not tight in the sense of [6], so that the above-mentioned theorem is not applicable.", "startOffset": 42, "endOffset": 45}, {"referenceID": 7, "context": "This claim cannot be justified, however, by a reference to Corollary 5 from [8].", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "The class of tight programs is defined in [6] in terms of predicate dependency graphs; that definition is reproduced in Section 3 below.", "startOffset": 42, "endOffset": 45}, {"referenceID": 7, "context": "The definition of an atomictight program in [8] refers to more informative \u201cfirst-order dependency graphs.", "startOffset": 44, "endOffset": 47}, {"referenceID": 5, "context": "This is an easy corollary to the theorem from [6] mentioned in the introduction.", "startOffset": 46, "endOffset": 49}, {"referenceID": 5, "context": "By Theorem 11 from [6], SM[\u03a0 \u2032] is equivalent to the completion of \u03a0 \u2032 in the sense of [6, Section 6.", "startOffset": 19, "endOffset": 22}, {"referenceID": 7, "context": "Program M is not atomic-tight, so that methods of [8] are not directly applicable to it.", "startOffset": 50, "endOffset": 53}, {"referenceID": 10, "context": "Our proof of the main theorem employs the method proposed (for a different purpose) by Miroslaw Truszczynski [11], and in this section we review some of the definitions and results of that paper.", "startOffset": 109, "endOffset": 113}, {"referenceID": 11, "context": "The stable model semantics of propositional formulas due to Paolo Ferraris [12] is extended there to formulas with infinitely long conjunctions and disjunctions, and that generalization is related to the operator SM.", "startOffset": 75, "endOffset": 79}, {"referenceID": 11, "context": "The definition of the reduct F I of a formula F relative to an interpretation I proposed in [12] is extended to infinitary formulas as follows: \u2013 \u22a5 = \u22a5.", "startOffset": 92, "endOffset": 96}, {"referenceID": 2, "context": "The first of them expresses a Fagesstyle property of infinitary formulas similar to Theorem 1 from [3].", "startOffset": 99, "endOffset": 102}, {"referenceID": 5, "context": "It is more general than the approach of [6].", "startOffset": 40, "endOffset": 43}, {"referenceID": 7, "context": "Its relationship with the ideas of [8] requires further study.", "startOffset": 35, "endOffset": 38}, {"referenceID": 10, "context": "The use of the stable model semantics of infinitary formulas [11] in the proof of the main theorem illustrates the potential of that semantics as a tool for the study of the operator SM.", "startOffset": 61, "endOffset": 65}], "year": 2013, "abstractText": "We investigate the relationship between the generalization of program completion defined in 1984 by Lloyd and Topor and the generalization of the stable model semantics introduced recently by Ferraris et al. The main theorem can be used to characterize, in some cases, the general stable models of a logic program by a first-order formula. The proof uses Truszczynski\u2019s stable model semantics of infinitary propositional formulas.", "creator": "LaTeX with hyperref package"}}}