{"id": "1302.7251", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Feb-2013", "title": "Modeling Stable Matching Problems with Answer Set Programming", "abstract": "The Stable Marriage Problem (SMP) is a well-known matching problem first introduced and solved by Gale and Shapley (1962). Several variants and extensions to this problem have since been investigated to cover a wider set of applications. Each time a new variant is considered, however, a new algorithm needs to be developed and implemented. As an alternative, in this paper we propose an encoding of the SMP using Answer Set Programming (ASP). Our encoding can easily be extended and adapted to the needs of specific applications. As an illustration we show how stable matchings can be found when individuals may designate unacceptable partners and ties between preferences are allowed. Subsequently, we show how our ASP based encoding naturally allows us to select specific stable matchings which are optimal according to a given criterion. Each time, we can rely on generic and efficient off-the-shelf answer set solvers to find (optimal) stable matchings.", "histories": [["v1", "Thu, 28 Feb 2013 16:43:43 GMT  (28kb)", "https://arxiv.org/abs/1302.7251v1", "17 pages"], ["v2", "Thu, 2 May 2013 05:39:33 GMT  (26kb)", "http://arxiv.org/abs/1302.7251v2", "26 pages"]], "COMMENTS": "17 pages", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["sofie de clercq", "steven schockaert", "martine de cock", "ann now\\'e"], "accepted": false, "id": "1302.7251"}, "pdf": {"name": "1302.7251.pdf", "metadata": {"source": "CRF", "title": "Modeling Stable Matching Problems with Answer Set Programming", "authors": ["Sofie De Clercq", "Steven Schockaert", "Martine De Cock", "Ann Now\u00e9"], "emails": ["Sofier.DeClercq@ugent.be", "Martine.DeCock@ugent.be", "S.Schockaert@cs.cardiff.ac.uk", "ANowe@vub.ac.be", "Sofier.DeClercq@ugent.be", "Martine.DeCock@ugent.be", "S.Schockaert@cs.cardiff.ac.uk", "ANowe@vub.ac.be"], "sections": [{"heading": null, "text": "Keywords: Answer Set Programming, Logic Rules, Stable Marriage Problem, Optimal Stable Matchings."}, {"heading": "1 Introduction", "text": "The Stable Marriage Problem (SMP) is a matching problem first introduced and solved by Gale and Shapley [7]. Starting from (i) a set of n men and n women, (ii) for each man a ranking of the women as preferred partners, and (iii) for each woman a ranking of the men as preferred partners, the SMP searches for a set of n couples (marriages) such that there are no man and woman who are in different marriages but both prefer each other to their actual partners. Such a man and woman are called a blocking pair and a matching without blocking pairs forms a stable set of marriages. Due to its practical relevance, countless variants on the SMP have been investigated, making the problem\n\u2217This research was funded by a Research Foundation-Flanders project.\n2\nassumptions more applicable to a wider range of applications, such as kidney-exchange [12] and the hospital-resident problem [18]. Recently Roth and Shapley won the Nobel Prize for Economics for their theory of stable allocations and the practice of market design, work that has directly resulted from an application of the SMP.\nIn the literature, typically each time a new variant on the SMP is considered, a new algorithm is developed (see e.g. [10, 13, 20]). In this paper, we propose to use Answer Set Programming (ASP) as a general vehicle for modeling a large class of extensions and variations of the SMP. We show how an ASP encoding allows us to express in a natural way ties in the preferences of men and women, as well as unacceptability constraints (where certain people prefer to remain single over being coupled to undesirable partners). Furthermore, we illustrate how we can use our ASP encoding to find stable matchings that are optimal according to a certain criterion. Although the SMP has been widely investigated, and efficient approximation or exact algorithms are available for several of its variants (see e.g. [20]), to the best of our knowledge, our encoding offers the first exact implementation to find sex-equal, minimum regret, egalitarian or maximum cardinality stable sets for SMP instances with unacceptability and ties.\nThe paper is structured as follows. In Section 2 we give some background about the SMP and ASP. We introduce our encoding of the SMP with ASP and prove its correctness in the third section. In Section 4, we extend our encoding enabling it to find optimal stable sets. We explore several notions of optimality for stable matchings and show how optimal stable matchings can be found by solving the corresponding disjunctive ASP program. Finally we draw our conclusions."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 The Stable Marriage Problem", "text": "To solve the standard SMP, Gale and Shapley [7] constructed an iterative algorithm \u2014known as the Gale-Shapley algorithm, G-S algorithm or deferred-acceptance algorithm\u2014 to compute a particular solution of an SMP instance. The algorithm works as follows: in round 1 every man proposes to his first choice of all women. A woman, when being proposed, then rejects all men but her first choice among the subset of men who proposed to her. That first choice becomes her temporary husband. In the next rounds, all rejected men propose to their first choice of the subset of women by whom they were not rejected yet, regardless of whether this woman already has a temporary husband. Each woman, when being proposed, then rejects all men but her first choice among the subset of men who just proposed to her and her temporary mate. This process continues until all women have a husband. This point, when everyone has a partner, is always reached after a polynomial number of steps and the corresponding set of marriages is stable [7]. It should be noted, however, that only one of the potentially exponentially many stable matchings is found in this way. We formally define the SMP and introduce two variants that will be considered in this paper. We denote a set of men as M = {m1, . . . ,mn} and a set of women W = {w1, . . . , wp}, with n = p for the classical SMP. A set of marriages is a set of man-woman pairs such that each man and each woman occurs in just one pair.\nDefinition 1 (Classical SMP) An instance of the classical SMP is a pair (SM , SW ), with SM = {\u03c31M , . . . , \u03c3 n M} and SW = {\u03c3 1 W , . . . , \u03c3 n W } sets of permutations of the integers 1, . . . , n. The permutations \u03c3iM and \u03c3 i W are the preferences of man mi and woman wi respectively. If \u03c3 i M (j) = k, we say that woman wk is the j th most preferred woman\nfor man mi, and similarly for \u03c3 i W (j) = k. Man m and woman w form a blocking pair in a set of marriages S if m prefers w to his partner in S and w prefers m to her partner in S. A solution of an instance is a stable set of marriages, i.e. a set of marriages without blocking pairs.\nA first variant of the classical SMP allows men and women to point out unacceptable partners by not including them in their preference list. The number of men n can differ from the number of women p since men and women can remain single. A set of marriages is a set of singles (i.e. persons paired to themselves) and man-woman pairs such that every man and woman occurs in just one pair.\nDefinition 2 (SMP with unacceptability) An instance of the SMP with unacceptability is a pair (SM , SW ), SM = {\u03c3 1 M , . . . , \u03c3 n M}, and SW = {\u03c31W , . . ., \u03c3 p W }, with each \u03c3 i M a permutation of a subset of {1, . . . , p} and each \u03c3 j W a permutation of a subset of {1, . . . , n}. If \u03c3iM (j) = k, woman wk is the j th most preferred woman for man mi, and similarly for \u03c3iW (j) = k. If there is no l such that \u03c3 i M (l) = j, woman wj is an unacceptable partner for man mi, and similarly for no l such that \u03c3 i W (l) = j. A person x forms a blocking individual in a set of marriages S if x prefers being single to being paired with his or her partner in S. A solution of an instance is a stable set of marriages, i.e. a set of marriages without blocking pairs or individuals.\nThe length of the permutation \u03c3iM is denoted as |\u03c3 i M |. A stable matching for an SMP instance with unacceptability always exists and can be found in polynomial time [22] by a slightly modified G-S algorithm.\nExample 1 Suppose M = {m1,m2,m3}, W = {w1, w2, w3, w4}, SM = {\u03c31M = (4, 1, 3), \u03c3 2 M = (3, 2), \u03c3 3 M = (1, 3)} and SW = {\u03c31W = (1, 3), \u03c3 2 W = (2), \u03c3 3 W = (3, 2), \u03c3 4 W = (2, 1)}. Hence woman w1 prefers man m1 to man m3 while man m2 is unacceptable. In this setting, there is exactly one stable set of marriages [22]: {(m1, w4), (m2, w3), (m3, w1), (w2, w2)}. Thus woman w2 stays single.\nThe second variant of the SMP allows unacceptability and ties, i.e. the preferences do not have to be strict. For this variant there are several ways to define stability, but we will use the notion of weak stability [11].\nDefinition 3 (SMP with unacceptability and ties) An instance of the SMP with unacceptability and ties is a pair (SM , SW ), SM = {\u03c31M , . . . , \u03c3 n M} and SW = {\u03c31W , . . . , \u03c3 p W }. For every i \u2208 {1, . . . , n}, \u03c3 i M is a list of disjoint subsets of {1, . . . , p}. Symmetrically \u03c3iW is a list of disjoint subsets of {1, . . . , n} for every i \u2208 {1, . . . , p}. We call \u03c3 i M and \u03c3 i W the preferences of man mi and woman wi respectively. If k \u2208 \u03c3iM (j), woman wk is in man mi\u2019s j th most preferred group of women. All the women in that group are equally preferred by mi. The case k \u2208 \u03c3iW (j) is similar. If there is no l such that j \u2208 \u03c3 i M (l), woman wj is an unacceptable partner for man mi, and similar for no l such that j \u2208 \u03c3 i W (l). For every k in the set 1 \u03c3iM (|\u03c3 i M |), man mi equally prefers staying single to being paired to woman wk, and symmetrically for the preferences of a woman wi. This is the only set in \u03c3 i M that might be empty, and similar for \u03c3 i W . Man m and woman w form a blocking pair in a set of marriages S if m strictly prefers w to his partner in S and w strictly prefers m to her partner in S. A blocking individual in S is a person who stricly prefers being single to being paired to his partner in S. A solution of an instance is a weakly stable set of marriages, i.e. a set of marriages without blocking pairs or individuals.\n1|\u03c3iM | denotes the length of the list \u03c3 i M .\nA weakly stable matching always exists for an instance of the SMP with unacceptability and ties and it can be found in polynomial time by arbitrarily breaking the ties [14]. However, as opposed to the previous variant, the number of matched persons is no longer constant for every stable set in this variant. Note that the setting of Definition 3 generalizes the setting of Definition 2, which generalizes the setting of Definition 1. We introduce the notations\nacceptableiM = \u03c3 i M (1) \u222a \u03c3 i M (2) \u222a . . . \u222a \u03c3 i M (|\u03c3 i M | \u2212 1)\n\ufe38 \ufe37\ufe37 \ufe38\n= preferred iM\n\u222a \u03c3iM (|\u03c3 i M |)\n\ufe38 \ufe37\ufe37 \ufe38\n= neutraliM\nFurthermore unacceptableiM = {1, . . . , p} \\ acceptable i M . We define the ordening \u2264 mi M on {wj | j \u2208 acceptableiM} \u222a {mi} as x \u2264 mi M y iff mi prefers person x at least as much as person y. The strict ordening <miM is defined in the obvious way and analogous notations are used for \u03c3 j W .\nExample 2 Suppose M = {m1, m2}, W = {w1, w2, w3, w4} and SM = {\u03c31M = ({1, 3}, {4}), \u03c3 2 M = ({2, 3}, {})}. Hence man m1 prefers women w1 and w3 to woman w4. There is a tie between woman w1 and w3 as well as between woman w4 and staying single. Woman w2 is unacceptable for man m1. Man m2 prefers woman w2 and w3 to staying single, but finds w1 and w4 unacceptable. It holds that w1 < m1 M m1, i.e. m1 prefers marrying w1 over staying single, acceptable 1 M = {1, 3, 4}, preferred 1 M = {1, 3}, neutral1M = {4} and unacceptable 1 M = {2}."}, {"heading": "2.2 Answer Set Programming", "text": "Answer Set Programming or ASP is a form of declarative programming [2]. Its transparence, elegance and ability to deal with \u03a3P2 -complete problems make it an attractive method for solving combinatorial search and optimization problems. An ASP program is a finite collection of first-order rules\nA1 \u2228 . . . \u2228 Ak \u2190 B1, . . . , Bm, not C1, . . . , not Cn\nwith A1, . . . , Ak, B1, . . . , Bm, C1, . . . , Cn predicates. The semantics are defined by the ground version of the program, consisting of all ground instantiations of the rules w.r.t. the constants that appear in it (see e.g. [2] for a good overview). This grounded program is a propositional ASP program. The building blocks of these programs are atoms, literals and rules. The most elementary are atoms, which are propositional variables that can be true or false. A literal is an atom or a negated atom. Beside strong negation, ASP uses a special kind of negation, namely negation-as-failure (naf), denoted with \u2018not\u2019. For a literal a we call \u2018not a\u2019 the naf-literal associated with a. The extended literals consist of all literals and their associated naf-literals. A disjunctive rule has the following form\na1 \u2228 . . . \u2228 ak \u2190 b1, . . . , bm, not c1, . . . , not cn\nwhere a1, . . . , ak, b1, . . . , bm, c1, . . . , cn are literals from a fixed set L, determined by a fixed set A of atoms. We call a1\u2228 . . .\u2228ak the head of the rule while the set of extended literals b1, . . . , bm, not c1, . . ., not cn is called the body. The rule above intuitively encodes that a1, a2, . . . or ak is true when we have evidence that b1, . . . , bm are true and we have no evidence that at least one of c1, . . . , cn are true. When a rule has an empty body, we call it a fact ; when the head is empty, we speak of a constraint. A rule without occurrences of not is called a simple disjunctive rule. A simple disjunctive ASP program is a finite collection of simple disjunctive rules and similarly a disjunctive ASP program P is a finite collection of disjunctive rules. If each rule head consists of at most one literal, we speak of a normal ASP program.\nWe define an interpretation I of a disjunctive ASP program P as a subset of L. An interpretation I satisfies a simple disjunctive rule a1\u2228. . .\u2228ak \u2190 b1, . . . , bm when a1 \u2208 I\u2228. . .\u2228ak \u2208 I or {b1, . . . , bm} 6\u2286 I. An interpretation which satisfies all rules of a simple disjunctive program is called a model of that program. An interpretation I is an answer set of a simple disjunctive program P iff it is a minimal model of P , i.e. no strict subset of I is a model of P [9]. The reduct PI of a disjunctive ASP program P w.r.t. an interpretation I is defined as the simple disjunctive ASP program PI = {a1 \u2228 . . . \u2228 ak \u2190 b1, . . . , bm | (a1 \u2228 . . .\u2228ak \u2190 b1, . . . , bm, not c1, . . . , not cn) \u2208 P , {c1, . . . , cn}\u2229 I = \u2205}. An interpretation I of a disjunctive ASP program P is an answer set of P iff I is an answer set of PI .\nExample 3 Let P be the ASP program with the following 4 rules:\nman(john) \u2190, person(john) \u2190, person(fiona) \u2190\nwoman(X) \u2228 child(X) \u2190 person(X), notman(X)\nThe last rule is grounded to 2 rules in which X is resp. replaced by john and by fiona. We check that the interpretation I = {man(john), woman(fiona), person(john), person(fiona)} is an answer set of the ground version of P by computing the reduct. The grounded rule with X = john is deleted since man(john) is in I. The reduct PI is:\nman(john) \u2190, person(john) \u2190, person(fiona) \u2190\nwoman(fiona) \u2228 child(fiona) \u2190 person(fiona)\nThe first 3 rules are facts, hence their heads will be in any answer set. The fourth rule encodes that any person who is not a man, is a woman or child. It is clear that I is a minimal model of this simple program, so I is an answer set of P . By replacing woman(fiona) by child(fiona) in I, another answer set is obtained.\nTo automatically compute the answer sets of the programs in this paper, we have used the ASP solver DLV2, due to its ability to handle predicates, disjunction and numeric values (with some built-in aggregate functions). The numeric values are only used for grounding."}, {"heading": "3 Modeling the Stable Marriage Problem in ASP", "text": "In this section we model variations and generalizations of the SMP with ASP. A few proposals of using nonmonotonic reasoning for modeling the SMP have already been described in the literature. For instance in [19] a specific variant of the SMP is mentioned (in which boys each know a subset of a set of girls and want to be matched to a girl they know) and in [4] an abductive program is used to find a stable set of marriages in which two fixed persons are paired, with strict, complete preference lists. To the best of our knowledge, beyond a few specific examples, no comprehensive study has been made of using ASP or related paradigms in this context. In particular, the generality of our ASP framework for weakly stable sets of SMP instances with unacceptablity and/or ties is a significant advantage. The expression accept(m,w) denotes that a man m and a woman w accept each other as partners. The predicate manpropose(m,w) expresses that man m is willing to propose to woman w and analogously womanpropose(m,w) expresses that woman w is willing to propose to man m. Inspired by the Gale-Shapley algorithm, we look for an ASP formalisation to find the stable sets.\n2Available from www.dlvsystems.com\nDefinition 4 (ASP program induced by SMP with unacc. and ties) The ASP program P induced by an instance ({\u03c31M , . . . , \u03c3 n M}, {\u03c3 1 W , . . . , \u03c3 p W }) of the classical SMP with unacceptability and ties is the program containing for every i \u2208 {1, . . . , n}, j \u2208 {1, . . . , p} the following rules:\naccept(mi, wj) \u2190 manpropose(mi, wj), womanpropose(mi, wj) (1)\naccept(mi,mi) \u2190 {not accept(mi, wk) | k \u2208 acceptable i M} (2) accept(wj , wj) \u2190 {not accept(mk, wj) | k \u2208 acceptable j W} (3)\nand for every i \u2208 {1, . . . , n}, j \u2208 acceptableiM :\nmanpropose(mi, wj) \u2190 {not accept(mi, x) |x \u2264 mi M wj and wj 6= x} (4)\nand for every j \u2208 {1, . . . , p}, i \u2208 acceptablejW :\nwomanpropose(mi, wj) \u2190 {not accept(x,wj) |x \u2264 wj W mi and mi 6= x} (5)\nIntuitively (1) means that a man and woman accept each other as partners if they propose to each other. Due to (2), a man accepts himself as a partner (i.e. stays single) if no woman in his preference list is prepared to propose to him. Rule (4) states that a man proposes to a woman if he is not paired to a more or equally preferred woman. For j \u2208 neutraliM the body of (4) contains not accept(mi,mi). No explicite rules are stated about the number of persons someone can propose to or accept but Proposition 1 implies that this is unnecessary.\nWe illustrate the induced ASP program with an example.\nExample 4 Consider the following instance (SM , SW ) of the SMP with unacceptability and ties. Let M = {m1,m2} and W = {w1, w2, w3}. Furthermore:\n\u03c31M = ({1}, {2, 3}, {}) \u03c32M = ({2}, {1}) \u03c31W = ({1, 2}, {}) \u03c32W = ({1}, {}) \u03c33W = ({2}, {1}, {})\nThe ASP program induced by this SMP instance is:\nman(m1) \u2190, man(m2) \u2190\nwoman(w1) \u2190, , woman(w2) \u2190, woman(w3) \u2190\naccept(X,Y ) \u2190 manpropose(X,Y ), womanpropose(X,Y ),man(X), woman(Y )\nmanpropose(m1, w1) \u2190\nmanpropose(m1, w2) \u2190 not accept(m1, w1), not accept(m1, w3)\nmanpropose(m1, w3) \u2190 not accept(m1, w1), not accept(m1, w2)\naccept(m1,m1) \u2190 not accept(m1, w1), not accept(m1, w2), not accept(m1, w3)\nmanpropose(m2, w2) \u2190\nmanpropose(m2, w1) \u2190 not accept(m2, w2), not accept(m2,m2)\naccept(m2,m2) \u2190 not accept(m2, w2), not accept(m2, w1)\nwomanpropose(m1, w1) \u2190 not accept(m2, w1)\nwomanpropose(m2, w1) \u2190 not accept(m1, w1)\naccept(w1, w1) \u2190 not accept(m1, w1), not accept(m2, w1)\nwomanpropose(m1, w2) \u2190\naccept(w2, w2) \u2190 not accept(m1, w2)\nwomanpropose(m2, w3) \u2190\nwomanpropose(m1, w3) \u2190 not accept(m2, w3)\naccept(w3, w3) \u2190 not accept(m1, w3), not accept(m2, w3)\nNotice that we use the facts man and woman to capture all the rules of the form (1) at once. If we run this program in DLV, we get three answer sets containing respectively:\n\u2022 {accept(m1, w3), accept(m2, w1), accept(w2, w2)},\n\u2022 {accept(m1, w2), accept(m2, w1), accept(w3, w3)},\n\u2022 {accept(m1, w1), accept(m2,m2), accept(w2, w2), accept(w3, w3)}.\nThese correspond to the three weakly stable set of marriages of this SMP instance, namely {(m1, w3), (m2, w1), (w2, w2)}, {(m1, w2), (m2, w1), (w3, w3)} and {(m1, w1), (m2,m2), (w2, w2), (w3, w3)}.\nProposition 1 Let (SM , SW ) be an instance of the SMP with unacceptability and ties and let P be the corresponding ASP program. If I is an answer set of P, then a weakly stable matching for (SM , SW ) is given by {(x, y) | accept(x, y) \u2208 I}.\nProof. Let (SM , SW ) and P be as described in the proposition. Because of the symmetry between the men and the women we restrict ourselves to the male case when possible. We prove this proposition in 4 steps.\n1. For every i \u2208 {1, . . . , n}, every j \u2208 {1, . . . , p} and for every answer set I of P, it holds that accept(mi, wj) \u2208 I implies that j \u2208 acceptableiM and i \u2208 acceptable j W .\nThis can be proved by contradiction. We will prove that for every man mi and every j \u2208 unacceptableiM, accept(mi, wj) is in no answer set I of the induced ASP program P . For accept(mi, wj) to be in an answer set I, the reduct must contain some rule with this literal in the head and a true body. The only rule which can make this happen is the one of the form (1), implying that manpropose(mi, wj) should be in I. But since j is not in acceptable i M there is no rule with manpropose(mi, wj) in the head and so manpropose(mi, wj) can never be in I.\n2. For every answer set I of P and every man mi, there exists at most one woman wj such that accept(mi, wj) \u2208 I. Similarly, for every woman wj there exists at most one man mi such that accept(mi, wj) \u2208 I. Moreover, if accept(mi,mi) \u2208 I then accept(mi, wj) /\u2208 I for any wj , and likewise when accept(wj , wj) \u2208 I then accept(mi, wj) /\u2208 I for any mi. This can be proved by contradiction. Suppose first that there is an answer set I of P that contains accept(mi, wj) and accept(mi, wj\u2032 ) for some man mi and two different women wj and wj\u2032 . The first step implies that j and j\n\u2032 are elements of acceptableiM . Either man mi prefers woman wj to woman wj\u2032 (wj \u2264 mi M wj\u2032 ) or the other way around (wj\u2032 \u2264 mi M wj) or man mi has\nno preference among them (wj \u2264 mi M wj\u2032 and wj\u2032 \u2264 mi M wj). The first two cases are symmetrical and can be handled analogously. The last case follows from the first case because it has stronger assumptions. We prove the first case and assume that man mi prefers woman wj to woman wj\u2032 . The rules (4) imply the presence of a rule manpropose(mi, wj\u2032) \u2190 . . ., not accept(mi, wj), . . . and this is the only rule which can make manpropose(mi, wj\u2032 ) true (the only rule with this literal in the head). However, since accept(mi, wj) is also in the answer set, this rule has a false body so manpropose(mi, wj\u2032) can never be in I. Consequently accept(mi, wj\u2032 ) can never be in I since the only rule with this literal in the head is of the form (1) and this body can never be true, which leads to a contradiction. Secondly assume that accept(mi, wj) and accept(mi,mi) are both in an answer set I of P . Again step 1 implies that j \u2208 acceptableiM . Because of the rules (2) P will contain the rule accept(mi,mi) \u2190 . . . , not accept(mi, wj), . . .. An analogous reasoning as above implies that since accept(mi, wj) is in the answer set I, accept(mi,mi) can never be in I.\n3. For every man mi, in every answer set I of P exactly one of the following conditions is satisfied :\n(a) there exists a woman wj such that accept(mi, wj) \u2208 I,\n(b) accept(mi,mi) \u2208 I,\nand similarly for every woman wi. Suppose I is an arbitrary answer set of P and mi is an arbitrary man. We already know from step 2 that a man cannot be paired to a woman while being single, so both possibilities are disjoint. So suppose there is no woman wj such that accept(mi, wj) is in I. P will contain the rule (2). Because of our assumptions and the definition of the reduct, this rule will be reduced to accept(mi,mi) \u2190, and so accept(mi,mi) will be in I.\n4. For an arbitrary answer set I of P the previous steps imply that I produces a set of marriages without blocking individuals. Weak stability also demands the absence of blocking pairs. Suppose by contradiction that there is a blocking pair (mi, wj), implying that there exist i 6= i\u2032 and j 6= j\u2032 such that accept(mi, wj\u2032 ) \u2208 I and accept(mi\u2032 , wj) \u2208 I while wj < mi M wj\u2032 and mi < wj W mi\u2032 .\nThe rules of the form (1), the only ones with the literals accept(mi, wj\u2032 ) and accept(mi\u2032 , wj) in the head, imply that literals manpropose(mi, wj\u2032 ) and womanpropose(mi\u2032 , wj) should be in I. But since wj < mi M wj\u2032 and because of the form of the rules (4) there are fewer conditions to be fulfilled for manpropose(mi, wj) to be in I than for manpropose(mi, wj\u2032) to be in I. So manpropose(mi, wj) should be in I as well. A similar reasoning implies that womanpropose(mi, wj) should be in I. But now the rules of the form (1) imply that accept(mi, wj) should be in I, contradicting step 2 since accept(mi, wj\u2032 ) and accept(mi\u2032 , wj) are already in I.\nProposition 2 Let (SM , SW ) be an instance of the SMP with unacceptability and ties, and let P be the corresponding ASP program. If {(x1, y1), . . ., (xk, yk)} is a weakly stable matching for (SM , SW ) then P has the following answer set I:\n{manpropose(xi, y) | i \u2208 {1, . . . , k}, xi \u2208 M, y < xi M yi)}\n\u222a{womanpropose(x, yi) | i \u2208 {1, . . . , k}, yi \u2208 W,x < yi W xi}\n\u222a{accept(xi, yi) | i \u2208 {1, . . . , k}}\n\u222a{manpropose(xi, yi) | i \u2208 {1, . . . , k}, xi 6= yi}\n\u222a{womanpropose(xi, yi) | i \u2208 {1, . . . , k}, xi 6= yi}\nProof. Suppose we have a stable set of marriages S = {(x1, y1), . . . , (xk, yk)}, implying that every yi is an acceptable partner of xi and the other way around. The rules of the form (1) do not alter when forming the reduct, but the other rules do as those contain naf-literals. Notice first that the stability of S implies that there cannot be an unmarried couple (m,w), with m a man and w a woman, such that manpropose(m,w) is in I and womanpropose(m,w) is in I. By definition of I this would mean that they both strictly prefer each other to their current partner in S. This means they would form a blocking pair, but since S was stable, that is impossible. So the rules of the form (1) will be applied exactly for married couples (mi, wj), since by definition of I manpropose(mi, wj) and womanpropose(mi, wj) are both in I under these conditions. For other cases the rule will also be fulfilled since the body will be false. This reasoning implies that the unique minimal model of the reduct w.r.t. I should indeed contain accept(mi, wj) for every married couple (mi, wj) in S. Since S is a stable set of marriages, every person is either married or single. If a man mi is single, there will be no other literal of the form accept(mi, .) in I, so rule (2) will reduce to a fact accept(mi,mi) \u2190, which is obviously fulfilled by I. Similarly if a woman wj is single. Any other rule of the form (2) or (3) is deleted because mi or wj is not single in that case and thus there is some literal of the form accept(mi, w) for some woman w and some literal of the form accept(m,wj) for some man m in I, falsifying the body of the rules. If mi is single, then accept(mi,mi) is in I and this is the only literal of the form accept(mi, .) in I, so the rules of the form (4) will all be reduced to facts. The rule heads of these facts should be in the minimal model of the reduct and are indeed in I since the women w for which manpropose(mi, w) is in I are exactly those who are strictly preferred to staying single. The rules of the form (4) for women wj in neutral i M will all be deleted in this case, because accept(mi,mi) is in I. If man mi is married to a certain woman wj in the stable set S then the rules of the form (4) will reduce to facts of the form manpropose(mi, w) \u2190 for every woman w who is strictly preferred to wj and will be deleted for every other woman appearing in the head, because those rules will contain not accept(mi, wj) in the body. Again I contains these facts by definition, as the minimal model of the reduct should. We can use an analogous reasoning for the women. So the presence of the literals of the form manpropose(., .), womanpropose(., .) and accept(., .) in I is required in the unique minimal model of the reduct w.r.t. I. We have proved that every literal in I should be the minimal model of the reduct and that every rule of the reduct is fulfilled by I, implying that I is an answer set of P .\nIn [18] it is shown that the decision problem \u2018is the pair (m,w) stable?\u2019 for a given SMP instance with unacceptablity and ties is an NP-complete problem, even in the absence of unacceptability. A pair (m,w) is stable if there exists a stable set that contains (m,w). It is straightforward to see that we can reformulate this decision problem as \u2018does there exist an answer set of the induced normal ASP program P which contains the literal accept(m,w)?\u2019 (i.e. brave reasoning), which is known to be an NP-complete problem [1]. So our model forms a suitable framework for these kind of decision problems concerning the SMP."}, {"heading": "4 Selecting Preferred Stable Sets", "text": ""}, {"heading": "4.1 Notions of Optimality of Stable Sets", "text": "When several stable matchings can be found for an instance of the SMP, some may be more interesting than others. The stable set found by the G-S algorithm is M-optimal [22], i.e. every man likes this set at least as well as any other stable set. Exchanging the roles of men and women in the G-S algorithm yields a W-optimal stable set [7], optimal from the point of view of the women.\nWhile some applications may require us to favour either the men or the women, in others it makes more sense to treat both parties equally. To formalize some commonly considered notions of fairness and optimality w.r.t. the SMP, we define the cost cx(S) of a stable set S to an individual x, where cx(S) = k if x has been matched with his or her k\nth preferred partner. More precisely, for x = mi a man, we define cmi(S) = |{z : z < mi M y}|+1 where y is the partner of x in S; for x = wj a woman, cx is defined analogously. So in case of ties we assign the same list position to equally preferred partners, as illustrated in Example 5.\nExample 5 Let x = m1 be a man with preference list \u03c3 1 M = ({1}, {2, 3}, {4}) then w1 as partner of x in some set of marriages S would yield cx(S) = 1, w2 and w3 yield cx(S) = 2 and w4 yields cx(S) = 4. If m1 would be single in S, then the cost cx(S) is 4, since m1 prefers women w1, w2 and w3 to being single, but is indifferent between being paired to w4 or staying single.\nDefinition 5 For S a set of marriages,\n\u2022 the sex-equalness cost is defined as csexeq(S) = | \u2211 x\u2208M cx(S)\u2212 \u2211 x\u2208W cx(S)|, \u2022 the egalitarian cost is defined as cweight(S) = \u2211 x\u2208M\u222aW cx(S),\n\u2022 the regret cost is defined as cregret(S) = maxx\u2208M\u222aW cx(S), and\n\u2022 the cardinality cost is defined as csingles(S) = |{z : (z, z) \u2208 S}|."}, {"heading": "S is a sex-equal stable set iff S is a stable set with minimal sex-equalness cost. Similarly, S is an egalitarian (resp. minmum regret, maximum cardinality) stable set iff S is a stable set with minimal egalitarian (resp. regret or cardinality) cost.", "text": "A sex-equal stable set assigns an equal importance to the preferences of the men and women. An egalitarian stable set is a stable set in which the preferences of every individual are considered to be equally important. In [23] the use of an egalitarian stable set is proposed to optimally match virtual machines (VM) to servers in order to improve cloud computing by equalizing the importance of migration overhead in the data center network and VM migration performance. A minimum regret stable set is optimal for the person who is worst off. A maximal or minimal cardinality stable set is a stable set with resp. as few or as many singles as possible. Examples of practical applications include an efficient kidney exchange program [21] and the National Resident Matching Program3 [18]. Maximizing cardinality garantuees that as many donors as possible will get a compatible donor and as many medical graduates as possible will get a position.\n3www.nrmp.org\nTable 1 presents an overview of known complexity results4 concerning finding an optimal stable set. Typically the presence of ties leads to an increase of complexity. Manlove et al. [17, 18] proved that the problem of finding a maximum (or minimum) cardinality stable set for a given instance of the SMP with unacceptability and ties is NP-hard. Using this result, the problem of finding an egalitarian or minimum regret stable matching for a given SMP instance with ties is proved to be NP-hard [18], even if the ties occur on one side only and each tie is of length 2 (i.e. each set in a preference list has size at most 2). If there are no ties, the problem of finding an egalitarian or minimum regret stable set is solvable in polynomial time [13, 10]. Since all stable sets consist of n couples in the classical SMP, the G-S algorithm trivially finds a maximum (or minimum) cardinality [7]. For an SMP instance with unacceptability the number of couples in a stable set is constant [8], so finding a maximum cardinality stable set reduces to finding a stable set, which is known to be solvable in polynomial time. Surprisingly, finding a sex-equal stable set for a classical SMP instance is NP-hard [16], even if the preference lists are bound in length by 3 [20].\nBetween brackets we mention in Table 1 the complexity of an algorithm that finds an optimal stable set if one exists, in function of the number of men n. To the best of our knowledge, the only exact algorithm tackling an NP-hard problem from Table 1 finds a sex-equal stable set for an SMP instance in which the strict preference lists of men and/or women are bounded in length by a constant [20]. To the best of our knowledge, no exact implementations exist to find an optimal stable set for an SMP instance with ties, regardless of the presence of unacceptability and regardless which notion of optimality from Table 1 is used. Our approach yields an exact implementation of all problems mentioned in Table 1."}, {"heading": "4.2 Finding Optimal Stable Sets using Disjunctive ASP", "text": "As we discuss next, we can extend our ASP encoding of the SMP such that the optimal stable sets correspond to the answer sets of an associated ASP program. In particular, we use a saturation technique [5, 1] to filter non-optimal answer sets. Intuitively, the idea is to create a program with 3 components: (i) a first part describing the solution candidates, (ii) a second part also describing the solution candidates since comparison of solutions requires multiple solution candidates within the same answer set whereas the first part in itself produces one solution per answer set, (iii) a third part comparing the solutions described in the first two parts and selecting the preferred solutions by saturation. It is known that the presence of negation-as-failure can cause problems when applying saturation. Therefore, we use a SAT encoding [15] of the ASP program in Definition 4 and define a\n4Throughout this paper we assume that P 6= NP.\ndisjunctive naf-free ASP program in Definition 6 which selects particular models of the SAT problem. Notice that our original normal program is absolutely tight, i.e. there is no finite sequence l1, l2, . . . of literals such that for every i there is a program rule for which li+1 is a positive body literal and li is in the head [6]. We use the completion and a translation of our ASP program to SAT to derive Definition 6. The completion of a normal ASP program is a set of propositional formulas. For every atom a with a \u2190 bodyi (i \u2208 {1, . . . , k}) all the program rules with head a, the propositional formula a \u2261 body\u20321 \u2228 . . . \u2228 body \u2032 k is in the completion of that program. If an atoms a of the program does not occur in any rule head, than a \u2261\u22a5 is in the completion of the program. Similarly the completion of the program contains the propositional formula \u22a5\u2261 body\u20321 \u2228 . . .\u2228 body \u2032 l with with \u2190 bodyi (i \u2208 {1, . . . , l}) all the program constraints. For every i, body\u2032i is the conjunction of literals derived from bodyi by replacing every occurence of \u2018not\u2019 with \u2018\u00ac\u2019. Because our program is absolutely tight, we know that the completion will correspond to it [6]. Applied to the induced normal ASP program in Definition 4, the completion becomes:\n{accept(mi, wj) \u2261 manpropose(mi, wj) \u2227womanpropose(mi, wj) | i \u2208 {1, . . . , n}, j \u2208 {1, . . . , p}}\n\u222a{accept(mi,mi) \u2261 \u2227\nk\u2208acceptablei M\n\u00acaccept(mi, wk) | i \u2208 {1, . . . , n}}\n\u222a{accept(wj, wj) \u2261 \u2227\nk\u2208acceptable j\nW\n\u00acaccept(mk, wj) | j \u2208 {1, . . . , p}}\n\u222a{manpropose(mi, wj) \u2261 \u2227\nx\u2264 mi M wj ,x 6=wj\n\u00acaccept(mi, x) | i \u2208 {1, . . . , n}, j \u2208 acceptable i M}\n\u222a{womanpropose(mi, wj) \u2261 \u2227\nx\u2264 wj\nW mi,x 6=mi\n\u00acaccept(x,wj) | j \u2208 {1, . . . , p}, i \u2208 acceptable j W}\n\u222a{manpropose(mi, wj) \u2261\u22a5 | i \u2208 {1, . . . , n}, j \u2208 unacceptable i M} \u222a{womanpropose(mi, wj) \u2261\u22a5 | j \u2208 {1, . . . , p}, i \u2208 unacceptable j W}\nUsing the formulas of the completion corresponding to the normal ASP program in Definition 4, we can define a corresponding disjunctive ASP program without negation-as-failure. Lemma 3 follows form the fact that the completion corresponds to the original program [6].\nDefinition 6 (Induced disj. naf-free ASP program) The disjunctive naf-free ASP program Pdisj induced by an SMP instance (SM , SW ) with unacceptability and ties contains the following rules for i \u2208 {1, . . . , n}, j \u2208 {1, . . . , p}:\n\u00acaccept(mi, wj) \u2228manpropose(mi, wj) \u2190\n\u00acaccept(mi, wj) \u2228 womanpropose(mi, wj) \u2190\naccept(mi, wj) \u2228 \u00acmanpropose(mi, wj) \u2228 \u00acwomanpropose(mi, wj) \u2190\nFor every i \u2208 {1, . . . , n}, l \u2208 unacceptableiM, j \u2208 acceptable i M , x \u2264 mi M wj , x 6= wj Pdisj contains:\n\u2228\nk\u2208acceptablei M\naccept(mi, wk) \u2228 accept(mi,mi) \u2190\n\u00acaccept(mi,mi) \u2228 \u00acaccept(mi, wj) \u2190\n\u00acmanpropose(mi, wj) \u2228 \u00acaccept(mi, x) \u2190\n\u2228 x\u2264 mi M wj ,x 6=wj accept(mi, x) \u2228manpropose(mi, wj) \u2190\n\u00acmanpropose(mi, wl) \u2190\nand symmetrical for j \u2208 {1, . . . , p} and womanpropose.\nLemma 3 Let P be the normal ASP program from Definition 4 and Pdisj the disjunctive ASP program from Definition 6. It holds that for any answer set I of P there exists an answer set Idisj of Pdisj such that the atoms of I and Idisj coincide. Conversely for any answer set Idisj of Pdisj there exists an answer set I of P such that the atoms of I and Idisj coincide."}, {"heading": "4.3 ASP Program to Select Optimal Solutions", "text": "Let (SM , SW ) be an SMP instance with unacceptability and ties, with SM = {\u03c3 1 M , . . . , \u03c3 n M} and SW = {\u03c31W , . . . , \u03c3 p W }, and let Pnorm be the induced normal ASP program from Definition 4. Our technique for extending this program to a program that can respectively optimize for the sex-equalness, egalitarian, minimum regret and maximum cardinality criterion is in each case very similar. We start by explaining it for the case of sex-equalness. Our first step is to add a set of rules that compute the sex-equalness cost of a set of marriages. For every man mi and every woman wj such that j \u2208 \u03c3iM (k) we use the following rule to determine the cost for mi if wj would be his partner:\nmancost(i, k) \u2190 accept(mi, wj) (6)\nand similarly for every wj and every mi such that i \u2208 \u03c3 j W (k):\nwomancost(j, k) \u2190 accept(mi, wj) (7)\nWe also use the following rules with i ranging from 1 to n and j from 1 to p:\nmancost(i, |\u03c3iM |) \u2190 accept(mi,mi) (8) womancost(j, |\u03c3jW |) \u2190 accept(wj , wj) (9)\nmanweight(Z) \u2190 #sum{B,A : mancost(A,B)} = Z,#int(Z) (10)\nwomanweight(Z) \u2190 #sum{B,A : womancost(A,B)} = Z,#int(Z) (11)\nsexeq(Z) \u2190 manweight(X), womanweight(Y ), Z = X \u2212 Y\nsexeq(Z) \u2190 manweight(X), womanweight(Y ), Z = Y \u2212X (12)\nRules (8) and (9) state staying single leads to the highest cost. Rule (10) determines the sum of the male costs5 and similarly (11) determines the sum of the female costs. According to Definition 5 the absolute difference of these values yields the sex-equalness cost, as determined by rules (12). Since numeric variables are restricted to positive integers in DLV, we omit conditions as \u2018X \u2265 Y \u2019 or \u2018X < Y \u2019. The program Pnorm extended with rules (6) \u2013 (12) is denoted P sexeq ext . We construct a program Psexeq, composed by subprograms, that selects optimal solutions. Let P \u2032disj be the disjunctive naf-free ASP program, induced by the same SMP instance, in which a prime symbol is added to all literal names (e.g. accept becomes accept\u2032). Define a new program P \u2032sexeqext with all the rules of P \u2032 disj in\n5#sum, #max, #int and #count are DLV aggregate functions. The \u2018A\u2019 mentioned as variable in #sum indicates that a cost must be included for every person (otherwise the cost is included only once when persons have the same cost).\nwhich every occurrence of \u00acatom is changed into natom for every atom atom, i.e. replace all negation symbols by a prefix \u2018n\u2019. For every occurring atom atom in P \u2032sexeqext , add the following rule to exclude non-consistent solutions6:\nsat \u2190 atom, natom (13)\nFinally add rules (6) \u2013 (12) with prime symbols to the literal names to P \u2032sexeqext but replace rule (10) and rule (11) by:\nmansum(n,X) \u2190 mancost(n,X)\nmansum(J, Z) \u2190 mansum(I,X),mancost(J, Y ), Z = X + Y,#succ(J, I)\nmanweight(Z) \u2190 mansum(1, Z)\nwomansum(p,X) \u2190 womancost(p,X)\nwomansum(J, Z) \u2190 womansum(I,X), womancost(J, Y ), Z = X + Y,#succ(J, I)\nwomanweight(Z) \u2190 womansum(1, Z) (14)\nThe DLV aggregate function #succ(J, I) is true whenever J +1 = I. The reason we replace the rules with the aggregate function #max by these rules is to make sure the saturation happens correct. When saturation is used, the DLV aggregate function #max, #sum and #count would not yield the right criteriumvalues. Moreover, DLV does not accept these aggregate function in saturation because of the cyclic dependency of literals within the aggragate functions created by the rules for saturation. These adjusted rules, however, will do the job because of the successive way they compute the criteriumvalues. This becomes more clear in the proof of Proposition 4. We define the ASP program Psexeq as the union of Psexeqext , P \u2032sexeq ext and Psat. The ASP program Psat contains the following rules to select minimal solutions based on sex-equalness:\nsat \u2190 sexeq(X), sexeq\u2032(Y ), X \u2264 Y (15)\n\u2190 not sat (16)\nmancost\u2032(X,Y ) \u2190 sat,manargcost\u20321(X),manargcost \u2032 2(Y )\nwomancost\u2032(X,Y ) \u2190 sat, womanargcost\u20321(X), womanargcost \u2032 2(Y ) (17)\nmanpropose\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\nwomanpropose\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\naccept\u2032(X,X) \u2190 sat,man(X)\naccept\u2032(X,X) \u2190 sat, woman(X)\naccept\u2032(X,Y ) \u2190 sat,man(X), woman(Y ) (18)\nand analogous to (18) a set of rules with prefix \u2018n\u2019 for the head predicates. Finally we add the facts7 manargcost\u20321(1..n) \u2190, manargcost \u2032 2(1..(p+ 1)) \u2190, womanargcost \u2032 1(1..p) \u2190, womanargcost \u2032 2(1..(n+ 1)) \u2190, man(x) \u2190 for every man x and woman(x) \u2190 for every woman x to Psat. Intuitively the rules of Psat express the key idea of saturation. First every answer set is forced to contain the atom sat by rule (16). Then the rules (17) \u2013 (18) and the facts make sure that any answer set should contain all possible literals with a prime symbol that occur in Psexeq. Rule (15) will establish that only optimal solutions will correspond to minimal models and thus lead to answer sets. For any\n6For instance, sat \u2190 accept\u2032(m1, w1), naccept\u2032(m1, w1) 7The rule manargcost\u2032\n1 (1..n) \u2190 is DLV-syntax for the n facts manargcost\u2032 1 (1) \u2190, . . . ,manargcost\u2032 1 (n) \u2190.\nnon-optimal solution, the corresponding interpretation containing sat will never be a minimal model of the reduct. It is formally proved in Proposition 4 below that Psexeq produces exactly the stable matchings with minimal sex-equalness cost.\nFurthermore, only small adjustments to Psexeq are needed to create programs Pweight, Pregret, and Psingles that resp. produce egalitarian, minimum regret and maximum cardinality stable sets. Indeed, the ASP program Pweight can easily be defined as Psexeq in which the predicates sexeq and sexeq\u2032 are resp. replaced by weight and weight\u2032 and the rules (12) are replaced by (19), determining the egalitarian cost of Definition 5 as the sum of the male and female costs:\nweight(Z) \u2190 manweight(X), womanweight(Y ), Z = X + Y (19)\nSimilarly the ASP program Pregret is defined as Psexeq in which the predicates sexeq and sexeq\u2032\nare resp. replaced by regret and regret\u2032 and rules (10) \u2013 (12) are replaced by the following rules:\nmanregret(Z) \u2190 #max{B : mancost(A,B)} = Z,#int(Z) (20)\nwomanregret(Z) \u2190 #max{B : womancost(A,B)} = Z,#int(Z) (21)\nregret(X) \u2190 manregret(X), womanregret(Y ), X > Y\nregret(Y ) \u2190 manregret(X), womanregret(Y ), X \u2264 Y (22)\nRule (20) determines the regret cost but only for the men. Similarly (21) determines the regret cost for the women. The regret cost as defined in Definition 5 is the maximum of these two values, determined by the rules in (22). Again we adjust rules (20) and (21) for the program part P \u2032regretext by replacing them with a successively computing variant:\nmanmax(n,X) \u2190 mancost(n,X)\nmanmax(J,X) \u2190 manmax(I,X),mancost(J, Y ), X \u2265 Y,#succ(J, I)\nmanmax(J, Y ) \u2190 manmax(I,X),mancost(J, Y ), X < Y,#succ(J, I)\nmanregret(Z) \u2190 manmax(1, Z)\nwomanmax(p,X) \u2190 womancost(p,X)\nwomanmax(J,X) \u2190 womanmax(I,X), womancost(J, Y ), X \u2265 Y,#succ(J, I)\nwomanmax(J, Y ) \u2190 womanmax(I,X), womancost(J, Y ), X < Y,#succ(J, I)\nwomanregret(Z) \u2190 womanmax(1, Z) (23)\nFinally we define the ASP program Psingles as Psexeq in which the predicates sexeq and sexeq\u2032 are resp. replaced by singles and singles\u2032. Furthermore we replace rules (6) \u2013 (12) by (24), determining the number of singles:\nsingles(Z) \u2190 #count{B : accept(B,B)} = Z,#int(Z) (24)\nThis time we adjust rule (24) for the program part P \u2032singlesext as follows:\nsingle(p+ i, 1) \u2190 accept(mi,mi)\nsingle(p+ i, 0) \u2190 naccept(mi,mi)\nsingle(j, 1) \u2190 accept(wj , wj)\nsingle(j, 0) \u2190 naccept(wj , wj)\nsinglesum(n+ p,X) \u2190 single(n+ p,X)\nsinglesum(J, Z)\u2190 singlesum(I,X), single(J, Y ), Z = X + Y,#succ(J, I)\nsingles(Z) \u2190 sat, singlesum(1, Z) (25)\nExample 6 We reconsider Example 4. This SMP instance had 3 stable sets of marriages:\n\u2022 S1 = {accept(m1, w3), accept(m2, w1), accept(w2, w2)},\n\u2022 S2 = {accept(m1, w2), accept(m2, w1), accept(w3, w3)},\n\u2022 S3 = {accept(m1, w1), accept(m2,m2), accept(w2, w2), accept(w3, w3)}.\nIt is easy to compute the respective regret costs as cregret(S1) = 2 and cregret(S2) = cregret(S3) = 3. The corresponding program selecting this minimum regret stable set is the program consisting of the rules in Example 4 in addition with:\nmancost(1, 1) \u2190 accept(m1, w1)\nmancost(1, 2) \u2190 accept(m1, w2)\nmancost(1, 2) \u2190 accept(m1, w3)\nmancost(1, 3) \u2190 accept(m1,m1)\nmancost(2, 2) \u2190 accept(m2, w1)\nmancost(2, 1) \u2190 accept(m2, w2)\nmancost(2, 2) \u2190 accept(m2,m2)\nwomancost(1, 1) \u2190 accept(m1, w1)\nwomancost(1, 1) \u2190 accept(m2, w1)\nwomancost(1, 2) \u2190 accept(w1, w1)\nwomancost(2, 1) \u2190 accept(m1, w2)\nwomancost(2, 2) \u2190 accept(w2, w2)\nwomancost(3, 2) \u2190 accept(m1, w3)\nwomancost(3, 1) \u2190 accept(m2, w3)\nwomancost(3, 3) \u2190 accept(w3, w3)\nmanregret(Z) \u2190 #max{B : mancost(A,B)} = Z,#int(Z)\nwomanregret(Z) \u2190 #max{B : womancost(A,B)} = Z,#int(Z)\nregret(X) \u2190 manregret(X), womanregret(Y ), X > Y\nregret(Y ) \u2190 manregret(X), womanregret(Y ), X <= Y\nnaccept\u2032(M,W ) \u2228manpropose\u2032(M,W ) \u2190 man(M), woman(W )\nnaccept\u2032(M,W ) \u2228 womanpropose\u2032(M,W ) \u2190 man(M), woman(W )\naccept\u2032(M,W ) \u2228 nmanpropose\u2032(M,W ) \u2228 nwomanpropose\u2032(M,W ) \u2190 man(M), woman(W )\naccept\u2032(m1, w1) \u2228 accept \u2032(m1, w2) \u2228 accept \u2032(m1, w3) \u2228 accept \u2032(m1,m1) \u2190\naccept\u2032(m2, w1) \u2228 accept \u2032(m2, w2) \u2228 accept \u2032(m2,m2) \u2190\nnaccept\u2032(m1,m1) \u2228 naccept \u2032(m1, w1) \u2190 naccept\u2032(m1,m1) \u2228 naccept \u2032(m1, w2) \u2190\nnaccept\u2032(m1,m1) \u2228 naccept \u2032(m1, w3) \u2190 naccept\u2032(m2,m2) \u2228 naccept \u2032(m2, w1) \u2190 naccept\u2032(m2,m2) \u2228 naccept \u2032(m2, w2) \u2190\naccept\u2032(m1, w1) \u2228 accept \u2032(m2, w1) \u2228 accept \u2032(w1, w1) \u2190\naccept\u2032(m1, w2) \u2228 accept \u2032(w2, w2) \u2190\naccept\u2032(m1, w3) \u2228 accept \u2032(m2, w3) \u2228 accept \u2032(w3, w3) \u2190\nnaccept\u2032(w1, w1) \u2228 naccept \u2032(m1, w1) \u2190 naccept\u2032(w1, w1) \u2228 naccept \u2032(m2, w1) \u2190 naccept\u2032(w2, w2) \u2228 naccept \u2032(m1, w2) \u2190 naccept\u2032(w3, w3) \u2228 naccept \u2032(m1, w3) \u2190 naccept\u2032(w3, w3) \u2228 naccept \u2032(m2, w3) \u2190\nnmanpropose\u2032(m1, w2) \u2228 naccept \u2032(m1, w1) \u2190 nmanpropose\u2032(m1, w2) \u2228 naccept \u2032(m1, w3) \u2190 nmanpropose\u2032(m1, w3) \u2228 naccept \u2032(m1, w1) \u2190 nmanpropose\u2032(m1, w3) \u2228 naccept \u2032(m1, w2) \u2190\nmanpropose\u2032(m1, w1) \u2190\naccept\u2032(m1, w1) \u2228 accept \u2032(m1, w3) \u2228manpropose \u2032(m1, w2) \u2190 accept\u2032(m1, w1) \u2228 accept \u2032(m1, w2) \u2228manpropose \u2032(m1, w3) \u2190\nnmanpropose\u2032(m2, w1) \u2228 naccept \u2032(m2, w2) \u2190 nmanpropose\u2032(m2, w1) \u2228 naccept \u2032(m2,m2) \u2190\nmanpropose\u2032(m2, w2) \u2190\naccept\u2032(m2, w2) \u2228 accept \u2032(m2,m2) \u2228manpropose \u2032(m2, w1) \u2190\nnwomanpropose\u2032(m1, w1) \u2228 naccept \u2032(m2, w1) \u2190 nwomanpropose\u2032(m2, w1) \u2228 naccept \u2032(m1, w1) \u2190\naccept\u2032(m1, w1) \u2228 womanpropose \u2032(m2, w1) \u2190 accept\u2032(m2, w1) \u2228 womanpropose \u2032(m1, w1) \u2190\nwomanpropose\u2032(m1, w2) \u2190\nnwomanpropose\u2032(m1, w3) \u2228 naccept \u2032(m2, w3) \u2190\nwomanpropose\u2032(m2, w3) \u2190\naccept\u2032(m2, w3) \u2228 womanpropose \u2032(m1, w3) \u2190\nnmanpropose\u2032(m2, w3) \u2190 nwomanpropose\u2032(m2, w2) \u2190\nsat \u2190 manpropose\u2032(X,Y ), nmanpropose\u2032(X,Y ),man(X), woman(Y )\nsat \u2190 womanpropose\u2032(X,Y ), nwomanpropose\u2032(X,Y ),man(X), woman(Y )\nsat \u2190 accept\u2032(X,Y ), naccept\u2032(X,Y ),man(X), woman(Y )\nsat \u2190 accept\u2032(X,X), naccept\u2032(X,X),man(X)\nsat \u2190 accept\u2032(X,X), naccept\u2032(X,X), woman(X)\nmancost\u2032(1, 1) \u2190 accept\u2032(m1, w1) mancost\u2032(1, 2) \u2190 accept\u2032(m1, w2) mancost\u2032(1, 2) \u2190 accept\u2032(m1, w3) mancost\u2032(1, 3) \u2190 accept\u2032(m1,m1) mancost\u2032(2, 2) \u2190 accept\u2032(m2, w1) mancost\u2032(2, 1) \u2190 accept\u2032(m2, w2) mancost\u2032(2, 2) \u2190 accept\u2032(m2,m2) womancost\u2032(1, 1) \u2190 accept\u2032(m1, w1) womancost\u2032(1, 1) \u2190 accept\u2032(m2, w1) womancost\u2032(1, 2) \u2190 accept\u2032(w1, w1) womancost\u2032(2, 1) \u2190 accept\u2032(m1, w2) womancost\u2032(2, 2) \u2190 accept\u2032(w2, w2) womancost\u2032(3, 2) \u2190 accept\u2032(m1, w3) womancost\u2032(3, 1) \u2190 accept\u2032(m2, w3) womancost\u2032(3, 3) \u2190 accept\u2032(w3, w3)\nmanmax\u2032(2, X) \u2190 mancost\u2032(2, X)\nmanmax\u2032(J,X) \u2190 manmax\u2032(I,X),mancost\u2032(J, Y ), X >= Y,#succ(J, I)\nmanmax\u2032(J,X) \u2190 manmax\u2032(I,X),mancost\u2032(J, Y ), X >= Y,#succ(J, I)\nmanregret\u2032(Z) \u2190 manmax\u2032(1, Z)\nwomanmax\u2032(2, X) \u2190 womancost\u2032(2, X)\nwomanmax\u2032(J,X) \u2190 womanmax\u2032(I,X), womancost\u2032(J, Y ), X >= Y,#succ(J, I)\nwomanmax\u2032(J,X) \u2190 womanmax\u2032(I,X), womancost\u2032(J, Y ), X >= Y,#succ(J, I)\nwomanregret\u2032(Z) \u2190 womanmax\u2032(1, Z)\nregret\u2032(X) \u2190 manregret\u2032(X), womanregret\u2032(Y ), X > Y\nregret\u2032(Y ) \u2190 manregret\u2032(X), womanregret\u2032(Y ), X <= Y\nsat \u2190 regret(X), regret\u2032(Y ), X <= Y\n\u2190 not sat\nmanargcost\u20321(1..2) \u2190 manargcost\u20322(1..4) \u2190 womanargcost\u20321(1..3) \u2190 womanargcost\u20321(1..3) \u2190\nmancost\u2032(X,Y ) \u2190 sat,manargcost\u20321(X),manargcost \u2032 2(Y )\nwomancost\u2032(X,Y ) \u2190 sat, womanargcost\u20321(X), womanargcost \u2032 2(Y )\nmanpropose\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\nnmanpropose\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\nwomanpropose\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\nnwomanpropose\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\naccept\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\naccept\u2032(X,X) \u2190 sat,man(X)\naccept\u2032(X,X) \u2190 sat, woman(X)\nnaccept\u2032(X,Y ) \u2190 sat,man(X), woman(Y )\nnaccept\u2032(X,X) \u2190 sat,man(X)\nnaccept\u2032(X,X) \u2190 sat, woman(X)\nLetting DLV compute the unique answer set of this disjunctive ASP program and filtering it to the literals accept and regret, yields {accept(m2, w1), accept(m1, w3), accept(w2, w2), regret(2)}, corresponding exactly to the minimum regret stable set of the SMP instance and the corresponding regret cost.\nProposition 4 Let the criterion crit be an element of {sexeq, weight, regret, singles}. For every answer set I of the program Pcrit induced by an SMP instance with unacceptability and ties the set SI = {(m,w) | accept(m, w) \u2208 I} forms an optimal stable set of marriages w.r.t. criterion crit and the optimal criterion value is given by the unique value vI for which crit(vI) \u2208 I. Conversely for every optimal stable set S = {(x1, y1), . . . , (xk, yk)} with optimal criterion value v there exists an answer set I of Pcrit such that {(x, y) | accept(x, y) \u2208 I} = {(xi, yi) | i \u2208 {1, . . . , k}} and v is the unique value for which crit(v) \u2208 I.\nProof. Let (SM , SW ) is an instance of the SMP with unacceptability and ties.\nAnswer set \u21d2 Optimal stable set Let I be an arbitrary answer set of Pcrit and let SI be as in the proposition. It is clear that the only rules in Pcrit that influence the literals of the form manpropose(., .), womanpropose(., .) and accept(., .) are the rules in Pnorm. Hence any answer set I of Pcrit should contain an answer set Inorm of Pnorm as a subset. Proposition 1 implies that Inorm corresponds to a stable set SI = {(m,w) | accept(m,w) \u2208 Inorm}. Moreover, the only literals of the form manpropose(., .), womanpropose(., .) and accept(., .) in I are those in Inorm, so SI = {(m,w) | accept(m,w) \u2208 I}. If crit = sexeq, it is straightforward to see that the literals of the form accept(., .) in Inorm uniquely determine which literals of the form mancost(., .), womancost(., .), manweight(.), womanweight(.) and sexeq(.) should be in the answer set I. These literals do not occur in rules of Pcrit besides those in P sexeq ext . Notice that the rules which do contain these literals will imply that there will be just one literal of the form sexeq(.) in I, namely sexeq(v) with v the sex-equalness cost of SI . Analogous results can be derived for crit \u2208 {weight, regret, singles}. It remains to be shown that SI is an optimal stable set. Suppose by contradiction that SI is not optimal, so there exists a stable set S\u2217 such that vI > v\n\u2217, with v\u2217 the criterion value of S\u2217 to be minimized. We will prove that this implies that I cannot be an answer set of Pcrit, contradicting our initial assumption. Proposition 2 and Lemma 3 imply that there exists an interpretation I\u2217disj of the ASP program Pdisj induced by (SM , SW ) that corresponds to the stable set S\n\u2217. Moreover this interpretation is consistent, i.e. it will not contain atom and \u00acatom for some atom atom. This implies that the interpretation I \u2032disj defined as I \u2217 disj in which \u00acatom is replaced by natom for every atom atom will falsify the body of the rules of the form (13) of P \u2032critext . An analogous reasoning as above yields that the literals of the\nform accept\u2032(., .) in I \u2032disj uniquely determine which literals of the form mancost \u2032(., .), womancost\u2032(., .), mansum\u2032(., .), womansum\u2032(., .), manweight\u2032(.), womanweight\u2032(.) and sexeq\u2032(.) should be in I \u2032disj . With those extra literals added to I \u2032disj , I \u2032 disj satisfies all the rules of P \u2032crit ext . Moreover, crit(v\n\u2217) is the unique literal of the form crit(.) in I \u2032disj . Notice that I \u2032 disj does not contain the atom sat. Define the interpretation J = Inorm \u222a I \u2032 disj . From the previous argument it follows that J will satisfy every rule of Pcritext \u222a P \u2032crit ext since the predicates occurring in both programs do not overlap. Moreover J contains crit(vI) and crit \u2032(v\u2217) and these are the only literals of the form crit(.) or crit\u2032(.). Since vI > v \u2217 the rules of the form (15) will be satisfied by J since their body is always false. Call J \u2032 the set J \u222a {a | (a \u2190) \u2208 Psat}. Since J \u2032 does not contain sat, the rules of Psat will all be satisfied by J \u2032, with exception of the rule \u2190 not sat. The rule of the form (16) implies that I as answer set of Pcrit should contain sat. Now the set of rules (17) \u2013 (18) imply that I should also contain the literals mancost\u2032(., .), womancost\u2032(., .) and manpropose\u2032(., .), womanpropose\u2032(., .), accept\u2032(., .) with the corresponding literals prefixed by n for every possible argument stated by the facts in Psat. The successively computing rules (14) resp. (23) and (25) in P \u2032critext , by which we replaced rules (10) \u2013 (11) resp. (20) \u2013 (21) and (24), garantuee that for every possible set of marriages and its corresponding criterium value c I will contain crit(c) and all associated intermediate results. E.g. for crit = sexeq, the rules will garantuee that I also contains mansum\u2032(., .), manweight(.), womansum(., .) and womanweight(.) for every argument that could occur in a model of P \u2032critext .\n8 This implies that I \u2032disj \u2286 I. We already reasoned in the beginning of the proof that Inorm \u2286 I holds so it follows that J \u2286 I. Since the literals of J \u2032 \\ J are stated as facts of Pcritext , they should be in I, hence J\n\u2032 \u2286 I. Moreover J \u2032 \u2282 I since sat \u2208 I \\ J \u2032. We use the notation red(P , I) to denote the reduct of an ASP program P w.r.t. an interpretation I. There is no rule in P \u2032critext with negation-as-failure in the body, hence red(P \u2032crit ext , I) = red(P \u2032crit ext , J\n\u2032) = P \u2032critext . We already reasoned that J\n\u2032 satifies all the rules of the latter. We also reasoned that I does not contain any other literals of the form accept(., .) than those who are also in Inorm, and by construction the same holds for J \u2032. Hence red(Pcritext , I) = red(P crit ext , J\n\u2032) and by construction J \u2032 satisfies all the rules of this reduct. It is clear that red(Psat, I) is Psat without the rule \u2190 not sat, since sat \u2208 I. Again we already argued that J \u2032 satisfies red(Psat, I). Hence J \u2032 satisfies all the rules of red(Pcrit, I), implying that I, which strictly contains J \u2032, cannot be an answer set of Pcrit since it is not a minimal model of the negation-free ASP program red(Pcrit, I) [9].\nOptimal stable set \u21d2 Answer set Let (SM , SW ) be an instance of the SMP with unacceptability and ties and let S = {(x1, y1), . . . , (xk, yk)} be an optimal stable set with optimal criterion value v. To see that the second part of the proposition holds it suffices to verify that the following interpretation I is an answer set of Pcrit, with the notation Pxi(y) as the index a for which y \u2208 \u03c3 l M (a) if xi = ml and symmetrically Pyi(x) as the index a for which x \u2208 \u03c3 l\u2032\nW (a) if yi = wl\u2032 . If xi = yi we set Pxi(yi) = Pyi(xi) = |\u03c3 i M | if xi is a man and |\u03c3 i W | otherwise. So let I be given by:\nI = I1 \u222a I2\n8Notice that this would not be the case if we use the original rules with #sum, #max and #count in P \u2032critext , since these rules would lead to only one value cM for which e.g. manweight(cM ) should be in I, and similarly only one value cW for which womanweight(cW ) should be in I. Consequently there would be only one value c such that crit(c) should be in I. This value would not necessarily correspond to v\u2217 and so we would not be able to conclude that I\u2032\ndisj \u2286 I.\nMoreover DLV does not allow the use of these rules because of the cyclic dependency of literals they would create, involving the variables in the aggregate functions.\nwith\nI1 ={accept(xi, yi) | i \u2208 {1, . . . , k}}{crit(v)} \u222a {sat}\n\u222a{womanpropose(xi, yi) |xi 6= yi}{manpropose(xi, yi)|xi 6= yi}\n\u222a{manpropose(xi, y) | i \u2208 {1, . . . , k}, xi = ml, \u2203a < Pxi(yi):y \u2208 \u03c3 l M (a)} \u222a{womanpropose(x, yi)|i \u2208 {1, . . . , k}, yi = wl\u2032 , \u2203a < Pyi(xi):x \u2208 \u03c3 l\u2032 W (a)} \u222a{mancost(l, Pxi(yi)) | crit 6= singles, i \u2208 {1, . . . , k}, xi = ml} \u222a{womancost(Pyi(xi), l \u2032) | crit 6= singles, i \u2208 {1, . . . , k}, yi = wl\u2032} \u222a{manweight(cM (S)) | crit \u2208 {sexeq, weight}}\n\u222a{womanweight(cW (S)) | crit \u2208 {sexeq, weight}}\n\u222a{manregret(cregret,M (S)) | crit = regret}\n\u222a{womanregret(cregret,W (S)) | crit = regret}\nand\nI2 ={manargcost \u2032 1(z) | z \u2208 {1, . . . , n}}\n\u222a{manargcost\u20322(z) | z \u2208 {1, . . . , p+ 1}} \u222a{womanargcost\u20321(z) | z \u2208 {1, . . . , p}} \u222a{womanargcost\u20322(z) | z \u2208 {1, . . . , n+ 1}} \u222a{man(x) |x \u2208 M} \u222a {woman(x) |x \u2208 W} (26)\n\u222a{mancost\u2032(i, j) | crit 6= singles, i \u2208 {1, . . . , n}, j \u2208 {1, . . . , p+ 1}}\n\u222a{womancost\u2032(j, i) | crit 6= singles, i \u2208 {1, . . . , n+ 1}, j \u2208 {1, . . . , p}} (27)\n\u222a{manpropose\u2032(x, y) |x \u2208 M, y \u2208 W} \u222a {womanpropose\u2032(x, y) |x \u2208 M, y \u2208 W}\n\u222a{accept\u2032(x, y) |x \u2208 M, y \u2208 W} \u222a {accept\u2032(x, x) |x \u2208 M \u222aW}\n\u222a{nmanpropose\u2032(x, y) |x \u2208 M, y \u2208 W}\n\u222a{nwomanpropose\u2032(x, y) |x \u2208 M, y \u2208 W}\n\u222a{naccept\u2032(x, y) |x \u2208 M, y \u2208 W} \u222a {naccept\u2032(x, x) |x \u2208 M \u222aW} (28)\n\u222a{crit\u2032(val) | val \u2208 arg(crit)}\n\u222a{single\u2032(i, j) | crit = singles, i \u2208 {1, . . . , n+ p}, j \u2208 {0, 1}}\n\u222a{singlesum\u2032(i, j) | crit = singles, i \u2208 {1, . . . , n+ p}, j \u2208 {1, . . . , (n+ p\u2212 i+ 1)}}\n\u222a{mansum\u2032(i, j) | crit \u2208 {sexeq, weight}, i \u2208 {1, . . . , n}, j \u2208 {n\u2212 i+ 1, . . . , (n\u2212 i+ 1)(p+ 1)}}\n\u222a{womansum\u2032(j, i) | crit \u2208 {sexeq, weight}, j \u2208 {1, . . . , p}, i \u2208 {p\u2212 j + 1, . . . , (p\u2212 i+ 1)(n+ 1)}}\n\u222a{manweight\u2032(z) | crit \u2208 {sexeq, weight}, z \u2208 {n, . . . , n(p+ 1)}}\n\u222a{womanweight\u2032(z) | crit \u2208 {sexeq, weight}, z \u2208 {p, . . . , p(n+ 1)}}\n\u222a{manmax\u2032(i, j) | crit = regret, i \u2208 {1, . . . , n}, j \u2208 {1, . . . , p+ 1}}\n\u222a{womanmax\u2032(j, i) | crit = regret, j \u2208 {1, . . . , p}, i \u2208 {1, . . . , n+ 1}\n\u222a{manregret\u2032(z) | crit = regret, z \u2208 {1, . . . , p+ 1}}\n\u222a{womanregret\u2032(z) | crit = regret, z \u2208 {1, . . . , n+ 1}} (29)\nThe notation arg(c) stands for the possible values the criterion can take within this problem instance:\n\u2022 crit = sexeq \u21d2 arg(crit) = {0, . . . ,max(np+ n\u2212 p, np+ p\u2212 n)},\n\u2022 crit = weight \u21d2 arg(crit) = {n+ p, . . . , 2np+ p+ n},\n\u2022 crit = regret \u21d2 arg(crit) = {1, . . . ,max(p, n) + 1)},\n\u2022 crit = singles \u21d2 arg(crit) = {0, . . . , n+ p}.\nTo verify wether this interpretation is an answer set of Pcrit, we should compute the reduct w.r.t. I and check wether I is a minimal model of the reduct [9]. It can readily be checked that I satisfies all the rules of red(Pcrit, I). It remains te be shown that there is no strict subset of I with satisfies all the rules. First of all all the facts of Pcrit must be in the minimal model of the reduct, explaining why the sets of literals (26) should be in I. The only rules with negation-as-failure are part of Pcritext . As in the previous part of the proof, it is straightforward to see that I1 is the unique minimal model of the reduct of Pcritext w.r.t. I, considering that the literals in I2 don\u2019t occur in P crit ext . So any minimal model of red(Pcrit, I) must contain I1. The key rule which makes sure that I is a minimal model of the reduct is (15). The rules (13) imply that for each model of red(Pcrit, I) that does not contain sat, the literals of P \u2032critext in that model will correspond to a stable set of the SMP instance. In that case rule (15) will have a true body, since S is optimal, implying that sat should have been in the model. And the presence of sat in any minimal model implies the presence of the set of literals (29) in any minimal model of the reduct. This can be seen with the following reasoning. Due to the presence of the facts (26) and sat in any minimal model of the reduct, rules (17) imply the presence of the literals (27) in any minimal model. For the same reason rules (18) imply that the literals (28) should be in any minimal model of red(Pcrit, I). For crit = sexeq the presence of the literals of the form (27) in any minimal model of the reduct together with rules (14) imply that mansum\u2032(i, j) should be in any minimal model for every i \u2208 {1, . . . , n} and j \u2208 {n\u2212 i+ 1, . . . , (n\u2212 i+ 1)(p+ 1)}: for i = n the first rule of (14) implies that mansum\u2032(n, x) is in any minimal model for every x such that manargcost\u20322(x) is in it, i.e. any x \u2208 {1, . . . , p+1}. Now the second rule of (14) implies that mansum\u2032(n\u22121, x) is in any minimal model for every x+y such that manargcost\u20322(x) and mansum\n\u2032(n, y) are in it, i.e. any x+y \u2208 {2, . . . , 2(p+1)}. If we continue like this, it is straightforward that every literal of the form mansum\u2032(., .) of I2 should be in any minimal model. The third rule of (14) now implies that manweight\u2032(x) should be in any minimal model for every x such that mansum\u2032(1, x) is in it, i.e. x \u2208 {n, . . . , n(p + 1)}. The same reasoning can be repeated for the literals womansum\u2032 and womanweight\u2032. At this point rules (12) imply that sexeq\u2032(|x \u2212 y|) should be in any minimal model which contains manweight\u2032(x) and womanweight\u2032(y). Notice that only one of the two rules in (12) will apply for every x and y since the numerical variables in DLV are positive. Considering the arguments for which manweight\u2032 and womanweight\u2032 should be in any minimal model, it follows that sexeq\u2032(x) should be in any minimal model for every x \u2208 {0, . . . ,max(p(n+1)\u2212n, n(p+1)\u2212 p)}, which is exactly arg(crit). For the other criteria, an analogous reasoning shows that the presence of all literals of I2 is required in any minimal model of the reduct. Considering the fact that we have proved that all literals of I should be in any minimal model of the reduct and I fulfils all the rules of the reduct, we know that I is a minimal model of the reduct and thus an answer set of Pcrit.\nIf we delete from Psexeq the rules (11) \u2013 (12) and replace rule (15) by the rule sat \u2190 manweight(X), manweight\u2032(Y ), X \u2264 Y , then we obtain the M-optimal stable sets. Analogously we can obtain the W-optimal stable sets.\nIf a criterion is to be maximized, the symbol \u2264 in rule (15) is simply replaced by \u2265. E.g. for crit = singles we will get minimum cardinality stable sets."}, {"heading": "5 Complexity and Future Work", "text": "The NP-complete decision problem \u2018does there exist a stable set with cardinality \u2265 k (resp. \u2264 k) for an SMP instance with unacceptability and ties with k a positive integer?\u2019 [17, 18] has practical importance, e.g. in the National Resident Matching Program [18]. If we add a rule sat \u2190 singles(X), X \u2264 (n+p\u22122k) to the extended induced program Psinglesext defined in Subsect. 4.3, then this problem can be formulated as \u2018does there exist an answer set of the normal ASP program Psinglesext which contains the literal sat?\u2019 (i.e. brave reasoning), another NP-complete problem [1]. So our model forms a suitable framework for these kind of decision problems concerning optimality of stable sets in the SMP.\nNotice that the complexity of this kind of decision problem and the one mentioned in the last paragraph of Subsect. 3 are a good indication how hard it is to find an (optimal) stable set, as opposed to the problems \u2018does there exist an (optimal) stable set?\u2019, which tell us how hard it is to know whether there exists a solution but not necessarily how hard it is to find one.\nCombining these problems leads to a new decision problem: \u2018is the pair (m,w) optimally stable for an instance of the SMP with unacceptability and ties?\u2019. We define an optimally stable pair as a pair (m,w) for which there exists an optimal stable set in which m and w are matched. As far as we know this problem has not been studied yet, although it could be useful in practice, for instance if one wants to find a maximum cardinality matching but also wants to prioritize some couple or a person. Optimality is still desirable, because it ensures the others from not being put too much at a disadvantage. For instance in the kidney exchange problem, in which kidney patients with a willing but incompatible donor try to interchange each other\u2019s donors to get a transplant, this is a realistic situation: if two patients with intercompatible donors urgently need a transplant, they should get priority, but of course we still want to match as many patients to donors as possible. Considering the complexity of the separate decision problems, the combined problem might have a higher complexity, perhaps corresponding to the \u03a3P2 -complexity of our grounded disjunctive normal ASP program with aggregate functions [1, 3]. It should be noticed however that the addition of constraints not necessarily increases complexity and a precise classification of complexity is desirable."}, {"heading": "6 Conclusion", "text": "We formalized and solved different variants of the SMP using ASP programs, which can easily be adapted to yet other variants. Moreover we applied saturation to compute optimal stable sets, with the advantage that these programs can be handled with the efficient off-the-shelf ASP solver DLV. To the best of our knowledge, our encoding offers the first exact implementation of finding sex-equal, egalitarian, minimum regret, or maximum cardinality stable sets for an instance of the SMP with unacceptability and ties. Hence, our general framework allows us to tackle a class of problems and requires only small adaptions to easily shift between them."}], "references": [{"title": "Knowledge Representation, Reasoning, and Declarative Problem Solving", "author": ["C. Baral"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Communications of the ACM,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2011}, {"title": "Aggregate functions in disjunctive logic programming: Semantics, complexity, and implementation in DLV", "author": ["T. Dell\u2019Armi", "W. Faber", "G. Ielpa", "N. Leone", "G. Pfeifer"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "An argumentation-theoretic foundation for logic programming", "author": ["P.M. Dung"], "venue": "The Journal of Logic Programming,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1995}, {"title": "Disjunctive datalog", "author": ["T. Eiter", "G. Gottlob", "H. Mannila"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1997}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "College admissions and the stability of marriage", "author": ["D. Gale", "L.S. Shapley"], "venue": "The American Mathematical Monthly,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1962}, {"title": "Some remarks on the stable matching problem", "author": ["D. Gale", "M. Sotomayor"], "venue": "Discr. Appl. Math.,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1985}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In ICLP/SLP,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1988}, {"title": "Three fast algorithms for four problems in stable marriage", "author": ["D. Gusfield"], "venue": "SIAM J. Comput.,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1987}, {"title": "Stable marriage and indifference", "author": ["R.W. Irving"], "venue": "Discr. Appl. Math.,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1994}, {"title": "The cycle roommates problem: a hard case of kidney", "author": ["R.W. Irving"], "venue": "exchange. Inf. Process. Lett.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "An efficient algorithm for the \u201coptimal\u201d stable marriage", "author": ["R.W. Irving", "P. Leather", "D. Gusfield"], "venue": "J. ACM,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1987}, {"title": "A survey of the stable marriage problem and its variants", "author": ["K. Iwama", "S. Miyazaki"], "venue": "In Proc. of the Intern. Conf. on Informatics Educ. and Research for Knowledge-Circulating Society,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2008}, {"title": "Representing normal programs with clauses", "author": ["T. Janhunen"], "venue": "Proc. of the 16th European Conference on Artificial Intelligence,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2004}, {"title": "Complexity of the sex-equal stable marriage problem", "author": ["A. Kato"], "venue": "Japan Journal of Industrial ans Applied Mathematics (JJIAM),", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1993}, {"title": "Stable marriage with ties and unacceptable partners", "author": ["D. Manlove"], "venue": "Technical report,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1999}, {"title": "Hard variants of stable marriage", "author": ["D. Manlove", "R.W. Irving", "K. Iwama", "S. Miyazaki", "Y. Morita"], "venue": "Theoretical Computer Science,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2002}, {"title": "A theory of nonmonotonic rule systems I", "author": ["V.W. Marek", "A. Nerode", "J.B. Remmel"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1990}, {"title": "Sex-equal stable matchings: Complexity and exact algorithms", "author": ["E. McDermid", "R.W. Irving"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2012}, {"title": "Pairwise kidney exchange", "author": ["A.E. Roth", "T. S\u00f6mnez", "M.U. \u00dcnver"], "venue": "J. Econ. Theory,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2005}, {"title": "Two-Sided Matching: A Study in Game-Theoretic Modeling and Analysis", "author": ["A.E. Roth", "M.A.O. Sotomayor"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1990}, {"title": "Egalitarian stable matching for VM migration in cloud computing", "author": ["H. Xu", "B. Li"], "venue": "In Computer Communications Workshops (INFOCOM WKSHPS),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2011}], "referenceMentions": [{"referenceID": 6, "context": "The Stable Marriage Problem (SMP) is a well-known matching problem first introduced and solved by Gale and Shapley [7].", "startOffset": 115, "endOffset": 118}, {"referenceID": 6, "context": "The Stable Marriage Problem (SMP) is a matching problem first introduced and solved by Gale and Shapley [7].", "startOffset": 104, "endOffset": 107}, {"referenceID": 11, "context": "assumptions more applicable to a wider range of applications, such as kidney-exchange [12] and the hospital-resident problem [18].", "startOffset": 86, "endOffset": 90}, {"referenceID": 17, "context": "assumptions more applicable to a wider range of applications, such as kidney-exchange [12] and the hospital-resident problem [18].", "startOffset": 125, "endOffset": 129}, {"referenceID": 9, "context": "[10, 13, 20]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 12, "context": "[10, 13, 20]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 19, "context": "[10, 13, 20]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 19, "context": "[20]), to the best of our knowledge, our encoding offers the first exact implementation to find sex-equal, minimum regret, egalitarian or maximum cardinality stable sets for SMP instances with unacceptability and ties.", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "To solve the standard SMP, Gale and Shapley [7] constructed an iterative algorithm \u2014known as the Gale-Shapley algorithm, G-S algorithm or deferred-acceptance algorithm\u2014 to compute a particular solution of an SMP instance.", "startOffset": 44, "endOffset": 47}, {"referenceID": 6, "context": "This point, when everyone has a partner, is always reached after a polynomial number of steps and the corresponding set of marriages is stable [7].", "startOffset": 143, "endOffset": 146}, {"referenceID": 21, "context": "A stable matching for an SMP instance with unacceptability always exists and can be found in polynomial time [22] by a slightly modified G-S algorithm.", "startOffset": 109, "endOffset": 113}, {"referenceID": 21, "context": "In this setting, there is exactly one stable set of marriages [22]: {(m1, w4), (m2, w3), (m3, w1), (w2, w2)}.", "startOffset": 62, "endOffset": 66}, {"referenceID": 10, "context": "For this variant there are several ways to define stability, but we will use the notion of weak stability [11].", "startOffset": 106, "endOffset": 110}, {"referenceID": 13, "context": "A weakly stable matching always exists for an instance of the SMP with unacceptability and ties and it can be found in polynomial time by arbitrarily breaking the ties [14].", "startOffset": 168, "endOffset": 172}, {"referenceID": 1, "context": "Answer Set Programming or ASP is a form of declarative programming [2].", "startOffset": 67, "endOffset": 70}, {"referenceID": 1, "context": "[2] for a good overview).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "no strict subset of I is a model of P [9].", "startOffset": 38, "endOffset": 41}, {"referenceID": 18, "context": "For instance in [19] a specific variant of the SMP is mentioned (in which boys each know a subset of a set of girls and want to be matched to a girl they know) and in [4] an abductive program is used to find a stable set of marriages in which two fixed persons are paired, with strict, complete preference lists.", "startOffset": 16, "endOffset": 20}, {"referenceID": 3, "context": "For instance in [19] a specific variant of the SMP is mentioned (in which boys each know a subset of a set of girls and want to be matched to a girl they know) and in [4] an abductive program is used to find a stable set of marriages in which two fixed persons are paired, with strict, complete preference lists.", "startOffset": 167, "endOffset": 170}, {"referenceID": 17, "context": "In [18] it is shown that the decision problem \u2018is the pair (m,w) stable?\u2019 for a given SMP instance with unacceptablity and ties is an NP-complete problem, even in the absence of unacceptability.", "startOffset": 3, "endOffset": 7}, {"referenceID": 0, "context": "brave reasoning), which is known to be an NP-complete problem [1].", "startOffset": 62, "endOffset": 65}, {"referenceID": 21, "context": "The stable set found by the G-S algorithm is M-optimal [22], i.", "startOffset": 55, "endOffset": 59}, {"referenceID": 6, "context": "Exchanging the roles of men and women in the G-S algorithm yields a W-optimal stable set [7], optimal from the point of view of the women.", "startOffset": 89, "endOffset": 92}, {"referenceID": 22, "context": "In [23] the use of an egalitarian stable set is proposed to optimally match virtual machines (VM) to servers in order to improve cloud computing by equalizing the importance of migration overhead in the data center network and VM migration performance.", "startOffset": 3, "endOffset": 7}, {"referenceID": 20, "context": "Examples of practical applications include an efficient kidney exchange program [21] and the National Resident Matching Program [18].", "startOffset": 80, "endOffset": 84}, {"referenceID": 17, "context": "Examples of practical applications include an efficient kidney exchange program [21] and the National Resident Matching Program [18].", "startOffset": 128, "endOffset": 132}, {"referenceID": 16, "context": "[17, 18] proved that the problem of finding a maximum (or minimum) cardinality stable set for a given instance of the SMP with unacceptability and ties is NP-hard.", "startOffset": 0, "endOffset": 8}, {"referenceID": 17, "context": "[17, 18] proved that the problem of finding a maximum (or minimum) cardinality stable set for a given instance of the SMP with unacceptability and ties is NP-hard.", "startOffset": 0, "endOffset": 8}, {"referenceID": 17, "context": "Using this result, the problem of finding an egalitarian or minimum regret stable matching for a given SMP instance with ties is proved to be NP-hard [18], even if the ties occur on one side only and each tie is of length 2 (i.", "startOffset": 150, "endOffset": 154}, {"referenceID": 12, "context": "If there are no ties, the problem of finding an egalitarian or minimum regret stable set is solvable in polynomial time [13, 10].", "startOffset": 120, "endOffset": 128}, {"referenceID": 9, "context": "If there are no ties, the problem of finding an egalitarian or minimum regret stable set is solvable in polynomial time [13, 10].", "startOffset": 120, "endOffset": 128}, {"referenceID": 6, "context": "Since all stable sets consist of n couples in the classical SMP, the G-S algorithm trivially finds a maximum (or minimum) cardinality [7].", "startOffset": 134, "endOffset": 137}, {"referenceID": 7, "context": "For an SMP instance with unacceptability the number of couples in a stable set is constant [8], so finding a maximum cardinality stable set reduces to finding a stable set, which is known to be solvable in polynomial time.", "startOffset": 91, "endOffset": 94}, {"referenceID": 15, "context": "Surprisingly, finding a sex-equal stable set for a classical SMP instance is NP-hard [16], even if the preference lists are bound in length by 3 [20].", "startOffset": 85, "endOffset": 89}, {"referenceID": 19, "context": "Surprisingly, finding a sex-equal stable set for a classical SMP instance is NP-hard [16], even if the preference lists are bound in length by 3 [20].", "startOffset": 145, "endOffset": 149}, {"referenceID": 15, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 12, "endOffset": 16}, {"referenceID": 12, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 25, "endOffset": 29}, {"referenceID": 9, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 39, "endOffset": 43}, {"referenceID": 6, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 53, "endOffset": 56}, {"referenceID": 19, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 78, "endOffset": 82}, {"referenceID": 7, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 85, "endOffset": 88}, {"referenceID": 17, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 108, "endOffset": 112}, {"referenceID": 17, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 121, "endOffset": 125}, {"referenceID": 16, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 153, "endOffset": 161}, {"referenceID": 17, "context": "SMP NP-hard [16] P (O(n) [13]) P (O(n) [10]) P (O(n) [7]) SMP + unacc NP-hard [20] P [8] SMP + ties NP-hard [18] NP-hard [18] SMP + {unacc,ties} NP-hard [17, 18]", "startOffset": 153, "endOffset": 161}, {"referenceID": 19, "context": "To the best of our knowledge, the only exact algorithm tackling an NP-hard problem from Table 1 finds a sex-equal stable set for an SMP instance in which the strict preference lists of men and/or women are bounded in length by a constant [20].", "startOffset": 238, "endOffset": 242}, {"referenceID": 4, "context": "In particular, we use a saturation technique [5, 1] to filter non-optimal answer sets.", "startOffset": 45, "endOffset": 51}, {"referenceID": 0, "context": "In particular, we use a saturation technique [5, 1] to filter non-optimal answer sets.", "startOffset": 45, "endOffset": 51}, {"referenceID": 14, "context": "Therefore, we use a SAT encoding [15] of the ASP program in Definition 4 and define a", "startOffset": 33, "endOffset": 37}, {"referenceID": 5, "context": "of literals such that for every i there is a program rule for which li+1 is a positive body literal and li is in the head [6].", "startOffset": 122, "endOffset": 125}, {"referenceID": 5, "context": "Because our program is absolutely tight, we know that the completion will correspond to it [6].", "startOffset": 91, "endOffset": 94}, {"referenceID": 5, "context": "Lemma 3 follows form the fact that the completion corresponds to the original program [6].", "startOffset": 86, "endOffset": 89}, {"referenceID": 8, "context": "Hence J \u2032 satisfies all the rules of red(Pcrit, I), implying that I, which strictly contains J , cannot be an answer set of Pcrit since it is not a minimal model of the negation-free ASP program red(Pcrit, I) [9].", "startOffset": 209, "endOffset": 212}, {"referenceID": 8, "context": "I and check wether I is a minimal model of the reduct [9].", "startOffset": 54, "endOffset": 57}, {"referenceID": 16, "context": "\u2264 k) for an SMP instance with unacceptability and ties with k a positive integer?\u2019 [17, 18] has practical importance, e.", "startOffset": 83, "endOffset": 91}, {"referenceID": 17, "context": "\u2264 k) for an SMP instance with unacceptability and ties with k a positive integer?\u2019 [17, 18] has practical importance, e.", "startOffset": 83, "endOffset": 91}, {"referenceID": 17, "context": "in the National Resident Matching Program [18].", "startOffset": 42, "endOffset": 46}, {"referenceID": 0, "context": "brave reasoning), another NP-complete problem [1].", "startOffset": 46, "endOffset": 49}, {"referenceID": 0, "context": "Considering the complexity of the separate decision problems, the combined problem might have a higher complexity, perhaps corresponding to the \u03a32 -complexity of our grounded disjunctive normal ASP program with aggregate functions [1, 3].", "startOffset": 231, "endOffset": 237}, {"referenceID": 2, "context": "Considering the complexity of the separate decision problems, the combined problem might have a higher complexity, perhaps corresponding to the \u03a32 -complexity of our grounded disjunctive normal ASP program with aggregate functions [1, 3].", "startOffset": 231, "endOffset": 237}], "year": 2013, "abstractText": "The Stable Marriage Problem (SMP) is a well-known matching problem first introduced and solved by Gale and Shapley [7]. Several variants and extensions to this problem have since been investigated to cover a wider set of applications. Each time a new variant is considered, however, a new algorithm needs to be developed and implemented. As an alternative, in this paper we propose an encoding of the SMP using Answer Set Programming (ASP). Our encoding can easily be extended and adapted to the needs of specific applications. As an illustration we show how stable matchings can be found when individuals may designate unacceptable partners and ties between preferences are allowed. Subsequently, we show how our ASP based encoding naturally allows us to select specific stable matchings which are optimal according to a given criterion. Each time, we can rely on generic and efficient off-the-shelf answer set solvers to find (optimal) stable matchings.", "creator": "LaTeX with hyperref package"}}}