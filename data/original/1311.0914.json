{"id": "1311.0914", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Nov-2013", "title": "A Divide-and-Conquer Solver for Kernel Support Vector Machines", "abstract": "The kernel support vector machine (SVM) is one of the most widely used classification methods; however, the amount of computation required becomes the bottleneck when facing millions of samples. In this paper, we propose and analyze a novel divide-and-conquer solver for kernel SVMs (DC-SVM). In the division step, we partition the kernel SVM problem into smaller subproblems by clustering the data, so that each subproblem can be solved independently and efficiently. We show theoretically that the support vectors identified by the subproblem solution are likely to be support vectors of the entire kernel SVM problem, provided that the problem is partitioned appropriately by kernel clustering. In the conquer step, the local solutions from the subproblems are used to initialize a global coordinate descent solver, which converges quickly as suggested by our analysis. By extending this idea, we develop a multilevel Divide-and-Conquer SVM algorithm with adaptive clustering and early prediction strategy, which outperforms state-of-the-art methods in terms of training speed, testing accuracy, and memory usage. As an example, on the covtype dataset with half-a-million samples, DC-SVM is 7 times faster than LIBSVM in obtaining the exact SVM solution (to within $10^{-6}$ relative error) which achieves 96.15% prediction accuracy. Moreover, with our proposed early prediction strategy, DC-SVM achieves about 96% accuracy in only 12 minutes, which is more than 100 times faster than LIBSVM.", "histories": [["v1", "Mon, 4 Nov 2013 22:06:40 GMT  (389kb,D)", "http://arxiv.org/abs/1311.0914v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["cho-jui hsieh", "si si", "inderjit s dhillon"], "accepted": true, "id": "1311.0914"}, "pdf": {"name": "1311.0914.pdf", "metadata": {"source": "CRF", "title": "A Divide-and-Conquer Solver for Kernel Support Vector Machines", "authors": ["Cho-Jui Hsieh", "Inderjit S. Dhillon"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The support vector machine (SVM) [Cortes and Vapnik, 1995] is probably the most widely used classifier in varied machine learning applications. For problems that are not linearly separable, kernel SVM uses a \u201ckernel trick\u201d to implicitly map samples from input space to a high-dimensional feature space, where samples become linearly separable. Due to its importance, optimization methods for kernel SVM have been widely studied [Platt, 1998, Joachims, 1998], and efficient libraries such as LIBSVM [Chang and Lin, 2011] and SVMLight [Joachims, 1998] are well developed. However, the kernel SVM is still hard to scale up when the sample size reaches more than one million instances. The bottleneck stems from the high computational cost and memory requirements of computing and storing the kernel matrix, which in general is not sparse. By approximating the kernel SVM objective function, approximate solvers [Zhang et al., 2012, Le et al., 2013] avoid high computational cost and memory requirement, but suffer in terms of prediction accuracy.\nIn this paper, we propose a novel divide and conquer approach (DC-SVM) to efficiently solve the kernel SVM problem. DC-SVM achieves faster convergence speed compared to state-of-the-art exact SVM solvers, as well as better prediction accuracy in much less time than approximate solvers. To accomplish this performance, DC-SVM first divides the full problem into smaller subproblems, which can be solved independently and efficiently. We theoretically show that the kernel kmeans algorithm is able to minimize the difference between the solution of subproblems and of the whole problem, and support vectors identified by subproblems are very likely to be support vectors of the whole problem. However, running kernel kmeans on the whole dataset is time consuming, so we apply a two-step kernel kmeans procedure to efficiently find the partition. In the conquer step, the local solutions from the subproblems are \u201cglued\u201d together to yield an initial point for the global problem. As suggested by our analysis, the coordinate descent method in the final stage converges quickly to the global optimal.\nar X\niv :1\n31 1.\n09 14\nv1 [\ncs .L\nG ]\n4 N\nov 2\n01 3\nEmpirically, our proposed Divide-and-Conquer Kernel SVM solver can reduce the objective function value much faster than existing SVM solvers. For example, on the covtype dataset with half a million samples, DC-SVM can find an accurate globally optimal solution (to within 10\u22126 accuracy) within 3 hours on a single machine with 8 GBytes RAM, while the state-of-the-art solver LIBSVM takes more than 22 hours to achieve a similarly accurate solution (which yields 96.15% prediction accuracy). More interestingly, due to the closeness of the subproblem solutions to the global solution, we can employ an early prediction approach, using which DC-SVM can obtain high test accuracy extremely quickly. For example, on the covtype dataset, by using early prediction DC-SVM achieves 96.03% prediction accuracy within 12 minutes, while other solvers cannot achieve such performance in 10 hours.\nThe rest of the paper is outlined as follows. We propose the single-level DC-SVM in Section 3, and extend it to the multilevel version in Section 4. Experimental comparison with other state-of-the-art SVM solvers is shown in Section 5. The relationship between DC-SVM and other methods is discussed in Section 2, and the conclusions are given in Section 6. Extensive experimental comparisons are included in the Appendix."}, {"heading": "2 Related Work", "text": "The optimization methods for SVM training has been intensively studied. Since training an SVM requires a large amount of memory, it is natural to apply decomposition methods [Platt, 1998], where only a subset of variables is updated at each step. Based on this idea, software packages such as LIBSVM [Chang and Lin, 2011] and SVMLight [Joachims, 1998] are well developed. To speed up the decomposition method, [Pe\u0301rez-Cruz et al., 2004] proposed a double chunking approach to maintain a chunk of important samples, and the shrinking technique [Joachims, 1998] is also widely used to eliminate unimportant samples.\nTo speed up kernel SVM training on large-scale datasets, it is natural to divide the problem into smaller subproblems, and combine the models trained on each partition. [Jacobs et al., 1991] proposed a way to combine models, although in their algorithm subproblems are not trained independently, while [Tresp, 2000] discussed a Bayesian prediction scheme (BCM) for model combination. [Collobert et al., 2002] partition the training dataset arbitrarily in the beginning, and then iteratively refine the partition to obtain an approximate kernel SVM solution. [Kugler et al., 2006] applied the above ideas to solve multi-class problems. [Graf et al., 2005] proposed a multilevel approach (CascadeSVM): they randomly build a partition tree of samples and train the SVM in a \u201ccascade\u201d way: only support vectors in the lower level of the tree are passed to the upper level. However, no earlier method appears to discuss an elegant way to partition the data. In this paper, we theoretically show that kernel kmeans minimizes the error of the solution from the subproblems and the global solution. Based on this division step, we propose a simple method to combine locally trained SVM models, and show that the testing performance is better than BCM in terms of both accuracy and time (as presented in Table 1). More importantly, DC-SVM solves the original SVM problem, not just an approximated one. We compare our method with Cascade SVM in the experiments.\nAnother line of research proposes to reduce the training time by representing the whole dataset using a smaller set of landmark points, and clustering is an effective way to find landmark points (cluster centers). [Moody and Darken, 1989] proposed this idea to train the reduced sized problem with RBF kernel (LTPU); [Pavlov et al., 2000] used a similar idea as a preprocessing of the dataset, while [Yu et al., 2005] further generalized this approach to a hierarchical coarsen-refinement solver for SVM. Based on this idea, the kmeans Nystro\u0308m method [Zhang et al., 2008] was proposed to approximate the kernel matrix using landmark points. [Boley and Cao, 2004] proposed to find samples with similar \u03b1 values by clustering, so both the clustering goal and training step are quite different from ours. All the above approaches focus on modeling the betweencluster (between-landmark points) relationships. In comparison, our method emphasizes on preserving the within-cluster relationships at the lower levels and explores the between-cluster information in the upper levels. We compare DC-SVM with LLSVM (using kmeans Nystro\u0308m) and LTPU in Section 5.\nThere are many other approximate solvers for the kernel SVM, including kernel approximation approaches [Fine and Scheinberg, 2001, Zhang et al., 2012, Le et al., 2013], greedy basis selection [Keerthi et al., 2006], and online SVM solvers [Bordes et al., 2005]. Recently, [Jose et al., 2013] proposed an approximate solver to reduce testing time, while our work is focused on reducing the training time of kernel SVM."}, {"heading": "3 Divide and Conquer Kernel SVM with a single level", "text": "Given a set of instance-label pairs (xi, yi), i = 1, . . . , n,xi \u2208 Rd and yi \u2208 {1,\u22121}, the main task in training the kernel SVM is to solve the following quadratic optimization problem:\nmin \u03b1 f(\u03b1) =\n1 2 \u03b1TQ\u03b1\u2212 eT\u03b1, s.t. 0 \u2264 \u03b1 \u2264 C, (1)\nwhere e is the vector of all ones; C is the balancing parameter between loss and regularization in the SVM primal problem; \u03b1 \u2208 Rn is the vector of dual variables; and Q is an n\u00d7 n matrix with Qij = yiyjK(xi,xj), where K(xi,xj) is the kernel function. Note that, as in [Keerthi et al., 2006, Joachims, 2006], we ignore the \u201cbias\u201d term \u2013 indeed, in our experiments reported in Section 5, we did not observe any improvement in test accuracy by including the bias term. Letting \u03b1\u2217 denote the optimal solution of (1), the decision value for a test data x can be computed by \u2211n i=1 \u03b1 \u2217 i yiK(x,xi).\nWe begin by describing the single-level version of our proposed algorithm. The main idea behind our divide and conquer SVM solver (DC-SVM) is to divide the data into smaller subsets, where each subset can be handled efficiently and independently. The subproblem solutions are then used to initialize a coordinate descent solver for the whole problem. To do this, we first partition the dual variables into k subsets {V1, . . . ,Vk}, and then solve the respective subproblems independently\nmin \u03b1(c)\n1 2 (\u03b1(c)) TQ(c,c)\u03b1(c)\u2212eT\u03b1(c), s.t. 0\u2264\u03b1(c)\u2264C, (2)\nwhere c = 1, . . . , k, \u03b1(c) denotes the subvector {\u03b1p | p \u2208 Vc} and Q(c,c) is the submatrix of Q with row and column indexes Vc.\nThe quadratic programming problem (1) has n variables, and generally takes O(n3) time to solve. By dividing it into k subproblems (2) with equal sizes, the time complexity for solving the subproblems can be dramatically reduced to O(k \u00b7 (nk )\n3) = O(n3/k2). Moreover, the space requirement is also reduced from O(n2) to O(n2/k2).\nAfter computing all the subproblem solutions, we concatenate them to form an approximate solution for the whole problem \u03b1\u0304 = [\u03b1\u0304(1), . . . , \u03b1\u0304(k)], where \u03b1\u0304(c) is the optimal solution for the c-th subproblem. In the conquer step, \u03b1\u0304 is used to initialize the solver for the whole problem. We show that this procedure achieves faster convergence due to the following reasons: (1) \u03b1\u0304 is close to the optimal solution for the whole problem \u03b1\u2217, so the solver only requires a few iterations to converge (see Theorem 1); (2) the set of support vectors of the subproblems is expected to be close to the set of support vectors of the whole problem (see Theorem 2). Hence, the coordinate descent solver for the whole problem converges very quickly.\nDivide Step. We now discuss in detail how to divide problem (1) into subproblems. In order for our proposed method to be efficient, we require \u03b1\u0304 to be close to the optimal solution of the original problem \u03b1\u2217. In the following, we derive a bound on \u2016\u03b1\u0304\u2212\u03b1\u2217\u20162 by first showing that \u03b1\u0304 is the optimal solution of (1) with an approximate kernel.\nLemma 1. \u03b1\u0304 is the optimal solution of (1) with kernel function K(xi,xj) replaced by\nK\u0304(xi,xj) = I(\u03c0(xi), \u03c0(xj))K(xi,xj), (3)\nwhere \u03c0(xi) is the cluster that xi belongs to; I(a, b) = 1 iff a = b and I(a, b) = 0 otherwise.\nProof. When using K\u0304 defined in (3), the matrix Q in (1) becomes Q\u0304 as given below:\nQ\u0304i,j =\n{ yiyjK(xi,xj), if \u03c0(xi) = \u03c0(xj),\n0, if \u03c0(xi) 6= \u03c0(xj). (4)\nTherefore, the quadratic term in (1) can be decomposed into\n\u03b1T Q\u0304\u03b1 = k\u2211 c=1 \u03b1T(c)Q(c,c)\u03b1(c).\nThe constraints and linear term in (1) are also decomposable, so the subproblems are independent, and concatenation of their optimal solutions, \u03b1\u0304, is the optimal solution for (1) when K is replaced by K\u0304.\nBased on the above lemma, we are able to bound \u2016\u03b1\u2217\u2212 \u03b1\u0304\u20162 by the sum of between-cluster kernel values:\nTheorem 1. Given data points x1, . . . ,xn and a partition indicator {\u03c0(x1), . . . , \u03c0(xn)},\n0 \u2264 f(\u03b1\u0304)\u2212 f(\u03b1\u2217) \u2264 (1/2)C2D(\u03c0), (5)\nwhere f(\u03b1) is the objective function in (1), \u03b1\u0304 is as in Lemma 1, \u03b1\u2217 is the global optimal of (1) and D(\u03c0) =\u2211 i,j:\u03c0(xi)6=\u03c0(xj) |K(xi,xj)|. Furthermore, \u2016\u03b1\n\u2217 \u2212 \u03b1\u0304\u201622 \u2264 C2D(\u03c0)/\u03c3n where \u03c3n is the smallest eigenvalue of the kernel matrix.\nProof. We use f\u0304(\u03b1) to denote the objective function of (1) with kernel K\u0304. By Lemma 1, \u03b1\u0304 is the minimizer of (1) with K replaced by K\u0304, thus f\u0304(\u03b1\u0304) \u2264 f\u0304(\u03b1\u2217). By the definition of f\u0304(\u03b1\u2217) we can easily show that\nf\u0304(\u03b1\u2217) = f(\u03b1\u2217)\u2212 1 2 \u2211 i,j:\u03c0(xi)6=\u03c0(xj) \u03b1\u2217i\u03b1 \u2217 jyiyjK(xi,xj) (6)\nSimilarly, we have\nf\u0304(\u03b1\u0304) = f(\u03b1\u0304)\u2212 1 2 \u2211 i,j:\u03c0(xi) 6=\u03c0(xj) \u03b1\u0304i\u03b1\u0304jyiyjK(xi,xj), (7)\nCombining with f\u0304(\u03b1\u0304) \u2264 f\u0304(\u03b1\u2217) we have\nf(\u03b1\u0304) \u2264 f\u0304(\u03b1\u2217) + 1 2 \u2211 i,j:\u03c0(xi)6=\u03c0(xj) \u03b1\u0304i\u03b1\u0304jyiyjK(xi,xj),\n= f(\u03b1\u2217) + 1\n2 \u2211 i,j:\u03c0(xi) 6=\u03c0(xj) (\u03b1\u0304i\u03b1\u0304j \u2212 \u03b1\u2217i\u03b1\u2217j )yiyjK(xi,xj) (8)\n\u2264 f(\u03b1\u2217)+ 1 2 C2D(\u03c0), since 0 \u2264 \u03b1\u0304i, \u03b1\u2217i \u2264 C for all i.\nAlso, since \u03b1\u2217 is the optimal solution of (1) and \u03b1\u0304 is a feasible solution, f(\u03b1\u2217) \u2264 f(\u03b1\u0304), thus proving the first part of the theorem.\nLet \u03c3n be the smallest singular value of the positive definite kernel matrix K. Since Q = diag(y)Kdiag(y), Q and K have identical singular values. Suppose we write \u03b1\u0304 = \u03b1\u2217 + \u2206\u03b1,\nf(\u03b1\u0304) = f(\u03b1\u2217) + (\u03b1\u2217)TQ\u2206\u03b1+ 1\n2 (\u2206\u03b1)TQ\u2206\u03b1\u2212 eT\u2206\u03b1.\nThe optimality condition for (1) is\n\u2207if(\u03b1\u2217)  = 0 if 0 < \u03b1\u2217i < C,\n\u2265 0 if \u03b1\u2217i = 0, \u2264 0 if \u03b1\u2217i = C,\n(9)\nwhere \u2207f(\u03b1\u2217) = Q\u03b1\u2217 \u2212 e. Since \u03b1\u0304 is a feasible solution, it is easy to see that (\u2206\u03b1)i \u2265 0 if \u03b1\u2217i = 0, and (\u2206\u03b1)i \u2264 0 if \u03b1\u2217i = C. Thus,\n(\u2206\u03b1)T (Q\u03b1\u2217 \u2212 e) = n\u2211 i=1 (\u2206\u03b1)i((Q\u03b1 \u2217)i \u2212 1) \u2265 0.\nSo f(\u03b1\u0304) \u2265 f(\u03b1\u2217) + 12\u2206\u03b1 TQ\u2206\u03b1 \u2265 f(\u03b1\u2217) + 12\u03c3n\u2016\u2206\u03b1\u2016 2 2. Since we already know that f(\u03b1\u0304) \u2264 f(\u03b1\u2217) + 1 2C 2D({xi}ni=1, \u03c0), this implies \u2016\u03b1\u2217 \u2212 \u03b1\u0304\u201622 \u2264 C2D(\u03c0)/\u03c3n.\nIn order to minimize \u2016\u03b1\u2217 \u2212 \u03b1\u0304\u2016, we want to find a partition with small D(\u03c0). Moreover, a balanced partition is preferred to achieve faster training speed. This can be done by the kernel kmeans algorithm, which aims to minimize the off-diagonal values of the kernel matrix with a balancing normalization.\nWe now show that the bound derived in Theorem 1 is reasonably tight in practice. On a subset (10000 instances) of the covtype data, we try different numbers of clusters k = 8, 16, 32, 64, 128; for each k, we use kernel kmeans to obtain the data partition {V1, . . . ,Vk}, and then compute C2D(\u03c0)/2 (the right hand side of (5)) and f(\u03b1\u0304)\u2212f(\u03b1\u2217) (the left hand side of (5)). The results are presented in Figure 1. The left panel shows the bound (in red) and the difference in objectives f(\u03b1\u0304)\u2212f(\u03b1\u2217) in absolute scale, while the right panel shows these values in a log scale. Figure 1 shows that the bound is quite close to the difference in objectives in an absolute sense (the red and blue curves nearly overlap), especially compared to the difference in objectives when the data is partitioned randomly (this also shows effectiveness of the kernel kmeans procedure). Thus, our data partitioning scheme and subsequent solution of the subproblems leads to good approximations to the global kernel SVM problem.\nHowever, kernel kmeans has O(n2d) time complexity, which is too expensive for large-scale problems. Therefore we consider a simple two-step kernel kmeans approach as in [Ghitta et al., 2011]. The two-step kernel kmeans algorithm first runs kernel kmeans on m randomly sampled data points (m n) to construct cluster centers in the kernel space. Based on these centers, each data point computes its distance to cluster centers and decides which cluster it belongs to. The algorithm has time complexity O(nmd) and space complexity O(m2).\nA key facet of our proposed divide and conquer algorithm is that the set of support vectors from the subproblems S\u0304 := {i | \u03b1\u0304i > 0}, where \u03b1\u0304i is the i-th element of \u03b1\u0304, is very close to that of the whole problem S := {i | \u03b1\u2217i > 0}. Letting f\u0304(\u03b1) denote the objective function of (1) with kernel K\u0304 defined in (3), the following theorem shows that when \u03b1\u0304i = 0 (xi is not a support vector of the subproblem) and \u2207if\u0304(\u03b1\u0304) is large enough, then xi will not be a support vector of the whole problem.\nTheorem 2. For any i \u2208 {1, . . . , n}, if \u03b1\u0304i = 0 and\n\u2207if\u0304(\u03b1\u0304) > CD(\u03c0)(1 + \u221a nKmax/ \u221a \u03c3nD(\u03c0)),\nwhere Kmax = maxiK(xi,xi), then xi will not be a support vector of the whole problem, i.e., \u03b1 \u2217 i = 0.\nProof. Let \u2206Q = Q\u2212 Q\u0304 and \u2206\u03b1 = \u03b1\u2217 \u2212 \u03b1\u0304. From the optimality condition for (1) (see (9)), we know that \u03b1\u2217i = 0 if (Q\u03b1 \u2217)i > 1. Since Q\u03b1 \u2217 = (Q\u0304+ \u2206Q)(\u03b1\u0304+ \u2206\u03b1), we see that\n(Q\u03b1\u2217)i = (Q\u0304\u03b1\u0304)i + (\u2206Q\u03b1\u0304)i + ((Q\u0304+ \u2206Q)\u2206\u03b1)i. = (Q\u0304\u03b1\u0304)i + \u2211\nj:\u03c0(xi)6=\u03c0(xj)\nyiyjK(xi,xj)\u03b1\u0304j + \u2211 j yiyjK(xi,xj)(\u2206\u03b1)j\n\u2265 (Q\u0304\u03b1\u0304)i \u2212 CD(\u03c0)\u2212Kmax\u2016\u2206\u03b1\u20161 \u2265 (Q\u0304\u03b1\u0304)i \u2212 CD(\u03c0)\u2212 \u221a nKmaxC \u221a D(\u03c0)/ \u221a \u03c3n\n= (Q\u0304\u03b1\u0304)i \u2212 CD(\u03c0) ( 1 +\n\u221a nKmax\u221a \u03c3nD(\u03c0)\n) .\nThe condition stated in the theorem implies (Q\u0304\u03b1\u0304)i > 1+CD(\u03c0)(1+ \u221a nKmax\u221a \u03c3nD(\u03c0)\n), which implies (Q\u03b1\u2217)i\u22121 > 0, so from the optimality condition (9), \u03b1\u2217i = 0.\nIn practice also, we observe that DC-SVM can identify the set of support vectors of the whole problem very quickly. Figure 2 demonstrates that DC-SVM identifies support vectors much faster than the shrinking strategy implemented in LIBSVM [Chang and Lin, 2011] (we discuss these results in more detail in Section 4).\nConquer Step. After computing \u03b1\u0304 from the subproblems, we use \u03b1\u0304 to initialize the solver for the whole problem. In principle, we can use any SVM solver in our divide and conquer framework, but we focus on using coordinate descent method as in LIBSVM to solve the whole problem. The main idea is to update one variable at a time, and always choose the \u03b1i with the largest gradient value to update. The benefit of applying coordinate descent is that we can avoid a lot of unnecessary access to the kernel matrix entries if\n\u03b1i never changes from zero to nonzero. Since \u03b1\u0304\u2019s are close to \u03b1 \u2217, the \u03b1\u0304-values for most vectors that are not support vectors will not become nonzero, and so the algorithm converges quickly."}, {"heading": "4 Divide and Conquer SVM with multiple levels", "text": "There is a trade-off in choosing the number of clusters k for a single-level DC-SVM with only one divide and conquer step. When k is small, the subproblems have similar sizes as the original problem, so we will not gain much speedup. On the other hand, when we increase k, time complexity for solving subproblems can be reduced, but the resulting \u03b1\u0304 can be quite different from \u03b1\u2217 according to Theorem 1, so the conquer step will be slow. Therefore, we propose to run DC-SVM with multiple levels to further reduce the time for solving the subproblems, and meanwhile still obtain \u03b1\u0304 values that are close to \u03b1\u2217.\nIn multilevel DC-SVM, at the l-th level, we partition the whole dataset into kl clusters {V(l)1 , . . . ,V (l) kl }, and solve those kl subproblems independently to get \u03b1\u0304(l). In order to solve each subproblem efficiently, we use the solutions from the lower level \u03b1\u0304(l+1) to initialize the solver at the l-th level, so each level requires very few iterations. This allows us to use small values of k, for example, we use k = 4 for all the experiments. In the following, we discuss more insights to further speed up our procedure.\nAdaptive Clustering. The two-step kernel kmeans approach has time complexity O(nmd), so the number of samples m cannot be too large. In our implementation we use m = 1000. When the data set is very large, the performance of two-step kernel kmeans may not be good because we sample only a few data points. This will influence the performance of DC-SVM.\nTo improve the clustering for DC-SVM, we propose the following adaptive clustering approach. The main idea is to explore the sparsity of \u03b1 in the SVM problem, and sample from the set of support vectors to perform two-step kernel kmeans. The number of support vectors is generally much smaller than n because of the bound constraints. Suppose we are at the l-th level, and the current set of support vectors is defined by S\u0304 = {i | \u03b1\u0304i > 0}. Suppose the set of support vectors for the final solution is given by S\u2217 = {i | \u03b1\u2217i > 0}. We can define the sum of off-diagonal elements on S\u0304 \u222a S\u2217 as DS\u2217\u222aS\u0304(\u03c0) = \u2211 i,j\u2208S\u2217\u222aS\u0304 and \u03c0(xi) 6=\u03c0(xj) |K(xi,xj)|. The following theorem shows that we can refine the bound in Theorem 1:\nTheorem 3. Given data points x1, . . . ,xn and a partition {V1, . . . ,Vk} with indicators \u03c0,\n0 \u2264 f(\u03b1\u0304)\u2212 f(\u03b1\u2217) \u2264 (1/2)C2DS\u2217\u222aS\u0304(\u03c0).\nFurthermore, \u2016\u03b1\u2217 \u2212 \u03b1\u0304\u201622 \u2264 C2DS\u2217\u222aS\u0304(\u03c0)/\u03c3n.\nProof. Similar to the proof in Theorem 1, we use f\u0304(\u03b1) to denote the objective function of (1) with kernel K\u0304. Combine (8) with the fact that \u03b1\u2217i = 0 \u2200i /\u2208 S\u2217 and \u03b1\u0304i = 0 \u2200i /\u2208 S\u0304, we have\nf(\u03b1\u0304) \u2264 f(\u03b1\u2217)\u2212 1 2 \u2211 i,j:\u03c0(xi)6=\u03c0(xj) and i,j\u2208S\u2217 (\u03b1\u0304i\u03b1\u0304j \u2212 \u03b1\u2217i\u03b1\u2217j )yiyjK(xi,xj)\n\u2264 f(\u03b1\u2217) + 1 2 C2DS\u2217\u222aS\u0304(\u03c0).\nThe second part of the proof is identical to the proof of the second part of Theorem 1.\nThe above observations suggest that if we know the set of support vectors S\u0304 and S\u2217, \u2016\u03b1\u2217 \u2212 \u03b1\u0304\u2016 only depends on whether we can obtain a good partition of S\u0304 \u222a S\u2217. Therefore, we can sample m points from S\u0304 \u222a S\u2217 instead of the whole dataset to perform the clustering. The performance of two-step kernel kmeans depends on the sampling rate; we reduce the sampling rate from m/n to m/|S\u2217 \u222a S\u0304|. As a result, the performance significantly improves when |S\u2217 \u222a S\u0304| n.\nIn practice we do not know S\u2217 or S\u0304 before solving the problem. However, both Theorem 2 and experiments shown in Figure 2 suggest that we have a good guess of support vectors even at the bottom level. Therefore, we can use the lower level support vectors as a good guess of the upper level support vectors. More specifically,\nafter computing \u03b1\u0304l from level l, we can use its support vector set S\u0304l := {i | \u03b1\u0304li > 0} to run two-step kernel kmeans for finding the clusters at the (l \u2212 1)-th level. Using this strategy, we obtain progressively better partitioning as we approach the original problem at the top level.\nEarly identification of support vectors. We first run LIBSVM to obtain the final set of support vectors, and then run DC-SVM with various numbers of clusters 45, 44, . . . , 40 (corresponding to level 5, 4, . . . , 1 for multilevel DC-SVM). We show the precision and recall for the \u03b1\u0304 at each level in identifying support vectors. Figure 2 shows that DC-SVM can identify about 90% support vectors even using 256 clusters. As discussed in Section 2, Cascade SVM [Graf et al., 2005] is another way to identify support vectors. However, it is clear from Figure 2 that Cascade SVM cannot identify support vectors accurately as (1) it does not use kernel kmeans clustering, and (2) it cannot correct the false negative error made in lower levels. Figure 2c, 2d, 2g, 2h further shows that DC-SVM identifies support vectors more quickly than the shrinking strategy in LIBSVM.\nEarly prediction based on the l-th level solution. Computing the exact kernel SVM solution can be quite time consuming, so it is important to obtain a good model using limited time and memory. We now propose a way to efficiently predict the label of unknown instances using the lower-level models \u03b1\u0304l. We will see in the experiments that prediction using \u03b1\u0304l from a lower level l already can achieve near-optimal testing performance.\nWhen the l-th level solution \u03b1\u0304l is computed, a single naive way to predict a new instance x\u2019s label y\u0303 is:\ny\u0303 = sign ( n\u2211 i=1 yi\u03b1\u0304 l iK(x,xi) ) . (10)\nAnother way to combine the models trained from k clusters is to use the probabilistic framework proposed in the Bayesian Committee Machine (BCM) [Tresp, 2000]. However, as we show below, both these methods do not give good prediction accuracy when the number of clusters is large.\nInstead, we propose the following early prediction strategy. From Lemma 1, \u03b1\u0304 is the optimal solution to the SVM dual problem (1) on the whole dataset with the approximated kernel K\u0304 defined in (3). Therefore, we propose to use the same kernel function K\u0304 in the testing phase, which leads to the prediction\nk\u2211 c=1 \u2211 i\u2208Vc yi\u03b1iK\u0304(xi,x) = \u2211 i\u2208V\u03c0(x) yi\u03b1iK(xi,x), (11)\nwhere \u03c0(x) can be computed by finding the nearest cluster center. Therefore, the testing procedure for early prediction is: (1) find the nearest cluster that x belongs to, and then (2) use the model trained by data within that cluster to compute the decision value.\nWe compare this method with prediction by (10) and BCM in Table 1. The results show that our proposed testing scheme is better in terms of test accuracy. We also compare average testing time per instance in Table 1, and our proposed method is much more efficient as we only evaluate K(x,xi) for all xi in the same cluster as x, thus reducing the testing time from O(|S|d) to O(|S|d/k), where S is the set of support vectors.\nRefine solution before solving the whole problem. Before training the final model at the top level using the whole dataset, we can refine the initialization by solving the SVM problem induced by all support vectors at the first level, i.e., level below the final level. As proved in Theorem 2, the support vectors of\nlower level models are likely to be the support vectors of the whole model, so this will give a more accurate solution, and only requires us to solve a problem with O(|S\u0304(1)|) samples, where S\u0304(1) is the support vectors at the first level. Our final algorithm is given in Algorithm 1.\nAlgorithm 1: Divide and Conquer SVM\nInput : Training data {(xi, yi)}ni=1, balancing parameter C, kernel function. Output: The SVM dual solution \u03b1. for l = lmax, . . . , 1 do\nSet number of clusters in the current level kl = k l; if l = lmax then Sample m points {xi1 , . . . ,xim} from the whole training set; else\nSample m points {xi1 , . . . ,xim} from {xi | \u03b1\u0304 (l+1) i > 0};\nend Run kernel kmeans on {xi1 , . . . ,xim} to get cluster centers c1, . . . , ckl ; Obtain partition V1, . . . ,Vkl for all data points ; for c = 1, . . . , kl do\nObtain \u03b1\u0304 (l) Vc by solving SVM for the data in the c-th cluster Vc with \u03b1\u0304 (l+1) Vc as the initial point ( \u03b1\u0304lmax+1Vc is set to 0);\nend\nend Refine solution: Compute \u03b1(0) by solving SVM on {xi | \u03b1(1)i 6= 0} using \u03b1(1) as the initial point; Solve SVM on the whole data using \u03b1(0) as the initial point;"}, {"heading": "5 Experimental Results", "text": "We now compare our proposed algorithm with other SVM solvers. All the experiments are conducted on an Intel Xeon X5355 2.66GHz CPU with 8G RAM.\nDatasets: We use 7 benchmark datasets as shown in Table 21. We use the raw data without scaling for two image datasets cifar and mnist8m, while features in all the other datasets are linearly scaled to [0, 1]. mnist8m is a digital recognition dataset with 10 numbers, so we follow the procedure in [Zhang et al., 2012] to transform it into a binary classification problem by classifying round digits and non-round digits. Similarly, we transform cifar into a binary classification problem by classifying animals and non-animals. We use a random 80%-20% split for covtype, webspam, kddcup99, a random 8M/0.1M split for mnist8m (used in the original paper [Loosli et al., 2007]), and the original training/testing split for ijcnn1 and cifar.\nCompeting Methods: We include the following exact SVM solvers (LIBSVM, CascadeSVM), approximate SVM solvers (SpSVM, LLSVM, FastFood, LTPU), and online SVM (LaSVM) in our comparison:\n1. LIBSVM: the implementation in the LIBSVM library [Chang and Lin, 2011] with a small modification to handle SVM without the bias term \u2013 we observe that LIBSVM has similar test accuracy with/without bias. 2. Cascade SVM: we implement cascade SVM [Graf et al., 2005] using LIBSVM as the base solver. 3. SpSVM: Greedy basis selection for nonlinear SVM [Keerthi et al., 2006]. 4. LLSVM: improved Nystro\u0308m method for nonlinear SVM by [Wang et al., 2011]. 5. FastFood: use random Fourier features to approximate the kernel function [Le et al., 2013]. We solve\nthe resulting linear SVM problem by the dual coordinate descent solver in LIBLINEAR.\n1cifar can be downloaded from http://www.cs.toronto.edu/~kriz/cifar.html; other datasets can be downloaded from http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets or the UCI data repository.\nthe model before solving the entire kernel SVM optimization problem. [Zhang et al., 2012] reported that the low-rank approximation based method (LLSVM) outperforms Core Vector Machines [Tsang et al., 2005] and the bundle method [Smola et al., 2007], so we omit those comparisons here. Notice that we apply LIBSVM/LIBLINEAR as the default solver for DC-SVM, FastFood, Cascade SVM, LLSVM and LTPU, so the shrinking heuristic is automatically used in the experiments.\nParameter Setting: We first consider the RBF kernel K(xi,xj) = exp(\u2212\u03b3\u2016xi \u2212 xj\u201622). We chose the balancing parameter C and kernel parameter \u03b3 by 5-fold cross validation on a grid of points: C = [2\u221210, 2\u22129, . . . , 210] and \u03b3 = [2\u221210, . . . , 210] for ijcnn1, census, covtype, webspam, and kddcup99. The average distance between samples for un-scaled image datasets mnist8m and cifar is much larger than other datasets, so we test them on smaller \u03b3\u2019s: \u03b3 = [2\u221230, 2\u221229, . . . , 2\u221210]. Regarding the parameters for DC-SVM, we use 5 levels (lmax = 4) and k = 4, so the five levels have 1, 4, 16, 64 and 256 clusters respectively. For DC-SVM (early), we stop at the level with 64 clusters. The following are parameter settings for other methods in Table 3: the rank is set to be 3000 in LLSVM; number of Fourier features is 3000 in Fastfood2; number of clusters is 3000 in LTPU; number of basis vectors is 200 in SpSVM; the tolerance in the stopping condition for LIBSVM and DC-SVM is set to 10\u22123 (the default setting of LIBSVM); for LaSVM we set the number of passes to be 1; for CascadeSVM we output the results after the first round.\n2In Fastfood we control the number of blocks so that number of Fourier features is close to 3000 for each dataset.\nExperimental Results with RBF kernel: Table 3 presents time taken and test accuracies. Experimental results show that the early prediction approach in DC-SVM achieves near-optimal test performance. By going to the top level (handling the whole problem), DC-SVM achieves better test performance but needs more time. Table 3 only gives the comparison on one setting; it is natural to ask, for example, about the performance of LIBSVM with a looser stopping condition, or Fastfood with varied number of Fourier features. Therefore, for each algorithm we change the parameter settings and present more detailed results in Figure 3.\nFigure 3 shows convergence results with time \u2013 in 3a, 3b, 3c the relative error on the y-axis is defined as (f(\u03b1) \u2212 f(\u03b1\u2217))/f(\u03b1\u2217), where \u03b1\u2217 is computed by running LIBSVM with 10\u22128 accuracy. Online and approximate solvers are not included in this comparison as they do not solve the exact kernel SVM problem. We observe that DC-SVM achieves faster convergence in objective function compared with the state-of-theart exact SVM solvers. Moreover, DC-SVM is also able to achieve superior test accuracy in lesser training time as compared with approximate solvers. Figure 3d, 3e, 3f compare the efficiency in achieving different testing accuracies. We can see that DC-SVM consistently achieves more than 50 fold speedup while achieving higher testing accuracy.\nExperimental Results with varying values of C, \u03b3: As shown in Theorem 1 the quality of approximation depends on D(\u03c0), which is strongly related to the kernel parameters. In the RBF kernel, when \u03b3 is large, a large portion of kernel entries will be close to 0, and D(\u03c0) will be small so that \u03b1\u0304 is a good initial point for the top level. On the other hand, when \u03b3 is small, \u03b1\u0304 may not be close to the optimal solution. To test the performance of DC-SVM under different parameters, we conduct the comparison on a wide range of parameters (C = [2\u221210, 2\u22126, 21, 26, 210], \u03b3 = [2\u221210, 2\u22126, 21, 26, 210]). The results on the ijcnn1, covtype, webspam and census datasets are shown in Tables 7, 8, 9, 10 (in the appendix). We observe that even when \u03b3 is small, DC-SVM is still 1-2 times faster than LIBSVM: among all the 100 settings, DC-SVM is faster on 96/100 settings. The reason is that even when \u03b1\u0304 is not close to \u03b1, using \u03b1\u0304 as the initial point is still better than initialization with a random or zero vector. On the other hand, DC-SVM (early) is extremely fast, and achieves almost the same or even better accuracy when \u03b3 is small (as it uses an approximated kernel). In Figure 5, 7, 6, 8 (in appendix) we plot the performance of DC-SVM and LIBSVM under various C and \u03b3 values, the results indicate that DC-SVM (early) is more robust to parameters. The accumulated runtimes are shown in Table 5.\nExperimental Results with the polynomial kernel: To show that DC-SVM is efficient for different types of kernels, we further conduct experiments on covtype and webspam datasets for the degree-3 polynomial kernel K(xi,xj) = (\u03b7 + \u03b3x T i xj)\n3. For the polynomial kernel, the parameters chosen by cross validation are C = 2, \u03b3 = 1 for covtype, and C = 8, \u03b3 = 16 for webspam. We set \u03b7 = 0, which is the default setting in LIBSVM. Figures 4a and 4c compare the training speed of DC-SVM and LIBSVM for reducing the objective function value while Figures 4b and 4d show the testing accuracy compared with LIBSVM and LaSVM. Since LLSVM, FastFood and LPTU are developed for shift-invariant kernels, we do not include them in our\ncomparison. We can see that when using the polynomial kernel, our algorithm is more than 100 times faster than LIBSVM and LaSVM. One main reason for such large improvement is that it is hard for LIBSVM and LaSVM to identify the right set of support vectors when using the polynomial kernel. As shown in Figure 2, LIBSVM cannot even identify 20% of the support vectors in 105 seconds, while DC-SVM has a very good guess of the support vectors even at the bottom level, where number of clusters is 256.\nClustering time vs Training time. Our DC-SVM algorithm is composed of two important parts: clustering and SVM training. In Table 6 we list the time taken by each part; we can see that the clustering time is almost constant at each level, while the rest of the training time keeps increasing."}, {"heading": "6 Conclusions", "text": "In this paper, we have proposed a novel divide and conquer algorithm for solving kernel SVMs (DC-SVM). Our algorithm divides the problem into smaller subproblems that can be solved independently and efficiently. We show that the subproblem solutions are close to that of the original problem, which motivates us to \u201cglue\u201d\nsolutions from subproblems in order to efficiently solve the original kernel SVM problem. Using this, we also incorporate an early prediction strategy into our algorithm. We report extensive experiments to demonstrate that DC-SVM significantly outperforms state-of-the-art exact and approximate solvers for nonlinear kernel SVM on large-scale datasets. The code for DC-SVM is available at http://www.cs.utexas.edu/~cjhsieh/ dcsvm."}], "references": [{"title": "Training support vector machine using adaptive clustering", "author": ["D. Boley", "D. Cao"], "venue": "In SDM,", "citeRegEx": "Boley and Cao.,? \\Q2004\\E", "shortCiteRegEx": "Boley and Cao.", "year": 2004}, {"title": "Fast kernel classifiers with online and active learning", "author": ["A. Bordes", "S. Ertekin", "J. Weston", "L. Bottou"], "venue": "JMLR, 6:1579\u20131619,", "citeRegEx": "Bordes et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bordes et al\\.", "year": 2005}, {"title": "LIBSVM: A library for support vector machines", "author": ["Chih-Chung Chang", "Chih-Jen Lin"], "venue": "ACM Transactions on Intelligent Systems and Technology,", "citeRegEx": "Chang and Lin.,? \\Q2011\\E", "shortCiteRegEx": "Chang and Lin.", "year": 2011}, {"title": "A parallel mixture of SVMs for very large scale problems", "author": ["R. Collobert", "S. Bengio", "Y. Bengio"], "venue": "In NIPS,", "citeRegEx": "Collobert et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Collobert et al\\.", "year": 2002}, {"title": "Efficient SVM training using low-rank kernel representations", "author": ["S. Fine", "K. Scheinberg"], "venue": "JMLR, 2:243\u2013264,", "citeRegEx": "Fine and Scheinberg.,? \\Q2001\\E", "shortCiteRegEx": "Fine and Scheinberg.", "year": 2001}, {"title": "Approximate kernel k-means: Solution to large scale kernel clustering", "author": ["Radha Ghitta", "Rong Jin", "Timothy C. Havens", "Anil K. Jain"], "venue": "In KDD,", "citeRegEx": "Ghitta et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ghitta et al\\.", "year": 2011}, {"title": "Parallel support vector machines: The cascade SVM", "author": ["H.P. Graf", "E. Cosatto", "L. Bottou", "I. Dundanovic", "V. Vapnik"], "venue": "In NIPS,", "citeRegEx": "Graf et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Graf et al\\.", "year": 2005}, {"title": "Adaptive mixtures of local experts", "author": ["R.A. Jacobs", "M.I. Jordan", "S.J. Nowlan", "G.E. Hinton"], "venue": "Neural Computation,", "citeRegEx": "Jacobs et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Jacobs et al\\.", "year": 1991}, {"title": "Making large-scale SVM learning practical", "author": ["T. Joachims"], "venue": "In Advances in Kernel Methods \u2013 Support Vector Learning,", "citeRegEx": "Joachims.,? \\Q1998\\E", "shortCiteRegEx": "Joachims.", "year": 1998}, {"title": "Training linear SVMs in linear time", "author": ["T. Joachims"], "venue": "In KDD,", "citeRegEx": "Joachims.,? \\Q2006\\E", "shortCiteRegEx": "Joachims.", "year": 2006}, {"title": "Local deep kernel learning for efficient non-linear SVM prediction", "author": ["C. Jose", "P. Goyal", "P. Aggrwal", "M. Varma"], "venue": "In ICML,", "citeRegEx": "Jose et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Jose et al\\.", "year": 2013}, {"title": "Building support vector machines with reduced classifier", "author": ["S.S. Keerthi", "O. Chapelle", "D. DeCoste"], "venue": "complexity. JMLR,", "citeRegEx": "Keerthi et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Keerthi et al\\.", "year": 2006}, {"title": "CombNET-III: a support vector machine based large scale classifier with probabilistic framework", "author": ["M. Kugler", "S. Kuroyanagi", "A.S. Nugroho", "A. Iwata"], "venue": "IEICE Trans. Inf. and Syst.,", "citeRegEx": "Kugler et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Kugler et al\\.", "year": 2006}, {"title": "Fastfood \u2013 approximating kernel expansions in loglinear time", "author": ["Q.V. Le", "T. Sarlos", "A.J. Smola"], "venue": "In ICML,", "citeRegEx": "Le et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Le et al\\.", "year": 2013}, {"title": "Training invariant support vector machines using selective sampling", "author": ["Ga\u00eblle Loosli", "St\u00e9phane Canu", "L\u00e9on Bottou"], "venue": "In Large Scale Kernel Machines,", "citeRegEx": "Loosli et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Loosli et al\\.", "year": 2007}, {"title": "Fast learning in networks of locally-tuned processing units", "author": ["John Moody", "Christian J. Darken"], "venue": "Neural Computation,", "citeRegEx": "Moody and Darken.,? \\Q1989\\E", "shortCiteRegEx": "Moody and Darken.", "year": 1989}, {"title": "Towards scalable support vector machines using squashing", "author": ["D. Pavlov", "D. Chudova", "P. Smyth"], "venue": "In KDD,", "citeRegEx": "Pavlov et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Pavlov et al\\.", "year": 2000}, {"title": "Art\u00e9s-Rod\u0155\u0131guez. Double chunking for solving SVMs for very large datasets", "author": ["F. P\u00e9rez-Cruz", "A.R. Figueiras-Vidal"], "venue": "In Proceedings of Learning", "citeRegEx": "P\u00e9rez.Cruz et al\\.,? \\Q2004\\E", "shortCiteRegEx": "P\u00e9rez.Cruz et al\\.", "year": 2004}, {"title": "Fast training of support vector machines using sequential minimal optimization", "author": ["J.C. Platt"], "venue": "In Advances in Kernel Methods - Support Vector Learning,", "citeRegEx": "Platt.,? \\Q1998\\E", "shortCiteRegEx": "Platt.", "year": 1998}, {"title": "Bundle methods for machine learning", "author": ["A. Smola", "S. Vishwanathan", "Q. Le"], "venue": null, "citeRegEx": "Smola et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Smola et al\\.", "year": 2007}, {"title": "A Bayesian committee machine", "author": ["V. Tresp"], "venue": "Neural Computation,", "citeRegEx": "Tresp.,? \\Q2000\\E", "shortCiteRegEx": "Tresp.", "year": 2000}, {"title": "Core vector machines: Fast SVM training on very large data", "author": ["I.W. Tsang", "J.T. Kwok", "P.M. Cheung"], "venue": "sets. JMLR,", "citeRegEx": "Tsang et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Tsang et al\\.", "year": 2005}, {"title": "Trading representability for scalability: Adaptive multihyperplane machine for nonlinear classification", "author": ["Z. Wang", "N. Djuric", "K. Crammer", "S. Vucetic"], "venue": "In KDD,", "citeRegEx": "Wang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2011}, {"title": "Making SVMs scalable to large data sets using hierarchical cluster indexing", "author": ["Hwanjo Yu", "Jiong Yang", "Jiawei Han", "Xiaolei Li"], "venue": "Data Mining and Knowledge Discovery,", "citeRegEx": "Yu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Yu et al\\.", "year": 2005}, {"title": "Improved Nystr\u00f6m low rank approximation and error analysis", "author": ["K. Zhang", "I.W. Tsang", "J.T. Kwok"], "venue": "In ICML,", "citeRegEx": "Zhang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2008}, {"title": "Scaling up kernel SVM on limited resources: A low-rank linearization approach", "author": ["K. Zhang", "L. Lan", "Z. Wang", "F. Moerchen"], "venue": "In AISTATS,", "citeRegEx": "Zhang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 2, "context": "Due to its importance, optimization methods for kernel SVM have been widely studied [Platt, 1998, Joachims, 1998], and efficient libraries such as LIBSVM [Chang and Lin, 2011] and SVMLight [Joachims, 1998] are well developed.", "startOffset": 154, "endOffset": 175}, {"referenceID": 8, "context": "Due to its importance, optimization methods for kernel SVM have been widely studied [Platt, 1998, Joachims, 1998], and efficient libraries such as LIBSVM [Chang and Lin, 2011] and SVMLight [Joachims, 1998] are well developed.", "startOffset": 189, "endOffset": 205}, {"referenceID": 18, "context": "Since training an SVM requires a large amount of memory, it is natural to apply decomposition methods [Platt, 1998], where only a subset of variables is updated at each step.", "startOffset": 102, "endOffset": 115}, {"referenceID": 2, "context": "Based on this idea, software packages such as LIBSVM [Chang and Lin, 2011] and SVMLight [Joachims, 1998] are well developed.", "startOffset": 53, "endOffset": 74}, {"referenceID": 8, "context": "Based on this idea, software packages such as LIBSVM [Chang and Lin, 2011] and SVMLight [Joachims, 1998] are well developed.", "startOffset": 88, "endOffset": 104}, {"referenceID": 17, "context": "To speed up the decomposition method, [P\u00e9rez-Cruz et al., 2004] proposed a double chunking approach to maintain a chunk of important samples, and the shrinking technique [Joachims, 1998] is also widely used to eliminate unimportant samples.", "startOffset": 38, "endOffset": 63}, {"referenceID": 8, "context": ", 2004] proposed a double chunking approach to maintain a chunk of important samples, and the shrinking technique [Joachims, 1998] is also widely used to eliminate unimportant samples.", "startOffset": 114, "endOffset": 130}, {"referenceID": 7, "context": "[Jacobs et al., 1991] proposed a way to combine models, although in their algorithm subproblems are not trained independently, while [Tresp, 2000] discussed a Bayesian prediction scheme (BCM) for model combination.", "startOffset": 0, "endOffset": 21}, {"referenceID": 20, "context": ", 1991] proposed a way to combine models, although in their algorithm subproblems are not trained independently, while [Tresp, 2000] discussed a Bayesian prediction scheme (BCM) for model combination.", "startOffset": 119, "endOffset": 132}, {"referenceID": 3, "context": "[Collobert et al., 2002] partition the training dataset arbitrarily in the beginning, and then iteratively refine the partition to obtain an approximate kernel SVM solution.", "startOffset": 0, "endOffset": 24}, {"referenceID": 12, "context": "[Kugler et al., 2006] applied the above ideas to solve multi-class problems.", "startOffset": 0, "endOffset": 21}, {"referenceID": 6, "context": "[Graf et al., 2005] proposed a multilevel approach (CascadeSVM): they randomly build a partition tree of samples and train the SVM in a \u201ccascade\u201d way: only support vectors in the lower level of the tree are passed to the upper level.", "startOffset": 0, "endOffset": 19}, {"referenceID": 15, "context": "[Moody and Darken, 1989] proposed this idea to train the reduced sized problem with RBF kernel (LTPU); [Pavlov et al.", "startOffset": 0, "endOffset": 24}, {"referenceID": 16, "context": "[Moody and Darken, 1989] proposed this idea to train the reduced sized problem with RBF kernel (LTPU); [Pavlov et al., 2000] used a similar idea as a preprocessing of the dataset, while [Yu et al.", "startOffset": 103, "endOffset": 124}, {"referenceID": 23, "context": ", 2000] used a similar idea as a preprocessing of the dataset, while [Yu et al., 2005] further generalized this approach to a hierarchical coarsen-refinement solver for SVM.", "startOffset": 69, "endOffset": 86}, {"referenceID": 24, "context": "Based on this idea, the kmeans Nystr\u00f6m method [Zhang et al., 2008] was proposed to approximate the kernel matrix using landmark points.", "startOffset": 46, "endOffset": 66}, {"referenceID": 0, "context": "[Boley and Cao, 2004] proposed to find samples with similar \u03b1 values by clustering, so both the clustering goal and training step are quite different from ours.", "startOffset": 0, "endOffset": 21}, {"referenceID": 11, "context": ", 2013], greedy basis selection [Keerthi et al., 2006], and online SVM solvers [Bordes et al.", "startOffset": 32, "endOffset": 54}, {"referenceID": 1, "context": ", 2006], and online SVM solvers [Bordes et al., 2005].", "startOffset": 32, "endOffset": 53}, {"referenceID": 10, "context": "Recently, [Jose et al., 2013] proposed an approximate solver to reduce testing time, while our work is focused on reducing the training time of kernel SVM.", "startOffset": 10, "endOffset": 29}, {"referenceID": 5, "context": "Therefore we consider a simple two-step kernel kmeans approach as in [Ghitta et al., 2011].", "startOffset": 69, "endOffset": 90}, {"referenceID": 2, "context": "Figure 2 demonstrates that DC-SVM identifies support vectors much faster than the shrinking strategy implemented in LIBSVM [Chang and Lin, 2011] (we discuss these results in more detail in Section 4).", "startOffset": 123, "endOffset": 144}, {"referenceID": 20, "context": "6ms BCM in [Tresp, 2000] 98.", "startOffset": 11, "endOffset": 24}, {"referenceID": 6, "context": "As discussed in Section 2, Cascade SVM [Graf et al., 2005] is another way to identify support vectors.", "startOffset": 39, "endOffset": 58}, {"referenceID": 20, "context": "Another way to combine the models trained from k clusters is to use the probabilistic framework proposed in the Bayesian Committee Machine (BCM) [Tresp, 2000].", "startOffset": 145, "endOffset": 158}, {"referenceID": 25, "context": "mnist8m is a digital recognition dataset with 10 numbers, so we follow the procedure in [Zhang et al., 2012] to transform it into a binary classification problem by classifying round digits and non-round digits.", "startOffset": 88, "endOffset": 108}, {"referenceID": 14, "context": "1M split for mnist8m (used in the original paper [Loosli et al., 2007]), and the original training/testing split for ijcnn1 and cifar.", "startOffset": 49, "endOffset": 70}, {"referenceID": 2, "context": "LIBSVM: the implementation in the LIBSVM library [Chang and Lin, 2011] with a small modification to handle SVM without the bias term \u2013 we observe that LIBSVM has similar test accuracy with/without bias.", "startOffset": 49, "endOffset": 70}, {"referenceID": 6, "context": "Cascade SVM: we implement cascade SVM [Graf et al., 2005] using LIBSVM as the base solver.", "startOffset": 38, "endOffset": 57}, {"referenceID": 11, "context": "SpSVM: Greedy basis selection for nonlinear SVM [Keerthi et al., 2006].", "startOffset": 48, "endOffset": 70}, {"referenceID": 22, "context": "LLSVM: improved Nystr\u00f6m method for nonlinear SVM by [Wang et al., 2011].", "startOffset": 52, "endOffset": 71}, {"referenceID": 13, "context": "FastFood: use random Fourier features to approximate the kernel function [Le et al., 2013].", "startOffset": 73, "endOffset": 90}, {"referenceID": 15, "context": "LTPU: Locally-Tuned Processing Units proposed in [Moody and Darken, 1989].", "startOffset": 49, "endOffset": 73}, {"referenceID": 1, "context": "LaSVM: An online algorithm proposed in [Bordes et al., 2005].", "startOffset": 39, "endOffset": 60}, {"referenceID": 25, "context": "[Zhang et al., 2012] reported that the low-rank approximation based method (LLSVM) outperforms Core Vector Machines [Tsang et al.", "startOffset": 0, "endOffset": 20}, {"referenceID": 21, "context": ", 2012] reported that the low-rank approximation based method (LLSVM) outperforms Core Vector Machines [Tsang et al., 2005] and the bundle method [Smola et al.", "startOffset": 103, "endOffset": 123}, {"referenceID": 19, "context": ", 2005] and the bundle method [Smola et al., 2007], so we omit those comparisons here.", "startOffset": 30, "endOffset": 50}], "year": 2013, "abstractText": "The kernel support vector machine (SVM) is one of the most widely used classification methods; however, the amount of computation required becomes the bottleneck when facing millions of samples. In this paper, we propose and analyze a novel divide-and-conquer solver for kernel SVMs (DC-SVM). In the division step, we partition the kernel SVM problem into smaller subproblems by clustering the data, so that each subproblem can be solved independently and efficiently. We show theoretically that the support vectors identified by the subproblem solution are likely to be support vectors of the entire kernel SVM problem, provided that the problem is partitioned appropriately by kernel clustering. In the conquer step, the local solutions from the subproblems are used to initialize a global coordinate descent solver, which converges quickly as suggested by our analysis. By extending this idea, we develop a multilevel Divide-and-Conquer SVM algorithm with adaptive clustering and early prediction strategy, which outperforms state-of-the-art methods in terms of training speed, testing accuracy, and memory usage. As an example, on the covtype dataset with half-a-million samples, DC-SVM is 7 times faster than LIBSVM in obtaining the exact SVM solution (to within 10\u22126 relative error) which achieves 96.15% prediction accuracy. Moreover, with our proposed early prediction strategy, DC-SVM achieves about 96% accuracy in only 12 minutes, which is more than 100 times faster than LIBSVM.", "creator": "LaTeX with hyperref package"}}}