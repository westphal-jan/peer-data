{"id": "1311.2241", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2013", "title": "Learning Gaussian Graphical Models with Observed or Latent FVSs", "abstract": "Gaussian Graphical Models (GGMs) or Gauss Markov random fields are widely used in many applications, and the trade-off between the modeling capacity and the efficiency of learning and inference has been an important research problem. In this paper, we study the family of GGMs with small feedback vertex sets (FVSs), where an FVS is a set of nodes whose removal breaks all the cycles. Exact inference such as computing the marginal distributions and the partition function has complexity $O(k^{2}n)$ using message-passing algorithms, where k is the size of the FVS, and n is the total number of nodes. We propose efficient structure learning algorithms for two cases: 1) All nodes are observed, which is useful in modeling social or flight networks where the FVS nodes often correspond to a small number of high-degree nodes, or hubs, while the rest of the networks is modeled by a tree. Regardless of the maximum degree, without knowing the full graph structure, we can exactly compute the maximum likelihood estimate in $O(kn^2+n^2\\log n)$ if the FVS is known or in polynomial time if the FVS is unknown but has bounded size. 2) The FVS nodes are latent variables, where structure learning is equivalent to decomposing a inverse covariance matrix (exactly or approximately) into the sum of a tree-structured matrix and a low-rank matrix. By incorporating efficient inference into the learning steps, we can obtain a learning algorithm using alternating low-rank correction with complexity $O(kn^{2}+n^{2}\\log n)$ per iteration. We also perform experiments using both synthetic data as well as real data of flight delays to demonstrate the modeling capacity with FVSs of various sizes.", "histories": [["v1", "Sun, 10 Nov 2013 02:39:48 GMT  (469kb,D)", "http://arxiv.org/abs/1311.2241v1", null]], "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["ying liu 0009", "alan s willsky"], "accepted": true, "id": "1311.2241"}, "pdf": {"name": "1311.2241.pdf", "metadata": {"source": "CRF", "title": "Learning Gaussian Graphical Models with Observed or Latent FVSs", "authors": ["Ying Liu", "Alan S. Willsky"], "emails": ["liu_ying@mit.edu", "willsky@mit.edu"], "sections": [{"heading": "1 Introduction", "text": "In undirected graphical models or Markov random fields, each node represents a random variable while the set of edges specifies the conditional independencies of the underlying distribution. When the random variables are jointly Gaussian, the models are called Gaussian graphical models (GGMs) or Gauss Markov random fields. GGMs, such as linear state space models, Bayesian linear regression models, and thin-membrane/thin-plate models, have been widely used in communication, image processing, medical diagnostics, and gene regulatory networks. In general, a larger family of graphs represent a larger collection of distributions and thus can better approximate arbitrary empirical distributions. However, many graphs lead to computationally expensive inference and learning algorithms. Hence, it is important to study the trade-off between modeling capacity and efficiency.\nBoth inference and learning are efficient for tree-structured graphs (graphs without cycles): inference can be computed exactly in linear time (with respect to the size of the graph) using belief propagation (BP) [1] while the learning problem can be solved exactly in quadratic time using the Chow-Liu algorithm [2]. Since trees have limited modeling capacity, many models beyond trees have been proposed [3, 4, 5, 6]. Thin junction trees (graphs with low tree-width) are extensions of trees, where inference can be solved efficiently using the junction algorithm [7]. However, learning\nar X\niv :1\n31 1.\n22 41\nv1 [\ncs .L\nG ]\n1 0\nN ov\njunction trees with tree-width greater than one is NP-complete [6] and tractable learning algorithms (e.g. [8]) often have constraints on both the tree-width and the maximum degree. Since graphs with large-degree nodes are important in modeling applications such as social networks, flight networks, and robotic localization, we are interested in finding a family of models that allow arbitrarily large degrees while being tractable for learning.\nBeyond thin-junction trees, the family of sparse GGMs is also widely studied [9, 10]. These models are often estimated using methods such as graphical lasso (or l-1 regularization) [11, 12]. However, a sparse GGM (e.g. a grid) does not automatically lead to efficient algorithms for exact inference. Hence, we are interested in finding a family of models that are not only sparse but also have guaranteed efficient inference algorithms.\nIn this paper, we study the family of GGMs with small feedback vertex sets (FVSs), where an FVS is a set of nodes whose removal breaks all cycles [13]. The authors of [14] have demonstrated that the computation of exact means and variances for such a GGM can be accomplished, using message-passing algorithms with complexity O(k2n), where k is the size of the FVS and n is the total number of nodes. They have also presented results showing that for models with larger FVSs, approximate inference (obtained by replacing a full FVS by a pseudo-FVS) can work very well, with empirical evidence indicating that a pseudo-FVS of size O(log n) gives excellent results. In Appendix A we will provide some additional analysis of inference for such models (including the computation of the partition function), but the main focus is maximum likelihood (ML) learning of models with FVSs of modest size, including identifying the nodes to include in the FVS.\nIn particular, we investigate two cases. In the first, all of the variables, including any to be included in the FVS are observed. We provide an algorithm for exact ML estimation that, regardless of the maximum degree, has complexityO(kn2 +n2 log n) if the FVS nodes are identified in advance and polynomial complexity if the FVS is to be learned and of bounded size. Moreover, we provide an approximate and much faster greedy algorithm when the FVS is unknown and large. In the second case, the FVS nodes are taken to be latent variables. In this case, the structure learning problem corresponds to the (exact or approximate) decomposition of an inverse covariance matrix into the sum of a tree-structured matrix and a low-rank matrix. We propose an algorithm that iterates between two projections, which can also be interpreted as alternating low-rank corrections. We prove that even though the second projection is onto a highly non-convex set, it is carried out exactly, thanks to the properties of GGMs of this family. By carefully incorporating efficient inference into the learning steps, we can further reduce the complexity to O(kn2 + n2 log n) per iteration. We also perform experiments using both synthetic data and real data of flight delays to demonstrate the modeling capacity with FVSs of various sizes. We show that empirically the family of GGMs of size O(log n) strikes a good balance between the modeling capacity and efficiency. Related Work In the context of classification, the authors of [15] have proposed the tree augmented naive Bayesian model, where the class label variable itself can be viewed as a size-one observed FVS; however, this model does not naturally extend to include a larger FVS. In [16], a convex optimization framework is proposed to learn GGMs with latent variables, where conditioned on a small number of latent variables, the remaining nodes induce a sparse graph. In our setting with latent FVSs, we further require the sparse subgraph to have tree structure."}, {"heading": "2 Preliminaries", "text": "Each undirected graphical model has an underlying graph G = (V, E), where V denotes the set of vertices (nodes) and E the set of edges. Each node s \u2208 V corresponds to a random variable xs. When the random vector xV is jointly Gaussian, the model is a GGM with density function given by p(x) = 1Z exp{\u2212 1 2x\nTJx + hTx}, where J is the information matrix or precision matrix, h is the potential vector, and Z is the partition function. The parameters J and h are related to the mean \u00b5 and covariance matrix \u03a3 by \u00b5 = J\u22121h and \u03a3 = J\u22121. The structure of the underlying graph is revealed by the sparsity pattern of J : there is an edge between i and j if and only if Jij 6= 0.\nGiven samples {xi}si=1 independently generated from an unknown distribution q in the family Q, the ML estimate is defined as qML = arg minq\u2208Q \u2211s i=1 log q(x\ni). For Gaussian distributions, the empirical distribution is p\u0302(x) = N (x; \u00b5\u0302, \u03a3\u0302), where the empirical mean \u00b5\u0302 = 1s \u2211s i=1 x i and the\nempirical covariance matrix \u03a3\u0302 = 1s \u2211s i=1 x i ( xi )T \u2212 \u00b5\u0302\u00b5\u0302T . The Kullback-Leibler (K-L) divergence\nbetween two distributions p and q is defined as DKL(p||q) = \u00b4 p(x) log p(x)q(x) dx. Without loss of generality, we assume in this paper the means are zero.\nTree-structured models are models whose underlying graphs do not have cycles. The ML estimate of a tree-structured model can be computed exactly using the Chow-Liu algorithm [2]. We use \u03a3CL = CL(\u03a3\u0302) and ECL = CLE(\u03a3\u0302) to denote respectively the covariance matrix and the set of edges learned using the Chow-Liu algorithm where the samples have empirical covariance matrix \u03a3\u0302."}, {"heading": "3 Gaussian Graphical Models with Known FVSs", "text": "In this section we briefly discuss some of the ideas related to GGMs with FVSs of size k, where we will also refer to the nodes in the FVS as feedback nodes. An example of a graph and its FVS is given in Figure 1, where the full graph (Figure 1a) becomes a cycle-free graph (Figure 1b) if nodes 1 and 2 are removed, and thus the set {1, 2} is an FVS.\n.\n1\n1\nGraphs with small FVSs have been studied in various contexts. The authors of [17] have characterized the family of graphs with small FVSs and their obstruction sets (sets of forbidden minors). FVSs are also related to the \u201cstable sets\u201d in the study of tournaments [18].\nGiven a GGM with an FVS of size k (where the FVS may or may not be given), the marginal means and variances \u00b5i = ( J\u22121h ) i and \u03a3ii = ( J\u22121 ) ii\n, for \u2200i \u2208 V can be computed exactly with complexity O(k2n) using the feedback message passing (FMP) algorithm proposed in [14], where standard BP is employed two times on the cycle-free subgraph among the non-feedback nodes while a special message-passing protocol is used for the FVS nodes. We provide a new algorithm in Appendix D, to compute det J , the determinant of J , and hence the partition function of such a model with complexity O(k2n). The algorithm is described and proved in Appendix A. An important point to note is that the complexity of these algorithms depends simply on the size k and the number of nodes n. There is no loss in generality in assuming that the size-k FVS F is fully connected and each of the feedback nodes has edges to every non-feedback node. In particular, after re-ordering the nodes so that the elements of F are the first k nodes (T = V \\F is the set of non-\nfeedback nodes of size n\u2212 k), we have that J = [ JF J T M\nJM JT\n] 0, where JT 0 corresponds to\na tree-structured subgraph among the non-feedback nodes, JF 0 corresponds to a complete graph among the feedback nodes, and all entries of JM may be non-zero as long as JT \u2212 JMJ\u22121F JTM 0 (while \u03a3 = [ \u03a3F \u03a3 T M\n\u03a3M JT\n] = J\u22121 0 ). We will refer to the family of such models with a given\nFVS F as QF , and the class of models with some FVS of size at most k as Qk.1 If we are not explicitly given an FVS, though the problem of finding an FVS of minimal size is NP-complete, the authors of [19] have proposed an efficient algorithm with complexity O(min{m log n, n2}), where m is the number of edges, that yields an FVS at most twice the minimum size (thus the inference complexity is increased only by a constant factor). However, the main focus of this paper, explored in the next section, is on learning models with small FVSs (so that when learned, the FVS is known). As we will see, the complexity of such algorithms is manageable. Moreover, as our experiments will demonstrate, for many problems, quite modestly sized FVSs suffice."}, {"heading": "4 Learning GGMs with Observed or Latent FVS of Size k", "text": "In this section, we study the problem of recovering a GGM from i.i.d. samples, where the feedback nodes are either observed or latent variables. If all nodes are observed, the empirical distribution\n1In general a graph does not have a unique FVS. The family of graphs with FVSs of size k includes all graphs where there exists an FVS of size k.\np\u0302(xF ,xT ) is parametrized by the empirical covariance matrix \u03a3\u0302 = [ \u03a3\u0302F \u03a3\u0302 T M\n\u03a3\u0302M \u03a3\u0302T\n] . If the feedback\nnodes are latent variables, the empirical distribution p\u0302(xT ) has empirical covariance matrix \u03a3\u0302T . With a slight abuse of notation, for a set A \u2282 V , we use q(xA) to denote the marginal distribution of xA under a distribution q(xV)."}, {"heading": "4.1 When All Nodes Are Observed", "text": "When all nodes are observed, we have two cases: 1) When an FVS of size k is given, we propose the conditioned Chow-Liu algorithm, which computes the exact ML estimate efficiently; 2) When no FVS is given a priori, we propose both an exact algorithm and a greedy approximate algorithm for computing the ML estimate."}, {"heading": "4.1.1 Case 1: An FVS of Size k Is Given.", "text": "When a size-k FVS F is given, the learning problem becomes solving\npML(xF ,xT ) = arg min q(xF ,xT )\u2208QF\nDKL(p\u0302(xF ,xT )||q(xF ,xT )). (1)\nThis optimization problem is defined on a highly non-convex set QF with combinatorial structures: indeed, there are (n \u2212 k)n\u2212k\u22122 possible spanning trees among the subgraph induced by the nonfeedback nodes. However, we are able to solve Problem (1) exactly using the conditioned Chow-Liu algorithm described in Algorithm 1.2 The intuition behind this algorithm is that even though the entire graph is not tree, the subgraph induced by the non-feedback nodes (which corresponds to the distribution of the non-feedback nodes conditioned on the feedback nodes) has tree structure, and thus we can find the best tree among the non-feedback nodes using the Chow-Liu algorithm applied on the conditional distribution. To obtain a concise expression, we also exploit a property of Gaussian distributions: the conditional information matrix (the information matrix of the conditional distribution) is simply a submatrix of the whole information matrix. In Step 1 of Algorithm 1, we compute the conditional covariance matrix using the Schur complement, and then in Step 2 we use the Chow-Liu algorithm to obtain the best approximate \u03a3CL (whose inverse is tree-structured). In Step 3, we match exactly the covariance matrix among the feedback nodes and the covariance matrix between the feedback nodes and the non-feedback nodes. For the covariance matrix among the non-feedback nodes, we add the matrix subtracted in Step 1 back to \u03a3CL. Proposition 1 states the correctness and the complexity of Algorithm 1. Its proof included in Appendix B.We denote the output covariance matrix of this algorithm as CCL(\u03a3\u0302).\nAlgorithm 1 The conditioned Chow-Liu algorithm Input: \u03a3\u0302 0 and an FVS F Output: EML and \u03a3ML\n1. Compute the conditional covariance matrix \u03a3\u0302T |F = \u03a3\u0302T \u2212 \u03a3\u0302M \u03a3\u0302\u22121F \u03a3\u0302TM .\n2. Let \u03a3CL = CL(\u03a3\u0302T |F ) and ECL = CLE(\u03a3\u0302T |F ). 3. EML = ECL and \u03a3ML = [ \u03a3\u0302F \u03a3\u0302 T M\n\u03a3\u0302M \u03a3CL + \u03a3\u0302M \u03a3\u0302 \u22121 F \u03a3\u0302 T M\n] .\nProposition 1. Algorithm 1 computes the ML estimate \u03a3ML and EML, exactly with complexity O(kn2 + n2 log n). In addition, all the non-zero entries of JML \u2206 = \u03a3\u22121ML can be computed with extra complexity O(k2n)."}, {"heading": "4.1.2 Case 2: The FVS Is to Be Learned", "text": "Structure learning becomes more computationally involved when the FVS is unknown. In this subsection, we present both exact and approximate algorithms for learning models with FVS of size no larger than k (i.e., in Qk). For a fixed empirical distribution p\u0302(xF ,xT ), we define d(F ), a set function of the FVS F as the minimum value of (1), i.e.,\n2Note that the conditioned Chow-Liu algorithm here is different from other variations of the Chow-Liu algorithm such as in [20] where the extensions are to enforce the inclusion or exclusion of a set of edges.\nd(F ) = min q(xF ,xT )\u2208QF\nDKL(p\u0302(xF ,xT )||q(xF ,xT )). (2)\nWhen the FVS is unknown, the ML estimate can be computed exactly by enumerating all possible( n\nk\n) FVSs of size k to find the F that minimizes d(F ). Hence, the exact solution can be obtained\nwith complexityO(nk+2k), which is polynomial in n for fixed k. However, as our empirical results suggest, choosing k = O(log(n)) works well, leading to quasi-polynomial complexity even for this exact algorithm. That observation notwithstanding, the following greedy algorithm (Algorithm 2), which, at each iteration, selects the single best node to add to the current set of feedback nodes, has polynomial complexity for arbitrarily large FVSs. As we will demonstrate, this greedy algorithm works extremely well in practice. Algorithm 2 Selecting an FVS by a greedy approach\nInitialization: F0 = \u2205 For t = 1 to k,\nk\u2217t = arg min k\u2208V \\Ft\u22121 d(Ft\u22121 \u222a {k}), Ft = Ft\u22121 \u222a {k\u2217t }"}, {"heading": "4.2 When the FVS Nodes Are Latent Variables", "text": "When the feedback nodes are latent variables, the marginal distribution of observed variables (the non-feedback nodes in the true model) has information matrix J\u0303T = \u03a3\u0302\u22121T = JT \u2212JMJ \u22121 F J T M . If the exact J\u0303T is known, the learning problem is equivalent to decomposing a given inverse covariance matrix J\u0303T into the sum of a tree-structured matrix JT and a rank-k matrix\u2212JMJ\u22121F JTM .3 In general, use the ML criterion\nqML(xF ,xT ) = arg min q(xF ,xT )\u2208QF\nDKL(p\u0302(xT )||q(xT )), (3)\nwhere the optimization is over all nodes (latent and observed) while the K-L divergence in the objective function is defined on the marginal distribution of the observed nodes only.\nWe propose the latent Chow-Liu algorithm, an alternating projection algorithm that is a variation of the EM algorithm and can be viewed as an instance of the majorization-minimization algorithm. The general form of the algorithm is as follows:\n1. Project onto the empirical distribution:\np\u0302(t)(xF ,xT ) = p\u0302(xT )q (t)(xF |xT ).\n2. Project onto the best fitting structure on all variables:\nq(t+1)(xF ,xT ) = arg min q(xF ,xT )\u2208QF DKL(p\u0302 (t)(xF ,xT )||q(xF ,xT )).\nIn the first projection, we obtain a distribution (on both observed and latent variables) whose marginal (on the observed variables) matches exactly the empirical distribution while maintaining the conditional distribution (of the latent variables given the observed ones). In the second projection we compute a distribution (on all variables) in the family considered that is the closest to the distribution obtained in the first projection. We found that among various EM type algorithms, this formulation is the most revealing for our problems because it clearly relates the second projection to the scenario where an FVS F is both observed and known (Section 4.1.1). Therefore, we are able to compute the second projection exactly even though the graph structure is unknown (which allows any tree structure among the observed nodes). Note that when the feedback nodes are latent, we do\n3It is easy to see that different models having the same JMJ\u22121F JM cannot be distinguished using the samples, and thus without loss of generality we can assume JF is normalized to be the identify matrix in the final solution.\nnot need to select the FVS since it is simply the set of latent nodes. This is the source of the simplification when we use latent nodes for the FVS: We have no search of sets of observed variables to include in the FVS. Algorithm 3 The latent Chow-Liu algorithm\nInput: the empirical covariance matrix \u03a3\u0302T Output: information matrix J = [ JF J T M\nJM JT\n] , where JT is tree-structured\n1. Initialization: J (0) =  J (0)F (J (0)M )T J\n(0) M J (0) T . 2. Repeat for t = 1, 2, 3, . . .:\n(a) P1: Project to the empirical distribution:\nJ\u0302 (t) =  J (t)F (J (t)M )T J\n(t) M ( \u03a3\u0302T )\u22121 + J (t) M (J (t) F ) \u22121(J (t) M ) T . Define \u03a3\u0302(t) = (J\u0302 (t))\u22121. (b) P2: Project to the best fitting structure:\n\u03a3(t+1) =  \u03a3\u0302(t)F ( \u03a3\u0302 (t) M )T \u03a3\u0302\n(t) M CL(\u03a3\u0302 (t) T |F ) + \u03a3\u0302 (t) M\n( \u03a3\u0302\n(t) F\n)\u22121 ( \u03a3\u0302\n(t) M\n)T  = CCL(\u03a3\u0302(t)),\nwhere \u03a3\u0302(t)T |F = \u03a3\u0302 (t) T \u2212 \u03a3\u0302 (t) M\n( \u03a3\u0302\n(t) F\n)\u22121 ( \u03a3\u0302\n(t) M\n)T . Define J (t+1) = ( \u03a3(t+1) )\u22121 .\nIn Algorithm 3 we summarize the latent Chow-Liu algorithm specialized for our family of GGMs, where both projections have exact closed-form solutions and exhibit complementary structure\u2014one using the covariance and the other using the information parametrization. In projection P1, three blocks of the information matrix remain the same; In projection P2, three blocks of the covariance matrix remain the same.\nThe two projections in Algorithm 3 can also be interpreted as alternating low-rank corrections : indeed,\nIn P1 J\u0302 (t) =\n[ 0 0\n0 (\n\u03a3\u0302T )\u22121 ]+ [ J (t)F J\n(t) M\n]( J\n(t) F )\u22121 [ J (t) F ( J (t) M )T ] ,\nand in P2 \u03a3(t+1) = [ 0 0\n0 CL(\u03a3\u0302T |F )\n] + [ \u03a3\u0302 (t) F\n\u03a3\u0302 (t) M\n]( \u03a3\u0302\n(t) F )\u22121 [ \u03a3\u0302 (t) F ( \u03a3\u0302 (t) M )T ] ,\nwhere the second terms of both expressions are of low-rank when the size of the latent FVS is small. This formulation is the most intuitive and simple, but a naive implementation of Algorithm 3 has complexity O(n3) per iteration, where the bottleneck is inverting full matrices J\u0302 (t) and \u03a3(t+1). By carefully incorporating the inference algorithms into the projection steps, we are able to further exploit the power of the models and reduce the per-iteration complexity toO(kn2+n2 log n), which is the same as the complexity of the conditioned Chow-Liu algorithm alone. We have the following proposition. Proposition 2. Using Algorithm 3, the objective function of (3) decreases with the number of iterations, i.e., DKL(N (0, \u03a3\u0302T )||N (0,\u03a3(t+1)T )) \u2264 N (0, \u03a3\u0302T )||N (0,\u03a3 (t) T )). Using an accelerated version of Algorithm 3, the complexity per iteration is O(kn2 + n2 log n).\nDue to the page limit, we defer the description of the accelerated version (the accelerated latent Chow-Liu algorithm) and the proof of Proposition 2 to Appendix C. In fact, we never need to explicitly invert the empirical covariance matrix \u03a3\u0302T in the accelerated version.\nAs a rule of thumb, we often use the spanning tree obtained by the standard Chow-Liu algorithm as an initial tree among the observed nodes. But note that P2 involves solving a combinatorial problem exactly, so the algorithm is able to jump among different graph structures which reduces the chance\nof getting stuck at a bad local minimum and gives us much more flexibility in initializing graph structures. In the experiments, we will demonstrate that Algorithm 3 is not sensitive to the initial graph structure."}, {"heading": "5 Experiments", "text": "In this section, we present experimental results for learning GGMs with small FVSs, observed or latent, using both synthetic data and real data of flight delays. Fractional Brownian Motion: Latent FVS We consider a fractional Brownian motion (fBM) with Hurst parameter H = 0.2 defined on the time interval (0, 1]. The covariance function is \u03a3(t1, t2) = 1 2 (|t1|\n2H + |t2|2H \u2212 |t1 \u2212 t2|2H). Figure 2 shows the covariance matrices of approximate models using spanning trees (learned by the Chow-Liu algorithm), latent trees (learned by the CLRG and NJ algorithms in [21]) and our latent FVS model (learned by Algorithm 3) using 64 time samples (nodes). We can see that in the spanning tree the correlation decays quickly (in fact exponentially) with distance, which models the fBM poorly. The latent trees that are learned exhibit blocky artifacts and have little or no improvement over the spanning tree measured in the K-L divergence. In Figure 3, we plot the K-L divergence (between the true model and the learned models using Algorithm 3) versus the size of the latent FVSs for models with 32, 64, 128, and 256 time samples respectively. For these models, we need about 1, 3, 5, and 7 feedback nodes respectively to reduce the K-L divergence to 25% of that achieved by the best spanning tree model. Hence, we speculate that empirically k = O(log n) is a proper choice of the size of the latent FVS. We also study the sensitivity of Algorithm 3 to the initial graph structure. In our experiments, for different initial structures, Algorithm 3 converges to the same graph structures (that give the K-L divergence as shown in Figure 3) within three iterations. Performance of the Greedy Algorithm: Observed FVS In this experiment, we examine the performance of the greedy algorithm (Algorithm 2) when the FVS nodes are observed. For each run, we construct a GGM that has 20 nodes and an FVS of size three as the true model. We first generate a random spanning tree among the non-feedback nodes. Then the corresponding information matrix J is also randomly generated: non-zero entries of J are drawn i.i.d. from the uniform distribution U [\u22121, 1] with a multiple of the identity matrix added to ensure J 0. From each generated GGM, we draw 1000 samples and use Algorithm 2 to learn the model. For 100 runs that we have performed, we recover the true graph structures successfully. Figure 4 shows the graphs (and the K-L divergence) obtained using the greedy algorithm for a typical run. We can see that we have the most divergence reduction (from 12.7651 to 1.3832) when the first feedback node is selected. When the size of the FVS increases to three (Figure 4e), the graph structure is recovered correctly.\nFlight Delay Model: Observed FVS In this experiment, we model the relationships among airports for flight delays. The raw dataset comes from RITA of the Bureau of Transportation Statistics. It contains flight information in the U.S. from 1987 to 2008 including information such as scheduled departure time, scheduled arrival time, departure delay, arrival delay, cancellation, and reasons for cancellation for all domestic flights in the U.S. We want to model how the flight delays at different airports are related to each other using GGMs. First, we compute the average departure delay for each day and each airport (of the top 200 busiest airports) using data from the year 2008. Note that the average departure delays does not directly indicate whether an airport is one of the major airports that has heavy traffic. It is interesting to see whether major airports (especially those notorious for delays) correspond to feedback nodes in the learned models. Figure 5a shows the best tree-structured graph obtained by the Chow-Liu algorithms (with input being the covariance matrix of the average delay). Figure 5b\u20135d show the GGMs learned using Algorithm 2. It is interesting that the first node selected is Nashville (BNA), which is not one of the top \u201chubs\u201d of the air system. The reason is that much of the statistical relationships related to those hubs are approximated well enough, when we consider a 1-FVS approximation, by a spanning tree (excluding BNA) and it is the breaking of the cycles involving BNA that provide the most reduction in K-L divergence over a spanning tree. Starting with the next node selected in our greedy algorithm, we begin to see hubs being chosen. In particular, the first ten airports selected in order are: BNA, Chicago, Atlanta, Oakland, Newark, Dallas, San Francisco, Seattle, Washington DC, Salt Lake City. Several major airports on the coasts (e.g., Los Angeles and JFK) are not selected, as their influence on delays at other domestic airports is well-captured with a tree structure."}, {"heading": "6 Future Directions", "text": "Our experimental results demonstrate the potential of these algorithms, and, as in the work [14], suggests that choosing FVSs of sizeO(log n) works well, leading to algorithms which can be scaled to large problems. Providing theoretical guarantees for this scaling (e.g., by specifying classes of models for which such a size FVS provides asymptotically accurate models) is thus a compelling open problem. In addition, incorporating complexity into the FVS-order problem (e.g., as in AIC or BIC) is another direction we are pursuing. Moreover, we are also working towards extending our results to the non-Gaussian settings."}, {"heading": "Acknowledgments", "text": "This research was supported in part by AFOSR under Grant FA9550-12-1-0287."}, {"heading": "Appendix of \u201cLearning Gaussian Graphical Models with Observed or Latent FVSs\u201d", "text": ""}, {"heading": "A Computing the Partition Function of GGMs in QF", "text": "In Section 3 of the paper, we have stated that given the information matrix J of a GGM with an FVS of size k, we can compute det J and hence the partition function using a message-passing algorithm with complexity O(k2n). This algorithm is inspired by the FMP algorithm developed in [14] and is described in Algorithm 4.\nAlgorithm 4 Computing the partition function when an FVS is given Input: an FVS F of size k and an n\u00d7n information matrix J = [ JF J T M\nJM JT\n] , where JT has tree\nstructure T with edge set ET . Output: det J\n1. Run standard Gaussian BP on T with information matrix JT to obtain P Tii = ( J\u22121T ) ii\nfor all i \u2208 T , P Tij = (J \u22121 T )ij for all (i, j) \u2208 ET , and (gp)i = (J \u22121 T h\np)i for all i \u2208 T and p \u2208 F , where hp is the column of JM corresponding to node p.\n2. Compute J\u0302F with ( J\u0302F ) pq = Jpq \u2212 \u2211\nj\u2208N (p)\u2229T\nJpjg q j , \u2200 p, q \u2208 F\n3. Compute det J\u0302F , the determinant of J\u0302F . 4. Output\ndet J =  \u220f (i,j)\u2208ET P Tii P T jj \u2212 ( P Tij )2 P Tii P T jj \u220f i\u2208V P Tii \u22121 det J\u0302F .\nWe state the correctness and the computational complexity of Algorithm 4 in Proposition 3.\nProposition 3. Algorithm 4 computes det J exactly and the computational complexity is O(k2n).\nBefore giving the proof for Proposition 3, we first prove Lemma 1.\nLemma 1. If the information matrix J 0 has tree structure T = (V, E), then we have\ndet (J) \u22121 = \u220f i\u2208V Pii \u220f (i,j)\u2208E PiiPjj \u2212 P 2ij PiiPjj , (4)\nwhere P = J\u22121.\nProof. WLOG, we assume the means are zero. For any tree-structured distribution p(x) with underlying tree T , we have the following factorization:\np(x) = \u220f i\u2208V p(xi) \u220f\n(i,j)\u2208ET\np(xi, xj)\np(xi)p(xj) . (5)\nFor a GGM of n nodes, the joint distribution, the singleton marginal distributions, and the pairwise marginal distributions can be expressed as follows.\np(x) = 1\n(2\u03c0) n 2 (det J)\n\u2212 12 exp{\u22121 2 xTJx}\np(xi) = 1\n(2\u03c0) 1 2Pii 1 2\nexp{\u22121 2 xTP\u22121ii x}\np(xi, xj) = 1\n2\u03c0 ( det [ Pii Pij Pji Pjj ]) 1 2\nexp{\u22121 2 xT [ Pii Pij Pji Pjj ]\u22121 x}.\nMatching the normalization factors using (5), we obtain\ndet (J) \u22121 = \u220f i\u2208V Pii \u220f (i,j)\u2208E det\n[ Pii Pij Pji Pjj ] PiiPjj . (6)\n= \u220f i\u2208V Pii \u220f (i,j)\u2208E PiiPjj \u2212 P 2ij PiiPjj\n(7)\nNow we proceed to prove Proposition 3.\nProof. First, we show that J\u0302F computed in Step 2 of Algorithm 4 equals JF \u2212JTMJ \u22121 T JM . We have[ g1 g2 \u00b7 \u00b7 \u00b7 gk ] = J\u22121T [ h1 h2 \u00b7 \u00b7 \u00b7 hk ] = J\u22121T JM\nfrom the definition in Step 1. From Step 3, we can get J\u0302F = JF \u2212 [ g1 g2 \u00b7 \u00b7 \u00b7 gk ]T JT [ g1 g2 \u00b7 \u00b7 \u00b7 gk ] = JF \u2212 ( J\u22121T JM )T JT ( J\u22121T JM\n) = JF \u2212 JTMJ\u22121T JM . (8)\nHence,\ndet J = det\n([ I \u2212JTMJ \u22121 T\n0 I\n]) det ([ JF J T M\nJM JT\n]) det ([ I 0\n\u2212J\u22121T JM I ]) = det ([ I \u2212JTMJ \u22121 T\n0 I\n] [ JF J T M\nJM JT\n] [ I 0\n\u2212J\u22121T JM I ]) = det [ JF \u2212 JTMJ \u22121 T JM 0\n0 JT ] = (\ndet J\u0302F ) \u00d7 (det JT ) , (9)\nFrom Lemma 1 to follow, we have\ndet (JT ) \u22121 = \u220f i\u2208V P Tii \u220f\n(i,j)\u2208ET\nP Tii P T jj \u2212 ( P Tij )2\nP Tii P T jj\n. (10)\nHence, we have proved the correctness of the algorithm. Now we calculate the complexity. The first step of Algorithm 4 has complexity O(n \u2212 k) using BP. Step 2 takes O ( k2(n\u2212 k) ) and the\ncomplexity of Step 3 is O(k3). Finally the complexity of Step 4 is O(n) since T is a tree. The total complexity is thus O(k2n). This completes the proof for Proposition3.\nNote that if the FVS is not given, we can use the factor-2 approximate algorithm in [19] to obtain an FVS of size at most twice the minimum size with complexity O(min{m log n, n2}), where m is the number of edges."}, {"heading": "B Proof for Proposition 1", "text": "B.1 Preliminaries\nProposition 1 states that Algorithm 1 computes the ML estimate with covariance \u03a3ML (together with EML, the set of edges among the non-feedback nodes) exactly with complexity O(kn2 + n2 log n), and that JML \u2206 = \u03a3\u22121ML can be computed with additional complexity O(k2n).\nFirst, we define the following information quantities:\n1. The entropy Hpx(x) = \u2212 \u00b4 x px(x) log px(x)dx\n2. The conditional entropy Hpx,y(x|y) = \u2212 \u00b4 x,y px,y(x,y) log px|y(x|y)dxdy 3. The mutual information Ipx,y(x;y) = \u00b4 x,y px,y(x,y) log p(x)p(y) p(x,y) dxdy\n4. The conditional mutual information\nIpx,y,z(x;y|z) = \u02c6 x,y,z px,y,z(x,y, z) log p(x,y|z) p(x|z)p(y|z) dxdy\n5. The conditional K-L divergence: D(p\u0302x|y||qx|y|p\u0302y) \u2206 = D(p\u0302x,y||qx|yp\u0302y).\nThe (conditional) K-L divergence is always nonnegative. It is zero if and only if the two distributions are the same (almost everywhere). When there is no confusion, the subscripts in the distributions are often omitted, e.g., Ipx,y(x;y) written as Ip(x;y). With a slight abuse of notation, l we use p(xF ) to denote the marginal distribution of xF under the joint distribution p(x), and similarly p(xT |xF ) to denote the conditional distribution of xT given xF under the joint distribution p(x).\nThe standard Chow-Liu Algorithm for GGMs is summarized in 5. The complexity is O(n2 log n). Note that in Step 3, for a fixed i, for any (i, j) /\u2208 ET , \u03a3ij can be computed following a topological order of with i being the root. Hence, by book-keeping the computed products along the paths, the complexity of computing each \u03a3ij is O(1).\nAlgorithm 5 the Chow-Liu Algorithm for GGMs Input: the empirical covariance matrix \u03a3\u0302 Output: \u03a3CL and ECL\n1. Compute the correlation coefficients \u03c1ij = \u03a3\u0302ij\u221a \u03a3\u0302ii\u03a3\u0302jj\n2. Find an MST (maximum weight spanning tree) of the complete graph with weights |\u03c1ij | for edge (i, j). The edge set of the tree is denoted as ET .\n3. For all i \u2208 V, (\u03a3CL)ii = \u03a3\u0302ii; for (i, j) \u2208 ET , (\u03a3CL)ij = \u03a3\u0302ij ; for (i, j) /\u2208 ET , (\u03a3CL)ij = \u221a \u03a3ii\u03a3jj \u220f (l,k)\u2208Path(i,j) \u03c1lk, where Path(i, j) is the set of edges on the unique\npath between i and j in the spanning tree.\nB.2 Lemmas\nLemma 2 is a well-known result stated without proof. Lemma 2. The p.d.f. of a tree-structured model T = (V, E) can be factorized according to either of the following two equations:\n1. p(x) = p(xr) \u220f i\u2208V\\r p(xi|x\u03c0(i)), where r is an arbitrary node selected as the root and\n\u03c0(i) is the unique parent of node i in the tree rooted at r.\n2. p(x) = \u220f i\u2208V p(xi) \u220f (i,j)\u2208E p(xi,xj) p(xi)p(xj) .\nFor a given F and a fixed tree T with edge set ET among the non-feedback nodes, Lemma 3 gives a closed form solution that minimizes the K-L divergence.\nLemma 3.\nmin q\u2208QF,T DKL(p\u0302||q) = \u2212Hp\u0302(x) +Hp\u0302(xF ) + \u2211 i\u2208V\\F Hp\u0302(xi|xF )\u2212 \u2211 (i,j)\u2208ET Ip\u0302(xi;xj |xF ), (11)\nwhere QF,T is the set of distributions defined on a graph with a given FVS F and a given spanning tree T among the non-feedback nodes. The minimum K-L divergence is obtained if and only if: 1) q(xF ) = p\u0302(xF ); 2) q(xF , xi, xj) = p\u0302(xF , xi, xj) for any (i, j) \u2208 ET .\nProof. With fixed F and T ,\nDKL(p\u0302||q) = \u02c6 p\u0302(x) log p\u0302(x)\nq(x) dx\n= \u2212Hp\u0302(x)\u2212 \u02c6 p\u0302(x) log q(x)dx = \u2212Hp\u0302(x)\u2212 \u02c6 p\u0302(x) log (q(xF )q(xT |xF )) dx\n(a) = \u2212Hp\u0302(x)\u2212 \u02c6 p\u0302(x) log q(xF )q(xr|xF ) \u220f i\u2208V\\F\\r q(xi|xF ,x\u03c0(i))  dx = \u2212Hp\u0302(x)\u2212 \u02c6 p\u0302(xF ) log q(xF )dxF \u2212 \u02c6 p\u0302(xF ,xr) log q(xr|xF )dxFdxr\n\u2212 \u2211\ni\u2208V\\F\\r\n\u02c6 p\u0302(xF ,x\u03c0(i),xi) log q(xi|xF ,x\u03c0(i))dxFdx\u03c0(i)dxi\n(b) = \u2212Hp\u0302(x) +Hp\u0302(xF ) +D(p\u0302F ||qF ) +Hp\u0302(xr|xF ) +D(p\u0302r|F ||qr|F |p\u0302F ) + \u2211\ni\u2208V \\F\\r\nHp\u0302(xi|xF,\u03c0(i)) +D(p\u0302i|F,r||qi|F,r|p\u0302F,r)\n(c) \u2265 \u2212Hp\u0302(x) +Hp\u0302(xF ) +Hp\u0302(xr|xF ) + \u2211\ni\u2208V \\F\\r\nHp\u0302(xi|xF,\u03c0(i)), (12)\nwhere (a) is obtained by using Factorization 1 in Lemma 2 with an arbitrary root node r; (b) can be directly verified using the definition of the information quantities, and the equality in (c) is satisfied when qF = p\u0302F , qr|F = p\u0302r|F , and qi|F,\u03c0(i) = p\u0302i|F,\u03c0(i),\u2200i \u2208 T\\r, or equivalently when\nqF = p\u0302F\nqF,i,j = p\u0302F,i,j ,\u2200(i, j) \u2208 ET . (13)\nNext, we derive another expression of (12). By substituting (13) into Factorization s of Lemma 2, we have\nq\u2217(x) = p\u0302(xF ) \u220f i\u2208T p\u0302(xi|xF ) \u220f\n(i,j)\u2208ET\np\u0302(xi,xj |xF ) p\u0302(xi|xF )p\u0302(xj |xF ) .\nHence,\nmin q\u2208QF,T\nD(p\u0302||q) = D(p\u0302||q\u2217)\n\u2212Hp\u0302(x) +Hp\u0302(xF ) + \u2211 i\u2208V \\F Hp\u0302(xi|xF ) (14)\n+ \u2211\n(i,j)\u2208ET\n\u02c6 p\u0302F,i,j(xF ,xi,xj) log\np\u0302(xi,xj |xF ) p\u0302(xi|xF )p\u0302(xj |xF ) dxFdxidxj (15)\n= Hp\u0302(x) +Hp\u0302(xF ) + \u2211 i\u2208V \\F Hp\u0302(xi|xF ) (16)\n\u2212 \u2211\n(i,j)\u2208ET\n\u02c6 p\u0302F,i,j(xF ,xi,xj) log\np\u0302(xi|xF )p\u0302(xj |xF ) p\u0302(xi,xj |xF ) dxFdxidxj (17)\n= \u2212Hp\u0302(x) +H(p\u0302F ) + \u2211 i\u2208V\\F H(p\u0302i|F |xF )\u2212 \u2211 (i,j)\u2208ET Ip\u0302(xi;xj |xF ). (18)\nWe have thus proved Lemma 3.\nThe following Lemma 4 gives a closed-form expression for the K-L divergence between two Gaussians. It can be verified by calculus and the proof is omitted.\nLemma 4. For two n-dimensional Gaussian distributions p\u0302(x) = N (x; \u00b5\u0302, \u03a3\u0302) and q(x) = N (x;\u00b5,\u03a3), we have\nD(p\u0302||q) = 1 2\n( Tr ( \u03a3\u22121\u03a3\u0302 ) +(\u00b5\u2212 \u00b5\u0302) T \u03a3\u22121 (\u00b5\u2212 \u00b5\u0302)\u2212 n ln det ( \u03a3\u22121\u03a3\u0302 )) . (19)\nAn immediate implication of Lemma 4 is that when learning GGMs we always have that \u00b5ML = \u00b5\u0302 if there is no constraint on the mean in.\nLemma 5. If a symmetric positive definite matrix \u03a3 is given and we know that its inverse J = \u03a3\u22121 is sparse with respect to a tree T = (V, E), then the non-zero entries of J can be computed using (20) in time O(n).\nJij =  (1\u2212 deg(i)) \u03a3\u22121ii + \u2211 j\u2208N (i) ( \u03a3ii \u2212 \u03a3ij\u03a3\u22121jj \u03a3ji )\u22121 i = j \u2208 V \u03a3ij \u03a32ij\u2212\u03a3ii\u03a3jj\n(i, j) \u2208 E 0 otherwise,\n(20)\nwhere N (i) is the set of neighbors of node i in T ; deg(i) is the degree of i in T .\nProof. Since \u03a3 0, we can construct a Gaussian distribution p(x) with zero mean and covariance matrix \u03a3. The distribution is tree-structured because J = \u03a3\u22121 has tree structure T . Hence, we have the following factorization.\np(x) = \u220f i\u2208V p(xi) \u220f (i,j)\u2208E p(xi, xj) p(xi)p(xj) ,\nwhere\np(x) = 1\n(2\u03c0) n 2 (det J)\n\u2212 12 exp{\u22121 2 xTJx}\np(xi) = 1\n(2\u03c0) 1 2Pii 1 2\nexp{\u22121 2 xT\u03a3\u22121ii x}\np(xi, xj) = 1\n2\u03c0 ( det [ \u03a3ii \u03a3ij \u03a3ji \u03a3jj ]) 1 2\nexp{\u22121 2 xT [ \u03a3ii \u03a3ij \u03a3ji \u03a3jj ]\u22121 x}.\nBy matching the quadratic coefficient in the exponents, we have that\nJii = \u03a3 \u22121 ii + \u2211 j\u2208N (i) (([ \u03a3ii \u03a3ji \u03a3ij \u03a3jj ]\u22121) 11 \u2212 \u03a3\u22121ii )\n= (1\u2212 deg(i)) \u03a3\u22121ii + \u2211\nj\u2208N (i)\n( \u03a3ii \u2212 \u03a3ij\u03a3\u22121jj \u03a3ji )\u22121 and for (i, j) \u2208 E ,\nJij = ([ \u03a3ii \u03a3ij \u03a3ji \u03a3jj ]\u22121) 12\n= \u03a3ij\n\u03a32ij \u2212 \u03a3ii\u03a3jj\nThe complexity of computing each Jij , (i, j) \u2208 E is O(1) and the complexity of computing each Jii is O(deg i). Since \u03a3i\u2208V deg(i) equals twice the number of edges, which is O(n), the total complexity is O(n).\nLemma 6. (The matrix inversion lemmas) If [ A B C D ] is invertible, we have[\nA B C D\n]\u22121 = [ (A\u2212BD\u22121C)\u22121 \u2212(A\u2212BD\u22121C)\u22121BD\u22121 \u2212D\u22121C(A\u2212BD\u22121C)\u22121 D\u22121 +D\u22121C(A\u2212BD\u22121C)\u22121BD\u22121 ] (21)\nor[ A B C D ]\u22121 = [ A\u22121 +A\u22121B(D \u2212 CA\u22121B)\u22121CA\u22121 \u2212A\u22121B(D \u2212 CA\u22121B)\u22121 \u2212(D \u2212 CA\u22121B)\u22121CA\u22121 (D \u2212 CA\u22121B)\u22121 ] (22)\nand ( A\u2212BD\u22121C )\u22121 = A\u22121 +A\u22121B(D \u2212 CA\u22121B)\u22121CA\u22121. (23)\nThe proof of Lemma 6 can be found in standard matrix analysis books.\nB.3 Proof of Proposition 1\nProof. For a fixed FVS F , the LHS of (11) is only a function of the spanning tree among the nonfeedback nodes. Hence, the optimal set of edges among the non-feedback nodes can be obtained by finding the maximum spanning tree of the subgraph induced by T with Ip\u0302(xi;xj |xF ) \u2265 0 being the edge weight between i and j. 4\n4In fact, we have given an algorithm to learn general models (not only GGMs, but also other models, e.g., discrete ones) defined on graphs with a given FVS F . However, we do not explore the general setting in this paper.\nFor Gaussian distributions, the covariance matrix of the distribution p\u0302(xT |xF ) depends only on the set F but is invariant to the value of xF . Hence, finding the optimal edge set of the tree part is equivalent to running the Chow-Liu algorithm with the input being the covariance matrix of p\u0302T |F (xT |xF ), which is simply \u03a3\u0302T |F = \u03a3\u0302T \u2212 \u03a3\u0302M \u03a3\u0302\u22121F \u03a3\u0302TM . Let ECL = CLE(\u03a3\u0302T |F ) and \u03a3CL = CL(\u03a3\u0302T |F ). Denote\nthe optimal covariance matrix as \u03a3ML = [ \u03a3MLF ( \u03a3MLM )T \u03a3MLM \u03a3 ML T ] . According to (13), we must have \u03a3MLF = \u03a3\u0302F and \u03a3 ML M = \u03a3\u0302M . From (13) the corresponding conditional covariance matrix \u03a3 ML T |F of\n\u03a3ML must equal \u03a3CL. Hence, we have \u03a3MLT |F = \u03a3 ML T \u2212 \u03a3MLM ( \u03a3MLF )\u22121 ( \u03a3MLM )T = \u03a3CL. Therefore, we can obtain \u03a3MLT = CL(\u03a3\u0302T |F ) + \u03a3\u0302M \u03a3\u0302 \u22121 F \u03a3\u0302 T M . We also have that EML = ECL since EML is defined to be the set of edges among the feedback nodes.\nNow we analyze the complexity of Algorithm 1. The matrix \u03a3\u0302T |F is computed with complexity O(kn2). Computing the maximum weight spanning tree algorithm has complexity O(n2 log n) using Kruskal\u2019s algorithm (the amortized complexity can be further reduced, but it is not the focus of this paper). Other operations have complexity O(n2). Hence, the total complexity of Algorithm 1 is O(kn2 + n2 log n).\nNext we proceed to prove that we can compute all the non-zero entries of JML = (\u03a3ML) \u22121 in time O(k2n).\nLet JML = [ JMLF ( JMLM )T JMLM J ML T ] . We have that JMLT = ( CL(\u03a3\u0302T |F ) )\u22121 has tree structure with T . Therefore, the non-zero entries of JMLT can be computed with complexity O(n\u2212 k).from Lemma 5. From (22) we have\nJMLM = \u2212JMLT \u03a3MLM ( \u03a3MLF )\u22121 , (24)\nwhich can be computed with complexityO(k2n) by matrix multiplication in the regular order. Note that JMLT \u03a3 ML M is computed in O(kn) since JMLT only has O(n) non-zero entries.\nFrom (22) we have\nJMLF = ( \u03a3MLF )\u22121 ( I + (( \u03a3MLM )T JMLT ) ( \u03a3MLM ( \u03a3MLF ))) ,\nwhich has complexity O(k2n) following the order specified by the parentheses. Note that( PMLM )T JMLT is computed in O(kn) because JMLT only has O(n) non-zero entries. Hence, we need extra complexity of O(k2n) to compute all the non-zero entries of JML. We have therefore completed the proof for Proposition 1.\nFor easy reference, we summarize the procedure to compute JML in Algorithm 6.\nAlgorithm 6 Compute JML = (\u03a3ML) \u22121 after running Algorithm 1\n1. Compute JMLT using (20) 2. Compute JMLM = \u2212JMLT \u03a3MLM \u03a3 \u22121 F using sparse matrix multiplication\n3. Compute ( \u03a3MLF )\u22121 ( I + (( \u03a3MLM )T JMLT ) ( \u03a3MLM ( \u03a3MLF ))) following the order specified by\nthe parentheses using sparse matrix multiplication."}, {"heading": "C Proof of Proposition 2", "text": "In this section, we first prove a more general result stated in Lemma 7.\nLemma 7. In Algorithm 7, if Step 2(a) and Step 2(b) can be computed exactly, then we have that D(p\u0302(xT )||q(t+1)(xT )) \u2264 D(p\u0302(xT )||q(t)(xT )), where the equality is satisfied if and only if p\u0302(t)(xF ,xT ) = p\u0302 (t+1)(xF ,xT ).\nAlgorithm 7 Alternating Projection\n1. Propose an initial distribution q(0)(xF ,xT ) \u2208 QF 2. Alternating projections:\n(a) P1: Project to the empirical distribution:\np\u0302(t)(xF ,xT ) = p\u0302(xT )q (t)(xF |xT )\n(b) P2: Project to the best fitting structure on all variables:\nq(t+1)(xF ,xT ) = arg min q(xF ,xT )\u2208QF D(p\u0302(t)(xF ,xT )||q(xF ,xT ))\n.\nProof. For any t,\nD(p\u0302(t)(xT ,xF )||q(t)(xF ,xT ))\n= \u02c6 xT ,xF p\u0302(xT )q (t)(xF |xT ) log p\u0302(xT )q (t)(xF |xT ) q(t)(xF ,xT )\n= \u02c6 xT ,xF p\u0302(xT )q (t)(xF |xT ) log p\u0302(xT ) q(t)(xT )\n= \u02c6 xT p\u0302(xT ) log p\u0302(xT ) q(t)(xT )\n=D(p\u0302(t)(xT )||q(t)(xT )) (25)\nBy the definition of q(t+1) in step (b), we have\nD(p\u0302(xT ,xF )||q(t+1)(xF ,xT )) \u2264 D(p\u0302(t)(xT ,xF )||q(t)(xF ,xT )). (26)\nTherefore,\nD(p\u0302(xT )||q(t)(xT )) (a) =D(p\u0302(t)(xT ,xF )||q(t)(xF ,xT )) (27) (b) \u2265D(p\u0302(t)(xT ,xF )||q(t+1)(xF ,xT )) (28)\n= \u02c6 xT ,xF p\u0302(xT )q (t)(xF |xT ) log p\u0302(xT )q (t)(xF |xT ) q(t+1)(xF ,xT )\n= \u02c6 xT ,xF p\u0302(xT )q (t)(xF |xT ) log p\u0302(xT ) q(t+1)(xT ) + \u02c6 xT ,xF p\u0302(xT )q (t)(xF |xT ) log q(t)(xF |xT ) q(t+1)(xF |xT )\n= \u02c6 xT p\u0302(xT ) log p\u0302(xT ) q(t+1)(xT ) + \u02c6 xT ,xF p\u0302(xT )q (t)(xF |xT ) log q(t)(xF |xT )p\u0302(xT ) q(t+1)(xF |xT )p\u0302(xT )\n(29)\n=D(p\u0302(xT )||q(t+1)(xT )) + \u02c6 xT ,xF p\u0302(t)(xF ,xT ) log p\u0302(t)(xF ,xT ) p\u0302(t+1)(xF ,xT )\n=D(p\u0302(xT )||q(t+1)(xT )) +D(p\u0302(t)(xF ,xT )||p\u0302(t+1)(xF ,xT )) (c) \u2265D(p\u0302(xT )||q(t+1)(xT )), (30)\nwhere (a) is due to (25), (b) is due to (26), and (c) is due to thatD(p\u0302(t)(xF ,xT )||p\u0302(t+1)(xF ,xT )) \u2265 0. Therefore, we always have D(p\u0302(xT )||q(t)) \u2265 D(p\u0302(xT )||q(t+1)). A necessary condition for the objective function to remain the same is that D(p\u0302(t)(xF ,xT )||p\u0302(t+1)(xF ,xT )) = 0, which implies that p\u0302(t)(xF ,xT ) = p\u0302(t+1)(xF ,xF ). Hence, it further implies that q(t)(xF ,xT ) = q(t+1)(xF ,xT ) under non-degenerate cases. Therefore, p\u0302(t)(xF ,xT ) = p\u0302(t+1)(xF ,xF ) is a necessary and sufficient condition for the objective function to remain the same. This completes the proof for Lemma 7.\nNow we proceed to the proof for Proposition 2.\nProof. Use the same notation as in the latent Chow-Liu algorithm (Algorithm 3). Let p\u0302(xT ) = N (0, \u03a3\u0302T ), p(t)(xF ,xT ) = N (0,\u03a3(t)). Then\np\u0302(xT ) = 1\u221a det (\n2\u03c0\u03a3\u0302T ) exp{\u221212xTT \u03a3\u0302\u22121T xT } p(t)(xF |xT ) =\n1\u221a det ( 2\u03c0 ( J (t)\nF\n)\u22121) exp{\u221212 ( xF \u2212 ( J (t) F )\u22121 J (t) M xT )T J (t) F ( xF \u2212 ( J (t) F )\u22121 J (t) M xT )T }\nHence, following Algorithm 7, we have\np\u0302(t)(xF ,xT ) = p\u0302(xT )q (t)(xF |xT )\n\u221d exp{\u22121 2 [ xF xT ]T  J (t)F (J (t)M )T J\n(t) M \u03a3\u0302 \u22121 T + J (t) M (J (t) F ) \u22121(J (t) M ) T\n[ xF xT ] },\nwhich gives the same expression as in P1 of Algorithm 3. The next projection\nq(t+1)(xF ,xT ) = min q(xF ,xT )\u2208QF D(p\u0302(t)(xF ,xT )||q(xF ,xT ))\nhas same form as M-L learning problem in Section 4.1.1, and therefore can be computed exactly using the conditioned Chow-Liu algorithm (Algorithm 1). By Lemma 7, we have thus proved the first part of Proposition 2. The second part about the complexity of an accelerated version is proved in Section D."}, {"heading": "D The Accelerated Latent Chow-Liu Algorithm", "text": "In this section, we describe the accelerated latent Chow-Liu algorithm (Algorithm 8), which gives exactly the same result as the latent Chow-Liu algorithm 3, but has a lower complexity of O(kn2 + n2 log n) per iteration. The main complexity reduction is due to the use of Algorithm 6.\nWe will use the following lemma in the proof of Algorithm 8.\nNow we proceed to prove the correctness of the accelerated Chow-Liu algorithm and obtain its complexity.\nProof. In P1 of the latent Chow-Liu algorithm (Algorithm 3) we have\nJ\u0302 (t) =  J (t)F (J (t)M )T J\n(t) M ( \u03a3\u0302T )\u22121 + J (t) M (J (t) F ) \u22121(J (t) M ) T  . Without explicitly computing J\u0302 (t), we can directly compute \u03a3\u0302(t) = ( J\u0302 (t) )\u22121 as follows.\nLet A = J (t)F , B = (J (t) M ) T , C = J\u0302 (t)M , and D = ( \u03a3\u0302T )\u22121 + J (t) M (J (t) F ) \u22121(J (t) M )\nT ). From (22) we have\n\u03a3\u0302 (t) F =\n( J\n(t) F\n)\u22121 + ( J\n(t) F\n)\u22121 ( J\n(t) M )T (D \u2212 CA\u22121B)\u22121J\u0302 (t)M ( J (t) F )\u22121 and\n\u03a3\u0302 (t) T = (D \u2212 CA \u22121B)\u22121 = \u03a3\u0302T . (31)\n\u03a3\u0302 (t) F =\n( J\n(t) F\n)\u22121 + ( J\n(t) F\n)\u22121 ( J\n(t) M )T \u03a3\u0302T J\u0302 (t) M ( J (t) F )\u22121 . (32)\nAlso from (22), we have that\n\u03a3\u0302 (t) M = \u2212\u03a3\u0302TJ (t) M\n( J\n(t) F\n)\u22121 . (33)\nIt can be checked that the matrix multiplications of (31), (32), and (33) have complexity O(kn2). P2 in Algorithm 3 can be computed with complexityO(n2k+n2 log n) from Proposition 1. Therefore, the complexity of this accelerated version (summarized in Algorithm 8) is O(n2k + n2 log n) per iteration. We have thus completed the proof for Proposition 2.\nAlgorithm 8 The accelerated Chow-Liu algorithm Input: the empirical covariance matrix \u03a3\u0302T Output: information matrix J = [ JF J T M\nJM JT\n] .\n1. Initialization: J (0) =  J (0)F (J (0)M )T J\n(0) M J (0) T . 2. Repeat\n(a) AP1: Compute\n\u03a3\u0302 (t) F =\n( J\n(t) F\n)\u22121 + ( Y (t) )T \u03a3\u0302TY (t)\n\u03a3\u0302 (t) T = \u03a3\u0302T\n\u03a3\u0302 (t) M = \u2212\u03a3\u0302TY (t),\nwhere Y (t) = J\u0302 (t)M ( J (t) F )\u22121 Let \u03a3\u0302(t) =\n \u03a3\u0302(t)F (\u03a3\u0302(t)M )T \u03a3\u0302\n(t) M \u03a3\u0302T . (b) AP2: Compute \u03a3(t+1) and J (t+1)= ( \u03a3(t+1) )\u22121 from \u03a3\u0302(t) using Algorithm 1 and Al-\ngorithm 6:\nJ (t+1) =  J (t+1)F (J (t+1)M )T J\n(t+1) M J (t+1) T  \u03a3(t+1) =\n \u03a3(t+1)F (\u03a3(t+1)M )T \u03a3\n(t+1) M \u03a3 (t+1) T\n"}], "references": [], "referenceMentions": [], "year": 2013, "abstractText": "Gaussian Graphical Models (GGMs) or Gauss Markov random fields are widely<lb>used in many applications, and the trade-off between the modeling capacity and<lb>the efficiency of learning and inference has been an important research prob-<lb>lem. In this paper, we study the family of GGMs with small feedback vertex<lb>sets (FVSs), where an FVS is a set of nodes whose removal breaks all the cycles.<lb>Exact inference such as computing the marginal distributions and the partition<lb>function has complexity O(kn) using message-passing algorithms, where k is<lb>the size of the FVS, and n is the total number of nodes. We propose efficient<lb>structure learning algorithms for two cases: 1) All nodes are observed, which is<lb>useful in modeling social or flight networks where the FVS nodes often corre-<lb>spond to a small number of highly influential nodes, or hubs, while the rest of<lb>the networks is modeled by a tree. Regardless of the maximum degree, without<lb>knowing the full graph structure, we can exactly compute the maximum likelihood<lb>estimate with complexity O(kn + n log n) if the FVS is known or in polyno-<lb>mial time if the FVS is unknown but has bounded size. 2) The FVS nodes are<lb>latent variables, where structure learning is equivalent to decomposing an inverse<lb>covariance matrix (exactly or approximately) into the sum of a tree-structured ma-<lb>trix and a low-rank matrix. By incorporating efficient inference into the learning<lb>steps, we can obtain a learning algorithm using alternating low-rank corrections<lb>with complexity O(kn + n log n) per iteration. We perform experiments using<lb>both synthetic data as well as real data of flight delays to demonstrate the modeling<lb>capacity with FVSs of various sizes.", "creator": "LaTeX with hyperref package"}}}