{"id": "1401.3469", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Exploiting Single-Cycle Symmetries in Continuous Constraint Problems", "abstract": "Symmetries in discrete constraint satisfaction problems have been explored and exploited in the last years, but symmetries in continuous constraint problems have not received the same attention. Here we focus on permutations of the variables consisting of one single cycle. We propose a procedure that takes advantage of these symmetries by interacting with a continuous constraint solver without interfering with it. A key concept in this procedure are the classes of symmetric boxes formed by bisecting a n-dimensional cube at the same point in all dimensions at the same time. We analyze these classes and quantify them as a function of the cube dimensionality. Moreover, we propose a simple algorithm to generate the representatives of all these classes for any number of variables at very high rates. A problem example from the chemical and#64257;eld and the cyclic n-roots problem are used to show the performance of the approach in practice.", "histories": [["v1", "Wed, 15 Jan 2014 05:27:27 GMT  (388kb)", "http://arxiv.org/abs/1401.3469v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["vicente ruiz de angulo", "carme torras"], "accepted": false, "id": "1401.3469"}, "pdf": {"name": "1401.3469.pdf", "metadata": {"source": "CRF", "title": "Exploiting Single-Cycle Symmetries in Continuous Constraint Problems", "authors": ["Vicente Ruiz de Angulo", "Carme Torras"], "emails": ["ruiz@iri.upc.edu", "torras@iri.upc.edu"], "sections": [{"heading": "1. Introduction", "text": "Symmetry exploitation in discrete constraint satisfaction problems (CSPs) has received a great deal of attention lately. Since CSPs are usually solved using AI search algorithms, the approaches dealing with symmetries fall into two groups: those that entail reformulating the problem or adding constraints before search (Flener, Frisch, Hnich, Kiziltan, & Miguel, 2002; Puget, 2005), and those that break symmetries along the search (Meseguer & Torras, 2001; Gent, 2002). Permutations of variables, and interchangeability of values are commonly addressed symmetries for which a repertoire of techniques have been developed, most of them relying on computational group theory.\nOn the contrary, symmetries have been largely disregarded in continuous constraint solving, despite the important growth in both theory and applications that this field has recently experienced (Sam-haroud & Faltings, 1996; Benhamou & Goualard, 2000; Jermann & Trombettoni, 2003; Porta, Ros, Thomas, & Torras, 2005). Continuous (or numerical) constraint solving is often tackled using Branch-and-Prune (B&P) algorithms (Hentenryck, Mcallester, & Kapur, 1997; Vu, Silaghi, Sam-Haroud, & Faltings, 2005), which iteratively locate solutions inside an initial domain box, by alternating box subdivision (branching) and box reduction (pruning) steps.\nMotivated by a molecular conformation problem, in this paper we deal with the most simple type of box symmetry, namely that in which some domain variables (i.e., box dimensions) undergo a single-cycle permutation leaving the constraints invariant. To be clear, if the cycle involves n variables, our algorithm handles the n \u2212 1 symmetries (excluding the\nc\u00a92009 AI Access Foundation. All rights reserved.\nidentity) generated by this cycle by composition. Since the computational gain will be shown to be roughly proportional to n, the longest cycle appearing in the problem formulation should be chosen as input to our algorithm.\nThis single-cycle permutation that leaves the constraints unchanged is a form of constraint symmetry in the terminology introduced by Cohen, Jeavons, Jefferson, Petrie, and Smith (2006). Note that any constraint symmetry is also a solution symmetry, but not the other way around. Thus, the symmetries we deal with are a subset of all possible solution symmetries; the advantage is that they can be assessed (although perhaps are difficult to find) from the problem formulation, therefore being operative.\nOur approach to exploit symmetries in continuous constraint problems requires the initial domain for the symmetric variables to be an n-cube, as it starts by subdividing this cube at the same point along all dimensions at once. Since box symmetry is a transitive relation, the subboxes resulting from the subdivision fall into equivalence classes. Then, a B&P algorithm (or any similar continuous constraint solver) is called on only the subboxes that are representatives of each symmetry equivalence class. Finally, for each solution found, all its symmetric ones are generated. Note that symmetry handling doesn\u2019t interfere with the inside workings of the constraint solver."}, {"heading": "2. Symmetry in Continuous Constraint Problems", "text": "We are interested in solving the following general continuous Constraint Satisfaction Problem (continuous CSP): Find all points x = (x1, . . . , xn) lying in an initial box of Rn satisfying the constraints f1(x) \u2208 C1 , . . . , fm(x) \u2208 Cm, where fi is a function fi : Rn \u2192 R, and Ci is an interval in R.\nThe only particular feature that we require of a Continuous Constraint Solver (CCS) is that it has to work with an axis-aligned box in Rn as input. Also, we assume that the CCS returns solution boxes. Note that a CCS returning solution points is a limit case still contained in our framework.\nWe say that a function s : Rn \u2192 Rn is a point symmetry of the problem if there exists an associated permutation \u03c3 \u2208 \u03a3m such that fi(x) = f\u03c3(i)(s(x)) and Ci = C\u03c3(i), \u2200i = 1, . . . ,m. We consider symmetry as a property that relates points that are equivalent as regards to a continuous CSP. Concretely, from the above definition one can conclude that\n\u2022 x is a solution to the problem iff s(x) is a solution to the problem.\nLet s and t be two symmetries of a continuous CSP with associated permutations \u03c3s and \u03c3t. It is easy to see that the composition of symmetries s(t(\u00b7)) is also a symmetry with associated permutation \u03c3s(\u03c3t(\u00b7)).\nAn interesting type of symmetries are permutations (bijective functions of a set onto itself) of the components of x. Let D be a finite set. A cycle of length k is a permutation \u03c8 such that there exist distinct elements a1, . . . ak \u2208 D such that \u03c8(ai) = \u03c8(a(i+1)mod k) and \u03c8(z) = z for any other element z \u2208 D. Such a cycle is represented as (a1, . . . ak). Every permutation can be expressed as a composition of disjoint cycles (i.e, cycles without common elements), which is unique up to the order of the factors. Composition of cycles is represented as concatenation, as for example (a1, . . . ak)(b1, . . . bl). In this paper we focus on a particular type of permutations, namely those constituted by a single cycle. In its\nsimplest form1, this is s(x1, x2, . . . xn) = (x\u03b8(1), x\u03b8(2), . . . x\u03b8(n)) = (x2, x3...xn, x1), where \u03b8(i) = (i+ 1) mod n.\nExample: n = 3,m = 4,x = (x1, x2, x3) \u2208 [\u22121, 1]\u00d7 [\u22121, 1]\u00d7 [\u22121, 1],\nf1(x) : x21 + x 2 2 + x 2 3 \u2208 [5, 5] \u2261 x21 + x22 + x23 = 5 f2(x) : 2x1 \u2212 x2 \u2208 [0,\u221e] \u2261 2x1 \u2212 x2 > 0 f3(x) : 2x2 \u2212 x3 \u2208 [0,\u221e] \u2261 2x2 \u2212 x3 > 0 f4(x) : 2x3 \u2212 x1 \u2208 [0,\u221e] \u2261 2x3 \u2212 x1 > 0\nThere exists a symmetry s(x1, x2, x3) = (x2, x3, x1), for which there is no need of reordering the variables. The constraint permutation associated to s is \u03c3(1) = 1, \u03c3(2) = 3, \u03c3(3) = 4, and \u03c3(4) = 2.\nGenerally there is not a unique symmetry for a given problem. If there exists a symmetry s, then for example s2(x) = s(s(x)) is another symmetry. In general, using the convention of denoting s0(x) the identity mapping, {si(x), i = 0 . . . n\u22121} is the set of different symmetries that can be obtained composing s(x) with itself, while for i > n we have that si(x) = si mod n(x). Thus, a single-cycle symmetry generates by composition n \u2212 1 symmetries, excluding the trivial identity mapping. Some of them may have different numbers of cycles. Imagine for example that in a continuous CSP with n = 4 the permutation of variables (1 2 3 4) is a symmetry. Then, the permutation obtained by composing it twice, (1 3)(2 4), is also a symmetry of the problem, but has a different number of cycles, and the longest cycle has length two instead of four. Besides, the former permutation cannot be generated from the latter. The algorithm presented in this paper deals with all the compositions of a single-cycle symmetry, even if some of them are not single-cycle symmetries. The gain obtained with the proposed algorithm will be shown to be roughly proportional to the number of different compositions of the selected symmetry. Therefore, when several single-cycle symmetries exist in a continuous CSP problem, the algorithm should be used with that generating the most symmetries by composition, i.e., with that having the longest cycle. Note that the single-cycle permutations we are dealing with need not encompass all the problem variables, since the the remaining ones will be considered fixed (unitary cycles)."}, {"heading": "3. Box Symmetry", "text": "Since continuous constraint solvers work with boxes, we turn our attention now to the set of points symmetric to those belonging to a box B \u2286 Rn. 2\nLet s be a single-cycle symmetry corresponding to the circular variable shifting \u03b8 introduced in the preceding section, and B = [x1, x1]\u00d7. . .\u00d7[xn, xn] a box in Rn. The box symme-\n1. In general, the variables must be arranged in a suitable order before one can apply the circular shifting. Thus, the general form of a single-cycle symmetry is s(x) = h\u22121(g(h(x))), where h(x1, . . . xn) = (x\u03c6(1), . . . , x\u03c6(n)), \u03c6 \u2208 \u03a3n is a general permutation that orders the variables, and g(x1, . . . , xn) = (x\u03b8(1), . . . x\u03b8(n)) is the circular shifting above. Thus, the cycle \u03c8 defining the symmetry can be expressed as \u03c8 = \u03c6\u22121(\u03b8(\u03c6(\u00b7))). Since the reordering does not change substantially the presented concepts and algorithms, we have simplified notation in the paper by assuming that the order of the component variables is the appropriate one, i.e., that \u03c8 = \u03b8 . 2. This set {s(x) s.t. x \u2208 B} is also a box if s(x) = (s1(x), . . . , sn(x)) = (g1(x\u03c6(1)), . . . , gn(x\u03c6(n))), where si is the i-th component of s, \u03c6 is an arbitrary permutation, and gi : R\u2192 R is any function such that if I is an interval of R then {gi(x) s.t. x \u2208 I} is also an interval of R.\ntry function S is defined as S(B) = {s(x) s.t. x \u2208 B} = [x\u03b8(1), x\u03b8(1)]\u00d7 . . .\u00d7 [x\u03b8(n), x\u03b8(n)] = [x2, x2] \u00d7 . . . \u00d7 [xn, xn] \u00d7 [x1, x1]. The box symmetry function has also an associated constraint permutation \u03c3, which is the same associated to s. Si will denote S composed i times. We say, then, that B1 and B2 are symmetric boxes if there exists i s.t. Si(B1) = B2.\nBox symmetry is an equivalence relation defining symmetry equivalence classes. Let R(B) be the set of different boxes in the symmetry class of B, R(B) = {Si(B), i \u2208 {0, . . . , n\u2212 1}}. For instance, for box B\u2032 = [0, 4]\u00d7 [2, 5]\u00d7 [2, 5]\u00d7 [0, 4]\u00d7 [2, 5]\u00d7 [2, 5], R(B\u2032) is composed of S0(B\u2032) = B\u2032, S1(B\u2032) = [2, 5]\u00d7[2, 5]\u00d7[0, 4]\u00d7[2, 5]\u00d7[2, 5]\u00d7[0, 4] and S2(B\u2032) = [2, 5]\u00d7[0, 4]\u00d7 [2, 5]\u00d7[2, 5]\u00d7[0, 4]\u00d7[2, 5]. Note that S3(B\u2032) is again B\u2032 itself and that subsequent applications of box symmetry would repeat the same sequence of boxes. We define the period P (B) of a box B as P (B) = |R(B)|. It is easily shown that R(B) = {Si(B), i \u2208 {0, . . . , P (B) \u2212 1}}. For example, for box B\u2032, R(B\u2032) = {S0(B\u2032), S1(B\u2032), S2(B\u2032)} and P (B\u2032) = 3.\nBox symmetry has implications for the continuous CSP, which are a direct consequence of the point symmetry case:\n\u2022 If there is no solution inside a box B, there is no solution inside any of its symmetric boxes either.\n\u2022 A box B\u222b \u2286 B is a solution iff Si(B\u222b ) \u2286 Si(B) is a solution box for all i \u2208 {1 . . . P (B)\u2212 1}.\nSketch of proof for the first statement: Assume there is no solution inside B and there is some solution xsol inside Si(B). By definition of box symmetry there exists a point x\u2032sol \u2208 B such that xsol = si(x\u2032sol). Using the property highlighted in Section 2 we deduce that x \u2032 sol must be also a solution, which contradicts the hypothesis. Sketch of proof for the second statement: A solution box is a box with at least a solution point inside. Assume B\u222b \u2286 B is a solution box containing the solution point xsol. Inside Si(B\u222b ) there is the point si(xsol) that, by the property highlighted in Section 2, must be also a solution. Conversely, assume now that Si(B\u222b ) \u2286 B is a solution box. Thus it contains at least a solution point, xsol. By definition of symmetric box, this point has a symmetric point x\u2032sol \u2208 B\u222b such that xsol = si(x\u2032sol). Using the property in Section 2 again we conclude that x\u2032sol must be also a solution and, thus, B\u222b is a solution box.\nBoth statements can be rephrased as follows :\n\u2022 If the set of solution boxes contained in a box B is SolSet, the set of solution boxes contained in its symmetric box Si(B) is {Si(B\u222b ) s.t. B\u222b \u2208 SolSet}\nThis means that once the solutions inside B have been found, the solutions inside its symmetric boxes Si(B), i \u2208 {1 . . . P (B)\u2212 1} are available without hard calculations. In the following sections we will show how to exploit this property to save much computing time in a meta-algorithm that uses a CCS as a tool without interfering with it.\n3.1 Box Symmetry Classes Obtained by Bisecting a n-cube\nThe algorithm we will propose to exploit box symmetry makes use of the symmetry classes formed by bisecting a n-dimensional cube In (i.e., of period 1) in all dimensions at the same time and at the same point, resulting in 2n boxes. We will denote L and H the two subintervals into which the original range I is divided. For example, for n = 2, we\nhave the following set of boxes {L \u00d7 L,L \u00d7 H,H \u00d7 L,H \u00d7 H} whose periods are 1, 2, 2 and 1, respectively. And their symmetry classes are: {L \u00d7 L}, {L \u00d7 H,H \u00d7 L}, and {H \u00d7H}. Representing the two intervals L and H as 0 and 1, respectively, and dropping the \u00d7 symbol, the sub-boxes can be coded as binary numbers. Let SRn be the set of representatives, formed by choosing the smallest box in binary order from each class. For example, SR2 = {00, 01, 11}. Note that the cube In to be partitioned can be thought of as the the set of binary numbers of length n, and that SRn is nothing more than a subset whose elements are different under circular shift.\nThe algorithm for exploiting symmetries and the way it uses SRn are explained in the next section. Afterwards, in Sections 6 and 7, we study how many components SRn has, how they are distributed and, more importantly, how can they be generated."}, {"heading": "4. Algorithm to Exploit Box Symmetry", "text": "Algorithm 1: CSym1 algorithm. Input: A n-cube, [xl, xh]\u00d7 \u00b7 \u00b7 \u00b7 \u00d7 [xl, xh].\nA single-cycle box symmetry, S. A Continuous Constraint Solver, CCS.\nOutput: A set of boxes covering all solutions.\nSolutionBoxSet\u2190 EmptySet1 x\u2217 \u2190 SelectBisectionPoint(xl, xh)2 foreach b \u2208 SRn do3 B \u2190 GenerateSubBox(b, xl, xh, x\u2217)4 SolutionBoxSet\u2190 SolutionBoxSet \u222aProcessRepresentative(B)5\nreturn SolutionBoxSet6\nThe symmetry exploitation algorithm we propose uses the CCS as an external routine. The internals of the CCS must not be modified or known.\nThe idea is to first divide the initial box into a number of symmetry classes. Next, one needs to process only a representative of each class with the CCS. At the end, by applying box symmetries to the solution boxes obtained in this way, one would get all the solutions lying in the space covered by the whole classes, i.e., the initial box. The advantage of this procedure is that the CCS would have to process only a fraction of the initial box. Assuming that the initial box is a n-cube covering the same interval [xl, xh] in all dimensions, we can directly apply the classes associated to SRn. A procedure to exploit single-cycle symmetries in this way is presented in Algorithm 1.\nSince SRn is a set of codes \u2014not real boxes\u2014 we need a translation of the codes into boxes for the given initial box. The operator GenerateSubBox(b, xl, xh, x\u2217) returns the box V = V1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Vn corresponding to code b = b1 . . . bn when [xl, xh] is the range of the initial box in all dimensions and x\u2217 is the point in which this interval is bisected:\nVi = { [xl, x\u2217] if bi = 0, [x\u2217, xh] if bi = 1.\n(1)\nThe point x\u2217 calculated by SelectBisectionPoint(xl, xh) can be any such that xl < x\u2217 < xh, but a reasonable one is (xl + xh)/2. The iterations over line 4 generate a set of representative boxes such that, together with their symmetries, cover the initial n-cube.\nProcessRepresentative(B) returns all the solution boxes associated to B, that is, the solutions inside R(B), or still in other words, the solutions inside B and inside its symmetric boxes. ProcessRepresentative(B) is based on the property stated at the end of Section 3, which allows to obtain all the solutions in the class of B by processing only B with the CCS. SolSet is the set of solutions found inside the representative box of the class, B. ApplySymmetry(SolSet, Si) calculates the set of solutions of box Si(B) by applying Si to each of the boxes in SolSet. Since the number of symmetries of B is P (B), the benefits of exploiting the symmetries of a class representative is proportional to its period.\nAlgorithm 2: The ProcessRepresentative function. Input: A box, B.\nA single-cycle box symmetry, S. A Continuous Constraint Solver, CCS.\nOutput: The set of solution boxes contained in B and its symmetric boxes. SolSet\u2190 CCS(B)1 TotalSolSet\u2190 SolSet2 for i=1: P (B)\u2212 1 do3 TotalSolSet\u2190 TotalSolSet \u222aApplySymmetry(SolSet, Si)4 return TotalSolSet5\nThe correctness of the algorithm is easy to check. The set of boxes in which it searches explicitly or implicitly (by means of symmetry) for solutions is U = {R(B) s.t. B is a representative}. In fact, U is the set of boxes formed by bisecting the initial box in all dimensions at the same time and at the same point. U covers the whole initial box and, thus, the algorithm finds all the solutions of the problem. Moreover, it finds each solution box only once, because the boxes in U do not have any volume in common (they share at most a \u201cwall\u201d)."}, {"heading": "4.1 Discussion on the Efficiency of CSYM1", "text": "The CSym1 algorithm launches the CCS algorithm on |SRn| small boxes instead of on only the original large one. Three factors affect its efficiency as compared to that of the standard approach:\n1. Fraction of domain processed. Only a fraction of the original domain is directly dealt with by the CCS. This fraction is a function of the periods of the SRn components. One element of period p represents a class formed by p boxes, only one of which is processed with the CCS. Since all the boxes of the classes are of equal size, the above fraction can be calculated by dividing the number of representatives by the total number of boxes in the classes, |SRn|2n = |SRn|P B\u2208SRn P (B) . The expected time gain\nis the inverse of this quantity, P B\u2208SRn P (B) |SRn| denoted by IFDP (Inverse of the Fraction of Domain Processed). When n grows (see Section 6), the majority of the elements\nof SRn have period n, and thus IFDP tends to n. However, for low n, IFDP can be significantly smaller than n. This is the main factor determining the efficiency of CSym1.\n2. Smaller processed boxes. Since the CCS initial boxes using CSym1 are 2n times smaller than the original initial box, the average size of the boxes processed by the CCS is also smaller than in the standard case. Prune (box reduction or contraction) step is carried out more quickly on smaller boxes in Branch-and-Prune algorithms. In fact, best Branch-and-Prune algorithms have box contraction operators exhibiting second-order convergence, but this contraction rate requires small enough boxes to hold in practice.\n3. Number of representatives. There is a disadvantage in fractioning excessively the initial domain. We can see this by noting that, using the original large initial box, if a contraction operator lowers the upper bound of a symmetric variable, this information could be used to lower the upper bound of the same variable in many representative boxes in SRn. As commented above, this contraction operator would act more strongly on the representatives themselves, but the \u201closs of parallelization\u201d effect is anyway present. This factor is irrelevant for small-length cycle symmetries, say up to n = 6, because |SRn| is very small (see Section 6 again) as compared to the number of boxes that a CCS must process in general. However, when n approaches 20, the number of representatives begins to become overwhelming."}, {"heading": "5. Two Illustrative Examples", "text": "The two problems below have been solved with the Branch-and-Prune CCS presented by Porta, Ros, Thomas, Corcho, Canto, and Perez (2008). It is a polytope-based method similar to that of Sherbrooke E. C. (1993) with global consistency, which exhibits quadratic convergence. The machine used to carry out all the experiments in the paper is a 2.5 Ghz G5 Apple computer."}, {"heading": "5.1 Cycloheptane", "text": "Molecules can be modeled as mechanical chains by making some reasonable approximations. If two atoms are joined by a chemical bond, one can assume that there is a rigid link between them. Thus, the first approximation is that bond lengths are constant. The second one is that the angles between two consecutive bonds are also constant. In other words, the distances between the atoms in any subchain of three atoms are assumed to be constant. All configurations of the atoms of the molecule that satisfy these distance constraints, sometimes denoted rigid-geometry hypothesis, are valid conformations of the molecule in a kinematic sense. The constraints induced by the rigid-geometry hypothesis are particularly strong when the molecule topology forms loops, as in cycloalkanes. The problem of finding all valid conformations of a molecule can be formulated as a distance-geometry (Blumenthal, 1953) problem in which some distances between points (atoms) are fixed and known, and one must find the set of values of unknown (variable) distances that are compatible with the embedding of the points in R3. The unknown distances can be found by solving a set\nof constraints consisting of equalities or inequalities of determinants formed with subsets of the fixed and variable distances (Blumenthal, 1953).\nFigure 1 displays the known and unknown distances of the cycloheptane, a molecule basically composed of a ring of seven carbon atoms. The distance between two consecutive atoms of the ring is constant and equal everywhere. The distance between two atoms connected to\na same atom is also known and constant no matter the atoms. The problem in underconstrained, having an infinite number of solutions of dimensionality 1. The problem has several symmetries. We use one of them, s(d1, . . . , d7) = (d\u03b8(1), d\u03b8(2), . . . , d\u03b8(7)) = (d2, d3 . . . , d7, d1). The length of the only cycle of this symmetry is n = 7, for which IFDP is 6.4.\nThe number of boxes processed using the raw CCS without symmetry handling is 1269, while using CSym1 the total number is 196, giving a ratio of 6.47 \u2248 IFDP. The problem is solved in 4.64 minutes using CSym1, which compares very favorably with the 31.6 minutes spent when using the algorithm of Porta et al. (2008) alone, a reduction by a factor of 6.81, slightly greater than IFDP. This means that, although the number of representatives begins to be relevant (|SR7| = 20), factor 2 in Section 4.1 is more determining than factor 3 in the same section, since the (small) time overhead introduced by handling box symmetries is also included in the reported time. Figure 2 shows a projection into d1, d2 and d3 of the solutions obtained using CSym1. The solutions were found inside five representative boxes of period seven, containing 16, 1, 4, 64 and 1 solution boxes, respectively, at the chosen level of resolution. The total number of solutions boxes is therefore 7(16+1+4+64+1)= 602.\n5.2 Cyclic n-roots Problem\nThe following polynomial equation system is the n = 5 instance of the so-called cyclic n-roots problem as described by Bjo\u0308rck and Fro\u0308berg (1991).\nx1 + x2 + x3 + x4 + x5 = 0 x1x2 + x2x3 + x3x4 + x4x5 + x5x1 = 0\nx1x2x3 + x2x3x4 + x3x4x5 + x4x5x1 + x5x1x2 = 0 x1x2x3x4 + x2x3x4x5 + x3x4x5x1 + x4x5x1x2 + x5x1x2x3 = 0\nx1x2x3x4x5 \u2212 1 = 0\n(2)\nThere are ten real solutions to this problem. The system has a single-cycle symmetry: s(x1, . . . , x5) = (x2, x3, x4, x5, x1), as well as a multiple-cycle symmetry not considered in this paper. Thus, the cycle length is n = 5, |SR5| = 8, and the IFDP is 4. When running the CCS alone using as initial box [\u221210, 10]5, the number of processed boxes is 399, while exploiting the aforementioned symmetry with the CSym1 algorithm this number reduces to 66. In the last case, two solutions were found in a representative box of period 5, which through symmetry led to the ten solutions. Running times are 16.86 seconds (CCS alone) and 2.08 seconds (CSym1) giving a gain of more than eight. This is the double of the IFDP, which highlights the benefits that factor 2 in Section 4.1 can bring to the efficacy of the approach. The number of representatives is very small compared to the number of boxes processed by the CCS alone, making factor 3 in Section 4.1 irrelevant in this case.\nTable 1 contains the results for n=4 to n=8 of the cyclic n-roots problem in the [\u221210, 10]n domain, except for n=8 for which the domain was [\u22125, 5]8. For n=4 and n=8 there is a continuum of solutions which, with the chosen resolution, produces 992 and 2435 solution boxes, respectively. Because of this, the number of processed boxes for n=5 is smaller than for n=4, but logically smaller also than for n=6 to n=8. Two observations can be\nmade. First, the time gains are always higher than the corresponding IFDP\u2019s, implying a preponderance of factor 2 in Section 4.1 over factor 3. Second, the time gain follows rather accurately the rate between the number of processed boxes using the CCS alone and using CSym1.\nTests on the cyclic n-roots problem using a classical CCSP solver, RealPaver (Granvilliers & Benhamou, 2006), have been carried out (Jermann, 2008). The results are preliminary and difficult to expose concisely, since there is a great variability depending on issues such as the pruning method used (RealPaver offers several options) and how the problem is coded (factorized or not). In every case, however, we have observed time gains greater than expected by the IFDP.\n6. Analysis of SRn: Counting the Number of Classes\nLet us define some quantities of interest: -Nn: Number of elements of SRn. -FPn: Number of elements of SRn that correspond to full-period boxes, i.e., boxes of period n. -Nnm: Number of elements of SRn having m 1\u2019s. -FPnm: Number of elements of SRn that correspond to full-period boxes having m 1\u2019s.\nPolya\u2019s theorem (Polya & Read, 1987) could be used to determine some of these quantities for a given n by building a possibly huge polynomial and elucidating some of its coefficients. We present a simpler way of calculating them and, at the same time, make the reader familiar with the concepts that will be used in our algorithm to generate SRn.\nWe begin by looking for the expression of FPn. When any number of 1\u2019s is allowed, the total number of binary numbers is 2n. The only periods that can exist in these binary numbers are divisors of n. Thus, the following equation holds:\n\u2211 p\u2208div(n) p FPp = 2n. (3)\nSegregating p = n,\nn FPn + \u2211\np\u2208div(n), p<n\np FPp = 2n, (4)\nand solving for FPn:\nFPn = 2n\nn \u2212 \u2211 p\u2208div(n), p<n p n FPp. (5)\nThis recurrence has a simple baseline condition: FP1 = 2. Then, Nn follows easily from\nNn = \u2211\np\u2208div(n)\nFPp. (6)\nSegregating p = n, a more efficient formula is obtained:\nNn = 2n\nn + \u2211 p\u2208div(n), p<n n\u2212 p n FPp. (7)\nThis formula is valid for n > 1. The remaining case is N1 = 2. We will use similar techniques to obtain FPnm and Nnm. There are ( n m ) binary numbers having m 1\u2019s and n \u2212 m 0\u2019s. Some of these binary numbers are circular shifts of others (like 011010 and 110100). The number of shifted versions of a binary number is the period of the box being represented by the binary number. For example, 1010, of period 2, has only another shifted version, 0101. A binary number representing a box of period p can be seen as a concatenation of n/p numbers of length nn/p = p and period p. This means that these \u201cconcatenated\u201d numbers are full-period, and they have mn/p 1\u2019s. Thus, the number of binary numbers of period p when shifted numbers are counted as the same (i.e., the number of classes of period p) is FP n\nn/p m n/p . Only common divisors of n and m, which we denote div(n,m), can be periods. Since there are p shifted versions of each binary number having period p, we can write\n\u2211 p\u2208div(n,m) p FP n n/p m n/p = ( n m ) . (8)\nWith a change of variable f = n/p we get\n\u2211 f\u2208div(n,m) n f FP n f m f = ( n m ) . (9)\nNote that the index of the summation goes through the same values as before. We can segregate the case f = 1 from the summand,\nn FPnm + \u2211\nf\u2208div(n,m), f>1\nn f FP n f m f\n= ( n\nm\n) , (10)\nand, finally, we obtain\nFPnm = ( n m ) n \u2212 \u2211 f\u2208div(n,m), f>1 FP n f m f f . (11)\nThis is a recurrence relation from which FPnm can be computed using the following baseline conditions:\nFPnn,FPn0 = { 0 if n > 1 1 if n = 1\n(12)\nNnm is obtained adding up the number of classes of each period:\nNnm = \u2211\nf\u2208div(n,m)\nFP n f m f . (13)\nSegregating again f = 1, a more efficient formula is obtained:\nNnm = ( n\nm\n) + \u2211 f\u2208div(n,m), f>1 (1\u2212 n f )FP n f m f , (14)\nthen carrying out the change of variable p = n/f :\nNnm = ( n\nm\n) + \u2211 p\u2208div(n,m), p<n (1\u2212 p)FPpmp n , (15)\nNote the change in the summation range. This equation is valid whenever m > 0 and m < n. Otherwise, Nnm = 1.\nIt is possible to extend the concept of FPn (and FPnm) to reflect the number of members of SRn having period p (and m 1\u2019s), which we denote N pn (N pnm):\nN pn = { 0 if p /\u2208 div(n) FPp otherwise\n(16)\nN pnm = { 0 if p /\u2208 div(n,m) FPp,mp\nn otherwise\n(17)\nFigure 3(a) displays the number of classes (Nn) as a function of n. The curve indicates an exponential-like behavior. This is confirmed in Figure 3(b) using a larger logarithmic scale, in which the curve appears almost perfectly linear. Figure 4 is an example of the distribution of classes by period for n = 12. Figure 5 shows the percentage of full-period classes in SRn (100N nn /Nn). One can see that the percentage of classes with period different from n is significant for low n, but approaches quickly 0 as n grows. Finally, Figures 6(a) and 6(b) display the distribution of the classes in SRn by number of 1\u2019s for n = 12 and n = 100, respectively. The majority of the classes concentrates in an interval in the middle of the graphic, around n/2. This interval becomes relatively smaller when n grows.\n7. Generating SRn, the Classes of Symmetric Boxes\nThe naive procedure to obtain SRn would initially generate all boxes originated by bisecting a n-dimensional cube at the same point in all dimensions at the same time. Then, one should check each of the boxes in this set to detect whether it is a circular shift of some of the others. The complete process of generating SRn in this way involves a huge number of operations even for rather small dimensions. Although the SRn for a few n\u2019s could be precomputed and stored in a database, we suggest here an algorithm capable of calculating SRn on the fly without significant computational overhead.\nAs made for counting, we distinguish different subsets of SRn on the basis of the number of 1\u2019s and the period:\n-SRnm: Subset of the elements of SRn having m 1\u2019s. -SRpnm: Subset of the elements of SRn having m 1\u2019s and period p. \u2013SRpn: Subset of the elements of SRn having period p. From a global point of view, the generation of SRn is carried out as follows. First, SRn0 is generated, which is constituted always by a unique member. Afterwards, all SRnm\nfor m = 1 . . . n are generated. The generation of SRnm is divided in each of the SRpnm, p \u2208 div(n,m), that compose it. The algorithm ClassGen described below generates all full-period representatives for any given number of variables n > 1 and number of ones m > 0, i.e., it generates SRnnm. The representatives of a lower period p \u2208 div(n,m) are obtained by concatenating one same block n/p = f times. Therefore, in order to obtain SRpnm, we generate SR\np pm f with our same algorithm, and then concatenate their elements\nf times. Thus, without loss of generality, in what follows we describe the workings of the algorithm ClassGen when it computes codes of full period, namely n.\nWe use a compact coding of the binary numbers representing the boxes consisting in ordered lists or chains of numbers. The first number of the code is the number of 0\u2019s appearing before the first 1 in the binary number. The i-th number of the code for i > 1 is the number of 0\u2019s between the (i\u22121)-th and the i-th 1\u2019s of the binary number. For example, the number 0100010111 is codified as 13100. The length of this numerical codification is the number of 1\u2019s of the codified binary number, which has been denoted by m.\nThere are binary numbers that cannot be codified in this way, because their last digit is 0. But, except for the all zero\u2019s case, there is always an element of its class that can be codified correctly (for example 0011 is an element of the class of 0110). As our objective is to have only a representative of each class, this is rather an advantage, because half of the boxes are already eliminated from the very beginning. The all zero\u2019s box, SRn0, is common to every n, and will be generated separately, as already mentioned.\nThe codification allows to determine if a box is full-period in the same way as in the binary representation: the box has period n iff after a number of circular shifts lower than the length of the numerical chain the result is never equal to the original. For instance, the example above is full-period, but 22, corresponding to 001001, is not. The only difference is that, in the new representation, at most m shifts must be compared.\nThe code of a box can be seen as a number of base n\u2212m. In a full-period box, the m circular shifts of the code are different numbers, and can be arranged in strictly increasing numerical order. We will take as representative box of a class the largest element of the class when expressed as a code (which is the smallest when expressed as a binary number). For example, the class of 130 has two other elements that can be represented by our coding, 013 and 301, the latter being the chosen representative of the class.\nNote that a box belonging to SRnm has n \u2212 m 0\u2019s or, equivalently, the sum of the components of the code is n\u2212m.\nThe output of the algorithm are all codes of length m, whose sum of components is n \u2212m, and which are both representatives of a class and full-period. Codes of length m whose components sum up a desired number are rather easy to generate systematically. The representativeness and full-period conditions are more difficult to guarantee efficiently. We can handle them by exploiting the properties of our codes stated below, which make use of the definition of i-compability.\nWe say that a code is i-compatible or compatible for position i if a sub-chain of it beginning at position i > 1 and ending at the last position m (thus of length m \u2212 i + 1) is strictly smaller in numerical terms than the sub-chain of the same length beginning at the first position. For example, 423423 is compatible for positions 2 and 3, but it is not 4-compatible.\nProperty 1 A code is a class representative and it is full-period iff it is i-compatible for all i s.t. 1 < i 6 m.\nThus, instead of comparing chains of length m (i.e., the code and its shifted versions), we can determine the code validity comparing shorter sub-chains. A second property helps us to devise a still faster and simpler algorithm:\nProperty 2 If a code is i-compatible and the sub-chain from position i to i+ l is equal to the sub-chain from position 1 to 1 + l then the code is also compatible for positions i + 1 through i+ l.\nAlgorithm 3: CodeValidity algorithm. Input: A code of length m expressed as an array, A. Output: A boolean value indicating whether the code is valid, i.e., whether it is\nfull-period and a class representative.\ni\u2190 21 ctrol\u2190 12 V alidCode\u2190 True3 while V alidCode & i < m do4 if A[i] > A[ctrol] then V alidCode\u2190 False5 else if A[i] < A[ctrol] then ctrol\u2190 16 else ctrol\u2190 ctrol + 1; /* A[i] = A[ctrol] */7 i\u2190 i+ 18\nif A[m] \u2265 A[ctrol] then V alidCode\u2190 False9 return ValidCode10\nThis property is interesting because it permits checking the validity of the code by travelling along it at most once, as shown in Algorithm 3. The trick is that when the decision of i-compatibility is being delayed because position i and the following numbers are the same as those at the beginning of the string, if it finally resolves positively, the compatibility for the intermediate numbers is also guaranteed. Hence, i-compatibility is either resolved with a simple comparison or it requires l comparisons. In the latter case, either the compatibility of l positions is also resolved (if the outcome is positive) or compatibility of intermediate positions doesn\u2019t matter (because the outcome is negative and, thus, the code can be labelled non valid without further checks). A ctrol variable is in charge of maintaining the last index of the \u201chead\u201d sub-chain that is being compared in the current compatibility check. When examining the compatibility of the current position i, if its value is lower than that of the ctrol position, the code is for sure i-compatible and therefore we must only worry about (i + 1)-compatibility by back-warding ctrol to the first position. If the value of the ctrol position is equal to that of the current position i, the compatibility of position i is still to be ascertained, and we continue advancing the current and the ctrol positions until the equality disappears. In other words, the only condition that must be fulfilled for non rejecting as invalid a code at position i is that\nAlgorithm 4: ClassGen algorithm. Input: The sum of the numbers that remain to be written on the right (from\nposition pos to m), sum. The index of the next position to be written, pos. The index of the current control element, whose value cannot be surpassed in\nthe next position, ctrol. The length of the code, m. Array where class codes are being generated, A.\nOutput: A set of codes representing classes, SR. SR\u2190 EmptySet1 if pos = m then2 if sum < A[ctrol] then /* otherwise, SR will remain EmptySet */3 A[m]\u2190 sum4 SR\u2190 {A};5\nelse6 if pos = 1 then7 LowerLimit = dsum/me8 UpperLimit\u2190 sum9\nelse10 LowerLimit = 011 UpperLimit\u2190Minimum(A[ctrol], sum)12\nfor i = UpperLimit to LowerLimit do13 A[pos]\u2190 i14 if i = A[ctrol] and pos 6= 1 then /* i = A[ctrol] = UpperLimit */15\nSR\u2190 SR \u22c3\nClassGen(sum\u2212 i, pos+ 1, ctrol + 1,m,A)16 else /* i < A[ctrol] or pos = 1 */17\nSR\u2190 SR \u22c3\nClassGen(sum\u2212 i, pos+ 1, 1,m,A)18 19\nreturn SR20\nA[i] 6 A[ctrol], (18)\na condition that is transformed into A[i] < A[ctrol] when i = m to resolve the last of the pending compatibility checks. As an aside, note that our codes are more general than the raw binary numbers, and that representativeness and full-periodness are defined in the same way for both. Therefore, the three properties and the CodeValidity algorithm apply also to the raw binary numbers.\nA rather direct way to generate SRnnm would be to generate all the codes of length m whose sum of components is n \u2212m (the number of zero\u2019s when expressed as a binary number) and then filter each of them with CodeValidity. Instead, we have taken a more\nefficient approach, generating only the codes that satisfy the conditions that need to be checked explicitly in CodeValidity. Therefore, Algorithm 3 (presented only for clarity purposes) is not used.\nOur main procedure to obtain all full-period representatives having m 1\u2019s, i.e., SRnnm, is the recursive program presented in Algorithm 4. ClassGen(n\u2212m, 1, 1,m,A), where A is an array of length m, must be called to obtain SRnnm, for any given n > 1, m > 0. Each call to the procedure writes a single component of the code at the position of A indicated by the parameter pos, beginning with pos = 1, which is subsequently incremented at each recursive call. The recursion finishes at the rightmost end of the code, when pos = m. The first parameter, sum, is the sum of the components of the code that remain to be written.\nThe range of values written at each position pos is limited by LowerLimit and UpperLimit, except for the last position m. In the following we show the correctness of the algorithm by verifying that these limits are chosen to satisfy the two requirements of the code:\n\u2022 The sum of the numbers of any code completed by the algorithm must be n\u2212m. First, recall that the initial call to the algorithm is done using a parameter sum = n \u2212m. In any position 1 \u2264 pos < m the number to be written must be greater than or equal to the sum of the numbers still to be written, quantity represented by sum, so that in subsequent positions it will be possible to write positive integers, or at least zeros. This condition is imposed to UpperLimit in line 9 for pos = 1 and in line 12 (juxtaposed to code validity conditions) for 1 < pos < m. The number written at pos is substracted from the sum parameter in the next recursive call. Finally, for pos = m, the only possibility to satisfy the sum condition is to assign the value of sum to the last element of the code.\n\u2022 The code validity conditions, just as in CodeValidity, are that the number to be written in position pos must be smaller than or equal to A[ctrol] for 1 < pos < m, and strictly lower than A[ctrol] for pos = m. These conditions are reflected in the UpperLimit assignments made in lines 12 and 3, respectively. LowerLimit is usually (pos < 1, line 4) set to the smallest possible element of the codes, 0. But at the beginning of the code (pos = 1, line 8) a more tight value can be chosen since, for a value lower than the upper rounded value dsum/me, there is no way to distribute what remains of sum among the other positions of the code without putting a value greater than the initial one, which would make any such code non-representative.\nThe maintenance of the ctrol variable is similar to that within the CodeValidity algorithm: if we write in pos something strictly minor than A[ctrol], ctrol is back-warded to the first position. Otherwise, ctrol is incremented by 1 for the next recursive call to write pos+ 1.\nThe output of the algorithm is a list of valid codes in decreasing numerical order. For instance, the output obtained when requesting SR993 with ClassGen(6, 1, 1, 3, A) is: {600, 510, 501, 420, 411, 402, 330, 321, 312}. In this example, the only case in which the recursion arrives to pos = m without returning a valid code is the frustrated code 222, whose last number is not written because the code is not full-period.\nFigure 7 displays quantitative results that reflect the efficiency of ClassGen. The dashed line accounts for the complete times required to generate all the class representatives\nSRn for n = 2 to n = 30. It is worth noting that only SR30 requires more than a second to be entirely generated. The continuous line encodes the division of |SRn| by the time required to generate SRn, measured in millions of class representatives generated by second. It is evident that the efficiency of ClassGen is very high and that it even grows slightly with n. This behavior shows that the dead-ends in the recursion are statistically insignificant, which proves the tightness of the bounds used to enforce the values of the code numbers."}, {"heading": "8. Conclusions", "text": "We have approached the problem of exploiting symmetries in continuous constraint satisfaction problems using continuous constraint solvers. Our approach is general and can make use of any box-oriented CCS as a black-box procedure. The particular symmetries we have tackled are single-cycle permutations of the problem variables.\nThe suggested strategy is to bisect the domain, the n-cube initial box, simultaneously in all dimensions at the same point. This forms a set of boxes that can be grouped in box symmetry classes. A representative of each class is selected to be processed by the CCS and all the symmetries of the representative are applied to the resulting solutions.\nIn this way, the solutions within the whole initial domain are found, while having processed only a fraction of it \u2014the set of representatives\u2014 with the CCS. The time savings obtained by processing a representative and applying its symmetries to the solutions tend to be proportional to the number of symmetric boxes of the representative. Therefore, symmetry exploitation is complete for full-period representatives, since they have the maximum number of symmetric boxes. Another factor that improves the efficiency above what could\nbe expected by these considerations is the smaller average size of the boxes processed by the CCS with our approach.\nWe have also studied the automatic generation of the classes resulting from bisecting a n-cube and analyzed their numerical properties. The algorithm for generating the classes is very powerful, eliminating the convenience of any pre-calculated table. The numerical analysis of the classes revealed that the average number of symmetries of the class representatives tends quickly to n as the number of variables, n, grows. This is good news, since n is the maximum number of symmetries attainable with single-cycle symmetries of n variables, leading to time reductions by a factor close to n. Nevertheless, for small n there is still a significant fraction of the representatives not having the maximum number of symmetries. Another weakness of the proposed strategy is the exponential growth in the number of classes as a function of n.\nThe problems with small and large n should be tackled with a more refined subdivision of the initial domain in box symmetry classes, which is left for near future work. We are also currently approaching the extension of this work to deal with permutations of the problem variables composed of several cycles. Another complementary research line is the addition of constraints before the search with the CCS. These constraints will be specific for each symmetry class. Finally, the extension to Branch-and-Bound algorithms for nonlinear optimization could be envisaged."}, {"heading": "Acknowledgments", "text": "This is an extended version of work presented at CP 2007 (Ruiz de Angulo & Torras, 2007). The authors acknowledge support from the Generalitat de Catalunya under the consolidated Robotics group, the Spanish Ministry of Science and Education, under the project DPI200760858, and the \u201cComunitat de Treball dels Pirineus\u201d under project 2006ITT-10004."}], "references": [{"title": "Universally quantified interval constraints", "author": ["F. Benhamou", "F. Goualard"], "venue": "Proceedings of the 6th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Benhamou and Goualard,? \\Q2000\\E", "shortCiteRegEx": "Benhamou and Goualard", "year": 2000}, {"title": "A faster way to count the solutions of inhomogeneous systems of algebraic equations, with applications to cyclic n-roots", "author": ["G. Bj\u00f6rck", "R. Fr\u00f6berg"], "venue": "J. Symb. Comput.,", "citeRegEx": "Bj\u00f6rck and Fr\u00f6berg,? \\Q1991\\E", "shortCiteRegEx": "Bj\u00f6rck and Fr\u00f6berg", "year": 1991}, {"title": "Theory and aplications of distance geometry", "author": ["L. Blumenthal"], "venue": "Oxford University Press.", "citeRegEx": "Blumenthal,? 1953", "shortCiteRegEx": "Blumenthal", "year": 1953}, {"title": "Symmetry definitions for constraint satisfaction", "author": ["D. Cohen", "P. Jeavons", "C. Jefferson", "K.E. Petrie", "B.M. Smith"], "venue": "problems. Constraints,", "citeRegEx": "Cohen et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Cohen et al\\.", "year": 2006}, {"title": "Breaking row and column symmetries in matrix models", "author": ["P. Flener", "A. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel"], "venue": "In CP \u201902: Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Flener et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Flener et al\\.", "year": 2002}, {"title": "Groups and constraints: Symmetry breaking during search", "author": ["I.P. Gent"], "venue": "In Proceedings of CP-02, LNCS 2470, pp. 415\u2013430. Springer.", "citeRegEx": "Gent,? 2002", "shortCiteRegEx": "Gent", "year": 2002}, {"title": "Realpaver: An interval solver using constraint satisfaction techniques", "author": ["L. Granvilliers", "F. Benhamou"], "venue": "ACM Trans. on Mathematical Software,", "citeRegEx": "Granvilliers and Benhamou,? \\Q2006\\E", "shortCiteRegEx": "Granvilliers and Benhamou", "year": 2006}, {"title": "Solving polynomial systems using a branch and prune approach", "author": ["P.V. Hentenryck", "D. Mcallester", "D. Kapur"], "venue": "SIAM Journal on Numerical Analysis,", "citeRegEx": "Hentenryck et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hentenryck et al\\.", "year": 1997}, {"title": "Inter-block backtracking : Exploiting the structure in continuous csps", "author": ["C. Jermann", "G. Trombettoni"], "venue": "In In: 2nd International Workshop on Global Constrained Optimization and Constraint Satisfaction,", "citeRegEx": "Jermann and Trombettoni,? \\Q2003\\E", "shortCiteRegEx": "Jermann and Trombettoni", "year": 2003}, {"title": "Exploiting symmetries within constraint satisfaction search", "author": ["P. Meseguer", "C. Torras"], "venue": "Artif. Intell.,", "citeRegEx": "Meseguer and Torras,? \\Q2001\\E", "shortCiteRegEx": "Meseguer and Torras", "year": 2001}, {"title": "Combinatorial enumeration of groups, graphs and chemical compounds", "author": ["G. Polya", "R. Read"], "venue": null, "citeRegEx": "Polya and Read,? \\Q1987\\E", "shortCiteRegEx": "Polya and Read", "year": 1987}, {"title": "Complete maps of molecular loop conformational spaces", "author": ["J.M. Porta", "L. Ros", "F. Thomas", "F. Corcho", "J. Canto", "J. Perez"], "venue": "Journal of Computational Chemistry,", "citeRegEx": "Porta et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Porta et al\\.", "year": 2008}, {"title": "A branch-and-prune solver for distance constraints", "author": ["J.M. Porta", "L. Ros", "F. Thomas", "C. Torras"], "venue": "IEEE Trans. on Robotics,", "citeRegEx": "Porta et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Porta et al\\.", "year": 2005}, {"title": "Symmetry breaking revisited", "author": ["Puget", "J.-F."], "venue": "Constraints, 10 (1), 23\u201346.", "citeRegEx": "Puget and J..F.,? 2005", "shortCiteRegEx": "Puget and J..F.", "year": 2005}, {"title": "Exploiting single-cycle symmetries in branchand-prune algorithms", "author": ["V. Ruiz de Angulo", "C. Torras"], "venue": "In CP \u201907: Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Angulo and Torras,? \\Q2007\\E", "shortCiteRegEx": "Angulo and Torras", "year": 2007}, {"title": "Consistency techniques for continuous", "author": ["D. Sam-haroud", "B. Faltings"], "venue": "constraints. Constraints,", "citeRegEx": "Sam.haroud and Faltings,? \\Q1996\\E", "shortCiteRegEx": "Sam.haroud and Faltings", "year": 1996}, {"title": "Computation of the solution of nonlinear polynomial systems", "author": ["C.P.N.M. Sherbrooke E."], "venue": "Computer Aided Geometric Design, 10, 379\u2013405.", "citeRegEx": "E.,? 1993", "shortCiteRegEx": "E.", "year": 1993}, {"title": "Branch-and-prune search strategies for numerical constraint solving", "author": ["Vu", "X.-H", "M. Silaghi", "D. Sam-Haroud", "B. Faltings"], "venue": "Tech. rep. LIA-Report", "citeRegEx": "Vu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Vu et al\\.", "year": 2005}], "referenceMentions": [{"referenceID": 16, "context": "Journal of Artificial Intelligence Research 34 (2009) 499-520 Submitted 10/08; published 3/09", "startOffset": 25, "endOffset": 54}, {"referenceID": 5, "context": "Since CSPs are usually solved using AI search algorithms, the approaches dealing with symmetries fall into two groups: those that entail reformulating the problem or adding constraints before search (Flener, Frisch, Hnich, Kiziltan, & Miguel, 2002; Puget, 2005), and those that break symmetries along the search (Meseguer & Torras, 2001; Gent, 2002).", "startOffset": 312, "endOffset": 349}, {"referenceID": 16, "context": "identity) generated by this cycle by composition. Since the computational gain will be shown to be roughly proportional to n, the longest cycle appearing in the problem formulation should be chosen as input to our algorithm. This single-cycle permutation that leaves the constraints unchanged is a form of constraint symmetry in the terminology introduced by Cohen, Jeavons, Jefferson, Petrie, and Smith (2006). Note that any constraint symmetry is also a solution symmetry, but not the other way around.", "startOffset": 2, "endOffset": 411}, {"referenceID": 16, "context": "The two problems below have been solved with the Branch-and-Prune CCS presented by Porta, Ros, Thomas, Corcho, Canto, and Perez (2008). It is a polytope-based method similar to that of Sherbrooke E.", "startOffset": 2, "endOffset": 135}, {"referenceID": 16, "context": "The two problems below have been solved with the Branch-and-Prune CCS presented by Porta, Ros, Thomas, Corcho, Canto, and Perez (2008). It is a polytope-based method similar to that of Sherbrooke E. C. (1993) with global consistency, which exhibits quadratic convergence.", "startOffset": 2, "endOffset": 209}, {"referenceID": 2, "context": "The problem of finding all valid conformations of a molecule can be formulated as a distance-geometry (Blumenthal, 1953) problem in which some distances between points (atoms) are fixed and known, and one must find the set of values of unknown (variable) distances that are compatible with the embedding of the points in R3.", "startOffset": 102, "endOffset": 120}, {"referenceID": 2, "context": "of constraints consisting of equalities or inequalities of determinants formed with subsets of the fixed and variable distances (Blumenthal, 1953).", "startOffset": 128, "endOffset": 146}, {"referenceID": 11, "context": "6 minutes spent when using the algorithm of Porta et al. (2008) alone, a reduction by a factor of 6.", "startOffset": 44, "endOffset": 64}, {"referenceID": 1, "context": "The following polynomial equation system is the n = 5 instance of the so-called cyclic n-roots problem as described by Bj\u00f6rck and Fr\u00f6berg (1991).", "startOffset": 119, "endOffset": 145}], "year": 2009, "abstractText": "Symmetries in discrete constraint satisfaction problems have been explored and exploited in the last years, but symmetries in continuous constraint problems have not received the same attention. Here we focus on permutations of the variables consisting of one single cycle. We propose a procedure that takes advantage of these symmetries by interacting with a continuous constraint solver without interfering with it. A key concept in this procedure are the classes of symmetric boxes formed by bisecting a n-dimensional cube at the same point in all dimensions at the same time. We analyze these classes and quantify them as a function of the cube dimensionality. Moreover, we propose a simple algorithm to generate the representatives of all these classes for any number of variables at very high rates. A problem example from the chemical field and the cyclic n-roots problem are used to show the performance of the approach in practice.", "creator": "TeX"}}}