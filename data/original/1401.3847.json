{"id": "1401.3847", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Automatic Induction of Bellman-Error Features for Probabilistic Planning", "abstract": "Domain-specific features are important in representing problem structure throughout machine learning and decision-theoretic planning. In planning, once state features are provided, domain-independent algorithms such as approximate value iteration can learn weighted combinations of those features that often perform well as heuristic estimates of state value (e.g., distance to the goal). Successful applications in real-world domains often require features crafted by human experts. Here, we propose automatic processes for learning useful domain-specific feature sets with little or no human intervention. Our methods select and add features that describe state-space regions of high inconsistency in the Bellman equation (statewise Bellman error) during approximate value iteration. Our method can be applied using any real-valued-feature hypothesis space and corresponding learning method for selecting features from training sets of state-value pairs. We evaluate the method with hypothesis spaces defined by both relational and propositional feature languages, using nine probabilistic planning domains. We show that approximate value iteration using a relational feature space performs at the state-of-the-art in domain-independent stochastic relational planning. Our method provides the first domain-independent approach that plays Tetris successfully (without human-engineered features).", "histories": [["v1", "Thu, 16 Jan 2014 04:57:22 GMT  (71kb)", "http://arxiv.org/abs/1401.3847v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["jia-hong wu", "robert givan"], "accepted": false, "id": "1401.3847"}, "pdf": {"name": "1401.3847.pdf", "metadata": {"source": "CRF", "title": "Automatic Induction of Bellman-Error Features for Probabilistic Planning Online Appendix 1", "authors": ["Jia-Hong Wu", "Robert Givan"], "emails": ["JW@ALUMNI.PURDUE.EDU", "GIVAN@PURDUE.EDU"], "sections": [{"heading": null, "text": "Automatic Induction of Bellman-Error Features for Probabilistic Planning\nOnline Appendix 1\nJia-Hong Wu JW@ALUMNI.PURDUE.EDU Robert Givan GIVAN@PURDUE.EDU Electrical and Computer Engineering, Purdue University, W. Lafayette, IN 47907 USA"}, {"heading": "1. Additional Pseudo-code and Grammar", "text": "In this section, we present additional pseudo-code and feature grammar for our feature-learning framework as follows:\n1. Pseudo-code for our trajectory-based approximate value iteration (AVI) approach is shown in Figure 1 on page 2.\n2. Pseudo-code for drawing training sets by following a policy is shown in Figure 2 on page 2.\n3. Our relational feature grammar is shown in Figure 3 on page 3."}, {"heading": "2. Details on the Selection and Modification of Competition Domains", "text": "Every goal-oriented domain with a problem generator from the first or second IPPC (Younes, Littman, Weissman, & Asmuth, 2005; Bonet & Givan, 2006) was considered for inclusion in our experiments. For inclusion, we require a planning domain with a fixed action definition, as defined in Section 2.4 in the paper, that in addition has only ground conjunctive goal regions. Four domains have these properties directly, and we have adapted three more of the domains to have these properties as we describe in the next paragraph. The resulting selection provides seven IPPC planning domains for our empirical study. Figure 4 lists the reasons for the exclusion of the other six goal-oriented domains. In addition, four of the domains that we use in evaluation occur in both competitions in slightly different forms and we evaluate on one version of each of these four, as described in Figure 5.\nThe three domains we adapted for inclusion are as follows. We created our own problem generators for the first IPPC domains TOWERS OF HANOI and FILEWORLD, as none were provided in the competition. For both these domains, there is only one instance of each size. In Towers of Hanoi, all instances share the same action set and state predicates, so that a suitable problem generator is straightforward. In Fileworld, a planning domain with a fixed action definition results if we consider the collection of instances that share the same fixed number of folders, but varying the number of files. When the number of folders varies, the state predicates and actions change, so that instances with varying numbers of folders cannot be in the same fixed-action-definition planning do-\nmain under our definitions (preventing natural generalization between sizes). For our experiments, we create a suitable domain by coding a problem generator restricted to three folders.\nFurthermore, FILEWORLD, as written for the competition, is partially propositionalized (for unknown reasons). First, rather than have a one-argument predicate \u201chave-folder\u201d, the competition domain has one proposition \u201chave-f\u201d for each folder f . Also, the competition domain duplicates\n\u3008term\u3009 ::= \u3008variable\u3009 | \u3008constant\u3009\n\u3008goal-based-enrichment\u3009 ::= goal-\u3008domain-predicate\u3009 | correct-\u3008domain-predicate\u3009\n\u3008predicate\u3009 ::= \u3008domain-predicate\u3009 | \u3008goal-based-enrichment\u3009\n\u3008enriched-predicate\u3009 ::= \u3008predicate\u3009 | \u3008predicate\u3009+ | min-\u3008predicate\u3009 | max-\u3008predicate\u3009\n\u3008atom\u3009 ::= \u3008enriched-predicate\u3009 (\u3008term1\u3009, \u00b7 \u00b7 \u00b7 , \u3008termn\u3009), where n is the arity of \u3008enriched-predicate\u3009\n\u3008literal\u3009 ::= \u3008atom\u3009 | \u00ac \u3008atom\u3009\n\u3008conjunction\u3009 ::= \u3008literal\u3009 | \u3008conjunction\u3009 \u2227 \u3008literal\u3009\n\u3008feature-expression\u3009 ::= \u3008conjunction\u3009 | \u2203 \u3008variable\u3009 \u3008feature-expression\u3009\nand renames each action for each folder rather than take a folder object as an action argument (again for unknown reasons). Finally, the competition domain contains an apparent bug because it does not give types to the objects, so it is possible to file a folder in itself. Because we study relational generalization here, we have constructed the obvious lifted version of this domain with object types; we include the PPDDL source as Section 4 of this appendix. We call the resulting domain LIFTEDFILEWORLD3.\nFinally, for BOXWORLD, we modify the problem generator so that the goal region is always a ground conjunctive expression by replacing the goal \u201call boxes must be at their destinations\u201d\nwith a conjunction of specific box location goals. We call the resulting domain CONJUNCTIVEBOXWORLD."}, {"heading": "3. Parameterization of Our Methods", "text": "Here we describe our choice of parameters for our methods. Where possible, parameterization is done once, to apply identically to all experiments, as described here. There are some choices made once for each domain, and these are described in the subsection dedicated to each domain. The primary choices that must be made in a domain-specific way control learning from small problems: we must specify for each domain the performance threshold at which difficulty will be increased (as shown in Figure 1 in the paper) as well as the sequence of difficulties to be considered (in cases where there is more than one parameter controlling problem size). We defer to future research the topic of automated control of problem difficulty when learning from small problems. We currently make these choices by experimentation with the domain; our experience with such experimentation suggests that these choices can successfully be automated in the future."}, {"heading": "3.1 Trajectory Termination", "text": "Training sets for both feature learning and for AVI weight update are drawn by drawing trajectories based on the current greedy policy in problems drawn from the problem distribution at the current level of difficulty, as detailed in Sections 3 and 2.5 in the paper. It is an important and somewhat independent research topic to automatically recognize when such a trajectory is not making progress, e.g., by recognizing dead-end regions of states and/or lack of progress towards the goal. Any such research can be plugged into our methods directly by terminating all training trajectories when they fail an appropriate test.\nHere, we do not address this issue in any sophisticated way, but terminate trajectories whenever one of three conditions holds:\n1. a goal state is reached,\n2. a dead-end state is reached,\n3. the trajectory contains 1,000 steps."}, {"heading": "3.2 Training Set Sizes", "text": "Each feature-learning training set across all our relational-learning experiments is drawn to be 20,000 states by the method described in Section 3 in the paper. Because propositional feature learning is faster than relational feature learning, we are able to allow 200,000 states in propositional feature learning training sets in the TETRIS and SYSADMIN experiments, but still only 20,000 states in the planning domains.\nThroughout all experiments, each AVI weight-update training set is drawn by collecting the states from 30 trajectories."}, {"heading": "3.3 Learning Rate for Weight Updates in AVI", "text": "As discussed in Section 2.5 in the paper, we adjust the weights of our approximated value functions using AVI. We use a search-then-converge schedule for the learning rate of this iterative gradient descent method throughout our experiments (see Darken & Moody, 1992); specifically, we set the learning rate \u03b1 in AVI to 3\n1+k/100 , where k is the number of AVI iterations already executed."}, {"heading": "3.4 Parametrization of the Relational Algorithm", "text": "There are various parameters in the feature construction process described in this section, including the beam-width W , the beam-search depth limit d, the regularization parameter \u03bb, and the bound on the maximum number of quantifiers in scope q. Changes to these parameters affect the quality of the constructed features by changing the feature-space regions searched and the number of candidate features considered, as well as changing the preferences expressed in scoring the features. The selection of these parameters further affects the choice of the size of feature training set, as in practice fewer training examples can be considered when the number of candidate features grows.\nThroughout all our experiments we choose W to be 60, d to be 5, and \u03bb to be 0.03 for all domains. We set q to 1 for the planning competition domains (setting q to 2 does not result in a noted improvement in the performance in these domains when using the above parameters, but results in a substantial and occasionally intolerable runtime cost), and we set q to 2 for TETRIS. These severe limits on q are necessary to control the expense of searching the feature space. Note however that there is implicit quantification in the transitive-closure predicates and min/max predicates in the extended predicate set defining the feature space, in addition to the explicit quantifiers limited by q. See Section 4.1 in the paper for discussion of the extended predicate set."}, {"heading": "3.5 Parametrization of the Propositional Algorithm", "text": "Our propositional feature learning algorithm is already well defined in Section 4.4 in the paper, except for how to setup the underlying C4.5 learner (Quinlan, 1993). We use the default parameters for C4.5, except for the following: we use the gain criterion instead of the gain ratio criterion. We allow the trees to grow from a node without any restriction on the minimum number of objects in the resulting branches1. The pruning confidence level is set to 0.9."}, {"heading": "4. PPDDL Source for Lifted-Fileworld3", "text": "The PPDDL source for LIFTED-FILEWORLD3 with a problem size of 10 files.\n(define (domain file-world) (:requirements :typing\n:disjunctive-preconditions :negative-preconditions :conditional-effects :probabilistic-effects :universal-preconditions)\n(:types file folder)\n(:predicates (has-type ?p - file) (goes-in ?p - file ?f - folder) (filed ?p - file) (have ?f - folder)) (:constants F0 F1 F2 - folder )\n(:action get-type :parameters (?p - file) :precondition (and (not (has-type ?p))) :effect (and (has-type ?p)\n(probabilistic 0.333 (goes-in ?p F0)\n1. The default C4.5 parameter requires at least 2 branches from any node to contain at least 2 objects.\n0.333 (goes-in ?p F1) 0.334 (goes-in ?p F2))))\n(:action get-folder :parameters (?f - folder) :precondition (and (forall (?x -folder) (not (have ?x)))) :effect (have ?f))\n(:action file-F :parameters (?p - file ?f - folder) :precondition (and (have ?f) (has-type ?p)\n(goes-in ?p ?f)) :effect (filed ?p))\n(:action return-folder :parameters (?f - folder) :precondition (have ?f) :effect (not (have ?f))) )\n(define (problem file-prob) (:domain file-world) (:objects p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 ) (:goal (and (filed p0) (filed p1) (filed p2) (filed p3)\n(filed p4) (filed p5) (filed p6) (filed p7) (filed p8) (filed p9)))\n)"}, {"heading": "5. Modifications to the Weight Update Rule in AVI", "text": "Scaling step-size during AVI For the complex domains addressed in this paper, simple gradient descent has many potential pitfalls. One such pitfall is that the Bellman error surface may be extremely steep at some points. Because the weight changes in AVI are proportional to the gradient, arbitrarily large gradients result in arbitrarily large single-step weight changes that are rarely desirable (and can also cause floating-point overflow). There is a substantial literature on dynamically adjusting step size during gradient descent (Jacobs, 1988; Kwong & Johnston, 1992; Harris, Chabries, & Bishop, 1986; Mathews & Xie, 1993); however, gradient descent is not the main topic of this paper and so we resort only to a simple work-around for arbitrarily large gradients: rather than step proportional to the gradient, we compress the unbounded space of possible step sizes to a finite interval using a sigmoidal function, as described next. Large gradients here are due to large statewise Bellman error averages over the training set, as can be seen by examining the weight update equation, Equation 1, in Section 2.5 in the paper. Here we compress large weight updates by a sigmoidal scaling of the average statewise Bellman error, as described formally in the next three equations:\nBavg = 1\nn\n\u2211\nj\n(U(V \u03b2)(sj)\u2212 V \u03b2(sj))\n\u03ba = 1\n1 + exp(\u22124(1\u2212 |Bavg|/rscale))\nw\u03b2+1i = w \u03b2 i + \u03ba\n1\nni\n\u2211\nj\n\u03b1fi(sj)(U(V \u03b2)(sj)\u2212 V \u03b2(sj))\nIn our experiments, we use this approach to computing w\u03b2+1 rather than the direct approach given by Equation 1. The scaling factor \u03ba will be close to one unless the average statewise Bellman error Bavg grows large, and thus significant differences between the direct approach and the scaled approach appear only in that case. The sigmoidal function is a somewhat arbitrary choice here; any bounded, smooth, monotone function that is linear for a scalable-sized region near the origin will suffice. The domain-specific parameter rscale represents the reward scaling of the problem domain. We note that any MDP problem can be rescaled by multiplying all rewards by the same positive scalar with consequent rescaling of the value of any policy at any state by the same scalar. Our method here is not invariant to this rescaling and thus requires a hand-set domain parameter to represent the reward scaling. We select rscale using trial-and-error in each domain by starting from rscale = 1, which suffices for all domains we evaluate here except SysAdmin, where we us rscale = 10. We leave for future research the topic of automatically, possibly dynamically, finding the value of the reward scaling parameter.\nSign restriction in weight adjustment Another pitfall in using gradient descent with complex gradient surfaces is that dramatic increases in error can result from one step of weight update. In our AVI setting, this can result in dramatic drops in the success rate of the resulting greedy policy. Because in goal-oriented domains a useful gradient is computed only from successful trajectories, such dramatic drops in success rate can result in an uninformative gradient from which AVI often cannot recover. Various mechanisms can be designed for detecting dramatic drops in policy quality during AVI and revisiting the weight updates that lead to them; here we focus only on revisiting\nweight updates that change the sign of a weight, and only when the immediately resulting policy performs much worse than the policy before the weight update.\nIt is fairly intuitive that weight updates changing the sign of a weight are particularly suspect. If the weight for a feature has been tuned to a positive value, it is hopefully because that feature has been seen to correlate to the desired value function; however, this immediately implies that the negation of that feature anti-correlates with the desired value. Changing the sign of a weight is a form of rejecting previous training regarding the entire direction of the importance of the corresponding feature. Empirically, we have found that AVI on complex error surfaces often makes damaging mistakes by stepping too far in weight update to the degree that the sign of a feature is reversed and the resulting policy is suddenly severely degraded.\nIn our experiments in goal-oriented planning problems, we implement a mechanism to detect and avoid weight sign changes that must be avoided to preserve policy quality, as follows. First, we define a method for empirically comparing policies: we say that a policy \u03c01 \u201ctests as significantly better\u201d than a policy \u03c02 if Student\u2019s t-test confirms the hypothesis that the success rate of \u03c02 is at most 0.9 times the success rate of \u03c01 with significance 0.025 based upon 100 sample trajectories of each. Second, each time we construct an AVI training set by drawing trajectories, we measure the success rate of the policy Greedy(V ) used over the trajectories drawn to create the training set\u2014we call this the training success rate of the value function V . If the training success of the current value function V2 is lower than the training success of the previous value function V1, we then test if the the policy Greedy(V1) tests as significantly better than the policy Greedy(V2). If so, we reconsider any weight sign changes (including changes to or from zero) made during the intervening weight update as follows. Suppose that V1 is described by weights w\u03b2 and V2 by weights w\u03b2+1. For each weight wi that changed sign from w \u03b2 i to w \u03b2+1 i , we test if reversing the update of just that weight, using w\u03b2i in place of w \u03b2+1 i , yields a greedy policy that tests significantly better than Greedy(V2). Any such weights that yield significant improvements when their \u03b2+1-iteration updates are reversed are then restored to their \u03b2-iteration values and their sign is locked for the remainder of this run of AVI. In other words, any future weight update to that weight which would change the sign of that weight is replaced with no change to that weight."}], "references": [{"title": "Non-deterministic planning track of the 2006 international planning competition", "author": ["B. Bonet", "R. Givan"], "venue": "Website. http://www.ldc.usb.ve/ bonet/ipc5/", "citeRegEx": "Bonet and Givan,? \\Q2006\\E", "shortCiteRegEx": "Bonet and Givan", "year": 2006}, {"title": "Towards faster stochastic gradient search", "author": ["C. Darken", "J. Moody"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Darken and Moody,? \\Q1992\\E", "shortCiteRegEx": "Darken and Moody", "year": 1992}, {"title": "A variable step (VS) adaptive filter algorithm", "author": ["R. Harris", "D. Chabries", "F. Bishop"], "venue": "IEEE Transactions on Acoustics, Speech, and Signal Processing,", "citeRegEx": "Harris et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Harris et al\\.", "year": 1986}, {"title": "Increased rates of convergence through learning rate adaptation", "author": ["R. Jacobs"], "venue": "Neural Networks,", "citeRegEx": "Jacobs,? \\Q1988\\E", "shortCiteRegEx": "Jacobs", "year": 1988}, {"title": "A variable step size LMS algorithm", "author": ["R. Kwong", "E. Johnston"], "venue": "IEEE Transactions on Signal Processing,", "citeRegEx": "Kwong and Johnston,? \\Q1992\\E", "shortCiteRegEx": "Kwong and Johnston", "year": 1992}, {"title": "A stochastic gradient adaptive filter with gradient adaptive step size", "author": ["V. Mathews", "Z. Xie"], "venue": "IEEE Transactions on Signal Processing,", "citeRegEx": "Mathews and Xie,? \\Q1993\\E", "shortCiteRegEx": "Mathews and Xie", "year": 1993}], "referenceMentions": [{"referenceID": 3, "context": "There is a substantial literature on dynamically adjusting step size during gradient descent (Jacobs, 1988; Kwong & Johnston, 1992; Harris, Chabries, & Bishop, 1986; Mathews & Xie, 1993); however, gradient descent is not the main topic of this paper and so we resort only to a simple work-around for arbitrarily large gradients: rather than step proportional to the gradient, we compress the unbounded space of possible step sizes to a finite interval using a sigmoidal function, as described next.", "startOffset": 93, "endOffset": 186}], "year": 2010, "abstractText": "Every goal-oriented domain with a problem generator from the first or second IPPC (Younes, Littman, Weissman, & Asmuth, 2005; Bonet & Givan, 2006) was considered for inclusion in our experiments. For inclusion, we require a planning domain with a fixed action definition, as defined in Section 2.4 in the paper, that in addition has only ground conjunctive goal regions. Four domains have these properties directly, and we have adapted three more of the domains to have these properties as we describe in the next paragraph. The resulting selection provides seven IPPC planning domains for our empirical study. Figure 4 lists the reasons for the exclusion of the other six goal-oriented domains. In addition, four of the domains that we use in evaluation occur in both competitions in slightly different forms and we evaluate on one version of each of these four, as described in Figure 5. The three domains we adapted for inclusion are as follows. We created our own problem generators for the first IPPC domains TOWERS OF HANOI and FILEWORLD, as none were provided in the competition. For both these domains, there is only one instance of each size. In Towers of Hanoi, all instances share the same action set and state predicates, so that a suitable problem generator is straightforward. In Fileworld, a planning domain with a fixed action definition results if we consider the collection of instances that share the same fixed number of folders, but varying the number of files. When the number of folders varies, the state predicates and actions change, so that instances with varying numbers of folders cannot be in the same fixed-action-definition planning do-", "creator": "dvips(k) 5.96.1 Copyright 2007 Radical Eye Software"}}}