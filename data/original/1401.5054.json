{"id": "1401.5054", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Jan-2014", "title": "An\\'alisis e implementaci\\'on de algoritmos evolutivos para la optimizaci\\'on de simulaciones en ingenier\\'ia civil. (draft)", "abstract": "This paper studies the applicability of evolutionary algorithms, particularly, the evolution strategies family to estimation of a degradation parameter (referred as kappa parameter) for the shear design of reinforced concrete beams, a problem which have an expensive computational cost and highly relevant in the design of pillars and reinforced concrete structures, which however, has not been covered extensively in the present literature.", "histories": [["v1", "Mon, 20 Jan 2014 20:55:13 GMT  (4489kb)", "http://arxiv.org/abs/1401.5054v1", "The authors acknowledge corrections, comments and suggestions to this paper"], ["v2", "Sun, 6 Apr 2014 19:29:19 GMT  (1913kb)", "http://arxiv.org/abs/1401.5054v2", "The authors acknowledge corrections, comments and suggestions to this paper"], ["v3", "Sat, 21 Jun 2014 20:07:11 GMT  (1871kb)", "http://arxiv.org/abs/1401.5054v3", "In Spanish. The authors acknowledge corrections, comments and suggestions to this paper, thanks."]], "COMMENTS": "The authors acknowledge corrections, comments and suggestions to this paper", "reviews": [], "SUBJECTS": "cs.NE cs.AI", "authors": ["jos\\'e alberto garc\\'ia guti\\'errez", "alejandro mateo hern\\'andez d\\'iaz"], "accepted": false, "id": "1401.5054"}, "pdf": {"name": "1401.5054.pdf", "metadata": {"source": "CRF", "title": "\u201cANA\u0301LISIS E IMPLEMENTACIO\u0301N DE ALGORITMOS EVOLUTIVOS PARA LA OPTIMIZACIO\u0301N DE SIMULACIONES EN INGENIERI\u0301A CIVIL.\u201d", "authors": [], "emails": [], "sections": [{"heading": "FACULTAD DE INFORM\u00c1TICA", "text": "Departamento de Ingenier\u00eda Inform\u00e1tica"}, {"heading": "GRADO EN INGENIERIA INFORMATICA", "text": "\u201cAN\u00c1LISIS E IMPLEMENTACI\u00d3N DE ALGORITMOS"}, {"heading": "EVOLUTIVOS PARA LA OPTIMIZACI\u00d3N DE", "text": ""}, {"heading": "SIMULACIONES EN INGENIER\u00cdA CIVIL.\u201d", "text": ""}, {"heading": "Alumno: Jos\u00e9 Alberto Garc\u00eda Guti\u00e9rrez", "text": ""}, {"heading": "Tutores: Dr. D. Jos\u00e9 Mar\u00eda Cecilia Canales, Dr. D. Alejandro Mateo Hern\u00e1ndez", "text": "D\u00edaz."}, {"heading": "Agradecimientos", "text": "Este trabajo ha sido realizado en colaboraci\u00f3n con el departamento de Ingenier\u00eda Civil de la Universidad Cat\u00f3lica de Murcia, a quienes agradezco la ayuda que me han prestado y en especial a mis tutores, Alejandro y Jos\u00e9 Mar\u00eda por su paciencia en las explicaciones, as\u00ed como por haberme confiado este trabajo a pesar de que no siempre he podido dedicarle todo el tiempo que me hubiese gustado. En \u00faltimo lugar, me gustar\u00eda agradecer tambi\u00e9n a la unidad departamental de F\u00edsica B\u00e1sica de la Universidad de La Laguna de Tenerife el permitirme hacer uso de los recursos de c\u00e1lculo de dicha universidad. Parte de los textos e ilustraciones referidas al an\u00e1lisis y el desarrollo matem\u00e1tico de los problemas tratados fueron aportados por sus autores para la elaboraci\u00f3n del presente trabajo siendo por tanto suyos los derechos de cesi\u00f3n o reproducci\u00f3n de esos apartados."}, {"heading": "Resumen", "text": "En este trabajo, estudiamos la posible aplicaci\u00f3n de algoritmos evolutivos, concretamente de la familia de las Estrategias de Evoluci\u00f3n al problema de la estimaci\u00f3n de un par\u00e1metro kappa para la degradaci\u00f3n en el dise\u00f1o a cortante en vigas de hormig\u00f3n reforzado, un problema costoso computacionalmente y de gran relevancia en el dise\u00f1o de pilares y estructuras de hormig\u00f3n armado, cuya resoluci\u00f3n algor\u00edtmica no ha sido sin embargo abordada de forma extensa en la literatura existente."}, {"heading": "Abstract", "text": "This paper studies the applicability of evolutionary algorithms, particularly, the evolution strategies family to estimation of a degradation parameter (referred as kappa parameter) for the shear design of reinforced concrete beams, a problem which have an expensive computational cost and highly relevant in the design of pillars and reinforced concrete structures, which however, has not been covered extensively in the present literature.\n\u00cdndice General\n1. Introducci\u00f3n...................................................................................... 7\n1.1. Algoritmos evolutivos: Visi\u00f3n general.................................................................. 7\n1.2. Alcance y objetivos del proyecto......................................................................... 9\n1.3. Estructura y desarrollo del trabajo..................................................................... 10\n2. Estado del arte.................................................................................. 12\n2.1 M\u00e9todos Meta-heur\u00edsticos: tipos y evoluci\u00f3n hist\u00f3rica\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 13\n2.1.1 Conceptos b\u00e1sicos en Algoritmos Evolutivos\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 14\n2.1.2 T\u00e9cnicas evolutivas. Clasificaci\u00f3n y tipos\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026.\u2026..\u2026\u2026 18\n2.1.3 Algoritmos evolutivos en optimizaci\u00f3n continua. Estrategias de evoluci\u00f3n (EE) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026... 20\n2.2 Algoritmos Evolutivos en aplicaciones industriales e ingenier\u00eda\u2026\u2026\u2026\u2026\u2026\u2026\u2026 21\n2.3 Algoritmos Evolutivos: sobre su uso en ingenier\u00eda civil\u2026\u2026\u2026\u2026...................\u2026.. 25"}, {"heading": "3. El problema de la estimaci\u00f3n de par\u00e1metro de degradaci\u00f3n del hormig\u00f3n", "text": "solicitado a cortante \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026.. 27\n3.1 Descripci\u00f3n del problema. Formalizaci\u00f3n. Restricciones\u2026.\u2026\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u202630\n3.2 Propuestas de resoluci\u00f3n mediante t\u00e9cnicas evolutivas \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 36\n3.2.1 Covariance Matrix Adaptation Evolution Strategy (CMA-ES) \u2026.\u2026\u2026\u2026. 39"}, {"heading": "4. Experimentaci\u00f3n y an\u00e1lisis de resultados \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 44", "text": ""}, {"heading": "5. Conclusiones y trabajos futuros\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026...\u2026. 50", "text": "6. Bibliograf\u00eda\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.... 54\nANEXO I. C\u00f3digo fuente de los algoritmos implementados \u2026\u2026\u2026..\u2026.... 60\nANEXO II. Autorizaci\u00f3n del tutor para la defensa \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026 69\nCap\u00edtulo 1.\nIntroducci\u00f3n.\nEl principal aval de las t\u00e9cnicas algor\u00edtmicas de inspiraci\u00f3n evolutiva es su propio \u00e9xito. Por separado o conjuntamente a otros m\u00e9todos, los algoritmos evolutivos se han abierto paso y aparecen ligados a disciplinas muy dispares como la Gen\u00e9tica, la Rob\u00f3tica, la F\u00edsica Experimental, la Ingenier\u00eda del Software, la Ingenier\u00eda Civil, el Control de Sistemas Cr\u00edticos, el Dise\u00f1o Industrial o la Ingenier\u00eda de Materiales. En los siguientes cap\u00edtulos, tratamos de dar una perspectiva amplia sobre qu\u00e9 es la computaci\u00f3n evolutiva, el conjunto de t\u00e9cnicas y variantes algor\u00edtmicas que comprende y c\u00f3mo estas pueden ayudar en el trabajo de campo de la Ingenier\u00eda Civil.\n1.1 Algoritmos evolutivos: Visi\u00f3n general\nLos algoritmos evolutivos son estrategias de optimizaci\u00f3n y b\u00fasqueda de soluciones que toman como inspiraci\u00f3n la evoluci\u00f3n de distintos sistemas biol\u00f3gicos. La idea fundamental de estos algoritmos es mantener un conjunto de individuos que representan una posible soluci\u00f3n del problema. Estos individuos se mezclan y compiten entre s\u00ed, siguiendo el principio de selecci\u00f3n natural en el cual s\u00f3lo los m\u00e1s aptos sobreviven al paso del tiempo. Esto redunda en una evoluci\u00f3n hacia soluciones cada vez m\u00e1s aptas.\nLos algoritmos evolutivos son una familia de m\u00e9todos de optimizaci\u00f3n, y como tal, tratan de hallar una tupla de valores (xi,...,xn) tales que se minimice una determinada funci\u00f3n F(xi,...,xn). En un algoritmo evolutivo, tras parametrizar el problema en una serie de variables, (xi,...,xn) se codifican en una poblaci\u00f3n de cromosomas. Sobre esta poblaci\u00f3n se aplican uno o varios operadores gen\u00e9ticos y se fuerza una presi\u00f3n selectiva (los operadores utilizados se aplicar\u00e1n sobre estos cromosomas, o sobre poblaciones de ellos). Esta forma de funcionamiento les confiere su caracter\u00edstica m\u00e1s destacable: un algoritmo evolutivo puede ser implementado de forma independiente del problema, o a lo sumo, con un conocimiento b\u00e1sico de este, lo cual los hace algoritmos robustos, por ser \u00fatil para cualquier problema, pero a la vez d\u00e9biles, pues no est\u00e1n especializados en ning\u00fan problema concreto siendo los operadores gen\u00e9ticos empleados los que en gran parte confieren la especificabilidad al m\u00e9todo empleado.\nEn los \u00faltimos a\u00f1os son muchos los esfuerzos dedicados por investigadores de todo el mundo al desarrollo y la aplicaci\u00f3n de nuevos operadores y nuevas variantes algor\u00edtmicas evolutivas especializadas en los m\u00e1s diversos problemas. Sin embargo, no deben considerarse a las t\u00e9cnicas evolutivas como t\u00e9cnicas aisladas ni pensar que son adecuadas a todos los casos, si no entenderlas en el contexto de la que hoy se conoce como t\u00e9cnicas algor\u00edtmicas de Soft-Computing [69, 70, 71, 72, 79, 80], una rama de investigaci\u00f3n muy activa en la actualidad que viene a recoger el testigo de los avances producidos en el campo de la Inteligencia Artificial despu\u00e9s de que este resurgiera con fuerza a mediados de los a\u00f1os 80 del pasado siglo.\nDebido a su alta aplicabilidad los algoritmos evolutivos han tenido una adopci\u00f3n muy r\u00e1pida tanto en la industria como en el \u00e1mbito civil o militar, actualmente los principales centros de investigaci\u00f3n dedican ya importantes inversiones dentro de sus presupuestos a la aplicaci\u00f3n de t\u00e9cnicas de inteligencia artificial en general y de computaci\u00f3n evolutiva en particular [81, 82, 83]. Hoy d\u00eda, la Inteligencia Artificial es una herramienta imprescindible para el trabajo de ingenier\u00eda y se encuentra ya embebida en multitud de dispositivos y paquetes comerciales de software permitiendo aportar una soluci\u00f3n de caja negra a investigadores de muchas ramas, haciendo posible hallar soluciones realistas y computacionalmente tratables en \u00e1reas como:\na. Optimizaci\u00f3n num\u00e9rica, real o simb\u00f3lica, en situaciones donde existe una alta dimensionalidad, varios objetivos enfrentados, o no es posible conocer a priori la forma del espacio objetivo [61, 62, 73].\nb. Aprendizaje autom\u00e1tico, clustering, clasificaci\u00f3n y reconocimiento de patrones [74, 75].\nc. Implementaci\u00f3n de sistemas robustos, capaces de reaccionar ante situaciones an\u00f3malas o inesperadas. [51, 52, 76]\nd. Conseguir comportamiento emergente, es decir, sistemas con respuesta adaptativa, capaces de lidiar con problemas computacionalmente dif\u00edciles y de obtener soluciones v\u00e1lidas ante cambios en los par\u00e1metros del problema. [49, 59, 77]\ne. En sistemas empotrados o tiempo real, capaces de dar una respuesta r\u00e1pida de calidad aceptable en tiempos acotados. [5, 6, 7, 8, 78]\nf. En el tratamiento de flujos de informaci\u00f3n, compresi\u00f3n de bloques o procesamiento de grandes vol\u00famenes de datos, en usos como la extracci\u00f3n de conocimiento, eliminaci\u00f3n de ruido o la predicci\u00f3n de secuencias. [10, 33, 37, 38, 39]\nDe las ramas mencionadas, aquella que dispone de mayor n\u00famero de publicaciones y en la que se basa nuestro trabajo es la que trata de explotar el potencial de la computaci\u00f3n evolutiva como una poderosa herramienta de optimizaci\u00f3n de dise\u00f1os en sistemas de naturaleza heterog\u00e9nea."}, {"heading": "1.2 Alcance y objetivos del proyecto", "text": "En \u00e1mbitos como la ingenier\u00eda o el dise\u00f1o industrial se presentan con frecuencia problemas de optimizaci\u00f3n de distinto grado de dificultad. De entre ellos destaca un subconjunto especial de problemas denominado conjunto NP. Un problema perteneciente a este grupo es aquel para el cual no se conoce un algoritmo exacto de resoluci\u00f3n cuyo coste computacional guarde una relaci\u00f3n polinomial respecto al tama\u00f1o de la entrada, esto es, que no podemos abarcar el problema simplemente aumentando nuestra capacidad de c\u00e1lculo, siendo esto lo que los hace de dif\u00edcil resoluci\u00f3n. La tarea se vuelve a\u00fan m\u00e1s dif\u00edcil cuando el problema a resolver tiene una alta dimensionalidad por la presencia de un gran n\u00famero de caracter\u00edsticas [1,2] o variables de entrada [3,4]. Obteni\u00e9ndose un crecimiento cercano a exponencial en el tiempo de c\u00f3mputo conforme se incrementa de forma lineal el n\u00famero de variables consideradas. Una dificultad adicional a considerar al lidiar con un problema de optimizaci\u00f3n es el que, a veces, peque\u00f1as variaciones en las variables de entrada del problema pueden ocasionar grandes cambios en el espacio de soluciones, (esto da lugar a los llamados sistemas ca\u00f3ticos), lo que hace necesario que el algoritmo ofrezca una capacidad manejable de re-parametrizaci\u00f3n [5,6]. En este \u00e1mbito las metaheur\u00edsticas aparecen como una nueva e innovadora manera de encontrar buenos ajustes y par\u00e1metros de calibraci\u00f3n a modelos matem\u00e1ticos que por su complejidad no admiten el an\u00e1lisis anal\u00edtico, siendo adem\u00e1s muy tolerantes a la necesitad de re-parametrizar el problema o realizar ajuste fino cuando aparece un nuevo conjunto de condiciones en el entorno [7,8].\nLos algoritmos anal\u00edticos o exactos, usados tradicionalmente como herramientas para abordar problemas de optimizaci\u00f3n, garantizan encontrar el \u00f3ptimo global en muchos problemas, pero por contra, tienen el grave inconveniente de que en problemas reales pueden elevar el tiempo de ejecuci\u00f3n necesario hasta hacer inabarcables los costes de su implementaci\u00f3n siendo por tanto inasumibles y obligando a considerar t\u00e9cnicas diferentes al an\u00e1lisis matem\u00e1tico exhaustivo.\nEn contraste, los algoritmos heur\u00edsticos ad hoc son normalmente bastante r\u00e1pidos [84, 85, 99, 100], pero la calidad de las soluciones encontradas puede ser a veces insuficiente y estar lejos de ser \u00f3ptima, adem\u00e1s de presentar el inconveniente adicional de determinar los discriminantes heur\u00edsticos, dif\u00edciles de definir en determinados problemas.\nLas metaheur\u00edsticas ofrecen un equilibrio adecuado entre ambos extremos: son m\u00e9todos gen\u00e9ricos que ofrecen soluciones de buena calidad (el \u00f3ptimo global en muchos casos) en un tiempo moderado [11]. Adem\u00e1s, la naturaleza de los problemas en el \u00e1mbito cient\u00edfico (por ejemplo simulaciones f\u00edsicas, modelado de materiales, dise\u00f1o industrial, etc.) hace que en ocasiones el proceso de c\u00f3mputo se realice de manera descentralizada, bien en grandes computadores especializados [9, 10], bien mediante redes dedicadas para el c\u00e1lculo distribuido, y por este motivo, los algoritmos evolutivos se adaptan, por lo general, muy bien a las infraestructuras de c\u00e1lculo disponibles mostr\u00e1ndose como herramientas de paralelizaci\u00f3n eficaces en un campo de investigaci\u00f3n notablemente reclamado en el \u00e1mbito cient\u00edfico actual.\nDurante las siguientes p\u00e1ginas se discutir\u00e1 las posibilidades de aplicaci\u00f3n de varias clases de algoritmos evolutivos a problemas de dise\u00f1o avanzado en ingenier\u00eda civil dif\u00edcilmente abarcable mediante computaci\u00f3n exhaustiva por su alta dimensionalidad y su car\u00e1cter multimodal. La realizaci\u00f3n del presente trabajo se enmarca dentro de los objetivos acad\u00e9micos para la obtenci\u00f3n del t\u00edtulo de Grado en Ingenier\u00eda Inform\u00e1tica menci\u00f3n en Ingenier\u00eda de Software. En \u00e9l, abordaremos un problema de optimizaci\u00f3n de alta dificultad seleccionado por su trascendencia en el \u00e1mbito de estudio y llevaremos a cabo su resoluci\u00f3n empleando t\u00e9cnicas evolutivas donde esperamos encontrar soluciones de calidad comparables a las conseguidas a trav\u00e9s de las t\u00e9cnicas empleadas habitualmente y recogidas en la bibliograf\u00eda pero con un menor costo computacional. Los objetivos que se marcan como m\u00ednimo exigible para los pr\u00f3ximos meses incluir\u00e1n:\n- Entender el problema propuesto, realizar una b\u00fasqueda bibliogr\u00e1fica que nos permita situar el problema y comprender su contexto as\u00ed como cu\u00e1l ha sido el abordaje tradicional y que trabajos conforma el estado de la cuesti\u00f3n. - Comprender, compilar y testar el c\u00f3digo que constituye la implementaci\u00f3n del problema y valorar las posibles formas de mejora y optimizaci\u00f3n. - Proponer, analizar, e implementar una o varias propuestas de resoluci\u00f3n mediante t\u00e9cnicas meta-heur\u00edsticas. - Analizar los resultados obtenidos por cada uno de los m\u00e9todos cuantificando las mejoras conseguidas por cada uno y realizando un an\u00e1lisis cr\u00edtico sobre indicadores mesurables como el tiempo de c\u00f3mputo, la calidad de la soluci\u00f3n, o la complejidad algor\u00edtmica."}, {"heading": "1.2 Estructura y desarrollo del proyecto", "text": "Para el presente trabajo decidimos abordar dos partes bien diferenciadas: En una primera parte llevaremos a cabo un acercamiento a la problem\u00e1tica que\nqueremos abordar y analizaremos las caracter\u00edsticas generales de las metaheur\u00edsticas como herramientas de parametrizaci\u00f3n de modelos num\u00e9ricos y el estado del arte de la investigaci\u00f3n en este campo. En una segunda parte, introduciremos el problema de estimaci\u00f3n del par\u00e1metro kappa para el hormig\u00f3n armado solicitado a cortante y trataremos de proponer un nuevo enfoque para su resoluci\u00f3n basado en t\u00e9cnicas meta-heur\u00edsticas.\nEn el cap\u00edtulo dos, daremos algunas nociones b\u00e1sicas sobre los diferentes enfoques algor\u00edtmicos que existen para la optimizaci\u00f3n de funciones continuas y realizaremos un recorrido bibliogr\u00e1fico sobre el desarrollo en este campo y las vertientes donde se centra la investigaci\u00f3n en estas \u00e1reas en la actualidad.\nEn el cap\u00edtulo tres, propondremos la resoluci\u00f3n del problema objeto de estudio mediante Estrategias de Evoluci\u00f3n y propondremos distintas variantes y su aplicabilidad.\nFinalmente el cap\u00edtulo cuatro revisar\u00e1 de forma anal\u00edtica los resultados obtenidos por las diferentes propuestas y mostrar\u00e1 los resultados de forma gr\u00e1fica y comparada.\nLa \u00faltima parte del trabajo consistir\u00e1 en la extracci\u00f3n de conclusiones, exposici\u00f3n de limitaciones del estudio y planteamiento de posibles l\u00edneas de ampliaci\u00f3n futura.\nCap\u00edtulo 2."}, {"heading": "Estado de la cuesti\u00f3n.", "text": "Hay muchas formas de abordar problemas de optimizaci\u00f3n. Probablemente la m\u00e1s sencilla a priori sea la mera aproximaci\u00f3n anal\u00edtica. Sin embargo, los modelos que son anal\u00edticamente tratables habitualmente son tambi\u00e9n normalmente demasiado generales para proveer la precisi\u00f3n que requiere un sistema f\u00edsico. Adem\u00e1s el tratamiento anal\u00edtico resulta dif\u00edcil y pesado computacionalmente para funciones de varias variables. Los algoritmos que intentan encontrar el m\u00ednimo a una funci\u00f3n mediante evaluaciones de la misma pertenecen al grupo de los llamados algoritmos de hillclimbing, o de escalado de colinas; el \u00e9xito de la b\u00fasqueda en este tipo de procedimientos no depende solo de la funci\u00f3n objetivo, sino tambi\u00e9n de la pol\u00edtica de escalado que escojamos o dicho de otra forma de si escogemos apropiadamente la funci\u00f3n paso (iteraci\u00f3n) y el punto de inicio de la b\u00fasqueda (figura 1). Aun as\u00ed se trata de algoritmos pensados para realizar un refinamiento de una soluci\u00f3n que ya era en inicio razonablemente buena y por ello son sobre todos t\u00e9cnicas de b\u00fasqueda local, y, como tales, se concentran en encontrar el m\u00e1ximo m\u00e1s cercano al punto de inicio. Un algoritmo escalador simplemente evaluar\u00e1 la funci\u00f3n en uno o m\u00e1s puntos e ir\u00e1 movi\u00e9ndose por ella en peque\u00f1as variaciones buscando el punto que maximiza la funci\u00f3n objetivo.\nSin embargo, frecuentemente este tipo de m\u00e9todos no son adecuados para paisajes de b\u00fasqueda complejos, pues suelen atascarse en m\u00ednimos locales.\nUna variante interesante que intenta evadir este problema es el m\u00e9todo de recocido simulado, llamado as\u00ed por su similitud a como se forman los metales en una forja. La t\u00e9cnica de recocido simulado intenta escapar de estos falsos puntos soluci\u00f3n aceptando como valor siguiente alg\u00fan vecino que no tiene necesariamente que ser mejor que las soluciones ya encontradas. Para decidir cu\u00e1ndo un valor, aun siendo peor, podr\u00eda ser prometedor se utiliza un factor de aceptaci\u00f3n nombrado normalmente como temperatura. De esta manera, el nuevo valor ser\u00e1 candidato a soluci\u00f3n siempre que la diferencia entre el punto en el que me encuentro y aquel al que voy sea menor que el valor actual de temperatura. A pesar de su aparente sencillez, esta idea permite que el algoritmo muestre una mayor tolerancia y sea m\u00e1s dif\u00edcil el estancamiento. Sin embargo, el hecho de evitar quedar atascados e incluso alcanzar la condici\u00f3n de convergencia no nos asegura que estemos cerca de un valor \u00f3ptimo ya que seguimos dependiendo del punto donde se inicia la b\u00fasqueda.\nParte de las problem\u00e1ticas anteriores se pueden resolver usando una estrategia de multi-comienzo. Este tipo de estrategias, en realidad, no son m\u00e1s que la ejecuci\u00f3n paralela de varios de estos algoritmos, y por tanto, aunque son mejores, tampoco nos garantizan que se encuentre, o incluso se aproximen al m\u00e1ximo global. En todo caso, tiene la ventaja de que, en cada iteraci\u00f3n del algoritmo, se tiene una soluci\u00f3n v\u00e1lida, aunque no tiene porqu\u00e9 ser la mejor posible. Empleemos el m\u00e9todo que empleemos, para no degradar en un proceso de b\u00fasqueda ciega (b\u00fasqueda voraz) todos estos algoritmos necesitan una pista de hacia d\u00f3nde deben avanzar para alcanzar la mejor soluci\u00f3n. A esta funci\u00f3n gu\u00eda es a lo que en computaci\u00f3n se le llama heur\u00edstica. Una heur\u00edstica consiste b\u00e1sicamente en usar una serie de reglas (un conocimiento previo m\u00ednimo) para avanzar hacia la resoluci\u00f3n de un tipo de problema.\nLos M\u00e9todos Metaheur\u00edsticos fueron introducidos por vez primera por Fred Glover (tambi\u00e9n conocido por ser el creador del m\u00e9todo Tab\u00fa) en [12] y surgieron al combinar diferentes m\u00e9todos heur\u00edsticos con el objetivo de alcanzar una mayor eficiencia, robustez y eficacia en la exploraci\u00f3n del espacio de b\u00fasqueda. Fueron dise\u00f1ados para resolver problemas de optimizaci\u00f3n (optimizaci\u00f3n combinatoria y continua) complejos, donde no exist\u00eda un conocimiento profundo de la forma que tiene el espacio n-dimensional de soluciones. Los algoritmos evolutivos pertenecen a este tipo de t\u00e9cnicas."}, {"heading": "2.1 Metaheur\u00edsticas", "text": "Actualmente existen diferentes formas de clasificar a los algoritmos metaheur\u00edsticos [7], entre las m\u00e1s aceptadas y utilizadas en computacional creemos acertado resaltar las siguientes:\na) Algoritmos bio-inspirados / no bio-inspirados: Si se basan o no en la evoluci\u00f3n biol\u00f3gica.\nb) Est\u00e1ticos / Din\u00e1micos: Si se utiliza la misma funci\u00f3n objetivo o no durante todo el proceso evolutivo.\nc) Basados en un conjunto de soluciones (poblaci\u00f3n) / basados en una \u00fanica soluci\u00f3n: Esta radica en el n\u00famero de soluciones que se utiliza en el proceso de optimizaci\u00f3n.\nd) Con memoria / sin memoria: Esta depende del uso que hacen de su historia de b\u00fasqueda, es decir, si utilizan memoria o no.\nPara este trabajo, se decide adoptar la clasificaci\u00f3n que divide a las metaheur\u00edsticas en basadas en una soluci\u00f3n y basadas en poblaciones porque es ampliamente utilizada en la comunidad cient\u00edfica. Las t\u00e9cnicas evolutivas (AE), que desarrollaremos en profundidad, pertenecen al grupo de las metaheur\u00edsticas basadas en poblaciones."}, {"heading": "2.1.1 Conceptos b\u00e1sicos de algoritmos evolutivos", "text": "Como hemos visto en las secciones anteriores, cuando modelamos problemas de la vida real uno de los m\u00e1s frecuentes problemas es la alta dimensionalidad de espacio de b\u00fasqueda pero no es el \u00fanico. Tambi\u00e9n es frecuente encontrarse con problemas en los que las condiciones para la optimalidad de la soluci\u00f3n var\u00edan a lo largo del tiempo o no existen como tal. Este tipo de problemas se conocen como problemas multimodales.\nNo siempre las condiciones del problema permanecen est\u00e1ticas durante la duraci\u00f3n del mismo; puede ser que el espacio de b\u00fasqueda aumente o disminuya, que la valoraci\u00f3n de una soluci\u00f3n cambie, o simplemente que la forma m\u00e1s simple de resolver un problema consista en resolver previamente una serie de sub-problemas, que vayan acotando la soluci\u00f3n cada vez m\u00e1s.\nEl concepto de multi-modalidad ha sido usado en diferentes contextos: estrictamente, un problema multimodal es un problema que tiene varios m\u00e1ximos, todos ellos de la misma jerarqu\u00eda, pero tambi\u00e9n se aplica a aquellos problemas que tienen varias soluciones posibles.\nEn general, casi todo problema de b\u00fasqueda, formulado como un problema de optimizaci\u00f3n, suele tener varios m\u00e1ximos, uno de ellos es mejor que el resto, y este se le denomina m\u00e1ximo global. El resto son m\u00e1ximos locales; es decir, se puede definir una vecindad alrededor de ellos en la cual son m\u00e1ximos globales.\nLos AE son, a grosso modo, un m\u00e9todo de optimizaci\u00f3n basado en poblaci\u00f3n, especialmente \u00fatiles cuando tratamos un problema donde es costoso realizar un gran n\u00famero de iteraciones o donde existen dos o m\u00e1s funciones objetivo ya que se adaptan excepcionalmente bien a problemas multi-objetivo. Por lo tanto, los AE est\u00e1n indicados para resolver todo tipo de problemas que puedan ser expresados en forma de problema de optimizaci\u00f3n de una o varias funciones sujetas a un n\u00famero variable de restricciones y a una o m\u00e1s restricciones de contorno. Los AE son tremendamente sensibles a la manera en que codifiquemos a los individuos de la poblaci\u00f3n y la codificaci\u00f3n utilizada puede influir sensiblemente en las posibilidades de convergencia. Tanto es as\u00ed que algunas variantes de AE se diferencian precisamente en elegir una u otra forma de codificaci\u00f3n interna. Por tanto, la tarea m\u00e1s importante en un AE ser\u00e1 encontrar la representaci\u00f3n adecuada para las soluciones. La segunda tarea cr\u00edtica ser\u00e1 elegir correctamente la funci\u00f3n que guiar\u00e1 la b\u00fasqueda, y que puede ser \u00fanica o formarse de la combinaci\u00f3n ponderada de varias funciones. Esta funci\u00f3n suele recibir el nombre de funci\u00f3n objetivo o funci\u00f3n fitness (adecuaci\u00f3n). B\u00e1sicamente, los algoritmos gen\u00e9ticos funcionan como sigue: dada una poblaci\u00f3n de soluciones candidatas, y en base al valor de la funci\u00f3n objetivo para cada una de los individuos (soluciones) de esa poblaci\u00f3n, se seleccionan los mejores individuos (los que minimizan la funci\u00f3n objetivo) y se combinan para generar otros nuevos. Este proceso se repite c\u00edclicamente.\nEn primer lugar, debemos contar con un modelo matem\u00e1tico que permita evaluar un punto del espacio de soluciones en que se define el problema. En otros t\u00e9rminos, tenemos que poder plantear el problema como un problema de minimizaci\u00f3n (o maximizaci\u00f3n) de una funci\u00f3n objetivo, que representa la presi\u00f3n selectiva del medio. En segundo lugar, deber\u00e1 especificarse la manera de codificar las soluciones. Las codificaciones m\u00e1s sencillas, son aquellas que est\u00e1n basadas en c\u00f3digo binario (representaci\u00f3n en forma de cadena de bits). La interpretaci\u00f3n que sed\u00e9 a esa cadena depender\u00e1 de la naturaleza de la soluci\u00f3n (puede ser la codificaci\u00f3n de un valor entero, de un real, un vector de valores bol\u00e9anos... y cualquier otra estructura de datos).\nLa figura muestra el esquema algor\u00edtmico general que puede encontrarse en cualquier algoritmo evolutivo con peque\u00f1as modificaciones en lo esencial. En primer lugar (1) se procede a la inicializaci\u00f3n de la poblaci\u00f3n. Para cada individuo de la poblaci\u00f3n se selecciona un valor que puede ser completamente aleatorio. Tambi\u00e9n puede considerarse tomar como valores iniciales una aproximaci\u00f3n a la soluci\u00f3n. Despu\u00e9s se aplica a cada individuo la funci\u00f3n objetivo, es decir, la funci\u00f3n objetivo nos dice cuan bueno es un individuo como soluci\u00f3n, lo que da una medida de lo adaptado que est\u00e1 cada uno de ellos. En funci\u00f3n del valor obtenido se ordena la poblaci\u00f3n (2.2), quedando as\u00ed en primer lugar los individuos m\u00e1s adaptados. Se seleccionan entonces los individuos que se van a cruzar (2.3).\nHay distintas maneras de realizar esa selecci\u00f3n, las m\u00e1s usuales son:\nSelecci\u00f3n basada en rango: Seg\u00fan este criterio se seleccionan los m individuos mejor adaptados.\nSelecci\u00f3n por ruleta: Este criterio consiste en dar a cada individuo una probabilidad de ser seleccionado proporcional a su fitness. En este tipo de selecci\u00f3n un individuo puede seleccionarse dos veces y cruzarse consigo mismo.\nSelecci\u00f3n por torneo: Este criterio toma n individuos de la poblaci\u00f3n y selecciona al de mayor fitness de los selecciona dos. Una hemos seleccionado a nuestros progenitores se procede a cruzarlos (3): se escoge un punto de corte, y la tira de bits que representa a cada progenitor se divide en dos por ese punto.\nSelecci\u00f3n ad hoc: Muchas veces la naturaleza del problema o de los datos de entrada fuerzan a que la selecci\u00f3n se realice siguiendo criterios espec\u00edficos al problema. Un ejemplo de esto lo encontramos en los m\u00e9todos de selecci\u00f3n utilizados en optimizaci\u00f3n multi-objetivo.\nEl cruce normalmente (salvo en las estrategias de evoluci\u00f3n) representa el mecanismo m\u00e1s importante y es la base de todos los AE ya que en este paso es donde se produce el intercambio de informaci\u00f3n gen\u00e9tica. Este intercambio gen\u00e9tico se puede llevar a cabo de muchas formas. Los tipos principales de cruce son:\nCrossover n-puntos: los dos cromosomas se cortan por n puntos, y el material gen\u00e9tico situado entre ellos se intercambia. Lo m\u00e1s habitual es un crossover deun punto o de dos puntos.\nCrossover uniforme: se genera un patr\u00f3n aleatorio de 1s y 0s, y se intercambian los bits de los dos cromosomas que coincidan donde hay un 1 en el patr\u00f3n. O bien se genera un n\u00famero aleatorio para cada bit, y si supera una determinada probabilidad se intercambia ese bit entre los dos cromosomas.\nCrossover especializados: en algunos problemas, aplicar aleatoriamente el crossover da lugar a cromosomas que codifican soluciones inv\u00e1lidas; en\neste caso hay que aplicar el crossover de forma que generen siempre soluciones v\u00e1lidas. Un ejemplo de estos son los operadores de crossover usados en el problema del viajante. Tambi\u00e9n aparecen operadores de cruce especializados en codificaciones muy especializadas o en problemas donde se ha llevado un estudio exhaustivo y tenemos un amplio conocimiento del problema y queremos traspasarlo al algoritmo. En el paso 4 se genera en la descendencia una mutaci\u00f3n en un alelo (en el caso m\u00e1s simple la mutaci\u00f3n consiste en negar un bit) aleatorio. Esto sucede con una probabilidad baja (esto es, en la mayor\u00eda de los casos, el paso 4 no tiene efecto).\nUna vez se ha generado la descendencia, deber\u00e1 insertarse en la poblaci\u00f3n (5). Para llevar a cabo la inserci\u00f3n existen diversas pol\u00edticas:\nEliminar a los individuos peor adaptados e insertar los reci\u00e9n generados.\nEliminar al individuo peor y reemplazarlo.\nReemplazar toda la poblaci\u00f3n\nDebemos elegir cuidadosamente cada uno de estos par\u00e1metros ya que de ellos depender\u00e1 el \u00e9xito de nuestro algoritmo.\nPor \u00faltimo, en el paso 6 se comprueba si alguno de los individuos disponibles satisface los criterios establecidos y se puede considerar como soluci\u00f3n al problema. En este paso tambi\u00e9n se puede comprobar si se ha excedido un n\u00famero de iteraciones o un l\u00edmite de tiempo. Si no es as\u00ed y ning\u00fan individuo cumple los criterios de parada, se vuelve al paso 2.3.\nEste sencillo algoritmo junto los mecanismos de cruce y selecci\u00f3n se encuentran en la base de todos los algoritmos gen\u00e9ticos que con el tiempo han ido incorporando a un amplio abanico de operadores gen\u00e9ticos mejores y m\u00e1s complejos."}, {"heading": "2.1.2 T\u00e9cnicas evolutivas. Clasificaci\u00f3n y tipos", "text": "Existen varias aproximaciones a la idea de algoritmos evolutivos (En adelante abreviados como AE) pero a pesar del amplio abanico de algoritmos disponibles, todos ellos son similares en su planteamiento b\u00e1sico y en el uso que dan a las ideas evolutivas, y difieren principalmente en la forma de representaci\u00f3n de la informaci\u00f3n y en la importancia que dan a los diferentes operadores gen\u00e9ticos.\nA pesar del gran n\u00famero de variantes y paradigmas recogidos como computaci\u00f3n evolutiva [20], la mayor\u00eda de los autores est\u00e1n de acuerdo en clasificarlas en:\n-Evolutionary programming\n-Evolutionary strategies\n-Genetic algorithms\n-Genetic programming\nLos algoritmos de Estrategia Evolutiva (ES) fueron introducidos por Rechenberg et al. [22] a principio de los 70 en diferentes aplicaciones industriales e hidr\u00e1ulicas. Destacan sobre las otras porque est\u00e1n pensados para trabajar sobre espacios continuos (n\u00fameros reales) y porque los par\u00e1metros de funcionamiento del algoritmo (tasa de mutaci\u00f3n, probabilidad de cruce.) no son fijos sino que forman parte del proceso de optimizaci\u00f3n. Por ejemplo, en el algoritmo CMA-ES, el c\u00e1lculo de dichos par\u00e1metros se calcula a partir de la obtenci\u00f3n de las matrices de covarianza en el espacio de n dimensiones.\nLos Algoritmos Gen\u00e9ticos (GA) como caso particular, son un tipo de algoritmo evolutivo que ha demostrado ser muy efectivo en la optimizaci\u00f3n de procesos no lineales [28,29], con saturaci\u00f3n de ruido, y en general poco conocidos. Adem\u00e1s los AGs son algoritmos que pueden abarcar y aplicarse con \u00e9xito a un amplio espectro de problemas y para su dise\u00f1o es suficiente con tener un conocimiento m\u00ednimo a priori acerca del sistema. Esto convierte a los algoritmos gen\u00e9ticos en un paradigma de aplicaci\u00f3n deseable en un gran n\u00famero de escenarios donde la complejidad del problema hace desaconsejable otro tipo de metodolog\u00edas. En escenarios menos adversos, y especialmente cuando el usuario desea hacer una implementaci\u00f3n r\u00e1pida (aunque esta no sea la m\u00e1s eficiente) se emplea una simplificaci\u00f3n de este esquema llamada Simple Genetic Algorithm (SGA).\nUna aproximaci\u00f3n evolutiva distinta es la Programaci\u00f3n Gen\u00e9tica (GP). Este paradigma permite abordar problemas de optimizaci\u00f3n no lineal basada en un lenguaje simb\u00f3lico. El paradigma usado en programaci\u00f3n gen\u00e9tica tambi\u00e9n utiliza principios de selecci\u00f3n darwiniana como la selecci\u00f3n basada en fitness, pero los operadores gen\u00e9ticos ahora act\u00faan sobre \u00e1rboles simb\u00f3licos [30]. Por ejemplo, cada uno de estos \u00e1rboles podr\u00eda estar formado por sentencias de un lenguaje de programaci\u00f3n determinado. Sale de lo convencional y se diferencia de los GA principalmente en lo que respecta a su sistema de representaci\u00f3n. Las estructuras sometidas a adaptaci\u00f3n son com\u00fanmente programas completos que son ejecutables o conjuntos jer\u00e1rquicos de reglas evaluables de forma din\u00e1mica y con tama\u00f1os y formas distintos. Frecuentemente este tipo de sistemas son sistemas h\u00edbridos, a modo de ejemplo, podemos citar el caso de la GP-Fuzzy (Reglas difusas construidas a trav\u00e9s de programaci\u00f3n gen\u00e9tica) [31], que comprende una poblaci\u00f3n de reglas difusas / bases (estructuras simb\u00f3licas) que son los candidatos a ser soluciones al problema, y evolucionan en respuesta a una presi\u00f3n selectiva inducida por su relativo \u00e9xito en la implementaci\u00f3n de la conducta deseada. Este no es un ejemplo aislado, en muchos casos las t\u00e9cnicas evolutivas son usadas dentro de soluciones h\u00edbridas. Los m\u00e9todos h\u00edbridos han demostrado ser eficaces en el dise\u00f1o de sistemas inteligentes [32]. En los \u00faltimos a\u00f1os han proliferado todo tipo de soluciones h\u00edbridas que transgreden las l\u00edneas de separaci\u00f3n entre diferentes algoritmos para tomas las caracter\u00edsticas buenas de uno y otro. La l\u00f3gica borrosa, las redes neuronales y los paradigmas evolutivos pueden ser y son metodolog\u00edas complementarias en los trabajos de dise\u00f1o e implementaci\u00f3n de sistemas inteligentes. Cada uno de esos enfoques tiene sus ventajas e inconvenientes. Para aprovechar las ventajas y eliminar sus desventajas, en aplicaciones operativas reales muchos trabajos proponen la integraci\u00f3n de varias de estas metodolog\u00edas. Estas t\u00e9cnicas incluyen la integraci\u00f3n de redes neuronales y t\u00e9cnicas de l\u00f3gica difusa, as\u00ed como la combinaci\u00f3n de estas dos tecnolog\u00edas con t\u00e9cnicas de computaci\u00f3n evolutiva."}, {"heading": "2.1.3 Algoritmos evolutivos para optimizaci\u00f3n continua. Estrategias de evoluci\u00f3n (EE).", "text": "Las Estrategias de Evoluci\u00f3n (Evolutionary Strategies en lengua inglesa) son una familia de algoritmos estoc\u00e1sticos de optimizaci\u00f3n num\u00e9rica de funciones no-lineales o problemas de optimizaci\u00f3n continua no convexa donde no es posible conocer a priori la forma del espacio de soluciones ni es factible realizar el c\u00e1lculo de las derivadas sucesivas. Los algoritmos de Evoluci\u00f3n diferencial [86, 87, 88, 89] y CMA-ES (Estrategia de evoluci\u00f3n de adaptaci\u00f3n mediante covarianzas) [90, 91, 92] son dos ejemplos de miembros de esta familia.\nLas estrategias de evoluci\u00f3n fueron desarrolladas por Rechenberg [22] en su intento de resolver problemas dif\u00edciles en el campo de la hidrodin\u00e1mica. La primera versi\u00f3n del algoritmo, llamada (1+1)-EE o estrategia e evoluci\u00f3n de dos miembros utilizaba \u00fanicamente un padre y un descendiente. El descendiente se manten\u00eda en la poblaci\u00f3n solo si resultaba mejor que su padre. En la siguiente generaci\u00f3n el siguiente hijo era calculado a partir de valores normales (ecuaci\u00f3n 1), donde t se refiere a la generaci\u00f3n actual y N es un vector de n\u00fameros Gaussianos con media 0 y desviaci\u00f3n est\u00e1ndar \u03c3.\n),0(1 \u03c3NXX tt +=+ (1) En sucesivos trabajos, Rechenberg extendi\u00f3 el concepto de poblaci\u00f3n y propuso otras variantes como la variante (\u00b5+1) \u2013 EE [23], en la cual hay \u00b5 pares que generan solo un descendiente el cual puede reemplazar al peor padre de la poblaci\u00f3n.\nAlgorithm 2.1: Evolutionary Strategies (De Jong, 2006)\n. Con posterioridad, serian Schwefel et al. quienes mejorar\u00edan el concepto a\u00f1adiendo el uso de m\u00faltiples hijos y una variante multi-generacional, respectivamente (\u00b5+\u03bb) \u2013 EE, y (\u00b5,\u03bb) - EE [24]. En el primer caso, el el proceso\nde selecci\u00f3n la descendencia y los padres son tenidos en cuenta de forma equitativa; En el segundo caso, solo se tiene en cuenta la descendencia. El esquema general de un algoritmo de estrategia de evoluci\u00f3n aparece recogido en el algoritmo 2.1. De especial relevancia es el m\u00e9todo de selecci\u00f3n, que en las estrategias de evoluci\u00f3n se realice de forma determinista, raz\u00f3n por la cual solo los mejores individuos pasan a la siguiente generaci\u00f3n. El operador principal es la mutaci\u00f3n, realizando el operador de recombinaci\u00f3n un papel \u00fanicamente secundario que incluso se omite en algunos casos.\nSeg\u00fan el consenso generalizado [102,103] son buenas gu\u00edas de cuando deber\u00eda considerarse el uso de EE el que se den varias de las situaciones siguientes:\nFunciones no-lineales Funciones de variables no-separables Espacios de b\u00fasqueda no convexos Situaciones de multi-modalidad Funciones ca\u00f3ticas o con gran cantidad de ruido Media o alta dimensionalidad (desde 5 hasta 100 dimensiones)\nCuando una o m\u00e1s e estas caracter\u00edsticas concurren en la naturaleza de la funci\u00f3n a optimizar (ver figura 4), el uso de estrategias de evoluci\u00f3n puede reportar importantes beneficios."}, {"heading": "2.2 Algoritmos evolutivos en aplicaciones industriales e ingenier\u00eda", "text": "Los Algoritmos Evolutivos son una potente herramienta en optimizaci\u00f3n de formas. Debido a su relativa sencillez en comparaci\u00f3n con otros m\u00e9todos algor\u00edtmicos, su facilidad de uso, y su capacidad para adaptarse a los problemas de optimizaci\u00f3n multi-objetivo, los AE han sido aplicados a problemas de optimizaci\u00f3n de dise\u00f1os en muchas \u00e1reas [21, 35, 40], entre estas aplicaciones se encuentran la resoluci\u00f3n de problemas reales de dise\u00f1o\nde materiales o todo tipo de conjuntos aerodin\u00e1micos, desde conducciones de aire, turbinas o compresores, hasta dise\u00f1os de motores, dise\u00f1os mec\u00e1nicos completos o conjuntos de alerones.\nLos AE han sido aplicados con \u00e9xito en proyectos de toda envergadura produciendo importantes reducciones de costes y mejoras sustanciales en los resultados conseguidos [93, 94, 95, 96, 97]. Revisando la bibliograf\u00eda encontramos referencias muy tempranas, dando testimonio de la enorme solidez te\u00f3rica de la que disponen estas t\u00e9cnicas a d\u00eda de hoy. Entre ellos, encontramos los trabajos de referencia de Fogel [21] que estudi\u00f3 la aplicabilidad de lo que hoy conocemos como t\u00e9cnicas de programaci\u00f3n evolutiva al dise\u00f1o de aut\u00f3matas; Rechenberg [22,23], que resolvi\u00f3 con \u00e9xito por primera vez problemas industriales de hidr\u00e1ulica utilizando algoritmos poblacionales que simulaban evoluci\u00f3n, muy parecidos a las actuales estrategias evolutivas; y Schwefel [24], que estudi\u00f3 su aplicaci\u00f3n a problemas de optimizaci\u00f3n num\u00e9rica, todos ellos de principios de los 70.\nM\u00e1s tarde ser\u00eda Holland [25], quien, bas\u00e1ndose en el trabajo que ven\u00eda desarrollando en el estudio de sistemas adaptativos sentar\u00eda la base te\u00f3rica formal de todos los algoritmos evolutivos actuales dando forma a la teor\u00eda de los esquemas [25, 26].\nMucho m\u00e1s recientemente, queda patente, al consultar la bibliograf\u00eda, un resurgir del inter\u00e9s por los algoritmos evolutivos en la primera mitad de los a\u00f1os 90. Son muchos los trabajos que se publican en esos a\u00f1os, aunque podemos destacar algunos.\nPor ejemplo en el campo de la f\u00edsica encontramos el trabajo de Charbonneau en entre los a\u00f1os 1994 y 1996, centrados en la elaboraci\u00f3n de una extensa toolbox para la utilizaci\u00f3n de algoritmos gen\u00e9ticos en aplicaciones cient\u00edficas como el modelado del viento solar, la simulaci\u00f3n de interacciones entre cuerpos masivamente pesados o la estimaci\u00f3n de distancias basadas en el efecto Doppler [33]. En el campo de la ac\u00fastica, y casi al mismo tiempo, cabe destacar el trabajo de Tang et at. [34], en que se analizan las posibles ventajas del uso de algoritmos gen\u00e9ticos en el an\u00e1lisis de ondas y el procesamiento de\nse\u00f1ales. Orientados a la industria aeroespacial, encontramos las publicaciones de Keane y Brown [35], que utilizaron un algoritmo gen\u00e9tico para producir nuevos dise\u00f1os para brazos o jirafas destinados a transportar carga pesada que pudiesen montarse en \u00f3rbita y utilizarse con sat\u00e9lites, estaciones espaciales y otros proyectos de construcci\u00f3n aeroespacial.\nEn un enfoque diferente, Altshuler y Linden [36] a finales de 1997, utilizaron un algoritmo gen\u00e9tico para conseguir formas evolutivas de antenas de alambre con propiedades especificadas a priori por la parametrizaci\u00f3n dada. Y ya en el a\u00f1o 2000, Hughes y Leylanden [37] centraron su investigaci\u00f3n en los problemas de optimizaci\u00f3n multi-objetivo, y aplicaron con \u00e9xito algoritmos gen\u00e9ticos modificados a problemas multi-objetivo como el de la clasificaci\u00f3n de objetivos bas\u00e1ndose en sus reflexiones radar.\nAlgo despu\u00e9s, en 2002, Gurfil et al. utilizar\u00edan un algoritmo similar aplic\u00e1ndolo a la caracterizaci\u00f3n de orbitas geoc\u00e9ntricas [38], poniendo especial \u00e9nfasis en su estudio en encontrar soluciones sub-\u00f3ptimas, por la importancia que tienen este tipo de \u00f3rbitas para el posicionamiento de sat\u00e9lites pues permiten una alta tasa de transferencia en comunicaciones mientras se mantienen dentro de un entorno operacional seguro y fuera de perturbaciones t\u00e9rmicas y de radiaciones e interferencias producidas por el campo magn\u00e9tico de la tierra.\nA finales de ese a\u00f1o, en el \u00e1mbito de la f\u00edsica, encontramos los trabajos de Metcalfe et al. [39], donde se lleva a cabo la implementaci\u00f3n de un algoritmo gen\u00e9tico distribuido para la determinaci\u00f3n de par\u00e1metros globalmente \u00f3ptimos para el ajuste de modelos matem\u00e1ticos experimentales en la inferencia de informaci\u00f3n f\u00edsica y estructural de cuerpos celestes a trav\u00e9s del an\u00e1lisis de sus frecuencias de oscilaci\u00f3n (estudio de sus periodos de pulsaci\u00f3n) abriendo la puerta a la automatizaci\u00f3n masiva de este tipo de observaciones.\nEn el campo de la optimizaci\u00f3n de dise\u00f1os, distinguimos los experimentos de Galv\u00e3o et al. [40] donde los autores utilizaron algoritmos gen\u00e9ticos para dise\u00f1ar pol\u00edmeros conductores de electricidad basados en el carbono, conocidos como polianilinas. Y centr\u00e1ndonos en dise\u00f1o industrial, cabe mencionar el notorio trabajo de Oyama et al., donde se aplican algoritmos evolutivos al redise\u00f1o de rotores trans\u00f3nicos de cohetes [44] as\u00ed como los trabajos de Liou et al. [45] y Lian et al. [46,47] aplicados al redise\u00f1o de los pistones de motores de combustible l\u00edquido.\nEn el mismo campo, Kroo et al. [41] describ\u00edan el uso de m\u00e9todos de dise\u00f1o evolutivo en aplicaciones en aeron\u00e1utica a trav\u00e9s de ejemplos aplicados al dise\u00f1o de aviones supers\u00f3nicos (figura 5 izq.) lo que supuso un gran avance en el campo pues, en la aeron\u00e1utica, los procesos de optimizaci\u00f3n cobran vital importancia pues, un peque\u00f1o cambio en la geometr\u00eda del dise\u00f1o, puede producir grandes deferencias en el flujo del aire a altas velocidades, y una\npeque\u00f1a variaci\u00f3n en el peso estructural de un dise\u00f1o, puede repercutir enormemente en su rendimiento operativo.\nLas complejas simulaciones necesarias para llevar a cabo las mediciones que permiten validar los nuevos dise\u00f1os basados en todo un conjunto de hip\u00f3tesis de comportamiento a menudo representan un tiempo de c\u00f3mputo elevado, requiriendo en ocasiones la soluci\u00f3n de grande sistemas de ecuaciones diferenciales no lineales a veces trabajando con millones de v\u00e9rtices o soluciones estructurales con cientos de miles de grados de libertad. En esta materia, los algoritmos evolutivos son una soluci\u00f3n v\u00e1lida que permiten encontrar muchas buenas aproximaciones y hacerlo adem\u00e1s de forma paralelizable, rebajando con ello los tiempos de c\u00e1lculo.\nLa adaptabilidad y la simplicidad de las t\u00e9cnicas evolutivas permiten su aplicaci\u00f3n en estos casos obteniendo en muchos casos soluciones m\u00e1s eficientes que la optimizaci\u00f3n num\u00e9rica directa y ahorrando un considerable esfuerzo computacional. En este caso concreto el algoritmo propuesto por los autores fue un algoritmo PCGA, un algoritmo que est\u00e1 estrechamente relacionado con las estrategias de evoluci\u00f3n [42,43]. El algoritmo PCGA utiliza una poblaci\u00f3n generalmente peque\u00f1a con codificaci\u00f3n real para las variables. En PCGA un descendiente se crea como combinaci\u00f3n lineal de sus padres, concretamente mediante interpolaci\u00f3n entre dos dise\u00f1os anteriores o extrapolaci\u00f3n en una direcci\u00f3n dada a partir de estos. El mejor hijo sustituye al peor padre preservando el mejor dise\u00f1o en la poblaci\u00f3n y requiriendo solo comparaciones locales que pueden ser f\u00e1cilmente paralelas.\nDe nuevo en el estudio del tratamiento de se\u00f1ales y el filtrado de ruido es interesante el trabajo de Andreas M. Chwatal de 2008 [48], que en este caso propone la utilizaci\u00f3n de algoritmos evolutivos para el an\u00e1lisis de los datos obtenidos de la sonda espacial europea CAROT, en concreto como alternativa a la descomposi\u00f3n de ondas de interferencia mediante el m\u00e9todo de Fourier.\nUnos meses m\u00e1s tarde, encontramos nuevas aplicaciones en ingenier\u00eda industrial en los papers de Peniak y Cangelosi [49] quienes utilizaron un algoritmo gen\u00e9tico para entrenar una red neuronal de capa oculta utilizada para enviar correcciones de rumbo en tiempo real a veh\u00edculos aut\u00f3nomos a partir de la informaci\u00f3n de las mediciones de los sensores a bordo, y que nos sirve como ejemplo ilustrativo de configuraci\u00f3n en un esquema h\u00edbrido. Se han publicado numerosas propuestas para intentar mejorar el rendimiento de los EA. Una forma de conseguirlo es mediante la hibridaci\u00f3n, como hemos explicado en las secciones anteriores las soluciones hibridas suelen darse con frecuencia, y entre estas soluciones, una f\u00f3rmula de hibridaci\u00f3n frecuente es la uni\u00f3n de un algoritmo evolutivo y un m\u00e9todo determinista, por ejemplo el m\u00e9todo de descenso del gradiente [50]. Los m\u00e9todos de descenso de gradiente tienen una tasa de rapidez de convergencia muy elevada y la idea es ceder parte de esta propiedad al EA. La estrategia a seguir es normalmente la de utilizar el EA para descomponer el espacio de soluciones original en varias subregiones para luego dejar al algoritmo determinista la tarea de buscar cerca de esos sub-intervalos. Esta es la estrategia propuesta por Oyama et al. que utiliza un m\u00e9todo h\u00edbrido basado en un EA y un m\u00e9todo basado en gradiente, en este caso un resolutor por programaci\u00f3n secuencial cuadr\u00e1tica (SQP).\nEn el \u00faltimo lustro, podemos citar como trabajos innovadores a Dellnitz et al. [51] que implementa un algoritmo de programaci\u00f3n gen\u00e9tica con la finalidad de generar secuencias \u00f3ptimas de comandos de control para sat\u00e9lites que se encuentran aparcados en \u00f3rbitas peri\u00f3dicas; Kang et al. [52], los cuales hacen uso de un algoritmo de programaci\u00f3n gen\u00e9tica que les permite el estudio de las mejores rutas sobre mapas representados por grafos adaptativos obtenidos mediante el despliegue aleatorio de sensores; y Gosselin et al. [53] que publica un completo review sobre el uso de t\u00e9cnicas evolutivas en simulaciones de incendios y problemas de trasferencia de calor con frontera."}, {"heading": "2.3 Algoritmos evolutivos en Ingenier\u00eda Civil.", "text": "En lo referente al campo concreto de la ingenier\u00eda civil, los primeros trabajos que encontramos donde hay un uso expreso de AE fueron desarrollados por Coello et al. [54, 54b] en 1997, y ten\u00edan como objetivo la optimizaci\u00f3n de del dise\u00f1o de vigas de hormig\u00f3n armado. Para tal fin, implementaron un AG simplificado (SGA) en diferentes sistemas de codificaci\u00f3n, provisto de una tasa de mutaci\u00f3n que se eleg\u00eda de manera aleatoria en cada iteraci\u00f3n (dentro del rango 0.0 - 0.9), un m\u00e9todo de selecci\u00f3n por torneo y un operador de cruce de 2 puntos. Los autores utilizan m\u00e9todos emp\u00edricos para experimentar con diferentes sistemas de codificaci\u00f3n y diferente n\u00famero de variables de entrada entre las que consideraron el canto y ancho de la viga, el tipo de refuerzo, y el \u00e1rea de su armadura inferior. El resultado final fue la optimizaci\u00f3n del dise\u00f1o de\nvigas de hormig\u00f3n armado sometidas a un conjunto espec\u00edfico de restricciones, teniendo en cuenta factores como el coste de los materiales (hormig\u00f3n, acero, encofrado, etc...), o el coste del proceso de producci\u00f3n. Los resultados obtenidos fueron comparados con los presentados algunos a\u00f1os antes por Chakrabarty, utilizando programaci\u00f3n geom\u00e9trica e involucrando un menor n\u00famero de restricciones en el modelo. En esta ocasi\u00f3n, el algoritmo fue una variante de SGA (descrito con anterioridad) que representaba una clara alternativa al proceso tradicional de obtenci\u00f3n de estos valores mediante m\u00e9todos anal\u00edticos obteniendo resultados m\u00e1s realistas para los par\u00e1metros del modelo habida cuenta del mayor n\u00famero de restricciones aplicadas y una convergencia m\u00e1s r\u00e1pida. De manera concurrente Rafiq y Southcombe [55] aplican SGA al problema de optimizar el armado de pilares de hormig\u00f3n sometidos a esfuerzo axil y flexi\u00f3n esviada. En este \u00faltimo caso, la geometr\u00eda del pilar no es una variable del problema sino un par\u00e1metro de entrada.\nEn 1998, Kuomousis et al. [57] utilizan un algoritmo gen\u00e9tico para decidir el n\u00famero y la ubicaci\u00f3n \u00f3ptimos de barras de armado en secciones de hormig\u00f3n en edificios de varias plantas. Y un a\u00f1o m\u00e1s tarde, Botello et al. [56] presentan un algoritmo hibrido que utiliza un AG con codificaci\u00f3n real que integra fases de b\u00fasqueda local mediante el m\u00e9todo de recocido simulado; en esta ocasi\u00f3n, el objetivo era, una vez m\u00e1s, la optimizaci\u00f3n del dise\u00f1o de estructuras bajo diferentes condiciones de funcionamiento; por un lado, se estudi\u00f3 el dise\u00f1o \u00f3ptimo de p\u00f3rticos de naves industriales sometidos a cargas laterales, y por otro, se analiz\u00f3 la respuesta de elementos estructurales de puentes sometidos a efectos de compresi\u00f3n.\nCuatro a\u00f1os m\u00e1s tarde, Chau y Albermani [58] crean una nueva aplicaci\u00f3n inform\u00e1tica para el dise\u00f1o optimizado de dep\u00f3sitos rectangulares de hormig\u00f3n armado mediante el uso del programa comercial Abaqus \u00ae. Los resultados fueron muy buenos, a pesar de llevar a cabo un an\u00e1lisis relativamente simple del problema basado en la consideraci\u00f3n \u00fanicamente de tres variables geom\u00e9tricas: canto de las losa de hormig\u00f3n, cuant\u00eda de la armadura y separaci\u00f3n entre barras, repitiendo los mismos valores de dichas variables para todos los elementos del dep\u00f3sito. Tambi\u00e9n en 2003, Leps y Sejnoha [59] aplican un algoritmo de 21 variables que combina SA (recocido simulado) y un AG para la optimizaci\u00f3n de una viga continua sim\u00e9trica de hormig\u00f3n de dos vanos con armadura de cortante y de flexi\u00f3n. La t\u00e9cnica en cuesti\u00f3n, conocida como Augmented Simulted Annealing, es similar a un SA en el que: a) se trabaja con una poblaci\u00f3n de soluciones en lugar de con una \u00fanica soluci\u00f3n y b) las nuevas soluciones se obtienen a partir de las existentes mediante la aplicaci\u00f3n de los operadores gen\u00e9ticos y no mediante el concepto de movimiento (como se realiza en el SA).\nMas recientemente, Lee y Ahn, proponen el optimizado de p\u00f3rticos planos de hormig\u00f3n armado [60] empleando tambi\u00e9n un algoritmo SGA al que incorporan\nuna estrategia elitista, y, Fairnairn et al. [61], dise\u00f1an un procedimiento para optimizar la construcci\u00f3n de estructuras de hormig\u00f3n en masa utilizando un SGA con codificaci\u00f3n binaria y pol\u00edtica elitista, y, tomando como variables de entrada, el tipo y coste de materiales, su resistencia t\u00e9rmica o la distribuci\u00f3n interna de cada capa de componente; ello permiti\u00f3 estimar diferentes caracter\u00edsticas de funcionamiento de la estructura como su permeabilidad, su distribuci\u00f3n t\u00e9rmica, o su estado tensional. El algoritmo propuesto se enfrenta a los resultados obtenidos mediante la aplicaci\u00f3n de un modelo termo-quimiomec\u00e1nico de Coussy al caso concreto de la construcci\u00f3n de una presa para una central hidroel\u00e9ctrica. De forma muy similar, Lim et al. [62] estudian el balance \u00f3ptimo de proporciones en la fabricaci\u00f3n de hormig\u00f3n de alta resistencia.\nEn 2005, Sobolev et al. [63], utilizan un algoritmo gen\u00e9tico para optimizar las proporciones de materiales compuestos de cemento y hormig\u00f3n habida cuenta de su repercusi\u00f3n en las propiedades f\u00edsicas del material (densidad, viscosidad, etc..) as\u00ed como en el rendimiento (fortaleza, durabilidad, elasticidad, etc..) de la mezcla finalmente obtenida. El algoritmo utilizado es el algoritmo SAGA (SeftAdaptative Genetic Algorithm) propuesto por Amirjanov un a\u00f1o antes [64]. Este algoritmo se basa en un algoritmo gen\u00e9tico de evoluci\u00f3n diferencial con aprendizaje adaptativo, donde los mejores individuos de la poblaci\u00f3n act\u00faan como focos atractores indicando al algoritmo las zonas prometedoras donde debe concentrarse la b\u00fasqueda.\nEn otro \u00e1mbito de aplicabilidad, Prendes et al. est\u00fadian el uso de algoritmos gen\u00e9ticos en la evaluaci\u00f3n del dise\u00f1o de edificios de estructura met\u00e1lica [65] centrando los objetivos de dise\u00f1o en la resistencia a cargas est\u00e1ticas, la seguridad y el coste de los materiales. El algoritmo utilizado es un AG de baja especificabilidad utilizando codificaci\u00f3n real, un tama\u00f1o de poblaci\u00f3n de entre 60 y 100 individuos y tasa de mutaci\u00f3n aleatoria con valores entre 0.01 y 0.03, obteniendo mejoras moderadas de en torno al 10% en la estabilidad de la estructura.\nTambi\u00e9n cabe destacar, por el \u00e1mbito de aplicaci\u00f3n que iniciaron, el trabajo desarrollado por Dhyanjyoti et al. en 2006 [66], donde los autores se valieron de un algoritmo gen\u00e9tico para llevar a cabo predicciones sobre el comportamiento elasto-pl\u00e1stico que experimentan los materiales de estructura cristalina cuando se les somete a cargas c\u00edclicas. El art\u00edculo estudia adem\u00e1s la resistencia de los distintos materiales frente a ratios de deformaci\u00f3n constantes, buscando un aumentando la seguridad del dise\u00f1o y evitando posibles procesos de fatiga. En este caso, la fuente consultada no proporciona mayor detalle acerca del tipo de AG empleado.\nEn los \u00faltimos 5 a\u00f1os encontramos las publicaciones de Nehdi et al. [67] en el que se presenta un modelo para medir la resistencia a esfuerzo a cortante en\nvigas de hormig\u00f3n con refuerzo laminado externo de materiales FRP. Para parametrizar su modelo utilizan un AG simple que parte de un conjunto de 212 datos obtenidos de forma experimental obteniendo un ajuste mejor que el presentado hasta entonces por los modelos y normativas existentes (ACI 440, EuroCode2, Matthys model y Colotty model). Los mismos autores [68] ya hab\u00edan estudiado la aplicaci\u00f3n de AG en la estimaci\u00f3n de la resistencia a cortante en vigas de hormig\u00f3n igualmente reforzadas internamente con FRP. En ambos casos, el algoritmo implementado utilizaba codificaci\u00f3n real y un m\u00e9todo de selecci\u00f3n estoc\u00e1stica con una tasa de mutaci\u00f3n baja de 0,005. La capacidad de obtener varias soluciones sub-optimas concurrentemente permiti\u00f3 a los autores experimentar con diferentes materiales y disposiciones.\nCap\u00edtulo 3."}, {"heading": "El problema de la estimaci\u00f3n de", "text": "par\u00e1metro de degradaci\u00f3n del hormig\u00f3n solicitado a cortante.\nLa teor\u00eda de campo de compresiones (CFT) comprende un conjunto de hip\u00f3tesis de comportamiento para el hormig\u00f3n armado que permiten la realizaci\u00f3n de predicciones sobre la deformaci\u00f3n y evoluci\u00f3n de ruptura del material sometido a carga y esfuerzo cortante. Hern\u00e1ndez-D\u00edaz en su tesis doctoral [101], lleva a cabo una revisi\u00f3n te\u00f3rica de dicha teor\u00eda proponiendo una formulaci\u00f3n actualizada del modelo m\u00e1s cercana a como ocurre el deterioro del hormig\u00f3n armado (en funci\u00f3n a la deformaci\u00f3n y del comportamiento de tenso-rigidez del acero) que integra muchos de los \u00faltimos avances en el campo (Vecchio 1986; Collins 1991; Bentz 2000) y que es m\u00e1s coherente con el comportamiento de la armadura y con el fen\u00f3meno real de adherencia entre el hormig\u00f3n y el acero antes, y una vez se produce el agrietamiento de la estructura. En este contexto, Hern\u00e1ndez-D\u00edaz define un par\u00e1metro kappa que relaciona la deformaci\u00f3n con la consistencia y degradaci\u00f3n de la viga, lo que permite, una notable simplificaci\u00f3n en las ecuaciones, siendo este, un par\u00e1metro que requiere un ajuste experimental ya que resulta de la resolubilidad del sistema no lineal de ecuaciones que conforman las ecuaciones directoras al modelo de campo de compresiones, m\u00e1s las ecuaciones de equilibrio, y del modelo constitutivo del acero. Apoy\u00e1ndonos en sus resultados, tratamos de obtener una mejor estimaci\u00f3n para el par\u00e1metro kappa utilizando algoritmos de optimizaci\u00f3n evolutiva que mejoren los resultados obtenidos de forma algebraica por los autores en los trabajos referidos."}, {"heading": "3.1 Descripci\u00f3n del problema. Formalizaci\u00f3n. Restricciones", "text": "Durante los \u00faltimos a\u00f1os han aparecido varias teor\u00edas que tienen como objetivo estudiar la respuesta del hormig\u00f3n frente a esfuerzo cortante. Unas de las que constituyen el principal marco te\u00f3rico son las teor\u00edas de campo de compresiones.\nSon varias las hip\u00f3tesis que se han ido incorporando con aplicaciones importantes en la predicci\u00f3n de deformaciones. Hernandez-Diaz en [101]\nrealiza una revisi\u00f3n actualizada de las teor\u00edas de campo de compresiones integrando la denominada hip\u00f3tesis de Wagner [ref original 12], seg\u00fan la cual, la direcci\u00f3n del campo de tensiones coincide con la del campo principal de deformaciones. Y el par\u00e1metro kappa denominado \u201cde degradaci\u00f3n del hormig\u00f3n\u201d introducido por Gil Mart\u00edn et al [ref original 19] que permite que el \u00e1rea efectiva de hormig\u00f3n sometida a tracci\u00f3n (Ac) var\u00ede conforme lo hace el agrietamiento. El par\u00e1metro kappa (k), resulta adem\u00e1s clave en la solubilidad de las ecuaciones constitutivas del acero lo que lo hace merecedor de un estudio en profundidad.\nEl estudio del agrietado del hormig\u00f3n estructural es un proceso especialmente complejo, al tratarse de un sistema vivo, en el que, conforme avanza la degradaci\u00f3n, la fisura inicial se propaga y se ramifica en nuevas grietas donde una parte de las ecuaciones dependen de los \u00e1ngulos de inclinaci\u00f3n de las fisuras. Los modelos de campo de compresiones determinan el \u00e1ngulo de inclinaci\u00f3n de estas gritas considerando las deformaciones de la armadura, tanto trasversal como longitudinal, y del hormig\u00f3n, sujeto a unas condiciones de equilibrio y a las relaciones de tensi\u00f3n-deformaci\u00f3n entre la armadura y el hormig\u00f3n agrietado, que determinan, como la rigidez tensional del hormig\u00f3n (la contribuci\u00f3n a tracci\u00f3n del hormig\u00f3n) afecta a la respuesta tenso-deformacional del acero y por tanto al material compuesto.\nEl modelo descrito por Hern\u00e1ndez-D\u00edaz est\u00e1 formado por un sistema de once ecuaciones no lineales [101], el presente trabajo no tiene por finalidad la justificaci\u00f3n de dichas ecuaciones por lo que pasaremos simplemente a enumerarlas brevemente agrupadas seg\u00fan su naturaleza:\n3 condiciones de equilibrio\n1 2 (tan cot ) w\nV\nz b \u03c3 \u03c3 \u03b8 \u03b8+ = +\n\u22c5 (1)\n2 2 ; ; 2 1( sin cos )s t s t wA b s\u03c3 \u03c3 \u03b8 \u03c3 \u03b8= \u2212 \u22c5 (2)\n; 1 ; 1 ; 2 ; 2 1 tans x s x s x s x w V A A b z\u03c3 \u03c3 \u03c3 \u03b8 + + = (3)\ndonde \u03b8 es el \u00e1ngulo de inclinaci\u00f3n de las tensiones de compresi\u00f3n diagonal, V es el esfuerzo cortante, \u03c31 es la tensi\u00f3n de tracci\u00f3n principal para el hormig\u00f3n, , \u03c32 es el esfuerzo de compresi\u00f3n principal en el hormig\u00f3n, bw es el ancho del entramado, s es la separaci\u00f3n de estribo, As;x1, As;x2 y As;t son las \u00e1reas de secci\u00f3n transversal de las barras inferiores longitudinales, barras superiores longitudinales y de estribo, respectivamente.\n2 condiciones de compatibilidad\n2 12\n2 1\ntan x t\nt x\n\u03b5 \u03b5 \u03b5 \u03b5 \u03b8 \u03b5 \u03b5 \u03b5 \u03b5 \u2212 \u2212\n= = \u2212 \u2212 (4)\n1 2x t\u03b5 \u03b5 \u03b5 \u03b5= + \u2212 (5)\ndonde \u03b5t es la deformaci\u00f3n transversal promedio, \u03b51 es la deformaci\u00f3n principal por tracci\u00f3n, \u03b5x es la deformaci\u00f3n longitudinal media y \u03b52 es la tensi\u00f3n principal de compresi\u00f3n.\n2 ecuaciones para el comportamiento del hormig\u00f3n a compresi\u00f3n:\n{ }12, 1min 1 , (0.8 170 )max cf f \u03b5 \u2212= \u22c5 + (6) 2\n2 2 2 2, 2max\nc c\nf \u03b5 \u03b5\u03c3 \u03b5 \u03b5     = \u2212      (7)\nDonde fc es la fuerza a compresi\u00f3n del hormig\u00f3n, \u03b5c es la fuerza compresiva correspondiente a fc, y f2,max es una cota m\u00e1xima para el estr\u00e9s a compresi\u00f3n.\n1 ecuaci\u00f3n de comportamiento del hormig\u00f3n a tracci\u00f3n\n1 1\n1 1 1\n1\nfor\n( ) for\n1 500\nc ct\nct ct\nE\nf \u03b5 \u03b5 \u03b5 \u03b1\u03c3 \u03b5 \u03b5 \u03b5\n\u03b5 \u2264  \u22c5=  >  + \u22c5 (8)\nDonde Ec es el m\u00f3dulo de la elasticidad del hormig\u00f3n y \u03b5ct es la deformaci\u00f3n correspondiente a la resistencia a la tracci\u00f3n del hormig\u00f3n (fct).\n3 ecuaciones del modelo constitutivo para el acero de las barras de refuerzo (una para la armadura longitudinal inferior, otra para la armadura longitudinal superior, y una para la transversal)\n; 1\n; 1; 1 ; 1 ; 1\n; 1\nmax; 1; 1 max; 1 ; 1\n; 1\n,\n, 1 500\nwhere:\n1 500\ns x x max x\nc xs x ct y x x max x\ns x x\nct\nxy x x c x\ns s s x\nE A f f\nA\nf\nf A\nE E A\n\u03b5 \u03b5 \u03b5 \u03ba\u03c3 \u03b5 \u03b5\n\u03b5\n\u03b5 \u03b5 \u03ba\n\u2264 =  \u2212 > +\n+ = \u2212\n(9)\n; 2\n; 2; 2 ; 2 ; 2\n; 2\nmax; 2; 2 max; 2 ; 2\n; 2\n,\n, 1 500\nwhere:\n1 500\ns x x max x\nc xs x ct y x x max x\ns x x\nct\nxy x x c x\ns s s x\nE\nA f f\nA\nf\nf A\nE E A\n\u03b5 \u03b5 \u03b5 \u03ba\u03c3 \u03b5 \u03b5\n\u03b5\n\u03b5 \u03b5 \u03ba\n\u2264 =  \u2212 > +\n+ = \u2212\n(10)\n;\n;; ; ;\n;\nmax;; max; ;\n;\n,\n, 1 500\nwhere:\n1 500\ns x t max t\nc ts t ct y t t max t\ns t x\nct\nty t t c t\ns s s t\nE\nA f f\nA\nf\nf A E E A\n\u03b5 \u03b5 \u03b5 \u03ba\u03c3 \u03b5 \u03b5\n\u03b5\n\u03b5 \u03b5 \u03ba\n\u2264 =  \u2212 > +\n+ = \u2212\n(11)\nEn las ecuaciones (9), (10) y (11), los sub\u00edndices x1, x2 y t denotan el refuerzo longitudinal inferior, superior y transverso respectivamente. En el caso m\u00e1s general, cada tipo de armadura presenta diferente l\u00edmite el\u00e1stico (fy), diferente cuant\u00eda (As), diferente coeficiente de adherencia hormig\u00f3n-acero (\u03b1i) y diferente \u00e1rea efectiva de hormig\u00f3n a tracci\u00f3n (Ac), raz\u00f3n por la cual la deformaci\u00f3n aparente de cedencia (\u03b5max) definida por la TUCC var\u00eda de un tipo de armadura a otro.\nEn total tenemos once ecuaciones y once inc\u00f3gnitas \u03b8, \u03b5x, \u03b5t, \u03b51, \u03b52, \u03c31, \u03c32,\u03c3s;x1, \u03c3s;x2, \u03c3s;t, f2,max que pueden ser resueltas para un determinado valor de V (cortante de agotamiento) y \u03ba.\nMediante sustituci\u00f3n y operaci\u00f3n algebraica es posible reducir el sistema a un sistema de dos ecuaciones (que denotaremos f y g) y dos inc\u00f3gnitas (\u03b51, \u03b8); que tomar\u00e1n distinta forma dependiente del r\u00e9gimen de comportamiento que tomamos como supuesto (el\u00e1stico o pl\u00e1stico) para cada tipo de armadura. La\nfunci\u00f3n que define la primera ecuaci\u00f3n se denota f y representa el equilibrio los refuerzos longitudinales superior e inferior; la funci\u00f3n que define la segunda ecuaci\u00f3n se denota g y corresponde al equilibrio de refuerzo transversal.\nComo hemos dicho anteriormente, las expresiones de estas funciones dependen de la hip\u00f3tesis de comportamiento asumida, que posteriormente deberemos verificar en base a la soluci\u00f3n general del sistema. En ambas ecuaciones, se denota como \"E\" la hip\u00f3tesis correspondiente al r\u00e9gimen el\u00e1stico, y por \"P\" la hip\u00f3tesis correspondiente al r\u00e9gimen pl\u00e1stico, de forma que para un esp\u00e9cimen concreto indicaremos una terna de tres letras \"E\" o \"P\" que se corresponden a la hip\u00f3tesis asumida para sus refuerzos longitudinal superior e inferior y trasversal.\n( ); 1 ; 2 1 1 co [ , t 1 5 ] 00 w ct u s x s xE sE\nb f z Vf A A E\u03b8\n\u03b5 \u03b8 \u03b5 \u2212 + + + = \u2126\n(12)\n; 1 ; 2 ; 1\n1\n1 2 ; 2cot\n1 500 1 50 [ , ] 0\n( ) ctw ct u s x s s x y c x P xE fb f z V A E A f A f \u03ba \u03b5 \u03b8 \u03b5 \u03b8\n\u03b5 \u2212 + \u2126 + + = + \u2212\n\u2126 (13)\n( ); 1 ; 2 ; 1 ; 1 ; 2 ; 2\n1\n1 1 cot (\n1 50\n) [ , ]\n0 1 500\nct c x c xw ct u s x y x s xP yP x\nf A Ab f z V A f Af f \u03ba \u03b5 \u03b8 \u03b5 \u03b8 \u03b5 + \u2212 + + \u2212 + +\n= \u2126 (14)\n;\n1\n1 tan 1 50 [ , ] 0 E w ct u\ns t s\nb f s V s E\nz g A\u03b8 \u03b5 \u03b8 \u03b5 \u22c5\u2212 + + = \u03a8\n(15)\n1 ; 1 ; ;\n1\nta ( )\n[ n 1 500 1 50 0\n, ] ctc tP w ct u s t y t\nfb f s V s A f\nz\nA g \u03b5 \u03b5 \u03b8 \u03b5 \u03b8 \u03ba\u22c5\u2212 + \u2212 + + =\n\u03a8 (16)\nDonde los factores \u2126 y \u03a8 se definen como:\n2\n2\n1\n2 1\n2 (behavior coefficient for the longitudinal reinforcement)\n1 tan\n(behavior coefficient for the transverse reinforcement) 1 tan\ntan\ntan\nc\nc\n\u03b8\n\u03b8\n\u03b5 \u03b8 \u03bb\u03b5\n\u03b5 \u03bb\u03b5 \u03b8\n\u2126 = +\n+\n+\u03a8 = +\nSujeto a:\n1\n1\n(cot tan )\n1 500 1 1\nmin , 0.8 170\nct\nw\nc c\nfV\nb z\nf f\n\u03b8 \u03b8 \u03b5\n\u03b5\n\u03bb\n+ \u2212 +\n\u2212 \u2212    + = \nUna importante propiedad de este sistema reducido es que permite su representaci\u00f3n gr\u00e1fica permiti\u00e9ndonos obtener la llamada curva de solubilidad\ndel sistema [105]. Esta curva se compone de un conjunto de puntos (\u03ba, \u03b51) para los que el sistema reducido tiene una soluci\u00f3n real.\nEn el estudio referido se llev\u00f3 a cabo una selecci\u00f3n de un total de 81 vigas de hormig\u00f3n armado ensayadas hasta su agotamiento a cortante, correspondientes a diferentes campa\u00f1as experimentales y contenidas en la base de datos de cortante editada por Reineck et al. [106]. Para cada una de las vigas se midieron directamente, entre otros par\u00e1metros, los valores de cortante (Vexp) y tensi\u00f3n en cercos (\u03c3st,exp) en la secci\u00f3n de agotamiento. En la Tabla 1 se resumen los valores experimentales de cortante y tensi\u00f3n en cercos de los 81 espec\u00edmenes.\nAuthor Beam V u \u03c3 st,exp Ahmad et al. (1995) [2] NHW-3b 122779 324.14\nA50 115426 492.41 A75 142203 420 C50 134107 507.59 C75 137977 444 S1-4 277900 450 S2-3 253300 265.96 S4-6 202900 300 S7-4 273600 375\nLeonhardt et al. (1962) [14] ET3 126248 313.92\nMoayer et al. (1974)[18] P20 120096 310.28 Soerensen (1974) [19] T22 128987 399.27\nBernhardt et al. (1986) [4] S8 A 125720 427\nH 50/4 246340 540 H 75/4 255230 530 H 100/4 266530 540\nRC 30 A1 676000 480 RC 30 A2 688000 480 RC 60 A1 990000 480 RC 60 A2 938000 480 RC 60 B1 1181000 480 RC 60 B2 1239000 480 RC 70 B1 1330000 480\nRosenbusch et al. (1999) [18] MHB 2.5-25 98801 267.30\nT3 105000 270 T4 110000 270 T6 205000 270 T7 109000 280 T8 124000 280 T9 154000 280 T13 90000 270 T15 104000 270 T17 134000 280 T19 106000 270 T20 138000 280 T26 179000 280 T32 216000 270 T34 112000 270 T35 115000 270 T37 209000 270 T38 238000 270\nPalaskas et al. (1981) [16]\nKong et al. (1997) [13]\nCladera et al. (2002) [6]\nLevi et al. (1988) [15]\nRegan (1971) [17]\nTabla 1. Listado de los 81 espec\u00edmenes recopilados por Reineck et al. (2000).\nUna vez sustituidos los par\u00e1metros calculados en las ecuaciones reducidas del sistema, se obtiene, para cada una de las hip\u00f3tesis de comportamiento ya definidas, un conjunto de dos funciones {f,g} parametrizado en V y \u03ba.\nA medida que aumenta el valor de \u03ba, se produce una evoluci\u00f3n en la posici\u00f3n relativa de las curvas de ceros de las funciones f y g. Se dice que una hip\u00f3tesis de comportamiento es soluble cuando ambas funciones tengan al menos un punto de intersecci\u00f3n para alg\u00fan valor de \u03ba. As\u00ed mismo, diremos que una secci\u00f3n de hormig\u00f3n armado es soluble a efectos del ajuste del par\u00e1metro \u03ba cuando lo sea al menos una de las hip\u00f3tesis de comportamiento para el valor experimental de V.\nLa figura 7 representa la curva de puntos (\u03ba, \u03b51) del esp\u00e9cimen H 75/4 para la hip\u00f3tesis EEP. De ellos solo una peque\u00f1a parte verifica la hip\u00f3tesis de comportamiento asumida (porci\u00f3n en verde). A efectos del ajuste del par\u00e1metro \u03ba, necesitamos espec\u00edmenes que, adem\u00e1s de solubles, sean consistentes. La\nfunci\u00f3n de par\u00e1metro buscado ser\u00e1 aquel que logre intersectar el mayor n\u00famero de segmentos consistentes para los 81 espec\u00edmenes tomados en el experimento y para aquellas de sus hip\u00f3tesis que sean solubles. Por simplicidad, se buscar\u00e1 el que esta funci\u00f3n tome forma polin\u00f3mica { }3 21 1 1 1( ) ; , , ,a b c d a b c d\u03ba \u03b5 \u03b5 \u03b5 \u03b5= + + + \u2208R"}, {"heading": "3.2 Propuestas de resoluci\u00f3n mediante t\u00e9cnicas evolutivas", "text": "Hern\u00e1ndez et al. proponen en [107] resolver el problema de la estimaci\u00f3n del par\u00e1metro de degradaci\u00f3n del hormig\u00f3n armado mediante algoritmo de computaci\u00f3n evolutiva derivado del Little Genetic Algorithm (LGA) propuesto por Coley et al. en el a\u00f1o 2000 para usos acad\u00e9micos e industriales [108]. En pocas palabras el m\u00e9todo es una simplificaci\u00f3n del esquema general de los algoritmos gen\u00e9ticos donde una poblaci\u00f3n inicial de individuos evolucionan a trav\u00e9s de dos mecanismos. Un mecanismo de selecci\u00f3n basado en ruleta (proporcional al fitness) y un operador de cruce uniforme de 1 punto con una probabilidad de mutaci\u00f3n aleatoria entre 0 y 1. La pol\u00edtica de reemplazo realiza el reemplazo completo de la poblaci\u00f3n en cada generaci\u00f3n llevando a cabo una estrategia elitista (conservaci\u00f3n del m\u00e1s apto individuo). Cada individuo en la poblaci\u00f3n lleva asociado un array R de 4*l bits (genoma) que codifica los cuatro coeficientes de una funci\u00f3n c\u00fabica \u03baR(\u03b51). El array R puede dividirse por tanto en cuatro secuencias de l bits R1, R2, R3 y R4, que resultan de dividir los n\u00fameros enteros cuyos codificaciones en codificaci\u00f3n gray son R1, R2, R3 y\nR4, respectivamente, por 2l, y, finalmente, transformar los n\u00fameros obtenidos en valores binarios.\nPara calcular la funci\u00f3n de aptitud (fitness) se hace uso de la siguiente funci\u00f3n auxiliar Fit(R)\u2208[0,1].\n( ) { }\n2\n, ,exp , , consistent( ) # ; is consistent st X st X R XF R X X\n\u03c3 \u03c3\u2212 = \u2211\n(17)\nDonde \u03c3st,X,exp es la tensi\u00f3n experimental en cercos en el punto de ruptura (\u03c3st,exp) cuyo valor conocemos (tabla 1) y \u03c3st,X,R es la tensi\u00f3n te\u00f3rica obtenida por el modelo tomando la ecuaci\u00f3n \u03ba=\u03baR(\u03b51) una vez deshechos los cambios de variable. Como podemos ver, la diferencia cuadrada (\u03c3st,X,exp- \u03c3st,X,R)\n2 actuar\u00e1 de error cuadr\u00e1tico para la obtenci\u00f3n del fitness. En caso de que este valor no pueda calcularse se devolver\u00e1 un valor de fitness penalizado lo suficientemente alto como para que se descarte la soluci\u00f3n.\nPara llevar a t\u00e9rmino la ejecuci\u00f3n del algoritmo se monta un cluster formado por 64 procesadores AMD Opteron de doble n\u00facleo interconectados mediante red GigaNet. Aun as\u00ed, el tiempo de ejecuci\u00f3n del algoritmo fue de 285 horas terminando su ejecuci\u00f3n al alcanzar un l\u00edmite de ejecuciones impuesto a priori partiendo de una poblaci\u00f3n inicial donde ya ha sido incluido una soluci\u00f3n aceptable (obtenida por los autores mediante regresi\u00f3n num\u00e9rica).\nComo consecuencia de haber a\u00f1adido soluciones artesanales en la poblaci\u00f3n inicial y la alta dispersi\u00f3n de los puntos (\u03b51, \u03baopt) de las muestras de la base de datos, la aptitud m\u00e1xima no aumenta mucho m\u00e1s all\u00e1 del valor inicial m\u00e1ximo de 16,63 % en las primeras generaciones. La figura 8 muestra la representaci\u00f3n gr\u00e1fica del candidato m\u00e1s apto encontrado despu\u00e9s de 200 generaciones. Los coeficientes correspondientes a esta soluci\u00f3n para la funci\u00f3n c\u00fabica 3 2\n1 1 1 1( )R a b c d\u03ba \u03b5 \u03b5 \u03b5 \u03b5= + + + son a=-0.1713, b=0.0346, c=1.2902 y d=-0.4725, y el fitness conseguido 28.40%.\nLa siguiente figura (figura 9) muestra la evoluci\u00f3n del fitness conseguido a lo largo de la ejecuci\u00f3n del algoritmo. En ella podemos observar como existe una situaci\u00f3n de estancamiento donde no existe una evoluci\u00f3n real de la aptitud de los individuos de la poblaci\u00f3n y donde la b\u00fasqueda ha degenerado en un proceso meramente aleatorio. La causa de este fen\u00f3meno posiblemente no puede ser explicada por un \u00fanico factor sino por una conjunci\u00f3n de varios factores. El m\u00e1s visible de todos ellos es que la b\u00fasqueda se realiza en un vasto espacio de soluciones cont\u00ednuas (el espacio R de 4 dimensiones) y sin embargo el algoritmo empleado es enormemente gen\u00e9rico y no especializado en espacios continuos dif\u00edciles. Tambi\u00e9n el hecho de introducir desde el principio soluciones aceptables, en combinaci\u00f3n con la pol\u00edtica elitista va a desembocar en un empobrecimiento muy r\u00e1pido de la informaci\u00f3n gen\u00e9tica contenida en la poblaci\u00f3n. Tampoco ayuda la penalizaci\u00f3n introducida, que en la ejecuci\u00f3n considerada era de 5 magnitudes (105). Esta pr\u00e1ctica se vuelve a\u00fan menos recomendable si consideramos que debido a la naturaleza del problema, puede darse el caso de que dos valores muy cercanos en el espacio de soluciones no comportan solubilidad, es decir, uno puede ser resoluble y\notro no, y, al estar la funci\u00f3n fitness indefinida en el caso de la no solubilidad, esta circunstancia lleva al extremo de que un avance en la direcci\u00f3n correcta pueda ser penalizado y por tanto descartado de la b\u00fasqueda. Podr\u00edamos considerar estos puntos no definidos como ruido en el espacio de soluciones. En este escenario, escapar de los m\u00ednimos locales (que ser\u00e1n abundantes) es crucial para poder alcanzar un m\u00ednimo global. Si esto es as\u00ed, entonces la pol\u00edtica elitista tendr\u00eda que ser llevada a cabo con sumo cuidado ya que puede dificultar el que el algoritmo pueda escapar de estos puntos trampa.\nAdem\u00e1s de estas consideraciones, existen otras de menor gravedad que tambi\u00e9n deber\u00edan ser tenidas en cuenta. Por ejemplo, la forma de cruce (cruce binario uniforme en un punto) no necesariamente es coherente ni con la naturaleza de la soluci\u00f3n, ni con la del dato mismo. Es decir, al partir una cadena binaria por la mitad podemos de hecho estar rompiendo un n\u00famero real el dos mitades (una con la parte entera y otra con la parte decimal) o incluso, estar partiendo por la mitad una de las dos partes. Adem\u00e1s cruzar los coeficientes R1 y R2 de una soluci\u00f3n con los coeficientes R3 y R4 de otra soluci\u00f3n podr\u00eda no tener sentido. As\u00ed mismo, al realizarse la mutaci\u00f3n al nivel binario, podemos encontrar que la mataci\u00f3n de un bit produzca un salto enorme o diminuto en el valor de un coeficiente seg\u00fan el bit afectado."}, {"heading": "3.2.1 Covariance Matrix Adaptation Evolution Strategy (CMA-ES)", "text": "Para tratar de solventar las deficiencias encontradas en el algoritmo b\u00e1sico, se propone la implementaci\u00f3n de un algoritmo CMA-ES, que, aunque en sus inicios fue concebido como m\u00e9todo de b\u00fasqueda local [109] ofrece tambi\u00e9n un buen rendimiento y calidad en la soluci\u00f3n cuando es aplicado en la b\u00fasqueda sobre espacios reales cuando el paisaje de b\u00fasqueda es complejo o contiene gran cantidad de ruido [110, 111]. El algoritmo CMA-ES siglas de estrategia de evoluci\u00f3n des-aleatorizada (ES) con adaptaci\u00f3n de matriz de covarianza [90, 91, 92] es un m\u00e9todo de b\u00fasqueda que basa su heur\u00edstica en la sucesiva adaptaci\u00f3n de la matriz de covarianza completa de una distribuci\u00f3n normal (distribuci\u00f3n gaussiana) de mutaci\u00f3n (figura 11).\nEl esquema general del algoritmo est\u00e1 recogido en la figura 10. En \u00e9l puede verse como CMA-ES emplea una funci\u00f3n gaussiana para generar mu soluciones para luego utilizar lambda mejores candidatos para refinar la propia funci\u00f3n de distribuci\u00f3n en un proceso iterativo. El bucle principal del algoritmo (ecuaci\u00f3n 1) parte de una distribuci\u00f3n gaussiana se generan los pesos, afectados por la ra\u00edz cuadrada de covarianzas (\u221aC) que act\u00faa como matriz de transformaci\u00f3n sobre los datos (1.1).\nA continuaci\u00f3n, se utilizan esos pesos para perturbar a la nueve de puntos (1.2) y se eval\u00faan seg\u00fan su aptitud (1.3).\n(Ec1):\u2200i=1,\u2026,\u03bb: wi \u2190\u03c3 \u221aC Ni (0,1), 1.1\nyi \u2190y+wi, (L2) 1.2\npi \u2190F(yi), 1.3\nUna vez terminado el proceso de reajuste se procede a realizar la selecci\u00f3n (2.1) y el cruce (2.2) hasta alcanzar el tama\u00f1o apropiado indicado por lambda.\n(Ec2): \u2200i=1,\u2026,mu\nSel \u2190 Sel U Seleccionar (pi) 2.1\ny * \u2190 Recombinar (sel) 2.2\nC\u00f3digo Mathematica equivalente: OffspringPop = Table[ (* Pr\u00f3xima generaci\u00f3n *) ( offspring[[4]] = Table[ Random[norm], {n}]; offspring[[3]] = sigma*(SqrtCov.offspring[[4]]); (* Ec 1 .1 *) offspring[[2]] = yParent + offspring[[3]]; (* Ec 1 .2 *) offspring[[1]] = f[offspring[[2]]]; (* Ec 1 .3 *) offspring ), {lambda} ]; (* esta es la nueva pop de tama\u00f1o lambda *)\nPuede observarse como el vector obtenido en 1.1 conecta el Yparent de dos generaciones. Posteriormente se procede a auto-adaptar los valores de la propia b\u00fasqueda. La ecuaci\u00f3n 3, ajusta el vector de direcci\u00f3n de la b\u00fasqueda. Aqu\u00ed el termino (1-(1/tau)) es un t\u00e9rmino de memoria (cumulacion). Y decrece conforme a la convergencia.\n(Ec3): S- VECTOR DE DIRECCION\nPosteriormente, el vector de direcci\u00f3n calculado es usado para actualizar la matriz C (ecuaci\u00f3n 4). Como se ha dicho anteriormente tauC es una ponderaci\u00f3n de tiempo en funci\u00f3n de la generaci\u00f3n actual, como este va decreciendo el elipsoide va colapsando en cada generaci\u00f3n.\nC\u00f3digo Mathematica equivalente: ParentPop = Take[Sort[OffspringPop], mu]; (* tomar los padres *) Desc = Sum[ParentPop[[m]], {m, 1, mu}]/mu; (* el cruce *) (* Ec 2 *) yParent = Desc[[2]]; (* el nuevo centro masas *)\nC\u00f3digo Mathematica equivalente: s = (1-1/tau)*s + Sqrt[mu/tau*(2-1/tau)]*Desc[[3]]/sigma;(* Ec 3 *)\nC\u00f3digo Mathematica equivalente: sSigma = (1-1/tauSigma)*sSigma + Sqrt[mu/tauSigma*(2-1/tauSigma)] * Desc[[4]];(* Ec 5 *) sigma = sigma*Exp[(sSigma.sSigma - n)/(2*n*Sqrt[n])]; (* Ec 6 *)\nCap\u00edtulo 4."}, {"heading": "Experimentaci\u00f3n y an\u00e1lisis de los", "text": "resultados obtenidos.\nEn las secciones anteriores, hemos ahondado en la complejidad del problema de estimaci\u00f3n del par\u00e1metro de degradaci\u00f3n del hormig\u00f3n armado sujeto a esfuerzo cortante y repasado su expresi\u00f3n anal\u00edtica y las t\u00e9cnicas que se han utilizado tradicionalmente para su abordaje. As\u00ed mismo, hemos realizado una introducci\u00f3n a las t\u00e9cnicas de computaci\u00f3n evolutiva y descrito en detalle el funcionamiento del subgrupo de estas t\u00e9cnicas conocido como estrategias de evoluci\u00f3n. En el presente cap\u00edtulo, utilizaremos una de esas t\u00e9cnicas (descrita en el apartado anterior) para tratar de conseguir el mejor ajuste para el par\u00e1metro de una funci\u00f3n polin\u00f3mica de grado 3 que cumpla los requisitos impuestos por el problema. El problema a resolver puede entonces enunciarse como un problema de optimizaci\u00f3n donde deberemos encontrar los cuatro coeficientes para el polinomio interpolador del par\u00e1metro que consiguen un mejor ajuste. Un vector R candidato a soluci\u00f3n vendr\u00e1 por tanto formado por cuatro n\u00fameros reales {R1, R2, R3, R4} que representan los cuatro coeficientes del polinomio buscado.\nGr\u00e1fico 1. Evoluci\u00f3n del fitness para la implementaci\u00f3n b\u00e1sica de cma-es. Pueden observarse como aparecen reiteradas generaciones perdidas.\nEl algoritmo evolutivo utilizado ser\u00e1 una versi\u00f3n adaptada y mejorada de la utilizada por los autores en los papers de Beyer et al. de 2001 [29b] y HansGeorg Beyer de 2007.\n0\n0,05\n0,1\n0,15\n0,2\n0,25\n0,3\n0,35\n0,4\n1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1\n1 0\n1\n1 1\n1\n1 2\n1\n1 3\n1\n1 4\n1\n1 5\n1\n1 6\n1\n1 7\n1\n1 8\n1\n1 9\n1\n2 0\n1\n2 1\n1\n2 2\n1\n2 3\n1\n2 4\n1\nBest\nAl tratarse de un problema especialmente duro computacionalmente y ser muy costoso el c\u00e1lculo de la funci\u00f3n de aptitud, el algoritmo cma aparece como una buena opci\u00f3n por ser un algoritmo que no necesita de un gran n\u00famero de evaluaciones y que funciona relativamente bien con poblaciones peque\u00f1as.\nEn la gr\u00e1fica 1, sobre estas l\u00edneas se observan los valores de fitness obtenidos para la mejor de tres ejecuciones. En ella observamos como el valor de aptitud crece r\u00e1pidamente en las primeras generaciones pero se estanca despu\u00e9s de 100 generaciones oscilando alrededor del 22%. En la figura 7 est\u00e1n graficadas las mejores soluciones encontradas por el algoritmo durante la misma ejecuci\u00f3n para 100, 150 y 200 generaciones.\nSi restringimos la gr\u00e1fica eliminando valores imposibles (segmentos del primer cuadrante con pendiente ascendente) obtenemos el detalle de la figura 8.\nSin embargo los resultados no dejan de ser pobres y en el gr\u00e1fico 1, se aprecian varias ca\u00eddas bruscas que se corresponden con soluciones inv\u00e1lidas que aparecen incluso en estadios avanzados de la b\u00fasqueda. Asociamos dichos saltos a valores donde la funci\u00f3n fitness no est\u00e1 definida. Y es que para la funci\u00f3n de aptitud con la que trabajamos dos polinomios que est\u00e1n muy pr\u00f3ximos\npueden tener puntuaciones de aptitud Figure 13. Detalle de las funciones anteriores.\nradicalmente distintos ya un peque\u00f1o cambio en los coeficientes puede hacer que el sistema de ecuaciones no tenga soluci\u00f3n.\nPara esquivar estos problemas, se decide a\u00f1adir un valor de penalizaci\u00f3n, este valor (debe ser un n\u00famero muy grande en comparaci\u00f3n con el rango donde se mueve la funci\u00f3n de aptitud), har\u00e1 que se descarten las soluciones invalidas y que se minimice la posibilidad de que estas sean seleccionadas. Tambi\u00e9n se decide fijar el n\u00famero de padres considerados a dos ya que de esta forma, un descendiente ser\u00e1 combinaci\u00f3n lineal de los coeficientes de \u00fanicamente dos padres lo que deber\u00eda minimizar el riesgo de dar saltos bruscos.\nHechos estos cambios volvemos a ejecutar el algoritmo obtenido en este caso una gr\u00e1fica de fitness donde se observa un valor m\u00e1s estable y una tendencia m\u00e1s clara al alza (grafico 2), aunque los resultados siguen sin ser los esperados.\nGr\u00e1fico 2. Evoluci\u00f3n del fitness en la ejecuci\u00f3n de CMA-es con las modificaciones indicadas (versi\u00f3n 2).\nA la vista de la nueva grafica observamos que aparecen espor\u00e1dicamente, incluso en generaciones muy tempranas, soluciones medianamente buenas con valores de aptitud por encima del 25% (recordemos que el polinomio obtenido por LGA ten\u00eda un ajuste del 16,6%) que sin embargo parecen no heredarse a sus descendientes.\n0\n0,05\n0,1\n0,15\n0,2\n0,25\n0,3\n0,35\n0,4\n1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1\n1 0\n1\n1 1\n1\n1 2\n1\n1 3\n1\n1 4\n1\n1 5\n1\n1 6\n1\n1 7\n1\n1 8\n1\n1 9\n1\n2 0\n1\n2 1\n1\n2 2\n1\n2 3\n1\n2 4\n1 Best\nEsto nos mueve a replantear de nuevo el algoritmo y se decide probar una nueva modificaci\u00f3n del algoritmo base buscando producir un comportamiento elitista mediante la incorporaci\u00f3n de una memoria global de soluciones, que har\u00e1 las veces de archivo gen\u00e9tico regenerando con periodicidad semialeatoria la variabilidad gen\u00e9tica de la poblaci\u00f3n evitando la convergencia prematura y orientando la b\u00fasqueda hacia zonas que resultaron ser prometedoras. As\u00ed mismo, y para minimizar el n\u00famero de evaluaciones, se decide hacer variar lambda de manera que el tama\u00f1o de la descendencia se ajuste seg\u00fan sea la diferencia entre el m\u00e1ximo fitness y el fitness promedio. El mecanismo descrito, puede observarse en el fragmento de la salida de mensajes que se aprecia en la captura (figura 9). En ella vemos como la poblaci\u00f3n se retroalimenta en ciertas iteraciones de individuos que hab\u00edan quedado apartados durante un tiempo del flujo evolutivo. Para confirmar el correcto funcionamiento de la modificaci\u00f3n, se realizan una nueva serie de ejecuciones y graficamos de nuevo tomando la evoluci\u00f3n de la mejor aptitud para cada generaci\u00f3n. En la nueva grafica (grafico 3), observamos un crecimiento m\u00e1s suave y progresivo as\u00ed como una recuperaci\u00f3n m\u00e1s r\u00e1pida cuando el algoritmo avanza en una direcci\u00f3n err\u00f3nea.\nGr\u00e1fico 3. Evoluci\u00f3n del fitness en la ejecuci\u00f3n e algoritmo CMA-es con modificaciones referidas (versi\u00f3n 3)\nCon todo, los resultados son mejores en las nuevas pruebas pero no satisfacen las expectativas del experimento por lo que decidimos sustituir la funci\u00f3n buscada (hasta ahora ven\u00edamos trabajando con funciones polin\u00f3micas de\ngrado 3) por una funci\u00f3n de la forma \u03ba(\u03b51)=a/(1+b*(\u03b51)^c), ya que creemos que la forma de esta funci\u00f3n podr\u00eda ajustarse mejor a nuestros datos experimentales. Al realizar nuevamente la bater\u00eda de pruebas nos sorprende gratamente observar como mejoran sensiblemente la correspondencia obteniendo valores de aptitud en el entorno de 50-53%.\nLos datos obtenidos son bastante mejores que en la anterior ocasi\u00f3n con una convergencia clara que por encima de la generaci\u00f3n 150 (esta tendencia puede observarse en el grafico 4) e incluye ya hasta el tercer decimal. Parece que la nueva funci\u00f3n favorece la b\u00fasqueda disminuyendo la inter-dependencia al estar los par\u00e1metros del problema menos acoplados. Por otra parte, el mejor ajuste podr\u00eda favorecer el que el algoritmo pase m\u00e1s tiempo en el espacio de soluciones aceptables.\n0\n0,05\n0,1\n0,15\n0,2\n0,25\n0,3\n0,35\n0,4\n0,45\n0,5\n1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1\n1 0\n1\n1 1\n1\n1 2\n1\n1 3\n1\n1 4\n1\n1 5\n1\n1 6\n1\n1 7\n1\n1 8\n1\n1 9\n1\n2 0\n1\n2 1\n1\n2 2\n1\n2 3\n1\n2 4\n1\nBest\nGr\u00e1fico 4. Evoluci\u00f3n del fitness en la ejecuci\u00f3n de algoritmo CMA-es con modificaciones indicadas (versi\u00f3n 4)\nTomemos por ejemplo el caso de la funci\u00f3n polin\u00f3mica; En \u00e9l, el par\u00e1metro R1 se correspond\u00eda con el coeficiente del t\u00e9rmino de orden 3, as\u00ed, que una variaci\u00f3n en este coeficiente alteraba considerablemente el resultado, mientras, que un cambio similar en el coeficiente de orden 1 alterar\u00eda en peque\u00f1a medida el resultado.\n3) Mejores para generaci\u00f3n 25 (verde), 50 (gris), 75 (rojo), amarillo (100), rosa (150). A partir de ah\u00ed las gr\u00e1ficas se solapaban y es dif\u00edcil graficar. DER. Los cinco mejores resultados obtenidos. El mejor, representado en color azul verdoso (y=1,04901/1+52,3107*x^0,660418) obtuvo un 51% de ajuste.\nLa figura 12 muestra la evoluci\u00f3n del mejor candidato con un lapso de 25 generaciones. En ella puede observarse gr\u00e1ficamente c\u00f3mo evolucionan los par\u00e1metros de entrada para ajustar la funci\u00f3n (izquierda) y como se lleva a cabo el ajuste fino local (derecha). La convergencia ahora puede apreciarse claramente en la fase de ajuste local cuando el tama\u00f1o del paso tiende a hacerse muy peque\u00f1o.\n0\n0,1\n0,2\n0,3\n0,4\n0,5 0,6 1\n1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1\n1 0\n1\n1 1\n1\n1 2\n1\n1 3\n1\n1 4\n1\n1 5\n1\n1 6\n1\n1 7\n1\n1 8\n1\n1 9\n1\n2 0\n1\n2 1\n1\n2 2\n1\n2 3\n1\n2 4\n1\nnkappa\nBest\nCap\u00edtulo 5."}, {"heading": "Conclusiones y posibles trabajos", "text": "futuros.\nLos resultados obtenidos demuestran que las estrategias de evoluci\u00f3n pueden mejorar notablemente los resultados obtenidos mediante m\u00e9todos de regresi\u00f3n y tienen una aplicaci\u00f3n clara en problemas donde el paisaje de b\u00fasqueda no se conoce o es imposible de calcular.\nEn el problema en cuesti\u00f3n que nos ocupa son varios los inconvenientes con los que nos hemos encontrado y que hemos tenido que lidiar. El primero de ellos es la costosa evaluaci\u00f3n de candidatos y la imposibilidad de aproximar su aptitud mediante alguna directriz heur\u00edstica.\nLa representaci\u00f3n de los par\u00e1metros del problema, que en nuestro caso se correspond\u00edan con los coeficientes del polinomio interpolador promov\u00edan el solapamiento de las variables. De forma que, por ejemplo, un peque\u00f1o cambio en el coeficiente de orden 3 pod\u00eda alterar enormemente el resultado mientras que un cambio similar en el t\u00e9rmino independiente solo ocasionaba un cambio peque\u00f1o. Para mayor dificultad, encontramos que la funci\u00f3n de aptitud no estaba definida en todos los valores de forma que era enormemente dif\u00edcil para el algoritmo aprender acerca del espacio de soluciones y un camino evolutivo prometedor pod\u00eda acabar degenerando en soluciones inv\u00e1lidas.\nComo l\u00ednea de investigaci\u00f3n futura deber\u00eda proponerse una reformulaci\u00f3n de la representaci\u00f3n de los candidatos que permitiese una mayor libertad al m\u00e9todo gen\u00e9tico, a la vez que aprovechase mejor sus capacidades y limitase la degeneraci\u00f3n de la poblaci\u00f3n. Por ejemplo, podr\u00eda considerarse permitir al algoritmo elegir el tipo de funci\u00f3n interpoladora o incluso construir la suya propia a partir de bloques constructivos b\u00e1sicos.\nTambi\u00e9n, y debido a las capacidades impl\u00edcitas de paralelizaci\u00f3n de los AE en futuras ampliaciones podr\u00edan considerarse estrategias de evoluci\u00f3n en implementaci\u00f3n paralela para explotar al m\u00e1ximo las posibilidades de ejecuci\u00f3n concurrente en multi-cpu, complutaci\u00f3n GPU, o ejecuci\u00f3n en Grid dedicado de alto rendimiento.\nBibliograf\u00eda\n[1] MOSER, Martin; JOKANOVIC, Dusan P.; SHIRATORI, Norio. An algorithm for the\nmultidimensional multiple-choice knapsack problem. IEICE transactions on\nfundamentals of electronics, communications and computer sciences, 1997, vol. 80, no\n3, p. 582-589..\n[2] TAMIR, Arie. New pseudopolynomial complexity bounds for the bounded and other\ninteger Knapsack related problems. Operations Research Letters, 2009, vol. 37, no 5,\np. 303-306.\n[3 TAVAKKOLI-MOGHADDAM, Reza; RAHIMI-VAHED, Alireza; MIRZAEI, Ali Hossein.\nA hybrid multi-objective immune algorithm for a flow shop scheduling problem with bi-\nobjectives: weighted mean completion time and weighted mean tardiness. Information\nSciences, 2007, vol. 177, no 22, p. 5072-5090.\n[4] VEGA GARCIA, C., et al. Applying neural network technology to human-caused\nwildfire occurrence prediction. AI applications, 1996, vol. 10..\n[5] SUD, Avneesh, et al. Real-time path planning for virtual agents in dynamic\nenvironments. En ACM SIGGRAPH 2008 classes. ACM, 2008. p. 55.\n[6] SUD, Avneesh, et al. Real-time navigation of independent agents using adaptive\nroadmaps. En Proceedings of the 2007 ACM symposium on Virtual reality software and\ntechnology. ACM, 2007. p. 99-106..\n[7] STENTZ, Anthony. Optimal and efficient path planning for partially-known\nenvironments. En Robotics and Automation, 1994. Proceedings., 1994 IEEE\nInternational Conference on. IEEE, 1994. p. 3310-3317.\n[8] LI, Yi; GUPTA, Kamal. Motion planning of multiple agents in virtual environments\non parallel architectures. En Robotics and Automation, 2007 IEEE International\nConference on. IEEE, 2007. p. 1009-1014.\n[9] SANCHES, Carlos Alberto Alonso; SOMA, Nei Yoshihiro; YANASSE, Horacio\nHideki. An optimal and scalable parallelization of the< i> two-list</i> algorithm for the\nsubset-sum problem. European Journal of Operational Research, 2007, vol. 176, no 2,\np. 870-879.\n[10] PLAZA, Antonio; VALENCIA, David; PLAZA, Javier. An experimental comparison\nof parallel algorithms for hyperspectral analysis using heterogeneous and\nhomogeneous networks of workstations. Parallel Computing, 2008, vol. 34, no 2, p. 92-\n114..\n[11] FINK, Andreas; VO\u0392, Stefan. Generic metaheuristics application to industrial\nengineering problems. Computers & Industrial Engineering, 1999, vol. 37, no 1, p. 281-\n284.\n[12]GLOVER, Fred W.; KOCHENBERGER, Gary A. Handbook of metaheuristics\n(International series in operations research & management science). 2003.\n[21] FOGEL, David B. Artificial Intelligence Through Simulated Evolution. Wiley-IEEE\nPress, 1967. New York: Wiley Publishing\n[22] RECHENBERG, Ingo. Cybernetic solution path of an experimental problem. 1965.\n[23] RECHENBERG, Ingo, I.: Evolutionsstrategie : Optimierung technischer Systeme\nnach Prinzipien der biologischen Evolution. 15. Stuttgart-Bad Cannstatt : Frommann-\nHolzboog, 1973.\n[24] SCHWEFEL, H.P. Numerische Optimierunguon Computer-Modellenmittels der\nEzdutionsstrategie, 1977, Volume 26 of Interdisciplinary systems research. Basel\nBirkhauser.\n[25] HOLLAND, John H. Outline for a logical theory of adaptive systems. Journal of the\nACM (JACM), 1962, vol. 9, no 3, p. 297-314..\n[26] HOLLAND, John H. Adaptation in natural and artificial systems: An introductory\nanalysis with applications to biology, control, and artificial intelligence. U Michigan\nPress, 1975.\n[26b] JOHN, Holland. Holland, Adaptation in Natural and Artificial Systems: An\nIntroductory Analysis with Applications to Biology, Control and Artificial Intelligence.\n1992.\n[27] TURCK-CHI\u00c8ZE, Sylvaine, et al. The solar interior. Physics reports, 1993, vol.\n230, no 2, p. 57-235..\n[28] EIBEN, Agosten E.; SMITH, James E. Introduction to evolutionary computing.\nBerlin: Springer, 2010.\n[29] MICHALEWICZ, Zbigniew. Genetic algorithms+ data structures= evolution\nprograms. springer, 1996..\n[29b] BEYER, Hans-Georg. The theory of evolution strategies. Springer, 2001.\n[30] ZAFRA, Amelia; GIBAJA, Eva L.; VENTURA, Sebasti\u00e1n. Multiple instance learning\nwith multiple objective genetic programming for web mining.Applied Soft Computing,\n2011, vol. 11, no 1, p. 93-102\n[31] AKBARZADEH-T, M. R., et al. Soft computing paradigms for hybrid fuzzy\ncontrollers: experiments and applications. En Fuzzy Systems Proceedings, 1998. IEEE\nWorld Congress on Computational Intelligence., The 1998 IEEE International\nConference on. IEEE, 1998. p. 1200-1205..\n[32] QIN, Hao; YANG, Simon X. Adaptive neuro-fuzzy inference systems based\napproach to nonlinear noise cancellation for images. fuzzy sets and systems, 2007, vol.\n158, no 10, p. 1036-1063..\n[33] CHARBONNEAU, Paul. Genetic algorithms in astronomy and astrophysics.The Astrophysical Journal Supplement Series, 1995, vol. 101, p. 309.\n[34] TANG, Kit-Sang, et al. Genetic algorithms and their applications. Signal Processing Magazine, IEEE, 1996, vol. 13, no 6, p. 22-37.\n[35] KEANE, A. J. The design of a satellite beam with enhanced vibration performance using genetic algorithm techniques. The Journal of the Acoustical Society of America, 1996, vol. 99, no 4, p. 2599-2603..\n[36] ALTSHULER, Edward E.; LINDEN, Derek S. Wire-antenna designs using genetic algorithms. Antennas and Propagation Magazine, IEEE, 1997, vol. 39, no 2, p. 33-43..\n[37] HUGHES, Evan J.; LEYLAND, Maurice. Using multiple genetic algorithms to generate radar point-scatterer models. Evolutionary Computation, IEEE Transactions on, 2000, vol. 4, no 2, p. 147-163.\n[38] VASILE, Massimiliano. Hybrid behavioral-based multiobjective space trajectory optimization. En Multi-Objective Memetic Algorithms. Springer Berlin Heidelberg, 2009. p. 231-253.\n[39] METCALFE, Travis S.; CHARBONNEAU, Paul. Stellar structure modeling using a parallel genetic algorithm for objective global optimization. Journal of Computational Physics, 2003, vol. 185, no 1, p. 176-193.\n[40] GIRO, R., M. Cyrillo y D.S. Galv\u00e3o. Designing conducting polymers using genetic algorithms.Chemical Physics Letters, vol.366, no.1-2, p.170-175, 2002.\n[41] KROO, I. Aeronautical Applications of Evolutionary Design. VKI lecture series on Optimization Methods & Tools for Multicriteria/Multidisciplinary Design, 2004.\n[42] HANSEN, Nikolaus; OSTERMEIER, Andreas. Adapting arbitrary normal mutation distributions in evolution strategies: The covariance matrix adaptation. En Evolutionary Computation, 1996., Proceedings of IEEE International Conference on. IEEE, 1996. p. 312-317..\n[43] HANSEN, Nikolaus; M\u00dcLLER, Sibylle D.; KOUMOUTSAKOS, Petros. Reducing the time complexity of the derandomized evolution strategy with covariance matrix adaptation (CMA-ES). Evolutionary Computation, 2003, vol. 11, no 1, p. 1-18.\n[44] OYAMA, Akira; LIOU, Meng-Sing; OBAYASHI, Shigeru. Transonic axial-flow blade shape optimization using evolutionary algorithm and three-dimensional Navier-Stokes solver. En 9th AIAA/ISSMO Symposium and Exhibit on Multidisciplinary Analysis and Optimization, Atlanta, GA. 2002. [45] LIAN, Yongsheng; OYAMA, Akira; LIOU, Meng-Sing. Progress in design optimization using evolutionary algorithms for aerodynamic problems.Progress in Aerospace Sciences, 2010, vol. 46, no 5, p. 199-223. [46] LIAN, Yongsheng; LIOU, Meng-Sing. Multiobjective Optimization Using Coupled Response Surface Model and Evolutionary Algorithm. AIAA journal, 2005, vol. 43, no 6, p. 1316-1325. [47] LIAN, Yongsheng; LIOU, Meng-Sing; OYAMA, Akira. An enhanced evolutionary algorithm with a surrogate model. En Proceedings of genetic and evolutionary computation conference, Seattle, WA. 2004. [48] HWATAL, Andreas M.; RAIDL, G\u00fcnther R. Determining orbital elements of extrasolar planets by evolution strategies. En Computer Aided Systems Theory\u2013 EUROCAST 2007. Springer Berlin Heidelberg, 2007. p. 870-877.\n[49] PENIAK, Martin; MAROCCO, Davide; CANGELOSI, Angelo. Autonomous robot exploration of unknown terrain: A preliminary model of mars rover robot. En Proceedings of 10th ESA Workshop on Advanced Space Technologies for Robotics and Automation. 2008.\n[50] OYAMA, Akira; LIOU, Meng-Sing. Multiobjective optimization of rocket engine pumps using evolutionary algorithm. Journal of Propulsion and Power, 2002, vol. 18, no 3, p. 528-535.\n[51] SCH\u00dcTZE, Oliver, et al. Designing optimal low-thrust gravity-assist trajectories using space pruning and a multi-objective approach.Engineering Optimization, 2009, vol. 41, no 2, p. 155-181.\n[52] KANG, Shin-Jin; KIM, YongO; KIM, Chang-Hun. Live path: adaptive agent navigation in the interactive virtual world. The Visual Computer, 2010, vol. 26, no 6-8, p. 467-476.\n[53] GOSSELIN, Louis; TYE-GINGRAS, Maxime; MATHIEU-POTVIN, Fran\u00e7ois. Review of utilization of genetic algorithms in heat transfer problems.International Journal of Heat and Mass Transfer, 2009, vol. 52, no 9, p. 2169-2188.\n[54] COELLO, CA Coello; CHRISTIANSEN, Alan D.; HERN\u00c1NDEZ, F. Santos. A simple genetic algorithm for the design of reinforced concrete beams.Engineering with Computers, 1997, vol. 13, no 4, p. 185-196.\n[54b] COELLO, Carlos Coello; HERN\u00c1NDEZ, Filiberto Santos; FARRERA, Francisco Alonso. Optimal design of reinforced concrete beams using genetic algorithms. Expert systems with Applications, 1997, vol. 12, no 1, p. 101-108.\n[55] RAFIQ, Mohammad Y.; SOUTHCOMBE, Colin. Genetic algorithms in optimal design and detailing of reinforced concrete biaxial columns supported by a declarative approach for capacity checking. Computers&structures, 1998, vol. 69, no 4, p. 443- 457.\n[56] MARROQU\u00cdN, Jos\u00e9 Luis; BOTELLO RIONDA, Salvador; O\u00d1ATE, Eugenio. Un modelo de optimizaci\u00f3n estoc\u00e1stica aplicado a la optimizaci\u00f3n de estructuras de barras prism\u00e1ticas. Revista internacional de m\u00e9todos num\u00e9ricos para c\u00e1lculo y dise\u00f1o en ingenier\u00eda, 1999, vol. 15, no 4, p. 425-434.\n[57] KOUMOUSIS, Vlasis K.; ARSENIS, S. J. Genetic algorithms in optimal detailed design of reinforced concrete members. Computer Aided Civil and Infrastructure Engineering, 1998, vol. 13, no 1, p. 43-52.\n[57b] GOVINDARAJ, V.; RAMASAMY, J. V. Optimum detailed design of reinforced concrete continuous beams using genetic algorithms. Computers & structures, 2005, vol. 84, no 1, p. 34-48.\n[58] CHAU, K. W.; ALBERMANI, F. Knowledge-based system on optimum design of liquid retaining structures with genetic algorithms. Journal of structural engineering, 2003, vol. 129, no 10, p. 1312-1321.\n[59] LEP\u0160, Mat\u011bj; \u0160EJNOHA, Michal. New approach to optimization of reinforced concrete beams. Computers & structures, 2003, vol. 81, no 18, p. 1957-1966.\n[60] LEE, C.; AHN, J. Flexural design of reinforced concrete frames by genetic algorithm. Journal of structural engineering, 2003, vol. 129, no 6, p. 762-774.\n[61] FAIRBAIRN, Eduardo MR, et al. Optimization of mass concrete construction using genetic algorithms. Computers & structures, 2004, vol. 82, no 2, p. 281-299.\n[62] LIM, Chul-Hyun; YOON, Young-Soo; KIM, Joong-Hoon. Genetic algorithm in mix proportioning of high-performance concrete. Cement and Concrete Research, 2004, vol. 34, no 3, p. 409-420.\n[63] AMIRJANOV, Adil; SOBOLEV, Konstantin. Optimal proportioning of concrete aggregates using a self-adaptive genetic algorithm. Computers and Concrete, 2005, vol. 2, no 5, p. 411-421.\n[64] QIN, A. Kai; SUGANTHAN, Ponnuthurai N. Self-adaptive differential evolution algorithm for numerical optimization. En Evolutionary Computation, 2005. The 2005 IEEE Congress on. IEEE, 2005. p. 1785-1791.\n[65] GERO, M\u00aa Bel\u00e9n Prendes, et al. APLICACI\u00d3N DE UN ALGORITMO GEN\u00c9TICO ELITISTA EN LA OPTIMIZACI\u00d3N DE EDIFICIOS MET\u00c1LICOS..\n[66] DEKA, Dhyanjyoti. Crystal plasticity modeling of deformation and creep in polycrystalline, Metallurgical and Materials Transactions A, 2006, vol. 37, no 5, p. 1371-1388.\n[67] NEHDI M, El Chabib H, Said A. Genetic algorithm model for shear capacity of RC beams reinforced with externally bonded FRP. Materials and Structures 44:1249\u2013 1258, 2011\n[68] NEHDI M, El Chabib H, Said A. Proposed shear design equations for FRPreinforced concrete beams based on genetic algorithms approach. ASCE J Mater CivEng 19:1033\u20131042, 2007.\n[69] BONISSONE, Piero P. Soft computing: the convergence of emerging reasoning technologies. Soft computing, 1997, vol. 1, no 1, p. 6-18.\n[70] KECMAN, Vojislav. Learning and soft computing: support vector machines, neural networks, and fuzzy logic models. MIT press, 2001.\n[71] MITRA, Sushmita; PAL, Sankar K.; MITRA, Pabitra. Data mining in soft computing framework: A survey. IEEE transactions on neural networks, 2002, vol. 13, no 1, p. 3- 14.\n[72] SANCHEZ, Elie; SHIBATA, Takanori; ZADEH, Lotfi Asker (ed.). Genetic algorithms and fuzzy logic systems: Soft computing perspectives. World Scientific, 1997.\n[73] GONZ\u00c1LEZ, Javier Serrano, et al. Optimization of wind farm turbines layout using an evolutive algorithm. Renewable Energy, 2010, vol. 35, no 8, p. 1671-1681.\n[74] MAULIK, Ujjwal; BANDYOPADHYAY, Sanghamitra. Genetic algorithm-based clustering technique. Pattern recognition, 2000, vol. 33, no 9, p. 1455-1465.\n[75] DEMIRIZ, Ayhan; BENNETT, Kristin P.; EMBRECHTS, Mark J. Semi-supervised clustering using genetic algorithms. Artificial neural networks in engineering (ANNIE99), 1999, p. 809-814.\n[76] ONG, Yew-Soon; NAIR, Prasanth B.; LUM, Kai Yew. Max-min surrogate-assisted evolutionary algorithm for robust design. Evolutionary Computation, IEEE Transactions on, 2006, vol. 10, no 4, p. 392-404.\n[77] GUTI\u00c9RREZ, Jos\u00e9 A. Garc\u00eda; COTTA, Carlos; LEIVA, Antonio J. Fern\u00e1ndez. Design of emergent and adaptive virtual players in a war RTS game. Foundations on Natural and Artificial Computation. Springer Berlin Heidelberg, 2011. p. 372-382.\n[78] FLOREANO, Dario; MONDADA, Francesco. Evolution of homing navigation in a real mobile robot. Systems, Man, and Cybernetics, Part B: Cybernetics, IEEE Transactions on, 1996, vol. 26, no 3, p. 396-407.\n[79] JANG, Jyh-Shing Roger; SUN, Chuen-Tsai; MIZUTANI, Eiji. Neuro-fuzzy and soft computing-a computational approach to learning and machine intelligence [Book Review]. Automatic Control, IEEE Transactions on, 1997, vol. 42, no 10, p. 1482-1484.\n[80] JANG, Jyh-Shing Roger; SUN, Chuen-Tsai; MIZUTANI, Eiji. Neuro-fuzzy and soft computing-a computational approach to learning and machine intelligence [Book Review]. Automatic Control, IEEE Transactions on, 1997, vol. 42, no 10, p. 1482-1484.\n[81] AKBARZADEH-T, M.-R., et al. Soft computing for autonomous robotic systems. Computers & Electrical Engineering, 2000, vol. 26, no 1, p. 5-32\n[82] ZADEH, Lotfi A. Some reflections on soft computing, granular computing and their roles in the conception, design and utilization of information/intelligent systems. Soft Computing-A fusion of foundations, methodologies and applications, 1998, vol. 2, no 1, p. 23-25.\n[83] DASGUPTA, Dipankar; JI, Zhou; GONZALEZ, Fabio. Artificial immune system (AIS) research in the last five years. En Evolutionary Computation, 2003. CEC'03. The 2003 Congress on. IEEE, 2003. p. 123-130.\n[84] ZHANG, Zheng, et al. A greedy algorithm for aligning DNA sequences.Journal of Computational biology, 2000, vol. 7, no 1-2, p. 203-214.\n[85] WOLSEY, Laurence A. An analysis of the greedy algorithm for the submodular set covering problem. Combinatorica, 1982, vol. 2, no 4, p. 385-393.\n[86] QUINTERO, Luis Vicente Santana. Un Algoritmo Basado en Evoluci\u00f3n Diferencial para Resolver Problemas Multiobjetivo. 2004. Tesis Doctoral. Tesis de Maestr\u00eda CINVESTAV-IPN.\n[87] RICE, Kenneth V.; STORN, Rainer M.; LAMPINEN, Jouni A. Differential evolution a practical approach to global optimization. 2005.\n[88] SUN, Jianyong; ZHANG, Qingfu; TSANG, Edward PK. DE/EDA: A new evolutionary algorithm for global optimization. Information Sciences, 2005, vol. 169, no 3, p. 249-262.\n[89] QIN, A. Kai; SUGANTHAN, Ponnuthurai N. Self-adaptive differential evolution algorithm for numerical optimization. En Evolutionary Computation, 2005. The 2005 IEEE Congress on. IEEE, 2005. p. 1785-1791.\n[90] HANSEN, Nikolaus; KERN, Stefan. Evaluating the CMA evolution strategy on multimodal test functions. En Parallel Problem Solving from Nature-PPSN VIII. Springer Berlin Heidelberg, 2004. p. 282-291.\n[91] ROS, Raymond; HANSEN, Nikolaus. A simple modification in CMA-ES achieving linear time and space complexity. En Parallel Problem Solving from Nature\u2013PPSN X. Springer Berlin Heidelberg, 2008. p. 296-305.\n[92] AUGER, Anne; HANSEN, Nikolaus. A restart CMA evolution strategy with increasing population size. En Evolutionary Computation, 2005. The 2005 IEEE Congress on. IEEE, 2005. p. 1769-1776.\n[93] SAVIC, Dragan A.; WALTERS, Godfrey A. Genetic algorithms for least-cost design of water distribution networks. Journal of Water Resources Planning and Management, 1997, vol. 123, no 2, p. 67-77.\n[94] BAKIRTZIS, Anastasios G., et al. Optimal power flow by enhanced genetic algorithm. Power Systems, IEEE Transactions on, 2002, vol. 17, no 2, p. 229-236.\n[95] DA SILVA, Edson Luiz; GIL, Hugo Alejandro; AREIZA, Jorge Mauricio. Transmission network expansion planning under an improved genetic algorithm. En Power Industry Computer Applications, 1999. PICA'99. Proceedings of the 21st 1999 IEEE International Conference. IEEE, 1999. p. 315-321.\n[96] DASGUPTA, Dipankar. Computational Intelligence in Cyber Security. EnComputational Intelligence for Homeland Security and Personal Safety, Proceedings of the 2006 IEEE International Conference on. IEEE, 2006. p. 2-3.\n[97] VLAHOPOULOS, N.; HART, C. G. A Multidisciplinary design optimization approach to relating affordability and performance in a conceptual submarine design. Journal of Ship Production and Design, 2010, vol. 26, no 4, p. 273-289.\n[98] DE JONG, Kenneth A. Evolutionary computation: a unified approach. Cambridge: MIT press, 2006\n[99] SIVAKUMAR, Raghupathy; SINHA, Prasun; BHARGHAVAN, Vaduvur. CEDAR: a core-extraction distributed ad hoc routing algorithm. Selected Areas in Communications, IEEE Journal on, 1999, vol. 17, no 8, p. 1454-1465.\n[100] SHEN, Chien-Chung; JAIKAEO, Chaiporn. Ad hoc multicast routing algorithm with swarm intelligence. Mobile Networks and Applications, 2005, vol. 10, no 1-2, p. 47- 59.\n[101] HERN\u00c1NDEZ-D\u00cdAZ, A. M. Revisi\u00f3n de las teor\u00edas de campo de compresiones en hormig\u00f3n estructural. 2013.\n[102] DE JONG, Kenneth A. Evolutionary computation: a unified approach. Cambridge: MIT press, 2006.\n[103] EBELING, Werner. Applications of evolutionary strategies. Systems Analysis Modelling Simulation, 1990, vol. 7, no 1, p. 3-16.\n[104] COLLINS, Michael P.; MITCHELL, Denis. Prestressed concrete structures. Englewood Cliffs: Prentice Hall, 1991.\n[105] HERN\u00c1NDEZ-D\u00cdAZ A M; GARC\u00cdA-ROM\u00c1N, M.D; Gil-Mart\u00edn L.M.; Hern\u00e1ndezMontes. Why is not always solvable the shear model for reinforced concrete beams proposed by the Compression Field Theories, 2012.\n[106] REINECK, K.; Kuchma, D.; Fitik, B., Formelsammlumg f\u00fcr die Datenerhebungs dateil Stahlbetonbalken mit B\u00fcgel, 2011.\n[107] HERN\u00c1NDEZ-D\u00cdAZ, A.M; GARC\u00cdA-ROM\u00c1N, M.D. Introducing a Degradation Parameter in the Shear Design of Reinforced Concrete Beams, 2013.\n[108] COLEY, David A. An introduction to genetic algorithms for scientists and engineers. World Scientific, 1999.\n[109] HANSEN, Nikolaus; OSTERMEIER, Andreas. Adapting arbitrary normal mutation distributions in evolution strategies: The covariance matrix adaptation. En Evolutionary Computation, 1996., Proceedings of IEEE International Conference on. IEEE, 1996. p. 312-317.\n[110] M\u00dcLLER, Sibylle D.; HANSEN, Nikolaus; KOUMOUTSAKOS, Petros. Increasing the serial and the parallel performance of the CMA-evolution strategy with large populations. En Parallel Problem Solving from Nature\u2014PPSN VII. Springer Berlin Heidelberg, 2002. p. 422-431.\n[111] JASTREBSKI, Grahame A.; ARNOLD, Dirk V. Improving evolution strategies through active covariance matrix adaptation. En Evolutionary Computation, 2006. CEC 2006. IEEE Congress on. IEEE, 2006. p. 2814-2821.\nAnexo I."}, {"heading": "C\u00f3digo fuente de los algoritmos", "text": "implementados.\n(* ::Package:: *)\n(* basado en los ejemplos de codigo del paper de Beyer et al. at 2001 y Hans-Georg Beyer de 2007 *)\n(* ************************************************************************* *)\n(* ENTRADA & SALIDA *)\n(* ************************************************************************* *)\nmessages=OpenWrite[path<>\"messages.txt\"];\ninputdata=path<>\"DataBase_Kuchma_et_al_nonprestressed_mathematica.xls\";\nvalidhyp=path<>\"Critical_Outlet_kappa_refined.xls\";\ninitpop=path<>\"initial_population.csv\";\nthetaseeds=path<>\"Strut-angle_seeds.xls\";\noutputxls=path<>\"Salida.csv\"; outputpng=path<>\"Salida.png\";\n(* ************************************************************************* *)\n(* PARAMETROS PROBLEMA *)\n(* ************************************************************************* *)\nepsilon1seeds=3; (* Number of equispaced seeds for epsilon1 to try *)\nspecimens={\"NHW-3b\",\"A50\",\"A75\",\"C50\",\"C75\",\"S1-4\",\"S2-3\",\"S4-6\",\"ET3\",\"P20\",\"T-22\",\"S8 A\",\"H 50/4\",\"H 75/4\",\"H 100/4\",\"RC 30 A1\",\"RC 30 A2\",\"RC 60 B1\",\"MHB 2.5- 25\",\"T3\",\"T4\",\"T6\",\"T7\",\"T8\",\"T9\",\"T13\",\"T15\",\"T17\",\"T19\",\"T20\",\"T26\",\"T32\",\"T34\",\"T35\",\"T37\",\"T38\"};\npenal=10^5;\n(* ************************************************************************* *)\n(* Parametros de estrategia *)\n(* ************************************************************************* *)\nmu = 4; (* n\u00famero de padres considerados *)\nmaxlambda = 32; (* tama\\[NTilde]o de la descendencia *)\nminlambda = 12; (* tama\\[NTilde]o de la descendencia *)\nyInit = Table[2, {3}]; (* vector inicial *)\nsigmaInit = 0.2; (* initial global mutation strength sigma *)\nsigmaMin = 10^-8; (* Criterio de parada sigma < sigmaMin *)\n(* ************************************************************************* *)\n(* Inicializaci\u00f3n de la distribuci\u00f3n de arranque *)\n(* ************************************************************************* *)\nnorm = NormalDistribution[0, 1]; (* inicializamos distribucion normal *)\nn = Dimensions[yInit][[1]]; (* dimensiones del espacio de busqueda *)\ntau = Sqrt[n]; tauC = n^2; tauSigma = Sqrt[n];\nCov = IdentityMatrix[n]; (* matriz covarianzas inicialmente igual a identidad *)\nsigma = sigmaInit;\ns = Table[0, {n}];\nsSigma = Table[0, {n}];\n(* Inicializacion Memoria *)\nIndividual = {f[yInit], yInit, yInit, yInit};\nParentPop = Table[Individual, {mu}];\nyParent = yInit; (* centroide inicial *)\noffspring = {{}, {}, {}, {}}; (* reservamos mem para la pob *)\nelite = {{}, {}, {}, {}}; (* reservamos mem para la pob *)\n(* Definicion de Funciones *)\nftest[x_] := Module[ {n}, n = Dimensions[x][[1]];\nSum[ i*x[[i]]^3, {i, 1, n}] ]\nf[R_]:=Module[{i,j,T,fit,Es,EqSystem,suma,\\[Alpha],\\[Alpha]1,\\[Alpha]2,\\[Alpha]t,z,bw,Asx1,Asx2,Ast,s,fy x1,fyx2,fyt,fc,\\[Epsilon]c,fctm,\\[Epsilon]ctm,Acx1,Acx2,Act,Ec,V,\\[Sigma]stexp,sol,\\[Kappa]limx1,\\[Kappa ]limx2,\\[Kappa]limt,\\[Kappa]lim2x1,\\[Kappa]lim2x2,\\[Kappa]lim2t,\\[Kappa]lim1,\\[Kappa]lim2,epsilonx,e psilont,\\[Epsilon]yx1,\\[Epsilon]yx2,\\[Epsilon]yt,check,hypx1,hypx2,hypt,emaxx1,emaxx2,emaxt,solx1,sol x2,solt,iter,y0,x0,x1,x2,a,b,c,d,H,spec,line,hyp,h,diff,specdiff,seedvector,S,lineseed,Sol},\nIf [R[[1]]==Null, return penal];If [R[[2]]==Null, return penal]; (* casos imposibles *)\nIf [R[[3]]==Null, return penal]; (* casos imposibles *)\na=Coef[R[[1]]];\nb=Coef[R[[2]]];\nc=Coef[R[[3]]];\nd=Coef[R[[4]]];\nPrint[\"Polinomio candidato \",a,\"/(1+\",b,\"*\\[Epsilon]1^\",c,\")\"];\nT=Import[inputdata];\nEs=200000;\n(* PARA CADA ESPECIMEN *)\nFor[spec=1,spec<=Length[specimens],spec++,\nline=0;\nFor[i=1,i<=Length[T[[1]]] && line==0, i++,\nIf[T[[1,i,1]]==specimens[[spec]],line=i];\n];\nIf[line==0 ,\nWrite[messages,\"Specimen \"<>ToString[specimens[[spec]]]<>\" is not in DataBase. Check if\n'path' for DataBase file is right.\"];\nExit[];\n];\n\\[Alpha]=T[[1,line,7]];\n\\[Alpha]1=T[[1,line,4]];\n\\[Alpha]2=T[[1,line,5]];\n\\[Alpha]t=T[[1,line,6]];\nz=T[[1,line,8]];\nbw=T[[1,line,9]];\nAsx1=T[[1,line,10]];\nAsx2=T[[1,line,11]];\nAst=T[[1,line,12]];\ns=T[[1,line,13]];\nfyx1=T[[1,line,14]];\nfyx2=T[[1,line,15]];\nfyt=T[[1,line,16]];\nfc=T[[1,line,17]];\nEc=8500Power[fc+8, (3)^-1];\n\\[Epsilon]c=T[[1,line,18]];\nfctm=T[[1,line,19]];\n\\[Epsilon]ctm=fctm/Ec;\nAcx1=T[[1,line,20]];\nAcx2=T[[1,line,21]];\nAct=T[[1,line,22]];\nEs=200000;\nV=T[[1,line,23]];\n\\[Epsilon]yx1= fyx1/Es;\n\\[Epsilon]yx2=fyx2/Es;\n\\[Epsilon]yt=fyt/Es;\n(* ESTE ES EL VALOR EXPERIMENTAL *)\n\\[Sigma]stexp=T[[1,line,2]];\n(* Limits to 'Degradation Parameter' for each type of reinforcement *)\n(* valores de frontera *)\n\\[Kappa]limx1=Asx1*fyx1/(\\[Alpha]1*Acx1*fctm);\nIf[\\[Alpha]2!=0,\\[Kappa]limx2=Asx2*fyx2/(\\[Alpha]2*Acx2*fctm)];\n\\[Kappa]limt=Ast*fyt/(\\[Alpha]t*Act*fctm);\n\\[Kappa]lim1=Min[\\[Kappa]limt,If[\\[Alpha]2!=0,Min[\\[Kappa]limx1,\\[Kappa]limx2],\\[Kappa]limx\n1]];\n\\[Kappa]lim2x1=\\[Kappa]limx1*(4500*\\[Epsilon]yx1+(1+1500*\\[Epsilon]yx1)^(3/2)-\n1)/(6750*\\[Epsilon]yx1);\nIf[\\[Alpha]2!=0,\\[Kappa]lim2x2=\\[Kappa]limx2*(4500*\\[Epsilon]yx2+(1+1500*\\[Epsilon]yx2)^(3\n/2)-1)/(6750*\\[Epsilon]yx2)];\n\\[Kappa]lim2t=\\[Kappa]limt*(4500*\\[Epsilon]yt+(1+1500*\\[Epsilon]yt)^(3/2)-\n1)/(6750*\\[Epsilon]yt);\n\\[Kappa]lim2=Min[\\[Kappa]lim2t,If[\\[Alpha]2!=0,Min[\\[Kappa]lim2x1,\\[Kappa]lim2x2],\\[Kappa]l\nim2x1]];\n(* Valores iniciales para el par\u00e1metro theta para el newton-rap *)\nS=Import[thetaseeds];\nFor[i=1,i<=Length[S[[1]]] && lineseed==0, i++,\nIf[S[[1,i,1]]==specimens[[spec]],\nlineseed=i;\nseedvector={};\n];\n];\nIf[lineseed==0 ,\nWrite[messages,\"Specimen \"<>ToString[specimens[[spec]]]<>\" has no theta seeds. Check if\n'path' for theta seeds file is right.\"];\nseedvector={30 Degree,30 Degree,30 Degree,30 Degree,30 Degree}; (* caso default *)\n];\n(* Hip\u00f3tesis v\u00e1lidas para cada esp\u00e9cimen. Al menos una de ellas es cierta *)\nH=Import[validhyp];\nline=0;\nFor[i=1,i<=Length[H[[1]]] && line==0, i++,\nIf[H[[1,i,1]]==specimens[[spec]],line=i];\n];\nIf[line==0 ,\nWrite[messages,\"Specimen \"<>specimens[[spec]]<>\" has no valid behaviour\nhypotheses. Check if 'path' for hypotheses file is right.\"];\nExit[];\n];\nhyp={};\nFor[h=0,h<=4,h++,\nIf[H[[1,line,2+9*h]]!=\"\" && H[[1,line,2+9*h]]!=\"Null\",\nhyp=Append[hyp,Table[StringTake[H[[1,line,2+9*h]],{k}],{k,1,3}]];\nIf[lineseed!=0,seedvector=Append[seedvector,S[[1,lineseed,2+h]]]];\n];\n];\ndiff={};\nFor[i=1,i<=Length[hyp],i++,\nj=1;\nspecdiff={};\nWhile[j<=epsilon1seeds, (*** Search for solutions with several seeds for epsilon1 ***)\nClear[\\[Sigma]1,\\[Sigma]2,\\[Sigma]sx1,\\[Sigma]sx2,\\[Sigma]st,\\[Epsilon]1,\\[Epsilon]2,\\[Epsilon]x\n,\\[Epsilon]t,\\[Theta],f2max,\\[Kappa]];\n(* sustituciones de variables *)\n\\[Sigma]1=\\[Alpha]*fctm/(1+Sqrt[500*\\[Epsilon]1]);\n\\[Sigma]2=(Tan[\\[Theta]]+1/Tan[\\[Theta]])*V/(z*bw)-\\[Sigma]1;\nf2max=Min[fc,fc/(0.8+170*\\[Epsilon]1)];\n\\[Epsilon]2=\\[Epsilon]c*(1-Sqrt[1-\\[Sigma]2/f2max]);\n\\[Epsilon]t=(\\[Epsilon]2*Tan[\\[Theta]]^2+\\[Epsilon]1)/(Tan[\\[Theta]]^2+1);\n\\[Epsilon]x=\\[Epsilon]1+\\[Epsilon]2-\\[Epsilon]t;\n\\[Kappa]=a/(1+b*(\\[Epsilon]1)^c);\n\\[Sigma]sx1=If[hyp[[i,1]]==\"E\",Es*\\[Epsilon]x,fyx1-\n\\[Kappa]*(Acx1/Asx1)*\\[Alpha]1*fctm/(1+Sqrt[500*\\[Epsilon]x])];\n\\[Sigma]sx2=If[\\[Alpha]2==0,0,If[hyp[[i,2]]==\"E\",Es*\\[Epsilon]x,fyx2-\n\\[Kappa]*(Acx2/Asx2)*\\[Alpha]2*fctm/(1+Sqrt[500*\\[Epsilon]x])]];\n\\[Sigma]st=If[hyp[[i,3]]==\"E\",Es*\\[Epsilon]t,fyt-\n\\[Kappa]*(Act/Ast)*\\[Alpha]t*fctm/(1+Sqrt[500*\\[Epsilon]t])];\n(* soluciona el sistema mediante N-R *)\nEq1[\\[Epsilon]1_,\\[Theta]_]:=Evaluate[Asx1*\\[Sigma]sx1+Asx2*\\[Sigma]sx2-\nV/Tan[\\[Theta]]+\\[Sigma]1*bw*z];\nEq2[\\[Epsilon]1_,\\[Theta]_]:=Evaluate[\\[Sigma]st*Ast-\n(\\[Sigma]2*Sin[\\[Theta]]^2-\\[Sigma]1*Cos[\\[Theta]]^2)*bw*s];\nQuiet[Sol=Check[FindRoot[{Eq1[\\[Epsilon]1,\\[Theta]],Eq2[\\[Epsilon]1,\\[Theta]]},{\\[Epsil\non]1,\\[Epsilon]ctm+(Min[\\[Epsilon]yx1,\\[Epsilon]yx2]+\\[Epsilon]yt-\\[Epsilon]ctm)*(j1)/(epsilon1seeds-1)},{\\[Theta],seedvector[[i]]}, MaxIterations->10000],0]];\n(* hay soluci\u00f3n pero est\u00e1 fuera de rango *)\nIf[Length[Sol]!=0,\n\\[Epsilon]1=\\[Epsilon]1/.Sol[[1]];\n(* POLINOMIO INTERPOLADOR para el valor k *)\n\\[Kappa]=a/(1+b*(\\[Epsilon]1)^c);\nIf[\\[Epsilon]1<\\[Epsilon]ctm || \\[Kappa]>\\[Kappa]lim2,\n(* Print[specimens[[spec]],\" - \",hyp[[i]],\" ->\nSoluci\\[OAcute]n fuera de rango \\[Epsilon]1=\" ,\\[Epsilon]1,\" < \\[Epsilon]ctm=\", \\[Epsilon]ctm,\" \\[Theta]=\",\\[Theta]/.Sol[[2]],\" \\[Kappa]=\", a*(\\[Epsilon]1*1000)^3+b*(\\[Epsilon]1*1000)^2+c*\\[Epsilon]1*1000+d ]; *)\nSol=0; (* Descarto solucion *)\n];\n];\n(* hay solucion. eq1 y eq2 se interceptan *)\nIf[Length[Sol]!=0,\n(*Print [Sol];*)\n(* deshacer el cambio de variables *)\n\\[Theta]=\\[Theta]/.Sol[[2]];\n\\[Sigma]1=\\[Alpha]*fctm/(1+Sqrt[500*\\[Epsilon]1]);\n\\[Sigma]2=(Tan[\\[Theta]]+1/Tan[\\[Theta]])*V/(z*bw)-\\[Sigma]1;\nf2max=Min[fc,fc/(0.8+170*\\[Epsilon]1)];\n\\[Epsilon]2=\\[Epsilon]c*(1-Sqrt[1-\\[Sigma]2/f2max]);\n\\[Epsilon]t=(\\[Epsilon]2*Tan[\\[Theta]]^2+\\[Epsilon]1)/(Tan[\\[Theta]]^2+1); (* la\nsolucion contradice la hipotesis inicial?. *)\n\\[Epsilon]x=\\[Epsilon]1+\\[Epsilon]2-\\[Epsilon]t;(* la solucion\ncontradice la hipotesis inicial?. *)\n(* ESTE ES EL VALOR TEORICO *)\n\\[Sigma]st=If[hyp[[i,3]]==\"E\",Es*\\[Epsilon]t,fyt-\n\\[Kappa]*(Act/Ast)*\\[Alpha]t*fctm/(1+Sqrt[500*\\[Epsilon]t])];\nsolx1=FindRoot[Es*(\\[Epsilon]yx1-x)==\n\\[Kappa]*(Acx1/Asx1)*\\[Alpha]1*fctm/(1+Sqrt[500*x]),{x,\\[Epsilon]yx1}];\nemaxx1=x/.solx1[[1]];\nIf[\\[Alpha]2!=0,\nsolx2=FindRoot[Es*(\\[Epsilon]yx2-x)==\n\\[Kappa]*(Acx2/Asx2)*\\[Alpha]2*fctm/(1+Sqrt[500*x]),{x,\\[Epsilon]yx2}];\nemaxx2=x/.solx2[[1]];\n];\nsolt=FindRoot[Es*(\\[Epsilon]yt-x)==\n\\[Kappa]*(Act/Ast)*\\[Alpha]t*fctm/(1+Sqrt[500*x]),{x,\\[Epsilon]yt}];\nemaxt=x/.solt[[1]];\n(* Calculo las diferencias cuadradas *)\nspecdiff=If[((\\[Epsilon]x<=emaxx1 &&\nhyp[[i,1]]==\"E\")||(\\[Epsilon]x>=emaxx1 && hyp[[i,1]]==\"P\")) &&(\\[Alpha]2==0 ||( \\[Epsilon]x<=emaxx2 && hyp[[i,2]]==\"E\")||(\\[Epsilon]x>=emaxx2 && hyp[[i,2]]==\"P\")) && ((\\[Epsilon]t<=emaxt && hyp[[i,3]]==\"E\")||(\\[Epsilon]t>=emaxt && hyp[[i,3]]==\"P\")), Append[specdiff,(\\[Sigma]st\\[Sigma]stexp)^2],Append[specdiff,penal]];\n];\n(* NO hay solucion. eq1 y eq2 no se interceptan *)\nIf[Length[Sol]==0,\nspecdiff=Append[specdiff,penal];\n];\nj++;\n]; (* fin for por cada especimen. *)\ndiff=Append[diff,Min[specdiff]];\n]; (* fin for por cada hipotesis. siguiente hipotesis posible *)\nsuma=suma+Min[diff];\n]; (* fin for por cada especimen *)\nIf[suma==Null,\nReturn[penal]; (* caso imposible *) ];\nsuma=Evaluate[suma/(Length[specimens]*10^2)];\nfit=Max[0,1-(suma/1000)]//N;\nIf [suma<1000,Print [\"Suma \",suma, \", Fitness Norm. \", fit]; ,Print [\"No se alcanza solucion.\"];Return[penal];];\nReturn[suma]; ];\nCoef[x_]:=Tan[\\[Pi]*x-\\[Pi]/2];\nCoord[y_]:=ArcTan[y]/\\[Pi]+1/2;\n(* **************************************************************************** *)\n(* ITERACION PRINCIPAL *)\n(* **************************************************************************** *)\nWhile[ True,\nSqrtCov = Transpose[CholeskyDecomposition[Cov]]; (* matriz transformacion *)\ngeneracion=generacion+1;\nlambda=Max[minlambda,(maxlambda-generacion)] //N;\nPrint[\"Generacion \",generacion,\" lambda=\", lambda];\nfmed=0;\nOffspringPop = Table[ (* Proxima generacion *)\n( offspring[[4]] = Table[ Random[norm], {n}]; (* E1 .1 *)\noffspring[[3]] = sigma*(SqrtCov.offspring[[4]]); (* E1 .2 *)\noffspring[[2]] = yParent + offspring[[3]]; (* E1 .3 *)\noffspring[[1]] = f[offspring[[2]]]; fmed = (fmed + offspring[[1]])/2; (* E1 .4 *)\noffspring\n), {lambda} ]; (* esta es la nueva pop de tam lambda *)\nIf [Element[generacion,Primes],OffspringPop = Union[OffspringPop,Take[Sort[elite],\nMin[5,Length[elite]-1]]];]; (* elitismo *)\nParentPop = Take[Sort[OffspringPop], mu]; (* tomar los padres *)\nPrint[\"f_Mean = \", fmed, \", f_Best = \", ParentPop[[1, 1]]]; (* el mejor *)\nPrint[\"Candidato a elite: \", f[ParentPop[[1, 2]]]];\nWrite[messages,\"Generacion;\"<> ToString[generacion] <> \";Mejor Fitness;\"<>ToString[ParentPop[[1,\n1]]]<> \";Med Fitness;\"<>ToString[fmed]];\nIf [Mod[generacion,10]==0, Print[\"Best = \", ParentPop[[1]]]; ];\nIf [generacion==1, elite=Take[Sort[OffspringPop], 1];,elite=Union[elite,Take[Sort[OffspringPop], 1]];]; (*\nelitismo *)\nPrint[\"nueva elite = \", elite];\nRecombinant = Sum[ParentPop[[m]], {m, 1, mu}]/mu; (* el cruce *) (* E2 *)\nyParent = Recombinant[[2]]; (* el nuevo centro *)\ns = (1-1/tau)*s + Sqrt[mu/tau*(2-1/tau)]*Recombinant[[3]]/sigma;(* E3 *)\nCov = (1-1/tauC)*Cov + Outer[Times, (s/tauC), s]; (* E4 *)\nCov = (Cov + Transpose[Cov])/2; (* forzamos la simetria *)\nsSigma = (1-1/tauSigma)*sSigma +\nSqrt[mu/tauSigma*(2-1/tauSigma)]*Recombinant[[4]]; (* E5 *)\nsigma = sigma*Exp[(sSigma.sSigma - n)/(2*n*Sqrt[n])]; (* E6 *)\nIf[ sigma < sigmaMin, Break[] ]\nIf[ generacion > maxgens, Break[] ]\n] (* termina si se cumple *)\nMejores=Take[Sort[elite], 5];\nExport[outputxls,ParentPop[[1, 1]],\"CSV\"];\nExport[outputxls,Mejores,\"CSV\"];\nClose[messages];\nAnexo II."}, {"heading": "Autorizaci\u00f3n para la defensa.", "text": "Dr. D. Jos\u00e9 Mar\u00eda Cecilia Canales profesor de la UCAM.\nCERTIFICA: que el Trabajo Fin de Grado titulado \u201cAN\u00c1LISIS E IMPLEMENTACI\u00d3N DE"}, {"heading": "ALGORITMOS EVOLUTIVOS PARA LA OPTIMIZACI\u00d3N DE SIMULACIONES EN INGENIER\u00cdA CIVIL.\u201d", "text": "que presenta D. Jos\u00e9 Alberto Garc\u00eda Guti\u00e9rrez, para optar al t\u00edtulo oficial de Grado en\nIngenier\u00eda inform\u00e1tica menci\u00f3n en Ingenier\u00eda del Software, ha sido realizado bajo su direcci\u00f3n.\nA su juicio re\u00fane las condiciones necesarias para ser presentado en la Universidad Cat\u00f3lica San\nAntonio de Murcia y ser juzgado por el tribunal correspondiente.\nMurcia, a 1 de Junio de 2014"}], "references": [{"title": "An algorithm for the multidimensional multiple-choice knapsack problem", "author": ["Martin MOSER", "Dusan P. JOKANOVIC", "Norio. SHIRATORI"], "venue": "IEICE transactions on fundamentals of electronics, communications and computer sciences,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1997}], "referenceMentions": [{"referenceID": 0, "context": "La tarea se vuelve a\u00fan m\u00e1s dif\u00edcil cuando el problema a resolver tiene una alta dimensionalidad por la presencia de un gran n\u00famero de caracter\u00edsticas [1,2] o variables de entrada [3,4].", "startOffset": 150, "endOffset": 155}, {"referenceID": 0, "context": "Para calcular la funci\u00f3n de aptitud (fitness) se hace uso de la siguiente funci\u00f3n auxiliar Fit(R)\u2208[0,1].", "startOffset": 98, "endOffset": 103}, {"referenceID": 0, "context": "2 *) offspring[[1]] = f[offspring[[2]]]; (* Ec 1 .", "startOffset": 15, "endOffset": 18}, {"referenceID": 0, "context": "[1] MOSER, Martin; JOKANOVIC, Dusan P.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "norm = NormalDistribution[0, 1]; (* inicializamos distribucion normal *)", "startOffset": 25, "endOffset": 31}, {"referenceID": 0, "context": "n = Dimensions[yInit][[1]]; (* dimensiones del espacio de busqueda *)", "startOffset": 22, "endOffset": 25}, {"referenceID": 0, "context": "ftest[x_] := Module[ {n}, n = Dimensions[x][[1]];", "startOffset": 44, "endOffset": 47}, {"referenceID": 0, "context": "If [R[[1]]==Null, return penal];If [R[[2]]==Null, return penal]; (* casos imposibles *)", "startOffset": 6, "endOffset": 9}, {"referenceID": 0, "context": "a=Coef[R[[1]]];", "startOffset": 9, "endOffset": 12}, {"referenceID": 0, "context": "For[i=1,i<=Length[T[[1]]] && line==0, i++,", "startOffset": 20, "endOffset": 23}, {"referenceID": 0, "context": "For[i=1,i<=Length[S[[1]]] && lineseed==0, i++,", "startOffset": 20, "endOffset": 23}, {"referenceID": 0, "context": "For[i=1,i<=Length[H[[1]]] && line==0, i++,", "startOffset": 20, "endOffset": 23}, {"referenceID": 0, "context": "Sol[[1]];", "startOffset": 4, "endOffset": 7}, {"referenceID": 0, "context": "solx1[[1]];", "startOffset": 6, "endOffset": 9}, {"referenceID": 0, "context": "solx2[[1]];", "startOffset": 6, "endOffset": 9}, {"referenceID": 0, "context": "solt[[1]];", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "offspring[[1]] = f[offspring[[2]]]; fmed = (fmed + offspring[[1]])/2; (* E1 .", "startOffset": 10, "endOffset": 13}, {"referenceID": 0, "context": "offspring[[1]] = f[offspring[[2]]]; fmed = (fmed + offspring[[1]])/2; (* E1 .", "startOffset": 61, "endOffset": 64}, {"referenceID": 0, "context": "Print[\"f_Mean = \", fmed, \", f_Best = \", ParentPop[[1, 1]]]; (* el mejor *)", "startOffset": 50, "endOffset": 56}, {"referenceID": 0, "context": "Print[\"f_Mean = \", fmed, \", f_Best = \", ParentPop[[1, 1]]]; (* el mejor *)", "startOffset": 50, "endOffset": 56}, {"referenceID": 0, "context": "Print[\"Candidato a elite: \", f[ParentPop[[1, 2]]]];", "startOffset": 41, "endOffset": 47}, {"referenceID": 0, "context": "Write[messages,\"Generacion;\"<> ToString[generacion] <> \";Mejor Fitness;\"<>ToString[ParentPop[[1, 1]]]<> \";Med Fitness;\"<>ToString[fmed]];", "startOffset": 93, "endOffset": 99}, {"referenceID": 0, "context": "Write[messages,\"Generacion;\"<> ToString[generacion] <> \";Mejor Fitness;\"<>ToString[ParentPop[[1, 1]]]<> \";Med Fitness;\"<>ToString[fmed]];", "startOffset": 93, "endOffset": 99}, {"referenceID": 0, "context": "If [Mod[generacion,10]==0, Print[\"Best = \", ParentPop[[1]]]; ];", "startOffset": 54, "endOffset": 57}, {"referenceID": 0, "context": "Export[outputxls,ParentPop[[1, 1]],\"CSV\"];", "startOffset": 27, "endOffset": 33}, {"referenceID": 0, "context": "Export[outputxls,ParentPop[[1, 1]],\"CSV\"];", "startOffset": 27, "endOffset": 33}], "year": 2014, "abstractText": "This paper studies the applicability of evolutionary algorithms, particularly, the evolution strategies family to estimation of a degradation parameter (referred as kappa parameter) for the shear design of reinforced concrete beams, a problem which have an expensive computational cost and highly relevant in the design of pillars and reinforced concrete structures, which however, has not been covered extensively in the present literature.", "creator": "PDFCreator Version 1.2.3"}}}