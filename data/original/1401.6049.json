{"id": "1401.6049", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jan-2014", "title": "Generating Approximate Solutions to the TTP using a Linear Distance Relaxation", "abstract": "In some domestic professional sports leagues, the home stadiums are located in cities connected by a common train line running in one direction. For these instances, we can incorporate this geographical information to determine optimal or nearly-optimal solutions to the n-team Traveling Tournament Problem (TTP), an NP-hard sports scheduling problem whose solution is a double round-robin tournament schedule that minimizes the sum total of distances traveled by all n teams. We introduce the Linear Distance Traveling Tournament Problem (LD-TTP), and solve it for n=4 and n=6, generating the complete set of possible solutions through elementary combinatorial techniques. For larger n, we propose a novel \"expander construction\" that generates an approximate solution to the LD-TTP. For n congruent to 4 modulo 6, we show that our expander construction produces a feasible double round-robin tournament schedule whose total distance is guaranteed to be no worse than 4/3 times the optimal solution, regardless of where the n teams are located. This 4/3-approximation for the LD-TTP is stronger than the currently best-known ratio of 5/3 + epsilon for the general TTP. We conclude the paper by applying this linear distance relaxation to general (non-linear) n-team TTP instances, where we develop fast approximate solutions by simply \"assuming\" the n teams lie on a straight line and solving the modified problem. We show that this technique surprisingly generates the distance-optimal tournament on all benchmark sets on 6 teams, as well as close-to-optimal schedules for larger n, even when the teams are located around a circle or positioned in three-dimensional space.", "histories": [["v1", "Thu, 23 Jan 2014 16:45:07 GMT  (339kb)", "http://arxiv.org/abs/1401.6049v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["richard hoshino", "ken-ichi kawarabayashi"], "accepted": false, "id": "1401.6049"}, "pdf": {"name": "1401.6049.pdf", "metadata": {"source": "CRF", "title": "Generating Approximate Solutions to the Traveling Tournament Problem using a Linear Distance Relaxation", "authors": ["Richard Hoshino", "Ken-ichi Kawarabayashi"], "emails": ["richard.hoshino@gmail.com", "keniti@nii.ac.jp"], "sections": [{"heading": null, "text": "We introduce the Linear Distance Traveling Tournament Problem (LD-TTP), and solve it for n = 4 and n = 6, generating the complete set of possible solutions through elementary combinatorial techniques. For larger n, we propose a novel \u201cexpander construction\u201d that generates an approximate solution to the LD-TTP. For n \u2261 4 (mod 6), we show that our expander construction produces a feasible double round-robin tournament schedule whose total distance is guaranteed to be no worse than 4\n3 times the optimal solution, regardless\nof where the n teams are located. This 4 3 -approximation for the LD-TTP is stronger than the currently best-known ratio of 5 3 + for the general TTP.\nWe conclude the paper by applying this linear distance relaxation to general (nonlinear) n-team TTP instances, where we develop fast approximate solutions by simply \u201cassuming\u201d the n teams lie on a straight line and solving the modified problem. We show that this technique surprisingly generates the distance-optimal tournament on all benchmark sets on 6 teams, as well as close-to-optimal schedules for larger n, even when the teams are located around a circle or positioned in three-dimensional space."}, {"heading": "1. Introduction", "text": "In this paper, we introduce a simple yet powerful technique to develop approximate solutions to the Traveling Tournament Problem (TTP), by \u201cassuming\u201d the n teams are located on a straight line, thereby reducing the\n(n 2 )\npairwise distance parameters to just n\u2212 1 variables, and then solving the relaxed problem.\nThe Traveling Tournament Problem (TTP) was inspired by the real-life problem of optimizing the regular-season schedule for Major League Baseball. The goal of the TTP is to determine the optimal double round-robin tournament schedule for an n-team sports league that minimizes the sum total of distances traveled by all n teams. Since the problem was first proposed (Easton, Nemhauser, & Trick, 2001), the TTP has attracted a significant amount of research (Kendall, Knust, Ribeiro, & Urrutia, 2010), with numerous heuristics developed for solving hard TTP instances, such as local search techniques as well as integer and constraint programming.\nc\u00a92012 AI Access Foundation. All rights reserved.\nIn many ways, the TTP is a variant of the well-known Traveling Salesman Problem (TSP), asking for a distance-optimal schedule linking venues that are close to one another. The computational complexity of the TSP is NP-hard; recently, it was shown that solving the TTP is strongly NP-hard (Thielen & Westphal, 2010).\nIn the Linear Distance Traveling Tournament Problem (LD-TTP), we assume the n teams are located on a straight line. This straight line relaxation is a natural heuristic when the n teams are located in cities connected by a common train line running in one direction, modelling the actual context of domestic sports leagues in countries such as Chile, Sweden, Italy, and Japan. For example, Figure 1 illustrates the locations of the six home stadiums in Nippon Pro Baseball\u2019s Central League, all situated in close proximity to major stations on Japan\u2019s primary bullet-train line.\nIn Section 2, we formally define the TTP. In Section 3, we solve the LD-TTP for n = 4 and list all 18 non-isomorphic tournament schedules achieving the optimal distance. In Section 4, we solve the LD-TTP for n = 6 and show that there are 295 non-isomorphic tournament schedules that can attain one of the seven possible values for the optimal distance. In Section 5, we provide an \u201cexpander construction\u201d to produce a feasible double round-robin tournament schedule for any tournament on n = 6m \u2212 2 teams, and prove that it is a 43 -approximation of the distance-optimal schedule, for any m \u2265 1. In Section 6, we apply our theories to all known (non-linear) 6-team benchmark sets (Trick, 2012), and show that in all cases, the optimal solution appears in our list of 295. We also apply our expander construction to various benchmark sets on 10 and 16 teams, showing that this optimality gap is actually far lower than the theoretical maximum of 33.3%. In Section 7, we do an in-depth analysis of the optimality gap, and conclude the paper in Section 8 with some open problems and directions for future research."}, {"heading": "2. The Traveling Tournament Problem", "text": "Let {t1, t2, . . . , tn} be the n teams in a sports league, where n is even. Let D be the n\u00d7 n distance matrix, where entry Di,j is the distance between the home stadiums of teams ti and tj. By definition, Di,j = Dj,i for all 1 \u2264 i, j \u2264 n, and all diagonal entries Di,i are zero. We assume the distances form a metric, i.e., Di,j \u2264 Di,k +Dk,j for all i, j, k.\nThe TTP requires a tournament lasting 2(n\u22121) days, where every team has exactly one game scheduled each day with no byes or days off (this explains why n must be even.) The objective is to minimize the total distance traveled by the n teams, subject to the following conditions:\n(a) each-venue: Each pair of teams plays twice, once in each other\u2019s home venue.\n(b) at-most-three: No team may have a home stand or road trip lasting more than three games.\n(c) no-repeat: A team cannot play against the same opponent in two consecutive games.\nWhen calculating the total distance, we assume that every team begins the tournament at home and returns home after playing its last away game. Furthermore, whenever a team has a road trip consisting of multiple away games, the team doesn\u2019t return to their home city but rather proceeds directly to their next away venue.\nTo illustrate with a specific example, Table 1 lists the distance-optimal schedule (Easton et al., 2001) for a bechmark set known as NL6 (six teams from Major League Baseball\u2019s National League). In this schedule, as with all subsequent schedules presented in this paper, home games are marked in bold.\nFor example, the total distance traveled by Florida is DFLO,ATL+DATL,PHI+DPHI,FLO+ DFLO,NYK+DNYK,MON+DMON,PIT+DPIT,FLO. Based on the NL6 distance matrix (Trick, 2012), the tournament schedule in Table 1 requires 23916 miles of total team travel, which can be shown to be the minimum distance possible."}, {"heading": "3. The 4-Team LD-TTP", "text": "In the Linear Distance TTP, we assume the n home stadiums lie on a straight line, with t1 at one end and tn at the other. Thus, Di,j = Di,k + Dk,j for all triplets (i, j, k) with\n1 \u2264 i < k < j \u2264 n. Since the Triangle Inequality is replaced by the Triangle Equality, we no longer need to consider all\n(n 2 )\nentries in the distance matrix D; each tournament\u2019s total travel distance is a function of n\u2212 1 variables, namely the set {Di,i+1 : 1 \u2264 i \u2264 n\u2212 1}. For notational convenience, denote di := Di,i+1 for all 1 \u2264 i \u2264 n\u2212 1.\nTable 2 gives a feasible solution to the 4-team LD-TTP. We claim that this solution is optimal, for all possible 3-tuples (d1, d2, d3). To see why this is so, define ILBti to be the independent lower bound for team ti, the minimum possible distance that can be traveled by ti in order to complete its games, independent of the other teams\u2019 schedules. Then a trivial lower bound for the total travel distance is TLB \u2265\n\u2211n i=1 ILBti .\nRecall that when calculating ti\u2019s travel distance, we assume that ti begins the tournament at home and returns home after playing its last away game. Since ti must play a road game against each of the other three teams, ILBti = 2(d1 + d2 + d3) for all 1 \u2264 i \u2264 4. This implies that TLB \u2265 8(d1 + d2 + d3). Since Table 2 is a tournament schedule whose total distance is the trivial lower bound, this completes the proof.\nWe remark that Table 2 is not the unique solution - for example, we can generate another optimal schedule by simply reading Table 2 from right to left. Assuming the first match between t1 and t2 occurs in the home city of t2, a straightforward computer search finds 18 different schedules with total distance 8(d1 + d2+ d3), which are provided in Table 3 below. (For readability, we have replaced each occurrence of ti by the single index i.) Thus, by symmetry, there are 36 optimal schedules for the 4-team LD-TTP. For the interested reader, Appendix A provides the actual Maplesoft code that generated these optimal schedules.\nThis completes the analysis of the 4-team Linear Distance TTP."}, {"heading": "4. The 6-Team LD-TTP", "text": "Unlike the previous section, the analysis for the 6-team LD-TTP requires more work.\nAny 6-team instance of the LD-TTP can be represented by the 5-tuple (d1, d2, d3, d4, d5). We define S = 14d1 + 16d2 + 20d3 + 16d4 + 14d5. We claim the following:\nTheorem 1. Let \u0393 be a 6-team instance of the LD-TTP. The optimal solution to \u0393 is a schedule with total distance S + 2min{d2 + d4, d1 + d4, d3 + d4, 3d4, d2 + d5, d2 + d3, 3d2}.\nWe will prove Theorem 1 through elementary combinatorial arguments, thus demonstrating the utility of this linear distance relaxation and presenting new techniques to attack the general TTP in ways that differ from integer/constraint programming. Our proof will follow from several lemmas, which we now prove one by one.\nLemma 1. Any feasible schedule of \u0393 must have total distance at least S.\nProof. For each 1 \u2264 k \u2264 5, define ck to be the total number of times a team crosses the \u201cbridge\u201d of length dk, connecting the home stadiums of teams tk and tk+1. Let Z be the total travel distance of this schedule. Since \u0393 is linear, Z =\n\u22115 k=1 ckdk. Since each team\ncrosses every bridge an even number of times, ck is always even.\nLet Lk be the home venues of {t1, t2, . . . , tk} and Rk be the home venues of {tk+1, . . . , t6}. By the each-venue condition, every team in Lk plays a road game against every team in Rk. By the at-most-three condition, every team in Lk must make at least 2d 6\u2212k 3 e trips across the bridge, with half the trips in each direction. Similarly, every team in Rk must make at least 2dk3e trips across the bridge, implying that ck \u2265 2kd 6\u2212k 3 e+ 2(6\u2212 k)d k 3 e.\nThus, c1 \u2265 14, c2 \u2265 16, c4 \u2265 16, and c5 \u2265 14. We now show that c3 \u2265 20, which will complete the proof that Z = \u2211\nckdk \u2265 14d1 + 16d2 + 20d3 + 16d4 + 14d5 = S.\nSince there are n = 6 teams, there are 2(n\u2212 1) = 10 days of games. For each 1 \u2264 i \u2264 9, let Xi,i+1 be the total number of times the d3-length bridge is crossed as the teams move from their games on the ith day to their games on the (i+1)th day. Let Xstart,1 and X10,end respectively be the number of times the teams cross this bridge to play their first game, and return home after having played their last game. Then c3 = Xstart,1+ \u22119 i=1 Xi,i+1+X10,end.\nFor each 1 \u2264 i \u2264 9, let f(i) denote the number of games played in L3 on day i. Thus, on day i, exactly 2f(i) teams are to the left of this bridge and 6 \u2212 2f(i) teams are to the right. So f(i) \u2208 {0, 1, 2, 3} for all i. Since |L3| and |R3| are odd, we have Xstart,1 \u2265 1 and X10,end \u2265 1.\nIf f(i) < f(i + 1), then Xi,i+1 \u2265 2, as at least two teams who played in R3 on day i must cross over to play their next game in L3. Similarly, if f(i) > f(i+1), then Xi,i+1 \u2265 2.\nIf f(i) = f(i+ 1) = 1, then on day i, two teams p and q play in L3 while the other four teams play in R3. If Xi,i+1 = 0 then no team crosses the bridge after day i, forcing p and\nq to play against each other on day i+ 1, thus violating the no-repeat condition. Thus, at least one of p or q must cross the bridge, exchanging positions with at least one other team who must cross to play in L3. Thus, Xi,i+1 \u2265 2. Similarly, if f(i) = f(i + 1) = 2, then Xi,i+1 \u2265 2.\nIf f(i) = f(i+ 1) = 0, then all teams play in R3 on days i and i+ 1. Then Xstart,1 = 3 if i = 1 and X10,end = 3 if i = 9. If 2 \u2264 i \u2264 8, then each of {t1, t2, t3} must play a home game on either day i\u2212 1 or day i+2, in order to satisfy the at-most-three condition. Thus, on one of these two days, at least two teams in {t1, t2, t3} play at home, implying at least four teams are in L3. Therefore, we must have Xi\u22121,i \u2265 4 or Xi+1,i+2 \u2265 4.\nWe derive the same results if f(i) = f(i + 1) = 3. We have Xstart,1 = 3 if i = 1, X10,end = 3 if i = 9, and either Xi\u22121,i \u2265 4 or Xi+1,i+2 \u2265 4 if 2 \u2264 i \u2264 8.\nSo in our double round-robin schedule, if the sequence {f(1), . . . , f(10)} has no pair of consecutive 0s or consecutive 3s, then c3 = Xstart,1+ \u22119 i=1Xi,i+1+X10,end \u2265 1+9\u00b72+1 = 20. And if this is not the case, we still have c3 \u2265 20 from the results of the previous two paragraphs. We have therefore proven that Z = \u2211\nckdk \u2265 S.\nLemma 2. Consider a feasible schedule of \u0393 with total distance Z = \u2211\nckdk. If c2 = 16, then teams t1 and t2 must play against each other on Days 1 and 10.\nProof. As we did in Lemma 1, for each 1 \u2264 i \u2264 9 define X\u2217i,i+1 be the total number of times the d2-length bridge is crossed as the teams move from their games on the i th day to their games on the (i + 1)th day. Similarly define X\u2217start,1 and X \u2217 10,end so that c2 = X \u2217 start,1 + \u22119 i=1 X \u2217 i,i+1 +X \u2217 10,end.\nWe now prove that \u22119 i=1X \u2217 i,i+1 \u2265 16. To do this, for each 1 \u2264 i \u2264 10, let g(i) denote the number of games played in L2 (i.e., the home stadiums of t1 and t2) on day i. So on day i, exactly 2g(i) teams are to the left of the d2-length bridge and 6\u2212 2g(i) teams are to the right. Clearly, 0 \u2264 g(i) \u2264 2 for all 1 \u2264 i \u2264 10.\nIf |g(i + 1) \u2212 g(i)| = 1, then X\u2217i,i+1 \u2265 2, as at least two teams who played on day i on one side of the bridge must cross over to play their next game on the other side. If |g(i + 1)\u2212 g(i)| = 2, then X\u2217i,i+1 = 4.\nIf g(i) = g(i+ 1) = 1, then on day i, two teams p and q play in L2 while the other four teams play in R2. If X \u2217 i,i+1 = 0 then no team crosses the bridge after day i, forcing p and q to play against each other on day i+ 1, thus violating the no-repeat condition. Thus, at least one of p or q must cross the bridge, exchanging positions with at least one other team who must cross to play in L2. Thus, X \u2217 i,i+1 \u2265 2. Similarly, if g(i) = g(i + 1) = 2, then two teams p and q play in R2 while the other four teams play in L2, and we apply the same argument to show that X\u2217i,i+1 \u2265 2. The remaining case to consider is g(i) = g(i + 1) = 0, in which case X\u2217i,i+1 could equal 0.\nSuppose there are a days with g(i) = 0, b days with g(i) = 1, and c days with g(i) = 2. Then a+ b+ c = 10. Since each of t1 and t2 play five home games, this implies b+2c = 10. From this, we see that a = c and that there are only six possible triplets for (a, b, c), namely (0, 10, 0), (1, 8, 1), (2, 6, 2), (3, 4, 3), (4, 2, 4), and (5, 0, 5).\nIf a = 0 or a = 1, then there does not exist an index i with g(i) = g(i+1) = 0, implying that X\u2217i,i+1 \u2265 2 for all 1 \u2264 i \u2264 9. Hence, \u22119 i=1 X \u2217 i,i+1 \u2265 9\u00d7 2 = 18 in these cases. If a = 2, then there is at most one index i with g(i) = g(i+1) = 0, implying that \u22119\ni=1X \u2217 i,i+1 \u2265 16.\nSuppose \u22119 i=1X \u2217 i,i+1 < 16. Then we must have 3 \u2264 a \u2264 5, with two or more indices i satisfying g(i) = g(i+ 1) = 0. For example, one such 10-tuple is (g(1), g(2), . . . , g(9), g(10)) = (1, 0, 0, 0, 1, 1, 1, 2, 2, 2), which can have\n\u22119 i=1X \u2217 i,i+1 = 14. A simple case analysis of each\nof (a, b, c) \u2208 {(3, 4, 3), (4, 2, 4), (5, 0, 5)} shows that all such \u201cbad\u201d 10-tuples violate the atmost-three condition; for example, in the 10-tuple above, either t1 or t2 must play four consecutive road games to start the tournament, which is a contradiction.\nTherefore, we have proven that \u22119 i=1X \u2217 i,i+1 \u2265 16 in all cases. This implies that if\nc2 = 16, then X \u2217 start,1 = X \u2217 10,end = 0. Hence, on Days 1 and 10, t1 and t2 stay in L2 while the other four teams stay in R2. Since t1 and t2 are the only teams in L2, clearly this forces these two teams to play against each other, to begin and end the tournament.\nLemma 3. Let S1 be the set of tournament schedules with distance S +2(d2 + d4), S2 with distance S + 2(d1 + d4), S3 with distance S + 2(d3 + d4), S4 with distance S + 6d4, S5 with distance S+2(d2+d5), S6 with distance S+2(d2+d3), and S7 with distance S+6d2. Then each set in {S1, S2, . . . , S7} is non-empty.\nProof. For each of these seven sets, it suffices to find just one feasible schedule with the desired total distance. For each of {S1, S2, S3, S4}, at least one such set has appeared previously in the literature, as the solution to a 6-team benchmark set or in some other context. (As we will see in the following section, we can label the six teams of the NL6 benchmark set so that Table 1 is an element of S4.)\nThe solution to CIRC6 (Trick, 2012), where Di,j = min{j\u2212 i, 6\u2212 (j\u2212 i)} for all 1 \u2264 i < j \u2264 6, is an element of S1. Table 4 provides this schedule. For each 1 \u2264 k \u2264 5, we list the number of times the dk bridge is crossed by each of the six teams.\nWe conclude the proof by noting that |Si+3| = |Si| for 2 \u2264 i \u2264 4, as we can label the teams backward from t6 to t1 to create a feasible schedule where each distance dk is replaced by d6\u2212k. Therefore, we have shown that each Si is non-empty.\nWe are now ready to prove Theorem 1, that the optimal solution to any 6-team instance \u0393 is a schedule that appears in S1 \u222a S2 \u222a . . . \u222a S7. We note that any of these seven optimal distances can be the minimum, depending on the 5-tuple (d1, d2, d3, d4, d5).\nProof. Suppose the optimal solution to \u0393 has total distance Z = \u2211\nckdk. By Lemma 1, c1, c5 \u2265 14, c2, c4 \u2265 16, and c3 \u2265 20. Recall that each coefficient ck is even.\nBy Lemma 3, S1 is non-empty, and so a schedule cannot be optimal if Z > S+2(d2+d4). Thus, if c2, c4 \u2265 18, then we must have (c1, c2, c3, c4, c5) = (14, 18, 20, 18, 14) so that Z = S + 2(d2 + d4), forcing the schedule to be in set S1.\nSuppose that c2 \u2264 c4, so that it suffices to check the possibility c2 = 16. By Lemma 2, t1 and t2 must play against each other on Days 1 and 10. There are three cases:\nCase 1: c2 = 16, c1 = 14.\nCase 2: c2 = 16, c1 \u2265 16, c4 = 16.\nCase 3: c2 = 16, c1 \u2265 16, c4 \u2265 18.\nIn Case 1, every team must travel the minimum number of times across the d1- and d2-bridges: team t1 can only take two road trips, team t2 can only take two road trips to play {t3, t4, t5, t6}, and each of {t3, t4, t5, t6} must play their road games against t1 and t2 on consecutive days.\nBy symmetry, we may assume that the first match between t1 and t2 occurs in the home city of t2 (i.e., it is a road game for t1). By Lemma 2, the schedule for team t1 must be one of the following four cases, for some permutation {p, q, r, s} of {3, 4, 5, 6}.\nCase Team 1 2 3 4 5 6 7 8 9 10 #A1 t1 t2 t? tp tq t? t? t? tr ts t2 #A2 t1 t2 t? t? tp tq t? t? tr ts t2 #A3 t1 t2 t? tp tq tr t? t? t? ts t2 #A4 t1 t2 t? t? tp tq tr t? t? ts t2\nIn all four cases, t1 plays a home game against ts on day 9. In other words, ts plays on the road against t1 on day 9, forcing ts\u2019s road game against t2 to take place either the day before or the day after. The latter is not possible, as t2 already has a game scheduled against t1 on day 10; thus, ts must play on the road against t2 on day 8.\nHence, t2 plays a home game against ts on day 8 and a road game against t1 on day 10. Now suppose that t2 has a home game on day 9. Then t2\u2019s opponent that day must be tr, and we must have either Case #A1 or #A2 above. (This is the only way we can ensure tr plays their road games against t1 and t2 on consecutive days.)\nTeam 1 2 3 4 5 6 7 8 9 10 t1 t1 tr ts t2 t2 t1 ts tr t1\nThere are six teams in the tournament, and on days 8 and 9, the same set of four teams have each been assigned a game. From the above table, it is clear that teams tp and tq must play each other on day 8 and day 9, which is a violation of the no-repeat condition. This is a contradiction, and therefore t2 must play a road game on day 9, against some team in {t3, t4, t5, t6}.\nAs mentioned earlier, t2 can only take two road trips to play the four teams in {t3, t4, t5, t6}, which forces one of the following two scenarios:\nCase Team 1 2 3 4 5 6 7 8 9 10 #B1 t2 t1 tp tq t? t? t? tr ts t? t1 #B2 t2 t1 tp t? t? t? tq tr ts t? t1\nFor each of the 4\u00d7 2 = 8 pairs matching the cases for t1 with the cases for t2, we check whether there exists a feasible schedule for which each team in {t3, t4, t5, t6} plays their road games against t1 and t2 on consecutive days. A quick check shows that the only possibility is the pairing of Case #A1 with Case #B1, leading to the following schedule for the first two teams:\nTeam 1 2 3 4 5 6 7 8 9 10 t1 t2 t? tp tq t? t? t? tr ts t2 t2 t1 tp tq t? t? t? tr ts t? t1\nThis structural characterization reduces the search space considerably, and from this (see Appendix B) we show that either (i) c4 \u2265 22, or (ii) c3 \u2265 22 and c4 \u2265 18. By Lemma 3, the latter implies Z = S + 2(d3 + d4) and the former implies Z = S + 6d4. Therefore, this optimal schedule must be in S3 or S4.\nIn Case 2, we demonstrate that no structural characterization exists if c2 = c4 = 16. To do this, we use Lemma 2 (for c2 = 16) and its symmetric analogue (for c4 = 16) to show that in order not to violate the at-most-three or no-repeat conditions, t3 and t4 must play each other on Days 1 and 10, as well as on some other Day i with 2 \u2264 i \u2264 9. But then this violates the each-venue condition. Hence, we may eliminate this case.\nIn Case 3, if c1 \u2265 16 and c4 \u2265 18, then Z is at least S + 2(d1 + d4). By Lemma 3, we must have Z = S + 2(d1 + d4) and this optimal schedule must be in S2.\nSo we have shown that if c2 = 16, then the schedule appears in S2 \u222a S3 \u222a S4. By symmetry, if c4 = 16, then the schedule appears in S5 \u222a S6 \u222a S7. Finally, if c2, c4 \u2265 18, the schedule appears in S1. This concludes the proof.\nBy Theorem 1, there are only seven possible optimal distances. For each optimal distance, we can enumerate the set of tournament schedules with that distance, thus producing the complete set of possible LD-TTP solutions, over all instances, for the case n = 6.\nTheorem 2. Consider the set of all feasible tournaments for which the first game between t1 and t2 occurs in the home city of t2. Then there are 295 schedules whose total distance appears in S1 \u222a S2 \u222a . . . \u222a S7, grouped as follows:\nTotal Distance \u2208 S1 \u2208 S2 \u2208 S3 \u2208 S4 \u2208 S5 \u2208 S6 \u2208 S7 # of Schedules 223 4 8 24 4 8 24\nWe derive Theorem 2 by a computer search. For each of {S1, S2, S3, S4}, we develop a structural characterization theorem, similar to Case 1 above, that shows that a feasible schedule in that set must have a certain form. This characterization reduces the search space, from which a brute-force search (using Maplesoft) enumerates all possible schedules. While it took several days to enumerate the 223 schedules in S1, Maplesoft took less than 100 seconds to enumerate the set of schedules in S3 and S4. As noted earlier, once we have\nthe set of schedules in Si (for 2 \u2264 i \u2264 4), we immediately have the set of schedules in Si+3 by symmetry. For the full details of each case, we refer the reader to Appendix B.\nLet us briefly explain why |S1| is odd. For any schedule S, let \u03a8(S) denote the schedule produced by playing the games backwards (i.e., ti hosts tj on day d in S iff ti hosts tj on day (11 \u2212 d) in \u03a8(S).) And let \u03a6(S) denote the schedule produced by labelling the six teams in reverse order (i.e., ti hosts tj on day d in S iff t7\u2212i hosts t7\u2212j on day d in \u03a6(S).) For any schedule S, clearly S 6= \u03a8(S) and S 6= \u03a6(S).\nFor any schedule S\u2217 \u2208 S1, exactly one of \u03a6(S \u2217) and \u03a6(\u03a8(S\u2217)) belongs to S1, since we\u2019ve stipulated that the first game between t1 and t2 occurs in the home city of t2. Since the mapping functions \u03a6 and \u03a6(\u03a8) are involutions, the schedules in S1 can be grouped into \u201cpairs\u201d. However, in 13 exceptional cases, the schedule S\u2217 \u2208 S1 does not have a pair, since S\u2217 = \u03a6(\u03a8(S\u2217)). One such example is given in Table 5.\nIn the above schedule, for any pair (i, j), ti hosts tj on day d iff t7\u2212i hosts t7\u2212j on day 11 \u2212 d. These thirteen exceptions justify the odd parity of |S1|. For 2 \u2264 i \u2264 7, there is no schedule with S\u2217 = \u03a6(\u03a8(S\u2217)), which explains why |Si| is even in each of these cases."}, {"heading": "5. An Approximation Algorithm", "text": "We have solved the LD-TTP for n = 4 and n = 6, and in both cases, determined the complete set of schedules attaining the optimal distances. A natural follow-up question is whether our techniques scale for larger values of n. To give a partial answer to this question, we show that for all n \u2261 4 (mod 6), we can develop a solution to the n-team LD-TTP whose total distance is at most 33% higher than that of the optimal solution, although in practice this optimality gap is actually much lower.\nWhile our construction is only a 43 -approximation, we note that this ratio is stronger than the currently best-known (53 + )-approximation for the general TTP (Yamaguchi, Imahori, Miyashiro, & Matsui, 2011). Our schedule is based on an \u201cexpander construction\u201d, and is completely different from previous approaches that generate approximate TTP solutions. We now describe this construction, and apply it to benchmark instances on 10 teams and 16 teams.\nLet m be a positive integer. We first create a single round-robin tournament U on 2m teams, and then expand this to a double round-robin tournament T on n = 6m\u2212 2 teams. We use a variation of the Modified Circle Method (Fujiwara, Imahori, Matsui, & Miyashiro, 2007) to build U , our single round-robin schedule. Let {u1, u2, . . . , u2m\u22121, x} be the 2m teams. Then each team plays 2m\u2212 1 games, according to this three-part construction:\n(a) For 1 \u2264 k \u2264 m, team k plays the other teams in the following order: {2m \u2212 k + 1, 2m \u2212 k + 2, . . . , 2m\u2212 1, 1, 2, . . . , k \u2212 1, x, k + 1, k + 2, . . . , 2m\u2212 k}.\n(b) For m + 1 \u2264 k \u2264 2m \u2212 1, team k plays the other teams in the following order: {2m\u2212 k + 1, 2m \u2212 k + 2, . . . , k \u2212 1, x, k + 1, k + 2, . . . , 2m\u2212 1, 1, 2, . . . , 2m\u2212 k}.\n(c) Team x plays the other teams in the following order: {1,m + 1, 2,m + 2, . . . ,m \u2212 1, 2m \u2212 1,m}.\nFor all games not involving team x, we designate one home team and one road team as follows: for 1 \u2264 k \u2264 m, uk plays only road games until it meets team x, before finishing the remaining games at home. And for m+1 \u2264 k \u2264 2m\u2212 1, we have the opposite scenario, where uk plays only home games until it meets team x, before finishing the remaining games on the road. As an example, Table 6 provides this single round-robin schedule for the case m = 4.\nThis construction ensures that for any 1 \u2264 i, j \u2264 2m\u22121, the match between ui and uj has exactly one home team and one road team. To verify this, note that ui is the home team and uj is the road team iff i occurs before j in the set {1, 2m\u22121, 2, 2m\u22122, . . . ,m\u22121,m+1,m}.\nNow we \u201cexpand\u201d this single round-robin tournament U on 2m teams to a double round-robin tournament T on n = 6m \u2212 2 teams. To accomplish this, we keep x and transform uk into three teams, {t3k\u22122, t3k\u22121, t3k}, so that the set of teams in T is precisely {t1, t2, t3, . . . , t6m\u22125, t6m\u22124, t6m\u22123, x}.\nSuppose ui is the home team in its game against uj, played in time slot r. Then we expand that time slot in U into six time slots in T , namely the slots 6r \u2212 5 to 6r. We describe the match assignments in Table 7.\nBefore proceeding further, let us explain the idea behind this construction. Recall that by the each-venue condition, each team in T must visit every opponent\u2019s home stadium exactly once, and by the at-most-three condition, road trips are at most three games. We will build a tournament that maximizes the number of three-game road trips, and ensure that the majority of these road trips involve three venues closely situated to one another, to minimize total travel. In Table 7 above, if {t3j\u22122, t3j\u22121, t3j} are located in the same region, then each of the teams in {t3i\u22122, t3i\u22121, t3i} can play their three road games against these teams in a highly-efficient manner.\nWe now explain how to expand the time slots in games involving team x. For each 1 \u2264 k \u2264 m, consider the game between uk and x. We expand that time slot in U into six time slots in T , as described in Table 8.\nAnd for each m + 1 \u2264 k \u2264 2m \u2212 1, consider the game between uk and x. We expand that time slot in U into six time slots in T , as described in Table 9.\nThis construction builds a double round-robin tournament T with n = 6m \u2212 2 teams and 2n \u2212 2 = 12m \u2212 6 time slots. To give an example, Table 10 provides T for the case m = 2.\nIt is straightforward to verify that this tournament schedule on n = 6m \u2212 2 teams is feasible for all m \u2265 1, i.e., it satisfies the each-venue, at-most-three, and no-repeat conditions. We now show that this expander construction gives a 43 -approximation to the LD-TTP, regardless of the values of the distance parameters d1, d2, . . . , dn\u22121.\nLet \u0393 be an n-team instance of the LD-TTP, with n = 6m\u22122 for some m \u2265 1. Let S be the total distance of the optimal solution of \u0393. Using our expander construction, we generate a feasible tournament with total distance less than 43S. This gives a 4 3 -approximation to the LD-TTP.\nLet y1, y2, . . . , yn be the n = 6m \u2212 2 teams of \u0393, in that order, with dk being the distance from yk to yk+1 for all 1 \u2264 k \u2264 n \u2212 1. Now we map the set {t1, t2, . . . , tn\u22121, x} to {y1, y2, . . . , yn} as follows: ti = yi for 1 \u2264 i \u2264 3m \u2212 3, x = y3m\u22122, and ti = yi+1 for 3m \u2212 2 \u2264 i \u2264 6m \u2212 3. In Figure 4 below, we illustrate this mapping for the case m = 2, where the n = 6m\u2212 2 teams are divided into three triplets and a singleton x:\nWe then apply this labeling to our expander construction to create a feasible n-team tournament T , where n = 6m\u2212 2 for some m \u2265 1. The following theorem tells us the total distance of this tournament, as a function of the n\u2212 1 distance parameters d1, d2, . . . , dn\u22121.\nTheorem 3. Let T be the n-team double round-robin tournament created by our expander construction, where n = 6m \u2212 2. For each 1 \u2264 k \u2264 6m \u2212 3, let fk be the total number of times the dk-length \u201cbridge\u201d is crossed, so that the total distance of T is \u2211n\u22121 k=1 fkdk. Then the value of fk is given by Table 11. In addition, f1 = (8n \u2212 8)/3, f2 = 4n \u2212 4, f3m\u22122 = fn/2\u22121 = (n 2 + 6n \u2212 16)/3, f3m\u22121 = fn/2 = (n 2 + 9n \u2212 22)/3, f3m = fn/2+1 = (n2 + 9n \u2212 34)/3, and f6m\u22123 = fn\u22121 = (8n \u2212 2)/3.\nProof. For each of the six cases, we carefully enumerate the number of times each team crosses the bridge, by considering the activity of each team in the tournament schedule T .\n(a) Of the k teams to the left of the dk-length bridge, one team crosses the bridge 2(n\u2212k)/3 times, (k + 5)/3 teams cross the bridge 2(n \u2212 k + 3)/3 times and (2k \u2212 8)/3 teams cross the bridge 2(n \u2212 k + 6)/3 times. And of the n \u2212 k \u2212 1 teams to the right of the bridge (not including team x), (2n \u2212 3k \u2212 5)/3 of these teams cross the bridge 2(k+2)/3 times and the remaining (n+2)/3 teams cross the bridge 2(k+5)/3 times. Finally, team x crosses the bridge (4k+2)/3 times. From there, we sum up the cases and determine that fk = 4k(n \u2212 k)/3 + (6n + 8k \u2212 20)/3.\n(b) Of the k teams to the left of the dk-length bridge, one team crosses the bridge 2(n\u2212 k + 1)/3 times, (k + 4)/3 teams cross the bridge 2(n\u2212 k + 4)/3 times and (2k \u2212 7)/3 teams cross the bridge 2(n\u2212 k + 7)/3 times. And of the n\u2212 k \u2212 1 teams to the right of the bridge (not including team x), (2n\u2212 3k \u2212 2)/3 of these teams cross the bridge 2(k + 1)/3 times, (n \u2212 4)/3 teams cross the bridge 2(k + 4)/3 times, and one team crosses 2(k + 7)/3 times. Finally, team x crosses the bridge (4k \u2212 2)/3 times. From there, we sum up the cases and determine that fk = 4k(n\u2212 k)/3+ (4n+12k\u2212 20)/3.\n(c) Of the k teams to the left of the dk-length bridge, (k + 6)/3 of these teams cross the bridge 2(n \u2212 k + 2)/3 times, and the remaining (2k \u2212 6)/3 teams cross the bridge 2(n \u2212 k + 5)/3 times. And of the n \u2212 k \u2212 1 teams to the right of the bridge (not including team x), (n \u2212 k \u2212 1)/3 of these teams cross the bridge 2k/3 times and the remaining 2(n \u2212 k \u2212 1)/3 teams cross the bridge (2k + 6)/3 times. Finally, team x crosses the bridge 4k/3 times. From there, we sum up the cases and determine that fk = 4k(n\u2212 k)/3 + (4n+ 6k \u2212 16)/3.\n(d) Of the k\u22121 teams to the left of the dk-length bridge (not including team x), (k+5)/3 teams cross the bridge 2(n \u2212 k)/3 times, and the remaining (2k \u2212 8)/3 teams cross the bridge 2(n \u2212 k + 3)/3 times. And of the n \u2212 k teams to the right of the bridge, (n\u2212k+3)/3 cross the bridge 2(k+2)/3 times and the remaining (2n\u22122k\u22123)/3 teams cross the bridge 2(k+5)/3 times. Finally, team x crosses the bridge 2(n\u2212k)/3 times. From there, we sum up the cases and determine that fk = 4k(n\u2212k)/3+(8n\u22124k\u221222)/3.\n(e) Of the k \u2212 1 teams to the left of the dk-length bridge (not including team x), (3k \u2212 n + 4)/3 teams cross the bridge 2(n \u2212 k + 1)/3 times, and the remaining (n \u2212 7)/3 teams cross the bridge 2(n \u2212 k + 4)/3 times. And of the n \u2212 k teams to the right of the bridge, (n \u2212 k + 4)/3 cross the bridge 2(k + 4)/3 times and the remaining (2n \u2212 2k \u2212 4)/3 teams cross the bridge 2(k + 7)/3 times. Finally, team x crosses the bridge 2(n \u2212 k + 4)/3 times. From there, we sum up the cases and determine that fk = 4k(n\u2212 k)/3 + (14n \u2212 10k \u2212 16)/3.\n(f) Of the k \u2212 1 teams to the left of the dk-length bridge (not including team x), (3k \u2212 n + 1)/3 teams cross the bridge 2(n \u2212 k + 2)/3 times, and the remaining (n \u2212 4)/3 teams cross the bridge 2(n \u2212 k + 5)/3 times. And of the n \u2212 k teams to the right of the bridge, (n \u2212 k + 2)/3 cross the bridge 2(k + 3)/3 times and the remaining (2n \u2212 2k \u2212 2)/3 teams cross the bridge 2(k + 6)/3 times. Finally, team x crosses the\nbridge 2(n \u2212 k + 2)/3 times. From there, we sum up the cases and determine that fk = 4k(n\u2212 k)/3 + (4n\u2212 2k \u2212 4).\nFinally, we clear all the exceptional cases. If k = 1, team t1 crosses the bridge 2(n\u22121)/3 times, while the remaining n \u2212 1 teams cross twice. Thus, f1 = 2(n \u2212 1)/3 + 2(n \u2212 1) = (8n\u2212 8)/3. If k = 2, team t1 crosses the bridge 2(n\u2212 1)/3 times, team t2 crosses 2(n+2)/3 times, (2n \u2212 5)/3 teams cross twice, and (n \u2212 1)/3 teams cross four times. Thus, f2 = 2(n \u2212 1)/3 + 2(n + 2)/3 + (4n \u2212 10)/3 + (4n \u2212 4)/3 = 4n \u2212 4. If k = n \u2212 1, team tn crosses the bridge 2(n + 2)/3 times, while the remaining n \u2212 1 teams cross twice. Thus, fn\u22121 = 2(n+ 2)/3 + 2(n \u2212 1) = (8n\u2212 2)/3.\nFor k = n2 \u2212 1, the formula for fk is the same as that of case (d), except that one team makes an additional trip across the bridge. For k = n2 \u2212 1, the formula for fk is the same as that of case (e), except that one team makes one fewer trip across the bridge. Finally, for k = n2 + 1, the formula for fk is the same as that of case (f), except that two teams make one additional trip across the bridge. A straightforward calculation then results in verifying that f3m\u22122 = fn/2\u22121 = (n 2 + 6n \u2212 16)/3, f3m\u22121 = fn/2 = (n 2 + 9n \u2212 22)/3, and f3m = fn/2+1 = (n 2 + 9n \u2212 34)/3. This completes the proof.\nFor example, for the case m = 2 (see Table 10), we have n = 10, and so the total travel distance of T is 24d1 + 36d2 + 42d3 + 48d4 + 56d5 + 52d6 + 38d7 + 36d8 + 26d9.\nLet S = \u2211n\u22121\nk=1 lkdk be the trivial lower bound of \u0393, found by adding the independent lower bounds for each team ti. As we described in the proof of Lemma 1, we have lk = 2kdn\u2212k3 e+ 2(n\u2212 k)d k 3e because each of the k teams to the left of the dk bridge must make at least 2dn\u2212k3 e trips across the bridge, and the n\u2212 k teams to the right of this bridge must make at least 2dk3e trips across.\nFor m \u2265 3, it is straightforward to verify that fklk < 4 3 for all 1 \u2264 k \u2264 n \u2212 1, thus establishing our 43 -approximation for the LD-TTP. This ratio of 4 3 is the best possible due to the case k = 3, which has f3 = 16n\u221234\n3 and l3 = 4n \u2212 8, implying f3 l3 \u2192 43 as n \u2192 \u221e. This worst-case scenario is achieved when dk = 0 for all k 6= 3, i.e., when teams {t1, t2, t3} are located at one vertex, and the remaining n\u2212 3 teams are located at another vertex.\nA natural question is whether there exist similar constructions for n \u2261 0 and n \u2261 2 (mod 6). In these cases, in addition to the n \u2261 4 case we just analyzed, we ask whether a 4 3 -approximation is best possible. This is just one of many open questions arising from this work."}, {"heading": "6. Application to Benchmark Sets", "text": "We now apply our theories to various benchmark TTP sets. We start with the case n = 6, and apply Theorems 1 and 2 to all known 6-team TTP benchmarks. In addition to NL6, we examine a six-team set from the Super Rugby League (SUPER6), six galaxy stars whose coordinates appear in three-dimensional space (GALAXY6), our earlier six-team circular distance instance (CIRC6), and the trivial constant distance instance (CON6) where each pair of teams has a distance of one unit.\nFor all our benchmark sets, we first order the six teams so that they approximate a straight line, either through a formal \u201cline of best fit\u201d or an informal check by inspection.\nHaving ordered our six teams, we determine the five-tuple (d1, d2, d3, d4, d5) from the distance matrix and ignore the other\n(6 2 )\n\u2212 5 = 10 entries. Modifying our benchmark set and assuming the six teams lie on a straight line, we solve the LD-TTP via Theorem 1. Using Theorem 2, we take the set of tournament schedules achieving this optimal distance and apply the actual distance matrix of the benchmark set (with all\n(6 2 )\nentries) to each of these optimal schedules and output the tournament with the minimum total distance.\nThis simple process, each taking approximately 0.3 seconds of computation time per benchmark set, generates a feasible solution to the 6-team TTP. To our surprise, this algorithm outputs the distance-optimal schedule in all five of our benchmark sets. This was an unexpected result, given the non-linearity of our data sets: for example, CIRC6 has the teams arranged in a circle, while GALAXY6 uses three-dimensional distances. To illustrate our theory, let us begin with NL6, ordering the six teams from south to north:\nThus, Florida is t1, Atlanta is t2, Pittsburgh is t3, Philadelphia is t4, New York is t5, and Montreal is t6. From the NL6 distance matrix (Trick, 2012), we have (d1, d2, d3, d4, d5) = (605, 521, 257, 80, 337).\nSince 2min{d2 + d4, d1 + d4, d3 + d4, 3d4, d2 + d5, d2 + d3, 3d2} = 6d4 = 480, Theorem 1 tells us that the optimal LD-TTP solution has total distance S + 6d4 = 14d1 + 16d2 + 20d3 + 22d4 + 14d5 = 28424. By Theorem 2, there are 24 schedules in set S4, all with total distance S + 6d4. Two of these 24 schedules are presented in Table 12.\nRemoving this straight line assumption, we now apply the actual NL6 distance matrix to determine the total distance traveled for each of these 24 schedules from set S4, which will naturally produce different sums. The left schedule in Table 12 is best among the 24 schedules, with total distance 23916, while the right schedule is the worst, with total\ndistance 24530. We note that the left schedule, achieving the optimal distance of 23916 miles, is identical to Table 1.\nWe repeat the same analysis with the other four benchmark sets. In each, we mark which of the sets {S1, S2, . . . , S7} produced the optimal schedule.\nA sophisticated branch-and-price heuristic (Irnich, 2010) solved NL6 in just over one minute, yet required three hours to solve CIRC6. The latter problem was considerably more difficult due to the inherent symmetry of the data set, which required more branching. However, through our LD-TTP approach, both problems can be solved to optimality in the same amount of time \u2013 approximately 0.3 seconds.\nBased on the results of Table 13, we ask whether there exists a 6-team instance \u0393 where the optimal TTP solution is different from the optimal LD-TTP solution. This question will be answered in the following section.\nTo conclude this section, we apply the 43 -approximation produced by our expander construction to various (non-linear) benchmark sets with n \u2261 4 (mod 6). We apply our construction to the 10-team and 16-team instances of our earlier examples (Trick, 2012).\nFor the GALAXY, NL, and SUPER instances, we first need to arrange the n teams to approximate a straight line. To do this, we apply a simple algorithm that first randomly assigns the n teams to {t1, t2, . . . , tn\u22121, x}, and calculates the sum total of distances between each \u201cadjacent\u201d pair of teams. We generate a local line-of-best-fit by recursively selecting two teams ti and tj and switching their positions if it reduces the sum of these n\u22121 distances. The algorithm terminates with a permutation of the n teams to {t1, t2, . . . , tn\u22121, x} that is\nlocally optimal (but perhaps not globally), from which we apply the expander construction to calculate the total travel distance of our n-team tournament.\nInstead of a time-consuming process that enumerates all n! permutations of the teams, our simple algorithm generates a fast solution to each of our benchmark instances in less than 2 seconds of total computation time. Despite the simplicity of our approach, we see in Table 14 that the optimality gap is extremely small for the constant instances (CONS), and is quite reasonable for all the other (non-linear) instances."}, {"heading": "7. Optimality Gap", "text": "In Table 13, all five of the 6-team benchmark instances produced identical solutions for both the TTP and LD-TTP. A natural question is whether this is always the case. We show that the TTP and LD-TTP solutions must be identical for n = 4, but not necessarily for n = 6.\nFor any instance \u0393 on n teams, define X\u0393 to be the total distance of an optimal TTP solution, and X\u2217\u0393 to be the total distance of an optimal LD-TTP solution. Define OGn to be the maximum optimality gap, the largest value of X\u2217\n\u0393 \u2212X\u0393 X\u0393 taken over all instances \u0393.\nTheorem 4. For any instance \u0393 on n = 4 teams, the optimal TTP solution is the optimal LD-TTP solution. In other words, OG4 = 0%.\nProof. In Table 3, we showed that there are 18 non-isomorphic schedules with total distance 8(d1 + d2 + d3), i.e., 18 different solutions to the LD-TTP. For each of these 18 schedules, we remove the linear distance assumption and determine the total travel distance as a function of the six distance parameters (i.e., the variables in {Di,j : 1 \u2264 i < j \u2264 4}). For example, the schedule in Table 2 has total distance 4D1,2 + 2D1,3 +2D1,4 + 3D2,3 +D2,4 + 5D3,4 which we represent by the 6-tuple (4, 2, 2, 3, 1, 5). Considering all 4! permutations of {t1, t2, t3, t4}, there are 18 \u00d7 24 tournament schedules, producing 36 unique 6-tuples, including (4, 2, 2, 3, 1, 5). Denote by L this set of thirty-six 6-tuples.\nA brute-force enumeration finds 1920 feasible 4-team tournaments. For each of these 1920 tournaments, we determine the 6-tuple representing the total travel distance, and find 246 unique 6-tuples, which we denote by set A. By definition, L \u2282 A.\nTo prove that OG4 = 0, we must verify that for any set {D1,2,D1,3,D1,4,D2,3,D2,4,D3,4} satisfying the Triangle Inequality, the optimal solutions of the TTP and LD-TTP are the same, i.e., the optimal solution among all schedules (whose six-tuples are given by A) appears in the subset of linear-distance schedules (whose six-tuples are given by L). To establish this, we first use the Triangle Inequality to verify that for 204 of the 246\u221236 = 210 elements in A\\L, the corresponding schedule is dominated by at least one of the elements in L.\nFor example, the six-tuple (3, 4, 3, 4, 1, 4) is one of the 210 elements in A\\L. Comparing this with the six-tuple (4, 2, 2, 3, 1, 5) \u2208 L, we see that the corresponding schedule in A\\L has total distance 2D1,3+D1,4+D2,3\u2212D1,2\u2212D3,4 = (D1,3+D1,4\u2212D3,4)+(D1,3+D2,3\u2212D1,2) \u2265 0 more than the corresponding schedule in L, which is given in Table 2.\nA computer search shows that 204 of the 210 elements in A\\L can be handled by applying the Triangle Inequality in this way, showing it is dominated by at least one element in L. There are just six \u201cexceptions\u201d, namely the 6-tuples in the set {(2, 3, 3, 3, 3, 4), (3, 2, 3, 3, 4, 3), (3, 3, 2, 4, 3, 3), (3, 3, 4, 2, 3, 3), (3, 4, 3, 3, 2, 3), and (4, 3, 3, 3, 3, 2)}. In these\ncases, the analysis is slightly harder. Consider the six-tuple (2, 3, 3, 3, 3, 4); the rest can be handled in the same way, by symmetry.\nThere are twelve 6-tuples in L which have 17 total trips, where the D1,2 coefficient is strictly less than the D4,5 coefficient. (An example of one such 6-tuple is (4, 2, 2, 3, 1, 5).) Taking its average, we derive the 6-tuple (7/3, 17/6, 17/6, 17/6, 17/6, 10/3), implying the existence of at least one LD-TTP schedule whose total distance X is at most (14D1,2 + 17D1,3 + 17D1,4 + 17D2,3 + 17D2,4 + 20D3,4)/6. Let Y be the distance represented by the 6-tuple (2, 3, 3, 3, 3, 4). Then by the Triangle Inequality,\n6(Y \u2212X) = \u22122D1,2 +D1,3 +D1,4 +D2,3 +D2,4 + 4D3,4\n= (D1,3 +D3,4 +D4,2 \u2212D2,1) + (D1,4 +D4,3 +D3,2 \u2212D2,1) + 2D3,4\n\u2265 0 + 0 + 2\u00d7 0 = 0.\nIn other words, we have shown that every element in A\\L is dominated by at least one element in L. Therefore, for any choice of {D1,2,D1,3,D1,4,D2,3,D2,4,D3,4} satisfying the Triangle Inequality, the optimal solutions of the TTP and LD-TTP are the same, i.e., OG4 = 0%.\nIn an earlier paper (Hoshino & Kawarabayashi, 2012), the authors conjectured that OG6 > 0%, although we were unable to find a 6-team instance with a positive optimality gap. Here we present a simple instance to show that OG6 \u2265 1 43 \u223c 2.3%.\nLet \u0393 be the 6-team instance with D1,2 = D5,6 = 2 and all other Di,j = 1. Clearly these (\n6 2\n)\n= 15 distances satisfy the Triangle Inequality. We now show that X\u0393 = 43 and X\u2217\u0393 = 44, thus proving that OG6 \u2265 1 43 . Consider Table 15, which is a solution to the TTP (but not LD-TTP) with 43 trips.\nBy inspection, we see that no team travels along the bridge connecting the stadiums of t1 and t2, or along the bridge connecting the stadiums of t5 and t6. Thus, the total travel distance must be 43\u00d7 1 = 43, since the 2-unit distances D1,2 and D5,6 do not appear in the total sum. Since every 6-team tournament must have at least 43 total trips (see Table 13), this proves that X\u0393 = 43.\nFor each of the 295 potentially-optimal LD-TTP schedules in Theorem 2, we consider all 6! = 720 permutations of (t1, t2, t3, t4, t5, t6) to see if any tournament can have total distance 43. A computer search shows that 36 of the 295 schedules can have total distance 44, but none can have distance 43. This proves that X\u2217\u0393 = 44 is the optimal LD-TTP travel distance for this instance \u0393.\nTherefore, the maximum optimality gap OG6 is at least 1 43 \u223c 2.3%. We ask whether\nthis gap can be made larger, and propose the following question.\nProblem 1. Determine the value of OGn for n \u2265 6.\nSuppose that OG6 = 5%. Then one of the 295 LD-TTP solutions in Theorem 2 is at most 5% higher than the optimal TTP solution, found at a fraction of the computational cost. Of course, this is not necessary for the case n = 6 as we can use integer and constraint programming to output the TTP solution in a reasonable amount of time. However, for larger values of n, this linear distance relaxation technique would allow us to quickly generate close-to-optimal solutions when the exact optimal total distance is unknown or too difficult computationally. We are hopeful that this approach will help us develop better upper bounds for large unsolved benchmark instances."}, {"heading": "8. Conclusion", "text": "In many professional sports leagues, teams are divided into two conferences, where teams have intra-league games within their own conference as well as inter-league games against teams from other conference. The TTP models intra-league tournament play. The NPcomplete Bipartite Traveling Tournament Problem (Hoshino & Kawarabayashi, 2011) models inter-league play, and it would be interesting to see whether our linear distance relaxation can also be applied to bipartite instances to help formulate new ideas in inter-league tournament scheduling.\nWe conclude the paper by proposing two new benchmark instances for the Traveling Tournament Problem, as well as an open problem and a conjecture on the Linear Distance TTP. We first begin with the benchmark instances.\nFor each n \u2265 4, define LINEn to be the instance where the n teams are located on a straight line, with a distance of one unit separating each pair of adjacent teams, i.e., dk = 1 for all 1 \u2264 k \u2264 n \u2212 1. And define INCRn to be the increasing-distance scenario where the n teams are arranged so that dk = k for all 1 \u2264 k \u2264 n\u2212 1. Figure 6 illustrates the location of each team in INCR6.\nBy definition, the TTP solution matches the LD-TTP solution for each of these two instances. By Theorem 1, the optimal solutions for LINE6 and INCR6 have total distance 84 and 250, respectively. This naturally motivates the following problem:\nProblem 2. Solve the TTP for the instances LINEn and INCRn, for n \u2265 8.\nWe conclude with one more problem, inspired by Theorem 2 which listed all seven possible optimal distances for the 6-team LD-TTP:\nProblem 3. Let PDn denote the number of possible distances that can be a solution to the n-team LD-TTP. For example, PD4 = 1 and PD6 = 7. Prove or disprove that PDn is exponential in n."}, {"heading": "Acknowledgments", "text": "This research has been partially supported by the Japan Society for the Promotion of Science (Grant-in-Aid for Scientific Research), the C & C Foundation, the Kayamori Foundation, and the Inoue Research Award for Young Scientists. The authors thank Brett Stevens from Carleton University for suggesting the idea of the Linear Distance TTP during the 2010 Winter Meeting of the Canadian Mathematical Society."}, {"heading": "Appendix A", "text": "We used Maplesoft (www.maplesoft.com) to generate the set of optimal LD-TTP schedules for n = 4 and n = 6. In this appendix, we explain the process by which we generated the 36 optimal schedules for the case n = 4.\nTo simplify notation, we used the numbers 1 to 4 to represent the team numbers of opponents for road games, and the numbers 11 to 14 to represent the team numbers of opponents for home games. Thus, in our notation, the schedule on the left (from Table 2) is identical to the 4\u00d7 6 matrix on the right.\nTeam 1 2 3 4 5 6 t1 t4 t3 t2 t4 t3 t2 t2 t3 t4 t1 t3 t4 t1 t3 t2 t1 t4 t2 t1 t4 t4 t1 t2 t3 t1 t2 t3\n14 13 2 4 3 12 13 14 11 3 4 1 2 1 14 12 11 4 1 2 3 11 12 13\nTo produce the set of 36 schedules, the following code was used:\nrestart: with(combinat):"}, {"heading": "A1 := \u2018<,>\u2018(12, 1, 14, 3): A2 := \u2018<,>\u2018(12, 1, 4, 13):", "text": ""}, {"heading": "A3 := \u2018<,>\u2018(2, 11, 14, 3): A4 := \u2018<,>\u2018(2, 11, 4, 13):", "text": ""}, {"heading": "B1 := \u2018<,>\u2018(13, 14, 1, 2): B2 := \u2018<,>\u2018(13, 4, 1, 12):", "text": ""}, {"heading": "B3 := \u2018<,>\u2018(3, 14, 11, 2): B4 := \u2018<,>\u2018(3, 4, 11, 12):", "text": ""}, {"heading": "C1 := \u2018<,>\u2018(14, 13, 2, 1): C2 := \u2018<,>\u2018(14, 3, 12, 1):", "text": ""}, {"heading": "C3 := \u2018<,>\u2018(4, 13, 2, 11): C4 := \u2018<,>\u2018(4, 3, 12, 11):", "text": "Z[{1, 2}] := d1: Z[{2, 3}] := d2: Z[{3, 4}] := d3: Z[{1, 3}] := d1+d2: Z[{1, 4}] := d1+d2+d3: Z[{2, 4}] := d2+d3:\ndist := proc (myinput, k) local i, myseq, x; x := 0; myseq := [7, op(myinput), 7]; for i to 7 do\nif 7<= myseq[i] and 7<= myseq[i+1] then x:=x elif 7<= myseq[i] and myseq[i+1]<7 then x:=x+Z[{myseq[i+1],k}] elif myseq[i]<7 and 7<= myseq[i+1] then x:=x+Z[{myseq[i],k}]\nelif myseq[i]<7 and myseq[i+1]<7 then x:=x+Z[{myseq[i+1],myseq[i]}] else RETURN(ERROR) fi:\nod: x: end:\nchecker := proc (my720) local k, flag, x, y, goodlist, temp; goodlist := NULL; for k to 720 do\ntemp := Matrix([seq(my720[k][t], t = 1 .. 6)]); flag := 0; for x to 4 do for y to 5 do\nif abs(temp[x][y]-temp[x][y+1])=10 then flag:=1 fi:\nod: od: for x to 4 do\nif dist([seq(temp[x,k],k = 1..6)],x)<>2*(d1+d2+d3) then flag := 1 fi:\nod: if flag = 0 then goodlist := goodlist, temp: fi:\nod: goodlist: end:\nmy720 := permute([A1, A4, B1, B4, C1, C4]): set1 := checker(my720): my720 := permute([A1, A4, B1, B4, C2, C3]): set2 := checker(my720): my720 := permute([A1, A4, B2, B3, C1, C4]): set3 := checker(my720): my720 := permute([A1, A4, B2, B3, C2, C3]): set4 := checker(my720): my720 := permute([A2, A3, B1, B4, C1, C4]): set5 := checker(my720): my720 := permute([A2, A3, B1, B4, C2, C3]): set6 := checker(my720): my720 := permute([A2, A3, B2, B3, C1, C4]): set7 := checker(my720): my720 := permute([A2, A3, B2, B3, C2, C3]): set8 := checker(my720): finallist := [set1, set2, set3, set4, set5, set6, set7, set8];"}, {"heading": "Appendix B", "text": "We now provide the Maplesoft code from which we generated the 295 non-isomorphic schedules in Theorem 2. Due to symmetry, we only need to consider the cases S1, S2, S3, S4. The authors would be happy to provide the full set of 295 schedules (available as a simple .txt file upon request), and/or answer any questions that explain why this code generates the complete set of optimal schedules for the n = 6 case of the LD-TTP.\nrestart: with(combinat):\nZ := Matrix(6, 6, 0): Z[1, 2] := a: Z[1, 3] := a+b: Z[1, 4] := a+b+c: Z[1, 5] := a+b+c+d: Z[1, 6] := a+b+c+d+e: Z[2, 3] := b: Z[2, 4] := b+c: Z[2, 5] := b+c+d: Z[2, 6] := b+c+d+e: Z[3, 4] := c: Z[3, 5] := c+d: Z[3, 6] := c+d+e: Z[4, 5] := d: Z[4, 6] := d+e: Z[5, 6] := e: for i to 6 do for j from i+1 to 6 do Z[j, i] := Z[i, j] od: od:\nall252 := choose(10, 5): combos := []:\nfor i to 252 do\ntest := all252[i]: flag := 0: for j to 2 do if test[j+3]-test[j] <= 3 then flag := 1: fi: od: for j to 4 do if test[j+1]-test[j] >= 5 then flag := 1: fi: od: if \u2018or\u2018(test[1] >= 5, test[5] <= 6) then flag := 1 fi: if flag = 0 then combos := [op(combos), test]: fi:\nod:\ntotaldist := proc (myinput, k) local i, myseq, y; y := 0; myseq := [7, op(myinput), 7]; for i to 11 do\nif 7<= myseq[i] and 7<= myseq[i+1] then y:=y elif 7<= myseq[i] and myseq[i+1]<7 then y:=y+Z[myseq[i+1],k] elif myseq[i]<7 and 7<= myseq[i+1] then y:=y+Z[myseq[i],k] elif myseq[i]<7 and myseq[i+1]<7 then y:=y+Z[myseq[i+1],myseq[i]] else RETURN(ERROR) fi:\nod: y: end:\ngetseq := proc (myfive, k) local myperm, myseq, mylist, i, j; mylist := []; myperm := permute(\u2018minus\u2018({1, 2, 3, 4, 5, 6}, {k})); for i to 120 do myseq := [seq(7, i = 1 .. 10)];\nfor j to 5 do myseq[myfive[j]] := myperm[i][j]: od: mylist := [op(mylist), myseq]\nod: mylist: end:\ncheckdup := proc (tryj, j, tryk, k) local i, val1, val2, x; x := 0; i:=0: while x=0 and i<10 do\ni:=i+1; if tryj[i]=tryk[i] and tryj[i]<7 then x:=1: fi: od:\ni:=0: while x=0 and i<10 do\ni:=i+1; if tryj[i]=k then if tryk[i]<7 then x:=1: fi: fi: od:\ni:=0: while x=0 and i<10 do\ni:=i+1; if tryk[i]=j then if tryj[i]<7 then x:=1: fi: fi: od:\ni:=0: while x=0 and i<10 do\ni:=i+1; if tryk[i]=j then val1:=i fi: if tryj[i]=k then val2:=i: fi: od:\nif x = 0 then if abs(val1-val2) <= 1 then x := 1: fi: fi: x: end:\nfivetuple := proc (myset) [coeff(myset,a),coeff(myset,b),coeff(myset,c),coeff(myset,d),coeff(myset,e)]: end:\nfor p to 5 do for q to 5 do for r to 5 do for s to 5 do for t to 5 do for k to 6 do\nS[k, [2*p, 2*q, 2*r, 2*s, 2*t]] := NULL:\nod: od: od: od: od: od: for kk to 6 do allvals[kk] := {}: od:\nfor r to 194 do x := getseq(combos[r], 1): for s to 120 do if \u2018in\u2018(2, {seq(x[s][k], k = 6 .. 10)}) then y := fivetuple(totaldist(x[s], 1)); allvals[1] := {y, op(allvals[1])}; S[1, y] := S[1, y], x[s] fi: od: od:\nfor r to 194 do x := getseq(combos[r], 2): for s to 120 do y := fivetuple(totaldist(x[s], 2)); allvals[2] := {y, op(allvals[2])}; S[2, y] := S[2, y], x[s] od: od:\nfor r to 194 do x := getseq(combos[r], 3); for s to 120 do y := fivetuple(totaldist(x[s], 3)); allvals[3] := {y, op(allvals[3])}; S[3, y] := S[3, y], x[s] od: od:\nfor r to 194 do x := getseq(combos[r], 4); for s to 120 do y := fivetuple(totaldist(x[s], 4)); allvals[4] := {y, op(allvals[4])}; S[4, y] := S[4, y], x[s] od: od:\nfor r to 194 do x := getseq(combos[r], 5); for s to 120 do y := fivetuple(totaldist(x[s], 5)); allvals[5] := {y, op(allvals[5])}; S[5, y] := S[5, y], x[s] od: od:\nfor r to 194 do x := getseq(combos[r], 6); for s to 120 do y := fivetuple(totaldist(x[s], 6)); allvals[6] := {y, op(allvals[6])}; S[6, y] := S[6, y], x[s] od: od:\nfor pp to 10 do for qq to 10 do for rr to 10 do for ss to 10 do\ntriplet1[[2*pp, 2*qq, 2*rr, 2*ss, 6]] := []: od: od: od: od:\nfor pp to 10 do for qq to 10 do for rr to 10 do for ss to 10 do\ntriplet2[[6, 2*ss, 2*rr, 2*qq, 2*pp]] := []: od: od: od: od:\nfor pp to nops(allvals[1]) do for qq to nops(allvals[2]) do for rr to nops(allvals[3]) do\nval := allvals[1][pp]+allvals[2][qq]+allvals[3][rr]; triplet1[val] := [op(triplet1[val]), [pp, qq, rr]]\nod: od: od:\nfor pp to nops(allvals[4]) do\nfor qq to nops(allvals[5]) do for rr to nops(allvals[6]) do\nval := allvals[4][pp]+allvals[5][qq]+allvals[6][rr]; triplet2[val] := [op(triplet2[val]), [pp, qq, rr]]\nod: od: od:\ngetnext := proc (inputset, x, setx) local i, k1, k2, k3, candx, mylist; mylist := NULL; k1 := op(\u2018minus\u2018({1, 2, 3, 4, 5, 6, 7}, {op(inputset[1])})); k2 := op(\u2018minus\u2018({1, 2, 3, 4, 5, 6, 7}, {op(inputset[2])})); k3 := op(\u2018minus\u2018({1, 2, 3, 4, 5, 6, 7}, {op(inputset[3])})); for i to nops(setx) do candx := setx[i];\nif checkdup(candx, x, inputset[1], k1) = 0 then if checkdup(candx, x, inputset[2], k2) = 0 then if checkdup(candx, x, inputset[3], k3) = 0 then mylist := mylist, candx fi: fi: fi: od:\n[mylist]: end:\ngetpos := proc (aval, bval, cval, dval) local pos3, pos4, pos5, pos6; if aval = 3 then pos3 := 2 elif aval = 4 then pos4 := 2 elif aval = 5 then\npos5 := 2 elif aval = 6 then pos6 := 2 else RETURN(ERROR) end if;\nif bval = 3 then pos3 := 3 elif bval = 4 then pos4 := 3 elif bval = 5 then\npos5 := 3 elif bval = 6 then pos6 := 3 else RETURN(ERROR) end if;\nif cval = 3 then pos3 := 7 elif cval = 4 then pos4 := 7 elif cval = 5 then\npos5 := 7 elif cval = 6 then pos6 := 7 else RETURN(ERROR) end if;\nif dval = 3 then pos3 := 8 elif dval = 4 then pos4 := 8 elif dval = 5 then\npos5 := 8 elif dval = 6 then pos6 := 8 else RETURN(ERROR) end if;\n[pos3, pos4, pos5, pos6]: end:\nfirsttwo := proc (aval, bval, cval, dval,new1,new2) local pairs12, p, q, i, t1, t2, flag; pairs12 := {}; for p to nops(new1) do for q to nops(new2) do\nif checkdup(new1[p], 1, new2[q], 2) = 0 then if new1[p][4] <> bval and new1[p][6] <> cval and new1[p][9] <> dval and\nnew2[q][2] <> aval and new2[q][5] <> bval and new2[q][7] <> cval then\nflag := 0; t1:=[2,aval,bval,new1[p][4],new1[p][5],new1[p][6],cval,dval,new1[p][9],2]; t2:=[1,new2[q][2],aval,bval,new2[q][5],new2[q][6],new2[q][7],cval,dval,1]; for i to 9 do if t1[i]=t2[i+1] and t1[i+1]=t2[i] then flag:=1 fi: od: if flag = 0 then pairs12 := {op(pairs12), [new1[p], new2[q]]} fi: fi: fi:\nod: od: pairs12: end:\nfirstthree := proc (pairs12, sixpos, new6) local last6, mytry, trips126, p, q, k; last6 := {}; trips126 := {}; for k to nops(new6) do mytry := new6[k];\nif mytry[sixpos] = 1 and mytry[sixpos+1] = 2 then last6 := {op(last6), mytry} fi:\nod: for p to nops(pairs12) do for q to nops(last6) do\nif checkdup(pairs12[p][1], 1, last6[q], 6) = 0 and\ncheckdup(pairs12[p][2], 2, last6[q], 6) = 0 then\ntrips126 := {op(trips126), [op(pairs12[p]), last6[q]]}: fi:\nod: od: trips126: end:\nsteps126 := proc (new1, new2, new6) local i, j, k, finalsol; finalsol := NULL; for i to nops(new1) do for j to nops(new2) do\nif checkdup(new1[i], 1, new2[j], 2) = 0 then\nfor k to nops(new6) do\nif checkdup(new1[i], 1, new6[k], 6) = 0 and checkdup(new2[j], 2, new6[k], 6) = 0 then finalsol := finalsol, [new1[i], new2[j], new6[k]]:\nfi: od: fi: od: od:\n[finalsol]: end:\nsteps345 := proc (iset, new3, new4, new5) local mylist, tryd, trye, tryf, candd, cande, candf, a, b, c; mylist := NULL; tryd := getnext(iset, 3, new3); if tryd <> [] then trye := getnext(iset, 4, new4); if trye <> [] then tryf := getnext(iset, 5, new5); if tryf <> [] then for a to nops(tryd) do candd := tryd[a]; for b to nops(trye) do cande := trye[b]; if checkdup(candd, 3, cande, 4) = 0 then for c to nops(tryf) do candf := tryf[c]; if checkdup(candf, 5, candd, 3) = 0 then if checkdup(candf, 5, cande, 4) = 0 then mylist := mylist, [iset[1], iset[2], candd, cande, candf, iset[3]]: fi: fi: od: fi: od: od: fi: fi: fi: [mylist]: end:\nallsix := proc (my126,aval,bval,cval,dval,new3,new4,new5) local last3, last4, last5, k, mytry, tempval, pos3, pos4, pos5, finalresult, p, q, r, s, trips345, my345, valnext, finalans; last3:={}; last4:={}; last5:={}; finalresult:={}; trips345:={}; tempval := getpos(aval, bval, cval, dval); pos3 := tempval[1]; pos4 := tempval[2]; pos5 := tempval[3];\nfor k to nops(new3) do mytry := new3[k];\nif mytry[pos3] = 1 and mytry[pos3+1] = 2 then if checkdup(my126[1], 1, mytry, 3) = 0 and\ncheckdup(my126[2], 2, mytry, 3) = 0 and checkdup(my126[3], 6, mytry, 3) = 0 then last3 := {op(last3), mytry} fi: fi:\nod: for k to nops(new4) do mytry := new4[k];\nif mytry[pos4] = 1 and mytry[pos4+1] = 2 then if checkdup(my126[1], 1, mytry, 4) = 0 and\ncheckdup(my126[2], 2, mytry, 4) = 0 and checkdup(my126[3], 6, mytry, 4) = 0 then last4 := {op(last4), mytry} fi: fi:\nod: for k to nops(new5) do mytry := new5[k];\nif mytry[pos5] = 1 and mytry[pos5+1] = 2 then if checkdup(my126[1], 1, mytry, 5) = 0 and\ncheckdup(my126[2], 2, mytry, 5) = 0 and checkdup(my126[3], 6, mytry, 5) = 0 then last5 := {op(last5), mytry} fi: fi:\nod: for p to nops(last3) do for q to nops(last4) do\nif checkdup(last3[p], 3, last4[q], 4) = 0 then\nfor r to nops(last5) do\nif checkdup(last3[p], 3, last5[r], 5) = 0 and\ncheckdup(last4[q], 4, last5[r], 5) = 0 then trips345 := {op(trips345), [last3[p], last4[q], last5[r]]}:\nfi: od: fi: od: od: for s to nops(trips345) do my345 := trips345[s]; finalresult := {op(finalresult),\n[my126[1], my126[2], my345[1], my345[2], my345[3], my126[3]]}:\nod: finalresult: end:\ncheckallsolutions := proc(sixtuples) local k,rr,mysolutions,cand1,cand2,cand3,cand4,cand5,cand6, new1,new2,new3,new4,new5,new6,mytry,firsthalf,val: mysolutions := []: for rr to nops(sixtuples) do\ncand1 := [S[1, allvals[1][sixtuples[rr][1]]]]; cand2 := [S[2, allvals[2][sixtuples[rr][2]]]]; cand3 := [S[3, allvals[3][sixtuples[rr][3]]]]; cand4 := [S[4, allvals[4][sixtuples[rr][4]]]]; cand5 := [S[5, allvals[5][sixtuples[rr][5]]]]; cand6 := [S[6, allvals[6][sixtuples[rr][6]]]];\nnew1 := {}; new2 := {}; new3 := {}; new4 := {}; new5 := {}; new6 := {}; for k to nops(cand1) do mytry := cand1[k]; new1 := {mytry, op(new1)}: od: for k to nops(cand2) do mytry := cand2[k]; new2 := {mytry, op(new2)}: od: for k to nops(cand3) do mytry := cand3[k]; new3 := {mytry, op(new3)}: od: for k to nops(cand4) do mytry := cand4[k]; new4 := {mytry, op(new4)}: od: for k to nops(cand5) do mytry := cand5[k]; new5 := {mytry, op(new5)}: od: for k to nops(cand6) do mytry := cand6[k]; new6 := {mytry, op(new6)}: od: firsthalf := steps126(new1, new2, new6); for k to nops(firsthalf) do val:=steps345(firsthalf[k],new3,new4,new5); if val <> [] then mysolutions := [op(mysolutions), op(val)]: fi:\nod: od: mysolutions: end:\ngeneratesolutions := proc(sixtuples) local cand1,cand2,cand3,cand4,cand5,cand6,new1,new2,new3,new4,new5,new6,\nk,rr,x,y,mytry,flag,aval,bval,cval,dval,pairs12,sixpos,trips126,my24,sols: sols := {}: my24 := permute([3,4,5,6]):\nfor rr to nops(sixtuples) do\ncand1 := [S[1, allvals[1][sixtuples[rr][1]]]]; cand2 := [S[2, allvals[2][sixtuples[rr][2]]]]; cand3 := [S[3, allvals[3][sixtuples[rr][3]]]]; cand4 := [S[4, allvals[4][sixtuples[rr][4]]]]; cand5 := [S[5, allvals[5][sixtuples[rr][5]]]]; cand6 := [S[6, allvals[6][sixtuples[rr][6]]]]; new1:={}; new2:={}; new3:={}; new4:={}; new5:={}; new6:={}; for k to nops(cand1) do mytry := cand1[k];\nif {mytry[1], mytry[2], mytry[3], mytry[7], mytry[8]} = {7} and mytry[10] = 2 then new1 := {mytry, op(new1)}: fi: od:\nfor k to nops(cand2) do mytry := cand2[k];\nif {mytry[3], mytry[4], mytry[8], mytry[9], mytry[10]} = {7} and mytry[1] = 1 then new2 := {mytry, op(new2)}: fi: od:\nfor k to nops(cand3) do mytry := cand3[k]; flag := 0;\nif \u2018and\u2018(mytry[1] > 2, mytry[10] > 2) then if mytry[2] = 1 and mytry[3] = 2 then flag := 1 fi: if mytry[3] = 1 and mytry[4] = 2 then flag := 1 fi: if mytry[7] = 1 and mytry[8] = 2 then flag := 1 fi: if mytry[8] = 1 and mytry[9] = 2 then flag := 1 fi: if flag = 1 then new3 := {mytry, op(new3)}: fi: fi: od:\nfor k to nops(cand4) do mytry := cand4[k]; flag := 0;\nif \u2018and\u2018(mytry[1] > 2, mytry[10] > 2) then if mytry[2] = 1 and mytry[3] = 2 then flag := 1 fi: if mytry[3] = 1 and mytry[4] = 2 then flag := 1 fi: if mytry[7] = 1 and mytry[8] = 2 then flag := 1 fi: if mytry[8] = 1 and mytry[9] = 2 then flag := 1 fi: if flag = 1 then new4 := {mytry, op(new4)}: fi: fi: od:\nfor k to nops(cand5) do mytry := cand5[k]; flag := 0;\nif \u2018and\u2018(mytry[1] > 2, mytry[10] > 2) then if mytry[2] = 1 and mytry[3] = 2 then flag := 1 fi: if mytry[3] = 1 and mytry[4] = 2 then flag := 1 fi: if mytry[7] = 1 and mytry[8] = 2 then flag := 1 fi: if mytry[8] = 1 and mytry[9] = 2 then flag := 1 fi: if flag = 1 then new5 := {mytry, op(new5)}: fi: fi: od:\nfor k to nops(cand6) do mytry := cand6[k]; flag := 0;\nif \u2018and\u2018(mytry[1] > 2, mytry[10] > 2) then if mytry[2] = 1 and mytry[3] = 2 then flag := 1 fi: if mytry[3] = 1 and mytry[4] = 2 then flag := 1 fi: if mytry[7] = 1 and mytry[8] = 2 then flag := 1 fi: if mytry[8] = 1 and mytry[9] = 2 then flag := 1 fi: if flag = 1 then new6 := {mytry, op(new6)}: fi: fi: od:\nfor x to 24 do\naval := my24[x][1]; bval := my24[x][2]; cval := my24[x][3]; dval := my24[x][4]; pairs12 := firsttwo(aval, bval, cval, dval,new1,new2); sixpos := getpos(aval, bval, cval, dval)[4]; trips126 := firstthree(pairs12, sixpos, new6); for y to nops(trips126) do\nsols := {op(sols),op(allsix(trips126[y],\naval,bval,cval,dval,new3,new4,new5))}:\nod:\nod:\nod: sols: end:\nS4cases := []: for pp to 8 do for qq to 8 do\nxx := triplet1[[8, 10, 2*pp, 2*qq, 6]]; yy := triplet2[[6, 6, 20-2*pp, 22-2*qq, 8]]; for u in xx do for v in yy do S4cases := [op(S4cases), [op(u), op(v)]]:\nod: od: od: od: SolutionsForS4 := generatesolutions(S4cases):\nS3cases := []: for pp from 2 to 8 do for qq to 8 do\nxx := triplet1[[8, 10, 2*pp, 2*qq, 6]]; yy := triplet2[[6, 6, 22-2*pp, 18-2*qq, 8]]; for u in xx do for v in yy do S3cases := [op(S3cases), [op(u), op(v)]]:\nod: od: od: od: SolutionsForS3 := generatesolutions(S3cases):\nS2cases := []: for pp to 9 do for qq to 9 do\nxx := triplet1[[10, 10, 2*pp, 2*qq, 6]]; yy := triplet2[[6, 6, 20-2*pp, 18-2*qq, 8]]; for u in xx do for v in yy do S2cases := [op(S2cases), [op(u), op(v)]]:\nod: od: od: od: SolutionsForS2 := checkallsolutions(S2cases):\nS1cases := []: for pp to 8 do for qq to 8 do for rr to 8 do\nxx := triplet1[[8, 2*pp, 2*qq, 2*rr, 6]]: yy := triplet2[[6, 18-2*pp, 20-2*qq, 18-2*rr, 8]]: for u in xx do for v in yy do S1cases := [op(S1cases), [op(u), op(v)]]:\nod: od: od: od: od: SolutionsForS1 := checkallsolutions(S1cases):"}], "references": [{"title": "The traveling tournament problem: description and benchmarks", "author": ["K. Easton", "G. Nemhauser", "M. Trick"], "venue": "Proceedings of the 7th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Easton et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Easton et al\\.", "year": 2001}, {"title": "Constructive algorithms for the constant distance traveling tournament problem", "author": ["N. Fujiwara", "S. Imahori", "T. Matsui", "R. Miyashiro"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "Fujiwara et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Fujiwara et al\\.", "year": 2007}, {"title": "Scheduling bipartite tournaments to minimize total travel distance", "author": ["R. Hoshino", "K. Kawarabayashi"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Hoshino and Kawarabayashi,? \\Q2011\\E", "shortCiteRegEx": "Hoshino and Kawarabayashi", "year": 2011}, {"title": "The linear distance traveling tournament problem", "author": ["R. Hoshino", "K. Kawarabayashi"], "venue": "Proceedings of the 26th AAAI Conference on Artificial Intelligence,", "citeRegEx": "Hoshino and Kawarabayashi,? \\Q2012\\E", "shortCiteRegEx": "Hoshino and Kawarabayashi", "year": 2012}, {"title": "A new branch-and-price algorithm for the traveling tournament problem", "author": ["S. Irnich"], "venue": "European Journal of Operational Research,", "citeRegEx": "Irnich,? \\Q2010\\E", "shortCiteRegEx": "Irnich", "year": 2010}, {"title": "Scheduling in sports: An annotated bibliography", "author": ["G. Kendall", "S. Knust", "C. Ribeiro", "S. Urrutia"], "venue": "Computers and Operations Research,", "citeRegEx": "Kendall et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kendall et al\\.", "year": 2010}, {"title": "Complexity of the traveling tournament problem", "author": ["C. Thielen", "S. Westphal"], "venue": "Theoretical Computer Science,", "citeRegEx": "Thielen and Westphal,? \\Q2010\\E", "shortCiteRegEx": "Thielen and Westphal", "year": 2010}, {"title": "Challenge traveling tournament problems.. [Online; accessed 9-June-2012", "author": ["M. Trick"], "venue": null, "citeRegEx": "Trick,? \\Q2012\\E", "shortCiteRegEx": "Trick", "year": 2012}, {"title": "An improved approximation algorithm for the traveling tournament problem", "author": ["D. Yamaguchi", "S. Imahori", "R. Miyashiro", "T. Matsui"], "venue": "Annals of Operations Research,", "citeRegEx": "Yamaguchi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Yamaguchi et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 7, "context": "In Section 6, we apply our theories to all known (non-linear) 6-team benchmark sets (Trick, 2012), and show that in all cases, the optimal solution appears in our list of 295.", "startOffset": 84, "endOffset": 97}, {"referenceID": 0, "context": "To illustrate with a specific example, Table 1 lists the distance-optimal schedule (Easton et al., 2001) for a bechmark set known as NL6 (six teams from Major League Baseball\u2019s National League).", "startOffset": 83, "endOffset": 104}, {"referenceID": 7, "context": "Based on the NL6 distance matrix (Trick, 2012), the tournament schedule in Table 1 requires 23916 miles of total team travel, which can be shown to be the minimum distance possible.", "startOffset": 33, "endOffset": 46}, {"referenceID": 7, "context": "The solution to CIRC6 (Trick, 2012), where Di,j = min{j\u2212 i, 6\u2212 (j\u2212 i)} for all 1 \u2264 i < j \u2264 6, is an element of S1.", "startOffset": 22, "endOffset": 35}, {"referenceID": 7, "context": "From the NL6 distance matrix (Trick, 2012), we have (d1, d2, d3, d4, d5) = (605, 521, 257, 80, 337).", "startOffset": 29, "endOffset": 42}, {"referenceID": 4, "context": "A sophisticated branch-and-price heuristic (Irnich, 2010) solved NL6 in just over one minute, yet required three hours to solve CIRC6.", "startOffset": 43, "endOffset": 57}, {"referenceID": 7, "context": "We apply our construction to the 10-team and 16-team instances of our earlier examples (Trick, 2012).", "startOffset": 87, "endOffset": 100}], "year": 2012, "abstractText": "In some domestic professional sports leagues, the home stadiums are located in cities connected by a common train line running in one direction. For these instances, we can incorporate this geographical information to determine optimal or nearly-optimal solutions to the n-team Traveling Tournament Problem (TTP), an NP-hard sports scheduling problem whose solution is a double round-robin tournament schedule that minimizes the sum total of distances traveled by all n teams. We introduce the Linear Distance Traveling Tournament Problem (LD-TTP), and solve it for n = 4 and n = 6, generating the complete set of possible solutions through elementary combinatorial techniques. For larger n, we propose a novel \u201cexpander construction\u201d that generates an approximate solution to the LD-TTP. For n \u2261 4 (mod 6), we show that our expander construction produces a feasible double round-robin tournament schedule whose total distance is guaranteed to be no worse than 4 3 times the optimal solution, regardless of where the n teams are located. This 4 3 -approximation for the LD-TTP is stronger than the currently best-known ratio of 5 3 + for the general TTP. We conclude the paper by applying this linear distance relaxation to general (nonlinear) n-team TTP instances, where we develop fast approximate solutions by simply \u201cassuming\u201d the n teams lie on a straight line and solving the modified problem. We show that this technique surprisingly generates the distance-optimal tournament on all benchmark sets on 6 teams, as well as close-to-optimal schedules for larger n, even when the teams are located around a circle or positioned in three-dimensional space.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}