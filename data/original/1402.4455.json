{"id": "1402.4455", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Feb-2014", "title": "Symbiosis of Search and Heuristics for Random 3-SAT", "abstract": "When combined properly, search techniques can reveal the full potential of sophisticated branching heuristics. We demonstrate this observation on the well-known class of random 3-SAT formulae. First, a new branching heuristic is presented, which generalizes existing work on this class. Much smaller search trees can be constructed by using this heuristic. Second, we introduce a variant of discrepancy search, called ALDS. Theoretical and practical evidence support that ALDS traverses the search tree in a near-optimal order when combined with the new heuristic. Both techniques, search and heuristic, have been implemented in the look-ahead solver march. The SAT 2009 competition results show that march is by far the strongest complete solver on random k-SAT formulae.", "histories": [["v1", "Tue, 18 Feb 2014 19:59:58 GMT  (258kb)", "http://arxiv.org/abs/1402.4455v1", "Proceedings of the Third International Workshop on Logic and Search (LaSh 2010)"]], "COMMENTS": "Proceedings of the Third International Workshop on Logic and Search (LaSh 2010)", "reviews": [], "SUBJECTS": "cs.DS cs.AI", "authors": ["sid mijnders", "boris de wilde", "marijn heule"], "accepted": false, "id": "1402.4455"}, "pdf": {"name": "1402.4455.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Marijn J. H. Heule"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 2.\n44 55\nv1 [\ncs .D\nS] 1\n8 Fe\nb 20\n14"}, {"heading": "1 Introduction", "text": "Satisfiability (SAT) solvers have a rich history of branching heuristics [1]. These heuristics are crucial for fast performance. They can be split into decision heuristics and direction heuristics. The former selects for each node in the tree a decision variable to branch on. These decision heuristics determine the size of the search tree. For each free value of the decision variable a child node is created. Direction heuristics provide the preferred order in which these child nodes should be visited. In case a search tree contains solutions, effective direction heuristics can boost performance.\nTwo techniques are designed to repair errors made by branching heuristics. First, restart strategies [2] are used to compensate for ineffective choices made by decision heuristics. A new search tree is created after every restart. Second, discrepancy search [3], a technique used in Constraint Programming, focuses on those parts of the search tree that mostly follow the preference of the direction heuristics. This technique only changes the order in which the search tree is traversed.\nIn this paper, we present a new branching heuristic for look-ahead SAT solvers, called the recursive weight heuristic. This heuristic is a generalization of earlier lookahead evaluation heuristics [4\u20136]. Regarding the decision heuristic, we show that on random 3-SAT formulae the search tree is significantly smaller compared to alternative heuristics. Although the heuristic is quite expensive in terms of computational costs, performance is clearly improved.\nAlso, the new direction heuristic results in an observable bias in the distribution of solutions. To capitalize on this, we developed a new discrepancy search algorithm, called advanced limited discrepancy search (ALDS), which combines features of improved limited discrepancy search [7] and depth-bounded discrepancy search [8]. We\n\u22c6 Supported by the Dutch Organization for Scientific Research (NWO) under grant 617.023.611\nprovide both theoretical and experimental evidence to show that the combination of ALDS and the recursive weight heuristic, traverse the tree in a near-optimal order on random 3-SAT formulae.\nThe outline of the paper is as follows: First, we will explain look-ahead heuristics in Section 2, both the existing work and our new heuristic. In Section 3, various search techniques will be discussed. The focus will be discrepancy search and our variant of this technique. Section 4 will offer theoretical and practical results showing that the combination of ALDS and our heuristic is effective on random 3-SAT instances. Finally, we draw some conclusions in Section 5."}, {"heading": "2 Look-ahead heuristics", "text": "Most work on branching heuristics in the field of Satisfiability focuses on look-ahead SAT solvers [1]. In contrast to many other solvers, look-ahead solvers keep track of various statistical measurements that make it possible to use quite complex heuristics. In this section, we first will provide an overview of look-ahead SAT solvers. Afterwards, the branching heuristics in these solvers are discussed. We conclude this section by introducing an improved heuristic."}, {"heading": "2.1 Look-ahead SAT solvers", "text": "The look-ahead architecture for SAT solvers is based on the DPLL framework [9]: It is a complete solving method which selects in each step a decision variable xdecision and recursively calls DPLL for the reduced formula where xdecision is assigned to false (denoted by F [xdecision = 0]) and another where xdecision is assigned to true (denoted by F [xdecision = 1]).\nA formula F is reduced by unit propagation: Given a formula F , an unassigned variable x and a Boolean value B, first x is assigned to B. If this assignment \u03d5 results in a unit clause (clause of size 1) then \u03d5 is expanded by assigning the remaining literal of that clause to true. This is repeated until no unit clauses are left in \u03d5 applied to F . We denote by \u03d5 \u2217 F the reduced formula after unit propagation of applying \u03d5 on F , with all satisfied clauses removed. So, more specific than above, F [x =B] := \u03d5 \u2217 F .\nAlgorithm 1 UNITPROPAGATION( formula F , variable x, B \u2208 {0, 1} ) 1: \u03d5 := {x\u2190B} 2: while empty clause /\u2208 \u03d5 applied on F and unit clause (y) \u2208 \u03d5 applied on F do 3: \u03d5 := \u03d5 \u222a {y \u2190 1} 4: end while 5: return \u03d5 \u2217 F\nThe recursion has two kinds of leaf nodes: Either all clauses have been satisfied (denoted by \u03d5 \u2217 F = \u2205), meaning that a satisfying assignment has been found, or \u03d5 \u2217 F contains an empty clause (a clause of which all literals have been falsified), meaning a dead end. In the latter case the algorithm backtracks.\nThe core of the look-ahead architecture is the LOOKAHEAD procedure, which incorporates the branching heuristics (selecting a decision variable and selecting the first branch) and several reasoning techniques to reduce the size of the formula. Because the latter are beyond the scope of this paper, we refer the reader to [10] for details. Algorithm 2 shows the top level structure. Notice that the LOOKAHEAD procedure returns a reduced formulaF , variable xdecision, and value B. Fig. 1 provides a graphical overview of the architecture.\nAlgorithm 2 DPLL( formula F ) 1: if F = \u2205 then 2: return satisfiable 3: end if 4: < F ; xdecision; B> := LOOKAHEAD(F ) 5: if empty clause \u2208 F then 6: return unsatisfiable 7: end if 8: if DPLL( F [xdecision = B] ) = satisfiable then 9: return satisfiable 10: end if 11: return DPLL( F [xdecision = \u00acB] )\nThe LOOKAHEAD procedure, as the name suggests, performs look-aheads. A lookahead on x starts by assigning x to true followed by unit propagation. The importance of x is measured and possible reductions of the formula are detected. After this analysis, it backtracks, ending the look-ahead. The rationale of a look-ahead operation is that evaluating the effect of actually assigning variables to truth values and performing unit propagation is more adequate than taking a cheap guess using statistical data on F ."}, {"heading": "2.2 Look-ahead evaluation", "text": "Branching heuristics in look-ahead SAT solvers are based on evaluating the reduction of the formula during a look-ahead. This reduction is expressed using the difference or distance heuristic (in short DIFF). The larger the reduction, the higher the heuristic value. A DIFF could be based on many statistics, such as the reduction of the number of variables. Yet, all look-ahead SAT solvers use a DIFF based only on the set of newly created (i.e. reduced, but not satisfied) clauses, denoted by Cnew [10].\nThe decision variable xdecision is selected by combining for each variable xi the values DIFF(F , F [xi = 0]) and DIFF(F , F [xi = 1]). The objective of the decision heuristic is to construct a small and balanced search tree. The product of these numbers is generally considered to be an effective heuristic for this purpose [1]. The sum of these numbers can be used for tie-breaking.\nOnce xdecision is selected, the direction heuristics decide whether to branch first on F [xdecision = 0] or F [xdecision = 1]. Most solvers prefer the branch which is the most satisfiable [1,10]. A heuristic used to determine the most satisfiable branch selects Boolean value B for which DIFF(F , F [xi = B]) is the smallest.\nConsider the following example formula:\nFLA = (\u00acx1\u2228x3)\u2227(x1\u2228x2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x4)\u2227(x1\u2228\u00acx2\u2228\u00acx4)\u2227(x2\u2228\u00acx3\u2228x4)\nSince all clauses in FLA have size three or smaller, only new binary clauses can be created. For instance, during the look-ahead on \u00acx1, three new binary clauses are created (all clauses in which literal x1 occurs). The look-ahead on x1 will force x3 to be assigned to true by unit propagation. This will reduce the last clause to a binary clause, while all other clauses become satisfied. Similarly, we can compute the number of new binary clauses for all look-aheads \u2013 see Fig. 1.\nFinally, the selection of the decision variable is based on the reduction measurements of both the look-ahead on \u00acxi and xi. Generally, the product is used to combine the numbers. In this example, x2 would be selected as decision variable, because the product of the reduction measured while performing look-ahead on \u00acx2 and x2 is the highest (i.e. 4).\nThe DIFF heuristic based on the number of newly created clauses was introduced by Li and Anbulagan [4]. Several extensions have been proposed dealing with how to weigh clauses in Cnew. If the original formula is 3-SAT, Cnew only consists of binary clauses. For this special case, Li [5] uses in satz weights based on the occurrences of variables. Let #(x) denote the number of occurrences of literal x. Each clause (y\u2228z) \u2208\nCnew gets a weight of #(\u00acy) + #(\u00acz). A slight variation but much more effective weight is used by Dubois and Dequen [6] in their solver kcnfs. Their backbone search heuristic weighs a binary clause (y\u2228z) by #(\u00acy)\u00d7#(\u00acz). In case of k-SAT instances, Kullmann [11] uses in the OKsolver weights based on the length of clauses in Cnew. A clause of size k roughly get a weight of \u03b3k = 52\u2212k."}, {"heading": "2.3 Recursive weight heuristic", "text": "We developed a model to generalize existing work on look-ahead branching heuristics. We refer to this model as the recursive weight heuristic. Let VAR(F) refer to the set of variables in F and n = |VAR(F)|. The heuristic values hi(x) express for each iteration i how much literal x is forced to true by the clauses containing x. First, for all literals x, h0(x) are initialized on 1:\nh0(x) = h0(\u00acx) = 1 (1)\nAt each step, the heuristics values hi(x) are scaled using the average value \u00b5i:\n\u00b5i = 1\n2n\n\u2211\nx\u2208VAR(F)\n( hi(x) + hi(\u00acx) )\n(2)\nFinally, in each next iteration, the heuristic values hi+1(x) are computed in which literals y get weight hi(\u00acy)/\u00b5i. Weight \u03b3 expresses the relative importance of binary clauses. This weight could also be seen as the heuristic value of a falsified literal.\nhi+1(x) = \u2211\n(x\u2228y\u2228z)\u2208F\n(hi(\u00acy) \u00b5i \u00b7 hi(\u00acz) \u00b5i ) + \u03b3 \u2211\n(x\u2228y)\u2208F\nhi(\u00acy)\n\u00b5i (3)\nEarlier work on look-ahead heuristics can be formulated using the model above. For binary clause (y \u2228 z) \u2208 Cnew they compute a weight w\u2217i (y \u2228 z) = hi(\u00acy) \u2217 hi(\u00acz):\n\u2013 Li & Anbulagan 1997 [4]: w(y \u2228 z) = 1 = h0(\u00acy)\u00d7 h0(\u00acz), in short w \u00d7 0 .\n\u2013 Li 1999 [5]: w(y \u2228 z) = #(\u00acy) + #(\u00acz) = h1(\u00acy) + h1(\u00acz), in short w + 1 .\n\u2013 Dubois 2001 [6]: w(y \u2228 z) = #(\u00acy) \u00d7#(\u00acz) = h1(\u00acy)\u00d7 h1(\u00acz), in short w \u00d7 1 .\nAlthough [5,6] used \u03b3 = 5, we observed stronger performance using \u03b3 = 3.3. Also, the size of the tree can be reduced significantly by using weights w\u00d7i with i > 1.\nWe implementedw\u00d70 , w + 1 , w \u00d7 1 , w \u00d7 2 , w \u00d7 3 and w \u00d7 4 in the look-ahead solver march ks [12] with \u03b3 = 3.3. We experimented on 500 random 3-SAT formulae with 450 variables and 1915 clauses (phase transition density). To provide stable numbers, all instances were unsatisfiable. Fig. 2 shows the results. Clearly, the average size of the tree is smaller using w\u00d73 compared to the alternative heuristics. Although w \u00d7\n3 is much more expensive to compute, the average time to solve these instances has also decreased. Regarding the computational costs, we observed that w\u00d73 resulted in best performance of all w\u00d7i on random 3-SAT formulae. In case i > 3, the reduction of the size of the tree is not large enough to compensate for the additional cost to compute the weights.\nOur implementation with w\u00d73 participated as march hi at the SAT competition of 20091. It won the random unsatisfiable category. Apart from a few minor optimizations and fixes, the only difference compared to march ks (the winner in 2007) is the recursive weight heuristic. Both versions competed during SAT 2009 and march hi solved over 10% more unsatisfiable instances. For many instances in this category it was the only program to solve them."}, {"heading": "3 Heuristic search", "text": "Let us take a step back from SAT to consider how to capitalize on direction heuristics in general. We will first discuss the terminology of direction heuristics, and the ideas behind the most important heuristic search strategies. Afterwards, we will introduce an alternative search strategy, which is very powerful in combination with the recursive weight heuristic."}, {"heading": "3.1 Direction heuristics", "text": "There are various ways to explore search trees. Searching the entire tree for a specific goal node is costly. Therefore, search strategies have been developed to guide the search towards a goal node. To show that a problem has no solutions, the search has to be complete by visiting all leaf nodes. Complete search strategies will either detect a goal node or prove that none exists.\nIf a search tree contains goal nodes, direction heuristics predict which branches have a higher probability of leading to a goal node than others. The branch with the highest preference will be called the left branch. Any other branch is called a discrepancy. In the case of a binary search tree a discrepancy can also be referred to as the right branch.\n1 see http://www.satcompetition.org for details\nIn theory, direction heuristics are very powerful. Perfect direction heuristics would lead to the goal node immediately. If such a perfect direction heuristic would exist, given that it is computable in polynomial time, it would prove that P = NP . At each node direction heuristics have a probability of picking the correct branch as left branch. This probability is called the heuristic probability. Another probability that we define is the goal node probability. For each node it expresses the probability that the subtree with this node as root contains a goal node. The heuristic probability Pheur(v) and the goal node probability Pgoal(v) are related as follows:\nPgoal(v) = P ( goal-node(v) )\nPheur(v) = P ( goal-node(left-child(v)) | goal-node(v) )\nPgoal(left-child(v)) = P ( goal-node(left-child(v)) )\n= Pgoal(v) \u00b7 Pheur(v)\nIn the case of the binary search tree we can also define:\nPgoal(right-child(v)) = P ( goal-node(right-child(v)) )\n= Pgoal(v) \u00b7 (1 \u2212 Pheur(v))\nFor a given dataset D and search strategy S, Pgoal(v) denotes the fraction of formulae in D that contain solutions in the subtree rooted at v, while applying algorithm S.\nIt is observed [12], that heuristics tend to make more mistakes in the top of the search tree. As we get closer to the leaf nodes in the tree, the underlying problem has been simplified. Heuristics perform better on simplified problems. Therefore, it is expected that Pheur(v) increases while descending in the search tree. Consequently, direction heuristics are most likely to make mistakes near the root of the search tree.\nTo illustrate goal node probabilities throughout a tree, we will consider a direction heuristic with increasing Pheur(v) in a binary tree with a single solution, see Fig. 3. Notice that, if a problem has solutions, Pgoal(root) = 1.\nLooking at the goal node probabilities in this example, it shows that, although for each node individually the left child has a higher Pgoal(v) than the right child, when comparing all nodes at a certain depth no clear pattern can be observed between the Pgoal(v) values. While searching for the goal node, one wants to take the Pgoal(v) of the leaf nodes into account. In this example, when a search strategy visits the nodes with a high goal node probability first, it will on average visit less leaf nodes before finding a goal node. We will now discuss several complete search strategies."}, {"heading": "3.2 Depth first search", "text": "One of the best know search strategies is depth first search (DFS). DFS branches left until it reaches a leaf node, after which it backtracks chronologically. The order in which DFS visits leaf nodes, from left to right, is shown in Fig. 4. DFS traverses the minimum number of edges needed to explore the entire tree. When Pheur(v) = 0.5 for all nodes v in a binary tree, meaning that the direction heuristic might as well randomly select branches, Pgoal(v) is equal for every node v at the same depth, then DFS is the cheapest strategy to use. When direction heuristics are stronger than random selection, as in Fig. 3, alternative strategies traverse the tree more efficiently."}, {"heading": "3.3 Discrepancy search", "text": "Assume that direction heuristics perform significantly better than random branch selection. When some leaf node is not a goal node, the intuition is that the heuristic only took a small number of wrong branches on the path to this leaf node. Intuitively, tree search performs best when paths with a small number of discrepancies are explored first.\nLimited Discrepancy Search (LDS) LDS [3] explores first those parts of the search tree that have a small number of discrepancies. In each iteration of LDS the number of allowed discrepancies is incremented. Fig. 5 illustrates the iterations of LDS. LDS has some redundancy since it only sets an upper bound on the allowed number of discrepancies. Therefore, in iteration x, LDS examines the paths from previous iterations again.\nImproved Limited Discrepancy Search (ILDS) ILDS improves LDS by eliminating the redundancy. This is achieved by providing a maximum search depth d to the algorithm. Given this depth, at any point during its execution, the algorithm keeps track of\nthe remaining number of depths to be searched. As a consequence, in each iteration x, only the paths with exactly x discrepancies are explored (starting with x = 0). This way ILDS ensures that subtrees rooted at depth d are explored only once. All subtrees rooted at depth d are searched using DFS. The iterations of ILDS are shown in Fig. 6.\nDepth-bounded Discrepancy Search (DDS) By incrementally increasing the maximum depth up to which discrepancies are allowed to occur, DDS [8] differs from (I)LDS. More specific, DDS visits in each iteration i + 1, all branches at depth d < i, only the discrepancies at depth d = i, and no discrepancies are allowed for d > i. Exploring the search tree this way also removes the requirement of specifying a maximum depth. As can be seen in Fig. 7, DDS explores paths with multiple right branches at the top of the search tree relatively early. In specific cases where the direction heuristics are bad (heuristic probabilities are close to 0.5 in case of a binary tree) near the root of the tree, but suddenly get very good (close to 1) at a certain depth, it is useful to introduce multiple discrepancies at the top of the search tree early."}, {"heading": "3.4 Advanced Limited Discrepancy Search", "text": "The papers describing LDS [3], ILDS [7] and DDS [8] are precise on which leaf nodes are explored in each of the iteration stages. Yet, apart from the pseudocode, the order in which leaf nodes are visited within a single iteration stage is not explicitly specified. We will assume that the strategies are applied as described in the pseudocode. For ILDS, DDS this means that, in each iteration, leaf nodes are explored from left to right.\nBy combining features from ILDS and DDS, a new search strategy can be created. This search strategy uses the iterations of ILDS, while nodes within an iteration are visited according to DDS. More specific, nodes with the same number of discrepancies are visited from right to left. We call this strategy Advanced Limited Discrepancy Search (ALDS). The iterations of this strategy are shown in Fig. 8. Like ILDS, ALDS is only applied until a certain depth d, while subtrees rooted at d are explored using DFS.\nThis search strategy is inspired by an earlier experimental study on random 3-SAT instances, where we observed [12] two patterns regarding the goal node probabilities:\n1. Leaf nodes reached with less discrepancies have a higher goal node probability. 2. For leaf nodes reached with the same number of discrepancies, those reached with\ndiscrepancies closer to the root have a higher goal node probability.\nNotice that ALDS visits leaf nodes in the preferred order of these observations. In order to compare the various search strategies, we propose a model to approximate the performance. In this model, the top of the search tree, until depth d, is visited using discrepancy search, while all subtrees rooted at depth d are visited by DFS. The depth d at which DFS takes over from the discrepancy search is called the jump depth. So, using a jump depth d would result in 2d subtrees. Discrepancy search ensures that promising parts of the search tree are explored first, while DFS searches the remaining subtree with minimal branching overhead. Subtrees explored by DFS are considered leaf nodes in the discrepancy search.\nIf the size of subtrees rooted at depth d is substantial, the cost of traversing a subtree is much higher than the overhead of jumping from one subtree to another. Assuming that subtrees at the same depth do not differ much in size, the cost of finding a goal node can be approximated by the number of subtrees one expects to explore. For search trees\nwith a single solution, the expected cost can be computed using the Pgoal(v) values of the nodes at the jump depth:\nEgoal(d) = 1\n2d \u00b7\n2d \u2211\nv=1\n( order(v) \u00b7 Pgoal(v) )\n(4)\nFor a given depth d, subtrees are numbered chronologically from 1 to 2d and order(v) denotes the index at which subtree v will be visited in the specific search strategy. For example, the summation for ALDS using the goal node probabilities in Fig. 3 is:\n1 8 \u00b7 (1 \u00b7 .504 + 4 \u00b7 .056 + 3 \u00b7 .126 + 7 \u00b7 .014 + 2 \u00b7 .216 + 6 \u00b7 .024 + 5 \u00b7 .054 + 8 \u00b7 .006)\nThe table below shows the Egoal(3) values based on the Fig. 3 probabilities:\nDFS ILDS DDS ALDS\nEgoal(3) 0.3375 0.31225 0.26375 0.26225\nIn case of multiple goal nodes, the \u2019expected\u2019 cost can be computed for a set of instances. Solve the instances using a search strategy and determine the average number of subtrees visited at depth d. Divide the average number by 2d to obtain the average cost. We will denote this alternative by E\u2217goal(d)."}, {"heading": "4 Experiments", "text": "Two types of results are presented in this section: theoretical and experimental results. The theoretical results are based on a probabilistic model of heuristic tree search. Experiments have been performed with the look-ahead SAT solver march [12], the fastest solver on random 3-SAT benchmarks.\nWe compare several discrepancy-based search strategies on the theoretical model and on a dataset of random 3-SAT formulae. Additionally, two experiments were performed to determine how much ALDS could be improved."}, {"heading": "4.1 Theoretical results", "text": "Based on the increasing heuristic probability observation [12] we created a model with just one goal node. In this model we assign the heuristic probability as follows (based on the observed Pheur(v) values in [12]):\nPheur(v) = 0.56 + 0.015 \u00b7 depth(v) (5)\nEach leaf node v at depth 12 is assigned a goal node probability Pgoal(v) using the equations described in Section 3.1. This means Pgoal is calculated by multiplying the heuristic probabilities of the left and right children leading to that leaf node, starting at the root with Pheur(root) = 1. So, similar to the tree in Fig. 3, only using a much larger tree.\nIn practice search trees contain multiple goal nodes, but no generality is lost by putting just one goal node in the search tree of our model. This will only cause expected cost to find a goal node and other numerical results to be a little larger, but this will not favour any search strategy in particular. The difference in numerical results is acceptable because this model is only used to compare the search strategies to each other.\nBecause the goal node probability of each subtree is defined by our own model, the optimal order in which to search the subtrees is to go from high to low goal probability. The expected fraction of the tree that has to be searched before a goal node is reached is the area below each graph (see Fig. 9). ALDS performs best on the model. In addition, the difference between ALDS and the optimal search order is quite small."}, {"heading": "4.2 Satisfiability results", "text": "For the experimental results we used the look-ahead SAT solver march [12] with the recursive weight heuristic w\u00d73 as direction heuristic (see Section 2.3). The dataset for the experiments consisted of 20146 satisfiable random 3-SAT instances with 350 variables and 1491 clauses. The clauses-to-variables ratio is 4.26, which is the ratio where the probability of generating a satisfiable instance is about 50%, known as the phase transition density.\nFor each instance, the complete search tree was explored to find out which of the 4096 subtrees at depth 12 contained solutions. A depth of 12was chosen to keep the data\ncompact enough for practical use, but still perform discrepancy search on a significant part of the search tree. On average each instance contained 17.2 satisfiable subtrees.\nResults from the experiments are shown in Fig. 10. The vertical axis shows the fraction of problems that has not been solved yet. The horizontal axis displays the number of subtrees that have been explored. Compared to the theoretical results, these lines decrease faster. This can be explained by the fact that there is an average of 17.2 goal nodes per instance in this experiment compared to a single goal node in the theoretical model. The E\u2217goal(12) values correspond to the area below the graphs."}, {"heading": "4.3 Analysis", "text": "Similar to Section 4.1, we want to demonstrate that ALDS performs close to optimal on the dataset of random 3-SAT instances. Yet, due to multiple satisfying subtrees per instance, it is hard to determine the performance of the optimal search strategy. To approximate the optimal search strategy, we construct a Greedy search strategy. The Greedy search strategy is introduced in [12], and is constructed as follows:\n\u2013 Select the subtree in which most instances from the dataset have at least one solution. This subtree is next to be visited in this specific Greedy search strategy. \u2013 Remove from consideration all the instances in which the selected subtree has at least one solution.\n\u2013 Repeat above steps until all instances are removed from consideration. \u2013 The subtrees that have not been ordered yet, are placed at the end in ALDS order.\nThe construction of the Greedy search strategy requires a set of instances as input. We let Greedy(S) denote the Greedy search strategy that has been constructed with input set S. Any Greedy search strategy will perform very well for the given input set. To determine whether or not Greedy could actually make a good generalized search strategy, the dataset has been split into two parts, which we will call part A and part B. When Greedy(A) is applied to part A, the E\u2217goal(12) performance is very strong, as expected. However, when Greedy(A) is applied to part B of the dataset, the result is worse than using the ALDS search method. This can be observed in Fig. 11.\nFurthermore, the Greedy(S) lines on dataset S in Fig. 11 reach the horizontal axis after about 1024 of the 4096 subtrees. This is due to the limited size of the experiment. On a hypothetical collection of all possible random 3-SAT instances, this line could not reach the horizontal axis this quickly. To summarize: the Greedy search strategy benefits greatly from the limited size of the dataset. Yet, it seems unlikely that a greedy search strategy can be converted into a generalized search strategy in such a way that it will outperform ALDS.\nIn our second analysis of the performance of ALDS, we experimented with various linear models for the Pheur(v) values, see (6). Our motivation to use this linear model is that we observed that the model (5) is an accurate approximation of the Pheur(v) values using march with the w\u22173 heuristic on random 3-SAT formulae.\nPheur(v) = y + x \u00b7 depth(v) (6)\nWe used these linear models to construct search strategies:\n\u2013 Compute for all 4096 subtrees at depth 12 the Pgoal(v) values \u2013 Visit the subtrees based on the Pgoal(v) values from high to low\nThe objective is to determine which linear model results in the smallest E\u2217goal(12) value. Because we only use the Pgoal(v) values to determine the order of the subtrees, parameter y can be fixed. We set it to y = 0.56 as in (5). The table below shows the results:\nx 0.0050 0.0055 0.0060 0.0065 0.0070 0.0075 0.0080\nE\u2217goal(12) 0.035331 0.035325 0.035327 0.035340 0.035341 0.035372 0.035390\nx 0.0090 0.0100 0.0110 0.0120 0.0130 0.0140 0.0150\nE\u2217goal(12) 0.035434 0.035447 0.035561 0.035735 0.035840 0.035974 0.036057\nTwo interesting things can be concluded from these experiments. First, the optimal value for the x parameter (0.0055) is much smaller than the value that matches the observed data (0.0150). Second, the optimal E\u2217goal(12) value (0.03525) is hardly smaller than the cost of ALDS (0.036114). It will be difficult to construct a search strategy based on a linear model that will outperform ALDS, because the overhead required to implement a more complex strategy will probably be more costly than the small reduction in E\u2217goal(12) can compensate."}, {"heading": "5 Conclusion", "text": "We introduced the recursive weight heuristic, a branching heuristic for look-ahead SAT solvers. The solver march equipped with this heuristic performs stronger than any other solver on unsatisfiable random 3-SAT formulae. It won the gold medal in this category at the SAT 2009 competition.\nTo capitalize on the recursive weight heuristic on satisfiable instances as well, we presented advanced limited discrepancy search (ALDS). Theoretical and practical results show that ADSL outperforms alternative complete search strategies on satisfiable random 3-SAT formulae. We show that on these instances, ALDS in combination with the recursive weight heuristic traverse the search tree in a near-optimal order."}], "references": [{"title": "Heavy-tailed phenomena in satisfiability and constraint satisfaction problems", "author": ["C.P. Gomes", "B. Selman", "N. Crato", "H. Kautz"], "venue": "J. Autom. Reason. 24(1-2)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2000}, {"title": "Limited discrepancy search", "author": ["W.D. Harvey", "M.L. Ginsberg"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1995}, {"title": "Heuristics based on unit propagation for satisfiability problems", "author": ["C.M. Li", "Anbulagan"], "venue": "IJCAI (1).", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1997}, {"title": "A constraint-based approach to narrow search trees for satisfiability", "author": ["C.M. Li"], "venue": "Information processing letters 71(2)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1999}, {"title": "A backbone-search heuristic for efficient solving of hard 3-SAT formulae", "author": ["O. Dubois", "G. Dequen"], "venue": "In Nebel, B., ed.: IJCAI, Morgan Kaufmann", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2001}, {"title": "Improved limited discrepancy search", "author": ["R.E. Korf"], "venue": "In Proceedings of AAAI-96, MIT Press", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1996}, {"title": "Depth-bounded discrepancy search", "author": ["T. Walsh"], "venue": "IJCAI\u201997: Proceedings of the Fifteenth international joint conference on Artifical intelligence, San Francisco, CA, USA, Morgan Kaufmann Publishers Inc.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1997}, {"title": "A machine program for theorem-proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Commun. ACM 5(7)", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1962}, {"title": "Investigating the behaviour of a SAT solver on random formulas", "author": ["O. Kullmann"], "venue": "Technical Report CSR 23-2002, University of Wales Swansea, Computer Science Report Series (http://www-compsci.swan.ac.uk/reports/2002.html)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2002}, {"title": "Whose side are you on? finding solutions in a biased searchtree", "author": ["M.J.H. Heule", "H. van Maaren"], "venue": "Technical report, Proceedings of Guangzhou Symposium on Satisfiability In LogicBased Modeling", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Handbook of Satisfiability", "author": ["A. Biere", "M.J.H. Heule", "H. van Maaren", "T. Walsh", "eds."], "venue": "Volume 185 of Frontiers in Artificial Intelligence and Applications. IOS Press", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "First, restart strategies [2] are used to compensate for ineffective choices made by decision heuristics.", "startOffset": 26, "endOffset": 29}, {"referenceID": 1, "context": "Second, discrepancy search [3], a technique used in Constraint Programming, focuses on those parts of the search tree that mostly follow the preference of the direction heuristics.", "startOffset": 27, "endOffset": 30}, {"referenceID": 2, "context": "This heuristic is a generalization of earlier lookahead evaluation heuristics [4\u20136].", "startOffset": 78, "endOffset": 83}, {"referenceID": 3, "context": "This heuristic is a generalization of earlier lookahead evaluation heuristics [4\u20136].", "startOffset": 78, "endOffset": 83}, {"referenceID": 4, "context": "This heuristic is a generalization of earlier lookahead evaluation heuristics [4\u20136].", "startOffset": 78, "endOffset": 83}, {"referenceID": 5, "context": "To capitalize on this, we developed a new discrepancy search algorithm, called advanced limited discrepancy search (ALDS), which combines features of improved limited discrepancy search [7] and depth-bounded discrepancy search [8].", "startOffset": 186, "endOffset": 189}, {"referenceID": 6, "context": "To capitalize on this, we developed a new discrepancy search algorithm, called advanced limited discrepancy search (ALDS), which combines features of improved limited discrepancy search [7] and depth-bounded discrepancy search [8].", "startOffset": 227, "endOffset": 230}, {"referenceID": 7, "context": "1 Look-ahead SAT solvers The look-ahead architecture for SAT solvers is based on the DPLL framework [9]: It is a complete solving method which selects in each step a decision variable xdecision and recursively calls DPLL for the reduced formula where xdecision is assigned to false (denoted by F [xdecision = 0]) and another where xdecision is assigned to true (denoted by F [xdecision = 1]).", "startOffset": 100, "endOffset": 103}, {"referenceID": 2, "context": "The DIFF heuristic based on the number of newly created clauses was introduced by Li and Anbulagan [4].", "startOffset": 99, "endOffset": 102}, {"referenceID": 3, "context": "For this special case, Li [5] uses in satz weights based on the occurrences of variables.", "startOffset": 26, "endOffset": 29}, {"referenceID": 4, "context": "A slight variation but much more effective weight is used by Dubois and Dequen [6] in their solver kcnfs.", "startOffset": 79, "endOffset": 82}, {"referenceID": 8, "context": "In case of k-SAT instances, Kullmann [11] uses in the OKsolver weights based on the length of clauses in Cnew.", "startOffset": 37, "endOffset": 41}, {"referenceID": 2, "context": "For binary clause (y \u2228 z) \u2208 Cnew they compute a weight w i (y \u2228 z) = hi(\u00acy) \u2217 hi(\u00acz): \u2013 Li & Anbulagan 1997 [4]: w(y \u2228 z) = 1 = h0(\u00acy)\u00d7 h0(\u00acz), in short w \u00d7 0 .", "startOffset": 108, "endOffset": 111}, {"referenceID": 3, "context": "\u2013 Li 1999 [5]: w(y \u2228 z) = #(\u00acy) + #(\u00acz) = h1(\u00acy) + h1(\u00acz), in short w + 1 .", "startOffset": 10, "endOffset": 13}, {"referenceID": 4, "context": "\u2013 Dubois 2001 [6]: w(y \u2228 z) = #(\u00acy) \u00d7#(\u00acz) = h1(\u00acy)\u00d7 h1(\u00acz), in short w \u00d7 1 .", "startOffset": 14, "endOffset": 17}, {"referenceID": 3, "context": "Although [5,6] used \u03b3 = 5, we observed stronger performance using \u03b3 = 3.", "startOffset": 9, "endOffset": 14}, {"referenceID": 4, "context": "Although [5,6] used \u03b3 = 5, we observed stronger performance using \u03b3 = 3.", "startOffset": 9, "endOffset": 14}, {"referenceID": 9, "context": "We implementedw 0 , w + 1 , w \u00d7 1 , w \u00d7 2 , w \u00d7 3 and w \u00d7 4 in the look-ahead solver march ks [12] with \u03b3 = 3.", "startOffset": 94, "endOffset": 98}, {"referenceID": 9, "context": "It is observed [12], that heuristics tend to make more mistakes in the top of the search tree.", "startOffset": 15, "endOffset": 19}, {"referenceID": 1, "context": "Limited Discrepancy Search (LDS) LDS [3] explores first those parts of the search tree that have a small number of discrepancies.", "startOffset": 37, "endOffset": 40}, {"referenceID": 6, "context": "Depth-bounded Discrepancy Search (DDS) By incrementally increasing the maximum depth up to which discrepancies are allowed to occur, DDS [8] differs from (I)LDS.", "startOffset": 137, "endOffset": 140}, {"referenceID": 1, "context": "The papers describing LDS [3], ILDS [7] and DDS [8] are precise on which leaf nodes are explored in each of the iteration stages.", "startOffset": 26, "endOffset": 29}, {"referenceID": 5, "context": "The papers describing LDS [3], ILDS [7] and DDS [8] are precise on which leaf nodes are explored in each of the iteration stages.", "startOffset": 36, "endOffset": 39}, {"referenceID": 6, "context": "The papers describing LDS [3], ILDS [7] and DDS [8] are precise on which leaf nodes are explored in each of the iteration stages.", "startOffset": 48, "endOffset": 51}, {"referenceID": 9, "context": "This search strategy is inspired by an earlier experimental study on random 3-SAT instances, where we observed [12] two patterns regarding the goal node probabilities:", "startOffset": 111, "endOffset": 115}, {"referenceID": 9, "context": "Experiments have been performed with the look-ahead SAT solver march [12], the fastest solver on random 3-SAT benchmarks.", "startOffset": 69, "endOffset": 73}, {"referenceID": 9, "context": "Based on the increasing heuristic probability observation [12] we created a model with just one goal node.", "startOffset": 58, "endOffset": 62}, {"referenceID": 9, "context": "In this model we assign the heuristic probability as follows (based on the observed Pheur(v) values in [12]): Pheur(v) = 0.", "startOffset": 103, "endOffset": 107}, {"referenceID": 9, "context": "2 Satisfiability results For the experimental results we used the look-ahead SAT solver march [12] with the recursive weight heuristic w 3 as direction heuristic (see Section 2.", "startOffset": 94, "endOffset": 98}, {"referenceID": 9, "context": "The Greedy search strategy is introduced in [12], and is constructed as follows:", "startOffset": 44, "endOffset": 48}], "year": 2017, "abstractText": "When combined properly, search techniques can reveal the full potential of sophisticated branching heuristics. We demonstrate this observation on the well-known class of random 3-SAT formulae. First, a new branching heuristic is presented, which generalizes existing work on this class. Much smaller search trees can be constructed by using this heuristic. Second, we introduce a variant of discrepancy search, called ALDS. Theoretical and practical evidence support that ALDS traverses the search tree in a near-optimal order when combined with the new heuristic. Both techniques, search and heuristic, have been implemented in the look-ahead solver march. The SAT 2009 competition results show that march is by far the strongest complete solver on random k-SAT formulae.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}