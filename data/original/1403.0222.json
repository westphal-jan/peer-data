{"id": "1403.0222", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Mar-2014", "title": "Beyond Q-Resolution and Prenex Form: A Proof System for Quantified Constraint Satisfaction", "abstract": "We consider the quantified constraint satisfaction problem (QCSP) which is to decide, given a structure and a first-order sentence (not assumed here to be in prenex form) built from conjunction and quantification, whether or not the sentence is true on the structure. We present a proof system for certifying the falsity of QCSP instances and develop its basic theory; for instance, we provide an algorithmic interpretation of its behavior. Our proof system places the established Q-resolution proof system in a broader context, and also allows us to derive QCSP tractability results.", "histories": [["v1", "Sun, 2 Mar 2014 15:19:57 GMT  (32kb)", "https://arxiv.org/abs/1403.0222v1", null], ["v2", "Fri, 23 May 2014 08:15:56 GMT  (22kb)", "http://arxiv.org/abs/1403.0222v2", null], ["v3", "Mon, 17 Nov 2014 14:07:51 GMT  (237kb,D)", "http://arxiv.org/abs/1403.0222v3", null], ["v4", "Sat, 20 Dec 2014 13:55:26 GMT  (246kb,D)", "http://arxiv.org/abs/1403.0222v4", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.CC", "authors": ["hubie chen"], "accepted": false, "id": "1403.0222"}, "pdf": {"name": "1403.0222.pdf", "metadata": {"source": "CRF", "title": "BEYOND Q-RESOLUTION AND PRENEX FORM: A PROOF SYSTEM FOR QUANTIFIED CONSTRAINT SATISFACTION", "authors": ["HUBIE CHEN", "Hubie Chen"], "emails": [], "sections": [{"heading": "1. Introduction", "text": "Background. The study of propositional proof systems for certifying the unsatisfiability of quantifier-free propositional formulas is supported by multiple motivations [3, 15]. First, the desire to have an efficiently verifiable certificate of a formula\u2019s unsatisfiability is a natural and basic one, and indeed the field of propositional proof complexity studies, for various proof systems, whether and when succinct proofs exist for unsatisfiable formulas. Next, theorem provers are typically based on such proof systems, and so insight into the behavior of proof systems can yield insight into the behavior of theorem provers. Also, algorithms that perform search to determine the satisfiability of formulas can typically be shown to implicitly generate proofs in a proof system, and thus lower bounds on proof size translate to lower bounds on the running time of such algorithms. Finally, algorithms that check for unsatisfiability proofs of various restricted forms have been shown to yield tractable cases of the propositional satisfiability problem and related problems (see for example [1, 2]).\nIn recent years, increasing attention has been directed towards the study of quantified proof systems that certify the falsity of quantified propositional formulas, which study is also pursued with the motivations similar to those outlined for the quantifier-free case. Indeed, the development of so-called QBF solvers, which determine the truth of quantified propositional formulas, has become an active research theme, and the study of quantified proof systems is pursued as a way to understand their behavior, as well as to explore the\n2012 ACM CCS: [Theory of computation]: Logic. Key words and phrases: Q-resolution, proof system, quantified constraint satisfaction.\nLOGICAL METHODSl IN COMPUTER SCIENCE DOI:10.2168/LMCS-10(4:14)2014 c\u00a9 Hubie ChenCC\u00a9 Creative Commons\nspace of potential certificate formats for verifying their correctness on particular input instances [14].\nQ-resolution [4] is a quantified proof system that can be viewed as a quantified analog of resolution, one of the best-known and most customarily considered propositional proof systems. In the context of quantified propositional logic, Q-resolution is a heavily studied and basic proof system on which others are built and to which others are routinely compared, as well as a point of departure for the discussion of suitable certificate formats (see [11, 16, 12] for examples). However, the Q-resolution proof system has intrinsic shortcomings. First, it is only applicable to quantified propositional sentences that are in prenex form, that is, where all quantifiers appear in front. While it is certainly true that an arbitrary given quantified propositional formula may be efficiently prenexed, the process of prenexing is not canonical: intuitively, it involves choosing a total order of variables consistent with the partial order given by the input formula. As argued by Egly, Seidl, and Woltran [10], this may disrupt the original formula structure, \u201cartificially extend\u201d the scopes of quantifiers, and generate dependencies among variables that were not originally present, unnecessarily increasing the expense of solving; we refer the reader to their article for a contemporary discussion of this issue.1 A second shortcoming of Q-resolution is that it is only defined in the propositional setting, despite that some scenarios may be more naturally and cleanly modelled by allowing variables to be quantified over domains of size greater than two.\nContributions. In this article, we introduce a proof system that directly overcomes both of the identified shortcomings of Q-resolution and that, in a sense made precise, generalizes Q-resolution.\nWe here define the quantified constraint satisfaction problem (QCSP) to be the problem of deciding, given a relational structure B and a first-order sentence \u03c6 (not necessarily in prenex form) built from the conjunction connective (\u2227) and the two quantifiers (\u2200, \u2203), whether or not the sentence is true on the structure. To permit different variables to have different domains, we formalize the QCSP using multi-sorted first-order logic. Our proof system (Section 3) allows for the certification of falsity of QCSP instances. While Q-resolution provides rules for deriving clauses from a given quantified propositional formula, our proof system provides rules for deriving what we call constraints at various formula locations of a given QCSP instance; here, a constraint (V, F ) is a set V of variables paired with a set F of assignments, each defined on V . A formula location i paired with a constraint is called a judgement ; a proof in our system is a sequence of judgements where each is derived from the previous ones via the rules. Crucially, we formulate and prove a key lemma (Lemma 3.5) that shows (essentially) that if a judgement (i, V, F ) is derivable from a QCSP instance (\u03c6,B), then there exists a formula \u03c8(V ) that \u201cdefines\u201d the constraint (V, F ) over B, such that \u03c8(V ) can be conjoined to the input sentence \u03c6 at location i while preserving logical equivalence. This key lemma is then swiftly deployed to establish soundness and completeness of our proof system (Theorem 3.6). We view the formulation of our proof system and of this key lemma as conceptual contributions. They offer a broader, deeper, and more general perspective on Q-resolution and what it means for a clause to be derivable by Q-resolution: we show (in a sense made precise) that each clause derivable by Q-resolution is derivable by our proof\n1Let us remark that using so-called dependency schemes is a potential way to cope with such introduced dependencies in a prenex formula [16].\nsystem (see Theorem 4.4). This yields a clear and transparent proof of the soundness of Q-resolution which, interestingly, is carried out in the setting of first-order logic, despite the result concerning propositional logic.\nIn order to relate our proof system to Q-resolution, we give a proof system for certain quantified propositional formulas (Section 4) and prove that this second proof system is a faithful propositional interpretation of our QCSP proof system (Theorem 4.3). We also provide an algorithmic interpretation of this second proof system. In particular, we give a nondeterministic search algorithm such that traces of execution that result in certifying falsity correspond to refutations in the proof system (Section 4.3). As a consequence, the proof system yields a basis for establishing running-time lower bounds for any deterministic algorithm which instantiates the non-deterministic choices of our search algorithm.\nIn the final section of the article (Section 5), we present and study a notion of consistency for the QCSP that is naturally induced by our proof system. In the context of constraint satisfaction, a consistency notion is a condition which is necessary for the satisfiability of an instance and which can typically be efficiently checked. An example used in practice is arc consistency, and understanding when various forms of consistency provide an exact characterization of satisfiability (that is, when consistency is sufficient for satisfiability in addition to being necessary) has been a central theme in the tractability theory of constraint satisfaction [1, 2, 8]. Atserias, Kolaitis, and Vardi [1] showed that checking for k-consistency, an oft-considered consistency notion, can be viewed as detecting the absence of a proof of unsatisfiability having width at most k, in a natural proof system (the width of a proof is the maximum number of variables appearing in a line of the proof); Kolaitis and Vardi [13] also characterized k-consistency algebraically as whether or not Duplicator can win a natural Spoiler-Duplicator pebble game in the spirit of Ehrenfeucht-Fra\u0308\u0131sse\u0301 games. Inspired by these connections, we directly define a QCSP instance to be k-judgeconsistent if it has no unsatisfiability proof (in our proof system) of width at most k; and, we then present an algebraic, Ehrenfeucht-Fra\u0308\u0131sse\u0301-style characterization of k-judge-consistency (Theorem 5.3). As an application of this algebraic characterization, we prove that (in a sense made precise) any case of the QCSP that lies in the tractable regime of a recent dichotomy theorem [7], is tractable via checking for k-judge-consistency.2 That is, within the framework considered by that dichotomy, if a class of QCSP instances is tractable at all, it is tractable via k-judge consistency. We remark that earlier work [6] presents algebraically a notion of consistency for the QCSP, but no corresponding proof system was explicitly presented; the notion of k-judgement consistency can be straightforwardly verified to imply the notion of consistency in this earlier article. To sum up, this article presents a proof system for non-prenex quantified formulas. Our proof system is based on highly natural and simple rules, and its utility is witnessed by its connections to Q-resolution and by our presentation of a consistency notion that it induces, which allows for the establishment of tractability results. We hope that this proof system will serve as a point of reference and foundation for the future study of solvers and certificates for non-prenex formulas. One particular possibility for future work is to compare this proof system to others that are defined on non-prenex formulas, such as those discussed and studied by Egly [9].\n2 Let us remark that this dichotomy theorem has since been generalized [5]."}, {"heading": "2. Preliminaries", "text": "When f is a mapping, we use f S to denote its restriction to a set S; we use f [s\u2192 b] to denote the extension of f that maps s to b. We extend this notation to sets of mappings in the natural fashion.\nFirst-order logic. We assume basic familiarity with the syntax and semantics of first-order logic. For the sake of broad applicability, in this article, we work with multi-sorted relational first-order logic, formalized here as follows. A signature is a pair (\u03c3,S) where S is a set of sorts and \u03c3 is a set of relation symbols; each relation symbol R \u2208 \u03c3 has an associated arity ar(R) which is an element of S\u2217. Each variable v has an associated sort s(v) \u2208 S; an atom is a formula R(v1, . . . , vk) where R \u2208 \u03c3 and s(v1) . . . s(vk) = ar(R). A structure B on signature (\u03c3,S) consists of an S-indexed family B = {Bs | s \u2208 S} of sets, called the universe of B, and, for each symbol R \u2208 \u03c3, an interpretation RB \u2286 Bar(R). Here, for a word w = w1 . . . wk \u2208 S\u2217, we use Bw to denote the product Bw1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Bwk . Suppose that V is a set of variables where each variable v \u2208 V has an associated sort s(v); by a mapping f : V \u2192 B, we mean a mapping that sends each v \u2208 V to an element f(v) \u2208 Bs(v).\nWhen \u03c6 is a formula, we use free(\u03c6) to denote the set containing the free variables of \u03c6. The width of a formula \u03c6 is the maximum of |free(\u03c8)| over all subformulas \u03c8 of \u03c6. A quantified-conjunctive formula (for short, qc-formula) is a formula over a signature built from atoms on the signature, conjunction (\u2227), and the two quantifiers (\u2200, \u2203). Note that we permit conjunction of arbitrary arity. As expected, a qc-sentence is a qc-formula \u03c6 such that free(\u03c6) = \u2205. We allow conjunction of arbitrary (finite) arity, in formulas. We will use > to denote a sentence that is always true; this is considered to be a qc-sentence. A relation P is qc-definable over a structure B if there exists a qc-formula \u03c6(v1, . . . , vk) such that P \u2286 Bs(v1)...s(vk) and P contains a tuple (b1, . . . , bk) if and only if B, b1, . . . , bk |= \u03c6(v1, . . . , vk). Note that by the notation B, b1, . . . , bk |= \u03c6(v1, . . . , vk), we mean that the structure B and the mapping taking each vi to bi satisfy \u03c6. We sometimes use \u2261 to indicate logical equivalence of two formulas.\nWe define the QCSP to be the problem of deciding, given a QCSP instance, which is a pair (\u03c6,B) where \u03c6 is a qc-sentence and B is a structure that both have the same signature, whether or not B |= \u03c6."}, {"heading": "3. QCSP proof system", "text": "In this section, we present our proof system for the QCSP, and establish some basic properties thereof, including soundness and completeness. Let (\u03c6,B) be a QCSP instance, and conceive of \u03c6 as a tree. The proof system will allow us to derive what we call constraints at the various nodes of the tree. To facilitate the discussion, we will assume that each qc-sentence \u03c6 has, associated with it, a set I\u03c6 of indices that contains one index for each subformula occurrence of \u03c6, that is, for each node of the tree corresponding for \u03c6. Let us remark that (in general) the collection of constraints derivable at an occurrence of a subformula does not depend only on the subformula, but also on the subformula\u2019s location in the full formula \u03c6. When i is an index, we use \u03c6(i) to denote the actual subformula of the subformula occurrence corresponding to i; we will also refer to i as a location.\nExample 3.1. Consider the qc-sentence \u03c6 = \u2203x\u2200y(E(x, y) \u2227 (\u2203xE(x, y))). (See Figure 3.) When viewed as a tree, this formula has 6 nodes. We may index them naturally according\nax tvg I7n\nutl,r: b\nae--7Lr -\" ,b\\\n% QLs) = ax gb'y)\nStroelweBi Uu', Verse l orlo'& ee =\\ (a,a) ,(n b), (ar.),\nLvrv), (c,c)l\nL,e+ (6 csur*arn *{nz vnag1.\n-H^atr sdtOtl ELxrg) ' tx41 * tarb,cl m glvocr*vr2 lb.\nL Z &c*2 (L\n'-\\b C.-. C\nFigure 1: Formula discussed in Examples 3.1 and 3.4.\nto the depth-first search order: we could take the index set {1, . . . , 6} where \u03c6(4) = \u03c6(6) = E(x, y), \u03c6(5) = \u2203x\u03c6(6), \u03c6(3) = \u03c6(4) \u2227 \u03c6(5), \u03c6(2) = \u2200y\u03c6(3), and \u03c6(1) = \u2203x\u03c6(2).\nWe say that an index i is a parent of an index j, and also that j is a child of i, if, in viewing the formula \u03c6 as a tree, the root of the subformula occurrence of i is the parent of the root of the subformula occurrence of j. Note that, when this holds, the formula \u03c6(i) either is of the form Qv\u03c6(j) where Q is a quantifier and v is a variable, or is a conjunction where \u03c6(j) appears as a conjunct. As examples, with respect to the qc-sentence and indexing in Example 3.1, index 3 has two children, namely, 4 and 5, and index 3 has one parent, namely, 2.\nDefinition 3.2. Let (\u03c6,B) be a QCSP instance. A constraint (on (\u03c6,B)) is a pair (V, F ) where V is a set of variables occurring in \u03c6, and F is a set of mappings from V to B. A judgement (on (\u03c6,B)) is a triple (i, V, F ) where i \u2208 I\u03c6 and (V, F ) is a constraint with V \u2286 free(\u03c6(i)); it is empty if F = \u2205.\nHere, we use the convention that (relative to a QCSP instance) there is exactly one map e : \u2205 \u2192 B defined on the empty set, so there are two constraints whose variable set is the empty set: the constraint (\u2205, \u2205), and the constraint (\u2205, {e}) where e is the aforementioned map.\nWhen (U1, F1), (U2, F2) are two constraints on the same QCSP instance, we define the join of F1 and F2, denoted by F1 on F2, to be the set {f : U1 \u222a U2 \u2192 B | (f U1) \u2208 F1, (f U2) \u2208 F2}. When (U,F ) is a constraint and y is a variable in U , we use yF to denote the set {f : U \\ {y} \u2192 B | for each b \u2208 Bs(y), it holds that f [y \u2192 b] \u2208 F}. The operator y will be used to eliminate a universally quantified variable y. Dually, in the following definition, projection can be used to cope with existential quantification.\nDefinition 3.3. A judgement proof on (\u03c6,B) is a finite sequence of judgements, each of which has one of the following types:\n(atom) (i, {v1, . . . , vk}, F ) where \u03c6(i) is an atom R(v1, . . . , vk) and F = {f : {v1, . . . , vk} \u2192 B | (f(v1), . . . , f(vk)) \u2208 RB}\n(projection) (i, U, F U) where (i, V, F ) is a previous judgement, and U \u2286 V\n(join) (i, U1 \u222a U2, F1 on F2) where (i, U1, F1) and (i, U2, F2) are previous judgements\n(upward flow) (i, V, F )\nwhere (j, V, F ) is a previous judgement and i is the parent of j\n(\u2200-elimination) (i, V \\ {y}, yF ) where (j, V, F ) is a previous judgement with y \u2208 V , \u03c6(i) = \u2200y\u03c6(j), and i is the parent of j\n(downward flow) (j, V, F )\nwhere (i, V, F ) is a previous judgement and i is the parent of j\nWe say that a judgement (i, V, F ) is derivable if there exists a judgement proof that contains the judgement.\nThe width of a judgement (i, V, F ) is |V |. The width of a judgement proof is the maximum width over all of its judgements, and the length of a judgement proof is the number of judgements that it contains.\nLet us emphasize that, by definition, a judgement proof is a finite sequence of judgements, and by definition, in order for a triple (i, V, F ) to be a judgement, it must hold that all variables in V are free variables of \u03c6(i). Consequently, upward flow can only be applied to a judgement (j, V, F ) if all variables in V are free variables of \u03c6(i), where i is the parent of j; an analogous comment holds for downward flow.\nExample 3.4. Let \u03c6 be the qc-sentence from Example 3.1 (shown in Figure 3), considered as a sentence over signature ({E}, {e, u}) with ar(E) = eu and where s(x) = e and s(y) = u. Define B to be a structure over this signature having universe B defined by Be = {a, b, c} and Bu = {d, e, f}, and where EB = {(a, d), (a, e), (a, f), (b, e), (c, f)}. To offer a feel of the proof system, we give some examples of derivable judgements.\nLet FE be the set of assignments from {x, y} to B that satisfy E(x, y) (over B). By (atom), we may derive the judgement (4, {x, y}, FE). By (upward flow), we may then derive the judgement (3, {x, y}, FE). By (\u2200-elimination), we may then derive the judgement (2, {x}, G), where G contains the single map that takes x to a. By applying (downward flow) twice, we may then derive the judgement (4, {x}, G). By (atom), we may also derive the judgement (6, {x, y}, FE). By (projection), we may then derive the judgement (6, {x}, H), where H contains the maps taking x to a, b, and c, respectively. Let us remark that, even though \u03c6(4) = \u03c6(6) and we derived the judgement (4, {x}, G), it is not possible to derive\nthe judgement (6, {x}, G). (This can be verified by Lemma 3.5, to be presented next, and the observation that B |= \u03c6.)\nWe now prove soundness and completeness of our proof system; we first establish a lemma, which indicates what it means for a judgement to be derivable.\nWhen \u03c6 is a qc-formula with index set I, and {\u03b8i}i\u2208I is a family of formulas, we use \u03c6+\u03b8 to denote the formula obtained from \u03c6 by replacing, at each location i, the subformula \u03c6(i) by \u03c6(i) \u2227 \u03b8i. Formally, we define \u03c6+\u03b8 by induction. When \u03c6(i) is an atom, we define \u03c6+\u03b8(i) = \u03c6(i)\u2227 \u03b8i. When \u03c6(i) = \u03c6(j)\u2227\u03c6(k), we define \u03c6+\u03b8(i) = \u03c6+\u03b8(j)\u2227\u03c6+\u03b8(k)\u2227 \u03b8i. When \u03c6(i) = Qv\u03c6(j), we define \u03c6+\u03b8(i) = (Qv\u03c6+\u03b8(j)) \u2227 \u03b8i. We define \u03c6+\u03b8 to be \u03c6+\u03b8(r) where r is the root index of \u03c6 (that is, where r is such that \u03c6(r) = \u03c6).\nLemma 3.5. Let (\u03c6,B) be a QCSP instance. For every derivable judgement (i, V, F ), there exists a qc-formula \u03c8 such that \u2022 free(\u03c8) = V ; \u2022 for each f : V \u2192 B, it holds that f \u2208 F if and only if B, f |= \u03c8; and \u2022 for any family {\u03b8i}i\u2208I of formulas, it holds that \u03c6+\u03b8 entails \u03c6+\u03b8[i\n\u2227\u2192 \u03c8] (and hence that \u03c6+\u03b8 \u2261 \u03c6+\u03b8[i \u2227\u2192 \u03c8]). Here, \u03c6+\u03b8[i \u2227\u2192 \u03c8] denotes the formula where, at location i, the subformula \u03c6+\u03b8(i) is replaced with \u03c6+\u03b8(i) \u2227 \u03c8.\nMoreover, if one has a judgement proof of width at most k, then each of the formulas \u03c8 produced for its judgements has width(\u03c8) \u2264 k.\nProof. We consider the different types of judgements, and use the notation from Definition 3.3. In each case, the claim on the width is straightforwardly verified.\nIn the case of (atom), we take \u03c8 = \u03c6(i); the formulas \u03c6+\u03b8 and \u03c6+\u03b8[i \u2227\u2192 \u03c8] are logically\nequivalent since \u03c6(i) \u2261 \u03c6(i) \u2227 \u03c6(i). In the case of (projection), by induction, we have that \u03c6+\u03b8 entails \u03c6+\u03b8[i\n\u2227\u2192 \u03c8\u2032] where \u03c8\u2032 is the formula for the judgement (i, V, F ). We take \u03c8 = \u2203v1 . . . \u2203vm\u03c8\u2032, where v1, . . . , vm is a listing of the elements in V \\ U . We have that \u03c6+\u03b8[i \u2227\u2192 \u03c8\u2032] entails \u03c6+\u03b8[i \u2227\u2192 \u03c8], and hence by transitivity of the entailment relation that \u03c6+\u03b8 entails \u03c6+\u03b8[i\n\u2227\u2192 \u03c8]. In the case of (join), by induction, we have (for any family {\u03b8j}j\u2208I) that \u03c6+\u03b8 entails\nboth \u03c6+\u03b8[i \u2227\u2192 \u03c81] and \u03c6+\u03b8[i \u2227\u2192 \u03c82] where \u03c81 and \u03c82 are the formulas corresponding to the judgements (i, U1, F1) and (i, U2, F2). We take \u03c8 = \u03c81\u2227\u03c82. Fix a family {\u03b8j}j\u2208I , and define {\u03b8\u2032j}j\u2208I to be the family that has \u03b8\u2032i = \u03b8i \u2227 \u03c81, and is everywhere else equal to {\u03b8j}j\u2208I . We have that \u03c6+\u03b8 entails \u03c6+\u03b8[i \u2227\u2192 \u03c81] \u2261 \u03c6+\u03b8 \u2032 , and that \u03c6+\u03b8 \u2032 entails \u03c6+\u03b8 \u2032 [i \u2227\u2192 \u03c82]. It follows that \u03c6+\u03b8 entails \u03c6+\u03b8 \u2032 [i \u2227\u2192 \u03c82] \u2261 \u03c6+\u03b8[i\n\u2227\u2192 (\u03c81 \u2227 \u03c82)]. In the case of (\u2200-elimination), by induction, we have that \u03c6+\u03b8 entails \u03c6+\u03b8[j \u2227\u2192 \u03c8\u2032],\nwhere \u03c8\u2032 is the formula for the judgement (j, V, F ). We take \u03c8 = \u2200y\u03c8\u2032. We claim that the formula \u03c6+\u03b8[j \u2227\u2192 \u03c8\u2032] is logically equivalent to \u03c6+\u03b8[i \u2227\u2192 \u03c8], which suffices to give that \u03c6+\u03b8 entails \u03c6+\u03b8[i \u2227\u2192 \u03c8]. This is because the subformula of \u03c6+\u03b8[j \u2227\u2192 \u03c8\u2032] at location i is logically equivalent to (\u2200y(\u03c6+\u03b8(j)\u2227\u03c8\u2032))\u2227 \u03b8i which is logicically equivalent to (\u2200y\u03c6+\u03b8(j))\u2227 (\u2200y\u03c8\u2032)\u2227 \u03b8i. In the cases of (upward flow) and (downward flow), we take \u03c8 to be equal to the formula that is given to us by the previous judgement. It is straightforwardly verified that \u03c6+\u03b8[i \u2227\u2192 \u03c8] and \u03c6+\u03b8[j \u2227\u2192 \u03c8] are logically equivalent.\nTheorem 3.6. Let (\u03c6,B) be a QCSP instance. An empty judgement on (\u03c6,B) is derivable if and only if B 6|= \u03c6.\nThis theorem is proved in the following way. The forward direction follows immediately from the previous lemma. For the backward direction, we show by induction that, for each location i, there exists a derivable judgement for which the formula \u03c8 given by the previous lemma is equal to \u03c6(i)!\nProof. Suppose that an empty judgement (i, V, F ) is derivable. Then by invoking the (projection) rule, the empty judgement (i, \u2205, \u2205) is derivable. Define {\u03b8j}j\u2208I so that \u03b8j is the true formula > for each j \u2208 I; then, invoking Lemma 3.5, we have that there exists a qc-formula \u03c8 that is false on B (that is, B 6|= \u03c8) and such that \u03c6 entails \u03c6[i \u2227\u2192 \u03c8]. We have that B 6|= \u03c6[i \u2227\u2192 \u03c8], and hence (since \u03c6 entails \u03c6[i \u2227\u2192 \u03c8]) we have that B 6|= \u03c6. Suppose that B 6|= \u03c6. We claim that for each location i, there exists a derivable judgement (i, V, F ) where the corresponding formula \u03c8, given by the proof of Lemma 3.5, is equal to \u03c6(i). This suffices, as then the root location r has a derivable judgement (r, V, F ) such that F = \u2205. We establish the claim by induction. When \u03c6(i) is an atom, we use the judgement given by (atom) in the proof system (Definition 3.3). When \u03c6(i) is a conjunction, let j and k be the children of i, so that \u03c6(i) = \u03c6(j) \u2227 \u03c6(k). Let (j, Vj , Fj) and (k, Vk, Fk) be the derivable judgements given by induction. By (upward flow) in the proof system, we have that (i, Vj , Fj) and (i, Vk, Fk) are derivable judgements; by invoking (join), we obtain the desired judgement. When \u03c6(i) begins with existential quantification, let j be the child of i, and denote \u03c6(i) = \u2203x\u03c6(j). Let (j, V, F ) be the derivable judgement given by induction; by applying the rule (projection) to obtain a constraint on V \\ {x} and then the rule (upward flow), we obtain the desired derivation. When \u03c6(i) begins with universal quantification, let j be the child of i, and denote \u03c6(i) = \u2200y\u03c6(j). Let (j, V, F ) be the derivable judgement given by induction; by the (\u2200-elimination) rule, we obtain the desired derivation."}, {"heading": "4. Propositional proof system", "text": "In this section, we introduce a different proof system, which is a propositional interpretation of the QCSP proof system. For differentiation, we refer to judgements and judgement proofs as defined in the previous section as constraint judgements and constraint judgement proofs. A literal is a propositional variable v or the negation v thereof. Two literals are complementary if one is a variable v and the other is v; each is said to be the complement of the other. A clause is a disjunction of literals that contains, for each variable, at most one literal on the variable; a clause is sometimes viewed as the set of the literals that it contains. A clause is empty if it does not contain any literals. The variables of a clause are simply the variables that underlie the clause\u2019s literals, and the set of variables of a clause \u03b1 is denoted by vars(\u03b1). A clause \u03b3 is a resolvent of two propositional clauses \u03b1 and \u03b2 if there exists a literal L \u2208 \u03b1 such that its complement M is in \u03b2, and \u03b3 = (\u03b1 \\ {L}) \u222a (\u03b2 \\ {M}). A clause \u03b3 is falsified by a propositional assignment a if a is defined on vars(\u03b3) and each literal in \u03b3 evalutes to false under a. We define a QCBF instance to be a propositional formula not having free variables that is built from clauses, conjunction, and universal and existential quantification over propositional variables. As with QCSP instance, we assume that each QCBF instance \u03c8 has\nan associated index set that contains an index for each subformula of \u03c8. Note that a clause is not considered to have any subformulas, other than itself. As an example, consider the QCBF instance \u2203x\u2200y\u2203z((y \u2228 z) \u2227 (y \u2228 z \u2228 x)). This formula would have 6 indices: one for each of the two clauses, one for the conjunction of the two clauses, and one for each of the quantifiers.\nLet \u03c8 be a QCBF instance. A clause judgement (on \u03c8) is a pair (i, \u03b1) where i \u2208 I\u03c8 and \u03b1 is a clause with vars(\u03b1) \u2286 free(\u03c8(i)); a clause judgement (i, \u03b1) is empty if \u03b1 is empty.\nDefinition 4.1. A clause judgement proof on a QCBF instance \u03c8 is a finite sequence of clause judgements, each of which has one of the following types:\n(clause) (i, \u03b1)\nwhere \u03c6(i) is the clause \u03b1\n(resolve) (i, \u03b3)\nwhere (i, \u03b1) and (i, \u03b2) are previous clause judgements, and \u03b3 is a resolvent of \u03b1 and \u03b2\n(upward flow) (i, \u03b1)\nwhere (j, \u03b1) is a previous clause judgement and i is the parent of j\n(\u2200-removal) (i, \u03b1 \\ {y, y}) where (j, \u03b1) is a previous clause judgement, \u03c6(i) = \u2200y\u03c6(j), and i is the parent of j\n(downward flow) (j, \u03b1)\nwhere (i, \u03b1) is a previous clause judgement and i is the parent of j\nWe say that a clause judgement (i, \u03b1) is derivable if there exists a clause judgement proof that contains the clause judgement.\nThe width of a clause judgement (i, \u03b1) is |vars(\u03b1)|. The width of a clause judgement proof is the maximum width over all of its clause judgements; the length of a clause judgement proof is the number of judgements that it contains. In a clause judgement proof, we refer to judgements that are not derived by the rules (upward flow) and (downward flow) as non-flow judgements.\nLet us emphasize that we allow resolution over both existential and universal variables, and the resolvent must be non-tautological, because it must be a clause (for our definition of clause).\n4.1. Relationship to the QCSP proof system. We now define the notion of a QCSP translation of a QCBF instance \u03c8, which intuitively is a QCSP instance that behaves just like \u03c8. When discussing QCSP translations, we will be concerned with structures B that have just one sort s with Bs = {0, 1}; we slightly abuse notation and simply write B = {0, 1}.\nDefinition 4.2. When \u03c8 is a QCBF instance, define a QCSP translation of \u03c8 to be a QCSP instance (\u03c6,B) where B is a one-sorted structure with B = {0, 1} and where \u03c6 is obtainable from \u03c8 by replacing each clause \u03b3 having variables v1, . . . , vk with an atom R(v1, . . . , vk)\nsuch that\nRB = {(f(v1), . . . , f(vk)) | f : {v1, . . . , vk} \u2192 {0, 1} satisfies \u03b3}; we typically assume that I\u03c6 = I\u03c8 and that each subformula of \u03c6 has the same index as the natural corresponding subformula of \u03c8.\nNote that when \u03c8 is a QCBF instance and (\u03c6,B) is a QCSP translation thereof, it can be immediately verified, by induction, that for each index i, an assignment g to {0, 1} that is defined on free(\u03c8(i)) = free(\u03c6(i)) satisfies \u03c8(i) if and only if it satisfies \u03c6(i). In particular, we have that \u03c8 is true if and only if \u03c6 is true on B. We prove that our clause judgement proof system is a faithful interpretation of our QCSP proof system, as made precise by the following theorem.\nTheorem 4.3. Let \u03c8 be a QCBF instance and let (\u03c6,B) be a QCSP translation of \u03c8. For each clause judgement (i, \u03b1) that is derivable from \u03c8, there exists a constraint judgement (i, vars(\u03b1), F ) derivable from (\u03c6,B) such that the unique g : vars(\u03b1)\u2192 {0, 1} that does not satisfy \u03b1 is not in F . The other way around, for each constraint judgement (i, V, F ) that is derivable from (\u03c6,B), and for each mapping g : V \u2192 {0, 1} with g /\u2208 F , there exists a clause judgement (i, \u03b1) derivable from \u03c8 where vars(\u03b1) \u2286 V and g does not satisfy \u03b1. Consequently, an empty clause judgement is derivable from \u03c8 if and only if an empty constraint judgement is derivable from (\u03c6,B).\nThe proof of this theorem is provided in Section A.\n4.2. Simulation of Q-resolution. We now show that our clause judgement proof system simulates Q-resolution [4], as made precise by the following theorem.\nTheorem 4.4. Let \u03c8 be a QCBF instance in prenex form, whose quantifier-free part is a conjunction of clauses with index c. If a clause \u03b3 is derivable from \u03c8 by Q-resolution, then the clause judgement (c, \u03b3) is derivable from \u03c8 by the clause judgement proof system.\nProof. It is straightforwardly verified that each clause derivable by Q-resolution from \u03c8 is contained in the smallest set C of clauses satisfying the following recursive definition: \u2022 Each clause \u03b1 appearing in \u03c8 is in C. \u2022 C is closed under taking resolvents. \u2022 If \u03b1 \u2208 C and y \u2208 vars(\u03b1) is universally quantified and is the first variable in vars(\u03b1) to be\nquantified on the unique path from c to the root of \u03c8, then \u03b1 \\ {y, y} is in C. It suffices to show, then, that for each \u03b1 \u2208 C, the clause judgement (c, \u03b1) is derivable. We consider the three types of clauses according to the just-given recursive definition. For each clause \u03b1 appearing in \u03c8, the clause judgement (c, \u03b1) is derivable by applying the (clause) rule at the location of \u03b1, followed by one application of the (upward flow) rule. For a clause that is a resolvent of two other clauses, one can simply apply the (resolve) rule. Finally, suppose that (c, \u03b1) is derivable and that y \u2208 vars(\u03b1) satisfies the described condition. We need to show that \u03b1 \\ {y, y} is derivable. Let j be the first location where y is quantified when walking from c to the root, and let K be the set of nodes appearing on the unique path from c to the child of j (inclusive). By the definition of C, no variable in vars(\u03b1) is quantified at a location in K and vars(\u03b1) \u2286 free(\u03c8(k)) for each k \u2208 K; hence, (upward flow) can be applied repeatedly to derive (k, \u03b1) for each k \u2208 K. By applying (\u2200-removal) at the child of j, we obtain (j, \u03b1 \\ {y, y}; then, (downward flow) can be applied repeatedly to derive (c, \u03b1 \\ {y, y}.\nThe soundness of Q-resolution (derivability of an empty clause implies falsehood) is thus a consequence of this theorem, Theorem 4.3, and Theorem 3.6.\n4.3. Algorithmic interpretation. We define the following notions relative to a QCBF instance \u03c8. We view \u03c8 as a rooted tree. When i, j \u2208 I\u03c8, we write i \u2264\u03c8 j if i is an ancestor of j, that is, if i occurs on the unique path from j to the root; we write i <\u03c8 j if i \u2264\u03c8 j and i 6= j. We define a located variable to be a pair (i, u) where i \u2208 I\u03c8 is an index, and u is a variable that is quantified at location i; this pair is a \u2200-located variable if u is universally quantified at location i. We say that index j \u2208 I\u03c8 follows a located variable (i, u) if i <\u03c8 j and for each index k \u2208 I\u03c8 with i <\u03c8 k \u2264\u03c8 j, it holds that u \u2208 free(\u03c6(k)). We say that a located variable (j, v) follows a located variable (i, u) if j follows (i, u). We say that an index j or a located variable (j, v) follows a set S of located variables if j follows each located variable in S. A set S of located variables is coherent if for any two distinct elements (i, u), (j, v) \u2208 S, one follows the other (that is, either (i, u) follows (j, v) or (j, v) follows (i, u)). When S is a set of located variables, we use vars(S) to denote the set of variables occurring in the located variables in S. Observe that when a set S of located variables is coherent, no variable occurs in two distinct located variables in S, and so |S| = |vars(S)|. We now present a nondeterministic, recursive algorithm that, in a sense to be made precise, corresponds to the proof system. At each point in time, the algorithm maintains a set S of coherent variables; actions it may perform include branching on a located variable (i, u) such that adding (i, u) to S is still coherent, and, nondeterministically setting a \u2200- located variable (i, y) that follows S. The algorithm returns either the false value F or the indeterminate value \u22a5. On these two values, we define the operation \u2228 by F \u2228 F = F and \u22a5\u2228 F = F \u2228\u22a5 = \u22a5\u2228\u22a5 = \u22a5. Intuitively speaking, the algorithm returns the indeterminate value \u22a5 when a nondeterministically selected action cannot be carried out. We assume that when the algorithm is first invoked on a given QCBF instance, the set S is initially assigned to the empty set. Algorithm Detect_Falsity( QCBF instance \u03c8, coherent set S, assignment a : vars(S)\u2192 {0, 1}) {\nSelect nondeterministically and perform one of the following:\n(falsify) check if there exists a location i following S such that \u03c8(i) is a clause falsified by a with vars(\u03c8(i)) = vars(S); if so, return F, else return \u22a5;\n(Q-branch) check if there exists a located variable (i, u) /\u2208 S such that S \u222a {(i, u)} is coherent; if not, return \u22a5, else: - nondeterministically select such a located variable (i, u); - nondeterministically pick subsets S0, S1 \u2286 S with S0 \u222a S1 = S; - return Detect-Falsity(\u03c8, S0 \u222a {(i, u)}, (a vars(S0))[u\u2192 0]) \u2228\nDetect-Falsity(\u03c8, S1 \u222a {(i, u)}, (a vars(S1))[u\u2192 1])\n(\u2200-branch) check if there exists a \u2200-located variable (i, y) that follows S; if not, return \u22a5, else: - nondeterministically select such a \u2200-located variable (i, y); - nondeterministically pick a value b \u2208 {0, 1}; - return Detect-Falsity(\u03c8, S \u222a {(i, y)}, a[y \u2192 b])\n}\nRelative to a clause judgement proof, we employ the following terminology. A clause judgement (j, \u03b2) that is derived using a previous judgement (i, \u03b1) is said to be a successor of (i, \u03b1); also, (i, \u03b1) is said to be a predecessor of (j, \u03b2). So, a clause judgement derived using the (clause) rule has 0 predecessors, one derived using the (resolve) rule has 2 predecessors, and one derived using one of the other rules has 1 predecessor. We say that a clause judgement proof is tree-like if each clause judgement has at most one successor; in this case, each clause judgement (i, \u03b1) naturally induces a tree (defined recursively) where: each node is labelled with a clause judgement; the root is labelled with (i, \u03b1); and, for each predecessor of the clause judgement (i, \u03b1), the root has a child which is the tree of the predecessor. We formalize the notion of a trace of the nondeterministic algorithm. A trace of a QCBF instance \u03c8 is a rooted tree where: \u2022 each node has a label (S, a) where S is a coherent set of located variables and a : vars(S)\u2192 {0, 1} is an assignment; \u2022 each node has 0, 1, or 2 children; \u2022 when a node has 2 children and label (S, a), the labels of the two children could be\ngenerated by the (Q-branch) step from (S, a); \u2022 when a node has 1 child and label (S, a), the label of the child could be generated by the\n(\u2200-branch) step from (S, a); \u2022 when a node has 0 children and label (S, a), the node has an associated index i that\nfollows S and such that \u03c8(i) is a clause falsified by a with vars(\u03c8(i)) = vars(S).\nWe take it as evident that this notion of trace properly formalizes the recursion trees that the algorithm generates. Let e denote the unique assignment from \u2205 to {0, 1}. We now show that, up to polynomial-time computable translations, tree-like clause judgement proofs of an empty clause correspond precisely to traces having root label (\u2205, e).\nTheorem 4.5. Let \u03c8 be a QCBF instance; let n \u2265 1. There exists a tree-like clause judgement proof P (viewed as a tree) of an empty clause with n non-flow judgements if and only if there exists a trace T whose root has label (\u2205, e) and having n nodes. Moreover, both implied translations (from proof to trace, and from trace to proof) can be computed in polynomial time.\nThe proof of this theorem is provided in Section B.\n5. Algebraic characterization of k-judge-consistency\nWe will assume that all structures under discussion in this section are finite, in that each structure\u2019s universe is finite.\nDefinition 5.1. Let k \u2265 1. A QCSP instance (\u03c6,B) is k-judge-consistent if there does not exist a judgement proof of width less than or equal to k that contains an empty judgement.\nDefinition 5.2. Let (\u03c6,B) be a QCSP instance, where \u03c6 is a qc-formula with index set I, and let k \u2265 1. A k-constraint system P provides, for each i \u2208 I and each V \u2286 free(\u03c6(i)) with |V | \u2264 k, a non-empty set P [i, V ] of maps from V to B satisfying the following four properties: \u2022 (\u03b1) If \u03c6(i) is an atom R(v1, . . . , vm) with V = {v1, . . . , vm}, then P [i, {v1, . . . , vm}] \u2286 {f : {v1, . . . , vm} \u2192 B | (f(v1), . . . , f(vm)) \u2208 RB} \u2022 (\u03c0) If U \u2286 V , then P [i, U ] = (P [i, V ] U).\n\u2022 (\u03bb) If j is a child of i and V \u2286 free(\u03c6(j)), then P [i, V ] = P [j, V ]. \u2022 ( ) If j is a child of i, \u03c6(i) = \u2200y\u03c6(j), U is a subset of free(\u03c6(j)) with |U | \u2264 k and y \u2208 U ,\nand V = U \\ {y}, then P [i, V ] \u2286 y(P [j, U ]).\nWe show that the existence of a k-constraint system characterizes k-judge consistency.\nTheorem 5.3. Let (\u03c6,B) be a QCSP instance. There exists a k-constraint system P for the instance if and only if the instance is k-judge-consistent.\nA proof of this theorem can be found in Section C.\nTheorem 5.4. For each k \u2265 1, there exists a polynomial-time algorithm that, given a QCSP instance (\u03c6,B), decides if the instance is k-judge-consistent.\nProof. We begin by describing the algorithm, which decides, given a QCSP instance (\u03c6,B), whether or not there exists a k-constraint system (this property is equivalent to k-judgeconsistency by Theorem 5.3). Throughout, i and j will always denote indices from I\u03c6. For each i \u2208 I\u03c6 and V \u2286 free(\u03c6(i)) with |V | \u2264 k, the algorithm initializes Q[i, V ] to be {f : {v1, . . . , vm} \u2192 B | (f(v1), . . . , f(vm)) \u2208 RB} in the case that \u03c6(i) is an atom R(v1, . . . , vm) and V = {v1, . . . , vm}, and otherwise initializes Q[i, V ] to be the set of all maps from V to B. The algorithm then iteratively performs the following rules (which parallel properties (\u03c0), (\u03bb), and ( ) in the definition of k-constraint system) until no changes can be made to Q: \u2022 When i is an index and U \u2286 V \u2286 free(\u03c6(i)) with |V | \u2264 k, assign to Q[i, U ] the value Q[i, U ]\u2229(Q[i, V ] U) and then assign to Q[i, V ] the value {f \u2208 Q[i, V ] | (f U) \u2208 Q[i, U ]}. \u2022 If j is a child of i, V \u2286 free(\u03c6(i)) \u2229 free(\u03c6(j)), and |V | \u2264 k, assign to each of Q[i, V ], Q[j, V ] the value Q[i, V ] \u2229Q[j, V ]. \u2022 If j is a child of i, \u03c6(i) = \u2200y\u03c6(j), and U is a set of variables with y \u2208 U \u2286 free(\u03c6(j)) and |U | \u2264 k, then assign to Q[i, U \\ {y}] the value Q[i, U \\ {y}] \u2229 y(P [j, U ]).\nThis algorithm runs in polynomial time: there are polynomially many pairs (i, V ) for which Q[i, V ] is initialized and used, and each Q[i, V ] contains (at most) polynomially many maps: when |V | \u2264 k, the number of maps from V to B is polynomial. (Here, when we say polynomial, we mean as a function of the input length.) Applying the three given rules can be done in polynomial time; each time they are applied, the sets Q[i, V ] may only decrease in size. Hence, the process of repeatedly applying the three rules until no changes are possible terminates in polynomial time. We now explain why the instance is k-judge-consistent if and only if no set Q[i, V ] is empty, which suffices to give the theorem. It is straightforward to verify that, for any k-constraint-system P , the invariant P [i, V ] \u2286 Q[i, V ] is maintained by the algorithm. Hence, when the algorithm terminates, if any set Q[i, V ] is empty, then there does not exist a kconstraint system P . It is also straightforward to verify that, when the algorithm terminates, the four properties in the definition of k-constraint system hold on Q. (As an example, consider property (\u03bb). Suppose that j is a child of i and that V \u2286 free(\u03c6(i)) \u2229 free(\u03c6(j)). When the algorithm terminates, since the second rule can no longer be applied it must hold that Q[i, V ] = Q[j, V ] = Q[i, V ] \u2229Q[j, V ].) Hence, if the algorithm terminates without any empty set Q[i, V ], it holds that Q is a k-constraint system.\nWe can upper bound the number of iterations that the algorithm performs on an instance (\u03c6,B) in the following way. Let n be the maximum number of free variables, over all subformulas of \u03c6. For each index i of \u03c6, the algorithm maintains, for each V \u2286 free(\u03c6(i))\nwith |V | \u2264 k, a set of mappings from V to B. The size of such a set is at most |B||V |. In each iteration, each such set of mappings can only have mappings deleted from it. The number of iterations is thus upper bounded by the number of mappings that can occur in such sets of mappings, which is |I\u03c6|( ( n k ) |B|k + ( n k\u22121 ) |B|k\u22121 + \u00b7 \u00b7 \u00b7+ ( n 0 ) |B|0). We now show that checking for k-judge-consistency gives a way to decide a set of prenex qc-sentences that is tractable via the dichotomy theorem on so-called prefixed graphs [7]. In particular, we prove this in the setting where relation symbols have bounded arity. Let us refer to the width notion defined in that previous work [7] as elimination width. Define the Q-width of a prenex qc-sentence \u03c6 to be the maximum of its elimination width and maxR |ar(R)| (where this maximum ranges over all relation symbols R appearing in \u03c6).\nTheorem 5.5. Let k \u2265 1. Suppose that \u03c6 is a prenex qc-sentence with Q-width k (or less). For any finite structure B, it holds that (\u03c6,B) is k-judge-consistent if and only if B |= \u03c6. (Intuitively, this says that checking for k-judge consistency is a decision procedure for QCSP instances involving \u03c6.)\nThis theorem, in conjunction with Theorem 5.4, immediately implies that for any set \u03a6 of qc-sentences having Q-width bounded by a constant k, checking for k-judge-consistency is a uniform polynomial-time procedure that decides any QCSP instance (\u03c6,B) where \u03c6 \u2208 \u03a6 and B is finite. Hence, in the setting of bounded arity, checking for k-judge-consistency is a generic reasoning procedure that correctly decides the tractable cases of QCSP identified by the work on elimination width.\nIn order to establish this theorem, we first prove a lemma.\nLemma 5.6. Suppose that the QCSP instance (\u03b8,B) is k-judge-consistent, that B is a finite structure, and that \u03b8\u2032 is a qc-sentence obtained from \u03b8 by applying one of the following three syntactic transformations to a subformula of \u03b8:\n(1) \u2227 i\u2208I \u03c6i ( \u2227 j\u2208J \u03c6j) \u2227 ( \u2227 k\u2208K \u03c6k), where I is the disjoint union of J and K (2) Qv(\u03c6 \u2227 \u03c8) (Qv\u03c6) \u2227 \u03c8 where v /\u2208 free(\u03c8) (3) \u2200y \u2227 i\u2208I \u03c6i \u2227 i\u2208I(\u2200y\u03c6i) Then, the QCSP instance (\u03b8\u2032,B) is k-judge-consistent.\nProof. By Theorem 5.3, it suffices to show that if (\u03b8,B) has a k-constraint system P , then (\u03b8\u2032,B) does as well. We consider each of the three cases. Case (1): We define a k-constraint system P \u2032 for (\u03b8\u2032,B) in the following way. Relative to the transformation, let i denote the index of \u03c6i in both \u03b8 and \u03b8\n\u2032; let c denote the index of \u2227 i\u2208I \u03c6i in \u03b8 and of ( \u2227 j\u2208J \u03c6j) \u2227 ( \u2227 k\u2208K \u03c6k) in \u03b8 \u2032; let a be the index of \u2227 j\u2208J \u03c6j in \u03b8 \u2032; and\nlet b be the index of \u2227 k\u2208K \u03c6k in \u03b8\n\u2032. For each other subformula occurrence in \u03b8\u2032, there is a corresponding subformula occurrence in \u03b8; we will assume that these two corresponding subformula occurrences share the same index.\nWe now describe how to define P \u2032. Whenever discussing P \u2032[d, V ], it will hold that d is an index of \u03b8\u2032, and we assume that V \u2286 free(\u03b8\u2032(d)) and |V | \u2264 k. We define P \u2032[i, V ] as P [i, V ]. We define P \u2032[c, V ] as P [c, V ]. We define P \u2032[a, V ] as P [c, V ], and similarly we define P \u2032[b, V ] as P [c, V ]. For each other index ` of \u03b8\u2032, we define P \u2032[`, V ] as P [`, V ]. It is straightforward to verify that P \u2032 is a k-constraint system. Case (2): We proceed as in the previous case; we define a k-constraint system P \u2032 for (\u03b8\u2032,B). Relative to the transformation, let a denote the index of Qv(\u03c6 \u2227 \u03c8) in \u03b8; let b denote the index of the subformula Qv\u03c6 in \u03b8\u2032. We define P \u2032[b, V ] as P [a, V ]. For each other subformula occurrence of \u03b8\u2032 with index `, there exists a corresponding subformula\noccurrence of \u03b8 which we assume to also have index `. We define P \u2032[`, V ] as P [`, V ]. It is straightforward to verify that P \u2032 is a k-constraint system.\nCase (3): We proceed as in the previous cases; we define a k-constraint system P \u2032 for (\u03b8\u2032,B). Let d denote the index of \u2200y \u2227 i\u2208I \u03c6i in \u03b8, and also the index of \u2227 i\u2208I(\u2200y\u03c6i) in \u03b8\u2032. Let i denote the index of \u03c6i in both \u03b8 and \u03b8 \u2032. Let c denote the index of \u2227 i\u2208I \u03c6i in \u03b8, and let i\u2032 denote the index of \u2200y\u03c6i in \u03b8\u2032. For each V \u2286 free(\u2200y\u03c6i) with |V | \u2264 k, define P \u2032[i\u2032, V ] to be P [d, V ]. Elsewhere, define P \u2032 to be equal to P (each other index of \u03b8\u2032 corresponds to an index of \u03b8). It is straightforward to verify that P \u2032 is a k-constraint system. In the region of interest, the property ( ) can be verified as follows. Suppose that U \u2286 free(\u03c6(i)) has |U | \u2264 k and y \u2208 U , and that V = U \\ {y}. Then P [d, V ] \u2286 y(P [c, U ]) = y(P [i, U ]) since P is a k-constraint system. As P \u2032[i\u2032, V ] = P [d, V ] by our definition of P \u2032, it follows that P \u2032[i\u2032, V ] \u2286 y(P [i, U ]).\nProof. (Theorem 5.5) Suppose that the instance (\u03c6,B) is not k-judge-consistent. Then, by definition, there exists a judgement proof for the instance containing an empty judgement, implying that B 6|= \u03c6 by Theorem 3.6.\nFor the other direction, suppose that B 6|= \u03c6. From the definition of elimination width (defined as width in [7]), it can straightforwardly be verified by induction on the number of variables in \u03c6 that \u03c6 can be transformed to a sentence \u03c6\u2032 having width less than or equal to k, via the three syntactic transformations of Lemma 5.6. As these three syntactic transformations preserve logical equivalence, we have B 6|= \u03c6\u2032. By Theorem 3.6, an empty judgement is derivable; by the proof of this theorem, there is a judgement proof with the empty judgement whose width is equal to the width of \u03c6\u2032. Since the width of \u03c6\u2032 is less than or equal to k, we thus obtain a judgement proof of the empty judgement having width less than or equal to k, so by definition, (\u03c6\u2032,B) is not k-judge-consistent. By appeal to Lemma 5.6, (\u03c6,B) is not k-judge-consistent."}, {"heading": "Acknowledgements", "text": "The author thanks Moritz Mu\u0308ller and Friedrich Slivovsky for useful comments. This work was supported by the Spanish project TIN2013-46181-C2-2-R, by the Basque project GIU12/26, and by the Basque grant UFI11/45."}, {"heading": "Appendix A. Proof of Theorem 4.3", "text": "The theorem follows directly from the following two theorems.\nTheorem A.1. Let \u03c8 be a QCBF instance and let (\u03c6,B) be a QCSP translation of \u03c8. For each clause judgement proof of \u03c8 having length s and width w, there exists a constraint judgement proof of (\u03c6,B) having length \u2264 2s and width \u2264 w + 1 such that: each clause judgement (i, \u03b1) appearing in the first proof has the entailment property that there exists a constraint judgement in the second proof of the form (i, vars(\u03b1), F ) such that each f \u2208 F satisfies \u03b1 (equivalently, the unique g : vars(\u03b1)\u2192 {0, 1} that does not satisfy \u03b1 is not in F ).\nA direct consequence of this theorem is that if the original clause judgement proof contains an empty clause, then the produced constraint judgement proof contains an empty constraint.\nProof. We prove this by induction on s. Given a clause judgement proof P of length s+ 1 we create a constraint judgement proof in the following way. Apply induction to the clause judgement proof consisting of the first s judgements in P ; this gives a constraint judgement proof P \u2032. We then need to show how to augment P \u2032. We consider cases, depending on the rule used to derive the last judgement of P . We use the notation of Definition 4.1. \u2022 In the case of (clause) deriving (i, \u03b1), apply (atom) at location i. \u2022 In the case of (resolve) deriving (i, \u03b3) from (i, \u03b1) and (i, \u03b2), let v be the variable underlying\nthe complementary literals that are eliminated from \u03b1 and \u03b2 to obtain \u03b3. The rule (join) is applied to the constraint judgements corresponding to (i, \u03b1) and (i, \u03b2) to obtain a new judgement, and then (projection) is used to remove the variable v from that new judgement. \u2022 In the case of (upward flow) or (downward flow), the same rule is applied to the corre-\nsponding constraint judgement. \u2022 In the case of (\u2200-removal), the rule (\u2200-elimination) is applied to the corresponding\nconstraint judgement.\nIn the case (resolve), two new constraint judgements are produced, and in all other cases, one new constraint judgement is produced; hence, the claim on the length is correct. In the case (resolve), the width of the first constraint judgement produced is one more than the width of the corresponding clause judgement, and the width of the second constraint judgement produced is equal to the width of the corresponding clause judgement; in all other cases, the new constraint judgement produced has width equal to that of the corresponding clause judgement. Hence, the claim on the width is correct. In each case, it is straightforward to verify the claimed entailment property. As an example, we verify the claimed entailment property in the case of (resolve). Suppose that (resolve) derives (i, \u03b3) from (i, \u03b1) and (i, \u03b2). Let g\u03b1 : vars(\u03b1) \u2192 {0, 1}, g\u03b2 : vars(\u03b2) \u2192 {0, 1}, and g\u03b3 : vars(\u03b3) \u2192 {0, 1} be assignments not satisfying \u03b1, \u03b2, and \u03b3, respectively. Let v be the variable such that vars(\u03b3) = (vars(\u03b1) \u222a vars(\u03b2)) \\ {v}. We assume without loss of generality that g\u03b1(v) = 0 and that g\u03b2(v) = 1. Let (i, vars(\u03b1), F\u03b1) and (i, vars(\u03b2), F\u03b2) be the constraint judgements for (i, \u03b1) and (i, \u03b2), respectively; we have g\u03b1 /\u2208 F\u03b1 and g\u03b2 /\u2208 F\u03b2. Consider the constraint judgement (i, vars(\u03b1) \u222a vars(\u03b2), F\u03b1 on F\u03b2) obtained by applying (join) to these two constraint judgements. By definition of the join on, neither g\u03b1 not g\u03b2 has an extension defined on vars(\u03b1)\u222a vars(\u03b2) that is contained in F\u03b1 on F\u03b2 . Next, consider the constraint judgement (i, vars(\u03b3), (F\u03b1 on F\u03b2) vars(\u03b3)) obtained from the previous one by applying (projection). We claim that g\u03b3 /\u2208 (F\u03b1 on F\u03b2) vars(\u03b3). Suppose not,\nfor a contradiction; then there exists an extension g\u2032\u03b3 of g\u03b3 which is contained in F\u03b1 on F\u03b2 . If g\u2032\u03b3(v) = 0, then g \u2032 \u03b3 is an extension of g\u03b1, but g \u2032 \u03b3 \u2208 F\u03b1 on F\u03b2 contradicts g\u03b1 /\u2208 F\u03b1; analogously, If g\u2032\u03b3(v) = 1, then g \u2032 \u03b3 is an extension of g\u03b2, but g \u2032 \u03b3 \u2208 F\u03b1 on F\u03b2 contradicts g\u03b2 /\u2208 F\u03b2.\nTheorem A.2. Let \u03c8 be a QCBF instance and let (\u03c6,B) be a QCSP translation of \u03c8. For each constraint judgement proof of (\u03c6,B) having length s and width w, there exists a clause judgement proof of \u03c8 of length \u2264 s \u00b7max(w2w\u22121, 1) and width \u2264 w such that: each constraint judgement (i, V, F ) appearing in the first proof has the entailment property that, for each mapping g : V \u2192 {0, 1} with g /\u2208 F , there exists a clause judgement (i, \u03b1) with vars(\u03b1) \u2286 V in the second proof where \u03b1 is not satisfied by g.\nA direct consequence of this theorem is that if a constraint judgement proof of (\u03c6,B) having length s and width w contains an empty constraint, it may be augmented by one constraint judgement to contain an empty constraint of the form (i, \u2205, \u2205), and then the theorem yields that there is a clause judgement proof having an empty clause of length \u2264 (s+ 1) \u00b7max(w2w\u22121, 1) and width \u2264 w.\nProof. We proceed as in the proof of the previous theorem. We prove this by induction on s. Given a constraint judgement proof P of length s+ 1, we create a clause judgement proof P \u2032 by applying induction to P with the last constraint judgement removed; we then explain how to augment the resulting clause judgement proof P \u2032 so that the last constraint judgement of P has a corresponding clause judgement with the properties given in the theorem statement. We consider cases depending on the rule used to derive the last constraint judgement of P ; we use the notation of Definition 3.3. \u2022 In the case of (atom) deriving (i, V, F ), apply (clause) at location i. \u2022 In the case of (projection) deriving (i, U, F U) from (i, V, F ), we first explain how to\nobtain the clause judgements in the case that |V | = |U |+ 1. Let v be the variable such that U \u222a{v} = V . For each clause judgement (i, \u03b1) with vars(\u03b1) \u2286 U that can be obtained by resolving two clause judgements in P \u2032 on the variable v, include the clause judgement in the proof. The maximum number of clause judgements that we can add in this fashion is the number of clauses on (w \u2212 1) variables, that is, 2w\u22121.\nIn the general case where U \u2286 V , we may proceed by applying the described procedure |V | \u2212 |U | many times. Since |V | \u2212 |U | \u2264 w, the total number of clause judgements that will be added can be upper bounded by w2w\u22121. \u2022 In the case of (join), no clause judgement needs to be added. This is because of the\nfollowing. Suppose the constraint judgement (i, U1 \u222a U2, F1 on F2) is obtained by applying (join) to (i, U1, F1) and (i, U2, F2). For each mapping g : U1\u222aU2 \u2192 {0, 1} with g /\u2208 F1 on F2, it holds (by definition of on) that either g U1 /\u2208 F1 or g U2 /\u2208 F2. \u2022 In the case of (\u2200-elimination) deriving (i, V \\ {y}, yF ) from (j, V, F ), take all clause\njudgements (j, \u03b1) where y \u2208 vars(\u03b1) \u2286 V , and apply (\u2200-removal) to each of these clause judgements. \u2022 In the case of (upward flow) or (downward flow), the same rule is applied to the corre-\nsponding clause judgement.\nIn each case, the clause judgements produced have width less than or equal to w. We now consider the number of clause judgements produced in each case. This number is 1 in the cases (atom), (upward flow), and (downward flow), and is 0 in the case (join). In the case of (projection), we argued that this number is less than or equal to w2w\u22121. In the case of\n(\u2200-elimination), since this rule can only be applied if w \u2265 1 and at most 2w\u22121 clauses are generated, we can also bound this number by w2w\u22121.\nIn each case, it is straightforward to verify the claimed entailment property."}, {"heading": "Appendix B. Proof of Theorem 4.5", "text": "The theorem follows directly from the following two theorems.\nTheorem B.1. Let \u03c8 be a QCBF instance. Given a tree-like clause judgement proof P (viewed as a tree) of an empty clause, there exists a trace E whose root has label (\u2205, e) and where the number of nodes in E is equal to the number of non-flow judgements in P . (Here, we use e to denote the unique assignment from \u2205 to {0, 1}.) Also, the translation from P to E is polynomial-time computable.\nProof. We prove the following result, which yields the theorem. Suppose that P is a tree-like clause judgement proof, viewed as a tree; using (i, \u03b1) to denote the clause judgement at the root of P , there exists a trace E whose number of nodes is equal to the number of non-flow judgements in P , and whose root has label (S, a), such that the following two conditions hold: (1) For each v \u2208 vars(\u03b1), the set S contains the located variable (j, v) where j is the first location above i where v is quantified. (2) The assignment a is the unique assignment on vars(\u03b1) that falsifies \u03b1.\nWe prove this result by induction on the structure of P , describing directly how to construct E. We consider cases depending on how the clause judgement at the root of P was derived; we use the notation of Definition 4.1. In the case of (clause), let E consist of a single node having label (S, a), where (S, a) is the unique pair satisfying the two conditions. In the case of (resolve), suppose that (i, \u03b3) is the clause judgement at the root of P and that (i, \u03b3) is derived as a resolvent of \u03b1 and \u03b2 via clause judgements (i, \u03b1) and (i, \u03b2). Suppose that v \u2208 \u03b1 and v \u2208 \u03b2 are the complementary literals such that \u03b3 = (\u03b1 \\ {v}) \u222a (\u03b2 \\ {v}). Take the trace whose root has label (U, c) where U is the union of S and T but without the located variable containing v, and where c is the unique assignment on vars(U) = vars(\u03b3) that falsifies \u03b3. Since i follows S and i follows T , we have that i follows U , and we have that (S, a) and (T, b) could be generated from (U, c) via a (Q-branch) step. In the case of (\u2200-removal), suppose that the clause judgement at the root of P has the form (i, \u03b1 \\{y, y}) and is derived from (j, \u03b1) where \u03c6(i) = \u2200y\u03c6(j). If \u03b1\u2229{y, y} = \u2205, then the trace E can be taken to be the trace given by induction. Otherwise, take the trace for (j, \u03b1) given by induction, and let (T, a) denote its root node label. Set S to be T , but with the located variable for y removed. We have that (T, a) could be derived from (S, a vars(S)) by a (\u2200-branch) step; hence, we may take the trace obtained from the trace for (j, \u03b1) by adding on the top a new root node with label (S, a vars(S)). In the case of (upward flow) or (downward flow), we simply take the trace given by induction. This preserves condition (1): if i is the parent of j in \u03c6 and (i, \u03b1) and (j, \u03b1) are clause judgements in P , then vars(\u03b1) \u2286 free(\u03c8(i)) \u2229 free(\u03c8(j)) and so no variable in vars(\u03b1) is quantified at location i (nor j).\nTheorem B.2. Let \u03c8 be a QCBF instance. Given a trace T with root node label (\u2205, e), there exists a tree-like clause judgement proof P of an empty clause where the number of non-flow nodes in P (viewed as a tree) is equal to the number of nodes in T . Also, the translation from T to P is polynomial-time computable.\nProof. We prove the following result which implies the theorem: for any trace T with root node label (S, a), there exists a tree-like clause judgement proof P ending in (i, \u03b1) where the number of nodes in P and T are related as in the theorem statement, and such that the following two conditions hold:\n(1) i follows S. (2) vars(S) = vars(\u03b1) and a is the unique assignment on vars(\u03b1) that falsifies \u03b1.\nWe prove the result by induction; we consider cases depending on the type of the root node of T , that is, depending on how many children the root node of T has.\nIf the root node of T is a leaf, the result is clear from the definition of trace. If the root node of T has one child, let (S \u222a {(j, y)}, a[y \u2192 b]) be the label of the child of the root node. By induction, there exists a tree-like clause judgement proof ending with (k, \u03b2) where k follows S \u222a {(j, y)} and a[y \u2192 b] is the unique assignment on vars(\u03b2) that falsifies \u03b2. Since (j, y) follows S and k follows (j, y), by applying (upward flow), we may obtain a tree-like clause judgement proof ending with (c, \u03b2) where c is the child of j. Then, as \u03c8(j) = \u2200y\u03c8(c), we can apply (\u2200-removal) to (c, \u03b2) to obtain the desired clause judgement proof. If the root node of T has two children, let (S0 \u222a {(j, u)}, (a vars(S0))[u \u2192 a0]) and (S1\u222a{(j, u)}, (a vars(S1))[u\u2192 a1]) be the labels of the children; we have a0, a1 \u2208 {0, 1} and a0 6= a1. By induction, we have tree-like clause judgement proofs ending with (k0, \u03b20) and (k1, \u03b21) where k0 follows S0 \u222a {(j, u)} and (a vars(S0))[u\u2192 a0] is the unique assignment on vars(\u03b20) that falsifies \u03b20; and similarly, k1 follows S1 \u222a {(j, u)} and (a vars(S1))[u\u2192 a1] is the unique assignment on vars(\u03b21) that falsifies \u03b21. By applying (upward flow), we obtain tree-like clause judgement proofs ending with (`0, \u03b20) and (`1, \u03b21) where `0 is the child of the lowest location in S0 \u222a {(j, u)}, and `1 is the child of the lowest location in S1 \u222a {(j, u)}. Let m be the child of the lowest location in S \u222a {(j, u)}. At least one of `0, `1 is equal to m (since S0 \u222a S1 = S). If one of `0, `1 is not equal to m, say `b, we may apply (downward flow) to obtain a clause judgement proof (m,\u03b2b); this is because vars(\u03b2b) is free in every location between m and `b (inclusive), as S \u222a {(j, u)} is coherent. We hence obtain clause judgement proofs for (m,\u03b20) and for (m,\u03b21). Apply (resolve) to these to obtain the desired clause judgement proof."}, {"heading": "Appendix C. Proof of Theorem 5.3", "text": "Theorem 5.3 follows immediately from the two lemmas presented in this section.\nLemma C.1. Let (\u03c6,B) be a QCSP instance. If there exists a k-constraint system P for the instance, then the instance is k-judge-consistent.\nProof. We show, by induction on the proof structure, that if (i, V, F ) with |V | \u2264 k is a derivable judgement, then P [i, V ] \u2286 F . We consider cases based on which rule was used to derive (i, V, F ).\nIn the case of (atom), we have P [i, V ] \u2286 F by property (\u03b1).\nIn the case of (projection), we suppose that (i, V, F ) is a previous judgement with P [i, V ] \u2286 F , and that the judgement of interest has the form (i, U, F U), where U \u2286 V . We have P [i, U ] = (P [i, V ] U) \u2286 (F U), where the equality holds by property (\u03c0). In the case of (join), we suppose that (i, U1, F1) and (i, U2, F2) are previous judgements with P [i, U1] \u2286 F1 and P [i, U2] \u2286 F2, and that the judgement of interest is (i, U1 \u222a U2, F1 on F2). By property (\u03c0), we have that P [i, U1 \u222a U2] U1 = P [i, U1] and P [i, U1 \u222a U2] U2 = P [i, U2]. It follows that P [i, U1 \u222a U2] \u2286 P [i, U1] on P [i, U2] \u2286 F1 on F2.\nThe cases of (upward flow) and (downward flow) follow immediately from property (\u03bb). In the case of (\u2200-elimination), we suppose that (j, V, F ) is a previous judgement with P [j, V ] \u2286 F , and that the judgement of interest is (i, V \\ {y}, yF ) where i is the parent of j, and \u03c6(i) = \u2200y\u03c6(j). We have P [i, V \\{y}] \u2286 y(P [j, V ]) \u2286 y(F ), where the first containment holds by property ( ).\nDefinition C.2. Let k \u2265 1. A structure B is k-behaved if for each i with 1 \u2264 i \u2264 k, there are finitely many relations of arity i that are qc-definable over B.\nLemma C.3. Let k \u2265 1. Let (\u03c6,B) be a QCSP instance where B is k-behaved. If the instance is k-judge-consistent, then then there exists a k-constraint system P for the instance.\nProof. Relative to a QCSP instance, we say that a judgement is k-derivable if there exists a judgement proof of width less than or equal to k that contains the judgement.\nLet I be an index set for \u03c6. Let us say that a k-derivable judgement (i, V, F ) is minimal if for all sets G such that the judgement (i, V,G) is k-derivable, it holds that G \u2286 F implies G = F . We claim that, when i \u2208 I and V \u2286 free(\u03c6(i)) with |V | \u2264 k, there is a unique minimal k-derivable judgement (i, V, F ). The existence of a minimal k-derivable judgement follows from Lemma 3.5 and the k-behavedness of B. To establish uniqueness, suppose for a contradiction that (i, V, F1) and (i, V, F2) are both minimal k-derivable judgements and F1 6= F2. By the definition of minimal, we have F1 6\u2286 F2 and F2 6\u2286 F1, so F1 \u222a F2 6\u2286 F1 and F1 \u222a F2 6\u2286 F2. By the (join) rule, the judgement (i, V, F1 on F2) is k-derivable; since here F1 on F2 = F1 \u2229 F2, we obtain a contradiction.\nFor all i \u2208 I and V \u2286 free(\u03c6(i)), we define P [i, V ] so that (i, V, P [i, V ]) is the unique minimal k-derivable judgement involving i and V . We confirm that P is a k-constraint system by verifying that it satisfies each of the four properties of the definition of k-constraint system. In discussing each of the properties, we use the notation of Definition 5.2.\nProperty (\u03b1) follows immediately from the (atom) rule. For property (\u03c0), suppose that U \u2286 V . We have that (i, U, P [i, U ]) and (i, V, P [i, V ]) are k-derivable. It follows that (i, V, FV ) and (i, U, FU ) are k-derivable, where FV = P [i, U ] on P [i, V ] and FU = FV U . We have FV \u2286 P [i, V ] and FU \u2286 P [i, U ]; it follows, by definition of P , that FV = P [i, V ] and FU = P [i, U ]. Since FU = FV U , we have P [i, U ] = P [i, V ] U .\nFor property (\u03bb), suppose that j is a child of i with V \u2286 free(\u03c6(j)). We have that (i, V, P [i, V ]) and (j, V, P [j, V ]) are k-derivable. By the (downward flow) and (upward flow) rules, we obtain that (i, V, P [j, V ]) and (j, V, P [i, V ]) are k-derivable. By definition of P , we obtain that P [i, V ] \u2286 P [j, V ] and P [j, V ] \u2286 P [i, V ] and hence P [i, V ] = P [j, V ]. For property ( ), suppose that j is a child of i, \u03c6(i) = \u2200y\u03c6(j), U is a subset of free(\u03c6(j)) with |U | \u2264 k and y \u2208 U , and V = U \\ {y}. That P [i, V ] \u2286 y(P [j, U ]) follows immediately from applying the (\u2200-elimination) rule to the k-derivable judgement (j, U, P [j, U ])."}], "references": [{"title": "Constraint propagation as a proof system", "author": ["A. Atserias", "P. Kolaitis", "M. Vardi"], "venue": "In Proceedings of CP,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Constraint satisfaction problems of bounded width", "author": ["L. Barto", "M. Kozik"], "venue": "In Proceedings of FOCS\u201909,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Propositional proof complexity: Past, present and future", "author": ["P. Beame", "T. Pitassi"], "venue": "Bulletin of the EATCS,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1998}, {"title": "Resolution for quantified Boolean formulas", "author": ["H.K. B\u00fcning", "M. Karpinski", "A. Fl\u00f6gel"], "venue": "Information and Computation,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1995}, {"title": "The tractability frontier of graph-like first-order query sets", "author": ["H. Chen"], "venue": "In Joint Meeting of the Twenty- Third EACSL Annual Conference on Computer Science Logic (CSL) and the Twenty-Ninth Annual ACM/IEEE Symposium on Logic in Computer Science (LICS), CSL-LICS \u201914,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "From Pebble Games to Tractability: An Ambidextrous Consistency Algorithm for Quantified Constraint Satisfaction", "author": ["H. Chen", "V. Dalmau"], "venue": "In Computer Science", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2005}, {"title": "Decomposing quantified conjunctive (or disjunctive) formulas", "author": ["H. Chen", "V. Dalmau"], "venue": "In LICS,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "Gru\u00dfien. Arc consistency and friends", "author": ["H. Chen", "V. Dalmau"], "venue": "J. Log. Comput.,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "On sequent systems and resolution for qbfs", "author": ["U. Egly"], "venue": "In SAT, pages 100\u2013113,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "A solver for QBFs in negation normal", "author": ["U. Egly", "M. Seidl", "S. Woltran"], "venue": "form. Constraints,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Clause/term resolution and learning in the evaluation of quantified Boolean formulas", "author": ["E. Giunchiglia", "M. Narizzano", "A. Tacchella"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "On propositional QBF expansions and Q-resolution", "author": ["M. Janota", "J. Marques-Silva"], "venue": "In SAT,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "A game-theoretic approach to constraint satisfaction", "author": ["P.G. Kolaitis", "M.Y. Vardi"], "venue": "In Proceedings of the 17th National Conference on AI,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2000}, {"title": "Evaluating and certifying qbfs: A comparison of state-of-the-art tools", "author": ["M. Narizzano", "C. Peschiera", "L. Pulina", "A. Tacchella"], "venue": "AI Commun.,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "The complexity of propositional proofs", "author": ["N. Segerlind"], "venue": "Bull. Symbolic Logic,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2007}, {"title": "Computing resolution-path dependencies in linear time", "author": ["F. Slivovsky", "S. Szeider"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}], "referenceMentions": [{"referenceID": 2, "context": "The study of propositional proof systems for certifying the unsatisfiability of quantifier-free propositional formulas is supported by multiple motivations [3, 15].", "startOffset": 156, "endOffset": 163}, {"referenceID": 14, "context": "The study of propositional proof systems for certifying the unsatisfiability of quantifier-free propositional formulas is supported by multiple motivations [3, 15].", "startOffset": 156, "endOffset": 163}, {"referenceID": 0, "context": "Finally, algorithms that check for unsatisfiability proofs of various restricted forms have been shown to yield tractable cases of the propositional satisfiability problem and related problems (see for example [1, 2]).", "startOffset": 210, "endOffset": 216}, {"referenceID": 1, "context": "Finally, algorithms that check for unsatisfiability proofs of various restricted forms have been shown to yield tractable cases of the propositional satisfiability problem and related problems (see for example [1, 2]).", "startOffset": 210, "endOffset": 216}, {"referenceID": 13, "context": "space of potential certificate formats for verifying their correctness on particular input instances [14].", "startOffset": 101, "endOffset": 105}, {"referenceID": 3, "context": "Q-resolution [4] is a quantified proof system that can be viewed as a quantified analog of resolution, one of the best-known and most customarily considered propositional proof systems.", "startOffset": 13, "endOffset": 16}, {"referenceID": 10, "context": "In the context of quantified propositional logic, Q-resolution is a heavily studied and basic proof system on which others are built and to which others are routinely compared, as well as a point of departure for the discussion of suitable certificate formats (see [11, 16, 12] for examples).", "startOffset": 265, "endOffset": 277}, {"referenceID": 15, "context": "In the context of quantified propositional logic, Q-resolution is a heavily studied and basic proof system on which others are built and to which others are routinely compared, as well as a point of departure for the discussion of suitable certificate formats (see [11, 16, 12] for examples).", "startOffset": 265, "endOffset": 277}, {"referenceID": 11, "context": "In the context of quantified propositional logic, Q-resolution is a heavily studied and basic proof system on which others are built and to which others are routinely compared, as well as a point of departure for the discussion of suitable certificate formats (see [11, 16, 12] for examples).", "startOffset": 265, "endOffset": 277}, {"referenceID": 9, "context": "As argued by Egly, Seidl, and Woltran [10], this may disrupt the original formula structure, \u201cartificially extend\u201d the scopes of quantifiers, and generate dependencies among variables that were not originally present, unnecessarily increasing the expense of solving; we refer the reader to their article for a contemporary discussion of this issue.", "startOffset": 38, "endOffset": 42}, {"referenceID": 15, "context": "dependencies in a prenex formula [16].", "startOffset": 33, "endOffset": 37}, {"referenceID": 0, "context": "An example used in practice is arc consistency, and understanding when various forms of consistency provide an exact characterization of satisfiability (that is, when consistency is sufficient for satisfiability in addition to being necessary) has been a central theme in the tractability theory of constraint satisfaction [1, 2, 8].", "startOffset": 323, "endOffset": 332}, {"referenceID": 1, "context": "An example used in practice is arc consistency, and understanding when various forms of consistency provide an exact characterization of satisfiability (that is, when consistency is sufficient for satisfiability in addition to being necessary) has been a central theme in the tractability theory of constraint satisfaction [1, 2, 8].", "startOffset": 323, "endOffset": 332}, {"referenceID": 7, "context": "An example used in practice is arc consistency, and understanding when various forms of consistency provide an exact characterization of satisfiability (that is, when consistency is sufficient for satisfiability in addition to being necessary) has been a central theme in the tractability theory of constraint satisfaction [1, 2, 8].", "startOffset": 323, "endOffset": 332}, {"referenceID": 0, "context": "Atserias, Kolaitis, and Vardi [1] showed that checking for k-consistency, an oft-considered consistency notion, can be viewed as detecting the absence of a proof of unsatisfiability having width at most k, in a natural proof system (the width of a proof is the maximum number of variables appearing in a line of the proof); Kolaitis and Vardi [13] also characterized k-consistency algebraically as whether or not Duplicator can win a natural Spoiler-Duplicator pebble game in the spirit of Ehrenfeucht-Fr\u00e4\u0131ss\u00e9 games.", "startOffset": 30, "endOffset": 33}, {"referenceID": 12, "context": "Atserias, Kolaitis, and Vardi [1] showed that checking for k-consistency, an oft-considered consistency notion, can be viewed as detecting the absence of a proof of unsatisfiability having width at most k, in a natural proof system (the width of a proof is the maximum number of variables appearing in a line of the proof); Kolaitis and Vardi [13] also characterized k-consistency algebraically as whether or not Duplicator can win a natural Spoiler-Duplicator pebble game in the spirit of Ehrenfeucht-Fr\u00e4\u0131ss\u00e9 games.", "startOffset": 343, "endOffset": 347}, {"referenceID": 6, "context": "As an application of this algebraic characterization, we prove that (in a sense made precise) any case of the QCSP that lies in the tractable regime of a recent dichotomy theorem [7], is tractable via checking for k-judge-consistency.", "startOffset": 179, "endOffset": 182}, {"referenceID": 5, "context": "We remark that earlier work [6] presents algebraically a notion of consistency for the QCSP, but no corresponding proof system was explicitly presented; the notion of k-judgement consistency can be straightforwardly verified to imply the notion of consistency in this earlier article.", "startOffset": 28, "endOffset": 31}, {"referenceID": 8, "context": "One particular possibility for future work is to compare this proof system to others that are defined on non-prenex formulas, such as those discussed and studied by Egly [9].", "startOffset": 170, "endOffset": 173}, {"referenceID": 4, "context": "2 Let us remark that this dichotomy theorem has since been generalized [5].", "startOffset": 71, "endOffset": 74}, {"referenceID": 3, "context": "We now show that our clause judgement proof system simulates Q-resolution [4], as made precise by the following theorem.", "startOffset": 74, "endOffset": 77}, {"referenceID": 6, "context": "We now show that checking for k-judge-consistency gives a way to decide a set of prenex qc-sentences that is tractable via the dichotomy theorem on so-called prefixed graphs [7].", "startOffset": 174, "endOffset": 177}, {"referenceID": 6, "context": "Let us refer to the width notion defined in that previous work [7] as elimination width.", "startOffset": 63, "endOffset": 66}, {"referenceID": 6, "context": "From the definition of elimination width (defined as width in [7]), it can straightforwardly be verified by induction on the number of variables in \u03c6 that \u03c6 can be transformed to a sentence \u03c6\u2032 having width less than or equal to k, via the three syntactic transformations of Lemma 5.", "startOffset": 62, "endOffset": 65}], "year": 2014, "abstractText": "We consider the quantified constraint satisfaction problem (QCSP) which is to decide, given a structure and a first-order sentence (not assumed here to be in prenex form) built from conjunction and quantification, whether or not the sentence is true on the structure. We present a proof system for certifying the falsity of QCSP instances and develop its basic theory; for instance, we provide an algorithmic interpretation of its behavior. Our proof system places the established Q-resolution proof system in a broader context, and also allows us to derive QCSP tractability results.", "creator": "LaTeX with hyperref package"}}}