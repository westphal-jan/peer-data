{"id": "1405.1005", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-May-2014", "title": "Comparing apples to apples in the evaluation of binary coding methods", "abstract": "We discuss methodological issues related to the evaluation of unsupervised binary code construction methods for nearest neighbor search. These issues have been widely ignored in literature. These coding methods attempt to preserve either Euclidean distance or angular (cosine) distance in the binary embedding space. We explain why when comparing a method whose goal is preserving cosine similarity to one designed for preserving Euclidean distance, the original features should be normalized by mapping them to the unit hypersphere before learning the binary mapping functions. To compare a method whose goal is to preserves Euclidean distance to one that preserves cosine similarity, the original feature data must be mapped to a higher dimension by including a bias term in binary mapping functions. These conditions ensure the fair comparison between different binary code methods for the task of nearest neighbor search. Our experiments show under these conditions the very simple methods (e.g. LSH and ITQ) often outperform recent state-of-the-art methods (e.g. MDSH and OK-means).", "histories": [["v1", "Mon, 5 May 2014 19:26:58 GMT  (795kb)", "http://arxiv.org/abs/1405.1005v1", null], ["v2", "Sat, 27 Sep 2014 18:35:35 GMT  (570kb)", "http://arxiv.org/abs/1405.1005v2", null]], "reviews": [], "SUBJECTS": "cs.CV cs.LG", "authors": ["mohammad rastegari", "shobeir fakhraei", "jonghyun choi", "david jacobs", "larry s davis"], "accepted": false, "id": "1405.1005"}, "pdf": {"name": "1405.1005.pdf", "metadata": {"source": "CRF", "title": "Comparing apples to apples in the evaluation of binary coding methods", "authors": ["Mohammad Rastegari", "Shobeir Fakhraei", "Jonghyun Choi", "David Jacobs", "Larry S. Davis"], "emails": ["@cs.umd.edu", "@umiacs.umd.edu"], "sections": [{"heading": "1 Introduction", "text": "Binary codes are attractive representations of data for similarity based search and retrieval purposes, due to their storage and computational efficacy. For example, 250 million images can be represented by 64 bit binary codes by employing only 16 GB of memory. Hashing is a common method to convert high dimensional features to binary codes whose Hamming distances preserve the original feature space distances. Although shorter codes are more desirable due to direct representation in hash tables, longer binary descriptors of data have also been shown to be efficient for fast similarity search tasks. For example, Norouzi et al. [15] proposed a multi-index hashing method, and Rastegari et al. [18] introduced a branch and bound approach to perform exact k-nearest neighbors search in sub-linear time with long binary codes.\nThere are two major categories of hashing methods. One group is based on random projections of data. For example, Datar et al. [1] introduced locality sensitivity hashing (LSH) and provide theoretical guarantees on retrieval in sublinear time. Locality Sensitive Hashing refers to a wide range of techniques but we use the term LSH for the random projection based technique as is common in the vision and learning communities. Data driven approaches, on the other hand, employ a learning procedure for binary code mapping. For instance, Weiss\net al. [23] introduced Spectral Hashing (SPH) and [24] Multidimensional Spectral Hashing (MDSH); they formulate the problem as an optimization that reduces to an eigenvalue problem. Furthermore, Gong and Lazebnik [5](ITQ) and Norouzi and Fleet [16] (CK-means) proposed methods to minimize the quantization error of mapping the data to a binary hypercube via rotation. These methods are based on vector quantization. Product Quantization [7] is an instance of Cartesian Kmeans[16] that does not optimize for rotation and Orthogonal K-means is the binary version of CK-means that number of subspaces are equal to the number of bits. There is another class of binary code learning methods that are supervised [12, 14, 19]. In these methods pairs of similar samples are provided for training and metric is learned. We experimentally observed that given a good supervision, MLH[14] performs similar to ITQ. In this paper we restrict our attention to unsupervised methods \u2013 there is no specification of similar or dissimilar samples.\nA common task used for evaluating performance of binary codes is a range searching task \u2013 find all samples within distance r of a query point. The performance of different methods in preserving feature space distances in the Hamming space depends on the distribution of data in the original feature space and the way that data is normalized before codes are designed. Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account. In particular, some methods preserve cosine similarity [5], while others preserve Euclidean distance [8, 24]. We should not compare the performance of these methods blindly.\nOur main contribution is to show that in many published comparisons, this distinction has not be accounted for sufficiently. When the goal is preserving cosine similarity, it is necessary to normalize the orriginal features by mapping them to the unit hypersphere before learning the binary mapping functions. On the other hand, when the goal is to preserve Euclidean distance, the original feature data must be mapped to a higher dimension by including a bias term in binary mapping functions. Our experiments reveal very different results in the performance of the binary code methods when these constraints are enforced. We show that the state-of-the-art technique OK-means [16] and MDSH [24] most of the times, in first scenario, performs worse than Iterative Quantization (ITQ)[5], which is an older method. LSH [1] most of the time performs better than every other method in the second scenario for long binary codes.\nIt is not obvious how to enforce the bias term for methods that preserve cosine similarity. Inspired by [19], we propose a geometrical intuition on learning Iterative Quantization (ITQ)[5] augmented by a bias term. This binary embedding leverages correlation using the notion of predictability introduced by Rastegari et al. [19, 20]. A particular bit in a predictable binary code is (ideally) identical in all neighboring data samples. Rastegari et al. [19, 20] use predictability to represent nearest neighbor preservation via a max-margin formulation. However, they had supervision in the form of specification on similar samples which results in tractable optimization. We show that for unsupervised discovery of predictable binary codes the max-margin formulation is intractable. But, by employing a bias term in ITQ we can easily produce predictable codes. Further, we show that even more predictable binary codes can be obtained by random perturbations of the hyperplane parameters at each iteration of quantization. Our experimental evaluation on three datasets shows that augmenting ITQ with a bias term\n(Predictable Hashing) often outperforms LSH and state-of-the-art data-driven methods.\nThe principle contribution of this paper is methodological \u2013 a specification of appropriate methodology for comparing binary coding methods. When these methods are employed, the relative performance of coding algorithms is often very different from results reported in the literature. Additionally, we propose a variation of iterative quantization (ITQ), using predictability of the bits, which involves extending the ITQ algorithm with a bias term."}, {"heading": "2 Experimental Settings and Notations", "text": "In order to evaluate the accuracy of binary codes we measure precision and recall for the task of r-nearest neighbor retrieval. First we partition the data into two sets; train and test. On the training partition we learn the binary codes and on the testing partition we use that model to extract the binary codes. We take the actual nearest neighbors in the original feature space as ground truth. Then we use the binary codes to find the nearest neighbors in binary space using Hamming distance. Given a query sample, we retrieve the samples around the query in the Hamming space within radius r. For each r we compute the precision and recall. Therefore by varying r we construct the precision-recall curve."}, {"heading": "2.1 Datasets", "text": "We consider three datasets from the computer vision community for image retrieval tasks and object recognition. ImageNet20K [2] ImageNet includes 17000 categories of objects. We used the benchmark of ImageNET referred to as ISLVRC2010 which has 1000 categories; for each category we randomly selected 20 samples. In total we have 20K images. This setting is followed by [19]. We used BoW (with 1000 codewords of SIFT features), SPHoG, GIST and LBP as visual features; we concatenated them into a long feature vector and used PCA to reduce the dimensionality to 1000. 1MGist [7] This dataset contains 1M internet images and their GIST features; it has 960 dimensions. This dataset was created by Je\u0301gou et al. [7] and has been used for approximate nearest neighbor search in the vision community. SUN14K [25] This dataset has 700 categories of images. Unlike ImageNet, this dataset is for scene recognition. We used the portion of this dataset used for attribute based recognition by Patterson and Hays [17]. It has 14K images and we used the visual features extracted by Patterson and Hays [17] which have 19K dimensions. We randomly selected 1K dimensions."}, {"heading": "2.2 Methods", "text": "We compare different state-of-the-art binary embedding methods on the image retrieval task. The methods we evaluate are: Iterative Quantization (ITQ) [5], Orthogonal K-means(OK-means)[16], Spectral Hashing (SPH) [23], Multidimensional Spectral Hashing (MDSH) [24], Locality Sensitive Hashing (LSH) [4]; we compare with two variant of LSH \u2013 one with the bias term (LSHbias) and the other without (LSHnobias). We present ITQ augmented with a bias term as Predictable Hashing (PH). We used the online available software for ITQ, MDSH and OK-means provided by their authors."}, {"heading": "2.3 Notation", "text": "We denote the data matrix by X \u2208 RD\u00d7N where D is the dimensionality of the space and N is the number of data points. A data point is represented by xi which is the i\nth column of X. The output binary codes are represented by B \u2208 {1,\u22121}K\u00d7N where K is the number of bits and bi is the ith column of B."}, {"heading": "3 Preserving Cosine Similarity", "text": "Our goal here is to map points that have high cosine similarity in the original feature space to binary codes that have small Hamming distance. If we regard the binary codes as hash buckets, this is equivalent of bucketing or discretizing the orientation in the original feature space. One way to accomplish this is to use LSH, but force each random hyperplane to pass through the origin (We assume the data are mean centered, i.e. mean of the data is at the origin). In LSH, each data point is projected to a K dimensional subspace using K random projections. Each projection is a hyperplane in the original D dimensional space. We denote wk as the normal vector for the k\nth hyperplane. The values of the elements of wk are randomly drawn from a stable distribution. A datapoint xi in RD is binarized to 1 or \u22121 by a random hyperplane wk depending on which side of the hyperplane wk it lies in. This binarization is simply achieved by taking the sign of wTk xi. By using K random hyperplanes, we generate a K dimensional binary code for each data point, creating a K dimensional Hamming space.\nTo compare such a method to one that preserves Euclidean distance, we must make sure that the comparison is fair. This can be ensured by simply normalizing the data by mapping it to the surface of the unit hypersphere. In this case, Euclidean distance is inversely proportional to cosine similarity, \ufffdxi \u2212 xj\ufffd = 2(1\u2212 cos(\u03b8ij)) where \u03b8ij is the angle between xi and xj . Therefore, all methods that preserve Euclidean distance will preserve cosine similarity as well. Unitnorm normalization is a very popular normalization method for visual features. For the intensity based features it provides some robustness to illumination and for high dimensional histogram feature it captures the pattern of the histograms which somewhat ameliorates the curse of dimensionality.\nGong and Lazebnik [5] did not explicitly show that ITQ preserves cosine similarity. It is simple to see that what ITQ is optimizing for is the best rotation of the unit(binary) hypercube so that the nodes of the hypercube have minimum distance from data points minR,B \ufffdRX \u2212 B\ufffd where R is a rotation matrix . When the data are not normalized, there is a large amount of error caused by different magnitudes of data points compared to the locations of the nodes of the hypercube. But when the data is normalized to the hypersphere the only source of error is the angular difference from data points to the nodes of the hypercube. Therefore, ITQ will achieve its best performance when the data are normalized.\nIn SPH and MDSH the affinity between data points A(xi, xj) = exp(\u2212\ufffdxi \u2212 xj\ufffd2/2\u03c32) is more correlated with Euclidean distance but normalizing the data makes it more correlated with cosine similarity.\nFigure 1 shows the precision-recall curves for performing nearest neighbor retrieval on each dataset. In each experiment, we used a specific code length\nand in the ground truth we fixed the number of nearest neighbors. These are reported in the title of each plot. \u201dDball\u201d indicates the average number of nearest neighbors and \u201dnbits\u201d is the number of bits(code length). Figure 2 shows the effect of the number of bits on the accuracy of retrieval. We vary the number of bits (Code length) by 32, 64, 128, 256 and 512. For each code length we measure the average precision by varying the radius size.\nIn Fig 1 and Fig 2 we show the results of comparing all methods when the data are appropriately normalized. ITQ consistently performs the best. This is contrary to the results presented in [16] and [24] that claimed that OK-means and MDSH outperform ITQ. In the GIST and ImageNet datasets OK-means and ITQ exhibit comparable results. We examined the distribution of eigenvalues of the data in each dataset and observed in GIST and ImageNet the eigenvalues are more uniformly distributed than the SUN dataset. This indicates that the intrinsic dimensions of feature spaces of GIST and ImageNet (which is BoW) are less correlated than the feature space of SUN (which is a combination of BoW, GIST, SSIM and color histogram)."}, {"heading": "4 Preserving Euclidean Distance", "text": "Here we train a model so that points with low Euclidian distance in the original feature space have small Hamming distance in the Hamming space. In this scenario the performance of LSH is significantly better than suggested by results published in conjunction with recently developed data driven approaches. When the length of binary codes are sufficiently large, LSH outperforms these data\ndriven methods. This is mainly because these data driven methods need a mechanism avoid selecting hyperplanes that are redundant - that code the training data very similarly. They do this by enforcing that vectors of encoded bits be uncorrelated across hyperplanes. We will explain why this constraint on correlation is too strong, and limits performance of data-driven methods. Furthermore, we investigate different data distributions, and illustrate and reason about the cases in which LSH performs better. We propose a simple coding scheme based on the notion of predictability that allows ITQ to learn binary codes that model the correlation between the original features. We show that predictability allows the method to be data driven without the need to enforce orthogonality of the bits. Our solution outperforms LSH up to fairly large code lengths."}, {"heading": "4.1 In Defense of LSH", "text": "The power of LSH has been underestimated in many recent papers [5, 14, 24]. We assume that nearest neighbors in the original Euclidean space are measured by the \ufffd2-norm. According to Datar et al. [1], the chance of preserving nearest neighbors in the Hamming space by LSH will be higher when the random values of wk come from a normal distribution.\nIn LSH each random hyperplane can have a bias term. This bias term can shift the hyperplane away from the origin, but should not move the hyperplane out of the region that the data points lie in. The diameter of the region that contains the data points is defined by d which is the distance between the two farthest points and the radius of the region is r = d2 . If we assume that data points are mean centered, then the bias term for each random hyperplane is a real value chosen uniformly from the range [\u2212r, +r]. Inspecting the authors\u2019\ncodes in many binary hashing papers for image retrieval [5]1 [9]2 [14]3 [24]4, reveals that they do not include a bias term for random hyperplanes in LSH when comparing their methods with LSH for preserving Euclidean distance.\nOne may think that since the original feature space for images is usually very high dimensional and the bias term just adds one more dimension, that its impact should be negligible. We show that the impact of the bias term is considerable when the length of the binary code is large. Figure 3 (a) shows a comparison on the GIST dataset, which is commonly used in image retrieval. When we increase the number of bits, the performance of LSH with the bias term (LSHbias) significantly increases. LSHbias even outperforms state-of-theart data driven methods. Two questions arise immediately: Why do data driven methods perform worse than LSHbias? and Why, with short code lengths, does LSHbias not perform as well as with larger code lengths?\nTo answer these questions we investigate two well known data driven methods for producing binary codes \u2013 Spectral Hashing (SPH) and Iterative Quantization (ITQ). SPH constructs binary codes with uncorrelated bits that minimize the expected Hamming distance between datapoints, i.e. pairs of points that have small distances in the original feature space, should also have small Hamming distances in the binary code space. Their optimization leads to a mapping of data into the space of eigen functions. The binary codes are produced by thresholding that mapped data using orthogonal axes in the eigen space. ITQ searches for a rotation of the data (after reducing the dimensionality by PCA) which when theresholded with respect to orthogonal axes results in small quantization error. The orthogonality of the axes leads to uncorrelated bits in the binary codes. Although these two approaches (SPH and ITQ) optimize different objectives, they share the common hard constraint that forces the bits to be uncorrelated. This hard constraint actually degrades the power of these methods. Figure 3(b) shows the precision-recall curves for 256 bit binary codes of different methods and (c-e) shows the correlation between the bits in ITQ, MDSH and LSHbias respectively in 256 bit codes. The bits in LSHbias have more correlation than\n1 http://www.unc.edu/~yunchao/code/smallcode.zip 2 http://www.cse.ohio-state.edu/~kulis/bre/bre.tar.gz 3 https://subversion.assembla.com/svn/min-loss-hashing/trunk 4 http://www.cs.huji.ac.il/\u0153yweiss/export2.tar\nMDSH and ITQ, but still LSHbias performs better. This observation is contrary to the popular belief that bits in binary codes should be uncorrelated.\nSuppose a bit value for a point in the feature space is created by a hyperplane w which crosses the data points in RD. In order to generate a K-bit binary code for each sample, we need K hyperplanes. We stack all the normal vectors of the hyperplanes in a D \u00d7 K matrix W where the kth column of W is the normal vector for the kth hyperplane. If we want the bits to be uncorrelated then we must have BTB \u2248 I. The bits are generated by B = sign(WTX) therefore:\nBTB = sign(XTW )sign(WTX) \u2248 I (1)\nBy relaxing the binary values (ignoring the sign function), we haveXTWWTX \u2248 I. Let S = WWT . Now we can rewrite the equation as XTSX \u2248 I. This indicates that matrix S must be high rank. But since S is generated by the outer product ofW with itself, its rank cannot be more than min(D,K) (W is D\u00d7K). In most binary hashing methods we want the number of bits to be fewer than the original dimensionality of the feature space. Thus D > K. Therefore, the rank of S must be K. This means that the K hyperplanes have to be orthogonal. Furthermore, to obtain uncorrelated bits, all the hyperplanes must pass through the mean of the data points. This forces the hyperplanes to have almost equal portions of the data points on each side. Figure 4-(a) shows a case of distribution of data in which data points (shown in blue) are highly correlated. To create a 2-bit binary code for this data we use two lines (hyperplanes in R2). The red lines indicate the orthogonal directions of PCA on this data. By rotating these red lines we can produce all the possible orthogonal directions that cross the mean of the data (In this figure the data are mean centered). However, the best way of splitting these data by two lines (to produce binary codes that preserve the nearest neighbors of each point) is given by the green lines. The green lines are not orthogonal and they do not cross the mean of the data points. Moreover, the bits produced by the green lines are also highly correlated. Here it makes\nsense that the bits be correlated, because the data itself are highly correlated. In most real world situations there are correlations between data. Therefore, binary codes should indeed model these correlations. The translations of the hyperplanes are very important for modeling these correlations. The bias term in LSH is the key factor, because it allows the hyperplanes to move freely in space.\nOne way to measure linear correlation between data points is to look at the eigenvalues of the principle components of the data. If all the components have equal eigenvalues, the data are not linearly correlated. There may be nonlinear correlations between the data but capturing nonlinear correlations is not trivial, and, in fact, is an area of current research; one can use Kernel-PCA[21]. If there were no strong correlations between data, then the bias term is not needed. In such a situation, data driven methods with the constraint of uncorrelated bits would work perfectly.\nWe next investigate the second question; Why, with short code lengths, does LSHbias not perform as well as with large code lengths? Consider two data points binarized by LSH into K bits. If all K bits of these two instances are equal, then the probability that these two points are neighbors is 1\u22122\u2212K . This is simply the confidence of being neighbors given the K bit Hamming similarity of random projection binary codes. This confidence value increases exponentially with K. When K is very small, ITQ performs significantly better than other methods because it first reduces the dimensionality of data to K via PCA. We know that the first few components of PCA usually have similar eigenvalues. This means that when the dimensionality of data is drastically reduced, they will not be highly correlated in the reduced space. For example, consider a 3D space where the data points are uniformly distributed on a plane. When you project the points on the first two eigenvector , which is the plane that fits data the best, the projected points are no longer correlated in the 2D space. Therefore, it is safe to enforce the constraint of uncorrelated bits during code construction.\nNow the question is: how can we take correlation into account for learning the binary codes? In the next section we propose a method that uses the notion of predictability and employs a bias term in the hyperplanes for learning in ITQ. We do not claim that our method outperforms LSHbias for all large numbers of bits, but our method shows superior empirical performance using fairly large code length (256 and 512 bits)."}, {"heading": "4.2 Predictable Embedding: Enforcing bias term in ITQ", "text": "The concept of predictability in binary codes was introduced for attribute discovery [19] and dual-view hashing [20]. It is the ability to predict the bit value of an arbitrary bit in a binary code of a sample by looking at the same bit of the binary codes of the nearest neighbors of that sample. For example, if the kth bit of a predictable binary codes is 1 then the kth bit of predictable binary codes of the neighbors of that sample are also highly likely to be 1 (in other words, the bit value can be easily predicted as 1). Rastegari et al. [19, 20] proposed that a bit value produced by a hyperplane is predictable when the corresponding hyperplane has max-margin from data points. However, in both their approaches, they need labels for data to learn the max-margin hyperplanes. In [19], their goal was to produce binary codes that preserve the classification performance\ncompared to the original feature space, therefore they use the class labels of each sample. In [20], their goal was to learn a shared Hamming space between two modalities (e.g. textual and visual). They use the bit values in one modality as labels for samples in the other modality. For our purpose, however, unlike the general predictable binary code setting, we do not have label information for samples to learn max-margin hyperplanes. We formulate an optimization function based on a max-margin criteria that does not require label information, as follows:\nmin w,\u03be\n\ufffdw\ufffd22 + C \ufffd \u03bei\ns.t.\n\u2200i, sign(wTxi)(wTxi) > 1\u2212 \u03bei \u2200i, \u03bei > 0.\n(2)\nGiven that each bit in the space is generated by a hyperplane, we seek a hyperplane w that has max margin from data points X. To enforce the max-margin constraint in equation 2 we use sign(wTxi) as the label of the i\nth sample. We embedded the bias term into the xis by [xi; 1]. Equation 2 is combinatorial due to the sign function and so it is not practical to solve this optimization directly.\nPredictability involves finding a hyperplane that passes through a region of data points with large margin. ITQ similarly looks for gaps between the main axes (e.g. X and Y which are orthogonal to each other) and the data points. If we can find a mapping of data that has a gap between the mapped points and the main axes, a simple quantization algorithm (ITQ) would construct predictable hyperplanes. To achieve this, we lift all the data points into a space with one more dimension by representing them using homogeneous coordinates. This is nothing more than enforcing a bias term for hyperplanes. To learn these bias terms we simply apply ITQ to the lifted data. Next we present a geometrical interpretation.\nFor illustration purposes, suppose the data lies on a 2D plane; by adding one more dimension we simply lift up the plane on to Z = 1 in the X-Y -Z coordinate system. By rotating this plane with respect to the origin we obtain a configuration in which the gaps between the data points are aligned with the axes in the X-Y coordinate system. Once we achieve that, we project the data back to the X-Y plane. The translation is implicitly determined by rotation in the higher dimension.\nFigure 4 (b) illustrates the process of adding one more dimension, rotation and projection. As can be seen, the axes on the original planes (green axes) are centered at the mean of the data points (blue points) which is in the dense area of the points. Quantizing the data using these axes will assign different binary codes to the points around the center. By rotating the data on the plane we can never obtain a good quantization from the axes of the plane because the center point is an invariant of such rotations. Thus, the data around the center are always assigned different binary codes (i.e., not predictable) while they are highly clustered. By rotating the plane of lifted data around the origin of the unit sphere and projecting it back to the X-Y plane we obtain the green points which are well separated by the main axes (blue axes). Basically, by rotating in higher dimension we achieve an affine transformation of data in the original\nspace (In this figure X-Y ) that can squeeze or stretch the data to align gaps between the data with the main axes.\nFormally, we first reduce the dimensionality of the feature vectors to K by PCA and append 1 to X to lift the points into the space that is larger than the original one by 1 dimension. We denote the augmented and dimensionreduced vector by X\u0302 = [X;1T ] where 1 is a vector of ones. The optimization is minB,R \ufffdB \u2212 RX\u0302\ufffd2F s.t. RRT = I. This optimization is identical to the one in ITQ. We can solve it with same iterative procedure as ITQ. One might think the same strategy would have a similar effect on Orthogonal K-means but it does not. In OK-means, in contrast to ITQ, the optimization for finding the best rotation is in the original feature space, not in the PCA reduced space. In OK-means the space will be divided to K partitions. After finding a global rotation, each partition will be quantized into two parts using a k-means like procedure. Therefore, the bias term will be effective on one partition at a time which is equivalent to being applied to a single bit at each iteration. We have not observed any difference in performance by enforcing a bias term in OK-means; therefore, we do not include them in our results.\nFigure 5 shows the precision-recall curves for performing nearest neighbor retrieval on each dataset. These results shows the LSH with bias (LSHbias) and ITQ with bias (PH) are outperforming other methods most of the times. Again, this is contrary to results published in previous papers [16, 24] on these methods. It can be observed that OK-means gives better performance only for short binary codes in the GIST and ImageNet datasets, but as we increase the number of bits it performs worse than PH and LSHbias. As explained before, the feature space of those two datasets are less correlated compared to the SUN dataset.\nFigure 6 shows the effect of the number of bits on the accuracy of retrieval. We vary the number of bits (Code length) by 32, 64, 128, 256 and 512. For each code length we measure the average precision by varying the radius size.\nPredictability with p-stable perturbation Since the optimization in ITQ is solved by a block coordinate descent algorithm, it may get stuck in local minima. In order to escape from the local minima, we again use the notion of predictability. As mentioned earlier, the bits produced by a hyperplane are predictable when the hyperplane has max-margin from data points. Equivalently, we can say that small changes to the predictable hyperplane should not change the binary values of the bits. This is because the hyperplanes are located within the gaps of the data and small changes will not flip a point to the other side of a hyperplane.\nIf we apply small perturbations to the normal vector of a predictable hyperplanes, the binary codes should be unchanged. If they do change, the perturbations can allow the solution to escape from a local minima. Formally, we are looking for a set of hyperplanes W (a D\u00d7K matrix), whose columns are normal vectors of hyperplanes, that produce the same binary codes for samples even when their coordinates are perturbed. With the perturbation, we can rewrite\nour criteria as follow:\nmin B,R \ufffdB \u2212WT X\u0302\ufffd2F s.t.\nW = tR+ (1\u2212 t)E, RRT = I,\n(3)\nwhere E is a K \u00d7K matrix of random values from the standard normal distribution and t is a balancing parameter for the amount of perturbation. We fix t = 0.9 in all of our experiments. One can tune this parameter to obtain better performance. This optimization is the same as ITQ but we apply small perturbations to the estimated rotation matrix at each iteration. The reason that the random perturbation values in E should be drawn from the standard normal distribution is because we need this mapping to preserve the neighbors under the \ufffd2-norm. As discussed in [4], the parameters of a random projection should come from a p-stable distribution to preserve \ufffdp-norm neighbors in the original feature space. The standard normal distribution is a 2-stable distribution, therefore it preserves neighbors under the \ufffd2-norm.\nTo measure the improvement due to random perturbations we performed an experiment without perturbation and compare with our full model (see Figure 7)."}, {"heading": "5 Conclusion", "text": "We showed that the appropriate way of comparing different binary code methods depends on the metric that the binary mapping is designed to preserve. For preserving cosine similarity, the data should be mapped to the unit hypersphere. This allows for fair comparison between Euclidean distance preserving methods and cosine similarity preserving methods. We showed ITQ outperforms all other methods, in contrast to what has been reported in recent papers. On the other hand, if the goal is preserving Euclidean distance, capturing the correlation between data plays a crucial role. Applying LSH with a bias term can achieve the best performance with a large budget of bit codes. We showed that including the bias helps model the correlation between the data in original feature space. When ITQ is augmented with a bias term it achieves better performance by a large margin. We also presented a geometrical intuition for that based on predictable binary codes."}], "references": [{"title": "Locality-sensitive hashing scheme based on p-stable distributions", "author": ["Mayur Datar", "Nicole Immorlica", "Piotr Indyk", "Vahab S Mirrokni"], "venue": "In Proceedings of the twentieth annual symposium on Computational geometry,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Imagenet: A large-scale hierarchical image database", "author": ["Jia Deng", "Wei Dong", "Richard Socher", "Li-Jia Li", "Kai Li", "Li Fei-Fei"], "venue": "In Computer Vision and Pattern Recognition,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Optimized product quantization for approximate nearest neighbor search", "author": ["Tiezheng Ge", "Kaiming He", "Qifa Ke", "Jian Sun"], "venue": "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "Similarity search in high dimensions via hashing", "author": ["Aristides Gionis", "Piotr Indyk", "Rajeev Motwani"], "venue": "In Proceedings of the international conference on very large data bases,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1999}, {"title": "Iterative quantization: A procrustean approach to learning binary codes", "author": ["Yunchao Gong", "Svetlana Lazebnik"], "venue": "In Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "K-means hashing: An affinitypreserving quantization method for learning binary compact codes", "author": ["Kaiming He", "Fang Wen", "Jian Sun"], "venue": "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2013}, {"title": "Searching with quantization: approximate nearest neighbor search using short codes and distance estimators", "author": ["Herv\u00e9 J\u00e9gou", "Matthijs Douze", "Cordelia Schmid"], "venue": "Technical Report RR-7020,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Complementary projection hashing", "author": ["Zhongming Jin", "Yao Hu", "Yue Lin", "Debing Zhang", "Shiding Lin", "Deng Cai", "Xuelong Li"], "venue": "In The IEEE International Conference on Computer Vision (ICCV),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Learning to hash with binary reconstructive embeddings", "author": ["Brian Kulis", "Trevor Darrell"], "venue": "In The Neural Information Processing Systems,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2009}, {"title": "A general two-step approach to learning-based hashing", "author": ["Guosheng Lin", "Chunhua Shen", "David Suter", "Anton van den Hengel"], "venue": "In The IEEE International Conference on Computer Vision (ICCV),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2013}, {"title": "Compressed hashing", "author": ["Yue Lin", "Rong Jin", "Deng Cai", "Shuicheng Yan", "Xuelong Li"], "venue": "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}, {"title": "Supervised hashing with kernels", "author": ["W Liu", "J Wang", "R Ji", "YG Jiang", "SF Chang"], "venue": "Proceedings of Computer Vision and Pattern Recognition,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Hash bit selection: A unified solution for selection problems in hashing", "author": ["Xianglong Liu", "Junfeng He", "Bo Lang", "Shih-Fu Chang"], "venue": "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "Minimal Loss Hashing for Compact Binary Codes", "author": ["M. Norouzi", "D.J. Fleet"], "venue": "In ICML,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Fast search in hamming space with multi-index hashing", "author": ["Mohammad Norouzi", "Ali Punjani", "David J Fleet"], "venue": "In Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "Cartesian k-means", "author": ["Mohammd Norouzi", "David Fleet"], "venue": "In Computer Vision and Pattern Recognition", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2013}, {"title": "Sun attribute database: Discovering, annotating, and recognizing scene attributes", "author": ["Genevieve Patterson", "James Hays"], "venue": "In Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Scalable objectclass retrieval with approximate and top-k ranking", "author": ["Mohammad Rastegari", "Chen Fang", "Lorenzo Torresani"], "venue": "In IEEE International Conference on Computer Vision (ICCV),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "Attribute discovery via predictable discriminative binary codes", "author": ["Mohammad Rastegari", "Ali Farhadi", "David Forsyth"], "venue": "In European Conference on Computer Vision (ECCV),", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2012}, {"title": "Dual-view predictable hashing", "author": ["Mohammad Rastegari", "Jonghyun Choi", "Shobeir Fakhraei", "Hal Daume", "Larry Davis"], "venue": "In International Conference on Machine Learning (ICML),", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2013}, {"title": "Kernel principal component analysis. In Advances in kernel methods-support vector learning", "author": ["Bernhard Scholkopf", "Alexander Smola", "Klaus-Robert M\u00fcller"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1999}, {"title": "Inductive hashing on manifolds", "author": ["Fumin Shen", "Chunhua Shen", "Qinfeng Shi", "Anton van den Hengel", "Zhenmin Tang"], "venue": "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2013}, {"title": "Spectral Hashing", "author": ["Y. Weiss", "A. Torralba", "R. Fergus"], "venue": "In NIPS,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2008}, {"title": "Multidimensional spectral hashing", "author": ["Yair Weiss", "Rob Fergus", "Antonio Torralba"], "venue": "In Proceedings of the 12th European conference on Computer Vision (ECCV),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Sun database: Large-scale scene recognition from abbey to zoo", "author": ["Jianxiong Xiao", "James Hays", "Krista A Ehinger", "Aude Oliva", "Antonio Torralba"], "venue": "In Computer vision and pattern recognition (CVPR),", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2010}], "referenceMentions": [{"referenceID": 14, "context": "[15] proposed a multi-index hashing method, and Rastegari et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18] introduced a branch and bound approach to perform exact k-nearest neighbors search in sub-linear time with long binary codes.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "[1] introduced locality sensitivity hashing (LSH) and provide theoretical guarantees on retrieval in sublinear time.", "startOffset": 0, "endOffset": 3}, {"referenceID": 22, "context": "[23] introduced Spectral Hashing (SPH) and [24] Multidimensional Spectral Hashing (MDSH); they formulate the problem as an optimization that reduces to an eigenvalue problem.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[23] introduced Spectral Hashing (SPH) and [24] Multidimensional Spectral Hashing (MDSH); they formulate the problem as an optimization that reduces to an eigenvalue problem.", "startOffset": 43, "endOffset": 47}, {"referenceID": 4, "context": "Furthermore, Gong and Lazebnik [5](ITQ) and Norouzi and Fleet [16] (CK-means) proposed methods to minimize the quantization error of mapping the data to a binary hypercube via rotation.", "startOffset": 31, "endOffset": 34}, {"referenceID": 15, "context": "Furthermore, Gong and Lazebnik [5](ITQ) and Norouzi and Fleet [16] (CK-means) proposed methods to minimize the quantization error of mapping the data to a binary hypercube via rotation.", "startOffset": 62, "endOffset": 66}, {"referenceID": 6, "context": "Product Quantization [7] is an instance of Cartesian Kmeans[16] that does not optimize for rotation and Orthogonal K-means is the binary version of CK-means that number of subspaces are equal to the number of bits.", "startOffset": 21, "endOffset": 24}, {"referenceID": 15, "context": "Product Quantization [7] is an instance of Cartesian Kmeans[16] that does not optimize for rotation and Orthogonal K-means is the binary version of CK-means that number of subspaces are equal to the number of bits.", "startOffset": 59, "endOffset": 63}, {"referenceID": 11, "context": "There is another class of binary code learning methods that are supervised [12, 14, 19].", "startOffset": 75, "endOffset": 87}, {"referenceID": 13, "context": "There is another class of binary code learning methods that are supervised [12, 14, 19].", "startOffset": 75, "endOffset": 87}, {"referenceID": 18, "context": "There is another class of binary code learning methods that are supervised [12, 14, 19].", "startOffset": 75, "endOffset": 87}, {"referenceID": 13, "context": "We experimentally observed that given a good supervision, MLH[14] performs similar to ITQ.", "startOffset": 61, "endOffset": 65}, {"referenceID": 2, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 5, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 7, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 9, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 10, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 12, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 15, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 21, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 23, "context": "Recent papers [3, 6, 8, 10, 11, 13, 16, 22, 24] showed comparisons without taking these factors into account.", "startOffset": 14, "endOffset": 47}, {"referenceID": 4, "context": "In particular, some methods preserve cosine similarity [5], while others preserve Euclidean distance [8, 24].", "startOffset": 55, "endOffset": 58}, {"referenceID": 7, "context": "In particular, some methods preserve cosine similarity [5], while others preserve Euclidean distance [8, 24].", "startOffset": 101, "endOffset": 108}, {"referenceID": 23, "context": "In particular, some methods preserve cosine similarity [5], while others preserve Euclidean distance [8, 24].", "startOffset": 101, "endOffset": 108}, {"referenceID": 15, "context": "We show that the state-of-the-art technique OK-means [16] and MDSH [24] most of the times, in first scenario, performs worse than Iterative Quantization (ITQ)[5], which is an older method.", "startOffset": 53, "endOffset": 57}, {"referenceID": 23, "context": "We show that the state-of-the-art technique OK-means [16] and MDSH [24] most of the times, in first scenario, performs worse than Iterative Quantization (ITQ)[5], which is an older method.", "startOffset": 67, "endOffset": 71}, {"referenceID": 4, "context": "We show that the state-of-the-art technique OK-means [16] and MDSH [24] most of the times, in first scenario, performs worse than Iterative Quantization (ITQ)[5], which is an older method.", "startOffset": 158, "endOffset": 161}, {"referenceID": 0, "context": "LSH [1] most of the time performs better than every other method in the second scenario for long binary codes.", "startOffset": 4, "endOffset": 7}, {"referenceID": 18, "context": "Inspired by [19], we propose a geometrical intuition on learning Iterative Quantization (ITQ)[5] augmented by a bias term.", "startOffset": 12, "endOffset": 16}, {"referenceID": 4, "context": "Inspired by [19], we propose a geometrical intuition on learning Iterative Quantization (ITQ)[5] augmented by a bias term.", "startOffset": 93, "endOffset": 96}, {"referenceID": 18, "context": "[19, 20].", "startOffset": 0, "endOffset": 8}, {"referenceID": 19, "context": "[19, 20].", "startOffset": 0, "endOffset": 8}, {"referenceID": 18, "context": "[19, 20] use predictability to represent nearest neighbor preservation via a max-margin formulation.", "startOffset": 0, "endOffset": 8}, {"referenceID": 19, "context": "[19, 20] use predictability to represent nearest neighbor preservation via a max-margin formulation.", "startOffset": 0, "endOffset": 8}, {"referenceID": 1, "context": "ImageNet20K [2] ImageNet includes 17000 categories of objects.", "startOffset": 12, "endOffset": 15}, {"referenceID": 18, "context": "This setting is followed by [19].", "startOffset": 28, "endOffset": 32}, {"referenceID": 6, "context": "1MGist [7] This dataset contains 1M internet images and their GIST features; it has 960 dimensions.", "startOffset": 7, "endOffset": 10}, {"referenceID": 6, "context": "[7] and has been used for approximate nearest neighbor search in the vision community.", "startOffset": 0, "endOffset": 3}, {"referenceID": 24, "context": "SUN14K [25] This dataset has 700 categories of images.", "startOffset": 7, "endOffset": 11}, {"referenceID": 16, "context": "We used the portion of this dataset used for attribute based recognition by Patterson and Hays [17].", "startOffset": 95, "endOffset": 99}, {"referenceID": 16, "context": "It has 14K images and we used the visual features extracted by Patterson and Hays [17] which have 19K dimensions.", "startOffset": 82, "endOffset": 86}, {"referenceID": 4, "context": "The methods we evaluate are: Iterative Quantization (ITQ) [5], Orthogonal K-means(OK-means)[16], Spectral Hashing (SPH) [23], Multidimensional Spectral Hashing (MDSH) [24], Locality Sensitive Hashing (LSH) [4]; we compare with two variant of LSH \u2013 one with the bias term (LSHbias) and the other without (LSHnobias).", "startOffset": 58, "endOffset": 61}, {"referenceID": 15, "context": "The methods we evaluate are: Iterative Quantization (ITQ) [5], Orthogonal K-means(OK-means)[16], Spectral Hashing (SPH) [23], Multidimensional Spectral Hashing (MDSH) [24], Locality Sensitive Hashing (LSH) [4]; we compare with two variant of LSH \u2013 one with the bias term (LSHbias) and the other without (LSHnobias).", "startOffset": 91, "endOffset": 95}, {"referenceID": 22, "context": "The methods we evaluate are: Iterative Quantization (ITQ) [5], Orthogonal K-means(OK-means)[16], Spectral Hashing (SPH) [23], Multidimensional Spectral Hashing (MDSH) [24], Locality Sensitive Hashing (LSH) [4]; we compare with two variant of LSH \u2013 one with the bias term (LSHbias) and the other without (LSHnobias).", "startOffset": 120, "endOffset": 124}, {"referenceID": 23, "context": "The methods we evaluate are: Iterative Quantization (ITQ) [5], Orthogonal K-means(OK-means)[16], Spectral Hashing (SPH) [23], Multidimensional Spectral Hashing (MDSH) [24], Locality Sensitive Hashing (LSH) [4]; we compare with two variant of LSH \u2013 one with the bias term (LSHbias) and the other without (LSHnobias).", "startOffset": 167, "endOffset": 171}, {"referenceID": 3, "context": "The methods we evaluate are: Iterative Quantization (ITQ) [5], Orthogonal K-means(OK-means)[16], Spectral Hashing (SPH) [23], Multidimensional Spectral Hashing (MDSH) [24], Locality Sensitive Hashing (LSH) [4]; we compare with two variant of LSH \u2013 one with the bias term (LSHbias) and the other without (LSHnobias).", "startOffset": 206, "endOffset": 209}, {"referenceID": 4, "context": "Gong and Lazebnik [5] did not explicitly show that ITQ preserves cosine similarity.", "startOffset": 18, "endOffset": 21}, {"referenceID": 15, "context": "This is contrary to the results presented in [16] and [24] that claimed that OK-means and MDSH outperform ITQ.", "startOffset": 45, "endOffset": 49}, {"referenceID": 23, "context": "This is contrary to the results presented in [16] and [24] that claimed that OK-means and MDSH outperform ITQ.", "startOffset": 54, "endOffset": 58}, {"referenceID": 4, "context": "The power of LSH has been underestimated in many recent papers [5, 14, 24].", "startOffset": 63, "endOffset": 74}, {"referenceID": 13, "context": "The power of LSH has been underestimated in many recent papers [5, 14, 24].", "startOffset": 63, "endOffset": 74}, {"referenceID": 23, "context": "The power of LSH has been underestimated in many recent papers [5, 14, 24].", "startOffset": 63, "endOffset": 74}, {"referenceID": 0, "context": "[1], the chance of preserving nearest neighbors in the Hamming space by LSH will be higher when the random values of wk come from a normal distribution.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "codes in many binary hashing papers for image retrieval [5] [9] [14] [24], reveals that they do not include a bias term for random hyperplanes in LSH when comparing their methods with LSH for preserving Euclidean distance.", "startOffset": 56, "endOffset": 59}, {"referenceID": 8, "context": "codes in many binary hashing papers for image retrieval [5] [9] [14] [24], reveals that they do not include a bias term for random hyperplanes in LSH when comparing their methods with LSH for preserving Euclidean distance.", "startOffset": 60, "endOffset": 63}, {"referenceID": 13, "context": "codes in many binary hashing papers for image retrieval [5] [9] [14] [24], reveals that they do not include a bias term for random hyperplanes in LSH when comparing their methods with LSH for preserving Euclidean distance.", "startOffset": 64, "endOffset": 68}, {"referenceID": 23, "context": "codes in many binary hashing papers for image retrieval [5] [9] [14] [24], reveals that they do not include a bias term for random hyperplanes in LSH when comparing their methods with LSH for preserving Euclidean distance.", "startOffset": 69, "endOffset": 73}, {"referenceID": 20, "context": "There may be nonlinear correlations between the data but capturing nonlinear correlations is not trivial, and, in fact, is an area of current research; one can use Kernel-PCA[21].", "startOffset": 174, "endOffset": 178}, {"referenceID": 18, "context": "The concept of predictability in binary codes was introduced for attribute discovery [19] and dual-view hashing [20].", "startOffset": 85, "endOffset": 89}, {"referenceID": 19, "context": "The concept of predictability in binary codes was introduced for attribute discovery [19] and dual-view hashing [20].", "startOffset": 112, "endOffset": 116}, {"referenceID": 18, "context": "[19, 20] proposed that a bit value produced by a hyperplane is predictable when the corresponding hyperplane has max-margin from data points.", "startOffset": 0, "endOffset": 8}, {"referenceID": 19, "context": "[19, 20] proposed that a bit value produced by a hyperplane is predictable when the corresponding hyperplane has max-margin from data points.", "startOffset": 0, "endOffset": 8}, {"referenceID": 18, "context": "In [19], their goal was to produce binary codes that preserve the classification performance", "startOffset": 3, "endOffset": 7}, {"referenceID": 19, "context": "In [20], their goal was to learn a shared Hamming space between two modalities (e.", "startOffset": 3, "endOffset": 7}, {"referenceID": 15, "context": "Again, this is contrary to results published in previous papers [16, 24] on these methods.", "startOffset": 64, "endOffset": 72}, {"referenceID": 23, "context": "Again, this is contrary to results published in previous papers [16, 24] on these methods.", "startOffset": 64, "endOffset": 72}, {"referenceID": 3, "context": "As discussed in [4], the parameters of a random projection should come from a p-stable distribution to preserve \ufffdp-norm neighbors in the original feature space.", "startOffset": 16, "endOffset": 19}], "year": 0, "abstractText": "We discuss methodological issues related to the evaluation of unsupervised binary code construction methods for nearest neighbor search. These issues have been widely ignored in literature. These coding methods attempt to preserve either Euclidean distance or angular (cosine) distance in the binary embedding space. We explain why when comparing a method whose goal is preserving cosine similarity to one designed for preserving Euclidean distance, the original features should be normalized by mapping them to the unit hypersphere before learning the binary mapping functions. To compare a method whose goal is to preserves Euclidean distance to one that preserves cosine similarity, the original feature data must be mapped to a higher dimension by including a bias term in binary mapping functions. These conditions ensure the fair comparison between different binary code methods for the task of nearest neighbor search. Our experiments show under these conditions the very simple methods (e.g. LSH and ITQ) often outperform recent state-of-the-art methods (e.g. MDSH and OK-means).", "creator": "cairo 1.10.2 (http://cairographics.org)"}}}