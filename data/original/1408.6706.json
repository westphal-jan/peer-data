{"id": "1408.6706", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Aug-2014", "title": "Equilibrium States in Numerical Argumentation Networks", "abstract": "Given an argumentation network with initial values to the arguments, we look for algorithms which can yield extensions compatible with such initial values. We find that the best way of tackling this problem is to offer an iteration formula that takes the initial values and the attack relation and iterates a sequence of intermediate values that eventually converges leading to an extension. The properties surrounding the application of the iteration formula and its connection with other numerical and non-numerical techniques proposed by others are thoroughly investigated in this paper.", "histories": [["v1", "Thu, 28 Aug 2014 12:56:17 GMT  (160kb,D)", "https://arxiv.org/abs/1408.6706v1", null], ["v2", "Wed, 18 Mar 2015 18:09:21 GMT  (126kb,D)", "http://arxiv.org/abs/1408.6706v2", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["d gabbay", "o rodrigues"], "accepted": false, "id": "1408.6706"}, "pdf": {"name": "1408.6706.pdf", "metadata": {"source": "CRF", "title": "Equilibrium States in Numerical Argumentation Networks", "authors": ["D. Gabbay"], "emails": ["dov.gabbay@kcl.ac.uk", "odinaldo.rodrigues@kcl.ac.uk"], "sections": [{"heading": "1 Orientation and Background", "text": ""}, {"heading": "1.1 Orientation", "text": "A finite system \u3008S,R\u3009, with R a binary relation on S, can be viewed in many different ways; among them are\n1. As an abstract argumentation framework [10], and\n2. As a generator of equations [13, 14]\nar X\niv :1\n40 8.\n67 06\nv2 [\nWhen viewed as an abstract argumentation framework, the basic concepts studied are those of extensions (being certain subsets of S) and different semantics (being sets of extensions). When studied as generators of equations, one can generate equations in such a way that the solutions f to the equations correspond to (complete) extensions and sets of such solutions correspond to semantics.\nThis paper offers an iteration schema for finding specific solutions to the equations responding to initial requirements and shows what these solutions correspond to in the abstract argumentation sense.\nWe now explain the role iteration formulas play in general in the equational context.\nWhen we have a system of equations designed to model an application area1 we face two problems: 1) find any solution to the system of equations, which will have a meaning in the application area giving rise to the equations; 2) given boundary conditions and/or other requirements not necessarily mathematical which are meaningful in the application area,2 we would like to find a solution to the system of equations that is compatible/respects the initial conditions/requirements.\nThese two problems are distinct. The first one of finding any solution is a numerical analysis problem. There are various iteration methods in numerical analysis to find solutions, of which one of the most known is Newton\u2019s method.3 The second problem is totally different. It calls for an understanding of the requirements coming from the application area and possibly the design of a specialised iteration formula which respects the type of requirements involved.\nThis paper provides the Gabbay-Rodrigues Iteration Schema, for the case of the equational approach to argumentation, seeking solutions (which we shall see will correspond to complete extensions) respecting as much as possible initial demands and restrictions of what arguments are in or out of the extension. We compare what our iteration schema does with Caminada and Pigozzi\u2019s downadmissible and up-complete constructions [7]. Because we are dealing with iteration formulas (involving limits) and we are comparing with set theoretical operations (as in Caminada and Pigozzi\u2019s paper) we have to be detailed and precise and despite it being conceptually clear and simple, the proofs turn out to be mathematically involved, and require some patience from our readers. However, once we establish the properties of our iteration schema, its use and application are straightforward and computationally simple, especially in the context of such tools as MATHEMATICA and others like it. The reader may wish to just glance at the technical proofs and concentrate on the examples and\n1For example, equations of fluid flow in hydrodynamics or equations of particle motion in mechanics, or equations modelling argumentation networks according to the equational approach (to be explained later), or equations modelling a biological system of predator-prey ecology, or some polynomial equation arising in macroeconomics.\n2For example, initial conditions in the case of particle mechanics, or initial size of population in the ecology, or arguments that we would like to be accepted.\n3This method starts with an initial guess of a possible solution and uses various iteration formulae hoping that it will converge to a solution (for an introduction on numerical analysis see [21]).\ndiscussions. Note the iteration schema idea is very general and applies to other systems of equations possibly using other iteration formulas.\nThe actual technical development of the paper will start in Section 2. In Appendix A we emphasise the distinction between the above two problems with two detailed examples, the first modelling the dynamics of predator-prey interactions and the second about merging/voting in argumentation networks. We shall see that Newton\u2019s method does not work in these scenarios and that there is the need for a new type of iteration schema. Thus this paper is not just incremental to the equational approach but constitutes a serious and necessary conceptual extension."}, {"heading": "1.2 Background", "text": "An abstract argumentation framework is a formalism proposed by Dung [10] and defined in terms of a tuple \u3008S,R\u3009, where S is a non-empty set of arguments and R \u2286 S\u00d7S is a binary attack relation. We will refer to an abstract argumentation framework \u3008S,R\u3009 simply as an argumentation network. If (X,Y ) \u2208 R, we say that the argument X attacks the argument Y . \u3008S,R\u3009 can be seen as a directed graph (see Figure 1). As informally introduced in Section 1, Att(X) will be used to denote the set {Y \u2208 S | (Y,X) \u2208 R}, i.e., the set of arguments attacking the argument X. Following graph theory convention, if X has no attackers (i.e., Att(X) = \u2205), we say that X is a source node in \u3008S,R\u3009. Given a set E \u2286 S, we write E \u2192 X as a shorthand for \u2203Y \u2208 E, such that (Y,X) \u2208 R. Furthermore, following [4], we use E+ to denote the set {Y \u2208 S | E \u2192 Y }.\nGiven an argumentation network, one usually wants to reason about the status of its arguments, i.e., whether an argument persists or is defeated by other arguments. It should be clear that arguments that have no attacks on them always persist. However, an attack from X to Y may not in itself be sufficient to defeat Y , because X may be defeated by some argument that attacks it, and thus one needs an evaluation process to determine the status of all arguments systematically. In Dung\u2019s original formulation, this was done through an acceptability semantics defining conditions for the acceptability of an argument. The semantics can be defined in terms of extensions \u2014 subsets of S with special properties. These subsets are based on two fundamental notions which are explained next.\nA set E \u2286 S is said to be conflict-free if for all elements X,Y \u2208 E, we have that (X,Y ) 6\u2208 R. Intuitively, arguments of a conflict-free set do not attack each other. However, this does not necessarily mean that all arguments in the set are properly supported. Well supported sets satisfy special admissibility criteria. We say that an argument X \u2208 S is acceptable with respect to E \u2286 S, if for all Y \u2208 S, such that (Y,X) \u2208 R, there is an element Z \u2208 E, such that (Z, Y ) \u2208 R. A set E \u2286 S is admissible if it is conflict-free and all of its elements are acceptable with respect to itself. An admissible set E is a complete extension if and only if E contains all arguments which are acceptable with respect to itself. E is called a preferred extension of S, if and only if E is maximal with respect to set inclusion amongst all complete extensions of S. Similarly, E is called a stable extension of S if and only if E is conflict-free and for every X \u2208 S\\E, there is an element Y \u2208 E, such that (Y,X) \u2208 R.\nNow consider the argumentation networks (L) and (R) depicted in Figure 2. According to the semantics given above, the network (L) has three extensions E0 = \u2205, E1 = {X} and E2 = {Y }. Both E1 and E2 are preferred and stable extensions. The network (R) only has only one extension, which is empty, and hence this is also its only preferred extension. This extension is however not stable.\nBesides Dung\u2019s acceptability semantics, it is also possible to give meaning to these networks through Caminada\u2019s labelling semantics [6, 5] and through Gabbay\u2019s equational approach [13, 14]. These are explained next.\nThe labelling semantics. The labelling semantics uses labelling functions \u03bb : S \u2212\u2192 {in,out,und} satisfying certain conditions tailored so as to obtain a complete correspondence with Dung\u2019s semantics.\nThe labelling of an argument in disagreement with Dung\u2019s semantics is said to be \u201cillegal\u201d. This is explained further as follows.\nDefinition 1.1 (Illegal labelling of an argument [7]) Let \u3008S,R\u3009 be an argumentation network and \u03bb a labelling function for S.\n1. An argument X \u2208 S is illegally labelled in by \u03bb if \u03bb(X) = in and there exists Y \u2208 Att(X) such that \u03bb(Y ) 6= out.\n2. An argument X \u2208 S is illegally labelled out by \u03bb if \u03bb(X) = out and there is no Y \u2208 Att(X) such that \u03bb(Y ) = in.\n3. An argument X \u2208 S is illegally labelled und by \u03bb if \u03bb(X) = und and either for all Y \u2208 Att(X), \u03bb(Y ) = out or there exists Y \u2208 Att(X), such that \u03bb(Y ) = in.\nA legal (complete) labelling is a labelling in which no argument is illegally labelled.\nIt is possible to have more than one legal labelling function for the same argumentation network. Each labelling function will correspond to an extension in Dung\u2019s semantics. For example, for network (L), we have the three functions \u03bb1, \u03bb2 and \u03bb0 below.\n\u03bb1 \u21d4 E1 = {X} \u03bb2 \u21d4 E2 = {Y } \u03bb0 \u21d4 E0 = \u2205 \u03bb1(X) = in \u03bb2(X) = out \u03bb0(X) = und \u03bb1(Y ) = out \u03bb2(Y ) = in \u03bb0(Y ) = und\nFor the network (R), we have only the function \u03bb such that \u03bb(X) = \u03bb(Y ) = \u03bb(Z) = und. This gives the empty extension.\nThe equational approach. The equational approach views an argumentation network \u3008S,R\u3009 as a mathematical graph generating equations for functions in the unit interval U = [0, 1]. Any solution f to these equations conceptually corresponds to an extension. Of course, the end result depends on how the equations are generated and we can get different solutions for different equations. Once the equations are fixed, the totality of the solutions to the system of equations is viewed as the totality of extensions via an appropriate mapping. One equation schema we can possibly use for generating equations is the Eqmax below, where V (X) is the value of a node X \u2208 S:\n(Eqmax) V (X) = 1\u2212maxYi\u2208Att(X){V (Yi)}\nAnother possibility is Eqinv: (Eqinv) V (X) = \u220f Yi\u2208Att(X)(1\u2212 V (Yi))\nIt is easy to see that according to Eqmax the value of any source argument will be 1 (since they have no attackers) and the value of any argument with an attacker with value 1 will be 0. The situation is more complex with nodes participating in cycles. Consider the network (L) again, with equations\nV (X) = 1\u2212 V (Y ) V (Y ) = 1\u2212 V (X)\nIf values are taken from the unit interval, this system of equations will accept any solution V such that V (X) + V (Y ) = 1. We can divide these solutions between three classes: V 1(X) = 1, V 1(Y ) = 0; V 2(X) = 0, V 2(Y ) = 1 and 0 < V 0(X) < 1, 0 < V 0(Y ) < 1 with V 0(X) + V 0(Y ) = 1. These again correspond to the three extensions E1, E2 and E0 given before.\nIn fact, Gabbay has shown that in the case of Eqmax the totality of solutions to the system of equations corresponds to the totality of extensions in Dung\u2019s sense [14]. The correspondence is best explained in terms of the labelling semantics, using the following correspondence:\nV (X) = 1 :: \u03bb(X) = in V (X) = 0 :: \u03bb(X) = out 0 < V (X) < 1 :: \u03bb(X) = und\nThe advantage of the equational approach is that it allows us to think of an argumentation network as a numeric system in which nodes are given certain values depending on specific rules governing their interaction with their neighbours. A rule may for instance require the value of a node to be 0 if the value of any attacking node is 1. Another rule may force the value of a node to be 1 if it has no attacking nodes. The schema Eqmax and Eqinv embed these rules, and they agree with Dung\u2019s semantics. A solution to the system of equations is any combination of values of nodes satisfying the equations. Of course, since the node values are no longer discrete we have more freedom to design rules which are appropriate for a given application. Part of the objective of this paper is to explore the nature of these rules.\nWe start by generalising some concepts a bit further. Consider the network in Figure 3 in which Att(X) = {Y1, Y2, . . . , Yk}. To agree with Dung\u2019s semantics, if the value of any attacker of X is 1, we want the value of X to be 0. If all of the attackers of X have value 0, we want the value of X to be 1. For any other combination of values of the attackers we want the value of X to be anything other than 0 or 1. So within the traditional semantics but taking the extended set of values of the unit interval, we can think of a single attack by a node with value v as the order-reversing operation which returns the value 1\u2212 v. This is a kind of negation.4 Since a node can have multiple attacks, we also need an operation to combine the values of the attackers. We can think of this as a type of conjunction, which numerically can be obtained through several operations. For instance, in fuzzy logic, the standard semantics of (weak) conjunction is given by the operation min.\n4If we make und equals 1\n2 , then an attack by a single undecided node will have value 1 2 .\nTherefore, the value of a node X can be defined as\nV (X) = min Y \u2208Att(X)\n{1\u2212 V (Y )}\nwhich is equivalent to\nV (X) = 1\u2212 max Y \u2208Att(X) {V (Y )}\nobtained by our now familiar schema Eqmax. Note that the conjunction operation in the schema Eqinv is product. The operations min and product are two examples of t-norms. They are two instances of functions that are particularly suitable for argumentation semantics. The following definition elaborates on this further.\nDefinition 1.2 A function g with domain being the family of all finite sequences of elements from U and range U is argumentation-friendly if g satisfies the following conditions.\n(T1) g(\u2205) = 1\n(T2) g(1; \u2206) = g(\u2206)5\n(T3) g(\u3008x1, . . . , x, . . . , y, . . . , xn\u3009) = g(\u3008x1, . . . , y, . . . , x, . . . , xn\u3009)\n(T4) g(\u2206) = 0 if and only if 0 \u2208 \u2206\n(T5) g(\u2206) = 1 if and only if x = 1 for every x \u2208 \u2206\n(T6) g is continuous as a multi-variable function6\nExample 1.1 Below are some examples of argumentation-friendly functions: 1. g(\u2206) = {\n1, if \u2206 = \u2205 min{xi}, if \u2206 = \u3008x1, . . . , xn\u3009\n2. g(\u2206) = {\n1, if \u2206 = \u2205 \u03a0n1 (1\u2212 xi), if \u2206 = \u3008x1, . . . , xn\u3009\n3. g\u03bb(\u2206) = (1\u2212\u03bb) min{ 12 , g(\u2206)}+\u03bbmax{ 1 2 , g(\u2206)}, for any g satisfying (T1)\u2013\n(T6).\nLater on, we will see that argumentation-friendly functions will be used both to calculate aggregation of attacks as well as for combining the value of attacks with initial values. However, as we mentioned attack is a type of negation and hence when operating on the attack of a node with value v, we will consider the complement of v to 1, i.e., (1\u2212 v).\nNotice that t-norms satisfy conditions (T1)\u2013(T4) above. 5The values of g for any sequence containing the value 1 is the same as the value of g for the subsequence without the 1. 6In fact, this condition is only needed to guarantee the existence of solutions to the equations.\nDefinition 1.3 For any assignment of values v : S 7\u2212\u2192 U define the sets in(v) = {X \u2208 dom v | v(X) = 1} and out(v) = {X \u2208 dom v | v(X) = 0}.\nTheorem 1.1 Let N = \u3008S,R\u3009 be a network, g an argumentation-friendly function, and T a system of equations written for N , where for each node X, V (X) = gY \u2208Att(X)({1 \u2212 V (Y )}). Take any solution V to T , it follows that in(V ) is a complete extension. Proof. Suppose that in(V ) is not conflict-free. Then there are X,Y \u2208 in(V ), such that (X,Y ) \u2208 R. Since Y \u2208 in(V ), then V (Y ) = 1 = gW\u2208Att(Y )({1 \u2212 V (W )}). But X \u2208 Att(Y ) and X \u2208 in(V ), and hence V (X) = 1. It then follows by (T4) that g(\u3008. . . , 0, . . .\u3009) = 0 and hence 1 6= 0, a contradiction.\nNow suppose that X \u2208 in(V ). We show that for all Y \u2208 Att(X) there exists Z \u2208 in(V ), such that (Z, Y ) \u2208 R. If V (X) = 1, then gY \u2208Att(X)({1\u2212V (Y )}) = 1 and then by (T5) it follows that 1 \u2212 V (Y ) = 1, for all Y \u2208 Att(X) and hence V (Y ) = 0 for all Y \u2208 Att(X). Take any such Y . Since V (Y ) = 0, we have by (T4) that for some W \u2208 Att(Y ), V (W ) = 1. It then follows that W \u2208 in(V ).\nTheorem 1.2 Let N = \u3008S,R\u3009 be a network, g an argumentation-friendly function, and T a system of equations written for N , where for each node X, V (X) = gY \u2208Att(X){1 \u2212 V (Y )}. Then for every preferred extension EN of N , there exists a solution V to T such that\n(C1) If X \u2208 EN , then V (X) = 1\n(C2) If EN \u2192 X, then V (X) = 0\n(C3) If X 6\u2208 EN and EN 6\u2192 X, then 0 < V (X) < 1\nProof. Let us start by partitioning the set S using EN into three sets \u22061 = EN , \u22060 = {X \u2208 S | EN \u2192 X}, and \u2206u = S\\(\u22060 \u222a\u22061). Note that the elements of \u2206u are the undecided elements in S with respect to EN . Each element of \u2206u is not attacked by any element of \u22061 and its attackers cannot all come from \u22060, i.e., at least one attacker comes from \u2206u itself. Consider the argumentation network \u3008\u2206u, R \u2206u\u3009. Write a system of equations Tu using g for \u3008\u2206u, R \u2206u\u3009. For each X \u2208 \u2206u, the equation is\nVu(X) = gY \u2208\u2206u s.t. (Y,X)\u2208R \u2206u{1\u2212 Vu(Y )}\nBy Brouwer\u2019s theorem, the above equations have a solution Vu.7 To be clear Vu is defined on \u2206u, giving values Vu(X), such that for every X \u2208 \u2206u, Vu(X) = gY \u2208\u2206u s.t. (Y,X)\u2208R \u2206u{1\u2212 Vu(Y )}\nWe are seeking however a solution V defined for all of S = \u22060 \u222a\u22061 \u222a\u2206u, which satisfies the system of equations T for \u3008S,R\u3009:\nV (X) = gY \u2208Att(X){1\u2212 V (Y )} 7The Euclidean version of the theorem states that if g is a real-valued function, defined and continuous on a bounded closed interval I of the real line where g(x) \u2208 I, for all x \u2208 I, then g has a fixed-point. In our case, there are n = |S| variables in the network \u3008S,R\u3009, which we can associate with the vector \u2212\u2192 X . We can then see each equation as \u2212\u2192 X = \u2212\u2192g ( \u2212\u2192 X ), where \u2212\u2192g is a continuous function on the n-dimensional space [0, 1]n (see Theorem 1.2 in [21]).\nFurthermore, we want V to be such that V (X) = 1 for X \u2208 \u22061, V (X) = 0, for X \u2208 \u22060 and V (X) \u2208 (0, 1) for X \u2208 \u2206u. We now define such a solution V . Let\nV (X) = 1, for all X \u2208 \u22061 V (X) = 0, for all X \u2208 \u22060 V (X) = Vu(X), for all X \u2208 \u2206u\nWe have to show now that V indeed solves the system of equations T for \u3008S,R\u3009. Take X \u2208 S: Case 1: X \u2208 \u22061. We defined V (X) = 1. We need to show that 1 = gY \u2208Att(X) {1\u2212V (Y )}. Since X \u2208 EN , then all of its attackers are in \u22060, and then V (Y ) = 0 (by definition), for all Y \u2208 Att(X). Therefore, gY \u2208Att(X){1\u2212 V (Y )} = 1, by (T5).\nCase 2: X \u2208 \u22060. We defined V (X) = 0. We need to show that 0 = gY \u2208Att(X) {1\u2212 V (Y )}. Since EN \u2192 X, then there exists Y \u2208 Att(X), such that Y \u2208 \u22061. By definition, V (Y ) = 1, and then gY \u2208Att(X){1\u2212 V (Y )} = 0, by (T4). case 3: X \u2208 \u2206u. We defined V (X) = Vu(X) = gY \u2208\u2206u s.t. (Y,X)\u2208R \u2206u{1 \u2212 Vu(Y )}. We need to show that gY \u2208Att(X){1 \u2212 V (Y )} = gY \u2208\u2206u s.t. (Y,X)\u2208R \u2206u {1 \u2212 Vu(Y )}. We noted above, that X \u2208 \u2206u implies that none of its attackers belong to \u22061 and therefore any remaining attackers Z not in \u2206u must be in \u22060. By definition, V (Z) = 0, therefore 1 \u2212 0 = 1 and by (T2), such values can be safely deleted in the calculation of gY \u2208Att(X){1 \u2212 V (Y )}. Therefore, deleting all such values will show that gY \u2208\u2206u s.t. (Y,X)\u2208R \u2206u{1\u2212Vu(Y )} = gY \u2208\u2206u\u222a\u22060 s.t. (Y,X)\u2208R{1\u2212 Vu(Y )}.\nHaving shown that V above solves the system of equations T , we can use Theorem 1.1 to show that in(V ) is a complete extension. We now ask whether any of the values Vu(X), for X \u2208 \u2206u can be 0 or 1. The answer is no, for if Vu(X) = 1 for any X \u2208 \u2206u, then V (X) = 1 and then X \u2208 in(V )\\EN , which is impossible, since EN is a preferred extension. Analogously, we can only get V (X) = 0 for some X \u2208 Deltau, if for some of its attackers Z \u2208 \u2206u, V (Z) = 1, which as we mentioned is impossible. This completed the proof.\nThe condition of preferred extension of the Theorem 1.2 is necessary, as shown in the example below.\nExample 1.2 Consider the complete extension E = {X} of the network below. E is not preferred, since E is a proper subset of {X,W}.\nX Y W Z\nThe network generates the following equations.\nV (X) = 1\u2212 V (Y ) (1) V (Y ) = 1\u2212 V (X) (2) V (W ) = 1\u2212 V (Z) (3) V (Z) = g({1\u2212 V (W ), 1\u2212 V (Z)}) (4)\nSince V (X) = 1, we get that V (Y ) = 0 and these values satisfy equations (1) and (2) above. However, replacing (3) in (4) gives us\nV (Z) = g(V (Z), 1\u2212 V (Z))\nIf g is product, this gives us V (Z) = V (Z)\u00b7(1\u2212V (Z))), and hence 1 = 1\u2212V (Z) \u2234 V (Z) = 0, and hence V (W ) = 1, and therefore no solution corresponding to E using g exists. Note that the two preferred extensions {X,W} and {Y,W} include W . No extension can include Z.\nHowever, with g as min, we have that (4) becomes\nV (Z) = min({1\u2212 V (W ), 1\u2212 V (Z)})\nand for this set of equations, the values V (X) = 1, V (Y ) = 0, V (W ) = V (Z) = 1 2 form a solution corresponding to E.\nThe loop in the example above is quite elucidating. Let us analyse it in some more detail.\nExample 1.3 Consider the network with a single self-referencing loop below.\nX\nThe network generates the equation:\nV (X) = g({1\u2212 V (X)})\nNotice that g({1 \u2212 V (X)}) = 1 \u2212 V (X) and hence we have that V (X) = 1 \u2212 V (X) \u2234 V (X) = 12 , whatever the function g is, as long as it satisfies (T1)\u2013(T5).\nNote that min satisfies (T1)\u2013(T4). As a result, we have that:\nCorollary 1.1 Let N = \u3008S,R\u3009 be a network and T a system of equations written for N , where for each node X, V (X) = minY \u2208Att(X)({1 \u2212 V (Y )}). Take any solution V to T . It follows that in(V ) is a complete extension.\nThis follows from Theorem 1.1. What it means is that any solution to the system of equations defined in terms of Eqmax can be translated into a complete extension simply by defining that extension as the set containing the nodes whose solution values are 1. Obviously, different solutions will give rise to different extensions.\nProposition 1.1 Let N = \u3008S,R\u3009 be a network and T a system of equations written for N , where for each node X, V (X) = minY \u2208Att(X)({1 \u2212 Y }). Then for every complete extension E of N , there exists a solution V to T satisfying:\n(C1) If X \u2208 E, then V (X) = 1.\n(C2) If E \u2192 X, then V (X) = 0.\n(C3) If X 6\u2208 E and E 6\u2192 X, then 0 < V (X) < 1.\nProof. Let E be a complete extension. Consider the following assignment of values to the nodes in S:\n\u2022 if X \u2208 E, then V (X) = 1\n\u2022 if E \u2192 X, then V (X) = 0\n\u2022 V (X) = 12 , otherwise\nWe now show that the values above form a solution to the system of equations T . As in Theorem 1.2, replacing the above values in the original system of equations will reduce them to the following types.\n(1) 1 = min(\u22061)\n(2) 0 = min(\u22062)\n(3) 12 = min(\u22063)\nWe have seen that \u22061 = {1} and since 1 = min({1}), (1) is satisfied. Similarly, 0 \u2208 \u22062 and since min({0, . . .}) = 0, so is (2). Notice that the image of V is {0, 1/2, 1}. All values in \u22063 are greater than 0, but at least one of them is 12 , therefore min(\u22063) = 12 , and hence the above assignment solves the equations.\nSo far, we have shown the basics of the equational numerical approach to abstract argumentation frameworks. In the next section we consider two additional developments that follow naturally. Firstly, we know that solutions do exist to the system of equations, but can we find them using some numerical method? For example, by applying iterations given some initial guess?8 Secondly, we would like to apply our methodology to questions of merging, voting, or any other application where a set of initial values emerges and needs to be transformed to the \u201cclosest\u201d extension. How can we do that? The following section provides a method to answer these questions."}, {"heading": "2 The Gabbay-Rodrigues Iteration Schema", "text": "Suppose we are given initial values which do not correspond to any extension in the way that we presented them in the previous section. These values may come attached to the nodes for different reasons. For instance, the arguments themselves may be expressed as some proof in a fuzzy logic and the initial values can represent the values of the conclusions of the proofs, or they can be obtained as the result of the merging of some networks, or they may come from some voting mechanism, etc. Whatever the reason, the initial values may or may not\n8As can be done to find the square root of numbers using Newton\u2019s method.\ncorrespond to a complete extension in Dung\u2019s sense and we seek a mechanism that would allow us to find the \u201cbest\u201d possible extension corresponding to them.\nConsider the equation Eqmax:\n(Eqmax) V (X) = 1\u2212maxYi\u2208Att(X){V (Yi)}\nEqmax is satisfied when the value of the node X is legal (in Caminada and Pigozzi\u2019s terminology [7]). That is, if the value of X is 1 and the value of all of X\u2019s attackers are 0; or if the value of X is 0 and at least of one X\u2019s attackers has value 1; or if the value of X \u2208 (0, 1) and at least one of X\u2019s attackers has value in (0, 1) and no attacker of X has value 1. If we aim to correct the values of the nodes in a network iteratively, we need a mechanism that leaves legal in, out and und node values intact, changing illegal in or out values into und.9 To make a distinction between these classes of values, we will call the values in {0, 1} crisp and the values in (0, 1) undecided.\nNow consider the following averaging function:\n(1\u2212X) \u00b7min {\n1 2 , 1\u2212maxY \u2208Att(X) Y\n} +X \u00b7max { 1 2 , 1\u2212maxY \u2208Att(X) Y } For legal assignments of values, we have three cases to consider:\n(L1) X is legally in. In this case X = 1 and all of its attackers have value 0. We want the value of X to remain 1. We have that:\n(1\u2212X) \u00b7min { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} +X \u00b7max { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} =\n1 \u00b7max { 1\n2 , 1\n} =\n= 1\n(L2) X is legally out. In this case X = 0 and at least one of its attackers has value 1. We want the value of X to remain 0. We have that:\n1 \u00b7min { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} +X \u00b7max { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} =\n1 \u00b7min { 1\n2 , 0\n} + 0 \u00b7max { 1\n2 , 0\n} =\n= 0\n(L3) X is legally und. In this case 0 < X < 1, none of its attackers has value 1 and at least one of its attackers has value greater than 0. This means that 0 < maxY \u2208Att(X) Y < 1 and therefore 0 < (1\u2212maxY \u2208Att(X) Y ) < 1. Let \u03b11 = min { 1 2 , 1\u2212maxY \u2208Att(X) Y } and \u03b12 = max { 1 2 , 1\u2212maxY \u2208Att(X) Y } .\nIt follows that 0 < \u03b11 < 1 and 0 < \u03b12 < 1. We want the value of X to 9We will come to the correction of illegal und nodes later.\nremain undecided, although we are prepared to accept changes to its initial value as long as its final value remains in the interval (0, 1). We have that:\n(1\u2212X) \u00b7min { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} +X \u00b7max { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} =\n(1\u2212X) \u00b7 \u03b11 +X \u00b7 \u03b12 = \u03b11 \u2212X \u00b7 \u03b11 +X \u00b7 \u03b12 = \u03b11 \u2212X \u00b7 (\u03b11 \u2212 \u03b12) = \u03ba\nNotice that \u03b11 \u2264 12 and \u03b12 \u2265 1 2 , therefore \u03b12 6< \u03b11. If \u03b11 = \u03b12, then \u03ba = \u03b11 and hence 0 < \u03ba \u2264 12 . If \u03b11 < \u03b12, then 0 < \u03b11 < 1 2 and \u03b12 = 1 2 . Therefore, \u2212 12 < (\u03b11 \u2212 \u03b12) < 0. It then follows that 0 < \u03b11 \u2264 \u03ba < 1 2 and therefore the value of X remains in (0, 1).\nWhat (L1)\u2013(L3) above give us is that legal labellings are preserved.10 Later on, we shall see that our iteration schema also eventually corrects all illegal values. It does so in two stages. In the first stage, all illegal crisp values are turned into undecided (this is done in t \u2264 |S| iterations). In the second stage, all remaining illegal undecided values converge to whatever legal crisp values they should be, so that in the limit, all of the values in the sequence are legal. Therefore, the Gabbay-Rodrigues Iteration Schema introduced below provides a numerical iterative method to turn any initial illegal assignment of values to arguments into its closest legal assignment.11\nDefinition 2.1 Let N = \u3008S,R\u3009 be an argumentation network and V0 be an assignment of values to the nodes in S. The Gabbay-Rodrigues Iteration Schema is defined by the following system of equations T , where for each node X \u2208 S, the value Vi+1(X) is defined in terms of the values of the nodes in Vi as follows:\nVi+1(X) = (1\u2212 Vi(X)) \u00b7min { 1 2 , 1\u2212maxY \u2208Att(X) Vi(Y ) } +\nVi(X) \u00b7max { 1 2 , 1\u2212maxY \u2208Att(X) Vi(Y ) } (T) We call the system of equations for N using the above iteration schema its GR system of equations. We ask whether we can regard the iteration schema above as an equation schema as in the previous section, i.e.,\nX = (1\u2212X) \u00b7min { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} +X \u00b7max { 1\n2 , 1\u2212 max Y \u2208Att(X) Y\n} (GR)\n10Legal undecided values may change, although they remain in the undecided range (by (L3)).\n11The precise definition of \u201cclosest\u201d will be made clear in Theorem 2.9.\nTo further clarify this point, let us take an equation written with an argumentation-friendly function g for a node X in terms of its attackers. The equation would be\nX = g(\u222aY \u2208Att(X){1\u2212 Y })\nIt is clear that if one of the attackers of X is 1, the value of X solves to 0, and if all the attackers of X are 0, the value of X will solve to 1. This follows from the properties (T1)\u2013(T5) of an argumentation-friendly function. Now let us compare and see what happens when we use the formula above. If the value of one of the attackers of X is 1, the first component of the sum will be 0, whereas the second component will be 12 , because the equation is implicit, we have the equation\nX = X\n2\nwhich solves to X = 0, which is correct. If the values of all attackers of X are 0, then we get the equation\nX = (1\u2212X)\n2 +X\nwhich solves to X = 1, which again gives a correct result. Otherwise, assume that the values of all attackers are either 0 or 12 , with at least one of them being 1 2 . We get the equation\nX = (1\u2212X) 2 + X 2\nwhich again solves to the correct value of X = 12 . By correct we mean that the results are exactly compatible with the Caminada labelling mentioned in Section 1, where X = 1 means X is in, X = 0 means X is out and X = 12 means X is und.\nTherefore, the Gabbay-Rodrigues schema remains faithful to the spirit of Dung\u2019s semantics captured through the legal Caminada labellings just as Eqmax does. Its advantage over Eqmax is that it can be used iteratively as we will show in the rest of this section. 12\nWe start by showing some properties of the schema. The first one ensures that the values of all nodes remain in the unit interval in all iterations.\nProposition 2.1 Let N = \u3008S,R\u3009 be an argumentation network and V0 : S 7\u2212\u2192 U an assignment of initial values to the nodes in S. Let each assignment Vi, i > 0, be calculated by the Gabbay-Rodrigues Iteration Schema for N . It follows that Vi(X) \u2208 U , for all i \u2265 0 and all X \u2208 S. Proof. The base of the induction is the initial value assignment that holds trivially. The induction step is proven by looking at the maximum and minimum values that the nodes can take and showing that the sum in the iterated schema\n12As an equation, we can regard the expression (GR) just as another type of g, a special eqGR.\nis always a number in U . Now, suppose that indeed for all nodes X \u2208 S, 0 \u2264 Vk(X) \u2264 1, for a given iteration k. Pick any node X. It follows that\nVk+1(X) = (1\u2212 Vk(X)) \u00b7min {\n1/2, 1\u2212 max Y \u2208Att(X) Vk(Y )\n} +\nVk(X) \u00b7max {\n1/2, 1\u2212 max Y \u2208Att(X) Vk(Y ) } So we have that Vk+1(X) = (1\u2212\u03b1) \u00b7x+\u03b1 \u00b7y, where 0 \u2264 \u03b1 \u2264 1, 0 \u2264 (1\u2212\u03b1) \u2264 1, 0 \u2264 x \u2264 1/2, and 1/2 \u2264 y \u2264 1.\nThe lowest value for Vk+1(X) is obtained with the lowest values for x and y, when we get that Vk+1(X) = \u03b12 . If \u03b1 = 0, then Vk+1(X) = 0 \u2265 0. If \u03b1 = 1, then we get Vk+1(X) = 1/2 \u2264 1. The highest value for Vk+1(X) is obtained with the highest values for x and y, when we get that Vk+1(X) = (1\u2212\u03b1) 2 +\u03b1. If \u03b1 = 0, then Vk+1(X) = 1/2 \u2264 1. If \u03b1 = 1, then we get Vk+1(X) = 1 \u2264 1. In all cases, 0 \u2264 Vk+1(X) \u2264 1.\nWe now show that a given \u201clegal\u201d set of initial values for the nodes in S satisfies the equations and hence the values remain unchanged.\nProposition 2.2 Let N = \u3008S,R\u3009 be a network and T its GR system of equations. Then for every complete extension E of N and all X \u2208 S, if V0 is defined using E by the clauses (C1)\u2013(C3) below, we have that V1(X) = V0(X).\n(C1) If X \u2208 E, then V0(X) = 1\n(C2) If E \u2192 X, then V0(X) = 0\n(C3) If X 6\u2208 E and E 6\u2192 X, then V0(X) = 12 Proof. Let E be a complete extension and suppose V0(X) = 1. Then X \u2208 E and hence, i) either Att(X) = \u2205, or ii) for all Y \u2208 Att(X), E \u2192 Y (since E is admissible). As a result, 1\u2212maxY \u2208Att(X){V (Y )} = 1, and hence we have that\nV1(X) = max\n{ 1\n2 , 1\n} = 1 = V0(X).\nIf on the other hand, V0(X) = 0, then E \u2192 X. Therefore, there exists some Y \u2208 Att(X), such that Y \u2208 E and hence V0(Y ) = 1. It follows that\nV1(X) = min\n{ 1\n2 , 1\u2212 1\n} = 0 = V0(X).\nFinally, if V0(X) = 12 , then X 6\u2208 E and E 6\u2192 X. We must have that for all Y \u2208 Att(X), V0(Y ) < 1 (otherwise, we would have that E \u2192 X). We must also have that for some Y \u2208 Att(X), V0(Y ) > 0, otherwise E would defend X and since it is complete X \u2208 E, but then V0(X) = 1. Therefore, 1\u2212maxY \u2208Att(X){V (Y )} = 12 , and hence we have that\nV1(X) = 1\n2 \u00b7min\n{ 1\n2 ,\n1\n2\n} + 1\n2 \u00b7max\n{ 1\n2 ,\n1\n2\n} = 1\n4 +\n1 4 = 1 2 = V0(X).\nObviously, if for all nodes X, V1(X) = V0(X) as above, then for all nodes X, Vi+1(X) = Vi(X), for all i \u2265 0.\nFurthermore, crisp values do not \u201cswap\u201d between each other and undecided values do not become crisp:\nTheorem 2.1 Let N = \u3008S,R\u3009 be an argumentation network, T a system of equations for N using the Gabbay-Rodrigues Iteration Schema, and V0 : S 7\u2212\u2192 U an assignment of initial values to the nodes in S. Let V0, V1, V2, . . . be a sequence of value assignments where each Vi, i > 0, is generated by T . Then the following properties hold for all X \u2208 S and for all k \u2265 0\n1. If Vk(X) = 0, then Vk+1(X) 6= 1.\n2. If Vk(X) = 1, then Vk+1(X) 6= 0.\n3. If 0 < Vk(X) < 1, then 0 < Vk+1(X) < 1.\nProof.\n1. Suppose Vk(X) = 0, then Vk+1(X) = min { 1/2, 1\u2212maxY \u2208Att(X) Vi(Y ) } \u2264\n1/2. 2. Suppose Vk(X) = 1, then Vk+1(X) = max { 1/2, 1\u2212maxY \u2208Att(X) Vi(Y ) } \u2265\n1/2.\n3. Suppose 0 < Vk(X) < 1. We first show that Vk+1(X) > 0. Note that 0 < (1\u2212 Vk(X)) < 1. Therefore, we have that\nVk+1(X) = (1\u2212 Vk(X)) \u00b7min {\n1/2, 1\u2212 max Y \u2208Att(X) Vi(Y )\n} +\nVk(X) \u00b7max {\n1/2, 1\u2212 max Y \u2208Att(X) Vi(Y ) } It is easy to see that the first component of the above sum is greater than or equal to 0, whereas the second is strictly greater than 0, and hence Vk+1(X) > 0.\nSince we start with values in U , Proposition 2.1, gives us that Vk+1(X) \u2264 1, for all X \u2208 S. We therefore only need to show that Vk+1(X) 6= 1. Again we have that Vk+1(X) = (1\u2212 \u03b1) \u00b7 x+ \u03b1 \u00b7 y, where\n0 < \u03b1 < 1\n0 < (1\u2212 \u03b1) < 1 0 \u2264 x \u2264 1/2 1/2 \u2264 y \u2264 1\nSuppose Vk+1(X) = 1. It follows that\n(1\u2212 \u03b1) \u00b7 x+ \u03b1 \u00b7 y = 1 x\u2212 \u03b1 \u00b7 x+ \u03b1 \u00b7 y = 1\n\u03b1(y \u2212 x) = (1\u2212 x)\n\u03b1 = 1\u2212 x y \u2212 x\nSince \u03b1 < 1, we have that 1\u2212x < y\u2212x, and hence y > 1, a contradiction.\nThe above theorem shows that any changes between iterations can only generate new values for nodes in the interval (0, 1), i.e., successive iterations can only turn crisp values into undecided. Therefore, the sets of nodes with crisp values can only decrease throughout the iterations:\nCorollary 2.1 Let N = \u3008S,R\u3009 be an argumentation network, V0 : S 7\u2212\u2192 U an initial assignment of values to the nodes in S and T its GR system of equations. It follows that for all 0 \u2264 i \u2264 j, in(Vj) \u2286 in(Vi) and out(Vj) \u2286 out(Vi).\nThe situation in the limit of the sequence of values is more complex and we will deal with it later. If between two successive iterations there are no changes in the crisp values, then these values \u201cstabilise\u201d:\nTheorem 2.2 Let N = \u3008S,R\u3009 be a network, T its GR system of equations, and V0 an initial assignment of values to the nodes in S. Let V0, V1, V2, . . . be a sequence of value assignments where each Vi, i > 0, is generated by T . Assume that for some iteration i and all nodes X \u2208 S such that Vi(X) \u2208 {0, 1}, we have that Vi+1(X) = Vi(X), then for all j \u2265 1, Vi+j(X) = Vi(X). Proof. Assume that Vi(X) \u2208 {0, 1} for some node X. There are two cases to consider.\nCase 1: Vi(X) = 0. By assumption, we have that Vi+1(X) = 0. We show that Vi+2(X) = 0. If Vi+1(X) = 0, we have that\nVi+1(X) = (1\u2212 Vi(X)) \u00b7min { 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi(Y )}\n} +\nVi(X) \u00b7max { 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi(Y )} } 0 = min { 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi(Y )} } So, maxY \u2208Att(X){Vi(Y )} = 1 and hence for some Y \u2208 Att(X), Vi(Y ) = 1. By assumption Vi+1(Y ) = 1 and hence maxY \u2208Att(X){Vi+1(Y )} = 1. Therefore,\nVi+2(X) = min\n{ 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi+1(Y )}\n} = 0\nCase 2: Vi(X) = 1. By assumption, we have that Vi+1(X) = 1. We show that Vi+2(X) = 1. If Vi+1(X) = 1, we have that\nVi+1(X) = (1\u2212 Vi(X)) \u00b7min { 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi(Y )}\n} +\nVi(X) \u00b7max { 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi(Y )} } 1 = max { 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi(Y )}\n}\nSo, maxY \u2208Att(X){Vi(Y )} = 0, and hence for all Y \u2208 Att(X), Vi(Y ) = 0. By assumption, maxY \u2208Att(X){Vi+1(Y )} = 0, and hence\nVi+2(X) = max\n{ 1\n2 , 1\u2212 max Y \u2208Att(X) {Vi+1(Y )}\n} = 1\nDefinition 2.2 Let N = \u3008S,R\u3009 be an argumentation network and V0 : S 7\u2212\u2192 U an assignment of initial values to the nodes in S. A sequence of assignments Vi : S 7\u2212\u2192 U where each i > 0 is generated by the Gabbay-Rodrigues Iteration Schema for N becomes stable at iteration k, if for all nodes X \u2208 S we have that\n1. If Vk(X) \u2208 {0, 1}, then Vk+1(X) = Vk(X); and\n2. k is the smallest value for which the condition above holds.\nNote that if Vk(X) \u2208 (0, 1), then Vk+1(X) \u2208 (0, 1), for all k \u2265 0, by Theorem 2.1.\nCorollary 2.2 Consider a sequence of value assignments V0, V1, V2, . . . as described in Theorem 2.2. If the sequence becomes stable at iteration k, then the sequence remains stable for all iterations k + j, j \u2265 0. Proof. The first stability condition in Definition 2.2 follows from Theorem 2.1 and the second condition follows from Theorem 2.2.\nCorollary 2.3 Let N = \u3008S,R\u3009 be an argumentation network, V0 : S 7\u2212\u2192 U an assignment of initial values to the nodes in S and T its GR system of equations. The following hold:\n1. If the sequence of value assignments is not stable at iteration k, then there exists X \u2208 S, such that Vk(X) \u2208 {0, 1} and Vk+1(X) \u2208 (0, 1).\n2. Let |S| = n. Then, the sequence is stable for some k \u2264 n.\nProof. (1) follows from Theorem 2.1. For (2), notice that each iteration i which is not stable causes at least one node to change value from {0, 1} into (0, 1). Theorem 2.1 states that all values in (0, 1) remain in (0, 1). Since S is finite, there are only finitely many nodes that can change from {0, 1} into (0, 1) and the number of iterations in which this can happen is bounded by |S|.\nCorollary 2.3 shows that for some value 0 \u2264 k \u2264 |S|, the sequence of value assignments V0(X), V1(X), V2(X), . . . eventually becomes stable. That is, there exists k \u2265 0, such that for all j \u2265 0 and all nodes X\n\u2022 if Vk(X) = 0, then Vk+j = 0;\n\u2022 if Vk(X) = 1, then Vk+j = 1; and\n\u2022 if Vk(X) \u2208 (0, 1), then Vk+j \u2208 (0, 1).\nRemark 2.1 Given an argumentation-friendly function g, we can define the Gabbay-Rodrigues Iteration Schema for g, denoted by GR(g), as follows.\nVi+1(X) = (1\u2212 Vi(X)) \u00b7min { 1\n2 , g(\u222aY \u2208Att(X){1\u2212 Vi(Y )})\n} +\nVi(X) \u00b7max { 1\n2 , g(\u222aY \u2208Att(X){1\u2212 Vi(Y )}) } If we further assume that g satisfies the optional condition\n(T6) If for all x \u2208 \u2206, we have that x < 1 and for some x \u2208 \u2206, x > 0, then g(\u2206) \u2208 (0, 1).\nThen the above sequence of definitions and theorems in this section still holds if we replace GR by GR(g).\nThe above discussion laid out the properties of the Gabbay-Rodrigues Iteration Schema. In what follows we shall apply it to the following question. Suppose we have an argumentation network \u3008S,R\u3009 with associated equations and an initial assignment f : S 7\u2212\u2192 U . f may come from a single agent who insists on giving certain values to the arguments of S; or f may be the result of merging several argumentation frameworks with the nodes in S (through some well-defined process, e.g., voting); or f may arise from any other process. Our problem is to find the function f \u2032, closest to f , which also corresponds to an extension of \u3008S,R\u3009 (for example, solves the equations generated from \u3008S,R\u3009). Now, what do we mean by \u201cclosest\u201d? Following Caminada and Pigozzi [7], we take the view that \u201cclosest\u201d means agreeing on the maximal number of nodes with f -values in {0, 1}. In what follows, we show how to find such an assignment f \u2032, through the Gabbay-Rodrigues Iteration Schema.\nTheorem 2.3 Let \u3008S,R\u3009 be a network and f : S 7\u2212\u2192 U an assignment of values to the nodes in S. Then there is an assignment h : S 7\u2212\u2192 U such that the sets in(h) \u2286 in(f) and out(h) \u2286 out(f) are maximal and for every node X \u2208 S:\nIf h(X) = 1, then maxY \u2208Att(X){h(Y )} = 0; and (5) If h(X) = 0, then maxY \u2208Att(X){h(Y )} = 1. (6)\nProof. The proof is analogous to the proof of Theorem 5 in [7]. Take any two assignments g1 and g2 such that for all X \u2208 S:\n\u2022 g1(X) = 0 implies f(X) = 0 and g2(X) = 0 implies f(X) = 0; and\n\u2022 g1(X) = 1 implies f(X) = 1 and g2(X) = 1 implies f(X) = 1\nand\nIf g1(X) = 1, then maxY \u2208Att(X){g1(Y )} = 0; and (7) If g2(X) = 1, then maxY \u2208Att(X){g2(Y )} = 0; and (8) If g1(X) = 0, then maxY \u2208Att(X){g1(Y )} = 1; and (9)\nIf g2(X) = 0, then maxY \u2208Att(X){g2(Y )} = 1 (10)\nIt follows that in(g1) \u2286 in(f) and out(g1) \u2286 out(f); and in(g2) \u2286 in(f) and out(g2) \u2286 out(f).\nLet us construct an assignment h : S 7\u2212\u2192 U , such that for all X \u2208 S:\nh(X) = 1 iff max(g1(X), g2(X)) = 1 (11) h(X) = 0 iff min(g1(X), g2(X)) = 0 (12)\nh(X) = 1/2 iff 0 < g1(X) < 1 and 0 < g2(X) < 1 (13)\nWe now show that the assignment h is a well-defined function and that in(h) \u2286 in(f) and that out(h) \u2286 out(f). It is easy to see that every node X gets at least one value h(X). We need to show that for every node X, this value is unique and that the above inclusions are satisfied. From (13), it is easy to see that h(X) is equal to 1/2 if and only if both g1(X) \u2208 (0, 1) and g2(X) \u2208 (0, 1). To show inclusion, suppose X \u2208 in(h). Then h(X) = 1 and hence max(g1(X), g2(X)) = 1. Either g1(X) = 1 or g2(X) = 1 (or both), and hence f(X) = 1. Therefore X \u2208 in(f). To show that h(X) is unique in this case, it is sufficient to show that min(g1(X), g2(X)) > 0. Suppose min(g1(X), g2(X)) = 0, then either g1(X) = 0 or g2(X) = 0, in which case f(X) = 0, a contradiction, since f is a function. Analogously, if X \u2208 out(h), then h(X) = 0 and hence min(g1(X), g2(X)) = 0. Then either g1(X) = 0 or g2(X) = 0 (or both), and hence f(X) = 0. Therefore, X \u2208 out(f). To show that h(X) is also unique in this case, it suffices to show that max(g1(X), g2(X)) < 1. Suppose that max(g1(X), g2(X)) = 1, then either g1(X) = 1 or g2(X) = 1, in which case f(X) = 1, a contradiction, since f is a function.\nWe now show that h satisfies (5) and (6). Suppose h(X) = 1. By construction, max(g1(X), g2(X)) = 1. It follows that i) either X \u2208 in(g1), and then by (7), maxY \u2208Att(X){g1(Y } = 0. This means that for every Y \u2208 Att(X), g1(Y ) = 0. By (12), for every Y \u2208 Att(X), h(Y ) = 0, and hence maxY \u2208Att(X){h(Y )} = 0; or ii) X \u2208 in(g2), and then by (8), maxY \u2208Att(X){g2(Y } = 0. By (12), for in(g2) is also admissible, Y \u2208 out(g2), and hence for every Y \u2208 Att(X), h(Y ) = 0, and hence again maxY \u2208Att(X){h(Y )} = 0. This shows that h satisfies (5).\nAs for (6), suppose h(X) = 0, then by the construction of h either g1(X) = 0 or g2(X) = 0 (or both). The two cases are identical. We consider only the case\ng1(X) = 0. By (9), maxY \u2208Att(X){g1(Y )} = 1, and hence for some Y \u2208 Att(X), g1(Y ) = 1. By (11), we have that h(Y ) = 1 and then maxY \u2208Att(X){h(Y )} = 1.\nNote that in(g1) \u2286 in(h), out(g1) \u2286 out(h), in(g2) \u2286 in(h) and out(g2) \u2286 out(h). Therefore, since every g1 and g2 satisfying (7)\u2013(10) give rise to a function h as described, and the number of all such functions is finite, then there exists one such h that the sets in(h) and out(h) are maximal.\nCorollary 2.4 Let \u3008S,R\u3009 be a network and f : S 7\u2212\u2192 U an assignment of values to the nodes in S and h : S 7\u2212\u2192 U the assignment such that the sets in(h) \u2286 in(f) and out(h) \u2286 out(f) are maximal and for every node X \u2208 S:\nIf h(X) = 1, then maxY \u2208Att(X){h(Y )} = 0; and (14) If h(X) = 0, then maxY \u2208Att(X){h(Y )} = 1. (15)\nas given by Theorem 2.3. Then the set in(h) is the largest admissible subset of in(f) such that also out(h) \u2286 out(f). Proof. in(h) is conflict-free: if you take X \u2208 in(h), then h(X) = 1 and then maxY \u2208Att(X){h(Y )} = 0. Therefore, either Att(X) = \u2205; or for all Y \u2208 Att(X), h(Y ) = 0, and hence Y 6\u2208 in(h).\nTo show that in(h) is admissible, we just need to show that if X \u2208 in(h) and Y \u2208 Att(X), then there exists Z \u2208 Att(Y ), such that Z \u2208 in(h). Assume that X \u2208 in(h) and Y \u2208 Att(X). By definition, h(X) = 1, and then by (14), maxWx\u2208Att(X){h(Wx)} = 0, and hence h(Y ) = 0. By (15), maxWy\u2208Att(Y ) {h(Wy)} = 1. Therefore, there exists Z \u2208 Att(Y ), such that Z \u2208 in(h).\nThe fact that in(h) is the largest subset of in(f) subject to out(h) \u2286 out(f) comes directly from Theorem 2.3.\nRemark 2.2 Consider the following network.\nX Y\nThere is no largest admissible subset of E = {X,Y }! There are two maximal admissible subsets E1 = {X} and E2 = {Y }, so the requirement that \u201cno new out nodes are generated\u201d is very important in Theorem 2.3. In terms of assignments (or labellings for that matter) this was expressed as: out(h) \u2286 out(f).13\nIf we are given an assignment f(A) = 1 and f(B) = 1, there is a class of assignments h such that the sets in(h) \u2286 in(f) and out(h) \u2286 out(f) are the largest. For instance, h(A) = h(B) = 12 . In the example above, it is sufficient to set 0 < h(A) < 1 and 0 < h(B) < 1 (we chose the value 12 in Theorem 2.3 simply because we wanted to show that one existed and because as we shall see the legal undecided values will end up converging to 12).\nNote, in particular that the assignment f does not satisfy the conditions of Theorem 2.3 (which guarantee by Corollary 2.4 that in(f) is an admissible\n13If we are given just E, we may want to think of an assignment f such that in(f) = E and out(f) = {X | E \u2192 X}, leaving the nodes in S\\(in(E) \u222a out(E)) with a value in (0, 1).\nset). We could turn f into an admissible assignment by just flipping one of the values of A or B to 0. However, if we did this, for instance, by generating the assignment f \u2032(A) = 1 and f \u2032(B) = 0, then although in(f \u2032) is admissible and in(f \u2032) \u2286 in(f), we would not have that out(f \u2032) = {B} \u2286 out(f) = \u2205!\nThis is as it should be, because an initial assignment f encodes not only which nodes we would like to be in, but also those that we would like to be out, and we cannot decide without further information to optimise on the in\u2019s in detriment of the out\u2019s.\nTheorem 2.4 Let N = \u3008S,R\u3009 be a network and T its GR system of equations. If the sequence of values V0, V1, . . . becomes stable at iteration k, then in(Vk) is the largest admissible set such that in(Vk) \u2286 in(V0) and out(Vk) \u2286 out(V0). Proof. We first show that in(Vk) is an admissible set.\n1. Suppose in(Vk) is not conflict-free. Therefore, there must exist X,Y \u2208 in(Vk), such that (Y,X) \u2208 R. Since X,Y \u2208 in(Vk), Vk(X) = Vk(Y ) = 1. Vk+1(X) = max { 1/2, 1\u2212maxY \u2208Att(X) Vk(Y ) } = 1/2, and then the se-\nquence is not stable at k, a contradiction. Therefore, in(Vk) is conflictfree.\n2. Suppose in(Vk) is not admissible. It follows that there exists X \u2208 in(Vk) and some Y \u2208 S with (Y,X) \u2208 R, such that in(Vk) 6\u2192 Y . Since X \u2208 in(Vk), then Vk(X) = 1 and since the sequence is stable at k, Vk+1(X) = 1 = max { 1/2, 1\u2212maxW\u2208Att(X) Vk(W ) } . Therefore, maxW\u2208Att(X) Vk(W )\n= 0. In particular, Vk(Y ) = 0, and hence Vk+1(Y ) = min {1/2, 1\u2212 maxZ\u2208Att(Y ) Vk(Z) } = 0, and therefore there exists Z \u2208 Att(Y ), such that Vk(Z) = 1, and hence Z \u2208 in(Vk), and hence in(Vk) \u2192 Y , a contradiction. Therefore, in(Vk) is admissible.\nNow we need to show that in(Vk) is indeed the maximal admissible set such that in(Vk) \u2286 in(V0) and out(Vk) \u2286 out(V0). By Theorem 2.3, there are unique maximal sets in(Vmax) \u2286 in(V0) and out(Vmax) \u2286 out(V0) such that in(Vmax) is admissible. Furthermore, in(Vmax) \u2287 in(Vk) and out(Vmax) \u2287 out(Vk). Suppose either in(Vk) or out(Vk) are not maximal and let 0 < j < k be the first index such that there is some X \u2208 in(Vmax), such that X 6\u2208 in(Vj) or that there is some Y \u2208 out(Vmax) such that Y 6\u2208 out(Vj) (or both). We start with the first case. Since X \u2208 in(Vmax), then X \u2208 in(Vj\u22121) and hence Vj\u22121(X) = 1. Since X 6\u2208 in(Vj), then Vj(X) < 1. It follows that Vj(X) = max { 1/2, 1\u2212maxY \u2208Att(X) Vj\u22121(Y ) } < 1. Therefore, there exists Y \u2208 Att(X), such that Vj\u22121(Y ) > 0 and hence Y 6\u2208 out(Vj\u22121). Since in(Vmax) is admissible, Y \u2208 out(Vmax) and this is a contradiction with the fact that j was the first index such that there was some Y \u2208 out(Vmax) such that Y 6\u2208 out(Vj) .\nThe second case is analogous. Take Y \u2208 out(Vmax) such that Y 6\u2208 out(Vj). Since Y \u2208 out(Vmax), then Y \u2208 out(Vj\u22121) and hence Vj\u22121(Y ) = 0. Since Y 6\u2208 out(Vj), then Vj(Y ) > 0. It follows that Vj(Y ) = min{1/2, 1\u2212maxZ\u2208Att(Y ) Vj\u22121(Z)} > 0. Therefore, for all Z \u2208 Att(Y ) we have that Vj\u22121(Z) < 1 and hence there is no Z \u2208 Att(Y ), such that Z \u2208 in(Vj\u22121). Since Y \u2208 out(Vmax),\nthere must be some Z \u2032 \u2208 Att(Y ), such that Z \u2032 \u2208 in(Vmax), but this is a contradiction since Z \u2032 6\u2208 in(Vj\u22121) and j was the first index such that there was some X \u2208 in(Vmax), such that X 6\u2208 in(Vj).\nRemark 2.3 Given an argumentation network N = \u3008S,R\u3009, an argumentationfriendly function g, a system of equations T written for N using g, and an assignment v : S 7\u2212\u2192 U , which represents initial desired values, then if v corresponds to a complete extension then the above theorems tell us that the sequence of equations V0 = v, V1, V2,. . . will become stable at some iteration k and Vk = v. Otherwise, Vk is the function giving the maximal possible crisp part in(Vk) and out(Vk) agreeing with v such that the set in(Vk) is admissible. We now have the option of extending in(Vk) into a complete extension Ecomp that is the closest extension agreeing with in(v). If this extension is also preferred, then it would correspond to an assignment f \u2032, which solves the original system of equations T (by Theorem 1.2). If the extension is not preferred, then whether such an f \u2032 exists depends on the nature of the function g. Some such functions, such as min can always find an f \u2032 for every complete extension. Others, such as product, can not always find them.14\nWe will see that with the Gabbay-Rodrigues Iteration Schema, if we continue iterating, in the limit of the sequence, we will get an extension.\nThe following definition helps to translate between values in U and values in {in,out,und}.\nDefinition 2.3 (Caminada-Pigozzi/Gabbay-Rodrigues Translation) A labelling function \u03bb and a valuation function V can be inter-defined according to the table below.\n\u03bb(X) \u2192 V\u03bb(X) V (X) \u2192 \u03bbV (X) in \u2192 1 1 \u2192 in out \u2192 0 0 \u2192 out und \u2192 1/2 (0, 1) \u2192 und\nThe choice of the value 1/2 in the translation from und is arbitrary. Any value in (0, 1) would do, but we will see that legal undecided values will converge to 1/2 in the limit, and so 1/2 is the natural choice.\nDefinition 2.4 A legal assignment V is an assignment of values V : S 7\u2212\u2192 U such that the corresponding labelling function \u03bbV defined according to Definition 2.3 is also legal.\nProposition 2.3 Let \u03bb be a labelling function and V\u03bb its corresponding CaminadaPigozzi translation. If the Gabbay-Rodrigues Iteration Schema is employed using V\u03bb as V0, then for some value k \u2265 0, the sequence of values V0, V1, . . . will\n14Product is given in Item 2. of Example 1.1. For the network S = {A,B}, R = {(A,B), (B,A), (B,B)} and the complete extension \u201call undecided\u201d, there is no solution using product.\nbecome stable and the sets in(Vk) and out(Vk) will correspond to the downadmissible labelling of \u03bb. Proof. This follows directly from Theorem 2.4 and Corollary 2.3.\nWe may also arbitrarily start with V0(X) = 1 for all nodes X \u2208 S and see if this assignment satisfies the equations. At each iteration, the equations may force the crisp values of some nodes to turn to und. Eventually, some iteration k \u2264 |S| will produce the last set of new undecided values, at which point we say that the sequence has stabilised. We have that in(Vk) and out(Vk) correspond to the largest admissible labelling such that in(Vk) \u2286 in(V0) and out(Vk) \u2286 out(V0). in(Vk) can now form the basis of a complete extension. The smallest of such (complete) extensions comes from what Caminada and Pigozzi called the up-complete labelling of \u03bbVk :\nDefinition 2.5 ([7]) Let \u03bb be an admissible labelling. The up-complete labelling of \u03bb is a complete labelling \u03bb\u2032 s.t. in(\u03bb\u2032) \u2287 in(\u03bb) and out(\u03bb\u2032) \u2287 out(\u03bb) and in(\u03bb\u2032) and out(\u03bb\u2032) are the smallest sets satisfying these conditions.\nIf we continue with our calculations we can see what happens with the values V0, V1,. . . ,Vi, . . . in the limit of the sequence. We cal these the equilibrium values. Formally,\nDefinition 2.6 Let N = \u3008S,R\u3009 be an argumentation network, T its GR system of equations, and V0 an assignment of initial values to the nodes in S. The equilibrium value of the node X is defined as Ve(X) = limi\u2192\u221e Vi(X).\nThe understanding of the meaning of the equilibrium values requires an analysis of the behaviour of the sequence. The value of a node X is essentially determined by the values of the nodes in Att(X). At the stable point k we know that the crisp values remain crisp. The values of the attackers of a node at the stable point k can be of one of three types:\n1. maxY \u2208Att(X){Vk(Y )} = 0\n2. maxY \u2208Att(X){Vk(Y )} = 1\n3. 0 < maxY \u2208Att(X){Vk(Y )} < 1\nIf the value of a node Y at the stable point k is in {0, 1}, then Theorem 2.2 ensures that it will remain the same in the limit limi\u2192\u221e Vi(Y ). As it turns out, if maxY \u2208Att(X){Vk(Y )} = 0, then limi\u2192\u221e Vi(X) = 1. And if maxY \u2208Att(X){Vk(Y )} = 1, then limi\u2192\u221e Vi(X) = 0, as shown by the next theorem.\nTheorem 2.5 Let N = \u3008S,R\u3009 be an argumentation network and V0 : S 7\u2212\u2192 U assign initial values to the nodes in S. Let the sequence of value assignments V0, V1, V2, . . . where each Vi, i > 0, is generated by the Gabbay-Rodrigues Iteration Schema be stable at iteration k. For every X \u2208 S:\n1. If maxY \u2208Att(X){Vk(Y )} = 0, then Ve(X) = 1; and\n2. If maxY \u2208Att(X){Vk(Y )} = 1, then Ve(X) = 0.\n3. If Vk(X) \u2208 {0, 1}, then Ve(X) = Vk(X);\nProof.\n1. If maxY \u2208Att(X) Vk(Y ) = 0, and the sequence is stable at k, then by Corollary 2.2, maxY \u2208Att(X) Vk+j(Y ) = 0, for all j \u2265 0. We have that\nVk+1(X) = (1\u2212 Vk(X)) \u00b7min { 1\n2 , 1\n} + Vk(X) \u00b7max { 1\n2 , 1 } = 1\n2 \u2212 Vk(X) 2 + Vk(X) = 1 2 + Vk(X) 2\nVk+2(X) = 1\n2 +\n1 4 + Vk(X) 4\nVk+j(X) = j\u2211 k=1 1 2k + Vk(X) 2j\nVe(X) = lim j\u2192\u221e Vk+j(X)\n= \u221e\u2211 k=1 1 2k + lim j\u2192\u221e Vk(X) 2j = 1 + 0 = 1\nSo if the maximum value mk of all attackers of X at iteration k is 0, then the value of X converges to 1; and finally\n2. If maxY \u2208Att(X) Vk(Y ) = 1, and the sequence is stable at k, then by Corollary 2.2, maxY \u2208Att(X) Vk+j(Y ) = 1, for all j \u2265 0. We have that\nVk+1(X) = (1\u2212 Vk(X)) \u00b7min { 1\n2 , 0\n} + Vk(X) \u00b7max { 1\n2 , 0 } = Vk(X)\n2\nVk+2(X) = Vk(X)\n4 \u2234 Vk+j(X) =\nVk(X)\n2j\nVe(X) = lim j\u2192\u221e Vk+j(X) = lim j\u2192\u221e\nVk(X)\n2j = 0\nSo if the maximum value mk of all attackers of X at iteration k is 1, then the value of X converges to 0.\n3. This follows from the fact that the sequence is stable at k;\nThe theorem above asserts self-correction for the values of nodes whose attackers are either all out or that have an attacker that is in. Case 3 above, in\nwhich 0 < maxY \u2208Att(X){Vk(Y )} < 1, is harder and will be dealt with in stages. We start with the case of a cycle whose values of the nodes are all in (0, 1) (see Figure 4). Such cycles may involve an even or odd number of nodes, so we have chains of attacks of one of the following types:\n\u2022 either X = Z1 \u2190 Z2 \u2190 . . .\u2190 Z2n = X (even cycle)\n\u2022 or X = Z1 \u2190 Z2 \u2190 . . .\u2190 Z2n+1 = X (odd cycle)\nThe next lemma shows that in either case, the value of X in the limit is 12 .\nTheorem 2.6 Let the sequence of values V0, V1, . . . , be stable at iteration k. Let X be a point such that Vk+i(X), Vk+i+1(X), . . . \u2208 (0, 1), for all i \u2265 0. Our final aim is to show that limi\u2192\u221e Vk+i(X) = 12 . As a first step towards our goal, we show that any converging subsequence V ck+j(X) converges to 1 2 (by a subsequence V ck+j(X) we mean some of the elements of the sequence Vk+i(X), that is for every j there is an ij such that V ck+j(X) = Vk+ij (X)). From now on we talk about the subsequence V ck+j(X), which we further assume that it converges to V ce (X), for every such X, and we will show that V ce (X) = 1 2 , for every X. To be absolutely clear we assume for the time being that there is a sequence of values s1, s2, s3, . . . , such that for every X, the sequence V csi(X) converges to V ce (X) and we show that under these conditions V ce (X) = 1 2 .\nConsider all possible cycles X = Z1 \u2190 Z2 \u2190 . . . \u2190 Z2n = X (even) and X = Z1 \u2190 Z2 \u2190 . . . \u2190 Z2n+1 = X (odd) and assume that amongst them we have a cycle such that there exists a sequence of values r1, r2, . . . such that for each Zi, Zi+1 is the node in Att(Zi) with maximum value and 0 < V ck+r1+r2+...+rm(Zi) < 1, for every m \u2265 0. Then V c e (Zi) = 1 2 , for all Zi.\nProof. Since the Gabbay-Rodrigues Iteration Schema uses continuous functions, if the schema holds for the elements of the sequence V ck+j(X), for every X \u2208 S, it also holds for the limit V ce (X).\nWe get the following systems of equations\n1. For the cycle X = Z1 \u2190 Z2 \u2190 . . .\u2190 Z2n = X: V ce (X) = (1\u2212V ce (X)) \u00b7min { 1 2 , 1\u2212 V c e (Y ) } +V ce (X) \u00b7max { 1 2 , 1\u2212 V c e (Y ) } ,\nwhere Y is the node in Att(X) with maximum value. We have two cases to consider.\n\u2022 V ce (Y ) \u2265 12 , then we get that\nV ce (X) = 1\u2212 V ce (Y )\n1.5\u2212 V ce (Y )\n\u2022 V ce (Y ) \u2264 12 , the we get that\nV ce (X) = 1\n1 + 2 \u00b7 V ce (Y )\nit is easy to see from the equations that if V ce (Y ) \u2265 12 , then V c e (X) \u2264 12 and if V ce (Y ) \u2264 12 , then V c e (X) \u2265 12 . Therefore, if we have the cycle X = Z1 \u2190 Z2 \u2190 . . . \u2190 Z2n = X, then we get that 12 \u2264 Z1 \u2264 1 2 , so all Zi = 1 2 .\n2. For the cycle X = Z1 \u2190 Z2 \u2190 . . .\u2190 Z2n+1 = X, we have that\n\u2022 either V ce (Y ) \u2265 12 . Let us write V c e (Y ) = 1 2 + (Y ), for some 0 \u2264\n(Y ) < 12 . We then get that\nV ce (X) = 1\u2212 V ce (Y )\n1.5\u2212 V ce (Y )\n= 1\u2212 12 \u2212 (Y )\n1.5\u2212 ( 12 + (Y ))\n= 1 2 \u2212 (Y ) 1\u2212 (Y )\nWrite V ce (X) = 1 2 \u2212 \u03b7, for some 0 < \u03b7 < 1 2 .\n1 2 \u2212 \u03b7 = 1 2 \u2212 (Y ) 1\u2212 (Y )\n\u03b7 = 12 \u2212 1 2\u2212 (Y ) 1\u2212 (Y )\n= (1 (Y ))\u22122( 12\u2212 (Y ))\n2(1\u2212 (Y )\n= 1\u2212 (Y )\u2212 1 + 2 (Y )\n2(1\u2212 (Y ))\n= (Y )\n2(1\u2212 (Y ))\n\u2022 or V ce (Y ) \u2264 12 . Let us write V c e (Y ) = 1 2 \u2212 (Y ), for some 0 \u2264 (Y ) <\n1 2 . We then get that\nV ce (X) = 1\n1 + 2( 12 \u2212 (Y )\n= 1\n1 + 1\u2212 2 (Y )\n= 1\n2(1\u2212 (Y ))\n= 1\n2 + \u03b7\n\u03b7 = 1 2(1\u2212 (Y )) \u2212 1 2\n= 1\u2212 1 + (Y ) 2(1\u2212 (Y ))\n= (Y )\n2(1\u2212 (Y ))\nWhere are we now? We saw that if we start from V ce (Y ) = 1 2 \u00b1 (Y ) and Y \u2192 X (Y attacks X as in a cycle), then V ce (X) = 12 \u00b1 \u03b7, where \u03b7 is in the other direction and\n\u03b7 = (Y )\n2(1\u2212 (Y )) .\nLet us now assume a cycle\nX = Z1 \u2190 Z2 \u2190 . . .\u2190 Zn = X\nAssume Z1 = 12 \u00b1 . What would the value of Zk be? We claim that\nZk = 1\n2 \u00b1 \u03b7k\nwhere \u03b7k =\n2(2k \u2212 (2k \u2212 1) )\nThe proof is by induction. Let X = Zk, then Y = Zk+1, and then\n\u03b7k+1 = \u03b7k\n2(1\u2212 \u03b7k)\n=\n2(2k\u2212(2k\u22121) )\n2(1\u2212 2(2k\u2212(2k\u22121) ) )\n=\n2(2k\u2212(2k\u22121) ) 2 ( 2(2k\u2212(2k\u22121) \u2212 ) 2(2k\u2212(2k+1) ) )\n= 2 ( 2k+1 \u2212 2k+1 + 2 \u2212 ) =\n2(2k+1 \u2212 (2k+1 \u2212 1) )\nSo the recursion works. Now if we have a loop, we get\nZn = Z1\nSo \u03b7n = \u03b71 and thus\n\u03b7 = \u03b7\n2(2k+1 \u2212 (2k+1 \u2212 1) )\nIf we divide by \u03b7 ( 6= 0), we get\n1 = 1\n2(2k+1 \u2212 (2k+1 \u2212 1) )\nIt is easy to see that only = 12 solves the equation. This means that V ce (Zi) = 1 2 , for all Zi.\nRemark 2.4 Ordinarily we cannot guarantee that Zi+1 is the node in Att(Zi) with maximum value for all k\u2032 > k, we need to find a subsequence. This is done as follows: we start with a node X and since there are a finite number of nodes attacking it (the network is finite), there exists a subsequence such that there is a single attacker whose V ck\u2032 value is the maximum for all k\n\u2032 in the subsequence. We can assume it is Z2. This Z2 is not unique, there may be other choices. Let Z\u03b122 be one arbitrary such choice. Repeating this consideration now for Z \u03b12 2 and for the subsequence thus obtained, we get a Z\u03b133 and a further subsequence of the subsequence and so on. Eventually, we get a final subsequence (which depends on the choices of Z\u03b1ii ) V c k+r1 ,V ck+r1+r2 , . . ., such that Z \u03b1i+1 i+1 is the node in Att(Z\u03b1ii ) with maximum value and 0 < V c k+r1+r2+...+rm\n(Z\u03b1ii+1) < 1, for each m.\nRemark 2.5 We use a similar argument to the one in Remark 2.4 to show that if a subsequence V ck+j(X) converges to V c e (X), then it can be further refined to a subsequence V csi such that V c si(Y ) converges for all Y . The reason is that the\nnumber of such Y is finite (since S is finite). We can then successively refine the sequence V ck+j(X) into subsequences for which V c k+j(Y ) also converges. Therefore, Theorem 2.6, can be used to show that the convergent sequence V ck+j converges to 12 . We can therefore further conclude that every convergent subsequence of Vk+m(X) converges to 12 . The next lemma shows that the sequence Vk+m(X) itself converges to 12 .\nLemma 2.1 Let \u03b1 = \u03b11, \u03b12, \u03b13, . . ., be an infinite sequence of values in [0, 1]. If every convergent subsequence of \u03b1 converges to 12 , then limi\u2192\u221e \u03b1i = 1 2 . Proof. For every 0 < \u03b5 < 12 , [ 1 2 \u2212 \u03b5, 1 2 + \u03b5] only a finite number of \u03b1i\u2019s are in [0, 12 \u2212 \u03b5] \u222a [ 1 2 + \u03b5, 1]. Otherwise, say [0, 1 2 \u2212 \u03b5] has an infinite number of \u03b1i\u2019s. Then since [0, 12 \u2212 \u03b5] is a closed interval with an infinite number of values in it, there would exist an infinite convergent subsequence of \u03b1 in it that does not converge to 12 .\nTherefore, we have shown that for every 0 < \u03b5 < 12 , \u03b5 small, there exists a number m such that for every n > m, ( 12 \u2212 \u03b1n) \u2208 [ 1 2 \u2212 \u03b5, 1 2 + \u03b5], that is limi\u2192\u221e \u03b1i = 1 2 .\nTheorem 2.5 asserts what the limit values of the nodes whose values of the attackers are known at the stable iteration k. Theorem 2.7 asserts the same in terms of the limit values of the attackers.\nTheorem 2.7\n1. If maxY \u2208Att(X){Ve(Y )} = 0, then Ve(X) = 1.\n2. If maxY \u2208Att(X){Ve(Y )} = 1, then Ve(X) = 0.\nProof. Note that limj\u2192\u221e{Vj+1(X)} = limj\u2192\u221e{Vj(X)}.\n1. If maxY \u2208Att(X){Ve(Y )} = 0, then we have that Ve(X) = (1\u2212 Ve(X)) \u00b7min { 1\n2 , 1\n} + Ve(X) \u00b7max { 1\n2 , 1 } Ve(X) = (1\u2212 Ve(X)) \u00b7 1\n2 + Ve(X)\n2 \u00b7 Ve(X) = 1\u2212 Ve(X) + 2 \u00b7 Ve(X) Ve(X) = 1\nSo if the equilibrium values of all attackers of X is 0, then the equilibrium value of X is 1.\n2. If maxY \u2208Att(X){Ve(Y )} = 1, then we have that Ve(X) = (1\u2212 Ve(X)) \u00b7min { 1\n2 , 0\n} + Ve(X) \u00b7max { 1\n2 , 0 } Ve(X) = Ve(X) 2 Ve(X) = 0\nSo if the equilibrium value of any of the attackers of X is 1, then the equilibrium value of X is 0.\nTheorem 2.8 Let \u3008S,R\u3009 be an argumentation network and T its GR system of equations. If the assignment V0 : S 7\u2212\u2192 U is legal then the sequence V0, V1, V2, . . . , where each Vi, i > 0, is generated by T , is stable at iteration 0. Proof. Suppose V0 is legal. Then if V0(X) = 0, then there exists Y \u2208 Att(X) such that V0(Y ) = 1. Therefore V1(X) = min {1/2, 0} = 0. If V0(X) = 1, then for all Y \u2208 Att(X), V0(Y ) = 0, and hence maxY \u2208Att(X)V0(Y ) = 0. Therefore, V1(X) = max {1/2, 1} = 1.\nThe stability of the crisp values then follows from Theorem 2.2 and since 0 < V0(X) < 1, then by Theorem 2.1 (case 3), so does the stability of the remaining non-crisp values.\nProposition 2.4 Let \u3008S,R\u3009 be an argumentation network; T its GR system of equations and Ve a function with the equilibrium values of the nodes in S calculated according to the Gabbay-Rodrigues Iteration Schema. Let \u03bb be a legal labelling function.\nTake any X \u2208 S. If \u03bb and Ve agree on the values of all nodes in Att(X), then \u03bb and Ve agree on the value of X. Proof. There are three cases to consider. Proofs of cases 1. and 2. are similar to the proofs of cases 1. and 2. of Theorem 2.5.\n1. maxY \u2208Att(X){Ve(Y )} = 0, then for all Y \u2208 Att(X), Ve(Y ) = 0. It follows that Ve(X) = \u2211\u221e k=1 1 2k + limj\u2192\u221e Vk(X)\n2j = 1 + 0 = 1. Since Ve and \u03bb agree with each other on the values of all nodes in Att(X), we have that for all Y \u2208 Att(X), \u03bb(Y ) = out and since \u03bb is legal, \u03bb(X) = in, and hence \u03bb and Ve agree with each other with respect to the value of X as well.\n2. maxY \u2208Att(X){Ve(Y )} = 1, then there exists Y \u2208 Att(X), such that Ve(Y ) = 1. It follows that Ve(X) = limj\u2192\u221e Ve(X) 2j = 0. Since Ve and \u03bb agree with\neach other on the values of all nodes in Att(X), we have that \u03bb(Y ) = in and since \u03bb is legal, \u03bb(X) = out. Hence \u03bb and Ve agree with each other with respect to the value of X as well.\n3. maxY \u2208Att(X){Ve(Y )} = 12 , then there exists Y \u2208 Att(X), such that Ve(Y ) = 1 2 (and hence \u03bb(Y ) = und) and for no Y \u2208 Att(X), Ve(Y ) = 1 (and hence for no Y \u2208 Att(X), \u03bb(Y ) = in). It follows that\nVe(X) = 1\u2212 Ve(X) 2 + Ve(X)\n2 2 \u00b7 Ve(X) =1\nVe(X) = 1\n2\nSince \u03bb is legal, \u03bb(X) = und, and hence \u03bb and Ve agree with each other with respect to the value of X.\nAnd now to the main theorem of this section, which explains the equilibrium values of all nodes and shows their relationship to Caminada and Pigozzi\u2019s downadmissible/up-complete constructions. A down-admissible labelling is obtained after a series of contraction operations as defined below.\nDefinition 2.7 ([7]) Let \u03bb be a labelling of an argumentation network \u3008S,R\u3009. A contraction sequence from \u03bb is a sequence of labellings [\u03bb1 = \u03bb, . . . \u03bbk] such that\n1. For each i \u2208 {1, . . . , k\u2212 1}, \u03bbi+1 = \u03bbi\u2212{(X, in), (X,out)}\u222a {(X,und)}, where X is an argument that is illegally labelled in, or illegally labelled out in \u03bbj; and\n2. \u03bbk is a labelling without any arguments illegally labelled in or illegally labelled out.\nTheorem 6 of [7] shows us that if we successively contract an initial labelling \u03bb, then at the end of the contraction sequence [\u03bb1 = \u03bb, \u03bb2, . . . \u03bbk], \u03bbk corresponds to the down-admissible labelling of \u03bb, which is the largest admissible labelling that is smaller or equal to \u03bb.\nNot every admissible labelling corresponds to a complete extension. However, an admissible labelling can be turned into a labelling that corresponds to a complete extension by changing the labels of nodes that illegally labelled und, to in or out as appropriate. Each such operation is called an expansion, and an expansion sequence corresponds to a list of all such operations:\nDefinition 2.8 ([7]) Let \u03bb be an admissible labelling of the argumentation network \u3008S,R\u3009. An expansion sequence from \u03bb is a sequence of labellings [\u03bb1 = \u03bb, . . . \u03bbk] such that\n1. For each i \u2208 {1, . . . , k \u2212 1},\n\u03bbi+1 =  \u03bbi \u2212 {(X,und)} \u222a {(X, in)}, if X is an argument that is illegally labelled und in \u03bbi and all its attackers are labelled out\n\u03bbi \u2212 {(X,und)} \u222a {(X,out)}, if X is an argument that is illegally labelled und in \u03bbi and it has an attacker labelled in\n2. \u03bbk is a labelling without any arguments illegally labelled und.\nCaminada and Pigozzi have shown us that if [\u03bb1 = \u03bb, . . . \u03bbk] is an expansion sequence,15 then \u03bbk is a complete labelling and it is the smallest such labelling containing \u03bb. We now introduce a few concepts to help us in the proof of our main theorem.\nDefinition 2.9 Let \u3008S,R\u3009 be an argumentation network; V be an assignment of values to the nodes in S; and \u03bb a labelling of these nodes. We say that V and \u03bb agree with each other with respect to the value of a node X if and only if the following conditions hold:\n15Note \u03bb1 must be admissible.\n1. V (X) = 1 if and only if \u03bb(X) = in\n2. V (X) = 0 if and only if \u03bb(X) = out\n3. V (X) = 1/2 if and only if \u03bb(X) = und\nWe say that V and \u03bb agree with each other if they agree with the values of all nodes in S.\nDefinition 2.10 (Attack tree of a node) Let \u3008S,R\u3009 be a network. The attack tree tree(X) of a node X \u2208 S is the tree with root X and for every node N in Tree(X), the children of N are the nodes in Att(N).\nDefinition 2.11 (Path from a node) Let \u3008S,R\u3009 be a network. Take X \u2208 S. A path from X is a sequence of nodes X = Z0, Z1, Z2, . . . such that each Zi+1, i \u2265 0, is a child of Zi in the attack tree of X. The set of all paths from a node X is denoted \u03a0(X). We allow for a single node to be a path.\nUsing paths, we can define a strongly connected component (SCC) to be a maximal subset C \u2286 S, such that for every X,Y \u2208 C, there exists a path from X containing Y .\nNote that in a SCC C for every path \u03c0 = Z0, Zi, . . . from every node Z0 \u2208 C, there exists a smallest i(\u03c0) such that for some r(\u03c0), Zi(\u03c0) = Zi(\u03c0)+r(\u03c0). i(\u03c0) < |C|. i(\u03c0) is the index of the first node in the path \u03c0 that is involved in a loop, or you can think of it as the minimum distance from the starting node of the path \u03c0 to a looping node in the path. If i(\u03c0) = 0, then Z0 attacks itself. Let us call the loop head of the path \u03c0 = Z0, Z1, . . ., the node Zi(\u03c0).\nDefinition 2.12 (Vmax-paths) Let Z be a node in a SCC C and let the sequence of values V0, V1, . . . be stable at iteration k. The set of Vmax-paths of Z is defined as Vmax-paths(Z) = {\u03c0 = [Z = Z0, Z1, . . . ] \u2208 \u03a0(Z) | for each Zi, Vk+r(Zi+1) = maxZ\u2032i+1{Vk+r(Z \u2032 i+1)} for an infinite number of r\u2019s}.\nFor every Z \u2208 C, the set of Vmax-paths from Z is non-empty (see Remark 2.4).\nDefinition 2.13 (Bar of a node) Let C be a SCC and take X \u2208 C. The bar of X is the set\nbar(X) = {Z \u2208 C | Z is the loop head of a path in Vmax-paths(X)}.\nDefinition 2.14 Let \u0393(X) be the set of Vmax-paths of X and take U \u2286 C a set of points. The bar of X modified by U is defined as\nbar(X,U) = \u22c3\n\u03c0\u2208\u0393(X)\n{ y y is the first node in \u03c0 such that either y is\nthe loop head of \u03c0 or y \u2208 U\n}\nTheorem 2.9 Let \u3008S,R\u3009 be an argumentation network; V0 be an initial assignment of values to the nodes in S; \u03bb0 an initial labelling of these nodes; and V0 and \u03bb0 faithful to each other according to Definition 2.3. Let \u03bbda be the labelling at the end of a contraction sequence from \u03bb0 and \u03bbCP the labelling at the end of an expansion sequence after \u03bbda. Let k be the point at which the sequence V0, V1,. . . becomes stable and Ve(X) the equilibrium value of a node calculated through the Gabbay-Rodrigues Iteration Schema. Then \u03bbCP and Ve agree with each other according to Definition 2.9. Proof. The proof is done on induction on the depth of a node X. Suppose the depth of X is 0. There are three main cases to consider.\nCase 1: X is a source node. By definition, X has no attackers, and hence maxY \u2208Att(X) V0(Y ) = maxY \u2208Att(X) Vk(Y ) = 0 and then by Theorem 2.5, Ve(X) = 1.\nIf \u03bb0(X) = in, then X is legally labelled in, X does not take part in the contraction or expansion sequences and therefore \u03bbCP (X) = in. If \u03bb0(X) = out, then X is illegally labelled out, and therefore the label of X is changed to und in the contraction sequence and since it is illegally labelled und, then it is subsequently changed to in in the expansion sequence. If \u03bb0(X) = und, then X cannot be contracted, and since it is illegally labelled und, its label must be changed to in during the expansion sequence. In all cases, \u03bbCP (X) = in, and hence \u03bbCP and Ve agree with each other with respect to the value of X.\nCase 2: X is part of a source SCC C and both V0 C and \u03bb0 C are legal assignments within C. Let us partition C into two components: Cc containing all nodes with crisp values and Cu containing all nodes with undecided values.\nSince \u03bb0 C is a legal assignment, and the nodes in Cc only have values in {in,out}, then no nodes in Cc are illegally labelled and hence their labels are unaffected by the contraction sequence. Likewise, since no node is labelled undecided in Cc, nothing can be subsequently expanded and \u03bbCP Cc = \u03bb0 Cc. By construction, the values of all nodes in Cu are und, and hence these nodes are not affected by the contraction sequence. Furthermore, they are all legally labelled undecided and hence the values remain unchanged, and hence \u03bbCP C = \u03bb0 C.\nSince V0 C is a legal assignment, then by Theorem 2.8, it is stable at iteration 0. As a result, for all nodes X \u2208 Cc, V1(X) = V0(X). Hence by Theorem 2.2, Ve(X) = V0(X) for all nodes X \u2208 Cc, and then since \u03bb0 and V0 are faithful to each other (Definition 2.3), conditions 1. and 2. of Definition 2.9 are satisfied. We now show that condition 3. also follows. For all nodes X \u2208 Cu, we have that 0 < V0(X) < 1. Since V0 C is a legal assignment, then for every X \u2208 Cu, 0 < maxY \u2208Att(X){V0(Y )} < 1.16\n16This effectively means that the only possible incoming attacks from Cc are from nodes labelled out. Otherwise, the attacked nodes in Cu should have been labelled out and hence would have been illegally labelled und.\nNotice that by construction Cu = C\\Cc. Stage two of case 3 below shows that for all nodes X \u2208 Cu, Ve(X) = 1/2. Therefore, condition 3. of Definition 2.9 is also satisfied and as a result, \u03bbCP and Ve agree with each other with respect to all nodes in C.\ncase 3: X is part of a source SCC C and \u03bb0 C and V0 C are not legal assignments. Stage one: We know that the sequence of assignments V0, V1,. . . , eventually becomes stable at some iteration k and by Theorem 2.4, in(Vk) \u2286 in(V0), out(Vk) \u2286 out(V0) and in(Vk) is the largest admissible subset of in(V0). By Theorem 6 of [7], in(\u03bbCP ) is the largest (and unique) admissible subset of in(\u03bb0) and since \u03bb0 and V0 are faithful to each other, we can conclude that in(Vk) = in(\u03bbda) and out(Vk) = out(\u03bbda). Note that since the sequence is stable at k, in(Vk) \u2286 in(Ve) and out(Vk) \u2286 out(Ve). Consider the sequence of expansion operations e1, e2, . . . , em and the sequence of labellings \u03bb0 = \u03bbda, \u03bb1, \u03bb2,. . . ,\u03bbm = \u03bbCP , where for each i > 0, \u03bbi is obtained from \u03bbi\u22121 via the expansion ei. We show by induction on m that in(\u03bbCP ) \u2286 in(Ve) and out(\u03bbCP ) \u2286 out(Ve). In a second step, we show that if \u03bbCP (X) = und, then Ve(X) = 1/2. Suppose that e1 turns the node X illegally labelled und by \u03bbda into in. Then out(\u03bb1) = out(\u03bbda) and in(\u03bb1) = in(\u03bbda) \u222a {X}. Then for all Y \u2208 Att(X), \u03bbda(X) = out. Therefore, Vk(Y ) = 0 for all Y \u2208 Att(X), and hence maxY \u2208Att(X){Vk(Y )} = 0. By Theorem 2.5, Ve(X) = 1 and therefore X \u2208 in(Ve). We set V 1,outk = out(Vk) and V 1,in k = in(Vk)\u222a{X}.\nSuppose that e1 turns the node X illegally labelled und by \u03bbda into out. Then in(\u03bb1) = in(\u03bbda) and out(\u03bb1) = out(\u03bbda) \u222a {X}. Then there exists Y \u2208 Att(X) such that \u03bbda(X) = in. Therefore, Vk(Y ) = 1 for some Y \u2208 Att(X), and hence maxY \u2208Att(X){Vk(Y )} = 1. By Theorem 2.5, Ve(X) = 0 and therefore X \u2208 out(Ve(X)). We set V 1,outk = out(Vk)\u222a{X} and V 1,ink = in(Vk). Assume that for some i, in(\u03bbi) = V i,in k and out(\u03bbi) = V i,out k . Now consider the i+ 1-th expansion operation ei+1. Suppose that e1+1 turns the node X illegally labelled und in \u03bbi into in. Then for all Y \u2208 Att(X), \u03bbi(X) = out. Therefore, Ve(Y ) = 0 for all Y \u2208 Att(X), and hence maxY \u2208Att(X){Ve(Y )} = 0. By Theorem 2.7, Ve(X) = 1 and therefore X \u2208 in(Ve). As before, we set V i+1,outk = V i,out k and V i+1,ink = in(Vk) \u222a {X}. Suppose that ei+1 turns the node X illegally labelled und by \u03bbi into out. Then there exists Y \u2208 Att(X) such that \u03bbi(X) = in. Therefore, Ve(Y ) = 1 for some Y \u2208 Att(X), and hence maxY \u2208Att(X){Ve(Y )} = 1. By Theorem 2.7, Ve(X) = 0 and therefore X \u2208 out(Ve(X)). Again, we set V i+1,outk = V i k \u222a {X} and V i+1,in k = V i,in k .\nBy now we know that if X \u2208 V m,ink , then Ve(X) = 1 and \u03bbCP (X) = in and that X \u2208 V m,outk , then Ve(X) = 0 and \u03bbCP (X) = out. We ask if there is some Z 6\u2208 V m,ink such that Ve(Z) = 1 or Z 6\u2208 V m,out k such that Ve(Z) = 0. The answer is no as it is explained in stage two below.\nStage two:\nLet us use Cc to denote (V m,ink \u222aV m,out k ) and C u to denote C\\Cc. Suppose X \u2208 Cu. We know that V m,ink = in(\u03bbCP ) is a complete extension and that no further expansion operation is possible from \u03bbCP , therefore if X 6\u2208 in(\u03bbCP ), then either \u03bbCP (X) = out and hence X \u2208 V m,outk , which is not possible, or \u03bbCP (X) = und and legally so. Therefore there exists Y \u2208 Att(X), such that \u03bbCP (Y ) = und and hence 0 < maxY \u2208Att(X){Ve(Y )} < 1. Similarly, if X 6\u2208 out(\u03bbCP ), then either \u03bbCP (X) = in and hence X \u2208 V m,ink , which is not possible, or \u03bbCP (X) = und and legally so. Therefore there exists Y \u2208 Att(X), such that \u03bbCP (Y ) = und and hence 0 < maxY \u2208Att(X){Ve(Y )} < 1 and therefore 0 < Ve(X) < 1. So we know that for all X \u2208 Cu, \u03bbCP (X) = und and 0 < Ve(X) < 1. In what follows, we will show that indeed for all nodes in C \u2212 Cc, Ve(X) = 1/2. Note that since we are in a SCC C, for all X \u2208 Cu, there is an infinite attack tree with root X, in which every branch is of the form X = Z0, Z1, Z2, . . . , Zk = X, where for every i > 0, (Zi+1, Zi) \u2208 R. Some of the Zi are in V m,out k , but none can be in V m,in k , for that would make Zi\u22121 out.\nThe proof is done by induction on the maximum distance from a node X in Cu to a loop Z1, Z2, . . . , Zk = Z1, where every Zi \u2208 C\\V mk . There are infinitely many paths from X in the attack tree of X, but we only need to consider the set \u0393(X) with all Vmax-paths of X. Each such path is of the form \u03c0(X) = (Z0 = X), Z1, . . .. Now define the distance of X, dimX, as the maximum index i such that for each path \u03c0(X), Zi \u2208 bar(Z, V m,outk ). This means that Zi is the first point in the path \u03c0(X) which is either a repetition of a previous point or a point in V m,outk .\nIf dimX = 0, then X must be attacked by a cycle involving only X (otherwise X \u2208 V m,outk , and then Ve(X) = 0, a contradiction). Therefore, we have a cycle that attacks X and which involves X alone. All attackers in this cycle (i.e., X) have maximum value and 0 < Vk+r(X) < 1 for every r \u2265 0. By Theorem 2.6, the value of every node in the cycle is Ve(X) = 1/2. Now the equilibrium value of the node X attacked by the\ncycle is calculated by Ve(X) = (1\u2212 Ve(X)) \u00b7min { 1\n2 ,\n1\n2\n} + Ve(X) \u00b7max { 1\n2 ,\n1\n2 } =\n1\u2212 Ve(X) 2 + Ve(X) 2\n= 1\u2212 Ve(X) + Ve(X)\n2\n= 1\n2\nNow assume that the equilibrium value of all nodes with distance up to k is 1/2 and consider the node X with distance k + 1. For all Y \u2208 Att(X), we have that dimY \u2264 k. Therefore, either Y \u2208 V m,outk in which case Ve(Y ) = 0, or by the inductive hypothesis Ve(Y ) = 1/2.17 Therefore we have that maxY \u2208 Att(X){Ve(Y )} = 1/2 and as before\nVe(X) = (1\u2212 Ve(X)) \u00b7min { 1\n2 ,\n1\n2\n} + Ve(X) \u00b7max { 1\n2 ,\n1\n2 } = 1\n2\nTo conclude, for all X \u2208 V m,ink , Ve(X) = 0; for all X \u2208 V m,out k , Ve(X) = 0; and for all X \u2208 Cu, Ve(X) = 1/2. in(Ve C) (resp., in(\u03bbCP C)) in this case is the minimal complete extension containing in(Vk C) (resp., in(\u03bbda C)).\nAssume the theorem holds for all nodes of depth up to k. We now show that it holds for nodes of depth k + 1.\nDefine Known0k+1 = {X \u2208 S | depth(X) \u2264 k} and Known m+1 k+1 = {X \u2208 S | depth(X) = k + 1 and for all Y \u2208 Att(X), Y \u2208 Knownmk+1}. We show that for all i \u2265 0, we have that \u03bbCP (X) = Ve(X), for all X \u2208 Knownik+1. First notice that by induction hypothesis, \u03bbCP (X) = Ve(X) for all X \u2208 Known0k+1. Now suppose that \u03bbCP (X) = Ve(X) for all X \u2208 Knownik+1, then by Proposition 2.4, \u03bbCP (X) = Ve(X) for all X \u2208 Knowni+1k+1. Since the network is finite, Knownek+1 = Known e+1 k+1, for some e \u2265 0. Define Cuk+1 = {X \u2208 S | depth(X) = k + 1} \\ Knownek+1. By definition, if there exists X \u2208 Cuk+1 and Y \u2208 Att(X) such that Y \u2208 Knownek+1, then \u03bbCP (Y ) = out and Ve(Y ) = 0 (otherwise the value of X would be known). Therefore, we can exclude the nodes in Knownek+1 and consider Cuk+1 in isolation. C u k+1 can therefore be treated as a network of depth 0, and the proof will follow exactly from Cases 2 and 3 of the base of the main induction, and hence for all X \u2208 Cuk+1, Ve(X) = \u03bbCP (X).\nCorollary 2.5 Let \u3008S,R\u3009 be an argumentation network and V0 be an initial assignment of values to the nodes in S. Let Ve(X) be the equilibrium value of\n17Note that Att(X) 6\u2286 Vm,outk , otherwise X would be illegally labelled und.\na node X calculated through the Gabbay-Rodrigues Iteration Schema. For all nodes X \u2208 S, Ve(X) \u2208 {0, 1/2, 1}. Proof. Follows from the possible equilibrium values of all nodes in Theorem 2.9."}, {"heading": "3 Discussion and Worked Examples", "text": "Suppose we are given a network such as the one in Figure 5 with some initial values to its nodes. The values may or may not correspond to a complete extension. We can write equations for the network, apply the Gabbay-Rodrigues Iteration Schema and obtain extensions for the network.\nFor the sake of illustration, we consider three sets of representative initial values 1., 2. and 3.. The table in Figure 5 shows what happens when these values are applied to the equations, giving both the values at the stable point (Vk) and at the limit (Ve). The corresponding down-admissible labellings and their resulting up-completion according to Caminada-Pigozzi\u2019s procedure can be obtained simply by replacing 0 with out, 1 with in and values in (0, 1) with und.\nCase 1. represents the situation in which the initial values in the cycleW \u2194 Z are compatible with an extension and hence the crisp values are preserved by the calculations. We end up with the complete extension E1 = {X,Z}. Contrast this with case 2., in which the initial values of W and Z are 1 and 0, resp. The extension E = {X,W} is also complete but is obtained neither by our procedure nor by Caminada-Pigozzi\u2019s down-admissible/up-complete construction. This can be explained as follows. The initial illegal value of Y invalidates the initial acceptance of W , turning it into undecided in the calculation of the downadmissible subset. From that point on, the original legal assignments for W and Z can no longer be restored and they both end up as undecided. As a result, we obtain the complete (but not preferred) extension E2 = {X}. This interference does not happen in case 1., because there the interference of the undecided value of Y over W is dominated by Z\u2019s 1 value that keeps W \u2019s 0 value in check (because of the behaviour of max). As a result, both W \u2019s and\nZ\u2019s initial values are retained. If however we start with a preferred extension, which is also complete by definition, we get as a result unchanged initial values (cf. Theorem 2.9). CaminadaPigozzi also give the same result because the down-admissible labelling of a labelling yielding a preferred extension is the labelling itself and since that labelling is also complete, then the up-completion does not change anything (case 3. in the table of Figure 5.\nWe can suggest an enhanced procedure to improve on the results obtained in case 2., which is outlined below. The procedure starts with an empty set of crisp values (Crisp) and a set of initial values to the nodes.\n1. Calculate the equilibrium values for all nodes using the iteration schema.\n2. If {X \u2208 S | Ve(X) \u2208 {0, 1}} \u2286 Crisp, stop. The extension is defined in the set {X | Ve(X) = 1}. Otherwise, set Crisp = Crisp \u222a {X \u2208 S | Ve(X) \u2208 {0, 1}} and proceed to step 3.\n3. For every X \u2208 {X | Ve(X) \u2208 {0, 1}}, set V0 = Ve(X) and leave V0(X) as before for the remaining nodes.\n4. Repeat from 1.\nThe above procedure is sound, since at each run the equilibrium values computed yield a complete extension. Note that re-using some of the original values does not affect soundness. If they cannot be used to generate a larger extension, they will just converge to 1/2. The procedure also terminates as long as the original network S is finite, since a new iteration is invoked only when new crisp values are generated and this is bound by |S|.\nIf we apply the procedure to Case 2. above, in the first run we will get Ve(X) = 1, Ve(Y ) = 0, Ve(W ) = Ve(Z) = 1/2. Hence, Crisp = {X,Y }. We then run it once more, this time with initial values V0(X) = 1, V0(Y ) = 0, V0(W ) = 1 and V0(Z) = 0. This will stabilise immediately at these values and then Crisp = {X,Y,W,Z}. In the third run, no new crisp values are generated, so we stop with extension {X,W}, which is a preferred extension (see case 3. above). This is closer to the original values, because the preference of W over Z is preserved.\nObviously, the procedure can also be applied using Caminada-Pigozzi\u2019s construction instead of the Gabbay-Rodrigues Iteration Schema of step 1. above."}, {"heading": "3.1 Worked Examples with Cycles", "text": "The table in Figure 6 displays initial, stable and equilibrium values (V0, Vk, Ve) for all nodes in the networks (L) and (R). The last row of the table indicates the iteration in which the stable values were reached and the equilibrium values approximated (S,E). Obviously the equilibrium values are an approximation. We set our tolerance as 10\u221219, the upper bound of the relative error due to rounding in the calculations in our 64-bit machine.18 Independent nodes, such\n18Effectively this means that if the maximum variation in node values between two successive iterations is smaller than 10\u221219, we cannot be sure it is not simply the result of a rounding\n(L) (R)\nas Z in the networks above always converge to 1 independently of their initial values. This also happens to all nodes whose values of the attackers all converge to 0. Cases (L) and (R) explore different scenarios involving cycles. The odd cycle in (L) attacks the even cycle X \u2194 Y and the even cycle in (R) attacks the odd cycle A \u2192 B \u2192 C \u2192 A. We start with (L), which contains an odd cycle attacking an even cycle. The values in the odd cycle in this case will converge to 1/2 independently of their initial values. This may or may not have an effect on nodes that are attacked by any of the nodes in the cycle. We start with an initial valid configuration for X and Y in both (L1) and (L2). The end results will differ though as explained next. If X starts with 0 and Y with 1 (L1), then the interference of the undecidedness of B over X is dominated by the Y \u2019s value of 1 and the initial values of both X and Y persist. However, if X starts with 1 and Y with 0, the undecidedness of B will then \u201ccontaminate\u201d the X\u2013Y loop. It will force X to become undecided, which in turn makes Y also become undecided. As a result, all of the values will converge to 1/2 apart from Z\u2019s, which as we said is independent and will converge to 1 (L2).\nNow let us look at (R) in which the even cycle attacks the odd one. (R1) and (R2) contain different initial valid configurations for the even cycle. This time the nodes in the even cycle are independent of external values and their original values remain. If X starts with 1, it remains with 1 and this in turn breaks the odd cycle. The attacked node B is forced to converge to 0, forcing C to converge to 1 and A to converge to 0 (independently of their initial values). An\nerror due to the precision of the computer. At that point we assume we have reached the limit of what can be accurately calculated.\ninitial value of 0 for X cannot break the odd cycle and its values will converge to 1/2 independently of their initial values (R2)."}, {"heading": "4 Comparisons with other work", "text": "This section compares our framework with other techniques that deal with initial values. Our discussions so far and the use of the Gabbay-Rodrigues Iteration Schema were in the context of the equational approach to an argumentation network when we are given some initial values. Our problem was to find a solution to the system of equations that was \u201cclose\u201d to these initial values.\nTwo important concepts which are directly related to the work presented in this paper were proposed in [7], which addressed the problem of finding an extension of an argumentation network given an initial labelling of its arguments. Their procedure works in two steps. Firstly, they calculate the downwardadmissible labelling of the original labelling, which essentially consists of an admissible labelling whose crisp part is maximally included in the original labelling. This is done by a procedure which at each step, turns an illegally labelled argument from in or out into und until no illegal crisp values remain. They called this step a contraction sequence and it is similar to what our schema does to the sequence of value assignments until it becomes stable, except that at each iteration our schema may contract more than one node simultaneously, whereas theirs contracts only one node per iteration. More importantly, their procedure is non-deterministic: it selects an illegally labelled node for contraction, but this requires searching for such nodes. Hence there is an implicit cost involved in it. Even though the search can be optimised, it renders the overall cost of the procedure in terms of steps higher than ours, which is truly bounded by |S|. Now, given an admissible labelling, a complete extension is constructed by turning nodes that are illegally labelled und into in or out as appropriate. They call this step an expansion and its counterpart in our procedure is the calculation of the limit values of the sequence. Obviously, in a computer program, we can only approximate these limit values. In our implementation, we stop the iterations when we can no longer guarantee the accuracy of the calculations without introducing rounding errors due to the limitations of the processor. This happens in linear time too (see Figure 6). In practice, the limit values can be guessed much earlier as the iteration values can be seen to be converging towards one of the three values 0, 1/2 and 1.\nWe stress that neither are we limited to the discreet values out, in and und, nor to the Eqmax equation used in the iteration schema and this allows the application of the schema in the calculation of extensions given different semantics (see Section 5).\nOne can take a different approach to the one above, especially if one is not using any equations. One can take the view that given a network with initial values, we should give an iteration formula that will stabilise on some limit final values. This approach is a bit risky. One needs to explain where the initial values come from and what is the meaning of the iteration formula. One also needs\nto check whether or not the iteration formula is sound relative to the network\u2019s extensions in Dung\u2019s sense. In other words, if the initial values correspond to an acceptable Dung extension, does the iteration formula yield a result which does not correspond to a Dung extension? We begin with the work of Pereira et al. [9], which does not take any equational approach but simply iterates on the values of the nodes. We examine in detail what they do.\nIn what follows, \u3008S,R\u3009 is an acyclic argumentation network and f : S 7\u2212\u2192 U is a function assigning initial values to the nodes in S.\nDefinition 4.1 Consider the sequence \u03b10(X), \u03b11(X), . . . , \u03b1i(X), . . ., where\n\u03b10(X) = f(X)\n\u03b1i(X) = \u03b1i\u22121(X) + min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i\u22121(Y )\n}\nand let \u03b1(X) = lim\ni\u2192\u221e\n1 2 \u03b1i + 1 2 min\n( f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i(Y ) ) Definition 4.2 The attack depth of a node X of an acyclic argumentation network, in symbols a-depth(X), is defined recursively as\na-depth(X) =\n{ 0, if Att(X) = \u2205(\nmax Y \u2208Att(X)\na-depth(Y ) ) + 1, otherwise\nThe function a-depth is well-defined, because there are no cycles in \u3008S,R\u3009.\nDefinition 4.3 Given initial values for the nodes of an acyclic network, the function \u03b2 : S 7\u2212\u2192 U provides a means of calculating fixed-point values for all nodes as follows.\n\u03b2(X) =  f(X), if a-depth(X) = 0 min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y )\n} , otherwise\nTheorem 4.1 \u03b1(X) = \u03b2(X) for all X \u2208 S. Proof. The proof is done by induction on the depth of a node. Base cases: (Depth 0) Let X be an argument node of depth 0. By definition, X\nhas no attacks. It follows that\n\u03b10(X) = f(X)\n\u03b11(X) = 1\n2 \u03b10(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y ) } = 1\n2 f(X) +\n1 2 f(X)\n= f(X)\n\u03b12(X) = 1\n2 \u03b11(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b11(Y ) } = 1\n2 f(X) +\n1 2 f(X) = f(X)\n\u03b1(X) = lim i\u2192\u221e\n{ 1\n2 \u03b1i +\n1 2 f(X) } \u03b1(X) = f(X) = \u03b2(X)\n(Depth 1) Let X be an argument node of depth 1. By definition, all nodes Y attacking X have depth 0. For all such nodes f(Y ) = \u03b10(Y ) = \u03b11(Y ) = \u03b1i(Y ) = . . . = \u03b1(Y ) = \u03b2(Y ).\n\u03b10(X) = f(X)\n\u03b11(X) = 1\n2 \u03b10(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y ) } = 1\n2 f(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y ) } \u03b12(X) = 1\n2\n( 1\n2 f(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y )\n}) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y ) } = 1\n22 f(X) +\n1\n22 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y )\n} +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y ) } \u03b1i(X) = 1\n2i f(X) + t\u2211 i=1 1 2i \u00b7min { f(X), 1\u2212 max Y \u2208Att(X) \u03b2(Y ) } = 1\n2i f(X) +\n( 1\u2212 1\n2i\n) \u00b7min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y ) } \u03b1(X) = lim\ni\u2192\u221e \u03b1i(X)\n= lim i\u2192\u221e\n1 2i f(X) +\n( 1\u2212 1\n2i\n) \u00b7min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y )\n}\n= min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y ) } = \u03b2(X)\nAssume that the theorem holds for nodes with attack depth up to k and let X be an argument node whose attack depth is k + 1. We have that\n\u03b10(X) = f(X)\n\u03b11(X) = 1\n2 \u03b10(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y ) } = 1\n2 f(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y ) } \u03b12(X) = 1\n2\n( 1\n2 f(X) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y )\n}) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b11(Y ) } = 1\n22 f(X) +\n1\n22 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y )\n} +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b11(Y ) } \u03b13(X) = 1\n2\n( 1\n22 f(X) +\n1\n22 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y )\n} +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b11(Y )\n}) +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b12(Y ) } = 1\n23 f(X) +\n1\n23 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y )\n} +\n1\n22 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b11(Y )\n} +\n1 2 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b12(Y ) } \u03b1i(X) = 1\n2i f(X) +\n1\n2i\u22120 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b10(Y )\n} +\n1\n2i\u22121 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b11(Y )\n} + . . .+\n1\n21 min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i\u22121(Y )\n}\n\u03b1i+1(X) = 1\n2i f(X) + i\u2211 i=1 1 2i \u00b7min { f(X), 1\u2212 max Y \u2208Att(X) \u03b1i(Y ) } = 1\n2i f(X) +\n( 1\u2212 1\n2i\n) \u00b7min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i(Y ) } \u03b1(X) = lim\ni\u2192\u221e\n1 2i f(X) +\n( 1\u2212 1\n2i\n) \u00b7min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i(Y ) } = lim\ni\u2192\u221e\n( 1\u2212 1\n2i\n) min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i(Y ) } = lim\ni\u2192\u221e min\n{ f(X), 1\u2212 max\nY \u2208Att(X) \u03b1i(Y ) } = min { f(X), 1\u2212 max\nY \u2208Att(X) lim i\u2192\u221e \u03b1i(Y ) } \u03b1(X) = min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b1(Y )\n}\nBut the attack depth of the nodes Y \u2208 Att(X) is no higher than k. By the induction hypothesis we have that \u03b1(Y ) = \u03b2(Y ) for all Y \u2208 Att(X) and hence\n\u03b1(X) = min { f(X), 1\u2212 max\nY \u2208Att(X) \u03b2(Y )\n} = \u03b2(X)\nThe theorem above shows that when there are no cycles, for any node X, the sequence \u03b1i(X) converges to the value \u03b2(X), which can be calculated by considering the tree with root X and propagating values from the leaves to the root according to Definition 4.3.\nOne can argue that the procedure is not sound with respect to admissibility. In particular, the algorithm does not turn arbitrary initial values into admissible ones. If we give initial value 0 to a node which should not be labelled out, the algorithm does not correct the node\u2019s value and it remains illegally out. Likewise, if we start with a two-node cycle A\u2194 B and provide initial values to A and B that correspond to a complete extension, say A = 1, B = 0, in the limit we get values A = 12 and B = 0. Ideally, the initial values should remain the same as in the Gabbay-Rodrigues Iteration Schema (and indeed Caminada and Pigozzi\u2019s down-admissible/up-complete construction)."}, {"heading": "5 Conclusions and Future Research", "text": "This paper investigated aspects concerned with argumentation networks where the arguments are provided with initial values. We are aware that assigning values to nodes and propagating values through the network has been independently investigated before as in, e.g., [8, 2]. However, our approach is different because we see a network as a generator for equations whose solutions generalise the concept of extensions of the network.\nThere are advantages to using equations to calculate extensions in this way as numerical values arise naturally in many applications where argumentation systems are used and the behaviour of the node interactions can be described naturally using equations. In addition, there are many mathematical tools to help find solutions to the equations.\nThe equational approach is general enough to be adapted to particular applications. For instance, the arguments themselves may be expressed as some proof in a fuzzy logic and then the initial values can represent the values of the conclusions of the proofs, in the spirit of Prakken\u2019s work [20]; or they can be obtained as the result of the merging of several networks, as proposed in [17, 16].\nIn this paper, we showed that the equations can be solved through an iterative process, as in Newton\u2019s method and as such one can regard initial values as initial guesses or a desired configuration of the extension. The GabbayRodrigues Iteration Schema takes the following generalised form:\nVi+1(X) = (1\u2212 Vi(X)) \u00b7min {1/2, g(N (X))}+ Vi(X) \u00b7max {1/2, g(N (X))}\nIn this paper, we considered the special case where g is min and N (X) is the set of complemented values of the nodes in the \u201cneighbourhood\u201d of X (i.e., the attackers of X).19 Other operations can be used for argumentation systems, whose relationship with the schema is being further investigated. One such operation is product, which unlike min combines the strength of the attacks on a node. Another interesting possibility is to use the schema for abstract dialectical frameworks (ADFs) [3]. ADFs require the specification of a possibly unique type of equation for each node. Consider the ADF with nodes a, b, c and d with R = {(a, b), (b, c), (c, c)}. The ADF equations are: Ca = >, Cb = a, Cc = c\u2227b and Cd = \u00acd. The complete models for this ADF are m1 = (t, t, u, u), m2 = (t, t, t, u) and m3 = (t, t, f, u). The Gabbay-Rodrigues schema converges to m1 given initial values (1, 1, 1/2, 1/2); to m2 given initial values (1, 1, 1, 1); and to m3 given initial values (0, 0, 0, 0).\nFor the case of min, we showed that the values generated at each iteration in the schema eventually \u201cstabilise\u201d by changing illegal crisp values into undecided. This process will calculate the down-admissible labelling of the initial values, as in [7], in time t linear to the set of arguments (t \u2264 |S|). If we carry on the calculation, the values of the sequence in the limit will correspond to a complete extension of the original network. Obviously, the values corresponding to a legitimate extension are all legal. If they are given as input, the sequence will immediately stabilise. In practice, a few iterations are sufficient to indicate what the values will converge to in the limit. We have also outlined a procedure which can improve on the calculation above by propagating crisp values and replacing the remaining undecided values with their initial counterparts after each run of the iterations. This procedure terminates when no new crisp values are generated. Original crisp values which are compatible with a calculated extension can thus be preserved and hence we can end up with a larger complete\n19Note that 1\u2212maxY \u2208Att(X){V (Y )} = minY \u2208Att(X){1\u2212 V (Y )}.\nextension than the one obtained through a single run. This extension is as compatible as possible with the initial values."}, {"heading": "Acknowledgements", "text": "The authors would like to thank Massimiliano Giacomin, Gabriella Pigozzi, Martin Caminada and Sanjay Modgil for comments and discussions on the topic of this paper."}, {"heading": "A Predator-Prey and Argumentation Motivating Case Studies", "text": "Let us motivate our ideas through two main examples. Our purpose is to make some conceptual distinction about iteration processes.\nExample A.1 Let us look at an example from biology. This is a model by M. P. Hassell [18] of the dynamics of a system with two parasitoids (P and Q) and one host (N). The interactions in the ecology are depicted in Figure 7. The equations modelling the dynamics are the following (see [1, p. 295]).\nN t+1 = \u03bbN tf1(P t)f2(Qt) P t+1 = N t[1\u2212 f1(P t)] Qt+1 = N tf1(P t)[1\u2212 f2(Qt)]\nIn the above equations the subscripts t and t+ 1 indicate two successive generations of P , Q and N ; \u03bb is the finite host rate of increase; and the functions f1 and f2 are the probabilities of a host not being found by P t or Qt parasitoids, respectively. This model applies to two quite distinct types of interaction that are frequently found in real systems. It applies to cases where P acts first, to be followed by Q acting only on the survivors. Such is the case where a host population with discrete generations is parasitized at different developmental stages. In addition, it applies to cases where both P and Q act together on the same host stage, but the larvae of P always out-compete those of Q, should multiparasitism occur.\nThe functions f1 and f2 are:\nf1(P t) =\n[ 1 +\na1P t k1 ]\u2212k1 f2(Qt) = [ 1 +\na2Qt k2 ]\u2212k2 where a1, a2, k1 and k2 are constants.\nTo simplify and later compare the biological model with the argumentation model, we put k1 = k2 = \u22121.\nThis gives\nf1(P t) = 1\u2212 a1P t f2(Qt) = 1\u2212 a2Qt\nand therefore, the equations are\n(1, t): N t+1 = \u03bbNt(1\u2212 a1P t)(1\u2212 a2Qt) (2, t): P t+1 = a1NtP t (3, t): Qt+1 = a2QtN t(1\u2212 a1P t) At a state of equilibrium, we get the following fixpoint equations:\nN = \u03bbN(1\u2212 a1P )(1\u2212 a2Q) (16) P = a1NP (17) Q = a2QN(1\u2212 a1P ) (18)\nIt can be easily seen from the above equations that one of the solutions is P = Q = N = 0 (the \u201call zero\u201d solution). If we ignore it, we get from (17) that\nN = 1\na1 (19)\nand from (18) we get\n1 = a2 \u00b7 1\na1 (1\u2212 a1P ) (20)\nand hence\na1 = a2 \u2212 a2a1P P = a2 \u2212 a1 a1a2\nFrom (16), we get\n1 = \u03bb ( 1\u2212 a1(a2 \u2212 a1)\na1a2\n) (1\u2212 a2Q)\n1 = \u03bba1 a2 (1\u2212 a2Q)\nso a2 \u03bba1 = 1\u2212 a2Q\na2Q = \u03bba1 \u2212 a2 \u03bba1\nQ = \u03bba1 \u2212 a2 \u03bba1a2\nTo have a specific example for discussion let a1 = 2, a2 = 3, \u03bb = 2. We get N = 0.5, P = 16 and Q = 1 12 . Indeed, substituting these values in the equations we have (1) 1 = 2 ( 1\u2212 2 \u00b7 16 ) ( 1\u2212 312\n) = 2 \u00b7 23 \u00b7 9 12 = 2 \u00b7 1836 = 1\n(2) 1 = 2 \u00b7 12 = 1\n(3) 1 = 3 \u00b7 12 ( 1\u2212 26 ) = 32 \u00b7 4 6\n= 1 Let us substitute a1, a2 and \u03bb in the equations and pretend we do not know\nthe solution. We get the equations:\n(1*) N = 2N(1\u2212 2P )(1\u2212 3Q) (2*) P = 2PN (3*) Q = 32Q(1\u2212 2P )\nSo we have a system of equations modelling a certain ecology. The equations above give rise to the iteration equations\n(1\u2217, i): N i+1 = 2N i(1\u2212 2P i)(1\u2212 3Qi) (2\u2217, i): P i+1 = 2N iP i (3\u2217, i): Qi+1 = 32Qi(1\u2212 2P i)\nLet us discuss our options. We have a system of equations involving N , P and Q and we want to solve it. We do not know whether there are solutions.\nOption 1 \u2013 a mathematical view. Let us just find a solution. We can guess a candidate solution, use Newton\u2019s method and iterate. Let us do this with the guess N0 = P 0 = Q0 = 1 2 and iterate. These are equations (1\u2217, i), (2\u2217, i) and (3\u2217, i) for i = 1. Because the equations come from ecological considerations, the iterations are not just a numerical device but also have an evolutionary meaning. However, our view is purely mathematical. The corresponding to the meaning is accidental.\nWe get N1 = 2 \u00b7 12 \u00b7Ni(1\u2212 1) ( 1\u2212 32 ) = 0 P 1 = 2 \u00b7 12 \u00b7 1 2 = 0 Q1 = 3 2 \u00b7Qi(1\u2212 2P i) = 0\nN2 = 0 P 2 = 0 Q2 = 0\nWe converge to the \u201call zero\u201d solution.\nOption 2 \u2013 a semantical view. We seek a solution motivated not by mathematics but by the meaning of the equations: by ecological considerations. So let us adopt\nthe friends of parasites view and say that we are equal and we all have a right to live and so let us seek a steady state of compromise and living together in tolerance and understanding, namely N0 = P 0 = Q0 = 1 2 .\nUnfortunately using Newton\u2019s method leads us, as shown above, to the solution P = Q = N = 0. In biological terms this is not good, it means everything is dead. So we may need a better iteration schema, a schema suitable for the biological interpretation.\nWe can choose to be selfish and cruel and start with N0 = 1 and P 0 = Q0 = 0. This means we aim at full population and no parasites. Iterating the equations will give us\nN1 = 2 P 1 = 0 Q1 = 0\nNk = 2 k P k = 0 Qk = 0\nThis does not lead to a solution. It diverges! The reader can check that even if the initial values are very close to a solu-\ntion, the method in general will not converge to the solution.\nRemark A.1 The conclusion we draw from Example A.1 is that we must be aware that some iteration processes can be mathematical only, just possibly leading to a mathematical solution but otherwise semantically meaningless, and some may be semantically meaningful and useful in the context of the application area from which the equations arise.\nThis observation shall become sharper and clearer in the case of our next example from abstract argumentation.\nExample A.2 Consider Figure 7 again but this time as an argumentation network where N , P , Q are arguments. This network has three extensions E1, E2 and E3, namely\nE1 = P is in = N and Q are out\nE2 = N is in = P and Q are out\nE3 = P , N and Q are all und In [13, 14, 15], we showed how to provide semantics for abstract argumentation in terms of equations. These equations are generated according to equation schema, of which two of the most significant ones are Eqmax and Eqinv, described next.\nLet Att(X) = {Y1, . . . , Yk} be all the attackers of X. Consider X, Y1,. . . ,Yk as variables ranging over [0, 1]. Define\nGmax(Att(X)) = 1\u2212max{Y1, . . . , Yk} Ginv(Att(X)) = \u03a0 k i=1(1\u2212 Yi)\nThe equation we write for a node X is\nX = G(Att(X)) (*)\nwhere G can be Gmax or Ginv or some other function. We consider X = 1 to mean X is in; X = 0 to mean X is out; and 0 < X < 1 to mean that X is und. The background material on the equational approach is given in the next section. It is sufficient to say here that Gmax follows more closely the traditional semantics of argumentation networks being only concerned about the highest strength of attack to a node. The solutions to the equations using Gmax correspond to the traditional concept of extensions (in Dung\u2019s sense) taking the nodes with value 1 in a solution to be the nodes in the extension.\nGinv on the other hand is also sensitive to the number of attackers to a node. For example, assume there are 10 undecided attackers Yi of X each having value 1 2 (und), then the value of X becomes 1 210 under Ginv, while under Gmax, the value of X is simply 12 . Note that X is nearer to 0 (i.e., out) in the Ginv case! The Gmax equations for the network in Figure 7 are:\nN = 1\u2212max{P ,Q} (21) P = 1\u2212N (22) Q = 1\u2212max{P ,N} (23)\nand its Ginv equations are:\nN = (1\u2212 P )(1\u2212Q) (24) P = (1\u2212N) (25) Q = (1\u2212 P )(1\u2212N) (26)\nThe Gmax equations have the solutions: N = Q = 0 and P = 1 (E1); N = 1, P = Q = 0 (E2); and N = P = Q = 12 (E3). The Ginv only accepts the first two solutions with the extension E3 not being possible.20\nNow suppose we actually do not know whether there are solutions or what they would be and let us consider our options. We have a system of equations involving N , P and Q and we want to try and solve it.\nOption 1 \u2013 A mathematical view. Let us just find a solution. This is a numerical analysis problem. We can guess a candidate solution; use, for instance, Newton\u2019s method; and iterate in the hope of converging to a solution. Option\n20The specific behaviour of Ginv is outside of the scope of this paper. However it is explored in detail in [12].\n2 \u2013 A semantical view. We seek a solution motivated not by mathematics but by the meaning of the equations; by argumentation considerations. Newton\u2019s method may not be adequate here. We want a method which, if we start very near a solution, then we get convergence to that desired solution. Here we cannot accept any solution. We want solutions which reflect the input. So we need to devise algorithms involving iterations which have a semanical meaning, in addition to the usual mathematical properties that the iteration sequences calculated by these algorithms converge. This point is important. Suppose we give the following interpretation to the network. 100 voters need to form a committee from amongst three experts P , Q and N to give an opinion on a crucial issue. All of them vote for N to be included (in), none of them want P to be included (i.e, they want P to be out), and they are equally divided on their support for Q (und). There is however an additional information about these candidates which is of a personal nature of which the voters are not aware. These are represented by the attack relation in the network, in which X \u2192 Y means X refuses to work with Y . We thus say that we have a numerical assignment N = 1, P = 0 and Q = 12 and we now ask what extension (i.e., what committee membership) is nearest to this majority vote? At first glance, the reader may think that it is extension E2 (N is in, and P and Q are out), because it agrees with the wishes of all of the voters that N is in and P is out. We would like our iteration algorithm to give us this result if possible.\nLet us look at what Newton\u2019s method would do to these initial values. We start with initial values N0 = 1, P 0 = 0 and Q0 = 1 2 and iterate for the case of Gmax (equations (21)\u2013(23)). We shall see that iterating in this way is not satisfactory. We get\nN1 = 1 2 , P 1 = 0, Q1 = 0 N2 = 1, P 2 = 12 , Q2 = 1 2 N2 = 1 2 , P 2 = 0, Q2 = 0\nThere is no convergence here, so this is not satisfactory as we do not get an answer for membership (i.e., no extension in the argumentation sense).\nLet us now compare with the Gabbay-Rodrigues Iteration Schema for Gmax, which is the main subject matter of this paper and is introduced in Section 2. The schema always yields a solution which corresponds to an extension in the argumentation sense.\nLet \u3008S,R\u3009 be an argumentation network and X,Yi \u2208 S be considered variables. Let Att(X) = {Yj} (j \u2265 0) be the attackers of X and let the equations be X = Gmax(Att(X)).21 Let Vi(X) be the value of X at iteration step i. Then the value of X at step i+ 1 is calculated as\nVi+1(X) = (1\u2212 Vi(X)) \u00b7min { 1\n2 , G ({Vi(Yj)})\n} +\nVi(X) \u00b7max { 1\n2 , G({Vi(Yj)}) } 21Ginv can also be used, with different results.\nSo for the network in Figure 7 and Gmax we get Vi+1(N) = (1\u2212 Vi(N)) \u00b7min { 1\n2 , 1\u2212max{Vi(P ), Vi(Q)}\n} +\nVi(N) \u00b7max { 1\n2 , 1\u2212max{Vi(P ), Vi(Q)} } Vi+1(P ) = (1\u2212 Vi(P )) \u00b7min { 1\n2 , 1\u2212 Vi(N)\n} +\nVi(P ) \u00b7max { 1\n2 , 1\u2212 Vi(N) } Vi+1(Q) = (1\u2212 Vi(Q)) \u00b7min { 1\n2 , 1\u2212max{Vi(P ), Vi(N)}\n} +\nVi(Q) \u00b7max { 1\n2 , 1\u2212max{Vi(P ), Vi(N)} } Let us now take the initial conditions V0(N) = 1, V0(P ) = 0 and V0(Q) = 0 and calculate the iterations. All values will converge to 12 . The perceptive reader might ask what is the philosophy behind the schema that led us to the extension E3, rather than to the larger extension E2. The schema is very sensitive to the undecided values. It acts cautiously in considering the votes for N \u2019s being included, because a proportion of the voters wanted Q to be included but N and Q cannot work together."}, {"heading": "B Numerical Argumentation Networks", "text": "In [1], the idea of support and attack networks was initially proposed. These networks allow for the assignment of initial values to the nodes of the graph; the specification of a transmission factor associated with the strength with which an attack between arguments is carried out; and the higher-level notion of an attack to an attack. In [17], we showed how some of these features can be used in the merging of argumentation networks. The numerical argumentation networks we now propose share some of the features of the support and attack networks, but introduce a functional approach to the computation of interaction between nodes.\nDefinition B.1 (Numerical Argumentation Network) A numerical argumentation network is a tuple \u3008S,R, V0, Ve, g, h,\u03a0\u3009, where\n\u2022 S is a set of nodes, representing arguments;\n\u2022 R \u2286 S2 is an attack relation, where (X,Y ) \u2208 R means \u201cX attacks Y \u201d;\n\u2022 V0 : S \u2212\u2192 U is a function assigning initial values to the nodes in S;\n\u2022 g is a function to combine attacks to a node;\n\u2022 h is a function to combine the initial value of a node with the value of its attack;\n\u2022 \u03a0 is an algorithm to compute equilibrium values Ve(X), for each node X \u2208 S.\nWe assume that g and h are possibly distinct argumentation-friendly functions according to Definition 1.2. The equilibrium value of a node X, Ve(X), is defined as h(V0(X), gY \u2208Att(X)({1\u2212 Ve(Y )})) and computed by the algorithm \u03a0. Since the computation of the equilibrium values of the nodes takes the values of the attacking nodes into account, in Cayrol and Lagasquie-Schiex\u2019s terminology, the algorithm \u03a0 offers a procedure to perform an interaction-based valuation of the graph \u3008S,R\u3009. However, our approach is more general because the computation is done in terms of equations satisfying abstract principles.\nWe start our discussion with a simple graph without cycles, such as the one in Figure 8 to illustrate how numerical argumentation networks are used in the context of the argumentation-friendly functions seen in this paper.\nGiven initial values V0(X), V0(Y ), and V0(Z) for the nodes X, Y and Z, respectively, we want the values of Ve(X), Ve(Y ) and Ve(Z) to depend on them. Since the node X is not attacked by any node, its equilibrium value Ve(X) is defined as h(V0(X), g(\u2205)) = h(V0(X), 1) = V0(X). However, the value of Ve(Y ) and Ve(Z) depend not only on their initial values, but also on the equilibrium values of their attackers. This suggests some notion of directionality in the computation.\nNow consider a more complex network, in which the node X has a number of attackers as well as an initial value V0(X) as depicted in Figure 9.\nWe can compute g({1 \u2212 Ve(Y1), . . . , 1 \u2212 Ve(Yk)}) = y, which gives us the value of the attack on X. The equilibrium value of X is the result of combining its initial value V0(X) with the value of the combined attacks on it, so we can pretend we have the interaction depicted in Figure 10. and compute h(Ve(Z1), Ve(Z2)), i.e., h(V0(X), g({1 \u2212 Ve(Y1), . . . , 1 \u2212 Ve(Yk)}). We get equations of the kind\nVe(X) = h(V0(X), g({1\u2212 Ve(Y1), . . . , 1\u2212 Ve(Yk)}) (27)\nto solve. As we mentioned, g and hmay be different functions, so for example we could have g({1\u2212 Ve(Y1), . . . , 1\u2212 Ve(Yk)}) = min({1\u2212 Ve(Y1), . . . , 1\u2212 Ve(Yk)}) and h(x, y) = x \u00b7 y.\nWhen f and g are the same, e.g., f = g = min, we can pretend we have Figure 11. And then we get Ve(X) = min({1\u2212 (1\u2212 V0(X)), 1\u2212 Ve(Y1), . . . , 1\u2212 Ve(Yk)}) = min({V0(X), 1 \u2212 Ve(Y1), . . . , 1 \u2212 Ve(Yk)}). Note that in this situation, the traditional equation (without h and initial values) is a special case of V0(X) = 1, because h(1, z) = z and then Ve(X) = h(1, g({1 \u2212 Ve(Y1), . . . , 1 \u2212 Ve(Yk)})) = g({1\u2212 Ve(Y1), . . . , 1\u2212 Ve(Yk)}).\nWe now address another issue. Once we solve equation (27), we get a function Ve such that\nVe(X) = h(V0(X), g({1\u2212 Y1, . . . , 1\u2212 Yk}))\nCan we use Ve(X) itself as an initial value? In other words, do we have that equation (28) below holds?\nVe(X) = h(Ve(X), g({1\u2212 Y1, . . . , 1\u2212 Yk})) (28)\nThe answer is \u201cno\u201d, because g and h are not necessarily the same function. In case it is the same function, we have\nVe(X) = h(Ve(X), g({1\u2212 Y1, . . . , 1\u2212 Yk})) = g({Ve(X), g({1\u2212 Y1, . . . , 1\u2212 Yk})}) = g({Ve(X), 1\u2212 Y1, . . . , 1\u2212 Yk}) = g({Z, 1\u2212 Y1, . . . , 1\u2212 Yk})\nwhere Z is the equilibrium value of a new point attacking X, whose value is fixed at V0(X). We can simulate this by adding new points Z1X and Z 2 X for each X and form the graph depicited in Figure 12. All solutions to the cycle\nZ1X \u2194 Z2X are of the form (Ve(Z1X),1\u2212 Ve(Z1X)), which means that Z1X can get any value in U and hence so can its attack on X. This can be seen as having the same effect as giving X a particular initial value in U .\nThese conditions are satisfied by the t-norm min. An attack takes the complement of the value of the attacking node to 1 (co-norm).\nWe have that\nmin Y \u2208Att(X) {1\u2212 Ve(Y )} = 1\u2212 max Y \u2208Att(X) {Ve(Y )}\ngiving us our now familiar Eqmax. The t-norm min only cares about the strength of the strongest argument. In some applications, one could argue that attacks by multiple arguments should bear more weight than the value of any of the arguments alone. One way of modelling this is by combining attacks via product.\u220f\nY \u2208Att(X)\n(1\u2212 Ve(Y )) (29)\nAgain, if any attacker of an argument has equilibrium value 1, then the value of the product will be 0. Otherwise, if all attackers of X are fully defeated, i.e., if they all have equilibrium value 0, then the value of the product will be 1. Combining the value of attacks in this way was initially proposed in [1].\nThe expression (29) is equivalent to\n1\u2212gY \u2208Att(X)Ve(Y ) (30)\nwhere xgy = x+y\u2212x.y and for V = {x1, . . . , xk}, gV = (((x1gx2)g. . .)gxk). (30) is the complement of the probabilistic sum t-conorm. It is well known that in probability theory, the probabilistic sum expresses the probability of the occurrence of independent events. Since we want to weaken the value of the attacked node, we take the complement of this sum to 1.\nA network generates a system of equations. If there are cycles in the graph, then some of the variables associated with equilibrium values will be expressed in terms of each other. We now explore this in a bit more detail.\nConsider the following example.\nAssume that all initial values are 1, that g and h are product. The graph in Figure 13 will generate the system of equations\nVe(X) = 1\u2212 Ve(Y ) Ve(Y ) = 1\u2212 Ve(X)\nwhich has an infinite number of solutions given by the formula Ve(X)+Ve(Y ) = 1. A way to arrive at a unique solution to the equations is to introduce a\nconstant \u03ba < 1 and analyse the solution to the system of equations in the limit \u03ba\u2192 1. This would give us\nVe(X) = \u03ba(1\u2212 Ve(Y )) Ve(Y ) = \u03ba(1\u2212 Ve(X))\nVe(X) = \u03ba\u2212 \u03baVe(Y ) = \u03ba\u2212 \u03ba(\u03ba\u2212 \u03baVe(X)) = \u03ba\u2212 \u03ba2 + \u03ba2Ve(X)\nVe(X)\u2212 \u03ba2Ve(X) = \u03ba\u2212 \u03ba2\nVe(X)(1\u2212 \u03ba2) = \u03ba\u2212 \u03ba2\nVe(X) = \u03ba(1\u2212 \u03ba)\n(1\u2212 \u03ba)(1 + \u03ba)\nVe(X) = \u03ba\n1 + \u03ba\nHence, when \u03ba\u2192 1, Ve(X) = Ve(Y ) = 1/2. This result explains the implicit introduction of the parameter \u03b5 to the vote aggregation function proposed by Leite and Martins in [19].22\nSince the initial values of the two nodes in the network of Figure 13 are the same, another way of looking at the network is by unravelling the cycle starting arbitrarily at one of its nodes, say X. In our example, this would result in the (infinite) network of Figure 14.\nIf we assume the initial values for X and Y are both x, the equilibrium value for X could be calculated as\nVe(X) = x \u00b7 (1\u2212 (x \u00b7 (1\u2212 (x \u00b7 (1\u2212 . . .)))) Now suppose x = 11+\u03b5 , for some \u03b5 > 0, we have that\nVe(X) = 1\n1 + \u03b5\n( 1\u2212 ( 1\n1 + \u03b5\n( 1\u2212 ( 1\n1 + \u03b5 (1\u2212 . . .) )))) Thus, in fact, we would be multiplying the initial value x = 11+\u03b5 by the number\n\u03b4 = 1\u2212 ( 1\n1 + \u03b5\n( 1\u2212 ( 1\n1 + \u03b5 (1\u2212 . . .) ))) 22We disagree with the reasons for the introduction of the parameter itself, although technically it is the reason why the solution converges. A full discussion about this is given on Section 4.\nLet us calculate what the value \u03b4 is. To simplify the calculation we set \u03b1 = (1 + \u03b5), we then get\n\u03b4 = 1\u2212 ( 1\n\u03b1\n( 1\u2212 ( 1\n\u03b1 (1\u2212 . . .) ))) If we expand the first multiplication, we get\n\u03b4 = 1\u2212 ( 1\n\u03b1 \u2212 1 \u03b12\n( 1\u2212 1\n\u03b1 (. . .) )) = 1\u2212 [ 1\n\u03b1 \u2212 1 \u03b12 + 1 \u03b13\n( 1\u2212 1\n\u03b1 (. . .) )] = 1\u2212 [ 1\n\u03b1 \u2212 1 \u03b12 + 1 \u03b13 \u2212 1 \u03b14\n( 1\u2212 1\n\u03b1 (. . .) )] = 1\u2212 [( \u03b1\u2212 1 \u03b12 ) + ( \u03b1\u2212 1 \u03b14 ) + ( \u03b1\u2212 1 \u03b16 ) + . . .\n] The component (\n\u03b1\u2212 1 \u03b12\n) + ( \u03b1\u2212 1 \u03b14 ) + ( \u03b1\u2212 1 \u03b16 ) + . . .\ncan be re-written as \u221e\u2211 k=1 (\u03b1\u2212 1) ( 1 \u03b12 )k which is the same as\n\u221e\u2211 k=0 (\u03b1\u2212 1) ( 1 \u03b12 )k \u2212 (\u03b1\u2212 1)\nThe first component in the main subtraction above is the sum of a geometric series with common ratio 1\u03b12 and scale factor \u03b1 \u2212 1. Now note that the ratio 1 \u03b12 < 1, since \u03b1 = 1 + \u03b5 > 1, and hence\n\u221e\u2211 k=0 (\u03b1\u2212 1) ( 1 \u03b12 )k = (\u03b1\u2212 1) 1\u2212 1\u03b12 = \u03b12(\u03b1\u2212 1) \u03b12 \u2212 1\nThe subtraction can therefore be re-written as\n\u03b12(\u03b1\u2212 1) \u03b12 \u2212 1 \u2212 (\u03b1\u2212 1)\n= \u03b12(\u03b1\u2212 1)\u2212 (\u03b12 \u2212 1)(\u03b1\u2212 1)\n\u03b12 \u2212 1\n= (\u03b1\u2212 1)(\u03b12 \u2212 \u03b12 + 1) \u03b12 \u2212 1 = \u03b1\n\u03b12 \u2212 1\nRemember that \u03b1 = 1 + \u03b5, hence \u03b1\n\u03b12 \u2212 1 = 1 + \u03b5\u2212 1 (1 + \u03b5)(1 + \u03b5)\u2212 1\n= \u03b5\n\u03b52 + 2\u03b5+ 1\u2212 1 = \u03b5\n\u03b5(\u03b5+ 2)\n= 1\n\u03b5+ 2\nTherefore,\n\u03b4 = ( 1\u2212 1\n\u03b5+ 2 ) and hence in the limit \u03b5\u2192 0, we get\nVe(X) = lim \u03b5\u21920\n1\n1 + \u03b5\n( 1\u2212 1\n\u03b5+ 2\n) = 1\n2\nas expected. If we just have an acyclic sequence of attacks such as the one in Figure 15, we can analyse what happens with the equilibrium values of each node, given a fixed initial value v for all nodes (again we consider f as product).\nFrom the network in Figure 15, we get that Ve(X1) = v, Ve(X2) = v \u00b7 (1\u2212v), Ve(X3) = v \u00b7 (1 \u2212 (v \u00b7 (1 \u2212 v))), and so forth. If v = 1, then Ve(X1) = 1, Ve(X2) = 0, Ve(X3) = 1,. . . . The values alternate between 0 and 1, agreeing with Dung\u2019s original semantics as expected. If v = 0, then Ve(Xi) = 0 for all 0 \u2264 i \u2264 k. This is a consequence of the fact, that by using g, the equilibrium value depends on the node\u2019s initial value and if this is 0, so is the equilibrium value of the node when g is product. Similarly, if the initial values of all nodes is 12 , we get Ve(X1) = 1 2 , Ve(X2) = 1 4 , Ve(X3) = 3 8 , . . . .\nContrast the calculation of the equilibrium values above with that of Besnard and Hunter [2], in which the values are calculated by a so-called categoriser function. In their paper, the given example of such a function was the hcategoriser h, defined as\nh(X) =\n{ 1, if Att(X) = \u2205\n1 1+ \u2211 Y \u2208Att(X) h(Y ) , otherwise\nAssuming initial value v = 1 in the example above, we would have that h(X1) = 1, h(X2) = 12 , h(X3) = 2 3 , and so forth. This obviously does not agree with Dung\u2019s interpretation.\nThe effect on the equilibrium value of a node calculated using g and h as product, when the node is attacked by a single node of same initial value is now discussed. This is the scenario depicted in Figure 16.\nIf we assume that X and Y get initial value x, we have that since X has no attacking arguments, Ve(X) = x \u00b7 (1\u2212 0) = x. We then have\nVe(X) = x Ve(Y ) = x(1\u2212 Ve(X)) = x\u2212 x2\nIf X gets initial value 1, then it gets equilibrium value 1 and since it attacks Y , its equilibrium value is 0, as expected.23 On the other hand, if X and Y get initial value 0, then Y \u2019s equilibrium value will also be 0. If X and Y get initial value 12 , then the attack by X on Y is not sufficiently strong to annihilate Y \u2019s initial value completely. In fact, it only brings it down by 50%, i.e., giving it equilibrium value 14 . This is the maximum weakening that an attack by an equally strong argument can inflict on Y using product. The full range of values under these circumstances is illustrated by Figure 17.\n0\n0.05\n0.1\n0.15\n0.2\n0.25\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1\nE qu\nili br\niu m\nv al\nue o\nf Y\nInitial value of X\nx-x2\nB.1 Comparisons with Social Abstract Argumentation Networks\nIn [19], Leite and Martins proposed social abstract argumentation frameworks which can be seen as an extension of Dung\u2019s abstract argumentation frameworks to allow the representation of information about votes to arguments. This work was subsequently extended in [11] to handle votes on attacks too.\nThe motivation for these networks is to provide a means to calculate the result of the interaction between arguments using approval and disapproval ratings from users of news forums. The idea is that when a user sees an argument, she may approve it, disapprove it, or simply abstain from expressing an opinion. Since the arguments relate to each other through an attack relation (not necessarily known to the users), the votes themselves are not sufficient to provide an overall picture of the discussion. An interesting feature of these environments is therefore their intrinsic informal nature in the sense that in practice it is possible that voters vote for multiple arguments in the debate and also that users may be unware of conflicts between the arguments.\nOne immediate concern is the provision of an appropriate semantics which can give an interpretation to the votes capturing the intuition of the voting process. The semantics must take into account both the interactions between the arguments as well as the votes originally cast for them.\nWe now introduce Eg\u030cilmez et al.\u2019s work [11], which is an extension to [19] so we can compare it with our methodology.24\nDefinition B.2 [11] A social abstract argumentation framework is a tuple \u3008S,R, VS , VR\u3009, where S is a set of arguments; R : S \u00d7 S is a binary attack relation between arguments; and VS : S \u2212\u2192 N \u00d7 N and VR : R \u2212\u2192 N \u00d7 N are functions mapping arguments and attacks to tuples \u3008v+, v\u2212\u3009 representing the total of approval and disapproval votes received by each.\nIn order to provide a semantical interpretation, Eg\u030cilmez et al. introduce the concept of a semantic framework presented below.\nDefinition B.3 [11] A social abstract argumentation semantic framework is a tuple \u3008L, \u03c4,f,g,\u00ac\u3009, where\n\u2022 L is a totally ordered set with top and bottom elements > and \u22a5, respectively\n\u2022 \u03c4 : N \u00d7 N \u2212\u2192 L is a vote aggregation function that computes the social support of arguments and attacks\n\u2022 fS ,fR : L \u00d7 L \u2212\u2192 L; g : L \u00d7 L \u2212\u2192 L; and \u00ac : L \u2212\u2192 L are algebraic operations on L\n24Note that [19] were not aware (and did not quote) [1], which was six years earlier. Thus, the only new contribution in [1] was how they determine the initial values and the connection with voting.\nThe operations \u03c4 , f, g and \u00ac are used to calculate the overall strength of the arguments and attacks based on their initial votes. For the voting scenario considered in [11], the so-called product semantics was given. In this semantics, L is U (i.e., the interval [0, 1]); fS and fR are both the product t-norm f, where xfy = x.y; g is its associated t-conorm, i.e., xgy = 1\u2212(1\u2212x).(1\u2212y) = x + y \u2212 x.y; \u00acx = 1 \u2212 x; and \u03c4 is one of a family of operations \u03c4\u03b5 defined as follows:\nDefinition B.4 [Initial support for attacks and arguments] Let X be an argument and VS(X) = \u3008p,m\u3009.\n\u03c4\u03b5(X) = p\np+m+ \u03b5\nwhere \u03b5 > 0. The initial support value for an attack (X,Y ) is calculated identically, except that we use VR ( (X,Y ) ) instead of VS(X).\nOne can regard \u03c4\u03b5 and the operation that calculates the initial social support value for arguments and attacks. However, one adverse effect of calculating the initial support in this way is that it fails to put the votes in context, so an argument for which a single supporting vote is cast can get social support close to 1 (depending on what the value of is).25\nThe semantics of a social abstract framework is then defined by a social model presented below.\nDefinition B.5 [11] Let F be a social abstract argumentation framework and T = \u3008L, \u03c4,fS ,fR,g,\u00ac\u3009 a semantic framework. A social model of F under semantics T is a total mapping M : S \u2212\u2192 L such that for every X \u2208 S\nM(X) = \u03c4(X)f \u00acgYi\u2208Att(X) {\u03c4 ( (Yi, X) ) fM(Yi)}\nNote that if f is product t-norm and g is its t-conorm, as in [11], then\nM(X) = \u03c4(X)f \u00acgYi\u2208Att(X) {\u03c4 ((Yi, X))fM(Yi)}\n= \u03c4(X) \u00b7 1\u2212 1\u2212 \u220f\nYi\u2208Att(X)\n(1\u2212 \u03c4((Yi, X)) \u00b7M(Yi))  = \u03c4(X) \u00b7\n\u220f Yi\u2208Att(X) (1\u2212 \u03c4((Yi, X)) \u00b7M(Yi))\nContrast M(X) with the equilibrium value of X, Ve(X) as we proposed it in [17, Definition 5]:\nVe(X) = V0(X) \u00b7 \u220f\nYi\u2208Att(X)\n(1\u2212 \u03be ((Yi, X))Ve(Yi))\n25\u03b5 cannot be 0, because this would render \u03c4\u03b5 ill defined for components with no votes.\nThe calculation is exactly the same, except that we compute initial support differently as discussed next. We emphasise that the notion of the strength of attack already existed since [1].\nAs Leite et al. initially pointed out in [19], there are difficulties with the vote aggregation function \u03c4 . At first, the constant \u03b5 was introduced to avoid the existence of infinite models. For example, consider the network\nY\n1\n1\nX\nAnd assume that VS(X) = VS(Y ) = \u3008x, 0\u3009. Then we have that \u03c40(X) = \u03c40(Y ) = 1 and hence any model M satisfying the equation M(X) = 1\u2212M(Y ) is a social model of the network.\nHowever, if the social support uses a very small value for \u03b5 that is nevertheless greater than 0, we get the following situation.\nM(X) = 1\n1 + \u03b5 (1\u2212M(Y ))\nM(Y ) = 1\n1 + \u03b5 (1\u2212M(X))\nIf we substitute one value for the other, we get that\nM(X) = 1\n1 + \u03b5\n( 1\u2212 1\n1 + \u03b5 (1\u2212M(X)) ) = 1\n1 + \u03b5\n( 1 + \u03b5\u2212 1 +M(X)\n1 + \u03b5 ) = 1\n1 + \u03b5\n( \u03b5+M(X)\n1 + \u03b5 ) = \u03b5+M(X)\n(1 + \u03b5)2\nM(X)(1 + \u03b5)2 = \u03b5+M(X)\nM(X)(1 + \u03b5)2 \u2212M(X) = \u03b5\nM(X) = \u03b5\n(1 + \u03b5)2 \u2212 1\n= \u03b5\n2\u03b5+ \u03b52\n= 1\n2 + \u03b5\nand hence lim\u03b5\u21920M(X) = 12 = M(Y ), which provides a unique solution. In our opinion, there is a methodological problem and a technical one. The value \u03b5 > 0 solves the technical problem, which is the convergence to a single model. However, methodologically speaking, the objective of \u03c4 is to calculate initial support for components and in that respect, the constant \u03b5 has no part to play. This situation does not arise in [17, 16], because the social support function there is normalised with respect to the total number of argumentation networks being merged. We hope we have shed some light into the technicalities of finding solutions to the equations throughout this paper.\nA more difficult problem is the exaggerated role played by terminal arguments with little support, as shown below. Consider the following example:\nX Y\n\u03c4 ( (X,Y ) )\nand assume that VS(X) = \u30081, 0\u3009 and VS(Y ) = \u300899, 0\u3009. According to Definition B.4, \u03c40(X) = 1. Since X is a terminal argument, M(X) = 1(1\u22120) = 1 and hence M(Y ) = \u03c40(Y )(1 \u2212 \u03c4 ((X,Y )) \u00b7M(X)) = \u03c40(Y ) (1\u2212 \u03c4 ((X,Y ))). Hence, the fate of Y depends on how strongly the attack from X is supported.26 Although this technically solves the problem, it mixes the two issues, because a voter must vote for an argument as well as for its attacks, if they are to have any effect and an argument can get very high initial support even if it is voted only by a very small number of voters.27\n26The main motivation for the introduction of the weights on attacks in [11]. 27High values of \u03c4 should correspond to high level of initial support."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "<lb>Given an argumentation network with initial values to the arguments,<lb>we look for algorithms which can yield extensions compatible with such<lb>initial values. We find that the best way of tackling this problem is to offer<lb>an iteration formula that takes the initial values and the attack relation<lb>and iterates a sequence of intermediate values that eventually converges<lb>leading to an extension. The properties surrounding the application of<lb>the iteration formula and its connection with other numerical and non-<lb>numerical techniques proposed by others are thoroughly investigated in<lb>this paper. 1 Orientation and Background 1.1 Orientation<lb>A finite system \u3008S,R\u3009, with R a binary relation on S, can be viewed in many<lb>different ways; among them are 1. As an abstract argumentation framework [10], and 2. As a generator of equations [13, 14] 1<lb>ar<lb>X<lb>iv<lb>:1<lb>40<lb>8.<lb>67<lb>06<lb>v2<lb>[<lb>cs<lb>.A<lb>I]<lb>1<lb>8<lb>M<lb>ar<lb>2<lb>01<lb>5 When viewed as an abstract argumentation framework, the basic concepts<lb>studied are those of extensions (being certain subsets of S) and different se-<lb>mantics (being sets of extensions). When studied as generators of equations,<lb>one can generate equations in such a way that the solutions f to the equations<lb>correspond to (complete) extensions and sets of such solutions correspond to<lb>semantics.<lb>This paper offers an iteration schema for finding specific solutions to the<lb>equations responding to initial requirements and shows what these solutions<lb>correspond to in the abstract argumentation sense.<lb>We now explain the role iteration formulas play in general in the equational<lb>context.<lb>When we have a system of equations designed to model an application area1<lb>we face two problems: 1) find any solution to the system of equations, which<lb>will have a meaning in the application area giving rise to the equations; 2)<lb>given boundary conditions and/or other requirements not necessarily mathe-<lb>matical which are meaningful in the application area,2 we would like to find<lb>a solution to the system of equations that is compatible/respects the initial<lb>conditions/requirements.<lb>These two problems are distinct. The first one of finding any solution is a<lb>numerical analysis problem. There are various iteration methods in numerical<lb>analysis to find solutions, of which one of the most known is Newton\u2019s method.3<lb>The second problem is totally different. It calls for an understanding of the<lb>requirements coming from the application area and possibly the design of a<lb>specialised iteration formula which respects the type of requirements involved.<lb>This paper provides the Gabbay-Rodrigues Iteration Schema, for the case of<lb>the equational approach to argumentation, seeking solutions (which we shall see<lb>will correspond to complete extensions) respecting as much as possible initial<lb>demands and restrictions of what arguments are in or out of the extension. We<lb>compare what our iteration schema does with Caminada and Pigozzi\u2019s down-<lb>admissible and up-complete constructions [7]. Because we are dealing with<lb>iteration formulas (involving limits) and we are comparing with set theoretical<lb>operations (as in Caminada and Pigozzi\u2019s paper) we have to be detailed and<lb>precise and despite it being conceptually clear and simple, the proofs turn out<lb>to be mathematically involved, and require some patience from our readers.<lb>However, once we establish the properties of our iteration schema, its use and<lb>application are straightforward and computationally simple, especially in the<lb>context of such tools as MATHEMATICA and others like it. The reader may<lb>wish to just glance at the technical proofs and concentrate on the examples and<lb>1For example, equations of fluid flow in hydrodynamics or equations of particle motion<lb>in mechanics, or equations modelling argumentation networks according to the equational<lb>approach (to be explained later), or equations modelling a biological system of predator-prey<lb>ecology, or some polynomial equation arising in macroeconomics.<lb>2For example, initial conditions in the case of particle mechanics, or initial size of population<lb>in the ecology, or arguments that we would like to be accepted.<lb>3This method starts with an initial guess of a possible solution and uses various iteration<lb>formulae hoping that it will converge to a solution (for an introduction on numerical analysis<lb>see [21]).", "creator": "LaTeX with hyperref package"}}}