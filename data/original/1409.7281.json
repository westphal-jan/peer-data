{"id": "1409.7281", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Sep-2014", "title": "Causal Graph Justifications of Logic Programs", "abstract": "In this work we propose a multi-valued extension of logic programs under the stable models semantics where each true atom in a model is associated with a set of justifications. These justifications are expressed in terms of causal graphs formed by rule labels and edges that represent their application ordering. For positive programs, we show that the causal justifications obtained for a given atom have a direct correspon- dence to (relevant) syntactic proofs of that atom using the program rules involved in the graphs. The most interesting contribution is that this causal information is obtained in a purely semantic way, by algebraic op- erations (product, sum and application) on a lattice of causal values whose ordering relation expresses when a justification is stronger than another. Finally, for programs with negation, we define the concept of causal stable model by introducing an analogous transformation to Gelfond and Lifschitz's program reduct. As a result, default negation behaves as \"absence of proof\" and no justification is derived from negative liter", "histories": [["v1", "Thu, 25 Sep 2014 14:56:57 GMT  (79kb,D)", "http://arxiv.org/abs/1409.7281v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["pedro cabalar", "jorge fandinno", "michael fink"], "accepted": false, "id": "1409.7281"}, "pdf": {"name": "1409.7281.pdf", "metadata": {"source": "CRF", "title": "Causal Graph Justifications of Logic Programs\u2217", "authors": ["Pedro Cabalar", "Jorge Fandinno", "Michael Fink"], "emails": ["jorge.fandino}@udc.es)", "fink@kr.tuwien.ac.at)"], "sections": [{"heading": null, "text": "KEYWORDS: Answer Set Programming, Causality, Knowledge Representation, Multi-valued Logic Programming"}, {"heading": "1 Introduction", "text": "An important difference between classical models and most Logic Programming (LP) semantics is that, in the latter, true atoms must be founded or justified by a given derivation. Consequently, falsity is understood as absence of proof: for instance, a common informal way reading for default literal not p is \u201cthere is no way to derive p.\u201d Although this idea seems quite intuitive, it actually resorts to a concept, the ways to derive p, outside the scope of the standard LP semantics. In other words, LP semantics point out whether there exists some derivation for an atom, but do not provide the derivations themselves, if several alternatives exist.\nHowever, such information on justifications for atoms can be of great interest for Knowledge Representation (KR), and especially, for dealing with problems related to causality. In the area of diagnosis, for instance, when a discrepancy between expected and observed behaviour\n\u2217 This research was partially supported by Spanish MEC project TIN2009-14562-C05-04, Xunta program INCITE 2011 and Inditex-University of Corunna 2013 grants, as well as by the Austrian Science Fund (FWF) project P24090.\nar X\niv :1\n40 9.\n72 81\nv1 [\ncs .A\nis found, it may be convenient to not only exhibit a set of malfunctioning components as explanation, but also the way (a causal graph) in which these breakdowns have eventually caused the discrepancies. Another potential application area is legal reasoning where determining a legal responsability usually involves finding out which agent or agents have eventually caused a given result, regardless the chain of effects involved in the process. An important challenge in causal reasoning is the capability of not only deriving facts of the form \u201cA has caused B,\u201d but also being able to represent them and reason about them. As an example, take the assertion:\n\u201cIf somebody causes an accident, (s)he is legally responsible for that.\u201d This law does not specify the possible ways in which a person may cause an accident. Depending on a representation of the domain, the chain of events from the agent\u2019s action(s) to the final effect may be simple (a direct effect) or involve a complex set of indirect effects and defaults like inertia. Regarding representation of the above law, for instance, one might think of an informal rule:\nresponsible(X ,Y )\u2190 action(A), person(X), accident(Y ), \u201cdo(A,X) caused occurs(Y )\u201d .\nIf the pseudo-literal \u201cdo(A,X) caused occurs(Y )\u201d actually corresponds to an explicit representation of all the possible ways of causing an accident, however, one immediately runs into a problem of elaboration tolerance (McCarthy 1998) \u2014 adding new rules that causally connect do(A,X) to occurs(Y ) (in a direct or indirect way) would force us to build new rules for responsible(X ,Y ). What is needed instead, and what we actually propose as an eventual aim and future extension of our work, is to introduce, indeed, some kind of new LP literal \u201cA caused B,\u201d with an associated semantics capable of revealing causes A of a given true atom B.\nWhile not straightforward, the rewarding perspective of such a semantic approach is an extension of Answer Set Programming (ASP) (Brewka et al. 2011) with causal literals capable of representing different kinds of causal influences (sufficient cause, necessary cause, etc). In this paper, we tackle the above issue and, as a first step and basic underlying requirement, develop a suitable semantics capable of associating causal justifications with each true atom. To this end, we propose a multi-valued extension of logic programs under the stable model semantics (Gelfond and Lifschitz 1988) where each true atom in a model is associated with a set of justifications in the form of causal graphs. To further illustrate our motivation, consider the following example.\nExample 1 (From Cabalar 2011) Some country has a law l that asserts that driving drunk is punishable with imprisonment. On the other hand, a second law m specifies that resisting arrest has the same effect. The execution e of a sentence establishes that a punishment implies imprisonment. Suppose that some person drove drunk and resisted to be arrested.\nWe can capture this scenario with the following logic program P1:\nl : punish\u2190 drive, drunk m : punish\u2190 resist e : prison\u2190 punish d : drive k : drunk r : resist\nThe least model of this positive program makes atom prison true, so we know that there exists a possible derivation for it. In particular, two alternative justifications can be made, corresponding to the graphs in Figure 1(a): driving drunk and, independently, resisting to authority (vertices and edges respectively corresponds with rule labels and their dependences).\nMore specifically, we summarise our contributions as follows. \u2022 We define a multi-valued semantics for (normal) logic programs based on causal graphs.\nAn important result is that, despite of this semantic nature, we are able to show that causal\nvalues have a direct correspondence to (relevant) syntactic proofs using the program rules involved in the graphs (cf. Section 4). \u2022 We also define an ordering relation that specifies when a cause is stronger than another, and show how causal values form a lattice with three associated algebraic operations: a product \u2018\u2217\u2019 representing conjunction or joint causation; a sum \u2018+\u2019 representing alternative causes; and a non-commutative product \u2018\u00b7\u2019 that stands for rule application. We study beneficial properties of these operations that allow manipulating and reasoning with causal values in an analytical way (cf. Sections 2 and 3). Fostered by its algebraic treatment of causal values, our work facilitates the incorporation of dedicated, more specific causal expressions representing causal influence of different kinds."}, {"heading": "2 Causes as graphs", "text": "In this and subsequent Section 3, we introduce the lattice of causal values in two different steps. In a first step, we focus on the idea of an \u201cindividual\u201d cause and then we proceed to explain the concept of causal value that allows collecting different alternative causes.\nWe begin recalling several graph definitions and notation. A (directed) graph is a pair \u3008V,E\u3009 where V is a set of vertices V and E is a set of edges E \u2286V \u00d7V . In the following definitions, let G = \u3008V,E\u3009 and G\u2032 = \u3008V \u2032,E \u2032\u3009 be two graphs. We say that G is a subgraph of G\u2032, written G\u2286 G\u2032, when V \u2286V \u2032 and E \u2286E \u2032. We write G\u222aG\u2032 to stand for the graph \u3008V \u222aV \u2032,E\u222aE \u2032\u3009. We represent the reflexive and transitive closure of G as G\u2217. Finally, we introduce a concatenation operation G G\u2032 on graphs corresponding to a graph with vertices V \u222aV \u2032 and edges E\u222aE \u2032\u222a{(x,y) | x\u2208V,y\u2208V \u2032}. Notice that, G\u222aG\u2032 \u2286G G\u2032, that is, the concatenation extends the union of graphs by adding all possible arcs that go from some node in G to some node in G\u2032.\nDefinition 1 (Causal graph) Given some set Lb of (rule) labels, a causal graph (c-graph) G is a reflexively and transitively closed directed graph, i.e., G\u2217 = G, whose vertices are labels, i.e. V \u2286 Lb. We denote by CLb the set of all possible causal graphs over Lb.\nIntuitively, the vertices correspond to rules involved in a derivation of a given atom (or formula), and the edges point out a (partial) ordering of application of rules in the derivation. Figure 1(a) shows two causal graphs with labels from P1. Transitivity is crucial for interpreting the subgraph relation G\u2286 G\u2032 as a way to express that G\u2032 is redundant with respect to G. For instance, a graph G3 formed by the single edge (r,e) is not a subgraph of G2 but is simpler (does not require using m). This fact is captured by G\u22173 \u2286 G\u22172. Reflexivity is convenient for simpler definitions. For\ninstance, the causal graph formed by a single label l also has a single edge (l, l)\u2014we call this an atomic causal graphs and represent it just by its label. For simplicity, we will usually omit transitive and reflexive arcs when depicting a causal graph. For instance, taking G1 and G2 in Figure 1(a) as causal graphs actually amounts to considering the graphs shown in Figure 1(b), where previously omitted arcs are shown as dotted lines. We define next a natural ordering relation among them.\nDefinition 2 (Sufficient) A causal graph G is sufficient for another causal graph G\u2032, written G\u2264 G\u2032, when G\u2287 G\u2032.\nSaying that G is sufficient for G\u2032 intuitively means that G contains enough information to yield the same effect than G\u2032, but perhaps more than needed (this explains G \u2287 G\u2032). For this reason, we sometimes read G\u2264 G\u2032 as \u201cG\u2032 is stronger than G.\u201d\nSince graphs with the subgraph relation form a poset, the set of causal graphs also constitutes a poset \u3008CLb,\u2264\u3009 with a top element corresponding to the empty c-graph G /0 = \u3008 /0, /0\u3009. This stands for a kind of \u201cabsolute truth\u201d and is of interest for including rules or facts one does not want to label, that is, their effect will not be traced in the justifications.\nAny causal graph can be built up from labels (atomic causal graphs) using two basic operations: the product G\u2217G\u2032 def= (G\u222aG\u2032)\u2217 that stands for union of causal graphs or joint interaction, and the concatenation G \u00b7G\u2032 def= (G G\u2032)\u2217 that captures their sequential application. The reason for applying a closure is that the result of G\u222aG\u2032 and G G\u2032 does not need to be closed under transitivity. We can extend the product to any (possibly empty and possibly infinite) set of causal graphs S so that \u220fS def= ( \u22c3 G\u2208S G\n)\u2217. Example 2 (Ex. 1 continued) The cause for the body of l in P1 is the product of causes for drive and drunk, that is d \u2217 k formed with vertices {d,k} and edges {(d,d),(k,k)}. As a result, the explanation of the rule head, punish, is formed by the concatenation of its body cause d \u2217k with its label, that is (d \u2217k) \u00b7 l. In its turn, this becomes the cause for the body of e and so, we get the explanation (d \u2217 k) \u00b7 l \u00b7 e for atom prison represented as G1 in Figure 1(b). Similarly, G2 corresponds to r \u00b7m \u00b7 e.\nWhen writing these causal expressions, we assume that \u2018\u00b7\u2019 has higher priority than \u2018\u2217\u2019. Furthermore, we will usually omit \u2018\u00b7\u2019 when applied to consecutive labels, so that r \u00b7m \u00b7 e will be abbreviated as rme. It is easy to see that G \u2217G\u2032 = G\u2032 \u2217G while, in general, G \u00b7G\u2032 6= G\u2032 \u00b7G, that is, concatenation is not commutative. Another observation is that G \u00b7G\u2032 \u2264 G \u2217G\u2032, that is, concatenation is sufficient for the product, but the opposite does not hold in general. Moreover, in our running example, we can check that (d \u2217 k) \u00b7 l is equal to (d \u00b7 l) \u2217 (k \u00b7 l). In fact, application distributes over products and, as a result, we can identify any causal graph with the product of all its edges. To conclude this section, we note that the set of causal graphs CLb ordered by \u2264 forms a lower semilattice \u3008CLb,\u2217\u3009, where the product constitutes the infimum."}, {"heading": "3 Alternative causes", "text": "Having settled the case for individual causes, let us now proceed to represent situations in which several alternative and independent causes can be found for an atom p. The obvious possibility is just using a set of causal graphs for that purpose. However, we should additionally disregard causes for which a stronger alternative exists. For instance, as we saw before, cause rme is sufficient for explaining punish and therefore, it is also an alternative way to prove this atom, but redundant in the presence of the stronger cause rm. This suggests to choose sets of \u2264-maximal\ncausal graphs as \u2018truth values\u2019 for our multi-valued semantics. In principle, this is the central idea, although\u2264-maximal causal graphs incur some minor inconveniences in mathematical treatment. For instance, if we collect different alternative causes by just using the union of sets of maximal causal graphs, the elements in the result need not be maximal. Besides, the operations of product and concatenation are expected to extend to the sets adopted as causal values. To address these issues, a more solid representation is obtained resorting to ideals of causal graphs.\nGiven any poset \u3008A,\u2264\u3009, an ideal I is any set I \u2286 A satisfying1: if x \u2208 I and y \u2264 x then y \u2208 I. A compact way of representing an ideal I is by using its set of maximal elements S, since the rest of I contains all elements below them. The principal ideal of an individual element x \u2208 A is denoted as \u2193 x def= {y \u2208 A | y \u2264 x}. We extend this notion for any set of elements S so that \u2193 S def= \u22c3 {\u2193 x | x \u2208 S}= {y \u2208 A | y\u2264 x, for some x \u2208 S}. Thus, we will usually represent an ideal I as \u2193 S where S are the maximal 2 elements in I. In fact, maximal elements constitute the relevant information provided by the ideal, while keeping all other elements is convenient for simplicity of algebraic treament (but we do not assign a particular meaning to them).\nDefinition 3 (Causal Value) Given a set of labels Lb, a causal value is any ideal for the poset \u3008CLb,\u2264\u3009. We denote by VLb the set of causal values.\nProduct, concatenation and the \u2264-relation are easily extended to any pair U , U \u2032 of causal values respectively as: U \u2217U \u2032 def= U \u2229U \u2032 and U \u00b7U \u2032 def= \u2193{ G \u00b7G\u2032 \u2223\u2223 G \u2208U and G\u2032 \u2208U \u2032 } and U \u2264U \u2032 iff U \u2286 U \u2032. We also define addition as: U +U \u2032 def= U \u222aU \u2032 allowing to collect alternative causes. Using terminology and results from lattice theory in (Stumme 1997) we can prove the following.\nTheorem 1 VLb forms a free, completely distributive lattice with join + and meet \u2217 generated by the lower semilattice \u3008CLb,\u2217\u3009 with the injective homomorphism (or embedding) \u2193: CLb \u2212\u2192 VLb . Essentially, this theorem means that the mapping \u2193 from c-graph G to its principal ideal \u2193G is preserved for their respective products, \u2193(G1 \u2217G2) =\u2193G1 \u2217 \u2193G2, and ordering relations: G1 \u2264 G2 (among c-graphs) iff \u2193G1 \u2264 \u2193G2 (among causal values). Example 3 (Ex. 1 continued) The interpretation for punish has two alternative causes (d \u2217 k) \u00b7 l and rm that become the causal values \u2193(d \u2217 k) \u00b7 l and \u2193rm. The causal value for punish is then formed by their addition: \u2193(d \u2217 k) \u00b7 l + \u2193rm = \u2193(d \u2217 k) \u00b7 l \u222a \u2193rm = \u2193{ (d \u2217 k) \u00b7 l, rm } This ideal contains, among others, the cause rme, although it is not maximal due to rm:\n\u2193{ (d \u2217 k) \u00b7 l, rm } \u222a \u2193rme = \u2193{ (d \u2217 k) \u00b7 l, rm, rme} = \u2193{ (d \u2217 k) \u00b7 l, rm }\nThe term completely distributive lattice in Theorem 1 means that meet (resp. join) operation is defined for any infinite subset of VLb and distributes over infinite joins (resp. meets). There is also a bottom element, the empty ideal /0 (standing for \u201cfalsity\u201d) that will be denoted as 0, and a top element, the ideal formed by the empty causal graph \u2193G /0 = CLb (standing for \u201cabsolute truth\u201d) that is denoted as 1 from now on. To improve readability, we introduce the syntactic notion of causal terms, that allow representing the possible causal values without explicitly resorting to graphs or ideals.\n1 We use terminology from (Stumme 1997). In some texts this is known as semi-ideal or down-set to differentiate this definition from the stronger case in which ideals are applied on a (full) lattice rather than a semi-lattice. 2 Note that, in the case of causal graphs, the existence of maximal elements for the \u2264-relation amounts to the existence of minimal elements for the subgraph relation, and this holds since the latter is well-founded.\nDefinition 4 (Causal term) A (causal) term, t, over a set of labels Lb, is recursively defined as one of the following expressions t ::= l | \u220fS | \u2211S | t1 \u00b7t2 where l \u2208 Lb, t1, t2 are in their turn causal terms and S is a (possibly empty and possible infinite) set of causal terms. When S is finite and non-empty, S = {t1, . . . , tn} we write \u220fS simply as t1 \u2217 \u00b7 \u00b7 \u00b7 \u2217 tn and \u2211S as t1 + \u00b7 \u00b7 \u00b7+ tn.\nWe assume that \u2018\u2217\u2019 has higher priority than \u2018+\u2019. The causal value associated to a causal term is naturally obtained by the recursive application of its operators until we reach the level of labels, so that each label l in the term actually stands for the principal ideal \u2193 l. When S = /0, the union in S corresponds to the bottom causal value that is, \u2211 /0 = 0. Analogously, the intersection of elements in S = /0 corresponds to top causal value, i.e., \u220f /0 = 1.\nFrom now on, we will use causal terms as compact representations of causal values. Individual causes (i.e. causal graphs) correspond to terms without addition (note that this also excludes 0, the empty sum). Several interesting algebraic properties can be proved for causal values. In particular, Theorem 1 guarantees that they form a free completely distributive lattice with respect to \u2018\u2217\u2019 and \u2018+\u2019 satisfying the standard properties such as associativity, commutativity, idempotence, absorption or distributivity on both directions3. Besides, as usual, 0 (resp. 1) is the annihilator for \u2018\u2217\u2019 (resp. \u2018+\u2019) and the identity for \u2018+\u2019 (resp. \u2018\u2217\u2019). More significantly, the main properties for \u2018\u00b7\u2019 are shown in Figure 2."}, {"heading": "4 Positive programs and minimal models", "text": "Let us now reconsider logic programs and provide a semantics based on the causal values we have just defined. For the syntax, we recall standard LP definitions, just slightly extending it by introducing rule labels. A signature is a pair \u3008At,Lb\u3009 of sets that respectively represent a set of atoms (or propositions) and a set of labels. As usual, a literal is defined as an atom p (positive literal) or its default negation not p (negative literal). In this paper, we will concentrate on programs without disjunction in the head (leaving its treatment for future work).\nDefinition 5 (Causal logic program) Given a signature \u3008At,Lb\u3009, a (causal) logic program P is a (possible infinite) set of rules of the form: t : H\u2190 B1, . . . ,Bn, (1) where t \u2208 Lb\u222a{1}, H is an atom (the head of the rule) and B1, . . . ,Bn are literals (the body).\nFor any rule R of the form (1) we define label(R) def= t. We denote by head(R) def= H its head, and by body(R) def= {B1, . . . ,Bn} its body. When n = 0 we say that the rule is a fact and omit the symbol \u2018\u2190.\u2019 When t \u2208 Lb we say that the rule is labelled; otherwise t = 1 and we omit both t\n3 The term \u201cfree lattice\u201d in Theorem 1 means that any equivalence with \u2217 and + can be derived from these properties.\nand \u2018:\u2019. By these conventions, for instance, an unlabelled fact p is actually an abbreviation of (1 : p\u2190). A logic program P is positive if it contains no default negation. A program is uniquely labelled if no pair of labelled rules share the same label, and completely labelled if, additionally, all rules are labelled. For instance, P1 is completely labelled.\nGiven a signature \u3008At,Lb\u3009 a causal interpretation is a mapping I : At \u2212\u2192 VLb assigning a causal value to each atom. For any interpretations I, J, we say that I \u2264 J when I(p) \u2264 J(p) for each atom p \u2208 At. Hence, there is a \u2264-bottom (resp. \u2264-top) interpretation 0 (resp. 1) that stands for the interpretation mapping each atom p to 0 (resp. 1). The value assigned to a negative literal not p by an interpretation I, denoted as I(not p), is defined as: I(not p) def= 1 if I(p) = 0; and I(not p) def= 0 otherwise. An interpretation is two-valued if it maps all atoms to {0,1}. Furthermore, for any causal interpretation, its corresponding two-valued interpretation, written Icl , is defined so that for any atom p: Icl(p) def= 0 if I(p) = 0; and Icl(p) def= 1 otherwise.\nDefinition 6 (Causal model) Given a positive causal logic program P, a causal interpretation I is a causal model, in symbols I |= P, if and only if, for each rule R \u2208 P of the form (1), the following condition holds:(\nI(B1)\u2217 . . .\u2217 I(Bn) ) \u00b7 t \u2264 I(H)\nExample 4 (Ex. 1 continued) Take rule l from program P1 and let I be such that I(drive) = d and I(drunk) = k. Then I will be a model of l when (d\u2217k) \u00b7 l\u2264 I(punish). In particular, this holds when I(punish) = (d \u2217 k) \u00b7 l + r \u00b7m which was the value we expected for that atom. But it would also hold when, for instance, I(punish) = l +m or I(punish) = 1. The inequality in Definition 6 is important to accommodate possible additional facts such as (l : punish) or even (1 : punish) in the program.\nThe fact that any I(punish) greater than (d \u2217k) \u00b7 l+ r \u00b7m also becomes a model clearly points out the need for selecting minimal models. In fact, as it is the case for non-causal programs, positive programs have a\u2264-least model that can be computed by iterating an extension of the well-known direct consequences operator (van Emden and Kowalski 1976).\nDefinition 7 (Direct consequences) Given a positive logic program P over signature \u3008At,Lb\u3009, the operator of direct consequences is a function TP : I\u2212\u2192 I such that, for any causal interpretation I and any atom p \u2208 At:\nTP(I)(p) def= \u2211 { ( I(B1)\u2217 . . .\u2217 I(Bn) ) \u00b7 t | (t : p\u2190 B1, . . . ,Bn) \u2208 P } Theorem 2 Let P be a (possibly infinite) positive logic program with n causal rules. Then, (i) lfp(TP) is the least model of P, and (ii) lfp(TP) = TP \u2191 \u03c9 (0) = TP \u2191 n (0).\nThe proof of this theorem relies on an encoding of causal logic programs into Generalized Annotated Logic Programming (GAP) (Kifer and Subrahmanian 1992) and applying existing results for that general multi-valued LP framework. Theorem 2 just guarantees that the least fixpoint of TP is well-behaved, but does not explain the nature of the obtained causal values. We illustrate next that these values have a direct relation to the syntactic idea of proof in a positive program.\nDefinition 8 Given a positive program P, a proof \u03c0(p) of an atom p can be recursively defined as a derivation:\n\u03c0(p) def= \u03c0(B1) . . . \u03c0(Bn)\np (R),\nwhere R \u2208 P is a rule with head(R) = p and body(R) = {B1, . . . ,Bn}. When n = 0, the derivation antecedent \u03c0(B1) . . . \u03c0(Bn) is replaced by > (corresponding to the empty body).\nEach derivation in a proof is a particular application of Modus Ponens where, once the body (conjunction of literals B) of a rule R (p\u2190 B) has been proved, then the head p can be concluded.\nExample 5 (Ex. 1 continued) Program P1 is positive and, in fact, completely labelled, so we can identify each rule with its label. Atom prison can be derived in P1 using the two proofs on the left in Figure 3. These two proofs have a clear correspondence to causes (d \u2217 k) \u00b7 le and rme depicted in Figure 1(b). In fact, the least model I of P1 assigns causal value I(punish) = (d \u2217 k) \u00b7 le+ rme.\nLet P be a positive, completely labelled program. Given a proof \u03c0 , we define its graph G\u03c0 as follows. For each sub-derivation in \u03c0 of the form \u03c0(p) in Definition 8 we include an edge (li,m) where m is the label of rule R and li is the label of the top-level rule in \u03c0(Bi), for all i = 1, . . . ,n. The vertices in G\u03c0 exclusively collect the labels in those edges. We define graph(\u03c0) def= G\u2217\u03c0 . The two left proofs in Figure 3 are then obviously mapped to the causal graphs in Figure 1(b). If \u03a0 is a set of proofs, we define graph(\u03a0) def= {graph(\u03c0) | \u03c0 \u2208\u03a0}.\nA proof can be sometimes redundant, in the sense that some of its derivation steps could be removed. A natural way of defining a non-redundant proof is resorting to its associated graph. We say that a proof \u03c0(p) of an atom p in a positive, completely labelled program P is redundant if there exists another proof of p, \u03c0 \u2032(p), such that graph(\u03c0(p))\u2264 graph(\u03c0 \u2032(p)), in other words, we can build another proof \u03c0 \u2032 with a smaller associated graph.\nExample 6 Suppose that we introduce an atom sentence which acts as a synonym for punish. Furthermore, assume law m mentions sentence as its head now, instead of punish. Hence, let P2 be program:\nl : punish\u2190 drive,drunk d : drive n : punish\u2190 sentence m : sentence\u2190 resist k : drunk s : sentence\u2190 punish e : prison\u2190 punish r : resist\nThen, the rightmost proof shown in Figure 3 together with its associated graph (d \u2217 k) \u00b7 lsne is redundant, since the (still valid) leftmost proof in Figure 3 for prison has an associated stronger cause (or smaller graph) (d \u2217 k) \u00b7 le. Considering the positive loop formed by n and s, one may wonder why it does not spoil the computation of TP2 to iterate forever (adding more and more\nconcatenations of n and s). The reason is that, at a given point, subsequent iterations yield redundant graphs subsumed by previous steps. In particular, the iteration of TP2 yields the steps:\ni drive drunk resist sentence punish prison\n1 d k r 0 0 0 2 d k r rm (d \u2217 k) \u00b7 l 0 3 d k r rm+(d \u2217 k) \u00b7 ls (d \u2217 k) \u00b7 l + rmn (d \u2217 k) \u00b7 le 4 d k r rm+(d \u2217 k) \u00b7 ls (d \u2217 k) \u00b7 l + rmn ((d \u2217 k) \u00b7 l + rmn) \u00b7 e\nreaching a fixpoint at step 4. The value for sentence at step 4 would actually be the sum of rm (derived from resist) with the value of punish in the previous step, (d \u2217k) \u00b7 l+ rmn followed by s. This corresponds to:\nrm+((d \u2217 k) \u00b7 l + rmn\ufe38 \ufe37\ufe37 \ufe38 punish ) \u00b7 s = rm+(d \u2217 k) \u00b7 ls+ rmns distributivity = rm+ rmns+(d \u2217 k) \u00b7 ls commutativity = rm+ rm \u00b7ns+(d \u2217 k) \u00b7 ls associativity = rm+1 \u00b7 rm \u00b7ns+(d \u2217 k) \u00b7 ls identity = rm+(d \u2217 k) \u00b7 ls absorption for \u2018+\u2019 and \u2018\u00b7\u2019\nThat is, iterating the loop rmns is redundant since a stronger cause rm was obtained before.\nTheorem 3 Let P be a positive, completely labelled program, and \u03a0p the set of non-redundant proofs of some atom p with respect to P. If I denotes the least model of P, then:\nG \u2208 graph(\u03a0p) iff G is a maximal causal graph in I(p)\nNote the importance of this result: it reveals that the information we obtain by a purely semantic treatment of causal values (computing the least model by algebraic operations) has a one-to-one correspondence to syntactic proofs obtained by modus ponens that are further guaranteed to be non-redundant (they do not contain unnecessary steps). Completely labelled programs are interesting for establishing the correspondence in the theorem above, but there are several scenarios in which one may be interested in disregarding the effect of rules in a program or in identifying a group of rules under the same label.\nExample 7 Let P3 be the following variation of P2:\nz : sentence\u2190 drive,drunk d : drive punish\u2190 sentence z : punish\u2190 resist k : drunk sentence\u2190 punish e : prison\u2190 punish r : resist\nwhere l and m in P2 are now just two cases of a common law z, and punish and sentence depend on each other through unlabelled rules.\nRemoving the labels in the positive cycle between sentence and punish captures the idea that, since they are synonyms, whenever we have a cause for sentence, it immediately becomes a cause for punish and vice versa. By iterating the TP operator, it is not difficult to see that the least causal model I3 makes the assignments I3(sentence) = I3(punish) = (d \u2217 k) \u00b7 z+ rz (that is sentence and punish are equivalent) and I3(prison) = (d \u2217 k) \u00b7 ze+ rze. This result could also be computed from the least model I2 for P2 by replacing l and m by z and \u201cremoving\u201d n and s (that\nis, replacing them by 1). This is, in fact, a general property we formalise as follows. Given two causal terms t,u and a label l, we define t[l 7\u2192 u] as the result of replacing label l in t by term u.\nTheorem 4 Let P be a positive causal logic program and P\u2032 be the result of replacing a label l in P by some u, where u is any label or 1. Furthermore, let I and I\u2032 be the least models of P and P\u2032, respectively. Then, I\u2032(p) = I(p)[l 7\u2192 u] for any atom p.\nIn particular, in our example, I3(p) = I2(p)[l 7\u2192 z][m 7\u2192 z][n 7\u2192 1][s 7\u2192 1], for any atom p. If we remove all labels in a program, we eventually get a standard, unlabelled program. Obviously, its least model will be two-valued, since removing all labels in causal terms, eventually collapses all of them to {0,1}. As a result, we can easily establish the following correspondence.\nTheorem 5 Let P be a causal positive logic program and P\u2032 its unlabelled version. Furthermore, let I be the least causal model of P and I\u2032 the least classical model of P\u2032. Then I\u2032 = Icl ."}, {"heading": "5 Default negation", "text": "To introduce default negation, let us consider the following variation of our running example.\nExample 8 Assume now that law e is a default and that there may be exceptional cases in which punishment is not effective. In particular, some of such exceptions are a pardon, that the punishment was revoked, or that the person has diplomatic immunity. A possible program P4 encoding this variant of the scenario is:\nl : punish\u2190 drive,drunk d : drive abnormal\u2190 pardon m : punish\u2190 resist k : drunk abnormal\u2190 revoke e : prison\u2190 punish,not abnormal r : resist abnormal\u2190 diplomat\nThis program has a unique stable model which still keeps prison true, since no proof for abnormal could be obtained, i.e. no exception occurred.\nFrom a causal perspective, saying that the lack of an exception is part of a cause (e.g., for imprisonment) is rather counterintuitive. It is not the case that we go to prison because of not receiving a pardon, not having a punishment revocation, not being a diplomat, or whatever possible exception that might be added in the future4. Instead, as nothing violated default e, the justifications for prison should be those shown in Figure 1(a). In this way, falsity becomes the default situation that is broken when a cause is found5. This interpretation carries over to negative literals, so that the presence of not p in a rule body does not propagate causal information, but instead is a check for the absence of an exception. To capture this behaviour, we proceed to extend the traditional program reduct (Gelfond and Lifschitz 1988) to causal logic programs.\n4 A case of the well-known qualification problem (McCarthy 1977), i.e., the impossibility of listing all the possible conditions that prevent an action to cause a given effect. Appendix B (available online) contains a more elaborated example showing how the qualification problem may affect causal explanations when inertia is involved. 5 The paper (Hitchcock and Knobe 2009) contains an extended discussion with several examples showing how people ordinarily understand causes as deviations from a norm.\nDefinition 9 (Program reduct) The reduct of program P with respect to causal interpretation I, in symbols PI , is the result of:\n1. removing from P all rules R, s.t. I(B) 6= 0 for some negative literal B \u2208 body(R); 2. removing all negative literals from the remaining rules of P.\nAn interpretation I is a causal stable model of program P iff I is the least causal model of PI .\nExample 9 (Ex. 8 continued) Suppose that we add atoms (p : pardon) and (d : diplomat) to program P4. The only stable model I of this extended program makes I(prison) = 0 and I(abnormal) = p+d as expected.\nTheorem 6 (Correspondence to non-causal stable models) Let P be a causal logic program and P\u2032 its unlabelled version. Then:\n1. If I is a causal stable model of P, then Icl is a stable model of P\u2032. 2. If I\u2032 is a stable model of P\u2032 then there is a unique causal stable model I of P s.t. I\u2032 = Icl .\nThis theorem also shows a possible method for computing causal stable models of a program P. We may first run a standard ASP solver on the unlabelled version of P to obtain a stable model I\u2032. This stable model I\u2032 has a corresponding causal stable model I, such that I\u2032 = Icl and both interpretations coincide in their assignment of 0\u2019s. Therefore, PI = PI \u2032 and we can use the latter to iterate the TP operator and obtain the least causal model of this reduct, which will mandatorily be a causal stable model due to Theorem 6."}, {"heading": "6 Related Work", "text": "Cabalar (2011) already introduced the main motivations of our work, but used ad hoc operations on proof trees without resorting to algebraic structures. A preliminary version (Cabalar and Fandinno 2013) of the current approach relied on chains of labels but was actually weaker, missing basic properties we can derive now from causal graphs.\nThere exists a vast literature on causal reasoning in Artificial Intelligence. Papers on reasoning about actions and change (Lin 1995; McCain and Turner 1997; Thielscher 1997) have been traditionally focused on using causal inference to solve representational problems (mostly, the frame, ramification and qualification problems) without paying much attention to the derivation of cause-effect relations. Perhaps the most established AI approach for causality is relying on causal networks (Pearl 2000; Halpern and Pearl 2005; Halpern 2008). In this approach, it is possible to conclude cause-effect relations like \u201cA has caused B\u201d from the behaviour of structural equations by applying the counterfactual interpretation from Hume (1748): \u201chad A not happened, B would not have happened.\u201d As discussed by Hall (2004), the counterfactual-based definition of causation corresponds to recognising some kind of dependence relation in the behaviour of a non-causal system description. As opposed to this, Hall considers a different (and incompatible) definition where causes must be connected to their effects via sequences of causal intermediates, something that is closer to our explanations in terms of causal graphs.\nApart from the different AI approaches and attitudes towards causality, from the technical point of view, the current approach can be classified as a labelled deductive system (Broda et al. 2004). In particular, the work that has had a clearest and most influential relation to the current proposal is the Logic of Proofs (LP) by Arte\u0308mov (2001). We have borrowed from that formalism part of the notation for our causal terms and rule labellings and the fundamental idea of keeping track of justifications by considering rule applications.\nFocusing on LP, our work obviously relates to explanations as provided by approaches to debugging in ASP (Gebser et al. 2008; Pontelli et al. 2009; Schulz et al. 2013; Dama\u0301sio et al. 2013). Pereira et al. (1991) and Denecker and De Schreye (1993) also define different semantics in terms of justifications, but do not provide calculi for them. In these works, explanations usually contain all possible ways to derive an atom or to prevent its derivation, including paths through negation. This differs from a KR orientation where only the cause-effect relations that \u201cbreak the norm\u201d should be considered relevant. This point of view is also shared, e.g., by the counterfactualbased causal LP approach (Vennekens 2011). Fages (1991) characterised stable models in terms of loop-free justifications expressed as partial order relations among atoms in positive bodies. We conjecture that the causal values obtained in our semantics formally capture Fages\u2019 justifications. A more far-fetched resemblance exists to work on the analysis of tabled Prolog computations. There, the goal is to identify potential causes for non-termination of program evaluations, which can be achieved examining so-called forest logs, i.e., a log of table operations for a computation. By adding unique labels for rules (with the original intention to disambiguate analysis results, cf. Liang and Kifer (2013), however not as an explicit means for representing knowledge), in principle a forest log implicitly contains the information necessary to read of the causal model of a completely labelled positive causal logic program."}, {"heading": "7 Conclusions", "text": "In this paper we have provided a multi-valued semantics for normal logic programs whose truth values form a lattice of causal graphs. A causal graph is nothing else but a graph of rule labels that reflects some order of rule applications. In this way, a model assigns to each true atom a value that contains justifications for its derivation from the existing rules. We have further provided three basic operations on the lattice: an addition, that stands for alternative, independent justifications; a product, that represents joint interaction of causes; and a concatenation that reflects rule application. We have shown that, for positive programs, there exists a least model that coincides with the least fixpoint of a direct consequences operator, analogous to van Emden and Kowalski (1976). With this, we are able to prove a direct correspondence between the semantic values we obtain and the syntactic idea of proof. These results have been extrapolated to stable models of programs with default negation, understanding the latter as \u201cabsence of cause.\u201d Although, for space reasons, we have not dealt with programs with variables, their semantics is obtained from their (possibly infinite) grounding, as usual.\nSeveral topics remain open for future study. An interesting issue is to replace the syntactic definition by a reduct in favour of a logical treatment of default negation, as has been done for (noncausal) stable models and their characterisation in terms of Equilibrium Logic (Pearce 2006). Regarding the representation of causal information, a natural next step would be the consideration of syntactic operators for more specific knowledge like the influence of a particular event or label in a conclusion, expressing necessary or sufficient causes, or even dealing with counterfactuals. Further ongoing work is focused on implementation, complexity assessment, and an extension to disjunctive programs, respectively the introduction of strong negation. Exploring related areas of KR and reasoning, such as, e.g., Paraconsistent Reasoning and Belief Revision, seems promising with respect to extending the range of problems to which our approach may effectively be applied.\nAcknowledgements We are thankful to David Pearce, Manuel Ojeda, Jesu\u0301s Medina, Carlos Damasio and Joost Vennekens for their suggestions and comments on earlier versions of this work. We also thank the anonymous reviewers for their help to improve the paper."}, {"heading": "Appendix A. Auxiliary figures", "text": ""}, {"heading": "Appendix B. An example of causal action theory", "text": "In this section we consider a more elaborated example from Pearl (2000).\nExample 10 Consider the circuit in Figure 5 with two switches, a and b, and a lamp l. Note that a is the main switch, while b only affects the lamp when a is up. Additionally, when the light is on, we want to track which wire section, v or w, is conducting current to the lamp.\nAs commented by Pearl (2000), the interesting feature of this circuit is that, seen from outside as a black box, it behaves exactly as a pair of independent, parallel switches, so it is impossible to detect the causal dependence between a and b by a mere observation of performed actions and their effects on the lamp. Figure 5 also includes a possible representation for this scenario; let us call it program P5. It uses a pair of fluents up(X) and down(X) for the position of switch X , as well as on and off to represent the state of the lamp. Fluents up(X) and down(X) (respectively, on and off) can be seen as the strong negation of each other, although we do not use an operator for that purpose6. Action m(X ,D) stands for \u201cmove switch X in direction D \u2208 {u,d}\u201d (up and down, respectively). Actions between state t and t +1 are located in the resulting state. Finally, we have also labelled inertia laws (by i) to help keeping track of fluent justifications inherited by persistence.\nSuppose we perform the following sequence of actions: we first move down both switches, next switch b is moved first up and then down, and finally we move up switch a. Assume also that each action occurrence is labelled with the action name so that, for instance, moving b up in Situation 1 corresponds to the program fact m(b,u)1 : m(b,u)1. The table in Figure 6 shows the resulting temporal projection. Note how the lamp turns on in Situation 1 but only because of v, that is, moving a down. Movements of b at 2 and 3 do not affect the lamp, and its causal explanation (down(a)) is maintained by inertia. In Situation 4, the lamp is still on but the reason has changed. The explanation this time is that we had closed down b at 3 (and this persisted by inertia) while we have just moved a up, firing rule w. This example also illustrates why we are not interested in providing negative justifications through default negation. This would mean to explicitly include non-occurrences of actions that might\n6 Notice how strong negation would point out the cause(s) for a boolean fluent to take value false, whereas default negation represents the absence of cause.\notherwise have violated inertia. For instance, the explanation for on2 would include the fact that we did not perform m(a,u)2. Including this information for one transition is perhaps not so cumbersome, but suppose that, from 2 we executed a high number of transitions without performing any action. The explanation for on3 would additionally collect that we did not perform m(a,u)3 either. The explanation for on4 should also collect the negation of further possibilities: moving a up at 4; three movements of a up, down and up; moving b at 3 and both switches at 4; moving both switches at 3 and b at 4; etc. It is easy to see that negative explanations grow exponentially: at step t we would get the negation of all possible plans for making ont false, while indeed, nothing has actually happened (everything persisted by inertia).\nExample 11 (The gear wheels) Consider a gear mechanism with a pair of wheels, each one powered by a separate motor. Each motor has a switch to start and stop it. There is another switch to connect or disconnect the wheels. (McCain 1997).\nThis example can be captured by the logic program P6 formed by the following causal rules:\nmotor(W )t \u2190 start(W )t \u00acmotor(W )t \u2190 stop(W )t\nturn(W )t \u2190 motor(W )t coupledt \u2190 couplet \u00accoupledt \u2190 uncouplet\nturn(1)t \u2190 turn(2)t , coupledt turn(2)t \u2190 turn(1)t , coupledt \u00acturn(1)t \u2190 \u00acturn(2)t , coupledt \u00acturn(2)t \u2190 \u00acturn(1)t , coupledt\nplus the fhe following inertia axioms:\nmotor(W )t+1\u2190 motor(W )t , not \u00acmotor(W )t+1 \u00acmotor(W )t+1\u2190 \u00acmotor(W )t , not motor(W )t+1\nturn(W )t+1 \u2190 turn(W )t , not \u00acturn(W )t+1 (2) \u00acturn(W )t+1 \u2190 \u00acturn(W )t , not turn(W )t+1\ncoupledt+1 \u2190 coupledt , not \u00accoupledt+1 \u00accoupledt+1 \u2190 \u00accoupledt , not coupledt+1\nSuppose that initially both motors are off an the wheels are immobile. This is reflected by the following set of facts { \u00acmotor(1)0, \u00acmotor(2)0, \u00acturn(1)0, \u00acturn(2)0, \u00accuopled0 } . Then\nwe perform the following actions { s(1)3 : start(1)3, c6 : couple6, u9 : uncouple9 }\n. Figure 7(a) shows the causal values associated with each fluent in each time interval. Note that we only have labelled the actions avoiding tracing rule application for clearity sake. This example illustrates the behaviour of causal logic programs in the presence of causal cycles. When no action is performed the value of a fluent is just propagate by inertia.\nAn iteresting variation of this example is incorporating some mechanic device to stop the wheels (Van Belleghem et al. 1998; Lin and Soutchanski 2011). This can be achived by adding the following set of rules:\nbreaked(W )t \u2190 break(W )t \u00acbreaked(W )t \u2190 unbreak(W )t \u00acturn(W )t \u2190 breaked(W )t\nbreaked(W )t+1\u2190 breaked(W )t , not \u00acbreaked(W )t+1 \u00acbreaked(W )t+1\u2190 \u00acbreaked(W )t , not breaked(W )t+1\nIf the second wheel is breaked at s9 we will get insted that turn(2)9 is false an the cause of \u00acturn(2)t in any future situation is break(2)9. Another interesiting situations is when we break the second wheel in the situation 5. In such case we have an incosistence. On the one hand the cause of turn(1)6 and turn(2)6 are respectively s1 and s(1)3 \u2217 c(6). On the other hand the cause of \u00acturn(1)6 and \u00acturn(2)6 are respectively break(2)5 \u2217 c(6) and break(2)5. Note that, causal values not only points the existence of an incosistence but also can be explaoited to explain why. In particual, in this case, the motor forces the wheels to spin whereas the break opposed to it.\nAnother iteresting variation of this example is assuming that wheels are breaked by friction as soon as the motriz force over them is absent. This can be achived by just replacing the inertia axiom (2) for turn by the following causal rule:\nf (W )t : \u00acturn(W )t+1\u2190 not \u00acturn(W )t , not turn(W )t+1\nFigure 7(b) shows the variation in the causal value of turn(2). Note that \u2217 means that the value is the same as Figure 7(a).\nAppendix C. Example with infinite rules\nExample 12 Consider the infinite program P7 given by the ground instances of the set of rules:\nl(s(X)) : nat(s(X))\u2190 nat(X) l(z) : nat(z)\ndefining the natural numbers with a Peano-like representation, where z stands for \u201czero.\u201d For each natural number n, the causal value obtained for nat(sn(z)) in the least model of the program is l(z) \u00b7 l(s(z)) . . . l(sn(z)). Read from right to left, this value can be seen as the computation steps performed by a top-down Prolog interpreter when solving the query nat(sn(z)). As a further elaboration, assume that we want to check that at least some natural number exists. For that purpose, we add the following rule to the previous program:\nsome\u2190 nat(X) (3)\nThe interesting feature of this example is that atom some collects an infinite number of causes from all atoms nat(sn(z)) with n ranging among all the natural numbers. That is, the value for some is I(some) = \u03b10 +\u03b11 +\u03b12 + . . .+\u03b1n + . . . where \u03b1n def= l(z) \u00b7 l(s(z)) \u00b7 . . . \u00b7 l(sn(z)). However, it is easy to see that the fact nat(z) labelled with l(z) is not only sufficient to prove the existence of some natural number, but, due to the recursive definition of the natural numbers, it is also necessary \u2013 note how all the proofs \u03b1i actually begin with an application of l(z).\nThis fact is captured in our semantic by the algebraic equivalences showed in Fig 2. From associativity and identity of \u2018\u00b7\u2019, the following equivalence holds:\n\u03b1n = 1 \u00b7 l(z) \u00b7 \u03b2n with \u03b2i def= l(s(z)) \u00b7 . . . \u00b7 l(si(z))\nfor any n\u2265 1. Furthermore, from absorption of \u2018\u00b7\u2019 w.r.t the addition, it also holds that\n\u03b10 +\u03b1n = l(z) + 1 \u00b7 l(z) \u00b7 \u03b2n = l(z)\nAs a consequence, the previous infinite sum just collapses to I(some) = l(z), reflecting the fact that, to prove the existence of a natural number, only the fact labelled as l(z) is relevant.\nSuppose now that, rather than defining natural numbers in a recursive way, we define them by\ndirectly asserting an infinite set of facts as follows:\nl(sn(z)) : nat(sn(z)) (4)\nfor any n\u2265 0, where s0(z) stands for z. In this variant, the causal value obtained for nat(sn(z)) is simply l(sn(z)), so that the dependence we had before on lower natural numbers does not exist any more. Adding rule (3) to the set of facts (4) allows us concluding I(some) = l(z)+ l(s(z))+ l(s2(z))+ . . .+ l(sn(z))+ . . . and this infinite sum cannot be collapsed into any finite term. This reflects that we have now infinite independent ways to prove that some natural number exists.\nThis last elaboration can be more elegantly captured by replacing the infinite set of facts (4) by an auxiliary recursive predicate aux defined as follows:\naux(s(X))\u2190 aux(X) aux(z)\nl(X) : nat(X)\u2190 aux(X)\nSince rules for aux are unlabelled, the value of aux(sn(z)) in the least model is I(aux(sn(z))= 1 so the effect of this predicate is somehow \u201ctransparent\u201d regarding causal justifications. As a result, the value of nat(sn(z)) is just l(sn(z)) as before."}, {"heading": "Appendix D. Proofs", "text": "In order to improve clarity, for any causal graph G = \u3008V,E\u3009, vertices v1 and v2 and edge (v1,v2) we respectively use the notation v1 \u2208 G and (v1,v2) \u2208 G instead of v1 \u2208V and (v1,v2) \u2208 E."}, {"heading": "7.1 Causes as graphs", "text": "Proposition 1 (Monotonicity) Let G,G\u2032 be a pair of causal graph with G\u2264 G\u2032. Then, for any causal graph H:\nG\u2217H \u2264 G\u2032 \u2217H, G \u00b7H \u2264 G\u2032 \u00b7H and H \u00b7G\u2264 H \u00b7G\u2032\nProof . First we will show that G\u2217H \u2264G\u2032 \u2217H. Suppose that E(G\u2217H) 6\u2287 E(G\u2032 \u2217H) and let (l1, l2) be an edge in E(G\u2032 \u2217H) but not in E(G\u2217H \u2032), i.e. (l1, l2) \u2208 E(G\u2032 \u2217H)\\E(G\u2217H \u2032).\nThus, since by product definition E(G\u2032\u2217H) =E(G\u2032)\u222aE(H), it follows that either (l1, l2)\u2208E(G\u2032) or (l1, l2) \u2208 E(H). It is clear that if (l1, l2) \u2208 E(H) then (l1, l2) \u2208 E(G \u2217H) = E(G)\u222a E(H). Furthermore, since G\u2264 G\u2032 it follows that E(G)\u2287 E(G\u2032), if (l1, l2) \u2208 E(G\u2032) then (l1, l2) \u2208 E(G) and consequently (l1, l2) \u2208 E(G \u2217H) = E(G)\u222aE(H). That is E(G \u2217H) \u2287 E(G\u2032 \u2217H) and then G \u2217H \u2264 G\u2032 \u2217H. Note that V (G \u2217H) \u2287 V (G\u2032 \u2217H) follows directly from E(G \u2217H) \u2287 E(G\u2032 \u2217H) and the fact that every vertex has and edge to itself.\nTo show that G \u00b7H \u2264 G\u2032 \u00b7H (the case for H \u00b7G\u2264 H \u00b7G\u2032 is analogous) we have has to show that, in addition to the previous, for every edge (lG, lH) \u2208 E(G\u2032 \u00b7H) with lG \u2208V (G\u2032) and lH \u2208V (H) it holds that (lG, lH) \u2208 E(G \u00b7H). Simply note that since G\u2264 G\u2032 it follows V (G)\u2287V (G)\u2032 and then lG \u2208V (G). Consequently (lG, lH) \u2208 E(G \u00b7H).\nProposition 2 (Application associativity for causal graphs) Let G1, G2 and G3 be three causal graphs. Then G1 \u00b7 (G2 \u00b7G3) = (G1 \u00b7G2) \u00b7G3.\nProof . By definition, it follows that V ( (G1 \u00b7G2) \u00b7G3 ) = (V (G1)\u222aV (G2))\u222aV (G3) = V (G1)\u222a (V (G2)\u222aV (G3)) (5)\nE ( (G1 \u00b7G2) \u00b7G3 ) = ( E(G1)\u222aE(G2)\u222aE12 ) \u222aE(G3)\u222aE12,3 = E(G1)\u222aE(G2)\u222aE(G3)\u222aE12\u222aE12,3 (6) E ( G1 \u00b7 (G2 \u00b7G3) ) = E(G1)\u222a ( E(G2)\u222aE(G3)\u222aE23 ) \u222aE1,23\n= E(G1)\u222aE(G2)\u222aE(G3)\u222aE1,23\u222aE23 (7)\nwhere\nE12 def= { (v1,v2) \u2223\u2223 v1 \u2208V1 and v2 \u2208V2 } E12,3 def= { (v12,v3) \u2223\u2223 v12 \u2208V1\u222aV2 and v3 \u2208V3 } E23 def= { (v2,v3) \u2223\u2223 v2 \u2208V2 and v3 \u2208V3 } E1,23 def= { (v1,v23) \u2223\u2223 v1 \u2208V1 and v23 \u2208V2\u222aV3 }\nFrom (5) and (7), it follows that\n(G1 \u00b7G2) \u00b7G3 = G1 \u00b7 (G2 \u00b7G3) if and only if E12\u222aE12,3 = E1,23\u222aE23 if and only if E12,3 \u2286 E1,23\u222aE23 and E1,23 \u2286 E12\u222aE12,3\nNote that E12 \u2286 E1,23 and E23 \u2286 E12,3. Then, we will show that E12,3 \u2286 E1,23 \u222aE23. Suppose there is an edge (v12,v3) \u2208 E12,3 such that (v12,v3) /\u2208 E23 and (v12,v3) /\u2208 E1,23. Since (v12,v3), v12 \u2208 V1 \u222aV2 and v3 \u2208 V3. If v12 \u2208 V1, then (v12,v3) \u2208 E12,3 which is a contradiction, and if,\notherwise, v12 \u2208V2, then (v12,v3)\u2208E23 which is also a contradiction. The case E1,23\u2286E12\u222aE12,3 is symmetric.\nProposition 3 For every causal graph G = \u3008V,E\u3009 it holds that G = \u220f { l \u00b7 l\u2032 \u2223\u2223 (l, l\u2032) \u2208 E }. Proof . Let G\u2032 be a causal graphb s.t. G\u2032 = \u220f { l \u00b7 l\u2032\n\u2223\u2223 (l, l\u2032) \u2208 E }. Then for every edge (l, l\u2032) \u2208 E(G) it holds that (l, l\u2032)\u2208 E(l \u00b7 l\u2032) and then (l, l\u2032)\u2208 E(G\u2032) = \u22c3 { E(l \u00b7 l\u2032)\n\u2223\u2223 (l, l\u2032)\u2208 E }, i.e. E(G)\u2286 E(G\u2032). Furthermore for every (l, l\u2032) \u2208 E(G\u2032) there is li \u00b7 l j s.t. (l, l\u2032) \u2208 li \u00b7 l j and (li, l j) \u2208 E(G). Then, since E(li \u00b7 l j) = {(li, l j)} it follows that (l, l\u2032) \u2208 E(G), i.e. E(G) \u2287 E(G\u2032). Consequently G = G\u2032 = \u220f { l \u00b7 l\u2032\n\u2223\u2223 (l, l\u2032) \u2208 E }. Proposition 4 (Infimum) Any set of causal graphs S has a \u2264-infimum given by their product \u220fS.\nProof . By definition \u220fS is the causal graph whose vertices and edges are respectively the sets V (\u220fS) = \u22c3{ V (G) \u2223\u2223 G \u2208 S } and E(\u220fS) = \u22c3{ E(G) \u2223\u2223 G \u2208 S }. It is easy to see that \u220fS is the supremum of the subgraph relation, so that, since for every pair of causal graphs G \u2264 G\u2032 iff G\u2287 G\u2032, it follows that infimum of S w.r.t. \u2264.\nProposition 5 (Application distributivity w.r.t. products over causal graphs) For every pair of sets of causal graphs S and S\u2032, it holds that(\n\u220fS ) \u00b7 ( \u220fS\u2032 ) = \u220f { G \u00b7G\u2032 \u2223\u2223 G \u2208 S and G\u2032 \u2208 S\u2032 }. Proof . For readability sake, we define two causal graphs\nGR def= ( \u220fS ) \u00b7 ( \u220fS\u2032 ) and GL def= \u220f { G \u00b7G\u2032 \u2223\u2223 G \u2208 S and G\u2032 \u2208 S\u2032 }\nand we assume that both S and S\u2032 are not empty sets. Note that \u220f /0 = CLb = \u220f{G /0}. Then, by product definition, it follows that\nE(GL) = (\u22c3{ E(G) \u2223\u2223 G \u2208 S }\u222a\u22c3{ E(G\u2032) \u2223\u2223 G \u2208 S\u2032 }\u222aEL)\u2217\nE(GR) = (\u22c3{ E(G)\u222aE(G\u2032)\u222aER(G,G\u2032) \u2223\u2223 G \u2208 S and G\u2032 \u2208 S\u2032 })\u2217\nwhere EL = { (l, l\u2032) \u2223\u2223 l \u2208\u22c3{ V (G) \u2223\u2223 G \u2208 S } and l\u2032 \u2208\u22c3{ V (G\u2032) \u2223\u2223 G\u2032 \u2208 S\u2032 } } ER(G,G\u2032) = { (l, l\u2032)\n\u2223\u2223 l \u2208V (G) and l\u2032 \u2208V (G\u2032) } Furthermore let ER = \u22c3 { ER(G,G\u2032)\n\u2223\u2223 G \u2208 S and G\u2032 \u2208 S\u2032 }. For every edge (l, l\u2032) \u2208 EL there are a pair of c-graphs G\u2208 S and G\u2032 \u2208 S\u2032 s.t. l \u2208V (G) and l\u2032 \u2208V (G\u2032) and then (l, l\u2032)\u2208 ER(G,G\u2032) and so (l, l\u2032) \u2208 ER. Moreover, for every edge (l, l\u2032) \u2208 ER there are a pair of c-graphs G \u2208 S and G\u2032 \u2208 S\u2032 s.t. (l, l\u2032) \u2208 ER(G,G\u2032) with l \u2208V (G) and l\u2032 \u2208V (G)\u2032. So that (l, l\u2032) \u2208 EL. That is EL = ER. Then\nE(GR) = (\u22c3{ E(G) \u2223\u2223 G \u2208 S }\u222a\u22c3{ E(G\u2032) \u2223\u2223 G\u2032 \u2208 S\u2032 }\u222aER)\u2217\n= ( E(GL)\\EL\u222aER )\u2217 = ( E(GL) )\u2217 = E(GL)\nConsequently GL = GR.\nProposition 6 (Transitive application distributivity w.r.t. products over causal graphs) For any causal graphs G, G\u2032 6= /0 and G\u2032\u2032, it holds that\nG \u00b7G\u2032 \u00b7G\u2032\u2032 = G \u00b7G\u2032 \u2217G\u2032 \u00b7G\u2032\u2032\nProof . It is clear that G \u00b7G\u2032 \u00b7G\u2032\u2032 \u2264 G \u00b7G\u2032 and G \u00b7G\u2032 \u00b7G\u2032\u2032 \u2264 G\u2032 \u00b7G\u2032\u2032 and then G \u00b7G\u2032 \u00b7G\u2032\u2032 \u2264 G \u00b7 G\u2032 \u2217G\u2032 \u00b7G\u2032\u2032. Let G1, G2, GL and GR be respectively G1 = G \u00b7G\u2032, G2 = G\u2032 \u00b7G\u2032\u2032, GL = G1 \u00b7G\u2032\u2032, and GR = G1 \u2217G2. Suppose that GL < GR, i.e. GL \u2283 GR and there is an edge (v1,v2) \u2208 GL but (v1,v2) /\u2208 GR. Then G1 \u2286 GR and G\u2032\u2032 \u2286 G2 \u2286 GR and one of the following conditions holds:\n1. (v1,v2) \u2208 G1 \u2286 GR or (v1,v2) \u2208 G\u2032\u2032 \u2286 GR which is a contradiction with (v1,v2) /\u2208 GR. 2. v1 \u2208 G1 and v2 \u2208 G\u2032\u2032, i.e. v1 \u2208 G and v2 \u2208 G\u2032\u2032 or v1 \u2208 G\u2032 and v2 \u2208 G\u2032\u2032. Furthermore, if the\nlast it is clear that (v1,v2) \u2208G\u2032 \u00b7G\u2032\u2032 = G2 \u2286GR which is a contradiction with (v1,v2) /\u2208GR.\nThus it must be that v1 \u2208 G and v2 \u2208 G\u2032\u2032. But then, since G\u2032 6= /0 there is some v\u2032 \u2208 G\u2032 and consequently there are edges (v1,v\u2032) \u2208G \u00b7G\u2032 = G1 \u2286GR and (v\u2032,v2) \u2208G\u2032 \u00b7G\u2032\u2032 = G2 \u2286GR. Since GR is closed transitively, (v1,v2) \u2208GR which is a contradiction with the assumption that (v1,v2) /\u2208 GR. That is, GL = G \u00b7G\u2032 \u00b7G\u2032\u2032 = G \u00b7G\u2032 \u2217G\u2032 \u00b7G\u2032\u2032 = GR.\nProposition 7 (Application idempotence w.r.t. singleton causal graphs) For any causal graph G whose only edge is (l, l), G \u00b7G = G. Proof . By definition G \u00b7G = G\u222aG\u222a{ (v1,v2) \u2223\u2223 v1 \u2208 G and v2 \u2208 G }. Since the only vertex of G is l, it follows that G \u00b7G = G\u222a{(l, l)}= G.\nProposition 8 (Application absorption over causal grapsh) Let G1, G2 and G3 be three causal graphs. Then G1 \u00b7G2 \u00b7G3 = G2 \u2217G1 \u00b7G2 \u00b7G3.\nProof . By definition, it is clear that G1 \u00b7G2 \u00b7G3 \u2287 G2 and then\nG2 \u2217G1 \u00b7G2 \u00b7G3 = (G2\u222aG1 \u00b7G2 \u00b7G3)\u2217 = (G1 \u00b7G2 \u00b7G3)\u2217 = G1 \u00b7G2 \u00b7G3\nProposition 9 (Absorption Extended) Let a and b be elements of an algebra holding the identity and absorption equivalences showed in Figure 2. Then\na\u2217a \u00b7b = a \u00b7b a\u2217b \u00b7a = b \u00b7a\nProof . The proof follow from the following equivalences:\na\u2217a \u00b7b = a\u22171 \u00b7a \u00b7b (identity) = 1 \u00b7a \u00b7b (absorption) = a \u00b7b (identity)\na\u2217b \u00b7a = a\u2217b \u00b7a \u00b71 (identity) = b \u00b7a \u00b71 (absorption) = b \u00b7a (identity)\nProposition 10 (Transitivity extended) Let a, b and c be elements of an algebra holding the identity and absorption equivalences showed in Figure 2 such that b is different from 1. Then\na \u00b7b\u2217b \u00b7 c = a \u00b7b\u2217b \u00b7 c\u2217a \u00b7 c\nfollows from application associative, identity and absorption and distributivity over products.\nProof .\na \u00b7b\u2217b \u00b7 c\u2217a \u00b7 c = (a \u00b7b\u2217b \u00b7 c)\u2217a \u00b7 c (associative \u2018\u2217\u2019) = (a \u00b7b \u00b7 c)\u2217a \u00b7 c (transitivity) = a \u00b7 (b \u00b7 c)\u2217a \u00b7 c (associative \u2019\u00b7\u2019) = a \u00b7 (b \u00b7 c\u2217 c) (distributivity) = a \u00b7 (b \u00b7 c) (absorption ext.) = a \u00b7b \u00b7 c (associativity) = a \u00b7b\u2217b \u00b7 c (transitivity)\nCorollary 1 Given causal graphs G1, G2, G3 and Gl such that (l, l) is the only edge of Gl , the equivalences reflected in the Figures 8 and 9 hold.\nTheorem 7 Given a set of labels Lb, \u3008CLb,\u2217, \u00b7\u3009 is the free algebra generated by Lb defined by equations in the Figure 8, i.e. the mapping graph : Lb \u2212\u2192 CLb mapping each label l to the graph Gl containing the only edge (l, l) is an injective (preserving-idempotence) homomorphism and for any set F and idempotence-preserving map \u03b4 : Lb\u2212\u2192 F , there exists a homomorphism term : CLb \u2212\u2192 F defined as term(G) 7\u2192\u220f{ \u03b4 (l1) \u00b7\u03b4 (l2)\n\u2223\u2223 (l1, l2) \u2208 G } such that \u03b4 = term\u25e6graph. Proof . For clarity sake we omit the idempotence-preserving mapping \u03b4 and we write just l instead of \u03b4 (l). Thus the mapping term : CLb \u2212\u2192 F is just term(G) 7\u2192\u220f{ l1\u00b7l2\n\u2223\u2223 (l1, l2) \u2208G }. We start showing that graph preservers the \u2018\u00b7\u2019 idempotence equation.\ngraph(l) \u00b7graph(l) = Gl \u00b7Gl = Gl \u222aGl \u222a{ (l1, l2) \u2223\u2223 l1 \u2208 Gl and l2 \u2208 Gl }\n= Gl \u222aGl \u222a{(l, l)}= Gl \u222aGl \u222aGl = Gl = graph(l)\nFurthermore, suppose graph(l1) = graph(l2), i.e. {(l1, l2)} = {(l2, l2)}. Then l1 = l2. Hence graph is an injective homomorphism. Now we show that term preserves the \u2018\u2217\u2019. Let D= \u22c3 G\u2208U G. Then\n\u220f G\u2208U term(G) = \u220f G\u2208U \u220f (l1,l2)\u2208G l1\u00b7l2 = \u220f (l1,l2)\u2208D l1\u00b7l2\n= \u220f (l1,l2)\u2208D\u2217 l1\u00b7l2 = term(D\u2217)\n= term (( \u22c3 G\u2208U G )\u2217) = term ( \u220f G\u2208U G )\nWe will show now that term also preserves \u2018\u00b7\u2019. term(G1) \u00b7 term(G2) = (\n\u220f (u1,u2)\u2208Gu\nu1\u00b7u2 ) \u00b7 (\n\u220f (v1,v2)\u2208Gv\nv1\u00b7v2 )\n= \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv (u1\u00b7u2) \u00b7 (v1\u00b7v2) = \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv u1 \u00b7 (u2\u00b7v1\u00b7v2) = \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv u1 \u00b7 (u2\u00b7v1 \u2217 v1\u00b7v2) = \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv u1\u00b7u2\u00b7v1 \u2217u1\u00b7v1\u00b7v2 = \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv u1\u00b7u2 \u2217u2\u00b7v1 \u2217u1\u00b7v1 \u2217 v1\u00b7v2 \u2217u1\u00b7v1 \u2217u1\u00b7v2 = \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv (u1\u00b7u2 \u2217 v1\u00b7v2)\u2217 (u2\u00b7v1 \u2217u1\u00b7v1 \u2217u1\u00b7v1 \u2217u1\u00b7v2) = \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv (u1\u00b7u2 \u2217 v1\u00b7v2)\u2217 \u220f (u1,u2)\u2208Gu, (v1,v2)\u2208Gv (u2\u00b7v1 \u2217u1\u00b7v1 \u2217u1\u00b7v1 \u2217u1\u00b7v2) = \u220f (l1,l2)\u2208Gu\u222aGv (l1\u00b7l2)\u2217 \u220f u\u2208Gu, v\u2208Gv (u\u00b7v) = \u220f (l1,l2)\u2208Gu\u00b7Gv (l1\u00b7l2) = term(G1 \u00b7G2)\nFinally note that term(graph(l)) = l\u00b7l = l (note that l stands for the more formally \u03b4 (l))."}, {"heading": "7.2 Alternative causes", "text": "We define an explanation formed by a set of causal graphs S as:\n\u2211S = G if G \u2208 S and G\u2217G\u2032 = G\u2032 for all G\u2032 \u2208 S\nTheorem 8 The set of causal values VLb with the opperations join \u2018+\u2019 and meet \u2018\u2217 forms the free, complete distributive lattice with generated by the set of causal graphs CLb and further \u2193: CLb \u2212\u2192 VLb is an injective homomorphism from the algebra \u3008CLb,+,\u2217, \u00b7\u3009 to \u3008VLb,+,\u2217, \u00b7\u3009. .\nProof of Theorem ??. Let F be the set of filters over the lower semilattice \u3008CLb,\u2217\u3009. Stumme was showed in (Stumme 1997) that the concept lattice B\u3008F,VLb,\u2206\u3009 (with F\u2206I\u21d4 F \u2229 I 6= /0) is isomorphic to the free completely distributive complete lattice generated by the partial lattice \u3008CLb,+,\u2217\u3009 where + and \u2217 are two partial functions corresponding with the supremum and infimum. In our particular, case for every set of causal graphs S its infimum is defined as \u220fS and the supremum is defined as G \u2208 S such that G\u2032 \u2264G for all G\u2032 \u2208 S, when such G exists and undefined otherwise. Thus VLb is the set of ideals over the partial lattice \u3008CLb,+,\u2217\u3009, i.e. every I \u2208 VLb is also closed under defined suprema. He also show that the elements of such lattice are described as pairs {\n(Ft ,It) \u2223\u2223 Ft \u2286 F, It \u2286 VLb, FIt = It and Ft = IIt }\nwhere FIt = { I \u2208 I \u2223\u2223 \u2200F \u2208 Ft : F \u2229 I 6= /0 }\nIIt = { F \u2208 F \u2223\u2223 \u2200I \u2208 It : F \u2229 I 6= /0 }\nThat is, every element is in the form \u3008IIt ,It\u3009. Furthermore infima and suprema can be described as follows: \u2227\nt\u2208T (IIt ,It) = (\u22c2 t\u2208T IIt , ( \u22c3 t\u2208T It )II)\n\u2228 t\u2208T (IIt ,It) = ((\u22c3 t\u2208T IIt )II , \u22c2 t\u2208T It )\nWe will show that \u03b5I : B\u2212\u2192 VLb given by (IIt ,It) 7\u2192 \u22c2\nIt is an isomorphism between \u3008B,\u2228,\u2227\u3009 and \u3008VLb,\u222a,\u2229\u3009. Note that, since \u220f /0 = G /0 it holds that the empty set is not close under defined infimum and then it is not a filter, i.e. /0 6\u2208 F, and then for every filter F \u2208 F it holds that G /0 \u2208 F . Thus if It = /0 follows that IIt =F and then IIIt = {I \u2208VLb |G /0 \u2208 I}=CLb 6= It . That is, \u3008 /0I , /0\u3009 6\u2208B.\nWe will show that for every ideal It \u2208 I and for every set of ideals It \u2286 I s.t. It = \u22c2 It it holds that\n(IIt ,It) \u2208B\u3008F,I,\u2206\u3009 \u21d0\u21d2 It = { I \u2208 I \u2223\u2223 It \u2286 I } (8)\nand consequently \u03b5I is a bijection between and B and VLb.\nSuppose that (IIt ,It) \u2208B\u3008F,I,\u2206\u3009. For every I \u2208 It it holds that It \u2286 I. So suppose there is I \u2208 I s.t. It \u2286 I and I 6\u2208 It . Then there is F \u2208 IIt s.t. I\u2229F = /0 and for every element I\u2032 \u2208 It it holds that I\u2032 \u2229F 6= /0. Pick a causal graph G s.t. G = \u220f{G\u2032 | G\u2032 \u2208 I\u2032 \u2229F and I\u2032 \u2208 It}. Since for every G\u2032 it holds G\u2032 \u2208 F and G \u2264 G\u2032 follows that G \u2208 F (F is close under infimum) and G \u2208 I\u2032 (every I\u2032 is close under \u2264). That is, for every I\u2032 \u2208 It it holds that G \u2208 I\u2032\u2229F and then, since It = \u22c2 It , it also\nholds that G \u2208 It \u2229F and since It \u2286 I also G \u2208 I\u2229F which contradict that I\u2229F = /0. So that I \u2208 It and it holds that\n(IIt ,It) \u2208B\u3008F,I,\u2206\u3009=\u21d2 It = { I \u2208 I \u2223\u2223 It \u2286 I }\nSuppose that It = {I \u2208 I | It \u2286 I} but (IIt ,It) \u2208B\u3008F,I,\u2206\u3009, i.e. It 6= IIIt . Note that It \u2286 IIIt because otherwise there are I \u2208 It and F \u2208 IIt s.t. I\u2229F = /0 which is a contradiction with the fact that for every F \u2208 IIt and I \u2208 It it holds that F \u2229 I 6= /0.\nSo, there is I \u2208 IIIt s.t. I 6\u2208 It , i.e. for every F \u2208 IIt it holds that F \u2229 I 6= /0 but It 6\u2286 I. Pick G \u2208 It\\I and F = {G\u2032 | G \u2264 G\u2032}. It is clear that F \u2208 F and F \u2229 It 6= /0 because G \u2208 It , so that F \u2208 IIt . Furthermore F \u2229 I = /0, because G 6\u2208 I, which is a contradiction with the assumption. Thus\n(IIt ,It) \u2208B\u3008F,I,\u2206\u3009 \u21d0= It = { I \u2208 I \u2223\u2223 It \u2286 I }\nNow, we will show that (II1,I1)\u2228 (II2,I2) = (II3,I3) iff I1 \u222a I2 = I3. From the above statement follows that\nI1\u2229 I2 = {I \u2208 I | I1 \u2286 I and I2 \u2286 I}= = {I \u2208 I | I1\u222a I2 \u2286 I}\nI3 = {I \u2208 I | I3 \u2286 I}\nThat is, I1 \u2229 I2 = I3 iff I1 \u222a I2 = I3 and by definition of \u2228 the first is equivalent to (II1,I1)\u2228 (II2,I2) = (I I 3,I3).\nFinally we will show that (II1,I1)\u2227 (II2,I2) = (II3,I3) iff I1\u2229 I2 = I3. It holds that (I1\u222a I2)II = ({ I \u2208 I \u2223\u2223 I1 \u2286 I or I2 \u2286 I })II =\n= ({ I \u2208 I \u2223\u2223 I1\u2229 I2 \u2286 I })II\nI3 = { I \u2208 I \u2223\u2223 I3 \u2286 I }\nSince \u03b5I is a bijection, it holds that (I1\u222a I2)II = I3 iff I1\u2229 I2 = I3.\nThus \u03b5I : B \u2212\u2192 VLb is an isomorphism between \u3008B,\u2228,\u2227\u3009 and \u3008VLb,\u222a,\u2229\u3009, i.e. \u3008VLb,\u222a,\u2229\u3009 is isomorphic to the free completely distributive lattice generated by \u3008CLb,+,\u2217\u3009.\nLet\u2019s check now that \u2193: CLb \u2212\u2192VLb is an injective homomorphism. Stumme has already showed that \u03b5p : CLb \u2212\u2192B given by\n\u03b5p(G) 7\u2192 ({ F \u2208 F \u2223\u2223 G \u2208 F },{ I \u2208 I \u2223\u2223 G \u2208 I })\nis an injective homomorphism between the partial lattice \u3008CLb,+,\u2217\u3009 and \u3008B,\u2228,\u2227\u3009. So that \u03b5I \u25e6\u03b5p is an injective homomorphism between \u3008CLb,+,\u2217\u3009 and \u3008VLb,\u222a,\u2229\u3009 given by\n\u03b5I \u25e6 \u03b5p(G) 7\u2192 \u22c2{ I \u2208 VLb \u2223\u2223 G \u2208 I } = \u2193G\nNote that for any causal graph G and G\u2032 \u2208 CLb s.t. G\u2032 \u2264 G it holds that G\u2032 \u2208 \u03b5I \u25e6 \u03b5p(G), that is \u2193 G \u2286 \u03b5I \u25e6 \u03b5p(G). Furthermore for every causal graph G it holds that \u03b5(G) is an ideal, i.e. \u2193 G \u2208 VLb and it is clear that G \u2208 \u2193G so that, \u03b5I \u25e6 \u03b5p is an intersection with \u2193 G as one of its operands, thus \u03b5I \u25e6 \u03b5p(G) \u2286\u2193 G. That is \u2193 G = \u03b5I \u25e6 \u03b5p(G) and consequently it is an injective homomorphism between \u3008CLb,+,\u2217\u3009 \u3008VLb,\u222a,\u2229\u3009.\nLet us show now that the mapping \u2193 also preserves the \u2018\u00b7\u2019 operation. Take any causal graphs G1 and G2, then\n\u2193G1 \u00b7 \u2193G2 = \u2193{ (G\u20321 \u00b7G\u20322) \u2223\u2223 G\u20321 \u2208 \u2193G1 and G\u20322 \u2208 \u2193G2 }\n= \u2193{ (G\u20321 \u00b7G\u20322) \u2223\u2223 G\u20321 \u2264 G1 and G\u20322 \u2264 G2 } = \u2193(G1 \u00b7G2)\nNote that, from Proposition 1, it follows that G\u20321 \u00b7G\u20322 \u2264 G1 \u00b7G2. That is, \u2193 in an homomorphism between \u3008CLb,+,\u2217\u00b7\u3009 and \u3008VLb,+,\u2217\u00b7\u3009.\nCorollary 2 Every equivalence showed in Figure 4 hold. Futheremore equivalences showed in Figures 8 and 9 also hold if principal ideals \u2193G1, \u2193G2 and \u2193G3 are considered instead of causal graphs G1, G2 and G3.\nCorollary 3 Given causal terms without sums c, d, e and a label l, the equivalences reflected in the Figures 10 and 11 hold.\nProposition 11 (Application associativity) Let T , U and W be three causal values. Then T \u00b7 (U \u00b7W ) = (T \u00b7U) \u00b7W .\nProof . By definition, it follows that (T \u00b7U) \u00b7W = \u2193{ Gt \u00b7Gu \u2223\u2223 Gt \u2208 T and Gu \u2208U } \u00b7W\n= \u2193{ G\u2032 \u00b7Gw \u2223\u2223 G\u2032 \u2264 Gt \u00b7Gu, Gt \u2208 T, Gu \u2208U and Gw \u2208W }\nIt is clear that Gt \u00b7Gu \u2264 Gt \u00b7Gu and then \u2193{ (Gt \u00b7Gu) \u00b7Gw \u2223\u2223 Gt \u2208 T, Gu \u2208U and Gw \u2208W } \u2286 \u2193{ G\u2032 \u00b7Gw \u2223\u2223 G\u2032 \u2264 Gt \u00b7Gu, Gt \u2208 T, . . . }\nFurthermore since \u2018\u00b7\u2019 is monotonic, for every G\u2032 \u2264 Gt \u00b7Gu, it holds that G\u2032 \u00b7Gw \u2264 (Gt \u00b7Gu) \u00b7Gw and then\n(T \u00b7U) \u00b7W = \u2193{ (Gt \u00b7Gu) \u00b7Gw \u2223\u2223 Gt \u2208 T, Gu \u2208U and Gw \u2208W }\nApplying the same reasoning we can also conclude that T \u00b7 (U \u00b7W ) = \u2193{ Gt \u00b7 (Gu \u00b7Gw) \u2223\u2223 Gt \u2208 T, Gu \u2208U and Gw \u2208W }\nThat is, T \u00b7 (U \u00b7W ) = (T \u00b7U) \u00b7W holds whether, for every causal graph Gt , Gu and Gw, it holds that (Gt \u00b7Gu) \u00b7Gw = Gt \u00b7 (Gu \u00b7Gw). This holds due to Proposition 2.\nProposition 12 (Application distributivity w.r.t. additions) Let T , U and W be three causal values. Then, it holds that U \u00b7 (T +W ) = (U \u00b7T )+(U \u00b7W ) and (U +T ) \u00b7W = (U \u00b7W )+(T \u00b7W ).\nProof . By definition, it follows that\n(U \u00b7T )+(U \u00b7W ) = (U \u00b7T )\u222a (U \u00b7W ) = \u2193 { GU \u00b7GT \u2223\u2223 GU \u2208U and GT \u2208 T } \u222a \u2193{ GU \u00b7GT \u2223\u2223 GU \u2208U and GW \u2208W } = \u2193 { GU \u00b7G\u2032\n\u2223\u2223 GU \u2208U and G\u2032 \u2208 T \u222aW }=U \u00b7 (T \u222aW ) =U \u00b7 (T +W ) Furthermore (U +T ) \u00b7W = (U \u00b7W )+(T \u00b7W ) holds symmetrically.\nProposition 13 (Application absorption) Let T , U and W be three causal values. Then T = T + U \u00b7T \u00b7W and U \u00b7T \u00b7W = T \u2217U \u00b7T \u00b7W\nProof . From Proposition 11 it follows that U \u00b7T \u00b7W = \u2193 { GU \u00b7GT \u00b7GW \u2223\u2223 GU \u2208U, GT \u2208 T and GW \u2208W }\nFurthermore, for every c-graph GT \u2208 T , it holds that GU \u00b7GT \u00b7 TW \u2264 GT . Then, since T is an ideal, it follows that GU \u00b7GT \u00b7TW \u2208 T and consequently U \u00b7T \u00b7W \u2286 T . Thus U \u00b7T \u00b7W \u222aT = T and U \u00b7T \u00b7W \u2229T =U \u00b7T \u00b7W and, by definition, these equalities can be rewritten as U \u00b7T \u00b7W +T = T and U \u00b7T \u00b7W \u2217T =U \u00b7T \u00b7W .\nProposition 14 (Application identity and annihilator)\nGiven a causal value T , it holds that T = 1 \u00b7T , T = T \u00b71, 0 = T \u00b70 and 0 = 0 \u00b7T .\nProof . Note that 1 and 0 respectively correspond to CLb and /0 and by definition it follows that\n1 \u00b7T = \u2193 { G \u00b7GT \u2223\u2223 G \u2208 CLb and GT \u2208 T }= T\n0 \u00b7T = \u2193 { G \u00b7GT \u2223\u2223 G \u2208 /0 and GT \u2208 T }= /0 = 0\nThe other cases are symmetric.\nCorollary 4\nThe equivalences reflected in the Figure 2 hold.\nTheorem 9\nGiven a set of labels Lb, \u3008VLb,+,\u2217, \u00b7\u3009 is the free algebra generated by Lb defined by equations in the Figure 4 and 2, i.e. the mapping value : Lb\u2212\u2192 VLb mapping each label l to the causal value \u2193Gl with Gl being the causal graph containing the only edge (l, l) is an injective (preservingidempotence) homomorphism and for any set F and idempotence-preserving map \u03b4 : Lb\u2212\u2192 F , there exists a homomorphism term : VLb \u2212\u2192 F defined as term(U) 7\u2192 \u2211{ term(G)\n\u2223\u2223 G \u2208U } such that \u03b4 = term\u25e6graph.\nProof . Note, from Theorems 7 and 8, that graph : Lb \u2212\u2192 CLb and \u2193: CLb \u2212\u2192 VLb are injective homomorphisms respectively from Lb to CLb and from CLb to VLb. Furthermore the composition of injective homomorphisms is injective too. So that value(l) 7\u2192 \u2193graph(l) is an injective homomorphism between Lb and VLb. We will show now that term : VLb \u2212\u2192 F preserves the \u2018+\u2019:\nterm (\n\u2211 U\u2208U\nU ) = term (\u22c3 U ) = \u2211\nG\u2208 \u22c3 U term(G) = \u2211 U\u2208U \u2211 G\u2208U term(G) = \u2211 U\u2208U term(U)\nthat term also preserves \u2018\u2217\u2019:\n\u220f U\u2208U term(U) = \u220f U\u2208U \u2211 G\u2208U term(G) = \u2211 \u03d5\u2208\u03a6 \u220f U\u2208U term(\u03d5(U)) = \u2211 \u03d5\u2208\u03a6\nterm (\n\u220f U\u2208U\n\u03d5(U) ) = \u2211\nt\u2208T1 t\nterm (\n\u220f U\u2208U\nU ) = term (\u22c2 U )\n= \u2211 G\u2208 \u22c2 U term(G) = \u2211 t\u2208T2 t\nwhere \u03a6 def= { \u03d5 \u2223\u2223 \u03d5(U)\u2208U with U \u2208U }. Note that G\u2208\u22c2U implies that G\u2208U for all U \u2208U\nand consequently there is \u03d5 \u2208 \u03a6 s.t. \u03d5(U) = G for all U \u2208 U . Thus term ( \u220fU\u2208U \u03d5(U) ) =\nterm ( \u220fU\u2208U G ) = term(G). That is T2 \u2286 T1. Note also that \u220fU\u2208U \u03d5(U) = (\u22c3 U\u2208U U )\u2217 \u2287 \u03d5(U) for all U \u2208 U and consequently \u220fU\u2208U U \u2208U for all U \u2208 U and so that \u220fU\u2208U U \u2208 \u22c2 U and\nT2 \u2287 T1. And that term preserves \u2018\u00b7\u2019 too: term(U) \u00b7 term(W ) = (\n\u2211 Gu\u2208U\nterm(Gu) ) \u00b7 (\n\u2211 Gw\u2208W\nterm(Gw) )\n= \u2211 Gu\u2208U, Gw\u2208W term(Gu) \u00b7 term(Gw) = \u2211 Gu\u2208U, Gw\u2208W term(Gu \u00b7Gw)\n= term (\n\u2211 Gu\u2208U, Gw\u2208W\nGu \u00b7Gw )\n= term (\n\u2211 Gu\u2208U Gu \u00b7 \u2211 Gw\u2208W\nGw )\n= term(U \u00b7W )\nFinally term(value(l)) = \u2211G\u2208value(l) term(G) = term(Gl) and, from Theorem 7, term(Gl) = l.\n7.3 Positive programs\nLemma 7.1 Let P be a positive (and possible infinite) logic program over signature \u3008At,Lb\u3009. Then, (i) the least fix point of TP, lfp(TP) is the least model of P, and (ii) lfp(TP) = TP \u2191 \u03c9 (0).\nProof . Since the set of causal values forms a lattice causal logic programs can be translated to Generalized Annotated Logic Programming (GAP). GAP is a general a framework for multivalued logic programming where the set of truth values must to form an upper semilattice and rules (annotated clauses) have the following form:\nH : \u03c1 \u2190 B1 : \u00b51 & . . . & Bn : \u00b5n (9)\nwhere L0, . . . ,Lm are literals, \u03c1 is an annotation (may be just a truth value, an annotation variable or a complex annotation) and \u00b51, . . . ,\u00b5n are values or annotation variables. A complex annotation is the result to apply a total continuous function to a tuple of annotations. Thus a positive program P is encoded in a GAP program, GAP(P) rewriting each rule R \u2208\u03a0 of the form\nt : H\u2190 B1\u2227 . . .\u2227Bn (10)\nas a rule GAP(R) in the form (9) where \u00b51, . . . ,\u00b5n are annotation that capture the causal values of each body literal and \u03c1 is a complex annotation defined as \u03c1 = (\u00b51 \u2217 . . .\u2217\u00b5n) \u00b7 t.\nThus we will show that a causal interpretation I |= \u03a0 if and only if I |=r GAP(P) where |=r refers to the GAP restricted semantics.\nFor any program P and interpretation I, by definition, I |= P (resp. I |=r GAP(P)) iff I |= R (resp. I |=r GAP(R)) for every rule R \u2208 P. Thus it is enough to show that for every rule R it holds that I |= R iff I |=r GAP(R). By definition, for any rule R of the form of (10) and an interpretation I, I |= R if and only if( I(B1)\u2217 . . .\u2217 I(Bn) ) \u00b7 t \u2264 I(H) whereas for any rule GAP(R) in the form of (9), I |=r GAP(R) iff for all \u00b5i \u2264 I(Bi) implies that \u03c1 = (\u00b51 \u2217 . . .\u2217\u00b5n) \u00b7 t \u2264 I(H).\nFor the only if direction, take \u00b5i = I(Bi), then \u03c1 = (\u00b51 \u2217 . . .\u2217\u00b5n) \u00b7 t = (I(B1)\u2217 . . .\u2217 I(Bn)) \u00b7 t and then \u03c1 \u2264 I(H) implies ( I(B1)\u2217 . . .\u2217 I(Bn) ) \u00b7 t \u2264 I(H), i.e. I |=r GAP(R) implies I |= R. For the if direction, take \u00b5i \u2264 I(Bi) then, since product an applications are monotonic operations, it follows that (\u00b51 \u2217 . . .\u2217\u00b5n) \u00b7 t \u2264 (I(B1)\u2217 . . .\u2217 I(Bn)) \u00b7 t \u2264 I(H), That is, I |= R also implies I |=r GAP(R). Consequently I |= R iff I |=r GAP(R).\nThus, from Theorem 1 in (Kifer and Subrahmanian 1992), it follows that the operator TP is monotonic.\nTo show that the operator TP is also continuous we need to show that for every causal program P the translation GAP(P) is an acceptable program. Indeed since in a program GAP(P) all body atoms are v-annotated it is acceptable. Thus from Theorem 3 in (Kifer and Subrahmanian 1992), it follows that TP \u2191 \u03c9 (0) = l f p(TP) and this is the least model of P.\nLemma 7.2 Given a positive and completely labelled program P, for every atom p and integer k \u2265 1,\nTP \u2191 k (0)(p) = \u2211 R\u2208\u03a8 \u2211 f\u2208R\n\u220f { f ( TP \u2191 k\u22121 (0)(q) ) \u2223\u2223 q \u2208 body(R) } \u00b7 label(R)\nwhere \u03a8 is the set of rules \u03a8 = { R \u2208 \u03a0 \u2223\u2223 head(R) = p } and R is the set of choice functions\nR = { f \u2223\u2223 f (S) \u2208 S }.\nProof . By definition of TP \u2191 k (0)(p) it follows that TP \u2191 k (0)(p) = \u2211 { ( TP \u2191 k\u22121 (0)(q1)\u2217 . . .\u2217TP \u2191 k\u22121 (0)(q1) ) \u00b7 label(R) \u2223\u2223 R \u2208 P with head(R) = p } then, applying distributive of application w.r.t. to the sum and and rewriting the sum and the product aggregating properly, it follows that\nTP \u2191 k (0)(p) = \u2211 R\u2208\u03a8\n\u220f { TP \u2191 k\u22121 (0)(q) \u2223\u2223 q \u2208 body(R) } \u00b7 label(R)\nFurthermore for any atom q the causal value TP \u2191 k\u22121 (0)(q) can be expressed as the sum of all c-graphs in it and then\nTP \u2191 k (0)(p) = \u2211 R\u2208\u03a8\n\u220f {\n\u2211 f\u2208R\nf ( TP \u2191 k\u22121 (0)(q) ) \u2223\u2223 q \u2208 body(R) } \u00b7abel(R) and applying distributivity of products over sums it follows that\nTP \u2191 k (0)(p) = \u2211 R\u2208\u03a8 \u2211 f\u2208R\n\u220f { f ( TP \u2191 k\u22121 (0)(q) ) \u2223\u2223 q \u2208 body(R) } \u00b7 lR\nLemma 7.3 Given a positive and completely labelled program P and a causal graph G, for every atom p and integer k\u2265 1, it holds that G\u2208 TP \u2191 k (0)(p) iff there is a rule l : p\u2190 q1, . . . ,qm and causal graphs Gq1 , . . . , Gqm respectively in TP \u2191 k\u22121 (0)(qi) and G\u2264 ( Gq1 \u2217 . . .\u2217Gqm ) \u00b7 l.\nProof . From Lemma 7.2 it follows that G \u2208 TP \u2191 k (0)(p) iff G \u2208 value (\n\u2211 R\u2208\u03a8 \u2211 f\u2208R\n\u220f { f ( TP \u2191 k\u22121 (0)(q) ) \u2223\u2223 q \u2208 body(R) } \u00b7 label(R) ) iff G \u2208\n\u22c3 R\u2208\u03a8 \u22c3 f\u2208R value ( \u220f { \u2193 f ( TP \u2191 k\u22121 (0)(q) )) \u2223\u2223 q \u2208 body(R) } \u00b7 label(R) iff there is R \u2208\u03a6, with head(R) = p and a choice function f \u2208\u03a8 s.t.\nG \u2208 value ( \u220f { f ( TP \u2191 k\u22121 (0)(q) ) \u2223\u2223 q \u2208 body(R) } \u00b7 label(R)) Let R = l : p\u2190 q1, . . . ,qm and f ( TP \u2191 k\u22121 (0)(qi) ) = Gqi . Then the above can be rewritten as\nG\u2264 ( Gq1 \u2217 . . .\u2217Gqm ) \u00b7 l.\nDefinition 10 Given a causal graph G = \u3008V,E\u3009, we define the restriction of G to a set of vertex V \u2032 \u2286 V as the casual graph G\u2032 = \u3008V \u2032,E \u2032\u3009 where E \u2032 = { (l1, l2) \u2208 E \u2223\u2223 l1 \u2208 V \u2032 and l2 \u2208 V \u2032 }, and we define the reachable restriction of G to a set of vertex V \u2032 \u2286 V , in symbols GV \u2032 , as the restriction of G to the set of vertex V \u2032\u2032 from where some vertex l \u2208 V \u2032 is reachable V \u2032\u2032 = { l\u2032 \u2208 V\n\u2223\u2223 (l\u2032, l) \u2208 E\u2217 for some l \u2208V \u2032 }. When V \u2032 = l is a singleton we write Gl .\nLemma 7.4 Let P be a positive, completely labelled program, p and q be atoms, G be a causal graph, R be a causal rule s.t. head(R) = q and label(R) = l is a vertex in G and k \u2208 {1, . . . ,\u03c9} be an ordinal. If G \u2208 TP \u2191 k (0)(p), then Gl \u2208 TP \u2191 k (0)(q).\nProof . In case that k = 0 the lemma statement holds vacuous. Otherwise assume as induction hypothesis that the lemma statement holds for k\u22121. From Lemma 7.3, since G\u2208 TP \u2191 k (0)(p), there is a rule Rp = (lp : p\u2190 p1, . . . , pm) and c-graph Gp1 , . . . ,Gpm s.t. each Gpi \u2208 TP \u2191 k\u22121 (0)(pi) and G\u2264 (Gp1 \u2217 . . .\u2217Gpm) \u00b7 lp.\nIf l = lp then, since P is uniquely labelled, R = Rp, Gl = G and by assumption G \u2208 TP \u2191 k (0)(p). Otherwise l \u2208 Gpi for some Gpi and in its turn Gpi \u2208 TP \u2191 k\u22121 (0)(pi). By induction hypothesis Gl \u2208 TP \u2191 k\u22121 (0)(q) and since TP \u2191 k\u22121 (0)(q)\u2286 TP \u2191 k (0)(q) it follows that Gl \u2208 TP \u2191 k (0)(q).\nIn case that k = \u03c9 , by definition TP \u2191 \u03c9 (0)(p) = \u2211i<\u03c9 TP \u2191 i (0)(p) and the same for atom q. Thus, if G \u2208 TP \u2191 \u03c9 (0)(p) there is some i < \u03c9 s.t. G \u2208 TP \u2191 i (0)(p), and as we already show, Gl \u2208 TP \u2191 i (0)(q) and consequently Gl \u2208 TP \u2191 \u03c9 (0)(q).\nLemma 7.5 Let P be a positive, completely labelled program, p be an atom and G be a causal graph and k\u2265 1 be an integer. If G is maximal in TP \u2191 k (0)(p) then\n1. there is a causal rule R = (l : p\u2190 p1, . . . , pm) and there are causal graphs Gp1 , . . . ,Gpm s.t. each Gpi \u2208maxTP \u2191 k\u22121 (0)(pi) and Gp = (Gp1 \u2217 . . .\u2217Gpm) \u00b7 l and 2. l is not a vertex of any Gpi .\nProof . From Lemma 7.3 it follows that G\u2208 TP \u2191 k (0)(p) iff there is a rule R=(l : p\u2190 q1, . . . ,qm) and causal graphs G\u2032q1 , . . . ,G \u2032 qm s.t. each Gpi \u2208maxTP \u2191 k\u22121 (0)(pi) and G = ( G\u2032q1 \u2217 . . .\u2217G \u2032 qm ) \u00b7 l. Let Gq1 , . . . ,Gqm be causes such that each Gqi \u2208 maxTP \u2191 k\u22121 (0)(qi) and G\u2032qi \u2264 Gqi and let G \u2032\nbe the c-graph G\u2032 = ( Gq1 \u2217 . . . \u2217Gqm ) \u00b7 l. By product and application monotonicity it holds that G\u2264G\u2032 and, again from Lemma 7.3, it follows that G\u2032 \u2208 TP \u2191 k (0)(p). Thus, since G is maximal, it must to be that G = G\u2032 and consequently G = ( Gq1 \u2217 . . .\u2217Gqm ) \u00b7 l where each Gqi is maximal.\nSuppose that l is a vertex of Gpi for some Gpi . From Lemma 7.4, if follows that G l pi \u2208TP \u2191 k (0)(p). Furthermore, since Gpi \u2287 Glpi , it follows that Gpi \u2264 G l pi and, since l is a label (l 6= 1), it follows that G < Gpi and so that G < G l pi which contradicts the assumption that G \u2208maxTP \u2191 k (0)(p).\nDefinition 11 Given a causal graph G we define height(G) as the length of the maximal simple (no repeated vertices) path in G.\nLemma 7.6 Let P be a positive, completely labelled program, p be an atom, k \u2208 {1, . . . ,\u03c9} be an ordinal and G be a causal graph. If G \u2208maxTP \u2191 k (0)(p) and height(G) = h\u2264 k then G \u2208 TP \u2191 h (0)(p).\nProof . In case that h = 0, from Lemma 7.5, it follows that if G \u2208 maxTP \u2191 k (0)(p) there is a causal rule R = (l : p\u2190 p1, . . . , pm) and c-graphs. . . . Furthermore, since P is completely labelled, it follows that l 6= 1 and then G < l < 1. Since 1 is the only c-graph whose height is 0 the lemma statement holds vacuous.\nIn case that h > 0, we proceed by induction assuming as hypothesis that the lemma statement holds for any h\u2032 < h. From Lemma 7.5, there is a causal rule l : p\u2190 p1, . . . , pm, and there are causal graphs Gp1 , . . . ,Gpm s.t. each Gpi \u2208 maxTP \u2191 k\u22121 (0)(pi), G = GR \u00b7 l and l 6\u2208 V (Gpi) for any Gpi where GR = Gp1 \u2217 . . .\u2217Gpm .\nIf m = 0 then G = 1 \u00b7 l = l, height(l) = 1 and l \u2208 maxTP \u2191 k (0)(p) for any k \u2265 1. Otherwise, since any path in Gpi is also a path Gp, it is clear that height(Gpi) = h \u2032 pi \u2264 h for any Gpi . Suppose that h\u2032pi = h for some Gpi . Then there is a simple path l1, . . . , lh of length h in Gpi and, since G = GR \u00b7 l, there is an edge (lh, l) \u2208 E(G). That is l1, . . . , lh, l is a walk of length h+1 in G and, since l 6\u2208V (Gpi), it follows that li 6= l with 1\u2264 i\u2264 h. So that l1, . . . , lh, l is a simple path of length h+1 which contradicts the assumption that height(G) = h. Thus height(Gpi) = h \u2032 pi < h for any Gpi and then, by induction hypothesis, Gpi \u2208maxTP \u2191 h\u2032pi (0)(pi).\nLet h\u2032 = max{ h\u2032pi \u2223\u2223 1\u2264 i\u2264m }< h. Since the TP operator is monotonic and h\u2032pi \u2264 h\u2032 for any pi, it follows that TP \u2191 h \u2032 pi (0)(pi)\u2264 TP \u2191 h \u2032 (0)(pi) and then there are casual graphs G\u2032p1 , . . . ,G \u2032 pm such that each G\u2032pi \u2208 maxTP \u2191 h\u2032 (0)(pi), Gpi \u2264 G\u2032pi and G \u2032 = GR \u00b7 l where G\u2032R = G\u2032p1 \u2217 . . .\u2217G \u2032 pm . By product and application monotonicity, it follows that G \u2264 G\u2032, and, from Lemma 7.3, it follows that G\u2032 \u2208 TP \u2191 h\n\u2032+1 (0)(p). Since h\u2032+1\u2264 h it follows that G\u2032 \u2208 TP \u2191 h (0)(p) and since G\u2264 G\u2032 it follows that G \u2208 TP \u2191 h (0)(p).\nSuppose that G 6\u2208 maxTP \u2191 h (0)(p). Then there is G\u2032\u2032 \u2208 maxTP \u2191 h (0)(p) s.t. G < G\u2032\u2032 and then, since h \u2264 k, it follows that G\u2032\u2032 \u2208 TP \u2191 k (0)(p) which, since G < G\u2032\u2032, contradicts the assumption that G \u2208maxTP \u2191 k (0)(p). Thus, if G \u2208maxTP \u2191 k (0)(p) and height(G) = h\u2264 k it follows that G \u2208 TP \u2191 h (0)(p).\nIn case that k=\u03c9 , by definition TP \u2191 \u03c9 (0)(p)=\u2211i<\u03c9 TP \u2191 i (0)(p). Thus, if G\u2208maxTP \u2191 \u03c9 (0)(p) and height(G) = h then there is some i<\u03c9 s.t. G\u2208maxTP \u2191 i (0)(p) and h\u2264 i, and as we already show, then G \u2208 TP \u2191 h (0)(p).\nLemma 7.7\nLet P,Q two positive causal logic programs such that Q is the result of replacing label l in P by some u (a label or 1) then TQ \u2191 k (0)(p) = TP \u2191 k (0)(p)[l 7\u2192 u] for any atom p and k \u2208 {1, . . . ,\u03c9}.\nProof . In case that n = 0, TQ \u2191 k (0)(p) = 0 and TP \u2191 k (0)(p) = 0 and 0 = 0[l 7\u2192 u]. That is TQ \u2191 k (0)(p) = TP \u2191 k (0)(p)[l 7\u2192 u].\nWe proceed by induction on k assuming that TQ \u2191 k\u22121 (0)(p) = TP \u2191 k\u22121 (0)(p)[l 7\u2192 u] for any atom p and we will show that TQ \u2191 (0)(p) = TP \u2191 k (0)(p)[l 7\u2192 u].\nPick G \u2208 TP \u2191 k (0)(p) then, from Lemma 7.3, there is a rule l\u2032 : p \u2190 q1, . . . ,qm and causal graphs Gq1 , . . . , Gqm each one respectively in TP \u2191 k\u22121 (0)(qi) s.t. G\u2264 GR = (Gq1 \u2217 . . .\u2217Gqm) \u00b7 l\u2032. Thus, by induction hypothesis, for every atom qi and c-graph Gqi \u2208 TP \u2191 k\u22121 (0)(q) it holds that Gqi [l 7\u2192 u] \u2208 TQ \u2191 k\u22121 (0)(qi).\nLet GR[l 7\u2192 u] be a c-graph defined as GR[l 7\u2192 u] = ( Gq1 [l 7\u2192 u] \u2217 . . . \u2217Gqm [l 7\u2192 u] ) \u00b7 l\u2032[l 7\u2192 u]. Then, since G \u2264 GR, it follows that G[l 7\u2192 u] \u2264 GR[l 7\u2192 u] and then, again from Lemma 7.3, it follows that G[l 7\u2192 u] \u2208 TQ \u2191 n (0)(p). That is TP \u2191 k (0)(p)[l 7\u2192 u]\u2286 TQ \u2191 k (0)(p).\nPick G \u2208 TQ \u2191 k (0)(p) then, from Lemma 7.3, there is a rule there is a rule l\u2032 : p\u2190 q1, . . . ,qm and c-graphs Gq1 , . . . , Gqm respectively in TP \u2191 k\u22121 (0)(qi) s.t. G \u2264 GR where GR = (Gq1 \u2217 . . . \u2217 Gqm) \u00b7 l\u2032. By induction hypothesis, for every atom qi and graph Gqi it holds that if Gqi \u2208 TQ \u2191 k\u22121 (0)(qi) then Gqi \u2208 TP \u2191 k\u22121 (0)(qi)[l 7\u2192 u]. Thus, it follows that there is a graph G\u2032qi \u2208 TP \u2191\nk\u22121 (0)(qi) such that G\u2032qi [l 7\u2192 u] = Gqi . Let G \u2032 R be a graph s.t. G \u2032 R = ( G\u2032q1 \u2217 . . .\u2217G \u2032 qm ) \u00b7 l\u2032. From Lemma 7.3 for every causal graph G\u2032 \u2264G\u2032R it holds that G\u2032 \u2208 TP \u2191 k (0)(p). Since G\u2032R[l 7\u2192 u] = GR and G\u2264GR it follows that G\u2264GR[l 7\u2192 u] and, since GR \u2208 TP \u2191 k (0)(p), it follows that G\u2208 TP \u2191 k (0)(p)[l 7\u2192 u]. Consequently TP \u2191 k (0)(p)[l 7\u2192 u]\u2287 TQ \u2191 n (0)(p) and then TP \u2191 k (0)(p)[l 7\u2192 u] = TQ \u2191 n (0)(p).\nIn case that k = \u03c9 , by definition TP \u2191 \u03c9 (0)(p)[l 7\u2192 u] = \u2211i<\u03c9 TP \u2191 (0)(i)p[l 7\u2192 u] and as we alerady show TP \u2191 (0)(i)p[l 7\u2192 u] = TQ \u2191 i (0)(p) for all integer i < \u03c9 , so that, their sum is also equal and consequently TP \u2191 \u03c9 (0)(p)[l 7\u2192 u] = TQ \u2191 \u03c9 (0)(p).\nProof of Theorem 2. Let P\u2032 be a positive, completely labelled causal program with the same rules as P. From Lemma 7.1 it follows that (i) lfp(TP) and lfp(TP\u2032) are respectively the least model of the programs P and P\u2032, and (ii) lfp(TP) = TP \u2191 \u03c9 (0) and lfp(TP\u2032) = TP\u2032 \u2191 \u03c9 (0).\nFuthermore, it is clear that if P is an infinite program, i.e. n = \u03c9 , then TP\u2032 \u2191 n (0) = TP\u2032 \u2191 \u03c9 (0). Otherwise, by definition it holds that TP\u2032 \u2191 n (0) \u2264 TP\u2032 \u2191 \u03c9 (0). Suppose TP\u2032 \u2191 n (0)< TP\u2032 \u2191 \u03c9 (0). Then there is some atom p and c-graph G \u2208 TP\u2032 \u2191 \u03c9 (0)(p) such that G 6\u2208 TP\u2032 \u2191 n (0)(p). The longest simple path in G must be smaller than the number of its vertices and this must be smaller than the number of labels of the program which in its turn is equal to the number of rules n, i.e. height(G) = h\u2264 n. From Lemma 7.6 it follows that G \u2208 TP\u2032 \u2191 h (0)(p) and since h\u2264 n it follows that TP\u2032 \u2191 h (0)(p)\u2286 TP\u2032 \u2191 n (0)(p) and so that G \u2208 TP\u2032 \u2191 n (0)(p) which is a contradiction with the assumption that G \u2208 TP \u2191 \u03c9 (0)(p) but G 6\u2208 TP \u2191 n (0)(p). Thus TP\u2032 \u2191 n (0) = TP\u2032 \u2191 \u03c9 (0).\nFurthermore, from Lemma 7.7, TP \u2191 k (0)(p) = TP\u2032 \u2191 k (0)(p)[l\u20321 7\u2192 l1] . . . [l\u2032n 7\u2192 ln] for k \u2208 {n,\u03c9} and where l\u20321, . . . , l \u2032 n are the labels of rules of P\n\u2032 and l1, . . . , ln are the correspondent labels of such rules in P. Thus, since TP\u2032 \u2191 n (0) = TP\u2032 \u2191 \u03c9 (0), it follows that TP \u2191 n (0) = TP \u2191 \u03c9 (0).\nLemma 7.8 For any proof \u03c0(p) it holds that\ngraph (\u03c0(q1), . . . ,\u03c0(qm) p (l) ) = ( graph(\u03c0(q1))\u2217 . . .\u2217graph(\u03c0(q1)) ) \u00b7 l\nProof . We proceed by structural induction assuming that for every proof in the antecedent \u03c0(qi) and every label l\u2032 \u2208V (graph(\u03c0(qi))) there is an edge (l\u2032, label(\u03c0(qi))) \u2208 E(graph(\u03c0(qi))).\nBy definition graph(\u03c0(p)) = G\u2217\u03c0(p) is the reflexive and transitive closure of G\u03c0(p) and then\ngraph(\u03c0(p)) = (\u22c3{ graph(\u03c0(qi)) \u2223\u2223 1\u2264 i\u2264 m }\u222a{ (label(\u03c0(qi), l) \u2223\u2223 1\u2264 i\u2264 m })\u2217\nThus, graph(\u03c0(p))\u2265\u220f { graph(\u03c0(qi)) \u2223\u2223 1\u2264 i\u2264m } \u00b7 l and remain to show that for every atom qi and label l\u2032 \u2208 V (graph(\u03c0(qi))) the edge (l\u2032, l) \u2208 E(graph(\u03c0(p))). Indeed, since by induction hypothesis there is an edge (l\u2032, label(\u03c0(qi))) \u2208 E(graph(\u03c0(qi)))\u2286 E(graph(\u03c0(p)), the fact that the edge (label(\u03c0(qi), l) \u2208 E(graph(\u03c0(p))) and since graph(\u03c0(p)) is closed transitively, it follows that (l\u2032, l) \u2208 E(graph(\u03c0(p))).\nLemma 7.9 Let P be a positive, completely labelled program and \u03c0(p) be a proof for p w.r.t. P. Then it holds that graph(\u03c0p) \u2208 TP \u2191 h (0)(p) where h is the height of \u03c0(p) which is recursively defined as\nheight(\u03c0) = 1+max{ height(\u03c0 \u2032) \u2223\u2223 \u03c0 \u2032 is a sub-proof of \u03c0 }\nProof . In case that h = 1 the antecedent of \u03c0(p) is empty, i.e.\n\u03c0(p) = > p (l)\nwhere l is the label of the fact (l : p). Then graph(\u03c0(p)) = l. Furthermore, since the fact (l : p) is in the program P, it follows that l \u2208 TP \u2191 1 (0)(p).\nIn the remain cases, we proceed by structural induction assuming that for every natural number h \u2264 n\u2212 1, atom p and proof \u03c0(p) of p w.r.t. P whose height(\u03c0(p)) = h it holds that graph(\u03c0(p)) \u2208 TP \u2191 h (0)(p) and we will show it in case that h = n.\nSince height(\u03c0p)> 1 it has a non empty antecedent, i.e.\n\u03c0(p) = \u03c0(q1), . . . ,\u03c0(qm)\np (l)\nwhere l is the label of the rule l : p \u2190 q1, . . . ,qm. By height definition, for each qi it holds that height(\u03c0(qi))\u2264 n\u22121 and so that, by induction hypothesis, graph(\u03c0(qi)) \u2208 TP \u2191 h\u22121 (0)(qi). Thus, from Lemmas 7.3 and 7.8, it follows respectively that\n\u220f{ graph(\u03c0(qi)) \u2223\u2223 1\u2264 i\u2264 m } \u00b7 l \u2208 TP \u2191 h (0)(p)\ngraph(\u03c0(p)) = \u220f{ graph(\u03c0(qi)) \u2223\u2223 1\u2264 i\u2264 m } \u00b7 l\nThat is, graph(\u03c0(p)) \u2208 TP \u2191 h (0)(p).\nLemma 7.10 Let P be a positive, completely labelled program and \u03c0(p) be a proof of p w.r.t. P. For every atom p and maximal causal graph G \u2208 TP \u2191 \u03c9 (0)(p) there is a non-redundant proof \u03c0(p) for p w.r.t. P s.t. graph(\u03c0(p)) = G.\nProof . From Lemma 7.5 for any maximal graph G\u2208TP \u2191 k (0)(p), there is a rule l : p\u2190 q1, . . . ,qm and maximal graphs Gq1 \u2208 TP \u2191 h\u22121 (0)(q1), . . . ,Gqm \u2208 TP \u2191 k\u22121 (0)(qm) s.t.\nG = (Gq1 \u2217 . . .\u2217Gqm) \u00b7 l\nFurthermore, we assume as induction hypothesis that for every atom qi there is a non redundant proof \u03c0(qi) for qi w.r.t. P s.t. graph(\u03c0(qi)) = Gqi . Then \u03c0(p) defined as\n\u03c0(p) = \u03c0(q1), . . . ,\u03c0(qm)\np (l)\nis a proof for p w.r.t. P which holds graph(\u03c0(p)) = Gp (from Lemma 7.8) and height(\u03c0(p) \u2264 h. Furthermore, suppose that \u03c0(p) is redundant, i.e. there is a proog \u03c0 \u2032 for p w.r.t P such that graph(\u03c0(p)) < graph(\u03c0 \u2032). Let h = height(\u03c0 \u2032). Then, from Lemma 7.9, it follows that graph(\u03c0 \u2032) \u2208 TP \u2191 h (0)(p) and then graph(\u03c0 \u2032) \u2208 TP \u2191 \u03c9 (0)(p) which contradicts the hypothesis that G is maximal in TP \u2191 \u03c9 (0)(p).\nProof of Theorem 3. From Theorem 2 it follows that the least model I is equal to TP \u2191 \u03c9 (0). For the only if direction, from Lemma 7.10, it follows that for every maximal c-graph G \u2208 I(p) = TP \u2191 \u03c9 (0)(p) there is a non-redundant proof \u03c0(p) for p w.r.t P s.t. G = graph(\u03c0(p)). That is, \u03c0(p) \u2208 \u03a0p and then G = graph(\u03c0(p)) \u2208 graph(\u03a0p). For the if direction, from Lemma 7.9, for every G \u2208 graph(\u03a0p), i.e. G = graph(\u03c0(p)) for some non-redundant proof \u03c0(p) for p w.r.t. P, it holds that G \u2208 TP \u2191 \u03c9 (0)(p) and so that G \u2208 I(p). Furthermore, suppose that G is not maximal, i.e. there is a maximal c-graph G\u2032 \u2208 I(p) s.t. G < G\u2032 and a proof \u03c0 \u2032 for p w.r.t. P s.t. graph(\u03c0 \u2032) = G\u2032 which contradicts that \u03c0(p) is non-redundant.\nLemma 7.11 Let t be a causal term. Then value(t[l 7\u2192 u]) = value(t)[l 7\u2192 u].\nProof . We proceed by structural induction. In case that t is a label. If t = l then value(l[l 7\u2192 u] = value(u) =\u2193 u = value(l)[l 7\u2192 u]. If t = l\u2032 6= l then value(l\u2032[l 7\u2192 u] = value(l\u2032) =\u2193 l\u2032 = value(l\u2032)[l 7\u2192 u]. In case that t = \u220fT it follows that value(\u220fT [l 7\u2192 u]) = \u22c2 { value(t \u2032[l 7\u2192\nu]) \u2223\u2223 t \u2032 \u2208T }) and by induction hypothesis value(t \u2032[l 7\u2192 u])= value(t \u2032)[l 7\u2192 u]. Then value(\u220fT [l 7\u2192\nu]) = \u22c2 { value(t \u2032)[l 7\u2192 u] \u2223\u2223 t \u2032 \u2208 T }) = value(\u220fT )[l 7\u2192 u]. The cases for t = \u2211T is analogous. In case that t = t1 \u00b7 t2 it follows that value(t[l 7\u2192 u]) = value(t1[l 7\u2192 u]) \u00b7value(t2[l 7\u2192 u]) = value(t1)[l 7\u2192 u] \u00b7 value(t2)[l 7\u2192 u] = value(t)[l 7\u2192 u]\nProof of Theorem 4. From Theorem 2, models I and I\u2032 are respectively equal to TP \u2191 \u03c9 (0) and TP\u2032 \u2191 \u03c9 (0). Furthermore, from Lemma 7.7, it follows that TP\u2032 \u2191 \u03c9 (0)(p) = TP \u2191 \u03c9 (0)(p)[l 7\u2192 u] for any atom p. Lemma 7.11 shows that the replacing can be done in any causal term without operate it.\nProof of Theorem 5. It is clear that if every rule in P is unlabelled, i.e. P = P\u2032, then their least model assigns 0 to every f alse atom and 1 to every true atom, so that their least models coincide with the classical one, i.e. I = I\u2032 and then Icl = I = I\u2032. Otherwise, let Pn be a program where n rules are labelled. We can build a program Pn\u22121 removing one label l and, from Theorem 4, it follows that In\u22121 = In[l\u2192 1]. By induction hypothesis the corresponding classical interpretation of least model of Pn\u22121 coincides with the least model of the unlabelled program, i.e. Icln\u22121 = I\n\u2032, and then In[l 7\u2192 1]cl = Icln\u22121 = I\u2032. Furthermore, for every atom p and c-graph G it holds that G \u2208 In(p) iff G[l 7\u2192 1] \u2208 In[l 7\u2192 1](p). Simple remain to note that value(z) = /0, so that In(p) = 0 iff In[l 7\u2192 1](p) = 0 and consequently Icln = In[l 7\u2192 1]cl = I\u2032.\nProof of Theorem 6. By definition I and Icl assigns 0 to the same atoms, so that PI = PI cl\n. Furthermore let Q (instead of P\u2032 for clarity) be the unlabelled version of P. Then QI cl is the unlabelled version of PI . (1) Let I be a stable model of P and J be the least model of QI cl\n. Then, I is the least model of PI and, from Theorem 5, it follows that Icl = J, i.e. Icl is a stable model of Q. (2) Let I\u2032 is a stable model of Q and I be the least model of PI \u2032 . Since I\u2032 is a stable model of Q, by definition it is the least model of QI \u2032 , furthermore, since QI \u2032 is the unlabelled version of PI \u2032 it follows, from Theorem 5, that Icl = I\u2032. Note that PI = PI cl = PI \u2032 . Thus I is a stable model of P."}, {"heading": "8 Algebraic completeness", "text": "We will show that causal terms with the algebraic properties reflected in Figures 12 and 13 are correct and complete with respect to the algebra of causal values.\nFirst note that the algebraic properties for \u201c\u2217\u201d and \u201c+\u201d reflected Figure 12 are the common algebraic properties satisfy by distributive lattices. Then their correctness follows directly from Theorem 1.\nProposition 15 (Application homomorphism) The mapping \u2193: CLb,\u2212\u2192 VLb is an homomorphism between \u3008CLb, \u00b7\u3009 and \u3008VLb, \u00b7\u3009,\nProof . Take any c-graphs G1 and G2, then \u2193G1 \u00b7 \u2193G2 = \u2193{ (G\u20321 \u00b7G\u20322) \u2223\u2223 G\u20321 \u2208 \u2193G1 and G\u20322 \u2208 \u2193G2 }\n= \u2193{ (G\u20321 \u00b7G\u20322) \u2223\u2223 G\u20321 \u2264 G1 and G\u20322 \u2264 G2 } = \u2193(G1 \u00b7G2)\nNote that, from Proposition 1,it follows that G\u20321 \u00b7G\u20322 \u2264 G1 \u00b7G2. That is, \u2193 in an homomorphism between \u3008CLb, \u00b7\u3009 and \u3008VLb, \u00b7\u3009.\nTheorem 10 (Homomorphism between causal graphs and values) The mapping \u2193: CLb,\u2212\u2192VLb is an injective homomorphism between \u3008CLb,+,\u2217\u00b7\u3009 and \u3008VLb,+,\u2217, \u00b7\u3009,\nProof . This follows directly from the Theorem 1 and Proposition 15\nProposition 16 For every causal term t without addition \u2018+\u2019 there exists a causal graph G such that t = \u2193G.\nProof . In case that t is a label, by definition is the principal ideal \u2193 t. We proceed by structural induction. In case that t = \u220fS, by induction hypothesis, for every ti \u2208 S there is some causal graph Gi such that ti = \u2193Gi and from Theorem 1 it follows that\nt = \u220fS = \u220f{ \u2193Gi \u2223\u2223 ti \u2208 S }= \u2193{ Gi \u2223\u2223 ti \u2208 S }\nwhich is a principal ideal. In case that t = t1 \u00b7 t2, by induction hypothesis, t1 = \u2193G1 and t2 = \u2193G2 and from Proposition 15, it follows that\nt = t1 \u00b7 t2 = \u2193G1 \u00b7 \u2193G2 = \u2193(G1 \u00b7G2)\nwhich is a principal idea.\nLemma 8.1 Let Gu and Gv be two causal graphs. If Gu \u2287 Gv, then term(Gu)\u2264 term(Gv) follows from the equivalence laws reflected in Figures 12 and 13.\nProof . By definition term(Gu)\u2217 term(Gv) is equal to \u220f { u1\u00b7u2 \u2223\u2223 (u1,u2) \u2208 Gu }\u2217\u220f{ v1\u00b7v2 \u2223\u2223 (v1,v2) \u2208 Gv } (11)\nand since, Gu \u2287 Gv, it follows that every edge (v1,v2) \u2208 Gv also belong to Gu. Thus applying associative and conmutative laws we can rewrite (11) as\n\u220f { u1\u00b7u2 \u2223\u2223 (u1,u2) \u2208 Gu\\Gv }\u2217\u220f{ (v1\u00b7v2)\u2217 (v1\u00b7v2) \u2223\u2223 (v1,v2) \u2208 Gv }\nthat, by product idempotence, is clearly equivalent to \u220f { u1\u00b7u2 \u2223\u2223 (u1,u2) \u2208 Gu\\Gv }\u2217\u220f{ (v1\u00b7v2) \u2223\u2223 (v1,v2) \u2208 Gv }\nThat is, term(Gu)\u2217 term(Gv) = term(Gu) which implies term(Gu)\u2264 term(Gv).\nLemma 8.2 Let U and V be two causal values. If U \u2286V , then term(U)\u2264 term(V ) follows from the equivalence laws reflected in Figures 12 and 13.\nProof . By definition term(U)+ term(V ) is equal to \u2211{ term(Gu) \u2223\u2223 Gu \u2208U }+\u2211{ term(Gv) \u2223\u2223 Gv \u2208V } (12)\nand since, U \u2286V , it follows that every c-graph Gu \u2208U also belong to V . Thus applying associative and conmutative laws we can rewrite (12) as\n\u2211 { Gu \u2223\u2223 (u1,u2) \u2208U }+\u2211{ Gv +Gv \u2223\u2223 Gv \u2208V\\U }\nthat, by summ idempotence, is clearly equivalent to \u2211 { Gu \u2223\u2223 (u1,u2) \u2208U }+\u2211{ Gv \u2223\u2223 Gv \u2208V\\U }\nThat is, term(U)+ term(V ) = term(V ) which implies term(U)\u2264 term(V ).\nProposition 17 (Application associativity) Let T , U and W be three causal values. Then, it holds that U \u00b7 (T \u00b7W ) = (U \u00b7T ) \u00b7W and further U \u00b7T \u00b7W = \u2193 { GU \u00b7GT \u00b7GW \u2223\u2223 GU \u2208U, GT \u2208 T and GW \u2208W }. Proof . By definition it follows that\n(U \u00b7T ) \u00b7W = \u2193{ GU \u00b7GT \u2223\u2223 GU \u2208U and GT \u2208 T } \u00b7W\n= \u2193{ G\u2032 \u00b7GW \u2223\u2223 GU \u2208U, GT \u2208 T, G\u2032 \u2264 GU \u00b7GT and GW \u2208W }\n= \u2193{ (GU \u00b7GT ) \u00b7GW \u2223\u2223 GU \u2208U, GT \u2208 T and GW \u2208W }\nIn the same way, it also follows that U \u00b7 (T \u00b7W ) = \u2193{ GU \u00b7 (GT \u00b7GW ) \u2223\u2223 GU \u2208U, GT \u2208 T and GW \u2208W }\nThen it is enough to show that (GU \u00b7GT ) \u00b7GW = GU \u00b7 (GT \u00b7Gw) = GU \u00b7GT \u00b7GW which holds due to Proposition 2.\nProposition 18 (Application absorption) Let T , U and W be three causal values. Then T = T + U \u00b7T \u00b7W and U \u00b7T \u00b7W = T \u2217U \u00b7T \u00b7W\nProof . From Proposition 17 it follows that U \u00b7T \u00b7W = \u2193 { GU \u00b7GT \u00b7GW \u2223\u2223 GU \u2208U, GT \u2208 T and GW \u2208W }\nFurthermore, for every c-graph GT \u2208 T , it holds that GU \u00b7GT \u00b7 TW \u2264 GT . Then, since T is an ideal, it follows that GU \u00b7GT \u00b7TW \u2208 T and consequently U \u00b7T \u00b7W \u2286 T . Thus U \u00b7T \u00b7W \u222aT = T and U \u00b7T \u00b7W \u2229T =U \u00b7T \u00b7W and, by definition, these equalities can be rewritten as U \u00b7T \u00b7W +T = T and U \u00b7T \u00b7W \u2217T =U \u00b7T \u00b7W .\nProposition 19 (Application distributivity w.r.t. additions) Let T , U and W be three causal values. Then, it holds that U \u00b7 (T +W ) = (U \u00b7T )+ (U \u00b7W and (U +T ) \u00b7W = (U \u00b7W )+(T \u00b7W ).\nProof . By definition, it follows that\n(U \u00b7T )+(U \u00b7W ) = (U \u00b7T )\u222a (U \u00b7W ) = \u2193 { GU \u00b7GT \u2223\u2223 GU \u2208U and GT \u2208 T } \u222a \u2193{ GU \u00b7GT \u2223\u2223 GU \u2208U and GW \u2208W } = \u2193 { GU \u00b7G\u2032\n\u2223\u2223 GU \u2208U and G\u2032 \u2208 T \u222aW }=U \u00b7 (T \u222aW ) =U \u00b7 (T +W ) Furthermore (U +T ) \u00b7W = (U \u00b7W )+(T \u00b7W ) holds symmetrically.\nProduct distributivity laws follows from Propositions 5 and 6.\nCorollary 5 The applications distributivity properties reflected in Figure 13 hold.\nProof . From proposition 16, it follows that c, d and e are the principal ideals \u2193Gc, \u2193Gd and \u2193Ge for some c-graphs Gc, Gd and Ge. Furthermore, from Proposition 5 distributivity holds for causal graphs, i.e. Gc \u00b7 (Gd \u2217Ge) = (Gc \u00b7Gd)\u2217 (Gc \u00b7Ge) and (Gc \u2217Gd) \u00b7Ge = (Gc \u00b7Ge)\u2217 (Gd \u00b7Ge) and from Theorem 10 it follows that this also holds for they principal ideals \u2193Gc, \u2193Gd and \u2193Ge. In the same way, from Proposition 6, it follows c \u00b7d \u00b7 e = (c \u00b7d)\u2217 (d \u00b7 e).\nProposition 20 (Application identity and annihilator) Given a causal value T , it holds that T = 1 \u00b7T , T = T \u00b71, 0 = T \u00b70 and 0 = 0 \u00b7T .\nProof . Note that 1 and 0 respectively correspond to CLb and /0 and by definition it follows that 1 \u00b7T = \u2193 { G \u00b7GT \u2223\u2223 G \u2208 CLb and GT \u2208 T }= T\n0 \u00b7T = \u2193 { G \u00b7GT \u2223\u2223 G \u2208 /0 and GT \u2208 T }= /0 = 0\nThe other cases are symmetric.\nProposition 21 (Application idempotentce) Given a label l, it holds that l \u00b7 l = l\nProof . By definition l corresponds to the causal value \u2193Gl where Gl is the causal graphs which contains the only edge (l, l). Furthermore Gl \u00b7Gl = Gl and from Theorem 10 it follows that \u2193Gl = \u2193Gl \u00b7 \u2193Gl and consequently l = l \u00b7 l.\nProposition 22 (Causal term representation) For every causal value T is equal to \u2211 { term(G) \u2223\u2223 G \u2208 T }. Proof . For every causal term T , it holds that T = \u2211{ \u2193G\n\u2223\u2223 G \u2208 T }. Furthermore, from Proposition 3, it follows that every causal graph G is equal to \u220f{ l1 \u00b7 l2\n\u2223\u2223 (l1, l2) is an edge of G } and then, from Theorem 10, it holds that \u2193G = \u220f{ l1 \u00b7 l2\n\u2223\u2223 (l1, l2) is an edge of G }. Consequently T = \u2211{ term(G)\n\u2223\u2223 G \u2208 T }. Proposition 23 Every causal term without sums c can be rewritten as normal(c) def=\u220f{ l1 \u00b7l2)\n\u2223\u2223 (l1, l2) is an edge of G } for some casual graph G using the algebraic equivalences in Figures 12 and 13.\nProof . We start rewritten c as \u220fC where every causal term x \u2208C is in the form of l1 \u00b7 . . . \u00b7 ln by by applying the distributive law until no product is in the scope of \u201c\u00b7\u201d. Then we remove each occurrence of 1 applying the identity law and we replace term x by x \u00b7x when x is a label. That is, we have C\u2032 s.t. every x\u2032 \u2208C is equal to x\u2032 = l1 \u00b7 . . . \u00b7 ln with n > 1 and li 6= 1. Then we rewrite each x\u2032 \u2208C\u2032 as l1 \u00b7 l2 \u2217 l2 \u00b7 l3 \u2217 . . .\u2217 ln\u22121 \u00b7 ln by successively application of the equivalence c \u00b7d \u00b7e = c \u00b7d \u2217 d \u00b7 e. Finally we add every transitive edge applying the equivalence c \u00b7d \u2217d \u00b7 e = c \u00b7d \u2217d \u00b7 e\u2217 c \u00b7 e (Proposition 10).\nProposition 24 Every causal term t can be rewritten as normal(t) def= { normal(c) \u2223\u2223 c \u2208 S } for some set of terms without sums S using the algebraic equivalences in Figures 12 and 13.\nProof . We only have to rewrite t as a causal term where sums are not in the scope of \u201c\u2217\u201d and \u201c\u00b7\u201d by successively application of distributivity over sums. Then the statement holds from Proposition 23\nProposition 25 Let c and d be causal terms without \u201c+\u201d. Then c \u2264 d iff c = c \u2217 d follows from the algebraic equivalences in Figures 12 and 13. Proof . From Proposition 23, c and d can be rewrite as c\u2032 = \u220f{ l1 \u00b7 l2) \u2223\u2223 (l1, l2) is an edge of Gc }\nand d\u2032 = \u220f{ l1 \u00b7 l2) \u2223\u2223 (l1, l2) is an edge of Gd } for some causal graphs Gc and Gd . Furthermore, from Proposition 3 and Theorem 10, it holds that \u2193Gc = c\u2032 and \u2193Gd = d\u2032. Thus, by definition c\u2264 d iff \u2193Gc \u2264 \u2193Gd iff \u2193Gc =\u2193Gc \u2229 \u2193Gd iff \u2193Gc = \u2193Gc \u2217 \u2193Gd iff c\u2032 = c\u2032 \u2217d\u2032. Let us see that c\u2032 = c\u2032 \u2217d\u2032 can be follows from the algebraic equivalences."}], "references": [{"title": "Explicit provability and constructive semantics", "author": ["S.N. ART\u00cbMOV"], "venue": "Bulletin of Symbolic Logic 7, 1, 1\u201336.", "citeRegEx": "ART\u00cbMOV,? 2001", "shortCiteRegEx": "ART\u00cbMOV", "year": 2001}, {"title": "Answer set programming at a glance", "author": ["G. BREWKA", "T. EITER", "M. TRUSZCZYNSKI"], "venue": "Commun. ACM 54, 12, 92\u2013103.", "citeRegEx": "BREWKA et al\\.,? 2011", "shortCiteRegEx": "BREWKA et al\\.", "year": 2011}, {"title": "Compiled Labelled Deductive Systems: A Uniform Presentation of Non-Classical Logics", "author": ["K. BRODA", "D. GABBAY", "L. LAMB", "A. RUSSO."], "venue": "Research Studies Press.", "citeRegEx": "BRODA et al\\.,? 2004", "shortCiteRegEx": "BRODA et al\\.", "year": 2004}, {"title": "Logic programs and causal proofs", "author": ["P. CABALAR"], "venue": "AAAI Spring Symposium: Logical Formalizations of Commonsense Reasoning. AAAI.", "citeRegEx": "CABALAR,? 2011", "shortCiteRegEx": "CABALAR", "year": 2011}, {"title": "An algebra of causal chains", "author": ["P. CABALAR", "J. FANDINNO"], "venue": "Proc. of the 6th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP\u201913).", "citeRegEx": "CABALAR and FANDINNO,? 2013", "shortCiteRegEx": "CABALAR and FANDINNO", "year": 2013}, {"title": "Justifications for logic programming", "author": ["C.V. DAM\u00c1SIO", "A. ANALYTI", "G. ANTONIOU"], "venue": "Proc. of the 12th Intl. Conf. on Logic Programming and Nonmonotonic Reasoning, (LPNMR\u201913). Lecture Notes in Computer Science, vol. 8148. Springer, 530\u2013542.", "citeRegEx": "DAM\u00c1SIO et al\\.,? 2013", "shortCiteRegEx": "DAM\u00c1SIO et al\\.", "year": 2013}, {"title": "Justification semantics: A unifiying framework for the semantics of logic programs", "author": ["M. DENECKER", "D. DE SCHREYE"], "venue": "Proc. of the Logic Programming and Nonmonotonic Reasoning Workshop. 365\u2013379.", "citeRegEx": "DENECKER and SCHREYE,? 1993", "shortCiteRegEx": "DENECKER and SCHREYE", "year": 1993}, {"title": "A new fixpoint semantics for general logic programs compared with the well-founded and the stable model semantics", "author": ["F. FAGES"], "venue": "New Generation Computing 9, 3-4, 425\u2013443.", "citeRegEx": "FAGES,? 1991", "shortCiteRegEx": "FAGES", "year": 1991}, {"title": "Meta-programming technique for debugging answer-set programs", "author": ["M. GEBSER", "J. P\u00dcHRER", "T. SCHAUB", "H. TOMPITS"], "venue": "Proc. of the 23rd Conf. on Artificial Inteligence (AAAI\u201908). 448\u2013453.", "citeRegEx": "GEBSER et al\\.,? 2008", "shortCiteRegEx": "GEBSER et al\\.", "year": 2008}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Logic Programming: Proc. of the Fifth International Conference and Symposium (Volume 2), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Cambridge, MA, 1070\u20131080.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "Two concepts of causality", "author": ["N. HALL"], "venue": "181\u2013276.", "citeRegEx": "HALL,? 2004", "shortCiteRegEx": "HALL", "year": 2004}, {"title": "Defaults and normality in causal structures", "author": ["J.Y. HALPERN"], "venue": "Proc. of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning (KR 2008). 198\u2013208.", "citeRegEx": "HALPERN,? 2008", "shortCiteRegEx": "HALPERN", "year": 2008}, {"title": "Causes and explanations: A structural-model approach", "author": ["J.Y. HALPERN", "J. PEARL"], "venue": "part I: Causes. British Journal for Philosophy of Science 56, 4, 843\u2013887.", "citeRegEx": "HALPERN and PEARL,? 2005", "shortCiteRegEx": "HALPERN and PEARL", "year": 2005}, {"title": "Cause and norm", "author": ["C. HITCHCOCK", "J. KNOBE"], "venue": "Journal of Philosophy 11, 587\u2013612.", "citeRegEx": "HITCHCOCK and KNOBE,? 2009", "shortCiteRegEx": "HITCHCOCK and KNOBE", "year": 2009}, {"title": "An enquiry concerning human understanding", "author": ["D. HUME"], "venue": "Reprinted by Open Court Press, LaSalle, IL, 1958.", "citeRegEx": "HUME,? 1748", "shortCiteRegEx": "HUME", "year": 1748}, {"title": "Theory of generalized annotated logic programming and its applications", "author": ["M. KIFER", "V.S. SUBRAHMANIAN"], "venue": "Journal of Logic Programming 12.", "citeRegEx": "KIFER and SUBRAHMANIAN,? 1992", "shortCiteRegEx": "KIFER and SUBRAHMANIAN", "year": 1992}, {"title": "A practical analysis of non-termination in large logic programs", "author": ["S. LIANG", "M. KIFER"], "venue": "TPLP 13, 4-5, 705\u2013719.", "citeRegEx": "LIANG and KIFER,? 2013", "shortCiteRegEx": "LIANG and KIFER", "year": 2013}, {"title": "Embracing causality in specifying the indirect effects of actions", "author": ["LIN F."], "venue": "Proc. of the Intl. Joint Conf. on Artificial Intelligence (IJCAI), C. S. Mellish, Ed. Morgan Kaufmann, Montreal, Canada.", "citeRegEx": "F.,? 1995", "shortCiteRegEx": "F.", "year": 1995}, {"title": "Causal theories of actions revisited", "author": ["F. LIN", "M. SOUTCHANSKI"], "venue": "AAAI Spring Symposium: Logical Formalizations of Commonsense Reasoning.", "citeRegEx": "LIN and SOUTCHANSKI,? 2011", "shortCiteRegEx": "LIN and SOUTCHANSKI", "year": 2011}, {"title": "Causal theories of action and change", "author": ["N. MCCAIN", "H. TURNER"], "venue": "Proc. of the AAAI-97. 460\u2013465.", "citeRegEx": "MCCAIN and TURNER,? 1997", "shortCiteRegEx": "MCCAIN and TURNER", "year": 1997}, {"title": "Causality in commonsense reasoning about actions", "author": ["N.C. MCCAIN"], "venue": "Tech. rep.", "citeRegEx": "MCCAIN,? 1997", "shortCiteRegEx": "MCCAIN", "year": 1997}, {"title": "Epistemological problems of Artificial Intelligence", "author": ["J. MCCARTHY"], "venue": "Proc. of the Intl. Joint Conf. on Artificial Intelligence (IJCAI). MIT Press, Cambridge, MA, 1038\u20131044.", "citeRegEx": "MCCARTHY,? 1977", "shortCiteRegEx": "MCCARTHY", "year": 1977}, {"title": "Elaboration tolerance", "author": ["J. MCCARTHY"], "venue": "Proc. of the 4th Symposium on Logical Formalizations of Commonsense Reasoning (Common Sense 98). London, UK, 198\u2013217. Updated version at http://www-formal.stanford.edu/jmc/elaboration.ps.", "citeRegEx": "MCCARTHY,? 1998", "shortCiteRegEx": "MCCARTHY", "year": 1998}, {"title": "Equilibrium logic", "author": ["D. PEARCE"], "venue": "Ann. Math. Artif. Intell. 47, 1-2, 3\u201341.", "citeRegEx": "PEARCE,? 2006", "shortCiteRegEx": "PEARCE", "year": 2006}, {"title": "Causality: models, reasoning, and inference", "author": ["J. PEARL"], "venue": "Cambridge University Press, New York, NY, USA.", "citeRegEx": "PEARL,? 2000", "shortCiteRegEx": "PEARL", "year": 2000}, {"title": "Derivation procedures for extended stable models", "author": ["L.M. PEREIRA", "J.N. APAR\u00cdCIO", "J.J. ALFERES"], "venue": "Proceedings of the 12th International Joint Conference on Artificial Intelligence, J. Mylopoulos and R. Reiter, Eds. Morgan Kaufmann, 863\u2013869.", "citeRegEx": "PEREIRA et al\\.,? 1991", "shortCiteRegEx": "PEREIRA et al\\.", "year": 1991}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. PONTELLI", "T.C. SON", "O. EL-KHATIB"], "venue": "Theory and Practice of Logic Programming 9, 1, 1\u201356.", "citeRegEx": "PONTELLI et al\\.,? 2009", "shortCiteRegEx": "PONTELLI et al\\.", "year": 2009}, {"title": "Argumentation-based answer set justification", "author": ["C. SCHULZ", "M. SERGOT", "F. TONI"], "venue": "Proc. of the 11th Intl. Symposium on Logical Formalizations of Commonsense Reasoning (Commonsense\u201913).", "citeRegEx": "SCHULZ et al\\.,? 2013", "shortCiteRegEx": "SCHULZ et al\\.", "year": 2013}, {"title": "Free distributive completions of partial complete lattices", "author": ["G. STUMME"], "venue": "Order 14, 179\u2013189.", "citeRegEx": "STUMME,? 1997", "shortCiteRegEx": "STUMME", "year": 1997}, {"title": "Ramification and causality", "author": ["M. THIELSCHER"], "venue": "Artificial Intelligence Journal 1-2, 89, 317\u2013364.", "citeRegEx": "THIELSCHER,? 1997", "shortCiteRegEx": "THIELSCHER", "year": 1997}, {"title": "A constructive approach to the ramification problem", "author": ["K. VAN BELLEGHEM", "M. DENECKER", "D. THESEIDER-DUPR\u00c9"], "venue": "Proceedings of ESSLLI. Citeseer, 1\u201317.", "citeRegEx": "BELLEGHEM et al\\.,? 1998", "shortCiteRegEx": "BELLEGHEM et al\\.", "year": 1998}, {"title": "The semantics of predicate logic as a programming language", "author": ["M.H. VAN EMDEN", "R.A. KOWALSKI"], "venue": "J. ACM 23, 4, 733\u2013742.", "citeRegEx": "EMDEN and KOWALSKI,? 1976", "shortCiteRegEx": "EMDEN and KOWALSKI", "year": 1976}, {"title": "Actual causation in cp-logic", "author": ["J. VENNEKENS"], "venue": "TPLP 11, 4-5, 647\u2013662.", "citeRegEx": "VENNEKENS,? 2011", "shortCiteRegEx": "VENNEKENS", "year": 2011}], "referenceMentions": [{"referenceID": 22, "context": "If the pseudo-literal \u201cdo(A,X) caused occurs(Y )\u201d actually corresponds to an explicit representation of all the possible ways of causing an accident, however, one immediately runs into a problem of elaboration tolerance (McCarthy 1998) \u2014 adding new rules that causally connect do(A,X) to occurs(Y ) (in a direct or indirect way) would force us to build new rules for responsible(X ,Y ).", "startOffset": 220, "endOffset": 235}, {"referenceID": 1, "context": "While not straightforward, the rewarding perspective of such a semantic approach is an extension of Answer Set Programming (ASP) (Brewka et al. 2011) with causal literals capable of representing different kinds of causal influences (sufficient cause, necessary cause, etc).", "startOffset": 129, "endOffset": 149}, {"referenceID": 9, "context": "To this end, we propose a multi-valued extension of logic programs under the stable model semantics (Gelfond and Lifschitz 1988) where each true atom in a model is associated with a set of justifications in the form of causal graphs.", "startOffset": 100, "endOffset": 128}, {"referenceID": 28, "context": "Using terminology and results from lattice theory in (Stumme 1997) we can prove the following.", "startOffset": 53, "endOffset": 66}, {"referenceID": 28, "context": "1 We use terminology from (Stumme 1997).", "startOffset": 26, "endOffset": 39}, {"referenceID": 15, "context": "The proof of this theorem relies on an encoding of causal logic programs into Generalized Annotated Logic Programming (GAP) (Kifer and Subrahmanian 1992) and applying existing results for that general multi-valued LP framework.", "startOffset": 124, "endOffset": 153}, {"referenceID": 9, "context": "To capture this behaviour, we proceed to extend the traditional program reduct (Gelfond and Lifschitz 1988) to causal logic programs.", "startOffset": 79, "endOffset": 107}, {"referenceID": 21, "context": "4 A case of the well-known qualification problem (McCarthy 1977), i.", "startOffset": 49, "endOffset": 64}, {"referenceID": 13, "context": "5 The paper (Hitchcock and Knobe 2009) contains an extended discussion with several examples showing how people ordinarily understand causes as deviations from a norm.", "startOffset": 12, "endOffset": 38}, {"referenceID": 4, "context": "A preliminary version (Cabalar and Fandinno 2013) of the current approach relied on chains of labels but was actually weaker, missing basic properties we can derive now from causal graphs.", "startOffset": 22, "endOffset": 49}, {"referenceID": 19, "context": "Papers on reasoning about actions and change (Lin 1995; McCain and Turner 1997; Thielscher 1997) have been traditionally focused on using causal inference to solve representational problems (mostly, the frame, ramification and qualification problems) without paying much attention to the derivation of cause-effect relations.", "startOffset": 45, "endOffset": 96}, {"referenceID": 29, "context": "Papers on reasoning about actions and change (Lin 1995; McCain and Turner 1997; Thielscher 1997) have been traditionally focused on using causal inference to solve representational problems (mostly, the frame, ramification and qualification problems) without paying much attention to the derivation of cause-effect relations.", "startOffset": 45, "endOffset": 96}, {"referenceID": 24, "context": "Perhaps the most established AI approach for causality is relying on causal networks (Pearl 2000; Halpern and Pearl 2005; Halpern 2008).", "startOffset": 85, "endOffset": 135}, {"referenceID": 12, "context": "Perhaps the most established AI approach for causality is relying on causal networks (Pearl 2000; Halpern and Pearl 2005; Halpern 2008).", "startOffset": 85, "endOffset": 135}, {"referenceID": 11, "context": "Perhaps the most established AI approach for causality is relying on causal networks (Pearl 2000; Halpern and Pearl 2005; Halpern 2008).", "startOffset": 85, "endOffset": 135}, {"referenceID": 2, "context": "Apart from the different AI approaches and attitudes towards causality, from the technical point of view, the current approach can be classified as a labelled deductive system (Broda et al. 2004).", "startOffset": 176, "endOffset": 195}, {"referenceID": 2, "context": "6 Related Work Cabalar (2011) already introduced the main motivations of our work, but used ad hoc operations on proof trees without resorting to algebraic structures.", "startOffset": 15, "endOffset": 30}, {"referenceID": 2, "context": "6 Related Work Cabalar (2011) already introduced the main motivations of our work, but used ad hoc operations on proof trees without resorting to algebraic structures. A preliminary version (Cabalar and Fandinno 2013) of the current approach relied on chains of labels but was actually weaker, missing basic properties we can derive now from causal graphs. There exists a vast literature on causal reasoning in Artificial Intelligence. Papers on reasoning about actions and change (Lin 1995; McCain and Turner 1997; Thielscher 1997) have been traditionally focused on using causal inference to solve representational problems (mostly, the frame, ramification and qualification problems) without paying much attention to the derivation of cause-effect relations. Perhaps the most established AI approach for causality is relying on causal networks (Pearl 2000; Halpern and Pearl 2005; Halpern 2008). In this approach, it is possible to conclude cause-effect relations like \u201cA has caused B\u201d from the behaviour of structural equations by applying the counterfactual interpretation from Hume (1748): \u201chad A not happened, B would not have happened.", "startOffset": 15, "endOffset": 1095}, {"referenceID": 2, "context": "6 Related Work Cabalar (2011) already introduced the main motivations of our work, but used ad hoc operations on proof trees without resorting to algebraic structures. A preliminary version (Cabalar and Fandinno 2013) of the current approach relied on chains of labels but was actually weaker, missing basic properties we can derive now from causal graphs. There exists a vast literature on causal reasoning in Artificial Intelligence. Papers on reasoning about actions and change (Lin 1995; McCain and Turner 1997; Thielscher 1997) have been traditionally focused on using causal inference to solve representational problems (mostly, the frame, ramification and qualification problems) without paying much attention to the derivation of cause-effect relations. Perhaps the most established AI approach for causality is relying on causal networks (Pearl 2000; Halpern and Pearl 2005; Halpern 2008). In this approach, it is possible to conclude cause-effect relations like \u201cA has caused B\u201d from the behaviour of structural equations by applying the counterfactual interpretation from Hume (1748): \u201chad A not happened, B would not have happened.\u201d As discussed by Hall (2004), the counterfactual-based definition of causation corresponds to recognising some kind of dependence relation in the behaviour of a non-causal system description.", "startOffset": 15, "endOffset": 1173}, {"referenceID": 2, "context": "Apart from the different AI approaches and attitudes towards causality, from the technical point of view, the current approach can be classified as a labelled deductive system (Broda et al. 2004). In particular, the work that has had a clearest and most influential relation to the current proposal is the Logic of Proofs (LP) by Art\u00ebmov (2001). We have borrowed from that formalism part of the notation for our causal terms and rule labellings and the fundamental idea of keeping track of justifications by considering rule applications.", "startOffset": 177, "endOffset": 345}, {"referenceID": 8, "context": "Focusing on LP, our work obviously relates to explanations as provided by approaches to debugging in ASP (Gebser et al. 2008; Pontelli et al. 2009; Schulz et al. 2013; Dam\u00e1sio et al. 2013).", "startOffset": 105, "endOffset": 188}, {"referenceID": 26, "context": "Focusing on LP, our work obviously relates to explanations as provided by approaches to debugging in ASP (Gebser et al. 2008; Pontelli et al. 2009; Schulz et al. 2013; Dam\u00e1sio et al. 2013).", "startOffset": 105, "endOffset": 188}, {"referenceID": 27, "context": "Focusing on LP, our work obviously relates to explanations as provided by approaches to debugging in ASP (Gebser et al. 2008; Pontelli et al. 2009; Schulz et al. 2013; Dam\u00e1sio et al. 2013).", "startOffset": 105, "endOffset": 188}, {"referenceID": 32, "context": ", by the counterfactualbased causal LP approach (Vennekens 2011).", "startOffset": 48, "endOffset": 64}, {"referenceID": 23, "context": "An interesting issue is to replace the syntactic definition by a reduct in favour of a logical treatment of default negation, as has been done for (noncausal) stable models and their characterisation in terms of Equilibrium Logic (Pearce 2006).", "startOffset": 230, "endOffset": 243}, {"referenceID": 7, "context": "Focusing on LP, our work obviously relates to explanations as provided by approaches to debugging in ASP (Gebser et al. 2008; Pontelli et al. 2009; Schulz et al. 2013; Dam\u00e1sio et al. 2013). Pereira et al. (1991) and Denecker and De Schreye (1993) also define different semantics in terms of justifications, but do not provide calculi for them.", "startOffset": 106, "endOffset": 212}, {"referenceID": 7, "context": "Focusing on LP, our work obviously relates to explanations as provided by approaches to debugging in ASP (Gebser et al. 2008; Pontelli et al. 2009; Schulz et al. 2013; Dam\u00e1sio et al. 2013). Pereira et al. (1991) and Denecker and De Schreye (1993) also define different semantics in terms of justifications, but do not provide calculi for them.", "startOffset": 106, "endOffset": 247}, {"referenceID": 7, "context": "Fages (1991) characterised stable models in terms of loop-free justifications expressed as partial order relations among atoms in positive bodies.", "startOffset": 0, "endOffset": 13}, {"referenceID": 7, "context": "Fages (1991) characterised stable models in terms of loop-free justifications expressed as partial order relations among atoms in positive bodies. We conjecture that the causal values obtained in our semantics formally capture Fages\u2019 justifications. A more far-fetched resemblance exists to work on the analysis of tabled Prolog computations. There, the goal is to identify potential causes for non-termination of program evaluations, which can be achieved examining so-called forest logs, i.e., a log of table operations for a computation. By adding unique labels for rules (with the original intention to disambiguate analysis results, cf. Liang and Kifer (2013), however not as an explicit means for representing knowledge), in principle a forest log implicitly contains the information necessary to read of the causal model of a completely labelled positive causal logic program.", "startOffset": 0, "endOffset": 665}, {"referenceID": 7, "context": "Fages (1991) characterised stable models in terms of loop-free justifications expressed as partial order relations among atoms in positive bodies. We conjecture that the causal values obtained in our semantics formally capture Fages\u2019 justifications. A more far-fetched resemblance exists to work on the analysis of tabled Prolog computations. There, the goal is to identify potential causes for non-termination of program evaluations, which can be achieved examining so-called forest logs, i.e., a log of table operations for a computation. By adding unique labels for rules (with the original intention to disambiguate analysis results, cf. Liang and Kifer (2013), however not as an explicit means for representing knowledge), in principle a forest log implicitly contains the information necessary to read of the causal model of a completely labelled positive causal logic program. 7 Conclusions In this paper we have provided a multi-valued semantics for normal logic programs whose truth values form a lattice of causal graphs. A causal graph is nothing else but a graph of rule labels that reflects some order of rule applications. In this way, a model assigns to each true atom a value that contains justifications for its derivation from the existing rules. We have further provided three basic operations on the lattice: an addition, that stands for alternative, independent justifications; a product, that represents joint interaction of causes; and a concatenation that reflects rule application. We have shown that, for positive programs, there exists a least model that coincides with the least fixpoint of a direct consequences operator, analogous to van Emden and Kowalski (1976). With this, we are able to prove a direct correspondence between the semantic values we obtain and the syntactic idea of proof.", "startOffset": 0, "endOffset": 1694}, {"referenceID": 17, "context": "An example of causal action theory In this section we consider a more elaborated example from Pearl (2000).", "startOffset": 12, "endOffset": 107}, {"referenceID": 23, "context": "As commented by Pearl (2000), the interesting feature of this circuit is that, seen from outside as a black box, it behaves exactly as a pair of independent, parallel switches, so it is impossible to detect the causal dependence between a and b by a mere observation of performed actions and their effects on the lamp.", "startOffset": 16, "endOffset": 29}, {"referenceID": 20, "context": "(McCain 1997).", "startOffset": 0, "endOffset": 13}, {"referenceID": 18, "context": "An iteresting variation of this example is incorporating some mechanic device to stop the wheels (Van Belleghem et al. 1998; Lin and Soutchanski 2011).", "startOffset": 97, "endOffset": 150}, {"referenceID": 28, "context": "Stumme was showed in (Stumme 1997) that the concept lattice B\u3008F,VLb,\u2206\u3009 (with F\u2206I\u21d4 F \u2229 I 6= / 0) is isomorphic to the free completely distributive complete lattice generated by the partial lattice \u3008CLb,+,\u2217\u3009 where + and \u2217 are two partial functions corresponding with the supremum and infimum.", "startOffset": 21, "endOffset": 34}, {"referenceID": 15, "context": "Thus, from Theorem 1 in (Kifer and Subrahmanian 1992), it follows that the operator TP is monotonic.", "startOffset": 24, "endOffset": 53}, {"referenceID": 15, "context": "Thus from Theorem 3 in (Kifer and Subrahmanian 1992), it follows that TP \u2191 \u03c9 (0) = l f p(TP) and this is the least model of P.", "startOffset": 23, "endOffset": 52}], "year": 2014, "abstractText": "In this work we propose a multi-valued extension of logic programs under the stable models semantics where each true atom in a model is associated with a set of justifications. These justifications are expressed in terms of causal graphs formed by rule labels and edges that represent their application ordering. For positive programs, we show that the causal justifications obtained for a given atom have a direct correspondence to (relevant) syntactic proofs of that atom using the program rules involved in the graphs. The most interesting contribution is that this causal information is obtained in a purely semantic way, by algebraic operations (product, sum and application) on a lattice of causal values whose ordering relation expresses when a justification is stronger than another. Finally, for programs with negation, we define the concept of causal stable model by introducing an analogous transformation to Gelfond and Lifschitz\u2019s program reduct. As a result, default negation behaves as \u201cabsence of proof\u201d and no justification is derived from negative literals, something that turns out convenient for elaboration tolerance, as we explain with a running example.", "creator": "LaTeX with hyperref package"}}}