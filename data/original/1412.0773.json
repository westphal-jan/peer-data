{"id": "1412.0773", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Dec-2014", "title": "Expressiveness of Logic Programs under General Stable Model Semantics", "abstract": "The stable model semantics had been recently generalized to non-Herbrand structures by several works, which provides a unified framework and solid logical foundations for answer set programming. This paper focuses on the expressiveness of normal and disjunctive programs under the general stable model semantics. A translation from disjunctive programs to normal programs is proposed for infinite structures. Over finite structures, some disjunctive programs are proved to be intranslatable to normal programs if the arities of auxiliary predicates and functions are bounded in a certain way. The equivalence of the expressiveness of normal programs and disjunctive programs over arbitrary structures is also shown to coincide with that over finite structures, and coincide with whether NP is closed under complement. Moreover, to capture the exact expressiveness, some intertranslatability results between logic program classes and fragments of second-order logic are obtained.", "histories": [["v1", "Tue, 2 Dec 2014 03:29:20 GMT  (38kb)", "http://arxiv.org/abs/1412.0773v1", "Technical report, an extended version ofarXiv:1304.0620"]], "COMMENTS": "Technical report, an extended version ofarXiv:1304.0620", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["heng zhang", "yan zhang"], "accepted": false, "id": "1412.0773"}, "pdf": {"name": "1412.0773.pdf", "metadata": {"source": "CRF", "title": "Expressiveness of Logic Programs under General Stable Model Semantics", "authors": ["Heng Zhang", "Yan Zhang"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n41 2.\n07 73\nv1 [\ncs .A"}, {"heading": "Introduction", "text": "Logic programming with default negation is an elegant and efficient formalism for knowledge representation, which incorporates the abilities of classical logic, inductive definition and commonsense reasoning. Nowadays, the most popular semantics for this formalism is the stable model semantics proposed by [16]. Logic programming based on this semantics, which is known as answer-set programming, has then emerged as a flourishing paradigm for declarative programming in the last fifteen years.\nThe original stable model semantics focuses only on Herbrand structures in which the unique name assumption is made. For a certain class of applications, this assumption will simplify the representation. However, there are many applications where the\nknowledge can be more naturally represented over non-Herbrand structures, including arithmetical structures and other metafinite structures. To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via Go\u0308del\u2019s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.\nThe main goal of this work is to identify the expressiveness of logic programs, which is one of the central topics in knowledge representation and reasoning. We will focus on two important classes of logic programs \u2013 normal programs and disjunctive programs. Over Herbrand structures, the expressiveness of logic programs under the query equivalence has been thoroughly studied in the last three decades. An excellent survey for these works can be found in [5]. Our task is quite different. On the one hand, we will work on the general stable model semantics so that non-Herbrand structures will be considered. On the other hand, instead of considering query equivalence, the expressiveness in our work will be based on model equivalence. This setting is important since answer set solvers are usually used to generate models. The model equivalence implies the query equivalence, but the converse is in general not true.\nWe also hope this work contributing to the effective implementation of answer set solvers. Translating logic programs into classical logics is a usual approach to implement answer set solvers, e.g., [22, 21]. In this work, we are interested in translating normal programs to first-order sentences so that the state-of-the-art SMT solvers can be used for answer set solving. As the arity of auxiliary symbol is the most important factor to introduce nondeterminism [18], we will try to find translations with small arities of auxiliary symbols.\nOur contribution in this paper is fourfold. Firstly, we show that, over infinite structures, every disjunctive program can be equivalently translated to a normal one. Secondly, we prove that, if finite structures are focused, for each integer n greater than 1 there is a disjunctive program with intensional predicates of arities less than n that cannot be equivalently translated to any normal program with auxiliary predicates of arities less than 2n. Thirdly, we show that disjunctive and normal programs are of the same expressiveness over arbitrary structures if and only if they are of the same expressiveness over finite structures, if and only if the complexity class NP is closed under complement. Lastly, to understand the exact expressiveness of logic programs, we also prove that the intertranslatability holds between some classes of logic programs and some fragments of second-order logic."}, {"heading": "Preliminaries", "text": "Vocabularies are assumed to be sets of predicate constants and function constants. Logical symbols are as usual, including a countable set of predicate variables and a countable set of function variables. Every constant or variable is equipped with a natural number, its arity. Nullary function constants and variables are called individual constants and variables respectively. Nullary predicate constants are called propositions. Sometimes, we do not distinguish between constants and variables, and simply call them predicates or functions if no confusion occurs. Atoms, formulas, sentences\nand theories of a vocabulary \u03c5 (or shortly, \u03c5-atoms, \u03c5-formulas, \u03c5-sentences and \u03c5theories) are built from \u03c5, equality, variables, connectives and quantifiers in a standard way. Every positive clause of \u03c5 is a finite disjunction of \u03c5-atoms. Given a sentence \u03d5 and a theory \u03a3, let \u03c5(\u03d5) and \u03c5(\u03a3) denote the sets of constants occurring in \u03d5 and \u03a3 respectively.\nAssuming Q to be \u2200 or \u2203, let Q\u03c4 and Qx\u0304 denote the quantifier blocks QX1 \u00b7 \u00b7 \u00b7QXn and Qx1 \u00b7 \u00b7 \u00b7Qxm respectively if \u03c4 is the finite set {X1, . . . , Xn}, x\u0304 = x1 \u00b7 \u00b7 \u00b7xm, Xi and xi are predicate/function and individual variables respectively. Let \u03a31Fn,k be the class of sentences of form Q1\u03c41 \u00b7 \u00b7 \u00b7Qn\u03c4n\u03d5, where Qi is \u2203 if i is odd, otherwise it is \u2200; \u03c4i is a finite set of variables of arities \u2264 k; and no second-order quantifier appears in \u03d5. Let \u03a31n,k denote the class defined as the same as \u03a3 1F n,k except no function variable allowed in any \u03c4i. Let \u03a31Fn (respectively, \u03a31n) be the union of \u03a31Fn,k (respectively, \u03a3 1 n,k) for all k \u2265 0. Given a class \u03a3 defined as above, let \u03a3[\u2200\u2217\u2203\u2217] (respectively, \u03a3[\u2200\u2217]) be the class of sentences in \u03a3 with first-order part of form \u2200x\u0304\u2203y\u0304\u03d1 (respectively, \u2200x\u0304\u03d1), where x\u0304 and y\u0304 are tuples of individual variables, and \u03d1 quantifier-free.\nEvery structure A of \u03c5 (or shortly, \u03c5-structure A) is accompanied by a nonempty set A, the domain of A, and interprets each n-ary predicate constant P in \u03c5 as an nary relation PA on A, and interprets each n-ary function constant f in \u03c5 as an n-ary function fA on A. A structure is finite if its domain is finite; otherwise it is infinite. Let FIN denote the class of finite structures, and let INF denote the class of infinite structures. A restriction of a structure A to a vocabulary \u03c3 is the structure obtained from A by discarding all interpretations for constants not in \u03c3. Given a vocabulary \u03c5 \u2283 \u03c3 and a \u03c3-structure B, every \u03c5-expansion of B is a structure A of \u03c5 such that B is a restriction of A to \u03c3. Given a structure A and a set \u03c4 of predicates, let INS(A, \u03c4) be the set of ground atoms P (a\u0304) for all a\u0304 \u2208 PA and all P in \u03c4 .\nEvery assignment in a structureA is a function that maps each individual variable to an element of A and maps each predicate (respectively, function) variable to a relation (respectively, function) on A of the same arity. Given a formula \u03d5 and an assignment \u03b1 in A, write A |= \u03d5[\u03b1] if \u03b1 satisfies \u03d5 in A in the standard way. In particular, if \u03d5 is a sentence, simply write A |= \u03d5, and say A is a model of \u03d5, or in other words, \u03d5 is true in A. Given formulas \u03d5, \u03c8 and a class C of structures, we say \u03d5 is equivalent to \u03c8 over C, or write \u03d5 \u2261C \u03c8 for short, if for every A in C and every assignment \u03b1 in A, \u03b1 satisfies \u03d5 in A if and only if \u03b1 satisfies \u03c8 in A. Given a quantifier-free formula \u03d5 and an assignment \u03b1 in A, let \u03d5[\u03b1] denote the ground formula obtained from \u03d5 by substituting a for t whenever a = \u03b1(t) and t is a term.\nA class of structures is also called a property. Let C and D be two properties. We say D is defined by a sentence \u03d5 over C, or equivalently, \u03d5 defines D over C, if each structure of C is in D if and only if it is a model of \u03d5; D is definable in a class \u03a3 of sentences over C if there is a sentence in \u03a3 that defines D over C. Given two classes \u03a3,\u039b of sentences, we write \u03a3 \u2264C \u039b if each property definable in \u03a3 over C is also definable in \u039b over C; we write \u03a3 \u2243C \u039b if both \u03a3 \u2264C \u039b and \u039b \u2264C \u03a3 hold. In particular, if C is the class of arbitrary structures, the subscript C can be dropped."}, {"heading": "Logic Programs and Stable Models", "text": "Every disjunctive program is a set of rules of the form\n\u03b61 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b6m \u2192 \u03b6m+1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03b6n (1)\nwhere 0 \u2264 m \u2264 n and n > 0; \u03b6i is an atom not involving the equality if m < i \u2264 n; \u03b6j is a literal, i.e. an atom or the negation of an atom, if 1 \u2264 j \u2264 m. Given a rule, the disjunctive part is called its head, and the conjunctive part is called its body. Given a disjunctive program \u03a0, a predicate is called intensional (w.r.t. \u03a0) if it appears in the head of some rule in \u03a0; a formula is called intensional (w.r.t. \u03a0) if it does not involve any non-intensional predicate. Let \u03c5(\u03a0) be the set of predicates and functions appearing in \u03a0.\nLet \u03a0 be a disjunctive program. Then \u03a0 is called normal if the head of each rule contains at most one atom, \u03a0 is plain if the negation of any intensional atom does not appear in the body of any rule, \u03a0 is propositional if it does not involve any predicate of positive arity, and \u03a0 is finite if it contains only a finite set of rules. In particular, unless mentioned otherwise, a disjunctive program is always assumed to be finite.\nGiven any disjunctive program \u03a0, let SM(\u03a0) denote the second-order sentence \u03d5\u2227 \u2200\u03c4\u2217(\u03c4\u2217 < \u03c4 \u2192 \u00ac\u03d5\u2217), where \u03c4 is the set of intensional predicates; \u03c4\u2217 is the set of predicate variables P \u2217 for all predicates P in \u03c4 ; \u03c4\u2217 < \u03c4 is the formula \u2227P\u2208\u03c4\u2200x\u0304(P \u2217(x\u0304) \u2192 P (x\u0304))\u2227\u00ac\u2227P\u2208\u03c4 \u2200x\u0304(P (x\u0304) \u2192 P \u2217(x\u0304)); \u03d5 is the conjunction of all the sentences \u03b3\u2200 such that \u03b3 is a rule in \u03a0 and \u03b3\u2200 is the first-order universal closure of \u03b3; \u03d5\u2217 is the formula obtained from \u03d5 by substituting P \u2217 for all positive occurrences of P in the head or in the body of each rule if P is in \u03c4 . (So, all negations in intensional literals are default negations.) A structure A is called a stable model of \u03a0 if it satisfies SM(\u03a0). For more details about this transformation, please refer to [14].\nGiven two properties C and D, we say D is defined by a disjunctive program \u03a0 over C via the set \u03c4 of auxiliary constants if the formula \u2203\u03c4SM(\u03a0) defines D over C, where \u03c4 is a set of predicates and functions occurring in \u03a0. Given n \u2265 0, let DLPn (respectively, DLPFn) be the class of sentences \u2203\u03c4SM(\u03a0) for all disjunctive programs \u03a0 and all finite sets \u03c4 of predicate (respectively, predicate and function) constants of arities \u2264 n. Let DLP (respectively,DLPF) be the union of DLPn (respectively,DLP F n) for all n \u2265 0. In above definitions, if \u03a0 is restricted to be normal, we then obtain the notations NLPn,NLP F n,NLP and NLP\nF respectively. Given a rule \u03b3, let \u03b3\u2212B be the set of conjuncts in the body of \u03b3 in which no intensional predicate positively occurs, and let \u03b3+ be the rule obtained from \u03b3 by removing all literals in \u03b3\u2212B . Given a disjunctive program \u03a0 and a structure A, let \u03a0\nA be the set of rules \u03b3+[\u03b1] for all assignments \u03b1 in A and all rules \u03b3 in \u03a0 such that \u03b1 satisfies \u03b3\u2212B in A. Now, \u03a0A can be regarded as a propositional program where each ground atom as a proposition. This procedure is called the first-order Gelfond-Lifschitz reduction due to the following result:\nProposition 1 ([28], Proposition 4). Let \u03a0 be a disjunctive program and \u03c4 the set of intensional predicates. Then an \u03c5(\u03a0)-structure A is a stable model of \u03a0 iff INS(A, \u03c4) is a minimal (w.r.t. the set inclusion) model of \u03a0A."}, {"heading": "Progression Semantics", "text": "In this subsection, we review a progression semantics proposed by [28], which generalizes the fixed point semantics of [24] to logic programming with default negation over arbitrary structures. For convenience, two positive clauses consisting of the same set of atoms will be regarded as the same.\nLet \u03a0 be a propositional, possibly infinite and plain disjunctive program. Let PC(\u03c5(\u03a0)) denote the set of positive clauses of \u03c5(\u03a0) and let \u039b \u2286 PC(\u03c5(\u03a0)). Define \u0393\u03a0(\u039b) to be\n\n   \n   \nH \u2228 C1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ck\n\u2223 \u2223 \u2223 \u2223 \u2223 \u2223 \u2223 \u2223 \u2223 \u2223 k \u2265 0 & H,C1, . . . , Ck \u2208 PC(\u03c5(\u03a0)) & \u2203p1, . . . , pk \u2208 \u03c5(\u03a0) s.t. [ p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pk \u2192 H \u2208 \u03a0 &\nC1 \u2228 p1, . . . , Ck \u2228 pk \u2208 \u039b\n]\n\n   \n   \n.\nIt is clear that \u0393\u03a0 is a monotone operator on PC(\u03c5(\u03a0)). Now, a progression operator for first-order programs can then be defined via the first-order Gelfond-Lifschitz reduction. Given a disjunctive program \u03a0 and an \u03c5(\u03a0)structure A, define \u0393A\u03a0 to be the operator \u0393\u03a0A ; let \u0393 A\n\u03a0 \u21910 denote the empty set, and let \u0393A\u03a0 \u2191n denote \u0393 A \u03a0(\u0393 A \u03a0 \u2191n\u22121) for all n > 0; finally, let \u0393 A \u03a0 \u2191\u03c9 be the union of \u0393 A\n\u03a0 \u2191n for all n \u2265 0. To illustrate the definitions, a simple example is given as follows.\nExample 1. Let \u03a0 be the logic program consisting of rules\nS(x) \u2228 T (x) and T (x) \u2227E(x, y) \u2192 T (y).\nLet \u03c5 be {E} and A a structure of \u03c5. Then, for n > 0, \u0393A\u03a0 \u2191n is the set of clauses S(a) \u2228 T (b) such that a, b \u2208 A and there exists a path from a to b via E of length less than n.\nThe following proposition shows that the general stable model semantics can be defined by the progression operator.\nProposition 2 ([28], Theorem 1). Let \u03a0 be a disjunctive program, \u03c4 the set of intensional predicates of \u03a0, and A a structure of \u03c5(\u03a0). Then A is a stable model of \u03a0 iff INS(A, \u03c4) is a minimal model of \u0393A\u03a0 \u2191\u03c9.\nRemark 1. In Proposition 2, it is clear that, if \u03a0 is normal, A is a stable model of \u03a0 if and only if INS(A, \u03c4) = \u0393A\u03a0 \u2191\u03c9."}, {"heading": "Infinite Structures", "text": "This section will focus on the expressiveness of logic programs over infinite structures. We first propose a translation that reduces each disjunctive program to a normal program over infinite structures. The main idea is to encode grounded positive clauses by elements in the intended domain. With the encoding, we then simulate the progression of the given disjunctive program by the progression of a normal program.\nWe first show how to encode a positive clause by an element. Let A be an infinite set. Each encoding function on A is defined to be an injective function from A\u00d7A into A. Let enc be an encoding function on A and c an element in A such that enc(a, b) 6= c for all elements a, b \u2208 A. To simplify the statement, let enc(a1, . . . , ak; c) denote the expression\nenc((\u00b7 \u00b7 \u00b7 (enc(c, a1), a2), \u00b7 \u00b7 \u00b7 ), ak) (2)\nfor any k \u2265 0 and any set of elements a1, . . . , ak \u2208 A. In the above expression, the special element c is used as a flag to indicate that the encoded tuple will be started after c, and is then called the encoding flag of this encoding.\nLet A\u2217 denote the set of finite tuples of elements in A and enc[A, c] the set of elements enc(a\u0304; c) for all tuples a\u0304 in A\u2217. The merging function mrg on A related to enc and c is the function from enc[A, c]\u00d7 enc[A, c] into enc[A, c] such that\nmrg(enc(a\u0304; c), enc(b\u0304; c)) = enc(a\u0304, b\u0304; c) (3)\nfor all tuples a\u0304 and b\u0304 in A\u2217. Again, to simplify the statement, we let mrg(a1, . . . , ak) be short for the expression\nmrg((\u00b7 \u00b7 \u00b7 (mrg(a1, a2), a3), \u00b7 \u00b7 \u00b7 ), ak) (4)\nif all encoding flags of a1, . . . , ak are the same. It is clear that the merging function is unique if enc and c are fixed.\nExample 2. Let Z+, the set of all positive integers, be the domain that we will focus, and let P1, P2, P3 be three predicates of arities 2, 3, 1 respectively. Next, we show how to encode ground positive clauses by integers in Z+.\nLet e be a function from Z+ \u00d7 Z+ into Z+ such that\ne(m,n) = 2m + 3n for all m,n \u2208 Z+. (5)\nIt is easy to check that e is an encoding function on Z+, and integers 1, 2, 3, 4 are not in the range of e. For 1 \u2264 i \u2264 3, let i be the encoding flag for the encodings of atoms built from Pi. Then the grounded atom P2(1, 3, 5) can be encoded by\ne(1, 3, 5; 2) = e(e(e(2, 1), 3), 5) = 2155 + 35. (6)\nLet 4 be the encoding flag for encodings of positive clauses. Then the positive clause P2(1, 3, 5) \u2228 P3(2) \u2228 P1(2, 4) can be encoded by e(e(1, 3, 5; 2), e(2; 3), e(2, 4; 1); 4).\nIn classical logic, two positive clauses are equivalent if and only if they contain the same set of atoms. Assume that c is the encoding flag for encodings of positive clauses and enc is the encoding function. To capture the equivalence between two positive clauses, some encoding predicates related to enc and c are needed. We define them as follows:\nin = {(enc(a\u0304; c), b) | a\u0304 \u2208 A\u2217 \u2227 b \u2208 [a\u0304]}, (7)\nsubc = {(enc(a\u0304; c), enc(b\u0304; c)) | a\u0304, b\u0304 \u2208 A\u2217 \u2227 [a\u0304] \u2286 [b\u0304]}, (8)\nequ = {(enc(a\u0304; c), enc(b\u0304; c)) | a\u0304, b\u0304 \u2208 A\u2217 \u2227 [a\u0304] = [b\u0304]}, (9)\nwhere [a\u0304], [b\u0304] are the sets of elements in a\u0304, b\u0304 respectively. Intuitively, in(a, b) expresses that the atom encoded by b appears in the positive clause encoded by a; subc(a, b) expresses that the positive clause encoded by a is a subclause of that encoded by b; and equ(a, b) expresses that the positive clauses encoded by a and b respectively are equivalent.\nWith the above method for encoding, we can then define a translation. Let \u03a0 be a disjunctive program. We first construct a class of normal programs related to \u03a0 as follows:\n1. Let C\u03a0 denote the set consisting of an individual constant cP for each predicate constant P that occurs in \u03a0, and of an individual constant c\u01eb, where c\u01eb will be interpreted as the encoding flag for positive clauses, and cP as the encoding flag for atoms built from P . Let \u03a01 consist of the rule\nENC(x, y, c) \u2192 \u22a5 (10)\nfor each individual constant c \u2208 C\u03a0, and the following rules:\n\u00acENC(x, y, z) \u2192 ENC(x, y, z) (11)\n\u00acENC(x, y, z) \u2192 ENC(x, y, z) (12)\nENC(x, y, z) \u2227 ENC(u, v, z) \u2227 \u00acx = u \u2192 \u22a5 (13)\nENC(x, y, z) \u2227 ENC(u, v, z) \u2227 \u00acy = v \u2192 \u22a5 (14)\nENC(x, y, z) \u2192 OKe(x, y) (15)\n\u00acOKe(x, y) \u2192 OKe(x, y) (16)\nENC(x, y, z) \u2227 ENC(x, y, u) \u2227 \u00acz = u \u2192 \u22a5 (17)\nInformally, rules (15)\u2013(17) describe that ENC is the graph of a function; rules (13)\u2013(14) describe that ENC is injective. Thus, ENC should be the graph of an encoding function. In addition, rule (10) assures that c is not in the range of ENC.\n2. Let \u03a02 be the program consisting of the following rules:\ny = c\u01eb \u2192 MRG(x, y, x) (18) [\nMRG(x, u, v) \u2227 ENC(u,w, y)\n\u2227 ENC(v, w, z)\n]\n\u2192 MRG(x, y, z) (19)\nENC(x, u, y) \u2192 IN(u, y) (20)\nENC(x, z, y) \u2227 IN(u, x) \u2192 IN(u, y) (21)\nx = c\u01eb \u2192 SUBC(x, y) (22)\nSUBC(u, y) \u2227 ENC(u, v, x) \u2227 IN(v, y) \u2192 SUBC(x, y) (23)\nSUBC(x, y) \u2227 SUBC(y, x) \u2192 EQU(x, y) (24)\nInformally, rules (18)\u2013(19) describe that MRG is the graph of the merging function related to ENC and c\u01eb; rules (20)\u2013(21) are an inductive version of (7); rules (22)\u2013(23) are an inductive version of (8); all rules (20)\u2013(24) then assert that EQU is the equivalence between positive clauses.\n3. Let \u03a03 be the logic program consisting of the rule\nTRUE(x) \u2227 EQU(x, y) \u2192 TRUE(y) (25)\nand the rule \n \nTRUE(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 TRUE(xk)\u2227\nENC(y1, \u2308\u03d11\u2309, x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 ENC(yk, \u2308\u03d1k\u2309, xk)\n\u2227 MRG(\u2308\u03b3H\u2309, y1, . . . , yk, z) \u2227 \u03b3B\n\n  \u2192 TRUE(z) (26)\nfor each rule \u03b3 in \u03a0, where \u03d11, . . . , \u03d1k list all the intensional atoms that have strictly positive occurrences in the body of \u03b3 for some k \u2265 0; \u03b3H is the head of \u03b3, \u03b3 \u2212 B is the conjunction of literals occurring in the body of \u03b3 but not in \u03d11, . . . , \u03d1k; ENC(t1, \u2308\u03d1\u2309, t2) denotes the following conjunction\nui0 = cP \u2227 ENC(u i 0, t1, u i 1) \u2227 \u00b7 \u00b7 \u00b7\n\u2227 ENC(uim\u22121, tm, u i m) \u2227 ENC(t1, u i m, t2)\nfor some new variables uij if t1, t2 are terms and \u03d1 an atom of form P (t1, . . . , tm); MRG(\u2308\u03b3H\u2309, y1, . . . , yk, z) denotes\nENC(v0,\u2308\u03b61\u2309, v1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 ENC(vn\u22121, \u2308\u03b6n\u2309, vn)\n\u2227 MRG(w0, y1, w1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 MRG(wk\u22121, yk, wk)\n\u2227 v0 = c\u01eb \u2227 w0 = vn \u2227 z = wk\nif \u03b3H = \u03b61 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03b6n for some atoms \u03b61, . . . , \u03b6n and n \u2265 0. Intuitively, rule (25) assures that the progression is closed under the equivalence of positive clauses; rule (26) then simulates the progression operator for the original program. As each positive clause is encoded by an element in the intended domain, the processes of decoding and encoding should be carried out before and after the simulation respectively.\nExample 3. Let \u03b3 = P (v) \u2227 \u00acQ(v) \u2192 R(v) \u2228 S(v) be a rule such that P,Q,R, S are intensional. Then the following rule, defined by (26) with a slight simplification, simulates \u03b3:\n\n \nTRUE(x1) \u2227 ENC(cP ,v,u1) \u2227 ENC(y1,u1,x1)\u2227\nENC(cR,v,u2) \u2227 ENC(c\u01eb,u2,w1) \u2227 ENC(cS ,v,u3)\u2227\nENC(w1,u3,w2) \u2227 MRG(w2,y1,z) \u2227 \u00acQ(v)\n\n  \u2192 TRUE(z).\n4. Let \u03a04 be the program consisting of the rule\nx = c\u01eb \u2192 FALSE(x) (27)\nand the rule\nFALSE(x) \u2227 ENC(x, \u2308\u03d1\u2309, y) \u2227 \u00ac\u03d1 \u2192 FALSE(y) (28)\nfor every intensional atom \u03d1 of the form P (z\u0304P ), where z\u0304P denotes a tuple of distinct individual variables z1 \u00b7 \u00b7 \u00b7 zkP that are different from x and y, and kP is the arity of P .\nThis program is intended to define the predicate FALSE as follows: FALSE(a) holds in the intended structure if and only if a encodes a positive clause that is false in the structure.\n5. Let \u03a05 be the logic program consisting of the rule\nTRUE(c\u01eb) \u2192 \u22a5 (29)\nand the following rule\nTRUE(x) \u2227 ENC(y, \u2308\u03d1\u2309, x) \u2227 FALSE(y) \u2192 \u03d1 (30)\nfor each atom \u03d1 of the form same as that in \u03a04. Informally, this program asserts that a ground atom is true in the intended structure if and only if there is a positive clause containing this atom such that the clause in true and all the other atoms in this clause are false in the structure.\nNow, we let \u03a0\u22c4 denote the union of \u03a01, . . . ,\u03a05. This then completes the definition of the translation. The soundness of this translation is assured by the following theorem.\nTheorem 1. Let \u03a0 be a disjunctive program. Then over infinite structures, SM(\u03a0) is equivalent to \u2203\u03c0SM(\u03a0\u22c4), where \u03c0 denotes the set of constants occurring in \u03a0\u22c4 but not in \u03a0.\nTo prove this result, some notations and lemmas are needed. Let \u03c5i and \u03c4 be the sets of intensional predicates of \u03a0i and \u03a0 respectively. Let \u03c3 = \u03c51 \u222a \u03c52 \u222a \u03c5(\u03a0). Given a structure A of \u03c5(\u03a0), each encoding expansion of A is defined to be a \u03c3-expansion B of A satisfying both of the following:\n1. ENC is interpreted as the graph of an encoding function enc on A such that no element among cB\u01eb and cBP (for all P \u2208 \u03c4 ) belongs to the range of enc, ENC as the complement of the graph of enc, and OKBe= A\u00d7A;\n2. MRG is interpreted as the graph of the merging function related to enc and cB\u01eb , and IN, SUBC, EQU as the encoding predicates in, subc, equ related to enc and cB\u01eb respectively.\nLet A be a structure of \u03c5(\u03a0) with an encoding expansion B. Let enc be the encoding function with graph ENCB. Let\n[[P (a1, . . . , ak)]] B = enc(a1, . . . , ak; cBP ), (31)\n[[\u03d11 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03d1n]] B = enc([[\u03d11]]B, . . . , [[\u03d1n]]B; cB\u01eb ). (32)\nIf the encoding expansion B is clear from the context, we simply write [[\u00b7]]B as [[\u00b7]]. Given a set \u03a3 of ground positive clauses, let [[\u03a3]] be the set of elements [[C]] for all C \u2208 \u03a3. Let \u2206n(B) be the set of elements a with TRUE(a) \u2208 \u0393B\u03a03\u2191n.\nLemma 1. Let A be a structure of \u03c5(\u03a0) with an encoding expansion B. Then [[\u0393A\u03a0\u2191\u03c9 ]] = \u222an\u22650\u2206 n(B).\nNext, given a structure A of \u03c5(\u03a0), an \u03c5(\u03a0\u22c4)-expansion C of A is called a progression expansion of A if the restriction of C to \u03c3, denoted by B, is an encoding expansion of A; C interprets TRUE as [[\u0393A\u03a0\u2191\u03c9]]B, and interprets FALSE as\n{ [[C]]B | C \u2208 GPC(\u03c4, A) & INS(A, \u03c4) |= \u00acC }\n(33)\nwhere GPC(\u03c4, A) denotes the set of ground positive clauses built from predicates in \u03c4 and elements in A.\nLemma 2. Let A be a structure of \u03c5(\u03a0) with a progression expansionC. Then INS(A, \u03c4) is a minimal model of \u0393A\u03a0\u2191\u03c9 iff INS(C, \u03c4) is a minimal model of \u03a0 C 5 .\nDue to the limit of space, we will omit the proofs of Lemmas 1 and 2 here. To show Lemma 1, it is sufficient to show both [[\u0393A\u03a0\u2191n]] \u2286 \u22062n(B) and [[\u0393A\u03a0\u2191n]] \u2287 \u2206n(B), and each of them can be done by an induction. For Lemma 2, roughly speaking, the soundness is assured by the result that every head-cycle-free disjunctive program is equivalent to the normal program obtained by shifting [4]. Please note that every set of positive clauses is head-cycle-free, and \u03a04 and \u03a05 are designed for the simulation of shifting. With these lemmas, we can then prove Theorem 1:\nProof of Theorem 1. By the splitting lemma in [15] and the second-order transformation, it suffices to show that SM(\u03a0) is equivalent to the following formula\n\u2203\u03c0[SM(\u03a01) \u2227 \u00b7 \u00b7 \u00b7 \u2227 SM(\u03a05)] (34)\nover infinite structures. Now we prove it as follows. \u201c=\u21d2\u201d: Let A be an infinite model of SM(\u03a0). Let B be an encoding expansion ofA. The existence of such an expansion is clearly assured by the infiniteness of A. It is easy to check that B is a stable model of both\u03a01 and\u03a02. Let C be the progression expansion of A that is also an expansion of B. By Proposition 2, INS(B, \u03c4) = INS(A, \u03c4) should be a minimal model of \u0393A\u03a0\u2191\u03c9. By Lemma 1 and definition, INS(B, \u03c4) is also a minimal model of \u0393B\u03a03\u2191\u03c9. By Proposition 2 again, B is then a stable model of \u03a03, which implies that so is C. It is also easy to check that C is a stable model of \u03a04. On the other hand, since INS(A, \u03c4) is a minimal model of \u0393A\u03a0 \u2191\u03c9, by Lemma 2, INS(C, \u03c4) should be a minimal model of \u03a0C5 , which means that C is a stable model of \u03a05 by Proposition 1. Thus, A is a model of formula (34).\n\u201c\u21d0=\u201d: Let A be an infinite model of formula (34). Then there exists an \u03c5(\u03a0\u22c4)expansion C of A such that C satisfies SM(\u03a0i) for all i : 1 \u2264 i \u2264 5. Let B be the restrictions of C to \u03c3. Then, by a routine check, it is easy to show that B is an encoding expansion of A. As C is a stable model of \u03a03, by Proposition 2, INS(C, \u03c53) is then a minimal model of \u0393C\u03a03 \u2191\u03c9 = \u0393 B \u03a03 \u2191\u03c9. Furthermore, by Lemma 1 and the conclusion that C satisfies SM(\u03a04), we then have that C is a progression expansion of A. On the other hand, since C is also a stable model of \u03a05, by Proposition 1 we can conclude that INS(C, \u03c4) is a minimal model of \u03a0C5 . Thus, by Lemma 2 we immediately have that INS(A, \u03c4) is a minimal model of \u0393A\u03a0 \u2191\u03c9. By Proposition 2, A is then a stable model of \u03a0.\nRemark 2. Note that, given any finite domain A, there is no injective function from A \u00d7 A into A. Therefore, we can not expect that the above translation works on finite structures.\nCorollary 1. DLP \u2243INF NLP.\nNow, let us focus on the relationship between logic programs and second-order logic. The following proposition says that, over infinite structures, normal programs are more expressive than the existential second-order logic, which then strengthens a result in [3] where such a separation over arbitrary structures was obtained.\nProposition 3. NLP 6\u2264INF \u03a311.\nTo show this, our main idea is to define a property that can be defined by a normal program but not by any existential second-order sentence. The property is defined as follows. Let \u03c5R be the vocabulary consisting of a binary predicate E and two individual constants s and t. Let REACHi be the class of infinite \u03c5R-structures in each of which there is a finite path from s to t via edges in E. Now, we show the result.\nProof of Proposition 3. First show that REACHi is definable in NLP over infinite structures. Let \u03a0 be the normal program\n{ P (s) , P (x) \u2227 E(x, y) \u2192 P (y), \u00acP (t) \u2192 \u22a5 } . (35)\nBy a simple check, we can show that the formula \u2203PSM(\u03a0) defines the desired property over infinite structures.\nNext, we prove that REACHi is undefinable in \u03a311 over infinite structures. Towards a contradiction, assume that there is a first-order sentence \u03d5 and a finite set \u03c4 of predicates such that \u2203\u03c4\u03d5 is in \u03a311 and defines REACHi over infinite structures. Let R be a binary predicate not in \u03c4 . Let \u03c8 denote\n\u2200x\u2203yR(x, y) \u2227 \u2200x\u00acR(x, x)\u2227\n\u2200x\u2200y\u2200z[R(x, y) \u2227R(y, z) \u2192 R(x, z)]. (36)\nIntuitively, it asserts that the relation R is both transitive and irreflexive, and each element in the domain has a successor w.r.t. this relation. It is obvious that such a relation exists if and only if the domain is infinite. Therefore, the formula \u2203\u03c4\u03d5 \u2227 \u2203R\u03c8 defines REACHi over arbitrary structures.\nMoreover, let \u03b30(x, y) be x = y; for all n > 0 let \u03b3n(x, y) denote \u2203zn(\u03b3n\u22121(x, zn)\u2227 E(zn, y)), where each \u03b3n(x, y) asserts that there is a path of length n from x to y. Let \u039b be the set of sentences \u00ac\u03b3n(s, t) for all n \u2265 0. Now we claim:\nClaim. \u039b \u222a {\u2203\u03c4\u03d5, \u2203R\u03c8} is satisfiable.\nTo show this, it suffices to show that the first-order theory \u039b\u222a{\u03d5, \u03c8} is satisfiable. Let \u03a6 be a finite subset of \u039b, and let n = max{m | \u00ac\u03b3m(s, t) \u2208 \u03a6}. Let A be an infinite model of \u03c8 with vocabulary \u03c5(\u03d5) \u222a \u03c5(\u03c8) in which the minimal length of paths from s to t via edge E is an integer > n. Then A is clearly a model of \u03a6\u222a{\u03d5, \u03c8}. Due to the arbitrariness of \u03a6, by the compactness we then have the desired claim.\nLet A be any model of \u039b \u222a {\u2203\u03c4\u03d5, \u2203R\u03c8}. Then according to \u2203R\u03c8, A should be infinite, and by \u039b, there is no path from s to t via E in A. However, according to \u2203\u03c4\u03d5, every infinite model of it should be s-to-t reachable, a contradiction. Thus, the property REACHi is then undefinable in \u03a311 over infinite structures. This completes the proof immediately.\nThe following separation immediately follows from the proof of Theorem 4.1 in [10]. Although their statement refers to arbitrary structures, the proof still works if only infinite structures are focused.\nProposition 4. \u03a312 6\u2264INF DLP."}, {"heading": "Finite Structures", "text": "This section will focus on the expressiveness of logic programs over finite structures. We first consider the relationship between disjunctive and normal programs. Unfortunately, in the general case, we have the following result:\nProposition 5. DLP \u2243FIN NLP iff NP = coNP.1\nProof. By Fagin\u2019s Theorem [13] and Stockmeyer\u2019s logical characterization of the polynomial hierarchy [27],2 we have that \u03a312 \u2243FIN \u03a3 1 1 iff \u03a3 p 2 = NP. By a routine complexity theoretical argument, it is also true that \u03a3p2 = NP iff NP = coNP. On the other hand, according to the proof of Theorem 6.3 in [11], or by Proposition 7 in this section, Leivant\u2019s normal form [20] and the definition of SM, we can conclude DLP \u2243FIN \u03a312; by Proposition 6 in this section, it holds that NLP \u2243FIN \u03a311. Combining these conclusions, we then have the desired proposition.\nThis result shows us how difficult it is to separate normal programs from disjunctive programs over finite structures. To know more about the relationship, we will try to prove a weaker separation between these two classes. Before doing this, we need to study the relationship between logic programs and second-order logic. For the class of normal programs, we have the following characterization:\nProposition 6. NLPFn \u2243FIN \u03a3 1F 1,n[\u2200 \u2217] for all n > 1.\nTo prove the above characterization, we have to develop a translation that turns normal programs to first-order sentences. The main idea is to extend the Clark completion by a progression simulation, so it is an improved version of the ordered completion proposed by [3].\nNow, we define the translation. Let \u03a0 be a normal program and n the maximal arity of intensional predicates of \u03a0. Without loss of generality, assume the head of every rule in \u03a0 is of form P (x\u0304), where P is a k-ary predicate for some k \u2265 0, and x\u0304 is the tuple of distinct individual variables x1, . . . , xk . Let \u227a be a new binary predicate and \u031f a\n1A similar result for traditional logic programs under the query equivalence can be obtained by the expressiveness results proved by [26, 11].\n2In their characterizations of complexity classes, no function constant of positive arity is allowed. However, this restriction can be removed as functions can be easily simulated by predicates.\nuniversal first-order sentence asserting that \u227a is a strict partial order. Given two tuple s\u0304, t\u0304 of terms of the same length, let s\u0304 \u227a t\u0304 be a quantifier-free formula asserting that s\u0304 is less than t\u0304 w.r.t. the lexicographic order extended from \u227a naturally.\nLet \u03c4 be the set of intensional predicates of \u03a0. Let c be the least integer \u2265 log2 |\u03c4 |+ n. Fix P to be a k-ary predicate in \u03c4 and let \u03bb = P (x1, . . . , xk). Suppose \u03b31, . . . , \u03b3l list all the rules in \u03a0 whose heads are \u03bb, and suppose \u03b3i is of form\n\u03b6i \u2227 \u03d1i1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03d1 i mi \u2192 \u03bb (37)\nwhere \u03d1i1, . . . , \u03d1imi list all the positive intensional conjuncts in the body of \u03b3i, \u03b6 i is the conjunction of other conjuncts that occurs in the body of \u03b3i, mi \u2265 0, and y\u0304i is the tuple of all individual variables occurring in \u03b3i but not in \u03bb.\nNext, we let \u03d5P denote the conjunction of rules \u03b3i for all i : 1 \u2264 i \u2264 l, and let \u03c8P denote the formula\n\u03bb \u2192 l \u2228\ni=1\n\u2203y\u0304i\n \u03b6i \u2227 mi \u2227\nj=1\n(\n\u03d1ij \u2227 LESSD(\u03d1 i j , \u03bb)\n)\n\n (38)\nwhere, for every intensional atoms\u03d1 and\u03d10, ord(\u03d1) denotes the tuple (ocQ(t\u0304), \u00b7 \u00b7 \u00b7 , o 1 Q(t\u0304)) if \u03d1 of form Q(t\u0304), each osQ is a new function whose arity is the same as that of Q, and LESSD(\u03d1, \u03d10) denotes formula ord(\u03d1) \u227a ord(\u03d10).\nDefine \u03d5\u03a0 as the universal closure of conjunction of the formula \u031f and formulas \u03d5P \u2227\u03c8P for all P \u2208 \u03c4 . Let \u03c3 be the set of functions osQ for all Q \u2208 \u03c4 and s : 1\u2264 s\u2264 c. Clearly, \u2203\u03c3\u03d5\u03a0 is equivalent to a sentence in \u03a31F1,n[\u2200\u2217] by introducing Skolem functions if n > 1. Now we show the soundness:\nLemma 3. Given any finite structure A of \u03c5(\u03a0) with at least two elements in the domain, A |= SM(\u03a0) iff A |= \u2203\u03c3\u03d5\u03a0.\nProof. Due to the limit of space, we only show the right-to-left direction. Let B be a finite model of \u03d5\u03a0. By formula \u031f, B must interpret predicate \u227a as a strict partial order on B. Let A be the restriction of B to \u03c5(\u03a0). To show that A is a stable model of \u03a0, by Proposition 2 it suffices to show that INS(A, \u03c4) = \u0393A\u03a0 \u2191\u03c9. We first claim that \u0393A\u03a0 \u2191m \u2286 INS(A, \u03c4) for all m \u2265 0. This can be shown by an induction on m. The case of m = 0 is trivial. Let m > 0 and assume \u0393A\u03a0 \u2191m\u22121\u2286 INS(A, \u03c4). Our task is to show \u0393A\u03a0 \u2191m \u2286 INS(A, \u03c4). Let p be a ground atom in \u0393A\u03a0 \u2191m. By definition, there must exist a rule \u03b3i of form (37) in \u03a0 and an assignment \u03b1 in A such that \u03bb[\u03b1] = p, \u03b1 satisfies \u03b6i in A (so equivalently, in B), and for each atom \u03d1ij , \u03d1ij [\u03b1] \u2208 \u0393A\u03a0 \u2191m\u22121. By the inductive assumption, each \u03d1ij[\u03b1] \u2208 INS(A, \u03c4), or in other words, \u03b1 satisfies each \u03d1ij in A (so equivalently, in B). As \u03b1 clearly satisfies the rule \u03b3i in B, we can conclude that \u03b1 satisfies \u03bb in B, which implies p = \u03bb[\u03b1] \u2208 INS(B, \u03c4) = INS(A, \u03c4). So, the claim is true. From it, we have \u0393A\u03a0 \u2191\u03c9\u2286 INS(A, \u03c4).\nNow, it remains to prove INS(A, \u03c4) \u2286 \u0393A\u03a0 \u2191\u03c9. Towards a contradiction, assume this is not true. Then we must have \u0393A\u03a0 \u2191\u03c9 ( INS(A, \u03c4) by the previous conclusion. Given two ground intensional atoms p1 and p2 in INS(A, \u03c4), we define p1 < p2 if LESSD(p1, p2) is true in B. Let p be a <-minimal atom in INS(A, \u03c4) \u2212 \u0393A\u03a0 \u2191\u03c9 and suppose p = P (a\u0304) for some P \u2208 \u03c4 . Let \u03b1 be an assignment in B such that \u03b1(x\u0304) = a\u0304.\nBy definition, \u03b1 should satisfy \u03c8P (in which \u03bb[\u03b1] = p) in B. So, there exist an integer i : 1 \u2264 i \u2264 l and an assignment \u03b10 in B such that (i) \u03b10(x\u0304) = a\u0304, (ii) \u03b6i[\u03b10] is true in B, and (iii) for all j, qj \u2208 INS(B, \u03c4) = INS(A, \u03c4) and qj < \u03bb[\u03b10], where qj denotes \u03d1ij[\u03b10]. As \u03bb[\u03b10] = \u03bb[\u03b1] = p and p is <-minimal in INS(A, \u03c4) \u2212 \u0393A\u03a0 \u2191\u03c9, we can conclude qj \u2208 \u0393A\u03a0 \u2191\u03c9 for all j. According to the definition of \u03c8P , the rule \u03b3i (of form (37)) is in \u03a0, which implies q1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 qmi \u2192 p = \u03b3 + i [\u03b10] \u2208 \u03a0 A. By definition, we then have p \u2208 \u0393A\u03a0 \u2191\u03c9, a contradiction.\nRemark 3. Let m and n be the number and the maximal arity of intensional predicates respectively. The maximal arity of auxiliary constants in our translation is only n (that of the ordered completion in [3] is 2n), which is optimal if Conjecture 13 in [6] is true. Moreover, the number of auxiliary constants in our translation is m \u00b7 (\u2308log2 m\u2309 + n), while that of the ordered completion is m2. (Note that n is normally very small.)\nRemark 4. Similar to the work in [3], we can develop an answer set solver by calling some SMT solver. By the comparison in the above remark, this approach is rather promising. In addition, as a strict partial order is available in almost all the SMT solvers (e.g., built-in arithmetic relations), our translation can be easily optimized.\nNow we are in the position to prove Proposition 6.\nProof of Proposition 6. \u201c\u2265FIN\u201d: Let \u03d5 be any sentence in \u03a31F1,n[\u2200\u2217]. It is obvious that \u03d5 can be written as an equivalent sentence of form \u2203\u03c4\u2200x\u0304(\u03b31 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b3k) for some k \u2265 0, where each \u03b3i is a disjunction of atoms or negated atoms, and \u03c4 a finite set of functions or predicates of arity \u2264 n. Let \u03a0 be a logic program consisting of the rule \u03b3\u0303i \u2192 \u22a5 for each i : 1 \u2264 i \u2264 k, where \u03b3\u0303i is obtained from \u03b3i by substituting \u03d1 for each negated atom \u00ac\u03d1, followed by substituting \u00ac\u03d1 for each atom \u03d1, and followed by substituting \u2227 for \u2228. It is easy to check that \u2203\u03c4SM(\u03a0) is in NLPFn and equivalent to \u03d5.\n\u201c\u2264FIN\u201d: Let C=1 (respectively, C>1) be the class of finite structures with exactly one (respectively, at least two) element(s) in the domain. Let \u03a0 be a normal program and \u03c4 a finite set of predicates and functions such that \u2203\u03c4SM(\u03a0) is in NLPFn. It is trivial to construct a sentence, say \u03b6, in \u03a31F1,n[\u2200\u2217] such that \u2203\u03c4SM(\u03a0) is equivalent to \u03b6 over C=1. (Please note that, if the domain is a singleton, a first-order logic program will regress to a propositional one.) By Lemma 3, there is also a sentence \u03c8 in \u03a31F1,n[\u2200\u2217] such that \u2203\u03c4SM(\u03a0) is equivalent to \u03c8 over C>1. Let \u03d5 be the following sentence:\n[\u2203x\u2200y(x = y) \u2227 \u03b6] \u2228 [\u2203x\u2203z(\u00acx = z) \u2227 \u03c8]. (39)\nInformally, this formula first test whether or not the domain is a singleton. If it is true, let \u03b6 work; otherwise let \u03c8 work. Thus, it is easy to show that \u2203\u03c4SM(\u03a0) is equivalent to \u03d5 over finite structures. It is also clear that \u03d5 can be written to be an equivalent sentence in \u03a31F1,n[\u2200\u2217]. (Please note that every first-order quantifier can be regarded as a second-order quantifier over a function variable of arity 0.)\nRemark 5. Assuming Conjecture 1 in [6], by the results of [17], NLPFk then exactly captures the class of languages computable in O(nk)-time (where n is the size of input)\n3It implies ESOFn[\u2200\u2217] \u2243FIN ESO F n[\u2200 n], where the latter is the class of sentences in ESOFn[\u2200\u2217] with at most n individual variables.\nin Nondeterministic Random Access Machines (NRAMs), and whether an extensional database can be expanded to a stable model of a disjunctive program is decidable in O(nk)-time in NRAMs.\nBy Proposition 6 and the fact that auxiliary functions can be simulated by auxiliary predicates in both logic programs and second-order logic, we have the following result:\nCorollary 2. NLP \u2243FIN \u03a311.\nNext, let us focus on the translatability from a fragment of second-order logic to disjunctive programs. For convenience, in the rest of this paper, we fix SUCC to be a binary predicate, fix FIRST and LAST to be two unary predicates, and fix \u03c5S to be the set consisting of these predicates. In particular, unless mentioned otherwise, a logic program or a formula is always assumed to contains no predicate in \u03c5S.\nA structure A is called a successor structure if:\n1. its vocabulary contains all the predicates in \u03c5S, and\n2. SUCCA is a binary relation R on A such that the transitive closure of R is a strict total order and for all a \u2208 A, both |{b | (a, b) \u2208 R}| \u2264 1 and |{b | (b, a) \u2208 R}| \u2264 1 hold, and\n3. FIRSTA (respectively, LASTA) consists of the least element (respectively, the largest element) in A w.r.t. SUCCA.\nBy this definition, given a successor structure, both the least and largest elements must exist, so it is then finite. Now, we let SUC denote the class of successor structures.\nLet \u03a312,n[\u2200n\u2203\u2217] be the class of sentences in \u03a312,n[\u2200\u2217\u2203\u2217] that involve at most n universal quantifiers. Now we can show:\nLemma 4. \u03a312,n[\u2200 n\u2203\u2217] \u2264SUC DLPn for all n > 0.\nProof. (Sketch) Let \u2203\u03c4\u2200\u03c3\u03d5 be any sentence in \u03a312,n[\u2200 n\u2203\u2217] where \u03c4, \u03c3 are finite sets of predicates of arities \u2264 n. Without loss of generality, suppose\u03d5 = \u2200x\u0304\u2203y\u0304(\u03d11\u2228\u00b7 \u00b7 \u00b7\u2228\u03d1m), where x\u0304 is of length n; each \u03d1i is a finite conjunction of literals. Next, we want to construct a disjunctive program which defines the property expressed by the sentence \u2203\u03c4\u2200\u03c3\u03d5.\nBefore constructing the program, we need to define some notations. Let u\u0304 and v\u0304 be any two tuples of individual variablesu1 \u00b7 \u00b7 \u00b7uk and v1 \u00b7 \u00b7 \u00b7 vk respectively. Let FIRST(u\u0304) denote the conjunction of FIRST(ui) for all i : 1 \u2264 i \u2264 k, and let LAST(u\u0304) denote the conjunction of LAST(ui) for all i : 1 \u2264 i \u2264 k. Moreover, let SUCCi(u\u0304, v\u0304) be the formula\n\n \nu1 = v1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 ui\u22121 = vi\u22121\n\u2227 SUCC(ui, vi) \u2227 LAST(ui+1)\n\u2227 FIRST(vi+1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 LAST(uk) \u2227 FIRST(vk)\n\n  (40)\nfor each i : 1 \u2264 i \u2264 k.\nNow let us construct the translation. First we define:\n\u22061 = { X(z\u0304) \u2228X c(z\u0304) | X \u2208 \u03c3 \u222a \u03c4 } , \u22062 = { LAST(x\u0304) \u2227D(x\u0304) \u2192 Xc(z\u0304) | X \u2208 \u03c3 } ,\n\u22063 = { LAST(x\u0304) \u2227D(x\u0304) \u2192 X(z\u0304) | X \u2208 \u03c3 } , \u22064 = { FIRST(x\u0304) \u2227 \u03d1ci (x\u0304, y\u0304) \u2192 D(x\u0304) | 1 \u2264 i \u2264 m } ,\n\u22065 =\n{\nSUCCj(v\u0304, x\u0304) \u2227D(v\u0304)\u2227\n\u03d1ci (x\u0304, y\u0304) \u2192 D(x\u0304)\n\u2223 \u2223 \u2223 \u2223 \u2223 1 \u2264 i \u2264 m 1 \u2264 j \u2264 n } ,\n\u22066 = { LAST(x\u0304) \u2227 \u00acD(x\u0304) \u2192 \u22a5 } ,\nwhere, for each X \u2208 \u03c3 \u222a \u03c4 , Xc is a new predicate of the same arity; \u03d1ci is the formula obtained from \u03d1i by substituting Xc for \u00acX whenever X \u2208 \u03c3 \u222a \u03c4 ; D is an n-ary new predicate.\nLet \u03a0 be the union of \u22061, . . . ,\u22066 and \u03c0 the set of new predicates introduced in the translation. Clearly, \u2203\u03c0SM(\u03a0) is in DLPn. By a similar (slightly more complicated) argument to that in Theorem 6.3 of [11], we can show that \u2203\u03c0\u2203\u03c4\u2203\u03c3SM(\u03a0) \u2261SUC \u2203\u03c4\u2200\u03c3\u03d5.\nNext, we show that this result can be generalized to finite structures. To do this, we need a program to define the class of successor structures. Now we define it as follows.\nLet \u03a0S be the program consisting of the following rules.\n\u00acLESS(x, y) \u2192 LESS(x, y) (41)\n\u00acLESS(x, y) \u2192 LESS(x, y) (42)\nLESS(x, y) \u2227 LESS(y, z) \u2192 LESS(x, z) (43)\nLESS(x, y) \u2227 LESS(y, x) \u2192 \u22a5 (44)\n\u00acLESS(x, y) \u2227 \u00acLESS(y, x) \u2227 \u00acx = y \u2192 \u22a5 (45)\nLESS(x, y) \u2192 FIRST(y) (46)\n\u00acFIRST(x) \u2192 FIRST(x) (47)\nLESS(x, y) \u2192 LAST(x) (48)\n\u00acLAST(x) \u2192 LAST(x) (49)\nLESS(x, y) \u2227 LESS(y, z) \u2192 SUCC(x, z) (50)\n\u00acSUCC(x, y) \u2227 LESS(x, y) \u2192 SUCC(x, y) (51)\nInformally, rules (41)\u2013(42) are choice rules to guess a binary relation LESS; rule (43), (44) and (45) restrict LESS to be transitive, antisymmetric and total respectively so that it is a strict total order; rules (46)\u2013(47) and rules assert that FIRST and LAST consist of the least and the last elements respectively if they exist; the last two rules then assert that SUCC defines the relation for direct successors. The following simple lemma shows that \u03a0S is the desired program.\nLemma 5. Given a vocabulary \u03c3 \u2287 \u03c5S and a structure A of \u03c3, A is a successor structure iff it is finite and is a model of \u2203\u03c4SM(\u03a0S), where \u03c4 denotes \u03c5(\u03a0S)\u2212 \u03c5S.\nNow we can then prove the following result:\nProposition 7. \u03a312,n[\u2200 n\u2203\u2217] \u2264FIN DLPn for all n > 1.\nProof. Let n > 1 and \u03d5 a sentence in \u03a312,n[\u2200 n\u2203\u2217]. Let \u03a00 be the disjunctive program constructed in the proof of Lemma 4 related to \u03d5, and let \u03c3 be the set of predicates appearing in \u03a00 but neither in \u03c5S nor in \u03c5(\u03d5). Let \u03a0 = \u03a00 \u222a \u03a0S and let \u03c4 be the set of predicates appearing in \u03a0S but not in \u03c5S. Next we show that \u03d5 is equivalent to \u2203\u03c4\u2203\u03c3SM(\u03a0) over finite structures. By definition and the splitting lemma in [15], it suffices to show that \u03d5 is equivalent to\n\u2203\u03c5S(\u2203\u03c4SM(\u03a0S) \u2227 \u2203\u03c3SM(\u03a00)) (52)\nover finite structures. Let \u03c5 denote the union of \u03c5(\u03d5) and \u03c5S. Now we prove the new statement as follows.\n\u201c=\u21d2\u201d: Let A be a finite model of \u03d5. Clearly, there must exist at least one \u03c5expansion, say B, of A such that B is a successor structure. By Lemma 5, B should be a model of \u2203\u03c4SM(\u03a0S), and by the proof of Lemma 4, B is also a model of \u2203\u03c3SM(\u03a00). Hence, A is a model of formula (52).\n\u201c\u21d0=\u201d: Let A be a finite model of formula (52). Then there is an \u03c5-expansion, say B, of A such that B satisfies both \u2203\u03c4SM(\u03a0S) and \u2203\u03c3SM(\u03a00). By Lemma 5, B is a successor structure, and then by the proof of Lemma 4, B must be a model of \u03d5. This means that A is a model of \u03d5.\nWith these results, we can prove a weaker separation:\nTheorem 2. DLPn 6\u2264FIN NLP F 2n\u22121 for all n > 1.\nProof. Let \u03c5n be the vocabulary consisting of only an n-ary predicate Pn. Define PARITYn to be the class of finite \u03c5n-structures in each of which Pn is interpreted as a set consisting of an even number of n-tuples. Fix n > 1. Now, let us show that PARITY2n is definable in DLPn over FIN.\nWe first show that, over successor structures, PARITY2n is definable in \u03a312,n[\u2200n\u2203\u2217]. Let FIRST, LAST and SUCCi be the same as those in the proof of Lemma 4, and let SUCC(s\u0304, t\u0304) denote the conjunction of SUCCi(s\u0304, t\u0304) for all i : 1 \u2264 i \u2264 n if s\u0304 and t\u0304 are n-tuples of terms. Let X and Y be two predicate variables of arity n. We define \u03d51 to be the formula\n[\n\u2200z\u0304(FIRST(z\u0304) \u2192 [Y (z\u0304) \u2194 P2n(x\u0304, z\u0304)])\u2227\n\u2200y\u0304z\u0304(SUCC(y\u0304, z\u0304) \u2192 [P2n(x\u0304, z\u0304) \u2194 Y (y\u0304)\u2295 Y (z\u0304)])\n]\n\u2192 \u2203z\u0304(LAST(z\u0304) \u2227 [X(x\u0304) \u2194 Y (z\u0304)]),\nwhere \u03c8 \u2295 \u03c7 denotes the formula (\u03c8 \u2194 \u00ac\u03c7). Informally, \u03d51 is intended to define \u201cX(a\u0304) is true if and only if the cardinality of {b\u0304 | P (a\u0304, b\u0304)} is odd\u201d. Define \u03d52 to be the formula\n[\n\u2200z\u0304(FIRST(z\u0304) \u2192 [X(z\u0304) \u2194 Y (z\u0304)])\u2227\n\u2200y\u0304z\u0304(SUCC(y\u0304, z\u0304) \u2192 [X(z\u0304) \u2194 Y (y\u0304)\u2295 Y (z\u0304)])\n]\n\u2192 \u2203z\u0304[LAST(z\u0304) \u2227 \u00acY (z\u0304)].\nIntuitively,\u03d52 asserts \u201cX consists of an even number of n-tuples on the domain\u201d. Now, let \u03d5 = \u2203X\u2200Y \u2200x\u0304(\u03d51 \u2227 \u03d52). Obviously, \u03d5 can be written as an equivalent sentence in \u03a312,n[\u2200\nn\u2203\u2217]. By a careful check, it is not difficult to show that, given any successor structure A of \u03c5(\u03d5), the restriction of A to \u03c52n is in PARITY2n if and only if A is a model of \u03d5.\nAccording to the proof of Lemma 4, there exist a disjunctive program \u03a00 and a finite set \u03c4 of predicates of arities \u2264 n such that \u2203\u03c4SM(\u03a00) is equivalent to \u03d5 over successor structures and no predicate in \u03c5S is intensional w.r.t. \u03a00. Let \u03a0 be the union of \u03a0S and \u03a00. Let \u03c3 be the set of predicates in \u03c5(\u03a0)\u2212 \u03c52n. It is easy to show that, over finite structures, PARITY2n is defined by \u2203\u03c3SM(\u03a0), so definable in DLPn.\nNext, we show that PARITY2n is undefinable in NLPF2n\u22121 over finite structures. If this is true, we then obtain the desired proposition immediately. By Proposition 6, it is sufficient to prove that PARITY2n is not definable in \u03a31F1,2n\u22121 over finite structures. Towards a contradiction, assume that it is not true. By a similar argument to that in Theorem 3.1 of [7], we have:\nClaim. Let m \u2265 1. Then PARITY2m is definable in \u03a31F1,2m\u22122 over FIN if PARITYm is definable in \u03a31F1,m\u22121 over FIN.\nWith this claim, we can then infer that PARITY4n is definable in \u03a31F1,4n\u22122 over finite structures. As every function variable of arity k \u2265 0 can always be simulated by a predicate variable of arity k + 1, PARITY4n should be definable in \u03a311,4n\u22121 over finite structures, which contradicts with Theorem 2.1 in [1]. This completes the proof."}, {"heading": "Arbitrary Structures", "text": "Based on the results presented in the previous two sections, we can then compare the expressiveness of disjunctive programs and normal programs over arbitrary structures.\nTheorem 3. DLP \u2243 NLP iff DLP \u2243FIN NLP.\nProof. The left-to-right direction is trivial. Now let us show the converse. Assume DLP \u2243FIN NLP, and let \u03a0 be a disjunctive program. Then there must exist a normal program \u03a0\u25e6 such that SM(\u03a0) \u2261FIN \u2203\u03c3SM(\u03a0\u25e6), where \u03c3 is the set of predicates occurring in \u03a0\u25e6 but not in \u03a0. By Theorem 1, there is a normal program \u03a0\u22c4 such that SM(\u03a0) \u2261INF \u2203\u03c4SM(\u03a0\u22c4). Without loss of generality, let us assume \u03c3 \u2229 \u03c4 = \u2205. To show DLP \u2243 NLP, our idea is to design a normal program testing whether or not the intended structure is finite. If that is true, we let \u03a0\u25e6 work; otherwise, let \u03a0\u22c4 work. To do this, we introduce a new predicate FINITE of arity 0, and let \u03a0T be the union of \u03a0S and the following logic program:\n\n \n \nFIRST(x) \u2192 NUM(x),\nNUM(x) \u2227 SUCC(x, y) \u2192 NUM(y),\nNUM(x) \u2227 LAST(x) \u2192 FINITE\n\n \n \n. (53)\nLet \u03c0 = \u03c5(\u03a0T)\u2212 {FINITE}. We then have the following:\nClaim. If A |=\u2203\u03c0SM(\u03a0T), then A is finite iff A |= FINITE.\nThe left-to-right direction follows from Lemma 5. We only show the converse. Let us assume that A satisfies both FINITE and \u2203\u03c0SM(\u03a0T). Let \u03c50 be the union of \u03c5(\u03a0T) and the vocabulary of A. Then, there must exist an \u03c50-expansion B of A such that B is a stable model of \u03a0T. So, LESSB should be a strict total order on A; the element in FIRSTB (respectively, LASTB), if it exists, should be the least (respectively, largest) element in A w.r.t. LESSB; and SUCCB should be the relation defining the direct successors w.r.t. LESSB. As FINITE is true in A, there must exist an integer n \u2265 0 and n elements a1, . . . , an in A such that FIRST(a1), LAST(an) and each SUCC(ai, ai+1) are true in B. We assert that every element in A should be ai for some i. If not, let b be one of such elements. As LESSB is a strict total order, there must exist i : 1\u2264 i < n such that both LESS(ai, b) and LESS(b, ai+1) are true in B. But this is impossible since SUCC(ai, ai+1) is true in B. So, we must have A = {a1, . . . , an}. This implies that A is finite, and then we obtain the claim.\nNext, let us construct the desired program. Let \u03a0\u25e60 (respectively \u03a0 \u22c4 0) denote the normal program obtained from \u03a0\u25e6 (respectively, \u03a0\u22c4) by adding FINITE (respectively, \u00acFINITE) to the body of each rule as a conjunct. Let \u03a0\u2020 be the union of \u03a0\u25e60, \u03a0 \u22c4 0 and \u03a0T. Let \u03bd = \u03c5(\u03a0\u2020) \u2212 \u03c5(\u03a0). Now, we show that \u2203\u03bdSM(\u03a0\u2020) is equivalent to SM(\u03a0) over arbitrary structures. By definition and the splitting lemma in [15], it suffices to show that SM(\u03a0) is equivalent to\n\u2203FINITE[\u2203\u03c3SM(\u03a0\u25e60) \u2227 \u2203\u03c4SM(\u03a0 \u22c4 0) \u2227 \u2203\u03c0SM(\u03a0T)]. (54)\nLet A be a structure of \u03c5(\u03a0). As a strict partial order always exists on domain A, we can construct an \u03c5(\u03a0) \u222a \u03c5(\u03a0T)-expansion B of A such that B is a stable model of \u03a0T. By the claim, B |= FINITE if and only if A is finite. First assume that A is finite. By definition, it is clear that \u2203\u03c3SM(\u03a0\u25e60) is satisfied by B if and only if \u2203\u03c3SM(\u03a0\n\u25e6) is satisfied by A, and \u2203\u03c3SM(\u03a0\u22c40) is always true in B. This means that \u2203\u03bdSM(\u03a0\n\u2020) is equivalent to SM(\u03a0) over finite structures. By a symmetrical argument, we can show that the equivalence also holds over infinite structures. This then completes the proof.\nRemark 6. In classical logic, it is well-known that separating languages over arbitrary structures is usually easier than that over finite structures [8]. In logic programming, it also seems that arbitrary structures are better-behaved than finite structures. For example, there are some preservation theorems that work on arbitrary structures, but not on finite structures [2]. Thus, it might be possible to develop techniques on arbitrary structures for some stronger separations of DLP from NLP.\nCorollary 3. DLP \u2243 NLP iff NP = coNP.\nNext, we give a characterization for disjunctive programs.\nProposition 8. DLP \u2243 \u03a312[\u2200 \u2217\u2203\u2217].\nProof. (Sketch) The direction \u201c\u2264\u201d trivially follows from the second-order definition of stable model semantics. So, it remains to show the converse. Let \u03d5 be a sentence in \u03a312[\u2200 \u2217\u2203\u2217]. Without loss of generality, assume that \u03d5 is of the form\n\u2203\u03c4\u2200\u03c3\u2200x\u0304\u2203y\u0304[\u03d11(x\u0304, y\u0304) \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03d1k(x\u0304, y\u0304)] (55)\nwhere \u03c4 and \u03c3 are two finite sets of predicates; x\u0304 and y\u0304 two finite tuples of individual variables; each \u03d1i is a conjunction of atoms or negated atoms. Let n be the length of x\u0304.\nNow, we construct a translation. Firstly, let us define\n\u039b1 = {TX(x\u0304, z\u0304) \u2228 FX(x\u0304, z\u0304) | X \u2208 \u03c3 \u222a \u03c4 },\n\u039b2 = { D(x\u0304) \u2192 FX(x\u0304, z\u0304) | X \u2208 \u03c3 },\n\u039b3 = { D(x\u0304) \u2192 TX(x\u0304, z\u0304) | X \u2208 \u03c3 }, \u039b4 = { \u03d1 \u22c4 i (x\u0304, y\u0304) \u2192 D(x\u0304) | 1 \u2264 i \u2264 k },\n\u039b5 = { \u00acD(x\u0304) \u2192 \u22a5 },\n(56)\nwhere, for each X \u2208 \u03c3\u222a\u03c4 , TX and FX are two distinct new predicates of arity (m+n) if m is the arity of X ; each \u03d1\u22c4i is the formula obtained from \u03d1i by substituting FX(x\u0304, t\u0304) for \u00acX(t\u0304) and followed by substituting TX(x\u0304, t\u0304) for X(t\u0304) whenever X \u2208 \u03c3 \u222a \u03c4 and t\u0304 is a tuple of terms of the corresponding length; and D is an n-ary new predicate.\nLet \u03a0 be the union of \u039b1, . . . ,\u039b5. Clearly, \u03a0 is a disjunctive program. Let \u03c0 be the set of new predicates introduced in the translation. By a similar argument to that in Lemma 4, we can show that \u03d5 is equivalent to \u2203\u03c0SM(\u03a0)."}, {"heading": "Conclusion and Related Work", "text": "Combining the results proved in previous sections with some existing results, we then obtain an almost complete picture for the expressiveness of logic programs and some related fragments of second-order logic. As shown in Figure 1, the expressiveness hierarchy in each subfigure is related to a structure class. In each subfigure, the syntactical classes in a same block are proved to be of the same expressiveness over the related structure class. A block is closer to the top, the classes in the block are then more expressive. In addition, a dashed line means that the corresponding separation is true if and only if NP is not closed under complement.\nWithout involving the well-known complexity conjecture, we established the intranslatability from disjunctive to normal programs over finite structures if the arities of auxiliary constants are bounded in a certain sense. This can be regarded as evidence\nthat disjunctive programs are more expressive than normal programs over finite structures. As a byproduct, we also developed a succinct translation from normal programs to first-order sentences. This then improved the ordered completion proposed by [3].\nThere are several existing works contributing to Figure 1, which are listed as follows. The translatability from \u03a311 to \u03a31F1 [\u2200\u2217] follows from the well-known Skolem normal form. The translatability from \u03a312 to \u03a3 1 2[\u2200\n\u2217\u2203\u2217] over finite structures is due to [20]. The separation of \u03a312 from \u03a312[\u2200\u2217\u2203\u2217] (on both arbitrary and infinite structures) is due to [10]. From NLP to \u03a311, both the intranslatability over arbitrary structures and the translatability over finite structures are due to [3].\nThe (in)translatability between first-order theories and logic programs were also considered in [29]. But first-order theories there are based on non-monotonic semantics. Over Herbrand structures, [26, 9] proved that normal programs, disjunctive programs and universal second-order logic are of the same expressiveness under the query equivalence. Their proofs employ an approach from recursion theory. However, this approach seems difficult to be applied to general infinite structures. In the propositional case, there have been a lot of works on the translatability and expressiveness of logic programs, e.g., [12, 19]. It should be noted that the picture of expressiveness and translatability in there is quite different from that in the first-order case."}], "references": [{"title": "\u03a311-formulae on finite structures", "author": ["M. Ajtai"], "venue": "Annals of Pure and Applied Logic 24 ", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1983}, {"title": "Datalog vs first-order logic", "author": ["M. Ajtai", "Y. Gurevich"], "venue": "Journal of Computer and System Sciences 49 ", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1994}, {"title": "Ordered completion for first-order logic programs on finite structures", "author": ["V. Asuncion", "F. Lin", "Y. Zhang", "Y. Zhou"], "venue": "Artificial Intelligence 177\u2013179 ", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Propositional semantics for disjunctive logic programs", "author": ["R. Ben-Eliyahu", "R. Dechter"], "venue": "Annals of Mathematics and Artificial Intelligence 12 ", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1994}, {"title": "Complexity and expressive power of logic programming", "author": ["E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov"], "venue": "ACM Computing Surveys 33 ", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "New results on arity vs", "author": ["A. Durand", "E. Grandjean", "F. Olive"], "venue": "number of variables, Research report 20\u20132004, LIF, Marseille, France ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2004}, {"title": "Subclasses of binary NP", "author": ["A. Durand", "C. Lautemann", "T. Schwentick"], "venue": "Journal of Logic and Computation 8 ", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1998}, {"title": "Finite model theory", "author": ["H.-D. Ebbinghaus", "J. Flum"], "venue": "2 ed., Springer-Verlag, New York", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1999}, {"title": "Expressiveness of stable model semantics for disjunctive logic programs with functions", "author": ["T. Eiter", "G. Gottlob"], "venue": "The Journal of Logic Programming 33 ", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1997}, {"title": "Normal forms for second-order logic over finite structures", "author": ["T. Eiter", "G. Gottlob", "Y. Gurevich"], "venue": "and classication of NP optimization problems, Annals of Pure and Applied Logic 78 ", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1996}, {"title": "Disjunctive datalog", "author": ["T. Eiter", "G. Gottlob", "H. Mannila"], "venue": "ACM Transactions on Database Systems 22 ", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1997}, {"title": "On eliminating disjunctions in stable logic programming", "author": ["Thomas Eiter", "Michael Fink", "Hans Tompits", "Stefan Woltran"], "venue": "Proceedings of KR,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2004}, {"title": "Generalized first-order spectra and polynomial-time recognizable sets", "author": ["R. Fagin"], "venue": "Complexity of Computation, SIAM-AMS Proceedings, vol. 7", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1974}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175 ", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "Symmetric splitting in the general theory of stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Proceedings of IJCAI", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of ICLP/SLP", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1988}, {"title": "Universal quantifiers and time complexity of random access machines", "author": ["Etienne Grandjean"], "venue": "Mathematical Systems Theory", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1985}, {"title": "Descriptive complexity, Graduate texts in computer", "author": ["Neil Immerman"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1999}, {"title": "Some (in)translatability results for normal logic programs and propositional theories", "author": ["Tomi Janhunen"], "venue": "Journal of Applied Non-Classical Logics", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2006}, {"title": "Descriptive characterizations of computational complexity", "author": ["D. Leivant"], "venue": "Journal of Computer and System Sciences 39 ", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1989}, {"title": "Cmodels-2: SAT-based answer set solver enhanced to non-tight programs", "author": ["Yuliya Lierler", "Marco Maratea"], "venue": "Proceedings of LPNMR,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2004}, {"title": "Assat: computing answer sets of a logic program by sat solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157 ", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2004}, {"title": "From answer set logic programming to circumscription via logic of GK", "author": ["F. Lin", "Y. Zhou"], "venue": "Artificial Intelligence 175 ", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "Foundations of disjunctive logic programming", "author": ["J. Lobo", "J. Minker", "A. Rajasekar"], "venue": "The MIT Press, Cambridge", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1992}, {"title": "A first order nonmonotonic extension of constructive logic", "author": ["David Pearce", "Agust\u0142n Valverde"], "venue": "Studia Logica", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2005}, {"title": "The expressive powers of the logic programming semantics", "author": ["J.S. Schlipf"], "venue": "Journal of Computer and System Sciences 51 ", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1995}, {"title": "The polynomial-time hierarchy", "author": ["L.J. Stockmeyer"], "venue": "Theoretical Computer Science 3 ", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1977}, {"title": "First-order expressibility and boundedness of disjunctive logic programs", "author": ["Heng Zhang", "Yan Zhang"], "venue": "Proceedings of IJCAI,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2013}], "referenceMentions": [{"referenceID": 15, "context": "Nowadays, the most popular semantics for this formalism is the stable model semantics proposed by [16].", "startOffset": 98, "endOffset": 102}, {"referenceID": 13, "context": "To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via G\u00f6del\u2019s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.", "startOffset": 147, "endOffset": 151}, {"referenceID": 22, "context": "To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via G\u00f6del\u2019s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.", "startOffset": 179, "endOffset": 183}, {"referenceID": 24, "context": "To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via G\u00f6del\u2019s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.", "startOffset": 212, "endOffset": 216}, {"referenceID": 4, "context": "An excellent survey for these works can be found in [5].", "startOffset": 52, "endOffset": 55}, {"referenceID": 21, "context": ", [22, 21].", "startOffset": 2, "endOffset": 10}, {"referenceID": 20, "context": ", [22, 21].", "startOffset": 2, "endOffset": 10}, {"referenceID": 17, "context": "As the arity of auxiliary symbol is the most important factor to introduce nondeterminism [18], we will try to find translations with small arities of auxiliary symbols.", "startOffset": 90, "endOffset": 94}, {"referenceID": 13, "context": "For more details about this transformation, please refer to [14].", "startOffset": 60, "endOffset": 64}, {"referenceID": 27, "context": "This procedure is called the first-order Gelfond-Lifschitz reduction due to the following result: Proposition 1 ([28], Proposition 4).", "startOffset": 113, "endOffset": 117}, {"referenceID": 27, "context": "Progression Semantics In this subsection, we review a progression semantics proposed by [28], which generalizes the fixed point semantics of [24] to logic programming with default negation over arbitrary structures.", "startOffset": 88, "endOffset": 92}, {"referenceID": 23, "context": "Progression Semantics In this subsection, we review a progression semantics proposed by [28], which generalizes the fixed point semantics of [24] to logic programming with default negation over arbitrary structures.", "startOffset": 141, "endOffset": 145}, {"referenceID": 27, "context": "Proposition 2 ([28], Theorem 1).", "startOffset": 15, "endOffset": 19}, {"referenceID": 3, "context": "For Lemma 2, roughly speaking, the soundness is assured by the result that every head-cycle-free disjunctive program is equivalent to the normal program obtained by shifting [4].", "startOffset": 174, "endOffset": 177}, {"referenceID": 14, "context": "By the splitting lemma in [15] and the second-order transformation, it suffices to show that SM(\u03a0) is equivalent to the following formula", "startOffset": 26, "endOffset": 30}, {"referenceID": 2, "context": "The following proposition says that, over infinite structures, normal programs are more expressive than the existential second-order logic, which then strengthens a result in [3] where such a separation over arbitrary structures was obtained.", "startOffset": 175, "endOffset": 178}, {"referenceID": 9, "context": "1 in [10].", "startOffset": 5, "endOffset": 9}, {"referenceID": 12, "context": "By Fagin\u2019s Theorem [13] and Stockmeyer\u2019s logical characterization of the polynomial hierarchy [27],2 we have that \u03a312 \u2243FIN \u03a3 1 1 iff \u03a3 p 2 = NP.", "startOffset": 19, "endOffset": 23}, {"referenceID": 26, "context": "By Fagin\u2019s Theorem [13] and Stockmeyer\u2019s logical characterization of the polynomial hierarchy [27],2 we have that \u03a312 \u2243FIN \u03a3 1 1 iff \u03a3 p 2 = NP.", "startOffset": 94, "endOffset": 98}, {"referenceID": 10, "context": "3 in [11], or by Proposition 7 in this section, Leivant\u2019s normal form [20] and the definition of SM, we can conclude DLP \u2243FIN \u03a312; by Proposition 6 in this section, it holds that NLP \u2243FIN \u03a311.", "startOffset": 5, "endOffset": 9}, {"referenceID": 19, "context": "3 in [11], or by Proposition 7 in this section, Leivant\u2019s normal form [20] and the definition of SM, we can conclude DLP \u2243FIN \u03a312; by Proposition 6 in this section, it holds that NLP \u2243FIN \u03a311.", "startOffset": 70, "endOffset": 74}, {"referenceID": 2, "context": "The main idea is to extend the Clark completion by a progression simulation, so it is an improved version of the ordered completion proposed by [3].", "startOffset": 144, "endOffset": 147}, {"referenceID": 25, "context": "Let \u227a be a new binary predicate and \u031f a 1A similar result for traditional logic programs under the query equivalence can be obtained by the expressiveness results proved by [26, 11].", "startOffset": 173, "endOffset": 181}, {"referenceID": 10, "context": "Let \u227a be a new binary predicate and \u031f a 1A similar result for traditional logic programs under the query equivalence can be obtained by the expressiveness results proved by [26, 11].", "startOffset": 173, "endOffset": 181}, {"referenceID": 2, "context": "The maximal arity of auxiliary constants in our translation is only n (that of the ordered completion in [3] is 2n), which is optimal if Conjecture 13 in [6] is true.", "startOffset": 105, "endOffset": 108}, {"referenceID": 5, "context": "The maximal arity of auxiliary constants in our translation is only n (that of the ordered completion in [3] is 2n), which is optimal if Conjecture 13 in [6] is true.", "startOffset": 154, "endOffset": 157}, {"referenceID": 2, "context": "Similar to the work in [3], we can develop an answer set solver by calling some SMT solver.", "startOffset": 23, "endOffset": 26}, {"referenceID": 5, "context": "Assuming Conjecture 1 in [6], by the results of [17], NLP k then exactly captures the class of languages computable in O(n)-time (where n is the size of input) 3It implies ESO n[\u2200\u2217] \u2243FIN ESO F n[\u2200 ], where the latter is the class of sentences in ESO n[\u2200\u2217] with at most n individual variables.", "startOffset": 25, "endOffset": 28}, {"referenceID": 16, "context": "Assuming Conjecture 1 in [6], by the results of [17], NLP k then exactly captures the class of languages computable in O(n)-time (where n is the size of input) 3It implies ESO n[\u2200\u2217] \u2243FIN ESO F n[\u2200 ], where the latter is the class of sentences in ESO n[\u2200\u2217] with at most n individual variables.", "startOffset": 48, "endOffset": 52}, {"referenceID": 10, "context": "3 of [11], we can show that \u2203\u03c0\u2203\u03c4\u2203\u03c3SM(\u03a0) \u2261SUC \u2203\u03c4\u2200\u03c3\u03c6.", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "By definition and the splitting lemma in [15], it suffices to show that \u03c6 is equivalent to", "startOffset": 41, "endOffset": 45}, {"referenceID": 6, "context": "1 of [7], we have: Claim.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "1 in [1].", "startOffset": 5, "endOffset": 8}, {"referenceID": 14, "context": "By definition and the splitting lemma in [15], it suffices to show that SM(\u03a0) is equivalent to \u2203FINITE[\u2203\u03c3SM(\u03a0\u25e60) \u2227 \u2203\u03c4SM(\u03a0 \u22c4 0) \u2227 \u2203\u03c0SM(\u03a0T)].", "startOffset": 41, "endOffset": 45}, {"referenceID": 7, "context": "In classical logic, it is well-known that separating languages over arbitrary structures is usually easier than that over finite structures [8].", "startOffset": 140, "endOffset": 143}, {"referenceID": 1, "context": "For example, there are some preservation theorems that work on arbitrary structures, but not on finite structures [2].", "startOffset": 114, "endOffset": 117}, {"referenceID": 2, "context": "This then improved the ordered completion proposed by [3].", "startOffset": 54, "endOffset": 57}, {"referenceID": 19, "context": "The translatability from \u03a312 to \u03a3 1 2[\u2200 \u2203] over finite structures is due to [20].", "startOffset": 76, "endOffset": 80}, {"referenceID": 9, "context": "The separation of \u03a312 from \u03a32[\u2200\u2203] (on both arbitrary and infinite structures) is due to [10].", "startOffset": 88, "endOffset": 92}, {"referenceID": 2, "context": "From NLP to \u03a311, both the intranslatability over arbitrary structures and the translatability over finite structures are due to [3].", "startOffset": 128, "endOffset": 131}, {"referenceID": 25, "context": "Over Herbrand structures, [26, 9] proved that normal programs, disjunctive programs and universal second-order logic are of the same expressiveness under the query equivalence.", "startOffset": 26, "endOffset": 33}, {"referenceID": 8, "context": "Over Herbrand structures, [26, 9] proved that normal programs, disjunctive programs and universal second-order logic are of the same expressiveness under the query equivalence.", "startOffset": 26, "endOffset": 33}, {"referenceID": 11, "context": ", [12, 19].", "startOffset": 2, "endOffset": 10}, {"referenceID": 18, "context": ", [12, 19].", "startOffset": 2, "endOffset": 10}], "year": 2014, "abstractText": "The stable model semantics had been recently generalized to nonHerbrand structures by several works, which provides a unified framework and solid logical foundations for answer set programming. This paper focuses on the expressiveness of normal and disjunctive programs under the general stable model semantics. A translation from disjunctive programs to normal programs is proposed for infinite structures. Over finite structures, some disjunctive programs are proved to be intranslatable to normal programs if the arities of auxiliary predicates and functions are bounded in a certain way. The equivalence of the expressiveness of normal programs and disjunctive programs over arbitrary structures is also shown to coincide with that over finite structures, and coincide with whether NP is closed under complement. Moreover, to capture the exact expressiveness, some intertranslatability results between logic program classes and fragments of secondorder logic are obtained.", "creator": "LaTeX with hyperref package"}}}