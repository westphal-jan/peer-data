{"id": "1412.4160", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Dec-2014", "title": "Ripple Down Rules for Question Answering", "abstract": "Recent years have witnessed a new trend on building ontology-based question answering systems, that is to use semantic web information to provide more precise answers to users' queries. However, these systems are mostly designed for English, therefore, we introduce in this paper such a system for Vietnamese, that is, to the best of our knowledge, the first one made for Vietnamese. Different from most of previous works, we propose an approach that systematically builds a knowledge base of grammar rules for processing each input question into an intermediate representation element. Then we take this element with respect to a target ontology by applying concept-matching techniques for returning an answer. Experimental results show that the performance of the system on a wide range of Vietnamese questions is promising with accuracies of 84.1% and 82.4% for analyzing question and retrieving answer, respectively. Furthermore, our approach to the question analysis can easily be applied to new domains and new languages, thus saving time and human effort.", "histories": [["v1", "Fri, 12 Dec 2014 23:30:06 GMT  (360kb,D)", "https://arxiv.org/abs/1412.4160v1", "21 pages, 7 figures, 10 tables. This article extends the work described in our publications at RANLP2011 and ISWC2013 conferences"], ["v2", "Mon, 15 Jun 2015 14:20:55 GMT  (388kb,D)", "http://arxiv.org/abs/1412.4160v2", "v1: 21 pages, 7 figures, 10 tables. This article extends the works described in our conference publications at KSE2009, RANLP2011 and ISWC2013 conferences. v2: 8 figures, 10 tables; shorten section 2; majorly change sections 4.3 and 5.1.2"], ["v3", "Thu, 29 Oct 2015 14:14:09 GMT  (398kb,D)", "http://arxiv.org/abs/1412.4160v3", "V1: 21 pages, 7 figures, 10 tables. V2: 8 figures, 10 tables; shorten section 2; change sections 4.3 and 5.1.2. V3 (Author's manuscript): Accepted for publication in the Semantic Web journal, available fromthis http URL"], ["v4", "Wed, 4 Nov 2015 23:39:58 GMT  (398kb,D)", "http://arxiv.org/abs/1412.4160v4", "V1: 21 pages, 7 figures, 10 tables. V2: 8 figures, 10 tables; shorten section 2; change sections 4.3 and 5.1.2. V3: Accepted for publication in the Semantic Web journal. V4 (Author's manuscript): camera ready version, available from the Semantic Web journal atthis http URL"]], "COMMENTS": "21 pages, 7 figures, 10 tables. This article extends the work described in our publications at RANLP2011 and ISWC2013 conferences", "reviews": [], "SUBJECTS": "cs.CL cs.IR", "authors": ["dat quoc nguyen", "dai quoc nguyen", "son bao pham"], "accepted": false, "id": "1412.4160"}, "pdf": {"name": "1412.4160.pdf", "metadata": {"source": "CRF", "title": "Ripple Down Rules for Question Answering", "authors": ["Editor(s): Christina Unger", "Shizhu He", "Dat Quoc Nguyen", "Dai Quoc Nguyen", "Son Bao Pham"], "emails": ["dat.nguyen@students.mq.edu.au", "daiquocn@coli.uni-saarland.de", "sonpb@vnu.edu.vn", "dat.nguyen@students.mq.edu.au."], "sections": [{"heading": null, "text": "Keywords: Question answering, Question analysis, Single Classification Ripple Down Rules, Knowledge acquisition, Ontology, Vietnamese, English, DBpedia, Biomedical"}, {"heading": "1. Introduction", "text": "Accessing online resources often requires the support from advanced information retrieval technologies to produce expected information. This brings new challenges to the construction of information retrieval systems such as search engines and question answering (QA) systems. Given an input query expressed in a keyword-based mechanism, most search engines return a long list of title and short snippet pairs ranked by their relevance to the input query. Then the user has to scan the list to get the expected information, so this is a time consuming task [66]. Unlike search engines,\n*The first two authors contributed equally to this work. Corresponding author\u2019s e-mail: dat.nguyen@students.mq.edu.au.\nQA systems directly produce an exact answer to an input question. In addition, QA systems allow to specify the input question in natural language rather than as keywords. In general, an open-domain QA system aims to po-\ntentially answer any user\u2019s question. In contrast, a restricted-domain QA system only handles the questions related to a specific domain. Specifically, traditional restricted-domain QA systems make use of relational databases to represent target domains. Subsequently, with the advantages of the semantic web, the recent restricted-domain QA systems employ knowledge bases such as ontologies as the target domains [30]. Thus, semantic markups can be used to add metainformation to return precise answers for complex nat-\nAccepted for publication. Available from http://www.semantic-web-journal.net/ c\u00a9 2015 \u2013 IOS Press and the authors. All rights reserved\nar X\niv :1\n41 2.\n41 60\nv4 [\ncs .C\nural language questions. This is an avenue which has not been actively explored for Vietnamese. In this paper, we introduce the first ontology-based\nQA system for Vietnamese, which we call KbQAS. KbQAS consists of question analysis and answer retrieval components. The question analysis component uses a knowledge base of grammar rules for analyzing input questions; and the answer retrieval component is responsible for interpreting the input questions with respect to a target ontology. The association between the two components is an intermediate representation element which captures the semantic structure of any input question. This intermediate element contains properties of the input question including question structure, question category, keywords and semantic constraints between the keywords. The key innovation of KbQAS is that it proposes\na knowledge acquisition approach to systematically build a knowledge base for analyzing natural language questions. To convert a natural language question into an explicit representation in a QA system, most previous works so far have used rule-based approaches, to the best of our knowledge. The manual creation of rules in an ad-hoc manner is more expensive in terms of time and effort, and it is error-prone because of the representation complexity and the variety of structure types of the questions. For example, rule-based methods, such as for English [26] and for Vietnamese as described in the first KbQAS version [35], manually define a list of pattern structures to analyze the questions. As rules are created in an ad-hoc manner, these methods share common difficulties in controlling the interaction between the rules and keeping the consistency among them. In our question analysis approach, however, we apply Single Classification Ripple Down Rules knowledge acquisition methodology [10,47] to acquire the rules in a systematic manner, where consistency between rules is maintained and an unintended interaction among rules is avoided. Our approach allows an easy adaptation to a new domain and a new language and saves time and effort of human experts. The paper is organized as follows. We provide re-\nlated work in Section 2. We describe KbQAS and our knowledge acquisition approach for question analysis in Section 3 and Section 4, respectively. We evaluate KbQAS in Section 5. The conclusion will be presented in Section 6."}, {"heading": "2. Short overview of question answering", "text": ""}, {"heading": "2.1. Open-domain question answering", "text": "The goal of an open-domain QA system is to automatically return an answer for every natural language question [21,63,31]. For example, such systems as START [23], FAQFinder [8] and AnswerBus [68] answer questions over the Web. Subsequently, the question paraphrase recognition task is considered as one of the important tasks in QA. Many proposed approaches for this task are based on machine learning as well as knowledge representation and reasoning [7,22,48,67,16,5]. Since aroused by the QA track of the Text Retrieval Conference [59] and the multilingual QA track of the CLEF conference [42], many open-domain QA systems from the information retrieval perspective [24] have been introduced. For example, in the TREC-9 QA competition [58], the Falcon system [20] achieved the highest results. The innovation of Falcon focused on a method using WordNet [17] to boost its knowledge base. In the QA track of the TREC-2002 conference [60], the PowerAnswer system [33] was the most powerful system, using a deep linguistic analysis."}, {"heading": "2.2. Traditional restricted-domain question answering", "text": "Usually linked to relational databases, traditional restricted-domain QA systems are called natural language interfaces to databases. A natural language interface to a database (NLIDB) is a system that allows the users to access information stored in a database by typing questions using natural language expressions [2]. In general, NLIDB systems focus on converting the input question into an expression in the corresponding database query language. For example, the LUNAR system [64] transfers the input question into a parsed tree, and the tree is then directly converted into an expression in a database query language. However, it is difficult to create converting rules that directly transform the tree into the query expression. Later NLIDBs, such as Planes [61], Eufid [51], PRECISE [46], C-Phrase [32] and the systems presented in [50,34], use semantic grammars to analyze questions. The semantic grammars consist of the hardwired knowledge orienting a specific domain, so these NLIDB systems need to develop new grammars whenever porting to a new knowledge domain.\nFurthermore, some systems, such as TEAM [29] and MASQUE/SQL [1], use syntactic-semantic interpretation rules driving logical forms to process the input question. These systems firstly transform the input question into an intermediate logical expression of high-level world concepts without any relation to the database structure. The logical expression is then converted to an expression in the database query language. Here, using the logical forms enables those systems to adapt to other domains as well as to different query languages [49]. In addition, there are many systems also using logical forms to process the input question, e.g. [52,33,56,18,15,25,6]."}, {"heading": "2.3. Ontology-based question answering", "text": "As a knowledge representation of a set of concepts and their relations in a specific domain, an ontology can provide semantic information to handle ambiguities, to interpret and answer user questions in terms of QA [27]. A discussion on the construction approach of an ontology-based QA system can be found in [4]. This approach was then applied to build the MOSES system [3], with the focus on the question analysis. The following systems are some typical ontology-based QA systems. The AquaLog system [26] performs semantic and syntactic analysis of the input question using resources including word segmentation, sentence segmentation and part-of-speech tagging, provided by the GATE framework [11]. When a question is asked, AquaLog transfers the question into a query-triple form of (generic term, relation, second term) containing the keyword concepts and relations in the question, using JAPE grammars in GATE. AquaLog then matches each element in the query-triple to an element in the target ontology to create an onto-triple, using string-based comparison methods and WordNet [17]. Evolved from AquaLog, the PowerAqua system [28] is an open-domain system, combining the knowledge from various heterogeneous ontologies which were autonomously created on the semantic web. Meanwhile, the PANTO system [62] relies on the statistical Stanford parser to map an input question into a query-triple; the query-triple is then translated into an onto-triple with the help of a lexicon of all entities from a given target ontology enlarged with WordNet synonyms; finally, the onto-triple and potential words derived from the parse tree are used to produce a SPARQL query on the target ontology.\nUsing the gazetteers in the GATE framework, the QuestIO system [12] identifies the keyword concepts in an input question. Then QuestIO retrieves potential relations between the concepts before ranking these relations based on their similarity, distance and specificity scores; and so QuestIO creates formal SeRQL or SPARQL queries based on the concepts and the ranked relations. Later the FREyA system [13], the successor of QuestIO, allows users to enter questions in any form and interacts with the users to handle ambiguities if necessary. In the ORAKEL system [9], wh-questions are converted to F-Logic or SPARQL queries by using domainspecific Logical Description Grammars. Although ORAKEL supports compositional semantic constructions and obtains a promising performance, it involves a customization process of the domain-specific lexicon. Also, another interesting work over linked data as detailed in [55] proposed an approach to convert the syntactic-semantic representations of the input questions into the SPARQL templates. Furthermore, the Pythia system [54] relies on ontology-based grammars to process complex questions. However, Pythia requires a manually created lexicon."}, {"heading": "2.4. Question answering and question analysis for Vietnamese", "text": "Turning to Vietnamese question answering, Nguyen and Le [34] introduced a Vietnamese NLIDB system using semantic grammars. Their system includes two main modules: the query translator (QTRAN) and the text generator (TGEN). QTRAN maps an input natural language question to an SQL query, while TGEN generates an answer based on the table result of the SQL query. The QTRAN module uses limited context-free grammars to convert the input question into a syntax tree by means of the CYK algorithm [65]. The syntax tree is then converted into an SQL query by using a dictionary to identify names of attributes in the database and names of individuals stored in these attributes. The TGEN module combines pattern-based and keywordbased approaches to make sense of the meta-data and relations in database tables to produce the answer. In our first KbQAS conference publication [35], we reported a hard-wired approach to convert input questions into intermediate representation elements which are then used to extract the corresponding elements from a target ontology to return answers. Later, Phan and Nguyen [45] described a method to map Vietnamese questions into triple-like formats (Subject,\nVerb, Object). Subsequently, Nguyen and Nguyen [40] presented another ontology-based QA system for Vietnamese, where keywords in an input question are identified by using pre-defined templates, and these keywords are then used to produce a SPARQL query to retrieve a triple-based answer from a target ontology. In addition, Tran et al. [53] described the VPQA system to answer person name-related questions while Nguyen et al. [41] presented another NLIDB system to answer questions in the economic survey domain."}, {"heading": "3. Our KbQAS question answering system", "text": "This section gives an overview of KbQAS. The architecture of KbQAS, as shown in Figure 1, contains two components: the natural language question analysis engine and the answer retrieval component.\nThe question analysis component consists of three modules: preprocessing, syntactic analysis and semantic analysis. This component takes the user question as an input and returns an intermediate element representing the input question in a compact form. The role of the intermediate representation element is to provide the structured information about the input question for the later process of answer retrieval. The answer retrieval component contains two modules: ontology mapping and answer extraction. It takes the intermediate representation element produced by the question analysis component and an ontology as its input to generate the answer."}, {"heading": "3.1. Intermediate representation of an input question", "text": "Unlike AquaLog [26], the intermediate representation element in KbQAS covers a wider variety of question types. This element consists of a question structure and one or more query tuples in the following format:\n(sub-structure, question category, Term1, Relation, Term2, Term3) where Term1 represents a concept (i.e. an object class), excluding the cases of Affirm, Affirm_3Term and Affirm_MoreTuples question structures. In addition, Term2 and Term3 represent entities (i.e. objects or instances), excluding the cases of Definition and Compare question structures. Furthermore, Relation is a semantic constraint between the terms. We define the following question structures: Normal, UnknTerm, UnknRel, Definition, Compare, ThreeTerm, Clause, Combine, And, Or, Affirm_MoreTuples, Affirm, Affirm_3Term, and question categories: What, When, Where, Who, HowWhy, YesNo, Many, ManyClass, List and Entity. See Appendix A and Appendix B for details of these definitions. A simple question has only one query tuple and its question structure is the sub-structure in the query tuple. A complex question, such as a composite one, has several sub-questions, where each sub-question is represented by a separate query tuple, and the question structure captures this composite factor. For example, the question \u201cPh\u1ea1m \u0110\u1ee9c \u0110\u0103ng h\u1ecdc tr\u01b0\u1eddng \u0111\u1ea1i h\u1ecdc n\u00e0o v\u00e0 \u0111\u01b0\u1ee3c h\u01b0\u1edbng d\u1eabn b\u1edfi ai ?\u201d (\u201cWhich university does Pham Duc Dang enroll in and who tutors him ?\u201d) has the Or question structure and two query tuples where ? represents a missing attribute: (Normal, Entity, tr\u01b0\u1eddng \u0111\u1ea1i h\u1ecdcuniversity, h\u1ecdcenroll, Ph\u1ea1m \u0110\u1ee9c \u0110\u0103ngPham Duc Dang, ?) and (UnknTerm, Who, ?, h\u01b0\u1edbng d\u1eabntutor, Ph\u1ea1m \u0110\u1ee9c \u0110\u0103ng Pham Duc Dang, ?). The intermediate representation element is designed so that it can represent various types of question structures. Therefore, attributes such as Relation or terms in the query tuple can be missing. For example, a question has the Normal question structure if it has only one query tuple and Term3 is missing."}, {"heading": "3.2. An illustrative example", "text": "For demonstration1 [38] and evaluation purposes, we reuse an ontology which models the organizational system of the VNU University of Engineering and Technology, Vietnam. The ontology contains 15 concepts such as \u201ctr\u01b0\u1eddngschool\u201d, \u201cgi\u1ea3ng vi\u00eanlecturer\u201d and \u201csinh vi\u00eanstudent\u201d, 17 relations or properties such as \u201ch\u1ecdcenroll\u201d, \u201cgi\u1ea3ng d\u1ea1yteach\u201d and \u201cl\u00e0 sinh vi\u00ean c\u1ee7a\n1The KbQAS is available at http://150.65.242.39:8080/KbQAS/ with an intro video on YouTube at http://youtu.be/M1PHvJvv1Z8.\nis student of\u201d, and 78 instances, as described in our first KbQAS version [35]. Given a complex-structure question \u201cLi\u1ec7t k\u00ea t\u1ea5t c\u1ea3 sinh vi\u00ean h\u1ecdc l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednh m\u00e0 c\u00f3 qu\u00ea \u1edf H\u00e0 N\u1ed9i\u201d (\u201cList all students enrolled in the K50 computer science course, whose hometown is Hanoi\u201d), the question analysis component determines that this question has the And question structure with two query tuples (Normal, List, sinh vi\u00eanstudent, h\u1ecdcenrolled, l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednhK50 computer science course, ?) and (Normal, List, sinh vi\u00eanstudent, c\u00f3 qu\u00eahas hometown, H\u00e0 N\u1ed9iHanoi, ?). In the answer retrieval component, the ontology mapping module maps the query tuples to ontology tuples: (sinh vi\u00eanstudent, h\u1ecdcenrolled, l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednhK50 computer science course) and (sinh vi\u00eanstudent, c\u00f3 qu\u00eahas hometown, H\u00e0 N\u1ed9iHanoi). For each ontology tuple, the answer extraction module finds all satisfied instances in the target ontology, and it then generates an answer based on the And question structure and the List question category. Figure 2 shows the answer."}, {"heading": "3.3. Natural language question analysis component", "text": "The natural language question analysis component is the first component in any QA system. When a question is asked, the task of this component is to convert\nthe input question into an intermediate representation which is then used in the rest of the system. KbQAS makes use of the JAPE grammars in the GATE framework [11] to specify semantic annotationbased regular expression patterns for question analysis, in which existing linguistic processing modules for Vietnamese including word segmentation and part-ofspeech tagging [43] are wrapped as GATE plug-ins. The results of the wrapped plug-ins are annotations covering sentences and segmented words. Each annotation has a set of feature-value pairs. For example, a word has a category feature storing its part-of-speech tag. This information can then be reused for further processing in subsequent modules. The new question analysis modules of preprocessing, syntactic analysis and semantic analysis in KbQAS are specifically designed to handle Vietnamese questions using patterns over existing linguistic annotations."}, {"heading": "3.3.1. Preprocessing module", "text": "The preprocessing module generates TokenVn annotations representing a Vietnamese word with features, such as part-of-speech, as displayed in Figure 3. Vietnamese is a monosyllabic language; hence, a word can contain more than one token. So there are words or word phrases which are indicative of the question categories, such as \u201cph\u1ea3i kh\u00f4ngis that / are there\u201d, \u201cl\u00e0 bao\nnhi\u00eauhow many\u201d, \u201c\u1edf \u0111\u00e2uwhere\u201d, \u201ckhi n\u00e0owhen\u201d and \u201cl\u00e0 c\u00e1i g\u00ecwhat\u201d. However, the Vietnamese word segmentation module was not trained on the question domain. In this module, therefore, we identify those words or phrases and label them as single TokenVn annotations with the question-word feature and its semantic category, like HowWhycause / method, YesNotrue or false, Whatsomething, Whentime / date, Wherelocation, Manynumber or Whoperson. In fact, this information will be used to create rules in the syntactic analysis module at a later stage.\nWe also label special words, such as abbreviations of words on a special domain, and phrases that refer to a comparison, such as \u201cl\u1edbn h\u01a1ngreater than\u201d, \u201cnh\u1ecf h\u01a1n ho\u1eb7c b\u1eb1ngless than or equal to\u201d and the like, by single TokenVn annotations."}, {"heading": "3.3.2. Syntactic analysis", "text": "The syntactic analysis module is responsible for\nidentifying concepts, entities and the relations between them in the input question. This module uses the TokenVn annotations which are the output of the preprocessing module. Concepts and entities are normally expressed in\nnoun phrases. Therefore, it is crucial to identify noun phrases in order to generate the query tuple. Based on the Vietnamese language grammar [14], we use the JAPE grammars to specify patterns over annotations as shown in Table 1. When a noun phrase is matched, a NounPhrase annotation is created to mark up the noun phrase. In addition, a type feature of the NounPhrase annotation is used to determine whether concept or entity is covered by the noun phrase, using the following heuristics: if the noun phrase contains a single noun (not including numeral nouns) and does not contain a proper noun, it covers a concept. If the noun phrase contains a proper noun or at least three single nouns,\nit covers an entity. Otherwise, the type feature value is determined by using a dictionary2. Furthermore, the question phrases are detected by using the matched noun phrases and the questionwords which are identified by the preprocessing module. QuestionPhrase annotations are generated to cover the question phrases, with a category feature that gives information about question categories. The next step is to identify relations between noun phrases or between a noun phrase and a question phrase. When a phrase is matched by one of the relation patterns, a Relation annotation is created to markup the relation. We use the following four grammar patterns to determine relation phrases:\n(Verb)+ (Noun Phrasetype == Concept) (Preposition)(Verb)? (Verb)+((Preposition)(Verb)?)? ((\u201cc\u00f3have/has\u201d)|(Verb))+ (Adjective) (Preposition) (Verb)? (\u201cc\u00f3have/has\u201d) ((Noun Phrasetype == Concept)|(Adjective)) (\u201cl\u00e0is/are\u201d)\n2The dictionary contains concepts which are extracted from the target ontology. However, there is no publicly available WordNetlike lexicon for Vietnamese. So we manually add synonyms of the extracted concepts to the dictionary.\nFor example, we can describe the first question \u201cLi\u1ec7t k\u00ea t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00ean c\u00f3 qu\u00ea qu\u00e1n \u1edf H\u00e0 N\u1ed9i\u201d (\u201cList all students whose hometown is Hanoi\u201d) in Figure 4, using NounPhrase, Relation and QuestionPhrase annotations as follows: [QuestionPhrase: Li\u1ec7t k\u00ealist [NounPhrase: t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00eanall students]] [Relation: c\u00f3 qu\u00ea qu\u00e1n \u1edfhave hometown] [NounPhrase: H\u00e0 N\u1ed9iHanoi] The phrase \u201cc\u00f3 qu\u00ea qu\u00e1n \u1edfhave hometown\u201d is the relation linking the question phrase \u201cli\u1ec7t k\u00ea t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00eanlist all students\u201d and the noun phrase \u201cH\u00e0 N\u1ed9iHanoi\u201d."}, {"heading": "3.3.3. Semantic analysis module", "text": "The semantic analysis module aims to identify the question structure and produce the query tuples (substructure, question category, Term1, Relation, Term2, Term3) as the intermediate representation element of the input question, using the TokenVn, NounPhrase, Relation and QuestionPhrase annotations returned by the two previous modules. Existing NounPhrase annotations and Relation annotations are potential candidates for terms and relations in the query tuples, respectively. In addition, QuestionPhrase annotations are used to detect the question category. In the first KbQAS version [35], following AquaLog [26], we developed an ad-hoc approach to detect structure patterns of questions and then use these patterns to generate the intermediate representation elements. For example, Figure 4 presents the detected structure patterns of the two example questions \u201cLi\u1ec7t k\u00ea t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00ean c\u00f3 qu\u00ea qu\u00e1n \u1edf H\u00e0 N\u1ed9i\u201d (\u201cList all students whose hometown is Hanoi\u201d) and \u201cDanh s\u00e1ch t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00ean c\u00f3 qu\u00ea qu\u00e1n \u1edf H\u00e0 N\u1ed9i m\u00e0 h\u1ecdc l\u1edbp khoa h\u1ecdc m\u00e1y t\u00ednh\u201d (\u201cList all students enrolled in the computer science course, whose hometown is Hanoi\u201d). We can describe these questions by using annotations generated by the preprocessing and syntactic analysis modules as follows: [QuestionPhrase: Li\u1ec7t k\u00ea t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00eanList all students] [Relation: c\u00f3 qu\u00ea qu\u00e1n \u1edfhave hometown] [NounPhrase: H\u00e0 N\u1ed9iHanoi]\nand\n[QuestionPhrase: Li\u1ec7t k\u00ea t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00eanList all students] [Relation: c\u00f3 qu\u00ea qu\u00e1n \u1edfhave hometown] [NounPhrase: H\u00e0 N\u1ed9iHanoi] [And: [TokenVn: m\u00e0and]] [Relation: h\u1ecdcenrolled] [NounPhrase: l\u1edbp khoa h\u1ecdc m\u00e1y t\u00ednhcomputer science course]\nThe intermediate representation element of an input question is created in a hard-wired manner linking every detected structure pattern via JAPE grammars. This hard-wired manner takes a lot of time and effort to handle new patterns. For example in Figure 4, the hard-wired approach is unable to reuse the detected structure pattern of the first question to identify the structure pattern of the second question. Since JAPE grammar rules were created in an ad-hoc manner, the hard-wired approach encounters common difficulties in managing the interaction among rules and keeping consistency. Consequently, in this module, we solve the mentioned difficulties by proposing a knowledge acquisition approach for the semantic analysis of input questions, as detailed in Section 4. In this paper, this is considered as the key innovation of KbQAS."}, {"heading": "3.4. Answer retrieval component", "text": "As presented in the first KbQAS version [35], the answer retrieval component includes two modules: ontology mapping and answer extraction, as shown in Figure 1. It takes the intermediate representation produced by the question analysis component and a target ontology as its input to generate an answer. To develop the answer retrieval component in KbQAS, we employed the relation similarity service component of AquaLog [26]. The task of the ontology mapping module is to map terms and relations in the query tuple to concepts, instances and relations in the target ontology by using string names. If an exact match is not possible, we use a string distance algorithm [57] and the dictionary\ncontaining concepts and their synonyms to find nearmatched elements from the target ontology, with the similarity measure above a certain threshold. In case the ambiguity is still present, KbQAS interacts with users by showing different options, and the users then choose the suitable ontology element. For example, given the question \u201cLi\u1ec7t k\u00ea t\u1ea5t c\u1ea3 c\u00e1c sinh vi\u00ean h\u1ecdc l\u1edbp khoa h\u1ecdc m\u00e1y t\u00ednh\u201d (\u201cList all students enrolled in the computer science course\u201d), the question analysis component produces a query tuple (Normal, List, sinh vi\u00eanstudent, h\u1ecdcenrolled, l\u1edbp khoa h\u1ecdc m\u00e1y t\u00ednhcomputer science course, ?). Because the ontology mapping module cannot find the exact instance corresponding to \u201cl\u1edbp khoa h\u1ecdc m\u00e1y t\u00ednh computer science course\u201d in the target ontology, it requires the user to select between \u201cl\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednh K50 computer science course\u201d - an instance of class \u201cl\u1edbpcourse\u201d, and \u201cb\u1ed9 m\u00f4n khoa h\u1ecdc m\u00e1y t\u00ednhcomputer science department\u201d - an instance of class \u201cb\u1ed9 m\u00f4ndepartment\u201d.\nFollowing AquaLog, for each query tuple, the result of the ontology mapping module is an ontology tuple where the terms and relations in the query tuple are now the corresponding elements from the target ontology. How the ontology mapping module finds the corresponding elements from the target ontology depends on the question structure. For example, when the query tuple contains Term1, Term2 and Relation with Term3 missing, the mapping process follows the diagram shown in Figure 5. The mapping process first\ntries to match Term1 and Term2 with concepts or instances in the target ontology. Then the mapping process finds a set of potential relations between the two mapped concepts/instances from the target ontology. The ontology relation is finally identified by mapping Relation to a relation in the potential relation set, using a manner similar to mapping a term to a concept or an instance. With the ontology tuple, the answer extraction module finds all individuals of the ontology concept corresponding to Term1, having the ontology relation with the ontology individual corresponding to Term2. The answer extraction module then returns the answer based on the question structure and question category. See the definitions of question structure and question category types in Appendix A and Appendix B."}, {"heading": "4. Single Classification Ripple Down Rules for question analysis", "text": "As mentioned in Section 3.3.3, due to the representation complexity and the variety of question structures, manually creating grammar rules in an ad-hoc manner is very expensive and error-prone. For example, such rule-based approaches as presented in [26,35,45] manually defined a list of sequence pattern structures to analyze questions. Since rules were created in an ad-hoc manner, these approaches share common difficulties in managing the interaction between rules and keeping consistency among them. This section introduces our knowledge acquisition approach3 to analyze natural language questions by applying the Single Classification Ripple Down Rules (SCRDR) methodology [10,47] to acquire rules incrementally. Our contribution focuses on the semantic analysis module by proposing a JAPE-like rule language and a systematic processing to create rules in a manner that the interaction among rules is controlled and consistency is maintained. Compared to the first KbQAS version [35], this is the key innovation of the current KbQAS version. A SCRDR knowledge base is built to identify the question structures and to produce the query tuples as the intermediate representations of the input questions. We outline the SCRDR methodology and propose a\n3The English question analysis demonstration is available online at http://150.65.242.39:8080/KbEnQA/, and the Vietnamese question analysis demonstration is available online at http://150.65. 242.39:8080/KbVnQA/.\nrule language for extracting the intermediate representation of a given question in Section 4.1 and Section 4.2, respectively. We then illustrate the process of systematically constructing a SCRDR knowledge base for analyzing questions in Section 4.3."}, {"heading": "4.1. Single Classification Ripple Down Rules", "text": "This section presents the basic idea of Single Classification Ripple Down Rules (SCRDR) [10,47] which inspired our knowledge acquisition approach for question analysis. A SCRDR tree is a binary tree with two distinct types of edges. These edges are typically called except and false edges. Associated with each node in a tree is a rule. A rule has the form: if \u03b1 then \u03b2 where \u03b1 is called the condition and \u03b2 is called the conclusion.\nCases in SCRDR are evaluated by passing a case to the root node of the SCRDR tree. At any node in the SCRDR tree, if the condition of the rule at a node \u03b7 is satisfied by the case (so the node \u03b7 fires), the case is passed on to the except child node of the node \u03b7 using the except edge if it exists; otherwise, the case is passed on to the false child node of the node \u03b7. The conclusion given by this process is the conclusion from the node which fired last. Given the question \u201cWho are the partners involved in AKT project ?\u201d and the SCRDR tree in Figure 6, it is satisfied by the rule at the root node (0). Then it is passed to node (1) using the except edge. As the case satisfies the condition of the rule at node (1), it\nis passed to node (2) using the except edge. Because the case does not satisfy the condition of the rule at node (2), it is then passed to node (3) using the false edge. As the case satisfies the conditions of the rules at nodes (3), (5) and (40), it is passed to node (42), using except edges. Since the case does not satisfy the conditions of the rules at nodes (42), (43) and (45), we have the evaluation path (0)-(1)-(2)-(3)-(5)-(40)-(42)- (43)-(45) with the last fired node (40). Given another case of \u201cIn which projects is enrico motta working on\u201d, it satisfies the conditions of the rules at nodes (0), (1) and (2); as node (2) has no except child node, we have the evaluation path (0)-(1)-(2) and the last fired node (2). A new node containing a new exception rule is added to an SCRDR tree when the evaluation process returns an incorrect conclusion. The new exception node is attached to the last node in the evaluation path of the given case as an except edge if the last node is the fired node; otherwise, it is attached as an false edge. To ensure that a conclusion is always reached, the root node, called the default node, typically contains a trivial condition which is always satisfied. The rule at the default node, the default rule, is the unique rule which is not an exception rule of any other rule. For example, the default rule \u201cif True then null\u201d from the SCRDR tree in Figure 6 means that its True condition satisfies every question, however, its null conclusion produces an empty intermediate representation element for every question. Started with a SCRDR knowledge base consisting of only the default node, the process of building the knowledge base can be performed automatically [37,39] or manually [44,36]. In the SCRDR tree from Figure 6, the rule at node (1) (simply, rule 1) is an exception rule of the default rule 0. Rule 2 is an exception rule of rule 1. As node (3) is the false-child node of node (2), the rule 3 is also an exception rule of rule 1. Furthermore, both rules 4 and 9 are also exception rules of rule 1. Similarly, all rules 40, 41 and 46 are exception rules of rule 5 while all rules 42, 43 and 45 are exception rules of rule 40. Therefore, the exception structure of the SCRDR tree extends to 5 levels, for examples: rules 1 at layer 1; rules 2, 3, 4 and 9 at layer 2; rules 5, 7, 21 and 22 at layer 3; and rules 40, 41, 46 and 50 at layer 4; and rules 42, 43, 44 and 45 at the layer 5 exception structure."}, {"heading": "4.2. Rule language", "text": "A rule is composed of a condition part and a conclusion part. A condition is a regular expression pattern\nover annotations using JAPE grammars in GATE [11]. It can also post new annotations over matched phrases of the pattern\u2019s sub-components. As annotations have feature-value pairs, we can impose constraints on the annotations in the pattern by specifying that a feature of an annotation must have a particular value. The following example shows the posting of an annotation over the matched phrase: (({TokenVn.string == \u201cli\u1ec7t k\u00ealist\u201d} |\n{TokenVn.string == \u201cch\u1ec9 rashow\u201d})\n{NounPhrase.type == \u201cConcept\u201d}):qp\n99K :qp.QuestionPhrase = {category = \u201cList\u201d}\nEvery complete pattern followed by a label must be enclosed by round brackets. In the above pattern, the label is qp. The pattern would match phrases starting with a TokenVn annotation covering either the word \u201cli\u1ec7t k\u00ealist\u201d or the word \u201cch\u1ec9 rashow\u201d, followed by a NounPhrase annotation covering a concept-typed noun phrase. When applying this pattern on a text fragment, QuestionPhrase annotations having the category feature with its List value would be posted over phrases matched by the pattern. Furthermore, the condition part of a rule can include additional constraints. See examples of the additional constraints from the constructions of rules (40) and (45) in Section 4.3. The conclusion part of a rule produces an intermediate representation containing the question structure\nand the query tuples, where each attribute in the query tuples is specified by a newly posted annotation from matching the rule\u2019s condition, in the following order:\n(sub-structure, question category, Term1, Relation, Term2, Term3)\nAll newly posted annotations have the same RDR prefix and the rule index so that a rule can refer to annotations of its parent rules. Examples of rules and how rules are created and stored in an exception structure will be explained in details in Section 4.3. Given an input question, the condition of a rule is satisfied if the whole input question is matched by the condition pattern. The conclusion of the fired rule produces the intermediate representation element of the input question. To create rules for matching the structures of questions, we use patterns over annotations returned by the preprocessing and syntactic analysis modules."}, {"heading": "4.3. Knowledge acquisition process", "text": "Our approach is language-independent, because the main focus is on the process of creating the rule-based system. The language-specific part is in the rules itself. So, in this section, we illustrate the process of building a SCRDR knowledge base to analyze English ques-\ntions. Figure 7 shows the graphic user interface to construct SCRDR knowledge bases. We reused the JAPE grammars which were developed to identify noun phrases, question phrases and relation phrases in AquaLog [26]. Based on Token annotations which are generated as output of the English tokenizer, sentence splitter and part-of-speech tagger in the GATE framework [11], the JAPE grammars produce NounPhrase4, QuestionPhrase and Relation annotations, and other annotation kinds such as Noun, Verb or Preps annotations for covering nouns, verbs or prepositions, respectively. We also reused question category definitions from AquaLog. For illustrations in Section 4.3.1 and Section 4.3.2, we employed a training set of 170 English questions5, which AquaLog [26] analyzed successfully, to construct the SCRDR knowledge base in Figure 6. These questions concern the Knowledge Media Institute and its research area on the semantic web."}, {"heading": "4.3.1. Reusing detected question structures", "text": "In contrast to the example in Section 3.3.3 with respect to Figure 4, we start with demonstrations of reusing detected question structure patterns.\nFor the question \u201cWho are the researchers in semantic web research area ?\u201d, we can represent this question using NounPhrase, QuestionPhrase and Relation annotations as shown in Figure 8 as follows: [QuestionPhrase:Who] [Relation: are the researchers in] [NounPhrase: semantic web research area] Supposed we start with a knowledge base containing only the default rule R0. Given the question, R0 is the fired rule that gives an incorrect conclusion of an empty intermediate representation element. This can be corrected by adding the following rule R1 as an exception rule of R0. In the knowledge base, node (1) containing R1 is added as the except-child node of the default node, as shown in Figure 6.\n4Here annotations are generated without any concept or entity type information.\n5http://technologies.kmi.open.ac.uk/aqualog/examples.html\nRule: R1 ( ({QuestionPhrase}):qp ({Relation}):rel ({NounPhrase}):np ):left 99K :left.RDR1_ = {category1 = \u201cUnknTerm\u201d} , :qp.RDR1_QP = {} , :rel.RDR1_Rel = {} , :np.RDR1_NP = {}\nConclusion: UnknTerm question structure and one query tuple (RDR1_.category1, RDR1_QP.QuestionPhrase.category, ?, RDR1_Rel, RDR1_NP, ?)\nIf the condition of R1 matches the whole input question, a new RDR1_ annotation will be created to entirely cover the input question. In addition, new annotations RDR1_QP, RDR1_Rel and RDR1_NP will be created to cover the same question phrase, relation phrase and noun phrase as the QuestionPhrase, Relation and NounPhrase annotations, respectively. When node (1) fired, the input question has one query tuple where the sub-structure attribute takes the value of the category1 feature of the RDR1_ annotation; the question category attribute takes the value of the category feature of the QuestionPhrase annotation which is in the same span as the RDR1_QP annotation. In addition, the Relation and Term2 attributes take values of the strings covered by the RDR1_Rel and RDR1_NP annotations, respectively, while Term1 and Term3 are missing. The example of firing the question at node (1) is displayed in Figure 7. Assume that, in addition to R0 and R1, the current knowledge base contains rule R2 as an exception rule of R1, for which node (2) containing R2 is the exceptchild node of node (1), as shown in Figure 6. For the question \u201cWhich universities are Knowledge Media Institute collaborating with ?\u201d, the following annotation-based representation is constructed:\n[RDR1_: [RDR1_QP: Which universities] [RDR1_Rel: are] [RDR1_NP: Knowledge Media Institute]] [Relation: collaborating with]\nWe have the evaluation path of (0)-(1)-(2) with the last fired node (1). However, R1 produces an incorrect conclusion of the UnknTerm question structure and one query tuple (UnknTerm, QU-whichClass, ?, ?, Knowledge Media Institute, ?). It is because the RDR1_ annotation only covers a part of the question and \u201care\u201d is not considered as a relation. The following rule R3 is added as an exception rule of R1:\nRule: R3 ( {RDR1_} ({Relation}):rel ):left 99K :left.RDR3_ = {category1 = \u201cNormal\u201d} , :rel.RDR3_Rel = {}\nConclusion: Normal question structure and one query tuple (RDR3_.category1, RDR1_QP.QuestionPhrase.category, RDR1_QP, RDR3_Rel, RDR1_NP, ?)\nIn the knowledge base, node (3) containing R3 is appended as the false-child node of node (2) which is the last node in the evaluation path. Regarding the input question \u201cWhich universities are Knowledge Media Institute collaborating with ?\u201d, we have a new evaluation path of (0)-(1)-(2)-(3) with the last fired node (3). So R3 produces a correct intermediate representation element of the question, consisting of the Normal question structure and one query tuple (Normal, QU-whichClass, universities, collaborating, Knowledge Media Institute, ?). Subsequently, another question makes an addition of rule R4 which is also an exception rule of R1. In the knowledge base, node (4) containing R4 is appended as the false-child node of node (3). For the question \u201cWho are the partners involved in AKT project ?\u201d, we have an annotation-based representation as follows:\n[RDR3_: [RDR1_QP:Who] [RDR1_Rel: are] [RDR1_NP: the partners] [RDR3_Rel: involved in]] [NounPhrase: AKT project]\nWe have the evaluation path (0)-(1)-(2)-(3) and node (3) is the last fired node. But R3 returns a wrong conclusion as the RDR3_ annotation covers a part of the question. The following rule R5 is added as an exception rule of R3 to correct the returned conclusion:\nRule: R5 ( {RDR3_} ({NounPhrase}):np ):left 99K :left.RDR5_ = {category1 = \u201cNormal\u201d} , :np.RDR5_NP = {}\nConclusion: Normal question structure and one query tuple (RDR5_.category1, RDR1_QP.QuestionPhrase.category, RDR1_NP, RDR3_Rel, RDR5_NP, ?)\nAs node (3) is the last node in the evaluation path, node (5) containing R5 is attached as the except-child node of node (3). Using R5, we get a correct conclu-\nsion consisting of the Normal question structure and one query tuple (Normal, QU-who-what, partners, involved, AKT project, ?)."}, {"heading": "4.3.2. Solving question structure ambiguities", "text": "The process of adding the rules above illustrates the ability of quickly handling new question structure patterns of our knowledge acquisition approach against the ad-hoc approaches [26,35]. The following examples demonstrate the ability of our approach to solve question structure ambiguities. For the question \u201cWhich researchers wrote publications related to semantic portals ?\u201d, the following representation is produced:\n[RDR5_: [RDR1_QP: Which researchers] [RDR1_Rel: wrote] [RDR1_NP: publications] [RDR3_Rel: related to] [RDR5_NP: semantic portals]]\nThis question is fired at node (5) which is the last node in the evaluation path (0)-(1)-(2)-(3)-(5). But R5 gives a wrong conclusion of theNormal question structure and one query tuple (Normal, QU-whichClass, publications, related to, semantic portals, ?). We add the following rule R40 as an exception rule of R5 to correct the conclusion returned by R5:\nRule: R40 ( {RDR5_} ):left\n99K :left.RDR40_ = {category1 = \u201cNormal\u201d, category2 = \u201cNormal\u201d}\nCondition: RDR1_QP.hasAnno == QuestionPhrase.category ==\nQU-whichClass\nConclusion: Clause question structure6 and two query tuples (RDR40_.category1, RDR1_QP.QuestionPhrase.category, RDR1_QP, RDR1_Rel, ?, ?) and (RDR40_.category2, RDR1_QP.QuestionPhrase.category, RDR1_NP, RDR3_Rel, RDR5_NP, ?)\nThe extra annotation constraint of hasAnno requires that the text covered by an annotation must contain another specified annotation. For example, the additional condition in R40 only matches the RDR1_QP annotation that has a QuestionPhrase annotation covering its\n6A Clause structure question has two query tuples where the answer returned for the second query tuple indicates the missing Term2 attribute in the first query tuple. See more details of our question structure definitions in appendix A.\nsubstring7. Additionally, this QuestionPhrase annotation must has \u201cQU-whichClass\u201d as the value of its category feature. In the knowledge base, node (40) containing R40 is added as the except-child node of node (5). Given the question, the last fired node now is node (40); and the conclusion of R40 produces a correct intermediate representation consisting of the Clause question structure and two query tuples (Normal, QU-whichClass, researchers, wrote, ?, ?) and (Normal, QU-whichClass, publications, related to, semantic portals, ?). For the question \u201cWhich projects sponsored by eprsc are related to semantic web ?\u201d, we have part-of-speech and annotation-based representations as follows: Which/WDT projects/NNS sponsored/VBN by/IN eprsc/NN are/VBP related/VBN to/TO semantic/JJ web/NN [RDR40_: [RDR1_QP: [QuestionPhrase category = QU-whichClass: Which projects]] [RDR1_Rel: sponsored by] [RDR1_NP: eprsc] [RDR3_Rel: are related to] [RDR5_NP: semantic web]] The current knowledge base generates an evaluation path (0)-(1)-(2)-(3)-(5)-(40)-(42)-(43) with the last fired node (40). However, R40 returns a wrong conclusion with the Clause question structure and two query tuples (Normal, QU-whichClass, projects, sponsored, ?, ?) and (Normal, QU-whichClass, eprsc, related to, semantic web, ?) since Term1 cannot be assigned to the instance \u201ceprsc\u201d. The following rule R45 which is a new exception rule of R40 is added to correct the conclusion given by R40:\nRule: R45 ( {RDR40_} ):left 99K :left.RDR45_ = {category1 = \u201cNormal\u201d, category2 = \u201cNormal\u201d}\nCondition: RDR1_Rel.hasAnno == Token.category == VBN\nConclusion: And question structure and two query tuples (RDR45_.category1, RDR1_QP.QuestionPhrase.category, RDR1_QP, RDR1_Rel, RDR1_NP, ?) and (RDR45_.category2, RDR1_QP.QuestionPhrase.category, RDR1_QP, RDR3_Rel, RDR5_NP, ?)\nR45 enables to return a correct intermediate representation element for the question with the And ques-\n7A whole string is also considered as its substring.\ntion structure and two query tuples (Normal, QUwhichClass, projects, sponsored, eprsc, ?) and (Normal, QU-whichClass, projects, related to, semantic web, ?). In the knowledge base, the associated node (45) is attached as the false-child node of node (43)."}, {"heading": "4.3.3. Porting to other domains", "text": "As illustrated in Section 4.3.1 and Section 4.3.2, using the set of 170 questions from AquaLog [26], we constructed a knowledge base of 59 rules for question analysis. Similarly, in this section, we illustrate the process of adding more exception rules into the knowledge base to handle DBpedia and biomedical test questions.\nFor the DBpedia test question \u201cWhich presidents of the United States had more than three children ?\u201d, the following representations are constructed:\nWhich/WDT presidents/NNS of/IN the/DT United/NNP States/NNPS had/VBD more/JJR than/IN three/CD children/NNS\n[RDR27_: [RDR10_: [RDR10_QP: Which presidents] [Preps: of] [RDR10_NP: the United States]] [RDR27_Rel: had more than] [RDR27_NP: three children]]\nThe last fired node for this DBpedia question is node (27). However, the conclusion of rule R27 at node (27) produced an incorrect intermediate representation element for the question. So a new exception rule of R27 is added to the knowledge base to correct the conclusion returned by R27 as follows:\nRule: R67 ( {RDR10_} {Verb} ({Token.category == JJR} {Token.string == than} {Token.category == CD}):cp ({Noun}):np ):left 99K :left.RDR67_ = {category1 = \u201cCompare\u201d, category2 = \u201cUnknRel\u201d} , :cp.RDR67_Compare = {} , :np.RDR67_NP = {}\nConclusion: Clause question structure and two query tuples (RDR67_.category1, RDR10_QP.QuestionPhrase.category, ? , RDR67_NP, ?, RDR67_Compare) and (RDR67_.category2, RDR10_QP.QuestionPhrase.category, RDR10_QP, ?, RDR10_NP, ?)\nGiven the question, R67 produces a correct intermediate representation element of the Clause question structure and two query tuples (Compare, QU-\nwhichClass, ?, children, ?, more than three) and (UnknRel, QU-whichClass, presidents, ?, United States, ?).\nFor the biomedical test question \u201cList drugs that lead to strokes and arthrosis\u201d, we have the following representations:\nList/NN drugs/NNS that/WDT lead/VBP to/TO strokes/NNS and/CC arthrosis/NNS\n[QuestionPhrase: List drugs] [RDR1_: [RDR1_QP: that] [RDR1_Rel: lead to] [RDR1_NP: strokes and arthrosis]]\nThe last fired node for this biomedical question is node (1). However, R1 returned an incorrect intermediate representation element. So a new exception rule of R1 is added to the knowledge base as follows:\nRule: R80 ( ({QuestionPhrase}):qp {RDR1_QP} {RDR1_Rel} ({Noun}):np1 {Token.category == CC} ({Noun}):np2 ):left 99K :left.RDR80_ = {category1 = \u201cNormal\u201d, category2 = \u201cNormal\u201d} , :qp.RDR80_QP = {} , :np1.RDR80_NP1 = {} , :np2.RDR80_NP2 = {}\nCondition: RDR80_QP.hasAnno == Noun\nConclusion: And question structure and two query tuples (RDR80_.category1, RDR80_QP.QuestionPhrase.category, RDR80_QP, RDR1_Rel, RDR80_NP1, ?) and (RDR80_.category2, RDR80_QP.QuestionPhrase.category, RDR80_QP, RDR1_Rel, RDR80_NP2, ?)\nGiven the question, R80 returns a correct intermediate representation element of the And question structure and two query tuples (Normal, QU-listClass, drugs, lead to, strokes, ?) and (Normal, QU-listClass, drugs, lead to, arthrosis, ?)."}, {"heading": "5. Experiments", "text": "In KbQAS, the question analysis component employs our language-independent knowledge acquisition approach, while the answer retrieval component produces answers from a domain-specific Vietnamese ontology. So we separately evaluate the question analy-\nsis and answer retrieval components in Section 5.1 and Section 5.2, respectively."}, {"heading": "5.1. Experiments on analyzing questions", "text": "This section indicates the abilities of our question analysis approach for quickly building a new knowledge base and easily adapting to a new domain and a new language. We evaluate both our approaches of adhoc manner (see Section 3.3.3) and knowledge acquisition (see Section 4) on Vietnamese question analysis, and then present the experiment of building a knowledge base for processing English questions."}, {"heading": "5.1.1. Question analysis for Vietnamese", "text": "We used a training set of 400 questions of various structures generated by four volunteer students. We then evaluated our question analysis approach on an unseen list of 88 questions related to the VNU University of Engineering and Technology, Vietnam. In this experiment, we also compare both our ad-hoc and knowledge acquisition approaches for question analysis, using the same training set of 400 questions and test set of 88 questions.\nWith our first approach it took about 75 hours to create rules in an ad-hoc manner, as shown in Table 2. In contrast, with our second approach it took 13 hours to build a Vietnamese knowledge base of rules for question analysis. However, most of the time was spent looking at questions to determine the question structures and the phrases which would be extracted to create intermediate representation elements. So the actual time to create rules in the knowledge base was about 5 hours in total.\nThe knowledge base consists of the default rule and 91 exception rules. Table 3 details the number of exception rules in each layer where every rule in layer n is an exception rule of a rule in layer n \u2212 1. The only rule which is not an exception rule of any rule is the default rule at layer 0. This indicates that the exception structure is indeed present and even extends to 4 levels. Table 2 also shows the number of successfully ana-\nlyzed questions for each approach. By using the knowledge base to resolve ambiguous cases, our knowledge acquisition approach performs better than our adhoc approach. Furthermore, Table 4 provides the error sources for our knowledge acquisition approach, in which most errors come from unexpected question structure patterns. This can be rectified by adding more exception rules to the current knowledge base, especially when having a large training set that contains a variety of question structure patterns.\nFor another example, our knowledge acquisition approach did not return a correct intermediate representation element for the question \u201cV\u0169 Ti\u1ebfn Th\u00e0nh c\u00f3 qu\u00ea v\u00e0 c\u00f3 m\u00e3 sinh vi\u00ean l\u00e0 g\u00ec ?\u201d (\u201cWhat is the hometown and student code of Vu Tien Thanh ?\u201d) because the existing linguistic processing modules for Vietnamese [43], including word segmentation and part-of-speech tagging, were not trained on the question domain. So these two modules assign the word \u201cqu\u00eahometown\u201d as an adjective instead of a noun. Thus, \u201cqu\u00eahometown\u201d is not covered by a NounPhrase annotation, leading to an unrecognized structure pattern. Regarding a question structure-based evaluation, Ta-\nble 5 presents the number of rules in the Vietnamese knowledge base and number of test questions, corresponding to each question structure type. For example, the cell at the second row and the fourth column of Table 5 means that, in 7 test questions tending to have the UnknRel question structure, there are 4 test questions correctly analyzed."}, {"heading": "5.1.2. Question analysis for English", "text": "For the experiment in English, we firstly used a set of 170 English questions8, which AquaLog [26] analyzed successfully. These questions are about the Knowledge Media Institute and its research area on the semantic web. Using this question set, we constructed a knowledge base of 59 rules for question analysis. It took 7 hours to build the knowledge base, including 3 hours of actual time to create all rules. We then evaluated the knowledge base using a set of 50 DBpedia test questions from the QALD-1 workshop and another set of 25 biomedical test questions from the QALD-4 workshop.9\nfrom unknown question structure patterns. Furthermore, just as in Vietnamese, the existing linguistic processing modules in the GATE framework [11], including the English tokenizer and part-of-speech tagger, are also error sources, leading to unrecognized structure patterns. For example, such questions as \u201cWhich U.S. states possess gold minerals ?\u201d and \u201cWhich drugs have a water solubility of 2.78e-01mg/mL ?\u201d are tokenized into \u201cWhich U . S . states possess gold minerals ?\u201d and \u201cWhich drugs have a water solubility of 2 . 78 e- 01 mg / mL ?\u201d, respectively. In addition, such other questions as \u201cWhich river does the Brooklyn Bridge cross ?\u201d, \u201cWhich states border Utah ?\u201d or \u201cWhich experimental drugs interact with food ?\u201d are tagged with noun labels for the words \u201ccross\u201d, \u201cborder\u201d and \u201cinteract\u201d instead of verb labels.\nTo correct the question analysis errors on the two sets of test questions, we spent 5 further hours to add 31 exception rules to the knowledge base. Finally, in total 12 hours, we constructed a knowledge base of 90 rules for English question analysis, including the default rule and 89 exception rules. The new evaluation results of question analysis on the DBpedia and biomedical domains are presented in Table 7. Table 8 shows the number of exception rules in each exception layer of the knowledge base while the number of rules corresponding to each question structure type is presented in Table 5.\nAs the intermediate representation in KbQAS is different from AquaLog, it is difficult to directly compare our knowledge acquisition approach with the ad-hoc\nquestion analysis approach in AquaLog on the English domain. However, this experiment on English questions shows the abilities to quickly build a new knowledge base and easily adapt to a new domain and a new language. As illustrated in Section 4.3, this experiment also presented a process of building a knowledge base for question analysis without any concept or entity type information. However, we found that the concept or entity type information in noun phrases is useful and can help to reduce ambiguities in question structure patterns. When adapting our knowledge acquisition approach for question analysis to anther target domain (or language), we can simply use the heuristics presented in Section 3.3.2 and a dictionary to determine whether a noun phrase is a concept or entity type. The dictionary can be (automatically) constructed by extracting concepts from the target domain and their synonyms from available semantic lexicons such as WordNet [17]."}, {"heading": "5.2. Experiment on answering Vietnamese questions", "text": "To evaluate the answer retrieval component of KbQAS, we used the ontology modeling the organizational structure of the VNU University of Engineering and Technology, as mentioned in Section 3.2, as target domain. This ontology was manually constructed by using the Prot\u00e9g\u00e9 platform [19]. From the list of 88 questions, as mentioned in Section 5.1.1, we employed 74 questions which were successfully analyzed by the question analysis component.\nThe performance result is presented in Table 9. The answer retrieval component produces correct answers for 61 out of 74 questions, obtaining a promising accuracy of 82.4%. The number of correctly answered questions corresponding to each question structure type can be found in the third column of Table 5. Out of those, 30 questions can be answered automatically without interaction with users. In addition, 31 questions are correctly answered with the help from the users to handle ambiguity cases, as illustrated in the first example in Section 3.4.\nTable 10 Questions with unsuccessful answers.\nType # questions\nOntology mapping errors 6/74 Answer extraction errors 7/74\nTable 10 gives the limitations that will be handled in future KbQAS versions. The errors raised by the ontology mapping module are due to the target ontology construction lacking a full domain-specific conceptual coverage and some relationships between concept pairs. So specific terms or relations in query tuples cannot be mapped or are incorrectly mapped to the corresponding elements in the target ontology to produce the ontology tuples. Furthermore, the answer extraction module fails to extract the answers for 7 questions because: (i) Dealing with questions having the Compare question structure involves specific services. For example, handling the question \u201csinh vi\u00ean n\u00e0o c\u00f3 \u0111i\u1ec3m trung b\u00ecnh cao nh\u1ea5t khoa c\u00f4ng ngh\u1ec7 th\u00f4ng tin ?\u201d (\u201cWhich student has the highest grade point average in the faculty of Information Technology ?\u201d) requires a comparison mechanism to rank students according to their GPA. (ii) In terms of four Clause structure questions and one Affirm_MoreTuples structure question for which KbQAS failed to return answers (see Table 5), combining their sub-questions triggers complex inference tasks and bugs which are difficult to handle in the current KbQAS version."}, {"heading": "6. Conclusion and future work", "text": "In this paper, we described the first ontology-based question answering system for Vietnamese, namely KbQAS. KbQAS contains two components: natural language question analysis and answer retrieval. The two components are connected by an intermediate representation element capturing the semantic structure of any input question, facilitating the matching process to a target ontology to produce an answer. Experimental results of KbQAS on a wide range of questions are promising. Specifically, the answer retrieval module achieves an accuracy of 82.4%. In addition, we proposed a question analysis approach for systematically building a knowledge base of rules to convert the input question into an intermediate representation element. Our approach allows for systematic control of interactions between rules and keeping consistency among them. We believe that our approach is important especially for under-resourced lan-\nguages where annotated data is not available. Our approach could be combined nicely with the process of annotating corpora where, on top of assigning a label or a representation to a question, the experts just have to add one more rule to justify their decision. Incrementally, an annotated corpus and a rule-based system can be obtained simultaneously. Furthermore, our approach can be applied to open-domain question answering where the technique requires an analysis to transform an input question into an explicit representation of some sort. Obtaining a question analysis accuracy of 84.1% on Vietnamese questions and taking 12 hours to build a knowledge base of 90 rules for analyzing English questions, the question analysis experiments show that our approach enables individuals to easily build a new knowledge base or adapt an existing knowledge base to a new domain or a new language. In the future, we will extend KbQAS to be an opendomain question answering system which can answer various questions over Linked Open Data such as DBpedia or YAGO. In addition, it would be interesting to investigate the process of building a knowledge base for question analysis, which directly converts the input questions into queries (e.g. SPARQL queries) on Linked Open Data."}, {"heading": "Acknowledgments", "text": "This work is partially supported by the Research Grant No. QG.14.04 from Vietnam National University, Hanoi (VNU). Most of this work was done while the first two authors was at the VNU University of Engineering and Technology. The first author is supported by an International Postgraduate Research Scholarship and a NICTA NRPA Top-Up Scholarship.\nAppendix"}, {"heading": "A. Definitions of question structure types", "text": "We define question structures types: Normal, UnknTerm, UnknRel, Definition, Affirm, ThreeTerm, Affirm_3Term, Affirm_MoreTuples, Compare, And, Or, Combine, Clause as follows: \u2022 A Normal structure question has only one query tuple in which Term3 is missing. \u2022 An UnknTerm structure question has only one query tuple in which Term1 and Term3 are missing.\n\u2022 An UnknRel structure question has only one query tuple in which Relation and Term3 are missing. For example, the question \u201cList all the publications in knowledge media institute\u201d has one query tuple (UnknRel, QU-listClass, publications, ?, knowledge media institute, ?). \u2022A Definition structure question has only one query tuple which lacks Term1, Relation and Term3. For example, the question \u201cWhat are research areas ?\u201d has one query tuple (Definition, QU-who-what, ?, ?, research areas, ?). \u2022 An Affirm structure question is a question which belongs to one of three types Normal, UnknRel and UnknTerm, and has the YesNo question category. For example, the question \u201cIs Tran Binh Giang a PhD student ?\u201d has the Affirm question structure and one query tuple (UnknRel, YesNo, PhD student, ?, Tran Binh Giang, ?). \u2022 A ThreeTerm structure question has only one query tuple where Term1 or Relation could be missing. An example for this structure type is illustrated in Figure 2. \u2022 An Affirm_3Term structure question is the question which belongs to ThreeTerm and has the YesNo question category. For example, the question \u201cs\u1ed1 l\u01b0\u1ee3ng sinh vi\u00ean h\u1ecdc l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednh l\u00e0 45 ph\u1ea3i kh\u00f4ng ?\u201d (\u201c45 is the number of students enrolled in the K50 computer science course, is it not ?\u201d) has the Affirm_3Term question structure and one query tuple (ThreeTerm, ManyClass, sinh vi\u00eanstudent, h\u1ecdcenrolled, l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednhK50 computer science course, 45).\n\u2022 An Affirm_MoreTuples structure question has more than one query tuple and belongs to the YesNo question category. For example, the question \u201ct\u1ed3n t\u1ea1i sinh vi\u00ean c\u00f3 qu\u00ea \u1edf H\u00e0 T\u00e2y v\u00e0 h\u1ecdc khoa to\u00e1n ph\u1ea3i kh\u00f4ng ?\u201d (\u201cIs there some student enrolled in the faculty of Mathematics, whose hometown is Hatay ?\u201d) has the Affirm_MoreTuples question structure and two query tuples (Normal, YesNo, sinh vi\u00eanstudent, c\u00f3 qu\u00eahave hometown, H\u00e0 T\u00e2yHatay, ?) and (Normal, YesNo, sinh vi\u00eanstudent, h\u1ecdcenrolled, khoa To\u00e1nfaculty of Mathematics, ?). \u2022 A Compare structure question is a question which belongs to one of three types Normal, UnknRel and UnknTerm, and it contains a comparison phrase which is detected by the preprocessing module. In this case, Term3 is used to hold the comparison information. For example, the question \u201csinh vi\u00ean n\u00e0o c\u00f3 \u0111i\u1ec3m trung b\u00ecnh cao nh\u1ea5t khoa c\u00f4ng ngh\u1ec7 th\u00f4ng tin ?\u201d (\u201cWhich student has the highest grade point average in the faculty of Information Technology ?\u201d) has the Com-\npare question structure and one query tuple (Normal, Entity, sinh vi\u00eanstudent, \u0111i\u1ec3m trung b\u00ecnhgrade point average, khoa c\u00f4ng ngh\u1ec7 th\u00f4ng tinfaculty of Information Technology, cao nh\u1ea5thighest).\n\u2022 An And or Or structure question contains the word \u201cm\u00e0and\u201d (\u201cv\u00e0and\u201d) or \u201cho\u1eb7cor\u201d, respectively, and it has more than one query tuple (i.e. two or more subquestions). The And type returns the final answer as an intersection (i.e. overlap) of the answers of the subquestions, while the Or type returns the final answer as an union of the answers for the sub-questions. For example, the question \u201cWhich projects are about ontologies and the semantic web ?\u201d has the And question structure and two query tuples (UnknRel, QUwhichClass, projects, ?, ontologies, ?) and (UnknRel, QU-whichClass, projects, ?, semantic web, ?). The question \u201cWhich publications are in knowledge media institute related to compendium ?\u201d has the And question structure and two query tuples (UnknRel, QUwhichClass, publications, ?, knowledge media institute, ?) and (Normal, QU-whichClass, publications, related to, compendium, ?). The question \u201cWho is interested in ontologies or in the semantic web ?\u201d has the Or question structure and two query tuples (UnknTerm, QU-who-what, ?, interested, ontologies, ?) and (UnknTerm, QU-who-what, ?, interested, semantic web, ?). However, such question as \u201cPh\u1ea1m \u0110\u1ee9c \u0110\u0103ng h\u1ecdc tr\u01b0\u1eddng \u0111\u1ea1i h\u1ecdc n\u00e0o v\u00e0 \u0111\u01b0\u1ee3c h\u01b0\u1edbng d\u1eabn b\u1edfi ai ?\u201d (\u201cWhich university does Pham Duc Dang enroll in and who tutors him ?\u201d) contains \u201cv\u00e0and\u201d, but it will have the Or question structure and two query tuples (Normal, Entity, tr\u01b0\u1eddng \u0111\u1ea1i h\u1ecdcuniversity, h\u1ecdcenroll, Ph\u1ea1m \u0110\u1ee9c \u0110\u0103ngPham Duc Dang, ?) and (UnknTerm, Who, ?, h\u01b0\u1edbng d\u1eabntutor, Ph\u1ea1m \u0110\u1ee9c \u0110\u0103ngPham Duc Dang, ?). \u2022 A Combine structure question is constructed from two or more independent sub-questions. Unlike the Or structure type, the query tuples in the Combine type do not share the same term or Relation. For example, the question \u201cAi c\u00f3 qu\u00ea qu\u00e1n \u1edf H\u00e0 T\u00e2y v\u00e0 ai h\u1ecdc khoa c\u00f4ng ngh\u1ec7 th\u00f4ng tin ?\u201d (\u201cWho has hometown of Hatay, and who enrolls in the faculty of Information Technology ?\u201d) has the Combine question structure and two query tuples (UnknTerm, Who, ?, c\u00f3 qu\u00ea qu\u00e1nhas hometown, H\u00e0 T\u00e2yHatay, ?) and (UnknTerm, Who, ?, h\u1ecdcenroll, khoa c\u00f4ng ngh\u1ec7 th\u00f4ng tinfaculty of Information Technology, ?).\n\u2022 A Clause structure question has two query tuples, where the answer returned for the second query tuple indicates the missing Term2 attribute in the first query tuple. For example, the question \u201cs\u1ed1 l\u01b0\u1ee3ng sinh vi\u00ean h\u1ecdc l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednh l\u1edbn h\u01a1n 45 ph\u1ea3i kh\u00f4ng\n?\u201d10 (\u201cThe number of students enrolled in K50 computer science course is higher than 45, is it not ?\u201d) has the Clause question structure and two query tuples (Compare, YesNo, 45, ?, ?, l\u1edbn h\u01a1nhigher than) and (Normal, ManyClass, sinh vi\u00eanstudent, h\u1ecdcenrolled, l\u1edbp K50 khoa h\u1ecdc m\u00e1y t\u00ednhK50 computer science course, ?). Another example of this Clause structure is presented in Section 4.3.2.\nIn general, Term1 represents a concept, excluding cases of Affirm, Affirm_3Term and Affirm_MoreTuples. In addition, Term2 and Term3 represent entities (i.e. objects or instances), excluding the cases of Definition and Compare."}, {"heading": "B. Definitions of Vietnamese question categories", "text": "In KbQAS, a question is classified as one of the following classes: HowWhy, YesNo, What, When, Where, Who, Many, ManyClass, List, and Entity. To identify question categories, we specify a number of JAPE grammars using the NounPhrase annotations and the question-word information given by the preprocessing module. \u2022 A HowWhy-category question refers to a cause or a method, containing a TokenVn annotation covering such strings as \u201ct\u1ea1i saowhy\u201d or \u201cv\u00ec saowhy\u201d or \u201cth\u1ebf n\u00e0ohow\u201d or \u201cl\u00e0 nh\u01b0 th\u1ebf n\u00e0ohow\u201d. This is similar to Whyquestions or How is/are questions in English.\n\u2022 A YesNo-category question requires a true or false answer, containing a TokenVn annotation covering such strings as \u201cc\u00f3 \u0111\u00fang l\u00e0is that\u201d or \u201c\u0111\u00fang kh\u00f4ngare those\u201d or \u201cph\u1ea3i kh\u00f4ngare there\u201d or \u201cc\u00f3 ph\u1ea3i l\u00e0is this\u201d. \u2022A What-category question contains a TokenVn annotation covering such strings as \u201cc\u00e1i g\u00ecwhat\u201d or \u201cl\u00e0 g\u00ecwhat\u201d or \u201cl\u00e0 nh\u1eefng c\u00e1i g\u00ecwhat\u201d. This question type is similar to What is/are questions in English. \u2022 A When-category question contains a TokenVn annotation covering such strings as \u201ckhi n\u00e0owhen\u201d or \u201cv\u00e0o th\u1eddi gian n\u00e0owhich time\u201d or \u201cl\u00fac n\u00e0owhen\u201d or \u201cng\u00e0y n\u00e0owhich date\u201d.\n\u2022 A Where-category question contains a TokenVn annotation covering such strings as \u201c\u1edf n\u01a1i n\u00e0owhere\u201d or \u201cl\u00e0 \u1edf n\u01a1i \u0111\u00e2uwhere\u201d or \u201c\u1edf ch\u1ed7 n\u00e0owhere\u201d.\n\u2022 A Who-category question contains a TokenVn annotation covering such strings as \u201cl\u00e0 nh\u1eefng aiwho\u201d or \u201cl\u00e0 ng\u01b0\u1eddi n\u00e0owho\u201d or \u201cnh\u1eefng aiwho\u201d.\n10This is the case of our system failing to correctly analyze due to an unknown structure pattern.\n\u2022 A Many-category question contains a TokenVn annotation covering such strings as \u201cs\u1ed1 l\u01b0\u1ee3nghow many\u201d or \u201cl\u00e0 bao nhi\u00eauhow much/many\u201d or \u201cbao nhi\u00eauhow much/ many\u201d. This question type is similar to How much/many is/are questions in English.\n\u2022 A ManyClass-category question contains a TokenVn annotation covering such strings as \u201cs\u1ed1 l\u01b0\u1ee3nghow many\u201d or \u201cl\u00e0 bao nhi\u00eauhow much/many\u201d or \u201cbao nhi\u00eauhow much/many\u201d, followed by a NounPhrase annotation. This type is similar to How many NounPhrase-questions in English.\n\u2022 An Entity-category question contains a NounPhrase annotation followed by a TokenVn annotation covering such strings as \u201cn\u00e0owhich\u201d or \u201cg\u00ecwhat\u201d. This type is similar to which/what NounPhrase-questions in English.\n\u2022 A List-category question contains a TokenVn annotation covering such strings as \u201ccho bi\u1ebftgive\u201d or \u201cch\u1ec9 rashow\u201d or \u201ck\u1ec3 ratell\u201d, or \u201ct\u00ecmfind\u201d or \u201cli\u1ec7t k\u00ealist\u201d, followed by a NounPhrase annotation."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "Recent years have witnessed a new trend of building ontology-based question answering systems. These systems use<lb>semantic web information to produce more precise answers to users\u2019 queries. However, these systems are mostly designed for<lb>English. In this paper, we introduce an ontology-based question answering system named KbQAS which, to the best of our<lb>knowledge, is the first one made for Vietnamese. KbQAS employs our question analysis approach that systematically constructs<lb>a knowledge base of grammar rules to convert each input question into an intermediate representation element. KbQAS then<lb>takes the intermediate representation element with respect to a target ontology and applies concept-matching techniques to return<lb>an answer. On a wide range of Vietnamese questions, experimental results show that the performance of KbQAS is promising<lb>with accuracies of 84.1% and 82.4% for analyzing input questions and retrieving output answers, respectively. Furthermore, our<lb>question analysis approach can easily be applied to new domains and new languages, thus saving time and human effort.", "creator": "LaTeX with hyperref package"}}}