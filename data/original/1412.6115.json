{"id": "1412.6115", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Dec-2014", "title": "Compressing Deep Convolutional Networks using Vector Quantization", "abstract": "Deep convolutional neural networks (CNN) has become the most promising method for object recognition, repeatedly demonstrating record breaking results for image classification and object detection in recent years. However, a very deep CNN generally involves many layers with millions of parameters, making the storage of the network model to be extremely large. This prohibits the usage of deep CNNs on resource limited hardware, especially cell phones or other embedded devices. In this paper, we tackle this model storage issue by investigating information theoretical vector quantization methods for compressing the parameters of CNNs. In particular, we have found in terms of compressing the most storage demanding dense connected layers, vector quantization methods have a clear gain over existing matrix factorization methods. Simply applying k-means clustering to the weights or conducting product quantization can lead to a very good balance between model size and recognition accuracy. For the 1000-category classification task in the ImageNet challenge, we are able to achieve 16-24 times compression of the network with only 1% loss of classification accuracy using the state-of-the-art CNN.", "histories": [["v1", "Thu, 18 Dec 2014 21:09:01 GMT  (896kb,D)", "http://arxiv.org/abs/1412.6115v1", null]], "reviews": [], "SUBJECTS": "cs.CV cs.LG cs.NE", "authors": ["yunchao gong", "liu liu", "ming yang", "lubomir bourdev"], "accepted": false, "id": "1412.6115"}, "pdf": {"name": "1412.6115.pdf", "metadata": {"source": "CRF", "title": "COMPRESSING DEEP CONVOLUTIONAL NETWORKS USING VECTOR QUANTIZATION", "authors": ["Yunchao Gong", "Liu Liu", "Ming Yang", "Lubomir Bourdev"], "emails": ["ycgong@fb.com", "lliu@fb.com", "mingyang@fb.com", "lubomir@fb.com"], "sections": [{"heading": "1 INTRODUCTION", "text": "Deep convolutional neural networks (Krizhevsky et al., 2012; LeCun et al., 1990; Szegedy et al., 2014; Simonyan & Zisserman, 2014) has recently achieved significant progress and have become the gold standard for object recognition, image classification, and retrieval. Almost all of the recent successful recognition systems (Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013; Gong et al., 2014) are built on top of this architecture. Importing CNN onto embedded platforms (Gokhale et al., 2013; Culurciello et al., 2013), the recent trend toward mobile computing, has a wide range of application impacts. It is especially useful when the bandwidth is limited or photos are not allowed to be sent to servers. However, the size of the CNN models are typically very large (e.g. more than 200M bytes), which limits the applicability of such models on the embedded platform. For example, it will be almost impossible for users to download an iPhone application with more than 20M. Thus, in order to apply neural network methods to embedded platforms, one important research problem is how to compress parameters to reduce storage requirements.\nIn this article we mainly consider compressing CNNs for computer vision tasks. For example, a typical CNN (Jia, 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013) that works well for object recognition contains eight layers (five convolutional layers and three dense connected layers) and a huge number of parameters (e.g. 108) in order to produce state-of-the-art results. Because as is widely known, the parameters are heavily over-parameterized (Denil et al., 2013), it is very interesting to investigate whether we can compress these parameters by exploring their structure. Here, we are mainly interested in compressing the parameters to reduce storage instead of speeding up the testing time (Denton et al., 2014). For a typical network described in (Zeiler & Fergus, 2013), about 90% of the storage is taken up by the dense connected layers; more than 90% of the running time is taken by the convolutional layers. Therefore, we shall focus upon how to compress the dense connected layers to reduce storage of neural networks.\n\u2217Currently with Snapchat.\nar X\niv :1\n41 2.\n61 15\nv1 [\ncs .C\nV ]\n1 8\nD ec\n2 01\n4\nA few early works on compressing CNNs have been published; however, their focus is different from ours. The most closely related one, Denton et al. (2014), explored matrix factorization methods for speeding up CNN testing time. These researchers showed that by exploring the linear structure of CNN parameters (in particular, convolutional layers), CNN testing time can be sped up by as much as 200% while keeping the accuracy within 1% of the original model. Another similar work on speeding up CNN is (Jaderberg et al., 2014), in which the authors described several reconstruction methods for approximating the filers in convolutional layers. Their goal of both works is complimentary to ours, in that they focus on compressing convolutional layers for speeding up CNN. Our focus, however, is on compressing dense connected layers in order to reduce the size of the model.\nIn this work, instead of the traditional matrix factorization methods considered in (Denton et al., 2014; Jaderberg et al., 2014), we mainly consider a series of information theoretical vector quantization methods (Jegou et al., 2011; Chen et al., 2010) for compressing dense connected layers. For example, we consider binarizing the parameters, scalar quantization using kmeans, and structured quantization using product quantization or residual quantization. Surprisingly, we have found that simply applying kmeans-based scalar quantization achieves very impressive results, and that this approach is better than matrix factorization methods. Structured quantization methods can give additional gain by exploring redundancy in the parameters. To our knowledge, this is the first work to systematically study different vector quantization methods for compressing CNN parameters.\nThis paper makes the following contributions: 1) We are among the first to systematically explore vector quantization methods for compressing the dense connected layers of deep CNNs to reduce storage; 2) We have performed a comprehensive evaluation of different vector quantization methods, which has shown in particular that structured quantization such as product quantization works significantly better than other methods; 3) We have performed experiments on other tasks such as image retrieval, to verify the generalization ability of the compressed model."}, {"heading": "2 RELATED WORK", "text": "Deep convolutional neural network has achieved great successes in image classification (Krizhevsky et al., 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al., 2014), and image retrieval (Razavian et al., 2014; Gong et al., 2014). With the great progress in this area, the state-of-the-art image classifier can achieve 94% top five accuracy on the ILSVRC2014 dataset with 1000 object classes, and is already very close human performance. Such great success ignites interest in adopting CNNs to real world applications. For example, CNN has already been applied to object classification, scene classification, and indoor scene classification. It has also been applied to image retrieval, with impressive results.\nAs discussed in the above section, a state-of-the-art CNN usually involves hundreds of millions of parameters, which require huge storage for the model that is difficult to achieve. The bottleneck comes from model storage and testing speed. Several works have been published on speeding up CNN prediction speed. Vanhoucke et al. (2011), who explored the properties of CPU to speed up the execution of CNN, particularly focused on the aligning of memory and SIMD operations to boost matrix operations. Mathieu et al. (2013) showed that the convolutional operation can be efficiently carried out in the Fourier domain, which leads to a speed-up of 200%. Two very recent works by Denton et al. (2014) and Jaderberg et al. (2014), which explored the use of linear matrix factorization methods for speeding up convolutional layers, showed a 200% speed-up with little compromise of classification performance. Almost all of the above mentioned works focus on making the prediction speed of CNN faster; little work has been specifically devoted to making CNN models smaller.\nThe use of vector quantization methods to compress CNN parameters is mainly inspired by the work of Denil et al. (2013), who demonstrate the redundancies in neural network parameters. They show that the weights within one layer can be accurately predicted by a small ( 5%) subset of the parameters, which indicates that the neural network is over-parameterized. These results motivate us to apply vector quantization methods to explore the redundancy in parameter space. In particular, our paper can be viewed as a compression realization of the parameter prediction results reported in Denil et al. (2013). Somewhat surprisingly, we have found very similar results to those of Denil\net al. (2013), in that we are able to compress the parameters about 20 times with little decrease of performance. This result further confirms the interesting empirical findings in Denil et al. (2013)."}, {"heading": "3 COMPRESS DENSE CONNECTED LAYERS", "text": "In this section, we consider two classes of methods for compressing the parameters in dense connected layers. We first consider the matrix factorization methods, and then introduce the vector quantization methods."}, {"heading": "3.1 MATRIX FACTORIZATION METHODS", "text": "We first consider matrix factorization methods, which have been widely used to speed up CNN (Denton et al., 2014) as well as for compressing parameters in linear models (Denton et al., 2014). In particular, we consider using singular-value decomposition (SVD) to factorize the parameter matrix. Given the parameter W \u2208 Rm\u00d7n in one dense connected layer, we factorize it as\nW = USV T , (1)\nwhere U \u2208 Rm\u00d7m and V \u2208 Rn\u00d7n are two dense orthogonal matrices and S \u2208 Rm\u00d7n is a diagonal matrix. In order to approximate W using two much smaller matrices, we can pick the top k singular vectors in U and V with corresponding eigenvalue in S, to reconstruct W :\nW\u0302 = U\u0302 S\u0302V\u0302 T , (2)\nwhere U\u0302 \u2208 Rm\u00d7k and V\u0302 \u2208 Rn\u00d7k are two submatrices that correspond to the leading k singular vectors in U and V . The diagonal elements in S\u0302 \u2208 Rk\u00d7k correspond to the largest k singular values. The approximation of SVD is controlled by the decay along the eigenvalues in S. The SVD method is optimal in the sense of a Frobenius norm, which minimizes the MSE error between the approximated matrix W\u0302 and original W . The two low-rank matrices U\u0302 and V\u0302 , as well as the eigenvalues, must be stored. So the compression rate given m, n, and k is computed as mn/k(m+ n+ 1)."}, {"heading": "3.2 VECTOR QUANTIZATION METHODS", "text": ""}, {"heading": "3.2.1 BINARIZATION", "text": "We start with the simplest way to quantize the parameter matrices. Given the parameter W , we take the sign of the matrix:\nW\u0302ij = { 1 if Wij \u2265 0, \u22121 if Wij < 0. (3)\nThis method is mainly inspired by Dropconnect (Wan et al., 2013), which randomly sets part of the parameters (neurons) to 0 during training. Here, we are taking a more aggressive approach by turning each neuron on if it is positive and turning it off when it is negative. From a geometric point of view, assuming that dense connected layers are a set of hyperplanes, we are actually rounding each hyperplane to its nearest coordinate. This method will compress the data by 32 times, since each neuron is represented by one bit.\n3.2.2 SCALAR QUANTIZATION USING kMEANS\nAnother simple method is to perform scalar quantization to the parameters. For W \u2208 Rm\u00d7n, we can collect all its scalar values as w \u2208 R1\u00d7mn, and perform kmeans clustering to the values:\nmin mn\u2211 i k\u2211 j \u2016wi \u2212 cj\u201622, (4)\nwhere w and c are both scalars. After the clustering, each value in w is assigned a cluster index, and a codebook can be formed of c1\u00d7k the cluster centers. During the prediction, we can directly look up the values for each wij in c. Thus, the reconstructed matrix is:\nW\u0302ij = cz, where min z \u2016Wij \u2212 cz\u201622. (5)\nFor this approach, we only need to store the indexes and the codebook as the parameters. Given the k centers, we only need log2(k) bits to encode the centers. For example, if we use k = 256 centers, only need 8 bits are needed per cluster index. Thus, the compression rate is 32/ log2(k), assuming that we use floating numbers for the original W and assuming that the codebook itself is negligible. Despite the simplicity of this approach, our experiments showed that this approach gives surprisingly good performance for compressing parameters."}, {"heading": "3.2.3 PRODUCT QUANTIZATION", "text": "Next, we consider structured vector quantization methods for compressing the parameters. In particular, we consider the use of product quantization (PQ) (Jegou et al., 2011), which explores the redundancy of structures in vector space. The basic idea of PQ is to partition the vector space into many disjoint subspaces, and perform quantization in each subspace. Due to its assumption that the vectors in each subspace are heavily redundant and by performing quantization in each subspace, we are able to better explore the redundancy structure. Specifically, given the matrix W , we partition it colum-wise into several submatrices:\nW = [W 1,W 2, . . . ,W s], (6)\nwhere W i \u2208 Rm\u00d7(n/s) assuming n is divisible by s. We can perform a kmeans clustering to each submatrix W i:\nmin m\u2211 z k\u2211 j \u2016wiz \u2212 cij\u201622, (7)\nwhere wiz denotes the zth row of sub-matrix W i, and cij denotes the jth row of sub-codebook Ci \u2208 Rk\u00d7(n/s). For each sub-vector wiz , we need only to store its corresponding cluster index and the codebooks. Thus, the reconstructed matrix is:\nW\u0302 = [W\u0302 1, W\u0302 2, . . . , W\u0302 s], where (8)\nw\u0302ij = c i j , where min j \u2016wiz \u2212 cij\u201622. (9)\nNote that PQ can be applied to either the x-axis or the y-axis of the matrix. In our experiments, we evaluated both cases.\nFor this approach, we need to store the cluster indexes and codebooks for each subvector. In particular, in contrast to the scalar quantization case, the codebook here is not negligible. The compression rate for this method is (32mn)/(32kn+ log2(k)ms)."}, {"heading": "3.2.4 RESIDUAL QUANTIZATION", "text": "The third quantization method we consider is residual quantization (Chen et al., 2010), which is another form of structured quantization. The basic idea is to first quantize the vectors into k centers and then to recursively quantize the residuals. For example, given a set of vectors wi, i \u2208 1, . . . ,m at the first stage, we begin by quantizing them into k different vectors using kmeans clustering:\nmin m\u2211 z k\u2211 j \u2016wz \u2212 c1j\u201622, (10)\nEvery vector wz will be represented by its closest center c1j . Next, we compute the residual r 1 z between wz and c1j for all the data points and recursively quantize the residual vectors r 1 z into k different code words c2j . Finally, a vector can be reconstructed by adding its corresponding centers at each stage:\nw\u0302z = c 1 j + c 2 j + . . . , c t j , (11)\ngiven we have recursively performed t iterations.\nWe need to store all the codebooks for each iteration, which potentially needs large a amount of memory. The compression rate is m/(tk + log2(k)tn)."}, {"heading": "3.2.5 OTHER METHODS AND DISCUSSION", "text": "The abovementioned (KM, PQ, and RQ) are three different kinds of vector quantization methods for compressing matrices. KM only captures the redundancy for each neuron (single scalar); PQ explores some local redundancy structure; and RQ tries to explore the global redundancy structure between weight vectors. It will be interesting to investigate what kinds of redundancies are present in the behavior of the learned parameters.\nMany learning-based binarization or product quantization methods are available, such as Spectral Hashing (Weiss et al., 2008), Iterative Quantization (Gong et al., 2012), and Catesian kmeans (Norouzi & Fleet, 2013), among others. However, they are not suitable for this particular task because we need to store the learned parameter matrix (e.g., a rotation matrix), which is very large. For this reason, we do not consider the other methods in this paper. It is also interesting to explore the structure in W when performing PQ. In particular, because the W is learned on a set of outputs of different filters, grouping together output from specific filters or grouping together specific dimensions from different filters might be interesting. However, in our preliminary investigation, we did not find any improvement by exploring such structure when doing PQ. Therefore, we grouped these dimensions by default order."}, {"heading": "4 EXPERIMENTS", "text": ""}, {"heading": "4.1 EXPERIMENTAL SETTING", "text": "We evaluated these different methods on the ILSVRC2012 benchmark image classification dataset. This dataset contains more than 1 million training images from 1000 object categories. It also has a validation set of 20,000 images, in categories that contain 20 images each. We trained on the standard training set, performed the compression to the parameters, and tested on the validation set.\nThe convolutional neural network we used, from Zeiler & Fergus (2013), contains 5 convolutional layers and 3 dense connected layers. All of the input images were first resized to minimal dimensions of 257, after which we performed random cropping to 225\u00d7225 patches. Then the images were fed into 5 different convolutional layers with respective filter sizes of 7, 5, 3, 3, and 3. The first two convolutional layers were followed by a local response normalization layer and a max pooling layer. At this point we have obtained three fully connected layers of sizes 9216\u00d7 2048, 2048\u00d7 2048 and 2048\u00d7 1000. The nonlinear function we used here was RELU. The network was trained on 1 GPU for about 5 days after 70 epochs. The learning rate started at 0.02 and halved every 5-10 epochs; the weight decay was set to 0.0005; and momentum was set to 0.9.\nTo evaluate the different methods, we used the classification accuracy on the validation set as the evaluation protocol. We used both the accuracy@1 and accuracy@5 to evaluate different parameter compression methods. The goal was either to achieve higher compression rate with same accuracy or higher accuracy with same compression rate."}, {"heading": "4.2 ANALYSIS OF PRODUCT QUANTIZATION", "text": "We first performed an analysis on the PQ-based compression of the parameters, because PQ has several different parameters. We used a different number of clusters k = 4, 8, 16 (corresponds to 2, 3, 4 bits) for each segment. For each fixed k, we show results for different segment dimension (column) sizes s = 1, 2, 3, 4, which changed the compression rate from lower to higher. As mentioned in section 3.2.3, we were able to perform PQ for either the x-axis or the y-axis and therefore show results for both cases. We shall compare different PQ methods when we align the segment size, and also compare them with the aligned compression rate.\nThe results for accuracy@1 are reported in Figure 1 and Figure 2 for different axis alignments. From the results in Figure 1, we see that by using more centers k and smaller segment size s, we were able to obtain smaller classification error. For example, in Figure 1, the red curve always has much smaller classification error than other methods. This result is consistent with previous observations for PQ (i.e., that using more centers in each segment can usually obtain a lower rate of quantization error). However, when we took the size of the codebook into account and measured the accuracy for the same compression rate, as in Figure 2, we found using more centers is not always helpful\nbecause they will aggressively increase the codebook size. For example, when we used k = 16 centers, the classification error was clearly not lower than when we used fewer number of clusters (e.g. k = 8). This difference is because the codebook itself is using too much storage space and and makes the compression rate very low. When we compare the results of compressing the x-axis and y-axis, the results for the x-axis are slightly better. This improvement is probably because there are more dimensions for the x-axis, which makes the codebook size larger and thereby reduces the loss of information. In the next set of experiments, we fixed the number of centers to 8 (3 bits per segment) because this approach achieves a good balance between compression rate and accuracy."}, {"heading": "4.3 OVERALL COMPARISON", "text": "Section 3 below contains a comparison of all of the quantization methods we introduce herein. Similarly to the above sections, we present the classification errors with respect to the compression rate. For binary quantization, which has no parameter to tune, the compression rate was 32. For PQ, we used 8 centers per segment and varied the dimension (from 1 to 4) of each segment to achieve different compression rates. For kmeans (KM), we varied the number of clusters from 1 to 32 to achieve a compression rate between 32 and 1. For SVD, we vary the output dimensionality to achieve different compression rates. The performance of RQ was unsatisfactory; here, we report results only for 256 centers with t = 2, 3 iterations. We also experimented with lower numbers of centers for RQ, but found the performance to be even worse.\nBoth accuracy@1 and accuracy@5 are shown in Figure 3, where we see that the trend is consistent for both figures. In particular, SVD achieves impressive results for compressing and speeding up convolutional layers (Denton et al., 2014) but does not work well for compressing dense connected layers. This difference is mainly because the two factorized matrices still need to be stored for SVD,\nwhich is not optimized for saving storage. Somewhat surprisingly, kmeans, despite its simplicity, works well for this task. We were able to achieve a 4-8 times compression rate with KM while keeping the accuracy loss within 1%. Applying structured quantization methods such as PQ can further improve performance beyond our results for KM. For RQ, we found it was not able to achieve a very high compression rate, mainly because the codebook size was too big. Given the same compression rate, its accuracy was also much worse than the other methods. Finally, the simplest binarization method worked reasonably well. We were not able to vary its compression rate, but given the same compression rate its performance was comparable to KM or PQ. In addition, its storage is quite simple. Therefore, this method is also a good choice when the goal is to compress data very aggressively.\nThe comparison among KM, PQ, and RQ suggests some interesting insights. First, KM works reasonably well and can achieve a descent compression rate without sacrificing performance. These results suggests that there is considerable redundancy between each single neuron. Applying PQ works even better, which means that there are very meaningful sub-vector local structures in these weight matrices. RQ works extremely poorly for such a task, which probably means there are few global structures in these weight vectors."}, {"heading": "4.4 ANALYSIS OF SINGLE LAYER ERROR", "text": "We also conducted additional analysis on the classification error rate for compressing each single layer while fixing other layers as uncompressed. The results are reported in Figure 4 (for accuracy@1 only). We found that compressing the eighth and ninth hidden layers did not usually lead to significant decrease of performance, but that compressing the tenth and final classification layer led to a much larger decrease of accuracy. Compressing all three layers together usually led to larger error, especially when the compression rate was high. Finally, some sample predictions results are shown in Figure 5."}, {"heading": "5 APPLICATION TO IMAGE RETRIEVAL", "text": "This section presents an application of the compressed CNN to image retrieval, in order to verify the generalization ability of the compressed networks. In real industry applications, many situations would not allow uploading of a photo to the server, or in which uploading large numbers of photos to the server would be unaffordable. In fact, due to bandwidth limits, we were only able to upload some processed data (e.g., features or hashes of the image) to the server. Given the compressed CNN above, we were able to process the images using compressed CNN on the cellphone side, and to perform retrieval on the database side by uploading only the processed feature.\nWe performed experiments on the Holidays dataset (Jegou et al., 2008). This is a widely used standard benchmark dataset for image retrieval that contains 1491 images for 500 different instances; each instance contains 2-3 images. The number of query images is fixed at 500; the rest are used to populate the database. We used mean average precision (mAP) to evaluate different methods. We used each compressed CNN model to generate the 2048-dimensional activation features from the last hidden layer, and used them as features for image retrieval. We used cosine distance to measure the similarities among image features.\nAccording to the results in Table 1, the trend of different methods is similar to the classification results; i.e., PQ consistently worked better than the other methods. One surprising finding was that kmeans with 2 centers (1 bit) gave high results\u2013even higher than the original feature (we also verified the variance as 0.1%). This is a special case, however, which probably came about because the application was near-duplicate image retrieval and because quantizing the values to binary is more robust to small image transformations. However, because our goal was to best reconstruct the original weight matrix, this improvement from this binary kmeans case indeed showed that it is not a very accurate approximation. We are not reporting the results for RQ here, because its performance was so poor.\nIn conclusion, we found that vector quantized CNNs can be safely applied to problems other than image classification."}, {"heading": "6 DISCUSSION", "text": "We have addressed the storage problem of applying vector quantization to compress deep convolutional neural networks in embedded systems. Our work systematically studied how to compress the 108 parameters of a deep convolutional neural network, in order to save storage of the models. Unlike previous approaches that considered using matrix factorization methods, we proposed to study a series of vector quantization methods for compressing the parameters. Somewhat surprisingly, we found that by simply performing a scalar quantization to the parameter\nvalues using kmeans, we were able to obtain 8-16 compression rate of the parameters without sacrificing top-five accuracy in more than 0.5% of the compressions. In addition, by using structured quantization methods, we were able to further compress the parameters up to 24 times while keeping the loss of top-five accuracy within 1%.\nBy compressing the parameters more than 20 times, we addressed the problem of applying state-of-the art CNNs in embedded devices. Given a state-of-the-art model with about 200MB of parameters, we were able to reduce them to less than 10MB, which enabled us to easily deploy such models. Another interesting implication of this paper is that our empirical results confirmed the finding in Denil et al. (2013) that the useful parameters in a CNN are about 5% (we were able to compress them about 20 times).\nIn the future, it will be interesting to explore hardware efficient operations for the compressed models on embedded devices to speed up computation. It will also be interesting to apply fine-tuning to the compressed layers to improve performance. Whereas this paper mainly focused on compressing dense connected layers, it will be interesting to investigate if we can apply the same vector quantization methods to compress convolutional layers."}], "references": [{"title": "Approximate nearest neighbor search by residual vector quantization", "author": ["Chen", "Yongjian", "Guan", "Tao", "Wang", "Cheng"], "venue": null, "citeRegEx": "Chen et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2010}, {"title": "Accelerating deep neural networks on mobile processor with embedded programmable logic", "author": ["Culurciello", "Eugenio", "Dundar", "Aysegul", "Jin", "Jonghoon", "Gokhale", "Vinayak", "Martini", "Berin"], "venue": "In NIPS", "citeRegEx": "Culurciello et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Culurciello et al\\.", "year": 2013}, {"title": "Predicting parameters in deep learning", "author": ["Denil", "Misha", "Shakibi", "Babak", "Dinh", "Laurent", "Ranzato", "Marc\u2019aurelio", "Freitas", "Nando D"], "venue": "K.q. (eds.), Advances in Neural Information Processing Systems", "citeRegEx": "Denil et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Denil et al\\.", "year": 2013}, {"title": "Exploiting linear structure within convolutional networks for efficient evaluation", "author": ["Denton", "Emily", "Zaremba", "Wojciech", "Bruna", "Joan", "LeCun", "Yann", "Fergus", "Rob"], "venue": "In NIPS", "citeRegEx": "Denton et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Denton et al\\.", "year": 2014}, {"title": "Decaf: A deep convolutional activation feature for generic visual recognition", "author": ["Donahue", "Jeff", "Jia", "Yangqing", "Vinyals", "Oriol", "Hoffman", "Judy", "Zhang", "Ning", "Tzeng", "Eric", "Darrell", "Trevor"], "venue": "CoRR, abs/1310.1531,", "citeRegEx": "Donahue et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Donahue et al\\.", "year": 2013}, {"title": "Rich feature hierarchies for accurate object detection and semantic segmentation", "author": ["Girshick", "Ross", "Donahue", "Jeff", "Darrell", "Trevor", "Malik", "Jitendra"], "venue": "In Computer Vision and Pattern Recognition,", "citeRegEx": "Girshick et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Girshick et al\\.", "year": 2014}, {"title": "A 240 g-ops/s mobile coprocessor for deep neural networks", "author": ["V. Gokhale", "Jin", "Jonghoon", "A. Dundar", "B. Martini", "E. Culurciello"], "venue": "In CVPR Workshops", "citeRegEx": "Gokhale et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Gokhale et al\\.", "year": 2013}, {"title": "Iterative quantization: A Procrustean approach to learning binary codes for large-scale image retrieval", "author": ["Gong", "Yunchao", "Lazebnik", "Svetlana", "Gordo", "Albert", "Perronnin", "Florent"], "venue": null, "citeRegEx": "Gong et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Gong et al\\.", "year": 2012}, {"title": "Multi-scale orderless pooling of deep convolutional activation features", "author": ["Gong", "Yunchao", "Wang", "Liwei", "Guo", "Ruiqi", "Lazebnik", "Svetlana"], "venue": "In ECCV", "citeRegEx": "Gong et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Gong et al\\.", "year": 2014}, {"title": "Speeding up convolutional neural networks with low rank expansions", "author": ["M. Jaderberg", "A. Vedaldi", "A. Zisserman"], "venue": "In BMVC", "citeRegEx": "Jaderberg et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Jaderberg et al\\.", "year": 2014}, {"title": "Hamming embedding and weak geometric consistency for large-scale image", "author": ["Jegou", "Herve", "Douze", "Matthijs", "Schmid", "Cordelia"], "venue": null, "citeRegEx": "Jegou et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Jegou et al\\.", "year": 2008}, {"title": "Product quantization for nearest neighbor search", "author": ["Jegou", "Herve", "Douze", "Matthijs", "Schmid", "Cordelia"], "venue": "IEEE TPAMI,", "citeRegEx": "Jegou et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Jegou et al\\.", "year": 2011}, {"title": "Caffe: An open source convolutional architecture for fast feature embedding", "author": ["Jia", "Yangqing"], "venue": "http: //caffe.berkeleyvision.org/,", "citeRegEx": "Jia and Yangqing.,? \\Q2013\\E", "shortCiteRegEx": "Jia and Yangqing.", "year": 2013}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["Krizhevsky", "Alex", "Sutskever", "Ilya", "Hinton", "Geoffrey E"], "venue": "Neural Information Processing Systems,", "citeRegEx": "Krizhevsky et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Handwritten digit recognition with a back-propagation", "author": ["Y. LeCun", "B. Boser", "J.S. Denker", "D. Henderson", "R.E. Howard", "W. Hubbard", "L.D. Jackel"], "venue": null, "citeRegEx": "LeCun et al\\.,? \\Q1990\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1990}, {"title": "Fast training of convolutional networks through ffts", "author": ["M Mathieu", "M. Henaff", "Y. LeCun"], "venue": "In Arxiv,", "citeRegEx": "Mathieu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mathieu et al\\.", "year": 2013}, {"title": "CNN features off-the-shelf: an astounding baseline for recognition", "author": ["Razavian", "Ali Sharif", "Azizpour", "Hossein", "Sullivan", "Josephine", "Carlsson", "Stefan"], "venue": "CoRR, abs/1403.6382,", "citeRegEx": "Razavian et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Razavian et al\\.", "year": 2014}, {"title": "Overfeat: Integrated recognition, localization and detection using convolutional networks", "author": ["Sermanet", "Pierre", "Eigen", "David", "Zhang", "Xiang", "Mathieu", "Michael", "Fergus", "Rob", "LeCun", "Yann"], "venue": "arXiv preprint arXiv:1312.6229,", "citeRegEx": "Sermanet et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Sermanet et al\\.", "year": 2013}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["Simonyan", "Karen", "Zisserman", "Andrew"], "venue": "CoRR, abs/1409.1556,", "citeRegEx": "Simonyan et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Simonyan et al\\.", "year": 2014}, {"title": "Deep fisher networks for large-scale image classification", "author": ["Simonyan", "Karen", "Vedaldi", "Andrea", "Zisserman", "Andrew"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Simonyan et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Simonyan et al\\.", "year": 2013}, {"title": "Improving the speed of neural networks on cpus", "author": ["V. Vanhoucke", "A. Senior", "M.Z. Mao"], "venue": "In Deep Learning and Unsupervised Feature Learning NIPS Workshop,", "citeRegEx": "Vanhoucke et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Vanhoucke et al\\.", "year": 2011}, {"title": "Regularization of neural networks using dropconnect", "author": ["Wan", "Li", "Zeiler", "Matt", "Zhang", "Sixin", "Lecun", "Yann", "Fergus", "Rob"], "venue": null, "citeRegEx": "Wan et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Wan et al\\.", "year": 2013}, {"title": "Visualizing and understanding convolutional neural networks", "author": ["Zeiler", "Matthew D", "Fergus", "Rob"], "venue": "arXiv preprint arXiv:1311.2901,", "citeRegEx": "Zeiler et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Zeiler et al\\.", "year": 2013}], "referenceMentions": [{"referenceID": 13, "context": "Deep convolutional neural networks (Krizhevsky et al., 2012; LeCun et al., 1990; Szegedy et al., 2014; Simonyan & Zisserman, 2014) has recently achieved significant progress and have become the gold standard for object recognition, image classification, and retrieval.", "startOffset": 35, "endOffset": 130}, {"referenceID": 14, "context": "Deep convolutional neural networks (Krizhevsky et al., 2012; LeCun et al., 1990; Szegedy et al., 2014; Simonyan & Zisserman, 2014) has recently achieved significant progress and have become the gold standard for object recognition, image classification, and retrieval.", "startOffset": 35, "endOffset": 130}, {"referenceID": 4, "context": "Almost all of the recent successful recognition systems (Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013; Gong et al., 2014) are built on top of this architecture.", "startOffset": 56, "endOffset": 177}, {"referenceID": 19, "context": "Almost all of the recent successful recognition systems (Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013; Gong et al., 2014) are built on top of this architecture.", "startOffset": 56, "endOffset": 177}, {"referenceID": 17, "context": "Almost all of the recent successful recognition systems (Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013; Gong et al., 2014) are built on top of this architecture.", "startOffset": 56, "endOffset": 177}, {"referenceID": 8, "context": "Almost all of the recent successful recognition systems (Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013; Gong et al., 2014) are built on top of this architecture.", "startOffset": 56, "endOffset": 177}, {"referenceID": 6, "context": "Importing CNN onto embedded platforms (Gokhale et al., 2013; Culurciello et al., 2013), the recent trend toward mobile computing, has a wide range of application impacts.", "startOffset": 38, "endOffset": 86}, {"referenceID": 1, "context": "Importing CNN onto embedded platforms (Gokhale et al., 2013; Culurciello et al., 2013), the recent trend toward mobile computing, has a wide range of application impacts.", "startOffset": 38, "endOffset": 86}, {"referenceID": 17, "context": "For example, a typical CNN (Jia, 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013) that works well for object recognition contains eight layers (five convolutional layers and three dense connected layers) and a huge number of parameters (e.", "startOffset": 27, "endOffset": 84}, {"referenceID": 2, "context": "Because as is widely known, the parameters are heavily over-parameterized (Denil et al., 2013), it is very interesting to investigate whether we can compress these parameters by exploring their structure.", "startOffset": 74, "endOffset": 94}, {"referenceID": 3, "context": "Here, we are mainly interested in compressing the parameters to reduce storage instead of speeding up the testing time (Denton et al., 2014).", "startOffset": 119, "endOffset": 140}, {"referenceID": 9, "context": "Another similar work on speeding up CNN is (Jaderberg et al., 2014), in which the authors described several reconstruction methods for approximating the filers in convolutional layers.", "startOffset": 43, "endOffset": 67}, {"referenceID": 3, "context": "In this work, instead of the traditional matrix factorization methods considered in (Denton et al., 2014; Jaderberg et al., 2014), we mainly consider a series of information theoretical vector quantization methods (Jegou et al.", "startOffset": 84, "endOffset": 129}, {"referenceID": 9, "context": "In this work, instead of the traditional matrix factorization methods considered in (Denton et al., 2014; Jaderberg et al., 2014), we mainly consider a series of information theoretical vector quantization methods (Jegou et al.", "startOffset": 84, "endOffset": 129}, {"referenceID": 11, "context": ", 2014), we mainly consider a series of information theoretical vector quantization methods (Jegou et al., 2011; Chen et al., 2010) for compressing dense connected layers.", "startOffset": 92, "endOffset": 131}, {"referenceID": 0, "context": ", 2014), we mainly consider a series of information theoretical vector quantization methods (Jegou et al., 2011; Chen et al., 2010) for compressing dense connected layers.", "startOffset": 92, "endOffset": 131}, {"referenceID": 2, "context": "The most closely related one, Denton et al. (2014), explored matrix factorization methods for speeding up CNN testing time.", "startOffset": 30, "endOffset": 51}, {"referenceID": 13, "context": "Deep convolutional neural network has achieved great successes in image classification (Krizhevsky et al., 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al.", "startOffset": 87, "endOffset": 214}, {"referenceID": 4, "context": "Deep convolutional neural network has achieved great successes in image classification (Krizhevsky et al., 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al.", "startOffset": 87, "endOffset": 214}, {"referenceID": 19, "context": "Deep convolutional neural network has achieved great successes in image classification (Krizhevsky et al., 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al.", "startOffset": 87, "endOffset": 214}, {"referenceID": 17, "context": "Deep convolutional neural network has achieved great successes in image classification (Krizhevsky et al., 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al.", "startOffset": 87, "endOffset": 214}, {"referenceID": 5, "context": ", 2013; Zeiler & Fergus, 2013), object detection (Girshick et al., 2014), and image retrieval (Razavian et al.", "startOffset": 49, "endOffset": 72}, {"referenceID": 16, "context": ", 2014), and image retrieval (Razavian et al., 2014; Gong et al., 2014).", "startOffset": 29, "endOffset": 71}, {"referenceID": 8, "context": ", 2014), and image retrieval (Razavian et al., 2014; Gong et al., 2014).", "startOffset": 29, "endOffset": 71}, {"referenceID": 2, "context": ", 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al., 2014), and image retrieval (Razavian et al., 2014; Gong et al., 2014). With the great progress in this area, the state-of-the-art image classifier can achieve 94% top five accuracy on the ILSVRC2014 dataset with 1000 object classes, and is already very close human performance. Such great success ignites interest in adopting CNNs to real world applications. For example, CNN has already been applied to object classification, scene classification, and indoor scene classification. It has also been applied to image retrieval, with impressive results. As discussed in the above section, a state-of-the-art CNN usually involves hundreds of millions of parameters, which require huge storage for the model that is difficult to achieve. The bottleneck comes from model storage and testing speed. Several works have been published on speeding up CNN prediction speed. Vanhoucke et al. (2011), who explored the properties of CPU to speed up the execution of CNN, particularly focused on the aligning of memory and SIMD operations to boost matrix operations.", "startOffset": 19, "endOffset": 1034}, {"referenceID": 2, "context": ", 2012; Jia, 2013; Donahue et al., 2013; Simonyan et al., 2013; Sermanet et al., 2013; Zeiler & Fergus, 2013), object detection (Girshick et al., 2014), and image retrieval (Razavian et al., 2014; Gong et al., 2014). With the great progress in this area, the state-of-the-art image classifier can achieve 94% top five accuracy on the ILSVRC2014 dataset with 1000 object classes, and is already very close human performance. Such great success ignites interest in adopting CNNs to real world applications. For example, CNN has already been applied to object classification, scene classification, and indoor scene classification. It has also been applied to image retrieval, with impressive results. As discussed in the above section, a state-of-the-art CNN usually involves hundreds of millions of parameters, which require huge storage for the model that is difficult to achieve. The bottleneck comes from model storage and testing speed. Several works have been published on speeding up CNN prediction speed. Vanhoucke et al. (2011), who explored the properties of CPU to speed up the execution of CNN, particularly focused on the aligning of memory and SIMD operations to boost matrix operations. Mathieu et al. (2013) showed that the convolutional operation can be efficiently carried out in the Fourier domain, which leads to a speed-up of 200%.", "startOffset": 19, "endOffset": 1221}, {"referenceID": 2, "context": "Two very recent works by Denton et al. (2014) and Jaderberg et al.", "startOffset": 25, "endOffset": 46}, {"referenceID": 2, "context": "Two very recent works by Denton et al. (2014) and Jaderberg et al. (2014), which explored the use of linear matrix factorization methods for speeding up convolutional layers, showed a 200% speed-up with little compromise of classification performance.", "startOffset": 25, "endOffset": 74}, {"referenceID": 2, "context": "The use of vector quantization methods to compress CNN parameters is mainly inspired by the work of Denil et al. (2013), who demonstrate the redundancies in neural network parameters.", "startOffset": 100, "endOffset": 120}, {"referenceID": 2, "context": "The use of vector quantization methods to compress CNN parameters is mainly inspired by the work of Denil et al. (2013), who demonstrate the redundancies in neural network parameters. They show that the weights within one layer can be accurately predicted by a small ( 5%) subset of the parameters, which indicates that the neural network is over-parameterized. These results motivate us to apply vector quantization methods to explore the redundancy in parameter space. In particular, our paper can be viewed as a compression realization of the parameter prediction results reported in Denil et al. (2013). Somewhat surprisingly, we have found very similar results to those of Denil", "startOffset": 100, "endOffset": 607}, {"referenceID": 2, "context": "This result further confirms the interesting empirical findings in Denil et al. (2013).", "startOffset": 67, "endOffset": 87}, {"referenceID": 3, "context": "We first consider matrix factorization methods, which have been widely used to speed up CNN (Denton et al., 2014) as well as for compressing parameters in linear models (Denton et al.", "startOffset": 92, "endOffset": 113}, {"referenceID": 3, "context": ", 2014) as well as for compressing parameters in linear models (Denton et al., 2014).", "startOffset": 63, "endOffset": 84}, {"referenceID": 21, "context": "This method is mainly inspired by Dropconnect (Wan et al., 2013), which randomly sets part of the parameters (neurons) to 0 during training.", "startOffset": 46, "endOffset": 64}, {"referenceID": 11, "context": "In particular, we consider the use of product quantization (PQ) (Jegou et al., 2011), which explores the redundancy of structures in vector space.", "startOffset": 64, "endOffset": 84}, {"referenceID": 0, "context": "The third quantization method we consider is residual quantization (Chen et al., 2010), which is another form of structured quantization.", "startOffset": 67, "endOffset": 86}, {"referenceID": 7, "context": ", 2008), Iterative Quantization (Gong et al., 2012), and Catesian kmeans (Norouzi & Fleet, 2013), among others.", "startOffset": 32, "endOffset": 51}, {"referenceID": 3, "context": "In particular, SVD achieves impressive results for compressing and speeding up convolutional layers (Denton et al., 2014) but does not work well for compressing dense connected layers.", "startOffset": 100, "endOffset": 121}, {"referenceID": 10, "context": "We performed experiments on the Holidays dataset (Jegou et al., 2008).", "startOffset": 49, "endOffset": 69}], "year": 2014, "abstractText": "Deep convolutional neural networks (CNN) has become the most promising method for object recognition, repeatedly demonstrating record breaking results for image classification and object detection in recent years. However, a very deep CNN generally involves many layers with millions of parameters, making the storage of the network model to be extremely large. This prohibits the usage of deep CNNs on resource limited hardware, especially cell phones or other embedded devices. In this paper, we tackle this model storage issue by investigating information theoretical vector quantization methods for compressing the parameters of CNNs. In particular, we have found in terms of compressing the most storage demanding dense connected layers, vector quantization methods have a clear gain over existing matrix factorization methods. Simply applying k-means clustering to the weights or conducting product quantization can lead to a very good balance between model size and recognition accuracy. For the 1000-category classification task in the ImageNet challenge, we are able to achieve 16-24 times compression of the network with only 1% loss of classification accuracy using the state-of-the-art CNN.", "creator": "LaTeX with hyperref package"}}}