{"id": "1502.00702", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Feb-2015", "title": "Hybrid Orthogonal Projection and Estimation (HOPE): A New Framework to Probe and Learn Neural Networks", "abstract": "In this paper, we propose a universal model for high-dimensional data, called the Hybrid Orthogonal Projection and Estimation (HOPE) model, which combines a linear orthogonal projection and a finite mixture model under a unified generative modelling framework. The HOPE model itself can be learned unsupervisedly from un-labelled data based on the maximum likelihood estimation as well as trained discriminatively from labelled data. More interestingly, we have shown the proposed HOPE models are closely related to neural networks (NNs) in a sense that each NN hidden layer can be reformulated as a HOPE model. As a result, the HOPE framework can be used as a novel tool to probe why and how NNs work, more importantly, it also provides several new learning algorithms to learn NNs either supervisedly or unsupervisedly. In this work, we have investigated the HOPE framework in learning NNs for several standard tasks, including image recognition on MNIST and speech recognition on TIMIT. Experimental results show that the HOPE framework yields significant performance gains over the current state-of-the-art methods in various types of NN learning problems, including unsupervised feature learning, supervised or semi-supervised learning.", "histories": [["v1", "Tue, 3 Feb 2015 01:38:19 GMT  (954kb,D)", "http://arxiv.org/abs/1502.00702v1", "29 pages, 4 Figures, technical report"], ["v2", "Sat, 6 Jun 2015 01:57:42 GMT  (1172kb,D)", "http://arxiv.org/abs/1502.00702v2", "31 pages, 5 Figures, technical report"]], "COMMENTS": "29 pages, 4 Figures, technical report", "reviews": [], "SUBJECTS": "cs.LG cs.NE", "authors": ["shiliang zhang", "hui jiang"], "accepted": false, "id": "1502.00702"}, "pdf": {"name": "1502.00702.pdf", "metadata": {"source": "CRF", "title": "Hybrid Orthogonal Projection and Estimation (HOPE): A New Framework to Probe and Learn Neural Networks", "authors": ["Shiliang Zhang", "Hui Jiang"], "emails": ["zsl2008@mail.ustc.edu.cn,", "hj@cse.yorku.ca"], "sections": [{"heading": null, "text": "In this paper, we propose a universal model for high-dimensional data, called the Hybrid Orthogonal Projection and Estimation (HOPE) model, which combines a linear orthogonal projection and a finite mixture model under a unified generative modelling framework. The HOPE model itself can be learned unsupervisedly from un-labelled data based on the maximum likelihood estimation as well as trained discriminatively from labelled data. More interestingly, we have shown the proposed HOPE models are closely related to neural networks (NNs) in a sense that each hidden layer can be reformulated as a HOPE model. As a result, the HOPE framework can be used as a novel tool to probe why and how NNs work, more importantly, it also provides several new learning algorithms to learn NNs either supervisedly or unsupervisedly. In this work, we have investigated the HOPE framework in learning NNs for several standard tasks, including image recognition on MNIST and speech recognition on TIMIT. Experimental results show that the HOPE framework yields significant performance gains over the current stateof-the-art methods in various types of NN learning problems, including unsupervised feature learning, supervised or semi-supervised learning."}, {"heading": "1 Introduction", "text": "Generally speaking, machine learning systems typically consist of several distinct steps in design, namely feature extraction and data modelling. In feature extraction, some engineering tricks are used to pre-process raw data to extract useful and representative features for the underlying data sets. As a result, this stage is sometimes called feature engineering. For high-dimensional data, the feature extraction stage needs to distill \u201cgood\u201d features that are representative enough to discriminate different data samples but also it has to perform effective dimensional reduction to generate less correlated features that can be easily modelled in a lower dimensional space. In data modelling, an appropriate model is selected to model data in the lower-dimensional feature space. There are a wide range of models available for this purpose, such as K-Nearest-Neighbours (kNN) model, decision trees, linear discriminant models, neural networks, statistical models from the exponential family, or mixtures of the exponential family distributions, and so on. Subsequently, all unknown model parameters are estimated from available training samples based on certain learning criterion, such as maximum likelihood estimation (MLE) or discriminative learning.\nar X\niv :1\n50 2.\n00 70\n2v 1\n[ cs\n.L G\n] 3\nF eb\nIn many traditional machine learning methods, feature extraction and data modelling are normally conducted independently in two loosely-coupled stages, where feature extraction parameters and model parameters are separately optimized based on rather different criteria. Particularly, feature extraction is normally regarded as a pre-processing stage, where feature extraction parameters are estimated under some quite loose conditions, such as the assumption that data is normally distributed in a high-dimensional space as implied in linear discriminant analysis (LDA) and principle component analysis (PCA). On the other hand, neural networks (NNs) favour an end-to-end learning process and it is normally considered as one exception to the above paradigm. In practice, it has been widely observed that that NNs are capable of dealing with almost any type of raw data directly without any explicit feature engineering. In the recent resurgence of NNs under the name of \u201cdeep learning\u201d, more and more empirical results have demonstrated that deep neural networks (DNNs) can effectively de-correlate highdimensional raw data and automatically learn useful features from large training sets, without being disturbed by \u201cthe curse of dimensionality\u201d. However, it still remains unclear why NNs can handle these and what mechanism is used by NNs to de-correlate high-dimensional raw data to learn good feature representations for many real-world complicated tasks.\nIn this paper, we first propose a universal data modelling framework for high-dimensional data, namely Hybrid Orthogonal Projection and Estimation (HOPE). The key argument for the HOPE framework is that feature extraction and data modelling should not be decoupled into two separate stages in learning and a good feature extraction module can not be learned based on some over-simplified and unrealistic modelling assumptions. The feature extraction and data modelling must be jointly learned and optimized by considering the complex nature of data distributions. This is particularly important in coping with high-dimensional data arising from most real-world applications. In the HOPE framework, we propose to model high-dimensional data by combining a relatively simple feature extraction model, namely a linear orthogonal projection, with a powerful statistical model for data modelling, namely a finite mixture model of the exponential family distributions, under one unified generative modelling framework. In this paper, we consider two possible choices for the mixture models, namely Gaussian mixture models (GMMs) and mixtures of the von Mises-Fisher (movMFs) distributions. First of all, an orthogonal linear projection is used in feature extraction to ensure that the highly-correlated high-dimensional raw data is first projected onto a lower-dimensional latent feature space, where all feature dimensions are largely un-correlated. This will give us huge advantages to model data in this feature space rather than the original data space because the feature space has lower dimensions and all feature dimensions are uncorrelated and thus more likely to be independent. Secondly, in the HOPE framework, we propose to use a powerful model to represent data in the lower-dimensional feature space, rather than using any over-simplified models for computational convenience. This is very important since any real-world data tend to follow a rather complex distribution, which can always be approximated by a finite mixture model up to any arbitrary precision. Thirdly, the most important argument in HOPE is that both the orthogonal projection and the mixture model must be learned jointly according to a single unified criterion. In this paper, we first consider to learn HOPE in an unsupervised manner based on the conventional maximum likelihood (ML) criterion and also explain that the HOPE models can also be supervisedly learned based on any discriminative learning criterion.\nOne important finding in this work is that the proposed HOPE models are closely related to neural networks (NNs) currently widely used in deep learning. As we will show, any single\nhidden layer in the most popular rectified linear (ReLU) NNs can always be reformulated as a HOPE model consisting of a linear orthogonal projection and a mixture of von Mises-Fisher distributions (movMFs). This formulation helps to explain how NNs actually deal with highdimensional data and why NNs can de-correlate almost any types of high-dimensional data to generate good feature representations. More importantly, this formulation may open up new possibilities to learn NNs more effectively. For example, both supervised and unsupervised learning algorithms for the HOPE models can be easily applied to learn NNs. By imposing an explicit orthogonal constraint on the feature extraction layer, we will show that the HOPE methods are very effective in learning NNs for both supervised and unsupervised learning. In unsupervised learning, we have shown that the maximum likelihood (ML) based HOPE learning algorithms can serve as an very effective unsupervised learning method to learn NNs from unlabelled data. Our experimental results have shown that the ML-based HOPE learning algorithm can learn good feature representations in an unsupervised way without using any data labels. These unsupervisedly learning features may be fed to some simple post-stage classifiers, such as linear SVM, to yield comparable performance as deep NNs supervisedly learned end-to-end with data labels. Our proposed unsupervised learning algorithms significantly outperform the previous methods based on the Restricted Boltzmann Machine (RBM) [12] and auto-encoder variants [5,27]. Moreover, in supervised learning, relying on the HOPE models, we have managed to learn some shallow NNs from scratch, which perform comparably with the state-of-the-art deep neural networks (DNNs), as opposed to learn shallow NNs to mimic a pre-trained deep neural network as in [2]. Finally, the HOPE models can also be used to train deep neural networks and it normally provides significant performance gain over the standard NN learning methods. These results have suggested that the orthogonal constraint in HOPE may serve as a good model regularization in learning of NNs."}, {"heading": "2 Related Work", "text": "Dimension reduction in feature space is a well-studied topic in machine learning. Among many, PCA is the most popular technique in this category. PCA is defined as the orthogonal projection of the high-dimensional data onto a lower dimensional linear space, known as the principal subspace, such that the variance of the projected data is maximized [6]. The nice property of PCA is that it can be formulated as the eigenvector problem of the data covariance matrix, where a simple closed-form solution exists. Moreover, in the probabilistic PCA [24,26], PCA can be expressed as the maximum likelihood solution of a probabilistic latent variable model. In this case, if the projected data are assumed to follow a zero-mean unit-covariance Gaussian distribution in the principal subspace, the probabilistic PCA can also be solved by an exact closed-form solution related to the eigenvectors of the data covariance matrix. The major limitation of PCA is that it is constrained to learn a linear subspace. Many approaches have been proposed to perform nonlinear dimensional reduction to learn possible nonlinear manifolds embedded within a high dimensional data space. One way to model the nonlinear structure is through a combination of linear models, so that we make a piece-wise linear approximation to the manifold. This can be obtained by a clustering technique to partition the data set into local groups with standard PCA applied to each group, such as [11,17,25]. In [25], the high-dimensional raw data is assumed to follow a mixture model, where each component may perform its own maximum likelihood PCA\nin a local region. However, in these methods, it may be quite challenging to perform effective clustering or estimate good mixture models for high-dimensional data due to the strong correlation in various data dimensions. Alternatively, in [13], a flexible nonlinear method is proposed to reduce feature dimension based on a deep auto-associative neural network.\nSimilar to PCA, the Fisher\u2019s linear discriminant analysis (LDA) can also be viewed as a linear dimensionality reduction technique. However, PCA is unsupervised in the sense that PCA depends only on the data while Fisher\u2019s LDA is supervised since it uses both data and class-label information. The high-dimensional data are linearly projected to a subspace where various classes are best distinguished as measured by the Fisher criterion. In [18], the so-called Heteroscedastic discriminant analysis (HDA) is proposed to extend LDA to deal with highdimensional data with heteroscedastic covariance, where a linear projection can be learned from data and class labels based on the maximum likelihood criterion."}, {"heading": "3 Hybrid Orthogonal Projection and Estimation (HOPE)", "text": "Consider a standard PCA setting, where each data sample is represented as a high-dimensional vector x with dimensionality D. Our goal is to learn a linear projection, represented as a matrix U, to map each data sample onto a space having dimensionality M < D, which is called the latent feature space hereafter in this paper. Our proposed HOPE model is essentially a generative model in nature but it may also be viewed as a generalization to extend the probabilistic PCA in [26] to consider a complex data distribution that has to be modelled by a finite mixture model in the latent feature space. This setting is very different from the ones used in [25], where the original data x is modelled by mixture models in the original higher D-dimensional raw data space."}, {"heading": "3.1 HOPE: combining generalized PCA with generative model", "text": "Assume we have a full-size D\u00d7D orthogonal matrix U\u0302, satisfying U\u0302T U\u0302 = U\u0302U\u0302T = I, each data sample x in the original D-dimensional data space can be decomposed based on all orthogonal row vectors of U\u0302, denoted as ui with i = 1, \u00b7 \u00b7 \u00b7 , D, as follows:\nx = D\u2211 i=1 (x \u00b7 ui) ui. (1)\nAs shown in PCA, each high-dimensional data x can normally be represented in a lowerdimensional space fairly precisely and the contributions from the remaining dimensions may be viewed as random residual noises that have sufficiently small variances. Therefore, we have\nx = (x \u00b7 u1) u1 + \u00b7 \u00b7 \u00b7+ (x \u00b7 uM ) uM\ufe38 \ufe37\ufe37 \ufe38 signal component x\u0303 + (x \u00b7 uM+1) uM+1 + \u00b7 \u00b7 \u00b7+ (x \u00b7 uD) uD\ufe38 \ufe37\ufe37 \ufe38 noise component x\u0304\n(2)\nHere we are interested in learning an M \u00d7 D projection matrix, denoted as U, to extract the signal component x\u0303. First of all, if M (M < D) is selected properly, the projection may serve as an effective feature extraction for signals as well as a mechanism to eliminate unwanted noises from the higher dimensional raw data. This may make the subsequent learning process more robust and less prone to overfitting. Secondly, all M row vectors ui with i = 1, \u00b7 \u00b7 \u00b7 ,M are\nlearned to represent signals well in a lower M -dimension space. Furthermore, since all ui are orthogonal, it implies the latent features are un-correlated, more likely to be independent. This will significantly simplify the following learning problem as well.\nIn this case, each D-dimension data x sample is linearly projected onto an M -dimension vector z as z = Ux, where U is an orthogonal matrix, satisfying UUT = I. Meanwhile, we denote the projection of the unwanted noise component x\u0304 as n, and n can be similarly computed as n = Vx, where V is another orthogonal matrix corresponding to all noise dimensions, satisfying VVT = I. Moreover, V is orthogonal to U, i.e. VUT = 0. In overall, we may represent the above projection as follows: [\nz; n ] = [ U; V ] x = U\u0302x (3)\nwhere U\u0302 is the above-mentioned D \u00d7D orthogonal projection matrix. Moreover, it is straightforward to show that the signal component x\u0303 and the residual noise x\u0304 in the original data space can be easily computed from the above projections as follows:\nx\u0303 = UT z = UTUx (4)\nx\u0304 = x\u2212 x\u0303 = (I\u2212UTU)x (5)\nIn the following, we consider how to learn the projection matrix U to representD-dimensional data well in a lower M -dimension feature space. If this projection is learned properly, it is reasonable to assume the above signal projection, z, and the residual noise projection, n, are independent in the latent feature space. Therefore, we may derive the probability distribution of the original data as follows:\np(x) = |U\u0302\u22121| \u00b7 p(z) \u00b7 p(n) (6)\nwhere U\u0302\u22121 denotes the Jacobian matrix to linearly map data from the projected space back to the original data space. If U\u0302 is orthonormal, the above Jacobian term equals to one. In this work, we follow [26] to assume the residual noise projection n follows an isotropic covariance Gaussian distribution in the (D-M)-dimensional space, i.e. p(n) \u223c N (n | 0, \u03c32I), 1 where \u03c32 is a variance parameter to be learned from data. As for the signal projection z, we adopt a quite different approach, as described below in detail.\nIn all previous works, the signal projection z is assumed to follow a simple distribution in the M -dimension space. For example, z is assumed to follow a zero-mean unit-covariance Gaussian distribution in probabilistic PCA [24, 26]. The advantage of this assumption is that an exact closed-form solution may be derived to calculate the projection matrix U using the spectral methods from the data covariance matrix.\nHowever, in most real-world applications, z still locates in a very high-dimensional space even after the linear projection, it does not make sense to assume z follows a simple unimodal distribution. As widely reported in the literature, it is observed that real-world data never follow a unimodal distribution in a high-dimensional space and they usually appear only in multiple concentrated regions in the high-dimensional space. More realistically, it is better to assume that z follows a finite mixture model in the M -dimension feature space because a finite\n1Without losing generality, we may simply normalize the training data to ensure that the residual noises have zero mean.\nmixture model may theoretically approximate any arbitrary statistical distribution as long as a sufficiently large number of mixture components are used. For simplicity, we may assume z follows a finite mixture of some exponential family distributions:\np(z) = K\u2211 k=1 \u03c0k \u00b7 fk(z|\u03b8k) (7)\nwhere \u03c0k denotes mixture weights with \u2211K\nk=1 \u03c0k = 1, and fk(z|\u03b8k) stands for a unimodal distribution from the exponential family with model parameters \u03b8k. We use \u0398 to denote all model parameters in the mixture model, i.e., \u0398 = {\u03b8k|k = 1, \u00b7 \u00b7 \u00b7 ,K}. In practice, fk(z|\u03b8k) is chosen from the exponential family based on the nature of data. In this paper, we consider two possible choices for high-dimensional continuous data, namely the multivariate Gaussian distributions and the von Mises-Fisher (vMF) distributions. The learning algorithm can be easily extended to other models in the exponential family.\nFor example, if we choose the multivariate Gaussian distribution, then z follows a Gaussian mixture model (GMM) as follows:\np(z) = K\u2211 k=1 \u03c0k \u00b7 fk(z|\u03b8k) = K\u2211 k=1 \u03c0k \u00b7 N (z | \u00b5k,\u03a3k) (8)\nwhere N (z | \u00b5k,\u03a3k) denotes a multivariate Gaussian distribution with the mean vector \u00b5k and the covariance matrix \u03a3k. Since the projection matrix U is orthogonal, all dimensions in z are uncorrelated. Therefore, it is reasonable to assume each Gaussian component has a diagonal covariance matrix \u03a3k. This may significantly simplify the model estimation of GMMs.\nAlternatively, we may select a less popular model, i.e., the von Mises-Fisher (vMF) distribution.2 The vFM distribution may be viewed as a generalized normal distribution defined on a high-dimensional spherical surface. In this case, z follows a mixture of the von Mises-Fisher (movMF) distributions as follows:\np(z) = K\u2211 k=1 \u03c0k \u00b7 fk(z|\u03b8k) = K\u2211 k=1 \u03c0k \u00b7 CM (|\u00b5k|) \u00b7 ez\u00b7\u00b5k (9)\nwhere z is located on the surface of an M-dimensional sphere, i.e., |z| = 1, \u03b8k denotes all model parameters of the k-th vMF component and it is an M -dimensional vector in this case, and CM (\u03ba) is the probability normalization term of the k-th vMF component defined as:\nCM (\u03ba) = \u03baM/2\u22121\n(2\u03c0)M/2IM/2\u22121(\u03ba) (10)\nwhere Iv(\u00b7) denotes the modified Bessel function of the first kind at order v. 2The main reason why we are interested in the von Mises-Fisher (vMF) distributions is that the choice of the vMF model can strictly link our HOPE model to regular neural networks in deep learning. We will elucidate this later in this paper."}, {"heading": "4 Unsupervised Learning of HOPE Models", "text": "Obviously, the HOPE model is essentially a generative model that combines feature extraction and data modelling together, and thus its model parameters, including both the project matrix and the mixture model, can be estimated based on the maximum likelihood (ML) criterion, just like normal generative models as well as the probabilistic PCA in [26]. However, since z follows a mixture distribution, no closed-form solution is available to derive either the projection matrix or the mixture model. In this case, some iterative optimization algorithms, such as stochastic gradient descent (SGD) [7,8], may be used to jointly estimate both the projection matrix U and the underlying mixture model altogether to maximize a joint likelihood function. In this section, we assume the projection matrices, not only U but also the whole U\u0302, are all orthonormal. As a result, the Jacobian term in eq.(6) disappears since it equals to one. Refer to Appendix A for the case where U is not orthonormal.\nAssume a training set is available as X = {xn | n = 1, \u00b7 \u00b7 \u00b7 , N}, the joint log-likelihood function related to all HOPE parameters, including the projection matrix U, the mixture model \u0398 = {\u03b8k|k = 1, \u00b7 \u00b7 \u00b7 ,K} and residual noise variance \u03c3, can be expressed as follows:\nL(U,\u0398, \u03c3 | X) = N\u2211 n=1 ln Pr(xn) = N\u2211 n=1 [ ln Pr(zn) + ln Pr(nn) ]\n= N\u2211 n=1 ln ( K\u2211 k=1 \u03c0k \u00b7 fk(Uxn|\u03b8k) ) \ufe38 \ufe37\ufe37 \ufe38\nL1(U,\u0398)\n+ N\u2211 n=1 ln ( N ( nn |0, \u03c32I )) \ufe38 \ufe37\ufe37 \ufe38\nL2(U,\u03c3)\n(11)\nThe HOPE parameters, including U, \u0398 and \u03c3, can all be estimated by maximizing the above likelihood function as:\n{U\u2217,\u0398\u2217, \u03c3\u2217} = arg maxU,\u0398,\u03c3 L(U,\u0398, \u03c3 | X) (12)\nsubject to an orthogonal constraint: UUT = I. (13)\nThere are many methods to enforce the above orthogonal constraint in the optimization. For example, we may periodically apply the Gram-Schmidt process in linear algebra to orthogonalize U during the optimization process. In this work, for computational efficiency, we follow [4] to cast the orthogonal constraint condition in eq.(13) as a penalty term in the objective function to convert the above constrained optimization problem into an unconstrained one as follows:\n{U\u2217,\u0398\u2217, \u03c3\u2217} = arg maxU,\u0398,\u03c3 [ L(U,\u0398, \u03c3 | X)\u2212 \u03b2 \u00b7 D(U) ] (14)\nwhere \u03b2 (\u03b2 > 0) is a control parameter to balance the contribution of the penalty term, and the penalty term D(U) is a differentiable function as:\nD(U) = M\u2211 i=1 M\u2211 j=i+1 |ui \u00b7 uj | |ui| \u00b7 |uj |\n(15)\nwith ui denoting the i-th row vector of the project matrix U, and ui \u00b7uj representing the inner product of ui and uj . The norms of all row vectors of U need to be normalized to one after each update.\nIn this work, we propose to use the stochastic gradient descent (SGD) method to optimize the objective function in eq.(14). In this case, given any training data or a mini-batch of them, we calculate the gradients of the objective function with respect to the projection matrix, U, and the parameters of the mixture model, \u0398, and then update them iteratively until the objective function converges. The gradients of L1(U,\u0398) depends on the mixture model to be used. In the following, we first consider how to compute derivatives of D(U) and L2(U, \u03c3), which are general for all HOPE models. After that, as two examples, we will show how to calculate the derivatives of L1(U,\u0398) for GMMs and movMFs.\n4.1 Dealing with the penalty term D(U)\nFollowing [4], the gradients of the penalty term D(U) with respect to each row vector, ui (i = 1, \u00b7 \u00b7 \u00b7 ,M), can be easily derived as follows:\n\u2202D(U) \u2202ui = M\u2211 j=1 gij \u00b7 [ uj ui \u00b7 uj \u2212 ui ui \u00b7 ui ] (16)\nwhere gij denotes the absolute cosine value of the angle between two row vectors, ui and uj , computed as follows:\ngij = |ui \u00b7 uj | |ui| \u00b7 |uj | . (17)\nThe above derivatives can be equivalently represented as the following matrix form:\n\u2202D(U) \u2202U = (D\u2212B)U (18)\nwhere D is an M \u00d7M matrix, with its elements computed as dij = sign(ui\u00b7uj)|ui|\u00b7|uj | (1 \u2264 i, j \u2264 M),\nand B is an M \u00d7M diagonal matrix, with its diagonal elements computed as bii = \u2211\nj=1 gij ui\u00b7ui (1 \u2264\ni \u2264M)."}, {"heading": "4.2 Dealing with the noise model term L2", "text": "The log-likelihood function related to the noise model, L2(U, \u03c3), can be expressed as:\nL2(U, \u03c3) = \u2212 N(D \u2212M) 2 ln(\u03c32)\u2212 1 2\u03c32 N\u2211 n=1 nTnnn. (19)\nAnd we have:\nnTnnn = (xn \u2212UT zn)T (xn \u2212UT zn) = (xn \u2212UTUxn)T (xn \u2212UTUxn) = xTnxn \u2212 2xTnUTUxn + xTnUTUUTUxn (20)\nTherefore, L2(U, \u03c3) can be expressed as:\nL2(U, \u03c3) = \u2212 N(D \u2212M) 2 ln(\u03c32)\u2212 1 2\u03c32 N\u2211 n=1 [ xTnxn \u2212 2xTnUTUxn + xTnUTUUTUxn ] (21)\nThe gradient with respect to U 3 can be derived as follows:\n\u2202L2(U, \u03c3) \u2202U = 1 \u03c32 N\u2211 n=1 [ 2Uxnx T n \u2212UUTUxnxTn \u2212UxnxTnUTU ]\n= 1\n\u03c32 N\u2211 n=1 U [ xn(x\u0304n) T + x\u0304n(xn) T ] . (22)\nFor the noise variance \u03c32, we can easily derive the following closed-form update formula by vanishing its derivative to zero:\n\u03c32 = 1\nN(D \u2212M) N\u2211 n=1 nTnnn (23)\nAs long as the learned noise variance \u03c32 is small enough, maximizing the above term L2 will force all signal dimensions into the projection matrix U and only the residual noises will be modelled by L2."}, {"heading": "4.3 Computing L1 for GMMs", "text": "In this section, we consider how to compute the partial derivatives of L1(U,\u0398) for GMMs. Assume each mini-batch X consists of a small subset of randomly selected training samples, X = {xn | n = 1, \u00b7 \u00b7 \u00b7 , N}, the log likelihood function of HOPE models with GMMs can be represented as follows:\nL1(U,\u0398) = N\u2211 n=1 ln [ K\u2211 k=1 \u03c0k \u00b7 N (Uxn | \u00b5k,\u03a3k) ] (24)\nThe partial derivative of L1(U,\u0398) w.r.t the mean vector, \u00b5k, of the k-th Gaussian component can be calculated as follows:\n\u2202L1(U,\u0398) \u2202\u00b5k = N\u2211 n=1 \u03b3k(zn) \u00b7 \u03a3\u22121k (zn \u2212 \u00b5k) (25)\nwhere zn = Uxn, and \u03b3k(zn) denotes the so-called occupancy statistics of the k-th Gaussian component, computed as \u03b3k(zn) = \u03c0kN (zn|\u00b5k,\u03a3k) K\u2211\nj=1 \u03c0jN (zn|\u00b5j ,\u03a3j)\n.\n3We may use the constraint UUT = I to significantly simplify the above derivation. However, that leads to a gradient computation strongly relying on the orthogonal constraint. Since we use SGD to iteratively optimize all model parameters, including U. We can not ensure UUT = I strictly holds anytime in the SGD process. Therefore, the simplified gradient usually yields poor convergence performance.\nThe partial derivative of L1(U,\u0398) w.r.t \u03c0k can be simply derived as follows:\n\u2202L1(U,\u0398) \u2202\u03c0k = N\u2211 n=1 \u03b3k(zn) \u03c0k (26)\nThe partial derivative of L1(U,\u0398) w.r.t the \u03a3k is computed as follows:\n\u2202L1(U,\u0398) \u2202\u03a3k = \u22121 2 N\u2211 n=1 \u03b3k(zn) [ \u03a3\u22121k \u2212 \u03a3 \u22121 k (zn \u2212 \u00b5k)(zn \u2212 \u00b5k) T\u03a3\u22121k ] . (27)\nWhen we use the above gradients to update Gaussian covariance matrices in SGD, we have to impose additional constraints to ensure all covariance matrices are positive semidefinite. However, if we adopt diagonal covariance matrices for all Gaussian components, these constraints can be implemented in a fairly simple way.\nFinally, the partial derivative of L1(U,\u0398) w.r.t the projection matrix U is computed as:\n\u2202L1(U,\u0398) \u2202U = N\u2211 n=1 K\u2211 k=1 \u03b3k(zn) \u00b7 \u03a3\u22121k (\u00b5k \u2212 zn)x T n . (28)"}, {"heading": "4.4 Computing L1 for movMFs", "text": "Similarly, we derive all partial derivatives of L1(U,\u0398) for mixtures of vMF (movMFs). In this case, given a mini-batch of training samples, X = {xn | n = 1, \u00b7 \u00b7 \u00b7 , N}, the log-likelihood function of the HOPE model with movMFs can be expressed as follows:\nL1(U,\u0398) = N\u2211 n=1 ln [ K\u2211 k=1 \u03c0k \u00b7 CM (|\u00b5k|) \u00b7 ezn\u00b7\u00b5k ]\n(29)\nwhere each zn must be normalized to be of unit length 4 as required by the vFM distribution as:\nz\u0303n = Uxn, zn = z\u0303n |z\u0303n| . (30)\nSimilar to the HOPE models with GMMs, we first define an occupancy statistic for k-th vMF component as:\n\u03b3k(zn) = \u03c0k \u00b7 CM (|\u00b5k|) \u00b7 ezn\u00b7\u00b5k\u2211K j=1 \u03c0j \u00b7 CM (|\u00b5j |) \u00b7 e zn\u00b7\u00b5j . (31)\nIn a similar way, we can derive the partial derivatives of L1(U,\u0398) with respect to \u03c0k,\u00b5k and U as follows:\n\u2202L1(U,\u0398) \u2202\u03c0k = N\u2211 n=1 \u03b3k(zn) \u03c0k (32)\n4In practice, we usually normalize all original data, xn, to be of unit length: |xn| = 1, prior to the HOPE model. In this case, as long as M is properly chosen to be large enough, the projection matrix U is always learned to extract from xn as much energy as possible. Therefore, this normalization step may be skipped because the norm of the projected zn is always very close to one even without normalization in this stage, i.e., |zn| = |z\u0303n| \u2248 1.\nAlgorithm 1 SGD-based Maximum Likelihood Learning Algorithm for HOPE\nrandomly initialize ui (i = 1, \u00b7 \u00b7 \u00b7 ,M), \u03c0k and \u03b8k (k = 1, \u00b7 \u00b7 \u00b7 ,K) for epoch = 1 to T do\nfor minibatch X in training set do U\u2190 U + \u00b7 ( \u2202L1(U,\u0398)\n\u2202U + \u2202L2(U,\u03c3) \u2202U \u2212 \u03b2 \u00b7 \u2202D(U) \u2202U ) \u03b8k \u2190 \u03b8k + \u00b7 \u2202L1(U,\u0398)\u2202\u03b8k (\u2200k) \u03c0k \u2190 \u03c0k + \u00b7 \u2202L1(U,\u0398)\u2202\u03c0k (\u2200k) \u03c32 \u2190 1N(D\u2212M) \u2211N n=1 n T nnn\n\u03c0k \u2190 \u03c0k\u2211 j \u03c0j\n(\u2200k) and ui \u2190 ui|ui| (\u2200i) end for\nend for\n\u2202L1(U,\u0398) \u2202\u00b5k = N\u2211 n=1 \u03b3k(zn) \u00b7 [ zn \u2212 \u00b5k |\u00b5k| \u00b7 IM/2(|\u00b5k|) IM/2\u22121(|\u00b5k|) ] (33)\n\u2202L1(U,\u0398) \u2202U = N\u2211 n=1 K\u2211 k=1 \u03b3k(zn) |z\u0303n| \u00b7 (I\u2212 znzTn )\u00b5kxTn (34)\nRefer to Appendix B for all details on how to derive the above derivatives for the movMF distributions. Moreover, when movMFs are used, we need some special treatments to compute the Bessel functions in vMF, i.e, Iv(\u00b7), as shown in eqs.(31) and (33). In this work, we adopt the numerical method in [1] to approximate the Bessel functions, refer to the Appendix C for the numerical details on this."}, {"heading": "4.5 The SGD-based Learning Algorithm", "text": "Because all mixture weights, \u03c0k (k = 1, \u00b7 \u00b7 \u00b7K), and all row vectors, ui (i = 1, \u00b7 \u00b7 \u00b7 ,M) of the projection matrix satisfy the constraints: \u2211K k \u03c0k = 1 and |uj | = 1 (\u2200j). During the SGD learning process, \u03c0k and ui must be normalized after each update as follows:\n\u03c0k \u2190 \u03c0k\u2211 j \u03c0j\n(35)\nui \u2190 ui |ui| . (36)\nFinally, we summarize the SGD algorithm to learn the HOPE models based on the maximum likelihood (ML) criterion in Algorithm 1."}, {"heading": "5 Learning Neural Networks as HOPE", "text": "As described above, the HOPE model may be used as a universal model for high-dimensional data. The HOPE model itself can be efficiently learned unsupervisedly from unlabelled data\nbased on the above-mentioned maximum likelihood criterion. Moreover, if data labels are available, a variety of discriminative training methods, such as those in [15,16], may be used to learn the HOPE model supervisedly based on some other discriminative learning criteria.\nMore interestingly, as we will elucidate here, there exists strong relationship between the HOPE models and neural networks (NNs). First of all, we will show that the HOPE models may be used as a new tool to probe the mechanism why NNs work so well in practice. Under the new HOPE framework, we may explain why NNs can almost universally excel on a variety of data types and how NNs can handle various types of highly-correlated high-dimensional data, which may be quite challenging to many other machine learning models. Secondly, more importantly, the HOPE framework provides us with some new approaches to learn NNs: (i) Unsupervised learning: the maximum likelihood estimation of HOPE may be directly applied to learn NNs from unlabelled data; (ii) Supervised learning: the HOPE framework can be incorporated into the normal supervised learning of NNs by explicitly imposing some orthogonal constraints in learning. This may improve the learning of NNs and yield better and more compact models. Moreover, under the HOPE framework, we can even directly learn some shallow neural nets that work almost as well as the popular deep models."}, {"heading": "5.1 Linking HOPE to Neural Networks", "text": "A HOPE model normally consists of two stages: i) a linear orthogonal projection from the raw data space to the latent feature space; ii) a generative model defined as a finite mixture model in the latent feature. As a result, we may depict every HOPE model as a two-layer network: a linear projection layer and a nonlinear model layer, as shown in Figure 1 (a). The first layer represents the linear orthogonal projection from x (x \u2208 RD) to z (z \u2208 RM ): z = Ux. The second layer represents the underlying finite mixture model in the feature space and each node in the model layer represents the log-likelihood value from one mixture component, i.e., ln fk(z|\u03b8k). Moreover, similar to neural networks, we may impose nonlinearity on all nodes in the model layer, e.g., \u03b7k = max(0, ln fk(z|\u03b8k)\u2212 \u03b5k), to eliminate those small log likelihood values below a given threshold, \u03b5k. Pruning these small log likelihood values does not affect the total likelihood from the mixture model (because it is always dominated by only a few components) while it may improve robustness since these small log-likelihood values may be very noisy. In this way, all rectified log likelihood values in the model layer, i.e., \u03b7k (1 \u2264 k \u2264 K), may be viewed as a sensory map in the latent feature space for each input, x. This sensory map may be viewed as a learned feature representation to feed to a softmax classifier to form a normal shallow neural network, or to another HOPE model to form a deep neural network.\nMoreover, since the projection layer is linear, it can be mathematically combined with the upper model layer to generate a single layer structure, as shown in Figure 1 (b). For example, if GMMs are used in HOPE, it is equivalent to a hidden layer in Radial basis function (RBF) networks. If movFMs are used in HOPE, it is equivalent to a hidden layer in normal rectified linear (ReLU) neural networks. And the weight matrix in the merged layer can be simply derived from the HOPE model parameters, U and \u0398. Take a HOPE model with movMFs as example, each weight vector in Figure 1 (b) may be computed as wk = U\nT\u00b5k and the bias in each hidden node is computed as bk = ln\u03c0k + ln CM (|\u00b5k|) \u2212 \u03b5k. The formulation in Figure 1 (a) helps to explain the underlying mechanism how neural networks work. Under the HOPE framework, it becomes clear that each hidden layer in neural networks actually perform two different tasks\nimplicitly, namely feature extraction and data modelling. This has solved the puzzle why neural nets can directly deal with various types of highly-correlated high-dimensional data [22] without any explicit dimension reduction and feature de-correlation steps.\nEven though the linear projection layer may be merged with the model layer after all model parameters are learned, however, it may be beneficial to keep them separate during the model learning process. In this way, the model capacity may be controlled by two distinct control parameters: i) M can be selected properly to filter out noise components as in eq.(2) to prevent overfitting in learning; ii) K may be chosen independently to ensure the model is complex enough to model very big data sets for more difficult tasks. Moreover, we may enforce the orthogonal constraint, i.e., UUT = I, during the model learning to ensure that all dimensions of z are uncorrelated in the latent feature space, which may significantly simplify the density estimation in the feature space using a finite mixture model.\nBased on the above discussion, a HOPE model is mathematically equivalent to a hidden layer in neural networks. Under this formulation, it is clear that any neural network can be trained under the HOPE framework. There are several advantages to learn neural networks under the HOPE framework. First of all, the modelling capacity of neural networks may be explicitly controlled by selecting proper values for M and K, each of which is chosen for a different purpose. Secondly, we can easily apply the maximum likelihood estimation of HOPE models in section 4 to unsupervised or semi-supervised learning to learn NNs from un-labeled data. Thirdly, the useful orthogonal constraints may be incorporated into the normal back-propagation process to learn better NN models in supervised learning as well."}, {"heading": "5.2 Unsupervised Learning of Neural Networks as HOPE", "text": "The maximum likelihood estimation method for HOPE in section 4 can be used to learn neural networks layer by layer in an unsupervised learning mode. All HOPE model parameters in Figure 1 (a) are first estimated based on the maximum likelihood criterion as in section 4. Next, the two layers in the HOPE model are merged to form a regular NN hidden layer as in Figure 1 (b). In this case, class labels are not required to learn all network weights and neural networks can be learned from un-labelled data under a theoretically solid framework. This is similar to\nthe Hebbian style learning [23] but it has a well-founded and converging objective function in learning. Next, the rectified log-likelihood values from the HOPE model, i.e., \u03b7k (1 \u2264 k \u2264 K), may be viewed as a sensory map in the latent feature space, which may serve as a good feature representation of the original data. At the end, a small amount of labelled data may be used to learn a simple classifier, either a softmax layer or a linear support vector machine (SVM), on the top of the HOPE layers, which takes the sensory map as input for final classification or prediction.\nIn unsupervised learning, the learned orthogonal projection matrix U may be viewed as a generalized PCA, which performs dimension reduction by considering the complex distribution in the latent feature space modelled by a finite mixture model."}, {"heading": "5.3 Supervised Learning of Neural Networks as HOPE", "text": "The HOPE framework can also be applied to the supervised learning of neural networks when data labels are available. Take rectified linear (ReLU) neural networks as example, each hidden layer in a ReLU neural network, as shown in Figure 1 (b), is viewed as a HOPE model and thus it can be decomposed as a combination of a projection layer and a model layer, as shown in Figure 1 (a). In this case, M needs to be chosen properly to avoid overfitting. In other words, each hidden layer in ReLU NNs is represented as two layers during learning, namely a linear projection layer and a nonlinear model layer. If data labels are available, we may use the standard minimum cross-entropy error criterion instead of the maximum likelihood criterion. The standard backpropagation algorithm may be used to learn all decomposed HOPE model parameters. The only difference is that the orthogonal constraints, as in eq.(13), must be imposed for all projection layers during training, where the derivatives in eq.(18) must be incorporated in the standard back-propagation process to update each project matrix U to ensure it is orthonormal. After the learning, each pair of projection and model layers can be merged into a single hidden layer. After merging, the resultant network remains the exactly same network structure as normal ReLU neural networks.\nIn supervised learning, the learned orthogonal projection matrix U may be viewed as a generalized LDA or HDA [18], which optimizes the data projection to maximize (or minimize) the underlying discriminative learning criterion."}, {"heading": "5.4 HOPE for Deep Learning", "text": "As above, the HOPE framework can be used to learn rather strong shallow NN models. However, this does not hinder HOPE from building deeper models for deep learning. As shown in Figure 2, we may have two different structures to learn very deep neural networks under the HOPE framework. In Figure 2 (a), one HOPE model is used as the first layer primarily for feature extraction and a deep neural network is concatenated on top of it as a powerful classifier to form a deep structure. The deep model in Figure 2 (a) may be learned in either supervised or semiunsupervised mode. In semi-unsupervised learning, the HOPE model is learned based on the maximum likelihood estimation and the upper deep NN is learned supervisedly. Alternatively, if we have enough labelled data, we may jointly learn both HOPE and DNN in a supervised mode. In Figure 2 (b), we may even stack multiple HOPE models to form another deep model structure. In this case, each HOPE model generates a sensory feature map in each HOPE\nlayer. Just like a normal image, this sensory feature map is normally highly correlated. Thus, it makes sense to add another HOPE model on top of it to de-correlate features and perform date modelling at finer granularity. The deep HOPE model structures in Figure 2 (b) can also be learned in either supervised or unsupervised mode. In unsupervised learning, these HOPE layers are learned layer-wise using the maximum likelihood estimation. In supervised learning, all HOPE layers are learned in back-propagation with orthonormal constraints being imposed to all projection layers."}, {"heading": "6 Experiments", "text": "In this section, we will investigate the proposed HOPE framework in learning neural networks for several standard image and speech recognition tasks under several different learning conditions: i) unsupervised feature learning; ii) supervised learning; iii) semi-supervised learning. The examined tasks include the image recognition tasks using the MNIST data set, and the speech recognition task using the TIMIT data set."}, {"heading": "6.1 MNIST: Image Recognition", "text": "The MNIST data set [19] consists of 28 \u00d7 28 pixel greyscale images of handwritten digits 0- 9, with 60,000 training and 10,000 test examples. In our experiments, we first evaluate the performance of unsupervised feature learning using the HOPE model with movMFs. Secondly, we investigate the performance of supervised learning of DNNs under the HOPE framework, and further study the effect of the orthogonal constraint in the HOPE framework. Finally, we consider a semi-supervised learning scenario with the HOPE models, where all training samples (without labels) are used to learn feature representation unsupervisedly and then a portion of training data (along with labels) is used to learn post-stage classification models supervisedly."}, {"heading": "6.1.1 Unsupervised Feature Learning on MNIST", "text": "In this experiment, we first randomly extract many small patches from the original unlabelled training images on MNIST. Each patch is of 6-by-6 in dimension, represented as a vector in RD, with D = 36. In this work, we randomly extract 400,000 patches in total from the MNIST training set for unsupervised feature learning. Moreover, every patch is normalized by subtracting the mean and being divided by the standard deviation of its elements.\nIn the unsupervised feature learning, we follow the same experimental setting in [9], where an unsupervised learning algorithm is used to learn a \u201cblack box\u201d feature extractor to map each input vector in RD to another K-dimension feature vector. In this work, we have examined several different unsupervised learning algorithms for feature learning: (i) kmeans clustering; (ii) spherical kmeans (spkmeans) clustering; (iii) mixture of vMF (movMF), (iv) PCA based dimension reduction plus movMF (PCA-movMF); and (v) the HOPE model with movMFs (HOPE-movMF). As for kmeans and spkmeans, the only difference is different distance measures are used in clustering: kmeans uses the Euclidean distance while spkmeans uses the cosine distance. As for the movMF model, we can use the expectation maximization (EM) algorithm for estimation, as described in [3]. In the following, we briefly summarize the experimental details for these feature extractors.\n1. kmeans: We first apply the k-means clustering method to learn K centroids \u00b5k from all extracted patch input vectors. For each learned centroid \u00b5k, we use a soft threshold function to compute each feature as: fk(x) = max(0, |x \u2212 \u00b5k| \u2212 \u03b5), where \u03b5 is a pre-set threshold. In this way, we may generate a K-dimension feature vector for each patch input vector.\n2. spkmeans: As for the spk-means clustering, we need to normalize all input patch vectors to be of unit length before clustering them into K different centroids based on the cosine distance measure. Given each learned centroid \u00b5k, we can compute each feature as fk(x) = max(0,xT\u00b5k \u2212 \u03b5).\n3. movMF: We also need to normalize all input patch vectors to be of unit length. We use the EM algorithm to learn all model parameters \u00b5k. For each learned centroid \u00b5k of the movMF model, we compute one feature as fk(x) = max ( 0, ln(\u03c0k)+ln(CN (|\u00b5k|))+xT\u00b5k\u2212\n\u03b5 ) .\n4. PCA-movMF: Comparing to movMF, the only difference is that we first use PCA for dimension reduction, reducing all input patch vectors from RD to RM . Then, we use the same method to estimate an movMF model for the reduced D-dimension feature vectors. In this experiment, we set M = 20 to reserve 99.5% of the total sum of all eigenvalues in PCA. For each learned vMF model \u00b5k, we compute one feature as fk(x) = max ( 0, ln(\u03c0k) + ln(CN (|\u00b5k|)) + zT\u00b5k \u2212 \u03b5 ) .\n5. HOPE-movMF: We use the maximum likelihood estimation method described in section 4 to learn a HOPE model with movMFs. For each learned vMF component, we can compute one feature as fk(x) = max(0, ln(\u03c0k) + ln(CM (|\u00b5k|)) + z\u0303 \u00b7 \u00b5k \u2212 \u03b5). Similar to PCA-movMF, we also set M = 20 here.\nFurthermore, since HOPE-movMF is learned using SGD, we need to tune some hyper-parameters for HOPE, such as learning rate, mini-batch size, \u03b2 and \u03c32. In this work, the learning rate is set to 0.002, minibatch size is set to 100, we set \u03b2 = 1.0, and the noise variance is manually set to \u03c32 = 0.1 for convenience.\nAfter learning the above models, they are used as feature extractors. We use the same method as described in [9] to generate a feature representation for each MNIST image, where each feature extractor is convolving over an MNIST image to obtain the feature representations for all local patches in the image. Next, we split the image into four equally-sized quadrants and the feature vectors in each quadrant are all summed up to pool as one feature vector. In this way, we can get a 4K-dimensional feature vector for each MNIST image, where K is the number of all learned features for each patch. Finally, we use these pooled 4K-dimension feature vectors for all training images, along with the labels, to estimate a simple linear SVM as a post-stage classifier for image classification. The experimental results are shown in Table 1. We can see that spkmeans and movMF can achieve much better performance than kmeans. The PCA-based dimension reduction leads to further performance gain. Finally, the jointly trained HOME model with movMFs yields the best performance, e.g., 0.64% in classification error rate when K = 1200."}, {"heading": "6.1.2 Supervised Learning of Neural Networks as HOPE on MNIST", "text": "In this experiment, we use the MNIST data set to examine the supervised learning of rectified linear (ReLU) neural networks under the HOPE framework, as discussed in section 5.3.\nHere we follow the normalized initialization in [10] to randomly initialize all NN weights, without using pre-training. We adopt a small modification to the method in [10] by adding a factor to control the dynamic range of initial weights as follows:\nWi \u223c [ \u2212 \u03b3 \u00b7 \u221a 6\u221a\nni + ni+1 , \u03b3 \u00b7\n\u221a 6\u221a\nni + ni+1\n] (37)\nwhere ni denotes the number of units in the i-th layer. For the ReLU units, due to the unbounded behaviour of the activation function, activations of ReLU units might grow without limit. To handle this numerical problem, we shrink the dynamic range of initial weights by using a small factor \u03b3 (\u03b3 = 0.5), which is equivalent to scaling the activations.\nWe use SGD to train ReLU neural networks using the following learning schedule:\nt = 0 \u00b7 \u03b1t (38)\nmt =\n{ t Tmf + (1\u2212 t T )mi t < T\nmf t \u2265 T (39)\nwhere t and mt denote the learning rate and momentum for the t-th epoch, and we set all control parameters as mi = 0.5,mf = 0.99, \u03b1 = 0.998. We totally run T = 50 epochs for learning without dropout and run T = 500 epochs for learning with dropout. Moreover, the weight decay is used here and it is set to 0.00001. Furthermore, for the HOPE model, the control parameter for the orthogonal constraint, \u03b2, is set to 0.01 in all experiments. In this work, we do not use any data augmentation method.\nUnder the HOPE framework, we decompose each ReLU hidden layer into two layers as in Figure 1 (a). In this experiment, we first examine the supervised learning of NNs with or without imposing the orthogonal constraints to all projection layers. Firstly, we investigate the performance of a neural network containing only a single hidden layer, decomposed into a pair of a linear projection layer and a nonlinear model layer. Here we evaluate neural networks with a different number of hidden units (K) and a varying size of the projection layer (M). From the experimental results shown in Table. 2, we can see that the HOPE-trained NN can achieve much better performance than the baseline NN, especially when smaller values are used for M . This supports that the projection layer may eliminate residual noises in data to avoid over-fitting when M is properly set. However, after we relax the orthogonal constraint in the HOPE model, as shown in Table 2, the performance of the models using only linear projection layers gets much worse than those of the HOPE models as well as that of the baseline NN. These results verify that orthogonal projection layers are critical in the HOPE models. Furthermore, in Figure. 3, we have plotted the learning curves of the total sum of all correlation coefficients\namong all row vectors in the learned projection matrix U, i.e., \u2211\ni\u2264j |ui\u00b7uj | |ui||uj | . We can see that\nall the projection vectors tend to get strongly correlated (especially when M is large) in the linear projection matrix as the learning goes. On the other hand, the orthogonal constraint can effectively de-correlate all the projection vectors. Moreover, we show all correlation coefficients, i.e., |ui\u00b7uj | |ui||uj | , of the linear projection matrix and the HOPE orthogonal projection matrix as two images in Figure 4, which clearly shows that the linear projection matrix has many strongly correlated dimensions and the HOPE projection matrix is (as expected) orthogonal .\nAs the MNIST training set is very small, we further use the dropout technique in [14] to improve the model learning on the MNIST task. In this experiment, the visible dropout probability is set to 20% and the hidden layer dropout probability is set to 30%. In Table 3, we compare a 1-hidden-layer shallow NN with two HOPE models (M=200,400). The results show that the HOPE framework can significantly improve supervised learning of NNs. Under the HOPE framework, we can train very simple shallow neural networks from scratch, which can yield comparable performance as deep models. For example, on the MNIST task, as shown in Table 3, we may achieve 0.85% in classification error rate using a shallow neural network (with only one hidden layer of 2000 nodes) trained under the HOPE framework. Furthermore, we consider to build deeper models (two-hidden-layer NNs) under the HOPE framework. Using the two different structures in Figure 2, we can further improve the classification error rate to 0.81%, as shown in Table. 4. To the best of our knowledge, this is one of the best results reported on MNIST without using CNNs and data augmentation."}, {"heading": "6.2 Semi-supervised Learning on MNIST", "text": "In this experiment, we combine the unsupervised feature learning with supervised model learning and examine the classification performance when only limited labelled data is available. Here we also list the results using convolutional deep belief networks (CDBN) in [20] as our baseline system. In our experiments, we use the raw pixel features and unsupervised learned (USL) features in section 6.1.1. As example, we choose the unsupervised learned features from the HOPE-movMF model (K = 800) in Table 15. Next, we concatenate a post-stage classifier, which is supervisedly trained using only a portion of the training data, ranging from 1000 to 60000 (all). We consider many different types of classifiers here, including linear SVM, regular DNNs and HOPE-trained DNNs. Note that all classifiers are trained separately from the feature learning. All results are summarized in Table 5. It shows that we can achieve the best performance when we combine the HOPE-trained USL features with HOPE-trained poststage classifiers. The gains are quite dramatic no matter how much labelled data is used. For example, when only 5000 labelled samples are used, our method can achieve 0.90% in error rate, which significantly outperforms all other methods including CDBN in [20]. At last, as we use all training data for the HOPE model, we can achieve 0.40% in error rate. This is the best result reported on MNIST without using data augmentation. Furthermore, our best system uses a quite simple model structure, consisting of a HOPE-trained feature extraction layer of 800 nodes and a HOPE-trained NN of two hidden layers (1200 node in each layer), which is much smaller and simpler than those top-performing systems on MNIST."}, {"heading": "6.3 TIMIT: Speech Recognition", "text": "In this experiment, we examine the supervised learning of shallow and deep neural networks under the HOPE framework for a standard speech recognition task using the TIMIT data set.\n5For the HOPE-movMF model with K = 800, there are 115 empty clusters. Thus, the unsupervised learned features are of 2740 in dimension.\nThe HOPE-based supervised learning method is compared with the regular back-propagation training method. We use the minimum cross-entropy learning criterion here.\nThe TIMIT speech corpus consists of a training set of 462 speakers, a separate development set of 50 speakers for cross-validation, and a core test set of 24 speakers. All results are reported on the 24-speaker core test set. The speech waveform data is analyzed using a 25-ms Hamming window with a 10-ms fixed frame rate. The speech feature vector is generated by a Fouriertransform-based filter-banks that include 40 coefficients distributed on the Mel scale and energy, along with their first and second temporal derivatives. This leads to a 123-dimension feature vector per speech frame. We further concatenate 15 consecutive frames within a long context window of (7+1+7) to feed to the models, as a 1845-dimension input vector [28]. All speech data are normalized by subtracting the mean of the training set and being divided by the standard deviation of the training set on each dimension so that all input vectors have zero mean and unit variance. We use 183 target class labels (i.e., 3 states for each of the 61 phones) for the DNN training. After decoding, these 61 phone classes are mapped to a set of 39 classes for the final scoring as in [21]. In our experiments, a bi-gram language model at phone level, estimated from all transcripts in the training set, is used for speech recognition.\nWe first train ReLUs based shallow and deep neural networks as our baseline systems. The networks are trained using the back-propagation algorithm, with a mini-batch size of 100. The initial learn rate is set to 0.004 and it is kept unchanged if the error rate on the development is still decreasing. Afterwards, the learning rate is halved after every epoch, and the whole training procedure is stopped when the error reduction in the development set is less than 0.1% in two consecutive iterations. In our experiments, we also use momentum and weight decay, which are set to 0.9 and 0.0001, respectively. When we use the mini-batch SGD to train neural networks under the HOPE framework, the control parameter for the orthogonal constraints, i.e. \u03b2, is set to be 0.01.\nIn our experiments, we compare the standard NNs with the HOPE-trained NNs for two network architectures, one shallow network with one hidden layer of 10240 hidden nodes and one deep network with 3 hidden layers of 2048 nodes. The performance comparison between them is shown in Table. 6. From the results, we can see that the HOPE-trained NNs can consistently outperform the regular NNs by an about 0.8% absolute reduction in phone recognition error rates. Moreover, the HOPE-trained neural networks are much smaller than their counterpart DNNs in number of model parameters if the HOPE layers are not merged. After merging, they have the exactly the same model structure as their counterpart DNNs."}, {"heading": "7 Final Remarks", "text": "In this paper, we have proposed a universal model, called hybrid orthogonal projection and estimation (HOPE), for high-dimensional data. The HOPE model combines feature extraction and data modelling under a unified generative modelling framework so that both feature extractor and data model can be jointly learned either supervisedly or unsupervisedly. More interestingly, we have shown that the HOPE models are closely related to neural networks in a way that each hidden layer in NNs can be reformulated as a HOPE model. Therefore, the proposed HOPE related learning algorithms can be easily applied to perform either supervised or unsupervised learning for neural networks. We have evaluated the proposed HOPE models in learning NNs on several standard tasks, including image recognition on MNIST and speech recognition on TIMIT. Experimental results have strongly supported that the HOPE models can provide a very effective unsupervised learning method for NNs. Meanwhile, the supervised learning of NNs can also be conducted under the HOPE framework, which normally yields better performance and more compact models.\nWe are currently investigating the HOPE model to learn convolution neural networks (CNNs) for more difficult image recognition tasks, such as CIFAR-100 or ImageNet. At the same time, we are also examining the HOPE-based supervised learning for large-scale speech recognition tasks, like Switchboard. These results will be reported shortly."}, {"heading": "A Learning HOPE when U\u0302 is not orthonormal", "text": "In some tasks, in additional to dimension reduction, we may want to use the projection matrix U to perform signal whitening to ensure the signal projection z has roughly the same variance along all dimensions. This has been shown to be quite important for many image recognition and speech recognition tasks. In this case, we may still want to impose the orthogonal constraints among all row vectors of U, i.e., ui \u00b7uj = 0 (i, j = 1, \u00b7 \u00b7 \u00b7 ,M, i 6= j), but these row vectors may not be of unit length, i.e., |ui| \u2265 1 (i = 1, \u00b7 \u00b7 \u00b7 ,M). Moreover, it is better not to whiten the residual noises in the remaining D \u2212M dimensions to amplify them unnecessarily. Therefore, we still enforce the unit-length constraints for the matrix V, i.e., |ui| = 1 (i = M + 1, \u00b7 \u00b7 \u00b7 , D). Because U is not orthonormal anymore, when we compute the likelihood function of the original data in eq.(11) for HOPE, we have to include the Jacobian term as follows:\nL(U,\u0398, \u03c3 | X) = N\u2211 n=1 ln Pr(xn) = N\u2211 n=1 [ ln |U\u0302\u22121|+ ln Pr(zn) + ln Pr(nn) ]\n= N \u00b7 ln |U\u0302\u22121|\ufe38 \ufe37\ufe37 \ufe38 J (U) + N\u2211 n=1 ln ( K\u2211 k=1 \u03c0k \u00b7 fk(Uxn|\u03b8k) ) \ufe38 \ufe37\ufe37 \ufe38\nL1(U,\u0398)\n+ N\u2211 n=1 ln ( N ( nn |0, \u03c32I )) \ufe38 \ufe37\ufe37 \ufe38\nL2(U,\u03c3)\n(40)\nBecause UUT 6= I here, we have\nxn = U T (UUT )\u22121zn + V Tnn (41)\nand then we have\nxTnxn = ( nTnV + z T n (UU T )\u22121U )( VTnn + U T (UUT )\u22121zn ) = nTnnn + z T n (UU T )\u22121zn = n T nnn + x T nU T (UUT )\u22121Uxn (42)\nTherefore, we may derive the residual noise energy as:\nnTnnn = x T nxn \u2212 xTnUT (UUT )\u22121Uxn\n= xTn\n[ I\u2212UT (UUT )\u22121U ] xn (43)\nIn this case, L2(U, \u03c3) can be expressed as:\nL2(U, \u03c3) = \u2212 N 2 ln(\u03c32)\u2212 1 2\u03c32 N\u2211 n=1 [ xTnxn \u2212 xTnUT (UUT )\u22121Uxn ] (44)\nTherefore, its gradient with respect to U, can be derived as follows:\n\u2202L2(U, \u03c3) \u2202U = 1 \u03c32 N\u2211 n=1 [ (UUT )\u22121Uxnx T n \u2212 (UUT )\u22121UxnxTnUT (UUT )\u22121U ]\n= 1\n\u03c32 N\u2211 n=1 (UUT )\u22121Uxnx T n [ I\u2212UT (UUT )\u22121U ] (45)\nNext, we consider the Jacobian term, J (U), which can be computed as follows:\nJ (U) = N \u00b7 ln |U\u0302\u22121| = \u2212N M\u2211 i=1 ln |ui| (46)\nBecause of \u2202J (U)\u2202ui = \u2212 N \u00b7ui |ui|2 (i = 1, \u00b7 \u00b7 \u00b7 ,M), it is easy to show that its derivative with respect\nto U can be derived as: \u2202J (U) \u2202U\n= \u2212N \u00b7 ( UUT )\u22121 U. (47)\nSimilarly, the HOPE parameters, i.e., U, \u0398 and \u03c3, can be estimated by maximizing the above likelihood function as follows:\n{U\u2217,\u0398\u2217, \u03c3\u2217} = arg maxU,\u0398,\u03c3 L(U,\u0398, \u03c3 | X) (48)\nsubject to an orthogonal constraint: UUT = \u03a6, (49)\nwhere \u03a6 is a diagonal matrix. The above constraint can also be implemented as an penalty term similar to eq.(15). However, the norm of each row vector is relaxed as follows:\n|ui| \u2265 1 (i = 1, \u00b7 \u00b7 \u00b7 ,M) (50)\nThe log-likelihood function related to the signal model, L1(U,\u0398), and signal variance, \u03c32, are calculated in the same way as before."}, {"heading": "B Derivatives of movMFs", "text": "The partial derivatives of the objective function in eq.(29) w.r.t all \u00b5k can be computed as follows:\n\u2202L1(U,\u0398) \u2202\u00b5k = N\u2211 n=1\n\u03c0k \u00b7 ( C\u2032M (|\u00b5k|) \u2202\u03bak \u00b5k \u00b7 ezTn \u00b7\u00b5k + CM (|\u00b5k|) \u00b7 ez T n \u00b7\u00b5k \u00b7 zn ) \u2211K\nj=1 \u03c0j \u00b7 CM (|\u00b5j |) \u00b7 e z\u00b7\u00b5j\n(51)\nwhere we have \u2202 |\u00b5k| \u2202\u00b5k = \u00b5k |\u00b5k| . (52)\nAs to C\u2032M (\u03ba), for brevity, let us denote s = M 2 \u2212 1, and \u03be = (2\u03c0) s+1.\nC\u2032M (\u03ba) = s \u00b7 \u03bas\u22121\n\u03beIs(\u03ba) \u2212 \u03ba s \u00b7 I \u2032s(\u03ba) \u03beIs 2(\u03ba) = \u03bas \u03beIs(\u03ba)\n( s\n\u03ba \u2212 I\n\u2032 s(\u03ba) Is(\u03ba) ) = CM (\u03ba) \u00b7 ( s\n\u03ba \u2212 I\n\u2032 s(\u03ba) Is(\u03ba) ) (53) where Iv(\u00b7) denotes the Bessel function of the first kind at the order v. Because we have\n\u03baIs+1(\u03ba) = \u03baI \u2032 s(\u03ba)\u2212 sIs(\u03ba)\u21d2\ns \u03ba \u2212 I\n\u2032 s(\u03ba)\nIs(\u03ba) = \u2212Is+1(\u03ba) Is(\u03ba)\nThus, we may derive\nC\u2032M (\u03ba) = \u2212CM (\u03ba) \u00b7 Is+1(\u03ba)\nIs(\u03ba) (54)\nSubstituting eq. (52) and eq. (54) into eq. (51), we obtain the partial derivative of the objective function in eq. (29) w.r.t \u00b5k as follows:\n\u2202L1(U,\u0398) \u2202\u00b5k = N\u2211 n=1\n\u03c0k \u00b7 CM (|\u00b5k|) \u00b7 ezn\u00b7\u00b5k ( zn \u2212 \u00b5k|\u00b5k| \u00b7 IM/2(|\u00b5k|) IM/2\u22121(|\u00b5k|) ) \u2211K\nj=1 \u03c0j \u00b7 CM(|\u00b5j |) \u00b7 e zn\u00b7\u00b5j\n= N\u2211 n=1 \u03b3(znk) \u00b7 ( zn \u2212 \u00b5k |\u00b5k| \u00b7 IM/2(|\u00b5k|) IM/2\u22121(|\u00b5k|) ) (55)\nwhere \u03b3(znk) = \u03c0k\u00b7CM (|\u00b5k|)\u00b7ezn\u00b7\u00b5k\u2211K j=1 \u03c0j \u00b7CM (|\u00b5j |)\u00b7e zn\u00b7\u00b5j is the occupancy statistics of k-th component of zn.\nNext, let us consider the partial derivative of the objective function in eq.(29) w.r.t U. Based on the chain rule, we have\n\u2202L1(U,\u0398) \u2202U = \u2202L1(U,\u0398) \u2202z\u0303n \u00b7 \u2202z\u0303n \u2202U = ( \u2202zTn \u2202z\u0303n \u00b7 \u2202L1(U,\u0398) \u2202zn ) \u00b7 \u2202z\u0303n \u2202U\n(56)\nFurthermore, we may derive\n\u2202L1(U,\u0398) \u2202zn = N\u2211 n=1 K\u2211 k=1 \u03c0k \u00b7 CM (|\u00b5k|) \u00b7 ezn\u00b7\u00b5k\u2211K j=1 \u03c0j \u00b7 CM (|\u00b5j |) \u00b7 e zn\u00b7\u00b5j \u00b7 \u00b5k = N\u2211 n=1 K\u2211 k=1 \u03b3(znk) \u00b7 \u00b5k (57)\n\u2202zTn \u2202z\u0303n = \u2202(z\u0303Tn/|z\u0303n|) \u2202z\u0303n = 1 |z\u0303n|2 ( \u2202z\u0303Tn \u2202z\u0303n |z\u0303n| \u2212 \u2202|z\u0303n| \u2202z\u0303n z\u0303Tn ) = 1\n|z\u0303n|\n( I\u2212 z\u0303nz\u0303 T n\n|z\u0303n|2\n) = 1\n|z\u0303n|\n( I\u2212 znzTn ) (58) Substituting eq.(57) and eq. (58) into eq. (56), we can obtain\n\u2202L1(U,\u0398) \u2202U = N\u2211 n=1 K\u2211 k=1 \u03b3(znk) |z\u0303n| (I\u2212 znzTn )\u00b5kxTn (59)"}, {"heading": "C Numerical Methods for Iv(\u00b7)", "text": "In the learning algorithm for movMFs, we may need to compute the Bessel functions, Iv(\u00b7), in several places. First of all, we need to compute the normalization term CM (\u03ba) when calculating the likelihood function of a vMF distribution as in eq.(9). Secondly, we need to calculate the rations of the modified Bessel functions, Ad(\u03ba) = IM/2(\u03ba)\nIM/2\u22121(\u03ba) , in eq.(55). As we know, the modified\nBessel functions of the first kind take the following form:\nId(\u03ba) = \u2211 k\u22650\n1 \u0393(d+ 1 + k)k! ( \u03ba 2 )2k+d, (60)\nFrom eq. (60), we can see that when \u03ba d, Id(\u03ba) overflows quite rapidly. Meanwhile, when \u03ba = o(d) and d \u2192 \u221e, Id(\u03ba) underflows quite rapidly. In this work, we use the approximation strategy in eq. (9.7.7) on page 378 of [1] as follows:\nId(\u03ba) \u223c 1\u221a 2\u03c0d \u00b7 e\nd\u03b7 (1 + (\u03bad ) 1/4) \u00b7 [ 1 + \u221e\u2211 k=1 uk(t) dk ] (61)\nwhere we have\nt = 1\u221a\n1 + (\u03ba/d)2 (62)\n\u03b7 = \u221a 1 + (\u03ba/d)2 + ln \u03ba/d\n1 + \u221a 1 + (\u03ba/d)2 (63)\nwith the functions uk(t) taking the following forms:\nu0(t) = 1 u1(t) = (3t\u2212 5t3)/24 u2(t) = (81t 2 \u2212 462t4 + 385t6)/1152\nRefer to page 366 of [1] for other higher orders uk(t). Usually, the term [1 + \u2211\u221e\nk=1 uk(t) dk\n] in eq.(61) is very small and it is safe to eliminate it from evaluation in most cases. Then, after substituting eq.(62) and eq.(63) into eq.(61), the logarithm of the approximated modified Bessel function is finally computed as follows:\nln Id(\u03ba) = \u2212 ln \u221a 1 + (\u03ba/d)2 +d \u00b7 (\u221a 1 + (\u03ba/d)2 +ln \u03ba\nd \u2212 ln\n\u221a 1 + (\u03ba/d)2)\u2212 1\n4 ln(1+(\n\u03ba d )2 ) (64)\nIn this work, the approximation in eq.(64) is used to compute all Bessel functions in the learning algorithms for movMFs."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "In this paper, we propose a universal model for high-dimensional data, called the Hybrid Orthogonal Projection and Estimation (HOPE) model, which combines a linear orthogonal projection and a finite mixture model under a unified generative modelling framework. The HOPE model itself can be learned unsupervisedly from un-labelled data based on the maximum likelihood estimation as well as trained discriminatively from labelled data. More interestingly, we have shown the proposed HOPE models are closely related to neural networks (NNs) in a sense that each hidden layer can be reformulated as a HOPE model. As a result, the HOPE framework can be used as a novel tool to probe why and how NNs work, more importantly, it also provides several new learning algorithms to learn NNs either supervisedly or unsupervisedly. In this work, we have investigated the HOPE framework in learning NNs for several standard tasks, including image recognition on MNIST and speech recognition on TIMIT. Experimental results show that the HOPE framework yields significant performance gains over the current stateof-the-art methods in various types of NN learning problems, including unsupervised feature learning, supervised or semi-supervised learning.", "creator": "LaTeX with hyperref package"}}}