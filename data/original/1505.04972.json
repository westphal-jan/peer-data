{"id": "1505.04972", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-May-2015", "title": "Recursion in RDF Data Shape Languages", "abstract": "An RDF data shape is a description of the expected contents of an RDF document (aka graph) or dataset. A major part of this description is the set of constraints that the document or dataset is required to satisfy. W3C recently (2014) chartered the RDF Data Shapes Working Group to define SHACL, a standard RDF data shape language. We refer to the ability to name and reference shape language elements as recursion. This article provides a precise definition of the meaning of recursion as used in Resource Shape 2.0. The definition of recursion presented in this article is largely independent of language-specific details. We speculate that it also applies to ShEx and to all three of the current proposals for SHACL. In particular, recursion is not permitted in the SHACL-SPARQL proposal, but we conjecture that recursion could be added by using the definition proposed here as a top-level control structure.", "histories": [["v1", "Tue, 19 May 2015 12:45:59 GMT  (26kb)", "https://arxiv.org/abs/1505.04972v1", "23 pages, W3C RDF Data Shapes Working Group"], ["v2", "Sun, 1 Nov 2015 22:27:03 GMT  (96kb,D)", "http://arxiv.org/abs/1505.04972v2", "31 pages, 2 figures, invited expert contribution to the W3C RDF Data Shapes Working Group"]], "COMMENTS": "23 pages, W3C RDF Data Shapes Working Group", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["arthur ryman"], "accepted": false, "id": "1505.04972"}, "pdf": {"name": "1505.04972.pdf", "metadata": {"source": "CRF", "title": "Recursion in RDF Data Shape Languages", "authors": ["Arthur Ryman"], "emails": ["arthur.ryman@gmail.com"], "sections": [{"heading": "1 Introduction", "text": "An RDF data shape is a description of the expected contents of an RDF document (aka graph) or dataset. A major part of this description is the set of constraints that the document or dataset is required to satisfy. In this respect, data shapes do for RDF what XML Schema[6] does for XML. The term shape is used instead of schema to avoid confusion with RDF Schema[3] which, like OWL[9], describes inference rules, not constraints.\nW3C recently (2014) chartered the RDF Data Shapes Working Group to define SHACL, a standard RDF data shape language[8]. Both of the member submissions to this working group, Resource Shape 2.0[13] and Shape Expressions (ShEx) [15] allow shapes to refer to each other. For example, in Resource Shape 2.0 the property oslc:valueShape lets one resource shape refer to another. ShEx has a similar feature. In these languages, a shape may refer directly or indirectly to itself.\nWe refer to the ability to name and reference shape language elements as recursion in analogy with that ubiquitous feature of programming languages which allows a function to call other functions, including itself. Of course, when writing a recursive function care must be taken to ensure that recursion terminates. Similarly, when defining a shape language care must be taken to\nar X\niv :1\n50 5.\n04 97\n2v 2\n[ cs\n.D B\n] 1\nN ov\nspell out the precise meaning of recursion. Neither of the member submissions included a precise definition of recursion.\nThis article provides a precise definition of the meaning of recursion as used in Resource Shape 2.0. Precision is achieved through the use of Z Notation [16], a formal specification language based on typed set theory. The LATEX source for this article has been type-checked using the fuzz type-checker [17] and is available in the GitHub repository agryman:shape-recursion [14].\nThe definition of recursion presented in this article is largely independent of language-specific details. We speculate that it also applies to ShEx and to all three of the current proposals for SHACL. In particular, recursion is not permitted in the SHACL-SPARQL proposal [10], but we conjecture that recursion could be added by using the definition proposed here as a top-level control structure."}, {"heading": "1.1 Organization of this Article", "text": "The remainder of this article is organized as follows.\n\u2022 Section 2 introduces examples in order to ground the following definitions.\n\u2022 Section 3 defines a few basic RDF concepts.\n\u2022 Section 4 defines neighbour functions and graphs which form the basis for the following definition of recursion.\n\u2022 Section 5 defines constraints.\n\u2022 Section 6 defines recursive shapes.\n\u2022 Section 7 discusses how the proposed definition of recursion relates to the existing and proposed shape languages.\n\u2022 Section 8 concludes the article."}, {"heading": "2 Examples", "text": "This section introduces two examples of recursive shapes. The first recursive shape describes the data in a Personal Information Management application. This application is highly simplified and easy to understand. It is used as a running example to illustrate the formal definitions. Although this shape is written using recursion, it can be re-written as an equivalent, non-recursive shape.\nThe second recursive shape describes what it means to be a Polentoni [11]. This shape is also highly simplified but cannot be re-written as non-recursive using the Resource Shape 2.0 specification."}, {"heading": "2.1 Example: Personal Information Management", "text": "We use a highly simplified running example to illustrate the concepts defined in the following sections. Each formal definition is instantiated with data drawn from the running example in order to help the reader understand the formalism and relate it to RDF. Although the inclusion of examples lengthens the presentation, we hope that it will make the formalism more tangible and accessible to readers who are unfamiliar with Z Notation.\nConsider a Linked Data [2] application for Personal Information Management (PIM). The application manages documents that contain information about a contact person and their associates. As a Linked Data application, the PIM application provides a REST API for creating, retrieving, updating, and deleting contact information over HTTP using RDF representations of the data. Shapes are useful in this context for two main reasons. First, the PIM application may publish shapes that describe the contact information so that application developers who want to use the REST API understand the API contract. Second, the PIM application may internally use a shape engine that automatically validates the data, especially incoming creation and update requests.\nThe prefixes rdf: and foaf: as used for terms in the RDF[5] and FOAF[4] vocabularies. The application maintains the following integrity constraints.\n\u2022 Each document contains information about exactly one contact person and zero or more of their associates. A contact person is never an associate of themself.\n\u2022 Each contact has type foaf:Person and has exactly one name given by the property foaf:name.\n\u2022 The contact\u2019s associates are given by the property foaf:knows which may have zero or more values.\n\u2022 Each associate has type foaf:Person and has exactly one name given by foaf:name.\n\u2022 Each associate is known by exactly one contact given by following the property foaf:knows in the backward direction, i.e. the associate is the object of the property and the contact is the subject.\nNote that these constraints are circular since the definition of contact refers to the definition of associate, and conversely. We have an obligation to give this circularity a precise meaning.\nThese constraints are illustrated by a valid document for Alice (Listing 1) and an invalid document for Bob (Listing 2). All RDF source code examples are written in Turtle format [1].\nThe following document about Alice satisfies all the constraints of the application.\n1 # http :// example.org/contacts/alice 2 @prefix foaf: <http :// xmlns.com/foaf /0.1/> . 3 @base <http :// example.org/contacts/> . 4 5 <alice#me> a foaf:Person ; 6 foaf:name \"Alice\" ; 7 foaf:knows 8 <bob#me > , 9 <charlie#me > .\n10 11 <bob#me> a foaf:Person ; 12 foaf:name \"Bob\" . 13 14 <charlie#me> a foaf:Person ; 15 foaf:name \"Charlie\" .\nListing 1: Contact document for Alice\nThe following document about Bob violates some of the constraints of the application.\n1 # http :// example.org/contacts/bob 2 @prefix foaf: <http :// xmlns.com/foaf /0.1/> . 3 @base <http :// example.org/contacts/> . 4 5 <bob#me> a foaf:Person ; 6 foaf:name \"Bob\" ; 7 foaf:knows 8 <alice#me > , 9 <charlie#me > .\n10 11 <alice#me> foaf:name \"Alice\" . 12 13 <charlie#me> a foaf:Person .\nListing 2: Contact document for Bob\nIt is clear that the document about Bob is invalid, since Alice has no type and Charlie has no name.\nIt is also intuitively clear that the document about Alice is valid. However, if we naively translate the PIM constraints into logical conditions on the document about Alice, then we run into a problem. All the constraints about types, names, and who knows who are satisfied and unproblematic, but the constraints about what it means to be a contact or an associate are circular. A naive translation of these constraints on the Alice document is as follows.\n\u2022 If Bob is an associate and Charlie is an associate then Alice is a contact.\n\u2022 If Alice is a contact then Bob is an associate.\n\u2022 If Alice is a contact then Charlie is an associate.\nTable 1 introduces propositional variables to stand for statements about being a contact or associate in the Alice document.\nThe PIM constraints on the Alice document translate to the following consistency condition.\n(B \u2227 C \u21d2 A) \u2227 (A\u21d2 B) \u2227 (A\u21d2 C )\nUnfortunately, this consistency condition does not uniquely determine the values of the propositional variables. In fact, this consistency condition has several solutions as shown in Table 2. Only the solution in which all the propositional variable are true agrees with our intuition.\nThis analysis shows that the naive translation of the constraints about contacts and associates produces a necessary, but not sufficient, consistency condition on the meaning of these constraints. A precise definition for this type of constraint is given in Section 6. A brief overview of this definition follows.\nThe correct interpretation of the constraints is based on the observation that they specify two essentially different kinds of information. One kind defines rules for labelling nodes with names. The other kind defines a set of conditions associated with each name and asserts that these conditions must hold at each node labelled with that name.\nIn the PIM application, the names are contact and associate. The rules for labelling the nodes in a document are as follows.\n1. Initially, no node has any labels.\n2. Start with the node that corresponds to the person that the document is about, and label it as a contact.\n3. For each node labelled as a contact, find all the nodes they know, and add an associate label to each of them.\n4. For each node labelled as an associate, find all the nodes that they are known by and add a contact label each of them.\n5. Repeat the previous two steps until no new labels are added.\n6. Note that this procedure always terminates because the number of nodes is finite and the number of names is finite (2 in this case).\nIn the Alice document, the labelling procedure results in the nodes being labelled as follows.\n\u2022 Alice is labelled as a contact because the document is about Alice and Alice is known by Bob and Charlie.\n\u2022 Bob is labelled as an associate because Alice knows Bob.\n\u2022 Charlie is labelled as an associate because Alice knows Charlie.\nWhenever a node gets labelled with a name, the conditions associated with the name must hold. No recursion is involved in this step.\nThe conditions that must hold for nodes labelled with contact are as follows.\n\u2022 A contact must be a person.\n\u2022 A contact must have exactly one name.\n\u2022 A contact must not know itself.\nThe conditions that must hold for nodes labelled with associate are as follows.\n\u2022 An associate must be a person.\n\u2022 An associate must have exactly one name.\n\u2022 An associate must be known by exactly one node.\nAlthough the statement of the PIM constraints uses recursion, the properties of the data in this case allow us to write an equivalent non-recursive statement [12]. Specifically, since a node is an associate only if it is known by a contact, and an associate must be known by exactly one contact, nothing more is gained by requiring that all nodes that know an associate must be contacts. Dropping this condition removes the recursion. However, in general we cannot convert a recursive constraint into an equivalent non-recursive constraint. The next example illustrates an essentially recursive constraint."}, {"heading": "2.2 Example: Polentoni", "text": "Consider the following definition of what it means to be a Polentoni [11].\n\u2022 A Polentoni lives in exactly one place and that place is Northern Italy.\n\u2022 A Polentoni only knows other Polentoni.\nThe definition of Polentoni refers to itself and is therefore recursive. However, we can give it a precise meaning using the labelling procedure described above.\nIn this example, the only label name is Polentoni. The labelling procedure is as follows.\n1. Initially, no node has any labels.\n2. Start with the node to be checked for being a Polentoni, and label it as a Polentoni.\n3. For each node labelled as a Polentoni, find all the nodes they know, and add a Polentoni label to each of them.\n4. Repeat the previous step until no new labels are added.\n5. Note that this procedure always terminates because the number of nodes is finite and the number of names is finite (1 in this case).\nThe condition that must hold for nodes labelled with Polentoni is as follows.\n\u2022 A Polentoni must live in Northern Italy.\nListing 3 contains some sample data.\n1 @prefix ex: <http :// example.org/polentoni#> . 2 3 ex:Enrico ex:livesIn ex:NorthernItaly . 4 ex:Diego ex:livesIn ex:NorthernItaly . 5 ex:Alessandro ex:livesIn ex:NorthernItaly . 6 ex:Sergio ex:livesIn ex:NorthernItaly . 7 ex:John ex:livesIn ex:NorthernItaly . 8 ex:Maurizio ex:livesIn ex:SouthernItaly . 9\n10 ex:Enrico ex:knows ex:John . 11 ex:John ex:knows ex:Maurizio . 12 ex:Diego ex:knows ex:Alessandro . 13 ex:Alessandro ex:knows ex:Diego . 14 ex:Alessandro ex:knows ex:Sergio .\nListing 3: Polentoni sample data\nFigure 1 depicts the Polentoni sample data where, for example, the arrow from Enrico to John indicates that Enrico knows John.\nChecking Enrico results in Enrico, John, and Maurizio being labelled as Polentoni. However, Maurizio lives in Southern Italy so Enrico is not a Polentoni.\nChecking Diego results in Diego, Alessandro, and Sergio begin labelled as Polentoni. They all live in Northern Italy so Diego is a Polentoni.\nNote that if Resource Shape 2.0 were more expressive then we could rewrite the definition of Polentoni to avoid recursion as follows.\n\u2022 A Polentoni lives in Northern Italy (and nowhere else).\n\u2022 Everyone that a Polentoni knows, directly or indirectly, lives in Northern Italy (and nowhere else).\nThe price paid for eliminating recursion is that now we have introduced the transitive closure of the knows relation, which is beyond the expressive power of the Resource Shape 2.0 specification.\nTransitive closure is, however, expressible using SPARQL property paths. In fact, all the Polentoni constraints can be expressed by a single SPARQL query. Listing 4 contains a SPARQL query that finds all non-Polentoni people in a graph, where we assume that a person is any resource that lives somewhere, or knows someone, or is known by someone. Note the use of the property path ex:knows* which is referred to as a ZeroOrMorePath expression.\n1 # polentoni.rq 2 3 prefix ex: <http :// example.org/polentoni#> 4 5 # finds all non -Polentoni person nodes ?this in the graph 6 select distinct ?this 7 where { 8 # binds each person node to ?this 9 {\n10 select distinct ?this 11 where { 12 {?this ex:livesIn ?region} 13 union 14 {?this ex:knows ?person} 15 union 16 {? person ex:knows ?this} 17 } 18 } 19 20 # binds each person that ?this knows , 21 # directly or indirectly , to ?person 22 ?this ex:knows* ?person . 23 24 # A non -Polentoni ?person must not live 25 # in and only in Northern Italy 26 { 27 # ?person lives nowhere 28 filter not exists {? person ex:livesIn ?region} 29 } 30 union 31 { 32 # ?person lives somewhere not Northern Italy 33 ?person ex:livesIn ?region. 34 filter (? region != ex:NorthernItaly) 35 } 36 }\nListing 4: SPARQL query for non-Polentoni people\nTable 3 gives the results of running the non-Polenoni query on the data contained in Listing 3.\n\u2022 Maurizio is non-Polentoni because he lives in Southern Italy.\n\u2022 John is non-Polentoni because he knows Maurizio.\n\u2022 Enrico is non-Polentoni because he knows John.\nOne might therefore contemplate avoiding the issue of recursion by adding powerful path expressions to the shape language. However, it is unclear that path expressions alone are sufficiently powerful to cover all the cases currently\nexpressible in Resource Shape 2.0. Furthermore, even if that were true, translating recursive references into property path expressions would impose a severe burden on the shape author. The use of recursion allows concise and intuitively clear descriptions so, as long as recursion can be given a precise definition, there is good reason to include in future shape languages."}, {"heading": "3 Basic RDF Concepts", "text": "This section formalizes some basic RDF concepts. For full definitions consult the RDF specification[5]."}, {"heading": "3.1 Terms", "text": "Let TERM be the set of all RDF terms.\n[TERM ]\nThe set of all RDF terms is partitioned into IRIs, blank nodes, and literals.\nIRI ,BNode,Literal : TERM\n\u3008IRI ,BNode,Literal\u3009 partition TERM\nFor example, the documents for Alice and Bob contain the following distinct literals where Alice denotes \"Alice\", etc.\nAlice,Bob,Charlie : Literal\ndisjoint \u3008{Alice}, {Bob}, {Charlie}\u3009\nand the following distinct IRIs where alice denotes http://example.org/contacts/alice#me, etc., rdf type denotes rdf:type, and foaf Person denotes foaf:Person, etc.\nalice, bob, charlie : IRI rdf type : IRI foaf Person, foaf name, foaf knows : IRI\ndisjoint \u3008{alice}, {bob}, {charlie}, {rdf type}, {foaf Person}, {foaf name}, {foaf knows}\u3009"}, {"heading": "3.2 Triples", "text": "An RDF triple is a statement that consists of three terms referred to as subject, predicate, and object.\nTriple == { s, p, o : TERM | s /\u2208 Literal \u2227 p \u2208 IRI }\n\u2022 The subject must not be a literal.\n\u2022 The predicate must be an IRI.\nFor example, the statement that Alice is a person is represented by the following triple.\n` (alice, rdf type, foaf Person) \u2208 Triple"}, {"heading": "3.3 Graphs", "text": "It is common to visualize a triple as a directed arc from the subject to the object, labelled by the predicate. A set of triples may therefore may visualized as a directed graph (technically, a directed, labelled, multigraph). We are only concerned with finite graphs here.\nAn RDF graph is a finite set of triples.\nGraph == Triple\nFor example, the following graph contains the triples in the document about Alice.\nalice graph : Graph\nalice graph = {(alice, rdf type, foaf Person), (alice, foaf name,Alice), (alice, foaf knows, bob), (alice, foaf knows, charlie), (bob, rdf type, foaf Person), (bob, foaf name,Bob), (charlie, rdf type, foaf Person), (charlie, foaf name,Charlie)}\nFigure 2 depicts the document about Alice as a directed, labelled graph. It is convenient to define functions that map graphs to the sets of subjects,\npredicates, and objects that appear in the graph.\nsubjects == (\u03bb g : Graph \u2022 { s, p, o : TERM | (s, p, o) \u2208 g \u2022 s })\npredicates == (\u03bb g : Graph \u2022 { s, p, o : TERM | (s, p, o) \u2208 g \u2022 p })\nobjects == (\u03bb g : Graph \u2022 { s, p, o : TERM | (s, p, o) \u2208 g \u2022 o })\nFor example, the graph for Alice contains the following predicates.\n` predicates(alice graph) = {rdf type, foaf name, foaf knows}\nThe nodes of a graph are its subjects and objects.\nnodes == (\u03bb g : Graph \u2022 subjects(g) \u222a objects(g))\nFor example, the graph for Alice contains the following nodes.\n` nodes(alice graph) = {alice, bob, charlie,Alice,Bob,Charlie, foaf Person}\nA pointed graph consists of a graph and a base node in the graph.\nPointedGraph graph : Graph baseNode : TERM\nbaseNode \u2208 nodes(graph)\n\u2022 The base node is some node in the graph.\nThe base node of a pointed graph is also referred to as the start node or focus node of the graph, depending on the context.\nFor example, alice is the natural base node of the graph for Alice.\nalice pg : PointedGraph\nalice pg .graph = alice graph\nalice pg .baseNode = alice\n\u2022 The graph is alice graph.\n\u2022 The base node is alice."}, {"heading": "4 Neighbour Functions", "text": "RDF applications often impose conditions on nodes, and related conditions on their neighbours, where a neighbour is some node that bears a specified relation\nto the given node. When the neighbour relation between nodes is specified by traversing triples, we say that the nodes are connected by a path. SPARQL 1.1[7] defines a property path syntax for specifying paths.\nMore generally, applications may use neighbour relations that cannot be specified by property paths. Many such relations might be specified by SPARQL queries that bind pairs of variables to nodes. For maximum generality, we do not place restrictions on how neighbour relations are specified.\nA neighbour function is any mapping from graphs to pair of nodes that belong to the graph.\nNeighbour : (Graph\" (TERM # TERM ))\nNeighbour = { q : Graph\" (TERM # TERM ) |\n(\u2200 g : Graph \u2022 q(g) \u2286 { x , y : nodes(g) }) }\n\u2022 A neighbour function is a mapping that maps a graph g to a binary relation on the nodes of g .\nWe say that the pair of nodes (x , y) matches the neighbour function q in the graph g when (x , y) \u2208 q(g)."}, {"heading": "4.1 Simple Path Expressions", "text": "Simple path expressions define a very commonly used type of neighbour function.\nA predicate p defines a simple path expression forward(p) by traversing triples in the forward direction. Forward path expressions are referred to as PredicatePath expressions in SPARQL 1.1.\nforward : IRI \"Neighbour\n\u2200 p : IRI ; g : Graph \u2022 forward(p)(g) =\n{ s, o : nodes(g) | (s, p, o) \u2208 g }\n\u2022 The simple path expression forward(p) matches all pairs (s, o) such that (s, p, o) is a triple in g .\nFor example, the following are forward path expressions.\nhas type == forward(rdf type)\nhas name == forward(foaf name)\nknows == forward(foaf knows)\nThe forward path expression has type matches the following pairs of nodes in the graph for Alice.\n` has type(alice graph) = {(alice, foaf Person), (bob, foaf Person), (charlie, foaf Person)}\nSimilarly, a predicate p defines a simple path expression backward(p) by traversing triples in the backward direction. Backward path expressions are referred to as InversePath expressions in SPARQL 1.1.\nbackward : IRI \"Neighbour\n\u2200 p : IRI ; g : Graph \u2022 backward(p)(g) =\n{ o, s : nodes(g) | (s, p, o) \u2208 g }\n\u2022 The simple path expression backward(p) matches all pairs (o, s) such that (s, p, o) is a triple in g .\nFor example, the following is a backward path expression.\nis known by == backward(foaf knows)\nThe backward path expression is known by matches the following pairs of nodes in the graph for Alice.\n` is known by(alice graph) = {(bob, alice), (charlie, alice)}"}, {"heading": "4.2 Values", "text": "Given a graph g and a node x \u2208 nodes(g), the set of all nodes that can be reached from x by matching the neighbour function q is values(g , x , q).\nvalues : Graph \u00d7 TERM \u00d7Neighbour \" TERM\n\u2200 g : Graph; x : TERM ; q : Neighbour \u2022 values(g , x , q) = { y : nodes(g) | (x , y) \u2208 q(g) }\n\u2022 The node y is in values(g , x , q) when (x , y) matches q in g .\nFor example, in the graph for Alice the node alice and forward path expression knows have the following values.\n` values(alice graph, alice, knows) = {bob, charlie}"}, {"heading": "5 Constraints", "text": "RDF applications often impose constraints on the data graphs they process. A given graph either satisfies or violates the constraint. Thus a constraint partitions the set of all graphs into two disjoint subsets, namely the set of all graphs that satisfy the constraint and the set of all graphs that violate the constraint. A constraint is therefore defined by the set of graphs that satisfy it.\nA constraint is a, possibly infinite, set of graphs.\nConstraint == Graph\nFor example, suppose we define a small graph to be a graph that has at most 10 triples. The set of all small graphs is a constraint.\nsmall graphs : Constraint\nsmall graphs = { g : Graph | #g \u2264 10 }\nThe Alice graph satisfies this constraint.\n` alice graph \u2208 small graphs"}, {"heading": "5.1 Node Constraints", "text": "A parameterized constraint is a mapping from some parameter set X to constraints.\nParameterizedConstraint [X ] == X \" Constraint\nA term constraint is a constraint that is parameterized by terms.\nTermConstraint == ParameterizedConstraint [TERM ]\nFor example, given a term x \u2208 TERM , the constraint hasSubject(x ) is the set of all graphs that have x as a subject.\nhasSubject : TermConstraint\n\u2200 x : TERM \u2022 hasSubject(x ) = { g : Graph | x \u2208 subjects(g) }\nSimilarly, hasPredicate(x ), hasObject(x ), and hasNode(x ) are constraints with the analogous definitions.\nhasPredicate == (\u03bb x : TERM \u2022 { g : Graph | x \u2208 predicates(g) })\nhasObject == (\u03bb x : TERM \u2022 { g : Graph | x \u2208 objects(g) })\nhasNode == (\u03bb x : TERM \u2022 { g : Graph | x \u2208 nodes(g) })\nNote that hasNode(x ) is the union of hasSubject(x ) and hasObject(x ).\n` \u2200 x : TERM \u2022 hasNode(x ) = hasSubject(x ) \u222a hasObject(x )\nA node constraint is a term constraint in which the term is a node in each graph that satisfies the constraint.\nNodeConstraint : TermConstraint\nNodeConstraint = { c : TermConstraint | \u2200 x : TERM \u2022 \u2200 g : c(x ) \u2022 x \u2208 nodes(g) }\nFor example, hasNode is a node constraint.\n` hasNode \u2208 NodeConstraint\nThe PIM application enforces the following node constraints. Both contact and associate nodes must be people.\nis a person : NodeConstraint\n\u2200 x : TERM \u2022 is a person(x ) =\n{ g : Graph | (x , rdf type, foaf Person) \u2208 g }\n\u2022 A node is a person when it has a foaf:Person as one of its RDF types.\nFor example, the Alice graph satisfies this constraint at the alice, bob, and charlie nodes.\n` alice graph \u2208 is a person(alice) \u2227 alice graph \u2208 is a person(bob) \u2227 alice graph \u2208 is a person(charlie)\nBoth contact and associate nodes must have exactly one name.\nhas one name : NodeConstraint\n\u2200 x : TERM \u2022 has one name(x ) =\n{ g : Graph | \u22031 y : TERM \u2022 (x , foaf name, y) \u2208 g }\n\u2022 A node has one name when it is the subject of exactly one foaf:name triple.\nFor example, the Alice graph satisfies this constraint at the alice, bob, and charlie nodes.\n` alice graph \u2208 has one name(alice) \u2227 alice graph \u2208 has one name(bob) \u2227 alice graph \u2208 has one name(charlie)\nAssociate nodes must be known by exactly one node.\nis known by one : NodeConstraint\n\u2200 x : TERM \u2022 is known by one(x ) =\n{ g : Graph | \u22031 y : TERM \u2022 (y , foaf knows, x ) \u2208 g }\n\u2022 A node is known by one node when it is the object of exactly one foaf:knows triple.\nFor example, the Alice graph satisfies this constraint at the bob and charlie nodes.\n` alice graph \u2208 is known by one(bob) \u2227 alice graph \u2208 is known by one(charlie)\nA contact node must satisfy the following constraint.\ncontact nc : NodeConstraint\n\u2200 x : TERM \u2022 contact nc(x ) =\nis a person(x )\u2229 has one name(x )\n\u2022 A contact is a person and has one name.\nThe Alice graph satisfies this constraint at the alice, bob, and charlie nodes.\n` alice graph \u2208 contact nc(alice) \u2227 alice graph \u2208 contact nc(bob) \u2227 alice graph \u2208 contact nc(charlie)\nAn associate node must satisfy the following constraint.\nassociate nc : NodeConstraint\n\u2200 x : TERM \u2022 associate nc(x ) =\nis a person(x )\u2229 has one name(x )\u2229 is known by one(x )\n\u2022 An associate is a person, has one name, and is known by one node.\nThe Alice graph satisfies this constraint at the bob and charlie nodes.\n` alice graph \u2208 associate nc(bob) \u2227 alice graph \u2208 associate nc(charlie)"}, {"heading": "6 Shapes", "text": "In general, a shape is any description of the expected contents of a graph. In this article we deal only with shapes that describe graphs using the following structure. A shape is a structure that defines how to associate a set of node constraints with each node of a data graph in two steps.\n1. Label each node of the graph with a set of node constraint names using a set of neighbour functions.\n2. Map each name to a node constraint.\nThese steps are described in detail below. Note that this definition of shape is very prescriptive about the labelling process but is completely independent of the details of both the neighbour functions and the node constraints. We speculate that the labelling process can be used to handle the recursive aspects of a wide variety of shape languages that differ only in their expressiveness for defining neighbour functions and node constraints. For example, Resource Shape 2.0 uses forward and backward path expressions as neighbour functions and has a small, fixed set of simple node constraints. SHACL-SPARQL allows node constraints to be expressed by arbitrary SPARQL 1.1 queries, but does not allow explicit recursion."}, {"heading": "6.1 Labelling Data Graph Nodes with Constraint Names", "text": "A shape contains a set of named constraints. A constraint may refer to other constraints by name. This means that a constraint may refer directly or indirectly to itself, in which case the constraint is recursive.\nShapes themselves may be represented as RDF graphs, so it is tempting to use IRIs to name node constraints. However, we introduce a new given set of names to emphasize that this set is logically independent of how we represent shapes.\n[NAME ]\nFor example, there are two distinct kinds of node in the PIM application, namely contact and associate.\ncontact , associate : NAME\ncontact 6= associate\n\u2022 contact and associate are distinct names.\nSince graphs appear in several roles, there is scope for confusion. To clarify its role, the graph to which constraints are being applied will be referred to as the data graph.\nThe part of a shape that defines how data graph nodes are labelled is a neighbour graph. A neighbour graph is a directed, labelled, multigraph whose nodes are names and whose arcs are labelled by neighbour functions.\nNeighbourGraph names : NAME arcs : (NAME \u00d7Neighbour \u00d7NAME )\narcs \u2286 names \u00d7Neighbour \u00d7 names\n\u2022 The nodes are names and the arcs are labelled by neighbour functions.\nFor example, in the PIM application, contacts are related to associates by the knows forward path expression, and associates are related to contacts by the is known by backward path expression.\npim ng : NeighbourGraph\npim ng .names = {contact , associate}\npim ng .arcs = {(contact , knows, associate), (associate, is known by , contact)}\nA pointed neighbour graph consists of a neighbour graph and a base name in the graph.\nPointedNeighbourGraph NeighbourGraph baseName : NAME\nbaseName \u2208 names\n\u2022 The base name belongs to the graph.\nThe base name of a pointed neighbour graph is also referred to as the start name or focus name, depending on the context.\nFor example, contact is the natural base name in the PIM application.\npim png : PointedNeighbourGraph\npim png .names = pim ng .names\npim png .arcs = pim ng .arcs\npim png .baseName = contact\nA named node is pair of the form (x , a) where x is a data graph node and a is a node constraint name.\nNamedNode == TERM \u00d7NAME\nFor example, (alice, contact) is named node.\n` (alice, contact) \u2208 NamedNode\nA data graph g and a neighbour graph ng define a requires binary relation requires(g ,ng) on the set of named nodes. The meaning of this relation is that if (x , a) requires (y , b) then whenever x must satisfy the constraints named by a then y must satisfy the constraints named by b.\nrequires : Graph \u00d7NeighbourGraph\" (NamedNode#NamedNode)\n\u2200 g : Graph; ng : NeighbourGraph \u2022 requires(g ,ng) =\n{ x , y : nodes(g); a, b : NAME ; q : Neighbour | (a, q , b) \u2208 ng .arcs \u2227 (x , y) \u2208 q(g) \u2022\n(x , a) 7\u2192 (y , b) }\n\u2022 The named node (x , a) requires (y , b) when the neighbour graph includes an arc (a, q , b) and the node y can be reached from x by matching the neighbour function q in g .\nFor example, the requires relation for the Alice graph in the PIM application is as follows.\n` requires(alice graph, pim ng) = {(alice, contact) 7\u2192 (bob, associate), (alice, contact) 7\u2192 (charlie, associate), (bob, associate) 7\u2192 (alice, contact), (charlie, associate) 7\u2192 (alice, contact)}\nA labelled graph is a data graph whose nodes are each labelled by a, possibly empty, set of names.\nLabelledGraph graph : Graph names : NAME label : TERM NAME\nlabel \u2208 nodes(graph)\" names\n\u2022 Each node in the graph is labelled by a set of names.\nFor example, the following is a labelled graph based on the Alice graph.\nalice lg : LabelledGraph\nalice lg .graph = alice graph\nalice lg .names = {contact , associate}\nalice lg .label = {alice 7\u2192 {contact}, bob 7\u2192 {associate}, charlie 7\u2192 {associate}, Alice 7\u2192 , Bob 7\u2192 , Charlie 7\u2192 , foaf Person 7\u2192 }\nA pointed graph and a pointed neighbour graph determine a unique labelled graph. Intuitively, the labelling process starts by labelling the base node with the base name. Next, the neighbour graph is checked for arcs that begin at baseName, e.g. (baseName, q , b). For each such arc compute the set values(g , q , baseNode) and for each node y in this set, label y with b. Now repeat these steps taking y as the new base node and b as the new base name, but only do this once for each named node (y , b). Since there are a finite number of nodes and a finite number of names, this process always terminates.\nLabelGraph PointedGraph PointedNeighbourGraph LabelledGraph\nlet ng == \u03b8NeighbourGraph \u2022 let R == (requires(graph,ng))\u2217 \u2022\nlabel = (\u03bb y : nodes(graph) \u2022 { b : names | (baseNode, baseName) R (y , b) })\n\u2022 The label of a node y is the set of names b such that the named node (y , b) is related to the base named node (baseNode, baseName) by R the reflexive-transitive closure of the requires relation requires(graph, shape).\n\u2022 Note that this labelling process makes use of R, the reflexive-transitive closure of the requires relation. The use of R avoids difficulties associated with explicitly recursive definitions. We have, in effect, eliminated explicit recursion by computing a transitive closure of a finite binary relation.\n\u2022 Note that the components of LabelledGraph are uniquely determined by the components of PointedGraph and PointedNeighbourGraph.\nFor example, the pointed graph alice pg and the pointed neighbour graph pim png uniquely determine the labelled graph alice lg .\n\u2200LabelGraph | \u03b8PointedGraph = alice pg \u2227 \u03b8PointedNeighbourGraph = pim png \u2022\n\u03b8LabelledGraph = alice lg"}, {"heading": "6.2 Mapping Constraint Names to Node Constraints", "text": "The association of node constraints to graph nodes is given by a mapping.\nNodeConstraints names : NAME constraint : NAME NodeConstraint\ndom constraint = names\n\u2022 Each name maps to a node constraint.\nFor example, the PIM application associates the following node constraints with names.\npim ncs : NodeConstraints\npim ncs.names = {contact , associate}\npim ncs.constraint = {contact 7\u2192 contact nc, associate 7\u2192 associate nc}\n\u2022 The PIM application has two kinds of nodes, named contact and associate.\n\u2022 contact nodes must satisfy the contact nc node constraint.\n\u2022 associate nodes must satisfy the associate nc node constraint.\nA constrained graph is an assignment of a, possibly empty, set of node constraints to each node of the graph.\nConstrainedGraph graph : Graph constraints : TERM NodeConstraint\ndom constraints = nodes(graph)\n\u2022 Each node of the data graph has a set of node constraints.\nFor example, the PIM application enforces the following constraints on the Alice graph.\nalice cg : ConstrainedGraph\nalice cg .graph = alice graph\nalice cg .constraints = {alice 7\u2192 {contact nc}, bob 7\u2192 {associate nc}, charlie 7\u2192 {associate nc}, Alice 7\u2192 , Bob 7\u2192 , Charlie 7\u2192 , foaf Person 7\u2192 }\n\u2022 alice must satisfy the contact node constraint.\n\u2022 bob and charlie must satisfy the associate node constraint.\n\u2022 There are no node constraints on the remaining nodes.\nA constrained graph is valid if it satisfies all the constraints at each node.\nValidGraph ConstrainedGraph\n\u2200 x : nodes(graph) \u2022 \u2200 c : constraints(x ) \u2022\ngraph \u2208 c(x )\n\u2022 A valid data graph satisfies each node constraint at each node.\nFor example, the constrained graph alice cg is valid.\n` alice cg \u2208 ValidGraph\nA mapping from nodes to names (LabelledGraph) and a mapping from names to node constraints (NodeConstraints) uniquely determines a mapping from nodes to node constraints (ConstrainedGraph).\nConstrainGraph LabelledGraph NodeConstraints ConstrainedGraph\n\u2200 x : nodes(graph) \u2022 constraints(x ) =\n{ a : label(x ) \u2022 constraint(a) }\n\u2022 The set of node constraints at each node x of a labelled data graph is equal to the to the set node constraints named by the labels a at x .\n\u2022 Note that the components of ConstrainedGraph are uniquely determined by the components of LabelledGraph and NodeConstraints.\nFor example, the Alice labelled graph alice lg and the PIM node constraints pim ncs uniquely determine the Alice constrained graph alice cg .\n` \u2200ConstrainGraph | \u03b8LabelledGraph = alice lg \u2227 \u03b8NodeConstraints = pim ncs \u2022\n\u03b8ConstrainedGraph = alice cg"}, {"heading": "6.3 Shapes as Constraints", "text": "A shape consists of a neighbour graph and node constraints.\nShape NeighbourGraph NodeConstraints\nFor example, the neighbour graph pim ng and the node constraints pim nc define a shape for the PIM application.\npim shape : Shape\npim shape.names = {contact , associate}\npim shape.arcs = pim ng .arcs\npim shape.constraint = pim ncs.constraint\nA pointed shape consists of a pointed neighbour graph and node constraints.\nPointedShape PointedNeighbourGraph NodeConstraints\nFor example, the pointed neighbour graph pim png , which has base name contact , and the node constraints pim ncs define a pointed shape for the PIM application.\npim ps : PointedShape\npim ps.names = {contact , associate}\npim ps.baseName = contact\npim ps.arcs = pim ng .arcs\npim ps.constraint = pim ncs.constraint\nA pointed data graph satisfies a pointed shape if the constrained graph produced by the composition of the labelling and constraining processes is valid.\nSatisfiesShape PointedShape PointedGraph LabelGraph ConstrainGraph\nValidGraph\n\u2022 The constrained graph that results from the labelling and constraining processes must be valid.\n\u2022 Note that the components of LabelGraph and ConstrainGraph are uniquely determined by the components of PointedShape and PointedGraph. The validity condition (ValidGraph) therefore determines a relation between PointedShape and PointedGraph. The pointed graph is said to satisfy the pointed shape.\nFor example, the pointed Alice graph satisfies the pointed PIM shape.\n` \u22031 SatisfiesShape \u2022 \u03b8PointedShape = pim ps \u2227 \u03b8PointedGraph = alice pg\nA pointed shape determines a node constraint.\nshapeConstraint : PointedShape\"NodeConstraint\n\u2200 ps : PointedShape; x : TERM \u2022 shapeConstraint(ps)(x ) =\n{SatisfiesShape | ps = \u03b8PointedShape \u2227 x = baseNode \u2022 graph }\n\u2022 Given a pointed shape ps, shapeConstraint(ps) is a node constraint. Given a node x , shapeConstraint(ps)(x ) is the set of all graphs graph such that the pointed graph formed by using x as the base node satisfies ps.\nFor example, the pointed PIM shape defines a node constraint.\npim nc : NodeConstraint\npim nc = shapeConstraint(pim ps)\nThe graph alice graph satisfies this node constraint at the node alice.\n` alice graph \u2208 pim nc(alice)"}, {"heading": "7 Relation to Shape Languages", "text": "This section discusses how the preceding formalism relates to Resource Shape 2.0, ShEx, and SHACL."}, {"heading": "7.1 Relation to Resource Shape 2.0", "text": "Resource Shape 2.0 provides a small vocabulary for defining simple, commonly occurring node constraints such as property occurrence, range, and allowed values. These are uncontentious and will not be discussed further.\nAs mentioned above, Resource Shape 2.0 also allows recursive shapes via the property oslc:valueShape. The preceding formalism was motivated by Resource Shape 2.0 and, not surprisingly, provides a precise description of the meaning of recursive shapes in that language."}, {"heading": "7.1.1 Example: Personal Information Management", "text": "The following listings illustrate the use of oslc:valueShape for the running PIM example.\nListing 5 contains the resource shape for contacts. Note that Resource Shape 2.0 is incapable of expressing the constraint that a contact must not have itself as an associate.\n1 # http :// example.org/shapes/contact 2 @prefix foaf: <http :// xmlns.com/foaf /0.1/> . 3 @prefix oslc: <http ://open -services.net/ns/core#> . 4 @prefix xsd: <http :// www.w3.org /2001/ XMLSchema#>. 5 @base <http :// example.org/shapes/> . 6 7 <contact > a oslc:ResourceShape ; 8 oslc:describes foaf:Person ; 9 oslc:property\n10 <contact#name > , 11 <contact#knows > . 12 13 <contact#name > a oslc:Property ; 14 oslc:name \"name\" ; 15 oslc:occurs oslc:Exactly -one ; 16 oslc:propertyDefinition foaf:name ; 17 oslc:valueType xsd:string . 18 19 <contact#knows > a oslc:Property ; 20 oslc:name \"knows\" ; 21 oslc:occurs oslc:Zero -or-many ; 22 oslc:propertyDefinition foaf:knows ; 23 oslc:range foaf:Person ; 24 oslc:valueShape <associate > .\nListing 5: Resource shape for contacts\nListing 6 contains the resource shape for associates.\n1 # http :// example.org/shapes/associate 2 @prefix foaf: <http :// xmlns.com/foaf /0.1/> . 3 @prefix oslc: <http ://open -services.net/ns/core#> . 4 @prefix xsd: <http :// www.w3.org /2001/ XMLSchema#>. 5 @base <http :// example.org/shapes/> . 6 7 <associate > a oslc:ResourceShape ; 8 oslc:describes foaf:Person ; 9 oslc:property\n10 <associate#name > , 11 <associate#isKnownBy > . 12 13 <associate#name > a oslc:Property ; 14 oslc:name \"name\" ; 15 oslc:occurs oslc:Exactly -one ; 16 oslc:propertyDefinition foaf:name ; 17 oslc:valueType xsd:string . 18 19 <associate#isKnownBy > a oslc:Property ; 20 oslc:name \"isKnownBy\" ; 21 oslc:occurs oslc:Exactly -one ; 22 oslc:propertyDefinition foaf:knows ;\n23 oslc:isInverseProperty true ; 24 oslc:range foaf:Person ; 25 oslc:valueShape <contact > .\nListing 6: Resource shape for associates\nThis example illustrates recursive shapes since the contact shape refers to the associate shape and the associate shape refers to the contact shape. This apparent circularity would cause difficulty if contact and associate were each described as a constraint. However, using the preceding formalism, the composite shape consisting of both the contact and associate resource shapes is given a well-defined meaning.\nIn Resource Shape 2.0, neighbour functions are limited to forward and backward path expressions. In fact, backward path expressions were missing from the original OSLC Resource Shape language and are a proposed extension in Resource Shape 2.0. The proposed syntax for backward path expressions uses the optional property oslc:isInverseProperty but this design could be improved to provide better compatibility with downlevel clients, i.e. a downlevel client might silently ignore this new property and produce incorrect results.\nThe following SPARQL query extracts the neighbour graph arcs from a set of resource shapes. Each binding of (?a ?direction ?p ?b) corresponds to an arc (a, q , b) where q = forward(p) or q = backward(p).\n1 prefix oslc: <http ://open -services.net/ns/core#> 2 3 select distinct ?a ?direction ?p ?b 4 where { 5 ?a a oslc:ResourceShape ; 6 oslc:property ?prop . 7 ?prop a oslc:Property ; 8 oslc:propertyDefinition ?p ; 9 oslc:valueShape ?b .\n10 optional {?prop oslc:isInverseProperty ?inverse} 11 bind (if(bound (? inverse) && ?inverse , 12 \u2019backward \u2019, \u2019forward \u2019) as ?direction) 13 }\nListing 7: Query for neighbour graph arcs\nThe result of running this query on the PIM resource shapes is given in Table 4.\nThe query correctly extracts the neighbour graph pim ng of the PIM shape."}, {"heading": "7.1.2 Example: Polentoni", "text": "Listing 8 contains the resource shape for Polentoni.\n1 # http :// example.org/shapes/polentoni 2 @prefix ex: <http :// example.org/polentoni#> . 3 @prefix oslc: <http ://open -services.net/ns/core#> . 4 @base <http :// example.org/shapes/> . 5 6 <polentoni > a oslc:ResourceShape ; 7 oslc:property 8 <polentoni#livesIn > , 9 <polentoni#knows > .\n10 11 <polentoni#livesIn > a oslc:Property ; 12 oslc:name \"livesIn\" ; 13 oslc:occurs oslc:Exactly -one ; 14 oslc:propertyDefinition ex:livesIn ; 15 oslc:allowedValue ex:NorthernItaly . 16 17 <polentoni#knows > a oslc:Property ; 18 oslc:name \"knows\" ; 19 oslc:occurs oslc:Zero -or-many ; 20 oslc:propertyDefinition ex:knows ; 21 oslc:valueShape <polentoni > .\nListing 8: Resource shape for Polentoni\nThis resource shape is clearly recursive since it refers to itself. However, as shown above, this recursion has a well-defined meaning and causes no difficulties."}, {"heading": "7.2 Relation to ShEx", "text": "One major difference between Resource Shape 2.0 and ShEx is that ShEx allows the definition of much richer node constraints using regular expressions, disjunction, and other operations. ShEx also allows recursion via reference to named shapes, e.g. @<UserShape>, which is referred to as the ValueReference feature.\nMost features of Resource Shape 2.0 can be expressed in ShEx. The intersection of Resource Shape 2.0 and ShEx certainly includes the recursive aspects of Resource Shape 2.0 as expressed by oslc:valueShape. Therefore the preceding formalism applies to ShEx provided that ValueReference is used in a way that maps directly to Resource Shape 2.0.\nHowever, ShEx allows a more permissive use ValueReference. For example, a ValueReference may appear inside GroupRule with cardinalities. It is not clear that this usage can be expressed using suitably defined neighbour functions."}, {"heading": "7.3 Relation to SHACL", "text": "The W3C Data Shapes Working Groups is currently developing the SHACL specification. At the time of writing, there are three competing proposals. One proposal, influenced by SPIN, appears to treat recursion similarly to Resource Shape 2.0. A second proposal is a further development of ShEx. The third proposal, SHACL-SPARQL, takes a different approach by avoiding recursion entirely.\nThe ability to name and refer to shapes allows for more intuitive descriptions of the constraints on graphs. The absence of recursion in SHACL-SPARQL therefore detracts from its usefulness. However, since the formalism presented here gives a clear and unobjectionable meaning to a limited form of recursion, this capability could be added to SHACL-SPARQL."}, {"heading": "8 Conclusion", "text": "The formalism presented here gives a precise meaning to recursive shapes as defined in Resource Shape 2.0.\nThis formalism is applicable to a subset of ShEx in which recursion is suitably limited. More analysis is required in order to determine if the unlimited form of recursion allowed in ShEx and its SHACL follow-on can be described using suitable neighbour functions, or if some new concept is required.\nFinally, the limited form of recursion presented here could be added to the SHACL-SPARQL proposal to enhance its expressiveness."}, {"heading": "Acknowledgements", "text": "Peter Patel-Schneider carefully reviewed an early draft of this article and provided valuable comments and criticisms. Holger Knublauch suggested the use of the Polentoni example as a better illustration of recursion."}], "references": [{"title": "RDF 1.1 Turtle", "author": ["D. Beckett", "T. Berners-Lee", "E. Prud\u2019hommeaux", "G. Carothers"], "venue": "W3C Recommendation,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2014}, {"title": "RDF 1.1 Concepts and Abstract Syntax", "author": ["R. Cyganiak", "D. Wood", "M. Lanthaler"], "venue": "W3C Recommendation,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures", "author": ["S.S. Gao", "C.M. Sperberg-McQueen", "H.S. Thompson"], "venue": "W3C Recommendation,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "SPARQL 1.1 Query Language. W3C Recommendation, World Wide Web Consortium, Mar", "author": ["S. Harris", "A. Seaborne"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "Rdf data shapes working group. wiki", "author": ["A. Le Hors"], "venue": "page, World Wide Web Consortium,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)", "author": ["B. Motik", "P.F. Patel-Schneider", "B. Parsia"], "venue": "W3C Recommendation,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "A SHACL Specification based on SPARQL", "author": ["P. Patel-Schneider"], "venue": "wiki page, World Wide Web Consortium,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2015}, {"title": "Re: Recursion in RDF Data Shape Languages", "author": ["P. Patel-Schneider"], "venue": "mailing list, World Wide Web Consortium,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2015}, {"title": "Resource Shape 2.0. W3C Member Submission", "author": ["A. Ryman"], "venue": "World Wide Web Consortium,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2014}, {"title": "agryman/shape-recursion. source code repository, GitHub", "author": ["A. Ryman"], "venue": "https://github.com/agryman/shape-recursion", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2015}, {"title": "Shape Expressions 1.0 Definition", "author": ["H. Solbrig", "E. Prud\u2019hommeaux"], "venue": "Member Submission, World Wide Web Consortium, June 2014. http://www.w3.org/Submission/2014/SUBM-shex-defn-20140602/", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2014}, {"title": "The Z Notation: a reference manual", "author": ["M. Spivey"], "venue": "https://spivey.oriel.ox.ac.uk/mike/zrm/index.html", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2001}, {"title": "The fuzz type-checker for Z. web", "author": ["M. Spivey"], "venue": "page, Oxford University,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}], "referenceMentions": [{"referenceID": 2, "context": "In this respect, data shapes do for RDF what XML Schema[6] does for XML.", "startOffset": 55, "endOffset": 58}, {"referenceID": 5, "context": "The term shape is used instead of schema to avoid confusion with RDF Schema[3] which, like OWL[9], describes inference rules, not constraints.", "startOffset": 94, "endOffset": 97}, {"referenceID": 4, "context": "W3C recently (2014) chartered the RDF Data Shapes Working Group to define SHACL, a standard RDF data shape language[8].", "startOffset": 115, "endOffset": 118}, {"referenceID": 8, "context": "0[13] and Shape Expressions (ShEx) [15] allow shapes to refer to each other.", "startOffset": 1, "endOffset": 5}, {"referenceID": 10, "context": "0[13] and Shape Expressions (ShEx) [15] allow shapes to refer to each other.", "startOffset": 35, "endOffset": 39}, {"referenceID": 11, "context": "Precision is achieved through the use of Z Notation [16], a formal specification language based on typed set theory.", "startOffset": 52, "endOffset": 56}, {"referenceID": 12, "context": "The LTEX source for this article has been type-checked using the fuzz type-checker [17] and is available in the GitHub repository agryman:shape-recursion [14].", "startOffset": 83, "endOffset": 87}, {"referenceID": 9, "context": "The LTEX source for this article has been type-checked using the fuzz type-checker [17] and is available in the GitHub repository agryman:shape-recursion [14].", "startOffset": 154, "endOffset": 158}, {"referenceID": 6, "context": "In particular, recursion is not permitted in the SHACL-SPARQL proposal [10], but we conjecture that recursion could be added by using the definition proposed here as a top-level control structure.", "startOffset": 71, "endOffset": 75}, {"referenceID": 1, "context": "The prefixes rdf: and foaf: as used for terms in the RDF[5] and FOAF[4] vocabularies.", "startOffset": 56, "endOffset": 59}, {"referenceID": 0, "context": "All RDF source code examples are written in Turtle format [1].", "startOffset": 58, "endOffset": 61}, {"referenceID": 7, "context": "Although the statement of the PIM constraints uses recursion, the properties of the data in this case allow us to write an equivalent non-recursive statement [12].", "startOffset": 158, "endOffset": 162}, {"referenceID": 1, "context": "For full definitions consult the RDF specification[5].", "startOffset": 50, "endOffset": 53}, {"referenceID": 3, "context": "1[7] defines a property path syntax for specifying paths.", "startOffset": 1, "endOffset": 4}], "year": 2015, "abstractText": "An RDF data shape is a description of the expected contents of an RDF document (aka graph) or dataset. A major part of this description is the set of constraints that the document or dataset is required to satisfy. W3C recently (2014) chartered the RDF Data Shapes Working Group to define SHACL, a standard RDF data shape language. We refer to the ability to name and reference shape language elements as recursion. This article provides a precise definition of the meaning of recursion as used in Resource Shape 2.0. The definition of recursion presented in this article is largely independent of language-specific details. We speculate that it also applies to ShEx and to all three of the current proposals for SHACL. In particular, recursion is not permitted in the SHACL-SPARQL proposal, but we conjecture that recursion could be added by using the definition proposed here as a top-level control structure.", "creator": "TeX"}}}