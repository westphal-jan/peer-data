{"id": "1511.00041", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Oct-2015", "title": "Learning Causal Graphs with Small Interventions", "abstract": "We consider the problem of learning causal networks with interventions, when each intervention is limited in size under Pearl's Structural Equation Model with independent errors (SEM-IE). The objective is to minimize the number of experiments to discover the causal directions of all the edges in a causal graph. Previous work has focused on the use of separating systems for complete graphs for this task. We prove that any deterministic adaptive algorithm needs to be a separating system in order to learn complete graphs in the worst case. In addition, we present a novel separating system construction, whose size is close to optimal and is arguably simpler than previous work in combinatorics. We also develop a novel information theoretic lower bound on the number of interventions that applies in full generality, including for randomized adaptive learning algorithms.", "histories": [["v1", "Fri, 30 Oct 2015 22:24:13 GMT  (61kb)", "http://arxiv.org/abs/1511.00041v1", "Accepted to NIPS 2015"]], "COMMENTS": "Accepted to NIPS 2015", "reviews": [], "SUBJECTS": "cs.AI cs.IT cs.LG math.IT stat.ML", "authors": ["karthikeyan shanmugam", "murat kocaoglu", "alexandros g dimakis", "sriram vishwanath"], "accepted": true, "id": "1511.00041"}, "pdf": {"name": "1511.00041.pdf", "metadata": {"source": "CRF", "title": "Learning Causal Graphs with Small Interventions", "authors": ["Karthikeyan Shanmugam", "Murat Kocaoglu", "Alexandros G. Dimakis", "Sriram Vishwanath"], "emails": ["karthiksh@utexas.edu,", "mkocaoglu@utexas.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n51 1.\n00 04\n1v 1\n[ cs\n.A I]\n3 0\nO ct\nFor general chordal graphs, we derive worst case lower bounds on the number of interventions. Building on observations about induced trees, we give a new deterministic adaptive algorithm to learn directions on any chordal skeleton completely. In the worst case, our achievable scheme is an \u03b1-approximation algorithm where \u03b1 is the independence number of the graph. We also show that there exist graph classes for which the sufficient number of experiments is close to the lower bound. In the other extreme, there are graph classes for which the required number of experiments is multiplicatively \u03b1 away from our lower bound.\nIn simulations, our algorithm almost always performs very close to the lower bound, while the approach based on separating systems for complete graphs is significantly worse for random chordal graphs."}, {"heading": "1 Introduction", "text": "Causality is a fundamental concept in sciences and philosophy. The mathematical formulation of a theory of causality in a probabilistic sense has received significant attention recently (e.g. [2, 6, 8, 9, 14]). A formulation advocated by Pearl considers the structural equation models: In this framework, X is a cause of Y , if Y can be written as f(X,E), for some deterministic function f and some latent random variable E. Given two causally related variables X and Y , it is not possible to infer whether X causes Y or Y causes X from random samples, unless certain assumptions are made on the distribution of E and/or on f [7, 15]. For more than two random variables, directed acyclic graphs (DAGs) are the most common tool used for representing causal relations. For a given DAG D = (V,E), the directed edge (X,Y ) \u2208 E shows that X is a cause of Y .\nIf we make no assumptions on the data generating process, the standard way of inferring the causal directions is by performing experiments, the so-called interventions. An intervention requires modifying the process that generates the random variables: The experimenter has to enforce values on the random variables. This process is different than conditioning as explained in detail in [14].\nThe natural problem to consider is therefore minimizing the number of interventions required to learn a causal DAG. Hauser et al. [6] developed an efficient algorithm that minimizes this number in the worst case. The algorithm is based on optimal coloring of chordal graphs and requires at most log\u03c7 interventions to learn any causal graph where \u03c7 is the chromatic number of the chordal skeleton.\nHowever, one important open problem appears when one also considers the size of the used interventions: Each intervention is an experiment where the scientist must force a set of variables to take random values. Unfortunately, the interventions obtained in [6] can involve up to n/2 variables. The simultaneous enforcing of many variables can\nbe quite challenging in many applications: for example in biology, some variables may not be enforceable at all or may require complicated genomic interventions for each parameter.\nIn this paper, we consider the problem of learning a causal graph when intervention sizes are bounded by some parameter k. The first work we are aware of for this problem is by Eberhardt et al. [2], where he provided an achievable scheme. Furthermore [3] shows that the set of interventions to fully identify a causal DAG must satisfy a specific set of combinatorial conditions called a separating system1, when the intervention size is not constrained or is 1. In [9], with the assumption that the same holds true for any intervention size, Hyttinen et al. draw connections between causality and known separating system constructions. One open problem is: If the learning algorithm is adaptive after each intervention, is a separating system still needed or can one do better? It was believed that adaptivity does not help in the worst case [3] and that one still needs a separating system.\nOur Contributions: We obtain several novel results for learning causal graphs with interventions bounded by size k. The problem can be separated for the special case where the underlying undirected graph (the skeleton) is the complete graph and the more general case where the underlying undirected graph is chordal. 1. For complete graph skeletons, we show that any adaptive deterministic algorithm needs a (n, k) separating system.\nThis implies that lower bounds for separating systems also hold for adaptive algorithms and resolves the previously mentioned open problem. 2. We present a novel combinatorial construction of a separating system that is close to the previous lower bound. This simple construction may be of more general interest in combinatorics. 3. Recently [8] showed that randomized adaptive algorithms need only log log n interventions with high probability for the unbounded case. We extend this result and show that O (\nn k log log k\n)\ninterventions of size bounded by k suffice with high probability. 4. We present a more general information theoretic lower bound of n2k to capture the performance of such randomized algorithms. 5. We extend the lower bound for adaptive algorithms for general chordal graphs. We show that over all orientations, the number of experiments from a (\u03c7(G), k) separating system is needed where \u03c7(G) is the chromatic number of the skeleton graph. 6. We show two extremal classes of graphs. For one of them, the interventions through (\u03c7, k) separating system is sufficient. For the other class, we need \u03b1(\u03c7\u22121)2k \u2248 n 2k experiments in the worst case. 7. We exploit the structural properties of chordal graphs to design a new deterministic adaptive algorithm that uses the idea of separating systems together with adaptability to Meek rules. We simulate our new algorithm and empirically observe that it performs quite close to the (\u03c7, k) separating system. Our algorithm requires much fewer interventions compared to (n, k) separating systems."}, {"heading": "2 Background and Terminology", "text": ""}, {"heading": "2.1 Essential graphs", "text": "A causal DAG D = (V,E) is a directed acyclic graph where V = {x1, x2 . . . xn} is a set of random variables and (x, y) \u2208 E is a directed edge if and only if x is a direct cause of y. We adopt Pearl\u2019s structural equation model with independent errors (SEM-IE) in this work (see [14] for more details). Variables in S \u2286 V cause xi, if xi = f({xj}j\u2208S , ey) where ey is a random variable independent of all other variables.\nThe causal relations of D imply a set of conditional independence (CI) relations between the variables. A conditional independence relation is of the following form: Given Z , the set X and the set Y are conditionally independent for some disjoint subsets of variables X,Y, Z . Due to this, causal DAGs are also called causal Bayesian networks. A set V of variables is Bayesian with respect to a DAG D if the joint probability distribution of V can be factorized as a product of marginals of every variable conditioned on its parents.\nAll the CI relations that are learned statistically through observations can also be inferred from the Bayesian network using a graphical criterion called the d-separation [16] assuming that the distribution is faithful to the graph 2. Two causal DAGs are said to be Markov equivalent if they encode the same set of CIs. Two causal DAGs are Markov\n1A separating system is a 0-1 matrix with n distinct columns and each row has at most k ones. 2Given Bayesian network, any CI relation implied by d-separation holds true. All the CIs implied by the distribution can be found using dseparation if the distribution is faithful. Faithfulness is a widely accepted assumption, since it is known that only a measure zero set of distributions are not faithful [13].\nequivalent if and only if they have the same skeleton3 and the same immoralities4. The class of causal DAGs that encode the same set of CIs is called the Markov equivalence class. We denote the Markov equivalence class of a DAG D by [D]. The graph union5 of all DAGs in [D] is called the essential graph of D. It is denoted E(D). E(D) is always a chain graph with chordal6 chain components 7 [1].\nThe d-separation criterion can be used to identify the skeleton and all the immoralities of the underlying causal DAG [16]. Additional edges can be identified using the fact that the underlying DAG is acyclic and there are no more immoralities. Meek derived 3 local rules (Meek rules), introduced in [17], to be recursively applied to identify every such additional edge (see Theorem 3 of [12]). The repeated application of Meek rules on this partially directed graph with identified immoralities until they can no longer be used yields the essential graph."}, {"heading": "2.2 Interventions and Active Learning", "text": "Given a set of variables V = {x1, ..., xn}, an intervention on a set S \u2282 X of the variables is an experiment where the performer forces each variable s \u2208 S to take the value of another independent (from other variables) variable u, i.e., s = u. This operation, and how it affects the joint distribution is formalized by the do operator by Pearl [14]. An intervention modifies the causal DAG D as follows: The post intervention DAG D{S} is obtained by removing the connections of nodes in S to their parents. The size of an intervention S is the number of intervened variables, i.e., |S|. Let Sc denote the complement of the set S.\nCI-based learning algorithms can be applied to D{S} to identify the set of removed edges, i.e. parents of S [16], and the remaining adjacent edges in the original skeleton are declared to be the children. Hence,\n(R0) The orientations of the edges of the cut between S and Sc in the original DAG D can be inferred. Then, 4 local Meek rules (introduced in [17]) are repeatedly applied to the original DAG D with the new directions learnt from the cut to learn more till no more directed edges can be identified. Further application of CI-based algorithms on D will reveal no more information. The Meek rules are given below: (R1) (a\u2212 b) is oriented as (a \u2192 b) if \u2203c s.t. (c \u2192 a) and (c, b) /\u2208 E. (R2) (a\u2212 b) is oriented as (a \u2192 b) if \u2203c s.t. (a \u2192 c) and (c \u2192 b). (R3) (a\u2212 b) is oriented as (a \u2192 b) if \u2203c, d s.t. (a\u2212 c),(a\u2212 d),(c \u2192 b),(d \u2192 b) and (c, d) /\u2208 E. (R4) (a\u2212 c) is oriented as (a \u2192 c) if \u2203b, d s.t. (b \u2192 c),(a\u2212 d),(a\u2212 b),(d \u2192 b) and (c, d) /\u2208 E. The concepts of essential graphs and Markov equivalence classes are extended in [4] to incorporate the role of interventions: Let I = {I1, I2, ..., Im}, be a set of interventions and let the above process be followed after each intervention. Interventional Markov equivalence class (I equivalence) of a DAG is the set of DAGs that represent the same set of probability distributions obtained when the above process is applied after every intervention in I. It is denoted by [D]I . Similar to the observational case, I essential graph of a DAG D is the graph union of all DAGs in the same I equivalence class; it is denoted by EI(D). We have the following sequence:\nD \u2192 CI learning \u2192 Meek rules \u2192 E(D) \u2192 I1 a \u2192 learn by R0 b \u2192 Meek rules\n\u2192 E{I1}(D) \u2192 I2 . . . \u2192 E{I1,I2}(D) . . . (1)\nTherefore, after a set of interventions I has been performed, the essential graph EI(D) is a graph with some oriented edges that captures all the causal relations we have discovered so far, using I. Before any interventions happened E(D) captures the initially known causal directions. It is known that EI(D) is a chain graph with chordal chain components. Therefore when all the directed edges are removed, the graph becomes a set of disjoint chordal graphs."}, {"heading": "2.3 Problem Definition", "text": "We are interested in the following question:\n3Skeleton of a DAG is the undirected graph obtained when directed edges are converted to undirected edges. 4An induced subgraph on X, Y,Z is an immorality if X and Y are disconnected, X \u2192 Z and Z \u2190 Y . 5Graph union of two DAGs D1 = (V, E1) and D2 = (V, E2) with the same skeleton is a partially directed graph D = (V, E), where (va, vb) \u2208 E is undirected if the edges (va, vb) in E1 and E2 have different directions, and directed as va \u2192 vb if the edges (va, vb) in E1 and E2 are both directed as va \u2192 vb.\n6An undirected graph is chordal if it has no induced cycle of length greater than 3. 7This means that E(D) can be decomposed as a sequence of undirected chordal graphs G1, G2 . . . Gm (chain components) such that there is a\ndirected edge from a vertex in Gi to a vertex in Gj only if i < j\nProblem 1. Given that all interventions in I are of size at most k < n/2 variables, i.e., for each intervention I , |I| \u2264 k, \u2200I \u2208 I, minimize the number of interventions |I| such that the partially directed graph with all directions learned so far EI(D) = D.\nThe question is the design of an algorithm that computes the small set of interventions I given E(D). Note, of course, that the unknown directions of the edges D are not available to the algorithm. One can view the design of I as an active learning process to find D from the essential graph E(D). E(D) is a chain graph with undirected chordal components and it is known that interventions on one chain components do not affect the discovery process of directed edges in the other components [5]. So we will assume that E(D) is undirected and a chordal graph to start with. Our notion of algorithm does not consider the time complexity (of statistical algorithms involved) of steps a and b in (1). Given m interventions, we only consider efficiently computing Im+1 using (possibly) the graph E{I1,...Im}. We consider the following three classes of algorithms:\n1. Non-adaptive algorithm: The choice of I is fixed prior to the discovery process. 2. Adaptive algorithm: At every step m, the choice of Im+1 is a deterministic function of E{I1,...Im}(D). 3. Randomized adaptive algorithm: At every step m, the choice of Im+1 is a random function of E{I1,...Im}(D). The problem is different for complete graphs versus more general chordal graphs since rule R1 becomes applicable when the graph is not complete. Thus we give a separate treatment for each case. First, we provide algorithms for all three cases for learning the directions of complete graphs E(D) = Kn (undirected complete graph) on n vertices. Then, we generalize to chordal graph skeletons and provide a novel adaptive algorithm with upper and lower bounds on its performance.\nThe missing proofs of the results that follow can be found in the Appendix."}, {"heading": "3 Complete Graphs", "text": "In this section, we consider the case where the skeleton we start with, i.e. E(D), is an undirected complete graph (denoted Kn). It is known that at any stage in (1) starting from E(D), rules R1, R3 and R4 do not apply. Further, the underlying DAG D is a directed clique. The directed clique is characterized by an ordering \u03c3 on [1 : n] such that, in the subgraph induced by \u03c3(i), \u03c3(i + 1) . . . \u03c3(n), \u03c3(i) has no incoming edges. Let D be denoted by ~Kn(\u03c3) for some ordering \u03c3. Let [1 : n] denote the set {1, 2 . . . n}. We need the following results on a separating system for our first result regarding adaptive and non-adaptive algorithms for a complete graph."}, {"heading": "3.1 Separating System", "text": "Definition 1. [10,18] An (n, k)-separating system on an n element set [1 : n] is a set of subsets S = {S1, S2 . . . Sm} such that |Si| \u2264 k and for every pair i, j there is a subset S \u2208 S such that either i \u2208 S, j /\u2208 S or j \u2208 S, i /\u2208 S. If a pair i, j satisfies the above condition with respect to S, then S is said to separate the pair i, j. Here, we consider the case when k < n/2\nIn [10], Katona gave an (n, k)-separating system together with a lower bound on |S|. In [18], Wegener gave a simpler argument for the lower bound and also provided a tighter upper bound than the one in [10]. In this work, we give a different construction below where the separating system size is at most\u2308log\u2308n/k\u2309 n\u2309 larger than the construction of Wegener. However, our construction has a simpler description.\nLemma 1. There is a labeling procedure that produces distinct \u2113 length labels for all elements in [1 : n] using letters from the integer alphabet {0, 1 . . . a} where \u2113 = \u2308loga n\u2309. Further, in every digit (or position), any integer letter is used at most \u2308n/a\u2309 times.\nOnce we have a set of n string labels as in Lemma 1, our separating system construction is straightforward.\nTheorem 1. Consider an alphabet A = [0 : \u2308nk \u2309] of size \u2308 n k \u2309+1 where k < n/2. Label every element of an n element set using a distinct string of letters from A of length \u2113 = \u2308log\u2308n k \u2309 n\u2309 using the procedure in Lemma 1 with a = \u2308 n k \u2309. For every 1 \u2264 i \u2264 \u2113 and 1 \u2264 j \u2264 \u2308nk \u2309, choose the subset Si,j of vertices whose string\u2019s i-th letter is j. The set of all such subsets S = {Si,j} is a k-separating system on n elements and |S| \u2264 (\u2308nk \u2309)\u2308log\u2308nk \u2309 n\u2309."}, {"heading": "3.2 Adaptive algorithms: Equivalence to a Separating System", "text": "Consider any non-adaptive algorithm that designs a set of interventions I, each of size at most k, to discover ~Kn(\u03c3). I has to be a separating system in the worst case over all \u03c3. This is already known. Now, we prove the necessity of a separating system for deterministic adaptive algorithms in the worst case.\nTheorem 2. Let there be an adaptive deterministic algorithm A that designs the set of interventions I such that the final graph learnt EI(D) = ~Kn(\u03c3) for any ground truth ordering \u03c3 starting from the initial skeleton E(D) = Kn. Then, there exists a \u03c3 such that A designs an I which is a separating system.\nThe theorem above is independent of the individual intervention sizes. Therefore, we have the following theorem, which is a direct corollary of Theorem 2:\nTheorem 3. In the worst case over \u03c3, any adaptive or a non-adaptive deterministic algorithm on the DAG ~Kn(\u03c3) has to be such that nk lognek n \u2264 |I|. There is a feasible I with |I| \u2264 \u2308( n k \u2309 \u2212 1)\u2308log\u2308nk \u2309 n\u2309 Proof. By Theorem 2, we need a separating system in the worst case and the lower and upper bounds are from [10, 18]."}, {"heading": "3.3 Randomized Adaptive Algorithms", "text": "In this section, we show that that total number of variable accesses to fully identify the complete causal DAG is \u2126(n).\nTheorem 4. To fully identify a complete causal DAG ~Kn(\u03c3) on n variables using size-k interventions, n2k interventions are necessary. Also, the total number of variables accessed is at least n2 .\nThe lower bound in Theorem 4 is information theoretic. We now give a randomized algorithm that requires O(nk log log k) experiments in expectation. We provide a straightforward generalization of [8], where the authors gave a randomized algorithm for unbounded intervention size.\nTheorem 5. Let E(D) be Kn and the experiment size k = nr for some 0 < r < 1. Then there exists a randomized adaptive algorithm which designs an I such that EI(D) = D with probability polynomial in n, and |I| = O(nk log log(k)) in expectation."}, {"heading": "4 General Chordal Graphs", "text": "In this section, we turn to interventions on a general DAG G. After the initial stages in (1), E(G) is a chain graph with chordal chain components. There are no further immoralities throughout the graph. In this work, we focus on one of the chordal chain components. Thus the DAG D we work on is assumed to be a directed graph with no immoralities and whose skeleton E(D) is chordal. We are interested in recovering D from E(D) using interventions of size at most k following (1)."}, {"heading": "4.1 Bounds for Chordal skeletons", "text": "We provide a lower bound for both adaptive and non-adaptive deterministic schemes for a chordal skeleton E(D). Let \u03c7 (E(D)) be the coloring number of the given chordal graph. Since, chordal graphs are perfect, it is the same as the clique number.\nTheorem 6. Given a chordal E(D), in the worst case over all DAGs D (which has skeleton E(D) and no immoralities), if every intervention is of size at most k, then |I| \u2265 \u03c7(E(D))k log\u03c7(E(D))e\nk\n\u03c7 (E(D)) for any adaptive and non-adaptive\nalgorithm with EI(D) = D.\nUpper bound: Clearly, the separating system based algorithm of Section 3 can be applied to the vertices in the chordal skeleton E(D) and it is possible to find all the directions. Thus, |I| \u2264 nk log\u2308nk \u2309 n \u2264 \u03b1(E(D))\u03c7(E(D)) k log\u2308nk \u2309 n. This with the lower bound implies an \u03b1 approximation algorithm (since log\u2308n k \u2309 n \u2264 log\u03c7(E(D))e\nk\n\u03c7 (E(D)) , under a\nmild assumption \u03c7(E(D)) \u2264 ne ). Remark: The separating system on n nodes gives an \u03b1 approximation. However, the new algorithm in Section 4.3 exploits chordality and performs much better empirically. It is possible to show that our heuristic also has an \u03b1 approximation guarantee but we skip that."}, {"heading": "4.2 Two extreme counter examples", "text": "We provide two classes of chordal skeletons G: One for which the number of interventions close to the lower bound is sufficient and the other for which the number of interventions needed is very close to the upper bound.\nTheorem 7. There exists chordal skeletons such that for any algorithm with intervention size constraint k, the number of interventions |I| required is at least \u03b1 (\u03c7\u22121)2k where \u03b1 and \u03c7 are the independence number and chromatic numbers respectively. There exists chordal graph classes such that |I| = \u2308\u03c7k \u2309\u2308log\u2308\u03c7k \u2309 \u03c7\u2309 is sufficient."}, {"heading": "4.3 An Improved Algorithm using Meek Rules", "text": "In this section, we design an adaptive deterministic algorithm that anticipates Meek rule R1 usage along with the idea of a separating system. We evaluate this experimentally on random chordal graphs. First, we make a few observations on learning connected directed trees T from the skeleton E(T ) (undirected trees are chordal) that do not have immoralities using Meek rule R1 where every intervention is of size k = 1. Because the tree has no cycle, Meek rules R2-R4 do not apply.\nLemma 2. Every node in a directed tree with no immoralities has at most one incoming edge. There is a root node with no incoming edges and intervening on that node alone identifies the whole tree using repeated application of rule R1.\nLemma 3. If every intervention in I is of size at most 1, learning all directions on a directed tree T with no immoralities can be done adaptively with at most |I| \u2264 O(log2 n) where n is the number of vertices in the tree. The algorithm runs in time poly(n).\nLemma 4. Given any chordal graph and a valid coloring, the graph induced by any two color classes is a forest.\nIn the next section, we combine the above single intervention adaptive algorithm on directed trees which uses Meek rules, with that of the non-adaptive separating system approach."}, {"heading": "4.3.1 Description of the algorithm", "text": "The key motivation behind the algorithm is that, a pair of color classes is a forest (Lemma 4). Choosing the right node to intervene leaves only a small subtree unlearnt as in the proof of Lemma 3. In subsequent steps, suitable nodes in the remaining subtrees could be chosen until all edges are learnt. We give a brief description of the algorithm below.\nLet G denote the initial undirected chordal skeleton E(D) and let \u03c7 be its coloring number. Consider a (\u03c7, k) separating system S = {Si}. To intervene on the actual graph, an intervention set Ii corresponding to Si is chosen. We would like to intervene on a node of color c \u2208 Si.\nConsider a node v of color c. Now, we attach a score P (v, c) as follows. For any color c\u2032 /\u2208 Si, consider the induced forest F (c, c\u2032) on the color classes c and c\u2032 in G. Consider the tree T (v, c, c\u2032) containing node v in F . Let d(v) be the degree of v in T . Let T1, T2, . . . Td(v) be the resulting disjoint trees after node v is removed from T . If v is intervened on, according to the proof of Lemma 3: a) All edge directions in all trees Ti except one of them would be learnt when applying Meek Rules and rule R0. b) All the directions from v to all its neighbors would be found.\nThe score is taken to be the total number of edge directions guaranteed to be learnt in the worst case. Therefore,\nthe score P (v) is: P (v) = \u2211\nc\u2032:|c,c\u2032 \u22c2 |=1\n(\n|T (c, c\u2032)| \u2212 max 1\u2264j\u2264d(v) |Tj|\n)\n. The node with the highest score among the color\nclass c is used for the intervention Ii. After intervening on Ii, all the edges whose directions are known through Meek Rules (by repeated application till nothing more can be learnt) and R0 are deleted from G. Once S is processed, we recolor the sparser graph G. We find a new S with the new chromatic number on G and the above procedure is repeated. The exact hybrid algorithm is described in Algorithm 1.\nTheorem 8. Given an undirected choral skeleton G of an underlying directed graph with no immoralities, Algorithm 1 ends in finite time and it returns the correct underlying directed graph. The algorithm has runtime complexity polynomial in n.\nAlgorithm 1 Hybrid Algorithm using Meek rules with separating system 1: Input: Chordal Graph skeleton G = (V,E) with no Immoralities. 2: Initialize ~G(V,Ed = \u2205) with n nodes and no directed edges. Initialize time t = 1. 3: while E 6= \u2205 do 4: Color the chordal graph G with \u03c7 colors. \u22b2 Standard algorithms exist to do it in linear time 5: Initialize color set C = {1, 2 . . . \u03c7}. Form a (\u03c7,min(k, \u2308\u03c7/2\u2309)) separating system S such that |S| \u2264 k, \u2200S \u2208\nS. 6: for i = 1 until |S| do 7: Initialize Intervention It = \u2205. 8: for c \u2208 Si and every node v in color class c do 9: Consider F (c, c\u2032), T (c, c\u2032, v) and {Tj} d(i) 1 (as per definitions in Sec. 4.3.1).\n10: Compute: P (v, c) = \u2211\nc\u2032\u2208C \u22c2\nSc i\n|T (c, c\u2032, v)| \u2212 max 1\u2264j\u2264d(i) |Tj |.\n11: end for 12: if k \u2264 \u03c7/2 then 13: It = It \u22c3\nc\u2208Si\n{ argmax v:P (v,c) 6=0 P (v, c)}.\n14: else 15: It = It \u222ac\u2208Si{First k \u2308\u03c7/2\u2309 nodes v with largest nonzero P (v, c)}. 16: end if 17: t = t+ 1 18: Apply R0 and Meek rules using Ed and E after intervention It. Add newly learnt directed edges to Ed\nand delete them from E. 19: end for 20: Remove all nodes which have degree 0 in G. 21: end while 22: return ~G."}, {"heading": "5 Simulations", "text": "We simulate our new heuristic, namely Algorithm 1, on randomly generated chordal graphs and compare it with a naive algorithm that follows the intervention sets given by our (n, k) separating system as in Theorem 1. Both algorithms apply R0 and Meek rules after each intervention according to (1). We plot the following lower bounds: a) Information Theoretic LB of \u03c72k b) Max. Clique Sep. Sys. Entropic LB which is the chromatic number based lower bound of Theorem 6. Moreover, we use two known (\u03c7, k) separating system constructions for the maximum clique size as \u201creferences\u201d: The best known (\u03c7, k) separating system is shown by the label Max. Clique Sep. Sys. Achievable LB and our new simpler separating system construction (Theorem 1) is shown by Our Construction Clique Sep. Sys. LB. As an upper bound, we use the size of the best known (n, k) separating system (without any Meek rules) and is denoted Separating System UB.\nRandom generation of chordal graphs: Start with a random ordering \u03c3 on the vertices. Consider every vertex starting from \u03c3(n). For each vertex i, (j, i) \u2208 E with probability inversely proportional to \u03c3(i) for every j \u2208 Si where Si = {v : \u03c3\u22121(v) < \u03c3\u22121(i)}. The proportionality constant is changed to adjust sparsity of the graph. After all such j are considered, make Si \u2229 ne(i) a clique by adding edges respecting the ordering \u03c3, where ne(i) is the neighborhood of i. The resultant graph is a DAG and the corresponding skeleton is chordal. Also, \u03c3 is a perfect elimination ordering.\nResults: We are interested in comparing our algorithm and the naive one which depends on the (n, k) separating system to the size of the (\u03c7, k) separating system. The size of the (\u03c7, k) separating system is roughly O\u0303(\u03c7/k). Consider values around \u03c7 = 100 on the x-axis for the plots with n = 1000, k = 10 and n = 2000, k = 10. Note that, our algorithm performs very close to the size of the (\u03c7, k) separating system, i.e. O\u0303(\u03c7/k). In fact, it is always < 40 in both cases while the average performance of naive algorithm goes from 130 (close to n/k = 100) to 260 (close to n/k = 200). The result points to this: For random chordal graphs, the structured tree search allows us to learn the edges in a number of experiments quite close to the lower bound based only on the maximum clique size and not n. The plots for (n, k) = (500, 10) and (n, k) = (2000, 20) are given in Appendix."}, {"heading": "6 Conclusions", "text": "We have considered the problem of adaptively designing interventions of bounded size to learn a causal graph under Pearl\u2019s SEM-IE model. We proposed lower and upper bounds for the number of interventions needed in the worst case for various classes of algorithms, when the causal graph skeleton is complete. We developed lower and upper bounds on the minimum number of interventions required in the worst case for general graphs. We characterized two extremal graph classes such that the minimum number of interventions in one class is close to the lower bound and in the other class it is close to the upper bound. In the case of chordal skeletons, we proposed an algorithm that combines ideas for the complete graphs with the ones when the skeleton is a forest via application of Meek rules. Empirically, on randomly generated chordal graphs, our algorithm performs close to the lower bound and it outperforms the previous state of the art. Possible future work includes obtaining a tighter lower bound for chordal graphs that would possibly establish a tighter approximation guarantee for our algorithm."}, {"heading": "Acknowledgments", "text": "Authors acknowledge the support from grants: NSF CCF 1344179, 1344364, 1407278, 1422549 and a ARO YIP award (W911NF-14-1-0258). We also thank Frederick Eberhardt for helpful discussions."}, {"heading": "6.1 Proof of Lemma 1", "text": "We describe a string labeling procedure as follows to label elements of the set [1 : n]. String Labelling: Let a > 1 be a positive integer. Let x be the integer such that ax < n \u2264 ax+1. x+1 = \u2308loga n\u2309. Every element j \u2208 [1 : n] is given a label L(j) which is a string of integers of length x + 1 drawn from the alphabet {0, 1, 2 . . . a} of size a+1. Let n = pdad+ rd and n = pd\u22121ad\u22121+ rd\u22121 for some integers pd, pd\u22121, rd, rd\u22121, where rd < a\nd and rd\u22121 < ad\u22121. Now, we describe the sequence of the d-th digit across the string labels of all elements from 1 to n:\n1. Repeat 0 ad\u22121 times, repeat the next integer 1 ad\u22121 times and so on circularly 8 from {0, 1 . . . a\u2212 1} till pdad.\n2. After that, repeat 0 \u2308rd/a\u2309 times followed by 1 \u2308rd/a\u2309 times till we reach the nth position. Clearly, n-th integer in the sequence would not exceed a\u2212 1.\n3. Every integer occurring after the position ad\u22121pd\u22121 is increased by 1.\nFrom the three steps used to generate every digit, a straightforward calculation shows that every integer letter is repeated at most \u2308n/a\u2309 times in every digit i in the string. Now, we would like to prove inductively that the labels are distinct for all n elements. Let us assume the induction hypothesis: For all n < aq+1, the labels are distinct. The base case of q = 0 is easy to see. Then, we would like to show that for aq+1 \u2264 n < aq+2, the labels are distinct.\nAnother way of looking at the labeling procedure is as follows. Let n = aq+1p + r with r < aq+1. Divide the label matrix L (of dimensions (q + 2)\u00d7 n) into two parts, one L1 consisting of the first paq+1 columns and the other L2 consisting of the remaining columns. The first q + 1 rows of L1 is nothing but the string labels for all numbers from 0 to paq+1 expressed in base a. For any row i \u2264 \u2308loga r\u2309 in the original matrix L of labels, till the end of first paq+1 columns, the labeling procedure would be still in Step 1. After that, one can take r to be the new size of the set of elements to be labelled and then restart the procedure with this r. Therefore we have the following key observation: L2(1 : \u2308loga r\u2309, :) (the matrix with first \u2308loga r\u2309 rows of L2) is nothing but the label matrix for r distinct elements from the above labeling procedure.\nSince, r < aq+1, by the induction hypothesis, the columns are distinct. Hence, any two columns in L2 are distinct. Suppose the first q + 1 rows of two columns b and c of L1 are identical. These correspond to base a expansion of b\u2212 1 and c\u2212 1. They are separated by at least aq+1 + 1 columns. But the last row of columns b and p in L1 has to be distinct because according to Step 2 and Step 3 of the labeling procedure, in the q + 2th row, every integer is repeated at most \u2308n/a\u2309 \u2264 aq+1 times continuously, and only once. Therefore, any two columns in L1 are distinct. The last row entries in L1 are different from L2 because of the addition in Step 3. Therefore, all columns of L are distinct. Hence, by induction, the result is shown."}, {"heading": "6.2 Proof of Theorem 1", "text": "By Lemma 1, ith place has at most \u2308 n\u2308n/k\u2309\u2309 \u2264 k occurrences of symbol j. Therefore, |Si,j | \u2264 k. Now, consider the pair of distinct elements p, q \u2208 [1 : n]. Since they are labelled distinctly (Lemma 1), there is at least one letter i in their string labels where they differ. Suppose the distinct ith letters are a, b \u2208 A, a 6= b and let us say a 6= 0 without loss of generality. Then, clearly the separation criterion is met by the subset Si,a. This proves the claim."}, {"heading": "6.3 Proof of Theorem 2", "text": "We construct a worst case \u03c3 inductively. Before every step m, the adaptive algorithm deterministically chooses Im based on E{I1,I2...Im\u22121}(Kn). Therefore, we will reveal a partial order \u03c3\n(m\u22121) to satisfy the observations so far. Inductively for every m, we will make sure that after Im is chosen by the algorithm, further details about \u03c3 can be revealed to form \u03c3(m) such that after intervening on I2 and then applying R0, we will make sure there is no opportunity to apply the rule R2. This would make sure that I is a separating system on n elements.\nBefore intervention at any step m, let us \u2018tag\u2019 every vertex i using a subset C(m\u22121)i \u2286 [1 : m] such that C (m\u22121) i = {p : i \u2208 Ip, p \u2264 m \u2212 1}. C (m\u22121) i contains indices of all those interventions that contain vertex i before step m.\n8Circular means that after a\u2212 1 is completed, we start with 0 again.\nLet C(m\u22121) contain distinct elements of the multi-set {C(m\u22121)i } .We will construct \u03c3 partially such that it satisfies the following criterion always:\nInductive Hypothesis: The partial order \u03c3(m\u22121) is such that for any two elements i, j with Ci and Cj , i and j are incomparable if Ci = Cj and comparable otherwise. This means the edges between the elements tagged with the same tag C has not been revealed, and thus the relevant directed edges are not known by the algorithm.\nNow, we briefly digress to argue that if we could construct \u03c3(1), \u03c3(2) . . . satisfying such a property throughout, then clearly all vertices must be tagged differently otherwise the directions among the vertices that are tagged similarly cannot be learned by the algorithm. Therefore, the algorithm has not succeeded in its task. If all vertices are tagged differently, then it means it is a separating system.\nConstruction of \u03c3(m): We now construct \u03c3(m) that can be shown to satisfy the induction hypothesis before step m + 1. Before step m , consider the vertices in C \u2208 C(m\u22121) for any C. Let the current intervention be Im chosen by the deterministic algorithm. We make the following changes: Modify \u03c3(m\u22121) such that vertices in Im \u22c2\nC come before (Im)c \u22c2\nC in the partial order \u03c3(m) (vertices inside either sets are still not ordered amongst themselves) in the ordering and clearly the directions between these two sets are revealed by R0. By the induction hypothesis for step m and with the new tagging of vertices into C(m), it is easy to see that only directions between distinct C\u2032s in the new C(m) have been revealed and all directions within a tag set C are not revealed and all vertices in a tag set are contiguous in the ordering so far. We need to only show that rule R2 cannot reveal anymore edges amongst vertices in C \u2208 C(m) after the new \u03c3(m) and intervention Im. Suppose there are two vertices i, j such that just after intervention Im and the modified \u03c3(m), they are tagged identically and application of R2 reveals the direction between i and j before the next intervention. Then there has to be a vertex k tagged differently from i, j such that j \u2192 k and k \u2192 i are both known. But this implies that j and i are comparable in \u03c3(m) leading to a contradiction. This implies the hypothesis holds for step m+ 1.\nBase case: Trivially, the induction hypothesis holds for step 0 where \u03c3(0) leaves the entire set unordered."}, {"heading": "6.4 Proof of Lemma 2", "text": "The proof is a direct obvious consequence of acyclicity, non-existence of immoralities and the definition of rule R1."}, {"heading": "6.5 Proof of Lemma 3", "text": "By Lemma 2, it is sufficient for an algorithm to identify the root node of the tree. Suppose the root node is b unknown to the algorithm. Every tree has a single vertex separator that partitions the tree into components each of which has size at most 23n [11]. Choose that vertex separator a1 (it can be found in by removing every node and determining the components left). If it is a root node we stop here. Otherwise, its parent p1 (if it is not) after application of rule R0 is identified. Let us consider component trees T1, T2 . . . Tk that result by removing node a1. Let T1 contain p1. All directions in all other trees are known after repeated application of R1 on the original tree after R0 is applied. Directions in T1 will not be known. For the next step, E(T1) is the new skeleton which has no immoralities. Again, we find the best vertex separator a2 and the process continues. This procedure will terminate at some step j when aj = b or there is only one node left which should be b by Lemma 2. Since the number of nodes reduce by about 1/3 at least each time, and initially it can be at most n, this procedure terminates in at most O(log2 n) steps."}, {"heading": "6.6 Proof of Lemma 4", "text": "The graph induced by two colors classes in any graph is a bi-partite graph and bi-partite graphs do not have odd induced cycles. Since the graph and any induced subgraph is chordal, it implies the induced graph on a pair of color classes does not have a cycle. This proves the theorem."}, {"heading": "6.7 Proof of Theorem 4", "text": "Assume n is even for simplicity. We define a family of partial order \u03c3(p) as follows: Group i, i+ 1 into Ci. Ordering among i and i+1 is not revealed. But all the edges between Ci and Cj for any j > i are directed from Ci to Cj . Now, one has to design a set of interventions such that exactly one node among every Ci is intervened on at least once. This is because, if neither i nor i+1 in Ci are intervened on, then the direction between i and i+1 cannot be figured out by\napplying rule R2 on any other set of directions in the rest of the graph. Since the size of every intervention is at most k and at least n/2 nodes need to be covered by intervention sets, the number of interventions required is at least n2k ."}, {"heading": "6.8 Proof of Theorem 5", "text": "Proof. Separate n vertices arbitrarily into nk disjoint subsetsCi of size-k. Let the first n/k interventions {I1, I2, ..., In/k} be such that Ii(v) = 1 if and only if v \u2208 Ci. This divides the problem of learning a clique of size n into learning n/k cliques of size k. Then, we can apply the clique learning algorithm in [8] as a black box to each of the nk blocks: Each block is learned with probability k\u2212c after log c log k experiments in expectation. For k = cnr, choose c > 1/r \u2212 1. Then the union bound over n/k blocks yields probability polynomial in n. Since each block takes O(log log k) experiments, we need nkO(log log k) experiments."}, {"heading": "6.9 Proof of Theorem 6", "text": "We need the following definitions and some results before proving the theorem.\nDefinition 2. A perfect elimination ordering \u03c3p = {v1, v2 . . . vn} on the vertices of an undirected chordal graph G is such that for all i, the induced neighborhood of vi on the subgraph formed by {v1, v2 . . . vi\u22121} is a clique.\nLemma 5. ( [6]) If all directions in the chordal graph are according to perfect elimination ordering (edges go only from vertices lower in the order to higher in the order), then there are no immoralities.\nWe make the following observation: Let the directions in a graph D be oriented according to an ordering \u03c3 on the vertices. If a clique comes first in the ordering, then the knowledge of edge directions in the rest of the graph, excluding that of the clique, cannot help at any stage of the intervention process on the clique; because all the edges are directed outwards from the clique and hence none of the Meek rules apply. This is because, if a \u2192 b is to be inferred by Meek rules from other known directions, then either there has to be a known edge direction into a or b before the inference step. So if one of the directed edges not from the clique was to help in the discovery process, either that edge has to be directed towards a or b (like in Meek rules R1, R2 and R3), or it has to be directed towards c in another c \u2192 a (R4) which belongs to the clique. Both the above cases are not possible.\nLemma 6. ( [6]) Let C be a maximum clique of an undirected chordal graph E(D), then there is an underlying DAG D on the chordal skeleton that is oriented according to a perfect elimination ordering (implying no immoralities), where the clique C occurs first.\nBy Lemmas 5, 6 and the observation above, given a chordal skeleton, we can construct a DAG on the skeleton with no immoralities such that the directions of the maximum clique in D cannot be learned by using knowledge of the directions outside. This means that only the intervention sets {I1 \u22c2 C, I2 \u22c2\nC . . .} matter for learning the directions on this clique. Therefore inference on the clique is isolated. Hence, all the lower bounds for the clique case transfer to this case and since the size of the largest clique is exactly the coloring number of the chordal skeleton, the theorem follows."}, {"heading": "6.10 Proof of Theorem 7", "text": "Example with a feasible solution with |I| close to the lower bound: Consider a graph G that can be partitioned into a clique of size \u03c7 and an independent set \u03b1. Such graphs are called split graphs and as n \u2192 \u221e, the fraction of split graphs to chordal graphs tends to 1. If E(D) = G where G is a split graph skeleton, it is enough to intervene only on the nodes in the clique and therefore the number of interventions that are needed is that for the clique. It is certainly possible to orient the edges in such a way so as to avoid immoralities, since the graph is chordal.\nExample with |I| which needs to be close to the upper bound: We construct a connected chordal skeleton with independent set \u03b1 and clique size \u03c7 (also coloring number) such that it would require \u03b1(\u03c7\u22121)2k interventions at least for any algorithm over a class of orientations.\nConsider a line L consisting of vertices 1, 2 . . .2\u03b1 such that every node 1 < i < 2\u03b1 is connected to i\u22121 and i+1. For, all 1 \u2264 p \u2264 \u03b1, consider a clique Cp of size \u03c7 which only has nodes 2p \u2212 1, 2p from the line L. Now assume that the actual orientation of the L is 1 \u2192 2 . . . \u2192 2\u03b1. In every clique, the orientation is partially specified as follows: In every clique Cp, all edges from node 2p \u2212 1 are outgoing. It is very clear that this partial orientation excludes all\nimmoralities. Further, each clique Cp \u2212 {2p\u2212 1} can have any arbitrary orientation out of \u03c7\u2212 1 possible ones in the actual DAG. Now, even if all the specified directions are revealed to the algorithm, the algorithm has to intervene on all \u03b1 disjoint cliques {Cp \u2212 {2p\u2212 1}}\u03b1p=1 each of size \u03c7\u2212 1 and directions in one clique will not force directions on the others through any of the Meek rules or rule R0. Therefore, the lower bound of \u03b1(\u03c7\u22121)2 total node accesses (total number of nodes intervened) is implied by Theorem 4. Given every intervention is of size k, these chordal skeletons with the revealed partial order needs at least \u03b1(\u03c7\u22121)2k more experiments.\n6.11 Performance Comparison of Our Algorithm vs. Naive Scheme for n = 500, k = 10 and n = 2000, k = 20"}, {"heading": "6.12 Proof of Theorem 8", "text": "We provide the following justifications for the correctness of Algorithm 1.\n1. At line 4 of the algorithm, when Meek rules and R0 are applied after every intervention, the intermediate graph G, with unlearned edges, will always be a disjoint union of chordal components (refer to (1) and the comments below) and hence a chordal graph.\n2. The number of unlearned edges before and after the main while loop in Algorithm 1 reduces by at least one. Every edge in E is incident on two colors and one of the colors is always picked for processing because we use a separating system on the colors. Therefore, one node belonging to some edge has a positive score and is intervened on. The edge direction is learnt through rule R0. Therefore, the algorithm terminates.\n3. It identifies the correct ~G because every edge is inferred after some intervention It by applying rule R0 and Meek rules as in (1) both of which are correct.\n4. the algorithm has polynomial run time complexity because the main while loop ends in time |E|."}], "references": [{"title": "A characterization of markov equivalence classes for acyclic digraphs", "author": ["Steen A. Andersson", "David Madigan", "Michael D. Perlman"], "venue": "The Annals of Statistics,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1997}, {"title": "Causation and Intervention", "author": ["Frederick Eberhardt"], "venue": "(Ph.D. Thesis),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2007}, {"title": "Characterization and greedy learning of interventional markov equivalence classes of directed acyclic graphs", "author": ["Alain Hauser", "Peter B\u00fchlmann"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2012}, {"title": "Two optimal strategies for active learning of causal networks from interventional data", "author": ["Alain Hauser", "Peter B\u00fchlmann"], "venue": "In Proceedings of Sixth European Workshop on Probabilistic Graphical Models,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Two optimal strategies for active learning of causal models from interventional data", "author": ["Alain Hauser", "Peter B\u00fchlmann"], "venue": "International Journal of Approximate Reasoning,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2014}, {"title": "Nonlinear causal discovery with additive noise models", "author": ["Patrik O Hoyer", "Dominik Janzing", "Joris Mooij", "Jonas Peters", "Bernhard Sch\u00f6lkopf"], "venue": "In Proceedings of NIPS", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}, {"title": "Randomized experimental design for causal graph discovery", "author": ["Huining Hu", "Zhentao Li", "Adrian Vetta"], "venue": "In Proceedings of NIPS", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "Experiment selection for causal discovery", "author": ["Antti Hyttinen", "Frederick Eberhardt", "Patrik Hoyer"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "On separating systems of a finite set", "author": ["Gyula Katona"], "venue": "Journal of Combinatorial Theory,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1966}, {"title": "A separator theorem for planar graphs", "author": ["Richard J Lipton", "Robert Endre Tarjan"], "venue": "SIAM Journal on Applied Mathematics,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1979}, {"title": "Causal inference and causal explanation with background knowledge", "author": ["Christopher Meek"], "venue": "In Proceedings of the eleventh international conference on uncertainty in artificial intelligence,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1995}, {"title": "Strong completeness and faithfulness in bayesian networks", "author": ["Christopher Meek"], "venue": "In Proceedings of the eleventh international conference on uncertainty in artificial intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1995}, {"title": "Causality: Models, Reasoning and Inference", "author": ["Judea Pearl"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "A linear non-gaussian acyclic model for causal discovery", "author": ["S Shimizu", "P. O Hoyer", "A Hyvarinen", "A. J Kerminen"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2006}, {"title": "Causation, Prediction, and Search", "author": ["Peter Spirtes", "Clark Glymour", "Richard Scheines"], "venue": "A Bradford Book,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2001}, {"title": "An algorithm for deciding if a set of observed independencies has a causal explanation", "author": ["Thomas Verma", "Judea Pearl"], "venue": "In Proceedings of the Eighth international conference on uncertainty in artificial intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1992}, {"title": "On separating systems whose elements are sets of at most k elements", "author": ["Ingo Wegener"], "venue": "Discrete Mathematics,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1979}], "referenceMentions": [{"referenceID": 4, "context": "[2, 6, 8, 9, 14]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 6, "context": "[2, 6, 8, 9, 14]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 7, "context": "[2, 6, 8, 9, 14]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 12, "context": "[2, 6, 8, 9, 14]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 5, "context": "Given two causally related variables X and Y , it is not possible to infer whether X causes Y or Y causes X from random samples, unless certain assumptions are made on the distribution of E and/or on f [7, 15].", "startOffset": 202, "endOffset": 209}, {"referenceID": 13, "context": "Given two causally related variables X and Y , it is not possible to infer whether X causes Y or Y causes X from random samples, unless certain assumptions are made on the distribution of E and/or on f [7, 15].", "startOffset": 202, "endOffset": 209}, {"referenceID": 12, "context": "This process is different than conditioning as explained in detail in [14].", "startOffset": 70, "endOffset": 74}, {"referenceID": 4, "context": "[6] developed an efficient algorithm that minimizes this number in the worst case.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "Unfortunately, the interventions obtained in [6] can involve up to n/2 variables.", "startOffset": 45, "endOffset": 48}, {"referenceID": 1, "context": "Furthermore [3] shows that the set of interventions to fully identify a causal DAG must satisfy a specific set of combinatorial conditions called a separating system1, when the intervention size is not constrained or is 1.", "startOffset": 12, "endOffset": 15}, {"referenceID": 7, "context": "In [9], with the assumption that the same holds true for any intervention size, Hyttinen et al.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "One open problem is: If the learning algorithm is adaptive after each intervention, is a separating system still needed or can one do better? It was believed that adaptivity does not help in the worst case [3] and that one still needs a separating system.", "startOffset": 206, "endOffset": 209}, {"referenceID": 6, "context": "Recently [8] showed that randomized adaptive algorithms need only log log n interventions with high probability for the unbounded case.", "startOffset": 9, "endOffset": 12}, {"referenceID": 12, "context": "We adopt Pearl\u2019s structural equation model with independent errors (SEM-IE) in this work (see [14] for more details).", "startOffset": 94, "endOffset": 98}, {"referenceID": 14, "context": "All the CI relations that are learned statistically through observations can also be inferred from the Bayesian network using a graphical criterion called the d-separation [16] assuming that the distribution is faithful to the graph 2.", "startOffset": 172, "endOffset": 176}, {"referenceID": 11, "context": "Faithfulness is a widely accepted assumption, since it is known that only a measure zero set of distributions are not faithful [13].", "startOffset": 127, "endOffset": 131}, {"referenceID": 0, "context": "E(D) is always a chain graph with chordal6 chain components 7 [1].", "startOffset": 62, "endOffset": 65}, {"referenceID": 14, "context": "The d-separation criterion can be used to identify the skeleton and all the immoralities of the underlying causal DAG [16].", "startOffset": 118, "endOffset": 122}, {"referenceID": 15, "context": "Meek derived 3 local rules (Meek rules), introduced in [17], to be recursively applied to identify every such additional edge (see Theorem 3 of [12]).", "startOffset": 55, "endOffset": 59}, {"referenceID": 10, "context": "Meek derived 3 local rules (Meek rules), introduced in [17], to be recursively applied to identify every such additional edge (see Theorem 3 of [12]).", "startOffset": 144, "endOffset": 148}, {"referenceID": 12, "context": "This operation, and how it affects the joint distribution is formalized by the do operator by Pearl [14].", "startOffset": 100, "endOffset": 104}, {"referenceID": 14, "context": "parents of S [16], and the remaining adjacent edges in the original skeleton are declared to be the children.", "startOffset": 13, "endOffset": 17}, {"referenceID": 15, "context": "Then, 4 local Meek rules (introduced in [17]) are repeatedly applied to the original DAG D with the new directions learnt from the cut to learn more till no more directed edges can be identified.", "startOffset": 40, "endOffset": 44}, {"referenceID": 2, "context": "The concepts of essential graphs and Markov equivalence classes are extended in [4] to incorporate the role of interventions: Let I = {I1, I2, .", "startOffset": 80, "endOffset": 83}, {"referenceID": 3, "context": "E(D) is a chain graph with undirected chordal components and it is known that interventions on one chain components do not affect the discovery process of directed edges in the other components [5].", "startOffset": 194, "endOffset": 197}, {"referenceID": 8, "context": "[10,18] An (n, k)-separating system on an n element set [1 : n] is a set of subsets S = {S1, S2 .", "startOffset": 0, "endOffset": 7}, {"referenceID": 16, "context": "[10,18] An (n, k)-separating system on an n element set [1 : n] is a set of subsets S = {S1, S2 .", "startOffset": 0, "endOffset": 7}, {"referenceID": 8, "context": "In [10], Katona gave an (n, k)-separating system together with a lower bound on |S|.", "startOffset": 3, "endOffset": 7}, {"referenceID": 16, "context": "In [18], Wegener gave a simpler argument for the lower bound and also provided a tighter upper bound than the one in [10].", "startOffset": 3, "endOffset": 7}, {"referenceID": 8, "context": "In [18], Wegener gave a simpler argument for the lower bound and also provided a tighter upper bound than the one in [10].", "startOffset": 117, "endOffset": 121}, {"referenceID": 8, "context": "By Theorem 2, we need a separating system in the worst case and the lower and upper bounds are from [10, 18].", "startOffset": 100, "endOffset": 108}, {"referenceID": 16, "context": "By Theorem 2, we need a separating system in the worst case and the lower and upper bounds are from [10, 18].", "startOffset": 100, "endOffset": 108}, {"referenceID": 6, "context": "We provide a straightforward generalization of [8], where the authors gave a randomized algorithm for unbounded intervention size.", "startOffset": 47, "endOffset": 50}], "year": 2015, "abstractText": "We consider the problem of learning causal networks with interventions, when each intervention is limited in size under Pearl\u2019s Structural Equation Model with independent errors (SEM-IE). The objective is to minimize the number of experiments to discover the causal directions of all the edges in a causal graph. Previous work has focused on the use of separating systems for complete graphs for this task. We prove that any deterministic adaptive algorithm needs to be a separating system in order to learn complete graphs in the worst case. In addition, we present a novel separating system construction, whose size is close to optimal and is arguably simpler than previous work in combinatorics. We also develop a novel information theoretic lower bound on the number of interventions that applies in full generality, including for randomized adaptive learning algorithms. For general chordal graphs, we derive worst case lower bounds on the number of interventions. Building on observations about induced trees, we give a new deterministic adaptive algorithm to learn directions on any chordal skeleton completely. In the worst case, our achievable scheme is an \u03b1-approximation algorithm where \u03b1 is the independence number of the graph. We also show that there exist graph classes for which the sufficient number of experiments is close to the lower bound. In the other extreme, there are graph classes for which the required number of experiments is multiplicatively \u03b1 away from our lower bound. In simulations, our algorithm almost always performs very close to the lower bound, while the approach based on separating systems for complete graphs is significantly worse for random chordal graphs.", "creator": "LaTeX with hyperref package"}}}