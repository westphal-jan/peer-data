{"id": "1512.05467", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Dec-2015", "title": "Unsupervised Feature Construction for Improving Data Representation and Semantics", "abstract": "Feature-based format is the main data representation format used by machine learning algorithms. When the features do not properly describe the initial data, performance starts to degrade. Some algorithms address this problem by internally changing the representation space, but the newly-constructed features are rarely comprehensible. We seek to construct, in an unsupervised way, new features that are more appropriate for describing a given dataset and, at the same time, comprehensible for a human user. We propose two algorithms that construct the new features as conjunctions of the initial primitive features or their negations. The generated feature sets have reduced correlations between features and succeed in catching some of the hidden relations between individuals in a dataset. For example, a feature like $sky \\wedge \\neg building \\wedge panorama$ would be true for non-urban images and is more informative than simple features expressing the presence or the absence of an object. The notion of Pareto optimality is used to evaluate feature sets and to obtain a balance between total correlation and the complexity of the resulted feature set. Statistical hypothesis testing is used in order to automatically determine the values of the parameters used for constructing a data-dependent feature set. We experimentally show that our approaches achieve the construction of informative feature sets for multiple datasets.", "histories": [["v1", "Thu, 17 Dec 2015 05:18:05 GMT  (6915kb,D)", "http://arxiv.org/abs/1512.05467v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LG", "authors": ["marian-andrei rizoiu", "julien velcin", "st\\'ephane lallich"], "accepted": false, "id": "1512.05467"}, "pdf": {"name": "1512.05467.pdf", "metadata": {"source": "CRF", "title": "Unsupervised Feature Construction for Improving Data Representation and Semantics", "authors": ["Marian-Andrei Rizoiu", "Julien Velcin", "St\u00e9phane Lallich"], "emails": ["Marian-Andrei.Rizoiu@univ-lyon2.fr", "Julien.Velcin@univ-lyon2.fr", "Stephane.Lallich@univ-lyon2.fr"], "sections": [{"heading": null, "text": "Keywords Unsupervised feature construction \u00b7 Feature evaluation \u00b7 Nonparametric statistics \u00b7 Data mining \u00b7 Clustering \u00b7 Representations \u00b7 Algorithms for data and knowledge management \u00b7 Heuristic methods \u00b7 Pattern analysis\nMarian-Andrei Rizoiu \u00b7 Julien Velcin \u00b7 Ste\u0301phane Lallich ERIC Laboratory, University Lumie\u0300re Lyon 2 5, avenue Pierre Mende\u0300s France, 69676 Bron Cedex, France Tel. +33 (0)4 78 77 31 54 Fax. +33 (0)4 78 77 23 75\nMarian-Andrei Rizoiu E-mail: Marian-Andrei.Rizoiu@univ-lyon2.fr\nJulien Velcin E-mail: Julien.Velcin@univ-lyon2.fr\nSte\u0301phane Lallich E-mail: Stephane.Lallich@univ-lyon2.fr\nar X\niv :1\n51 2.\n05 46\n7v 1\n[ cs\n.A I]\n1 7\nD ec\n2 01"}, {"heading": "1 Introduction", "text": "Most machine learning algorithms use a representation space based on a feature-based format. This format is a simple way to describe an instance as a measurement vector on a set of predefined features. In the case of supervised learning, a class label is also available. One limitation of the feature-based format is that supplied features sometimes do not adequately describe, in terms of classification, the semantics of the dataset. This happens, for example, when general-purpose features are used to describe a collection that contains certain relations between individuals.\nIn order to obtain good results in classification tasks, many algorithms and preprocessing techniques (e.g., SVM (Cortes and Vapnik, 1995), PCA (Dunteman, 1989) etc.) deal with non-adequate variables by internally changing the description space. The main drawback of these approaches is that they function as a black box, where the new representation space is either hidden (for SVM) or completely synthetic and incomprehensible to human readers (PCA).\nThe purpose of our work is to construct a new feature set that is more descriptive for both supervised and unsupervised classification tasks. In the same way that frequent itemsets (Piatetsky-Shapiro, 1991) help users to understand the patterns in transactions, our goal with the new features is to help understand relations between individuals of datasets. Therefore, the new features should be easily comprehensible by a human reader. Literature proposes algorithms that construct features based on the original user-supplied features (called primitives). However, to our knowledge, all of these algorithms construct the feature set in a supervised way, based on the class information, supplied a priori with the data.\nIn order to construct new features, we propose two algorithms that create new feature sets in the absence of classified examples, in an unsupervised manner. The first algorithm is an adaptation of an established supervised algorithm, making it unsupervised. For the second algorithm, we have developed a completely new heuristic that selects, at each iteration, pairs of highly correlated features and replaces them with conjunctions of literals that do not co-occur. Therefore, the overall redundancy of the feature set is reduced. Later iterations create more complex Boolean formulas, which can contain negations (meaning absence of features). We use statistical considerations (hypothesis testing) to automatically determine the value of parameters depending on the dataset, and a Pareto front (Sawaragi et al, 1985)- inspired method for the evaluation. The main advantage of the proposed methods over PCA or the kernel of the SVM is that the newly-created features are comprehensible to human readers (features like people\u2227mani f estation\u2227 urban and people\u2227\u00acurban\u2227 f orest are easily interpretable).\nIn Sections 2 and 3, we present our proposed algorithms and in Section 4 we describe the evaluation metrics and the complexity measures. In Section 5, we perform a set of initial experiments and outline some of the inconveniences of the algorithms. In Section 6, by use of statistical hypothesis testing, we address these weak points, notably the choice of the threshold parameter. In Section 7, a second set of experiments validates the proposed improvements. Finally, Section 8 draws the conclusion and outlines future works.\n1.1 Motivation: why construct a new feature set\nIn the context of classification (supervised or unsupervised), a useful feature needs to portray new information. A feature p j, that is highly correlated with another feature pi, does\nnot bring any new information, since the value of p j can be deduced from that of pi. Subsequently, one could filter out \u201cirrelevant\u201d features before applying the classification algorithm. But by simply removing certain features, one runs the risk of losing important information of the hidden structure of the feature set, and this is the reason why we perform feature construction. Feature construction attempts to increase the expressive power of the original features by discovering missing information about relationships between features.\nWe deal primarily with datasets described with Boolean features. Any dataset described by using the feature-value format can be converted to a binary format using discretization and binarization. In real-life datasets, most binary features have specific meanings. Let us consider the example of a set of images that are tagged using Boolean features. Each feature marks the presence (true) or the absence (false) of a certain object in the image. These objects could include: water, cascade, mani f estation, urban, groups or interior. In this case, part of the semantic structure of the feature set can be guessed quite easily. Relations like \u201cis-a\u201d and \u201cpart-of\u201d are fairly intuitive: cascade is a sort of water, paw is part of animal etc. But other relations might be induced by the semantics of the dataset (images in our example). mani f estation will co-occur with urban, for they usually take place in the city. Fig. 1 depicts a simple image dataset described using the feature set {groups, road, building, interior}. The feature set is quite redundant and some of the features are non-informative (e.g., feature groups is present for all individuals). Considering co-occurrences between features, we could create the more eloquent features groups\u2227\u00acroad\u2227 interior (describing the top row) and groups\u2227 road\u2227building (describing the bottom row).\nThe idea is to create a data-dependent feature set, so that the new features are as independent as possible, limiting co-occurrences between the new features. At the same time they should be comprehensible to the human reader.\n1.2 Related work\nThe literature proposes methods for augmenting the descriptive power of features. Liu and Motoda (1998) collects some of them and divides them into three categories: feature selection, feature extraction and feature construction.\nFeature selection (Lallich and Rakotomalala, 2000; Mo and Huang, 2011) seeks to filter the original feature set in order to remove redundant features. This results in a representation space of lower dimensionality. Feature extraction is a process that extracts a set of new features from the original features through functional mapping (Motoda and Liu, 2002). For example, the SVM algorithm (Cortes and Vapnik, 1995) constructs a kernel function that changes the description space into a new separable one. Supervised and non-supervised algorithms can be boosted by pre-processing with principal component analysis (PCA) (Dunteman, 1989). PCA is a mathematical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of uncorrelated variables, called principal components. Manifold learning (Huo et al, 2005) can be seen as a classification approach where the representation space is changed internally in order to boost the performances. Feature extraction mainly seeks to reduce the description space and redundancy between features. Newly-created features are rarely comprehensible and very difficult to interpret. Both feature selection and feature extraction are inadequate for detecting relations between the original features.\nFeature Construction is a process that discovers missing information about the relationships between features and augments the space of features by inferring or creating additional features (Motoda and Liu, 2002). This usually results in a representation space with a larger dimension than the original space. Constructive induction (Michalski, 1983) is a process of constructing new features using two intertwined searches (Bloedorn and Michalski, 1998): one in the representation space (modifying the feature set) and another in the hypothesis space (using classical learning methods). The actual feature construction is done using a set of constructing operators and the resulted features are often conjunctions of primitives, therefore easily comprehensible to a human reader. Feature construction has mainly been used with decision tree learning. New features served as hypotheses and were used as discriminators in decision trees. Supervised feature construction can also be applied in other domains, like decision rule learning (Zheng, 1995).\nAlgorithm 1 General feature construction schema. Input: P \u2013 set of primitive user-given features Input: I \u2013 the data expressed using P which will be used to construct features\nInner parameters: Op \u2013 set of operators for constructing features, M \u2013 machine learning algorithm to be employed\nOutput: F \u2013 set of new (constructed and/or primitives) features. F \u2190 P iter\u2190 0 repeat\niter\u2190 iter+1 Iiter \u2190 convert(Iiter\u22121,F) out put\u2190 Run M(Iiter,F) F \u2190 F \u22c3 new feat. constructed with Op(F,out put)\nprune useless features in F until stopping criteria are met.\nAlgorithm 1, presented in Gomez and Morales (2002); Yang et al (1991), represents the general schema followed by most constructive induction algorithms. The general idea is to start from I, the dataset described with the set of primitive features. Using a set of constructors and the results of a machine learning algorithm, the algorithm constructs new features that are added to the feature set. In the end, useless features are pruned. These\nsteps are iterated until some stopping criterion is met (e.g., a maximum number of iterations performed or a maximum number of created features).\nMost constructive induction systems construct features as conjunctions or disjunctions of literals. Literals are the features or their negations. E.g., for the feature set {a,b} the literal set is {a,\u00aca,b,\u00acb}. Operator sets {AND,Negation} and {OR,Negation} are both complete sets for the Boolean space. Any Boolean function can be created using only operators from one set. FRINGE (Pagallo and Haussler, 1990) creates new features using a decision tree that it builds at each iteration. New features are conjunctions of the last two nodes in each positive path (a positive path connects the root with a leaf having the class label true). The newly-created features are added to the feature set and then used in the next iteration to construct the decision tree. This first algorithm of feature construction was initially designed to solve replication problems in decision trees.\nOther algorithms have further improved this approach. CITRE (Matheus, 1990) adds other search strategies like root (selects first two nodes in a positive path) or root-fringe (selects the first and last node in the path). It also introduces domain-knowledge by applying filters to prune the constructed features. CAT (Zheng, 1998) is another example of a hypothesis-driven constructive algorithm similar to FRINGE. It also constructs conjunctive features based on the output of decision trees. It uses a dynamic-path based approach (the conditions used to generate new features are chosen dynamically) and it includes a pruning technique.\nThere are alternative representations, other than conjunctive and disjunctive. The M-ofN and X-of-N representations use feature-value pairs. An feature-value pair AVk(Ai = Vi j) is true for an instance if and only if the feature Ai has the value Vi j for that instance. The difference between M-of-N and X-of-N is that, while the second one counts the number of true feature-value pairs, the first one uses a threshold parameter to assign a value of truth for the entire representation. The algorithm ID2\u2212o f \u22123 (Murphy and Pazzani, 1991) uses M-of-N representations for the newly-created features. It has a specialization and a generalization construction operator and it does not need to construct a new decision tree at each step, but instead integrates the feature construction in the decision tree construction. The Xo f N (Zheng, 1995) algorithm functions similarly, except that it uses the X-of-N representation. It also takes into account the complexity of the features generated.\nComparative studies like Zheng (1996) show that conjunctive and disjunctive representations have very similar performances in terms of prediction accuracy and theoretical complexity. M-of-N, while more complex, has a stronger representation power than the two before. The X-of-N representation has the strongest representation power, but the same studies show that it suffers from data fragmenting more than the other three.\nThe problem with all of these algorithms is that they all work in a supervised environment and they cannot function without a class label. In the following sections, we will propose two approaches towards unsupervised feature construction."}, {"heading": "2 uFRINGE - adapting FRINGE for unsupervised learning", "text": "We propose uFRINGE, an unsupervised version of FRINGE, one of the first feature construction algorithms. FRINGE (Pagallo and Haussler, 1990) is a framework algorithm (see Section 1.2), following the same general schema shown in Algorithm 1. It creates new features using a logical decision tree, created using a traditional algorithm like ID3 (Quinlan, 1986) or C4.5 (Quinlan, 1993). Taking a closer look at FRINGE, one would observe that its only component that is supervised is the decision tree construction. The actual construction\nof features is independent of the existence of a class attribute. Hence, using an unsupervised decision tree construction algorithm renders FRINGE unsupervised.\nClustering trees (Blockeel et al, 1998) were introduced as generalized logical decision trees. They are constructed using a top-down strategy. At each step, the cluster under a node is split into two, seeking to maximize the intra-cluster variance. The authors argue that supervised indicators, used in traditional decision trees algorithms, are special cases of intra-cluster variance, as they measure intra-cluster class diversity. Following this interpretation, clustering trees can be considered generalizations of decision trees and are suitable candidates for replacing ID3 in uFRINGE.\nAdapting FRINGE to use clustering trees is straightforward: it is enough to replace M in Algorithm 1 with the clustering trees algorithm. At each step, uFRINGE constructs a clustering tree using the dataset and the current feature set. Just like in FRINGE, new features are created using the conditions under the last two nodes in each path connecting the root to a leaf. FRINGE constructs new features starting only from positive leaves (leaves labelled true). But unlike decision trees, in classification trees the leaves are not labelled using class features. Therefore, uFRINGE constructs new features based on all paths from root to a leaf.\nNewly-constructed features are added to the feature set and used in the next classification tree construction. The algorithm stops when either no more features can be constructed from the clustering tree or when a maximum allowed number of features have already been constructed.\nLimitations. uFRINGE is capable of constructing new features in an unsupervised context. It is also relatively simple to understand and implement, as it is based on the same framework as FRINGE. However, it suffers from a couple of drawbacks. Constructed features tend to be redundant and contain doubles. Newly-constructed features are added to the feature set and are used, alongside old features, in later iterations. Older features are never removed from the feature set and they can be combined multiple times, thus resulting in doubles in the constructed feature set. What is more, old features can be combined with new features in which they already participated, therefore constructing redundant features (e.g., f2 and f1\u2227 f2\u2227 f3 resulting in f2\u2227 f1\u2227 f2\u2227 f3). Another limitation is controlling the number of constructed features. The algorithm stops when a maximum number of features are constructed. This is very inconvenient, as the dimension of the new feature set cannot be known in advance and is highly dependent on the dataset. Furthermore, constructing too many features leads to overfitting and an overly complex feature set. These shortcomings could be corrected by refining the constructing operator and by introducing a filter operator."}, {"heading": "3 uFC - a greedy heuristic", "text": "We address the limitations of uFRINGE by proposing a second, innovative approach. We propose an iterative algorithm that reduces the overall correlation of features of a dataset by iteratively replacing pairs of highly correlated features with conjunctions of literals. We use a greedy search strategy to identify the features that are highly correlated, then use a construction operator to create new features. From two correlated features fi and f j we create three new features: fi\u2227 f j, fi\u2227 f j and fi\u2227 f j. In the end, both fi and f j are removed from the feature set. The algorithm stops when no more new features are created or when it has performed a maximum number of iterations. The formalization and the different key\nparts of the algorithm (e.g., the search strategy,construction operators or feature pruning) will be presented in the next sections.\nFig. 2 illustrates visually, using Venn diagrams, how the algorithm replaces the old features with new ones. Features are represented as rectangles, where the rectangle for each feature contains the individuals having that feature set to true. Naturally, the individuals in the intersection of two rectangles have both features set to true. f1 and f2 have a big intersection, showing that they co-occur frequently. On the contrary, f2 and f5 have a small intersection, suggesting that their co-occurrence is less than that of the hazard (negatively correlated). f3 is included in the intersection of f1 and f2, while f4 has no common elements with any other. f4 is incompatible with all of the others.\nIn the first iteration, f1 and f2 are combined and 3 features are created: f1 \u2227 f2, f1 \u2227 f2 and f1 \u2227 f2. These new features will replace f1 and f2, the original ones. At the second iteration, f1 \u2227 f2 is combined with f3. As f3 is contained in f1 \u2227 f2, the feature f1\u2227 f2 \u2227 f3 will have a support equal to zero and will be removed. Note that f2 and f5 are never combined, as they are considered uncorrelated. The final feature set will be { f1 \u2227 f2, f1 \u2227 f2\u2227 f3, f1\u2227 f2\u2227 f3, f1\u2227 f2, f4, f5}\n3.1 uFC - the proposed algorithm\nWe define the set P = {p1, p2, ..., pk} of k user-supplied initial features and I = {i1, i2, ..., in} the dataset described using P. We start from the hypothesis that even if the primitive set P cannot adequately describe the dataset I, there is a data-specific feature set F = { f1, f2, ..., fm} that can be created in order to represent the data better. New features are iteratively created using conjunctions of primitive features or their negations (as seen in Fig. 2). Our algorithm does not use the output of a learning algorithm in order to create the new features. Instead we use a greedy search strategy and a feature set evaluation function that can determine if a newly-obtained feature set is more appropriate than the former one.\nThe schema of our proposal is presented in Algorithm 2. The feature construction is performed starting from the dataset I and the primitives P. The algorithm follows the general inductive schema presented in Algorithm 1. At each iteration, uFC searches for frequently co-occurring pairs in the feature set created at the previous iteration (Fiter\u22121). It determines the candidate set O and then creates new features as conjunctions of the highest scoring pairs. The new features are added to the current set (Fiter), after which the set is filtered in\nAlgorithm 2 uFC - Unsupervised feature construction Input: P \u2013 set of primitive user-given features Input: I \u2013 the data expressed using P which will be used to construct features\nInner parameters: \u03bb \u2013 correlation threshold for searching, limit iter \u2013 max no of iterations. Output: F \u2013 set of newly-constructed features.\nF0\u2190 P iter\u2190 0 repeat\niter\u2190 iter+1 O\u2190 search correlated pairs(Iiter,Fiter\u22121,\u03bb ) Fiter \u2190 Fiter\u22121 while O 6= /0 do\npair\u2190 highest scoring pair(O) Fiter \u2190 Fiter \u22c3 construct new feat(pair)\nremove candidate(O, pair) end while prune obsolete features(Fiter, Iiter) Iiter+1\u2190 convert(Iiter,Fiter)\nuntil Fiter = Fiter\u22121 OR iter = limit iter F \u2190 Fiter\norder to remove obsolete features. At the end of each iteration, the dataset I is translated to reflect the feature set Fiter. A new iteration is performed as long as new features were generated in the current iteration and a maximum number of iterations have not yet been reached (limit iter is a parameter for the algorithm).\n3.2 Searching co-occurring pairs\nThe search correlated pairs function searches for frequently co-occurring pairs of features in a feature set F . We start with an empty set O\u2190 /0 and we investigate all possible pairs of features { fi, f j} \u2208 F \u00d7F . We use a function (r) to measure the co-occurrence of a pair of features { fi, f j} and compare it to a threshold \u03bb . If the value of the function is above the threshold, then their co-occurrence is considered as significant and the pair is added to O. Therefore, O will be\nO = {{ fi, f j}|\u2200{ fi, f j} \u2208 F\u00d7F sothat r({ fi, f j})> \u03bb}\nThe r function is the empirical Pearson correlation coefficient, which is a measure of the strength of the linear dependency between two variables. r \u2208 [\u22121,1] and it is defined as the covariance of the two variables divided by the product of their standard deviations. The sign of the r function gives the direction of the correlation (inverse correlation for r < 0 and positive correlation for r > 0), while the absolute value or the square gives the strength of the correlation. A value of 0 implies that there is no linear correlation between the variables. When applied to Boolean variables, having the contingency table as shown in Table 1, the r function has the following formulation:\nr({ fi, f j}) = a\u00d7d\u2212b\u00d7 c\u221a\n(a+b)\u00d7 (a+ c)\u00d7 (b+d)\u00d7 (c+d)\nThe \u03bb threshold parameter will serve to fine-tune the number of selected pairs. Its impact on the behaviour of the algorithm will be studied in Section 5.3. A method of automatic choice of \u03bb using statistical hypothesis testing is presented in Section 6.1.\n3.3 Constructing and pruning features\nOnce O is constructed, uFC performs a greedy search. The function highest scoring pair is iteratively used to extract from O the pair { fi, f j} that has the highest co-occurrence score.\nThe function construct new feat constructs three new features: fi\u2227 f j, fi\u2227 f j and fi\u2227 f j. They represent, respectively, the intersection of the initial two features and the relative complements of one feature in the other. The new features are guaranteed by construction to be negatively correlated. If one of them is set to true for an individual, the other two will surely be false. At each iteration, very simple features are constructed: conjunctions of two literals. The creation of more complex and semantically rich features appears through the iterative process. fi and f j can be either primitives or features constructed in previous iterations.\nAfter the construction of features, the remove candidate function removes from O the pair { fi, f j}, as well as any other pair that contains fi of f j. When there are no more pairs in O, prune obsolete features is used to remove from the feature set two types of features:\n\u2013 features that are false for all individuals. These usually appear in the case of hierarchical relations. We consider that f1 and f2 have a hierarchical relation if all individuals that have feature f1 true, automatically have feature f2 true (e.g., f1 \u201cis a type of\u201d f2 or f1 \u201cis a part of\u201d f2). One of the generated features (in the example f1\u2227 f2) is false for all individuals and, therefore, eliminated. In the example of water and cascade, we create only water\u2227 cascade and water\u2227\u00accascade, since there cannot exist a cascade without water (considering that a value of false means the absence of a feature and not missing data). \u2013 features that participated in the creation of a new feature. Effectively, all { fi|{ fi, f j}\u2208 O, f j \u2208 F} are replaced by the newly-constructed features.\n{ fi, f j| fi, f j \u2208 F,{ fi, f j} \u2208 O} repl.\u2212\u2212\u2192 { fi\u2227 f j, fi\u2227 f j, fi\u2227 f j}"}, {"heading": "4 Evaluation of a feature set", "text": "To our knowledge, there are no widely accepted measures to evaluate the overall correlation between the features of a feature set. We propose a measure inspired from the \u201cinclusionexclusion\u201d principle (Feller, 1950). In set theory, this principle permits to express the cardinality of the finite reunion of finite ensembles by considering the cardinality of those ensembles and their intersections. In the Boolean form, it is used to estimate the probability of a clause (disjunction of literals) as a function of its composing terms (conjunctions of literals).\nGiven the feature set F = { f1, f2, ..., fm}, we have:\np( f1\u2228 f2\u2228 ...\u2228 fm) = m\n\u2211 k=1\n( (\u22121)k\u22121 \u2211\n1\u2264i1<...<ik\u2264m p( fi1 \u2227 fi2 \u2227 ...\u2227 fik)\n)\nwhich, by putting apart the first term, is equivalent to:\np( f1\u2228 f2\u2228 ...\u2228 fm) = m\n\u2211 i=1\np( fi)+ m\n\u2211 k=2\n( (\u22121)k\u22121 \u2211\n1\u2264i1<...<ik\u2264m p( fi1 \u2227 fi2 \u2227 ...\u2227 fik)\n)\nWithout loss of generality, we can consider that each individual has at least one feature set to true. Otherwise, we can create an artificial feature \u201cnull\u201d that is set to true when all the others are false. Consequently, the left side of the equation is equal to 1. On the right side, the second term is the probability of intersections of the features. Knowing that 1 \u2264 \u2211mi=1 p( fi) \u2264 m, this probability of intersection has a value of zero when all features are incompatible (no overlapping). It has a \u201cworst case scenario\u201d value of m\u2212 1, when all individuals have all the features set to true.\nBased on these observations, we propose the Overlapping Index evaluation measure:\nOI(F) = \u2211mi=1 p( fi)\u22121\nm\u22121\nwhere OI(F) \u2208 [0,1] and \u201cbetter\u201d towards zero. Hence, a feature set F1 describes a dataset better than another feature set F2 when OI(F1)< OI(F2).\n4.1 Complexity of the feature set.\nNumber of features Considering the case of the majority of machine learning datasets, where the number of primitives is inferior to the number of individuals in the dataset, reducing correlations between features comes at the expense of increasing the number of features. Consider the pair of features { fi, f j} judged correlated. Unless fi \u2287 f j or fi \u2286 f j, the algorithm will replace { fi, f j} by { fi \u2227 f j, fi \u2227 f j, fi \u2227 f j}, thus increasing the total number of features. A feature set that contains too many features is no longer informative, nor comprehensible. The maximum number of features that can be constructed is mechanically limited by the number of unique combinations of primitives in the dataset (the number of unique individuals).\n|F | \u2264 unique(I)\u2264 |I|\nwhere F is the constructed feature set and I is the dataset. To measure the complexity in terms of number of features, we use:\nC0(F) = |F |\u2212 |P|\nunique(I)\u2212|P|\nwhere P is the primitive feature set. C0 measures the ratio between how many extra features are constructed and the maximum number of features that can be constructed. 0 \u2264 C0 \u2264 1 and a value closer to 0 means a feature set less complex.\nThe average length of features At each iteration, simple conjunctions of two literals are constructed. Complex Boolean formulas are created by combining features constructed in previous iterations. Long and complicated expressions generate incomprehensible features, which are more likely a random side-effect rather than a product of underlying semantics.\nWe define C1 as the average number of literals (a primitive or its negation) that appear in a Boolean formula representing a new feature.\nP = {pi|pi \u2208 P}; L = P \u22c3 P\nC1(F) = \u2211 fi\u2208F |{l j|l j \u2208L , l j appears in fi}|\n|F | where P is the primitive set and 1\u2264C1 < \u221e.\nAs more iterations are performed, the feature set contains more features (C0 grows) which are increasingly more complex (C1 grows). This suggests a correlation between the two. What is more, since C1 can potentially double at each iteration and C0 can have at most a linear increase, the correlation is exponential. For this reason, in the following sections we shall use only C0 as the complexity measure.\nOverfitting All algorithms that learn from data risk overfitting the solution to the learning set. There are two ways in which uFC can overfit the resulted feature set, corresponding to the two complexity measures above: a) constructing too many features (measure C0) and b) constructing features that are too long (measure C1). The worst overfitting of type a) is when the algorithm constructs as many features as the maximum theoretical number (one for each individual in the dataset). The worst overfitting of type b) appears in the same conditions, where each constructed feature is a conjunction of all the primitives appearing for the corresponding individual. The two complexity measures can be used to quantify the two types of ovefitting. Since C0 and C1 are correlated, both types of overfitting appear simultaneously and can be considered as two sides of a single phenomenon.\n4.2 The trade-off between two opposing criteria\nC0 is a measure of how overfitted a feature set is. In order to avoid overfitting, feature set complexity should be kept at low values, while the algorithm optimizes the co-occurrence score of the feature set. Optimizing both the correlation score and the complexity at the same time is not possible, as they are opposing criteria. A compromise between the two must be achieved. This is equivalent to the optimization of two contrary criteria, which is a very well-known problem in multi-objective optimization. To acquire a trade-off between the two mutually contradicting objectives, we use the concept of Pareto optimality (Sawaragi et al, 1985), originally developed in economics. Given multiple feature sets, a set is considered to be Pareto optimal if there is no other set that has both a better correlation score and a better complexity for a given dataset. Pareto optimal feature sets will form the Pareto front. This means that no single optimum can be constructed, but rather a class of optima, depending on the ratio between the two criteria.\nWe plot the solutions in the plane defined by the complexity, as one axis, and the cooccurrence score, as the other. Constructing the Pareto front in this plane makes a visual evaluation of several characteristics of the uFC algorithm possible, based on the deviation of solutions compared to the front. The distance between the different solutions and the constructed Pareto front visually shows how stable the algorithm is. The convergence of the algorithm can be visually evaluated by how fast (in number of performed iterations) the algorithm transits the plane from the region of solutions with low complexity and high cooccurrence score to solutions with high complexity and low co-occurrence. We can visually evaluate overfitting, which corresponds to the region of the plane with high complexity and low co-occurence score. Solutions found in this region are overfitted.\nIn order to avoid overfitting, we propose the \u201cclosest-point\u201d heuristic for finding a compromise between OI and C0. We consider the two criteria to have equal importance. We consider as a good compromise, the solution in which the gain in co-occurrence score and the loss in complexity are fairly equal. If one of the indicators has a value considerably larger than the other, the solution is considered to be unsuitable. Such solutions would have either\na high correlation between features or a high complexity. Therefore, we perform a battery of tests and we search a posteriori the Pareto front for solutions for which the two indicators have essentially equal values. In the space of solutions, this translates into a minimal Euclidian distance between the solution and the ideal point (the point (0;0))."}, {"heading": "5 Initial Experiments", "text": "Throughout the experiments, uFC was executed by varying only the two parameters: \u03bb and limititer. We denote an execution with specific values for parameters as uFC(\u03bb , limititer), whereas the execution where the parameters were determined a posteriori using the \u201cclosestpoint\u201d strategy will be noted uFC*(\u03bb , limititer). For uFRINGE, the maximum number of features was set at 300. We perform a comparative evaluation of the two algorithms seen from a qualitative and quantitative point of view, together with examples of typical executions. Finally, we study the impact of the two parameters of uFC.\nExperiments were performed on three Boolean datasets. The hungarian dataset1 is a real-life collection of images, depicting Hungarian urban and countryside settings. Images were manually tagged using one or more of the 13 tags. Each tag represents an object that appears in the image (eg. tree, cascade etc.). The tags serve as features and a feature takes the value true if the corresponding object is present in the image or false otherwise. The resulted dataset contains 264 individuals, described by 13 Boolean features. Once the dataset was constructed, the images were not used any more. The street dataset2 was constructed in a similar way, starting from images taken from the LabelMe dataset (Russell et al, 2008). 608 urban images from Barcelona, Madrid and Boston were selected. Image labels were transformed into tags depicting objects by using the uniformization list provided with the toolbox. The dataset contains 608 individuals, described by 66 Boolean features.\nThe third dataset is \u201cSpect Heart\u201d3 from the UCI. The corpus is provided with a \u201cclass\u201d attribute and divided into a learning corpus and a testing one. We eliminated the class attribute and concatenated the learning and testing corpus into a single dataset. It contains 267 instances described by 22 Boolean features. Unlike the first two datasets, the features of spect have no specific meaning, being called \u201cF1\u201d, \u201cF2\u201d, ... , \u201cF22\u201d.\n1 http://eric.univ-lyon2.fr/~arizoiu/files/hungarian.txt 2 http://eric.univ-lyon2.fr/~arizoiu/files/street.txt 3 http://archive.ics.uci.edu/ml/datasets/SPECT+Heart\n5.1 uFC and uFRINGE: Qualitative evaluation\nFor the human reader, it is quite obvious why water and cascade have the tendency to appear together or why road and interior have the tendency to appear separately. One would expect, that based on a given dataset, the algorithms would succeed in making these associations and catching the underlying semantics. Table 2 shows the features constructed with uFRINGE and uFC*(0.194,2) on hungarian. A quick overview shows that constructed features manage to make associations that seem \u201clogical\u201d to a human reader. For example, one would expect the feature sky\u2227building\u2227 panorama to denote images where there is a panoramic view and the sky, but no buildings, therefore suggesting images outside the city. Fig. 3 supports this expectation. Similarly, the feature sky\u2227 building\u2227 groups\u2227 road covers urban images, where groups of people are present and water\u2227 cascade\u2227 tree\u2227 f orest denotes a cascade in the forest (Fig. 4).\nComprehension quickly deteriorates when the constructed feature set is overfitted, when the constructed features are too complex. The execution of uFC(0.184,5) reveals features like:\nsky\u2227building\u2227 tree\u2227building\u2227 f orest \u2227 sky\u2227building\u2227groups\u2227 road\u2227\nsky\u2227building\u2227 panorama\u2227groups\u2227 road\u2227 person\u2227 sky\u2227groups\u2227 road\nEven if the formula is not in the Disjunctive Normal Form (DNF), it is obvious that it is too complex to make any sense. If uFC tends to construct overly complex features, uFRINGE suffers from another type of dimensionality curse. Even if the complexity of features does not impede comprehension, the fact that there are over 300 hundred features constructed from 13 primitives makes the newly-constructed feature set unusable. The number of features is actually greater than the number of individuals in the dataset, which proves that some of the features are redundant. The actual correlation score of the newly-created feature set is even greater than the initial primitive set. What is more, new features present redundancy, just as predicted in section 2. For example, the feature water\u2227 f orest\u2227grass\u2227 water\u2227 person which contains two times the primitive water.\nThe same conclusions are drawn from execution on the street dataset. uFC*(0.322,2) creates comprehensible features. For example headlight\u2227windshield\u2227arm\u2227head (Fig. 5) suggests images in which the front part of cars appear. It is especially interesting how the algorithm specifies arm in conjunction with head in order to differenciate between people (head\u2227arm) and objects that have heads (but no arms).\n5.2 uFC and uFRINGE: Quantitative evaluation\nTable 3 shows, for the three datasets, the values of certain indicators, like the size of the feature set, the average length of a feature (C1), the OI and C0 indicators. For each dataset, we compare four feature sets: the initial feature set (primitives), the execution of uFC* (parameters determined by the \u201cclosest-point\u201d heuristic), uFC with another random set of\nparameters and uFRINGE. For the hungarian and street datasets, the same parameter combinations are used as in the qualitative evaluation.\nOn all three datasets, uFC* creates feature sets that are less correlated than the primitive sets, while the increase in complexity is only marginal. Very few (2-3) iterations are needed, as uFC converges very fast. Increasing the number of iterations has very little impact on OI, but results in very complex vocabularies (large C0 and feature lengths). In the feature set created by uFC(0.180,5) on street, on average, each feature contains more than 18 literals. This is obviously too much for human comprehension.\nFor uFRINGE, the OI indicator shows very marginal or no improvement on spect and hungarian datasets, and even a degradation on street (compared to the primitive set). Features constructed using this approach have an average length between 2.08 and 3.1 literals, just as much as the selected uFC* configuration. But, it constructs between 2.6 and 13.9 times more features than uFC*. We consider this to be due to the lack of filtering in uFRINGE, which would also explain the low OI score. Old features remain in the feature set and amplify the total correlation by adding the correlation between old and new features.\n5.3 Impact of parameters \u03bb and limititer\nIn order to understand the impact of parameters, we executed uFC with a wide range of values for \u03bb and limititer and studied the evolution of the indicators OI and C0. For each dataset, we varied \u03bb between 0.002 and 0.5 with a step of 0.002. For each value of \u03bb , we executed uFC by varying limititer between 1 and 30 for the hungarian dataset, and between 1 and 20 for street and spect. We study the evolution of the indicators as a function of limititer, respectively \u03bb , we plot the solution in the (OI,C0) space and construct the Pareto front.\nFor the study of limititer, we hold \u03bb fixed at various values and we vary only limititer. The evolution of the OI correlation indicator is given in Fig. 6a. As expected, the measure ameliorates with the number of iterations. OI has a very rapid descent and needs less than 10 iterations to converge on all datasets towards a value dependent on \u03bb . The higher the value of \u03bb , the higher the value of convergence. The complexity has a very similar evolution, but in the inverse direction: it increases with the number of iterations performed. It also converges\ntowards a value that is dependent on \u03bb : the higher the value of \u03bb , the lower the complexity of the resulting feature set.\nSimilarly, we study \u03bb by fixing limititer. Fig. 6b shows how OI evolves when varying \u03bb . As foreseen, for all values of limititer, the OI indicator increases with \u03bb , while C0 decreases with \u03bb . OI shows an abrupt increase between 0.2 and 0.3, for all datasets. For lower values of \u03bb , many pairs get combined as their correlation score is bigger than the threshold. As \u03bb increases, only highly correlated pairs get selected and this usually happens in the first iterations. Performing more iterations does not bring any change and indicators are less dependent on limititer. For hungarian, no pair has a correlation score higher than 0.4. Setting \u03bb higher than this value causes uFC to output the primitive set (no features are created).\nTo study Pareto optimality, we plot the generated solutions in the (OI, C0) space. Fig. 7a presents the distribution of solutions, the Pareto front and the solution chosen by the \u201cclosestpoint\u201d heuristic. The solutions generated by uFC with a wide range of parameter values are not dispersed in the solution space, but their distribution is rather close together. This shows good algorithm stability. Even if not all the solutions are Pareto optimal, none of them are too distant from the front and there are no outliers.\nMost of the solutions densely populate the part of the curve corresponding to low OI and high C0. As pointed out in the Section 4.2, the area of the front corresponding to high feature set complexity (high C0) represents the overfitting area. This confirms that the algorithm converges fast, then enters overfitting. Most of the improvement in quality is done in the first 2-3 iterations, while further iterating improves quality only marginally with the cost of an explosion of complexity. The \u201cclosest-point\u201d heuristic keeps the constructing out of overfitting, by stopping the algorithm at the point where the gain of co-occurence score and the loss in complexity are fairly equal. Fig. 7b magnifies the region of the solution space corresponding for low numbers of iterations.\n5.4 Relation between number of features and feature length\nBoth the average length of a feature (C1) and the number of features (C0) increase with the number of iterations. In Section 4.1 we have speculated that the two are correlated: C1 = f (C0). For each \u03bb in the batch of tests, we create the C0 and C1 series depending on the limititer and we perform a statistical hypothesis test, using the Kendall rank coefficient as the test statistic. The Kendall rank coefficient is particularly useful as it makes no assumptions about the distributions of C0 and C1. For all values of \u03bb , for all datasets, the statistical test revealed a p-value of the order of 10\u22129. This is consistently lower than habitually used significance levels and makes us reject the null independence hypothesis and conclude that C0 and C1 are statistically dependent."}, {"heading": "6 Improving the uFC algorithm", "text": "The major difficulty of uFC, shown by the initial experiments, is setting the values of parameters. An unfortunate choice would result in either an overly complex feature set or a feature set where features are still correlated. But both parameters \u03bb and limititer are dependent on the dataset and finding the suitable values would prove to be a process of trial and error for each new corpus. The \u201cclosest-point\u201d heuristic achieves acceptable equilibrium between complexity and performance, but requires multiple executions with large choices of values for parameters and the construction of the Pareto front, which might not always be desirable or even possible.\nWe propose a new method for choosing \u03bb based on statistical hypothesis testing and a new stopping criterion inspired from the \u201cclosest-point\u201d heuristic. These will be integrated into a new \u201crisk-based\u201d heuristic that approximates the best solution while avoiding the time consuming construction of multiple solutions and the Pareto front. The only parameter is the significance level \u03b1 , which is independent of the dataset, and makes the task of running uFC on new, unseen datasets easy. A pruning technique is also proposed.\n6.1 Automatic choice of \u03bb\nWe propose replacing the user-supplied co-occurrence threshold \u03bb with a technique that selects only pairs of features for whom the positive linear correlation is statistically significant. These pairs are added to the set O of co-occurring pairs (defined in Section 3.2) and, starting from O, new features are constructed. We use a statistical method: the hypothesis testing. For each pair of candidate features, we test the independence hypothesis H0 against the positive correlation hypothesis H1.\nWe use as a test statistic the Pearson correlation coefficient (calculated as defined in Section 3.2) and test the following formally defined hypothesis: H0 : \u03c1 = 0 and H1 : \u03c1 > 0, where \u03c1 is the theoretical correlation coefficient between two candidate features. We can show that in the case of Boolean variables, having the contingency table shown in Table 1, the observed value of the \u03c72 of independence is \u03c72obs = nr\n2 (n is the size of the dataset). Consequently, considering true the hypothesis H0, nr2 is approximately following a \u03c72 distribution with one degree of freedom (nr2 \u223c \u03c721 ), resulting in r \u221a n following a standard\nnormal distribution (r \u221a\nn\u223c N(0,1)), given that n is large enough. We reject the H0 hypothesis in favour of H1 if and only if r \u221a n \u2265 u1\u2212\u03b1 , where u1\u2212\u03b1 is the right critical value for the standard normal distribution. Two features will be considered significantly correlated when r({ fi, f j}) \u2265 u1\u2212\u03b1\u221an . The significance level \u03b1 represents the risk of rejecting the independence hypothesis when it was in fact true. It can be interpreted as the false discovery risk in data mining. In the context of feature construction it is the false construction risk, since this is the risk of constructing new features based on a pair of features that are not really correlated. Statistical literature usually sets \u03b1 at 0.05 or 0.01, but levels of 0.001 or even 0.0001 are often used.\nThe proposed method repeats the independence test a great number of times, which inflates the number of type I errors. Ge et al (2003) presents several methods for controlling the false discoveries. Setting aside the Bonferroni correction, often considered too simplistic and too drastic, one has the option of using sequential rejection methods (Benjamini and Liu, 1999; Holm, 1979), the q-value method of Storey (Storey, 2002) or making use of bootstrap (Lallich et al, 2006). In our case, applying these methods is not clear-cut, as tests performed at each iteration depend on the results of the tests performed at previous iterations. It is noteworthy that a trade-off must be acquired between the inflation of false discoveries and the inflation of missed discoveries. This makes us choose a risk between 5% and 5%m , where m is the theoretical number of tests to be performed.\n6.2 Candidate pruning technique. Stopping criterion.\nPruning In order to apply the \u03c72 independence test, it is necessary that the expected frequencies considering true the H0 hypothesis be greater or equal than 5. We add this constraint to the new feature search strategy (subsection 3.2). Pairs for whom the values of (a+b)(a+c)n , (a+b)(b+c)\nn , (a+c)(c+d) n and (b+d)(c+d)\nn are not greater than 5, will be filtered from the set of candidate pairs O. This will impede the algorithm from constructing features that are present for very few individuals in the dataset.\nRisk-based heuristic We introduced in Section 4.2 the \u201cclosest-point\u201d for choosing the values for parameters \u03bb and limititer. It searches the solution on the Pareto front for which the indicators are sensibly equal. We transform the heuristic into a stopping criterion: OI and C0 are combined into a single formula, the root mean square (RMS). The algorithm will\nstop iterating when RMS has reached a minimum. Using the generalized mean inequality, we can prove that RMS(OI,C0) has only one global minimum, as with each iteration the complexity increases and OI descends.\nThe limititer parameter, which is data-dependent, is replaced by the automatic RMS stopping criterion. This stopping criterion together with the automatic \u03bb choice strategy, presented in Section 6.1, form a data-independent heuristic for choosing parameters. We will call the new heuristic risk-based heuristic. This new heuristic will make it possible to approximate the best parameter compromise and avoid the time consuming task of computing a batch of solutions and constructing the Pareto front."}, {"heading": "7 Further Experiments", "text": "We test the proposed ameliorations, similarly to what was shown in Section 5, on the same three datasets: hungarian, spect and street. We execute uFC in two ways: the classical uFC (Section 3) and the improved uFC (Section 6). The classical uFC needs to have parameters \u03bb and limititer set (noted uFC(\u03bb , limititer)). uFC*(\u03bb , limititer) denotes the execution with parameters which were determined a posteriori using the \u201cclosest-point\u201d heuristic. The improved uFC will be denoted as uFC\u03b1 (risk). The \u201crisk-based\u201d heuristic will be used to determine the parameters and control the execution.\n7.1 Risk-based heuristic for choosing parameters\nRoot Mean Square In the first batch of experiments, we study the variation of the Root Means Square aggregation function for a series of selected values of \u03bb . We vary limititer between 0 and 30, for hungarian, and between 0 and 20 for spect and street. The evolution of RMS is presented in Fig. 8.\nFor all \u03bb the RMS starts by decreasing, as OI descends more rapidly than the C0 increases. In just 1-3 iterations, RMS reaches its minimum and afterwards its value starts to increase. This is due to the fact that complexity increases rapidly, with only marginal improvement of quality. This behaviour is consistent with the results presented in Section 5. As\nalready discussed in Section 5.3, \u03bb has a bounding effect over complexity, thus explaining why RMS reaches a maximum for higher values of \u03bb .\nThe \u201crisk-based\u201d heuristic The second batch of experiments deals with comparing the \u201crisk-based\u201d heuristic to the \u201cclosest-point\u201d heuristic. The \u201cclosest-point\u201d was determined as described in Section 5. The \u201crisk-based\u201d heuristic was executed multiple times, with values for parameter \u03b1 \u2208 {0.05, 0.01, 0.005, 0.001, 0.0008, 0.0005, 0.0003, 0.0001, 0.00005, 0.00001}\nTable 4 gives a quantitative comparison between the two heuristics. A risk of 0.001 is used for hungarian and 0.0001 for spect and street. The feature sets created by the two approaches are very similar, considering all indicators. Not only the differences between values for OI, C0, average feature length and feature set dimension are negligible, but most of the created features are identical. On hungarian, 19 of the 21 features created by the two heuristics are identical. Table 5 shows the two features sets, with non-identical features in bold.\nFig. 9 presents the distribution of solutions created by the \u201crisk-based\u201d heuristic with multiple \u03b1 , plotted on the same graphics as the Pareto front in the (OI, C0) space. Solutions for different values of risk \u03b1 are grouped closely together. Not all of them are on the\nTable 5: Feature sets constructed by \u201cclosest-point\u201d and \u201crisk-based\u201d heuristics on\nhungarian\nprimitives uFC*(0.194, 2) uFC\u03b1 (0.001)\nperson groups\u2227 road\u2227 interior groups\u2227 road\u2227 interior groups groups\u2227 road\u2227 interior groups\u2227 road\u2227 interior water groups\u2227 road\u2227 interior groups\u2227 road\u2227 interior cascade water\u2227 cascade\u2227 tree\u2227 f orest water\u2227 cascade\u2227 tree\u2227 f orest sky water\u2227 cascade\u2227 tree\u2227 f orest water\u2227 cascade\u2227 tree\u2227 f orest tree water\u2227 cascade\u2227 tree\u2227 f orest water\u2227 cascade\u2227 tree\u2227 f orest grass sky\u2227building\u2227 tree\u2227 f orest sky\u2227building\u2227 tree\u2227 f orest f orest sky\u2227building\u2227 tree\u2227 f orest sky\u2227building\u2227 tree\u2227 f orest statue sky\u2227building\u2227 tree\u2227 f orest sky\u2227building\u2227 tree\u2227 f orest building sky\u2227building\u2227 panorama sky\u2227building\u2227 panorama road sky\u2227building\u2227 panorama sky\u2227building\u2227 panorama interior sky\u2227building\u2227 panorama sky\u2227building\u2227 panorama panorama groups\u2227 road\u2227 person groups\u2227 road\u2227 person\ngroups\u2227 road\u2227 person groups\u2227 road\u2227 person groups\u2227 road\u2227 person groups\u2227 road\u2227 person water\u2227 cascade sky\u2227building\u2227groups\u2227 road sky\u2227building sky\u2227building\u2227groups\u2227 road tree\u2227 f orest sky\u2227building\u2227groups\u2227 road groups\u2227 road water\u2227 cascade grass tree\u2227 f orest statue grass\nstatue\nPareto front, but they are never too far from the \u201cclosest-point\u201d solution, providing a good equilibrium between quality and complexity.\nOn street, performances of the \u201crisk-based\u201d heuristic start to degrade compared to uFC*. Table 4 shows differences in the resulted complexity and only 33% of the constructed features are common for the two approaches. Fig. 10a shows that solutions found by the \u201crisk-based\u201d approach are moving away from the \u201cclosest-point\u201d. The cause is the large size of the street dataset. As the sample size increases, the null hypothesis tends to be rejected at lower levels of p-value. The auto-determined \u03bb threshold is set too low and the constructed feature sets are too complex. Pruning solves this problem as shown in Fig. 10b and Section 7.2.\n7.2 Pruning the candidates\nThe pruning technique is independent of the \u201crisk-based\u201d heuristic and can be applied in conjunction with the classical uFC algorithm. An execution of this type will be denoted uFCP(\u03bb ,maxiter). We execute uFCP(\u03bb ,maxiter) with the same parameters and on the same datasets as described in Section 5.3.\nWe compare uFC with and without pruning by plotting on the same graphic the two Pareto fronts resulted from each set of executions. Fig. 11a shows the pruned and nonpruned Pareto fronts on hungarian. The graphic should be interpreted in a manner similar to a ROC curve, since the algorithm seeks to minimize OI and C0 at the same time. When one Pareto front runs closer to the origin of the graphic (0,0) than a second, it means that the first dominates the second one and, thus, its corresponding approach yields better results. For all datasets, the pruned Pareto front dominates the non-pruned one. The difference is marginal, but proves that filtering improves results.\nThe most important conclusion is that filtering limits complexity. As the initial experiments (Fig. 7a) showed, most of the non-pruned solutions correspond to very high complexities. Visually, the Pareto front is tangent to the vertical axis (the complexity) and showing complexities around 0.8\u22120.9 (out of 1). On the other hand, the Pareto front corresponding\nto the pruned approach stops, for all datasets, for complexities lower than 0.15. This proves that filtering successfully discards solutions that are too complex to be interpretable.\nLast, but not least, filtering corrects the problem of automatically choosing \u03bb for the \u201crisk-based\u201d heuristic on big datasets. We ran uFCP with risk \u03b1 \u2208 {0.05, 0.01, 0.005, 0.001, 0.0008, 0.0005, 0.0003, 0.0001, 0.00005, 0.00001}. Fig. 10b presents the distributions of solutions found with the \u201crisk-based pruned\u201d heuristic on street. Unlike results without pruning (Fig. 10a), solutions generated with pruning are distributed closely to those generated by \u201cclosest-point\u201d and to the Pareto front.\n7.3 Algorithm stability\nIn order to evaluate the stability of the uFC\u03b1 algorithm, we introduce noise in the hungarian dataset. The percentage of noise varied between 0% (no noise) and 30%. Introducing a certain percentage x% of noise means that x%\u00d7 k\u00d7 n random features in the datasets are inverted (false becomes true and true becomes false). k is the number of primitives and n is the number of individuals. For each given noise percentage, 10 noised datasets are created and only the averages are presented. uFC\u03b1 is executed for all the noised datasets, with the same combination of parameters (risk = 0.001 and no filtering).\nThe stability is evaluated using five indicators:\n\u2013 Overlapping Index; \u2013 Feature set complexity (C0); \u2013 Number of features: the total number of features constructed by the algorithm; \u2013 Common with zero noise: the number of identical features between the feature sets\nconstructed based on the noised datasets and the non-noised dataset. This indicator evaluates the measure in which the algorithm is capable of constructing the same features, even in the presence of noise; \u2013 Common between runs: the average number of identical features between feature sets constructed using datasets with the same noise percentage. This indicator evaluates how much the constructed feature sets differ at the same noise level.\nAs the noise percentage augments, the dataset becomes more random. Less pairs of primitives are considered as correlated and therefore less new features are created. Fig. 12a shows that the overlapping indicator increases with the noise percentage, while the complexity decreases. Furthermore, most features in the initial dataset are set to false. As the percentage of noise increases, the ratio equilibrates (more false values becoming true, than the contrary). As a consequence, for high noise percentages, the OI score is higher than for the primitive set.\nThe same conclusions can be drawn from Fig. 12b. The indicator Number of features descends when the noise percentage increases. This is because fewer features are constructed and the resulting feature set is very similar to the primitive set. The number of constructed features stabilizes around 20% of noise. This is the point where most of the initial correlation between features is lost. Common with zero noise has a similar evolution. The number of features identical to the non-noised dataset descends quickly and stabilizes around 20%. After 20%, all the identical features are among the initial primitives. Similarly, the value of Common between runs descends at first. For small values of introduced noise, the correlation between certain features is reduced, modifying the order in which pairs of correlated features are selected in Algorithm 2. This results in a diversity of constructed feature sets. As the noise level increases and the noised datasets become more random, the constructed feature sets resemble the primitive set, therefore augmenting the value of Common between runs."}, {"heading": "8 Conclusion and future work", "text": "In this article, we propose two approaches towards feature construction. Unlike the other feature construction algorithms proposed so far in the literature, our proposals work in an unsupervised learning paradigm. uFRINGE is an unsupervised adaptation of the FRINGE algorithm, while uFC is a new approach that replaces linearly correlated features with conjunctions of literals. We prove that our approaches succeed in reducing the overall correlation in the feature set, while constructing comprehensible and interpretable features. We have performed extensive experiments to highlight the impact of parameters on the total correlation measure and feature set complexity. Based on the first set of experiments, we have proposed a heuristic that finds a suitable balance between quality and complexity and avoids time consuming multiple executions, followed by a Pareto front construction. We use statistical hypothesis testing and confidence levels for parameter approximation and reasoning on the Pareto front of the solutions for evaluation. We also propose a pruning technique, based on hypothesis testing, that limits the complexity of the generated features and speeds up the construction process.\nFor future development, we consider taking into account non-linear correlation between variables by modifying the metric of the search and the co-occurence measure. Another research direction will be adapting our algorithms for data of the Web 2.0 (e.g., automatic treatment of labels on the web). Several challenges arise, like very large label sets (it is common to have over 10 000 features), non-standard label names (see standardization preprocessing task that we have performed for the LabelMe dataset in Section 5) and missing data (a value of false can mean absence or missing data). We also consider converting generated features to the Disjunctive Normal Form for easier reading and suppressing features that have a low support in the dataset. This would reduce the size of the feature set by removing rare features, but would introduce new difficulties such as detecting nuggets."}], "references": [{"title": "A step-down multiple hypotheses testing procedure that controls the false discovery rate under independence", "author": ["Y Benjamini", "W Liu"], "venue": "Journal of Statistical Planning and Inference", "citeRegEx": "Benjamini and Liu,? \\Q1999\\E", "shortCiteRegEx": "Benjamini and Liu", "year": 1999}, {"title": "Top-down induction of clustering trees", "author": ["H Blockeel", "L De Raedt", "J Ramon"], "venue": "Proceedings of the 15th International Conference on Machine Learning,", "citeRegEx": "Blockeel et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Blockeel et al\\.", "year": 1998}, {"title": "Data-driven constructive induction", "author": ["E Bloedorn", "RS Michalski"], "venue": "Intelligent Systems and their Applications", "citeRegEx": "Bloedorn and Michalski,? \\Q1998\\E", "shortCiteRegEx": "Bloedorn and Michalski", "year": 1998}, {"title": "Support-vector networks. Machine learning", "author": ["C Cortes", "V Vapnik"], "venue": null, "citeRegEx": "Cortes and Vapnik,? \\Q1995\\E", "shortCiteRegEx": "Cortes and Vapnik", "year": 1995}, {"title": "An introduction to probability theory and its applications", "author": ["W Feller"], "venue": null, "citeRegEx": "Feller,? \\Q1950\\E", "shortCiteRegEx": "Feller", "year": 1950}, {"title": "Resampling-based multiple testing for microarray data analysis", "author": ["Y Ge", "S Dudoit", "TP Speed"], "venue": null, "citeRegEx": "Ge et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Ge et al\\.", "year": 2003}, {"title": "Automatic feature construction and a simple rule induction algorithm for skin detection", "author": ["G Gomez", "E Morales"], "venue": "Proc. of the ICML workshop on Machine Learning in Computer Vision,", "citeRegEx": "Gomez and Morales,? \\Q2002\\E", "shortCiteRegEx": "Gomez and Morales", "year": 2002}, {"title": "A simple sequentially rejective multiple test procedure. Scandinavian journal of statistics pp", "author": ["S Holm"], "venue": null, "citeRegEx": "Holm,? \\Q1979\\E", "shortCiteRegEx": "Holm", "year": 1979}, {"title": "A survey of manifold-based learning methods. Mining of Enterprise Data pp", "author": ["X Huo", "XS Ni", "AK Smith"], "venue": null, "citeRegEx": "Huo et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Huo et al\\.", "year": 2005}, {"title": "Fast feature selection using partial correlation for multivalued attributes", "author": ["S Lallich", "R Rakotomalala"], "venue": "Proceedings of the 4th European Conference on Principles of Data Mining and Knowledge Discovery, LNAI Springer-Verlag,", "citeRegEx": "Lallich and Rakotomalala,? \\Q2000\\E", "shortCiteRegEx": "Lallich and Rakotomalala", "year": 2000}, {"title": "Statistical inference and data mining: false discoveries control. In: COMPSTAT: proceedings in computational statistics: 17th symposium", "author": ["S Lallich", "O Teytaud", "E Prudhomme"], "venue": null, "citeRegEx": "Lallich et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Lallich et al\\.", "year": 2006}, {"title": "Feature extraction, construction and selection: A data mining perspective", "author": ["H Liu", "H Motoda"], "venue": null, "citeRegEx": "Liu and Motoda,? \\Q1998\\E", "shortCiteRegEx": "Liu and Motoda", "year": 1998}, {"title": "Adding domain knowledge to sbl through feature construction", "author": ["CJ Matheus"], "venue": "Proceedings of the Eighth National Conference on Artificial Intelligence,", "citeRegEx": "Matheus,? \\Q1990\\E", "shortCiteRegEx": "Matheus", "year": 1990}, {"title": "A theory and methodology of inductive learning", "author": ["RS Michalski"], "venue": "Artificial Intelligence", "citeRegEx": "Michalski,? \\Q1983\\E", "shortCiteRegEx": "Michalski", "year": 1983}, {"title": "Feature selection based on inference correlation. Intelligent Data Analysis", "author": ["D Mo", "SH Huang"], "venue": null, "citeRegEx": "Mo and Huang,? \\Q2011\\E", "shortCiteRegEx": "Mo and Huang", "year": 2011}, {"title": "Feature selection, extraction and construction", "author": ["H Motoda", "H Liu"], "venue": "Communication of IICM (Institute of Information and Computing", "citeRegEx": "Motoda and Liu,? \\Q2002\\E", "shortCiteRegEx": "Motoda and Liu", "year": 2002}, {"title": "Id2-of-3: Constructive induction of m-of-n concepts for discriminators in decision trees", "author": ["PM Murphy", "MJ Pazzani"], "venue": "Proceedings of the Eighth International Workshop on Machine Learning,", "citeRegEx": "Murphy and Pazzani,? \\Q1991\\E", "shortCiteRegEx": "Murphy and Pazzani", "year": 1991}, {"title": "Boolean feature discovery in empirical learning. Machine learning", "author": ["G Pagallo", "D Haussler"], "venue": null, "citeRegEx": "Pagallo and Haussler,? \\Q1990\\E", "shortCiteRegEx": "Pagallo and Haussler", "year": 1990}, {"title": "Discovery, analysis, and presentation of strong rules. Knowledge discovery in databases", "author": ["G Piatetsky-Shapiro"], "venue": null, "citeRegEx": "Piatetsky.Shapiro,? \\Q1991\\E", "shortCiteRegEx": "Piatetsky.Shapiro", "year": 1991}, {"title": "Induction of decision trees. Machine learning", "author": ["JR Quinlan"], "venue": null, "citeRegEx": "Quinlan,? \\Q1986\\E", "shortCiteRegEx": "Quinlan", "year": 1986}, {"title": "C4.5: programs for machine learning", "author": ["JR Quinlan"], "venue": null, "citeRegEx": "Quinlan,? \\Q1993\\E", "shortCiteRegEx": "Quinlan", "year": 1993}, {"title": "Labelme: a database and webbased tool for image annotation", "author": ["BC Russell", "A Torralba", "KP Murphy", "WT Freeman"], "venue": "International Journal of Computer Vision", "citeRegEx": "Russell et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Russell et al\\.", "year": 2008}, {"title": "A direct approach to false discovery rates. Journal of the Royal Statistical Society: Series B (Statistical Methodology", "author": ["JD Storey"], "venue": null, "citeRegEx": "Storey,? \\Q2002\\E", "shortCiteRegEx": "Storey", "year": 2002}, {"title": "A scheme for feature construction and a comparison of empirical methods", "author": ["DS Yang", "L Rendell", "G Blix"], "venue": "Proceedings of the Twelfth International Joint Conference on Artificial Intelligence,", "citeRegEx": "Yang et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Yang et al\\.", "year": 1991}, {"title": "Constructing nominal x-of-n attributes", "author": ["Z Zheng"], "venue": "Proceedings of International Joint Conference On Artificial Intelligence,", "citeRegEx": "Zheng,? \\Q1995\\E", "shortCiteRegEx": "Zheng", "year": 1995}, {"title": "A comparison of constructive induction with different types of new attribute", "author": ["Z Zheng"], "venue": "Tech. rep., School of Computing and Mathematics,", "citeRegEx": "Zheng,? \\Q1996\\E", "shortCiteRegEx": "Zheng", "year": 1996}, {"title": "Constructing conjunctions using systematic search on decision trees. Knowledge-Based Systems", "author": ["Z Zheng"], "venue": null, "citeRegEx": "Zheng,? \\Q1998\\E", "shortCiteRegEx": "Zheng", "year": 1998}], "referenceMentions": [{"referenceID": 3, "context": ", SVM (Cortes and Vapnik, 1995), PCA (Dunteman, 1989) etc.", "startOffset": 6, "endOffset": 31}, {"referenceID": 18, "context": "In the same way that frequent itemsets (Piatetsky-Shapiro, 1991) help users to understand the patterns in transactions, our goal with the new features is to help understand relations between individuals of datasets.", "startOffset": 39, "endOffset": 64}, {"referenceID": 11, "context": "Liu and Motoda (1998) collects some of them and divides them into three categories: feature selection, feature extraction and feature construction.", "startOffset": 0, "endOffset": 22}, {"referenceID": 9, "context": "Feature selection (Lallich and Rakotomalala, 2000; Mo and Huang, 2011) seeks to filter the original feature set in order to remove redundant features.", "startOffset": 18, "endOffset": 70}, {"referenceID": 14, "context": "Feature selection (Lallich and Rakotomalala, 2000; Mo and Huang, 2011) seeks to filter the original feature set in order to remove redundant features.", "startOffset": 18, "endOffset": 70}, {"referenceID": 15, "context": "Feature extraction is a process that extracts a set of new features from the original features through functional mapping (Motoda and Liu, 2002).", "startOffset": 122, "endOffset": 144}, {"referenceID": 3, "context": "For example, the SVM algorithm (Cortes and Vapnik, 1995) constructs a kernel function that changes the description space into a new separable one.", "startOffset": 31, "endOffset": 56}, {"referenceID": 15, "context": "Feature Construction is a process that discovers missing information about the relationships between features and augments the space of features by inferring or creating additional features (Motoda and Liu, 2002).", "startOffset": 190, "endOffset": 212}, {"referenceID": 13, "context": "Constructive induction (Michalski, 1983) is a process of constructing new features using two intertwined searches (Bloedorn and Michalski, 1998): one in the representation space (modifying the feature set) and another in the hypothesis space (using classical learning methods).", "startOffset": 23, "endOffset": 40}, {"referenceID": 2, "context": "Constructive induction (Michalski, 1983) is a process of constructing new features using two intertwined searches (Bloedorn and Michalski, 1998): one in the representation space (modifying the feature set) and another in the hypothesis space (using classical learning methods).", "startOffset": 114, "endOffset": 144}, {"referenceID": 24, "context": "Supervised feature construction can also be applied in other domains, like decision rule learning (Zheng, 1995).", "startOffset": 98, "endOffset": 111}, {"referenceID": 6, "context": "Algorithm 1, presented in Gomez and Morales (2002); Yang et al (1991), represents the general schema followed by most constructive induction algorithms.", "startOffset": 26, "endOffset": 51}, {"referenceID": 6, "context": "Algorithm 1, presented in Gomez and Morales (2002); Yang et al (1991), represents the general schema followed by most constructive induction algorithms.", "startOffset": 26, "endOffset": 70}, {"referenceID": 17, "context": "FRINGE (Pagallo and Haussler, 1990) creates new features using a decision tree that it builds at each iteration.", "startOffset": 7, "endOffset": 35}, {"referenceID": 12, "context": "CITRE (Matheus, 1990) adds other search strategies like root (selects first two nodes in a positive path) or root-fringe (selects the first and last node in the path).", "startOffset": 6, "endOffset": 21}, {"referenceID": 26, "context": "CAT (Zheng, 1998) is another example of a hypothesis-driven constructive algorithm similar to FRINGE.", "startOffset": 4, "endOffset": 17}, {"referenceID": 16, "context": "The algorithm ID2\u2212o f \u22123 (Murphy and Pazzani, 1991) uses M-of-N representations for the newly-created features.", "startOffset": 25, "endOffset": 51}, {"referenceID": 24, "context": "The Xo f N (Zheng, 1995) algorithm functions similarly, except that it uses the X-of-N representation.", "startOffset": 11, "endOffset": 24}, {"referenceID": 12, "context": "CITRE (Matheus, 1990) adds other search strategies like root (selects first two nodes in a positive path) or root-fringe (selects the first and last node in the path). It also introduces domain-knowledge by applying filters to prune the constructed features. CAT (Zheng, 1998) is another example of a hypothesis-driven constructive algorithm similar to FRINGE. It also constructs conjunctive features based on the output of decision trees. It uses a dynamic-path based approach (the conditions used to generate new features are chosen dynamically) and it includes a pruning technique. There are alternative representations, other than conjunctive and disjunctive. The M-ofN and X-of-N representations use feature-value pairs. An feature-value pair AVk(Ai = Vi j) is true for an instance if and only if the feature Ai has the value Vi j for that instance. The difference between M-of-N and X-of-N is that, while the second one counts the number of true feature-value pairs, the first one uses a threshold parameter to assign a value of truth for the entire representation. The algorithm ID2\u2212o f \u22123 (Murphy and Pazzani, 1991) uses M-of-N representations for the newly-created features. It has a specialization and a generalization construction operator and it does not need to construct a new decision tree at each step, but instead integrates the feature construction in the decision tree construction. The Xo f N (Zheng, 1995) algorithm functions similarly, except that it uses the X-of-N representation. It also takes into account the complexity of the features generated. Comparative studies like Zheng (1996) show that conjunctive and disjunctive representations have very similar performances in terms of prediction accuracy and theoretical complexity.", "startOffset": 7, "endOffset": 1612}, {"referenceID": 17, "context": "FRINGE (Pagallo and Haussler, 1990) is a framework algorithm (see Section 1.", "startOffset": 7, "endOffset": 35}, {"referenceID": 19, "context": "It creates new features using a logical decision tree, created using a traditional algorithm like ID3 (Quinlan, 1986) or C4.", "startOffset": 102, "endOffset": 117}, {"referenceID": 20, "context": "5 (Quinlan, 1993).", "startOffset": 2, "endOffset": 17}, {"referenceID": 4, "context": "We propose a measure inspired from the \u201cinclusionexclusion\u201d principle (Feller, 1950).", "startOffset": 70, "endOffset": 84}, {"referenceID": 0, "context": "Setting aside the Bonferroni correction, often considered too simplistic and too drastic, one has the option of using sequential rejection methods (Benjamini and Liu, 1999; Holm, 1979), the q-value method of Storey (Storey, 2002) or making use of bootstrap (Lallich et al, 2006).", "startOffset": 147, "endOffset": 184}, {"referenceID": 7, "context": "Setting aside the Bonferroni correction, often considered too simplistic and too drastic, one has the option of using sequential rejection methods (Benjamini and Liu, 1999; Holm, 1979), the q-value method of Storey (Storey, 2002) or making use of bootstrap (Lallich et al, 2006).", "startOffset": 147, "endOffset": 184}, {"referenceID": 22, "context": "Setting aside the Bonferroni correction, often considered too simplistic and too drastic, one has the option of using sequential rejection methods (Benjamini and Liu, 1999; Holm, 1979), the q-value method of Storey (Storey, 2002) or making use of bootstrap (Lallich et al, 2006).", "startOffset": 215, "endOffset": 229}], "year": 2015, "abstractText": "Feature-based format is the main data representation format used by machine learning algorithms. When the features do not properly describe the initial data, performance starts to degrade. Some algorithms address this problem by internally changing the representation space, but the newly-constructed features are rarely comprehensible. We seek to construct, in an unsupervised way, new features that are more appropriate for describing a given dataset and, at the same time, comprehensible for a human user. We propose two algorithms that construct the new features as conjunctions of the initial primitive features or their negations. The generated feature sets have reduced correlations between features and succeed in catching some of the hidden relations between individuals in a dataset. For example, a feature like sky\u2227\u00acbuilding\u2227 panorama would be true for non-urban images and is more informative than simple features expressing the presence or the absence of an object. The notion of Pareto optimality is used to evaluate feature sets and to obtain a balance between total correlation and the complexity of the resulted feature set. Statistical hypothesis testing is used in order to automatically determine the values of the parameters used for constructing a data-dependent feature set. We experimentally show that our approaches achieve the construction of informative feature sets for multiple datasets.", "creator": "LaTeX with hyperref package"}}}