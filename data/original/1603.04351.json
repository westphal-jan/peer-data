{"id": "1603.04351", "review": {"conference": "acl", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Mar-2016", "title": "Simple and Accurate Dependency Parsing Using Bidirectional LSTM Feature Representations", "abstract": "We present a simple and effective scheme for dependency parsing which is based on bidirectional-LSTMs (BiLSTMs). Each sentence token is associated with a BiLSTM vector representing the token in its sentential context, and feature vectors are constructed by concatenating a few BiLSTM vectors. The BiLSTM is trained jointly with the parser objective, resulting in very effective feature extractors for parsing. We demonstrate the effectiveness of the approach by applying it to a greedy transition based parser as well as to a globally optimized graph-based parser. The resulting parsers have very simple architectures, and match or surpass the state-of-the-art accuracies on English and Chinese.", "histories": [["v1", "Mon, 14 Mar 2016 17:18:27 GMT  (35kb)", "http://arxiv.org/abs/1603.04351v1", null], ["v2", "Thu, 26 May 2016 09:45:18 GMT  (97kb,D)", "http://arxiv.org/abs/1603.04351v2", null], ["v3", "Wed, 20 Jul 2016 15:17:29 GMT  (205kb,D)", "http://arxiv.org/abs/1603.04351v3", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["eliyahu kiperwasser", "yoav goldberg"], "accepted": true, "id": "1603.04351"}, "pdf": {"name": "1603.04351.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["elikip@gmail.com", "yoav.goldberg@gmail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 3.\n04 35\n1v 1\n[ cs\n.C L\n] 1\n4 M"}, {"heading": "1 Introduction", "text": "The focus of this paper is on feature representation for dependency parsing, using recent techniques from the neural-networks (\u201cdeep learning\u201d) literature. Modern approaches to dependency parsing can be broadly categorized into graph-based and transition-based parsers (K\u00fcbler et al., 2008). Graph-based parsers (McDonald, 2006) treat parsing as a search-based structured prediction problem in which the goal is learning a scoring function over dependency trees such that the correct tree is scored above all other trees. Transition-based parsers (Nivre, 2004; Nivre, 2008) treat parsing as a sequence of actions that produce a parse tree, and a classifier is trained to score the possible actions at each stage of the process and guide the parsing process. Perhaps the simplest graph-based parsers are\narc-factored (first order) models (McDonald, 2006), in which the scoring function for a tree decomposes over the individual arcs of the tree. More elaborate models look at larger (overlapping) parts, requiring more sophisticated inference and training algorithms (Martins et al., 2009; Koo and Collins, 2010). The basic transition-based parsers work in a greedy manner, performing a series of locally-optimal decisions, and boast very fast parsing speeds. More advanced transition-based parsers introduce some search into the process using a beam (Zhang and Clark, 2008) or dynamic programming (Huang and Sagae, 2010).\nRegardless of the details of the parsing framework being used, a crucial step in parser design is choosing the right feature function for the underlying statistical model. Recent work (see Section 2.2 for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of \u201ccore\u201d features and leaving it up to the machine-learning machinery to come up with good feature combinations (Chen and Manning, 2014; Pei et al., 2015; Lei et al., 2014; Taub-Tabib et al., 2015). However, the need to carefully define a set of core features remains. For example, the work of (Chen and Manning, 2014) uses 18 different elements in its feature function, while the work of (Pei et al., 2015) uses 21 different elements. Other works, notably (Dyer et al., 2015; Le and Zuidema, 2014), propose more sophisticated feature representations, in which the feature engineering is replaced with architecture engineering.\nIn this work, we suggest an approach which is much simpler in terms of both feature engineering\nand architecture engineering. Our proposal (Section 3) is centered around BiRNNs (Irsoy and Cardie, 2014; Schuster and Paliwal, 1997), and more specifically BiLSTMs (Graves, 2008), which are strong and trainable sequence models (see Section 2.3). The BiLSTM excels at representing elements in a sequence (i.e., words) together with their contexts, capturing the element and an \u201cinfinite\u201d window around it. We represent each word by its BiLSTM encoding, and use a concatenation of a minimal set of such BiLSTM encodings as our feature function, which is then passed to a non-linear scoring function (multi-layer perceptron). Crucially, the BiLSTM is trained with the rest of the parser in order to learn a good feature representation for the parsing problem. If we set aside the inherent complexity of the BiLSTM itself and treat it as a black box, our proposal results in a frustratingly simple feature extractor.\nWe demonstrate the effectiveness of the approach by using the BiLSTM feature extractor in two parsing architectures, transition-based (Section 4) as well as a graph-based (Section 5). In the graphbased parser, we jointly train a structured-prediction model on top of a BiLSTM, propagating errors from the structured objective all the way back to the BiLSTM feature-encoder. To the best of our knowledge, we are the first to perform such end-to-end training of a structured prediction model and a recurrent feature extractor.\nAside from the novelty of the BiLSTM feature extractor and the end-to-end structured training, we rely on existing models and techniques from the parsing and structured prediction literature. We stick to the simplest parsers in each category \u2013 greedy inference for the transition-based architecture, and a first-order, arc-factored model for the graph-based architecture. Despite the simplicity of the parsing architectures and the feature functions, we achieve state-of-the-art parsing accuracies in both English (93.2 UAS) and Chinese (86.4 UAS), using a firstorder parser with two features and while training solely on Treebank data, without relying on semisupervised signals such as pre-trained word embeddings (Chen and Manning, 2014), word-clusters (Koo et al., 2008), or techniques such as tri-training (Weiss et al., 2015). When including also pretrained word embeddings, we obtain further im-\nprovements, with accuracies of 93.6 UAS (English) and 87.3 UAS (Chinese) for a greedy transitionbased parser with 11 features, and 93.3 UAS (En) / 86.6 (Ch) for a greedy transition-based parser with 4 features."}, {"heading": "2 Background and Notation", "text": "Notation We use x1:n to denote a sequence of n vectors x1, \u00b7 \u00b7 \u00b7 , xn. F\u03b8(\u00b7) is a function parameterized with parameters \u03b8. We write FL(\u00b7) as a shortcut to F\u03b8L \u2013 an instantiation of F with a specific set of parameters \u03b8L. We use \u25e6 to denote a vector concatenation operation, and v[i] to denote an indexing operation taking the ith element of a vector v."}, {"heading": "2.1 Feature Functions in Dependency Parsing", "text": "Traditionally, state-of-the-art parsers rely on linear models over hand-crafted feature functions. The feature functions look at core components (e.g. \u201cword on top of stack\u201d, \u201cleftmost child of the second-totop word on the stack\u201d, \u201cdistance between the head and the modifier words\u201d), and are comprised of several templates, where each template instantiates a binary indicator function over a conjunction of core elements (resulting in features of the form \u201cword on top of stack is X and leftmost child is Y and . . . \u201d). The design of the feature function \u2013 which components to consider and which combinations of components to include \u2013 is a major challenge in parser design. Once a good feature function is proposed in a paper it is usually adopted in later works, and sometimes tweaked to improve performance. Examples of good feature functions are the feature-set proposed by Zhang and Nivre (2011) for transitionbased parsing (including roughly 20 core components and 72 feature templates), and the feature-set proposed by McDonald et al (2005) for graph-based parsing, with the paper listing 18 templates for a first-order parser, and the MSTParser\u2019s first-order feature-extractor code containing roughly a hundred feature templates.\nThe core features in a transition-based parser usually look at information such as the word-identity and part-of-speech (POS) tags of a fixed number of words on top of the stack, a fixed number of words on the top of the buffer, the modifiers (usually leftmost and right-most) of items on the stack and on the\nbuffer, the number of modifiers of these elements, parents of words on the stack, and the length of the spans spanned by the words on the stack. The core features of a first-order graph-based parser usually take into account the word and POS of the head and the modifier items, as well as the POS-tags of the items around to the head and the modifier, the POS tags of items between the head and the modifier, and the distance and direction between the head and the modifier."}, {"heading": "2.2 Related Research Efforts", "text": "Coming up with a good feature-set for a parser is a hard and time consuming task, and many researchers attempt to reduce the required manual efforts. The work of Lei et al (2014) suggest a low-rank tensor representation to automatically find good feature combinations. Taub-Tabib et al (2015) suggest a kernel-based approach to implicitly consider all possible feature combinations over sets of core-features. The recent popularity of neural-networks prompted a move from templates of sparse, binary indicator features to dense core feature encodings fed into non-linear classifiers. Chen and Manning (2014) encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a nonlinear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations. Weiss et al (2015) showed further gains using the same approach coupled with a somewhat improved set of core features, a more involved network architecture with skip-layers, beam search-decoding, and careful hyper-parameter tuning. Pei et al (2015) apply a similar methodology to graph-based parsing. While the move to neural-network classifiers alleviates the need for hand-crafting featurecombinations, the need to carefully define a set of core features remain. For example, the feature representation in (Chen and Manning, 2014) is a concatenation of 18 word vectors, 18 POS vectors and 12 dependency-label vectors.1\n1In all of these neural-network based approaches, the vector representations of words were initialized using pre-trained word-embeddings derived from a large corpus external to the training data. This puts the approaches in the semi-supervised category, making it hard to tease apart the contribution of the automatic feature-combination component from that of the semi-\nThe above works tackle the effort in hand-crafting effective feature combinations. A different line of work attacks the feature-engineering problem by suggesting novel neural-network architectures for encoding the parser state, including intermediatelybuilt subtrees, as vectors which are then fed to nonlinear classifiers. In the work of Dyer et al (2015), the entire stack and buffer of a transition-based parser are encoded as a stack-LSTMs, where each stack element is itself based on a compositional representation of parse trees. Le and Zuidema (2014) encode each tree node as two compositional representations capturing the inside and outside structures around the node, and feed the representations into a reranker. A similar reranking approach, this time based on convolutional neural networks, is taken by Zhu et al (2015). Finally, in Kiperwasser and Goldberg (2016) we present an Easy-First parser based on a novel hierarchical-LSTM tree encoding.\nIn contrast to these, the approach we present in this work results in much simpler feature functions, without resorting to elaborate network architectures or compositional tree representations."}, {"heading": "2.3 Bidirectional Recurrent Neural Networks", "text": "Recurrent neural networks (RNNs) are statistical learners for modeling sequential data. An RNN allows to model the ith element in the sequence based on the past \u2013 the elements x1:i up to and including it. The RNN model provides a framework for conditioning on the entire history x1:i without resorting to the Markov assumption which is traditionally used for modeling sequences. RNNs were shown to be capable of learning to count, as well as to model line lengths and complex phenomena such as bracketing and code indentation (Karpathy et al., 2015). Our proposed feature extractors are based on a bidirectional recurrent neural network (BiRNN), an extension of RNNs that take into account both the past x1:i and the future xi:n. We use a specific flavor of RNN called a long short-term memory network (LSTM). For brevity, we treat RNN as an abstraction, without getting into the mathematical details of the implementation of the RNNs and LSTMs. For further details on RNNs and LSTMs, the reader is referred to (Goldberg, 2015; Cho, 2015).\nsupervised component.\nThe recurrent neural network (RNN) abstraction is a parameterized function RNN\u03b8(x1:n) mapping a sequence of n input vectors x1:n, xi \u2208 Rdin to a sequence of n output vectors h1:n, hi \u2208 Rdout . Each output vector hi is conditioned on all the input vectors x1:i, and can be thought of as a summary of the prefix x1:i of x1:n. In our notation, we ignore the intermediate vectors h1:n\u22121 and take the output of RNN\u03b8(x1:n) to be the vector hn.\nA bidirectional RNN is composed of two RNNs, RNNF and RNNR, one reading the sequence in its regular order, and the other reading it in reverse. Concretely, given a sequence of vectors x1:n and a desired index i, the function BIRNN\u03b8(x1:n, i) is defined as:\nBIRNN\u03b8(x1:n, i) = RNNF (x1:i) \u25e6 RNNR(xn:i)\nThe vector vi = BIRNN(x1:n, i) is then a representation of the ith item in x1:n, taking into account both the entire history x1:i and the entire future xi:n. We can view the BiRNN encoding of an item i as representing the item i together with a context of an infinite window around it.\nComputational Complexity Computing the BiRNN vectors encoding of the ith element of a sequence x1:n requires O(n) time for computing the two RNNs and concatenating their outputs. A naive approach of computing the bidirectional representation of all n elements result in O(n2) computation. However, it is trivial to compute the BiRNN encoding of all sequence items in linear time by pre-computing RNNF (x1:n) and RNNR(xn:1), keeping the intermediate representations, and concatenating the required elements as needed.\nBiRNN Training Initially, the BiRNN encodings vi do not capture any particular information. During training, the encoded vectors vi are fed into further network layers, until at some point a prediction is made, and a loss is incurred. The back-propagation algorithm is used to compute the gradients of all the parameters in the network (including the BiRNN parameters) with respect to the loss, and an optimizer is used to update the parameters according to the gradients. The training procedure causes the BiRNN function to extract from the input sequence x1:n the relevant information for the task task at hand.\nGoing deeper A deep RNN (or k-layer RNN) is composed of k RNN functions RNN1, \u00b7 \u00b7 \u00b7 ,RNNk that feed into each other: the output h\u21131:n of RNN\u2113 becomes the input of RNN\u2113+1. Stacking RNNs in this way was empirically shown to be effective. Finally, in a deep bidirectional RNN, both RNNF and RNNR are k-layer RNNs, and BIRNN\u2113(x1:n, i) = v\u2113i = h \u2113 F,i \u25e6 h \u2113 R,i. In this work, we use BiRNNs and deep-BiRNNs interchangeably, specifying the number of layers when needed.\nHistorical Notes RNNs were introduced by Elamn (Elman, 1990), and extended to BiRNNs by (Schuster and Paliwal, 1997). The LSTM variant of RNNs is due to (Hochreiter and Schmidhuber, 1997). BiLSTMs were recently popularized by Graves (2008), and deep BiRNNs were introduced to NLP by Irsoy and Cardie (2014), who used them for sequence tagging."}, {"heading": "3 Our Approach", "text": "We propose to replace the hand-crafted feature functions in favor of minimally-defined feature functions which make use of automatically learned Bidirectional LSTM representations.\nGiven an n words input sentence s with words w1, . . . , wn together with the corresponding POS tags t1, . . . , tn,2 we associate each word wi and POS ti with embedding vectors e(wi) and e(ti), and create a sequence of input vectors x1:n in which each xi is a concatenation of the corresponding word and POS vectors:\nxi = e(wi) \u25e6 e(pi)\nThe embeddings are trained together with the model. This encodes each word in isolation, disregarding its context. We introduce context by representing each input element as its (deep) BiLSTM vector, vi:\nvi = BILSTM(x1:n, i)\nOur feature function \u03c6 is then a concatenation of a small number of BiLSTM vectors. The exact feature function is parser dependent and will be discussed when discussing the corresponding parsers.\n2In this work the tag sequence is assumed to be given, and in practice is predicted by an external model. Future work will address relaxing this assumption.\nThe resulting feature vectors are then scored using a non-linear function, namely a multi-layer perceptron with one hidden layer (MLP):\nMLP\u03b8(x) = W 2 \u00b7 tanh(W 1 \u00b7 x+ b1) + b2\nwhere \u03b8 = {W 1,W 2, b1, b2} are the model parameters.\nBeside using the BiLSTM-based feature functions, we make use of standard parsing techniques. Crucially, the BiLSTM is trained jointly with the rest of the parsing objective. This allows it to learn representations which are suitable for the parsing task.\nConsider a concatenation of two BiLSTM vectors (vi \u25e6 vj) scored using an MLP. The scoring function has access to the words and POS-tags of vi and vj , as well as the words and POS-tags of the words in an infinite window surrounding them. As LSTMs are known to capture length and sequence position information, it is very plausible that the scoring function can be sensitive also to the distance between i and j, their ordering, and the sequential material between them.\nParsing-time Complexity Once the BiLSTM is trained, parsing is performed by first computing the BiLSTM encoding vi for each word in the sentence (a linear time operation).3 Then, parsing proceeds as usual, where the feature extraction involves a concatenation of a small number of the pre-computed vi vectors."}, {"heading": "4 Transition-based Parser", "text": "We begin by integrating the feature extractor in a transition-based parser (Nivre, 2008). We follow the notation in (Goldberg and Nivre, 2013). The transition-based parsing framework assumes a transition system, an abstract machine that processes sentences and produces parse trees. The transition system has a set of configurations and a set of transitions which are applied to configurations. When parsing a sentence, the system is initialized to an initial configuration based on the input sentence, and transitions are repeatedly applied to this configuration. After a finite number of transitions, the system\n3While the BiLSTM computation is quite efficient as it is, if using a GPU the BiLSTM encoding can be performed over many of sentences in parallel, making its computation cost almost negligible.\narrives at a terminal configuration, and a parse tree is read off the terminal configuration. In a greedy parser, a classifier is used to choose the transition to take in each configuration, based on features extracted from the configuration itself. The parsing algorithm is presented in algorithm 1 below:\nAlgorithm 1 Greedy transition-based parsing 1: Input: sentence s = w1, . . . , xw, t1, . . . , tn,\nparameterized function SCORE\u03b8(\u00b7) with parameters \u03b8.\n2: c \u2190 INITIAL(s) 3: while not TERMINAL(c) do 4: t\u0302 \u2190 argmaxt\u2208LEGAL(c) SCORE\u03b8 ( \u03c6(c), t ) 5: c \u2190 t\u0302(c)\n6: return tree(c)\nGiven a sentence s, the parser is initialized with the configuration c (line 2). Then, a feature function \u03c6(c) represents the configuration c as a vector, which is fed to a scoring function SCORE assigning scores to (configuration,transition) pairs. SCORE scores the possible transitions t, and the highest scoring transition t\u0302 is chosen (line 4). The transition t\u0302 is applied to the configuration, resulting in a new parser configuration. The process ends when reaching a final configuration, from which the resulting parse tree is read and returned (line 6).\nTransition systems differ by the way they define configurations, and by the particular set of transitions available to them. A parser is determined by the choice of a transition system, a feature function \u03c6 and a scoring function SCORE. Our choices are detailed below.\nThe Arc-Hybrid System Many transitions systems exist in the literature. In this work, we use the arc-hybrid transition system (Kuhlmann et al., 2011), which is similar to the more popular arcstandard system (Nivre, 2004), but for which an efficient dynamic oracle is available (Goldberg and Nivre, 2012; Goldberg and Nivre, 2013). In the archybrid system, a configuration c = (\u03c3, \u03b2, T ) consists of a stack \u03c3, a buffer \u03b2, and a set T of dependency arcs. Both the stack and the buffer hold integer indices to sentence elements. Given a sentence s = w1, . . . , wn, t1, . . . , tn, the system is initialized with an empty stack, an empty arc set, and\n\u03b2 = 1, . . . , n, ROOT , where ROOT is the special root index. Any configuration c with an empty stack and a buffer containing only ROOT is terminal, and the parse tree is given by the arc set Tc of c. Arc-hybrid system allows 3 possible transitions, SHIFT, LEFT\u2113 and RIGHT\u2113, defined as:\nSHIFT[(\u03c3, b0|\u03b2, T )] = (\u03c3|b0, \u03b2, T ) LEFT\u2113[(\u03c3|s1|s0, b0|\u03b2, T )] = (\u03c3, b0|\u03b2, T \u222a {(b0, s0, \u2113)}) RIGHT\u2113[(\u03c3|s1|s0, \u03b2, T )] = (\u03c3|s1, \u03b2, T \u222a {(s1, s0, \u2113)})\nThe SHIFT transition moves the first item of the buffer (b0) to the stack. The LEFT\u2113 transition removes the first item on top of the stack (s0) and attaches it as a modifier to b0 with label \u2113, adding the arc (b0, s0, \u2113). The RIGHT\u2113 transition removes s0 from the stack and attaches it as a modifier to the next item on the stack (s1), adding the arc (s1, s0, \u2113).\nScoring Function Traditionally, the scoring function SCORE\u03b8(x, t) is a discriminative linear model of the form SCOREW (x, t) = (W \u00b7 x)[t]. The linearity of SCORE required the feature function \u03c6(\u00b7) to encode non-linearities in the form of combination features. We follow Chen and Manning (2014) and replace the linear scoring model with an MLP.\nSCORE\u03b8(x, t) = MLP\u03b8(x)[t]\nSimple Feature Function The feature function \u03c6(c) typically complex (see Section 2.1). Our feature function is the concatenated BiLSTM vectors of the top 3 items on the stack and the first item on the buffer. I.e., for a configuration c = (. . . |s2|s1|s0, b0| . . . , T ) the feature extractor is defined as:\n\u03c6(c) = vs2 \u25e6 vs1 \u25e6 vs0 \u25e6 vb0\nvi = BILSTM(x1:n, i)\nThis feature function is rather minimal: it takes into account the BiLSTM representations of s1, s0 and b0, which are the items affected by the possible transitions being scored, as well as one extra stack context s2.4 Note that, unlike previous work, this feature function does not take into account T , the\n4An additional buffer context is not needed, as b1 is by definition adjecent to b0, a fact that we expect the BiLSTM encoding of b0 to capture. In contrast, b0, s0, s1 and s2 are not necessarily adjacent to each other.\nalready built structure. The high parsing accuracies in the experimental sections suggest that the BiLSTM encoding is capable of estimating a lot of the missing information based on the provided stack and buffer elements and the sequential content between them.\nExtended Feature Function One of the benefits of the greedy transition-based parsing framework is precisely its ability to look at arbitrary features from the already built tree. If we allow somewhat less minimal feature function, we could add the BiLSTM vectors corresponding to the right-most and left-most modifiers of s0, s1 and s2, as well as the left-most modifier of b0, reaching a total of 11 BiLSTM vectors. We refer to this as the extended feature set. As we\u2019ll see in Section 6, using the extended set does indeed improve parsing accuracies when using pre-trained word embeddings, but has a minimal effect in the fully-supervised case."}, {"heading": "4.1 Details of the Training Algorithm", "text": "The training objective is to set the score of correct transitions above the scores of incorrect transitions. We use a margin-based objective, aiming to maximize the margin between the highest scoring correct action and the highest scoring incorrect action. The hinge loss at each parsing configuration c is defined as:\nmax (\n0, 1\u2212max to\u2208G\nMLP ( \u03c6(c) )\n[to]\n+ max tp\u2208A\\G\nMLP ( \u03c6(c) ) [tp] )\nwhere A is the set of possible transitions and G is the set of correct (gold) transitions at the current stage. At each stage of the training process the parser scores the possible transitions A, incurs a loss, selects a transition to follow, and moves to the next configuration based on it. The local losses are summed throughout the parsing process of a sentence, and the parameters are updated with respect to the sum of the losses at sentence boundaries.5\n5To increase gradient stability and training speed, we simulate mini-batch updates by only updating the parameters when the sum of local losses contains at least 50 non-zero elements. Sums of fewer elements are carried across sentences. This assures us a sufficient number of gradient samples for every update thus minimizing the effect of gradient instability.\nThe gradients of the entire network (including the MLP and the BiLSTM) with respect to the sum of the losses are calculated using the backpropagation algorithm. As usual, we perform several training iterations over the training corpus, shuffling the order of sentences in each iteration.\nError-Exploration and Dynamic Oracle Training We follow Goldberg and Nivre (2013; 2012) in using error exploration training with a dynamic-oracle, which we briefly describe below.\nAt each stage in the training process, the parser assigns scores to all the possible transitions t \u2208 A. It then selects a transition, applies it, and moves to the next step. Which transition should be followed? A common approach follows the highest scoring transition that can lead to the gold tree. However, when training in this way the parser sees only configurations that result from following correct actions, and as a result tends to suffer from error propagation at test time. Instead, in error-exploration training the parser follows the highest scoring action in A during training even if this action is incorrect, exposing it to configurations that result from erroneous decisions. This strategy requires defining the set G such that the correct actions to take are well-defined also for states that cannot lead to the gold tree. Such a set G is called a dynamic oracle. We perform error-exploration training using the dynamic-oracle defined in (Goldberg and Nivre, 2013).\nAggressive Exploration We found that even when using error-exploration, after one iteration the model remembers the training set quite well, and does not make enough errors to make error-exploration effective. In order to expose the parser to more errors, we follow an aggressive-exploration scheme: we sometimes follow incorrect transitions also if they score below correct transitions. Specifically, when the score of the correct transition is greater than that of the wrong transition but the difference is smaller than a margin constant, we chose to follow the incorrect action with probability pagg (we use pagg = 0.1 in our experiments).\nSummary The greedy transition based parser follows standard techniques from the literature (margin-based objective, dynamic oracle training, error exploration, MLP-based non-linear scoring\nfunction). We depart from the literature by replacing the hand-crafted feature function over carefully selected components of the configuration with a concatenation of BiLSTM representations of few prominent items on the stack and the buffer, and training the BiLSTM encoder jointly with the rest of the network."}, {"heading": "5 Graph-based Parser", "text": "Graph-based parsing follows the common structured prediction paradigm (Taskar et al., 2005; McDonald et al., 2005):\npredict(s) = argmax y\u2208Y(s) scoreglobal(s, y)\nscoreglobal(s, y) = \u2211\npart\u2208y\nscorelocal(s, part)\nGiven an input sentence s (and the corresponding sequence of vectors x1:n) we look for the highestscoring parse tree y in the space Y(s) of valid dependency trees over s. In order to make the search tractable, the scoring function is decomposed to the sum of local scores for each part independently.\nIn this work, we focus on arc-factored graph based approach presented in (McDonald et al., 2005). Arc-factored parsing decomposes the score of tree to the sum of the score of its head-modifier arcs (h,m):\nparse(s) = argmax y\u2208Y(s)\n\u2211\n(h,m)\u2208y\nscore ( \u03c6(s, h,m) )\nGiven the scores of the arcs the highest scoring projective tree can be efficiently found using Eisner\u2019s decoding algorithm (1996). McDonald et al and most subsequent work estimate the local score of an arc by a linear model parameterized by a weight vector w, and a feature function \u03c6(s, h,m) assigning sparse feature vector for an arc linking modifier m to head h. We follow Pei et al (2015) and replace the linear scoring function with an MLP.\nThe feature extractor \u03c6(s, h,m) is usually complex, involving many elements (see section 2.1). In contrast, our feature extractor uses merely the BiLSTM encoding of the head word and the modifier word:\n\u03c6(s, h,m) = BIRNN(x1:n, h) \u25e6 BIRNN(x1:n,m)\nThe final model is:\nparse(s) = argmax y\u2208Y(s) scoreglobal(s, y)\n= argmax y\u2208Y(s)\n\u2211\n(h,m)\u2208y\nscore ( \u03c6(s, h,m) )\n= argmax y\u2208Y(s)\n\u2211\n(h,m)\u2208y\nMLP (vh \u25e6 vm)\nvi = BIRNN(x1:n, i)\nTraining The training objective is to set the Score function such that correct tree y is scored above incorrect ones. We use a margin-based objective (McDonald et al., 2005; LeCun et al., 2006), aiming to maximize the margin between the score of the gold tree y and highest scoring incorrect tree y\u2032. We define a hinge loss with respect to a gold tree y as:\nmax (\n0, 1\u2212max y\u2032 6=y\n\u2211\n(h,m)\u2208y\u2032\nMLP (vh \u25e6 vm)\n+ \u2211\n(h,m)\u2208y\nMLP (vh \u25e6 vm) )\nEach of the tree scores is the calculated by activating the MLP on the arc representations. The entire loss can viewed as the sum of multiple neural networks, which is sub-differentiable. We calculate the gradients of the entire thing (including to the BiLSTM encoder and word embeddings).\nLabeled Parsing Up to now, we described unlabeled parsing. A possible approach of adding labels is to score the combination of an unlabeled arc (h,m) and its label \u2113 by considering the label as part of the arc (h,m, \u2113). This results in |Labels|\u00d7|Arcs| parts that need to be scored, leading to slow parsing speeds and arguably a harder learning problem.\nInstead, we chose to first predict the unlabeled structure using the model given above, and then predict the label of each resulting arc. Using this approach, the number of parts stays small, enabling fast parsing.\nThe labeling of an arc (h,m) is performed using the same feature representation \u03c6(s, h,m) fed into a different MLP predictor:\nlabel(h,m) = argmax \u2113\u2208labels MLPLBL(vh \u25e6 vm)[\u2113]\nAs before we use a margin based hinge loss. The labeler is trained on the gold trees.6 The BiLSTM encoder responsible for producing vh and vm is shared with the arc-factored parser: the same BiLSTM encoder is used in the parer and the labeler. This sharing of parameters can be seen as an instance of multi-task learning (Caruana, 1997). As we show in Section 6, the sharing is effective: training the BiLSTM feature encoder to be good at predicting arclabels significantly improves the parser\u2019s unlabeled accuracy.\nLoss augmented inference In initial experiments, the network learned quickly and overfit the data. In order to remedy this, we found it useful to use loss augmented inference (Taskar et al., 2005). The intuition behind loss augmented inference is to update against trees which have high model scores and are also very wrong. This is done by augmenting the score of each part not belonging to the gold tree by adding a constant to its score. Formally, the loss transforms as follows:\nmax(0,1 + score(x, y)\u2212\nmax y\u2032 6=y\n\u2211\npart\u2208y\u2032\n(scorelocal(x, part) + Ipart6\u2208y))\nSpeed improvements The arc-factored model requires the scoring of n2 arcs. Scoring is performed using an MLP with one hidden layer, resulting in n2 matrix-vector multiplications from the input to the hidden layer, and n2 multiplications from the hidden to the output layer. The first n2 multiplications involve larger dimensional input and output vectors, and are the most time consuming. Fortunately, these can be reduced to 2n multiplications and n2 vector additions, by observing that the multiplication W \u00b7 (vh \u25e6 vm) can be written as W 1 \u00b7 vh +W 2 \u00b7 vm where W 1 and W 1 are are the first and second half of the matrix W and reusing the products across different pairs. Summary The graph-based parser is straightforward first-order parser, trained with a marginbased hinge-loss and loss-augmented inference. We depart from the literature by replacing the handcrafted feature function with a concatenation of\n6When training the labeled parser, we calculate the structure loss and the labeling loss for each training sentence, and sum the losses prior to computing the gradients.\nBiLSTM representations of the head and modifier words, and training the BiLSTM encoder jointly with the structured objective. We also introduce a novel MTL-based approach for labeled parsing by training a second-stage arc-labeler sharing the same BiLSTM encoder with the unlabeled parser."}, {"heading": "6 Experiments and Results", "text": "We evaluated our parsing model on English and Chinese data. For comparison purposes we follow the setup of (Dyer et al., 2015).\nData For English, we used the Stanford Dependency (SD) (de Marneffe and Manning, 2008) conversion of the Penn Treebank (Marcus et al., 1993), using the standard train/dev/test splitswith the same predicted POS-tags as used in (Dyer et al., 2015; Chen and Manning, 2014). This dataset contains a few non-projective trees. Punctuation symbols are excluded from the evaluation.\nFor Chinese, we use the Penn Chinese Treebank 5.1 (CTB5), using the train/test/dev splits of (Zhang and Clark, 2008; Dyer et al., 2015) with gold partof-speech tags, also following (Dyer et al., 2015; Chen and Manning, 2014).\nWhen using external word embeddings, we also use the same data as (Dyer et al., 2015).7\nImplementation Details The parsers are implemented in python, using the PyCNN toolkit8 for neural network training. The code will be made available on the first author\u2019s website. We use the LSTM variant implemented in PyCNN, and optimize using the Adam optimizer (Kingma and Ba, 2014). Unless otherwise noted, we use the default values provided by PyCNN (e.g. for random initialization, learning rates etc).\nThe word and POS embeddings e(wi) and e(pi) are initialized to random values and trained together with the rest of parsers\u2019 networks. In some experiments, we introduce also pre-trained word embeddings. In those cases, the vector representation of a word is a concatenation of its randomly-initialized vector embedding with its pre-trained word vector. Both are tuned during training. We use the same word vectors as in Dyer et al (2015).\n7We thank Dyer et al for sharing their data with us. 8http://www.github.com/clab/cnn/pycnn\nDuring training, we employ a variant of word dropout (Iyyer et al., 2015), and replace a word with the unknown-word symbol with probability that is inversely proportional to frequency of the word. A word w appearing #(w) times in the training corpus is replaced with the unknown symbol with a probability punk(w) = \u03b1 #(w)+\u03b1 . If a word was dropped the external embedding of the word is also dropped with probability of half.\nWe train the parsers for up to 30 iterations, and choose the best model according to the UAS accuracy on the development set.\nHyperparameter Tuning We performed a very minimal hyper-parameter search with the graphbased parser, and use the same hyper-parameters for both parsers. The hyper-parameters of the final networks used for all the reported experiments are detailed in Table 1.\nMain Results Table 2 lists the test-set accuracies of our best parsing models, compared to other state-ofthe art parsers from the literature.9\nIt is clear that our parsers are very competitive, despite using very simple parsing architectures and minimal feature extractors. When not using external embeddings, the first-order graph-based parser with 2 features outperforms all other systems that are not using external resources, including the third-order TurboParser. The greedy transition based parser with 4 features also matches or outperforms most other parsers, including the beam-based transition parser with heavily engineered features of Zhang and Nivre (2011) and the Stack-LSTM parser of\n9Unfortunately, many papers still report English parsing results on the deficient Yamada and Matsumoto head rules (PTB-YM) rather than the more modern Stanford-dependencies (PTB-SD). We note that the PTB-YM and PTB-SD results are not strictly comparable, and in our experience the PTB-YM results are usually about half a UAS point higher.\nDyer et al (2015). Moving from the simple (4 features) to the extended (11 features) feature set leads to very small improvements for English and small accuracy losses in Chinese.\nInterestingly, when adding external word embeddings the accuracy of the graph-based parser degrades. We are not sure why this happens, and leave the exploration of effective semi-supervised parsing with the graph-based model for future work. The greedy parser does manage to benefit from the external embeddings, and with using them we also see gains from moving from the simple to the extended feature set. Both feature sets result in very competitive results, with the extended feature set yielding the best reported results for Chinese, and the is ranked third for English, after the heavily-tuned beam-based parser of Weiss et al (2015) and the much more elaborate reranker-based neural parser of Le and Zuidema (2014).\nAdditional Results We perform some ablation experiments in order to quantify the effect of the different components on our best models (Table 3). Loss augmented inference is crucial for the success of the graph-based parser, and the MTL arc-\nlabeler contributes nicely to the unlabeled scores. Dynamic-oracle training has mixed results on the greedy parser, yielding small gains for English and small drops for Chinese."}, {"heading": "7 Conclusion", "text": "We presented a frustratingly effective approach for feature extraction for dependency parsing based on a BiLSTM encoder that is trained jointly with the parer, and demonstrated its effectiveness by integrating it into two simple parsing models: a greedy transition based parser and a globally optimized firstorder graph-based parser, yielding very competitive parsing accuracies in both cases.\nAcknowledgements This research is supported by the Intel Collaborative Research Institute for Computational Intelligence (ICRI-CI) and the Israeli Science Foundation (grant number 1555/15)."}], "references": [{"title": "Multitask learning", "author": ["Rich Caruana."], "venue": "Mach. Learn., 28(1):41\u201375, July.", "citeRegEx": "Caruana.,? 1997", "shortCiteRegEx": "Caruana.", "year": 1997}, {"title": "A Fast and Accurate Dependency Parser using Neural Networks", "author": ["Danqi Chen", "Christopher Manning."], "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 740\u2013750, Doha, Qatar, October. Association for", "citeRegEx": "Chen and Manning.,? 2014", "shortCiteRegEx": "Chen and Manning.", "year": 2014}, {"title": "Natural language understanding with distributed representation", "author": ["Kyunghyun Cho."], "venue": "CoRR, abs/1511.07916.", "citeRegEx": "Cho.,? 2015", "shortCiteRegEx": "Cho.", "year": 2015}, {"title": "Stanford dependencies manual", "author": ["Marie-Catherine de Marneffe", "Christopher D. Manning."], "venue": "Technical report, Stanford University.", "citeRegEx": "Marneffe and Manning.,? 2008", "shortCiteRegEx": "Marneffe and Manning.", "year": 2008}, {"title": "TransitionBased Dependency Parsing with Stack Long ShortTerm Memory", "author": ["Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith."], "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguis-", "citeRegEx": "Dyer et al\\.,? 2015", "shortCiteRegEx": "Dyer et al\\.", "year": 2015}, {"title": "Three new probabilistic models for dependency parsing: An exploration", "author": ["Jason Eisner."], "venue": "Proc. of COLING.", "citeRegEx": "Eisner.,? 1996", "shortCiteRegEx": "Eisner.", "year": 1996}, {"title": "Finding Structure in Time", "author": ["Jeffrey L. Elman."], "venue": "Cognitive Science, 14(2):179\u2013211, March.", "citeRegEx": "Elman.,? 1990", "shortCiteRegEx": "Elman.", "year": 1990}, {"title": "A dynamic oracle for the arc-eager system", "author": ["Yoav Goldberg", "Joakim Nivre."], "venue": "Proc. of COLING 2012.", "citeRegEx": "Goldberg and Nivre.,? 2012", "shortCiteRegEx": "Goldberg and Nivre.", "year": 2012}, {"title": "Training deterministic parsers with non-deterministic oracles", "author": ["Yoav Goldberg", "Joakim Nivre."], "venue": "Transactions of the association for Computational Linguistics, 1.", "citeRegEx": "Goldberg and Nivre.,? 2013", "shortCiteRegEx": "Goldberg and Nivre.", "year": 2013}, {"title": "A primer on neural network models for natural language processing", "author": ["Yoav Goldberg."], "venue": "CoRR, abs/1510.00726.", "citeRegEx": "Goldberg.,? 2015", "shortCiteRegEx": "Goldberg.", "year": 2015}, {"title": "Supervised sequence labelling with recurrent neural networks", "author": ["A. Graves."], "venue": "Ph.D. thesis, Technische Universit\u00e4t M\u00fcnchen.", "citeRegEx": "Graves.,? 2008", "shortCiteRegEx": "Graves.", "year": 2008}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "J\u00fcrgen Schmidhuber."], "venue": "Neural computation, 9(8):1735\u2013 1780.", "citeRegEx": "Hochreiter and Schmidhuber.,? 1997", "shortCiteRegEx": "Hochreiter and Schmidhuber.", "year": 1997}, {"title": "Dynamic programming algorithms", "author": ["gio Satta"], "venue": null, "citeRegEx": "Satta.,? \\Q2011\\E", "shortCiteRegEx": "Satta.", "year": 2011}, {"title": "A tutorial on energy-based", "author": ["F. Huang"], "venue": null, "citeRegEx": "Huang.,? \\Q2006\\E", "shortCiteRegEx": "Huang.", "year": 2006}, {"title": "Low-rank tensors for scor", "author": ["Tommi Jaakkola"], "venue": null, "citeRegEx": "Jaakkola.,? \\Q2014\\E", "shortCiteRegEx": "Jaakkola.", "year": 2014}, {"title": "Building a large annotated corpus of English: The penn Treebank", "author": ["Mitchell P. Marcus", "Beatrice Santorini", "Mary Ann Marchinkiewicz."], "venue": "Computational Linguistics, 19.", "citeRegEx": "Marcus et al\\.,? 1993", "shortCiteRegEx": "Marcus et al\\.", "year": 1993}, {"title": "Concise integer linear programming formulations for dependency parsing", "author": ["Andre Martins", "Noah Smith", "Eric Xing."], "venue": "Proc. ACL/AFNLP.", "citeRegEx": "Martins et al\\.,? 2009", "shortCiteRegEx": "Martins et al\\.", "year": 2009}, {"title": "Turning on the turbo: Fast third-order nonprojective turbo parsers", "author": ["Andre Martins", "Miguel Almeida", "Noah A. Smith."], "venue": "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pages 617\u2013622,", "citeRegEx": "Martins et al\\.,? 2013", "shortCiteRegEx": "Martins et al\\.", "year": 2013}, {"title": "Online large-margin training of dependency parsers", "author": ["Ryan McDonald", "Koby Crammer", "Fernando Pereira."], "venue": "Proc. of ACL.", "citeRegEx": "McDonald et al\\.,? 2005", "shortCiteRegEx": "McDonald et al\\.", "year": 2005}, {"title": "Discriminative Training and Spanning Tree Algorithms for Dependency Parsing", "author": ["Ryan McDonald."], "venue": "Ph.D. thesis, University of Pennsylvania.", "citeRegEx": "McDonald.,? 2006", "shortCiteRegEx": "McDonald.", "year": 2006}, {"title": "Incrementality in deterministic dependency parsing", "author": ["Joakim Nivre."], "venue": "Incremental Parsing: Bringing Engineering and Cognition Together, ACL-Workshop.", "citeRegEx": "Nivre.,? 2004", "shortCiteRegEx": "Nivre.", "year": 2004}, {"title": "Algorithms for Deterministic Incremental Dependency Parsing", "author": ["Joakim Nivre."], "venue": "Computational Linguistics, 34(4):513\u2013553, December.", "citeRegEx": "Nivre.,? 2008", "shortCiteRegEx": "Nivre.", "year": 2008}, {"title": "An Effective Neural Network Model for Graph-based Dependency Parsing", "author": ["Wenzhe Pei", "Tao Ge", "Baobao Chang."], "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Nat-", "citeRegEx": "Pei et al\\.,? 2015", "shortCiteRegEx": "Pei et al\\.", "year": 2015}, {"title": "Bidirectional recurrent neural networks", "author": ["M. Schuster", "Kuldip K. Paliwal."], "venue": "IEEE Transactions on Signal Processing, 45(11):2673\u20132681, November.", "citeRegEx": "Schuster and Paliwal.,? 1997", "shortCiteRegEx": "Schuster and Paliwal.", "year": 1997}, {"title": "Learning structured prediction models: a large margin approach", "author": ["Ben Taskar", "Vassil Chatalbashev", "Daphne Koller", "Carlos Guestrin."], "venue": "Proceedings of the 22nd international conference on Machine learning, ICML \u201905, pages 896\u2013903, New York, NY, USA.", "citeRegEx": "Taskar et al\\.,? 2005", "shortCiteRegEx": "Taskar et al\\.", "year": 2005}, {"title": "Template kernels for dependency parsing", "author": ["Hillel Taub-Tabib", "Yoav Goldberg", "Amir Globerson."], "venue": "Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technolo-", "citeRegEx": "Taub.Tabib et al\\.,? 2015", "shortCiteRegEx": "Taub.Tabib et al\\.", "year": 2015}, {"title": "Structured Training for Neural Network Transition-Based Parsing", "author": ["David Weiss", "Chris Alberti", "Michael Collins", "Slav Petrov."], "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference", "citeRegEx": "Weiss et al\\.,? 2015", "shortCiteRegEx": "Weiss et al\\.", "year": 2015}, {"title": "A tale of two parsers: investigating and combining graph-based and transition-based dependency parsing using beamsearch", "author": ["Yue Zhang", "Stephen Clark."], "venue": "Proc. of EMNLP.", "citeRegEx": "Zhang and Clark.,? 2008", "shortCiteRegEx": "Zhang and Clark.", "year": 2008}, {"title": "Transition-based dependency parsing with rich non-local features", "author": ["Yue Zhang", "Joakim Nivre."], "venue": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 188\u2013193.", "citeRegEx": "Zhang and Nivre.,? 2011", "shortCiteRegEx": "Zhang and Nivre.", "year": 2011}, {"title": "A Re-ranking Model for Dependency Parser with Recursive Convolutional Neural Network", "author": ["Chenxi Zhu", "Xipeng Qiu", "Xinchi Chen", "Xuanjing Huang."], "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th", "citeRegEx": "Zhu et al\\.,? 2015", "shortCiteRegEx": "Zhu et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 19, "context": "Graph-based parsers (McDonald, 2006) treat parsing as a search-based structured prediction problem in which the goal is learning a scoring func-", "startOffset": 20, "endOffset": 36}, {"referenceID": 20, "context": "Transition-based parsers (Nivre, 2004; Nivre, 2008) treat parsing as a sequence of actions that produce a parse tree, and a classifier is trained to score the possible actions at each stage of the process and guide the parsing process.", "startOffset": 25, "endOffset": 51}, {"referenceID": 21, "context": "Transition-based parsers (Nivre, 2004; Nivre, 2008) treat parsing as a sequence of actions that produce a parse tree, and a classifier is trained to score the possible actions at each stage of the process and guide the parsing process.", "startOffset": 25, "endOffset": 51}, {"referenceID": 19, "context": "Perhaps the simplest graph-based parsers are arc-factored (first order) models (McDonald, 2006), in which the scoring function for a tree decomposes over the individual arcs of the tree.", "startOffset": 79, "endOffset": 95}, {"referenceID": 16, "context": "More elaborate models look at larger (overlapping) parts, requiring more sophisticated inference and training algorithms (Martins et al., 2009; Koo and Collins, 2010).", "startOffset": 121, "endOffset": 166}, {"referenceID": 27, "context": "More advanced transition-based parsers introduce some search into the process using a beam (Zhang and Clark, 2008) or dynamic programming (Huang and Sagae, 2010).", "startOffset": 91, "endOffset": 114}, {"referenceID": 1, "context": "2 for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of \u201ccore\u201d features and leaving it up to the machine-learning machinery to come up with good feature combinations (Chen and Manning, 2014; Pei et al., 2015; Lei et al., 2014; Taub-Tabib et al., 2015).", "startOffset": 287, "endOffset": 372}, {"referenceID": 22, "context": "2 for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of \u201ccore\u201d features and leaving it up to the machine-learning machinery to come up with good feature combinations (Chen and Manning, 2014; Pei et al., 2015; Lei et al., 2014; Taub-Tabib et al., 2015).", "startOffset": 287, "endOffset": 372}, {"referenceID": 25, "context": "2 for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of \u201ccore\u201d features and leaving it up to the machine-learning machinery to come up with good feature combinations (Chen and Manning, 2014; Pei et al., 2015; Lei et al., 2014; Taub-Tabib et al., 2015).", "startOffset": 287, "endOffset": 372}, {"referenceID": 1, "context": "For example, the work of (Chen and Manning, 2014) uses 18 different el-", "startOffset": 25, "endOffset": 49}, {"referenceID": 22, "context": "ements in its feature function, while the work of (Pei et al., 2015) uses 21 different elements.", "startOffset": 50, "endOffset": 68}, {"referenceID": 23, "context": "Our proposal (Section 3) is centered around BiRNNs (Irsoy and Cardie, 2014; Schuster and Paliwal, 1997), and more specifically BiLSTMs (Graves, 2008), which are strong and trainable sequence models (see Section 2.", "startOffset": 51, "endOffset": 103}, {"referenceID": 10, "context": "Our proposal (Section 3) is centered around BiRNNs (Irsoy and Cardie, 2014; Schuster and Paliwal, 1997), and more specifically BiLSTMs (Graves, 2008), which are strong and trainable sequence models (see Section 2.", "startOffset": 135, "endOffset": 149}, {"referenceID": 1, "context": "4 UAS), using a firstorder parser with two features and while training solely on Treebank data, without relying on semisupervised signals such as pre-trained word embeddings (Chen and Manning, 2014), word-clusters (Koo et al.", "startOffset": 174, "endOffset": 198}, {"referenceID": 26, "context": ", 2008), or techniques such as tri-training (Weiss et al., 2015).", "startOffset": 44, "endOffset": 64}, {"referenceID": 20, "context": "amples of good feature functions are the feature-set proposed by Zhang and Nivre (2011) for transition-", "startOffset": 75, "endOffset": 88}, {"referenceID": 19, "context": "based parsing (including roughly 20 core components and 72 feature templates), and the feature-set proposed by McDonald et al (2005) for graph-based parsing, with the paper listing 18 templates for a first-order parser, and the MSTParser\u2019s first-order", "startOffset": 111, "endOffset": 133}, {"referenceID": 1, "context": "Chen and Manning (2014) encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a nonlinear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations.", "startOffset": 0, "endOffset": 24}, {"referenceID": 1, "context": "Chen and Manning (2014) encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a nonlinear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations. Weiss et al (2015) showed further gains using the same approach coupled with a somewhat improved set of core features, a more involved network architecture with skip-layers, beam search-decoding, and careful hyper-parameter tuning.", "startOffset": 0, "endOffset": 300}, {"referenceID": 1, "context": "Chen and Manning (2014) encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a nonlinear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations. Weiss et al (2015) showed further gains using the same approach coupled with a somewhat improved set of core features, a more involved network architecture with skip-layers, beam search-decoding, and careful hyper-parameter tuning. Pei et al (2015)", "startOffset": 0, "endOffset": 530}, {"referenceID": 1, "context": "resentation in (Chen and Manning, 2014) is a concatenation of 18 word vectors, 18 POS vectors and 12 dependency-label vectors.", "startOffset": 15, "endOffset": 39}, {"referenceID": 9, "context": "Finally, in Kiperwasser and Goldberg (2016) we present an Easy-First parser based on a novel hierarchical-LSTM tree encoding.", "startOffset": 28, "endOffset": 44}, {"referenceID": 9, "context": "For further details on RNNs and LSTMs, the reader is referred to (Goldberg, 2015; Cho, 2015).", "startOffset": 65, "endOffset": 92}, {"referenceID": 2, "context": "For further details on RNNs and LSTMs, the reader is referred to (Goldberg, 2015; Cho, 2015).", "startOffset": 65, "endOffset": 92}, {"referenceID": 6, "context": "Historical Notes RNNs were introduced by Elamn (Elman, 1990), and extended to BiRNNs by (Schuster and Paliwal, 1997).", "startOffset": 47, "endOffset": 60}, {"referenceID": 23, "context": "Historical Notes RNNs were introduced by Elamn (Elman, 1990), and extended to BiRNNs by (Schuster and Paliwal, 1997).", "startOffset": 88, "endOffset": 116}, {"referenceID": 11, "context": "The LSTM variant of RNNs is due to (Hochreiter and Schmidhuber, 1997).", "startOffset": 35, "endOffset": 69}, {"referenceID": 6, "context": "Historical Notes RNNs were introduced by Elamn (Elman, 1990), and extended to BiRNNs by (Schuster and Paliwal, 1997). The LSTM variant of RNNs is due to (Hochreiter and Schmidhuber, 1997). BiLSTMs were recently popularized by Graves (2008), and deep BiRNNs were introduced to NLP by Irsoy and Cardie (2014), who used them for sequence tagging.", "startOffset": 48, "endOffset": 240}, {"referenceID": 6, "context": "Historical Notes RNNs were introduced by Elamn (Elman, 1990), and extended to BiRNNs by (Schuster and Paliwal, 1997). The LSTM variant of RNNs is due to (Hochreiter and Schmidhuber, 1997). BiLSTMs were recently popularized by Graves (2008), and deep BiRNNs were introduced to NLP by Irsoy and Cardie (2014), who used them for sequence tagging.", "startOffset": 48, "endOffset": 307}, {"referenceID": 21, "context": "We begin by integrating the feature extractor in a transition-based parser (Nivre, 2008).", "startOffset": 75, "endOffset": 88}, {"referenceID": 8, "context": "We follow the notation in (Goldberg and Nivre, 2013).", "startOffset": 26, "endOffset": 52}, {"referenceID": 20, "context": ", 2011), which is similar to the more popular arcstandard system (Nivre, 2004), but for which an efficient dynamic oracle is available (Goldberg and", "startOffset": 65, "endOffset": 78}, {"referenceID": 1, "context": "We follow Chen and Manning (2014) and replace the linear scoring model with an MLP.", "startOffset": 10, "endOffset": 34}, {"referenceID": 8, "context": "We perform error-exploration training using the dynamic-oracle defined in (Goldberg and Nivre, 2013).", "startOffset": 74, "endOffset": 100}, {"referenceID": 24, "context": "Graph-based parsing follows the common structured prediction paradigm (Taskar et al., 2005; McDonald et al., 2005):", "startOffset": 70, "endOffset": 114}, {"referenceID": 18, "context": "Graph-based parsing follows the common structured prediction paradigm (Taskar et al., 2005; McDonald et al., 2005):", "startOffset": 70, "endOffset": 114}, {"referenceID": 18, "context": "In this work, we focus on arc-factored graph based approach presented in (McDonald et al., 2005).", "startOffset": 73, "endOffset": 96}, {"referenceID": 5, "context": "Given the scores of the arcs the highest scoring projective tree can be efficiently found using Eisner\u2019s decoding algorithm (1996). McDonald et al and most subsequent work estimate the local score of an arc by a linear model parameterized by a weight vector w, and a feature function \u03c6(s, h,m) assigning sparse feature vector for an arc linking modifier m to head h.", "startOffset": 96, "endOffset": 131}, {"referenceID": 5, "context": "Given the scores of the arcs the highest scoring projective tree can be efficiently found using Eisner\u2019s decoding algorithm (1996). McDonald et al and most subsequent work estimate the local score of an arc by a linear model parameterized by a weight vector w, and a feature function \u03c6(s, h,m) assigning sparse feature vector for an arc linking modifier m to head h. We follow Pei et al (2015) and replace the linear scoring function with an MLP.", "startOffset": 96, "endOffset": 394}, {"referenceID": 18, "context": "We use a margin-based objective (McDonald et al., 2005; LeCun et al., 2006), aiming to maximize the margin between the score of the gold tree y and highest scoring incorrect tree y\u2032.", "startOffset": 32, "endOffset": 75}, {"referenceID": 0, "context": "This sharing of parameters can be seen as an instance of multi-task learning (Caruana, 1997).", "startOffset": 77, "endOffset": 92}, {"referenceID": 24, "context": "In order to remedy this, we found it useful to use loss augmented inference (Taskar et al., 2005).", "startOffset": 76, "endOffset": 97}, {"referenceID": 4, "context": "For comparison purposes we follow the setup of (Dyer et al., 2015).", "startOffset": 47, "endOffset": 66}, {"referenceID": 15, "context": "Data For English, we used the Stanford Dependency (SD) (de Marneffe and Manning, 2008) conversion of the Penn Treebank (Marcus et al., 1993), using the standard train/dev/test splitswith the same predicted POS-tags as used in (Dyer et al.", "startOffset": 119, "endOffset": 140}, {"referenceID": 4, "context": ", 1993), using the standard train/dev/test splitswith the same predicted POS-tags as used in (Dyer et al., 2015; Chen and Manning, 2014).", "startOffset": 93, "endOffset": 136}, {"referenceID": 1, "context": ", 1993), using the standard train/dev/test splitswith the same predicted POS-tags as used in (Dyer et al., 2015; Chen and Manning, 2014).", "startOffset": 93, "endOffset": 136}, {"referenceID": 27, "context": "1 (CTB5), using the train/test/dev splits of (Zhang and Clark, 2008; Dyer et al., 2015) with gold partof-speech tags, also following (Dyer et al.", "startOffset": 45, "endOffset": 87}, {"referenceID": 4, "context": "1 (CTB5), using the train/test/dev splits of (Zhang and Clark, 2008; Dyer et al., 2015) with gold partof-speech tags, also following (Dyer et al.", "startOffset": 45, "endOffset": 87}, {"referenceID": 4, "context": ", 2015) with gold partof-speech tags, also following (Dyer et al., 2015; Chen and Manning, 2014).", "startOffset": 53, "endOffset": 96}, {"referenceID": 1, "context": ", 2015) with gold partof-speech tags, also following (Dyer et al., 2015; Chen and Manning, 2014).", "startOffset": 53, "endOffset": 96}, {"referenceID": 4, "context": "When using external word embeddings, we also use the same data as (Dyer et al., 2015).", "startOffset": 66, "endOffset": 85}, {"referenceID": 20, "context": "The greedy transition based parser with 4 features also matches or outperforms most other parsers, including the beam-based transition parser with heavily engineered features of Zhang and Nivre (2011) and the Stack-LSTM parser of", "startOffset": 188, "endOffset": 201}, {"referenceID": 28, "context": "The different systems and the numbers reported from them are taken from: ZhangNivre11: (Zhang and Nivre, 2011); Martins13: (Martins et al.", "startOffset": 87, "endOffset": 110}, {"referenceID": 17, "context": "The different systems and the numbers reported from them are taken from: ZhangNivre11: (Zhang and Nivre, 2011); Martins13: (Martins et al., 2013); Weiss15 (Weiss et al.", "startOffset": 123, "endOffset": 145}, {"referenceID": 26, "context": ", 2013); Weiss15 (Weiss et al., 2015); Pei15: (Pei et al.", "startOffset": 17, "endOffset": 37}, {"referenceID": 22, "context": ", 2015); Pei15: (Pei et al., 2015); Dyer15 (Dyer et al.", "startOffset": 16, "endOffset": 34}, {"referenceID": 4, "context": ", 2015); Dyer15 (Dyer et al., 2015); LeZuidema14 (Le and Zuidema, 2014); Zhu15: (Zhu et al.", "startOffset": 16, "endOffset": 35}, {"referenceID": 29, "context": ", 2015); LeZuidema14 (Le and Zuidema, 2014); Zhu15: (Zhu et al., 2015).", "startOffset": 52, "endOffset": 70}], "year": 2016, "abstractText": "We present a simple and effective scheme for dependency parsing which is based on bidirectional-LSTMs (BiLSTMs). Each sentence token is associated with a BiLSTM vector representing the token in its sentential context, and feature vectors are constructed by concatenating a few BiLSTM vectors. The BiLSTM is trained jointly with the parser objective, resulting in very effective feature extractors for parsing. We demonstrate the effectiveness of the approach by applying it to a greedy transition based parser as well as to a globally optimized graph-based parser. The resulting parsers have very simple architectures, and match or surpass the state-of-the-art accuracies on English and Chinese.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}