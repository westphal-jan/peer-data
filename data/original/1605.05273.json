{"id": "1605.05273", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-May-2016", "title": "Learning Convolutional Neural Networks for Graphs", "abstract": "Numerous important problems can be framed as learning from graph data. We propose a framework for learning convolutional neural networks for arbitrary graphs. These graphs may be undirected, directed, and with both discrete and continuous node and edge attributes. Analogous to image-based convolutional networks that operate on locally connected regions of the input, we present a general approach to extracting locallyconnected regions from graphs. Using established benchmark data sets, we demonstrate that the learned feature representations are competitive with state of the art graph kernels and that their computation is highly efficient.", "histories": [["v1", "Tue, 17 May 2016 18:13:13 GMT  (379kb,D)", "http://arxiv.org/abs/1605.05273v1", "To be presented at ICML 2016"], ["v2", "Wed, 18 May 2016 15:38:30 GMT  (379kb,D)", "http://arxiv.org/abs/1605.05273v2", "To be presented at ICML 2016"], ["v3", "Mon, 6 Jun 2016 13:33:38 GMT  (379kb,D)", "http://arxiv.org/abs/1605.05273v3", "To be presented at ICML 2016"], ["v4", "Wed, 8 Jun 2016 11:40:13 GMT  (379kb,D)", "http://arxiv.org/abs/1605.05273v4", "To be presented at ICML 2016"]], "COMMENTS": "To be presented at ICML 2016", "reviews": [], "SUBJECTS": "cs.LG cs.AI stat.ML", "authors": ["mathias niepert", "mohamed ahmed", "konstantin kutzkov"], "accepted": true, "id": "1605.05273"}, "pdf": {"name": "1605.05273.pdf", "metadata": {"source": "META", "title": "Learning Convolutional Neural Networks for Graphs", "authors": ["Mathias Niepert", "Mohamed Ahmed", "Konstantin Kutzkov"], "emails": ["MATHIAS.NIEPERT@NECLAB.EU", "M.AHMED@NECLAB.EU", "KONSTANTIN.KUTZKOV@NECLAB.EU"], "sections": [{"heading": "1. Introduction", "text": "With this paper we aim to bring convolutional neural networks to bear on a large class of graph-based learning problems. We consider the following two problems.\n1. Given a collection of graphs, learn a function that can be used for classification and regression problems on unseen graphs. The nodes and edges of any two graphs are not necessarily in correspondence. For instance, each graph of the collection could model a chemical compound and the output could be a function mapping unseen compounds to their level of activity against cancer cells.\n2. Given a large graph, learn graph representations that can be used to infer unseen graph properties such as node types and missing edges.\nWe propose a framework for learning representations for classes of directed and undirected graphs. The graphs may\nProceedings of the 33 rd International Conference on Machine Learning, New York, NY, USA, 2016. JMLR: W&CP volume 48. Copyright 2016 by the author(s).\n1 2\n3 4\n1 2\n3 4\n1 2\n3 4\n1 2\n3 4\n1 1 1 1... ...\n......(b)\n(a)\nFigure 1. A CNN with a receptive field of size 3x3. The field is moved over an image from left to right and top to bottom using a particular stride (here: 1) and zero-padding (here: none) (a). The values read by the receptive fields are transformed into a linear layer and fed to a convolutional architecture (b). The node sequence for which the receptive fields are created and the shapes of the receptive fields are fully determined by the hyper-parameters.\nhave nodes and edges with multiple discrete and continuous attributes and may have multiple types of edges. Similar to convolutional neural network for images, we construct locally connected neighborhoods from the input graphs. These neighborhoods are generated efficiently and serve as the receptive fields of a convolutional architecture, allowing the framework to learn effective graph representations.\nThe proposed approach builds on concepts from convolutional neural networks (CNNs) (Fukushima, 1980; Atlas et al., 1988; LeCun et al., 1998; 2015) for images and extends them to arbitrary graphs. Figure 1 illustrates the locally connected receptive fields of a CNN for images. An image can be represented as a square grid graph whose nodes represent pixels. Now, a CNN can be seen as traversing a node sequence (nodes 1-4 in Figure 1(a)) and generating fixed-size neighborhood graphs (the 3x3 grids in Figure 1(b)) for each of the nodes. The neighborhood graphs serve as the receptive fields to read feature values from the pixel nodes. Due to the implicit spatial order of the pixels, the sequence of nodes for which neighborhood graphs are created, from left to right and top to bottom, is uniquely determined. The same holds for NLP problems where each sentence (and its parse-tree) determines ar X\niv :1\n60 5.\n05 27\n3v 1\n[ cs\n.L G\n] 1\n7 M\nay 2\n01 6\na sequence of words. However, for numerous graph collections a problem-specific ordering (spatial, temporal, or otherwise) is missing and the nodes of the graphs are not in correspondence. In these instances, one has to solve two problems: (i) Determining the node sequences for which neighborhood graphs are created and (ii) computing a normalization of neighborhood graphs, that is, a unique mapping from a graph representation into a vector space representation. The proposed approach, termed PATCHY-SAN, addresses these two problems for arbitrary graphs. For each input graph, it first determines nodes (and their order) for which neighborhood graphs are created. For each of these nodes, a neighborhood consisting of exactly k nodes is extracted and normalized, that is, it is uniquely mapped to a space with a fixed linear order. The normalized neighborhood serves as the receptive field for a node under consideration. Finally, feature learning components such as convolutional and dense layers are combined with the normalized neighborhood graphs as the CNN\u2019s receptive fields.\nFigure 2 illustrates the PATCHY-SAN architecture which has several advantages over existing approaches: First, it is highly efficient, naively parallelizable, and applicable to large graphs. Second, for a number of applications, ranging from computational biology to social network analysis, it is important to visualize learned network motifs (Milo et al., 2002). PATCHY-SAN supports feature visualizations providing insights into the structural properties of graphs. Third, instead of crafting yet another graph kernel, PATCHY-SAN learns application dependent features without the need to feature engineering. Our theoretical contributions are the definition of the normalization problem on graphs and its complexity; a method for comparing graph labeling approaches for a collection of graphs; and a result that shows that PATCHY-SAN generalizes CNNs on images. Using standard benchmark data sets, we demonstrate that the learned CNNs for graphs are both efficient and effective compared to state of the art graph kernels."}, {"heading": "2. Related Work", "text": "Graph kernels allow kernel-based learning approaches such as SVMs to work directly on graphs (Vishwanathan et al., 2010). Kernels on graphs were originally defined as similarity functions on the nodes of a single graph (Kondor & Lafferty, 2002). Two representative classes of kernels are the skew spectrum kernel (Kondor & Borgwardt, 2008) and kernels based on graphlets (Kondor et al., 2009; Shervashidze et al., 2009). The latter is related to our work, as it builds kernels based on fixed-sized subgraphs. These subgraphs, which are often called motifs or graphlets, reflect functional network properties (Milo et al., 2002; Alon, 2007). However, due to the combinatorial complexity of subgraph enumeration, graphlet kernels are restricted to\nsubgraphs with few nodes. An effective class of graph kernels are the Weisfeiler-Lehman (WL) kernels (Shervashidze et al., 2011). WL kernels, however, only support discrete features and use memory linear in the number of training examples at test time. PATCHY-SAN uses WL as one possible labeling procedure to compute receptive fields. Deep graph kernels (Yanardag & Vishwanathan, 2015) and graph invariant kernels (Orsini et al., 2015) compare graphs based on the existence or count of small substructures such as shortest paths (Borgwardt & Kriegel, 2005), graphlets, subtrees, and other graph invariants (Haussler, 1999; Orsini et al., 2015). In contrast, PATCHY-SAN learns substructures from graph data and is not limited to a predefined set of motifs. Moreover, while all graph kernels have a training complexity at least quadratic in the number of graphs (Shervashidze et al., 2011), which is prohibitive for large-scale problems, PATCHY-SAN scales linearly with the number of graphs.\nGraph neural networks (GNNs) (Scarselli et al., 2009) are a recurrent neural network architecture defined on graphs. GNNs apply recurrent neural networks for walks on the graph structure, propagating node representations until a fixed point is reached. The resulting node representations are then used as features in classification and regression problems. GNNs support only discrete labels and perform as many backpropagation operations as there are edges and nodes in the graph per learning iteration. Gated Graph Sequence Neural Networks modify GNNs to use gated recurrent units and to output sequences (Li et al., 2015).\nRecent work extended CNNs to topologies that differ from the low-dimensional grid structure (Bruna et al., 2014; Henaff et al., 2015). All of these methods, however, assume one global graph structure, that is, a correspondence of the vertices across input examples. (Duvenaud et al., 2015) perform convolutional type operations on graphs, developing a differentiable variant of one specific graph feature."}, {"heading": "3. Background", "text": "We provide a brief introduction to the required background in convolutional networks and graph theory."}, {"heading": "3.1. Convolutional Neural Networks", "text": "CNNs were inspired by earlier work that showed that the visual cortex in animals contains complex arrangements of cells, responsible for detecting light in small local regions of the visual field (Hubel & Wiesel, 1968). CNNs were developed in the 1980s and have been applied to image, speech, text, and drug discovery problems (Atlas et al., 1988; LeCun et al., 1989; 1998; 2015; Wallach et al., 2015). A predecessor to CNNs was the Neocognitron (Fukushima, 1980). A typical CNN is composed of convolutional and dense layers. The purpose of the first convolutional layer is the extraction of common patterns found within local regions of the input images. CNNs convolve learned filters over the input image, computing the inner product at every image location in the image and outputting the result as tensors whose depth is the number of filters."}, {"heading": "3.2. Graphs", "text": "A graph G is a pair (V,E) with V = {v1, ..., vn} the set of vertices andE \u2286 V \u00d7V the set of edges. Let n be the number of vertices and m the number of edges. An undirected graph is a graph in which edges have no direction. Each graph can be represented by an adjacency matrix A of size n \u00d7 n, where Ai,j = 1 if there is an edge from vertex vi to vertex vj , and Ai,j = 0 otherwise. In this case, we say that vertex vi has position i in A. Moreover, if Ai,j = 1 we say vi and vj are adjacent. Node and edge attributes are features that attain one value for each node and edge of a graph. We use the term attribute value instead of label to avoid confusion with the graph-theoretical concept of a labeling. A walk is a sequence of nodes in a graph, in which consecutive nodes are connected by an edge. A path is a walk with distinct nodes. We write d(u, v) to denote the distance between u and v, that is, the length of the shortest path between u and v. N1(v) is the 1-neighborhood of a node, that is, all nodes that are adjacent to v.\nLabeling and Node Partitions. PATCHY-SAN utilizes graph labelings to impose an order on nodes. A graph labeling ` is a function ` : V \u2192 S from the set of vertices V to an ordered set S such as the real numbers and integers. A graph labeling procedure computes a graph labeling for an input graph. When it is clear from the context, we use labeling to refer to both, the graph labeling and the procedure to compute it. A ranking (or coloring) is a function r : V \u2192 {1, ..., |V |}. Every labeling induces a ranking r with r(u) < r(v) if and only if `(u) > `(v). If the labeling ` of graph G is injective, it determines a total or-\nAlgorithm 1 SELNODESEQ: Select Node Sequence 1: input: graph labeling `, graph G = (V,E), stride s, width\nw, receptive field size k 2: Vsort = top w elements of V according to ` 3: i = 1, j = 1 4: while j < w do 5: if i \u2264 |Vsort| then 6: f = RECEPTIVEFIELD(Vsort[i]) 7: else 8: f = ZERORECEPTIVEFIELD() 9: apply f to each input channel\n10: i = i+ s, j = j + 1\nAlgorithm 2 NEIGHASSEMB: Neighborhood Assembly 1: input: vertex v, receptive field size k 2: output: set of neighborhood nodes N for v 3: N = [v] 4: L = [v] 5: while |N | < k and |L| > 0 do 6: L = \u22c3 v\u2208L N1(v)\n7: N = N \u222a L 8: return the set of vertices N\nder of G\u2019s vertices a unique adjacency matrix A`(G) of G where vertex v has position r(v) in A`(G). Moreover, every graph labeling induces a partition {V1, ..., Vn} on V with u, v \u2208 Vi if and only if `(u) = `(v).\nExamples of graph labeling procedures are node degree and other measures of centrality commonly used in the analysis of networks. For instance, the betweeness centrality of a vertex v computes the fractions of shortest paths that pass through v. The Weisfeiler-Lehman algorithm (Weisfeiler & Lehman, 1968) is a procedure for partitioning the vertices of a graph. It is also known as color refinement and naive vertex classification. Color refinement has attracted considerable interest in the ML community as it can be applied to speed-up inference in graphical models (Kersting et al., 2009; 2014) and as a method to compute graph kernels (Shervashidze et al., 2011). PATCHY-SAN applies these labeling procedures, among others (degree, page-rank, eigenvector centrality, etc.), to impose an order on the nodes of graphs, replacing application-dependent orders (temporal, spatial, etc.) where missing.\nIsomorphism and Canonicalization. The computational problem of deciding whether two graphs are isomorphic surfaces in several application domains. The graph isomorphism (GI) problem is in NP but not known to be in P or NP-hard. Under several mild restrictions, GI is known to be in P. For instance, GI is in P for graphs of bounded degree (Luks, 1982). A canonicalization of a graph G is a graph G\u2032 with a fixed vertex order which is isomorphic to G and which represents its entire isomorphism class. In practice, the graph canonicalization tool NAUTY has shown remarkable performance (McKay & Piperno, 2014)."}, {"heading": "4. Learning CNNs for Arbitrary Graphs", "text": "When CNNs are applied to images, a receptive field (a square grid) is moved over each image with a particular step size. The receptive field reads the pixels\u2019 feature values, once for each channel, and a patch of values is created for each channel. Since the pixels of an image have an implicit arrangement \u2013 a spatial order \u2013 the receptive fields are always moved from left to right and top to bottom. Moreover, the spatial order uniquely determines the nodes of each receptive field and the way its nodes are mapped to a vector space representation (see Figure 1(b)). Consequently, the values read from two pixels using two different locations of the receptive field are assigned to the same relative position if and only if the pixels\u2019 structural roles (their spatial position within the receptive field) are identical.\nTo show the connection between CNNs and PATCHY-SAN, we frame CNNs on images as identifying a sequence of nodes in the square grid graph representing the image and building a normalized neighborhood graph \u2013 a receptive field \u2013 for each node in the identified sequence. For graph collections where an application-dependent node order is missing and where the nodes of any two graphs are not yet aligned, we need to determine for each graph (i) the sequences of nodes for which we create neighborhoods, and (ii) a unique mapping from the graph representation to a vector representation such that nodes with similar structural roles in the neighborhood graphs are positioned similarly in the vector representation.\nWe address these problems by leveraging graph labeling procedures that assigns nodes of two different graphs to a similar relative position in their respective adjacency matrices if their structural roles within the graphs are similar. Given a collection of graphs, PATCHY-SAN (SELECTASSEMBLE-NORMALIZE) applies the following steps to each graph: (1) Select a fixed-length sequence of nodes from the graph; (2) assemble a fixed-size neighborhood for each node in the selected sequence; (3) normalize the extracted neighborhood graph; and (4) learn neighborhood representations with convolutional neural networks from the resulting sequence of patches.\nAlgorithm 3 NORMALIZEGRAPH: Graph Normalization 1: input: subset of vertices U from original graph G, vertex v,\ngraph labeling `, receptive field size k 2: output: receptive field for v 3: compute ranking r of U using `, subject to \u2200u,w \u2208 U : d(u, v) < d(w, v)\u21d2 r(u) < r(w) 4: if |U | > k then 5: N = top k vertices in U according to r 6: compute ranking r of N using `, subject to \u2200u,w \u2208 N : d(u, v) < d(w, v)\u21d2 r(u) < r(w) 7: else if |V | < k then 8: N = U and k \u2212 |U | dummy nodes 9: else\n10: N = U 11: construct the subgraph G[N ] for the vertices N 12: canonicalize G[N ], respecting the prior coloring r 13: return G[N ]\nIn the following, we describe methods that address the above-mentioned challenges."}, {"heading": "4.1. Node Sequence Selection", "text": "Node sequence selection is the process of identifying, for each input graph, a sequence of nodes for which receptive fields are created. Algorithm 1 lists one such procedure. First, the vertices of the input graph are sorted with respect to a given graph labeling, turning the nodes of the graph into a sequence of nodes. Second, the resulting node sequence is traversed using a given stride s and for each visited node, Algorithm 4 is executed to construct a receptive field, until exactlyw receptive fields have been created. The stride s determines the distance, relative to the selected node sequence, between two consecutive nodes for which a receptive field is created. If the number of nodes is smaller than w, the algorithm creates all-zero receptive fields for padding purposes.\nSeveral alternative methods for vertex sequence selection are possible. For instance, a depth-first traversal of the input graph guided by the values of the graph labeling. We leave these ideas to future work.\nAlgorithm 4 RECEPTIVEFIELD: Create Receptive Field 1: input: vertex v, graph labeling `, receptive field size k 2: N = NEIGHASSEMB(v, k) 3: Gnorm = NORMALIZEGRAPH(N, v, `, k) 4: return Gnorm"}, {"heading": "4.2. Neighborhood Assembly", "text": "For each of the nodes identified in the previous step, a receptive field has to be constructed. Algorithm 4 first calls Algorithm 2 to assembles a local neighborhood for the input node. The nodes of the neighborhood are the candidates for the receptive field. Algorithm 2 lists the neighborhood assembly procedure. Given as inputs a node v and the size of the receptive field k, the procedure performs a breadth-first search, exploring vertices with an increasing distance from v, and adds these vertices to a set N . First, the algorithm collects N1(v), the 1-neighborhood of v. If the number of collected nodes is smaller than k, the 1-neighborhood of the vertices most recently added to N are collected, and so on, until at least k vertices are in N , or until there are no more neighbors to add. Note that at this time, the size of N is possibly different to k."}, {"heading": "4.3. Graph Normalization", "text": "The receptive field for a node is constructed by normalizing the neighborhood assembled in the previous step. Illustrated in Figure 3, the normalization imposes an order on the nodes of the neighborhood graph so as to map from the unordered graph space to a vector space with a linear order. The basic idea is to leverage graph labeling procedures that assigns nodes of two different graphs to a similar relative position in the respective adjacency matrices if and only if their structural roles within the graphs are similar.\nTo formalize this intuition, we define the optimal graph normalization problem which aims to find a labeling that is optimal relative to a given collection of graphs.\nProblem 1 (Optimal graph normalization). Let G be a collection of unlabeled graphs with k nodes, let ` be an injective graph labeling procedure, let dG be a distance measure on graphs with k nodes, and let dA be a distance measure on k \u00d7 k matrices. Find \u02c6\u0300such that\n\u02c6\u0300= argmin `\nEG [\u2223\u2223dA (A`(G),A`(G\u2032))\u2212 dG(G,G\u2032)\u2223\u2223] .\nThis problem amounts to finding a graph labeling procedure `, such that, for any two graphs drawn uniformly at random from G, the expected difference between the distance of the graphs in vector space (with respect to the adjacency matrices based on `) and the distance of the graphs in graph space is minimized. The optimal graph normalization problem is a generalization of the classical graph\ncanonicalization problem. A canonical labeling algorithm, however, is optimal only for isomorphic graphs and might perform poorly for graphs that are similar but not isomorphic. In contrast, the smaller the expectation of the optimal normalization problem, the better the labeling aligns nodes with similar structural roles. Note that the similarity is determined by dG.\nWe have the following result concerning the complexity of the optimal normalization problem.\nTheorem 1. Optimal graph normalization is NP-hard.\nProof: By reduction from subgraph isomorphism.\nPATCHY-SAN does not solve the above optimization problem. Instead, it may compare different graph labeling methods and choose the one that performs best relative to a given collection of graphs.\nTheorem 2. Let G be a collection of graphs and let (G1, G \u2032 1), ..., (GN , G \u2032 N ) be a sequence of pairs of graphs sampled independently and uniformly at random from G. Let \u03b8\u0302` := \u2211N i=1 dA ( A`(Gi),A `(G\u2032i) ) /N and \u03b8` :=\nEG [\u2223\u2223dA (A`(G),A`(G\u2032))\u2212 dG(G,G\u2032)\u2223\u2223]. If dA \u2265 dG, then EG [\u03b8\u0302`1 ] < EG [\u03b8\u0302`2 ] if and only if \u03b8`1 < \u03b8`2 .\nTheorem 2 enables us to compare different labeling procedures in an unsupervised manner via a comparison of the corresponding estimators. Under the assumption dA \u2265 dG, the smaller the estimate \u03b8\u0302` the smaller the absolute difference. Therefore, we can simply choose the labeling ` for which \u03b8\u0302` is minimal. The assumption dA \u2265 dG holds, for instance, for the edit distance on graphs and the Hamming distance on adjacency matrices. Finally, note that all of the above results can be extended to directed graphs.\nThe graph normalization problem and the application of appropriate graph labeling procedures for the normalization of local graph structures is at the core of the proposed approach. Within the PATCHY-SAN framework, we normalize the neighborhood graphs of a vertex v. The labeling of the vertices is therefore constrained by the graph distance to v: for any two vertices u,w, if u is closer to v thanw, then v is always ranked higher than w. This definition ensures that v has always rank 1, and that the closer a vertex is to v in G, the higher it is ranked in the vector space representation.\nSince most labeling methods are not injective, it is necessary to break ties between same-label nodes. To do so, we use NAUTY (McKay & Piperno, 2014). NAUTY accepts prior node partitions as input and breaks remaining ties by choosing the lexicographically maximal adjacency matrix. It is known that graph isomorphism is in PTIME for graphs of bounded degree (Luks, 1982). Due to the constant size k of the neighborhood graphs, the algorithm runs in time polynomial in the size of the original graph and, on average, in time linear in k (Babai et al., 1980). The experiments we\nconducted verify that computing a canonical labeling of the graph neigborhoods adds a negligible overhead.\nAlgorithm 3 lists the normalization procedure. If the size of the input set U is larger than k, it first applies the ranking based on ` to select the top k nodes and computes the ranking again on the smaller set of nodes. If the size of U is smaller than k, it adds disconnected dummy nodes. Finally, it induces the subgraph on the verticesN and canonicalizes the graph taking the ranking r as prior coloring.\nWe can relate PATCHY-SAN to CNNs for images as follows. Theorem 3. Given a sequence of pixels taken from an image. Applying PATCHY-SAN with receptive field size (2m \u2212 1)2, stride s, no zero padding, and 1-WL normalization to the sequence is identical (up to a fixed permutation of the receptive field) to the first layer of a CNN with receptive field size 2m\u2212 1, stride s, and no zero padding.\nProof: It is possible to show that if an input graph is a square grid, then the 1-WL normalized receptive field constructed for a vertex is always a square grid graph with a unique vertex order."}, {"heading": "4.4. Convolutional Architecture", "text": "PATCHY-SAN is able to process both vertex and edge attributes (discrete and continuous). Let av be the number of vertex attributes and ae be the number of edge attributes. For each input graph G, it applies the normalized receptive fields for vertices and edges which results in a (w, k, av) and (w, k, k, ae) tensor, respectively. This can be reshaped to the 2-dimensional (wk, av) and a (wk2, ae) tensors, respectively. Note that av and ae are the number of input channels. We can now apply a 1-dimensional convolutional layer with stride k to the first and with stride k2 to the second tensor. The rest of the architecture can be chosen arbitrarily. To combine convolutional layers representing nodes and edges, respectively, one may use merge layers."}, {"heading": "5. Complexity and Implementation", "text": "PATCHY-SAN\u2019s algorithm for creating receptive fields is highly efficient and naively parallelizable because the fields are generated independently. We can show the following asymptotic worst-case result. Theorem 4. Let N be the number of graphs, let k be the receptive field size, w the width, and O(f(n,m)) the complexity of computing a given labeling ` for a graph with n vertices and m edges. PATCHY-SAN has a worst-case complexity of O(Nw(f(n,m) + n log(n) + exp(k))) for computing the receptive fields for N graphs.\nProof: Node sequence selection requires the labeling of each input graph and the retrieval of the k highest ranked nodes. For the creation of normalized graph patches, most\ncomputational effort is spent on evaluating the labeling ` for a neighborhood that is potentially larger than k. Let d be the maximum degree of the input graph G, and U the neighborhood returned by Algorithm 2. We have |U | \u2264 (k \u2212 2)d \u2264 n. The term exp(k) comes from the worstcase complexity of the graph canonicalization algorithm NAUTY on a k node graph (Miyazaki, 1997).\nFor instance, for the Weisfeiler-Lehman algorithm, which has a complexity of O((n + m) log(n)) (Berkholz et al., 2013), and constants w n and k n, the complexity of PATCHY-SAN is linear in N and quasi-linear in m and n. PATCHY-SAN was implemented in PYTHON."}, {"heading": "6. Experiments", "text": "We conduct three types of experiments: a runtime analysis, a qualitative analysis of the learned features, and a comparison to graph kernels on benchmark data sets."}, {"heading": "6.1. Runtime Analysis", "text": "We assess the efficiency of PATCHY-SAN by applying it to real-world graphs. The objective is to compare the rates at which receptive fields can be generated to the rate at which state of the art CNNs perform learning. All graphs are part of the collection of the Python module GRAPH-TOOL1. For a given graph, we used PATCHY-SAN to compute a receptive field for all nodes using 1-WL normalization. torus is a periodic lattice with 10, 000 nodes; random is a random undirected graph with degree distribution P (k) \u221d 1/k and kmax = 3; power is a network representing the topology of a power grid in the US; polbooks is a co-purchasing network of books about US politics published during the 2004 presidential election; preferential is a preferential attachment network model where newly added vertices have degree 3; astro-ph is a coauthorship network between authors of preprints posted on the astrophysics arxiv (Newman, 2001); email-enron is a communication network generated from about half a million sent emails (Leskovec et al., 2009). Experiments were run on commodity hardware with 64G RAM and one 2.8 GHz CPU.\n1https://graph-tool.skewed.de/\nFigure 4 depicts the receptive fields per second rate for each graph. For field size k = 5 and k = 10 PATCHYSAN creates fields at a rate of more than 1000/s except for email-enron with a rate of 600/s and 320/s, respectively. For k = 50, the largest tested size, fields are created at a rate of at least 100/s. A CNN with 2 convolutional and 2 dense layers learns at a rate of about 200-400 training examples per second on the same machine. Hence, the speed at which receptive fields are generated is sufficient to saturate a downstream CNN."}, {"heading": "6.2. Feature Visualization", "text": "The visualization experiments\u2019 aim is to qualitatively investigate whether popular models such as the restricted Boltzman machine (RBM) (Freund & Haussler, 1992) can be combined with PATCHY-SAN for unsupervised feature learning. For every input graph, we generated receptive fields for all nodes and used these as input to an RBM. The RBM had 100 hidden nodes and was trained for 30 epochs with contrastive divergence and a learning rate of 0.01. We visualize the features learned by a single-layer RBM for 1-WL normalized receptive fields of size 9. Note that the features learned by the RBM correspond to reoccurring receptive field patterns. Figure 5 depicts some of the features and samples drawn from it for four different graphs."}, {"heading": "6.3. Graph Classification", "text": "Graph classification is the problem of assigning graphs to one of several categories.\nData Sets. We use 6 standard benchmark data sets to compare run-time and classification accuracy with state of the art graph kernels: MUTAG, PCT, NCI1, NCI109, PROTEIN, and D&D. MUTAG (Debnath et al., 1991) is a data set of 188 nitro compounds where classes indicate whether\nthe compound has a mutagenic effect on a bacterium. PTC consists of 344 chemical compounds where classes indicate carcinogenicity for male and female rats (Toivonen et al., 2003). NCI1 and NCI109 are chemical compounds screened for activity against non-small cell lung cancer and ovarian cancer cell lines (Wale & Karypis, 2006). PROTEINS is a graph collection where nodes are secondary structure elements and edges indicate neighborhood in the amino-acid sequence or in 3D space. Graphs are classified as enzyme or non-enzyme. D&D is a data set of 1178 protein structures (Dobson & Doig, 2003) classified into enzymes and non-enzymes.\nExperimental Set-up. We compared PATCHY-SAN with the shortest-path kernel (SP) (Borgwardt & Kriegel, 2005), the random walk kernel (RW) (Gaertner et al., 2003), the graphlet count kernel (GK) (Shervashidze et al., 2009), and the Weisfeiler-Lehman subtree kernel (WL) (Shervashidze et al., 2011). Similar to previous work (Yanardag & Vishwanathan, 2015), we set the height parameter of WL to 2, the size of the graphlets for GK to 7, and chose the decay factor for RW from {10\u22126, 10\u22125, ..., 10\u22121}. We performed 10-fold cross-validation with LIB-SVM (Chang & Lin, 2011), using 9 folds for training and 1 for testing, and repeated the experiments 10 times. We report average prediction accuracies and standard deviations.\nFor PATCHY-SAN (referred to as PSCN), we used 1-WL normalization, a width w equal to the average number of nodes (see Table 1), and receptive field sizes of k = 5 and k = 10. For the experiments we only used node attributes. In addition, we ran experiments for k = 10 where we combined receptive fields for nodes and edges using a merge layer (k = 10E). To make a fair comparison, we used a single network architecture with two convolutional layers, one dense hidden layer, and a softmax layer for all experiments. The first convolutional layer had 16 output channels\n(feature maps). The second convolutional layer has 8 output channels, a stride of s = 1, and a field size of 10. The convolutional layers have rectified linear units. The dense layer has 128 rectified linear units with a dropout rate of 0.5. Dropout and the relatively small number of neurons are needed to avoid overfitting on the smaller data sets. The only hyperparameter we optimized is the number of epochs and the batch size for the mini-batch gradient decent algorithm RMSPROP. All of the above was implemented with the THEANO (Bergstra et al., 2010) wrapper KERAS (Chollet, 2015). We also applied a logistic regression (PSLR) classifier on the patches for k = 10.\nMoreover, we ran experiments with the same set-up2 on larger social graph data sets (up to 12000 graphs each, with an average of 400 nodes), and compared PATCHY-SAN with previously reported results for the graphlet count (GK) and the deep graphlet count kernel (DGK) (Yanardag & Vishwanathan, 2015). We used the normalized node degree as attribute for PATCHY-SAN, featuring one of its advantages: it can easily incorporate continuous features.\nResults. Table 1 lists the results of the experiments. We omit the results for NCI109 as they are almost identical to NCI1. Despite using a one-fits-all CN architecture, the CNs accuracy is highly competitive with existing graph kernels. A receptive field size of 10 leads usually to a better classification accuracy. The relatively high variance can be explained with the data set\u2019s small size and the fact that the\n2Due to the larger size of the data sets, we removed dropout.\nCNs hyperparameters (with the exception of epochs and batch size) were not tuned to individual data sets. Similar to the experience on image and text data, we expect PATCHYSAN to perform even better for large data sets. Moreover, PATCHY-SAN is between 2 and 8 times more efficient than the most efficient graph kernel (WL). We expect the performance advantage to be much more pronounced for data sets with a large number of graphs. Results for betweeness centrality normalization are similar with the exception of the runtime which increases by about 10%. Logistic regression applied to PATCHY-SAN\u2019s receptive fields performs worse, indicating that PATCHY-SAN works especially well in conjunction with CNNs which learn non-linear feature combinations and which share weights across receptive fields.\nPATCHY-SAN is also highly competitive on the social graph data. It significantly outperforms the other two kernels on four of the six data sets and achieves ties on the rest. Table 2 lists the results of the experiments."}, {"heading": "7. Conclusion and Future Work", "text": "We proposed a framework for learning graph representations that are especially beneficial in conjunction with CNNs. It combines two complementary procedures: (a) selecting a sequence of nodes that covers large parts of the graph and (b) generating local normalized neigbrohood representations for each of the nodes in the sequence. Experiments show that the approach is competitive with state of the art graph kernels.\nDirections for future work include the use of alternative neural network architectures such as RNNs; combining different receptive field sizes; pretraining with RBMs and autoencoders; and statistical relational models based on the ideas of the approach."}, {"heading": "ACKNOWLEDGMENTS", "text": "Many thanks to the anonymous ICML reviewers who provided tremendously helpful comments."}], "references": [{"title": "Network motifs: theory and experimental approaches", "author": ["Alon", "Uri"], "venue": "Nature Reviews Genetics,", "citeRegEx": "Alon and Uri.,? \\Q2007\\E", "shortCiteRegEx": "Alon and Uri.", "year": 2007}, {"title": "An artificial neural network for spatio-temporal bipolar patterns: Application to phoneme classification", "author": ["Atlas", "Les E", "Homma", "Toshiteru", "Marks", "Robert J. II"], "venue": "Neural Information Processing Systems,", "citeRegEx": "Atlas et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Atlas et al\\.", "year": 1988}, {"title": "Random graph isomorphism", "author": ["Babai", "L\u00e1szl\u00f3", "Erd\u0151s", "Paul", "Selkow", "Stanley M"], "venue": "SIAM J. Computing,", "citeRegEx": "Babai et al\\.,? \\Q1980\\E", "shortCiteRegEx": "Babai et al\\.", "year": 1980}, {"title": "Emergence of scaling in random networks", "author": ["Barab\u00e1si", "Albert-Laszlo", "Albert", "R\u00e9ka"], "venue": null, "citeRegEx": "Barab\u00e1si et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Barab\u00e1si et al\\.", "year": 1999}, {"title": "Tight lower and upper bounds for the complexity of canonical colour refinement", "author": ["Berkholz", "Christoph", "Bonsma", "Paul S", "Grohe", "Martin"], "venue": "In Proceedings of the European Symposium on Algorithms,", "citeRegEx": "Berkholz et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Berkholz et al\\.", "year": 2013}, {"title": "Shortestpath kernels on graphs", "author": ["Borgwardt", "Karsten M", "Kriegel", "Hans-Peter"], "venue": "In Proceedings of the Fifth IEEE International Conference on Data Mining (ICDM), pp", "citeRegEx": "Borgwardt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Borgwardt et al\\.", "year": 2005}, {"title": "Spectral networks and locally connected networks on graphs", "author": ["Bruna", "Joan", "Zaremba", "Wojciech", "Szlam", "Arthur", "LeCun", "Yann"], "venue": "In International Conference on Learning Representations,", "citeRegEx": "Bruna et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Bruna et al\\.", "year": 2014}, {"title": "Libsvm: A library for support vector machines", "author": ["Chang", "Chih-Chung", "Lin", "Chih-Jen"], "venue": "ACM Trans. Intell. Syst. Technol.,", "citeRegEx": "Chang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Chang et al\\.", "year": 2011}, {"title": "Distinguishing enzyme structures from non-enzymes without alignments", "author": ["Dobson", "Paul D", "Doig", "Andrew J"], "venue": "Journal of Molecular Biology,", "citeRegEx": "Dobson et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Dobson et al\\.", "year": 2003}, {"title": "Unsupervised learning of distributions of binary vectors using two layer networks", "author": ["Freund", "Yoav", "Haussler", "David"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Freund et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Freund et al\\.", "year": 1992}, {"title": "Neocognitron: A self-organizing neural network model for a mechanism of pattern recognition unaffected by shift in position", "author": ["Fukushima", "Kunihiko"], "venue": "Biological Cybernetics,", "citeRegEx": "Fukushima and Kunihiko.,? \\Q1980\\E", "shortCiteRegEx": "Fukushima and Kunihiko.", "year": 1980}, {"title": "On graph kernels: Hardness results and efficient alternatives", "author": ["Gaertner", "Thomas", "Flach", "Peter", "Wrobel", "Stefan"], "venue": "In Proceedings of the 16th Annual Conference on Computational Learning Theory, pp", "citeRegEx": "Gaertner et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Gaertner et al\\.", "year": 2003}, {"title": "Convolution kernels on discrete structures", "author": ["Haussler", "David"], "venue": "Technical report, Department of Computer Science, University of California at Santa Cruz,", "citeRegEx": "Haussler and David.,? \\Q1999\\E", "shortCiteRegEx": "Haussler and David.", "year": 1999}, {"title": "Deep convolutional networks on graph-structured data", "author": ["Henaff", "Mikael", "Bruna", "Joan", "LeCun", "Yann"], "venue": "arXiv preprint arXiv:1506.05163,", "citeRegEx": "Henaff et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Henaff et al\\.", "year": 2015}, {"title": "Receptive fields and functional architecture of monkey striate cortex", "author": ["Hubel", "David H", "Wiesel", "Torsten N"], "venue": "Journal of Physiology (London),", "citeRegEx": "Hubel et al\\.,? \\Q1968\\E", "shortCiteRegEx": "Hubel et al\\.", "year": 1968}, {"title": "Counting belief propagation", "author": ["Kersting", "Kristian", "Ahmadi", "Babak", "Natarajan", "Sriraam"], "venue": "In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Kersting et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kersting et al\\.", "year": 2009}, {"title": "Power iterated color refinement", "author": ["Kersting", "Kristian", "Mladenov", "Martin", "Garnett", "Roman", "Grohe"], "venue": "In Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Kersting et al\\.,? \\Q1904\\E", "shortCiteRegEx": "Kersting et al\\.", "year": 1904}, {"title": "The skew spectrum of graphs", "author": ["Kondor", "Risi", "Borgwardt", "Karsten M"], "venue": "In Proceedings of the 25th International Conference on Machine Learning (ICML),", "citeRegEx": "Kondor et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kondor et al\\.", "year": 2008}, {"title": "Diffusion kernels on graphs and other discrete input spaces", "author": ["Kondor", "Risi", "Lafferty", "John"], "venue": "In Proceedings of the 19th International Conference on Machine Learning (ICML),", "citeRegEx": "Kondor et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Kondor et al\\.", "year": 2002}, {"title": "The graphlet spectrum", "author": ["Kondor", "Risi", "Shervashidze", "Nino", "Borgwardt", "Karsten M"], "venue": "In Proceedings of the 26th International Conference on Machine Learning (ICML),", "citeRegEx": "Kondor et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kondor et al\\.", "year": 2009}, {"title": "Backpropagation applied to handwritten zip code recognition", "author": ["Y. LeCun", "B. Boser", "J.S. Denker", "D. Henderson", "R.E. Howard", "W. Hubbard", "L.D. Jackel"], "venue": "Neural Comput.,", "citeRegEx": "LeCun et al\\.,? \\Q1989\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1989}, {"title": "Gradient-based learning applied to document recognition", "author": ["LeCun", "Yann", "Bottou", "L\u00e9on", "Bengio", "Yoshua", "Haffner", "Patrick"], "venue": "Proceedings of the IEEE,", "citeRegEx": "LeCun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1998}, {"title": "Community structure in large networks: Natural cluster sizes and the absence of large well-defined clusters", "author": ["Leskovec", "Jure", "Lang", "Kevin J", "Dasgupta", "Anirban", "Mahoney", "Michael W"], "venue": "Internet Mathematics,", "citeRegEx": "Leskovec et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Leskovec et al\\.", "year": 2009}, {"title": "Gated graph sequence neural networks", "author": ["Li", "Yujia", "Tarlow", "Daniel", "Brockschmidt", "Marc", "Zemel", "Richard"], "venue": "arXiv preprint arXiv:1511.05493,", "citeRegEx": "Li et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Li et al\\.", "year": 2015}, {"title": "Isomorphism of graphs of bounded valence can be tested in polynomial time", "author": ["Luks", "Eugene M"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Luks and M.,? \\Q1982\\E", "shortCiteRegEx": "Luks and M.", "year": 1982}, {"title": "Practical graph isomorphism, {II", "author": ["McKay", "Brendan D", "Piperno", "Adolfo"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "McKay et al\\.,? \\Q2014\\E", "shortCiteRegEx": "McKay et al\\.", "year": 2014}, {"title": "Network motifs: simple building blocks of complex", "author": ["Milo", "Ron", "Shen-Orr", "Shai", "Itzkovitz", "Shalev", "Kashtan", "Nadav", "Chklovskii", "Dmitri", "Alon", "Uri"], "venue": null, "citeRegEx": "Milo et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Milo et al\\.", "year": 2002}, {"title": "The complexity of mckays canonical labeling algorithm", "author": ["Miyazaki", "Takunari"], "venue": "In Groups and Computation II,", "citeRegEx": "Miyazaki and Takunari.,? \\Q1997\\E", "shortCiteRegEx": "Miyazaki and Takunari.", "year": 1997}, {"title": "The structure of scientific collaboration networks", "author": ["Newman", "Mark EJ"], "venue": "Proceedings of the National Academy of Sciences,", "citeRegEx": "Newman and EJ.,? \\Q2001\\E", "shortCiteRegEx": "Newman and EJ.", "year": 2001}, {"title": "Graph invariant kernels", "author": ["F. Orsini", "P. Frasconi", "Raedt", "L. De"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Orsini et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Orsini et al\\.", "year": 2015}, {"title": "The graph neural network model", "author": ["F. Scarselli", "M. Gori", "A.C. Tsoi", "M. Hagenbuchner", "G. Monfardini"], "venue": "IEEE Transactions on Neural Networks,", "citeRegEx": "Scarselli et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Scarselli et al\\.", "year": 2009}, {"title": "Weisfeiler-lehman graph kernels", "author": ["2009. Shervashidze", "Nino", "Schweitzer", "Pascal", "van Leeuwen", "Erik Jan", "Mehlhorn", "Kurt", "Borgwardt", "Karsten M"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "Shervashidze et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Shervashidze et al\\.", "year": 2011}, {"title": "Statistical evaluation of the predictive toxicology challenge 2000\u20132001", "author": ["Toivonen", "Hannu", "Srinivasan", "Ashwin", "King", "Ross D", "Kramer", "Stefan", "Helma", "Christoph"], "venue": null, "citeRegEx": "Toivonen et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Toivonen et al\\.", "year": 2003}, {"title": "Comparison of descriptor spaces for chemical compound retrieval and classification", "author": ["Wale", "Nikil", "Karypis", "George"], "venue": "In Proceedings of the International Conference on Data Mining (ICDM), pp", "citeRegEx": "Wale et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Wale et al\\.", "year": 2006}, {"title": "Atomnet: A deep convolutional neural network for bioactivity prediction in structure-based drug", "author": ["Wallach", "Izhar", "Dzamba", "Michael", "Heifets", "Abraham"], "venue": "discovery. CoRR,", "citeRegEx": "Wallach et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Wallach et al\\.", "year": 2015}, {"title": "A reduction of a graph to a canonical form and an algebra arising during this reduction", "author": ["Weisfeiler", "Boris", "Lehman", "AA"], "venue": "Nauchno-Technicheskaya Informatsia,", "citeRegEx": "Weisfeiler et al\\.,? \\Q1968\\E", "shortCiteRegEx": "Weisfeiler et al\\.", "year": 1968}, {"title": "Deep graph kernels", "author": ["Yanardag", "Pinar", "S.V.N. Vishwanathan"], "venue": "In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,", "citeRegEx": "Yanardag et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Yanardag et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 1, "context": "The proposed approach builds on concepts from convolutional neural networks (CNNs) (Fukushima, 1980; Atlas et al., 1988; LeCun et al., 1998; 2015) for images and extends them to arbitrary graphs.", "startOffset": 83, "endOffset": 146}, {"referenceID": 21, "context": "The proposed approach builds on concepts from convolutional neural networks (CNNs) (Fukushima, 1980; Atlas et al., 1988; LeCun et al., 1998; 2015) for images and extends them to arbitrary graphs.", "startOffset": 83, "endOffset": 146}, {"referenceID": 26, "context": "Second, for a number of applications, ranging from computational biology to social network analysis, it is important to visualize learned network motifs (Milo et al., 2002).", "startOffset": 153, "endOffset": 172}, {"referenceID": 19, "context": "Two representative classes of kernels are the skew spectrum kernel (Kondor & Borgwardt, 2008) and kernels based on graphlets (Kondor et al., 2009; Shervashidze et al., 2009).", "startOffset": 125, "endOffset": 173}, {"referenceID": 26, "context": "These subgraphs, which are often called motifs or graphlets, reflect functional network properties (Milo et al., 2002; Alon, 2007).", "startOffset": 99, "endOffset": 130}, {"referenceID": 31, "context": "An effective class of graph kernels are the Weisfeiler-Lehman (WL) kernels (Shervashidze et al., 2011).", "startOffset": 75, "endOffset": 102}, {"referenceID": 29, "context": "Deep graph kernels (Yanardag & Vishwanathan, 2015) and graph invariant kernels (Orsini et al., 2015) compare graphs based on the existence or count of small substructures such as shortest paths (Borgwardt & Kriegel, 2005), graphlets, subtrees, and other graph invariants (Haussler, 1999; Orsini et al.", "startOffset": 79, "endOffset": 100}, {"referenceID": 29, "context": ", 2015) compare graphs based on the existence or count of small substructures such as shortest paths (Borgwardt & Kriegel, 2005), graphlets, subtrees, and other graph invariants (Haussler, 1999; Orsini et al., 2015).", "startOffset": 178, "endOffset": 215}, {"referenceID": 31, "context": "Moreover, while all graph kernels have a training complexity at least quadratic in the number of graphs (Shervashidze et al., 2011), which is prohibitive for large-scale problems, PATCHY-SAN scales linearly with the number of graphs.", "startOffset": 104, "endOffset": 131}, {"referenceID": 30, "context": "Graph neural networks (GNNs) (Scarselli et al., 2009) are a recurrent neural network architecture defined on graphs.", "startOffset": 29, "endOffset": 53}, {"referenceID": 23, "context": "Gated Graph Sequence Neural Networks modify GNNs to use gated recurrent units and to output sequences (Li et al., 2015).", "startOffset": 102, "endOffset": 119}, {"referenceID": 6, "context": "Recent work extended CNNs to topologies that differ from the low-dimensional grid structure (Bruna et al., 2014; Henaff et al., 2015).", "startOffset": 92, "endOffset": 133}, {"referenceID": 13, "context": "Recent work extended CNNs to topologies that differ from the low-dimensional grid structure (Bruna et al., 2014; Henaff et al., 2015).", "startOffset": 92, "endOffset": 133}, {"referenceID": 1, "context": "CNNs were developed in the 1980s and have been applied to image, speech, text, and drug discovery problems (Atlas et al., 1988; LeCun et al., 1989; 1998; 2015; Wallach et al., 2015).", "startOffset": 107, "endOffset": 181}, {"referenceID": 20, "context": "CNNs were developed in the 1980s and have been applied to image, speech, text, and drug discovery problems (Atlas et al., 1988; LeCun et al., 1989; 1998; 2015; Wallach et al., 2015).", "startOffset": 107, "endOffset": 181}, {"referenceID": 34, "context": "CNNs were developed in the 1980s and have been applied to image, speech, text, and drug discovery problems (Atlas et al., 1988; LeCun et al., 1989; 1998; 2015; Wallach et al., 2015).", "startOffset": 107, "endOffset": 181}, {"referenceID": 15, "context": "Color refinement has attracted considerable interest in the ML community as it can be applied to speed-up inference in graphical models (Kersting et al., 2009; 2014) and as a method to compute graph kernels (Shervashidze et al.", "startOffset": 136, "endOffset": 165}, {"referenceID": 31, "context": ", 2009; 2014) and as a method to compute graph kernels (Shervashidze et al., 2011).", "startOffset": 55, "endOffset": 82}, {"referenceID": 2, "context": "Due to the constant size k of the neighborhood graphs, the algorithm runs in time polynomial in the size of the original graph and, on average, in time linear in k (Babai et al., 1980).", "startOffset": 164, "endOffset": 184}, {"referenceID": 4, "context": "For instance, for the Weisfeiler-Lehman algorithm, which has a complexity of O((n + m) log(n)) (Berkholz et al., 2013), and constants w n and k n, the complexity of PATCHY-SAN is linear in N and quasi-linear in m and n.", "startOffset": 95, "endOffset": 118}, {"referenceID": 22, "context": "torus is a periodic lattice with 10, 000 nodes; random is a random undirected graph with degree distribution P (k) \u221d 1/k and kmax = 3; power is a network representing the topology of a power grid in the US; polbooks is a co-purchasing network of books about US politics published during the 2004 presidential election; preferential is a preferential attachment network model where newly added vertices have degree 3; astro-ph is a coauthorship network between authors of preprints posted on the astrophysics arxiv (Newman, 2001); email-enron is a communication network generated from about half a million sent emails (Leskovec et al., 2009).", "startOffset": 617, "endOffset": 640}, {"referenceID": 32, "context": "PTC consists of 344 chemical compounds where classes indicate carcinogenicity for male and female rats (Toivonen et al., 2003).", "startOffset": 103, "endOffset": 126}, {"referenceID": 11, "context": "We compared PATCHY-SAN with the shortest-path kernel (SP) (Borgwardt & Kriegel, 2005), the random walk kernel (RW) (Gaertner et al., 2003), the graphlet count kernel (GK) (Shervashidze et al.", "startOffset": 115, "endOffset": 138}, {"referenceID": 31, "context": ", 2009), and the Weisfeiler-Lehman subtree kernel (WL) (Shervashidze et al., 2011).", "startOffset": 55, "endOffset": 82}], "year": 2016, "abstractText": "Numerous important problems can be framed as learning from graph data. We propose a framework for learning convolutional neural networks for arbitrary graphs. These graphs may be undirected, directed, and with both discrete and continuous node and edge attributes. Analogous to image-based convolutional networks that operate on locally connected regions of the input, we present a general approach to extracting locally connected regions from graphs. Using established benchmark data sets, we demonstrate that the learned feature representations are competitive with state of the art graph kernels and that their computation is highly efficient.", "creator": "LaTeX with hyperref package"}}}