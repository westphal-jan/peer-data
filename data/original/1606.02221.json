{"id": "1606.02221", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Jun-2016", "title": "Multi-resource defensive strategies for patrolling games with alarm systems", "abstract": "Security Games employ game theoretical tools to derive resource allocation strategies in security domains. Recent works considered the presence of alarm systems, even suffering various forms of uncertainty, and showed that disregarding alarm signals may lead to arbitrarily bad strategies. The central problem with an alarm system, unexplored in other Security Games, is finding the best strategy to respond to alarm signals for each mobile defensive resource. The literature provides results for the basic single-resource case, showing that even in that case the problem is computationally hard. In this paper, we focus on the challenging problem of designing algorithms scaling with multiple resources. First, we focus on finding the minimum number of resources assuring non-null protection to every target. Then, we deal with the computation of multi-resource strategies with different degrees of coordination among resources. For each considered problem, we provide a computational analysis and propose algorithmic methods.", "histories": [["v1", "Tue, 7 Jun 2016 17:10:16 GMT  (49kb,D)", "http://arxiv.org/abs/1606.02221v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.GT", "authors": ["nicola basilico", "giuseppe de nittis", "nicola gatti"], "accepted": false, "id": "1606.02221"}, "pdf": {"name": "1606.02221.pdf", "metadata": {"source": "CRF", "title": "Multi\u2013resource defensive strategies for patrolling games with alarm systems", "authors": ["Nicola Basilico", "Giuseppe De Nittis", "Nicola Gatti"], "emails": ["nicola.basilico@unimi.it", "nicola.gatti}@polimi.it"], "sections": [{"heading": "1 Introduction", "text": "Security Games represent one of the most successful application of non\u2013cooperative game theory in the real world [Jain et al., 2012]. The basic approach is to model a security situation with a 2\u2013player game, between a Defender and an Attacker, and to derive the best strategy of the Defender, most of the times according to the Stackelberg paradigm. A wide literature on Security Games studies issues like resource scheduling constraints [Kiekintveld et al., 2009], bounded rationality [Yang et al., 2011], Attacker\u2019s observation models [An et al., 2013], protection of infrastructures [Blum et al., 2014].\nReal security systems are equipped with sensors that are capable to trigger alarms when attacks are detected but may suffer from various forms of uncertainty. Mobile defensive resources (a.k.a. patrollers) can respond to alarm signals covering the targets potentially under attack. It is demonstrated that disregarding alarm signals may lead to strategies arbitrarily worse than those obtained when alarm signals are exploited. Nevertheless, the study of how to include alarm systems in Security Games is largely unexplored and represents\none of the most challenging open problems in the field. In particular, the central question is: given an alarm signal, how should the Defender respond to it at best? [Basilico et al., 2015a] study the scenario with only one resource available to the Defender and with sensors suffering from spatial uncertainty, i.e., an alarm signal is raised whenever an attack is performed, but the Defender is uncertain on the actual attacked location, as in border patrolling [Agmon et al., 2008]. In such situations, the best strategy is to stay in a location, wait for an alarm signal and then respond to it at best. This last task is proved APX\u2013hard. [Basilico et al., 2016] study the scenario with sensors suffering both from spatial uncertainty and false negatives when only one resource is available to the Defender, showing that it is PSPACE\u2013hard. For small missed detection rates, placing in a location and responding to an alarm signal keeps to be the best strategy for the Defender, while for large missed detection rates the best strategy is to patrol a number of targets even in absence of alarm signals and respond to an alarm signal once triggered.\nOriginal contributions. In this paper, we focus on settings with a spatial uncertain alarm system and multiple defensive resources. Here the challenge is to design algorithms able to scale with the resources. We provide some original contributions. In real\u2013world settings, due to budget constraints, it is important to minimize the number of resources assuring a minimum protection level. We study the problem of finding the minimum number of resources assuring non\u2013null protection to every target.\nThis number corresponds to the lower bound over the number of resources one should employ in practice. We show that the problem is log\u2013APX\u2013complete on general graphs, while it is in P for special graphs, such as trees and cycles, that are rather usual in real\u2013world applications. Then, we study the problem of finding the best strategy to respond to any alarm signal once a disposition of resources in the environment is given, according to different degrees of coordination among the resources. Finally, we propose an approach that includes the previous algorithms and that returns in anytime fashion the best disposition of resources. For each of our algorithms, we provide a thorough experimental evaluation showing that they can solve realistic settings.\nar X\niv :1\n60 6.\n02 22\n1v 1\n[ cs\n.A I]\n7 J\nun 2\n01 6"}, {"heading": "2 Security game model and previous results", "text": "Our security game is a generalization of [Basilico et al., 2015b], obtained allowing the Defender to control an arbitrary number of m resources instead of just a single one. We summarize its main features. A patrolling setting is a graph G \u201c pV,Eq representing an environment where areas that can be attacked are given by n target vertices, denoted as T \u010e V . A target t P T has a value \u03c0ptq P p0, 1s and requires dptq P N` time units (penetration time) to be compromised. Edges in E are unitary, while \u03c9\u02dai,j is the smallest traveling cost beweem vertices i and j. An alarm system pS, pq generates a signal s P S if target t is attacked with probability pps | tq. S, p and any generated signal s are public knowledge. We call T psq \u201c tt P T | pps | tq \u0105 0u the support of a signal s and Sptq \u201c ts P S | pps | tq \u0105 0u the support of a target t. We assume that ppH | tq \u201c pps | Hq \u201c 0 for any t P T and s P S, i.e., there are no false positives or missed detections, and that |Sptq| \u011b 1 for any t P T .\nA 2\u2013player security game takes place between an Attacker A and a Defender D. In this game, A seeks to gain value by compromising some target while D can control m defending resources by specifying a movement strategy for them. At any turn of the game, A and D play simultaneously: A observes the position of the m and decides whether to attack a target (we assume that A can instantly reach the attacked target, this can be relaxed as shown in [Basilico et al., 2009].) or to wait. On the opposite side, D has no information about A but, if an attack is present, it observes the alarm signal and decides where to allocate the m resources. Each resource can be allocated either to the same vertex or to an adjacent one. If A attacks target t and a resource is allocated on t in any of the next dptq turns, then D and A receive payoffs of 1 and 0, respectively. Otherwise, they receive 1\u00b4\u03c0ptq and \u03c0ptq. A route r for a single resource is a sequence of targets to which the resource is moved where lr is the route length, rpiq is the i\u2013th assigned target and Aprpiqq \u201c\n\u0159i\u00b41 h\u201c1 \u03c9 \u02da rphq,rph`1q is the time\nbetween visits to rp1q and rpiq. We say that rs,j is a covering route for resource j under signal s if, @i P t1, . . . , lru, we have that rpiq P T psq and Aprpiqq \u010f dprpiqq. The interpretation is that when s is generated, having a resource following r will guarantee protection over T psq. A joint covering route is an m\u2013tuple rs \u201c xrs,1, rs,2, . . . , rs,my. To simplify the notation, we will omit signal s when clear from the context.\nThe resolution approach for m \u201c 1 is given in [Basilico et al., 2015b]. With no false positives and missed detections, the best strategy for the patroller is to stay on a vertex, wait for a signal, and then respond to it at best. The same holds with multiple resources (the extension of the proof is straightforward) and allows us to decompose the problem into two phases: determining the best signal response strategy from every vertex (Signal Response Game), and then determining the best vertex in which the patroller can place (Patrolling Game). Once a signal s is received, D has to respond by randomizing over the possible covering routes under signal s and starting from v. The signal response strategy is defined as \u03c3Dv \u201c p\u03c3Dv,s1 , \u03c3 D v,s2 , . . .q, that is a response strategy for every possible signal. Despite the game being constant\u2013 sum, the problem is shown to be APX\u2013hard, its difficulty\nmainly being in generating the covering routes under a signal s and starting from v. An approximation algorithm for such difficult subproblem is given in [Basilico et al., 2015a]. With multiple resources, several questions, related to finding the best number of resources to employ, their placement, and their signal response strategies, arise. In the next sections, we provide some answers to them."}, {"heading": "3 Minimizing the number of resources", "text": "Ideally, the determination of the best number of defensive resources must take into account both the level of protection that can be achieved and the costs of additional resources. The minimum protection level a Defender should guarantee is that for each target t P T there is at least a resource in a vertex v with \u03c9\u02dav,t \u010f dptq, such that it can cover t by dptq, thus stopping a potential ongoing attack. The least number of resources satisfying this requirement represents the lower bound necessary for the protection of any environment, while the upper bound is the number of resources such that, for any signal s, there is a response strategy to s covering all the targets in T psq thus assuring the Defender a utility of 1. Here we study the problem of computing the minimum number of resources guaranteeing each target a non\u2013null protection. We start by defining the concept of covering placement.\nDefinition 1 (Covering Placement) A covering placement is defined as a set of vertices P \u201c tp1, . . . , pmu where pi P V , pi \u2030 pj if i \u2030 j and for every target t P T there exists a pi P P such that \u03c9\u02dapi,t \u010f dptq."}, {"heading": "3.1 Arbitrary instances", "text": "With arbitrary graphs, we state the following results.\nTheorem 1 Computing the minimum covering placement is log\u2013APX\u2013hard even in the basic case all the vertices are targets with penetration times equal to 1.\nProof. Log\u2013APX\u2013hardness of our problem is direct from DOMINATING\u2013SET [Escoffier and Paschos, 2006] that is known to be log\u2013APX\u2013complete. This latter problem is defined as follows: given a graph G \u201c pV ,Eq, minimize |V 1| with V\n1 \u010e V with the property that for all v P V zV 1 there is at least a v1 P V 1 such that pv, v1q P E. Every instance of DOMINATING\u2013SET with graph G is equivalent to the problem of minimizing the covering placement over graph G in which all the vertices V are targets and have d \u201c 1. l\nTheorem 2 Computing the minimum covering placement is in log\u2013APX .\nProof. The membership to log\u2013APX follows from the fact that every instance of our problem can be formulated in direct way as a SET\u2013COVER instance and that SET\u2013COVER in is in log\u2013APX [Chvatal, 1979]\u2014our problem is more general than DOMINATING\u2013SET, this justifies the need to consider SET\u2013COVER. More precisely, given an instance of our problem, for each vertex v P V we can find in polynomial time the set of targets t such that \u03c9\u02dav,t \u010f dptq. Thus, we map\nset T to the universe set of SET\u2013COVER and each vertex v to a set in SET\u2013COVER. The objective functions of the two problems are the same. Therefore, every \u03b1 approximation of SET\u2013COVER is also an \u03b1 approximation of our problem. l\nThe proof of Theorem 2 is based on the fact that every instance of our problem can be formulated in direct way as a SET\u2013COVER instance. As a consequence we can find a solution to our problem by formulating it as a SET\u2013COVER and then by using algorithms for this latter problem: integer linear programming (ILP) for finding the exact solution and greedy algorithms to find an approximate solution [Chvatal, 1979]. In our approach, we also apply a local search [Musliu, 2006] to the solution generated by the greedy algorithm to improve its quality."}, {"heading": "3.2 Special instances: tree and cycle graphs", "text": "Interestingly, in particular instances that are rather usual in real\u2013world applications the problem is optimally solvable in polynomial time. Let us start from the following lemma.\nAlgorithm 1 TM(v) 1: if v is a leaf then 2: return p8, dpvq \u00b4 1q 3: else 4: for all v1 P Succpvq do 5: ` Covpv1q, UnCovpv1q \u02d8 \u00d0 TM ` v1 \u02d8 6: if min v1 tUnCovpv1q, dpvqu \u00b4min v1 Covpv1q \u011b 0 then 7: return pmin v1 Covpv1q ` 1,8q 8: else if min v1 tUnCovpv1q, dpvqu \u00b4 1 \u011b 0 then 9: return p8,min v1 tUnCovpv1q, dpvqu \u00b4 1q 10: else 11: resv \u00d0 1 12: return p1,8q\nLemma 3 A minimum covering placement in a tree rooted in v\u0302 can be computed in polynomial time with Algorithm 1 by calling TMpv\u0302q.\nAlgorithm 1 works recursively taking as input a vertex v P V . To ease its description, let us assume that T \u201c V . The case including non\u2013target vertices only amounts to minor modifications. Binary variables resv are initially set to 0 and their assertion corresponds to place a resource on v P V . With Succpvq \u010e V we denote all the immediate successors of v on the path leaving the root. The idea is to recursively allocate resources by processing the graph in a bottom\u2013up fashion, from its leaves to the root. Let us consider a function call for a generic vertex v. By recursively invoking TMpv1q for each v1 P Succpvq we get, for each successor, a coverage profile defined with a pair of values ` Covpv1q, UnCovpv1q \u02d8\n. They encode the following conditions under the currently built resource placement. If variables res\u03bd of the subtree rooted in v1 constitute a coverage placement for whole the subtree, the coverage profile is such that Covpv1q \u201c k \u0103 8 where k is the distance between v and the closest resource on such subtree and UnCovpv1q \u201c 8. Otherwise, the coverage profile is such that Covpv1q \u201c 8 and UnCovpv1q \u201c k \u0103 8 where k is the distance from v by which we need to place a resource to have a coverage placement for the subtree rooted in v1.\nWe start from an empty placement and derive coverage profiles recursively from the base case in which v is a leaf (Line 1). Since deadlines are non\u2013null and costs are unitary, a resource on a leaf is never necessary: we can always cover it from any ancestor whose distance from v is \u010f dpvq \u00b4 1. Hence the coverage profile for the base case is p8, dpvq \u00b4 1q (Line 2).\nLet us consider the recursive step in which v is a non\u2013leaf vertex. From Line 6 we have all the coverage profiles of each one of the immediate successors of v and we must return the coverage profile of v and decide if a resource must be placed on it. We have three cases.\n\u2022 Case 1 (Lines 6\u20137): if the condition of Line 6 is satisfied then the subtree rooted at v is covered by the resources we placed in such subtree. Hence we do not need any resource in v. Moreover, the father of v will be at distance min v1 Covpv1q ` 1 from the closest of such resources.\n\u2022 Case 2 (Lines 8\u20139): if the condition of Line 8 is satisfied then the subtree rooted at v is not covered by the resources we placed in such subtree. We can achieve coverage by placing a resource in v or in any ancestor whose distance from v should not exceed min v1 tUnCovpv1q, dpvqu\u00b41. Since we are trying to min-\nimize the number of resources, there is always interest in postponing a resource allocation in our bottom\u2013up processing of the tree. Therefore, we do not allocate a resource in v and we return the strategy profile naturally resulting from the above considerations (Line 9).\n\u2022 Case 3 (Lines 11\u201312): if none of the previous two cases is verified, then no resource in any ancestor of v can complete the coverage for the subtree rooted at v. We are forced to place a resource in v which makes the associated coverage profile equal to p1,8q (Line 12).\nAlgorithm 1 can be adopted also to solve cycle graphs by extracting the n linear subgraphs spanning all the n targets, solving each of them with Algorithm 1, and then selecting the solution with the least number of resources. We summarize the above positive results in the following theorem.\nTheorem 4 Given k, deciding if there exists a covering placement with size m \u010f k is P for trees and cycle graphs."}, {"heading": "4 Signal response", "text": "In this section, we deal with the problem of how to compute a signal response strategy for the m resources once we are given a joint placement P \u010e V m, which satisfies the coverage requirement (see Definition 1), and each of the m necessary resources is placed at pi P P . To ease the presentation, we assume that only one signal s is present in S and that T psq \u201c T , omitting s in our formulas. The general case with multiple signals can be obtained by simply refining notation. The extra computational cost due to signals is linear in their number.\nIn general, any resource i will always move along a covering route. Let us denote with Ri the set of covering routes for resource i starting from pi (we will omit the dependency on\npi since P is always fixed in the scope of a signal response game). In order to compute the covering routes, we resort the exact and approximate methods proposed in [Basilico et al., 2015a]. The presence of multiple resources introduces the coordination dimension [Basilico et al., 2010]. We consider three coordination schemes and define three Signal Response Oracles (SRO). Each oracle works on a different game model and returns the signal response strategy from a given joint placement P under the corresponding scheme. Strategies for D and A are denoted as \u03c3D and \u03c3A, respectively. If not defined differently, \u03c3A : T \u00d1 r0, 1s gives the probability \u03c3Aptq of attacking a target t."}, {"heading": "4.1 Full coordination SRO (FC\u2013SRO)", "text": "In the full coordination scheme, we assume that D acts as central planner and executor of the signal response strategy. In other words, D has full control over the resources at any time of the game. It computes a joint strategy for them and jointly moves them on the graph according to it. This scheme can describe scenarios where resources are connected to a central control unit from where orders are issued (e.g., police patrols equipped with radio transceivers). The security game originating from this scheme is played by D and A where \u03c3D : R \u00d1 r0, 1s, R \u201c\n\u015am i\u201c1Ri and \u03c3 Dprq is the probability of playing the joint covering route r. We define Ipr, tq as a function returning 1 if and only if target t is protected by r (we allow r to be both a joint and a single\u2013 resource covering route) and 0 otherwise. For any r P R and t P T , pr, tq is a game outcome where D and A receive UDpr, tq \u201c 1\u00b4p1\u00b4Ipr, tqq\u03c0ptq and UApr, tq \u201c 1\u00b4UDpr, tq, respectively. The game is constant\u2013sum and can be solved computing the maxmin strategy with a linear program. However, each Ri can have exponential size and its computation entails the resolution of an NP\u2013hard problem. Even adopting the approximated method and working with incomplete sets of covering routes would require us to enumerate over all the possible combinations to construct the space of joint covering routes, which are exponentially many in the number of resources. However, we observe that in our case there always exists a minmax equilibrium where D plays on at most |T | routes as shown in from [Shapley and Snow, 1950].\nTheorem 5 Given a game with K players in which all the players k P Kzt1u have m actions and player 1 has n actions, there is a minmax strategy of players Kzt1u in which the support of each player has a size not larger than n.\nFor this reason, we devise a row\u2013generation approach that iteratively generates rows in the game matrix (joint covering routes). The row generation routine first generates, for each resource i, a set of covering routes Ri. Then, it considers a joint covering route r1 (initial covering route). Set R \u201c tr1u and solve the corresponding constant\u2013sum game using R as the action space forD. Solve the following ILP where xir is a binary variable taking value of 1 when route r P Ri is selected for resource i, yt is a binary variable taking value of 1 when target t is protected by the set of selected covering routes, and \u03c3A is A\u2019s minmax strategy in the previously solved game.\nargmax 1\u00b4 \u00ff tPT \u03c3 Aptq\u03c0ptqp1\u00b4 ytq s.t.\nm \u00ff\ni\u201c1\n\u00ff\nrPRi\nIpr, tqxir \u00b4 yt \u011b 0 @t P T\n\u00ff\nrPRi\nxir \u201c 1 @i P t1 . . .mu\nFrom the solution of this problem we obtain a joint covering route r\u0302 where resource i plays route i if xri \u201c 1. Clearly, r\u0302 is a best response forD in the incumbent game equilibrium. If r\u0302 R R, then it is included and the game is solved again, otherwise the exact solution of the minmax problem is found. In the above formulation, only the integrality constraints on yt can be relaxed still obtaining a feasible optimal solution.\nTheorem 6 Deciding if there is at least a joint covering route where a subset of targets T 1 can be covered with at most k single\u2013resource routes is NP\u2013hard.\nProof. A simple reduction from SET\u2013COVER can be given by map the universe on T 1, set m \u201c k, and define R1 \u201c R2 . . . \u201c Rm a set of one route for each set Sj in SET\u2013 COVER where the targets covered by the route correspond to the elements of Sj . It is easy to see that SET\u2013COVER admits a cover with at most k sets if we can cover T 1 with no more that k single\u2013resource routes (one for each resource). l\nIn practice, we empirically assessed that the following heuristic method gives acceptable results. We solve the linear relaxation (on xir variables) an then sample a route r for each resource r with probability xir. We iterate this double\u2013 LP scheme until convergence, namely when the best response computed by the above program is pure and already in D\u2019s support at the equilibrium."}, {"heading": "4.2 Partial coordination SRO (PC\u2013SRO)", "text": "Partial coordination models those situations where D can act as central planner but cannot communicate with each resource to prescribe a joint action. Another way to see this is to consider each resource as a separate player that has interest in cooperating with others but that cannot correlate with them. Real scenarios falling in this scope can be characterized by resources for which a communication with the control unit is not available (e.g., patrolling units operating in stealth mode).\nTeam games [von Stengel and Koller, 1997] are a suitable model to describe our security game under this coordination scheme. We define a m ` 1 game where resource players D1, . . . ,Dm compete together againstA. Each resource strategy is defined as \u03c3Di : Ri \u00d1 r0, 1s, where \u03c3Di priq denotes the probability of having resource i following covering route ri P Ri. A game outcome is again defined with pr, tq (r is a joint covering route) where each Di receives the same utility UD as previously defined. The proper solution concept of this game is the team maxmin strategy whose computation can be described with the following non\u2013linear program:\nmin \u03c3D1 ...\u03c3 D m v s.t.\nv \u00b4 \u03c0ptq m \u017a\ni\u201c1\n` 1\u00b4 \u00ff\nrPRi\nIpr, tq\u03c3Di prq \u02d8 \u011b 0 @t P T\n\u00ff\nrPRi\n\u03c3 D i prq \u201c 1 @i P t1 . . .mu\n\u03c3 D i prq \u011b 0 @i P t1 . . .mu, r P Ri\nNotice that, the minmax value with three or more players can be irrational and not exactly computable even when the payoffs can assume only three different integer values. Approximating it with additive gap is, in general, hard. More precisely, approximating the minmax value of 2 players against 1 player within an additive error of 13z2 where z is the number of actions of each player is NP\u2013hard even with binary payoffs [Borgs et al., 2010]. [Hansen et al., 2008] provides a quasi\u2013polynomial algorithm with complexity Opzl logpzq 2 q approximating with additive error the minmax value with l players. It requires, for each player, to enumerate all the possible supports composed of logpnq actions. However, such methods become impractical for the problem we need to solve even for toy instances and non\u2013negligible (e.g., with 10 actions, 2 resources, and \u201c 0.5, the number of needed iterations is of the order of 1018).\nThus, to cope with the resolution of this problem we propose the following iterative method. Consider a starting strategy profile \u03c3\u0302D1 , . . . , \u03c3\u0302 D m with the corresponding game value \u03bd\u0302. Define \u03bdi as the value returned by the linear program obtained from the above formulation by setting \u03c3Dj \u201c \u03c3\u0302Dj for any j \u2030 i. We then compute i1 \u201c argmaxi \u03bdi solving m linear programs, set \u03c3\u0302Di1 \u201c \u03c3Di1 and repeat until convergence. Notice that, at each iteration, the value of the game increases (non\u2013 strictly) monotonically. Finally, once convergence achieved, we have a random restart generating a new strategy profile for D. Let us notice that, in the case the number of routes per resource is large, a row\u2013generation approach similar to that described in the previous section can be adopted."}, {"heading": "4.3 No coordination SRO (NC\u2013SRO)", "text": "When no coordination is allowed between resources we are ruling out not only strategy correlation but also joint planning. In this scenario resources are unaware of each other and act as single players against A. This case is modeled with m independent single resource signal response games (as defined in [Basilico et al., 2015b]) where the game associated with resource i has pi as starting vertex and is played on the restricted set of targets Ti \u201c tt P T | \u03c9pi,t \u010f dptqu. For each game i, the maxmin strategy is computed taking Ri as the action space of Di. However, although the defensive resources are completely non\u2013coordinated, A can observe the strategy of each resource and play at best. Thus, given the m resource allocation strategies obtained in this way, we can compute the game value as 1 \u00b4 maxtPT \u015bm i\u201c1 `\n1 \u00b4 \u0159\nriPRi \u03c3 D i priqIpr, tq\n\u02d8\n\u03c0ptq."}, {"heading": "5 Overall resolution approach", "text": "The contributions we presented are organized in the resolution approach sketched in Figure 1. We start by tackling the problem of finding the minimum\u2013size resource placement by solving the associated SET\u2013COVER formulation (or our polynomial algorithm with trees and cycles). If the problem cannot be solved exactly in a short time, we adopt the greedy approximation algorithm of [Chvatal, 1979] and then apply a simple local search to improve the greedy solution. Once this step is terminated, we have fixed a number of resourcesm and we address the problem of finding the best allocation strategy for them. As previously stated, in absence of false negatives and false positives the best allocation strategy when no signal is raised is to statically place the m resources in the best covering placement. Such placement is defined as the one from which the signal response game yields the maximum expected utility. To deal with this, we resort again to a simple variation of the local search procedure [Musliu, 2006] to enumerate covering placements of exactly m resources. For each considered covering placement, we compute sets Ri for each resource i as mentioned in the previous section and then we run the signal response oracles we introduced."}, {"heading": "6 Experimental evaluations", "text": "To evaluate our algorithms we implemented a random instance generator that leverages some domain knowledge we gathered by discussing with representatives of the Italian State Police. From such process, we were able to develop a tool for randomly generating patrolling instances that could represent realistic urban environments, such as streets, squares or districts, capturing scenarios with police patrolling units placed in police stations. In the graphs, all the vertices are targets, |T | P t20, 40, 60, 80, 100, 120u, edges are unitary, the average indegree of each vertex is 3, and penetration times have been set according to the size of the instances as follows: for |T | P t20, 40u, dptq \u201c 3, for |T | P t60, 80u, dptq \u201c 4 and finally for |T | P t100, 120u, dptq \u201c 5. There is one single signal covering all the targets, corresponding to the worst case in computational terms. Since the algorithms are anytime, the whole resolution process depicted in Figure 1 is given a timeout of 60 minutes, thus implicitly posing a limit on the maximum size of instances that can be solved. All the numerical results we report are averaged on 50 instances for\neach |T |. For the instances employed here, we used the exact method of [Basilico et al., 2015a] to generate the covering routes, requiring a compute time comparable to the approximation algorithm. We run experiments in MATLAB on a UNIX computer with 2.3GHz CPU and 128GB RAM.\nResources and dispositions We initially evaluate the performance of the algorithms to find the best covering placement. As we discussed in Section 3.2, we tackle this problem by solving an associated SET\u2013COVER problem for which we have an exact method based on an ILP and an approximation one combining a greedy heuristic with a local search procedure. The ILP\u2013based method scales up to instances with 500 vertices when evaluated in standalone runs and up to 120 vertices in the scope of the whole resolution process (in this last case a portion of time is necessarily spent for the other subtasks listed in Figure 1). The approximation algorithm achieves an average error \u0103 5% up to 500 targets, suggesting that it can provide good suboptimal results even for settings with more than 500 targets. In the following analysis, we use the ILP\u2013based method.\nFirst, we focus on the characteristics exhibited by our experimental settings in terms of number of resources needed for the covering placement and the degree of overlap over the targets covered by the resources, see Figure 2.\nWe observe that the average number of resources is linear in the number of targets (see Figure 2(a)), which is reasonable in real\u2013world scenarios.\nTo quantify the overlap degree induced by a given covering placement P \u201c tp1, p2, . . . , pmu we define two complementary indicators. We recall that Ti is the subset of targets that can be covered (reached by their deadlines) from vertex pi (see Section 4.3). Then the following quantity counts the number of extra coverings induced by P : \u03b7 \u201c \u0159m i\u201c1 |T ppiq| \u00b4 |T |. Notice that 0 \u010f \u03b7 \u010f p|T | \u00b4mqpm\u00b4 1q getting its maximum value when each resource covers a different subset of |T | \u00b4m` 1 targets. We denote with \u03c4 \u201c \u03b7|T | the average overlap per target and \u03c4\u0302 \u201c \u03b7p|T |\u00b4mqpm\u00b41q the normalized overlap. Figure 2(b) shows how these two indicators vary with the number of targets. The index \u03c4 grows linearly in the number of targets due to the linear growth of the number of resources while \u03c4\u0302 has a slower growth since for any resource i the number of covered targets |T ppiq| is usually not as big as |T |.\nNow we focus on the covering placement enumeration phase and we evaluate the number of covering placements that our algorithm is able to consider within a 60 minutes deadline. Referring again to Figure 1, notice that each additionally considered placement requires to compute the covering routes sets and to run one of the three SROs. This time is dominated by the covering route computation phase, being the time required by each oracle never exceeding 1 minute. The number of generated covering placements is reported in Figure 2(a). The curve grows reaching its maximum for |T | \u201c 60 and then decreases. Indeed, when the size of the problem is small, the algorithm terminates before the deadline, returning few placements. On the other side, when the size of the problem is large, due to the time limit and the huge amount of time required by the computation of the covering\nroutes, the time to compute new placements lowers significantly and thus the curve decreases. We remark that we are able to solve large instances up to 120 targets.\nSROs quality and performance Here we compare the performance of the three SROs, both in terms of utility and compute time. We exploit the solution returned by the NC\u2013SRO to initialize the PC\u2013SRO and the FC\u2013SRO (in this last case as input for the row\u2013generation algorithm). We evaluate the PC\u2013 SRO both with 0 and 10 random restarts observing that the improvement is not significant (\u0103 1%) and confirming that choosing the solution of the NC\u2013SRO as the starting point is appropriate. For the FC\u2013SRO, we evaluate both the exact and the approximation row\u2013generation algorithm, finding that the average difference between the two objective functions is negligible up to 120 targets (\u0103 1%), suggesting that the linear relaxation works very well in practice. In the results we report below we use 0 random restarts for PC\u2013SRO and the exact row\u2013generation algorithm for FC\u2013SRO (returning thus the optimal strategy). Figure 3(a) shows that enabling coordination among the resources gives a significant burst in the growth of the utility w.r.t. the number of targets, especially after 100 targets. As expected, FC\u2013SRO guarantees the highest utility. Interestingly, the performance of PC\u2013SRO is very close to that one of FC\u2013SRO, suggesting that in our settings the price of partial coordination is low. Figure 3(b) shows the time ratio among the three SROs. The absolute times are all very low (usually on average \u0103 20 seconds even for 120 targets). We observe that both FC\u2013SRO and PC\u2013SRO present a linear growth in time w.r.t. NC\u2013SRO but FC\u2013SRO requires less time. This suggests that the row\u2013generation of FC\u2013SRO works very well, generating a small set of joint routes. Hence, FC\u2013SRO is the best oracle in terms of tradeoff between utility and compute time, when full coordination is possible.\nFinally, we evaluate the performance of the SROs as the number of resources varies. We conduct experiments on graphs with |T | \u201c 80 (instances with more targets require excessive computational costs) in which the best |P | = 4. Then, we consider the resources as guard posts and we assign up to 5 mobile patrollers to each guard post. The FC\u2013SRO needs more time w.r.t. PC\u2013SRO, as it can be seen in Figure 4(b), but this difference is very small. Observing Figure 4(a), we note that also in this case enabling coordination gives more utility. Thus, we conclude that the FC\u2013SRO is the best performing method, providing the highest utility and requiring only slightly more time than the PC\u2013SRO. On the other side,\nthe PC\u2013SRO is a viable good solution since, even without coordination, it still provides good utility results.\nUtility trend in time Now we focus on the evolution of the utility in time, after different placements have been enumerated and evaluated. Figure 5 shows two instances with |T | \u201c 60 where we compare the performances of the three oracles with one resource per guard post. While NC\u2013SRO is quite constant even though several placements are evaluated, FC\u2013SRO and PC\u2013SRO utilities increase, with the former always preceding the latter due to its lower computational time."}, {"heading": "7 Conclusions and future research", "text": "In this work, we considered a security game with the presence of a spatially imperfect alarm system and we addressed the novel generalization towards settings in which the Defender can control multiple mobile resources. We proposed a resolution approach for dealing with the new algorithmic problems that such generalization introduces. First, we addressed the problem of computing the minimum number of\nresources required in a given setting and then we tackled the determination of the best signal response strategy under different resource coordination schemes.\nFuture direction of research will involve adaptations of our algorithms to cases in which the number of resources available to D is greater than the ones required for the minimum covering placement. In addition, we plan to work on the model by allowing the presence of false positives and missed detection in the alarm systems as well as the presence of multiple resource from the attacker side. These extensions are naturally driven by real\u2013world requirements to which security games must comply."}], "references": [{"title": "In 2008 IEEE International Conference on Robotics and Automation", "author": ["Noa Agmon", "Sarit Kraus", "Gal A. Kaminka. Multi-robot perimeter patrol in adversarial settings"], "venue": "ICRA, pages 2339\u20132345,", "citeRegEx": "Agmon et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "In AAMAS", "author": ["Bo An", "Matthew Brown", "Yevgeniy Vorobeychik", "Milind Tambe. Security games with surveillance cost", "optimal timing of attack execution"], "venue": "pages 223\u2013230,", "citeRegEx": "An et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "2009", "author": ["N. Basilico", "N. Gatti", "Thomas Rossi. Capturing augmented sensing capabilities", "intrusion delay in patrolling-intrusion games. In Computational Intelligence", "Games"], "venue": "CIG 2009. IEEE Symposium on, pages 186\u2013193, Sept", "citeRegEx": "Basilico et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Asynchronous multi-robot patrolling against intrusion in arbitrary topologies", "author": ["N. Basilico", "N. Gatti", "F. Villa"], "venue": "AAAI, pages 1224\u20131229", "citeRegEx": "Basilico et al.. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Adversarial patrolling with spatially uncertain alarm signals", "author": ["Nicola Basilico", "Giuseppe De Nittis", "Nicola Gatti"], "venue": "arXiv preprint arXiv:1506.02850,", "citeRegEx": "Basilico et al.. 2015a", "shortCiteRegEx": null, "year": 2015}, {"title": "pages 192\u2013207", "author": ["Nicola Basilico", "Giuseppe De Nittis", "Nicola Gatti. A security game model for environment protection in the presence of an alarm system. In Decision", "Game Theory for Security"], "venue": "Springer,", "citeRegEx": "Basilico et al.. 2015b", "shortCiteRegEx": null, "year": 2015}, {"title": "Combining patrolling strategies together with responses to alarm signals in security games", "author": ["N. Basilico", "G. De Nittis", "N. Gatti"], "venue": "AAAI", "citeRegEx": "Basilico et al.. 2016", "shortCiteRegEx": null, "year": 2016}, {"title": "In AAAI", "author": ["Avrim Blum", "Nika Haghtalab", "Ariel D. Procaccia. Lazy defenders are almost optimal against diligent attackers"], "venue": "pages 573\u2013579,", "citeRegEx": "Blum et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "The myth of the folk theorem", "author": ["C. Borgs", "J.T. Chayes", "N. Immorlica", "A.T. Kalai", "V.S. Mirrokni", "C.H. Papadimitriou"], "venue": "Games and Economic Behavior, 70(1):34\u201343", "citeRegEx": "Borgs et al.. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Mathematics of operations research", "author": ["Vasek Chvatal. A greedy heuristic for the set-covering problem"], "venue": "4(3):233\u2013235,", "citeRegEx": "Chvatal. 1979", "shortCiteRegEx": null, "year": 1979}, {"title": "Theoretical computer science", "author": ["Bruno Escoffier", "Vangelis Th Paschos. Completeness in approximation classes beyond apx"], "venue": "359(1):369\u2013 377,", "citeRegEx": "Escoffier and Paschos. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Approximability and parameterized complexity of minmax values", "author": ["K.A. Hansen", "T.D. Hansen", "P.B. Miltersen", "T.B. S\u00f8rensen"], "venue": "WINE, pages 684\u2013695", "citeRegEx": "Hansen et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "An overview of recent application trends at the AAMAS conference: Security", "author": ["Manish Jain", "Bo An", "Milind Tambe"], "venue": "sustainability, and safety. AI Magazine, 33(3):14\u201328,", "citeRegEx": "Jain et al.. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Computing optimal randomized resource allocations for massive security games", "author": ["Kiekintveld et al", "2009] C. Kiekintveld", "M. Jain", "J. Tsai", "J. Pita", "F. Ord\u00f3\u00f1ez", "M. Tambe"], "venue": "In International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS),", "citeRegEx": "al. et al\\.,? \\Q2009\\E", "shortCiteRegEx": "al. et al\\.", "year": 2009}, {"title": "Local search algorithm for unicost set covering problem", "author": ["Nysret Musliu"], "venue": "Springer,", "citeRegEx": "Musliu. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Basic solutions of discrete games", "author": ["L.S. Shapley", "R.N. Snow"], "venue": "Annals of Mathematics Studies, 24:27\u201335", "citeRegEx": "Shapley and Snow. 1950", "shortCiteRegEx": null, "year": 1950}, {"title": "Games and Economic Behavior", "author": ["Bernhard von Stengel", "Daphne Koller. Team-maxmin equilibria"], "venue": "21(1):309\u2013321,", "citeRegEx": "von Stengel and Koller. 1997", "shortCiteRegEx": null, "year": 1997}, {"title": "In AAAI", "author": ["Rong Yang", "Christopher Kiekintveld", "Fernando Ordonez", "Milind Tambe", "Richard John. Improving resource allocation strategy against human adversaries in security games"], "venue": "pages 458\u2013464,", "citeRegEx": "Yang et al.. 2011", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 12, "context": "Security Games represent one of the most successful application of non\u2013cooperative game theory in the real world [Jain et al., 2012].", "startOffset": 113, "endOffset": 132}, {"referenceID": 17, "context": ", 2009], bounded rationality [Yang et al., 2011], Attacker\u2019s observation models [An et al.", "startOffset": 29, "endOffset": 48}, {"referenceID": 1, "context": ", 2011], Attacker\u2019s observation models [An et al., 2013], protection of infrastructures [Blum et al.", "startOffset": 39, "endOffset": 56}, {"referenceID": 7, "context": ", 2013], protection of infrastructures [Blum et al., 2014].", "startOffset": 39, "endOffset": 58}, {"referenceID": 4, "context": "In particular, the central question is: given an alarm signal, how should the Defender respond to it at best? [Basilico et al., 2015a] study the scenario with only one resource available to the Defender and with sensors suffering from spatial uncertainty, i.", "startOffset": 110, "endOffset": 134}, {"referenceID": 0, "context": ", an alarm signal is raised whenever an attack is performed, but the Defender is uncertain on the actual attacked location, as in border patrolling [Agmon et al., 2008].", "startOffset": 148, "endOffset": 168}, {"referenceID": 6, "context": "[Basilico et al., 2016] study the scenario with sensors suffering both from spatial uncertainty and false negatives when only one resource is available to the Defender, showing that it is PSPACE\u2013hard.", "startOffset": 0, "endOffset": 23}, {"referenceID": 5, "context": "Our security game is a generalization of [Basilico et al., 2015b], obtained allowing the Defender to control an arbitrary number of m resources instead of just a single one.", "startOffset": 41, "endOffset": 65}, {"referenceID": 2, "context": "At any turn of the game, A and D play simultaneously: A observes the position of the m and decides whether to attack a target (we assume that A can instantly reach the attacked target, this can be relaxed as shown in [Basilico et al., 2009].", "startOffset": 217, "endOffset": 240}, {"referenceID": 5, "context": "The resolution approach for m \u201c 1 is given in [Basilico et al., 2015b].", "startOffset": 46, "endOffset": 70}, {"referenceID": 4, "context": "An approximation algorithm for such difficult subproblem is given in [Basilico et al., 2015a].", "startOffset": 69, "endOffset": 93}, {"referenceID": 10, "context": "Log\u2013APX\u2013hardness of our problem is direct from DOMINATING\u2013SET [Escoffier and Paschos, 2006] that is known to be log\u2013APX\u2013complete.", "startOffset": 62, "endOffset": 91}, {"referenceID": 9, "context": "The membership to log\u2013APX follows from the fact that every instance of our problem can be formulated in direct way as a SET\u2013COVER instance and that SET\u2013COVER in is in log\u2013APX [Chvatal, 1979]\u2014our problem is more general than DOMINATING\u2013SET, this justifies the need to consider SET\u2013COVER.", "startOffset": 175, "endOffset": 190}, {"referenceID": 9, "context": "As a consequence we can find a solution to our problem by formulating it as a SET\u2013COVER and then by using algorithms for this latter problem: integer linear programming (ILP) for finding the exact solution and greedy algorithms to find an approximate solution [Chvatal, 1979].", "startOffset": 260, "endOffset": 275}, {"referenceID": 14, "context": "In our approach, we also apply a local search [Musliu, 2006] to the solution generated by the greedy algorithm to improve its quality.", "startOffset": 46, "endOffset": 60}, {"referenceID": 4, "context": "In order to compute the covering routes, we resort the exact and approximate methods proposed in [Basilico et al., 2015a].", "startOffset": 97, "endOffset": 121}, {"referenceID": 3, "context": "The presence of multiple resources introduces the coordination dimension [Basilico et al., 2010].", "startOffset": 73, "endOffset": 96}, {"referenceID": 15, "context": "However, we observe that in our case there always exists a minmax equilibrium where D plays on at most |T | routes as shown in from [Shapley and Snow, 1950].", "startOffset": 132, "endOffset": 156}, {"referenceID": 16, "context": "Team games [von Stengel and Koller, 1997] are a suitable model to describe our security game under this coordination scheme.", "startOffset": 11, "endOffset": 41}, {"referenceID": 8, "context": "More precisely, approximating the minmax value of 2 players against 1 player within an additive error of 1 3z2 where z is the number of actions of each player is NP\u2013hard even with binary payoffs [Borgs et al., 2010].", "startOffset": 195, "endOffset": 215}, {"referenceID": 11, "context": "[Hansen et al., 2008] provides a quasi\u2013polynomial algorithm with complex-", "startOffset": 0, "endOffset": 21}, {"referenceID": 5, "context": "This case is modeled with m independent single resource signal response games (as defined in [Basilico et al., 2015b]) where the game associated with resource i has pi as starting vertex and is played on the restricted set of targets Ti \u201c tt P T | \u03c9pi,t \u010f dptqu.", "startOffset": 93, "endOffset": 117}, {"referenceID": 9, "context": "If the problem cannot be solved exactly in a short time, we adopt the greedy approximation algorithm of [Chvatal, 1979] and then apply a simple local search to improve the greedy solution.", "startOffset": 104, "endOffset": 119}, {"referenceID": 14, "context": "To deal with this, we resort again to a simple variation of the local search procedure [Musliu, 2006] to enumerate covering placements of exactly m resources.", "startOffset": 87, "endOffset": 101}, {"referenceID": 4, "context": "For the instances employed here, we used the exact method of [Basilico et al., 2015a] to generate the covering routes, requiring a compute time comparable to the approximation algorithm.", "startOffset": 61, "endOffset": 85}], "year": 2016, "abstractText": "Security Games employ game theoretical tools to derive resource allocation strategies in security domains. Recent works considered the presence of alarm systems, even suffering various forms of uncertainty, and showed that disregarding alarm signals may lead to arbitrarily bad strategies. The central problem with an alarm system, unexplored in other Security Games, is finding the best strategy to respond to alarm signals for each mobile defensive resource. The literature provides results for the basic single\u2013resource case, showing that even in that case the problem is computationally hard. In this paper, we focus on the challenging problem of designing algorithms scaling with multiple resources. First, we focus on finding the minimum number of resources assuring non\u2013null protection to every target. Then, we deal with the computation of multi\u2013resource strategies with different degrees of coordination among resources. For each considered problem, we provide a computational analysis and propose algorithmic methods.", "creator": "LaTeX with hyperref package"}}}