{"id": "1606.04487", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2016", "title": "Omnivore: An Optimizer for Multi-device Deep Learning on CPUs and GPUs", "abstract": "We perform a study of the factors affecting training time in multi-device deep learning systems. Given a specification of a convolutional neural network, we study how to minimize the time to train this model on a cluster of commodity CPUs and GPUs. Our first contribution focuses on the single-node setting, in which we show that by using standard batching and data-parallel techniques throughput can be improved by at least 5.5x over state-of-the-art systems when training on CPUs. This ensures an end-to-end training time directly proportional to the throughput of a device regardless of its underlying hardware, allowing each node in the cluster to be treated as a black box. Our second contribution is a theoretical and empirical study of the tradeoffs affecting end-to-end training time in a multiple-device setting. We identify the degree of asynchronous parallelization as a key feature affecting both hardware and statistical efficiency. We show that asynchrony can be viewed as introducing a momentum parameter, which we use to limit our search space; in turn, this leads to a simpler optimizer, which is our third contribution. Our optimizer involves a predictive model for the total time to convergence and selects an allocation of resources to minimize that time. We demonstrate that the most popular distributed deep learning systems fall within our tradeoff space but do not optimize within the space. By doing such optimization, our prototype runs 1.9x to 12x faster than the fastest state-of-the-art systems.", "histories": [["v1", "Tue, 14 Jun 2016 18:21:04 GMT  (2439kb,D)", "http://arxiv.org/abs/1606.04487v1", null], ["v2", "Mon, 18 Jul 2016 00:05:49 GMT  (2439kb,D)", "http://arxiv.org/abs/1606.04487v2", null], ["v3", "Fri, 26 Aug 2016 13:04:00 GMT  (2439kb,D)", "http://arxiv.org/abs/1606.04487v3", null], ["v4", "Wed, 19 Oct 2016 04:26:03 GMT  (2549kb,D)", "http://arxiv.org/abs/1606.04487v4", null]], "reviews": [], "SUBJECTS": "cs.DC cs.LG", "authors": ["stefan hadjis", "ce zhang", "ioannis mitliagkas", "dan iter", "christopher r\\'e"], "accepted": false, "id": "1606.04487"}, "pdf": {"name": "1606.04487.pdf", "metadata": {"source": "CRF", "title": "Omnivore: An Optimizer for Multi-device Deep Learning on CPUs and GPUs", "authors": ["Stefan Hadjis", "Ce Zhang", "Ioannis Mitliagkas", "Christopher R\u00e9"], "emails": ["imit}@stanford.edu", "chrismre}@cs.stanford.edu"], "sections": [{"heading": "1. INTRODUCTION", "text": "Deep learning has emerged as a powerful technique in machine learning, providing astonishing improvements in quality for a number of data-driven applications [8, 10, 17, 26]. An important aspect of deep learning is that quality improves with the amount of data, and so advances in system efficiency and scalability directly improve quality. This observation has led to an arms race of distributed deep learning systems both in industry (e.g., Google\u2019s DistBelief [8], Microsoft\u2019s Adam [7]) and in academia [5, 15,19,25].\nIn spite of this proliferation of deep learning systems, there have been few studies of deep learning from a datasystems perspective. Each of these systems makes a set of design decisions, although these design decisions may not work for other tasks or hardware settings. To address this concern, we perform a first study of the design space for deep learning systems. Moreover, systems that do implement a number of design choices provide no way of automatically selecting an optimal configuration, placing this burden on the user. In our experience working with multiple PhD-level users of these systems\u2014including experts in pathology, radiology, computer vision, and the energy sector\u2014it is often very difficult even for advanced users to make these design decisions themselves. It is not uncommon for a suboptimal design choice to result in a runtime that is an order of magnitude slower end-to-end than what is possible. By exploiting our understanding of the tradeoff space and new theoretical insights on asynchrony, we develop a simple optimizer that enables our own prototype system to be 1.9\u00d7 to 12\u00d7 faster than the fastest competitor systems.\nWe focus on perhaps the most popular deep learning models, Convolutional Neural Networks (CNNs), which are state-of-the-art for a wide range of applications (e.g., image processing, video analysis, drug discovery) and which contain many of the fundamental layers used in other deep learning models. Our study answers the question: \u201cGiven a cluster (e.g. X machines, Y GPUs, Z CPUs, etc.), how do I train my CNN as quickly as possible?\u201d. Answers to this question have obvious implications for performance as well as total cost of ownership and end-user cost in the cloud.\nWe assume that the following are given: (i) a deep learning model (network architecture), (ii) a dataset for training this model, and (iii) a set of computational resources (a number of devices on machines, their throughput, and the network speed).1 We then study how to minimize the total training time. We build a complete prototype capable of training the most popular deep learning models. This allows us to hone in on two major choices: (i) how to use hardware on each node and (ii) the degree to which asynchrony can be tolerated. Our work demystifies these factors by identifying the key tradeoffs that underlie all design decisions, providing theoretical guidance about asynchrony, and quantifying the impact of those tradeoffs experimentally.\n1 We only do basic network optimization, and we assume that machines are connected by a uniform and fast topology, e.g., if they were housed on the same rack.\nar X\niv :1\n60 6.\n04 48\n7v 1\n[ cs\n.D C\n] 1\n4 Ju\nn 20\n16"}, {"heading": "Overview of Technical Contributions", "text": "To conduct our study, we develop a prototype distributed system, which we call Omnivore as it scales to consume all available hardware resources. We make three contributions.\nContribution 1: Single-Device Optimizations. In Section 3 we demonstrate that we can achieve throughput proportional to the FLOPS of both CPUs and GPUs. This statement is not trivial\u2014there has been a long debate about CPUs vs GPUs for deep learning: GPUs are popular for CNN systems because of the high throughput they provide, but they contain smaller off-chip memories than CPUs. Microsoft\u2019s Project Adam argues that CPUs can deliver more cost-effective performance [7]. For users who cannot control their data-center hardware, another issue is that Amazon\u2019s EC2 provides GPUs but Google Compute does not. Also, Amazon provides more aggregate available FLOPS if one selects CPU clusters. We observe that while state-of-theart systems achieve GPU speeds proportional to the device throughput, existing CPU implementations can be sped up significantly compared to what is reported in the literature.\nOur study explores two key optimizations that we first reported last year [13]. We use batching and data-parallel optimizations\u2014not employed in other systems\u2014to achieve end-to-end speedups of more than 5.5\u00d7 over state-of-the-art systems on commodity CPUs. Such optimizations are not always possible on the GPU, but by selecting this strategy for the CPU, we now achieve speeds proportional to the peak throughput. This allows us to build a radically simpler optimizer by modeling CPUs and GPUs as black boxes.\nContribution 2: Multi-device Tradeoffs. In Section 4 we describe our second contribution, an empirical study of the factors affecting training time for multi-device deep learning training. We analyze the decisions made on existing systems and conclude that, while diverse, the strategies of the most popular systems fall within a tradeoff space defined by two fundamental dimensions [5, 7, 8, 15, 19, 25]: (i) the server architecture, or how the layers of a CNN map to devices; and (ii) the execution strategy, or how batches of data are mapped to machines for processing. We develop a simple framework that allows us to model each of these approaches. Devices are organized in compute groups. Each compute group is responsible for a single batch of data per iteration. Inside a group, the CNN computation for that batch occurs in standard, synchronous steps. Across groups, however, computation happens asynchronously. This leads to the use of stale model parameters.\nThis setting lets us hone in on a key aspect in deep learning: asynchrony during training. Asynchronous approaches are widely used in industry as they make better use of the hardware by forgoing any locking [7, 20]. The question is: how does one divide up available resources? Because deep learning models are often trained iteratively, we decouple the problem into two portions: (i) hardware efficiency (HE), the time per training iteration; and (ii) the statistical efficiency (SE), the number of iterations required for training to converge. From these definitions,\nSE\u00d7 HE = total training time, (1)\nwhich we want to minimize.\nAt a high level, HE is straightforward: the more compute groups, the better the hardware utilization (less coordination, fewer locks and less network congestion). To build an optimizer we also need to predict the throughput. As we shall see, deep learning\u2019s core computation is very regular (standard deviation in runtime is less than 6%). Thus, a simple queuing model that determines which resource is the bottleneck in the network allows us to predict execution throughput within 15% on a range of datasets.\nStatistical efficiency is conceptually more difficult. We give a new theoretical characterization of asynchronousparallel training and show that it can be viewed as a synchronous update but with an increased, implicit momentum term. Momentum is explicitly (i.e., algorithmically) introduced in almost every system [23], but we are the first to realize this connection between asynchrony and momentum. Furthermore, no prior work has identified any relationship between the hyperparameters and asynchrony. The implicit momentum from asynchrony increases with the number of asynchronous workers in the model. We have begun to explore the theory in a companion paper [18]; here we summarize its impact on deep learning systems. A particular consequence is that if optimal (synchronous) momentum is above the implicit momentum, then there is no penalty for running asynchronously as long as the momentum is properly tuned\u2014which we demonstrate empirically. For large datasets like ImageNet, the best choice is to run with maximum asynchrony for more than 85% of the execution. There is, however, a natural tradeoff: too much asynchrony, especially for smaller models, can be ineffective. This leads us to develop an automatic optimizer.\nContribution 3: Simple Automatic Optimizer. In Section 5, based on the theory above, the intuition behind our optimizer is very simple: pick the highest degree of asynchrony such that the implicit momentum induced by asynchrony is below the optimal momentum. Given a fixed number of compute groups (asynchrony), we grid-search the parameters for learning rate and momentum. If the best-found momentum is non-zero, the optimizer chooses this configuration. If it is zero, we assume that there could be a better setting with fewer compute groups. Our optimizer is able to choose a near-optimal point in the tradeoff space and we demonstrate that our system achieves end-to-end speedups of 1.9\u00d7 to 12\u00d7 on popular CNN workloads compared to state-of-the-art tools that choose suboptimal tradeoff points. To leverage the above tradeoff, we show that it suffices to measure the statistical and hardware efficiency for minutes (less than 10% of the time to train a network). We compare our simple optimizer with a state-of-the-art Bayesian optimization approach [22]. Both approaches are able to reach the same final accuracy (within 1%), but the Bayesian strategy takes almost 6\u00d7 as long.\nFinally, we demonstrate that our optimizer is generic, and we apply it to other deep learning systems. In some cases this prevents those other tools from diverging, and in other cases the optimizer speeds them up by a factor of 7\u00d7.\nOutline. We present background in Section 2. Section 3 and Section 4 introduce the tradeoff space related to singlemachine and multi-device settings, respectively. Section 5 describes the optimizer for making decisions in this tradeoff space. We validate our results in Section 6, discuss related work in Section 7 and conclude in Section 8."}, {"heading": "2. BACKGROUND", "text": ""}, {"heading": "2.1 Convolutional Neural Networks (CNNs)", "text": "A convolutional neural network (CNN, [17]) consists of layers L1, L2, . . . , LP . Each layer is an operator which takes as input a 3D data tensor D \u2208 Rn\u00d7n\u00d7din and transforms it to a resulting 3D data tensor R \u2208 Rm\u00d7m\u00d7dout , i.e. LFWp (Dp) = Rp. FW indicates the layer running in the \u201cforward\u201d direction to transform D into R. Layers have a second operation, backward or BW , described later. As a running example, let the input D1 to the first CNN layer L1 be an image I \u2208 Rn\u00d7n\u00d73, where 3 represents the RGB color channels.\nFor layers after L1 (the input layer), the input tensor Dp comes from the output of a prior layer (usually Dp = Rp\u22121), such that the CNN layers are cascaded to define a composite operation (boldface highlights inputs and outputs)\nRP = L FW P \u25e6 LFWP\u22121 \u25e6 ... \u25e6 LFW2 \u25e6 LFW1 (I) (2)\nThe final result RP is the CNN\u2019s prediction for image, I. For example, if the task is image classification with 1000 categories, the tensor RP \u2208 R1\u00d71\u00d71000 is a vector containing the probability of each category. This prediction is then compared to C, the true classification for I, using a loss function `(RP , C) that evaluates the quality of the prediction. A lower loss indicates a better prediction.\nMany types of layers exist in a CNN. Some layers perform a pre-defined transformation such as downsampling while other layers contain a model, W, and perform an operation parameterized by the model. Models are also known as weights or parameters. The models of all layers constitute the entire set of weights or parameters of the CNN, i.e. W = WCNN = {WL1 , . . . ,WLP }\u2014although recall some layers have no model parameters."}, {"heading": "2.2 Stochastic Gradient Descent", "text": "The goal of CNN training is to optimize the model W in order to minimize the loss function `(RP , C), also denoted as `(W, I,C) to make the fact that RP is a function of W and I explicit. Low loss is correlated with high prediction accuracy and in this work we refer to both. The most popular training algorithm for CNNs is an iterative technique called stochastic gradient descent (SGD). Each SGD iteration consists of a forward and backward pass.\nThe input to each SGD iteration is an image-label tuple (I, C) as described above. The forward pass calculates the prediction RP of I using equation (2), and then the prediction error compared to C is used to calculate the gradient (or derivative) of ` with respect to RP . We denote this gradient as \u2207RP `. Now the cascade of equation (2) runs in reverse by applying each layer in the \u201cbackward\u201d direction:\nLBW1 \u25e6 LBW2 \u25e6 . . . \u25e6 LBWP\u22121 \u25e6 LBWP (\u2207RP`) (3)\nequation (3) implements the chain rule of calculus. The BW operation of layer p takes as input a data gradient \u2207Rp` and outputs a data gradient \u2207Dp`. Internally, it also updates that layer\u2019s model WLp by (i) calculating a gradient of the loss with respect to the model, \u2207WLp `, and (ii) using an SGD update on the model. The SGD algorithm repeats iteratively for many iterations, often in the millions, until\nthe loss is sufficiently low, i.e. the model is sufficiently optimized. The initial model W (0) is randomly initialized. The SGD update at step t takes the form\nW (t) \u2190W (t\u22121) + V (t), (4)\nwhere the new step, V (t), consists of a scaled version of the previous step, V (t\u22121), plus a gradient calculated on the new tuple (I, C).\nV (t) \u2190 \u00b5V (t\u22121) \u2212 \u03b7 [ \u2207W ` ( W (t\u22121), I, C ) + \u03bbW (t\u22121) ] (5)\nIn Section 4 we introduce the notion of asynchronous updates. The main change in equation (5) under asynchrony, is the use of an older model, W (s), when evaluating the gradient \u2207W `. This gradient (specifically, its negative) is the direction to \u201cstep\u201d within the parameter space each SGD iteration. The learning rate, \u03b7, is the scale factor applied to the magnitude of this gradient, i.e. the size of the step. \u03bb dictates the amount of regularization, which is an input to the training problem (part of the CNN model to train). \u00b5 is the amount of explicit momentum we add to the update. Momentum is used to \u201caccelerate\u201d learning in the directions common to each gradient by keeping a history of past gradients and adding this history to the gradient of the current step, with past gradients decayed exponentially. Commonly, in order to produce more stable gradients, each SGD iteration does not process a single tuple (I, C), but a batch B of tuples, e.g. 256, in which case D and R become 4D. The gradients from each tuple are summed to produce a single, combined gradient for that iteration.\nSelecting the right values for hyper-parameters (\u03b7, \u00b5,B) is critical for performance. We will describe a simple optimizer to pick these parameters."}, {"heading": "2.3 CNN Computation", "text": "Of all the CNN layers, two model layers are the most computationally intensive, convolutional (conv) and fullyconnected (FC) layers. A convolutional layer performs many independent convolutions over an image, i.e., several sliding window operations; in contrast, an FC layer performs a dense matrix multiplication. In many popular implementations, the bottleneck in both layers is a matrix multiply implemented as a call to either a BLAS or cuBLAS library. For our study, their data properties are more important, and we refer to Chetlur et al. [6] for a more detailed description of their use in machine learning.\nAs shown in Figure 1, in state-of-the-art models, all convolutional layers always appear before all fully-connected layers. Therefore, in this work we introduce an abstraction\nwhich separates a CNN into two phases, each consisting of a number of consecutive layers: first the convolution phase (conv), whose layers have large data tensors D and R (e.g., 100MB-1GB) and small models W (e.g., 5-50 MB), followed by the fully-connected phase (FC), whose layers have small D and R (e.g., 1-10MB) and large W (e.g., 30-300 MB). The reduction in data size is in part due to pooling layers in the convolution phase which perform down-sampling. The increase in model size is due to the fact that convolution layers repeat the same weights for the sliding window. Note that our two-phase categorization also applies to modern, non-linear CNNs [14]. See Appendix B.1 for a full description of CNN trends.\nThe computation for both the conv and FC phases is usually compute-bound although the conv phase contains significantly more computation (e.g., in AlexNet conv is 1.6 TFLOPs and FC is 80 GFLOPs, or 95% of the computation is convolution). Within a machine, each layer\u2019s computation can be mapped to CPUs, GPUs or a combination of both. In addition, this computation can be parallelized either using data parallelism (partitioning the data batch and replicating the model, which works well for the conv layers) or model parallelism (partitioning the model and replicating the data batch, which works well for the FC layers). These single-machine choices are studied in Section 3.\nSection 4 studies these same choices but in the distributed setting. There the layer computations are mapped across machines, although as we will show this mapping is always done at the coarser granularity of entire phases (conv or FC) because it reduces network delays due to the distinct model and data sizes of the two phases. In addition, Section 4 studies techniques to parallelize the iterative (seemingly sequential) SGD algorithm in a distributed setting."}, {"heading": "2.4 Problem Definition", "text": "We study systems tradeoffs to build an optimizer for the most widely used networks/algorithms. We focus on SGD due to its popularity, although our optimizer applies to other algorithms as well. More precisely, we are given as input the following: (i) a CNN architecture {L1, ..., Lp}, including regularization, (ii) a dataset D consisting of data batches, (iii) a device graph G in which vertices are hardware devices (specified by their throughput) and edges are communication speeds between devices. Our goal is to design an optimizer which creates a plan for physical mapping and execution strategy in order to train as quickly as possible.\nA plan for physical mapping maps the computation (both FW and BW) of each layer of the CNN to vertices (e.g., GPUs or CPU cores) of the device graph. Section 3 first studies how to do this mapping to hardware within a device, and concludes that with proper optimization only the throughput of each vertex matters, not its underlying hardware. Section 4 then studies how to do this mapping across devices. If the cluster is homogeneous, we do not need the explicit device graph \u2013 instead, a few parameters, such as the number of devices and the throughput of each device, are enough to specify the cluster for the optimizer.\nA plan for the execution strategy maps data batches to devices in order to parallelize SGD in the multi-device case. The key decision here is the degree of asynchrony in execution. This is further described in Section 4."}, {"heading": "3. SINGLE-DEVICE TRADEOFF", "text": "The first step towards building a distributed optimizer is understanding the systems tradeoffs within a single device. We show that for each device (GPU or CPU) we can achieve throughput that is proportional to its peak FLOPS. This will enable the distributed optimizer to treat each device as a black box in Section 4. This is not a trivial property for deep learning: many CNN systems exist [1, 2, 16] which use either CPUs or GPUs, but these always report that GPU implementations are an order of magnitude faster than CPU. This is true even when the devices offer similar FLOPS. Therefore the challenge is to utilize the FLOPS on the CPU. We study the key kernel in CNN implementations, which is compute bound. We introduce a data batching technique which trades off memory footprint for compute time and demonstrate that this tradeoff gives a more than 5\u00d7 CPU speedup over existing systems. With this optimization now both CPUs and GPUs give throughput proportional to the FLOPS offered by the device."}, {"heading": "3.1 Convolutional Layer Computation", "text": "As reported in the literature and confirmed by our experiments, the most computationally intensive layers in the CNN are the convolutional layers. Together, all convolutional layers in a CNN often consume between 70-90% of total execution time. Recall that a convolutional layer contains a model, which we will also call its kernel and denote as K. A convolutional layer accepts as input a 4D data tensor D \u2208 Rn\u00d7n\u00d7din\u00d7b, where recall b is the batch size. K is also a 4D tensor, K \u2208 Rk\u00d7k\u00d7din\u00d7dout . The output is a 4D data tensor R \u2208 Rm\u00d7m\u00d7dout\u00d7b, where:\nRx,y,z,w = din\u22121\u2211 d\u2032=0 k\u22121\u2211 x\u2032=0 k\u22121\u2211 y\u2032=0 Dx\u2212 k 2 +x\u2032,y\u2212 k 2 +y\u2032,d\u2032,wKx\u2032,y\u2032,d\u2032,z\n(6) Like most HPC kernels a straightforward implementation is suboptimal, and many optimized implementations of this convolution kernel exist [6, 16, 24]. A popular implementation is to perform equation (6) as a dense matrix multiplication (also known as GEMM, general matrix multiply),\nwhich [6] demonstrates to be versatile and fast for a range of size parameters, as GEMM kernels are highly optimized.\nIn order for equation (6) to be carried out as a matrix multiplication an initial reformatting and replication step called lowering is required to put the data and model into the correct format. Figure 2 shows the three logical steps in the lowering process: (i) lowering, which transforms 3D tensors\nD and K into 2D matrices D\u0302 and K\u0302; (ii) matrix multiply,\nwhich multiplies D\u0302K\u0302 to get the result R\u0302; and (iii) lifting,\nwhich transforms R\u0302 back to a tensor representation of R. In prior work [13] we studied a number of lowering strategies and showed that this one works best for most CNN kernels. See Appendix C.1 for a full tradeoff analysis. The lifting step is fast (reformatting), but the lowering step requires replication of the data, sometimes by a factor of 1 or 2 orders of magnitude. This blowup in the data size demands more off-chip memory and more computation in step (ii)."}, {"heading": "3.2 Batching and Data Parallelism", "text": "The design tradeoff between CPUs and GPUs arises as a result of this increase in data size. Assume that we are given a fixed batch size of b images (e.g. b = 256, discussion on selecting b in Appendix E.1). GPUs cannot fit an entire batch of lowered data into off-chip memory, therefore many CNN implementations on GPUs perform lowering/GEMM serially on one or few images at a time until all b have been processed. On the CPU however, off-chip memory is larger which allows lowering/GEMM to be performed on all b images at once. This leads to significant CPU speedups compared with state-of-the-art tools which do not explore this tradeoff but use the same implementation suited to the GPU for the CPU. In particular, as Figure 3 shows, this allows us to view a CPU or GPU as simply a device producing FLOPS; for reference, we also include the FLOPS delivered by the most popular CNN framework Caffe [16] and the call of an optimized single-precision matrix multiply (SGEMM) for that hardware. The throughput obtained by Omnivore on all devices in Figure 3 also matches the expected range for CNNs (on GPUs) reported by the manufacturer [6].\nTo achieve this throughput on the CPU, we use a simple convolution batching technique in which we first lower all b images in a batch before performing any GEMM. After this lowering, we perform a single GEMM for all b images, rather than b smaller GEMMs. This consumes b\u00d7 the memory because the D\u0302 matrix is b\u00d7 larger than when lowering images one by one. However, it has two speed benefits: (i) one large GEMM is faster than b smaller GEMMs because CPU caches and vector instructions are fully utilized, and\n(ii) lowering all images in the batch at once enables data parallelism to be used during lowering. Specifically for (ii), given n CPU cores, a batch is split into n partitions, with b/n images per partition. A separate thread then performs lowering and GEMM on each partition, i.e. each thread performs convolution on a subset of the batch. This data parallelism can similarly be applied to all layers of the CNN.\nGeneralizing this implementation tradeoff, bp images can be processed in parallel by the convolution layer, where 1 \u2264 bp \u2264 b. Increasing bp increases the memory footprint but decreases the overall execution time. Figure 4 shows batching experiments for a CPU GEMM kernel (the GPU is discussed in Appendix C.2). All points in each graph perform GEMM on 256 images (i.e., b = 256), but the number of total GEMM calls depends on bp (e.g., if bp = 256, there is one large GEMM). We therefore advocate the strategy of\nselecting bp as large as possible (up to b) such that D\u0302 fits into the off-chip memory. This can be predicted because memory usage increases linearly with bp as seen in Figure 4 (c). For a range of modern CPUs that we used in our experiments, the optimal bp value is always b.\nWhile this tradeoff is simple, it enables FLOPS proportional scheduling which allows us to abstract away the details of devices in our distributed implementation."}, {"heading": "4. MULTI-DEVICE TRADEOFF", "text": "Having studied the tradeoffs for a single device, this section now studies the distributed setting. Given a CNN, an input set of data and a set of devices, our goal is to map each layer of the CNN and a subset of data to each device. While many diverse distributed CNN systems exist [5,7,8,15,19,25], we explain in Appendix D.3 that these can be mapped to points within our tradeoff space.\nOur exploration revealed that a key tradeoff is the degree of asynchrony. Following the HE, SE decomposition in equation (1), we build models predicting how hardware efficiency (Section 4.1) and statistical efficiency (Section 4.2) are affected by asynchronous execution. As we will see HE and SE are in opposition, but by decoupling them and creating a separate model for each the optimizer can find a balance and minimize the total time to convergence. Specifically, we argue for an analytic model for HE and we are able to give a new theoretical characterization of SE.\nWe separate each layer into compute servers, responsible for computation, and a model server responsible for handling reads from and writes to the model. These \u201cservers\u201d are virtual: many servers may be mapped to the same device or an individual server may be mapped to several devices. While\nthe separation of compute and model servers is present in all systems, only project Adam [7] described mapping both compute and model servers to the same device (or set of devices for parallelism), i.e. merging the servers, which they did for FC layers. Figure 5 (a) shows this mapping. For concreteness, suppose there are N + 1 devices: one device handles the FC layers, and the remaining N devices handle the conv layers (motivated by 90 \u2212 95% of the computation being in the convolutions). To simplify our exposition we refer to this reference architecture throughout Section 4. Section 5 demonstrates the benefits of this architecture empirically both in terms of hardware and statistical efficiency.\nCompute Groups. The input data to a layer is divided into batches (whose size is determined by the system). The main computational operation for each layer is to (i) read the model; (ii) compute an operation on the data (the forward or the backward pass) for the given a batch of data; and (iii) update the model. We assign each compute server to a compute group. Within a compute group, many devices speed up the computation of an individual batch of data, e.g., all devices compute a single gradient for a batch. Across compute groups, different devices process distinct batches.\nAsynchrony and Staleness. In most systems, compute groups communicate asynchronously [7, 8, 20]: the models are updated without locking or barriers, and so forward and backward passes may be computed with a stale model. Intuitively, the lack of coordination allows one to make better use of the hardware (better hardware efficiency) but the use of stale information may reduce statistical efficiency. If there are g = S + 1 compute groups, we call S the staleness parameter. This is justified as the computation within each group in step (ii) above is very regular for CNNs (standard deviation of runtime is less than 6% of mean), hence these groups execute in a nearly round-robin fashion.\nThroughout this section, we make two simplifying assumptions: First, we focus our description on the two phases described in Section 2, i.e., we abstract networks into convolutional layers (conv) which have a large amount of data but a small model, and fully-connected layers (FC) which have small data but a large model. Practically, these two layers are the main bottlenecks in current networks. Their differing characteristics give rise to different points of the tradeoff space. Second, many popular networks are simply a single chain, not a DAG (e.g. AlexNet), and DAGs can be serialized into a chain, hence we view the input as a list of layers (without loss of generality).\nExecution. Given a list of layers, the main computational loop is to move through the list forward calling the forward operation and in reverse order calling the backward operation at each step. As we have decomposed each layer into a model server and compute servers and further mapped compute servers to compute groups over several devices, it is the responsibility of our execution engine to make sure that all data is on each device when needed. We use standard techniques to hide latency of device copies, e.g., double buffering."}, {"heading": "4.1 Hardware Efficiency Model", "text": "The goal of this section is to create a predictive model HE(S) for hardware efficiency, specifically how HE is affected by the amount of staleness S in the system (or equivalently the number of compute groups, g). We derive a simple analytic model which reasons about the bottlenecks. An execution strategy partitions the N conv devices into g compute groups. Again for concreteness, assume there are k devices per group (k = N/g). Let tconv(k) be a function that returns the time that a group of size k needs to compute the convolution phase. We make the assumption that FC only operates sequentially2. Note that the number of requests to the FC phase is a function of the number of groups, and let tfc be the time that the FC phase needs to serve one group.\nGiven g, tconv(k) and tfc, our goal is to create a hardware efficiency model which predicts the time per iteration. There are two cases depending on which phase is the bottleneck:\n\u2022 Case 1: Saturated FC The first case is when FC phase is saturated, i.e., it starts to serve the next request immediately after the previous request finishes. In this case,\nTime per iterationsaturated fc = tfc\n\u2022 Case 2: Saturated Conv When the FC phase is not saturated, each conv group becomes the bottleneck. In this case (the proof is in the Appendix D.4),\nTime per iterationsaturated conv = (tconv(k) + tfc)/g\nwhich is the total time for a single iteration divided by the number of parallel groups.\nThus, our predicted model for iteration time, HE(g), is:\nHE(g) = max{tfc, (tconv(k) + tfc)/g}\nGiven tconv(k), tfc and the number of groups, g, the model can now predict what the mode of saturation will be and therefore the time per iteration. In Appendix D.4, we show that this works across a range of datasets.\nObtaining the Parameters. The parameters above can be measured with high accuracy and low variance. tfc can be measured by running an iteration on a single device, but tconv(k), though still directly measurable, requires measurements for each k. Instead, tconv(k) can be calculated from (i) the throughput of each node; (ii) the network speed; and (iii) a measurement of tconv(1) (which only needs to be measured for a single k, k = 1, and on a single device). We present this calculation in Appendix D.4, and Figure 5 (b) shows that given only (i) to (iii) above, the end-to-end\n2 For simplicity, assume different groups (batches) cannot be executed in parallel on the FC server (we handle this in Appendix D.4).\nhardware efficiency model described in this section is accurate and matches the statically measured time per iteration for each S. This works because tconv(1) and tfc have low variance, for example on a cluster of 9 machines we observed a standard deviation of < 6% in these (see Appendix D.4)."}, {"heading": "4.2 Statistical Efficiency Model", "text": "Our goal is to characterize the effect of staleness on statistical efficiency. During our study, we discovered a theoretical characterization of this phenomenon, which was surprising to us as deep learning problems are seemingly impenetrable to theory. We demonstrate that staleness can be regarded as a synchronous update\u2014but with a stronger momentum term. We state a simplified version of this result that is sufficient to understand our optimizer, and describe a more detailed version in a companion theoretical paper [18]. More importantly, we validate the predictions of this model on a range of deep learning models. In turn, this will form the basis of our optimizer.\nWe make the following modeling assumptions, which are not necessary but help us capture the essence of the result and form the basis of our optimizer. The full model, detailed assumptions and proofs can be found in [18]. We make the three following simplifying assumptions.\n(A0) The batch to be used for each step is drawn uniformly at random with replacement. This is a standard assumption of SGD.\n(A1) Variations in the time it takes to process a step are due to unmodeled system behavior. Importantly, variations are independent of the specific batch drawn. This is justified by the fact that, for all batches, all computation involves dense operations.\n(A2) The time it takes to process a step is exponentially distributed and independent from other steps. This is a simplifying but standard assumption from queuing theory [12]. A more general (and complex) version of Theorem 1 below holds without this assumption.\nTheorem 1. Consider g asynchronous groups and set explicit momentum to zero, i.e. \u00b5 = 0 in the update of equation (5). Under the above assumptions, the expected update becomes\nEV (t+1) = (\n1\u2212 1 g\n) EV (t) \u2212 \u03b7\ng E\u2207W `(W (t)). (7)\nIn which `(W ) denotes the expectation of `(W, I,C) over the random draw of possible batches (I, C).\nIn plain English, asynchrony increases momentum \u2013 there is implicit momentum of 1 \u2212 1/g. This simple version is interpretable in that it exactly matches the standard form of momentum used by deep learning practitioners in equation (5). Moreover, it successfully predicts measured system behavior. Figure 6 shows the predicted and actual measured momentum for two datasets: Theory suggests that, as long as the asynchrony-induced implicit momentum is less than the optimal total momentum, we can algorithmically compensate with explicit momentum. When however, implicit momentum exceeds the optimal total momentum, we start incurring statistical inefficiency. We use this intuition as the basis for our optimizer in Section 5.\nCold-start. We observe a phenomenon similar to burnin [21] in Gibbs samplers. The model needs a few iterations to set the appropriate scale of the model parameters. On Imagenet-1000, we find that 5 passes over the dataset (< 15% of total execution) suffice to \u201cwarm up\u201d the model. As a result, the optimizer starts by running synchronously and then switches to asynchronous (see Section 5)."}, {"heading": "5. DISTRIBUTED OPTIMIZER", "text": "This section uses the models and tradeoff space characterization of the previous two sections to create (i) a plan for physical mapping which maps each server to a machine, and (ii) a plan for the execution strategy which defines the number of compute groups by allocating data batches to each server. As in previous sections we assume a fixed number of machines. We first discuss the process of physical mapping and then describe our optimizer. We conclude with theoretical and empirical justification for the optimizer, and in Section 6 compare it to state-of-the-art, Bayesian approaches."}, {"heading": "5.1 Physical Mapping", "text": "We observe that in all CNNs the architecture of Figure 5 (a) works best, and describe other physical maps and the search space in Appendix D.4. Omnivore maps the FC compute and model servers to the same machine, an approach we call merged FC. Merging the FC compute and model servers to the same devices was shown in [7] to reduce communication overhead in a CPU cluster (improving HE), however it was not known that (1) this also benefits HE for a GPU cluster, and (2) this technique also benefits SE by eliminating staleness in the FC model. These are both observations we make. The remaining machines are used for the conv compute servers. The conv model servers are mapped to one of the conv compute machines. These optimizations are critical: on a cluster of 33 EC2 c4.4xlarge machines, not merging the FC servers incurs an additional hardware efficiency penalty of 1.2\u00d7 due to increased communication as well as a statistical efficiency penalty of 2.5\u00d7 because of staleness in the FC model. The key tradeoff is therefore the number of conv compute groups, which we describe next."}, {"heading": "5.2 Optimizer", "text": "Multiple factors impact the performance of the training procedure: (1) the number of compute groups; (2) the momentum; and (3) the learning rate. As we illustrated in Section 4.2, all these three are interdependent. Moreover, the optimal setting of these parameters might change during training, so our optimizer runs periodically in epochs (e.g., every hour). Algorithm 1 shows the end-to-end optimizer that runs after the intial cold-start period (described in more detail in Appendix E.4).\nAlgorithm 1 Automatic Optimizer for the Tradeoff\nInput: Time budget T and possible choices of (1) # compute groups CG, (2) momentum M, and (3) learning rate H. Output: Trained model W .\n1: g = CG 2: while not reaching the termination criteria do 3: (\u00b5, \u03b7) \u2190 gridSearch(M,H|W, g) 4: while \u00b5 = 0 and g > 1 do 5: g \u2190 g/2 6: (\u00b5, \u03b7) \u2190 gridSearch(M,H|W, g) 7: end while 8: W \u2190 train(g, \u00b5, \u03b7,W ) for T minutes 9: end while\n10: return W .\nIn each of the epochs, the key issue is to set the number of compute groups, g. We perform a grid search over both the learning rate and the momentum starting at a particular value of g. This search determines the optimal explicit momentum for that g by selecting the configuration with the lowest final loss. The key intuition is: set the highest amount of asynchrony, g, such that this explicit momentum is non-zero. The reasoning is that, when the optimal explicit momentum is 0, the implicit momentum is likely higher than the optimal value, and a cause of statistical inefficiency (c.f. Figure 6). In this case, we reduce the amount of asynchrony by reducing g. We provide an initial value for g by leveraging the HE model of Section 4.1. In particular, we start with the smallest number of compute groups that saturate the FC server. This can be determined analytically or through measurements during the cold start phase. Having selected a (g, \u03b7, \u00b5), we run for the rest of the epoch, which is an hour. At the end of the hour, the epoch ends, the model is checkpointed (written to disk), and the optimizer repeats.\nImportance of Compute Groups. We demonstrate that using the right number of compute groups has an impact on performance. Fixing the total number of machines, we try different numbers of compute groups on CPU-L (Figure 9) for the Imagenet 1000-class dataset, and AlexNet CNN. We grid-search a number of values for the learning rate and momentum and report the best result achieved in each case (details in Appendix E.3). Figure 7 reports (a) the time per iteration (hardware efficiency, HE), (b) the number of iterations to reach a specific training loss (statistical efficiency, SE), and (c) their product, which by equation (1) is the total time required to reach the final loss. Note that the HE curve in (a) is the same as in Figure 5 (b).\nWe see in Figure 7 (c) that g = 32 (fully asynchronous) is 3.7\u00d7 faster than g = 1 (synchronous) as measured by wall-clock time to final loss. This is due to its 6.7\u00d7 faster iteration time (HE) in (a), although it requires 1.8\u00d7 more it-\nerations (SE) as shown in (b). This matches the theory\u2019s prediction: increasing g causes the optimal explicit momentum, \u00b5\u2217, to decrease. We see that \u00b5\u2217 drops to 0 at g = 32, and consequently there is a penalty in SE. Running the optimizer of Algorithm 1 selects g = 4, which is near-optimal: 5.3\u00d7 faster than sync and 1.4\u00d7 faster than async. We repeat the same experiment for CIFAR and report similar wall-clock time plots in Appendix F.3. We see that in all cases, the optimal number of groups is more than 2\u00d7 faster compared to sync, and that Algorithm 1 always picks a near-optimal point strictly better than sync."}, {"heading": "6. EXPERIMENTS", "text": "We evaluate the runtime performance of our system, and we observe that Omnivore outperforms state-of-the-art tools by 1.9\u00d7 to 12\u00d7 on a range of training tasks. Our result holds (i) across a diverse range of hardware, including both CPUs and GPUs, (ii) in both single device and multiple device/machine settings. Importantly, Omnivore does not require users to pick hyperparameter values. The tradeoff analysis presented in Section 4 leads to the automatic optimizer of Section 5, which takes care of those choices. Our experiments validate that our optimizer produces better results compared to hand-tuned schedules and is up to 6\u00d7 faster compared to state-of-the-art Bayesian optimizers."}, {"heading": "6.1 Experiment Setup", "text": "We begin by describing the datasets, models and tasks as well as the hardware we run on.\nDatasets and Models. We validate the performance of Omnivore on a diverse range of datasets and models, as shown in Figure 8. The largest corpus we use is ImageNet [9], which contains 1.3M images. ImageNet is the de facto benchmark for deep learning systems [7, 8, 17]. Training a model on ImageNet can take tens of hours\u2014even on the latest 7 TFLOPS Titan X GPU, NVIDIA reports that it took three days to train with a single GPU.3 For some of our experiments, which require running many configurations to convergence, we used a reduced version, ImageNet8, containing the first 8 classes. We train the standard CaffeNet4 on both data sets. We also use smaller, but standard, datasets CIFAR and MNIST, which are for object recognition and handwriting recognition, respectively. We train the standard networks in Caffe\u2019s tutorials for both.\nMetrics. Our main metric of performance is the wall-clock time required to achieve a given training accuracy. As in Section 5, we measure the statistical efficiency, which is the number of iterations needed to achieve a given training accuracy.\nCompetitor Systems and Experiment Settings. We compare Omnivore against a range of existing tools using both a single-machine and multiple machines. Single machine: we compare Omnivore to Caffe [16] and Google\u2019s TensorFlow [1], the two most popular CNN systems, using Caffe\u2019s\n3 https://blogs.nvidia.com/blog/2015/03/17/digits-devbox/ 4 https://github.com/BVLC/caffe/tree/master/models/bvlc_ reference_caffenet\nreference (CaffeNet) model. Multiple machines: we compare Omnivore to MXNet [5] and SINGA [25], two popular distributed deep learning systems.5 Both MXNet and SINGA support multiple execution strategies, and we consider all of these strategies in our experiments. We set up and tune both systems according to their tutorials. On data sets where SINGA performs strictly worse than MXNet, we omit its result from the figure.\nOmnivore is implemented in C++ and uses ZeroMQ to handle networks. Caffe, TensorFlow, MXNet, and SINGA all implement their core components in C++. We compile all systems with g++ 4.8.2, and use OpenBLAS 0.2.15, cuda 7.5, as well as both cuDNN v3 and v4 for competitor systems and report the faster result."}, {"heading": "6.2 Performance Evaluation", "text": "We validate that Omnivore has faster execution to the same quality as existing systems in training deep learning models. More precisely, Omnivore achieves the same training accuracy/loss faster, as measured by wall-clock time. We first present our main end-to-end performance results, comparing Omnivore to the state of the art. Then, we validate our contributions by showing results (i) for a single machine comparing to Caffe and TensorFlow and (ii) in the distributed setting comparing to MXNet and SINGA. We evaluate the impact of our tradeoff space and optimizer in Section 6.3.\n6.2.1 End-to-end Performance For large datasets, Omnivore is faster than state-of-the-\nart tools. We validate this on ImageNet, the de facto deep\n5 We also surveyed a range of distributed training systems including SparkNet, DL4J, and others, discussed in Appendix D.3. We found that MXNet is the fastest system on our datasets/tasks. At the time of writing, the official version of Caffe can only run on a single machine, and TensorFlow does not contain a distributed example for AlexNet/CaffeNet.\nlearning benchmark. We compare Omnivore with MXNet and SINGA. We train the standard CaffeNet on all systems using both CPU-L and GPU-S clusters. We time out each run after 8 hours and report the training accuracy at a given time. We tune all competitor systems following the official performance tuning guideline6. (We describe the full setting in Appendix F. The time for this tuning of other tools exceeds Omnivore\u2019s automatic tuning time for the cold start phase so we omit these initial tuning times). For Omnivore, we use its automatic optimizer that does not require any hyperparameters. Because SINGA is always slower than MXNet in our experiments, we omit it from this figure but discuss SINGA more in Section 6.2.3.\nFigure 10 shows the result. We report sync and async for MXNet as their documentation suggests trying both. Omnivore reaches the same accuracy up to 11\u00d7 faster than MXNet on the GPU cluster and 12\u00d7 faster on the CPU cluster. Compared to sync, Omnivore is 4.5\u00d7 and 1.9\u00d7 faster respectively. This includes the 10% overhead of Omnivore\u2019s optimizer during the run. The optimizer reduces momentum or learning rate each time it runs (full details in Appendix F.5). In the remainder of this section we conduct detailed analysis of Omnivore, MXNet, and SINGA to understand this improvement. As we will see, Omnivore\u2019s optimizer, which searches within the larger tradeoff space, is the key reason for our system\u2019s performance.\n6.2.2 Single Machine Experiments We validate our claim that Omnivore\u2019s performance is\nFLOPS-proportional, which means it scales with available FLOPS, regardless of the number or type of devices available. We first explain the protocol of our experiments. Then we report our results and discuss the importance of FLOPSproportional system performance.\nProtocol. We compare Omnivore against Caffe and Tensorflow on a single machine. We train CaffeNet on the full ImageNet dataset on hardware described in Figure 9. We measure the time each system needs to finish 40 iterations of training (following 10 iterations of warm-up), using the standard batch size in CaffeNet (256 images). Our single-machine optimizations only affect hardware efficiency; the number of iterations needed for convergence does not change. Hence, we can use time per iteration as a surrogate for performance.\n6 https://github.com/dmlc/mxnet/tree/ db6f6a9418e5696b04be741a78a47ae877bb5505/example/imageclassification and previous work [3, 17]\nResults. Figure 11 shows the results. We normalize all execution times by the slowest system in each column and report the resulting speedups. We see that on a single CPU, Omnivore is 3.9\u00d7 faster than both Caffe and TensorFlow; on a single GPU, all systems show similar speed. This is consistent with our observation in Section 3.2: TensorFlow and Caffe use the same strategy for both CPU and GPU, which is optimal for GPU but suboptimal for CPU. One interesting consequence of this speedup result is that, although Caffe on 1xCPU is 7\u00d7 slower than on 1xGPU, Omnivore is only 1.8\u00d7 slower on 1xCPU, which we will see matches the FLOPS ratio of these devices. The gap increases for more CPU sockets (2xCPU) or GPU cards (4xGPU).7\nFLOPS Proportionality. The training performance of CPUs is commonly believed to be an order of magnitude slower than GPU performance. Literature often reports so; we also see that this is the case for Caffe on 1xCPU and 1xGPU. We validate that Omnivore delivers performance proportional to the FLOPS that a device can provide. As shown in Figure 9, 1xGPU provides 1.7\u00d7 more FLOPS than 1xCPU, and Omnivore has a 1.8\u00d7 gap between 1xCPU and 1xGPU. In other words, regardless of the type of device, Omnivore performs proportionally to the number of FLOPS available. We also observe that proportionality holds for all machines in Table 9; details are deferred to Appendix C.5. FLOPS-proportionality means that, using both CPUs and GPUs on the same machine, we should be able to construct an even faster system. We validate this by using both CPUs and GPUs on 4xGPU, whose CPU and GPU provides 0.67 TFLOPS and 4.89 TFLOPS, respectively. By using data parallelism across the CPU and a single GPU, Omnivore achieves an 18% speedup over just using the GPU.\n6.2.3 Distributed Experiments We now conduct experiments to understand our end-to-\nend improvement across three different clusters described in Figure 9. As we will show, our tradeoff characterization contributes to the performance gains of Omnivore. We first describe the settings and the performance metric used in the experiments. Then we discuss the optimizer\u2019s contribution and analyze across different clusters.\nProtocol. A systematic understanding of the performance gap between Omnivore, MXNet, and SINGA requires running multiple systems to convergence under multiple settings. For this reason, we focus on ImageNet8 that contains\n7 We also run experiments on a 4-socket, 56-core Haswell CPU machine, and Omnivore is 13\u00d7 faster than Caffe.\nthe first eight classes of ImageNet. This allows us to grid search all parameters in MXNet and SINGA, including synchronization strategies and learning rate, and pick the best run. Because the goal of this section is to understand the difference of training performance, we do not include the time of our optimizer, which also takes significantly less time compared with the grid search we did for MXNet and SINGA. We run all systems for 2 hours and measure the training accuracy at a given time. Figure 12 shows the results.\nResults. (Small CPU Cluster: CPU-S) CPU-S is a small CPU cluster that contains 9 1xCPU machines. Because each machine is slow and the network is fast, we expect that a fully synchronous strategy will be fast in terms of hardware efficiency while having the best statistical efficiency. Figure 12(a) shows the results. All systems reach accuracy 60% within 2 hours, and Omnivore reaches 60% the fastest. Omnivore is 2.3\u00d7 faster than MXNet (388 seconds vs. 907 seconds). At 3000 seconds, Omnivore already achieves an accuracy > 99%, while MXNet achieves the same accuracy after 7000 seconds. The speed up here is also 2.3\u00d7. As expected, both systems chose a fully synchronous strategy, so statistical efficiency is not the cause of this performance gap. The 2.3\u00d7 speed up is due to our CPU-based optimization (Section 3) and merging FC servers (Section 5.1).8\n(Small GPU Cluster: GPU-S) GPU-S is a small GPU cluster that contains 9 4xGPU machines (36 GPUs). In this case, because each node is significantly (7\u00d7) faster than 1xCPU, we expect the optimal strategy to be more asynchronous, and thus, statistical efficiency to come into play. Figure 12(b) shows the result.9 Similarly to the CPU-S cluster, Omnivore outperforms MXNet: it reaches 99% accuracy 4.8\u00d7 faster. MXNet only supports completely synchronous or asynchronous execution, and its optimal run uses the completely synchronous strategy. On the other hand, Omnivore\u2019s optimizer chooses to run with two compute groups. Had Omnivore chosen the same strategy as MXNet, it would be 1.7\u00d7 slower than Omnivore\u2019s actual choice due to a different choice of the synchronization strategy. The remainder of the 4.8\u00d7 gap is due to the physical mapping (merging FC) used by Omnivore, and this improves both HE and SE: while originally described as a mechanism to reduce network communication [7], we find that merged FC also improves SE by reducing staleness in the FC model.\n8 SINGA does not converge to 99% in 2 hours and Omnivore is 11\u00d7 faster than SINGA to reach 60% accuracy. 9\nAs of the time of writting, SINGA does not support GPUs and is omitted from Figure 12(b).\n(Large CPU Cluster: CPU-L) CPU-L is a large CPU cluster that contains 33 1xCPU machines. Because the number of machines is large, we expect the synchronization across all machines would incur a large penalty in terms of hardware efficiency\u2014therefore, we expect that the optimal strategy should be more asynchronous. Figure 12(c) shows the result. We see that Omnivore is 3.2\u00d7 faster than MXNet to reach 99% accuracy. The best MXNet strategy was to train completely synchronously; Omnivore\u2019s optimizer now chose four compute groups. Had Omnivore chosen the same strategy as MXNet, it would incur 5\u00d7 overhead for HE compared to its actual choice but only gain a 2\u00d7 benefit for SE. Also, had Omnivore simply chosen a fully asynchronous configuration, it would be 3\u00d7 slower than its actual choice. This shows the importance of choosing the right number of groups to balance both SE and HE.\nImpact of Optimizer. In the experiments above, we use grid search to find the optimal strategy for both MXNet and SINGA. On the other hand, Omnivore relies on the optimizer to automatically choose the best strategy. Had we not used the grid search for MXNet and relied on default parameters the performance gap would be 20\u00d7 on ImageNet8. This is compared to MXNet\u2019s completely asynchronous strategy, which is recommended in their performance tuning guideline for networks like AlexNet. We study this in more detail in Appendix F.3.\nComparison across Clusters. Omnivore\u2019s optimizer makes different choices on different clusters. It is interesting to compare them. As we can see, given the same amount of machines (CPU-S vs. GPU-S), as devices get faster, Omnivore tends to choose more asynchronous strategies. Intuitively, the faster compute nodes get, the easier for the network to get congested. The fully synchronous approach incurs higher penalty in that case. On the other hand, given the same speed of each compute node (CPU-S vs. CPUL), when the number of machines gets larger, Omnivore also tends to choose a strategy that is between a fully synchronous and a fully asynchronous strategy: (1) when the staleness gets very large, even a properly tuned, fully asynchronous strategy incurs a penalty in terms of statistical efficiency, and (2) when the number of machines that need to be synchronized gets larger, a fully synchronous strategy incurs a penalty in terms of hardware efficiency. Omnivore\u2019s optimizer makes it possible for us to be robust across different devices and cluster sizes."}, {"heading": "6.3 Tradeoff and Optimizer of Omnivore", "text": "We validate the hypothesis that (1) the tradeoffs studied in this paper and (2) the automatic optimizer have a significant impact on the performance of Omnivore. We study the importance of compute groups, as well as compute-groupspecific momentum tuning. We also study the effectiveness of Omnivore\u2019s automatic optimizer for this tradeoff space by comparing it against a standard Bayesian optimizer.\n6.3.1 The Tradeoff Space In this section we demonstrate that the various dimensions\nof the tradeoff space have a significant impact on performance. Throughout this paper we already illustrated some of these tradeoffs, so here we only summarize them and leave the detailed discussion Appendix F.3. In Section 6.2.3 and\nSection 5.1, we showed that tuning the learning rate is necessary for convergence and that the physical mapping has both HE and SE benefits. In Section 6.2.3, we showed that using the right number of compute groups can yield 6.3\u00d7 speedups compared to fully synchronous and 1.6\u00d7 compared to fully asynchronous execution. We now focus on the importance of properly tuned momentum, which as we prove in Section 4.2, is a function of the level of asynchrony.\nImportance of Momentum Tuning. We validate that the correct value of momentum depends on the number of groups. We expect that properly tuned momentum would outperform a momentum tuned agnostically to the number of compute groups. Therefore, we compare different methods of momentum tuning on the optimal number groups for ImageNet8 on CPU-L. The optimal number of groups for ImageNet8 on CPU-L is 4. We fix that number of groups and (i) set momentum to 0.9 (as reported in AlexNet [17]); (ii) use the momentum tuned for a synchronous system; (iii) tune the momentum using Omnivore\u2019s optimizer for 4 compute groups. As we see in Figure 13, tuning for the right amount of asynchrony is important: if Omnivore did not tune momentum, it would be 1.5\u00d7 slower. This both verifies our expectations for this experiment and provides further support for our theory in Section 4.2.\nDiscussion: Other Models. We find that these tradeoffs are impactful when applied to other models. We find that for Recurrent Neural Network models and LSTM models (e.g., [11]), the same choices affect performance\u2014for example, choosing a completely synchronous or asynchronous configuration can be up to 2\u00d7 slower than the optimal configuration. We report the details in Appendix F.6. This could imply speedups for applications in which RNNs are widely used, such as hand writing, speech recognition, and general sequence or time-series data.\n6.3.2 Optimizer We validate that our optimizer outperforms state-of-the-\nart Bayesian optimization algorithms. We compare our optimizer with the optimizer proposed by Snoek et al. [22], which requires knowledge of the number epochs to run. To be fair we give the Bayesian Optimizer this information. We measure both the number of configurations and the total number of epochs that the Bayesian optimizer needs to achieve an accuracy within 1% of the configuration with the highest accuracy after 1000 seconds. In our experiments, the Bayesian optimizer never discovers a configuration which outperforms the optimal configuration obtained by grid search. We report the detailed result in Appendix F.8. We found that\nthe Bayesian optimizer takes 12 runs to find a near-optimal strategy, which on average is 6\u00d7 more epochs than running that strategy. Because of this search overhead it was not feasible to use the full ImageNet 1000 dataset so we used ImageNet8 (whereas recall from Figure 10 than Omnivore had an overhead of only 10% on ImageNet 1000). We used the GPU-S cluster. Typically Bayesian optimizers can amortize this cost by running in parallel, but here that is not possible as the parameters depend on the hardware configuration and so the optimizer needs complete access to the entire cluster."}, {"heading": "7. RELATED WORK", "text": "Single Node. Optimizing CNN performance has become a well-studied problem in recent years. Popular libraries include Caffe [16], cuDNN [6], TensorFlow [1], Theano [2], and Torch10. To compute convolutions, many of these frameworks use lowering, an idea proposed by Chellapilla et al. [4] that takes advantage of highly-optimized BLAS libraries. Our work follows from this line of research and demonstrates how to optimize lowering for CPUs in order to build a system which is robust to different types of hardware.\nDistributed Deep Learning. Distributed systems for Deep Learning is a popular topic including SINGA [25], MXNET [5], FireCaffe [15], SparkNet [19], DL4J11, Google\u2019s DistBelief [8], and Microsoft\u2019s Project Adam [7]. Each selects different execution strategies and other optimizations. A contribution of our study is to show a combined tradeoff space including the union of all these techniques. We did this by decoupling the hardware and statistical efficiency for each technique and optimizing these separately. Our work is the first to provide a theoretical characterization for statistical efficiency and to demonstrate that hyper-parameters need to be adjusted in order to compensate for asynchrony.\nThe idea of splitting number of iterations and time per iteration and analyzing each separately is not new for distributed CNN systems. MXNet reported hardware efficiency and statistical efficiency separately, providing a plot of accuracy vs. iteration which was decoupled from the time per iteration. SINGA also decoupled these, and also went deeper into the tradeoff, identifying the compute group size as a tunable parameter. They advocate combining both synchronous and asynchronous training and offer a flexible training architecture which enables trading off the convergence rate with the time per iteration in order to to minimize training time. However, while SINGA identifies this tradeoff and provides experimental evidence of its importance similar to the curves we showed, the onus is currently on the user to manually select the optimal configuration.\nSparkNet also separated the time per iteration and number of iterations by building models of each. They did not explore the same tradeoff of machines per group, but rather a similar tradeoff related to staleness. Because SparkNet uses a MapReduce framework they implement model averaging (see terminology section in Appendix D.2). Within this technique they explore, in isolation, how the staleness (their \u03c4 parameter) impacts the number of iterations to convergence and the time per iteration. Their hardware efficiency model was measured (both network speed and compute time) and their statistical efficiency model was also empirical (they varied staleness and measured the SE penalty).\n10 http://torch.ch/ 11 http://deeplearning4j.org/"}, {"heading": "8. CONCLUSIONS", "text": "We described the first explicit study of the tradeoff space for deep learning systems, a popular, high-value type of industrially deployed learning systems. We identified critical issues in how one maps layers to devices and are the first to systematically study widely used techniques like asynchrony. We designed a new optimizer and showed that it has excellent end-to-end performance and is independent of our particular implementation substructure."}, {"heading": "9. ACKNOWLEDGEMENTS", "text": "The authors would like to thank Dan Iter, Chris Aberger and the rest of the Hazy Group for their feedback and help, as well as HyoukJoong Lee, Nadathur Rajagopalan Satish, Peter Bailis and Benjamin Recht for their thoughtful comments. We would like to thank Intel, Toshiba and the Moore Foundation for support along with DARPA through MEMEX (FA8750-14-2-0240), SIMPLEX (N6600115-C-4043), and XDATA (FA8750-12-2-0335) programs, and the Office of Naval Research (N000141210041 and N000141310129). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA, ONR, or the U.S. government."}, {"heading": "10. REFERENCES", "text": "[1] Abadi et al. TensorFlow: Large-scale machine learning on\nheterogeneous distributed systems. arXiv, 2015.\n[2] J. Bergstra et al. Theano: a CPU and GPU math expression compiler. In SciPy, 2010. [3] L. Bottou. Stochastic gradient descent tricks. In Neural Networks: Tricks of the Trade (2nd ed.). Springer, 2012. [4] K. Chellapilla et al. High performance convolutional neural networks for document processing. ICFHR, 2006. [5] T. Chen et al. Mxnet: A flexible and efficient machine learning library for heterogeneous distributed systems. arXiv, 2015. [6] S. Chetlur et al. cuDNN: Efficient Primitives for Deep Learning. ArXiv, 2014. [7] T. Chilimbi et al. Project adam: Building an efficient and scalable deep learning training system. In OSDI, 2014. [8] J. Dean et al. Large scale distributed deep networks. In NIPS, 2012. [9] J. Deng et al. ImageNet: A large-scale hierarchical image database. In CVPR, 2009.\n[10] L. Deng and D. Yu. Deep learning: Methods and applications. FTSP, 2014. [11] A. Graves. Generating sequences with recurrent neural networks. arXiv, 2013. [12] D. Gross. Fundamentals of queueing theory. John Wiley & Sons, 2008. [13] S. Hadjis et al. Caffe con Troll: Shallow ideas to speed up deep learning. In DanaC, 2015. [14] K. He et al. Deep residual learning for image recognition. In CVPR, 2016. [15] F. N. Iandola et al. FireCaffe: near-linear acceleration of deep neural network training on compute clusters. arXiv, 2015. [16] Y. Jia et al. Caffe: Convolutional architecture for fast feature embedding. ArXiv, 2014. [17] A. Krizhevsky et al. ImageNet classification with deep convolutional neural networks. In NIPS, 2012. [18] I. Mitliagkas et al. Asynchrony begets momentum, with an application to deep learning. arXiv:1605.09774, 2016. [19] P. Moritz et al. SparkNet: Training deep networks in Spark. arXiv, 2015.\n[20] F. Niu et al. Hogwild!: A lock-free approach to parallelizing stochastic gradient descent. In NIPS, 2011. [21] A. E. Raftery, S. Lewis, et al. How many iterations in the gibbs sampler. Bayesian statistics, 1992. [22] J. Snoek, H. Larochelle, and R. P. Adams. Practical bayesian optimization of machine learning algorithms. In NIPS, 2012. [23] I. Sutskever et al. On the importance of initialization and momentum in deep learning. In ICML, 2013. [24] N. Vasilache et al. Fast Convolutional Nets With fbfft: A GPU Performance Evaluation. ArXiv, 2014. [25] W. Wang et al. SINGA: A distributed system for deep learning. Technical report, NUS Tech Report, 2015. [26] X. Zhang and Y. LeCun. Text Understanding from Scratch. ArXiv, 2015."}, {"heading": "APPENDIX", "text": ""}, {"heading": "A. APPENDIX FOR INTRODUCTION (SECTION 1)", "text": "Tradeoff Table. While many distributed deep learning systems exist, each of these makes design decisions suited for a particular type of (1) compute cluster, (2) deep learning model and (3) dataset, although these same decisions may not work for other problem settings or hardware resources. This is because deep learning is known to be complex both from a computational and machine learning perspective, and designing a highly efficient and scalable deep learning engine involves a number of interrelated design decisions. Table 1 shows a number of factors to consider when designing distributed deep learning systems. Given a fixed number of machines, a number of tradeoffs exist from how to use hardware on each node, to how to allocate batches of data to machines, to the type of deep learning model to use in order to minimize communication. In addition, these decisions impact one another \u2013 for instance the batch size influences the number of machines which can be used to effectively parallelize within a batch and therefore influences the total number of parallel gradients being computed to update the model. Our work, which is a study, demystifies these factors by identifying the key tradeoffs which underlie all design decisions and quantifying the impact of those tradeoffs experimentally.\nContribution 1: Single-Node Optimization Even focusing on just a single node, there has been a long debate about CPUs vs GPUs for deep learning. GPUs are popular for CNN systems because of the high throughput they provide. Modern GPUs offer between 1.2 TFLOPS (NVIDIA GRID K520, per GPU) and 8 TFLOPS (NVIDIA\nTitan Z). However, GPUs contain smaller off-chip memories than CPUs, and GPUs are connected to host memory by a slow PCI-e interconnect. On the other hand, Microsoft\u2019s Project Adam argues that CPUs can deliver more costeffective performance [7].12 This debate is only going to get more interesting, as modern GPUs offer high-speed interconnect with host memory13 while Intel\u2019s current Haswell CPU can achieve 1.4 TFLOPS on a single chip.14. Moreover, SIMD parallelism has doubled in each of the last four Intel CPU generations and is likely to continue.15\nB. APPENDIX FOR BACKGROUND (SECTION 2)"}, {"heading": "B.1 CNN Computation", "text": "AlexNet FLOPS. We approximate the FLOPs (# floating point operations) in AlexNet by the sum of all the GEMM operations with batch size 256. Specifically, we add 1 GEMM in the forward pass for each Conv and FC layer, plus two GEMMs in the backward pass for each Conv and FC layer (although Conv1 backward has only 1 GEMM because no gradient is needed with respect to the data).\nTerminology. This section introduces model and data parallelism as two techniques to parallelize CNNs. For a full description of these concepts, see the Terminology in Appendix D.2.\nCNN Trends. This section viewed CNNs as two phases, Conv and FC. Recent CNNs, e.g. Residual Networks (ResNets) and Inception Networks, can also be categorized into this partitioning. For instance early Inception variants contained multiple FC layers at different parts of the network, but from a computational point of view these are all considered to be part of the FC phase.\nIn particular, CNNs have undergone a number of changes in the past few years16. We summarize a few here:\n\u2022 Multiple FC layers replaced with average pooling, leaving a single fully-connected layer (for the softmax). This leads to a reduction in the overall model size (e.g. 60 million parameters for AlexNet compared to 4 million for GoogleNet)\n\u2022 Increase in network depth (e.g. AlexNet with 5 conv layers, compared to ResNets17) with > 150. This increases memory requirements of networks, and makes multi-device training necessary.\nAs we will see, the optimizer presented in this paper considers the impacts of each of these points when making decisions for physical mapping and execution strategy.\n12 http://www.wired.com/2014/07/microsoft-adam/ 13 http://nvidianews.nvidia.com/news/nvidia-launches-world-s-\nfirst-high-speed-gpu-interconnect-helping-pave-the-way-to-\nexascale-computing 14\nXeon E5-2698 v3, http://ark.intel.com/products/81060 15\nSIMD scales linearly in power and area (whereas frequency scaling is cubic) http://parasol.tamu.edu/lcpc2014/keynote-tian.pdf.\n16 http://cs231n.github.io/convolutional-networks/#case 17 https://github.com/KaimingHe/deep-residual-networks"}, {"heading": "B.2 Problem Definition", "text": "Scope of Work. Our work does not focus on improving machine learning techniques but rather studies systems tradeoffs in order to build an optimizer that is robust to the most widely used networks/algorithms. Our study uses the SGD algorithm due to its popularity, although our optimizer applies to other algorithms as well. Similarly we do not modify the CNN architecture but assume that this is provided by the user.\nTerminology. The physical mapping maps the layer computation to vertices in G. Vertices in G may contain other vertices, e.g. GPUs or CPU cores within a machine. Section 3 first studies how to map the CNN to hardware within a machine, and concludes that with proper optimization only the throughput of each vertex matters, not its underlying hardware. Section 4 then studies how to map the CNN to all of G, i.e. across machines."}, {"heading": "C. APPENDIX FOR SINGLE-NODE TRADEOFFS (SECTION 3)", "text": "This section describes the optimizer\u2019s physical plan (how to map the CNN to hardware) at the level of a single machine. Given a machine containing devices of various throughput (CPUs, GPUs), our goal is to run the CNN computation as quickly as possible. We do this by identifying two tradeoffs. Our first tradeoff introduces a data batching technique which trades off memory footprint for compute time. We demonstrate that this tradeoff gives a > 5\u00d7 CPU speedup over existing systems. With this optimization now both CPUs and GPUs give throughput proportional to the FLOPS offered by the device, and our second tradeoff partitions the CNN computation across both the CPU and GPU to combine their FLOPS \u2013 a known HPC trick, but one which has not been applied to CNNs."}, {"heading": "C.1 Convolutional Layer Computation", "text": "A 3D convolution consumes a pair of order 3 tensors\u2013the data D \u2208 Rn\u00d7n\u00d7din and the kernel K \u2208 Rk\u00d7k\u00d7din . For example, if D is a color image with 3 (RGB) color channels, din = 3. In AlexNet [17], n \u2208 [13, 227], k \u2208 [3, 11], and din \u2208 [3, 384], The output is a 2D matrix R \u2208 Rm\u00d7m where m = n\u2212 k + 1 and each element Rx,y is defined as:\nRx,y = din\u22121\u2211 d\u2032=0 k\u22121\u2211 x\u2032=0 k\u22121\u2211 y\u2032=0 Dx\u2212 k 2 +x\u2032,y\u2212 k 2 +y\u2032,d\u2032Kx\u2032,y\u2032,d\u2032 (8)\nThe kernel also supports parameters called padding and stride, which affect the size of m. For details on stride and padding see http://cs231n.github.io/convolutionalnetworks/#conv.\nThis is the standard image 3D discrete convolution. A convolution layer in the CNN contains a number of kernels {Kj}, not just one, where we call dout = |Kj | the number of output channels. These kernels {Kj} constitute the model of the convolutional layer, and the reason for computing multiple kernels rather than just 1 in the convolutional layer is to a more powerful machine learning model. The convolutional layer takes as input the 3D data tensor D and performs dout 3D convolutions, one per {Kj}, such that the output of the\nconvolutional layer is now not a 2D matrix R but a 3D tensor R \u2208 Rm\u00d7m\u00d7dout . Similarly the model of the CNN can be viewed as a 4D tensor K \u2208 Rk\u00d7k\u00d7din\u00d7dout .\nFinally, recall that often rather than process a single data example the CNN processes a batch of b examples simultaneously. The motivation for doing this is that gradient computations during learning are less noisy. Therefore in the most general case, the input D to a convolutional layer is not 1 but b 3D data tensors, or equivalently a 4D data tensor D \u2208 Rn\u00d7n\u00d7din\u00d7b. The model is unchanged, but the convolutional layer now performs the dout 3D convolutions on each example in the batch, i.e. the batched convolution layer performs b\u00b7dout 3D convolutions. The output of the convolutional layer is therefore also a 4D tensor, R \u2208 Rm\u00d7m\u00d7dout\u00d7b.\nTo summarize, a convolutional layer accepts as input a 4D data tensor D \u2208 Rn\u00d7n\u00d7d\u00d7b, performs a total of b \u00b7 dout 3D discrete convolutions using D and its model K \u2208 Rk\u00d7k\u00d7din\u00d7dout , and outputs a 4D output data tensor R \u2208 Rm\u00d7m\u00d7dout\u00d7b. The full formula is:\nRx,y,z,w = din\u22121\u2211 d\u2032=0 k\u22121\u2211 x\u2032=0 k\u22121\u2211 y\u2032=0 Dx\u2212 k 2 +x\u2032,y\u2212 k 2 +y\u2032,d\u2032,wKx\u2032,y\u2032,d\u2032,z\nMany implementations of this convolutional layer exist. Like most other HPC kernels, a straightforward implementation of this operation is suboptimal. Optimized implementations include directly computing the convolutions, as in cuda-convnet2,18, computing the convolution as a discrete Fourier transform as in [24], or implementing the convolution as a matrix multiply, as in Caffe [16] or cuDNN [6].\nWhile the studies in these papers conclude that different strategies perform best for different kernel sizes, cuDNN [6] demonstrates that the third technique of performing convolution as a matrix multiplication is versatile and fast for a range of size parameters, as matrix multiplication kernels are often highly optimized.\nIn order for the convolution to be carried out as a matrix multiplication, an initial reformatting phase called lowering is required to put the data and kernel into the correct format, which we discuss in the next subsection of this appendix.\nC.1.1 Convolution by Lowering and GEMM Lowering followed by a general dense matrix multiplica-\ntion (GEMM) is a popular way to implement the convolution operation. Figure 2 shows the three logical steps in the lowering process: (1) lowering, which transforms 4D tensors\nD and K into 2D matrices D\u0302 and K\u0302; (2) matrix multiply\n(GEMM), in which we multiply D\u0302K\u0302 to get the result R\u0302;\nand (3) lifting, which transforms R\u0302 back to a tensor representation of R.\nLowering Phase in which we construct the matrix D\u0302 and K\u0302. A value of D will appear more than once in the lowered matrices.\nMultiply Phase (GEMM) in which we multiply D\u0302 and\nK\u0302 to create R\u0302 = D\u0302K\u0302.\nLifting Phase in which we map R\u0302 back to R.\nThree techniques exist to perform this process, each corresponding to a different way to group the sum in Equation 8. Each of these techniques requires replicating the data or the kernel in order to allow the convolution to be implemented\n18 https://code.google.com/p/cuda-convnet2/\nas a GEMM, but the amount of replication and the size of the GEMM depend on whether the replication happens in the lowering phase, lifting phase, or partly in each. The tradeoff is studied in detail by [13], which concludes that the best choice is determined entirely by the ratio din/dout (the ratio of the number of input channels to the number of output channels of the convolution), and that for modern CNNs these ratios suggest that the data replication should be done during the lowering phase. Therefore in the lowering used by this work, there are two components to convolution: lowering (which requires replication of data), and the GEMM. The lifting does not require any memory copies or computation in the optimal technique. Note also that in this technique, the kernel does not require any replication, only the data. CNNs are continuously evolving however, and so it is possible that future CNN architectures will benefit from other lowering strategies. For a full study of the lowering tradeoff, refer to [13].\nThe amount of data replication required by the lowering in this work is m2k2/n2, where m < n and m depends on the stride and padding of the convolution. The replication can be on the order of 1 to 2 orders of magnitude (i.e. 10\u2212 100\u00d7 more data). In turn, this blowup in the data size requires more memory and computation in step 2 (GEMM). The benefit however is that a sparse computation has become dense, which is important for hardware implementations because the direct computation of the 3D convolution is usually memory bandwidth-bound (due to the small convolution window size, k \u2208 [3, 11]). A GEMM implementation on the other hand, while performing more computation as a result of lowering, receives hardware acceleration which eclipses the increase in data size."}, {"heading": "C.2 Batching and Data Parallelism", "text": "C.2.1 Batching Analysis Batching is the implementation tradeoff that arises be-\ntween the CPU and GPU as a result of available off-chip memory. It concerns how many images of the batch to process in parallel by the convolution layer. Recall that bp images are processed in parallel, where where 1 \u2264 bp \u2264 b. b is the batch size, i.e. the total number of images that need to be processed. The value of bp (how much to batch the convolution computation) is determined by how many lowered images can be stored in off-chip memory.\nModern GPU cards cannot store entire batches of lowered data into off-chip memory and implementations of CNNs on GPUs perform lowering and GEMM serially on one or few images at a time until all b have been processed, i.e. bp = 1. On the CPU, off-chip memory is larger which allows for batching techniques that perform lowering and GEMM on all images in parallel and therefore allow CPU caches and vector instructions to be fully utilized. This tradeoff is continuing to evolve however, as newer GPU cards contain more off-chip memory (e.g. 12 GB in the Titan X), and also use new implementations which perform lowering and GEMM without having to materialize the intermediate lowered representation, as described by [6]. Therefore we believe that this tradeoff will grow in importance.\nFor example bp = 1 in Caffe [16]: in order to process b images in a batch, Caffe performs convolution on one image at a time, i.e. lowering/GEMM is done serially for each image in the batch (lower one image, run GEMM, lower the\nnext image, etc.) This has the smallest possible memory footprint as it only maintains the lowered matrix of a single image in memory, and is the preferred strategy for devices with limited memory. Figure 4(c) showed that the memory footprint for the convolution is directly proportional to bp.\nComputationally however, Figure 4 (b) showed that bp = 1 suffers from lower hardware utilization. This figure was run for the GEMM in the Conv2 layer of Alexnet (although we observed similar trends for other Conv layers). Specifically the matrix D\u0302 is \u201cB\u201d in the GEMM operation A \u00d7 B, and increasing bp increased the number of columns in D\u0302.\nIn Figure 4 (b) we fix the number of threads to 8, vary bp, and plot the speedup normalized to bp = 1. Increasing bp reduces the number of total GEMM calls, and this gives a 2\u00d7 overall speedup for bp = 256 compared to bp = 1. This is because a small bp means that D\u0302 becomes thinner. For thinner matrices, possible partition sizes of the underlying GEMM algorithm are smaller and so the kernel cannot run optimally, for example the L2 and L3 caches cannot be filled during blocking optimizations. As a result bp = 1 is more likely memory-bandwidth-bound than higher batch sizes (and this phenomenon is likely more severe when the GEMM kernel is executed with multiple threads.) Also note that Figure 4 was run on a CPU machine with 8 physical cores. Regarding Figure 4 (a), the reason that 16 threads was slightly slower than 8 is that we hit the memory bandwidth bottleneck.\nFor modern CPUs, memory is large and so b = bp. We use b = bp for the remaining CPU experiments in this section.\nC.2.2 Data Parallelism in non-GEMM Kernels On the CPU, recall that the batching technique above\nmakes a single matrix that is b times (full batch size) larger than it would be for a single image, and then performs a single GEMM on this large matrix. A related strategy is to split a batch into multiple partitions, and process each partition in parallel using a separate thread.\nFor GEMM, processing an entire batch of size b with n threads is equivalent to partitioning the batch into p partitions of size b/p with n/p threads used in each GEMM. For example, batching b images and performing a single GEMM with 8 threads is equivalent to creating 8 matrices, each with b/8 images, and performing 8 parallel GEMM kernels with 1 thread each. These are equivalent as this is exactly how BLAS parallelizes GEMM: by partitioning partition columns of B in A \u00d7 B and allocating 1 thread per partition.\nWhile partitioning and then performing the GEMM kernel is the same as simply performing the GEMM kernel, this is not true for other kernels which are not multi-threaded For non-GEMM kernels such as lowering, or other layers such as pooling, the second technique of partitioning the batch and processing each partition using a separate thread gives significant speedups (this is simply data parallelism) across all cores. For example, it can be used to lower images in parallel using all cores by assigning a subset of the images in the batch to each core.\nFigure 14 shows the impact of data parallelism on a full end-to-end CaffeNet on the EC2 c4.4xlarge instance with 8 physical cores (CPU only). The batch size used is 256 images and the horizontal axis represents into how many parallel partitions we partitioned these 256 images for each layer of the CNN. I.e. the horizontal axis is the number\nof threads used for data parallelism. Note that the GEMM kernel is always parallelized (OpenBLAS was used) and uses the maximum number of threads (16).\n\u201cNone\u201d indicates the default Caffe implementation. For all layers, each image is processed serially. For example, one image is lowered, then the convolution GEMM is performed, and then the next image is lowered, etc. The only multithreaded kernels are the BLAS GEMM kernels used in the convolution and FC.\n\u201c1\u201d is identical to the Caffe implementation except that lowering is first done for all images (serially, i.e. one image lowered at a time), and then a single, large GEMM is done for the convolution. All other layers are the same.\nFor all other number of parallel partitions p, the 256 images were equally split into p partitions. For example if p = 2, two partitions of size 128 images each were created. Then, layers processed each partition in parallel, one thread per partition. For example if p = 2, lowering was done with two threads, each lowering 128 images. Following the lowering, a GEMM was performed for each partition. The total number of threads used for these GEMM kernels was always 16, i.e. the GEMM is performed on each partition with 16/p threads per GEMM.\nFigure 14 (None vs 1) shows that batching the GEMM kernels (one large GEMM as opposed to 256 smaller ones) saves \u223c 2.2s of convolution time. Then, data parallelism provides another \u223c 10 s of reduction. The final time is then 4s, where \u223c 3s is spend in convolution layers. Therefore the batching of the GEMM made the convolution roughly \u223c 2\u00d7 faster (in the optimized execution), and the remaining speedups were due to data parallelism.\nFinally, studying more closely the speedups from data parallelism, the time reduction from 14 seconds to 4 seconds from data parallelism was roughly 80% due to speeding up the lowering, and 20% due to speeding up the other layers. I.e. the final iteration time would be \u223c 6s if data parallelism was only used for the Conv layers. The remaining 20% is for data parallelism in pooling, normalization, dropout and ReLU layers. Fully-Connected layers are simply a GEMM which always uses 16 threads, so data parallelism and model parallelism do not apply on the CPU, although as we also saw previously this GEMM can be made slightly faster by\nusing 8 threads instead for the FC layers (because there are 8 physical cores).\nOverall, batching combined with data parallelism gives more than a 4\u00d7 speedup end-to-end when running Caffe\u2019s AlexNet on 8 physical cores. Importantly, this end-to-end speed is now proportional to the peak throughput of the CPU.\nIn summary, we show two sources of speedup on the CPU. First, by batching the lowering and GEMM, we perform a single GEMM which is b\u00d7 larger, as opposed to b smaller GEMMs, which as described above has better hardware utilization on the CPU. Second, we apply the batch partition (data parallel) technique above to parallelize non-GEMM kernels such as lowering. These optimizations are possible for the CPU because it has more memory to store the lowered matrices. As a result the CPU performance is proportional to the device FLOPS, which allows partitioning computation across both the CPU and GPU proportional to the device throughput."}, {"heading": "C.3 Device Throughput", "text": "FLOPS Experiments. Figure 3 showed throughput for the CNN when using Caffe, Omnivore and also for reference a single-precision GEMM kernel. For the CPU the GEMM experiment used OpenBLAS and matrices of size 16384 \u00d7 16384. For the GPU GEMM we used a GEMM kernel from NVIDIA\u2019s CUDA examples. For Caffe and Omnivore we focus on only the Convolution layers, specifically the time to run forwards and backwards on all 5 layers of CaffeNet.\nFLOPS calculations. The c4.4xlarge instance contains a single-socket Haswell CPU with 8 physical cores. The c4.4xlarge instance CPU FLOPS are calculated as: 8 physical cores \u00d7 2.9 GHz \u00d732 = 0.742 TFLOPs, where 32 is the single-precision Haswell instructions per cycle (8-float SIMD \u00d7 2 FMA per cycle, and FMA is fused-multiply-add).\nEach g2.2xlarge instance provides a single Grid K520 GPU, i.e. 1536 cores \u00d7800 MHz = 1.23 TFLOPS (the Grid K520 contains a total of 3072 cores, 1536/GPU).\nThe c4.8xlarge instance contains a dual-socket Haswell CPU with 18 physical cores. The FLOPS are calculated as: 18 physical cores \u00d7 2.9 GHz \u00d732 = 1.670 TFLOPs."}, {"heading": "C.4 FLOPS-Proportional Scheduling", "text": "Given that both CPU and GPU speeds are now proportional to the device FLOPS, we next consider whether the CPU and GPU can be used simultaneously to process each layer. We do this using data parallelism (batch is partitioned, model is replicated) for all layers in the convolution phase, which is compute-bound and has small data. The tradeoff is what fraction of the batch to give to each device. We select the simple but optimal choice that a device should process a fraction p of the input where p is the proportion of total FLOPS which that device contributes. E.g. if a CPU provides 1 TFLOPS and a GPU 4 TFLOPS, 1/5 of the batch is processed by the CPU for an ideal speedup of 20% over the GPU alone."}, {"heading": "C.5 Single-Node Experiments", "text": "Omnivore matches Caffe\u2019s output on each layer. It accepts the same input files as Caffe and produces the same\noutputs. Our experiments compare against Caffe and use the CaffeNet19 CNN, which is Caffe\u2019s implementation of the popular AlexNet (the default architecture for benchmarking), as well as the ImageNet dataset.\nBoth systems take as input the same network configuration files that Caffe provides. We remove grouping for convolution layers because the full AlexNet fits in the memory of a single K520 (g2.2xlarge) GPU. We use the same external libraries for both Caffe and Omnivore: GCC-4.8, CUDA7.5, and OpenBLAS. For Caffe we report both cuDNN v3 and v4.\nWe built the same timer into Caffe and Omnivore (measuring wall-clock time, clock gettime in C). We run for 50 iterations and omit the first 10 in case there are disk or other delays in the first few iterations not representative of steady-state execution. Beyond these first 10 iterations we noticed that all iterations were consistent in terms of time for both tools and had a coefficient of variation less than 5%.\nWe also ran Tensorflow using the same protocol as above (40 iterations, burn-in of 10, identical network).\nC.5.1 End-to-end Performance Figure 15 shows the results of running Omnivore and Caffe\non various EC2 instances. Given that Omnivore and Caffe generate the same outputs, we concentrate on throughput. We ran both Omnivore and Caffe on each EC2 instance for 50 iterations, and counted the last 40. On the c4.4xlarge CPU instance Omnivore outperforms Caffe by nearly 4\u00d7 due to batching and data parallelism. On the g2.2xlarge GPU instance Omnivore and Caffe achieve the same speed\n19 https://github.com/BVLC/caffe/tree/master/models/bvlc_\nreference_caffenet\n(within 5%). Note that the c4.4xlarge instance offers 60% of the FLOPS of the g2.2xlarge instance, and the ratio of Omnivore speeds on these instances is 59%, i.e. Omnivore delivers speed proportional to the FLOPS. On the two-socket c4.8xlarge CPU instance Omnivore is now 5.5\u00d7 faster than Caffe. Caffe does not speed up given the additional cores, but Omnivore does. The speedup is not linear because the extra cores are distributed across sockets and not all layers are compute-bound. However, these results show that given similar device throughput, CPU CNN performance is not an order of magnitude slower than GPU performance as the literature often reports and as is the case in Caffe. Lastly we compared Omnivore to Caffe on a 4-socket, 56-core Haswell (non-EC2) CPU machine, and Omnivore is 13\u00d7 faster than Caffe.\nFLOPS calculations. See Appendix C.3 for the FLOPS calculations in Figure 15.\nC.5.2 CPU/GPU Hybrid and Multi-GPU Figure 15 also shows that using the CPU in a GPU in-\nstance can accelerate purely GPU training. The g2.8xlarge instance\u2019s CPU provides 0.67 TFLOPS, and by using data parallelism across the CPU and a single GPU we achieve an 18% speedup in Omnivore end-to-end over just using the GPU. This is faster than all other single GPU results.\nFinally, we also apply this data parallel partitioning across multiple GPUs. We ran both Omnivore and Caffe using the 4 GPUs on the g2.8xlarge instance and show that while Caffe actually slows down compared to the 1 GPU case, Omnivore becomes 3.1\u00d7 faster.\nFor CPU + GPU, each g2.8xlarge GPU provides 1.23 TFLOPS as shown above, and the CPU provides 665.6 TFLOPS (Sandy/Ivy bridge, i.e. 16 SP instructions per cycle \u00d716 physical cores \u00d72.6 GHz). The ratio of CPU:GPU FLOPS is therefore 1:2, i.e. we should partition roughly 1/3 of the data on the CPU and 2/3 on the GPU. Since a batch size is 256 images, we rounded 67% on the GPU to 75%, such that the CPU processes 64 images, because this partition is better suited to hardware (although we see only a 5% speedup compared to using the exact ratio). This partitioning gives a 18% speedup over just using the GPU.\nFor parallelization across 4 GPUs, we use data parallelism for all layers (each GPU given 1/4 of the batch and a model replica) except for the FC layers, which use model parallelism (each GPU given 1/4 of the model and a replica of the batch).\nWe ran Caffe on 4 GPUs with cuDNN v4, cuDNN v3 and no cuDNN, and found that Caffe was fastest but neither gave a speedup compared to 1 GPU.\nTherefore while CNN parallelization is challenging even for state-of-the-art systems, we\u2019ve shown that FLOPSproportional partitioning is possible across a range of hardware devices. We now extend this technique to multiple machines, where the added challenge of network delay motivates re-thinking the SGD algorithm."}, {"heading": "D. APPENDIX FOR DISTRIBUTED", "text": "TRADEOFFS (SECTION 4)\nHaving studied the tradeoffs for a single machine, this section now studies the distributed setting. The goal of this section is to build an optimizer that creates (1) a physical plan P (A,G) which maps the CNN architecture A to machines in the device graph G, and (2) an execution plan E(G,D) which parallelizes SGD by allocating data batches from the dataset D to each machine. This section begins by describing why these two are the most important tasks for the optimizer. While many distributed CNN systems exist [5, 7, 8, 15, 19, 25] and each describes their own distribution techniques, upon analyzing these strategies we discover that, though diverse, they all describe either (1) or (2) above. Given these two fundamental design dimensions, we then arrange existing strategies into a tradeoff space and restate our optimizer\u2019s goal precisely within this space. The remainder of the section then quantifies the impact of these tradeoffs to allow optimization within the space."}, {"heading": "D.1 Distributed CNN Tradeoff Space", "text": "This section describes popular techniques for distributed CNN training and refines them into a tradeoff space.\nD.1.1 Distributed Stochastic Gradient Descent Recall that SGD iteration i (1) reads a batch of data Bi,\n(2) uses the current model Mi to compute the model gradient \u2207M(Mi), and (3) subtracts \u2207M(Mi) from Mi to obtain Mi+1. Iteration i+ 1 reads a new batch Bi+1 and the algorithm repeats until convergence.\nFigure 16 (a) shows a common distributed implementation of SGD in which the entire CNN model is stored on a server called a model server or parameter server. There are also a number of compute servers which each perform the CNN calculation (Equations 2 and 3). Each iteration, every compute server reads M over the network from the parameter server, as well as a batch of data B from a local database. Each compute server calculates a gradient \u2207M which is sent back to the parameter server and used to update the model. In this example, compute servers operate in parallel and do not synchronize or communicate with one another.\nIn Figure 16 (a), each server physically maps to a single machine (node). Generally, multiple servers can map to a single machine or a single server to multiple machines. For example, parameter and compute servers can map to the same node to reduce network communication. Figure 16 (b) shows a more complex server architecture for SGD in which rather than two types of servers (compute and model), there\nare now 4 types: (1) conv compute, (2) conv model, (3) FC compute, and (4) FC model. 1 and 2 are for layers in the conv phase of the CNN while 3 and 4 are for layers in the FC phase. In Figure 16 (b), the FC compute and model servers map physically to the same machine, i.e. the computation of the FC phase happens on the same machine as where the FC model is stored. There are many benefits to Figure 16 (b) vs. (a): Recall that FC has small data, large model whereas conv has large data, small model. This server architecture has the benefit of only needing to communicate the conv model (and its gradients) and the FC data (and its gradients) across the network. Second, computation is offloaded from the compute machines to the FC model server, which otherwise is majorly idle. These benefits both improve hardware efficiency, and were described in [7]. However, yet another benefit is that by having only a single FC compute machine, the FC model does not experience any staleness \u2013 a term we define next. This improves statistical efficiency.\nD.1.2 Staleness Staleness is a metric used to quantify the statistical effi-\nciency (# iterations to convergence). Figure 17 shows staleness graphically for the simple server architecture of Figure 16 (a). In Figure 17 (a) there is a single worker, and so that worker always computes the gradient using the current model. In this diagram, we assume that once a worker sends the updates back to the model server, it is immediately sent a new model, i.e. in this diagram, write/read is an atomic operation for each worker (the write to the model and read from the model happen together).\nIn Figure 17 (b), there are now two concurrent workers. Assume for now that (1) these workers update the model in round-robin order, (2) write/read is again atomic, and (3) the server architecture is again as in Figure 16 (a). We notice that now each worker computes the gradient using a copy of the model which is stale by 1 iteration, e.g. updating model 2 to produce model 3, but doing so using a gradient update which was calculated using model 1. The reason for this staleness is that while worker 0 is computing its next update, worker 1 updates the model. This staleness is bad for statistical efficiency (i.e. more iterations are required to converge) because now each gradient used to update the model no longer points in the direction of steepest descent for the model it is applied to, but rather the direction of steepest direction for a model from an earlier iteration.\nPrecisely, we define staleness as follows: given N workers, the staleness is the number of updates to the model between a worker\u2019s read from the model and subsequent write back to the model. Because the updates are round-robin, this staleness is the same for all workers, and is equal to S = N \u2212 1. E.g. if there are 100 parallel workers, S = 99. Intuitively, the staleness is just equal to the number of parallel workers sending gradient updates (minus one, although this can often be ignored because the number of workers is large).\nThe three assumptions above are useful to give a precise definition but are not necessary in practice.\nAssumption 1:. In practice the workers do not proceed in round-robin order due to inherent variance across machines, but we observe empirically that for dense models the updates are nearly round-robin. This is because dense model computations like those used in deep learning have roughly constant time per iteration (this is not true for sparse models).\nAssumption 2:. Writes and reads do not need to be atomic, and in fact this can be beneficial for statistical efficiency. Rather than have a conv compute server request an entire updated model as soon as it publishes all of its gradients to the conv model server, it may instead publish gradients layer-by-layer in a backwards fashion during the backward pass of iteration i, and then lazily request the updated model in the forwards pass of the next iteration i+1. For example, AlexNet may update the model with gradients from conv5, conv4, conv3, conv2, and conv1, and then begin its next forwards pass and request conv1, conv2, conv3, conv4 and conv5. These requests can happen asynchronously from the computation to hide latency and overlap the network delays with the computation. As a result the write/read for conv1 may be almost atomic, but there would be some delay between the write/read for conv5. This delay in fact reduces staleness slightly because it reduces the number of intermediate writes by other workers between a worker\u2019s read and subsequent write (intuitively, in the extreme case, if the delay was very large, then every worker would write before any of them read the new model. Then this is just equal to minibatch, except with a larger batch size, although that would of course make each iteration slower, i.e. harm hardware efficiency). In practice we observed a roughly 20% reduction in the number of iterations to converge by requesting models in this lazy fashion (which does not harm hardware efficiency).\nAssumption 3:. Staleness also applies to the server architecture of Figure 16 (b), which recall reduces network communication by merging the FC model and FC compute servers, i.e. mapping them to the same machine which does both the gradient computation and model updates for the FC phase. This merged FC server processes only one batch at a time, and thus produces only one FC model gradient at a time. This means that the staleness for the FC model is 0 which is good for statistical efficiency. The conv compute servers on the other hand still calculate the updates to the conv model in parallel (once they receive their data gradients from the FC machine), therefore the merged architecture in Figure 16 (b) still contains staleness, but only for the conv model.\nD.1.3 Compute Groups The final concept common to all systems is the compute\ngroup. Consider the example of two conv compute machines in Figure 18 (a). This configuration has a conv staleness of S = 1, as there are 2 workers independently updating the model. However, it is not necessary to introduce staleness in order for both compute machines to be utilized, and Figure 18 (b) shows a second configuration in which data parallelism is used across the machines: each conv compute worker processes half the data of a single batch, using the same model replica, and produces half of the final gradient. A barrier is then introduced in which the gradients are summed, and a single, final gradient is applied to the model. Figure 18 (b) seemingly solves both problems: all the hardware is being utilized (good for hardware efficiency), and S = 0 (good for statistical efficiency). However the price we pay is in hardware efficiency, specifically the cost of synchronization across the machines. Indeed, we will show that the hardware efficiency of Figure 18 (b) is poorer than that of Figure 18 (a).\nWe define a compute group as a group of machines working together to process a single batch of data. A compute group is characterized by processing a single data batch at a time, with all machines in the group using the same model replica, and returning a single gradient to the model server. The compute groups in Figure 18 are shown with black dotted lines. Figure 18 (a) has 2 compute groups, and since there are 2 machines, the compute group size is 1 machine. Figure 18 (b) has 1 compute group of size 2. Note that this allows us to simplify our definition of staleness: because the number of parallel gradients being computed in the system is equal to the number of compute groups, the staleness is just equal to the number of compute groups (minus one).\nGenerally, if we have N machines used as conv compute servers, Figure 18 (a) and (b) show two extreme cases. Figure 18 (a) is the extreme case of 1 machine per compute group, and N groups. This technique is often called asynchronous SGD, or \u201casync\u201d for short. In async, workers do not communicate and each worker updates the model independently. Every worker computes a separate gradient using a separate batch and separate model replica, and then sends these gradients to the parameter server in order to update the model. Figure 18 (b) is the other extreme case of\n1 group, and all N machines in that single compute group. This technique is often called synchronous SGD, or \u201csync\u201d. In sync, all machines work synchronously and in parallel on a single batch of data and using a single model replica to compute a single gradient. In this case the gradients over all workers are aggregated each iteration (or batch) before updating the model. An intermediate configuration could also exist, for example one which has 4 groups each of size N/4. There could even be groups of different sizes if different machines have different throughput (some GPUs, some CPUs, etc.). Notice that because the compute group in Figure 18 (b) parallelizes the conv phase, it uses data parallelism, i.e. the batch is partitioned across the machines in the group.\nD.1.4 Precise Problem Definition This section has described two key tradeoffs: (1) the server\narchitecture, concerned with physically mapping servers to machines, and (2) the execution strategy (the number of compute groups vs. their size), concerned with mapping batches to servers. We can now restate the goals of the optimizer from 2.4 in terms of our tradeoff space. Given (1) A, the CNN architecture, (2) D, the dataset, and (3) G, the device graph, our optimizer transforms A into S, an abstracted network of logical server types (Convmodel, Convcompute, FCmodel, and FCcompute), and creates (1) a physical plan P (S,G) mapping each server in S to machines in G (note that we also refer to this distributed portion of the physical plan as the server architecture), and (2) an execution plan E(S,D) which defines the number of compute groups by allocating batches of D to each server in S. Both of these choices impact hardware and statistical efficiency, and our next task is to quantify this impact. First, we present terminology and then finish this section by describing where existing systems fall within this tradeoff space.\nOur mapping from CNN layers to devices is shown in Figure 19.\nWe are given: (1) a network, which can be viewed as a labeled directed acyclic graph in which each node is a type of layer (e.g. convolution, fully connected, max pooling) and edges indicate dataflow dependencies, and (2) a set of devices grouped into machines. Our goal is to devise a mapping from the network to the machines."}, {"heading": "D.2 Terminology", "text": "In this work we interchangeably uses the terms node and machine to refer to a single box, connected to other nodes or machines over a network. We also interchangeably use the terms device and (when describing a device graph) vertex to refer to a discrete unit of compute hardware (e.g. a GPU\nor CPU core. When discussing a cluster, a device can also be a machine in that cluster.). Finally, we also use the terms group and compute group interchangeably, as defined in Section 2.\nExisting work also often contains a lot of terminology, which we summarize here. Consider for these examples the simple case of N identical compute devices (e.g. N machines, N GPUs, N CPU cores, etc.)\nD.2.1 Synchronous Batches These first two definitions apply to a single batch of data,\ni.e. there are not multiple parallel batches in the system used to compute asynchronous gradients, but rather a single batch used to compute a single gradient. As a result, this gradient is applied to the model at once to produce a new model, i.e. there only ever a single model in the system (although it may be replicated, in which case all models are identical). This is also known as the synchronous case above.\nModel Parallelism: A single replica of the model and N replicas of the data batch are created. Each device is given 1/N of the model replica and 1 replica of the data batch. This is useful for parallelizing fully-connected layers, which contain small data but large models: each device receives 1/N of the model and a replica of the data, and uses the data to compute a gradient for that portion of the model. These gradients in total combine to a single gradient with respect to that entire model, using the data batch.\nNote that logically, a single gradient is produced by all devices together and that single gradient is used to update the model and produce a new model (physically the updates may occur locally on each device communication, i.e. the device updates its portion of the model).\nData Parallelism: A single replica of the data batch and N (identical) replicas of the model are created. Each device is given 1/N of the data replica and 1 replica of the model. This is useful for parallelizing convolutional layers, which contain small models but large data: each device receives 1/N of the data and a replica of the model, and together they calculate a single gradient with respect to that entire model using the data batch.\nNote that, as mentioned above, here the model is always the same for each device, i.e. the model is replicated and a single gradient is produced. That gradient is then used to update the model and the model is then re-broadcast to each device. So while model replicas exist, they are identical model replicas.\n(Note: model replica is a logical term and does not always correspond to a physical replica. In particular, when two devices share memory, e.g. 2 CPU threads running on 2 cores, no physical replica is necessary as the same model in memory can be read by both.)\nD.2.2 Asynchronous Batches The above definitions apply to a single data batch in the\nsystem (although it may have been replicated for the purpose of parallelization). Consequently, there was always one gradient being computed at once, and so each model replica was identical.\nThis definition focuses on the asynchronous case mentioned previously, i.e. NB parallel batches in the system being used to compute NB parallel gradients. Each of these NB batches of data in the system is different. Each batch is\nallocated to a compute group (a group of devices), and each batch (i.e. each group of devices) is given a replica of the model. For example if NB = N/4, then there will be 4 devices assigned to each batch, and one model replica assigned to each of these N/4 batches (i.e. each group of 4 devices). Each compute group of 4 devices will then compute a gradient given that model and that batch, and the devices in the group may do so using either model or data parallelism (i.e. choosing to create additional model or data replicas within the group, as described above, e.g. if the group uses data parallelism it will create 4 additional model replicas, but each of these models will be identical).\nNote that here the number of batches in the system, the number of compute groups, and the number of parallel gradients being computed by the system are all the same number. Within a compute group (group of devices), additional model replicas will be the same. However across compute groups, the model replicas may be out of sync, because of asynchronous gradient computations. This is discussed in the final definition.\nTo make all the definitions above concrete, consider the example of 2 devices, e.g. 2 GPUs. There are 3 possible scenarios: (a) 2 parallel asynchronous batches (\u201casync\u201d), (b) 1 batch with data parallelism across the 2 devices (\u201csync\u201d), or (c) 1 batch replicated twice with model parallelism across the 2 devices (also sync).\nD.2.3 Combining Model Replicas If there are G asynchronous compute groups, each using\na separate data batch and producing a separate gradient each iteration, then each group will also have a separate version of the model as a result of the asynchronous gradient computations.\nParameter server is a technique in which these separate compute groups will not perform their model updates locally, but rather each publish their gradients to a global parameter server which will then broadcast the updated model to a group upon receiving the update for that group. In this way the groups always have models which are almost the same (they will still be slightly out of sync because gradients are published asynchronously and so models are returned to the groups asynchronously as well). DistBelief, Adam, SINGA, MXNet use this technique, and it is the focus of our study.\nNote that if the parameter server waits for each parallel group to publish a gradient and then broadcasts the model to all groups (i.e. introduces a barrier), this is no longer asynchronous, and is now equivalent to the synchronous case above (data parallelism) where the batch size is N times larger than it is per individual compute group.\nFinally, the updates to the server from parallel groups can happen with or without race conditions. The case of race conditions is known as Hogwild!.\nModel Averaging is a technique in which there is also a global parameter server, but model updates happen locally within each group. Then periodically, every \u03c4 iterations, the groups will publish not their gradients but their entire models to the parameter server. The parameter server will average the models (reduce step) and then broadcast them to each group (map step). This averaging does not have theoretical guarantees because neural networks are non-convex, but works in practice. This technique works well for map/reduce frameworks, e.g. Spark/Hadoop, and\nis used by SparkNet and DL4J. Here the models are more different than they are in the parameter server case.\nThe choice of the \u03c4 parameter is similar to the tradeoff of multiple groups of varying size, except that here staleness comes not from multiple asynchronous workers updating a single model, but multiple workers with a separate model combining models. In the case where \u03c4 = 1, this is identical to the synchronous case of parameter server (all machines in a single group, i.e. all computing a single batch/gradient).\nEnsembles are used by AlexNet. Here each group trains an entirely separate model to convergence and then predictions of these models are combined (e.g. through voting). The gradients or models themselves are never combined.\nIn this study we focus on the parameter server approach, which is the most widely used by distributed CNN systems."}, {"heading": "D.3 Existing Systems", "text": "Using the terminology above, we discuss design decisions made by CNN systems in Table 2. In our review of the literature, these are the tradeoffs which we identified as most impactful to minimizing convergence time.\nExecution Strategy. In terms of execution strategies, Microsoft\u2019s Project Adam [7] reports that the async strategy is effective and uses one or a few (e.g. 4) machines per compute group. Moreover, they report that using a technique called Hogwild! [20], which minimizes write conflicts, is an effective source of additional hardware speedups. On the other end of the spectrum, FireCaffe [15] implements the sync strategy and notices that high scalability can be achieved by having all machines work synchronously and in parallel on a single, large batch of data, and by reducing communication using reduction trees. MXNet [5] implements both the sync and async strategies, and allows the user to select which to use. They also call the sync strategy the Bulk Synchronous Parallel (BSP) protocol. Finally, Google DistBelief [8] and Apache SINGA [25] implement both sync and async as well as the compromise of multiple, larger compute groups. They also call sync Sandblaster, and cases of more than one group Downpour (e.g. Downpour with group size of 1 machine is equivalent to the async). SINGA calls the intermediate case of multiple, larger compute groups hybrid (SINGA also has hybrid parallelism, which is different. That is a combination of model and data parallelism.)\nAll these systems implement the Parameter Server technique, described above in the Terminology section (Appendix D.2). It is the most widely used technique by distributed CNN systems and the technique we focus on in this study. Another technique known as model averaging, which works well within a map/reduce framework, is used by\nSparkNet [19] and DL4J (http://deeplearning4j.org/). Model averaging is also described above. The key difference between model averaging and parameter server is the way in which model replicas are combined.\nPhysical Map, Modern Networks. The second point in the distributed tradeoff space is the server architecture (how servers map to hardware), specifically whether the FC compute and FC model servers are mapped to the same physical machine (or machines, for multi-machine model parallelism).\nThis is a technique introduced by Microsoft\u2019s Project Adam [7] to avoid communicating the large FC model and its gradient. The method was reported for older networks with large, fully-connected layers (AlexNet, VGG), however it also is useful for modern networks (Inception, ResNets). In traditional networks, the fully-connected layers contained the majority of the model parameters [17] (> 90%). Newer networks instead use average pooling and have only a single FC layer (for softmax regression) [14]. Therefore newer networks contain fewer parameters in the FC phase, and fewer parameters overall, however this single FC layer can still be very large (e.g. when predicting among 22,000 classes on ImageNet 22k) and still benefits from reduced FC communication (because the number of FC weights will always be less than the number of inputs to the FC phase). Therefore while newer networks contain only a single FC layer, the merged FC optimization of Project Adam is still relevant, and while a characteristic of newer networks is that their overall model size is smaller due to the elimination of multiple FC layers, ultimately this does not translate to reduced communication overall because the cost of communicating the FC layers has been eliminated in prior work.\nIn addition, as we show, the benefit of merging the FC servers is not only improving HE due to reduced network communication, as [7] noted, but also improving SE because staleness in the FC model is eliminated (i.e. the device or devices which compute the FC model gradient updates also store that subset of the model). Moreover there is no consequence of merging the FC servers for small FC models because little computation in the FC phase means it is less likely for the FC to saturate (become the bottleneck), but merging still provides the benefit of (1) improving SE, (2) reducing communication and (3) offloading computation to the parameter server machines.\nAs our goal is to be a complete study, we study both cases (many large FC layers, few small FC layers) in order to build a system which is robust to any application. For example future CNN architectures may employ multiple FC layers again to support transfer learning tasks, or may need to predict among many object classes (e.g. hundreds of thousands or millions), further increasing the communication bottleneck for the FC. In addition, FC layers are also used for RNNs and other architectures.\nThis is the subset of the tradeoff which we study in this work, summarized in Table 2. Our goal is to find best point in the tradeoff space given the model, data, and hardware specifications from the user. Specifically we do not change the neural network architecture, but assume that this model is given to us. I.e. we do not focus on machine learning algorithms or techniques in this work, but rather study systems tradeoffs which exist for the most widely used networks/algorithms. We focus on the SGD algorithm for\nlearning, as it has been and continues to be used along with momentum by annual ImageNet winners [14, 17]. Other algorithms exist for training deep learning models and can also be parallelized, for example Google\u2019s deep learning system uses Adagrad [8]. Microsoft on the other hand uses SGD [7]. Because the systems tradeoffs we study in this work are orthogonal to the choice of update algorithm, in this work we focus on SGD, although the same tradeoff applies to other algorithms as well."}, {"heading": "D.4 Hardware Efficiency Model", "text": "The goal of this section is to create a predictive model for how the hardware efficiency (HE) varies with the amount of staleness S in the system, given a fixed number of machines and batch size. Recall that the staleness S is equal to the number of compute groups (minus one). This is because a compute group is characterized by processing a unique data batch and returning a unique gradient to the model server, so the number of parallel gradients being computed is equal to the number of compute groups. S = 0 is the case of 1 compute group, also called the synchronous case.\nFigure 20 shows a plot of staleness vs. hardware efficiency penalty for three datasets. The standard networks from Caffe\u2019s tutorials are used for each dataset. The hardware efficiency penalty, or PHE , is defined as the ratio of the time per iteration relative to the time per iteration for this synchronous case,\nPHE(S) = HE(S)\nHE(0)\nA higher PHE is worse (more time per iteration). PHE decreases (iterations become faster) as the number of compute groups increases. This is because, if we fix the number of machines to be N , the smallest time per iteration occurs when there is no synchronization, i.e. when the compute group size is 1 and there are N compute groups (asynchronous case). In this case S = N \u2212 1. As the compute group sizes increase, and hence the number of groups decreases (because the number of machines is fixed to N), PHE will increase due to synchronization delays within the groups. When the number of compute groups is 1, that group contains all N machines and requires the most synchronization. In this case S = 0, and this has the highest penalty PHE .\nThe hardware efficiency penalty is dimensionless. It is the ratio of hardware efficiencies (time per iter / time per iter). Because PHE is normalized to the synchronous (S = 0) case, PHE \u2264 1. Note also that the hardware efficiency penalty is only comparable across different staleness values if the number of machines is fixed.\nThe hardware efficiency penalty can be predicted analytically. However, as we will see in a later section, the cold-start phase of the optimizer performs a short adaptive grid search across different staleness values. Because a few iterations are run for various staleness values, the execution time for these iterations can be used to provide a precise hardware efficiency model (deep learning layer computations are dense, not sparse, so there is little variation in iteration time). Nevertheless understanding the hardware efficiency precisely is important:\n1. to understand the execution bottlenecks and either hard-code or allow the optimizer to make physical mapping choices 2. because it may be too time-consuming to obtain static information for every staleness value of interest, and 3. because our work is a study meant to inform future systems which may not use a static optimizer\nFigure 20 was run on 33 EC2 CPU machines. The server architecture shown in Figure 18 was used, i.e. one machine contains the merged FC compute and FC model servers, and the other 32 machines contain Conv Compute servers. The Conv Model server is mapped to one of the Conv Compute machines. We make two observations, which are true for all datasets in Figure 20:\nObservation 1: As the number of groups decreases (and hence as their sizes increases), the hardware efficiency becomes poorer. There are two reasons for this: (1) machine variance, which causes synchronization delays, and (2) network congestion, because the convolution model needs to be sent simultaneously to all machines in the group (and gradients need to be send back simultaneously). Our analysis below shows that while machine variance exists, it is insignificant compared to increased network congestion.\nObservation 2: As the number of groups increases, the speedup is not linear (it saturates). This is because the FC phase processes only a single batch at once, or equivalently because the FC compute and FC model server map to the same physical machine (or machines, as the FC compute / model server may use multi-machine model parallelism). Recall that this has benefits for both hardware efficiency (by reducing network communication) and statistical efficiency (by reducing the staleness of the FC model). However it means that only one gradient computation (batch) is processed by the FC at a time, and so it may become a computational bottleneck.\nMany optimizations exist for both of these observations. They are presented after our derivation of the model.\nD.4.1 Full Derivation of Analytic Model Formally, let there be N + 1 machines. 1 machine is\nallocated to the FC phase, and N machines (e.g. 32) to the conv phase. An execution strategy partitions the N conv machines into g compute groups. Each group contains k machines, and the k machines in a group compute the conv phase with data-parallelism. Therefore, there will be g = N/k compute groups sharing the single FC server machine. In addition, let tconv(k) be a function that returns the time that a group of size k needs to compute the convolution phase (forwards and backwards for only the conv phase), and tfc be the time that an FC server needs to serve one group (forwards and backwards for only the FC phase. Note that tfc is independent of k, the number of machines\nused to perform convolution on each batch). We also define that tfc includes the network time to transfer the data from the conv phase to the fc phase and the data gradients from the fc phase back to the conv phase, although we observe that this network time is often small compared to the computation time of tfc. Note that tfc is independent of k, the number of machines used to perform convolution on each batch. Finally, assume for now as we did above that different groups (batches) cannot be executed in parallel on the FC server (that case is described later).\nGiven k, g, tconv(k) and tfc, our goal is to create a hardware efficiency model which predicts the time per iteration or, equivalently, which given a time interval T predicts how many batches will be processed by the system. Because each batch must be processed by the FC server, this is equivalent to determining the number of requests that the FC server can process from the g convolution groups in time T . There are two cases, also illustrated in Figure 21.\nCase 1: Saturated FC Server The first case is when FC server is saturated, i.e. it starts to serve the next request immediately after the previous request finishes. In this case, the hardware efficiency is straightforward. The server will serve T/tfc requests in time T, or equivalently,\nTime per iterationsaturated fc = tfc\nCase 2: Saturated Conv Server When the FC Server is not saturated, each conv server becomes the bottleneck. In this case, the FC server serves Tg/(tconv(k)+tfc) requests in time T, or equivalently,\nTime per iterationsaturated conv = (tconv(k) + tfc)/g\nwhich is the total time for a single iteration divided by the number of parallel groups. This is because the groups all are computed in parallel, with the exception of the FC server which is serial, but the FC server is never saturated so it can also be seen as being part of each parallel group. Refer\nto Figure 21 for an illustration of this case. To understand this case, note that:\n1. When each conv server is fast (tconv(k) is small), the FC server serves more requests in time T\n2. When the FC server is fast (tfc is small), the FC server serves more requests in time T\n3. When the number of concurrent group is large (g is large), the FC server serves more requests in time T\nDetermining Saturation Finally, the model needs to predict when the FC server will saturate. This occurs at the boundary of the times above, specifically the FC server saturates (case 1) when:\ntconv(k) + tfc < gtfc\nIntuitively, if the combined FC time to process all groups (gtfc) exceeds the time for a single group\u2019s iteration (tconv(k)+tfc), then the FC server will always be saturated. Note that:\n1. When each conv server is fast (tconv(k) is small), it is easier to saturate the FC server\n2. When the FC server is fast (tfc is small), it is harder to saturate the FC server.\n3. When the number of concurrent group is large (g is large), it is easier to saturate the FC server.\nWe now have an expression for the time per iteration in both cases as well as a condition to decide which case applies. Given the following:\n\u2022 Two of: N , g or k (the third can be calculated from the other 2),\n\u2022 tconv(k), the time to complete the convolution portion of the network (forwards and backwards) given the group size, and\n\u2022 tfc, the time to complete forwards and backwards on the FC phase,\nthe model can predict the mode of saturation and therefore the time per iteration. tconv(k) can be calculated given the throughput of each node and the network speed. It has two components: tconv,compute(k) and tconv,network(k).\nLet us define tconv,compute(1) = Tc,c, i.e. Tc,c is the time it takes for a single machine (k = 1) to compute the forward and backward pass of the convolution phase. Similarly, let us define tconv,network(1) = Tn,c, i.e. Tn,c is the time needed for a single copy of all the conv phase\u2019s models (forwards pass) and model gradients (backwards pass) to be passed over the network. We will describe how to determine these two quantities later.\nThe computation time for the convolution phase for k > 1 is then tconv,compute(k) = Tc,c/k, because recall that a single compute group performs computation on a single batch of data (data parallelism), i.e. the amount of data per group is always the same per iteration (e.g. b images) and so if there are k machines in a group, each will process b/k images. We assume a linear speedup.\nOn the other hand, the time for the network communication increases with k. This is because of increased network communication from the conv model server, i.e. the model needs to be sent to k workers simultaneously and gradients will be received from k workers simultaneously (all requests\nare made at almost the same time, because the workers in the group are synchronous). The network time for the convolution phase for k > 1 is then tconv,network(k) = Tn,c \u2217 k. Here, we assume a linear slowdown.\nSo while the compute time decreases with k, the network time increases with k. We assume that both of these are linear. Empirically we notice that the convolution computation does not scale exactly linearly with k: on 8 c4.4xlarge machines in a single group, the forward pass of the convolution becomes 7.2\u00d7 faster and the backwards pass 6.6\u00d7 faster. Similarly, we observe that the network slowdown is usually linear but can be super-linear, which we attribute to thrashing.\nGiven tconv,compute(k) and tconv,network(k), we can naively approximate\ntconv(k) = tconv,compute(k) + tconv,network(k)\nHowever, these two can be done in parallel, i.e. while one layer is computing its forwards pass, the model for the next layer is being sent over the network. This does not entirely overlap because the first layer needs to complete its backwards pass before requesting the model for its next forwards pass, but we can approximate the total convolution phase time as:\ntconv(k) = max(tconv,compute(k), tconv,network(k))\nFinally, it is necessary to obtain Tc,c, Tn,c and tfc. We measured these because they only need to be measured once (not for each k), but they can be calculated using the node throughput and network throughput: Tc,c and tfc can be approximated by counting the total number of operation from each GEMM operation in the conv and fc phases and assuming that BLAS achieves the device peak. Tn,c can be approximated by counting the total number of bytes in the conv models and assuming the peak network throughput is achieved. These assumptions are justified because the matrices and models are large.\nAlso note that measurements of these quantities are accurate for all iterations because deep learning computations are dense and so there is little variation in the computation time across iterations, as shown in Figure 22. Note that there is a standard deviation of than 6% for tconv(1) and tfc, and a standard deviation of 8% for the total iteration time. For CIFAR-10, the standard deviation for total iteration time was 1.5%. We also observed similar variances on a GPU cluster.\nUsing measurements of Tc,c, Tn,c and tfc, Figure 5 shows that the analytic model of hardware efficiency is accurate. When the FC server is saturated (right side of the graph), the model is almost exact. When the FC server is not saturated (left side of the graph), the slowdown and speedups are not exactly linear, and we under-estimate the time per iteration.\nWhile this analytic model may seem specific to CNNs, it extends to any deep learning model because its derivation relies only on queuing theory, not any specific properties of CNNs.\nD.4.2 Further Optimizations A primary goal for understanding the hardware efficiency\nabove is to determine possible optimizations.\nSaturated Conv Server. We showed above that as the group size (k) increases, there is no longer FC saturation, because\ntconv(k) + tfc > gtfc\nand recall\ntconv(k) = max(tconv,compute(k), tconv,network(k))\nSpecifically, in Figure 5 the case of a single group (left side of the graph) is so much slower than FC saturation (right side of the graph) because tconv,network becomes very large, i.e. the time it takes to send the conv model to all 32 machines in the group is significantly greater than the computation time, which is small due to data parallelism across 32 machines.\nIn particular, note that a single, large group is slower than many small groups not because of synchronization delays due to machine variance exists, but because of increased network congestion, although some variance does exist in the computation time across machines.\nMicrosoft\u2019s Adam [7] discusses techniques to mitigate both of these problems, from not requiring each worker in a group to finish processing all of its images to adding multiple NIC cards on the parameter server machines. FireCaffe [15] uses the technique of reduction tress for their parameter servers to reduce communication overhead, which allows them to reduce this network congestion and scale to many machines in the synchronous case using a larger batch size.\nSaturated FC Server. The optimizations above improve the hardware efficiency for the synchronous case, or generally for small g and large k. On the right side of Figure 5 (small k, large g), the FC server becomes saturated and no further speedups are possible. Recall that this is because the FC compute and FC model servers are mapped to the same physical machine. Also recall that this has benefits for both hardware efficiency (by reducing network communication) as well as statistical efficiency (by reducing the staleness of the FC model). However it means that there is only one FC compute server, and so it may become a computational bottleneck. This is seen in the top Gantt chart of Figure 21 in which there are blank spaces which indicate un-utilized machines.\nA simple way to fix this is to make the FC machine faster, for example if there is limited access to GPU hardware, it\nit best to use them on this machine (indeed, we see in Section 6 that the GPU cluster does not saturate FC). Another technique is to use multiple machines for the FC phase, for example using model parallelism across multiple machines such that each machine stores a portion of the FC model (this still has a staleness of 0 for the FC phase).\nAnother solution is to remove this physical mapping, i.e. rather than have a single FC compute server mapped to the FC model server, to have a separate FC compute server per Conv compute server. This removes the bottleneck of a single FC compute server, although it also sacrifices the benefits mentioned above. Section 6 demonstrates the consequences of this decision experimentally.\nPhysical Mapping Details. In addition to mapping the FC compute and model servers to the same physical machine, note that the conv model server does minimal computation and can also be mapped physically to the same machine as the FC compute/model server or one of the conv compute machines. The primary concern with this server is network congestion, so it makes more sense to map to one of the conv compute server\u2019s machines.\nIn addition to multiple servers physically mapping to a single machine, it is also possible for a server to physically map to many machines, for example using multiple machines in a model server to implement a reduction tree as in FireCaffe, or mapping 4 FC Compute servers to a machine that contains 4 GPUs, etc. Another example is merging the FC compute and FC model server and mapping them to the same physical hardware as in Figure 16 (b), but where that hardware is not a single machine as shown in Figure 16 (b) but multiple machines e.g. using model parallelism.\nFinally, a common technique is to \u201cpipeline\u201d the servers by mapping multiple conv compute servers to the same physical machine. For instance in the synchronous case (1 group of N machines), during the FC computation all N machines are idle (because they are waiting for the FC to return data gradients before they can begin the backwards pass of the conv phase). During this idle time those machines can be processing a different batch, i.e. N = 32, but there are two groups of size 32. Note that in this example, this pipelining increases staleness from 0 to 1. Using this pipelining, now the time per iteration in conv saturation becomes:\nTime per iterationsaturated conv = tconv(k)/g\ni.e. the FC time is completely hidden."}, {"heading": "D.5 Statistical Efficiency Model", "text": "Because asynchrony can be viewed as increasing implicit momentum, asynchrony can be made equivalent to synchronous execution by properly reducing the explicit momentum in order for the total explicit + implicit momentum to stay the same as the optimal momentum of the synchronous case. This is true as long as the implicit momentum is less than the optimal momentum of the synchronous case. This is a key discovery because it means that staleness can exist in the system without incurring a statistical penalty, which is advantageous for hardware efficiency. Also, making the momentum stay the same (rather than just ignoring this result and letting there be extra momentum) is important because a total momentum that is too high will diverge, which we show experimentally in Appendix E. This theory also successfully predicts measured\nsystem behavior: Figure 6 shows the predicted and actual measured momentum for several popular deep learning problems. In both cases, upon reducing the explicit momentum to compensate for implicit momentum, we observe no SE penalty. Moreover, the momentum increase due to asynchrony closely matches the theoretical curve for both datasets. Our study is the first to identify a relationship between hyper-parameters and asynchrony, and next these results are used to design the optimizer in Section 5."}, {"heading": "E. APPENDIX FOR DISTRIBUTED OPTIMIZER (SECTION 5)", "text": "This section describes how to use the models from the previous two sections to choose (1) a physical mapping which maps each server to a machine, and (2) an execution strategy which defines the number of compute groups by allocating data batches to each server. As in previous sections we assume that the number of machines are fixed."}, {"heading": "E.1 Selecting the Batch Size", "text": "We first study the batch size in Figure 23, which uses the imagenet-8 dataset with S = 0 and momentum \u00b5 = 0.9. The x axis varies the batch size and the y axis plots the # passes over the dataset (or epochs) until convergence. For each batch size we used an oracle to find the optimal learning rate, \u03b7\u2217. \u03b7 > \u03b7\u2217 diverged.\nWe see that as long as \u03b7\u2217 increases with the batch size, there is little penalty for larger batch sizes. This is because larger batch sizes provide a truer gradient each iteration and permit a larger \u03b7 before divergence, therefore while a larger batch consumes more of the dataset, the progress made by each step is greater. \u03b7\u2217 cannot scale infinitely however, and plateaus beyond \u03b7\u2217 = 0.0032. As a result, larger batch sizes make no more progress per iteration than smaller batch sizes, but consume much more of the dataset each iteration. This is catastrophic for performance (it can take 30\u00d7 more epochs to converge) as computation is effectively \u201cwasted\u201d, which is why neural networks have been trained with SGD rather than batch gradient descent since the early days. This also greatly exceeds the staleness cost incurred of \u201csplitting\u201d a large batch into smaller, asynchronous batches (which we show is nearly flat), which is why asynchrony is necessary for systems to scale to very large clusters.\nThis suggests that the optimizer needs to tune batch size, however for imagenet-8 and other datasets we observe that this performance penalty is negligible around 256 (specifically we use 256 for Imagenet, 128 for CIFAR-10 and 64 for MNIST, based on published results for these datasets). In principle the optimizer could tune b as well, but we observe that unless b is too large the penalty is small so we dont study this in more detail."}, {"heading": "E.2 Physical Mapping", "text": "As discussed in the text, for the physical map which maps servers to machines, we map the FC compute and model servers to the same machine (i.e. \u201cmerge\u201d the FC servers, which as [7] argues reduces communication overhead because it avoids communicating the large FC model) and use one compute group for the FC phase. The rest of the machines are used for the conv compute servers. The conv model servers are mapped to one of the conv compute machines.\nEmpirically we show in Appendix F.3 that this mapping is best for both hardware and statistical efficiency: on a cluster of 33 EC2 c4.4xlarge machines, not merging the FC servers incurs an additional hardware efficiency penalty of 1.2\u00d7 due to increased communication as well as a statistical efficiency penalty of 2.5\u00d7 because of staleness in the FC model. We describe this result further in the experimental results of Appendix F.3. Our current optimizer therefore always chooses this server architecture, although Appendix D.5 (for Section 4.1) described other architectures scenarios in which these penalties are justified to eliminate FC saturation, as well as additional optimizations within this server architecture (such as reduction trees or multi-machine model parallelism for the FC phase)."}, {"heading": "E.3 Optimizer Details", "text": "For each epoch, Algorithm 1 performs an adaptive grid search over both the learning rate and the momentum starting at the current value of g. Specifically, we run each learning rate and momentum (see below) for one minute and select the configuration with lowest loss after 1 minute of execution. If after 1 minute all these configurations have the same loss, we continue to run another minute until there is a clear winner in terms of loss (we determine this using a threshold of 5% from the loss of the past 50 iterations, although a statistical test can be used as well). We then run this best (\u00b5\u2217, \u03b7\u2217) for an hour and then rerun the optimizer.\nOne could use more sophisticated parameter search routines, but this took less than 10% of the execution time.\nWe search the learning rate as follows. Let the learning rate and momentum used in the previous 1 hour epoch (i.e. the result of the grid search from that epoch) be (\u00b5\u2217last, \u03b7 \u2217 last). For the current epoch, we then search \u03b7 \u2208 {\u03b7\u2217last, \u03b7\u2217last/10}, and \u00b5 \u2208 {0.0, 0.3, 0.6, 0.9}. As an optimization to prune the search space, we do not search \u00b5 > \u00b5\u2217last when \u03b7 = \u03b7\u2217last, as we notice empirically that as the run progresses, the optimal total momentum decreases.\nIf the optimal \u00b5\u2217 = 0.0, we try \u00b5\u2217 = 0.1 and \u00b5\u2217 = 0.2 as well, and if the lowest loss is still achieved at \u00b5\u2217 = 0.0, we decrease g and repeat the search.\n(\u00b5\u2217, \u03b7\u2217) in the initial (cold-start) phase are selected using a similar procedure, described in Appendix E.4.\nE.3.1 Empirical Validation\nWe now justify the theoretical results of Section 4.2 experimentally. We use a cluster of 33 EC2 CPU machines (CPU-L in Figure 9), the Imagenet 1000-class dataset, and the AlexNet CNN. We run each execution strategy from sync (g = 1 conv compute group) to async (g = 32), each for a single epoch (1 hour). Specifically, we plot 6 strategies: g = {1, 2, 4, 8, 16, 32}, where the number of conv compute machines is fixed to 32.\nEach strategy starts from the same checkpoint (i.e. same loss), but achieves a different final loss by the end of the epoch. We select the lowest final training loss achieved by all strategies, `F , and plot three measures in Figure 7: (a) the time per iteration (hardware efficiency, HE), (b) the number of iterations to reach `F (statistical efficiency, SE), and (c) their product, which by equation (1) is the total time to reach `F . For completeness, each strategy uses an oracle to exhaustively find its optimal explicit momentum, \u00b5\u2217 (within 0.3) and optimal learning rate \u03b7\u2217 (within an order of magnitude. For all strategies \u03b7\u2217 = 0.01 was optimal). The HE curve in (a) is the same as in Figure 5 (b).\nWe see in (c) that g = 32 (fully asynchronous) is 4\u00d7 faster to reach `F than g = 1 (synchronous). This is due to its faster iteration time (HE) in (a), although it requires 1.8\u00d7 more iterations (SE) to reach `F in (b). This matches the theory\u2019s prediction: increasing g decreases the explicit momentum \u00b5\u2217, which falls to 0 at g = 32, and consequently there is a penalty in SE. The optimizer of Algorithm 1 would therefore select g = 16, which is near-optimal.\nHowever, our optimizer additionally employs an optimization to leverage the HE model from Section 4.1: because the FC server saturates at g = 4 (determined analytically or through measurements during the cold start phase), the optimizer will \u201cshort-circuit\u201d Algorithm 1 to begin at g = 4 instead of g = 32, and ends up selecting g = 4, which is 5\u00d7 faster than sync.\nFigure 24 shows the accuracy vs. time (and for reference accuracy vs. iter, i.e. statistical efficiency) for each configuration (# groups) in Figure 7. Recall that the optimizer selected 4 groups because with proper momentum tuning the statistical efficiency was nearly the same for all curves, but 4 or more groups had the best hardware efficiency. Figures 7 and 24 use ImageNet 1000 class (1 hour of training) as described above with 33 EC2 c4.4xlarge machines."}, {"heading": "E.4 Cold Start Phase", "text": "The model is trained synchronously before beginning asynchronous execution in Algorithm 1. This is needed in order to set the appropriate scale for the weights. However\nfully synchronous execution may be slow, and just as an optimization to Algorithm 1 was to run asynchronously only up to FC saturation, similarly this section focuses on accelerating training during the cold-start phase. In particular, a fully synchronous execution may significantly increase the duration of the cold-start phase due to poor hardware efficiency, and so a cold-start run with slight asynchrony may more quickly terminate the cold start phase. Therefore, tuning the number of compute groups is also important for the cold-start phase.\nCold Start Grid Search. To do this, as in Algorithm 1, we grid search hyper-parameters for each number of groups (1, 2, 4, . . . , N , for N machines). For each we also grid search learning rate and momentum. We use a standard adaptive grid search algorithm for its simplicity. For each staleness, the algorithm searches for optimal settings of momentum and learning rate by running each configuration of parameters for 1 minute, and selecting the parameters with the lowest loss after 1 minute.\nThe search happens as follows, and is similar to the search in the steady-state execution of Algorithm 1. We start with S = 0, fix the momentum to 0.9, and run 1 minute for each learning rate \u03b7 \u2208 {0.1, 0.01, 0.001, 0.0001, 0.00001}. We search from lowest to highest and stop early if a learning rate produces a final loss worse than the previous learning rate (or if a learning rate causes divergence). We select the learning rate which has the lowest loss after 1 minute. Call this \u03b7\u2217sync. Therefore for S = 0, the optimal configuration (\u00b5\u2217, \u03b7\u2217) = (0.9, \u03b7\u2217sync). We do not tune momentum for sync because 0.9 is standard [17], because this saves optimizer time, and because there is no implicitly induced momentum due to asynchrony for S = 0.\nFor the remaining S after S = 0, we perform the following iteration: We increase the number of groups to the next highest power of 2 (after sync, this is g = 2, then g = 4, g = 8, etc, i.e. S = 1, 3, 7, . . .) Let the optimal configuration from the previous S be (\u00b5\u2217last, \u03b7 \u2217 last). For the current S, we run a grid search for (\u00b5, \u03b7)|\u00b5 \u2208 {0.0, 0.3, 0.6, 0.9}, \u03b7 \u2208 {\u03b7\u2217last, \u03b7\u2217last/10}. I.e., \u03b7\u2217 defines the search range for the next S. In addition, \u00b5\u2217 reduces the search space for the next S: we do not search a higher momentum than \u00b5\u2217last while searching \u03b7 = \u03b7\u2217last.\nWe notice empirically that there is not a large impact of running a finer grid for momentum (although this can be done by adding a second-phase of search which fixes \u03b7\u2217 and searches \u00b5 around \u00b5\u2217). Running multiple random seeds (network weight initializations) can also be used to find a good starting point for the SGD algorithm (this is a known technique). Tuning parameters is not a novel idea in machine learning, but unlike existing work our problem is more sophisticated as we are coupling tuning hyper-parameters and execution strategies (staleness). Our work is the first to show that hyper-parameters and execution strategies need to be tuned jointly to avoid divergence as staleness increases.\nOnce we obtain (\u00b5\u2217, \u03b7\u2217) for each S, we then run each S for one minute at a time until there is a clear winner in terms of loss (we determine this using a threshold of 5% from the loss of the past 50 iterations, although a statistical test can be used as well). We then run this best S with its (\u00b5\u2217, \u03b7\u2217) for an hour (the cold-start period).\nParameter Search Experiments. The remainder of this section describes experiments motivating the pruning above, in particular why a larger staleness does not need to try larger learning rates or larger momentum values at the same learning rate. There are a number of insights which allow us to prune the search space for the cold-start phase and reduce the total search time. We discovered that as staleness increases, the optimal learning rate and momentum parameters when S = 0 cause divergence (loss goes to infinity) for larger staleness values, e.g. S = 31. This makes sense given our theoretical foundation from the steady-state optimizer: staleness induces implicit momentum, hence if explicit momentum is not decreased as S increases, total momentum can be > 1 and cause divergence. As S increases, we note that one or both of \u03b7 and \u00b5 need to be reduced otherwise SGD will diverge (loss goes to infinity).\nTable 3 shows the optimal parameters for the same datasets and networks used in Figure 20, at different staleness values. Here the optimal parameter settings are defined as the parameter settings with which the training converges in the fewest number of iterations. We say that a model has converged once the training accuracy reaches 99.5%. Recall that a staleness value of S corresponds to N = S+1 parallel groups updating the model asynchronously. In these experiments, the staleness of the fully-connected models was zero, and so only the conv model had staleness. Note that for imagenet 8-class there are only 10400 examples and batch size is 256 so 128 parallel workers was not possible (there is insufficient data). Note that these small datasets all converge in under an hour and therefore consist entirely of the coldstart phase in our implementation. While the cold-start phase of these datasets is less than an hour (e.g. MNIST converges in seconds), and therefore Algorithm 1 could be run part-way during execution to select a better strategy for the remainder of the execution (e.g. asynchronous), the overhead of re-running Algorithm 1 is not justified for these small datasets, i.e. it is faster to treat the entire run as the cold-start phase. Therefore we use these smaller datasets to study the cold-start phase.\nThe table shows that, with a fixed batch size, as staleness increases the optimal momentum and/or learning rate decreases, and in some cases not decreasing these parameters and reusing the parameters for S = 0 causes divergence. Also, we see that decreasing the learning rate means momentum can increase again. Intuitively this is because\nmomentum can be viewed as increasing the learning rate (larger SGD steps), and so if the learning rate is decreased too much, momentum increases to compensate for this decrease. Our grid search searches orders of magnitude for the learning rate, following from previous work [17], but decreasing the learning rate by a smaller factor may avoid the need for momentum to increase and provide faster overall convergence. We leave this exploration to future work."}, {"heading": "F. APPENDIX FOR DISTRIBUTED EXPERIMENTS (SECTION 6)", "text": ""}, {"heading": "F.1 Single-Node Experiments", "text": "See Appendix C.5."}, {"heading": "F.2 Small Cluster Experiments", "text": "This section provides additional details of the experimental setup. For the end-to-end experiment on ImageNet 1000, see Appendix F.5.\nWe ran all systems with a timeout of 2 hours. For each system we used the same CPU and GPU external libraries as discussed in Appendix C.5.\nWe further sped up other tools by applying our optimizer to the extent that no code change was required. MXNet offers both the sync and async strategy. Given our observation that async requires tuning parameters, to ensure training did not diverge we ran each strategy of MXNet with 4 orders of magnitude of the learning rate for 10 minutes each. We then selected the best strategy (as the static optimizer would) and ran it until convergence or timeout. For SINGA we followed the same procedure and tried all available configurations. SINGA supports not only sync (1 group) and async (1 machine per group) strategies, but also intermediate group sizes. We ran SINGA with 1, 2, 4, and 8 machines per group, and also 4 orders of magnitude for the learning rate \u03b7 in each case. All runs were also for 10 minutes, and then as with MXNet the best one was run to convergence.\nFor Omnivore we ran our optimizer, which merged the FC compute and model servers to one machine and used the other 8 machines as conv compute machines. As with SINGA, the optimizer searched statically among 1, 2, 4 and 8 machines per group, but for 1 minute per execution setting. Overall the optimizer ran for less time than the tuning we did to ensure no divergence for MXNet and SINGA.\nWe followed the tutorials for each system and also ensured that all three systems used identical networks and parameters, including weight initializations and data preprocessing.\nThe network we use is CaffeNet, which is Caffe\u2019s version of Alexnet20. AlexNet is the standard network for ImageNet and Caffe is the most widely used CNN framework, so this ensures reproducibility. The weight initializations, batch size, regularization, and other hyperparameters are the same as CaffeNet, with a few minor differences:\nUnlike Caffe and SINGA, MXNet does not easily support learning rate and weight decay multipliers, or different initializations for each model and bias. For consistency across tools, we therefore just made all 3 tools use the same weight initialization scheme, which is Gaussian with mean 0 and standard deviation 0.01, and no multipliers.\n20 https://github.com/BVLC/caffe/blob/master/models/bvlc_\nreference_caffenet\nMXNet and SINGA do not support the grouping in AlexNet (which was done in 2012 to save GPU memory), so this is disabled from CaffeNet (and also is not important anymore as GPUs have more memory)\nNo random data preprocessing was used (crop, mirror), and we show convergence on the training set, not a test or validation set. We do this because these are machine learning concerns/optimizations and our focus is the system. We do subtract the image mean to avoid divergence.\nSimilarly, we disable the learning rate schedule in all tools and use a constant learning rate. We do this because we only train on a subset of ImageNet and to reduce the search space of the parameter configurations.\nThe following subsections describe in detail the individual settings used for each system to ensure fairness in our comparison.\nF.2.1 Detailed Settings for Both Systems For both systems we built in a wall-clock timer to ensure\naccurate timing. We created and shuffled the dataset using the tools provided by the systems: MXNet required shuffling beforehand, SINGA provided an im2rec utility. Those tools also were used to calculate the image mean: MXNet automatically generated the mean file when it ran and SINGA as part of im2rec. Because we focus on the training set we removed any validation set from the tools to ensure no time was spent on that. We used the provided AlexNet examples for each system and changed them only as above to ensure identical settings across all three systems (e.g. weight initializations, L2 regularization, etc.) Accuracy was reported instead of loss for all tools to ensure consistency. The MXNet examples do not report loss so we used their accuracy eval metric. Moreover MXNet\u2019s acc metric is by default on the entire epoch while SINGA\u2019s is since last time printing, so we averaged the logs to ensure consistency across all three tools.\nF.2.2 Detailed MXNET Settings and Results We removed all machine learning optimizations from both\ntools except those described above. For MXNet this meant removing gradient clipping. Because we ensure the parameters are used for all tools, including the batch size (256 for CaffeNet), this meant that for MXNet\u2019s dist sync strategy on 8 machines, a batch size of 32 was used, and for 32 machines, a batch size of 8 was used (other tools partition the batch size for the sync strategy, i.e. they partition b images by sending b/N to each sync worker, but MXNet uses that batch per worker, i.e. they use a batch size of b \u00d7 N). We fixed the random seed to 1 so the initialization is always the same.\nWe created a single data file and ensured that each worker read it from different location (using ImageRecordIter as in the AlexNet example). The timer was added as modified version of the speedometer callback (using time.time(), which is wall-clock time in python).\nWe used a cluster of 9 machines in these experiments because MXNet\u2019s AWS documentation instructs to \u201cPrepare a host file with all slavess private IPs\u201d. Therefore in order to test parallelism across 8 machines, we opened 9 EC2 machines, ran MXNet from the master (root) machine, and placed the other 8 machines in the hosts file.\nOn the cluster of 9 c4.4xlarge machines we ran the 4 orders of magnitude learning rate for each execution strategy and\nnoticed after 10 minutes that the best was learning rate 0.01 and sync, so we ran until 99% convergence. We needed 4 orders of magnitude to ensure that the optimal setting was never on the \u201cboundary\u201d of the interval, i.e. the optimal \u03b7 we report was superior to an order of magnitude higher \u03b7 and lower \u03b7. For async no parameter setting had high accuracy after 10 minutes: The best sync was 60% in 10 min and the best async got to 20% in 10 min, in spite of better hardware efficiency for async (72 s per epoch async, 120 s per epoch sync). The best async was with learning rate 0.0001.\nOn the cluster of 9 g2.8xlarge machines (again following MXNet\u2019s documentation, 1 parameter server machine and 8 compute machines), we tried both cuDNN v3 and v4 and found no speed difference. Again we searched learning rate and found that 0.01, sync was best.\nOn the c4.4xlargs machines we ensured each worker was using all the cores, and on the g2.8xlarge machines that all 4 GPUs on each worker were utilized (using nvidia-smi).\nF.2.3 Detailed SINGA Settings and Results For SINGA, the timer built into TrainOneBatch. It also\nuses wall-clock time (clock gettime, same as Omnivore). Again we use the default AlexNet example with only small changes to make all weight initializations the same (as in MXNet), and to remove learning rate / weight decay multipliers (since not supported easily in MXNet).\nTuning parallelism within groups: we tried tuning partition dim for each layer. Specifically we first used the default, i.e. partition dim commented out (as in their AlexNet example). We then uncommented those recommended partition dim settings in the example (i.e. dim 0 or batch parallelism for convolution, and dim 1 or model parallelism for FC) and found no difference, so we left partition dim commented out as in the default AlexNet SINGA example.\nTuning parallelism across groups: To ensure different data for each worker we tried specifying a random skip in the data section but this made no difference. Documentation v0.1.0 suggested using random skip but in v0.2.0 (which we used) it was deprecated, so as with partition dim we left this out and used the default AlexNet SINGA example settings.\nNext, we had to select for each machine number of workers per process. For each machine, we tried 1 process of 8, 16, and 32 threads on a single machine. The number of physical cores is 8 on the c4.4xlarge, and virtual cores is 16 (nproc = 16). 16 was fastest so we used 16 workers per process.\nAs with MXNet we followed the documentation for SINGA and also included 8 machines in the hostfile. We ran 4 orders of magnitude for the learning rate as described above and found that 0.0001 and 4 groups of 2 machines each was best after 10 minutes. The result was noisy however, and looked similar to the distributed results in the \u201cSINGA: Putting Deep Learning in the Hands of Multimedia Users\u201d paper. We then ran the best configuration for but it did not converge in 3 hours (got to 70-80%).\nSINGA GPU distributed did not work at the time of this study so it is not included.\nF.2.4 Detailed Omnivore Settings and Results Omnivore was run using the same network and parameters\nas the systems above. The optimizer was run as described above in Appendix E. Each configuration was searched by\nthe optimizer for 1 minute and search time was reduced by pruning the space across staleness values. The second search phase was skipped (momentum granularity was 0.3). We fixed the random seed to 1 so the initialization is always the same. The overall optimizer time was less than the search time to avoid divergence in other tools.\nOn the CPU cluster, the strategy chosen was the same as with MXNet, i.e. sync with \u03b7 = 0.01. Momentum is untuned for both Omnivore and MXNet, i.e. 0.9, because our contribution is tuning momentum to compensate for staleness and sync has no staleness. Since the parameters and staleness are the same as MXNet, as expected Omnivore achieves the same statistical efficiency. However, it is 2.3\u00d7 faster in terms of hardware efficiency, for an overall end-toend convergence speedup of 2.3\u00d7. On the GPU cluster, the optimizer chose 2 groups of 4 m/g, and was 5.0\u00d7 faster to converge. The following section studies the benefits of the optimizer in more detail, and also examines how the tradeoffs change on a large cluster which has more options for execution strategies: for example, the extreme strategies of sync or async may not be sufficient for a larger cluster. This may prevent MXNet, which only supports these strategies, from scaling to a larger cluster."}, {"heading": "F.3 Detailed Tradeoff Space Analysis", "text": "This section analyzes the speedups observed in the previous section to understand the contribution of each tradeoff selection that the optimizer made. These tradeoffs include (1) execution strategy (number of groups), (2) optimizing hyper-parameters to compensate for staleness, and (3) physical plan (server to machine allocation).\nF.3.1 Penalty Definition Consider again Figure 7, which we\u2019ve replicated here for\nconvenience in Figure 25 and also shown momentum (note that when the optimal explicit momentum is 0, there is an associated SE penalty). Recall this figure showed the tradeoff for compute groups on the CPU-L cluster for an epoch of ImageNet 1000. The HE and SE plots were multiplied to produce the right-most plot of total time to reach a final loss.\nThe vertical axis of the SE figure in Figure 25 shows what we call the SE penalty, PSE(S), which is defined as the ratio of the # iterations needed to converge relative to the case of no staleness (S = 0),\nPSE(S) = SE(S)\nSE(0) (9)\nPSE is dimensionless, because it is the ratio of statistical efficiencies (#iter / #iter). The penalty is 1 when the stal-\neness is 0, and should be higher for all S > 0. A higher PSE is worse (more iterations to converge).\nRecall also that we defined hardware efficiency penalty (PHE). This is shown in the middle graph of Figure 25. Since the statistical efficiency penalty is defined as the ratio of the # iterations to convergence with respect to S = 0, for consistency PHE(S) is also normalized with respect to S = 0. S = 0 is the case of 1 compute group, also called the synchronous case. The hardware efficiency penalty is defined as the ratio of the time per iteration relative to the time per iteration for this synchronous case,\nPHE(S) = HE(S)\nHE(0) (10)\nAs with PSE , a higher PHE is worse (more time per iteration). Whereas PSE(S) increased with staleness, for hardware efficiency this trend is reversed: PHE decreases (iterations become faster) as the number of compute groups increases.\nNote in these figures, the staleness is 0 for the FC model, so staleness on the horizontal axis refers only to the conv models (i.e. the number of conv compute groups).\nFinally, recall that the product of hardware and statistical efficiency is the total time to convergence (Equation 1). Since the horizontal axis (staleness, i.e. # groups) is the same on both the SE and HE plots, these plots can be multiplied, and the resulting vertical axis is the total penalty, defined as the ratio of the total time to convergence (normalized to sync, i.e. S = 0):\nPTotal(S) = PSE(S) \u00b7 PHE(S) = SE(S) \u00b7HE(S) SE(0) \u00b7HE(0) (11)\nWe use figures of this format throughout this section to quantify the benefit of the choice of compute groups.\nF.3.2 End-to-End Imagenet 1000 Recall that Figure 25 was run for a 1-hour optimizer epoch\nof Imagenet 1000, on the CPU-L cluster. Figure 26 (bottom 2 sets of figures) shows the same experiment on the GPU-S cluster. Notice again that SE is flat, i.e. maximum asynchrony is optimal.\nThese figures show steady-state execution, hence the SE curves show no penalty (nearly flat). The same curves but for the cold-start epoch of the GPU-S cluster are shown in the top of Figure 26.\nWe also validate this for the small cifar dataset in Figure 27. Here for exposition we reduced the epoch size to 2 minutes (otherwise the cold start would converge after only a few minutes).\nF.3.3 Small Clusters The optimizer\u2019s choice of execution strategy for the small\ncluster experiments is shown in Figure 28 (CPU-S) and Figure 29 (GPU-S). In addition to the imagenet-8 dataset we also include CIFAR-10 to show the optimizer is robust across datasets. We see that for these small clusters, choosing the execution strategy incorrectly incurs a penalty of roughly 1.5\u00d7.\nNote that Figure 28 and Figure 29 have the same statistical efficiency curves but different hardware efficiency curves. This is because the difference in throughput between the GPU machines and CPU machines exceeds the difference in network speed between these clusters so there is a higher\npenalty for the sync case on the GPU cluster. Also, neither of these 9 machine clusters reach FC saturation.\nNext we consider the CPU-L cluster.\nF.3.4 Large Cluster The tradeoff for CPU-L is shown in Figure 30. 4 groups\n(8 machines per group) was the optimal point, and that the optimizer chose this execution strategy. The detailed tradeoff space for CPU-L is analyzed in Figure 31. Each curve, from the bottom up, represents a selection made by the optimizer. We\u2019ve isolated each selection to observe their relative impact.\nAvoiding Divergence. First, consider the red line, which represents the default point chosen by many systems: asynchronous with a large number of machines. Indeed, statistical efficiency is often ignored by other systems and so by default, the configuration with the best hardware efficiency (fastest iteration time) is erroneously selected. However if the published AlexNet hyper-parameters [17] (which are optimal for the sync case) are naively used in the async case, there is divergence. Thus, our tuning approach is critical.\nThe green curve shows that if only the learning rate \u03b7 is tuned, divergence can be avoided. Tuning \u03b7 is also common practice, although prior work does not do so explicitly to compensate for staleness as we advocate. In the green curve momentum is not been tuned, as many systems always use a momentum of 0.9 (as mentioned in [17]). For example, at the time of this study MXNet hard-codes this momentum into every example 21.\n21 https://github.com/dmlc/mxnet/blob/\n52ea0f0cbbf5eaaf38a2341e57afd6829f88a86d/example/imageclassification/train_model.py#L77\nAlso, the green curve does not merge the FC compute and model servers by physically mapping them to the same machine. Instead, this curve represents the architecture shown in Figure 16 (a), i.e. there is an FC compute server for each CONV compute server, and each of these server pairs is mapped to a separate machine. Of the 33 machines therefore, one machine contains the CONV and FC model servers, while each of the other 32 contains a CONV compute and FC compute server. This configuration represents the strategy chosen by MXNet, so we report their async curve as the green line because their system is optimized for this case (note that doing this disadvantages our final speedup figure, i.e. if we had used Omnivore\u2019s implementation of this tradeoff point our optimizer\u2019s speedup would be > 20\u00d7). The remaining curves have their hardware and statistical efficiencies normalized to those of this green curve.\nDevice Mapping. We now examine our choice of merging the FC compute and model servers to the same machine (the 33rd machine), as Section 5 described. The other systems do not support this merging so we take \u201cunmerged\u201d as the baseline, and use the 33rd machine for the conv and FC model servers as MXNet and SINGA\u2019s documentation suggests. The remaining curves will have their hardware and statistical efficiencies normalized to those of this curve.\nThe turquoise curve merges the FC servers. We see that this gives a 1.18\u00d7 improvement to hardware efficiency (due to reduced communication) and a 2.55\u00d7 improvement to statistical efficiency (due to no staleness in the FC model). Overall, this is 3.01\u00d7 faster to converge than the baseline.\nIn the turquoise curve, note that the hardware efficiency improvement is only 1.18\u00d7 for the merged FC. As discussed\nin Section 4.1, this is because while communication is reduced by merging these servers, on the large CPU cluster the FC saturation point is reached at 4 groups, and not mapping the FC servers to the same physical machine as described above eliminates the saturation (but requires more network communication and incurs a statistical efficiency penalty).\nParameter Tuning for Staleness. Divergence can always be avoided by tuning \u03b7 alone, and indeed most systems always use a momentum of 0.9 (see comment above) which is standard for the sync case [17]. However, we show in the purple curve that at larger staleness values, additionally tuning the momentum \u00b5 permits using a higher \u03b7. This does not change hardware efficiency, but now gives an overall 5.85\u00d7 speedup over the baseline due to improved statistical efficiency.\nExecution Strategy. Finally, the blue line represents the actual choice made by the optimizer. In addition to the selections above, the optimizer did not choose 32 groups but 4 groups (Figure 30), which further improves the statistical efficiency to give an overall speedup of > 20\u00d7 compared to standard choices traditionally made by deep learning systems. Note that changing the number of groups to 4 did not hurt hardware efficiency because the FC server is already saturated (see Section 4.1)."}, {"heading": "F.4 Scalability to a Larger Cluster", "text": "The previous section showed that as a result of the optimizer\u2019s tradeoffs Omnivore is able to scale to 32 machines. In this final experiment we compare Omnivore to the best competitor from the small clusters, MXNet, on this larger cluster. We use the same dataset and network as the small cluster experiments, and define convergence the same way (99% accuracy).\nWe attemped to open a cluster of 33 g2.8xlarge instances but continuously ran into EC2 errors related to not enough machines available (InsufficientInstanceCapacity).\nAs in Section 6.2, we repeat the same procedure to apply our optimizer to MXNet, i.e. we run each configuration for 10 minutes, select the best execution strategy and learning rate, and run that to convergence. The best strategy was once again sync with \u03b7 = 0.01. Specifically, as in the previous experiments, we followed MXNet\u2019s documentation and used the EC2 master machine as the root, and put the other 32 workers in the hostfile. We ran MXNet for 10 minutes with both sync/async and 4 orders of magnitude learning rate as described above. This time all 4 orders of magnitude for \u03b7 were needed because for sync with 32 machines, after 10 minutes 0.001 and 0.01 were almost the same, although 0.001 was better by \u223c 5% points. Since this differed from the optimal \u03b7 from the 8 machine case, which was 0.01 (i.e. statistical efficiency changed for the larger cluster), to be sure we ran MXNet with each \u03b7 to convergence and noticed that in fact 0.01 was significantly faster to converge in the end, as was true on the smaller clusters. Similarly, for async after 10 minutes the best \u03b7 was 0.00001, although this was close to 0.0001, therefore once again we ran both to convergence and noticed that 0.0001 was faster to con-\nverge for MXNet. We did not do this extended parameter tuning for Omnivore, and only ran the 1 minute static runs described above, to make sure that we were getting the best possible performance from MXNet for our comparison.\nFor Omnivore the optimizer was used as described in the previous section. The best result of MXNet and Omnivore is shown in Figure 12(c). We see that Omnivore is 3.2\u00d7 faster than MXNet to converge now (it was 2.3\u00d7 faster on the 9 CPU cluster). In addition, we see that compared to Figure 12(a), Omnivore sped up on the larger cluster but MXNet did not. Therefore not only does the optimizer give speedups by not relying solely on the sync strategy and by merging the FC servers, but also enables scalability to more machines.\nIf we do not apply our optimizer to MXNet, Omnivore now converges 20\u00d7 faster. This is compared to MXNet\u2019s async strategy, which has poor statistical efficiency for 32 machines. This 20\u00d7 corresponds exactly to the speedup in the previous section because the green curve in that section is MXNet using the async strategy (i.e. they are the same point in the tradeoff, see the discussion in Appendix F.3.) By applying our optimizer to MXNet we select the sync strategy instead, which lowers the gap with Omnivore to 3\u00d7 on this cluster. Therefore this section shows not only that the optimizer gives speedups of more than an order of magnitude, but that it is versatile and can be applied to existing tools."}, {"heading": "F.5 End-To-End Experiments", "text": "The end-to-end result is in Figure 10. We trained the standard CaffeNet (same setup as in Appendix F.2) using ImageNet-1000 on both systems using both the CPU-L and GPU-S clusters. We time out each run after 8 hours and report the training accuracy vs. time.\nAccording to MXNet\u2019s official performance tuning guideline 22, they recommend trying the sync strategy, but also state that \u201cif the model size is quite large or you use a large number of machines, you may want to use dist async\u201d. Immediately above, they describe large as \u201cmodels with size >> 100MB such as AlexNet and VGG.\u201d Because we are training AlexNet and use up to 33 machines, which may be considered large, then according to these instructions async could be the best choice. Because they do not provide an automatic mechanism to make this decision we followed this advice and tried both strategies, as we did above in section F.2. This required tuning the learning rate for each strategy. We used the optimal learning rate obtained for each strategy on ImageNet-8, as recommended by [3] which states that \u201cthe best way to determine the correct learning rates is to perform experiments using a small but representative sample of the training set\u201d. In addition, MXNet does not provide a learning rate schedule for their AlexNet example (as of the writing of this study) so we use the standard learning rate schedule of [17] which decreased the learning rate by 10\u00d7 when training plateaued.\nFor Omnivore, we ran the optimizer end-to-end. We ensure a 10% overhead by running the optimizer and then training for 10\u00d7 the optimizer time before rerunning the optimizer. Each time the optimizer runs, it searches momentum, \u00b5 and learning rate, \u03b7, either reducing one, reduc-\n22 https://github.com/dmlc/mxnet/tree/\ndb6f6a9418e5696b04be741a78a47ae877bb5505/example/imageclassification\ning both, or keeping them the same. On the GPU-S cluster, the first time the optimizer ran \u00b5 remained at 0.6 but \u03b7 decreased from 0.01 to 0.001. The second time, the parameters did not change. On the CPU-L cluster, the first optimizer run made the same choices: \u00b5 also began at 0.6, and remained 0.6, while \u03b7 decreased from 0.01 to 0.001. Following the second optimizer run, \u00b5 reduced from 0.6 to 0.3, and \u03b7 remained unchanged. Note that the cold-start (first) phase of the CPU-L run in Figure 10 shows a very large slope, and then after the optimizer run this slope decreases. In ongoing work we are exploring a slope-aware optimizer which would not rerun the optimizer at this point but continue the execution. With this change we expect the gap against competitor systems to increase significantly."}, {"heading": "F.6 Preliminary RNN/LSTM Result", "text": "To understand if our tradeoff applies more broadly, we implemented the Recurrent Neural Network model and LSTM proposed by Graves [11]. Following the same protocol as Figure 28 and using the CPU-S cluster, we see in Figure 32 that the tradeoff between statistical efficiency and hardware efficiency is comparable, and choosing a completely synchronous or asynchronous configuration can be up to 2\u00d7 slower than the optimal configuration. 23"}, {"heading": "F.7 Comparison to Standard Schedules", "text": "We have shown that tuning is critical for good performance. We next validate the hypothesis that Omnivore\u2019s optimizer outperforms standard tuning and parameter scheduling methods. To validate this, we run Omnivore on the full ImageNet using the standard CaffeNet. We run two versions of Omnivore: (1) Omnivore (Default Schedule), which uses CaffeNet\u2019s default learning rate schedule\n23 We also see a similar tradeoff in the LSTM variant proposed by\nGraves [11].\nthat decreases the learning rate by 10x every 100,000 iterations; and (2) Omnivore, which uses the standard Omnivore optimizer. To be fair, both versions use the same grid search strategies to select the optimal learning rate, momentum, and number of compute groups at the beginning. In addition, we run Omnivore for 10\u00d7 the optimizer time before it re-optimizes the parameters.\nFigure 33 shows the training loss vs. wall-clock time. The two plateaus shown in Omnivore correspond to the times Omnivore re-optimizes the parameters. The losses of both Omnivore (Default Schedule) and Omnivore decrease over time. However, after the first parameter re-tuning, Omnivore\u2019s loss starts to decrease more rapidly. Finishing at 36K seconds, Omnivore is 1.5\u00d7 faster to achieve the same loss as Omnivore (Default Schedule). Omnivore does not require the user to specify the number of iterations to run before re-optimize the parameters."}, {"heading": "F.8 Comparison to Bayesian Optimizer", "text": "We compare our simple optimizer with the state-of-the-art Bayesian optimization approach that explores the parameter space of CNNs. The results are shown in Figure 34. We follow Snoek et al. [22] to model the search space as (\u03b7, \u00b5, S,N) where N is the number of epochs to run. We use the same search space for (\u03b7, \u00b5, S) as in our optimizer and measure both the number of configurations and the total number of epochs that the Bayesian optimizer needs to run before finding a run that achieves an accuracy within 1% of the best loss after 1000 seconds.\nOur procedure is as follows. We first run Omnivore to obtain a run which reaches 99% convergence using the same dataset and cluster as in Figure 12 (b). This took 80 epochs. We then give the Bayesian optimizer N = 80 and it tries to fit \u03b7, \u00b5 and S in order to reach the lowest loss (highest accuracy) by 1000 seconds. It searchesN in the range 1, . . . , 80, \u00b5 in the range 0.0, 0.3, 0.6, 0.9, and learning rates in the range 0.1, 0.01, 0.001, 0.0001, 0.00001, i.e. the same as Omnivore searches.\nIt took the Bayesian optimizer on average 12 runs before finding a strategy which achieves accuracy within 10% of Omnivore\u2019s run. On average this takes 6\u00d7 more epochs than just training to convergence, which makes the Bayesian\napproach infeasible to run on Imagenet 1000 (whereas Omnivore\u2019s optimizer incurred only a 10% overhead).\nCompared with our optimizer, one difference is that we are using the first minute\u2019s execution as a proxy for a longer run, while on the other hand, Snoek et al. have the number of epochs to run as a parameter to explore and do not share information across runs. It is of course possible to use Bayesian optimization to guide our grid search for the first minute, however, it is future work to integrate this heuristic into the Bayesian optimization framework in a principled way."}, {"heading": "G. APPENDIX STUDYING TOTAL COST", "text": "OF OWNERSHIP (TCO)\nOur study showed that CNN training is compute-bound regardless of the compute device used. Given that we can now train CNNs on CPUs proportional to the CPU FLOPS, this opens new questions in total cost of ownership (TCO) for running CNN systems. We discuss those trends and changes.\nSingle Node: We compare the price of running Omnivore on a GPU instance (g2.2xlarge, $0.65/hr, 1.2 TFLOPS) and a CPU instance (c4.4xlarge, $0.838/hr, 0.7 TFLOPS) for the same number of iterations. As Figure 11 showed, Omnivore\u2019s speed on the c4.4xlarge instance is 0.57\u00d7 the speed of the g2.2xlarge instance. This ratio closely matches the FLOPS ratio 0.7/1.2. Therefore we observe that running on a CPU instance is 2.1\u00d7 more expensive than a GPU instance, due to the difference in the FLOPS/dollar ratio for these instances. This suggests that on cloud services such as Google Compute which do not have GPU instances, CPU-based deep learning is a viable and cost-effective option when using Omnivore. Moreover, organizations that can amortize the cost of CPUs in more ways than GPUs may find them to be a cheaper alternative.\nDistributed: In the distributed setting we consider again the case of 9 machines and compare Omnivore running on the GPU cluster (g2.8xlarge, $2.60 per machine-hr, 4.8 TFLOPS per machine) and CPU cluster (c4.4xlarge, $0.838 per machine-hr, 0.7 TFLOPS per machine). The difference in peak FLOPS between these clusters is 6.8\u00d7, and the speedup to convergence obtained by Omnivore on the GPU cluster compared to the CPU cluster is 5\u00d7\u2013note it is not quite 6.8\u00d7 because network speed does not scale with the node throughput. If we consider only hardware efficiency (since statistical efficiency is unrelated to the underlying hardware), the GPU cluster is 5.6\u00d7 faster than the CPU cluster, which is nearly the FLOPS ratio. As in the singlemachine case therefore it is only the FLOPS/dollar ratio which matters. The GPU cluster is more cost-effective, now by a factor of 1.8\u00d7.\nThese results show that CPU deep learning is not significantly different from GPU in terms of consumer cost, and it will be exciting to see how these trends change for future CPUs which have increased SIMD parallelism as well as newer GPUs which optimize for lower power. As SIMD processor bandwidth has been doubling in each generation, it seems that CPU training may indeed catch GPUs relatively soon.\nG.1 Distributed Calculation\nThe ratio of peak FLOPS of the GPU cluster / CPU cluster is 4.9/0.74 = 6.6. Considering the optimal points chosen by our optimizer, the CPU / GPU time to convergence is 5\u00d7. If statistical efficiency is ignored, and we compare only the speeds of the async cases on each cluster, the ratio is now 34s/iter for the CPU cluster and 6 s/iter for the GPU, or 5.6\u00d7, which almost matches the ratio in device FLOPS. Given that GPU cluster is $2.6/$0.838 = 3.1\u00d7more expensive, the GPU cluster is 1.8\u00d7 cheaper per iteration which matches closely with the FLOPS/dollar ratio.\nH. APPENDIX FOR CONCLUSIONS (SECTION 8)\nOur study first demonstrated that on a single machine we could achieve CPU speeds proportional to the device FLOPS, showing end-to-end speedups of more than 5.5\u00d7 on EC2 CPU instances over state-of-the-art tools. With this improved CPU speed we showed that CNN computations are compute-bound. This allows the underlying hardware in a machine to be treated as a black-box, and we are 2.7\u00d7 faster than other systems on 4 GPUs and also 15% faster on a single GPU by using the weak CPU alongside the EC2 instance\u2019s GPU. More generally, we show that each device or node in a cluster can be treated as a black-box that is characterized only by the throughput which it provides and\nis irrelevant to the type of hardware on that node (e.g. CPUs or GPUs).\nOur second contribution was an empirical study of the factors affecting time to convergence for distributed deep learning training, and a novel, theoretical characterization of asynchrony which demonstrates that by tuning algorithmic (explicit) momentum in SGD there is no statistical penalty associated with asynchronous execution. We justified this empirically. We defined a tradeoff space and demonstrated that the execution strategy and server architecture were key in reducing the total time to convergence. We further showed that all existing distributed deep learning systems fall somewhere along this tradeoff space, but do not optimize within the space.\nFinally, we studied each of these tradeoffs by decoupling their impact on hardware and statistical efficiency. This made it possible to study these factors in isolation and build an optimizer which optimizes within the tradeoff space. We showed both theoretically and empirically the need to jointly tune hyper-parameters with execution strategies in order to avoid slower convergence or divergence. We show that our optimizer provides a > 20\u00d7 reduction in time to convergence compared to other systems which select sub-optimal points in the space, and we also show that our optimizer is versatile by applying it to existing tools. In doing so, we close the gap between our system to 3\u00d7 faster than other systems, in some cases also preventing divergence in those other tools."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "We perform a study of the factors affecting training time in<lb>multi-device deep learning systems. Given a specification of<lb>a convolutional neural network, we study how to minimize<lb>the time to train this model on a cluster of commodity CPUs<lb>and GPUs. Our first contribution focuses on the single-node<lb>setting, in which we show that by using standard batching<lb>and data-parallel techniques throughput can be improved<lb>by at least 5.5\u00d7 over state-of-the-art systems when training<lb>on CPUs. This ensures an end-to-end training time directly<lb>proportional to the throughput of a device regardless of its<lb>underlying hardware, allowing each node in the cluster to be<lb>treated as a black box. Our second contribution is a theoret-<lb>ical and empirical study of the tradeoffs affecting end-to-end<lb>training time in a multiple-device setting. We identify the<lb>degree of asynchronous parallelization as a key feature af-<lb>fecting both hardware and statistical efficiency. We show<lb>that asynchrony can be viewed as introducing a momentum<lb>parameter, which we use to limit our search space; in turn,<lb>this leads to a simpler optimizer, which is our third contri-<lb>bution. Our optimizer involves a predictive model for the<lb>total time to convergence and selects an allocation of re-<lb>sources to minimize that time. We demonstrate that the<lb>most popular distributed deep learning systems fall within<lb>our tradeoff space but do not optimize within the space. By<lb>doing such optimization, our prototype runs 1.9\u00d7 to 12\u00d7<lb>faster than the fastest state-of-the-art systems.", "creator": "LaTeX with hyperref package"}}}