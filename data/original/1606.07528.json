{"id": "1606.07528", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Jun-2016", "title": "A Dynamic Epistemic Framework for Conformant Planning", "abstract": "In this paper, we introduce a lightweight dynamic epistemic logical framework for automated planning under initial uncertainty. We reduce plan verification and conformant planning to model checking problems of our logic. We show that the model checking problem of the iteration-free fragment is PSPACE-complete. By using two non-standard (but equivalent) semantics, we give novel model checking algorithms to the full language and the iteration-free language.", "histories": [["v1", "Fri, 24 Jun 2016 00:33:19 GMT  (70kb,D)", "http://arxiv.org/abs/1606.07528v1", "In Proceedings TARK 2015,arXiv:1606.07295"]], "COMMENTS": "In Proceedings TARK 2015,arXiv:1606.07295", "reviews": [], "SUBJECTS": "cs.AI cs.CC cs.LO", "authors": ["quan yu", "yanjun li", "yanjing wang"], "accepted": false, "id": "1606.07528"}, "pdf": {"name": "1606.07528.pdf", "metadata": {"source": "CRF", "title": "A Dynamic Epistemic Framework for Conformant Planning", "authors": ["Quan Yu", "Yanjun Li", "Yanjing Wang"], "emails": [], "sections": [{"heading": null, "text": "R. Ramanujam (Ed.): TARK 2015 EPTCS 215, 2016, pp. 298\u2013318, doi:10.4204/EPTCS.215.21\nA Dynamic Epistemic Framework for Conformant Planning\nQuan Yu Department of Computer Science, Sun Yat-sen University, China\nQiannan Normal College for Nationalities, China\nYanjun Li Department of Philosophy, Peking University, China\nFaculty of Philosophy, University of Groningen, The Netherlands\nYanjing Wang\u2217\nDepartment of Philosophy, Peking University, China\nIn this paper, we introduce a lightweight dynamic epistemic logical framework for automated planning under initial uncertainty. We reduce plan verification and conformant planning to model checking problems of our logic. We show that the model checking problem of the iteration-free fragment is PSPACE-complete. By using two non-standard (but equivalent) semantics, we give novel model checking algorithms to the full language and the iteration-free language."}, {"heading": "1 Introduction", "text": "Conformant planning is the problem of finding a linear plan (a sequence of action) to achieve a goal in presence of uncertainty about the initial state (cf. [29]). For example, suppose that you are a rookie spy trapped in a foreign hotel with the following map at hand:1\ns6 s7:Safe s8:Safe\ns1 r // s2 r // u OO s3 r // u OO s4:Safe r // u OO s5\nNow somebody spots you and sets up the alarm. In this case you need to move fast to one of the safe hiding places marked in the map (i.e., s7,s8 and s4). However, since you were in panic, you lost your way and you are not sure whether you are at s2 or s3 (denoted by the circle in the above graph). Now what should you do in order to reach a safe place quickly? Clearly, merely moving r or moving u may not guarantee your safety given the uncertainty. A simple plan is to move r first and then u, since this plan will take you to a safe place, no matter where you actually are initially. This plan is conformant since it does not require any feedback during the execution and it should work in presence of uncertainty about the initial state. More generally, a conformant plan should also work given actions with non-deterministic effects. Such a conformant plan is crucial when there are no feedbacks/observations available during the execution of the plan.2 Note that since no information is provided during the execution, the conformant plan is simply a finite sequence of actions without any conditional moves.\n\u2217Corresponding author 1It is a variant of the running example in [33]. 2In many other cases, feedbacks may be just too \u2018expensive\u2019 to obtain during a plan aiming for quick actions [8].\nAs discussed in [9, 25], conformant planning can be reduced to classical planning, the planning problem without any initial uncertainty, over the space of belief states. Intuitively, a belief state is a subset of the state space, which records the uncertainty during the execution of a plan, e.g., {s2,s3} is an initial belief state in the above example. In order to make sure a goal is achieved eventually, it is crucial to track the transitions of belief states during the execution of the plan, and this may traverse exponentially many belief states in the size of the original state space. As one may expect, conformant planning is computationally harder than classical planning. The complexity of checking the existence of a conformant plan is EXPSPACE-complete in the size of the variables generating the state space [19]. In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.g., [11, 12].\nBesides the traditional AI approaches, we can also take an epistemic-logical perspective on planning in presence of initial uncertainties, based on dynamic epistemic logic (DEL) (cf. e.g., [16]). The central philosophy of DEL takes the meaning of an action as the change it brings to the knowledge of the agents. Intuitively, this is what we need to track the belief states during the execution of a plan3. Indeed, in recent years, there has been a growing interest in using DEL to handle multi-agent planning with knowledge goals (cf. e.g., [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case. In particular, the event models of DEL (cf. [6]) are used to handle non-public actions that may cause different knowledge updates to different agents. In these DEL-based planning frameworks, states are epistemic models, actions are event models and the state transitions are implicitly encoded by the update product which computes a new epistemic model based on an epistemic model and an event model.\nOne advantage of this approach is its expressiveness in handling scenarios which require reasoning about agents\u2019 higher-order knowledge about each other in presence of partially observable actions. However, this expressiveness comes at a price, as shown in [7, 4], that multi-agent epistemic planning is undecidable in general. Many interesting decidable fragments are found in the literature [7, 24, 34, 1], which suggests that the single-agent cases and restrictions on the form of event models are the key to decidability. However, if we focus on the single-agent planning, a natural question arises: how do we compare such DEL approaches with the traditional AI planning? It seems that the DEL-based approaches are more suitable for planning with actions that change (higher-order) knowledge rather than planning with fact-changing actions, although the latter type of actions can also be handled in DEL. Moreover, the standard models of DEL are purely epistemic thus do not encode the temporal information of available actions directly. This may limit the applicability of such approaches to planning problems based on transition systems.\nIn this paper, we tackle the standard single-agent conformant planning problem over transition systems, by using the core idea of DEL, but not its standard formalism. Our formal framework is based on the logic proposed by Wang and Li in [33], where the model is simply a transition system with initial uncertainty as in the motivating example, and an action is interpreted in the semantics as an update on the uncertainty of the agent. Our contributions are summarized as follows:\n\u2022 A lightweight dynamic epistemic framework with a simple language and a complete axiomatization.\n\u2022 Non-trivial reduction of conformant planning to a model checking problem using our language with programs.\n3Here the belief states are actually about knowledge in epistemic logic.\n\u2022 Two novel model checking algorithms based on two alternative semantics for the proposed logic, which make the context-dependency in the original semantics explicit.\n\u2022 The complexity of model checking the iteration-free fragment of our language is PSPACE-complete. The model checking problem of the full language is in EXPTIME. The model checking problem of the conformant planning is in PSPACE.\nThe last result may sound contradictory to the aforementioned result that the complexity of conformant planning is EXPSPACE-complete. Actually, the apparent contradiction is due to the fact that the EXPSPACE complexity result is based on the number of state variables which require an exponential blow up to generate an explicit transition system that we use here. We will come back to this issue at the end of Section 4.3.\nOur approach has the following advantages compared to the existing planning approaches:\n\u2022 The planning goals can be specified as arbitrary formulas in an epistemic language. Extra plan constraints (e.g., what actions to use) can be expressed explicitly by programs in the language. Therefore it may cover a richer class of (conformant) planning problems compared to the traditional AI approach where a goal is Boolean.4\n\u2022 The plans can be specified as regular expressions with tests in terms of arbitrary EPDL formulas, which generalizes the knowledge-based programs in [18, 22].\n\u2022 By reducing conformant planning to a model checking problem in an explicit logical language, we also see the subtleties hidden in the planning problem. In principle, there are various model checking techniques to be applied to conformant planning based on this reduction.\n\u2022 Our logical language and models are very simple compared to the standard action-model based DEL approach, yet we can encode the externally given executability of the actions in the model, inspired by epistemic temporal logic (ETL) [17, 27].\n\u2022 Our approach is flexible enough to provide, in the future, a unified platform to compare different planning problems under uncertainty. By studying different fragments of the logical language and model classes, we may categorize planning problems according to their complexity.\nThe rest of the paper is organized as follows: We introduce our basic logical framework and its axiomatization in Section 2, and extend it in Section 3 with programs to handle the conformant planning. The complexity analysis of the model checking problems is in Section 4 and we conclude in Section 5 with future directions."}, {"heading": "2 Basic framework", "text": ""}, {"heading": "2.1 Epistemic action language", "text": "To talk about the knowledge of the agent during an execution of a plan, we use the following language proposed in [33].\n4The goal in the standard conformant planning is simply a set of different valuations of basic propositional variables. Our approach can even handle epistemic goals in negative forms, e.g., we want to make sure the agent knows something but does not know too much in the end.\nDefinition 2.1 (Epistemic Action Language (EAL)) Given a countable set A of action symbols and a countable set P of atomic proposition letters , the language EALAP is defined as follows: 5\n\u03c6 ::=> | p | \u00ac\u03c6 | (\u03c6 \u2227\u03c6) | [a]\u03c6 | K\u03c6 ,\nwhere p\u2208 P, a\u2208 A. The following standard abbreviations are used: \u22a5 :=\u00ac>, \u03c6\u2228\u03c8 :=\u00ac(\u00ac\u03c6\u2227\u00ac\u03c8),\u03c6\u2192 \u03c8 := \u00ac\u03c6 \u2228\u03c8,\u3008a\u3009\u03c6 := \u00ac[a]\u00ac\u03c6 , K\u0302\u03c6 := \u00acK\u00ac\u03c6 .\nK\u03c6 says that the agent knows that \u03c6 , and [a]\u03c6 expresses that if the agent can move forward by action a, then after doing a, \u03c6 holds. Throughout the paper, we fix some P and A, and refer to EALAP by EAL.\nThe size of EAL-formulas (notation |\u03d5|) is defined inductively: |>| = |p| = 1; |\u00ac\u03c6 | = 1+ |\u03c6 |; |\u03c6 \u2227 \u03c8| = 1+ |\u03c6 |+ |\u03c8|; |K\u03c6 | = |[a]\u03c6 | = 1+ |\u03c6 |. The set of subformulas of \u03c6 \u2208 EAL, denoted as sub(\u03c6), is defined as usual.\nDefinition 2.2 (Uncertainty map) Given P and A, a (multimodal) Kripke model N is a tuple \u3008S ,{Ra | a \u2208 A},V \u3009, where S is a non-empty set of states, Ra \u2286 S \u00d7S is a binary relation labelled by a, V : S \u2192 2P is a valuation function. An uncertainty map M is a Kripke model \u3008S ,{Ra | a \u2208 A},V \u3009 with a non-empty set U \u2286 S . Given an uncertainty map M , we refer to its components by SM , RaM , VM , and UM . A pointed uncertainty map M ,s is an uncertainty map M with a designated state s \u2208UM . We write s a\u2192 t for (s, t) \u2208Ra.\nIntuitively, a Kripke model encodes a map (transition system) and the uncertainty set U encodes the uncertainty that the agent has about where he is in the map. The graph mentioned at the beginning of the introduction is a typical example of an uncertainty map. Note that there may be non-deterministic transitions in the model, i.e., there may be t1 6= t2 such that s a\u2192 t1 and s a\u2192 t2 for some s, t1, t2.\nRemark 1 It is crucial to notice that the designated state in a pointed uncertainty map must be one of the states in the uncertainty set.\nDefinition 2.3 (Semantics) Given any uncertainty map M = \u3008S ,{Ra | a \u2208 A},V ,U \u3009 and any state s \u2208U , the semantics is defined as follows:\nM ,s > always M ,s p \u21d0\u21d2 s \u2208 V (p) M ,s \u00ac\u03c6 \u21d0\u21d2 M ,s 2 \u03c6 M ,s \u03c6 \u2227\u03c8 \u21d0\u21d2 M ,s \u03c6 and M ,s \u03c8 M ,s [a]\u03c6 \u21d0\u21d2 \u2200t \u2208 S : s a\u2192 t implies M |a, t \u03c6 M ,s K\u03c6 \u21d0\u21d2 \u2200u \u2208U : M ,u \u03c6\nwhere M |a = \u3008S ,{Ra | a \u2208 A},V ,U |a\u3009 and U |a = {r\u2032 | \u2203r \u2208U such that r a\u2192 r\u2032}. We say \u03c6 is valid (notation: \u03c6 ) if it is true on all the pointed uncertainty maps. For a action sequence \u03c3 = a1 . . .an, we write U |\u03c3 for (. . .((U |a1)|a2) . . .)|an . and write M |\u03c3 for (. . .((M |a1)|a2) . . .)|an .\nIntuitively, the agent \u2018carries\u2019 the uncertainty set with him when moving forward and obtains a new uncertainty set U |a. Note that here we differ from [33] where the updated uncertainty set is further\n5We do need unboundedly many action symbols to encode the desired problem in the later discussion of model checking complexity.\nrefined according to what the agent can observe at the new state. For conformant planning, we do not consider the observational power of the agent during the execution of a plan.\nLet us call the model mentioned in the introduction M , it is not hard to see that M |r and (M |r)|u are as follows:\ns6 s7:Safe s8:Safe\ns1 r // s2 r //\nu\nOO\ns3 r //\nu\nOO\ns4:Safe r //\nu\nOO\ns5\ns6 s7:Safe s8:Safe\ns1 r // s2 r //\nu\nOO\ns3 r //\nu\nOO\ns4:Safe r //\nu\nOO\ns5\nThus we have:\n\u2022 M ,s3 [r](Safe\u2227\u00acKSafe)\n\u2022 M ,s3 K[r][u](Safe\u2227KSafe)\nThe usual global model checking algorithm for modal logics labels the states with the subformulas that are true on the states. However, this cannot work here since the truth value of epistemic formulas on the states outside U is simply undefined. Moreover, the exact truth value of an epistemic formula on a state depends on \u2018how you get there\u2019, as the following example shows (the underlined states mark the actual states):\ns1 b //\na\ns3 : p\na\ns2\na\n<<\ns4\nb\u2192\ns1 b //\na\ns3 : p\na\ns2\na <<\ns4\ns1 b //\na\ns3 : p\na\ns2\na\n<<\ns4\na\u2192 a\u2192\ns1 b //\na\ns3 : p\na\ns2\na <<\ns4\nLet the left-hand-side model be M then it is clear that M |b,s3 K p while M |aa,s3 2 K p thus M ,s1 \u3008b\u3009K p\u2227\u3008a\u3009\u3008a\u3009\u00acK p. This shows that the truth value of an epistemic subformula w.r.t. a state in the model is somehow \u2018context-dependent\u2019, which requires new techniques in model checking. We will make this explicit in Section 4.3 when we discuss the model checking algorithm."}, {"heading": "2.2 Axiomatization", "text": "Following the axioms proposed in [33], we give the following axiomatization for EALw.r.t. our semantics:\nSystem SELA Axioms Rules TAUT all axioms of propositional logic MP \u03c6 ,\u03c6 \u2192 \u03c8 \u03c8 DISTK K(p\u2192 q)\u2192 (K p\u2192 Kq) NECK \u03c6 K\u03c6 DIST(a) [a](p\u2192 q)\u2192 ([a]p\u2192 [a]q) NEC(a) \u03c6\n[a]\u03c6\nT K p\u2192 p SUB \u03c6(p) \u03c6(\u03c8)\n4 K p\u2192 KK p\n5 \u00acK p\u2192 K\u00acK p\nPR(a) K[a]p\u2192 [a]K p\nNM(a) \u3008a\u3009K p\u2192 K[a]p\nwhere a ranges over A, p,q range over P. PR(\u00b7) and NM(\u00b7) denote the axioms of perfect recall and no miracles respectively (cf. [32]).\nNote that since we do not assume that the agent can observe the available actions, the axiom OBS(a) : K\u3008a\u3009>\u2228K\u00ac\u3008a\u3009> in [33] is abandoned. Due to the same reason, the axiom of no miracles is also simplified.\nWe show the completeness of SELA using a more direct proof strategy compared to the one used in [33].\nTheorem 2.1 SELA is sound and strongly complete w.r.t. EAL on uncertainty maps.\nProof: To prove that SELA is sound on uncertainty maps, we need to show that all the axioms are valid and all the inference rules preserve validity. Since the uncertainty set in an UM denotes an equivalent class, axioms T, 4 and 5 are valid; due to the semantics, the validity of axioms PR(\u00b7) and NM(\u00b7) can be proved step by step; others can be proved as usual.\nTo prove that SELA is strongly complete on uncertainty maps, we only need to show that every SELA-consistent set of formulas is satisfiable on some uncertainty map. The proof idea is that we construct an uncertainty map consisting of maximal SELA-consistent sets (MCSs), and then with the Lindenbaum-like lemma that every SELA-consistent set of formulas can be extended in to a MCS (we omit the proof here), we only need to prove that every formula holds on the MCS to which it belongs.\nFirstly, we construct a canonical Kripke model N c = \u3008S c,{Rca | a \u2208 A},V c\u3009 as follows:\n\u2022 S c is the set of all MCSs;\n\u2022 sRcat \u21d0\u21d2 \u3008a\u3009\u03c6 \u2208 s for any \u03c6 \u2208 t (equivalently \u03c6 \u2208 t for any [a]\u03c6 \u2208 s);\n\u2022 V c(p) = {s | p \u2208 s}.\nGiven s \u2208S c, we define U cs = {u \u2208S c | K\u03c6 \u2208 s iff K\u03c6 \u2208 u}, and it is obvious that s \u2208U cs . Thus we have that for each s \u2208S c, M cs = \u3008N c,U cs \u3009 is an uncertainty map, and M cs ,s is a pointed uncertainty map.\nSecondly, we prove the following claim.\nClaim 2.1 If s a\u2192 t, then we have U cs |a = U ct .\n\u2286: Assuming v \u2208 U cs |a, we need to show v \u2208 U ct , namely we need to show that K\u03c6 \u2208 v \u21d0\u21d2 K\u03c6 \u2208 t. Since v \u2208 U cs |a, we have that there is u \u2208 U cs such that uRcav. If K\u03c6 \u2208 t, it follows by axiom 4 that KK\u03c6 \u2208 t. Thus we have \u3008a\u3009KK\u03c6 \u2208 s. By axiom NM(a), it follows that K[a]K\u03c6 \u2208 s. By u\u2208U cs and axiom T, we have [a]K\u03c6 \u2208 u. It follows by uRcav that K\u03c6 \u2208 v. If K\u03c6 6\u2208 t, we have \u00acK\u03c6 \u2208 t. By axiom 5, we have K\u00acK\u03c6 \u2208 t. Similarly, we have \u00acK\u03c6 \u2208 v. Thus we have K\u03c6 6\u2208 v. \u2287: Assuming v \u2208U ct , we need to show v \u2208U cs |a, namely there is u \u2208U cs such that uRcav. Let u\u2212 be {K\u03c6 | K\u03c6 \u2208 s}\u222a{\u3008a\u3009\u03c8 | \u03c8 \u2208 v}. Then u\u2212 is consistent. For suppose not, we have ` K\u03c61\u2227 \u00b7\u00b7 \u00b7\u2227K\u03c6n\u2192 [a]\u00ac\u03c81\u2228 \u00b7\u00b7 \u00b7\u2228 [a]\u00ac\u03c8k for some n and k. Since ` [a]\u00ac\u03c81\u2228 \u00b7\u00b7 \u00b7\u2228 [a]\u00ac\u03c8k\u2192 [a](\u00ac\u03c81\u2228 \u00b7\u00b7 \u00b7\u2228\u00ac\u03c8k), we have ` K\u03c61 \u2227 \u00b7\u00b7 \u00b7 \u2227K\u03c6n \u2192 [a](\u00ac\u03c81 \u2228 \u00b7\u00b7 \u00b7 \u2228\u00ac\u03c8k). By rule NECK and axiom DISTK, we have ` KK\u03c61 \u2227 \u00b7\u00b7 \u00b7 \u2227 KK\u03c6n\u2192 K[a](\u00ac\u03c81\u2228\u00b7\u00b7 \u00b7\u2228\u00ac\u03c8k). Since KK\u03c6i \u2208 s for each 1\u2264 i\u2264 n, we have K[a](\u00ac\u03c81\u2228\u00b7\u00b7 \u00b7\u2228\u00ac\u03c8k) \u2208 s. By axiom PR(a), it follows that [a]K(\u00ac\u03c81\u2228\u00b7\u00b7 \u00b7\u2228\u00ac\u03c8k)\u2208 s. It follows by sRcat that K(\u00ac\u03c81\u2228\u00b7\u00b7 \u00b7\u2228\u00ac\u03c8k)\u2208 t. Since v \u2208U ct , by axiom T, we have \u00ac\u03c81\u2228\u00b7\u00b7 \u00b7\u2228\u00ac\u03c8k \u2208 v. This is contrary with \u03c8i \u2208 v for each 1\u2264 i\u2264 k. Thus u\u2212 is consistent. By Lindenbaum-like Lemma, there exists a MCS u extending u\u2212. It follows by u\u2212 \u2286 u that u \u2208U cs and uRcav. We conclude that v \u2208U cs |a.\nFinally, we will show that M cs ,s \u03c6 iff \u03c6 \u2208 s. we prove it by induction on \u03c6 . Please note that the \u2018existence lemmas\u2019 (that \u00ac[a]\u03c6 \u2208 s implies \u00ac\u03c6 \u2208 t for some t such that s a\u2192 t and that \u00acK\u03c6 \u2208 s implies \u00ac\u03c6 \u2208 s\u2032 for some s\u2032 \u2208U cs ) also hold in the model N c. We only focus on the case of [a]\u03c6 . With Claim 2.1, it follows that M ct = M c s |a if s\na\u2192 t. Then by the induction hypothesis and the existence lemmas, it is easy to show that M cs ,s [a]\u03c6 iff [a]\u03c6 \u2208 s."}, {"heading": "3 An extension of EAL for conformant planning", "text": ""}, {"heading": "3.1 Epistemic PDL over uncertainty maps", "text": "In this section we extend the language of EAL with programs in propositional dynamic logic and use this extended language to express the existence of a conformant plan.\nDefinition 3.1 (Epistemic PDL) The Epistemic PDL Language (EPDL) is defined as follows:\n\u03c6 ::=> | p | \u00ac\u03c6 | (\u03c6 \u2227\u03c6) | [\u03c0]\u03c6 | K\u03c6 \u03c0 ::= a | ?\u03c6 | (\u03c0;\u03c0) | (\u03c0 +\u03c0) | \u03c0\u2217\nwhere p \u2208 P, a \u2208 A. We use L\u03c0M\u03c6 to denote [\u03c0]\u03c6 \u2227\u3008\u03c0\u3009\u03c6 , which is logically equivalent to [\u03c0]\u03c6 \u2227\u3008\u03c0\u3009>. Given a finite B\u2286 A, we write B\u2217 for (\u03a3a\u2208Ba)\u2217, i.e., the iteration over the \u2018sum\u2019 of all the action symbols in B. The size of EPDL formulas/programs is given by: |[\u03c0]\u03c6 |= |\u03c0|+ |\u03c6 |, |a|= 1, |\u03c01;\u03c02|= 1+ |\u03c01|+ |\u03c02|, |?\u03c6 |= |\u03c0\u2217|= 1+ |\u03c6 |, and |\u03c01 +\u03c02|= 1+ |\u03c01|+ |\u03c02|.\nGiven any uncertainty map M = \u3008S ,{Ra | a \u2208 A},V ,U \u3009, any state s \u2208U , the semantics is given by a mutual induction on \u03c6 and \u03c0 (we only show the case about [\u03c0]\u03c6 , other cases are as in EAL):\nM ,s [\u03c0]\u03c6\u21d4 for all M \u2032,s\u2032 : (M ,s)J\u03c0K(M \u2032,s\u2032) implies M \u2032,s\u2032 \u03c6\n(M ,s)JaK(M \u2032,s\u2032)\u21d4M \u2032 = M |a and s a\u2192 s\u2032 (M ,s)J?\u03c8K(M \u2032,s\u2032)\u21d4 (M \u2032,s\u2032) = (M ,s) and M ,s \u03c8\n(M ,s)J\u03c01;\u03c02K(M \u2032,s\u2032)\u21d4 (M ,s)J\u03c01K\u25e6 J\u03c02K(M \u2032,s\u2032) (M ,s)J\u03c01 +\u03c02K(M \u2032,s\u2032)\u21d4 (M ,s)J\u03c01K\u222a J\u03c02K(M \u2032,s\u2032)\n(M ,s)J\u03c0\u2217K(M \u2032,s\u2032)\u21d4 (M ,s)J\u03c0K?(M \u2032,s\u2032)\nwhere \u25e6,\u222a, ? at the right-hand side denote the usual composition, union and reflexive transitive closure of binary relations respectively. Clearly this semantics coincides with the semantics of EAL on EAL formulas.\nNote that each program \u03c0 can be viewed as a set of computation sequences, which are sequences of actions in A and tests with \u03c6 \u2208 EPDL:\nL (a) = {a} L (?\u03c6) = {?\u03c6} L (\u03c0;\u03c0 \u2032) = {\u03c3\u03b7 | \u03c3 \u2208L (\u03c0) and \u03b7 \u2208L (\u03c0 \u2032)} L (\u03c0 +\u03c0 \u2032) = L (\u03c0)\u222aL (\u03c0 \u2032) L (\u03c0\u2217) = {\u03b5}\u222a \u22c3 n>0(L (\u03c0 \u00b7 \u00b7 \u00b7\u03c0\ufe38 \ufe37\ufe37 \ufe38\nn\n)) where \u03b5 is the empty sequence\nHere are some valid formulas which are useful in our latter discussion: \u3008\u03c0;\u03c0 \u2032\u3009\u03c6 \u2194 \u3008\u03c0\u3009\u3008\u03c0 \u2032\u3009\u03c6 [\u03c0 +\u03c0 \u2032]\u03c6 \u2194 [\u03c0]\u03c6 \u2227 [\u03c0 \u2032]\u03c6 [?\u03c8]\u03c6 \u2194 (\u03c8 \u2192 \u03c6 ) We leave the complete axiomatization of EPDL on uncertainty maps to future work."}, {"heading": "3.2 Conformant planning via model checking EPDL", "text": "Definition 3.2 (Conformant planning) Given an uncertainty map M , a goal formula \u03c6 \u2208 EPDL, and a set B\u2286 A, the conformant planning problem is to find a finite (possibly empty) sequence \u03c3 = a1a2 \u00b7 \u00b7 \u00b7an \u2208 L (B\u2217) such that for each u \u2208UM we have M ,u La1MLa2M \u00b7 \u00b7 \u00b7LanM\u03c6 . The existence problem of conformant planning is to test whether such a sequence exists.\nRecall that L\u03c0M\u03c6 is the shorthand of [\u03c0]\u03c6 \u2227\u3008\u03c0\u3009\u03c6 . Intuitively, we want a plan which is both executable and safe w.r.t. non-deterministic actions and initial uncertainty of the agent. It is crucial to observe the difference between La1MLa2M \u00b7 \u00b7 \u00b7LanM\u03c6 and La1;a2; \u00b7 \u00b7 \u00b7 ;anM\u03c6 by the following example: Example 1 Given uncertainty map M depicted as follows, we have M ,s1 La;bMp but M ,s1 2 LaMLbMp.\ns2 b // s4 : p\ns1 a 66\na (( s3\nGiven M and \u03c6 , to verify whether \u03c3 \u2208L (\u03c0) is a conformant plan can be formulated as the model checking problem: M ,u KLa1MLa2M \u00b7 \u00b7 \u00b7LanM\u03c6 . On the other hand, the existence problem of a conformant plan is more complicated to formulate: it asks whether there exists a \u03c3 \u2208 L (B\u2217) such that it can be verified as a conformant plan. The simple-minded attempt would be to check whether M ,u K\u3008B\u2217\u3009\u03c6 holds. Despite the \u3008\u00b7\u3009-vs.-L\u00b7M distinction, K\u3008B\u2217\u3009\u03c6 may hold on a model where the sequences to guarantee \u03c6 on different states in UM are different, as the following example shows:\nExample 2 Given uncertainty map M depicted as follows, let the goal formula be p and B= {a,b}. We have M ,s1 K\u3008B\u2217\u3009p, but there is no solution to this conformant planning problem.\ns1 a // s3 b // s5 : p\ns2 b // s4 a // s6 : p\nThe right formula to check for the existence of a conformant plan w.r.t. B\u2286 A and \u03c6 \u2208 EPDL is:\n\u03b8B,\u03c6 = \u3008(\u03a3a\u2208B(?K\u3008a\u3009>;a))\u2217\u3009K\u03c6 .\nFor example, if B = {a1,a2} then \u03b8B,\u03c6 = \u3008((?K\u3008a1\u3009>;a1)+ (?K\u3008a2\u3009>;a2))\u2217\u3009K\u03c6 . Intuitively, the confrmant plan consists of actions that are always executable given the uncertainty of the agent (guaranteed by the guard K\u3008a\u3009>). In the end the plan should also make sure that \u03c6 must hold given the uncertainty of the agent (guaranteed by K\u03c6 ). In the following, we will prove that this formula is indeed correct.\nFirst, we observe that the rule of substitution of equivalents is valid (\u03c6(\u03c8/\u03c7) is obtained by replacing any occurrence of \u03c7 by \u03c8 , similar for J\u03c0(\u03c8/\u03c7)K): Proposition 3.1 If \u03c8 \u2194 \u03c7 , then:\n(1) \u03c6 \u2194 \u03c6(\u03c8/\u03c7); (2) J\u03c0K = J\u03c0(\u03c8/\u03c7)K.\nProposition 3.2 KLaM\u03c6 \u2194 \u3008?K\u3008a\u3009>;a\u3009K\u03c6 Proof: Since KLaM\u03c6 \u2194 (K[a]\u03c6 \u2227K\u3008a\u3009\u03c6) and (K\u3008a\u3009>\u2227\u3008a\u3009K\u03c6)\u2194 \u3008?K\u3008a\u3009>;a\u3009K\u03c6 , we only need to show that (K[a]\u03c6 \u2227K\u3008a\u3009\u03c6)\u2194 (K\u3008a\u3009>\u2227\u3008a\u3009K\u03c6).\nLeft to right: (L1) K[a]\u03c6 \u2192 [a]K\u03c6 , by validity of Axiom PR(a) (L2) K\u3008a\u3009\u03c6 \u2192 \u3008a\u3009>\u2227K\u3008a\u3009>, by semantics (L3) \u3008a\u3009>\u2227 [a]K\u03c6 \u2192 \u3008a\u3009K\u03c6 , by semantics (L4) K[a]\u03c6 \u2227K\u3008a\u3009\u03c6 \u2192 K\u3008a\u3009>\u2227\u3008a\u3009K\u03c6 , by (L1)-(L3) Right to left: (R1) \u3008a\u3009K\u03c6 \u2192 K[a]\u03c6 , by validity of Axiom NM(a) (R2) K[a]\u03c6 \u2227K\u3008a\u3009>\u2192 K\u3008a\u3009\u03c6 , by semantics (R3) K\u3008a\u3009>\u2227\u3008a\u3009K\u03c6 \u2192 K[a]\u03c6 \u2227K\u3008a\u3009\u03c6 , by R(1)-R(2)\nLemma 3.1 For any a1a2 \u00b7 \u00b7 \u00b7an \u2208L (A\u2217):\nKLa1MLa2M \u00b7 \u00b7 \u00b7LanM\u03c6 \u2194 \u3008?K\u3008a1\u3009>;a1; . . . ; ?K\u3008an\u3009>;an\u3009K\u03c6 Proof: It is trivial when n = 0 (i.e., the sequence is \u03b5), since the claim then boils down to K\u03c6 \u2194 K\u03c6 . We prove the non-trivial cases by induction on n\u2265 1. When n = 1, it follows from Proposition 3.2. Now, as the induction hypothesis, we assume that:\nKLa1MLa2M \u00b7 \u00b7 \u00b7LakM\u03c6 \u2194 \u3008?K\u3008a1\u3009>;a1; . . . ; ?K\u3008ak\u3009>;ak\u3009K\u03c6 . We need to show:\nKLa1MLa2M \u00b7 \u00b7 \u00b7Lak+1M\u03c6 \u2194 \u3008?K\u3008a1\u3009>;a1; . . . ; ?K\u3008ak+1\u3009>;ak+1\u3009K\u03c6 . By IH,\nKLa1MLa2M \u00b7 \u00b7 \u00b7Lak+1M\u03c6 \u2194 \u3008?K\u3008a1\u3009>;a1; . . . ; ?K\u3008ak\u3009>;ak\u3009KLak+1M\u03c6 . (1) Due to Propositions 3.1 and 3.2, we have:\n\u3008?K\u3008a1\u3009>;a1; . . . ; ?K\u3008ak\u3009>;ak\u3009KLak+1M\u03c6 \u2194 \u3008?K\u3008a1\u3009>;a1; . . . ; ?K\u3008an\u3009>;ak\u3009\u3008?K\u3008ak+1\u3009>;ak+1\u3009K\u03c6 . (2) The conclusion is immediate by combining (1) and (2).\nThe following theorem follows from the above lemma.\nTheorem 3.1 Given a pointed uncertainty map M ,s, an EPDL formula \u03c6 and a set B\u2286 A, the following two are equivalent:\n(1) There is a \u03c3 = a1 . . .an \u2208L (B\u2217) such that M ,s KLa1MLa2M \u00b7 \u00b7 \u00b7LanM\u03c6 ; (2) M ,s \u3008(\u03a3a\u2208B(?K\u3008a\u3009>;a))\u2217\u3009K\u03c6 .\nWe would like to emphasise that the K operator right before \u03c6 in the definition of \u03b8B,\u03c6 cannot be omitted, as demonstrated by the following example:\nExample 3 Given uncertainty map M depicted as follows, let the goal formula be p. As we can see, there is no solution to this conformant planning problem. Indeed M ,s1 2 \u3008(\u03a3a\u2208B(?K\u3008a\u3009>;a))\u2217\u3009K p with B= {a,b}, but we could have M ,s1 \u3008(\u03a3a\u2208B(?K\u3008a\u3009>;a))\u2217\u3009p.\ns1 a // s2 b //\nb \"\"\ns5 : p\ns4\nWe close this section with an example about planning with both positive and negative epistemic goals (the agent should know something, but not too much).\nExample 4 Given uncertainty map M depicted as follows, let the goal be K p then both a and b are conformant plans. If the goal is K p\u2227\u00acKq, only a is a good plan.\ns1 a // b && s3 : p s2 a //\nb &&\ns4 : p,q\ns5 : p,q"}, {"heading": "4 Model checking EPDL: complexity and algorithms", "text": "In this section, we first focus on the model checking problem of the following star-free fragment of EPDL (call it EPDL\u2212):\n\u03c6 ::=> | p | \u00ac\u03c6 | (\u03c6 \u2227\u03c6) | [\u03c0]\u03c6 | K\u03c6 \u03c0 ::= a | ?\u03c6 | (\u03c0;\u03c0) | (\u03c0 +\u03c0)\nWe will show that model checking EPDL\u2212 is PSPACE-complete. In particular, the upper bound is shown by making use of an alternative context-dependent semantics. Then we give an EXPTIME algorithm for the model checking problem of the full EPDL inspired by another alternative semantics based on 2- dimensional models. Finally we give a PSPACE algorithm for the conformant planning problem in EPDL. Note that throughout this section, we focus on uncertainty maps with finitely many states and assume Ra = /0 for co-finitely many a \u2208 A."}, {"heading": "4.1 Complexity of model checking EPDL\u2212", "text": ""}, {"heading": "4.1.1 Lower Bound", "text": "To show the PSPACE lower bound, we provide a polynomial reduction of QBF (quantified Boolean formula) truth testing to the model checking problem of EPDL\u2212. Note that to determine whether a given\nQBF (even in prenex normal form based on a conjunctive normal form) is true or not is known to be PSPACE-complete [30]. Our method is inspired by [28] which discusses the complexity of model checking temporal logics with past operators. Surprisingly, we can use the uncertainty sets to encode the \u2018past\u2019 and use the dual of the knowledge operator to \u2018go back\u2019 to the past. This intuitive idea will become more clear in the proof.\nQBF formulas are Q1x1Q2x2 . . .Qnxn\u03c6(x1, . . . ,xn) where:\n\u2022 For 1\u2264 n\u2264 n,Qi is \u2203 if i is odd, and Qi is \u2200 if i is even.\n\u2022 \u03c6 is a propositional formula in CNF based on variables x1, . . . ,xn,\nFor each such QBF \u03b1 with n variables, we need to find a pointed model Mn,x0 and a formula \u03b8\u03b1 such that \u03b1 is true iff Mn,x0 \u03b8\u03b1 . The model Mn is defined below.\nDefinition 4.1 Let A= {ai, a\u0304i | i\u2265 1} and P= {pk,qk | k\u2265 1}, the uncertainty map Mn = \u3008S ,{Ra | a\u2208 A},V ,U \u3009 is defined as:\n\u2022 S = {x0}\u222a{xi | 1\u2264 i\u2264 n}\u222a{x\u0304i | 1\u2264 i\u2264 n}\n\u2022 V (x0) = /0, and V (xi) = {pi},V (x\u0304i) = {qi} for 1\u2264 i\u2264 n.\n\u2022 ai\u2192= {(s,s) | s \u2208S }\u222a{(xi\u22121,xi),(x\u0304i\u22121,xi)}\n\u2022 a\u0304i\u2192= {(s,s) | s \u2208S }\u222a{(xi\u22121, x\u0304i),(x\u0304i\u22121, x\u0304i)}\n\u2022 U = {x0}\n|Mn| is linear in n and can be depicted as the following:\nx1 : p1\nA\na2 //\na\u03042\nx2 : p2\nA\na3 //\na\u03043\n\u00b7 \u00b7 \u00b7 xn\u22121 : pn\u22121\nA\nan //\na\u0304n\nxn : pn\nA\nx0\nA a1 ::\na\u03041 ## x\u03041 : q1\nA\nWW a\u03042 //\na2\nAA\nx\u03042 : q2\nA\nWW a\u03043 //\na3\nDD\n\u00b7 \u00b7 \u00b7 x\u0304n\u22121 : pn\u22121 A WW a\u0304n //\nan\n>>\nx\u0304n : qn\nA\nWW\nGiven \u03b1 = Q1x1Q2x2 . . .Qnxn\u03c6(x1, . . . ,xn), the formula \u03b8\u03b1 is defined as\nQT1 \u00b7 \u00b7 \u00b7QTn\u03c8(K\u0302 p1, \u00b7 \u00b7 \u00b7 , K\u0302 pn, K\u0302q1, \u00b7 \u00b7 \u00b7 , K\u0302qn)\nwhere QTi is \u3008(ai+ a\u0304i); ?(pi\u2228qi)\u3009 if i is odd and QTi is [(ai+ a\u0304i); ?(pi\u2228qi)] if i is even, and \u03c8 is obtained from \u03c6(x1, . . . ,xn) by replacing each xi with K\u0302 pi and \u00acxi with K\u0302qi.\nTo ease the latter proof, we first define the valuation tree below.\nDefinition 4.2 (V-tree) A V-tree \u03c4 is a rooted tree such that 1) each node is 0 or 1 (except the root \u03b5); 2) each internal node in an even level has only one successor; 3) each internal node in an odd level has two successors: one is 0 and the other one is 1; 4) each edge to node 0 of level i is labelled a\u0304i; 5) each edge to node 1 of level i is labelled ai. Given a V-tree with depth n, a path \u03c3 is a sequence of A1 . . .An where Ai = ai or Ai = a\u0304i. A path \u03c3 can also be seen as a valuation assignment for x1, . . . ,xn with the convention that \u03c3(xi) = 1 if ai occurs in \u03c3 and \u03c3(xi) = 0 if a\u0304i occurs in \u03c3 . Let path(\u03c4) be the set of all paths of \u03c4 .\nAs an example, a V-tree \u03c4 can be depicted as below:\n\u03b5 a1 // 1 a\u03042 ))\na2 55\n0 a3 //\n1 a\u03043 //\n1\n0\nIt is not hard to see the following:\nProposition 4.1 For each 1\u2264 i\u2264 n, we have: \u03b1 = Q1x1 . . .QixiQi+1xi+1 . . .Qnxn\u03c6 is true iff there exists a V-tree \u03c4 with depth i such that for each \u03c3 \u2208 path(\u03c4) \u03c3(Qi+1xi+1 . . .Qnxn\u03c6) = 1 (\u03c3 as a valuation). Now let us see the update result of running a path \u03c3 \u2208 path(\u03c4) on Mn. Due to the lack of space, we omit the proofs of the following two propositions.\nProposition 4.2 Given Mn, let \u03c3 = A1 . . .Ai (1 \u2264 i \u2264 n) be a sequence of actions such that Ak = ak or Ak = a\u0304k for each 1 \u2264 k \u2264 i, then we have U |\u03c3 = {x0,X1, . . . ,Xi} where Xk = xk if Ak = ak else Xk = x\u0304k for each 1\u2264 k \u2264 i.\nGiven \u03c3 = A1 . . .An where Ai is ai or a\u0304i for each 1\u2264 i\u2264 n, let g(\u03c3) = xn if An = an and g(\u03c3) = x\u0304n if An = a\u0304n. By Proposition 4.2, we always have g(\u03c3)\u2208UMk |\u03c3 with k > n. Thus given Mk and \u03c3 =A1 . . .An and k > n, Mk|\u03c3 ,g(\u03c3) is a pointed uncertainty map.\nProposition 4.3 For each 1\u2264 i\u2264 n, we have Mk,x0 QT1 . . .QTiQTi+1 . . .QTn\u03c8 iff there exists a V-tree \u03c4 with depth i such that Mk|\u03c3 ,g(\u03c3) QTi+1 . . .QTn\u03c8 for each \u03c3 \u2208 path(\u03c4), where k > n and g(\u03c3) is the state corresponds to the last edge of \u03c3 , e.g., g(a1a\u03042) = x\u03042.\nTheorem 4.1 The following two are equivalent:\n\u2022 \u03b1 = Q1x1Q2x2 . . .Qnxn\u03c6(x1, . . . ,xn) is true \u2022 Mn,x0 QT1 \u00b7 \u00b7 \u00b7QTn\u03c8(K\u0302 p1 \u00b7 \u00b7 \u00b7 K\u0302 pn, K\u0302q1 \u00b7 \u00b7 \u00b7 K\u0302qn) in which \u03c8 is obtained from \u03c6 by replacing each\nxi with K\u0302 pi and \u00acxi with K\u0302qi.\nProof: By Propositions 4.1 and 4.3, we only need to show that given V-tree \u03c4 with depth n, \u03c3(\u03c6) = 1 if and only if Mn|\u03c3 ,g(\u03c3) \u03c8 for each \u03c3 \u2208 path(\u03c4). Since \u03c6 is in CNF, \u03c8 is also in CNF-like form obtained by replacing each xi with K\u0302 pi and each \u00acxi with K\u0302qi for 1\u2264 i\u2264 n. Thus we only need to show that \u03c3(xi)= 1 iff Mn|\u03c3 ,g(\u03c3) K\u0302 pi and \u03c3(\u00acxi)= 1 iff Mn|\u03c3 ,g(\u03c3) K\u0302qi. Since \u03c3(xi)= 1 iff \u03c3(\u00acxi)= 0, we only need to show that \u03c3(xi) = 1 iff Mn|\u03c3 ,g(\u03c3) K\u0302 pi and Mn|\u03c3 ,g(\u03c3) K\u0302 pi iff Mn|\u03c3 ,g(\u03c3) \u00acK\u0302qi. By the definition of \u03c4 , we know that \u03c3 = A1 . . .An where Ai is ai or a\u0304i for each 1\u2264 i\u2264 n.\nFirstly, we will show that Mn|\u03c3 ,g(\u03c3) K\u0302 pi if and only if Mn|\u03c3 ,g(\u03c3) \u00acK\u0302qi. To verify the rightto-left direction, if Mn|\u03c3 ,g(\u03c3) K\u0302 pi, it follows by the definition of Mn that xi \u2208 U |\u03c3 . Then it must be the case that ai occurs in \u03c3 . Suppose not, a\u0304i occurs in \u03c3 . It follows by Proposition 4.2, U |\u03c3 = {x0,X1, . . . ,Xi\u22121, x\u0304i,Xi+1, . . . ,Xn}. This is contrary with xi \u2208 U |\u03c3 . Thus it must be that ai occurs in \u03c3 . It follows by Proposition 4.2 that U |\u03c3 = {x0,X1, . . . ,Xi\u22121,xi,Xi+1, . . . ,Xn}. Thus x\u0304i 6\u2208 U |\u03c3 . By the definition of Mn and the semantics, we have Mn|\u03c3 ,g(\u03c3) \u00acK\u0302qi. To verify the left-to-right direction, Mn|\u03c3 ,g(\u03c3) \u00acK\u0302qi implies that x\u0304i 6\u2208 U |\u03c3 . For the similar reason as above, it must be the case that a\u0304i does not occur in \u03c3 . Thus we have that ai occurs in \u03c3 . It follows by Proposition 4.2 that xi \u2208U |\u03c3 . Thus we have Mn|\u03c3 ,g(\u03c3) K\u0302 pi.\nNext we will show that \u03c3(xi)= 1 iff Mn|\u03c3 ,g(\u03c3) K\u0302 pi. To verify the right-to-left direction, \u03c3(xi)= 1 implies that Ai = ai. It follows by Proposition 4.2 that xi \u2208 U |\u03c3 . Thus we have Mn|\u03c3 ,g(\u03c3) K\u0302 pi. To verify the left-to-right direction, we will show that \u03c3(xi) = 0 implies Mn|\u03c3 ,g(\u03c3) K\u0302qi. It follows by the definition of \u03c3(xi) = 0 that Ai = a\u0304i. It follows by Proposition 4.2 that x\u0304i \u2208 U |\u03c3 . Thus we have\nMn|\u03c3 ,g(\u03c3) K\u0302qi.\nThis gives us the desired lower bound:\nTheorem 4.2 The model checking problem for EPDL\u2212 is PSPACE-hard."}, {"heading": "4.1.2 Upper Bound", "text": "In this section we give a non-trivial model checking algorithm for EPDL\u2212 inspired by an equivalent semantics.\nAs we mentioned earlier, the semantics of EPDL is \u2018context-dependent\u2019: reaching the same state through different paths may affect the truth value of an epistemic subformula. This means that the usual global model checking algorithm for modal logics may not work here. In order to establish the upper bound, we first give the following equivalent semantics to EPDL\u2212 which makes the context dependency explicit in order to facilitate a local model checking algorithm. The idea is to keep the model intact but record the scope of action modalities in order to compute the right uncertainty set for epistemic subformulas. Similar idea appeared in [32] to give an alternative semantics of public announcement logic.\nDefinition 4.3 Given an uncertainty map M = \u3008S ,{Ra | a \u2208 A},V ,U \u3009 and any state s \u2208 S , the satisfaction relation is defined using the auxiliary satisfaction relation \u03c3 and auxiliary relation\n\u03c9\u03c3\u2192, where \u03c3 is a finite (possibly empty) sequence of actions in A:\nM ,s \u03c6 \u21d4M ,s \u03b5 \u03c6 M ,s \u03c3 > \u21d4 always M ,s \u03c3 p \u21d4 p \u2208 V (s) M ,s \u03c3 \u00ac\u03c6 \u21d4M ,s 1\u03c3 \u03c6 M ,s \u03c3 \u03c6 \u2227\u03c8\u21d4M ,s \u03c3 \u03c6 and M ,s \u03c3 \u03c8 M ,s \u03c3 K\u03c6 \u21d4 for all v \u2208U |\u03c3 : M ,v \u03c3 \u03c6 M ,s \u03c3 \u3008\u03c0\u3009\u03c6 \u21d4 there exists \u03c9 \u2208L (\u03c0) and t \u2208S\nsuch that s \u03c9\u03c3\u2192 t and M , t \u03c3r(\u03c9) \u03c6\ns \u03b5\u03c3\u2192 t \u21d4 s = t s (a\u03c9 \u2032)\u03c3\u2192 t \u21d4 there exists s\u2032 such that s a\u2192 s\u2032 and s\u2032\n\u03c9 \u2032(\u03c3a)\u2192 t s (?\u03c6\u03c9 \u2032)\u03c3\u2192 t \u21d4M ,s \u03c3 \u03c6 and s\n\u03c9 \u2032\u03c3\u2192 t where r(\u03c9) is the sequence of actions obtained by eliminating all the tests in \u03c9 .\nNote that \u03c9 in the above definition is a computation sequence, i.e., a finite sequence of actions and EPDL\u2212-tests, while \u03c3 is a test-free sequence of actions.\nThe following can be proved by induction on \u03b7 : Proposition 4.4 Given an uncertainty map M and sequences of actions and tests \u03b7 ,\u03c9,\u03c9 \u2032 such that \u03b7 = \u03c9\u03c9 \u2032, we have (s, t) \u2208\u03b7\u03c3\u2192 iff (s, t) \u2208\u03c9\u03c3\u2192\u25e6 \u03c9 \u2032\u03c3r(\u03c9)\u2192 for any sequence of actions \u03c3 .\nProof: We prove it by induction on |\u03b7 |. If |\u03b7 | \u2264 2, it is obvious by the definition. If |\u03b7 | > 2, there are two cases, that is, \u03b7 = a\u03b7 \u2032 or \u03b7 =?\u03c6\u03b7 \u2032.\nCase \u03b7 = a\u03b7 \u2032 : We have \u03c9 = a\u03c9 \u2032\u2032 for some initial segment \u03c9 \u2032\u2032 of \u03b7 \u2032, and (s, t) \u2208(a\u03b7 \u2032)\u03c3\u2192 iff there exists\ns\u2032 such that s a\u2192 s\u2032 and (s\u2032, t) \u2208\u03b7 \u2032 \u03c3a\u2192. By IH, we have \u03b7 \u2032 \u03c3a\u2192=\u03c9 \u2032\u2032 \u03c3a\u2192 \u25e6 \u03c9 \u2032\u03c3ar(\u03c9 \u2032\u2032)\u2192 . Thus we have (s\u2032, t) \u2208\u03b7 \u2032 \u03c3a\u2192 iff there\nexists t \u2032 such that (s\u2032, t \u2032) \u2208\u03c9 \u2032\u2032 \u03c3a\u2192 and (t \u2032, t) \u2208 \u03c9 \u2032\u03c3ar(\u03c9 \u2032\u2032)\u2192 . By definition, we have that s a\u2192 s\u2032 and (s\u2032, t \u2032) \u2208\u03c9 \u2032\u2032 \u03c3a\u2192 iff (s, t \u2032) \u2208a\u03c9 \u2032\u2032 \u03c3\u2192 . Thus we have (s, t) \u2208a\u03c9 \u2032\u2032 \u03c3\u2192 \u25e6 \u03c9 \u2032\u03c3ar(\u03c9 \u2032\u2032)\u2192 , namely (s, t) \u2208\u03c9\u03c3\u2192\u25e6 \u03c9 \u2032\u03c3r(\u03c9)\u2192 .\nCase \u03b7 =?\u03c6\u03b7 \u2032 : We have \u03c9 =?\u03c6\u03c9 \u2032\u2032 for some initial segment \u03c9 \u2032\u2032 of \u03b7 \u2032, and (s, t) \u2208(?\u03c6\u03b7 \u2032)\u03c3\u2192 iff M ,s \u03c3\n\u03c6 and s \u03b7 \u2032\u03c3\u2192 t. By IH, we have s \u03b7 \u2032 \u03c3\u2192 t iff (s, t) \u2208\u03c9 \u2032\u2032 \u03c3\u2192 \u25e6 \u03c9 \u2032\u03c3r(\u03c9 \u2032\u2032)\u2192 . Thus we have there exists s\u2032 such that (s,s\u2032) \u2208\u03c9 \u2032\u2032 \u03c3\u2192 and (s\u2032, t) \u2208 \u03c9 \u2032\u03c3r(\u03c9 \u2032\u2032)\u2192 . This follows that (s,s\u2032) \u2208(?\u03c6\u03c9 \u2032\u2032)\u03c3\u2192 , and (s, t) \u2208(?\u03c6\u03c9 \u2032\u2032)\u03c3\u2192 \u25e6 \u03c9 \u2032\u03c3r(?\u03c6\u03c9 \u2032\u2032)\u2192 , namely (s, t) \u2208\u03c9\u03c3\u2192\u25e6 \u03c9 \u2032\u03c3r(\u03c9)\u2192 .\nIn the following we show that coincides with .\nTheorem 4.3 Given an uncertainty map M and an action sequence \u03c3 , if U |\u03c3 6= /0, we have that for each s \u2208U |\u03c3 ,\n(i) M |\u03c3 ,sJ\u03c0KM \u2032,s\u2032 iff there exists \u03c9 \u2208L (\u03c0) such that M \u2032 = M |\u03c3r(\u03c9) and s \u03c9\u03c3\u2192 s\u2032, (ii) M |\u03c3 ,s \u03c6 iff M ,s \u03c3 \u03c6 .\nProof: The proof is by simultaneous induction on \u03c0 and \u03c6 (due to the test actions). For (i), we will only focus on the case of \u03c01;\u03c02; the other cases are straightforward.\nCase \u03c01;\u03c02: We only show the direction from left to right; the other direction is similar. It follows by assumption that there is pointed uncertainty map N , t such that M |\u03c3 ,sJ\u03c01KN , t and N , tJ\u03c02KM \u2032,s\u2032. By IH, we have that there exists \u03c9 \u2208L (\u03c01) such that N = M |\u03c3r(\u03c9) and s\n\u03c9\u03c3\u2192 t. Since N , t is a pointed uncertainty map and N =M |\u03c3r(\u03c9), we have t \u2208U |\u03c3r(\u03c9). By IH and M |\u03c3r(\u03c9), tJ\u03c02KM \u2032,s\u2032, we have that\nthere exists \u03c9 \u2032 \u2208L (\u03c02) such that M |\u03c3r(\u03c9)r(\u03c9 \u2032) = M |\u03c3r(\u03c9\u03c9 \u2032) = M \u2032 and t \u03c9 \u2032\u03c3r(\u03c9)\u2192 s\u2032. By Proposition 4.4, it follows that \u03c9\u03c9 \u2032 \u2208L (\u03c01;\u03c02) and s\n(\u03c9\u03c9 \u2032)\u03c3\u2192 s\u2032. For (ii), we will focus on the case of \u3008\u03c0\u3009\u03c6 ; the other cases are straightforward. Case \u3008\u03c0\u3009\u03c6 : We have M |\u03c3 ,s \u3008\u03c0\u3009\u03c6 if and only if there is pointed uncertainty map M \u2032,s\u2032 such that M |\u03c3 ,sJ\u03c0KM \u2032,s\u2032 and M \u2032,s\u2032 \u03c6 . By (i), it follows that M |\u03c3 ,sJ\u03c0KM \u2032,s\u2032 iff there exists \u03c9 \u2208L (\u03c0) such that M \u2032 = M |\u03c3r(\u03c9) and s \u03c9\u03c3\u2192 s\u2032. By IH, it follows that M |\u03c3r(\u03c9),s\u2032 \u03c6 iff M ,s\u2032 \u03c3r(\u03c9) \u03c6 . Thus we have M ,s \u3008\u03c0\u3009\u03c6 .\nLet \u03c3 be \u03b5 , we have the equivalence of and . Corollary 4.1 Given pointed uncertainty map M ,s, we have M ,s \u03c6 iff M ,s \u03c6 for each \u03c6 \u2208 EPDL\u2212.\nThis alternative semantics induces a natural algorithm to compute the truth value of an EPDL\u2212 formula w.r.t. to a pointed uncertainty map. The idea is to recursively call a function MC(M ,s,\u03c3 ,\u03c6) which returns the truth value of a subformula \u03c6 on state s given the context of \u03c3 while keeping M intact. Note that, we do not need to compute all the MC(M ,s,\u03c3 ,\u03c6) for each \u03c3 and each subformula \u03c6 . The only tricky part comes when evaluating \u3008\u03c0\u3009\u03c6 formulas since it is too space consuming to compute the whole set of L (\u03c0) in the search of the right \u03c9 . Instead, we can generate one by one in some lexicographical order all the possible sequences up to a bound based on the atomic actions and tests occurring in the formula, and then test whether it belongs to the program \u03c0 . Note that in this way, we can use the space repeatedly, and the membership testing of L (\u03c0) is not expensive (NLOGSPACE-complete according to [20]).\nIn the appendix we present three algorithms based on matrix representation of the model: Algorithm 1 computes the uncertainty set U |\u03c3 ; Algorithm 2 computes w\u03c3\u2192 and Algorithm 3 is the main model\nchecking algorithm. Note that Algorithms 2 and 3 involve mutual recursion of each other due to the tests in programs. However, the depth of the recursion is bounded by the length of the formula, and for each call polynomial space suffices. The detailed algorithms and complexity analysis can be found in the appendix. It is not hard to show the following (based on Theorem 4.2)\nTheorem 4.4 (Upper bound) The model checking problem of EPDL\u2212 is in PSPACE. Thus it is PSPACEcomplete."}, {"heading": "4.2 Upper Bounds for model checking EPDL", "text": "In this section, we give an EXPTIME model checking method for the full EPDL via model checking EPDL over two-dimensional models with both epistemic and action relations. Let us first define such models.\nDefinition 4.4 (Epistemic Temporal Structure) An Epistemic Temporal Structure (ETS) is a Kripke model with both epistemic and action relations. Formally, an ETS model M is a tuple \u3008S ,{Ra | a \u2208 A},\u223c,V \u3009, where Ra is a binary relation on S , \u223c is an equivalence relation on S and V : S \u2192 2P is a valuation function.\nNow we define an alternative semantics of EPDL over ETSs.6\nDefinition 4.5 (ETS Semantics) Given any ETS model M= \u3008S ,{Ra | a \u2208 A},\u223c,V \u3009 and any state s \u2208S , the satisfaction relation for EPDL formulas is defined as follows (the Boolean cases are as in the standard modal logic):\nM,s K\u03c6 \u21d4\u2200u \u2208S : s\u223c u implies M,u \u03c6 M,s [\u03c0]\u03c6\u21d4\u2200t \u2208 S : s \u03c0\u2192 t implies M, t \u03c6 a\u2192 = Ra ?\u03c6\u2192 = {(s,s) |M,s \u03c6} \u03c01;\u03c02\u2192 = \u03c01\u2192\u25e6 \u03c02\u2192 \u03c01+\u03c02\u2192 = \u03c01\u2192\u222a \u03c02\u2192 \u03c0\u2217\u2192 = ( \u03c0\u2192)?\nwhere \u25e6,\u222a, ? at right-hand side denote the usual composition, union and reflexive transitive closure of binary relations respectively.\nWe can turn a Kripke model without the epistemic relation into an ETS model by essentially considering all the possible uncertainty sets.\nDefinition 4.6 Given any Kripke model M = \u3008S ,{Ra | a \u2208 A},V \u3009, we define the ETS model M \u2022 as follows:\nS \u2022 = {s\u0393 | s \u2208S ,\u0393 \u2208 2S ,s \u2208 \u0393} R\u2022a = {(s\u0393, t\u2206) | s\na\u2192 t,\u2206 = \u0393|a} \u223c\u2022 = {(s\u0393, t\u2206) | \u0393 = \u2206} V \u2022(s\u0393) =V (s)\nwhere \u0393|a = {t \u2208S | \u2203s \u2208 \u0393 such that s a\u2192 t}. For any Kripke model M and any \u0393 \u2208 2S \\{ /0}, let M \u0393 be the uncertainty map \u3008M ,\u0393\u3009.\n6Here we abuse the notation to denote the new semantics. Note that it is different from the alternative semantics in the previous section.\nNote that each s\u0393 can be viewed as an uncertainty set (\u0393) with a designated state (s), and the definition of Ra captures the update in the semantics of EPDL, and M \u2022 unravels all the updates in a whole picture. Note that the size of M \u2022 is |S | \u00b72|S |\u22121 where S is the set of states of M .\nNow we can show that and coincide w.r.t. uncertainty map M \u0393 and ETS model M \u2022 (the proofs are omitted due to the lack of space).\nProposition 4.5 Given any map M , we have\n(i) M \u0393,sJ\u03c0KM \u2206, t iff s\u0393 \u03c0\u2192 t\u2206 in M \u2022;7\n(ii) M \u0393,s \u03c6 iff M \u2022,s\u0393 \u03c6 .\nCorollary 4.2 Given an uncertainty map M = \u3008N ,U \u3009 and s \u2208U , we have M ,s \u03c6 iff N \u2022,sU \u03c6 .\nBased on the above corollary we can have a model checking method via model checking EPDL over ETS models.\nProposition 4.6 The model checking problem of EPDL on uncertainty maps is in EXPTIME.\nProof: Given an uncertainty map M = \u3008N ,U \u3009, the construction of ETS N \u2022 can be done in exponential time in the size of N due to the fact that there are at most |N | a-successors t\u2206 of each s\u0393 since \u2206 = \u0393|a. By modifying the algorithm for PDL in [23], we can get an algorithm to check EPDL formula \u03c6 on N \u2022 w.r.t. , and its time complexity is O(|\u03c6 |2 \u00b7 |N \u2022|3). Thus, the time complexity of model checking \u03c6 on M is bounded by O(|\u03c6 |2 \u00b7 |SN |3 \u00b723|SN |\u22123).\nWe conjecture that the model checking problem of full EPDL is EXPTIME-complete, and leave the lower bound to the extended version of this paper."}, {"heading": "4.3 Complexity of conformant planning", "text": "In the rest of this section, let us look at the complexity of conformant planning in terms of EPDL model checking. Although the model checking problem of full EPDL is likely to be EXPTIME-complete, the complexity of model checking the EPDL formula which encodes the conformant planning problem (cf. Theorem 3.1) is in PSPACE if the goal formula is program-free. More precisely, we can show the following:\nTheorem 4.5 The problem of model checking EPDL formulas in the shape of \u3008(\u03a3a\u2208B(?K\u3008a\u3009>;a))\u2217\u3009K\u03c6 , where \u03c6 is an epistemic formula (i.e. program-free) and B\u2286 A, is in PSPACE.\nProof: (Sketch) Note that (\u2211a\u2208B(?K\u3008a\u3009>;a))\u2217 is a special program which has only simple epistemic tests depending on the structure of the underlying Kripke model. Now given a Kripke model N and a set B \u2286 A we can define an ETS model N \u25e6 similar to N \u2022 but with a different definition for the action relations:\nR\u25e6a = {(s\u0393, t\u2206) | s a\u2192 t,\u2206 = \u0393|a,\u2200u \u2208 \u0393\u2203v st. u a\u2192 v.}\nNote that the extra condition guarantees that the action a is always executable w.r.t. the whole \u0393, thus fulfilling the test ?K\u3008a\u3009>. Now we can have an analog of Corollary 4.2, and reduce the problem of checking \u3008N ,U \u3009,s (\u2211a\u2208B(?K\u3008a\u3009>;a))\u2217K\u03c6 to the reachability problem in N \u25e6: whether there is a path from sU in N \u25e6 such that it can reach a state tU \u2032 where K\u03c6 holds. Since \u03c6 is [\u03c0]-free, we can check it easily given U \u2032 using polynomial space, thus the main task is to find the reachable tU \u2032 . Note\n7Cf. the definition of \u03c0\u2192 in Def. 4.5.\nthat, in the size of N , there are exponentially many such tU \u2032 and the maximal length of the plan is also exponential. However, we do not need to build the whole N \u25e6 and the bisection-like algorithm behind the proof of Savitch\u2019s Theorem will do the job.8 More precisely, we first pick up a tU \u2032 , and then run the recursive bisection method to see whether tU \u2032 is reachable from sU within 2|N | steps. The depth of the recursion is bounded by log2(2|N |) = |N | and at each recursion we need to record the choice of the state which can be encoded by a (0,1)-vector using log2(2|N |) = |N | space (plus one bit to record the result). Moreover, at the bottom of the recursion we only need to verify one step reachability, i.e., whether two states in N \u25e6 are linked by R\u25e6a , without building the whole N\n\u25e6. Thus the whole procedure of model checking can be done using polynomial space.\nAs we mentioned in the introduction, the conformant planning problems in the AI literature are usually given by using state variables and actions with preconditions and (conditional) effects, rather than explicit transition systems. The corresponding explicit transition system can be generated by taking all the possible valuations of the state variables as the state space (an exponential blow up), and computing the transitions among the valuations according to the preconditions and the postconditions of the actions. In terms of the size of explicit transition systems, our above result is consistent with the EXPSPACE complexity result in the AI literature for conformant planning with Boolean and modal goals [21, 8]. Actually, the complexity result of Theorem 4.5 can be strengthened to PSPACE-complete based on the corresponding complexity result in the AI literature.\nHowever, not all the transition systems can be generated in this way since the preconditions and postconditions are (usually) purely propositional and thus two states that share the same valuation must have the same executable actions. In an arbitrary transition system, multiple states with the same valuation may have different available actions due to some underlying protocol or other (external) factors not modelled by basic propositions."}, {"heading": "5 Conclusions and future work", "text": "In this work we first introduce the logical language EAL over uncertainty maps and axiomatize it completely. EAL is then extended to EPDL with programs to specify conformant and conditional plans. We show that the conformant planning problems can be reduced to model checking problems of EPDL. Finally we showed that model checking star-free EPDL over uncertainty maps is PSPACE-complete and model checking the full fragment is in EXPTIME. On the other hand, model checking the conformant planning problem is in PSPACE.\nNote that our EPDL is a powerful language which can already express conditional plans, for example, (?p;a+?\u00acp;b);c. This suggests that we can use the very EPDL language (EPDL\u2212 is enough) to verify plans in contingent planning w.r.t. a variant of the semantics which can handle feedbacks during the execution. In fact, observational power about the availability of the actions has been already incorporated in [33], which can be extended to general feedbacks discussed in the literature of contingent planning (cf. e.g., [10]). On the other hand, to check the existence of a conditional plan, we are not sure whether EPDL is expressive enough, as subtleties may arise as in the case of conformant planning. We leave the contingent planning to future work.\nAnother natural extension is to go probabilistic, and reduce the probabilistic planning over MDP to some model checking problem of the probabilistic version of our EPDL. Our ultimate goal is to cast all the standard AI planning problems into one unified logical framework in order to facilitate careful\n8A similar algorithm was used to pinpoint complexity of the conformant planning in AI, cf.[21].\ncomparison and categorization. We will then see clearly how the form of the goal formula, the constructor of the plan, and the observational ability matter in the theoretical and practical complexity of planning, in line with the research pioneered in [5].\nAcknowledgement Quan Yu is supported by NSF Grant No.61463044 and Grant No.[2014]7421 from the Joint Fund of the NSF of Guizhou province of China. Yanjun Li thanks the support from China Scholarship Council. Yanjing Wang acknowledges the support from ROCS of SRF by Education Ministry of China and the NSSF major project 12&ZD119."}, {"heading": "A Algorithms for EPDL\u2212", "text": "Definition A.1 (Matrix representation) Let Bn\u00d7m denote a (0,1)-matrix of size n\u00d7m. A matrix Bn\u00d71, or Bn for short, is called a vector. Given finite uncertainty map M , its domain S can be linearly ordered as {s1, \u00b7 \u00b7 \u00b7 ,sn}. Thus M can be represented by a set {Ban\u00d7n | a \u2208 A} of adjacency matrices for accessibility relation, a vector BUn for U and a set {B p n | p \u2208 P} of vectors for atomic propositions.\nDefinition A.2 Given (0,1)-matrices B\u2032n\u00d7k,Bk\u00d7m, their product B \u2032\u2032 n\u00d7m is defined as: B \u2032\u2032 n\u00d7m[i, j] = 1 iff there exists r \u2264 n such that B\u2032n\u00d7k[i,r] = Bk\u00d7m[r, j] = 1 for all 1\u2264 i\u2264 n,1\u2264 j \u2264 m.\nThe following algorithms are to check whether \u03c6 holds on a pointed uncertainty map M ,s by Definition 4.3. The main algorithm (Algorithm 3) recursively calls itself for each non-trivial subformula of \u03c6 . The complex cases are for the subformulas in the form of \u3008\u03c0\u3009\u03c6 and K\u03c6 . By Definition 4.3, to check M ,s \u03c3 \u3008\u03c0\u3009\u03c6 , we need to make sure that there exists a sequence \u03c9 \u2208L (\u03c0) and a state t \u2208S such that s\n\u03c9\u03c3\u2192 t and M , t \u03c3r(\u03c9) \u03c6 . Since \u03c0 is star-free, |\u03c9| \u2264 |\u03c0| for each \u03c9 \u2208L (\u03c0). It is clear that we cannot compute and store the whole set of L (\u03c0) within polynomial space. Instead, one by one we generate all the possible sequences that are shorter than |\u03c0| and are formed from the alphabet of \u03c0 (cf. line 14), and check whether they are in L (\u03c0). We can order the possible sequences lexicographically according to an ordering of the basic actions and tests in Sig, and compute the next sequence merely from the current one using function next. memb chec(\u03c9,\u03c0) checks whether it is the case \u03c9 \u2208L (\u03c0). If \u03c9 \u2208L (\u03c0), we need to check whether there exists s j \u2208SM such that s\n\u03c9\u03c3\u2192 s j (Algorithm 2) and M ,s j \u03c3r(\u03c9) \u03c6 , where r(\u03c9) is the test-free subsequence of \u03c9 which is easy to compute. For the case of K\u03c6 , we need to calculate the state set U |\u03c3 (Algorithm 1)."}, {"heading": "B Complexity analysis", "text": "We suppose |SM |= n and |\u03c6 |= k. Algorithm 1 uses one variable A to record the uncertainty set which requires O(n) space. Note that there is a mutual recursion in Algorithm 2 and 3, but the depth of the overall recursion is bounded by k. In Algorithm 2, the variable consuming the most of the space is the matrix Bn\u00d7n recording the (intermediate) relation. Since \u03c3 and \u03c9 are also variables in the main algorithm and |\u03c9|+ |\u03c3 | \u2264 k due to the construction in Algorithm 3, the space usage of Algorithm 2 before the recursive calls of PW and MC is bounded by O(k+n2). For Algorithm 3, the most space-demanding part is the \u3008\u03c0\u3009\u03c6 case, where we need to store \u03c0 , Sig, and keep track one \u03c9 and one state s in the loop, which are bounded by either k or s. Moreover, according to [20], the complexity of memb chec is NLOGSPACEcomplete in the size of Sig, i.e., the alphabet of \u03c0 which is bounded again by k. Thus before calling MC and PW again in the \u3008\u03c0\u3009\u03c6 case, the space requirement is at most linear in both k and n, which is less demanding than PW for each recursion. Recall that the overall recursion depth of MC (and PW ) is bounded by k thus the space usage of the whole algorithm is bounded by O(k(k+n2)) = O(k2 + kn2).\nAlgorithm 1: Function CNU(U ,\u03c3): Calculate the the new uncertainty set U |\u03c3\ninput : U , \u03c3 output: BU | \u03c3\nn\n1 A\u2190 BUn ; 2 for i\u2190 1 to |\u03c3 | do 3 A\u2190 A\u00d7B\u03c3 [i]n\u00d7n; 4 return A;\nAlgorithm 2: Function PW (\u03c9,\u03c3): Calculate the binary relation \u03c9\u03c3\u2192 input : computation sequence \u03c9 , action sequence \u03c3 output: Bn\u00d7n\n1 switch \u03c9\u03c3 do 2 case \u03b5\u03c3 return Matrix({(s,s) | s \u2208S }) /* Matrix(R) is the (0,1)-matrix representation of the binary relation R */; 3 case (?\u03c6\u03c9 \u2032)\u03c3 return Matrix({(s,s) |MC(M ,s,\u03c3 ,\u03c6) = true })\u00d7 PW(\u03c9 \u2032,\u03c3 ) ; 4 case (a\u03c9 \u2032)\u03c3 return Ban\u00d7n\u00d7 PW(\u03c9 \u2032,\u03c3a) ;\nAlgorithm 3: Function MC(M ,s,\u03c3 ,\u03c6): Model checking algorithm for EPDL\u2212 (Boolean cases omitted)\ninput : The pointed uncertainty map (M ,s), sequence of actions \u03c3 , \u03c6 \u2208 EPDL\u2212. output: true if M ,s \u03c3 \u03c6 .\n1 switch \u03c6 do 2 case \u3008\u03c0\u3009\u03d5 3 Let Sig be the array consisting of atomic programs and formulas in \u03c0 ordered according to their first appearances; 4 \u03c9 \u2190 Sig[1] /* \u03c9 is the candidate sequence we want to test */; 5 while |\u03c9| \u2264 |\u03c0| do 6 if memb chec(\u03c9,\u03c0) then 7 for i = 1 to SM do 8 if (s,si) \u2208 PW (\u03c9,\u03c3) then 9 if MC(M ,s j,\u03c3r(\u03c9),\u03d5) then return true ;\n10 \u03c9 \u2190 next(\u03c9,Sig) /* calculate the next sequence lexicographically according to the order Sig */;\n11 return false; 12 case K\u03d5 13 B U |\u03c3 n = CNU(U ,\u03c3) /* calculate the vector representation of U |\u03c3 */ 14 for m = 1 to |SM | do 15 if (BU | \u03c3\nn )m = 1 and MC(M ,sm,\u03c3 ,\u03d5) = false then return false ; 16 return true;"}], "references": [{"title": "DEL-sequents for regression and epistemic planning", "author": ["Guillaume Aucher"], "venue": "Journal of Applied Non- Classical Logics", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "Undecidability in Epistemic Planning", "author": ["Guillaume Aucher", "Thomas Bolander"], "venue": "In: IJCAI,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "All PSPACE-Complete Planning Problems Are Equal but Some Are More Equal than Others", "author": ["Christer B\u00e4ckstr\u00f6m", "Peter Jonsson"], "venue": "SOCS", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Epistemic planning for single and multi-agent systems", "author": ["Thomas Bolander", "M. Birkegaard Andersen"], "venue": "Journal of Applied Non-Classical Logics", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Conformant plans and beyond: Principles and complexity", "author": ["Blai Bonet"], "venue": "Artificial Intelligence", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Planning with Incomplete Information as Heuristic Search in Belief Space", "author": ["Blai Bonet", "Hector Geffner"], "venue": "ICAPS", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2000}, {"title": "Width and Complexity of Belief Tracking in Non-Deterministic Conformant and Contingent Planning", "author": ["Blai Bonet", "Hector Geffner"], "venue": "AAAI", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Conformant Planning via Heuristic Forward Search: A New Approach", "author": ["Ronen I. Brafman", "J\u00f6rg Hoffmann"], "venue": "ICAPS", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2004}, {"title": "Planning Graph Heuristics for Belief Space Search", "author": ["Daniel Bryce", "Subbarao Kambhampati", "David E. Smith"], "venue": "Journal of Artificial Intelligence Research", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2006}, {"title": "Conformant Planning via Symbolic Model Checking", "author": ["Alessandro Cimatti", "Marco Roveri"], "venue": "Journal of Artificial Intelligence Research", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2000}, {"title": "Conformant Planning via Symbolic Model Checking", "author": ["Alessandro Cimatti", "Marco Roveri"], "venue": "CoRR abs/1106.0252", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Conformant planning via symbolic model checking and heuristic search", "author": ["Alessandro Cimatti", "Marco Roveri", "Piergiorgio Bertoli"], "venue": "Artificial Intelligence", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2004}, {"title": "Dynamic epistemic logic. Springer, doi:10.1007/978-1-4020-5839-4", "author": ["Hans van Ditmarsch", "Wiebe van der Hoek", "Barteld Kooi"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Y", "author": ["R. Fagin", "J. Halpern"], "venue": "Moses & M. Vardi ", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1995}, {"title": "Y", "author": ["R. Fagin", "J.Y. Halpern"], "venue": "Moses & M. Y. Vardi ", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1997}, {"title": "Some Results on the Complexity of Planning with Incomplete Information", "author": ["Patrik Haslum", "Peter Jonsson"], "venue": "ECP", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1999}, {"title": "A note on the space complexity of some decision problems for finite automata", "author": ["Tao Jiang", "B. Ravikumar"], "venue": "Information Processing Letters", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1991}, {"title": "Knowledge-Based Programs as Plans - The Complexity of Plan Verification", "author": ["J\u00e9r\u00f4me Lang", "Bruno Zanuttini"], "venue": "ECAI", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2012}, {"title": "Model checking propositional dynamic logic with all extras", "author": ["Martin Lange"], "venue": "Journal of Applied Logic", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2006}, {"title": "DEL planning and some tractable cases", "author": ["Benedikt L\u00f6we", "Eric Pacuit", "Andreas Witzel"], "venue": "LORI", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2011}, {"title": "Compiling Uncertainty Away: Solving Conformant Planning Problems using a Classical Planner (Sometimes)", "author": ["H\u00e9ctor Palacios", "Hector Geffner"], "venue": "AAAI", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2006}, {"title": "Strong Planning in the Logics of Communication and Change", "author": ["Pere Pardo", "Mehrnoosh Sadrzadeh"], "venue": "Declarative Agent Languages and Technologies X,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2013}, {"title": "Distributed Processes and the Logic of Knowledge", "author": ["Rohit. Parikh", "R. Ramanujam"], "venue": "Proceedings of Conference on Logic of Programs,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1985}, {"title": "The Complexity of Temporal Logic Model Checking", "author": ["Philippe Schnoebelen"], "venue": "AiML", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2003}, {"title": "Word problems requiring exponential time (Preliminary Report)", "author": ["Larry J Stockmeyer", "Albert R Meyer"], "venue": "STOC 1973, ACM,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1973}, {"title": "A New Approach to Conformant Planning Using CNF", "author": ["Son Thanh To", "Tran Cao Son", "Enrico Pontelli"], "venue": "ICAPS", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "On axiomatizations of public announcement logic", "author": ["Yanjing Wang", "Qinxiang Cao"], "venue": "Synthese 190,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2013}, {"title": "Not All Those Who Wander Are Lost: Dynamic Epistemic Reasoning in Navigation", "author": ["Yanjing Wang", "Yanjun Li"], "venue": "AiML", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2012}], "referenceMentions": [{"referenceID": 27, "context": "\u2217Corresponding author 1It is a variant of the running example in [33].", "startOffset": 65, "endOffset": 69}, {"referenceID": 4, "context": "2In many other cases, feedbacks may be just too \u2018expensive\u2019 to obtain during a plan aiming for quick actions [8].", "startOffset": 109, "endOffset": 112}, {"referenceID": 5, "context": "As discussed in [9, 25], conformant planning can be reduced to classical planning, the planning problem without any initial uncertainty, over the space of belief states.", "startOffset": 16, "endOffset": 23}, {"referenceID": 20, "context": "As discussed in [9, 25], conformant planning can be reduced to classical planning, the planning problem without any initial uncertainty, over the space of belief states.", "startOffset": 16, "endOffset": 23}, {"referenceID": 15, "context": "The complexity of checking the existence of a conformant plan is EXPSPACE-complete in the size of the variables generating the state space [19].", "startOffset": 139, "endOffset": 143}, {"referenceID": 9, "context": "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.", "startOffset": 107, "endOffset": 119}, {"referenceID": 11, "context": "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.", "startOffset": 107, "endOffset": 119}, {"referenceID": 10, "context": "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.", "startOffset": 107, "endOffset": 119}, {"referenceID": 25, "context": "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.", "startOffset": 128, "endOffset": 132}, {"referenceID": 7, "context": ", [11, 12].", "startOffset": 2, "endOffset": 10}, {"referenceID": 8, "context": ", [11, 12].", "startOffset": 2, "endOffset": 10}, {"referenceID": 12, "context": ", [16]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 3, "context": ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.", "startOffset": 2, "endOffset": 23}, {"referenceID": 19, "context": ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.", "startOffset": 2, "endOffset": 23}, {"referenceID": 0, "context": ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.", "startOffset": 2, "endOffset": 23}, {"referenceID": 21, "context": ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.", "startOffset": 2, "endOffset": 23}, {"referenceID": 3, "context": "However, this expressiveness comes at a price, as shown in [7, 4], that multi-agent epistemic planning is undecidable in general.", "startOffset": 59, "endOffset": 65}, {"referenceID": 1, "context": "However, this expressiveness comes at a price, as shown in [7, 4], that multi-agent epistemic planning is undecidable in general.", "startOffset": 59, "endOffset": 65}, {"referenceID": 3, "context": "Many interesting decidable fragments are found in the literature [7, 24, 34, 1], which suggests that the single-agent cases and restrictions on the form of event models are the key to decidability.", "startOffset": 65, "endOffset": 79}, {"referenceID": 19, "context": "Many interesting decidable fragments are found in the literature [7, 24, 34, 1], which suggests that the single-agent cases and restrictions on the form of event models are the key to decidability.", "startOffset": 65, "endOffset": 79}, {"referenceID": 27, "context": "Our formal framework is based on the logic proposed by Wang and Li in [33], where the model is simply a transition system with initial uncertainty as in the motivating example, and an action is interpreted in the semantics as an update on the uncertainty of the agent.", "startOffset": 70, "endOffset": 74}, {"referenceID": 14, "context": "4 \u2022 The plans can be specified as regular expressions with tests in terms of arbitrary EPDL formulas, which generalizes the knowledge-based programs in [18, 22].", "startOffset": 152, "endOffset": 160}, {"referenceID": 17, "context": "4 \u2022 The plans can be specified as regular expressions with tests in terms of arbitrary EPDL formulas, which generalizes the knowledge-based programs in [18, 22].", "startOffset": 152, "endOffset": 160}, {"referenceID": 13, "context": "\u2022 Our logical language and models are very simple compared to the standard action-model based DEL approach, yet we can encode the externally given executability of the actions in the model, inspired by epistemic temporal logic (ETL) [17, 27].", "startOffset": 233, "endOffset": 241}, {"referenceID": 22, "context": "\u2022 Our logical language and models are very simple compared to the standard action-model based DEL approach, yet we can encode the externally given executability of the actions in the model, inspired by epistemic temporal logic (ETL) [17, 27].", "startOffset": 233, "endOffset": 241}, {"referenceID": 27, "context": "To talk about the knowledge of the agent during an execution of a plan, we use the following language proposed in [33].", "startOffset": 114, "endOffset": 118}, {"referenceID": 27, "context": "Note that here we differ from [33] where the updated uncertainty set is further", "startOffset": 30, "endOffset": 34}, {"referenceID": 27, "context": "Following the axioms proposed in [33], we give the following axiomatization for EALw.", "startOffset": 33, "endOffset": 37}, {"referenceID": 26, "context": "[32]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "Note that since we do not assume that the agent can observe the available actions, the axiom OBS(a) : K\u3008a\u3009>\u2228K\u00ac\u3008a\u3009> in [33] is abandoned.", "startOffset": 118, "endOffset": 122}, {"referenceID": 27, "context": "We show the completeness of SELA using a more direct proof strategy compared to the one used in [33].", "startOffset": 96, "endOffset": 100}, {"referenceID": 24, "context": "QBF (even in prenex normal form based on a conjunctive normal form) is true or not is known to be PSPACE-complete [30].", "startOffset": 114, "endOffset": 118}, {"referenceID": 23, "context": "Our method is inspired by [28] which discusses the complexity of model checking temporal logics with past operators.", "startOffset": 26, "endOffset": 30}, {"referenceID": 26, "context": "Similar idea appeared in [32] to give an alternative semantics of public announcement logic.", "startOffset": 25, "endOffset": 29}, {"referenceID": 16, "context": "Note that in this way, we can use the space repeatedly, and the membership testing of L (\u03c0) is not expensive (NLOGSPACE-complete according to [20]).", "startOffset": 142, "endOffset": 146}, {"referenceID": 18, "context": "By modifying the algorithm for PDL in [23], we can get an algorithm to check EPDL formula \u03c6 on N \u2022 w.", "startOffset": 38, "endOffset": 42}, {"referenceID": 4, "context": "In terms of the size of explicit transition systems, our above result is consistent with the EXPSPACE complexity result in the AI literature for conformant planning with Boolean and modal goals [21, 8].", "startOffset": 194, "endOffset": 201}, {"referenceID": 27, "context": "In fact, observational power about the availability of the actions has been already incorporated in [33], which can be extended to general feedbacks discussed in the literature of contingent planning (cf.", "startOffset": 100, "endOffset": 104}, {"referenceID": 6, "context": ", [10]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 2, "context": "We will then see clearly how the form of the goal formula, the constructor of the plan, and the observational ability matter in the theoretical and practical complexity of planning, in line with the research pioneered in [5].", "startOffset": 221, "endOffset": 224}], "year": 2016, "abstractText": "In this paper, we introduce a lightweight dynamic epistemic logical framework for automated planning under initial uncertainty. We reduce plan verification and conformant planning to model checking problems of our logic. We show that the model checking problem of the iteration-free fragment is PSPACE-complete. By using two non-standard (but equivalent) semantics, we give novel model checking algorithms to the full language and the iteration-free language.", "creator": "LaTeX with hyperref package"}}}