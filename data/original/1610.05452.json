{"id": "1610.05452", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Oct-2016", "title": "Makespan Optimal Solving of Cooperative Path-Finding via Reductions to Propositional Satisfiability", "abstract": "The problem of makespan optimal solving of cooperative path finding (CPF) is addressed in this paper. The task in CPF is to relocate a group of agents in a non-colliding way so that each agent eventually reaches its goal location from the given initial location. The abstraction adopted in this work assumes that agents are discrete items moving in an undirected graph by traversing edges. Makespan optimal solving of CPF means to generate solutions that are as short as possi-ble in terms of the total number of time steps required for the execution of the solution.", "histories": [["v1", "Tue, 18 Oct 2016 06:42:45 GMT  (1852kb)", "http://arxiv.org/abs/1610.05452v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["pavel surynek"], "accepted": false, "id": "1610.05452"}, "pdf": {"name": "1610.05452.pdf", "metadata": {"source": "META", "title": "Makespan Optimal Solving of Cooperative Path-Finding", "authors": ["Pavel Surynek"], "emails": ["pavel.surynek@aist.go.jp"], "sections": [{"heading": null, "text": "1\nthis paper. The task in CPF is to relocate a group of agents in a non-colliding way so that each agent eventually reaches its goal location from the given initial location. The abstraction adopted in this work assumes that agents are discrete items moving in an undirected graph by traversing edges. Makespan optimal solving of CPF means to generate solutions that are as short as possible in terms of the total number of time steps required for the execution of the solution.\nWe show that reducing CPF to propositional satisfiability (SAT) represents a viable option for obtaining makespan optimal solutions. Several encodings of CPF into propositional formulae are suggested and experimentally evaluated. The evaluation indicates that SAT based CPF solving outperforms other makespan optimal methods significantly in highly constrained situations (environments that are densely occupied by agents).\nKeywords: cooperative path-finding (CPF), propositional satisfiability (SAT), time expanded graphs, makespan optimality, multi-robot path planning, multi-agent path finding, pebble motion on a graph1"}, {"heading": "1. Introduction and Motivation", "text": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding -\nMAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion\non a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to\nrelocate some objects that spatially interacts with each other. In case of CPF, we are speak-\ning about mobile agents (or robots) that can be moved in a certain environment. Each agent\nstarts at a given initial position in the environment and it is assigned a unique goal position\nto which it has to relocate. The problem consists in finding a spatial-temporal path for each\nagent by which the agent can relocate itself from its initial position to the given goal with-\nout colliding with other agents (that are simultaneously trying to reach their goals as well).\nA graph theoretical abstraction, where the environment in which agents are moving is\nmodeled as an undirected graph, is often adopted [18, 20]. Agents are represented as dis-\ncrete items placed in vertices of the graph in this abstraction. Space occupancy imposed by\npresence of agents is modeled by the requirement that at most one agent resides in each\nvertex.\nMovements of agents are also greatly simplified in the abstraction. An agent can in-\nstantaneously move to a neighboring vertex assumed that the target vertex is unoccupied\n1 This is a preprint submitted to ArXiv on October 18, 2016.\nPavel Surynek 2\nand no other agent is trying to enter the same target vertex simultaneously. Note that vari-\nous versions of the problem may have different conditions on movements - sometimes it is\nfor instance allowed to move agents in a train like manner [28] or even rotate agents around\ncycle without any unoccupied vertex in the cycle [39].\nThere are many practical motivations for CPF ranging from unit navigation in computer\ngames [24] to item relocation in automated storage (see KIVA robots [13]). Interesting\nmotivations can be also found in traffic where problems like vessel avoidance at sea are of\ngreat practical importance [12]. An analogical challenge appears in the air where availabil-\nity of drones implies need for developing cooperative air traffic control mechanisms [15].\nWe suggest to solve CPF via reducing it to propositional satisfiability (SAT) [7]. Par-\nticularly we are dealing with so-called makespan optimal solving of CPF [23, 29], which\nmeans to find a solution of a makespan as short as possible. The makespan of a solution is\nthe number of steps necessary to execute all the moves of the solution. In other words, it is\nthe length of the longest path from paths traveled by individual agents. It is known that\nfinding makespan optimal solutions to CPF is a difficult problem, namely it is NP-hard\n[16, 32, 39]. Hence reducing the makespan optimal CPF to SAT is justified as both prob-\nlems are at the same level in terms of the complexity. Moreover, the reduction allows ex-\nploiting the power of modern SAT solvers [2, 3] in CPF solving. The question however is\nthe design of an encoding of the CPF problem into propositional formula. Several encod-\nings of CPF into propositional formulae are introduced in this paper. They are based on a\nso-called time expansion of the graph that models the environment [11, 26] so that the\nformula can represent all the possible arrangements of agents at all the time steps up to the\ngiven final time step. All the encodings are thoroughly experimentally evaluated with each\nother and also with alternative techniques for makespan optimal CPF solving."}, {"heading": "2. Context of Related Works", "text": "The approach to solve CPF by reducing it to SAT has multiple alternatives. There exist\nalgorithms based on search that find makespan optimal or near optimal solutions. The sem-\ninal work in this category is represented by Silver\u2019s WHCA* algorithm [20] which is a\nvariant of A* search where cooperation among agents is incorporated. Recent contributions\ninclude OD+ID [23], which is a combination of A* and powerful agent independence de-\ntection heuristics, and ICTS [21] which employs the concept of increasing cost tree (instead\nof makespan, the total cost of solution is optimized). Other approaches resolve conflicts\namong robot trajectories when avoidance is necessary [5, 8, 34].\nFast polynomial time algorithms for generating makespan suboptimal solutions include\nPUSH-AND-ROTATE [37, 38] and other algorithms [28]. The drawback of these algorithms\nis that their solutions are dramatically far from the optimum.\nTranslation of CPF to a different formalism, namely to answer set programming (ASP),\nhas been suggested in [9]. Integer programming (IP) as the target formalism has been also\nused [39]. The choice of SAT as the target formalism is very common in domain independ-\nent planning where the idea of time expansion [10, 11] and its reductions [4, 35] are studied.\nMakespan Optimal Solving of Cooperative Path-Finding\n3"}, {"heading": "3. Background", "text": "An arbitrary undirected graph can model the environment where agents are moving. Let \ud835\udc3a = (\ud835\udc49, \ud835\udc38) be such a graph where \ud835\udc49 = {\ud835\udc631, \ud835\udc632, \u2026 , \ud835\udc63\ud835\udc5b} is a finite set of vertices and \ud835\udc38 \u2286 (\ud835\udc49 2 ) is a set of edges. The configuration of agents in the environment is modeled by assigning them vertices of the graph. Let \ud835\udc34 = {\ud835\udc4e1, \ud835\udc4e2, \u2026 , \ud835\udc4e\ud835\udf07} be a finite set of agents. Then, a configuration of agents in vertices of graph \ud835\udc3a will be fully described by a location function \ud835\udefc: \ud835\udc34 \u27f6 \ud835\udc49; the interpretation is that an agent \ud835\udc4e \u2208 \ud835\udc34 is located in a vertex \ud835\udefc(\ud835\udc4e). At most one agent can be located in a vertex; that is \ud835\udefc is a uniquely invertible function. A generalized inverse of \ud835\udefc denoted as \ud835\udefc\u22121: \ud835\udc49 \u27f6 \ud835\udc34 \u222a {\u22a5} will provide us an agent located in a given vertex or \u22a5 if the vertex is empty.\nDefinition 1 (COOPERATIVE PATH FINDING). An instance of cooperative path-finding problem (CPF) is a quadruple \u03a3 = [\ud835\udc3a = (\ud835\udc49, \ud835\udc38), \ud835\udc34, \ud835\udefc0, \ud835\udefc+] where location functions \ud835\udefc0 and \ud835\udefc+ define the initial and the goal configurations of a set of agents \ud835\udc34 in \ud835\udc3a respectively. \u25a1\nThe dynamicity of the model assumes a discrete time divided into time steps. A configuration \ud835\udefc\ud835\udc56 at the \ud835\udc56-th time step can be transformed by a transition action which instantaneously moves agents in the non-colliding way to form a new configuration \ud835\udefc\ud835\udc56+1. The resulting configuration \ud835\udefc\ud835\udc56+1 must satisfy the following validity conditions:\n \u2200\ud835\udc4e \u2208 \ud835\udc34 either \ud835\udefc\ud835\udc56(\ud835\udc4e) = \ud835\udefc\ud835\udc56+1(\ud835\udc4e) or {\ud835\udefc\ud835\udc56(\ud835\udc4e), \ud835\udefc\ud835\udc56+1(\ud835\udc4e)} \u2208 \ud835\udc38 holds (agents move along edges or not move at all),\n \u2200\ud835\udc4e \u2208 \ud835\udc34 \ud835\udefc\ud835\udc56(\ud835\udc4e) \u2260 \ud835\udefc\ud835\udc56+1(\ud835\udc4e) \u21d2 \ud835\udefc\ud835\udc56 \u22121(\ud835\udefc\ud835\udc56+1(\ud835\udc4e)) =\u22a5\n(agents move to vacant vertices only), and\n \u2200\ud835\udc4e, \ud835\udc4f \u2208 \ud835\udc34 \ud835\udc4e \u2260 \ud835\udc4f \u21d2 \ud835\udefc\ud835\udc56+1(\ud835\udc4e) \u2260 \ud835\udefc\ud835\udc56+1(\ud835\udc4f) (no two agents enter the same target/unique\ninvertibility of resulting arrangement).\nThe task in cooperative path finding is to transform \ud835\udefc0 using above valid transitions to \ud835\udefc+. An illustration of CPF and its solution is depicted in Figure 1.\nDefinition 2 (SOLUTION, MAKESPAN). A solution of a makespan \ud835\udf02 to a cooperative path finding instance \u03a3 = [\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc +] is a sequence of arrangements \ud835\udc60 = [\ud835\udefc0, \ud835\udefc1, \ud835\udefc2, \u2026 , \ud835\udefc\ud835\udf02] where \ud835\udefc\ud835\udf02 = \ud835\udefc + and \ud835\udefc\ud835\udc56+1 is a result of valid transformation of \ud835\udefc\ud835\udc56 for every \ud835\udc56 = 1,2, \u2026 , \ud835\udf02 \u2212 1. \u25a1\nThe number |\ud835\udc60| = \ud835\udf02 is a makespan of solution \ud835\udc60. It is often a question whether there exists a solution of \u03a3 of the given makespan \ud835\udf02 \u2208 \u2115. This is known as a decision variant of CPF. It is known that the decision variant of CPF is NP-complete, hence finding makespan optimal solution to CPF is NP-hard [16]. Note that due to no-ops introduced in valid transitions, it is equivalent to ask whether there is a solution of exactly the given makespan ant to ask whether there is a solution of at most given makespan.\n(1)\n(2)\n(3)\nPavel Surynek 4"}, {"heading": "4. Solving CPF Optimally through Propositional Satisfiability", "text": "The question we are addressing is how to obtain makespan optimal solutions of CPFs in some practical manner. The approach we are suggesting here employs propositional satisfiability (SAT) [1] solving as the key technology. Note that the decision variant of CPF is in NP, hence it can be reduced to propositional satisfiability. That is, a propositional formula \ud835\udc39(\u03a3, \ud835\udf02) such that it is satisfiable if and only if a given CPF \u03a3 with makespan \ud835\udf02 is solvable can be constructed. Being able to construct such a formula \ud835\udc39(\u03a3, \ud835\udf02) one can obtain the optimal makespan for the given CPF \u03a3 by asking multiple queries whether formula \ud835\udc39(\u03a3, \ud835\udf02) is satisfiable with different makespan bounds \ud835\udf02. Various strategies of choice of makespan bounds for queries exist for getting the optimal makespan. The simplest and efficient one at the same time is to try sequentially makespan \ud835\udf02 = 1,2, \u2026 until \ud835\udf02 equal to the optimal makespan is reached. This strategy will be further referred as sequential increasing. The sequential increasing strategy is also used in domain independent planners such as SATPLAN [11], SASE [10] and others. Pseudo-code of the strategy is listed as Algorithm 1.\nThe focus here is on SAT encoding while querying strategies are out of scope of the paper; though let us mention that in depth study of querying strategies is given in [17]. There is a great potential in querying strategies as they can bring speedup of planning process in orders of magnitude, especially when combined with parallel processing.\nThe important property of propositional encoding \ud835\udc39(\u03a3, \ud835\udf02) is that a solution of CPF \u03a3 of makespan \ud835\udf02 can be unambiguously extracted from satisfying valuation of \ud835\udc39(\u03a3, \ud835\udf02) (otherwise, equivalence between solvability of CPF \u03a3 bounded by \ud835\udf02 and solvability of \ud835\udc39(\u03a3, \ud835\udf02) could be trivially established by setting \ud835\udc39(\u03a3, \ud835\udf02) \u2261 \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 in case \u03a3 is solvable in \ud835\udf02 time steps and \ud835\udc39(\u03a3, \ud835\udf02) \u2261 \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 otherwise). Note that the solving process represented by Algorithm 1 is incomplete, as it does not terminate when the input instance is unsolvable. Nevertheless, the solving process can be easily made complete by checking instance solvability prior to SAT-based optimization by some fast polynomial time algorithm such as those described in [14, 28, 38].\nMakespan Optimal Solving of Cooperative Path-Finding\n5\nAlgorithm 1. SAT-based optimal CPF solving \u2013 sequential increasing strategy. The algorithm sequentially finds the smallest possible makespan \ud835\udf02 for that a given CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+) is solvable. A question whether a solution of CPF \u03a3 exists is constructed with respect to increasing makespans and submitted to a SAT solver.\ninput: \u03a3 \u2013 a CPF instance output: a pair consisting of the optimal makespan and corresponding optimal solution\nfunction Find-Optimal-Solution-Sequentially (\u03a3 = (G, \ud835\udc34, \ud835\udefc0, \ud835\udefc+)): pair 1: \ud835\udf02 \u2190 1 2 loop 3: \ud835\udc39(\u03a3, \ud835\udf02) \u2190Encode-CPF-as-SAT (\ud835\udef4, \ud835\udf02) 4: if Solve-SAT (\ud835\udc39(\u03a3, \ud835\udf02)) then 5: \ud835\udc60 \u2190 Extract-Solution-from-Valuation(\ud835\udc39(\u03a3, \ud835\udf02)) 6: return (\ud835\udf02, \ud835\udc60) 7: \ud835\udf02 \u2190 \ud835\udf02 + 1 8: return (\u221e, \u2205)\nThe important advantage of solving CPF as SAT is that there exist many powerful solvers for SAT [2, 3] implementing numerous advanced techniques such as intelligent search space pruning and learning. The spectrum of these techniques is so rich and so well engineered in modern SAT solvers that it is almost impossible to reach the equal level of advancement in solving CPF by own dedicated solver. Nevertheless, all the well-engineered techniques implemented in SAT solvers can be employed in CPF solving if it is translated to SAT. Note, that the effect of SAT solving techniques is indirect in CPF solving as it is mediated through the translation. Hence, the design of the encoding of CPF as SAT should take into consideration the way in which SAT solvers operate."}, {"heading": "4.1. Time Expansion Graphs", "text": "The trajectory of an agent in time over \ud835\udc3a is not necessarily simple in general case (that is, a single vertex can be visited multiple times). In a propositional representation of such kind of trajectory, it is difficult to fix the number of variables. Therefore, a graph derived from \ud835\udc3a by expanding it over time, where the trajectory of each agent will correspond to a simple path in this graph, will be used (a simple path visits each vertex of the graph at most once). The graph of required properties is introduced in the following definition and illustrated in Figure 3.\nDefinition 3 (TIME EXPANSION GRAPH - ExpT(\ud835\udc3a, \ud835\udf02)). Let \ud835\udc3a = (\ud835\udc49, \ud835\udc38) be an undirected graph and \ud835\udf02 \u2208 \u2115. A time expansion graph with \ud835\udf02 + 1 time layers (indexed from 0 to \ud835\udf02) associated with \ud835\udc3a is a directed graph ExpT(\ud835\udc3a, \ud835\udf02) = (\ud835\udc49\u00d7{0,1, \u2026 , \ud835\udf02}, \ud835\udc38\u2032) where \ud835\udc38\u2032 = {([\ud835\udc62, \ud835\udc59], [\ud835\udc63, \ud835\udc59 + 1]) | {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38; \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 \u2212 1} \u222a {([\ud835\udc63, \ud835\udc59], [\ud835\udc63, \ud835\udc59 + 1])| \ud835\udc63 \u2208 \ud835\udc49; \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 \u2212 1}. \u25a1\nPavel Surynek 6\nDefinition 4 (NON-OVERLAPPING VERTEX DISJOINT PATHS IN ExpT(\ud835\udc3a, \ud835\udf02)). A collection of paths \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07} in ExpT(\ud835\udc3a, \ud835\udf02) so that \ud835\udf0b\ud835\udc56 connects [\ud835\udc65\ud835\udc56 , 0] with [\ud835\udc66\ud835\udc56 , \ud835\udf02] with \ud835\udc65\ud835\udc56 , \ud835\udc66\ud835\udc56 \u2208 \ud835\udc49 for \ud835\udc56 = 1,2, \u2026 , \ud835\udf07 is called to be non-\noverlapping vertex disjoint if and only if \ud835\udf0b\ud835\udc56 \u2229 \ud835\udf0b\ud835\udc57 = \u2205 for any two \ud835\udc56, \ud835\udc57 \u2208 {1,2, \u2026 , \ud835\udf07} with \ud835\udc56 \u2260 \ud835\udc57 and {\ud835\udf0b\ud835\udc56[\ud835\udc59, 2] | \ud835\udf0b\ud835\udc56[\ud835\udc59, 2] \u2260 \ud835\udf0b\ud835\udc56[\ud835\udc59 + 1,2] \u2227 \ud835\udc56 = 1,2, \u2026 , \ud835\udf07} \u2229 {\ud835\udf0b\ud835\udc56[\ud835\udc59 + 1,2] | \ud835\udf0b\ud835\udc56[\ud835\udc59, 2] \u2260 \ud835\udf0b\ud835\udc56[\ud835\udc59 + 1,2] \u2227 \ud835\udc56 = 1,2, \u2026 , \ud835\udf07}1 for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 \u2212 1. \u25a1\nNon-overlapping vertex disjoint paths between two consecutive time layers of ExpT(\ud835\udc3a, \ud835\udf02) are shown in Figure 2. The correspondence between existence of a solution to CPF and non-overlapping vertex disjoint paths is established in the next proposition.\nProposition 1 (NON-OVERLAPPING VERTEX DISJOINT PATHS IN EXPT). A solution of makespan \ud835\udf02 \u2208 \u2115 of a CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+) with \ud835\udc34 = {\ud835\udc4e1, \ud835\udc4e2, \u2026 , \ud835\udc4e\ud835\udf07} exists if and only if there exist a set \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07} of non-overlapping vertex disjoint paths in ExpT(\ud835\udc3a, \ud835\udf02) so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] for \ud835\udc56 = 1,2, \u2026 , \ud835\udf07. \nProof. Assume that a solution \ud835\udc60 = [\ud835\udefc0, \ud835\udefc1, \ud835\udefc2, \u2026 , \ud835\udefc\ud835\udf02] of makespan \ud835\udf02 of given CPF \u03a3 exists. Then vertex disjoint paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 in ExpT(\ud835\udc3a, \ud835\udf02) can be constructed from \ud835\udc60. Path \ud835\udf0b\ud835\udc56 will correspond to the trajectory of agent \ud835\udc4e\ud835\udc56; that is, \ud835\udf0b\ud835\udc56 = ([\ud835\udefc0(\ud835\udc4e\ud835\udc56),0], [\ud835\udefc1(\ud835\udc4e\ud835\udc56),1], \u2026, [\ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02]). The path constructed in this way is a correct path in ExpT(\ud835\udc3a, \ud835\udf02), since {\ud835\udefc\ud835\udc59(\ud835\udc4e\ud835\udc56), \ud835\udefc\ud835\udc59+1(\ud835\udc4e\ud835\udc56)} \u2208 \ud835\udc38 or \ud835\udefc\ud835\udc59(\ud835\udc4e\ud835\udc56) = \ud835\udefc\ud835\udc59+1(\ud835\udc4e\ud835\udc56) for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 \u2212 1; that is, ([\ud835\udefc\ud835\udc59(\ud835\udc4e\ud835\udc56), \ud835\udc59], [\ud835\udefc\ud835\udc59+1(\ud835\udc4e\ud835\udc56), \ud835\udc59 + 1]) \u2208 \ud835\udc38\u2032 holds by construction of ExpT(\ud835\udc3a, \ud835\udf02). Obviously \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56) = \ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02] in ExpT(\ud835\udc3a, \ud835\udf02). It remains to check that no two constructed paths intersect and that paths are non-overlapping. Validity condition (3) ensures that no two path share a common vertex since otherwise agents would collide. Validity\n1 The notation \ud835\udf0b\ud835\udc56[\ud835\udc59, 2] refers to the second component of the \ud835\udc59-th element of \ud835\udf0b\ud835\udc56.\nMakespan Optimal Solving of Cooperative Path-Finding\n7\nconditions (1) and (2) together ensure that overlapping between set of endpoints of edges of paths between consecutive time layers happens only with trivial edges \u2013 that is, edges that continues into the same vertex in the next time layer.\nLet us show the opposite implication. Assume that non-overlapping vertex disjoint paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 in ExpT(\ud835\udc3a, \ud835\udf02) exist. We will construct a solution of CPF \u03a3 of makespan \ud835\udf02. Assume that Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02, \ud835\udf02]), \ud835\udc62\ud835\udc59 \u2208 \ud835\udc49 for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 where \ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56) and \ud835\udc62\ud835\udf02 = \ud835\udefc+(\ud835\udc4e\ud835\udc56). The trajectory of agent \ud835\udc4e\ud835\udc56 is set as follows: \ud835\udefc0(\ud835\udc4e\ud835\udc56) = \ud835\udc620, \ud835\udefc1(\ud835\udc4e\ud835\udc56) = \ud835\udc621, \ud835\udefc2(\ud835\udc4e\ud835\udc56) = \ud835\udc622, \u2026, \ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56) = \ud835\udc62\ud835\udf02. It can be easily verified that validity conditions (1) \u2013 (3) are satisfied by such a construction. Paths are vertex disjoint, so agents do not collide by following them \u2013 condition (2) is satisfied. As paths do not overlap agents either stay in a vertex or move into a vertex that was not occupied in the previous step. Altogether, validity conditions (1) \u2013 (3) are satisfied. "}, {"heading": "4.2. Propositional Encodings Based on Time Expansion Graphs", "text": "The concept of time expansion graph represents an important step towards the design of a propositional formula that is satisfiable if and only if the given CPF has a solution of a given makespan. Moreover, we require such a formula where a corresponding CPF solution can be extracted from its satisfying valuation. Time expansion graph can be used as a basis\nPavel Surynek 8\nfor such a formula as it can capture all the arrangements of agents over the graph modeling the environment at all the time steps up to the given final step."}, {"heading": "4.2.1. INVERSE Propositional Encoding", "text": "Let degG(\ud835\udc63) denote the degree of vertex \ud835\udc63 in \ud835\udc3a; that is, degG(\ud835\udc63) is the number of edges from \ud835\udc38 incident with \ud835\udc63. It is further assumed that neighbors of each vertex \ud835\udc63 in \ud835\udc3a are assigned ordering numbers by a one-to-one assignment \ud835\udf0e\ud835\udc63: {\ud835\udc62|{\ud835\udc63, \ud835\udc62} \u2208 \ud835\udc38} \u27f6 {1,2, \u2026 , degG(\ud835\udc63)} (that is, for each neighbor \ud835\udc62 of \ud835\udc63 we are told that it is a \ud835\udf0e\ud835\udc63(\ud835\udc62)-th neighbor). An inverse \ud835\udf0e\ud835\udc63 \u22121 is naturally defined (that is, \ud835\udf0e\ud835\udc63 \u22121(\ud835\udc56) returns \ud835\udc56-th neighbor of \ud835\udc63 for \ud835\udc56 \u2208 {1,2, \u2026 , degG(\ud835\udc63)}). The following definition introduces the INVERSE encoding over finite domain state variables that will be further encoded into bit-vectors using the standard binary encoding.\nDefinition 5 (INVESE ENCODING \u2013 \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3)). Assume that a CPF \u03a3 = [\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+] with \ud835\udc3a = (\ud835\udc49, \ud835\udc38) is given. An INVERSE encoding for CPF \u03a3 consists of the following finite domain variables for each time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}: \ud835\udc9c\ud835\udc63\n\ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf07} for every \ud835\udc63 \u2208 \ud835\udc49 to model agent occurrences in vertices. For time layers \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1} there are also finite domain variables \ud835\udcaf\ud835\udc63\n\ud835\udc59 \u2208 {0,1, \u2026 , 2 \u2219 degG(\ud835\udc63)} for every \ud835\udc63 \u2208 \ud835\udc49 to represent agent movements. Constraints of INVERSE encoding are as follows:\n \ud835\udcaf\ud835\udc63 \ud835\udc59 = 0 \u21d2 \ud835\udc9c\ud835\udc63 \ud835\udc59+1 = \ud835\udc9c\ud835\udc63 \ud835\udc59 for every \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}\n(if there is no movement occurs in a vertex then the vertex hold the same agent at the next time step)\n 0 < \ud835\udcaf\ud835\udc63 \ud835\udc59 \u2264 deg\ud835\udc3a(\ud835\udc63) \u21d2 \ud835\udc9c\ud835\udc62 \ud835\udc59 = 0 \u2227 \ud835\udc9c\ud835\udc62 \ud835\udc59+1 = \ud835\udc9c\ud835\udc63 \ud835\udc59 \u2227 \ud835\udcaf\ud835\udc62 \ud835\udc59 = \ud835\udf0e\ud835\udc62(\ud835\udc63) + deg\ud835\udc3a(\ud835\udc62),\nfor every \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, where \ud835\udc62 = \ud835\udc5c\ud835\udc63 \u22121(\ud835\udcaf\ud835\udc63 \ud835\udc59) (an agent leaves from \ud835\udc63 to its \ud835\udcaf\ud835\udc63 \ud835\udc59-th neighbor \ud835\udc62)\n deg\ud835\udc3a (\ud835\udc63) < \ud835\udc47\ud835\udc63 \ud835\udc59 \u2264 2 \u22c5 deg\ud835\udc3a(\ud835\udc63) \u21d2 \ud835\udcaf\ud835\udc62 \ud835\udc59 = \ud835\udf0e\ud835\udc62(\ud835\udc63), for every \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, where \ud835\udc62 = \ud835\udf0e\ud835\udc63 \u22121(\ud835\udcaf\ud835\udc63 \ud835\udc59 \u2212 deg\ud835\udc3a(\ud835\udc63))\n(an agent leaves arrives to \ud835\udc63 from its (\ud835\udcaf\ud835\udc63 \ud835\udc59 \u2212 deg\ud835\udc3a (\ud835\udc63))-th neighbor \ud835\udc62). \u25a1\nInitial and goal arrangements will be expressed though the following constraints:\n \ud835\udc9c\ud835\udc62 0 = \ud835\udc56 for \ud835\udc62 \u2208 \ud835\udc49 if there is \ud835\udc56 \u2208 {1,2, \u2026 , \ud835\udf07} such that \ud835\udefc0(\ud835\udc4e\ud835\udc56) = \ud835\udc62  \ud835\udc9c\ud835\udc62 0 = 0 for \ud835\udc62 \u2208 \ud835\udc49 if (\u2200\ud835\udc4e \u2208 \ud835\udc34)\ud835\udefc0(\ud835\udc4e) \u2260 \ud835\udc62  \ud835\udc9c\ud835\udc62 \ud835\udf02\n= \ud835\udc56 for \ud835\udc62 \u2208 \ud835\udc49 if there is \ud835\udc56 \u2208 {1,2, \u2026 , \ud835\udf07} such that \ud835\udefc+(\ud835\udc4e\ud835\udc56) = \ud835\udc62\n \ud835\udc9c\ud835\udc62 \ud835\udf02 = 0 for \ud835\udc62 \u2208 \ud835\udc49 if (\u2200\ud835\udc4e \u2208 \ud835\udc34)\ud835\udefc+(\ud835\udc4e) \u2260 \ud835\udc62\nThe resulting propositional formula in CNF, where \ud835\udc9c\ud835\udc63 \ud835\udc59 and \ud835\udcaf\ud835\udc63 \ud835\udc59 variables are replaced with bit vectors with binary encoding and constraints are replaced accordingly, will be denoted as \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3).\n(4)\n(5)\n(6)\n} Goal locations (10)\n(7)\n(9)\n} Initial locations (8)\nMakespan Optimal Solving of Cooperative Path-Finding\n9\nThe meaning of \ud835\udc9c\ud835\udc63 \ud835\udc59 variables correspond to the inverse location function at time step\n\ud835\udc59. That is, if the inverse location function at time step \ud835\udc59 is \ud835\udefc\ud835\udc59 \u22121 then \ud835\udc9c\ud835\udc63 \ud835\udc59 = \ud835\udc57 iff \ud835\udefc\ud835\udc59 \u22121(\ud835\udc63) = \ud835\udc4e\ud835\udc57 and \ud835\udc9c\ud835\udc63 \ud835\udc59 = 0 iff \ud835\udefc\ud835\udc59 \u22121(\ud835\udc63) =\u22a5. Variables \ud835\udcaf\ud835\udc63 \ud835\udc59 represent transitions of agents among vertices. Zero value is reserved for no-movement. Half of remaining values from 1 to degG(\ud835\udc63) represent outgoing movements from \ud835\udc63 to some neighbor indicated by \ud835\udcaf\ud835\udc63 \ud835\udc59; the other half of values represent incoming movements into \ud835\udc63 from some of its neighbors indicated by \ud835\udcaf\ud835\udc63 \ud835\udc59 \u2212 degG(\ud835\udc63). It is not straightforward to encode the above finite domain model into propositional model where finite domain state variables are replaced with bit-vectors (vectors of propositional variables) using binary encoding as we need to represent quite complex integer constraints over bit vectors. Variables \ud835\udc9c\ud835\udc63 \ud835\udc59 are modeled by a vector of \u2308log2(\ud835\udf07 + 1)\u2309 propositional variables where individual (propositional) bits will be accessed by a bit index \ud835\udd5a \u2208 {0,1, \u2026 , \u2308log2(\ud835\udf07 + 1)\u2309 \u2212 1} denoted as \ud835\udc9c\ud835\udc63 \ud835\udc59 [\ud835\udd5a]. Variables \ud835\udcaf\ud835\udc63 \ud835\udc59 are modeled by vectors of \u2308log2(2 \u22c5 deg\ud835\udc3a(\ud835\udc63) + 1)\u2309 propositional variables. Note, that typical environments are connected only locally, which means that deg\ud835\udc3a(\ud835\udc63) \u226a \ud835\udf07 typically. If the represented finite domain variable has the number of states that is different from the power of 2, then extra states are forbidden.\nConstraints need to distinguish between all the 2 \u22c5 degG(\ud835\udc63) + 1 states of \ud835\udcaf\ud835\udc63 \ud835\udc59 variables since over bit vectors we are able to express very simple constraints only \u2013 such as an expression that a bit vector equals to a constant. Note that over \ud835\udc9c\ud835\udc63 \ud835\udc59 variables we only need to model equality between them and equality to zero which does not distinguish between too many cases. Let \ud835\udd53: \u21150\u00d7\u21150 \u2192 {0,1} be a binary representation of positive integers where \ud835\udd53(\ud835\udc65, \ud835\udd5a) represents value of the \ud835\udd5a-th bit in binary encoding of \ud835\udc65; that is \ud835\udc65 = \u2211 \ud835\udd53(\ud835\udc65, \ud835\udd5a) \u22c5 2\ud835\udd5a\ud835\udc4f\u22121\ud835\udd5a=0 . Equality of a \ud835\udcaf\ud835\udc63\n\ud835\udc59 variable to a given constant \ud835\udc50 \u2208 {0,1, \u2026, 2 \u22c5 deg\ud835\udc3a(\ud835\udc63)} will be expressed as following conjunction:\nEquality between variables \ud835\udc9c\ud835\udc63 \ud835\udc59 and \ud835\udc9c\ud835\udc62 \ud835\udc59+1 is expressed by the following conjunction of\nequivalences:\nThe above elementary constructions are put together to represent constraints (4) \u2013 (6) using Tseitin\u2019s encoding [33] which introduces auxiliary propositional variables to the encoding. Auxiliary propositional variables \ud835\udc4e\ud835\udc63,\ud835\udc59 zero representing empty vertex \ud835\udc63 at time step \ud835\udc59, \ud835\udc4e\ud835\udc62,\ud835\udc63,\ud835\udc59 = representing equality between \ud835\udc9c\ud835\udc63 \ud835\udc59 and \ud835\udc9c\ud835\udc62 \ud835\udc59+1, and \ud835\udc4e\ud835\udc63,\ud835\udc59,\ud835\udc50 tran representing equality \ud835\udcaf\ud835\udc63 \ud835\udc59 = \ud835\udc50.\n(12)\ncon=(\ud835\udcaf\ud835\udc63 \ud835\udc59, \ud835\udc50) = \u22c0 lit(\ud835\udcaf\ud835\udc63 \ud835\udc59, \ud835\udc50, \ud835\udd5a)\n\u2308log2(2\u22c5deg\ud835\udc3a(\ud835\udc63)+1)\u2309\u22121\n\ud835\udd5a=0\nwhere lit(\ud835\udcaf\ud835\udc63 \ud835\udc59, \ud835\udc50, \ud835\udd5a) = \u124a\n\ud835\udcaf\ud835\udc63 \ud835\udc59[\ud835\udd5a]\n\ud835\udcaf\ud835\udc63 \ud835\udc59[\ud835\udd5a]\niff \ud835\udd53(\ud835\udc50, \ud835\udd5a) = 1\niff \ud835\udd53(\ud835\udc50, \ud835\udd5a) = 0\nvar=(\ud835\udc9c\ud835\udc63 \ud835\udc59 , \ud835\udc9c\ud835\udc62 \ud835\udc59+1) = \u22c0 (\ud835\udc9c\ud835\udc63 \ud835\udc59 [\ud835\udd5a] \u2228 \ud835\udc9c\ud835\udc62 \ud835\udc59+1[\ud835\udd5a]) \u2227 (\ud835\udc9c\ud835\udc63 \ud835\udc59 [\ud835\udd5a] \u2228 \ud835\udc9c\ud835\udc62 \ud835\udc59+1[\ud835\udd5a])\n\u2308log2(\ud835\udf07+1)\u2309\u22121\n\ud835\udd5a=0\n(11)\nPavel Surynek 10\nThe connection of auxiliary variables with their exact meaning is done by the following constraints:\nAs \ud835\udc9c\ud835\udc63 \ud835\udc59 variables appear only on the right side of implications in constraints (4) \u2013 (6) of the INVERSE encoding it is sufficient to connect their auxiliary by implications only. Whereas \ud835\udcaf\ud835\udc63 \ud835\udc59 variables appear on both sides of implications in (4) \u2013 (6); therefore they need to be connected by equivalences to their auxiliary variables.\nHaving above auxiliary variables, INVERSE encoding constraints can be easily ex-\npressed using them as follows:\n \ud835\udc4e\ud835\udc63,\ud835\udc59,0 tran \u21d2 \ud835\udc4e\ud835\udc63,\ud835\udc63,\ud835\udc59 =\nfor every \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}\n \ud835\udc4e\ud835\udc63,\ud835\udc59,\ud835\udc50 tran \u21d2 \ud835\udc4e\ud835\udc62,\ud835\udc59 zero \u2227 \ud835\udc4e\ud835\udc62,\ud835\udc63,\ud835\udc59 = \u2227 \ud835\udc4e\ud835\udc62,\ud835\udc59,\ud835\udf0e\ud835\udc62(\ud835\udc63)+deg\ud835\udc3a(\ud835\udc62) tran\nfor each 0 < \ud835\udc50 \u2264 deg\ud835\udc3a(\ud835\udc63), \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, where \ud835\udc62 = \ud835\udc5c\ud835\udc63 \u22121(\ud835\udc50)\n \ud835\udc4e\ud835\udc63,\ud835\udc59,\ud835\udc50 tran \u21d2 \ud835\udc4e\ud835\udc62,\ud835\udc59,\ud835\udf0e\ud835\udc62(\ud835\udc63) tran\nfor each deg\ud835\udc3a (\ud835\udc63) < \ud835\udc50 \u2264 2 \u22c5 deg\ud835\udc3a(\ud835\udc63), \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, where \ud835\udc62 = \ud835\udf0e\ud835\udc63 \u22121(\ud835\udcaf\ud835\udc63 \ud835\udc59 \u2212 deg\ud835\udc3a(\ud835\udc63))\nIn the following space consumption of the INVERSE encoding only regular time layers are counted as asymptotically requirements of the initial and final time layers are dominated by the rest.\nProposition 2 (INVERSE ENCODING SIZE). The number of visible propositional variables in \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \ud835\udef4) is \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309 + \u2211 \u2308log2(deg\ud835\udc3a (\ud835\udc63))\u2309\ud835\udc63\u2208\ud835\udc49 )) and there are \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc49| + |\ud835\udc38|)) auxiliary variables; that is \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309 + \u2211 \u2308log2(deg\ud835\udc3a(\ud835\udc63))\u2309\ud835\udc63\u2208\ud835\udc49 + |\ud835\udc38|)) propositional variables in total. The number of clauses is \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309 + |\ud835\udc38| \u2219 \u2308log2(\ud835\udf07)\u2309 + \u2211 deg\ud835\udc3a(\ud835\udc63)\ud835\udc63\u2208\ud835\udc49 \u2219 (\u2308log2(deg\ud835\udc3a(\ud835\udc63))\u2309))). \nProof. To show the result we need just to calculate variables and clauses. The visible variables, that is, propositional variables representing \ud835\udc9c\ud835\udc63 \ud835\udc59 and \ud835\udcaf\ud835\udc63\n\ud835\udc59 counts for (\ud835\udf02 + 1) \u2219 |\ud835\udc49| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 and \ud835\udf02 \u2219 \u2211 \u2308log2(2 \u22c5 deg\ud835\udc3a(\ud835\udc63) + 1)\u2309\ud835\udc63\u2208\ud835\udc49 respectively. The number of auxiliary variables \ud835\udc4e\ud835\udc63,\ud835\udc59 zero is (\ud835\udf02 + 1) \u2219 |\ud835\udc49|; the number of \ud835\udc4e\ud835\udc62,\ud835\udc63,\ud835\udc59 = variables is (\ud835\udf02 + 1) \u2219 |\ud835\udc38|; and the number of \ud835\udc4e\ud835\udc63,\ud835\udc59,\ud835\udc50 tran variables is 2 \u2219 \ud835\udf02 \u2219 \u2211 deg\ud835\udc3a(\ud835\udc63)\ud835\udc63\u2208\ud835\udc49 which is 4\u2219 \ud835\udf02 \u2219 |\ud835\udc38|. Hence the total number of propositional variables is (\ud835\udf02 + 1) \u2219 (|\ud835\udc49| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 + |\ud835\udc49| + |\ud835\udc38|) + \ud835\udf02 \u2219 (\u2211 \u2308log2(2 \u22c5 deg\ud835\udc3a (\ud835\udc63) + 1)\u2309\ud835\udc63\u2208\ud835\udc49 + 4 \u2219 |\ud835\udc38|) which is \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309 + \u2211 \u2308log2(deg\ud835\udc3a(\ud835\udc63))\u2309\ud835\udc63\u2208\ud835\udc49 + |\ud835\udc38|)).\n(13) \ud835\udc4e\ud835\udc63,\ud835\udc59 zero \u21d2 con=(\ud835\udc9c\ud835\udc63 \ud835\udc59 , 0)\n\ud835\udc4e\ud835\udc62,\ud835\udc63,\ud835\udc59 = \u21d2 var=(\ud835\udc9c\ud835\udc63 \ud835\udc59 , \ud835\udc9c\ud835\udc62 \ud835\udc59+1)\n\ud835\udc4e\ud835\udc63,\ud835\udc59,\ud835\udc50 tran \u21d4 con=(\ud835\udcaf\ud835\udc63 \ud835\udc59, \ud835\udc50)\n(14)\n(15)\n(16)\n(17)\n(18)\nMakespan Optimal Solving of Cooperative Path-Finding\n11\nLet us calculate the number of clauses. A single constraint (13) develops into \u2308log2(\ud835\udf07 + 1)\u2309 binary clauses; a single constraint (14) develops into 2 \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 ternary clauses; and a single constraint (15) develops into \u2308log2(2 \u22c5 deg\ud835\udc3a(\ud835\udc63) + 1)\u2309 binary clauses and one clause of arity \u2308log2(2 \u22c5 deg\ud835\udc3a(\ud835\udc63) + 1)\u2309 + 1. There is as many as \ud835\udf02 \u2219 |\ud835\udc49| constraints (13); \ud835\udf02 \u2219 |\ud835\udc38| constraints (14); and \ud835\udf02 \u2219 \u2211 deg\ud835\udc3a(\ud835\udc63)\ud835\udc63\u2208\ud835\udc49 constraints (15) which in total gives \ud835\udf02 \u2219 ((|\ud835\udc49| + 2 \u2219 |\ud835\udc38|) \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 + \u2211 deg\ud835\udc3a(\ud835\udc63)\ud835\udc63\u2208\ud835\udc49 \u2219 (\u2308log2(2 \u22c5 deg\ud835\udc3a(\ud835\udc63) + 1)\u2309 + 1)) clauses (binary, ternary, and one multi-arity). Constraints (16) count for \ud835\udf02 \u2219 |\ud835\udc49| binary clauses, constraints (17) together with (18) count for 4 \u2219 \ud835\udf02 \u2219 \u2211 deg\ud835\udc3a (\ud835\udc63)\ud835\udc63\u2208\ud835\udc49 binary clauses which is clearly dominated by the already calculated number of clauses. Hence, we have \ud835\udf02 \u2219 (|\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309 + |\ud835\udc38| \u2219 \u2308log2(\ud835\udf07)\u2309 + \u2211 deg\ud835\udc3a(\ud835\udc63)\ud835\udc63\u2208\ud835\udc49 \u2219 (\u2308log2(deg\ud835\udc3a(\ud835\udc63))\u2309)) clauses. \nProposition 3 (PATHS AND \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3) SATISFACTION). A set \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07} of nonoverlapping vertex disjoint paths in ExpT(\ud835\udc3a, \ud835\udf02) so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] for \ud835\udc56 = 1,2, \u2026 , \ud835\udf07 exists if and only if \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3) is satisfiable. Moreover, paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 can be unambiguously constructed from satisfying valuation of \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3) and vice versa. \nSketch of proof. For simplicity, we will show the proposition over finite domain variables instead of bit-vectors. The equivalence between bit vectors and finite domain variables is can be seen directly from the translation of finite domain constraints to equivalent constraints over bit vectors.\nAssume that there exists a collection of vertex disjoint paths \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07}, where \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02]. Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02 , \ud835\udf02]), \ud835\udc62\ud835\udc59 \u2208 \ud835\udc49 for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 where \ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56) and \ud835\udc62\ud835\udf02 = \ud835\udefc+(\ud835\udc4e\ud835\udc56). We can set \ud835\udc9c\ud835\udc620 0 = \ud835\udc56, \ud835\udc9c\ud835\udc621 1 = \ud835\udc56, \u2026, \ud835\udc9c\ud835\udc62\ud835\udf02 \ud835\udf02 = \ud835\udc56. Transition variables are set according to traversed edges; that is, \ud835\udcaf\ud835\udc620 0 = \ud835\udf0e\ud835\udc620(\ud835\udc621), \ud835\udcaf\ud835\udc621 0 = \ud835\udf0e\ud835\udc621(\ud835\udc620) + deg\ud835\udc3a(\ud835\udc621), \ud835\udcaf\ud835\udc621 1 = \ud835\udf0e\ud835\udc621(\ud835\udc622), \ud835\udcaf\ud835\udc622 1 = \ud835\udf0e\ud835\udc622(\ud835\udc621) + deg\ud835\udc3a(\ud835\udc622), \u2026, \ud835\udcaf\ud835\udc62\ud835\udc59 \ud835\udc59 = \ud835\udf0e\ud835\udc62\ud835\udc59(\ud835\udc62\ud835\udc59+1), \ud835\udcaf\ud835\udc62\ud835\udc59+1 \ud835\udc59 = \ud835\udf0e\ud835\udc62\ud835\udc59+1(\ud835\udc62\ud835\udc59) + deg\ud835\udc3a(\ud835\udc62\ud835\udc59+1), \u2026, \ud835\udcaf\ud835\udc62\ud835\udf02\u22121 \ud835\udf02\u22121 = \ud835\udf0e\ud835\udc62\ud835\udf02\u22121(\ud835\udc62\ud835\udf02), \ud835\udcaf\ud835\udc62\ud835\udf02 \ud835\udf02\u22121 = \ud835\udf0e\ud835\udc62\ud835\udf02(\ud835\udc62\ud835\udf02\u22121) + deg\ud835\udc3a(\ud835\udc62\ud835\udf02). Other paths from \u03a0 are processed in the same way. Observe that there is no conflict in setting the variables; that is, each variable is set at most once by the assignment; which is due to the fact that paths are vertex disjoin. Variables \ud835\udc9c\ud835\udc63 \ud835\udc59 and \ud835\udcaf\ud835\udc63 \ud835\udc59 that has not been set so far are set to 0. It is not difficult to check that constraints (4) \u2013 (6) as well as (7) \u2013 (11) are satisfied.\nOn the other hand, if there is a satisfying valuation of \ud835\udc39\ud835\udf02\u2212\ud835\udc3c\ud835\udc41\ud835\udc49(\u03a3) then we are able to reconstruct required vertex disjoint paths from it. Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02, \ud835\udf02]) where \ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56), and \ud835\udc62\ud835\udc59+1 = \ud835\udf0e\ud835\udc62\ud835\udc59 \u22121(\ud835\udcaf\ud835\udc62\ud835\udc59 \ud835\udc59 ) for every \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 \u2212 1 (it holds also that \ud835\udc62\ud835\udc59 = \ud835\udf0e\ud835\udc62\ud835\udc59+1 \u22121 (\ud835\udcaf\ud835\udc62\ud835\udc59+1 \ud835\udc59+1 ) \u2212 degG (\ud835\udc62\ud835\udc59+1)). Transition state variables \ud835\udcaf\ud835\udc63 \ud835\udc59 that take just one value ensure that each vertex at each time layer needs to decide if it either is connected to a neighbor or accepts a connection from a neighbor (or is connected to itself). It is ensured that no intersection between selected paths appears as otherwise a vertex must have accepted connections from at least two sources or has to branch connections to at least two neighbors, which is both forbidden. A value of \ud835\udc9c\ud835\udc63 \ud835\udc59 variable is propagated to the next time layer only through the connection of the corresponding transition state variable \ud835\udcaf\ud835\udc63 \ud835\udc59. The\nPavel Surynek 12\nfact that agents were propagated to their goals ensures that there must be a paths induced by transition state variables from initial positions of agents to their goal.  The following theorem can be directly obtained by applying Proposition 1 and Proposition 3 which together justify solving of CPF via translation to SAT.\nTheorem 1 (SOLUTION OF \u03a3 AND \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3) SATISFACTION). A solution of a CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+) with \ud835\udc34 = {\ud835\udc4e1, \ud835\udc4e2, \u2026 , \ud835\udc4e\ud835\udf07} exists if and only if there exist \ud835\udf02 \u2208 \u2115 for that formula \ud835\udc39\ud835\udf02\u2212\ud835\udc3c\ud835\udc41\ud835\udc49(\u03a3) is satisfiable. "}, {"heading": "4.2.2. ALL-DIFFERENT Propositional Encoding", "text": "Choosing location function instead of its inverse for representing arrangements of agents at individual time steps led to another encoding called ALL-DIFFERENT \u2013 the name comes from the fact that it is necessary to express the requirement that each vertex is occupied by at most one agent explicitly which is modeled by pair-wise differences between variables representing the arrangement. Again it is easier to express the encoding over finite domain state variables before it is transformed to propositional formula.\nDefinition 6 (ALL-DIFFERENT ENCODING \u2013 \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3)). Assume that a CPF \u03a3 = [\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+] with \ud835\udc3a = (\ud835\udc49, \ud835\udc38) is given. An ALL-DIFFERENT encoding for CPF \u03a3 consists of finite domain variables \u2112\ud835\udc4e\n\ud835\udc59 \u2208 {1, \u2026 , \ud835\udc5b} for every \ud835\udc4e \u2208 \ud835\udc34 and each time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} to model locations of agents over time. Constraints are as follows:\n \u2112\ud835\udc4e \ud835\udc59 = \ud835\udc57 \u21d2 \u2112\ud835\udc4e \ud835\udc59+1 = \ud835\udc57 \u2228 \u22c1 \u2112\ud835\udc4e \ud835\udc59+1 = \ud835\udcbf\ud835\udcbf\u2208{1,\u2026,\ud835\udc5b}|{\ud835\udc63\ud835\udc57,\ud835\udc63\ud835\udcbf}\u2208\ud835\udc38\nfor every \ud835\udc4e \u2208 \ud835\udc34, \ud835\udc57 \u2208 {1,2, \u2026 , \ud835\udc5b} and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1} (agent \ud835\udc4e moves along edges only or stay in a vertex)\n \u22c0 \u2112\ud835\udc4e \ud835\udc59+1 \u2260 \u2112\ud835\udc4f \ud835\udc59 \ud835\udc4f\u2208\ud835\udc34|\ud835\udc4f\u2260\ud835\udc4e for every \ud835\udc4e \u2208 \ud835\udc34 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}\n(target vertex of agent\u2019s \ud835\udc4e move must be empty)\n AllDifferent(\u2112\ud835\udc4e1 \ud835\udc59 , \u2112\ud835\udc4e2 \ud835\udc59 , \u2026 , \u2112\ud835\udc4e\ud835\udf07 \ud835\udc59 ) for every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}\n(at most one agent reside in each vertex at each time step). \u25a1\nInitial and goal arrangements will be expressed though the following constraints:\n \u2112\ud835\udc4e 0 = \ud835\udc57 for \ud835\udc4e \u2208 \ud835\udc34 with \ud835\udefc0(\ud835\udc4e) = \ud835\udc63\ud835\udc57  \u2112\ud835\udc4e \ud835\udf02 = \ud835\udc57 for \ud835\udc4e \u2208 \ud835\udc34 with \ud835\udefc+(\ud835\udc4e) = \ud835\udc63\ud835\udc57\nAgain, finite domain state variables \u2112\ud835\udc4e \ud835\udc59 are represented as a bit vector (vector of propositional variables) using binary encoding. That is, \u2308log2 |\ud835\udc49|\u2309 propositional variables are introduced for each \u2112\ud835\udc4e \ud835\udc59 variable. The resulting formula in CNF will be denoted as \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3). AllDifferent(\u2112\ud835\udc4e1 \ud835\udc59 , \u2112\ud835\udc4e2 \ud835\udc59 , \u2026 , \u2112\ud835\udc4e\ud835\udf07 \ud835\udc59 ) constraint requires that all the involved variables are assigned different values; that is, \u22c0 \u2112\ud835\udc4e\ud835\udc57 \ud835\udc59 \u2260 \u2112\ud835\udc4e\ud835\udc58 \ud835\udc59 \ud835\udc57,\ud835\udc58\u2208{1,2,\u2026,\ud835\udf07}|\ud835\udc57<\ud835\udc58 . Differences between finite\n(19)\n(23)\n} Initial locations (22)\n(20)\n(21)\n} Goal locations\nMakespan Optimal Solving of Cooperative Path-Finding\n13\ndomain state variables are encoded using the scheme introduced in [1]. The scheme is used to encode constraints (20) as well as (21). Inequality between variables \u2112\ud835\udc4e\ud835\udc57 \ud835\udc59 and \u2112\ud835\udc4e\ud835\udc58 \ud835\udc59 is expressed in the scheme by the following clauses. Auxiliary variables \ud835\udc51\ud835\udc57,\ud835\udc58 \ud835\udc59 representing difference at individual bits are introduced.\nConditional equality disjunction (19) is encoded by introducing auxiliary propositional variables to represent equalities between bit vectors. For each \ud835\udc57 \u2208 {1,2, \u2026 , \ud835\udc5b} (that is, for each vertex), agent \ud835\udc4e \u2208 \ud835\udc34, and time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}, an auxiliary variable \ud835\udc52\ud835\udc4e,\ud835\udc57 \ud835\udc59 which stands for equality \u2112\ud835\udc4e \ud835\udc59 = \ud835\udc57 is introduced. The link between auxiliary variables \ud835\udc52\ud835\udc4e,\ud835\udc57 \ud835\udc59 and actual equalities is established through the following constraint:\nThen moving along edges \u2013 constraints (19) \u2013 can be easily expressed as single clause\nover auxiliary variables:\nAgain, the space consumption of the ALL-DIFFERENT encoding will be calculated for\nregular time layers only.\nProposition 4 (ALL-DIFFERENT ENCODING SIZE). The number of visible propositional variables in \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) is \ud835\udcaa(\ud835\udf02 \u2219 \ud835\udf07 \u2219 \u2308log2|\ud835\udc49|\u2309) and there are \ud835\udcaa(\ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49|) auxiliary variables; that is, the number of variables is \ud835\udcaa(\ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49|). The number of clauses is\n\ud835\udcaa (\ud835\udf02 \u2219 \u2308log2|\ud835\udc49|\u2309 \u2219 (( \ud835\udf07 2 ) + \ud835\udf07 \u2219 |\ud835\udc49|)). \nProof. Let us calculate the number of variables and clauses. Each variable \u2112\ud835\udc4e \ud835\udc59 is represented by log2|\ud835\udc49| variables and the number of \u2112\ud835\udc4e \ud835\udc59 variables is (\ud835\udf02 + 1) \u2219 \ud835\udf07. For each \u2112\ud835\udc4e \ud835\udc59 variable and its value, an auxiliary variable is introduced. As \u2112\ud835\udc4e \ud835\udc59 can take |\ud835\udc49| values, we get the result that there are (\ud835\udf02 + 1) \u2219 \ud835\udf07 \u2219 (log2|\ud835\udc49| + |\ud835\udc49|) variables which is \ud835\udcaa(\ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49|).\nA single time layer requires as many as (\ud835\udf07 2 ) inequalities between all pairs of \u2112\ud835\udc4e \ud835\udc59 variables corresponding to distinct agents to model the AllDifferent constraint from (21). Each inequality is modeled by 2 \u2219 \u2308log2|\ud835\udc49|\u2309 ternary clauses plus one clause of arity \u2308log2|\ud835\udc49|\u2309. This is in total (\ud835\udf02 + 1) \u2219 (\ud835\udf07 2 ) \u2219 (2 \u2219 \u2308log2|\ud835\udc49|\u2309 + 1) clauses.\n(24)\n\u22c0 (\ud835\udc51\ud835\udc57,\ud835\udc58 \ud835\udc59 \u2228 \u2112\ud835\udc4e\ud835\udc57 \ud835\udc59 [\ud835\udd5a] \u2228 \u2112\ud835\udc4e\ud835\udc58 \ud835\udc59 [\ud835\udd5a]) \u2227 (\ud835\udc51\ud835\udc57,\ud835\udc58 \ud835\udc59 \u2228 \u2112\ud835\udc4e\ud835\udc57 \ud835\udc59 [\ud835\udd5a] \u2228 \u2112\ud835\udc4e\ud835\udc58 \ud835\udc59 [\ud835\udd5a])\n\u2308log2\ud835\udc5b\u2309\u22121\n\ud835\udd5a=0\nvar\u2260 (\u2112\ud835\udc4e\ud835\udc57 \ud835\udc59 , \u2112\ud835\udc4e\ud835\udc58 \ud835\udc59 ) = \u22c1 \ud835\udc51\ud835\udc57,\ud835\udc58 \ud835\udc59\n\u2308log2\ud835\udc5b\u2309\u22121\n\ud835\udd5a=0\nwhere\n(25) \ud835\udc52\ud835\udc4e,\ud835\udc57 \ud835\udc59 \u21d4 con=(\u2112\ud835\udc4e \ud835\udc59 , \ud835\udc57)\n\ud835\udc52\ud835\udc4e,\ud835\udc57 \ud835\udc59 \u21d2 \ud835\udc52\ud835\udc4e,\ud835\udc57 \ud835\udc59+1 \u2228 \u22c1 \ud835\udc52\ud835\udc4e,\ud835\udcbf \ud835\udc59+1\n\ud835\udcbf\u2208{1,\u2026,\ud835\udc5b}|{\ud835\udc63\ud835\udc57,\ud835\udc63\ud835\udcbf}\u2208\ud835\udc38\n(26)\nPavel Surynek 14\nNext, we need as many as (\ud835\udf07 2 ) inequalities between \u2112\ud835\udc4e \ud835\udc59 variables from two consecutive\ntime layers (constraint (20)) which adds the same number of (\ud835\udf02 + 1) \u2219 (\ud835\udf07 2 ) \u2219 (2 \u2219 \u2308log2|\ud835\udc49|\u2309 + 1) clauses again.\nLinks between auxiliary variables \ud835\udc52\ud835\udc4e,\ud835\udc57 \ud835\udc59 and actual equalities (25) they represent need \u2308log2|\ud835\udc49|\u2309 binary clauses plus one clause of arity \u2308log2|\ud835\udc49|\u2309 + 1, which is (\ud835\udf02 + 1) \u2219 \ud835\udf07 \u2219 |\ud835\udc49| \u2219 (\u2308log2|\ud835\udc49|\u2309 + 1) in total. Finally, constraints expressing that agents move along edges only (26) contribute to each vertex \ud835\udc63\ud835\udc57 in ExpT(\ud835\udc3a, \ud835\udf02) at given time layer except the last one by \ud835\udf07 clauses of arity degG(\ud835\udc63\ud835\udc57) + 2 which is \ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49| clauses in total.\nAltogether we have (\ud835\udf02 + 1) \u2219 ((\ud835\udf07 2 ) \u2219 (2 \u2219 \u2308log2|\ud835\udc49|\u2309 + 1) + \ud835\udf07 \u2219 |\ud835\udc49| \u2219 (\u2308log2|\ud835\udc49|\u2309 + 1)) +\n\ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49| clauses in \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) encoding which is \ud835\udcaa (\ud835\udf02 \u2219 \u2308log2|\ud835\udc49|\u2309 \u2219 (( \ud835\udf07 2 ) + \ud835\udf07 \u2219 |\ud835\udc49|)). \nProposition 5 (PATHS AND \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) SATISFACTION). A set \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07} of nonoverlapping vertex disjoint paths in ExpT(\ud835\udc3a, \ud835\udf02) so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] for \ud835\udc56 = 1,2, \u2026 , \ud835\udf07 exists if and only if \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) is satisfiable. Moreover, paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 can be unambiguously constructed from satisfying valuation of \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) and vice versa. \nSketch of proof. For simplicity, we will work on the level of finite domain state variables. Assume that non-overlapping vertex disjoint paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 exist in ExpT(\ud835\udc3a, \ud835\udf02). The satisfying valuation of \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) can be directly constructed from these paths. Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02, \ud835\udf02]), \ud835\udc62\ud835\udc59 \u2208 \ud835\udc49 for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 where \ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56) and \ud835\udc62\ud835\udf02 = \ud835\udefc+(\ud835\udc4e\ud835\udc56). Then finite domain state variables will be set as follows: \u2112\ud835\udc4e\ud835\udc56 0 = \ud835\udc620, \u2112\ud835\udc4e\ud835\udc56 1 = \ud835\udc621, \u2026, \u2112\ud835\udc4e\ud835\udc56 \ud835\udf02 = \ud835\udc62\ud835\udf02 for every \ud835\udc56 = 1,2, \u2026 , \ud835\udf07. The assumptions that paths were vertex disjoint and nonoverlapping ensure that constraints (21) and (20) respectively are satisfied. Consecutive vertices in paths are connected by directed edges that correspond to edges in \ud835\udc3a. Hence, constraints (19) are satisfied.\nAssume on the other hand that we have a satisfying valuation of \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3). We can\nimmediately set \ud835\udf0b\ud835\udc56 = ([\u2112\ud835\udc4e\ud835\udc56 0 , 0], [\u2112\ud835\udc4e\ud835\udc56 1 , 1], [\u2112\ud835\udc4e\ud835\udc56 2 , 2], \u2026, [\u2112\ud835\udc4e\ud835\udc56 \ud835\udf02 , \ud835\udf02]) for every \ud835\udc56 = 1,2, \u2026 , \ud835\udf07. Satisfaction of constraints (19) ensures that constructed sequences of vertices are paths in ExpT(\ud835\udc3a, \ud835\udf02) which are moreover vertex disjoint and non-overlapping due to constraints (21) and (20). \nCPF solving via \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) satisfaction is justified by the following theorem which can be shown by combining Proposition 1 and just proven Proposition 5 (from \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) satisfaction non-overlapping vertex disjoint paths can be obtained which correspond to CPF solution). Theorem 2 (SOLUTION OF \u03a3 AND \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) SATISFACTION). A solution of a CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+) exists if and only if there exist \ud835\udf02 \u2208 \u2115 for that formula \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc39\ud835\udc39(\ud835\udf02, \u03a3) is satisfiable. \nMakespan Optimal Solving of Cooperative Path-Finding\n15"}, {"heading": "4.2.3. MATCHING Propositional Encoding", "text": "We observed that vertex disjoint non-overlapping paths in time expansion graph resemble a commodity flow [1] in a network of time expansion graph where vertices and edges are assigned unit capacities. The intuition is that edges included into paths should be saturated by one unit of the flow. Such setting conveys commodity from each initial vertex to each goal vertex. However, the correspondence between paths of required properties and flow works in one direction only. The flow reflects well the requirement that paths should be vertex disjoint but does not simulate non-overlapping between paths as well as the correct interconnection between initial and goal vertex of the same agents (the flow may interconnect initial and goal vertices of two distinct agents).\nThe design of the MATCHING encoding will follow the intuition suggested by single commodity flows. It will be divided into two parts \u2013 the first part, called FLOW part, will check the existence of a flow that generates non-overlapping vertex disjoint paths. This\nPavel Surynek 16\npart can be regarded as an encoding of a relaxed CPF with anonymous agents where we care about relocation of a group of agents to a set of goal vertices but we don\u2019t care about what particular agent arrives at particular goal vertex (generated paths may interconnect initial and goal vertices of distinct agents). The second part, called MAPPING part, of the encoding maps distinguishable agents to paths marked out by the flow, which eventually override the relaxation from the first part of the encoding. The encoding should allow fast testing of the existence of non-overlapping flow to enable using this test as a heuristic since its existence is necessary condition for existence of a solution.\nDefinition 7 (MATCHING ENCODING \u2013 \ud835\udc39\ud835\udf02\u2212\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b \ud835\udc39\ud835\udc3f\ud835\udc42\ud835\udc4a (\u03a3)). A FLOW part of the MATCHING encoding of given CPF \u03a3 = [\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+] with \ud835\udc3a = (\ud835\udc49, \ud835\udc38) consists of a propositional variable for each vertex and edge in the time expansion graph that model its saturation by the flow. That is, propositional variable \u2133\ud835\udc63 \ud835\udc59 is introduced for every \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 and \ud835\udc63 \u2208 \ud835\udc49 and propositional variables \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 and \u2130\ud835\udc62 \ud835\udc59 are introduced for every \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 and {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38 and \ud835\udc62 \u2208 \ud835\udc49 respectively. Constraints enforce that variables set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 form a nonoverlapping flow:\n \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \u21d2 \u2133\ud835\udc62 \ud835\udc59 \u2227 \u2133\ud835\udc63 \ud835\udc59+1 for every {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38\nand \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, \u2130\ud835\udc62 \ud835\udc59 \u21d2 \u2133\ud835\udc62 \ud835\udc59 \u2227 \u2133\ud835\udc62\n\ud835\udc59+1 for every \ud835\udc62 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1} (if an edge is selected into flow then its endpoints are selected as well)\n \u2130\ud835\udc62 \ud835\udc59 + \u2211 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \ud835\udc63|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38 \u2264 1 for every \ud835\udc62 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1},\n\u2130\ud835\udc63 \ud835\udc59 + \u2211 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \ud835\udc62|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38 \u2264 1 for every \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, (at most one incoming and outgoing edge is selected into flow)\n \u2133\ud835\udc62 \ud835\udc59 \u21d2 \u2130\ud835\udc62 \ud835\udc59 \u2228 \u22c1 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \ud835\udc63|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38 for every \ud835\udc62 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1},\n\u2133\ud835\udc63 \ud835\udc59+1 \u21d2 \u2130\ud835\udc62 \ud835\udc59 \u2228 \u22c1 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \ud835\udc62|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38 for every \ud835\udc63 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, (if a vertex is selected into flow then at least one outgoing and incoming edge must be selected as well)\n \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \u21d2 \u2133\ud835\udc63 \ud835\udc59 for every {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38\nand \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1},\n(source and target vertices of non-trivial moves must be disjoint). \u25a1\nThe second part of the encoding where individual distinguishable agents manifest them-\nselves is introduced in the following definition.\nDefinition 8 (MATCHING ENCODING \u2013 \ud835\udc39\ud835\udf02\u2212\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b \ud835\udc40\ud835\udc34\ud835\udc43 (\u03a3)). A MAPPING part of the MATCHING encoding of given CPF \u03a3 = [\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+] with \ud835\udc3a = (\ud835\udc49, \ud835\udc38) consists of a finite domain variable \ud835\udc9c\ud835\udc63\n\ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf07} for each vertex \ud835\udc63 \u2208 \ud835\udc49 and every time layer \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 to model agent occurrence in a vertex. Constraints interconnect the MAPPING part with FLOW part so that actual agents follow paths indicated by the flow:\n \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \u21d2 \ud835\udc9c\ud835\udc62 \ud835\udc59 = \ud835\udc9c\ud835\udc63 \ud835\udc59+1 for every {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38\nand \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1},\n(25)\n(26)\n(27)\n(28)\n(29)\nMakespan Optimal Solving of Cooperative Path-Finding\n17\n(if an edge is saturated by the flow then the same agent appears at its both ends)\n \ud835\udc9c\ud835\udc62 \ud835\udc59 \u2260 0 \u21d2 \u2133\ud835\udc62 \ud835\udc59 for every \ud835\udc62 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}\nAs in the previous encodings \ud835\udc9c\ud835\udc63 \ud835\udc59 variables having \ud835\udf07 + 1 states are represented by \u2308log2(\ud835\udf07 + 1)\u2309 propositional variables using binary encoding. Initial and goal arrangements will be expressed though the following constraints:\n \ud835\udc9c\ud835\udc62 0 = \ud835\udc56 \u2227 \u2133\ud835\udc62 0 for \ud835\udc62 \u2208 \ud835\udc49 if there is \ud835\udc56 \u2208 {1,2, \u2026 , \ud835\udf07} such that \ud835\udefc0(\ud835\udc4e\ud835\udc56) = \ud835\udc62  \ud835\udc9c\ud835\udc62 0 = 0 \u2227 \u2133\ud835\udc62 0 for \ud835\udc62 \u2208 \ud835\udc49 if (\u2200\ud835\udc4e \u2208 \ud835\udc34)\ud835\udefc0(\ud835\udc4e) \u2260 \ud835\udc62\n(32)\n} Initial locations (31)\n(30)\nPavel Surynek 18\n \ud835\udc9c\ud835\udc62 \ud835\udf02 = \ud835\udc56 \u2227 \u2133\ud835\udc62 \ud835\udf02 for \ud835\udc62 \u2208 \ud835\udc49 if there is \ud835\udc56 \u2208 {1,2, \u2026 , \ud835\udf07}\nsuch that \ud835\udefc+(\ud835\udc4e\ud835\udc56) = \ud835\udc62\n \ud835\udc9c\ud835\udc62 \ud835\udf02 = 0 \u2227 \u2133\ud835\udc62 \ud835\udf02 for \ud835\udc62 \u2208 \ud835\udc49 if (\u2200\ud835\udc4e \u2208 \ud835\udc34)\ud835\udefc+(\ud835\udc4e) \u2260 \ud835\udc62\nThe resulting formula of the MATCHING encoding in CNF is a conjunction of the FLOW part, MAPPING part, and boundary conditions and is denoted as \ud835\udc39\ud835\udf02\u2212\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\u03a3). To obtain CNF it is necessary to rewrite (26) as clauses. That is, for example \u2130\ud835\udc62 \ud835\udc59 + \u2211 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \ud835\udc63|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38 \u2264 1 is rewritten as a conjunction of clauses that forbid all pairs of involved variables to be set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 simultaneously:\nBinary encoded variables \ud835\udc9c\ud835\udc63 \ud835\udc59 are not involved in any complex relation \u2013 only conditional equality between these variables are introduced while all other modeling issues concerning validity conditions are done in the FLOW part of the encoding.\nThe conditional equality between \ud835\udc9c\ud835\udc62 \ud835\udc59 and \ud835\udc9c\ud835\udc63 \ud835\udc59+1 (25) can be expressed using construct\nintroduced earlier:\nConstraint (26) can be also easily rewritten as follows:\nProposition 6 (MATCHING ENCODING SIZE). The number of propositional variables in\n\ud835\udc39\ud835\udf02\u2212\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\u03a3) is \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc38| + |\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309)). The number of clauses is \ud835\udcaa (\ud835\udf02 \u2219\n((|\ud835\udc49| + |\ud835\udc38|) \u2219 \u2308log2(\ud835\udf07)\u2309 + \u2211 ( degG(\ud835\udc63)\n2 )\ud835\udc63\u2208\ud835\udc49 )). \nProof. The FLOW part of the MATCHING encoding has a propositional variable \u2133\ud835\udc63 \ud835\udc59 for each vertex \ud835\udc63 \u2208 \ud835\udc49 and time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} and \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 for each edge {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38 and time layer, which in total makes (\ud835\udf02 + 1) \u2219 (|\ud835\udc49| + |\ud835\udc38|) propositional variables. Further, we have a vector of \u2308log2(\ud835\udf07 + 1)\u2309 propositional variables representing \ud835\udc9c\ud835\udc63 \ud835\udc59 for each vertex and time layer in the MAPPING part. This in total makes another (\ud835\udf02 + 1) \u2219 |\ud835\udc49| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 variables. Altogether, there are (\ud835\udf02 + 1) \u2219 (|\ud835\udc38| + |\ud835\udc49| + |\ud835\udc49| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309) variables which is \ud835\udcaa(\ud835\udf02 \u2219 (|\ud835\udc38| + |\ud835\udc49| \u2219 \u2308log2(\ud835\udf07)\u2309)).\nConstraints (25) develops into \ud835\udf02 \u2219 (|\ud835\udc49| + |\ud835\udc38|) ternary clauses. Constraints (26) develop\ninto 2 \u2219 \ud835\udf02 \u2219 \u2211 (degG (\ud835\udc63)+1 2 )\ud835\udc63\u2208\ud835\udc49 binary clauses as indicated by (31). Constraints (27) introduce two clauses of length degG(\ud835\udc63) + 1 for each vertex and time layer; that is, 2 \u2219 \ud835\udf02 \u2219 |\ud835\udc49| clauses\n} Goal locations (34)\n(33)\n\u22c0 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \u2228 \u2130\ud835\udc62,\ud835\udc64 \ud835\udc59\n\ud835\udc63,\ud835\udc64|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38\u2227{\ud835\udc62,\ud835\udc64}\u2208\ud835\udc38\u2227\ud835\udc63\u2260\ud835\udc64\n\u22c0 \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \u2228 \u2130\ud835\udc62 \ud835\udc59\n\ud835\udc63|{\ud835\udc62,\ud835\udc63}\u2208\ud835\udc38\n(35)\n\u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 \u21d2 var=(\ud835\udc9c\ud835\udc62 \ud835\udc59 , \ud835\udc9c\ud835\udc63 \ud835\udc59+1) (36)\n\u22c0 \ud835\udc9c\ud835\udc62 \ud835\udc59 [\ud835\udd5a] \u2228 \u2133\ud835\udc62\n\ud835\udc59 \u2308log2(\ud835\udf07+1)\u2309\u22121\n\ud835\udd5a=0\n(37)\nMakespan Optimal Solving of Cooperative Path-Finding\n19\nare added. Finally, constraints (28) add a binary clause for each vertex and time layer, which is again dominated by previous expressions. Conditional equality between two bit vectors in (29) develops into 2 \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 ternary clauses while the equality is introduced for each edge and time layer; that is, 2 \u2219 \ud835\udf02 \u2219 |\ud835\udc38| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 ternary clauses are added. It is easy to observe that expression (30) represents (\ud835\udf02 + 1) \u2219 |\ud835\udc38| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 binary clauses. Altogether, there are \ud835\udf02 \u2219 (3 \u2219 |\ud835\udc49| + |\ud835\udc38| + 2 \u2219 \u2211 (degG (\ud835\udc63)+1 2 )\ud835\udc63\u2208\ud835\udc49 + 2 \u2219 |\ud835\udc38| \u2219\n\u2308log2(\ud835\udf07 + 1)\u2309) + (\ud835\udf02 + 1) \u2219 |\ud835\udc38| \u2219 \u2308log2(\ud835\udf07 + 1)\u2309 clauses which is \ud835\udcaa (\ud835\udf02 \u2219 ((|\ud835\udc49| + |\ud835\udc38|) \u2219\n\u2308log2(\ud835\udf07)\u2309 + \u2211 ( degG(\ud835\udc63)\n2 )\ud835\udc63\u2208\ud835\udc49 )). \nProposition 7 (PATHS AND \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) SATISFACTION). A set \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07} of non-overlapping vertex disjoint paths in ExpT(\ud835\udc3a, \ud835\udf02) so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] for \ud835\udc56 = 1,2, \u2026 , \ud835\udf07 exists if and only if \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) is satisfiable. Moreover, paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 can be unambiguously constructed from satisfying valuation of \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) and vice versa. \nSketch of proof. We will work at the level of finite domain state variables \ud835\udc9c\ud835\udc63 \ud835\udc59 instead of bit vectors to simplify the proof.\nAssume that non-overlapping vertex disjoint paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 exist so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] in ExpT(\ud835\udc3a, \ud835\udf02). Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02, \ud835\udf02]), with \ud835\udc62\ud835\udc59 \u2208 \ud835\udc49 for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 where \ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56) and \ud835\udc62\ud835\udf02 = \ud835\udefc+(\ud835\udc4e\ud835\udc56). The satisfying valuation of \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) can be easily constructed by setting \ud835\udc9c\ud835\udc620 0 = \ud835\udc56, \ud835\udc9c\ud835\udc621 1 = \ud835\udc56, \u2026, \ud835\udc9c\ud835\udc62\ud835\udf02 \ud835\udf02 = \ud835\udc56. Next, variables representing flow \u2133\ud835\udc620 0 , \u2133\ud835\udc621 1 , \u2026, \u2133\ud835\udc62\ud835\udf02 \ud835\udf02 are set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 and \u2130\ud835\udc620,\ud835\udc621 0 , \u2130\ud835\udc621,\ud835\udc622 1 , \u2026, \u2130\ud835\udc62\ud835\udf02\u22121,\ud835\udc62\ud835\udf02 \ud835\udf02\u22121 are set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 as well (the convention that \u2130\ud835\udc62\ud835\udc59,\ud835\udc62\ud835\udc59+1 \ud835\udc59 \u2261 \u2130\ud835\udc62\ud835\udc59 \ud835\udc59 if \ud835\udc62\ud835\udc59 = \ud835\udc62\ud835\udc59+1 is used here). Now, observe that all the constraints are satisfied. The interconnection between the FLOW and the MAPPING part (constraints (25) and (26)) is satisfied by the construction so we just need to check constraints in the FLOW part of the encoding. Propagation of the flow from edges to vertices (constraints (24)) is also ensured by the construction. The fact that original paths are vertex disjoint ensures validity of constraints (25) and (26) which together enforce selection of exactly one incoming and one outgoing edge through setting \u2130\ud835\udc62,\ud835\udc63 \ud835\udc59 variables for each vertex saturated by the flow indicated by \u2133\ud835\udc63 \ud835\udc59 variable set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38. Finally, the non-overlapping property of paths is directly translated to satisfaction of constraints (28). Initial and goal location constraints are trivially satisfied. Altogether, \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) is satisfied by constructed valuation of its variables. Now let us check the opposite implication. Assume that \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) is satisfiable. Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02 , \ud835\udf02]) such that \ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56) and \u2130\ud835\udc62\ud835\udc59,\ud835\udc62\ud835\udc59+1 \ud835\udc59 is \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 for each \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 \u2212 1. This can be done due to constraints (25) - (27) that propagate flow from the initial positions in the first time layer towards final layer. We shall verify that paths constructed in this way have required properties \u2013 are vertex disjoint non-overlapping and interconnects initial and goal positions of agents. FLOW part of the encoding ensures that constructed paths are vertex disjoint and non-overlapping. We need just to add nonoverlapping to already checked flow propagation. The non-overlapping is established by constraints (28). However, the FLOW part does not ensure that \ud835\udc62\ud835\udf02 = \ud835\udefc+(\ud835\udc4e\ud835\udc56); satisfaction\nPavel Surynek 20\nof the FLOW part alone may result in a path that interconnects initial and goal positions of two distinct agents. This is corrected by constraints included in the MAPPING part of the encoding. These constraints propagate agent \ud835\udc4e\ud835\udc56 along edges {\ud835\udc62\ud835\udc59 , \ud835\udc62\ud835\udc59+1} and eventually force it to appear in \ud835\udc62\ud835\udf02 where goal constraints (33) and (34) ensure that agent \ud835\udc4e\ud835\udc56 arrives to the right vertex. \nBy combining just proven Proposition 7 and correspondence between non-overlapping\nvertex disjoint paths in ExpT(\ud835\udc3a, \ud835\udf02) the following theorem can be immediately obtained.\nTheorem 3 (SOLUTION OF \u03a3 AND \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) SATISFACTION). A solution of a CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+) exists if and only if there exist \ud835\udf02 \u2208 \u2115 for that formula \ud835\udc39\ud835\udc40\ud835\udc34\ud835\udc47\ud835\udc36\ud835\udc3b(\ud835\udf02, \u03a3) is satisfiable. "}, {"heading": "4.2.4. DIRECT/SIMPLIFIED Propositional Encoding", "text": "As all the previous encodings of CPF used binary representation of agent occurrence in a vertex in some form, we also considered encoding of CPF that expresses agent occurrences in vertices directly. That is, there will be single propositional variable that encodes occurrence of a given agent in a given vertex at a given time-step. The resulting CPF encoding will be called DIRECT. While the design of variables is extremely simple in the DIRECT encoding, the set of constraints is more complex as summarized in the following definition [30].\nDefinition 9 (DIRECT ENCODING \u2013 \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3)). Assume that a CPF \u03a3 = [\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+] with \ud835\udc3a = (\ud835\udc49, \ud835\udc38) is given. A DIRECT encoding for CPF \u03a3 consists of propositional variables \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 for every \ud835\udc4e \u2208 \ud835\udc34, \ud835\udc63 \u2208 \ud835\udc49, and time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} to model occurrences of agents in vertices over time. The interpretation is that \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 is assigned \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 if and agent \ud835\udc4e appears in vertex \ud835\udc63 at time step \ud835\udc59. The following constrains ensure satisfaction of validity conditions between consecutive arrangements of agents:\n \u22c0 \ud835\udcb3\ud835\udc4e,\ud835\udc62 \ud835\udc59 \u2228 \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \ud835\udc62,\ud835\udc63\u2208\ud835\udc49,\ud835\udc62\u2260\ud835\udc63 for every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}\n\u22c1 \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \ud835\udc63\u2208\ud835\udc49 and \ud835\udc4e \u2208 \ud835\udc34 (an agent is placed in exactly one vertex at each time step)\n \u22c0 \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \u2228 \ud835\udcb3\ud835\udc4f,\ud835\udc63 \ud835\udc59 \ud835\udc4e,\ud835\udc4f\u2208A,\ud835\udc4e\u2260\ud835\udc4f for every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}\nand \ud835\udc63 \u2208 \ud835\udc49 (at most one agent is placed in each vertex at each time step)\n \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \u21d2 \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59+1 \u2228 \u22c1 \ud835\udcb3\ud835\udc4e,\ud835\udc62 \ud835\udc59+1 \ud835\udc62\u2208\ud835\udc49,{\ud835\udc63,\ud835\udc62}\u2208\ud835\udc38 for every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1},\n\ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59+1 \u21d2 \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \u2228 \u22c1 \ud835\udcb3\ud835\udc4e,\ud835\udc62 \ud835\udc59 \ud835\udc62\u2208\ud835\udc49,{\ud835\udc63,\ud835\udc62}\u2208\ud835\udc38 \ud835\udc63 \u2208 \ud835\udc49, and \ud835\udc4e \u2208 \ud835\udc34 (an agent relocates to some of its neighbors or makes no move)\n \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \u2227 \ud835\udcb3\ud835\udc4e,\ud835\udc62 \ud835\udc59+1 \u21d2 \u22c0 \ud835\udcb3\ud835\udc4f,\ud835\udc62 \ud835\udc59 \ud835\udc4f\u2208\ud835\udc34 \u2227 \u22c0 \ud835\udcb3\ud835\udc4f,\ud835\udc63 \ud835\udc59+1 \ud835\udc4f\u2208\ud835\udc34\nfor every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, \ud835\udc62, \ud835\udc63 \u2208 \ud835\udc49 such that {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38 and \ud835\udc4e \u2208 \ud835\udc34\n(target vertex of a move must be vacant and the source vertex\n(38)\n(39)\n(40)\n(41)\nMakespan Optimal Solving of Cooperative Path-Finding\n21\nwill be vacant after the move is performed). \u25a1\nInitial and goal arrangements will be expressed though the following constraints:\n \ud835\udcb3\ud835\udc4e,\ud835\udc63 0 for \ud835\udc63 \u2208 \ud835\udc49 if there is \ud835\udc4e \u2208 \ud835\udc34\nsuch that \ud835\udefc0(\ud835\udc4e) = \ud835\udc63\n \ud835\udcb3\ud835\udc4e,\ud835\udc63 0 otherwise  \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udf02 for \ud835\udc63 \u2208 \ud835\udc49 if there is \ud835\udc4e \u2208 \ud835\udc34\nsuch that \ud835\udefc+(\ud835\udc4e) = \ud835\udc63\n \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udf02\notherwise\nThe resulting DIRECT encoding formula in CNF will be denoted as \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3). It can be easily observed that the vacancy of target vertex and source vertex before and after the move (constraint (41)) is quite repetitive as the right side of the implication is independent of agent \ud835\udc4e. Therefore, the encoding is enhanced by introducing auxiliary variables \u2130\ud835\udc62 \ud835\udc59 for each vertex \ud835\udc62 \u2208 \ud835\udc49 and time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} that represent vacancy of vertex \ud835\udc62 at time step \ud835\udc59. Semantics of \u2130\ud835\udc62 \ud835\udc59 variables is represented by the following constraint:\n \u2130\ud835\udc62 \ud835\udc59 \u21d2 \u22c0 \ud835\udcb3\ud835\udc4e,\ud835\udc62 \ud835\udc59 \ud835\udc4e\u2208\ud835\udc34 for every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} and \ud835\udc62 \u2208 \ud835\udc49\n(in an empty vertex no agent can appear at given time)\nThe repetitive part in constraint (41) can be then replaced by its version with auxiliary\nvariables as follows:\n \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 \u2227 \ud835\udcb3\ud835\udc4e,\ud835\udc62 \ud835\udc59+1 \u21d2 \u2130\ud835\udc62 \ud835\udc59 \u2227 \u2130\ud835\udc63 \ud835\udc59+1 for every \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02 \u2212 1}, \ud835\udc62, \ud835\udc63 \u2208 \ud835\udc49\nsuch that {\ud835\udc62, \ud835\udc63} \u2208 \ud835\udc38 and \ud835\udc4e \u2208 \ud835\udc34.\nThe resulting encoding with auxiliary variables will be called SIMPLIFIED and the cor-\nresponding CNF formula will be denoted as \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3).\nProposition 8 (DIRECT/SIMPLIFIED ENCODING SIZE). The number of propositional variables in \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) is \ud835\udcaa(\ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49|). The number of clauses is \ud835\udcaa(\ud835\udf02 \u2219 (\ud835\udf07 \u2219 |\ud835\udc49| 2 + \ud835\udf072 \u2219 |\ud835\udc49| + \ud835\udf072 \u2219 |\ud835\udc38|)). \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3) contains additional \ud835\udcaa(\ud835\udf02 \u2219 |\ud835\udc49|) propositional variables while the total number of clauses is \ud835\udcaa(\ud835\udf02 \u2219 (\ud835\udf07 \u2219 |\ud835\udc49|2 + \ud835\udf072 \u2219 |\ud835\udc49| + \ud835\udf07 \u2219 |\ud835\udc38|)). \nProof. It is easy to see that there are exactly (\ud835\udf02 + 1) \u2219 \ud835\udf07 \u2219 |\ud835\udc49| variables \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 and \ud835\udf02 \u2219 |\ud835\udc49| \u2130\ud835\udc62 \ud835\udc59 variables just by calculating their index scopes which gives us the result regarding the number of propositional variables in \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) and \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3).\nEvery time layer and agent adds (|V| 2 ) binary clauses and one |\ud835\udc49|-ary clause within con-\nstraints (38). Thus, we have (\ud835\udf02 + 1) \u2219 \ud835\udf07 \u2219 (|V| 2 ) binary clauses and (\ud835\udf02 + 1) \u2219 \ud835\udf07 |\ud835\udc49|-ary from writing constraints (38) as clauses in total. The similar calculation can be done for constraints (39); we have (\ud835\udf07 2 ) binary clauses for each time layer and a vertex; that is, (\ud835\udf02 + 1) \u2219 |\ud835\udc49| \u2219 (\ud835\udf07 2 ) binary clauses in total.\n} Goal locations\n(43)\n} Initial locations (42)\n(44)\n(45)\n(46)\n(47)\nPavel Surynek 22\nThere are two (degG(\ud835\udc63) + 2)-ary clauses for every vertex \ud835\udc63 in every time layer except the last one and for every agent from constraints (40), which in total gives \ud835\udf02 \u2219 \ud835\udf07 (degG(\ud835\udc63) + 2)-ary clauses for each vertex \ud835\udc63 \u2208 \ud835\udc49. That is, \ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc49| clauses in total. Note that each implication in constraint (41) develops into 2 \u2219 \ud835\udf07 ternary clauses. There are |\ud835\udc38| such groups of clauses for every agent and a time layer except the last one. Thus, 2 \u2219 \ud835\udf02 \u2219 \ud835\udf072 \u2219 |\ud835\udc38| ternary clauses are needed in total for expressing constraints (41).\nAltogether, the total number of clauses in \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) is (\ud835\udf02 + 1) \u2219 (\ud835\udf07 \u2219 (( |V|\n2 ) + 1) +\n|\ud835\udc49| \u2219 (\ud835\udf07 2 )) + 2 \u2219 \ud835\udf02 \u2219 \ud835\udf07 \u2219 (|\ud835\udc49| + \ud835\udf07 \u2219 |\ud835\udc38|) which is \ud835\udcaa(\ud835\udf02 \u2219 (\ud835\udf07 \u2219 |\ud835\udc49|2 + \ud835\udf072 \u2219 |\ud835\udc49| + \ud835\udf072 \u2219 |\ud835\udc38|)).\nConstraints (47) develop into smaller number of clauses if compared with the original constraints (41) which they replace because of the shorter right hand side in the implication in \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3). Concretely, each implication from (47) develops into exactly 2 ternary clauses which gives 2 \u2219 \ud835\udf02 \u2219 \ud835\udf07 \u2219 |\ud835\udc38| ternary clauses in total. Interconnection of auxiliary variables \u2130\ud835\udc62\n\ud835\udc59 with their meaning requires \ud835\udf07 binary clauses per one implication from constraint (46). There are as many as (\ud835\udf02 + 1) \u2219 |\ud835\udc49| such interconnections which results in (\ud835\udf02 + 1) \u2219 \ud835\udf07 \u2219 |\ud835\udc49| in total. Hence, the total number of clauses in \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3) is (\ud835\udf02 + 1) \u2219 (\ud835\udf07 \u2219 (( |V| 2 ) + 1) + |\ud835\udc49| \u2219 (\ud835\udf07 2 )) + \ud835\udf02 \u2219 \ud835\udf07 \u2219 (|\ud835\udc49| + 2 \u2219 |\ud835\udc38|) which is \ud835\udcaa(\ud835\udf02 \u2219 (\ud835\udf07 \u2219 |\ud835\udc49|2 + \ud835\udf072 \u2219 |\ud835\udc49| + \ud835\udf07 \u2219 |\ud835\udc38|)). \nProposition 9 (PATHS AND \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3)/\ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3) SATISFACTION). A set \u03a0 = {\ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07} of non-overlapping vertex disjoint paths in ExpT(\ud835\udc3a, \ud835\udf02) so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] for \ud835\udc56 = 1,2, \u2026 , \ud835\udf07 exists if and only if \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) is satisfiable. Moreover, paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 can be unambiguously constructed from satisfying valuation of \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) and vice versa. The same hold for \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3). \nSketch of proof. Assume that non-overlapping vertex disjoint paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 exist so that \ud835\udf0b\ud835\udc56 connects [\ud835\udefc0(\ud835\udc4e\ud835\udc56),0] with [\ud835\udefc+(\ud835\udc4e\ud835\udc56), \ud835\udf02] in ExpT(\ud835\udc3a, \ud835\udf02). We will construct a satisfying valuation of \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) from \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07.\nLet \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02, \ud835\udf02]), with \ud835\udc62\ud835\udc59 \u2208 \ud835\udc49 for \ud835\udc59 = 0,1, \u2026 , \ud835\udf02 where\n\ud835\udc620 = \ud835\udefc0(\ud835\udc4e\ud835\udc56) and \ud835\udc62\ud835\udf02 = \ud835\udefc+(\ud835\udc4e\ud835\udc56), then variables \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc620 0 , \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc621 1 , ..., \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc62\ud835\udf02 \ud835\udf02 will be set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38. This setup of \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 variables will be set for every \ud835\udc56 = 1,2, \u2026 , \ud835\udf07.\nIt is now easy to verify that all the constraints from the DIRECT encoding hold. Constraints (38) hold because each directed path \ud835\udf0b\ud835\udc56 intersects the time layer in exactly one vertex. Constraints (39) hold since directed paths are vertex disjoint. As paths go from one time layer to the next, constraints (40) hold as well. Finally, since paths are non-overlapping constraints (41) also hold.\nSatisfying valuation of \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3) requires assigning truth values to \u2130\ud835\udc62 \ud835\udc59 variables in addition. Nevertheless, truth values of \u2130\ud835\udc62 \ud835\udc59 are directly implied from assignment of truth values to \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 through constraints (46). Satisfaction of constraints (47) is ensured by satisfaction of constraints (41) and by transitivity of implication through the auxiliary \u2130\ud835\udc62 \ud835\udc59 . Connecting initial positions of agents with their goals by paths ensures satisfaction of constraints (42)-\nMakespan Optimal Solving of Cooperative Path-Finding\n23\n(45) enforcing that initial time layer and the final time layer correspond to initial and goal arrangements of agent respectively.\nIf on the other hand we have satisfying valuation of \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3), non-overlapping vertex disjoint paths can be constructed from it. Paths \ud835\udf0b1, \ud835\udf0b2, \u2026 , \ud835\udf0b\ud835\udf07 will be constructed by following variables \ud835\udcb3\ud835\udc4e,\ud835\udc63 \ud835\udc59 . Let \ud835\udf0b\ud835\udc56 = ([\ud835\udc620, 0], [\ud835\udc621, 1], [\ud835\udc622, 2], \u2026, [\ud835\udc62\ud835\udf02 , \ud835\udf02]) where \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc620 0 , \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc621 1 , ..., \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc62\ud835\udf02 \ud835\udf02 are \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38. Single path is correctly defined as in each time layer \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} and agent \ud835\udc4e\ud835\udc56 \u2208 \ud835\udc34 there is exactly one \ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc63 \ud835\udc59 with \ud835\udc63 \u2208 \ud835\udc49 set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 which is ensured by constraints (38). Consecutive vertices in the path are connected by arcs which is ensured by constraints (40). If we consider all the paths together, then constraints (39) enforce that paths never intersects because two distinct agents cannot share a vertex. Finally, non-overlapping is ensured by constraints (41) since whenever non-trivial traversal between two consecutive time layers is made, no other agent can be involved in affected vertices. \nAgain, recall that non-overlapping vertex disjoint paths correspond to CPF solutions\n(Proposition 1) which together with just proven result gives the following theorem.\nTheorem 4 (SOLUTION OF \u03a3 AND \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3)/ \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3) SATISFACTION). A solution of a CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+) exists if and only if there exist \ud835\udf02 \u2208 \u2115 for that formula \ud835\udc39\ud835\udc37\ud835\udc3c\ud835\udc45(\ud835\udf02, \u03a3) is satisfiable. The same result holds for the simplified formula \ud835\udc39\ud835\udc46\ud835\udc3c\ud835\udc40(\ud835\udf02, \u03a3). "}, {"heading": "4.3. Summary of the Size Complexity of Propositional Encodings", "text": "Theoretical analysis of the size of encodings has been fine grained so far and it is not straightforward to see immediately how individual encodings compare with each other just by looking on expressions. Therefore, the extreme cases of all the expressions showing the number of variables and clauses have been evaluated and are shown here to provide a more complete picture.\nThe extreme cases concern the number of agents and neighborhood size in the graph \ud835\udc3a, which is either considered to be constant or asymptotically the same as the number of vertices.\nAssumptions that the number of agents \ud835\udf07 and the size of neighborhood in the graph asymptotically compares the number of vertices has been adopted in the space analysis in order to show the number of variables and clauses as much as possible in terms of the size of the input graph \ud835\udc3a = (\ud835\udc49, \ud835\udc38).\nThus, we have following 4 scenarios (2 cases for each of 2 parameters):\n Scenario (i): The number of agents \ud835\udf07 and the size of the neighborhood in \ud835\udc3a is asymptotically the same as the number of vertices.\n(that is, \ud835\udf07 \u2208 \u0398(|\ud835\udc49|) and degG (\ud835\udc63) \u2208 \u0398(|\ud835\udc49|) for \u2200\ud835\udc63 \u2208 \ud835\udc49). The assumption tells that the graph is highly occupied by agents and that the graph contains many edges. The consequence of the second assumption is also that the number of edges in the graph is asymptotically quadratic with respect to the number of vertices; that is, |\ud835\udc38| \u2208 \u0398(|\ud835\udc49|2).\nPavel Surynek 24\nSpace complexities in terms of the number of variables and clauses based upon\nabove assumptions for this scenario are shown in Table 1.\nMakespan Optimal Solving of Cooperative Path-Finding\n25\nThe measure used here for comparison of encodings is that the smaller number of variables or clauses the better. This is usually a realistic measure as the search space often correlates with the number of (decision) variables when solving the propositional formula satisfiability problem by standard search procedures. Similarly, the small number of clauses means that the overall size of the propositional formula is small and thus it is easier for the overall processing. Nevertheless, such small formula preference should be considered just as an intuitive measure since sometimes lot of variables may be derivable from values of other variables (thus they do not increase size of the search space) and sometimes more clauses may improve propagation.\nPavel Surynek 26\nSeveral conclusions can be made upon asymptotic numbers of variables and clauses in individual encodings presented in Table 1 - Table 4. In cases with many agents and dense graphs (corresponding to scenario (i)), INVERSE and ALL-DIFFERENT encodings excel in a small number of clauses.\nMakespan Optimal Solving of Cooperative Path-Finding\n27\nWhen we have many agents and relatively sparse graphs (scenario (ii)), which is the most common case in practice, then INVERSE and MATCHING encodings excel in both, in the number of variables as well as in the number of clauses.\nThe remaining two scenarios (scenario (iii) and (iv)) can be regarded as non-cooperative scenarios since the number of agents is constant and hence the interaction among them is limited. The ALL-DIFFERENT encoding is the most space saving in a case with dense graphs (scenario (iii)) while INVERSE and MATCHING encodings are the most space saving on sparse graphs (scenario (iv)).\nObserve that DIRECT and SIMPLIFIED encodings do not excel in any of the suggested scenarios. This is mostly caused by the fact that no binary encoding of finite domain state variables, which significantly reduces the size of representation of the state variable using propositional variables, is used in these two encodings."}, {"heading": "4.3.1. Knowledge Compilation \u2013 Distance Heuristics", "text": "Encodings based on time expansion graph can be be further enhanced by a so called distance heuristic. Intuitively said, a path indicating the trajectory of a given agent cannot go through vertices that there too far from the initial or the goal vertex under given time constraints. In other words, vertices at a given time layer where the distance to the initial position of the agent is larger than the time elapsed for the time layer (which equals to the position of the time layer in the time expansion graph) or where the distance to the goal vertex is larger than the time that remains for the given time layer (which equals to the position of the time layer in the time expansion graph counted from the end) can never be visited by the agent. The just described time consideration can be easily formalized in the time expansion graphs through existence of directed paths.\nThe knowledge of these impassable vertices can rule out the occurrence of the agent in them from further consideration during the search for a solution and consequently reduce the search space.\nAssume a time expansion graph ExpT(\ud835\udc3a, \ud835\udf02) for CPF \u03a3 = (\ud835\udc3a, \ud835\udc34, \ud835\udefc0, \ud835\udefc+); let distD \u2192(\ud835\udc62, \ud835\udc63) denote the length of the shortest directed path connecting \ud835\udc62 to \ud835\udc63 in a given digraph \ud835\udc37 = (\ud835\udc4b, \ud835\udc39); distD \u2192(\ud835\udc62, \ud835\udc63) = \u221e if there is no path connecting \ud835\udc62 to \ud835\udc63 in \ud835\udc37.\nProposition 10 (DISTANCE HEURISTIC). Any solution \ud835\udc60 = [\ud835\udefc0, \ud835\udefc1, \ud835\udefc2, \u2026 , \ud835\udefc\ud835\udf02] to \u03a3 satisfies that distExpT(\ud835\udc3a,\ud835\udf02) \u2192 ([\ud835\udefc0(\ud835\udc4e\ud835\udc56), 0], [\ud835\udefc\ud835\udc59(\ud835\udc4e\ud835\udc56), \ud835\udc59]) < \u221e and distExpT(\ud835\udc3a,\ud835\udf02) \u2192 ([\ud835\udefc\ud835\udc59(\ud835\udc4e\ud835\udc56), \ud835\udc59], [\ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02]) < \u221e for every \ud835\udc56 \u2208 {1,2, \u2026 , \ud835\udf07} and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02}. \nProof. The proposition is in fact a direct consequence of Proposition 1. If distExpT(\ud835\udc3a,\ud835\udf02) \u2192 ([\ud835\udefc0(\ud835\udc4e\ud835\udc56), 0], [\ud835\udc63, \ud835\udc59]) = \u221e or distExpT(\ud835\udc3a,\ud835\udf02) \u2192 ([\ud835\udc63, \ud835\udc59], [\ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02]) = \u221e for some \ud835\udc63 \u2208 \ud835\udc49 then there is no directed path connecting [\ud835\udefc0(\ud835\udc4e\ud835\udc56), 0] and [\ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02] going through [\ud835\udc63, \ud835\udc59]. A fortiori, there is no path connecting [\ud835\udefc0(\ud835\udc4e\ud835\udc56), 0] and [\ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02] visiting [\ud835\udc63, \ud835\udc59] that does not overlap and does not intersect other paths. Hence, \ud835\udefc\ud835\udc59(\ud835\udc4e\ud835\udc56) \u2260 \ud835\udc63. \nPavel Surynek 28\nThe above proposition can be used to design a heuristic. All the vertices [\ud835\udc63\ud835\udc57 , \ud835\udc59] with \ud835\udc63\ud835\udc57 \u2208 \ud835\udc49 and \ud835\udc59 \u2208 {0,1, \u2026 , \ud835\udf02} in ExpT(\ud835\udc3a, \ud835\udf02) for that distExpT(\ud835\udc3a,\ud835\udf02) \u2192 ([\ud835\udefc0(\ud835\udc4e\ud835\udc56), 0], [\ud835\udc63\ud835\udc57 , \ud835\udc59]) = \u221e or distExpT(\ud835\udc3a,\ud835\udf02) \u2192 ([\ud835\udc63\ud835\udc57 , \ud835\udc59], [\ud835\udefc\ud835\udf02(\ud835\udc4e\ud835\udc56), \ud835\udf02]) = \u221e can be excluded from trajectories corresponding to agent \ud835\udc4e\ud835\udc56 (in original graph it translates to the requirement that agent \ud835\udc4e\ud835\udc56 cannot enter \ud835\udc63\ud835\udc57 at time step \ud835\udc59). In all the encodings, this can be done easily as follows:\nThe inequality between a bit vector and a constant is encoded as a single clause that forbids the bit vector to take that constant. That is, at least one bit must disagree with binary representation of the constant. For example, the inequality \ud835\udc9c\ud835\udc63 \ud835\udc59 \u2260 \ud835\udc50 is encoded as follows:\nIt holds that added inequalities are logical consequences of the encoded propositional formulae (that is, for example \ud835\udc39\ud835\udc3c\ud835\udc41\ud835\udc49(\ud835\udf02, \u03a3) \u21d2 \ud835\udc9c\ud835\udc63\ud835\udc57 \ud835\udc59 \u2260 \ud835\udc56 is a valid formula). Thus in theory, the SAT solver should be able to infer that some vertices are not reachable at certain time steps. However, it may be costly to derive such a fact for the SAT solver while the same knowledge can be obtained easily in advance and compiled directly into the formula almost without any increase of its complexity."}, {"heading": "5. Experimental Evaluation", "text": "Experimental evaluation has been focused on measuring the actual size of suggested encodings and on measuring runtime when encodings are used for makespan optimal CPF solving.\nThe solving procedure presented as Algorithm 1 was used as a core framework for our makespan optimal CPF solving technique (that is, the sequential increasing strategy for querying the SAT solver was used) while suggested individual propositional encodings can be regarded as its exchangeable modules. The SAT solver itself was connected to the solving technique as another external module. All the implemented encodings used build-in distance heuristic discussed in section 4.3.1.\n\ud835\udc9c\ud835\udc63\ud835\udc57 \ud835\udc59 \u2260 \ud835\udc56\n\u2112\ud835\udc4e\ud835\udc56 \ud835\udc59 \u2260 \ud835\udc57\n\ud835\udcb3\ud835\udc4e\ud835\udc56,\ud835\udc63\ud835\udc57 \ud835\udc59\nin the INVERSE and MATCHING encoding\nin the ALL-DIFFERENT encoding\nin the DIRECT/SIMPLIFIED encoding\n(30)\n(31)\ncon\u2260(\ud835\udc9c\ud835\udc63 \ud835\udc59 , \ud835\udc50) = \u22c1 lit(\ud835\udc9c\ud835\udc63 \ud835\udc59 , \ud835\udc50, \ud835\udd5a)\n\u2308log2 \ud835\udf07\u2309\u22121\n\ud835\udd5a=0\n(33)\n(32)\nMakespan Optimal Solving of Cooperative Path-Finding\n29\nThe SAT-based CPF solving procedure was implemented in C++ as well as procedures for generating propositional formulae from given CPF and makespan bound (solving pro-"}, {"heading": "5.1. Benchmark Setup", "text": "We followed benchmark setup suggested by Silver in [20]. Four-connected grids of various sizes were used to model environments in testing instances. The size of grids ranged from 6\u2a2f6 to 12\u2a2f12 with 20% of randomly selected vertices occupied by obstacles (obstacle was represented by a missing vertex in grid \u2013 see Figure 6). Initial and goal arrangements of agents was random \u2013 the random arrangement of agents has been obtained by placing agents one by one while the position has been uniformly randomly picked from the remaining unoccupied vertices. Only solvable instances were taken into runtime tests.\nTo allow full reproducibility of presented results all the source codes and experimental\ndata were posted on-line on: http://ktiml.mff.cuni.cz/~surynek/research/j-encoding-2015."}, {"heading": "5.2. Encoding Size Evaluation", "text": "The size of propositional formulae was tested for discussed 4-connected grids with the increasing number of agents inside. The number of agents ranged from 1 up to the half all the vertices in the graph.\nFor each number of agents, 10 random CPF instances were generated and their characteristics were measured. Formulae corresponding to all the suggested encodings were generated for each number of agents. The number of layers in time expansion graphs was fixed and set relatively to the size of the instance \u2013 it was 12 for 6\u2a2f6 grid; 16 for 8\u2a2f8 grid; and 24 for 12\u2a2f12 grid.\nv2 v3 v4 v1\nG=(V,E)\nv5 v6 v7 obstacle\nv9 v8\nv11 v12 v13 v10\nobstacles\nPavel Surynek 30\nThe average number of propositional variables, average number of clauses, ratio between the number of clauses and variables, and average clause length were calculated for each encoding and number of agents out of 10 randomly generated instances. Partial results are shown in Table 5, Table 6, and Table 7 \u2013 preferred values of individual characteristics are listed in bold.\nThe number of variables and clauses directly correspond to the size of formulae. Preference is given to formulae that are smaller as they are expected to be easier to solve as well as easier for processing.\nThe ratio of the number of clauses and the number of variables is an important measure of the difficulty of propositional formula. Formulae that are under-constrained or overconstrained are easier to solve [7] (easily satisfiable or easily unsatisfiable respectively) and hence such situation is preferred in formulae encoding CPF.\nA very important characteristic is the average length of clause while short clauses are preferred since they support unit propagation [7], which allows deriving values for other variable without search.\nResults indicate that DIRECT and SIMPLIFIED encodings have best size characteristics with respect to the small size preference in cases with small number of agents in the instance. This result can be observed for all the sizes of the grid modeling the environment. As the neighborhood connectivity in 4-connected grids can be regarded as constant; that is, degG (\ud835\udc63) \u2208 \u0398(1) for \u2200\ud835\udc63 \u2208 \ud835\udc49, the cases, where DIRECT and SIMPLIFIED encoding have best size characteristics, roughly correspond to scenario (iv). However, theoretical asymptotic formula size estimations suggest different results - DIRECT and SIMPLIFIED encodings should be same as other encodings in terms of the number of variables and worse than other encodings in terms of the number of variables. Hence, experimental evaluation has shown a surprising result in this aspect.\nMakespan Optimal Solving of Cooperative Path-Finding\n31\nIf the number of agents is higher, the MATCHING encoding dominates in the size characteristics for all the size of the grid. It has the fewest number of propositional variables as well as the fewest number of clauses. If we consider that this case roughly correspond to scenario (ii), these observations correspond to theoretical asymptotic estimations, which indicate that MATCHING encoding together with INVERSE encoding should be smallest (note, that the INVERSE encoding is the second smallest according to experimental results).\nDIRECT and SIMPLIFIED encodings excel in terms of the ratio of the number of clauses to the number of variables. Both encodings tend to be over-constrained, which intuitively suggest easier proving of unsatisfiability. The average length of clauses is shortest for the SIMPLIFIED encoding. As the number of agents increases the average clause length converges towards 2 for all the sizes of the grid (that is, most of clauses are binary in the SIMPLIFIED encoding).\nAbove observations of static characteristics of encodings indicate that MATCHING encoding and especially SIMPLIFIED encoding should perform well in CPF solving (or at least better than other encodings).\nPavel Surynek 32"}, {"heading": "5.3. Runtime Evaluation", "text": "We re-implemented A*-based OD+ID CPF solving procedure [23] in C++ with the objective function for minimizing the makespan and compared it with our SAT based solving method in order to provide broader picture regarding the runtime evaluation.\nAgain, CPFs over 4-connected grids of sizes 6\u2a2f6, 8\u2a2f8, and 12\u2a2f12 with 20% of vertices occupied by randomly placed obstacles were used. Initial and goal arrangements of agents were generated randomly. Runtime evaluation was done for the increasing number of agents in instances while for each number of agents 10 random instances were generated and solved. All the instances used for evaluation were solvable.\nThe timeout for single CPF instance solving was set to 256 seconds (approximately 4 minutes). The number of agents was increased until all the 10 random instances were solvable within the given timeout \u2013 that is, each solving method (encoding) is characterized by the maximum number of agents for which it is able to solve all the 10 random instances within the given timeout.\nThe average and median runtimes were calculated out of these 10 instances for all the tested methods. In the case of SAT based CPF solving methods, the runtime is a sum of the runtime of the core CPF solving procedure (corresponding to Algorithm 1) plus runtimes of all the runs of the SAT solver invoked by the core procedure.\nMakespan Optimal Solving of Cooperative Path-Finding\n33\nRuntime results together with average optimal makespan are shown in Figure 7, Figure 8, and Figure 91 (note that, all the methods generate solutions of the same optimal makespan).\nIt can be observed that OD+ID, although it is the fastest for small number of agents, does not scale up as the runtime quickly blows up for more agents. The SAT-based solving method with all the encodings performs better and scales up for higher number of agents. Particularly, the SIMPLIFIED encoding performs as best in all the sizes of the grid followed by MATCHING, DIRECT, ALL-DIFFERENT, and INVERSE encodings respectively.\nNote that the good performance of the SIMPLIFIED encoding has been predicted by the static analysis of encodings (particularly, it has been assumed to support unit propagation well). Another well competing MATCHING encoding had been predicted to have a good performance as well due to its small size in testing instances.\nAn interesting behavior can be observed with MATCHING encoding that start with almost the same promising performance as the SIMPLIFIED encoding for small number of agents, but it quickly degrades and it is eventually outperformed by the DIRECT encoding\n1 All the runtime measurements were done on a machine with the 4-core CPU Xeon 2.0GHz and 12GB RAM under Linux kernel 3.5.0-48. Although we used multiple cores to run experiments in parallel, the individual instances were solved in a single thread (that is, the core solving procedure and all its call to the SAT solver were run in single thread).\nPavel Surynek 34\non 6\u2a2f6 and 12\u2a2f12 grids for higher number of agents (in case of the 8\u2a2f8 grid, the degradation of the MATCHING encoding can be observed as well but it is less significant \u2013 the DIRECT encoding reached the timeout before it could overtake the MATCHING encoding).\nInstances with occupancy by agents up to 62% are solvable within the given timeout in the 6\u2a2f6 grid by using the SIMPLIFIED encoding. This figure is 46% for the 8\u2a2f8 grid and 28% for the 12\u2a2f12 grid for the SIMPLIFIED encoding. OD+ID method can solve instances with occupancy up to 24%, 13%, and 7% in 6\u2a2f6, 8\u2a2f8, 12\u2a2f12 grids respectively. Thus, approximately 3 times more agents are solvable with SAT based method than with OD+ID in given testing instances.\nThe general conclusion from the above experimental evaluation is also that the binary encoding used for encoding finite domain state variables in the INVERSE, ALL-DIFFERENT, and MATCHING encoding contributes to the small size but it is questionable if it contributes the overall performance as these encodings clearly performed worse than the DIRECT and SIMPLIFIED encodings that did not rely on the binary encoding.\nOn the other hand, the simple design of the DIRECT and SIMPLIFIED encodings is not at the expense of the performance of their solving. The simple design of variables allowed modeling constraints using short clauses that significantly support intensive unit propagation, which is most likely the key factor for the good performance of both encodings \u2013 especially in the case of the SIMPLIFIED encoding.\nMakespan Optimal Solving of Cooperative Path-Finding\n35"}, {"heading": "5.4. Solution Quality Evaluation", "text": "Although all the solutions generated by the suggested SAT based solving techniques are makespan optimal, that is, the best with respect to our objective function, they may differ in other aspects. Particularly important is the total number of moves performed by agents (also called a sum of costs) which can be regarded as the total energy consumed by agents to perform their movements. The total number of moves is also considered as an objective function in several approaches to CPF solving such as [21, 22]. Hence, it is interesting what do solutions generated by makespan optimal SAT solving look like with respect to the total number of moves despite the fact that this aspect has been completely disregarded in the design of propositional encodings of CPF.\nThe way in which a given problem is encoded into propositional formula greatly affects heuristics the SAT solver uses for selecting variables and their values. Values selected to satisfy the formula are then reflected in the CPF solution reconstructed from its satisfying valuation. Although not a rule, SAT solvers in their default settings usually prefer assigning \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 value if it is not more advantageous than to assign value \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38. Observe that only values assigned to visible propositional variables are directly reflected in the resulting CPF solution. Visible propositional variables in the suggested encodings are either part of a directly encoded state (DIRECT and SIMPLIFIED encodings) or part of a binary encoded bit vector (INVERSE, ALL-DIFFERENT, and MATCHING encodings).\nPropositional variables within directly encoded state directly correspond to occupancy of a vertex or an edge by a fixed agent. Assignment of value \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 to a propositional variable of the directly encoded state corresponds to no occupancy by the given fixed agent. Complete no-occupancy appears if and only if all the propositional variables directly encoding the state are set to \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 for all the agents.\nPavel Surynek 36\nThe interpretation of bit vector propositional variables is that occupancy of a corresponding vertex or an edge appears if any of the propositional variables within the bit vector is set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38. No occupancy corresponds to the assignment of integer zero to the bit vector, which means to assign \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 to all the propositional variables, which the bit vector consists of.\nIf we assume that the SAT solver tries to find a solution conservatively; that is, it prefers to assign \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 values, then it seems that using encodings with visible variables that directly encode states results in smaller vertex and edge occupancy, which correspond to CPF solutions consisting of fewer total number of moves.\nThe reasoning behind this hypothesis assumes to have a set of agents \ud835\udc34 and a location (vertex/edge) that is to be occupied by at most one agent from \ud835\udc34. The occupancy of the location is modeled by directly encoded state in one scenario and as a binary encoded bit vector in the second scenario. The first scenario yields |\ud835\udc34| propositional variables with |\ud835\udc34| + 1 allowed assignments - one of these assignments corresponding to no occupancy of the location assigns \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 to all the propositional variables; other allowed assignments have just a single propositional variable set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38. The second scenario yields log2\u2308|\ud835\udc34| + 1\u2309 propositional variables - all the possible combinations of Boolean values are allowed as assignments while all the propositional variables set to \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 correspond to no occupancy of the location. If the preference of assigning \ud835\udc39\ud835\udc34\ud835\udc3f\ud835\udc46\ud835\udc38 actually results in setting strictly fewer variables to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 then no occupancy immediately appears in the first scenario while there is little chance that no occupancy appears in the second scenario (setting strictly fewer variables to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 may lead to another assignment of the bit vector with some propositional variables set to \ud835\udc47\ud835\udc45\ud835\udc48\ud835\udc38 - that is, representing some occupancy). Results of measurement of the total number of moves generated by SAT based CPF solving with suggested encodings are presented in Figure 10, Figure 11, and Figure 12. The same set of testing instances over 4-connected grids as in the runtime measurement\nMakespan Optimal Solving of Cooperative Path-Finding\n37\nhas been used. The total number of moves generated by OD+ID is also included in the measurement.\nThe fewest number of moves in most testing instances is yielded by the SIMPLIFIED encoding. Thus, we also present sorted differences in the total number of moves between those yielded by the SIMPLIFIED encoding and other methods. It can be also observed that OD+ID generates solutions with the smallest number of moves in instances containing few agents. Unfortunately, as OD+ID does not scale up well enough it cannot show qualities of its solutions for larger number of agents.\nThere is almost no significant difference in the total number of moves generated by other methods except a marginal tendency of the DIRECT encoding to yield better solutions than methods using binary encoded bit vectors especially observable over 8\u2a2f8 grid. Altogether, we can conclude that the hypothesis that encodings using directly encoded states is more advantageous than encodings with binary encoded bit-vectors with respect to the total number of moves."}, {"heading": "6. Conclusions", "text": "Several propositional encodings of cooperative path-finding problem (CPF) have been in-\ntroduced - INVERSE, ALL-DIFFERENT, MATCHING, DIRECT, and SIMPLIFIED encodings. The\npresented encodings are based on the notion of the time expanded graph that expands the\ngraph modeling the environment over time so that arrangements of agents at all the time\nsteps up to a certain final time step can be represented. Time expanded graphs provided an\nessential step towards building propositional formulae, in which a query whether there is a\nsolution of a given CPF with the specified number of time steps is encoded. Obtaining\nmakespan optimal solution is then carried out by submitting multiple encoded queries to a\nPavel Surynek 38\nSAT solver. The reduction of CPF to SAT allows accessing all the advanced search, prun-\ning, and learning techniques of the SAT solver that can be in this way employed in CPF\nsolving.\nThe suggested encodings either use binary encoded bit vectors (INVERSE, ALL-DIFFER-\nENT, and MATCHING encoding) or directly encoded states (DIRECT and SIMPLIFIED encod-\nings) to model arrangements of agents at individual time steps. Using binary encoded bit\nvectors results in smaller formulae in terms of the number of variables and clauses. The\nadvantage of encodings with directly encoded states is on the other hand a better support\nfor Boolean constraint propagation (unit propagation) which enabled by the presence of\nmany short clauses.\nPerformed experimental evaluation indicates that CPF solving via SAT is generally the\nbest option in highly constrained situations (environments densely occupied by agents).\nSAT based CPF solving scales up for larger number of agents much better than the alter-\nnative A* based search technique.\nIf we compare solely SAT encodings, than the SIMPLIFIED encoding turned out to per-\nform as best. Instances with the highest occupancy by agents were solved only by the SIM-\nPLIFIED encoding in the given timeout. Moreover, the comparison of the quality of solutions\ngenerated by the SAT based solving in terms of the total number of generated moves also\nindicates that the SIMPLIFIED encoding generates fewest moves."}, {"heading": "Acknowledgments", "text": "This work is supported by Czech-Israeli cooperation project number 8G15027 and by\nCharles University within the PRVOUK (section P46) and UNCE projects. The author\nwould like to thank the research team from Ben Gurion University, Israel led by Ariel\nFelner and Roni Stern and student members of the team Guni Sharon and Eli Boyarski for\nproviding source code for conducting presented experiments."}], "references": [{"title": "Network flows: theory, algorithms, and applications", "author": ["R.K. Ahuja", "T.L. Magnanti", "J.B. Orlin"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1993}, {"title": "The Glucose SAT Solver", "author": ["G. Audemard", "L. Simon"], "venue": "http://labri.fr/perso/lsimon/glucose/,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Relaxing the Relaxed Exist-Step Parallel Planning Semantics", "author": ["T. Balyo"], "venue": "Proceedings of the 26th IEEE International Conference on Tools with Artificial Intelligence (ICTAI", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Suboptimal Variants of the Conflict-Based Search Algorithm for the Multi-Agent Pathfinding Problem", "author": ["M. Barer", "G. Sharon", "R. Stern", "A. Felner"], "venue": "ECAI 2014 - 21st European Conference on Artificial Intelligence (ECAI", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Consistency Checking of All Different Constraints over Bit-Vectors within a SAT Solver", "author": ["A. Biere", "R. Brummayer"], "venue": "Proceedings of Formal Methods in Computer-Aided Design (FMCAD", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "Multi-agent RRT: sampling-based cooperative pathfinding", "author": ["M. \u010c\u00e1p", "P. Nov\u00e1k", "J. Vok\u0159\u00ednek", "M. P\u011bchou\u010dek"], "venue": "International conference on Autonomous Agents and Multi-Agent Systems (AAMAS", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "A General Formal Framework for Pathfinding Problems with Multiple Agents", "author": ["E. Erdem", "D.G. Kisa", "U. \u00d6ztok", "P. Sch\u00fcller"], "venue": "Proceedings of the 27th AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "A Novel Transition Based Encoding Scheme for Planning as Satisfiability", "author": ["R. Huang", "Y. Chen", "W. Zhang"], "venue": "Proceedings of the 24th AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Unifying SAT-based and Graph-based Planning", "author": ["H. Kautz", "B. Selman"], "venue": "Proceedings of the 16th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1999}, {"title": "Collision Avoidance in Multiple-Ship Situations by Distributed Local Search", "author": ["D. Kim", "K. Hirayama", "Park", "G.-K"], "venue": "Journal of Advanced Computational Intelligence and Intelligent Informatics (JACIII), Volume", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2014}, {"title": "Coordinating Pebble Motion on Graphs, the Diameter of Permutation Groups, and Applications", "author": ["D. Kornhauser", "G.L. Miller", "P.G. Spirakis"], "venue": "Proceedings of the 25th Annual Symposium on Foundations of Computer Science (FOCS", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1984}, {"title": "Cooperative manipulation and transportation with aerial robots", "author": ["N. Michael", "J. Fink", "V. Kumar"], "venue": "Autonomous Robots,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "Finding a Shortest Solution for the N \u00d7 N Extension of the 15PUZZLE Is Intractable", "author": ["D. Ratner", "M.K. Warmuth"], "venue": "Proceedings of the 5th National Conference on Artificial Intelligence (AAAI", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1986}, {"title": "Planning as satisfiability: parallel plans and algorithms for plan search", "author": ["J. Rintanen", "K. Heljanko", "I. Niemel\u0308a"], "venue": "Artificial Intelligence, Volume", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "Graph Decomlocation for Efficient Multi-Robot Path Planning", "author": ["M.R.K. Ryan"], "venue": "Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}, {"title": "Exploiting Subgraph Structure in Multi-Robot Path Planning", "author": ["M.R.K. Ryan"], "venue": "Journal of Artificial Intelligence Research (JAIR), Volume", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2008}, {"title": "Cooperative Pathfinding", "author": ["D. Silver"], "venue": "Proceedings of the 1st Artificial Intelligence and Interactive Digital Entertainment Conference (AIIDE", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2005}, {"title": "The increasing cost tree search for optimal multi-agent pathfinding", "author": ["G. Sharon", "R. Stern", "M. Goldenberg", "A. Felner"], "venue": "Artificial Intelligence,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2013}, {"title": "Conflict-based search for optimal multiagent pathfinding", "author": ["G. Sharon", "R. Stern", "A. Felner", "N.R. Sturtevant"], "venue": "Artificial Intelligence,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2015}, {"title": "Complete Algorithms for Cooperative Pathfinding Problems", "author": ["T.S. Standley", "R.E. Korf"], "venue": "Proceedings of Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2011}, {"title": "Benchmarks for Grid-Based Pathfinding", "author": ["N.R. Sturtevant"], "venue": "IEEE Transactions on Computational Intelligence and AI in Games, Volume", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Towards Optimal Cooperative Path Planning in Hard Setups through Satisfiability Solving", "author": ["P. Surynek"], "venue": "Proceedings of 12th Pacific Rim International Conference on Artificial Intelligence (PRICAI", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2012}, {"title": "On Propositional Encodings of Cooperative Path-Finding", "author": ["P. Surynek"], "venue": "Proceedings of the 24th International Conference on Tools with Artificial Intelligence (ICTAI", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2012}, {"title": "Mutex reasoning in cooperative path finding modeled as propositional satisfiability", "author": ["P. Surynek"], "venue": "Proceedings of the 2013 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2013}, {"title": "Solving Abstract Cooperative Path-Finding in Densely Populated Environments", "author": ["P. Surynek"], "venue": "Computational Intelligence (COIN),", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2014}, {"title": "Compact Representations of Cooperative Path-Finding as SAT Based on Matchings in Bipartite Graphs", "author": ["P. Surynek"], "venue": "Proceedings of the 26th International Conference on Tools with Artificial Intelligence (ICTAI", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2014}, {"title": "A Simple Approach to Solving Cooperative Path-Finding as Propositional Satisfiability Works Well", "author": ["P. Surynek"], "venue": "Proceedings of the 13th Pacific Rim International Conference on Artificial Intelligence (PRICAI", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2014}, {"title": "Simple Direct Propositional Encoding of Cooperative Path Finding Simplified Yet More", "author": ["P. Surynek"], "venue": "Proceedings of the 13th Mexican International Conference on Artificial Intelligence (MICAI", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2014}, {"title": "On the Complexity of Optimal Parallel Cooperative Path-Finding", "author": ["P. Surynek"], "venue": "Fundamenta Informaticae, Volume 137,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2015}, {"title": "On the complexity of derivation in propositional calculus. Structures in Constructive Mathematics and Mathematical Logic, Part II, Seminars in Mathematics (translated from Russian)", "author": ["G.S. Tseitin"], "venue": "Steklov Mathematical Institute,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1968}, {"title": "Subdimensional expansion for multirobot path planning", "author": ["G. Wagner", "H. Choset"], "venue": "Artificial Intelligence,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2015}, {"title": "Planning as satisfiability with relaxed exist-step plans", "author": ["M. Wehrle", "J. Rintanen"], "venue": "Proceedings of the 20th Australian Joint Conference on Artificial Intelligence,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2007}, {"title": "Introduction to Graph Theory", "author": ["D.B. West"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2000}, {"title": "Push and rotate: cooperative multi-agent path planning", "author": ["B. de Wilde", "A. ter Mors", "C. Witteveen"], "venue": "Proceedings of the International conference on Autonomous Agents and Multi-Agent Systems (AAMAS", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2013}, {"title": "Push and Rotate: a Complete Multi-agent Pathfinding Algorithm", "author": ["B. de Wilde", "A.W. ter Mors", "C. Witteveen"], "venue": "Journal of Artificial Intelligence Research (JAIR), Volume", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2014}, {"title": "Structure and Intractability of Optimal Multi-Robot Path Planning on Graphs", "author": ["J. Yu", "S.M. LaValle"], "venue": "Proceedings of the 27th AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2013}], "referenceMentions": [{"referenceID": 10, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 31, "endOffset": 43}, {"referenceID": 19, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 31, "endOffset": 43}, {"referenceID": 21, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 31, "endOffset": 43}, {"referenceID": 17, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 89, "endOffset": 105}, {"referenceID": 18, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 89, "endOffset": 105}, {"referenceID": 33, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 89, "endOffset": 105}, {"referenceID": 34, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 89, "endOffset": 105}, {"referenceID": 14, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 145, "endOffset": 153}, {"referenceID": 15, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 145, "endOffset": 153}, {"referenceID": 10, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 191, "endOffset": 199}, {"referenceID": 12, "context": "Cooperative path-finding - CPF [14, 23, 25] (also known as multi-agent path finding MAPF [21, 22, 37, 38] or as multi-robot path planning - MRPP [18, 19] or as pebble motion on a graph - PMG [14, 16]) is an abstraction for many real-file tasks where the goal is to relocate some objects that spatially interacts with each other.", "startOffset": 191, "endOffset": 199}, {"referenceID": 14, "context": "A graph theoretical abstraction, where the environment in which agents are moving is modeled as an undirected graph, is often adopted [18, 20].", "startOffset": 134, "endOffset": 142}, {"referenceID": 16, "context": "A graph theoretical abstraction, where the environment in which agents are moving is modeled as an undirected graph, is often adopted [18, 20].", "startOffset": 134, "endOffset": 142}, {"referenceID": 24, "context": "Note that various versions of the problem may have different conditions on movements - sometimes it is for instance allowed to move agents in a train like manner [28] or even rotate agents around cycle without any unoccupied vertex in the cycle [39].", "startOffset": 162, "endOffset": 166}, {"referenceID": 35, "context": "Note that various versions of the problem may have different conditions on movements - sometimes it is for instance allowed to move agents in a train like manner [28] or even rotate agents around cycle without any unoccupied vertex in the cycle [39].", "startOffset": 245, "endOffset": 249}, {"referenceID": 20, "context": "There are many practical motivations for CPF ranging from unit navigation in computer games [24] to item relocation in automated storage (see KIVA robots [13]).", "startOffset": 92, "endOffset": 96}, {"referenceID": 9, "context": "Interesting motivations can be also found in traffic where problems like vessel avoidance at sea are of great practical importance [12].", "startOffset": 131, "endOffset": 135}, {"referenceID": 11, "context": "An analogical challenge appears in the air where availability of drones implies need for developing cooperative air traffic control mechanisms [15].", "startOffset": 143, "endOffset": 147}, {"referenceID": 19, "context": "Particularly we are dealing with so-called makespan optimal solving of CPF [23, 29], which means to find a solution of a makespan as short as possible.", "startOffset": 75, "endOffset": 83}, {"referenceID": 25, "context": "Particularly we are dealing with so-called makespan optimal solving of CPF [23, 29], which means to find a solution of a makespan as short as possible.", "startOffset": 75, "endOffset": 83}, {"referenceID": 12, "context": "It is known that finding makespan optimal solutions to CPF is a difficult problem, namely it is NP-hard [16, 32, 39].", "startOffset": 104, "endOffset": 116}, {"referenceID": 28, "context": "It is known that finding makespan optimal solutions to CPF is a difficult problem, namely it is NP-hard [16, 32, 39].", "startOffset": 104, "endOffset": 116}, {"referenceID": 35, "context": "It is known that finding makespan optimal solutions to CPF is a difficult problem, namely it is NP-hard [16, 32, 39].", "startOffset": 104, "endOffset": 116}, {"referenceID": 1, "context": "Moreover, the reduction allows exploiting the power of modern SAT solvers [2, 3] in CPF solving.", "startOffset": 74, "endOffset": 80}, {"referenceID": 8, "context": "They are based on a so-called time expansion of the graph that models the environment [11, 26] so that the formula can represent all the possible arrangements of agents at all the time steps up to the given final time step.", "startOffset": 86, "endOffset": 94}, {"referenceID": 22, "context": "They are based on a so-called time expansion of the graph that models the environment [11, 26] so that the formula can represent all the possible arrangements of agents at all the time steps up to the given final time step.", "startOffset": 86, "endOffset": 94}, {"referenceID": 16, "context": "The seminal work in this category is represented by Silver\u2019s WHCA* algorithm [20] which is a variant of A* search where cooperation among agents is incorporated.", "startOffset": 77, "endOffset": 81}, {"referenceID": 19, "context": "Recent contributions include OD+ID [23], which is a combination of A* and powerful agent independence detection heuristics, and ICTS [21] which employs the concept of increasing cost tree (instead of makespan, the total cost of solution is optimized).", "startOffset": 35, "endOffset": 39}, {"referenceID": 17, "context": "Recent contributions include OD+ID [23], which is a combination of A* and powerful agent independence detection heuristics, and ICTS [21] which employs the concept of increasing cost tree (instead of makespan, the total cost of solution is optimized).", "startOffset": 133, "endOffset": 137}, {"referenceID": 3, "context": "Other approaches resolve conflicts among robot trajectories when avoidance is necessary [5, 8, 34].", "startOffset": 88, "endOffset": 98}, {"referenceID": 5, "context": "Other approaches resolve conflicts among robot trajectories when avoidance is necessary [5, 8, 34].", "startOffset": 88, "endOffset": 98}, {"referenceID": 30, "context": "Other approaches resolve conflicts among robot trajectories when avoidance is necessary [5, 8, 34].", "startOffset": 88, "endOffset": 98}, {"referenceID": 33, "context": "Fast polynomial time algorithms for generating makespan suboptimal solutions include PUSH-AND-ROTATE [37, 38] and other algorithms [28].", "startOffset": 101, "endOffset": 109}, {"referenceID": 34, "context": "Fast polynomial time algorithms for generating makespan suboptimal solutions include PUSH-AND-ROTATE [37, 38] and other algorithms [28].", "startOffset": 101, "endOffset": 109}, {"referenceID": 24, "context": "Fast polynomial time algorithms for generating makespan suboptimal solutions include PUSH-AND-ROTATE [37, 38] and other algorithms [28].", "startOffset": 131, "endOffset": 135}, {"referenceID": 6, "context": "Translation of CPF to a different formalism, namely to answer set programming (ASP), has been suggested in [9].", "startOffset": 107, "endOffset": 110}, {"referenceID": 35, "context": "Integer programming (IP) as the target formalism has been also used [39].", "startOffset": 68, "endOffset": 72}, {"referenceID": 7, "context": "The choice of SAT as the target formalism is very common in domain independent planning where the idea of time expansion [10, 11] and its reductions [4, 35] are studied.", "startOffset": 121, "endOffset": 129}, {"referenceID": 8, "context": "The choice of SAT as the target formalism is very common in domain independent planning where the idea of time expansion [10, 11] and its reductions [4, 35] are studied.", "startOffset": 121, "endOffset": 129}, {"referenceID": 2, "context": "The choice of SAT as the target formalism is very common in domain independent planning where the idea of time expansion [10, 11] and its reductions [4, 35] are studied.", "startOffset": 149, "endOffset": 156}, {"referenceID": 31, "context": "The choice of SAT as the target formalism is very common in domain independent planning where the idea of time expansion [10, 11] and its reductions [4, 35] are studied.", "startOffset": 149, "endOffset": 156}, {"referenceID": 12, "context": "It is known that the decision variant of CPF is NP-complete, hence finding makespan optimal solution to CPF is NP-hard [16].", "startOffset": 119, "endOffset": 123}, {"referenceID": 0, "context": "The approach we are suggesting here employs propositional satisfiability (SAT) [1] solving as the key technology.", "startOffset": 79, "endOffset": 82}, {"referenceID": 8, "context": "The sequential increasing strategy is also used in domain independent planners such as SATPLAN [11], SASE [10] and others.", "startOffset": 95, "endOffset": 99}, {"referenceID": 7, "context": "The sequential increasing strategy is also used in domain independent planners such as SATPLAN [11], SASE [10] and others.", "startOffset": 106, "endOffset": 110}, {"referenceID": 13, "context": "The focus here is on SAT encoding while querying strategies are out of scope of the paper; though let us mention that in depth study of querying strategies is given in [17].", "startOffset": 168, "endOffset": 172}, {"referenceID": 10, "context": "Nevertheless, the solving process can be easily made complete by checking instance solvability prior to SAT-based optimization by some fast polynomial time algorithm such as those described in [14, 28, 38].", "startOffset": 193, "endOffset": 205}, {"referenceID": 24, "context": "Nevertheless, the solving process can be easily made complete by checking instance solvability prior to SAT-based optimization by some fast polynomial time algorithm such as those described in [14, 28, 38].", "startOffset": 193, "endOffset": 205}, {"referenceID": 34, "context": "Nevertheless, the solving process can be easily made complete by checking instance solvability prior to SAT-based optimization by some fast polynomial time algorithm such as those described in [14, 28, 38].", "startOffset": 193, "endOffset": 205}, {"referenceID": 1, "context": "The important advantage of solving CPF as SAT is that there exist many powerful solvers for SAT [2, 3] implementing numerous advanced techniques such as intelligent search space pruning and learning.", "startOffset": 96, "endOffset": 102}, {"referenceID": 29, "context": "The above elementary constructions are put together to represent constraints (4) \u2013 (6) using Tseitin\u2019s encoding [33] which introduces auxiliary propositional variables to the encoding.", "startOffset": 112, "endOffset": 116}, {"referenceID": 0, "context": "domain state variables are encoded using the scheme introduced in [1].", "startOffset": 66, "endOffset": 69}, {"referenceID": 0, "context": "We observed that vertex disjoint non-overlapping paths in time expansion graph resemble a commodity flow [1] in a network of time expansion graph where vertices and edges are assigned unit capacities.", "startOffset": 105, "endOffset": 108}, {"referenceID": 26, "context": "While the design of variables is extremely simple in the DIRECT encoding, the set of constraints is more complex as summarized in the following definition [30].", "startOffset": 155, "endOffset": 159}, {"referenceID": 32, "context": "The second assumption tells the graph is sparse and can be intuitively compared to planar graphs [36] that are very common in practice.", "startOffset": 97, "endOffset": 101}, {"referenceID": 1, "context": "0 SAT solver [2] in our tests, which is justified by the fact that this SAT solver ranked among the winners in recent SAT Competitions [3] in the category of hard combinatorial problems to which we consider CPF belongs as well.", "startOffset": 13, "endOffset": 16}, {"referenceID": 16, "context": "We followed benchmark setup suggested by Silver in [20].", "startOffset": 51, "endOffset": 55}, {"referenceID": 19, "context": "We re-implemented A*-based OD+ID CPF solving procedure [23] in C++ with the objective function for minimizing the makespan and compared it with our SAT based solving method in order to provide broader picture regarding the runtime evaluation.", "startOffset": 55, "endOffset": 59}, {"referenceID": 17, "context": "The total number of moves is also considered as an objective function in several approaches to CPF solving such as [21, 22].", "startOffset": 115, "endOffset": 123}, {"referenceID": 18, "context": "The total number of moves is also considered as an objective function in several approaches to CPF solving such as [21, 22].", "startOffset": 115, "endOffset": 123}], "year": 2016, "abstractText": "The problem of makespan optimal solving of cooperative path finding (CPF) is addressed in this paper. The task in CPF is to relocate a group of agents in a non-colliding way so that each agent eventually reaches its goal location from the given initial location. The abstraction adopted in this work assumes that agents are discrete items moving in an undirected graph by traversing edges. Makespan optimal solving of CPF means to generate solutions that are as short as possible in terms of the total number of time steps required for the execution of the solution. We show that reducing CPF to propositional satisfiability (SAT) represents a viable option for obtaining makespan optimal solutions. Several encodings of CPF into propositional formulae are suggested and experimentally evaluated. The evaluation indicates that SAT based CPF solving outperforms other makespan optimal methods significantly in highly constrained situations (environments that are densely occupied by agents).", "creator": "Microsoft\u00ae Word 2016"}}}