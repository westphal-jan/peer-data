{"id": "1611.02189", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Nov-2016", "title": "CoCoA: A General Framework for Communication-Efficient Distributed Optimization", "abstract": "The scale of modern datasets necessitates the development of efficient distributed optimization methods for machine learning. We present a general-purpose framework for the distributed environment, CoCoA, that has an efficient communication scheme and is applicable to a wide variety of problems in machine learning and signal processing. We extend the framework to cover general non-strongly convex regularizers, including L1-regularized problems like lasso, sparse logistic regression, and elastic net regularization, and show how earlier work can be derived as a special case. We provide convergence guarantees for the class of convex regularized loss minimization objectives, leveraging a novel approach in handling non-strongly convex regularizers and non-smooth loss functions. The resulting framework has markedly improved performance over state-of-the-art methods, as we illustrate with an extensive set of experiments on real distributed datasets.", "histories": [["v1", "Mon, 7 Nov 2016 17:49:49 GMT  (406kb,D)", "http://arxiv.org/abs/1611.02189v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["virginia smith", "simone forte", "chenxin ma", "martin takac", "michael i jordan", "martin jaggi"], "accepted": false, "id": "1611.02189"}, "pdf": {"name": "1611.02189.pdf", "metadata": {"source": "CRF", "title": "CoCoA: A General Framework for Communication-Efficient Distributed Optimization", "authors": ["Virginia Smith", "Simone Forte", "Chenxin Ma"], "emails": ["vsmith@berkeley.edu", "simone.forte@gess.ethz.ch", "chm514@lehigh.edu", "Takac.MT@gmail.com", "jordan@cs.berkeley.edu", "martin.jaggi@epfl.ch"], "sections": [{"heading": null, "text": "The scale of modern datasets necessitates the development of efficient distributed optimization methods for machine learning. We present a general-purpose framework for the distributed environment, CoCoA, that has an efficient communication scheme and is applicable to a wide variety of problems in machine learning and signal processing. We extend the framework to cover general non-strongly convex regularizers, including L1-regularized problems like lasso, sparse logistic regression, and elastic net regularization, and show how earlier work can be derived as a special case. We provide convergence guarantees for the class of convex regularized loss minimization objectives, leveraging a novel approach in handling non-strongly convex regularizers and non-smooth loss functions. The resulting framework has markedly improved performance over state-of-the-art methods, as we illustrate with an extensive set of experiments on real distributed datasets.\nKeywords: Convex optimization, distributed systems, large-scale machine learning, parallel and distributed algorithms\nar X\niv :1\n61 1."}, {"heading": "1. Introduction", "text": "Distributed computing architectures have come to the fore in modern machine learning, in response to the challenges arising from a wide range of large-scale learning applications. Distributed architectures offer the promise of scalability by increasing both computational and storage capacities. A critical challenge in realizing this promise of scalability is to develop efficient methods for communicating and coordinating information between distributed machines, taking into account the specific needs of machine-learning algorithms. On most distributed systems, the communication of data between machines is vastly more expensive than reading data from main memory and performing local computation. Moreover, the optimal trade-off between communication and computation can vary widely depending on the dataset being processed, the system being used, and the objective being optimized. It is therefore essential for distributed methods to accommodate flexible communicationcomputation profiles while still providing convergence guarantees.\nAlthough numerous distributed optimization methods have been proposed, the minibatch optimization approach has emerged as one of the most popular paradigms for tackling this communication-computation tradeoff (see, e.g., Tak\u00e1\u010d et al., 2013; Shalev-Shwartz and Zhang, 2013b; Qu et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016). Mini-batch methods are often developed by generalizing classical stochastic methods to process multiple data points at a time, which helps to alleviate the communication bottleneck by enabling more distributed computation per round of communication. However, while the need to reduce communication would suggest large mini-batch sizes, the theoretical convergence rates of these methods degrade with increased mini-batch size, reverting to the rates of classical (batch) gradient methods. Empirical results corroborate these theoretical rates, and in practice, mini-batch methods have limited flexibility to adapt to the communication-computation tradeoffs that would maximally leverage parallel execution. Moreover, because mini-batch methods are typically derived from a specific single-machine solver, these methods and their associated analyses are often tailored to specific problem instances and can suffer both theoretically and practically when applied outside of their restricted problem setting.\nIn this work, we propose a framework, CoCoA1, that addresses these two fundamental limitations. First, we allow arbitrary local solvers to be used on each machine in parallel. This allows our framework to directly incorporate state-of-the-art, application-specific singlemachine solvers in the distributed setting. Second, we share information between machines in our framework with a highly flexible communication scheme. This allows the amount of communication to be easily tailored to the problem and system at hand, in particular allowing for the case of significantly reduced communication in the distributed environment.\nA key step in providing these features in our framework is to first define meaningful subproblems for each machine to solve in parallel, and to then combine updates from the subproblems in an efficient manner. Our method and convergence results rely on noting that, depending on the distribution of the data (e.g., by feature or by training point), and whether we solve the problem in the primal or the dual, certain machine learning objectives can be\n1. CoCoA-v1 (Jaggi et al., 2014) and CoCoA+ (Ma et al., 2015a,b) are predecessors of this work. We continue to use the name CoCoA for the more general framework proposed here, and show how earlier work can be derived as a special case (Section 4). Portions of this newer work appear in SF\u2019s Master\u2019s Thesis (Forte, 2015) and Smith et al. (2015).\nmore easily decomposed into subproblems in the distributed environment. In particular, we categorize common machine learning objectives into several cases, and use duality to help decompose these objectives. Using primal-dual information in this manner not only allows for highly efficient methods (achieving, e.g., up to 50x speedups compared to state-of-theart distributed methods), but also allows for strong primal-dual convergence guarantees and practical benefits such as computation of the duality gap for use as an accuracy certificate and stopping criterion."}, {"heading": "1.1 Contributions", "text": "General framework. We develop a communication-efficient primal-dual framework that is applicable to a broad class of convex optimization problems. Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015a); and Ma et al. (2015b), our generalized, cohesive framework: (1) specifically incorporates difficult cases of L1 regularization and other non-strongly convex regularizers; (2) allows for the flexibility of distributing the data by either feature or training point; and (3) can be run on either a primal or dual formulation, which we show to have significant theoretical and practical implications.\nFlexible communication and local solvers. Two key advantages of the proposed framework are its communication efficiency and ability to employ off-the-shelf single-machine solvers internally. On real-world systems, the cost of communication versus computation can vary widely, and it is thus advantageous to permit a flexible amount of communication depending on the setting at hand. Our framework provides exactly such control. Moreover, we allow arbitrary solvers to be used on each machine, which permits the reuse of existing code and the benefits from multi-core or other optimizations therein.\nPrimal-dual rates. We derive convergence rates for our framework, leveraging a novel approach in the analysis of primal-dual rates for non-strongly convex regularizers. The proposed technique is a significant improvement over simple smoothing techniques used in, e.g., Nesterov (2005); Shalev-Shwartz and Zhang (2014); and Zhang and Lin (2015) that enforce strong convexity by adding a small L2 term to the objective. Our results include primal-dual rates and certificates for the general class of linear regularized loss minimization, and we show how earlier work can be derived as a special case of our more general approach.\nExperimental comparison. The proposed framework yields order-of-magnitude speedups (as much as 50\u00d7 faster) compared to state-of-the-art methods for large-scale machine learning. We demonstrate these performance gains with an extensive experimental comparison on real-world distributed datasets. We additionally explore properties of the framework itself, including the effect of running the framework in the primal or the dual. All algorithms for comparison are implemented in Apache Spark and run on Amazon EC2 clusters. Our code is open-source and publicly available at: github.com/gingsmith/proxcocoa."}, {"heading": "2. Background and Setup", "text": "In this paper we develop a general framework for minimizing problems of the following form:\n`(u) + r(u) , (I)\nfor convex functions ` and r. Frequently the first term ` is an empirical loss over the data, taking the form \u2211 i `i(u), and the second term r is a regularizer, e.g., r(u) = \u03bb\u2016u\u2016p. This formulation includes many popular methods in machine learning and signal processing, such as support vector machines, linear and logistic regression, lasso and sparse logistic regression, and many others."}, {"heading": "2.1 Definitions", "text": "The following standard definitions will be used throughout the paper.\nDefinition 1 (L-Lipschitz Continuity). A function h : Rm \u2192 R is L-Lipschitz continuous if \u2200u,v \u2208 Rm, we have\n|h(u)\u2212 h(v)| \u2264 L\u2016u\u2212 v\u2016 . (1)\nDefinition 2 (L-Bounded Support). A function h : Rm \u2192 R \u222a {+\u221e} has L-bounded support if its effective domain is bounded by L, i.e.,\nh(u) < +\u221e \u21d2 \u2016u\u2016 \u2264 L . (2)\nDefinition 3 ((1/\u00b5)-Smoothness). A function h : Rm \u2192 R is (1/\u00b5)-smooth if it is differentiable and its derivative is (1/\u00b5)-Lipschitz continuous, or equivalently\nh(u) \u2264 h(v) + \u3008\u2207h(v),u\u2212 v\u3009+ 1 2\u00b5 \u2016u\u2212 v\u20162 \u2200u,w \u2208 Rm . (3)\nDefinition 4 (\u00b5-Strong Convexity). A function h : Rm \u2192 R is \u00b5-strongly convex for \u00b5 \u2265 0 if\nh(u) \u2265 h(v) + \u3008s,u\u2212 v\u3009+ \u00b5 2 \u2016u\u2212 v\u20162 \u2200u,v \u2208 Rm , (4)\nfor any s \u2208 \u2202h(v), where \u2202h(v) denotes the subdifferential of h at v."}, {"heading": "2.2 Primal-Dual Setting", "text": "Numerous methods have been proposed to solve (I), and these methods generally fall into two categories: primal methods, which run directly on the primal objective, and dual methods, which instead run on the dual formulation of the primal objective. In developing our framework, we present an abstraction that allows for either a primal or a dual variant of our framework to be run. In particular, to solve the input problem (I), we consider mapping the problem to one of the following two general problems:\nmin \u03b1\u2208Rn\n[ OA(\u03b1) := f(A\u03b1) + g(\u03b1)\n] (A)\nmin w\u2208Rd\n[ OB(w) := f\u2217(w) + g\u2217(\u2212A>w)\n] (B)\nHere \u03b1 \u2208 Rn and w \u2208 Rd are parameter vectors, A := [x1; . . . ;xn] \u2208 Rd\u00d7n is a data matrix with column vectors xi \u2208 Rd, i \u2208 {1, . . . , n}, and the functions f\u2217 and g\u2217i are the convex conjugates of f and gi, respectively.\nThe dual relationship in problems (A) and (B) is known as Fenchel-Rockafellar duality (Borwein and Zhu, 2005, Theorem 4.4.2). We provide a self-contained derivation of the duality in Appendix B. Note that while dual problems are typically presented as a pair of (min, max) problems, we have equivalently reformulated (A) and (B) to both be minimization problems in accordance with their roles in our framework.\nGiven \u03b1 \u2208 Rn in the context of (A), a corresponding vector w \u2208 Rd for problem (B) is obtained by:\nw = w(\u03b1) := \u2207f(A\u03b1) . (5)\nThis mapping arises from first-order optimality conditions on the f -part of the objective. The duality gap, given by:\nG(\u03b1) := OA(\u03b1)\u2212 [\u2212OB(w(\u03b1))] (6)\nis always non-negative, and under strong duality, the gap will reach zero only for an optimal pair (\u03b1?,w?). The duality gap at any point provides a practically computable upper bound on the unknown primal as well as dual optimization error (suboptimality), since\nOA(\u03b1) \u2265 OA(\u03b1?) \u2265 \u2212OB(w?) \u2265 \u2212OB(w(\u03b1)) .\nIn developing the proposed framework, noting the duality between (A) and (B) has many benefits, including the ability to compute the duality gap, which acts as a certificate of the approximation quality. It is also useful as an analysis tool, helping us to present a cohesive framework and relate this work to the prior work of Yang (2013); Jaggi et al. (2014); and Ma et al. (2015b,a). As a word of caution, note that we avoid prescribing the name \u201cprimal\u201d or \u201cdual\u201d directly to either of the problems (A) or (B), as we demonstrate below that their role as primal or dual can change depending on the application problem of interest."}, {"heading": "2.3 Assumptions and Problem Cases", "text": "Our main assumptions on problem (A) are that f is (1/\u03c4)-smooth, and the function g is separable, i.e., g(\u03b1) = \u2211 i gi(\u03b1i), with each gi having L-bounded support. Given the duality between the problems (A) and (B), this can be equivalently stated as assuming that in problem (B), f\u2217 is \u03c4 -strongly convex, and the function g\u2217(\u2212A>w) = \u2211 i g \u2217 i (\u2212x>i w) is separable with each g\u2217i being L-Lipschitz. For clarity, in Table 1 we relate our assumptions on objectives (A) and (B) to the general input problem (I). Suppose, as in equation (I), we would like to find a minimizer of the general objective `(u)+r(u). Depending on the smoothness of the function ` and the strong convexity of the function r, we will be able to map the input function (I) to one (or both) of the objectives (A) and (B) based on our assumptions.\nIn particular, we outline three separate cases: Case I, in which the function ` is smooth and the function r is strongly convex; case II, in which ` is smooth, and r is non-strongly convex and separable; and case III, in which ` is non-smooth and separable, and r is strongly convex. The union of these cases will capture most commonly-used applications of linear regularized loss minimization problems. In Section 3, we will see that different variants of our framework may be realized depending on which of these three cases we consider when solving the input problem (I)."}, {"heading": "2.4 Running Examples", "text": "To illustrate the three cases in Table 1, we consider several examples below. These applications will serve as running examples throughout the paper, and we will revisit them in our experiments (Section 6). Further applications and details are provided in Section 5.\n1. Elastic Net Regression (Case I: map to either (A) or (B)). We can map elastic-net regularized least squares regression,\nmin u\u2208Rp\n1 2\u2016Au\u2212 b\u2016 2 2 + \u03b7\u03bb\u2016u\u20161 + (1\u2212 \u03b7)\n\u03bb 2 \u2016u\u201622 , (7)\nto either objective (A) or (B). To map to objective (A), we let: f(A\u03b1) = 12\u2016A\u03b1\u2212b\u2016 2 2 and g(\u03b1) = \u2211 i gi(\u03b1i) = \u2211 i \u03b7\u03bb|\u03b1i| + (1 \u2212 \u03b7) \u03bb 2\u03b1 2 i , setting n to be the number of\nfeatures and d the number of training points. To map to (B), we let: g(\u2212A>w) =\u2211 i g \u2217 i (\u2212x>i w) = \u2211 i 1 2(x > i w\u2212bi)2 and f\u2217(w) = \u03b7\u03bb\u2016w\u20161 + (1\u2212 \u03b7)\u03bb2\u2016w\u2016 2 2, setting d to be the number of features and n the number of training points. We discuss in Section 3 how the choice of mapping elastic net regression to either (A) or to (B) will result in one of two variants of our framework, and can have implications on the distribution scheme and overall performance of the method.\n2. Lasso (Case II: map to (A)). We can represent L1-regularized least squares regression by mapping the model:\nmin u\u2208Rp\n1 2\u2016Au\u2212 b\u2016 2 2 + \u03bb\u2016u\u20161 (8)\nto objective (A), letting f(A\u03b1) = 12\u2016A\u03b1 \u2212 b\u2016 2 2 and g(\u03b1) = \u2211 i gi(\u03b1i) = \u2211 i \u03bb|\u03b1i|. In this mapping, n represents the number of features, and d the number of training points. Note that we cannot map the lasso objective to (B) directly, as f\u2217 must be \u03c4 -strongly convex and the L1-norm is non-strongly convex.\n3. Support Vector Machine (Case III: map to (B)). We can represent a hinge loss support vector machine (SVM) by mapping the model:\nmin u\u2208Rp\n1\nm m\u2211 i=1 max { 0, 1\u2212 yi(x>i u) } + \u03bb2\u2016u\u2016 2 2 , (9)\nto objective (B), letting g\u2217(\u2212A>w) = \u2211\ni g \u2217 i (\u2212x>i w) = \u2211 i 1 n max{0, 1\u2212 yix > i w} and\nf\u2217(w) = \u03bb2\u2016w\u2016 2 2. In this mapping, d represents the number of features, and n the number of training points. Note that we cannot map the hinge loss SVM primal to objective (A) directly, as f must be (1/\u03c4)-smooth and the hinge loss is non-smooth."}, {"heading": "2.5 Data Partitioning", "text": "To view our setup in the distributed environment, we suppose that the dataset A is distributed over K machines according to a partition {Pk}Kk=1 of the columns of A \u2208 Rd\u00d7n. We denote the size of the partition on machine k by nk = |Pk|. For machine k \u2208 {1, . . . ,K} and weight vector \u03b1 \u2208 Rn, we define \u03b1[k] \u2208 Rn as the n-vector with elements (\u03b1[k])i := \u03b1i if i \u2208 Pk and (\u03b1[k])i := 0 otherwise. Analogously, we write A[k] for the corresponding group of columns of A, and zeros elsewhere (note that columns can correspond to either training examples or features, depending on the application). We discuss these distribution schemes in greater detail in Section 3."}, {"heading": "3. CoCoA", "text": "We first describe the proposed framework, CoCoA, at a high level, and then discuss two approaches for using the framework in practice: CoCoA in the primal, where we consider (A) to be the primal objective and run the framework on this problem directly, and CoCoA in the dual, where we instead consider (B) to be the primal objective, and then run the framework on the dual (A). Note that in both approaches, the aim will be to compute a minimizer of the problem (A) in a distributed fashion; the main difference will be whether we view (A) as the primal objective or as the dual objective."}, {"heading": "3.1 The Generalized Framework", "text": "The goal of our framework is to find a global minimizer of the objective (A), while distributing computation based on the partitioning of the dataset A across machines (Section 2.5). As a first step, note that distributing the update to the function g in objective (A) is straightforward, as we have required that this term is separable according to the partitioning of our data, i.e., g(\u03b1) = \u2211n i=1 gi(\u03b1i). However, the same does not hold for the term f(A\u03b1). To minimize this part of the objective in a distributed fashion, we propose minimizing a quadratic approximation of the function, which allows the minimization to separate across machines. We make this approximation precise in the following subsection.\nData-local quadratic subproblems. In the general CoCoA framework (Algorithm 1), we distribute computation by defining a data-local subproblem of the optimization problem (A) for each machine. This simpler problem can be solved on machine k and only requires accessing data which is already available locally, i.e., the columns A[k]. More formally, each machine k is assigned the following local subproblem, which depends only on the previous shared vector v := A\u03b1 \u2208 Rd, and the local data A[k]:\nmin \u2206\u03b1[k]\u2208Rn\nG\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]) , (10)\nwhere\nG\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]) := 1 K f(v) + w>A[k]\u2206\u03b1[k] +\n\u03c3\u2032\n2\u03c4 \u2225\u2225\u2225A[k]\u2206\u03b1[k]\u2225\u2225\u22252 + \u2211 i\u2208Pk gi(\u03b1i + \u2206\u03b1[k]i),\nandw := \u2207f(v). Here we let \u2206\u03b1[k] denote the change of local variables \u03b1i for indices i \u2208 Pk, and we set (\u2206\u03b1[k])i := 0 for all i /\u2208 Pk. It is important to note that the subproblem (10)\nAlgorithm 1 Generalized CoCoA Distributed Framework\n1: Input: Data matrix A distributed column-wise according to partition {Pk}Kk=1, aggregation parameter \u03b3\u2208(0, 1], and parameter \u03c3\u2032 for the local subproblems G\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]). Starting point \u03b1(0) := 0 \u2208 Rn, v(0) := 0 \u2208 Rd. 2: for t = 0, 1, 2, . . . do 3: for k \u2208 {1, 2, . . . ,K} in parallel over computers do 4: call local solver, returning a \u0398-approximate solution \u2206\u03b1[k] of the local subproblem (10) 5: update local variables \u03b1(t+1)[k] := \u03b1 (t) [k] + \u03b3\u2206\u03b1[k] 6: return updates to shared state \u2206vk := A[k]\u2206\u03b1[k] 7: end for 8: reduce v(t+1) := v(t) + \u03b3 \u2211K k=1 \u2206vk 9: end for\nis simple in the sense that it is always a quadratic objective (apart from the gi term). The subproblem does not depend on the function f itself, but only its linearization at the fixed shared vector v. This property additionally simplifies the task of the local solver, especially for cases of complex functions f .\nFramework parameters \u03b3 and \u03c3\u2032. There are two parameters that must be set in our framework: \u03b3, the aggregation parameter, which controls how the updates from each machine are combined, and \u03c3\u2032, the subproblem parameter, which is a data-dependent term measuring the difficulty of the data partitioning {Pk}Kk=1. These terms play a crucial role in the convergence of the method, as we demonstrate in Section 4. In practice, we provide a simple and robust way to set these parameters: For a given aggregation parameter \u03b3 \u2208 (0, 1], the subproblem parameter \u03c3\u2032 will be set as \u03c3\u2032 := \u03b3K, but can also be improved in a datadependent way as we discuss below. In general, as we show in Section 4, setting \u03b3 := 1 and \u03c3\u2032 := K will guarantee convergence while delivering our fastest convergence rates.\nDefinition 5 (Data-dependent aggregation parameter). In Algorithm 1, the aggregation parameter \u03b3 controls the level of adding (\u03b3 := 1) versus averaging (\u03b3 := 1K ) of the partial solutions from all machines. For our convergence results (Section 4) to hold, the subproblem parameter \u03c3\u2032 must be chosen not smaller than\n\u03c3\u2032 \u2265 \u03c3\u2032min := \u03b3 max \u03b1\u2208Rn \u2016A\u03b1\u20162\u2211K k=1 \u2016A[k]\u03b1[k]\u20162 . (11)\nThe simple choice of \u03c3\u2032 := \u03b3K is valid for (11), i.e.,\n\u03b3K \u2265 \u03c3\u2032min .\nIn some cases, it will be possible to give a better (data-dependent) choice for \u03c3\u2032, closer to the actual bound given in \u03c3\u2032min.\nSubproblem Interpretation. Here we provide further intuition behind the data-local subproblems (10). The local objective functions G\u03c3\u2032k are defined to closely approximate the global objective in (A) as the \u201clocal\u201d variable \u2206\u03b1[k] varies, which we will see in the analysis (Appendix D, Lemma 1). In fact, if the subproblem were solved exactly, this could be interpreted as a data-dependent, block-separable proximal step, applied to the f part of the objective (A) as follows: K\u2211 k=1 G\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]) = R+ f(v) +\u2207f(v)>A\u2206\u03b1 + \u03c3\u2032 2\u03c4 \u2206\u03b1> A > [1]A[1] 0 . . . 0 A>[K]A[K]\n\u2206\u03b1 , where R = \u2211 i\u2208[n] gi(\u2212\u03b1i \u2212\u2206\u03b1i) .\nHowever, note that in contrast to traditional proximal methods, our algorithm does not assume that this subproblem is solved to high accuracy, as we instead allow the use of local solvers of any approximation quality \u0398.\nReusability of existing single-machine solvers. Our local subproblems (10) have the appealing property of being very similar in structure to the global problem (A), with the main difference being that they are defined on a smaller (local) subset of the data, and are simpler because they are not dependent on the shape of f . For a user of CoCoA, this presents a major advantage in that existing single machine-solvers can be directly re-used in our distributed framework (Algorithm 1) by employing them on the subproblems G\u03c3\u2032k .\nTherefore, problem-specific tuned solvers which have already been developed, along with associated speed improvements (such as multi-core implementations), can be easily leveraged in the distributed setting. We quantify the dependence on local solver performance with the following assumption and remark, and relate this performance to our global convergence rates in Section 4.\nAssumption 1 (\u0398-approximate solution). We assume that there exists \u0398 \u2208 [0, 1) such that \u2200k \u2208 [K], the local solver at any outer iteration t produces a (possibly) randomized approximate solution \u2206\u03b1[k], which satisfies\nE [ G\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k])\u2212 G\u03c3 \u2032 k (\u2206\u03b1 ? [k];v,\u03b1[k]) ] \u2264 \u0398 ( G\u03c3\u2032k (0;v,\u03b1[k])\u2212 G\u03c3 \u2032 k (\u2206\u03b1 ? [k];v,\u03b1[k]) ) ,\n(12)\nwhere \u2206\u03b1?[k] \u2208 arg min\n\u2206\u03b1\u2208Rn G\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]), \u2200k \u2208 [K] . (13)\nRemark 1. In practice, the time spent solving the local subproblems in parallel should be chosen comparable to the required time of a communication round, for best overall efficiency on a given system. We study this trade-off both in theory (Section 4) and experiments (Section 6).\nRemark 2. Note that the accuracy parameter \u0398 does not have to be chosen a priori: Our convergence results (Section 4) are valid if \u0398 is an upper bound on the actual empirical values \u0398 in the rounds of Algorithm 1. This allows for some of the K machines to at times deliver better or worse accuracy (e.g., if a slow local machine is stopped early during a specific round, to avoid the others needing to wait).\nWith this general framework in place, we next discuss two variants of our framework, CoCoA-Primal and CoCoA-Dual. In running either the primal or dual variant of our framework, the goal will always be to solve objective (A) in a distributed fashion. The main difference will be whether this objective is viewed as the primal or dual of the input problem (I). If we map the input (I) to objective (A), then (A) will be viewed as the primal. If we map (I) to (B), the objective (A) will be viewed as the dual. We make this mapping technique precise and discuss its implications in the following subsections (Sections 3.2\u20133.4)."}, {"heading": "3.2 Primal Distributed Optimization", "text": "In the primal distributed version of the framework (Algorithm 2), the framework is run by mapping the initial problem (I) directly to objective (A) and then applying the generalized CoCoA framework described in Algorithm 1. In other words, we view problem (A) as the primal objective, and solve this problem directly.\nFrom a theoretical perspective, viewing (A) as the primal will allow us to consider nonstrongly convex regularizers, since we allow the terms gi to be non-strongly convex. This setting was not covered in earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015b); and Ma et al. (2015a), and we discuss it in detail in Section 4, as additional machinery must be introduced to develop primal-dual rates for this setting.\nRunning the primal version of the framework has important practical implications in the distributed setting, as it typically implies that the data is distributed by feature rather than by training point. In this setting, the amount of communication at every outer iteration will be O(# of training points). When the number of features is high (as is common when using sparsity-inducing regularizers) this can help to reduce communication and improve overall performance, as we demonstrate in Section 6.\nAlgorithm 2 CoCoA-Primal (Mapping Problem (I) to (A))\n1: Map: Input problem (I) to objective (A) 2: Distribute: Dataset A by columns (here typically features) according to par-\ntition {Pk}Kk=1 3: Run: Algorithm 1 with aggregation parameter \u03b3 and subproblem parameter \u03c3\u2032"}, {"heading": "3.3 Dual Distributed Optimization", "text": "In the dual distributed version of the framework (Algorithm 3), we run the framework by mapping the original problem (I) to objective (B), and then solve the problem by running Algorithm 1 on the dual (A). In other words, we view problem (B) as the primal, and solve this problem via the dual (A).\nThis version of the framework will allow us to consider non-smooth losses, such as the hinge loss or absolute deviation loss, since the terms g\u2217i can be non-smooth. From a practical perspective, this version of the framework will typically imply that the data is distributed by training point, and for a vector O(# of features) to be communicated at every outer iteration. This variant may therefore be preferable when the number of training points exceeds the number of features.\nAlgorithm 3 CoCoA-Dual (Mapping Problem (I) to (B))\n1: Map: Input problem (I) to objective (B) 2: Distribute: Dataset A by columns (here typically training points) according\nto partition {Pk}Kk=1 3: Run: Algorithm 1 with aggregation parameter \u03b3 and subproblem parameter \u03c3\u2032"}, {"heading": "3.4 Primal vs. Dual", "text": "In Table 2, we revisit the three cases from Section 2, showing how the primal and dual variants of CoCoA can be applied to various input problems `(u) + r(u), depending on properties of the functions ` and r. In particular, in the setting where ` is smooth and r is strongly convex, the user may choose whether to run the framework in the primal (Algorithm 2), or in the dual (Algorithm 3). Intuitively, Algorithm 2 will be preferable as r loses strong convexity, and Algorithm 3 will be preferable as ` loses smoothness. However, there are also systems-related aspects to consider. In Algorithm 2, we typically distribute the data by feature, and in Algorithm 3, by training point (this distribution depends on how the terms n and d are defined in our mapping, see Section 5). Depending on whether the number of features or number of training points is the dominating term, we may chose to run Algorithm 2 or Algorithm 3, respectively, in order to reduce communication costs. We validate these ideas empirically in Section 6 by comparing the performance of each variant (primal vs. dual) on real distributed datasets.\nIn the following two subsections, we provide greater insight into the form of the generalized CoCoA framework and its relation to prior work. An extended discussion on related work is available in Section 7.\n3.5 Interpretation of CoCoA in the Context of Classical Parallelization Schemes\nThere are numerous methods that have been developed to solve (A) and (B) in parallel and distributed environments. We describe related work in detail in Section 7, and here briefly highlight a major algorithmic difference between CoCoA and other widely-used parallelized methods. In particular, we contrast CoCoA with mini-batch and batch methods commonly used in distributed computing environments, such as mini-batch stochastic gradient descent or coordinate descent, gradient descent, and quasi-Newton methods.\nCoCoA is similar to these methods in that they are all iterative, i.e., they make progress towards the optimal solution by updating the parameter vector \u03b1 according to some function\nh : Rn \u2192 Rn at each iteration t:\n\u03b1(t+1) = h(\u03b1(t)) t = 0, 1, . . . ,\nuntil convergence is reached. From a coordinate-wise perspective, two approaches for updating the parameter vector \u03b1 in an iterative fashion include the Jacobi method, in which updates made to coordinates of \u03b1 do not take into account the most recent updates to the other coordinates, and Gauss-Seidel, in which the most recent information is used (Bersekas and Tsitsiklis, 1989). In particular, these two paradigms make the following updates to a coordinate i at iteration t+ 1:\nJacobi: \u03b1(t+1)i = hi(\u03b1 (t) 1 , . . . ,\u03b1 (t) n ), i = 1, . . . , n,\nGauss-Seidel: \u03b1(t+1)i = hi(\u03b1 (t+1) 1 , . . . ,\u03b1 (t+1) i\u22121 ,\u03b1 (t) i , . . . ,\u03b1 (t) n ), i = 1, . . . , n.\nThe Jacobi method does not require information from the other coordinates to update coordinate i, which makes this style of method well-suited for parallelization. However, the Gauss-Seidel style method tends to converge faster in terms of iterations, since it is able to incorporate information from the other coordinates more quickly. This difference is wellknown and evident in single machine solvers, where stochastic methods (benefiting from fresh updates) tend to outperform their batch counterparts.\nTypical mini-batch methods, e.g., mini-batch coordinate descent, perform a Jacobi-style update on a subset of the coordinates at each iteration. This makes these methods amenable to high levels of parallelization. However, they are unable to incorporate information as quickly as their serial counterparts in terms of number of data points accessed, because they must wait for a synchronization step to update the coordinates. As the size of the mini-batch grows, this can slow them down in terms of overall runtime, and can even lead to divergence in practice (Tak\u00e1\u010d et al., 2013; Tak\u00e1\u010d et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016; Marecek et al., 2015).\nCoCoA instead attempts to combine attractive properties of both of these update paradigms. It performs Jacobi-style parallel updates to blocks of the coordinates of \u03b1 to parallelize the method, while allowing for (though not necessarily requiring) faster GaussSeidel style updates on each machine. This change in parallelization scheme is one of the major reasons for improved performance over simpler mini-batch or batch style methods.\nCoCoA incorporates an additional level of flexibility by allowing an arbitrary number of Gauss-Seidel iterations (or any other local solver for that matter) to be performed on each machine, which lets the framework scale from very low-communication environments, where more iterations will be made before communicating, to higher communication environments, where fewer internal iterations are necessary. We will see in Section 6 that this communication flexibility also greatly improves the overall runtime in practice."}, {"heading": "3.6 Comparison to ADMM", "text": "Finally, in this subsection we provide a direct comparison between CoCoA and ADMM (Boyd et al., 2010). Alternating direction method of multipliers (ADMM) is a well-established framework for distributed optimization. Similar to CoCoA, ADMM differs from the methods discussed in the previous section in that it defines a subproblem for each problem to solve\nin parallel, rather than parallelizing a global batch or mini-batch update. It also leverages duality structure, similar to that presented in Section 2.\nFor consensus ADMM, the objective (B) is decomposed with a re-parameterization:\nmax w1,...wK ,w K\u2211 k=1 \u2211 i\u2208Pk g\u2217(\u2212x>i wk) + f\u2217(w)\ns.t. wk = w, k = 1, . . . ,K.\nThis problem is then solved by constructing the augmented Lagrangian, which yields the following decomposable updates:\nw (t) k = arg min\nwk\n\u2211 i\u2208Pk g\u2217(\u2212x>i wk) + \u03c1 2 \u2016wk \u2212 ( w(t\u22121) \u2212 u(t\u22121)k ) \u20162, (14)\nw(t) = arg min w f\u2217(w) + \u03c1 K\u2211 k=1 u>k (wk \u2212w) + \u03c1 2 K\u2211 k=1 \u2016wk \u2212w\u20162,\nu (t) k = u (t\u22121) k + w (t) k \u2212w (t),\nwhere \u03c1 is a penalty parameter that must be tuned for best performance. When running CoCoA in the dual (Algorithm 3) and setting f(\u00b7) = 12\u2016 \u00b7 \u2016 2 2, we can derive a similar subproblem for updating wk in the CoCoA framework. In particular, the following subproblem can be found by unrolling the CoCoA update and viewing the dual subproblem in its primal formulation:\nmin wk \u2211 i\u2208Pk g\u2217i (\u2212x>i wk) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225wk \u2212 (w(t\u22121) + \u03b3\u2206v(t\u22121))\u2225\u2225\u22252. (15) Comparing (14) and (15) we can see that in the specific case where f(\u00b7) = 12\u2016 \u00b7 \u2016 2 2 and we solve the problem in the dual (according to Algorithm 3), ADMM and CoCoA consider a similar subproblem on each machine, but where the parameter \u03c1 is explicitly set in CoCoA as \u03c4\u03c3\u2032 . However, there are major differences between the methods even in this setting. First, CoCoA has a more direct and simplified scheme for updating the global weight vector w. Second, and most importantly, in the CoCoA method and theory, we allow for the subproblem to be solved approximately, rather than requiring a full batch update as in ADMM. We will see in our experiments that these differences have a large impact in practice (Section 6). We provide a full derivation of the comparison to ADMM for reference in Appendix C."}, {"heading": "4. Convergence Analysis", "text": "In this section, we provide convergence rates for the proposed framework and introduce an important theoretical technique in analyzing non-strongly convex terms in the primal-dual setting. For simplicity of presentation, we assume in the analysis that the data partitioning is balanced; i.e., nk = n/K for all k. Furthermore, we assume that the columns of A satisfy \u2016xi\u2016 \u2264 1 for all i \u2208 [n]. We present rates for the case where \u03b3 := 1 in Algorithm 1, and where the subproblems (10) are defined using the corresponding safe bound \u03c3\u2032 := K. This\ncase will guarantee convergence while delivering our fastest rates in the distributed setting, which in particular don\u2019t degrade as the number of machines K grows and n remains fixed."}, {"heading": "4.1 Proof Strategy: Relating Subproblem Approximation to Global Progress", "text": "To guarantee convergence, it is critical to show how progress made on the local subproblems (10) relates to the global objective OA. Our first lemma provides exactly this information. In particular, we see that if the aggregation and subproblem parameters are selected according to Definition 5, the sum of the subproblem objectives, \u2211K k=1 G\u03c3 \u2032 k , will form a block-separable upper bound on the global objective OA.\nLemma 1. For any weight vector \u03b1,\u2206\u03b1 \u2208 Rn, v = v(\u03b1) := A\u03b1, and real values \u03b3, \u03c3\u2032 satisfying (11), it holds that\nOA ( \u03b1 + \u03b3 K\u2211 k=1 \u2206\u03b1[k] ) \u2264 (1\u2212 \u03b3)OA(\u03b1) + \u03b3 K\u2211 k=1 G\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]) . (16)\nA proof of Lemma 1 is provided in Appendix D. We use this main lemma, in combination with our assumption on the quality of the subproblem approximations (Assumption 1), to deliver our global convergence rates.\n4.2 Rates for General Convex gi, L-Lipschitz g\u2217i Our first main theorem provides convergence guarantees for objectives with general convex gi (or, equivalently, L-Lipschitz g\u2217i ), including models with non-strongly convex regularizers such as lasso and sparse logistic regression, or models with non-smooth losses, such as the hinge loss support vector machine.\nProviding primal-dual rates and globally defined primal-dual accuracy certificates for these objectives may require an important theoretical technique that we introduce below, in which we show how to satisfy the notion of L-bounded support for gi, as stated in Definition 2.\nTheorem 2. Consider Algorithm 1 with \u03b3 := 1, and let \u0398 be the quality of the local solver as in Assumption 1. Let gi have L-bounded support, and let f be (1/\u03c4)-smooth. Then after T iterations, where\nT \u2265 T0 + max{ \u2308 1\n1\u2212\u0398\n\u2309 ,\n4L2n2\n\u03c4 G(1\u2212\u0398) } , (17)\nT0 \u2265 t0 + [ 2\n1\u2212\u0398\n( 8L2n2 \u03c4 G \u2212 1 )] + ,\nt0 \u2265 max(0, \u2308 1 (1\u2212\u0398) log ( \u03c4(OA(\u03b1(0))\u2212OA(\u03b1?)) 2L2Kn )\u2309 ) ,\nwe have that the expected duality gap satisfies\nE [ OA(\u03b1)\u2212 (\u2212OB(w(\u03b1))) ] \u2264 G ,\nwhere \u03b1 is the averaged iterate: 1T\u2212T0 \u2211T\u22121 t=T0+1 \u03b1(t)."}, {"heading": "4.2.1 Bounded support modification", "text": "As mentioned earlier, additional work is necessary if Theorem 2 is to be applied to nonstrongly convex regularizers such as the L1 norm, which do not have L-bounded support for each gi, and thus violate the assumptions of the theorem. Note for example that the conjugate function of gi = | \u00b7 |, which is the indicator function of an interval, is not defined globally over R, and thus (without further modification) the duality gap G(\u03b1) := OA(\u03b1)\u2212 (\u2212OB(w(\u03b1))) is not even defined at all points \u03b1.\nSmoothing. To address this problem, existing approaches typically use a simple smoothing technique (as in Nesterov, 2005; Shalev-Shwartz and Zhang, 2014): by adding a small amount of L2 to the objective gi, the functions gi become strongly convex. Followed by this change, the algorithms are then run on the dual of instead of the original primal problem at hand. While this modification satisfies the necessary assumptions for convergence of our framework, this Nesterov smoothing technique is often undesirable in practice, as it changes the iterates, the algorithms at hand, the convergence rate, and the tightness of the resulting duality gap compared to the original objective. Further, the amount of smoothing can be difficult to tune and can have a large influence on the performance of the method at hand. We show practical examples of these difficulties in Section 6.\nBounded support modification. In contrast to smoothing, our approach preserves all solutions of the original objective, leaves the iterate sequence unchanged, and allows for direct reusability of existing solvers for the original gi objectives (such as L1 solvers). It also removes the need for tuning a smoothing parameter. To achieve this, we modify the function gi by imposing an additional weak constraint that is inactive in our region of interest. Formally, we replace gi(\u03b1i) by the following modified function:\ng\u0304i(\u03b1i) := { gi(\u03b1i) : \u03b1i \u2208 [\u2212B,B] +\u221e : otherwise.\n(18)\nFor large enough B, this problem yields the same solution as the original objective. Note also that this only affects convergence theory, in that it allows us to present a strong primaldual rate (Theorem 2 for L=B). The modification of gi does not affect the algorithms for the original problems. Whenever a monotone optimizer is used, we will never leave the level set defined by the objective at the starting point.\nUsing the resulting modified function will allow us to apply the results of Theorem 2 for general convex functions gi. This technique can also be thought of as \u201cLipschitzing\u201d the dual g\u2217i , because of the general result that g \u2217 i is L-Lipschitz if and only if gi has Lbounded support (Rockafellar, 1997, Corollary 13.3.3). We derive the conjugate function g\u0304\u2217i for completeness in Appendix B (Lemma 6). In Section 5, we show how to leverage this technique for a variety of application input problems. See also D\u00fcnner et al. (2016) for a follow-up discussion of this technique in the non-distributed case.\n4.3 Rates for Strongly Convex gi, Smooth g\u2217i For the case of objectives with strongly convex gi (or, equivalently, smooth g\u2217i ), e.g., elastic net regression or logistic regression, we obtain the following faster linear convergence rate.\nTheorem 3. Consider Algorithm 1 with \u03b3 := 1, and let \u0398 be the quality of the local solver as in Assumption 1. Let gi be \u00b5-strongly convex \u2200i \u2208 [n], and let f be (1/\u03c4)-smooth. Then after T iterations where\nT \u2265 1(1\u2212\u0398) \u00b5\u03c4+n \u00b5\u03c4 log n OA , (19)\nit holds that E [ OA(\u03b1(T ))\u2212OA(\u03b1?) ] \u2264 OA .\nFurthermore, after T iterations with\nT \u2265 1(1\u2212\u0398) \u00b5\u03c4+n \u00b5\u03c4 log\n( 1\n(1\u2212\u0398) \u00b5\u03c4+n \u00b5\u03c4 n G\n) ,\nwe have the expected duality gap E [ OA(\u03b1(T ))\u2212 (\u2212OB(w(\u03b1(T ))) ] \u2264 G .\nWe provide proofs of both Theorem 2 and Theorem 3 in Appendix D."}, {"heading": "4.4 Convergence Cases", "text": "Revisiting Table 1 from Section 2, we summarize our convergence guarantees for the three cases of input problems (I) in the following table. In particular, we see that for cases II and III, we obtain a sublinear convergence rate, whereas for case I we can obtain a faster linear rate, as provided in Theorem 3."}, {"heading": "4.5 Recovering Earlier Work as a Special Case", "text": "As a special case, the proposed framework and rates directly apply to L2-regularized lossminimization problems, including those presented in the earlier work of Jaggi et al. (2014) and Ma et al. (2015b).\nRemark 3. If we run Algorithm 3 (mapping (I) to (B)), restrict f\u2217(\u00b7) := \u03bb2\u2016 \u00b7 \u2016 2 (so that \u03c4 = \u03bb), and let g\u2217i := 1 n` \u2217 i , Theorem 2 recovers as a special case the CoCoA\n+ rates for general L-Lipschitz `\u2217i losses (see Ma et al., 2015b, Corollary 9). The earlier work of CoCoA-v1 (Jaggi et al., 2014) did not provide rates for L-Lipschitz `\u2217i losses.\nThese cases follow since g\u2217i is L-Lipschitz if and only if gi has L-bounded support (Rockafellar, 1997, Corollary 13.3.3).\nRemark 4. If we run Algorithm 3 (mapping (I) to (B)), restrict f\u2217(\u00b7) := \u03bb2\u2016 \u00b7 \u2016 2 (so that \u03c4 = \u03bb), and scale g\u2217i := 1 n` \u2217 i , Theorem 3 recovers as a special case the CoCoA\n+ rates for (1/`\u2217i )-smooth losses (see Ma et al., 2015b, Corollary 11). The earlier rates of CoCoA-v1 can be obtained by setting \u03b3:= 1K and \u03c3 \u2032=1 in Algorithm 1 (Jaggi et al., 2014, Theorem 2).\nThese cases follow since g\u2217i is \u00b5-strongly convex if and only if gi is (1/\u00b5)-smooth (HiriartUrruty and Lemar\u00e9chal, 2001, Theorem 4.2.2)."}, {"heading": "5. Applications", "text": "In this section we provide a detailed treatment of example applications that can be cast within the general CoCoA framework. For each example, we describe the primal-dual setup and algorithmic details, discuss the convergence properties our framework for the application, and include practical concerns such as information on state-of-the-art local solvers. We discuss examples according to the three cases defined in Table 1 of Section 2 for finding a minimizer of the general objective `(u) + r(u), and provide a summary of these common examples in Table 4."}, {"heading": "5.1 Case I: Smooth `, Strongly convex r", "text": "For input problems (I) with smooth ` and strongly convex r, Theorem 3 from Section 4 gives a global linear (geometric) convergence rate. Smooth loss functions can be mapped either to the function f in objective (A), or g\u2217 in (B). Similarly, strongly convex regularizers can be mapped either to function g in objective (A), or f\u2217 in (B). To illustrate the role of f as a smooth loss function and g as a strongly convex regularizer in objective (A), contrasting with their traditional roles in prior work (Yang, 2013; Jaggi et al., 2014; Ma et al., 2015b,a), we consider the following examples. Note that mapping to objective (B) instead will follow trivially assuming that the loss is separable across training points (see Table 4).\nFor the examples in this subsection, we use nonstandard definitions of the number of training points as d and the number of features as n. These definitions are intentionally used so that we can present both the primal and dual variations of our framework (Algorithms 2 and 3) with a single abstracted method (Algorithm 1).\nSmooth `: least squares loss. Let b \u2208 Rd be labels or response values, and consider the least squares objective, f(v) := 12\u2016v \u2212 b\u2016 2 2, which is 1-smooth. We obtain the familiar least-squares regression objective in our optimization problem (A), using\nf(A\u03b1) := 12\u2016A\u03b1\u2212 b\u2016 2 2 . (20)\nObserving that the gradient of f is \u2207f(v) = v \u2212 b, the primal-dual mapping is given by: w(\u03b1) := \u2207f(v(\u03b1)) = A\u03b1 \u2212 b, which is well known as the residual vector in least-squares regression.\nSmooth `: logistic regression loss. For classification problems, we consider a logistic regression model with d training examples, yj \u2208 Rn for j \u2208 [d], collected as the rows of the data matrix A. For each training example, we are given a binary label, which we collect in the vector b \u2208 {\u22121, 1}d. Formally, the objective is defined as f(v) := \u2211d j=1 log (1 + exp (\u2212bjvj)), which is again a separable function. The classifier loss is given by\nf(A\u03b1) := d\u2211 j=1 log (1 + exp (\u2212bjy>j \u03b1)) , (21)\nwhere \u03b1 \u2208 Rn is the parameter vector. It is not hard to show that f is 1-smooth if the labels satisfy bj \u2208 [\u22121, 1]. The primal-dual mapping w(\u03b1) := \u2207f(v(\u03b1)) = \u2207f(A\u03b1) is given by wj(\u03b1) :=\n\u2212bj 1+exp (bjy>j \u03b1) .\nStrongly convex r: elastic net regularizer. An application we can consider for a strongly convex regularizer, g in (A) or f\u2217 in (B), is elastic net regularization, \u03b7\u03bb\u2016u\u20161 + (1\u2212 \u03b7)\u03bb2\u2016u\u2016 2 2, for fixed parameter \u03b7 \u2208 (0, 1]. This can be obtained in (A) by setting\ng(\u03b1) = n\u2211 i=1 gi(\u03b1i) := n\u2211 i=1 \u03b7\u03bb|\u03b1i|+ (1\u2212 \u03b7)\u03bb2\u03b1 2 i . (22)\nFor the special case \u03b7 = 1, we obtain the L1-norm, and for \u03b7 = 0, we obtain the L2-norm. The conjugate of gi is given by: g\u2217i (x) := 1 2(1\u2212\u03b7) ([ |x| \u2212 \u03b7 ] + )2, where [.]+ is the positive part operator, [s]+ = s for s > 0, and zero otherwise."}, {"heading": "5.2 Case II: Smooth `, Non-Strongly Convex Separable r", "text": "In case II, we consider mapping the input problem (I) to objective (A), where ` is assumed to be smooth, and r non-strongly convex and separable. For smooth losses in (A), we can consider as examples those provided in Subsection 5.1, e.g., the least squares loss or logistic loss. For an example of a non-strongly convex regularizer, we consider the important case of L1 regularization below. Again, we note that this application cannot be realized by objective (B), where it is assumed that the regularization term f\u2217 is strongly convex.\nNon-strongly convex r: L1 regularizer. L1 regularization is obtained in objective (A) by letting gi(\u00b7) := \u03bb| \u00b7 |. However, an additional modification is necessary to obtain primaldual convergence and certificates for this setting. In particular, we employ the modification introduced in Section 4, which will guarantee L-bounded support. Formally, we replace gi(\u00b7) = | \u00b7 | by\ng\u0304(\u03b1) := { |\u03b1| : \u03b1 \u2208 [\u2212B,B], +\u221e : otherwise.\nFor large enough B, this problem yields the same solution as the original L1-objective. Note that this only affects convergence theory, in that it allows us to present a strong primal-dual\nrate (Theorem 2 for L=B). With this modified L1-regularizer, the optimization problem (A) with regularization parameter \u03bb becomes\nmin \u03b1\u2208Rn f(A\u03b1) + \u03bb n\u2211 i=1 g\u0304(\u03b1i) . (23)\nFor large enough choice of the value B, this problems yields the same solution as the original objective:\nmin \u03b1\u2208Rn\n{ OA(\u03b1) := f(A\u03b1) + \u03bb n\u2211 i=1 |\u03b1i| } . (24)\nThe modified g\u0304 is simply a constrained version of the absolute value to the interval [\u2212B,B]. Therefore by setting B to a large enough value that the values of \u03b1i will never reach it, g\u0304\u2217 will be continuous and at the same time make (23) equivalent to (24). Formally, a simple way to obtain a large enough value of B, so that all solutions of (24) are unaffected, is the following: If we start the algorithm at \u03b1 = 0, for every solution encountered during execution, the objective values will never become worse than OA(0). Formally, under the assumption that f is non-negative, we will have that (for each i):\n\u03bb|\u03b1i| \u2264 f(0) = OA(0) =\u21d2 |\u03b1i| \u2264 f(0)\n\u03bb .\nWe can therefore safely set the value of B as f(0)\u03bb . For the modified g\u0304i, the conjugate g\u0304 \u2217 i is given by:\ng\u0304\u2217i (x) := { 0 : x \u2208 [\u22121, 1], B(|x| \u2212 1) : otherwise.\nWe provide a proof of this in Appendix B (Lemma 6).\nNon-strongly convex r: group lasso. The group lasso penalty can be mapped to objective (A), with:\ng(\u03b1) := \u03bb P\u2211 p=1 \u2016\u03b1Ip\u20162 with P\u22c3 p=1 Ip = {1, . . . , n} , (25)\nwhere the disjoint sets Ip \u2286 {1, . . . , n} represent a partitioning of the total set of variables. This penalty can be viewed as an intermediate between a pure L1 or L2 penalty, performing variable selection only at the group level. The term \u03b1Ip \u2208 R|Ip| denotes part of the vector \u03b1 with indices Ip. The conjugate is given by:\ng\u2217(w) = I{w|maxIp\u2208[n] \u2016\u03b1Ip\u20162\u2264\u03bb}(w).\nFor details, see, e.g., D\u00fcnner et al. (2016) or Boyd and Vandenberghe (2004, Example 3.26)."}, {"heading": "5.3 Case III: Non-Smooth Separable `, Strongly Convex r", "text": "Finally, in case III, we consider mapping the input problem (I) to objective (B), where ` is assumed to be non-smooth and separable, and r strongly convex. We discuss two common cases of general non-smooth losses `, including the the hinge loss for classification and absolute deviation loss for regression. When paired with a strongly convex regularizer, the regularizer via f gives rise to the primal-dual mapping, and Theorem 2 provides a sublinear convergence rate for objectives of this form. We note that these losses cannot be realized directly by objective (A), where it is assumed that the data fit term f is smooth.\nNon-smooth `: hinge loss. For classification problems, we can consider a hinge loss support vector machine model, on n training points in Rd, given with the loss:\ng\u2217(\u2212A>w) = n\u2211 i=1 g\u2217i (\u2212x>i w) := 1 n n\u2211 i=1 max{0, 1\u2212 yix>i w}. (26)\nThe conjugate function of the hinge loss \u03c6(a) = max{0, 1 \u2212 b} is given by \u03c6\u2217(b) = {b if b \u2208 [\u22121, 0], else \u221e .}. When using the L2 norm for regularization in this problem: f\u2217(w) := \u03bb\u2016w\u201622, a primal-dual mapping is given by: w(\u03b1) := 1\u03bbnA\u03b1.\nNon-smooth `: absolute deviation loss. The absolute deviation loss, used, e.g., in quantile regression or least absolute deviation regression, can be realized in objective (B) by setting:\ng\u2217(\u2212A>w) = n\u2211 i=1 g\u2217i (\u2212x>i w) := 1 n n\u2211 i=1 \u2223\u2223\u2223x>i w \u2212 yi\u2223\u2223\u2223 . (27) The conjugate function of the absolute deviation loss \u03c6(a) = |a \u2212 yi| is given by \u03c6\u2217(\u2212b) = \u2212byi, with b \u2208 [\u22121, 1]."}, {"heading": "5.4 Local Solvers", "text": "As discussed in Section 3, the subproblems solved on each machine in the CoCoA framework are appealing in that they are very similar in structure to the global problem (A), with the main difference being that they are defined on a smaller (local) subset of the data, and have a simpler dependence on the term f . Therefore, solvers which have already proven their value in the single machine or multicore setting can be easily leveraged within the framework. We discuss some specific examples of local solvers below, and point the reader to Ma et al. (2015a) for an empirical exploration of these choices.\nIn the primal setting (Algorithm 2), the local subproblem (10) becomes a simple quadratic problem on the local data, with regularization applied only to local variables \u03b1[k]. For the L1 examples discussed, existing fast L1-solvers for the single-machine case, such as glmnet variants (Friedman et al., 2010) or blitz (Johnson and Guestrin, 2015) can be directly applied to each local subproblem G\u03c3\u2032k ( \u00b7 ;v,\u03b1[k]) within Algorithm 1. The sparsity induced on the subproblem solutions of each machine naturally translates into the sparsity of the global solution, since the local variables \u03b1[k] will be concatenated.\nIn terms of the approximation quality parameter \u0398 for the local problems (Assumption 1), we can apply existing recent convergence results from the single machine case. For\nexample, for randomized coordinate descent (as part of glmnet), Lu and Xiao (2013, Theorem 1) gives a O(1/t) approximation quality for any separable regularizer, including L1 and elastic net; see also Tappenden et al. (2015) and Shalev-Shwartz and Tewari (2011).\nIn the dual setting (Algorithm 3) for the discussed examples, the losses are applied only to local variables \u03b1[k], and the regularizer is approximated via a quadratic term. Current state of the art for the problems of the form in (B) are variants of randomized coordinate ascent\u2014Stochastic Dual Coordinate Ascent (SDCA) (Shalev-Shwartz and Zhang, 2013a). This algorithm and its variants are increasingly used in practice (Wright, 2015), and extensions such as accelerated and parallel versions can directly be applied (Shalev-Shwartz and Zhang, 2014; Fan et al., 2008) in our framework. For non-smooth losses such as SVMs, the analysis of Shalev-Shwartz and Zhang (2013a) provides a O(1/t) rate, and for smooth losses, a faster linear rate. There have also been recent efforts to derive a linear convergence rate for problems like the hinge-loss support vector machine that could be applied, e.g., by using error bound conditions (Necoara and Nedelcu, 2014; Wang and Lin, 2014), weak strong convexity conditions (Ma et al., 2015c; Necoara, 2015) or by considering Polyak-\u0141ojasiewicz conditions (Karimi et al., 2016)."}, {"heading": "6. Experiments", "text": "In this section we demonstrate the empirical performance of CoCoA in the distributed setting. We first compare CoCoA to competing methods for two common machine learning applications: lasso regression (Section 6.1) and support vector machine (SVM) classification (Section 6.2). We then explore the performance of CoCoA in the primal versus the dual directly by solving an elastic net regression model with both variants (Section 6.3). Finally, we illustrate general properties of the CoCoA method empirically in Section 6.4.\nExperimental setup. We compare CoCoA to numerous state-of-the-art general-purpose methods for large-scale optimization, including:\n\u2022 Mb-SGD: Mini-batch stochastic gradient. For our experiments with lasso, we compare against Mb-SGD with an L1-prox.\n\u2022 GD: Full gradient descent. For lasso we use the proximal version, Prox-GD. \u2022 L-BFGS: Limited-memory quasi-Newton method. For lasso, we use OWL-QN (orthant-\nwise limited quasi-Newton).\n\u2022 ADMM: Alternating direction method of multipliers. We use conjugate gradient internally for the lasso experiments, and SDCA for SVM experiments.\n\u2022 Mb-CD: Mini-batch parallel coordinate descent. For SVM experiments, we implement Mb-SDCA (mini-batch stochastic dual coordinate ascent).\nThe first three methods are optimized and implemented in Apache Spark\u2019s MLlib (v1.5.0) (Meng et al., 2016). We test the performance of each method in large-scale experiments fitting lasso, elastic net regression, and SVM models to the datasets shown in Table 5. In comparing to other methods, we plot the distance to the optimal primal solution. This optimal value is calculated by running all methods for a large number of iterations (until progress has stalled), and then selecting the smallest primal value amongst the re-\nsults. All code is written in Apache Spark and experiments are run on public-cloud Amazon EC2 m3.xlarge machines with one core per machine. Our code is publicly available at github.com/gingsmith/proxcocoa.\nWe carefully tune each competing method in our experiments for best performance. ADMM requires the most tuning, both in selecting the penalty parameter \u03c1 and in solving the subproblems. Solving the subproblems to completion for ADMM is prohibitively slow, and we thus use an iterative method internally and improve performance by allowing early stopping. We also use a varying penalty parameter \u03c1 \u2014 practices described in Boyd et al. (2010, Sections 4.3, 8.2.3, 3.4.1). For Mb-SGD, we tune the step size and mini-batch size parameters. For Mb-CD and Mb-SDCA, we scale the updates at each round by \u03b2b for mini-batch size b and \u03b2 \u2208 [1, b], and tune both parameters b and \u03b2. Further implementation details for all methods are given in Section 6.5.\nFor simplicity of presentation and comparison, in all of the following experiments, we restrict CoCoA to only use simple coordinate descent as the local solver. We note that even stronger empirical results for CoCoA could be obtained by plugging in state of the art local solvers for each application at hand.\n6.1 CoCoA in the Primal\nWe first demonstrate the performance of CoCoA in the primal (Algorithm 2) by applying CoCoA to a lasso regression model (8) fit to the distributed datasets in Table 5. We use stochastic coordinate descent as a local solver for CoCoA, and select the number of local iterations H (a proxy for subproblem approximation quality, \u0398) from several options with best performance.\nWe compare CoCoA to the general methods listed above, including Mb-SGD with an L1-prox, Prox-GD, OWL-QN, ADMM and Mb-CD. A comparison with Shotgun (Bradley et al., 2011), a popular method for solving L1-regularized problems in the multicore environment, is provided as an extreme case to highlight the detrimental effects of frequent communication in the distributed environment. For Mb-CD, Shotgun, and CoCoA in the primal, datasets are distributed by feature, whereas for Mb-SGD, Prox-GD, OWL-QN and ADMM they are distributed by training point.\nIn analyzing the performance of each algorithm (Figure 1), we measure the improvement to the primal objective given in (A) (OA(\u03b1)) in terms of wall-clock time in seconds. We see that both Mb-SGD and Mb-CD are slow to converge, and come with the additional burden of having to tune extra parameters (though Mb-CD makes clear improvements over Mb-SGD). As expected, naively distributing Shotgun (single coordinate updates per\nmachine) does not perform well, as it is tailored to shared-memory systems and requires communicating too frequently. OWL-QN performs the best of all compared methods, but is still much slower to converge than CoCoA, and converges, e.g., 50\u00d7 more slowly for the webspam dataset. The optimal performance of CoCoA is particularly evident in datasets with large numbers of features (e.g., url, kddb, webspam), which are exactly the datasets of interest for L1 regularization.\nResults are shown for regularization parameters \u03bb such that the resulting weight vector \u03b1 is sparse. However, our results are robust to varying values of \u03bb as well as to various problem settings, as we illustrate in Figure 2.\nA case against smoothing. We additionally motivate the use of CoCoA in the primal by showing how it improves upon CoCoA in the dual (Yang, 2013; Jaggi et al., 2014; Ma et al., 2015b,a) for non-strongly convex regularizers. First, CoCoA in the dual cannot be included in the set of experiments in Figure 1 because it cannot be directly applied to the lasso objective (recall that Algorithm 3 only allows for strongly convex regularizers).\nSeconds 0 100 200 300 400 500 600 700 800\nP rim\nal S\nub op\ntim al\nity : O\nA (,\n) -\nO A (,\n*)\n10-3\n10-2\n10-1\n100 Epsilon - Lasso: Convergence Across 6\nCoCoA-Primal 6=1e-4 OWL-QN 6=1e-4 CoCoA-Primal 6=1e-5 OWL-QN 6=1e-5 CoCoA-Primal 6=1e-6 OWL-QN 6=1e-6\nSeconds 0 100 200 300 400 500\nP rim\nal S\nub op\ntim al\nity : O\nA (,\n) -\nO A (,\n*)\n10-3\n10-2\n10-1\n100 Url - Elastic Net: Convergence Across 2\nCoCoA-Primal 2=.25 OWL-QN 2=.25 CoCoA-Primal 2=.5 OWL-QN 2=.5 CoCoA-Primal 2=.75 OWL-QN 2=.75\nFigure 3 & Table 6: For pure L1 regularization, Nesterov smoothing is not an effective option for CoCoA in the dual. It either modifies the solution (Figure 3) or slows convergence (Table 6). This motivates running CoCoA instead on the primal for these problems.\nTo get around this requirement, previous work has suggested implementing the Nesterov smoothing technique used in, e.g., Shalev-Shwartz and Zhang (2014); Zhang and Lin (2015) \u2014 adding a small amount of strong convexity \u03b4\u2016\u03b1\u201622 to the objective for lasso regression. In Figure 3 we demonstrate the issues with this approach, comparing CoCoA in the primal on a pure L1-regularized regression problem to CoCoA in the dual for decreasing levels of \u03b4. The smaller we set \u03b4, the less smooth the problem becomes. As \u03b4 decreases, the final sparsity of running CoCoA in the dual starts to match that of running pure L1 (Table 6), but the performance also degrades (Figure 3). We note that by using CoCoA in the primal with the modification presented in Section 4, we can deliver strong rates without having to make these fundamental alterations to the problem of interest.\n6.2 CoCoA in the Dual\nNext we present results on CoCoA in the dual against competing methods, for an SVM model (9) on the datasets in Table 5. We use stochastic dual coordinate ascent (SDCA) as a local solver for CoCoA in this setting, again selecting the number of local iterations H from several options with best performance. We compare CoCoA to the general methods listed above, including Mb-SGD, GD, L-BFGS, ADMM, and Mb-SDCA. All datasets are distributed by training point for these methods.\nIn analyzing the performance the methods in this setting (Figure 3), we measure the improvement to the primal objective given in (B) (OB(w)) in terms of wall-clock time in seconds. We see again that Mb-SGD and Mb-CD are slow to converge, and come with the additional burden of having to tune extra parameters. ADMM performs the best of the methods other than CoCoA, followed by L-BFGS. However, both are still much slower to converge than CoCoA in the dual. ADMM was in particular affected by the fact that many internal iterations of SDCA were necessary in order to guarantee convergence. In contrast,\nCoCoA is able to incorporate arbitrary amounts of work locally and still converge. We note that although CoCoA, ADMM and Mb-SDCA run in the dual, the plots in Figure 3 mark progress towards the primal objective, OB(w)."}, {"heading": "6.3 Primal vs. Dual", "text": "To understand the effect of primal versus dual optimization for CoCoA, we compare the performance of both variants by fitting an elastic net regression model (7) to two datasets. For comparability of the methods, we use coordinate descent (with closed-form updates) as the local solver in both variants. From the results in Figure 4, we see that CoCoA in the dual tends to perform better on datasets with a large number of training points (relative to the number of features), and that as expected, the performance deteriorates as the strong convexity in the problem disappears. In contrast, CoCoA in the primal performs well on datasets with a large number of features relative to training points, and is robust to changes in strong convexity. These changes in performance are to be expected, as we have already discussed that CoCoA in the primal is more suited for non-strongly convex regularizers (Section 6.1), and that the feature size dominates communication for CoCoA in the dual, as compared to the training point size for CoCoA in the primal (Section 3.4)."}, {"heading": "6.4 General Properties: Effect of Communication", "text": "Finally, we note that in contrast to the compared methods from Sections 6.1 and 6.2, CoCoA comes with the benefit of having only a single parameter to tune: the subproblem approximation quality, \u0398, which we control in our experiments via the number of local subproblem iterations, H, for the example of local coordinate descent. We further explore the effect of this parameter in Figure 5, and provide a general guideline for choosing it in prac-\ntice (see Remark 1). In particular, we see that while increasing H always results in better performance in terms of the number of communication rounds, smaller or larger values of H may result in better performance in terms of wall-clock time, depending on the cost of communication and computation. The flexibility to fine-tune H is one of the reasons for CoCoA\u2019s significant performance gains."}, {"heading": "6.5 Experiment Details", "text": "In this subsection we provide thorough details on the experimental setup and methods used in our comparison. All experiments are run on Amazon EC2 clusters of m3.xlarge machines, with one core per machine. The code for each method is written in Apache Spark, v1.5.0. Our code is open source and publicly available at github.com/gingsmith/proxcocoa.\nADMM. Alternating Direction Method of Multipliers (ADMM) (Boyd et al., 2010) is a popular method that lends itself naturally to the distributed environment. For lasso regression, implementing ADMM for the problems of interest requires solving a large linear system Cx = d on each machine, where C \u2208 Rn\u00d7n with n scaling beyond 107 for the datasets in Table 5, and with C being possibly dense. It is prohibitively slow to solve this directly on each machine, and we therefore employ the iterative method of conjugate gradient with early stopping (see, e.g., Boyd et al., 2010, Section 4.3). For SVM classification, we use stochastic dual coordinate ascent as an internal optimizer, which is shown in Zhang et al. (2012) to have superior performance. We further improve performance by using a varying rather than constant penalty parameter, as suggested in Boyd et al. (2010, Section 3.4.1).\nMini-batch SGD and proximal GD. Mini-batch SGD is a standard and widely used method for parallel and distributed optimization. We use the optimized code provided in Spark\u2019s machine learning library, MLlib, v1.5.0 (Meng et al., 2016). We tune both the size of the mini-batch and the SGD step size using grid search. For lasso, we use the proximal version of the method. Full gradient descent can be seen as a specific setting of mini-batch\nSGD, where the mini-batch size is equal to the total number of training points. We thus also use the implementation in MLlib for full GD, and tune the step size parameter using grid search.\nMini-batch CD and SDCA. Mini-batch CD (for lasso) and SDCA (for SVM) aim to improve mini-batch SGD by employing coordinate descent, which has theoretical and practical justifications (Shalev-Shwartz and Tewari, 2011; Tak\u00e1\u010d et al., 2015; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015; Tak\u00e1\u010d et al., 2013). We implement mini-batch CD and SDCA in Spark and scale the updates made at each round by \u03b2b for mini-batch size b and \u03b2 \u2208 [1, b], tuning both parameters b and \u03b2 via grid search. For the case of lasso regression, we implement Shotgun (Bradley et al., 2011), which is a popular method for parallel optimization. Shotgun can be seen an extreme case of mini-batch CD where the mini-batch is set to K, i.e., there is a single update made by each machine per round. We see in the experiments that communicating this frequently becomes prohibitively slow in the distributed environment.\nOWL-QN. OWN-QN (Yu et al., 2010) is a quasi-Newton method optimized in Spark\u2019s spark.ml package (Meng et al., 2016). Outer iterations of OWL-QN make significant progress towards convergence, but the iterations themselves can be slow because they require processing the entire dataset. CoCoA, the mini-batch methods, and ADMM with early stopping all improve on this by allowing the flexibility of only a subset of the dataset to be processed at each iteration. CoCoA and ADMM have even greater flexibility by allowing internal methods to process the dataset more than once. CoCoA makes this approximation quality explicit, both in theoretical convergence rates and by providing general guidelines for setting the parameter.\nCoCoA. We implement CoCoA with coordinate descent as the local solver. We note that since the framework and theory allow any internal solver to be used, CoCoA could benefit even beyond the results shown, e.g., by using existing fast L1-solvers for the singlemachine case, such as glmnet variants (Friedman et al., 2010) or blitz (Johnson and Guestrin, 2015) or SVM solvers like liblinear (Fan et al., 2008). The only parameter necessary to tune for CoCoA is the level of approximation quality, which we parameterize in the experiments through H, the number of local iterations of the iterative method run locally. Our theory relates local approximation quality to global convergence (Section 4), and we provide a guideline for how to choose this value in practice that links the parameter to the systems environment at hand (Remark 1)."}, {"heading": "7. Related Work", "text": "Single-machine coordinate solvers. For strongly convex regularizers, the current stateof-the-art for empirical loss minimization is randomized coordinate ascent on the dual (SDCA) (Shalev-Shwartz and Zhang, 2013a) and its accelerated variants (e.g., ShalevShwartz and Zhang, 2014). In contrast to primal stochastic gradient descent (SGD) methods, the SDCA family is often preferred as it is free of learning-rate parameters and has faster (geometric) convergence guarantees. Interestingly, a similar trend in coordinate solvers has been observed in the recent literature on the lasso, but with the roles of primal and dual reversed. For those problems, coordinate descent methods on the primal have become state-\nof-the-art, as in glmnet (Friedman et al., 2010) and extensions (Yuan et al., 2012); see, e.g., the overview in Yuan et al. (2010). However, primal-dual convergence rates for unmodified coordinate algorithms have to our knowledge only been obtained for strongly convex regularizers to date (Shalev-Shwartz and Zhang, 2014; Zhang and Lin, 2015).\nCoordinate descent on L1-regularized problems (i.e., (A) with g(\u00b7) = \u03bb\u2016\u00b7\u20161) can be interpreted as the iterative minimization of a quadratic approximation of the smooth part of the objective (as in a one-dimensional Newton step), followed by a shrinkage step resulting from the L1 part. In the single-coordinate update case, this is at the core of glmnet (Friedman et al., 2010; Yuan et al., 2010), and widely used in, e.g., solvers based on the primal formulation of L1-regularized objectives (Shalev-Shwartz and Tewari, 2011; Yuan et al., 2012; Bian et al., 2013; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015). When changing more than one coordinate at a time, again employing a quadratic upper bound on the smooth part, this results in a two-loop method as in glmnet for the special case of logistic regression. This idea is crucial for the distributed setting. When the set of active coordinates coincides with the ones on the local machine, these single-machine approaches closely resemble the distributed framework proposed here.\nParallel methods. For the general regularized loss minimization problems of interest, methods based on stochastic subgradient descent (SGD) are well-established. Several variants of SGD have been proposed for parallel computing, many of which build on the idea of asynchronous communication (Niu et al., 2011; Duchi et al., 2013). Despite their simplicity and competitive performance on shared-memory systems, the downside of this approach in the distributed environment is that the amount of required communication is equal to the amount of data read locally, since one data point is accessed per machine per round (e.g., mini-batch SGD with a batch size of one per worker). These variants are in practice not competitive with the more communication-efficient methods considered in this work, which allow more local updates per communication round.\nFor the specific case of L1-regularized objectives, parallel coordinate descent (with and without using mini-batches) was proposed in Bradley et al. (2011) (Shotgun) and generalized in Bian et al. (2013), and is among the best performing solvers in the parallel setting. Our framework reduces to Shotgun as a special case when the internal solver is a singlecoordinate update on the subproblem (10), \u03b3 = 1, and for a suitable \u03c3\u2032. However, Shotgun is not covered by our convergence theory, since it uses a potentially unsafe upper bound of \u03b2 instead of \u03c3\u2032, which isn\u2019t guaranteed to satisfy our condition for convergence (11). We compare empirically with Shotgun in Section 6 to highlight the detrimental effects of running this high-communication method in the distributed environment.\nOne-shot communication schemes. At the other extreme, there are distributed methods that use only a single round of communication, such as Mann et al. (2009); Zinkevich et al. (2010); Zhang et al. (2013); McWilliams et al. (2014); and Heinze et al. (2016). These methods require additional assumptions on the partitioning of the data, which are usually not satisfied in practice if the data are distributed \u201cas is\u201d, i.e., if we do not have the opportunity to distribute the data in a specific way beforehand. Furthermore, some cannot guarantee convergence rates beyond what could be achieved if we ignored data residing on all but a single computer, as shown in Shamir et al. (2014). Additional relevant lower bounds on\nthe minimum number of communication rounds necessary for a given approximation quality are presented in Balcan et al. (2012) and Arjevani and Shamir (2015).\nMini-batch methods. Mini-batch methods (which use updates from several training points or features per round) are more flexible and lie within the two extremes of parallel and one-shot communication schemes. However, mini-batch versions of both SGD and coordinate descent (CD) (e.g., Tak\u00e1\u010d et al., 2013; Shalev-Shwartz and Zhang, 2013b; Qu et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016) suffer from their convergence rate degrading towards the rate of batch gradient descent as the size of the mini-batch is increased. This follows because mini-batch updates are made based on the outdated previous parameter vector w, in contrast to methods that allow immediate local updates like CoCoA.\nAnother disadvantage of mini-batch methods is that the aggregation parameter is more difficult to tune, as it can lie anywhere in the order of mini-batch size. The optimal choice is often either unknown or too challenging to compute in practice. In the CoCoA framework there is no need to tune parameters, as the aggregation parameter and subproblem parameters can be set directly using the safe bound discussed in Section 3 (Definition 5).\nBatch solvers. ADMM (Boyd et al., 2010), gradient descent, and quasi-Newton methods such as L-BFGS and are also often used in distributed environments because of their relatively low communication requirements. However, they require at least a full (distributed) batch gradient computation at each round, and therefore do not allow the gradual trade-off between communication and computation provided by CoCoA. In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007).\nFinally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods.\nDistributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al. (2011); Yang (2013); Yang et al. (2013) and Lee and Roth (2015), the CoCoA-v1 and CoCoA+ frameworks (which are special cases of the presented framework, CoCoA) are the first to allow the use of any local solver\u2014of weak local approximation quality\u2014in each round in the distributed setting. The practical variant of the DisDCA (Yang, 2013), called DisDCA-p, allows for additive updates in a similar manner to CoCoA, but is restricted to coordinate decent (CD) being the local solver, and was initially proposed without convergence guarantees. DisDCA-p, CoCoA-v1, and CoCoA+ are all limited to strongly convex regularizers, and therefore are not as general as the CoCoA framework discussed in this work.\nIn the L1-regularized setting, an approach related to our framework includes distributed variants of glmnet as in Mahajan et al. (2014). Inspired by glmnet and Yuan et al.\n(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression.\nIf hypothetically each of our quadratic subproblems G\u03c3\u2032k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al. (2012); and Yen et al. (2015) assume that the quadratic subproblems are solved exactly. Therefore, these methods are not able to freely trade off communication and computation. Also, they do not allow the re-use of arbitrary local solvers. On the theoretical side, the convergence rate results provided by Mahajan et al. (2014); Trofimov and Genkin (2014); and Yuan et al. (2012) are not explicit convergence rates but only asymptotic, as the quadratic upper bounds are not explicitly controlled for safety as with our \u03c3\u2032."}, {"heading": "8. Discussion", "text": "To enable large-scale machine learning, we have developed, analyzed, and evaluated a general-purpose framework for communication-efficient primal-dual optimization in the distributed environment. Our framework, CoCoA, takes a unique approach by using duality to derive subproblems for each machine to solve in parallel. These subproblems closely match the global problem of interest, which allows for state-of-the-art single-machine solvers to easily be re-used in the distributed setting. Further, by allowing the local solvers to find solutions of arbitrary approximation quality to the subproblems on each machine, our framework permits a highly flexible communication scheme. In particular, as the local solvers make updates directly to their local parameters, the need to communicate reduces and can be adapted to the system at hand, which helps to manage the communication bottleneck in the distributed setting.\nWe analyzed the impact of the local solver approximation quality and derived global primal-dual convergence rates for our framework that are agnostic to the specifics of the local solvers. We have taken particular care in extending our framework to the case of nonstrongly convex regularizers, where we introduced a bounded-support modification technique to provide robust convergence guarantees. Finally, we demonstrated the efficiency of our framework in an extensive experimental comparison with state-of-the-art distributed solvers. Our framework achieves up to a 50\u00d7 speedup over other widely-used methods on real-world distributed datasets."}, {"heading": "Acknowledgments", "text": "We thank Michael P. Friedlander, Jakub Kone\u010dn\u00fd, and Peter Richt\u00e1rik for their help and for fruitful discussions."}, {"heading": "Appendix A. Convex Conjugates", "text": "The convex conjugate of a function f : Rd \u2192 R is defined as\nf\u2217(v) := max u\u2208Rd v>u\u2212 f(u) . (28)\nBelow we list several useful properties of conjugates (see, e.g., Boyd and Vandenberghe, 2004, Section 3.3.2):\n\u2022 Double conjugate: (f\u2217)\u2217 = f if f is closed and convex.\n\u2022 Value Scaling: (for \u03b1 > 0) f(v) = \u03b1g(v) \u21d2 f\u2217(w) = \u03b1g\u2217(w/\u03b1) .\n\u2022 Argument Scaling: (for \u03b1 6= 0) f(v) = g(\u03b1v) \u21d2 f\u2217(w) = g\u2217(w/\u03b1) .\n\u2022 Conjugate of a separable sum: f(v) = \u2211 i \u03c6i(vi) \u21d2 f\u2217(w) = \u2211 i \u03c6 \u2217 i (wi) .\nLemma 4 (Duality between Lipschitzness and L-Bounded Support, (Rockafellar, 1997, Corollary 13.3.3)). Given a proper convex function f , it holds that f is L-Lipschitz if and only if f\u2217 has L-bounded support.\nLemma 5 (Duality between Smoothness and Strong Convexity, (Hiriart-Urruty and Lemar\u00e9chal, 2001, Theorem 4.2.2)). Given a closed convex function f , it holds that f is \u00b5 strongly convex w.r.t. the norm \u2016 \u00b7 \u2016 if and only if f\u2217 is (1/\u00b5)-smooth w.r.t. the dual norm \u2016 \u00b7 \u2016\u2217."}, {"heading": "Appendix B. Proofs of Primal-Dual Relationships", "text": "In the following subsections we provide derivations of the primal-dual relationship of the general objectives (A) and (B), and then show how to derive the conjugate of the modified L1-norm, as an example of the bounded-support modification introduced in Section 4.\nB.1 Primal-Dual Relationship\nThe relation of our original formulation (A) to its dual formulation (B) is standard in convex analysis, and is a special case of the concept of Fenchel Duality. Using the combination with the linear map A as in our case, the relationship is called Fenchel-Rockafellar Duality, see e.g. Borwein and Zhu (2005, Theorem 4.4.2) or Bauschke and Combettes (2011, Proposition 15.18). For completeness, we illustrate this correspondence with a self-contained derivation of the duality.\nStarting with the original formulation (A), we introduce an auxiliary vector v \u2208 Rd representing v = A\u03b1. Then optimization problem (A) becomes:\nmin \u03b1\u2208Rn\nf(v) + g(\u03b1) such that v = A\u03b1 . (29)\nIntroducing Lagrange multipliers w \u2208 Rd, the Lagrangian is given by:\nL(\u03b1,v;w) := f(v) + g(\u03b1) + w> (A\u03b1\u2212 v) .\nThe dual problem of (A) follows by taking the infimum with respect to both \u03b1 and v:\ninf \u03b1,v L(w,\u03b1,v) = inf v\n{ f(v)\u2212w>v } + inf\n\u03b1\n{ g(\u03b1) + w>A\u03b1 } = \u2212 sup\nv\n{ w>v \u2212 f(v) } \u2212 sup\n\u03b1\n{ (\u2212w>A)\u03b1\u2212 g(\u03b1) } = \u2212f\u2217(w)\u2212 g\u2217(\u2212A>w) . (30)\nWe change signs and turn the maximization of the dual problem (30) into a minimization, thereby arriving at the dual formulation (B) as claimed:\nmin w\u2208Rd\n[ OB(w) := g\u2217(\u2212A>w) + f\u2217(w) ] .\nB.2 Continuous Conjugate Modification for Indicator Functions\nLemma 6 (Conjugate of the modified L1-norm). The convex conjugate of the bounded support modification of the L1-norm, as defined in (18), is:\ng\u0304\u2217i (x) := { 0 : x \u2208 [\u22121, 1], B(|x| \u2212 1) : otherwise,\nand is B-Lipschitz.\nProof. We start by applying the definition of convex conjugate:\ng\u0304i(\u03b1) = sup x\u2208R\n[\u03b1x\u2212 g\u0304\u2217i (x)] .\nWe begin by looking at the case in which \u03b1 \u2265 B; in this case it\u2019s easy to see that when x\u2192 +\u221e, we have:\n\u03b1x\u2212B(|x| \u2212 1) = (\u03b1\u2212B)x\u2212B \u2192 +\u221e ,\nas \u03b1 \u2212 B \u2265 0. The case \u03b1 \u2264 \u2212B holds analogously. We\u2019ll now look at the case \u03b1 \u2208 [0, B]; in this case it is clear we must have x? \u2265 0. It also must hold that x? \u2264 1, since\n\u03b1x\u2212B(x\u2212 1) < \u03b1x ,\nfor every x > 1. Therefore the maximization becomes\ng\u0304i(\u03b1) = sup x\u2208[0,1] \u03b1x ,\nwhich has maximum \u03b1 at x = 1. The remaining \u03b1 \u2208 [\u2212B, 0] case follows in similar fashion. Lipschitz continuity of g\u0304\u2217i follows directly, or alternatively also from the general result that g\u2217i is L-Lipschitz if and only if gi has L-bounded support (Rockafellar, 1997, Corollary 13.3.3) or (D\u00fcnner et al., 2016, Lemma 5)."}, {"heading": "Appendix C. Comparison to ADMM", "text": "Here we derive the comparison of ADMM and CoCoA discussed in Section 3.6, following the line of reasoning in Yang (2013). For consensus ADMM, the objective (B) is decomposed using the following re-parameterization:\nmax w1,...wK ,w K\u2211 k=1 \u2211 i\u2208Pk g\u2217(\u2212x>i wk) + f\u2217(w)\ns.t. wk = w, k = 1, . . . ,K.\nTo solve this problem, we construct the augmented Lagrangian:\nL\u03c1(w1, . . . ,wk,u1, . . . ,uk,w) := K\u2211 k=1 \u2211 i\u2208Pk g\u2217(\u2212x>i wk)\n+ f\u2217(w) + \u03c1 K\u2211 k=1 u>k (wk \u2212w) + \u03c1 2 K\u2211 k=1 \u2016wk \u2212w\u20162 ,\nwhich yields the following decomposable updates:\nw (t) k = arg min\nwk\n\u2211 i\u2208Pk g\u2217(\u2212x>i wk) + \u03c1 2 \u2016wk \u2212w(t\u22121) + u (t\u22121) k \u2016 2,\nw(t) = arg min w f\u2217(w) + \u03c1 K\u2211 k=1 u>k (wk \u2212w) + \u03c1 2 K\u2211 k=1 \u2016wk \u2212w\u20162,\nu (t) k = u (t\u22121) k + w (t) k \u2212w (t).\nTo compare this to the proposed framework, recall that the subproblem (10) (excluding the extraneous term f(v)) can be written as:\nmin \u03b1[k]\u2208Rn \u2211 i\u2208Pk gi(\u03b1[k]i) + w >A\u03b1[k] + \u03c3\u2032 2\u03c4 \u2225\u2225\u2225A[k]\u03b1[k]\u2225\u2225\u22252. We can further reformulate by completing the square:\nmin \u03b1[k]\u2208Rn \u2211 i\u2208Pk gi((\u03b1[k])i) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225 w + \u03c3\u2032 \u03c4 A[k]\u03b1[k] \u2225\u2225\u22252. Assuming for the time being that f(\u00b7) = 12\u2016 \u00b7 \u2016 2 2 such that w = \u2207f(v) = v, we can unroll\nthe update as follows, using \u03b3\u2206v(t\u22121) = \u03b3 \u2211K\ni=1 \u2206v (t\u22121) k :\nmin \u03b1[k]\u2208Rn \u2211 i\u2208Pk gi((\u03b1[k])i) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225 w(t\u22121) + \u03b3\u2206v(t\u22121) + \u03c3\u2032 \u03c4 A[k]\u03b1[k] \u2225\u2225\u22252. We will show that the above objective has the following primal form for each machine k:\nmin w \u2211 i\u2208Pk g\u2217i (\u2212x>i w) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225w \u2212 (w(t\u22121) + \u03b3\u2206v(t\u22121))\u2225\u2225\u22252. (31)\nIndeed, suppressing the subscript k for simplicity, we have:\nmin w \u2211 i g\u2217i (\u2212x>i w) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225w \u2212 (w(t\u22121) + \u03b3\u2206v(t\u22121))\u2225\u2225\u22252 = min\nw \u2211 i max \u03b1i \u2212x>i w\u03b1i \u2212 gi(\u03b1i) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225w \u2212 (w(t\u22121) + \u03b3\u2206v(t\u22121))\u2225\u2225\u22252 = max\n\u03b1 min w \u2211 i \u2212x>i w\u03b1i \u2212 gi(\u03b1i) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225w \u2212 (w(t\u22121) + \u03b3\u2206v(t\u22121))\u2225\u2225\u22252. Solving the minimization yields: w = wt\u22121 +\u03b3\u2206v(t\u22121) + \u03c3 \u2032\n\u03c4 A\u03b1. Plugging this back in yields:\n= max \u03b1 \u2211 i \u2212gi(\u03b1i)\u2212 (A\u03b1)>w(t\u22121) \u2212 (A\u03b1)>\u03b3\u2206v(t\u22121) \u2212 \u03c3\u2032 \u03c4 \u2016A\u03b1\u20162 + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225\u03c3\u2032 \u03c4 A\u03b1 \u2225\u2225\u22252\n= max \u03b1 \u2211 i \u2212gi(\u03b1i)\u2212 (A\u03b1)>w(t\u22121) \u2212 (A\u03b1)>\u03b3\u2206v(t\u22121) \u2212 \u03c3\u2032 2\u03c4 \u2016A\u03b1\u20162\n= min \u03b1 \u2211 i gi(\u03b1i) + (A\u03b1) >w(t\u22121) + (A\u03b1)>\u03b3\u2206v(t\u22121) + \u03c3\u2032 2\u03c4 \u2016A\u03b1\u20162\n= min \u03b1 \u2211 i gi(\u03b1i) + \u03c4 2\u03c3\u2032 \u2225\u2225\u2225 w(t\u22121) + \u03b3\u2206v(t\u22121) + \u03c3\u2032 \u03c4 A\u03b1 \u2225\u2225\u22252."}, {"heading": "Appendix D. Convergence Proofs", "text": "In this section we provide proofs of our main convergence results. The arguments follow the reasoning in Ma et al. (2015b,a), but where we have generalized them to be applicable directly to (A). We provide full details of Lemma 1 as a proof of concept, but omit details in later proofs that can be derived using the arguments in Ma et al. (2015b) or earlier work of Shalev-Shwartz and Zhang (2013a), and instead outline the proof strategy and highlight sections where the theory deviates.\nD.1 Approximation of OA(\u00b7) by the Local Subproblems G\u03c3 \u2032 k (\u00b7)\nOur first lemma in the overall proof of convergence helps to relate progress on the local subproblems to the global objective OA(\u00b7).\nLemma\u2019 1. For any dual variables \u03b1,\u2206\u03b1 \u2208 Rn, v = v(\u03b1) := A\u03b1, and real values \u03b3, \u03c3\u2032 satisfying (11), it holds that\nOA ( \u03b1 + \u03b3 K\u2211 k=1 \u2206\u03b1[k] ) \u2264 (1\u2212 \u03b3)OA(\u03b1) + \u03b3 K\u2211 k=1 G\u03c3\u2032k (\u2206\u03b1[k];v,\u03b1[k]) . (32)\nProof. In this proof we follow the line of reasoning in Ma et al. (2015b, Lemma 4) with a more general (1/\u03c4) smoothness assumption on f(\u00b7). An outer iteration of CoCoA performs\nthe following update:\nOA(\u03b1 + \u03b3 K\u2211 k=1 \u2206\u03b1[k]) = f(v(\u03b1 + \u03b3 K\u2211 k=1\n\u2206\u03b1[k]))\ufe38 \ufe37\ufe37 \ufe38 A\n+ n\u2211 i=1 gi(\u03b1i + \u03b3( K\u2211 k=1\n\u2206\u03b1[k])i)\ufe38 \ufe37\ufe37 \ufe38 B\n. (33)\nWe bound A and B separately. First we bound A using (1/\u03c4)-smoothness of f :\nA = f ( v(\u03b1 + \u03b3 K\u2211 k=1 \u2206\u03b1[k]) ) = f ( v(\u03b1) + \u03b3 K\u2211 k=1 v(\u2206\u03b1[k]) )\nsmoothness of f as in (3) \u2264 f(v(\u03b1)) + K\u2211 k=1 \u03b3\u2207f(v(\u03b1))>v(\u2206\u03b1[k]) + \u03b32 2\u03c4 \u2016 K\u2211 k=1 v(\u03b1[k])\u20162\ndefinition of w as in (5) \u2264 f(v(\u03b1)) + K\u2211 k=1 \u03b3v(\u2206\u03b1[k]) >w(\u03b1) + \u03b32 2\u03c4 \u2016 K\u2211 k=1 v(\u03b1[k])\u20162\nsafe choice of \u03c3\u2032 as in (11) \u2264 f(v(\u03b1)) + K\u2211 k=1 \u03b3v(\u2206\u03b1[k]) >w(\u03b1) + 1 2\u03c4 \u03b3\u03c3\u2032 K\u2211 k=1 \u2016v(\u03b1[k])\u20162 .\nNext we use Jensen\u2019s inequality to bound B:\nB = K\u2211 k=1 \u2211 i\u2208Pk gi(\u03b1i + \u03b3(\u2206\u03b1[k])i)  = K\u2211 k=1 \u2211 i\u2208Pk gi((1\u2212 \u03b3)\u03b1i + \u03b3(\u03b1 + \u2206\u03b1[k])i)  \u2264\nK\u2211 k=1 \u2211 i\u2208Pk (1\u2212 \u03b3)gi(\u03b1i) + \u03b3gi(\u03b1i + \u2206\u03b1[k]i)  . Plugging A and B back into (33) yields:\nOA ( \u03b1 + \u03b3 K\u2211 k=1 \u2206\u03b1[k] ) \u2264 f(v(\u03b1))\u00b1 \u03b3f(v(\u03b1)) + K\u2211 k=1 \u03b3v(\u2206\u03b1[k]) >w(\u03b1) + 1 2\u03c4 \u03b3\u03c3\u2032 K\u2211 k=1 \u2016v(\u03b1[k])\u20162\n+ K\u2211 k=1 \u2211 i\u2208Pk (1\u2212 \u03b3)gi(\u03b1i) + \u03b3gi(\u03b1i + \u2206\u03b1[k]i)\n= (1\u2212 \u03b3)f(v(\u03b1)) + K\u2211 k=1 \u2211 i\u2208Pk (1\u2212 \u03b3)gi(\u03b1i)  \ufe38 \ufe37\ufe37 \ufe38\n(1\u2212\u03b3)OA(\u03b1)\n+ \u03b3 K\u2211 k=1  1 K f(v(\u03b1)) + v(\u2206\u03b1[k]) >w(\u03b1) + \u03c3\u2032 2\u03c4 \u2016v(\u03b1[k])\u20162 + \u2211 i\u2208Pk gi(\u03b1i + \u2206\u03b1[k]i)  (10) = (1\u2212 \u03b3)OA(\u03b1) + \u03b3\nK\u2211 k=1 G\u03c3\u2032k (\u2206\u03b1[k];v) ,\nwhere the last equality is by the definition of the subproblem objective G\u03c3\u2032k (.) as in (10).\nD.2 Proof of Main Convergence Result (Theorem 2)\nBefore proving the main convergence results, we introduce several useful quantities, and establish the following lemma, which characterizes the effect of iterations of Algorithm 1 on the duality gap for any chosen local solver of approximation quality \u0398.\nLemma 7. Let gi be strongly convex 2 with convexity parameter \u00b5 \u2265 0 with respect to the norm \u2016 \u00b7 \u2016, \u2200i \u2208 [n]. Then at each iteration of Algorithm 1 under Assumption 1, and any s \u2208 [0, 1], it holds that\nE[OA(\u03b1(t))\u2212OA(\u03b1(t+1))] \u2265 \u03b3(1\u2212\u0398) ( sG(\u03b1(t))\u2212 \u03c3 \u2032s2\n2\u03c4 R(t)\n) , (34)\nwhere\nR(t) := \u2212 \u03c4\u00b5(1\u2212s)\u03c3\u2032s \u2016u (t) \u2212\u03b1(t)\u20162 + \u2211K k=1\u2016A[k](u(t) \u2212\u03b1(t))[k]\u20162 , (35)\nfor u(t) \u2208 Rn with\nu (t) i \u2208 \u2202g \u2217 i (\u2212x>i w(\u03b1(t))) . (36)\nProof. This proof is motivated by Shalev-Shwartz and Zhang (2013a, Lemma 19) and follows Ma et al. (2015b, Lemma 5), with a difference being the extension to our generalized subproblems G\u03c3\u2032k (\u00b7;v,\u03b1[k]) along with the mappings w(\u03b1) := \u2207f(v(\u03b1)) with v(\u03b1) := A\u03b1.\nFor simplicity, we write \u03b1 instead of \u03b1(t), v instead of v(\u03b1(t)), w instead of w(\u03b1(t)) and u instead of u(t). We can estimate the expected change of the objective OA(\u03b1) as follows. Starting from the definition of the update \u03b1(t+1) := \u03b1(t) + \u03b3 \u2211 k \u2206\u03b1[k] from Algorithm 1, we apply Lemma 1, which relates the local approximation G\u03c3\u2032k (\u03b1;v,\u03b1[k]) to the global objective OA(\u03b1), and then bound this using the notion of quality of the local solver (\u0398), as in Assumption 1. This gives us:\nE [ OA(\u03b1(t))\u2212OA(\u03b1(t+1)) ] = E [ OA(\u03b1)\u2212OA ( \u03b1 + \u03b3 K\u2211 k=1 \u2206\u03b1[k] )]\n\u2265 \u03b3(1\u2212\u0398) OA(\u03b1)\u2212 K\u2211 k=1\nG\u03c3\u2032k (\u2206\u03b1?[k];v,\u03b1[k])\ufe38 \ufe37\ufe37 \ufe38 C\n . (37)\nWe next upper bound the C term, denoting \u2206\u03b1? = \u2211K\nk=1 \u2206\u03b1 ? [k]. We first plug in the\ndefinition of the objective OA in (A) and the local subproblems (10), and then substitute\n2. Note that the case of weakly convex gi(.) is explicitly allowed here as well, as the Lemma holds for the case \u00b5 = 0.\ns(ui \u2212 \u03b1i) for \u2206\u03b1?i and apply the \u00b5-strong convexity of the gi terms. This gives us:\nC = n\u2211 i=1 (gi(\u03b1i)\u2212 gi(\u03b1i + \u2206\u03b1?i ))\u2212 (A\u2206\u03b1?)>w(\u03b1)\u2212 K\u2211 k=1 \u03c3\u2032 2\u03c4 \u2225\u2225\u2225A[k]\u2206\u03b1?[k]\u2225\u2225\u22252 \u2265\nn\u2211 i=1 ( sgi(\u03b1i)\u2212 sgi(ui) + \u00b5 2 (1\u2212 s)s(ui \u2212 \u03b1i)2 ) \u2212A(s(u\u2212\u03b1))>w(\u03b1)\u2212\nK\u2211 k=1 \u03c3\u2032 2\u03c4 \u2225\u2225\u2225A[k](s(u\u2212\u03b1)[k])\u2225\u2225\u22252 . (38) From the definition of the optimization problems (A) and (B), and definition of convex\nconjugates, we can write the duality gap as:\nG(\u03b1) := OA(\u03b1)\u2212 (\u2212OB(w(\u03b1)) (A),(B) = n\u2211 i=1 ( g\u2217i (\u2212x>i w(\u03b1)) + gi(\u03b1i) ) + f\u2217(w(\u03b1)) + f(A\u03b1))\n= n\u2211 i=1 ( g\u2217i (\u2212x>i w(\u03b1)) + gi(\u03b1i) ) + f\u2217(\u2207f(A\u03b1)) + f(A\u03b1)\n= n\u2211 i=1 ( g\u2217i (\u2212x>i w(\u03b1)) + gi(\u03b1i) ) + (A\u03b1)>w(\u03b1)\n= n\u2211 i=1 ( g\u2217i (\u2212x>i w(\u03b1)) + gi(\u03b1i) + \u03b1ix>i w(\u03b1) ) . (39)\nThe convex conjugate maximal property from (36) implies that\ngi(ui) = ui(\u2212x>i w(\u03b1))\u2212 g\u2217i (\u2212x>i w(\u03b1)) . (40)\nUsing (40) and (39), we therefore have:\nC (40) \u2265 n\u2211 i=1 ( sgi(\u03b1i)\u2212 sui(\u2212x>i w(\u03b1)) + sg\u2217i (\u2212x>i w(\u03b1)) + \u00b5 2 (1\u2212 s)s(ui \u2212 \u03b1i)2 ) \u2212A(s(u\u2212\u03b1))>w(\u03b1)\u2212\nK\u2211 k=1 \u03c3\u2032 2\u03c4 \u2225\u2225\u2225A[k](s(u\u2212\u03b1)[k])\u2225\u2225\u22252 =\nn\u2211 i=1 [ sgi(\u03b1i) + sg \u2217 i (\u2212x>i w(\u03b1)) + sx>i w(\u03b1)\u03b1i ] \u2212 n\u2211 i=1 [ sx>i w(\u03b1)(\u03b1i \u2212 ui)\u2212 \u00b5 2 (1\u2212 s)s(ui \u2212 \u03b1i)2 ] \u2212A(s(u\u2212\u03b1))>w(\u03b1)\u2212\nK\u2211 k=1 \u03c3\u2032 2\u03c4 \u2225\u2225\u2225A[k](s(u\u2212\u03b1)[k])\u2225\u2225\u22252 (39) = sG(\u03b1) + \u00b5\n2 (1\u2212 s)s\u2016u\u2212\u03b1\u20162 \u2212 \u03c3\n\u2032s2\n2\u03c4 K\u2211 k=1 \u2016A[k](u\u2212\u03b1)[k]\u20162 . (41)\nThe claimed improvement bound (34) then follows by plugging (41) into (37).\nThe following Lemma provides a uniform bound on R(t):\nLemma 8. If g\u2217i are L-Lipschitz continuous for all i \u2208 [n], then\n\u2200t : R(t) \u2264 4L2 K\u2211 k=1\n\u03c3knk\ufe38 \ufe37\ufe37 \ufe38 =:\u03c3\n, (42)\nwhere\n\u03c3k := max \u03b1[k]\u2208Rn\n\u2016A[k]\u03b1[k]\u20162\n\u2016\u03b1[k]\u20162 . (43)\nProof. (Ma et al., 2015b, Lemma 6). For general convex functions, the strong convexity parameter is \u00b5 = 0, and hence the definition (35) of the complexity constant R(t) becomes\nR(t) = K\u2211 k=1 \u2016A[k](u(t) \u2212\u03b1(t))[k]\u20162 (43) \u2264 K\u2211 k=1 \u03c3k\u2016(u(t) \u2212\u03b1(t))[k]\u20162 \u2264 K\u2211 k=1 \u03c3k|Pk|4L2 .\nHere the last inequality follows from (Shalev-Shwartz and Zhang, 2013a, Lemma 21), which shows that for g\u2217i : R\u2192 R being L-Lipschitz, it holds that for any real value a with |a| > L one has that gi(a) = +\u221e.\nRemark 5. (Ma et al., 2015b, Remark 7) If the data points xi are normalized such that \u2016xi\u2016 \u2264 1, \u2200i \u2208 [n], then \u03c3k \u2264 |Pk| = nk. Furthermore, if we assume that the data partition is balanced, i.e., that nk = n/K for all k, then \u03c3 \u2264 n2/K. This can be used to bound the constants R(t), above, as R(t) \u2264 4L2n2K .\nTheorem 9. Consider Algorithm 1, using a local solver of quality \u0398 (See Assumption 1). Let g\u2217i (\u00b7) be L-Lipschitz continuous, and G > 0 be the desired duality gap (and hence an upper-bound on suboptimality OA). Then after T iterations, where\nT \u2265 T0 + max{ \u2308 1 \u03b3(1\u2212\u0398) \u2309 ,\n4L2\u03c3\u03c3\u2032\n\u03c4 G\u03b3(1\u2212\u0398) } , (44)\nT0 \u2265 t0 + [ 2 \u03b3(1\u2212\u0398) ( 8L2\u03c3\u03c3\u2032 \u03c4 G \u2212 1 )] + , t0 \u2265 max(0, \u2308 1 \u03b3(1\u2212\u0398) log ( \u03c4(OA(\u03b1(0))\u2212OA(\u03b1?)) 2L2\u03c3\u03c3\u2032 )\u2309 ) ,\nwe have that the expected duality gap satisfies\nE[OA(\u03b1)\u2212 (\u2212OB(w(\u03b1)))] \u2264 G\nat the averaged iterate \u03b1 := 1T\u2212T0 \u2211T\u22121 t=T0+1 \u03b1(t) . (45)\nProof. We begin by estimating the expected change of feasibility for OA. We can bound this above by using Lemma 7 and the fact that the OB(\u00b7) is always a lower bound for \u2212OA(\u00b7), and then applying (42) to find:\nE[OA(\u03b1(t+1))\u2212OA(\u03b1?)] \u2264 (1\u2212 \u03b3(1\u2212\u0398)s) (OA(\u03b1(t))\u2212OA(\u03b1?)) + \u03b3(1\u2212\u0398)\u03c3 \u2032s2\n2\u03c4 4L 2\u03c3 . (46)\nUsing (46) recursively we have\nE[OA(\u03b1(t))\u2212OA(\u03b1?)] \u2264 (1\u2212 \u03b3(1\u2212\u0398)s)t (OA(\u03b1(0))\u2212OA(\u03b1?)) + s 4L2\u03c3\u03c3\u2032\n2\u03c4 . (47)\nChoosing s = 1 and t = t0 := max{0, d 1\u03b3(1\u2212\u0398) log(2(OA(\u03b1 (0))\u2212OA(\u03b1?))/(4L2\u03c3\u03c3\u2032))e} leads to\nE[OA(\u03b1(t))\u2212OA(\u03b1?)] \u2264 (1\u2212 \u03b3(1\u2212\u0398))t0 (OA(\u03b1(0))\u2212OA(\u03b1?)) + 4L2\u03c3\u03c3\u2032\n2\u03c4 \u2264 4L\n2\u03c3\u03c3\u2032 \u03c4 .\n(48)\nNext, we show inductively that\n\u2200t \u2265 t0 : E[OA(\u03b1(t))\u2212OA(\u03b1?)] \u2264 4L2\u03c3\u03c3\u2032\n\u03c4(1 + 12\u03b3(1\u2212\u0398)(t\u2212 t0)) . (49)\nClearly, (48) implies that (49) holds for t = t0. Assuming that it holds for any t \u2265 t0, we show that it must also hold for t+ 1. Indeed, using\ns = 1\n1 + 12\u03b3(1\u2212\u0398)(t\u2212 t0) \u2208 [0, 1] , (50)\nwe obtain\nE[OA(\u03b1(t+1))\u2212OA(\u03b1?)] \u2264 4L2\u03c3\u03c3\u2032\n\u03c4\n( 1 + 12\u03b3(1\u2212\u0398)(t\u2212 t0)\u2212 1 2\u03b3(1\u2212\u0398)\n(1 + 12\u03b3(1\u2212\u0398)(t\u2212 t0))2 ) \ufe38 \ufe37\ufe37 \ufe38\nD\nby applying the bounds (46) and (49), plugging in the definition of s (50), and simplifying. We upper bound the term D using the fact that geometric mean is less or equal to arithmetic mean:\nD = 1 1 + 12\u03b3(1\u2212\u0398)(t+ 1\u2212 t0) (1 + 12\u03b3(1\u2212\u0398)(t+ 1\u2212 t0))(1 + 1 2\u03b3(1\u2212\u0398)(t\u2212 1\u2212 t0))\n(1 + 12\u03b3(1\u2212\u0398)(t\u2212 t0))2\ufe38 \ufe37\ufe37 \ufe38 \u22641\n\u2264 1 1 + 12\u03b3(1\u2212\u0398)(t+ 1\u2212 t0) .\nIf \u03b1 is defined as (45), we apply the results of Lemma 7 and Lemma 8 to obtain\nE[G(\u03b1)] = E G T\u22121\u2211 t=T0 1 T\u2212T0\u03b1 (t)  \u2264 1T\u2212T0E T\u22121\u2211 t=T0 G ( \u03b1(t) ) \u2264 1 \u03b3(1\u2212\u0398)s 1 T \u2212 T0 E [ OA(\u03b1(T0))\u2212OA(\u03b1?) ] + 4L 2\u03c3\u03c3\u2032s 2\u03c4 . (51)\nIf T \u2265 d 1\u03b3(1\u2212\u0398)e+ T0 such that T0 \u2265 t0 we have\nE[G(\u03b1)] (51),(49) \u2264 1 \u03b3(1\u2212\u0398)s 1 T \u2212 T0\n( 4L2\u03c3\u03c3\u2032\n\u03c4(1 + 12\u03b3(1\u2212\u0398)(T0 \u2212 t0))\n) + 4L2\u03c3\u03c3\u2032s\n2\u03c4\n= 4L2\u03c3\u03c3\u2032\n\u03c4\n( 1\n\u03b3(1\u2212\u0398)s 1 T \u2212 T0 1 1 + 12\u03b3(1\u2212\u0398)(T0 \u2212 t0) + s 2\n) . (52)\nChoosing\ns = 1\n(T \u2212 T0)\u03b3(1\u2212\u0398) \u2208 [0, 1] (53)\ngives us\nE[G(\u03b1)] (52),(53) \u2264 4L 2\u03c3\u03c3\u2032\n\u03c4\n( 1\n1 + 12\u03b3(1\u2212\u0398)(T0 \u2212 t0) +\n1 (T \u2212 T0)\u03b3(1\u2212\u0398) 1 2\n) . (54)\nTo have right hand side of (54) smaller then G it is sufficient to choose T0 and T such that\n4L2\u03c3\u03c3\u2032\n\u03c4\n( 1\n1 + 12\u03b3(1\u2212\u0398)(T0 \u2212 t0)\n) \u2264 1\n2 G , (55)\n4L2\u03c3\u03c3\u2032\n\u03c4\n( 1\n(T \u2212 T0)\u03b3(1\u2212\u0398) 1 2\n) \u2264 1\n2 G . (56)\nHence if T0 \u2265 t0 + 2\u03b3(1\u2212\u0398) ( 8L2\u03c3\u03c3\u2032 \u03c4 G \u2212 1 ) and T \u2265 T0 + 4L 2\u03c3\u03c3\u2032\n\u03c4 G\u03b3(1\u2212\u0398) then (55) and (56) are satisfied.\nThe following main theorem simplifies the results of Theorem 9 and is a generalization of Ma et al. (2015b, Corollary 9) for general f\u2217(\u00b7) functions: Theorem\u2019 2. Consider Algorithm 1 with \u03b3 := 1, using a local solver of quality \u0398 (see Assumption 1). Let g\u2217i (\u00b7) be L-Lipschitz continuous, and assume that the columns of A satisfy \u2016xi\u2016 \u2264 1, \u2200i \u2208 [n]. Let G > 0 be the desired duality gap (and hence an upper-bound on primal sub-optimality). Then after T iterations, where\nT \u2265 T0 + max{ \u2308 1\n1\u2212\u0398\n\u2309 ,\n4L2n2\n\u03c4 G(1\u2212\u0398) } , (57)\nT0 \u2265 t0 + [ 2\n1\u2212\u0398\n( 8L2n2 \u03c4 G \u2212 1 )] + ,\nt0 \u2265 max(0, \u2308 1 (1\u2212\u0398) log ( \u03c4(OA(\u03b1(0))\u2212OA(\u03b1?)) 2L2Kn )\u2309 ) ,\nwe have that the expected duality gap satisfies\nE[OA(\u03b1)\u2212 (\u2212OB(w(\u03b1)))] \u2264 G ,\nwhere \u03b1 is the averaged iterate returned by Algorithm 1.\nProof. Plug in parameters \u03b3 := 1, \u03c3\u2032 := \u03b3K = K to the results of Theorem 9, and note that for balanced datasets we have \u03c3 \u2264 n2K (see Remark 5). We can further simplify the rate by noting that \u03c4 = 1 for the 1-smooth losses (least squares and logistic) given as examples in this work.\nD.3 Proof of Convergence Result for Strongly Convex gi\nOur second main theorem follows reasoning in Shalev-Shwartz and Zhang (2013a) and is a generalization of Ma et al. (2015b, Corollary 11). We first introduce a lemma to simplify the proof.\nLemma 10. Assume that gi(0) \u2208 [0, 1] for all i \u2208 [n], then for the zero vector \u03b1(0) := 0 \u2208 Rn, we have\nOA(\u03b1(0))\u2212OA(\u03b1?) = OA(0)\u2212OA(\u03b1?) \u2264 n . (58)\nProof. For \u03b1 := 0 \u2208 Rn, we have w(\u03b1) = A\u03b1 = 0 \u2208 Rd. Therefore, since the dual \u2212OA(\u00b7) is always a lower bound on the primal OB(\u00b7), and by definition of the objective OA given in (A),\n0 \u2264 OA(\u03b1)\u2212OA(\u03b1?) \u2264 OA(\u03b1)\u2212 (\u2212OB(w(\u03b1))) (A) \u2264 n .\nTheorem 11. Assume that gi are \u00b5-strongly convex \u2200i \u2208 [n]. We define \u03c3max = maxk\u2208[K] \u03c3k. Then after T iterations of Algorithm 1, with\nT \u2265 1\u03b3(1\u2212\u0398) \u00b5\u03c4+\u03c3max\u03c3\u2032\n\u00b5\u03c4 log n OA ,\nit holds that E[OA(\u03b1(T ))\u2212OA(\u03b1?)] \u2264 OA .\nFurthermore, after T iterations with\nT \u2265 1\u03b3(1\u2212\u0398) \u00b5\u03c4+\u03c3max\u03c3\u2032 \u00b5\u03c4 log ( 1 \u03b3(1\u2212\u0398) \u00b5\u03c4+\u03c3max\u03c3\u2032 \u00b5\u03c4 n G ) ,\nwe have the expected duality gap\nE[OA(\u03b1(T ))\u2212 (\u2212OB(w(\u03b1(T ))))] \u2264 G .\nProof. Given that gi(.) is \u00b5-strongly convex with respect to the \u2016 \u00b7 \u2016 norm, we can apply (35) and the definition of \u03c3k to find:\nR(t) \u2264 \u2212 \u03c4\u00b5(1\u2212s)\u03c3\u2032s \u2016u (t) \u2212\u03b1(t)\u20162 + \u2211K k=1 \u03c3k\u2016u(t) \u2212\u03b1 (t) [k]\u2016 2\n\u2264 ( \u2212 \u03c4\u00b5(1\u2212s)\u03c3\u2032s + \u03c3max ) \u2016u(t) \u2212\u03b1(t)\u20162 , (59)\nwhere \u03c3max = maxk\u2208[K] \u03c3k. If we plug the following value of s\ns = \u03c4\u00b5\n\u03c4\u00b5+ \u03c3max\u03c3\u2032 \u2208 [0, 1] (60)\ninto (59) we obtain that \u2200t : R(t) \u2264 0. Putting the same s into (34) will give us\nE[OA(\u03b1(t))\u2212OA(\u03b1(t+1))] (34),(60) \u2265 \u03b3(1\u2212\u0398) \u03c4\u00b5\n\u03c4\u00b5+ \u03c3max\u03c3\u2032 G(\u03b1(t))\n\u2265 \u03b3(1\u2212\u0398) \u03c4\u00b5 \u03c4\u00b5+ \u03c3max\u03c3\u2032 (OA(\u03b1(t))\u2212OA(\u03b1?)) . (61)\nUsing the fact that E[OA(\u03b1(t))\u2212OA(\u03b1(t+1))] = E[OA(\u03b1?)\u2212OA(\u03b1(t+1))]+OA(\u03b1(t))\u2212OA(\u03b1?) we have\nE[OA(\u03b1?)\u2212OA(\u03b1(t+1))] +OA(\u03b1(t))\u2212OA(\u03b1?) (61) \u2265 \u03b3(1\u2212\u0398) \u03c4\u00b5\n\u03c4\u00b5+ \u03c3max\u03c3\u2032 (OA(\u03b1(t))\u2212OA(\u03b1?)) ,\nwhich is equivalent to E[OA(\u03b1(t+1))\u2212OA(\u03b1?)] \u2264 (\n1\u2212 \u03b3(1\u2212\u0398) \u03c4\u00b5 \u03c4\u00b5+ \u03c3max\u03c3\u2032\n) (OA(\u03b1(t))\u2212OA(\u03b1?)) . (62)\nTherefore if we denote (t)OA = OA(\u03b1 (t))\u2212OA(\u03b1?) we have recursively that\nE[ (t)OA ] (62) \u2264 ( 1\u2212 \u03b3(1\u2212\u0398) \u03c4\u00b5 \u03c4\u00b5+ \u03c3max\u03c3\u2032 )t (0) OA (58) \u2264 ( 1\u2212 \u03b3(1\u2212\u0398) \u03c4\u00b5 \u03c4\u00b5+ \u03c3max\u03c3\u2032 )t n\n\u2264 exp ( \u2212t\u03b3(1\u2212\u0398) \u03c4\u00b5\n\u03c4\u00b5+ \u03c3max\u03c3\u2032\n) n .\nThe right hand side will be smaller than some OA if\nt \u2265 1 \u03b3(1\u2212\u0398)\n\u03c4\u00b5+ \u03c3max\u03c3 \u2032\n\u03c4\u00b5 log\nn OA .\nMoreover, to bound the duality gap, we have\n\u03b3(1\u2212\u0398) \u03c4\u00b5 \u03c4\u00b5+ \u03c3max\u03c3\u2032 G(\u03b1(t)) (61) \u2264 E[OA(\u03b1(t))\u2212OA(\u03b1(t+1))] \u2264 E[OA(\u03b1(t))\u2212OA(\u03b1?)] .\nThus, G(\u03b1(t)) \u2264 1\u03b3(1\u2212\u0398) \u03c4\u00b5+\u03c3max\u03c3\u2032 \u03c4\u00b5 (t) OA . Hence if OA \u2264 \u03b3(1\u2212\u0398) \u03c4\u00b5 \u03c4\u00b5+\u03c3max\u03c3\u2032\nG then G(\u03b1(t)) \u2264 G. Therefore after\nt \u2265 1 \u03b3(1\u2212\u0398)\n\u03c4\u00b5+ \u03c3max\u03c3 \u2032\n\u03c4\u00b5 log\n( 1\n\u03b3(1\u2212\u0398) \u03c4\u00b5+ \u03c3max\u03c3\n\u2032\n\u03c4\u00b5\nn\nG ) iterations we have obtained a duality gap less than G.\nTheorem\u2019 3. Consider Algorithm 1 with \u03b3 := 1, using a local solver of quality \u0398 (see Assumption 1). Let gi(\u00b7) be \u00b5-strongly convex, \u2200i \u2208 [n], and assume that the columns of A satisfy \u2016xi\u2016 \u2264 1 \u2200i \u2208 [n]. Then we have that T iterations are sufficient for suboptimality OA, with\nT \u2265 1\u03b3(1\u2212\u0398) \u03c4\u00b5+n \u03c4\u00b5 log n OA .\nFurthermore, after T iterations with\nT \u2265 1\u03b3(1\u2212\u0398) \u03c4\u00b5+n \u03c4\u00b5 log\n( 1\n\u03b3(1\u2212\u0398) \u03c4\u00b5+n \u03c4\u00b5 n G\n) ,\nwe have the expected duality gap\nE[OA(\u03b1(T ))\u2212 (\u2212OB(w(\u03b1(T ))))] \u2264 G .\nProof. Plug in parameters \u03b3 := 1, \u03c3\u2032 := \u03b3K = K to the results of Theorem 11 and note that for balanced datasets we have \u03c3max \u2264 nK (see Remark 5). We can further simplify the rate by noting that \u03c4 = 1 for the 1-smooth losses (least squares and logistic) given as examples in this work."}], "references": [{"title": "Scalable training of L1-regularized log-linear models", "author": ["G. Andrew", "J. Gao"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Andrew and Gao.,? \\Q2007\\E", "shortCiteRegEx": "Andrew and Gao.", "year": 2007}, {"title": "Communication complexity of distributed convex learning and optimization", "author": ["Y. Arjevani", "O. Shamir"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Arjevani and Shamir.,? \\Q2015\\E", "shortCiteRegEx": "Arjevani and Shamir.", "year": 2015}, {"title": "Distributed learning, communication complexity and privacy", "author": ["M.-F. Balcan", "A. Blum", "S. Fine", "Y. Mansour"], "venue": "In Conference on Learning Theory,", "citeRegEx": "Balcan et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Balcan et al\\.", "year": 2012}, {"title": "Convex Analysis and Monotone Operator Theory in Hilbert Spaces", "author": ["H.H. Bauschke", "P.L. Combettes"], "venue": "Springer Science & Business Media,", "citeRegEx": "Bauschke and Combettes.,? \\Q2011\\E", "shortCiteRegEx": "Bauschke and Combettes.", "year": 2011}, {"title": "Parallel and Distributed Computation: Numerical Methods", "author": ["D.P. Bersekas", "J.N. Tsitsiklis"], "venue": null, "citeRegEx": "Bersekas and Tsitsiklis.,? \\Q1989\\E", "shortCiteRegEx": "Bersekas and Tsitsiklis.", "year": 1989}, {"title": "Parallel coordinate descent Newton method for efficient `1-regularized minimization", "author": ["Y. Bian", "X. Li", "Y. Liu", "M.-H. Yang"], "venue": "arXiv.org,", "citeRegEx": "Bian et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bian et al\\.", "year": 2013}, {"title": "Convex Optimization", "author": ["S. Boyd", "L. Vandenberghe"], "venue": null, "citeRegEx": "Boyd and Vandenberghe.,? \\Q2004\\E", "shortCiteRegEx": "Boyd and Vandenberghe.", "year": 2004}, {"title": "Distributed optimization and statistical learning via the alternating direction method of multipliers", "author": ["S. Boyd", "N. Parikh", "E. Chu", "B. Peleato", "J. Eckstein"], "venue": "Foundations and Trends in Machine Learning,", "citeRegEx": "Boyd et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Boyd et al\\.", "year": 2010}, {"title": "Parallel coordinate descent for l1-regularized loss minimization", "author": ["J.K. Bradley", "A. Kyrola", "D. Bickson", "C. Guestrin"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Bradley et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bradley et al\\.", "year": 2011}, {"title": "Estimation, optimization, and parallelism when data is sparse", "author": ["J. Duchi", "M.I. Jordan", "B. McMahan"], "venue": "Neural Information Processing Systems,", "citeRegEx": "Duchi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2013}, {"title": "Primal-dual rates and certificates", "author": ["C. D\u00fcnner", "S. Forte", "M. Tak\u00e1\u010d", "M. Jaggi"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "D\u00fcnner et al\\.,? \\Q2016\\E", "shortCiteRegEx": "D\u00fcnner et al\\.", "year": 2016}, {"title": "LIBLINEAR: A library for large linear classification", "author": ["R.-E. Fan", "K.-W. Chang", "C.-J. Hsieh", "X.-R. Wang", "C.-J. Lin"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Fan et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Fan et al\\.", "year": 2008}, {"title": "Accelerated, parallel, and proximal coordinate descent", "author": ["O. Fercoq", "P. Richt\u00e1rik"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "Fercoq and Richt\u00e1rik.,? \\Q2015\\E", "shortCiteRegEx": "Fercoq and Richt\u00e1rik.", "year": 2015}, {"title": "Distributed Optimization for Non-Strongly Convex Regularizers", "author": ["S. Forte"], "venue": "Master\u2019s thesis, ETH Zu\u0308rich,", "citeRegEx": "Forte.,? \\Q2015\\E", "shortCiteRegEx": "Forte.", "year": 2015}, {"title": "Regularization paths for generalized linear models via coordinate descent", "author": ["J. Friedman", "T. Hastie", "R. Tibshirani"], "venue": "Journal of Statistical Software,", "citeRegEx": "Friedman et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Friedman et al\\.", "year": 2010}, {"title": "DUAL-LOCO: Distributing statistical estimation using random projections", "author": ["C. Heinze", "B. McWilliams", "N. Meinshausen"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "Heinze et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Heinze et al\\.", "year": 2016}, {"title": "Fundamentals of convex analysis", "author": ["J.-B. Hiriart-Urruty", "C. Lemar\u00e9chal"], "venue": "Springer\u2013Verlag, Berlin,", "citeRegEx": "Hiriart.Urruty and Lemar\u00e9chal.,? \\Q2001\\E", "shortCiteRegEx": "Hiriart.Urruty and Lemar\u00e9chal.", "year": 2001}, {"title": "Communication-efficient distributed dual coordinate ascent", "author": ["M. Jaggi", "V. Smith", "M. Tak\u00e1\u010d", "J. Terhorst", "S. Krishnan", "T. Hofmann", "M.I. Jordan"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Jaggi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Jaggi et al\\.", "year": 2014}, {"title": "Blitz: A principled meta-algorithm for scaling sparse optimization", "author": ["T. Johnson", "C. Guestrin"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Johnson and Guestrin.,? \\Q2015\\E", "shortCiteRegEx": "Johnson and Guestrin.", "year": 2015}, {"title": "Linear convergence of gradient and proximal-gradient methods under the Polyak-\u0142ojasiewicz condition", "author": ["H. Karimi", "J. Nutini", "M. Schmidt"], "venue": "In European Conference on Machine Learning,", "citeRegEx": "Karimi et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Karimi et al\\.", "year": 2016}, {"title": "Distributed box-constrained quadratic optimization for dual linear SVM", "author": ["C.-P. Lee", "D. Roth"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Lee and Roth.,? \\Q2015\\E", "shortCiteRegEx": "Lee and Roth.", "year": 2015}, {"title": "On the complexity analysis of randomized block-coordinate descent methods", "author": ["Z. Lu", "L. Xiao"], "venue": null, "citeRegEx": "Lu and Xiao.,? \\Q2013\\E", "shortCiteRegEx": "Lu and Xiao.", "year": 2013}, {"title": "Distributed optimization with arbitrary local solvers. arXiv.org, 2015a", "author": ["C. Ma", "J. Kone\u010dn\u00fd", "M. Jaggi", "V. Smith", "M. Jordan", "P. Richt\u00e1rik", "M. Tak\u00e1\u010d"], "venue": null, "citeRegEx": "Ma et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2015}, {"title": "Adding vs. averaging in distributed primal-dual optimization", "author": ["C. Ma", "V. Smith", "M. Jaggi", "M.I. Jordan", "P. Richt\u00e1rik", "M. Tak\u00e1\u010d"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Ma et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2015}, {"title": "Linear convergence of the randomized feasible descent method under the weak strong convexity assumption. arXiv.org, 2015c", "author": ["C. Ma", "R. Tappenden", "M. Tak\u00e1\u010d"], "venue": null, "citeRegEx": "Ma et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2015}, {"title": "A distributed block coordinate descent method for training l1 regularized linear classifiers", "author": ["D. Mahajan", "S.S. Keerthi", "S. Sundararajan"], "venue": "arXiv.org,", "citeRegEx": "Mahajan et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Mahajan et al\\.", "year": 2014}, {"title": "Distributed Block Coordinate Descent for Minimizing Partially Separable Functions, volume", "author": ["J. Marecek", "P. Richt\u00e1rik", "M. Tak\u00e1\u010d"], "venue": "Proceedings in Mathematics & Statistics. Springer International Publishing,", "citeRegEx": "Marecek et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Marecek et al\\.", "year": 2015}, {"title": "LOCO: Distributing ridge regression with random projections", "author": ["B. McWilliams", "C. Heinze", "N. Meinshausen", "G. Krummenacher", "H.P. Vanchinathan"], "venue": null, "citeRegEx": "McWilliams et al\\.,? \\Q2014\\E", "shortCiteRegEx": "McWilliams et al\\.", "year": 2014}, {"title": "MLlib: Machine learning in apache spark", "author": ["X. Meng", "J. Bradley", "B. Yavuz", "E. Sparks", "S. Venkataraman", "D. Liu", "J. Freeman", "D. Tsai", "M. Amde", "S. Owen", "D. Xin", "R. Xin", "M.J. Franklin", "R. Zadeh", "M. Zaharia", "A. Talwalkar"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Meng et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Meng et al\\.", "year": 2016}, {"title": "Linear convergence of first order methods under weak nondegeneracy assumptions for convex programming", "author": ["I. Necoara"], "venue": null, "citeRegEx": "Necoara.,? \\Q2015\\E", "shortCiteRegEx": "Necoara.", "year": 2015}, {"title": "Distributed dual gradient methods and error bound conditions", "author": ["I. Necoara", "V. Nedelcu"], "venue": "arXiv.org,", "citeRegEx": "Necoara and Nedelcu.,? \\Q2014\\E", "shortCiteRegEx": "Necoara and Nedelcu.", "year": 2014}, {"title": "Smooth minimization of non-smooth functions", "author": ["Y. Nesterov"], "venue": "Mathematical Programming,", "citeRegEx": "Nesterov.,? \\Q2005\\E", "shortCiteRegEx": "Nesterov.", "year": 2005}, {"title": "Hogwild!: A lock-free approach to parallelizing stochastic gradient descent", "author": ["F. Niu", "B. Recht", "C. R\u00e9", "S.J. Wright"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Niu et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Niu et al\\.", "year": 2011}, {"title": "Solving large scale linear SVM with distributed block minimization", "author": ["D. Pechyony", "L. Shen", "R. Jones"], "venue": "In International Conference on Information and Knowledge Management,", "citeRegEx": "Pechyony et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Pechyony et al\\.", "year": 2011}, {"title": "Quartz: Randomized dual coordinate ascent with arbitrary sampling", "author": ["Z. Qu", "P. Richt\u00e1rik", "T. Zhang"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Qu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Qu et al\\.", "year": 2015}, {"title": "SDNA: Stochastic dual Newton ascent for empirical risk minimization", "author": ["Z. Qu", "P. Richt\u00e1rik", "M. Tak\u00e1\u010d", "O. Fercoq"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Qu et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Qu et al\\.", "year": 2016}, {"title": "Distributed coordinate descent method for learning with big data", "author": ["P. Richt\u00e1rik", "M. Tak\u00e1\u010d"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Richt\u00e1rik and Tak\u00e1\u010d.,? \\Q2016\\E", "shortCiteRegEx": "Richt\u00e1rik and Tak\u00e1\u010d.", "year": 2016}, {"title": "Convex Analysis", "author": ["R.T. Rockafellar"], "venue": null, "citeRegEx": "Rockafellar.,? \\Q1997\\E", "shortCiteRegEx": "Rockafellar.", "year": 1997}, {"title": "Stochastic methods for l1-regularized loss minimization", "author": ["S. Shalev-Shwartz", "A. Tewari"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Shalev.Shwartz and Tewari.,? \\Q2011\\E", "shortCiteRegEx": "Shalev.Shwartz and Tewari.", "year": 2011}, {"title": "Stochastic dual coordinate ascent methods for regularized loss minimization", "author": ["S. Shalev-Shwartz", "T. Zhang"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Shalev.Shwartz and Zhang.,? \\Q2013\\E", "shortCiteRegEx": "Shalev.Shwartz and Zhang.", "year": 2013}, {"title": "Accelerated mini-batch stochastic dual coordinate ascent", "author": ["S. Shalev-Shwartz", "T. Zhang"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Shalev.Shwartz and Zhang.,? \\Q2013\\E", "shortCiteRegEx": "Shalev.Shwartz and Zhang.", "year": 2013}, {"title": "Accelerated proximal stochastic dual coordinate ascent for regularized loss minimization", "author": ["S. Shalev-Shwartz", "T. Zhang"], "venue": "Mathematical Programming, Series", "citeRegEx": "Shalev.Shwartz and Zhang.,? \\Q2014\\E", "shortCiteRegEx": "Shalev.Shwartz and Zhang.", "year": 2014}, {"title": "Communication-efficient distributed optimization using an approximate newton-type method", "author": ["O. Shamir", "N. Srebro", "T. Zhang"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Shamir et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Shamir et al\\.", "year": 2014}, {"title": "L1-Regularized Distributed Optimization: A Communication-Efficient Primal-Dual Framework", "author": ["V. Smith", "S. Forte", "M.I. Jordan", "M. Jaggi"], "venue": null, "citeRegEx": "Smith et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Smith et al\\.", "year": 2015}, {"title": "Mini-batch primal and dual methods for SVMs", "author": ["M. Tak\u00e1\u010d", "A. Bijral", "P. Richt\u00e1rik", "N. Srebro"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Tak\u00e1\u010d et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Tak\u00e1\u010d et al\\.", "year": 2013}, {"title": "Distributed mini-batch SDCA", "author": ["M. Tak\u00e1\u010d", "P. Richt\u00e1rik", "N. Srebro"], "venue": "arXiv.org,", "citeRegEx": "Tak\u00e1\u010d et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Tak\u00e1\u010d et al\\.", "year": 2015}, {"title": "On the complexity of parallel coordinate descent", "author": ["R. Tappenden", "M. Tak\u00e1\u010d", "P. Richt\u00e1rik"], "venue": null, "citeRegEx": "Tappenden et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Tappenden et al\\.", "year": 2015}, {"title": "Distributed coordinate descent for l1-regularized logistic regression", "author": ["I. Trofimov", "A. Genkin"], "venue": "arXiv.org,", "citeRegEx": "Trofimov and Genkin.,? \\Q2014\\E", "shortCiteRegEx": "Trofimov and Genkin.", "year": 2014}, {"title": "Iteration complexity of feasible descent methods for convex optimization", "author": ["P.-W. Wang", "C.-J. Lin"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Wang and Lin.,? \\Q2014\\E", "shortCiteRegEx": "Wang and Lin.", "year": 2014}, {"title": "Coordinate descent algorithms", "author": ["S.J. Wright"], "venue": "Mathematical Programming,", "citeRegEx": "Wright.,? \\Q2015\\E", "shortCiteRegEx": "Wright.", "year": 2015}, {"title": "Trading computation for communication: Distributed stochastic dual coordinate ascent", "author": ["T. Yang"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Yang.,? \\Q2013\\E", "shortCiteRegEx": "Yang.", "year": 2013}, {"title": "On theoretical analysis of distributed stochastic dual coordinate ascent", "author": ["T. Yang", "S. Zhu", "R. Jin", "Y. Lin"], "venue": null, "citeRegEx": "Yang et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Yang et al\\.", "year": 2013}, {"title": "A dual augmented block minimization framework for learning with limited memory", "author": ["I.E.-H. Yen", "S.-W. Lin", "S.-D. Lin"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "Yen et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Yen et al\\.", "year": 2015}, {"title": "Large linear classification when data cannot fit in memory", "author": ["H.-F. Yu", "C.-J. Hsieh", "K.-W. Chang", "C.-J. Lin"], "venue": "ACM Transactions on Knowledge Discovery from Data,", "citeRegEx": "Yu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Yu et al\\.", "year": 2012}, {"title": "A quasi-Newton approach to nonsmooth convex optimization problems in machine learning", "author": ["J. Yu", "S. Vishwanathan", "S. G\u00fcnter", "N.N. Schraudolph"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Yu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Yu et al\\.", "year": 2010}, {"title": "A comparison of optimization methods and software for large-scale l1-regularized linear classification", "author": ["G.-X. Yuan", "K.-W. Chang", "C.-J. Hsieh", "C.-J. Lin"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Yuan et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Yuan et al\\.", "year": 2010}, {"title": "An improved GLMNET for L1-regularized logistic regression", "author": ["G.-X. Yuan", "C.-H. Ho", "C.-J. Lin"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Yuan et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Yuan et al\\.", "year": 2012}, {"title": "Efficient distributed linear classification algorithms via the alternating direction method of multipliers", "author": ["C. Zhang", "H. Lee", "K.G. Shin"], "venue": "In Artificial Intelligence and Statistics Conference,", "citeRegEx": "Zhang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2012}, {"title": "Stochastic primal-dual coordinate method for regularized empirical risk minimization", "author": ["Y. Zhang", "X. Lin"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Zhang and Lin.,? \\Q2015\\E", "shortCiteRegEx": "Zhang and Lin.", "year": 2015}, {"title": "Communication-efficient algorithms for statistical optimization", "author": ["Y. Zhang", "J.C. Duchi", "M.J. Wainwright"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Zhang et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2013}, {"title": "Parallelized stochastic gradient descent", "author": ["M.A. Zinkevich", "M. Weimer", "A.J. Smola", "L. Li"], "venue": "Neural Information Processing Systems,", "citeRegEx": "Zinkevich et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Zinkevich et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 34, "context": "Although numerous distributed optimization methods have been proposed, the minibatch optimization approach has emerged as one of the most popular paradigms for tackling this communication-computation tradeoff (see, e.g., Tak\u00e1\u010d et al., 2013; Shalev-Shwartz and Zhang, 2013b; Qu et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016).", "startOffset": 209, "endOffset": 317}, {"referenceID": 36, "context": "Although numerous distributed optimization methods have been proposed, the minibatch optimization approach has emerged as one of the most popular paradigms for tackling this communication-computation tradeoff (see, e.g., Tak\u00e1\u010d et al., 2013; Shalev-Shwartz and Zhang, 2013b; Qu et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016).", "startOffset": 209, "endOffset": 317}, {"referenceID": 17, "context": "CoCoA-v1 (Jaggi et al., 2014) and CoCoA+ (Ma et al.", "startOffset": 9, "endOffset": 29}, {"referenceID": 13, "context": "Portions of this newer work appear in SF\u2019s Master\u2019s Thesis (Forte, 2015) and Smith et al.", "startOffset": 59, "endOffset": 72}, {"referenceID": 13, "context": "Portions of this newer work appear in SF\u2019s Master\u2019s Thesis (Forte, 2015) and Smith et al. (2015).", "startOffset": 60, "endOffset": 97}, {"referenceID": 42, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al.", "startOffset": 40, "endOffset": 52}, {"referenceID": 17, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al.", "startOffset": 53, "endOffset": 73}, {"referenceID": 17, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015a); and Ma et al.", "startOffset": 53, "endOffset": 92}, {"referenceID": 17, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015a); and Ma et al. (2015b), our generalized, cohesive framework: (1) specifically incorporates difficult cases of L1 regularization and other non-strongly convex regularizers; (2) allows for the flexibility of distributing the data by either feature or training point; and (3) can be run on either a primal or dual formulation, which we show to have significant theoretical and practical implications.", "startOffset": 53, "endOffset": 115}, {"referenceID": 17, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015a); and Ma et al. (2015b), our generalized, cohesive framework: (1) specifically incorporates difficult cases of L1 regularization and other non-strongly convex regularizers; (2) allows for the flexibility of distributing the data by either feature or training point; and (3) can be run on either a primal or dual formulation, which we show to have significant theoretical and practical implications. Flexible communication and local solvers. Two key advantages of the proposed framework are its communication efficiency and ability to employ off-the-shelf single-machine solvers internally. On real-world systems, the cost of communication versus computation can vary widely, and it is thus advantageous to permit a flexible amount of communication depending on the setting at hand. Our framework provides exactly such control. Moreover, we allow arbitrary solvers to be used on each machine, which permits the reuse of existing code and the benefits from multi-core or other optimizations therein. Primal-dual rates. We derive convergence rates for our framework, leveraging a novel approach in the analysis of primal-dual rates for non-strongly convex regularizers. The proposed technique is a significant improvement over simple smoothing techniques used in, e.g., Nesterov (2005); Shalev-Shwartz and Zhang (2014); and Zhang and Lin (2015) that enforce strong convexity by adding a small L2 term to the objective.", "startOffset": 53, "endOffset": 1374}, {"referenceID": 17, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015a); and Ma et al. (2015b), our generalized, cohesive framework: (1) specifically incorporates difficult cases of L1 regularization and other non-strongly convex regularizers; (2) allows for the flexibility of distributing the data by either feature or training point; and (3) can be run on either a primal or dual formulation, which we show to have significant theoretical and practical implications. Flexible communication and local solvers. Two key advantages of the proposed framework are its communication efficiency and ability to employ off-the-shelf single-machine solvers internally. On real-world systems, the cost of communication versus computation can vary widely, and it is thus advantageous to permit a flexible amount of communication depending on the setting at hand. Our framework provides exactly such control. Moreover, we allow arbitrary solvers to be used on each machine, which permits the reuse of existing code and the benefits from multi-core or other optimizations therein. Primal-dual rates. We derive convergence rates for our framework, leveraging a novel approach in the analysis of primal-dual rates for non-strongly convex regularizers. The proposed technique is a significant improvement over simple smoothing techniques used in, e.g., Nesterov (2005); Shalev-Shwartz and Zhang (2014); and Zhang and Lin (2015) that enforce strong convexity by adding a small L2 term to the objective.", "startOffset": 53, "endOffset": 1407}, {"referenceID": 17, "context": "Notably, in contrast to earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015a); and Ma et al. (2015b), our generalized, cohesive framework: (1) specifically incorporates difficult cases of L1 regularization and other non-strongly convex regularizers; (2) allows for the flexibility of distributing the data by either feature or training point; and (3) can be run on either a primal or dual formulation, which we show to have significant theoretical and practical implications. Flexible communication and local solvers. Two key advantages of the proposed framework are its communication efficiency and ability to employ off-the-shelf single-machine solvers internally. On real-world systems, the cost of communication versus computation can vary widely, and it is thus advantageous to permit a flexible amount of communication depending on the setting at hand. Our framework provides exactly such control. Moreover, we allow arbitrary solvers to be used on each machine, which permits the reuse of existing code and the benefits from multi-core or other optimizations therein. Primal-dual rates. We derive convergence rates for our framework, leveraging a novel approach in the analysis of primal-dual rates for non-strongly convex regularizers. The proposed technique is a significant improvement over simple smoothing techniques used in, e.g., Nesterov (2005); Shalev-Shwartz and Zhang (2014); and Zhang and Lin (2015) that enforce strong convexity by adding a small L2 term to the objective.", "startOffset": 53, "endOffset": 1433}, {"referenceID": 46, "context": "It is also useful as an analysis tool, helping us to present a cohesive framework and relate this work to the prior work of Yang (2013); Jaggi et al.", "startOffset": 124, "endOffset": 136}, {"referenceID": 17, "context": "It is also useful as an analysis tool, helping us to present a cohesive framework and relate this work to the prior work of Yang (2013); Jaggi et al. (2014); and Ma et al.", "startOffset": 137, "endOffset": 157}, {"referenceID": 46, "context": "This setting was not covered in earlier work of Yang (2013); Jaggi et al.", "startOffset": 48, "endOffset": 60}, {"referenceID": 17, "context": "This setting was not covered in earlier work of Yang (2013); Jaggi et al. (2014); Ma et al.", "startOffset": 61, "endOffset": 81}, {"referenceID": 17, "context": "This setting was not covered in earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015b); and Ma et al.", "startOffset": 61, "endOffset": 100}, {"referenceID": 17, "context": "This setting was not covered in earlier work of Yang (2013); Jaggi et al. (2014); Ma et al. (2015b); and Ma et al. (2015a), and we discuss it in detail in Section 4, as additional machinery must be introduced to develop primal-dual rates for this setting.", "startOffset": 61, "endOffset": 123}, {"referenceID": 4, "context": "From a coordinate-wise perspective, two approaches for updating the parameter vector \u03b1 in an iterative fashion include the Jacobi method, in which updates made to coordinates of \u03b1 do not take into account the most recent updates to the other coordinates, and Gauss-Seidel, in which the most recent information is used (Bersekas and Tsitsiklis, 1989).", "startOffset": 318, "endOffset": 349}, {"referenceID": 44, "context": "As the size of the mini-batch grows, this can slow them down in terms of overall runtime, and can even lead to divergence in practice (Tak\u00e1\u010d et al., 2013; Tak\u00e1\u010d et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016; Marecek et al., 2015).", "startOffset": 134, "endOffset": 223}, {"referenceID": 45, "context": "As the size of the mini-batch grows, this can slow them down in terms of overall runtime, and can even lead to divergence in practice (Tak\u00e1\u010d et al., 2013; Tak\u00e1\u010d et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016; Marecek et al., 2015).", "startOffset": 134, "endOffset": 223}, {"referenceID": 36, "context": "As the size of the mini-batch grows, this can slow them down in terms of overall runtime, and can even lead to divergence in practice (Tak\u00e1\u010d et al., 2013; Tak\u00e1\u010d et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016; Marecek et al., 2015).", "startOffset": 134, "endOffset": 223}, {"referenceID": 26, "context": "As the size of the mini-batch grows, this can slow them down in terms of overall runtime, and can even lead to divergence in practice (Tak\u00e1\u010d et al., 2013; Tak\u00e1\u010d et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016; Marecek et al., 2015).", "startOffset": 134, "endOffset": 223}, {"referenceID": 7, "context": "6 Comparison to ADMM Finally, in this subsection we provide a direct comparison between CoCoA and ADMM (Boyd et al., 2010).", "startOffset": 103, "endOffset": 122}, {"referenceID": 41, "context": "To address this problem, existing approaches typically use a simple smoothing technique (as in Nesterov, 2005; Shalev-Shwartz and Zhang, 2014): by adding a small amount of L2 to the objective gi, the functions gi become strongly convex.", "startOffset": 88, "endOffset": 142}, {"referenceID": 10, "context": "See also D\u00fcnner et al. (2016) for a follow-up discussion of this technique in the non-distributed case.", "startOffset": 9, "endOffset": 30}, {"referenceID": 17, "context": "The earlier work of CoCoA-v1 (Jaggi et al., 2014) did not provide rates for L-Lipschitz `i losses.", "startOffset": 29, "endOffset": 49}, {"referenceID": 17, "context": "5 Recovering Earlier Work as a Special Case As a special case, the proposed framework and rates directly apply to L2-regularized lossminimization problems, including those presented in the earlier work of Jaggi et al. (2014) and Ma et al.", "startOffset": 205, "endOffset": 225}, {"referenceID": 17, "context": "5 Recovering Earlier Work as a Special Case As a special case, the proposed framework and rates directly apply to L2-regularized lossminimization problems, including those presented in the earlier work of Jaggi et al. (2014) and Ma et al. (2015b). Remark 3.", "startOffset": 205, "endOffset": 247}, {"referenceID": 9, "context": ", D\u00fcnner et al. (2016) or Boyd and Vandenberghe (2004, Example 3.", "startOffset": 2, "endOffset": 23}, {"referenceID": 14, "context": "For the L1 examples discussed, existing fast L1-solvers for the single-machine case, such as glmnet variants (Friedman et al., 2010) or blitz (Johnson and Guestrin, 2015) can be directly applied to each local subproblem G\u03c3 k ( \u00b7 ;v,\u03b1[k]) within Algorithm 1.", "startOffset": 109, "endOffset": 132}, {"referenceID": 18, "context": ", 2010) or blitz (Johnson and Guestrin, 2015) can be directly applied to each local subproblem G\u03c3 k ( \u00b7 ;v,\u03b1[k]) within Algorithm 1.", "startOffset": 17, "endOffset": 45}, {"referenceID": 20, "context": "We discuss some specific examples of local solvers below, and point the reader to Ma et al. (2015a) for an empirical exploration of these choices.", "startOffset": 82, "endOffset": 100}, {"referenceID": 49, "context": "This algorithm and its variants are increasingly used in practice (Wright, 2015), and extensions such as accelerated and parallel versions can directly be applied (Shalev-Shwartz and Zhang, 2014; Fan et al.", "startOffset": 66, "endOffset": 80}, {"referenceID": 41, "context": "This algorithm and its variants are increasingly used in practice (Wright, 2015), and extensions such as accelerated and parallel versions can directly be applied (Shalev-Shwartz and Zhang, 2014; Fan et al., 2008) in our framework.", "startOffset": 163, "endOffset": 213}, {"referenceID": 11, "context": "This algorithm and its variants are increasingly used in practice (Wright, 2015), and extensions such as accelerated and parallel versions can directly be applied (Shalev-Shwartz and Zhang, 2014; Fan et al., 2008) in our framework.", "startOffset": 163, "endOffset": 213}, {"referenceID": 30, "context": ", by using error bound conditions (Necoara and Nedelcu, 2014; Wang and Lin, 2014), weak strong convexity conditions (Ma et al.", "startOffset": 34, "endOffset": 81}, {"referenceID": 48, "context": ", by using error bound conditions (Necoara and Nedelcu, 2014; Wang and Lin, 2014), weak strong convexity conditions (Ma et al.", "startOffset": 34, "endOffset": 81}, {"referenceID": 29, "context": ", by using error bound conditions (Necoara and Nedelcu, 2014; Wang and Lin, 2014), weak strong convexity conditions (Ma et al., 2015c; Necoara, 2015) or by considering Polyak-\u0141ojasiewicz conditions (Karimi et al.", "startOffset": 116, "endOffset": 149}, {"referenceID": 19, "context": ", 2015c; Necoara, 2015) or by considering Polyak-\u0141ojasiewicz conditions (Karimi et al., 2016).", "startOffset": 72, "endOffset": 93}, {"referenceID": 19, "context": "example, for randomized coordinate descent (as part of glmnet), Lu and Xiao (2013, Theorem 1) gives a O(1/t) approximation quality for any separable regularizer, including L1 and elastic net; see also Tappenden et al. (2015) and Shalev-Shwartz and Tewari (2011).", "startOffset": 64, "endOffset": 225}, {"referenceID": 19, "context": "example, for randomized coordinate descent (as part of glmnet), Lu and Xiao (2013, Theorem 1) gives a O(1/t) approximation quality for any separable regularizer, including L1 and elastic net; see also Tappenden et al. (2015) and Shalev-Shwartz and Tewari (2011). In the dual setting (Algorithm 3) for the discussed examples, the losses are applied only to local variables \u03b1[k], and the regularizer is approximated via a quadratic term.", "startOffset": 64, "endOffset": 262}, {"referenceID": 11, "context": "This algorithm and its variants are increasingly used in practice (Wright, 2015), and extensions such as accelerated and parallel versions can directly be applied (Shalev-Shwartz and Zhang, 2014; Fan et al., 2008) in our framework. For non-smooth losses such as SVMs, the analysis of Shalev-Shwartz and Zhang (2013a) provides a O(1/t) rate, and for smooth losses, a faster linear rate.", "startOffset": 196, "endOffset": 317}, {"referenceID": 28, "context": "0) (Meng et al., 2016).", "startOffset": 3, "endOffset": 22}, {"referenceID": 8, "context": "A comparison with Shotgun (Bradley et al., 2011), a popular method for solving L1-regularized problems in the multicore environment, is provided as an extreme case to highlight the detrimental effects of frequent communication in the distributed environment.", "startOffset": 26, "endOffset": 48}, {"referenceID": 31, "context": "To get around this requirement, previous work has suggested implementing the Nesterov smoothing technique used in, e.g., Shalev-Shwartz and Zhang (2014); Zhang and Lin (2015) \u2014 adding a small amount of strong convexity \u03b4\u2016\u03b1\u20162 to the objective for lasso regression.", "startOffset": 77, "endOffset": 153}, {"referenceID": 31, "context": "To get around this requirement, previous work has suggested implementing the Nesterov smoothing technique used in, e.g., Shalev-Shwartz and Zhang (2014); Zhang and Lin (2015) \u2014 adding a small amount of strong convexity \u03b4\u2016\u03b1\u20162 to the objective for lasso regression.", "startOffset": 77, "endOffset": 175}, {"referenceID": 7, "context": "Alternating Direction Method of Multipliers (ADMM) (Boyd et al., 2010) is a popular method that lends itself naturally to the distributed environment.", "startOffset": 51, "endOffset": 70}, {"referenceID": 28, "context": "0 (Meng et al., 2016).", "startOffset": 2, "endOffset": 21}, {"referenceID": 7, "context": "Alternating Direction Method of Multipliers (ADMM) (Boyd et al., 2010) is a popular method that lends itself naturally to the distributed environment. For lasso regression, implementing ADMM for the problems of interest requires solving a large linear system Cx = d on each machine, where C \u2208 Rn\u00d7n with n scaling beyond 107 for the datasets in Table 5, and with C being possibly dense. It is prohibitively slow to solve this directly on each machine, and we therefore employ the iterative method of conjugate gradient with early stopping (see, e.g., Boyd et al., 2010, Section 4.3). For SVM classification, we use stochastic dual coordinate ascent as an internal optimizer, which is shown in Zhang et al. (2012) to have superior performance.", "startOffset": 52, "endOffset": 712}, {"referenceID": 38, "context": "Mini-batch CD (for lasso) and SDCA (for SVM) aim to improve mini-batch SGD by employing coordinate descent, which has theoretical and practical justifications (Shalev-Shwartz and Tewari, 2011; Tak\u00e1\u010d et al., 2015; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015; Tak\u00e1\u010d et al., 2013).", "startOffset": 159, "endOffset": 284}, {"referenceID": 45, "context": "Mini-batch CD (for lasso) and SDCA (for SVM) aim to improve mini-batch SGD by employing coordinate descent, which has theoretical and practical justifications (Shalev-Shwartz and Tewari, 2011; Tak\u00e1\u010d et al., 2015; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015; Tak\u00e1\u010d et al., 2013).", "startOffset": 159, "endOffset": 284}, {"referenceID": 12, "context": "Mini-batch CD (for lasso) and SDCA (for SVM) aim to improve mini-batch SGD by employing coordinate descent, which has theoretical and practical justifications (Shalev-Shwartz and Tewari, 2011; Tak\u00e1\u010d et al., 2015; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015; Tak\u00e1\u010d et al., 2013).", "startOffset": 159, "endOffset": 284}, {"referenceID": 46, "context": "Mini-batch CD (for lasso) and SDCA (for SVM) aim to improve mini-batch SGD by employing coordinate descent, which has theoretical and practical justifications (Shalev-Shwartz and Tewari, 2011; Tak\u00e1\u010d et al., 2015; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015; Tak\u00e1\u010d et al., 2013).", "startOffset": 159, "endOffset": 284}, {"referenceID": 44, "context": "Mini-batch CD (for lasso) and SDCA (for SVM) aim to improve mini-batch SGD by employing coordinate descent, which has theoretical and practical justifications (Shalev-Shwartz and Tewari, 2011; Tak\u00e1\u010d et al., 2015; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015; Tak\u00e1\u010d et al., 2013).", "startOffset": 159, "endOffset": 284}, {"referenceID": 8, "context": "For the case of lasso regression, we implement Shotgun (Bradley et al., 2011), which is a popular method for parallel optimization.", "startOffset": 55, "endOffset": 77}, {"referenceID": 54, "context": "OWN-QN (Yu et al., 2010) is a quasi-Newton method optimized in Spark\u2019s spark.", "startOffset": 7, "endOffset": 24}, {"referenceID": 28, "context": "ml package (Meng et al., 2016).", "startOffset": 11, "endOffset": 30}, {"referenceID": 14, "context": ", by using existing fast L1-solvers for the singlemachine case, such as glmnet variants (Friedman et al., 2010) or blitz (Johnson and Guestrin, 2015) or SVM solvers like liblinear (Fan et al.", "startOffset": 88, "endOffset": 111}, {"referenceID": 18, "context": ", 2010) or blitz (Johnson and Guestrin, 2015) or SVM solvers like liblinear (Fan et al.", "startOffset": 17, "endOffset": 45}, {"referenceID": 11, "context": ", 2010) or blitz (Johnson and Guestrin, 2015) or SVM solvers like liblinear (Fan et al., 2008).", "startOffset": 76, "endOffset": 94}, {"referenceID": 14, "context": "of-the-art, as in glmnet (Friedman et al., 2010) and extensions (Yuan et al.", "startOffset": 25, "endOffset": 48}, {"referenceID": 56, "context": ", 2010) and extensions (Yuan et al., 2012); see, e.", "startOffset": 23, "endOffset": 42}, {"referenceID": 41, "context": "However, primal-dual convergence rates for unmodified coordinate algorithms have to our knowledge only been obtained for strongly convex regularizers to date (Shalev-Shwartz and Zhang, 2014; Zhang and Lin, 2015).", "startOffset": 158, "endOffset": 211}, {"referenceID": 58, "context": "However, primal-dual convergence rates for unmodified coordinate algorithms have to our knowledge only been obtained for strongly convex regularizers to date (Shalev-Shwartz and Zhang, 2014; Zhang and Lin, 2015).", "startOffset": 158, "endOffset": 211}, {"referenceID": 14, "context": "In the single-coordinate update case, this is at the core of glmnet (Friedman et al., 2010; Yuan et al., 2010), and widely used in, e.", "startOffset": 68, "endOffset": 110}, {"referenceID": 55, "context": "In the single-coordinate update case, this is at the core of glmnet (Friedman et al., 2010; Yuan et al., 2010), and widely used in, e.", "startOffset": 68, "endOffset": 110}, {"referenceID": 38, "context": ", solvers based on the primal formulation of L1-regularized objectives (Shalev-Shwartz and Tewari, 2011; Yuan et al., 2012; Bian et al., 2013; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015).", "startOffset": 71, "endOffset": 194}, {"referenceID": 56, "context": ", solvers based on the primal formulation of L1-regularized objectives (Shalev-Shwartz and Tewari, 2011; Yuan et al., 2012; Bian et al., 2013; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015).", "startOffset": 71, "endOffset": 194}, {"referenceID": 5, "context": ", solvers based on the primal formulation of L1-regularized objectives (Shalev-Shwartz and Tewari, 2011; Yuan et al., 2012; Bian et al., 2013; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015).", "startOffset": 71, "endOffset": 194}, {"referenceID": 12, "context": ", solvers based on the primal formulation of L1-regularized objectives (Shalev-Shwartz and Tewari, 2011; Yuan et al., 2012; Bian et al., 2013; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015).", "startOffset": 71, "endOffset": 194}, {"referenceID": 46, "context": ", solvers based on the primal formulation of L1-regularized objectives (Shalev-Shwartz and Tewari, 2011; Yuan et al., 2012; Bian et al., 2013; Fercoq and Richt\u00e1rik, 2015; Tappenden et al., 2015).", "startOffset": 71, "endOffset": 194}, {"referenceID": 12, "context": "of-the-art, as in glmnet (Friedman et al., 2010) and extensions (Yuan et al., 2012); see, e.g., the overview in Yuan et al. (2010). However, primal-dual convergence rates for unmodified coordinate algorithms have to our knowledge only been obtained for strongly convex regularizers to date (Shalev-Shwartz and Zhang, 2014; Zhang and Lin, 2015).", "startOffset": 26, "endOffset": 131}, {"referenceID": 32, "context": "Several variants of SGD have been proposed for parallel computing, many of which build on the idea of asynchronous communication (Niu et al., 2011; Duchi et al., 2013).", "startOffset": 129, "endOffset": 167}, {"referenceID": 9, "context": "Several variants of SGD have been proposed for parallel computing, many of which build on the idea of asynchronous communication (Niu et al., 2011; Duchi et al., 2013).", "startOffset": 129, "endOffset": 167}, {"referenceID": 7, "context": "For the specific case of L1-regularized objectives, parallel coordinate descent (with and without using mini-batches) was proposed in Bradley et al. (2011) (Shotgun) and generalized in Bian et al.", "startOffset": 134, "endOffset": 156}, {"referenceID": 5, "context": "(2011) (Shotgun) and generalized in Bian et al. (2013), and is among the best performing solvers in the parallel setting.", "startOffset": 36, "endOffset": 55}, {"referenceID": 55, "context": "(2009); Zinkevich et al. (2010); Zhang et al.", "startOffset": 8, "endOffset": 32}, {"referenceID": 54, "context": "(2010); Zhang et al. (2013); McWilliams et al.", "startOffset": 8, "endOffset": 28}, {"referenceID": 26, "context": "(2013); McWilliams et al. (2014); and Heinze et al.", "startOffset": 8, "endOffset": 33}, {"referenceID": 15, "context": "(2014); and Heinze et al. (2016). These methods require additional assumptions on the partitioning of the data, which are usually not satisfied in practice if the data are distributed \u201cas is\u201d, i.", "startOffset": 12, "endOffset": 33}, {"referenceID": 15, "context": "(2014); and Heinze et al. (2016). These methods require additional assumptions on the partitioning of the data, which are usually not satisfied in practice if the data are distributed \u201cas is\u201d, i.e., if we do not have the opportunity to distribute the data in a specific way beforehand. Furthermore, some cannot guarantee convergence rates beyond what could be achieved if we ignored data residing on all but a single computer, as shown in Shamir et al. (2014). Additional relevant lower bounds on", "startOffset": 12, "endOffset": 460}, {"referenceID": 34, "context": "However, mini-batch versions of both SGD and coordinate descent (CD) (e.g., Tak\u00e1\u010d et al., 2013; Shalev-Shwartz and Zhang, 2013b; Qu et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016) suffer from their convergence rate degrading towards the rate of batch gradient descent as the size of the mini-batch is increased.", "startOffset": 69, "endOffset": 172}, {"referenceID": 36, "context": "However, mini-batch versions of both SGD and coordinate descent (CD) (e.g., Tak\u00e1\u010d et al., 2013; Shalev-Shwartz and Zhang, 2013b; Qu et al., 2015; Richt\u00e1rik and Tak\u00e1\u010d, 2016) suffer from their convergence rate degrading towards the rate of batch gradient descent as the size of the mini-batch is increased.", "startOffset": 69, "endOffset": 172}, {"referenceID": 7, "context": "ADMM (Boyd et al., 2010), gradient descent, and quasi-Newton methods such as L-BFGS and are also often used in distributed environments because of their relatively low communication requirements.", "startOffset": 5, "endOffset": 24}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007).", "startOffset": 179, "endOffset": 201}, {"referenceID": 50, "context": "The practical variant of the DisDCA (Yang, 2013), called DisDCA-p, allows for additive updates in a similar manner to CoCoA, but is restricted to coordinate decent (CD) being the local solver, and was initially proposed without convergence guarantees.", "startOffset": 36, "endOffset": 48}, {"referenceID": 0, "context": "the minimum number of communication rounds necessary for a given approximation quality are presented in Balcan et al. (2012) and Arjevani and Shamir (2015).", "startOffset": 104, "endOffset": 125}, {"referenceID": 0, "context": "(2012) and Arjevani and Shamir (2015). Mini-batch methods.", "startOffset": 11, "endOffset": 38}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007). Finally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods. Distributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al.", "startOffset": 180, "endOffset": 1113}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007). Finally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods. Distributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al. (2011); Yang (2013); Yang et al.", "startOffset": 180, "endOffset": 1137}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007). Finally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods. Distributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al. (2011); Yang (2013); Yang et al.", "startOffset": 180, "endOffset": 1150}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007). Finally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods. Distributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al. (2011); Yang (2013); Yang et al. (2013) and Lee and Roth (2015), the CoCoA-v1 and CoCoA+ frameworks (which are special cases of the presented framework, CoCoA) are the first to allow the use of any local solver\u2014of weak local approximation quality\u2014in each round in the distributed setting.", "startOffset": 180, "endOffset": 1170}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007). Finally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods. Distributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al. (2011); Yang (2013); Yang et al. (2013) and Lee and Roth (2015), the CoCoA-v1 and CoCoA+ frameworks (which are special cases of the presented framework, CoCoA) are the first to allow the use of any local solver\u2014of weak local approximation quality\u2014in each round in the distributed setting.", "startOffset": 180, "endOffset": 1194}, {"referenceID": 0, "context": "In Section 6, we include experimental comparisons with ADMM, gradient descent, and L-BFGS variants, including orthant-wise limited memory quasi-Newton (OWL-QN) for the L1 setting (Andrew and Gao, 2007). Finally, we note that while the convergence rates provided for CoCoA mirror the convergence class of classical batch gradient methods in terms of the number of outer rounds, existing batch gradient methods come with a weaker theory, as they do not allow general inexactness \u0398 for the local subproblem (10). In contrast, our convergence rates incorporate this approximation directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods (where in each round, every machine has to process exactly a full pass through the local data). This makes CoCoA more flexible in the distributed setting, as it can adapt to varied communication costs on real systems. We have seen in Section 6 that this flexibility results in significant performance gains over the competing methods. Distributed solvers. By making use of the primal-dual structure in the line of work of Yu et al. (2012); Pechyony et al. (2011); Yang (2013); Yang et al. (2013) and Lee and Roth (2015), the CoCoA-v1 and CoCoA+ frameworks (which are special cases of the presented framework, CoCoA) are the first to allow the use of any local solver\u2014of weak local approximation quality\u2014in each round in the distributed setting. The practical variant of the DisDCA (Yang, 2013), called DisDCA-p, allows for additive updates in a similar manner to CoCoA, but is restricted to coordinate decent (CD) being the local solver, and was initially proposed without convergence guarantees. DisDCA-p, CoCoA-v1, and CoCoA+ are all limited to strongly convex regularizers, and therefore are not as general as the CoCoA framework discussed in this work. In the L1-regularized setting, an approach related to our framework includes distributed variants of glmnet as in Mahajan et al. (2014). Inspired by glmnet and Yuan et al.", "startOffset": 180, "endOffset": 1967}, {"referenceID": 25, "context": "If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016).", "startOffset": 290, "endOffset": 348}, {"referenceID": 56, "context": "If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016).", "startOffset": 290, "endOffset": 348}, {"referenceID": 35, "context": "If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016).", "startOffset": 290, "endOffset": 348}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al.", "startOffset": 21, "endOffset": 40}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context.", "startOffset": 21, "endOffset": 66}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression.", "startOffset": 21, "endOffset": 210}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al.", "startOffset": 21, "endOffset": 645}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al.", "startOffset": 21, "endOffset": 795}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al. (2012); and Yen et al.", "startOffset": 21, "endOffset": 815}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al. (2012); and Yen et al. (2015) assume that the quadratic subproblems are solved exactly.", "startOffset": 21, "endOffset": 838}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al. (2012); and Yen et al. (2015) assume that the quadratic subproblems are solved exactly. Therefore, these methods are not able to freely trade off communication and computation. Also, they do not allow the re-use of arbitrary local solvers. On the theoretical side, the convergence rate results provided by Mahajan et al. (2014); Trofimov and Genkin (2014); and Yuan et al.", "startOffset": 21, "endOffset": 1136}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al. (2012); and Yen et al. (2015) assume that the quadratic subproblems are solved exactly. Therefore, these methods are not able to freely trade off communication and computation. Also, they do not allow the re-use of arbitrary local solvers. On the theoretical side, the convergence rate results provided by Mahajan et al. (2014); Trofimov and Genkin (2014); and Yuan et al.", "startOffset": 21, "endOffset": 1164}, {"referenceID": 5, "context": "(2012), the works of Bian et al. (2013) and Mahajan et al. (2014) introduced the idea of a block-diagonal Hessian upper approximation in the distributed L1 context. The later work of Trofimov and Genkin (2014) specialized this approach to sparse logistic regression. If hypothetically each of our quadratic subproblems G\u03c3 k (\u2206\u03b1[k]) as defined in (10) were to be minimized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each coordinate block k, where the Newton-subproblem is modified to also contain the L1-regularizer (Mahajan et al., 2014; Yuan et al., 2012; Qu et al., 2016). While Mahajan et al. (2014) allows a fixed accuracy for these subproblems, but not arbitrary approximation quality \u0398 as in our framework, the works of Trofimov and Genkin (2014); Yuan et al. (2012); and Yen et al. (2015) assume that the quadratic subproblems are solved exactly. Therefore, these methods are not able to freely trade off communication and computation. Also, they do not allow the re-use of arbitrary local solvers. On the theoretical side, the convergence rate results provided by Mahajan et al. (2014); Trofimov and Genkin (2014); and Yuan et al. (2012) are not explicit convergence rates but only asymptotic, as the quadratic upper bounds are not explicitly controlled for safety as with our \u03c3\u2032.", "startOffset": 21, "endOffset": 1188}, {"referenceID": 50, "context": "6, following the line of reasoning in Yang (2013). For consensus ADMM, the objective (B) is decomposed using the following re-parameterization:", "startOffset": 38, "endOffset": 50}, {"referenceID": 22, "context": "The arguments follow the reasoning in Ma et al. (2015b,a), but where we have generalized them to be applicable directly to (A). We provide full details of Lemma 1 as a proof of concept, but omit details in later proofs that can be derived using the arguments in Ma et al. (2015b) or earlier work of Shalev-Shwartz and Zhang (2013a), and instead outline the proof strategy and highlight sections where the theory deviates.", "startOffset": 38, "endOffset": 280}, {"referenceID": 22, "context": "The arguments follow the reasoning in Ma et al. (2015b,a), but where we have generalized them to be applicable directly to (A). We provide full details of Lemma 1 as a proof of concept, but omit details in later proofs that can be derived using the arguments in Ma et al. (2015b) or earlier work of Shalev-Shwartz and Zhang (2013a), and instead outline the proof strategy and highlight sections where the theory deviates.", "startOffset": 38, "endOffset": 332}, {"referenceID": 36, "context": "3 Proof of Convergence Result for Strongly Convex gi Our second main theorem follows reasoning in Shalev-Shwartz and Zhang (2013a) and is a generalization of Ma et al.", "startOffset": 98, "endOffset": 131}], "year": 2016, "abstractText": "The scale of modern datasets necessitates the development of efficient distributed optimization methods for machine learning. We present a general-purpose framework for the distributed environment, CoCoA, that has an efficient communication scheme and is applicable to a wide variety of problems in machine learning and signal processing. We extend the framework to cover general non-strongly convex regularizers, including L1-regularized problems like lasso, sparse logistic regression, and elastic net regularization, and show how earlier work can be derived as a special case. We provide convergence guarantees for the class of convex regularized loss minimization objectives, leveraging a novel approach in handling non-strongly convex regularizers and non-smooth loss functions. The resulting framework has markedly improved performance over state-of-the-art methods, as we illustrate with an extensive set of experiments on real distributed datasets.", "creator": "LaTeX with hyperref package"}}}