{"id": "1611.02453", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Nov-2016", "title": "The Data Complexity of Description Logic Ontologies", "abstract": "We analyze the data complexity of ontology-mediated querying where the ontologies are formulated in a description logic (DL) of the ALC family and queries are conjunctive queries, positive existential queries, or acyclic conjunctive queries. Our approach is non-uniform in the sense that we aim to understand the complexity of each single ontology instead of for all ontologies formulated in a certain language. While doing so, we quantify over the queries and are interested, for example, in the question whether all queries can be evaluated in polynomial time w.r.t. a given ontology. Our results include a PTime/coNP-dichotomy for ontologies of depth one in the description logic ALCFI, the equivalence of a PTime/coNP-dichotomy for ALC and ALCI-ontologies of unrestricted depth to the famous dichotomy conjecture for CSPs by Feder and Vardi, and the failure of PTime/coNP-dichotomy theorem for ALCF-ontologies. Regarding the latter DL, we also show that it is undecidable whether a given ontology admits PTime query evaluation.", "histories": [["v1", "Tue, 8 Nov 2016 09:52:54 GMT  (92kb)", "http://arxiv.org/abs/1611.02453v1", null], ["v2", "Tue, 24 Oct 2017 09:19:25 GMT  (96kb)", "http://arxiv.org/abs/1611.02453v2", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["carsten lutz", "frank wolter"], "accepted": false, "id": "1611.02453"}, "pdf": {"name": "1611.02453.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["clu@uni-bremen.de", "wolter@liverpool.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n61 1.\n02 45\n3v 1\n[ cs\n.A I]\n8 N"}, {"heading": "1. INTRODUCTION", "text": "In recent years, the use of ontologies to access instance data has become increasingly popular [PLC+08, KZ14, BO15]. The general idea is that an ontology provides domain knowledge and an enriched vocabulary for querying, thus serving as an interface between the query and the data, and enabling the derivation of additional facts. In this emerging area, called ontology-mediated querying, it is a central research goal to identify ontology languages for which query evaluation scales to large amounts of instance data. Since the size of the data typically dominates the size of the ontology and the size of the query by orders of magnitude, the central measure for such scalability is data complexity\u2014the complexity of query evaluation where only the data is considered to be an input, but both the query and the ontology are fixed.\nIn description logic (DL), ontologies take the form of a TBox, data is stored in an ABox, and the most important classes of queries are conjunctive queries (CQs) and variations thereof, such as positive existential queries (PEQs). A fundamental observation regarding this setup is that, for expressive DLs such as ALC and SHIQ, the complexity of query evaluation is CONP-complete and thus intractable [Sch93, HMS07, GLHS08].1 The classical approach to avoid this problem is to replace ALC and SHIQ with less expressive DLs that are \u2018Horn\u2019 in the sense that they can\n1998 ACM Subject Classification: Logic, Description Logics. Key words and phrases: Description Logic, Ontology-Based Data Access, Data Complexity, Conjunctive Queries. 1When speaking of complexity, we always mean data complexity\nLOGICAL METHODS IN COMPUTER SCIENCE DOI:10.2168/LMCS-???\nc\u00a9 DATA COMPLEXITY OF ONTOLOGIES Creative Commons\n1\nbe embedded into the Horn fragment of first-order (FO) logic. Horn DLs typicall admit query evaluation in PTIME, examples include a variety of logics from the EL [BBL05] and DL-Lite families [CDGL+07] as well as Horn-SHIQ, a large fragment of SHIQ with PTIME query evaluation [HMS07].\nIt may thus seem that the data complexity of query evaluation in the presence of DL ontologies is understood rather well. However, all results discussed above are on the level of logics, i.e., traditional results about data complexity concern a class of TBoxes that is defined in a syntactic way in terms of expressibility in a certain DL language, but no attempt is made to identify more structure inside these classes. Such a more fine-grained study, however, seems very natural both from a theoretical and from a practical perspective; in particular, it is well-known that ontologies which emerge in practice tend to use \u2018expensive\u2019 language constructs that can result in CONPhardness of data complexity, but they typically do so in an extremely restricted and intuitively \u2018harmless\u2019 way. This distinction between hard and harmless cases cannot be analyzed on the level of logics. The aim of this paper is to initiate a more fine-grained study of data complexity that is non-uniform in the sense that it does not treat all TBoxes formulated in the same DL in a uniform way.\nWhen taking a non-uniform perspective, there is an important choice regarding the level of granularity. First, one can analyze the complexity on the level of TBoxes, quantifying over the actual query. Then, query evaluation for a TBox T is in PTIME if every query (from the class under consideration) can be evaluated in PTIME w.r.t. T and it is CONP-hard if there is at least one query that is CONP-hard to evaluate w.r.t. T . And second, one might take an even more fine-grained approach where the query is not quantified away and the aim is to classify the complexity on the level of ontology-mediated queries (OMQs), that is, combinations of a TBox and an actual query. From a practical perspective, both setups make sense; when the actual queries are fixed at the design time of the application, one would probably prefer to work on the level of OMQs whereas the level of TBoxes seems more appropriate when the queries can be freely formulated at application running time. A non-uniform analysis on the level of OMQs has been carried out in [BtCLW14]. In this paper, we concentrate on the level of TBoxes. The ultimate goal of our approach is as follows:\nFor a fixed DL L and query language Q, classify all TBoxes T in L according to the complexity of evaluating queries from Q w.r.t. T .\nWe consider the basic expressive DL ALC, its extensions ALCI with inverse roles and ALCF with functional roles, and their union ALCFI. As query languages, we cover CQs, acyclic CQs, and PEQs (which have the same expressive power as unions of conjunctive queries, UCQs, which are thus implicitly also covered). It turns out that, even for ALC, fully achieving the above goal is far beyond the scope of a single research paper. In fact, we show that for any of the mentioned query languages, a full classification of the complexity of ALC- and ALCI-TBoxes is essentially equivalent to a full classification of the complexity of non-uniform constraint satisfaction problems with finite templates (CSPs). The latter is a major research programme ongoing for many years that combines complexity theory, graph theory, logic, and algebra [BJK05, KS09, Bul11, Bar14].\nIn the current paper, we mainly concentrate on understanding the boundary between PTIME and CONP-hardness of query evaluation w.r.t. DL TBoxes, mostly neglecting other relevant classes such as AC0, LOGSPACE, and NLOGSPACE. Our main results are as follows (they always apply to all query languages mentioned above).\n1. There is a PTIME/CONP-dichotomy for query evaluation w.r.t. ALCFI-TBoxes of depth one, i.e., TBoxes in which existential and universal restrictions are not nested; moreover, PTIME query\nevaluation coincides with rewritability into monadic Datalog (with inequalities, to capture functional roles).\nThe proof rests on interesting model-theoretic characterizations of polynomial time CQ-evaluation which are discussed below. Note that this is a relevant case since most TBoxes from practical applications have depth one. In particular, all TBoxes formulated in DL-Lite and its extensions proposed in [CDGL+07, ACKZ09] have depth one, and the same is true for more than 80 percent of the 429 TBoxes in the BioPortal ontology repository.\n2. There is a PTIME/CONP-dichotomy for CQ-evaluation w.r.t. ALC-TBoxes if and only if Feder and Vardi\u2019s dichotomy conjecture for CSPs is true; the same holds for ALCI-TBoxes.\nThe proof establishes a close link between query evaluation in ALC and CSP. While dichotomy questions are mainly of theoretical interest, linking these two worlds is potentially very relevant also for more applied DL research.\n3. There is no PTIME/CONP-dichotomy for query evaluation w.r.t. ALCF-TBoxes (unless PTIME = NP).\nThis is proved by showing that, for every problem in CONP, there is an ALCF-TBox for which CQevaluation has the same complexity (up to polynomial time reductions); it then remains to apply Ladner\u2019s Theorem, which guarantees the existence of NP-intermediate problems. Consequently, we cannot expect an exhaustive classification of the complexity of query evaluation w.r.t. ALCFTBoxes.\nTo prove these results, we introduce two new notions that are of independent interest and general utility. The first one is materializability of a TBox T , which means that evaluating a query over an ABox A w.r.t. T can be reduced to query evaluation in a single model of A and T (a materialization). Note that such models play a crucial role in the context of Horn DLs, where they are often called canonical models or universal models. In contrast to the Horn DL case, however, we only require the existence of such a model without making any assumptions about its form or construction.\n4. If an ALCFI-TBox T is not materializable, then CQ-evaluation w.r.t. T is CONP-hard.\nWe also investigate the nature of materializations. It turns out that if a TBox is materializable for one of the considered query languages, then it is materializable also for all others. The concrete materializations, however, need not agree. To obtain these results, we characterize CQ-materializations in terms of homomorphisms and ELIQ-materializations in terms of simulations (an ELIQ is an ELI-instance query, thus the DL version of an acyclic CQ, with a single answer variable).\nPerhaps in contrary to the intuitions that arise from the experience with Horn DLs, materializability of a TBox T is not a sufficient condition for query evaluation w.r.t. T to be in PTIME (unless PTIME = NP) since the existing materialization might be hard to compute. This leads us to study the notion of unraveling tolerance of a TBox T , meaning that answers to acyclic CQs over an ABox A w.r.t. T are preserved under unraveling the ABox A. In CSP, unraveling tolerance corresponds to the existence of tree obstructions, a notion that characterizes the well-known arc consistency condition and rewritability into monadic Datalog [FV93, Kro10a]. It can be shown that every TBox formulated in Horn-ALCFI (the intersection of ALCFI and Horn-SHIQ) is unraveling tolerant and that there are unraveling tolerant TBoxes which are not equivalent to any Horn-ALCFI-TBox. Thus, the following result yields a rather general (and uniform!) PTIME upper bound for CQ-evaluation.\n5. If an ALCFI-TBox T is unraveling tolerant, then query evaluation w.r.t. T is in PTIME.\nAlthough the above result is rather general, unraveling tolerance of a TBox T is not a necessary condition for CQ-evaluation w.r.t. T to be in PTIME (unless PTIME = NP). However, for ALCFITBoxes T of depth one, being materializable and being unraveling tolerant turns out to be equivalent. For such TBoxes, we thus obtain that CQ-evalutation w.r.t. T is in PTIME iff T is materializable iff T is unraveling tolerant while, otherwise, CQ-evaluation w.r.t. T is CONP-hard. This establishes the first main result above.\nOur framework also allows to formally capture some intuitions and beliefs commonly held in the context of CQ-answering in DLs. For example, we show that for every ALCFI-TBox T , CQ-evaluation is in PTIME iff PEQ-evaluation is in PTIME iff ELIQ-evaluation is in PTIME, and the same is true for rewritability into monadic Datalog and for CONP-hardness. In fact, the use of multiple query languages and in particular of ELI-instance queries does not only yield additional results, but is at the heart of our proof strategies. Another interesting observation in this spirit is that an ALCFI-TBox is materializable iff it is convex, a condition that is also called the disjunction property and plays a central role in attaining PTIME complexity for standard reasoning in Horn DLs such as EL, DL-Lite, and Horn-SHIQ; see for example [BBL05, KL07] for more details.\nThis paper is an extended and revised version of the conference publication [LW12].\nRelated Work. An early reference on data complexity in DLs is [Sch93], showing CONP-hardness of ELQs in the fragment ALE of ALC (an ELQ is an ELIQ in which all edges are directed away from the answer variable). A CONP upper bound for ELIQs in the much more expressive DL SHIQ was obtained in [HMS07] and generalized to CQs in [GLHS08]. Horn-SHIQ was first defined in [HMS07], where also a PTIME upper bound for ELIQs is established; the generalization to CQs can be found in [EGOS08]. See also [KL07, Ros07, OCE08, CDL+13] and references therein for the data complexity in DLs and [BGO10, BMRT11] for related work on the guarded fragment and on existential rules.\nTo the best of our knowledge, the conference version of this paper was first to initiate the study of data complexity in ontology-mediated querying at the level of individual TBoxes and the first to observe a link between this area and CSP. There is, however, a certain technical similarity to the link between view-based query processing for regular path queries (RPQs) and CSP found in [CGLV00, CGLV03b, CGLV03a]. In this case, the recognition problem for perfect rewritings for RPQs can be polynomially reduced to non-uniform CSP and vice versa. On the level of OMQs, the data complexity of ontology-mediated querying with DLs has been studied in [BtCLW14]; also here, a connection to CSP plays a central role. In [LSW13, LSW15], the non-uniform data complexity of ontology-mediated query answering is studied in the case where the TBox is formulated in an inexpressive DL of the DL-Lite or EL family and where individual predicates in the data can be given a closed-world reading, which also gives rise to CONP-hardness of query evaluation; while [LSW13] is considering the level of TBoxes, [LSW15] treats the level of OMQs, establishing a connection to surjective CSPs.\nThe work on CSP dichotomies started with Schaefer\u2019s PTIME/NP-dichotomy theorem, stating that every CSP defined by a two element template is in PTIME or NP-hard [Sch78]. Schaefer\u2019s theorem was followed by dichotomy results for CSPs with (undirected) graph templates [HN90] and several other special cases, leading to the widely known Feder-Vardi conjecture which postulates a PTIME/NP-dichotomy for all CSPs, independently of the size of the template [FV93]. An influential approach to studying the complexity of CSPs is via universal algebra [BJK05], and it has resulted in a confirmation of the Feder Vardi conjecture for ternary CSPs [Bul02]. Interesting results have also\nbeen obtained for other complexity classes such as AC0 [ABI+05, LLT07]. For a recent summary of the state of the art we refer to [Bar14]."}, {"heading": "2. PRELIMINARIES", "text": "We introduce the relevant description logics and query languages, define the fundamental notions studied in this paper, and illustrate them with suitable examples.\nWe shall be concerned with the DL ALC and its extensions ALCI, ALCF , and ALCFI. Let NC, NR, and NI denote countably infinite sets of concept names, role names, and individual names, respectively. ALC concepts are constructed according to the rule\nC,D := \u22a4 | \u22a5 | A | C \u2293D | C \u2294D | \u00acC | \u2203r.C | \u2200r.C\nwhere A ranges over NC and r ranges over NR. ALCI concepts admit, in addition, inverse roles from the set N\u2212\nR = {r\u2212 | r \u2208 NR}, which can be used in place of role names. Thus, A \u2293 \u2203r\u2212.\u2200s.B\nis an example of an ALCI concept. To avoid heavy notation, we set r\u2212 := s if r = s\u2212 for a role name s; in particular, we thus have (r\u2212)\u2212 = r.\nIn DLs, ontologies are formalized as TBoxes. An ALC-TBox is a finite set of concept inclusions (CIs) C \u2291 D, where C,D are ALC concepts, and ALCI TBoxes are defined analogously. An ALCF-TBox (resp. ALCFI-TBox) is an ALC-TBox (resp. ALCI-TBox) that additionally admits functionality assertions func(r), where r \u2208 NR (resp. r \u2208 NR \u222a N \u2212 R\n), declaring that r is interpreted as a partial function. Note that there is no such thing as an ALCF concept or an ALCFI concept, as the extension with functional roles does not change the concept language.\nAn ABox A is a non-empty finite set of assertions of the form A(a) and r(a, b) with A \u2208 NC, r \u2208 NR, and a, b \u2208 NI. In some cases, we drop the finiteness condition on ABoxes and then explicitly speak about infinite ABoxes. We use Ind(A) to denote the set of individual names used in the ABox A and sometimes write r\u2212(a, b) \u2208 A instead of r(b, a) \u2208 A.\nThe semantics of DLs is given by interpretations I = (\u2206I , \u00b7I), where \u2206I is a non-empty set and \u00b7I maps each concept name A \u2208 NC to a subset AI of \u2206I and each role name r \u2208 NR to a binary relation rI on \u2206I . The extension (r\u2212)I of r\u2212 under the interpretation I is defined as the converse relation (rI)\u22121 of rI and the extension CI \u2286 \u2206I of concepts under the interpretation I is defined inductively as follows:\n\u22a4I = \u2206I\n\u22a5I = \u2205\n(C \u2293D)I = CI \u2229DI\n(C \u2294D)I = CI \u222aDI\n(\u2203r.C)I = {d \u2208 \u2206I | \u2203d\u2032 \u2208 \u2206I : (d, d\u2032) \u2208 rI and d\u2032 \u2208 CI}\n(\u2200r.C)I = {d \u2208 \u2206I | \u2200d\u2032 \u2208 \u2206I : (d, d\u2032) \u2208 rI implies d\u2032 \u2208 CI}\nAn interpretation I satisfies a CI C \u2291 D if CI \u2286 DI , an assertion A(a) if a \u2208 CI , an assertion r(a, b) if (a, b) \u2208 rI , and a functionality assertion func(r) if rI is a partial function. Note that we make the standard name assumption, that is, individual names are not interpreted as domain elements (like first-order constants), but as themselves. This assumption is common both in DLs and in database theory. The results in this paper do not depend on it.\nAn interpretation I is a model of a TBox T if it satisfies all CIs in T and I is a model of an ABox A if it satisfies all assertions in A. We call an ABox A consistent w.r.t. a TBox T if A and T have a joint model.\nWe consider several query languages. A positive existential query (PEQ) q(~x) is a first-order formula with free variables ~x = x1, . . . , xn constructed from atoms A(x) and r(x, y) using conjunction, disjunction, and existential quantification where A \u2208 NC, r \u2208 NR, and x, y are individual variables. The variables in ~x are the answer variables of q(~x). A PEQ without answer variables is Boolean. An assignment \u03c0 for q(~x) in an interpretation I is a mapping from the variables that occur in q(~x) to \u2206I . A tuple ~a = a1, . . . , an in Ind(I) is an answer to q(~x) in I if there exists an assigment \u03c0 for q(~x) in I such that I |=\u03c0 q(~x) (in the standard first-order sense) and \u03c0(xi) = ai for 1 \u2264 i \u2264 n. In this case, we write I |= q(~a). A tuple ~a \u2208 Ind(A), A an ABox, is a certain answer to q(~x) in A w.r.t. a TBox T , in symbols T ,A |= q(~a), if I |= q(~a) for all models I of T and A. Computing certain answers to a query in the sense just defined is that main querying problem that we are interested in. Although this paper focusses on the theoretical aspects of query answering, we given a concrete example that illustrates the usefulness of query answering with DL ontologies.\nExample 1. Let\nT = {Professer \u2291 Academic, Professor \u2291 \u2203gives.Course}\nA = {Student(john), supervisedBy(john,mark), Professor(mark)}\nq(x, y) = \u2203z Student(x) \u2227 supervisedBy(x, y) \u2227 Academic(y) \u2227 gives(y, z) \u2227 Course(z)\nThus the query asks to return all pairs that consist of a student x and an academic y such that x is supervised by y and y gives a course. Although this information is not directly present in the ABox, because of the TBox it is easy to see that (john,mark) is a certain answer.\nApart from PEQs, we also study several fragments thereof. A conjunctive query (CQ) is a PEQ without disjunction. We generally assume that a CQ q(~x) takes the form \u2203~y \u03d5(~x, ~y), where \u03d5(~x, ~y) is a conjunction of atoms of the form A(x) and r(x, y). It is easy to see that every PEQ q(~x) is equivalent to a disjunction \u2228 i\u2208I qi(~x), where each qi(~x) is a CQ (such a disjunction is often called a union of conjunctive queries, or UCQ). To introduce relevant fragments of CQs, we recall two further DLs that we use here for querying purposes. EL concepts are constructed from NC and NR according to the syntax rule\nC,D := \u22a4 | A | C \u2293D | \u2203r.C\nand ELI concepts additionally admit inverse roles. If C is an ELI concept and x a variable, then C(x) is called an ELI query (ELIQ); if C is an EL concept, then C(x) is called an EL query (ELQ). Note that every ELIQ can be regarded as an acyclic CQ with one answer variable, and indeed this is an equivalent definition of ELIQs; in the case of ELQs, it is additionally the case that all edges are directed away from the answer variable. For example, the ELIQ \u2203r.(A \u2293 \u2203s\u2212.B)(x) is equivalent to the acyclic CQ\n\u2203y1\u2203y2(r(x, y1) \u2227A(y1) \u2227 s(y2, y1) \u2227B(y2)).\nIn what follows, we will not distinguish between an ELIQ and its translation into an acyclic CQ with one answer variable and freely apply notions introduced for PEQs also to ELIQs and ELQs. We also sometimes slightly abuse notation and use PEQ to denote the set of all positive existential queries, and likewise for CQ, ELIQ, and ELQ.\nExample 2. (1) Let T\u2203,r = {A \u2291 \u2203r.A} and q(x) = \u2203r.A(x). Then we have for any ABox A, T\u2203,r,A |= q(a) iff A(a) \u2208 A or there are r(a, b), A(b) \u2208 A.\n(2) Let T\u2203,l = {\u2203r.A \u2291 A} and q(x) = A(x). For any ABox A, T\u2203,l,A |= q(a) iff there is an r-path in A from a to some b with A(b) \u2208 A; that is, there are r(a0, a1), . . . , r(an\u22121, an) \u2208 A, n \u2265 0, with a0 = a, an = b, and A(b) \u2208 A.\n(3) Consider an undirected graph G represented as an ABox A with assertions r(a, b), r(b, a) \u2208 A iff there is an edge between a and b. Let A1, . . . , Ak,M be concept names. Then G is k-colorable iff Tk,A 6|= \u2203xM(x), where\nTk = {Ai \u2293Aj \u2291 M | 1 \u2264 i < j \u2264 k}\u222a\n{Ai \u2293 \u2203r.Ai \u2291 M | 1 \u2264 i \u2264 k}\u222a {\u22a4 \u2291 \u2294 1\u2264i\u2264k Ai}.\nWe now introduce the main complexity notions investigated in this paper. An ontology-mediated query (OMQ) is a a pair (T , q(~x)) with T a TBox T and q(~x) a query. The query evaluation problem for (T , q(~x)) is to decide, given an ABox A and ~a in Ind(A), whether T ,A |= q(~a). Instead of actually computing certain answers, we concentrate on the query evaluation problem, which is the decision problem version of query answering. In this paper, we are typically interested in joint complexity bounds for all OMQs based on a given TBox and query language.\nDefinition 3. Let T be an ALCFI-TBox and let Q \u2208 {CQ,PEQ,ELIQ,ELQ}. Then \u2022 Q-evaluation w.r.t. T is in PTIME if for every q(~x) \u2208 Q, the query evaluation problem for (T , q(~x)) is in PTIME.\n\u2022 Q-evaluation w.r.t. T is CONP-hard if there exists q(~x) \u2208 Q such that the query evaluation problem for (T , q(~x)) is coNP-hard.\nExample 4. (1) PEQ-evaluation w.r.t. the TBoxes T\u2203,r and T\u2203,l from Example 2 is in PTIME. This follows from the fact that these TBoxes are EL TBoxes (TBoxes using only EL concepts) and it is well known that PEQ-evaluation w.r.t. EL-TBoxes is in PTIME [KL07]. (2) Consider the TBoxes Tk from Example 2 that express k-colorability. For k \u2265 3, CQ-evaluation w.r.t. Tk is CONP-hard since k-colorability is NP-hard. However, in contrast to the tractability of 2-colorability, CQ-evaluation w.r.t. T2 is still CONP-hard. This follows from Theorem 18 below and, intuitively, is the case because T2 \u2018entails a disjunction\u2019: for A = {B(a)}, we have T2,A |= A1(a) \u2228A2(a), but neither T2,A |= A1(a) nor T2,A |= A2(a).\nIn addition to the classification of TBoxes according to whether query evaluation is in PTIME or CONP-hard, we are also interested in whether OMQs based on the TBox are rewritable into more classical database querying languages, in particular into Datalog.\nA Datalog rule \u03c1 has the form S(~x) \u2190 R1(~y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Rn(~yn) where n > 0, S is a relation symbol, and R1, . . . , Rn are relation symbols, that is, concept names and role names. We refer to S(~x) as the head of \u03c1 and R1(~y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Rn(~yn) as its body. Every variable in the head of \u03c1 is required to occur also in its body. A Datalog program \u03a0 is a finite set of Datalog rules with a selected goal relation goal that does not occur in rule bodies. Relation symbols that occur in the head of at least one rule are called intensional relation symbols (IDBs), the remaining symbols are called extensional relation symbols (EDBs). Note that, by definition, goal is an IDB. The arity of the program is the arity of the goal relation. Programs of arity zero are called Boolean.\nFor an ABox A, a Datalog program \u03a0, and~a from Ind(A) of the same length as the arity of goal, we write A |= \u03a0(~a) if \u03a0 returns ~a as an answer on A, defined in the usual way [CGT89]. A Datalog program \u03a0 is a Datalog-rewriting of an OMQ (T , q(~x)) if for all ABoxes A and ~a from Ind(A), T ,A |= q(~a) iff A |= \u03a0(~a). In this case the OMQ (T , q(~x)) is called Datalog-rewritable. When working with DLs such as ALCFI that include functional roles, it is more natural to admit the use of inequalities in the bodies of Datalog rules instead of working with \u2018pure\u2019 programs. We refer to such extended programs as Datalog6= programs and accordingly speak of Datalog6=-rewritability.\nExample 5. (1) The OMQ (T\u2203,l, A(x)) from Example 2 expressing a form of reachability is rewritable into the Datalog program\ngoal(x) \u2190 P (x), P (x) \u2190 A(x), P (x) \u2190 r(x, y) \u2227 P (y).\n(2) The OMQ (Tk,\u2203xM(x)) from Example 2 is Datalog-rewritable iff k \u2264 2 since non-2-colorability can be expressed by a Datalog program but for k \u2265 3, non-k-colorability cannot be expressed by a Datalog program (in fact, not even by a Datalog6= program) [ACY91]. (3) The OMQ ({func(r)},\u2203xM(x)) is rewritable into the Datalog6= program\ngoal() \u2190 r(x, y1) \u2227 r(x, y2) \u2227 y1 6= y2\nbut is not rewritable into pure Datalog.\nDefinition 6. Let T be an ALCFI-TBox and let Q \u2208 {CQ,PEQ,ELIQ,ELQ}. Then T is Datalog6=-rewritable for Q if (T , q(~x)) is Datalog6=-rewritable for every q(~x) \u2208 Q.\nExample 7. It is folklore that every EL-TBox is Datalog-rewritable for ELQ, ELIQ, CQ, and for PEQ. Thus, this applies in particular to the TBoxes T\u2203,l and T\u2203,r from Example 2. A concrete construction of Datalog-rewritings for ELIQs can be found in the proof of Theorem 24 below. In contrast, the TBox Tk from Example 2 is not Datalog6=-rewritable for ELQ when k \u2265 3 since the OMQ (Tk,\u2203xM(x)) is not Datalog6=-rewritable, by Example 5 (2).\nIt is well-known that Datalog6=-programs can be evaluated in PTIME [CGT89], and thus Datalog6=rewritability for Q of a TBox T implies that Q-evaluation w.r.t. T is in PTIME. We shall see later that the converse direction does not hold.\nWe will often be concerned with homomorphisms between ABoxes and between interpretations, defined next. Let A and B be ABoxes. A function h : Ind(A) \u2192 Ind(B) is a homomorphism from A to B if it satisfies the following conditions:\n(1) A(a) \u2208 A implies A(h(a)) \u2208 B and (2) r(a, b) \u2208 A implies r(h(a), h(b)) \u2208 B.\nWe say that h preserves I \u2286 NI if h(a) = a for all a \u2208 I . Homomorphisms from an interpretation I to an interpretation J are defined analogously as functions h : \u2206I \u2192 \u2206J . Note that these two notions are in fact identical since, up to presentation, ABoxes and finite interpretations are the same thing. In what follows we will not always distinguish between the two presentations."}, {"heading": "3. MATERIALIZABILITY", "text": "We introduce materializability as a central notion for analyzing the complexity and rewritability of TBoxes. A materialization of a TBox T and ABox A for a class of queries Q is a model of T and A that gives the same answers to queries in Q as T and A do. It is not difficult to see that a materialization for ELIQs is not necessarily a materialization for CQs and that a materialization for ELQs is not necessarily a materialization for ELIQs. We shall call a TBox T materializable for a query language Q if for every ABox A that is consistent w.r.t. T , there is at least one materialization of T and A for Q. Interestingly, we show that materializability of ALCFI-TBoxes does not depend on whether one considers ELIQs, CQs, or PEQs. This result allows us to simply talk about materializable TBoxes, independently of the query language considered. The fundamental\nresult linking materializability of a TBox to the complexity of query evaluation is that query evaluation is CONP-hard w.r.t. non-materializable ALCFI-TBoxes. As a first application, we show that PTIME query evaluation and Datalog6=-rewritability of ALCFI-TBoxes also do not depend on the query language, and the same is true for CONP-hardness of query evaluation. As a side line, we also consider the case of ALCF where, additionally, materializability for ELIQs coincides with materializability for ELQs.\nDefinition 8. Let T be an ALCFI-TBox and Q \u2208 {CQ,PEQ,ELIQ,ELQ}. Then (1) a model I of T and an ABoxA is a Q-materialization of T and A if for all queries q(~x) \u2208 Q\nand ~a \u2286 Ind(A), we have I |= q(~a) iff T ,A |= q(~a); (2) T is Q-materializable if for every ABox A that is consistent w.r.t. T , there exists a Q-\nmaterialization of T and A.\nIn Point (1) of Definition 8, it is important that the materialization I of T and A is a model of T and A. In fact, for every ABox A that is consistent w.r.t. T , we find an interpretation I such that for every CQ q(~x) and ~a \u2286 Ind(A), I |= q(~a) iff T ,A |= q(~a); take, for example, the direct product of all (up to isomorphisms) countable models of T and A. Note that I is, in general, not a model of T .\nNote that a Q-materialization can be viewed as a more abstract version of the canonical or minimal or universal model as often used in the context of \u2018Horn DLs\u2019 such as EL and DL-Lite [LTW09, KLT+10, BO15] and more expressive ontology languages based on tuple-generating dependencies (tgds) [CGK13] as well as in data exchange [FKMP05]. In fact, the ELQ-materialization in the next example is exactly the \u2018compact canonical model\u2019 from [LTW09].\nExample 9. (1) Let T\u2203,l = {\u2203r.A \u2291 A} be as in Example 2 and let A be an ABox. Let I be the interpretation obtained from A by adding to AI all a \u2208 Ind(A) such that there exists an r-path from a to some b with A(b) \u2208 A. Then I is a PEQ-materialization of T and A and so T is PEQ-materializable.\n(2) Let T\u2203,r = {A \u2291 \u2203r.A} be as in Example 2 and let A be an ABox with at least one assertion of the form A(a). To obtain an ELQ-materialization I of T and A, start with A as an interpretation, add a fresh domain element dr to \u2206I and to AI , and extend rI with (a, dr) and (dr, dr) for all A(a) \u2208 A. Thus T\u2203,r is ELQ-materializable.\nTrivially, every PEQ-materialization is a CQ-materialization, every CQ-materialization is an ELIQmaterialization and every ELIQ-materialization is an ELQ-materialization. Conversely, it follows directly from the fact that each PEQ is equivalent to a disjunction of CQs that every CQ-materialization is also a PEQ-materialization. In contrast, the following example demonstrates that ELQ-materializations are different from ELIQ-materializations. A similar argument separates ELIQ-materializations from CQ-materializations.\nExample 10. Let T\u2203,r be as in Example 9,\nA = {B1(a), B2(b), A(a), A(b)} and\nq(x) = (B1 \u2293 \u2203r.\u2203r \u2212.B2)(x),\nThen the ELQ-materialization MA from Example 9 is not a Q-materialization for any Q from the set of query languages ELIQ,CQ,PEQ. For example, we have MA |= q(a), but T ,A 6|= q(a). An ELIQ/CQ/PEQ-materialization of T and A is obtained by unfolding MA (see below): instead of using only one additional individual dr as a witness for \u2203r.A, we attach to both a and b an infinite r-path of elements that satisfy A. Note that every CQ/PEQ-materialization of T\u2203,r and A must be infinite.\nWe will sometimes restrict our attention to materializations I that are countable and generated, i.e, every d \u2208 \u2206I is reachable from some a \u2208 \u2206I \u2229 NI in the undirected graph\nGI = (\u2206 I , {{d, d\u2032} | (d, d\u2032) \u2208\n\u22c3\nr\u2208NR\nrI}).\nThe following lemma shows that we can make that assumption without loss of generality.\nLemma 11. Let T be an ALCFI-TBox, A an ABox, and Q \u2208 {CQ,PEQ,ELIQ,ELQ}. If I is a Q-materialization of T and A, then there exists a subinterpretation J of I that is a countable and generated Q-materialization of T and A.\nProof. Let I be a Q-materialization of T and A. To construct J we apply a standard selective filtration procedure to I . More precisely, we identify a sequence Ind(A) = S0 \u2286 S1 \u2286 \u00b7 \u00b7 \u00b7 \u2286 \u2206I\nand then define J to be the restriction of I to \u22c3\ni Si. Let C be the set of all concepts of the form \u2203r.C that occur in T and of all concepts \u2203r.\u00acC such that \u2200r.C occurs in T . Assume Si has already been defined. Then define Si+1 as the union of Si and, for every d \u2208 Si and concept \u2203r.C \u2208 C with d \u2208 (\u2203r.C)I , an arbitrary d\u2032 \u2208 \u2206I with (d, d\u2032) \u2208 rI and d\u2032 \u2208 CI (unless such a d\u2032 exists already in Si). It is easy to see that J is a countable and generated Q-materialization of T and A. \u274f\n3.1. Model-Theoretic Characterizations of Materializability. We characterize materializations using simulations and homomorphisms. This sheds light on the nature of materializations and establishes a close connection between materializations and initial models as studied in model theory, algebraic specification, and logic programming [Mal71, MG85, Mak87].\nA simulation from an interpretation I1 to an interpretation I2 is a relation S \u2286 \u2206I1 \u00d7 \u2206I2\nsuch that\n(1) for all A \u2208 NC: if d1 \u2208 AI1 and (d1, d2) \u2208 S, then d2 \u2208 AI2 ; (2) for all r \u2208 NR: if (d1, d2) \u2208 S and (d1, d\u20321) \u2208 r I1 , then there exists d\u20322 \u2208 \u2206 I2 such that\n(d\u20321, d \u2032 2) \u2208 S and (d2, d \u2032 2) \u2208 r I2; (3) for all a \u2208 \u2206I1 \u2229 NI: a \u2208 \u2206I2 and (a, a) \u2208 S.\nNote that, by Condition (3), domain elements that are individual names need to be respected by simulations while other domain elements need not. In database parlance, the latter are thus treated as labeled nulls, that is, while their existence is important, their identity is not.\nWe call a simulation S an i-simulation if Condition (2) is satisfied also for inverse roles. Note that S is a homomorphism preserving \u2206I1 \u2229 NI if S is a function with domain \u2206I . We remind the reader of the following characterizations of ELQs using simulations, ELIQs using i-simulations, and CQs using homomorphisms (see e.g. [LW10]). An interpretation I has finite outdegree if the undirected graph GI has finite outdegree.\nLemma 12. Let I and J be interpretations such that \u2206I \u2229 NI is finite, I is countable and generated, and J has finite outdegree. Then the following conditions are equivalent (where none of the assumed conditions on I and J is required for (2) \u21d2 (1)).\n(1) For all ELIQs C(x) and a \u2208 \u2206I \u2229 NI: if I |= C(a), then J |= C(a); (2) There is an i-simulation from I and J .\nThe same equivalence holds when ELIQs and i-simulations are replaced by ELQs and simulations, respectively. Moreover, the following conditions are equivalent (where none of the assumed conditions on I and J is required for (3) \u21d2 (1)).\n(3) For all PEQs q(~x) and ~a \u2286 \u2206I \u2229 NI: if I |= q(~a), then J |= q(~a);\n(4) For all CQs q(~x) and ~a \u2286 \u2206I \u2229 NI: if I |= q(~a), then J |= q(~a); (5) There is a homomorphism from I to J preserving \u2206I \u2229 NI.\nProof. We prove the equivalence of (3)-(5). The equivalence of (1) and (2) is similar (both for ELIQs and ELQs) but simpler and left to the reader. The implication (3) \u21d2 (4) is trivial. For the proof of (4) \u21d2 (5), assume that I is countable and generated and let J have finite outdegree. We first assume that only a finite set \u03a3 of concept and role names have a non-empty interpretation in I and then generalize the result to arbitrary I . Assume that (4) holds. First observe that for every finite subset X of \u2206I there is a homomorphism hX preserving X \u2229 NI from the subinterpretation I\u21beX of I induced by X into J : associate with every d \u2208 X an individual variable xd and regard I\u21beX as the CQ qX(~x) = \u2203~y\u03d5(~x, ~y) defined by setting\n\u03d5(~x, ~y) = \u2203~y \u2227\nd\u2208X\u2229AI\nA(xd) \u2227 \u2227\n(d,d\u2032)\u2208(X\u00d7X)\u2229rI\nr(xd, xd\u2032),\nwhere ~x comprises the individual variables in {xa | a \u2208 X \u2229 NI} and ~y comprises the individual variables xd with d \u2208 X \\NI (qX is a CQ by our assumption that only finitely many concept and role names have non-empty interpretation). For the assignment \u03c0(xd) = d, we have I |=\u03c0 \u03d5(~x, ~y). Thus I |=\u03c0 qX(~x) and so, by (2), J |=\u03c0 qX(~x). Consequently, there exists an assignment \u03c0\u2032 for qX(~x) in J which coincides with \u03c0 on {xa | a \u2208 X \u2229 NI} such that J |=\u03c0\u2032 \u03d5(~x, ~y). Let hX(d) = \u03c0\u2032(d) for d \u2208 X. Then hX is a homomorphism from I\u21beX to J preserving X \u2229 NI, as required.\nWe now lift the homomorphisms hX to a homomorphism h from I to J preserving \u2206I \u2229 NI. Since I is countable and generated, there exists a sequence X0 \u2286 X1 \u2286 \u00b7 \u00b7 \u00b7 of finite subsets of \u2206I\nsuch that X0 = \u2206I \u2229 NI, \u22c3 i\u22650 Xi = \u2206 I , and for all d \u2208 Xi there exists a path in Xi from some a \u2208 X0 to d. By the observation above, we find homomorphisms hXi from I\u21beXi to J preserving Xi\u2229NI, for i \u2265 0. Let d0, d1 . . . be an enumeration of \u2206I . We define the required homomorphism h as the limit of a sequence h0 \u2286 h1 \u2286 \u00b7 \u00b7 \u00b7 , where each hn has domain {d0, . . . , dn} and where we ensure for each hn and all d \u2208 {d0, . . . , dn} that there are infinitely many j with hn(d) = h\u21beXj(d). Observe that since J has finite outdegree and since for all d \u2208 Xi, there exists a path in Xi from some a \u2208 X0 to d, for each d \u2208 \u2206I there exist only finitely many distinct values in {h\u21beXi(d) | i \u2265 0}. By the pigeonhole principle, there thus exist infinitely many j with the same value hXj (d). For h0(d0) we take such a value for d0. Assume hn has been defined and assume that the set I = {j | hn(d) = h\u21beXj (d) for all d \u2208 {d0, . . . , dn}} is infinite. Again by the pigeonhole principle, we find a value e \u2208 \u2206J such that hXj (dn+1) = e for infinitely many j \u2208 I . We set hn+1(dn+1) = e. The function h = \u22c3 i\u22650 h0 is a homomorphism from I to J preserving \u2206\nI \u2229 NI, as required. To lift this result to arbitrary interpretations I , it is sufficient to prove that the homomorphisms hX still exist. This can be shown using again the pigeonhole principle. Let X \u2286 \u2206I be finite. We may assume that for each d \u2208 X, there exists a path in X from some a \u2208 X \u2229 NI, to d. We have shown that for each finite set \u03a3 of concept and role names, there exists a homomorphism h\u03a3X from the \u03a3-reduct I\u03a3X of IX to J (I \u03a3 X interprets only the symbols in \u03a3 as non-empty). Since J has finite outdegree, infinitely many h\u03a3X coincide. A straightforward modification of the pigeonhole argument above can now be used to construct the required homomorphism hX .\nFor the proof of (5) \u21d2 (3), assume I |= q(~a) and let h be a homomorphism from I to J preserving \u2206I \u2229NI. Let \u03c0 be an assignment for q(~x) in I witnessing I |= q(~a). Then the composition h \u25e6 \u03c0 is an assignment for q(~x) in J witnessing J |= q(~a). \u274f\nFor the next steps, we need some observations regarding the unfolding of interpretations into forestshaped interpretations. Let us first make precise what we mean by unfolding. The i-unfolding of an interpretation I is an interpretation J defined as follows. The domain \u2206J of J consists of all words d0r1 . . . rndn with n \u2265 0, each di from \u2206I and each ri a (possibly inverse) role such that\n(a) di \u2208 NI iff i = 0; (b) (di, di+1) \u2208 rIi+1 for 0 \u2264 i < n; (c) if r\u2212i = ri+1, then di\u22121 6= di+1 for 0 < i < n.\nFor d0 \u00b7 \u00b7 \u00b7 dn \u2208 \u2206J , we set tail(d0 \u00b7 \u00b7 \u00b7 dn) = dn. Now set\nAJ = {w \u2208 \u2206J | tail(w) \u2208 AI} for all A \u2208 NC rJ = (rI \u2229 (NI \u00d7 NI))\u222a\n{(\u03c3, \u03c3rd) | \u03c3, \u03c3rd \u2208 \u2206J } \u222a {(\u03c3r\u2212d, \u03c3) | \u03c3, \u03c3r\u2212d \u2208 \u2206J } for all r \u2208 NR.\nWe say that an interpretation I is i-unfolded if it is isomorphic to its own i-unfolding. Clearly, every i-unfolding of an interpretation is i-unfolded.\nFor ALCF-TBoxes, it is not required to unfold along inverse roles. This is reflected in the unfolding of an interpretation I , where in contrast to the i-unfolding we use as the domain the set of all words d0r1 . . . rndn with n \u2265 0, each di from \u2206I , and each ri a role name such that Conditions (a) and (b) above are satisfied. The interpretation of concept and role names remains the same. We call an interpretation I unfolded if it is isomorphic to its own unfolding. The following lemma summarizes the main properties of unfoldings. Its proof is straightforward and left to the reader.\nLemma 13. Let I be an interpretation, I i its i-unfolding, and Iu its unfolding. Then for every interpretation J , the following conditions are satisfied:\n(1) the function f(w) := tail(w), w \u2208 \u2206I i , is a homomorphism from I i to I preserving\n\u2206I \u2229 NI; (2) the function f(w) := tail(w), w \u2208 \u2206I u\n, is a homomorphism from Iu to I preserving \u2206I \u2229 NI; (3) if there is an i-simulation from I to J , then there is a homomorphism from I i to J preserving \u2206I \u2229 NI; (4) if there is a simulation from I to J , then there is a homomorphism from Iu to J preserving \u2206I \u2229 NI; (5) if I is a model of T and A with T an ALCFI-TBox, then I i is a model of T and A; (6) if I is a model of T and A with T an ALCF-TBox, then Iu is a model of T and A.\nAn interpretation I is called hom-initial in a class K of interpretations if for every J \u2208 K, there exists a homomorphism from I to J preserving \u2206I \u2229 NI. I is called sim-initial (i-sim-initial) in a class K of interpretations if for every J \u2208 K, there exists a simulation (i-simulation) from I to J . The following theorem provides the announced characterization of materializations in terms of simulations and homomorphisms. In the following, the class of all models of T and A is denoted by Mod(T ,A).\nTheorem 14. Let T be an ALCFI-TBox, A an ABox, and let I \u2208 Mod(T ,A) be countable and generated. Then I is\n(1) an ELIQ-materialization of T and A iff it is i-sim-initial in Mod(T ,A); (2) a CQ-materialization of T and A iff it is a PEQ-materialization of T and A iff it is hom-\ninitial in Mod(T ,A);\n(3) an ELQ-materialization of T and A iff it is sim-initial in Mod(T ,A), provided that T is an ALCF-TBox.\nThe \u2018only if\u2019 directions of all three points hold without any of the assumed conditions on I .\nProof. We show that (1) follows from Lemma 12 and Lemma 13; (2) and (3) can be proved similarly. We start with the direction from right to left. Assume that I is i-sim-initial in Mod(T ,A). Since I is a model of T and A, we have I |= C(a) whenever T ,A |= C(a) for any ELIQ C(x) and a \u2208 Ind(A). Conversely, if T ,A 6|= C(a) then there exists a model J of T and A such that J 6|= C(a). There is an i-simulation from I to J . Thus, by the implication (2) \u21d2 (1) from Lemma 12, we have I 6|= C(a) as required.\nFor the direction from left to right, assume that I is a materialization of T and A and take a model J of T and A. We have to construct an i-simulation from I to J . It actually suffices to construct an i-simulation from I to the i-unfolding J i of J : by Point (3) of Lemma 13, there is a homomorphism from J i to J and the composition of an i-simulation with a homomorphism is again an i-simulation.\nTo obtain an i-simulation from I to J i, we first identify a subinterpretation J \u2032 of J i that has finite outdegree and is still a model of T and A. By the implication (1) \u21d2 (2) from Lemma 12 and since I is a materialization, there must then be an i-simulation from I to J \u2032. Clearly this is also an i-simulation from I to J i and we are done.\nIt thus remains to construct J \u2032, which is done by applying selective filtration to J i in exactly the same way as in the proof of Lemma 11. It can be verified that the outdegree of the resulting subinterpretation J \u2032 of J i is bounded by |T | + |A| and, therefore, finite. By construction, J \u2032 \u2208 Mod(T ,A). \u274f\nThe following example shows that the generatedness condition in Theorem 14 cannot be dropped. We leave it open whether the same is true for countability.\nExample 15. Let T = {A \u2291 \u2203r.A,B \u2291 A} and A = {B(a)} and consider the interpretation I defined by\n\u2206I = {a} \u222a {0, 1, 2 . . .} \u222a {. . . ,\u22122\u2032,\u22121\u2032, 0\u2032, 1\u2032, 2\u2032, . . . }\nAI = \u2206I\nBI = {a}\nrI = {(a, 0)} \u222a {(n, n+ 1) | n \u2208 N} \u222a {(n\u2032, n\u2032 + 1) | n \u2208 Z}.\nThen I is a PEQ-materialization of T and A, but it is not hom-initial (and in fact not even siminitial) since the restriction of I to domain {a} \u222a {0, 1, 2 . . .} is also a model of T and A, but there is no homomorphism (and no simulation) from I to this restriction preserving {a}.\nAs an application of Theorem 14, we now show that materializability coincides for the query languages PEQ, CQ, and ELIQ (and that for ALCF-TBoxes, all these also coincide with ELQmaterializability).\nTheorem 16. Let T be an ALCFI-TBox. Then the following conditions are equivalent: (1) T is PEQ-materializable; (2) T is CQ-materializable; (3) T is ELIQ-materializable; (4) Mod(T ,A) contains an i-sim-initial I , for every ABox A that is consistent w.r.t. T ; (5) Mod(T ,A) contains a hom-initial I , for every ABox A that is consistent w.r.t. T .\nIf T is an ALCF-TBox, then the above is the case iff T is ELQ-materializable iff Mod(T ,A) contains a sim-initial I , for every ABox A that is consistent w.r.t. T .\nProof. The implications (1) \u21d2 (2) and (2) \u21d2 (3) are trivial. For (3) \u21d2 (4), let I be an ELIQmaterialization of T and an ABox A. By Lemma 11, we may assume that I is countable and generated. By Lemma 14, Mod(T ,A) contains an i-sim-initial interpretation. For (4) \u21d2 (5), assume that I \u2208 Mod(T ,A) is i-sim-initial. By Points (3) and (5) of Lemma 13, the i-unfolding of I is hom-initial in Mod(T ,A) and (5) follows. (5) \u21d2 (1) follows from Theorem 14. The implications for ALCF-TBoxes are proved similarly. \u274f\nBecause of Theorem 16, we sometimes speak of materializability without reference to a query language and of materializations instead of PEQ-materializations.\n3.2. Materializability and CONP-hardness. We show that non-materializability implies CONPhardness of query evaluation. To this end, we first establish that materializability is equivalent to the disjunction property, which is sometimes also called convexity and plays a central role in attaining PTIME complexity for subsumption in DLs [BBL05], and for attaining PTIME data complexity for query answering with DL TBoxes [KL07].\nA TBox T has the ABox disjunction property for ELIQ (resp. ELQ) if for all ABoxes A, individuals a0, . . . , ak \u2208 Ind(A), and ELIQs (resp. ELQs) C0(x), . . . , Cn(x), T ,A |= C0(a0) \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ck(ak) implies T ,A |= Ci(ai) for some i \u2264 k.\nTheorem 17. An ALCFI- (ALCF-) TBox T is materializable iff it has the ABox disjunction property for ELIQs (ELQs).\nProof. For the nontrivial \u201cif\u201d direction, let A be an ABox that is consistent w.r.t. T and such that there is no ELIQ-materialization of T and A. Then T \u222a A \u222a \u0393 is not satisfiable, where\n\u0393 = {\u00acC(a) | T ,A 6|= C(a), a \u2208 Ind(A), C(x) ELIQ}.\nIn fact, any satisfying interpretation would be an ELIQ-materialization. By compactness, there is a finite subset \u0393\u2032 of \u0393 such that T \u222a A \u222a \u0393\u2032 is not satisfiable, i.e. T ,A |= \u2228 \u00acC(a)\u2208\u0393\u2032 C(a). Since \u0393\u2032 \u2286 \u0393, we have T ,A 6|= C(a) for all \u00acC(a) \u2208 \u0393\u2032. Thus, T lacks the ABox disjunction property. \u274f\nBased on Theorems 16 and 17, we now establish that materializability is a necessary condition for query-evaluation to be it PTIME.\nTheorem 18. If an ALCFI-TBox T (ALCF-TBox T ) is not materializable, then ELIQ-evaluation (ELQ-evaluation) w.r.t. T is CONP-hard.\nProof. The proof is by reduction of 2+2-SAT, a variant of propositional satisfiability that was first introduced by Schaerf as a tool for establishing lower bounds for the data complexity of query answering in a DL context [Sch93]. A 2+2 clause is of the form (p1 \u2228 p2 \u2228 \u00acn1 \u2228 \u00acn2), where each of p1, p2, n1, n2 is a propositional letter or a truth constant 0, 1. A 2+2 formula is a finite conjunction of 2+2 clauses. Now, 2+2-SAT is the problem of deciding whether a given 2+2 formula is satisfiable. It is shown in [Sch93] that 2+2-SAT is NP-complete.\nWe first show that if an ALCFI-TBox T is not materializable, then UELIQ-evaluation w.r.t. T is CONP-hard, where a UELIQ is a disjunction C0(x) \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ck(x), with each Ci(x) an ELIQ. We then sketch the modifications necessary to lift the result to ELIQ-evaluation w.r.t. T .\nSince T is not materializable, by Theorem 16 it does not have the disjunction property. Thus, there is an ABox A\u2228, individual names a1, . . . , ak \u2208 Ind(A), and ELIQs C0(x), . . . , Ck(x) such\nthat T ,A\u2228 |= C0(a0) \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ck(ak), but T ,A\u2228 6|= Ci(ai) for all i \u2264 k. Assume w.l.o.g. that this sequence is minimal, i.e., T ,A\u2228 6|= C0(a0)\u2228 \u00b7 \u00b7 \u00b7 \u2228Ci\u22121(ai\u22121)\u2228Ci+1(ai+1)\u2228 \u00b7 \u00b7 \u00b7 \u2228Ck(ak) for all i \u2264 k. This clearly implies that for all i \u2264 k,\n(\u2217) there is a model Ii of T and A\u2228 with I |= Ci(ai) and I 6|= Cj(aj) for all j 6= i. We will use A\u2228, the individuals a1, . . . , ak, and the ELIQs C0(x), . . . , Ck(x) to generate truth values for variables in the input 2+2 formula.\nLet \u03d5 = c0 \u2227 \u00b7 \u00b7 \u00b7 \u2227 cn be a 2+2 formula in propositional letters z0, . . . , zm, and let ci = pi,1 \u2228 pi,2 \u2228 \u00acni,1 \u2228 \u00acni,2 for all i \u2264 n. Our aim is to define an ABox A\u03d5 with a distinguished individual name f and a UELIQ q(x) such that \u03d5 is unsatisfiable iff T ,A\u03d5 |= q(f). To start, we represent the formula \u03d5 in the ABox A\u03d5 as follows:\n\u2022 the individual name f represents the formula \u03d5; \u2022 the individual names c0, . . . , cn represent the clauses of \u03d5; \u2022 the assertions c(f, c0), . . . , c(f, cn), associate f with its clauses, where c is a role name that\ndoes not occur in T ; \u2022 the individual names z0, . . . , zm represent variables, and the individual names 0, 1 represent\ntruth constants; \u2022 the assertions \u22c3\ni\u2264n\n{p1(ci, pi,1), p2(ci, pi,2), n1(ci, ni,1), n2(ci, ni,2)}\nassociate each clause with the variables/truth constants that occur in it, where p1, p2, n1, n2 are role names that do not occur in T .\nWe further extend A\u03d5 to enforce a truth value for each of the variables zi. To this end, add to A\u03d5 copies A0, . . . ,Am of A\u2228 obtained by renaming individual names such that Ind(Ai)\u2229 Ind(Aj) = \u2205 whenever i 6= j. As a notational convention, let aij be the name used for the individual name aj \u2208 Ind(A\u2228) in Ai for all i \u2264 m and j \u2264 k. Intuitively, the copy Ai of A is used to generate a truth value for the variable zi. To actually connect each individual name zi to the associated ABox Ai, we use role names r0, . . . , rk that do not occur in T . More specifically, we extend A\u03d5 as follows:\n\u2022 link variables zi to the ABoxes Ai by adding assertions rj(zi, aij) for all i \u2264 m and j \u2264 k; thus, truth of zi means that the concept \u2203r0.C0 is true at zi and falsity means that one of the concepts \u2203rj.Cj , j \u2264 k, is true at zi; \u2022 to ensure that 0 and 1 have the expected truth values, add a copy of C0(x) viewed as an ABox with root 1\u2032 and a copy of C2(x) viewed as an ABox with root 0\u2032; add r0(1, 1\u2032) and r1(0, 0\n\u2032). Consider the query q0(x) = C(x) with\nC = \u2203c.(\u2203p1.ff \u2293 \u2203p2.ff \u2293 \u2203n1.tt \u2293 \u2203n2.tt)\nwhich describes the existence of a clause with only false literals and thus captures falsity of \u03d5, where tt is an abbreviation for \u2203r0.C0 and ff an abbreviation for the ELU -concept \u2203r1.C1 \u2294 \u00b7 \u00b7 \u00b7 \u2294 \u2203rk.Ck. It is straightforward to show that \u03d5 is unsatisfiable iff T ,A |= q0(f). To obtain the desired UELIQ q(x), it remains to take q0(x) and distribute disjunction to the outside.\nWe now show how to improve the result from UELIQ-evaluation to ELIQ-evaluation. Our aim is to change the encoding of falsity of a variable zi from satisfaction of \u2203r1.C1 \u2294 \u00b7 \u00b7 \u00b7 \u2294 \u2203rk.Ck at zi to satisfaction of \u2203h.(\u2203r1.C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rk.Ck), at zi, where h is an additional role that does not\noccur in T . We can then replace the concept ff in the query q0 with \u2203h.(\u2203r1.C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rk.Ck), which gives the desired ELIQ q(x).\nIt remains to modify A\u03d5 to support the new encoding of falsity. The basic idea is that each zi has k successors bi1, . . . , b i k reachable via h such that for 1 \u2264 j \u2264 k,\n\u2022 \u2203r\u2113.C\u2113 is satisfied at bij for all \u2113 = 1, . . . , j \u2212 1, j + 1, . . . , k and \u2022 the assertion rj(bij , a i j) is in A\u03d5.\nThus, \u2203r1.C1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rk.Ck is satisfied at bij iff Cj is satisfied at a i j , for all j with 1 \u2264 j \u2264 k. In detail, the modification of A\u03d5 is as follows:\n\u2022 for 1 \u2264 j \u2264 k, add to A\u03d5 a copy of Cj viewed as an ABox, where the root individual name is dj ; \u2022 for all i \u2264 m, replace the assertions rj(zi, aij), 1 \u2264 j \u2264 k, with the following: \u2013 h(zi, bi1), . . . , h(zi, b i k) for all i \u2264 m;\n\u2013 rj(bij , a i j), r1(b i j , d1), . . . , rj\u22121(b i j , dj\u22121),\nrj+1(b i j , dj+1), . . . , rk(b i j , dk) for all i \u2264 m and 1 \u2264 j \u2264 k.\nThis finishes the modified construction. Again, it is not hard to prove correctness.\nIt remains to note that, when T is an ALCF-TBox, then the above construction of q yields an ELQ instead of an ELIQ. \u274f\nThe converse of Theorem 18 fails, i.e., there are TBoxes that are materializable, but for which ELIQevaluation is CONP-hard. In fact, materializations of such a TBox T and ABox A are guaranteed to exist, but cannot always be computed in PTIME (unless PTIME = CONP). Technically, this follows from Theorem 28 later on which states that for every non-uniform CSP, there is a materializable ALC-TBox for which Boolean CQ-answering has the same complexity, up to complementation of the complexity class.\n3.3. Complexity of TBoxes for Different Query Languages. We make use of our results on materializability to show that PTIME query evaluation w.r.t. ALCFI-TBoxes does not depend on whether we consider PEQs, CQs, or ELIQs, and the same is true for Datalog6=-rewritability. For ALCF-TBoxes, we can add ELQs to the list. Theorem 19 below gives a uniform explanation for the fact that, in the traditional approach to data complexity in OBDA, the complexity of evaluating PEQs, CQs, and ELIQs has turned out to be identical for almost all DLs. It allows us to (sometimes) speak of the \u2018complexity of query evaluation\u2019 without reference to a concrete query language.\nTheorem 19. For all ALCFI-TBoxes T , (1) PEQ-evaluation w.r.t. T is in PTIME iff CQ-evaluation w.r.t. T is in PTIME iff ELIQ-\nevaluation w.r.t. T is in PTIME; (2) T is Datalog6=-rewritable for PEQ iff it is Datalog6=-rewritable for CQ iff it is Datalog6=-\nrewritable for ELIQ (unless PTIME = CONP); (3) PEQ-evaluation w.r.t. T is CONP-hard iff CQ-evaluation w.r.t. T is CONP-hard iff ELIQ-\nevaluation w.r.t. T is CONP-hard. If T is an ALCF-TBox, then ELIQ can be replaced by ELQ in (1), (2), and (3). If T is an ALCI TBox, then Datalog6=-rewritability can be replaced by Datalog-rewritability in (2).\nProof. We start with Points (1) and (2), for which the \u201conly if\u201d directions are trivial. For the converse directions, we may assume by Theorem 18 that the TBox T is materializable. The implications from CQ to PEQ in Points (1) and (2) follow immediately from this assumption: one can first transform a given PEQ q(~x) into an equivalent disjunction of CQs \u2228 i\u2208I qi(~x). CQ-materializability of T implies that, for any ABox A and ~a in Ind(A), T ,A |= q(~a) iff there exists i \u2208 I such that T ,A |= qi(~a). Thus if CQ-evaluation w.r.t. T is in PTIME, evaluation of (T , q(~x)) is in PTIME. The same holds for Datalog6=-rewritability because the class of Datalog6=-queries is closed under finite union.\nWe now consider the implications from ELIQ to CQ (and from ELQ to CQ if T is a ALCFTBox) in Points (1) and (2), first concentrating on the PTIME case. The following claim is the main step of the proof. It states that for any CQ q(~x), we can reduce the evaluation of q(~x) w.r.t. T on an ABox A to evaluating quantifier-free CQs and ELIQs C(x) w.r.t. T (ELQs if T is an ALCF-TBox), both on A.\nClaim 1. For any materializable TBox T and CQ q(~x) with ~x = x1 \u00b7 \u00b7 \u00b7 xn, one can construct a finite set Q of pairs (\u03d5(~x, ~y), C), where\n\u2022 \u03d5(~x, ~y) is a (possibly empty) conjunction of atoms of the form x = y or r(x, y), where r is a role name in q(~x) and\n\u2022 C is a finite set of ELIQs such that the following conditions are equivalent for any ABox A and ~a = a1 \u00b7 \u00b7 \u00b7 an from Ind(A):\n(i) T ,A |= q(~a); (ii) there exists (\u03d5(~x, ~y), C) \u2208 Q and an assignment \u03c0 in Ind(A) with \u03c0(xi) = ai for 1 \u2264 i \u2264 n,\nA |=\u03c0 \u03d5(~x, ~y), and T ,A |= C(\u03c0(x)) for all C(x) \u2208 C.\nIf T is an ALCF-TBox, then one can choose ELQs instead of ELIQs in each C in Q.\nBefore we prove Claim 1, we show how the desired results follow from it. Let a CQ q(~x) be given and let Q be the set of pairs from Claim 1.\n\u2022 Assume that ELIQ-evaluation w.r.t. T is in PTIME. Then T ,A |= q(~a) can be decided in polynomial time since there are only polynomially many assignments \u03c0 and for any such \u03c0, A |=\u03c0 \u03d5(~x, ~y) can be checked in polynomial time (using a naive algorithm) and T ,A |= C(\u03c0(x)) can be checked in polynomial time for each ELIQ C(x) \u2208 C. \u2022 Assume that T is Datalog6=-rewritable for ELIQ. Let p = (\u03d5(~x, ~y), C) \u2208 Q. For each C(x) \u2208 C, choose a Datalog6=-rewriting \u03a0C(x) of (T , C(x)), assume w.l.o.g that none of the chosen programs share any IDB relations, and that the goal relation of \u03a0C(x) is goalC . Let \u03a0p be the Datalog6= program that consists of the rules of all the chosen programs, plus the following rule:\ngoal(~x) \u2190 \u03d5(~x, ~y) \u2227 \u2227\nC(x)\u2208C\ngoalC(x).\nThe desired Datalog6=-rewriting of (T , q(~x)) is obtained by taking the union of all the constructed Datalog6= queries, which can again be expressed in Datalog6=.\nThe implications from ELQs to CQs for ALCF-TBoxes in Points (1) and (2) follow in the same way since, then, each C in Q consists of ELQs only.\nFor the proof of Claim 1, we first require a technical observation that allows us to deal with subqueries that are not connected to an answer variable in the CQ q(~x). To illustrate, consider the query q0 = \u2203xB(x). To prove Claim 1 for q0, we have to find a set Q of pairs (\u03d5(~y), C) satisfying Conditions (i) and (ii). Clearly, in this case the components \u03d5(~y) will be empty and so we have\nto construct a finite set C of ELIQs such that for any ABox A, T ,A |= \u2203xB(x) iff there exists an ELIQ C(x) \u2208 C and an assignment \u03c0 in Ind(A) such that T ,A |= C(\u03c0(x)). An infinite set C with this property is given by the set of all ELIQs \u2203~r.B(x), where ~r is a sequence r1 \u00b7 \u00b7 \u00b7 rn of roles ri in T and \u2203~r.B stands for \u2203r1 \u00b7 \u00b7 \u00b7 \u2203rn.B\u2014this follows immediately from the assumption that T is materializable and that, by Lemma 11, for any ABox A that is consistent w.r.t. T , there exists a generated CQ-initial model of T and ABox A. The following result states that it is sufficient to include in C the set of all \u2203~r.B(x) with ~r of length bounded by n0 := 2(2(|T |+|C|) \u00b7 2|T |+ 1.\nClaim 2. Let C be an ELI-concept and assume that T ,A |= \u2203xC(x). If T is materializable, then there exists a sequence of roles ~r = r1 \u00b7 \u00b7 \u00b7 rn with ri in T and of length n \u2264 n0 and an a \u2208 Ind(A) such that T ,A |= \u2203~r.C(a). If C is an EL-concept and T an ALCF-TBox, then the sequence ~r consists of role names in T .\nProof of Claim 2. Let I be a CQ-materialization of T and A. By Points (3) and (5) of Lemma 13, we may assume that I is i-unfolded. From T ,A |= \u2203xC(x), we obtain CI 6= \u2205. Let n be minimal such that there are a \u2208 Ind(A) and d \u2208 CI with n = distI(d, a) where distI(d, a) denotes the length of the shortest path from d to a in the undirected graph GI . If n \u2264 n0, we are done. Otherwise fix an a \u2208 Ind(A) and denote by M the set all e \u2208 CI with n = distI(e, a). Let d0, . . . , dn with a = d0, dn = d, and (di, di+1) \u2208 rIi+1 for i < n be the shortest path from a to d. Observe that T ,A |= \u2203~r.C(a) for ~r = r0 \u00b7 \u00b7 \u00b7 rn\u22121 since I is a materialization of T and A. We now employ a pumping argument to show that this leads to a contradiction. Let cl(T , C) denote the closure under single negation of the set of subconcepts of concepts in T and C . Set\ntIT ,C(e) = {D \u2208 cl(T , C) | e \u2208 D I}.\nAs n > n0, then there exist di and di+j with j > 1 and i+ j < n such that\ntIT ,C(di) = t I T ,C(di+j), t I T ,C(di+1) = t I T ,C(di+j+1), ri+1 = ri+j+1\nNow replace in I the interpretation induced by the subtree rooted at di+j+1 by the interpretation induced by the subtree rooted at di+1. We do the same construction for all elements of M and denote the resulting interpretation by J . One can easily show by induction that J is still a model of T and A, but now J 6|= \u2203~r.C(a) and so T ,A 6|= \u2203~r.C(a). This contradiction finishes the proof of Claim 2. For EL-concepts and ALCF-TBoxes, Claim 2 can be proved similarly by using an unfolded (rather than i-unfolded) materialization, which exists by Points (4) and (6) of Lemma 13.\nProof of Claim 1. Assume that T and q(~x) = \u2203~x\u03c8(~x, ~y) are given. We have to construct a set Q such that Conditions (i) and (ii) are satisfied. Let A be an ABox with T ,A |= q(~a), I a materialization of T and A that is i-unfolded, and \u03c0 an assignment in I such that I |=\u03c0 \u03c8(~x, ~y). We define a corresponding pair p = (\u03d5(~x, ~z), C) to be included in Q (and these are the only pairs in Q).\nFor identifying \u03d5(~x, ~z), set x \u223c y if \u03c0(x) = \u03c0(y) and denote by [x] the equivalence class of x w.r.t. \u201c\u223c\u201d. Let \u03d50 be the set of all atoms r([x], [y]) such that \u03c0(x), \u03c0(y) \u2208 Ind(A) and there are x\u2032 \u2208 [x] and y\u2032 \u2208 [y] with r(x\u2032, y\u2032) in \u03c8. We obtain \u03d5(~x, ~y) by selecting an answer variable y \u2208 [x] for every [x] that contains such a variable and then replacing [x] by y in \u03d50, adding xi = xj to \u03d5(~x, ~z) for any two (selected) answer variables xi, xj with xi \u223c xj , and by regarding the remaining equivalences classes [y] that do not contain answer variables as variables in ~z.\nWe now identify C. Assume w.l.o.g. that I uses the naming scheme of i-unravelings. Let a \u2208 Ind(A). By Ia, we denote the subinterpretation of I induced by the set of all elements ar1d1 \u00b7 \u00b7 \u00b7 rndn \u2208 \u2206\nI . Let M be a maximal connected component of \u2206Ia \u2229 {\u03c0(y) | y \u2208 var(\u03c8)}. We associate with M an ELIQ to be included in C (and these are the only ELIQs in C).\nThe conjunctive query \u03d5M consists of all atoms r([x], [y]) such that \u03c0(x), \u03c0(y) \u2208 M and there are x\u2032 \u2208 [x], y\u2032 \u2208 [y] with r(x\u2032, y\u2032) in \u03c8 and all atoms A([x]) such that \u03c0(x) \u2208 M and there is x\u2032 \u2208 [x] with A(x\u2032) in \u03c8. We again assume that equivalence classes [x] that contain an answer variable (there is at most one such class in \u03d5M ) are replaced with an answer variable from [x] and regard the remaining equivalences classes as variables. Note that \u03d5M is tree-shaped since Ia is. We can thus pick a variable x0 with \u03c0(x0) \u2208 M such that distI(a, \u03c0(x0)) is minimal. Let x be [x0] if [x0] contains no answer variable and, otherise, let x be the answer variable that [x0] has been replaced with. Let [y1], . . . , [ym] be the variables in \u03d5M that are distinct from x and consider the ELIQ \u2203[y1] \u00b7 \u00b7 \u00b7 \u2203[ym]\u03d5M (x, [y1], . . . , [ym]), which we write as CM (x) where CM is an appropriate ELI-concept. We now distinguish the following cases:\n\u2022 \u03c0(x) = a. In this case, we include CM (x) in C; \u2022 otherwise, we still know that T ,A |= \u2203xC(x). Thus, by Claim 2 there is a sequence\nof roles ~r = r1 \u00b7 \u00b7 \u00b7 rn with ri in T and n \u2264 n0 such that T ,A |= \u2203~r.CM (a) for some a \u2208 Ind(A) . In this case, we include \u2203~r.CM (y) in C for some fresh individual variable y.\nThis finishes the construction of C and thus of Q. Clearly, Q is finite. The stated properties of Q follow directly from its construction. For ALCF-TBoxes and ELQs, Claim 1 can be proved similarly using an unfolded materialization (instead of an i-unfolded one) and the observation that in this case all CM ([x]) and \u2203~r.CM (y) are ELQs (~r uses role names only by Claim 2).\nWe now turn our attention to Point (3). Here, the \u201cif\u201d directions are trivial and we prove the \u201conly if\u201d part. It suffices to show that if PEQ-evaluation w.r.t. a TBox T is CONP-hard, then so is ELIQ-evaluation. We start with showing the slightly simpler result that CONP-hardness of CQevaluation w.r.t. T implies CONP-hardness of UELIQ-evaluation, and then sketch the modifications required to strengthen the proof to attain the original statement.\nThus assume that evaluating the CQ q(~x) w.r.t. T is CONP-hard. We shall exhibit an UELIQ q\u2032(x) such that for every ABox A and all ~a \u2208 Ind(A), one can produce in polynomial time an ABox A\u2032 with a distinguished individual a0 such that T ,A |= q(~a) iff T ,A\u2032 |= q\u2032(a0). Instead of constructing q\u2032(~x) right away, we will start with describing the translation of A to A\u2032. Afterwards, it will be clear how to construct q\u2032(~x).\nThus, let A be an ABox and ~a from Ind(A). The construction of A\u2032 builds on Claim 1 above. Let Q be the set of pairs from that claim and reserve a fresh individual name a0. To obtain the desired ABox A\u2032, we extend A for every pair p = (\u03d5(~x, ~y), C) in Q. Let C = Cp,1(x1), . . . , Cp,kp(xkp). Then\n\u2022 introduce a fresh individual name ap and fresh role names rp, r, rp,1, . . . , rp,kp ; \u2022 add the assertion rp(a0, ap); \u2022 for every assignment \u03c0 in Ind(A) with A |=\u03c0 \u03d5(~x, ~y) and \u03c0(~x) = ~a, introduce\n\u2013 a fresh individual name ap,\u03c0 and the assertion r(ap, ap,\u03c0); \u2013 the assertion rp,i(ap, \u03c0(xi)) for 1 \u2264 i \u2264 kp.\nFrom Claim 1, it is immediate that T ,A |= q(~a) iff T ,A\u2032 |= q\u2032(x) where q\u2032(x) is the UELIQ \u2294 p\u2208Q q\u2032(x) with Cp = \u2203rp.\u2203r. \u2293 1\u2264i\u2264kp \u2203rp,i.Cp,i. Thus, evaluating q\u2032(x) w.r.t. T is CONP-hard, as required. It remains to modify the reduction by replacing CQs with PEQs and UELIQs with ELIQs. The former is straightforward: every PEQ is equivalent to a finite disjunction of CQs, and thus we can construct A\u2032 and q\u2032(x) in essentially the same way as before; instead of considering all pairs from Q for a single CQ, we now use the union of all sets Q for the finitely many CQs in question. Finally, we can replace UELIQs with ELIQs by using the same construction as in the proof of Theorem 18: after adding some straightforward auxiliary structure to A\u2032, one can replace a\ndisjunction of ELIQs by (essentially) their conjunction, which is again an ELIQ. Details are left to the reader. \u274f\nWe remark that Theorem 19 can be extended to also cover rewritability into first-order (FO) queries, and that the proof is almost identical to that for Datalog6=-rewritability."}, {"heading": "4. UNRAVELING TOLERANCE", "text": "We develop a condition on TBoxes, called unraveling tolerance, that is sufficient for the TBox to be Datalog6=-rewritable for PEQ, and thus also sufficient for PEQ-evaluation w.r.t. the TBox being in PTIME. Unraveling tolerance strictly generalizes syntactic \u2018Horn conditions\u2019 such as the ones used to define the DL Horn-SHIQ, which was designed as a (syntactically) maximal DL with PTIME query evaluation [HMS07, EGOS08].\nUnraveling tolerance is based on an unraveling operation on ABoxes, in the same spirit as the unfolding of an interpretation into a tree interpretation we discussed above. Formally, the unraveling Au of an ABox A is the following (possibly infinite) ABox:\n\u2022 Ind(Au) is the set of sequences b0r0b1 \u00b7 \u00b7 \u00b7 rn\u22121bn, n \u2265 0, with b0, . . . , bn \u2208 Ind(A) and r0, . . . , rn\u22121 \u2208 NR\u222aN \u2212 R such that for all i < n, we have ri(bi, bi+1) \u2208 A and (bi\u22121, r \u2212 i\u22121) 6=\n(bi+1, ri) when i > 0; \u2022 for each C(b) \u2208 A and \u03b1 = b0r0 \u00b7 \u00b7 \u00b7 rn\u22121bn \u2208 Ind(Au) with bn = b, C(\u03b1) \u2208 Au; \u2022 for each \u03b1 = b0r0 \u00b7 \u00b7 \u00b7 rn\u22121bn \u2208 Ind(Au) with n > 0, rn\u22121(b0r0 \u00b7 \u00b7 \u00b7 rn\u22121bn\u22121, \u03b1) \u2208 Au.\nFor all \u03b1 = b0 \u00b7 \u00b7 \u00b7 bn \u2208 Ind(Au), we write tail(\u03b1) to denote bn. Note that the condition (bi\u22121, r \u2212 i\u22121) 6= (bi+1, ri) is needed to ensure that functional roles can still be interpreted in a functional way after unraveling.\nDefinition 20 (Unraveling Tolerance). A TBox T is unraveling tolerant if for all ABoxes A and ELIQs q, we have that T ,A |= q implies (T ,Au) |= q.\nIt is not hard to prove that the converse direction \u2018T ,Au |= q implies T ,A |= q\u2019 is true for all ALCFI-TBoxes. Note that it is pointless to define unraveling tolerance for queries that are not necessarily tree shaped, such as CQs.\nExample 21. (1) The ALC-TBox T1 = {A \u2291 \u2200r.B} is unraveling tolerant. This can be proved by showing that (i) for any (finite or infinite) ABox A, the interpretation I+A that is obtained from A by extending BI +\nA with all a \u2208 Ind(A) that satisfy \u2203r\u2212.A in A (when viewed as an interpretation) is an ELIQmaterialization of T1 and A; and (ii) I + A |= C(a) iff I + Au |= C(a) for all ELIQs C(x) and a \u2208 Ind(A). The proof of (ii) is based on a straightforward induction on the structure of the ELIconcept C . As illustrated by the ABox A = {r(a, b), A(a)} and the fact that Au,T |= B(b), the use of inverse roles in the definition of Au is crucial here despite the fact that T1 does not use inverse roles.\n(2) A simple example for an ALC-TBox that is not unraveling tolerant is\nT2 = {A \u2293 \u2203r.A \u2291 B,\u00acA \u2293 \u2203r.\u00acA \u2291 B}.\nFor A = {r(a, a)}, it is easy to see that we have T2,A |= B(a) (use a case distinction on the truth value of A at a), but T2,Au 6|= B(a).\nBefore we show that unraveling tolerance indeed implies PTIME query evaluation, we first demonstrate the generality of this property by relating it to Horn-ALCFI , the ALCFI-fragment of HornSHIQ. Different versions of Horn-SHIQ have been proposed in the literature, giving rise to different versions of Horn-ALCFI [HMS07, KRH07, EGOS08, Kaz09]. As the original definition from [HMS07] based on polarity is rather technical, we prefer to work with the following equivalent and less cumbersome definition. A Horn-ALCFI-TBox T is a finite set of concept inclusions L \u2291 R and functionality assertions where L and R are built according to the following syntax rules:\nR,R\u2032 ::=\u22a4 | \u22a5 | A | \u00acA | R \u2293R\u2032 | L \u2192 R | \u2203r.R | \u2200r.R\nL,L\u2032 ::=\u22a4 | \u22a5 | A | L \u2293 L\u2032 | L \u2294 L\u2032 | \u2203r.L\nwith r ranging over NR \u222a N \u2212 R\nand L \u2192 R abbreviating \u00acL \u2294 R. Whenever convenient, we may assume w.l.o.g. that T contains only a single concept inclusion \u22a4 \u2291 CT where CT is built according to the topmost rule above.\nBy applying some simple transformations, it is not hard to show that every Horn-ALCFITBox according to the original polarity-based definition is equivalent to a Horn-ALCFI-TBox of the form introduced here. Although not important in our context, we note that even a polynomial time transformation is possible.\nTheorem 22. Every Horn-ALCFI-TBox is unraveling tolerant.\nProof. As a preliminary, we give a characterization of the entailment of ELIQs in the presence of Horn-ALCFI-TBoxes which is in the spirit of the chase procedure as used in database theory [FKMP05, CGK13] and of consequence-driven algorithms as used for reasoning in Horn description logics such as EL++ and Horn-SHIQ [BBL05, Kaz09, Kro\u030810b].\nWe use extended ABoxes, i.e., finite sets of assertions C(a) and r(a, b) with C a potentially compound concept. An ELIU\u22a5-concept is a concept that is formed according to the second syntax rule in the definition of Horn-ALCFI . For an extended ABox A\u2032 and an assertion C(a), C an ELIU\u22a5-concept, we write A\u2032 \u22a2 C(a) if C(a) has a syntactic match in A\u2032, formally:\n\u2022 A\u2032 \u22a2 \u22a4(a) is unconditionally true; \u2022 A\u2032 \u22a2 \u22a5(a) if \u22a5(b) \u2208 A\u2032 for some b \u2208 Ind(A); \u2022 A\u2032 \u22a2 A(a) if A(a) \u2208 A\u2032; \u2022 A\u2032 \u22a2 C \u2293D(a) if A\u2032 \u22a2 C(a) and A\u2032 \u22a2 D(a); \u2022 A\u2032 \u22a2 C \u2294D(a) if A\u2032 \u22a2 C(a) or A\u2032 \u22a2 D(a); \u2022 A\u2032 \u22a2 \u2203r.C(a) if there is an r(a, b) \u2208 A\u2032 such that A\u2032 \u22a2 C(b).\nNow for the announced characterization. Let T = {\u22a4 \u2291 CT } be a Horn-ALCFI-TBox and A a potentially infinite ABox (so that the characterization also applies to unravelings of ABoxes). We produce a sequence of extended ABoxes A0,A1, . . . , starting with A0 = A. In what follows, we use additional individual names of the form ar1C1 \u00b7 \u00b7 \u00b7 rkCk with a \u2208 Ind(A0), r1, . . . , rk roles that occur in T , and C1, . . . , Ck subconcept of concept in T . We assume that NI contains such names as needed and use the symbols a, b, . . . also to refer to individual names of this compound form. Each extended ABox Ai+1 is obtained from Ai by applying the following rules in a fair way:\nR1 if a \u2208 Ind(Ai), then add CT (a). R2 if C \u2293D(a) \u2208 Ai, then add C(a) and D(a); R3 if C \u2192 D(a) \u2208 Ai and Ai \u22a2 C(a), then add D(a); R4 if \u2203r.C(a) \u2208 Ai and func(r) /\u2208 T , then add r(a, arC) and C(arC); R5 if \u2203r.C(a) \u2208 Ai, func(r) \u2208 T , and r(a, b) \u2208 Ai, then add C(b);\nR6 if \u2203r.C(a) \u2208 Ai, func(r) \u2208 T , and there is no r(a, b) \u2208 Ai, then add r(a, arC) and C(arC); R7 if \u2200r.C(a) \u2208 Ai and r(a, b) \u2208 Ai, then add C(b).\nLet Ac = \u22c3 i\u22650Ai be the completion of the original ABox A. 2 Note that Ac may be infinite even if A is finite, and that none of the above rules is applicable in Ac. We write \u2018Ac \u22a2 \u22a5\u2019 instead of \u2018Ac \u22a2 \u22a5(a) for some a \u2208 NC\u2019. If A 6\u22a2 \u22a5, then Ac corresponds to an interpretation Ic in the standard way, i.e.,\n\u2206Ic = Ind(Ac) AIc = {a | A(a) \u2208 Ac} for all A \u2208 NC rIc = {r(a, b) | r(a, b) \u2208 Ac} for all r \u2208 NR\nwhere in Ic we assume that only the individual names in Ind(A) are elements of NI.\nClaim 1. If Ac 6\u22a2 \u22a5, then Ic is a PEQ-materialization of T and A.\nTo prove Claim 1 it suffices to show that there is a homomorphism h preserving Ind(A) into any model J of T and A and that Ic is a model of T and A. The homomorphism h can be constructed inductively following the construction of Ac. Similarly, following the construction of Ac it is readily checked that Ic is a model of T and A. Using Claim 1 and the easily proved fact that Ac 6\u22a2 \u22a5 iff A is consistent w.r.t. T one can now prove\nClaim 2. T ,A |= C(a) iff Ac \u22a2 C(a) or Ac \u22a2 \u22a5, for all ELIQs C(x) and a \u2208 Ind(A).\nWe now turn to the actual proof of Theorem 22. Consider the application of the above completion construction to both the original ABox A and its unraveling Au. Recall that individuals in Au are of the form a0r0a1 \u00b7 \u00b7 \u00b7 rn\u22121an. Consequently, individuals in Auc take the form a0r0a1 \u00b7 \u00b7 \u00b7 rn\u22121ans1C1 \u00b7 \u00b7 \u00b7 skCk. For a \u2208 Ind(Ac) and \u03b1 \u2208 Ind(Auc ), we write a \u223c \u03b1 if a and \u03b1 are of the form ans1C1 \u00b7 \u00b7 \u00b7 skCk and a0r0a1 \u00b7 \u00b7 \u00b7 rn\u22121ans1C1 \u00b7 \u00b7 \u00b7 skCk, respectively, with k \u2265 0. Note that, in particular, a \u223c a for all a \u2208 Ind(A). The following claim can be shown by induction on i.\nClaim 3. For all a \u2208 Ind(Ai) and \u03b1 \u2208 Ind(Aui ) with a \u223c \u03b1, we have (1) Ai \u22a2 C(a) iff Aui \u22a2 C(\u03b1) for all ELI-concepts C; (2) C(a) \u2208 Ai iff C(\u03b1) \u2208 Aui for all subconcepts C of concepts in T . Now, unraveling tolerance of T follows from Claims 2 and 3. \u274f\nTheorem 22 shows that unraveling tolerance and Horn logic are closely related. Yet, the next example demonstrates that there are unraveling tolerant ALCFI-TBoxes that are not equivalent to any Horn sentence of FO. Since any Horn-ALCFI-TBox is equivalent to such a sentence, it follows that unraveling tolerant ALCFI-TBoxes strictly generalize Horn-ALCFI-TBoxes. This increased generality will pay off in Section 5 when we establish a dichotomy result for TBoxes of depth one.\nExample 23. Take the ALC-TBox\nT = {\u2203r.(A \u2293 \u00acB1 \u2293 \u00acB2) \u2291 \u2203r.(\u00acA \u2293 \u00acB1 \u2293 \u00acB2)}.\nOne can show as in Example 21 (1) that T is unraveling tolerant; here, the materialization is actually A itself rather than some extension thereof, i.e., as far as ELIQ (and even PEQ) evaluation is concerned, T cannot be distinguished from the empty TBox.\n2Order of rule application has an impact on the shape of Ac, but is irrelevant for the remainder of the proof.\nIt is well-known that FO Horn sentences are preserved under direct products of interpretations [CK90]. To show that T is not equivalent to any such sentence, it thus suffices to show that T is not preserved under direct products. This is simple: let I1 and I2 consist of a single r-edge between elements d and e, and let e \u2208 (A\u2293B1\u2293\u00acB2)I1 and e \u2208 (A\u2293\u00acB1\u2293B2)I2; then the direct product I of I1 and I2 still has the r-edge between (d, d) and (e, e) and satisfies (e, e) \u2208 (A\u2293\u00acB1 \u2293\u00acB2)I , thus is not a model of T .\nWe next show that unraveling tolerance is indeed a sufficient condition for Datalog6=-rewritability (and thus for PTIME query evaluation). In Section 6, we will establish a connection between query evaluation under DL TBoxes and constraint satisfaction problems (CSPs). The Datalog6= program constructed in the proof of the following result resembles canonical monadic Datalog programs for CSPs [FV93]. Note that it is not clear how to attain a proof of Theorem 24 via the CSP connection: first, as we will also see in Section 6, functional roles break this connection; and second, canonical Datalog programs are available only for Boolean queries while we construct programs for unary queries.\nTheorem 24. Every unraveling tolerant ALCFI-TBox is Datalog6=-rewritable for PEQ.\nProof. Let T be an unraveling tolerant ALCFI-TBox. By Theorem 19, it suffices to show that T is Datalog6=-rewritable for ELIQ. Let A be an ABox and q = C0(x) an ELIQ. Recall from the proof of Theorem 19 that cl(T , C0) denotes the closure under single negation of the set of subconcepts of T and C0. For an interpretation I and d \u2208 \u2206I , we use tIT ,q(d) to denote the set of concepts C \u2208 cl(T , C0) such that d \u2208 CI . A T , q-type is a subset t \u2286 cl(T , C0) such that for some model I of T , we have t = tIT ,q(d). We use tp(T , q) to denote the set of all T ,q-types. For t, t \u2032 \u2208 tp(T , q) and r a role, we write t r t\u2032 if there are a model I of T and d, d\u2032 \u2208 \u2206I such that tIT ,q(d) = t, tIT ,q(d \u2032) = t\u2032, and (d, d\u2032) \u2208 rI .\nIntroduce, for every set T \u2286 tp(T , C0) a unary IDB relation PT . Define a Datalog6= program \u03a0 that consists of the following rules:\n(1) PT (x) \u2190 A(x) for all concept names A \u2208 cl(T , C0) and T = {t \u2208 tp(T , q) | A \u2208 t}; (2) PT (x) \u2190 PT0(x) \u2227 r(x, y) \u2227 PT1(y) for all T0, T1 \u2286 tp(T , q) and all role names r that\noccur in cl(T , C0) and their inverses, where T = {t \u2208 T0 | \u2203t\u2032 \u2208 T1 : t r t\u2032}; (3) PT0\u2229T1(x) \u2190 PT0(x) \u2227 PT1(x) for all T0, T1 \u2286 tp(T , q); (4) goal(x) \u2190 PT (x) for all T \u2286 tp(T , q) such that t \u2208 T implies C0 \u2208 T ; (5) goal(x) \u2190 P\u2205(y); (6) goal(x) \u2190 r(y, z1) \u2227 r(y, z2) \u2227 z1 6= z2 for all func(r) \u2208 T .\nTo show that \u03a0 is a rewriting of the OMQ (T , C0(x)), it suffices to establish the following.\nClaim. A |= \u03a0(a0) iff T ,A |= C0(a0) for all ABoxes A and a0 \u2208 Ind(A).\nThe \u201cif\u201d direction is straightforward: by induction on the number of rule applications, one can show that whenever \u03a0 derives PT (a), then every model of T and A satisfies tIT ,q(a) \u2208 T . By definition of the goal rules of \u03a0, A |= \u03a0(a0) thus implies that every model of T and A makes C0(a0) true or that A is inconsistent w.r.t. T . Consequently, T ,A |= C0(a0).\nFor the \u201conly if\u201d direction, it suffices to show that A 6|= \u03a0(a0) implies T ,Au 6|= C0(a0) since T is unraveling tolerant. Because of the rules in \u03a0 of the form (3), for every a \u2208 Ind(A) we can find a unique minimal Ta such that PTa(a) is derived by \u03a0. Observe that, A(\u03b1) \u2208 A\nu, tail(\u03b1) = a, and t \u2208 Ta implies A \u2208 t because of the rules of the form (1) in \u03a0 and by construction of Au.\nWe first associate with every \u03b1 \u2208 Ind(Au) a concrete T , q-type t\u03b1 \u2208 Ttail(\u03b1). To start, we choose ta \u2208 Ta arbitrarily for all a \u2208 Ind(A). Now assume that t\u03b1 has already been chosen and that\n\u03b2 = \u03b1rb \u2208 Ind(Au). Then r(tail(\u03b1), b) \u2208 A. Because of the rules in \u03a0 of the form (2) and (5), we can thus choose t\u03b2 \u2208 Tb such that t\u03b1 r t\u03b2 . In this way, all types t\u03b1 will eventually be chosen. We now construct an interpretation I , starting with\n\u2206I = Ind(Au)\nAI = {\u03b1 | A \u2208 t\u03b1} for all concept names A\nrI = {(\u03b1, \u03b2) | r(\u03b1, \u03b2) \u2208 Au} for all role names r.\nNext, consider every \u03b1 \u2208 Ind(Au) and every \u2203r.C \u2208 t\u03b1 such that Au does not contain an assertion r(\u03b1, \u03b2) with C \u2208 t\u03b2 . First assume that func(r) 6\u2208 T . There must be a T , q-type t such that t\u03b1 r t and C \u2208 t. Choose a model J\u03b1,\u2203r.C of T and D = \u2293 ta \u2293 \u2203r.\u2293 t, a d \u2208 DJ\u03b1,\u2203r.C , and an e \u2208 (\u2293 t)J\u03b1,\u2203r.C with (d, e) \u2208 rJ\u03b1,\u2203r.C . W.l.o.g., we can assume that J\u03b1,\u2203r.C is tree-shaped with root d. Let J\u2212\u03b1,\u2203r.C be obtained from J\u03b1,\u2203r.C by dropping the subtree rooted at e. Now disjointly add J\u2212\u03b1,\u2203r.C to I , additionally including (a, d) in r I . Now assume that func(r) \u2208 T . Then, if there exists r(\u03b1, \u03b2) \u2208 Au, then C \u2208 t\u03b2 as otherwise we do not have t\u03b1 r t\u03b2 . Thus, assume there is no r(\u03b1, \u03b2) \u2208 Au. There must be a T , q-type t such that t\u03b1 r t and C \u2208 t. We then have D \u2208 t for all \u2203r.D \u2208 t\u03b1 and so construct only a single J \u2212 \u03b1,\u2203r.C for the role r and disjointly add J \u2212 \u03b1,\u2203r.C to I , additionally including (a, d) in rI . This finishes the construction of I . The following claim can be proved by induction on C , details are omitted.\nClaim. For all C \u2208 cl(T , C0) : (a) \u03b1 \u2208 CI iff C \u2208 t\u03b1 for all \u03b1 \u2208 Ind(Au) and\n(b) d \u2208 CJ\u03b1,\u2203r.D iff d \u2208 CI for all J\u03b1,\u2203r.D and all d \u2208 \u2206 J\u2212 \u03b1,\u2203r.D .\nBy construction of I and since A(\u03b1) \u2208 Au implies A \u2208 t\u03b1, I is a model of A. Due to the rules in \u03a0 that are of the form (4), Point (a) of the claim yields I 6|= C0(a0). Finally, we observe that I is a model of T . The concept inclusions in T are satisfied by the above claim, since C \u2291 D \u2208 T means that C \u2208 t implies D \u2208 t for every T , q-type t, and since each J\u03b1,\u2203r.C is a model of T . Due to the rules in \u03a0 that are of the form (6) and since each J\u03b1,\u2203r.C is a model of T , all functionality assertions in T are satisfied as well. Summing up, we have shown that T ,Au 6|= C0(a0), as required. \u274f\nTogether with Theorems 19 and 22, Theorem 24 also reproves the known PTIME upper bound for the data complexity of CQ-evaluation in Horn-ALCFI [EGOS08].\nBy Theorems 18 and 24, unraveling tolerance implies materializability unless PTIME = NP. Based on the disjunction property, this implication can also be proved without the side condition.\nTheorem 25. Every unraveling tolerant ALCFI-TBox is materializable.\nProof. We show the contrapositive using a proof strategy that is very similar to the second step in the proof of Theorem 18. Thus, take an ALCFI-TBox T that is not materializable. By Theorem 16, T does not have the disjunction property. Thus, there are an ABox A\u2228, ELIQs C0(x0), . . . , Ck(xk), and a1, . . . , ak \u2208 Ind(A\u2228) such that T ,A\u2228 |= C0(a0) \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ck(ak), but T ,A\u2228 6|= Ci(ai) for all i \u2264 k. Let Ai be Ci viewed as a tree-shaped ABox with root bi, for all i \u2264 k. Assume w.l.o.g. that none of the ABoxes A\u2228,A0, . . . ,Ak share any individual names and reserve a fresh individual name b and role names r, r0, . . . , rk that do not occur in T . Construct an ABox\nA = A\u2228 \u222a A0 \u222a \u00b7 \u00b7 \u00b7 \u222a Ak \u222a {r(b, b0), . . . , r(b, bk)} \u222a {r0(bj , b0), . . . , rj\u22121(bj , bj\u22121), rj+1(bj , bj+1), . . . , rk(bj , bk)}\n\u222a {r0(b0, a0), . . . , rk(bk, ak)}\nand an ELIQ q = \u2203r.(\u2203r0.C0 \u2293 \u00b7 \u00b7 \u00b7 \u2293 \u2203rk.Ck)(x). By the following claim, A and q witness that T is not unraveling tolerant.\nClaim. T ,A |= q(b), but T ,Au 6|= q(b).\nProof. \u201cT ,A |= q(b)\u201d. Take a model I of T and A. By construction of A, we have bIi \u2208 (\u2203rj.Cj) I whenever i 6= j. Due to the edges r0(b0, a0), . . . , rk(bk, ak) and since T ,A\u2228 |= C0(a0) \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ck(ak), we thus find at least one bi such that bIi \u2208 (\u2203ri.Ci) I . Consequently, I |= q(b).\n\u201cT ,Au 6|= q(b)\u201d (sketch). Consider the elements brbiriai in Au. Each such element is the root of a copy of the unraveling Au\u2228 of A\u2228, restricted to those individuals in A\u2228 that are reachable from ai. Since T ,A\u2228 6|= Ci(ai), we find a model Ii of T and A\u2228 with a Ii i /\u2208 C Ii i . By unraveling I , we obtain a model Iui of T and A u \u2228 with a Iui i /\u2208 C Iui i . Combining the models I u 0 , . . . ,I u k in a suitable way, one can craft a model I of T and Au\u2228 such that brbiria I i /\u2208 C I i for all i \u2264 k. Consequently, I 6|= q(b). \u274f"}, {"heading": "5. DICHOTOMY FOR DEPTH ONE", "text": "In practical applications, the concepts used in TBoxes are often of very limited quantifier depth. Motivated by this observation, we consider TBoxes of depth one which are sets of CIs C \u2291 D such that the maximum nesting depth of the constructors \u2203r.E and \u2200r.E in C and D is one. To confirm that this is indeed a practically relevant case, we have analyzed the 429 ontologies in the BioPortal repository,3 finding that after removing all constructors that are not part of ALCFI, more than 80% of them are of depth one. The main result of this section is a dichotomy between PTIME and CONP for TBoxes of depth one which is established by proving a converse of Theorem 25, that is, showing that materializability implies unraveling tolerance (and thus PTIME query evaluation and even Datalog6=-rewritability by Theorem 24) for TBoxes of depth one. Together with Theorem 18, which says that non-materializability implies CONP-hardness, this yields the dichotomy.\nWe remark that the same strategy cannot be used to obtain a dichotomy in the case of unrestricted depth. In particular, the well-known technique of rewriting a TBox into depth one by introducing fresh concept names can change its complexity because it enables querying for concepts such as \u00acA or \u2200r.A which are otherwise \u2018invisible\u2019 to (positive existential) queries. For TBoxes of unrestricted depth (and even in ALC) it is in fact neither the case that PTIME query evaluation implies unraveling tolerance nor that PTIME query evaluation implies Datalog6= rewritability nor that materializability implies PTIME query evaluation. As an example for the former, we show in Section 6 how the TBox T2 from Example 2, which encodes 2-colorability, can be modified to have PTIME query evaluation. However, 2-colorability is not invariant under tree unravelings and, consequently, T2 is not unraveling tolerant. Also the latter two statements follow from results established in Section 6.\nTheorem 26. Every materializable ALCFI-TBox of depth one is unraveling tolerant.\n3The ontologies are available at https://bioportal.bioontology.org/ontologies.\nProof. Let T be a materializable TBox of depth one, A an ABox, C0(x) an ELIQ, and a0 \u2208 Ind(A) such that T ,Au 6|= C0(a0). We have to show that T ,A 6|= C0(a0). It follows from T ,Au 6|= C0(a0) that Au is consistent w.r.t. T . There must thus be a materialization Iu for T and Au, despite the fact that Au is infinite: by Theorem 26, T has the disjunction property and the argument from the proof of Theorem 26 that the disjunction property implies materializability goes through without modification also for infinite ABoxes. Our aim is to turn Iu into a model I of A and T such that I 6|= C0(a0). To achieve this, we first uniformize Iu in a suitable way.\nWe assume w.l.o.g. that Iu has forest-shape, i.e., that Iu can be constructed by selecting a tree-shaped interpretation I\u03b1 with root \u03b1 for each \u03b1 \u2208 Ind(Au), then taking the disjoint union of all these interpretations, and finally adding role edges (\u03b1, \u03b2) to rI u\nwhenever r(\u03b1, \u03b2) \u2208 Au. In fact, to achieve the desired shape we can take the i-unfolding of Iu defined and analysed in Lemmas 13 and 14, where we start the i-unfolding from the elements of Ind(Au) \u2286 \u2206I u\n. We start with exhibiting a self-similarity inside the unraveled ABox Au and inside Iu.\nClaim 1. For all \u03b1, \u03b2 \u2208 Ind(Au) with tail(\u03b1) = tail(\u03b2), (1) Au |= C(\u03b1) iff Au |= C(\u03b2) for all ELIQs C(x); (2) \u03b1 \u2208 CI u iff \u03b2 \u2208 CI u for all concepts C built only from concept names, \u00ac, and \u2293.\nTo establish Point (1), take \u03b1, \u03b2 \u2208 Ind(Au) such that tail(\u03b1) = tail(\u03b2) and Au 6|= C(\u03b1). Then there is a model I of Au and T such that I 6|= C(\u03b1). One can find a model J of Au and T such that J 6|= C(\u03b2), as follows. By construction of Au, there is an isomorphism \u03b9 : Ind(Au) \u2192 Ind(Au) with \u03b9(\u03b1) = \u03b2 such that A(\u03b3) \u2208 Au iff A(\u03b9(\u03b3)) \u2208 Au and r(\u03b3, \u03b3\u2032) \u2208 Au iff r(\u03b9(\u03b3), \u03b9(\u03b3\u2032)) \u2208 Au for all \u03b3 \u2208 Ind(Au), all concept names A, and all role names r. We obtain J from I by renaming each \u03b3 \u2208 Ind(Au) with \u03b9(\u03b3). Point (2) can be proved by a straightforward induction on C . The base case uses Point (1) and the fact that Iu is a materialization of T and A. This finishes the proof of Claim 1.\nNow for the announced uniformization of Iu. What we want to achieve is that for all \u03b1, \u03b2 \u2208 Ind(Au), tail(\u03b1) = tail(\u03b2) implies I\u03b1 = I\u03b2 (recall that I\u03b1 is the tree component of Iu rooted at \u03b1, and likewise for I\u03b2). Construct the interpretation J u as follows:\n\u2022 for each \u03b1 \u2208 Ind(Au) with tail(\u03b1) = a, take a copy J\u03b1 of Ia with the root a renamed to \u03b1; \u2022 then J u is the disjoint union of all interpretations J\u03b1, \u03b1 \u2208 Ind(Au), extended with a role\nedge (\u03b1, \u03b2) \u2208 rJ u whenever r(\u03b1, \u03b2) \u2208 Au.\nOur next aim is to show that J u is as required, that is, it is a model of T and Au and satisfies J u 6|= C0(a0).\nIt is indeed straightforward to verify that J u is a model of Au: all role assertions are satisfied by construction; moreover, A(\u03b1) \u2208 Au implies A(a) \u2208 Au where a = tail(\u03b1) , thus a \u2208 AIu and \u03b1 \u2208 AJu .\nNext, we show that J u is a model of T . Let f : \u2206J u \u2192 \u2206I u be a mapping that assigns to\neach domain element of J u the original element in Iu of which it is a copy.\nClaim 2. d \u2208 CJ u iff f(d) \u2208 CI u for all d \u2208 \u2206J u and ALCI-concepts C of depth one.\nThe proof of claim 2 is by induction on the structure of C . We assume w.l.o.g. that C is built only from the constructors \u00ac, \u2293, and \u2203r.C . The base case, where C is a concept name, is an immediate consequence of the definition of J u. The case where C = \u00acD and C = D1 \u2293D2 is routine. It thus remains to consider the case C = \u2203r.D, where D is built from \u00ac and \u2293 only.\nFirst let d \u2208 CJ u . Then there is a (d, e) \u2208 rJ u with e \u2208 DJ u . First assume that the edge\n(d, e) was added to rJ u because d = \u03b1 and e = \u03b2 for some \u03b1, \u03b2 \u2208 Ind(Au) with r(\u03b1, \u03b2) \u2208 Au. Let tail(\u03b1) = a and tail(\u03b2) = b. Then we have f(\u03b1) = a and f(\u03b2) = b. By construction of\nAu, r(\u03b1, \u03b2) \u2208 Au implies that \u03b2 = \u03b1rb or \u03b1 = \u03b2r\u2212a. In both cases we have r(a, b) \u2208 A, thus r(a, arb) \u2208 Au, thus (a, arb) \u2208 rI u . Since \u03b2 = e \u2208 DJ u , induction hypothesis yields that b \u2208 DI u . From Point (2) of Claim 1, we obtain arb \u2208 DI u\nand we are done. Now assume that there is an \u03b1 \u2208 Ind(Au) such that (d, e) \u2208 J\u03b1. By construction of J u, we then have (f(d), f(e)) \u2208 rI u and induction hypothesis yields f(e) \u2208 DI u .\nNow let f(d) \u2208 CI u . Then there is an (f(d), e) \u2208 rI u with e \u2208 DI u . First assume that f(d) = \u03b1 and e = \u03b2 for some \u03b1, \u03b2 \u2208 Ind(Au) with r(\u03b1, \u03b2) \u2208 Au. Since f(d) \u2208 Ind(Au), we must have d = \u03b3 \u2208 Ind(Au) and f(d) = a \u2208 Ind(A) with tail(\u03b3) = a. By construction of Au, r(a, \u03b2) \u2208 Au implies that \u03b2 = arb, thus r(a, b) \u2208 A, thus r(\u03b3, \u03b4) \u2208 Au with (i) \u03b4 = \u03b3rb or (ii) \u03b3 = \u03b4r\u2212a and tail(\u03b4) = b. Since arb = e \u2208 DI u\n, Point (2) of Claim 1 yields b \u2208 DIu . Since tail(\u03b4) = b implies f(\u03b4) = b, induction hypothesis yields \u03b4 \u2208 DJ u and we are done. Now assume that there is an \u03b1 \u2208 Ind(Au) such that (f(d), e) \u2208 I\u03b1. By construction of J u, f(d) being in I\u03b1 implies that \u03b1 = a for some a \u2208 Ind(A) and that there is an \u03b1\u2032 \u2208 Ind(Au) such that d is in J\u03b1\u2032 and tail(\u03b1\u2032) = a. Again by construction of J u, we thus find an e\u2032 in J\u03b1\u2032 with f(e\u2032) = e and (d, e\u2032) \u2208 rJ\u03b1\u2032 \u2286 rJ u . Induction hypothesis yields e\u2032 \u2208 DJ u . This finishes the proof of Claim 2.\nIt follows from Claim 2 that J u satisfies all CIs in T . To show that J u is a model of T , it remains to show that J u satisfies all functionality assertions. Thus, let func(r) \u2208 T and d \u2208 \u2206J u . If d /\u2208 Ind(Au), then it is straightforward to verify that, by construction of J u, d has at most one r-successor in J u. Now assume d = \u03b1 \u2208 Ind(Au) and let tail(\u03b1) = a. By construction of J u and Au, \u03b1 has the same number of r-successors in J u as a in Iu. Since Iu satisfies func(r), \u03b1 can have at most one r-successor in J u.\nThe final condition that J u should satisfy is J u 6|= C0(a0). Assume to the contrary. We view C0(x0) as a (tree-shaped) CQ. Take a homomorphism h from C0(x0) to J u with h(x0) = a0. (In this proof we consider homomorphisms that do not have to preserve any individual names.) Let the CQ q(x) be obtained from C0(x0) by identifying variables y1, y2 whenever h(y1) = h(y2). To achieve a contradiction, it suffices to exhibit a homomorphism h\u2032 from q(x0) to Iu with h\u2032(x0) = a0. We start with setting h\u2032(x) = h(x) whenever h(x) \u2208 Ind(Au). Let q\u2032 be obtained from q(x0) by dropping all role atoms r(x, y) with h\u2032(x) and h\u2032(y) already defined (which are satisfied under h\u2032 by construction of J u and since Iu is a model of A). Because of the forest shape of J u and by construction, q\u2032 is a disjoint union of ELIQs such that, in each ELIQ C(x) contained in q\u2032, h\u2032 is defined for the root x of C(x), but not for any other variable in it. Consequently, it suffices to show that whenever J\u03b1 |= C(\u03b1) for some ELIQ C(x) and \u03b1 \u2208 Ind(Au), then Iu |= C(\u03b1); the remaining part of h\u2032 can then be constructed in a straightforward way. Now J\u03b1 |= C(\u03b1) implies Ia |= C(a) where a = tail(\u03b1) by choice of J\u03b1, which yields Iu |= C(a) and thus Iu |= C(\u03b1) by Point (1) of Claim 1.\nThis finishes the construction and analysis of the uniform model J u. It remains to convert J u\ninto a model I of T and the original ABox A such that I 6|= C0(a0)q:\n\u2022 take the disjoint union of the components Ja of J u, for each a \u2208 Ind(A); \u2022 add the edge (a, b) to rI whenever r(a, b) \u2208 A.\nIt is straightforward to verfiy that I is a model of A: all role assertions are satisfied by construction of I; moreover, A(a) \u2208 A implies A(a) \u2208 Au implies a \u2208 AJ u implies a \u2208 AI . To show that I is a model of T and that I 6|= C0(a0), we first observe the following. A bisimulation between interpretations I1 and I2 is a relation S \u2286 \u2206I1 \u00d7\u2206I2 such that\n(1) for all A \u2208 NC and (d1, d2) \u2208 S: d1 \u2208 AI1 iff d2 \u2208 AI2 ; (2) for all r \u2208 NR \u222a {s\u2212 | s \u2208 NR}: if (d1, d2) \u2208 S and (d1, d\u20321) \u2208 r\nI1 , then there exists d\u20322 \u2208 \u2206 I2 such that (d\u20321, d \u2032 2) \u2208 S and (d2, d \u2032 2) \u2208 r I2;\n(3) for all r \u2208 NR \u222a {s\u2212 | s \u2208 NR}: if (d1, d2) \u2208 S and (d2, d\u20322) \u2208 r I2 , then there exists\nd\u20321 \u2208 \u2206 I1 such that (d\u20321, d \u2032 2) \u2208 S and (d1, d \u2032 1) \u2208 r I2 .\nRecall that, whenever there is a bisimulation S between I1 and I2 with (d, e) \u2208 S, then d \u2208 CI1 iff e \u2208 CI2 for all ALCI-concepts C [GO07, LPW11].\nClaim 3. There is a bisimulation S between J u and I such that (a, a) \u2208 S for all a \u2208 Ind(A).\nSince J u is uniform in the sense that J\u03b1 is isomorphic to J\u03b2 whenever tail(\u03b1) = tail(\u03b2), we find a bisimulation between J\u03b1 and Ja whenever tail(\u03b1) = a. It can be verified that the union of all these bisimulations qualifies as the desired bisimulation S for Claim 3. Thus, Claim 3 is proved.\nIt follows from Claim 3 that I satisfies all concept inclusions in T , and that I 6|= C0(a0). It thus remains to verify that I also satisfies all functionality assertions in T . This can be done in the same way in which we have verified that J u satisfies all those assertions. \u274f\nThe desired dichotomy follows: If an ALCFI-TBox T of depth one is materializable, then PEQ-evaluation w.r.t. T is in PTIME and Datalog6=-rewritable by Theorems 26 and 24. Otherwise, ELIQ-evaluation w.r.t. T is CONP-complete by Theorem 18.\nTheorem 27 (Dichotomy). For every ALCFI-TBox T of depth one, one of the following is true: \u2022 Q-evaluation w.r.t. T is in PTIME for any Q \u2208 {PEQ,CQ,ELIQ} (and Datalog6=-rewritable); \u2022 Q-evaluation w.r.t. T is CONP-complete for any Q \u2208 {PEQ,CQ,ELIQ}.\n6. QUERY EVALUATION IN ALC/ALCI = CSP\nWe show that query evaluation w.r.t. ALC- and ALCI-TBoxes has the same computational power as non-uniform CSPs in the following sense:\n(1) for every CSP, there is an ALC-TBox T such that the CSP can be reduced in polynomial time to the complement of evaluating an OMQ (T ,\u2203xM(x)) and, conversely, for every OMQ (T , q) query evaluation can be reduced in polynomial time to the CSP\u2019s complement; (2) for every OMQ (T , q) with T an ALCI-TBox and q an ELIQ, there is a CSP such that the complement of the CSP and the query evaluation problem for the (T , q) are reducible to each other in polynomial time.\nThis result has many interesting consequences. In particular, the Feder-Vardi conjecture holds if and only if there is a PTIME/CONP-dichotomy for query evaluation w.r.t. ALC-TBoxes (equivalently: w.r.t. ALCI-TBoxes). Remarkably, all this is true already for materializable TBoxes. By Theorem 19 and since we carefully choose the appropriate query language in each technical result below, it furthermore holds for any of the query languages ELIQ, CQ, and PEQ (and ELQ for ALC-TBoxes).\nWe begin by introducing CSPs. Since every CSP is equivalent to a CSP with a single predicate that is binary, up to polynomial time reductions [FV93], we consider CSPs over unary and binary predicates (concept names and role names) only. A signature \u03a3 is a finite set of concept and role names. An ABox A is a \u03a3-ABox if all concept and role names in A are in \u03a3. For two finite \u03a3ABoxes A and B, we write A \u2192 B if there is a homomorphism from A to B that does not have to preserve any individual names. Any \u03a3-ABox B gives rise to the following (non-uniform) constraint satisfaction problem\n\u2022 CSP(B): given a finite \u03a3-ABox A, decide whether A \u2192 B.\nB is called the template of CSP(B). Many algorithmic problems can be given in the form CSP(B). For example, k-colorability is CSP(Ck), where Ck is the {r}-ABox containing r(i, j) for all 1 \u2264 i 6= j \u2264 k.\nWe now formulate and prove Points (1) and (2) from above, starting with (1).\nTheorem 28. For every template B, one can construct in polynomial time a materializable ALCTBox TB such that, for a distinguished concept name M , the following hold:\n(1) CSP(B) is polynomial time reducible to the complement of the query evaluation problem for (TB,\u2203xM(x)); (2) the query evaluation problem for (TB, q) is polynomial time reducible to the complement of CSP(B), for all PEQs q.\nOur approach to proving Theorem 28 is to generalize the reduction of k-colorability to query evaluation w.r.t. ALC-TBoxes discussed in Examples 2 and 4, where the main challenge is to overcome the observation from Example 4 that PTIME CSPs such as 2-colorability may be translated into CONP-hard TBoxes. Note that this is due to the disjunction in the TBox Tk of Example 2, which causes non-materializability. Our solution is to replace the concept names A1, . . . , Ak in Tk with suitable compound concepts that are \u2018invisible to the (positive existential) query\u2019. Unlike the original depth one TBox Tk, the resulting TBox is of depth three. We first define and analyze the replacement of concept names by compound concepts in some detail (as this will be reused later in the paper again) and then return to the proof of Theorem 28.\nLet \u03a3 be a set of concept names. For any B \u2208 \u03a3, let ZB be a fresh concept name and let rB and sB be fresh role names. The abstraction of B is the ALC-concept HB := \u2200rB.\u2203sB.\u00acZB. The \u03a3-abstraction C \u2032 of a (potentially compound) concept C is obtained from C by replacing every B \u2208 \u03a3 with HB. The \u03a3-abstraction of a TBox T is obtained from T by replacing all concepts in T with their \u03a3-abstractions. We associate with \u03a3 an auxiliary TBox\nT \u2203 = {\u22a4 \u2291 \u2203rB .\u22a4,\u22a4 \u2291 \u2203sB.ZB | B \u2208 \u03a3}\nFinally, T \u2032 \u222a T \u2203 is called the enriched \u03a3-abstraction of T and \u03a3. In what follows, we are going to replace TBoxes T with their enriched abstractions. The following example shows that the TBox T \u2203 is crucial for hiding the concept names in \u03a3: without T \u2203, disjunctions in T over concept names from \u03a3 can still induce disjunctions in the \u03a3-abstraction.\nExample 29. Let T = {A \u2291 \u00acB1 \u2294 \u00acB2} and \u03a3 = {B1, B2}. Then T \u2032 = {A \u2291 \u00acHB1 \u2294 \u00acHB2} is the \u03a3-abstraction of T . For A = {A(a)}, we derive T \u2032,A |= \u2203rB1 .\u22a4(a) \u2228 \u2203rB2 .\u22a4(a) but T \u2032,A 6|= \u2203rB1 .\u22a4(a) and T \u2032,A 6|= \u2203rB2(a).\u22a4. Thus T \u2032 does not have the ABox disjunction property and is not materializable. In contrast, it follows from Lemma 30 below that T \u2032\u222aT \u2203 is materializable and, in fact, T \u2032 \u222a T \u2203,A |= q(a) iff T \u2203,A |= q(a) holds for all PEQs q.\nWe say that a TBox T admits trivial models if the singleton interpretation I with XI = \u2205 for all X \u2208 NC \u222a NR is a model of T . Moreover, we write A|\u03a3 to denote the ABox obtained from the ABox A by removing all assertions in A that use a symbol that is not in \u03a3, and likewise for A\u03a3 and symbols that are in \u03a3. An ABox A is strongly \u03a3-consistent w.r.t. a TBox T if there exists a model I of T and A|\u03a3 such that \u2206\nI = Ind(A), AI = {a | A(a) \u2208 A} for all A 6\u2208 \u03a3, and rI = {(a, b) | r(a, b) \u2208 A} for all role names r 6\u2208 \u03a3. Thus, strong \u03a3-consistency formalizes the intuition that we regard the symbols in \u03a3 as existentially quantified second-order variables. The following lemma summarizes the main properties of abstractions. Points (1) and (2) establish a close link between the original TBox and its enriched abstraction. Points (3) and (4) together state that query evaluation is tractable for the enriched abstraction of a TBox T for ABoxes that are strongly \u03a3-consistent w.r.t. T .\nLemma 30. Assume that T admits trivial models and let \u03a3 be a finite set of concept names and T \u2032 \u222a T \u2203 the enriched \u03a3-abstraction of T . Then for every ABox A and all ALCI concepts C not using the fresh symbols from \u03a3-abstractions:\n(1) A|\u03a3 is consistent w.r.t. T iff A is consistent w.r.t. T \u2032 \u222a T \u2203; (2) for all a \u2208 Ind(A) and the \u03a3-abstraction C \u2032 of C:\nT ,A|\u03a3 |= C(a) iff T \u2032 \u222a T \u2203,A |= C \u2032(a)\nand if C is a concept name:\nT ,A|\u03a3 |= \u2203xC(x) iff T \u2032 \u222a T \u2203,A |= \u2203xC \u2032(x);\n(3) T \u2203 is Datalog6=-rewritable for PEQs; (4) if A is strongly \u03a3-consistent w.r.t. T , then\nT \u2032 \u222a T \u2203,A |= q(~a) iff T \u2203,A |= q(~a)\nfor all PEQs q and all ~a.\nProof. Observe that (1) follows from (2) as we can choose C = \u22a5. Thus we prove (2). Let C \u2032 be the \u03a3-abstraction of C .\nWe first consider (\u21d2). Assume T \u2032 \u222a T \u2203,A 6|= C \u2032(a). Take a model I of T \u2032 \u222a T \u2203 and A that witnesses this. Define an interpretation J in the same way as I except that BJ := HIB for all B \u2208 \u03a3. It is straightforward to show for all d \u2208 \u2206I that d \u2208 DJ iff d \u2208 D\u2032I holds for all ALCI-concepts D not using the fresh symbols from \u03a3-abstractions and their \u03a3-abstractions D\u2032. Thus J is a model of T and A|\u03a3 and shows that T ,A|\u03a3 6|= C(a) if T\n\u2032\u222aT \u2203,A 6|= C \u2032(a). The same proof shows that (\u21d2) holds for queries of the form \u2203xC(x) and \u2203xC \u2032(x) as well (even if C is not a concept name).\nNow consider (\u21d0). Assume T ,A|\u03a3 6|= C(a) or T ,A|\u03a3 6|= \u2203xA(x) (where A is a concept name). Let I be a model of T and A|\u03a3 that witnesses this. Construct a model Ican of T\n\u2032 \u222a T \u2203 and A as follows: \u2206Ican is the set of words w = dv1 \u00b7 \u00b7 \u00b7 vn such that d \u2208 \u2206I and vi \u2208 {rB , sB , s\u0304B | B \u2208 \u03a3} where vi 6= s\u0304B if (i) i > 2 or (ii) i = 2 and (d 6\u2208 HIB or v1 6= rB). Now let\nAIcan = AI for all concept names A 6\u2208 \u03a3\nBIcan = {d \u2208 Ind(A) | B(d) \u2208 A} for all B \u2208 \u03a3\nZIcanB = Z I B \u222a {w | tail(w) = sB} for all B \u2208 \u03a3\nrIcan = rI for all r 6\u2208 {rB , sB | r \u2208 \u03a3} rIcanB = r I B \u222a {(w,wrB) | wrB \u2208 \u2206 Ican} for all r \u2208 \u03a3 sIcanB = s I B \u222a {(w,wsB) | wrB \u2208 \u2206 Ican} \u222a {(w,ws\u0304B) | ws\u0304B \u2208 \u2206 Ican} for all r \u2208 \u03a3\nBy construction of Ican, we have H Ican B = B I for all B \u2208 \u03a3. Thus for all concepts D (not using symbols from \u03a3-abstractions) and their \u03a3-abstractions D\u2032 and all d \u2208 \u2206I , we have d \u2208 D\u2032Ican iff d \u2208 DI . Thus, the CIs of T \u2032 hold in all d \u2208 \u2206I since the CIs of T hold in all d \u2208 \u2206I . The CIs of T \u2032 also hold in all d \u2208 \u2206Ican \\\u2206I since T admits trivial models. Thus Ican is a model of T \u2032. Since Ican is a model of T \u2203 by construction, it follows that Ican is a model of T \u2032 \u222a T \u2203. It also follows that Ican shows T \u2032 \u222a T \u2203,A 6|= C \u2032(a) if I shows that T ,A|\u03a3 6|= C(a) and that Ican shows that T \u2032 \u222a T \u2203,A 6|= \u2203xA\u2032(x) if I shows that T ,A|\u03a3 6|= \u2203xA(x).\n(3) is a consequence of the fact that T \u2203 can be viewed as a TBox formulated in the description logic DL-LiteR and that any OMQ (T , q) with T a DL-LiteR-TBox and q a PEQ is known to be rewritable into a union of CQs [CDGL+07, ACKZ09].\n(4) Assume that A is strongly \u03a3-consistent w.r.t. T and that T \u2203,A 6|= q(~a). We show T \u2032 \u222a T \u2203,A 6|= q(~a). Note first that one can construct a hom-initial model I\u2203A of T\n\u2203 and A in the same way as Ican was constructed from I above (by replacing I with the interpretation IA corresponding to A and not using the symbols s\u0304B in the construction). Thus, \u2206I \u2203 A is the set of words w = av1 \u00b7 \u00b7 \u00b7 vn such that a \u2208 Ind(A) and vi \u2208 {rB , sB , | B \u2208 \u03a3}. We have I\u2203A 6|= q(~a). Now, as A is strongly \u03a3-consistent w.r.t. T , there is a model I of T and A|\u03a3 with \u2206\nI = Ind(A) and AI = {a | A(a) \u2208 A} for all A 6\u2208 \u03a3, and rI = {(a, b) | r(a, b) \u2208 A} for all role names r. Construct the model Ican of T \u2032 \u222a T \u2203 and A in the same way as in the proof of (2). Define a mapping h : Ican \u2192 I\u2203A by setting h(w) = w\n\u2032, where w\u2032 is obtained from w by replacing every s\u0304B by sB. One can show that h is a homomorphism. Thus Ican 6|= q(~a) and so T \u2032 \u222a T \u2203,A 6|= q(~a), as required. The converse direction is trivial. \u274f\nWe are now ready to prove Theorem 28.\nProof of Theorem 28. Assume a \u03a30-template B is given. We construct the TBox TB in two steps. First take for any d \u2208 Ind(B) a concept name Ad and define a TBox HB with the following CIs:\ndom \u2291 \u2294 d\u2208Ind(B) Ad\nAd \u2293Ae \u2291 \u22a5 for all d, e \u2208 Ind(B), d 6= e\nAd \u2293 \u2203r.Ae \u2291 \u22a5 for all d, e \u2208 Ind(B), r \u2208 \u03a30, r(d, e) 6\u2208 B\nAd \u2293A \u2291 \u22a5 for all d \u2208 Ind(B), A \u2208 \u03a30, A(d) 6\u2208 B.\nHere dom \u2291 \u2294 d\u2208Ind(B) Ad stands for the set of CIs\n\u2203r.\u22a4 \u2291 \u2294 d\u2208Ind(B) Ad, A \u2291 \u2294 d\u2208Ind(B) Ad, \u22a4 \u2291 \u2200r.( \u2294 d\u2208Ind(B) Ad)\nwhere r and A range over all role and concept names in \u03a30, respectively. We use a CI of the form dom \u2291 C rather than \u22a4 \u2291 C to ensure that the TBox HB admits trivial models. Let M be a fresh concept name and set \u03a3 = {Ad | d \u2208 Ind(B)}. Then the following can be proved in a straightforward way.\nClaim 1. For any ABox A the following conditions are equivalent: (1) HB,A|\u03a3\u222a{M} 6|= \u2203xM(x); (2) A|\u03a3 is consistent w.r.t. HB; (3) A|\u03a30 \u2192 B. Thus, CSP(B) and the complement of the query evaluation problem for (HB,\u2203xM(x)) are reducible to each other in polynomial time. Because of the disjunctions, however, the query evaluation problem w.r.t HB is typically CONP-hard even if CSP(B) is in PTIME. We thus \u2018hide\u2019 the concept names Ad by replacing them with their abstractions HAd . Let H \u2032 B \u222a T\n\u2203 be the enriched \u03a3abstraction of HB. From Claim 1 and Lemma 30 (1) according to which A|\u03a3 is consistent w.r.t. HB iff A is consistent w.r.t. H\u2032B \u222a T \u2203, we obtain\nClaim 2. For any ABox A, the following conditions are equivalent: (1) H\u2032B \u222a T \u2203,A|{M} 6|= \u2203xM(x);\n(2) A is consistent w.r.t. H\u2032B \u222a T \u2203; (3) A|\u03a30 \u2192 B.\nLet TB = H\u2032B \u222a T \u2203 be the enriched \u03a3-abstraction of HB. We show that TB is as required to prove Theorem 28.\n(1) We have to show that CSP(B) is reducible in polynomial time to the complement of the query evaluation problem for (TB,\u2203xM(x)). But given a \u03a30-ABox A, we have by Claim 2 that A \u2192 B iff TB,A |= \u2203xM(x).\n(2) For the converse reduction, let q be a PEQ. We have to show that the query evaluation problem for (TB, q) is reducible in polynomial time to the complement of CSP(B). Let A be an ABox and ~a from Ind(A). We show that the following are equivalent:\n(a) TB,A |= q(~a); (b) A|\u03a30 6\u2192 B or T \u2203,A |= q(~a).\nRegarding (b), we remark that by Lemma 30 (3) T \u2203,A |= q(~a) can be checked in polynomial time and thus can be checked as part of the reduction. First assume that (a) holds. If A|\u03a30 \u2192 B, then by Claim 1 the ABox A|\u03a3 is consistent w.r.t. HB. Thus there is a model I of HB and A|\u03a3 satisfying \u2206I = Ind(A) and AI = {a | A(a) \u2208 A} for all concept names A 6\u2208 \u03a3 and rI = {(a, b) | r(a, b) \u2208 A} for all role names r. Thus, A is strongly \u03a3-consistent w.r.t. HB. By Lemma 30 (4) we have TB,A |= q(~a) iff T \u2203,A |= q(~a) for all PEQs q and all ~a, as required.\nConversely, assume (b) holds. If A|\u03a30 6\u2192 B, then by Claim 2 A is not consistent w.r.t. TB and so TB,A |= q(~a). If T \u2203,A |= q(~a), then TB,A |= q(~a) since T \u2203 \u2286 TB. \u274f\nThe following converse of Theorem 28 is proved in [BtCLW14].\nTheorem 31. For every ALCI-TBox T and ELIQ C(x), one can compute a template B in exponential time such that the query evaluation problem for (T , C(x)) and the complement of CSP(B) are polynomial time reducible to each other.\nThe proof of Theorem 31 given in [BtCLW14] proceeds in two steps. To deal with answer variables, it uses generalized CSPs with constants, defined by a finite set of templates (instead of a single one) and admitting the inclusion of constant symbols in the signature of the CSP (instead of only relation symbols). One shows that (i) for every OMQ (T , C(x)), one can construct a generalized CSP with a single constant whose complement is mutually reducible in polynomial time with the query evaluation problem for (T , C(x)) and (ii) every generalized CSP with constants is mutually reducible in polynomial time with some standard CSP. For the reader\u2019s convenience, we illustrate the construction of the template from a given OMQ, concentrating on Boolean ELIQs which are of the form \u2203xC(x) with C(x) an ELIQ. In this special case, one can avoid the use of generalized CSPs with constants.\nTheorem 32. Let T be an ALCI-TBox, q = \u2203xC(x) with C an ELIQ, and \u03a3 the signature of T and q. Then one can construct (in time single exponential in |T |+ |C|) a \u03a3-template BT ,q such that for all ABoxes A:\n(HomDual) T ,A |= q iff A|\u03a3 6\u2192 BT ,q\nProof. Assume T and q = \u2203xC(x) are given. We use the notation from the proof of Theorem 24. Thus, cl(T , C) denotes the closure under single negation of the set of subconcepts of T and C , tp(T , q) denotes the set of T , q-types and for t, t\u2032 \u2208 tp(T , q) we write t r t\u2032 if t and t\u2032 can be satisfied in domain elements of a model of T that are related by r. Now, a T , q-type t omits q if it is satisfiable in a model I of T with CI = \u2205. Let BT ,q be the set of assertions A(t) such t omits q and A \u2208 t and r(t, t\u2032) such that t and t\u2032 omit q and t r t\u2032. It is not difficult to show that condition (HomDual) holds for all ABoxes A. Observe that BT ,q can be constructed in exponential time since the set of T , q-types omitting q can be constructed in exponential time. \u274f\nExample 33. Let T = {A \u2291 \u2200r.B} and define q = \u2203xB(x). Then BT ,q is defined, up to isomorphism, as {r(a, a), r(a, b), A(b), r(a, c)}.\nAs a consequence of Theorems 28 and 31, we obtain the following.\nTheorem 34. There is a dichotomy between PTIME and CONP for CQ-evaluation w.r.t. ALCTBoxes if and only if the Feder-Vardi conjecture is true. The same is true for ALCI-TBoxes, for ELIQs, and for PEQs. For ALC-TBoxes, it additionally holds for ELQs.\nProof. Let CSP(B) be an NP-intermediate CSP, i.e., a CSP that is neither in PTIME nor NP-hard. Take the TBox TB from Theorem 28. By Point 1 of that theorem, CQ-evaluation w.r.t. T is not in PTIME. By Point 2, CQ-evaluation w.r.t. TB is not CONP-hard.\nConversely, let T be an ALC-TBox for which CQ-evaluation w.r.t. T is neither in PTIME nor CONP-hard. Then by Theorem 19, the same holds for ELIQ-evaluation w.r.t. T . It follows that there is a concrete ELIQ q such that query evaluation for (T , q) is CONP-intermediate. By Theorem 31, there is a template B such that evaluating (T , q) is mutually reducible in polynomial time with the complement of CSP(B). Thus CSP(B) is NP-intermediate, as required. \u274f\nObserve that the TBox constructed in the proof of Theorem 28 has depth three. Thus, a dichotomy between PTIME and CONP for CQ-evaluation w.r.t. ALC-TBoxes of depth three would imply that the Feder-Vardi conjecture is true. On the other hand, we have proved a dichotomy between PTIME and CONP for CQ-evaluation w.r.t. ALCIF-TBoxes of depth one. The behavior of TBoxes of depth two remains open.\n7. NON-DICHOTOMY AND UNDECIDABILITY IN ALCF\nWe show that the complexity landscape of query evaluation w.r.t. ALCF-TBoxes is much richer than for ALCI, and in fact too rich to be fully manageable. In particular, we prove that for CQevaluation, there is no dichotomy between PTIME and CONP (unless PTIME = NP). We also establish that materializability, Datalog6=-rewritability, PTIME query evaluation, and CONP-hardness of query evaluation are undecidable. We start with the undecidability proofs, which are by reduction of an undecidable rectangle tiling problem and reuse the \u2018hidden concepts\u2019 introduced in the previous section. Next, the TBox from that reduction is adapted to prove the non-dichotomy result by an encoding of the computations of nondeterministic polynomial time Turing machines (and again using hidden concepts). The basis for the technical development in this section is a TBox constructed in [BBLW16] to prove the undecidability of query emptiness in ALCF .\nAn instance of the finite rectangle tiling problem is given by a triple P = (T,H, V ) with T a finite set of tile types including an initial tile Tinit to be placed on the lower left corner and a final tile Tfinal to be placed on the upper right corner, H \u2286 T\u00d7 T a horizontal matching relation, and V \u2286 T\u00d7T a vertical matching relation. A tiling for (T,H, V ) is a map f : {0, . . . , n}\u00d7{0, . . . ,m} \u2192 T such that n,m \u2265 0, f(0, 0) = Tinit, f(n,m) = Tfinal, (f(i, j), f(i + 1, j)) \u2208 H for all i < n, and (f(i, j), f(i, j + 1)) \u2208 V for all i < m. We say that P admits a tiling if there exists a map f that is a tiling for P. It is undecidable whether an instance of the finite rectangle tiling problem admits a tiling.\nNow let P = (T,H, V ) be a finite rectangle tiling problem with T = {T1, . . . , Tp}. We regard the tile types in T as concept names and set \u03a3g = {T1, . . . , Tp, x, y, x\u0302, y\u0302}, where x, y, x\u0302, and y\u0302 are functional role names. The TBox TP is defined as the following set of CIs, where (Ti, Tj , T\u2113) range over all triples from T such that (Ti, Tj) \u2208 H and (Ti, T\u2113) \u2208 V and where for e \u2208 {c, x, y}\nthe concept Be ranges over all conjunctions L1 \u2293 L2 with Li \u2208 {Ze,i,\u00acZe,i}, for concept names Ze,i (i = 1, 2):\nTfinal \u2291 Y \u2293 U \u2293R\n\u2203x.(U \u2293 Y \u2293 Tj) \u2293 Ix \u2293 Ti \u2291 U \u2293 Y\n\u2203y.(R \u2293 Y \u2293 T\u2113) \u2293 Iy \u2293 Ti \u2291 R \u2293 Y\n\u2203x.(Tj \u2293 Y \u2293 \u2203y.Y ) \u2293 \u2203y.(T\u2113 \u2293 Y \u2293 \u2203x.Y ) \u2293 Ix \u2293 Iy \u2293 C \u2293 Ti \u2291 Y\nY \u2293 Tinit \u2291 A\nBx \u2293 \u2203x.\u2203x\u0302.Bx \u2291 Ix\nBy \u2293 \u2203y.\u2203y\u0302.By \u2291 Iy\n\u2203x.\u2203y.Bc \u2293 \u2203y.\u2203x.Bc \u2291 C\n\u2294 1\u2264s<t\u2264p Ts \u2293 Tt \u2291 \u22a5\nU \u2291 \u2200y.\u22a5 R \u2291 \u2200x.\u22a5 U \u2291 \u2200x.U R \u2291 \u2200y.R\nY \u2293 Tinit \u2291 D \u2293 L D \u2291 \u2200y\u0302.\u22a5 L \u2291 \u2200x\u0302.\u22a5 D \u2291 \u2200x.D \u2293 \u2200x\u0302.D L \u2291 \u2200y.L \u2293 \u2200y\u0302.L\nWith the exception of the CIs in the last line, the TBox TP has been defined and analyzed in [BBLW16]. Here, we briefly give intuition and discuss its main properties. The role names x and y are used to represent horizontal and vertical adjacency of points in a rectangle. The role names x\u0302 and y\u0302 are used to simulate the inverses of x and y. The concept names in TP serve the following puroposes:\n\u2022 U , R, L, and D mark the upper, right, left, and lower (\u2018down\u2019) border of the rectangle. \u2022 In the Bc concepts, the concept names Zc,1 and Zc,2 serve as second-order variables and\nensure that a flag C is set at positions where the grid cell is closed. \u2022 In the concepts Bx and By, the concept names Zx,1, Zx,2, Zy,1, Zy,2 also serve as second-\norder variables and ensure that flags Ix and Iy are set at positions where x and x\u0302 as well as y and y\u0302 are inverse to each other. \u2022 The concept name Y is propagated through the grid from the upper right corner to the lower left one, ensuring that these flags are set everywhere, that every position of the grid is labeled with at least one tile type, and that the horizontal and vertical matching conditions are satisfied. \u2022 Finally, when the lower left corner of the grid is reached, the concept name A is set as a flag.\nBecause of the use of the concepts Be, CQ evaluation w.r.t. TP is coNP-hard: we leave it as an exercise to the reader to verify that TP does not have the ABox disjunction property. TP without the three CIs involving the concepts Be, however, is (equivalent to) a Horn-ALCF TBox and thus enjoys PTIME CQ-evaluation. It can also be verified that TP admits trivial models. Call a \u03a3g-ABox A an grid ABox (with initial individual a) if A represents a grid along with a proper tiling for P. In detail, we require that there is a tiling f for P with domain {0, . . . , n}\u00d7{0, . . . ,m} and a bijection g : {0, . . . , n} \u00d7 {0, . . . ,m} \u2192 Ind(A) with g(0, 0) = a such that\n\u2022 for all j < n, k \u2264 m: T (g(j, k)) \u2208 A iff T = f(j, k); \u2022 for all b1, b2 \u2208 Ind(A): x(b1, b2) \u2208 A iff x\u0302(b2, b1) \u2208 A iff there are j < n, k \u2264 m such\nthat (b1, b2) = (g(j, k), g(j + 1, k)); \u2022 for all b1, b2 \u2208 Ind(A): y(b1, b2) \u2208 A iff y\u0302(b2, b1) \u2208 A iff there are j \u2264 n, k < m such that (b1, b2) = (g(j, k), g(j, k + 1)).\nClearly, if P admits a tiling then a grid ABox exists and for any grid ABox A, TP,A |= A(a) for the (uniquely determined) initial individual a of A. The following summarizes relevant properties of \u03a3g-ABoxes that follow almost directly from the analysis of TP in [BBLW16]. We say that an ABox A contains an ABox A\u2032 if A\u2032 \u2286 A and that A contains a closed ABox A if, additionally, r(a, b) \u2208 A and a \u2208 Ind(A\u2032) implies r(a, b) \u2208 A\u2032 for r \u2208 {x, y, x\u0302, y\u0302}. Moreover, we say that inconsistency of (\u03a3-)ABoxes w.r.t. a TBox T is Datalog6=-rewritable if there is a Boolean Datalog6=-program \u03a0 such that for any (\u03a3-)ABox A, A |= \u03a0() iff A is inconsistent w.r.t. T .\nLemma 35. Let P be a finite rectangle tiling problem. Then the following holds. (1) Inconsistency of \u03a3g-ABoxes w.r.t. TP is Datalog6=-rewritable. (2) If a \u03a3g-ABox A is consistent w.r.t. TP, then it is \u03a3g-strongly consistent w.r.t. TP and A\ncontains \u2022 closed grid ABoxes A1, . . . ,An, n \u2265 0, with mutually disjoint sets Ind(Ai) and \u2022 a (possibly empty) \u03a3g-ABox A\u2032 disjoint from A1 \u222a \u00b7 \u00b7 \u00b7 \u222a An such that A = A1 \u222a \u00b7 \u00b7 \u00b7 \u222a An \u222a A\u2032 and TP,A |= A(a) iff a is the initial node of some Ai. Moreover, there is a model I witnessing \u03a3g-strong consistency w.r.t. TP that satisfies a \u2208 AI iff a is the initial node of some Ai.\nProof. (1) Assume a \u03a3g-ABox A is given. Apply the following rules exhaustively to A: (a) add Ix(a) to A if there exists b with x(a, b), x\u0302(b, a) \u2208 A; (b) add Iy(a) to A if there exists b with y(a, b), y\u0302(b, a) \u2208 A; (c) add C(a) to A if there exist a1, a2, b with x(a, a1), y(a, a2), y(a1, b), x(a2, b) \u2208 A. Denote the resulting ABox by A\u2020. Now remove the three CIs involving the concepts Be from TP and denote by T \u2020P the resulting TBox. Using the analysis of the CIs involving the concepts Be in [BBLW16], one can show that A is consistent w.r.t. TP iff A\u2020 is consistent w.r.t. T \u2020 P. Since the latter is a Horn-ALCF -TBox, it is unraveling tolerant and one can build a Datalog6=-rewriting of the inconsistency of \u03a3g-ABoxes w.r.t. T \u2020 P, essentially as in the proof of Theorem 24. Finally, the obtained program can be modified so as to behave as if started on A\u2020 when started on A, by implementing rules (a) to (c) as Datalog rules.\n(2) This is almost a direct consequence of the properties established in [BBLW16]. In particular, one finds the desired model I from the \u2018moreover\u2019 part by applying the three rules from the proof of Point (1) and then applying the CIs in T \u2020P as rules. The only condition on the decomposition of the ABox A into A = A1\u222a \u00b7 \u00b7 \u00b7 \u222aAn \u222aA\u2032 that does not follow from [BBLW16] is that the containment of A1, . . . ,An in A is closed also for the role names x\u0302 and y\u0302. To ensure this condition, we use the CIs that mention L and D that were not present in the TBox used in that paper. In fact, the following two properties follow directly from these CIs: (i) the individuals c reachable along an x-path in A from some a with TP,A |= A(a) all satisfy TP,A |= D(c) and so do not have an x\u0302-successor; and (ii) the individuals c reachable along a y-path in A from some a with TP,A |= A(a) all satisfy TP,A |= L(c) and so do not have a y\u0302-successor. (i) and (ii) together with the properties established in [BBLW16] entail that the containment of A1, . . . ,An in A is closed also for the role names x\u0302 and y\u0302, as required. \u274f\nNote that it follows from Lemma 35 (2) that if A is consistent w.r.t. T , then the sequence A1, . . . ,An is empty iff TP,A 6|= \u2203xA(x) (and A\u2032 is non-empty since ABoxes are non-empty). In particular this must be the case when P does not admit a tiling. In the proof Lemma 36 below, this is actually\nall we need from from Lemma 35 (2). In full generality, it will only be used in the proof of nondichotomy later on. We also remark that the decomposition A1 \u222a \u00b7 \u00b7 \u00b7 \u222a An \u222aA\u2032 of A in Lemma 35 (2) is unique.\nLet T = TP\u222a{A \u2291 B1\u2294B2}, where B1 and B2 are fresh concept names. Set \u03a3 = sig(TP)\\\u03a3g and let T \u2032 \u222a T \u2203 be the enriched \u03a3-abstraction of T .\nLemma 36.\n(1) If P admits a tiling, then CQ-evaluation w.r.t. T \u2032 \u222a T \u2203 is CONP-hard and T \u2032 \u222a T \u2203 is not materializable. (2) If P does not admit a tiling, then CQ-evaluation w.r.t. T \u2032 \u222a T \u2203 is Datalog6=-rewritable and T \u2032 \u222a T \u2203 is materializable.\nProof. (1) If P admits a tiling, then there is a grid ABox A with initial node a. A uses symbols from \u03a3g, only. We have TP,A |= A(a) and A is consistent w.r.t. TP. Thus T ,A |= B1\u2294B2(a) and T ,A 6|= Bi(a) for i = 1, 2. By Lemma 30 (2), T \u2032\u222aT \u2203,A |= B1\u2294B2(a) and T \u2032\u222aT \u2203,A 6|= Bi(a) for i = 1, 2. Thus T \u2032 \u222a T \u2203 does not have the ABox disjunction property. It follows that T \u2032 \u222a T \u2203 is not materializable and that CQ-evaluation w.r.t. T \u2032 \u222a T \u2203 is CONP-hard.\n(2) Assume that P does not admit a tiling. Let q be a PEQ. We show how to construct a Datalog6=-rewriting \u03a0 of (T \u2032 \u222a T \u2203, q). On ABoxes A that are inconsistent w.r.t. T \u2032 \u222a T \u2203, \u03a0 is supposed to return all tuples over Ind(A) of the same arity as q. By Lemma 30 (1), an ABox A is consistent w.r.t. T \u2032 \u222a T \u2203 iff A|\u03a3 is consistent w.r.t. T . It thus follows from Lemma 35 (1) that inconsistency of ABoxes w.r.t. T \u2032 \u222a T \u2203 is Datalog6=-rewritable. From a concrete rewriting, we can build a Datalog6=-program \u03a00 that checks inconsistency and, if successful, returns all answers.\nNow for ABoxes A that are consistent w.r.t. T \u2032 \u222a T \u2203. By Lemma 30 (1), A|\u03a3 is consistent w.r.t. TP. Since P does not admit a tiling and by Lemma 35 (2), TP,A|\u03a3 6|= \u2203xA(x). Thus, by Lemma 35 (2) we find a model I of TP and A|\u03a3 such that \u2206\nI = Ind(A), AI = {a | A(a) \u2208 A} for all A 6\u2208 \u03a3, rI = {(a, b) | r(a, b) \u2208 A} for all role names r, and AI = \u2205. Since AI = \u2205, I is a model of T . From Lemma 30 (4), we thus obtain that T \u2032 \u222a T \u2203,A |= q(~a) iff T \u2203,A |= q(~a), for all ~a. By Lemma 30 (3), (T \u2203, q) is Datalog6=-rewritable into a program \u03a01.\nThe desired program \u03a0 is simply the union of \u03a00 and \u03a01, assuming disjointness of IDB relations. \u274f\nLemma 36 implies the announced undecidability results.\nTheorem 37. For ALCF-TBoxes T , the following problems are undecidable (Points 1 and 2 are subject to the side condition that PTIME 6= NP):\n(1) CQ-evaluation w.r.t. T is in PTIME; (2) CQ-evaluation w.r.t. T is CONP-hard; (3) T is Datalog6=-rewritable; (4) T is materializable.\nWe now come to the proof of non-dichotomy.\nTheorem 38. For every language L \u2208 CONP, there exists an ALCF-TBox T such that, for a distinguished concept name M0, the following holds:\n(1) L is polynomial time reducible to the evaluation of (T ,\u2203xM0(x)); (2) the evaluation of (T , q) is polynomial time reducible to L, for all PEQs q.\nTo prove Theorem 38 let L \u2208 CONP. Take a non-deterministic polynomial time Turing Machine M that recognizes the complement of L. Let M = (Q,\u03930,\u03931,\u2206, q0, qa, qr) with Q a finite set of states, \u03930 and \u03931 finite input and tape alphabets such that \u03930 \u2286 \u03931 and \u03931 \\ \u03930 contains the blank symbol \u03b2, q0 \u2208 Q the starting state, \u2206 \u2286 Q \u00d7 \u03931 \u00d7 Q \u00d7 \u03931 \u00d7 {L,R} the transition relation, and qa, qr \u2208 Q the accepting and rejecting states. Denote by L(M) the language recognized by M . We can assume w.l.o.g. that there is a fixed symbol \u03b30 \u2208 \u03930 such that all words accepted by M are of the form \u03b30v with v \u2208 (\u03930 \\ {\u03b30})\u2217; in fact, it is easy to modify M to satisfy this property without changing the complexity of its word problem. We also assume that for any input v \u2208 \u0393\u22170, M uses exactly |v|k1 cells for the computation, halts after exactly |v|k2 steps in the accepting or rejecting state, and does not move to the left of the starting cell.\nTo represent inputs to M and to provide the space for simulating computations, we use grid ABoxes as in the proof of Theorem 37, where the tiling of the bottom row represents the input word followed by blank symbols. As the set of tile types, we use T = \u03930 \u222a {\u03b2, T, Tfinal} where T is a \u2018default tile\u2019 that labels every position except those in the bottom row and the upper right corner. Identify Tinit with \u03b30 and let \u03a3g = \u03930\u222a{\u03b2, T, Tfinal}\u222a{x, y, x\u0302, y\u0302}. Consider the TBox TPM defined above, for PM = (T,H, V ) with\nH = {(\u03b30, \u03b3), (\u03b3, \u03b3 \u2032), (\u03b3, \u03b2), (\u03b2, \u03b2), (T, T ), (T, Tfinal) | \u03b3, \u03b3 \u2032 \u2208 \u03930 \\ {\u03b30}}\nV = {(\u03b3, T ), (\u03b2, T ), (T, T ), (T, Tfinal), (\u03b3, Tfinal), (\u03b2, Tfinal) | \u03b3 \u2208 \u03930}.\nRecall that TPM checks whether a given \u03a3g-ABox contains a grid structure with a tiling that respects H , V , Tinit, and Tfinal, and derives the concept name A at the lower left corner of such grids. We now construct a TBox TM that, after the verification has finished, initiates a computation of M on the grid. In addition to the concept names in TPM , TM uses concept names A\u03b3 and Aq,\u03b3 for all \u03b3 \u2208 \u03931 and q \u2208 Q to represent symbols written during the computation (in contrast to the elements of \u03931 as concept names, used to encode the input word) and to represent the state and head position. In detail, TM contains the following CIs:\n\u2022 When the verification of the grid has finished, A floods the ABox:\nA \u2291 \u2200r.A for all r \u2208 {x, y, x\u0302, y\u0302}.\n\u2022 The initial configuration is as required:\n\u03b30 \u2293A \u2291 Aq0,\u03b3 \u03b3 \u2293A \u2291 A\u03b3 for all \u03b3 \u2208 (\u03930 \u222a {\u03b2}) \\ {\u03b30}.\n\u2022 For every (q, \u03b3) \u2208 Q\u00d7 \u03931, the transition relation of M is satisfied:\nAq,\u03b3 \u2293A \u2291 \u2294 (q,\u03b3,q\u2032,\u03b3\u2032,L)\u2208\u2206 \u2203y.(A\u03b3\u2032 \u2293 \u2294 \u03b3\u2032\u2032\u2208\u03931 \u2203x\u0302.Aq\u2032,\u03b3\u2032\u2032) \u2294\n\u2294 (q,\u03b3,q\u2032,\u03b3\u2032,R)\u2208\u2206 \u2203y.(A\u03b3\u2032 \u2293 \u2294 \u03b3\u2032\u2032\u2208\u03931 \u2203x.Aq\u2032,\u03b3\u2032).\n\u2022 The symbol written on a cell does not change if the head is not on the cell:"}, {"heading": "A\u03b3 \u2293A \u2291 \u2200y.A\u03b3 for all \u03b3 \u2208 \u03931", "text": "\u2022 The rejecting state is never reached:\nAqr,\u03b3 \u2293A \u2291 \u22a5 for all \u03b3 \u2208 \u03931.\nLet T = TPM \u222a TM . We are going to show that an appropriate extended abstraction of T satisfies Conditions (1) and (2) of Theorem 38. We start with the following lemma which summarizes two important properties of T .\nLemma 39.\n(1) T admits trivial models. (2) For any \u03a3g-ABox A, A is consistent w.r.t. T iff the following two conditions hold:\n(a) A is consistent w.r.t. TPM ; (b) let A = A1 \u222a \u00b7 \u00b7 \u00b7 \u222a An \u222a A\u2032 be the decomposition of A given in Lemma 35 (2) and\nassume that Ai is the ni \u00d7 mi-grid ABox with input vi for 1 \u2264 i \u2264 n. Then the following hold for 1 \u2264 i \u2264 n:\n(i) ni \u2265 |vi|k1 and mi \u2265 |vi|k2 and (ii) vi \u2208 L(M).\nMoreover, if A is consistent w.r.t. T , then it is strongly \u03a3g-consistent w.r.t. T .\nProof. Since (1) follows directly from the shape of the CIs in T , we concentrate on (2). Assume first that A is consistent w.r.t. T . Then A is consistent w.r.t. TPM and so we can assume that there is a decomposition A1\u222a\u00b7 \u00b7 \u00b7 An\u222aA\u2032 of A as in Lemma 35 (2). By definition, each Ai is an ni\u00d7mi-grid ABox with input vi. Since A is consistent w.r.t. T , there is a model I of A and T . By the first CIs of TM and since the initial node a of each Ai must be in AI by Lemma 35, Ind(Ai) \u2286 AI for each i. Thus the restriction of I to Ind(Ai) simulates an accepting computation of M starting with vi. But since every computatation of M starting with a word of length n requires at least nk1 space and mk2 time and the containment of Ai in A is closed for the role names x and y, this is impossible if ni < |vi|\nk1 or mi < |vi|k2 and also if vi 6\u2208 L(M). Thus (i) and (ii) hold, as required. For the converse direction, assume that (a) and (b) hold. Since A is consistent w.r.t. TPM , there is a decomposition A1 \u222a \u00b7 \u00b7 \u00b7 \u222a An \u222a A\u2032 of A as in Lemma 35 (2). Also by Lemma 35 (2), there is a model I that witnesses strong \u03a3g-consistency of A w.r.t. TPM such that a \u2208 A\nI iff a is the initial node of some Ai. We construct a model I \u2032 of T by modifying I as follows: with the exception of A, the symbols of TPM are interpreted in the same way as in I and thus I\n\u2032 is a model of TPM . To satisfy the first CI of TM , we set AI \u2032 = Ind(A1 \u222a \u00b7 \u00b7 \u00b7 \u222a An). Note that this suffices since the containment of each Ai in A is closed for the role names x and y. The remaining symbols from TM are now interpreted in such a way that they describe on each Ai an accepting computation for vi. This is possible since vi \u2208 L(M), ni \u2265 |vi|k1 and mi \u2265 |vi|k2 , and each computation of M starting with a word v of length n requires at most nk1 space and mk2 time. It can be verified that I \u2032 is a model of TM ; note that since A is a conjunct of the left hand side of every CI in TM , the CIs in TM are trivially satisfied in every node d \u2208 \u2206I \\ Ind(A1 \u222a \u00b7 \u00b7 \u00b7 \u222aAn). Thus I \u2032 satisfies T and A and we have proved consistency of A w.r.t. T , as required.\nFor the \u2018moreover\u2019 part of the lemma, it suffices to observe that I \u2032 witnesses strong \u03a3gconsistency of A w.r.t. T . \u274f\nWe are now in the position to prove non-dichotomy.\nProof of Theorem 38. Let L \u2208 CONP and let M and T be the TM and TBox from above. Set \u03a3 = sig(T )\\\u03a3g and let T \u2032\u222aT \u2203 be the enriched \u03a3-abstraction of T . Thus, the only concept names that we are not \u2018hiding\u2019 are the concept names in \u03a3g. We show that T satisfies Points (1) and (2) from Theorem 38.\n(1) It suffices to give a polynomial time reduction from L(M) to the complement of evaluating (T \u2032 \u222a T \u2203,\u2203xM0(x)) (note that M0 does not occur in any of the involved TBoxes). Assume that an input word v for M is given. If v is not from \u03b30(\u03930 \\ {\u03b30}), then reject. Otherwise, construct in polynomial time the |v|k1\u00d7|v|k2 -grid ABox A with input v. Observe that A is consistent w.r.t. TPM and has the trivial decomposition A = A1 in Lemma 35 (2). Thus Lemma 39 (2) implies that v \u2208 L(M) iff A is consistent w.r.t. T . The latter condition is equivalent to T ,A 6|= \u2203xM0(x) since\nM0 does not occur in A or T . Since T admits trivial models, Lemma 30 (2) thus yields v \u2208 L(M) iff T \u2032 \u222a T \u2203,A 6|= \u2203xM0(x).\n(2) We first make the following observation.\nClaim 1. T \u2032 \u222a T \u2203,A |= q(~a) iff \u2022 A|\u03a3g is not consistent w.r.t. T or \u2022 T \u2203,A |= q(~a).\nFor the \u2018only if\u2019 direction, observe that if A|\u03a3g is consistent w.r.t. T , then Lemma 39 yields that A is strongly \u03a3g-consistent w.r.t. T . Thus, by Lemma 30 (4), T \u2032 \u222a T \u2203,A |= q(~a) iff T \u2203,A |= q(~a). For the \u2018if\u2019 direction, observe that if A|\u03a3g is not consistent w.r.t. T , then by Lemma 30 (1) A is not consistent w.r.t. T \u2032 \u222a T \u2203. This finishes the proof of the claim.\nBy Lemma 30 (3), T \u2203,A |= q(~a) can be decided in polynomial time. Thus, Claim 1 implies that it suffices to give a polynomial time reduction of ABox consistency w.r.t. T to L(M). But Lemma 39 (2) provides a polynomial reduction of ABox consistency w.r.t. T to L(M) since\n\u2022 Condition (a) of Lemma 39 (2) can be checked in polynomial time (by Lemma 35 (1)); \u2022 the decomposition of A in Condition (b) of Lemma 39 (2) as well as the words vi, 1 \u2264 i \u2264 n, can be computed in polynomial time; \u2022 and Point (i) of Condition (b) can be checked in polynomial time.\nIt thus remains to check whether vi \u2208 L(M) for 1 \u2264 i \u2264 n. This finishes the proof of Theorem 38.\nTheorems 38 and 19 imply that that there is no PTIME/CONP-dichotomy, unless PTIME = NP. Observe that the TBoxes constructed in the undecidability and the non-dichotomy proof are both of depth four. This can be easily reduced to depth three: recall that the TBoxes of depth four are obtained from TBoxes T of depth two by taking their enriched \u03a3-abstractions. One can obtain a TBox of depth three (for which query evaluation has the same complexity up to polynomial time reductions) by first replacing in T compound concepts C in the scope of a single value or existential restriction by fresh concept names AC and adding AC \u2261 C to T . Then the fresh concept names are added to the signature \u03a3 and one constructs the enriched abstraction of the resulting TBox for the extended signature. This TBox is as required. Thus, our undecidability and non-dichotomy results hold for ALCF TBoxes of depth three already."}, {"heading": "8. DISCUSSION", "text": "We have studied the complexity of query evaluation in the presence of an ontology formulated in a DL between ALC and ALCFI , focussing on the boundary between PTIME and CONP. For ALCFI-TBoxes of depth one (which covers the vast majority of practically relevant cases), our results are very positive: there is a dichotomy between PTIME and CONP and it can be precisely characterized in terms of unraveling tolerance and materializability. Moreover and unlike in the general case, PTIME complexity coincides with rewitability into Datalog6=. The case of higher or unrestricted depth is harder to analyze. We have shown that for ALC- and ALCI-TBoxes of depth three, the existence of a dichotomy between PTIME and CONP is equivalent to the Feder-Vardi conjecture that there is a dichotomy between PTIME and NP for CSPs with finite template\u2014the case of depth two remains as an open problem. For ALCF TBoxes of depth three we have shown that there is no dichotomy unless PTIME = NP and that deciding whether a given TBox admits PTIME query evaluation is undecidable, and so are related questions.\nSeveral interesting research questions remain. We briefly discuss three possible directions.\n(1) Is it decidable whether a given ALC- or ALCI-TBox admits PTIME query evaluation and, closely related, whether it is unraveling tolerant and whether it is materializable? We conjecture that this is indeed the case for TBoxes of depth one, but we have no conjecture for TBoxes of larger depth. It is interesting to point out that unraveling tolerance is decidable for OMQs whose TBox is formulated in ALCI (where a concrete query is given, unlike in the case of unraveling tolerance of TBoxes); in that case, unraveling tolerance is equivalent to rewritability into monadic Datalog [FKL]. It would also be interesting to study more general notions of unraveling tolerance based on unravelings into structures of bounded treewidth rather than into real trees.\n(2) It would be interesting to study additional complexity classes such as LOGSPACE, NLOGSPACE, and AC0. It is known that all these classes occur even for ALC TBoxes of depth one, see e.g. [CDL+13]. For example, CQ-evaluation w.r.t. the depth one EL-TBox {\u2203r.A \u2291 A}, which encodes reachability in directed graphs, is NLOGSPACE-complete. It would thus be interesting to identify further dichotomies such as between NLOGSPACE and PTIME. We conjecture that for ALCFI-TBoxes of depth one, it is decidable whether query evaluation is in PTIME, NLOGSPACE, LOGSPACE, and AC0.\n(3) Apart from deciding whether query evaluation w.r.t. a given TBox has a certain complexity, it is also interesting to decide whether the TBox admits rewritability into relevant query languages such as FO-queries or Datalog queries. In the context of OMQs, several results have been obtained, see e.g. [BLW13, HLSW15, BHLW16] for FO-rewritability of OMQs whose TBox is formulated in a Horn DL and [BtCLW14, FKL] for FO- and Datalog-rewritability of OMQs whose TBox is formulated in ALC or an extension thereof. In the TBox (rather than OMQ) case, a first relevant result has been established in [LW11] where it is shown that that FO-rewritability is decidable for materializable ALCFI-TBoxes of depth one. This underlines the importance of deciding materializability, which would allow to lift this result to (otherwise unrestricted) ALCFI-TBoxes of depth one.\nAcknowledgments. Carsten Lutz was supported by ERC consolidator grant 647289. Frank Wolter was supported by EPSRC grant EP/M012646/1."}], "references": [{"title": "The complexity of satisfiability problems: Refining Schaefer\u2019s theorem", "author": ["Eric Allender", "Michael Bauland", "Neil Immerman", "Henning Schnoor", "Heribert Vollmer"], "venue": "In MFCS,", "citeRegEx": "Allender et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Allender et al\\.", "year": 2005}, {"title": "The DL-Lite family and relations", "author": ["Alessandro Artale", "Diego Calvanese", "Roman Kontchakov", "Michael Zakharyaschev"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Artale et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2009}, {"title": "On datalog vs. polynomial time", "author": ["Foto N. Afrati", "Stavros S. Cosmadakis", "Mihalis Yannakakis"], "venue": "In PODS,", "citeRegEx": "Afrati et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Afrati et al\\.", "year": 1991}, {"title": "Constraint satisfaction problem and universal algebra", "author": ["Libor Barto"], "venue": "SIGLOG News,", "citeRegEx": "Barto.,? \\Q2014\\E", "shortCiteRegEx": "Barto.", "year": 2014}, {"title": "Pushing the EL envelope. In IJCAI, pages 364\u2013369", "author": ["Franz Baader", "Sebastian Brandt", "Carsten Lutz"], "venue": "Professional Book Center,", "citeRegEx": "Baader et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2005}, {"title": "Query and predicate emptiness in ontology-based data access", "author": ["Franz Baader", "Meghyn Bienvenu", "Carsten Lutz", "Frank Wolter"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Baader et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2016}, {"title": "Querying the guarded fragment", "author": ["Vince Barany", "Georg Gottlob", "Martin Otto"], "venue": "In LICS,", "citeRegEx": "Barany et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Barany et al\\.", "year": 2010}, {"title": "First order-rewritability and containment of conjunctive queries in Horn description logics", "author": ["Meghyn Bienvenu", "Peter Hansen", "Carsten Lutz", "Frank Wolter"], "venue": "In IJCAI,", "citeRegEx": "Bienvenu et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bienvenu et al\\.", "year": 2016}, {"title": "Classifying the complexity of constraints using finite algebras", "author": ["Andrei A. Bulatov", "Peter Jeavons", "Andrei A. Krokhin"], "venue": "SIAM J. Comput.,", "citeRegEx": "Bulatov et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bulatov et al\\.", "year": 2005}, {"title": "First-order rewritability of atomic queries in horn description logics", "author": ["Meghyn Bienvenu", "Carsten Lutz", "Frank Wolter"], "venue": "In IJCAI,", "citeRegEx": "Bienvenu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bienvenu et al\\.", "year": 2013}, {"title": "Walking the complexity lines for generalized guarded existential rules", "author": ["Jean-Francois Baget", "Marie-Laure Mugnier", "Sebastian Rudolph", "Michael Thomazo"], "venue": "In IJCAI,", "citeRegEx": "Baget et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Baget et al\\.", "year": 2011}, {"title": "Ontology-mediated query answering with data-tractable description logics", "author": ["Meghyn Bienvenu", "Magdalena Ortiz"], "venue": "In Reasoning Web,", "citeRegEx": "Bienvenu and Ortiz.,? \\Q2015\\E", "shortCiteRegEx": "Bienvenu and Ortiz.", "year": 2015}, {"title": "Ontology-based data access: A study through disjunctive datalog, CSP, and MMSNP", "author": ["Meghyn Bienvenu", "Balder ten Cate", "Carsten Lutz", "Frank Wolter"], "venue": "ACM Trans. Database Syst.,", "citeRegEx": "Bienvenu et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Bienvenu et al\\.", "year": 2014}, {"title": "A dichotomy theorem for constraints on a three-element set", "author": ["Andrei A. Bulatov"], "venue": "In FOCS,", "citeRegEx": "Bulatov.,? \\Q2002\\E", "shortCiteRegEx": "Bulatov.", "year": 2002}, {"title": "On the CSP dichotomy conjecture", "author": ["Andrei A. Bulatov"], "venue": "In CSR,", "citeRegEx": "Bulatov.,? \\Q2011\\E", "shortCiteRegEx": "Bulatov.", "year": 2011}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Riccardo Rosati"], "venue": "J. of Autom. Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Data complexity of query answering in description logics", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Riccardo Rosati"], "venue": "Artificial Intelligence,", "citeRegEx": "Calvanese et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2013}, {"title": "Taming the infinite chase: Query answering under expressive relational constraints", "author": ["Andrea Cal\u0131", "Georg Gottlob", "Michael Kifer"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2013}, {"title": "View-based query processing and constraint satisfaction", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Moshe Y. Vardi"], "venue": "In LICS,", "citeRegEx": "Calvanese et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2000}, {"title": "Reasoning on regular path queries", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Moshe Y. Vardi"], "venue": "SIGMOD Record,", "citeRegEx": "Calvanese et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2003}, {"title": "View-based query containment", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Moshe Y. Vardi"], "venue": "In PODS,", "citeRegEx": "Calvanese et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2003}, {"title": "What you always wanted to know about datalog (and never dared to ask)", "author": ["Stefano Ceri", "Georg Gottlob", "Letizia Tanca"], "venue": "IEEE Trans. Knowl. Data Eng.,", "citeRegEx": "Ceri et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Ceri et al\\.", "year": 1989}, {"title": "Model Theory, volume 73 of Studies in Logic and the Foundations of Mathematics", "author": ["C.C. Chang", "H. Jerome Keisler"], "venue": null, "citeRegEx": "Chang and Keisler.,? \\Q1990\\E", "shortCiteRegEx": "Chang and Keisler.", "year": 1990}, {"title": "Query answering in the description logic Horn-SHIQ", "author": ["Thomas Eiter", "Georg Gottlob", "Magdalena Ortiz", "Mantas Simkus"], "venue": "In JELIA,", "citeRegEx": "Eiter et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2008}, {"title": "Data exchange: semantics and query answering", "author": ["Ronald Fagin", "Phokion G. Kolaitis", "Ren\u00e9e J. Miller", "Lucian Popa"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Fagin et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Fagin et al\\.", "year": 2005}, {"title": "Monotone monadic SNP and constraint satisfaction", "author": ["Tom\u00e1s Feder", "Moshe Y. Vardi"], "venue": "In STOC,", "citeRegEx": "Feder and Vardi.,? \\Q1993\\E", "shortCiteRegEx": "Feder and Vardi.", "year": 1993}, {"title": "Conjunctive query answering for the description logic SHIQ", "author": ["Birte Glimm", "Carsten Lutz", "Ian Horrocks", "Ulrike Sattler"], "venue": "JAIR, 31:157\u2013204,", "citeRegEx": "Glimm et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Glimm et al\\.", "year": 2008}, {"title": "Model theory of modal logic", "author": ["Valentin Goranko", "Martin Otto"], "venue": "In Handbook of Modal Logic,", "citeRegEx": "Goranko and Otto.,? \\Q2007\\E", "shortCiteRegEx": "Goranko and Otto.", "year": 2007}, {"title": "Efficient query rewriting in the description logic EL and beyond", "author": ["Peter Hansen", "Carsten Lutz", "Inan\u00e7 Seylan", "Frank Wolter"], "venue": "In IJCAI,", "citeRegEx": "Hansen et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Hansen et al\\.", "year": 2015}, {"title": "Reasoning in description logics by a reduction to disjunctive datalog", "author": ["Ullrich Hustadt", "Boris Motik", "Ulrike Sattler"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Hustadt et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2007}, {"title": "On the complexity of h-coloring", "author": ["Pavol Hell", "Jaroslav Nesetril"], "venue": "J. Comb. Theory, Ser. B,", "citeRegEx": "Hell and Nesetril.,? \\Q1990\\E", "shortCiteRegEx": "Hell and Nesetril.", "year": 1990}, {"title": "Consequence-driven reasoning for Horn-SHIQ ontologies", "author": ["Yevgeny Kazakov"], "venue": null, "citeRegEx": "Kazakov.,? \\Q2009\\E", "shortCiteRegEx": "Kazakov.", "year": 2009}, {"title": "Data complexity in the EL family of description logics", "author": ["Adila Krisnadhi", "Carsten Lutz"], "venue": "In LPAR,", "citeRegEx": "Krisnadhi and Lutz.,? \\Q2007\\E", "shortCiteRegEx": "Krisnadhi and Lutz.", "year": 2007}, {"title": "The combined approach to query answering in DL-Lite", "author": ["Roman Kontchakov", "Carsten Lutz", "David Toman", "Frank Wolter", "Michael Zakharyaschev"], "venue": "In KR,", "citeRegEx": "Kontchakov et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2010}, {"title": "Complexity boundaries for Horn description logics", "author": ["Markus Kr\u00f6tzsch", "Sebastian Rudolph", "Pascal Hitzler"], "venue": "In AAAI,", "citeRegEx": "Kr\u00f6tzsch et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Kr\u00f6tzsch et al\\.", "year": 2007}, {"title": "Tree dualities for constraint satisfaction", "author": ["Andrei A. Krokhin"], "venue": "In CSL,", "citeRegEx": "Krokhin.,? \\Q2010\\E", "shortCiteRegEx": "Krokhin.", "year": 2010}, {"title": "Efficient inferencing for OWL EL", "author": ["Markus Kr\u00f6tzsch"], "venue": "In JELIA, pages 234\u2013246,", "citeRegEx": "Kr\u00f6tzsch.,? \\Q2010\\E", "shortCiteRegEx": "Kr\u00f6tzsch.", "year": 2010}, {"title": "A new line of attack on the dichotomy conjecture", "author": ["G\u00e1bor Kun", "Mario Szegedy"], "venue": "In STOC,", "citeRegEx": "Kun and Szegedy.,? \\Q2009\\E", "shortCiteRegEx": "Kun and Szegedy.", "year": 2009}, {"title": "An introduction to description logics and query rewriting", "author": ["Roman Kontchakov", "Michael Zakharyaschev"], "venue": "In Reasoning Web,", "citeRegEx": "Kontchakov and Zakharyaschev.,? \\Q2014\\E", "shortCiteRegEx": "Kontchakov and Zakharyaschev.", "year": 2014}, {"title": "A characterisation of first-order constraint satisfaction problems", "author": ["Benoit Larose", "Cynthia Loten", "Claude Tardif"], "venue": "Logical Methods in Computer Science,", "citeRegEx": "Larose et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Larose et al\\.", "year": 2007}, {"title": "Description logic tboxes: Model-theoretic characterizations and rewritability", "author": ["Carsten Lutz", "Robert Piro", "Frank Wolter"], "venue": "In IJCAI,", "citeRegEx": "Lutz et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2011}, {"title": "Ontology-based data access with closed predicates is inherently intractable (sometimes)", "author": ["Carsten Lutz", "Inan\u00e7 Seylan", "Frank Wolter"], "venue": "In IJCAI,", "citeRegEx": "Lutz et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2013}, {"title": "Ontology-mediated queries with closed predicates. In IJCAI, pages 3120\u20133126", "author": ["Carsten Lutz", "Inan\u00e7 Seylan", "Frank Wolter"], "venue": null, "citeRegEx": "Lutz et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2015}, {"title": "Conjunctive query answering in the description logic EL using a relational database system", "author": ["Carsten Lutz", "David Toman", "Frank Wolter"], "venue": null, "citeRegEx": "Lutz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2009}, {"title": "Deciding inseparability and conservative extensions in the description logic EL", "author": ["Carsten Lutz", "Frank Wolter"], "venue": "J. Symb. Comput.,", "citeRegEx": "Lutz and Wolter.,? \\Q2010\\E", "shortCiteRegEx": "Lutz and Wolter.", "year": 2010}, {"title": "Non-uniform data complexity of query answering in description logics", "author": ["Carsten Lutz", "Frank Wolter"], "venue": "In Description Logics,", "citeRegEx": "Lutz and Wolter.,? \\Q2011\\E", "shortCiteRegEx": "Lutz and Wolter.", "year": 2011}, {"title": "Non-uniform data complexity of query answering in description logics. In KR", "author": ["Carsten Lutz", "Frank Wolter"], "venue": null, "citeRegEx": "Lutz and Wolter.,? \\Q2012\\E", "shortCiteRegEx": "Lutz and Wolter.", "year": 2012}, {"title": "Why Horn formulas matter in computer science: Initial structures and generic examples", "author": ["Johann A. Makowsky"], "venue": "J. Comput. Syst. Sci.,", "citeRegEx": "Makowsky.,? \\Q1987\\E", "shortCiteRegEx": "Makowsky.", "year": 1987}, {"title": "The metamathematics of algebraic systems, collected papers:1936-1967", "author": ["Anatoli I. Malcev"], "venue": null, "citeRegEx": "Malcev.,? \\Q1971\\E", "shortCiteRegEx": "Malcev.", "year": 1971}, {"title": "Initiality, induction, and computability", "author": ["Jose Meseguer", "Joseph A. Goguen"], "venue": null, "citeRegEx": "Meseguer and Goguen.,? \\Q1985\\E", "shortCiteRegEx": "Meseguer and Goguen.", "year": 1985}, {"title": "Data complexity of query answering in expressive description logics via tableaux", "author": ["Magdalena Ortiz", "Diego Calvanese", "Thomas Eiter"], "venue": "J. of Autom. Reasoning,", "citeRegEx": "Ortiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2008}, {"title": "Linking data to ontologies", "author": ["Antonella Poggi", "Domenico Lembo", "Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Riccardo Rosati"], "venue": "J. Data Semantics,", "citeRegEx": "Poggi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Poggi et al\\.", "year": 2008}, {"title": "The limits of querying ontologies", "author": ["Riccardo Rosati"], "venue": "In ICDT, volume 4353 of LNCS,", "citeRegEx": "Rosati.,? \\Q2007\\E", "shortCiteRegEx": "Rosati.", "year": 2007}, {"title": "The complexity of satisfiability problems", "author": ["Thomas J. Schaefer"], "venue": "In STOC, pages 216\u2013226,", "citeRegEx": "Schaefer.,? \\Q1978\\E", "shortCiteRegEx": "Schaefer.", "year": 1978}, {"title": "On the complexity of the instance checking problem in concept languages with existential quantification", "author": ["Andrea Schaerf"], "venue": "J. of Intel. Inf. Systems,", "citeRegEx": "Schaerf.,? \\Q1993\\E", "shortCiteRegEx": "Schaerf.", "year": 1993}], "referenceMentions": [], "year": 2016, "abstractText": "We analyze the data complexity of ontology-mediated querying where the ontologies are formulated in a description logic (DL) of the ALC family and queries are conjunctive queries, positive existential queries, or acyclic conjunctive queries. Our approach is non-uniform in the sense that we aim to understand the complexity of each single ontology instead of for all ontologies formulated in a certain language. While doing so, we quantify over the queries and are interested, for example, in the question whether all queries can be evaluated in polynomial time w.r.t. a given ontology. Our results include a PTIME/CONP-dichotomy for ontologies of depth one in the description logic ALCFI, the equivalence of a PTIME/CONP-dichotomy for ALCand ALCI-ontologies of unrestricted depth to the famous dichotomy conjecture for CSPs by Feder and Vardi, and the failure of PTIME/CONP-dichotomy theorem for ALCF -ontologies. Regarding the latter DL, we also show that it is undecidable whether a given ontology admits PTIME query evaluation.", "creator": "LaTeX with hyperref package"}}}