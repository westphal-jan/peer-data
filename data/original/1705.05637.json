{"id": "1705.05637", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-May-2017", "title": "Text-based Adventures of the Golovin AI Agent", "abstract": "The domain of text-based adventure games has been recently established as a new challenge of creating the agent that is both able to understand natural language, and acts intelligently in text-described environments.", "histories": [["v1", "Tue, 16 May 2017 10:55:08 GMT  (106kb,D)", "http://arxiv.org/abs/1705.05637v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["bartosz kostka", "jaroslaw kwiecien", "jakub kowalski", "pawel rychlikowski"], "accepted": false, "id": "1705.05637"}, "pdf": {"name": "1705.05637.pdf", "metadata": {"source": "CRF", "title": "Text-based Adventures of the Golovin AI Agent", "authors": ["Bartosz Kostka", "Jaros\u0142aw Kwiecie\u0144", "Jakub Kowalski", "Pawe\u0142 Rychlikowski"], "emails": ["bartosz.kostka@stud.cs.uni.wroc.pl,", "jaroslaw.kwiecien@stud.cs.uni.wroc.pl,", "jko@cs.uni.wroc.pl", "prych@cs.uni.wroc.pl"], "sections": [{"heading": null, "text": "In this paper, we present our approach to tackle the problem. Our agent, named Golovin, takes advantage of the limited game domain. We use genre-related corpora (including fantasy books and decompiled games) to create language models suitable to this domain. Moreover, we embed mechanisms that allow us to specify, and separately handle, important tasks as fighting opponents, managing inventory, and navigating on the game map.\nWe validated usefulness of these mechanisms, measuring agent\u2019s performance on the set of 50 interactive fiction games. Finally, we show that our agent plays on a level comparable to the winner of the last year Text-Based Adventure AI Competition.\nI. INTRODUCTION\nThe standard approach to develop an agent playing a given game is to analyze the game rules, choose an appropriate AI technique, and incrementally increase the agent\u2019s performance by exploiting these rules, utilizing domain-dependent features and fixing unwanted behaviors. This strategy allowed to beat the single games which were set as the milestones for the AI development: Chess [1] and Go [2].\nAn alternative approach called General Game Playing (GGP), operating on a higher level of abstraction has recently gained in popularity. Its goal is to develop an agent that can play any previously unseen game without human intervention. Equivalently, we can say that the game is one of the agent\u2019s inputs [3].\nCurrently, there are two main, well-established GGP domains providing their own game specification languages and competitions [4]. The first one is the Stanford\u2019s GGP, emerged in 2005 and it is based on the Game Description Language (GDL), which can describe all finite, turn-based, deterministic games with full information [5], and its extensions (GDL-II [6] and rtGDL [7]).\nThe second one is the General Video Game AI framework (GVGAI) from 2014, which focuses on arcade video games [8]. In contrast to Stanford\u2019s GGP agents are provided with the forward game model instead of the game rules. The domain is more restrictive but the associated competition provides multiple tracks, including procedural content generation challenges [9], [10].\nWhat the above-mentioned approaches have in common is usually a well-defined game state the agent is dealing with. It contains the available information about the state (which\nmay be partially-observable), legal moves, and some kind of scoring function (at least for the endgame states). Even in a GGP case, the set of available moves is known to the agent, and the state is provided using some higher-level structure (logic predicates or state observations).\nIn contrast, the recently proposed Text-Based Adventure AI Competition, held during the IEEE Conference on Computational Intelligence and Games (CIG) in 2016, provides a new kind of challenge by putting more emphasis on interaction with the game environment. The agent has access only to the natural language description about his surroundings and effects of his actions.\nThus, to play successfully, it has to analyze the given descriptions and extract high-level features of the game state by itself. Moreover, the set of possible actions, which are also expected to be in the natural language, is not available and an agent has to deduct it from his knowledge about the game\u2019s world and the current state.\nIn some sense, this approach is coherent with the experiments on learning Atari 2600 games using the Arcade Learning Environment (ALE), where the agent\u2019s inputs were only raw screen capture and a score counter [11], [12]. Although in that scenario the set of possible commands is known in advance.\nThe bar for text-based adventure games challenge is set high \u2013 agents should be able to play any interactive fiction (IF) game, developed by humans for the humans. Such environment, at least in theory, requires to actually understand the text in order to act, so completing this task in its full spectrum, means building a strong AI.\nAlthough some approaches tackling similar problems exist since early 2000s ([13], [14]), we are still at the entry point for this kind of problems, which are closely related to the general problem solving. However, recent successes of the machine learning techniques combined with the power of modern computers, give hope that some vital progress in the domain can be achieved.\nWe pick up the gauntlet, and in this work we present our autonomous agent that can successfully play many interactive fiction games. We took advantage of the specific game domain, and trained agent using matching sources: fantasy books and texts from decompiled IF games. Moreover, we embed some rpg-game-based mechanisms, that allow us to improve fighting opponents, managing hero\u2019s inventory, and navigating in the maze of games\u2019 locations.\nar X\niv :1\n70 5.\n05 63\n7v 1\n[ cs\n.A I]\n1 6\nM ay\n2 01\n7\nWe evaluated our agent on a set of 50 games, testing the influence of each specific component on the final score. Also, we tested our agent against the winner of the last year competition [15]. The achieved results are comparable. Our agent scored better in 12 games and worse in 11 games.\nThe paper is organized as follows. Section II provides background for the domain of interactive fiction, Natural Language Processing (NLP), Text-Based Adventure AI Competition, and the related work. In Section III, we presented detailed description of our agent. Section IV contains the results of the performed experiments. Finally, in Section V, we conclude and give perspective of the future research."}, {"heading": "II. BACKGROUND", "text": "A. Interactive Fiction\nInteractive Fiction (IF), emerged in 1970s, is a domain of text-based adventure or role playing games, where the player uses text commands to control characters and influence the environment. One of the most famous example is the Zork series developed by the Infocom company. From the formal point of view, they are single player, non-deterministic games with imperfect information. IF genre is closely related to MUDs (Multi-User Dungeons), but (being single-player) more focused on plot and puzzles than fighting and interacting with other players. IF was popular up to late 1980s, where the graphical interfaces become available and, as much user friendlier, more popular. Nevertheless, new IF games are still created, and there are annual competitions for game authors (such as The Interactive Fiction Competition).\nIF games usually (but not always) take place in some fantasy worlds. The space the character is traversing has a form of labyrinth consisting of so called rooms (which despite the name can be open areas like forest). Entering the room, the game displays its description, and the player can interact with the objects and game characters it contains, or try to leave the room moving to some direction. However, reversing a movement direction (e.g. go south\u2194 go north) not necessarily returns the character to the previous room.\nAs a standard, the player character can collect objects from the world, store them in his equipment, and combine with other objects to achieve some effects on the environment (e.g. put the lamp and sword in the case). Thus, many games require solving some kind of logical puzzle to push the action forward. After performing an action, the game describes its effect. Many available actions are viable, i.e. game engine understands them, but they are not required to solve the game, or even serve only for the player amusement.\nSome of the games provide score to evaluate the player\u2019s progress, however the change in the score is often the result of a complex series of moves rather than quick \u201cframe to frame\u201d decisions, or the score is given only after the game\u2019s end. Other games do not contain any scoring function and the only output is win or lose."}, {"heading": "B. Playing Text-Based Games", "text": "Although the challenge of playing text-based games was not take on often, there are several attempts described in the literature, mostly based on the MUD games rather than the classic IF games.\nAdventure games has been carefully revised as the field of study for the cognitive robotics in [14]. First, the authors identify the features of \u201ctradition adventure game environment\u201d to point-out the specifics of the domain. Second, they enumerate and discuss existing challenges, including e.g. the need for commonsense knowledge (its learning, revising, organization, and using), gradually revealing state space and action space, vague goal specification and reward specification.\nIn [13], the agent able to live and survive in an existing MUD game have been described. The authors used layered architecture: high level planning system consisting of reasoning engine based on hand-crafted logic trees, and a low level system responsible for sensing the environment, executing commands to fulfill the global plan, detecting and reacting in emergency situations.\nWhile not directly-related to playing algorithms, it is worth to note the usage of computational linguistics and theorem proving to build an engine for playing text-based adventure games [16]. Some of the challenges are similar for both tasks, as generating engine requires e.g. object identification (given user input and a state description) and understanding dependencies between the objects.\nThe approach focused on tracking the state of the world in text-based games, and translating it into the first-order logic, has been presented in [17]. Proposed solution was able to efficiently update agent\u2019s belief state from a sequence of actions and observations.\nThe extension of the above approach, presents the agent that can solve puzzle-like tasks in partially observable domain that is not known in advance, assuming actions are deterministic and without conditional effects [18]. It generates solutions by interleaving planning (based on the traditional logic-based approach) and execution phases. The correctness of the algorithm is formally proved.\nRecently, an advanced MUD playing agent has been described in [19]. Its architecture consists of two modules. First, responsible for converting textual descriptions to state representation is based on the Long Short-term Memory (LSTM) networks [20]. Second, uses Deep Q-Networks [11] to learn approximated evaluations for each action in a given state. Provided results show that the agent is able to to successfully complete quests in small, and even medium size, games."}, {"heading": "C. Natural Language Processing", "text": "Natural Language Processing is present in the history of computers almost from the very beginning. Alan Turing in his famous paper [21] state (approximately) that \u201cexhibit intelligent behavior\u201d means \u201cunderstand natural language and use it properly in conversations with human being\u201d. So, since 1950 Turing test is the way of checking whether computer has reached strong AI capability.\nFirst natural language processing systems were rule based. Thanks to the growing amount of text data and increase of the computer power, during last decades one can observe the shift towards the data driven approaches (statistical or machine learning). Nowadays, NLP very often is done \u201calmost from scratch\u201d, as it was done if [22] where the authors have used neural network in order to solve many NLP tasks, including part-of-speech tagging, named entity recognition and semantic role labeling. The base for this was the neural language model. Moreover, this systems produced (as a side effect) for every word in a vocabulary a dense vector which reflected word properties. This vectors are called word embeddings and can be obtained in many ways. One of the most popular is the one proposed in [23] that uses very simple, linear language model and is suitable to large collections of texts.\nLanguage models allow to compute probability of the sentence treated as a sequence of items (characters, morphemes or words). This task was traditionally done using Markov models (with some smoothing procedures, see [24]). Since predicting current words is often dependent on the long part of history, Markov models (which, by definition, looks only small numbers of words behind) are outperformed by the modern methods that can model long distance dependencies. This methods use recursive (deep) neural networks, often augmented with some memory.\nWe will use both word embeddings (to model words similarity) and LSTM neural networks [25] with attention mechanism (see [26] and [27]). We are particularly interested in the information given from the attention mechanism, which allows us to estimate how important is each word, when we try to predict the next word in the text."}, {"heading": "D. The Text-Based Adventure AI Competition", "text": "The first Text-Based Adventure AI Competition1, organized by the group from the University of York, has been announced in May 2016 and took place at the 2016 IEEE CIG conference in September. The second, will be held this year, also colocated with CIG.\nThe purpose of the competition is to stimulate research towards the transcendent goal of creating General Problem Solver, the task stated nearly six decades ago [28]. The organizers plan to gradually increase the level of given challenges, with time providing more complex games that require more sophisticated approaches from the competitors. Thus, finally force them to develop agents that can autonomously acquire knowledge required to solve given tasks from the restricted domain of text-based games.\nThe domain of the competition is specified as any game that can be described by the Z-machine, the classic text adventuring engine. Interactive Fiction games are distributed as compiled byte code, requiring the special interpreter to run them. The first Z-machine has been developed in 1979 by Infocom, and supports games developed using a LISP-like programming language named Infocom\u2019s ZIL (Zork Implementation\n1http://atkrye.github.io/IEEE-CIG-Text-Adventurer-Competition/.\nLanguage). The Text-based AI Competition uses Frotz2, the modern version of the Z-machine, compatible with the original interpreter.\nThe competition organizers provide a Java package managing the communication between a game file and an agent process. Also, example random agents in Java and Python 3 are available. The interpreter is extended by the three additional commends, allowing players to quit the game, restart it with a new instance of the agent, and restart without modifying the agent. Given that, the text-based AI framework supports learning and simulation-based approaches.\nLittle details about the competition insides are available. In particular, the number of participants is unknown, and the test environment game used to evaluate agents remained hidden, as it is likely to be used again this year. The game has been developed especially for the purpose of the competition and supports graduated scale of scoring points, depending on the quality of agent\u2019s solution.\nThe winner of the first edition was the BYU-Agent3 from the Perception Control and Cognition lab at Brigham Young University, which achieved a score 18 out of 100. The idea behind the agent has been described in [15]. It uses Q-learning [29] to estimate the utility of an action in a given game state, identified as the hash of its textual description.\nThe main contribution concerns affordance detection, used to generating reasonable set of actions. Based on the word2vec [30], an algorithm mapping words into a vector representations based on their contextual similarities, and the Wikipedia as the word corpus, the verb-noun affordances are generated. Thus, the algorithm is able to detect, for an in-game object, words with a similar meaning, and provide a set of actions that are possible to undertake with that object.\nProvided results, based on the IF games compatible with Zmachine interpreter, shows the overall ability of the algorithm to successfully play text-based games. Usually, the learning process results in increasing score, and requires playing a game at least 200 times to reach the peek. However, there are some games that achieve that point much slower, or even the score drops as the learning continues."}, {"heading": "III. THE GAME PLAYING AGENT", "text": ""}, {"heading": "A. Overview", "text": "Our agent is characterized by the following features.:\n\u2022 it uses a huge set of predefined command patterns, obtained by analyzing various domain-related sources; the actual commands are obtained by suitable replacements; \u2022 it uses language models based on selection of fantasy books; \u2022 it takes advantage of the game-specific behaviors, natural for adventure games, like fight mode, equipment management, movement strategy;\n2http://frotz.sourceforge.net. 3The agent is open source and available at https://github.com/danielricks/\nBYU-Agent-2016.\n\u2022 it memorizes and uses some aspects of the current play history; \u2022 it tries to imitate human behavior: after playing several games and exploring the game universe it repeats the most promising sequence of commands. We treat the result reached in this final trial as the agent\u2019s result in this game.\nThe agent was named \u201cGolovin\u201d, as one of the first answers it gives after asking Hey bot, what is your name?, was your name is Golovin, a phrase from the game Doomlords."}, {"heading": "B. Preprocessing", "text": "1) Language Models: We used language models for two purposes. First, they allow us to define words similarity (which in turns gives us opportunity to replace some words in commands with their synonyms). For this task we use word2vec [30] (and its implementation in TensorFlow [31]). Secondly, we use neural network language models to determine which words in the scene description plays more important role than other (and so are better candidates to be a part of the next command). We use the LSTM neural networks operating on words [25], augmented by the attention mechanism ([26] and [27]). This combination was previously tested in [32].\nSince the action of many games is situated in fantasy universe, we decided to train our models on the collection of 3000 fantasy books from bookrix.com (instead of using Wikipedia, as in [15]).\n2) Commands: In order to secure out agent against overfitting, we fix the set of games used in tests (the same 50 games as in [15]). No data somehow related to this games were used in any stage of preprocessing.\nWe considered three methods to gather commands: \u2022 walkthroughs \u2013 for several games, sequence of com-\nmands from winning path can be found in the Internet. This source provides raw valid commands, that are useful in some games. \u2022 tutorials \u2013 on the other hand, some games have tutorials written in natural language. Analyzing such tutorials4\nseemed to be a promising way of getting valid command. Concept of reading manuals has been successfully used to learn how to play Civilization II game [33]. \u2022 games \u2013 at the end, there are many games that don\u2019t have tutorials nor walkthroughs. We downloaded a big collection of games, decompiled their codes, and extracted all texts from them.\nThe last two sources required slightly more complicated preprocessing. After splitting texts into sentences, we parsed them using PCFG parser from NLTK package [34]. Since commands are (in general) verb phrases, we found all minimal VP phrases from parse trees. After reviewing some of them, we decided not to take every found phrase, but manually create the list of conditions which characterizes \u2019verb phrases useful in games\u2019. In this way we obtained the collections of\n4This tutorials were downloaded from the following sites: http://www. ifarchive.org/, https://solutionarchive.com/, http://www.gameboomers.com/, http://www.plover.net/~davidw/sol/\napproximately 250,000 commands (or, to be more precisely, command patterns). We also remember the count of every command (i.e. the number of parse tree it occurs in).\nSome of the commands have special tag: \u201cuseful in the battle\u201d. We have manually chosen five verbs, as the most commonly related to fighting: attack, kill, fight, shoot, and punch. Approximately 70 most frequent commands containing one of these verbs received this tag.\nThe commands used by our agent were created from these patterns by replacing (some) nouns by nouns taken from the game texts."}, {"heading": "C. Playing Algorithm", "text": "The algorithm uses 5 types of command generators: battle mode, gathering items, inventory commands, general actions (interacting with environment), and movement. The generators are fired in the given order, until a non-empty set of commands is proposed.\nThere are multiple reasons why some generator may not produce any results, e.g. the agent reaches the predefined limit of making actions of that type, all the candidates are blacklisted, or simply we cannot find any appropriate command in the database. We will describe other special cases later.\nWhen the description of the area changes, all the command lists are regenerated.\n1) Generating Commands: Our general method to compute available commands and choose the one which is carried out, looks as follows:\n1) Find all nouns in the state description and agent\u2019s equipment. (We accept all type of nouns classified by the nltk.pos_tag function.) 2) Determine their synonyms, based on the cosine similarity between word vectors. (We use n-best approach with n being subject to Spearmint optimization; see IV-A.) 3) Find the commands containing nouns from the above described set. If a command contains a synonym, it is replaced by the word originally found in the description. 4) Score each command taking into account: \u2022 cosine similarity between used synonyms and the\noriginal words \u2022 uniqueness of the words in command, computed as\nthe inverse of number of occurrences in the corpora. \u2022 the weight given by the neural network model \u2022 the number of words occurring both in the descrip-\ntion and in the command The score is computed as the popularity of the command (number of occurrences in the command database) multiplied by the product of the above. The formula uses some additional constants influencing the weights of the components. 5) Then, using the score as the command\u2019s weight, randomly pick one command using the roulette wheel selection.\n2) Battle Mode: The battle mode has been introduced to improve the agent\u2019s ability to survive. It prevents from what\nhas been the main cause of agent\u2019s death before \u2013 careless walking into an enemy or spending too much time searching for the proper, battle-oriented and life-saving, action.\nThe agent starts working in battle mode after choosing one of the \u201cfight commands\u201d. Being in this mode, the agent strongly prefers using battle command, moreover it repeats the same command several times (even if it fails), because in many games the opponent has to be attacked multiple times to be defeated. Therefore, between the consecutive fighting actions we prevent using standard commands (like look, examine), as wasting precious turns usually gives the opponent an advantage.\n3) Inventory Management (gathering and using items): In every new area, the algorithm searches its description for interesting objects. It creates a list of nouns ordered by the weight given by the neural network model and their rarity. Then, the agent tries take them.\nIf it succeeds (the content of the inventory has changed), a new list of commands using only the newly acquired item is generated (using the general method). The constant number of highest scored commands is immediately executed.\n4) Exploration: The task of building an IF game map is difficult for two reasons. One, because a single area can be presented using multiple descriptions and they may change as the game proceeds. Two, because there may be different areas described by the same text. Our map building algorithm tries to handle these problems.\nWe have found that usually the first sentence of the area description remains unchanged, so we use it to label the nodes of the graph (we have tried other heuristics as well but they performed worse). This heuristic divides all visited nodes into the classes suggesting that corresponding areas may be equivalent. The edges of the graph are labeled by the move commands used to translocate between the nodes (we assume that movement is deterministic).\nWe initialize the map graph using the paths corresponding to the past movements of the agent. Then, the algorithm takes all pairs of nodes with the same label and considers them in a specific, heuristic-based, order. For every pair, the MergeNodes procedure (Listing 1) is fired. The procedure merges two states joining their outcoming edges and recursively proceeds to the pairs of states that are reachable using the same move command. If the procedure succeeds, we replaces current map graph with the minimized one, otherwise the changes are withdrawn.\nWe use a small fixed set of movement commands (south, northwest, up, left, etc.) to reveal new areas and improve the knowledge about the game layout. When the agent decides to leave the area, it tries a random direction, unless it already discovered all outgoing edges \u2013 then it uses map to find a promising destination. We evaluate destination nodes minimizing the distance to that node plus the number of tested commands divided by the node\u2019s curiosity (depending on scores of available commands and untested movement commands). Then, the agent follows the shortest path to the best scored destination.\nAlgorithm 1 MergeNodes(A, B) 1: if A = B then return True end if 2: if label(A)6=label(B) then return False end if 3: mergelist \u2190 {} 4: for all m \u2208MoveCommands do 5: if A.moveby(m) 6=None \u2227 B.moveby(m) 6=None then 6: mergelist.append((A.moveby(m), B.moveby(m))) 7: end if 8: end for 9: JoinIncomingAndOutgoingEdges(A, B) 10: for all (A\u2032, B\u2032) \u2208 mergelist do 11: if \u00ac MergeNodes(A\u2032, B\u2032) then return False end if 12: end for 13: return True\n5) Failing Commands: When, after executing a command, the game state (description) remains unchanged, we assume the command failed. Thus, the algorithm puts it on a blacklist assigned to the current location. The command on the location\u2019s black list is skipped by the command generators.\nAfter any change in the agent\u2019s inventory, all blacklists are cleared.\n6) Restarts: The Frotz environment used for the contest allows to restart the game, i.e. abandon current play and start again from the beginning.\nMe make use of this possibility in a commonsense imitating of the human behavior. When the agent dies, it restarts the game and, to minimize the chance of the further deaths, it avoids repeating the last commands of his previous lives. The agent also remembers the sequence of moves that lead to the best score and eventually repeats it. The final trial\u2019s result is used as the agent\u2019s result in the game."}, {"heading": "IV. EXPERIMENTS", "text": "Our experiments had two main objectives: creating the most effective agent, and analyze how some parameters influence the agents performance.\nThe most natural way to measure the agent performance is to use the score given by the game (divided by the maximum score, when we want to compare different games). However, there are many games in which our agent (as well as BYUAgent) has problems with receiving non zero points. So, we have decided to reward any positive score and add to the positive agent result arbitrarily chosen constant 0.2. Therefore, optimal (hypothetical) agent would get 1.2 in every game.\nWe selected 20 games for the training purposes, for all of them the maximum score is known. The performance of the agent is an averaged (modified) score computed on these games."}, {"heading": "A. Creating The Best Agent", "text": "The agent\u2019s play is determined by some parameters, for instance: \u2022 the set of command patterns, \u2022 the number of synonyms taken from word2vec,\n\u2022 the number of items, we are trying to gather, after visiting new place, \u2022 the number of standard command, tried after gathering phase, \u2022 how to reward the commands containing many words from description (the actual reward is bk, where k is the number of common words, and b is a positive constant), \u2022 how to punish the commands containing words with no good reason to be used (neither in state description nor in generated synonyms), the score is divided by pk, where k is the number of such words, and p is a constant, \u2022 how many command should be done before trying movement command.\nFurthermore we wanted to check, whether using battle mode or a map has an observable effect on agent performance. The number of parameter combinations was too large for grid search, so we decided to use Spearmint5.\nWe started this optimization process with (total) score equal to 0.02, and after some hours of computation we end with 0.08 (which means that the score has been multiplied 4 times). From now all parameters (if not stated otherwise) will be taken from the final Spearmint result."}, {"heading": "B. Evaluation of Domain-based Mechanisms", "text": "We wanted to check whether some more advanced features of our agent give observable influence on agent performance. We checked the following 4 configurations with battle-mode and map turned on or off. The results are presented in Figure 1. One can see that map is useful (but only to some extent), and battle mode is undoubtedly useful."}, {"heading": "C. Evaluation of Language Model Sources", "text": "Commands were taken from 3 sources: tutorials (T), walkthroughs (W), and state description from games (G). We compared the agents used command from all combination of these sources. The results are presented in Figure 2. The\n5Spearmint is a package which performs Bayesian optimization of hyperparameters. It allows to treat the optimized function as a black-box, and tries to choose the parameters for the next run considering the knowledge gathered during previous runs. See [35].\noptimal configuration uses only two sources: T and W6. We, however, still believe that decompiled games can be a useful source for game commands. But they cannot be found in descriptions, but in command interpreter \u2013 which requires more advanced automated code analysis. We left it as a future work."}, {"heading": "D. Gameplay Examples", "text": "While playing detective, our agent finds himself in a closet. We get the following state description:\nGame: You are in a closet. There is a gun on the floor. Better get it. To exit, go east.\nOur agent determines items: closet, gun, floor, exit. Our agent is choosing from the commands listed in Table I. We see that what is the most important for the agent is gun and how to take it, which is reasonable and even suggested by the game. Moreover, the agent also tries to search using synonyms of the word gun in order to find proper commands (for instance: we can see that he recognizes gun as some kind of weapon, and some weapons, as for example knife, can be sharpened). Fortunately, after using a command get gun, Golovin obtains a black little pistol.\nAnother example comes from zork3. We start with the following location description:\n6The difference between T+W and G+T+W is not very big. In the previous version of this experiment the winner was G+T+W.\nGame: You are in a shadowy land of low, rolling hills stretching out to the west and south. The land is bordered to the north by a massive stone wall. Ancient and weathered, the wall has crumbled enough at one point to permit passage. A cloaked and hooded person, carrying a sword not unlike your own, is standing blocking the way to the northeast. The hooded figure has a great deal of strength, perhaps matching your own. Golovin: examine figure Game: There is nothing special to be seen. Your quick reflexes cannot stop the hooded figure\u2019s stroke! You are hit!\nIn this very moment, in the agent\u2019s inventory are: a sword, a lamp. In the command list we can find for instance kill man with sword. As the word man is close enough to figure, and Golovin also have sword, he chooses to use command kill figure with sword. Because the fighting command was chosen, the battle mode is turned on, and the game continues as follows:\nGolovin: kill figure with sword Game: The hooded figure is hit with a quick slash! The figure has a light wound which hasn\u2019t affected its seemingly great strength.\nthe agent\u2019s score improves and the fight continues. . . Golovin: kill figure with sword Game: You charge, but the hooded figure jumps nimbly aside. The hooded figure stabs nonchalantly with its sword and misses."}, {"heading": "E. The Comparison with BYU-Agent", "text": "Finally, we validate our approach by comparing it with the BYU-Agent. We were using the same set of 50 Z-machine games7 as in [15].\nThe results of the comparison are presented in Table II. The BYU agent was trained for 1000 epochs (each epoch containing 1000 game steps), and its score was noted after each epoch. Because the learning curves vary depending on the game, including degeneration of the results (see [15,\nFigure 5]), as the main measure we took the maximum score achieved over all epochs.\nAs for the Golovin, we restricted his playing time to 1000 steps (i.e. an equivalent of one epoch) and use our commonsense restarting mechanism.\nThe BYU-Agent results are obtained using the verb and action space reduction algorithm, except the games marked with an asterisk, where the verb space reduction experienced errors, so we present scores obtained by the action space reduction variant instead.\nEventually, there are 24 games, out of 50, where some of the agents received any positive reward. Golovin scored better in 12 games, including 7 games where BYU-Agent received no reward. BYU-Agent scored better in 11 games, including\n7The game set is available at https://github.com/danielricks/textplayer/tree/ master/games.\n6 games where Golovin scored no points. One game is a nonzero tie.\nThus, despite significantly shorter learning time (i.e. available number of steps), our agent is able to outperform BYUAgent on a larger number of games than he is outperformed on. On the other hand, BYU-Agent gains in the games where the Q-learning is effective and gradually increases score through the epochs, e.g. curses, detective or Parc.\nLast observation concerns the number of games where only one of the agents scored 0, which is surprisingly large. This may suggest that the two compared approaches are effective on a different types of games, and may, in some sense, complement each other."}, {"heading": "V. CONCLUSIONS AND FUTURE WORK", "text": "We have presented an agent able to play any interactive fiction game created for human players, on the level comparable to the winner of the last year Text-Based Adventure AI Competition. Due to the number of domain-based mechanisms, our agent can successfully handle the game in a limited number of available steps. The results of the presented experiments show that the mechanisms we embed (battle mode, mapping) and a choice of learning sources, indeed improves the agent\u2019s performance.\nAlthough the results are promising, we are still at the beginning of the path towards creating the agent that can really understand the natural language descriptions in order to efficiently play the text-based adventure games.\nThere are multiple future work directions we would like to point out. First, and one of the most important, is to embed a learning mechanisms: the in-game learning, that uses restart functionality to improve player efficiency in one particular game; and preliminary learning, that is able to gain useful knowledge from playing entire set of games. Also, we plan to take a closer look at the decompiled game codes, as we believe that analyzing them may provide very useful knowledge.\nWe would like to improve the battle mode behavior, especially mitigate the agent and make it more sensitive to the particular situation. We hope that the mapping mechanism can be further extended to allow the casual approach, where the agent travels to distant locations for some specific reason (e.g. item usage), instead of a simple reactive system that we have now.\nLastly, we would like to continue the domain-based approach, and so focus our efforts on discovering the subgames (like we did with fighting and exploring) that we are able to properly detect, and handle significantly better than the general case."}, {"heading": "ACKNOWLEDGMENTS", "text": "The authors would like to thank Szymon Malik for his valuable contribution in the early stage of developing Golovin.\nWe would also like to thank Nancy Fulda for helpful answers to our questions and providing up-to date results of the BYU-Agent."}], "references": [{"title": "Deep Blue", "author": ["M. Campbell", "A.J. Hoane", "F. Hsu"], "venue": "Artificial intelligence, vol. 134, no. 1, pp. 57\u201383, 2002.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2002}, {"title": "Mastering the game of Go with deep neural networks and tree search", "author": ["D. Silver", "A. Huang", "C.J. Maddison", "A. Guez", "L. Sifre", "G. van den Driessche", "J. Schrittwieser", "I. Antonoglou", "V. Panneershelvam", "M. Lanctot", "S. Dieleman", "D. Grewe", "J. Nham", "N. Kalchbrenner", "I. Sutskever", "T. Lillicrap", "M. Leach", "K. Kavukcuoglu", "T. Graepel", "D. Hassabis"], "venue": "Nature, vol. 529, pp. 484\u2013503, 2016.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2016}, {"title": "General Game Playing: Overview of the AAAI Competition", "author": ["M. Genesereth", "N. Love", "B. Pell"], "venue": "AI Magazine, vol. 26, pp. 62\u201372, 2005.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2005}, {"title": "General Game Playing: Game Description Language Specification", "author": ["N. Love", "T. Hinrichs", "D. Haley", "E. Schkufza", "M. Genesereth"], "venue": "Stanford Logic Group, Tech. Rep., 2006.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2006}, {"title": "A General Game Description Language for Incomplete Information Games", "author": ["M. Thielscher"], "venue": "AAAI Conference on Artificial Intelligence, 2010, pp. 994\u2013999.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "Towards a Real-time Game Description Language", "author": ["J. Kowalski", "A. Kisielewicz"], "venue": "International Conference on Agents and Artificial Intelligence, vol. 2, 2016, pp. 494\u2013499.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2016}, {"title": "The 2014 General Video Game Playing Competition", "author": ["D. Perez", "S. Samothrakis", "J. Togelius", "T. Schaul", "S. Lucas", "A. Cou\u00ebtoux", "J. Lee", "C. Lim", "T. Thompson"], "venue": "IEEE Transactions on Computational Intelligence and AI in Games, vol. 8, no. 3, pp. 229\u2013243, 2015.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "General Video Game AI: Competition, Challenges and Opportunities", "author": ["D. Perez", "S. Samothrakis", "J. Togelius", "T. Schaul", "S.M. Lucas"], "venue": "AAAI Conference on Artificial Intelligence, 2016, pp. 4335\u20134337.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2016}, {"title": "General Video Game Level Generation", "author": ["A. Khalifa", "D. Perez", "S. Lucas", "J. Togelius"], "venue": "Genetic and Evolutionary Computation Conference, 2016, pp. 253\u2013259.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2016}, {"title": "Human-level control through deep reinforcement learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski"], "venue": "Nature, vol. 518, no. 7540, pp. 529\u2013533, 2015.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2015}, {"title": "Emergent Tangled Graph Representations for Atari Game Playing Agents", "author": ["S. Kelly", "M.I. Heywood"], "venue": "EuroGP 2017: Genetic Programming, ser. LNCS, 2017, vol. 10196, pp. 64\u201379.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2017}, {"title": "being-in-the-world", "author": ["M.A. DePristo", "R. Zubek"], "venue": "Proceedings of the 2001 AAAI Spring Symposium on Artificial Intelligence and Interactive Entertainment, 2001, pp. 31\u201334.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2001}, {"title": "Adventure games: A challenge for cognitive robotics", "author": ["E. Amir", "P. Doyle"], "venue": "Proc. Int. Cognitive Robotics Workshop, 2002, pp. 148\u2013 155.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2002}, {"title": "What can you do with a rock? Affordance extraction via word embeddings", "author": ["N. Fulda", "D. Ricks", "B. Murdoch", "D. Wingate"], "venue": "International Joint Conference on Artificial Intelligence, 2017, (to appear).", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2017}, {"title": "Put my galakmid coin into the dispenser and kick it: Computational linguistics and theorem proving in a computer game", "author": ["A. Koller", "R. Debusmann", "M. Gabsdil", "K. Striegnitz"], "venue": "Journal of Logic, Language and Information, vol. 13, no. 2, pp. 187\u2013206, 2004.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2004}, {"title": "Knowledge-gathering agents in adventure games", "author": ["B. Hlubocky", "E. Amir"], "venue": "AAAI-04 workshop on Challenges in Game AI, 2004.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2004}, {"title": "Goal Achievement in Partially Known, Partially Observable Domains", "author": ["A. Chang", "E. Amir"], "venue": "Proceedings of the Sixteenth International Conference on International Conference on Automated Planning and Scheduling, 2006, pp. 203\u2013211.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2006}, {"title": "Language Understanding for Text-based Games using Deep Reinforcement Learning", "author": ["K. Narasimhan", "T. Kulkarni", "R. Barzilay"], "venue": "Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, 2015, pp. 1\u201311.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2015}, {"title": "Long Short-Term Memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural Comput., vol. 9, no. 8, pp. 1735\u20131780, 1997.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1997}, {"title": "Computing machinery and intelligence", "author": ["A.M. Turing"], "venue": "Mind, vol. 59, no. 236, pp. 433\u2013460, 1950. [Online]. Available: http: //www.jstor.org/stable/2251299", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1950}, {"title": "Natural language processing (almost) from scratch", "author": ["R. Collobert", "J. Weston", "L. Bottou", "M. Karlen", "K. Kavukcuoglu", "P.P. Kuksa"], "venue": "CoRR, vol. abs/1103.0398, 2011. [Online]. Available: http://arxiv.org/abs/1103.0398", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "Efficient estimation of word representations in vector space", "author": ["T. Mikolov", "K. Chen", "G. Corrado", "J. Dean"], "venue": "CoRR, vol. abs/1301.3781, 2013. [Online]. Available: http://arxiv.org/abs/1301.3781", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "An empirical study of smoothing techniques for language modeling", "author": ["S.F. Chen", "J. Goodman"], "venue": "Proceedings of the 34th Annual Meeting on Association for Computational Linguistics, ser. ACL \u201996. Stroudsburg, PA, USA: Association for Computational Linguistics, 1996, pp. 310\u2013318. [Online]. Available: http://dx.doi.org/ 10.3115/981863.981904", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1996}, {"title": "A neural probabilistic language model", "author": ["Y. Bengio", "R. Ducharme", "P. Vincent", "C. Jauvin"], "venue": "JOURNAL OF MACHINE LEARNING RE- SEARCH, vol. 3, pp. 1137\u20131155, 2003.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2003}, {"title": "Feed-forward networks with attention can solve some long-term memory problems", "author": ["C. Raffel", "D.P.W. Ellis"], "venue": "CoRR, vol. abs/1512.08756, 2015. [Online]. Available: http://arxiv.org/abs/1512.08756", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2015}, {"title": "Long short-term memory-networks for machine reading", "author": ["J. Cheng", "L. Dong", "M. Lapata"], "venue": "CoRR, vol. abs/1601.06733, 2016. [Online]. Available: http://arxiv.org/abs/1601.06733", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2016}, {"title": "Report on a general problem solving program", "author": ["A. Newell", "J.C. Shaw", "H.A. Simon"], "venue": "Proceedings of the International Conference on Information Processing, 1959, pp. 256\u2013264.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1959}, {"title": "Q-learning", "author": ["C.J. Watkins", "P. Dayan"], "venue": "Machine learning, vol. 8, no. 3-4, pp. 279\u2013292, 1992.", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1992}, {"title": "Efficient estimation of word representations in vector space", "author": ["T. Mikolov", "K. Chen", "G. Corrado", "J. Dean"], "venue": "2013, arXiv:1301.3781 [cs.CL].", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2013}, {"title": "TensorFlow: Large-scale machine learning on heterogeneous systems", "author": ["A M."], "venue": "2015, software available from tensorflow.org. [Online]. Available: http://tensorflow.org/", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2015}, {"title": "Application of artificial neural networks with attention mechanism for discovering distant dependencies in time series", "author": ["S. Malik"], "venue": "Bachelor Thesis, University of Wroc\u0142aw, 2016.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning to Win by Reading Manuals in a Monte-Carlo Framework", "author": ["S. Branavan", "D. Silver", "R. Barzilay"], "venue": "Journal of Artificial Intelligence Research, vol. 43, pp. 661\u2013704, 2012.", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2012}, {"title": "Natural Language Processing with Python, 1st ed", "author": ["S. Bird", "E. Klein", "E. Loper"], "venue": null, "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2009}, {"title": "Practical bayesian optimization of machine learning algorithms", "author": ["J. Snoek", "H. Larochelle", "R.P. Adams"], "venue": "Advances in Neural Information Processing Systems 25, F. Pereira, C. J. C. Burges, L. Bottou, and K. Q. Weinberger, Eds. Curran Associates, Inc., 2012, pp. 2951\u20132959.", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 0, "context": "This strategy allowed to beat the single games which were set as the milestones for the AI development: Chess [1] and Go [2].", "startOffset": 110, "endOffset": 113}, {"referenceID": 1, "context": "This strategy allowed to beat the single games which were set as the milestones for the AI development: Chess [1] and Go [2].", "startOffset": 121, "endOffset": 124}, {"referenceID": 2, "context": "Currently, there are two main, well-established GGP domains providing their own game specification languages and competitions [4].", "startOffset": 126, "endOffset": 129}, {"referenceID": 3, "context": "in 2005 and it is based on the Game Description Language (GDL), which can describe all finite, turn-based, deterministic games with full information [5], and its extensions (GDL-II [6] and rtGDL [7]).", "startOffset": 149, "endOffset": 152}, {"referenceID": 4, "context": "in 2005 and it is based on the Game Description Language (GDL), which can describe all finite, turn-based, deterministic games with full information [5], and its extensions (GDL-II [6] and rtGDL [7]).", "startOffset": 181, "endOffset": 184}, {"referenceID": 5, "context": "in 2005 and it is based on the Game Description Language (GDL), which can describe all finite, turn-based, deterministic games with full information [5], and its extensions (GDL-II [6] and rtGDL [7]).", "startOffset": 195, "endOffset": 198}, {"referenceID": 6, "context": "The second one is the General Video Game AI framework (GVGAI) from 2014, which focuses on arcade video games [8].", "startOffset": 109, "endOffset": 112}, {"referenceID": 7, "context": "ple tracks, including procedural content generation challenges [9], [10].", "startOffset": 63, "endOffset": 66}, {"referenceID": 8, "context": "ple tracks, including procedural content generation challenges [9], [10].", "startOffset": 68, "endOffset": 72}, {"referenceID": 9, "context": "In some sense, this approach is coherent with the experiments on learning Atari 2600 games using the Arcade Learning Environment (ALE), where the agent\u2019s inputs were only raw screen capture and a score counter [11], [12].", "startOffset": 210, "endOffset": 214}, {"referenceID": 10, "context": "In some sense, this approach is coherent with the experiments on learning Atari 2600 games using the Arcade Learning Environment (ALE), where the agent\u2019s inputs were only raw screen capture and a score counter [11], [12].", "startOffset": 216, "endOffset": 220}, {"referenceID": 11, "context": "Although some approaches tackling similar problems exist since early 2000s ([13], [14]), we are still at the entry point for this kind of problems, which are closely related to the general problem solving.", "startOffset": 76, "endOffset": 80}, {"referenceID": 12, "context": "Although some approaches tackling similar problems exist since early 2000s ([13], [14]), we are still at the entry point for this kind of problems, which are closely related to the general problem solving.", "startOffset": 82, "endOffset": 86}, {"referenceID": 13, "context": "Also, we tested our agent against the winner of the last year competition [15].", "startOffset": 74, "endOffset": 78}, {"referenceID": 12, "context": "Adventure games has been carefully revised as the field of study for the cognitive robotics in [14].", "startOffset": 95, "endOffset": 99}, {"referenceID": 11, "context": "In [13], the agent able to live and survive in an existing MUD game have been described.", "startOffset": 3, "endOffset": 7}, {"referenceID": 14, "context": "While not directly-related to playing algorithms, it is worth to note the usage of computational linguistics and theorem proving to build an engine for playing text-based adventure games [16].", "startOffset": 187, "endOffset": 191}, {"referenceID": 15, "context": "The approach focused on tracking the state of the world in text-based games, and translating it into the first-order logic, has been presented in [17].", "startOffset": 146, "endOffset": 150}, {"referenceID": 16, "context": "The extension of the above approach, presents the agent that can solve puzzle-like tasks in partially observable domain that is not known in advance, assuming actions are deterministic and without conditional effects [18].", "startOffset": 217, "endOffset": 221}, {"referenceID": 17, "context": "Recently, an advanced MUD playing agent has been described in [19].", "startOffset": 62, "endOffset": 66}, {"referenceID": 18, "context": "First, responsible for converting textual descriptions to state representation is based on the Long Short-term Memory (LSTM) networks [20].", "startOffset": 134, "endOffset": 138}, {"referenceID": 9, "context": "Second, uses Deep Q-Networks [11] to learn approximated evaluations for each action in a given state.", "startOffset": 29, "endOffset": 33}, {"referenceID": 19, "context": "Alan Turing in his famous paper [21] state (approximately) that \u201cexhibit", "startOffset": 32, "endOffset": 36}, {"referenceID": 20, "context": "Nowadays, NLP very often is done \u201calmost from scratch\u201d, as it was done if [22] where the authors have used neural network in order to solve many NLP tasks, including part-of-speech tagging, named entity recognition and semantic role labeling.", "startOffset": 74, "endOffset": 78}, {"referenceID": 21, "context": "One of the most popular is the one proposed in [23] that uses very simple, linear language model and is suitable to large collections of texts.", "startOffset": 47, "endOffset": 51}, {"referenceID": 22, "context": "This task was traditionally done using Markov models (with some smoothing procedures, see [24]).", "startOffset": 90, "endOffset": 94}, {"referenceID": 23, "context": "We will use both word embeddings (to model words similarity) and LSTM neural networks [25] with attention mechanism (see [26] and [27]).", "startOffset": 86, "endOffset": 90}, {"referenceID": 24, "context": "We will use both word embeddings (to model words similarity) and LSTM neural networks [25] with attention mechanism (see [26] and [27]).", "startOffset": 121, "endOffset": 125}, {"referenceID": 25, "context": "We will use both word embeddings (to model words similarity) and LSTM neural networks [25] with attention mechanism (see [26] and [27]).", "startOffset": 130, "endOffset": 134}, {"referenceID": 26, "context": "Solver, the task stated nearly six decades ago [28].", "startOffset": 47, "endOffset": 51}, {"referenceID": 13, "context": "The idea behind the agent has been described in [15].", "startOffset": 48, "endOffset": 52}, {"referenceID": 27, "context": "It uses Q-learning [29] to estimate the utility of an action in a given game state, identified as the hash of its textual description.", "startOffset": 19, "endOffset": 23}, {"referenceID": 28, "context": "Based on the word2vec [30], an algorithm mapping words into a vector representations based on their contextual similarities, and the Wikipedia as the word corpus, the verb-noun affordances are generated.", "startOffset": 22, "endOffset": 26}, {"referenceID": 28, "context": "For this task we use word2vec [30] (and its implementation in TensorFlow [31]).", "startOffset": 30, "endOffset": 34}, {"referenceID": 29, "context": "For this task we use word2vec [30] (and its implementation in TensorFlow [31]).", "startOffset": 73, "endOffset": 77}, {"referenceID": 23, "context": "We use the LSTM neural networks operating on words [25], augmented by the attention mechanism ([26] and [27]).", "startOffset": 51, "endOffset": 55}, {"referenceID": 24, "context": "We use the LSTM neural networks operating on words [25], augmented by the attention mechanism ([26] and [27]).", "startOffset": 95, "endOffset": 99}, {"referenceID": 25, "context": "We use the LSTM neural networks operating on words [25], augmented by the attention mechanism ([26] and [27]).", "startOffset": 104, "endOffset": 108}, {"referenceID": 30, "context": "This combination was previously tested in [32].", "startOffset": 42, "endOffset": 46}, {"referenceID": 13, "context": "com (instead of using Wikipedia, as in [15]).", "startOffset": 39, "endOffset": 43}, {"referenceID": 13, "context": "2) Commands: In order to secure out agent against overfitting, we fix the set of games used in tests (the same 50 games as in [15]).", "startOffset": 126, "endOffset": 130}, {"referenceID": 31, "context": "to learn how to play Civilization II game [33].", "startOffset": 42, "endOffset": 46}, {"referenceID": 32, "context": "After splitting texts into sentences, we parsed them using PCFG parser from NLTK package [34].", "startOffset": 89, "endOffset": 93}, {"referenceID": 33, "context": "See [35].", "startOffset": 4, "endOffset": 8}, {"referenceID": 13, "context": "We were using the same set of 50 Z-machine games7 as in [15].", "startOffset": 56, "endOffset": 60}], "year": 2017, "abstractText": "The domain of text-based adventure games has been recently established as a new challenge of creating the agent that is both able to understand natural language, and acts intelligently in text-described environments. In this paper, we present our approach to tackle the problem. Our agent, named Golovin, takes advantage of the limited game domain. We use genre-related corpora (including fantasy books and decompiled games) to create language models suitable to this domain. Moreover, we embed mechanisms that allow us to specify, and separately handle, important tasks as fighting opponents, managing inventory, and navigating on the game map. We validated usefulness of these mechanisms, measuring agent\u2019s performance on the set of 50 interactive fiction games. Finally, we show that our agent plays on a level comparable to the winner of the last year Text-Based Adventure AI Competition.", "creator": "LaTeX with hyperref package"}}}