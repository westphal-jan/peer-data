{"id": "1705.09064", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-May-2017", "title": "MagNet: a Two-Pronged Defense against Adversarial Examples", "abstract": "Deep learning has shown promising results on hard perceptual problems in recent years. However, deep learning systems are found to be vulnerable to small adversarial perturbations that are nearly imperceptible to human. Such specially crafted perturbations cause deep learning systems to output incorrect decisions, with potentially disastrous consequences. These vulnerabilities hinder the deployment of deep learning systems where safety or security is important. Attempts to secure deep learning systems either target specific attacks or have been shown to be ineffective.", "histories": [["v1", "Thu, 25 May 2017 06:49:57 GMT  (310kb,D)", "http://arxiv.org/abs/1705.09064v1", "In submission as a conference paper"], ["v2", "Mon, 11 Sep 2017 02:41:15 GMT  (2417kb,D)", "http://arxiv.org/abs/1705.09064v2", "Accepted at the ACM Conference on Computer and Communications Security (CCS), 2017"]], "COMMENTS": "In submission as a conference paper", "reviews": [], "SUBJECTS": "cs.CR cs.LG", "authors": ["dongyu meng", "hao chen"], "accepted": false, "id": "1705.09064"}, "pdf": {"name": "1705.09064.pdf", "metadata": {"source": "META", "title": "MagNet: a Two-Pronged Defense against Adversarial Examples", "authors": ["Dongyu Meng", "Hao Chen"], "emails": ["mengdy@shanghaitech.edu.cn", "chen@ucdavis.edu"], "sections": [{"heading": null, "text": "In this paper, we propose MagNet, a framework for defending neural network classifiers against adversarial examples. MagNet does not modify the protected classifier or know the process for generating adversarial examples. MagNet includes one or more separate detector networks and a reformer network. Different from previous work, MagNet learns to differentiate between normal and adversarial examples by approximating the manifold of normal examples. Since it does not rely on any process for generating adversarial examples, it has substantial generalization power. Moreover, MagNet reconstructs adversarial examples by moving them towards the manifold, which is effective for helping classify adversarial examples with small perturbation correctly. We discuss the intrinsic difficulty in defending against whitebox attack and propose a mechanism to defend against graybox attack. Inspired by the use of randomness in cryptography, we propose to use diversity to strengthen MagNet. We show empirically that MagNet is effective against most advanced state-of-the-art attacks in blackbox and graybox scenarios while keeping false positive rate on normal examples very low."}, {"heading": "1 INTRODUCTION", "text": "In recent years, deep learning demonstrated impressive performance on many tasks, such as image classification [8] and natural language processing [15]. However, recent research showed that an attacker could generate adversarial examples to fool classifiers [33, 5, 23, 18]. Their algorithms perturbed benign examples, which were correctly classified, by a small amount that did not affect human recognition but that caused neural networks to mis-classify. We call theses neural networks target classifiers.\nWe can divide defenses against adversarial examples into three approaches: (1) Training the target classifier with adversarial examples, called adversarial training [33, 5]; (2) Training a classifier to distinguish between normal and adversarial examples [19]; and (3) Making target classifiers hard to attack by blocking gradient pathway, e.g., defensive distillation [24].\nHowever, all these approaches have limitations. Both (1) and (2) require adversarial examples to train the defense, so the defense is specific to the process for generating these adversarial examples.\nFor (3), Carlini et al. showed that defensive distillation did not significantly increase the robustness of neural networks [2]. Moreover, this approach requires changing and retraining the target classifier, which adds engineering complexities.\nWe propose MagNet1, a defense against adversarial examples with two novel properties. First, it does not modify the target classifier or rely on specific properties of the classifier, so we may use it to protect a wide range of neural networks. MagNet uses the target classifier as a blackbox, e.g., reading the output of its last layer, but MagNet neither reads data on any internal layer nor modifies the classifier. Second, MagNet is independent of any adversarial example generating process, as it needs only normal examples for training."}, {"heading": "1.1 Adversarial examples", "text": "A normal example x for a classification task is an example that occurs naturally. In other words, the natural data generation process for this classification task generates x with non-negligible probability. For example, if the task is classifying handwritten digits, then the data generation process rarely generates an image of a tiger. 1Imagine the manifold of normal examples as a magnet and test examples as iron particles in a high-dimensional space. The magnet is able to attract and move nearby particles (illustrating the effect of our reformer) but refuses to move distant particles (illustrating the effect of our detectors).\nar X\niv :1\n70 5.\n09 06\n4v 1\n[ cs\n.C R\n] 2\n5 M\nay 2\n01 7\nAn adversarial example y for a classifier is not a normal example and the classifier\u2019s decision on y disagrees with human\u2019s prevailing judgment. See Section 3.1 for a more detailed discussion.\nResearchers speculate that for many AI tasks, their relevant data lie on a manifold that is of much lower dimension than the full sample space [22]. This suggests that all the normal examples for a classification task are on a manifold, and all adversarial examples are off the manifold."}, {"heading": "1.2 Causes of mis-classification and solutions", "text": "A classifier mis-classifies an adversarial example for two reasons.\n(1) The adversarial example is far from the boundary of the manifold of the task. For example, the task is handwritten digit classification, and the adversarial example is an image that does not contain a digit. If the classifier does not have an option to reject this example (i.e., is forced to output a class label), then mis-classification occurs. (2) The adversarial example is close to the boundary of the manifold. If the classifier generalizes poorly off the manifold in the vicinity of the adversarial example , then misclassification occurs.\nWe propose MagNet to mitigate these problems. To deal with the first problem, MagNet uses a detector to detect how different a test example is from normal examples. The detector learns a function f : X \u2192 {0, 1}, where X is the set of all examples. f (x) tries to measure the distance between the example x and the manifold. If this distance is greater than a threshold, then the detector rejects x .\nTo deal with the second problem, MagNet uses a reformer to reform adversarial examples. For this we use autoencoders, which are neural networks trained to attempt to copy its input to its output, where the hidden layer is often a simpler representation of the input. After we train an autoencoder with adequate normal examples, we expect it to learn an approximate manifold of the data. Given an adversarial example x close to the boundary of the manifold, we expect the autoencoder to output an example y on the manifold where y is close to x . This way, the autoencoder reforms the adversarial example x to a similar normal example y. Figure 1 shows the effect of the reformer.\nSince MagNet is independent of the target classifier, we assume that the attacker always knows the classifier and its parameters. In the case of blackbox attack on MagNet, the attacker does not know defense parameters. In this setting, we evaluated MagNet on popular attacks [25, 21, 2]. On the MNIST data set, MagNet achieved more than 99% classification accuracy on adversarial examples generated by nine out of ten attacks considered. On the CIFAR-10 dataset, the classification accuracy improvement was also significant. Particularly, MagNet achieved high accuracy on adversarial examples generated by Carlini\u2019s attack, the most powerful attack known to us, across a wide range of confidence levels of the attack on both data sets. To our knowledge, this is the first effective defense against Carlini\u2019s attack. Note that we trained our defense without using any adversarial examples generated by the attack. In the case of whitebox attack, the attacker knows the parameters of MagNet. In this case, the attacker could viewMagNet\u2019s autoencoder and the target classifier as a new composite classifier, and then generate adversarial examples against this composite classifier. Not\nsurprisingly, we found that the performance of MagNet on whitebox attack degraded sharply. When we trained Carlini\u2019s attack on our reformer, the attack was able to generate adversarial examples that fooled our reformer 100%. In fact, we can view any defense against adversarial examples as enhancing the target classifier. As long as the enhanced classifier is imperfect (i.e., unable to match human decisions), adversarial examples are guaranteed to exist. One could make it difficult to find these examples, e.g., by hiding the defense mechanism or its parameters, but these are precluded in whitebox attack.\nWe advocate defense via diversity. We draw our inspiration from cryptography. The security of a good cipher relies on the diversity of its keys, as long as there is no better attack than searching the key space by brute force and this search is computationally infeasible. Adopting a similar approach, we create a number of different defenses and randomly pick one at run time. This way, we defend against graybox attack (Section 3.3). In our implementation, we trained a number of different autoencoders as described above. If the attacker cannot predict which of these autoencoders is used at run time, then he has to generate adversarial examples that can fool all of them. As the number and diversity of these autoencoders grows, it becomes more difficult for the attacker to find adversarial examples. Section 5.4 will show that this technique raises the classification accuracy on Carlini\u2019s adversarial examples from 0 (whitebox attack) to 80% (graybox attack).\nWe may also take advantage of these diverse autoencoders to build another detector, which distinguishes between normal and adversarial examples. The insight is that since normal examples are on the manifold, they change little after being transformed by an autoencoder. By contrast, since adversarial examples are not on the manifold, they change more significantly after being transformed by the autoencoder. We use the similarity between an example and its output from an autoencoder as a metric. But in contrast to the previous detector, which computes the distance between a test example and the manifold without consulting the target classifer, here we enlist the help from the target classifier. We assume that the classifier outputs the probability distribution of the test example on each label. Let this distribution be p(y;x) for the original test example x , and q(y; f (x)) for the output of the autoencoder f on x , where y is the random variable for class labels. We use the JensenShannon divergence between p and q as the similarity measure. Note that although this approach uses the target classifier, during training it does not depend on any specific classifier. It uses the classifier to compute the similarity measure only during testing. We found this detector more sensitive than the previous detector on powerful attacks (Section 5.3)."}, {"heading": "1.3 Contributions", "text": "We make the following contributions.\n\u2022 We formally define adversarial example and metrics for evaluating defense against adversarial examples (Section 3.1). \u2022 We propose a defense against adversarial examples. The defense is independent of either the target classifier or the process for generating adversarial examples (Section 4.1, Section 4.2).\n\u2022 We argue that it would be very difficult to defend against whitebox attacks. Therefore, we propose the graybox threat model and advocate defending against such attacks using diversity. We demonstrate two approaches using diversity (Section 4.3)."}, {"heading": "2 BACKGROUND AND RELATEDWORK", "text": ""}, {"heading": "2.1 Deep learning systems in adversarial environments", "text": "Deep learning systems play an increasingly important role in modern world. They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12]. These security-critical domains require better understanding of neural networks from the security perspective.\nRecent work has demonstrated the feasibility of attacking such systems with carefully crafted input [2, 27, 7] for real-world systems. More specifically, researchers showed that it was possible to generate adversarial examples to fool classifiers [33, 5, 23, 18]. Their algorithms perturbed normal examples by a small volume that did not affect human recognition but that caused mis-classification by the learning system. Therefore, how to protect such classifiers from adversarial examples is a real concern."}, {"heading": "2.2 Distance metrics", "text": "By definition, adversarial examples and their normal counterparts should be visually indistinguishable by humans. Since it is hard to model human perception, researchers proposed three popular metrics to approximate human\u2019s perception of visual difference, namely L0, L2, and L\u221e [2]. These metrics are special cases of the Lp norm:\n\u2225x \u2225p = ( n\u2211 i=1 |xi |p ) 1 p\nThese three metrics focus on different aspects of visual significance. L0 counts the number of pixels with different values at corresponding positions in the two images. It answers the question of how many pixels are changed. L2 measures the Euclidean distance between the two images. L\u221e measures the maximum difference for all pixels at corresponding positions in the two images.\nThere has been debates about which metric is the best, but we will not discuss this question. Instead, we evaluated our defense on successful attacks, which cover all these three metrics."}, {"heading": "2.3 Past attacks", "text": "Since the discovery of adversarial examples for neural networks in [33], researchers found adversarial examples on various network architectures including feedforward convolutional classification networks [2], generative networks [13], and recurrent networks [26]. Adversarial examples threaten many applications, e.g., classification[21] and semantic segmentation [34]. Researchers developed several methods for generating adversarial examples, most of which leveraged gradient based optimization from normal examples [2, 33, 5]. Moosavi et al. showed that it was even possible to find one effective universal adversarial perturbation that, when applied, turned many images adversarial [20].\nTo simplify the discussion, we only focus on attacks targeting neural network classifiers. We evaluated our defense against four popular, and arguably most advanced, attacks. We now explain these attacks.\n2.3.1 Fast gradient sign method(FGSM). Given a normal image x , fast gradient sign method [5] looks for a similar image x \u2032 in the L\u221e neighborhood of x that fools the classifier. It defines a loss function Loss(x , l) that describes the cost of classifying x as label l . Then, it transforms the problem to maximizing Loss(x \u2032, lx ) which is the cost of classifying image x \u2032 as its ground truth label lx while keeping the perturbation small. Fast gradient sign method solves this optimization problem by performing one step gradient update from x in the image space with volume \u03f5 . The update step-width \u03f5 is identical for each pixel, and the update direction is determined by the sign of gradient at this pixel. Formally, the adversarial example x \u2032 is calculated as:\nx \u2032 = x + \u03f5 \u00b7 si\u0434n(\u2207xLoss(x , lx )) Although this attack is simple, it is fast and can be quite powerful. Normally, \u03f5 is set to be small. Increasing \u03f5 usually leads to higher attack success rate. For this paper, we use FGSM to refer to this attack.\n2.3.2 Iterative gradient sign Method. [16] proposed to improve FGSM by using a finer iterative optimization strategy. For each iteration, the attack performs FGSM with a smaller step-width \u03b1 , and clips the updated result so that the updated image stays in the \u03f5 neighborhood of x . Such iteration is then repeated for several times. For the ith iteration, the update process is:\nx \u2032i+1 = clip\u03f5,x (x \u2032 i + \u03b1 \u00b7 si\u0434n(\u2207xLoss(x , lx )))\nThis update strategy can be used for both L\u221e and L2 metrics and greatly improves the FGSM attack. We refer to this attack as the iterative method for the rest of the paper.\n2.3.3 DeepFool. DeepFool is also an iterative attack but formalizes the problem in a different way [21]. The basic idea is to find the closest decision boundary from a normal image x in the image space, and then to cross that boundary to fool the classifier. It is hard to solve this problem directly in the high-dimensional and highly non-linear space in neural networks. So instead, it iteratively solves this problem with a linearized approximation. More specifically, for each iteration, it linearizes the classifier around the intermediate x \u2032 and derives an optimal update direction on this linearized model. It then updates x \u2032 towards this direction by a small step \u03b1 . By repeating the linearize-update process until x \u2032 crosses the decision boundary, the attack finds an adversarial example with small perturbation. We use the L\u221e version of the DeepFool attack.\n2.3.4 Carlini attack. Carlini recently introduced a powerful attack that generates adversarial exampleswith small perturbation [2]. The attack can be targeted or untargeted for all three metrics L0, L2, and L\u221e. We take the untargeted L2 version as an example here to introduce its main idea.\nWe may formalize the attack as the following optimization problem:\nminimize \u03b4 \u2225\u03b4 \u22252 + c \u00b7 f (x + \u03b4 ) such that x + \u03b4 \u2208 [0, 1]n\nFor a fixed input image x , the attack looks for a perturbation \u03b4 that is small in length(\u2225 \u00b7 \u2225 term in objective) and fools the classifier(the f (\u00b7) term in objective) at the same time. c is a hyperparameter that balances the two. Also, the optimization has to satisfy the box constraints to be a valid image.\nf (\u00b7) is designed in such a way that f (x \u2032) \u2a7d 0 if and only if the classifier classifies x \u2032 incorrectly, which indicates that the attack succeeds. f (x \u2032) has hinge loss form and is defined as\nf (x \u2032) = max(Z (x \u2032)lx \u2212max{Z (x \u2032)i : i , lx },\u2212\u03ba)\nwhere Z (x \u2032) is the pre-softmax classification result vector (called logits) and lx is the ground truth label.\u03ba is a hyper-parameter called confidence. Higher confidence encourages the attack to search for adversarial examples that are stronger in classification confidence. High-confidence attacks often have larger perturbation and better transferability.\nIn this paper, we show that our defense is effective against Carlini\u2019s attack across a wide range of confidence levels (Section 5.3)."}, {"heading": "2.4 Past defense", "text": "Defense on neural networks is much harder compared to attacks. We summarize current approaches to defense and compare them to our work.\n2.4.1 Adversarial training. One idea of defending against adversarial examples is to train a better classifier [29]. An intuitive way to build a robust classifier is to include adversarial information in the training process, which we refer to as adversarial training. For example, one may use a mixture of normal and adversarial examples in the training set to do data augmentation [33, 21], or mix the adversarial objective with the classification objective as regularizer [5]. Though this idea is promising, it is hard to reason about what attacks to train on and how important the adversarial component should be. Currently, these questions are still unanswered.\nMeanwhile, our approach is orthogonal to this branch of work. MagNet is an additional defense framework that does not require modification to the target classifier in any sense. The design and training of MagNet is independent from the target classifier, and is therefore faster and more flexible. MagNet may benefit from a robust target classifier (section 5).\n2.4.2 Defensive distillation. Defensive distillation [24] trains the classifier in a certain way such that it is nearly impossible for gradient based attacks to generate adversarial examples directly on the network. Defensive distillation leverages distillation training techniques [9] and hides the gradient between the pre-softmax layer (logits) and softmax outputs. However, [2] showed that it is easy to bypass the defense by adopting one of the three following strategies: (1) choose a more proper loss function (2) calculate gradient directly from pre-softmax layer instead of from post-softmax layer (3) attack an easy-to-attack network first and then transfer to the distilled network.\nWe argue that in whitebox attack where the attacker knows the parameters of the defense network, it is very difficult to prevent\nadversaries from generating adversarial examples that defeat the defense. Instead, we propose to study defense in the graybox model (Section 3.3), where we introduce a randomization strategy to make it hard for the attacker to generate adversarial examples.\n2.4.3 Detecting adversarial examples. Another idea of defense is to detect adversarial examples with hand-crafted statistical features [6] or separate classification networks [19]. An representative work of this idea is [19]. For each attack generating method considered, it constructed a deep neural network classifier (detector) to tell whether an input is normal or adversarial. The detector was directly trained on both normal and adversarial examples. The detector showed good performance when the training and testing attack examples were generated from the same process and the perturbation was large enough, but it did not generalize well across different attack parameters and attack generation processes.\nMagNet also employs one more more detectors. Contrary to previous work, however, we do not train our detectors on any adversarial examples. Instead, MagNet tries to learn the manifold of normal data and makes decision based on the relationship between a test example and the manifold. Further, MagNet includes a reformer that pushes hard-to-detect adversarial examples (with small perturbation) towards the manifold. Since MagNet is independent of any process for generating adversarial examples, it generalizes well."}, {"heading": "3 PROBLEM DEFINITION", "text": ""}, {"heading": "3.1 Adversarial examples", "text": "We define the following sets:\n\u2022 S: the set of all examples in the sample space (e.g., all images). \u2022 Ct : the set of mutually exclusive classes for the classification task t . E.g., if t is handwritten digit classification, then C = {0, 1, . . . , 9}. \u2022 Nt = {x |x \u2208 S and x occurs naturally with regard to the classification task t }. Each classification task t assumes a data generation process that generates each example x \u2208 S with probability p(x). x occurs naturally if p(x) is non-negligible. Researchers believe that Nt constitute a manifold that is of much lower dimension than S [22]. Since we do not know the data generation process, we approximate Nt by the union of all natural data sets for t , such as CIFAR and MNIST for image recognition.\nDefinition 3.1. A classifier for a task t is a function ft : S\u2192 Ct Definition 3.2. The ground-truth classifier for a task t represents human\u2019s prevailing judgment. We represent it by a function \u0434t : S\u2192 Ct \u222a \u22a5 where \u22a5 represents the judgment that the input x is unlikely from t \u2019s data generation process.\nDefinition 3.3. An adversarial example x for a task t and a classifier ft is one where:\n\u2022 ft (x) , \u0434t (x), and \u2022 x \u2208 S \\ Nt\nThe first condition indicates that the classifier makes a mistake, but this in itself isn\u2019t adequate for making the example adversarial.\nSince no classifier is perfect, there must exist natural examples that a classifier mis-classifies, so an attacker could try to find these examples. But these aren\u2019t interesting adversarial examples for two reasons. First, traditionally they are considered as testing errors as they reflect poor generalization of the classifier. Second, finding these examples by brute force in large collections of natural examples is inefficient and laborious, because it would require humans to collect and label all the natural examples. Therefore, we add the second condition above to limit adversarial examples to only examples generated artificially by the attacker to fool the classifier.2"}, {"heading": "3.2 Defense and evaluation", "text": "Definition 3.4. A defense against adversarial examples for a classifier ft is a function dft : S\u2192 Ct \u222a \u22a5\nThe defense dft extends the classifier ft to make it robust. The defense algorithm in dft may use ft in three different ways:\n\u2022 The defense algorithm does not read data in ft or modify parameters in ft . \u2022 The defense algorithm reads data in ft but does not modify parameters in ft .\n\u2022 The defense algorithm modifies parameters in ft . When evaluating the effectiveness of a defense dft , we cannot merely evaluate whether it classifies each example correctly, i.e., whether its decision agrees with that of the ground truth classifier \u0434t . After all, the goal of the defense is to improve the accuracy of the classifier on adversarial examples rather than on normal examples.\nDefinition 3.5. The defense dft makes a correct decision on an example x if either of the following applies:\n\u2022 x is a normal example, and dft and the ground-truth classifier \u0434t agree on x \u2019s class, i.e., x \u2208 Nt and dft (x) = \u0434t (x). \u2022 x is an adversarial example, and either dft decides that x is adversarial or that dft and the ground-truth classifier \u0434t agree on x \u2019s class, i.e., x \u2208 S \\ Nt and (dft (x) = \u22a5 or dft (x) = \u0434t (x))."}, {"heading": "3.3 Threat model", "text": "We assume that the attacker knows everything about the classifier ft that she wishes to attack, called target classifier, such as its architecture, parameters, training procedure, etc. Depending on whether the attacker knows the defensedft , there are two scenarios:\n\u2022 Blackbox attack: the attacker does not know the parameters of dft . \u2022 Whitebox attack: the attacker knows the parameters of dft . \u2022 Graybox attack: except for the parameters, the attacker\nknows everything aboutdft , such as its architecture, hyperparameters, training set, training epochs. If we train a neural network multiple times while fixing these variables, we often get different model parameters each time due to random initialization. We can view that we get a different network each time. To push this one step further, we can train these different networks at the same time and\n2Kurakin et al. showed that many adversarial images generated artificially remain adversarial after being printed and then captured by a camera [16]. We do not consider these as adversarial examples because although they occurred in physical forms, they were not generated by the natural process for generating normal examples.\nforce them to be sufficiently different by penalizing their resemblance. Section 4.3 for an example.\nWe assume that the defense knows nothing about how the attacker generates adversarial examples."}, {"heading": "4 DESIGN", "text": "MagNet is a framework for defending against adversarial examples (Figure 2). In Section 1.2 we provided two reasons why a classifier mis-classifies an adversarial example: (1) The example is far from the boundary of the manifold of normal examples, but the classifier has no option to reject it; (2) The example is close to the boundary of the manifold, but the classifier generalizes poorly off themanifold in the vicinity of the example. Motivated by these observations, MagNet consists of two components: (1) a detector that rejects examples that are far from the manifold boundary, and (2) a reformer that, given an example x , strives to find an example x \u2032 on or close to the manifold where x \u2032 is as close an approximation to x as possible, and then gives x \u2032 to the target classifier. Figure 3 illustrates the effect of the detector and reformer in a 2-D sample space."}, {"heading": "4.1 Detector", "text": "The detector is a function d : S\u2192 {0, 1} that decides whether the input is adversarial. As an example of this approach, a recent work trained a classifier to distinguish between normal and adversarial examples [19]. However, it has the fundamental limitation that it requires the defender to model the attacker, by either acquiring adversarial examples or knowing the process for generating adversarial examples. Therefore, it unlikely generalizes to other processes for generating adversarial examples. For example, [19] used a basic iterative attack based on the L2 norm. Its results showed that if its detector was trained with slightly perturbed adversarial samples, the detector had high false positive rates because it decided many normal examples as adversarial. On the other hand, if the marker was trained with significantly perturbed examples, it would not be able to detect slightly perturbed adversarial examples.\n4.1.1 Detector based on reconstruction error. To avoid the problem of requiring adversarial examples, MagNet\u2019s detector models only normal examples, and estimates the distance between the test example and boundary of the manifold of normal examples. Our\nimplementation uses an autoencoder as the detector and uses the reconstruction error to approximate the distance between the input and the manifold of normal examples. An autoencoder ae = d \u25e6 e contains two components: an encoder e : S \u2192 H and a decoder d : H\u2192 S, where S is the input space and H is the space of hidden representation of the input. We train the autoencoder to minimize a loss function over the training set, where the loss function commonly is mean squared error:\nL(Xtrain) = 1 |Xtrain | \u2211\nx \u2208Xtrain \u2225x \u2212 ae(x))\u22252\nThe reconstruction error on a test example x is\nE(x) = \u2225x \u2212 ae(x))\u2225p An autoencoder learns the features of the training set so that the encoder can represent the input more compactly, and the decoder tries to reconstruct the input from the compact representation. If an input is drawn from the same data generation process as the training set, then we expect a small reconstruction error. Otherwise, we expect a larger reconstruction error. Hence, we use reconstruction error to estimate how far a test example is from the manifold of normal examples. Since reconstruction error is a continuous value, we must set a threshold tre for deciding whether the input is normal. This threshold is a hyper-parameter of an instance of detector. It should be as low as possible to detect slightly perturbed adversarial examples, but not too low to falsely flag normal examples. We decide tre by a validation set containing normal examples, where we select the highest tre such that the detector\u2019s false positive rate on the validation set is below a threshold tfp. This threshold tfp should be decided catering for the need of the system.\nWhen calculating reconstruction errors, it is important to choose suitable norms. Though reconstruction error based detectors are attack-independent, the norm choosen for detection do influence the sharpness of detection results. Intuitively, p-norm with larger p\nis more sensitive to the maximum difference among all pixels, while smaller p averages its concentration to each pixel. Empirically, we found it sufficient to use two reconstruction error based detectors with L1 and L2 norms respectively to cover both ends.\n4.1.2 Detector based on probability divergence. The detector described in Section 4.1.1 is effective in detecting adversarial examples whose reconstruction errors are large. However, it becomes less effective on adversarial examples whose reconstruction errors are small. To overcome this problem, we take advantage of the target classifier.\nMost neural network classifiers implement the softmax function at the last layer\nsoftmax(l)i = exp(li )\u2211n j=1 exp(lj )\nThe output of softmax is a probability mass function over the classes. The input to softmax is a vector l called logit. Let rank(l , i) be the index of the element that is ranked the ith largest among all the elements in l . Given a normal example whose logit is l , the goal of the attacker is to perturb the example to get a new logit l \u2032 such that rank(l , 1) , rank(l \u2032, 1).\nLet f (x) be the output of the last layer (softmax) of the neural network f on the input x . Let ae(x) be the output of the autoencoder ae that was trained on normal examples. If x is a normal example, since ae(x) is very close to x , the probability mass functions f (x) and f (ae(x)) are similar. By contrast, if x \u2032 is an adversarial example, ae(x \u2032) is significantly different from x \u2032. We observed that even when the reconstruction error on x \u2032 is small, f (x \u2032) and f (ae(x \u2032)) are significantly different. This indicates that the divergence between f (x) and f (ae(x)) reflects how likely x is from the same data generation process as normal examples. We use Jensen-Shannon divergence:\nJSD(P \u2225 Q) = 1 2 DKL(P \u2225 M) + 1 2 DKL(Q \u2225 M)\nwhere\nDKL(P \u2225 Q) = \u2211 i P(i) log P(i) Q(i)\nand\nM = 1 2 (P +Q)\nWhen we implemented this, we encountered a numerical problem. Let l(x) be the logit of the input x . When the largest element in l(x) is much larger than its second largest element, softmax(l(x)) saturates, i.e., the largest element in softmax(l(x)) is very close to 1. When this happens, we observed that softmax(l(ae(x))) also saturates on the same element. This will make the Jensen-Shannon divergence between softmax(l(x)) and softmax(l(ae(x))) very small. To overcome this numerical problem, we add a temperature T > 1 when calculating softmax:\nsoftmax(l)i = exp(li/T )\u2211n j=1 exp(lj/T )"}, {"heading": "4.2 Reformer", "text": "The reformer is a function r : S \u2192 Nt that tries to reconstruct the test input. The output of the reformer is then fed to the target classifier. Note that we do not use the reformer when training the target classifier, but use the reformer only when deploying the target classifier. An ideal reformer:\n(1) should not change the classification results of normal examples. (2) should change adversarial examples adequately so that the reconstructed examples are close to normal examples. In other words, it should reform adversarial examples.\n4.2.1 Noise-based reformer. A naive reformer is a function that adds random noise to the input. If we use Gaussian noise, we get the following reformer\nr (x) = clip(x + \u03f5 \u00b7 y)\nwhere y~N(y; 0, I) is the normal distribution with zero mean and identity covariance matrix, \u03f5 scales the noise, and clip is a function that clips each element of its input vector to be in the valid range.\nA shortcoming of this noise-based reformer is that it fails to take advantage of the distribution of normal examples. Therefore, it changes both normal and adversarial examples randomly and blindly, but our ideal reformer should barely change normal examples but should move adversarial examples towards normal examples.\n4.2.2 Autoencoder-based reformer. We propose to use an autoencoder as the reformer. We train the autoencoder to minimize the reconstruction error on the training set and ensures that it generalizes well on the validation set. Afterwards, when given a normal example, which is from the same data generating process as the training examples, the autoencoder is expected to output a very similar example. But when given an adversarial example, the autoencoder is expected to output an example that approximates the adversarial example and that is closer to the manifold of the normal examples."}, {"heading": "4.3 Use diversity to mitigate graybox attacks", "text": "In blackbox attacks, the attacker knows the parameters of the target classifier but not those of the detector or reformer. Our evaluation showed that MagNet was highly accurate in defending against blackbox attacks (Section 5.2).\nHowever, in whitebox attacks, where the attacker also knows the parameters of the detector and reformer, our evaluation showed that MagNet became less accurate. This is not surprising because we can view that MagNet transforms the target classifier ft into a new classifier f \u2032t . In whitebox attacks, the attacker knows all the parameters of f \u2032t , so he can use the same method that he used on ft to find adversarial examples for f \u2032t . If such adversarial examples did not exist or were negligible, then it would mean that f \u2032t agrees with the ground-truth classifier on almost all the examples off the manifold of normal example. Since there is no evidence that we could find this perfect classifier anytime soon, non-negligibly number of adversarial examples exist for any classifier, including f \u2032t .\nAlthough we cannot eliminate adversarial examples, we could make it difficult for attackers to find them. One approach would be to create a robust classifier such that even if the attacker knows all the parameters of the classifier, it would be difficult for her to find adversarial example [24]. However, [2] showed that it was actually easy to find adversarial examples for the classifier hardened in [24]. We don\u2019t know how to find such robust classifiers, or even if they exist.\nWe take a different approach.We draw inspirations from cryptography, which uses randomness to make it computationally difficult for the attacker to find secrets, such as secret keys. We use the same idea to diversify our defense. In our implementation, we create a large number of autoencoders as candidate detectors and reformers. MagNet randomly picks one of these autoencoders for each defensive device for every session, every test set, or even every test example. Assume that the attacker cannot predict which autoencoder we pick for her adversarial example and that successful adversarial examples trained on one autoencoder succeed on another autoencoders with low probability, then the attacker would have to train her adversarial examples on all the autoencoders in our collection. We can increase the size and diversity of this collection to increase the attacker\u2019s computational complexity. This way, we defend against graybox attack as defined in Section 3.3.\nA key question is how to find large number of diverse autoencoders such that transfer attacks on target classifiers succeed with low probability. Rigorous theoretical analysis of the question is beyond the scope of this paper. Instead, we show a method for constructing these autoencoders and empirical evidence of its effectiveness.\nWe train n autoencoders of the same or different architectures at the same time with random initialization. During training, in the cost function we add a regularizer to penalize the resemblance of these autoencoders\nL(x) = n\u2211 i=1 MSE(x ,aei (x)) \u2212 \u03b1 n\u2211 i=1 MSE(aei (x), 1 n n\u2211 j=1 aej (x)) (1)\nwhere aei is the ith autoencoder, MSE is the mean squared error function, and \u03b1 > 0 is a hyper-parameter that reflects the tradeoff between reconstruction error and autoencoder diversity. When \u03b1 becomes larger, it encourages autoencoder diversity but also increases reconstruction error. We will evaluate this approach in Section 5.4."}, {"heading": "5 IMPLEMENTATION AND EVALUATION", "text": "We evaluated the accuracy and properties of our defense described in section 4 on two standard dataset: MNIST [17] and CIFAR-10 [14]."}, {"heading": "5.1 Setup", "text": "OnMNIST, we selected 55 000 examples for the training set, 5 000 for the validation set, and 1 000 for the test set. We trained a classifier using the setting in [2] and got an accuracy of 99.4%. On CIFAR-10, we selected 45 000 examples for training set, 5 000 for the validation set, and 10 000 for the test set. We used the architecture in [32] and got an accuracy of 90.6%. The accuracy of both these classifiers is near the state of the art on these data sets. Table 1 and Table 2 show\nthe architecture and training parameters of these classifiers. We used a scaled range of [0, 1] instead of [0, 255] for simplicity.\nIn the rest of this section, first we evaluate the robustness of MagNet in blackbox attack, where the attacker does not know the parameters used in MagNet. To understand why MagNet works and when it works well, we analyze the impact of the detector and the reformer, respectively, on the accuracy of MagNet against Carlini\u2019s attack. Finally, we evaluate the use of diversity to mitigate graybox attack, where we use the same classifier architecture but train it to get many classifiers of different parameters.\nWe may divide attacks using adversarial examples into two types. In targeted attack, the attacker chooses a particular class and then creates adversarial examples that the victim classifier mis-classifies into that class. In untargeted attack, the attacker does not care which class the victim classifier outputs as long as it is different from the ground truth. Previous work showed that untargeted attack is easier to succeed, results in smaller perturbations, and transfers better to different models [18, 2]. Since untargeted attack is more difficult to defend against, we evaluate MagNet on untargeted attack to show its worst case performance."}, {"heading": "5.2 Overall performance against blackbox attacks", "text": "We tested MagNet against attacks using fast gradient sign method, iterative gradient sign method, DeepFool, and Carlini\u2019s method. For fast gradient sign method and iterative gradient sign method,\nwe used the implementation of Cleverhans [25]. For DeepFool and Carlini\u2019s, we used their authors\u2019 open source implementations [21, 2].\nIn principle, MagNet works better when we deploy several instances of both reconstruction error based detectors and probability divergence based detectors. Diversified autoencoder architecture also boosts defense performance. In our implementation, we try to simplify the setup by limiting our detector usage and sharing architectures among autoencoders. This is for convenience rather than mandatory. More specifically, for MNIST dataset, we only use two reconstruction error based detectors of two unique architectures. For CIFAR-10 dataset, we share the same structure among all autoencoders. Table 3, Table 4, and Table 5 show the architectures and training hyper-parameters of the autoencoder for MNIST and CIFAR-10. We tune the network to make sure it works, but make no further effort to optimize these settings.\nBelow we use the criteria described and justified in Section 3.2 to evaluate the accuracy of MagNet on normal and adversarial examples.\n5.2.1 MNIST. Compared to CIFAR-10, MNIST is an easier data set for classifiers. We trained a classifier to achieve an accuracy of 99.4%, which is close to the state of the art. We found that we needed\nonly the reconstruction error-based detector and reformer to become highly accurate against adversarial examples generated from MNIST. Therefore, we did not include the probability divergencebased detector inMagNet in this evaluation. Detector II and detector I(see Table 3) used the L2 and L1 norm to measure reconstruction error, respectively. We selected the threshold of reconstruction error such that the false positive rate of the detector on the validation set is at most 0.001, i.e., each detector mistakenly rejects no more than 0.1% examples in the validation set.\nEffect on normal examples. On the test set, without MagNet, the accuracy of the classifier is 99.4%; with MagNet, the accuracy is reduced to 99.1%. This small reduction is negligible.\nEffect on adversarial examples. Table 6a shows that the accuracy of MagNet is above 99% on all the attacks considered except Carlini attack with L0 norm(92.0%). Note that we achieved such high accuracy without training MagNet on any of these attacks.\n5.2.2 CIFAR-10. Compared to MNIST, CIFAR-10 is more challenging for classifiers. We trained a classifier to achieve an accuracy of 90.6%, which is close to the state of the art. For CIFAR-10, MagNet consists of a reformer, a reconstruction error-based detector, and\ntwo probability divergence-based detectors with temperature T of 10 and 40, respectively. We trained the autoencoder as a denoising autoencoder with unit Guassian noise with volume 0.025. Error based detector uses the L1 norm to measure reconstruction error. Again, we set a threshold of false positive rate tfp on the validation set to find the threshold of reconstruction error. We set tfp to 0.005 for the reconstruction error-based detector, and 0.01 for the probability divergence-based detector.\nEffect on normal examples. On the test set, without MagNet, the accuracy of the classifier is 90.6%; with MagNet, the accuracy is reduced to 86.8%. The reduction in accuracy is small.\nEffect on adversarial examples. Table 6b shows that the accuracy of MagNet on 10 different attacks. MagNet is not as accurate on CIFAR-10 as on MNIST, because the target classifier is not as strong on CIFAR-10 and leaves less space forMagNet to take effect. MagNet achieved an accuracy above 75% on all the attacks, and above 90% on more than half attacks. This provides empirical evidence that MagNet is effective and generalizes well to different attacks and different parameters of the same attack."}, {"heading": "5.3 Case study on Carlini attack, why does MagNet work?", "text": "Carlini showed that it was viable to mount transfer attack with higher confidence on MNIST [2]. Among the attacks that we evaluated, Carlini\u2019s attack is the most interesting because it is the most effective on the distillation defense [24] and there is no known effective defense prior to our work. This attack is also interesting because the attacker can change the attack strength by adjusting the confidence level when generating adversarial examples. The higher confidence is, the stronger classification confidence is, and the larger distortion gets. At a confidence level of 40, the attack achieved a success rate of close to 100% on classifier with distillation defense even by conducting transfer attack.\nWe evaluated the impact of different confidence levels in Carlini\u2019s attack on MagNet. For MNIST, we used the same classifier as in Carlini\u2019s paper [2] for generating adversarial examples and as the target classifier in our evaluation. We generated adversarial examples with confidence levels in the range of [0, 40]. For CIFAR-10, [2] did not evaluate the impact of confidence level, but we picked confidence levels in the range of [0, 100]. We use the classifier in Section 5.2 for CIFAR-10 as target classifier. We keep the defense setting in Section 5.2 unchanged for both datasets.\nFigure 4 shows the performance of the detector and reformer on MNIST. Without MagNet, the attack succeeded almost 100%, i.e., the classification accuracy rate is close to 0. With MagNet, the classification accuracy rate is above 99% on adversarial examples generated at all confidence levels tested. This indicates that MagNet blocks Carlini attack completely in blackbox scenario.\nFigure 5 shows the classification accuracy of MagNet on CIFAR10. The attack also gets near 100% success rate for all confidences. A striking revelation in Figure 5 is that the detector and reformer compensate each other to achieve an overall high accuracy at all confidence levels. At high confidence level, the adversarial example is far from the manifold of normal examples, so it likely has a high reconstruction error, and therefore will be rejected by the detector.\nAt low confidence level, the adversarial example is close to the manifold of normal examples, so the reconstructed example by the reformer is more likely to lie on the manifold and therefore to be classified correctly. In other words, as the confidence level of the adversarial example goes up, the reformer becomes less effective but the detector becomes more effective, so there is a dip in the mid range on the curve of the overall classification accuracy as shown in Figure 5. This dip is an window of opportunity for the attacker, as it is where the effectiveness of the reformer begins to wane but the power of detectors have not started. In Figure 5, even though this window of opportunity exists, MagNet still achieves classification accuracy above 80% at all confidence levels.\nSame dip should have appeared in Figure 4, but the classifier and MagNet is strong enough to fill the dip.\nFigure 6 shows the effect of the temperatureT on the accuracy of the probability divergence-based detector. Low temperature makes the detector more accurate on adversarial examples at low confidence level, and high temperature makes the detector more accurate on adversarial examples at high confidence level.\nNote again that we did not train MagNet with Carlini\u2019s attack or any other attacks, so we conjecture that the results likely generalize to other attacks."}, {"heading": "5.4 Defend against graybox attacks", "text": "In graybox attack, except for the parameters, the attacker knows everything else about the defense, such as network architecture, training set, and training procedure. If we assume that (1) the attacker cannot predict the parameters that the defender uses when classifying her adversarial examples; and (2) the attacker cannot feasibly try all parameters when generating her adversarial examples, then we can defend against attackers by diversifying our defensive network.\nWe show an example defense against graybox attack. In this example, we provide diversity by training n different autoencoders for the reformer in MagNet. In our proof-of-concept implementation, we used the same architecture, a convolutional autoencoder with 3 \u00d7 3 \u00d7 8 hidden layers and ReLU activation, to obtain eight autoencoders of different parameters. During training, we used the same hyper-parameters as in Section 5.2 except that we first trained the eight autoencoders independently for 3 epochs using the standard mean squared error loss. Then, we continued training these autoencoders using the loss in Equation 1 for another 10 epochs,\nwhere we chose \u03b1 = 0.2 empirically. At test time, we randomly picked one of the eight autoencoders as the reformer.\nWe chose Carlini\u2019s attack to evaluate this defense. However, Carlini\u2019s attack models only one network and uses the decision of the network to decide how to perturb the candidate adversarial example. But MagNet contains at least two networks, a reformer and one (or more) detector, that make independent decisions. Therefore, the attack as described in [2] cannot handle MagNet. To overcome this obstacle, we removed the detectors from MagNet and kept only the reformer to allow Carlini\u2019s attack to generate adversarial examples. But in this case, it would not fair to test MagNet with adversarial examples at high confidence level, because MagNet relies on the detector to reject adversarial examples at high confidence level (Figure 5). Therefore, we ran Carlini attack to generate adversarial examples at confidence level 0. We chose only CIFAR-10 because Carlini\u2019s attack is more effective on it than on MNIST.\nTable 7 shows the classification accuracy of MagNet on adversarial examples generated by Carlini\u2019s attack. We name each autoencoder A through H. Each column corresponds to an autoencoder that the attack is generated on, and each row corresponds to an autoencoder that is used during testing. The last row, random, means thatMagNet picks a random one from its eight autoencoders. The diagonal shows that MagNet\u2019s classification accuracy drops to mostly 0 when the autoencoder on which Carlini\u2019s attack was trained is also the one that MagNet used during testing. However, when these two autoencoders differ, the classification accuracy jumps to above 90%. The last row shows a more realistic scenario when the attacker chooses a random autoencoder during training and MagNet also chooses a random autoencoder during testing from the eight candidate autoencoders. In this case, MagNet maintains classification accuracy above 80%.\nTable 8 shows the classifier accuracy of these autoencoders on the test set for CIFAR-10. Compared to the accuracy of the target classifier, 90.6%, these autoencoders barely reduce the accuracy of the target classifier.\nThere is much room for improvement on how to diversify MagNet. We could use autoencoders of different architectures, tune autoencoders with different training parameters, increase the amount of autoencoders, and encourage the difference between these autoencoders. We leave these for future work."}, {"heading": "6 DISCUSSION", "text": ""}, {"heading": "6.1 Criteria for evaluating attacks and defenses", "text": "Sincemany AI tasks are subjective, we cannot describe their groundtruth solutions using mathematical formula. Instead, we represent the ground-truth solutions using manually labeled examples in datasets, and we use these datasets to evaluate classifiers. However, we cannot use these datasets to evaluate the robustness of classifiers against adversarial examples. For this task, we must first decide the criteria for distinguishing between adversarial examples and mis-classified normal examples.\nWe argue that the criteria cannot depend on the intention of the provider of the test examples. Since our goal is to improve the accuracy of the classifier, we often do not care or know the intention of the tester. It is reasonable to assume that benign users do not provide adversarial examples. Therefore, we must exclude all examples in existing datasets from adversarial examples.\nTherefore, attackers must find adversarial examples by creating new datasets. There are two ways: (1) by sampling from the same data generating process for the task, and (2) by perturbing examples in existing datasets. The first approach is laborious, as the attacker must manually collect examples and label their ground-truth. Since this approach is costly and scales poorly, we do not consider it further. By contrast, the second approach allows the attacker to create mis-classified examples automatically based on the assumption that slightly perturbed examples do not change human judgement. Therefore, we consider only examples created by this approach as adversarial examples.\nGiven this definition of adversarial examples, how do we evaluate the robustness of a classifier or a defense against adversarial examples? It would be unfair if the classifier were trained with the knowledge of a particular process for generating adversarial examples, and then tested on examples generated from the same process.\nWe could require that the designer train the classifier without using any knowledge about the process for generating adversarial examples on which the classifier will be tested. But this is difficult to enforce or verify, as the designer may inadvertently or implicitly incorporate such knowledge into the architecture or training procedure of the classifier.\nA more reliable approach is to test the classifier or defense using unbiased samples from A, the set of all the examples that are close to any example in the available datasets. To define A, we need the dataset of normal examples, a distance measure, and a threshold \u03b4 for defining closeness. Given these, sampling from A is straightforward as follows:\n(1) Randomly select a data set D and then randomly select an example x from D. (2) Perturb x according to some random probability distribution to get x \u2032 subject to the constraint that the distance between x and x \u2032 is less than \u03b4 .\nSamples from this process are independent of any particular process for generating adversarial examples, so we believe that they are fairer for comparing the robustness of classifiers or defenses against adversarial examples. However, these samples have two shortcomings. First, they exclude adversarial examples whose distance from normal examples are above the threshold \u03b4 . Second, since this sampling process does not intentionally select difficult examples, most samples will be classified correctly by competent classifiers. Therefore, to compare the robustness of different classifiers or defenses, we would need a lot of samples to cause the classifiers to make enough mistakes to make the comparison statistically significant."}, {"heading": "6.2 Limitations", "text": "The effectiveness of MagNet against adversarial examples depends on the following assumptions:\n\u2022 There exist detector functions that measure the distance between its input and the manifold of normal examples. \u2022 There exist reformer functions that outputs an example x \u2032 that is perceptibly close to the input x , and x \u2032 is closer to the manifold than x .\nWe chose autoencoder for both the reformer and the two types of detectors in MagNet. MagNet\u2019s high accuracy against the stateof-the-art attacks provides empirical evidence that our assumptions are likely correct. However, before we find stronger justification or proof, we cannot deny the possibility that our good results are because the state-of-the-art attacks are not powerful enough. We hope that our results would motivate further work on finding more powerful attacks or more powerful detectors and reformers."}, {"heading": "7 CONCLUSION", "text": "We proposed MagNet, a framework for defending against adversarial perturbation of examples for neural networks. MagNet handles untrusted input in a two-fold fashion. It detects adversarial examples with large perturbation using dedicated detector networks, and pushes examples with small perturbation towards the manifold of normal examples. These two methods work jointly to enhance the classification accuracy. Moreover, by using autoencoder as detector networks, MagNet learns to detect adversarial examples without requiring either adversarial examples or the knowledge of the process for generating them, leading to better generalization ability. Experiments show that MagNet defended against the state-of-art attacks effectively. In case that the attacker knows the training examples of MagNet, we described a new graybox threat model and used diversity to defend against this attack effectively.\nWe advocate that defense on adversarial examples should be attack-independent. Instead of finding properties of adversarial examples from specific generation processes, a defense would be more transferable by finding intrinsic common properties among all adversarial generation processes. Our defense is a first step towards this end and demonstrated good performance empirically."}, {"heading": "ACKNOWLEDGMENTS", "text": "We wish to thank professor Xuming He from ShanghaiTech University for his valuable feedback."}], "references": [{"title": "End to end learning for self-driving cars", "author": ["Mariusz Bojarski", "Davide Del Testa", "Daniel Dworakowski", "Bernhard Firner", "Beat Flepp", "Prasoon Goyal", "Lawrence D Jackel", "Mathew Monfort", "Urs Muller", "Jiakai Zhang"], "venue": "arXiv preprint arXiv:1604.07316,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2016}, {"title": "Towards evaluating the robustness of neural networks", "author": ["Nicholas Carlini", "David Wagner"], "venue": "In IEEE Symposium on Security and Privacy,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2017}, {"title": "Learning transferable policies for monocular reactive mav control", "author": ["Shreyansh Daftry", "J Andrew Bagnell", "Martial Hebert"], "venue": "arXiv preprint arXiv:1608.00627,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2016}, {"title": "Deep visual foresight for planning robot motion", "author": ["Chelsea Finn", "Sergey Levine"], "venue": "arXiv preprint arXiv:1610.00696,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2016}, {"title": "Explaining and harnessing adversarial examples", "author": ["Ian J. Goodfellow", "Jonathon Shlens", "Christian Szegedy"], "venue": "In International Conference on Learning Representations (ICLR),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "On the (statistical) detection of adversarial examples", "author": ["Kathrin Grosse", "PraveenManoharan", "Nicolas Papernot", "Michael Backes", "Patrick McDaniel"], "venue": "arXiv preprint arXiv:1702.06280,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2017}, {"title": "Adversarial perturbations against deep neural networks for malware classification", "author": ["Kathrin Grosse", "Nicolas Papernot", "PraveenManoharan", "Michael Backes", "Patrick McDaniel"], "venue": "arXiv preprint arXiv:1606.04435,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2016}, {"title": "Deep residual learning for image recognition", "author": ["Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun"], "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2016}, {"title": "Distilling the knowledge in a neural network", "author": ["Geoffrey Hinton", "Oriol Vinyals", "Jeff Dean"], "venue": "arXiv preprint arXiv:1503.02531,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Deep neural networks for acoustic modeling in speech recognition: the shared views of four research groups", "author": ["Geoffrey Hinton", "Li Deng", "Dong Yu", "George E Dahl", "Abdelrahman Mohamed", "Navdeep Jaitly", "Andrew Senior", "Vincent Vanhoucke", "Patrick Nguyen", "Tara N Sainath"], "venue": "IEEE Signal Processing Magazine,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Poster: deep learning for zero-day flash malware detection", "author": ["Wookhyun Jung", "Sangwon Kim", "Sangyong Choi"], "venue": "IEEE Symposium on Security and Privacy,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2015}, {"title": "Uncertainty-aware reinforcement learning for collision avoidance", "author": ["Gregory Kahn", "Adam Villaflor", "Vitchyr Pong", "Pieter Abbeel", "Sergey Levine"], "venue": "arXiv preprint arXiv:1702.01182,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2017}, {"title": "Adversarial examples for generative models", "author": ["Jernej Kos", "Ian Fischer", "Dawn Song"], "venue": "arXiv preprint arXiv:1702.06832,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2017}, {"title": "Learning multiple layers of features from tiny", "author": ["Alex Krizhevsky", "Geoffrey Hinton"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "Ask me anything: dynamic memory networks for natural language processing", "author": ["Ankit Kumar", "Ozan Irsoy", "Peter Ondruska", "Mohit Iyyer", "James Bradbury", "Ishaan Gulrajani", "Victor Zhong", "Romain Paulus", "Richard Socher"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2016}, {"title": "Adversarial examples in the physical world", "author": ["Alexey Kurakin", "Ian J. Goodfellow", "Samy Bengio"], "venue": "CoRR, abs/1607.02533,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2016}, {"title": "The mnist database of handwritten digits", "author": ["Yann LeCun", "Corinna Cortes", "Christopher JC Burges"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1998}, {"title": "Delving into transferable adversarial examples and black-box attacks", "author": ["Yanpei Liu", "Xinyun Chen", "Chang Liu", "Dawn Song"], "venue": "In International Conference on Learning Representations (ICLR),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2017}, {"title": "On detecting adversarial perturbations", "author": ["Jan Hendrik Metzen", "Tim Genewein", "Volker Fischer", "Bastian Bischoff"], "venue": "In International Conference on Learning Representations (ICLR),", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2017}, {"title": "Universal adversarial perturbations", "author": ["Seyed-Mohsen Moosavi-Dezfooli", "Alhussein Fawzi", "Omar Fawzi", "Pascal Frossard"], "venue": "arXiv preprint arXiv:1610.08401,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2016}, {"title": "Deepfool: a simple and accurate method to fool deep neural networks", "author": ["Seyed-Mohsen Moosavi-Dezfooli", "Alhussein Fawzi", "Pascal Frossard"], "venue": "CoRR, abs/1511.04599,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2015}, {"title": "Sample complexity of testing the manifold hypothesis", "author": ["H. Narayanan", "S. Mitter"], "venue": "In NIPS,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2010}, {"title": "The limitations of deep learning in adversarial settings", "author": ["N. Papernot", "P. McDaniel", "S. Jha", "M. Fredrikson", "Z.B. Celik", "A. Swami"], "venue": "In IEEE European Symposium on Security and Privacy (EuroSP),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2016}, {"title": "Distillation as a defense to adversarial perturbations against deep neural networks", "author": ["N. Papernot", "P. McDaniel", "X. Wu", "S. Jha", "A. Swami"], "venue": "In IEEE Symposium on Security and Privacy,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2016}, {"title": "Cleverhans v1.0.0: an adversarial machine learning library", "author": ["Nicolas Papernot", "Ian Goodfellow", "Ryan Sheatsley", "Reuben Feinman", "Patrick McDaniel"], "venue": "arXiv preprint arXiv:1610.00768,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2016}, {"title": "Crafting adversarial input sequences for recurrent neural networks", "author": ["Nicolas Papernot", "Patrick D. McDaniel", "Ananthram Swami", "Richard E. Harang"], "venue": "CoRR, abs/1604.08275,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2016}, {"title": "Practical blackbox attacks against machine learning", "author": ["Nicolas Papernot", "Patrick McDaniel", "Ian Goodfellow", "Somesh Jha", "Z Berkay Celik", "Ananthram Swami"], "venue": "In Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2017}, {"title": "Malware classification with recurrent networks. InAcoustics", "author": ["Razvan Pascanu", "Jack W Stokes", "Hermineh Sanossian", "Mady Marinescu", "Anil Thomas"], "venue": "Speech and Signal Processing  (ICASSP),", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2015}, {"title": "Understanding adversarial training: increasing local stability of neural nets through robust optimization", "author": ["Uri Shaham", "Yutaro Yamada", "Sahand Negahban"], "venue": "arXiv preprint arXiv:1511.05432,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2015}, {"title": "Deep learning in medical image analysis", "author": ["Dinggang Shen", "GuorongWu", "Heung-Il Suk"], "venue": "Annual Review of Biomedical Engineering,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2017}, {"title": "Deep learning for mortgage risk, 2016", "author": ["Justin Sirignano", "Apaar Sadhwani", "Kay Giesecke"], "venue": null, "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2016}, {"title": "Striving for simplicity: the all convolutional net", "author": ["Jost Tobias Springenberg", "Alexey Dosovitskiy", "Thomas Brox", "Martin Riedmiller"], "venue": "arXiv preprint arXiv:1412.6806,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2014}, {"title": "Intriguing properties of neural networks", "author": ["Christian Szegedy", "Wojciech Zaremba", "Ilya Sutskever", "Joan Bruna", "Dumitru Erhan", "Ian J. Goodfellow", "Rob Fergus"], "venue": "In International Conference on Learning Representations (ICLR),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2014}, {"title": "Adversarial examples for semantic segmentation and object detection", "author": ["Cihang Xie", "Jianyu Wang", "Zhishuai Zhang", "Yuyin Zhou", "Lingxi Xie", "Alan Yuille"], "venue": "arXiv preprint arXiv:1703.08603,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2017}], "referenceMentions": [{"referenceID": 7, "context": "In recent years, deep learning demonstrated impressive performance on many tasks, such as image classification [8] and natural language processing [15].", "startOffset": 111, "endOffset": 114}, {"referenceID": 14, "context": "In recent years, deep learning demonstrated impressive performance on many tasks, such as image classification [8] and natural language processing [15].", "startOffset": 147, "endOffset": 151}, {"referenceID": 32, "context": "However, recent research showed that an attacker could generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 105, "endOffset": 120}, {"referenceID": 4, "context": "However, recent research showed that an attacker could generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 105, "endOffset": 120}, {"referenceID": 22, "context": "However, recent research showed that an attacker could generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 105, "endOffset": 120}, {"referenceID": 17, "context": "However, recent research showed that an attacker could generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 105, "endOffset": 120}, {"referenceID": 32, "context": "We can divide defenses against adversarial examples into three approaches: (1) Training the target classifier with adversarial examples, called adversarial training [33, 5]; (2) Training a classifier to distinguish between normal and adversarial examples [19]; and (3) Making target classifiers hard to attack by blocking gradient pathway, e.", "startOffset": 165, "endOffset": 172}, {"referenceID": 4, "context": "We can divide defenses against adversarial examples into three approaches: (1) Training the target classifier with adversarial examples, called adversarial training [33, 5]; (2) Training a classifier to distinguish between normal and adversarial examples [19]; and (3) Making target classifiers hard to attack by blocking gradient pathway, e.", "startOffset": 165, "endOffset": 172}, {"referenceID": 18, "context": "We can divide defenses against adversarial examples into three approaches: (1) Training the target classifier with adversarial examples, called adversarial training [33, 5]; (2) Training a classifier to distinguish between normal and adversarial examples [19]; and (3) Making target classifiers hard to attack by blocking gradient pathway, e.", "startOffset": 255, "endOffset": 259}, {"referenceID": 23, "context": ", defensive distillation [24].", "startOffset": 25, "endOffset": 29}, {"referenceID": 1, "context": "showed that defensive distillation did not significantly increase the robustness of neural networks [2].", "startOffset": 100, "endOffset": 103}, {"referenceID": 21, "context": "Researchers speculate that for many AI tasks, their relevant data lie on a manifold that is of much lower dimension than the full sample space [22].", "startOffset": 143, "endOffset": 147}, {"referenceID": 24, "context": "In this setting, we evaluated MagNet on popular attacks [25, 21, 2].", "startOffset": 56, "endOffset": 67}, {"referenceID": 20, "context": "In this setting, we evaluated MagNet on popular attacks [25, 21, 2].", "startOffset": 56, "endOffset": 67}, {"referenceID": 1, "context": "In this setting, we evaluated MagNet on popular attacks [25, 21, 2].", "startOffset": 56, "endOffset": 67}, {"referenceID": 0, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 60, "endOffset": 69}, {"referenceID": 2, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 60, "endOffset": 69}, {"referenceID": 3, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 60, "endOffset": 69}, {"referenceID": 30, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 89, "endOffset": 93}, {"referenceID": 29, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 114, "endOffset": 118}, {"referenceID": 10, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 141, "endOffset": 149}, {"referenceID": 27, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 141, "endOffset": 149}, {"referenceID": 9, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 182, "endOffset": 190}, {"referenceID": 11, "context": "They are used in autonomous control for robots and vehicles [1, 3, 4], financial systems [31], medical treatments [30], information security [11, 28], and human-computer interaction [10, 12].", "startOffset": 182, "endOffset": 190}, {"referenceID": 1, "context": "Recent work has demonstrated the feasibility of attacking such systems with carefully crafted input [2, 27, 7] for real-world systems.", "startOffset": 100, "endOffset": 110}, {"referenceID": 26, "context": "Recent work has demonstrated the feasibility of attacking such systems with carefully crafted input [2, 27, 7] for real-world systems.", "startOffset": 100, "endOffset": 110}, {"referenceID": 6, "context": "Recent work has demonstrated the feasibility of attacking such systems with carefully crafted input [2, 27, 7] for real-world systems.", "startOffset": 100, "endOffset": 110}, {"referenceID": 32, "context": "More specifically, researchers showed that it was possible to generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 112, "endOffset": 127}, {"referenceID": 4, "context": "More specifically, researchers showed that it was possible to generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 112, "endOffset": 127}, {"referenceID": 22, "context": "More specifically, researchers showed that it was possible to generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 112, "endOffset": 127}, {"referenceID": 17, "context": "More specifically, researchers showed that it was possible to generate adversarial examples to fool classifiers [33, 5, 23, 18].", "startOffset": 112, "endOffset": 127}, {"referenceID": 1, "context": "Since it is hard to model human perception, researchers proposed three popular metrics to approximate human\u2019s perception of visual difference, namely L0, L2, and L\u221e [2].", "startOffset": 165, "endOffset": 168}, {"referenceID": 32, "context": "Since the discovery of adversarial examples for neural networks in [33], researchers found adversarial examples on various network architectures including feedforward convolutional classification networks [2], generative networks [13], and recurrent networks [26].", "startOffset": 67, "endOffset": 71}, {"referenceID": 1, "context": "Since the discovery of adversarial examples for neural networks in [33], researchers found adversarial examples on various network architectures including feedforward convolutional classification networks [2], generative networks [13], and recurrent networks [26].", "startOffset": 205, "endOffset": 208}, {"referenceID": 12, "context": "Since the discovery of adversarial examples for neural networks in [33], researchers found adversarial examples on various network architectures including feedforward convolutional classification networks [2], generative networks [13], and recurrent networks [26].", "startOffset": 230, "endOffset": 234}, {"referenceID": 25, "context": "Since the discovery of adversarial examples for neural networks in [33], researchers found adversarial examples on various network architectures including feedforward convolutional classification networks [2], generative networks [13], and recurrent networks [26].", "startOffset": 259, "endOffset": 263}, {"referenceID": 20, "context": ", classification[21] and semantic segmentation [34].", "startOffset": 16, "endOffset": 20}, {"referenceID": 33, "context": ", classification[21] and semantic segmentation [34].", "startOffset": 47, "endOffset": 51}, {"referenceID": 1, "context": "Researchers developed several methods for generating adversarial examples, most of which leveraged gradient based optimization from normal examples [2, 33, 5].", "startOffset": 148, "endOffset": 158}, {"referenceID": 32, "context": "Researchers developed several methods for generating adversarial examples, most of which leveraged gradient based optimization from normal examples [2, 33, 5].", "startOffset": 148, "endOffset": 158}, {"referenceID": 4, "context": "Researchers developed several methods for generating adversarial examples, most of which leveraged gradient based optimization from normal examples [2, 33, 5].", "startOffset": 148, "endOffset": 158}, {"referenceID": 19, "context": "showed that it was even possible to find one effective universal adversarial perturbation that, when applied, turned many images adversarial [20].", "startOffset": 141, "endOffset": 145}, {"referenceID": 4, "context": "Given a normal image x , fast gradient sign method [5] looks for a similar image x \u2032 in the L\u221e neighborhood of x that fools the classifier.", "startOffset": 51, "endOffset": 54}, {"referenceID": 15, "context": "[16] proposed to improve FGSM by using a finer iterative optimization strategy.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "DeepFool is also an iterative attack but formalizes the problem in a different way [21].", "startOffset": 83, "endOffset": 87}, {"referenceID": 1, "context": "Carlini recently introduced a powerful attack that generates adversarial exampleswith small perturbation [2].", "startOffset": 105, "endOffset": 108}, {"referenceID": 0, "context": "such that x + \u03b4 \u2208 [0, 1]n", "startOffset": 18, "endOffset": 24}, {"referenceID": 28, "context": "One idea of defending against adversarial examples is to train a better classifier [29].", "startOffset": 83, "endOffset": 87}, {"referenceID": 32, "context": "For example, one may use a mixture of normal and adversarial examples in the training set to do data augmentation [33, 21], or mix the adversarial objective with the classification objective as regularizer [5].", "startOffset": 114, "endOffset": 122}, {"referenceID": 20, "context": "For example, one may use a mixture of normal and adversarial examples in the training set to do data augmentation [33, 21], or mix the adversarial objective with the classification objective as regularizer [5].", "startOffset": 114, "endOffset": 122}, {"referenceID": 4, "context": "For example, one may use a mixture of normal and adversarial examples in the training set to do data augmentation [33, 21], or mix the adversarial objective with the classification objective as regularizer [5].", "startOffset": 206, "endOffset": 209}, {"referenceID": 23, "context": "Defensive distillation [24] trains the classifier in a certain way such that it is nearly impossible for gradient based attacks to generate adversarial examples directly on the network.", "startOffset": 23, "endOffset": 27}, {"referenceID": 8, "context": "Defensive distillation leverages distillation training techniques [9] and hides the gradient between the pre-softmax layer (logits) and softmax outputs.", "startOffset": 66, "endOffset": 69}, {"referenceID": 1, "context": "However, [2] showed that it is easy to bypass the defense by adopting one of the three following strategies: (1) choose a more proper loss function (2) calculate gradient directly from pre-softmax layer instead of from post-softmax layer (3) attack an easy-to-attack network first and then transfer to the distilled network.", "startOffset": 9, "endOffset": 12}, {"referenceID": 5, "context": "Another idea of defense is to detect adversarial examples with hand-crafted statistical features [6] or separate classification networks [19].", "startOffset": 97, "endOffset": 100}, {"referenceID": 18, "context": "Another idea of defense is to detect adversarial examples with hand-crafted statistical features [6] or separate classification networks [19].", "startOffset": 137, "endOffset": 141}, {"referenceID": 18, "context": "An representative work of this idea is [19].", "startOffset": 39, "endOffset": 43}, {"referenceID": 21, "context": "Researchers believe that Nt constitute a manifold that is of much lower dimension than S [22].", "startOffset": 89, "endOffset": 93}, {"referenceID": 15, "context": "showed that many adversarial images generated artificially remain adversarial after being printed and then captured by a camera [16].", "startOffset": 128, "endOffset": 132}, {"referenceID": 18, "context": "As an example of this approach, a recent work trained a classifier to distinguish between normal and adversarial examples [19].", "startOffset": 122, "endOffset": 126}, {"referenceID": 18, "context": "For example, [19] used a basic iterative attack based on the L2 norm.", "startOffset": 13, "endOffset": 17}, {"referenceID": 23, "context": "One approach would be to create a robust classifier such that even if the attacker knows all the parameters of the classifier, it would be difficult for her to find adversarial example [24].", "startOffset": 185, "endOffset": 189}, {"referenceID": 1, "context": "However, [2] showed that it was actually easy to find adversarial examples for the classifier hardened in [24].", "startOffset": 9, "endOffset": 12}, {"referenceID": 23, "context": "However, [2] showed that it was actually easy to find adversarial examples for the classifier hardened in [24].", "startOffset": 106, "endOffset": 110}, {"referenceID": 16, "context": "We evaluated the accuracy and properties of our defense described in section 4 on two standard dataset: MNIST [17] and CIFAR-10 [14].", "startOffset": 110, "endOffset": 114}, {"referenceID": 13, "context": "We evaluated the accuracy and properties of our defense described in section 4 on two standard dataset: MNIST [17] and CIFAR-10 [14].", "startOffset": 128, "endOffset": 132}, {"referenceID": 1, "context": "We trained a classifier using the setting in [2] and got an accuracy of 99.", "startOffset": 45, "endOffset": 48}, {"referenceID": 31, "context": "We used the architecture in [32] and got an accuracy of 90.", "startOffset": 28, "endOffset": 32}, {"referenceID": 0, "context": "We used a scaled range of [0, 1] instead of [0, 255] for simplicity.", "startOffset": 26, "endOffset": 32}, {"referenceID": 17, "context": "Previous work showed that untargeted attack is easier to succeed, results in smaller perturbations, and transfers better to different models [18, 2].", "startOffset": 141, "endOffset": 148}, {"referenceID": 1, "context": "Previous work showed that untargeted attack is easier to succeed, results in smaller perturbations, and transfers better to different models [18, 2].", "startOffset": 141, "endOffset": 148}, {"referenceID": 24, "context": "we used the implementation of Cleverhans [25].", "startOffset": 41, "endOffset": 45}, {"referenceID": 20, "context": "For DeepFool and Carlini\u2019s, we used their authors\u2019 open source implementations [21, 2].", "startOffset": 79, "endOffset": 86}, {"referenceID": 1, "context": "For DeepFool and Carlini\u2019s, we used their authors\u2019 open source implementations [21, 2].", "startOffset": 79, "endOffset": 86}, {"referenceID": 1, "context": "Carlini showed that it was viable to mount transfer attack with higher confidence on MNIST [2].", "startOffset": 91, "endOffset": 94}, {"referenceID": 23, "context": "Among the attacks that we evaluated, Carlini\u2019s attack is the most interesting because it is the most effective on the distillation defense [24] and there is no known effective defense prior to our work.", "startOffset": 139, "endOffset": 143}, {"referenceID": 1, "context": "For MNIST, we used the same classifier as in Carlini\u2019s paper [2] for generating adversarial examples and as the target classifier in our evaluation.", "startOffset": 61, "endOffset": 64}, {"referenceID": 1, "context": "For CIFAR-10, [2] did not evaluate the impact of confidence level, but we picked confidence levels in the range of [0, 100].", "startOffset": 14, "endOffset": 17}, {"referenceID": 1, "context": "Therefore, the attack as described in [2] cannot handle MagNet.", "startOffset": 38, "endOffset": 41}], "year": 2017, "abstractText": "Deep learning has shown promising results on hard perceptual problems in recent years. However, deep learning systems are found to be vulnerable to small adversarial perturbations that are nearly imperceptible to human. Such specially crafted perturbations cause deep learning systems to output incorrect decisions, with potentially disastrous consequences. These vulnerabilities hinder the deployment of deep learning systems where safety or security is important. Attempts to secure deep learning systems either target specific attacks or have been shown to be ineffective. In this paper, we propose MagNet, a framework for defending neural network classifiers against adversarial examples. MagNet does not modify the protected classifier or know the process for generating adversarial examples. MagNet includes one or more separate detector networks and a reformer network. Different from previous work, MagNet learns to differentiate between normal and adversarial examples by approximating the manifold of normal examples. Since it does not rely on any process for generating adversarial examples, it has substantial generalization power. Moreover, MagNet reconstructs adversarial examples by moving them towards the manifold, which is effective for helping classify adversarial examples with small perturbation correctly. We discuss the intrinsic difficulty in defending against whitebox attack and propose a mechanism to defend against graybox attack. Inspired by the use of randomness in cryptography, we propose to use diversity to strengthen MagNet. We show empirically that MagNet is effective against most advanced state-of-the-art attacks in blackbox and graybox scenarios while keeping false positive rate on normal examples very low.", "creator": "LaTeX with hyperref package"}}}