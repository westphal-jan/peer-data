{"id": "1706.03200", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Jun-2017", "title": "Critical Hyper-Parameters: No Random, No Cry", "abstract": "The selection of hyper-parameters is critical in Deep Learning. Because of the long training time of complex models and the availability of compute resources in the cloud, \"one-shot\" optimization schemes - where the sets of hyper-parameters are selected in advance (e.g. on a grid or in a random manner) and the training is executed in parallel - are commonly used. It is known that grid search is sub-optimal, especially when only a few critical parameters matter, and suggest to use random search instead. Yet, random search can be \"unlucky\" and produce sets of values that leave some part of the domain unexplored. Quasi-random methods, such as Low Discrepancy Sequences (LDS) avoid these issues. We show that such methods have theoretical properties that make them appealing for performing hyperparameter search, and demonstrate that, when applied to the selection of hyperparameters of complex Deep Learning models (such as state-of-the-art LSTM language models and image classification models), they yield suitable hyperparameters values with much fewer runs than random search. We propose a particularly simple LDS method which can be used as a drop-in replacement for grid or random search in any Deep Learning pipeline, both as a fully one-shot hyperparameter search or as an initializer in iterative batch optimization.", "histories": [["v1", "Sat, 10 Jun 2017 08:02:34 GMT  (4508kb,D)", "http://arxiv.org/abs/1706.03200v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["olivier bousquet", "sylvain gelly", "karol kurach", "olivier teytaud", "damien vincent"], "accepted": false, "id": "1706.03200"}, "pdf": {"name": "1706.03200.pdf", "metadata": {"source": "CRF", "title": "Critical Hyper-Parameters: No Random, No Cry", "authors": ["Olivier Bousquet", "Sylvain Gelly", "Karol Kurach", "Olivier Teytaud", "Damien Vincent"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Hyperparameter (HP) optimization can be interpreted as the black-box search of an x, such that, for a given function f : S \u2282 Rd \u2192 R, the value f(x) is small, where the function f can be stochastic. This captures the situation where one is looking for the best setting of the hyper-parameters of a (possibly randomized) machine learning algorithm by trying several values of these parameters and picking the value yielding the best validation error. Non-linear optimization in general is a well-developed area [18]. However, hyper-parameter optimization in the context of Deep Learning has several specific features that need to be taken into account to develop appropriate optimization techniques: function evaluation is very expensive, computations can be parallelized, derivatives are not easily accessible, and there is a discrepancy between training, validation and test errors. Also, there can be very deep and narrow optima. Published methods for hyper-parameters search include evolution strategies [2], Gaussian processes [10, 23], pattern search [4], grid sampling and random sampling [1]. In this work we explore one-shot optimization, hence focusing on non-iterative methods like random search1. This type of optimization is popular - extremely scalable and easy to implement. Among one-shot optimization methods, grid sampling is sub-optimal if only a few critical parameters matter because the same values of these parameters will be explored many times. Another very popular approach, random sampling, can suffer from unlucky draws, and leave some part of the space unexplored. To address those issues, we investigate Low Discrepancy Sequences (LDS) to see if they can improve upon currently used methods, an approach also suggested by [1] as future work (although they already proposed the use of LDS and did preliminary experiments on artificial\n1Note that most of the improvements on one-shot optimization can be applied to batch iterative methods as well, as shown by Section E.7.\nar X\niv :1\n70 6.\n03 20\n0v 1\n[ cs\n.L G\n] 1\n0 Ju\nn 20\n17\nobjective functions, they did not run experiments on HP tuning for Deep Learning as we do here). LDS is a rich family of different methods to produce sequences well spread in [0, 1]d. Based on a theoretical analysis and empirical evaluation, we suggest Randomly Scrambled Hammersley with random shift as a robust one-shot optimization method for HP search in Deep Learning."}, {"heading": "2 One-shot optimization: formalization & algorithms", "text": "In this work, we focus on so-called one-shot optimization methods where one chooses a priori the points at which the function will be evaluated and does not alter this choice based on observed values of the function. This reflects the parallel tuning of HPs where one runs the training of a learning algorithm with several choices of HPs and simply picks the best choice (based on the validation error). We do not consider the possibility of saving computational resources by stopping some runs early based on an estimate of their final performance, as is done by methods such as Sequential Halving [11] and Hyperband [14] or validation curves modeling as in [5]. However, the techniques presented here can easily be combined with such stopping methods."}, {"heading": "2.1 Formalization", "text": "We consider a function f defined on [0, 1]d and are interested in finding its infimum. To simplify the analysis, we will assume that the infimum of f is reached at some point x\u2217 \u2208 [0, 1]d. A one-shot optimization algorithm is a (possibly randomized) algorithm that produces a sequence x1, . . . , xn of elements of [0, 1]d and, given any function f , returns the value mini f(xi). Since the choice of the sequence is independent of the function f and its values, we can simply see such an algorithm as producing a distribution P over sets {x1, . . . , xn}. The performance of such an algorithm is then measured via the optimization error: |mini f(xi)\u2212 infx\u2208[0,1]d f(x)| = |mini f(xi)\u2212 f(x\u2217)| . This is a random variable and we are thus interested in its quantiles. We would like algorithms that make this quantity small with high probability. Since we have to choose the sequence before having any information about the function, it is natural to try to have a good coverage of the domain. In particular, by ensuring that any point of the domain has a close neighbor in the sequence, we can get a control on the optimization error (provided we have some knowledge of how the function behaves with respect to the distance between points). In order to formalize this, we first introduce several notions of how \u201cspread\u201d a particular sequence is.\nDefinition 1 (Volume Dispersion) The volume dispersion of S = {x1, . . . , xn} \u2282 [0, 1]d with respect to a familyR of subsets of [0, 1]d is vdisp(S,R) := sup{\u00b5(R) : R \u2208 R, R \u2229 S = \u2205} .\nIn particular, we will be interested in the case where the familyR is the set B of all balls B(x, ), in which case instead of considering the volume we can consider directly the radius of the ball.\nDefinition 2 (Dispersion) The dispersion of a set S = {x1, . . . , xn} \u2282 [0, 1]d is defined as disp(S) := sup{ : x \u2208 [0, 1]d, B(x, ) \u2229 S = \u2205} .\nSince we are interested in sequences that are stochastic, we introduce a more general notion of dispersion. Imagine that the sets S are generated by sampling from a distribution P .\nDefinition 3 (Stochastic Dispersion) The stochastic dispersion of a distribution P over sets S = {x1, . . . , xn} \u2282 [0, 1]d at confidence \u03b4 \u2208 [0, 1] is defined as\nsdisp(P, \u03b4) := sup x\u2208[0,1]d sup{ : P (min i \u2016xi \u2212 x\u2016 > ) \u2265 1\u2212 \u03b4}, (1)\nsdisp\u2032(P, \u03b4) := sup x\u2208[0,1]d sup{ : P (min i \u2016xi \u2212 x\u2016\u2032 > ) \u2265 1\u2212 \u03b4} . (2)\nwhere \u2016.\u2016\u2032 is the torus distance in [0, 1]d. We present a simple result that connects the (stochastic) dispersion to the optimization error when the function is well behaved around its infimum.\nLemma 1 Let \u03c9(f, x\u2217\u03b4) be the modulus of continuity of f around x\u2217, \u03c9(f, x\u2217, \u03b4) = supy:\u2016x\u2217\u2212y\u2016\u2264\u03b4 |f(x\u2217) \u2212 f(y)|. Then for any fixed sequence S, |minx\u2208S f(x) \u2212 f(x\u2217)| \u2264 \u03c9(f, x\u2217, disp(S)) , and for any distribution P over sequences, with probability at least 1\u2212 \u03b4 (when S is sampled according to P ), |minx\u2208S f(x)\u2212 f(x\u2217)| \u2264 \u03c9(f, x\u2217, sdisp(P, \u03b4)) .\nIn particular, if the function is known to be Lipschitz then its modulus of continuity is a linear function \u03c9(f, x\u2217, \u03b4) \u2264 L(f)\u03b4. In view of the above lemma, the (stochastic) dispersion gives a direct control on the optimization error (provided one has some knowledge about the behavior of the function). We will thus present our results in terms of the stochastic dispersion for various algorithms."}, {"heading": "2.2 Sampling Algorithms", "text": ""}, {"heading": "2.2.1 Grid and Random", "text": "Grid and random are the two most widely used algorithms to choose HPs in Deep Learning. Let us assume that n = kd. Then Grid sampling consists in choosing k values for each axis and then taking all kd points which can be obtained with these k values per axis. The value k does not have to be the same for all axes; this has no impact on the present discussion. There are various tools for choosing the k values per axis; evenly spaced, or purely randomly, or in a stratified manner. Random sampling consists in picking n independently and uniformly sampled vectors in [0, 1]d."}, {"heading": "2.2.2 Low Discrepancy Sequences", "text": "Low-discrepancy sequences have been heavily used in numerical integration but seldom in oneshot optimization. In the case of numerical integration there exists a tight connection between the integration error and a measure of \u201cspread\u201d of the points called discrepancy.\nDefinition 4 (Discrepancy) The discrepancy of a set S = {x1, . . . , xn} \u2282 [0, 1]d with respect to a familyR of subsets of [0, 1]d is defined as disc(S,R) := supR\u2208R |\u00b5S(R)\u2212 \u00b5(R)| , where \u00b5(R) is the Lebesgue measure of R and \u00b5S(R) is the fraction of elements of S that belong to R.\nLDS refer to algorithms constructing S of size n such that disc(S,H0) = O(log(n)d/n). One common way of generating such sequences is as follows: pick d coprime integers q1, . . . , qd. For an integer k, if k = \u2211 j\u22650 bjq j is its q-ary representation, then we define \u03b3q(k) := \u2211 j\u22650 bjq \u2212j\u22121 which corresponds to the point in [0, 1] whose q-ary representation is the reverse of that of k. Then the Halton sequence [7] is defined as {(\u03b3q1(k), . . . , \u03b3qd(k)) : 1 \u2264 k \u2264 n} and the Hammersley sequence is defined as {((k \u2212 12 )/n, \u03b3q1(k), . . . , \u03b3qd\u22121(k)) : 1 \u2264 k \u2264 n} One can also define scrambled versions of those sequences by randomly permuting the digits in the q-ary expansion (with a fixed permutation). The Sobol sequence [19] is also a popular choice and can be constructed using Gray codes [3]. It has the property that (for n = 2d) all hypercubes obtained by splitting each axis into two equal parts contain exactly one point. We use the publicly available implementation of Sobol by John Burkardt (2009).\nIt is often desirable to randomize LDS. This improves their robustness and permits repeated distinct runs. Some LDS are randomized by nature, e.g. when the scrambling is randomized, as in Halton scrambling. Another randomization consists in discarding the first k points, with k randomly chosen. A simple and generic randomization technique, called Random Shifting, consists in shifting by a random vector in the unit box; i.e. with x = (x1, . . . , xn) a sampling in [0, 1]d, we randomly draw a uniformly in [0, 1]d, and the randomly shifted counterpart of x is mod(x1 + a, 1),mod(x2 + a, 1), . . . ,mod(xn + a, 1) (where mod is the coordinate-wise modulo operator). Random shifting does not change the discrepancy (asymptotically) and provides low variance numerical integration [22]. The shifted versions of scrambled Halton and scrambled Hammersley are denoted by S-Ha and S-SH respectively."}, {"heading": "2.2.3 Latin Hypercube Sampling (LHS)", "text": "LHS [6, 16] construct a sequence as follows: for a given n, consider the partition of [0, 1]d into a regular grid of nd cells and then define the index of a cell as its position in the corresponding nd grid; choose d random permutations \u03c31, . . . , \u03c3d of {1, . . . , n} and choose for each k = 1, . . . , n, the cell whose index is \u03c31(k), . . . , \u03c3d(k), and choose xk uniformly at random in this cell. LHS ensures that all marginal projections on one axis have one point in each of the n regular intervals partitioning [0, 1]. On the other hand, LHS can be unlucky; if \u03c3j(i) = i for each j \u2208 {1, 2, . . . , d} and i \u2208 {1, 2, . . . , n}, then all points will be on the diagonal cells. Several variants of LHS exist that prevent such issues, in particular orthogonal sampling [21]."}, {"heading": "3 Theoretical Analysis", "text": "Due to length constraints all proofs are reported to the supplementary material.\nDesirable properties. Here are some properties that are particularly relevant in the setup of parallel HP optimization: No bad sequence: When using randomized algorithms to generate sequences, one desirable property is that the probability of getting a bad sequence (and thus missing the optimal setting of the HPs by a large amount) should be as low as possible. In other words, one would want to have some way to avoid being unlucky. Robustness w.r.t. irrelevant parameters: the performance of the search procedure should not be affected by the addition of irrelevant parameters. Indeed, it is often the case that one develops algorithms with many HPs, some of which do not affect the performance of the algorithm, or affect it only mildly. Otherwise stated, when projecting to a subset of critical variables, we get a point set with similar properties on this lower dimensional subspace. As argued in [1], this concept is critical in HP optimization. Consistency: The produced sequence should be such that the optimization error converges to zero as n goes to\u221e. Optimal Dispersion: it is known that the best possible dispersion for a sequence of n points is of order 1/n1/d, so it is desirable to have a sequence whose dispersion is within a constant factor of this optimal rate. We first mention a result from [17] which gives an estimate (tight up to constant factors) of the dispersion (with respect to hyperrectangles) of some known LDS.\nTheorem 1 ([17]) Consider Sn a set of n Halton points (resp. n Hammersley points, resp. n (t,m, s)-net points) in dimension d, then vdisp(Sn,H) = \u0398(1/n)\nLet Vd be the volume of the unit ball in dimension d, V \u2032d the volume of the orthant of this ball intersecting [0,\u221e)d and Kd be the volume of the largest hypercube included in this orthant. The following lemma gives relations between the different measures of spread we have introduced, showing that the discrepancy upper bounds all the others.\nLemma 2 (Relations between measures) For any distribution P and any \u03b4 \u2265 0, sdisp(P, \u03b4) \u2264 sdisp(P, 0). And if P generates only one sequence S, then sdisp(P, 0) = disp(S) \u2264 (vdisp(S,B)/V \u2032d)1/d \u2264 (Kdvdisp(S,H)/V \u2032d)1/d. Also we have for any family R, vdisp(S,R) \u2264 disc(S,R)."}, {"heading": "3.1 Dispersion of Sampling Algorithms & Projection to Critical Variables", "text": "The first observation is that if we compare (shifted) Grid and (shifted) LDS such as considered in Theorem 1 their stochastic dispersion is of the same asymptotic order 1/n1/d.\nTheorem 2 (Asymptotic Rate) Consider Random, (shifted) Grid, or a shifted LDS such as those considered in Theorem 1. For any fixed \u03b4, there exists a constant c\u03b4 such that for n large enough, sdisp(P, \u03b4) \u2264 K ( c\u03b4 n )1/d .\nRemark 1 One natural question to ask is whether the dependence on \u03b4 is different for different sequences. We can prove a slightly better bound on the stochastic dispersion for shifted LDS or shifted grid than for random. In particular we can show that, for all 0 < c < 12 , for \u03b4 close enough to\n1, sdisp\u2032(P, \u03b4) \u2264 K ( 1\u2212\u03b4 n )1/d . The constant K depends on the considered sequence and on \u03b4; and for \u03b4 close enough to 1 the constant is better for S-SH or a randomly shifted grid than for random. This follows from noticing that when the points of the sequence are at least 2 -separated, then the probability of x\u2217 to be in the -neighborhood (for the torus distance) of any point of the sequence is n dVd.\nNext we observe that the Random sequences have one major drawback which is that they cannot guarantee a small dispersion, while for Grid or LDS, we can get a small dispersion with probability 1. The following theorem follows from the proof of theorem 2:\nTheorem 3 (Guaranteed Success) For Random, lim\u03b4\u21920 sdisp(P, \u03b4) = 1. However, for Grid and Halton/Hammersley, sdisp(P, 0) = O(1/n1/d).\nFinally, we show that when the function f depends only on a subset of the variables, LDS and Random provide lower dispersion while this is not the case for Grid. Assume f(x) depends only on\n(xi)i\u2208I for some subset I of {1, . . . , d}. Then the optimization error is controlled by the stochastic dispersion of the projection of the sequence on the coordinates in I . Given a sequence S, we define SI as the sequence of projections on coordinates I of the elements of S, and we define PI as the distribution of SI when S is distributed according to P .\nTheorem 4 (Dependence on Critical Variables) We have the following bounds on the stochastic dispersion of projections: (i) For Random, Halton or Hammersley sdisp(PI , \u03b4) = O(1/n1/|I|), (ii) for Grid sdisp(PI , \u03b4) = \u0398(1/n1/d).\nRemark 2 (Importance of ranking variables properly) While the above result suggests that the dispersion of the projection only depends on the number of important variables, the performance in the non-asymptotic regime actually depends on the order of the important variables among all coordinates. Indeed, for Halton and Hammersley, the distribution on any given coordinate will become uniform only when n is larger than the corresponding qi. Since the qi have to be coprime, this means that assuming the qi are sorted, they will each be not smaller than the i-th prime number. So what will determine the quality of the sequence when only variables in I matter is the value maxi\u2208I qi. Hence it is preferable to assign small qi to the important variables.\nThe conclusion of this section, as illustrated by Fig. 1 is that among the various algorithms considered here, only the scrambled/shifted variants of Halton and Hammersley have all the desirable properties from Section 3. We will see in Section 4 that, besides having the desirable theoretical properties, the Halton/Hammersley variants also reach the best empirical performance."}, {"heading": "3.2 Pathological Functions", "text": "As we have seen above, the dispersion can give a characterization of the optimization error in cases where the modulus of continuity around the optimum is well behaved. Hence convergence to zero of the dispersion is a sufficient condition for consistency. However, one can construct pathological functions for which the considered algorithms fail to give a low optimization error.\nDeterministic sequences are inconsistent: In particular, if the sequence is deterministic one can always construct a function on which the optimization will not converge at all. Indeed, given a sequence x1, . . . , xn, . . ., one can construct a function such that f(xi) = 1 for any i and f(x) = 0 otherwise except in the neighborhood of the xi. Obviously the optimization error will be 1 for any n, meaning that the optimization procedure is not even consistent (i.e. fails to converge to the essential infimum of the function in the limit of n\u2192\u221e). Shifted sequences are consistent but can be worse than Random: One obvious fix for this issue is to use non-deterministic sequences by adding a random shift. This will guarantee that the optimization is consistent with probability 1. However, since we are shifting by the same vector every point in the deterministic sequence, we can still construct a pathological function which will be such that the optimization with the shifted sequence performs significantly worse that with a pure Random strategy. Indeed, imagine a function which is equal to 1 on balls B(xi, ) (for torus distance) for some small enough and which is equal to 0 everywhere else ( has to be small enough for the balls not to cover the whole space, so depends on n). In this case, the probability that the shifted sequence gives an optimization error of 1 is proportional to Vd, while it is less than (n Vd)n (which is much smaller for small enough) for Random. This proof does not cover stochastic LDS; but it can be extended to random shifts of any possibly stochastic point set which has a positive probability for at least one fixed set of values - this covers all usual LDS, stochastic or not.\nOther pathological examples: If we compare the various algorithms to Random, it is possible to construct pathological functions which will lead to worse performance than Random as illustrated on Figure 1 (right)."}, {"heading": "4 Experiments", "text": "We perform extensive empirical evaluation of LDS. We first validated the theory using a set of simple toy optimization problems, these fast problems provide an extensive validation with negligible p-values. Results (given in Section C) illustrate each claim - the performance of LDS for one-shot optimization (compared to random and LHS), the positive effect of Hammersley (compared to Halton)\nand of scrambling, the additional improvement when variables are ranked by decreasing importance, and the existence of counter-examples.\nWe perform some real-world deep learning experiments to further confirm the good properties of S-SH for hyper-parameter optimization. We finally broaden the use of LDS as a first-step initialization in the context of Bayesian optimization. Some additional experiments are provided in Section E, the additional results are consistent with the claims."}, {"heading": "4.1 Deep Learning tasks", "text": "Metrics We need to have a consistent and robust way to compare the sampling algorithms which are inherently stochastic. For this purpose, we can simply measure the probability p that a sampling algorithm S performs better than random search, when both use the same budget b of hyper-parameters trials. From this \u201cwin rate\u201d probability p, we can simply define a speed-up s as s = 2p\u221211\u2212p . Given two instances of random search R1 and R2, with different budgets b1 and b2, s refers to the additional budget needed for R1 to be better than R2 with probability p. That is, if b1 = (1 + s)b2, then p = 1+s2+s or equivalently s = 2p\u22121 1\u2212p .\nIn addition to the speed-up s, we report p and, when we have enough experiments on a single setup for having meaningful such statistics, we also report the raw improvements in validation score when using the same budget.\nLanguage Modeling We use language modeling as one of the challenging domain. Our datasets include Penn Tree Bank (PTB) [15], using both a word level representation and a byte level representation, and a variant UB-PTB that we created from PTB by randomly permuting blocks of 200 lines, to avoid systematic bias between train/validation/test2. Additionally, we use a subset of the Enwik8 [9] dataset, about 6%, which we name MiniWiki, and the corresponding shuffled version MiniUBWiki.\nWe use close to state-of-the-art LSTM models as language models, and measure the perplexity (or bit-per-byte) as the target loss. We compare S-SH and LHS with random search on all those datasets, tuning 5 HPs. More details can be found in setup A of Section B.\nThe results can be found in Fig. 2. Using that setup, both LHS and S-SH outperform random on all considered metrics, and for all budgets. LHS outperforms S-SH for small budgets (<11 values explored), while S-SH is best for larger budgets.\n2PTB and Enwik8 have systematic differences between the distributions of the train and the validation/test parts, because it is split in the order of the text. That can create systematic biases when an algorithm is more heavily tuned on the validation set.\nWe then perform additional experiments, with larger numbers of epochs and bigger nets, on language modeling. Results in Fig. 3 confirm that S-SH can provide a significant improvement, especially for budgets 30-60 for the word-PTB model and for budgets greater than 60 for the byte-PTB model. Detailed p-values for that experiment are given in Section E.\nImage classification experiments In addition to language modeling, image classification is representative of current Deep Learning challenges. We use a classical CNN model trained on Cifar10 [12]. The chosen architecture is not the state-of-the-art but is representative of the mainstream ones. Those experiments are tuning 6 HPs. More details can be found in setup B in Section B.\nResults are presented in Fig. 4. Except for very small budgets (< 5, for which S-SH fails and for which we might recommend LHS rather than LDS; see also Fig. 2 on this LHS/S-SH comparison for small budget) we usually get better results with S-SH."}, {"heading": "4.2 LDS as a first-step in a Bayesian optimization framework.", "text": "LDS (here S-Ha) also succeeds in the context of sampling the first batch in a Bayesian optimization run (Table 1), LDS outperforms (a) random sampling, (b) LHS, and (c) methods based on pessimistically fantasizing the objective value of sampled vectors[8]. For rare cases Bayesian optimization based on LHS or pessimistic fantasizing outperform our LDS-based Bayesian optimization even for one single batch - but in dimension 12 LDS-BO (LDS-initialized Bayesian optimization) still performed best for most numbers of batches in {1, 3, 5} and most functions in {Branin,Beale, SixHump,Rastrigin,Ellipsoidal, Sphere}. Results were mixed in dimension 2."}, {"heading": "5 Conclusion", "text": "We analyzed theoretically and experimentally the performance of LDS for hyper-parameter optimization. The convergence rate results show that LDS are strictly better than random search both for high confidence and low confidence quantiles (Theorem 3 and Remark 1). In particular, with enough points, LDS can find the optimum within distance with probability exactly 1, due to the absence of unlucky cases, unlike random search. For intermediate quantiles the theoretical rate bounds are equivalent between LDS and random search but we could not prove that the constant is better except in dimension 1. In the common case where parameters have different impacts, and only a few really matter, we show that parameters should be ranked (Remark 2). Further we prove that LDS outperforms grid search (in case some variables are critically important) and the best LDS sequences are robust against bad parameter ranking (Theorem 4). The experiments confirmed and extended our theoretical results: LDS is consistently outperforming random search, as well as LHS except for small budget. Importantly, while the theory covers only the one-shot case, we get great performance for LDS as a first step in Bayesian optimization[10], even compared to entropy search[8] or LHS-initialized Bayesian optimization.\nAs a summary of this study, we suggest Randomly Scrambled Hammersley with random shift as a robust one-shot optimization method. Replacing random search with this sampling method is a very simple change in a Deep Learning training pipeline, can bring some significant speedup and we believe should be adopted by most practitioners - though for budgets < 10 we might prefer LHS. To spread the use of LDS as a way to optimize HPs, we will open-source a small library at https://AnonymizedUrl. Our results also support the application of LDS for the first batch of Bayesian optimization. Importantly, not all LDS perform equally - we were never disappointed by S-SH, but Sobol (used in [13]) or unscrambled variants of Halton are risky alternatives."}, {"heading": "A Proofs", "text": "Proof [Lemma 2] A ball of radius has volume Vd d, so if v is the volume of a ball, its radius is (v/Vd)1/d. If v is the largest volume of a ball not containing any point of S, then the largest hypercube contained in this ball, which has volume v.Kd will also be empty, which shows that vdisp(S,B) \u2264 Kdvdisp(S,H). Finally it is easy to see that the volume dispersion is upper bounded by the discrepancy as it follows from their definition.\nProof [Theorem 2] For Grid this is a known result[20]. For Random, the probability of n randomly picked balls of radius to contain any particular point x\u2217 is upper bounded by 1 \u2212 (1 \u2212 V \u2032d d)n,\nhence this gives an upper bound of (\nlog 1/\u03b4 n\n)1/d for n large with respect to log 1/\u03b4.\nFor the LDS sequences, this follows from combining Lemma 2 with Theorem 1.\nProof [Theorem 4] The projection of Random (resp. Halton) sequences are Random (resp. Halton) sequences. For Hammersley the first coordinate is uniform, so the projection onto I is Hammersley if 1 \u2208 I or is Halton otherwise. Theorem 2 allows to conclude. The result for Grid is obvious."}, {"heading": "B Detailed experiment setups", "text": "Setup A Language model with 3 layers of LSTM with 250 units trained for 6 epochs. In this setup, we have 5 hyper-parameters: weight init scale [0.02, 1], Adam\u2019s parameter [0.001, 2], clipping gradient norm [0.02, 1], learning rate [0.5, 30], dropout keep probability [0.6, 1].\nSetup B Image classification model with 3 convolutional layers, with filter size 7x7, max-pooling, stride 1, 512 chanels; then one convolutional layer with filter size 5x5 and 64 chanels; then two fully connected layers with 384 and 192 units respectively. We apply stochastic gradient descent with batch size 64, weight init scale in [1, 30] for feedforward layers and [0.005, 0.03] for convolutional layers, learning rate [0.00018, 0.002], epoch for starting the learning rate decay [2, 350], learning rate decay in [0.5, 0.99999] (sampled logarithmically around 1), dropout keep probability in [0.995, 1.]. Trained for 30 epochs.\nSetup C Language model with 2 stacked LSTM with 650 units, with the following hyperparameters: learning rate [0.5, 30], gradient clipping [0.02, 1], dropout keep probability [0.6, 1]. Model trained for 45 epochs."}, {"heading": "C Toy optimization problems", "text": "We conducted a set of experiments on multiple toy problems to quickly validate our assumptions. Compared methods are one-shot optimization algorithms based on the following samplings: Random, LHS, Sobol, Hammersley, Halton, S-SH. We loop over dimensions 2, 4, 8, and 16; we check three objective functions (l2-norm f(x) = ||x \u2212 x\u2217||, illcond f(x) = \u2211d i=1(d \u2212 i)3(xi \u2212 x\u2217i )2,\nreverseIllcond f(x) = \u2211d i=1(1 + i)\n3(xi \u2212 x\u2217i )2). The budget is n = 37 in all cases. We used antithetic variables, thanks to mirroring w.r.t the 3 first axes (hence 8 symmetries). Each method is tested with and without this 3D mirroring. 3D mirroring deals conveniently with multiples of 8; additional points are generated in a pure random manner. x\u2217 is randomly drawn uniformly in the domain. Each of these 12 experiments is reproduced 1221 times.\nIn each of these 12 cases (4 different dimensions \u00d7 3 different test functions), on average over the 1221 runs, Sobol and Scrambled-Hammersley performed better than Random in terms of simple\nregret. This validates, on these artificial problems, both Sobol and Scrambled-Hammersley, in terms of one-shot optimization and face to random search, with p-value 0.0002.\nUnsurprisingly, for illcond, Halton and Hammersley outperform random, whereas it is the opposite for reverseIllcond at least in dimension 8 and 16, i.e. it matters to have the most important variables first for these sequences. Scrambled versions (both Halton and Hammersley) resist much better and still outperform random - this validates scrambling.\nScrambled Hammersley performs best 6 times, scrambled Halton and Hammersley 2 times each, Sobol and Halton once each; none of the 3d mirrored tools ever performed best. This invalidates mirroring, and confirm the good behavior of scrambled Hammersley.\nThese intensive toy experiments are in accordance with the known results and our theoretical analysis (Section 3). Based on the results, the randomly shifted Scrambled-Hammersley is our main LDS for the evaluation on real Deep Learning tasks."}, {"heading": "D Artificial datasets", "text": "Our artificial datasets are indexed with one string (AN or ANBN or .N or others, detailed below) and 4 numbers. For the artificial dataset C, the 4 numbers are the vocabulary size (the number of letters), maximum word size (n or N ), vocabulary growth and depth - unless specified otherwise, vocabulary growth is 10 and depth is 3. There are also four parameters for ANBN, AN, .N and anbn; but the two last parameters are different: they are \u201cfixed size\u201d (True for fixed size, False otherwise) and \u201csize gaps\u201d (impact of size gaps equal to True detailed below). For example, artificial(anbn,26,10,0,1) means that n is randomly drawn between 1 and 10, and that there are size gaps; whereas artificial(anbn,26,10,1,0) means that n is fixed equal to 10 and there is no size gap.\n\u2022 AN is a artificial dataset with, as word, a single letter randomly drawn (once for each sequence) and repeated a fixed number of times (same number of times for different sequences, but different letter). For examples, the first sequence might be \u201cqqqqqq qqqqqq qqqqqq\u201d and the second one \u201cpppppp pppppp pppppp\u201d.\n\u2022 The \u201cANBN\u201d testbed is made of words built by concatenating N copies of a given randomly drawn letter, followed by N copies of another randomly drawn letter. The words are repeated until the end of the sequence. For different sequences, we have different letters, but the same number N.\n\u2022 In the \u201cABNA\u201d dataset, a word is one letter (randomly drawn, termed A), then N copies of another letter (randomly drawn and termed B), and then the first letter again.\n\u2022 We also use the \u201c.N\u201d testbed, where the \u201clanguage\u201d to be modelled is made of sequences, each of them containing only one word (made of N randomly independently drawn letters) repeated until the end of the sequence. The first sequence might be \u201cbridereix bridereix bridereix\u201d and the second sequence \u201cdunlepale dunlepale dunlepale\u201d.\n\u2022 We also have \u201canbn\u201d as a testbed: compared to ANBN, the number of letters vary for each word in a same sequence, and the letters vary even inside a sequence. The first sequence might be \u201caaabbb ddddcccc db\u201d.\n\u2022 Finally, we use the \u201cC\u201d testbed, in which there are typically 26 letters (i.e. the vocabulary size is 26 unless stated otherwise), words are randomly drawn combinations of letters and there exists V \u00d7 26 words of e.g. 10 (word size) letters; and there exists V 2 \u00d7 26 groups (we might say \u201csentences\u201d) of 10 words, where V is the \u201cvocabulary growth\u201d; there are 3 levels (letters, words, groups of words) when the depth is 3. For example artificial(C, 26, 10, 7, 3) contains 26 letters, 26\u00d77 words of length 10, and 26\u00d772 groups of 10 words.\nFor each sequence of these artificial datasets, the word size N is randomly chosen uniformly between 1 and the maximum word size, except when fixed size is 1 - in which case the word size is always the maximum word size.\nIf size gaps is equal to True, then the test sizes used in test and validation are guaranteed to not have been seen in training; 4 word sizes are randomly chosen for valid and for test, and the other 16 are used in training. There are 10 000 training sequences, 1000 validation sequences, 1000 test sequences.\nEach sequence is made of 50 words, except for C for which a sequence is one group of the maximum level.\nIn all artificial sequences, letters which are not predictable given the type of sequence have a weight 0 (i.e. are not taken into account when computing the loss). In all cases, the loss functions are in bits-per-byte."}, {"heading": "E Additional experiments", "text": "E.1 Robustness speed-up\nIn addition to the speed-up defined in Section 4.1, we here define a robustness speed-up.\nSpeed-up was defined as such because (1 + s)/(2 + s) is the frequency at which a random search with budget b \u00d7 (1 + s) wins against a random search with budget b. We can define the speed-up similarly when S competes with several (say K) instances of random search with the same budget b: p = (1+s)/(K+1+s). Note that whenK > 1, we could define another type of speed-up: instead of the frequency at which S is better than all K independent copies of random search, we can consider the frequency at which it performs worse than all these K instances. We call it robustness speed-up; this speed-up is positive when the algorithm is robust and avoids bad cases. When ambiguous, we refer to the initial one as optimistic speed-up, otherwise simply speed-up.\nE.2 Average speed-ups over many budgets and testbeds: LDS outperforms random in a stable manner\nWe consider tuning three commonly used hyper-parameters ranked in the following way: learning rate, weight init scale, max gradient norm in three different settings \u2013 untuned, half-tuned and tuned \u2013 which corresponds to some degree of prior on the expected range of those hyper parameters (Table 2).\nS-SH performs clearly better than random (Table 3): all statistically significant results are in favor of S-SH compared to random. In cases in which the speed-up was negative, this was not statistically significant; and we checked, in all cases in which the speed-up was less than +200%, that the robustness speed-up is still positive.\nE.3 Results on toy language modeling problems with additional model hyper-parameters.\nWe use a modified version of the LSTM cell using 100 leaky state units; each state unit includes 2 additional parameters, sampled at initialization time according to a gaussian distribution, whose mean and variance are the 2 additional HPs of the model. Whereas we use, in all experiments (including the present ones), learning rate and gradient clipping norm as the two first parameters, a posteriori analysis shows that the important parameters are these two specific parameters and therefore our prior (on the ranking of HP) was wrong - this is a common scenario where we do not have any prior on the relative importance of the hyper-parameters. The model was trained on 6 of the artificial datasets described in Appendix D, namely toy(.N26,5,0,1), toy(.N,26,10,0,1), toy(AN,26,5,0,1), toy(AN,26,10,0,1), toy(anbn,26,5,0,1), toy(anbn,26,10,0,1). We use learning rate \u2208 [5, 100], weight init scale \u2208 [0.05, 1], max gradient norm \u2208 [0.05, 1], and the two new parameters (mean/std) are respectively \u2208 [\u22129, 9] and \u2208 [0.01, 10]. We check budget 10, 15, 20, 25, . . . , 100. Fig. 6 shows the rank of S-SH, among S-SH and 3 instances of random search; this rank is between 1 and 4; after normalization to [0, 1] we get 0.404\u00b1 0.097, 0.456 \u00b1 0.084, 0.281\u00b1 0.084, 0.491\u00b10.080, 0.544\u00b1 0.092, 0.316\u00b1 0.081 on these 6 tasks respectively; all but one are in favor of S-SH (i.e. rank < 0.5), 2 are statistically significant, and when agregating over all these runs we get an average rank 0.415 at \u2265 3 standard deviations from .5, hence clearly significant.\nE.4 Other sampling algorithms: S-SH performs best\nE.4.1 Validating scrambling/Hammersley on PTB: not all LDS are equivalent\nFig. 7 compares pure random, Halton, and scrambled Halton on PTB-Bytes and PTB-Words. The setting is as follows: 7 HPs (dropout keep probability in [0.2, 1], learning rate in [0.05, 300], gradient clipping norm in [0.002, 1], Adam\u2019s epsilon parameter in [0.001, 2], weight initialization scale in [0.002, 10], epoch index for starting the exponential decay of learning rate in [5, 15], learning rate decay in [0.1, 1]); 17 training epochs, 2 stacked LSTM; we perform experiments for a number of units ranging from 12 to 29. The budget for the randomly drawn HPs is 20. Overall, there are 36 comparisons (18 on PTB-Bytes, corresponding to 18 different numbers of units, and 18 on PTB-Words);\n\u2022 Scrambled-Hammersley outperforms Halton 25 times (p-value 0.036); \u2022 Scrambled-Hammersley outperforms random 22 times (p-value 0.12); \u2022 Halton outperforms random 19 times (p-value 0.43).\nThe experiment was reproduced a second time, with budget = 30 random tries for the HPs. Results are presented in Fig. 8 - no statistically significant improvement.\nE.5 Robustness vs peak performance\nWe have seen in Section E.2 that S-SH was always beneficial in terms of robustness; and most often in terms of peak performance (optimistic speed-up). We develop this point by performing additional experiments. We prefer challenges, so we focus on the so-called tuned-setting in which our results in Section E.2 were least positive for S-SH. We performed experiments with many different values of the budget (number of HPs vectors sampled) and tested if S-SH performs better than random in both low budget regime (\u2264 48) and large budget > 48). Each budget from 5 to 73 was tested. For large budget regime, S-SH performed excellently, both in terms of best performance (speed-up +87%, p-value 0.09) and worst performance (robustness speed-up +50%, p-value 0.18). For budget \u2264 48, random was performing better than S-SH for the optimistic speed-up (\u221251%, p-value 0.18); but worse than S-SH for the robustness speed-up (+28%, p-value 0.09). Importantly, this section focuses on the only setting in which S-SH was not beneficial in our diverse experiments (Section E.2); we have, on purpose, developped precisely the case in which things were going wrong in order to clarify to which extent replacing random by S-SH can be detrimental.\nE.6 Performance as a function of the number of epochs\nWe consider the untuned setting, on the same 6 problems as (*) in Fig. 3. We have a number of epochs ranging from 7 to 36, and we consider moving averages of the ranks over the 6 datasets and 4 successive numbers of epochs. Fig. 9 presents the impact of the number of epochs; S-SH performs best overall.\nE.7 Results as an initialization for GP\nIn this section we leave the one-shot setting; we consider several batches, and a Gaussian processes (GP) based Bayesian optimization. Results in [24] already advocated LDS for the initialization of GP, pointing out that this outperforms Latin Hypercube Sampling; in the present section, we confirm those results in the case of deep learning and show that we also outperform typical pessimistic fantasizing as used in batch entropy search. The pessimistic fantasizing method for GP is based on (i) for the first point of a batch, use optimistic estimates on the value as a criterion for selecting candidates (ii) for the next points in the same batch, fantasizing the values of the previous points in the current batch in a pessimistic manner; and apply the same criterion as above, assuming these pessimistic values for previous values of the batch. For the first batch, this leads to regular patterns as\nin grids. We keep the same method for further iterations but replace this first batch by (a) random sampling (b) low-discrepancy sampling. Results are presented in Fig. 10. We randomly translate the optimum in the domain but do not rotate the space of functions - which would destroy the concept of critical variables. We consider artificial test functions, namely Sphere, Ellipsoid, Branin, Rastrigin, Six-Hump, Styblinski, Beale. We work in dimension 12, with 64 vectors of HPs per batch. We average results over 750, 100 and 50 runs for 1, 3 and 5 batches respectively."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "The selection of hyper-parameters is critical in Deep Learning. Because of the long training time of complex models and the availability of compute resources in the cloud, \u201cone-shot\u201d optimization schemes \u2013 where the sets of hyper-parameters are selected in advance (e.g. on a grid or in a random manner) and the training is executed in parallel \u2013 are commonly used. [1] show that grid search is sub-optimal, especially when only a few critical parameters matter, and suggest to use random search instead. Yet, random search can be \u201cunlucky\u201d and produce sets of values that leave some part of the domain unexplored. Quasi-random methods, such as Low Discrepancy Sequences (LDS) avoid these issues. We show that such methods have theoretical properties that make them appealing for performing hyperparameter search, and demonstrate that, when applied to the selection of hyperparameters of complex Deep Learning models (such as state-of-the-art LSTM language models and image classification models), they yield suitable hyperparameters values with much fewer runs than random search. We propose a particularly simple LDS method which can be used as a drop-in replacement for grid/random search in any Deep Learning pipeline, both as a fully one-shot hyperparameter search or as an initializer in iterative batch optimization.", "creator": "LaTeX with hyperref package"}}}