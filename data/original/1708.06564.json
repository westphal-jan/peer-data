{"id": "1708.06564", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Aug-2017", "title": "The Continuous Hint Factory - Providing Hints in Vast and Sparsely Populated Edit Distance Spaces", "abstract": "Intelligent tutoring systems can support students in solving multi-step tasks by providing a hint regarding what to do next. However, engineering such next-step hints manually or using an expert model becomes infeasible if the space of possible states is too large. Therefore, several approaches have emerged to infer next-step hints automatically, relying on past student's data. Such hints typically have the form of an edit which could have been performed by capable students in the given situation, based on what past capable students have done. In this contribution we provide a mathematical framework to analyze edit-based hint policies and, based on this theory, propose a novel hint policy to provide edit hints for learning tasks with a vast state space and sparse student data. We call this technique the continuous hint factory because it embeds student data in a continuous space, in which the most likely edit can be inferred in a probabilistic sense, similar to the hint factory.", "histories": [["v1", "Tue, 22 Aug 2017 11:33:46 GMT  (140kb,D)", "http://arxiv.org/abs/1708.06564v1", "Submitted to the Journal of Educational Datamining on 2017-08-12"]], "COMMENTS": "Submitted to the Journal of Educational Datamining on 2017-08-12", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["benjamin paa{\\ss}en", "barbara hammer", "thomas william price", "tiffany barnes", "sebastian gross", "niels pinkwart"], "accepted": false, "id": "1708.06564"}, "pdf": {"name": "1708.06564.pdf", "metadata": {"source": "CRF", "title": "The Continuous Hint Factory - Providing Hints in Vast and Sparsely Populated Edit Distance Spaces", "authors": ["Benjamin Paa\u00dfen", "Barbara Hammer", "Thomas W. Price", "Tiffany Barnes"], "emails": ["bpaassen@techfak.uni-bielefeld.de", "bhammer@techfak.uni-bielefeld.de", "twprice@ncsu.edu", "tmbarnes@ncsu.edu", "sebastian.gross@informatik.hu-berlin.de", "niels.pinkwart@hu-berlin.de"], "sections": [{"heading": null, "text": "1\nar X\niv :1\npolicy to provide edit hints for learning tasks with a vast state space and sparse student data. We call this technique the continuous hint factory because it embeds student data in a continuous space, in which the most likely edit can be inferred in a probabilistic sense, similar to the hint factory.\nIn our experimental evaluation we demonstrate that the continuous hint factory can predict what capable students would do in solving a multi-step programming task and that hints provided by the continuous hint factory match to some extent the edit hints that human tutors would have given in the same situation.\nkeywords: next-step hints, hint factory, edit distances, computer science education, Gaussian Processes"}, {"heading": "1 Introduction", "text": "In many educational domains, learning tasks require more than a single step to solve. For example, programming tasks require a student to iteratively write, test and refine code that accomplishes a given objective [15, 39, 44]. When working on such multi-step-tasks, students start with an initial state and then change their state by applying an action (such as inserting or deleting a piece of code). At some point, a student may not know how to proceed or may be unable to find an error in her current state, in which case external help is required. In particular, such a student may benefit from a next-step hint, guiding her toward a more complete and/or more correct version and allowing her to continue working on her own [2]. Many intelligent tutoring systems (ITS) support these multi-step tasks by generating next-step hints to match the student\u2019s current state and her underlying strategy [47]. Typically, such hints are generated using an expert-crafted model. However, designing such an expert model becomes infeasible if the space of possible states grows too large [28, 20, 44]. This is the case for most computer programming tasks because the space of possible programs grows exponentially with the program length and the set of programs which generate the same function is infinite [36]. Other examples are so-called ill-defined domains where explicit domain knowledge is not available or at least very hard to formalize [25]. In this paper, we address hint generations in these vast state spaces with a particular focus on the domain of computer programming.\nSeveral approaches have emerged which provide next-step hints without an expert model. Typically, these approaches provide hints in the form of edits, that is, actions which can be applied to the student\u2019s current state to change it into a more correct and/or more complete state, based on the edits that successful students in the past have applied [5, 16, 36, 38, 44, for example]. Such edit-based next-step hints constitute an elegant and simple approach to feedback for complex learning tasks. The most basic version of the approach needs only two ingredients: an edit function, which is able to compute the edits that are necessary to transform one state into a solution to the task. If a student issues a help request, the system can simply compute the necessary edits from the student\u2019s state to the solution and use one of these edits as a hint [50]. Even though this approach is fairly simple, it is conceptually quite powerful, because the feedback provided is personalized in the sense that the hint a student receives depends on her personal state and is thereby tailored to her specific situation [23]. Another advantage is that this approach needs very little task-specific work on the side of the teachers, because they only need to construct one solution for the task, and can apply a general-purpose edit function which is applicable across tasks or even across domains [27].\nIn this contribution, we will embed existing edit-based hint approaches into a common, mathematical framework, providing precise definitions for key concepts in the field. A key part of this novel theory is the notion of the edit distance space, a continuous space in which each state corresponds to one vector and the distance between vectors corresponds exactly to the number of edits it takes to get from one state to another one. This edit distance space forms the basis for the continuous hint factory, a novel hint approach which first infers the most likely edit in the edit distance space based on machine learning techniques and then finds a human-readable edit which corresponds to the recommendation in the edit distance space. This novel technique is a general-purpose hint policy which can be applied whenever an edit distance and some, possibly few, data of past students is available. Therefore, the continuous hint factory provides a novel option for hint feedback in learning tasks where little domain engineering is possible and little student data is available. In a sense, we combine the probabilistic modelling of the hint factory, a well-established hint approach for densely populated state spaces [45], with the nearest-neighbor-principle commonly used in hint policies for vast and sparsely populated state spaces [16, 44, 50] to achieve a novel approach that extends existing work. In experiments on two real-world datasets we\ndemonstrate that the continuous hint factory is able to predict what capable students would do in solving a learning task and that it can utilize these predictions to provide hints which match what human tutors would have recommended.\nWe begin our work by introducing precise definitions of key concepts of edit-based hint policies and review existing approaches within this novel framework. In section 3 we introduce the continuous hint factory based on this framework and in section 4 we report on our experimental evaluation of the continuous hint factory."}, {"heading": "2 An integrated view of edit-based hint policies", "text": "In this section we review existing approaches to edit-based hint policies. Alongside this review, we develop a mathematical theory of edit distances and edit-based hint policies, which helps us to contextualize past approaches and will form a firm basis for our own approach in the next section. First, let us start with an example of a learning task, for which an edit-based hint policy may be helpful. Consider the task of creating an activity diagram in the unified modelling language (UML), which models a program that has two inputs, m and n, and returns \u22121 if m < n, 0 if m = n, and 1 if m > n. The solution to this task is shown in Figure 1 on the left. In a tutoring system including this task, the student starts off with an empty UML diagram, and then applies edits to the diagram until she is stuck and does not know how to proceed, for example in state x3 on the right. Then, she hits the \u201chelp\u201d button of the system and is provided with a suggestion for an edit she could apply to get closer to a correct solution, for example to add the statement \u201cLet n be the second input\u201d to her diagram.\nFrom a pedagogic point of view, other kinds of hints may lead to better learning gains compared to edit hints. In particular, edit hints lack the capacity to reference underlying concepts which may be helpful for the task or elaborate on these concepts, as suggested by Fleming and Levie [10, 22]. Instead, edit hints directly display the next step towards a more correct and complete state. Aleven et al. suggest to display these \u201cbottom-out hints\u201d hints only as a last resort after exhausting options for more principle-based hints [2]. Indeed, the research they review suggests that principle-based hints lead to higher learning gains compared to bottom-out hints. So, why do we focus in this particular kind of hint?\nFirst, edit hints are different from other bottom-out hints in that they display only a very small part of the solution (a single edit), allowing the student to finish most of the problem independently. Second, bottom-out hints, such as edit hints, may lead to learning gains, if students reflect on the hint and engage in sense-making behavior [2]. Conversely, if students aim to abuse the system, this is not hindered by principle-based hints: students simply skip through them to reach the bottom-out hint [2]. Third, we point to a study by Price et al. which indicates that edit hints are judged as relevant and interpretable by human tutors [41]. Finally, and most importantly, we argue that more elaborate hint strategies are simply not available in many important learning tasks, because they require hint messages which result from an expert-crafted model, which is infeasible if the space of possible states is vast and includes many different strategies, because the sheer number of different hint messages necessary is too large for human experts to handle [28, 44, 23], or because human experts may overlook strategies that novices might employ (\u201cexpert blind spot\u201d) [29]. For such learning tasks, edit-based hints may be the best form of feedback that is still applicable in practice. For this reason, recent work on hint generation for programming has focused largely on automatic, edit-based hint generation [16, 21, 38, 44, 50].\nWe note that there have been some approaches to make expert-crafted hints available in larger state spaces. First, we highlight authoring tools for tutoring systems, which aim at reducing the expert work that needs to be put in to design feedback for individual tasks. A prime example are the cognitive tutor authoring tools (CTAT) which support the construction of cognitive tutors, in particular example-tracing tutors [1]. With regards to intelligent tutoring systems, this can be seen as a \u201cgold standard\u201d, because the effectiveness of cognitive tutors has been established in classroom studies, as well as their successful application in classrooms across the US [20]. However, even with authoring tools, covering the whole space of possible states may be very challenging or even impossible for learning tasks with vast state spaces, given that the upper end of complexity demonstrated by Aleven et al. is a task with roughly 20 steps and 6 different paths toward the solution [1]. By comparison, in our programming dataset, we observed that almost each of the 47 solution attempts was unique and each of them involved more than 40 steps. Another approach is \u201cforce multiplication\u201d, which assumes that a relatively small number of expert-crafted hint messages are available, which are then applied to new situations automatically, thereby \u201cmultiplying the force\u201d of expert work [35]. Examples include the work of Head et al., Yin et\nal., and Choudhury et al. who apply clustering methods to aggregate many different states and then provide the same hint to all states in the same cluster [18, 48, 7]. Another example is the work of Piech et al. who assume that expert-crafted hints are annotated with example states for which the given hint makes sense, and example states for which the given hint does not make sense in the opinion of the experts. Then, they train a classifier function via machine learning which decides for any new state whether the hint should be displayed or not [35]. Finally, Marin et al. annotate expertcrafted hints with small snippets of Java code for which the given hint makes sense and display the hint whenever the respective snippet is discovered in a student\u2019s state [26]. Note that these approaches are limited by the number of hints that are provided by the teaching experts. If for some situation no hint is contained in the database, the system is not able to provide fitting feedback.\nIn the remainder of this chapter we will analyze edit-based next-step hint approaches in more detail. We will highlight key concepts, provide precise definitions and shed some light on the theory behind edit-based hint approaches. We start our investigation by defining edits, legal move graphs and edit distances in a rigorous fashion. Second, we discuss techniques to change our data representation in order to support meaningful hints. Third, we incorporate student data in the form of traces and interaction networks. Finally, we provide an overview of the different approaches that have emerged in the literature and compare them in light of our mathematical framework."}, {"heading": "2.1 Edit Distances and Legal Move Graphs", "text": "Remember that we want to support students in solving a multi-step learning task by providing on-demand hints. In this scenario, a student starts with an initial state provided by the system, and then successively edits this initial state until she finishes or gets stuck and asks the system for help. To achieve such a hint system, we first need to define the set of possible edits that students can apply (the edit set). Then, we need to chain these edits to find paths of edits that lead to a solution (the legal move graph). Finally, we want to identify the shortest path toward a solution, which leads us to the notion of edit distance. We begin by defining the edit set. Recall our example of a UML activity diagram task. Figure 1 (right) shows how an initially empty graph can be extended by different edits. Note that each state in this figure is a UML diagram, and our edits manipulate diagrams\nto yield new diagrams. In this example, our edit set permits inserting new nodes as successors of existing nodes, deleting nodes and re-labelling nodes in the existing diagram. Note that edits differ depending on which node we manipulate and which labels we consider. For example, inserting a start node (the transition of x1 to x2) is different from inserting an action node (x2 to x3), and inserting an action node after the start node (x2 to x3) is different from inserting an action node after another action node (x3 to x5). Further note that this edit set is symmetric, meaning that for every edit we apply we can apply an inverse edit which undoes our previous edit. In general, we also assume that our edit sets are reflexive, meaning that a \u201cneutral\u201d edit exists which leaves the student\u2019s state unchanged. These set properties are of key importance to our later mathematical claims. The mathematical definition of edits and edit sets is as follows:\nDefinition 1 (Edit Set). Let X be the set of all states for a learning task. An edit on X is a function \u03b4 : X \u2192 X. A set \u2206 of edits on X is called an edit set. We call an edit set reflexive if for all states x \u2208 X there exists an edit \u03b4 \u2208 \u2206, Such that \u03b4(x) = x. We call an edit set symmetric if for all states x \u2208 X and all edits \u03b4 \u2208 \u2206 there exists an edit \u03b4\u22121 \u2208 \u2206 such that \u03b4\u22121(\u03b4(x)) = x. We call \u03b4\u22121 the inverse edit for \u03b4 on x.\nThis concept of edits already permits us to define the problem we would like to solve, namely to find a function which, for any state a student might find herself in, returns an edit guiding her closer to a solution. Inspired by Piech et al. we call such a function a hint policy [36].\nDefinition 2 (Hint Policy). Let X be a set and \u2206 be an edit set on X. A hint policy is a function \u03c0 : X \u2192 \u2206.\nNote that Piech et al. define a hint policy differently, namely as a function \u03c0\u2032 mapping a state to a state the student should proceed to next. Our definition is more general than theirs, in the sense that for every policy \u03c0 according to our definition we can construct a Piech-style hint policy \u03c0\u2032 by simply setting \u03c0\u2032(x) = \u03b4(x) where \u03b4 = \u03c0(x).\nA simple example hint policy is the policy of Zimmerman and Rupakheti, who suggest to return the first edit in the shortest sequence of edits which transforms the input state to a correct solution for the task [50]. This shortest sequence of edits can be viewed as a path in a legal move graph which has the possible states X as nodes and the edits \u2206 as edges. The precise definition of this graph is as follows:\nDefinition 3 (Legal Move Graph). Let X be a set and \u2206 be an edit set on X. Then, the legal move graph according to X and \u2206 is defined as the directed graph GX,\u2206 = (X,E) where E = {(x, y)|\u2203\u03b4 \u2208 \u2206 : \u03b4(x) = y}.\nAn excerpt of the legal move graph for our UML example is shown in Figure 1 (right). The legal move graph for this example can be constructed as follows: First, start with a node representing an empty UML diagram (x1 in Figure 1 on the right). Then, recursively extend the legal move graph with the following procedure: For all states x that we have already constructed, consider the states y that result from adding, removing or relabelling a single node to x, add y to the legal move graph (if not already present) and connect x to y with a directed egde. Note that the legal move graph does not only include states which lead toward the solution but also includes a lot of erroneous or absurd states. For example, Figure 1 includes the states x4 and x6 which add the decision node too early.\nThe notion of a shortest sequence of edits transforming a student\u2019s state x to a solution y now has a proper graph-theoretical interpretation: It is the shortest path from x to y in the legal move graph. The length of this shortest path can be seen as a distance d between x and y. As an example, consider once more the legal move graph in Figure 1 (right). Here we find, for example, d(x1, x2) = 1 and d(x1, x6) = 3.\nWe implicitly assumed that all edges in a legal move graph have the length 1. However, we can also consider edges with different lengths, which leads us to the notion of an edit cost function and a more general concept of edit distance:\nDefinition 4 (Edit Cost Function and Edit Distances). Let X be a set and \u2206 be an edit set on X. A function C : \u2206 \u00d7 X \u2192 R is called an edit cost function on \u2206. We call C(\u03b4, x) the cost of applying edit \u03b4 to the state x.\nWe call an edit cost function non-negative if C(\u03b4, x) \u2265 0 for all states X \u2208 X and all edits \u03b4 \u2208 \u2206. We call an edit cost function reflexive if for all states x \u2208 x there exists An edit \u03b4 \u2208 \u2206, such that \u03b4(x) = x and C(\u03b4, x) = 0. We call an edit cost function symmetric if C(\u03b4, x) = C(\u03b4\u22121, \u03b4(x)) for all states x \u2208 X and all edits \u03b4 \u2208 \u2206 where \u03b4\u22121 is the inverse edit for \u03b4 on x.\nLet GX,\u2206 be the legal move graph according to X and \u2206 and let C be an edit cost function on \u2206. The edit distance d\u2206,C according to \u2206 and C is defined as the shortest path distance in the legal move graph GX,\u2206 with the edge weights \u03b2(x, y) = min\u03b4\u2208\u2206{C(\u03b4, x)|\u03b4(x) = y}. So the formula for the\nedit distance is:\nd\u2206,C(x, y) := min \u03b41,...,\u03b4T\u2208\u2206 x2,...,xT\u2208X { T\u2211 t=1 C(\u03b4t, xt) \u2223\u2223\u2223\u2223\u2223x1 = x, \u03b4t(xt) = xt+1, \u03b4T (xT ) = y } (1)\nIf no path between x and y exists, we define d\u2206,C(x, y) =\u221e.\nFor some combinations of edit sets and edit cost functions, edit distances can be computed efficiently, even without representing the legal move graph explicitly. As an example, consider the string edit distance [24] which operates on sequences over some alphabet A. It permits deletions of single elements in the string, insertions of single elements and replacements of elements at each position. More precisely, the edit set is defined as\n\u2206 = {deln, insn,u, repn,u|n \u2208 N, u \u2208 A} where (2) deln(v1, . . . , vN) = v1, . . . , vn\u22121, vn+1, . . . , vN (3)\ninsn,u(v1, . . . , vN) = v1, . . . , vn, u, vn+1, . . . , vN (4) repn,u(v1, . . . , vN) = v1, . . . , vn\u22121, u, vn+1, . . . , vN (5)\nand the edit cost function is defined as C(deln, x) = C(insn,u, x) = 1 and C(repn,u, v1, . . . , vN) = 1 if u 6= vn and 0 if u = vn for all n \u2208 N, x \u2208 X, u \u2208 A. In this case, the overall edit distance can be computed in O(N2) using a dynamic programming algorithm [24]. Note that \u2206 is reflexive and symmetric and C is non-negative, reflexive and symmetric. A small excerpt of the legal move graph of the string edit distance over the alphabet {a, b, c} is shown in Figure 4 (left). Here, the string \u201cab\u201d is connected to \u201cbb\u201d because there exists an edit \u03b4 \u2208 \u2206 which transforms \u201cab\u201d to \u201cbb\u201d, namely rep1,b. The reverse edit \u03b4\u22121 \u2208 \u2206 in this case is rep1,a. Similarly, \u201cab\u201d is connected to \u201cabc\u201d because ins3,c(ab) = abc and, inversely, del3(abc) = ab.\nOftentimes in intelligent tutoring systems, states have the form of trees, for example abstract syntax trees of computer programs [44]. For such data, the tree edit distance algorithm of Zhang and Shasha is a natural fit and has been applied in several contributions [7, 11, 30, 44]. Similarly to the string edit distance, the tree edit distance permits deletion, insertion and replacements of tree nodes, but the algorithm is more complex with O(N4) runtime [49]. An alternative has been suggested by Zimmerman et al. who compute an edit distance on pq-grams in trees, meaning small subtrees, which results in a considerably faster runtime of O(N \u00b7 log(N)) [50]. Mokbel et al.\nas well as Price et al. have suggested a two-level approach where student states are first decomposed into fragments which may be arbitrarily ordered and fragments are compared using a string edit distance [27, 40]. A very generic approach has been developed by Paa\u00dfen et al., who devised a generalpurpose O(N2) algorithm for string edit distances which supports a broad class of edit sets as well as edit cost functions and relies on the framework of algebraic dynamic programming [13, 32]. This approach has also been applied to abstract syntax trees by flattening the trees to sequences of code statements in order of their execution [32].\nNote that an edit distance is not alway guaranteed to correspond to the semantic distance between states. Consider the UML example in Figure 1 (left). The diagram could be changed, without affecting the computed function, by renaming the variable m to x, by replacing node 4 with \u201cinitialize z = \u22121\u201d, by replacing node 7 with z = 4 + 3 \u2212 7, or by introducing a node \u201cinitialize y = 4\u201d at some point in the graph. In principle, we can apply arbitrarily many edits to the graph in Figure 1 (left), without changing the computed function of the diagram at all. However, if we replace node 10 with \u201cReturn m\u201d, a rather subtle change, the computed function changes considerably. This can negatively impact the capability of a tutoring system to provide useful hints. Consider the hint policy of Zimmerman and Rupakheti mentioned above [50]. Due to an edit distance which over-emphasizes semantically irrelevant edits and underestimates the impact of subtle, but semantically important edits, a hint may be returned which is semantically irrelevant and does not help the student, while a more important edit, from a semantic perspective, may be ignored.\nOne approach to address this issue is canonicalization, which essentially transforms the raw states in X to a canonic form, such that semantically equivalent states have the same canonic form. The edit distance is then defined in the canonic forms, leading to a smaller legal move graph and edits which put stronger emphasis on semantically relevant changes. Canonicalization is particularly common in the domain of computer programs, where the order of binary relations (such as <) or variable names can be normalized or unreachable code can be removed [43]. Note that it may be ill-advised to compress the state set too drastically because it may render it impossible to distinguish between states that require different feedback. For example, tutoring systems for computer program often not only intend to teach functionally correct programming, but also programming style, such that important stylistic differences, even though functionally irrelevant, need to be preserved\nin the canonic form [35, 7]. Another challenge in canonicalization is that edits on the canonic form may not be interpretable to the user directly, such that these edits first need to be aligned with the student\u2019s code, a process that has been dubbed state reification [44].\nAn alternative approach is metric adaptation. Instead of mapping two semantically equivalent states x and y to the same canonic form, we could also lower the cost of edits which transform x to y [32]. This makes it possible to smoothly regulate the emphasis on semantics, style and syntax and keeps the original legal move graph intact, such that state reification is unnecessary. However, metric adaptation is limited by the neighborhood structure in the original legal move graph and thus can not easily map equivalent states which are far apart in the legal move graph to the same point. Overall, the most promising route may be to use (mild) canonicalization and metric adaptation in conjunction to achieve best results.\nIn summary, the concepts of edit set, legal move graph and edit distance permit us to define a hint policy that is mathematically optimal in the sense that each student will receive a hint which lies on the shortest path to a solution [50]. In order to provide such hints helpful we require an edit distance which roughly corresponds to the semantic distance between two states, but also takes important stylistic features into account. Yet, there are still possible scenarios where such a hint policy may produce low-quality hints from a pedagogic point of view, namely if the shortest path in the legal move graphs involves intermediate states which are counter-intuitive to students, that is, if the shortest path is one that no student would take. To find a path which takes student\u2019s preferences into account, we can utilize past student\u2019s data, which brings us to the notion of traces and interaction networks."}, {"heading": "2.2 Traces and Interaction Networks", "text": "In many cases, legal move graphs are infinite and contain many states which are absurd and highly unlikely to be visited by students. Interaction networks aim at capturing the subgraph which is likely to be relevant for feedback and dismiss the rest of the legal move graph. The relevant subgraph is approximated by analyzing a dataset of actual student activity on the learning task and keeping only the states and edits which have actually occurred. In other words, an interaction networks tries to approximate what students are likely to do by capturing what past students have done [9, 4].\nThe student data necessary to generate an interaction network has the\nform of traces. Inspired by Eagle et al., we define traces as follows [9]:\nDefinition 5 (Trace). Let X be a set of possible states for a learning task and \u2206 be an edit set on X. Then, a sequence x1, \u03b41, . . . , \u03b4T\u22121, xT where xt \u2208 X, \u03b4t \u2208 \u2206 and xt+1 = \u03b4t(xt) is called a trace.\nNote that this definition is not exactly equivalent to the one given by Eagle et al. In particular, they do not require actions to be deterministic, that is, in their framework the same action applied to the same state may lead to different subsequent states. We could generalize the notion of edits accordingly, re-defining them as probability distributions on subsequent states, but as almost all approaches in the literature frame edits as deterministic, we also employ a more simplistic, deterministic model here.\nThe interaction network corresponding to a dataset of traces is defined as follows:\nDefinition 6 (Interaction Network). Let X be a set of possible states for a learning task and \u2206 be an edit set onX. Further, let {(xi1, \u03b4i1, . . . , \u03b4iTi\u22121, x i Ti\n)}i=1,...,N be a set of traces. The interaction network corresponding to this set of traces is defined as the graph G = (V,E) where\nV = { xit \u2223\u2223\u2223i \u2208 {1, . . . , N}, t \u2208 {1, . . . , Ti}} (6) E = { (xit, x i t+1) \u2223\u2223\u2223i \u2208 {1, . . . , N}, t \u2208 {1, . . . , Ti \u2212 1}} (7)\nIdeally, \u2206 exactly corresponds to the edit set of the legal move graph, but there are many cases where this condition may not hold. For example, the edit sets might be different because students work on a different representation compared to the representation used to compute edit distances, for example due to canonicalization [43, 44]. Another reason may be that student\u2019s states may be recorded only at certain points in time (e.g. when they explicitly hit a \u201csave\u201d button) such that multiple actions may have been performed since the last recorded state. Finally, the concrete actions of a student may not even be available because the students work on the task offline and submit their current state only if they need help from the system. In these cases we have to assume that students may \u201cjump\u201d in the legal move graph from state to state and the exact path they have taken needs to be inferred by the system [36].\nConsider the example shown in Figure 2. On the left, we show three traces through a legal move graph. Note that students may leave out intermediate\nsteps in the legal move graph and \u201cjump\u201d directly toward a distant state. On the right we show the interaction network corresponding to the three traces on the right. Note that there are much fewer, and different, edges compared to the legal move graph. In particular, we now have a directed graph instead of an undirected one and the state x3 is not even part of the interaction network anymore.\nWe now have accumulated the necessary basic concepts to introduce the existing hint policies discussed in the literature, which is our next step."}, {"heading": "2.3 Hint policies", "text": "Recall the definition of a hint policy (Definition 2). We are referring to a function which outputs an edit for each possible input state. In the remainder of this section, we are going to provide a short review of the hint policies that have been suggested in the literature.\nThe arguably simplest policy is the one of Zimmerman et al. we introduced above, which always recommends the first edit on the shortest path to the closest solution [50]. Such an approach does not even require student data, except for at least one example of a solution. Rivers and Koedinger take a more advanced approach in their Intelligent Teaching Assistant for Programming (ITAP), an intelligent tutoring system for Python programming [44]. Their technique involves the following steps: First, they retrieve the closest solution according to the tree edit distance on canonic forms. Second, they use the edits which transform from the student state to the closest correct one to construct a path of intermediate states. Third, of these intermediate states, the one with the highest desirability score is selected for feedback, where the desirability score is a weighted sum of the frequency in past student data, the distance to the student\u2019s state, the number of successful test cases the state passes and the distance to the solution [44]. Finally, an inverse canonicalization (state reification) step is applied to infer edits that can be directly applied to the student\u2019s state to transform it to the selected state.\nBoth of these approaches have been part of a study by Piech et al. who compared several hint policies against expert recommendations on a largescale dataset consisting of over a million states from theHour of Code Massive Open Online Course (MOOC). The data was collected from two beginner\u2019s programming tasks in a block-based programming language. They found that the policy which agreed most with the recommendations of tutors was a so-\ncalled Poisson path policy, which recommends the first state on the shortestpath algorithm on a version of the legal move graph which weighted the edges according to the inverse frequency of the target state in the dataset, that is, \u03b2(x, x\u2032) := N/N(x\u2032) where N is the overall number of states submitted by successful students and N(x\u2032) is the number of times x\u2032 was submitted by successful students [36].\nInstead of recommending edits toward the closest solution, one can recommend edits toward the closest intermediate state on a trace leading to a solution. This is the approach of Gross and Pinkwart for supporting students learning Java programming in the JavaFIT system1. They distinguish between two types of help-seeking behavior, namely searching for errors or searching for a next-step. In both cases, they retrieve the closest state to the student\u2019s state in the interaction network. If students are trying to find an error in their code, the system recommends an edit leading the student toward this reference state, thereby attempting to correct the error. If students assume that their current state is correct, but they are looking for a next step, the system recommends an edit toward the successor of the reference state, thereby guiding the student closer to a solution [16]. This policy can be seen as an instance of case-based reasoning, where recommendations are based on a similar case from an underlying case base. Freeman et al. have taken this view to analyze Python programs and used a weighted tree edit distance to retrieve similar cases [11]. Also similar to case-based reasoning, Gross et al. proposed example-based feedback, in which the closest prototypical state in a dataset is retrieved and shown to the student to elicit self-reflection and sense-making in order to improve their own state [15].\nThe scheme of Lazar and Bratko takes a different approach by applying edits that have been frequent in past student traces to manipulate the current student\u2019s state until an edit is found that achieves better unit test scores [21].\nA final approach is the hint factory approach by Barnes et al. [5] They achieve an optimal hint policy in a precise probabilistic sense by modelling the multi-step learning task as a Markov Decision Process [46]. Their hint policy always returns the action which maximizes the expected future reward, where a reward is given whenever a student has achieved a solution. The model relies on an estimate of the transition probability distribution P (x\u2032|x, \u03b4) of moving to state x\u2032 if one has been in x and applied action \u03b4. The hint factory estimates this probability distribution based on transition frequencies in the\n1https://javafit.de/\ntrace data and therefore requires past student data to provide an accurate estimate.\nThe hint factory was originally created as a hint-generation add-on to the DeepThought instruction system for deductive logic [5]. Several studies have demonstrated that the hint factory reduces student dropout and helps students to complete more problems more efficiently [45, 8]. The hint factory has also been applied to further domains, such as the serious game BOTS [19] or the SNAP programming environment [39].\nA schematic overview of the different approaches is shown in Figure 3. The legal move graph for our example learning task is drawn in gray and semantically equivalent states which are canonicalized have the same gray background. We assume that the bottom left state is the initial state and that the top right state is the solution. Further, we assume that the edit set of our legal move graph corresponds to the student actions directly. As training data for the hint policies, the traces of three successful students (drawn in blue) are available. The trace of the new students who asks for help is shown in red. She does two edits on her own and then requests a hint from the system in the highlighted, red state. So which edit would be recommended by the different hint policies discussed above? The approach of Zimmerman and Rupakheti (Figure 3a) would just search the shortest path through the legal move graph to the solution and recommend the first edit on that path [50]. In our example, this could either be the arrow to the right or to the top right. The approach of Gross and Pinkwart (Figure 3b) would select the closest state in a previously seen trace and recommend an edit toward the successor in that trace, which would be the edit to the right [16]. Similarly, the hint factory (Figure 3b) would just have information for one trace in that state and thus would also recommend following this trace [5]. The Poisson hint policy of Piech et al. (Figure 3c) would search for the shortest path taking into account state frequency in the available trace data [36]. Therefore, the edit to the upper left would be recommended, even though it leads to a longer path and, in this case, takes the student back to a previous semantic equivalence class. Both the approach of Lazar and Bratko and the approach of Rivers and Koedinger take semantic equivalence into account by employing pre-defined tests. Only edits are recommended which extend the functionality of the previous state by achieving a higher test score [21, 44]. Further, Rivers and Koedinger explicitly apply canonicalization to reduce the size of the legal move graph, which would likely collapse some of the semantically equivalent states to a single point. Finally, Rivers and\nKoedinger also take into account state frequency to make a recommendation. In our example, it is likely that they would recommend a more distant state which ensures a change in terms of semantics, such as the one shown in the figure (Figure 3d).\nOur own approach can be seen as an extension of each of these approaches. We extend the work of Zimmerman and Rupakheti, Gross and Pinkwart, as well as Rivers and Koedinger in that we do not only utilize data from one single reference state but from several ones, which we merge in a probabilistic model. We extend the work of Lazar and Bratko in that our approach does not require unit tests to select a viable edit but follows the trajectory of past students. Our most important inspiration is the hint factory by Barnes et al., because we also attempt to build a probabilistic model that describes student behavior in solving a multi-step task to guide future student\u2019s behavior. We extend the hint factory, as well as the approach of Piech et al., because our approach does not require student states to be part of the interaction network. This key point warrants some further discussion.\nThe hint factory - as well as the approach of Piech et al. - can provide hints only for states that are part of the interaction network and for which a directed path to a solution in the interaction network exists. This has been dubbed the hintable subgraph [4]. In practice, students may very well find themselves in states which are not part of the hintable subgraph. Indeed, research has shown that for a reasonably small, open-ended programming task, over 90% of states are visited only once, indicating that future students will likely visit states that have not been seen before and may not even be connected to previously seen states in the legal move graph [37]; and the number of unique states remained high even after applying harsh canonicalization [37]. This also matches our own two datasets, where 97.23% and 82.79% of states were visited only once. So how can the hint factory be extended to situations be addressed were student data is sparse? A first approach has been proposed by Price et al., who suggested contextual tree decomposition (CTD) which generates interaction networks only for small modules in the student\u2019s state [38]. Due to the limited size of the modules the variability in student data is significantly reduced and is easier to cover with interaction networks corresponding to few traces. A challenge of this approach is that the system generates hints for each module, from which the student must select [40]. Our approach addresses this selection problem. However, we also take a different route to arrive at edits. We do not decompose the student states into smaller parts, but instead embed students\u2019 states into a continuous\nspace where a hint policy is easier to obtain. This embedding sets apart our approach from all other policies described here. The embedding is inspired by recent work of Paa\u00dfen et al. who proposed a prediction scheme for data that is given in terms of pairwise dissimilarities [33]. We extend this scheme by also providing a method to infer a recommended edit in the original space that corresponds to the recommended edit in the continuous space.\nWe note that there exists at least one embedding approach in the literature on intelligent tutoring systems, namely the approach of Piech et al. who proposed an embedding of computer programs via neural networks [35]. The embedding is computed by executing the programs on example data and recording the variable states P before executing a block of code A as well as the variable states Q after A has been executed. Both P and Q are embedded in a common space via a single-layer neural network, yielding the representations fP and fQ. Then, a matrix MA is constructed which maps fP to fQ, that is, MA is constructed such that fQ \u2248 MA \u00b7 fP . This matrix MA is the embedding of the code block A [35]. We extend this work in two ways: First, our approach does not need to explicitly compute a embedding but instead relies on an implicit embedding that is based on an edit distance. Therefore, we also do not not require execution data. Second, because our proposed embedding relies on the edit distance, it explicitly takes the compositional structure of the data into account. Finally, we provide a technique to interpret the predictive result in the continuous space as an actual, human-readable edit, which the Piech-approach lacks.\nIn summary, our proposed approach improves upon existing ones on at least one of two dimensions: First, it has fewer pre-conditions compared to many other approaches because it requires neither expert hints, nor unit tests, nor dense coverage of the legal move graph by past student data. It only requires an edit distance and some (but few) student traces. Second, it achieves a richer model compared to many other approaches, namely a probabilistic model of student behavior. In the next chapter, we introduce our proposed model in detail."}, {"heading": "3 Continuous Hint Factory", "text": "We define two goals for any hint generated by our hint policy. First, the hint should seem reasonable to the student requesting it; otherwise, the hint will likely be ignored [41]. We hypothesize that an action taken by other, students\nin the same situation should seem reasonable to the student requesting a hint. Therefore, creating a reasonable hint entails predicting the most likely edit that students will make in a given situation. Second, the hint should lead the student closer to a solution. To align these two goals, we recommend the most likely edit that has been taken by students who did end up in the solution. In addition to these two goals, we want the hint policy to be generalizable to other learning tasks and domains. Therefore, our policy requires no information about the states themselves, only a way to calculate the distance between them.\nA policy that would achieve our goals in densely populated state spaces is the hint factory [5]. Relying on the theoretical framework of reinforcement learning, the hint factory recommends the edit that is most likely to lead to a solution, given what other students have done in the same situation [5]. However, in sparsely populated state spaces, data of students in the same situation is likely not available. Therefore, we need to utilize data of students in similar situations. More precisely, we embed student data in a continuous space in which machine learning can help us to address questions of generalization and model performance in a precise, quantitative fashion. This scheme inspires the name of our method, the continuous hint factory.\nOur approach has three steps. First, we embed student data in a continuous space by means of an edit distance. Second, we develop a hint policy in this embedding space based on Gaussian process prediction for structured data [33]. This policy returns the most likely edit for a student in a given situation based on what successful students have done in similar situations However, the prediction has the form of a vector in the continuous space. Therefore, in a third step, we need to transform this vector into a humanreadable edit which can be used as a next-step hint. In the following sections, we discuss each of these three steps in turn."}, {"heading": "3.1 The Edit Distance Space", "text": "For our hint policy we require a continuous space in which past and present student data is embedded. In mathematical terms, this space should be an Euclidean vector space. A simple example of such an embedding is shown in Figure 4b. In this figure, the strings \u201cab\u201d, \u201caa\u201d, \u201caac\u201d, \u201cbb\u201d, and \u201cbbc\u201d are embedded in a two-dimensional space, namely the two dimensions of the paper. In this embedding, the Euclidean distance between the strings on the paper approximately corresponds to their edit distance, that is, strings with\nan edit distance of 2, such as \u201cab\u201d and \u201caac\u201d, are about twice as far away from each other on the paper compared to strings with an edit distance of 1, such as \u201cab\u201d and \u201caa\u201d. Also note that this embedding is not exact. For example, the distance on the paper between \u201cab\u201d and \u201cabc\u201d is much larger compared to the distance between \u201cab\u201d and \u201cbb\u201d, even though in both cases the edit distance is 1. So finding an embedding which permits an exact correspondence between Euclidean distance and edit distance is not trivial. Interestingly, though, we can guarantee that such an embedding exists if the edit distance fulfills some constraints:\nTheorem 1 (Latent Distance Space). Let X be some finite set and d : X \u00d7 X \u2192 R be a function such that for all x, y \u2208 X it holds: d(x, x) = 0, d(x, y) \u2265 0 and d(x, y) = d(y, x). Then, there exists a vector space Y \u2282 Rs for some s \u2208 N and a mapping \u03c6 : X \u2192 Y, such that for all x, y \u2208 X:\nd(x, y)2 = (\u03c6(x)\u2212 \u03c6(y))T \u00b7 \u039b \u00b7 (\u03c6(x)\u2212 \u03c6(y)) (8)\nwhere \u039b is a diagonal matrix with entries in {\u22121, 0, 1}.\nProof. Refer to [17, 34].\nNote that if \u039b has no negative entries, d corresponds to the Euclidean distance in the embedding space. Otherwise, there exist points in the latent vector space Y for which the pairwise distance becomes negative, which may cause errors in subsequent processing. These negative entries can be avoided by eigenvalue correction techniques. Such techniques convert the matrix of pairwise distances to a matrix of pairwise similarities, decompose this matrix into its Eigenvectors and Eigenvalues, then sets the Eigenvalues to non-negative values and convert the resulting similarity matrix back to a matrix of pairwise distances [14]. Note that this correction is an approximation and does distort the distances, but only to the extent to which negative Eigenvalues are present.\nAlso note that the dimensions of Y have no inherent meaning. The dimensions are only relevant in that we can fulfill a higher number of distance constraints in a higher-dimensional space. For an intuition, consider the example shown in Figure 4b. To construct our embedding, we start with the strings \u201cab\u201d, \u201caa\u201d, and \u201cbb\u201d. The edit distance between \u201cab\u201d and \u201caa\u201d as well as \u201cbb\u201d is 1, while the edit distance between \u201caa\u201d and \u201cbb\u201d is 2. We can embed the strings by arbitrarily fixing the location of \u201cab\u201d to 0 and then\nsetting the location of \u201caa\u201d and \u201cab\u201d, such that the distance constraints are fulfilled. A one-dimensional solution for this problem is to assign the location \u22121 to \u201caa\u201d and 1 to \u201cbb\u201d. However, we could equally well rotate our solution, for example by 180\u25e6, or shift all positions by any real number to achieve an equally valid embedding. So neither rotation or absolute location in our embedded space are interpretable, just the pairwise Euclidean distances are meaningful. Further, if we also wish to embed the strings \u201caac\u201d and \u201cbbc\u201d, we notice that one dimension is not sufficient anymore. Many of the distance constraints can be fulfilled by assigning the position \u22122 to \u201caac\u201d and 2 to \u201cbbc\u201d, but then the Euclidean distance between \u201caac\u201d and \u201cbbc\u201d is 4, while the edit distance is only 2. Therefore, we must increase the number of dimensions to fulfill our additional constraints. Indeed, even in two dimensions we can only approximately fulfil the constraints, as is visible in Figure 4b. Yet, our theorem shows that there is always some number of dimensions, for which an exact embedding is possible, and with the help of Eigenvalue correction we can make this embedding Euclidean. Based on this embedding, we can prove the main theorem of our work, namely the existence of an edit distance space:\nTheorem 2 (Edit Distance Space). Let X be some finite set of past and present student data, let \u2206 be a reflexive and symmetric edit set on X and let C : \u2206 \u00d7 X \u2192 R be a non-negative, reflexive and symmetric edit cost function on \u2206. Further, let D be the eigenvalue-corrected version (via clip) of the matrix with entries Dij = d\u2206,C(xi, xj) for all xi, xj \u2208 X.\nThen there exists a vector space Y = Rs, for some s \u2208 N which we call the edit distance space for d\u2206,C; and there exists a mapping \u03c6 : X \u2192 Y, such that for all x, y \u2208 X it holds: \u2016\u03c6(x) \u2212 \u03c6(y)\u201622 = D(x, y), i.e. the Euclidean distance in Y corresponds to d, up to Eigenvalue correction.\nProof. We first show that, under our constraints on \u2206 and C, the resulting edit distance d\u2206,C fulfills the constraints of theorem 1.\nd\u2206,C(x, y) \u2265 0: If x and y are connected in the legal move graph, d\u2206,C(x, y) is a sum of non-negative contributions (because C is non-negative), and thus d\u2206,C(x, y) \u2265 0. Otherwise d\u2206,C(x, y) =\u221e > 0.\nd\u2206,C(x, x) = 0: Because \u2206 and C are reflexive we know that for all states x \u2208 X there is an edit \u03b4 \u2208 \u2206, such that \u03b4(x) = x and C(\u03b4, x) = 0. Therefore it holds: d\u2206,C(x, x) \u2264 C(\u03b4, x) = 0. Because we have already\nshown that the edit distance is non-negative, we know that d\u2206,C(x, x) = 0\nd\u2206,C(x, y) = d\u2206,C(y, x): Let x, y \u2208 X such that x and y are connected in the legal move graph. Let \u03b41, . . . , \u03b4T be a sequence of edits that transforms x to y such that the cost is minimal. Because \u2206 is symmetric we can construct the sequence of edits \u03b4\u22121T , . . . , \u03b4 \u22121 1 which transforms y to x.\nBecause C is symmetric we know that the cost of this path is equal to the cost of \u03b41, . . . , \u03b4T , which in turn implies d\u2206,C(x, y) \u2265 d\u2206,C(y, x). We can do the same argument in the other direction (from y to x), such that d\u2206,C(x, y) \u2264 d\u2206,C(y, x), which implies d\u2206,C(x, y) = d\u2206,C(y, x). If there is no path from x to y in the legal move graph, then there is also no path from y to x and it holds d\u2206,C(x, y) =\u221e = d\u2206,C(y, x).\nTheorem 1 now yields the required embedding. Because of eigenvalue correction, this embedding is Euclidean.\nIn our approach, we will make extensive use of the edit distance space. In particular, we replace the problem of finding a hint policy for the original edit set of the edit distance by finding a hint policy in the edit distance space."}, {"heading": "3.2 A Hint Policy in the Edit Distance Space", "text": "Due to theorem 2 we know that, for a reasonably constrained edit distance d\u2206,C , there exists an embedding in a vector space Y \u2282 Rs, such that the edit distance corresponds to the Euclidean distance in Y after Eigenvalue correction. The main advantage of the edit distance space Y is that constructing a hint policy for vectors is much easier compared to a hint policy for arbitrarily complicated states. More precisely, we replace the problem of constructing a hint policy \u03c0 : X \u2192 \u2206 with the problem of constructing a hint policy \u03c0 : Y \u2192 \u2206Y , where \u2206Y is an edit set in the edit distance space, which we define as follows.\n\u2206Y = {\u03b4~\u03be|~\u03be \u2208 Y} where \u2200~\u03c6 \u2208 Y : \u03b4~\u03be(~\u03c6) = ~\u03c6+ ~\u03be and CY(\u03b4~\u03be, ~\u03c6) = \u2016~\u03be\u2016 (9) In other words: There is an edit \u03b4~\u03be for every vector ~\u03be in the edit distance space Y and the edit \u03b4~\u03be just adds ~\u03be to its input, that is, for all vectors ~\u03c6 in the edit distance space Y we define: \u03b4~\u03be(~\u03c6) = ~\u03c6 + ~\u03be. The cost C of \u03b4~\u03be is just\nthe length of ~\u03be, that is, for all vectors ~\u03c6 and ~\u03be in the edit distance space Y , we define: CY(\u03b4~\u03be, ~\u03c6) = \u2016~\u03be\u2016. It is easy to show that the corresponding edit distance d\u2206Y ,CY is the Euclidean distance in Y : Recall that the edit distance is defined as the length of the shortest path in the legal move graph if the edges are weighted according to the edit cost function (refer to equation 1). For any two points ~x and ~y in Y there exists the edit \u03b4~y\u2212~x \u2208 \u2206Y . The cost of that edit is precisely \u2016~y \u2212 ~x\u2016 which is the Euclidean distance between y and x. Because of the triangular inequality we can guarantee that there is no sequence of edits with a lower cost than that, which concludes the proof.\nNow, recall that theorem 2 tells us that the original edit distance is also equal to the Euclidean distance in Y (up to Eigenvalue correction), so we can conclude that for all x, y \u2208 X the original edit distance d\u2206,C and the edit distance in the edit distance space d\u2206Y ,CY are equal, up to Eigenvalue correction. Therefore, we can approximate the problem of inferring a hint policy for \u2206 with a hint policy for \u2206Y .\nRecall that we wish to construct a policy which recommends the most likely edit according to what successful students have done in the past. However, even successful students may have taken detours on their path toward a solution. To get rid of these detours in our trace data, we introduce the following distance-based heuristic. Let x1, . . . , xT be the states in a student trace and let d\u2206,C be our edit distance. Then, for all t \u2208 {1, . . . , T \u2212 1} we look for t\u2032 \u2208 {t + 2, T} such that d(xt, xt\u2032) \u2264 d(xt, xt+1). In such a case, the student has returned to a previous state (namely to xt) after trying the states\nxt+1, . . . , xt\u2032\u22121. Thus, we can shorten the trace to x1, . . . , xt, xt\u2032 , . . . , xT (see Figure 5).\nAfter this pre-processing step, we can start our edit prediction mechanism. We denote a state in our trace dataset as xi and the next step after it with yi. If xdataidx is the end point of a trace, then yi = xi. Now, we intend to construct a hint policy in the edit distance space which can predict the vector ~\u03bei := \u03c6(yi) \u2212 \u03c6(xi) for all points \u03c6(xi). In machine learning terms, this is a regression problem. The simplest approach to this problem would be 1-nearest neighbor regression, which looks for the closest data point in the database and returns the edit that has been done for that point, that is, \u03c01NN(\u03c6(x)) = ~\u03bei where d(x, xi) is minimal. This is equivalent to the policy of Gross and Pinkwart [16], which we will use as baseline. Unfortunately, such a policy necessarily has difficulty to optimally exploit the knowledge encoded in past student data, because it can only use the edit of one student at a time. To integrate the edits of multiple students in a probabilistically optimal fashion, we turn to Gaussian Process Regression (GPR) for structured data [33]. To apply this technique, we need just one more ingredient, which is a kernel function. For an exact definition of kernel functions for GPR we point to the work of Rasmussen and Williams [42]. For our purposes here it suffices to describe a kernel function as a measure of similarity. In particular, we use the radial basis function (RBF) kernel, which is defined as: k\u03c8,d(x, y) = exp(\u22120.5 \u00b7 d(x,y) 2\n\u03c82 ) [42]. The RBF kernel measures similarity by assigning a\nvalue of 1 for a distance of 0 and assigns lower values for higher distance, quickly approaching 0. \u03c8 is a hyper-parameter called length-scale which controls the distance value at which k\u03c8,d reaches its maximum slope (see Figure 6).\nLet now ~k(x) be the row vector of kernel values k(x, xi) for all i = 1, . . . ,M and letK be the matrix of pairwise kernel values k(xi, xi\u2032) for all i = 1, . . . ,M and i\u2032 = 1, . . . ,M . Further, let X be the matrix of all embedded states \u03c6(xi) as rows and let Y be the matrix of all embedded states \u03c6(yi) as rows. Note that we will not compute these embeddings explicitly. We will show later that our approach works without these explicit reference to the embedded states. Then, for the point \u03c6(x), GPR yields a Gaussian probability distribution for the edit ~\u03be with mean ~\u00b5(x) and covariance matrix \u03c32(x) \u00b7 Is, where Is is the M \u00d7M -dimensional identity matrix (a matrix of zeros with ones on the diagonal). The mean ~\u00b5(x) and variance \u03c32(x) can be computed as follows\n[33].\n~\u00b5(x) = ~k(x) \u00b7 ( K + \u03c3\u03032 \u00b7 IM )\u22121 \u00b7 ( Y \u2212X ) and (10)\n\u03c32(x) = k(x, x)\u2212 ~k(x) \u00b7 (K + \u03c3\u03032 \u00b7 IM)\u22121 \u00b7 ~k(x) T\n(11)\nwhere \u03c3\u0303 is a hyper-parameter which quantifies the assumed amount of noise in our data. Increasing this parameter makes GPR less accurate, but more robust and numerically stable. Note that the matrix Y \u2212X contains the edits that have occured in our trace data; in particular, the ith row of this matrix contains exactly the vector ~\u03bei = \u03c6(yi)\u2212 \u03c6(xi).\nOur hint policy now recommends the edit with the highest probability. For a Gaussian probability distribution, this is always the mean, that is, we set \u03c0GPR(x) := ~\u00b5(x) for all x \u2208 X. Thanks to GPR, this policy has several desirable properties which we want to highlight here. First, if x = xi for some state xi in the trace data, then ~k(x) equals the ith column in the matrix K. The product ~k(x) \u00b7K\u22121 is then equal to a vector of zeros which is only one at position i. So for \u03c3\u0303 = 0, the policy will return exactly the vector ~\u03bei. Further, if x is far away from all states in the trace data, the vector ~k(x)\nwill be a approximately a zero vector and thus the prediction will be zero as well. So the policy gracefully degrades and recommends to do nothing if our example data is uninformative. For all other cases, the GPR hint policy combines the edits in the trace data in a linear fashion, which becomes clear if we re-write: \u03c0GPR(x) = \u2211M i=1 \u03b1i(x) \u00b7 ~\u03bei where ~\u03b1(x) = ~k(x) \u00b7 (K + \u03c3\u03032 \u00b7 IM)\u22121. In this view, \u03b1i(x) can be interpreted as the weight or importance of state i to state x. In other words, if \u03b1i(x) is positive, then you can improve x by going in the direction of xi; if \u03b1i(x) is 0, then xi is irrelevant; and if \u03b1i(x) is negative, then you can improve x by going away from xi. We can also represent the recommendations of the nearest-neighbor policy in this way, by assigning a weight of \u22121 to the nearest neighbor xi and a weight of 1 to the successor yi. This alternative representation also makes obvious that our recommended edit can be represented in terms of linear coefficients ~\u03b1(x) instead of an explicit vector in the edit distance space. In our actual implementation, we will exclusively use this representation via coefficients and will avoid computing the embedding \u03c6 for any data points.\nAs an example for our hint policy, consider the string edit distance example shown in Figure 4b. Note that the string edit distances are: d\u2206,C(x, x1) = d\u2206,C(x, x2) = 1 and d\u2206,C(x1, x2) = d\u2206,C(x2, x1) = 2. For the length scale \u03c8 = 0.5 and a noise variance \u03c3\u03032 = 0 we obtain the kernel vector ~k(x) =\n( 1\u221a e , 1\u221a e ), the kernel matrix K =\n( 1 1\ne2 1 e2 1\n) and the coefficient vector ~\u03b1(x) =\n~k(x) \u00b7K\u22121 \u2248 (1 2 , 1 2 ). Thus, the recommended edit (dashed, orange arrow) is \u03c0GPR(x) \u2248 12 \u00b7 ~\u03be1 + 1 2 \u00b7 ~\u03be2, that is, the average of ~\u03be1 = \u03c6(y1)\u2212\u03c6(x1) (blue arrow on the top) and ~\u03be2 = \u03c6(y2)\u2212 \u03c6(x2) (blue arrow at the bottom). Via the hint policy \u03c0GPR we can now recommend edits in the edit distance space which are optimal according to a Gaussian Process model. However, this edit has the form of a vector in the edit distance space, or equivalently a coefficient vector ~\u03b1(x), neither of which is directly interpretable by a student. So our last challenge is to derive a viable hint from our prediction in the edit distance space. More precisely, we wish to obtain an edit in our original edit set \u2206 which corresponds to the recommended edit in the edit distance space."}, {"heading": "3.3 Edit pre-image problems", "text": "The problem of finding an original object which maps to a known point in an embedding space is called a pre-image problem [3], so the problem of finding\nthe edit which best corresponds to a recommended edit in the edit distance space can be described as an edit pre-image problem. We want to emphasize here that such pre-image problems are typically hard to solve [3] and, to our knowledge, no approach exists to date which addresses the edit pre-image problem. In this section, we provide an approximation for this problem\nFirst, following Bakir et al., we re-frame our edit pre-image problem as a minimization problem: Starting from the student\u2019s current state x, we try to find the edit \u03b4 which brings us closest to the recommended state by Gaussian process regression (GPR) in the edit distance space:\nmin \u03b4\u2208\u2206 \u2016\u03c6 ( \u03b4(x)\u03c6 ) \u2212 ( \u03c6(x) + \u03c0GPR(x) ) \u20162 (12)\nA naive approach for this problem would be to just try out all possible edits \u03b4 \u2208 \u2206, compute the embedding \u03c6 ( \u03b4(x)\u03c6 ) , then compute the distance\n\u2016\u03c6 ( \u03b4(x)\u03c6 ) \u2212 ( \u03c6(x) +\u03c0GPR(x) ) \u20162 and afterwards take the edit \u03b4 for which the distance is minimal. The first thing we can improve is to avoid computing the explicit embedding \u03c6 ( \u03b4(x)\u03c6 ) , by re-writing our minimization problem in a simpler form:\nTheorem 3. Let ~\u03b1 be the weights applied by GPR, that is ~\u03b1 = ~k(x) \u00b7 (K + \u03c3\u03032 \u00b7 IM)\u22121. Then, the maximization problem in 12 can be re-written as:\nmin \u03b4\u2208\u2206\nd\u2206,C(\u03b4(x), x) 2 + M\u2211 i=1 \u03b1i \u00b7 d\u2206,C(\u03b4(x), xi)2 (13)\nProof. To keep this rather technical proof brief, we point to theorems 3 and 4 in the paper of Paa\u00dfen et al., which show that we are permitted to re-write the the distance in 12 as:\nmin \u03b4\u2208\u2206 \u2016\u03c6(\u03b4(x))\u2212 \u03c6(x))\u20162 + M\u2211 i=1 \u03b1i \u00b7 \u2016\u03c6 ( \u03b4(x) ) \u2212 \u03c6 ( xi ) \u20162 \u2212 Z (14)\nwhere Z is some constant that does not depend on \u03b4 [33]. Due to theorem 2 we know that the Euclidean distance in the edit distance space corresponds exactly to the edit distance, which concludes the proof.\nThis result lets us re-interpret our minimization problem: We want to find an edit which brings us closer to states that have been weighted positively by GPR and brings us away from states that have been weighted negatively by\nGPR. In a revised approach we could try out all edits \u03b4 \u2208 \u2206, compute the edit distances d\u2206,C(\u03b4(x), xi) and d\u2206,C(\u03b4(x), x), and then determine the optimal edit according to 13. Still, there are two challenges left: First, the edit set \u2206 is typically very large or even infinite. This issue can be addressed by only considering edits which are part of the cheapest edit sequence \u03b41, . . . , \u03b4T that transforms x to a state xi which has a positive weight \u03b1i. Second, computing the edit distances d\u2206,C(\u03b4(x), xi) for all edits is costly. Fortunately, we can approximate these edit distances such that we can avoid the explicit edit distance computation.\nTheorem 4. Let C be such that for all x \u2208 X and \u03b4 \u2208 \u2206 it holds: d\u2206,C(x, \u03b4(x)) = C(\u03b4, x), that is, it is always cheaper to use a single edit instead of multiple edits. Then problem 13 can be approximated by:\nmin \u03b4\u2208\u2206 C(\u03b4, x)2 + M\u2211 i=1 \u03b1i \u00b7 ( d(x, xi) + C\u0303i )2 (15) where C\u0303i is \u2212C(\u03b4, x) if \u03b4 = \u03b41 for the cheapest hint sequence \u03b41, . . . , \u03b4T that transforms x to xi, and C ( \u03b4\u22121, \u03b4(x) ) otherwise.\nProof. Consider two cases: If \u03b4 = \u03b41 for the cheapest hint sequence \u03b41, . . . , \u03b4T that transforms x to xi, then \u03b42, . . . , \u03b4T transforms \u03b4(x) to xi and has the cost d\u2206,C(x, xi)\u2212 C(\u03b4, x) = d\u2206,C(\u03b4(x), xi).\nOtherwise we can construct a path from \u03b4(x) to xi via the edit sequence \u03b4\u22121, \u03b41, . . . , \u03b4T where \u03b4\u22121 is the inverse edit for \u03b4 in state x. This path has the cost d\u2206,C(x, xi) + C ( \u03b4\u22121, \u03b4(x) ) which constutes an upper bound for d\u2206,C(\u03b4(x), xi). Our overall approximation is d\u2206,C(\u03b4(x), xi) \u2248 d\u2206,C(x, xi) + C\u0303i where C\u0303i is \u2212C(\u03b4, x) if \u03b4 = \u03b41 and C ( \u03b4\u22121, \u03b4(x) ) otherwise.\nIn our experiment, we use an even tighter approximation for the case of the string edit distance. Recall that a string edit distance permits deletion, insertion and replacement operations at each position in the string (also refer to equation 2 above). If \u03b4 is a replacement operation, that is, \u03b4 = repn,u for some position n and some character u, and if \u03b41 . . . \u03b4T is the cheapest edit script transforming x to xi which contains an edit of the form \u03b4t = repn,v for some character v, then we can transform \u03b4(x) to xi by just applying the edits \u03b41 . . . \u03b4T , which now replace u with v, which is as most as expensive as the edit sequence \u03b4\u22121\u03b41 . . . \u03b4T . Similar arguments are possible for other\ncombinations of edits as well, but we omit the detailed discussion here for the sake of brevity.\nOur pre-image search mechanism is illustrated in Figure 4c. Recall that the weights of GPR for our states are \u03b1x1 = \u03b1x2 \u2248 \u221212 and \u03b1y1 = \u03b1y1 \u2248 1 2 . So we need to find an edit which brings us closer to y1 = aac and y2 = bbc but further away from x1 = aa and x2 = bb. The edits rep2,a and ins3,c bring us closer to y1 and the edits rep1,b and ins3,c bring us closer to y2. We now try each of those edits in turn. Applying rep2,a results in rep2,a(ab) = aa, and we obtain C\u0303x1 = C\u0303y1 = \u2212C(rep2,a, ab) = \u22121, as well as C\u0303x2 = C\u0303y2 = C(rep2,b, aa) = 1, which leads us to a value of 12 \u2212 12(1 \u2212 1)2 + 1\n2 (2\u2212 1)2 \u2212 1 2 (1 + 1)2 + 1 2 (2 + 1)2 = 4 according to 15. Applying rep1,b\nalso leads to a value of 4 for symmetry reasons. Applying ins3,c results in ins3,c(ab) = abc, and we obtain C\u0303x1 = C\u0303x2 = C(del3, abc) = 1, as well as C\u0303y1 = C\u0303y2 = \u2212C(ins3,c, ab) = \u22121, which leads us to a value of 12 \u2212 12(1 + 1)2 + 1\n2 (2\u2212 1)2 \u2212 1 2 (1 + 1)2 + 1 2 (2\u2212 1)2 = \u22122 according to 15. Therefore, we\nwould select the edit ins3,c. Note that we would not have obtained the same result for the one-nearestneighbor policy. In this case, all three edits, rep2,a, rep1,b, and ins3,c would have appeared equally valid because we only utilize the information contained in one other trace and do not combine information from different traces. This is the main advantage of our approach above existing approaches: By means of a continuous embedding and Gaussian process regression for structured data, we are able to integrate the edits of multiple past students in a probabilistic compromise. As such, our approach combines approaches for dense state spaces with approaches for vast and sparsely populated solution spaces, namely a probabilistic model, similar to the hint factory [5], and the nearestneighbor principle as used by Rivers and Koedinger [44], Zimmerman and Rupakheti [50], as well as Gross and Pinkwart [16]. For students, this means that they will receive hints that reflect the collective understanding of many capable students instead of that try to follow the nearest student in detail, including all eccentricities of her approach. This concludes our description of the continuous hint factory. In the next section, we evaluate the continuous hint factory on real-world data."}, {"heading": "4 Experiments", "text": "In our experiments, we investigate two research questions:\nRQ1: How well does the Gaussian Process model capture the behavior of capable students, that is, can the Gaussian process predict what a capable student would do?\nRQ2: Do the hints of the Continuous Hint Factory correspond to the hints of human tutors?"}, {"heading": "4.1 Modelling Student Behavior", "text": "For RQ1, we considered data which is inherently challenging to predict, namely data from an open-ended programming task, collected in an introductory undergraduate computing course for non-computer science majors during the Fall of 2015 at a research university in the south-eastern United States. The course had approximately 80 students, split among six lab sections. The first half of the course focused on learning the Snap2 programming language through a curriculum based on the Beauty and Joy of Computing [12]. Here, we focus on the \u201cGuessing Game\u201d task, which had the following description: \u201cThe computer chooses a random number between 1 and 10 and continuously asks the user to guess the number until they guess correctly.\u201d Students did not receive specific instructions regarding the form of the program. A sample state is presented in Figure 7a. Students worked on this assignment during class for approximately one hour, with a Teaching Assistant (TA) available to assist them and the option of working in pairs. The class was conducted as normal, and the students were not informed that data was being collected. A state of the student\u2019s program was recorded after every edit. Students who did not correctly select the assignment they were working on were excluded from the analysis. The dataset consists of 52 traces with 8669 states overall.\nEach of the final states was graded by two independent graders. The graders used a rubric consisting of nine assignment objectives and marked whether each state successfully or unsuccessfully completed each objective. The graders had an initial agreement of 94.5%, with Cohen\u2019s \u03ba = 0.544. After clarifying objective criteria, each grader independently regraded each state where there was disagreement, reaching an agreement of 98.1%, with Cohen\u2019s \u03ba = 0.856. Any remaining disagreements were discussed to create final grades for each assignment. As our aim is to predict what capable\n2http://snap.berkeley.edu\nstudents would do, we kept only traces which successfully completed at least eight of the nine objectives. This left 47 traces with 7864 states.\nAs an edit distance, we employed a string edit distance on the sequence of syntactic building blocks of Snap programs. The building blocks were annotated by their label (e.g. \u201cdoIf\u201d, \u201cvar\u201d, \u201cliteral\u201d) as well as their relative depth in the abstract syntax tree(s) (0 for each root node and 1 for the deepest nodes in the AST). The edit costs were set to 1 for deletion and insertion operations and to 1\n2 \u00b7 (Clabel + |depth \u2212 depth\u2032|) for replacement operations\nwhere Clabel is 0 if the labels of the node before and after replacement agree and 1 if they do not, and \u201cdepth\u201d and \u201cdepth\u2019 \u201d are the depth of the node before and after replacement respectively. The edit distance was computed using the TCS Alignment Toolbox [31]. First, we computed the pairwise edit\ndistances inside traces and applied the cycle detection mechanism, which left 2066 states. For these 2066 remaining states, we computed all pairwise edit distances and applied Eigenvalue correction with the clip method as suggested by Gisbrecht et al. [14]. Note that of the 2066 remaining states, 1875 were unique according to our edit distance, and of these, 97.23% were visited only once. The lack of overlap in this dataset is also visible in the 2-dimensional embedding of the dataset in Figure 7b. Due to this lack of overlap, frequency-based models such as required by the hint factory are difficult to construct, which motivates the use of our method.\nIn our experiment we iterated over all 47 traces and, for all states xt within the current trace, applied the GPR hint policy \u03c0GPR using the remaining 46 traces as training data 3. We selected the length scale \u03c8 and the noise parameter \u03c3\u0303 via random search as suggested by Bergstra and Bengio [6]. For the recommended next state \u03c6(xt) + \u03c0GPR(xt) in the edit distance space we computed two evaluation measures: first, the squared Euclidean distance in the edit distance space between the recommended next state \u03c6(xt)+\u03c0GPR(xt) and the actual next state \u03c6(xt+1) of the student. This measure indicates how well we can predict what a capable student will do based on what other capable students have done. Second, we computed the squared Euclidean distance in the edit distance space between the recommended next state \u03c6(xt)+\u03c0GPR(xt) and the final state xT of the student. This measure indicates how close the recommended edit brings us to a solution if the task, that is, it tells us if following the path of capable students does actually bring us closer to a solution. Note that this measure is included for overview purposes and does not address our research question RQ1 directly. We average both evaluation measures over the trace and take the root, which is then called the root mean square error (RMSE).\nWe compare the GPR hint policy with three other hint policies: First, a simple baseline of always recommending to do nothing; second, the policy of Gross et al. which recommends the successor of the next student state in the data base, which is essentially a one-nearest-neighbor hint policy [16]; third, the hint policy of Zimmerman and Rupakheti, which recommends the closest solution, meaning the closest end point in one of the other 46 traces [50]. Note that we do use a different distance measure than Zimmerman and Rupakheti. Their proposed policy may very well work better with the\n3Our implementation of the GPR hint policy is available under the DOI 10.4119/unibi/2913104\npq-gram tree distance, but in the interest of a fair comparison we applied all hint policies based on the same distance measure.\nTable 1 shows the mean RMSEs and their standard deviation across all 47 traces. We see that our proposed Gaussian process hint policy has lower RMSE in predicting the next step compared to all other policies. This differences are highly significant (p < 10\u22123 in a signed Wilcoxon rank-sum test after Bonferroni correction). In bringing students closer to a solution, the Gaussian process hint policy does better than the baseline and the one-nearest-neighbor policy of Gross and Pinkwart (p < 10\u22123 in a signed Wilcoxon rank-sum test after Bonferroni correction), but is outperformed by the policy of Zimmerman and Rupakheti. This is not surprising given that the sole purpose of the latter policy is to find the fastest route toward a solution, while our own policy also attempts to find a way that follows what other students have done, which may result in better hint quality as we will see in the next experiment.\nNote that we have not compared GPR with more intricate policies, because these have requirements which are not fulfilled by our setup: The hint factory as well as the Poisson path policy by Piech et al. rely on overlap between traces to achieve meaningful approximations of their underlying probability distributions [5, 36]. However, in this dataset, overlap is rare. Further, we do not have unit tests at our disposal, which prevented us from applying the policies of Rivers and Koedinger or Lazar and Bratko [21, 44]. We emphasize that we do not make any claim that our method would be better in settings where these alternative policies are applicable. We just try\nto investigate whether we can improve the state-of-the-art in settings where student data is very sparse in comparison to the size of the state space and auxiliary information, such as unit tests, are not available."}, {"heading": "4.2 Hint Quality", "text": "To investigate RQ2, we require an objective measure of hint quality. We chose to compare the hints provided by the system to hints provided by human tutors, similar to Price et al. [40]. We utilized data collected in a beginner\u2019s programming course for computer scientists at a German university in 2012. The students were faced with the task to draw a UML activity diagram which described the process of adding two binary numbers (see Figure 8). From the student states we extracted six typical strategies that occurred in the states and manually created two correct and one erroneous trace for each strategy. We presented each state in the erroneous traces to three tutors who independently were asked to suggest all possible edit hints that could be given to a student in the particular situation, taking past states into account. They also were asked to grade their hints with a real value in the interval [0, 1] indicating hint quality, taking into account the following criteria: 1) Does the hint follow the strategy of the student? 2) Does the hint conform to the student\u2019s current focus of attention or does it address a different part of the state? 3) Is the hint effective in addressing the problems in the student\u2019s state? 4) Is the hint effective in guiding the student toward a solution? In a second meeting, all tutors met to add ratings for the hints of the other tutors and to address discrepancies in the ratings. If after discussion at least one expert rated a hint with a grade below 0.5, the hint was excluded from the set. Overall, the dataset consisted of 12 correct traces with a total of 364 states and 6 erroneous traces with a total of 115 states with a total of 1053 hints. The average inter-rater correlation via Pearson\u2019s r was r = 0.588, indicating moderate agreement. This dataset is available on-line under the DOI 10.4119/unibi/2913083.\nAs in the first experiment, we relied on a variation of the string edit distance which we computed on strings of edges and nodes in the UML diagrams. We generated the strings by ordering the nodes and edges of the UML diagrams according to their execution sequence and concatenated different branches after a fork or decision node in the diagram. We defined the edit cost as 1 for insertions of deletions, as\u221e for replacements between nodes of different types (to prevent the string edit distance from replacing nodes\nwith different types), as 0 for replacements between nodes of the same type, except for actions. For subsequent actions, we also permitted re-orderings and defined the edit costs between replacements of actions with different text as 1 and with the same text as 0. Note that we applied canonicalization in this dataset: We normalized the order of binary comparisons, as well as the order of branches after decision nodes, and we made our edit distance invariant against ordering changes in subsequent actions. Despite this canonicalization, there were 215 unique states in the training dataset of 364 states and of these, 82.79% were visited only once.\nIn our experiment, we let the continuous hint factory (CHF) recommend an edit hint for each erroneous state and compared it with the hints recommended by tutors. If the recommended hint of the CHF matched at least one tutor hint, we graded the CHF hint with the average rating of the tutors for this hint, otherwise the rating was set to 0. In comparing system hints with the hints of tutors, we roughly follow the evaluation scheme suggested by Price et al. [40]. Again, we compare our system with the policy of Gross and Pinkwart [16] and the policy of Zimmerman and Rupakheti [50]. For all these policies we excluded hints that just deleted nodes in the diagram, because we regard deletions as less informative in that they just provide negative feedback to the student without a constructive counter-proposal. If a policy rated multiple hints as optimal, we chose the hint that changed the most recently added node in the student\u2019s diagram.\nAs a worst-case baseline we also report hints that were generated by selecting a random reference state from the data base (\u201crandom\u201d) and always recommending the best human-crafted hint (\u201ctutor\u201d).\nThe experimental results are shown in table 2. We report the median rating for the hints, the mean rating, the standard deviation in ratings, the fraction of ratings with a rating > 0.5, the root mean square error (RMSE) with respect to the closest tutor hint and the fraction of states for which the policy returned a hint that was not a deletion. Note that the number of independent samples (6) is too low for meaningful statistical tests. Even though we describe the results in terms of \u201cbetter\u201d or \u201cworse\u201d, these descriptions do not imply statistical significant differences.\nAs one would expect, all other policies appear to perform considerably better than the random policy. We also note that our proposed Gaussian process policy and the policy of Gross and Pinkwart perform better compared to the policy of Zimmerman and Rupakheti in terms of median and mean hint quality, fraction of hints with quality > 0.5 and RMSE. However, the\npolicy of Zimmerman and Rupakheti was able to provide hints in all cases, which is neither the case for the policy of Gross and Pinkwart nor for our proposed one. The reason is that we excluded edits which would just delete parts of the student\u2019s state without providing a counter-proposal. The differences between our proposed policy and the policy by Gross and Pinkwart are minor, except for the RMSE, which is considerably lower for the Gaussian process policy, indicating that hints of our proposed policy are close to tutor-crafted hints in the edit distance space, but due to Eigenvalue correction and approximations in the pre-image finding scheme, this advantage in quality may get lost. We also note that the hint quality of both policies is quite high, with a median quality of 1, indicating that the task may be too easy to reveal meaningful differences.\nAn interesting finding is that the policy of Zimmerman and Rupakheti performed relatively poorly, even though it aims at guiding students directly to a solution. This is likely the case because, if the edit distance between the solution and the current state of the student is high, many edits are possible and equally valid to guide a student closer to a solution. In such a case, the policy likely selects an edit which introduces an advanced step too early, leading to a low hint quality rating. This is directly related to the fact that\nthe shortest path toward the solution may be not always be the most intuitive one. As an example, consider the state displayed in Figure 9. The student has completed initialization of two input numbers x and y and has also inserted a decision node. The continuous hint factory correctly recommends to start padding the first input x if it is shorter than y. The policy of Zimmerman and Rupakethi, on the other hand, recommends to set a bit in the output number z, which has not even been initialized yet.\nFurther, a closer look revealed that all policies achieved perfect hints for the first two to four steps in each policy, because the beginning for each diagram was essentially the same. This is important in light of the research of Price et al. which indicates that students are more likely to seek help and follow hints if early hints provided by the system were useful [41]."}, {"heading": "5 Conclusion", "text": "This work makes two primary contributions: First, we have provided a mathematical framework for edit-based hints and placed prior contributions within this framework. We also have introduced the concept of the edit distance space, which is a continuous embedding of student states for which the edit\ndistance corresponds to the Euclidean distance in the embedding space. Second, we introduced the continuous hint factory, a novel hint policy which provides edit hints to students by combining probabilistic modelling inspired by the hint factory with the nearest neighbor principle commonly used in hint policies for vast and sparsely populated state spaces.\nIn our experiments we have shown that the Gaussian process model is able to predict what capable students would do. We have also demonstrated that the hints provided by the continuous hint factory match what human tutors would have recommended in a given situation, although the hints, on average, have lower quality compared to the feedback given by human tutors.\nWith this new hint policy we have extended the capabilities of intelligent tutoring systems to provide edit hints to student even in tasks where state spaces are vast and student data is sparse. We have also provided a better theoretical overview of edit distances and edit-based hint policies which hopefully facilitates future research in the field.\nWe note that the continuous hint factory still has several limitations. In particular, the hint factory can only be applied if an edit distance is available which is efficient, takes syntax and semantics into account appropriately and yields edits that are viable as next-step-hints for the student. This is not an issue for the domain of computer programming, as edit distances appear as a natural fit for syntax-tree-based representations of programs, but may be an issue for other domains. Further, as any data-driven hint approach, hint quality will suffer if the strategy of a new student is substantially different from anything that the system has seen before. With regards to evaluation, our assessment of hint quality is not definitive and it appears likely that our proposed approach only yields significant advantages compared to existing work on more complicated tasks compared to the one we investigated. Further, we do not yet know how a difference in hint quality translates to learning outcomes in students. After all, better hints from the view of a tutor may not always yield better learning outcomes, due to difficulties in sense-making or lack of prior knowledge on the student\u2019s side [2]. Finally, we acknowledge that our evaluation is rather narrow, including only two learning tasks from different domains.\nWith regards to future work, it appears promising to combine our proposed approach with other work presented in the literature, in particular canonicalization, state re-ification, unit tests and frequency information as suggested by Rivers and Koedinger [44], or more sophisticated edit distances as suggested by Mokbel et al. Paa\u00dfen et al. and Price et al. [27, 32, 40]. In-\ncorporating such approaches has the potential to enhance the edits suggested by the continuous hint factory significantly and, ideally, reach human-level quality in recommending edit hints. We also hope the continue to refine methods for evaluating and comparing hint quality across hint policies, to allow for better a better understanding of each policy\u2019s strengths and weaknesses."}, {"heading": "6 Acknowledgement", "text": "This research was funded by the German Research Foundation (DFG) as part of the project \u201cLearning Dynamic Feedback for Intelligent Tutoring Systems\u201d under the grant number HA 2719/6-2 as well as the Cluster of Excellence Cognitive Interaction Technology \u2019CITEC\u2019 (EXC 277), Bielefeld University and the NSF under grant number #1432156 \u201cEducational Data Mining for Individualized Instruction in STEM Learning Environments\u201d with Min Chi & Tiffany Barnes as Co-PIs. We also wish to express our gratitude to our anonymous reviewers who helped to substantially increase the quality of our contribution."}], "references": [{"title": "A new paradigm for intelligent tutoring systems: Example-tracing tutors", "author": ["V. Aleven", "B.M. McLaren", "J. Sewall", "K.R. Koedinger"], "venue": "International Journal of Artificial Intelligence in Education,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Help helps, but only so much: Research on help seeking with intelligent tutoring systems", "author": ["V. Aleven", "I. Roll", "B.M. McLaren", "K.R. Koedinger"], "venue": "International Journal of Artificial Intelligence in Education,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2016}, {"title": "Learning to Find Pre-images", "author": ["G.H. Bak\u0131r", "J. Weston", "B. Sch\u00f6lkopf"], "venue": "Proceedings of the 16th International Conference on Neural Information Processing Systems (NIPS", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "Data-Driven Domain Models for Problem Solving, volume 4 of Design Recommendations for Intelligent Tutoring Systems", "author": ["T. Barnes", "B. Mostafavi", "M.J. Eagle"], "venue": "US Army Research Laboratory,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2016}, {"title": "Toward automatic hint generation for logic proof tutoring using historical student data", "author": ["T. Barnes", "J. Stamper"], "venue": "Proceedings of the 9th International Conference on Intelligent Tutoring Systems (ITS", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Random search for hyper-parameter optimization", "author": ["J. Bergstra", "Y. Bengio"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Scale-driven automatic hint generation for coding style", "author": ["R.R. Choudhury", "H. Yin", "A. Fox"], "venue": "Proceedings of the 13th International Conference on Intelligent Tutoring Systems (ITS", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2016}, {"title": "Evaluation of automatically generated hint feedback", "author": ["M. Eagle", "T. Barnes"], "venue": "Proceedings of the 6th International Conference on Educational Data Mining (EDM", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Interaction networks: Generating high level hints based on network community clustering", "author": ["M. Eagle", "M. Johnson", "T. Barnes"], "venue": "Proceedings of the 5th International Conference on Educational Data Mining (EDM", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "Instructional Message Design: Principles from the Behavioral and Cognitive Sciences", "author": ["M.L. Fleming", "W.H. Levie"], "venue": "Educational Technology Publications,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1993}, {"title": "Inferring student coding goals using abstract syntax trees", "author": ["P. Freeman", "I. Watson", "P. Denny"], "venue": "Proceedings of the 24th International Conference on  Preprint as provided by the authors", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2016}, {"title": "The Beauty and Joy of Computing", "author": ["D. Garcia", "B. Harvey", "T. Barnes"], "venue": "ACM Inroads,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2015}, {"title": "A discipline of dynamic programming over sequence data", "author": ["R. Giegerich", "C. Meyer", "P. Steffen"], "venue": "Science of Computer Programming,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2004}, {"title": "Metric and non-metric proximity transformations at linear costs", "author": ["A. Gisbrecht", "F.-M. Schleif"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2015}, {"title": "Example-based feedback provision using structured solution spaces", "author": ["S. Gross", "B. Mokbel", "B. Hammer", "N. Pinkwart"], "venue": "International Journal on Learning Technologies,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2014}, {"title": "How do learners behave in help-seeking when given a choice", "author": ["S. Gross", "N. Pinkwart"], "venue": "Proceedings of the 17th International Conference on Artificial Intelligence in Education (AIED", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2015}, {"title": "Topographic mapping of large dissimilarity data sets", "author": ["B. Hammer", "A. Hasenfuss"], "venue": "Neural Computation,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2010}, {"title": "Writing reusable code feedback at scale with mixedinitiative program synthesis", "author": ["A. Head", "E. Glassman", "G. Soares", "R. Suzuki", "L. Figueredo", "L. D\u2019Antoni", "B. Hartmann"], "venue": "In Proceedings of the Fourth ACM Conference on Learning@Scale (L@S", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2017}, {"title": "Building games to learn from their players: Generating hints in a serious game", "author": ["A. Hicks", "B. Peddycord", "T. Barnes"], "venue": "Proceedings of the 12th International Conference Intelligent Tutoring Systems  Preprint as provided by the authors", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2014}, {"title": "New potentials for data-driven intelligent tutoring system development and optimization", "author": ["K.R. Koedinger", "E. Brunskill", "R.S. Baker", "E.A. McLaughlin", "J. Stamper"], "venue": "AI Magazine,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2013}, {"title": "Data-driven program synthesis for hint generation in programming tutors", "author": ["T. Lazar", "I. Bratko"], "venue": "Proceedings of the 12th International Conference on Intelligent Tutoring Systems (ITS", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2014}, {"title": "A classification of adaptive feedback in educational systems for programming", "author": ["N.-T. Le"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2002}, {"title": "Towards a classification for programming exercises", "author": ["N.-t. Le", "N. Pinkwart"], "venue": "In Proceedings of the 2nd Workshop on AI-supported Education for Computer Science (AIEDCS),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2014}, {"title": "Binary codes capable of correcting deletions, insertions, and reversals", "author": ["V.I. Levenshtein"], "venue": "Soviet Physics Doklady,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1965}, {"title": "Concepts, structures, and goals: Redefining ill-definedness", "author": ["C. Lynch", "K.D. Ashley", "N. Pinkwart", "V. Aleven"], "venue": "International Journal of Artificial Intelligence in Education,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2009}, {"title": "Automated personalized feedback in introductory java programming moocs", "author": ["V.J. Marin", "T. Pereira", "S. Sridharan", "C.R. Rivero"], "venue": "In 33rd International IEEE Conference on Data Engineering (ICDE", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2017}, {"title": "Domain-Independent Proximity Measures in Intelligent Tutoring Systems", "author": ["B. Mokbel", "S. Gross", "B. Paa\u00dfen", "N. Pinkwart", "B. Hammer"], "venue": "Proceedings of the 6th International Conference on Educational Data Mining (EDM", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2013}, {"title": "Authoring tools for advanced technology learning environments: Toward cost-effective adaptive, interactive and intelligent educational software", "author": ["T. Murray", "S. Blessing", "S. Ainsworth"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2003}, {"title": "Expert blind spot: When content knowledge eclipses pedagogical content knowledge", "author": ["M.J. Nathan", "K.R. Koedinger", "M.W. Alibali"], "venue": "In Proceedings of the Third International Conference on Cognitive Science,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2001}, {"title": "Codewebs: Scalable homework search for massive open online programming courses", "author": ["A. Nguyen", "C. Piech", "J. Huang", "L. Guibas"], "venue": "In Proceedings of the 23rd International Conference on World Wide Web (WWW", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2014}, {"title": "A toolbox for adaptive sequence dissimilarity measures for intelligent tutoring systems", "author": ["B. Paa\u00dfen", "B. Mokbel", "B. Hammer"], "venue": "Proceedings of the 8th International Conference on Educational Data Mining (EDM", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2015}, {"title": "Adaptive structure metrics for automated feedback provision in intelligent tutoring systems", "author": ["B. Paassen", "B. Mokbel", "B. Hammer"], "venue": null, "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2016}, {"title": "Time Series Prediction for Graphs in Kernel and Dissimilarity Spaces", "author": ["B. Paa\u00dfen", "C. G\u00f6pfert", "B. Hammer"], "venue": "Neural Processing Letters,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2017}, {"title": "The dissimilarity representation for pattern recognition: foundations and applications", "author": ["E. P\u0119kalska"], "venue": "PhD thesis,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2005}, {"title": "Learning program embeddings to propagate feedback on student code", "author": ["C. Piech", "J. Huang", "A. Nguyen", "M. Phulsuksombati", "M. Sahami", "L. Guibas"], "venue": "Proceedings of the 32nd International Conference on Machine Learning (ICML 2015), International Conference on Machine Learning,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2015}, {"title": "Autonomously generating hints by inferring problem solving policies", "author": ["C. Piech", "M. Sahami", "J. Huang", "L. Guibas"], "venue": "Proceedings of the Second ACM Conference on Learning @ Scale (L@S", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2015}, {"title": "An exploration of data-driven hint generation in an open-ended programming problem", "author": ["T.W. Price", "T. Barnes"], "venue": "Workshops Proceedings of the 8th International Conference on Educational Data Mining (EDM", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2015}, {"title": "Generating data-driven hints for open-ended programming", "author": ["T.W. Price", "Y. Dong", "T. Barnes"], "venue": "Proceedings of the 9th International Conference on Educational Data Mining (EDM 2016),", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2016}, {"title": "iSnap: Towards intelligent tutoring in novice programming environments", "author": ["T.W. Price", "Y. Dong", "D. Lipovac"], "venue": "In Proceedings of the 2017 ACM Technical Symposium on Computer Science Education (SIGCSE),", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2017}, {"title": "Evaluation of a data-driven feedback algorithm for open-ended programming", "author": ["T.W. Price", "R. Zhi", "T. Barnes"], "venue": "Proceedings of the 10th International Conference on Educational Datamining (EDM 2017),", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2017}, {"title": "Hint generation under uncertainty: The effect of hint quality on help-seeking behavior", "author": ["T.W. Price", "R. Zhi", "T. Barnes"], "venue": "Proceedings of the 18th International Conference on Artificial Intelligence in Education (AIED", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2017}, {"title": "Gaussian Processes for Machine Learning (Adaptive Computation and Machine Learning)", "author": ["C.E. Rasmussen", "C.K.I. Williams"], "venue": null, "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2005}, {"title": "A canonicalizing model for building programming tutors", "author": ["K. Rivers", "K.R. Koedinger"], "venue": "Proceedings of the 11th International Conference on Intelligent Tutoring Systems,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2012}, {"title": "Data-driven hint generation in vast solution spaces: a self-improving python programming tutor", "author": ["K. Rivers", "K.R. Koedinger"], "venue": "International Journal of Artificial Intelligence in Education,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2015}, {"title": "Experimental evaluation of automatic hint generation for a logic tutor", "author": ["J.C. Stamper", "T. Barnes", "M. Croy", "M. Eagle"], "venue": "International Journal of Artificial Intelligence in Education,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2012}, {"title": "Introduction to Reinforcement Learning", "author": ["R.S. Sutton", "A.G. Barto"], "venue": null, "citeRegEx": "46", "shortCiteRegEx": "46", "year": 1998}, {"title": "The behavior of tutoring systems", "author": ["K. Van Lehn"], "venue": "International Journal of Artificial Intelligence in Education,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2006}, {"title": "Clustering student programming assignments to multiply instructor leverage", "author": ["H. Yin", "J. Moghadam", "A. Fox"], "venue": "In Proceedings of the Second ACM Conference on Learning @ Scale (L@S", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2015}, {"title": "Simple fast algorithms for the editing distance between trees and related problems", "author": ["K. Zhang", "D. Shasha"], "venue": "SIAM Journal on Computing,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 1989}, {"title": "An automated framework for recommending program elements to novices (n)", "author": ["K. Zimmerman", "C.R. Rupakheti"], "venue": "In Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering (ASE", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2015}], "referenceMentions": [{"referenceID": 14, "context": "For example, programming tasks require a student to iteratively write, test and refine code that accomplishes a given objective [15, 39, 44].", "startOffset": 128, "endOffset": 140}, {"referenceID": 38, "context": "For example, programming tasks require a student to iteratively write, test and refine code that accomplishes a given objective [15, 39, 44].", "startOffset": 128, "endOffset": 140}, {"referenceID": 43, "context": "For example, programming tasks require a student to iteratively write, test and refine code that accomplishes a given objective [15, 39, 44].", "startOffset": 128, "endOffset": 140}, {"referenceID": 1, "context": "In particular, such a student may benefit from a next-step hint, guiding her toward a more complete and/or more correct version and allowing her to continue working on her own [2].", "startOffset": 176, "endOffset": 179}, {"referenceID": 46, "context": "Many intelligent tutoring systems (ITS) support these multi-step tasks by generating next-step hints to match the student\u2019s current state and her underlying strategy [47].", "startOffset": 166, "endOffset": 170}, {"referenceID": 27, "context": "However, designing such an expert model becomes infeasible if the space of possible states grows too large [28, 20, 44].", "startOffset": 107, "endOffset": 119}, {"referenceID": 19, "context": "However, designing such an expert model becomes infeasible if the space of possible states grows too large [28, 20, 44].", "startOffset": 107, "endOffset": 119}, {"referenceID": 43, "context": "However, designing such an expert model becomes infeasible if the space of possible states grows too large [28, 20, 44].", "startOffset": 107, "endOffset": 119}, {"referenceID": 35, "context": "This is the case for most computer programming tasks because the space of possible programs grows exponentially with the program length and the set of programs which generate the same function is infinite [36].", "startOffset": 205, "endOffset": 209}, {"referenceID": 24, "context": "Other examples are so-called ill-defined domains where explicit domain knowledge is not available or at least very hard to formalize [25].", "startOffset": 133, "endOffset": 137}, {"referenceID": 49, "context": "If a student issues a help request, the system can simply compute the necessary edits from the student\u2019s state to the solution and use one of these edits as a hint [50].", "startOffset": 164, "endOffset": 168}, {"referenceID": 22, "context": "Even though this approach is fairly simple, it is conceptually quite powerful, because the feedback provided is personalized in the sense that the hint a student receives depends on her personal state and is thereby tailored to her specific situation [23].", "startOffset": 251, "endOffset": 255}, {"referenceID": 26, "context": "Another advantage is that this approach needs very little task-specific work on the side of the teachers, because they only need to construct one solution for the task, and can apply a general-purpose edit function which is applicable across tasks or even across domains [27].", "startOffset": 271, "endOffset": 275}, {"referenceID": 44, "context": "In a sense, we combine the probabilistic modelling of the hint factory, a well-established hint approach for densely populated state spaces [45], with the nearest-neighbor-principle commonly used in hint policies for vast and sparsely populated state spaces [16, 44, 50] to achieve a novel approach that extends existing work.", "startOffset": 140, "endOffset": 144}, {"referenceID": 15, "context": "In a sense, we combine the probabilistic modelling of the hint factory, a well-established hint approach for densely populated state spaces [45], with the nearest-neighbor-principle commonly used in hint policies for vast and sparsely populated state spaces [16, 44, 50] to achieve a novel approach that extends existing work.", "startOffset": 258, "endOffset": 270}, {"referenceID": 43, "context": "In a sense, we combine the probabilistic modelling of the hint factory, a well-established hint approach for densely populated state spaces [45], with the nearest-neighbor-principle commonly used in hint policies for vast and sparsely populated state spaces [16, 44, 50] to achieve a novel approach that extends existing work.", "startOffset": 258, "endOffset": 270}, {"referenceID": 49, "context": "In a sense, we combine the probabilistic modelling of the hint factory, a well-established hint approach for densely populated state spaces [45], with the nearest-neighbor-principle commonly used in hint policies for vast and sparsely populated state spaces [16, 44, 50] to achieve a novel approach that extends existing work.", "startOffset": 258, "endOffset": 270}, {"referenceID": 9, "context": "In particular, edit hints lack the capacity to reference underlying concepts which may be helpful for the task or elaborate on these concepts, as suggested by Fleming and Levie [10, 22].", "startOffset": 177, "endOffset": 185}, {"referenceID": 21, "context": "In particular, edit hints lack the capacity to reference underlying concepts which may be helpful for the task or elaborate on these concepts, as suggested by Fleming and Levie [10, 22].", "startOffset": 177, "endOffset": 185}, {"referenceID": 1, "context": "suggest to display these \u201cbottom-out hints\u201d hints only as a last resort after exhausting options for more principle-based hints [2].", "startOffset": 128, "endOffset": 131}, {"referenceID": 1, "context": "Second, bottom-out hints, such as edit hints, may lead to learning gains, if students reflect on the hint and engage in sense-making behavior [2].", "startOffset": 142, "endOffset": 145}, {"referenceID": 1, "context": "Conversely, if students aim to abuse the system, this is not hindered by principle-based hints: students simply skip through them to reach the bottom-out hint [2].", "startOffset": 159, "endOffset": 162}, {"referenceID": 40, "context": "which indicates that edit hints are judged as relevant and interpretable by human tutors [41].", "startOffset": 89, "endOffset": 93}, {"referenceID": 27, "context": "Finally, and most importantly, we argue that more elaborate hint strategies are simply not available in many important learning tasks, because they require hint messages which result from an expert-crafted model, which is infeasible if the space of possible states is vast and includes many different strategies, because the sheer number of different hint messages necessary is too large for human experts to handle [28, 44, 23], or because human experts may overlook strategies that novices might employ (\u201cexpert blind spot\u201d) [29].", "startOffset": 416, "endOffset": 428}, {"referenceID": 43, "context": "Finally, and most importantly, we argue that more elaborate hint strategies are simply not available in many important learning tasks, because they require hint messages which result from an expert-crafted model, which is infeasible if the space of possible states is vast and includes many different strategies, because the sheer number of different hint messages necessary is too large for human experts to handle [28, 44, 23], or because human experts may overlook strategies that novices might employ (\u201cexpert blind spot\u201d) [29].", "startOffset": 416, "endOffset": 428}, {"referenceID": 22, "context": "Finally, and most importantly, we argue that more elaborate hint strategies are simply not available in many important learning tasks, because they require hint messages which result from an expert-crafted model, which is infeasible if the space of possible states is vast and includes many different strategies, because the sheer number of different hint messages necessary is too large for human experts to handle [28, 44, 23], or because human experts may overlook strategies that novices might employ (\u201cexpert blind spot\u201d) [29].", "startOffset": 416, "endOffset": 428}, {"referenceID": 28, "context": "Finally, and most importantly, we argue that more elaborate hint strategies are simply not available in many important learning tasks, because they require hint messages which result from an expert-crafted model, which is infeasible if the space of possible states is vast and includes many different strategies, because the sheer number of different hint messages necessary is too large for human experts to handle [28, 44, 23], or because human experts may overlook strategies that novices might employ (\u201cexpert blind spot\u201d) [29].", "startOffset": 527, "endOffset": 531}, {"referenceID": 15, "context": "For this reason, recent work on hint generation for programming has focused largely on automatic, edit-based hint generation [16, 21, 38, 44, 50].", "startOffset": 125, "endOffset": 145}, {"referenceID": 20, "context": "For this reason, recent work on hint generation for programming has focused largely on automatic, edit-based hint generation [16, 21, 38, 44, 50].", "startOffset": 125, "endOffset": 145}, {"referenceID": 37, "context": "For this reason, recent work on hint generation for programming has focused largely on automatic, edit-based hint generation [16, 21, 38, 44, 50].", "startOffset": 125, "endOffset": 145}, {"referenceID": 43, "context": "For this reason, recent work on hint generation for programming has focused largely on automatic, edit-based hint generation [16, 21, 38, 44, 50].", "startOffset": 125, "endOffset": 145}, {"referenceID": 49, "context": "For this reason, recent work on hint generation for programming has focused largely on automatic, edit-based hint generation [16, 21, 38, 44, 50].", "startOffset": 125, "endOffset": 145}, {"referenceID": 0, "context": "A prime example are the cognitive tutor authoring tools (CTAT) which support the construction of cognitive tutors, in particular example-tracing tutors [1].", "startOffset": 152, "endOffset": 155}, {"referenceID": 19, "context": "With regards to intelligent tutoring systems, this can be seen as a \u201cgold standard\u201d, because the effectiveness of cognitive tutors has been established in classroom studies, as well as their successful application in classrooms across the US [20].", "startOffset": 242, "endOffset": 246}, {"referenceID": 0, "context": "is a task with roughly 20 steps and 6 different paths toward the solution [1].", "startOffset": 74, "endOffset": 77}, {"referenceID": 34, "context": "Another approach is \u201cforce multiplication\u201d, which assumes that a relatively small number of expert-crafted hint messages are available, which are then applied to new situations automatically, thereby \u201cmultiplying the force\u201d of expert work [35].", "startOffset": 239, "endOffset": 243}, {"referenceID": 17, "context": "who apply clustering methods to aggregate many different states and then provide the same hint to all states in the same cluster [18, 48, 7].", "startOffset": 129, "endOffset": 140}, {"referenceID": 47, "context": "who apply clustering methods to aggregate many different states and then provide the same hint to all states in the same cluster [18, 48, 7].", "startOffset": 129, "endOffset": 140}, {"referenceID": 6, "context": "who apply clustering methods to aggregate many different states and then provide the same hint to all states in the same cluster [18, 48, 7].", "startOffset": 129, "endOffset": 140}, {"referenceID": 34, "context": "Then, they train a classifier function via machine learning which decides for any new state whether the hint should be displayed or not [35].", "startOffset": 136, "endOffset": 140}, {"referenceID": 25, "context": "annotate expertcrafted hints with small snippets of Java code for which the given hint makes sense and display the hint whenever the respective snippet is discovered in a student\u2019s state [26].", "startOffset": 187, "endOffset": 191}, {"referenceID": 35, "context": "we call such a function a hint policy [36].", "startOffset": 38, "endOffset": 42}, {"referenceID": 49, "context": "A simple example hint policy is the policy of Zimmerman and Rupakheti, who suggest to return the first edit in the shortest sequence of edits which transforms the input state to a correct solution for the task [50].", "startOffset": 210, "endOffset": 214}, {"referenceID": 23, "context": "As an example, consider the string edit distance [24] which operates on sequences over some alphabet A.", "startOffset": 49, "endOffset": 53}, {"referenceID": 23, "context": "In this case, the overall edit distance can be computed in O(N) using a dynamic programming algorithm [24].", "startOffset": 102, "endOffset": 106}, {"referenceID": 43, "context": "Oftentimes in intelligent tutoring systems, states have the form of trees, for example abstract syntax trees of computer programs [44].", "startOffset": 130, "endOffset": 134}, {"referenceID": 6, "context": "For such data, the tree edit distance algorithm of Zhang and Shasha is a natural fit and has been applied in several contributions [7, 11, 30, 44].", "startOffset": 131, "endOffset": 146}, {"referenceID": 10, "context": "For such data, the tree edit distance algorithm of Zhang and Shasha is a natural fit and has been applied in several contributions [7, 11, 30, 44].", "startOffset": 131, "endOffset": 146}, {"referenceID": 29, "context": "For such data, the tree edit distance algorithm of Zhang and Shasha is a natural fit and has been applied in several contributions [7, 11, 30, 44].", "startOffset": 131, "endOffset": 146}, {"referenceID": 43, "context": "For such data, the tree edit distance algorithm of Zhang and Shasha is a natural fit and has been applied in several contributions [7, 11, 30, 44].", "startOffset": 131, "endOffset": 146}, {"referenceID": 48, "context": "Similarly to the string edit distance, the tree edit distance permits deletion, insertion and replacements of tree nodes, but the algorithm is more complex with O(N) runtime [49].", "startOffset": 174, "endOffset": 178}, {"referenceID": 49, "context": "who compute an edit distance on pq-grams in trees, meaning small subtrees, which results in a considerably faster runtime of O(N \u00b7 log(N)) [50].", "startOffset": 139, "endOffset": 143}, {"referenceID": 26, "context": "have suggested a two-level approach where student states are first decomposed into fragments which may be arbitrarily ordered and fragments are compared using a string edit distance [27, 40].", "startOffset": 182, "endOffset": 190}, {"referenceID": 39, "context": "have suggested a two-level approach where student states are first decomposed into fragments which may be arbitrarily ordered and fragments are compared using a string edit distance [27, 40].", "startOffset": 182, "endOffset": 190}, {"referenceID": 12, "context": ", who devised a generalpurpose O(N) algorithm for string edit distances which supports a broad class of edit sets as well as edit cost functions and relies on the framework of algebraic dynamic programming [13, 32].", "startOffset": 206, "endOffset": 214}, {"referenceID": 31, "context": ", who devised a generalpurpose O(N) algorithm for string edit distances which supports a broad class of edit sets as well as edit cost functions and relies on the framework of algebraic dynamic programming [13, 32].", "startOffset": 206, "endOffset": 214}, {"referenceID": 31, "context": "This approach has also been applied to abstract syntax trees by flattening the trees to sequences of code statements in order of their execution [32].", "startOffset": 145, "endOffset": 149}, {"referenceID": 49, "context": "Consider the hint policy of Zimmerman and Rupakheti mentioned above [50].", "startOffset": 68, "endOffset": 72}, {"referenceID": 42, "context": "Canonicalization is particularly common in the domain of computer programs, where the order of binary relations (such as <) or variable names can be normalized or unreachable code can be removed [43].", "startOffset": 195, "endOffset": 199}, {"referenceID": 34, "context": "in the canonic form [35, 7].", "startOffset": 20, "endOffset": 27}, {"referenceID": 6, "context": "in the canonic form [35, 7].", "startOffset": 20, "endOffset": 27}, {"referenceID": 43, "context": "Another challenge in canonicalization is that edits on the canonic form may not be interpretable to the user directly, such that these edits first need to be aligned with the student\u2019s code, a process that has been dubbed state reification [44].", "startOffset": 240, "endOffset": 244}, {"referenceID": 31, "context": "Instead of mapping two semantically equivalent states x and y to the same canonic form, we could also lower the cost of edits which transform x to y [32].", "startOffset": 149, "endOffset": 153}, {"referenceID": 49, "context": "In summary, the concepts of edit set, legal move graph and edit distance permit us to define a hint policy that is mathematically optimal in the sense that each student will receive a hint which lies on the shortest path to a solution [50].", "startOffset": 235, "endOffset": 239}, {"referenceID": 8, "context": "In other words, an interaction networks tries to approximate what students are likely to do by capturing what past students have done [9, 4].", "startOffset": 134, "endOffset": 140}, {"referenceID": 3, "context": "In other words, an interaction networks tries to approximate what students are likely to do by capturing what past students have done [9, 4].", "startOffset": 134, "endOffset": 140}, {"referenceID": 8, "context": ", we define traces as follows [9]:", "startOffset": 30, "endOffset": 33}, {"referenceID": 42, "context": "For example, the edit sets might be different because students work on a different representation compared to the representation used to compute edit distances, for example due to canonicalization [43, 44].", "startOffset": 197, "endOffset": 205}, {"referenceID": 43, "context": "For example, the edit sets might be different because students work on a different representation compared to the representation used to compute edit distances, for example due to canonicalization [43, 44].", "startOffset": 197, "endOffset": 205}, {"referenceID": 35, "context": "In these cases we have to assume that students may \u201cjump\u201d in the legal move graph from state to state and the exact path they have taken needs to be inferred by the system [36].", "startOffset": 172, "endOffset": 176}, {"referenceID": 49, "context": "we introduced above, which always recommends the first edit on the shortest path to the closest solution [50].", "startOffset": 105, "endOffset": 109}, {"referenceID": 43, "context": "Rivers and Koedinger take a more advanced approach in their Intelligent Teaching Assistant for Programming (ITAP), an intelligent tutoring system for Python programming [44].", "startOffset": 169, "endOffset": 173}, {"referenceID": 43, "context": "Third, of these intermediate states, the one with the highest desirability score is selected for feedback, where the desirability score is a weighted sum of the frequency in past student data, the distance to the student\u2019s state, the number of successful test cases the state passes and the distance to the solution [44].", "startOffset": 316, "endOffset": 320}, {"referenceID": 35, "context": "called Poisson path policy, which recommends the first state on the shortestpath algorithm on a version of the legal move graph which weighted the edges according to the inverse frequency of the target state in the dataset, that is, \u03b2(x, x\u2032) := N/N(x\u2032) where N is the overall number of states submitted by successful students and N(x\u2032) is the number of times x\u2032 was submitted by successful students [36].", "startOffset": 399, "endOffset": 403}, {"referenceID": 15, "context": "If students assume that their current state is correct, but they are looking for a next step, the system recommends an edit toward the successor of the reference state, thereby guiding the student closer to a solution [16].", "startOffset": 218, "endOffset": 222}, {"referenceID": 10, "context": "have taken this view to analyze Python programs and used a weighted tree edit distance to retrieve similar cases [11].", "startOffset": 113, "endOffset": 117}, {"referenceID": 14, "context": "proposed example-based feedback, in which the closest prototypical state in a dataset is retrieved and shown to the student to elicit self-reflection and sense-making in order to improve their own state [15].", "startOffset": 203, "endOffset": 207}, {"referenceID": 20, "context": "The scheme of Lazar and Bratko takes a different approach by applying edits that have been frequent in past student traces to manipulate the current student\u2019s state until an edit is found that achieves better unit test scores [21].", "startOffset": 226, "endOffset": 230}, {"referenceID": 4, "context": "[5] They achieve an optimal hint policy in a precise probabilistic sense by modelling the multi-step learning task as a Markov Decision Process [46].", "startOffset": 0, "endOffset": 3}, {"referenceID": 45, "context": "[5] They achieve an optimal hint policy in a precise probabilistic sense by modelling the multi-step learning task as a Markov Decision Process [46].", "startOffset": 144, "endOffset": 148}, {"referenceID": 4, "context": "The hint factory was originally created as a hint-generation add-on to the DeepThought instruction system for deductive logic [5].", "startOffset": 126, "endOffset": 129}, {"referenceID": 44, "context": "Several studies have demonstrated that the hint factory reduces student dropout and helps students to complete more problems more efficiently [45, 8].", "startOffset": 142, "endOffset": 149}, {"referenceID": 7, "context": "Several studies have demonstrated that the hint factory reduces student dropout and helps students to complete more problems more efficiently [45, 8].", "startOffset": 142, "endOffset": 149}, {"referenceID": 18, "context": "The hint factory has also been applied to further domains, such as the serious game BOTS [19] or the SNAP programming environment [39].", "startOffset": 89, "endOffset": 93}, {"referenceID": 38, "context": "The hint factory has also been applied to further domains, such as the serious game BOTS [19] or the SNAP programming environment [39].", "startOffset": 130, "endOffset": 134}, {"referenceID": 49, "context": "So which edit would be recommended by the different hint policies discussed above? The approach of Zimmerman and Rupakheti (Figure 3a) would just search the shortest path through the legal move graph to the solution and recommend the first edit on that path [50].", "startOffset": 258, "endOffset": 262}, {"referenceID": 15, "context": "The approach of Gross and Pinkwart (Figure 3b) would select the closest state in a previously seen trace and recommend an edit toward the successor in that trace, which would be the edit to the right [16].", "startOffset": 200, "endOffset": 204}, {"referenceID": 4, "context": "Similarly, the hint factory (Figure 3b) would just have information for one trace in that state and thus would also recommend following this trace [5].", "startOffset": 147, "endOffset": 150}, {"referenceID": 35, "context": "(Figure 3c) would search for the shortest path taking into account state frequency in the available trace data [36].", "startOffset": 111, "endOffset": 115}, {"referenceID": 20, "context": "Only edits are recommended which extend the functionality of the previous state by achieving a higher test score [21, 44].", "startOffset": 113, "endOffset": 121}, {"referenceID": 43, "context": "Only edits are recommended which extend the functionality of the previous state by achieving a higher test score [21, 44].", "startOffset": 113, "endOffset": 121}, {"referenceID": 49, "context": "(a) [50] (b) [16, 5]", "startOffset": 4, "endOffset": 8}, {"referenceID": 15, "context": "(a) [50] (b) [16, 5]", "startOffset": 13, "endOffset": 20}, {"referenceID": 4, "context": "(a) [50] (b) [16, 5]", "startOffset": 13, "endOffset": 20}, {"referenceID": 35, "context": "(c) [36] (d) [21, 44]", "startOffset": 4, "endOffset": 8}, {"referenceID": 20, "context": "(c) [36] (d) [21, 44]", "startOffset": 13, "endOffset": 21}, {"referenceID": 43, "context": "(c) [36] (d) [21, 44]", "startOffset": 13, "endOffset": 21}, {"referenceID": 3, "context": "This has been dubbed the hintable subgraph [4].", "startOffset": 43, "endOffset": 46}, {"referenceID": 36, "context": "Indeed, research has shown that for a reasonably small, open-ended programming task, over 90% of states are visited only once, indicating that future students will likely visit states that have not been seen before and may not even be connected to previously seen states in the legal move graph [37]; and the number of unique states remained high even after applying harsh canonicalization [37].", "startOffset": 295, "endOffset": 299}, {"referenceID": 36, "context": "Indeed, research has shown that for a reasonably small, open-ended programming task, over 90% of states are visited only once, indicating that future students will likely visit states that have not been seen before and may not even be connected to previously seen states in the legal move graph [37]; and the number of unique states remained high even after applying harsh canonicalization [37].", "startOffset": 390, "endOffset": 394}, {"referenceID": 37, "context": ", who suggested contextual tree decomposition (CTD) which generates interaction networks only for small modules in the student\u2019s state [38].", "startOffset": 135, "endOffset": 139}, {"referenceID": 39, "context": "A challenge of this approach is that the system generates hints for each module, from which the student must select [40].", "startOffset": 116, "endOffset": 120}, {"referenceID": 32, "context": "who proposed a prediction scheme for data that is given in terms of pairwise dissimilarities [33].", "startOffset": 93, "endOffset": 97}, {"referenceID": 34, "context": "who proposed an embedding of computer programs via neural networks [35].", "startOffset": 67, "endOffset": 71}, {"referenceID": 34, "context": "This matrix MA is the embedding of the code block A [35].", "startOffset": 52, "endOffset": 56}, {"referenceID": 40, "context": "First, the hint should seem reasonable to the student requesting it; otherwise, the hint will likely be ignored [41].", "startOffset": 112, "endOffset": 116}, {"referenceID": 4, "context": "A policy that would achieve our goals in densely populated state spaces is the hint factory [5].", "startOffset": 92, "endOffset": 95}, {"referenceID": 4, "context": "Relying on the theoretical framework of reinforcement learning, the hint factory recommends the edit that is most likely to lead to a solution, given what other students have done in the same situation [5].", "startOffset": 202, "endOffset": 205}, {"referenceID": 32, "context": "Second, we develop a hint policy in this embedding space based on Gaussian process prediction for structured data [33].", "startOffset": 114, "endOffset": 118}, {"referenceID": 16, "context": "Refer to [17, 34].", "startOffset": 9, "endOffset": 17}, {"referenceID": 33, "context": "Refer to [17, 34].", "startOffset": 9, "endOffset": 17}, {"referenceID": 13, "context": "Such techniques convert the matrix of pairwise distances to a matrix of pairwise similarities, decompose this matrix into its Eigenvectors and Eigenvalues, then sets the Eigenvalues to non-negative values and convert the resulting similarity matrix back to a matrix of pairwise distances [14].", "startOffset": 288, "endOffset": 292}, {"referenceID": 15, "context": "This is equivalent to the policy of Gross and Pinkwart [16], which we will use as baseline.", "startOffset": 55, "endOffset": 59}, {"referenceID": 32, "context": "To integrate the edits of multiple students in a probabilistically optimal fashion, we turn to Gaussian Process Regression (GPR) for structured data [33].", "startOffset": 149, "endOffset": 153}, {"referenceID": 41, "context": "For an exact definition of kernel functions for GPR we point to the work of Rasmussen and Williams [42].", "startOffset": 99, "endOffset": 103}, {"referenceID": 41, "context": "5 \u00b7 d(x,y) 2 \u03c82 ) [42].", "startOffset": 18, "endOffset": 22}, {"referenceID": 0, "context": "Figure 6: The output of the radial basis function (RBF) kernel (y-axis) for distances between two states x and y in the range [0, 1] (x-axis) and a lengthscale of \u03c8 = 1 (red line).", "startOffset": 126, "endOffset": 132}, {"referenceID": 32, "context": "[33].", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "The problem of finding an original object which maps to a known point in an embedding space is called a pre-image problem [3], so the problem of finding", "startOffset": 122, "endOffset": 125}, {"referenceID": 2, "context": "We want to emphasize here that such pre-image problems are typically hard to solve [3] and, to our knowledge, no approach exists to date which addresses the edit pre-image problem.", "startOffset": 83, "endOffset": 86}, {"referenceID": 32, "context": "where Z is some constant that does not depend on \u03b4 [33].", "startOffset": 51, "endOffset": 55}, {"referenceID": 4, "context": "As such, our approach combines approaches for dense state spaces with approaches for vast and sparsely populated solution spaces, namely a probabilistic model, similar to the hint factory [5], and the nearestneighbor principle as used by Rivers and Koedinger [44], Zimmerman and Rupakheti [50], as well as Gross and Pinkwart [16].", "startOffset": 188, "endOffset": 191}, {"referenceID": 43, "context": "As such, our approach combines approaches for dense state spaces with approaches for vast and sparsely populated solution spaces, namely a probabilistic model, similar to the hint factory [5], and the nearestneighbor principle as used by Rivers and Koedinger [44], Zimmerman and Rupakheti [50], as well as Gross and Pinkwart [16].", "startOffset": 259, "endOffset": 263}, {"referenceID": 49, "context": "As such, our approach combines approaches for dense state spaces with approaches for vast and sparsely populated solution spaces, namely a probabilistic model, similar to the hint factory [5], and the nearestneighbor principle as used by Rivers and Koedinger [44], Zimmerman and Rupakheti [50], as well as Gross and Pinkwart [16].", "startOffset": 289, "endOffset": 293}, {"referenceID": 15, "context": "As such, our approach combines approaches for dense state spaces with approaches for vast and sparsely populated solution spaces, namely a probabilistic model, similar to the hint factory [5], and the nearestneighbor principle as used by Rivers and Koedinger [44], Zimmerman and Rupakheti [50], as well as Gross and Pinkwart [16].", "startOffset": 325, "endOffset": 329}, {"referenceID": 11, "context": "The first half of the course focused on learning the Snap2 programming language through a curriculum based on the Beauty and Joy of Computing [12].", "startOffset": 142, "endOffset": 146}, {"referenceID": 30, "context": "The edit distance was computed using the TCS Alignment Toolbox [31].", "startOffset": 63, "endOffset": 67}, {"referenceID": 13, "context": "[14].", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "We selected the length scale \u03c8 and the noise parameter \u03c3\u0303 via random search as suggested by Bergstra and Bengio [6].", "startOffset": 112, "endOffset": 115}, {"referenceID": 15, "context": "which recommends the successor of the next student state in the data base, which is essentially a one-nearest-neighbor hint policy [16]; third, the hint policy of Zimmerman and Rupakheti, which recommends the closest solution, meaning the closest end point in one of the other 46 traces [50].", "startOffset": 131, "endOffset": 135}, {"referenceID": 49, "context": "which recommends the successor of the next student state in the data base, which is essentially a one-nearest-neighbor hint policy [16]; third, the hint policy of Zimmerman and Rupakheti, which recommends the closest solution, meaning the closest end point in one of the other 46 traces [50].", "startOffset": 287, "endOffset": 291}, {"referenceID": 15, "context": "036) 1-NN / [16] 0.", "startOffset": 12, "endOffset": 16}, {"referenceID": 49, "context": "041) [50] 0.", "startOffset": 5, "endOffset": 9}, {"referenceID": 4, "context": "rely on overlap between traces to achieve meaningful approximations of their underlying probability distributions [5, 36].", "startOffset": 114, "endOffset": 121}, {"referenceID": 35, "context": "rely on overlap between traces to achieve meaningful approximations of their underlying probability distributions [5, 36].", "startOffset": 114, "endOffset": 121}, {"referenceID": 20, "context": "Further, we do not have unit tests at our disposal, which prevented us from applying the policies of Rivers and Koedinger or Lazar and Bratko [21, 44].", "startOffset": 142, "endOffset": 150}, {"referenceID": 43, "context": "Further, we do not have unit tests at our disposal, which prevented us from applying the policies of Rivers and Koedinger or Lazar and Bratko [21, 44].", "startOffset": 142, "endOffset": 150}, {"referenceID": 39, "context": "[40].", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "They also were asked to grade their hints with a real value in the interval [0, 1] indicating hint quality, taking into account the following criteria: 1) Does the hint follow the strategy of the student? 2) Does the hint conform to the student\u2019s current focus of attention or does it address a different part of the state? 3) Is the hint effective in addressing the problems in the student\u2019s state? 4) Is the hint effective in guiding the student toward a solution? In a second meeting, all tutors met to add ratings for the hints of the other tutors and to address discrepancies in the ratings.", "startOffset": 76, "endOffset": 82}, {"referenceID": 39, "context": "[40].", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "Again, we compare our system with the policy of Gross and Pinkwart [16] and the policy of Zimmerman and Rupakheti [50].", "startOffset": 67, "endOffset": 71}, {"referenceID": 49, "context": "Again, we compare our system with the policy of Gross and Pinkwart [16] and the policy of Zimmerman and Rupakheti [50].", "startOffset": 114, "endOffset": 118}, {"referenceID": 15, "context": "1-NN / [16] 1 0.", "startOffset": 7, "endOffset": 11}, {"referenceID": 49, "context": "[50] 0.", "startOffset": 0, "endOffset": 4}, {"referenceID": 40, "context": "which indicates that students are more likely to seek help and follow hints if early hints provided by the system were useful [41].", "startOffset": 126, "endOffset": 130}, {"referenceID": 1, "context": "After all, better hints from the view of a tutor may not always yield better learning outcomes, due to difficulties in sense-making or lack of prior knowledge on the student\u2019s side [2].", "startOffset": 181, "endOffset": 184}, {"referenceID": 43, "context": "With regards to future work, it appears promising to combine our proposed approach with other work presented in the literature, in particular canonicalization, state re-ification, unit tests and frequency information as suggested by Rivers and Koedinger [44], or more sophisticated edit distances as suggested by Mokbel et al.", "startOffset": 254, "endOffset": 258}, {"referenceID": 26, "context": "[27, 32, 40].", "startOffset": 0, "endOffset": 12}, {"referenceID": 31, "context": "[27, 32, 40].", "startOffset": 0, "endOffset": 12}, {"referenceID": 39, "context": "[27, 32, 40].", "startOffset": 0, "endOffset": 12}], "year": 2017, "abstractText": "Intelligent tutoring systems can support students in solving multistep tasks by providing a hint regarding what to do next. However, engineering such next-step hints manually or using an expert model becomes infeasible if the space of possible states is too large. Therefore, several approaches have emerged to infer next-step hints automatically, relying on past student\u2019s data. Such hints typically have the form of an edit which could have been performed by capable students in the given situation, based on what past capable students have done. In this contribution we provide a mathematical framework to analyze edit-based hint policies and, based on this theory, propose a novel hint 1 ar X iv :1 70 8. 06 56 4v 1 [ cs .A I] 2 2 A ug 2 01 7 Preprint as provided by the authors. 2 policy to provide edit hints for learning tasks with a vast state space and sparse student data. We call this technique the continuous hint factory because it embeds student data in a continuous space, in which the most likely edit can be inferred in a probabilistic sense, similar to", "creator": "LaTeX with hyperref package"}}}