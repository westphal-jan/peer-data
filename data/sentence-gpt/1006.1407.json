{"id": "1006.1407", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jun-2010", "title": "Begin, After, and Later: a Maximal Decidable Interval Temporal Logic", "abstract": "Interval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals, i.e., periods of time. The most famous ITL studied so far is Halpern and Shoham's HS, which is the logic of the thirteen Allen's interval relations. Unfortunately, HS and most of its fragments have an undecidable satisfiability problem. This discouraged the research in this area until recently, when a number non-trivial decidable ITLs have been discovered.\n\n\nIn his last two lectures, in the second issue of the book, Halpern argues that there is an unimportant problem in a given data set, and that there are no meaningful methods to measure it, and that we cannot know what data are supposed to be. However, this is not the case for the first time in the last two editions of his book. The first edition of his book, H.T.S., is not an example of a technique like this: we have to get our head around it first and then find out what it is.\nThe first version of H.T.S., published in 1967, is a collection of 12 books, each with some more than 2,500 sublayers. These sublayers are the most commonly used in the history of the first edition of the text. They are not always the first to incorporate the new techniques, and the last to use them, because the only method that is particularly useful is the simple definition of an interlocking chain between multiple data points and a single, consistent and coherent data point. It has also been suggested that some of the best generalists and writers of the period have written about it (E.g., Algebra of Time), but have instead focused on one idea of the work.\nAnother example of H.T.S., published in 1962, is a collection of 6 books, each with some more than 2,500 sublayers. These sublayers are the most commonly used in the history of the first edition of the text. They are not always the first to incorporate the new techniques, and the last to use them, because the only method that is particularly useful is the simple definition of an interlocking chain between multiple data points and a single, consistent and coherent data point. It has also been suggested that some of the best generalists and writers of the period have written about it (E.g., Algebra of Time), but have instead focused on one idea of the work", "histories": [["v1", "Tue, 8 Jun 2010 00:42:51 GMT  (33kb)", "http://arxiv.org/abs/1006.1407v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["davide bresolin", "pietro sala", "guido sciavicco"], "accepted": false, "id": "1006.1407"}, "pdf": {"name": "1006.1407.pdf", "metadata": {"source": "CRF", "title": "Begin, After, and Later: a Maximal Decidable Interval Temporal Logic", "authors": ["Angelo Montanari", "Margherita Napoli", "Mimmo Parente", "Davide Bresolin", "Pietro Sala", "Guido Sciavicco"], "emails": ["davide.bresolin@univr.it", "pietro.sala@univr.it", "guido@um.es"], "sections": [{"heading": null, "text": "Angelo Montanari, Margherita Napoli, Mimmo Parente (Eds.) Proceedings of GandALF 2010 EPTCS 25, 2010, pp. 72\u201388, doi:10.4204/EPTCS.25.10\nBegin, After, and Later: a Maximal Decidable Interval Temporal Logic\u2217\nDavide Bresolin University of Verona\nVerona, Italy davide.bresolin@univr.it\nPietro Sala University of Verona\nVerona, Italy pietro.sala@univr.it\nGuido Sciavicco University of Murcia\nMurcia, Spain guido@um.es\nInterval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals, i.e., periods of time. The most famous ITL studied so far is Halpern and Shoham\u2019s HS, which is the logic of the thirteen Allen\u2019s interval relations. Unfortunately, HS and most of its fragments have an undecidable satisfiability problem. This discouraged the research in this area until recently, when a number non-trivial decidable ITLs have been discovered. This paper is a contribution towards the complete classification of all different fragments of HS. We consider different combinations of the interval relations begins (B), after (A), later (L) and their inverses A, B and L. We know from previous works that the combinationABBA is decidable only when finite domains are considered (and undecidable elsewhere), and thatABB is decidable over the natural numbers. We extend these results by showing that decidability of ABB can be further extended to capture the language ABBL, which lies in between ABB and ABBA, and that turns out to be maximal w.r.t decidability over strongly discrete linear orders (e.g. finite orders, the naturals, the integers). We also prove that the proposed decision procedure is optimal with respect to the EXPSPACE complexity class."}, {"heading": "1 Introduction", "text": "Interval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals instead of points. The most famous ITL studied so far is probably Halpern and Shoham\u2019s HS [6], which is the logic of (the thirteen) Allen\u2019s interval relations between intervals [1]. It features a modal operator for each relation, that is after (\u3008A\u3009) (also called meets), begins (\u3008B\u3009), ends (\u3008E\u3009), overlaps (\u3008O\u3009), during (\u3008D\u3009), later (\u3008L\u3009), and their inverses (denoted by \u3008X\u3009, where \u3008X\u3009 is a modal operator), although some of them are definable in terms of others. Since HS is undecidable when interpreted over almost all interesting classes of linearly ordered sets, it is natural to ask whether there exist decidable fragments of it, and how the properties of the underlying linearly ordered domain can influence its decidable/undecidable status. In the literature, the classes of linear orderings that have received more attention are i) the class of all linearly ordered sets, ii) the set of all discrete linearly ordered sets, iii) the class of all dense linearly ordered sets. In the second case one can also distinguish among strong discreteness (i.e., N,Z-like), and weak discreteness (which allows non-standard models such as N+Z). In recent years, a number of papers have been published in which new, sometimes unexpected, decidable and undecidable fragments are presented. Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9]. Interestingly enough, the extension ABBA (and AEEA) turns out to be decidable only when finite models are considered, and undecidable as soon as an infinite ascending (resp., descending) chain is admitted\n\u2217This research was partly supported by the EU project FP7-ICT-223844 CON4COORD, by the Spanish-South African project HS2008-0006, by the Spanish MEC project TIN2009-14372-C03-01, and by the Italian GNCS project \u201dLogics, Automata, and Games for the formal verification of complex systems\u201d.\nin the model [7]. Other interesting fragments are BB and EE, that are decidable in most cases [5], while any other combination of the four operators B, B, E, and E immediately leads to undecidability [2]. Other combinations such as ABB, and the simpler AB, though, remain still uncovered.\nIn this paper, we present another piece of this complicated puzzle by considering also the Allen\u2019s relation later, that captures any interval starting at some point after the ending point of the current interval, and it can be defined as \u3008A\u3009\u3008A\u3009, and the inverse relation before. We will show that the logic ABBL (and the symmetric logic AEEL) is decidable and EXPSPACE-complete when interpreted over strongly discrete linear orders. It is worth emphasizing that adding any other non-definable Allen\u2019s relation to ABBL and to AEEL leads to undecidability over all considered structures, with the exception of A and A, respectively, which keep decidability only when finite models are considered (and cause undecidability over infinite models). Hence, our results shows also that ABBL and AEEL are maximal fragments of HS with respect to decidability in the class of all strongly discrete linear orders.\nThe structure of this paper is as follows. In Section 2 we introduce syntax and semantics of our logic. In Section 3, we deal with the decidability of the satisfiability problem over finite and infinite structures, while in Section 4 we discuss its complexity. Finally, in Section 5 we draw some conclusions and outline future research directions.\n2 The interval temporal logic ABBL\nIn this section, we briefly introduce syntax and semantics of the logicABBL, along with the basic notions of atom, type, and dependency. We conclude the section by providing an alternative interpretation of ABBL over labeled grid-like structures."}, {"heading": "2.1 Syntax and semantics", "text": "The logic ABBL features four modal operators \u3008A\u3009, \u3008B\u3009, \u3008B\u3009 and \u3008L\u3009, and it is interpreted in interval temporal structures over a strongly discrete linear order endowed with the four Allen\u2019s relations A (\u201cmeets\u201d), B (\u201cbegins\u201d), B (\u201cbegun by\u201d) and L (\u201cbefore\u201d). We recall that a linear order O = \u3008O,<\u3009 is strongly discrete if and only if there are only finitely many points between any pair of points x < y \u2208O. Example of strongly discrete linear orders are all finite linear orders, and the sets N and Z.\nGiven a set Prop of propositional variables, formulas of ABBL are built up from Prop using the boolean connectives \u00ac and \u2228 and the unary modal operators \u3008A\u3009, \u3008B\u3009, \u3008B\u3009, \u3008L\u3009. As usual, we shall take advantage of shorthands like \u03d51 \u2227 \u03d52 = \u00ac(\u00ac\u03d51 \u2228 \u00ac\u03d52), [A]\u03d5 = \u00ac\u3008A\u3009\u00ac\u03d5, [B]\u03d5 = \u00ac\u3008B\u3009\u00ac\u03d5, etc. Hereafter, we denote by |\u03d5| the size of \u03d5. Given any strongly discrete linear order O = \u3008O,<\u3009 we define IO as the set of all closed intervals [x,y], with x,y \u2208 O and x < y. For any pair of intervals [x,y], [x \u2032,y \u2032]\u2208 IO, the Allen\u2019s relations \u201cmeets\u201dA, \u201cbegins\u201d B, \u201cbegun by\u201d B, and \u201cbefore\u201d L are defined as follows:\n\u2022 \u201cmeets\u201d relation: [x,y]A [x \u2032,y \u2032] iff y= x \u2032;\n\u2022 \u201cbegins\u201d relation: [x,y] B [x \u2032,y \u2032] iff x= x \u2032 and y \u2032 < y;\n\u2022 \u201cbegun by\u201d relation: [x,y] B [x \u2032,y \u2032] iff x= x \u2032 and y < y \u2032;\n\u2022 \u201cbefore\u201d relation: [x,y] L [x \u2032,y \u2032] iff y \u2032 < x.\nGiven an interval structure S = (IO,A,B,B,L,\u03c3), where \u03c3 : IO \u2192 P(Prop) is a labeling function that maps intervals in IO to sets of propositional variables, and an initial interval I = [x,y], we define the semantics of an ABBL formula as follows:\n\u2022 S,I a iff a \u2208 \u03c3(I), for any a \u2208 Prop;\n\u2022 S,I \u00ac\u03d5 iff S,I 6 \u03d5;\n\u2022 S,I \u03d51 \u2228 \u03d52 iff S,I \u03d51 or S,I \u03d52;\n\u2022 for every relation R \u2208 {A,B,B,L}, S,I \u3008R\u3009\u03d5 iff there is an interval J \u2208 IO such that I R J and S,J \u03d5.\nGiven an interval structure S and a formula \u03d5, we say that S satisfies \u03d5 (and hence \u03d5 is satisfiable) if there is an interval I in S such that S,I \u03d5. Accordingly, we define the satisfiability problem for ABBL as the problem of establishing whether a given ABBL-formula \u03d5 is satisfiable.\nAs we have recalled in the Introduction, we have that S,I \u3008L\u3009\u03d5 iff S,I \u3008A\u3009\u3008A\u3009\u03d5, and thus that \u3008L\u3009 is definable in the language of ABBA. As a direct consequence of the decidability and complexity results proved in this paper, we have that the converse it is not true. Moreover, it is easy to see that the operator \u3008L\u3009 cannot be defined in the language of ABB: the modal operators \u3008A\u3009, \u3008B\u3009 and \u3008B\u3009 allow the language to see only intervals whose endpoints are greater or equals to the endpoints of the interval were a formula is interpreted. Hence, the logic ABBL is strictly more expressive than ABB and strictly less expressive than ABBA."}, {"heading": "2.2 Atoms, types, and dependencies", "text": "Let S = (IO,A,B,B,L,\u03c3) be an interval structure that satisfies the ABBL-formula \u03d5. In the sequel, we relate intervals in S with respect to the set of sub-formulas of\u03d5 they satisfy. To do that, we introduce the key notions of \u03d5-atom and \u03d5-type.\nFirst of all, we define the closure Cl(\u03d5) of \u03d5 as the set of all sub-formulas of \u03d5 and of their negations (we identify \u00ac\u00ac\u03b1 with \u03b1, \u00ac\u3008A\u3009\u03b1 with [A]\u00ac\u03b1, etc.). For technical reasons, we also introduce the extended closure Cl+(\u03d5), which is defined as the set of all formulas in Cl(\u03d5) plus all formulas of the forms \u3008R\u3009\u03b1 and \u00ac\u3008R\u3009\u03b1, with R\u2208 {A,B,B,L} and \u03b1\u2208 Cl(\u03d5). A\u03d5-atom is any non-empty set F\u2286 Cl+(\u03d5) such that (i) for every \u03b1 \u2208 Cl+(\u03d5), we have \u03b1 \u2208 F iff \u00ac\u03b1 6\u2208 F and (ii) for every \u03b3 = \u03b1 \u2228 \u03b2 \u2208 Cl+(\u03d5), we have \u03b3 \u2208 F iff \u03b1 \u2208 F or \u03b2 \u2208 F (intuitively, a \u03d5-atom is a maximal locally consistent set of formulas chosen from Cl+(\u03d5)). Note that the cardinalities of both sets Cl(\u03d5) and Cl+(\u03d5) are linear in the number |\u03d5| of sub-formulas of \u03d5, while the number of \u03d5-atoms is at most exponential in |\u03d5| (precisely, we have |Cl(\u03d5)| = 2|\u03d5|, |Cl+(\u03d5)| = 18|\u03d5|, and there are at most 28|\u03d5| distinct atoms). We define A\u03d5 as the set of all possible atoms that can be built over Cl+(\u03d5).\nWe associate with each interval I \u2208 S the set of all formulas \u03b1 \u2208 Cl+(\u03d5) such that S,I \u03b1. Such a set is called \u03d5-type of I and it is denoted by TypeS(I). We have that every \u03d5-type is a \u03d5-atom, but not vice versa. Hereafter, we shall omit the argument \u03d5, thus calling a \u03d5-atom (resp., a \u03d5-type) simply an atom (resp., a type). Given an atom F, we denote by Obs(F) the set of all observable of F, namely, the formulas \u03b1 \u2208 Cl(\u03d5) such that \u03b1 \u2208 F. Similarly, given an atom F and a relation R \u2208 {A,B,B,L}, we denote by ReqR(F) the set of all R-requests of F, namely, the formulas \u03b1 \u2208 Cl(\u03d5) such that \u3008R\u3009\u03b1 \u2208 F. Taking advantage of the above sets, we can define the following three relations between two atoms F and G:\nF A\u2212\u2192G iff ReqA(F) = Obs(G) \u222a ReqB(G) \u222a ReqB(G)\nF B\u2212\u2192G iff\n \n\nObs(F) \u222a ReqB(F) \u2286 ReqB(G) \u2286 Obs(F) \u222a ReqB(F) \u222a ReqB(F)\nObs(G) \u222a ReqB(G) \u2286 ReqB(F) \u2286 Obs(G) \u222a ReqB(G) \u222a ReqB(G)\nReqL(F) = ReqL(G).\nF L\u2212\u2192G iff Obs(G)\u222aReqL(G) \u2286 ReqL(F)\nNote that the relations B\u2212\u2192 and L\u2212\u2192 are transitive, while A\u2212\u2192 is not. Moreover, all A\u2212\u2192 , B\u2212\u2192 and L\u2212\u2192 satisfy a view-to-type dependency, namely, for every pair of intervals I,J in S, we have that\nI A J implies TypeS(I) A\u2212\u2192 TypeS(J) I B J implies TypeS(I) B\u2212\u2192 TypeS(J)\nI L J implies TypeS(I) L\u2212\u2192 TypeS(J)."}, {"heading": "2.3 Compass structures", "text": "The logicABBL can be equivalently interpreted over grid-like structures (hereafter called compass structures) by exploiting the existence of a natural bijection between the intervals I = [x,y] and the points p = (x,y) of an O\u00d7O grid such that x < y. As an example, in Fig. 1 are shown five intervals I0, ...,I4, such that I0 B I1, I0 B I2, I0 A I3, and I0 L I4, together with the corresponding points p0, ...,p4 of a grid (note that the four Allen\u2019s relations A,B,B,L between intervals are mapped to the corresponding spatial relations between points; for the sake of readability, we name the latter ones as the former ones).\nDEFINITION 1. Given anABBL formula \u03d5, a (consistent and fulfilling) compass (\u03d5-)structure is a pair G = (PO,L), where PO is the set of points of the form p = (x,y), with x,y \u2208 O and x < y, and L is function that maps any point p \u2208 PO to a (\u03d5-)atom L(p) in such a way that:\n\u2022 for every pair of points p,q\u2208PO and every relation R\u2208 {A,B,L}, if pRq holds, then L(p) R\u2212\u2192L(q) follows (consistency);\n\u2022 for every point p \u2208 PO, every relation R \u2208 {A,B,B,L}, and every formula \u03b1 \u2208 ReqR ( L(p) )\n, there is a point q \u2208 PO such that p R q and \u03b1 \u2208 Obs ( L(q) ) (fulfillment).\nWe say that a compass (\u03d5-)structure G= (PO,L) features a formula \u03b1 if there is a point p\u2208 PO such that \u03b1 \u2208L(p). The following proposition implies that the satisfiability problem for ABBL is reducible to the problem of deciding, for any given formula \u03d5, whether there exists a \u03d5-compass structure featuring \u03d5.\nPROPOSITION 2. AnABBL-formula \u03d5 is satisfied by some interval structure if and only if it is featured by some (\u03d5-)compass structure.\n3 Deciding the satisfiability problem for ABBL\nIn this section, we prove that the satisfiability problem for ABBL is decidable by providing a \u201csmallmodel theorem\u201d for the satisfiable formulas of the logic. For the sake of simplicity, we first show that the satisfiability problem for ABBL interpreted over finite interval structures is decidable and then we generalize such a result to all (finite or infinite) interval structures based on strong discrete linear orders.\nAs a preliminary step, we introduce the key notions of shading, of witness set, and of compatibility between rows of a compass structure. Let G= (PO,L) be a compass structure and let y\u2208O. The shading of the row y of G is the set ShadingG(y) = { L(x,y) : x< y } , namely, the set of the atoms of all points in PO whose vertical coordinate has value y (basically, we interpret different atoms as different colors). A witness set for y is any minimal set Wit(y)\u2286 {(x\u03c8,y\u03c8) : x\u03c8<y\u03c8\u2227y\u03c8>y} that respects the following property:\n(WIT) for every \u03c8 \u2208 Cl(\u03d5) that appears in the labeling of some point (x \u2032,y \u2032) with y \u2032 > y, there exists a witness (x\u03c8,y\u03c8) \u2208Wit(y) such that\n1. \u03c8 \u2208 L(x\u03c8,y\u03c8) , and 2. y\u03c8 is minimal, that is, for all (x \u2032,y \u2032) with y < y \u2032 < y\u03c8, \u00ac\u03c8 \u2208L(x \u2032,y \u2032).\nSince Wit(y) is minimal we have that there is at most one distinct point for every \u03c8 \u2208 Cl(\u03d5) and thus |Wit(y)| < |Cl(\u03d5)| = 2 \u00b7 |\u03d5|. Intuitively, a witness set for a row y is a set that contains, for every formula \u03c8 that occurs in some point above the row y, a witness (x\u03c8,y) for it, that is, a point that satisfies \u03c8 at the minimum possible distance from the row y. The notion of shading and of witness set allow us to determine whether two rows are compatible or not.\nLet P \u2286 PO a set of points and y be a coordinate we define \u03c0y(P) = {x : (x,y) \u2208 P\u2227x < y)}, the set of all x-coordinate belonging to points in P which are smaller than y.\nDEFINITION 3. Given a compass structure G and two rows y0 < y1, we say that y0 and y1 are compatible if and only if the following properties holds:\n1. ShadingG(y0) = ShadingG(y1); 2. L(y0 \u22121,y0) = L(y1 \u22121,y1);\n3. there exists a witness set Wit(y1) for y1 and an injective mapping function w : \u03c0y1(Wit(y1)) 7\u2192 {x : x < y0} s.t. L(x,y1) = L(w(x),y0) for every x \u2208 \u03c0y1(Wit(y1)), that assigns a distinct xcoordinate on the row y0 for every witness (x\u03c8,y\u03c8) in Wit(y1) with x\u03c86 y1.\nIn the following, we will show how the properties of compatible rows can be used to contract compass structures to smaller ones, first for finite models and then for infinite ones."}, {"heading": "3.1 A small-model theorem for finite structures", "text": "Let \u03d5 be an ABBL formula. It is easy to see that \u03d5 is satisfiable over a finite model if and only if the formula \u03d5\u2228 \u3008B\u3009\u03d5\u2228 \u3008A\u3009\u03d5\u2228 \u3008A\u3009\u3008A\u3009\u03d5 is featured by the initial point (0,1) a finite compass structure G= (PO,L). We prove that we can restrict our attention to compass structures G= (PO,L) with a number of points in O bounded by a double exponential in |\u03d5|. We start with the following lemma that proves two simple, but crucial, properties of the relations A\u2212\u2192 , B\u2212\u2192 , and L\u2212\u2192 .\nLEMMA 4. Let F,G,H be some atoms:\n1. if F A\u2212\u2192H and G B\u2212\u2192H hold, then F A\u2212\u2192G holds as well;\n2. if F B\u2212\u2192G and G L\u2212\u2192H hold, then F L\u2212\u2192H holds as well.\nProof. The proof for property 1 can be found in [8]. As for property 2, we have that, by the definition of B\u2212\u2192 , if F B\u2212\u2192G then ReqL(F) =ReqL(G). This implies that Obs(H)\u222aReqL(H)\u2286ReqL(F) and thus F L\u2212\u2192H holds as well. \u2737\nThe next lemma shows that, under suitable conditions, a given compass structure G may be reduced in length, preserving the existence of atoms featuring \u03d5.\nLEMMA 5. Let G be a finite compass structure of size N featuring \u03d5 on the initial point (0,1). If there exist two compatible rows 0 < y0 < y1 < N in G, then there exists a compass structure G \u2032 of size N \u2032 =N\u2212y1 +y0 that features \u03d5.\nProof. Suppose that 0 < y0 < y1 < N are two compatible rows of G. By definition, we have that ShadingG(y0) = ShadingG(y1), L(y0 \u2212 1,y0) = L(y1 \u2212 1,y1), and there exists a witness set Wit(y1) for y1 and an injective mapping function w : \u03c0y1(Wit(y1)) 7\u2192 {x : x < y0} that assigns a distinct xcoordinate on the row y0 for every witness (x\u03c8,y\u03c8) in Wit(y1) with x\u03c8 6 y1. Then, we can define a function f : {0, ...,y0 \u22121} 7\u2192 {0, ...,y1\u22121} such that, for every 0 6 x < y0, L(x,y0) =L(f(x),y1) and for every (x\u03c8,y\u03c8) \u2208Wit(y1) if x\u03c8< y1 then f(w(x\u03c8)) = x\u03c8.\nLet k= y1 \u2212y0,N \u2032 =N\u2212k (<N), O \u2032 = \u3008{0, . . . ,N \u2032\u22121},<\u3009, and PO \u2032 be the correspondent portion of the grid. We extend f to a function that maps points in PO \u2032 to points in PO as follows:\n\u2022 if p= (x,y), with 0 6 x < y < y0, then we simply let f(p) = p;\n\u2022 if p= (x,y), with 0 6 x < y0 6 y, then we let f(p) = (f(x),y+k);\n\u2022 if p= (x,y), with y0 6 x < y, then we let f(p) = (x+k,y+k).\nWe denote by L \u2032 the labeling of PO \u2032 such that, for every point p \u2208 PO \u2032 , L \u2032(p) =L(f(p)) and we denote by G \u2032 the resulting structure (PO \u2032 ,L \u2032) (see Figure 2). We have to prove that G \u2032 is a consistent and fulfilling compass structure that features \u03d5. First, we show that G \u2032 satisfies the consistency conditions for the relations B, A, and L; then we show that G \u2032 satisfies the fulfillment conditions for the B-, B-, A, and L-requests; finally, we show that G \u2032 features \u03d5.\nCONSISTENCY WITH RELATION B. Consider two points p = (x,y) and p \u2032 = (x \u2032,y \u2032) in G \u2032 such that p B p \u2032, i.e., 0 6 x = x \u2032 < y \u2032 < y < N \u2032. We prove that L \u2032(p) B\u2212\u2192L \u2032(p \u2032) by distinguishing among the following three cases (note that exactly one of such cases holds):\n1. y < y0 and y \u2032 < y0, 2. y> y0 and y \u2032 > y0, 3. y> y0 and y \u2032 < y0.\nIf y < y0 and y \u2032 < y0, then, by construction, we have f(p) = p and f(p \u2032) = p \u2032. Since G is a (consistent) compass structure, we immediately obtain L \u2032(p) = L(p) B\u2212\u2192L(p \u2032) = L \u2032(p \u2032).\nIf y > y0 and y > y0, then, by construction, we have either f(p) = (f(x),y+ k) or f(p) = (x+ k,y+k), depending on whether x < y0 or x > y0. Similarly, we have either f(p \u2032) = (f(x \u2032),y \u2032+k) = (f(x),y \u2032+k) or f(p \u2032) = (x \u2032+k,y \u2032+k) = (x+k,y \u2032+k). This implies f(p) B f(p \u2032) and thus, since G is a (consistent) compass structure, we have L \u2032(p) = L(f(p)) B\u2212\u2192 L(f(p \u2032)) = L \u2032(p \u2032).\nIf y > y0 and y \u2032 < y0, then, since x < y \u2032 < y0, we have by construction f(p) = (f(x),y+ k) and f(p \u2032) = p \u2032. Moreover, if we consider the point p \u2032\u2032 = (x,y0) in G \u2032, we easily see that (i) f(p \u2032\u2032) = (f(x),y1), (ii) f(p) B f(p \u2032\u2032) (whence L(f(p)) B\u2212\u2192L(f(p \u2032\u2032))), (iii) L(f(p \u2032\u2032)) = L(p \u2032\u2032), and (iv) p \u2032\u2032 B p \u2032 (whence L(p \u2032\u2032) B\u2212\u2192L(p \u2032)). It thus follows that L \u2032(p) = L(f(p)) B\u2212\u2192L(f(p \u2032\u2032)) = L(p \u2032\u2032) B\u2212\u2192 L(p \u2032) = L(f(p \u2032))=L \u2032(p \u2032). Finally, by exploiting the transitivity of the relation B\u2212\u2192 , we obtain L \u2032(p) B\u2212\u2192L \u2032(p \u2032).\nG\nCONSISTENCY WITH RELATION A. Consider two points p= (x,y) and p \u2032 = (x \u2032,y \u2032) such that pA p \u2032, i.e., 0 6 x < y = x \u2032 < y \u2032 <N \u2032. We define p \u2032\u2032 = (y,y+1) in such a way that p A p \u2032\u2032 and p \u2032 B p \u2032\u2032 and we distinguish between the following two cases:\n1. y> y0,\n2. y < y0.\nIf y> y0, then, by construction, we have f(p)A f(p \u2032\u2032). Since G is a (consistent) compass structure, it follows that L \u2032(p) = L(f(p)) A\u2212\u2192 L(f(p \u2032\u2032)) = L \u2032(p \u2032\u2032).\nIf y < y0, then, by construction, we have L(p \u2032\u2032) = L(f(p \u2032\u2032)). Again, since G is a (consistent) compass structure, it follows that L \u2032(p) = L(f(p)) = L(p) A\u2212\u2192 L(p \u2032\u2032) = L(f(p \u2032\u2032)) = L \u2032(p \u2032\u2032).\nIn both cases we have L \u2032(p) A\u2212\u2192L \u2032(p \u2032\u2032). Now, we recall that p \u2032 B p \u2032\u2032 and that, by previous arguments, G \u2032 is consistent with the relation B. We thus have L \u2032(p \u2032) B\u2212\u2192L \u2032(p \u2032\u2032). Finally, by applying Lemma 4, we obtain L \u2032(p) A\u2212\u2192L \u2032(p \u2032).\nCONSISTENCY WITH RELATION L. Consider two points p = (x,y) and p \u2032 = (x \u2032,y \u2032) in G \u2032 such that p L p \u2032, i.e., 0 6 x \u2032 < y \u2032 < x < y < N \u2032. We prove that L \u2032(p) L\u2212\u2192L \u2032(p \u2032) by distinguishing among the following three cases (note that exactly one of such cases holds):\n1. y < y0 and y \u2032 < y0, 2. y> y0 and y \u2032 > y0, 3. y> y0 and y \u2032 < y0.\nIf y < y0 and y \u2032 < y0, then, by construction, we have f(p) = p and f(p \u2032) = p \u2032. Since G is a (consistent) compass structure, we immediately obtain L \u2032(p) = L(p) L\u2212\u2192L(p \u2032) = L \u2032(p \u2032).\nIf y> y0 and y \u2032 > y0, then, by construction, we have either f(p \u2032) = (f(x \u2032),y \u2032+k) or f(p \u2032) = (x \u2032+ k,y \u2032+k), depending on whether x \u2032 < y0 or x \u2032 > y0. Since y0 6 y \u2032 < x, we have f(p) = (x+k,y+k). This implies f(p) L f(p \u2032) and thus, since G is a (consistent) compass structure, we have L \u2032(p) =L(f(p)) L\u2212\u2192 L(f(p \u2032)) = L \u2032(p \u2032).\nIf y> y0 and y \u2032 <y0, then, we have by construction that f(p \u2032) = p \u2032 and either f(p) = (x+k,y+k) or f(p) = (f(x),y+ k). In the former case we have that f(p) L f(p \u2032) and thus, since G is a consistent\ncompass structure, L \u2032(p) = L(f(p)) L\u2212\u2192L(f(p \u2032)) = L \u2032(p \u2032). In the latter case it is not necessarily true that y \u2032 < f(x). Consider the points p \u2032\u2032 = (f(x),y1) and p \u2032\u2032\u2032 = (x,y0): by the definition of f, L(p \u2032\u2032) = L(p \u2032\u2032\u2032). Moreover, we have that f(p)Bp \u2032\u2032 and p \u2032\u2032\u2032Lf(p \u2032) = p \u2032. Since G is a consistent compass structure, this implies that L \u2032(p) = L(f(p)) B\u2212\u2192L(p \u2032\u2032) = L(p \u2032\u2032\u2032) L\u2212\u2192L(f(p \u2032)) = L \u2032(p \u2032). Finally, by applying Lemma 4, we obtain L \u2032(p) L\u2212\u2192L \u2032(p \u2032).\nFULFILLMENT OF B-REQUESTS. Consider a point p=(x,y) in G \u2032 and someB-request \u03b1\u2208ReqB ( L \u2032(p) ) associated with it. Since, by construction, \u03b1 \u2208 ReqB ( L(f(p)) )\nand G is a (fulfilling) compass structure, we know that G contains a point q \u2032 = (x \u2032,y \u2032) such that f(p)B q \u2032 and \u03b1 \u2208Obs ( L(q \u2032) ) . We prove that G \u2032 contains a point p \u2032 such that p B p \u2032 and \u03b1 \u2208 Obs ( L \u2032(p \u2032) )\nby distinguishing among the following three cases (note that exactly one of such cases holds):\n1. y < y0 2. y \u2032 > y1, 3. y> y0 and y \u2032 < y1.\nIf y < y0, then, by construction, we have p = f(p) and q \u2032 = f(q \u2032). Therefore, we simply define p \u2032 = q \u2032 in such a way that p= f(p) B q \u2032 = p \u2032 and \u03b1 \u2208Obs ( L \u2032(p \u2032) ) (=Obs ( L(f(p \u2032)) ) =Obs ( L(q \u2032) )\n). If y \u2032 > y1, then, by construction, we have either f(p) = (f(x),y+k) or f(p) = (x+k,y+k), depending on whether x<y0 or x> y0. We define p \u2032 = (x,y \u2032\u2212k) in such a way that pBp \u2032. Moreover, we observe that either f(p \u2032) = (f(x),y \u2032) or f(p \u2032) = (x+k,y \u2032), depending on whether x < y0 or x> y0, and in both cases f(p \u2032) = q \u2032 follows. This shows that \u03b1 \u2208 Obs ( L \u2032(p \u2032) ) (= Obs ( L(f(p \u2032) ) = Obs ( L(q \u2032) )\n). If y > y0 and y \u2032 < y1, then we define p = (x,y0) and q = (x \u2032,y1) and we observe that f(p) B q,\nq B q \u2032, and f(p) = q. From f(p) B q and q B q \u2032, it follows that \u03b1 \u2208 ReqB ( L(q) )\nand hence \u03b1 \u2208 ReqB ( L(p) )\n. Since G is a (fulfilling) compass structure, we know that there is a point p \u2032 such that p B p \u2032 and \u03b1 \u2208 Obs ( L(p \u2032) ) . Moreover, since p B p \u2032, we have f(p \u2032) = p \u2032, from which we obtain p B p \u2032 and \u03b1 \u2208 Obs ( L(p \u2032) ) .\nFULFILLMENT OF B-REQUESTS. The proof that G \u2032 fulfills all B-requests of its atoms is symmetric with respect to the previous one.\nFULFILLMENT OFA-REQUESTS. Consider a point p=(x,y) in G \u2032 and someA-request\u03b1\u2208ReqA ( L \u2032(p) ) associated with p in G \u2032. Since, by previous arguments, G \u2032 fulfills all B-requests of its atoms, it is sufficient to prove that either \u03b1 \u2208 Obs ( L \u2032(p \u2032) )\nor \u03b1 \u2208 ReqB ( L \u2032(p \u2032) ) , where p \u2032 = (y,y+ 1). This can be easily proved by distinguishing among the three cases y < y0 \u22121, y= y0 \u22121, and y> y0.\nFULFILLMENT OF L-REQUESTS. Consider a point p= (x,y) in G \u2032 and some L-request \u03b1\u2208ReqL ( L \u2032(p) ) associated with it. Since, by construction, \u03b1 \u2208 ReqL ( L(f(p)) )\nand G is a (fulfilling) compass structure, we know that G contains a point q \u2032 = (x \u2032,y \u2032) such that f(p) L q \u2032 and \u03b1 \u2208 Obs ( L(q \u2032) )\n. To simplify the proofs, we assume that q \u2032 is minimal with respect to the vertical coordinate, that is, for every other point q \u2032\u2032 = (x \u2032\u2032,y \u2032\u2032) with y \u2032\u2032 < y \u2032, \u03b1 6\u2208 Obs ( L(q \u2032\u2032) ) . We prove that G \u2032 contains a point p \u2032 such that p L p \u2032 and \u03b1 \u2208 Obs ( L \u2032(p \u2032) )\nby distinguishing among the following five cases (note that exactly one of such cases holds):\n1. y6 y0,\n2. x < y0 and y> y0, 3. x> y0 and y \u2032 < y1, 4. x> y0 and y \u2032 = y1, 5. x> y0 and y \u2032 > y1.\nIf y < y0, then, by construction, we have p = f(p) and q \u2032 = f(q \u2032). Therefore, we simply define p \u2032 = q \u2032 in such a way that p= f(p) L q \u2032 = p \u2032 and \u03b1 \u2208Obs ( L \u2032(p \u2032) ) (=Obs ( L(f(p \u2032)) ) =Obs ( L(q \u2032) )\n). If x < y0 and y > y0 then f(p) = (f(x),y+ k). Now, consider the point p \u2032\u2032 = (f(x),y1): since f(p)Bp \u2032\u2032 and G is a consistent compass structure, we have that ReqL(p \u2032\u2032) = ReqL(f(p)). By definition of f, we have that L(f(x),y1) =L(x,y0) and thus, since G is fulfilling, there exists a point p \u2032 = (x \u2032\u2032,y \u2032\u2032) such that y \u2032\u2032 < x and \u03b1 \u2208 Obs ( L(p \u2032) ) . Since f(p \u2032) = p \u2032, this shows that \u03b1 \u2208 Obs ( L \u2032(p \u2032) )\nas well. If x > y0 and y \u2032 < y1 then f(p) = (x+ k,y+ k). Since G is a consistent compass structure, we have that \u03b1 \u2208 ReqL(L(y1 \u22121,y1)). By the definition of compatible rows, we have that L(y1 \u22121,y1) = L(y0 \u2212 1,y0) and thus (by the minimality assumption) y \u2032 < y0 and q \u2032 = f(q \u2032). Therefore, we simply define p \u2032 = q \u2032 in such a way that p L q \u2032 = p \u2032 and \u03b1 \u2208 Obs ( L \u2032(p \u2032) ) (= Obs ( L(f(p \u2032)) ) =Obs ( L(q \u2032) )\n). If x> y0 and y \u2032 = y1 then L(q \u2032)\u2208 ShadingG(y1). By the definition of compatible rows, we have that ShadingG(y1) = ShadingG(y0) and thus there must exists a point q \u2032\u2032=(x \u2032\u2032,y0) such that L(q \u2032) =L(q \u2032\u2032) and y0 < y \u2032, against the hypothesis that q \u2032 is a minimal point satisfying \u03b1. Hence, this case cannot happen.\nIf x > y0 and y \u2032 > y1 then, by the minimality assumption on q \u2032 we have that for every y \u2032\u2032 < y \u2032, \u03b1 6\u2208Obs ( L(x \u2032\u2032,y \u2032\u2032) )\nfor any x \u2032\u2032 <y \u2032\u2032. Hence, by the definition of witness set, we have that there exists a witness (x\u03b1,y\u03b1)\u2208Wit(y1) such that \u03b1\u2208Obs ( L(x\u03b1,y\u03b1) )\nand y\u03b1 = y \u2032 (by the minimality assumption). If x\u03b1>y1 then we define p \u2032=(x\u03b1\u2212k,y\u03b1\u2212k). Otherwise, x\u03b1<y1 and by the definition of the mapping function w and of the function f, we have that f(w(x\u03b1)) = x\u03b1: we define p \u2032 = (w(x\u03b1),y \u2032\u2212k). In both cases we have that f(p \u2032) = (x\u03b1,y\u03b1), pLp \u2032 and \u03b1 \u2208 Obs ( L \u2032(p \u2032) ) .\nFEATURED FORMULAS. Recall that, by previous assumptions, \u03d5 \u2208 L(0,1). Since our contraction procedure never changes the labelling of the initial point, \u03d5 \u2208 L \u2032(0,1) as well. \u2737\nOn the grounds of the above result, we can provide a suitable upper bound for the length of a minimal finite interval structure that satisfies \u03d5, if there exists any. This yields a straightforward, but inefficient, 2NEXPTIME algorithm that decides whether a given ABBL-formula \u03d5 is satisfiable over finite interval structures.\nTHEOREM 6. AnABBL-formula \u03d5 is satisfied by some finite interval structure iff it is featured by some compass structure of length N6 (8|\u03d5|+15)2 32|\u03d5|+56 \u00b7232|\u03d5|+56 (i.e., double exponential in |\u03d5|).\nProof. Suppose that \u03d5 is satisfied by a finite interval structure S, and let \u03be = \u03d5\u2228 \u3008B\u3009\u03d5\u2228 \u3008A\u3009\u03d5\u2228 \u3008A\u3009\u3008A\u3009\u03d5. By Proposition 2, there is a compass structure G that features \u03be on the initial point and has finite length N. By Lemma 5, we can assume without loss of generality that all rows of G are pairwise incompatible. We recall from Section 2.2 that G contains at most 28|\u03be| distinct atoms. For every row y of the compass structure and every atom F \u2208A\u03be, let #(F,y) be the cardinality of the set {(x,y) : x < y and L(x,y) = F}. We associate to every row y of the structure a characteristic function cy :A\u03be 7\u2192 N defined as follows:\ncy(F) =\n{ #(F,y) #(F,y) 6 2|\u03be|\n2|\u03be| otherwise (1)\nSince any witness set Wit(y) contains at most 2|\u03be| witnesses, it is easy to see that two rows y0 and y1 with the same characteristic function and such that L(y0 \u2212 1,y0) = L(y1 \u2212 1,y1) are compatible. The number of possible characteristic functions is bounded by (2|\u03be|+1)2 8|\u03be| , and thus G cannot have more than (2|\u03be|+ 1)2 8|\u03be| \u00b7 28|\u03be| rows. Since |\u03be| = 4|\u03d5|+ 7 we can conclude that N 6 (8|\u03d5|+ 15)2 32|\u03d5|+56\n\u00b7 232|\u03d5|+56, and thus double exponential in |\u03d5|. \u2737"}, {"heading": "3.2 A small-model theorem for infinite structures", "text": "In general, compass structures that feature \u03d5 may be infinite. Here, we prove that, without loss of generality, we can restrict our attention to sufficiently \u201cregular\u201d infinite compass structures, which can be represented in double exponential space with respect to |\u03d5|. To do that, we introduce the notion of compass structure generator, that is, of a finite compass structure featuring \u03d5 that can be extended to an infinite fulfilling one.\nDEFINITION 7. We say that a finite compass structure G= (PO,L) of size N is partially fulfilling if for every point (x,y) \u2208 PO such that y < N\u2212 1, for every relation R \u2208 {A,B,B,L}, and for every formula \u03c8 \u2208 ReqR(L(p)), one of the following conditions hold:\n1. there exists a point p \u2032 \u2208 PO such that p R p \u2032 and \u03c8 \u2208 Obs(L(p \u2032)) (\u03c8 is fulfilled in p \u2032),\n2. R= B and \u03c8 \u2208 ReqB(L(x,N\u22121)), 3. R=A and \u03c8 \u2208ReqB(L(y,N\u22121)), 4. R= L and \u03c8 \u2208 ReqL(L(0,1)).\nNotice that all B-requests are fulfilled in a partially fulfilling compass structure and that B, A, and L requests are either fulfilled or \u201ctransferred to the border\u201d of the compass structure. Moreover, any substructure G \u2032 of a fulfilling compass structure G is partially fulfilling.\nDEFINITION 8. Given a finite compass structure G = (PO,L) and a row y, a future witness set for y is any minimal set FutWit(y) \u2286 {x : x < y} such that for every F \u2208 ShadingG(y) there exists a witness xF \u2208 FutWit(y) that respects the following properties:\n1. L(xF,y) = F, 2. for every \u03c8 \u2208 ReqB(F) there exists a point (xF,y \u2032) \u2208 G with y \u2032 > y and \u03c8 \u2208 Obs(L(xF,y)).\nSince FutWit(y) is minimal, we have that for every F \u2208 Shading(y) there is exactly one witness xF in FutWit(y). Hence, |FutWit(y))|6 28|\u03d5|.\nDEFINITION 9. Given a finite compass structure G = (PO,L) and a row y, a past witness set for y is any minimal set PastWit(y) \u2286 PO such that for every request \u03c8 \u2208 ReqL(Obs(L(y\u2212 1,y)) there exists a witness (x\u03c8,y\u03c8) such that \u03c8 \u2208 Obs(L(x\u03c8,y\u03c8)) and y\u03c8< y\u22121.\nAgain, by the minimality of PastWit(y) we have that there is at most one distinct point for every Lformula in L(y\u22121,y) and thus |PastWit(y)| 6 |ReqL(y\u22121,y)|6 |Cl(\u03d5)| 6 2 \u00b7 |\u03d5|.\nWe concentrate our attention on infinite structures that are unbounded both on the future and on the past (i.e., based on the set of integers Z). The case when the structure is unbounded only in one direction (e.g., the naturals N or the set of negative integers Z\u2212) can be tackled in a similar way by appropriately adapting the following notions and theorems.\nDEFINITION 10. Given an ABBL formula \u03d5 and a finite, partially fulfilling compass structure G = (PO,L) of size N, we say that G is a compass generator for \u03d5 if there exists four rows y\u03d5, y0, y1, and y2 which satisfy the following properties:\nG1 y0 < y1 < y2 and y0 6 y\u03d5,\nG2 \u03d5 \u2208 L(y\u03d5\u22121,y\u03d5) or \u3008B\u3009\u03d5 \u2208 L(y\u03d5\u22121,y\u03d5),\nG3 Shading(y1)\u2286 Shading(y0) and L(y0 \u22121,y0) = L(y1 \u22121,y1),\nG4 there exists a past witness set PastWit(y1) such that y0 6 min(\u03c0y1(PastWit(y1))),\nG5 Shading(N\u22121)\u2286 Shading(y2) and L(y2 \u22121,y2) = L(N\u22122,N\u22121),\nG6 there exists a future witness set FutWit(y2) for y2.\nThe next theorem shows that the information contained in a compass generator for \u03d5 is sufficient to build an infinite fulfilling compass structure featuring \u03d5.\nTHEOREM 11. An ABBL formula \u03d5 is satisfiable over the integers Z if and only if there exists a compass generator G= (PO,L) for \u03d5.\nProof. (\u21d2) Let \u03d5 an ABBL formula that is satisfiable over an infinite fulfilling compass structure G = (PZ,L). Since G features \u03d5 we have that there exists a point (x,y) with \u03d5 \u2208 L(x,y) and thus the row y\u03d5 = x+1 respects condition G2.\nNow, let Inf (G) be the set of shadings that occurs infinitely often in G. We define y1 as the greatest row such that for every y \u2032 6 y1, Shading(y \u2032) \u2208 Inf (G), and y2 as the smallest row such that for every y \u2032 > y2, Shading(y \u2032) \u2208 Inf (G). Clearly, since G is unbounded in the past, we can find two rows ymin and y0 such that ymin < y0, and a corresponding portion of the grid Pymin = {(x,y) : x> ymin} such that (i) y0 6 y\u03d5, (ii) y0 < y1, (iii) Shading(y1) \u2286 Shading(y0) in Pymin , (iv) L(y0 \u2212 1,y0) = L(y1 \u2212 1,y1), and (v) there exists a past witness set PastWit(y1) for y1 such that y0 6 min(\u03c0y1(PastWit(y1))) in Pymin . Hence, conditions G3 and G4 are respected.\nSymmetrically, since G is unbounded in the future, we can find a row ymax>y2 and a corresponding portion of the grid Pymaxymin = {(x,y) : x> ymin\u2227y6 ymax} such that\n1. Shading(ymax)\u2286 Shading(y2), 2. L(y2 \u22121,y2) = L(ymax\u22121,ymax), and 3. there exists a future witness set FutWit(y2) for y2 in P ymax ymin .\nThis shows that conditions G5 and G6 are respected as well. Since y0 6 y\u03d5 and y0 <y1 < y2 condition G1 is also respected. Since the restriction of G to the finite grid Pymaxymin is a partially fulfilling compass structure, we have found the required compass generator for \u03d5.\n(\u21d0) Let G = (PO,L) be a compass generator of size N for \u03d5 and let y0 < y1 < y2 and y\u03d5 be the four rows that satisfy properties G1\u2013G6 of Definition 10. We will define an infinite sequence of partially fulfilling compass structures G0 \u2282 G1 \u2282 G2 \u2282 . . . such that the infinite union G\u03c9 = \u22c3+\u221e i=0 Gi is an infinite fulfilling compass structure that features \u03d5. We start from the initial compass structure G0 = (P0,L0) where P0 = {(x,y)\u2208 PO : x> y0\u22121\u2227y0 6 y <N} and L0(x,y) =L(x,y) for every point (x,y) \u2208 P0O, and we will show how to iteratively build the infinite sequence of compass structures. For every step i of the procedure, let Gi = (Pi,Li) be the current structure, and let yimin and y i max be the minimum and maximum vertical coordinate in Pi, respectively. We guarantee that the following invariant is respected:\n(INV) ShadingGi(y i max)\u2286 ShadingG(y2),\nShadingGi(y i min+y1 \u2212y0)\u2286 ShadingG(y0), Li(yimax\u22121,y i max) = L(y2 \u22121,y2), and L i(yimin\u22121,y i min) = L(y0 \u22121,y0).\nThe invariant trivially holds for G0. Now, suppose that Gi respects (INV) and let kpast = y1 \u2212y0 and kfuture = N\u2212 y2. Figure 3 depicts how Gi+1 = (Pi+1,Li+1) can be built from Gi. Formally, the procedure is defined as follows.\na) yi+1min = y i min\u2212kpast, y i+1 max = y i max+kfuture, and P i+1 = {(x,y) \u2208 PZ : x > y i+1 min\u2212 1\u2227\nyi+1min 6 y < y i+1 max}.\nb) for every point p \u2208 Pi+1 \u2229Pi, let Li+1(p) =Li(p).\ny0\ny1\nN\u22121\ny2\nthat ShadingGi(y i max) \u2286 ShadingG (y2). Then there exists a point x \u2208 FutWit(y2) such that Li+1(x,yimax) =L(x,y2). We define L i+1(x,yimax+j)=L(x,y2+j) for every 16 j6 kfuture.\nIt is easy to see that Gi is a partially fulfilling compass structure that respects the invariant. Moreover, suppose that for some point p= (x,y) \u2208 Pi and relation R \u2208 {A,B,B,L} there exists \u03b1 \u2208ReqR(p) that is not fulfilled in Gi. We show that Gi+1 fulfills the R-request \u03b1 for p.\n\u2022 If R =A, since Gi is partial fulfilling and it is finite we have that the point p \u2032 = (y,yimax) is such that \u03b1 \u2208 ReqB(L(p\n\u2032)). By step h) of the procedure, and by the definition of future witness set, Gi+1 contains a point p \u2032\u2032 = (y,yimax+ j) such that \u03b1 \u2208 L i+1(p \u2032\u2032).\n\u2022 If R = B, by Definition 7 we have all the B-requests in a partial fulfilling compass structure are fulfilled and thus this case connot be given.\n\u2022 If R= B the case is analogous to the case of R =A.\n\u2022 If R = L, since Gi is partial fulfilling and it is finite we have that \u03b1 \u2208 ReqL(L(y i min\u22121,y i min)).\nBy point c) of the construction we have that Li(yimin\u22121,y i min) =L(y0\u22121,y0) =L(y1\u22121,y1). Hence, by condition G4 of Definition 10 and by the definition of past witness set, there exists a point (x,y) with y0 6 x < y6 y1 such that \u03b1 \u2208 L(x,y). By construction we have that L(x,y) = Li+1(x\u2212(i+ 1) \u00b7kpast,y\u2212(i+ 1) \u00b7kpast) and thus and thus the L-request \u03b1 for the point p is fulfilled at step i+1 by the point (x\u2212(i+1) \u00b7kpast,y\u2212(i+1) \u00b7kpast).\nHence, we can conclude that the infinite compass structure G\u03c9 is fulfilling. By condition G2 of Definition 10 we have that G\u03c9 features \u03d5 and thus that \u03d5 is satisfiable over the integers. \u2737\nTheorem 11 shows that satisfiability of a formula over infinite models can be reduced to the existence of a finite compass generator for it. However, it does not give any bound on the size of it. In the following we will show how the techniques exploited in Section 3.1 for finite models can be adapted to obtain a doubly exponential bound on the size of compass generators.\nDEFINITION 12. Given a compass generator G = (PO,L), we say that two rows y < y \u2032 are globally compatible if and only if the following properties holds:\n1. L(y\u22121,y) = L(y \u2032\u22121,y \u2032) and ShadingG(y) = ShadingG(y \u2032), 2. for every y \u2208 {y\u03d5,y0,y1,y2} it is not the case that y6 y6 y \u2032,\n3. there exists a past witness set PastWit(y1) such that for every point (x,y) \u2208 PastWit(y1) it is not the case that y6 y6 y \u2032;\n4. there exists a future witness set FutWit(y2) such that for every point x \u2208 FutWit(y2) and every B-request \u03b1 \u2208 ReqB(L(x,y2) there is a point (x,y) such that y2 < y, \u03b1 \u2208 Obs(L(x,y2)) and it is not the case that y6 y6 y \u2032;\n5. there exists a witness set Wit(y \u2032) for y \u2032 and an injective mapping function w : \u03c0y \u2032(Wit(y \u2032)\u222a PastWit(y1) \u222a FutWit(y2)) 7\u2192 {x : x < y}, such that L(x,y \u2032) = L(w(x),y), for every x \u2208 \u03c0y \u2032(Wit(y \u2032)\u222aPastWit(y1)\u222aFutWit(y2)), and w(x) = x, for every x \u2208 \u03c0y \u2032(PastWit(y1).\nClearly, two globally compatible rows are compatible. The additional conditions of the definition guarantees that the contraction procedure do not remove \u201cmeaningful\u201d parts of the compass generator, like the rows y\u03d5, y0, y1, and y2 (condition 2) or future and past witnesses (conditions 3 and 4).\nLEMMA 13. Let G be a compass generator for \u03d5 of size N. If there exist two global-compatible rows 0< y < y \u2032 <N in G, then there exists a compass generator G \u2032 of size N \u2032 =N\u2212y+y \u2032 that features \u03d5.\nProof. We can define a function f : {0, ...,y} \u2192 {0, ...,y \u2032} and contract G to a smaller compass structure G \u2032 in the very same way of Lemma 5. It can be easily proved that the obtained G \u2032 is a partial fulfilling compass structure. Let k = y \u2032\u2212y and let y \u2032\u03d5 = y\u03d5 if y\u03d5 < y, y \u2032 \u03d5 = y\u03d5\u2212k otherwise. To prove that G \u2032 is a compass generator, let us consider the following four cases.\n- If y \u2032 < y0, then we have that y \u2032i = yi\u2212k for i \u2208 {0,1,2,\u03d5} satisfy conditions G1-G6 in G \u2032. - If y0 <y< y \u2032 < y1, then for every point (x,y) \u2208 PastWit(y1) we have that either f(x,y) = (x,y) (when y < y) or f(x,y\u2212 k) = (w(x),y\u2212 k) = (x,y) (when y > y \u2032), and thus PastWit(y1) is a past witness set for G \u2032 as well. From this we can conclude that y \u2032\u03d5,y0,y1 \u2212k, and y2 \u2212k satisfy conditions G1-G6 in G \u2032.\n- If y0 < y1 < y < y \u2032 < y2, then it is easy to prove that y \u2032\u03d5,y0,y1 and y2 \u2212k satisfy G1-G6 in G \u2032. - If y0 < y1 < y2 < y < y \u2032, then it is easy to observe that y \u2032\u03d5,y0,y1 and y2 satisfy G1-G6 in G \u2032.\nHence, in all possible cases G \u2032 is a compass generator for \u03d5. \u2737\nTHEOREM 14. An ABBL-formula \u03d5 is satisfied by some infinite interval structure iff it is featured by some compass generator of length N6 (2|\u03d5|+1)2 8|\u03d5| \u00b7216|\u03d5| 2+8|\u03d5| (i.e., double exponential in |\u03d5|).\nProof. Suppose that \u03d5 is satisfied by a infinite interval structure S. By Theorem 11, there is a compass generator G that features \u03d5. By Lemma 13, we can assume without loss of generality that all rows of G are pairwise global-incompatible. Let cy the characteristic function defined in the proof of Theorem 6. Now, let x1 < . . .< xk be the ordered sequence of the points in PastWit(y1). We associate to every row y a finite word Wy of length |Wy| 6 k 6 2 \u00b7 |\u03d5| on the alphabet A\u03d5 (|A\u03d5| = 28|\u03d5|) such that for every xi \u2208 PastWit(y1), W(i) = L(xi,y). It is easy to prove that two rows y < y \u2032 in O with cy(F) = cy \u2032 , Wy =Wy \u2032 and such that L(y \u2032\u22121,y \u2032) = L(y\u22121,y) are global-compatible.\nSince the number of possible characteristic functions is bounded by (2|\u03d5|+1)2 8|\u03d5| , and the number of\npossible words is bounded by (28|\u03d5|)2\u00b7|\u03d5| = 216|\u03d5| 2 , G cannot have more than (2|\u03d5|+1)2 8|\u03d5| \u00b7216|\u03d5| 2+8|\u03d5| rows, and thus N is at most doubly exponential in |\u03d5|. \u2737\n4 Complexity bounds to the satisfiability problem for ABBL\nIn this section, we discuss the complexity of the satisfiability problem forABBL interpreted over strongly discrete interval temporal structures. An EXPSPACE lower bound on the complexity follows from the reduction of the exponential-corridor tiling problem (which is known to be EXPSPACE-complete [10]) to the satisfiability problem for the fragment ABB given in [8].\nTo give an upper bound to the complexity we claim that the existence of a compass structure (or compass generator) G that features a given formula \u03d5 can be decided by verifying suitable local (and stronger) consistency conditions over all pairs of contiguous rows, in a way similar to the EXPSPACE algorithm given in [8] for ABB. In this way, to check those local conditions it is sufficient to store only (i) a counter y with the number of the current row, (ii) two guessed shadings S and S \u2032 associated with the rows y and y+1, and (iii) the characteristic functions of the shadings of y and y+1. Since all this information needs only an exponential amount of space, the complexity of the satisfiability problem for ABBL is in EXPSPACE. The procedure for the infinite case is depicted in Figure 4. For the sake of\nbrevity, given a shading S we denote with F\u03c0S the unique element of S such that ReqB(F \u03c0 S) = \u2205. Note that for every row y with shading S, the type of the unit interval [y\u22121,y] is exactly F\u03c0S , while the type F of all other intervals in the row must contain the formula \u3008B\u3009\u22a4, and thus it cannot be the case that ReqB(F) = \u2205. Given a function cS : S\u2192 {0, ...,8|\u03d5|+ 14} such that cS(F\u03c0S) 6 1, we denote with S (extended shading) the pair \u3008S,cS\u3009; thus, in the code we use S to denote a shading, and S to denote an extended-shading. Moreover we have to introduce the following stronger version of the relation B\u2212\u2192 :\nF B7\u2212\u2192G iff\n \n\nReqB(F) = Obs(G) \u222a ReqB(G)\nReqB(G) = Obs(F) \u222a ReqB(F)\nReqL(F) = ReqL(G).\nFinally, given two extended shadings S= \u3008S,cS\u3009 and S \u2032 = \u3008S \u2032,cS \u2032\u3009, we say that S \u2032 is a successor of S, and we write S 7\u2212\u2192S \u2032, if the following conditions hold:\n\u2022 for every F \u2208 S \u2032 with ReqB(F) 6= \u2205 there exists G \u2208 S with F B7\u2212\u2192G; \u2022 there exists a set R\u2286 S \u2032\u00d7S\u00d7 {1, ...,8|\u03d5|+14} such that for every (F,G,n) \u2208 R, F B7\u2212\u2192G, for every F \u2208 S \u2032 we have \u2211\n(F,G,n)\u2208R n = cS \u2032(F), and for every G \u2208 S we have\n\u2211\n(F,G,n)\u2208R n = cS(G).\nThe second condition ensures that all the witnesses of the lower shading S are correctly transferred in the upper shading S \u2032 according to the functions cS and cS \u2032 . It is easy to see that, given two rows y and y+1 with shadings S and S \u2032, the two extended shadings S= \u3008S,cy\u3009 and S \u2032 = \u3008S \u2032,cy+1\u3009, (where cy and cy+1 are the characteristic functions of y and y+1, respectively) are such that S 7\u2212\u2192S \u2032.\nThe main procedure basically guesses two extended shadings Spast and Sfuture which represent the rows y0 and y2 of a compass generator, and then it checks whether a compass generator featuring them exists. The procedure checkPast ensures that we can construct the portion of the compass structure between y0 and y1 (see Figure 3). The procedure starts from y0 and construct this portion incrementally row by row until it reaches row y1. The procedure exits successfully when it reaches, without exceeding the given number of steps, a row labelled with the extended shading Spast and such that all formulas \u03c8 \u2208 ReqL(F \u03c0 Spast\n) are \u201dwitnessed\u201d by points with the first coordinate greater than the starting row (i.e., points belonging to the red triangle in Figure 3) to guarantee that there exists a past witness set for y1 that respects condition G3 of Definition 10. This condition is verified by means of the set Slower which keeps track of such points. The procedure checkFinite simply checks if the extended shading Sfuture is \u201dreachable\u201d from the extended shading Spast, and thus it represents the construction of the finite part of a compass generator (the portion between y1 and y2 in Figure 3). Finally the the procedure checkFuture ensures that we can construct the portion between y2 and N\u22121 of a compass generator. This last procedure is similar to the procedure checkPast, and it checks whether there exists a portion of a compass structure where both the lowest and the biggest rows are labelled with Sfuture. To guarantee that a future witness set for y2 exists (condition G6 of Definition 10), we require that for every F \u2208 Sfuture and for every \u03c8 \u2208 ReqB(F), it is the case that \u03c8 is fulfilled by some successor of Sfuture. This condition is ensured by means of the set REQF, which keeps track of the formulas in ReqB(F) that still need to be satisfied. It is worth to notice that all the counters, the extended shadings, and the shadings using in these procedures can be represented using exponential space with respect to the length of the input formula. Summing up, we obtain the following tight complexity result.\nTHEOREM 15. The satisfiability problem for ABBL interpreted over strongly complete linear orders is EXPSPACE-complete."}, {"heading": "5 Conclusions", "text": "We considered an interval temporal logic (ABBL) with four modalities, corresponding, respectively, to Allen\u2019s interval relations after, begins, begun-by, and before, and interpreted in the class of all strongly discrete linearly ordered sets, which includes, among others, all frames built over N, Z, and finite orders. We showed that this logic is decidable in EXPSPACE, and complete for this class. The importance of this result relies on the fact that, for the considered interpretations, this logic is maximal with respect to decidability. Moreover, these results represent a non-trivial contribution towards the complete classification of all fragments of Halpern and Shoham\u2019s modal logic of intervals. We plan to complete the study of this particular language when it is interpreted over other classes of orders, such as the class of all dense linearly ordered sets, or the class of all linear orders, and to refine these results to include point-intervals, too."}], "references": [{"title": "Maintaining Knowledge About Temporal Intervals", "author": ["J.F. Allen"], "venue": "Communications of the Association for Computing Machinery", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1983}, {"title": "Decidable and Undecidable Fragments of Halpern and Shoham\u2019s Interval Temporal Logic: towards a complete classification.  88  Begin, After, and Later: a Maximal Decidable Interval Temporal Logic In: Proceedings of the 15th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR), Lecture Notes in Computer Science 5330", "author": ["D. Bresolin", "D. Della Monica", "V. Goranko", "A. Montanari", "G. Sciavicco"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2008}, {"title": "Propositional Interval Neighborhood Logics: expressiveness, decidability, and undecidable extensions", "author": ["D. Bresolin", "V. Goranko", "A. Montanari", "G. Sciavicco"], "venue": "Annals of Pure and Applied Logic", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Propositional Interval Neighborhood Temporal Logics", "author": ["V. Goranko", "A. Montanari", "G. Sciavicco"], "venue": "Journal of Universal Computer Science", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "A Road Map of Interval Temporal Logics and Duration Calculi", "author": ["V. Goranko", "A. Montanari", "G. Sciavicco"], "venue": "Applied Non-classical Logics", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2004}, {"title": "A Propositional Modal Logic of Time Intervals", "author": ["J.Y. Halpern", "Y. Shoham"], "venue": "Journal of the ACM", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1991}, {"title": "Maximal decidable fragments of Halpern and Shoham\u2019s modal logic of intervals", "author": ["A. Montanari", "G. Puppis", "P. Sala"], "venue": "Proceedings of the 37th International Colloquium on Automata, Languages and Programming (ICALP", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Decidability of the Interval Temporal Logic ABB Over the Natural Numbers", "author": ["A. Montanari", "G. Puppis", "P. Sala", "G. Sciavicco"], "venue": "Research Report UDMI/2009/07, Department of Mathematics and Computer Science,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2009}, {"title": "Decidability of the Interval Temporal Logic ABB on Natural Numbers", "author": ["A. Montanari", "G. Puppis", "P. Sala", "G. Sciavicco"], "venue": "Proceedings of the 27th Symposium on Theoretical Aspects of Computer Science (STACS", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2010}, {"title": "The Convenience of Tilings", "author": ["P. Van Emde Boas"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1997}], "referenceMentions": [{"referenceID": 5, "context": "The most famous ITL studied so far is probably Halpern and Shoham\u2019s HS [6], which is the logic of (the thirteen) Allen\u2019s interval relations between intervals [1].", "startOffset": 71, "endOffset": 74}, {"referenceID": 0, "context": "The most famous ITL studied so far is probably Halpern and Shoham\u2019s HS [6], which is the logic of (the thirteen) Allen\u2019s interval relations between intervals [1].", "startOffset": 158, "endOffset": 161}, {"referenceID": 3, "context": "Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9].", "startOffset": 72, "endOffset": 75}, {"referenceID": 2, "context": "Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9].", "startOffset": 97, "endOffset": 100}, {"referenceID": 8, "context": "Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9].", "startOffset": 263, "endOffset": 266}, {"referenceID": 6, "context": "in the model [7].", "startOffset": 13, "endOffset": 16}, {"referenceID": 4, "context": "Other interesting fragments are BB and EE, that are decidable in most cases [5], while any other combination of the four operators B, B, E, and E immediately leads to undecidability [2].", "startOffset": 76, "endOffset": 79}, {"referenceID": 1, "context": "Other interesting fragments are BB and EE, that are decidable in most cases [5], while any other combination of the four operators B, B, E, and E immediately leads to undecidability [2].", "startOffset": 182, "endOffset": 185}, {"referenceID": 7, "context": "The proof for property 1 can be found in [8].", "startOffset": 41, "endOffset": 44}, {"referenceID": 9, "context": "An EXPSPACE lower bound on the complexity follows from the reduction of the exponential-corridor tiling problem (which is known to be EXPSPACE-complete [10]) to the satisfiability problem for the fragment ABB given in [8].", "startOffset": 152, "endOffset": 156}, {"referenceID": 7, "context": "An EXPSPACE lower bound on the complexity follows from the reduction of the exponential-corridor tiling problem (which is known to be EXPSPACE-complete [10]) to the satisfiability problem for the fragment ABB given in [8].", "startOffset": 218, "endOffset": 221}, {"referenceID": 7, "context": "To give an upper bound to the complexity we claim that the existence of a compass structure (or compass generator) G that features a given formula \u03c6 can be decided by verifying suitable local (and stronger) consistency conditions over all pairs of contiguous rows, in a way similar to the EXPSPACE algorithm given in [8] for ABB.", "startOffset": 317, "endOffset": 320}], "year": 2013, "abstractText": "Interval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals, i.e., periods of time. The most famous ITL studied so far is Halpern and Shoham\u2019s HS, which is the logic of the thirteen Allen\u2019s interval relations. Unfortunately, HS and most of its fragments have an undecidable satisfiability problem. This discouraged the research in this area until recently, when a number non-trivial decidable ITLs have been discovered. This paper is a contribution towards the complete classification of all different fragments of HS. We consider different combinations of the interval relations begins (B), after (A), later (L) and their inverses A, B and L. We know from previous works that the combinationABBA is decidable only when finite domains are considered (and undecidable elsewhere), and thatABB is decidable over the natural numbers. We extend these results by showing that decidability of ABB can be further extended to capture the language ABBL, which lies in between ABB and ABBA, and that turns out to be maximal w.r.t decidability over strongly discrete linear orders (e.g. finite orders, the naturals, the integers). We also prove that the proposed decision procedure is optimal with respect to the EXPSPACE complexity class.", "creator": "LaTeX with hyperref package"}}}