{"id": "1007.2364", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jul-2010", "title": "A Note on Semantic Web Services Specification and Composition in Constructive Description Logics", "abstract": "The idea of the Semantic Web is to annotate Web content and services with computer interpretable descriptions with the aim to automatize many tasks currently performed by human users. In the context of Web services, one of the most interesting tasks is their composition. In this paper we formalize this problem in the framework of a constructive description logic. In particular we propose a declarative service specification language and a calculus for service composition. We show by means of an example how this calculus can be used to define composed Web services and we discuss the problem of automatic service synthesis. In particular we are proposing an approach to the language and a calculus for service composition. We use the following framework to define the language and a calculus for service composition. For example it is possible to compose an EMA (EMA) using the syntax provided by the following language: e.g. e.g. e.g. e.g. e.g. e.g. EMA-Ema-Ema-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-", "histories": [["v1", "Wed, 14 Jul 2010 16:02:32 GMT  (26kb)", "http://arxiv.org/abs/1007.2364v1", "15 pages, 2 figures. Part of this work will appear as a position paper in Proceedings of 4th Int. Conf. on Web Reasoning and Rule Systems (RR 2010)"]], "COMMENTS": "15 pages, 2 figures. Part of this work will appear as a position paper in Proceedings of 4th Int. Conf. on Web Reasoning and Rule Systems (RR 2010)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["loris bozzato", "mauro ferrari"], "accepted": false, "id": "1007.2364"}, "pdf": {"name": "1007.2364.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n00 7.\n23 64\nv1 [\ncs .A\nI] 1\n4 Ju"}, {"heading": "1 Introduction", "text": "The idea of the Semantic Web is to annotate Web content and services with computer interpretable descriptions in order to automatize many tasks currently performed by human users. In the context of the Web services, this has led to the definition of semantic Web services, that is a semantic description of the capabilities and the structure of services in the languages of the semantic Web. The current proposals for the representation of semantic Web services, as OWL-S [10], view services as processes with pre- and post- conditions and effects. The representation by pre- and post- conditions describe the requirements and output of a service that is useful to retrieve the service; the representation of the process associated with a service describe the interaction with other given services. One of the main problems in the context of Web services is their composition. The problem can be stated as follows: given a composition goal, represented as a service with pre- and post- conditions, compose the available services so to satisfy the goal. Obviously in this context the challenge is to provide tools to support the definition of the composite service or, at best, to automatize the entire composition process. Using the well known relation between semantic Web languages and description logics, here we discuss the problem of service composition in the context of constructive description logics. This allows us to draw from the long tradition of use of constructive mathematics in the context of program synthesis. Indeed, the composition calculus we discuss in this paper is inspired by [13].\n\u22c6 Part of this work will appear as a position paper in Proceedings of the 4th International Conference on Web Reasoning and Rule Systems (RR 2010).\nIn this paper we formalize the composition problem in the framework of the constructive description logic BCDL0. This paper represents an initial presentation for our approach: its main contribution is to lay down the definitions for a composition language in a way that it can then be possible to define an automatic procedure for composition by software synthesis principles. Moreover, our approach also exhibits an interesting application of constructive semantics for description logics and demonstrates how to take advantage of their computational properties.\nThe logic BCDL0 that forms the base of our proposal is a subsystem of BCDL [9], a logic based on an information terms semantics. The main advantage of this semantics is to provide a natural notion of state which is at the base of our formalization of Web services and Web service composition. Moreover, how discussed in [9] this logic supports the proofs-as-programs paradigm. This allows to characterize in this setting also the problem of automatic Web services composition. For our purposes, in this paper we present a natural deduction calculus for BCDL0: however, this logic can be related to KALC [4], a constructive description logic based on a Kripke-style semantics for which we provided a decidable tableaux calculus.\nIn the following sections we introduce our formalism for the specification of services and we present our calculus SC for the definition of composite services. In order to do this, we begin by introducing the syntax and information terms semantics of BCDL0.\n2 BCDL0: Syntax and Semantics\nBCDL0 is a subsystem of BCDL [9] which is the correspondent in the information terms semantics context of the basic description logic ALC [1]. The language L for BCDL0 is based on the following denumerable sets: the set NR of role names, the set NC of concept names, the set NI of individual names and the set Var of individual variables. The concepts C,D and the formulas K of L are defined according to the following grammar:\nC,D ::= A | \u00acC | C \u2293D | C \u2294D | \u2203R.C | \u2200R.C\nK ::= \u22a5 | (s, t) : R | t : C | A\u2291C\nwhere s, t \u2208 NI \u222a Var, R \u2208 NR, A \u2208 NC. A closed formula is a formula not containing individual variables. A simple formula is either a formula of the kind \u22a5, (s, t) : R or a formula of the kind t : C with C a concept name or a negated concept. We remark that we do not allow general inclusions of concepts, but we only admit atomic concepts in the antecedent of a subsumption.\nIn the following we will be interested in the formulas generated by a finite subset N of NI; we denote with LN such a language. A model M for LN is a pair (DM, .M), where DM is a non-empty set (the domain of M) and .M is a valuation map such that: (i) for every c \u2208 N , cM \u2208 DM; (ii) for every A \u2208 NC, AM \u2286 DM; (iii) for every R \u2208 NR, RM \u2286 DM \u00d7DM.\nA non atomic concept C is interpreted by a subset CM of DM as usual:\n(\u00acC)M = DM \\ CM\n(C \u2293D)M = CM \u2229DM\n(C \u2294D)M = CM \u222aDM\n(\u2203R.C)M = { c \u2208 DM | there is d \u2208 DM s.t. (c, d) \u2208 RM and d \u2208 CM}\n(\u2200R.C)M = { c \u2208 DM | for all d \u2208 DM, (c, d) \u2208 RM implies d \u2208 CM}\nA closed formula K is valid in M, and we write M |= K, if K 6= \u22a5 and:\nM |= (s, t) : R iff (sM, tM) \u2208 RM\nM |= t : C iff tM \u2208 CM\nM |= A \u2291 C iff AM \u2286 CM\nA theory T consists of a TBox and an ABox. A TBox is a finite set of formulas of the form A \u2291 C. An ABox is a finite set of concept and role assertions: a concept assertion is a formula of the kind c : A, with c \u2208 NI and A \u2208 NC; a role assertion is a formula of the kind (c, d) : R, with c, d \u2208 NI and R \u2208 NR.\nThe constructive interpretation of BCDL0 is based on the notion of information term [9]. Intuitively, an information term \u03b1 for a closed formula K is a structured object that provides a justification for the validity of K in a classical model, in the spirit of the BHK interpretation of logical connectives [18]. Information terms are inductively defined on the structure of the closed formulas, starting from the constant symbol tt associated to atomic formulas. The meaning and the correct reading of an information term is provided by the related formula. For instance, the truthness of an existential formula c : \u2203R.C in a classical model M can be explained by its information term (d, \u03b1), that explicitly provides the witness d such that (cM, dM) \u2208 RM and dM \u2208 CM; moreover, the information term \u03b1 recursively explains why dM \u2208 CM.\nFormally, given N \u2286 NI and a closed formula K of LN , we define the set of information terms itN (K) by induction on K as follows.\nitN (K) = {tt}, if K is a simple formula\nitN (c : C1 \u2293 C2) = { (\u03b1, \u03b2) | \u03b1 \u2208 itN (c : C1) and \u03b2 \u2208 itN (c : C2) }\nitN (c : C1 \u2294 C2) = { (k, \u03b1) | k \u2208 {1, 2} and \u03b1 \u2208 itN (c : Ck) }\nitN (c : \u2203R.C) = { (d, \u03b1) | d \u2208 N and \u03b1 \u2208 itN (d : C) } itN (c : \u2200R.C) = {\u03c6 : N \u2192 \u22c3 d\u2208N itN (d : C) | \u03c6(d) \u2208 itN (d : C) } itN (A\u2291C) = {\u03c6 : N \u2192 \u22c3 d\u2208N itN (d : C) | \u03c6(d) \u2208 itN (d : C) }\nWe remark that information terms for K = c : \u2200R.C and K = A\u2291C formulas are defined as a set of functions mapping every element d of the finite set N to an information term for d : C. In other words, any information term for these formulas justifies that every element of N belongs to the concept defined by C in a given classical model.\nLet M be a model for LN , K a closed formula of LN and \u03b7 \u2208 itN (K). We define the realizability relation M\u2704 \u3008\u03b7\u3009K by induction on the structure of K.\n\u2013 M\u2704 \u3008tt\u3009K iff M |= K. \u2013 M\u2704 \u3008(\u03b1, \u03b2)\u3009 c : C1 \u2293 C2 iff M \u2704 \u3008\u03b1\u3009 c : C1 and M\u2704 \u3008\u03b2\u3009 c : C2. \u2013 M\u2704 \u3008(k, \u03b1)\u3009 c : C1 \u2294 C2 iff M\u2704 \u3008\u03b1\u3009 c : Ck. \u2013 M\u2704 \u3008(d, \u03b1)\u3009 c : \u2203R.C iff M |= (c, d) : R and M\u2704 \u3008\u03b1\u3009 d : C. \u2013 M \u2704 \u3008\u03c6\u3009 c : \u2200R.C iff M |= c : \u2200R.C and, for every d \u2208 N , M |= (c, d) : R\nimplies M\u2704 \u3008\u03c6(d)\u3009 d : C \u2013 M \u2704 \u3008\u03c6\u3009A\u2291C iff, M |= A\u2291C and, for every d \u2208 N , if M \u2704 \u3008tt\u3009 d : A then\nM\u2704 \u3008\u03c6(d)\u3009 d : C\nIf \u0393 is a finite set of closed formulas {K1, . . . ,Kn} of LN (for any ordering of the formulas of \u0393 ), itN (\u0393 ) denotes the set of n-tuples \u03b7 = (\u03b71, . . . , \u03b7n) such that, for every 1 \u2264 j \u2264 n, \u03b7j \u2208 itN (Kj); M \u2704 \u3008\u03b7\u3009\u0393 iff, for every 1 \u2264 j \u2264 n, M\u2704 \u3008\u03b7j\u3009Kj.\nNow, we introduce the example we refer to throughout this paper.\nExample 1 (Theory definition). Our example represents a reinterpretation and a formalization in our context of the \u201cpurchase and delivery service\u201d example of [17]. The example presents a system composed by three agents: a User, a Shipper and a Producer agent. The Shipper and the Producer provide the User with services to request and obtain offers for the delivery and the purchase of a product: the goal of the example is to combine the services of the two agents in order to provide the User with a single service to request the production and shipping of a product. We begin by defining the theory TPS that models our system.\nAcceptedRequest \u2291 Request RefusedRequest \u2291 Request \u2293 \u00acAcceptedRequest\nProduceRequest \u2291 Request AcceptedProduceRequest \u2291 ProduceRequest \u2293 AcceptedRequest\nShippingRequest \u2291 Request AcceptedShippingRequest \u2291 ShippingRequest \u2293 AcceptedRequest\nProduceOffer \u2291 Offer ShippingOffer \u2291 Offer\nThe theory states that a request can be classified as accepted or refused by one of the two agents: we further characterize offers, requests and accepted requests by the agent to which they refer. To relate requests to offers and to the information that they convey, we include in TPS the following axioms:\nOffer \u2291 \u2200hasCost.Price Request \u2291 \u2200hasOffer.Offer\nShippingRequest \u2291 \u2200hasDestination.Location ProduceRequest \u2291 \u2200hasProduct.Product\nIn other words, every offer in Offer specifies its Price by the role hasCost; requests relate to their offers by the role hasOffer; finally, a ShippingRequest\ncontains information about the Location to where to ship by the role hasDestination and a ProduceRequest describes the Product to buy by the role hasProduct.\nGiven a finite set of individual names N , we assume to have a suitable \u03b7 \u2208 itN (TPS) justifying the validity of TPS with respect to elements of N . Note that TPS only represents a TBox, thus information terms of its subsumptions are functions mapping information terms of the included concept in those of the including concept. If we assume to store assertions of an ABox over N in some kind of database (e.g., a relational database or the data part of a logic program), the functions for each of these information terms can be implemented as query prototypes (to be instantiated with individuals of N ) over the database. \u2738\nGiven a finite subset N of NI, an N -substitution \u03c3 is a map \u03c3 : Var \u2192 N . We extend \u03c3 to LN as usual: if c \u2208 N , \u03c3c = c; for a formula K of LN , \u03c3K denotes the closed formula of LN obtained by replacing every variable x occurring in K with \u03c3(x); given a set of formulas \u0393 , \u03c3\u0393 is the set of \u03c3K such that K \u2208 \u0393 . If c \u2208 N , \u03c3[c/p] is the N -substitution \u03c3\u2032 such that \u03c3\u2032(p) = c and \u03c3\u2032(x) = \u03c3(x) for x 6= p. A N -substitution \u03c3 is a closing substitution for a set of formulas \u0393 if \u03c3\u0393 is a set of closed formulas.\nNow, let us consider the natural deduction calculus ND for BCDL0 whose rules are given in Figure 1. We denote with \u03c0 :: \u0393 \u22a2 K the fact that \u03c0 is a proof of \u0393 \u22a2 K and with \u0393 |\nBCDL0 K the fact that there exists a proof \u03c0 :: \u0393 \u22a2 K in\nND . For a detailed presentation of the calculus and its properties we refer the reader to [9]. Here we only note that ND is sound with respect to the information term semantics, namely:\nTheorem 1 (Soundness). Let \u0393 \u222a {K} \u2286 LN , let \u03c0 :: \u0393 \u22a2 K be a proof of ND and let \u03a3 be the set of all the closing N -substitutions for \u0393 \u222a {K}. Then there exists an operator\n\u03a6\u03c0N : \u22c3\n\u03c3\u2208\u03a3\nitN (\u03c3\u0393 ) \u2192 \u22c3\n\u03c3\u2208\u03a3\nitN (\u03c3K)\nsuch that, for every \u03b3 \u2208 it(\u03c3\u0393 ) and for every model M for LN , M \u2704 \u3008\u03b3\u3009\u03c3\u0393 implies M\u2704 \u3008\u03a6\u03c0N (\u03b3)\u3009\u03c3K. \u2293\u2294\nWe remark that the proof of the above theorem is constructive. As shown in [9] we can effectively extract from the proof \u03c0 the operator \u03a6\u03c0N . This plays an important role in the definition of our service composition calculus in Section 4."}, {"heading": "3 Service Specifications", "text": "In this section we introduce the basic definitions for the description of systems and for the specification of services operating on them. A service specification (over LN ) is an expression of the form s(x) :: P \u21d2 Q where: s is a label that identifies the service; x is the input parameter of the service (to be instantiated with an individual name from N ); P and Q are concepts over LN . P is called the service pre-condition, denoted with Pre(s), and Q the service post-condition,\ndenoted with Post(s). Given a service specification s(x) :: P \u21d2 Q over LN we call service implementation a function\n\u03a6s : \u22c3\nt\u2208N\nitN (t : P ) \u2192 \u22c3\nt\u2208N\nitN (t : Q)\nWe denote with the pair (s(x) :: P \u21d2 Q,\u03a6s) (or simply with (s, \u03a6s)) a service definition over LN .\nEssentially, a service definition corresponds to an effective Web service. The service specification provides the formal description of the behavior of the service in terms of pre- and post- conditions. The function \u03a6s represents a formal description of service implementation (i.e., of the input/output function).\nThe notion of correctness is modeled as follows. Given a language LN , a service definition (s(x) :: P \u21d2 Q,\u03a6s) over LN and a model M for LN , \u03a6s uniformly solves s(x) :: P \u21d2 Q in M iff, for every individual name t \u2208 N and every \u03b1 \u2208 itN (t : P ) such that M\u2704 \u3008\u03b1\u3009 t : P , M\u2704 \u3008\u03a6s(\u03b1)\u3009 t : Q.\nExample 2 (Service specification). We can now model the services provided by the Producer and Shipper agents.\nDoProduceRequest(req) :: ProduceRequest \u2293 \u2203hasProduct.Product \u21d2 RefusedRequest \u2294 ( AcceptedProduceRequest \u2293 \u2203hasOffer.( ProduceOffer \u2293 \u2203hasCost.Price ) )\nDoShippingRequest(req) :: ShippingRequest \u2293 \u2203hasDestination.Location\n\u21d2 RefusedRequest \u2294 ( AcceptedShippingRequest \u2293 \u2203hasOffer.( ShippingOffer \u2293 \u2203hasCost.Price ) )\nThe service described by DoProduceRequest takes as input a request req specifying the required product and must classify it according to the service postcondition: namely, the service can answer with a refusal to the request (by classifying req in RefusedRequest) or it can accept the request and produce an offer with a price specified by the hasCost role. The DoShippingRequest service works in a similar way: it takes as input the destination where to ship the product and either refuses the request or it accepts the request providing an offer with the associated price.\nIn our setting, service implementations correspond to functions mapping information terms for the pre-condition into information terms for the postcondition. These functions formalize the behavior of the effective implementation of the web services. In particular let us consider the implementation \u03a6DPR of the DoProduceRequest service. Let req 1 be the individual name representing a request. The input of \u03a6DPR is any information term for \u03b1 \u2208 itN (req 1 : Pre(DoProduceRequest)). req 1 can be seen as a reference to a database record providing the information required by the service precondition and \u03b1 can be seen as a structured representation of such information. Let us suppose that \u03b1 = (tt, (book 1, tt)); this information term means that req 1 is a product request with associated product book 1. Now, let \u03b2 = \u03a6DPR(\u03b1) \u2208 it(req 1 : Post(DoProduceRequest)). If \u03b2 = (1, tt), this classify req 1 as refused. Otherwise \u03b2 could be (2, (tt, (off 1, (tt, (price 1, tt))))) which classifies req 1 as accepted and specifies that there is an offer off 1 with associated price price 1 for the requested product. The implementation \u03a6DSR of DoShippingRequest acts in a similar way.\nTo conclude, we remark that the intended model M we use to evaluate the correctness of the system is implicitly defined by the knowledge base of the system. Indeed, M \u2704 \u3008\u03b1\u3009 req 1 : Pre(DoProduceRequest) if and only if in our system req 1 effectively codify a request and book 1 is classified as a product. In this case, since \u03a6DPR uniformly solves the service specification, we know that M \u2704 \u3008\u03b2\u3009 req 1 : Post(DoProduceRequest): this trivially corresponds to the fact that, looking at its knowledge base, the Producer can generate its offer. \u2738\nThe problem of service composition amounts to build a new service from a family of implemented services. We formalize this problem in the context of an environment, that is a structure E = \u3008LN ,T, \u03b7, (s1, \u03a61), . . . , (sn, \u03a6n)\u3009 where:\n\u2013 T is a theory over the language LN ; \u2013 \u03b7 \u2208 itN (T); \u2013 for every i \u2208 {1, . . . , n}, (si, \u03a6i) is a service definition in LN .\nGiven a model M for LN we say that M is a model for E iff M\u2704 \u3008\u03b7\u3009T and for every i \u2208 {1, . . . , n}, \u03a6i uniformly solves si in M.\nA service specification s\u2032 is solvable in E if there exists an implementation \u03a6\u2032 of s\u2032 such that, for every model M of LN , if M is a model for E then \u03a6\u2032 uniformly solves s\u2032 in M.\nExample 3 (Composition problem definition). Given the previous specifications, we are now ready to state the composition problem. We want to combine the services DoProduceRequest and DoShippingRequest to provide the User with a single service to request both the production and the delivery of an object. To do this, we define a third service that composes the offers from the two agents:\nProcessOffers(req) :: AcceptedProduceRequest \u2293 \u2203hasOffer.( ProduceOffer \u2293 \u2203hasCost.Price ) \u2293 AcceptedShippingRequest \u2293 \u2203hasOffer.( ShippingOffer \u2293 \u2203hasCost.Price ) \u21d2 AcceptedRequest \u2293 \u2203hasOffer.( Offer \u2293 \u2203hasCost.Price )\nLet \u03a6PO be the implementation of ProcessOffers. We define the environment EPS = \u3008LN ,TPS , \u03b7, S1, S2, S3\u3009 where S1 = (DoProduceRequest, \u03a6DPR), S2 = (DoShippingRequest, \u03a6DSR) and S3 = (ProcessOffers, \u03a6PO). The problem can be now reduced to the definition of a suitable service specification that is solvable in such environment. \u2738\nNow, the main point of service composition is to effectively build the implementation of the service specification starting from the environment. This problem can be solved in two ways: the first solution consists in the definition of a composition language which allows the user to build up a new service starting from the environment. The second is given by providing a method to automatically build up the new service implementation.\nThe formalization of the composition problem in the framework of a (constructive) logic allows to use the proof-theoretical properties of the logical system to support the composition problem. In this paper we concentrate on the definition of a composition language. As for the problem of automatic service composition, it can be seen as a reformulation of the program-synthesis problem, a problem which has a long tradition in the constructive logics context and which has already been studied in the framework of BCDL, see [3, 9]."}, {"heading": "4 Composition Calculus SC", "text": "The composition calculus we describe in this section is inspired by PAP [13], a calculus which support program synthesis from proofs of a constructive logical system. Our calculus allows to manually compose services guaranteeing the correctness of the composed service. The main advantage of our formalization is that service composition can be supported by an appropriate proof-system. This tool can be used to check the correctness of rule applications and to automatically build the proofs of the applicability conditions.\nA composition over an environment E = \u3008LN ,T, \u03b7, (s1, \u03a61), . . . , (sn, \u03a6n)\u3009 is defined as:\ns(x) :: P \u21d2 Q\n\u03a01 : s1(x) :: P1 \u21d2 Q1 \u00b7 \u00b7 \u00b7 \u03a0n : sn(x) :: Pn \u21d2 Qn\nr\nwhere:\n\u2013 s(x) :: P \u21d2 Q is a service specification over E; \u2013 r is one of the rules of the composition calculus SC; \u2013 For every i \u2208 {1, . . . , n}, \u03a0i : si(x) :: Pi \u21d2 Qi is a service composition over E\nthat meets the applicability conditions of r.\nThe rules of the composition calculus SC and their computational interpretation \u03a6s are given in Figure 2. In the rules, the service specification s(x) :: P \u21d2 Q is called the main sequent of the rule and represents the specification of the service to be composed. The service specifications si(x) :: Pi \u21d2 Qi are called subsequents of the rule and represent the services involved in the composition. The sequents must satisfy the applicability conditions (AC) of the rule. These conditions describe the role of the subsequents in the composition of the main sequent: in order to verify the correctness of compositions, the proof checker must verify the truth of such conditions. The composition rules have both a logical and a computational reading. Given a service composition \u03a0 with main sequent s(x) :: P \u21d2 Q, we define the function\n\u03a6s : \u22c3 t\u2208N itN (t : P ) \u2192 \u22c3\nt\u2208N itN (t : Q) associated with s. The function is inductively defined on the last rule r applied in \u03a0 . Here we assume the following conventions: given a subsequent s\u2032 of the rule r, we denote with \u03a6s\u2032 its computed function; given the applicability condition (a) \u0393 |\nBCDL0 x : A of the rule r we\ndenote with \u03a6a the operator corresponding to the proof \u03c0 :: \u0393 \u22a2 x : A defined according to Section 2.\nInspecting the rules of Figure 2 we see that:\n\u2013 The AND rule represents a \u2293 introduction on the right hand side of the specification sequents: the services composed by this rule are seen as a parallel execution of the sub services. \u2013 The CASE rule represents a \u2294 elimination on the left hand side of the specification sequent: the services composed by this rule are seen as in a case construct, in which the applicability condition determines the executed sub-service. \u2013 The SEQ rule represents a composition given as a sequential execution of the sub-services and a composition of proofs under the logical reading. \u2013 The AX rule states that the system can infer specifications provable under a suitable calculus for BCDL0. \u2013 The ENV rule allows to use the specifications given in the environment E.\nLet us complete our example with a sample service composition.\nExample 4 (Service Composition). Given the environment EPS defined in Example 3 and the rules of SC, we can define a new service ProduceAndShip as the composition \u03a0 of the stated specifications as follows:\nProduceAndShip(req) :: ProduceRequest \u2293 ShippingRequest\u2293 \u2203hasProduct.Product \u2293 \u2203hasDestination.Location \u21d2\nRefusedRequest \u2294 ( AcceptedRequest \u2293 \u2203hasOffer.( Offer \u2293 \u2203hasCost.Price ) ) SEQ \u03a01 : DoRequest(req) :: ProduceRequest \u2293 ShippingRequest\u2293 \u2203hasProduct.Product \u2293 \u2203hasDestination.Location \u21d2\nRefusedRequest \u2294 ( ( AcceptedProduceRequest \u2293 \u2203hasOffer.( ProduceOffer \u2293 \u2203hasCost.Price ) ) \u2293 ( AcceptedShippingRequest \u2293 \u2203hasOffer.( ShippingOffer \u2293 \u2203hasCost.Price ) ) ) AND DoProduceRequest(req) :: ENV\nProduceRequest \u2293 \u2203hasProduct.Product \u21d2\nRefusedRequest \u2294 ( AcceptedProduceRequest \u2293 \u2203hasOffer.( ProduceOffer \u2293 \u2203hasCost.Price ) )\nDoShippingRequest(req) :: ENV ShippingRequest \u2293 \u2203hasDestination.Location \u21d2\nRefusedRequest \u2294 ( AcceptedShippingRequest \u2293 \u2203hasOffer.( ShippingOffer \u2293 \u2203hasCost.Price ) )\n\u03a02 : PresentOffer(req) ::\nRefusedRequest \u2294 ( ( AcceptedProduceRequest \u2293 \u2203hasOffer.( ProduceOffer \u2293 \u2203hasCost.Price ) ) \u2293 ( AcceptedShippingRequest \u2293 \u2203hasOffer.( ShippingOffer \u2293 \u2203hasCost.Price ) ) ) \u21d2\nRefusedRequest \u2294 ( AcceptedRequest \u2293 \u2203hasOffer.( Offer \u2293 \u2203hasCost.Price ) ) CASE RefuseRequest(req) :: AX\nRefusedRequest \u21d2 RefusedRequest\nProcessOffers(req) :: ENV AcceptedProduceRequest \u2293 \u2203hasOffer.( ProduceOffer \u2293 \u2203hasCost.Price ) \u2293 AcceptedShippingRequest \u2293 \u2203hasOffer.( ShippingOffer \u2293 \u2203hasCost.Price ) \u21d2\nAcceptedRequest \u2293 \u2203hasOffer.( Offer \u2293 \u2203hasCost.Price )\nThe behavior of this service is defined as follows: using the DoRequest service (service composition \u03a01), it first invokes the DoProduceRequest and the DoShippingRequest services to query the Producer and the Shipper over the combined request req. The answer of the two is then combined by PresentOffer (service composition \u03a02): by a case construct, this sub-service either responds that the request req has been classified as refused, or it accepts the request and generate the combined price using the ProcessOffers service.\nLet us discuss how the composite service computes information terms by explaining a sample execution. Let req 2 be both a ProduceRequest and a ShippingRequestwith associated product book 1 and shipping destination my home. Then, a call of ProduceAndShip over req 2 has as input information term \u03b11 = (tt, (tt, ((book 1, tt), (my home, tt)))). Following the composition, The execution of ProduceAndShip starts with the sequence construct and the first invoked service is DoRequest which process the information term \u03b11. DoRequest consists of a parallel call to the services of the Producer and the Shipper. The request to the Producer is executed as a call to DoProduceRequest. According to the conditions of the AND rule, we have a proof:\n\u03c01 :: TPS , x : Pre(DoRequest) | BCDL0 x : Pre(DoProduceRequest)\nThe corresponding operator \u03a6\u03c01N allows us to extract from \u03b11 the information term (tt, (book 1, tt)) \u2208 itN (req 2 : Pre(DoProduceRequest)). Let us suppose that the Producer accepts the request and produces an offer p off with an associated price. The offer is codified in the information term \u03b12 = \u03a6DPR((tt, (book 1, tt)). Let us assume that \u03b12 has the following form:\n\u03b12 = (2, (tt, (p off, (tt, (p off price, tt)))))\nThe request to the Shipper consists in a call to DoShippingRequest with input information term (tt, (my home, tt)). Also in this case this information term is generated from the operator associated with an applicability rule. As above, if\nthe Shipper accepts the request with an offer s off and its price, then the output information term is:\n\u03b13 = (2, (tt, (s off, (tt, (s off price, tt)))))\nNow the applicability conditions of the AND composition rule, in particular the proof:\n\u03c02 :: TPS , x : Post(DoProduceRequest) \u2293 Post(DoShippingRequest)\n| BCDL0 x : Post(DoRequest)\nallows us to combine \u03b12 and \u03b13 to get an \u03b14 \u2208 itN (req 2 : Post(DoRequest)) as follows:\n\u03b14 = (2, ((tt, (p off, (tt, (p off price, tt)))), (tt, (s off, (tt, (s off price, tt))))))\nProceeding in the sequence, the previous responses are combined by a call of PresentOffer with input information term \u03b14. By the AC of the CASE construct, as the request has been accepted by both agents, we enter in the second of the cases and we call ProcessOffers with input information term:\n\u03b15 = ( (tt, (p off, (tt, (p off price, tt)))), (tt, (s off, (tt, (s off price, tt)))) )\nThe service combines the offers producing a composite offer ps off with its associated price ps off price modeled by the information term:\n(tt, (ps off, (tt, (ps off price, tt))))\nFinally the output of PresentOffer and ProduceAndShip is:\n(2, (tt, (ps off, (tt, (ps off price, tt)))))\nThis object states that the request has been accepted and it contains both the object representing the composite offer (ps off) and its composite price (ps off price). \u2738\nTo conclude this section we state the result asserting the soundness of the rules with respect to uniform solvability. Its proof easily follows by induction on the structure of the composition \u03a0 .\nTheorem 2. Let E = \u3008LN ,T, \u03b7, (s1, \u03a61), . . . , (sn, \u03a6n)\u3009 be an environment and let s(x) :: P \u21d2 Q be the main sequent of a composition \u03a0 over E. For every model M for L, if M is a model for E then the function \u03a6s extracted from \u03a0 uniformly solves s in M. \u2293\u2294"}, {"heading": "5 Related Works and Conclusions", "text": "In this section we review some of the current approaches for the composition of semantic Web services and we discuss the relations with our proposal.\nOne of the most relevant proposals for the semantic description of Web services is OWL-S [10]. An OWL-S service is described by three representations conforming to three distinct ontologies: a service profile, describing its use in terms of inputs, outputs, pre- and post- conditions, a process model, stating the flow of interactions that composes the service, and a grounding model, describing the details about its interface. Among these, the profile and the process model define an abstract representation of the service. In particular, the service profile gives a declarative description of the service. The process model describes the possible interactions with a service, that is its composition with other given services. The model mainly distinguish services into atomic and composite processes : atomic processes do not have a representation of their internal structure and thus they are entirely defined by their profiles; on the other hand, composite processes are representations of compositions of processes linked by some control structure.\nMany tasks can be supported by a pure atomic view of the services: one of these tasks is planning, which can be seen as a way to synthesize service compositions. In [10] it is stated that the execution behavior of control constructs of the composite processes can not be suitably represented in OWL-DL: this brought to several translations of OWL-S compositions into different formalisms. The idea is that by a formalization of control structures one can reason over the definition of composite processes. One of these formalizations has been presented in [15]: the authors define a translation from DAML-S descriptions to Petri Nets and give procedures to compute composition, verification and simulation of services. However, as noted in [17], this approach only allows sequential composition of atomic services. A similar approach is presented in [17] in which OWL-S process models are encoded into state transition systems: synthesis of compositions is performed by planning techniques. This approach features the representation of non deterministic outcomes of services, complex specifications of goals and the translation of the resulting plans to executable processes. We must note that the above approaches are mostly based on the process representation of services.\nAn approach that highlights the relationships between composition and software synthesis is proposed in [11]. This approach composes services on the base of their service profiles. The idea is that Web services can be treated as software components, thus service composition can be carried out as a problem of software composition. The approach uses the Structural Synthesis Program (SSP) method [12] to extract compositions. We notice that SSP is based on the implicative part of the intuitionistic propositional calculus and it can only define sequential or conditional compositions in general.\nA different representation of semantic Web services is given by the WSMO ontology [7] and its Web service modeling language WSML. As OWL-S, these languages define services by their profiles, but WSMO does not explicitly represent the structure of composition of Web services in terms of control flow. Interactions of services are controlled by specific agents called mediators which refer to the standard execution environment WSMX.\nAs can be noted, many of the latter proposals do not base their compositions on a logic representation of pre- and post- conditions or on the function mapping inputs to outputs. Moreover, whenever a composition of sub services is defined, this does not explicitly depend on the condition stated in declarative description of the composite service. A kind of composition that depends on the formulas of service profiles can be found in the related approaches for action formalisms and planning over description logics as in [2, 6, 8, 14]. However, classical planning techniques mostly generate sequences of services achieving a goal: as noted in [17], this can be limiting in practical cases when one needs to distinguish between different condition cases and represent sequence constraints between goals.\nTo compare our approach with the ones cited above, we remark that SC assures that the composite service specification (the service profile) directly follows from composition proof. The correctness of compositions can be checked directly by verifying the applicability conditions of the rules used in the composition: moreover, our rules directly represent common control structures, thus allowing to represent complex compositions.\nEven if in this paper we detailed manual composition of services, by implementing SC we would obtain a method for automatic composition. For an actual implementation of our calculus we need both an implementation of BCDL0 and a method to convert in our formalism the service descriptions from specification languages as OWL-S that preserves their intended semantics. The main limitation of our approach stands in the restricted expressivity of the description logic at its base, that represents a small fragment of the actual expressivity of current ontology languages. In order to define a calculus for automatic composition, in our future work we plan to study the properties of SC and of its underlying constructive description logic BCDL0. In particular, we remark that BCDL0 is related to the logic KALC [4] for which we already presented a decidable tableaux calculus: moreover, it can be shown that the derived tableaux procedure is Pspace-complete, as in the case of satisfiability procedures for classical ALC [16]. The relations between BCDL0, BCDL and KALC will be subject of our future investigations. On the other hand, in order to evaluate the properties of the composition calculus, we also intend to examine its relations with software synthesis and action formalisms."}], "references": [{"title": "editors", "author": ["F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": "The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2003}, {"title": "A description logic based approach to reasoning about web services", "author": ["F. Baader", "C. Lutz", "M. Milicic", "U. Sattler", "F. Wolter"], "venue": "In WSS2005, Chiba City, Japan,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2005}, {"title": "A decidable constructive description logic", "author": ["L. Bozzato", "M. Ferrari", "C. Fiorentini", "G. Fiorino"], "venue": "In JELIA 2010, Lecture Notes in Computer Science. SpringerVerlag,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2010}, {"title": "editors", "author": ["D. Calvanese", "E. Franconi", "V. Haarslev", "D. Lembo", "B. Motik", "S. Tessaris", "A. Turhan"], "venue": "Proceedings of the 20th International Workshop on Description Logics, volume 250 of CEUR Workshop Proceedings. CEUR-WS.org,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2007}, {"title": "The Web Service Modeling Language WSML: An Overview", "author": ["J. de Bruijn", "H. Lausen", "A. Polleres", "D. Fensel"], "venue": "In ESWC 2006,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2006}, {"title": "Integrating action calculi and description logics", "author": ["C. Drescher", "M. Thielscher"], "venue": "In KI 2007, volume 4667 of Lecture Notes in Computer Science, pages 68\u201383. Springer-Verlag,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "BCDL: Basic Constructive Description Logic", "author": ["M. Ferrari", "C. Fiorentini", "G. Fiorino"], "venue": "Journal of Automated Reasoning, 44(4):371\u2013399,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Bringing Semantics to Web Services with OWL-S", "author": ["D. Martin", "M. Burstein", "D. McDermott", "S. McIlraith", "M. Paolucci", "K. Sycara", "D.L. McGuinness", "E. Sirin", "N. Srinivasan"], "venue": "World Wide Web, 10(3):243\u2013277,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Value-added web services composition using automatic program synthesis", "author": ["M. Matskin", "J. Rao"], "venue": "In C. Bussler, R. Hull, S. A. McIlraith, M. E. Orlowska, B. Pernici, and J. Yang, editors, WES 2002, volume 2512 of Lecture Notes in Computer Science, pages 213\u2013224. Springer,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2002}, {"title": "Strategies of structural synthesis of programs and its extensions", "author": ["M. Matskin", "E. Tyugu"], "venue": "Computers and Artificial Intelligence, 20(1),", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2001}, {"title": "Program specification and synthesis in constructive formal systems", "author": ["P. Miglioli", "U. Moscato", "M. Ornaghi"], "venue": "In LOPSTR 1991, pages 13\u201326. Springer-Verlag,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1991}, {"title": "Simulation, verification and automated composition of web services", "author": ["S. Narayanan", "S.A. McIlraith"], "venue": "In WWW 2002, pages 77\u201388,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2002}, {"title": "Attributive concept descriptions with complements", "author": ["M. Schmidt-Schau\u00df", "G. Smolka"], "venue": "Artificial Intelligence, 48(1):1\u201326,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1991}, {"title": "Automated composition of semantic web services into executable processes", "author": ["P. Traverso", "M. Pistore"], "venue": "In ISWC 2004, volume 3298 of Lecture Notes in Computer Science, pages 380\u2013394. Springer,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2004}, {"title": "From constructivism to computer science", "author": ["A.S. Troelstra"], "venue": "Theoretical Computer Science, 211(1-2):233\u2013252,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1999}], "referenceMentions": [{"referenceID": 7, "context": "The current proposals for the representation of semantic Web services, as OWL-S [10], view services as processes with pre- and post- conditions and effects.", "startOffset": 80, "endOffset": 84}, {"referenceID": 10, "context": "Indeed, the composition calculus we discuss in this paper is inspired by [13].", "startOffset": 73, "endOffset": 77}, {"referenceID": 6, "context": "The logic BCDL0 that forms the base of our proposal is a subsystem of BCDL [9], a logic based on an information terms semantics.", "startOffset": 75, "endOffset": 78}, {"referenceID": 6, "context": "Moreover, how discussed in [9] this logic supports the proofs-as-programs paradigm.", "startOffset": 27, "endOffset": 30}, {"referenceID": 2, "context": "For our purposes, in this paper we present a natural deduction calculus for BCDL0: however, this logic can be related to KALC [4], a constructive description logic based on a Kripke-style semantics for which we provided a decidable tableaux calculus.", "startOffset": 126, "endOffset": 129}, {"referenceID": 6, "context": "BCDL0 is a subsystem of BCDL [9] which is the correspondent in the information terms semantics context of the basic description logic ALC [1].", "startOffset": 29, "endOffset": 32}, {"referenceID": 0, "context": "BCDL0 is a subsystem of BCDL [9] which is the correspondent in the information terms semantics context of the basic description logic ALC [1].", "startOffset": 138, "endOffset": 141}, {"referenceID": 6, "context": "The constructive interpretation of BCDL0 is based on the notion of information term [9].", "startOffset": 84, "endOffset": 87}, {"referenceID": 14, "context": "Intuitively, an information term \u03b1 for a closed formula K is a structured object that provides a justification for the validity of K in a classical model, in the spirit of the BHK interpretation of logical connectives [18].", "startOffset": 218, "endOffset": 222}, {"referenceID": 13, "context": "Our example represents a reinterpretation and a formalization in our context of the \u201cpurchase and delivery service\u201d example of [17].", "startOffset": 127, "endOffset": 131}, {"referenceID": 6, "context": "For a detailed presentation of the calculus and its properties we refer the reader to [9].", "startOffset": 86, "endOffset": 89}, {"referenceID": 6, "context": "As shown in [9] we can effectively extract from the proof \u03c0 the operator \u03a6\u03c0N .", "startOffset": 12, "endOffset": 15}, {"referenceID": 6, "context": "As for the problem of automatic service composition, it can be seen as a reformulation of the program-synthesis problem, a problem which has a long tradition in the constructive logics context and which has already been studied in the framework of BCDL, see [3, 9].", "startOffset": 258, "endOffset": 264}, {"referenceID": 10, "context": "The composition calculus we describe in this section is inspired by PAP [13], a calculus which support program synthesis from proofs of a constructive logical system.", "startOffset": 72, "endOffset": 76}, {"referenceID": 7, "context": "One of the most relevant proposals for the semantic description of Web services is OWL-S [10].", "startOffset": 89, "endOffset": 93}, {"referenceID": 7, "context": "In [10] it is stated that the execution behavior of control constructs of the composite processes can not be suitably represented in OWL-DL: this brought to several translations of OWL-S compositions into different formalisms.", "startOffset": 3, "endOffset": 7}, {"referenceID": 11, "context": "One of these formalizations has been presented in [15]: the authors define a translation from DAML-S descriptions to Petri Nets and give procedures to compute composition, verification and simulation of services.", "startOffset": 50, "endOffset": 54}, {"referenceID": 13, "context": "However, as noted in [17], this approach only allows sequential composition of atomic services.", "startOffset": 21, "endOffset": 25}, {"referenceID": 13, "context": "A similar approach is presented in [17] in which OWL-S process models are encoded into state transition systems: synthesis of compositions is performed by planning techniques.", "startOffset": 35, "endOffset": 39}, {"referenceID": 8, "context": "An approach that highlights the relationships between composition and software synthesis is proposed in [11].", "startOffset": 104, "endOffset": 108}, {"referenceID": 9, "context": "The approach uses the Structural Synthesis Program (SSP) method [12] to extract compositions.", "startOffset": 64, "endOffset": 68}, {"referenceID": 4, "context": "A different representation of semantic Web services is given by the WSMO ontology [7] and its Web service modeling language WSML.", "startOffset": 82, "endOffset": 85}, {"referenceID": 1, "context": "A kind of composition that depends on the formulas of service profiles can be found in the related approaches for action formalisms and planning over description logics as in [2, 6, 8, 14].", "startOffset": 175, "endOffset": 188}, {"referenceID": 5, "context": "A kind of composition that depends on the formulas of service profiles can be found in the related approaches for action formalisms and planning over description logics as in [2, 6, 8, 14].", "startOffset": 175, "endOffset": 188}, {"referenceID": 13, "context": "However, classical planning techniques mostly generate sequences of services achieving a goal: as noted in [17], this can be limiting in practical cases when one needs to distinguish between different condition cases and represent sequence constraints between goals.", "startOffset": 107, "endOffset": 111}, {"referenceID": 2, "context": "In particular, we remark that BCDL0 is related to the logic KALC [4] for which we already presented a decidable tableaux calculus: moreover, it can be shown that the derived tableaux procedure is Pspace-complete, as in the case of satisfiability procedures for classical ALC [16].", "startOffset": 65, "endOffset": 68}, {"referenceID": 12, "context": "In particular, we remark that BCDL0 is related to the logic KALC [4] for which we already presented a decidable tableaux calculus: moreover, it can be shown that the derived tableaux procedure is Pspace-complete, as in the case of satisfiability procedures for classical ALC [16].", "startOffset": 275, "endOffset": 279}], "year": 2014, "abstractText": "The idea of the Semantic Web is to annotate Web content and services with computer interpretable descriptions with the aim to automatize many tasks currently performed by human users. In the context of Web services, one of the most interesting tasks is their composition. In this paper we formalize this problem in the framework of a constructive description logic. In particular we propose a declarative service specification language and a calculus for service composition. We show by means of an example how this calculus can be used to define composed Web services and we discuss the problem of automatic service synthesis.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}