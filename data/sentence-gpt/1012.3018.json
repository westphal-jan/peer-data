{"id": "1012.3018", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Dec-2010", "title": "On the size of data structures used in symbolic model checking", "abstract": "Temporal Logic Model Checking is a verification method in which we describe a system, the model, and then we verify whether some properties, expressed in a temporal logic formula, hold in the system. It has many industrial applications. In order to improve performance, some tools allow preprocessing of the model, verifying on-line a set of properties reusing the same compiled model; we prove that the complexity of the Model Checking problem, without any preprocessing or preprocessing the model or the formula in a polynomial data structure, is the same. As a result preprocessing does not always exponentially improve performance.\n\nIn this article, we will be talking about the implementation of the preprocessing model for the prediction and prediction model for the model. In our presentation, we show how to create and validate the preprocessing model for the prediction model for the prediction model and predict model for the prediction model for the prediction model. In particular, we show how to produce a model for the prediction model in the prediction model for the prediction model, with a set of properties being defined in a polynomial data structure.\nThe following example shows how to use a preprocessing model for predicting the prediction model. First, you will define a model for a random number model that has properties, with a single value, in two separate data structures, one to give rise to a polynomial data structure. In this example, we can check if there are some properties. We use the prediction model as a model for a particular condition, and if we do not have any properties, we can check if they have properties. If you have a property, we will have to test whether there is some other properties. This test can be useful to ensure that there are more properties. For example, we will add properties, where they are the property. In our example, we can verify that a given property can be determined with probability, and we can verify that some properties do not exist, as in the case of the predicted model for the prediction model.\nWe can also check if there are a property for the prediction model. In our example, we will be defining a model for the prediction model for the prediction model in a polynomial data structure. As a result, we will test whether there are any properties. This is a test. We have a property in the input for the prediction model, and we can check that a given property is true.\nUsing the Prediction Model for the prediction model, we can generate a prediction model for the prediction model", "histories": [["v1", "Tue, 14 Dec 2010 13:18:44 GMT  (23kb)", "http://arxiv.org/abs/1012.3018v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.CC cs.DS cs.LO", "authors": ["paolo liberatore", "marco schaerf"], "accepted": false, "id": "1012.3018"}, "pdf": {"name": "1012.3018.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["lastname@dis.uniroma1.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n01 2.\n30 18\nv1 [\ncs .A\nI] 1\n4 D\nTemporal Logic Model Checking is a verification method in which we describe a system, the model, and then we verify whether some properties, expressed in a temporal logic formula, hold in the system. It has many industrial applications. In order to improve performance, some tools allow preprocessing of the model, verifying on-line a set of properties reusing the same compiled model; we prove that the complexity of the Model Checking problem, without any preprocessing or preprocessing the model or the formula in a polynomial data structure, is the same. As a result preprocessing does not always exponentially improve performance.\nSymbolic Model Checking algorithms work by manipulating sets of states, and these sets are often represented by BDDs. It has been observed that the size of BDDs may grow exponentially as the model and formula increase in size. As a side result, we formally prove that a superpolynomial increase of the size of these BDDs is unavoidable in the worst case. While this exponential growth has been empirically observed, to the best of our knowledge it has never been proved so far in general terms. This result not only holds for all types of BDDs regardless of the variable ordering, but also for more powerful data structures, such as BEDs, RBCs, MTBDDs, and ADDs."}, {"heading": "1 Introduction", "text": "Temporal Logic Model Checking [20] is a verification method for discrete systems. In a nutshell, the system, often called the model, is described by the possible transitions of its components, while the properties to verify are encoded in a temporal modal logic. It is used, for example, for the verification of protocols and hardware circuits [5]. Many tools, called model checkers, have been developed to this aim. The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].\nThere are many languages to express the model; the most widespread ones are Promela and SMV. Two temporal logics are mainly used to define the specification: CTL [20] and LTL [45]. In this paper we focus on the latter.\nIn many cases, the two inputs of the model checking problem (the model and the formula) can be processed in a different way. If we want to verify several properties of the same system, it makes sense to spend more time on the model alone, if the verification of the properties becomes faster. Many tools allow to build the model separately from checking the formula [16, 53, 36]. This way, one can reuse the same model, compiled into a data structure, in order to check several formulae.\nIn the same way, we may wish to verify the same property on different systems: the property is this time the part we can spend more time on. Many tools allow populating a property database [16, 53, 36], i.e., a collection of temporal formulae which will be checked on the models. We imagine a situation in which we early establish the requirements that our system must satisfy, even before the system is actually designed. As a result, and we can fill a database of temporal formulae, but we do not yet describe the system. While the design/modeling of the system goes on, we can preprocess the formulae (without knowledge of the model, which is not yet known). Whenever the system is specified, we can then use the result of this preprocessing step to check the model against the formulae.\nIn this paper, we analyze whether preprocessing a part of the model checking problem instances improve the performances. The technical tool we use is the compilability theory [15, 39]. This theory characterizes the complexity of problems when the problem instances can be divided into two parts (the fixed and the varying part), and we can spend more time on the first part alone, provided that the result of this preprocessing step has polynomial size respect the fixed part. We show that the Model Checking problem remains PSPACE-hard even if we can preprocess either the model or the formula, if this preprocessing step is constrained to have a polynomial size. These theorems hold for all model checkers.\nFinally, we answer to a long-time standing question in Symbolic Model Checking [43, 11]. It has been observed that the BDDs that are used by SMV and other Symbolic Model Checking systems become exponentially large in some cases. However, it has not yet been established whether this size increase is due to the choice of variable ordering, or to the kind of BDDs employed, or it is intrinsic of the problem. We show that, if PSPACE 6\u2286 \u03a0p2 \u2229 \u03a3 p 2, such a growth is, in the worst case, unavoidable. This result is independent from the particular class of BDDs and from the variable order of the BDDs. It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2]."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Model Checking", "text": "In this section, we briefly recall the basic definitions about model checking that are needed in the rest of the paper. We follow the notation of [47, 46]. LTL (Linear Temporal Logic) is a modal logic aimed at encoding how states evolve over time. It has three unary modal operators (X , G, and F ) and one binary modal operator (U). Their meaning is: X\u03c6 is true in particular state if and only\nif the formula \u03c6 is true in the next state; G\u03c6 is true if and only \u03c6 is true from now on; F\u03c6 is true if \u03c6 will become true at some time in the future; \u03c6U\u03c8 is true if \u03c8 will eventually become true and \u03c6 stays true until then. We indicate with L(O1, . . . , On) the LTL fragment in which the only temporal operators allowed are O1, . . . , On; for instance, L(F,X) is the fragment of LTL in which only F and X are allowed.\nThe semantics of LTL is based on Kripke models. In the following, for an \u2019atomic proposition\u2019 we mean a Boolean variable. Given a set of atomic proposition, a Kripke structure for LTL is a tuple \u3008Q,R, \u2113, I\u3009, where Q is a set of states, R is a binary relation over states (the transition relation), \u2113 is a function from states to atomic propositions (it labels every state with the atomic propositions that are true in that state), I is a set of initial states. A run of a Kripke structure is a Kripke model. A Kripke model for LTL is an infinite sequence of states, where the transition relation links each state with the one immediately following it in the sequence. The semantics of the modal operators is defined in the intuitive way: for example, F\u03c6 is true in a state of a Kripke model if \u03c6 is true in some following state.\nThe main problem of interest in practice is to verify whether all runs of a Kripke structure (all of its Kripke models) satisfy the formula; this is the Universal Model Checking problem. The Existential Model Checking one is to verify whether there is a run of the Kripke structure that satisfies the formula. In formal verification, we encode the behavior of a system as a Kripke structure, and the property we want to check as an LTL formula. Checking the structure against the formula tells whether the system satisfies the property. Since the Kripke structure is usually called a \u201cmodel\u201d (which is in fact very different from a Kripke model, which is only a possible run), this problem is called Model Checking.\nIn practice, all model checkers describe a system by the Kripke structure of its components. A Kripke structure can be seen as a transition system [20]. Thus the global system is obtained by parallel composition of the transition systems representing its components and sharing some variables [42, 20]; using this approach, we can give results valid for all model checkers."}, {"heading": "2.2 Composition of Transition Systems", "text": "Each component of the global system is modeled using a transition system, which is a formal way to describe a possible transition a system can go through. Intuitively, all is needed is to specify the state variables, the possible initial states, and which transitions are possible, i.e., we have to say whether the transition from state s to state s\u2032 is possible for any pair of states s and s\u2032. The formal definition is as follows [42, 20].\nDefinition 1 A finite-state transition system is a triple (V, I, \u033a), where V = {x1, . . . , xn} is a set of Boolean variables, I is a formula over V , and \u033a(V, V \u2032) is a formula over V \u222a V \u2032, where V \u2032 = {x\u20321, . . . , x \u2032 n} is a set of new variables in one to one relation with elememts of V .\nIntuitively, V is the set of state variables, I is a formula that is true on a truth assignment if and only if it represents a possible initial state, and \u033a is true on a pair of truth assignments if they represent a possible transition of\nthe system. The set of variables V \u2032 is needed because \u033a must refer to both the value of a variable in the current state (xi) and in the next state (x \u2032 i). In other words, in this formula xi means the value of xi in the current state, while x \u2032 i is the value of the same variable in the next state. For example, the fact that xi remains true is encoded by \u033a = xi \u2192 x\u2032i: if xi is true now, then x \u2032 i is true, i.e., xi is true in the next state. Formally, a state s is an assignment to the variables; a state s\u2032 is successor of a state s iff \u3008s, s\u2032\u3009 |= \u033a(V, V \u2032). A computation is an infinite sequence of states s0, s1, s2, . . . , satisfying the following requirements:\nInitiality: s0 is initial, i.e. s0 |= I\nConsecution: For each j \u2265 0, the state sj+1 is a successor of the state sj\nFor the sake of simplicity, without loss of any generality, we only consider Boolean variables and Boolean assertions.\nIn order to model a complex system, we assume that each of its parts can be modeled by a transition system. Clearly, there is usually some interaction between the parts; as a result, some variables may be shared between the transition systems. In the following, we consider k transition systems M1, . . . ,Mk. Every Mi is described by ((V L i \u222a V S i ), Ii(Vi), \u033ai(Vi, V \u2032 i )) for i 1 \u2264 i \u2264 k where V Li is the set variables local to Mi, V S i is the set of shared variables of Mi, and Vi = V L i \u222a V S i . A group of transition systems can be composed in different ways: synchronous, interleaved asynchronous, and asynchronous. The third way is not frequently used in Model Checking, so we only define the first two ways of composition. In the following, a process is any of the transition systems Mi.\nThe synchronous parallel composition of k transition systems is obtained by assuming that the global transition is due to all processes Mi making a transition simultaneously. In other words, all processes must make a transition at any time step, and no process is allowed to \u201cidle\u201d at any time step.\nDefinition 2 The synchronous parallel composition of processes M1, . . . ,Mk, denoted by M1\u2016 . . . \u2016Mk, is the transition system M = (V, I, \u033a) described by:\nV = \u22c3k i=1 Vi I(V ) = \u2227k i=1 Ii(Vi)\n\u033a(V, V \u2032) = \u2227k i=1 \u033ai(Vi, V \u2032 i )\nThe basic idea of the interleaved asynchronous parallel composition is that only one process is active at the same time. As a result, a global transition can only result from the transition of a single process. The variables that are not changed by this process must maintain the same value.\nDefinition 3 The interleaved asynchronous parallel composition of M1, . . . ,Mk is the transition system M = (V, I, \u033a): , where V and I are as in the synchronous composition and \u033a is:\n\u033a(V, V \u2032) = \u2228k\ni=1\n[\n\u033ai(Vi, V \u2032 i ) \u2227 \u2227k j=1 j 6=i V Li = V L i\n\u2032 ]\nThe interleaved asynchronous parallel composition of M1, . . . ,Mk, is denoted by M1| . . . |Mk.\nA model can be described as the composition of transition systems. As a result, we can define the model checking problem for concurrent transition systems as the problem of verifying whether the model described by the composition of the transition systems satisfies the given formula."}, {"heading": "2.3 Complexity and Compilability", "text": "We assume that the reader knows the basic concepts of complexity theory [48, 31]. What we mainly use in this paper are the concepts of polynomial reduction and the class PSPACE.\nThe Model Checking problem is PSPACE-complete, and is thus intractable. On the other hand, as said in the Introduction, it makes sense to preprocess only one part of the problem (either the model or the formula), if this reduces the remaining running time. The analysis of how much can be gained by such preprocessing, however, cannot be done using the standard tools of the polynomial classes and reductions. The compilability classes [15] have to be used instead.\nThe way in which the complexity of the problem is identified in the theory of NP-completeness is that of giving a set of increasing classes of problems. If a problem is in a class C but is not in an inner class C\u2032, then we can say that this problem is more complex to solve that a problem in C\u2032. A similar characterization, with similar classes, can be given when preprocessing is allowed. For example the class \u2016;P is the class of problems that can be solved in polynomial time after a preprocessing step. Crucial to this definition are two points:\n1. which part of the problem instance can be preprocessed?\n2. how expensive is the preprocessing part allowed to be?\nThe first point depends on the specific problem and on the specific settings: depending on the scenario, for example, we can preprocess either the model or the formula for the model checking problem. The second question instead allows for a somehow more general answer. First, we cannot limit this phase to take polynomial time, as otherwise there would be no gain in doing preprocessing from the point of view of computational complexity. Second, we cannot allow the final result of this part to be exponentially large, for practical reasons; we bound the result of the preprocessing phase only to take a polynomial amount of space.\nIn order to denote problems in which only one part can be preprocessed, we assume that their instances are composed of two parts, and that the part that can be preprocessed is the first one. As a result, the model checking problem written as \u3008M,\u03c6\u3009 indicates that M can be preprocessed; written as \u3008\u03c6,M\u3009 indicates that \u03c6 can be preprocessed.\nThe \u201ccomplexity when preprocessing is allowed\u201d is established by characterizing how hard a problem is after the preprocessing step. This is done by building over the usual complexity classes: if C is a \u201cregular\u201d complexity class such as NP, then a problem is in the (non-uniform) compilability class \u2016;C if the problem is in C after a preprocessing step whose result takes polynomial space. In other words, \u2016;C is \u201calmost\u201d C, but preprocessing is allowed and will not be counted in the cost of solving the problem. More details can be found in [15].\nIn order to identify how hard a problem is, we also need a concept of hardness. Since the regular polynomial reductions are not appropriate when preprocessing is allowed, ad-hoc reductions (called nu-comp reductions in [15]) have been defined.\nIn this paper, we do not show the hardness of problems directly, but rather use a sufficient condition called representative equivalence. For example, in order to prove that model checking is \u2016;PSPACE-hard, we first show a (regular) polynomial reduction from a PSPACE-hard problem to model checking and then show that this reduction satisfies the condition of representative equivalence.\nLet us assume that we know that a given problem A is \u2016;C-hard and we have a polynomial reduction from the problem A to the problem B. Can we use this reduction to prove the \u2016;C-hardness of B ? Liberatore [39] shows sufficient conditions that should hold on A as well as on the reduction. If all these conditions are verified, then there is a nucomp reduction from \u2217A to B, where \u2217A = {\u3008x, y\u3009 |y \u2208 A}, thus proving the \u2016;C-hardness of B.\nDefinition 4 (Classification Function) A classification function for a problem A is a polynomial function Class from instances of A to nonnegative integers, such that Class(y) \u2264 ||y||.\nDefinition 5 (Representative Function) A representative function for a problem A is a polynomial function Repr from nonnegative integers to instances of A, such that Class(Repr(n)) = n, and that ||Repr(n)|| is bounded by some polynomial in n.\nDefinition 6 (Extension Function) An extension function for a problem A is a polynomial function from instances of A and nonnegative integers to instances of A such that, for any y and n \u2265 Class(y), the instance y\u2032 = Exte(y, n) satisfies the following conditions:\n1. y \u2208 A if and only if y\u2032 \u2208 A; 2. Class(y\u2032) = n.\nLet us give some intuitions about these functions. Usually, an instance of a problem is composed of a set of objects combined in some way. For problems on boolean formulas, we have a set of variables combined to form a formula. For graph problems, we have a set of nodes, and the graph is indeed a set of edges, which are pairs of nodes. The classification function gives the number of objects in an instance. The representative function thus gives an instance with the given number of objects. This instance should be in some way \u201csymmetric\u201d, in the sense that its elements should be interchangeable (this is because the representative function must be determined only from the number of objects). Possible results of the representative function can be the set of all clauses of\nthree literals over a given alphabet, the complete graph over a set of nodes, the graph with no edges, etc. Let for example A be the problem of propositional satisfiability. We can take Class(F ) as the number of variables in the formula F , while Repr(n) can be the set of all clauses of three literals over an alphabet of n variables. Finally, a possible extension function is obtained by adding tautological clauses to an instance. Note that these functions are related to the problem A only, and do not involve the specific problem B we want to prove hard, neither the specific reduction used. We now define a condition over the polytime reduction from A to B. Since B is a problem of pairs, we can define a reduction from A to B as a pair of polynomial functions \u3008r, h\u3009 such that x \u2208 A if and only if \u3008r(x), h(x)\u3009 \u2208 B.\nDefinition 7 (Representative Equivalence) Given a problem A (having the above three functions), a problem of pairs B, and a polynomial reduction \u3008r, h\u3009 from A to B, the condition of representative equivalence holds if, for any instance y of A, it holds:\n\u3008r(y), h(y)\u3009 \u2208 B iff \u3008r(Repr(Class(y)), h(y)\u3009 \u2208 B\nThe condition of representative equivalence can be proved to imply that the problem B is \u2016;C-hard, if A is C-hard [39]. As an example, we show these three functions for the PLANSAT \u22171 problem. PLANSAT \u2217 1 is the following problem of planning: giving a STRIPS [29] instance y = \u3008P,O, I,G\u3009 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT \u22171 is PSPACE-Complete [12]. Without loss of generality we consider y = (P,O\u222ao0, I, G), where o0 is a operator which is always usable (it has no preconditions) and does nothing (it has no postconditions). We use the following notation: P = {x1, . . . , xn}, I is the set of conditions true in the initial state, G = \u3008M,N\u3009. A state in STRIPS is a set of conditions. In the following we indicate with \u03c6hi the hth positive precondition of the operator oi, with \u03c6i all its the positive preconditions, with \u03b7 h i its hth negative precondition, and with \u03b7i all its negative preconditions; \u03b1i is the positive postcondition of the operator oi, \u03b2i is the negative postcondition of the operator oi. Since any operator has only one postcondition, for every operator i it holds that \u2016\u03b1i\u222a\u03b2i\u2016 = 1.\nSince we shall use them in the following, we define a classification function, a representative function and a extension function for PLANSAT \u22171 :\nClassification Function: Class(y) = \u2016P\u2016. Clearly, it satisfies the condition Class(y) \u2264 \u2016y\u2016.\nRepresentative Function: Repr(n) = \u3008Pn, \u2205, \u2205, \u2205\u3009, where Pn = {x1, . . . , xn}. Clearly, this function is polynomial and satisfies the following conditions: (i) Class(Repr(n))=n, (ii) \u2016Repr(n)\u2016 \u2264 p(n) where p(n) is a polynomial.\nExtension Function: Let y = \u3008P,O, I,G\u3009 and y\u2032 = Exte(y, n) = \u3008Pn, O, I,G\u3009. Clearly for any y and n s.t. n \u2265 Class(y) y\u2032 satisfies the following conditions: (i)y \u2208 A iff y\u2032 \u2208 A, (ii) Class(y\u2032) = n.\nGiven the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances."}, {"heading": "3 Results", "text": "The Model Checking problem for concurrent transition systems is PSPACEcomplete [37]. In Section 3.1, we prove that the following problems are \u2016;PSPACEhard, which implies that they remain PSPACE-hard even if preprocessing is allowed.\n1. model checking on the synchronous and interleaved asynchronous composition of transition systems, where the transitions systems are the fixed part of the problem and the LTL formula is the varying part;\n2. the same problem, where the LTL formula is the fixed part and the transition system is the varying part;\n3. given a set of transition systems and a formula as the fixed part, a state as the varying part, checking whether the state is a legal initial state.\nWe can conclude that preprocessing the model or the formula does not lead to a polynomial algorithm for model checking. We recall that the fixed part is preprocessed off-line in a polynomial data structure during the preprocessing phase, and the varying part is given on-line.\nThe relevance of the first two problems is clear: in formal verification, it is often the case that many properties (formulae) have to be verified over the same system (the model, in this case modeled by the transition systems); on the other hand, it may also be that the same property has to be verified on different systems.\nThe result about the third problem is less interesting by itself. On the other hand, we use it to prove that the superpolynomial growth of the size of the data structures (e.g. OBDDs) currently used in model checkers based on the Symbolic Model Checking algorithms [43] (such as SMV and NuSMV) cannot be avoided in general. The result is independent from its variable ordering, and it holds for others data structures that can be employed. We show these results in Section 3.2.\nWe point out that most of Temporal Logic Model Checking algorithms [20] fall in one of three classes: Symbolic Model Checking algorithms, which work on symbolic representation of M ; algorithms based on Bounded Model Checking [7] (i.e. based on reduction from Model Checking into SAT); algorithms that work on an explicit representation of M (e.g. [32]). Our results concerning the size of the BDD (or some other decision diagrams) are valid for all algorithms of the first class.\nIn the proofs of the following sections we consider Existential Model Checking problems, but the results are valid also for the Universal case; in fact PSPACE is closed under complementation also for compilability."}, {"heading": "3.1 Preprocessing Model Checking", "text": "We now identify the complexity of the Model Checking problem when the preprocessing of the model (represented as the composition of transition systems) is allowed, both in the synchronous and in the interleaved case.\nTheorem 1 The model checking problem for k synchronous concurrent process MCsyn = \u3008(M1|| . . . ||Mk), \u03d5\u3009 where \u03d5 \u2208 LTL is \u2016;PSPACE-hard, and remains \u2016;PSPACE-hard for \u03d5 \u2208 L(F,G,X).\nProof. It is similar to the proof of the Theorem 2. We carry out a reduction from the PLANSAT \u22171 problem, that satisfies the conditions of representative equivalence; the main difference is about the LTL formula.\nWe now consider the Model Checking problem for concurrent processes composed in a interleaved way when the model can be preprocessed.\nTheorem 2 The model checking problem for k interleaved concurrent process MCasyn = \u3008(M1| . . . |Mk), \u03d5\u3009 where \u03d5 \u2208 LTL is \u2016;PSPACE-complete, and remains \u2016;PSPACE-hard for \u03d5 \u2208 L(F,G,X).\nProof. We show a reduction, that translates an instance y \u2208 PLANSAT \u22171 into an instance \u3008r(y), h(y)\u3009 \u2208 Masyn, satisfying the condition of representative equivalence. Given y = \u3008P,O, I,G\u3009 \u2208 PLANSAT \u22171\n- r(y) defines a concurrent transition systems M1, . . . ,Mn, where each Mi is obtained from a variable xi \u2208 P and it is described by:\nVi = {xi}\nIi(Vi) = (xi) \u2228 (\u00acxi) \u033ai(Vi, V \u2032 i ) = (xi = 0 \u2227 x \u2032 i = 0) \u2228 (xi = 0 \u2227 x \u2032 i = 1) \u2228\n(xi = 1 \u2227 x\u2032i = 0) \u2228 (xi = 1 \u2227 x \u2032 i = 1)\nThe process M = M1\u2016 . . . \u2016Mn represents all possible computations, starting from all possible initial assignments, over the variables x1, . . . , xn.\n- h(y) = h(I,G,O) = \u00ac(\u03c6I \u2227 \u03c6G \u2227 \u03c6O) where:\n\u03d5I = \u2227\ni\u2208I xi \u2227\n\u2227\ni/\u2208I\n\u00acxi\n\u03d5G = F ( \u2227\ni\u2208M xi \u2227\n\u2227\ni\u2208N \u00acxi)\n\u03d5O = G m \u2228\ni=0\n[ \u2016\u03c6i\u2016 \u2227\nh=1\n\u03c6hi \u2227 \u2016\u03b7i\u2016 \u2227\nh=1\n\u00ac\u03b7hi \u2227X\u03b3i \u2227 n \u2227\nj 6=i j=1\n(xj \u2194 Xxj)]\nwhere\n\u03b3i =\n{\n\u03b1i if \u03b1i 6= \u2205 \u00ac\u03b2i if \u03b2i 6= \u2205\n\u03d5I adds constraints about the initial states of y represented by I.\n\u03d5G adds constraints about the goal states of y represented by G: it tells that a goal state will be reached.\n\u03d5O describes the operators in O: globally (i.e. in every state) one of the operators must be used to go in the next state; \u03d5O also describes the nop operator o0.\nNow, we prove that y \u2208 PLANSAT \u22171 iff \u3008r(y), h(y)\u3009 \u2208 Masyn. Given y = \u3008P,O, I,G\u3009, a solution for y is a plan which generates the following sequence of states: (s1, . . . , sp) where s1 is an initial state and sp is a goal state. This sequence of states is obtained applying a sequence of operators (oh1 , . . . , ohp) chosen in O = {o1, . . . , om} in the following way: for all i s.t. 1 \u2264 i \u2264 p, preconditions for ohi are included in the state si, and the state si+1 is obtained from the state si modifying the postcondition associated with ohi . We remark that a state in STRIPS is the set of conditions.\nThe model M = r(y) = r(P ) represents all possible traces starting from all possible initial configurations, over the variables x1, . . . , xn. Thus, in this case the Existential Model Checking problem \u3008M,\u03d5\u3009 reduces to the satisfiability problem for \u03d5: we check whether ther exists a trace among all traces over the variables x1, . . . , xn that satisfies the LTL formula \u03d5. Therefore, we have to prove that y \u2208 A iff \u03d5 = h(y) is satisfiable:\n\u21d2. Given a solution for y \u2208 A, we identify a model for \u03d5 = h(y); by construction such a model has:\n- initial state sM1 s.t. \u2113(s1) = I \u222a {\u00acxi|xi /\u2208 I}\n- a state sMp s.t. \u2113(sp) \u2286 M\u222a {\u00acxi|xi /\u2208 N}\n- given a state sMi , s M i+1 is successor of s M i iff\n- \u2113(sMi ) \u2286 Precond(ohi ), where Precond(ohi) = {xj |xj \u2208 \u03c6hi} \u222a {\u00acxj |xj \u2208 \u03b7hi} - \u2113(sMi+1) = \u2113(s M i ) \u222a \u03b1i \u2212 \u03b2i\nwhere \u03b1i is the positive postcondition of ohi and \u03b2i is the negative postcondition of ohi .\n- an infinite number of states: when the state sp is reached this state is repeated for at least once or for ever (applying the nop operator o0), or it is possible, it depends from y, to apply any operators whose preconditions are satisfied by \u2113(sMp ).\n\u21d0. Let (sM1 , . . . , s M p , . . .) a model for \u03d5, and let sp the goal state, that the first state satisfying \u03d5G. We obtain the sequence of states visited by a plan which is a solution for y, by cutting the states after the goal state sp and assigning si = \u2113(s M i ); thus this sequence of states (s1, . . . , sp), associated with the plan, has by construction:\n- initial state s1 s.t. s1 = I \u222a {\u00acxi|xi /\u2208 I}\n- a state sp s.t. sp \u2286 M\u222a {\u00acxi|xi /\u2208 N}\n- given a state si, si+1 is successor of si iff\n- si \u2286 Precond(ohi )\n- si+1 = si \u222a \u03b1i \u2212 \u03b2i where \u03b1i is the positive postcondition of ohi and \u03b2i is the negative postcondition of ohi .\nNow we show the complexity results, both in the synchronous and in the interleaved case, when the formula can be preprocessed.\nTheorem 3 The model checking problem for k synchronous concurrent process MC\u2032syn = \u3008\u03d5, (M1|| . . . ||Mk)\u3009 where \u03d5 \u2208 LTL is \u2016;PSPACE-complete, and remains \u2016;PSPACE-hard for \u03d5 \u2208 L(F,G,X).\nProof. PLANSAT \u22171 is the following problem of planning: giving a STRIPS [29] instance y = \u3008P,O, I,G\u3009 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT \u22171 is PSPACE-complete [12]. Without loss of generality we consider y = (P,O \u222a o0, I, G), where o0 is a operator which is always usable (it has no preconditions) and does nothing (it has no postconditions). We use the following notation: P = {x1, . . . , xn}, I is the set of conditions true in the initial state, G = \u3008M,N\u3009. A state in STRIPS is a set of conditions.\nIn the following we indicate with \u03c6hi the hth positive precondition of the operator oi, and with \u03b7 h i the hth negative precondition of the operator oi; \u03b1i is the positive postcondition of the operator oi, \u03b2i is the negative postcondition of the operator oi. Since any operator has only one postcondition, for every operator i it hold that \u2016\u03b1i \u222a \u03b2i\u2016 = 1.\nWe show a polynomial reduction from the problem A to the problem B that satisfies the condition of representative equivalence. This proves that B is \u2016;C-hard, if A is C-hard; to apply this condition we must define a Classification Function, a Representative Function and a Extension Function for A. Thus we use such a proof schema: we define a Classification Function, a Representative Function and a Extension Function for PLANSAT \u22171 , then we show a polynomial reduction from an instance y \u2208 PLANSAT \u22171 to an instance \u3008r(y), h(y)\u3009 \u2208 MC\u2032SY N that satisfies the condition of representative equivalence.\nLet y = \u3008P,O, I,G\u3009 \u2208 PLANSAT \u22171 . We define r and h as follows:\n- r(y) = r(P ) = \u00ac { F (xg) \u2227G \u2227n\ni=0\n[\n\u00ac(xi \u2194 Xxi) \u2192 \u2227n j=1\nj 6=i (xj \u2194 Xxj)\n]}\n- h(y) defines the transition systems M1\u2016 . . . \u2016Mk. The generic Mi is obtained from the operators oi1 , . . . , oidi whose postcondition involves the variable xi \u2208 P ; di is the number of such operators. We add the variable xg; thus we have at most as many processes as variables: if k is the number of variables used as postcondition of operators plus one, we have k \u2264 n+1. Let Mk the process associated with the variable xg; this variable is 0 at the beginning and it becomes 1 only when the goal of the PLANSAT problem is reached. Mi, for i s.t. 1 \u2264 i < k, is defined by:\nVi = \u22c3di q=1 \u03c6iq \u222a \u03b7iq \u222a \u03b1iq \u222a \u03b2iq Ii(Vi) = \u2227\nxj\u2208I\u2229Vi\nxj \u2227 \u2227\nxj\u2208I\u222aVi\n\u00acxj\n\u033ai(Vi, V \u2032 i ) = \u2228di k=1\n\u2016\u03c6ik\u2016 \u2227\nh=1\n\u03c6hik \u2227 \u2016\u03b7ik\u2016 \u2227\nh=1\n\u00ac\u03b7hik \u2227 \u00ac( \u2227\ni\u2208M xi \u2227\n\u2227\ni\u2208N \u00acxi) \u2227 (x\u2032i \u2261 bik)\nwhere bik =\n{\n1 if \u03b1ik 6= \u2205 0 if \u03b2ik 6= \u2205\nThe process Mk is defined by:\nVk = {xg}\nIk(V ) = (xg = 0) \u033ak(Vk, V \u2032 k) = \u2227 i\u2208M xi \u2227 \u2227 i\u2208N \u00acxi \u2227 x \u2032 g = 1\nNow we prove that this reduction is correct, i.e. y \u2208 PLANSAT \u22171 iff \u3008r(y), h(y)\u3009 \u2208 MC\u2032SY N .\n\u21d2. Given a solution for y \u2208 PLANSAT \u22171 , we show a path of M which satisfies \u03d5 (r(y) defined above).\nA solution for y is a plan which generates the following sequence of states: (s1, . . . , sp) where s1 is a initial state and sp is a goal state. This sequence of states is obtained by applying a sequence of operators (oh1 , . . . , ohp).\nBy construction M admits a path (sM1 , . . . , s M p , s M p+1, . . . ) s.t.:\n- \u2113(sMi ) = si \u222a \u00acxg for i 1 \u2264 i \u2264 p\n- \u2113(sMp+1) = sp \u222a xg\nThis path satisfies \u03d5:\n- \u03d5 does not constrain about the initial state, therefore every initial state of the model is legal;\n- xg \u2286 \u2113(sMp+1), therefore F (xg) is true;\n- the path shown is s.t. only one variable change at a time, therefore the subformula under the Globally is true.\n\u21d0. Given a path of M which satisfies \u03d5, we show a solution for y \u2208 PLANSAT \u22171 . The path is a sequence (sM1 , . . . , s M p , s M p+1, . . . ). We can obtain the sequence of states visited by a plan for y in this way:\n- si = \u2113(s M i )\u2212 {\u00acxg} for i 1 \u2264 i \u2264 p;\n- we ignore the rest of the path of M .\nTheorem 4 The model checking problem for k interleaved concurrent process MC\u2032asyn = \u3008\u03d5, (M1| . . . |Mk)\u3009 where \u03d5 \u2208 LTL is \u2016;PSPACE-complete, and remains \u2016;PSPACE-hard for \u03d5 \u2208 L(F ).\nProof. We carry out a reduction from the PLANSAT \u22171 problem, that satisfies the conditions of representative equivalence. The proof is similar to the proof of the Theorem 3.\nNow we introduce the decision problem MCs0 = \u3008[M,\u03d5], s0\u3009, where M is specified by the interleaved parallel composition of k transition systemsM1, . . . ,Mk, \u03d5 \u2208 L(F ), and s0 is a specific state. MCs0 is true if the model checking problem for concurrent transition system \u3008M,\u03d5\u3009 has solution and s0 is a legal initial state i.e., is an initial state belonging to M that satisfies \u03d5.\nTheorem 5 MCs0 is \u2016;PSPACE-complete.\nProof. The hardness follows from a polynomial time reduction from the problem \u3008(P,O,G), I\u3009, that can be easily shown \u2016;PSPACE-complete on the basis of the results in [40].\nWe sketch the reduction. We encode each operator in O into each process Mi, and the goal G into the formula \u03d5. We encode the set of initial states I using s0."}, {"heading": "3.2 The Size of BDDs", "text": "In this section we prove that the size of BDDs and others data structures increases superpolynomially with the size of the input data, in the worst case, when are used in a Symbolic Model Checking algorithm.\nLet M a model specified by k concurrent transition systems M1, . . . ,Mk, and let \u03d5 an LTL (or a CTL or CTL*) formula.\nTheorem 6 If PSPACE 6\u2286 \u03a0p2 \u2229 \u03a3 p 2, then there is not always a BDD of any kind and with any variable order that is polynomially large and represents the set of initial states consistent with M and \u03d5.\nProof. The evaluation problem for any kind of BDD, i.e. giving a BDD and an assignment of its variables evaluate the BDD, is in P . If there exists a poly-size BDD representing the set of initial states consistent with M and \u03d5, then we can compile M and \u03d5 in the BDD and evaluate the assignment (representing a initial state) in polynomial time. This implies that MCs0 is in \u2016;P. We know from Theorem 5 that MCs0 is \u2016;PSPACE-complete. Therefore if such a BDD exists, then \u2016;PSPACE=\u2016;P. Now, by applying Theorem 2.12 in [15], we conclude that there is no poly-size reduction from MCs0 to the evaluation problem for a BDD, if PSPACE 6\u2286 \u03a0p2 \u2229 \u03a3 p 2.\nSymbolic Model Checking algorithms work by building a representation of the set of the initial states of M that satisfy \u03d5. In particular, this set is represented by BDDs. Therefore, the last theorem proves that these algorithms, in the worst case, end up with a BDD of superpolynomial size. This result does not depend on the kind of BDD used (free, ordered, etc.) and on the variable ordering. On the contrary, it holds also when the states are labeled with enumerative variable; in other words it holds not only for BDD but also for any decision diagram, provided that the evaluation problem over this representation of the states is in a class of the polynomial hierarchy. More formally, we consider an arbitrary representation of a set of states. The evaluation problem is that of determining whether a state belongs to a set.\nTheorem 7 Given a method for representing a set of states whose evaluation problem is in a class \u03a3pi of the polynomial hierarchy, it is not always possible to represent in polynomial space the set of legal initial states of a model M and a formula \u03d5, provided that \u03a3pi+1 6= \u03a0 p i+1.\nThe proof of this theorem has the same structure of the proof of the Theorem 6.\nInstances of such data structures, currently used in Symbolic Model Checking tools, are BDDs, Boolean Expression Diagrams (BEDs) [54] and Reduced Boolean Circuits (RBCs) [1]. Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].\nOn the other hand, it is also possible to prove that the above two theorems cannot be stated unconditionally: indeed if P = PSPACE, then there is a data structure of polynomial size allowing the representation of the set of initial states in such a way deciding whether a state is in this set can be decided in polynomial time. As a result, the non-conditioned version of the above two theorems implies a separation in the polynomial hierarchy."}, {"heading": "4 Related Works", "text": "Some works in the literature are related to the results in this article:\n1. the exponential growth of the BDD size respect to a particular problem (e.g. integer multiplication [10]); some results concern the size growth of other decision diagrams [25] respect to particular problems. While these results are not conditional to the collapse of the polynomial hierarchy as the ones reported in this paper, they are also more specific, as they concern only specific kinds of data structures (e.g. OBDDs) respect to particular problems (e.g. integer multiplication).\n2. the complexity of model checking:\n(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem;\n(b) it has been shown that [28]:\ni. the complexity of model checking does not decrease under the ipotheses of some structural restrictions (e.g. treewidth) in the input.\nii. despite a CNF formula of bounded treewidth can be represented by an OBDD of polynomial size, the nice properties of treewidthbounded CNF formulas are not preserved under existential quantification or unrolling, that is a basic operation of model checking algorithms.\n(c) the compilability of the model checking problem [27]: it remains PSPACE-complete even if a part of the input, either the implicit model or the formula, is preprocessed using any amount of time and storing the result of this prerpocesing step in a polynomial-sized data structure.\n3. the theoretical limitations of Symbolic Model Checking. The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33]. Moreover, a\nclassic information theoretic argument shows that only a small fraction of all finite Kripke structures can be exponentially compressed [38].\n4. succinctness of languages; for instance [21], in which succinctness of language for preferences are discussed, and [22] that presents results on the succinctness of several formalism, including BDDs and CNF."}], "references": [{"title": "Symbolic reachability analisys based on SAT-solvers", "author": ["P.A. Abdullah", "P. Bjesse", "N. Een"], "venue": "Proceedings of the 6th International Conference on Tools and Algorithms for the Construction and Analisys of Systems (TACAS\u201900),", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2000}, {"title": "Algebraic decision diagrams and their applications", "author": ["R.I. Bahar", "E.A. Frohm", "C.M. Gaona", "C.M. Hachtel", "G.D. Macii", "F. Somenzi"], "venue": "Proceedings of the International Conference CAD, pages 188\u2013191,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1993}, {"title": "The complexity of searching implicit graphs", "author": ["Jos\u00e9 L. Balc\u00e1zar"], "venue": "Artif. Intell.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1996}, {"title": "The complexity of algorithmic problems on succinct instances, pages 351\u2013377", "author": ["Jos\u00e9 L. Balc\u00e1zar", "Antoni Lozano", "Jacobo Tor\u00e1n"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1992}, {"title": "Methodology and system for pratical formal verification of reactive hardware", "author": ["I. Beer", "S. Ben David", "D. Geist", "R. Gewirtzman", "M. Yoeli"], "venue": "Proceedings of the 6th International Conference on Computer-Aided Verification (CAV\u201994), volume 818 of LNCS, pages 182\u2013193. Springer,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1994}, {"title": "On the fly model checking for rctl formulas", "author": ["I. Beer", "S. Ben David", "A. Landver"], "venue": "Proceedings of the 10th International Conference on Computer-Aided Verification (CAV\u201998), volume 1427 of LNCS, pages 184\u2013 194. Springer,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1998}, {"title": "Symbolic model checking without BDDs", "author": ["A. Biere", "A. Cimatti", "E.M. Clarke", "Yunshan Zhu"], "venue": "In Proceedings of the 5th Int. Conf. Tools and Algorithms for the Construction and Analisys of Systems (TACAS\u20191999),", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1999}, {"title": "VIS: a system for verification and syntesis", "author": ["R.K. Brayton", "G.D. Hachtel", "A. Sangiovanni Vincetelli", "F. Somenzi", "A. Aziz", "S.T. Cheng", "S. Edwards", "S. Khatri", "T. Kukimoto", "A. Pardo", "S. Qadeer", "R.K. Ranjan", "S. Sarwary", "T.R. Shiple", "G. Swamy", "T. Villa"], "venue": "Proceedings of the 8th International Conference on Computer-Aided Verification (CAV\u201996), volume 1102 of LNCS, pages 428\u2013432. Springer,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1996}, {"title": "Verification of arithmetic circuits using binary moment diagrams", "author": ["Randal E. Bryant", "Yirng-An Chen"], "venue": "STTT, 3(2):137\u2013155,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2001}, {"title": "On the complexity of vlsi implementations and graph representations of boolean functions with application to integer multiplication", "author": ["R.E. Bryant"], "venue": "IEEE Transactions on Computers, 40:205\u2013213,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1991}, {"title": "Symbolic model checking: 100 states and beyond", "author": ["Jerry R. Burch", "Edmund M. Clarke", "Kenneth L. McMillan", "David L. Dill", "L.J. Hwang"], "venue": "Inf. Comput.,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1992}, {"title": "Complexity results for planning", "author": ["T. Bylander"], "venue": "Proceedings of the 12th International Joint Conference on Artificial Intelligence, LNCS, pages 274\u2013 279, San Mateo, CA,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1991}, {"title": "Space efficency of propositional knowledge representation formalisms", "author": ["M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf"], "venue": "Journal of Artificial Intelligence Research, 13:25\u201364,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1999}, {"title": "The size of a revised knowledge base", "author": ["M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf"], "venue": "Artificial Intelligence, 115:1\u201331,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2000}, {"title": "Preprocessing of intractable problems", "author": ["M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf"], "venue": "Information and Computation, 176:89\u2013120,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2002}, {"title": "NuSMV 2.4 User\u2019s Manual", "author": ["R. Cavada", "A. Cimatti", "E. Olivetti", "M. Pistore", "M. Roveri"], "venue": "IRST, http://nusmv.irst.itc.it,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "NuSMV 2: An opensource tool for symbolic model checking", "author": ["A. Cimatti", "E.M. Clarke", "E. Giunchiglia", "F. Giunchiglia", "M. Pistore", "M. Roveri", "R. Sebastiani", "A. Tacchella"], "venue": "Proceedings of the 14th International Conference on Computer-Aided Verification (CAV\u201902),", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2002}, {"title": "Multi terminal binary decision diagrams: An efficient data structure for matrix representation", "author": ["E. Clarke", "M. Fujita", "P. McGeer", "K.L. McMillan", "J. Yang", "X. Zhao"], "venue": "Proceedings of the International Workshop on Logic and Synthesis, pages 1\u201315,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1993}, {"title": "Progress on the state explosion problem in model checking", "author": ["Edmund M. Clarke", "Orna Grumberg", "Somesh Jha", "Yuan Lu", "Helmut Veith"], "venue": "In Informatics,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "Model Checking", "author": ["E.M. Clarke", "O. Grumberg", "D.A. Peled"], "venue": "MIT Press,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2000}, {"title": "Expressive power and succinctness of propositional languages for preference representation", "author": ["Sylvie Coste-Marquis", "J\u00e9r\u00f4me Lang", "Paolo Liberatore", "Pierre Marquis"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2004}, {"title": "A knowledge compilation", "author": ["Adnan Darwiche", "Pierre Marquis"], "venue": "map. J. Artif. Intell. Res. (JAIR),", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2002}, {"title": "A parametric analysis of the state explosion problem in model checking", "author": ["St\u00e9phane Demri", "Fran\u00e7ois Laroussinie", "Ph. Schnoebelen"], "venue": "In STACS,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2002}, {"title": "Parametrized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Springer,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1999}, {"title": "Binary decision diagrams in theory and practice", "author": ["R. Drechsler", "D. Sieling"], "venue": "International Journal on Software Tools for Technology Transfer (STTT), 3(2):112\u2013136, May", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2001}, {"title": "The complexity of problems on graphs represented as obdds", "author": ["Joan Feigenbaum", "Sampath Kannan", "Moshe Y. Vardi", "Mahesh Viswanathan"], "venue": "Chicago J. Theor. Comput. Sci.,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1999}, {"title": "Model checking and preprocessing", "author": ["Andrea Ferrara", "Paolo Liberatore", "Marco Schaerf"], "venue": "In AI*IA,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2007}, {"title": "Treewidth in verification: Local vs. global", "author": ["Andrea Ferrara", "Guoqiang Pan", "Moshe Y. Vardi"], "venue": "In LPAR,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2005}, {"title": "Strips: a new approach to the application of theorem proving to problem solving", "author": ["R. Fikes", "N. Nilson"], "venue": "Artificial Intelligence, 2:189\u2013209,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1971}, {"title": "Succinct representations of graphs", "author": ["Hana Galperin", "Avi Wigderson"], "venue": "Information and Control,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1983}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": "W.H. Freeman and Company, San Francisco, Ca,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1979}, {"title": "Simple on-the-fly automatic verification of linear temporal logic", "author": ["R. Gerth", "D. Peled", "M.Y. Vardi", "P.Wolper"], "venue": "In Proceedings of the 13th Symposium on Protocol Specification, Testing and Verification,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1995}, {"title": "Succinctness as a source of complexity in logical formalisms", "author": ["Georg Gottlob", "Nicola Leone", "Helmut Veith"], "venue": "Ann. Pure Appl. Logic,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1999}, {"title": "The model checker spin", "author": ["G.J. Holzmann"], "venue": "IEEE Transactions on Software Engineering, 23(5):279\u2013295,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 1997}, {"title": "An automata theoretic approach to branching-time model checking", "author": ["O. Kupferman", "M.Y. Vardi", "P. Wolper"], "venue": "Journal of ACM, 47(2):312\u2013360,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2000}, {"title": "An Introduction to Kolmogorov Complexity and Its Applications", "author": ["M. Li", "P. Vitanyi"], "venue": "Springer Verlag,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1997}, {"title": "Monotonic reductions, representative equivalence, and compilation of intractable problems", "author": ["P. Liberatore"], "venue": "Journal of ACM, 48(6):1091\u20131125,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2001}, {"title": "On the complexity of case-based planning", "author": ["Paolo Liberatore"], "venue": "Technical Report cs.AI/0407034, Computing Research Repository (CoRR),", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2004}, {"title": "The complexity of graph problems fore succinctly represented graphs", "author": ["Antoni Lozano", "Jos\u00e9 L. Balc\u00e1zar"], "venue": "In WG,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1989}, {"title": "Temporal Verification of Reactive Systems - Safety", "author": ["Z. Manna", "A. Pnueli"], "venue": "Springer Verlag,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 1995}, {"title": "Symbolic Model Checking", "author": ["K.L. McMillan"], "venue": "Kluwer Academic,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 1993}, {"title": "A note on succinct representations of graphs", "author": ["Christos H. Papadimitriou", "Mihalis Yannakakis"], "venue": "Information and Control,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1986}, {"title": "The temporal logic of programs", "author": ["A. Pnueli"], "venue": "Proceeding of the 18th IEEE Symposium on Foundations of Computer Science (FOCS\u201977), pages 46\u201357,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 1977}, {"title": "The complexity of temporal logic model checking", "author": ["Ph. Schnoebelen"], "venue": "In Proceedings of the 4th Internationa Workshop in Advances in Modal Logic (AiML\u201902),", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2002}, {"title": "The complexity of propositional linear temporal logics", "author": ["A.P. Sistla", "E.M. Clarke"], "venue": "Journal of ACM, 32(3):733\u2013749,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 1985}, {"title": "The polynomial-time hierarchy", "author": ["L.J. Stockmeyer"], "venue": "Theoretical Computer Science, 3:1\u201322,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 1976}, {"title": "Succinct representations of counting problems", "author": ["Jacobo Tor\u00e1n"], "venue": "In AAECC, pages 415\u2013426,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 1988}, {"title": "Succinct representation and leaf languages", "author": ["Helmut Veith"], "venue": "Electronic Colloquium on Computational Complexity (ECCC),", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 1995}, {"title": "Languages represented by boolean formulas", "author": ["Helmut Veith"], "venue": "Inf. Process. Lett.,", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 1997}, {"title": "Succinct representation, leaf languages, and projection reductions", "author": ["Helmut Veith"], "venue": "Inf. Comput.,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1998}, {"title": "VIS User\u2019s Manual", "author": ["T. Villa", "G. Swarny", "T. Shiple"], "venue": "VIS Group, http://vlsi.colorado.edu/\u223cvis/usrDoc.html,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2003}, {"title": "Combining decision diagrams and SAT procedures for efficient symbolic model checking", "author": ["P.F. Williams", "A. Biere", "E.M. Clarke", "A. Gupta"], "venue": "Proceedings of the 14th International Conference on Computer-Aided Verification (CAV 2000), volume 1855 of LNCS, pages 124\u2013138. Springer,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 19, "context": "Temporal Logic Model Checking [20] is a verification method for discrete systems.", "startOffset": 30, "endOffset": 34}, {"referenceID": 4, "context": "It is used, for example, for the verification of protocols and hardware circuits [5].", "startOffset": 81, "endOffset": 84}, {"referenceID": 33, "context": "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].", "startOffset": 30, "endOffset": 34}, {"referenceID": 40, "context": "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].", "startOffset": 43, "endOffset": 47}, {"referenceID": 16, "context": "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].", "startOffset": 83, "endOffset": 87}, {"referenceID": 5, "context": "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].", "startOffset": 98, "endOffset": 101}, {"referenceID": 7, "context": "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].", "startOffset": 108, "endOffset": 111}, {"referenceID": 19, "context": "Two temporal logics are mainly used to define the specification: CTL [20] and LTL [45].", "startOffset": 69, "endOffset": 73}, {"referenceID": 42, "context": "Two temporal logics are mainly used to define the specification: CTL [20] and LTL [45].", "startOffset": 82, "endOffset": 86}, {"referenceID": 15, "context": "Many tools allow to build the model separately from checking the formula [16, 53, 36].", "startOffset": 73, "endOffset": 85}, {"referenceID": 50, "context": "Many tools allow to build the model separately from checking the formula [16, 53, 36].", "startOffset": 73, "endOffset": 85}, {"referenceID": 15, "context": "Many tools allow populating a property database [16, 53, 36], i.", "startOffset": 48, "endOffset": 60}, {"referenceID": 50, "context": "Many tools allow populating a property database [16, 53, 36], i.", "startOffset": 48, "endOffset": 60}, {"referenceID": 14, "context": "The technical tool we use is the compilability theory [15, 39].", "startOffset": 54, "endOffset": 62}, {"referenceID": 36, "context": "The technical tool we use is the compilability theory [15, 39].", "startOffset": 54, "endOffset": 62}, {"referenceID": 40, "context": "Finally, we answer to a long-time standing question in Symbolic Model Checking [43, 11].", "startOffset": 79, "endOffset": 87}, {"referenceID": 10, "context": "Finally, we answer to a long-time standing question in Symbolic Model Checking [43, 11].", "startOffset": 79, "endOffset": 87}, {"referenceID": 51, "context": "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].", "startOffset": 147, "endOffset": 151}, {"referenceID": 8, "context": "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].", "startOffset": 166, "endOffset": 169}, {"referenceID": 0, "context": "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].", "startOffset": 176, "endOffset": 179}, {"referenceID": 17, "context": "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].", "startOffset": 188, "endOffset": 192}, {"referenceID": 1, "context": "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].", "startOffset": 203, "endOffset": 206}, {"referenceID": 44, "context": "We follow the notation of [47, 46].", "startOffset": 26, "endOffset": 34}, {"referenceID": 43, "context": "We follow the notation of [47, 46].", "startOffset": 26, "endOffset": 34}, {"referenceID": 19, "context": "A Kripke structure can be seen as a transition system [20].", "startOffset": 54, "endOffset": 58}, {"referenceID": 39, "context": "Thus the global system is obtained by parallel composition of the transition systems representing its components and sharing some variables [42, 20]; using this approach, we can give results valid for all model checkers.", "startOffset": 140, "endOffset": 148}, {"referenceID": 19, "context": "Thus the global system is obtained by parallel composition of the transition systems representing its components and sharing some variables [42, 20]; using this approach, we can give results valid for all model checkers.", "startOffset": 140, "endOffset": 148}, {"referenceID": 39, "context": "The formal definition is as follows [42, 20].", "startOffset": 36, "endOffset": 44}, {"referenceID": 19, "context": "The formal definition is as follows [42, 20].", "startOffset": 36, "endOffset": 44}, {"referenceID": 45, "context": "3 Complexity and Compilability We assume that the reader knows the basic concepts of complexity theory [48, 31].", "startOffset": 103, "endOffset": 111}, {"referenceID": 30, "context": "3 Complexity and Compilability We assume that the reader knows the basic concepts of complexity theory [48, 31].", "startOffset": 103, "endOffset": 111}, {"referenceID": 14, "context": "The compilability classes [15] have to be used instead.", "startOffset": 26, "endOffset": 30}, {"referenceID": 14, "context": "More details can be found in [15].", "startOffset": 29, "endOffset": 33}, {"referenceID": 14, "context": "Since the regular polynomial reductions are not appropriate when preprocessing is allowed, ad-hoc reductions (called nu-comp reductions in [15]) have been defined.", "startOffset": 139, "endOffset": 143}, {"referenceID": 36, "context": "Can we use this reduction to prove the \u2016;C-hardness of B ? Liberatore [39] shows sufficient conditions that should hold on A as well as on the reduction.", "startOffset": 70, "endOffset": 74}, {"referenceID": 36, "context": "The condition of representative equivalence can be proved to imply that the problem B is \u2016;C-hard, if A is C-hard [39].", "startOffset": 114, "endOffset": 118}, {"referenceID": 28, "context": "PLANSAT \u2217 1 is the following problem of planning: giving a STRIPS [29] instance y = \u3008P,O, I,G\u3009 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT \u2217 1 is PSPACE-Complete [12].", "startOffset": 66, "endOffset": 70}, {"referenceID": 11, "context": "PLANSAT \u2217 1 is the following problem of planning: giving a STRIPS [29] instance y = \u3008P,O, I,G\u3009 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT \u2217 1 is PSPACE-Complete [12].", "startOffset": 242, "endOffset": 246}, {"referenceID": 14, "context": "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.", "startOffset": 122, "endOffset": 126}, {"referenceID": 13, "context": "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.", "startOffset": 151, "endOffset": 159}, {"referenceID": 12, "context": "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.", "startOffset": 151, "endOffset": 159}, {"referenceID": 36, "context": "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.", "startOffset": 222, "endOffset": 226}, {"referenceID": 34, "context": "The Model Checking problem for concurrent transition systems is PSPACEcomplete [37].", "startOffset": 79, "endOffset": 83}, {"referenceID": 40, "context": "OBDDs) currently used in model checkers based on the Symbolic Model Checking algorithms [43] (such as SMV and NuSMV) cannot be avoided in general.", "startOffset": 88, "endOffset": 92}, {"referenceID": 19, "context": "We point out that most of Temporal Logic Model Checking algorithms [20] fall in one of three classes: Symbolic Model Checking algorithms, which work on symbolic representation of M ; algorithms based on Bounded Model Checking [7] (i.", "startOffset": 67, "endOffset": 71}, {"referenceID": 6, "context": "We point out that most of Temporal Logic Model Checking algorithms [20] fall in one of three classes: Symbolic Model Checking algorithms, which work on symbolic representation of M ; algorithms based on Bounded Model Checking [7] (i.", "startOffset": 226, "endOffset": 229}, {"referenceID": 31, "context": "[32]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "PLANSAT \u2217 1 is the following problem of planning: giving a STRIPS [29] instance y = \u3008P,O, I,G\u3009 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT \u2217 1 is PSPACE-complete [12].", "startOffset": 66, "endOffset": 70}, {"referenceID": 11, "context": "PLANSAT \u2217 1 is the following problem of planning: giving a STRIPS [29] instance y = \u3008P,O, I,G\u3009 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT \u2217 1 is PSPACE-complete [12].", "startOffset": 242, "endOffset": 246}, {"referenceID": 37, "context": "The hardness follows from a polynomial time reduction from the problem \u3008(P,O,G), I\u3009, that can be easily shown \u2016;PSPACE-complete on the basis of the results in [40].", "startOffset": 159, "endOffset": 163}, {"referenceID": 14, "context": "12 in [15], we conclude that there is no poly-size reduction from MCs0 to the evaluation problem for a BDD, if PSPACE 6\u2286 \u03a0p2 \u2229 \u03a3 p 2.", "startOffset": 6, "endOffset": 10}, {"referenceID": 51, "context": "Instances of such data structures, currently used in Symbolic Model Checking tools, are BDDs, Boolean Expression Diagrams (BEDs) [54] and Reduced Boolean Circuits (RBCs) [1].", "startOffset": 129, "endOffset": 133}, {"referenceID": 0, "context": "Instances of such data structures, currently used in Symbolic Model Checking tools, are BDDs, Boolean Expression Diagrams (BEDs) [54] and Reduced Boolean Circuits (RBCs) [1].", "startOffset": 170, "endOffset": 173}, {"referenceID": 17, "context": "Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].", "startOffset": 139, "endOffset": 143}, {"referenceID": 1, "context": "Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].", "startOffset": 180, "endOffset": 183}, {"referenceID": 24, "context": "Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].", "startOffset": 212, "endOffset": 216}, {"referenceID": 9, "context": "integer multiplication [10]); some results concern the size growth of other decision diagrams [25] respect to particular problems.", "startOffset": 23, "endOffset": 27}, {"referenceID": 24, "context": "integer multiplication [10]); some results concern the size growth of other decision diagrams [25] respect to particular problems.", "startOffset": 94, "endOffset": 98}, {"referenceID": 23, "context": "(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem; (b) it has been shown that [28]: i.", "startOffset": 32, "endOffset": 36}, {"referenceID": 22, "context": "(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem; (b) it has been shown that [28]: i.", "startOffset": 82, "endOffset": 86}, {"referenceID": 27, "context": "(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem; (b) it has been shown that [28]: i.", "startOffset": 154, "endOffset": 158}, {"referenceID": 26, "context": "(c) the compilability of the model checking problem [27]: it remains PSPACE-complete even if a part of the input, either the implicit model or the formula, is preprocessed using any amount of time and storing the result of this prerpocesing step in a polynomial-sized data structure.", "startOffset": 52, "endOffset": 56}, {"referenceID": 18, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 87, "endOffset": 91}, {"referenceID": 25, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 29, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 41, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 2, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 38, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 3, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 46, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 47, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 48, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 49, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 32, "context": "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].", "startOffset": 254, "endOffset": 296}, {"referenceID": 35, "context": "classic information theoretic argument shows that only a small fraction of all finite Kripke structures can be exponentially compressed [38].", "startOffset": 136, "endOffset": 140}, {"referenceID": 20, "context": "succinctness of languages; for instance [21], in which succinctness of language for preferences are discussed, and [22] that presents results on the succinctness of several formalism, including BDDs and CNF.", "startOffset": 40, "endOffset": 44}, {"referenceID": 21, "context": "succinctness of languages; for instance [21], in which succinctness of language for preferences are discussed, and [22] that presents results on the succinctness of several formalism, including BDDs and CNF.", "startOffset": 115, "endOffset": 119}], "year": 2010, "abstractText": "Temporal Logic Model Checking is a verification method in which we describe a system, the model, and then we verify whether some properties, expressed in a temporal logic formula, hold in the system. It has many industrial applications. In order to improve performance, some tools allow preprocessing of the model, verifying on-line a set of properties reusing the same compiled model; we prove that the complexity of the Model Checking problem, without any preprocessing or preprocessing the model or the formula in a polynomial data structure, is the same. As a result preprocessing does not always exponentially improve performance. Symbolic Model Checking algorithms work by manipulating sets of states, and these sets are often represented by BDDs. It has been observed that the size of BDDs may grow exponentially as the model and formula increase in size. As a side result, we formally prove that a superpolynomial increase of the size of these BDDs is unavoidable in the worst case. While this exponential growth has been empirically observed, to the best of our knowledge it has never been proved so far in general terms. This result not only holds for all types of BDDs regardless of the variable ordering, but also for more powerful data structures, such as BEDs, RBCs, MTBDDs, and ADDs.", "creator": "LaTeX with hyperref package"}}}