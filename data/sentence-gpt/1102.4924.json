{"id": "1102.4924", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Feb-2011", "title": "New Worst-Case Upper Bound for #XSAT", "abstract": "An algorithm running in O(1.1995n) is presented for counting models for exact satisfiability formulae(#XSAT). This is faster than the previously best algorithm which runs in O(1.1995n) where the number of objects in the formulae for which the number of nonstandard solutions can be counted is given by the method. To do this, a subset of the equations are evaluated using the same method as described above. It is possible to construct the formula for solving the formulae for each of the equations in the formulae. Here, the formula for calculating the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations in the formulae for each of the equations", "histories": [["v1", "Thu, 24 Feb 2011 08:16:59 GMT  (580kb)", "http://arxiv.org/abs/1102.4924v1", "submitted to AAAI-10"]], "COMMENTS": "submitted to AAAI-10", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["junping zhou", "minghao yin"], "accepted": false, "id": "1102.4924"}, "pdf": {"name": "1102.4924.pdf", "metadata": {"source": "CRF", "title": "New Worst-Case Upper Bound for #XSAT", "authors": ["Junping Zhou", "Minghao Yin"], "emails": ["ymh@nenu.edu.cn"], "sections": [{"heading": null, "text": "previously best algorithm which runs in O(1.2190n). In order to improve the efficiency of the algorithm, a new principle, i.e. the common literals principle, is addressed to simplify formulae. This allows us to eliminate more common literals. In addition, we firstly inject the resolution principles into solving #XSAT problem, and therefore this further improves the efficiency of the algorithm."}, {"heading": "Introduction", "text": "Tremendous efforts have been made on analyzing algorithms for difficult problems, such as propositional satisfiability (SAT) or model counting (#SAT). If P \u2260 NP, these problems are all super-polynomial. When constructing the super-polynomial algorithms, improvements in the exponential time bounds are crucial in determining the size of these problems that can be solved, for even a slight improvement from O(c k ) to O((c-) k ) may significantly increase the size of these problems being\ntractable. Take the 3-SAT problem for example. The currently fastest deterministic algorithm for solving 3-SAT (Kutzkov et al. 2010) ran in O(1.439 n ), which is a meaningful advance over O(2 n ). And the 3-SAT instances with 65 variables can be solved by the algorithm in approximately 10 10 steps, instead of 10 19 (which may not be tractable). Therefore, it is significant to improve the upper bounds on the worst-case running time for problems with high computational complexity.\n#XSAT is one of hard problems whose computational complexity is further up the polynomial hierarchy. Valiant (1979) has proved that #XSAT is #P-complete. This is a problem of computing the number of models for a given formula in Conjunction Normal Form (CNF), i.e., the number of distinct complete truth assignments to variables such that exactly one literal in each clause evaluates to true. In fact, the problem is a vital variant of the well-known #SAT problem, which has a wide range of applications, such as various probabilistic inference problems can be translated into #SAT problem (cf. Park 2002; Sang et al. 2005).\nRecently, most of the efforts in algorithm construction have been dedicated to algorithms for #XSAT problem. For example, based on an algorithm for counting all maximum weight independent sets in a simple graph, Dahllof and Jonsson (2002) presented an upper time bound for #XSAT (O(1.7548 n ), where n is the number of the variables). Further improved algorithm in (Porschen 2005) proposed a new upper time bound for the #XSAT (O(1.3248 n )). Instead of only outputting the number of models, Porschen in 2006 presented an algorithm solving #XSAT for enumerating all exact models of the input formula. By addressing a simple reduction, Dahllof et al. (2004) presented a #XSAT algorithm which ran in O(1.2190 n ), which is the best upper bound so far.\nThe aim of this paper is to exploit new upper bounds for #XSAT. We provide an algorithm for solving #XSAT. This algorithm employs a new principle, i.e. the common variables principle, to simplify formulae. This allows us to eliminate more common variables, and therefore improves the efficiency of the algorithm. In addition, we firstly inject the resolution principles into solving #XSAT problem, which further improves the efficiency of the algorithm. By analyzing the algorithm, we present a deep analysis and obtain the worst-case upper bound O(1.1995 n ) for #XSAT."}, {"heading": "Problem Definitions", "text": "We describe some definitions used in this paper. Let V be a set of propositional variables. Each variable can take the values true or false. A literal is either a variable x or its negation x. Also, each literal can take the values true or false. If a literal is l, the negation of the literal is l. The logic disjunction of a finite number of literals forms a clause. A clause containing\nexactly k literals is also called k-clause. The length of a clause is the number of literals in it, denoted by C . A clause C is a\nunit clause if the length of the clause is 1. And if there is a clause x1  x2  ... xi  C such that C is a disjunction of one or more literals, we call C is a sub-clause. A formula F in Conjunction Normal Form (CNF) is a logic conjunction of a set of clauses. A variable occurring once in F is referred to as singleton. The degree of a variable x, represented by (x), is the\nnumber of times it occurs in F. The degree of a formula F, denoted by (F), is the maximum degree of variables in F. A literal l is an (i + , j + )-literal if F contains at least i occurrences of l and at least j occurrences of l. A literal l is an (i, j)-literal if F contains exactly i occurrences of l and exactly j occurrences of l. And a literal l is monotone if its complementary literal does not appear in F. A truth assignment for F is a map that assigns each variable a value. When a truth assignment makes the F true, we say that the truth assignment satisfies F. The exact satisfiability problem (XSAT) is to determine if a CNFformula has a truth assignment satisfying exactly one literal in each clause. The satisfying assignment of the XSAT, called as a model, is a truth assignment such exactly one literal in each clause is true. The counting exact satisfiablity problem\n(#XSAT) is to compute the number of models for a formula. We define M(F) as the number of models of the formula F, m as the number of clauses in F, n as the number of variables F contains, Var(C) as the variables in C, lit(C) as the set of literals in the clause C, and lit (C')-lit (C) as the set of literals that appear in the clause C' but not in the clause C. We also use F(\u00b5/\u03b7) to denote the substitution of \u00b5 by \u03b7 in the formula F, where \u00b5 is either a literal or a clause and \u03b7 is either a literal or false. To avoid a tedious enumeration of trivialities, if more than one literal is substituted by false, \u00b5 is usually expressed as a set of literals.\nA formula F in CNF can be expressed as an undirected graph called constraint graph. In the constraint graph G, the vertexes are the variables of F and the edges between two vertexes if the corresponding variables appear together in some clause of F. A component of such a graph is a maximal sub-graph such that for every pair of vertices in the sub-graph, there is a path between the pair of vertices. Let F1, F2, \u2026, Fk be the sub-formulae of F corresponding to the components. Then,\nM(F)=M(F1)M(F2)\u2026M(Fk) (1)\nGiven a formula F, the basic strategy of Davis-Putnam-Logemann-Loveland (DPLL) is to arbitrarily choose one or more variables that appear in F. That means that we branch on one or more variables in the formula F, i.e., we assign values to the variable(s) such that the problem for F is reduced to the problem for two or more formulae."}, {"heading": "Estimating the Running Time", "text": "In this section, we explain how to compute an upper bound on the running time of a DPLL-style algorithm. At first, we present a notion called branching tree. The branching tree (Hirsch 2000) is a hierarchical tree structure with a set of nodes, each of which is labeled with a formula. Suppose there is a node labeled with a formula F, then its sons labeled with F1, F2, \u2026 , Fk are obtained by branching on one or more variables in the formula F, i.e., assigning values to the variable(s) such that the formula F is reduced to two or more sub-formulae F1, F2, \u2026 , Fk with fewer variables. Indeed, the construction of a branching tree can be viewed as an execution of a DPLL-style algorithm. Therefore, we use the branching tree to estimate the running time of our algorithm.\nSuppose there is a branching tree whose nodes are labeled with formulae. To each node we attach a branching vector. Let us consider a node labeled with F and its sons labeled with F1, F2, \u2026, Fk. The branching vector of the node labeled with F is a k-tuple (r1, r2,\u2026, rk), where ri=f (F)-f (Fi) and ri >0 (1\u2264 i \u2264 k and f (F) is the number of variables of F). From the definition of the branching vector of the node, it is easy to see that the branching tree requires that each sub-formula has smaller\ncomplexity than the initial formula after the formula being spitted. The characteristic polynomial of the branching vector is defined as follows:\nh(x)=11 i\nk r\ni\nx \n\n (1)\nThe positive root of this polynomial is called the branching number, denoted by  (r1, r2,\u2026, rk). And we assume that the branching number of the leaves is 1. The maximum branching numbers of nodes is defined as the branching number of the branching tree, expressed by max  (r1, r2,\u2026, rk). Actually, the branching number of a branching tree has an important relationship with the running time (T(n)) of a DPLL-style algorithm. At first, assume the running time of a DPLL-style algorithm performing on each node is in polynomial time. Then the following inequality is obtained.\nT(n)  (max  (r1, r2,\u2026, rk)) n  poly(F)\n= (max 1\nk\ni\n T(n-ri)) n  poly(F)\n(2)\nwhere n is the number of variables in F, ploy(F) is the polynomial time executing on the node F, and\n (r1, r2,\u2026, rk)= 1\nk\ni\n T(n-ri) (3)\nIn addition, if a #XSAT problem recursively solved by a DPLL-style algorithm, the time required doesn\u2019t increase, for\n1\nk\ni  T(ni)  T(n) where n = 1\nk\ni\n ni (4)\nwhere n is the number of variables, ni is the number of variables in the sub-formula Fi (1ik) of the formula F. Note that when analyzing the running time, we ignore the polynomial factor so that we assume that all polynomial time computations take O(1) time in this paper."}, {"heading": "Algorithm for Solving #XSAT", "text": "In this section, we present the algorithm #XSAT for counting models of the exact satisfiability problem and prove an upper bound O(1.1995 n ). Firstly we address some principles used in this part."}, {"heading": "Reduction Principles", "text": "In this subsection, we concentrate on introducing the common literals principle and describing how to use the resolution principles in solving the #XSAT problem.\nBefore presenting the common variables principle, function unit(F[l]) in Figure 1 is addressed, which recursively executes the propagation. The function takes a formula F and a literal l being assigned true as input. The detailed process of the function is presented as follows. (1) Remove all clauses containing literal l from F; (2) delete all literals occurring with l from the other clauses; (3) delete all occurrences of the negation of literal l from F; (4) perform the process as far as possible. Finally, the function returns a simplified formula. For ease in writing, the function unit(F[l]) is called F[l] for short in the following sections.\nNow we begin to present the common variables principle. Supposing an exact SAT formula F contains at least two clauses\nhaving at least variables in common. Then we can calculate the models of F as follows:\nCommon Literals Principle. Let F=(C  C1)  (C  C2)  \u2026  (C  Ck)  F', where C, C1 , C2,\u2026, Ck are sub-clauses, and Var(C) Var(F\u2019)= . Then,\nM(F)= C M(F'' [x])+ M(F'' [ x]) where F''=\n(x  C1)  (x  C2)  \u2026  (x  Ck)  F' and xC\n(5)\nThis principle is referred to as removing superfluous common literals. For example, F=(x  y  z)  (x  y  r)  (s  p). Then by executing the common literals principle, the formula can be reduced as F''= (x  z)  (x  r)  (s   p). It seems reasonable that M(F)=M(F'') but this is not the case. In a model when x=true, y is false. However, we know that there is a model that x=false and y=true. This means that the reserved literal x represents both, and therefore, we should hold the\nnumber of the common literals when counting the models of the #XSAT problem. Thus, from the above we know if a XSAT formula F can be simplified by the common variables principle, then any two clauses in F don\u2019t have more than two literals in common. And once there are two clauses having more than two literals in common, this means that Var(C) Var(F\u2019)\u2260 and at least one common variable appears in another clause. Then we can branch on maximal degree of\nthe common variables, which allows us to eliminate as many variables as possible.\nNext we describe how to solve the #XSAT problem using the resolution principles which inspired by (Byskov et al. 2005). Actually, the resolution principle is a well-known technique for removing variables occurring both positive and negative and efficiently solving SAT problem. However, it is a pity that the technique can\u2019t be applied in solving #SAT for sometimes it eliminates a few variables which leads to the wrong result. Although #XSAT is also a counting problem, but the technique is suitable to solve #XSAT on account of the nature of the XSAT problem. Since the complexity of each node in the branching tree is strictly greatly than its son, we just use the resolution principle for (1, 1 + )-literals and (2, 2)-literals so that the resolution never increase the complexity. Now suppose that an exact SAT formula F contains a (1, 1 + )-literal or a (2, 2)- literal, then we obtain the following principles.\nResolution Principle 1. Let F = (x  C)  ( x  C1)  ( x  C2)  \u2026  ( x  Ck)  F', where x is a literal, C1 , C2, and Ck are sub-clauses in F. Then,\nM(F)=M(F'')\nwhere F''=(C  C1)  (C  C2)  \u2026  (C  Ck)  F'\n(6)\nResolution Principle 2. Let F=(x  C1)  ( x C2)  ( x  C3)  ( x  C4)  F\u2019, where x is a literal, C1 , C2, C3, and C4 are sub-clauses in F. Then,\nM(F)=M(F'') where F''=(C1  C3)  (C1  C4)  (C2  C3)  (C2  C4)  F'\n(7)\nBy performing the resolution principles, if the reduced formula F contains a variable occurring both unnegated and negated,\nthe literal consisting of the variable must be a (2 + , 3 + )-literal. According to the two resolution principles, we can obtain the follows.\nTheorem 1. Given a formula F, if F only contains (1, 0)-literals, (2, 0)-literals, (3, 0)-literals, and it has a clause x  y, then x and y can be both removed.\nProof. In order to make the formula F true, the clause x  y must be set true. And since in each clause only one literal can be true,  x=y. Thus, y is substituted by x and this makes x a (1, 1)-literals, (2, 1)-literals, or (2, 2)-literals, which can be\nremoved by the two resolution principles. Therefore, x and y can be both removed in this case. \u25a1"}, {"heading": "Helpful Functions", "text": "The subsection discusses some functions used for simplifying the formulae. The first function Reduce(F) in Figure 2 is to simplify the formula F by recursively executing the common literal principle, the resolution principles, and some standard reductions used by (Kulikov 2005). It takes the formula F as input and returns the reduced F and a set of R recording the eliminating sub-clauses. The reason why we use R is that when using the common literal principle, the number of literals in\nthe removed sub-clause C should be hold. In addition, given a XSAT formula F, if a clause contains more than one singleton, we can reserve one singleton and remove the superfluous ones. However, the eliminating sub-clause containing only singletons also causes the wrong result when counting the models of F. Therefore, we introduce the set of R to record the eliminating sub-clauses. According to the function, we obtain the Theorem 2.\nTheorem 2. In a reduced XSAT formula, there are no unit clauses and 2-clauses; no clause has more than one singleton; if there is a variable occurring both unnegated and negated, the literal consisting of the variable must be a (2 + , 3 + )-literal; for all pairs of clauses, each has at least two variables that do not occur in the other; and if two clauses have more than two literals in common, at least one common literal appears in another clause.\nProof. Let us analyze the theorem one by one based on the function Reduce. The reduced formula containing no unit clauses and 2-clauses can be directly obtained by line 1 and 2 of the function. It is easy to see that the clauses in the reduced formula contain at most one singleton from line 8. If the reduced formula contains a variable occurring both unnegated and negated, then the literal composed of the variable may be a (1, 1 + )-literal, a (2, 2)-literal, or a (2 + , 3 + )-literal. When the literal is a (1, 1 + )-literal or a (2, 2)-literal, the literal can be removed by line 9 and 10. So in this case the literal must be a (2 + , 3 + )-literal.For all pairs of clauses, each having at least two variables that do not occur in the other can be obtained by line 7. In addition, if two clauses have more than two literals in common, then at least one common literal appearing in another clause can be\nobtained by line 11. \u25a1\nThe second function  (F, ) in Figure 3 is to assign  true and reduce the formula after assigning values to the variables.\nThe input to the function is the formula, and  , where  can be a literal, two literals, or a clause consisting of only two literals. When  is a literal, the literal is set true directly; when  is a clause, the clause is fixed true and it implies that the only two literals have the complementary truth value; when is two literals, the two literals are assigned true respectively.\nNote that in this function, S is an integer value recording the length of the eliminating sub-clause that  appears in. We assume that P=1 when the literals in don\u2019t appear in R."}, {"heading": "Algorithm #XSAT", "text": "We propose a main algorithm #XSAT (Figure 5) which makes use of another algorithm #XSAT3 when (F)  3. Both of the algorithms are based on the DPLL and take the reduced XSAT formula F as the input. The basic idea of the two algorithms is to choose a variable and recursively count the number of satisfying assignments where the variable is true and the variable is false. At first, we present the framework of our algorithm #XSAT3 for solving #XSAT when  (F)  3 in Figure 4. Note that in the algorithm MC(F) is a function that solves the #XSAT by exhaustive search. As we all know, if a #XSAT instance is solved by exhaustive search, it will spend a lot of time. However, when the number of clauses that the formula F contains is so few, it may run in polynomial time. Therefore, we use the function MC(F) only when the number of clauses isn\u2019t above 4, which can guarantee the exhaustive search runs in polynomial time. In addition, since the operation on each node is the function  (F,  ) running in polynomial time, we analyze the algorithms #XSAT3 and #XSAT using the measure described above in the following theorems.\nTheorem 3. Algorithm #XSAT3 runs in O(1.1995 n ) time, where n is the number of the variables.\nProof. Let us analyze the algorithm case by case.\nCase 1, 2, and 3: These cases run in O(1). Case 4: This case doesn\u2019t increase the time needed.\nCase 5: Suppose the two clauses are of the forms (x  y  C) and (x y  C\u2019). We know that at least the literal x appears in another clause based on Theorem 2.The running time T(n) of the algorithm satisfies the recursive relation\nT(n)=T(n- C - 'C + 'C C -1)+T(n-2-i) (8)\nwhere i is an integer and 'C C is the set of literals occurring in both sub-clauses. When (x  y)=true, the literals in C and C\u2019\nare removed. When x=false and y=false, the two literals are also removed. Furthermore, once C =2 one literal is removed by\nfunction Reduce (line 2), i.e., i=1. And the same situation is encountered when 'C =2. Here, since each clause has at least two\nvariables that do not occur in the other by Theorem 2, C  2, 'C  2, and 'C C  min ( C -2, 'C -2). Moreover,\nif 'C C  1, x and y both occur in another clauses based on Theorem 2. When (x  y)=true, y is substituted by x and this makes x a (1, 1 + )-literals, which we can remove by resolution principle 1. Therefore, it is easy to see that the worst case\noccurs when C =3, 'C =3, 'C C =0 or 'C C =1. The time needed in this case is bounded by T(n)=T(n-7)+T(n-2) with solution O(1.1908 n ).\nCase 6.1: When (x  p)=true, the other two literals are fixed false so as to be removed. Besides, p is substituted by x by function Reduce (line 2) and this makes x a (1, 1 + )-literals, which we can remove by resolution principle 1. Therefore, the current formula contains at least four variables less than F. We have T(n)=2T(n-4) because the same situation arises when (q  r)=true. This case takes O(1.1892 n ) time.\nCase 6.2: Due to the previous cases, we know that the overlap of the clauses is only one literal and the literal is monotone.\nSuppose the other clause that x occurs in is C'. The case 'C =3 runs in T(n)=T(n-5)+T(n-4) time and the remaining cases run\nin T(n)=T(n- 'C -2)+T(n-2-i), where i is an integer. When 'C =4 and z is singleton, the length of the clause the literal y in\nmust be also 4 and there is a singleton in it. When x=false, it makes two singletons occur in the 4-clause and one of the singletons can be removed by function Reduce (line 8), i.e., i=1. Therefore, the worst running time is T(n)=T(n-7)+T(n-2) with solution O(1.1908 n ).\nCase 7: When (x  y)=true, the other two literals are fixed false so as to be removed. Besides, y is substituted by x by function Reduce (line 2) and this makes x a (1, 1 + )-literals, which we can remove by resolution principle 1. Therefore, the current formula contains at least four variables less than F. We have T(n)=2T(n-4) because the same situation arises when (z  p)=true. This case takes O(1.1892 n ) time.\nCase 8: This case is similar to case 7 when (x  y)=true and it removes four variables. On account of the previous cases, we know that the other 4-clause that z also occurs is a clause containing a singleton. Once (z  p)=true, z is substituted by p. This makes two singletons occur in the other 4-clause containing z and one of the singletons can be removed by function Reduce (line 8). Therefore, the time needed in this case is bounded by T(n)=2T(n-4) with solution O(1.1892 n ).\nCase 9: The same circumstance as case 8 arises when (x  y)=true and (z  p)=true. Five variables are removed due to (x  y)=true and one more variable is removed when x or y occur in a 4-clause. When p=true, at least nine variables removed except the case when p occurs in a 4-clause. Above all, it is easy to see that the worst case occurs when all the five literals in the 5-clauses also appear in other 5-clauses. Hence, the time needed in this case is bounded by T(n)=T(n-9)+T(n-5)+T(n-5) with solution O(1.1995 n ).\nCase 10: Since x=true, at least nine variables are removed. This is the same as y=true. Owing to (z  p)=true, three\nvariables are removed. Therefore, the recurrence is T(n)=T(n-9)+T(n-9)+T(n-3) with solution O(1.1925 n ).\nCase 11: According to the above cases, the literal x that isn\u2019t a singleton may occur in a 5-clause. So at least ten variables can be removed due to x=true. When x=false, at least the variable x can be removed. The time needed is bounded by T(n)=T(n-10)+T(n-1) with solution O(1.1975 n ).\nCase 12: Each of the remaining clauses is 5-clause with one singleton based on the previous cases. The similar case as 7 when (x  y)=true and this makes five variables remove. When z=true, at least nine variables are removed. In addition, five variables are removed because the similar case as 8 occurs when (p  q)=true. So the time needed in this case is bounded by T(n)=T(n-9)+T(n-5)+T(n-5) with solution O(1.1995 n ).\nIn total, #XSAT3 runs in O(1.1995 n ) time. \u25a1\nTheorem 4. Algorithm #XSAT runs in O(1.1995 n ) time, where n is the number of the variables.\nProof. Let us analyze the algorithm case by case.\nCase 1and 2: These cases run in O(1). Case 3: This case doesn\u2019t increase the time needed. Case 4: It is easy to see that the worst case occurs when the all variable x occurs in the 3-clauses because in a reduced formula the length of the clause is at least three by Theorem 2. So when x=true, seven variables are removed; when x=false, five variables are removed. The time needed is bounded by T(n)=T(n-7)+T(n-5) with solution O(1.1238 n ).\nCase 5: This case is the same with the case 5 in Theorem 3. Therefore, the time needed in this case is bounded by\nT(n)=T(n-7)+T(n-2) with solution O(1.1908 n ).\nCase 6: Suppose x occurs in C1, C2, C3, and C4.When x=true, the other literals in every clause containing x are fixed false\nso that it makes 1 C + 2 C + 3 C + 4 C -3 variables remove. When x=false, one variable is removed and at least one more variables\ncan be removed once i C =3 (i=1, 2, 3, 4). Therefore, it is easy to see that the worst case occurs when x occurs in the 4-clauses. So at least thirteen variables can be removed due to x=true. When x=false, at least the variable x can be removed. The time needed is bounded by T(n)=T(n-13)+T(n-1) with solution O(1.1632 n ).\nCase 7: The result follows from Theorem 3 if  (F)  3.\nIn total, #XSAT runs in O(1.1995 n ) time. \u25a1"}, {"heading": "Conclusion", "text": "This paper addresses the worst-case upper bound for #XSAT. The algorithm presented is DPLL-style algorithm. In order to improve the algorithms, we put forward a new common literals principle to simplify the formulae and firstly inject the resolution principles into solving #XSAT problem, which further improves the efficiency of the algorithm. After a skillful analysis of these algorithms, we obtain the worst-case upper bound O(1.1995 n ) time for #XSAT, where n is the number of the variables."}], "references": [{"title": "New algorithms for Exact Satisfiability", "author": ["J. Byskov", "A. Madsen", "B.. Skjernaa"], "venue": "Theoretical Comput. Sci. 332(1-3): 515\u2013541. Dahll\u00f6f V., Jonsson P.. 2002. An algorithm for counting maximum weighted independent sets and its applications. In 13th SODA, 292-298. Dahll\u00f6f V., Jonsson P., and Beigel R.. 2004. Algorithms for four variants of the exact satisfiability problem. Theoretical", "citeRegEx": "Byskov et al\\.,? 2005", "shortCiteRegEx": "Byskov et al\\.", "year": 2005}, {"title": "Using CSP to improve deterministic 3-SAT. arXiv:1007.1166v2", "author": ["Kutzkov K", "Scheder D"], "venue": "Comput. Sci", "citeRegEx": "K. and D..2010.,? \\Q2005\\E", "shortCiteRegEx": "K. and D..2010.", "year": 2005}, {"title": "16254n ) for exact 3-satisfiability: a simpler proof", "author": ["Hirsch E. A"], "venue": "J. Math. Sci", "citeRegEx": "0", "shortCiteRegEx": "0", "year": 2000}, {"title": "MAP complexity results and approximation methods", "author": ["Park J.D.."], "venue": "18th UAI, 388-396. Sang T., Beame P., and Kautz H.A.. 2005. Performing Bayesian inference by weighted model counting. In 20th AAAI, 475482. Porschen S.. 2005. On some weighted satisfiability and graph problems. In 31s SOFSEM, 278-287. Porschen S.. 2006. Counting all solutions of minimum weight exact satisfiability. In 6th CIAC, 50-59.", "citeRegEx": "J.D..,? 2002", "shortCiteRegEx": "J.D..", "year": 2002}, {"title": "The complexity of computing the permanent", "author": ["Valiant G.."], "venue": "Theoretical Comput. Sci. 8(2): 189\u2013201.", "citeRegEx": "G..,? 1979", "shortCiteRegEx": "G..", "year": 1979}], "referenceMentions": [{"referenceID": 2, "context": "2010) ran in O(1.439 n ), which is a meaningful advance over O(2 n ). And the 3-SAT instances with 65 variables can be solved by the algorithm in approximately 10 10 steps, instead of 10 19 (which may not be tractable). Therefore, it is significant to improve the upper bounds on the worst-case running time for problems with high computational complexity. #XSAT is one of hard problems whose computational complexity is further up the polynomial hierarchy. Valiant (1979) has proved that #XSAT is #P-complete.", "startOffset": 1, "endOffset": 473}, {"referenceID": 3, "context": "example, based on an algorithm for counting all maximum weight independent sets in a simple graph, Dahllof and Jonsson (2002) presented an upper time bound for #XSAT (O(1.", "startOffset": 23, "endOffset": 126}, {"referenceID": 2, "context": "example, based on an algorithm for counting all maximum weight independent sets in a simple graph, Dahllof and Jonsson (2002) presented an upper time bound for #XSAT (O(1.7548 n ), where n is the number of the variables). Further improved algorithm in (Porschen 2005) proposed a new upper time bound for the #XSAT (O(1.3248 n )). Instead of only outputting the number of models, Porschen in 2006 presented an algorithm solving #XSAT for enumerating all exact models of the input formula. By addressing a simple reduction, Dahllof et al. (2004) presented a #XSAT algorithm which ran in O(1.", "startOffset": 121, "endOffset": 544}, {"referenceID": 0, "context": "Next we describe how to solve the #XSAT problem using the resolution principles which inspired by (Byskov et al. 2005).", "startOffset": 98, "endOffset": 118}], "year": 2011, "abstractText": "An algorithm running in O(1.1995) is presented for counting models for exact satisfiability formulae(#XSAT). This is faster than the previously best algorithm which runs in O(1.2190). In order to improve the efficiency of the algorithm, a new principle, i.e. the common literals principle, is addressed to simplify formulae. This allows us to eliminate more common literals. In addition, we firstly inject the resolution principles into solving #XSAT problem, and therefore this further improves the efficiency of the algorithm.", "creator": "Microsoft\u00ae Office Word 2007"}}}