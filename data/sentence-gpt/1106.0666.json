{"id": "1106.0666", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Jun-2011", "title": "Experiments with Infinite-Horizon, Policy-Gradient Estimation", "abstract": "In this paper, we present algorithms that perform gradient ascent of the average reward in a partially observable Markov decision process (POMDP). These algorithms are based on GPOMDP, an algorithm introduced in a companion paper (Baxter and Bartlett, this volume), which computes biased estimates of the performance gradient in POMDPs. The algorithm's chief advantages are that it uses only one free parameter beta, which has a natural interpretation in terms of bias-variance trade-off, it requires no knowledge of the underlying state, and it can be applied to infinite state, control and observation spaces, and can not be derived from randomness, because there are not enough data. Instead of an input bias, the algorithm applies randomness to the whole random-space network. These algorithms have been used extensively in the past, particularly to evaluate whether the algorithm is an efficient implementation of Gaussian distribution (GAS).\n\n\nThe current paper proposes to implement a new algorithm with gradient descent that takes into account the fact that gradient descent is the most expensive method of gradient descent. Using gradient descent, we describe a new algorithm using a gradient descent algorithm that employs gradient descent, called gradient descent. A gradient descent algorithm is a general algorithm that can be applied to all instances of a given value in a given value. We describe a general gradient descent algorithm that uses a gradient descent algorithm that uses gradient descent (F) or, alternatively, a gradient descent algorithm that uses gradient descent (G) or gradient descent (G) as input. As we describe, we propose a new gradient descent algorithm, known as gradient descent. A gradient descent algorithm, called a gradient descent algorithm, is a general algorithm that uses gradient descent (GF) or a gradient descent (G) or gradient descent (G) as input. When the value is lower, it is used to add additional cost to the cost of the algorithm. For example, an individual can add $1,000 (X) to their cost of $1,000 or $1,000 (X) for an additional cost of $1,000 and $1,000 for the additional cost of $1,000 and $1,000 for an additional cost of $1,000 and $1,000 for a additional cost of $1,000 and $1,000 for an additional cost of $1,000 and $1,000 for an additional cost of $1,000 and $1,000 for an additional cost of $1,000 and $1,", "histories": [["v1", "Fri, 3 Jun 2011 14:52:26 GMT  (146kb)", "http://arxiv.org/abs/1106.0666v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["p l bartlett", "j baxter", "l weaver"], "accepted": false, "id": "1106.0666"}, "pdf": {"name": "1106.0666.pdf", "metadata": {"source": "CRF", "title": "Experiments with Infinite-Horizon, Policy-Gradient Estimation", "authors": ["Jonathan Baxter", "Peter L. Bartlett"], "emails": ["JBAXTER@WHIZBANG.COM", "BARTLETT@BARNHILLTECHNOLOGIES.COM", "LEX.WEAVER@ANU.EDU.AU"], "sections": [{"heading": "1. Introduction", "text": "Function approximation is necessary to avoid the curse of dimensionality associated with largescale dynamic programming and reinforcement learning problems. The dominant paradigm is to use the function to approximate the state (or state and action) values. Most algorithms then seek to minimize some form of error between the approximate value function and the true value function, usually by simulation (Sutton & Barto, 1998; Bertsekas & Tsitsiklis, 1996). While there have been a multitude of empirical successes for this approach (for example, Samuel, 1959; Tesauro, 1992, 1994; Baxter, Tridgell, & Weaver, 2000; Zhang & Dietterich, 1995; Singh & Bertsekas, 1997), there are only weak theoretical guarantees on the performance of the policy generated by the approximate value function. In particular, there is no guarantee that the policy will improve as the approximate value function is trained; in fact performance can degrade even when the function class contains an approximate value function whose corresponding greedy policy is optimal (see Baxter & Bartlett, 2001, Appendix A, for a simple two-state example).\nAn alternative technique that has received increased attention recently is the \u201cpolicy-gradient\u201d approach in which the parameters of a stochastic policy are adjusted in the direction of the gradient of some performance criterion (typically either expected discounted reward or average reward). The\nc 2001 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nkey problem is how to compute the performance gradient under conditions of partial observability when an explicit model of the system is not available.\nThis question has been addressed in a large body of previous work (Barto, Sutton, & Anderson, 1983; Williams, 1992; Glynn, 1986; Cao & Chen, 1997; Cao & Wan, 1998; Fu & Hu, 1994; Singh, Jaakkola, & Jordan, 1994, 1995; Marbach & Tsitsiklis, 1998; Marbach, 1998; Baird & Moore, 1999; Rubinstein & Melamed, 1998; Kimura, Yamamura, & Kobayashi, 1995; Kimura, Miyazaki, & Kobayashi, 1997). See the introduction of (Baxter & Bartlett, 2001) for a discussion of the history of policy-gradient approaches. Most existing algorithms rely on the existence of an identifiable recurrent state in order to make their updates to the gradient estimate, and the variance of the algorithms is governed by the recurrence time to that state. In cases where the recurrence time is too large (for instance because the state space is large), or in situations of partial observability where such a state cannot be reliably identified, we need to seek alternatives that do not require access to such a state. Motivated by these considerations, Baxter and Bartlett (2001, 2000) introduced and analysedGPOMDP\u2014an algorithm for generating a biased estimate of the gradient of the average reward in general Partially Observable Markov Decision Processes (POMDPs) controlled by parameterized stochastic policies. The chief advantages of GPOMDP are that it requires only a single sample path of the underlying Markov chain, it uses only one free parameter 2 [0; 1), which has a natural interpretation in terms of bias-variance trade-off, and it requires no knowledge of the underlying state.\nMore specifically, suppose 2 RK are the parameters controlling the POMDP. For example, could be the parameters of an approximate neural-network value-function that generates a stochastic policy by some form of randomized look-ahead, or could be the parameters of an approximate Q function used to stochastically select controls1. Let ( ) denote the average reward of the POMDP with parameter setting . GPOMDP computes an approximation r ( ) tor ( ) based on a single continuous sample path of the underlying Markov chain. The accuracy of the approximation is controlled by the parameter 2 [0; 1), and one can show thatr ( ) = lim !1r ( ): The trade-off preventing choosing arbitrarily close to 1 is that the variance of GPOMDP\u2019s estimates ofr ( ) scale as 1=(1 )2 . However, on the bright side, it can also be shown that the bias ofr ( ) (measured by kr ( ) r ( )k) is proportional to (1 ) where is a suitable mixing time of the Markov chain underlying the POMDP (Bartlett & Baxter, 2000a). Thus for \u201crapidly mixing\u201d POMDP\u2019s (for which is small), estimates of the performance gradient with acceptable bias and variance can be obtained.\nProvided r ( ) is a sufficiently accurate approximation to r ( )\u2014in fact, r ( ) need only be within 90\u00c6 of r ( )\u2014small adjustments to the parameters in the direction r ( ) will guarantee improvement in the average reward ( ). In this case, gradient-based optimization algorithms using r ( ) as their gradient estimate will be guaranteed to improve the average reward ( ) on each step. Except in the case of table-lookup, most value-function based approaches to reinforcement learning cannot make this guarantee.\nIn this paper we present a conjugate-gradient ascent algorithm that uses the estimates ofr ( ) provided by GPOMDP. Critical to the successful operation of the algorithm is a novel line search\n1. Stochastic policies are not strictly necessary in our framework, but the policy must be \u201cdifferentiable\u201d in the sense thatr ( ) exists.\nsubroutine that brackets maxima by relying solely upon gradient estimates. This largely avoids problems associated with finding the maximum using noisy value estimates. Since the parameters are only updated after accumulating sufficiently accurate estimates of the gradient direction, we refer to this approach as the \u201coff-line\u201d algorithm. This approach essentially allows us to take a stochastic gradient optimization problem and treat it as a non-stochastic optimization problem, thus enabling the use of a large body of accumulated heuristics and algorithmic improvements associated with such methods. We also present a more traditional, \u201con-line\u201d stochastic gradient ascent algorithm based on GPOMDP that updates the parameters at every time step. This algorithm is essentially the algorithm proposed in (Kimura et al., 1997).\nThe off-line and on-line algorithms are applied to a variety of problems, beginning with a simple 3-state Markov decision process (MDP) controlled by a linear function for which the true gradient can be exactly computed. We show rapid convergence of the gradient estimates r ( ) to the true gradient, in this case over a large range of values of . With this simple system we are able to illustrate vividly the bias/variance tradeoff associated with the selection of . We then compare the performance of the off-line and on-line approaches applied to finding a good policy for the MDP. The off-line algorithm reliably finds a near-optimal policy in less than 100 iterations of the Markov chain, an order of magnitude faster than the on-line approach. This can be attributed to the more aggressive exploitation of the gradient information by the off-line method.\nNext we demonstrate the effectiveness of the off-line algorithm in training a neural network controller to control a \u201cpuck\u201d in a two-dimensional world. The task in this case is to reliably navigate the puck from any starting configuration to an arbitrary target location in the minimum time, while only applying discrete forces in the x and y directions. Although the on-line algorithm was tried for this problem, convergence was considerably slower and we were not able to reliably find a good local optimum.\nIn the third experiment, we use the off-line algorithm to train a controller for the call admission queueing problem treated in (Marbach, 1998). In this case near-optimal solutions are found within about 2000 iterations of the underlying queue, 1-2 orders of magnitude faster than the experiments reported in (Marbach, 1998) with on-line (stochastic-gradient) algorithms.\nIn the fourth and final experiment, the off-line algorithm was used to reliably train a switched neural-network controller for a two-dimensional variation on the classical \u201cmountain-car\u201d task (Sutton & Barto, 1998, Example 8.2).\nThe rest of this paper is organized as follows. In Section 2 we introduce POMDPs controlled by stochastic policies, and the assumptions needed for our algorithms to apply. GPOMDP is described in Section 3. In Section 4 we describe the off-line and on-line gradient-ascent algorithms, including the gradient-based line-search subroutine. Experimental results are presented in Section 5.\n2. POMDPs Controlled by Stochastic Policies A partially observable, Markov decision process (POMDP) consists of a state space S , observation space Y and a control space U . For each state i 2 S there is a deterministic reward r(i). Although the results in Baxter and Bartlett (2001) only guarantee convergence of GPOMDP in the case of finite S (but continuous U and Y), the algorithm can be applied regardless of the nature of S so we do not restrict the cardinality of S , U or Y .\nConsider first the case of discrete S , U and Y . Each control u 2 U determines a stochastic matrix P (u) = [pij(u)\u2104 giving the transition probability from state i to state j (i; j 2 S). For each\nstate i 2 S , an observation Y 2 Y is generated independently according to a probability distribution (i) over observations in Y . We denote the probability that Y = y by y(i). A randomized policy is simply a function mapping observations into probability distributions over the controls U . That is, for each observation y 2 Y , (y) is a distribution over the controls in U . Denote the probability under of control u given observation y by u(y).\nFor continuous S;Y and U , pij(u) becomes a kernel kij(u) giving the probability density of transitions from i to j, (i) becomes a probability density function on Y with y(i) the density at y, and (y) becomes a probability density function on U with u(y) the density at u.\nTo each randomized policy there corresponds a Markov chain in which state transitions are generated by first selecting an observation Y in state i according to the distribution (i), then selecting a control U according to the distribution (Y ), and finally generating a transition to state j according to the probability pij(U).\nAt present we are only dealing with a fixed POMDP. To parameterize the POMDP we parameterize the policies, so that now becomes a function ( ; y) of a set of parameters 2 RK , as well as of the observation y. The Markov chain corresponding to has state transition matrixP ( ) = [pij( )\u2104 given by pij( ) = EY (i)EU ( ;Y )pij(U): (1) Note that the policies are purely reactive or memoryless in that their choice of action is based only upon the current observation. All the experiments described in the present paper use purely reactive policies. Aberdeen and Baxter (2001) have extended GPOMDP and the techniques of the present paper to controllers with internal state.\nThe following technical assumptions are required for the operation of GPOMDP. Assumption 1. The derivatives, u( ; y) k ; exist, and the ratios u( ; y) k u( ; y) are uniformly bounded by B <1, for all u 2 U , y 2 Y , 2 RK and k = 1; : : : ;K .\nThe second part of this assumption is needed because the ratio appears in the GPOMDP algorithm. It allows zero-probability actions u( ; y) = 0 only if r u( ; y) is also zero, in which case we set 0=0 = 0. See Section 5 for examples of policies satisfying this requirement. Assumption 2. The magnitudes of the rewards, jr(i)j, are uniformly bounded by R < 1 for all states i.\nFor deterministic rewards, his condition only represents a restriction in infinite state spaces. However, all the results in the present paper apply to bounded stochastic rewards, in which case r(i) is the expectation of the reward in state i. Assumption 3. Each P ( ); 2 RK , has a unique stationary distribution ( ) = [ 1( ; : : : ; n( )\u2104, satisfying the balance equations: ( )P ( ) = ( ):\nAssumption 3 ensures that, for all parameters , the Markov chain forms a single recurrent class. Since any finite-state Markov chain always ends up in a recurrent class, and it is the properties of this class that determine the long-term average reward, this assumption is mainly for convenience so that we do not have to include the recurrence class as a quantifier in our theorems. Observe that episodic problems, such as the minimization of time to a goal state, may be modeled in a way that satisfies Assumption 3 by simply resetting the agent upon reaching the goal state back to some initial starting distribution over states. Examples are described in Section 5.\nThe average reward ( ) is simply the expected reward under the stationary distribution ( ): ( ) = nXi=1 i( )r(i): (2) Because of Assumption 3, ( ) is also equal to the expected long-term average of the reward received when starting from any state i: ( ) = limT!1E 1T T 1Xt=0 r(Xt) X0 = i! : Here the expectation is over sequences of states X0; : : : ;XT 1 with state transitions generated byP ( ) (note that the expectation is independent of the starting state i). 3. The GPOMDP AlgorithmGPOMDP (Algorithm 1) is an algorithm for computing a biased estimate T of the gradient of the average reward r ( ). T satisfies limT!1 T = r ( ); where r ( ) ( 2 [0; 1)) is an approximation tor ( ) satisfyingr ( ) = lim !1r ( ); (Baxter & Bartlett, 2001, Theorems 2, 5). Note that GPOMDP relies only upon a single sample path from the POMDP. Also, it does not require knowledge of the transition probability matrix P , nor of the observation process ; it only requires knowledge of the randomized policy , in particular the ability to compute the gradient of the probability of the chosen control divided by the probability of the chosen control.\nWe cannot set arbitrarily close to 1 in GPOMDP, since the variance of the estimate is proportional to 1=(1 )2. However, on the bright side, it can also be shown that the bias of r ( ) (measured by kr ( ) r ( )k) is proportional to (1 ) where is a suitable mixing time of the Markov chain underlying the POMDP (Bartlett & Baxter, 2000a). Under Assumption 3, regardless of the initial starting state, the distribution over states converges to the stationary distribution ( ) when the agent is following policy ( ; ). Standard Markov chain theory shows that the rate of convergence to ( ) is exponential, and loosely speaking, the mixing time is the time constant in the exponential decay.\nAlgorithm 1 GPOMDP( ; T; )! RK 1: Given: 2 [0; 1). T > 0. Parameters 2 RK . Randomized policy ( ; ) satisfying Assumption 1. POMDP with rewards satisfying Assumption 2, and which when controlled by ( ; )\ngenerates stochastic matrices P ( ) satisfying Assumption 3. Arbitrary (unknown) starting state X0. 2: Set z0 = 0 and 0 = 0 (z0; 0 2 RK ). 3: for t = 0 to T 1 do 4: Observe Yt (generated according to the observation distribution (Xt)) 5: Generate control Ut according to ( ; Yt) 6: Observe r(Xt+1) (where the next state Xt+1 is generated according to pXtXt+1(Ut)). 7: Set zt+1 = zt + r Ut( ; Yt) Ut( ; Yt) 8: Set t+1 = t + r(Xt+1)zt+1 9: end for\n10: T T =T 11: return T\nThus has a natural interpretation in terms of a bias/variance trade-off: small values of give lower variance in the estimates T , but higher bias in that the expectation of T may be far from r ( ), whereas values of close to 1 yield small bias but correspondingly larger variance. Fortunately, for problems which mix rapidly (small ), can be small and still yield reasonable bias. This bias/variance trade-off is vividly illustrated in the experiments of Section 5; see (Bartlett & Baxter, 2000a) for a more detailed theoretical discussion of the bias/variance question."}, {"heading": "4. Stochastic Gradient Ascent Algorithms", "text": "This section introduces two approaches to exploiting the gradient estimates produced by GPOMDP: 1. an off-line approach based on traditional conjugate-gradient optimization techniques but em-\nploying a novel line-search mechanism to cope with the noise in GPOMDP\u2019s estimates, and 2. an on-line stochastic optimization approach that uses the core update in GPOMDP (r(Xt)zt)\nto update the parameters on every iteration of the POMDP.\n4.1 Off-line optimization of the average rewardGPOMDP generates biased and noisy estimates T of the gradient of the average rewardr ( ) forPOMDPs controlled by parameterized stochastic policies. A straightforward algorithm for finding local maxima of ( ) would be to compute T ( ) at the current parameter settings , and then modify by + T ( ). Provided T ( ) is close enough to the true gradient directionr ( ), and provided the step-sizes are suitably decreasing, standard stochastic optimization theory tells us that this technique will converge to a local maximum of ( ). However, given that each computation of T ( ) requires many iterations of the POMDP to guarantee suitably accurate gradient estimates (that is, in general T needs to be large), we would like to more aggressively exploit the information contained in T ( ) than by simply adjusting the parameters by a small amount in the direction T ( ).\nThere are two techniques for making better use of gradient information that are widely used in non-stochastic optimization: better choice of the search direction and better choice of step size. Better search directions can be found by employing conjugate-gradient directions rather than the pure gradient direction. Better step sizes are usually obtained by performing some kind of line-search to find a local maximum in the search direction, or through the use of second order methods. Since line-search techniques tend to be more robust to departures from quadraticity in the optimization surface, we will only consider those here (however, see Baxter & Bartlett, 2001, Section 7.3, for a discussion of how second-order derivatives may be computed with a GPOMDP-like algorithm).CONJPOMDP, described in Algorithm 2, is a version of the Polak-Ribiere conjugate-gradient algorithm (see, e.g. Fine, 1999, Section 5.5.2) that is designed to operate using only noisy (and possibly) biased estimates of the gradient of the objective function (for example, the estimates T provided by GPOMDP). The argument GRAD to CONJPOMDP computes the gradient estimate. The novel feature of CONJPOMDP is GSEARCH, a linesearch subroutine that uses only gradient information to find the local maximum in the search direction. The use of gradient information ensures GSEARCH is robust to noise in the performance estimates. Both CONJPOMDP andGSEARCH can be applied to any stochastic optimization problem for which noisy (and possibly) biased gradient estimates are available.\nThe argument s0 to CONJPOMDP provides an initial step-size for GSEARCH. The argument provides a stopping condition; when kGRAD( )k2 falls below , CONJPOMDP terminates. 4.2 TheGSEARCH algorithm The key to the successful operation of CONJPOMDP is the linesearch algorithm GSEARCH (Algorithm 3). GSEARCH uses only gradient information to bracket the maximum in the direction , and then quadratic interpolation to jump to the maximum.\nWe found the use of gradients to bracket the maximum far more robust than the use of function values. To illustrate why this is so, in Figure 1 we have plotted a stylized view of the average reward ( ) along some search direction (labeled \u201cf\u201d in the figure), and its gradient in that directionr ( ) (labeled \u201cgrad(f )\u201d). There are two ways we could search in the direction to bracket the maximum of ( ) in that direction (at 0 in this case), one using function values and the other using gradient estimates:\n1. Find three points 1; 2; 3, all lying in the direction from , such that ( 1) < ( 2) and ( 3) < ( 2). Assuming no overshooting, we then know the maximum must lie between 1\nAlgorithm 2 CONJPOMDP(GRAD; ; s0; ) 1: Given: GRAD : RK ! RK : a (possibly noisy and biased) estimate of the gradient of the objec-\ntive function to be maximized. Starting parameters 2 RK (set to maximum on return). Initial step size s0 > 0. Gradient resolution . 2: g = h = GRAD( ) 3: while kgk2 do 4: GSEARCH(GRAD; ; h; s0; ) 5: = GRAD( ) 6: = ( g) =kgk2 7: h = + h 8: if h < 0 then 9: h =\n10: end if 11: g = 12: end while\nand 3 and we can use the three points and quadratic interpolation to estimate the location of the maximum.\n2. Find two points 1 and 2 such that r ( 1) > 0 and r ( 2) < 0, and again use quadratic interpolation (which corresponds to linear interpolation of the gradients) to estimate the location of the maximum.\nBoth of these approaches will be equally satisfactory provided there is no noise in either the function estimates ( ), or the gradient estimates r ( ). However, when estimates of ( ) or r ( ) are available only through simulation, they will necessarily be noisy and the situation will look more like Figure 2. In this case the use of gradients to bracket the maximum becomes more desirable, because the line-search technique based on value estimates could choose any of the peaks in the plot of f + noise as the location of the maximum, which occur nearly uniformly along the x-axis, whereas the second technique based on gradients would choose any of the zero-crossings of the noisy gradient plot, which are far closer to the true maximum2. This is illustrated in Figure 3.\nAnother view of this phenomenon is that regardless of the variance of our estimates of ( ), the variance of sign [ ( 1) ( 2)\u2104 approaches 1 (the maximum possible) as 1 approaches 2. Thus, to reliably bracket the maximum using noisy estimates of ( ) we need to be able to reduce the variance of the estimates when 1 and 2 are close. In our case this means running the simulation\n2. There is an implicit assumption in our argument that the noise processes in the gradient and value estimates are of approximately the same magnitude. If the variance of the value estimates is considerably smaller than the variance of the gradient estimates then we would expect bracketing with values to be superior. In all our experiments we found gradient bracketing to be superior.\nfrom which the estimates are derived for longer and longer periods of time. In contrast, the variance of signr ( 1) (and signr ( 2) ) is independent of the distance between 1 and 2, and in particular does not grow as the two points approach one another.\nOne disadvantage to using gradient estimates to bracket is that it is not possible to detect extreme overshooting of the maximum. However, this can be avoided by using value estimates as a \u201csanity\ncheck\u201d to determine if the value has dropped dramatically, and suitably adjusting the search if this occurs. In Algorithm 3, lines 5\u201325 bracket the maximum by finding a parameter setting = 0 +s such that GRAD( ) > , and a second parameter setting + = 0 + s+ such thatGRAD( +) < . The reason for rather than 0 in these expressions is to provide some robustness against errors in the estimates GRAD( ). It also prevents the algorithm \u201cstepping to1\u201d if there is no local maximum in the direction . Note that we use the same as used in CONJPOMDP to determine when to terminate due to small gradient (line 4 in CONJPOMDP).\nProvided that the signs of the gradients at the bracketing points and + show that the maximum of the quadratic defined by these points lies between them, line 27 will jump to the maximum. Otherwise the algorithm simply jumps to the midpoint between and +. 4.3 On-line optimization of the average reward: OLPOMDPCONJPOMDP combined with GSEARCH operates by iteratively choosing \u201cuphill\u201d directions and then searching for a local maximum in the chosen direction. If theGRAD argument toCONJPOMDP is GPOMDP, the optimization will involve many iterations of the underlying POMDP between parameter updates.\nIn traditional stochastic optimization one typically uses algorithms that update the parameters at every iteration, rather than accumulating gradient estimates over many iterations. Algorithm 4,OLPOMDP, presents an adaptation of GPOMDP to this form. See Bartlett and Baxter (2000b) for a proof that OLPOMDP converges to the vicinity of a local maximum of ( ). Note that OLPOMDP is very similar to the algorithms proposed in Kimura et al. (1995, 1997).\nAlgorithm 3 GSEARCH(GRAD; 0; ; s0; ) 1: Given: GRAD : RK ! RK : a (possibly noisy and biased) estimate of the gradient of the objec-\ntive function. Starting parameters 0 2 RK (set to maximum on return). Search direction 2 RK with GRAD( 0) > 0. Initial step size s0 > 0. Inner product resolution >= 0. 2: s = s0 3: = 0 + s 4: = GRAD( ) 5: if < 0 then 6: Step back to bracket the maximum: 7: repeat 8: s+ = s 9: p+ =\n10: s = s=2 11: = 0 + s 12: = GRAD( ) 13: until > 14: s = s 15: p = 16: else 17: Step forward to bracket the maximum: 18: repeat 19: s = s 20: p = 21: s = 2s 22: = 0 + s 23: = GRAD( ) 24: until < 25: s+ = s 26: p+ = 27: end if 28: if p > 0 and p+ < 0 then 29: s = s p s+ s p+ p 30: else 31: s = s +s+2 32: end if 33: 0 = 0 + s\nAlgorithm 4 OLPOMDP( ; T; 0)! RK . 1: Given: 2 [0; 1). T > 0. Initial parameter values 0 2 RK . Randomized parameterized policies ( ; ) : 2 RK satisfying Assumption 1. POMDP with rewards satisfying Assumption 2, and which when controlled by ( ; )\ngenerates stochastic matrices P ( ) satisfying Assumption 3. Step sizes t; t = 0; 1; : : : satisfying P t =1 andP 2t <1. Arbitrary (unknown) starting state X0. 2: Set z0 = 0 (z0 2 RK ). 3: for t = 0 to T 1 do 4: Observe Yt (generated according to (Xt)). 5: Generate control Ut according to ( ; Yt) 6: Observe r(Xt+1) (where the next state Xt+1 is generated according to pXtXt+1(Ut). 7: Set zt+1 = zt + r Ut( ; Yt) Ut( ; Yt) 8: Set t+1 = t + tr(Xt+1)zt+1 9: end for\n10: return T"}, {"heading": "5. Experiments", "text": "In this section we present several sets of experimental results. Throughout this section, where we refer to CONJPOMDP we mean CONJPOMDP with GPOMDP as its GRAD argument.\nIn the first set of experiments, we consider a system in which a controller is used to select actions for a 3-state Markov Decision Process (MDP). For this system we are able to compute the true gradient exactly using the matrix equationr ( ) = 0( )rP ( ) I P ( ) + e 0( ) 1 r; (3) where P ( ) is the transition matrix of the underlying Markov chain with the controller\u2019s parameters set to , 0( ) is the stationary distribution corresponding to P ( ) (written as a row vector), e 0( ) is the square matrix in which each row is the stationary distribution, and r is the (column) vector of rewards (see Baxter & Bartlett, 2001, Section 3, for a derivation of (3)). Hence we can compare the estimates T generated byGPOMDPwith the true gradientr ( ), both as a function of the number of iterations T and as a function of the discount parameter . We also optimize the performance of the controller using the on-line algorithm, OLPOMDP, and the off-line algorithm CONJPOMDP.CONJPOMDP reliably converges to a near optimal policy with around 100 iterations of the MDP, while the on-line method requires approximately 1000 iterations. This should be contrasted with\ntraining a linear value-function for this system using TD(1) (Sutton, 1988), which can be shown to converge to a value function whose one-step lookahead policy is suboptimal (Weaver & Baxter, 1999).\nIn the second set of experiments, we consider a simple \u201cpuck-world\u201d problem in which a small puck must be navigated around a two-dimensional world by applying thrust in the x and y directions. We train a 1-hidden-layer neural-network controller for the puck using CONJPOMDP. Again the controller reliably converges to near optimality.\nIn the third set of experiments we use CONJPOMDP to optimize the admission thresholds for the call-admission problem considered in (Marbach, 1998).\nIn the final set of experiments we use CONJPOMDP to train a switched neural-network controller for a two-dimensional variant of the \u201cmountain-car\u201d task (Sutton & Barto, 1998, Example 8.2).\nIn all the experiments we found that convergence of the line-searches was greatly improved if all calls to the GPOMDP algorithm were seeded with the same random number sequence."}, {"heading": "5.1 A three-state MDP", "text": "In this section we consider a three-state MDP, in each state of which there is a choice of two actionsa1 and a2. Table 1 shows the transition probabilities as a function of the states and actions. Each state x has an associated two-dimensional feature vector (x) = ( 1(x); 2(x)) and reward r(x) which are detailed in Table 2. Clearly, the optimal policy is to always select the action that leads to state C with the highest probability, which from Table 1 means always selecting action a2.\nThis rather odd choice of feature vectors for the states ensures that a value function linear in those features and trained using TD(1)\u2014while observing the optimal policy\u2014will implement a suboptimal greedy one-step lookahead policy (see (Weaver & Baxter, 1999) for a proof). Thus, in\ncontrast to the gradient based approach, for this system, TD(1) training a linear value function is guaranteed to produce a worse policy if it starts out observing the optimal policy."}, {"heading": "5.1.1 TRAINING A CONTROLLER", "text": "Our goal is to learn a stochastic controller for this system that implements an optimal (or nearoptimal) policy. Given a parameter vector = ( 1; 2; 3; 4), we generate a policy as follows. For any state x, let s1(x) := 1 1(x) + 2 2(x)s2(x) := 3 1(x) + 4 2(x): Then the probability of choosing action a1 in state x is given by a1(x) = es1(x)es1(x) + es2(x) ; while the probability of choosing action a2 is given by a2(x) = es2(x)es1(x) + es2(x) = 1 a1(x): The ratios\nr ai(x) ai (x) needed by Algorithms 1 and 4 are given by,r a1(x) a1(x) = es2(x)es1(x) + es2(x) [ 1(x); 2(x); 1(x); 2(x)\u2104 (4)r a2(x) a2(x) = es1(x)es1(x) + es2(x) [ 1(x); 2(x); 1(x); 2(x)\u2104 (5) Since the second two components in r = are always the negative of the first two, this shows that two of the parameters are redundant in this case: we could just as well have set 3 = 1 and 4 = 2."}, {"heading": "5.1.2 GRADIENT ESTIMATES", "text": "With a parameter vector3 of = [1; 1; 1; 1\u2104, GPOMDP was used to generate estimates T ofr , for various values of T and 2 [0; 1). To measure the progress of T towards the true gradientr , r was calculated from (3) and then for each value of T the angle between T and r and the relative error k T r kkr k were recorded. The angles and relative errors are plotted in Figures 4, 5 and 6.\nThe graphs illustrate a typical trade-off for the GPOMDP algorithm: small values of give higher bias in the estimates, while larger values of give higher variance (the final bias is only shown in Figure 6 for the norm deviation because it was too small to measure for the angular deviation). The bias introduced by having < 1 is very small for this system. In the worst case, = 0:0, the final gradient direction is indistinguishable from the true direction while the relative deviation kr T kkr k is only 7:7%.\n3. Other initial values of the parameter vector were chosen with similar results. Note that [1; 1; 1; 1\u2104 generates a suboptimal policy.\n5.1.3 TRAINING VIA CONJUGATE-GRADIENT ASCENTCONJPOMDP with GPOMDP as the \u201cGRAD\u201d argument was used to train the parameters of the controller described in the previous section. Following the low bias observed in the experiments of the previous section, the argument of GPOMDP was set to 0. After a small amount of experimentation, the arguments s0 and of CONJPOMDP were set to 100 and 0:0001 respectively. None of these values were critical, although the extremely large initial step-size (s0) did considerably reduce the time required for the controller to converge to near-optimality. We tested the performance of CONJPOMDP for a range of values of the argument T toGPOMDP from 1 to 4096. Since GSEARCH only uses GPOMDP to determine the sign of the inner product of the gradient with the search direction, it does not need to run GPOMDP for as many iterations as CONJPOMDP does. Thus, GSEARCH determined its own T parameter to GPOMDP as follows. Initially, (somewhat arbitrarily) the value of T within GSEARCH was set to 1=10 the value used in CONJPOMDP (or 1 if the value in CONJPOMDPwas less than 10). GSEARCH then called GPOMDP to obtain an estimate T of the gradient direction. If T < 0 ( being the desired search direction) then T was doubled and GSEARCH was called again to generate a new estimate T . This procedure was repeated until T > 0, or T had been doubled four times. If T was still negative at the end of this process, GSEARCH searched for a local maximum in the direction , and the number of iterations T used by CONJPOMDP was doubled on the next iteration (the conclusion being that the direction was generated by overly noisy estimates fromGPOMDP).\nFigure 7 shows the average reward ( ) of the final controller produced by CONJPOMDP, as a function of the total number of simulation steps of the underlying Markov chain. The plots represent an average over 500 independent runs of CONJPOMDP. Note that 0:8 is the average reward of the optimal policy. The parameters of the controller were (uniformly) randomly initialized in the range[ 0:1; 0:1\u2104 before each call to CONJPOMDP. After each call to CONJPOMDP, the average reward of the resulting controller was computed exactly by calculating the stationary distribution for the controller. From Figure 7, optimality is reliably achieved using approximately 100 iterations of the Markov chain.\n5.1.4 TRAINING ON-LINE WITH OLPOMDP The controller was also trained on-line using Algorithm 4 (OLPOMDP) with fixed step-sizes t = with = 0:1; 1; 10; 100. Reducing step-sizes of the form t = =t were tried, but caused intolerably slow convergence. Figure 8 shows the performance of the controller (measured exactly as in the previous section) as a function of the total number of iterations of the Markov chain, for different values of the step-size . The graphs are averages over 100 runs, with the controller\u2019s weights randomly initialized in the range [ 0:1; 0:1\u2104 at the start of each run. From the figure, convergence to optimal is about an order of magnitude slower than that achieved by CONJPOMDP, for the best step-size of = 1:0. Step-sizes much greater that = 10:0 failed to reliably converge to an optimal policy."}, {"heading": "5.2 Puck World", "text": "In this section, experiments are described in which CONJPOMDP and OLPOMDP were used to train 1-hidden-layer neural-network controllers to navigate a small puck around a two-dimensional world."}, {"heading": "5.2.1 THE WORLD", "text": "The puck was a unit-radius, unit-mass disk constrained to move in the plane in a region 100 units square. The puck had no internal dynamics (i.e rotation). Collisions with the region\u2019s boundaries were inelastic with a (tunable) coefficient of restitution e (set to 0:9 for the experiments reported here). The puck was controlled by applying a 5 unit force in either the positive or negative x direction, and a 5 unit force in either the positive or negative y direction, giving four different controls in total. The control could be changed every 1=10 of a second, and the simulator operated at a granularity of 1=100 of a second. The puck also had a retarding force due to air resistance of0:005 speed2. There was no friction between the puck and the ground.\nThe puck was given a reward at each decision point (1=10 of a second) equal to d where d was the distance between the puck and some designated target point. To encourage the controller to learn to navigate the puck to the target independently of the starting state, the puck state was reset every 30 (simulated) seconds to a random location and random x and y velocities in the range[ 10; 10\u2104, and at the same time the target position was set to a random location.\nNote that the size of the state-space in this example is essentially infinite, being of the order of2PRECISION where PRECISION is the floating point precision of the machine (64 bits). Thus, the\ntime between visits to a recurrent state is likely to be large. Also, the puck cannot just maximize its immediate reward because this leads to significant overshooting of the target locations."}, {"heading": "5.2.2 THE CONTROLLER", "text": "A one-hidden-layer neural-network with six input nodes, eight hidden nodes and four output nodes was used to generate a probabilistic policy in a similar manner to the controller in the three-state Markov chain example of the previous section. Four of the inputs were set to the raw x and y locations and velocities of the puck at the current time-step, the other two were the differences between the puck\u2019s x and y location and the target\u2019s x and y location respectively. The location inputs were scaled to lie between 1 and 1, while the velocity inputs were scaled so that a speed of 10 units per second mapped to a value of 1. The hidden nodes computed a tanh squashing function, while the output nodes were linear. Each hidden and output node had the usual additional offset parameter. The four output nodes were exponentiated and then normalized as in the Markovchain example to produce a probability distribution over the four controls ( 5 units thrust in the x direction, 5 units thrust in the y direction). Controls were selected at random from this distribution."}, {"heading": "5.2.3 CONJUGATE GRADIENT ASCENT", "text": "We trained the neural-network controller using CONJPOMDPwith the gradient estimates generated by GPOMDP. After some experimentation we chose = 0:95 and T = 1; 000; 000 as the parameters CONJPOMDP supplied to GPOMDP. GSEARCH used the same value of and the scheme discussed in Section 5.1.3 to determine the number of iterations with which to call GPOMDP.\nDue to the saturating nature of the neural-network hidden nodes (and the exponentiated output nodes), there was a tendency for the network weights to converge to local minima at \u201cinfinity\u201d. That is, the weights would grow very rapidly early on in the simulation, but towards a suboptimal solution. Large weights tend to imply very small gradients and thus the network becomes \u201cstuck\u201d at these suboptimal solutions. We have observed a similar behaviour when training neural networks for pattern classification problems. To fix the problem, we subtracted a small quadratic penalty term k k2 from the performance estimates and hence also a small correction 2 i from the gradient calculation4 for i.\nWe used a decreasing schedule for the quadratic penalty weight (arrived at through some experimentation). was initialized to 0:5 and then on every tenth iteration of CONJPOMDP, if the performance had improved by less than 10% from the value ten iterations ago, was reduced by a factor of 10. This schedule solved nearly all the local minima problems, but at the expense of slower convergence of the controller.\nA plot of the average reward of the neural-network controller is shown in Figure 9, as a function of the number of iterations of the POMDP. The graph is an average over 100 independent runs, with the parameters initialized randomly in the range [ 0:1; 0:1\u2104 at the start of each run. The four bad runs shown in Figure 10 were omitted from the average because they gave misleadingly large error bars.\nNote that the optimal performance (within the neural-network controller class) seems to be around 8 for this problem, due to the fact that the puck and target locations are reset every 30 simulated seconds and hence there is a fixed fraction of the time that the puck must be away from\n4. When used as a technique for capacity control in pattern classification, this technique goes by the name \u201cweight decay\u201d. Here we used it to condition the optimization problem.\nthe target. From Figure 9 we see that the final performance of the puck controller is close to optimal. In only 4 of the 100 runs did CONJPOMDP get stuck in a suboptimal local minimum. Three of those cases were caused by overshooting in GSEARCH (see Figure 10), which could be prevented by adding extra checks to CONJPOMDP.\nFigure 11 illustrates the behaviour of a typical trained controller. For the purpose of the illustration, only the target location and puck velocity were randomized every 30 seconds, not the puck location."}, {"heading": "5.3 Call Admission Control", "text": "In this section we report the results of experiments in which CONJPOMDP was applied to the task of training a controller for the call admission problem treated by Marbach (1998, Chapter 7)."}, {"heading": "5.3.1 THE PROBLEM", "text": "The call admission control problem treated by Marbach (1998, Chapter 7) models the situation in which a telecommunications provider wishes to sell bandwidth on a communications link to customers in such a way as to maximize long-term average reward.\nSpecifically, the problem is a queuing problem. There are three different types of call, each with its own call arrival rate (1), (2), (3), bandwidth demand b(1), b(2), b(3) and average holding time h(1), h(2), h(3). The arrivals are Poisson distributed while the holding times are exponentially distributed. The link has a maximum bandwidth of 10 units. When a call arrives and there is sufficient available bandwidth, the service provider can choose to accept or reject the call (if there is not enough available bandwidth the call is always rejected). Upon accepting a call of\ntype m, the service provider receives a reward of r(m) units. The goal of the service provider is to maximize the long-term average reward.\nThe parameters associated with each call type are listed in Table 3. With these settings, the optimal policy (found by dynamic programming by Marbach (1998)) is to always accept calls of type 2 and 3 (assuming sufficient available bandwidth) and to accept calls of type 1 if the available\nbandwidth is at least 3. This policy has an average reward of 0:804, while the \u201calways accept\u201d policy has an average reward5 of 0:784."}, {"heading": "5.3.2 THE CONTROLLER", "text": "The controller had three parameters = ( 1; 2; 3), one for each type of call. Upon arrival of a call of type m, the controller chooses to accept the call with probability ( ) = ( 11+exp(1:5(b m)) if b+ b(m) 10,0 otherwise, where b is the currently used bandwidth. This is the class of controllers studied by Marbach (1998). 5.3.3 CONJUGATE GRADIENT ASCENTCONJPOMDP was used to train the above controller, with GPOMDP generating the gradient estimates from a range of values of and T . The influence of on the performance of the trained controllers was marginal, so we set = 0:0 which gave the lowest-variance estimates. We used the same value of T for calls to GPOMDP within CONJPOMDP and within GSEARCH, and this was varied between 10 and 10; 000. The controller was always started from the same parameter setting = (8; 8; 8) (as was done by Marbach (1998)). The value of this initial policy is 0:691. The graph of the average reward of the final controller produced by CONJPOMDP as a function of the total number of iterations of the queue is shown in Figure 12. A performance of 0:784 was reliably achieved with less than 2000 iterations of the queue.\nNote that the optimal policy is not achievable with this controller class since it is incapable of implementing any threshold policy other than the \u201calways accept\u201d and \u201calways reject\u201d policies. Although not provably optimal, a parameter setting of 1 7:5 and any suitably large values of 2 and 3 generates something close to the optimal policy within the controller class, with an average reward of 0:8. Figure 13 shows the probability of accepting a call of each type under this policy (with 2 = 3 = 15), as a function of the available bandwidth.\nThe controllers produced by CONJPOMDPwith = 0:0 and sufficiently large T are essentially \u201calways accept\u201d controllers with an average reward of 0:784, within 2% of the optimum achievable in the class. To produce policies even nearer to the optimal policy in performance, CONJPOMDP must keep 1 close to its starting value of 8, and hence the gradient estimate T = ( 1; 2; 3)\n5. There is some discrepancy between our average rewards and those quoted by Marbach (1998). This is probably due to a discrepancy in the way the state transitions are counted, which was not clear from the discussion in (Marbach, 1998).\nproduced by GPOMDP must have a relatively small first component. Figure 14 shows a plot of normalized T as a function of , for T = 1; 000; 000 (sufficiently large to ensure low variance in T ) and the starting parameter setting = (8; 8; 8). From the figure, 1 starts at a high value which explains why CONJPOMDP produces \u201calways accept\u201d controllers for = 0:0, and does not become negative until 0:93, a value for which the variance in T even for moderately large T is relatively high.\nA plot of the performance of CONJPOMDP for = 0:9 and = 0:95 is shown in Figure 15. Approximately half of the remaining 2% in performance can be obtained by setting = 0:9, while for = 0:95 a sufficiently large choice for T gives most of the remaining performance. For this problem, there is a huge difference between gaining 98% of optimal performance, which is achieved for = 0:0 and less than 2000 iterations of the queue, and gaining 99% of the optimal which requires = 0:9 and of the order of 500,000 queue iterations. A similar convergence rate and final approximation error to the latter case were reported for the on-line algorithms by Marbach (1998, Chapter 7)."}, {"heading": "5.4 Mountainous Puck World", "text": "The \u201cmountain-car\u201d task is a well-studied problem in the reinforcement learning literature (Sutton & Barto, 1998, Example 8.2). As shown in Figure 16, the task is to drive a car to the top of a onedimensional hill. The car is not powerful enough to accelerate directly up the hill against gravity, so any successful controller must learn to \u201coscillate\u201d back and forth until it builds up enough speed to crest the hill.\nIn this section we describe a variant of the mountain car problem based on the puck-world example of Section 5.2. With reference to Figure 17, in our problem the task is to navigate a puck\nout of a valley and onto a plateau at the northern end of the valley. As in the mountain-car task, the puck does not have sufficient power to accelerate directly up the hill, and so has to learn to oscillate in order to climb out of the valley. Once again we were able to reliably train near-optimal neuralnetwork controllers for this problem, using CONJPOMDP and GSEARCH, and with GPOMDP generating the gradient estimates."}, {"heading": "5.4.1 THE WORLD", "text": "The world dimensions, physics, puck dynamics and controls were identical to the flat puck world described in Section 5.2, except that the puck was subject to a constant gravitational force of 10 units, the maximum allowed thrust was 3 units (instead of 5), and the height of the world varied as\nfollows: height(x; y) = 8<:15 if y < 25 or y > 757:5 1 os ( y2 50)25 otherwise: With only 3 units of thrust, a unit mass puck can not accelerate directly out of the valley.\nEvery 120 (simulated) seconds, the puck was initialized with zero velocity at the bottom of the valley, with a random x location. The puck was given no reward while in the valley or on the southern plateau, and a reward of 100 s2 while on the northern plateau, where s was the speed of the puck. We found the speed penalty helped to improve the rate of convergence of the neural network controller."}, {"heading": "5.4.2 THE CONTROLLER", "text": "After some experimentation we found that a neural-network controller could be reliably trained to navigate to the northern plateau, or to stay on the northern plateau once there, but it was difficult to combine both in the same controller (this is not so surprising since the two tasks are quite distinct). To overcome this problem, we trained a \u201cswitched\u201d neural-network controller: the puck used one controller when in the valley and on the southern plateau, and then switched to a second neuralnetwork controller while on the northern plateau. Both controllers were one-hidden-layer neuralnetworks with nine input nodes, five hidden nodes and four output nodes. The nine inputs were the normalized ([ 1; 1\u2104-valued) x, y and z puck locations, the normalized x, y and z locations relative to center of the northern wall, and the x, y and z puck velocities. The four outputs were used to generate a policy in the same fashion as the controller of Section 5.2.2.\nAn approach requiring less prior knowledge would be to have a third controller that stochastically selects the base neural network controller as a function of the puck\u2019s location. This \u201cmaster\u201d\ncontroller could itself be parameterized and have its parameters trained along with the base controllers."}, {"heading": "5.4.3 CONJUGATE GRADIENT ASCENT", "text": "The switched neural-network controller was trained using the same scheme discussed in Section 5.2.3, except this time the discount factor was set to 0:98.\nA plot of the average reward of the neural-network controller is shown in Figure 18, as a function of the number of iterations of the POMDP. The graph is an average over 100 independent runs, with the neural-network controller parameters initialized randomly in the range [ 0:1; 0:1\u2104 at the start of each run. In this case no run failed to converge to near-optimal performance. From the figure we can see that the puck\u2019s performance is nearly optimal after about 40 million total iterations of the puck world. Although this figure may seem rather high, to put it in some perspective note that a random neural-network controller takes about 10,000 iterations to reach the northern plateau from a standing start at the base of the valley. Thus, 40 million iterations is equivalent to only about 4,000 trips to the top for a random controller.\nNote that the puck converges to a final average performance around 75, which indicates it is spending at least 75% of its time on the northern plateau. Observation of the puck\u2019s final behaviour shows it behaves nearly optimally in terms of oscillating back and forth to get out of the valley.\n5.5 Choosing and the Running Time of GPOMDP One aspect of these experiments that required some measure of tuning is the choice of the parameter and running time T used by GPOMDP. Although these were selected by trial and error, we have\nhad some success recently with a scheme for automatically choosing these parameters as follows. Before any training begins, GPOMDP is run for a large number of iterations whilst simultaneously generating gradient estimates for a number of different choices of . This can be done from a single simulation simply by maintaining a separate eligibility trace zt for each value of . Since the bias reduces with increasing , the largest that gives a reasonably low-variance gradient estimate at the end of the long run is selected as a \u201creference\u201d (the variance is estimated by comparing gradient estimates at reasonably well-separated intervals towards the end of the run). Furthermore, since the variance of the gradient estimate decreases as decreases, all gradient estimates for values of smaller than the reference will typically have smaller variance than that of the reference . Hence, we can reliably compare the directions for smaller \u2019s with the direction given by the reference , and choose the smallest whose corresponding direction is sufficiently close to the reference direction. We take\u201csufficiently close\u201d to mean within 10\u00c6\u201315\u00c6.\nNote that this scheme only works if the original run is sufficiently long to get a low-variance direction estimate at the right value of . If the right value of is too large then any fixed bound on the run length can be made to fail, but this will be a problem for all algorithms that automatically choose .\nOnce a suitable has been found, we can go back and find the point in the original long run where the direction estimate corresponding to that value of \u201csettled down\u201d (again, we measure the variance of the estimates by sampling at suitably large intervals, and choose a point where the variance falls below some chosen value). This time is then used as the running time T for GPOMDP when estimating the gradient direction. Finally, the running time used inGPOMDPwhen bracketing the maximum in GSEARCH can also be automatically tuned by starting with an initial fixed running time that is a fraction of T , and then continuing until the sign of the inner product of the estimates produced by GPOMDP with the search direction \u201csettles down\u201d. With this technique, the sign estimation time is usually considerably smaller than the gradient direction estimation time.\nAnother useful heuristic is to re-estimate and GPOMDP\u2019s running time T whenever the parameters change by a large amount, since a large change in can lead to significant changes in the mixing time of the POMDP."}, {"heading": "6. Conclusion", "text": "This paper showed how to use the performance gradient estimates generated by the GPOMDP algorithm (Baxter & Bartlett, 2001) to optimize the average reward of parameterized POMDPs. We described both a traditional \u201con-line\u201d stochastic gradient algorithm and an \u201coff-line\u201d approach that relied on the use of GSEARCH, a robust line-search algorithm that uses gradient estimates, rather than value estimates, to bracket the maximum. The off-line approach in particular was found to perform well on four quite distinct problems: optimizing a controller for a three-state MDP, optimizing a neural-network controller for navigating a puck around a two-dimensional world, optimizing a controller for a call admission problem, and optimizing a switched neural-network controller in a variation of the classical mountain-car task. One reason for the superiority of the off-line approach is that by searching for a local maximum at each step it makes much more aggressive use of the gradient information than does the on-line algorithm.\nFor the three-state MDP and the call-admission problems we were able to provide graphic illustrations of how the bias and variance of the gradient estimatesr can be traded against one another by varying between 0 (low variance, high bias) and 1 (high variance, low bias).\nRelatively little tuning was required to generate these results. In addition, the controllers operated on direct and simple representations of the state, in contrast to the more complex representations usually required of value-function based approaches.\nIt is often the case that value-function methods converge much more rapidly than their policygradient counterparts. This is due to the fact that they enforce constraints on the value-function. With this in mind an interesting avenue for further research is Actor-Critic algorithms (Barto et al., 1983; Baird & Moore, 1999; Kimura & Kobayashi, 1998; Konda & Tsitsiklis, 2000; Sutton, McAllester, Singh, & Mansour, 2000) in which one attempts to combine the fast convergence of value-functions with the theoretical guarantees of policy-gradient approaches.\nDespite the success of the off-line approach in the experiments described here, the on-line algorithm has advantages in other settings. In particular, when it is applied to multi-agent reinforcement learning, both gradient computations and parameter updates can be performed for distinct agents without any communication beyond the global distribution of the reward signal. This idea has led to a parameter optimization procedure for spiking neural networks, and some successful preliminary results with network routing (Bartlett & Baxter, 1999; Tao, Baxter, & Weaver, 2001)."}, {"heading": "Acknowledgements", "text": "This work was supported by the Australian Research Council, and benefited from the comments of several anonymous referees. Most of this research was performed while the first and second authors were with the Research School of Information Sciences and Engineering, Australian National University."}], "references": [{"title": "Policy-gradient learning of controllers with internal state", "author": ["D. Aberdeen", "J. Baxter"], "venue": null, "citeRegEx": "Aberdeen and Baxter,? \\Q2001\\E", "shortCiteRegEx": "Aberdeen and Baxter", "year": 2001}, {"title": "Gradient descent for general reinforcement learning", "author": ["L. Baird", "A. Moore"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Baird and Moore,? \\Q1999\\E", "shortCiteRegEx": "Baird and Moore", "year": 1999}, {"title": "Hebbian synaptic modifications in spiking neurons that learn", "author": ["P.L. Bartlett", "J. Baxter"], "venue": "Tech. rep., Research School of Information Sciences and Engineering,", "citeRegEx": "Bartlett and Baxter,? \\Q1999\\E", "shortCiteRegEx": "Bartlett and Baxter", "year": 1999}, {"title": "Estimation and approximation bounds for gradient-based reinforcement learning", "author": ["P.L. Bartlett", "J. Baxter"], "venue": "In Proceedings of the Thirteenth Annual Conference on Computational Learning Theory,", "citeRegEx": "Bartlett and Baxter,? \\Q2000\\E", "shortCiteRegEx": "Bartlett and Baxter", "year": 2000}, {"title": "Stochastic optimization of controlled partially observable markov decision processes", "author": ["P.L. Bartlett", "J. Baxter"], "venue": "In Proceedings of the 39th IEEE Conference on Decision and Control (CDC00)", "citeRegEx": "Bartlett and Baxter,? \\Q2000\\E", "shortCiteRegEx": "Bartlett and Baxter", "year": 2000}, {"title": "Neuronlike adaptive elements that can solve difficult learning control problems", "author": ["A.G. Barto", "R.S. Sutton", "C.W. Anderson"], "venue": "IEEE Transactions on Systems, Man, and Cybernetics,", "citeRegEx": "Barto et al\\.,? \\Q1983\\E", "shortCiteRegEx": "Barto et al\\.", "year": 1983}, {"title": "Reinforcement learning in POMDPs via direct gradient ascent", "author": ["J. Baxter", "P.L. Bartlett"], "venue": "In Proceedings of the Seventeenth International Conference on Machine Learning", "citeRegEx": "Baxter and Bartlett,? \\Q2000\\E", "shortCiteRegEx": "Baxter and Bartlett", "year": 2000}, {"title": "Infinite-horizon policy-gradient estimation", "author": ["J. Baxter", "P.L. Bartlett"], "venue": "Journal of Artificial Intelligence Research. To appear", "citeRegEx": "Baxter and Bartlett,? \\Q2001\\E", "shortCiteRegEx": "Baxter and Bartlett", "year": 2001}, {"title": "Learning to play chess using temporal-differences", "author": ["J. Baxter", "A. Tridgell", "L. Weaver"], "venue": "Machine Learning,", "citeRegEx": "Baxter et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Baxter et al\\.", "year": 2000}, {"title": "Perturbation Realization, Potentials, and Sensitivity Analysis of Markov Processes", "author": ["Cao", "X.-R", "Chen", "H.-F"], "venue": "IEEE Transactions on Automatic Control,", "citeRegEx": "Cao et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cao et al\\.", "year": 1997}, {"title": "Algorithms for Sensitivity Analysis of Markov Chains Through Potentials and Perturbation Realization", "author": ["Cao", "X.-R", "Wan", "Y.-W"], "venue": "IEEE Transactions on Control Systems Technology,", "citeRegEx": "Cao et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Cao et al\\.", "year": 1998}, {"title": "Feedforward Neural Network Methodology", "author": ["T.L. Fine"], "venue": null, "citeRegEx": "Fine,? \\Q1999\\E", "shortCiteRegEx": "Fine", "year": 1999}, {"title": "Smooth Perturbation Derivative Estimation for Markov Chains", "author": ["M.C. Fu", "J. Hu"], "venue": "Operations Research Letters,", "citeRegEx": "Fu and Hu,? \\Q1994\\E", "shortCiteRegEx": "Fu and Hu", "year": 1994}, {"title": "Stochastic approximation for monte-carlo optimization", "author": ["P.W. Glynn"], "venue": "In Proceedings of the 1986 Winter Simulation Conference,", "citeRegEx": "Glynn,? \\Q1986\\E", "shortCiteRegEx": "Glynn", "year": 1986}, {"title": "An analysis of actor/critic algorithms using eligibility traces: Reinforcement learning with imperfect value functions", "author": ["H. Kimura", "S. Kobayashi"], "venue": "In Fifteenth International Conference on Machine Learning,", "citeRegEx": "Kimura and Kobayashi,? \\Q1998\\E", "shortCiteRegEx": "Kimura and Kobayashi", "year": 1998}, {"title": "Reinforcement learning in POMDPs with function approximation", "author": ["H. Kimura", "K. Miyazaki", "S. Kobayashi"], "venue": "Proceedings of the Fourteenth International Conference on Machine Learning", "citeRegEx": "Kimura et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Kimura et al\\.", "year": 1997}, {"title": "Reinforcement learning by stochastic hill climbing on discounted reward", "author": ["H. Kimura", "M. Yamamura", "S. Kobayashi"], "venue": "In Proceedings of the Twelfth International Conference on Machine Learning", "citeRegEx": "Kimura et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Kimura et al\\.", "year": 1995}, {"title": "Actor-Critic Algorithms", "author": ["V.R. Konda", "J.N. Tsitsiklis"], "venue": "In Neural Information Processing Systems", "citeRegEx": "Konda and Tsitsiklis,? \\Q2000\\E", "shortCiteRegEx": "Konda and Tsitsiklis", "year": 2000}, {"title": "Simulation-Based Methods for Markov Decision Processes", "author": ["P. Marbach"], "venue": "Ph.D. thesis,", "citeRegEx": "Marbach,? \\Q1998\\E", "shortCiteRegEx": "Marbach", "year": 1998}, {"title": "Simulation-Based Optimization of Markov Reward Processes", "author": ["P. Marbach", "J.N. Tsitsiklis"], "venue": null, "citeRegEx": "Marbach and Tsitsiklis,? \\Q1998\\E", "shortCiteRegEx": "Marbach and Tsitsiklis", "year": 1998}, {"title": "Some Studies in Machine Learning Using the Game of Checkers", "author": ["A.L. Samuel"], "venue": "IBM Journal of Research and Development,", "citeRegEx": "Samuel,? \\Q1959\\E", "shortCiteRegEx": "Samuel", "year": 1959}, {"title": "Learning Without State-Estimation in Partially Observable Markovian Decision Processes", "author": ["S.P. Singh", "T. Jaakkola", "M.I. Jordan"], "venue": "In Proceedings of the Eleventh International Conference on Machine Learning", "citeRegEx": "Singh et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Singh et al\\.", "year": 1994}, {"title": "Reinforcement learning for dynamic channel allocation in cellular telephone systems", "author": ["S. Singh", "D. Bertsekas"], "venue": "In Advances in Neural Information Processing Systems: Proceedings of the 1996 Conference,", "citeRegEx": "Singh and Bertsekas,? \\Q1997\\E", "shortCiteRegEx": "Singh and Bertsekas", "year": 1997}, {"title": "Reinforcement learning with soft state aggregation", "author": ["S. Singh", "T. Jaakkola", "M. Jordan"], "venue": "Advances in Neural Information Processing Systems,", "citeRegEx": "Singh et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Singh et al\\.", "year": 1995}, {"title": "Learning to Predict by the Method of Temporal Differences", "author": ["R. Sutton"], "venue": "Machine Learning,", "citeRegEx": "Sutton,? \\Q1988\\E", "shortCiteRegEx": "Sutton", "year": 1988}, {"title": "Reinforcement Learning: An Introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": null, "citeRegEx": "Sutton and Barto,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto", "year": 1998}, {"title": "Policy Gradient Methods for Reinforcement Learning with Function Approximation", "author": ["R.S. Sutton", "D. McAllester", "S. Singh", "Y. Mansour"], "venue": "In Neural Information Processing Systems", "citeRegEx": "Sutton et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Sutton et al\\.", "year": 2000}, {"title": "A multi-agent, policy-gradient approach to network routing", "author": ["N. Tao", "J. Baxter", "L. Weaver"], "venue": null, "citeRegEx": "Tao et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Tao et al\\.", "year": 2001}, {"title": "Practical Issues in Temporal Difference Learning", "author": ["G. Tesauro"], "venue": "Machine Learning,", "citeRegEx": "Tesauro,? \\Q1992\\E", "shortCiteRegEx": "Tesauro", "year": 1992}, {"title": "TD-Gammon, a self-teaching backgammon program, achieves master-level play", "author": ["G. Tesauro"], "venue": "Neural Computation,", "citeRegEx": "Tesauro,? \\Q1994\\E", "shortCiteRegEx": "Tesauro", "year": 1994}, {"title": "Reinforcement learning from state and temporal differences", "author": ["L. Weaver", "J. Baxter"], "venue": null, "citeRegEx": "Weaver and Baxter,? \\Q1999\\E", "shortCiteRegEx": "Weaver and Baxter", "year": 1999}, {"title": "Simple Statistical Gradient-Following Algorithms for Connectionist Reinforcement Learning", "author": ["R.J. Williams"], "venue": "Machine Learning,", "citeRegEx": "Williams,? \\Q1992\\E", "shortCiteRegEx": "Williams", "year": 1992}, {"title": "A reinforcement learning approach to job-shop scheduling", "author": ["W. Zhang", "T. Dietterich"], "venue": "In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,", "citeRegEx": "Zhang and Dietterich,? \\Q1995\\E", "shortCiteRegEx": "Zhang and Dietterich", "year": 1995}], "referenceMentions": [{"referenceID": 6, "context": "Experimental results are presented illustrating both the theoretical results of Baxter and Bartlett (2001) on a toy problem, and practical aspects of the algorithms on a number of more realistic problems.", "startOffset": 80, "endOffset": 107}, {"referenceID": 31, "context": "This question has been addressed in a large body of previous work (Barto, Sutton, & Anderson, 1983; Williams, 1992; Glynn, 1986; Cao & Chen, 1997; Cao & Wan, 1998; Fu & Hu, 1994; Singh, Jaakkola, & Jordan, 1994, 1995; Marbach & Tsitsiklis, 1998; Marbach, 1998; Baird & Moore, 1999; Rubinstein & Melamed, 1998; Kimura, Yamamura, & Kobayashi, 1995; Kimura, Miyazaki, & Kobayashi, 1997).", "startOffset": 66, "endOffset": 383}, {"referenceID": 13, "context": "This question has been addressed in a large body of previous work (Barto, Sutton, & Anderson, 1983; Williams, 1992; Glynn, 1986; Cao & Chen, 1997; Cao & Wan, 1998; Fu & Hu, 1994; Singh, Jaakkola, & Jordan, 1994, 1995; Marbach & Tsitsiklis, 1998; Marbach, 1998; Baird & Moore, 1999; Rubinstein & Melamed, 1998; Kimura, Yamamura, & Kobayashi, 1995; Kimura, Miyazaki, & Kobayashi, 1997).", "startOffset": 66, "endOffset": 383}, {"referenceID": 18, "context": "This question has been addressed in a large body of previous work (Barto, Sutton, & Anderson, 1983; Williams, 1992; Glynn, 1986; Cao & Chen, 1997; Cao & Wan, 1998; Fu & Hu, 1994; Singh, Jaakkola, & Jordan, 1994, 1995; Marbach & Tsitsiklis, 1998; Marbach, 1998; Baird & Moore, 1999; Rubinstein & Melamed, 1998; Kimura, Yamamura, & Kobayashi, 1995; Kimura, Miyazaki, & Kobayashi, 1997).", "startOffset": 66, "endOffset": 383}, {"referenceID": 15, "context": "This algorithm is essentially the algorithm proposed in (Kimura et al., 1997).", "startOffset": 56, "endOffset": 77}, {"referenceID": 18, "context": "In the third experiment, we use the off-line algorithm to train a controller for the call admission queueing problem treated in (Marbach, 1998).", "startOffset": 128, "endOffset": 143}, {"referenceID": 18, "context": "In this case near-optimal solutions are found within about 2000 iterations of the underlying queue, 1-2 orders of magnitude faster than the experiments reported in (Marbach, 1998) with on-line (stochastic-gradient) algorithms.", "startOffset": 164, "endOffset": 179}, {"referenceID": 6, "context": "Although the results in Baxter and Bartlett (2001) only guarantee convergence of GPOMDP in the case of finite S (but continuous U and Y), the algorithm can be applied regardless of the nature of S so we do not restrict the cardinality of S , U or Y .", "startOffset": 24, "endOffset": 51}, {"referenceID": 0, "context": "Aberdeen and Baxter (2001) have extended GPOMDP and the techniques of the present paper to controllers with internal state.", "startOffset": 0, "endOffset": 27}, {"referenceID": 2, "context": "See Bartlett and Baxter (2000b) for a proof that OLPOMDP converges to the vicinity of a local maximum of ( ).", "startOffset": 4, "endOffset": 32}, {"referenceID": 24, "context": "training a linear value-function for this system using TD(1) (Sutton, 1988), which can be shown to converge to a value function whose one-step lookahead policy is suboptimal (Weaver & Baxter, 1999).", "startOffset": 61, "endOffset": 75}, {"referenceID": 18, "context": "In the third set of experiments we use CONJPOMDP to optimize the admission thresholds for the call-admission problem considered in (Marbach, 1998).", "startOffset": 131, "endOffset": 146}, {"referenceID": 18, "context": "With these settings, the optimal policy (found by dynamic programming by Marbach (1998)) is to always accept calls of type 2 and 3 (assuming sufficient available bandwidth) and to accept calls of type 1 if the available", "startOffset": 73, "endOffset": 88}, {"referenceID": 18, "context": "This is the class of controllers studied by Marbach (1998).", "startOffset": 44, "endOffset": 59}, {"referenceID": 18, "context": "This is probably due to a discrepancy in the way the state transitions are counted, which was not clear from the discussion in (Marbach, 1998).", "startOffset": 127, "endOffset": 142}, {"referenceID": 18, "context": "The controller was always started from the same parameter setting = (8; 8; 8) (as was done by Marbach (1998)).", "startOffset": 94, "endOffset": 109}, {"referenceID": 18, "context": "The controller was always started from the same parameter setting = (8; 8; 8) (as was done by Marbach (1998)). The value of this initial policy is 0:691. The graph of the average reward of the final controller produced by CONJPOMDP as a function of the total number of iterations of the queue is shown in Figure 12. A performance of 0:784 was reliably achieved with less than 2000 iterations of the queue. Note that the optimal policy is not achievable with this controller class since it is incapable of implementing any threshold policy other than the \u201calways accept\u201d and \u201calways reject\u201d policies. Although not provably optimal, a parameter setting of 1 7:5 and any suitably large values of 2 and 3 generates something close to the optimal policy within the controller class, with an average reward of 0:8. Figure 13 shows the probability of accepting a call of each type under this policy (with 2 = 3 = 15), as a function of the available bandwidth. The controllers produced by CONJPOMDPwith = 0:0 and sufficiently large T are essentially \u201calways accept\u201d controllers with an average reward of 0:784, within 2% of the optimum achievable in the class. To produce policies even nearer to the optimal policy in performance, CONJPOMDP must keep 1 close to its starting value of 8, and hence the gradient estimate T = ( 1; 2; 3) 5. There is some discrepancy between our average rewards and those quoted by Marbach (1998). This is probably due to a discrepancy in the way the state transitions are counted, which was not clear from the discussion in (Marbach, 1998).", "startOffset": 94, "endOffset": 1418}, {"referenceID": 5, "context": "With this in mind an interesting avenue for further research is Actor-Critic algorithms (Barto et al., 1983; Baird & Moore, 1999; Kimura & Kobayashi, 1998; Konda & Tsitsiklis, 2000; Sutton, McAllester, Singh, & Mansour, 2000) in which one attempts to combine the fast convergence of value-functions with the theoretical guarantees of policy-gradient approaches.", "startOffset": 88, "endOffset": 225}], "year": 2011, "abstractText": "In this paper, we present algorithms that perform gradient ascent of the average reward in a partially observable Markov decision process (POMDP). These algorithms are based on GPOMDP, an algorithm introduced in a companion paper (Baxter & Bartlett, 2001), which computes biased estimates of the performance gradient in POMDPs. The algorithm\u2019s chief advantages are that it uses only one free parameter 2 [0; 1), which has a natural interpretation in terms of bias-variance trade-off, it requires no knowledge of the underlying state, and it can be applied to infinite state, control and observation spaces. We show how the gradient estimates produced by GPOMDP can be used to perform gradient ascent, both with a traditional stochastic-gradient algorithm, and with an algorithm based on conjugate-gradients that utilizes gradient information to bracket maxima in line searches. Experimental results are presented illustrating both the theoretical results of Baxter and Bartlett (2001) on a toy problem, and practical aspects of the algorithms on a number of more realistic problems.", "creator": "dvips(k) 5.86 Copyright 1999 Radical Eye Software"}}}