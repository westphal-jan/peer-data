{"id": "1107.0030", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2011", "title": "Coherent Integration of Databases by Abductive Logic Programming", "abstract": "We introduce an abductive method for a coherent integration of independent data-sources. The idea is to compute a list of data-facts that should be inserted to the amalgamated database or retracted from it in order to restore its consistency. This method is implemented by an abductive solver, called Asystem, that applies SLDNFA-resolution on a meta-theory that relates different, possibly contradicting, input databases and other data sources (e.g., the Wikipedia or Google Docs). The SLDNFA method will be applied to all the entities that provide an explicit, complete, and correct description of a set of data sources. The SLDNFA method will also allow for a consistent search of information over the entire time period. In a more natural-space approach, the data source is a separate object to the query. When asked to do so, the SLDNFA method will then be used to perform the search on each entity that provides the information, as well as to obtain an accurate representation of its source.\n\n\n\n\nThe full scope of the data-sources section in this article is available from the following websites: https://www.pw.org/en/wiki/AUTHORIAL/AUTHORIAL\nRelated articles:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Thu, 30 Jun 2011 20:34:53 GMT  (254kb)", "http://arxiv.org/abs/1107.0030v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["o arieli", "m bruynooghe", "m denecker", "b van nuffelen"], "accepted": false, "id": "1107.0030"}, "pdf": {"name": "1107.0030.pdf", "metadata": {"source": "CRF", "title": "Coherent Integration of Databases by Abductive Logic Programming", "authors": ["Ofer Arieli", "Marc Denecker", "Bert Van Nuffelen", "Maurice Bruynooghe"], "emails": ["oarieli@mta.ac.il", "Marc.Denecker@cs.kuleuven.ac.be", "Bert.VanNuffelen@cs.kuleuven.ac.be", "Maurice.Bruynooghe@cs.kuleuven.ac.be"], "sections": [{"heading": "1. Introduction", "text": "Complex reasoning tasks often have to integrate information that is coming from different sources. One of the major challenges with this respect is to compose contradicting sources of information such that what is obtained would properly reflect the combination of the datasources on one hand1, and would still be coherent (in terms of consistency) on the other hand. There are a number of different issues involved in this process, the most important of which are the following:\n1. Unification of the different ontologies and/or database schemas, in order to get a fixed (global) schema, and a translation of the integrity constraints2 of each database to the new ontology.\n2. Unification of translated integrity constraints in a single global set of integrity constraints. This means, in particular, elimination of contradictions among the translated\n1. This property is sometimes called compositionality (Verbaeten, Denecker, & De Schreye, 1997, 2000). 2. I.e., the rules that represent intentional truths of a database domain.\nc\u00a92004 AI Access Foundation. All rights reserved.\nintegrity constraints, and inclusion of any global integrity constraint that is imposed on the integration process.\n3. Integration of databases w.r.t. the unified set of integrity constraints, computed according to the previous item.\nEach one of the issues mentioned above has its own difficulties and challenges. For instance, the first issue is considered, e.g., by Ullman (2000) and Lenzerini (2001, 2002), where questions such as how to express the relations between the \u2018global database schema\u2019 and the source (local) schemas, and how this influences query processing with respect to the global schema (Bertossi, Chomicki, Corte\u0301s, & Gutierrez, 2002), are dealt with3.\nThe second issue above is concerned with the construction of a single, classically consistent, set of integrity constraints, applied on the integrated data. In database context, it is common to assume that such a set is pre-defined, and consists of global integrity constraints that are imposed on the integration process itself (Bertossi et al., 2002; Lenzerini, 2002). In such case there is no need to derive these constraints from the local databases. When different integrity constraints are specified in different local databases, it is required to integrate not only the database instances (as specified in issue 3 above), but also the integrity constraints themselves (issue 2). The reason for separating these two topics is that integrity constraints represent truths that should be valid in all situations, while a database instance exhibits an extensional truth, i.e., an actual situation. Consequently, the policy of resolving contradictions among integrity constraints is often different than the one that is applied on database facts, and often the former is applied before the latter.\nDespite their different nature, both issues are based on some formalisms that maintain contradictions and allow to draw plausible conclusions from inconsistent situations. Roughly, there are two approaches to handle this problem:\n\u2022 Paraconsistent formalisms, in which the amalgamated data may remain inconsistent, but the set of conclusions implied by it is not explosive, i.e.: not every fact follows from an inconsistent database, and so the inference process does not become trivial in the presence of contradictions. Paraconsistent procedures for integrating data, like those of Subrahmanian (1994) and de Amo, Carnielli, and Marcos (2002), are often based on a paraconsistent reasoning systems, such as LFI (Carnielli & Marcos, 2001), annotated logics (Subrahmanian, 1990; Kifer & Lozinskii, 1992; Arenas, Bertossi, & Kifer, 2000), or other non-classical proof procedures (Priest, 1991; Arieli & Avron, 1996; Avron, 2002; Carnielli & Marcos, 2002)4.\n\u2022 Coherent (consistency-based) methods, in which the amalgamated data is revised in order to restore consistency (see, e.g., Baral, Kraus, & Minker, 1991; Baral, Kraus, Minker, & Subrahmanain, 1992; Benferhat, Dubois, & Prade, 1995; Arenas, Bertossi,\n3. For surveys on schema matching and related aspects, see also (Batini, Lenzerini, & Navathe, 1986) and (Rahm & Bernstein, 2001). 4. See also (Decker, 2003) for a historical perspective and some computational remarks on this kind of formalisms.\n& Chomicki, 1999; Arieli & Avron, 1999; Greco & Zumpano, 2000; Liberatore & Schaerf, 2000; Bertossi & Schwind, 2002; Arieli, Denecker, Van Nuffelen, & Bruynooghe, 2004). In many cases the underlying formalisms of these approaches are closely related to the theory of belief revision (Alchourro\u0301n, Ga\u0308rdenfors, & Makinson, 1995; Ga\u0308rdenfors & Rott, 1995). In the context of database systems the idea is to consider consistent databases that are \u2018as close as possible\u2019 to the original database. These \u2018repaired\u2019 instances of the \u2018spoiled\u2019 database correspond to plausible and compact ways of restoring consistency.\nIn this paper we follow the latter approach, and consider abductive approaches that handle the third issue above, namely: coherent methods for integrating different data-sources (with the same ontology) w.r.t. a consistent set of integrity constraints5. The main difficulty in this process stems from the fact that even when each local database is consistent, the collective information of all the data-sources may not remain consistent anymore. In particular, facts that are specified in a particular database may violate some integrity constraints defined elsewhere, and so this data might contradict some elements in the unified set of integrity constraints. Moreover, as noted e.g. in (Lenzerini, 2001; Cali, Calvanese, De Giacomo, & Lenzerini, 2002), the ability to handle, in a plausible way, incomplete and inconsistent data, is an inherent property of any system for data integration with integrity constrains, no matter which integration phase is considered. Providing proper ways of gaining this property is a major concern here as well.\nOur goal is therefore to find ways to properly \u2018repair\u2019 a combined (unified) database, and restore its consistency. For this, we consider a pure declarative representation of the composition of distributed data by a meta-theory, relating a number of different input databases (that may contradict each other) with a consistent output database. The underlying language of the theory is that of abductive logic programming (Kakas, Kowalski, & Toni, 1992; Denecker & Kakas, 2000). For reasoning with such theories we use an abductive system, called Asystem (Kakas, Van Nuffelen, & Denecker, 2001; Van Nuffelen & Kakas, 2001), which is an abductive solver implementing SLDNFA-resolution (Denecker & De Schreye, 1992, 1998). The composing system is implemented by abductive reasoning on the meta-theory. In the context of this work, we have extended this system with an optimizing component that allows us to compute preferred coherent ways to restore the consistency of a given database. The system that is obtained induces an operational semantics for database integration. In the sequel we also consider some model-theoretic aspects of the problem, and define a preferential semantics (Shoham, 1988) for it. According to this semantics, the repaired databases are characterized in terms of the preferred models (i.e., the most-consistent valuations) of the underlying theory. We relate these approaches by showing that the Asystem is sound and complete w.r.t. the model-based semantics. It is also noted that our framework supports reasoning with various types of special information, such as timestamps and source identification. Some implementation issues and experimen-\n5. In this sense, one may view this work as a method for restoring the consistency of a single inconsistent database. We prefer, however, to treat it as an integration process of multiple sources, since it also has some mediating capabilities, such as source identification, making priorities among different data-sources, etc. (see, e.g., Section 4.6).\ntal results are discussed as well.\nThe rest of this paper is organized as follows: in the next section we formally define our goal, namely: a coherent way to integrate different data-sources. In Section 3 we set up a semantics for this goal in terms of a corresponding model theory. Then, in Section 4 we introduce our abductive-based application for database integration. This is the main section of this paper, in which we also describe how a given integration problem can be represented in terms of meta logic programs, show how to reason with these programs by abductive computational models, present some experimental results, consider proper ways of reasoning with several types of special data, and show that our application is sound and complete with respect to the model-based semantics, considered in Section 3. Section 5 contains an overview of some related works, and in Section 6 we conclude with some further remarks, open issues, and future work6."}, {"heading": "2. Coherent Integration of Databases", "text": "We begin with a formal definition of our goal. In this paper we assume that we have a first-order language L, based on a fixed database schema S, and a fixed domain D. Every element of D has a unique name. A database instance D consists of atoms in the language L that are instances of the schema S. As such, every instance D has a finite active domain, which is a subset of D.\nDefinition 1 A database is a pair (D, IC), where D is a database instance, and IC, the set of integrity constraints, is a finite and classically consistent set of formulae in L.\nGiven a database DB = (D, IC), we apply to it the closed word assumption, so only the facts that are explicitly mentioned in D are considered true. The underlying semantics corresponds, therefore, to minimal Herbrand interpretations.\nDefinition 2 The minimal Herbrand model HD of a database instance D is the model of D that assigns true to all the ground instances of atomic formulae in D, and false to all the other atoms.\nThere are different views on a database. One view is that it is a logic theory consisting of atoms and, implicitly, the closed world assumption (CWA) that indicates that all atoms not in the database are false. Another common view of a database is that it is a structure that consists of a certain domain and corresponding relations, representing the state of the world. Whenever there is a complete knowledge and all true atoms are represented in the database, both views coincide: the unique Herbrand model of the theory is the intended structure. However, in the context of independent data-sources, the assumption that each local database represents the state of the world is obviously false. However, we can still view a local database as an incomplete theory, and so treating a database as a theory rather than as a structure is more appropriate in our case.\n6. This is a combined and extended version of (Arieli, Van Nuffelen, Denecker, & Bruynooghe, 2001) and (Arieli, Denecker, Van Nuffelen, & Bruynooghe, 2002).\nDefinition 3 A formula \u03c8 follows from a database instance D (alternatively, D entails \u03c8; notation: D |= \u03c8) if the minimal Herbrand model of D is also a model of \u03c8.\nDefinition 4 A database DB=(D, IC) is consistent if every formula in IC follows from D (notation: D |= IC).\nOur goal is to integrate n consistent local databases, DBi=(Di, ICi) (i=1, . . . n) to one consistent database that contains as much information as possible from the local databases. The idea, therefore, is to consider the union of the distributed data, and then to restore its consistency in such a way that as much information as possible will be preserved.\nNotation 1 Let DBi = (Di, ICi), i = 1, . . . n, and let I(IC1, . . . ,ICn) be a classically consistent set of integrity constraints. We denote:\nUDB = ( n \u22c3\ni=1\nDi , I(IC1, . . . ,ICn)).\nIn the notation above, I is an operator that combines the integrity constraints and eliminates contradictions (see, e.g., Alferes, Leite, Pereira, & Quaresma, 2000; Alferes, Pereira, Przymusinska, & Przymusinski, 2002). As we have already noted, how to choose this operator and how to apply it on a specific database is beyond the scope of this paper. In cases that the union of all the integrity constraints is classically consistent, it makes sense to take I as the union operator. Global consistency of the integrity constraints is indeed a common assumption in the database literature (Arenas et al., 1999; Greco & Zumpano, 2000; Greco, Greco, & Zumpano, 2001; Bertossi et al., 2002; Konieczny & Pino Pe\u0301rez, 2002; Lenzerini, 2002), but for the discussion here it is possible to take, instead of the union, any operator I for consistency restoration.\nA key notion in database integration is the following:\nDefinition 5 A repair of a database DB=(D, IC) is a pair (Insert,Retract), such that:\n1. Insert \u2229 D=\u2205,\n2. Retract \u2286 D7,\n3. (D \u222a Insert \\ Retract, IC) is a consistent database.\nIntuitively, Insert is a set of elements that should be inserted into D and Retract is a set of elements that should be removed from D in order to have a consistent database.\nAs noted above, repair of a given database is a key notion in many formalisms for data integration. In the context of database systems, this notion was first introduced by Arenas, Bertossi, and Chomicki (1999), and later considered by many others (e.g., Greco & Zumpano, 2000; Liberatore & Schaerf, 2000; Franconi, Palma, Leone, Perri, & Scarcello, 2001; Bertossi et al., 2002; Bertossi & Schwind, 2002; de Amo et al., 2002; Arenas, Bertossi, & Chomicki, 2003; Arieli et al., 2004). Earlier versions of repairs and inclusion-based consistency restoration may be traced back to Dalal (1988) and Winslett (1988).\n7. Note that by conditions (1) and (2) it follows that Insert \u2229 Retract=\u2205.\nDefinition 6 A repaired database of DB = (D, IC) is a consistent database of the form (D \u222a Insert \\ Retract , IC), where (Insert,Retract) is a repair of DB.\nAs there may be many ways to repair an inconsistent database8, it is often convenient to make preferences among the possible repairs, and consider only the most preferred ones. Below are two common preference criteria for preferring a repair (Insert,Retract) over a repair (Insert\u2032,Retract\u2032):\nDefinition 7 Let (Insert,Retract) and (Insert\u2032,Retract\u2032) be two repairs of a given database.\n\u2022 set inclusion preference criterion : (Insert\u2032,Retract\u2032) \u2264i (Insert,Retract), if Insert \u2286 Insert\u2032 and Retract \u2286 Retract\u2032.\n\u2022 minimal cardinality preference criterion: (Insert\u2032,Retract\u2032) \u2264c (Insert,Retract), if |Insert|+ |Retract| \u2264 |Insert\u2032|+ |Retract\u2032|.\nSet inclusion is also considered in (Arenas et al., 1999; Greco & Zumpano, 2000; Bertossi et al., 2002; Bertossi & Schwind, 2002; de Amo et al., 2002; Arenas et al., 2003; Arieli et al., 2004, and others), minimal cardinality is considered, e.g., in (Dalal, 1988; Liberatore & Schaerf, 2000; Arenas et al., 2003; Arieli et al., 2004).\nIn what follows we assume that the preference relation \u2264 is a fixed pre-order that represents some preference criterion on the set of repairs (and we shall omit subscript notations in it whenever possible). We shall also assume that if (\u2205, \u2205) is a valid repair, it is the \u2264-least (i.e., the \u2018best\u2019) one. This corresponds to the intuition that a database should not be repaired unless it is inconsistent.\nDefinition 8 A \u2264-preferred repair of DB is a repair (Insert,Retract) of DB, s.t. for every repair (Insert\u2032,Retract\u2032) of DB, if (Insert,Retract)\u2264(Insert\u2032,Retract\u2032) then (Insert\u2032,Retract\u2032)\u2264 (Insert,Retract). The set of all the \u2264-preferred repairs of DB is denoted by !(DB,\u2264).\nDefinition 9 A \u2264-repaired database of DB is a repaired database of DB, constructed from a \u2264-preferred repair of DB. The set of all the \u2264-repaired databases is denoted by:\nR(DB,\u2264) = { (D \u222a Insert \\ Retract , IC) | (Insert,Retract) \u2208 !(DB,\u2264) }.\nNote that if DB is consistent and \u2264 is a preference relation, then DB is the only \u2264- repaired database of itself (thus, there is nothing to repair in this case, as expected).\nNote 1 It is usual to refer to the \u2264-preferred databases of DB as the consistent databases that are \u2018as close as possible\u2019 to DB itself (see, e.g., Arenas, Bertossi, & Chomicki, 1999; Liberatore & Schaerf, 2000; de Amo, Carnielli, & Marcos, 2002; Konieczny & Pino Pe\u0301rez, 2002; Arenas, Bertossi, & Chomicki, 2003; Arieli, Denecker, Van Nuffelen, & Bruynooghe, 2004). Indeed, let\ndist(D1,D2) = (D1 \\ D2) \u222a (D2 \\ D1).\n8. Some repairs may be trivial and/or useless, though. For instance, one way to eliminate the inconsistency in (D, IC) = ({p, q, r}, {\u00acp}) is by deleting every element in D, but this is certainly not the optimal way of restoring consistency in this case.\nIt is easy to see that DB\u2032 = (D\u2032,IC) is a \u2264i-repaired database of DB = (D, IC), if the set dist(D\u2032,D) is minimal (w.r.t. set inclusion) among all the sets of the form dist(D\u2032\u2032,D), where D\u2032\u2032 |= IC. Similarly, if |S| denotes the size of S, then DB\u2032 = (D\u2032,IC) is a \u2264c-repaired database of DB = (D, IC), if |dist(D\u2032,D)| = min{|dist(D\u2032\u2032,D)| | D\u2032\u2032 |= IC}.\nGiven n databases and a preference criterion \u2264, our goal is therefore to compute the set R(UDB,\u2264) of the \u2264-repaired databases of the unified database, UDB (Notation 1). The reasoner may use different strategies to determine the consequences of this set. Among the common approaches are the skeptical (conservative) one, that it is based on a \u2018consensus\u2019 among all the elements of R(UDB,\u2264) (see Arenas et al., 1999; Greco & Zumpano, 2000), a \u2018credulous\u2019 approach, in which entailments are determined by any element in R(UDB,\u2264), an approach that is based on a \u2018majority vote\u2019 (Lin & Mendelzon, 1998; Konieczny & Pino Pe\u0301rez, 2002), etc. In cases where processing time is a major consideration, one may want to speed-up the computations by considering any repaired database. In such cases it is sufficient to find an arbitrary element in the set R(UDB,\u2264).\nBelow are some examples9 of the integration process10.\nExample 1 Consider a relation teaches of the schema (course name, teacher name), and an integrity constraint, stating that the same course cannot be taught by two different teachers:\nIC = { \u2200X\u2200Y \u2200Z (teaches(X,Y ) \u2227 teaches(X,Z) \u2192 Y = Z) }.\nConsider now the following two databases:\nDB1 = ( {teaches(c1, n1), teaches(c2, n2)}, IC ),\nDB2 = ( {teaches(c2, n3)}, IC).\nClearly, the unified database DB1\u222aDB2 is inconsistent. It has two preferred repairs, which are (\u2205, {teaches(c2, n3)}) and (\u2205, {teaches(c2, n2)}). The corresponding repaired databases are the following:\nR1 = ( {teaches(c1, n1), teaches(c2, n2)}, IC ),\nR2 = ( {teaches(c1, n1), teaches(c2, n3)}, IC ).\nThus, e.g., teaches(c1, n1) is true both in the conservative approach and the credulous approach to database integration, while the conclusion teaches(c2, n2) is supported only by credulous reasoning.\nExample 2 Consider databases with relations class and supply, of schemas (item, type) and (supplier, department, item), respectively. Let\nDB1 = ({supply(c1, d1, i1), class(i1, t1)}, IC),\nDB2 = ({supply(c2, d2, i2), class(i2, t1)}, \u2205),\nwhere IC = { \u2200X\u2200Y \u2200Z (supply(X,Y,Z)\u2227class(Z, t1) \u2192 X = c1) } states that only supplier\n9. See, e.g., (Arenas et al., 1999; Greco & Zumpano, 2000; Bertossi & Schwind, 2002) for further discussions on these examples. 10. In all the following examples we use set inclusion as the preference criterion, and take the operator I that combines integrity constraints (see Notation 1) to be the union operator.\nc1 can supply items of type t1. Again, DB1 \u222a DB2 is inconsistent, and has two preferred repairs: (\u2205, {supply(c2, d2, i2)}) and (\u2205, {class(i2, t1)}). It follows that there are two repairs of this database:\nR1 = ( {supply(c1, d1, i1), class(i1, t1), class(i2, t1)}, IC ),\nR2 = ( {supply(c1, d1, i1), supply(c2, d2, i2), class(i1, t1)}, IC ).\nExample 3 Let D1={p(a), p(b)},D2={q(a), q(c)}, and IC={\u2200X(p(X)\u2192q(X))}. Again, (D1, \u2205) \u222a (D2,IC) is inconsistent. The corresponding preferred repairs are ({q(b)}, \u2205) and (\u2205, {p(b)}). Thus, the repaired databases are the following:\nR1 = ( {p(a), p(b), q(a), q(b), q(c)}, IC ),\nR2 = ( {p(a), q(a), q(c)}, IC ). In this case, then, both the \u2018consensus approach\u2019 and the \u2018credulous approach\u2019 allow to infer, e.g., that p(a) holds, while p(b) is supported only by credulous reasoning, and p(c) is not supported by either of these approaches."}, {"heading": "3. Model-based Characterization of Repairs", "text": "In this section we set up a semantics for describing repairs and preferred repairs in terms of a corresponding model theory. This will allow us, in particular, to give an alternative description of preferred repairs, this time in terms of a preferential semantics for database theory.\nAs database semantics is usually defined in terms of two-valued (Herbrand) models (cf. Definition 2 and the discussion that proceeds it), it is natural to consider two-valued semantics first. We show that arbitrary repairs can be represented by two-valued models of the integrity constraints. When a database is inconsistent, then by definition, there is no two-valued interpretation which satisfies both its database instance and its integrity constraints. A standard way to cope with this type of inconsistencies is to move to multiplevalued semantics for reasoning with inconsistent and incomplete information (see, e.g., Subrahmanian, 1990, 1994; Messing, 1997; Arieli & Avron, 1999; Arenas, Bertossi, & Kifer, 2000; de Amo, Carnielli, & Marcos, 2002). What we will show below, is that repairs can be characterized by three-valued models of the whole database, that is, of the database instance and the integrity constraints. Finally, we concentrate on the most preferred repairs, and show that a certain subset of the three-valued models can be used for characterizing \u2264- preferred repairs.\nDefinition 10 Given a valuation \u03bd and a truth value x. Denote:\n\u03bdx = {p | p is an atomic formula, and \u03bd(p) = x}11.\nThe following two propositions characterize repairs in terms of two-valued structures.\nProposition 1 Let (D, IC) be a database and let M be a two-valued model of IC. Let Insert =M t \\ D and Retract = D \\M t. Then (Insert,Retract) is a repair of (D, IC).\n11. Note, in particular, that in terms of Definition 2, if \u03bd=HD and x= t, we have that \u03bdx = D.\nProof: The definitions of Insert and Retract immediately imply that Insert \u2229 D = \u2205 and Retract \u2286 D. For the last condition in Definition 5, note that D \u222a Insert \\ Retract = D \u222a (M t\\D)\\(D\\M t) =M t. It follows thatM is the least Herbrand model of D\u222aInsert\\Retract and it is also a model of IC, therefore D \u222a Insert \\ Retract |= IC. \u2737\nProposition 2 Let (Insert,Retract) be a repair of a database (D, IC). Then there is a two-valued model M of IC such that Insert =M t \\ D and Retract = D \\M t.\nProof: Consider a valuation M , defined for every atom p as follows:\nM(p) =\n{\nt if p \u2208 D \u222a Insert \\ Retract,\nf otherwise.\nBy its definition, M is a minimal Herbrand model of D \u222a Insert \\ Retract. Now, since (Insert,Retract) is a repair of (D, IC), we have that D \u222a Insert \\ Retract |= IC, thus M is a (two-valued) model of IC. Moreover, since (Insert,Retract) is a repair, necessarily Insert \u2229D = \u2205 and Retract \u2286 D, hence we have the following: \u2022 M t \\ D = (D \u222a Insert \\ Retract) \\ D = Insert, \u2022 D \\M t = D \\ (D \u222a Insert \\ Retract) = Retract. \u2737\nWhen a database is inconsistent, it has no models that satisfy both its integrity constraints and its database instance. One common method to overcome such an inconsistency is to introduce additional truth-values that intuitively represent partial knowledge, different amounts of beliefs, etc. (see, e.g., Priest, 1989, 1991; Subrahmanian, 1990; Fitting, 1991; Arieli, 1999; Arenas et al., 2000; Avron, 2002). Here we follow this guideline, and consider database integration in the context of a three-valued semantics. The benefit of this is that, as we show below, any database has some three-valued models, from which it is possible to pinpoint the inconsistent information, and accordingly construct repairs.\nThe underlying three-valued semantics considered here is induced by the algebraic structure T HREE , shown in the double-Hasse diagram of Figure 112.\nIntuitively, the elements t and f in T HREE correspond to the usual classical values true and false, while the third element, \u22a4, represents inconsistent information (or belief).\n12. This structure is used for reasoning with inconsistency by several other three-valued formalisms, such as LFI (Carnielli & Marcos, 2001, 2002) and LP (Priest, 1989, 1991).\nViewed horizontally, T HREE is a complete lattice. According to this view, f is the minimal element, t is the maximal one, and \u22a4 is an intermediate element. The corresponding order relation, \u2264t, intuitively represents differences in the amount of truth that each element exhibits. We denote the meet, join, and the order reversing operation on \u2264t by \u2227, \u2228, and \u00ac (respectively). Viewed vertically, T HREE is a semi-upper lattice. In this view, \u22a4 is the maximal element and the two \u2018classical values\u2019 are incomparable. This partial order, denoted by \u2264k, may be intuitively understood as representing differences in the amount of knowledge (or information) that each element represents13. We denote by \u2295 the join operation on \u2264k 14.\nVarious semantic notions can be defined on T HREE as natural generalizations of similar classical ones: a valuation \u03bd is a function that assigns a truth value in T HREE to each atomic formula. Given a valuation \u03bd, truth values xi \u2208 {t, f,\u22a4}, and atomic formulae pi, we shall sometimes write \u03bd = {pi :xi} instead of \u03bd(pi) = xi (i=1, 2 . . .). Any valuation is extended to complex formulae in the obvious way. For instance, \u03bd(\u00ac\u03c8) = \u00ac\u03bd(\u03c8), \u03bd(\u03c8\u2227\u03c6) = \u03bd(\u03c8) \u2227 \u03bd(\u03c8), and so forth15. The set of the designated truth values in T HREE (i.e., those elements in T HREE that represent true assertions) consists of t and \u22a4. A valuation \u03bd satisfies a formula \u03c8 iff \u03bd(\u03c8) is designated. A valuation that assigns a designated value to every formula in a theory T is a (three-valued) model of T .\nLemma 1 Let \u03bd and \u00b5 be three-valued valuations s.t. for every atom p, \u03bd(p)\u2265k\u00b5(p). Then for every formula \u03c8, \u03bd(\u03c8)\u2265k\u00b5(\u03c8).\nProof: By induction on the structure of \u03c8. \u2737\nWe shall write \u03bd\u2265k\u00b5, if \u03bd and \u00b5 are three-valued valuations, for which the condition of Lemma 1 holds.\nLemma 2 If \u03bd\u2265k\u00b5 and \u00b5 is a model of some theory T , then \u03bd is also a model of T .\nProof: For every formula \u03c8 \u2208 T , \u00b5(\u03c8) is designated. Hence, by Lemma 1, for every formula \u03c8 \u2208 T \u03bd(\u03c8) is also designated, and so \u03bd is a model of T . \u2737\nNext we characterize the repairs of a database DB by its three-valued models:\nProposition 3 Let (D, IC) be a database and letM be a two-valued model of IC. Consider the three-valued valuation N , defined for every atom p by N(p) =HD(p) \u2295M(p), and let Insert = N\u22a4 \\ D, Retract = N\u22a4 \u2229 D. Then:\n1. N is a three-valued model of D \u222a IC, and\n13. See (Belnap, 1977; Ginsberg, 1988; Fitting, 1991) for a more detailed discussion on these orders and their intuitive meaning. 14. We follow here the notations of Fitting (1990, 1991). 15. As usual, we use here the same logical symbol to denote the connective that appear on the left-hand\nside of an equation, and the corresponding operator on T HREE that appear on the right-hand side of the same equation.\n2. (Insert,Retract) is a repair of (D, IC).\nProposition 3 shows that repairs of a database (D, IC) may be constructed in a standard (uniform) way by considering three-valued models that are the \u2264k-least upper bounds of two two-valued valuations: the minimal Herbrand model of the database instance, and a two-valued model of the integrity constraints. Proposition 4 below shows that any repair of (D, IC) is of this form.\nBefore we give a proof for Proposition 3, let\u2019s demonstrate it by a simple example.\nExample 4 Let DB = ({p, r} , {p\u2192 q}). Then HD = {p :t, q :f, r :t}, and the two-valued models of IC = {p \u2192 q} are {p :t, q :t, r :t}, {p :t, q :t, r :f}, {p :f, q :t, r :t}, {p :f, q :t, r :f}, {p :f, q :f, r :t}, and {p :f, q :f, r :f}. Thus, the (three-valued) models of the form HD\u2295M , whereM is a two-valued model of IC, are {p :t, q :\u22a4, r :t}, {p :t, q :\u22a4, r :\u22a4}, {p :\u22a4, q :\u22a4, r :t}, {p :\u22a4, q :\u22a4, r :\u22a4}, {p :\u22a4, q : f, r : t} and {p :\u22a4, q : f, r :\u22a4}. By Proposition 3, the pairs ({q}, {}), ({q}, {r}), ({q}, {p}), ({q}, {p, r}), ({}, {p}), and ({}, {p, r}), are repairs of DB.\nProof of Proposition 3: Since by the definition of N , N \u2265k H D, and since HD is a model of D, Lemma 2 implies that N is a model D. Similarly, N \u2265kM , and M is a model of IC, thus by the same lemma N is also a model of IC.\nFor the second part, we observe that Insert = N\u22a4 \\D =M t \\D and Retract = N\u22a4\u2229D = Mf \u2229 D = D \\M t. Now, M is a two-valued model of IC and hence, by Proposition 1, (Insert,Retract) is a repair of (D, IC). \u2737\nNote that the specific form of the three-valued valuations considered in Proposition 3 is essential here, as the proposition does not hold for every three-valued model of D \u222a IC. To see this consider, e.g., D = {}, IC = {p , p\u2192 q}, and a three valued valuation N that assigns \u22a4 to p and t to q. Clearly, N is a model of D \u222a IC, but the corresponding update, (N\u22a4 \\D , N\u22a4 \u2229D) = ({p}, {}) is not a repair of (D, IC), since ({p},IC) is not a consistent database.\nAgain, as we have noted above, it is possible to show that the converse of Proposition 3 is also true:\nProposition 4 Let (Insert,Retract) be a repair of a database (D, IC). Then there is a three-valued model N of D \u222a IC, such that Insert = N\u22a4 \\ D and Retract = N\u22a4 \u2229 D.\nProof: Consider a valuation N , defined for every atom p as follows:\nN(p) =\n  \n \n\u22a4 if p\u2208 Insert \u222a Retract,\nt if p 6\u2208 Insert \u222a Retract but p\u2208D,\nf otherwise.\nBy the definition ofN and since (Insert,Retract) is a repair of (D, IC), we have thatN\u22a4\\D = (Insert \u222a Retract) \\ D = Insert and N\u22a4 \u2229 D = (Insert \u222a Retract) \u2229 D = Retract.\nIt remains to show that N is a (three-valued) model of D and IC. It is a three-valued model of D because for every p \u2208 D, N(p) \u2208 {t,\u22a4}. Regarding IC, (Insert,Retract) is a\nrepair of (D, IC), thus every formula in IC is true in the least Herbrand model M of D\u2032 = D \u222a Insert \\ Retract. In particular, M(q) = t for every q \u2208 D\u2032. But since for every p\u2208D\u222aInsert we have thatN(p)\u2208{t,\u22a4} and D\u2032 \u2286 D\u222aInsert, necessarily \u2200q\u2208D\u2032 N(q)\u2208{t,\u22a4}. It follows that for every q\u2208D\u2032, N(q)\u2265kM(q) = t, thus by Lemma 1 and Lemma 2, N must also be a (three-valued) model of D\u2032. Hence N is a model of IC. \u2737\nThe last two propositions characterize the repairs of UDB in terms of pairs that are associated with certain three-valued models of D \u222a IC. We shall denote the elements of these pairs as follows:\nNotation 2 Let N be a three-valued model and let DB = (D, IC) be a database. Denote: Insert N = N\u22a4 \\ D and RetractN = N\u22a4 \u2229 D.\nWe conclude this model-based analysis by characterizing the set of the \u2264-preferred repairs, where \u2264 is one of the preference criteria considered in Definition 7 (i.e., set inclusion or minimal cardinality). As the propositions below show, common considerations on how inconsistent databases can be \u2018properly\u2019 recovered (e.g., keeping the amount of changes as minimal as possible, being \u2018as close as possible\u2019 to the original instance, etc.) can be captured by preferential models in the context of preferential semantics (Shoham, 1988). The idea is to define some order relation on the set of the (three-valued) models of the database. This relation intuitively captures some criterion for making preferences among the relevant models. Then, only the \u2018most preferred\u2019 models (those that are minimal with respect to the underlying order relation) are considered in order to determine how the database should be repaired. Below we formalize this idea:\nDefinition 11 Given a database DB = (D, IC), denote:\nMDB = {N | N \u2265k H D \u2295M for some classical model M of IC}16.\nExample 5 Consider again the database DB = ({p, r} , {p \u2192 q}) of Example 4. As we have shown, there are six valuations of the form HD \u2295M , for some two-valued model M of IC, namely:\n{p :t , q :\u22a4, r :t}, {p :t , q :\u22a4, r :\u22a4}, {p :\u22a4, q :\u22a4, r :t},\n{p :\u22a4, q :\u22a4, r :\u22a4}, {p :\u22a4, q :f, r :t}, {p :\u22a4, q :f, r :\u22a4}.\nThe k-minimal models among these models are {p :t, q :\u22a4, r :t} and {p :\u22a4, q :f, r :t}, thus MDB = {N | N(p) \u2265k t, N(q) = \u22a4, N(r) \u2265k t} \u222a {N | N(p) = \u22a4, N(q) \u2265k f, N(r) \u2265k t}.\nPreference orders should reflect some normality considerations applied on the relevant set of valuations (MDB, in our case); \u03bd is preferable than \u00b5, if \u03bd describes a situation that is more common (plausible) than the one described by \u00b5. Hence, a natural way to define preferences in our case is by minimizing inconsistencies. We thus get the following definition:\nDefinition 12 Let S be a set of three-valued valuations, and N1, N2\u2208S.\n16. Note that N is a three-valued valuation and M is a two-valued model of IC.\n\u2022 N1 is \u2264i-more consistent than N2, if N \u22a4 1 \u2282 N \u22a4 2 .\n\u2022 N1 is \u2264c-more consistent than N2, if |N \u22a4 1 | < |N \u22a4 2 |.\n\u2022 N \u2208S is \u2264i-maximally consistent in S (respectively, N is \u2264c-maximally consistent in S), if there is no N \u2032\u2208S that is \u2264i-more consistent than N (respectively, no N\n\u2032\u2208S is \u2264c-more consistent than N).\nThe following propositions show that there is a close relationship between most consistent models of MDB and the preferred repairs of DB.\nProposition 5 If N is a \u2264i-maximally consistent element inM DB, then (InsertN , RetractN ) is a \u2264i-preferred repair of DB.\nProof: By Proposition 3, (InsertN , RetractN ) is a repair of DB. If it is not a \u2264i-preferred repair of DB, then there is a repair (Insert, Retract) s.t. Insert \u2286 InsertN , Retract \u2286 RetractN , and Insert\u222aRetract \u2282 InsertN \u222aRetractN . By Proposition 4 and its proof, there is an element N \u2032\u2208MDB s.t. Insert = InsertN \u2032 , Retract = RetractN \u2032 , and (N \u2032)\u22a4 = InsertN \u2032 \u222a RetractN \u2032\n. It follows, then, that (N \u2032)\u22a4 \u2282 N\u22a4, and so N is not a maximally consistent in MDB, but this is a contradiction to the definition of N . \u2737\nProposition 6 Suppose that (Insert, Retract) is a \u2264i-preferred repair of DB. Then there is a \u2264i-maximally consistent element N in M DB s.t. Insert = InsertN and Retract = RetractN .\nProof: The pair (Insert, Retract) is in particular a repair of DB, thus by Proposition 2 there is a classical model M of IC such that Insert =M t \\D and Retract = D \\M t. Consider the following valuation:\nN(p) =\n{\n\u22a4 if p\u2208M t \\ D or p\u2208D \\M t\nM(p) otherwise.\nFirst we show that N = HD \u2295M . This is so since if M(p) = HD(p), then since HD is a minimal Herbrand model of D, necessarily p 6\u2208M t \\ D and p 6\u2208D \\M t, thus N(p)=M(p)= M(p) \u2295M(p) = M(p) \u2295 HD(p). Otherwise, if M(p) 6= HD(p), then either M(p) = t and HD(p) = f , i.e., p \u2208M t \\ D, or M(p) = f and HD(p) = t, i.e., p \u2208D \\M t. In both cases, N(p)=\u22a4=M(p)\u2295HD(p)17. Thus N = HD \u2295M , and so N \u2208MDB. Now, by Proposition 2 again, and by the definition of N , InsertN = N\u22a4 \\D = [(M t \\D)\u222a (D\\M t)]\\D =M t \\D = Insert, and RetractN = N\u22a4 \u2229 D = [(M t \\ D) \u222a (D \\M t)] \u2229D = D \\M t = Retract.\nIt remains to show that N is \u2264i-maximally consistent in M DB. Suppose not. Then there\nis an N \u2032\u2208MDB s.t. (N \u2032)\u22a4 \u2282 N\u22a4 = Insert\u222aRetract. By Proposition 3, (InsertN \u2032 , RetractN \u2032\n) is also a repair of DB. Moreover, \u2022 InsertN \u2032\n=(N \u2032)\u22a4 \\ D\u2286N\u22a4 \\ D= InsertN = Insert, \u2022 RetractN \u2032\n=(N \u2032)\u22a4 \u2229 D\u2286N\u22a4 \u2229 D=RetractN =Retract, \u2022 InsertN \u2032 \u222a RetractN \u2032\n=(N \u2032)\u22a4\u2282N\u22a4= InsertN \u222a RetractN = Insert \u222a Retract. Hence (InsertN \u2032 , RetractN \u2032\n) <i (Insert, Retract), and so (Insert, Retract) is not a \u2264i-preferred repair of (D, IC), a contradiction. \u2737\nPropositions 5 and 6 may be formulated in terms of \u2264c as follows:\n17. Here we use the fact that t\u2295 f=\u22a4.\nProposition 7 If N is a \u2264c-maximally consistent element in M DB, then (InsertN , RetractN ) is a \u2264c-preferred repair of DB.\nProposition 8 Suppose that (Insert, Retract) is a \u2264c-preferred repair of DB. Then there is a \u2264c-maximally consistent element N in M DB s.t. Insert = InsertN and Retract = RetractN .\nThe proofs of the last two propositions are similar to those of Propositions 5 and 6, respectively.\nExample 6 Consider again Example 3. We have that:\nUDB = (D, IC) = ( {p(a), p(b), q(a), q(c)}, {\u2200X(p(X)\u2192q(X))} ).\nThus, HD = {p(a) : t, p(b) : t, p(c) : f, q(a) : t, q(b) : f, q(c) : t}, and the classical models of IC are those in which either p(y) is false or q(y) is true for every y\u2208{a, b, c}. Now, since in HD neither p(b) is false nor q(b) is true, it follows that every element in MUDB must assign \u22a4 either to p(b) or to q(b). Hence, the \u2264i-maximally consistent elements in M\nUDB (which in this case are also the \u2264c-maximally consistent elements in M UDB) are the following:\nM1 = { p(a) :t, p(b) :\u22a4, p(c) :f, q(a) :t, q(b) :f, q(c) :t },\nM2 = { p(a) :t, p(b) :t, p(c) :f, q(a) :t, q(b) :\u22a4, q(c) :t }.\nBy Propositions 5 and 6, then, the \u2264i-preferred repairs of UDB (which are also its \u2264cpreferred repairs) are (InsertM1 , RetractM1) = (\u2205, {p(b)}) and (InsertM2, RetractM2) = ({q(b)}, \u2205) (cf. Example 3).\nExample 7 In Examples 4 and 5, the \u2264i-maximally consistent elements (and the \u2264cmaximally consistent elements) ofMDB areN1 = {p :t, q :\u22a4, r :t} andN2 = {p :\u22a4, q :f, r :t}. It follows that the preferred repairs in this case are ({q}, \u2205) and (\u2205, {p}).\nTo summarize, in this section we have considered a model-based, three-valued preferential semantics for database integration. We have shown (Propositions 5 \u2013 8) that common and natural criteria for making preferences among possible repairs (i.e., set inclusion and minimal cardinality) can be expressed by order relations on three-valued models of the database. The two ways of making preferences (among repairs on one hand and among three-valued models on the other hand) are thus strongly related, and induce two alternative approaches for database integration. In the next section we shall consider a third approach to the same problem (aimed to provide an operational semantics for database integration) and relate it to the model-based semantics, discussed above."}, {"heading": "4. Computing Repairs through Abduction", "text": "In this section we introduce an abductive system that consistently integrates possibly contradicting data-sources. This system computes, for a set of data-sources and a preference criterion \u2264, the corresponding \u2264-repaired databases18. Our framework is composed of an abductive logic program (Denecker & Kakas, 2000) and an abductive solver Asystem (Kakas, Van Nuffelen, & Denecker, 2001; Van Nuffelen & Kakas, 2001) that is based on the\n18. It is important to note already in this stage that for computing the \u2264-repaired databases it won\u2019t be necessary to produce all the repaired databases.\nabductive refutation procedure SLDNFA (Denecker & De Schreye, 1992, 1998). In the first three parts of this section we describe these components: in Section 4.1 we give a general description of abductive reasoning, in Section 4.2 we show how it can be applied to encode database repairs, and in Section 4.3 we describe the \u2018computational platform\u2019. Then, in Section 4.4 we demonstrate the computation process by a comprehensive example, and in Section 4.5 we specify soundness and completeness results of our approach (with respect to the basic definitions of Section 2 and the model-based semantics of Section 3). Finally, in Section 4.6 we consider some ways of representing special types of data in the system."}, {"heading": "4.1 Abductive Logic Programming", "text": "We start with a general description of abductive reasoning in the context of logic programming. As usual in logic programming, the language contains constants, functions, and predicate symbols. A term is either a variable, a constant, or a compound term f(t1, . . . , tn), where f is an n-ary function symbol and ti are terms. An atom is an expression of the form p(t1, . . . , tm), where p is an m-ary predicate symbol and ti (i=1,. . .,m) are terms. A literal is an atom or a negated atom. A denial is an expression of the form \u2200X(\u2190 F ), where F is a conjunction of literals and X is a subset of the variables in F . The free variables in F (those that are not in X) can be considered as place holders for objects of unspecified identity (Skolem constants). Intuitively, the body F of a denial \u2200X(\u2190 F ) represents an invalid situation.\nDefinition 13 (Kakas et al., 1992; Denecker & Kakas, 2000) An abductive logic theory is a triple T = (P , A , IC), where:\n\u2022 P is a logic program, consisting of clauses of the form h \u2190 l1 \u2227 . . . \u2227 ln, where h is an atomic formula and li (i = 1, . . . , n) are literals. These clauses are interpreted as definitions for the predicates in their heads,\n\u2022 A is a set of abducible predicates, i.e., predicates that do not appear in the head of any clause in P,\n\u2022 IC is a set of first-order formulae, called integrity constraints.\nAll the main model semantics of logic programming can be extended to abductive logic programming. This includes two-valued completion (Console, Theseider Dupre, & Torasso, 1991) and three-valued completion semantics (Denecker & De Schreye, 1993), extended well-founded semantics (Pereira, Aparicio, & Alferes, 1991), and generalized stable semantics (Kakas & Mancarella, 1990b). These semantics can be defined in terms of arbitrary interpretations (Denecker & De Schreye, 1993), but generally they are based on Herbrand interpretations. The effect of this restriction on the semantics of the abductive theory is that a domain closure condition is imposed: the domain of interpretation is known to be the Herbrand universe. A model of an abductive theory under any of these semantics is a Herbrand interpretation H, for which there exists a collection of ground abducible facts \u2206, such that H is a model of the logic program P \u222a\u2206 (with respect to the corresponding semantics of logic programming) and H classically satisfies any element in IC.\nSimilarly, for any of the main semantics S of logic programming, one can define the notion of an abductive solution for a query and an abductive theory.\nDefinition 14 (Kakas et al., 1992; Denecker & Kakas, 2000) An (abductive) solution for a theory (P , A , IC) and a query Q is a set \u2206 of ground abducible atoms, each one having a predicate symbol in A, together with an answer substitution \u03b8, such that the following three conditions are satisfied:\na) P \u222a\u2206 is consistent in the semantics S,\nb) P \u222a\u2206 |=S IC,\nc) P \u222a\u2206 |=S \u2200Q\u03b8.\nIn the next section we will use an abductive theory with a non-recursive program to model the database repairs. The next proposition shows that for such abductive theories all Herbrand semantics coincide, and models correspond to abductive solutions for the query true.\nProposition 9 Let T = (P , A , IC) be an abductive theory, such that P is a non-recursive program. Then H is a Herbrand model of the three-valued completion semantics, iff H is a Herbrand model of the two-valued completion semantics, iff H is a generalized stable model of T , iff H is a generalized well-founded model of T .\nIf H is a model of T , then the set \u2206 of abducible atoms in H is an abductive solution for the query true. Conversely, for every abductive solution for true, there exists a unique model H of T , such that \u2206 is the set of true abducible atoms in H.\nProof: The proof is based on the well-known fact that for non-recursive logic programs, all the main semantics of logic programming coincide. In particular, for a non-recursive logic program P there is a Herbrand interpretation H, which is the unique model under each semantics (see, for example, Denecker & De Schreye, 1993).\nLet H be a model of T = (P , A , IC) under any of the four semantics mentioned above. Then there exists a collection of ground abducible facts \u2206, such that H is a model of the logic program P \u222a\u2206 under the corresponding semantics of logic programming. Since P is non-recursive, so is P \u222a\u2206. By the above observation, H is the unique model of P \u222a\u2206 under any of the above mentioned semantics. Hence, H is a model of T under any of the other semantics. This proves the first part of the proposition.\nWhen H is a Herbrand model of T , there is a set \u2206 of abducible atoms such that H is a model of P \u222a\u2206. Clearly, \u2206 must be the set of true abducible atoms in H. Then P \u222a\u2206 is obviously consistent, and it entails the integrity constraints of T , which entails true. Hence, \u2206 is an abductive solution for true. Conversely, for any set \u2206 of abducible atoms, P \u222a\u2206 has a unique model H and the set of true abducible atoms in H is \u2206. When \u2206 is an abductive solution for true, H satisfies the integrity constraints, and hence H is a model of T . Consequently, H is the unique model of T , and its set of true abducible atoms is \u2206. \u2737\nIn addition to the standard properties of abductive solutions for a theory T and a query Q, specified in Definition 14, one frequently imposes optimization conditions on the solutions\n\u2206, analogous to those found in the context of database repairs. Two frequently used criteria are that the generated abductive solution \u2206 should be minimal with respect to set inclusion or with respect to set cardinality (cf. Definition 7). The fact that the same preference criteria are used for choosing appropriate abductive solutions and for selecting preferred database repairs does not necessarily mean that there is a natural mapping between the corresponding solutions. In the next sections we will show, however, that meta-programming allows us to map a database repair problem into an abductive problem (w.r.t. the same type of preference criterion)."}, {"heading": "4.2 An Abductive Meta-Program for Encoding Database Repairs", "text": "The task of repairing the union of n given databases DBi with respect to the integration of the local integrity constraints IC, can be represented by an abductive theory T = (P , A , IC\u2032), where P is a meta-program encoding how a new database is obtained by updating the existing databases, A is the set {insert, retract} of abducible predicates used to describe updates, and IC\u2032 encodes the integrity constraints. In P, facts p that appear in at least one of the databases are encoded by atomic rules db(p), and facts p that appear in the updated database are represented by atoms fact(p). The latter predicate is defined as follows:\nfact(X) \u2190 db(X) \u2227 \u00acretract(X) fact(X) \u2190 insert(X)\nTo assure that the predicates insert and retract encode a proper update of the database, the following integrity constraints are also specified:\n\u2022 An inserted element should not belong to a given database: \u2190 insert(X) \u2227 db(X)\n\u2022 A retracted element should belong to some database: \u2190 retract(X) \u2227 \u00acdb(X)\nThe set of integrity constraints IC\u2032 is obtained by a straightforward transformation from IC: every occurrence of a database fact p in some integrity constraint is replaced by fact(p)19.\nExample 8 (Example 1, revisited) Figure 2 contains the meta-program encoding Example 1 (the codes for Examples 2 and 3 are similar).\nAs noted in Section 4.1, under any of the main semantics of abductive logic programing there is a one to one correspondence between repairs of the composed database DB and the Herbrand models of its encoding, the abductive meta theory T . Consequently, abduction can be used to compute repairs. In the following sections we introduce an abductive method for this purpose.\n19. Since our abductive system (see Section 4.3) will accept integrity constraints in a denial form, in case that the elements of IC\u2032 are not in this form, the Lloyd-Topor transformation (Lloyd & Topor, 1984) may also be applied here; we consider this case in Section 4.3.2.\n4.3 The Abductive Computational Model (The Asystem)\nBelow we describe the abductive system that will be used to compute database repairs. The Asystem (Kakas, Van Nuffelen, & Denecker, 2001; Van Nuffelen & Kakas, 2001) is a tool combining abductive logic theories and constraint logic programming (CLP). It is a synthesis of the refutation procedures SLDNFA (Denecker & De Schreye, 1998) and ACLP (Kakas et al., 2000), together with an improved control strategy. The essence of the Asystem is a reduction of a high level specification to a lower level constraint store, which is managed by a constraint solver. See http://www.cs.kuleuven.ac.be/\u223cdtai/kt/ for the latest version of the system20. Below we review the theoretical background as well as some practical considerations behind this system. For more information, see (Denecker & De Schreye, 1998) and (Kakas, Van Nuffelen, & Denecker, 2001)."}, {"heading": "4.3.1 Abductive Inference", "text": "The input to the Asystem is an abductive theory T = (P, A, IC), where IC consists of universally quantified denials. The process of answering a query Q, given by a conjunction of literals, can be described as a derivation for Q through rewriting states. A state is a pair (G , ST ), where G, the set of goal formulae, is a set of conjunctions of literals and denials. During the rewriting process the elements in G (the goals) are reduced to basic formulae\n20. This version runs on top of Sicstus Prolog 3.10.1 or later versions.\nthat are stored in the structure ST . This structure is called a store, and it consists of the following elements21:\n\u2022 a set \u2206 that contains abducibles a(t).\n\u2022 a set \u2206\u2217 that contains denials of the form \u2200X(\u2190 a(t)\u2227Q), where a(t) is an abducible. Such a denial may contain free variables.\n\u2022 a set E of equalities and inequalities over terms.\nThe consistency of E is maintained by a constraint solver that uses the Martelli and Montanari unification algorithm (Martelli & Montanari, 1982) for the equalities and constructive negation for the inequalities.\nA state S = (G , ST ) is called consistent if G does not contain false and ST is consistent (since \u2206 and \u2206\u2217 are kept consistent with each other and with E , the latter condition is equivalent to the consistency of E). A consistent state with an empty set of goals (G = \u2205) is called a solution state.\nA derivation starts with an initial state (G0 , ST 0), where every element in ST 0 is empty, and the initial goal, G0, contains the query Q and all the integrity constraints IC of the theory T . Then a sequence of rewriting steps is performed. A step starts in a certain state Si = (Gi , ST i), selects a goal in Gi, and applies an inference rule (see below) to obtain a new consistent state Si+1. When no consistent state can be reached from Si the derivation backtracks. A derivation terminates when a solution state is reached, otherwise it fails (see Section 4.4 below for a demonstration of this process).\nNext we present the inference rules in the Asystem, using the following conventions:\n\u2022 G\u2212i = Gi \u2212 {F}, where F is the selected goal formula.\n\u2022 OR and SELECT denote nondeterministic choices in an inference rule.\n\u2022 Q is a conjunction of literals, possibly empty. Since an empty conjunction is equivalent to true, the denial \u2190 Q with empty Q is equivalent to false.\n\u2022 If \u2206, \u2206\u2217, and E are not mentioned, they remain unchanged.\nThe inference rules are classified in four groups, named after the leftmost literal in the selected formula (shown in bold). Each group contains rules for (positive) conjunctions of literals and rules for denials.\n1. Defined predicates: The inference rules unfold the bodies of a defined predicate. For positive conjunctions this corresponds to standard resolution with a selected clause, whereas in the denial all clauses are used because every clause leads to a new denial.\nD.1 p(t) \u2227Q: Let p(si) \u2190 Bi \u2208 P (i = 1, . . . , n) be n clauses with p in the head. Then: Gi+1 = G \u2212 i \u222a {t = s1 \u2227B1 \u2227Q} OR . . .OR Gi+1 = G \u2212 i \u222a {t = sn \u2227Bn \u2227Q}\n21. The actual implementation of the Asystem also contains a store for finite domain constraint expressions. This store is not needed for the application here, and hence it is omitted.\nD.2 \u2200X(\u2190 p(t) \u2227Q): Gi+1 = G \u2212 i \u222a{\u2200X,Y (\u2190 t = s\u2227B \u2227Q) | there is p(s) \u2190 B \u2208 P with variables Y }\n2. Negations: Resolving negation corresponds to \u2018switching\u2019 the mode of reasoning from a positive literal to a denial and vice versa. This is similar to the idea of negation-as-failure in logic programming.\nN.1 \u00acp(t) \u2227Q: Gi+1 = G \u2212 i \u222a {Q,\u2190 p(t)} N.2 \u2200X(\u2190 \u00acp(t) \u2227Q) and t does not contain variables in X: Gi+1 = G \u2212 i \u222a {p(t)} OR Gi+1 = G \u2212 i \u222a {\u2190 p(t),\u2200X(\u2190 Q)}\n3. Abducibles: The first rule is responsible for the creation of new hypotheses. Both rules ensure that the elements in \u2206 are consistent with those in \u2206\u2217.\nA.1 a(t) \u2227Q: SELECT an arbitrary a(s) \u2208 \u2206 and define Gi+1 = G \u2212 i \u222a {Q} \u222a {s = t}\nOR Gi+1 = G \u2212 i \u222a {Q} \u222a {\u2200X(\u2190 s = t \u2227R) | \u2200X(\u2190 a(s) \u2227R) \u2208 \u2206 \u2217 i } \u222a\n{\u2190 (t = s) | a(s) \u2208 \u2206i} and \u2206i+1 = \u2206i \u222a {a(t)}\nA.2 \u2200X(\u2190 a(t) \u2227Q): Gi+1 = G \u2212 i \u222a {\u2200X(\u2190 s = t\u2227Q) | a(s) \u2208 \u2206i} and \u2206 \u2217 i+1 = \u2206 \u2217 i \u222a {\u2200X(\u2190 a(t)\u2227Q)}\n4. Equalities: These inference rules isolate the (in)equalities, so that the constraint solver can evaluate them. The first rule applies to equalities in goal formulae:\nE.1 s = t \u2227Q: Gi+1 = G \u2212 i \u222a {Q} and Ei+1 = Ei \u222a {s = t}\nThe following three rules handle equalities in denials. Which rule applies depends on whether s or t contain free or universally quantified variables. In these rules Q[X/t] denotes the formula that is obtained from Q by substituting the term t for X.\nE.2 \u2200X(\u2190 s = t \u2227Q): If s and t are not unifiable then Gi+1 = G \u2212 i ;\nOtherwise, let Es be the equation set in solved form representing a most general unifier of s and t (Martelli & Montanari, 1982). Gi+1 = G \u2212 i \u222a {\u2200X(\u2190 Es \u2227Q)}.\nE.3 \u2200X,Y(\u2190 X = t \u2227Q) where t is a term not containing X: Gi+1 = G \u2212 i \u222a {\u2200Y (\u2190 Q[X/t])} E.4 \u2200X,Y(\u2190 X = t \u2227Q) where X is a free variable and X is the set of universally quantified variables in a term t: Ei+1 = Ei \u222a {\u2200X(X 6= t)} OR Gi+1 = G \u2212 i \u222a {X = t} \u222a {\u2200Y (\u2190 Q[X/t])} 22.\n22. In its first branch the inference E.4 explores the condition \u2200X(X 6= t). In the second branch, the negation of this condition is explored. Here X is identical to t, for some values assigned to X . This is why in the second branch, the universally quantified variables X are turned into free variables which may appear free in \u2200Y (\u2190 Q[X/t]).\nAs usual, one has to check for floundering negation. This occurs when the inference rule N.2 is applied on a denial with universally quantified variables in the negative literal \u00acp(t). Floundering aborts the derivation.\nAn answer substitution \u03b8, derived from a solution state S, is any substitution \u03b8 of the free variables in S which satisfies E (i.e. \u03b8(E) is true) and grounds \u2206. Note that, in case of an abductive theory without abducibles and integrity constraints, computed answers as defined by Lloyd (1987) are most general unifiers of E and correct answers are answer substitutions as defined above.\nProposition 10 (Kakas, Van Nuffelen, & Denecker, 2001) Let T = (P,A,IC) be an abductive theory, Q a query, S a solution state of a derivation for Q, and \u03b8 an answer substitution of S. Then the pair consisting of the ground abducible atoms \u03b8(\u2206(S)) and of the answer substitution \u03b8 is an abductive solution for T and Q."}, {"heading": "4.3.2 Constraint Transformation to Denial Form", "text": "Since the inference rules of the Asystem are applied only on integrity constraints in denial form, the integrity constraints IC in the abductive theory T must be translated to this form. This is done by applying a variant of the Lloyd-Topor transformation (Lloyd & Topor, 1984) on the integrity constraints (see Denecker & De Schreye, 1998). This is the same procedure as the well-known procedure used in deductive databases to convert a first order quantified query Q into a logically equivalent pair of an atomic query and a nonrecursive datalog procedure. The transformation is defined as a rewriting process of sets of formulae: the initial set is {\u2190 \u00acF |F \u2208 IC}, and the transformation is done by applying De Morgan and various distribution rules. New predicates and rules may be introduced during the transformation in order to deal with universal quantifications in denials. Below we illustrate the transformation in the case of the integrity constraints of the running example.\nExample 9 Consider the following extension of the integrity constraints of Example 1:\nIC = { \u2200X\u2200Y \u2200Z (teaches(X,Y ) \u2227 teaches(X,Z) \u2192 Y = Z) ,\n\u2200X (teacher(X) \u2192 \u2203Y teaches(Y,X)) }.\nNote that in addition to the original integrity constraint of Example 1, here we also demand that every teacher has to give at least one course.\n\u2022 Lloyd-Topor transformation on the first integrity constraint:\n(1) \u2190 \u00ac\u2200X \u2200Y \u2200Z (\u00acteaches(X,Y ) \u2228 \u00acteaches(X,Z) \u2228 Y = Z)\n(2) \u2190 \u2203X \u2203Y \u2203Z (teaches(X,Y ) \u2227 teaches(X,Z) \u2227 Y 6= Z)\n(3) \u2200X \u2200Y \u2200Z (\u2190 teaches(X,Y ) \u2227 teaches(X,Z) \u2227 Y 6= Z)\n\u2022 Lloyd-Topor transformation on the second integrity constraint:\n(1) \u2190 \u00ac\u2200X (\u00acteacher(X) \u2228 \u2203Y teaches(Y,X))\n(2) \u2200X (\u2190 teacher(X) \u2227 \u00ac\u2203Y teaches(Y,X))\n(3) \u2200X (\u2190 teacher(X) \u2227 \u00acgives courses(X)) where gives courses is defined by: gives courses(X) \u2190 \u2203Y teaches(Y,X)\n(4) \u2200X (\u2190 teacher(X) \u2227 \u00acgives courses(X)), and gives courses(X) \u2190 teaches(Y,X)"}, {"heading": "4.3.3 Control Strategy", "text": "The selection strategy applied during the derivation process is crucial. A Prolog-like selection strategy (left first, depth first) often leads to trashing, because it is blind to other choices, and it does not result in a global overview of the current state of the computation. In the development of the Asystem the main focus was on the improvement of the control strategy. The idea is to apply first those rules that result in a deterministic change of the state, so that information is propagated. If none of such rules is applicable, then one of the left over choices is selected. By this strategy, commitment to a choice is suspended until the moment where no other information can be derived in a deterministic way. This resembles a CLP-solver, in which the constraints propagate their information as soon as a choice is made. This propagation can reduce the number of choices to be made and thus often dramatically increases the performance."}, {"heading": "4.3.4 Implementation", "text": "In this section we describe the structure of our implementation. Figure 3 shows a layered view. The upper-most level consists of the specific abductive logic theory of the integration task, i.e., the database information and the integrity constraints. This layer together with the composer form the abductive meta-theory (see Section 4.2) that is processed by the Asystem.\nAs noted above, the composer consists of a meta-theory for integrating the databases in a coherent way. It is interpreted here as an abductive theory, in which the abducible predicates provide the information on how to restore the consistency of the amalgamated data.\nThe abductive system (enclosed by dotted lines in Figure 3) consists of three main components: a finite domain constraint solver (part of Sicstus Prolog), an abductive metainterpreter (described in the previous sections), and an optimizer.\nThe optimizer is a component that, given a preference criterion on the space of the solutions, computes only the most-preferred (abductive) solutions. Given such a preference criterion, this component prunes \u2018on the fly\u2019 those branches of the search tree that lead to solutions that are worse than others that have already been computed. This is actually a branch and bound \u2018filter\u2019 on the solutions space, that speeds-up execution and makes sure that only the desired solutions will be obtained23. If the preference criterion is a pre-order, then the optimizer is complete, that is, it can compute all the optimal solutions (more about this in Section 4.5). Moreover, this is a general-purpose component, and it may be useful not only for data integration, but also for, e.g., solving planning problems."}, {"heading": "4.3.5 Complexity", "text": "It is well-known that in general, the task of repairing a database is not tractable, as there may be an exponential number of different ways of repairing it. Even in cases where integrity constraints are assumed to be single-headed dependencies (Greco & Zumpano, 2000), checking whether there exists a \u2264-repaired database in which a certain query Q is satisfied, is in \u03a3P2 . Checking if a fact is satisfied by all the \u2264-repaired databases is in \u03a0 P 2 (see Greco & Zumpano, 2000). This is not surprising in light of the correspondence between computations of \u2264-minimal repairs and computations of entailment relations defined by maximally consistent models (see Propositions 5\u20138), also known to be on the second level of the polynomial hierarchy.\nA pure upper bound for the Asystem is still unknown, since \u2013 to the best of our knowledge \u2013 no complexity results on SLDNFA refutation procedure are available.\n4.4 Example: A Derivation of Repairs by the Asystem\nConsider again Example 9. The corresponding meta-theory (assuming that the Lloyd-Topor transformation has been applied on it) is given in Figure 4. In this case, and in what follows, we shall assume that all variables in the denials are universally quantified, and so, in order to reduce the amount of notations, universal quantifiers are omitted from the denial rules.\nWe have executed the code of Figure 4, as well as other examples from the literature in our system. As Theorem 2 in Section 4.5 guarantees, the output in each case is the set of the most preferred solutions of the corresponding problem. In what follows we demonstrate\n23. See also the third item of Note 2 (at the end of Section 4.4).\nhow some of the most preferred solutions for the meta-theory above are computed.\nWe follow one branch in the refutation tree, starting from the initial state (G0, ST 0), where the initial set of goals is G0 = {\u2018true\n\u2032, ic1, ic2, composer-ic1, composer-ic2}, and the initial store is ST 0 = (\u2205, \u2205, \u2205). Suppose that the first selected formula is\nF1 = ic1 = \u2190 fact(teaches(X, Y)) \u2227 fact(teaches(X, Z)) \u2227 (Y 6= Z).\nThen, by D.2,\nG1 = G0 \\ F1 \u222a\n{\u2190 db(teaches(X, Y)) \u2227 \u00acretract(teaches(X, Y))\u2227 fact(teaches(X, Z))\u2227 (Y 6= Z),\n\u2190 insert(teaches(X, Y))\u2227 fact(teaches(X, Z))\u2227 (Y 6= Z) },\nand ST 1 = ST 0. Now, pick\nF2 = \u2190 db(teaches(X, Y)) \u2227 \u00acretract(teaches(X, Y))\u2227 fact(teaches(X, Z))\u2227 (Y 6= Z).\nSelect db(teaches(X,Y)), unfold all the corresponding atoms in the database, and then, again by D.2, followed by E.2 and E.3,\nG2 = G1 \\ F2 \u222a\n{\u2190 \u00acretract(teaches(c1, n1)) \u2227 fact(teaches(c1, Z)) \u2227 (n1 6= Z),\n\u2190 \u00acretract(teaches(c2, n2)) \u2227 fact(teaches(c2, Z)) \u2227 (n2 6= Z),\n\u2190 \u00acretract(teaches(c2, n3)) \u2227 fact(teaches(c2, Z)) \u2227 (n3 6= Z) },\nand still ST 2 = ST 1. Pick then the second denial among the new goals that were added to G2. Denote this denial F3. Since F3 starts with a negated literal, N.2 applies, and the derivation process splits here to two branches. The second branch contains\nG3 = G2 \\ F3 \u222a {\u2190 retract(teaches(c2, n2)), \u2190 fact(teaches(c2, Z)) \u2227 (n2 6= Z) },\nand still ST 3 = ST 2. Choose now the first new goal, i.e.,\nF4 = \u2190 retract(teaches(c2, n2)).\nNow, since \u22063 = \u2205, the only option is to add F4 to \u2206 \u2217 3. Thus, by A.2,\nG4 = G3 \\ F4 and ST 4 = (\u2205, {F4}, \u2205).\nAssume, now, that we take the second new goal of G3:\nF5 = \u2190 fact(teaches(c2, Z)) \u2227 (n2 6= Z).\nFollowing a similar process of unfolding data as described above, using db(teaches(c2, n3)), we end-up with\n\u2190 retract(teaches(c2, n3)) \u2227 (n2 6= n3).\nSelecting the negative literal (n2 6= n3), N.2 applies again. The first branch quickly results in failure after adding (n2 = n3) to E . The second branch adds \u2190 (n2 = n3) and retract(teaches(c2, n3)) to the set of goals. The former one is added to the constraint store, as (n2 6= n3), and simplifies to true. Assume the latter is selected next. Let this be the i-th step. We have that by now \u2206i\u22121 (the set of abducible predicates produced until the current step) is empty, thus the only option is to abduce retract(teaches(c2, n3)). Thus, by A.1, ST i consists of:\n\u2206i = {retract(teaches(c2, n3))}, \u2206 \u2217 i = {F4} = {\u2190 retract(teaches(c2, n2))},"}, {"heading": "Ei = Ei\u22121, and", "text": "Gi = Gi\u22121 \\ {retract(teaches(c2, n3))} \u222a {\u2190 teaches(c2, n2) = teaches(c2, n3)}.\nAs the last goal is certainly satisfied, ic1 is resolved in this branch.\nNow we turn to ic2. So:\nFi+1 = ic2 = \u2190 fact(teacher(X))\u2227 \u00acgives courses(X).\nThe evaluation of Fi+1 for either x = n1 or x = n2 is successful, so the only interesting case is when x = n3. In this case the evaluation leads to the goal gives courses(X). Unfolding this goal yields that fact(teaches(Y, n3)) appears in the goal set. In order to satisfy this goal, it should be resolved either with one of the composer\u2019s rules (using D.1). The first rule (i.e., fact(X) \u2190 db(X) \u2227\u00ac retract(X)) leads to a failure (since retract(teaches(c2, n3)) is already in \u2206), and so the second rule of the composer, fact(X) \u2190 insert(X), must be applied. This leads to the abduction of insert(teaches(Y, n3)). By ic1, Y 6= c1 and Y 6= c2 is derived24. Also, composer-ic1 and composer-ic2 are satisfied by the current state, so eventually the solution state that is reached from the derivation path described here,\n24. One can verify that these constraints are indeed detected during the derivations process. We omit the details here in order to keep this example tractable.\ncontains the following sets:\n\u2206 = {retract(teaches(c2, n3)), insert(teaches(Y, n3))},\nE = {Y 6= c1, Y 6= c2},\nwhich means retraction of teaches(c2, n3) and insertion of teaches(Y, n3) for some Y 6= c1 and Y 6= c2. The other solutions are obtained in a similar way.\nNote 2 Below are some remarks on the above derivation process.\n1. The solution above contains a non-ground abducible predicate. This indeed is the expected result, since this solution resolves the contradiction with the integrity constraint ic1 by removing the assumption that teacher n3 teaches course c2. As a result, teacher n3 does not teach any course. Thus, in order to assure the other integrity constraint (ic2), the solution indicates that n3 must teach some course (other than c1 and c2).\n2. One possible (and realistic) explanation for the cause of the inconsistency in the database of Example 9 and Figure 4, is a typographic error. It might happen, for instance, that c2 was mistakenly typed instead of, say, c3, in teaches(c2,n3). In this case, the database repair computed above pinpoints this possibility (in our case, then, Y should be equal to c3)\n25. This explanation cannot be explicitly captured, unless particular repairs with non-ground solutions are constructed, as indeed is the case here. While some other approaches that have been recently introduced (e.g., Bravo & Bertossi, 2003; Cali, Lembo, & Rosati, 2003) properly capture cases such as those of Example 9, to the best of our knowledge, no other application of database integration has this ability.\n3. Once the system finds a solution that corresponds to a goal state Sg = (Gg, ST g) with Gg = \u2205 and ST g = (\u2206g,\u2206 \u2217 g, Eg), the \u2264i-optimizer may be used such that whenever a\nstate S = (Gs, (\u2206s,\u2206 \u2217 s, Es)) is reached, and |\u2206g| < |\u2206s|, the corresponding branch of the tree is pruned26."}, {"heading": "4.5 Soundness and Completeness", "text": "In this section we give some soundness and completeness results for the Asystem, and relate these results to the model-based preferential semantics, considered in Section 3.\nIn what follows we denote by T an abductive meta-theory (constructed as described in Section 4.2) for composing n given databases DB1, . . . ,DBn. Let also ProcALP be some sound abductive proof procedure for T 27. The following proposition shows that ProcALP provides a coherent method for integrating the databases that are represented by T .\nProposition 11 Every abductive solution that is obtained by ProcALP for the query \u2018true\u2019 on a theory T , is a repair of UDB.\n25. The variable Y is free and {Y/c3} is an answer substitution as it grounds \u2206 and satisfies E . 26. As the size of \u2206s can only increase along the derivation, the state S cannot lead to a solution that is\nbetter than the one induced by Sg, and so the corresponding branch of the tree can indeed be pruned. 27. That is, ProcALP is a process for computing only the abductive solutions of T , in the sense of Definition 14.\nProof: By the construction of T it is easy to see that all the conditions that are listed in Definition 5 are satisfied. Indeed, the first two conditions are assured by the integrity constraints of the composer. The last condition is also met since by the soundness of ProcALP it produces abductive solutions \u2206i for a query \u2018true\u2019 on T . Thus, by the second property in Definition 14, for every such solution \u2206i = (Inserti,Retracti) we have that P \u222a\u2206i |= IC. Since P contains a data section with all the facts, it follows that D \u222a\u2206i |= IC, i.e. every integrity constraints follows from D \u222a Inserti \\ Retracti. \u2737\nAs SLDNFA is a sound abductive proof procedure (Denecker & De Schreye, 1998), it can be taken as the procedure ProcALP, and so Proposition 11 provides a soundness theorem for the current implementation of the Asystem. When an optimizer is incorporated in the Asystem, we have the following soundness result for the extended system:\nTheorem 1 (Soundness) Every output that is obtained by the query \u2018true\u2019 on T , where the Asystem is executed with a \u2264c-optimizer [respectively, with an \u2264i-optimizer], is a \u2264cpreferred repair [respectively, an \u2264i-preferred repair] of UDB.\nProof: Follows from Proposition 11 (since the Asystem is based on SLDNFA which is a sound abductive proof procedure), and the fact that the \u2264c-optimizer prunes paths that lead to solutions that are not \u2264c-preferable. Similar arguments hold for systems with an \u2264i-optimizer. \u2737\nProposition 12 Suppose that the query \u2018true\u2019 has a finite SLDNFA-tree w.r.t. T . Then every \u2264c-preferred repair and every \u2264i-preferred repair of UDB is obtained by running T in the Asystem.\nOutline of proof: The proof that all the abductive solutions with minimal cardinality are obtained by the system is based on Theorem 10.1 of Denecker & De Schreye, 1998, where it is shown that SLDNFAo, which is an extension of SLDNFA, aimed for computing solutions with minimal cardinality, is complete; see Denecker & De Schreye, 1998, Section 10.1, for further details. Similarly, the proof that all the abductive solutions which are minimal w.r.t. set inclusion are obtained by the system is based on Theorem 10.2 of Denecker & De Schreye, 1998, that shows that SLDNFA+, which is another extension of SLDNFA, aimed for computing minimal solutions w.r.t. set inclusion, is also complete; see Denecker & De Schreye, 1998, Section 10.2, for further details.\nNow, the Asystem is based on the combination of SLDNFAo and SLDNFA+. Moreover, as this system does not change the refutation tree (but only controls the way rules are selected), Theorems 10.1 and 10.2 in Denecker and De Schreye (1998) are applicable in our case as well. Thus, all the \u2264c- and the \u2264i-minimal solutions are produced. This in particular means that every \u2264c-preferred repair as well as every \u2264i-preferred repair of UDB is produced by our system. \u2737\nIt should be noted that the last proposition does not guarantee that non-preferred repairs will not be produced (as this is not true in general). However, as the following theorem shows, the use of an optimizer excludes this possibility.\nTheorem 2 (Completeness) In the notations of Proposition 12 and under its assumptions, the output of the execution of T in the Asystem together with a \u2264c-optimizer [respectively, together with an \u2264i-optimizer] is exactly !(UDB,\u2264c) [respectively, !(UDB,\u2264i)].\nProof: We shall show the claim for the case of \u2264c; the proof w.r.t. \u2264i is similar.\nLet (Insert,Retract) \u2208 !(UDB,\u2264c). By Proposition 12, \u2206 = (Insert,Retract) is one of the solutions produced by the Asystem for T . Now, during the execution of the system together with the \u2264c-optimizer, the path that corresponds to \u2206 cannot be pruned from the refutation tree, since by our assumption (Insert,Retract) has a minimal cardinality among the possible solutions, so the pruning condition is not satisfied. Thus \u2206 will be produced by the \u2264c-optimized system. For the converse, suppose that (Insert,Retract) is some repair of UDB that is produced by the \u2264c-optimized system. Suppose for a contradiction that (Insert,Retract) 6\u2208 !(UDB,\u2264c). By the proof of Proposition 12, there is some \u2206\u2032 = (Insert\u2032,Retract\u2032)\u2208 !(UDB,\u2264c) that is constructed by the Asystem for T , and (Insert\u2032,Retract\u2032)<c (Insert,Retract). But |\u2206\n\u2032| < |\u2206|, and so the \u2264c-optimizer would prune the path of the \u2206 solution once its cardinality becomes bigger than |\u2206\u2032|. This contradicts our assumption that (Insert,Retract) is produced by the \u2264c-optimized system. \u2737\nNote 3 The SLDNFA-resolution on which the Asystem is based is an extension of SLDNFresolution (Lloyd, 1987) and coincides with it for logic programs with empty sets of abducible predicates. SLDNF-resolution is complete only if its computation always terminates. SLDNFA inherits this property. This is the reason why the condition of a finite SLDNFA-tree is imposed in Proposition 12 and Theorem 2. Like SLDNF, the termination of SLDNFA can be guaranteed by imposing syntactic conditions on the program. We refer to (Verbaeten, 1999), where some conditions are proposed to guarantee the existence of a finite SLDNFA-tree.\nIn the context of our paper, floundering would arise in the presence of unsafe integrity constraints (e.g., \u2200x p(x)). One way to eliminate this problem is to use a unary domain predicate dom, ranging over the objects of the database, and to add a range for each quantified variable in the integrity constraints, so that we obtain formulae of the form \u2200x(dom(x) \u2192 \u03c8(x)) and \u2203x(dom(x) \u2227 \u03c8(x)).\nThe following results immediately follow from the propositions above and those of Section 3 (unless explicitly said, the Asystem is without optimizer).\nCorollary 1 Suppose that the query \u2018true\u2019 has a finite SLDNFA refutation tree w.r.t. input theory T . Then:\n1. for every output (Insert, Retract) of the Asystem there is a classical model M of IC s.t. Insert =M t \\ D and Retract = D \\M t.\n2. for every output (Insert, Retract) of the Asystem there is a 3-valued model N of D\u222aIC s.t. InsertN = Insert and RetractN =Retract.\nCorollary 2 In the notations of Corollary 1 and under its assumption, we have that:\n1. for every output (Insert, Retract) that is obtained by running the Asystem together with an \u2264i-optimizer [respectively, together with a \u2264c-optimizer], there is an \u2264i-maximally consistent element [respectively, a \u2264c-maximally consistent element] N in M UDB s.t.\nInsert N = Insert and RetractN = Retract.\n2. for every \u2264i-maximally consistent element [respectively, \u2264c-maximally consistent element] N in MUDB there is a solution (Insert, Retract) that is obtained by running the Asystem together with an \u2264i-optimizer [respectively, together with a \u2264c-optimizer] s.t. Insert = InsertN and Retract = RetractN .\nThe last corollaries show that the operational semantics, induced by the Asystem, can also be represented by a preferential semantics, in terms of preferred models of the theory. The setR(UDB,\u2264) that represents the intended meaning of how to \u2018\u2264-recover\u2019 the database UDB, can therefore be obtained computationally, by the set\n{(Insert,Retract) | (Insert,Retract) is an output of the Asystem with an \u2264-optimizer},\nor, equivalently, it can be described in terms of preferred models of the theory, by the following set:\n{(InsertN ,RetractN ) | N is \u2264-maximally consistent in MUDB}."}, {"heading": "4.6 Handling Specialized Information", "text": "The purpose of this section is to demonstrate the potential usage of our system in more complex scenarios, where various kinds of specialized data are incorporated in the system. In particular, we briefly consider time information and source identification. We also give some guidelines on how to extend the system with capabilities of handling these kinds of information."}, {"heading": "4.6.1 Timestamped Information", "text": "Many database applications contain temporal information. This kind of data may be divided in two types: time information that is part of the data itself, and time information that is related to database operations (e.g., records on database update time). Consider, for instance, birth day(John,15/05/2001)16/05/2001. Here, John\u2019s date of birth is an instance of the former type of time information, and the subscripted data that describes the time in which this fact was added to the database, is an instance of the latter type of time information.\nIn our approach, timestamp information can be integrated by adding a temporal theory describing the state of the database at any particular time point. One way of doing so is by using situation calculus. In this approach a database is described by some initial information and a history of events performed during the database lifetime (see Reiter, 1995). Here we use a different approach, which is based on event calculus (Kowalski & Sergot, 1986). The idea is to make a distinction between two kinds of events, add db and del db, that describe the database modifications, and the composer-driven events insert\nand retract that are used for constructing database repairs. In this view, the extended composer has the following form:\nholds at(P,T) \u2190 initially(P) \u2227 \u00acclipped(0,P,T) holds at(P,T) \u2190 add(P,E) \u2227 E<T \u2227 \u00acclipped(E,P,T)\nclipped(E,P,T) \u2190 del(P,C) \u2227 E\u2264C, C<T\nadd(P,T) \u2190 add db(P,T) add(P,T) \u2190 insert(P,T) del(P,T) \u2190 del db(P,T) del(P,T) \u2190 retract(P,T)\n\u2190 insert(P,T) \u2227 retract(P,T) \u2190 insert(P,T) \u2227 add db(P,T) \u2190 retract(P,T) \u2227 del db(P,T)\nNote that in the above extended representation, the integrity constraints must be carefully specified. Consider, e.g. the statement that a person can be born only on one date:\n\u2190 holds at(birth day(P,D1),T) \u2227 holds at(birth day(P,D2),T) \u2227 D1 6=D2\nThe problem here is that to ensure consistency, this constraint must be checked at every point in time. This may be avoided by a simple rewriting that ensures that the constraint will be verified only when an event for that person occurs:\nic(P,T) \u2190 holds at(birth day(P,D1),T) \u2227 holds at(birth day(P,D2),T) \u2227 D1 6=D2 \u2190 add db(birth day(P, ),T) \u2227 NT = T+1 \u2227 ic(P,NT) \u2190 insert(birth day(P, ),T) \u2227 NT = T+1 \u2227 ic(P,NT) \u2190 ic(P,0)\nNote 4 In the last example we have used temporal integrity constraints in order to resolve contradicting update events. Clearly, contradicting events do not necessarily yield a classically inconsistent database, and so the role of such integrity constraints is to express possible events in terms of time and causation, and \u2013 if necessary \u2013 describe their consequence as a violation of consistency.\nInstead of using temporal integrity constraints and event calculus, one could repair a database with time-stamps by using some time-based criterion for making preferences among its repairs. For instance, denote by db(x1, . . . , xn)t that the data-fact db(x1, . . . , xn) has a timestamp t, and suppose that (Insert,Retract) and (Insert\u2032,Retract\u2032) are two repairs of a database (D, IC). A time-based criterion for preferring (Insert,Retract) over (Insert\u2032,Retract\u2032) could state, e.g., that for every data-fact db(x1, . . . , xn) and timestamps t1, t2 s.t. db(x1, . . . , xn)t1 follows from D\u222a Insert\\Retract and db(x1, . . . , xn)t2 follows from D\u222a Insert\u2032 \\Retract\u2032, necessarily t1 \u2265 t2. A more detailed treatment of this issue is outside the scope of this paper.\nThe interested reader may refer, e.g., to (Sripada, 1995; Mareco & Bertossi, 1999) for a detailed discussion on the use of logic programming based approaches to the specification of temporal databases. Such specifications can be easily combined with those for repairs, given above."}, {"heading": "4.6.2 Keeping Track of Source Identities", "text": "There are cases in which it is important to preserve the identity of the database from which a specific piece of information was originated. This is useful, for instance, when one wants to make preferences among different sources, or when some specific source should be filtered out (e.g, when the corresponding database is not available or becomes unreliable). This kind of information may be decoded by adding another argument to every fact, which denotes the identity of its origin. This requires minor modifications in the basic composer, since the composer controls the way in which the data is integrated. As such, it is the only component that can keep track on the source of the information.\nSuppose, then, that for every database fact we add another argument that identifies its source. I.e., db(X,S) denotes that X is a fact originated from a database S. The composer then has the following form:\nfact(X,S) \u2190 db(X,S) \u2227 \u00acretract(X) fact(X,composer) \u2190 insert(X) \u2190 insert(X) \u2227 db(X,S) \u2190 retract(X) \u2227 \u00acdb(X,S)\nNote that the composer considers itself as an extra source that inserts brand new data facts. Now it is possible, e.g., to trace information that comes from a specific source, make preferences among different sources (by specifying appropriate integrity constraints), and filter data that comes from certain sources. The last property is demonstrated by the next rule:\nvalidFact(X) \u2190 fact(X,S) \u2227 trusted source(S)\nwhere trusted source enumerates all reliable sources of the data.\nNote that the last example of \u2018source identification\u2019 can be further extended in order to make preferences among different sources (and not only ignoring some unreliable sources). By introducing a new predicate, trust(Source,Amount), that attaches a certain level of reliability to each source, it is possible, in case of conflicts, to prefer sources with higher reliability as follows:\n\u2190 fact(X,S) \u2227 db(X,S0) \u2227 S 6= S0 \u2227 more trusted(S0,S) more trusted(S0,S) \u2190 trust(S0,A0) \u2227 trust(S,A) \u2227 A0 > A\nThis method is particularly useful when the integrity constraint above acts as a functional dependency on specific facts. The following example (originally introduced in Subrahmanian, 1994) demonstrates this.\nExample 10 Consider the following simple scenario of \u2018target recognition\u2019, where three sensors of an autonomous vehicle, which have different degrees of reliability, should identify objects in the vehicle\u2019s neighborhood:\ntrust(radar,10) trust(gunchar,8)\ntrust(speedometer,5)\ndb(observe(object1,t72),radar) db(observe(object1,t60),gunchar) db(observe(object1,t80),speedometer)\n\u2190 fact(observe(O,V1),S) \u2227 db(observe(O,V2),S0) \u2227 S 6=S0 \u2227 more trusted(S0,S)\nAs the radar has the highest reliability, its observation will be preserved. The observations of the other sensors will be retracted from the database."}, {"heading": "5. Discussion and an Overview of Related Works", "text": "The interest in systems for coherent integration of databases has been continuously growing in the last few years (see, e.g, Olive\u0301, 1991; Baral et al., 1991, 1992; Revesz, 1993; Subrahmanian, 1994; Bry, 1997; Gertz & Lipeck, 1997; Messing, 1997; Lin & Mendelzon, 1998; Liberatore & Schaerf, 2000; Ullman, 2000; Greco & Zumpano, 2000; Greco et al., 2001; Franconi et al., 2001; Lenzerini, 2001, 2002; Arenas et al., 1999, 2003; Bravo & Bertossi, 2003; Cali et al., 2003, and many others). Already in the early works on this subject it became clear that the design of systems for data integration is a complex task, which demands solutions to many questions from different disciplines, such as belief revision, merging and updating, reasoning with inconsistent information, constraint enforcement, query processing and \u2013 of course \u2013 many aspects of knowledge representation. In this section we shall address some of these issues.\nOne important aspect of data integration systems is how concepts in the independent (stand-alone) data-sources and those of the unified database are mapped to each other. A proper specification of the relations between the source schemas and the schema of the amalgamated data exempts the potential user from being aware where and how data is arranged in the sources. One approach for this mapping, sometimes called global-centric or global-as-view (Ullman, 2000), requires that the unified schema should be expressed in terms of the local schemas. In this approach, every term in the unified schema is associated with a view (alternatively, a query) over the sources. This approach is taken by most of the systems for data integration, as well as ours. The main advantage of this approach is that it induces a simple query processing strategy that is based on unfolding of the query, and uses the same terminology as that of the databases. This indeed is the case in the abductive derivation process, defined in Section 4.3.1. The other approach, sometimes called sourcecentric or local-as-view (used, e.g., in Bertossi et al., 2002), considers every source as a view over the integrated database, and so the meaning of every source is obtained by concepts of the global database. In particular, the global schema is independent of the distributed ones. This implies, in particular, that an addition of a new source to the system requires only to provide local definitions and not necessarily involves changes in the global schema. The main advantage of the latter approach is, therefore, that it provides a better setting for maintenance. For a detailed discussion on this topic, see (Ullman, 2000; Lenzerini, 2001; Cali et al., 2002; Van Nuffelen et al., 2004). More references and a survey on different approaches to data integration appear in the papers of Batini, Lenzerini, and Navathe (1986),\nRahm and Bernstein (2001), and Lenzerini (2002).\nAnother major issue that has to be addressed is the ability of data integration systems to properly cope with dynamically evolving worlds. In particular, the domain of discourse should not be fixed in advance, and information may be revised on a regular basis. The last issue is usually handled by methods of belief revision (Alchourro\u0301n et al., 1995; Ga\u0308rdenfors & Rott, 1995) and nonmonotonic reasoning . In the context of belief revision it is common to make a distinction between revisions of integrity constraints and changes in the sets of the data-facts, since the two types of information have different nature and thus may require different approaches for handling dynamic changes. When the set of integrity constraints is given in a clause form, methods of dynamic logic programing (Alferes et al., 2000, 2002) may be useful for handling revisions. As noted in (Alferes et al., 2002), assuming that each local database is consistent (as in our case), dynamic logic programing (together with a proper language for implementing it, like LUPS (Alferes et al., 2002)) provides a way of avoiding contradictory information, and so this may be viewed as a method of updating a database by a sequence of integrity constraints that arrive at different time points.\nWhen the types of changes are predictable, or can be characterized in some sense, temporal integrity constraints (in the context of temporal databases) can be used in order to specify how to treat new information. This method is also useful when the revision criteria are known in advance (e.g., \u2018in case of collisions, prefer the more recent data\u2019, cf. Section 4.6.1). See, e.g., (Sripada, 1995; Mareco & Bertossi, 1999) for a detailed discussion on temporal integrity constraints and temporal databases in a logic programming based formalisms.\nThe second type of revisions (i.e., modifications of data-facts) is obtained here through the (preferred) repairs of the unified database, which induce corresponding modifications of data-facts. A repair is usually induced by a method of restoring (or assuring) consistency of the amalgamated database by a minimal amount of change. As in our case, the minimization criterion is often determined by the aspiration to remain \u2018as close as possible\u2019 to the set of the collective information. This is a typical kind of a repair goal , and the standard ways of formally expressing it are by enumeration methods, such as the following28:\n\u2022 Minimizing the Hamming distance between the (propositional) models of the unified database and its repairs (Liberatore & Schaerf, 2000), or minimizing the distance between the corresponding three-valued interpretations (de Amo et al., 2002) according to a suitable generalization of Hamming distance.\n\u2022 Minimizing the symmetric distance between the sets of consequences of the corresponding databases (Arenas, Bertossi, & Chomicki, 1999; Arenas, Bertossi, & Kifer, 2000; Bertossi, Chomicki, Corte\u0301s, & Gutierrez, 2002) or, equivalently, minimizations in terms of set inclusion (Greco & Zumpano, 2000).\n\u2022 When the underlying data is prioritized, the corresponding quantitative information is also considered in the computations of distances (see, for instance, the work of Liberatore & Schaerf, 2000).\n28. See also (Gertz & Lipeck, 1997, Section 5) for a discussion on repair strategies.\nVarious ways of computing (preferred/minimal) repairs are described in the literature, among which are proof-theoretical (deductive) methods (Bertossi & Schwind, 2002; de Amo et al., 2002), abductive methods (Kakas & Mancarella, 1990a; Inoue & Sakama, 1995; Sakama & Inoue, 1999, 2000), and algorithmic approaches that are based on computations of maximal consistent subsets (Baral et al., 1991, 1992), or use techniques from model-based diagnosis (Gertz & Lipeck, 1997). A common approach is to view a database as a logic program, and to adopt standard techniques of giving semantics to logic programs in order to compute database repairs. For instance, stable-model semantics on disjunctive logic programs is used for computing repairs in (Greco & Zumpano, 2000; Greco et al., 2001; Franconi et al., 2001; Arenas et al., 2003), and resolution-based procedures for integrating several annotated databases are introduced by Subrahmanian (1990, 1994). As it follows from Section 4, the application introduced here is also based on an extended resolution strategy, applied on logic programs that may contain negation-as-failure operators and abducible predicates.\nAs repairing a database means in particular elimination of contradictions, reasoning with inconsistent information has been a major challenge for data integration systems. First, it is important to note in this respect that not every formalism for handling inconsistency is acceptable in the context of databases, even if the underlying criterion for handling inconsistency is the same as one of the repair goals mentioned above. The following example demonstrates such a case:\nExample 11 (Arenas, Bertossi, & Chomicki, 1999) Consider the following (inconsistent) database: DB = ({p, q}, {\u00ac(p \u2227 q)}). In the approach of Lin (1996), for instance, p \u2228 q may be inferred as the repaired database, following a strategy of minimal change. However, in this approach none of p, q, and \u00ac(p \u2227 q) holds in the repaired database. In particular (since in (Lin, 1996) there is no distinction between data-facts and integrity constraints), the integrity constraint {\u00ac(p \u2227 q)} itself cannot be inferred, which violates the intended meaning of an integrity constraint in databases.\nMany techniques for consistency enforcement and repairs of constraint violations have been suggested, among which are methods for resolving contradictions by quantitative considerations, such as \u2018majority vote\u2019 (Lin & Mendelzon, 1998; Konieczny & Pino Pe\u0301rez, 2002) or qualitative ones (e.g., defining priorities on different sources of information or preferring certain data over another, as in Benferhat, Cayrol, Dubois, Lang, & Prade, 1993, and Arieli, 1999). Another common method of handling inconsistent (and incomplete) information is by turning to multi-valued semantics. Three-valued formalisms such as the one considered in Section 3 are used as a semantical basis of paraconsistent methods to construct database repairs (de Amo, Carnielli, & Marcos, 2002) and are useful in general for pinpointing inconsistencies (Priest, 1991). Other approaches use lattice-based semantics to decode within the language itself some meta-information, such as confidence factors, amount of belief for or against a specific assertion, etc. These approaches combine corresponding formalisms of knowledge representation, such as annotated logic programs (Subrahmanian, 1990, 1994; Arenas et al., 2000) or bilattice-based logics (Fitting, 1991; Arieli & Avron, 1996; Messing, 1997), together with non-classical refutation procedures (Fitting, 1989; Subrahmanian,\n1990; Kifer & Lozinskii, 1992) that allow to detect inconsistent parts of a database and maintain them."}, {"heading": "6. Summary and Future Work", "text": "In this paper we have developed a formal declarative foundation for rendering coherent data, provided by different databases, and presented an application that implements this approach. Like similar applications (e.g., Subrahmanian, 1994; Bertossi, Arenas, & Ferretti, 1998; Greco & Zumpano, 2000; Liberatore & Schaerf, 2000), our system mediates among the sources of information and also between the reasoner and the underlying data.\nComposition of several data-sources is encoded by meta-theories in the form of abductive logic programs, and it is possible to extend these theories by providing meta-information on the data-facts, such as time-stamps and source identities. Moreover, since the reasoning process of the system is based on a pure generalization of classical refutation procedures, no syntactical embedding of first-order formulae into other languages, nor any extension of two-valued semantics, is necessary.\nDue the inherent modularity of the system, each component is independent and can be modified to meet different needs. Thus, for instance, the underlying solver may be replaced with any other solver that is capable of dealing with the meta-theory, and any improvement of the optimizer will affect the whole system and its efficiency, regardless the nature of its input. Also, the way of keeping data coherent is encapsulated in the component that integrates the data (i.e., the composer). This implies, in particular, that no input from the reasoner nor any other external policy for making preferences among conflicting sources is compulsory in order to resolve contradictions.\nAs we have shown, the operational semantics for inconsistent databases, induced by the Asystem, is strongly related to (multi-valued) preferential semantics. As preferential semantics provides the background for many non-monotonic and paraconsistent formalisms (e.g., Shoham, 1988; Priest, 1989, 1991; Kifer & Lozinskii, 1992; Arieli & Avron, 1996; Arieli, 1999, 2003), this implies that the Asystem may be useful for reasoning with general uncertain theories (not necessarily in the form of databases).\nIt is important to note that our composing system inherits the functionality of the underlying solver. The outcome of this is flexibility, modularity, simple interaction with different sources of information, and the ability to reason with any set of first-order formulae of integrity constraints29. To the best of our knowledge no other application of data integration has this ability.\nThere are several directions for further exploration. First, as we have already noted, two more phases, which have not been considered here, might be needed for a complete process of data integration:\n29. Provided, of-course, that the constraints do not lead to floundering.\na) translation of difference concepts to a unified ontology, and\nb) integration of integrity constraints.\nSo far, formalisms for dealing with the first item (e.g., Lenzerini, 2001, 2002; Van Nuffelen et al., 2004) mainly focus on the mutual relations between the global schema and the source (local) schemas, in particular how concepts of each ontology map to each other. On the other hand, formalisms for handling the second item concentrate on nonmonotonic reasoning for dynamically evolving (and mutually inconsistent) worlds. A synthesis of the main ideas behind these approaches, and incorporating them in our system, is a major challenge for future work.\nAnother important issue that deserves attention is the repair of inconsistency in the context of deductive databases with integrity constraints and definitions of predicates, often called view predicates. We refer to (Denecker, 2000) for a sketch on how this may be done. This kind of data may be further combined with (possibly inconsistent) temporal information, (partial) transactions, and (contradictory) update information.\nFinally, since different databases may have different information about the same predicates, it is reasonable to use some weakened version of the closed word assumption as part of the integration process (for instance, an assumption that something is false unless it is in the database, or unless some other database has some information about it)."}, {"heading": "Acknowledgements", "text": "We would like to thank the anonymous reviewers for many helpful comments and suggestions. This research was supported by the Research Fund K.U.Leuven and by FWO\u2013 Vlaanderen."}], "references": [], "referenceMentions": [], "year": 2011, "abstractText": "We introduce an abductive method for a coherent integration of independent datasources. The idea is to compute a list of data-facts that should be inserted to the amalgamated database or retracted from it in order to restore its consistency. This method is implemented by an abductive solver, called Asystem, that applies SLDNFA-resolution on a meta-theory that relates different, possibly contradicting, input databases. We also give a pure model-theoretic analysis of the possible ways to \u2018recover\u2019 consistent data from an inconsistent database in terms of those models of the database that exhibit as minimal inconsistent information as reasonably possible. This allows us to characterize the \u2018recovered databases\u2019 in terms of the \u2018preferred\u2019 (i.e., most consistent) models of the theory. The outcome is an abductive-based application that is sound and complete with respect to a corresponding model-based, preferential semantics, and \u2013 to the best of our knowledge \u2013 is more expressive (thus more general) than any other implementation of coherent integration of databases.", "creator": "dvips(k) 5.92b Copyright 2002 Radical Eye Software"}}}