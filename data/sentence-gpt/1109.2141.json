{"id": "1109.2141", "review": {"conference": "nips", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Sep-2011", "title": "Efficiency versus Convergence of Boolean Kernels for On-Line Learning Algorithms", "abstract": "The paper studies machine learning problems where each example is described using a set of Boolean features and where hypotheses are represented by linear threshold elements. One method of increasing the expressiveness of learned hypotheses in this context is to expand the feature set to include conjunctions of basic features. This can be done explicitly or where possible by using a kernel function. Focusing on the well known Perceptron and Winnow algorithms, the paper demonstrates a tradeoff between the computational efficiency with which the algorithm can be run over the expanded feature space and the generalization ability of the corresponding learning algorithm. We first describe several kernel functions which capture either limited forms of conjunctions or all conjunctions. We show that these kernels can be used to efficiently run the Perceptron algorithm over a feature space of exponentially many conjunctions; however we also show that using such kernels, the Perceptron algorithm can provably make an exponential number of mistakes even when learning simple functions. We then consider the question of whether kernel functions can analogously be used to run the multiplicative-update Winnow algorithm over an expanded feature space of exponentially many conjunctions. Known upper bounds imply that the Winnow algorithm can learn Disjunctive Normal Form (DNF) formulae with a polynomial mistake bound in this setting. However, we prove that it is computationally hard to simulate Winnows behavior for learning DNF over such a feature set. This implies that the kernel functions which correspond to running Winnow for this problem are not efficiently computable, and that there is no general construction that can run Winnow with kernels.\n\n\n\n\nWe use the Winnow algorithm to calculate the probability that a complex set of recursive expressions is expected to be generated in one step. For example, the number of recursive expressions is determined by the number of recursive expressions in a given list and the number of recursive expressions in the next step. For example, the number of recursive expressions is calculated by the number of recursive expressions in the next step. For example, the number of recursive expressions is determined by the number of recursive expressions in the next step. For example, the number of recursive expressions in the next step.\n\n\n\nThe results of our computation demonstrate that the average of a typical function is determined by a specific function in which the function is evaluated.\n\n\nWe then consider that the typical function of a simple function is determined by a single function in which the function is evaluated. To further illustrate the computational power of this approach, we consider that this process can be used as", "histories": [["v1", "Fri, 9 Sep 2011 20:31:05 GMT  (220kb)", "http://arxiv.org/abs/1109.2141v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["r khardon", "d roth", "r a servedio"], "accepted": true, "id": "1109.2141"}, "pdf": {"name": "1109.2141.pdf", "metadata": {"source": "CRF", "title": "Efficiency versus Convergence of Boolean Kernels for On-Line Learning Algorithms", "authors": ["Roni Khardon", "Dan Roth", "Rocco A. Servedio"], "emails": ["roni@cs.tufts.edu", "danr@cs.uiuc.edu", "rocco@cs.columbia.edu"], "sections": [{"heading": null, "text": "We first describe several kernel functions which capture either limited forms of conjunctions or all conjunctions. We show that these kernels can be used to efficiently run the Perceptron algorithm over a feature space of exponentially many conjunctions; however we also show that using such kernels, the Perceptron algorithm can provably make an exponential number of mistakes even when learning simple functions.\nWe then consider the question of whether kernel functions can analogously be used to run the multiplicative-update Winnow algorithm over an expanded feature space of exponentially many conjunctions. Known upper bounds imply that the Winnow algorithm can learn Disjunctive Normal Form (DNF) formulae with a polynomial mistake bound in this setting. However, we prove that it is computationally hard to simulate Winnow\u2019s behavior for learning DNF over such a feature set. This implies that the kernel functions which correspond to running Winnow for this problem are not efficiently computable, and that there is no general construction that can run Winnow with kernels."}, {"heading": "1. Introduction", "text": "The problem of classifying objects into one of two classes being \u201cpositive\u201d and \u201cnegative\u201d examples of a concept is often studied in machine learning. The task in machine learning is to extract such a classifier from given pre-classified examples - the problem of learning from data. When each example is represented by a set of n numerical features, an example\nc\u00a92005 AI Access Foundation. All rights reserved.\ncan be seen as a point in Euclidean space \u211cn. A common representation for classifiers in this case is a hyperplane of dimension (n \u2212 1) which splits the domain of examples into two areas of positive and negative examples. Such a representation is known as a linear threshold function, and many learning algorithms that output a hypothesis represented in this manner have been developed, analyzed, implemented, and applied in practice. Of particular interest in this paper are the well known Perceptron (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) and Winnow (Littlestone, 1988) algorithms that have been intensively studied in the literature.\nIt is also well known that the expressiveness of linear threshold functions is quite limited (Minsky & Papert, 1968). Despite this fact, both Perceptron and Winnow have been applied successfully in recent years to several large scale real world classification problems. As one example, the SNoW system (Roth, 1998; Carlson, Cumby, Rosen, & Roth, 1999) has successfully applied variations of Perceptron and Winnow to problems in natural language processing. The SNoW system extracts basic Boolean features x1, . . . , xn from labeled pieces of text data in order to represent the examples, thus the features have numerical values restricted to {0, 1}. There are several ways to enhance the set of basic features x1, . . . , xn for Perceptron or Winnow. One idea is to expand the set of basic features x1, . . . , xn using conjunctions such as (x1\u2227x3\u2227x4) and use these expanded higher-dimensional examples, in which each conjunction plays the role of a basic feature, as the examples for Perceptron or Winnow. This is in fact the approach which the SNoW system takes running Perceptron or Winnow over a space of restricted conjunctions of these basic features. This idea is closely related to the use of kernel methods, see e.g. the book of Cristianini and Shawe-Taylor (2000), where a feature expansion is done implicitly through the kernel function. The approach clearly leads to an increase in expressiveness and thus may improve performance. However, it also dramatically increases the number of features (from n to 3n if all conjunctions are used), and thus may adversely affect both the computation time and convergence rate of learning. The paper provides a theoretical study of the performance of Perceptron and Winnow when run over expanded feature spaces such as these."}, {"heading": "1.1 Background: On-Line Learning with Perceptron and Winnow", "text": "Before describing our results, we recall some necessary background on the on-line learning model (Littlestone, 1988) and the Perceptron and Winnow algorithms.\nGiven an instance space X of possible examples, a concept is a mapping of instances into one of two (or more) classes. A concept class C \u2286 2X is simply a set of concepts. In on-line learning a concept class C is fixed in advance and an adversary can pick a concept c \u2208 C. The learning is then modeled as a repeated game where in each iteration the adversary picks an example x \u2208 X, the learner gives a guess for the value of c(x) and is then told the correct value. We count one mistake for each iteration in which the value is not predicted correctly. A learning algorithm learns a concept class C with mistake bound M if for any choice of c \u2208 C and any (arbitrarily long) sequence of examples, the learner is guaranteed to make at most M mistakes.\nIn this paper we consider the case where the examples are given by Boolean features, that is X = {0, 1}n, and we have two class labels denoted by \u22121 and 1. Thus for x \u2208 {0, 1}n, a labeled example \u3008x, 1\u3009 is a positive example, and a labeled example \u3008x,\u22121\u3009 is a negative\nexample. The concepts we consider are built using logical combinations of the n base features and we are interested in mistake bounds that are polynomial in n."}, {"heading": "1.1.1 Perceptron", "text": "Throughout its execution Perceptron maintains a weight vector w \u2208 \u211cN which is initially (0, . . . , 0). Upon receiving an example x \u2208 \u211cN the algorithm predicts according to the linear threshold function w \u00b7 x \u2265 0. If the prediction is 1 and the label is \u22121 (false positive prediction) then the vector w is set to w\u2212x, while if the prediction is \u22121 and the label is 1 (false negative) then w is set to w + x. No change is made to w if the prediction is correct. Many variants of this basic algorithm have been proposed and studied and in particular one can add a non zero threshold as well as a learning rate that controls the size of update to w. Some of these are discussed further in Section 3.\nThe famous Perceptron Convergence Theorem (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) bounds the number of mistakes which the Perceptron algorithm can make:\nTheorem 1 Let \u3008x1, y1\u3009, . . . , \u3008x t, yt\u3009 be a sequence of labeled examples with x i \u2208 \u211cN , \u2016xi\u2016 \u2264"}, {"heading": "R and yi \u2208 {\u22121, 1} for all i. Let u \u2208 \u211c", "text": "N , \u03be > 0 be such that yi(u \u00b7 x i) \u2265 \u03be for all i. Then Perceptron makes at most R 2\u2016u\u20162\n\u03be2 mistakes on this example sequence."}, {"heading": "1.1.2 Winnow", "text": "The Winnow algorithm (Littlestone, 1988) has a very similar structure. Winnow maintains a hypothesis vector w \u2208 \u211cN which is initially w = (1, . . . , 1). Winnow is parameterized by a promotion factor \u03b1 > 1 and a threshold \u03b8 > 0; upon receiving an example x \u2208 {0, 1}N Winnow predicts according to the threshold function w \u00b7x \u2265 \u03b8. If the prediction is 1 and the label is \u22121 then for all i such that xi = 1 the value of wi is set to wi/\u03b1; this is a demotion step. If the prediction is \u22121 and the label is 1 then for all i such that xi = 1 the value of wi is set to \u03b1wi; this is a promotion step. No change is made to w if the prediction is correct.\nFor our purposes the following mistake bound, implicit in Littlestone\u2019s work (1988), is of interest:\nTheorem 2 Let the target function be a k-literal monotone disjunction f(x1, . . . , xN ) = xi1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 xik . For any sequence of examples in {0, 1}\nN labeled according to f the number of prediction mistakes made by Winnow(\u03b1, \u03b8) is at most \u03b1\u03b1\u22121 \u00b7 N \u03b8 + k(\u03b1 + 1)(1 + log\u03b1 \u03b8)."}, {"heading": "1.2 Our Results", "text": "We are interested in the computational efficiency and convergence of the Perceptron and Winnow algorithms when run over expanded feature spaces of conjunctions. Specifically, we study the use of kernel functions to expand the feature space and thus enhance the learning abilities of Perceptron and Winnow; we refer to these enhanced algorithms as kernel Perceptron and kernel Winnow.\nOur first result (cf. also the papers of Sadohara, 1991; Watkins, 1999; and Kowalczyk et al., 2001) uses kernel functions to show that it is possible to efficiently run the kernel Perceptron algorithm over an exponential number of conjunctive features.\nResult 1: (see Theorem 3) There is an algorithm that simulates Perceptron over the 3ndimensional feature space of all conjunctions of n basic features. Given a sequence of t labeled examples in {0, 1}n the prediction and update for each example take poly(n, t) time steps. We also prove variants of this result in which the expanded feature space consists of all monotone conjunctions or all conjunctions of some bounded size.\nThis result is closely related to one of the main open problems in learning theory: efficient learnability of disjunctions of conjunctions, or DNF (Disjunctive Normal Form) expressions.1 Since linear threshold elements can represent disjunctions (e.g. x1 \u2228 x2 \u2228 x3 is true iff x1 + x2 + x3 \u2265 1), Theorem 1 and Result 1 imply that kernel Perceptron can be used to learn DNF. However, in this framework the values of N and R in Theorem 1 can be exponentially large (note that we have N = 3n and R = 2n/2 if all conjunctions are used), and hence the mistake bound given by Theorem 1 is exponential rather than polynomial in n. The question thus arises whether the exponential upper bound implied by Theorem 1 is essentially tight for the kernel Perceptron algorithm in the context of DNF learning. We give an affirmative answer, thus showing that kernel Perceptron cannot efficiently learn DNF.\nResult 2: There is a monotone DNF f over x1, . . . , xn and a sequence of examples labeled according to f which causes the kernel Perceptron algorithm to make 2\u2126(n) mistakes. This result holds for generalized versions of the Perceptron algorithm where a fixed or updated threshold and a learning rate are used. We also give a variant of this result showing that kernel Perceptron fails in the Probably Approximately Correct (PAC) learning model (Valiant, 1984) as well.\nTurning to Winnow, an attractive feature of Theorem 2 is that for suitable \u03b1, \u03b8 the bound is logarithmic in the total number of features N (e.g. \u03b1 = 2 and \u03b8 = N). Therefore, as noted by several researchers (Maass & Warmuth, 1998), if a Winnow analogue of Theorem 3 could be obtained this would imply that DNF can be learned by a computationally efficient algorithm with a poly(n)-mistake bound. However, we give strong evidence that no such Winnow analogue of Theorem 3 can exist.\nResult 3: There is no polynomial time algorithm which simulates Winnow over exponentially many monotone conjunctive features for learning monotone DNF unless every problem in the complexity class #P can be solved in polynomial time. This result holds for a wide range of parameter settings in the Winnow algorithm.\nWe observe that, in contrast to this negative result, Maass and Warmuth have shown that the Winnow algorithm can be simulated efficiently over exponentially many conjunctive features for learning some simple geometric concept classes (Maass & Warmuth, 1998).\nOur results thus indicate a tradeoff between computational efficiency and convergence of kernel algorithms for rich classes of Boolean functions such as DNF formulas; the kernel\n1. Angluin (1990) proved that DNF expressions cannot be learned efficiently using equivalence queries whose hypotheses are themselves DNF expressions. Since the model of exact learning from equivalence queries only is equivalent to the mistake bound model which we consider in this paper, her result implies that no online algorithm which uses DNF formulas as hypotheses can efficiently learn DNF. However, this result does not preclude the efficient learnability of DNF using a different class of hypotheses. The kernel Perceptron algorithm generates hypotheses which are thresholds of conjunctions rather than DNF formulas, and thus Angluin\u2019s negative results do not apply here.\nPerceptron algorithm is computationally efficient to run but has exponentially slow convergence, whereas kernel Winnow has rapid convergence but seems to require exponential runtime."}, {"heading": "2. Kernel Perceptron with Many Features", "text": "It is well known that the hypothesis w of the Perceptron algorithm is a linear combination of the previous examples on which mistakes were made (Cristianini & Shaw-Taylor, 2000). More precisely, if we let L(v) \u2208 {\u22121, 1} denote the label of example v, then we have that w = \u2211\nv\u2208M L(v)v where M is the set of examples on which the algorithm made a mistake. Thus the prediction of Perceptron on x is 1 iff w \u00b7x = ( \u2211\nv\u2208M L(v)v)\u00b7x = \u2211\nv\u2208M L(v)(v \u00b7x) \u2265 0.\nFor an example x \u2208 {0, 1}n let \u03c6(x) denote its transformation into an enhanced feature space such as the space of all conjunctions. To run the Perceptron algorithm over the enhanced space we must predict 1 iff w\u03c6 \u00b7 \u03c6(x) \u2265 0 where w\u03c6 is the weight vector in the enhanced space; from the above discussion this holds iff \u2211\nv\u2208M L(v)(\u03c6(v) \u00b7 \u03c6(x)) \u2265 0. Denoting K(v, x) = \u03c6(v) \u00b7 \u03c6(x) this holds iff \u2211\nv\u2208M L(v)K(v, x) \u2265 0.\nThus we never need to construct the enhanced feature space explicitly; in order to run Perceptron we need only be able to compute the kernel function K(v, x) efficiently. This is the idea behind all so-called kernel methods, which can be applied to any algorithm (such as support vector machines) whose prediction is a function of inner products of examples. A more detailed discussion is given in the book of Cristianini and Shawe-Taylor (2000). Thus the next theorem is simply obtained by presenting a kernel function capturing all conjunctions.\nTheorem 3 There is an algorithm that simulates Perceptron over the feature spaces of (1) all conjunctions, (2) all monotone conjunctions, (3) conjunctions of size \u2264 k, and (4) monotone conjunctions of size \u2264 k. Given a sequence of t labeled examples in {0, 1}n the prediction and update for each example take poly(n, t) time steps.\nProof: For case (1) \u03c6(\u00b7) includes all 3n conjunctions (with positive and negative literals) and K(x, y) must compute the number of conjunctions which are true in both x and y. Clearly, any literal in such a conjunction must satisfy both x and y and thus the corresponding bit in x, y must have the same value. Thus each conjunction true in both x and y corresponds to a subset of such bits. Counting all these conjunctions gives K(x, y) = 2same(x,y) where same(x, y) is the number of original features that have the same value in x and y, i.e. the number of bit positions i which have xi = yi. This kernel has been obtained independently by Sadohara (2001).\nTo express all monotone monomials as in (2) we take K(x, y) = 2|x\u2229y| where |x \u2229 y| is the number of active features common to both x and y, i.e. the number of bit positions which have xi = yi = 1.\nSimilarly, for case (3) the number of conjunctions that satisfy both x and y is K(x, y) = \u2211k\nl=0 (same(x,y) l ) . This kernel is reported also by Watkins (1999). For case (4) we have\nK(x, y) = \u2211k\nl=0 (|x\u2229y| l ) . \u2737"}, {"heading": "3. Kernel Perceptron with Many Mistakes", "text": "In this section we describe a simple monotone DNF target function and a sequence of labeled examples which causes the monotone monomials kernel Perceptron algorithm to make exponentially many mistakes.\nFor x, y \u2208 {0, 1}n we write |x| to denote the number of 1\u2019s in x and, as described above, |x\u2229y| to denote the number of bit positions i which have xi = yi = 1. We need the following well-known tail bound on sums of independent random variables which can be found in, e.g., Section 9.3 of the book by Kearns and Vazirani (1994):\nFact 4 Let X1, . . . , Xm be a sequence of m independent 0/1-valued random variables, each of which has E[Xi] = p. Let X denote \u2211m i=1 Xi, so E[X] = pm. Then for 0 \u2264 \u03b3 \u2264 1, we have\nPr[X > (1 + \u03b3)pm] \u2264 e\u2212mp\u03b3 2/3 and Pr[X < (1 \u2212 \u03b3)pm] \u2264 e\u2212mp\u03b3 2/2.\nWe also use the following combinatorial property:\nLemma 5 There is a set S of n-bit strings S = {x1, . . . , xt} \u2282 {0, 1}n with t = en/9600 such that |xi| = n/20 for 1 \u2264 i \u2264 t and |xi \u2229 xj | \u2264 n/80 for 1 \u2264 i < j \u2264 t.\nProof: We use the probabilistic method. For each i = 1, . . . , t let xi \u2208 {0, 1}n be chosen by independently setting each bit to 1 with probability 1/10. For any i it is clear that E[|xi|] = n/10. Applying Fact 4, we have that Pr[|xi| < n/20] \u2264 e\u2212n/80, and thus the probability that any xi satisfies |xi| < n/20 is at most te\u2212n/80. Similarly, for any i 6= j we have E[|xi \u2229 xj |] = n/100. Applying Fact 4 we have that Pr[|xi \u2229 xj | > n/80] \u2264 e\u2212n/4800, and thus the probability that any xi, xj with i 6= j satisfies |xi \u2229 xj | > n/80 is at most (t 2 ) e\u2212n/4800. For t = en/9600 the value of (t 2 )\ne\u2212n/4800 + te\u2212n/80 is less than 1. Thus for some choice of x1, . . . , xt we have each |xi| \u2265 n/20 and |xi \u2229 xj | \u2264 n/80. For any xi which has |xi| > n/20 we can set |xi| \u2212 n/20 of the 1s to 0s, and the lemma is proved. \u2737\nNow using the previous lemma we can construct a difficult data set for kernel Perceptron:\nTheorem 6 There is a monotone DNF f over x1, . . . , xn and a sequence of examples labeled according to f which causes the kernel Perceptron algorithm to make 2\u2126(n) mistakes.\nProof: The target DNF with which we will use is very simple: it is the single conjunction x1x2 . . . xn. While the original Perceptron algorithm over the n features x1, . . . , xn is easily seen to make at most poly(n) mistakes for this target function, we now show that the monotone kernel Perceptron algorithm which runs over a feature space of all 2n monotone monomials can make 2 + en/9600 mistakes.\nRecall that at the beginning of the Perceptron algorithm\u2019s execution all 2n coordinates of w\u03c6 are 0. The first example is the negative example 0n. The only monomial true in this example is the empty monomial which is true in every example. Since w\u03c6 \u00b7 \u03c6(x) = 0 Perceptron incorrectly predicts 1 on this example. The resulting update causes the coefficient w\u03c6\u2205 corresponding to the empty monomial to become \u22121 but all 2 n \u2212 1 other coordinates of w\u03c6 remain 0. The next example is the positive example 1n. For this example we have w\u03c6 \u00b7 \u03c6(x) = \u22121 so Perceptron incorrectly predicts \u22121. Since all 2n monotone conjunctions\nare satisfied by this example the resulting update causes w\u03c6\u2205 to become 0 and all 2 n \u2212 1 other coordinates of w\u03c6 to become 1. The next en/9600 examples are the vectors x1, . . . , xt described in Lemma 5. Since each such example has |xi| = n/20 each example is negative; however as we now show the Perceptron algorithm will predict 1 on each of these examples.\nFix any value 1 \u2264 i \u2264 en/9600 and consider the hypothesis vector w\u03c6 just before example xi is received. Since |xi| = n/20 the value of w\u03c6 \u00b7 \u03c6(xi) is a sum of the 2n/20 different coordinates w\u03c6T which correspond to the monomials satisfied by x i. More precisely we have w\u03c6 \u00b7 \u03c6(xi) = \u2211\nT\u2208Ai w \u03c6 T + \u2211 T\u2208Bi w \u03c6 T where Ai contains the monomials which are satisfied\nby xi and xj for some j 6= i and Bi contains the monomials which are satisfied by x i but no xj with j 6= i. We lower bound the two sums separately. Let T be any monomial in Ai. By Lemma 5 any T \u2208 Ai contains at most n/80 variables and thus there can be at most \u2211n/80\nr=0 (n/20 r )\nmonomials in Ai. Using the well known bound \u2211\u03b1\u2113\nj=0 (\u2113 j ) = 2(H(\u03b1)+o(1))\u2113 where 0 < \u03b1 \u2264 1/2 and H(p) = \u2212p log p \u2212 (1 \u2212 p) log(1 \u2212 p) is the binary entropy function, which can be found e.g. as Theorem 1.4.5 of the book by Van Lint (1992), there can be at most 20.8113\u00b7(n/20)+o(n) < 20.041n terms in Ai. Moreover the value of each w\u03c6T must be at least \u2212e n/9600 since w\u03c6T decreases by at most 1 for each example, and hence \u2211\nT\u2208Ai w \u03c6 T \u2265 \u2212e n/960020.041n > \u221220.042n. On the other hand, any T \u2208 Bi\nis false in all other examples and therefore w\u03c6T has not been demoted and w \u03c6 T = 1. By Lemma 5 for any r > n/80 every r-variable monomial satisfied by xi must belong to Bi, and hence \u2211\nT\u2208Bi w \u03c6 T \u2265 \u2211n/20 r=n/80+1 (n/20 r ) > 20.049n. Combining these inequalities we have\nw \u00b7 xi \u2265 \u221220.042n + 20.049n > 0 and hence the Perceptron prediction on xi is 1. \u2737\nRemark 7 At first sight it might seem that the result is limited to a simple special case of the perceptron algorithm. Several variations exist that use: an added feature with a fixed value that enables the algorithm to update the threshold indirectly (via a weight w\u0302), a non zero fixed (initial) threshold \u03b8, and a learning rate \u03b1, and in particular all these three can be used simultaneously. The generalized algorithm predicts according to the hypothesis w \u00b7 x + w\u0302 \u2265 \u03b8 and updates w \u2190 w + \u03b1x and w\u0302 \u2190 w\u0302 + \u03b1 for promotions and similarly for demotions. We show here that exponential lower bounds on the number of mistakes can be derived for the more general algorithm as well. First, note that since our kernel includes a feature for the empty monomial which is always true, the first parameter is already accounted for. For the other two parameters note that there is a degree of freedom between the learning rate \u03b1 and fixed threshold \u03b8 since multiplying both by the same factor does not change the hypothesis and therefore it suffices to consider the threshold only. We consider several cases for the value of the threshold. If \u03b8 satisfies 0 \u2264 \u03b8 \u2264 20.047 then we use the same sequence of examples. After the first two examples the algorithm makes a promotion on 1n (it may or may not update on 0n but that is not important). For the examples in the sequence the bounds on \u2211\nT\u2208Ai w \u03c6 T and \u2211 T\u2208Bi w \u03c6 T are still valid so the\nfinal inequality in the proof becomes w \u00b7 xi \u2265 \u221220.042n + 20.049n > 20.047n which is true for sufficiently large n. If \u03b8 > 20.047n then we can construct the following scenario. We use the function f = x1 \u2228 x2 \u2228 . . . \u2228 xn, and the sequence of examples includes \u03b8 2 \u2212 1 repetitions of the same example x where the first bit is 1 and all other bits are 0. The example x satisfies exactly 2 monomials and therefore the algorithm will make mistakes on all the examples in the sequence. If \u03b8 < 0 then the initial hypothesis misclassifies 0n. We start the example\nsequence by repeating the example 0n until it is classified correctly, that is \u2308\u2212\u03b8\u2309 times. If the threshold is large in absolute value e.g. \u03b8 < \u221220.042n we are done. Otherwise we continue with the example 1n. Since all weights except for the empty monomial are zero at this stage the examples 0n and 1n are classified in the same way so 1n is misclassified and therefore the algorithm makes a promotion. The argument for the rest of the sequence is as above (except for adding a term for the empty monomial) and the final inequality becomes w \u00b7xi \u2265 \u221220.042n\u221220.042n +20.049n > \u221220.042n so each of the examples is misclassified. Thus in all cases kernel Perceptron may make an exponential number of mistakes."}, {"heading": "3.1 A Negative Result for the PAC Model", "text": "The proof above can be adapted to give a negative result for kernel Perceptron in the PAC learning model (Valiant, 1984). In this model each example x is independently drawn from a fixed probability distribution D and with high probability the learner must construct a hypothesis h which has high accuracy relative to the target concept c under distribution D. See the Kearns-Vazirani text (1994) for a detailed discussion of the PAC learning model.\nLet D be the probability distribution over {0, 1}n which assigns weight 1/4 to the example 0n, weight 1/4 to the example 1n, and weight 12 1 en/9600 to each of the en/9600 examples x1, . . . , xt.\nTheorem 8 If kernel Perceptron is run using a sample of polynomial size p(n) then with probability at least 1/16 the error of its final hypothesis is at least 0.49.\nProof: With probability 1/16, the first two examples received from D will be 0n and then 1n. Thus, with probability 1/16, after two examples (as in the proof above) the Perceptron algorithm will have w\u03c6\u2205 = 0 and all other coefficients of w \u03c6 equal to 1.\nConsider the sequence of examples following these two examples. First note that in any trial, any occurrence of an example other than 1n (i.e. any occurrence either of some xi or of the 0n example) can decrease \u2211\nT\u2286[n] w \u03b8 T by at most 2 n/20. Since after the first two examples\nwe have w\u03c6 \u00b7\u03c6(1n) = \u2211 T\u2286[n] w \u03b8 T = 2 n\u2212 1, it follows that at least 219n/20 \u2212 1 more examples must occur before the 1n example will be incorrectly classified as a negative example. Since we will only consider the performance of the algorithm for p(n) < 219n/20 \u2212 1 steps, we may ignore all subsequent occurrences of 1n since they will not change the algorithm\u2019s hypothesis.\nNow observe that on the first example which is not 1n the algorithm will perform a demotion resulting in w\u03c6\u2205 = \u22121 (possibly changing other coefficients as well). Since no promotions will be performed on the rest of the sample, we get w\u03c6\u2205 \u2264 \u22121 for the rest of the learning process. It follows that all future occurrences of the example 0n are correctly classified and thus we may ignore them as well.\nConsidering examples xi from the sequence constructed above, we may ignore any example that is correctly classified since no update is made on it. It follows that when the perceptron algorithm has gone over all examples, its hypothesis is formed by demotions on examples in the sequence of xi\u2019s. The only difference from the scenario above is that the algorithm may make several demotions on the same example if it occurs multiple times in the sample. However, an inspection of the proof above shows that for any xi that has not been seen by the algorithm, the bounds on \u2211\nT\u2208Ai w \u03c6 T and \u2211 T\u2208Bi w \u03c6 T are still valid and\ntherefore xi will be misclassified. Since the sample is of size p(n) and the sequence is of size en/9600 the probability weight of examples in the sample is at most 0.01 for sufficiently large n so the error of the hypothesis is at least 0.49. \u2737"}, {"heading": "4. Computational Hardness of Kernel Winnow", "text": "In this section, for x \u2208 {0, 1}n we let \u03c6(x) denote the (2n \u2212 1)-element vector whose coordinates are all nonempty monomials (monotone conjunctions) over x1, . . . , xn. We say that a sequence of labeled examples \u3008x1, b1\u3009, . . . , \u3008x\nt, bt\u3009 is monotone consistent if it is consistent with some monotone function, i.e. xik \u2264 x j k for all k = 1, . . . , n implies bi \u2264 bj . If S is monotone consistent and has t labeled examples then clearly there is a monotone DNF formula consistent with S which contains at most t conjunctions. We consider the following problem:\nKERNEL WINNOW PREDICTION(\u03b1, \u03b8) (KWP) Instance: Monotone consistent sequence S = \u3008x1, b1\u3009, . . . , \u3008x\nt, bt\u3009 of labeled examples with each xi \u2208 {0, 1}m and each bi \u2208 {\u22121, 1}; unlabeled example z \u2208 {0, 1}\nm. Question: Is w\u03c6 \u00b7 \u03c6(z) \u2265 \u03b8, where w\u03c6 is the N = (2m \u2212 1)-dimensional hypothesis vector generated by running Winnow(\u03b1, \u03b8) on the example sequence \u3008\u03c6(x1), b1\u3009, . . . \u3008\u03c6(x t), bt\u3009?\nIn order to run Winnow over all 2m \u2212 1 nonempty monomials to learn monotone DNF, one must be able to solve KWP efficiently. Our main result in this section is a proof that KWP is computationally hard for a wide range of parameter settings which yield a polynomial mistake bound for Winnow via Theorem 2.\nRecall that #P is the class of all counting problems associated with NP decision problems; it is well known that if every function in #P is computable in polynomial time then P = NP. See the book of Papadimitriou (1994) or the paper of Valiant (1979) for details on #P. The following problem is #P-hard (Valiant, 1979):\nMONOTONE 2-SAT (M2SAT) Instance: Monotone 2-CNF Boolean formula F = c1 \u2227 c2 \u2227 . . . \u2227 cr with ci = (yi1 \u2228 yi2) and each yij \u2208 {y1, . . . , yn}; integer K such that 1 \u2264 K \u2264 2\nn. Question: Is |F\u22121(1)| \u2265 K, i.e. does F have at least K satisfying assignments in {0, 1}n?\nTheorem 9 Fix any \u01eb > 0. Let N = 2m \u2212 1, let \u03b1 \u2265 1 + 1/m1\u2212\u01eb, and let \u03b8 \u2265 1 be such that max( \u03b1\u03b1\u22121 \u00b7 N \u03b8 , (\u03b1 + 1)(1 + log\u03b1 \u03b8)) = poly(m). If there is a polynomial time algorithm for KWP(\u03b1, \u03b8), then every function in #P is computable in polynomial time.\nProof: For N,\u03b1 and \u03b8 as described in the theorem a routine calculation shows that\n1 + 1/m1\u2212\u01eb \u2264 \u03b1 \u2264 poly(m) and 2m\npoly(m) \u2264 \u03b8 \u2264 2poly(m). (1)\nThe proof is a reduction from the problem M2SAT. The high level idea of the proof is simple: let (F,K) be an instance of M2SAT where F is defined over variables y1, . . . , yn. The Winnow algorithm maintains a weight w\u03c6T for each monomial T over variables x1, . . . , xn. We define a 1-1 correspondence between these monomials T and truth assignments yT \u2208 {0, 1}n\nfor F, and we give a sequence of examples for Winnow which causes w\u03c6T \u2248 0 if F (y T ) = 0 and w\u03c6T = 1 if F (y T ) = 1. The value of w\u03c6 \u00b7 \u03c6(z) is thus related to |F\u22121(1)|. Note that if we could control \u03b8 as well this would be sufficient since we could use \u03b8 = K and the result will follow. However \u03b8 is a parameter of the algorithm. We therefore have to make additional updates so that w\u03c6 \u00b7 \u03c6(z) \u2248 \u03b8 + (|F\u22121(1)| \u2212 K) so that w\u03c6 \u00b7 \u03c6(z) \u2265 \u03b8 if and only if |F\u22121(1)| \u2265 K. The details are somewhat involved since we must track the resolution of approximations of the different values so that the final inner product will indeed give a correct result with respect to the threshold.\nGeneral setup of the construction. In more detail, let\n\u2022 U = n + 1 + \u2308(\u2308log\u03b1 4\u2309 + 1) log\u03b1\u2309,\n\u2022 V = \u2308 n+1log\u03b1\u2309 + 1,\n\u2022 W = \u2308U+2log\u03b1\u2309 + 1\nand let m be defined as\nm = n + U + 6V n2 + 6UW + 3. (2)\nSince \u03b1 \u2265 1 + 1/m1\u2212\u01eb, using the fact that log(1 + x) \u2265 x/2 for 0 < x < 1 we have that log\u03b1 \u2265 1/(2m1\u2212\u01eb), and from this it easily follows that m as specified above is polynomial in n. We describe a polynomial time transformation which maps an n-variable instance (F,K) of M2SAT to an m-variable instance (S, z) of KWP(\u03b1, \u03b8) where S = \u3008x1, b1\u3009, . . . , \u3008x\nt, bt\u3009 is monotone consistent, each xi and z belong to {0, 1}m, and w\u03c6 \u00b7 \u03c6(z) \u2265 \u03b8 if and only if |F\u22121(1)| \u2265 K.\nThe Winnow variables x1, . . . , xm are divided into three sets A,B and C where A = {x1, . . . , xn}, B = {xn+1, . . . , xn+U} and C = {xn+U+1, . . . , xm}. The unlabeled example z is 1n+U0m\u2212n\u2212U , i.e. all variables in A and B are set to 1 and all variables in C are set to 0. We thus have w\u03c6\u00b7\u03c6(z) = MA+MB+MAB where MA = \u2211 \u22056=T\u2286Aw \u03c6 T , MB = \u2211 \u22056=T\u2286B w \u03c6 T and MAB = \u2211 T\u2286A\u222aB,T\u2229A 6=\u2205,T\u2229B 6=\u2205w \u03c6 T . We refer to monomials \u2205 6= T \u2286 A as type-A monomials, monomials \u2205 6= T \u2286 B as type-B monomials, and monomials T \u2286 A\u222aB, T\u2229A 6= \u2205, T\u2229B 6= \u2205 as type-AB monomials.\nThe example sequence S is divided into four stages. Stage 1 results in MA \u2248 |F \u22121(1)|; as described below the n variables in A correspond to the n variables in the CNF formula F. Stage 2 results in MA \u2248 \u03b1\nq|F\u22121(1)| for some positive integer q which we specify later. Stages 3 and 4 together result in MB +MAB \u2248 \u03b8\u2212\u03b1\nqK. Thus the final value of w\u03c6 \u00b7\u03c6(z) is approximately \u03b8 + \u03b1q(|F\u22121(1)| \u2212K), so we have w\u03c6 \u00b7 \u03c6(z) \u2265 \u03b8 if and only if |F\u22121(1)| \u2265 K.\nSince all variables in C are 0 in z, if T includes a variable in C then the value of w\u03c6T does not affect w\u03c6 \u00b7 \u03c6(z). The variables in C are \u201cslack variables\u201d which (i) make Winnow perform the correct promotions/demotions and (ii) ensure that S is monotone consistent.\nStage 1: Setting MA \u2248 |F \u22121(1)|. We define the following correspondence between truth assignments yT \u2208 {0, 1}n and monomials T \u2286 A : yTi = 0 if and only if xi is not present in T. For each clause yi1 \u2228 yi2 in F, Stage 1 contains V negative examples such that xi1 = xi2 = 0 and xi = 1 for all other xi \u2208 A. We show below that (1) Winnow makes a false positive prediction on each of these examples and (2) in Stage 1 Winnow never does a\npromotion on any example which has any variable in A set to 1. Consider any yT such that F (yT ) = 0. Since our examples include an example yS such that yT \u2264 yS the monomial T is demoted at least V times. As a result after Stage 1 we will have that for all T , w\u03c6T = 1 if F (yT ) = 1 and 0 < w\u03c6T \u2264 \u03b1 \u2212V if F (yT ) = 0. Thus we will have MA = |F\n\u22121(1)| + \u03b31 for some 0 < \u03b31 < 2\nn\u03b1\u2212V < 12 . We now show how the Stage 1 examples cause Winnow to make a false positive prediction on negative examples which have xi1 = xi2 = 0 and xi = 1 for all other i in A as described above. For each such negative example in Stage 1 six new slack variables x\u03b2+1, . . . , x\u03b2+6 \u2208 C are used as follows: Stage 1 has \u2308log\u03b1(\u03b8/3)\u2309 repeated instances of the positive example which has x\u03b2+1 = x\u03b2+2 = 1 and all other bits 0. These examples cause promotions which result in \u03b8 \u2264 w\u03c6x\u03b2+1 + w \u03c6 x\u03b2+2 + w\u03c6x\u03b2+1x\u03b2+2 < \u03b1\u03b8 and hence w \u03c6 x\u03b2+1\n\u2265 \u03b8/3. Two other groups of similar examples (the first with x\u03b2+3 = x\u03b2+4 = 1, the second with x\u03b2+5 = x\u03b2+6 = 1) cause w\u03c6x\u03b2+3 \u2265 \u03b8/3 and w \u03c6 x\u03b2+5\n\u2265 \u03b8/3. The next example in S is the negative example which has xi1 = xi2 = 0, xi = 1 for all other xi in A, x\u03b2+1 = x\u03b2+3 = x\u03b2+5 = 1 and all other bits 0. For this example w\u03c6 \u00b7 \u03c6(x) > w\u03c6x\u03b2+1 + w \u03c6 x\u03b2+3\n+ w\u03c6x\u03b2+5 \u2265 \u03b8 so Winnow makes a false positive prediction.\nSince F has at most n2 clauses and there are V negative examples per clause, this construction can be carried out using 6V n2 slack variables xn+U+1, . . . , xn+U+6V n2 . We thus have (1) and (2) as claimed above.\nStage 2: Setting MA \u2248 \u03b1 q|F \u22121(1)|. The first Stage 2 example is a positive example with xi = 1 for all xi \u2208 A, xn+U+6V n2+1 = 1 and all other bits 0. Since each of the 2 n monomials which contain xn+U+6V n2+1 and are satisfied by this example have w \u03c6 T = 1, we have w\u03c6 \u00b7 \u03c6(x) = 2n + |F\u22121(1)| + \u03b31 < 2 n+1. Since \u03b8 > 2m/poly(m) > 2n+1 (recall from equation (2) that m > 6n2), after the resulting promotion we have w\u03c6 \u00b7 \u03c6(x) = \u03b1(2n + |F\u22121(1)| + \u03b31) < \u03b12 n+1. Let\nq = \u2308log\u03b1(\u03b8/2 n+1)\u2309 \u2212 1\nso that\n\u03b1q2n+1 < \u03b8 \u2264 \u03b1q+12n+1. (3)\nStage 2 consists of q repeated instances of the positive example described above. After these promotions we have w\u03c6 \u00b7 \u03c6(x) = \u03b1q(2n + |F\u22121(1)| + \u03b31) < \u03b1\nq2n+1 < \u03b8. Since 1 < |F\u22121(1)| + \u03b31 < 2 n we also have\n\u03b1q < MA = \u03b1 q(|F\u22121(1)| + \u03b31) < \u03b1 q2n < \u03b8/2. (4)\nEquation (4) gives the value which MA will have throughout the rest of the argument.\nSome Calculations for Stages 3 and 4. At the start of Stage 3 each type-B and typeAB monomial T has w\u03c6T = 1. There are n variables in A and U variables in B so at the start of Stage 3 we have MB = 2 U \u2212 1 and MAB = (2 n \u2212 1)(2U \u2212 1). Since no example in Stages 3 or 4 satisfies any xi in A, at the end of Stage 4 MA will still be \u03b1 q(|F\u22121(1)| + \u03b31) and MAB will still be (2 n \u2212 1)(2U \u2212 1). Therefore at the end of Stage 4 we have\nw\u03c6 \u00b7 \u03c6(z) = MB + \u03b1 q(|F\u22121(1)| + \u03b31) + (2 n \u2212 1)(2U \u2212 1).\nTo simplify notation let\nD = \u03b8 \u2212 (2n \u2212 1)(2U \u2212 1) \u2212 \u03b1qK.\nIdeally at the end of Stage 4 the value of MB would be D\u2212\u03b1 q\u03b31 since this would imply that w\u03c6 \u00b7\u03c6(z) = \u03b8+\u03b1q(|F\u22121(1)| \u2212K) which is at least \u03b8 if and only if |F\u22121(1)| \u2265 K. However it is not necessary for MB to assume this exact value, since |F\n\u22121(1)| must be an integer and 0 < \u03b31 < 1 2 . As long as\nD \u2264 MB < D + 1\n2 \u03b1q (5)\nwe get that\n\u03b8 + \u03b1q(|F\u22121(1)| \u2212K + \u03b31) < w \u03c6 \u00b7 \u03c6(z) < \u03b8 + \u03b1q(|F\u22121(1)| \u2212K + \u03b31 +\n1 2 ).\nNow if |F\u22121(1)| \u2265 K we clearly have w\u03c6 \u00b7 \u03c6(z) \u2265 \u03b8. On the other hand if |F\u22121(1)| < K then since |F\u22121(1)| is an integer value |F\u22121(1)| \u2264 K\u22121 and we get w\u03c6 \u00b7\u03c6(z) < \u03b8. Therefore all that remains is to construct the examples in Stages 3 and 4 so that that MB satisfies Equation (5).\nWe next calculate an appropriate granularity for D. Note that K \u2264 2n, so by Equation (3) we have that \u03b8 \u2212 \u03b1qK > \u03b8/2. Now recall from Equations (2) and (1) that m > n + U + 6n2 and \u03b8 > 2m/poly(m), so \u03b8/2 \u2265 2n+U+6n 2\n/poly(m) \u226b 2n2U . Consequently we certainly have that D > \u03b8/4, and from Equation (3) we have that D > \u03b8/4 > \u03b1q2n\u22121 > 14\u03b1\nq. Let\nc = \u2308log\u03b1 4\u2309,\nso that we have\n\u03b1q\u2212c \u2264 1\n4 \u03b1q < D. (6)\nThere is a unique smallest positive integer p > 1 which satisfies D \u2264 p\u03b1q\u2212c < D+ 14\u03b1 q. The Stage 3 examples will result in MB satisfying p < MB < p + 1 4 . We now have that:\n\u03b1q\u2212c < D \u2264 p\u03b1q\u2212c < D + 1\n4 \u03b1q\n\u2264 \u03b8 \u2212 3\n4 \u03b1q (7)\n\u2264 \u03b1q+12n+1 \u2212 3\u03b1q\u2212c (8) = \u03b1q\u2212c \u00b7 (\u03b1c+12n+1 \u2212 3). (9)\nHere (7) holds since K \u2265 1, and thus (by definition of D) we have D + \u03b1q \u2264 \u03b8 which is equivalent to Equation (7). Inequality (8) follows from Equations (6) and (3).\nHence we have that\n1 < p \u2264 \u03b1c+12n+1 \u2212 3 \u2264 2n+1+\u2308(c+1) log\u03b1\u2309 \u2212 3 = 2U \u2212 3, (10)\nwhere the second inequality in the above chain follows from Equation (9). We now use the following lemma:\nLemma 10 For all \u2113 \u2265 1, for all 1 \u2264 p \u2264 2\u2113 \u2212 1, there is a monotone CNF F\u2113,p over \u2113 Boolean variables which has at most \u2113 clauses, has exactly p satisfying assignments in {0, 1}\u2113, and can be constructed from \u2113 and p in poly(\u2113) time.\nProof: The proof is by induction on \u2113. For the base case \u2113 = 1 we have p = 1 and F\u2113,p = x1. Assuming the lemma is true for \u2113 = 1, . . . , k we now prove it for \u2113 = k + 1 :\nIf 1 \u2264 p \u2264 2k \u2212 1 then the desired CNF is Fk+1,p = xk+1 \u2227Fk,p. Since Fk,p has at most k clauses Fk+1,p has at most k + 1 clauses. If 2\nk + 1 \u2264 p \u2264 2k+1 \u2212 1 then the desired CNF is Fk+1,p = xk+1 \u2228Fk,p\u22122k . By distributing xk over each clause of Fk,p\u22122k we can write Fk+1,p as a CNF with at most k clauses. If p = 2k then Fk,p = x1. \u2737\nStage 3: Setting MB \u2248 p. Let FU,p be an r-clause monotone CNF formula over the U variables in B which has p satisfying assignments. Similar to Stage 1, for each clause of FU,p, Stage 3 has W negative examples corresponding to that clause, and as in Stage 1 slack variables in C are used to ensure that Winnow makes a false positive prediction on each such negative example. Thus the examples in Stage 3 cause MB = p + \u03b32 where 0 < \u03b32 < 2\nU\u03b1\u2212W < 14 . Since six slack variables in C are used for each negative example and there are rW \u2264 UW negative examples, the slack variables xn+U+6V n2+2, . . . , xm\u22122 are sufficient for Stage 3.\nStage 4: Setting MB + MAB \u2248 \u03b8 \u2212 \u03b1 qK. All that remains is to perform q \u2212 c promotions on examples which have each xi in B set to 1. This will cause MB to equal (p + \u03b32)\u03b1 q\u2212c. By the inequalities established above, this will give us\nD \u2264 p\u03b1q\u2212c < (p + \u03b32)\u03b1 q\u2212c = MB < D +\n1 4 \u03b1q + \u03b32\u03b1 q\u2212c < D + 1 2 \u03b1q\nwhich is as desired.\nIn order to guarantee q \u2212 c promotions we use two sequences of examples of length q \u2212 \u2308U\u2212nlog\u03b1 \u2309 and \u2308 U\u2212n log\u03b1 \u2309 \u2212 c respectively. We first show that these are positive numbers. It follows directly from the definitions U = n + 1 + \u2308(\u2308log\u03b1 4\u2309 + 1) log\u03b1\u2309 and c = \u2308log\u03b1 4\u2309 that U\u2212nlog\u03b1 \u2265 c. Since \u03b8 > 2 6n2 (by definition of m and Equation (1)) and \u03b1 is bounded by a polynomial in m, we clearly have that log(\u03b8/2n+1) > U \u2212 n + log(\u03b1). Now since q = \u2308log\u03b1(\u03b8/2 n+1)\u2309\u22121 this implies that q > log(\u03b8/2 n+1) log(\u03b1) \u22121 > \u2308 U\u2212n log\u03b1 \u2309, so that q\u2212\u2308 U\u2212n log\u03b1\u2309 > 0.\nThe first q \u2212 \u2308U\u2212nlog\u03b1 \u2309 examples in Stage 4 are all the same positive example which has each xi in B set to 1 and xm\u22121 = 1. The first time this example is received, we have w\u03c6 \u00b7 \u03c6(x) = 2U + p + \u03b32 < 2 U+1. Since \u03b8 > 26n 2\n, by inspection of U we have 2U+1 < \u03b8, so Winnow performs a promotion. Similarly, after q \u2212 \u2308U\u2212nlog\u03b1 \u2309 occurrences of this example, we have\nw\u03c6 \u00b7 \u03c6(x) = \u03b1q\u2212\u2308 U\u2212n log \u03b1 \u2309 (2U + p + \u03b32) < \u03b1 q\u2212\u2308U\u2212n log \u03b1 \u2309 2U+1 \u2264 \u03b1q2n+1 < \u03b8\nso promotions are indeed performed at each occurrence, and\nMB = \u03b1 q\u2212\u2308U\u2212n log \u03b1 \u2309 (p + \u03b32).\nThe remaining examples in Stage 4 are \u2308U\u2212nlog\u03b1\u2309 \u2212 c repetitions of the positive example x which has each xi in B set to 1 and xm = 1. If promotions occurred on each repetition of\nthis example then we would have w\u03c6 \u00b7\u03c6(x) = \u03b1\u2308 U\u2212n log \u03b1 \u2309\u2212c (2U +\u03b1 q\u2212\u2308U\u2212n log \u03b1 \u2309 (p+ \u03b32)), so we need only show that this quantity is less than \u03b8. We reexpress this quantity as \u03b1 \u2308U\u2212n log \u03b1 \u2309\u2212c\n2U + \u03b1q\u2212c(p + \u03b32). We have\n\u03b1q\u2212c(p + \u03b32) < p\u03b1 q\u2212c +\n1 4 \u03b1q\u2212c\n\u2264 \u03b8 \u2212 3\n4 \u03b1q +\n1\n16 \u03b1q (11)\n< \u03b8 \u2212 1\n2 \u03b1q\nwhere (11) follows from (7) and the definition of c. Finally, we have that \u03b1 \u2308U\u2212n log \u03b1 \u2309\u2212c\n2U \u2264 \u03b1 \u00b722U\u2212n\u2212c log\u03b1 < \u03b1 \u00b722U\u2212n\u22122 < 12\u03b1 \u03b8 2n+1 < 12\u03b1 q, where the last inequality is by Equation (3) and the previous inequality is by inspection of the values of \u03b1, \u03b8 and U . Combining the two bounds above we see that indeed w\u03c6 \u00b7 \u03c6(x) < \u03b8.\nFinally, we observe that by construction the example sequence S is monotone consistent. Since m = poly(n) and S contains poly(n) examples the transformation from M2SAT to KWP(\u03b1, \u03b8) is polynomial-time computable and the theorem is proved. \u2737(Theorem 9)"}, {"heading": "5. Conclusion", "text": "Linear threshold functions are a weak representation language for which we have interesting learning algorithms. Therefore, if linear learning algorithms are to learn expressive functions, it is necessary to expand the feature space over which they are applied. This work explores the tradeoff between computational efficiency and convergence when using expanded feature spaces that capture conjunctions of base features.\nWe have shown that while each iteration of the kernel Perceptron algorithm can be executed efficiently, the algorithm can provably require exponentially many updates even when learning a function as simple as f(x) = x1x2 . . . xn. On the other hand, the kernel Winnow algorithm has a polynomial mistake bound for learning polynomial-size monotone DNF, but our results show that under a widely accepted computational hardness assumption it is impossible to efficiently simulate the execution of kernel Winnow. The latter also implies that there is no general construction that will run Winnow using kernel functions.\nOur results indicate that additive and multiplicative update algorithms lie on opposite extremes of the tradeoff between computational efficiency and convergence; we believe that this fact could have significant practical implications. By demonstrating the provable limitations of using kernel functions which correspond to high-degree feature expansions, our results also lend theoretical justification to the common practice of using a small degree in similar feature expansions such as the well-known polynomial kernel.2\nSince the publication of the initial conference version of this work (Khardon, Roth, & Servedio, 2002), several authors have explored closely related ideas. One can show that our construction for the negative results for Perceptron does not extend (either in the PAC or\n2. Our Boolean kernels are different than standard polynomial kernels in that all the conjunctions are weighted equally, and also in that we allow negations.\nonline setting) to related algorithms such as Support Vector Machines which work by constructing a maximum margin hypothesis consistent with the examples. The paper (Khardon & Servedio, 2003) gives an analysis of the PAC learning performance of maximum margin algorithms with the monotone monomials kernel, and derives several negative results thus giving further negative evidence for the monomial kernel. In the paper (Cumby & Roth, 2003) a kernel for expressions in description logic (generalizing the monomials kernel) is developed and successfully applied for natural language and molecular problems. Takimoto and Warmuth (2003) study the use of multiplicative update algorithms other than Winnow (such as weighted majority) and obtain some positive results by restricting the type of loss function used to be additive over base features. Chawla et al. (2004) have studied Monte Carlo estimation approaches to approximately simulate the Winnow algorithm\u2019s performance when run over a space of exponentially many features. The use of kernel methods for logic learning and developing alternative methods for feature expansion with multiplicative update algorithms remain interesting and challenging problems to be investigated."}, {"heading": "Acknowledgments", "text": "This work was partly done while Khardon was at the University of Edinburgh and partly while Servedio was at Harvard University. The authors gratefully acknowledge financial support for this work by EPSRC grant GR/N03167, NSF grant IIS-0099446 and a Research Semester Fellowship Award from Tufts University (Khardon), NSF grants ITR-IIS00-85836, ITR-IIS-0085980 and IIS-9984168 (Roth), and NSF grant CCR-98-77049 and NSF Mathematical Sciences Postdoctoral Fellowship (Servedio)."}], "references": [{"title": "Negative results for equivalence queries", "author": ["D. Angluin"], "venue": "Machine Learning, 2, 121\u2013150. Block, H. (1962). The perceptron: a model for brain functioning. Reviews of Modern", "citeRegEx": "Angluin,? 1990", "shortCiteRegEx": "Angluin", "year": 1990}, {"title": "The SNoW learning architecture", "author": ["A. Carlson", "C. Cumby", "J. Rosen", "D. Roth"], "venue": null, "citeRegEx": "Carlson et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Carlson et al\\.", "year": 1999}, {"title": "UIUCDCS-R-99-2101, UIUC Computer Science", "author": ["Tech. rep"], "venue": null, "citeRegEx": "rep.,? \\Q2004\\E", "shortCiteRegEx": "rep.", "year": 2004}, {"title": "On kernel methods for relational learning", "author": ["C. Cambridge Press. Cumby", "D. Roth"], "venue": null, "citeRegEx": "Cumby and Roth,? \\Q2003\\E", "shortCiteRegEx": "Cumby and Roth", "year": 2003}, {"title": "Efficiency versus convergence of Boolean kernels for on-line learning algorithms", "author": ["R. Khardon", "D. Roth", "R. Servedio"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Khardon et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Khardon et al\\.", "year": 2002}, {"title": "Maximum margin algorithms with Boolean kernels", "author": ["R. Khardon", "R. Servedio"], "venue": "In Proceedings of the Sixteenth Annual Conference on Computational Learning Theory,", "citeRegEx": "Khardon and Servedio,? \\Q2003\\E", "shortCiteRegEx": "Khardon and Servedio", "year": 2003}, {"title": "Introduction to Coding Theory", "author": ["J.V. Lint"], "venue": "Springer-Verlag.", "citeRegEx": "Lint,? 1992", "shortCiteRegEx": "Lint", "year": 1992}, {"title": "Learning quickly when irrelevant attributes abound: A new linearthreshold algorithm", "author": ["N. Littlestone"], "venue": "Machine Learning, 2, 285\u2013318.", "citeRegEx": "Littlestone,? 1988", "shortCiteRegEx": "Littlestone", "year": 1988}, {"title": "Efficient learning with virtual threshold gates", "author": ["W. Maass", "M.K. Warmuth"], "venue": "Information and Computation,", "citeRegEx": "Maass and Warmuth,? \\Q1998\\E", "shortCiteRegEx": "Maass and Warmuth", "year": 1998}, {"title": "Perceptrons: an introduction to computational geometry", "author": ["M. Minsky", "S. Papert"], "venue": null, "citeRegEx": "Minsky and Papert,? \\Q1968\\E", "shortCiteRegEx": "Minsky and Papert", "year": 1968}, {"title": "On convergence proofs for perceptrons", "author": ["A. Novikoff"], "venue": "Proceeding of the Symposium on the Mathematical Theory of Automata, Vol. 12, pp. 615\u2013622.", "citeRegEx": "Novikoff,? 1963", "shortCiteRegEx": "Novikoff", "year": 1963}, {"title": "Computational Complexity", "author": ["C. Papadimitriou"], "venue": "Addison-Wesley.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "The Perceptron: a probabilistic model for information storage and organization in the brain", "author": ["F. Rosenblatt"], "venue": "Psychological Review, 65, 386\u2013407.", "citeRegEx": "Rosenblatt,? 1958", "shortCiteRegEx": "Rosenblatt", "year": 1958}, {"title": "Learning to resolve natural language ambiguities: A unified approach", "author": ["D. Roth"], "venue": "Proc. of the American Association of Artificial Intelligence, pp. 806\u2013813.", "citeRegEx": "Roth,? 1998", "shortCiteRegEx": "Roth", "year": 1998}, {"title": "Learning of Boolean functions using support vector machines", "author": ["K. Sadohara"], "venue": "Proc. of the Conference on Algorithmic Learning Theory, pp. 106\u2013118. Springer. LNAI 2225.", "citeRegEx": "Sadohara,? 2001", "shortCiteRegEx": "Sadohara", "year": 2001}, {"title": "Path kernels and multiplicative updates", "author": ["E. Takimoto", "M. Warmuth"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Takimoto and Warmuth,? \\Q2003\\E", "shortCiteRegEx": "Takimoto and Warmuth", "year": 2003}, {"title": "The complexity of enumeration and reliability problems", "author": ["L.G. Valiant"], "venue": "SIAM Journal of Computing, 8, 410\u2013421.", "citeRegEx": "Valiant,? 1979", "shortCiteRegEx": "Valiant", "year": 1979}, {"title": "A theory of the learnable", "author": ["L.G. Valiant"], "venue": "Communications of the ACM, 27 (11), 1134\u20131142.", "citeRegEx": "Valiant,? 1984", "shortCiteRegEx": "Valiant", "year": 1984}, {"title": "Kernels from matching operations", "author": ["C. Watkins"], "venue": "Tech. rep. CSD-TR-98-07, Computer Science Department, Royal Holloway, University of London. 356", "citeRegEx": "Watkins,? 1999", "shortCiteRegEx": "Watkins", "year": 1999}], "referenceMentions": [{"referenceID": 12, "context": "Of particular interest in this paper are the well known Perceptron (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) and Winnow (Littlestone, 1988) algorithms that have been intensively studied in the literature.", "startOffset": 67, "endOffset": 114}, {"referenceID": 10, "context": "Of particular interest in this paper are the well known Perceptron (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) and Winnow (Littlestone, 1988) algorithms that have been intensively studied in the literature.", "startOffset": 67, "endOffset": 114}, {"referenceID": 7, "context": "Of particular interest in this paper are the well known Perceptron (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) and Winnow (Littlestone, 1988) algorithms that have been intensively studied in the literature.", "startOffset": 126, "endOffset": 145}, {"referenceID": 13, "context": "As one example, the SNoW system (Roth, 1998; Carlson, Cumby, Rosen, & Roth, 1999) has successfully applied variations of Perceptron and Winnow to problems in natural language processing.", "startOffset": 32, "endOffset": 81}, {"referenceID": 2, "context": "A common representation for classifiers in this case is a hyperplane of dimension (n \u2212 1) which splits the domain of examples into two areas of positive and negative examples. Such a representation is known as a linear threshold function, and many learning algorithms that output a hypothesis represented in this manner have been developed, analyzed, implemented, and applied in practice. Of particular interest in this paper are the well known Perceptron (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) and Winnow (Littlestone, 1988) algorithms that have been intensively studied in the literature. It is also well known that the expressiveness of linear threshold functions is quite limited (Minsky & Papert, 1968). Despite this fact, both Perceptron and Winnow have been applied successfully in recent years to several large scale real world classification problems. As one example, the SNoW system (Roth, 1998; Carlson, Cumby, Rosen, & Roth, 1999) has successfully applied variations of Perceptron and Winnow to problems in natural language processing. The SNoW system extracts basic Boolean features x1, . . . , xn from labeled pieces of text data in order to represent the examples, thus the features have numerical values restricted to {0, 1}. There are several ways to enhance the set of basic features x1, . . . , xn for Perceptron or Winnow. One idea is to expand the set of basic features x1, . . . , xn using conjunctions such as (x1\u2227x3\u2227x4) and use these expanded higher-dimensional examples, in which each conjunction plays the role of a basic feature, as the examples for Perceptron or Winnow. This is in fact the approach which the SNoW system takes running Perceptron or Winnow over a space of restricted conjunctions of these basic features. This idea is closely related to the use of kernel methods, see e.g. the book of Cristianini and Shawe-Taylor (2000), where a feature expansion is done implicitly through the kernel function.", "startOffset": 9, "endOffset": 1875}, {"referenceID": 7, "context": "Before describing our results, we recall some necessary background on the on-line learning model (Littlestone, 1988) and the Perceptron and Winnow algorithms.", "startOffset": 97, "endOffset": 116}, {"referenceID": 12, "context": "The famous Perceptron Convergence Theorem (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) bounds the number of mistakes which the Perceptron algorithm can make:", "startOffset": 42, "endOffset": 89}, {"referenceID": 10, "context": "The famous Perceptron Convergence Theorem (Rosenblatt, 1958; Block, 1962; Novikoff, 1963) bounds the number of mistakes which the Perceptron algorithm can make:", "startOffset": 42, "endOffset": 89}, {"referenceID": 7, "context": "The Winnow algorithm (Littlestone, 1988) has a very similar structure.", "startOffset": 21, "endOffset": 40}, {"referenceID": 7, "context": "The Winnow algorithm (Littlestone, 1988) has a very similar structure. Winnow maintains a hypothesis vector w \u2208 RN which is initially w = (1, . . . , 1). Winnow is parameterized by a promotion factor \u03b1 > 1 and a threshold \u03b8 > 0; upon receiving an example x \u2208 {0, 1}N Winnow predicts according to the threshold function w \u00b7x \u2265 \u03b8. If the prediction is 1 and the label is \u22121 then for all i such that xi = 1 the value of wi is set to wi/\u03b1; this is a demotion step. If the prediction is \u22121 and the label is 1 then for all i such that xi = 1 the value of wi is set to \u03b1wi; this is a promotion step. No change is made to w if the prediction is correct. For our purposes the following mistake bound, implicit in Littlestone\u2019s work (1988), is of interest:", "startOffset": 22, "endOffset": 730}, {"referenceID": 18, "context": "Our first result (cf. also the papers of Sadohara, 1991; Watkins, 1999; and Kowalczyk et al., 2001) uses kernel functions to show that it is possible to efficiently run the kernel Perceptron algorithm over an exponential number of conjunctive features.", "startOffset": 17, "endOffset": 99}, {"referenceID": 17, "context": "We also give a variant of this result showing that kernel Perceptron fails in the Probably Approximately Correct (PAC) learning model (Valiant, 1984) as well.", "startOffset": 134, "endOffset": 149}, {"referenceID": 0, "context": "Angluin (1990) proved that DNF expressions cannot be learned efficiently using equivalence queries whose hypotheses are themselves DNF expressions.", "startOffset": 0, "endOffset": 15}, {"referenceID": 14, "context": "This kernel has been obtained independently by Sadohara (2001). To express all monotone monomials as in (2) we take K(x, y) = 2|x\u2229y| where |x \u2229 y| is the number of active features common to both x and y, i.", "startOffset": 47, "endOffset": 63}, {"referenceID": 2, "context": "This kernel is reported also by Watkins (1999). For case (4) we have K(x, y) = \u2211k l=0 (|x\u2229y| l )", "startOffset": 15, "endOffset": 47}, {"referenceID": 6, "context": "5 of the book by Van Lint (1992), there can be at most 20.", "startOffset": 21, "endOffset": 33}, {"referenceID": 17, "context": "The proof above can be adapted to give a negative result for kernel Perceptron in the PAC learning model (Valiant, 1984).", "startOffset": 105, "endOffset": 120}, {"referenceID": 16, "context": "The proof above can be adapted to give a negative result for kernel Perceptron in the PAC learning model (Valiant, 1984). In this model each example x is independently drawn from a fixed probability distribution D and with high probability the learner must construct a hypothesis h which has high accuracy relative to the target concept c under distribution D. See the Kearns-Vazirani text (1994) for a detailed discussion of the PAC learning model.", "startOffset": 106, "endOffset": 397}, {"referenceID": 16, "context": "The following problem is #P-hard (Valiant, 1979):", "startOffset": 33, "endOffset": 48}, {"referenceID": 11, "context": "See the book of Papadimitriou (1994) or the paper of Valiant (1979) for details on #P.", "startOffset": 16, "endOffset": 37}, {"referenceID": 11, "context": "See the book of Papadimitriou (1994) or the paper of Valiant (1979) for details on #P.", "startOffset": 16, "endOffset": 68}, {"referenceID": 13, "context": "In the paper (Cumby & Roth, 2003) a kernel for expressions in description logic (generalizing the monomials kernel) is developed and successfully applied for natural language and molecular problems. Takimoto and Warmuth (2003) study the use of multiplicative update algorithms other than Winnow (such as weighted majority) and obtain some positive results by restricting the type of loss function used to be additive over base features.", "startOffset": 22, "endOffset": 227}, {"referenceID": 13, "context": "In the paper (Cumby & Roth, 2003) a kernel for expressions in description logic (generalizing the monomials kernel) is developed and successfully applied for natural language and molecular problems. Takimoto and Warmuth (2003) study the use of multiplicative update algorithms other than Winnow (such as weighted majority) and obtain some positive results by restricting the type of loss function used to be additive over base features. Chawla et al. (2004) have studied Monte Carlo estimation approaches to approximately simulate the Winnow algorithm\u2019s performance when run over a space of exponentially many features.", "startOffset": 22, "endOffset": 458}], "year": 2011, "abstractText": "The paper studies machine learning problems where each example is described using a set of Boolean features and where hypotheses are represented by linear threshold elements. One method of increasing the expressiveness of learned hypotheses in this context is to expand the feature set to include conjunctions of basic features. This can be done explicitly or where possible by using a kernel function. Focusing on the well known Perceptron and Winnow algorithms, the paper demonstrates a tradeoff between the computational efficiency with which the algorithm can be run over the expanded feature space and the generalization ability of the corresponding learning algorithm. We first describe several kernel functions which capture either limited forms of conjunctions or all conjunctions. We show that these kernels can be used to efficiently run the Perceptron algorithm over a feature space of exponentially many conjunctions; however we also show that using such kernels, the Perceptron algorithm can provably make an exponential number of mistakes even when learning simple functions. We then consider the question of whether kernel functions can analogously be used to run the multiplicative-update Winnow algorithm over an expanded feature space of exponentially many conjunctions. Known upper bounds imply that the Winnow algorithm can learn Disjunctive Normal Form (DNF) formulae with a polynomial mistake bound in this setting. However, we prove that it is computationally hard to simulate Winnow\u2019s behavior for learning DNF over such a feature set. This implies that the kernel functions which correspond to running Winnow for this problem are not efficiently computable, and that there is no general construction that can run Winnow with kernels.", "creator": "dvips(k) 5.86 Copyright 1999 Radical Eye Software"}}}