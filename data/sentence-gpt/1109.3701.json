{"id": "1109.3701", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Sep-2011", "title": "Active Ranking using Pairwise Comparisons", "abstract": "This paper examines the problem of ranking a collection of objects using pairwise comparisons (rankings of two objects). In general, the ranking of $n$ objects can be identified by standard sorting methods using $n log_2 n$ pairwise comparisons. We are interested in natural situations in which relationships among the objects may allow for ranking using far fewer pairwise comparisons than the average number of items available to the object. This paper considers the use of $n$ items in the ranking system with a large-scale approach to ranking a collection of objects with greater than a single object.\n\n\n\n\nThe main question asked is is the extent to which all objects can be ranked, if only through a sort of filter that is similar to that applied in the classical list classification system:\nAs in most systems, the ranking algorithm, which has only a few parameters (like a set of properties for each object, and of which there are no constraints to its ranking), is restricted to all of the objects, all those that are ranked with or without a few conditions. The method that takes a few parameters is called the ranking algorithm (the rank is its own value in terms of the total number of objects that are ranked. For the list of objects, the rank is its own value in terms of the number of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the list of objects that are ranked, and for the", "histories": [["v1", "Fri, 16 Sep 2011 19:35:13 GMT  (212kb,D)", "http://arxiv.org/abs/1109.3701v1", "13 pages, an extended version of our accepted paper with the same title that will appear at NIPS 2011"], ["v2", "Sat, 10 Dec 2011 01:02:14 GMT  (216kb,D)", "http://arxiv.org/abs/1109.3701v2", "17 pages, an extended version of our NIPS 2011 paper. The new version revises the argument of the robust section and slightly modifies the result there to give it more impact"]], "COMMENTS": "13 pages, an extended version of our accepted paper with the same title that will appear at NIPS 2011", "reviews": [], "SUBJECTS": "cs.LG cs.IT math.IT stat.ML", "authors": ["kevin g jamieson", "robert d nowak"], "accepted": true, "id": "1109.3701"}, "pdf": {"name": "1109.3701.pdf", "metadata": {"source": "CRF", "title": "Active Ranking using Pairwise Comparisons", "authors": ["Kevin G. Jamieson", "Robert D. Nowak"], "emails": ["kgjamieson@wisc.edu", "nowak@engr.wisc.edu"], "sections": [{"heading": "1 Introduction", "text": "This paper addresses the problem of ranking a set of objects based on a limited number of pairwise comparisons (rankings between pairs of the objects). A ranking over a set of n objects \u0398 = (\u03b81, \u03b82, . . . , \u03b8n) is a mapping \u03c3 : {1, . . . , n} \u2192 {1, . . . , n} that prescribes an order\n\u03c3(\u0398) := \u03b8\u03c3(1) \u227a \u03b8\u03c3(2) \u227a \u00b7 \u00b7 \u00b7 \u227a \u03b8\u03c3(n\u22121) \u227a \u03b8\u03c3(n) (1) where \u03b8i \u227a \u03b8j means \u03b8i precedes \u03b8j in the ranking. A ranking uniquely determines the collection of pairwise comparisons between all pairs of objects. The primary objective here is to bound the number of pairwise comparisons needed to correctly determine the ranking when the objects (and hence rankings) satisfy certain known structural constraints. Specifically, we suppose that the objects may be embedded into a low-dimensional Euclidean space such that the ranking is consistent with distances in the space. We wish to exploit such structure in order to discover the ranking using a very small number of pairwise comparisons. To the best of our knowledge, this is a previously open and unsolved problem.\nThere are practical and theoretical motivations for restricting our attention to pairwise rankings that are discussed in Section 2. We begin by assuming that every pairwise comparison is consistent with an unknown ranking. Each pairwise comparison can be viewed as a query: is \u03b8i before \u03b8j? Each query provides 1 bit of information about the underlying ranking. Since the number of rankings is n!, in general, specifying a ranking requires \u0398(n log n) bits of information. This implies that at least this many pairwise comparisons are required without additional assumptions about the ranking. In fact, this lower bound can be achieved with a standard adaptive sorting algorithm like binary sort [1]. In large-scale problems or when humans are queried for pairwise comparisons, obtaining this many pairwise comparisons may be impractical and therefore we consider situations in which the space of rankings is structured and thereby less complex.\nar X\niv :1\n10 9.\n37 01\nv1 [\ncs .L\nG ]\n1 6\nSe p\n20 11\nA natural way to induce a structure on the space of rankings is to suppose that the objects can be embedded into a d-dimensional Euclidean space so that the distances between objects are consistent with the ranking. This may be a reasonable assumption in many applications, and for instance the audio dataset used in our experiments is believed to have a 2 or 3 dimensional embedding [2]. We further discuss motivations for this assumption in Section 2. It is not difficult to show (see Section 3) that the number of full rankings that could arise from n objects embedded in Rd grows like n2d, and so specifying a ranking from this class requires only O(d log n) bits. The main results of the paper show that under this assumption a randomly selected ranking can be determined using O(d log n) pairwise comparisons selected in an adaptive and sequential fashion, but almost all ( n 2 ) pairwise rankings are needed if they are picked randomly rather than selectively. In other words, actively selecting the most informative queries has a tremendous impact on the complexity of learning the correct ranking."}, {"heading": "1.1 Problem statement", "text": "Let \u03c3 denote the ranking to be learned. The objective is to learn the ranking by querying the reference for pairwise comparisons of the form\nqi,j := {\u03b8i \u227a \u03b8j}. (2) The response or label of qi,j is binary and denoted as yi,j := 1{qi,j} where 1 is the indicator function; ties are not allowed. The main results quantify the minimum number of queries or labels required to determine the reference\u2019s ranking, and they are based on two key assumptions.\nA1 Embedding: The set of n objects are embedded in Rd (in general position) and we will also use \u03b81, . . . , \u03b8n to refer to their (known) locations in Rd. Every ranking \u03c3 can be specified by a reference point r\u03c3 \u2208 Rd, as follows. The Euclidean distances between the reference and objects are consistent with the ranking in the following sense: if the \u03c3 ranks \u03b8i \u227a \u03b8j , then \u2016\u03b8i \u2212 r\u03c3\u2016 < \u2016\u03b8j \u2212 r\u03c3\u2016. Let \u03a3n,d denote the set of all possible rankings of the n objects that satisfy this embedding condition.\nThe interpretation of this assumption is that we know how the objects are related (in the embedding), which limits the space of possible rankings. The ranking to be learned, specified by the reference (e.g., preferences of a human subject), is unknown. Many have studied the problem of finding an embedding of objects from data [3, 4, 5]. This is not the focus here, but it could certainly play a supporting role in our methodology (e.g., the embedding could be determined from known similarities between the n objects, as is done in our experiments with the audio dataset). We assume the embedding is given and our interest is minimizing the number of queries needed to learn the ranking, and for this we require a second assumption.\nA2 Consistency: Every pairwise comparison is consistent with the ranking to be learned. That is, if the reference ranks \u03b8i \u227a \u03b8j , then \u03b8i must precede \u03b8j in the (full) ranking. As we will discuss later in Section 3.2, these two assumptions alone are not enough to rule out pathological arrangements of objects in the embedding for which at least \u2126(n) queries must be made to recover the ranking. However, because such situations are not representative of what is typically encountered, we analyze the problem in the framework of the average-case analysis [6]. Definition 1. With each ranking \u03c3 \u2208 \u03a3n,d we associate a probability \u03c0\u03c3 such that \u2211 \u03c3\u2208\u03a3n,d \u03c0\u03c3 = 1. Let \u03c0 denote these probabilities and write \u03c3 \u223c \u03c0 for shorthand. The uniform distribution corresponds to \u03c0\u03c3 = |\u03a3n,d|\u22121 for all \u03c3 \u2208 \u03a3n,d, and we write \u03c3 \u223c U for this special case. Definition 2. If Mn(\u03c3) denotes the number of pairwise comparisons requested by an algorithm to identify the ranking \u03c3, then the average query complexity with respect to \u03c0 is denoted by E\u03c0[Mn]. The main results are proven for the special case of \u03c0 = U , the uniform distribution, to make the analysis more transparent and intuitive. However the results can easily be extended to general distributions \u03c0 that satisfy certain mild conditions (see Appendix A.5). All results henceforth, unless otherwise noted, will be given in terms of (uniform) average query complexity and we will say such results hold \u201con average.\u201d\nOur main results can be summarized as follows. If the queries are chosen deterministically or randomly in advance of collecting the corresponding pairwise comparisons, then we show that almost all ( n 2 ) pairwise comparisons queries are needed to identify a ranking under the assumptions above. However, if the queries are selected in an adaptive and sequential fashion according to the algorithm\nin Figure 1, then we show that the number of pairwise rankings required to identify a ranking is no more than a constant multiple of d log n, on average. The algorithm requests a query if and only if the corresponding pairwise ranking is ambiguous (see Section 4.2), meaning that it cannot be determined from previously collected pairwise comparisons and the locations of the objects in Rd. The efficiency of the algorithm is due to the fact that most of the queries are unambiguous when considered in a sequential fashion. For this very same reason, picking queries in a non-adaptive or random fashion is very inefficient. It is also noteworthy that the algorithm is also computationally efficient with an overall complexity no greater than O(n poly(d) poly(log n)) (see Appendix A.1). In Section 5 we present a robust version of the algorithm of Figure 1 that is tolerant to a fraction of errors in the pairwise comparison queries. In the case of persistent errors (see Section 5) we show that at least O(n/ log n) objects can be correctly ranked in a partial ranking with high probability by requesting just O(d log2 n) pairwise comparisons. This allows us to handle situations in which either or both of the assumptions, A1 and A2, are reasonable approximations to the situation at hand, but do not hold strictly (which is the case in our experiments with the audio dataset).\nProving the main results involves an uncommon marriage of ideas from the ranking and statistical learning literatures. Geometrical interpretations of our problem derive from the seminal works of [7] in ranking and [8] in learning. From this perspective our problem bears a strong resemblance to the halfspace learning problem, with two crucial distinctions. In the ranking problem, the underlying halfspaces are not in general position and have strong dependencies with each other. These dependencies invalidate many of the typical analyses of such problems [9, 10]. One popular method of analysis in exact learning involves the use of something called the extended teaching dimension [11]. However, because of the possible pathological situations alluded to earlier, it is easy to show that the extended teaching dimension must be at least \u2126(n) making that sort of worst-case analysis uninteresting. These differences present unique challenges to learning."}, {"heading": "2 Motivation and related work", "text": "The problem of learning a ranking from few pairwise comparisons is motivated by what we perceive as a significant gap in the theory of ranking and permutation learning. Most work in ranking assumes a passive approach to learning; pairwise comparisons or partial rankings are collected in a random or non-adaptive fashion and then aggregated to obtain a full ranking (cf. [12, 13, 14, 15]). However, this may be quite inefficient in terms of the number of pairwise comparisons or partial rankings needed to learn the (full) ranking. This inefficiency was recently noted in the related area of social choice theory [16]. Furthermore, empirical evidence suggests that, even under complex ranking models, adaptively selecting pairwise comparisons can reduce the number needed to learn the ranking [17]. It is cause for concern since in many applications it is expensive and time-consuming to obtain pairwise comparisons. For example, psychologists and market researchers collect pairwise comparisons to gauge human preferences over a set of objects, for scientific understanding or product placement. The scope of these experiments is often very limited simply due to the time and expense required\nto collect the data. This suggests the consideration of more selective and judicious approaches to gathering inputs for ranking. We are interested in taking advantage of underlying structure in the set of objects in order to choose more informative pairwise comparison queries. From a learning perspective, our work adds an active learning component to a problem domain that has primarily been treated from a passive learning mindset.\nWe focus on pairwise comparison queries for two reasons. First, pairwise comparisons admit a halfspace representation in embedding spaces which allows for a geometrical approach to learning in such structured ranking spaces. Second, pairwise comparisons are the most common form of queries in many applications, especially those involving human subjects. For example, consider the problem of finding the most highly ranked object, as illustrated by the following familiar task. Suppose a patient needs a new pair of prescription eye lenses. Faced with literally millions of possible prescriptions, the doctor will present candidate prescriptions in a sequential fashion followed by the query: better or worse? Even if certain queries are repeated to account for possible inaccurate answers, the doctor can locate an accurate prescription with just a handful of queries. This is possible presumably because the doctor understands (at least intuitively) the intrinsic space of prescriptions and can efficiently search through it using only binary responses from the patient.\nWe assume that the objects can be embedded in Rd and that the distances between objects and the reference are consistent with the ranking (Assumption A1). The problem of learning a general function f : Rd \u2192 R using just pairwise comparisons that correctly ranks the objects embedded in Rd has previously been studied in the passive setting [12, 13, 14, 15]. The main contributions of this paper are theoretical bounds for the specific case when f(x) = ||x \u2212 r\u03c3|| where r\u03c3 \u2208 Rd is the reference point. This is a standard model used in multidimensional unfolding and psychometrics [7, 18]. We are unaware of any existing query-complexity bounds for this problem. We do not assume a generative model is responsible for the relationship between rankings to embeddings, but one could. For example, the objects might have an embedding (in a feature space) and the ranking is generated by distances in this space. Or alternatively, structural constraints on the space of rankings could be used to generate a consistent embedding. Assumption A1, while arguably quite natural/reasonable in many situations, significantly constrains the set of possible rankings."}, {"heading": "3 Geometry of rankings from pairwise comparisons", "text": "The embedding assumption A1 gives rise to geometrical interpretations of the ranking problem, which are developed in this section. The pairwise comparison qi,j can be viewed as the membership query: is \u03b8i ranked before \u03b8j in the (full) ranking \u03c3? The geometrical interpretation is that qi,j requests whether the reference r\u03c3 is closer to object \u03b8i or object \u03b8j in Rd. Consider the line connecting \u03b8i and \u03b8j in Rd. The hyperplane that bisects this line and is orthogonal to it defines two halfspaces: one containing points closer to \u03b8i and the other the points closer to \u03b8j . Thus, qi,j is a membership query about which halfspace r\u03c3 is in, and there is an equivalence between each query, each pair of objects, and the corresponding bisecting hyperplane. The set of all possible pairwise comparison queries can be represented as ( n 2 ) distinct halfspaces in Rd. The intersections of these halfspaces partition Rd into a number of cells, and each one corresponds to a unique ranking of \u0398. Arbitrary rankings are not possible due to the embedding assumption A1, and recall that the set of rankings possible under A1 is denoted by \u03a3n,d. The cardinality of \u03a3n,d is equal to the number of cells in the partition. We will refer to these cells as d-cells (to indicate they are subsets in d-dimensional space) since at times we will also refer to lower dimensional cells; e.g., (d\u2212 1)-cells."}, {"heading": "3.1 Counting the number of possible rankings", "text": "The following lemma determines the cardinality of the set of rankings, \u03a3n,d, under assumption A1. Lemma 1. [7] Assume A1-2. LetQ(n, d) denote the number of d-cells defined by the hyperplane arrangement of pairwise comparisons between these objects (i.e. Q(n, d) = |\u03a3n,d|). Q(n, d) satisfies the recursion\nQ(n, d) = Q(n\u2212 1, d) + (n\u2212 1)Q(n\u2212 1, d\u2212 1) , where Q(1, d) = 1 and Q(n, 0) = 1. (3)\nIn the hyperplane arrangement induced by the n objects in d dimensions, each hyperplane is intersected by every other and is partitioned into Q(n\u2212 1, d\u2212 1) subsets or (d\u2212 1)-cells. The recursion,\nabove, arises by considering the addition of one object at a time. Using this lemma in a straightforward fashion, we prove the following corollary in Appendix A.2. Corollary 1. Assume A1-2. There exist positive real numbers k1 and k2 such that\nk1 n2d\n2dd! < Q(n, d) < k2\nn2d\n2dd! for n > d+ 1. If n \u2264 d+ 1 then Q(n, d) = n!. For n sufficiently large, k1 = 1 and k2 = 2 suffice."}, {"heading": "3.2 Lower bounds on query complexity", "text": "Since the cardinality of the set of possible rankings is |\u03a3n,d| = Q(n, d), we have a simple lower bound on the number of queries needed to determine the ranking. Theorem 1. Assume A1-2. To reconstruct an arbitrary ranking \u03c3 \u2208 \u03a3n,d any algorithm will require at least log2 |\u03a3n,d| = \u0398(2d log2 n) pairwise comparisons.\nProof. By Corollary 1 |\u03a3n,d| = \u0398(n2d), and so at least 2d log n bits are needed to specify a ranking. Each pairwise comparison provides at most one bit.\nIf each query provides a full bit of information about the ranking, then we achieve this lower bound. For example, in the one-dimensional case (d = 1) the objects can be ordered and binary search can be used to select pairwise comparison queries, achieving the lower bound. This is generally impossible in higher dimensions. Even in two dimensions there are placements of the objects (still in general position) that produce d-cells in the partition induced by queries that have n\u22121 faces (i.e., bounded by n \u2212 1 hyperplanes) as shown in Appendix A.3. It follows that the worst case situation may require at least n\u2212 1 queries in dimensions d \u2265 2. In light of this, we conclude that worst case bounds may be overly pessimistic indications of the typical situation, and so we instead consider the average case performance introduced in Section 1.1."}, {"heading": "3.3 Inefficiency of random queries", "text": "The geometrical representation of the ranking problem reveals that randomly choosing pairwise comparison queries is inefficient relative to the lower bound above. To see this, suppose m queries were chosen uniformly at random from the possible ( n 2 ) . The answers to m queries narrows the set of possible rankings to a d-cell in Rd. This d-cell may consist of one or more of the d-cells in the partition induced by all queries. If it contains more than one of the partition cells, then the underlying ranking is ambiguous. Theorem 2. Assume A1-2. Let N = ( n 2 ) . Suppose m pairwise comparison are chosen uniformly at\nrandom without replacement from the possible ( n 2 ) . Then for all positive integers N \u2265 m \u2265 d the\nprobability that the m queries yield a unique ranking is ( m d ) / ( N d ) \u2264 ( emN )d.\nProof. No fewer than d hyperplanes bound each d-cell in the partition of Rd induced by all possible queries. The probability of selecting d specific queries in a random draw of m is equal to(\nN \u2212 d m\u2212 d\n)/( N\nm\n) = ( m\nd\n)/( N\nd\n) \u2264 m d\nd!\ndd Nd \u2264 ( m N )d dd d! \u2264 ( em N )d .\nNote that ( m d ) / ( N d ) < 1/2 unless m = \u2126(n2). Therefore, if the queries are randomly chosen, then we will need to ask almost all queries to guarantee that the inferred ranking is probably correct."}, {"heading": "4 Analysis of sequential algorithm for query selection", "text": "Now consider the basic sequential process of the algorithm in Figure 1. Suppose we have ranked k \u2212 1 of the n objects. Call these objects 1 through k \u2212 1. This places the reference r\u03c3 within a d-cell (defined by the labels of the comparison queries between objects 1, . . . , k \u2212 1). Call this d-cell Ck\u22121. Now suppose we pick another object at random and call it object k. A comparison query between object k and one of objects 1, . . . , k \u2212 1 can only be informative (i.e., ambiguous) if the associated hyperplane intersects this d-cell Ck\u22121 (see Figure 2). If k is significantly larger than d, then it turns out that the cell Ck\u22121 is probably quite small and the probability that one of the queries intersects Ck\u22121 is very small; in fact the probability is on the order of 1/k2."}, {"heading": "4.1 Hyperplane-point duality", "text": "Consider a hyperplane h = (h0, h1, . . . , hd) with (d + 1) parameters in Rd and a point p = (p1, . . . , pd) \u2208 Rd that does not lie on the hyperplane. Checking which halfspace p falls in, i.e., h1p1 + h2p2 + \u00b7 \u00b7 \u00b7 + hdpd + h0 \u2277 0, has a dual interpretation: h is a point in Rd+1 and p is a hyperplane in Rd+1 passing through the origin (i.e., with d free parameters).\nRecall that each possible ranking can be represented by a reference point r\u03c3 \u2208 Rd. Our problem is to determine the ranking, or equivalently the vector of responses to the ( n 2 ) queries represented by hyperplanes in Rd. Using the above observation, we see that our problem is equivalent to finding a labeling over ( n 2 ) points in Rd+1 with as few queries as possible. We will refer to this alternative representation as the dual and the former as the primal."}, {"heading": "4.2 Characterization of an ambiguous query", "text": "The characterization of an ambiguous query has interpretations in both the primal and dual spaces. We will now describe the interpretation in the dual which will be critical to our analysis of the sequential algorithm of Figure 1. Definition 3. [8] Let S be a finite subset of Rd and let S+ \u2282 S be points labeled +1 and S\u2212 = S \\ S+ be the points labeled \u22121 and let x be any other point except the origin. If there exists two homogeneous linear separators of S+ and S\u2212 that assign different labels to the point x, then the label of x is said to be ambiguous with respect to S. Lemma 2. [8, Lemma 1] The label of x is ambiguous with respect to S if and only if S+ and S\u2212 are homogeneously linearly separable by a (d\u2212 1)-dimensional subspace containing x. Let us consider the implications of this lemma to our scenario. Assume that we have labels for all the pairwise comparisons of k \u2212 1 objects. Next consider a new object called object k. In the dual, the pairwise comparison between object k and object i, for some i \u2208 {1, . . . , k\u22121}, is ambiguous if and only if there exists a hyperplane that still separates the original points and also passes through this new point. In the primal, this separating hyperplane corresponds to a point lying on the hyperplane defined by the associated pairwise comparison."}, {"heading": "4.3 The probability that a query is ambiguous", "text": "An essential component of the sequential algorithm of Figure 1 is the initial random order of the objects; every sequence in which it could consider objects is equally probable. This allows us to state a nontrivial fact about the partial rankings of the first k objects observed in this sequence. Lemma 3. Assume A1-2 and \u03c3 \u223c U . Consider the subset S \u2282 \u0398 with |S| = k that is randomly selected from \u0398 such that all ( n k ) subsets are equally probable. If \u03a3k,d denotes the set of possible rankings of these k objects then every \u03c3 \u2208 \u03a3k,d is equally probable. Proof. Let a k-partition denote the partition of Rd into Q(k, d) d-cells induced by k objects for 1 \u2264 k \u2264 n. In the n-partition, each d-cell is weighted uniformly and is equal to 1/Q(n, d). If we uniformly at random select k objects from the possible n and consider the k-partition, each d-cell in the k-partition will contain one or more d-cells of the n-partition. If we select one of these d-cells from the k-partition, on average there will beQ(n, d)/Q(k, d) d-cells from the n-partition contained in this cell. Therefore the probability mass in each d-cell of the k-partition is equal to the number of cells from the n-partition in this cell multiplied by the probability of each of those cells from the n-partition: Q(n, d)/Q(k, d)\u00d7 1/Q(n, d) = 1/Q(k, d), and |\u03a3k,d| = Q(k, d).\nAs described above, for 1 \u2264 i \u2264 k some of the pairwise comparisons qi,k+1 may be ambiguous. The algorithm chooses a random sequence of the n objects in its initialization and does not use the labels of q1,k+1, . . . , qj\u22121,k+1, qj+1,k+1, . . . , qk,k+1 to make a determination of whether or not qj,k+1 is ambiguous. It follows that the events of requesting the label of qi,k+1 for i = 1, 2, . . . , k are independent and identically distributed (conditionally on the results of queries from previous steps). Therefore it makes sense to talk about the probability of requesting any one of them. Lemma 4. Assume A1-2 and \u03c3 \u223c U . Let A(k, d,U) denote the probability of the event that the pairwise comparison qi,k+1 is ambiguous for i = 1, 2, . . . , k. Then there exists positive, real number constants a1 and a2 independent of k such that for k > 2d, a1 2dk2 \u2264 A(k, d,U) \u2264 a2 2dk2 .\nProof. By Lemma 2, a point in the dual (pairwise comparison) is ambiguous if and only if there exists a separating hyperplane that passes through this point. This implies that the hyperplane representation of the pairwise comparison in the primal intersects the cell containing r\u03c3 (see Figure 2 for an illustration of this concept). Consider the partition of Rd generated by the hyperplanes corresponding to pairwise comparisons between objects 1, . . . , k. Let P (k, d) denote the number of d-cells in this partition that are intersected by a hyperplane corresponding to one of the queries qi,k+1, i \u2208 {1, . . . , k}. Then it is not difficult to show that P (k, d) is bounded above and below by constants independent of n and k times k 2(d\u22121)\n2d\u22121(d\u22121)! (see Appendix A.4). By Lemma 3, every d-cell in the partition induced by the k objects corresponds to an equally probable ranking of those objects. Therefore, the probability that a query is ambiguous is the number of cells intersected by the corresponding hyperplane divided by the total number of d-cells, and therefore A(k, d,U) = P (k,d)Q(k,d) . The result follows immediately from the bounds on P (k, d) and Corollary 1.\nBecause the individual events of requesting each query are conditionally independent, the total number of queries requested by the algorithm is just Mn = \u2211n\u22121 k=1 \u2211k i=1 1{Request qi,k+1}. Using the results above, it straightforward to prove the main theorem below (see Appendix A.5). Theorem 3. Assume A1-2 and \u03c3 \u223c U . Let the random variable Mn denote the number of pairwise comparisons that are requested in the algorithm of Figure 1, then\nEU [Mn] \u2264 2d log2 2d+ 2da2 log n.\nFurthermore, if \u03c3 \u223c \u03c0 and max\u03c3\u2208\u03a3n,d \u03c0\u03c3 \u2264 c|\u03a3n,d|\u22121 for some c > 0, then E\u03c0[Mn] \u2264 cEU [Mn]."}, {"heading": "5 Robust sequential algorithm for query selection", "text": "We now extend the algorithm of Figure 1 to situations in which the response to each query is only probably correct. If the correct label of a query qi,j is yi,j , we denote the possibly incorrect response by Yi,j . The probability that Yi,j = yi,j is at least 1 \u2212 p, p < 1/2. The robust algorithm operates in the same fashion as the algorithm in Figure 1, with the exception that when an ambiguous query is encountered several (equivalent) queries are made and a decision is based on the majority vote. This voting procedure allows us to construct a ranking (or partial ranking) that is correct with high probability by requesting just O(d log2 n) queries where the extra log factor comes from voting.\nFirst consider the case in which each query can be repeated to obtain multiple independent responses (votes) for each comparison query. This random noise model arises, for example, in social choice theory where the \u201creference\u201d is a group of people, each casting a vote. The elementary proof of the next theorem is given in Appendix A.6. Theorem 4. Assume A1-2 and \u03c3 \u223c U but that each query response is a realization of an i.i.d. Bernoulli random variable Yi,j with P (Yi,j 6= yi,j) \u2264 p < 1/2. If all ambiguous queries are decided by the majority vote of R independent responses to each such query, then with probability greater than 1 \u2212 2n log2(n) exp(\u2212 12 (1 \u2212 2p)2R) this procedure correctly identifies the correct ranking and requests no more than O(Rd log n) queries on average.\nIn other situations, if we ask the same query multiple times we may get the same, possibly incorrect, response each time. This persistent noise model is natural, for example, if the reference is a single human. Under this model, if two rankings differ by only a single pairwise comparison, then they cannot be distinguished with probability greater than 1 \u2212 p. So, in general, exact recovery of the ranking cannot be guaranteed with high probability. The best we can hope for is to exactly recover a partial ranking of the objects (i.e. the ranking over a subset of the objects). Henceforth, we will assume the noise is persistent and aim to exactly recover a partial ranking of the objects.\nThe key ingredient in the persistent noise setting is the design of a voting set for each ambiguous query encountered. Suppose that at the jth object in the algorithm in Figure 1 the query qi,j is ambiguous. In principle, a voting set could be constructed using objects ranked between i and j. If object k is between i and j, then note that yi,j = yi,k = yk,j . In practice, we cannot identify the subset of objects ranked between i and j, but it is contained within the set Ti,j , defined to be the subset of objects \u03b8k such that qi,k, qk,j , or both are ambiguous. Furthermore, Lemma 3 implies that each object in Ti,j is ranked between i and j with probability at least 1/3 (see Appendix A.7). Ti,j will be our voting set. Note however, if objects i and j are closely ranked, then Ti,j may be\nrather small, and so it is not always possible to find a sufficiently large voting set. Therefore, we must specify a size-threshold R \u2265 1. If the size of Ti,j is at least R, then we decide the label for qi,j by voting over the responses to {qi,k, qk,j : k \u2208 Ti,j} and qi,j ; otherwise we pass over object j and move on to the next object in the list. This allows us to construct a probably correct ranking of the objects that are not passed over. The theorem below proves that a large portion of objects will not be passed over. At the end of the process, some objects that were passed over may then be unambiguously ranked (based on queries made after they were passed over) or they can be ranked without voting (and without guarantees). Proof of the next theorem is given in Appendix A.7. Theorem 5. Assume A1-2, \u03c3 \u223c U , and P (Yi,j 6= yi,j) = p. For any size-threshold R \u2265 1, with probability greater than 1\u2212 2n log2(n) exp ( \u2212 29 (1\u2212 2p)2R ) the procedure above correctly ranks at least n/(2R+ 1) objects and requests no more than O(Rd log n) queries on average."}, {"heading": "6 Empirical results", "text": "In this section we present empirical results for both the noiseless algorithm of Figure 1 and the robust algorithm of Section 5. For the noiseless algorithm, n = 100 points, representing the objects to be ranked, were uniformly at random simulated from the unit hypercube [0, 1]d for d = 1, 10, 20, . . . , 100. The reference was simulated from the same distribution. For each value of d the experiment was repeated 25 times using a new simulation of points and the reference. Because responses are noiseless, exact identification of the ranking is guaranteed. The number of requested queries is plotted in Figure 3 with the lower bound of Theorem 1 for reference. The number of requested queries never exceeds twice the lower bound which agrees with the result of Theorem 3.\nThe robust algorithm in Section 5 was evaluated using a symmetric similarity matrix dataset available at [19] whose (i, j)th entry, denoted si,j , represents the human-judged similarity between audio signals i and j for all i 6= j \u2208 {1, . . . , 100}. If we consider the kth row of this matrix, we can rank the other signals with respect to their similarity to the kth signal; we define q(k)i,j := {sk,i > sk,j} and y(k)i,j := 1{q (k) i,j }. Since the similarities were derived from human subjects, the derived labels may be erroneous. Moreover, there is no possibility of repeating queries here and so the noise is persistent. The analysis of this dataset in [2] suggests that the relationship between signals can be well approximated by an embedding in 2 or 3 dimensions. We used non-metric multidimensional scaling [5] to find an embedding of the signals: \u03b81, . . . , \u03b8100 \u2208 Rd for d = 2 and 3. For each object \u03b8k, we use the embedding to derive pairwise comparison labels between all other objects as follows: y\u0303\n(k) i,j := 1{||\u03b8k \u2212 \u03b8i|| < ||\u03b8k \u2212 \u03b8j ||}, which can be considered as the best approximation to the labels y(k)i,j (defined above) in this embedding. The output of the robust sequential algorithm, which uses only a small fraction of the similarities, is denoted by y\u0302(k)i,j . We set R = 15 using Theorem 5 as\na rough guide. Using the popular Kendell-Tau distance d(y(k), y\u0302(k)) = ( n 2 )\u22121\u2211 i<j 1{y (k) i,j 6= y\u0302 (k) i,j } [20] for each object k, we denote the average of this metric over all objects by d(y, y\u0302) and report this statistic and the number of queries requested in Table 1. Because the average error of y\u0302 is only 0.07 higher than that of y\u0303, this suggests that the algorithm is doing almost as well as we could hope. Also, note that 2R 2d log n/ ( n 2 ) is equal to 11.4% and 17.1% for d = 2 and 3, respectively, which agrees well with the experimental values."}, {"heading": "A Appendix", "text": "A.1 Computational complexity and implementation\nThe computational complexity of the algorithm in Figure 1 is determined by the complexity of testing whether a query is ambiguous or not and how many times we make this test. As written in Figure 1, the test would be performed O(n2) times. But if binary sort is used instead of the bruteforce linear search this can be reduced to n log2 n and, in fact, this is implemented in our simulations and the proofs of the main results. The complexity of each test is polynomial in the number of queries requested because each one is a linear constraint. Because our results show that no more than O(d log n) queries are requested, the overall complexity is no greater thanO(n poly(d) poly(log n)).\nA.2 Proof of Corollary 1\nProof. For initial conditions given in Lemma 1, if d n\u2212 1 a simple manipulation of (3) shows\nQ(n, d) = 1 + n\u22121\u2211 i=1 (n\u2212 i)Q(n\u2212 i, d\u2212 1)\n= 1 + n\u22121\u2211 i=1 iQ(i, d\u2212 1)\n= 1 + n\u22121\u2211 i=1 i [ 1 + i\u22121\u2211 j=1 j Q(j, d\u2212 2) ]\n= 1 + \u0398(n2/2) + n\u22121\u2211 i=1 i\u22121\u2211 j=1 i j [ 1 + j\u22121\u2211 k=1 k Q(k, d\u2212 3) ]\n= 1 + \u0398(n2/2) + \u0398(n4/2/4) + n\u22121\u2211 i=1 i\u22121\u2211 j=1 j\u22121\u2211 k=1 i j k [ 1 + k\u22121\u2211 l=1 l Q(l, d\u2212 4) ]\n= 1 + \u0398(n2/2) + \u00b7 \u00b7 \u00b7+ \u0398 ( n2d\n2dd!\n) .\nFrom simulations, this is very tight for large values of n. If d \u2265 n \u2212 1 then Q(n, d) = n! because any permutation of n objects can be embedded in n\u2212 1 dimensional space [7].\nA.3 Construction of a d-cell with n\u2212 1 sides\nSituations may arise in which \u2126(n) queries must be requested to identify a ranking because the d-cell representing the ranking is bounded by n \u2212 1 hyperplanes (queries) and if they are not all requested, the ranking is ambiguous. We now show how to construct this pathological situation in R2. Let \u0398 be a collection of n points in R2 where each \u03b8 \u2208 \u0398 satisfies \u03b821 = \u03b82 and \u03b81 \u2208 [0, 1] where \u03b8i denotes the ith dimension of \u03b8 (i \u2208 {1, 2}). Then there exists a 2-cell in the hyperplane arrangement induced by the queries that has n \u2212 1 sides. This follows because the slope of the parabola keeps increasing with \u03b81 making at least one query associated with (n \u2212 1) \u03b8\u2019s bisect the lower-left, unbounded 2-cell. This can be observed in Figure 4. Obviously, a similar arrangement could be constructed for all d \u2265 2.\nA.4 Proof of Lemma 4\nProof. Here we prove the bounds on P (k, d). P (k, d) is equal to the number of d-cells in the partition induced by objects 1, . . . , k that are intersected by a hyperplane corresponding to a pairwise comparison query between object k + 1 and object i, i \u2208 {1, . . . , k}. This new hyperplane is intersected by all the ( k 2 ) hyperplanes in the partition. These intersections partition the new hyperplane into a number of (d \u2212 1)-cells. Because the (k + 1)st object is in general position with respect to objects 1, . . . , k, the intersecting hyperplanes will not intersect the hyperplane in any special or\nnon-general way. That is to say, the number of (d \u2212 1)-cells this hyperplane is partitioned into is the same number that would occur if the hyperplane were intersected by ( k 2 ) hyperplanes in general\nposition. Let K = ( k 2 ) for ease of notation. It follows then from [8, Theorem 3] that\nP (k, d) = d\u22121\u2211 i=0 ( K i ) = d\u22121\u2211 i=0 \u0398 ( Ki i! ) = d\u22121\u2211 k=0 \u0398 ( k2i 2ii! ) = \u0398 ( k2(d\u22121) 2d\u22121(d\u2212 1)! ) .\nA.5 Proof of Theorem 3\nProof. Let Bk+1 denote the total number of pairwise comparisons requested of the (k+ 1)st object; i.e., number of ambiguous queries in the set qi,k+1, i = 1, . . . , k. Because the individual events of requesting these are conditionally independent (see Section 4.3), it follows that each Bk+1 is an independent binomial random variable with parameters A(k, d,U) and k. The total number of queries requested by the algorithm is\nMn = n\u22121\u2211 k=1 k\u2211 i=1 1{Request qi,k+1} = n\u22121\u2211 k=1 Bk+1 . (4)\nBecause Lemma 4 holds only for k > 2da2 we assume that none of the pairwise comparisons are ambiguous when k \u2264 2da2. Recall from Section A.1 that binary sort is implemented so for these first d2da2e objects, at most d2da2e log2(d2da2e) queries are requested. For k > 2da2 the number of requested queries to the kth object is upper bounded by the number of ambiguous queries of the kth object. Then using the known mean and variance formulas for the binomial distribution EU [ Mn ] =\nn\u22121\u2211 k=1 EU [ Bk+1 ] \u2264 d2da2e\u2211 k=2 Bk+1 + n\u22121\u2211 k=d2da2e+1 2da2 k \u2264 d2da2e log2(d2da2e) + 2da2 log n .\nWe now consider the case for a general distribution \u03c0. Enumerate the rankings of \u03a3n,d. Let Ni denote the (random) number of requested queries needed by the algorithm to reconstruct the ith ranking. Note that the randomness of Ni is only due to the randomization of the algorithm. Let \u03c0i denote the probability it assigns to the ith ranking as in Definition distribution. Then\nE\u03c0[Mn] = Q(n,d)\u2211 i=1 \u03c0i E[Ni]. (5)\nAssume that the distribution over rankings is bounded above such that no ranking is overwhelmingly probable. Specifically, assume that the probability of any one ranking is upper bounded by c/Q(n, d)\nfor some constant c > 1 that is independent of n. Under this bounded distribution assumption, E\u03c0[Mn] is maximized by placing probability c/Q(n, d) on the k := Q(n, d)/c cells for which E[Ni] is largest (we will assume k is an integer, but it is straightforward to extend the following argument to the general case). Since the mass on these cells is equal, without loss of generality we may assume that E[Ni] = \u00b5, a common value on each, and we have E\u03c0[Mn] = \u00b5. For the remaining Q(n, d) \u2212 k cells we know that E[Ni] \u2265 d, since each cell is bounded by at least d hyperplanes/queries. Under these conditions, we can relate E\u03c0[Mn] to EU [Mn] as follows. First observe that\nEU [Mn] = 1\nQ(n, d) Q(n,d)\u2211 i=1 E[Ni] \u2265 k Q(n, d) \u00b5+ d Q(n, d)\u2212 k Q(n, d) ,\nwhich implies E\u03c0[Mn] = \u00b5 \u2264 Q(n,d)k ( EU [Mn]\u2212 dQ(n,d)\u2212kQ(n,d) ) = c ( EU [Mn]\u2212 dQ(n,d)\u2212kQ(n,d) ) \u2264 cEU [Mn] .\nIn words, the non-uniformity constant c > 1 scales the expected number of queries. Under A1-2, for large n we have E\u03c0[Mn] = O(c d log n).\nA.6 Proof of Theorem 4\nProof. Suppose qi,j is ambiguous. Let \u03b1\u0302 be the frequency of Yi,j = 1 after R trials. Let E[\u03b1\u0302] = \u03b1. The majority vote decision is correct if |\u03b1 \u2212 \u03b1\u0302| \u2264 1/2 \u2212 p. By Chernoff\u2019s bound, P(|\u03b1 \u2212 \u03b1\u0302| \u2265 1/2\u2212 p) \u2264 2 exp(\u22122(1/2\u2212 p)2R). The result follows from the union bound over the total number of queries considered: n log2 n (See Appendix A.1).\nA.7 Proof of Theorem 5\nSuppose qi,j is ambiguous. Let Si,j denote the subset of \u0398 such that \u03b8k \u2208 Si,j if it is ranked between objects \u03b8i and \u03b8j (i.e. Si,j = {\u03b8k \u2208 \u0398 : \u03b8i \u227a \u03b8k \u227a \u03b8j or \u03b8j \u227a \u03b8k \u227a \u03b8i}). Note that yi,j = yi,k = yk,j if and only if \u03b8k \u2208 Si,j . If we define Eki,j = 1{Yi,k = 1\u2227Yk,j = 1}\u22121{Yi,k = 0\u2227Yk,j = 0}, where 1 is the indicator function, then for any subset T \u2282 \u0398 with Si,j \u2282 T , the sign of the sum\u2211 \u03b8k\u2208T E k i,j is a predictor of yi,j . In fact, E [\u2223\u2223\u2211 \u03b8k\u2208T E k i,j\n\u2223\u2223] = |Si,j |(1 \u2212 2p). To see this, without loss of generality let yi,j = 1, then for \u03b8k \u2208 Si,j\nE[Eki,j ] = E [ 1{Yi,k = 1 \u2227 Yk,j = 1} \u2212 1{Yi,k = 0 \u2227 Yk,j = 0} ] = P(Yi,k = 1 \u2227 Yk,j = 1)\u2212 P(Yi,k = 0 \u2227 Yk,j = 0) = (1\u2212 p)2 \u2212 p2 = 1\u2212 2p.\nIf \u03b8k /\u2208 Si,j then it can be shown by a similar calculation that E[Eki,j ] = 0. To identify Si,j we use the fact that if \u03b8k \u2208 Si,j then qi,k, qj,k, or both are also ambiguous simply because otherwise qi,j would not have been ambiguous in the first place (Figure 5 may be a useful aid to see this). While the converse is false, Lemma 3 says that each of the six possible rankings of {\u03b8i, \u03b8j , \u03b8k} are equally probable. It follows that if we define the subset Ti,j \u2208 \u0398 to be those objects \u03b8k with the property that qi,k, qk,j , or both are ambiguous then the probability that \u03b8k \u2208 Si,j is at least 1/3 if \u03b8k \u2282 Ti,j . You can convince yourself of this using Figure 5. Moreover, E [\u2223\u2223\u2211\nk\u2208Ti,j E k i,j \u2223\u2223] = |Ti,j |(1\u2212 2p)/3 which implies the sign of the sum\u2211\u03b8k\u2208Ti,j Eki,j is a reliable predictor of qi,j ; just how reliable depends only on the size of Ti,j .\nFix R > 0. Suppose qi,j is ambiguous and assume without loss of generality that qi,j = 1. Given that E [\u2223\u2223\u2211 k\u2208Ti,j E k i,j \u2223\u2223] = |Ti,j |(1\u2212 2p)/3 from above, it follows from Hoeffding\u2019s inequality that the probability that \u2211 k\u2208Ti,j E k i,j \u2264 0 is less than 2 exp ( \u2212 29 (1\u22122p)2|Ti,j | ) . If only a subset of Ti,j of size R is used in the sum then |Ti,j | is replaced by R in the exponent. This test is only performed when |Ti,j | > R and clearly no more times than the number of queries considered to rank n objects in the full ranking: n log2 n. Thus, all decisions using this test are correct with probability at least 1 \u2212 2n log2(n) exp ( \u2212 29 (1 \u2212 2p)2R ) . Only a subset of the n objects will be ranked and of those,\n2R times more queries will be requested than in the noiseless case (two queries per object in Ti,j). Thus the robust algorithm will request no more than O(Rd log n) queries on average.\nTo determine the number of objects that are in the partial ranking, let \u0398\u2032 \u2282 \u0398 denote the subset of objects that are ranked in the output partial ranking. Each \u03b8k \u2208 \u0398\u2032 is associated with an index in the true full ranking and is denoted by \u03c3(\u03b8k). That is, if \u03c3(\u03b8k) = 5 then it is ranked fifth in the full ranking but in the partial ranking could be ranked first, second, third, fourth, or fifth. Now imagine the real line with tick marks only at the integers 1, . . . , n. For each \u03b8k \u2208 \u0398\u2032 place an R-ball around each \u03b8k on these tick marks such that if \u03c3(\u03b8k) = 5 and R = 3 then 2, . . . , 8 are covered by the ball around \u03c3(\u03b8k) and 1 and 9, . . . , n are not. I claim that the union of the balls from \u0398\u2032 cover 1, . . . , n. If this were not true then there would be an object \u03b8j /\u2208 \u0398\u2032 with |Si,j | > R for all \u03b8i \u2208 \u0398\u2032. Because Si,j \u2282 Ti,j it follows using the same Hoeffding\u2019s inequality of above that |Ti,j | < R with less than 2 exp ( \u2212 29 (1\u22122p)2R ) . Because at least n/(2R+1)R-balls are required to cover 1, . . . , n, at least this many objects are contained in \u0398\u2032."}], "references": [{"title": "The Art of Computer Programming", "author": ["D. Knuth"], "venue": "Volume 3: Sorting and Searching. Addison- Wesley", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1998}, {"title": "Perceptual feature identification for active sonar echoes", "author": ["Scott Philips", "James Pitton", "Les Atlas"], "venue": "OCEANS", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Partial order embedding with multiple kernels", "author": ["B. McFee", "G. Lanckriet"], "venue": "Proceedings of the 26th Annual International Conference on Machine Learning, pages 721\u2013728. ACM", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "A latent space model for rank data", "author": ["I. Gormley", "T. Murphy"], "venue": "Statistical Network Analysis: Models, Issues, and New Directions, pages 90\u2013102", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "Multidimensional scaling", "author": ["M.A.A. Cox", "T.F. Cox"], "venue": "Handbook of data visualization, pages 315\u2013347", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2008}, {"title": "Information-based complexity", "author": ["J.F. Traub"], "venue": "John Wiley and Sons Ltd.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "A theory of data", "author": ["C.H. Coombs"], "venue": "Psychological review, 67(3):143\u2013159", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1960}, {"title": "Geometrical and statistical properties of systems of linear inequalities with applications in pattern recognition", "author": ["T.M. Cover"], "venue": "IEEE transactions on electronic computers, 14(3):326\u2013334", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1965}, {"title": "Analysis of perceptron-based active learning", "author": ["S. Dasgupta", "A.T. Kalai", "C. Monteleoni"], "venue": "The Journal of Machine Learning Research, 10:281\u2013299", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "Theoretical foundations of active learning", "author": ["S. Hanneke"], "venue": "PhD thesis, Citeseer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "Generalized teaching dimensions and the query complexity of learning", "author": ["Tibor Heged\u00fcs"], "venue": "In Proceedings of the eighth annual conference on Computational learning theory,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1995}, {"title": "An efficient boosting algorithm for combining preferences", "author": ["Y. Freund", "R. Iyer", "R.E. Schapire", "Y. Singer"], "venue": "The Journal of Machine Learning Research, 4:933\u2013969", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2003}, {"title": "Learning to rank using gradient descent", "author": ["C. Burges", "T. Shaked", "E. Renshaw", "A. Lazier", "M. Deeds", "N. Hamilton", "G. Hullender"], "venue": "Proceedings of the 22nd international conference on Machine learning, pages 89\u201396. ACM", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "A regression framework for learning ranking functions using relative relevance judgments", "author": ["Z. Zheng", "K. Chen", "G. Sun", "H. Zha"], "venue": "Proceedings of the 30th annual international ACM SI- GIR conference on Research and development in information retrieval, pages 287\u2013294. ACM", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "Support vector learning for ordinal regression", "author": ["R. Herbrich", "T. Graepel", "K. Obermayer"], "venue": "Artificial Neural Networks, 1999. ICANN 99. Ninth International Conference on (Conf. Publ. No. 470), volume 1, pages 97\u2013102. IET", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}, {"title": "Robust approximation and incremental elicitation in voting protocols", "author": ["T. Lu", "C. Boutilier"], "venue": "IJCAI-11, Barcelona", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Extensions of gaussian processes for ranking: semi-supervised and active learning", "author": ["W. Chu", "Z. Ghahramani"], "venue": "Learning to Rank, page 29", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2005}, {"title": "Multidimensional unfolding: Determining the dimensionality of ranked preference data", "author": ["J.F. Bennett", "W.L. Hays"], "venue": "Psychometrika, 25(1):27\u201343", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1960}, {"title": "Analyzing and modeling rank data", "author": ["J.I. Marden"], "venue": "Chapman & Hall/CRC", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1995}], "referenceMentions": [{"referenceID": 0, "context": "In fact, this lower bound can be achieved with a standard adaptive sorting algorithm like binary sort [1].", "startOffset": 102, "endOffset": 105}, {"referenceID": 1, "context": "This may be a reasonable assumption in many applications, and for instance the audio dataset used in our experiments is believed to have a 2 or 3 dimensional embedding [2].", "startOffset": 168, "endOffset": 171}, {"referenceID": 2, "context": "Many have studied the problem of finding an embedding of objects from data [3, 4, 5].", "startOffset": 75, "endOffset": 84}, {"referenceID": 3, "context": "Many have studied the problem of finding an embedding of objects from data [3, 4, 5].", "startOffset": 75, "endOffset": 84}, {"referenceID": 4, "context": "Many have studied the problem of finding an embedding of objects from data [3, 4, 5].", "startOffset": 75, "endOffset": 84}, {"referenceID": 5, "context": "However, because such situations are not representative of what is typically encountered, we analyze the problem in the framework of the average-case analysis [6].", "startOffset": 159, "endOffset": 162}, {"referenceID": 6, "context": "Geometrical interpretations of our problem derive from the seminal works of [7] in ranking and [8] in learning.", "startOffset": 76, "endOffset": 79}, {"referenceID": 7, "context": "Geometrical interpretations of our problem derive from the seminal works of [7] in ranking and [8] in learning.", "startOffset": 95, "endOffset": 98}, {"referenceID": 8, "context": "These dependencies invalidate many of the typical analyses of such problems [9, 10].", "startOffset": 76, "endOffset": 83}, {"referenceID": 9, "context": "These dependencies invalidate many of the typical analyses of such problems [9, 10].", "startOffset": 76, "endOffset": 83}, {"referenceID": 10, "context": "One popular method of analysis in exact learning involves the use of something called the extended teaching dimension [11].", "startOffset": 118, "endOffset": 122}, {"referenceID": 11, "context": "[12, 13, 14, 15]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 12, "context": "[12, 13, 14, 15]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 13, "context": "[12, 13, 14, 15]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 14, "context": "[12, 13, 14, 15]).", "startOffset": 0, "endOffset": 16}, {"referenceID": 15, "context": "This inefficiency was recently noted in the related area of social choice theory [16].", "startOffset": 81, "endOffset": 85}, {"referenceID": 16, "context": "Furthermore, empirical evidence suggests that, even under complex ranking models, adaptively selecting pairwise comparisons can reduce the number needed to learn the ranking [17].", "startOffset": 174, "endOffset": 178}, {"referenceID": 11, "context": "The problem of learning a general function f : R \u2192 R using just pairwise comparisons that correctly ranks the objects embedded in R has previously been studied in the passive setting [12, 13, 14, 15].", "startOffset": 183, "endOffset": 199}, {"referenceID": 12, "context": "The problem of learning a general function f : R \u2192 R using just pairwise comparisons that correctly ranks the objects embedded in R has previously been studied in the passive setting [12, 13, 14, 15].", "startOffset": 183, "endOffset": 199}, {"referenceID": 13, "context": "The problem of learning a general function f : R \u2192 R using just pairwise comparisons that correctly ranks the objects embedded in R has previously been studied in the passive setting [12, 13, 14, 15].", "startOffset": 183, "endOffset": 199}, {"referenceID": 14, "context": "The problem of learning a general function f : R \u2192 R using just pairwise comparisons that correctly ranks the objects embedded in R has previously been studied in the passive setting [12, 13, 14, 15].", "startOffset": 183, "endOffset": 199}, {"referenceID": 6, "context": "This is a standard model used in multidimensional unfolding and psychometrics [7, 18].", "startOffset": 78, "endOffset": 85}, {"referenceID": 17, "context": "This is a standard model used in multidimensional unfolding and psychometrics [7, 18].", "startOffset": 78, "endOffset": 85}, {"referenceID": 6, "context": "[7] Assume A1-2.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] Let S be a finite subset of R and let S \u2282 S be points labeled +1 and S\u2212 = S \\ S be the points labeled \u22121 and let x be any other point except the origin.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "For the noiseless algorithm, n = 100 points, representing the objects to be ranked, were uniformly at random simulated from the unit hypercube [0, 1] for d = 1, 10, 20, .", "startOffset": 143, "endOffset": 149}, {"referenceID": 1, "context": "The analysis of this dataset in [2] suggests that the relationship between signals can be well approximated by an embedding in 2 or 3 dimensions.", "startOffset": 32, "endOffset": 35}, {"referenceID": 4, "context": "We used non-metric multidimensional scaling [5] to find an embedding of the signals: \u03b81, .", "startOffset": 44, "endOffset": 47}, {"referenceID": 18, "context": "Using the popular Kendell-Tau distance d(y, \u0177) = ( n 2 )\u22121\u2211 i<j 1{y (k) i,j 6= \u0177 (k) i,j } [20] for each object k, we denote the average of this metric over all objects by d(y, \u0177) and report this statistic and the number of queries requested in Table 1.", "startOffset": 91, "endOffset": 95}], "year": 2017, "abstractText": "This paper examines the problem of ranking a collection of objects using pairwise comparisons (rankings of two objects). In general, the ranking of n objects can be identified by standard sorting methods using n log2 n pairwise comparisons. We are interested in natural situations in which relationships among the objects may allow for ranking using far fewer pairwise comparisons. Specifically, we assume that the objects can be embedded into a d-dimensional Euclidean space and that the rankings reflect their relative distances from a common reference point in R. We show that under this assumption the number of possible rankings grows like n and demonstrate an algorithm that can identify a randomly selected ranking using just slightly more than d log n adaptively selected pairwise comparisons, on average. If instead the comparisons are chosen at random, then almost all pairwise comparisons must be made in order to identify any ranking. In addition, we propose a robust, error-tolerant algorithm that only requires that the pairwise comparisons are probably correct. Experimental studies with synthetic and real datasets support the conclusions of our theoretical analysis.", "creator": "LaTeX with hyperref package"}}}