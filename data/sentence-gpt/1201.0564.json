{"id": "1201.0564", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Jan-2012", "title": "The RegularGcc Matrix Constraint", "abstract": "We study propagation of the RegularGcc global constraint. This ensures that each row of a matrix of decision variables satisfies a Regular constraint, and each column satisfies a Gcc constraint. On the negative side, we prove that propagation is NP-hard even under some strong restrictions (e.g. just 3 values, just 4 states in the automaton, or just 5 columns to the matrix). On the positive side, we identify two cases where propagation is fixed parameter tractable. In addition, we show how to improve propagation over a simple decomposition into separate Regular and Gcc constraints by identifying some necessary but insufficient conditions for a solution. We enforce these conditions with some additional weighted row automata. Experimental results demonstrate the potential of these methods on some standard benchmark problems.\n\n\nThe first case in which the general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general linear general", "histories": [["v1", "Tue, 3 Jan 2012 03:30:18 GMT  (95kb)", "http://arxiv.org/abs/1201.0564v1", "Submitted to CPAIOR 2012"]], "COMMENTS": "Submitted to CPAIOR 2012", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["ronald de haan", "nina narodytska", "toby walsh"], "accepted": false, "id": "1201.0564"}, "pdf": {"name": "1201.0564.pdf", "metadata": {"source": "CRF", "title": "The RegularGcc Matrix Constraint", "authors": ["Ronald de Haan", "Nina Narodytska"], "emails": ["Haan@mailbox.tu-dresden.de,", "nina.narodytska@nicta.com.au", "toby.walsh@nicta.com.au"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 1.\n05 64\nv1 [\ncs .A\nI] 3\nJ an"}, {"heading": "1 Introduction", "text": "Global constraints can be used to model and reason about commonly found substructures. Many such models contain matrices of decision variables [1\u20133]. Matrix constraints are global constraints that apply to such matrices [4]. For example, the RegularGcc matrix constraint can be used to model rostering problems. It ensures each row of the matrix satisfies a Regular constraint (representing the shift rules) and each column satisfies a Gcc constraint (representing the required capacities for each shift). We prove here that propagating the RegularGcc constraint is costly, even under very severe restrictions. Therefore, as in [5], we look for partial methods that only enforce a limited level of consistency. These methods are based on necessary conditions that improve propagation over the decomposition into separate Regular constraints on the rows and separate Gcc constraints on the columns. These necessary conditions depend on extracting several string properties from the rows. We enforce these necessary conditions by constraining the rows with additional automaton constraints. Unfortunately, when the number of columns increases, these automata increase in size quite drastically. By using weighted automata, we show that we can limit the increase in size. Finally, we show that this approach can be used in a more general setting where we have a matrix with multicostRegular and Gcc constraints."}, {"heading": "2 Intractable cases", "text": "We first prove that propagating the RegularGcc matrix constraint is intractable even under strong conditions. More precisely, we show that enforcing bound consistency (BC) is NP-hard. This justifies why we later look for partial propagation methods based on some necessary (but not sufficient) conditions.\nTheorem 1. Enforcing BC on RegularGcc is NP-hard, already for Regular constraints given by a DFA of size 4, Gcc constraints specifying only an upper bound on the number of occurrences of one particular value, and just 3 values.\nProof: Reduction from 3-SAT. Let \u03d5 = \u03b31 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b3C be a Boolean formula in CNF on propositional variables p1, . . . , pR. We construct an R \u00d7 C matrix M of decision variables taking their values from {\u22121, 0, 1}, where each row 1 \u2264 r \u2264 R corresponds to a propositional variable pr and each column 1 \u2264 c \u2264 C corresponds to a clause \u03b3c.\nTo initialize the domain of variables in the matrix, we do the following for each clause \u03b3i = l i 1\u2228 l i 2\u2228 l i 3. We set Mr,i = 0 for all propositions pr not occurring in \u03b3i. For j \u2208 {1, 2, 3} we set Mi,k \u2208 {0, 1} if l i j = pk and we set Mi,k \u2208 {0,\u22121} if lij = \u00acpk. On each column we put the Gcc constraint that states that the value 0 occurs at most R \u2212 1 times. On each row we put the Regular constraint that states that besides 0\u2019s either only 1\u2019s or only \u22121\u2019s occur.\nWe show that this instance of RegularGcc has a solution iff \u03d5 is satisfiable. (\u21d2) We create a satisfying assignment I for \u03d5 as follows. For each pr, if in row r occurs at least one 1, we let I(pr) = \u22a4, otherwise we let I(pr) = \u22a5 (the choice of I(pr) when only 0\u2019s occur in row r is arbitrary). Since in each column c there occur only R\u2212 1 many 0\u2019s, we know that there exists some pi for which Mi,c 6= 0 and thus I(lci ) = \u22a4. Therefore I |= \u03b3c.\n(\u21d0) Let I be an assignment satisfying \u03d5. We can instantiate M as follows. For each clause \u03b3c = l c 1 \u2228 l c 2 \u2228 l c 3, for j \u2208 {1, 2, 3} we do the following. If l c j = pk and I(pk) = \u22a4, we let Mk,c = 1. If lcj = \u00acpk and I(pk) = \u22a5, we let Mk,c = \u22121. Otherwise, we let Mk,c = 0. Since I is functional each Regular constraint on the rows is satisfied. Also, since at least one literal is satisfied in each clause, each column contains at least one value that is not 0, so the Gcc constraints are satisfied.\nAutomaton A in Fig. 1 witnesses that this Regular constraint can be enforced by a DFA of size 4. Note that this proof also works for any other restriction on Regular constraints that can enforce that, for two given values, in any word at most one of these values occurs.\nIn fact, since we only bound the number of one particular value in the Gcc constraint, the above proof also works for the RegularAmong constraint.\nA common type of Regular constraint in aRegularGccmatrix constraint is a Stretch constraint. This constrains the length of any stretch of values (e.g. there are at most 3 night shifts in a row) and the possible transitions (e.g. a night\nshift can only be followed by a day off). Unfortunately, even this special case is intractable to propagate.\nTheorem 2. Enforcing BC on StretchGcc is NP-hard, already for just 3 values.\nProof: Reduction from the Exact Cover problem. We are given F = {S1, . . . , Sn} with \u22c3\ni Si = U . We ask if there is some subset C \u2286 F with \u22c3\nc\u2208C c = U and c \u2229 c \u2032 = \u2205 for all distinct c, c\u2032 \u2208 C. W.l.o.g. we assume U contains the integers 1 to |U |. We construct a |F | \u00d7 |U | matrix M, of decision variables taking their value in {\u22121, 0, 1}. For each row 1 \u2264 r \u2264 |F | and each value 1 \u2264 i \u2264 |U | we do the following. If i \u2208 Sr, we let Mr,i \u2208 {0, 1}. If i 6\u2208 Sr, we let Mr,i \u2208 {\u22121, 0}.\nOn each column we put the Gcc constraint that states that the value 1 occurs exactly once. On each row we put the Stretch constraint stating that each stretch of 0\u2019s must have a length of at least |U |.\nWe show that this instance of StretchGcc has a solution iff there exists an exact cover.\n(\u21d2) Take a solution for our instance. We let C be the set of all Ur for which row r in the solution contains only \u22121\u2019s and 1\u2019s. Obviously C \u2286 F . In order to show that \u22c3\nc\u2208C = U , it suffices to show that U \u2286 \u22c3\nc\u2208C . Take an arbitrary i \u2208 U . Since our solution contains at least one 1 in each column, we know there is some c \u2208 C such that i \u2208 c. We also show that all distinct c, c\u2032 \u2208 C are disjoint. Take arbitrary c, c\u2032 \u2208 C such that c 6= c\u2032. Assume j \u2208 c\u2229 c\u2032. This means that column j in the solution would contain two 1\u2019s, which contradicts the Gcc constraints on the columns.\n(\u21d0) Let C \u2286 F be an exact cover. We fill M as follows. For each row 1 \u2264 r \u2264 |F |, we do the following. If Sr \u2208 C, fill the row with \u22121\u2019s and 1\u2019s (this can be done only in one way). Otherwise, fill row r with only 0\u2019s. Obviously, the Stretch constraints on the rows are satisfied. Also, since C is an exact cover, we know that for each 1 \u2264 i \u2264 |U | there is exactly one row r such that Mr,i = 1. Thus the Gcc constraints on the columns are satisfied.\nThis proof also works for the Regular constraint accepting only words that contain either only 0\u2019s or only \u22121\u2019s and 1\u2019s, and therefore for any restriction on Regular constraints that can enforce permitted (or forbidden) words of length two (such as the meta constraint Slide).\nCorollary 1. Enforcing BC on SlideGcc is NP-hard, already for Slide constraints based on constraints of arity 2 and just 3 values.\nAnother common type of Regular constraint in a RegularGcc matrix constraint is a Sequence constraint. This limits the number of values of a particular type that occur in each sequence (e.g. at most 3 shifts in every 7 can be night shifts). This case is unfortunately also intractable to propagate. We prove that both enforcing domain consistency (DC) and enforcing bound consistency (BC) are NP-hard even if the matrix has just a few columns.\nTheorem 3. Enforcing DC on SequenceGcc is NP-hard, already for just 5 columns.\nProof: Reduction from the 3D Matching problem. The proof is inspired by [6]. Given are three pair-wise disjoint sets W , Z, Y of equal size q and a set M \u2286 W \u00d7 Z \u00d7 Y , |M | = m. The question is if there exists M \u2032 \u2286 M such that |M \u2032| = q and no two different elements of M \u2032 agree in any coordinate.\nAssume M = {s1, . . . , sm}. We create a m \u00d7 5 matrix M of decision variables taking their value in {0, t, w1, . . . , wq, z1, . . . , zq, y1, . . . , yq}. For each (wi, zi, yi) = si we let Mi,1 \u2208 {0, wi}, Mi,2 \u2208 {0, t}, Mi,3 \u2208 {0, zi}, Mi,4 \u2208 {0, t}, and Mi,5 \u2208 {0, yi}.\nWe constrain each row i with the constraint Sequence(Mi, 1, 2, 2, {0}), stating that in each sequence of length 2, at least one 0 occurs. On columns 1 (resp. 3 and 5) we put the Gcc constraint stating that each value in W (resp. Z and Y ) occurs at least once, and that at least m\u2212 q many 0\u2019s occur. On columns 2 and 4 we put the Gcc constraint stating that at least q many t\u2019s occur, and at least m\u2212 q many 0\u2019s.\nWe show that this instance of SequenceGcc has a solution iff there exists a 3D matching.\n(\u21d2) Take a solution for SequenceGcc. We know column 2 contains exactly m\u2212 q many t\u2019s, and q many 0\u2019s. For each occurrence of a t in column 2 at row i, columns 1 and 3 contain a 0 at row i (by the Sequence constraint). Then, by the Gcc constraint, for all rows j where column 2 contains a 0, columns 1 and 3 contain a non-0 at row j, and thus (by Sequence) column 4 contains a 0 at row j. By a similar argument, we know that in the remaining rows column 4 contains t\u2019s. Continuing this argument for column 5, we know that in the solution there are q many rows taking values (wi, 0, zi, 0, yi) and m \u2212 q rows taking values (0, t, 0, t, 0). By the Gcc constraints, we know that each value w \u2208 W occurs exactly once, as well as each value z \u2208 Z and each y \u2208 Y . Since the possible values were chosen by taking elements from M , we know that M \u2032 = {si | Mi 6= (0, t, 0, t, 0)} is a 3D matching.\n(\u21d0) Let M \u2032 \u2286 M be a 3D matching. We can fill M as follows. For each (wi, zi, yi) = si \u2208 M \u2032, we let Mi = (wi, 0, zi, 0, yi). For each si \u2208 M\\M \u2032 we let Mi = (0, t, 0, t, 0). Obviously each row satisfies the Sequence constraint. Since |M \u2032| = q and each value w \u2208 W occurs exactly once in the first coordinate of M \u2032 (and similarly for values z \u2208 Z and the second coordinate, and y \u2208 Y and the third coordinate), we have that each column satisfies the corresponding Gcc constraint.\nNote that the Sequence constraints on all rows are the same, but the Gcc constraints on the columns differ.\nTheorem 4. Enforcing BC on SequenceGcc is NP-hard, already for just 5 columns.\nProof: The proof is similar to the proof of Theorem 3, and also inspired by [6].\nLet cwi (resp. czi, cyi) be the number of occurrences of the value wi (resp. zi, yi) in M . For each value wi (resp. zi, yi) we create cwi \u2212 1 (resp. czi \u2212 1, cyi \u2212 1) clones of it. We now define the total order on values as U = [\u2212w1q , . . . ,\u2212w cwq\u22121 q , . . . ,\u2212w11, . . . ,\u2212w cw1\u22121 1 ,\u2212z 1 q , . . . ,\u2212z czq\u22121 q , . . . ,\u2212z11, . . . , \u2212zcz1\u221211 ,\u2212y 1 q , . . . ,\u2212y cyq\u22121 q , . . . ,\u2212y11, . . . ,\u2212y cy1\u22121 1 , 0, t, y1, . . . , yq, z1, . . . , zq, w1, . . . , wq].\nWe create the matrix M in a similar fashion as in the proof for Theorem 3, with the difference that for each (wi, zi, yi) = si we let Mi,1 \u2208 [\u2212w1i , . . . ,\u2212w cwi\u22121 i , . . . , wi], Mi,3 \u2208 [\u2212z 1 i , . . . ,\u2212z czi\u22121 i , . . . , zi], Mi,5 \u2208 [\u2212y1i , . . . ,\u2212y cyi\u22121 i , . . . , yi], and Mi,2 \u2208 [0, t] and Mi,4 \u2208 [0, t].\nWe adapt the constraint on rows to Sequence(Mi, 1, 2, 2, [\u2212w1q , 0]), stating that in each sequence of length 2, at least one value in [\u2212w1q , 0] occurs. On columns 1 (resp. 3 and 5) we replace the Gcc constraint with one stating that each value in {\u2212w1q , . . . ,\u2212w cwq\u22121 q , . . . ,\u2212w11 , . . . ,\u2212w cw1\u22121 1 } \u222a W (resp. {\u2212z1q , . . . ,\u2212z czq\u22121 q , . . . ,\u2212z11 , . . . ,\u2212z cz1\u22121 1 } \u222a Z and {\u2212y1q , . . . ,\u2212y cyq\u22121 q , . . . ,\u2212y11, . . . ,\u2212y cy1\u22121 1 } \u222a Y ) occurs at least once. We do not change the Gcc constraints on columns 2 and 4.\nWe show that this instance of SequenceGcc has a solution iff there exists a 3D matching.\n(\u21d2) By reasoning similarly to the proof of Theorem 3 (replacing \u20180\u2019 with \u2018a value in [\u2212w1q , 0]\u2019 when reasoning about columns 1, 3 and 5), we know that in the solution there are q many rows taking values (wi, 0, zi, 0, yi), possibly containing clones, and m \u2212 q rows taking values (n, t, n\u2032, t, n\u2032\u2032) where n, n\u2032, n\u2032\u2032 are either 0 or some clone w\u2032i, z \u2032 i, or y \u2032 i (respectively).\nFurthermore, by the Gcc constraint on the odd columns, we know that each value in {\u2212w1q , . . . ,\u2212w cwq\u22121 q , wq} must occur exactly once. Since these values occur only in the domains of Mi,1 for the cwq many si \u2208 M that contain wq, we know that each of these Mi,1 must take a value in {\u2212w1q , . . . ,\u2212w cwq\u22121 q , wq}.\nThen, by the Gcc constraint on the odd columns, we know that each value in {\u2212w1q\u22121, . . . ,\u2212w cwq\u22121\u22121 q\u22121 , wq\u22121} must occur exactly once. These values occur only in the domains of Mi,1 for the si \u2208 M that contain wq\u22121 or wq. However, the Mi,1 for the si \u2208 M that contain wq must take values in {\u2212w1q , . . . ,\u2212w cwq\u22121 q , wq}. Therefore, the Mi,1 for the si \u2208 M that contain wq\u22121 must take a value in {\u2212w1q\u22121, . . . ,\u2212w cwq\u22121\u22121 q\u22121 , wq\u22121}.\nRepeating this argument recursively until reaching the value t, we can restrict the effective domain of the odd positions of Mi for si = (wi, zi, yi) \u2208 M to Mi,1 \u2208 {\u2212w1i , . . . ,\u2212w cwi\u22121 i , wi}, Mi,3 \u2208 {\u2212z 1 i , . . . ,\u2212z czi\u22121 i , zi}, and Mi,5 \u2208 {\u2212y1i , . . . ,\u2212y cyi\u22121 i , yi}.\nTherefore, we know that each row Mi for si = (wi, zi, yi) \u2208 M either has the values (wi, 0, zi, 0, yi) or the values (w \u2032 i, t, z \u2032 i, t, y \u2032 i) for some clones w \u2032 i, z \u2032 i, y \u2032 i of\nwi, zi, yi. Now, by the Gcc constraints, we know that each value w \u2208 W occurs exactly once, as well as each value z \u2208 Z and each y \u2208 Y . Since the possible values were chosen by taking elements from M , we know that M \u2032 = {si | Mi = (w, 0, z, 0, y), w \u2208 W, z \u2208 Z, y \u2208 Y } is a 3D matching.\n(\u21d0) Let M \u2032 \u2286 M be a 3D matching. We can fill M as follows. For each (wi, zi, yi) = si \u2208 M \u2032, we let Mi = (wi, 0, zi, 0, yi). For each (wi, zi, yi) = si \u2208 M\\M \u2032 we let Mi = (w\u2032i, t, z \u2032 i, t, y \u2032 i) for some clones w \u2032 i, z \u2032 i, y \u2032 i of wi, zi, yi that have not been used before in the process of filling M. We know there are enough different clones for this procedure. It is easy to verify that this instantiation of M satisfies all the constraints."}, {"heading": "3 Fixed parameter tractable cases", "text": "We have seen that propagating the RegularGcc matrix constraint is NP-hard even under the strong restriction that either the number of values or the number of columns is bounded. However, if we consider Regular2 and we bound the number of columns and the number of states in the row and column automata we at last have a case in which propagation is polynomial.\nTheorem 5. Enforcing DC on Regular2 is fixed parameter tractable in k = C \u00b7 |Q| \u00b7 (log |Q\u2032|), where C is the number of columns, |Q| is the size of the row automata, and |Q\u2032| is the size of the column automata.\nProof: We assume w.l.o.g. that all row constraints are the same, and all column constraints are the same. We can encode the matrix constraint on a R \u00d7 C matrix M in a single DFA on the matrix stretched out to a single sequence of variables M1,1, . . . ,M1,C , . . . ,MR,1, . . . ,MR,C . The state set of the automaton is Q\u00d7Q\u2032|C|. In each state, the automaton keeps track of the current state q\u2032 \u2208 Q\u2032 for each column c, as well as the current state q \u2208 Q in the current row. The size of the automaton is O(|Q| \u00b7 2C(log |Q|)). Enforcing DC on a Regular constraint takes time polynomial in the size of the automaton, so our algorithm runs in fixed parameter tractable time.\nWe also get tractability if we bound the number of rows and the size of the automata.\nTheorem 6. Enforcing DC on RegularGcc is fixed parameter tractable in k = r(logQ) where r is the number of rows and Q the maximum number of states in any row automaton.\nProof: This follows directly from Observation 2 in [4], and the fact that Gcc over a sequence with fixed size can be encoded in a DFA with polynomially many states.\nOn the other hand, just bounding the number of rows is not enough to give tractability.\nTheorem 7. Enforcing BC on RegularGcc is W[2]-hard in k = R the number of rows, even with just 2 values.\nProof: This proof is similar to the proof of Theorem 3 in [4]. We reduce from p-Hitting-Set. Let H = (V,E) a hypergraph, where V = {v1, . . . , v|V |} and E = {e1, . . . , e|E|}. We ask if there is a hitting set S \u2286 V in H of cardinality k.\nWe construct an instance M of RegularGcc with |V | + |E| columns and k rows on the alphabet {0, 1}. The Regular constraint accepts |V | different words w1, . . . , w|V | of length |V | + |E|. For any word wv, the vth value is 1, and the remainder of the first |V | values is 0. Also, for any word wv and any 1 \u2264 j \u2264 |E|, the jth value of wv is 1 if v \u2208 ej , and is 0 otherwise. The Gcc constraints we put on the columns are as follows. In the first |V | columns we require exactly one 1. In the remaining columns, we require at least one 1.\nIn this reduction, each row corresponds to one vertex that is being chosen for inclusion in the hitting set, and each column after the first |V | to one hyperedge.\nThe Gcc constraints on the first |V | columns ensure that no vertex is chosen in two rows. The constraints on the last |E| columns ensure that each hyperedge contains a vertex chosen for the hitting set. If there is a hyperedge all vertices of which are not included in the hitting set, the column corresponding to this hyperedge will contain 0\u2019s only, violating the Gcc constraint of that column.\nWe show that there exists a hitting set S in H of cardinality k iff the RegularGcc matrix constraint has a solution.\n(\u21d2) Assume there exists a hitting set S in H of size k. We construct an assignment to RegularGcc by matching one vertex v \u2208 S with each row (in any manner). If row i is matched to vertex v, we assign word wv to row i. The fact that S contains k different vertices v ensures that k different words wv are used. Also, since S is a hitting set, we know that for each hyperedge ej there is at least one v \u2208 ej \u2229S, and so each of the last |E| columns contains at least one 1. Thus the Gcc constraints are satisfied.\n(\u21d0) Suppose the RegularGcc matrix constraint has a solution. We construct a hitting set S by taking all v such that wv is a row in the solution. By the Gcc constraints we know that the solution contains k different words wv, so S is of size k. Now, to derive the contrary, assume there exists a hyperedge ej \u2208 E such that S \u2229 ej = \u2205. Then the column corresponding to ej (column |V | + j) contains only 0\u2019s. This violates Gcc on this column, which is a contradiction.\nNote that the Gcc constraints in the above proof can be expressed with Regular constraints of bounded size as well, which gives us the following corollary.\nCorollary 2. Enforcing BC on the Regular2 matrix constraint is W[2]-hard in k the number of rows, even with just 2 values.\nAnother special case that is intractable is when we repace the Gcc constraint on the columns with a simpler sum constraint.\nTheorem 8. Enforcing BC on the RegularSum matrix constraint is W[2]hard in k the number of rows, even with just 3 values.\nProof: (Sketch) The proof is similar to the proof of Theorem 7 and the proof of Theorem 3 in [4]. We reduce from p-Hitting-Set and construct a matrix constraint as in the proof of Theorem 7, with the following differences. The\nfirst |V | columns we fill with \u22121\u2019s instead of 1\u2019s. We can then replace the Gcc constraints on these columns with the Sum constraint requiring a sum of at least \u22121. The Gcc constraints on the last |E| columns can be replaced with the Sum constraint requiring a sum of at least 1. The arguments in the proof of Theorem 7 now hold for this instance of RegularSum.\nNote that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4]."}, {"heading": "4 Some necessary conditions", "text": "Motivated by these rather negative complexity results, we investigate how to improve propagation over a simple decomposition into separateRegular andGcc constraints by means of deriving necessary conditions based on string properties. In fact, we will show how to extend the method of [5] to the (decomposed) setting of multicostRegular constraints on the rows andGcc constraints on the columns. This method is based on a double counting argument. Using automata constraints we extract several string properties from the rows. For these string properties, we derive lower and upper bounds based on the Gcc constraints on the columns. This allows us to derive necessary constraints relating the bounds to the corresponding string properties.\nWe start with some preliminary definitions needed for our exposition. The multicostRegular global constraint [7] is defined as follows. Given a sequence X = (x1, x2, . . . , xn) of finite domain decision variables and a deterministic finite automaton A = (Q, V,\u2206, s, F ), the constraint Regular(X,A) holds iff X is a word of length n over V accepted by DFA A. Given a vector Z = (z0, . . . , zR) of bounded variables and c = (crq,v) r\u2208[0...R] q\u2208Q,v\u2208V a family of assignment cost matrices, multicostRegular(X,Z,A, c) holds iff Regular(X,A) holds and for an accepting run q0q1 . . . qn of A on the instantiation (v0, . . . , vn) of X we have that \u2211\n0\u2264i<n c r qi,vi+1 = zr for all 0 \u2264 r \u2264 R. For any two DFAs A1 = (Q1, V,\u22061, s1, F1) and A2 = (Q2, V,\u22062, s2, F2), with corresponding c1 and c2 cost matrices over resources R = {r0, . . . , rR}, we define the product automaton A1 \u00d7A2 = (Q1 \u00d7Q2, V,\u2206, (s1, s2), F1 \u00d7 F2) and product cost matrix c = c1 \u00d7 c2 as follows.\n\u2206((q1, q2), v) = (\u22061(q1, v), \u22062(q2, v))\ncr(q1,q2),v = c 1,r q1,v + c2,rq2,v for 0 \u2264 r \u2264 R\nIn other words, when taking the product of two weighted automata, we take the usual cross product of the underlying automata, and add the cost matrices.\nWe show how to extract relevant string properties using multicostRegular constraints on the rows. In the following, we let v \u2208 V denote a value that the decision variables can take, we let v\u0302, w\u0302i \u2286 V (for indices i \u2208 N) denote a subset of these values, we let \u00acv\u0302 denote V \\v\u0302, and we let Z be a set of bounded variables representing the calculated weights. We also define the concatenation w\u03021 \u00b7 . . . \u00b7w\u0302m of several w\u0302i as the set {w1 \u00b7 \u00b7 \u00b7wm \u2208 V m | wi \u2208 w\u0302i, 1 \u2264 i \u2264 m}.\nTo extract the number of uninterrupted stretches of elements from v\u0302 in X using a resource variable zr \u2208 Z, we can use the weighted DFA Av\u03021 (Figure 2), where transitions are marked with the symbol and the cost cr they consume. For any word X , we have that multicostRegular(X,Z,Av\u03021 , c) holds for z r the number of stretches of symbols in v\u0302 that occur in X .\nTo extract whether a word w \u2208 w\u0302 occurs in X starting at position k using a resource variable zrk, we can use the weighted DFA A k,w\u0302 2 (Figure 3) with parameter k \u2208 N, where transitions are marked with the symbol and the cost cr they consume. For any wordX , we have that multicostRegular(X,Z,Ak,w\u03022 , c) sets zrk to true if and only if some word w \u2208 w\u0302 occurs in X starting at position k. To extract the total number of occurrences of words w \u2208 w\u0302 (starting any position) in X , we take the sum of the values of the variables zrk (for 1 \u2264 k \u2264 n) that represent whether a suitable word w occurs in X starting at position k.\nTo extract the minimum and maximum length of stretches, we can simulate counters using weights. Let A be a DFA annotated with counters d = (d1, . . . , dm), taking their values from {0, . . . , n \u2212 1}. We can construct a DFA A\u2032 of size less than or equal to nm \u00b7 |A|, together with a cost matrix c for resources r1, . . . , rm such that for any word w there exists an accepting run for w on A where the counters have final values (v1, . . . , vm) if and only if there exists an accepting run for w on A\u2032 for (z1, . . . , zm) = (v1, . . . , vm). This can be done straightforwardly by choosing Q\u00d7{0, . . . , n\u22121}m as state set for A\u2032, and choosing transitions \u2206 corresponding to the update formulae for the counters. Now c can be chosen to mimic the changes in counter values over transitions. The automaton A\u2032 can possibly be reduced in size by removing unreachable states or minimizing it using other methods.\nWe can transform any given automaton A to extract the minimum and maximum length of a stretch of symbols from v\u0302 occurring in A on X as follows.\nWe annotate A with counters that represent stretchminlen(v\u0302, n) and stretchmaxlen(v\u0302, n), as described in [5]. Then we transform this annotated automaton, as described above, into an automaton A\u2032 with resource variables zv\u0302min and zv\u0302max whose values (respectively) represent the minimum and maximum length of stretches of symbols in v\u0302 occurring in X .\nThe above automata, extracting the different string properties from rows, can be combined with each other and with other automata by using the product operation. By defining zero cost matrices for all resources not used explicitly in a given automaton, we can extract several different string properties simultaneously with one weighted product automaton.\nIn this more general decomposed setting with multicostRegular constraints on the rows, a tractable option for propagation is the algorithm based on a Lagrangian relaxation of the Resource Constrained Shortest Path Problem (RCSPP) from [7]. Using weighted automata to extract string properties has several advantages. The size of the automata is relatively low. The automata used to extract the number of stretch occurrences are even of constant size. A weighted automaton used to extract a string property is never larger than the unfolding of an (unweighted) automaton annotated with counters used to extract the same string property. Also, the use of weighted automata allows us to express several other constraints with small automata. For instance, Gcc constraints on the rows can be expressed by a weighted automaton with a single state. In fact, Gcc constraints can be expressed using additional weights on other automaton constraints already posed on the rows.\nUsing the above string properties, we can derive necessary conditions that exploit the matrix structure. Consider the following CSP, similar to the one sketched in [5]. Given three positive integers R, K, and V , we have an R \u00d7K matrix M of decision variables with domain {0, 1, . . . , V \u2212 1}, and a V \u00d7 K matrix M# of cardinality variables with domain {0, 1, . . . , R}. Each row r, for 0 \u2264 r < R, of M is subject to a multicostRegular constraint. For simplicity, we assume that each row is subject to the same constraint. Each column k, for 0 \u2264 k < K, of M is subject to a Gcc constraint that restricts the number of occurrences of the values according to column k of M#. Let #vk denote the number of occurrences of value v, for 0 \u2264 v < V , in column k of M, that is, the cardinality variable in row v and column k of M#. For any v\u0302 \u2286 V , we let #v\u0302k denote \u2211\nv\u2208v\u0302(# v k).\nIn order to constrain the number of occurrences of words, we define the bounds lwk(w\u0302) and uwk(w\u0302) on the number of occurrences of words in w\u0302 starting at column k, based on the Gcc constraints on the columns, as follows:\nlwk(w\u0302) = max\n\n\n\n\n|w\u0302|\u22121 \u2211\nj=0\n# w\u0302j k+j\n\n\u2212 (|w\u0302| \u2212 1) \u00b7 R, 0\n\n (1)\nuwk(w\u0302) = |w\u0302|\u22121\nmin j=0\n(\n# w\u0302j k+j\n)\n(2)\nNote that definitions (1) and (2) are exactly the same as in [5]. The lower bound (1) is the worst-case intersection of all column value occurrences. The upper bound (2) is justified by the fact that a word cannot occur more often than its minimally occurring letter. We now get the following necessary conditions for each 0 \u2264 k < K:\nlwk(w\u0302) \u2264 R\u22121 \u2211\nr=0\nzw\u0302r,k (3) uwk(w\u0302) \u2265 R\u22121 \u2211\nr=0\nzw\u0302r,k (4)\nwhere zw\u0302r,k denotes the resource variable representing whether a word in w\u0302 occurs in row r starting at column k. Since we extracted the number of word occurrences for each starting position k, we can directly relate the bounds derived from the column constraints with the number of word occurrences per starting position. This results in constraints (3) and (4) potentially leading to more propagation than their counterparts in [5]. This is illustrated in Example 1. Note that the constraints from [5] on words occurring as a prefix or as a suffix correspond to particular cases of constraints (3) and (4).\nExample 1. Consider the scenario concerning a partially instantiated 5 \u00d7 5 matrix in Figure 4, which could occur as a node in the search tree. Let w\u0302 = {2}{2}. In this scenario lwk(w\u0302) are variables. Also, zw\u0302r is a variable such that zw\u0302r = \u2211K\u22121 k=0 z w\u0302 r,k. In this scenario, the bounds of the variables z w\u0302 r,k can be automatically derived by the row automata. By using equation (3), we can directly detect unsatisfiability in this case, since lw1(w\u0302) \u2208 [3, 5] and thus lw1(w\u0302) 6\u2264 ( \u2211R\u22121 r=0 z w\u0302 r,1) \u2208 [0, 2]. Consider the counterpart of equation (3) from [5]: \u2211K\u2212|w\u0302|\nk=0 lwk(w\u0302) \u2264 \u2211R\u22121 r=0 z w\u0302 r . Using this constraint, unsatisfiability cannot\ndirectly be detected in this particular case.\nTake note of the following case, where w\u0302 = v\u0302 for some v\u0302 \u2286 V . In this case, for each 0 \u2264 k < K the constraints (1) and (2) and the constraints (3) and (4) simplify to, respectively:\nlwk(v\u0302) = uwk(v\u0302) = # v\u0302 k (5) # v\u0302 k =\nR\u22121 \u2211\nr=0\nzv\u0302r,k (6)\nIn order to constrain the number of occurrences of stretches, we define the bounds ls+k and us + k (referring to the number of uninterrupted stretches of variables from v\u0302 that start in column k) and the bounds ls\u2212k and us \u2212 k (referring to the number of uninterrupted stretches of variables from v\u0302 that end in column k),\nbased on the Gcc constrains as follows:\nls+k = max(0,# v\u0302 k \u2212# v\u0302 k\u22121) (7)\nus+k = # v\u0302 k \u2212max(0,# v\u0302 k\u22121 +# v\u0302 k \u2212R) (8)\nls\u2212k = max(0,# v\u0302 k \u2212# v\u0302 k+1) (9)\nus\u2212k = # v\u0302 k \u2212max(0,# v\u0302 k+1 +# v\u0302 k \u2212R) (10)\nDefinitions (7) through (10) are exactly the same as in [5]. The lower bound (7) is the difference between the number of occurrences of values v\u0302 in column k minus the number of occurrences of v\u0302 in column k \u2212 1, if positive. If the total number of occurrences of values v\u0302 on column k and on column k\u2212 1 are strictly greater than the number of rows R, then there must be at least #v\u0302k\u22121 +# v\u0302 k \u2212R stretches of values v\u0302 that cover both columns. This minimum intersection gives us the upper bound (8). Bounds (9) and (10) are derived similarly. We now get the following necessary conditions:\nK\u22121 \u2211\nk=0\nls+k (v\u0302) \u2264 R\u22121 \u2211\nr=0\nzv\u0302r (11)\nK\u22121 \u2211\nk=0\nus+k (v\u0302) \u2265 R\u22121 \u2211\nr=0\nzv\u0302r (12)\nK\u22121 \u2211\nk=0\nls\u2212k (v\u0302) \u2264 R\u22121 \u2211\nr=0\nzv\u0302r (13)\nK\u22121 \u2211\nk=0\nus\u2212k (v\u0302) \u2265 R\u22121 \u2211\nr=0\nzv\u0302r (14)\nwhere zv\u0302r denotes the variable corresponding to the resource that represents the number of uninterrupted sequences of symbols in v\u0302 occurring in row r.\nIn order to constrain the minimum and maximum length of a stretch, using the minimum and maximum length (zv\u0302min and z v\u0302 max, respectively) of uninterrupted sequences of symbols in v\u0302 occurring in any row, we get the following necessary conditions for each 0 \u2264 k < K:\n#v\u0302k \u2265 k \u2211\nj=max(0,k\u2212zv\u0302min+1)\nls+j (v\u0302) (15) #v\u0302k \u2265\nmin(K\u22121,k+zv\u0302min\u22121) \u2211\nj=k\nls\u2212j (v\u0302) (16)\nConstraints (15) and (16) are justified by the fact that stretches starting resp. ending at the considered columns j must overlap column k. Also, for each 0 \u2264 k < K \u2212 zv\u0302max we get the necessary condition:\nls+k (v\u0302) +\nzv\u0302max \u2211\nj=zv\u0302 min\n#v\u0302k+j \u2212 (z v\u0302 max \u2212 z v\u0302 min + 1) \u00b7R \u2264 0 (17)\nand for each zv\u0302max \u2264 k < K the necessary condition:\nls\u2212k (v\u0302) +\nzv\u0302max \u2211\nj=zv\u0302 min\n#v\u0302k\u2212j \u2212 (z v\u0302 max \u2212 z v\u0302 min + 1) \u00b7R \u2264 0 (18)\nThe justification behind constraint (17) is that for a stretch of values v\u0302 beginning at column k, there must be a value not in v\u0302 in some column j, for k + zv\u0302min \u2264 j \u2264 k + zv\u0302max. Constraint (18) is justified similarly."}, {"heading": "5 Evaluation", "text": "To evaluate our method, we used NSPLib [8], a library of benchmark instances of the nurse scheduling problem (NSP). This is a particular rostering problem. For N the number of nurses, D the number of days in the scheduling horizon, and S the number of shifts, the objective is to construct a N \u00d7 D matrix of values in the integer interval [1, S], where value S represents the off-duty shift.\nIn instance files, there are hard coverage constraints and soft preference constraints. We only consider the hard coverage constraints. These give for each day d and shift s the lower bound on the number of nurses that must be assigned to shift s on day d. These constraints can be modelled by Gcc constraints on the columns. We considered instance files forN\u00d77 rosters withN \u2208 {25, 50, 75, 100}.\nCase files provide hard constraints on the rows. For each shift s, there are lower and upper bounds on the number of occurrences of s in any row. There are also lower and upper bounds on the cumulative number of occurrences of the working shifts 1, . . . , S \u2212 1 in any row. These two types of constraints can be modelled by Gcc constraints on the rows. For each shift s, there are also lower and upper bounds on the length of any stretch of value s in any row. Finally, there are lower and upper bounds on the length of any stretch of working shifts 1, . . . , S \u2212 1 in any row. These two types of constraints can be modelled by stretch path and stretch path partition constraints on the rows, respectively. By translating these row constraints to automata, we get that the NSP benchmark problems as described above correspond to the RegularGcc pattern studied in this paper.\nIn order to compare the effect of the necessary conditions in the settings of both weighted and unweighted automata, we implemented the row constraints (both for the constraints from the case files and for extracting string properties) using weighted finite automata as well as regular (unweighted) finite automata. For the setting of unweighted automata, we translated the case constraints specified for each shift and for the total set of working shifts as a single Regular constraint on each row (by taking the corresponding minimised product DFA). For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values. The methods used in [5] for automata annotated with counters are not implemented in the free major constraint programming libraries and solvers.\nFor the setting of weighted automata. We translated the case constraints for each shift and for the total set of working shifts as a single multicostRegular constraint on each row (by taking the corresponding product automaton). For each string property that we extract from the rows, we posed a single multi-\ncostRegular constraint defined by the corresponding weighted automaton as described in Section 4.\nIn order to compare the two settings fairly, we posed the constraints defined by automata in a similar pattern, i.e., we take the products of corresponding automata in the two settings. One advantage that the setting of weighted automata possesses, is that taking the product of particular automata results in a relatively small increase in the automaton size, not nearly as explosive as the size increase in the corresponding unweighted product automaton. In order to improve propagation, we were able to pose the weighted automata extracting the number of stretches of different shifts from the rows as the product of the corresponding automaton with (a copy of) the automata specifying the constraints on the number of shift occurrences from the case file. In the unweighted setting this is completely intractable, since the size of the product DFA corresponding to the automata annotated with counters gets too large.\nIn both settings, we implemented necessary constraints based on the following string properties:\n\u2013 for each shift, lower and upper bounds on the number of its occurrences, \u2013 for each shift, lower and upper bounds on the number and length of its\nstretches, \u2013 each word of length at most 2 that consists of one single shift.\nIn the setting of weighted automata, the necessary constraints are derived as described in Section 4. In the setting of unweighted automata, the necessary constraints are derived as in [5].\nThe objective of our experiments is to measure the impact in runtime and backtracks for the different settings. The experiments were run under Choco 2.1.1 on a 2.27 GHz Intel Xeon with a 4GB RAM. All runs were allocated 3 CPU minutes. For each case and nurse count N , we used instances 1-270.\nIn the experiments we used a labelling procedure that selects variables with the smallest domain, with a row-wise order as tie-breaker, and selects the smallest value. We used a LexChain constraint for symmetry breaking. We used the implementation of the multicostRegular constraint available in Choco.\nTable 1 summarises the running of the instances for the different settings (the setting of weighted automata with cross products (CWA) and without extra cross products (WA), and the setting of unweighted automata (UA)), for Cases 7 and 8. Each row first indicates the number of known instances of some satisfiability status for a given case and nurse count N , and then the performance of each setting to the first solution, namely the number of instances decided to be of that status without timing out, as well as the average runtime (in seconds) and the average number of backtracks for all instances on which none of the settings timed out. Numbers in boldface indicate best performance in a row.\nThe benchmark results in Table 1 show that WA and CWA were able to solve significantly more instances compared to the method using unweighted automata, both for satisfiable and unsatisfiable instances. Further, CWA improved the performance for most of the benchmarks in terms of number of backtracks and runtime, compared to WA. Notably, the UA method solved only 4 out of 156\nknown unsatisfiable instances while CWA and UA solved all of these benchmarks. This shows that using weighted automata together with necessary constraints leads to significantly more pruning than using unweighted automata with similar necessary constraints. For the majority of solved unsatisfiable instances, WA and CWA detected unsatisfiability at the root of the search tree. This is not visible in the table, because the shown runtimes and number of backtracks are based on instances solved by all methods. Note that these benchmarking results are not directly comparable to the results in [5], since these results were obtained under a different experimental set-up (e.g. a different search strategy was used).\nOverall, the results indicate that the use of weighted automata to solve rostering problems shows potential. A combination of weighted automata and necessary constraints dramatically increase propagation compared to using unweighted automata. Our results on unsatisfiable instances suggest that such a combination can be very useful in finding optimum solutions for rostering problems. Another advantage of our approach is that it can be easily implemented in open-source constraint solvers."}, {"heading": "6 Conclusions", "text": "We studied the propagation of the RegularGcc matrix constraint. We showed that propagation is NP-hard, even under some strong restrictions, and also showed two cases in which propagation is fixed parameter tractable. Additionally, we showed how to improve propagation over a decomposition into separate Regular constraints on the rows and Gcc constraints on the columns by identifying some necessary but insufficient conditions. We showed how the use of weighted automata for the row constraints can be beneficial. Experimental results on nurse scheduling problems demonstrate the potential for this method."}], "references": [{"title": "Matrix modelling", "author": ["P. Flener", "A.M. Frisch", "B.H.Z. Kzlltan", "I. Miguel", "T. Walsh"], "venue": "Proceedings of the International Workshop on Modelling and Problem Formulation.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2001}, {"title": "Matrix modelling: Exploiting common patterns in constraint programming", "author": ["P. Flener", "A.M. Frisch", "B.H.Z. Kzlltan", "I. Miguel", "T. Walsh"], "venue": "Proceedings of the International Workshop on Reformulating Constraint Satisfaction Problems.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2002}, {"title": "The Cardinality Matrix Constraint", "author": ["J.C. R\u00e9gin", "C.P. Gomes"], "venue": "In Wallace, M., ed.: Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming (CP\u201904). Volume 3258 of Lecture Notes in Computer Science., Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2004}, {"title": "Global matrix constraints", "author": ["George Katsirelos", "C.G.Q. Nina Narodytska", "T. Walsh"], "venue": "Proceedings of the International Workshop on Constraint Modelling and Reformulation.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "On matrices, automata, and double counting", "author": ["N. Beldiceanu", "M. Carlsson", "P. Flener", "J. Pearson"], "venue": "In Lodi, A., Milano, M., Toth, P., eds.: Proceedings of the 7th International Conference on Integration of AI and OR Techniques in Constaint Programming for Combinatorial Optimization Problems (CPAIOR\u201910). Volume 6140 of Lecture Notes in Computer Science., Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Sequencing and Counting with the multicost-regular Constraint", "author": ["J. Menana", "S. Demassey"], "venue": "In van Hoeve, W.J., Hooker, J.N., eds.: Proceedings of the 6th International Conference on Integration of AI and OR Techniques in Constaint Programming for Combinatorial Optimization Problems (CPAIOR\u201909). Volume 5547 of Lecture Notes in Computer Science., Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2009}, {"title": "On the characterization and generation of nurse scheduling problem instances", "author": ["M. Vanhoucke", "B. Maenhout"], "venue": "European Journal of Operational Research 196(2)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2009}, {"title": "Global grammar constraints", "author": ["C.G. Quimper", "T. Walsh"], "venue": "In Benhamou, F., ed.: Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming (CP\u201906). Volume 4204., Springer", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [{"referenceID": 0, "context": "Many such models contain matrices of decision variables [1\u20133].", "startOffset": 56, "endOffset": 61}, {"referenceID": 1, "context": "Many such models contain matrices of decision variables [1\u20133].", "startOffset": 56, "endOffset": 61}, {"referenceID": 2, "context": "Many such models contain matrices of decision variables [1\u20133].", "startOffset": 56, "endOffset": 61}, {"referenceID": 3, "context": "Matrix constraints are global constraints that apply to such matrices [4].", "startOffset": 70, "endOffset": 73}, {"referenceID": 4, "context": "Therefore, as in [5], we look for partial methods that only enforce a limited level of consistency.", "startOffset": 17, "endOffset": 20}, {"referenceID": 3, "context": "Proof: This follows directly from Observation 2 in [4], and the fact that Gcc over a sequence with fixed size can be encoded in a DFA with polynomially many states.", "startOffset": 51, "endOffset": 54}, {"referenceID": 1, "context": "Enforcing BC on RegularGcc is W[2]-hard in k = R the number of rows, even with just 2 values.", "startOffset": 31, "endOffset": 34}, {"referenceID": 3, "context": "Proof: This proof is similar to the proof of Theorem 3 in [4].", "startOffset": 58, "endOffset": 61}, {"referenceID": 1, "context": "Enforcing BC on the Regular matrix constraint is W[2]-hard in k the number of rows, even with just 2 values.", "startOffset": 50, "endOffset": 53}, {"referenceID": 1, "context": "Enforcing BC on the RegularSum matrix constraint is W[2]hard in k the number of rows, even with just 3 values.", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "Proof: (Sketch) The proof is similar to the proof of Theorem 7 and the proof of Theorem 3 in [4].", "startOffset": 93, "endOffset": 96}, {"referenceID": 0, "context": "Note that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4].", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "Note that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4].", "startOffset": 105, "endOffset": 108}, {"referenceID": 4, "context": "In fact, we will show how to extend the method of [5] to the (decomposed) setting of multicostRegular constraints on the rows andGcc constraints on the columns.", "startOffset": 50, "endOffset": 53}, {"referenceID": 5, "context": "The multicostRegular global constraint [7] is defined as follows.", "startOffset": 39, "endOffset": 42}, {"referenceID": 4, "context": "We annotate A with counters that represent stretchminlen(v\u0302, n) and stretchmaxlen(v\u0302, n), as described in [5].", "startOffset": 106, "endOffset": 109}, {"referenceID": 5, "context": "In this more general decomposed setting with multicostRegular constraints on the rows, a tractable option for propagation is the algorithm based on a Lagrangian relaxation of the Resource Constrained Shortest Path Problem (RCSPP) from [7].", "startOffset": 235, "endOffset": 238}, {"referenceID": 4, "context": "Consider the following CSP, similar to the one sketched in [5].", "startOffset": 59, "endOffset": 62}, {"referenceID": 4, "context": "Note that definitions (1) and (2) are exactly the same as in [5].", "startOffset": 61, "endOffset": 64}, {"referenceID": 4, "context": "This results in constraints (3) and (4) potentially leading to more propagation than their counterparts in [5].", "startOffset": 107, "endOffset": 110}, {"referenceID": 4, "context": "Note that the constraints from [5] on words occurring as a prefix or as a suffix correspond to particular cases of constraints (3) and (4).", "startOffset": 31, "endOffset": 34}, {"referenceID": 2, "context": "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(\u0175) \u2208 [3, 5] and thus lw1(\u0175) 6\u2264 ( \u2211R\u22121 r=0 z \u0175 r,1) \u2208 [0, 2].", "startOffset": 92, "endOffset": 98}, {"referenceID": 4, "context": "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(\u0175) \u2208 [3, 5] and thus lw1(\u0175) 6\u2264 ( \u2211R\u22121 r=0 z \u0175 r,1) \u2208 [0, 2].", "startOffset": 92, "endOffset": 98}, {"referenceID": 1, "context": "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(\u0175) \u2208 [3, 5] and thus lw1(\u0175) 6\u2264 ( \u2211R\u22121 r=0 z \u0175 r,1) \u2208 [0, 2].", "startOffset": 140, "endOffset": 146}, {"referenceID": 4, "context": "[5]: K\u2212|\u0175| k=0 lwk(\u0175) \u2264 \u2211R\u22121 r=0 z \u0175 r .", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 13, "endOffset": 19}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 30, "endOffset": 36}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 45, "endOffset": 51}, {"referenceID": 2, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 61, "endOffset": 67}, {"referenceID": 4, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 61, "endOffset": 67}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 78, "endOffset": 84}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 93, "endOffset": 99}, {"referenceID": 1, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 109, "endOffset": 115}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 136, "endOffset": 142}, {"referenceID": 4, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 152, "endOffset": 158}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 179, "endOffset": 185}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 217, "endOffset": 223}, {"referenceID": 4, "context": "Definitions (7) through (10) are exactly the same as in [5].", "startOffset": 56, "endOffset": 59}, {"referenceID": 6, "context": "To evaluate our method, we used NSPLib [8], a library of benchmark instances of the nurse scheduling problem (NSP).", "startOffset": 39, "endOffset": 42}, {"referenceID": 4, "context": "For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values.", "startOffset": 114, "endOffset": 117}, {"referenceID": 7, "context": "For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values.", "startOffset": 195, "endOffset": 198}, {"referenceID": 4, "context": "The methods used in [5] for automata annotated with counters are not implemented in the free major constraint programming libraries and solvers.", "startOffset": 20, "endOffset": 23}, {"referenceID": 4, "context": "In the setting of unweighted automata, the necessary constraints are derived as in [5].", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "Note that these benchmarking results are not directly comparable to the results in [5], since these results were obtained under a different experimental set-up (e.", "startOffset": 83, "endOffset": 86}], "year": 2016, "abstractText": "We study propagation of the RegularGcc global constraint. This ensures that each row of a matrix of decision variables satisfies a Regular constraint, and each column satisfies a Gcc constraint. On the negative side, we prove that propagation is NP-hard even under some strong restrictions (e.g. just 3 values, just 4 states in the automaton, or just 5 columns to the matrix). On the positive side, we identify two cases where propagation is fixed parameter tractable. In addition, we show how to improve propagation over a simple decomposition into separate Regular and Gcc constraints by identifying some necessary but insufficient conditions for a solution. We enforce these conditions with some additional weighted row automata. Experimental results demonstrate the potential of these methods on some standard benchmark problems.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}