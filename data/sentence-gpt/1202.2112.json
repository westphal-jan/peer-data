{"id": "1202.2112", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2012", "title": "Predicting Contextual Sequences via Submodular Function Maximization", "abstract": "Sequence optimization, where the items in a list are ordered to maximize some reward has many applications such as web advertisement placement, search, and control libraries in robotics. Previous work in sequence optimization produces a static ordering that does not take any features of the item or context of the problem into account. In this work, we propose a general approach to order the items within the sequence based on the context (e.g., perceptual information, environment description, and goals). We take a simple, efficient, reduction-based approach where the choice and order of the items is established by repeatedly learning simple classifiers or regressors for each \"slot\" in the sequence. Our approach leverages recent work on submodular function maximization to provide a formal regret reduction from submodular sequence optimization to simple cost-sensitive prediction. We apply our contextual sequence prediction algorithm to optimize control libraries and demonstrate results on two robotics problems: manipulator trajectory prediction and mobile robot path planning. We demonstrate an efficient and efficient, reduced approach in robotics. In addition, we demonstrate that the optimization in this particular example will produce predictable patterns with small and large dimensions, making it more difficult to predict the result, as shown in Figure 2. This results in a novel decision-making approach that has not yet been developed in the field of human machine learning. We show that the optimization for the control library was implemented in both robotics and machine learning, and to facilitate the reduction of submodular sequence optimization to simple cost-sensitive prediction. In addition, we demonstrate that the optimization in this particular example will produce predictable patterns with small and large dimensions, making it more difficult to predict the result, as shown in Figure 2. This results in a novel decision-making approach that has not yet been developed in the field of human machine learning. We show that the optimization in this particular example will produce predictable patterns with small and large dimensions, making it more difficult to predict the result, as shown in Figure 2. This results in a novel decision-making approach that has not yet been developed in the field of human machine learning. We demonstrate that the optimization in this particular example will produce predictable patterns with small and large dimensions, making it more difficult to predict the result, as shown in Figure 2. This results in a novel decision-making approach that has not yet been developed in the field of human machine learning. We demonstrate that the optimization in this particular example will produce predictable patterns with small and large dimensions, making it more difficult to predict the result, as shown in Figure 2. This results in", "histories": [["v1", "Thu, 9 Feb 2012 20:48:22 GMT  (989kb,D)", "http://arxiv.org/abs/1202.2112v1", "8 pages"]], "COMMENTS": "8 pages", "reviews": [], "SUBJECTS": "cs.AI cs.LG cs.RO", "authors": ["debadeepta dey", "tian yu liu", "martial hebert", "j", "rew bagnell"], "accepted": false, "id": "1202.2112"}, "pdf": {"name": "1202.2112.pdf", "metadata": {"source": "CRF", "title": "Predicting Contextual Sequences via Submodular Function Maximization", "authors": ["Debadeepta Dey", "Tian Yu Liu", "Martial Hebert", "Andrew Bagnell"], "emails": ["dbagnell)@ri.cmu.edu"], "sections": [{"heading": null, "text": "I. INTRODUCTION\nOptimizing the order of a set of choices is fundamental to many problems such as web search, advertisement placements as well as in robotics and control. Relevance and diversity are important properties of an optimal ordering or sequence. In web search, for instance, if the search term admits many different interpretations then the results should be interleaved with items from each interpretation [16]. Similarly in advertisement placement on web pages, advertisements should be chosen such that within the limited screen real estate they are diverse yet relevant to the page content. In robotics, control libraries have the same requirements for relevance and diversity in the ordering of member actions. In this paper, we apply sequence optimization to develop near-optimal control libraries. In the context of control libraries, a sequence refers to a ranked list of control action choices rather than a series of actions to be taken. Examples of control actions include grasps for manipulation, trajectories for mobile robot navigation or seed trajectories for initializing a local trajectory optimizer.\nControl libraries are a collection of control actions obtained by sampling a useful set of often high dimensional control trajectories or policies. Examples of control libraries include a collection of feasible grasps for manipulation [5], a collection of feasible trajectories for mobile robot navigation [9], and a collection of expert-demonstrated trajectories for a walking robot (Stolle et. al. [20]). Similarly, recording demonstrated trajectories of experts aggressively flying unmanned aerial vehicles (UAVs) has enabled dynamically feasible trajectories\nto be quickly generated by concatenating a suitable subset of stored trajectories in the control library [8].\nSuch libraries are an effective means of spanning the space of all feasible control actions while at the same time dealing with computational constraints. The performance of control libraries on the specified task can be significantly improved by careful consideration of the content and order of actions in the library. To make this clear let us consider specific examples:\nMobile robot navigation. In mobile robot navigation the task is to find a collision-free, low cost of traversal path which leads to the specified goal on a map. Since sensor horizons are finite and robots usually have constrained motion models and non-trivial dynamics, a library of trajectories respecting the dynamic and kinematic constraints of the robot are precomputed and stored in memory. This constitutes the control library. It is desired to sample a subset of trajectories at every time step so that the overall cost of traversal of the robot from start to goal is minimized.\nTrajectory optimization. Local trajectory optimization techniques are sensitive to initial trajectory seeds. Bad trajectory initializations may lead to slow optimization, suboptimal performance, or even remain in collision. In this setting, the control actions are end-to-end trajectory seeds that act as input to the optimization. Zucker [27] and Jetchev et al. [11] proposed methods for predicting trajectories from a precomputed library using features of the environment, yet these methods do not provide recovery methods when the prediction fails. Having a sequence of initial trajectory seeds provides fallbacks should earlier ones fail.\nGrasp libraries. During selection of grasps for an object, a library of feasible grasps can be evaluated one at a time until a collision-free, reachable grasp is found. While a naive ordering of grasps can be based on force closure and stability criteria [2], if a grasp fails, then grasps similar to it are also likely to fail. A more principled ordering approach which takes into account features of the environment can reduce depth of the sequence that needs to be searched by having diversity in higher ranked grasps.\nCurrent state-of-the-art methods in the problems we address either predict only a single control action in the library that has the highest score for the current environment, or use an ad-hoc ordering of actions such as random order or by past rate of success. If the predicted action fails then systems (e.g. manipulators and autonomous vehicles) are unable to\nar X\niv :1\n20 2.\n21 12\nv1 [\ncs .A\nI] 9\nF eb\n2 01\n2\nrecover or have to fall back on some heuristic/hard-coded contingency plan. Predicting a sequence of options to evaluate is necessary for having intelligent, robust behavior. Choosing the order of evaluation of the actions based on the context of the environment leads to more efficient performance.\nA naive way of predicting contextual sequences would be to train a multi-class classifier over the label space consisting of all possible sequences of a certain length. This space is exponential in the number of classes and sequence length posing information theoretic difficulties. A more reasonable method would be to use the greedy selection technique by Steeter et al. [21] over the hypothesis space of all predictors which is guaranteed to yield sequences within a constant factor of the optimal sequence. Implemented naively, this remains expensive as it must explicitly enumerate the label space. Our simple reduction based approach where we propose to train multiple multi-class classifiers/regressors to mimic greedy selection given features of the environment is both efficient and maintains performance guarantees of the greedy selection.\nPerception modules using sensors such as cameras and lidars are part and parcel of modern robotic systems. Leveraging such information in addition to the feedback of success or failure is conceptually straightforward: instead of considering a sequence of control actions, we consider a sequence of classifiers which map features X to control actions A, and attempt to find the best such classifier at each slot in the control action sequence. By using contextual features, our method has the benefit of closing the loop with perception while maintaining the performance guarantees in Streeter et al.[21].\nThe outlined examples present loss functions that depend only on the \u201cbest\u201d action in the sequence, or attempt to minimize the prediction depth to find a satisfactory action. Such loss functions are monotone, submodular \u2013 i.e., one with diminishing returns.1 We define these functions in section II and review the online submodular function maximization approach of Streeter et al. [21]. We also describe our contextual sequence optimization (CONSEQOPT) algorithm in detail. Section III shows our algorithm\u2019s performance improvement over alternatives for local trajectory optimization for manipulation and in path planning for mobile robots.\nOur contributions in this work are: \u2022 We propose a simple, near-optimal reduction for contex-\ntual sequence optimization. Our approach moves from predicting a single decision based on features to making a sequence of predictions, a problem that arises in many domains including advertisement prediction [22, 16] and search. \u2022 The application of this technique to the contextual optimization of control libraries. We demonstrate the efficacy of the approach on two important problems: robot manipulation planning and mobile robot navigation. Using\n1For more information on submodularity and optimization of submodular functions we refer readers to the tutorial [4].\nthe sequence of actions generated by our approach we observe improvement in performance over sequences generated by either random ordering or decreasing rate of success of the actions. \u2022 Our algorithm is generic and can be naturally applied to any problem where ordered sequences (e.g., advertisement placement, search, recommendation systems, etc) need to be predicted and relevance and diversity are important."}, {"heading": "II. CONTEXTUAL OPTIMIZATION OF SEQUENCES", "text": ""}, {"heading": "A. Background", "text": "The control library is a set V of actions. Each action is denoted by a \u2208 V . 2 Formally, a function f : S \u2192 \u211c+ is monotone submodular for any sequence S \u2208S where S is the set of all sequences of actions if it satisfies the following two properties: \u2022 (Monoticity) for any sequence S1,S2 \u2208S , f (S1)\u2264 f (S1\u2295\nS2) and f (S2)\u2264 f (S1\u2295S2) \u2022 (Submodularity) for any sequence S1,S2 \u2208S , f (S1) and\nany action a \u2208 V , f (S1\u2295S2\u2295\u3008a\u3009)\u2212 f (S1\u2295S2)\u2264 f (S1\u2295 \u3008a\u3009)\u2212 f (S1) where \u2295 denotes order dependent concatenation of sequences. These imply that the function always increases as more actions are added to the sequence (monotonicity) but the gain obtained by adding an action to a larger pre-existing sequence is less as compared to addition to a smaller pre-existing sequence (sub-modularity).\nFor control library optimization, we attempt to optimize one of two possible criteria: the cost of the best action a in a sequence (with a budget on sequence size) or the time (depth in sequence) to find a satisficing action. For the former, we consider the function,\nf \u2261 No\u2212min(cost(a1),cost(a2), . . . ,cost(aN)) No , (1)\nwhere cost is an arbitrary cost on an action (ai) given an environment and No is a constant, positive normalizer which is the highest cost. 3 Note that the f takes in as arguments the sequence of actions a1,a2, . . . ,aN directly, but is also implicitly dependent on the current environment on which the actions are evaluated in cost(ai). Dey et al. [6] prove that this criterion is monotone submodular in sequences of control actions and can be maximized\u2013 within a constant factor\u2013 by greedy approaches similar to Streeter et al. [21].\nFor the latter optimization criteria, which arises in grasping and trajectory seed selectin, we define the monotone, submodular loss function f : S \u2192 [0,1] as f \u2261 P(S) where P(S) is the probability of successfully grasping an object in\n2In this work we assume that each action choice takes the same time to execute although the proposed approach can be readily extended to handle different execution times.\n3For mobile robot path planning, for instance, cost(ai) is typically a simple measure of mobility penalty based on terrain for traversing a trajectory ai sampled from a set of trajectories and terminating in a heuristic cost-to-go estimate, compute by, e.g. A*.\na given scenario using the sequence of grasps provided. It is easy to check [6] that this function is also monotone and submodular, as the probability of success always increases as we consider additional elements. Minimizing the depth in the control library to be evaluated becomes our goal. In the rest of the paper all objective functions are assumed to be monotone submodular unless noted otherwise.\nWhile optimizing these over library actions is effective, the ordering of actions does not take into account the current context. People do not attempt to grasp objects based only on previous performance of grasps: they take into account the position, orientation of the object, the proximity and arrangement of clutter around the object and also their own position relative to the object in the current environment."}, {"heading": "B. Our Approach", "text": "We consider functions that are submodular over sequences of either control actions themselves or, crucially, over classifiers that take as input environment features X and map to control actions V . Additionally, by considering many environments, the expectation of f in equation (1) over these environments also maintains these properties. In our work, we always consider the expected loss averaged over a (typically empirical) distribution of environments.\nIn Algorithm 1, we present a simple approach for learning such a near-optimal contextual control library."}, {"heading": "C. Algorithm for Contextual Submodular Sequence Optimization", "text": "Figure 1 shows the schematic diagram for algorithm 1 which trains a classifier for each slot of the sequence. Define matrix X to be the set of features from a distribution of example environments (one feature vector per row) and matrix Y to be the corresponding target action identifier for each example. Let each feature vector contain L attributes. Let D be the set of example environments containing |D| examples. The size of X is |D|\u00d7L and size of Y is |D|\u00d7 1. We denote the ith classifier by \u03c0i. Define MLi to be the matrix of marginal losses for each environment for the ith slot of the sequence. In the parlance of cost-sensitive learning MLi is the exampledependent cost matrix. MLi is of dimension |D|\u00d7 |V |. Each row of MLi contains, for the corresponding environment, the loss suffered by the classifier for selecting a particular action a \u2208 V . The most beneficial action has 0 loss while others have non-zero losses. These losses are normalized to be within [0\u22121]. We detail how to calculate the entries of MLi below. Classifier inputs are the set of feature vectors X for the dataset of environments and the marginal loss matrix MLi .\nFor ease of understanding let us walk through the training of the first two classifiers \u03c01 and \u03c02.\nConsider the first classifier training in Figure 1 and its inputs X and ML1 . Consider the first row of ML1 . Each element of this row corresponds to the loss incurred if the corresponding action in V were taken on the corresponding environment whose features are in the first row of X. The best action has 0 loss while all the others have relative losses in the range [0\u22121]\ndepending on how much worse they are compared to the best action. This way the rest of the rows in ML1 are filled out. The cost sensitive classifier \u03c01 is trained. The set of features X from each environment in the training set are again presented to it to classify. The output is matrix Y\u03c01 which contains the selected action for the 1st slot for each environment. As no element of the hypothesis class performs perfectly this results in Y\u03c01 , where not every environment had the 0 loss action picked.\nConsider the second classifier training in Figure 1. Consider the first row of ML2 . Suppose control action id 13 was selected by classifier \u03c01 in the classification step for the first environment, which provides a gain of 0.6 to the objective function f i.e. f [13] = 0.6. For each of the control actions a present in the library V find the action which provides maximum marginal improvement i.e. amax = argmaxa( f ([13,a])\u2212\nAlgorithm 1 Algorithm for training CONSEQOPT using classifiers Input: sequence length N, multi-class cost sensitive classifier routine \u03c0, dataset D of |D| number of environments and associated features X, library of control actions V Output: sequence of classifiers \u03c01,\u03c02, . . . ,\u03c0N 1: for i = 1 to N do 2: MLi \u2190 computeTargetActions(X,Y\u03c01,\u03c02,...,\u03c0i\u22121 ,V ) 3: \u03c0i\u2190 train(X,MLi) 4: Y\u03c0i \u2190 classify(X) 5: end for\nAlgorithm 2 Algorithm for training CONSEQOPT using regressors Input: sequence length N, regression routine \u211c, dataset D of |D| number of\nenvironments, library of control actions V Output: sequence of regressors \u211c1,\u211c2, . . . ,\u211cN\n1: for i = 1 to N do 2: Xi,MBi \u2190 computeFeatures&Benefit(D,Y\u211c1,\u211c2,...,\u211ci\u22121 ,V ) 3: \u211ci\u2190 train(Xi,MBi) 4: M\u0303Bi \u2190 regress(Xi,\u211ci) 5: Y\u211ci = argmax(M\u0303Bi) 6: end for\nf ([13])) = argmaxa( f ([13,a])\u2212 0.6. Additionally convert the marginal gains computed for each a in the library to proportional losses and store in the first row of ML2 . If amax is the action with the maximum marginal gain then the loss for each of the other actions is f ([13,amax])\u2212 f ([13,a]). amax has 0 loss while other actions have >= 0 loss. The rest of the rows are filled up similarly. \u03c02 is trained, and evaluated on same dataset to produce Y\u03c02 .\nThis procedure is repeated for all N slots producing a sequence of classifiers \u03c01,\u03c02, . . . ,\u03c0N. The idea is that a classifier must suffer a high loss when it chooses a control action which provides little marginal gain when a higher gain action was available. Any cost-sensitive multi-class classifier may be used.\nDuring test time, for a given environment features are extracted, and the classifiers associated with each slot of the sequence outputs a control action to fill the slot. This sequence can then be evaluated as usual. This procedure is formalized in Algorithm 1. In computeTargetActions the previously detailed procedure for calculating the entries of the marginal loss matrix MLi for the i\nth slot is carried out, followed by the training step in train and classification step in classify.\nAlgorithm 2 has a similar structure as algorithm 1. This alternate formulation has the advantage of being able to add actions to the control library without retraining the sequence of classifiers. Instead of directly identifying a target class, we use a squared-loss regressor in each slot to produce an estimate of the marginal benefit from each action at that particular slot. Hence MBi is a |D|\u00d7|V | matrix of the actual marginal benefit computed in a similiar fashion as MLi of Algorithm 1, and M\u0303Bi is the estimate given by our regressor at ith slot. In line 2 we compute the feature matrix Xi. In this case, a feature vector\nis computed per action per environment, and uses information from the previous slots\u2019 target choice Y\u211ci . For feature vectors of length L, Xi has dimensions |D||V |\u00d7L. The features and marginal benefits at ith slot are used to train regressor \u211ci, producing the estimate M\u0303Bi . We then pick the action a which produces the maximum M\u0303Bi to be our target choice Y\u211ci , a |D| length vector of indices into V for each environment."}, {"heading": "D. Reduction Argument", "text": "We establish a formal regret reduction [3] between cost sensitive multi-class classification error and the resulting error on the learned sequence of classifiers. Specifically, we demonstrate that if we consider the control actions to be the classes and train a series of classifiers\u2013 one for each slot of the sequence\u2013 on the features of a distribution of environments then we can produce a near-optimal sequence of classifiers. This sequence of classifiers can be invoked to approximate the greedy sequence constructed by allowing additive error in equation (3).\nTheorem 1. If each of the classifiers (\u03c0i) trained in Algorithm 1 achieves multi-class cost-sensitive regret of ri, then the resulting sequence of classifiers is within at least (1\u2212 1e )maxS\u2208S f (S)\u2212\u2211 N i=1 ri of the optimal such sequence of classifiers S from the same hypothesis space. 4\nProof: (Sketch) Define the loss of a multi-class, cost-sensitive classifier \u03c0 over a distribution of environments D as l(\u03c0,D). Each example can be represented as (xn,m1n,m 2 n,m 3 n, . . . ,m |V | n ) where xn is the set\n4When the objective is to minimize the time (depth in sequence) to find a satisficing element then the resulting sequence of classifiers f (S\u0302\u3008N\u3009)\u2264 4 \u222b \u221e 0 1\u2212 maxS\u2208S f (S\u3008n\u3009)dn+\u2211Ni=1 ri.\nof features representing the nth example environment and m1n,m 2 n,m 3 n, . . . ,m |V | n are the per class costs of misclassifying xn. m1n,m 2 n,m 3 n, . . . ,m |V | n are simply the nth row of MLi (which corresponds to the nth environment in the dataset D). The best class has a 0 misclassification cost and while others are greater than equal to 0 (There might be multiple actions which will yield equal marginal benefit). Classifiers generally minimize the expected loss l(\u03c0,D) = E\n(xn,m1n,m2n,m3n,...,m |V | n )\u223cD\n[C\u03c0(xn)] where\nC\u03c0(xn) = m \u03c0(xn) n denotes the example-dependent multi-class misclassification cost. The best classifier in the hypothesis space \u03a0 minimizes l(\u03c0,D)\n\u03c0\u2217 = argmin \u03c0\u2208\u03a0 E (xn,m1n,m2n,m3n,...,m |V | n )\u223cD [C\u03c0(xn)] (2)\nThe regret of \u03c0 is defined as r = l(\u03c0,D)\u2212 l(\u03c0\u2217,D). Each classifier associated with ith slot of the sequence has a regret ri.\nStreeter et al. [21] consider the case where the ith decision made by the greedy algorithm is performed with additive error \u03b5i. Denote by S\u0302 = \u3008s\u03021, s\u03022, . . . , s\u0302N\u3009 a variant of the sequence S in which the ith argmax is evaluated with additive error \u03b5i. This can be formalized as\nf (S\u0302i\u2295 s\u0302i)\u2212 f (S\u0302i)\u2265max si\u2208V f (S\u0302i\u2295 si)\u2212 f (S\u0302i)\u2212 \u03b5i (3)\nwhere S\u03020 = \u3008\u3009, S\u0302i = \u3008s\u03021, s\u03022, s\u03023, . . . , s\u0302i\u22121\u3009 for i\u2265 1 and si is the predicted control action by classifier \u03c0i. They demonstrate that, for a budget or sequence length of N\nf (S\u0302\u3008N\u3009)\u2265 (1\u2212 1 e )max S\u2208S f (S)\u2212\nN\n\u2211 i=1 \u03b5i (4)\nassuming each control action takes equal time to execute. Thus the ith argmax in equation (3) is chosen with some error \u03b5i = ri. An \u03b5i error made by classifier \u03c0i corresponds to the classifier picking an action whose marginal gain is \u03b5i less than the maximum possible. Hence the performance bound on additive error greedy sequence construction stated in equation (4) can be restated as\nf (S\u0302\u3008N\u3009)\u2265 (1\u2212 1 e )max S\u2208S f (S)\u2212\nN\n\u2211 i=1 ri (5)\nTheorem 2. The sequence of squared-loss regressors (\u211ci) trained in Algorithm 2 is within at least (1\u2212 1e )maxS\u2208S f (S)\u2212 \u2211Ni=1 \u221a 2(|V |\u22121)rregi of the optimal sequence of classifiers S from the hypothesis space of multi-class cost-sensitive classifiers.\nProof: (Sketch) Langford et al. [14] show that the regret reduction from multi-class classification to squared-loss regression has a regret reduction of \u221a 2(|k|\u22121)rreg where k is the number of classes and rreg is the squared-loss regret on the underlying regression problem. In Algorithm 2 we use squared-loss regression to perform multi-class classification thereby incurring for each slot of the sequence a reduction\nregret of \u221a\n2(|V |\u22121)rregi where |V | is the number of actions in the control library. Theorem 1 states that the sequence of classifiers is within at least f (S\u0302\u3008N\u3009)\u2265 (1\u2212 1e )maxS\u2208S f (S)\u2212 \u2211Ni=1 ri of the optimal sequence of classifiers. Plugging in the regret reduction from [14] we get the result that the resulting sequence of regressors in Algorithm 2 is within at least (1\u2212 1e )maxS\u2208S f (S)\u2212\u2211 N i=1 \u221a 2(|V |\u22121)rregi of the optimal sequence of multi-class cost-sensitive classifiers."}, {"heading": "III. CASE STUDIES", "text": ""}, {"heading": "A. Robot Manipulation Planning via Contextual Control Libraries", "text": "We demonstrate the application of CONSEQOPT for manipulation planning on a 7 degree of freedom manipulator.\nRecent work [18, 11] has shown that by relaxing the hard constraint of avoiding obstacles into a soft penalty term on collision, simple local optimization techniques can quickly lead to smooth, collision-free trajectories suitable for robot execution. Often the default initialization trajectory seed is a simple straight-line initialization in joint space [18]. This heuristic is surprisingly effective in many environments, but suffers from local convergence and may fail to find a trajectory when one exists. In practice, this may be tackled by providing cleverer initialization seeds [11, 27]. While these methods reduce the chance of falling into local minima, they do not have any alternative plans should the chosen initialization seed fail. A contextual ranking of a library of initialization trajectory seeds can provide feasible alternative seeds should earlier choices fail. Proposed initialization trajectory seeds can be developed in many ways including human demonstration [17] or use of a slow but complete planner[13].\nFor this experiment we attempt to plan a trajectory to a pre-grasp pose over the target object in a cluttered environment using the local optimization planner CHOMP [18] and minimize the total planning and execution time of the trajectory. A training dataset of |D| = 310 environments and test dataset of 212 environments are generated. Positions of the target object and obstacles on the table are randomly assigned. To populate the control library, we consider initialization trajectories that move first to an \u201cexploration point\u201d and then to the goal. The exploration points are generated by randomly perturbing the midpoint of the original straight line initialization in joint space. The resulting initial trajectories are then piecewise straight lines in joint space from the start point to the exploration point, and from the exploration point to the goal. Half of the seed trajectories are prepended with a short path to start from a left-arm configuration, and half are in right-arm configuration. This is because the local planner has a difficult time switching between configurations, while environmental context can provide a lot of information about which configuration to use. 30 trajectories are generated and form our action library V . Figure 2a shows an example set for a particular environment. Notice that in this case the straightline initialization of CHOMP goes through the obstacle and\ntherefore CHOMP has a difficult time finding a valid trajectory using this initial seed.\nIn our results we use a small number (1\u22123) of slots in our sequence to ensure the overhead of ordering and evaluating the library is small. When CHOMP fails to find a collision-free trajectory for multiple initializations seeds, one can always fall back on slow but complete planners. Thus the contextual control sequence\u2019s role is to quickly evaluate a few good options and choose the initialization trajectory that will result in the minimum execution time. We note that in our experiments, the overhead of ordering and evaluating the library is negligible as we rely on a fast predictor and features computed as part of the trajectory optimization, and by choosing a small sequence length we can effectively compute a motion plan with expected planning time under 0.5s. We can solve most manipulation problems that arise in our manipulation research very quickly, falling back to initializing the trajectory optimization with a complete motion planner only in the most difficult of circumstances.\nFor each initialization trajectory, we calculate 17 simple feature values which populate a row of the feature matrix Xi: length of trajectory in joint space; length of trajectory in task space, the xyz values of the end effector position at the exploration point (3 values), the distance field values used by CHOMP at the quarter points of the trajectory (3 values), joint values of the first 4 joints at both the exploration point (4 values) and the target pose (4 values), and whether the initialization seed is in the same left/right kinematic arm configuration as the target pose. During training time, we evaluate each initialization seed in our library on all environments in the training set, and use their performance and features to train each regressor \u211ci in CONSEQOPT. At test time, we simply run Algorithm 2 without the training step to produce Y\u211c1,...,\u211cN as the sequence of initialization seeds to be evaluated. Note that while the first regressor uses only the 17 basic features, the subsequent regressors also include the difference in feature values between the remaining actions and the actions chosen by the previous regressors. These difference features improve the algorithm\u2019s ability to consider trajectory diversity in the actions chosen.\nWe compare CONSEQOPT with two other methods of ranking the initialization library: a random ordering of the actions, and an ordering by sorting the output of the first regressor. Sorting by the first regressor is functionally the same as maximizing the absolute benefit rather than the marginal benefit at each slot. We compare both the number of CHOMP failures as well as the average execution time of the final trajectory. For execution time, we assume the robot can be actuated at 1 rad/second for each joint and use the shortest trajectory generated using the N seeds ranked by CONSEQOPT as the performance. If we fail to find a collision free trajectory and need to fall back to a complete planner (RRT [13] plus trajectory optimization), we apply a maximum execution time penalty of 40 seconds due to the longer computation time and resulting trajectory.\nThe results over 212 test environments are summarized\nin Figure 3. With only simple straight line initialization, CHOMP is unable to find a collision free trajectory in 162/212 environments, with a resulting average execution time of 33.4s. While a single regressor (N = 1) can reduce the number of CHOMP failures from 162 to 79 and the average execution time from 33.4s to 18.2s, when we extend the sequence length, CONSEQOPT is able to reduce both metrics faster than a ranking by sorting the output of the first regressor. This is because for N > 1, CONSEQOPT chooses a primitive that provides the maximum marginal benefit, which results in trajectory seeds that have very different features from the previous slots\u2019 choices. Ranking by the absolute benefit tends to pick trajectory seeds that are similar to each other, and thus are more likely to fail when the previous seeds fail. At a sequence length of 3, CONSEQOPT has only 16 failures and an average execution time of 3 seconds. A 90% improvement in success rate and a 75% reduction in execution time. Note that planning times are generally negligible compared to execution times for manipulation hence this improvement is significant. Figure 2b shows the initialization seed found by CONSEQOPT for the same environment as in Figure 2a. Notice that this seed avoids collision with the obstacle between the manipulator and the target object enabling CHOMP to produce a successful trajectory."}, {"heading": "B. Mobile Robot Navigation", "text": "An effective means of path planning for mobile robots is to sample a budgeted number of trajectories from a large library of feasible trajectories and traverse the one which has the lowest cost of traversal for a small portion and repeat the process again. The sub-sequence of trajectories is usually computed offline [9, 7]. Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs. We use CONSEQOPT to maximize this function and generate trajectory sequences taking the current environment features.\nFigures 4a and 4b shows a section of Fort Hood, TX and the corresponding robot cost-map respectively. We simulated a robot traversing between various random starting and goal locations using the maximum-discrepancy trajectory [9] sequence as well as sequences generated by CONSEQOPT using Algorithm 1. A texton library [26] of 25 k-means cluster centers was computed for the whole overhead map. At runtime the texton histogram for the image patch around the robot was used as features. Online linear support vector machines (SVM) with slack re-scaling [19] were used as the costsensitive classifiers for each slot. We report a 9.6% decrease over 580 runs using N = 30 trajectories in the cost of traversal as compared to offline precomputed trajectory sequences which maximize the area between selected trajectories [9]. Our approach is able to choose which trajectories to use at each step based on the appearance of terrain (woods, brush, roads, etc.) As seen in Figure 4c at each time-step CONSEQOPT the trajectories are so selected that most of them fall in the empty\nspace around obstacles."}], "references": [{"title": "Learning for autonomous navigation", "author": ["J.A. Bagnell", "D. Bradley", "D. Silver", "B. Sofman", "A. Stentz"], "venue": "Robotics Automation Magazine, IEEE,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "Grasp planning in complex scenes", "author": ["D. Berenson", "R. Diankov", "K. Nishiwaki", "S. Kagami", "J Kuffner"], "venue": "In IEEE- RAS Humanoids,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "Overhead color map of portion of Fort Hood, TX  (b) Cost map of corresponding portion (c) Robot traversing the map using CONSEQOPT generating trajectory sequences which try to avoid obstacles in the vicinity B. Zadrozny. Error limiting reductions between classification tasks", "author": ["A. Beygelzimer", "V. Dani", "T. Hayes", "J. Langford"], "venue": "In ICML. ACM,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Ranking planar grasp configurations for a threefinger hand", "author": ["E. Chinellato", "R.B. Fisher", "A. Morales", "A.P. del Pobil"], "venue": "In ICRA,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Efficient optimization of control libraries", "author": ["Debadeepta Dey", "Tian Yu Liu", "Boris Sofman", "J. Andrew (Drew) Bagnell"], "venue": "Technical Report CMU-RI-TR-11-20,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Survivability: Measuring and ensuring path diversity", "author": ["L.H. Erickson", "S.M. LaValle"], "venue": "In ICRA,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Robust hybrid control for autonomous vehicle motion planning", "author": ["E. Frazzoli", "MA Dahleh", "E. Feron"], "venue": "In Decision and Control,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2000}, {"title": "Optimal sampling in the space of paths: Preliminary results", "author": ["C. Green", "A. Kelly"], "venue": "Technical Report CMU-RI- TR-06-51,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "The DARPA LAGR program: Goals, challenges, methodology, and phase I results", "author": ["LD Jackel"], "venue": "JFR,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}, {"title": "Trajectory prediction: learning to map situations to robot trajectories", "author": ["N. Jetchev", "M. Toussaint"], "venue": "In ICML. ACM,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2009}, {"title": "Toward reliable off road autonomous vehicles operating in challenging environments", "author": ["Alonzo Kelly"], "venue": "IJRR,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2006}, {"title": "Rrt-connect: An efficient approach to single-query path planning", "author": ["J.J. Jr. Kuffner", "S.M. LaValle"], "venue": "In ICRA,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2000}, {"title": "Sensitive error correcting output codes", "author": ["John Langford", "Alina Beygelzimer"], "venue": "In Learning Theory, Lecture Notes in Computer Science", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2005}, {"title": "Junior: The stanford entry in the urban challenge", "author": ["M. Montemerlo"], "venue": "JFR, 25(9):569\u2013597,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Learning diverse rankings with multi-armed bandits", "author": ["Filip Radlinski", "Robert Kleinberg", "Thorsten Joachims"], "venue": "In Proceedings of the 25th ICML,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2008}, {"title": "Imitation learning for locomotion and manipulation", "author": ["N. Ratliff", "J.A. Bagnell", "S. Srinivasa"], "venue": "Technical Report CMU-RI-TR-07-45,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2007}, {"title": "Chomp: Gradient optimization techniques for efficient motion planning", "author": ["Nathan Ratliff", "Matthew Zucker", "J. Andrew (Drew) Bagnell", "Siddhartha Srinivasa"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2009}, {"title": "Learning with kernels: support vector machines, regularization, optimization, and beyond", "author": ["B. Scholkopf", "A.J. Smola"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2002}, {"title": "Policies based on trajectory libraries", "author": ["M. Stolle", "C.G. Atkeson"], "venue": "In ICRA,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "An online algorithm for maximizing submodular functions", "author": ["M. Streeter", "D. Golovin"], "venue": "In NIPS,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2008}, {"title": "Online learning of assignments", "author": ["M. Streeter", "D. Golovin", "A. Krause"], "venue": "In NIPS,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2009}, {"title": "Stanley: The robot that won the darpa grand challenge: Research articles", "author": ["Sebastian Thrun"], "venue": "J. Robot. Syst.,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2006}, {"title": "A robust approach to highspeed navigation for unrehearsed desert", "author": ["Christopher Urmson"], "venue": "terrain. JFR,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2006}, {"title": "Autonomous driving in urban environments: Boss and the urban challenge", "author": ["Christopher Urmson"], "venue": "JFR,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2008}, {"title": "Object categorization by learned universal visual dictionary", "author": ["J. Winn", "A. Criminisi", "T. Minka"], "venue": "In ICCV,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2005}, {"title": "A data-driven approach to high level planning", "author": ["Matthew Zucker"], "venue": "Technical Report CMU-RI-TR-09-42, Robotics Institute,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}], "referenceMentions": [{"referenceID": 14, "context": "In web search, for instance, if the search term admits many different interpretations then the results should be interleaved with items from each interpretation [16].", "startOffset": 161, "endOffset": 165}, {"referenceID": 3, "context": "Examples of control libraries include a collection of feasible grasps for manipulation [5], a collection of feasible trajectories for mobile robot navigation [9], and a collection of expert-demonstrated trajectories for a walking robot (Stolle et.", "startOffset": 87, "endOffset": 90}, {"referenceID": 7, "context": "Examples of control libraries include a collection of feasible grasps for manipulation [5], a collection of feasible trajectories for mobile robot navigation [9], and a collection of expert-demonstrated trajectories for a walking robot (Stolle et.", "startOffset": 158, "endOffset": 161}, {"referenceID": 18, "context": "[20]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "vehicles (UAVs) has enabled dynamically feasible trajectories to be quickly generated by concatenating a suitable subset of stored trajectories in the control library [8].", "startOffset": 167, "endOffset": 170}, {"referenceID": 25, "context": "Zucker [27] and Jetchev et al.", "startOffset": 7, "endOffset": 11}, {"referenceID": 9, "context": "[11] proposed methods for predicting trajectories from a precomputed library using features of the environment, yet these methods do not provide recovery methods when the prediction fails.", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "While a naive ordering of grasps can be based on force closure and stability criteria [2], if a grasp fails, then grasps similar to it are also likely to fail.", "startOffset": 86, "endOffset": 89}, {"referenceID": 19, "context": "[21] over the hypothesis space of all predictors which is guaranteed to yield sequences within a constant factor of the optimal sequence.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[21].", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[21].", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "predicting a single decision based on features to making a sequence of predictions, a problem that arises in many domains including advertisement prediction [22, 16] and search.", "startOffset": 157, "endOffset": 165}, {"referenceID": 14, "context": "predicting a single decision based on features to making a sequence of predictions, a problem that arises in many domains including advertisement prediction [22, 16] and search.", "startOffset": 157, "endOffset": 165}, {"referenceID": 4, "context": "[6] prove that this criterion is monotone submodular in sequences of control actions and can be maximized\u2013 within a constant factor\u2013 by greedy approaches similar to Streeter et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 19, "context": "[21].", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "For the latter optimization criteria, which arises in grasping and trajectory seed selectin, we define the monotone, submodular loss function f : S \u2192 [0,1] as f \u2261 P(S) where", "startOffset": 150, "endOffset": 155}, {"referenceID": 4, "context": "It is easy to check [6] that this function is also monotone and", "startOffset": 20, "endOffset": 23}, {"referenceID": 11, "context": "f [13] = 0.", "startOffset": 2, "endOffset": 6}, {"referenceID": 11, "context": "f ([13])) = argmaxa( f ([13,a])\u2212 0.", "startOffset": 3, "endOffset": 7}, {"referenceID": 2, "context": "We establish a formal regret reduction [3] between cost sensitive multi-class classification error and the resulting error on the learned sequence of classifiers.", "startOffset": 39, "endOffset": 42}, {"referenceID": 19, "context": "[21] consider the case where the ith decision made by the greedy algorithm is performed with additive error \u03b5i.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[14] show that the re-", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "Plugging in the regret reduction from [14] we get the result that the resulting sequence of regressors in Algorithm 2 is within at least (1\u2212 e )maxS\u2208S f (S)\u2212\u2211 N i=1 \u221a 2(|V |\u22121)rregi of the optimal sequence of multi-class cost-sensitive classifiers.", "startOffset": 38, "endOffset": 42}, {"referenceID": 16, "context": "Recent work [18, 11] has shown that by relaxing the hard constraint of avoiding obstacles into a soft penalty term on collision, simple local optimization techniques can quickly lead to smooth, collision-free trajectories suitable for robot execution.", "startOffset": 12, "endOffset": 20}, {"referenceID": 9, "context": "Recent work [18, 11] has shown that by relaxing the hard constraint of avoiding obstacles into a soft penalty term on collision, simple local optimization techniques can quickly lead to smooth, collision-free trajectories suitable for robot execution.", "startOffset": 12, "endOffset": 20}, {"referenceID": 16, "context": "Often the default initialization trajectory seed is a simple straight-line initialization in joint space [18].", "startOffset": 105, "endOffset": 109}, {"referenceID": 9, "context": "In practice, this may be tackled by providing cleverer initialization seeds [11, 27].", "startOffset": 76, "endOffset": 84}, {"referenceID": 25, "context": "In practice, this may be tackled by providing cleverer initialization seeds [11, 27].", "startOffset": 76, "endOffset": 84}, {"referenceID": 15, "context": "Proposed initialization trajectory seeds can be developed in many ways including human demonstration [17] or use of a slow but complete planner[13].", "startOffset": 101, "endOffset": 105}, {"referenceID": 11, "context": "Proposed initialization trajectory seeds can be developed in many ways including human demonstration [17] or use of a slow but complete planner[13].", "startOffset": 143, "endOffset": 147}, {"referenceID": 16, "context": "For this experiment we attempt to plan a trajectory to a pre-grasp pose over the target object in a cluttered environment using the local optimization planner CHOMP [18] and minimize the total planning and execution time of the trajectory.", "startOffset": 165, "endOffset": 169}, {"referenceID": 11, "context": "If we fail to find a collision free trajectory and need to fall back to a complete planner (RRT [13] plus trajectory optimization), we apply a maximum execution time penalty of 40 seconds due to the longer computation time and", "startOffset": 96, "endOffset": 100}, {"referenceID": 7, "context": "The sub-sequence of trajectories is usually computed offline [9, 7].", "startOffset": 61, "endOffset": 67}, {"referenceID": 5, "context": "The sub-sequence of trajectories is usually computed offline [9, 7].", "startOffset": 61, "endOffset": 67}, {"referenceID": 23, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 151, "endOffset": 167}, {"referenceID": 13, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 151, "endOffset": 167}, {"referenceID": 22, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 151, "endOffset": 167}, {"referenceID": 21, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 151, "endOffset": 167}, {"referenceID": 8, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 174, "endOffset": 178}, {"referenceID": 0, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 184, "endOffset": 187}, {"referenceID": 10, "context": "Such methods are widely used in modern, autonomous ground robots including the two highest placing teams for DARPA Urban Challenge and Grand Challenge [25, 15, 24, 23], LAGR [10], UPI [1], and Perceptor [12] programs.", "startOffset": 203, "endOffset": 207}, {"referenceID": 7, "context": "We simulated a robot traversing between various random starting and goal locations using the maximum-discrepancy trajectory [9] sequence as well as sequences generated by CONSEQOPT using", "startOffset": 124, "endOffset": 127}, {"referenceID": 24, "context": "A texton library [26] of 25 k-means cluster centers was computed for the whole overhead map.", "startOffset": 17, "endOffset": 21}, {"referenceID": 17, "context": "Online linear support vector machines (SVM) with slack re-scaling [19] were used as the costsensitive classifiers for each slot.", "startOffset": 66, "endOffset": 70}, {"referenceID": 7, "context": "over 580 runs using N = 30 trajectories in the cost of traversal as compared to offline precomputed trajectory sequences which maximize the area between selected trajectories [9].", "startOffset": 175, "endOffset": 178}], "year": 2010, "abstractText": "Sequence optimization, where the items in a list are ordered to maximize some reward has many applications such as web advertisement placement, search, and control libraries in robotics. Previous work in sequence optimization produces a static ordering that does not take any features of the item or context of the problem into account. In this work, we propose a general approach to order the items within the sequence based on the context (e.g., perceptual information, environment description, and goals). We take a simple, efficient, reduction-based approach where the choice and order of the items is established by repeatedly learning simple classifiers or regressors for each \u201cslot\u201d in the sequence. Our approach leverages recent work on submodular function maximization to provide a formal regret reduction from submodular sequence optimization to simple costsensitive prediction. We apply our contextual sequence prediction algorithm to optimize control libraries and demonstrate results on two robotics problems: manipulator trajectory prediction and mobile robot path planning.", "creator": "LaTeX with hyperref package"}}}