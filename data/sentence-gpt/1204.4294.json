{"id": "1204.4294", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Apr-2012", "title": "Learning in Riemannian Orbifolds", "abstract": "Learning in Riemannian orbifolds is motivated by existing machine learning algorithms that directly operate on finite combinatorial structures such as point patterns, trees, and graphs. These methods, however, lack statistical justification. This contribution derives consistency results for learning problems in structured domains and thereby generalizes learning in vector spaces and manifolds. Furthermore, there are no systematic differences between the performance of algorithms that use a single program to perform any function. The only consistent difference is that many computations are performed with specific program components, but this difference is due to the computational complexity of the algorithms used and the fact that the algorithm is only an extension of a single program.\n\n\nThe above code is inspired from an article in C++ that discusses a subset of operations. This paper discusses how a single program can perform all of these operations without using the same algorithm to perform any operation. The key difference between this method and a more specific program, is that the computational complexity of each operation in the program has not changed drastically from the previous version. This is also important because this model is a more practical approach to a program, as we cannot predict how many operations are performed for each operation at the same time as the current version.\nThe following table summarizes some of the most basic algorithms using Python. To learn more about Python, please see the tutorial.\n1.1 The first-level programming language with multiple operations, one of the most common, the most complex programming languages. The language that makes it easy to understand and write large programs, such as Python, is the most popular language in the world. As a result, some problems arise when one program generates the following data:\n2.1 The first-level programming language, C++, has the most number of operations. The language that makes it possible to understand and write large programs, such as Python, is the most popular language in the world. The language that makes it possible to understand and write large programs, such as Python, is the most popular language in the world.\n3.1 The first-level programming language, C++, has the most number of operations. The language that makes it possible to understand and write large programs, such as Python, is the most popular language in the world. The language that makes it possible to understand and write large programs, such as Python, is the most popular language in the world. The language that makes it possible to understand and write large programs, such as Python, is the most popular language in the world. The language", "histories": [["v1", "Thu, 19 Apr 2012 09:29:10 GMT  (16kb)", "http://arxiv.org/abs/1204.4294v1", "arXiv admin note: substantial text overlap witharXiv:1001.0921"]], "COMMENTS": "arXiv admin note: substantial text overlap witharXiv:1001.0921", "reviews": [], "SUBJECTS": "cs.LG cs.AI cs.CV", "authors": ["brijnesh j jain", "klaus obermayer"], "accepted": false, "id": "1204.4294"}, "pdf": {"name": "1204.4294.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["brijnesh.jain@gmail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 4.\n42 94\nv1 [\ncs .L\nG ]\n1 9\nA pr\n2 01\n2\nLearning in Riemannian Orbifolds\nBrijnesh J. Jain and Klaus Obermayer\nTechnische Universita\u0308t Berlin\nBerlin, Germany\ne-mail: brijnesh.jain@gmail.com\nLearning in Riemannian orbifolds is motivated by existing machine learning algorithms that directly operate on finite combinatorial structures such as point patterns, trees, and graphs. These methods, however, lack statistical justification. This contribution derives consistency results for learning problems in structured domains and thereby generalizes learning in vector spaces and manifolds."}, {"heading": "1 Introduction", "text": "Statistical data analysis and learning in Riemannian orbifolds is motivated by applications, where the data we want to learn on are naturally represented by finite combinatorial structures such as point patterns, trees, and graphs. Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20]. In retrospect, the structure space framework proposed by [18] theoretically justifies the above approaches in the sense that they actually minimize an empirical risk function on structures. Since minimizing an empirical risk function is usually computationally intractable, the ultimate challenge consists in constructing efficient algorithms which are capable to return optimal or at least suboptimal solutions.\nFrom the point of view of statistical pattern recognition, however, the ultimate goal is not to determine a good solution of an empirical risk function, but rather to discover the true but unknown structure of the data with respect to its distribution. According to this perspective, we may regard the solutions of empirical risk functions as estimators of the true but unknown population parameter. One gap between statistical and structural pattern recognition is the lack of consistency results of existing estimators for the population parameters. As a consequence most methods from structural pattern recognition that directly operate in the domain of graphs still have no statistical justification.\nThe first contribution of this paper establishes sufficient conditions for consistency of estimators defined by empirical risk functions on attributed graphs. For this we regard graphs as points of some structure space [18]. A structure space is the quotient of a Euclidean space by some permutation group. The benefit of the structure space framework is that it provides enough mathematical structure for doing differential geometry and at the same time preserves the full relational information of the graphs. In comparison to [18], the innovations are as follows: First, we extend the more suitable concept of generalized differentiability in the sense of Norkin [22] to functions on graphs. Second, we prove the stronger result that the underlying empirical risk functions on graphs are generalized differentiable rather than locally Lipschitz. Third, equipped with these results, we apply a consistency theorem by Ermoliev and Norkin [8] for generalized differentiable loss functions. Finally, using some examples, we show that standard methods from statistical pattern recognition can be generalized to consistent learning algorithms on graphs.\nThe second contribution shifts the terminology from structure spaces to the more general notion of orbifold. Informally, orbifolds are topological spaces locally modeled on quotients of manifolds by finite group actions. As such, structure spaces are the simplest examples of Riemannian orbifolds. Shifting the focus to orbifolds provides a new view on the problem with the following benefits: First, the notion of orbifold more strongly emphasizes the way we exploit differential geometric tools for graphs, namely via charting and lifting as in Riemannian geometry. Second, using the notion of orbifold integrates the structure space framework into an established mathematical field providing access to useful concepts, results, and insights. Third, the notion of orbifold indicates how the theory can be generalized to structures that locally live in a quotient of a manifold by some finite group action. Fourth, since orbifolds generalize Euclidean spaces and manifolds, this framework not only establishes consistency for stochastic generalized gradient learning but also for standard stochastic gradient learning in Euclidean spaces (see [4]) under the unifying umbrella of learning on Riemannian orbifolds."}, {"heading": "2 The Problem of Learning on Graphs", "text": "This section aims at outlining the problem of learning on structured data in order to motivate learning in Riemannian orbifolds. As an illustrative example, we consider the problem of estimating the mean of a distribution on attributed graphs.\nAttributed Graphs. We begin with describing the structures we want to learn on. Let A be a set of attributes and let \u03b5 \u2208 A be a distinguished element denoting the null or void element. An attributed graph is a tuple X = (V, \u03b1) consisting of a finite nonempty set V of vertices and an attribute function \u03b1 : V \u00d7 V \u2192 A. Elements of the set E = {(i, j) \u2208 V \u00d7 V : i 6= j and \u03b1(i, j) 6= \u03b5} are the edges of X. By GA we denote the set of all attributed graphs with attributes from A. The vertex set of an attributed graph X is often referred to as VX and its attribute function as \u03b1X .\nAlignments. Alignments serve to compare the common structure of two given graphs. An alignment of a graph X is a graph X \u2032 with VX \u2286 VX\u2032 and\n\u03b1X\u2032(i, j) =\n{\n\u03b1X(i, j) (i, j) \u2208 VX \u00d7 VX \u03b5 otherwise \u2200 i, j \u2208 VX\u2032 .\nThus, we obtain an alignment of X by adding isolated vertices with null-attribute. The set V \u03b5X\u2032 = VX\u2032\\VX is the set of aligned vertices. By A(X) we denote the infinite set of all alignments of X. A pairwise alignment of graphs X and Y is a triple (\u03c6,X \u2032, Y \u2032) consisting of alignments X \u2032 \u2208 A(X) and Y \u2032 \u2208 A(Y ) together with a bijective mapping\n\u03c6 : VX\u2032 \u2192 VY \u2032 , i 7\u2192 i \u03c6.\nA pairwise alignment (\u03c6,X \u2032, Y \u2032) is minimal if \u03c6 does not map aligned vertices onto each other, that is \u03c6 (\nV \u03b5X\u2032 )\n\u2286 VY . By A(X,Y ) we denote the set of all minimal pairwise alignments between X and Y . Note that A(X,Y ) is finite due to the minimality condition. Sometimes we briefly write \u03c6 instead of (\u03c6,X \u2032, Y \u2032).\nGraph Edit Distance. Dissimilarity is a fundamental concept in machine learning. Here, we consider the graph edit distance, which is a common choice for measuring structural variation of two given graphs. Several distance measures reported in the structural pattern recognition literature can be derived as special cases of the graph edit distance function. Examples are geometric graph distance functions [11] and distances based on the maximum common subgraph including graph and subgraph isomorphism [5].\nTo define the graph edit distance, we regard each minimal pairwise alignment (\u03c6,X \u2032, Y \u2032) \u2208 A(X,Y ) as an edit path with edit cost\nd\u03c6 ( X \u2032, Y \u2032 ) = \u2211\ni,j\u2208V X\u2032\ndA\n(\n\u03b1X\u2032(i, j), \u03b1Y \u2032(i \u03c6, j\u03c6)\n)\n,\nwhere dA : A \u00d7 A \u2192 R+ is a distance function defined on the set A of attributes. The edit cost d\u03c6 can be decomposed into deletion cost dA(a, \u03b5), insertion cost dA(\u03b5, a\n\u2032), and substitution cost dA(a, a\n\u2032) of vertices and edges, where a, a\u2032 \u2208 A \\ {\u03b5} are non-null attributes. Since dA is a distance function, we have dA(\u03b5, \u03b5) = 0. This can only occur for pairs of non-edges by definition of minimal pairwise alignments and therefore can safely be ignored. Observe that deletion (insertion) of vertices also deletes (inserts) all edges the respective vertices are incident to. The graph edit distance of X and Y is then defined as the edit path with minimal cost\nd(X,Y ) = min { d\u03c6 ( X \u2032, Y \u2032 ) : (\u03c6,X \u2032, Y \u2032) \u2208 A(X,Y ) } .\nThe Problem of Learning. Let (GA, d) be a graph distance space. As an illustrative example, consider the expected risk\nR(W ) = 1\n2\n\u222b\nGA\nd(X,W )2 dPGA(X),\nwhere W \u2208 W \u2286 GA is the optimization variable and X \u2208 GA is a random variable with probability distribution PGA . Since the distribution on the set GA of graphs is usually unknown, the goal of learning is to minimize the risk R(W ) on the basis of empirical data.\nTo point out the problems of learning in the domain of graphs, we consider the counterpart of minimizing the risk R(W ) in a Euclidean vector space X . The goal is to minimize the expected risk\nR(w) = 1\n2\n\u222b\nX\n\u2016x\u2212w\u20162 dPX (x),\nbased on independent and identically distributed random points x1, . . . ,xN \u2208 X , where PX is a probability measure on X . Since the loss function \u2016x\u2212w\u2016\n2 is continuously differentiable, the interchange of integral and gradient is valid, that is\n\u2207R(w) = \u2212\n\u222b\nX\n(x\u2212w)dPX (x).\nWe can minimize the risk R(w) using the following stochastic gradient method\nwt+1 = wt + 1\nt+ 1 (xt \u2212wt),\nwhere w1 = x1 and t \u2265 1. The elements wt of the sequence (wt)t\u22650 are sample means\nwt = 1\nt\nt \u2211\ni=1\nxt.\nIt is well-known that the sample mean is a consistent estimator of the population mean \u00b5, which in turn is the unique global minimizer of the expected risk R(w).\nAfter this short digression in vector spaces, let us return to the problem of minimizing the expected risk R(W ) in graph spaces. As opposed to vector spaces, the following factors complicate learning on graphs in a statistically consistent way: (i) the graph edit distance d(X,Y ) is in general not-differentiable; and (ii) neither a well-defined addition on graphs nor the notion of derivative for functions on graphs is known.\nWe therefore address the following questions: (i) How can we extend gradient-based learning problems from Euclidean spaces to GA? (ii) How can we minimize the expected risk of a learning problem with structured input- and/or output-space GA in a statistically consistent way?\nThe ansatz to answer both questions is to identify graphs as points of a Riemannian orbifold and to extend the concept of generalized differentiability in the sense of Norkin [22] in order to apply methods from stochastic optimization for non-differentiable and non-convex loss functions."}, {"heading": "3 Riemannian Orbifolds", "text": "This section introduces Riemannian orbifolds. To keep the treatment technically as uncluttered as possible, we assume that X = Rn is the n-dimensional Euclidean space, and\n\u0393 is a permutation group acting on X . In doing so, we can refer to [18] for proofs of statements and claims made in this section. In a more general setting, however, X can also be a Riemannian manifold. In this case, we refer to [3] for more details."}, {"heading": "3.1 Riemannian Orbifolds", "text": "The binary operation\n\u00b7 : \u0393\u00d7 X \u2192 X , (\u03b3,x) 7\u2192 \u03b3(x)\nis a group action of \u0393 on X . For x \u2208 X , the orbit of x is the set defined by [x] = {\u03b3(x) : \u03b3 \u2208 \u0393}. The quotient set X\u0393 = X/\u0393 = {[x] : x \u2208 X} consisting of all all orbits carries the structure of a Riemannian orbifold. Its orbifold chart is the surjective continuous mapping\n\u03c0 : X \u2192 X\u0393, x 7\u2192 [x]\nthat projects each point x to its orbit [x]. With \u0393 = {id} being the trivial permutation group, X is also an orbifold. Hence, orbifolds generalize the notion of Euclidean space and manifold.\nIn the following, an orbifold is a triple Q = (X ,\u0393, \u03c0) consisting of a Euclidean space X , a permutation group \u0393 acting on X and its orbifold chart \u03c0. We call the elements of X\u0393 structures, since they represent combinatorial structures such as graphs. We use capital letters X,Y,Z, . . . to denote structures from X\u0393 and write x \u2208 X if \u03c0(x) = X. Each vector x \u2208 X is a vector representation of structure X and the set X of all vector representation is the representation space of X\u0393."}, {"heading": "3.2 The Riemannian Orbifold of Graphs", "text": "Riemannian orbifolds of attributed graphs arise by considering equivalence classes of matrices representing the same graph. To identify graphs with points from some orbifold, some technical assumptions to simplify the mathematical treatment are necessary. For this, let (GA, d) be a graph distance space with graph edit distance d(\u00b7|\u00b7). Then we make the following assumptions:\nA1. There is a feature map \u03a6 : A \u2192 H of the attributes into some finite dimensional Euclidean feature space H and a distance function dH : H \u00d7H \u2192 R+ such that \u03a6(\u03b5) = 0 \u2208 H and\ndA(a, a \u2032) = dH(\u03a6(a),\u03a6(a \u2032)) \u2200 a, a\u2032 \u2208 A.\nA2. All graphs are finite of bounded order n, where n is a sufficiently large number. A graph X of order less than n, say m < n, is aligned to graph X \u2032 of order n by inserting p = n\u2212m isolated vertices with null attribute \u03b5.\nLet us consider the above assumptions in more detail. Both conditions do not effect the graph edit distance, provided an appropriate feature map for the attributes can be found. Restricting to finite dimensional Euclidean feature spaces H is necessary for deriving consistency results and for applying methods from stochastic optimization. Limiting the maximum size of the graphs to some arbitrarily large number n and aligning smaller graphs to graphs of oder n are purely technical assumptions to simplify mathematics.\nFor machine learning problems, this limitation should have no practical impact, because neither the bound n needs to be specified explicitly nor an extension of all graphs to an identical order needs to be performed. When applying the theory, all we actually require is that the order of the graphs is bounded.\nWith both assumptions in mind, we construct the Riemannian orbifold of attributed graphs. Let X = Hn\u00d7n be the set of all (n\u00d7n)-matrices with elements from feature space H. A graph X is completely specified by a representation matrix X = (xij) from X with elements\nxij =\n{\n\u03c6 (\u03b1X(i, j)) i = j or (i, j) \u2208 E\n0 otherwise\nfor all i, j \u2208 VX . The form of a representation matrix X of X is generally not unique and depends on how the vertices are arranged in the diagonal of X.\nNow suppose that \u03a0n be the set of all (n\u00d7 n)-permutation matrices. For each P \u2208 \u03a0n\nwe define a mapping\n\u03b3P : X \u2192 X , X 7\u2192 P TXP .\nThen \u0393 = {\u03b3P : P \u2208 \u03a0 n} is a permutation group acting on X . Regarding an arbitrary matrix X as a representation of some graph X, then the orbit [X] consists of all possible matrices that can represent X. By identifying the orbits of X\u0393 with attributed graphs, the set GA of attributed graphs of bounded order n is a Riemannian orbifold."}, {"heading": "3.3 Metric Structures", "text": "Let Q = (X ,\u0393, \u03c0) be an orbifold. We derive an intrinsic metric that enables us to do Riemannian geometry. Note that in the case of graph orbifolds, the intrinsic metric is a special graph edit distance based on a generalization of the concept of maximum common subgraph. This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].\nAny inner product \u3008\u00b7, \u00b7\u3009 on X gives rise to a maximizer k : X\u0393 \u00d7 X\u0393 \u2192 R of the form\nk(X,Y ) = max {\u3008x,y\u3009 : x \u2208 X,y \u2208 Y } .\nWe call the kernel function k(\u00b7|\u00b7) optimal alignment kernel, induced by \u3008\u00b7, \u00b7\u3009. Note that the maximizer of a set of positive definite kernels is an indefinite kernel in general. Since \u0393 is a group, we find that\nk(X,Y ) = max {\u3008x,y\u3009 : x \u2208 X},\nwhere y is an arbitrary but fixed vector representation of Y .\nExample 3.1 Suppose that X and Y are attributed graphs where edges have attribute 1 and vertices have attribute 0. The optimal alignment kernel k (X,Y ) induced by the standard inner product of X is the number of edges of a maximum common subgraph of X and Y .\nSuppose that X \u2208 X\u0393. Since k(X,X) = \u3008x,x\u3009 for all x \u2208 X, we can define the length of X by\nl(X) = \u221a k(X,X).\nSince the Cauchy-Schwarz inequality |k(X,Y )| \u2264 l(X) \u00b7 l(Y ) is valid, the geometric interpretation of k(\u00b7|\u00b7) is that it computes the cosine of a well-defined angle between X and X \u2032 provided both are normalized.\nLikewise, k(\u00b7|\u00b7) gives rise to a distance function defined by\nd(X,Y ) = \u221a l(X)2 \u2212 2k(X,Y ) + l(Y )2.\nFrom the definition of k(\u00b7|\u00b7) follows that d is a metric. In addition, we have\nd(X,Y ) = min {\u2016x\u2212 y\u2016 : x \u2208 X,y \u2208 Y }, (1)\nwhere \u2016\u00b7\u2016 denotes the Euclidean norm induced by the inner product \u3008\u00b7, \u00b7\u3009 of the Euclidean space X .\nEquation (1) states that d (\u00b7|\u00b7) is the length of a minimizing geodesic of X and Y and therefore an intrinsic metric, because it coincides with the infimum of the length of all admissible curves from X to Y . In addition, we find that the topology of X\u0393 induced by the metric d coincides with the quotient topology induced by the topology of the Euclidean space X ."}, {"heading": "3.4 Orbifold Mappings", "text": "This section introduces mappings between orbifolds and investigates local analytical concepts of orbifold functions. We assume that Q = (X ,\u0393, \u03c0) and Q\u2032 = (X \u2032,\u0393\u2032, \u03c0\u2032) are orbifolds.\nMappings. An orbifold mapping between Q and Q\u2032 is a mapping f : X\u0393 \u2192 X \u2032 \u0393\u2032 between their underlying spaces. The lift of f is a mapping f\u0303 : X \u2192 X \u2032 between their representation spaces such that f \u25e6 \u03c0 = \u03c0\u2032 \u25e6 f\u0303 . Since R is an orbifold of the form QR = (R, {id}, idR), we can define an orbifold function between Q and QR as a function f : X\u0393 \u2192 R. The lift of f is a function f\u0303 : X \u2192 R satisfying f\u0303 = f \u25e6 \u03c0. The lift f\u0303 is invariant under group actions of \u0393, that is f\u0303(x) = f\u0303 (\u03b3(x)) for all \u03b3 \u2208 \u0393.\nWe say, an orbifold function f : X\u0393 \u2192 R is continuous (locally Lipschitz, differentiable) at X \u2208 X\u0393 if its lift f\u0303 is continuous (locally Lipschitz, differentiable) at some vector representation x \u2208 X. The definition is independent of the choice of the vector representation that projects to X.\nGradients. Suppose that f : X\u0393 \u2192 R is differentiable at X \u2208 X\u0393. Then its lift f\u0303 : X \u2192 R is differentiable at all vector representations that project to X. The gradient \u2207f(X) of f at X is defined by the projection\n\u2207f(X) = \u03c0(\u2207f\u0303(x))\nof the gradient \u2207f\u0303(x) of f\u0303 at a vector representation x \u2208 X. This definition is independent of the choice of the vector representation. We have\n\u2207f\u0303(\u03b3(x)) = \u03b3(\u2207f\u0303(x))\nfor all \u03b3 \u2208 \u0393. This implies that the gradients of f\u0303 at x and \u03b3(x) are vector representations of the same structure, namely the gradient \u2207f(X) of the orbifold function f at X. Thus, the gradient of f at X is a well-defined structure pointing to the direction of steepest ascent."}, {"heading": "4 Generalized Gradients", "text": "This section extends the concept of generalized differentiability in the sense of Norkin [22] to orbifold functions. We begin with introducing generalized differentiable functions. Let X = Rn be a finite-dimensional Euclidean space. A function f : X \u2192 R is generalized differentiable at x \u2208 X if there is a multi-valued map \u2202f : X \u2192 2X in a neighborhood of x such that\n1. \u2202f(x) is a convex and compact set;\n2. \u2202f(x) is upper semicontinuous at x, that is, if yi \u2192 x and gi \u2208 \u2202f(yi) for each i \u2208 N, then each accumulation point g of (gi) is in \u2202f(x);\n3. for each y \u2208 X and any g \u2208 \u2202f(y) holds f(y) = f(x)+\u3008g,y \u2212 x\u3009+o (x,y,g), where the remainder o (x,y,g) satisfies the condition\nlim i\u2192\u221e\n|o (x,yi,gi)|\n\u2016yi \u2212 x\u2016 = 0\nfor all sequences yi \u2192 y and gi \u2208 \u2202f (yi).\nWe call f generalized differentiable if it is generalized differentiable at each point x \u2208 X . The set \u2202f(x) is the subdifferential of f at x and its elements are called generalized gradients.\nGeneralized differentiable functions have the following properties [22]:\n1. Generalized differentiable functions are locally Lipschitz and therefore continuous and differentiable almost everywhere.\n2. Continuously differentiable, convex, and concave functions are generalized differentiable.\n3. Suppose that f1, . . . , fn : X \u2192 R are generalized differentiable at x \u2208 X . Then\nf\u2217(x) = min(f1(x), . . . , fm(x)) and f \u2217(x) = max(f1(x), . . . , fm(x))\nare generalized differentiable at x \u2208 X .\n4. Suppose that f1, . . . , fm : X \u2192 R are generalized differentiable functions at x \u2208 X and f0 : R m \u2192 R is generalized differentiable at y = (f1(x), . . . , fm(x)) \u2208 R m. Then\nf(x) = f0(f1(x), . . . , fm(x)) is generalized differentiable at x \u2208 X . The subdifferential of f at x is of the form\n\u2202f(x) = con { g \u2208 X : g = [ g1g2 . . . gm ] g0,g0 \u2208 \u2202f0(y),gi \u2208 \u2202fi(x), 1 \u2264 i \u2264 m } .\nwhere [g1g2 . . . gm] is a (N \u00d7m)-matrix.\n5. Suppose that F (x) = Ez [f(x,z)], where f(\u00b7,z) is generalized differentiable. Then F is generalized differentiable and its subdifferential at x \u2208 X is of the form \u2202F (x) = Ez [\u2202f(x,z)].\nNow suppose that f : X\u0393 \u2192 R is an orbifold function. We say f is generalized differentiable at X \u2208 X\u0393, if its lift f\u0303 : X \u2192 R is generalized differentiable at all vector representations that project to X. The subdifferential \u2202f(X) of f at X is defined by the projection\n\u2202f(X) = \u03c0(\u2202f\u0303(x))\nof the subdifferential \u2202f\u0303(x) of f\u0303 at a vector representation x \u2208 X. This definition is independent of the choice of the vector representation. We have\n\u2202f\u0303(\u03b3(x)) = \u03b3(\u2202f\u0303(x))\nfor all \u03b3 \u2208 \u0393. This implies that the subdifferentials \u2202f\u0303(x) \u2286 X and \u2202f\u0303(\u03b3(x)) \u2286 X are subsets that project to the same subset of X\u0393, namely the subdifferential \u2202f(X). Proposition 4.1 summarizes and proves the statements.\nProposition 4.1 Let f : X\u0393 \u2192 R be an orbifold function. Suppose that its lift f\u0303 : X \u2192 R is generalized differentiable at a vector representation x that projects to X \u2208 X\u0393. Then f\u0303 is generalized differentiable at \u03b3(x) for all \u03b3 \u2208 \u0393 and\n\u2202f\u0303(\u03b3(x)) = \u03b3 ( \u2202f\u0303(x) ) .\nis a subdifferential of f\u0303 at \u03b3(x) for all \u03b3 \u2208 \u0393.\nProof: Since f\u0303 is generalized differentiable at x, there is a multi-valued mapping \u2202f\u0303 : U\u03b4(x) \u2192 2\nX defined on some neighborhood U\u03b4(x). Let \u03b3 \u2208 \u0393 be an arbitrary permutation and x\u2032 = \u03b3(x). Then\n\u2202f\u0303 : U\u03b4(x \u2032) \u2192 2X , y\u2032 = \u03b3(y) 7\u2192 \u03b3\n( \u2202f\u0303(y) )\nis a multi-valued mapping in a neighborhood of x\u2032. Since \u03b3 is a homeomorphic linear map, we find that \u03b3(\u2202f\u0303(x)) = \u2202f\u0303(x\u2032) is a convex and compact set. Next we show that f\u0303 is upper semicontinuous at x\u2032. Suppose that y\u2032i \u2192 x \u2032, g\u2032i \u2208 f\u0303c(y \u2032 i) for each i \u2208 N, and g \u2032\nis an accumulation point of (g\u2032i)i\u2208N. Then there is a i0 \u2208 N such that y \u2032 i \u2208 U\u03b4(x \u2032) for all i \u2265 i0. From\nU\u03b4(x \u2032) = U\u03b4(\u03b3(x)) = \u03b3 (U\u03b4(x))\nfollows that there are vector representations yi \u2208 U\u03b4(x) with \u03b3(yi) = y \u2032 i for each i \u2265 i0. From continuity of \u03b3\u22121 follows that yi \u2192 x. By construction of \u2202f\u0303 follows that\ng\u2032i \u2208 \u2202f\u0303 ( y\u2032i ) = \u2202f\u0303 (\u03b3 (yi)) = \u03b3 ( \u2202f\u0303 (yi) )\nfor each i \u2265 i0. Hence, there are vector representations gi \u2208 \u2202f\u0303(yi) with \u03b3(gi) = g \u2032 i for each i \u2265 i0. Since f\u0303 is upper semicontinuous at x, we find that g \u2208 \u2202f\u0303(x). Again by construction of \u2202f\u0303 follows that\ng\u2032 = \u03b3(g) \u2208 \u03b3 ( \u2202f\u0303(x) ) = \u2202f\u0303 (\u03b3(x)) = \u2202f\u0303(x\u2032).\nThis proves upper semicontinuity of \u2202f\u0303 at all vector representations projecting to X = \u03c0(x). Finally, we prove that f\u0303 satisfies the subderivative property at x\u2032. Suppose that y\u2032,y \u2208 X with y\u2032 = \u03b3(y). By \u0393-invariance of f\u0303 , we have f\u0303(y\u2032) = f\u0303(y). Since f\u0303 is generalized differentiable at x, we find a g \u2208 \u2202f\u0303(y) such that\nf\u0303(y\u2032) = f\u0303(y) = f\u0303(x) + \u3008g,y \u2212 x\u3009+ o(x,y,g)\nwith o(x,y,g) tending faster to zero than \u2016y \u2212 x\u2016. Let g\u2032 = \u03b3(g). Exploiting \u0393-invariance of f\u0303 as well as isometry and linearity of \u03b3 yields\nf\u0303(y\u2032) = f\u0303(\u03b3(x)) + \u3008\u03b3(g), \u03b3(y \u2212 x)\u3009+ o(x,y,g)\n= f\u0303(x\u2032) + \u2329 g\u2032,y\u2032 \u2212 x\u2032 \u232a + o(x,y,g).\nWe define o\u2032(x\u2032,y\u2032,g\u2032) = o \u25e6 \u03b3\u22121(x\u2032,y\u2032,g\u2032) = o(x,y,g) showing that o\u2032 tends faster to zero than \u2016y\u2032 \u2212 x\u2016. This proves the subderivative property of f\u0303 at all vector representations projecting to X = \u03c0(x). Putting all results together yields that f\u0303 is generalized differentiable at \u03b3(x) for all \u03b3 \u2208 \u0393.\nExample 4.1 Let (GA, d) be a graph space, where d is a graph edit distance.We can identify GA with a Riemannian orbifold Q = (X ,\u0393, \u03c0) and the graph edit distance d (\u00b7|\u00b7) with a distance function defined on X\u0393. Suppose that the edit costs d\u03c6 (\u00b7|\u00b7) of all edit paths are generalized differentiable. Then the distance d (\u00b7|\u00b7) is generalized differentiable.\nExample 4.2 Let Q be a graph orbifold. Then the optimal assignment kernel k (\u00b7|\u00b7), the intrinsic metric d (\u00b7|\u00b7), and the squared metric d (\u00b7|\u00b7)2 are generalized differentiable."}, {"heading": "5 Stochastic Optimization", "text": "We assume that QW = (W,H, \u03c1) and QZ = (Z,\u0393, \u03c0) are Riemannian orbifolds and \u2126 \u2286 WH is some (sufficiently large) bounded convex constraint set. Learning is formulated\nas a stochastic optimization problem of the form\nmin R(W ) = E [L(Z,W )] =\n\u222b\nZ\u0393\nL(Z,W )dP\u0393(Z) (2)\ns.t. W \u2208 \u2126, (3)\nwhere R(W ) is the expected risk function, W \u2208 \u2126 is the optimization variable, and Z \u2208 Z\u0393 is a random variable with probability measure P\u0393. The loss function L : Z\u0393 \u00d7 \u2126 \u2192 R measures the performance of the learning system with parameter W given an observable event Z. We assume that the loss L(Z,W ) is generalized differentiable inW and integrable in Z. The expectation E is taken with respect to some probability space (Z\u0393,\u03a3\u0393, P\u0393).\nSince the distribution PZ of the observable events Z \u2208 Z is usually unknown, the expected risk function R(W ) can neither be computed nor be minimized directly. In addition, the loss function L(W,Z) is neither convex nor differentiable. The field of stochastic approximation provides methods to minimize R(W ) that are consistent under very general conditions.\nSince the interchange of integral and generalized gradient is valid, that is \u2202WR(W ) = E [\u2202WL(Z,W )] under mild assumptions [8, 22], we can minimize the expected risk R(W ) according to the following stochastic generalized gradient (SGG) method:\nWt+1 = \u03a0\u2126 (Wt \u2212 \u03b7tSt), t \u2265 0,\nwhere W0 \u2208 \u2126 and \u03a0\u2126 is a projection operator on \u2126. The random structures St are stochastic generalized gradients, i.e. random variables defined on the probability space (Z\u0393,\u03a3\u0393, P\u0393) \u221e such that\nE [St |W0, . . . ,Wt] \u2208 \u2202WR (W ) . (4)\nWe can take St = g(Zt,Wt) with iid (Zt)t\u22650 and some single valued selection g(Z,W ) \u2208 \u2202WL(Z,W ), measurable in (Z,W ). We consider the following conditions for almost sure convergence of the SSG method:\nA1 The sequence (\u03b7t)t\u22650 of step sizes satisfies\n\u03b7t > 0, lim t\u2192\u221e \u03b7t = 0,\n\u221e \u2211\nt=1\n\u03b7t = \u221e, \u221e \u2211\nt=1\n\u03b72t <\u221e.\nA2 The sequence (St)t\u22650 satisfies (4).\nA3 We have E [ \u2016St\u2016 2 ] < +\u221e.\nThen by Ermoliev and Norkin\u2019s Theorem [8], the SGG method is consistent in the sense that the sequence (Wt)t\u22650 converges almost surely to points satisfying necessary extremum conditions\n\u2126\u2217 = {W \u2208 \u2126 : 0 \u2208 \u2202WR(W ) +N\u2126(W )},\nwhere N\u2126(W ) is a normal cone to the constraint set \u2126 at W \u2208 \u2126. Besides the sequence (R(Wt))t\u22650 converges almost surely and limtR(Wt) \u2208 R(\u2126 \u2217).\nSince orbifolds generalize Euclidean spaces and manifolds the consistency theorem is also valid for standard machine learning algorithms in Euclidean spaces with differentiable cost function (e.g multi-layer perceptron) and non-differentiable cost function (e.g. online k-means) [4]."}, {"heading": "6 Examples", "text": "This section extends some typical examples of statistical data analysis and learning problems from vector spaces to structured domains. We assume that Q = (X ,\u0393, \u03c0) is a Riemannian orbifold with optimal alignment kernel k(\u00b7|\u00b7).\nOrbifold-Adaline. Orbifold adaline generalizes the adaline proposed by [26].\nLet W = X\u0393 \u00d7 R be the parameter space and let Z = X\u0393 \u00d7 {\u00b11} be the space of observable data. The parameter space W consists of augmented parameter structures W \u2032 = (W, b), where W \u2208 X\u0393 is the weight structure and b \u2208 R is the bias. The observable data Z = (X, y) from Z consists of input structures X \u2208 X\u0393 together with their labels y \u2208 {\u00b11}.\nThe loss function of the orbifold-Adaline is of the form\nLada(Z,W \u2032) =\n( y \u2212 (k(X,W ) + b) )2 .\nSince k(\u00b7|\u00b7) is generalized differentiable, so is Lada(Z,W ). Lifting the loss Lada to the Euclidean space gives\nL\u0302ada ( z,w\u2032 ) = ( y \u2212max {\u2329 x\u2032,w \u232a : x\u2032 \u2208 X } \u2212 b ) 2,\nwhere z = (x, y) \u2208 Z and w\u2032 = (w, b) \u2208 W with vector representations x and y that project to structures X \u2208 X\u0393 and W \u2208 X\u0393, respectively. The update rule is given by\nwt+1 = wt \u2212 \u03b7t (yt \u2212 \u3008x \u2217 t ,wt\u3009x \u2217 t )\nbt+1 = bt \u2212 \u03b7t (yt \u2212 bt),\nwhere (x\u2217t ,wt) is an optimal alignment.\nLearning Orbifold Maps. This example presents a generic formulation of learning functional relationships between orbifolds in a supervised manner. Since orbifolds generalize Euclidean spaces, this setting covers various types of functional relationships that can be learned. Non-standard examples include multi-layer perceptrons for adaptive processing of graphs [20] and learning to predict structured data [2].\nLet QW = (W,\u2126, \u03c8), QX = (X ,\u0393, \u03c0), and QY = (Y,\u039b, \u03c6) be Riemannian orbifolds. The parameter space is represented by orbifold QW and the space of observable data by\nthe orbifold QZ = QX\u00d7QY . Suppose that F is a class of generalized differentiable orbifold mappings of the form\nf : X\u0393 \u00d7W\u2126 \u2192 Y\u039b.\nThe mean-squared-error loss function is defined by\nLmse(Z,W ) = 1\n2 (Y \u2212 f(X,W ))2 .\nLifting this loss function yields\nL\u0302mse(z,w) = 1\n2\n( y \u2212 f\u0302(x,w) )2 ,\nwhere z = (x,y) projects to structure Z = (X,Y ) and w projects to W . The update rule is then of the form\nwt+1 = wt \u2212 \u03b7t ( yt \u2212 f\u0302(xt,wt) ) T g(xt,wt),\nwhere g(xt,wt) \u2208 \u2202L\u0302mse(zt,wt) is a stochastic generalized gradient of the lifted loss at wt.\nStructure Quantization. Structure quantization generalizes vector quantization to the quantization of structures. For graphs, a number of structure quantizer design techniques for the purpose of central clustering have already been proposed. Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].\nLet W = X k\u0393 be the parameter space and let Z = X\u0393 be the space of observable data. The parameter space W consists of k-tuples W = (W1, . . . ,Wk), called codebook.\nThe general loss function of structure quantization is defined by the distortion\nLsq(X,W ) = min 1\u2264i\u2264k d(X,Wi).\nFor generalized differentiable distance function d(\u00b7|\u00b7), the update rule is defined by\nw\u2217t+1 = w \u2217 t \u2212 \u03b7g(xt,w \u2217 t ),\nwhere (xt,w \u2217 t ) is an optimal alignment of input structure Xt and its closest codebook structure W \u2217t . If d(\u00b7|\u00b7) is the squared intrinsic metric, we have g(x,w \u2217 t ) = xt \u2212w \u2217 t .\nObserve that structure quantization also generalizes the problem of estimating a mean graph of Section 2.4 by fixing the number k of centroids to 1."}, {"heading": "7 Conclusion", "text": "This contribution proves consistency of learning in structured domains by reducing it to stochastic generalized gradient learning on Riemannian orbifolds. The proposed framework is applicable to learning on combinatorial structures such as point patterns, trees, and\ngraphs. In retrospect, the proposed results provide a theoretical foundation and statistical justification of a number of existing learning methods that directly operate in the domain of graphs. In addition, the orbifold framework provides a generic technique to generalize gradient-based learning methods to structured domains. Future work aims at generalizing the theory to more general Riemannian orbifolds and to discontinuous graph edit distance functions.\nAcknowledgments.\nThe authors are very grateful to Vladimir Norkin for his kind support and valuable comments."}], "references": [{"title": "A linear programming approach for the weighted graph matching problem", "author": ["H.A. Almohamad", "S.O. Duffuaa"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on, 15(5):522\u2013525", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1993}, {"title": "editors", "author": ["G. Bakir", "T. Hofmann", "B. Sch\u00f6lkopf", "A.J. Smola", "B. Taskar"], "venue": "Predicting structured data. The MIT Press", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Riemannian geometry of orbifolds", "author": ["J.E. Borzellino"], "venue": "PhD thesis, University of California, Los Angelos", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1992}, {"title": "Stochastic learning", "author": ["L. Bottou"], "venue": "Advanced lectures on machine learning, pages 146\u2013 168", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "On a relation between graph edit distance and maximum common subgraph", "author": ["H. Bunke"], "venue": "Pattern Recognition Letters, 18(8):689 \u2013 694", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1997}, {"title": "L", "author": ["T.S. Caetano"], "venue": "Cheng, Q.V. Le, , and A.J. Smola. Learning graph matching. In International Conference on Computer Vision, ICCV 2007, pages 1\u20138", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2007}, {"title": "Balanced graph matching", "author": ["T. Cour", "P. Srinivasan", "J. Shi"], "venue": "Advances in Neural Information Processing Systems, NIPS 2007, volume 19", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Stochastic generalized gradient method for nonconvex nonsmooth stochastic optimization", "author": ["Y.M. Ermoliev", "V.I. Norkin"], "venue": "Cybernetics and Systems Analysis, 34(2):196\u2013 215", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1998}, {"title": "Theory and algorithms on the median graph", "author": ["M. Ferrer"], "venue": "Application to graph-based classification and clustering. PhD thesis, Universitat Aut\u00f2noma de Barcelona", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2007}, {"title": "I", "author": ["M. Ferrer", "E. Valveny", "F. Serratosa"], "venue": "Bardaj\u0301\u0131, and H. Bunke. Graph-based k-means clustering: A comparison of the set median versus the generalized median graph. In Computer Analysis of Images and Patterns, CAIP 2009, pages 342\u2013350", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "A graduated assignment algorithm for graph matching", "author": ["S. Gold", "A. Rangarajan"], "venue": "Ieee Transactions On Pattern Analysis and Machine Intelligence, 18(4):377\u2013388", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1996}, {"title": "Learning with preknowledge: Clustering with point and graph matching distance measures", "author": ["S Gold", "A Rangarajan", "E Mjolsness"], "venue": "Neural Computation, 8(4):787\u2013 804", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1996}, {"title": "Self-organizing map for clustering in the graph domain", "author": ["S. G\u00fcnter", "H. Bunke"], "venue": "Pattern Recognition Letters, 23(4):405\u2013417", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2002}, {"title": "Median graph computation for graph clustering", "author": ["A. Hlaoui", "S. Wang"], "venue": "Soft Computing-A Fusion of Foundations, Methodologies and Applications, 10(1):47\u201353", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2006}, {"title": "On the sample mean of graphs", "author": ["B. Jain", "K. Obermayer"], "venue": "International Joint Conference on Neural Networks, IJCNN 2008, pages 993\u20131000", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "Algorithms for the sample mean of graphs", "author": ["B. Jain", "K. Obermayer"], "venue": "Computer Analysis of Images and Patterns, CAIP 2009, pages 351\u2013359", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "Graph quantization", "author": ["B. Jain", "K. Obermayer"], "venue": "arXiv:1001.0921v1 [cs.AI]", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2009}, {"title": "Structure spaces", "author": ["B. Jain", "K. Obermayer"], "venue": "Journal of Machine Learning Research, 10:2667\u20132714", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2009}, {"title": "Central clustering of attributed graphs", "author": ["B. Jain", "F. Wysotzki"], "venue": "Machine Learning, 56(1-3):169\u2013207", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2004}, {"title": "Structural perceptrons for attributed graphs", "author": ["B. Jain", "F. Wysotzki"], "venue": "Structural, Syntactic, and Statistical Pattern Recognition, SSPR/SPR 2004, pages 85\u201394", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2004}, {"title": "An median graphs: properties", "author": ["X. Jiang", "A. Munger", "H. Bunke"], "venue": "algorithms, and applications. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 23(10):1144\u20131151", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2001}, {"title": "Stochastic generalized-differentiable functions in the problem of nonconvex nonsmooth stochastic optimization", "author": ["V.I. Norkin"], "venue": "Cybernetics, 22(6):804\u2013809", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1986}, {"title": "Clustering of web documents using graph representations", "author": ["A. Schenker", "H. Bunke", "M. Last", "A. Kandel"], "venue": "Applied Graph Theory in Computer Vision and Pattern Recognition, volume 52 of Studies in Computational Intelligence, pages 247\u2013265. Springer", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2007}, {"title": "An eigendecomposition approach to weighted graph matching problems", "author": ["S. Umeyama"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., 10(5):695\u2013703", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1988}, {"title": "A rkhs interpolator-based graph matching algorithm", "author": ["M.A. van Wyk", "T.S. Durrani", "B.J. van Wyk"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2002}, {"title": "Adaptive switching circuits", "author": ["B. Widrow", "M.E. Hoff"], "venue": "IRE WESCON Convention Record, volume 4, pages 96\u2013104", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1960}], "referenceMentions": [{"referenceID": 8, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 165, "endOffset": 180}, {"referenceID": 15, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 165, "endOffset": 180}, {"referenceID": 14, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 165, "endOffset": 180}, {"referenceID": 20, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 165, "endOffset": 180}, {"referenceID": 9, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 11, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 12, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 13, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 18, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 14, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 22, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 211, "endOffset": 239}, {"referenceID": 16, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 269, "endOffset": 273}, {"referenceID": 19, "context": "Examples from structural pattern recognition that learn on structured data include estimating central points of a distribution on graphs such as the mean and median [9, 16, 15, 21], central clustering of graphs [10, 12, 13, 14, 19, 15, 23], learning graph quantization [17], and multilayer perceptrons for graphs [20].", "startOffset": 313, "endOffset": 317}, {"referenceID": 17, "context": "In retrospect, the structure space framework proposed by [18] theoretically justifies the above approaches in the sense that they actually minimize an empirical risk function on structures.", "startOffset": 57, "endOffset": 61}, {"referenceID": 17, "context": "For this we regard graphs as points of some structure space [18].", "startOffset": 60, "endOffset": 64}, {"referenceID": 17, "context": "In comparison to [18], the innovations are as follows: First, we extend the more suitable concept of generalized differentiability in the sense of Norkin [22] to functions on graphs.", "startOffset": 17, "endOffset": 21}, {"referenceID": 21, "context": "In comparison to [18], the innovations are as follows: First, we extend the more suitable concept of generalized differentiability in the sense of Norkin [22] to functions on graphs.", "startOffset": 154, "endOffset": 158}, {"referenceID": 7, "context": "Third, equipped with these results, we apply a consistency theorem by Ermoliev and Norkin [8] for generalized differentiable loss functions.", "startOffset": 90, "endOffset": 93}, {"referenceID": 3, "context": "Fourth, since orbifolds generalize Euclidean spaces and manifolds, this framework not only establishes consistency for stochastic generalized gradient learning but also for standard stochastic gradient learning in Euclidean spaces (see [4]) under the unifying umbrella of learning on Riemannian orbifolds.", "startOffset": 236, "endOffset": 239}, {"referenceID": 10, "context": "Examples are geometric graph distance functions [11] and distances based on the maximum common subgraph including graph and subgraph isomorphism [5].", "startOffset": 48, "endOffset": 52}, {"referenceID": 4, "context": "Examples are geometric graph distance functions [11] and distances based on the maximum common subgraph including graph and subgraph isomorphism [5].", "startOffset": 145, "endOffset": 148}, {"referenceID": 21, "context": "We therefore address the following questions: (i) How can we extend gradient-based learning problems from Euclidean spaces to GA? (ii) How can we minimize the expected risk of a learning problem with structured input- and/or output-space GA in a statistically consistent way? The ansatz to answer both questions is to identify graphs as points of a Riemannian orbifold and to extend the concept of generalized differentiability in the sense of Norkin [22] in order to apply methods from stochastic optimization for non-differentiable and non-convex loss functions.", "startOffset": 451, "endOffset": 455}, {"referenceID": 17, "context": "In doing so, we can refer to [18] for proofs of statements and claims made in this section.", "startOffset": 29, "endOffset": 33}, {"referenceID": 2, "context": "In this case, we refer to [3] for more details.", "startOffset": 26, "endOffset": 29}, {"referenceID": 0, "context": "This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].", "startOffset": 93, "endOffset": 114}, {"referenceID": 5, "context": "This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].", "startOffset": 93, "endOffset": 114}, {"referenceID": 6, "context": "This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].", "startOffset": 93, "endOffset": 114}, {"referenceID": 10, "context": "This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].", "startOffset": 93, "endOffset": 114}, {"referenceID": 23, "context": "This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].", "startOffset": 93, "endOffset": 114}, {"referenceID": 24, "context": "This graph metric occurs in various different guises as a common choice of proximity measure [1, 6, 7, 11, 24, 25].", "startOffset": 93, "endOffset": 114}, {"referenceID": 21, "context": "4 Generalized Gradients This section extends the concept of generalized differentiability in the sense of Norkin [22] to orbifold functions.", "startOffset": 113, "endOffset": 117}, {"referenceID": 21, "context": "Generalized differentiable functions have the following properties [22]: 1.", "startOffset": 67, "endOffset": 71}, {"referenceID": 7, "context": "Since the interchange of integral and generalized gradient is valid, that is \u2202WR(W ) = E [\u2202WL(Z,W )] under mild assumptions [8, 22], we can minimize the expected risk R(W ) according to the following stochastic generalized gradient (SGG) method: Wt+1 = \u03a0\u03a9 (Wt \u2212 \u03b7tSt), t \u2265 0, where W0 \u2208 \u03a9 and \u03a0\u03a9 is a projection operator on \u03a9.", "startOffset": 124, "endOffset": 131}, {"referenceID": 21, "context": "Since the interchange of integral and generalized gradient is valid, that is \u2202WR(W ) = E [\u2202WL(Z,W )] under mild assumptions [8, 22], we can minimize the expected risk R(W ) according to the following stochastic generalized gradient (SGG) method: Wt+1 = \u03a0\u03a9 (Wt \u2212 \u03b7tSt), t \u2265 0, where W0 \u2208 \u03a9 and \u03a0\u03a9 is a projection operator on \u03a9.", "startOffset": 124, "endOffset": 131}, {"referenceID": 7, "context": "Then by Ermoliev and Norkin\u2019s Theorem [8], the SGG method is consistent in the sense that the sequence (Wt)t\u22650 converges almost surely to points satisfying necessary extremum conditions \u03a9 = {W \u2208 \u03a9 : 0 \u2208 \u2202WR(W ) +N\u03a9(W )},", "startOffset": 38, "endOffset": 41}, {"referenceID": 3, "context": "online k-means) [4].", "startOffset": 16, "endOffset": 19}, {"referenceID": 25, "context": "Orbifold adaline generalizes the adaline proposed by [26].", "startOffset": 53, "endOffset": 57}, {"referenceID": 19, "context": "Non-standard examples include multi-layer perceptrons for adaptive processing of graphs [20] and learning to predict structured data [2].", "startOffset": 88, "endOffset": 92}, {"referenceID": 1, "context": "Non-standard examples include multi-layer perceptrons for adaptive processing of graphs [20] and learning to predict structured data [2].", "startOffset": 133, "endOffset": 136}, {"referenceID": 11, "context": "Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].", "startOffset": 38, "endOffset": 50}, {"referenceID": 12, "context": "Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].", "startOffset": 38, "endOffset": 50}, {"referenceID": 16, "context": "Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].", "startOffset": 38, "endOffset": 50}, {"referenceID": 9, "context": "Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].", "startOffset": 95, "endOffset": 107}, {"referenceID": 14, "context": "Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].", "startOffset": 95, "endOffset": 107}, {"referenceID": 22, "context": "Examples include competitive learning [12, 13, 17] and k-means as well as k-medoids algorithms [10, 15, 23].", "startOffset": 95, "endOffset": 107}], "year": 2012, "abstractText": "Learning in Riemannian orbifolds is motivated by existing machine learning algorithms that directly operate on finite combinatorial structures such as point patterns, trees, and graphs. These methods, however, lack statistical justification. This contribution derives consistency results for learning problems in structured domains and thereby generalizes learning in vector spaces and manifolds.", "creator": "LaTeX with hyperref package"}}}