{"id": "1206.3318", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2012", "title": "On Local Regret", "abstract": "Online learning aims to perform nearly as well as the best hypothesis in hindsight. For some hypothesis classes, though, even finding the best hypothesis offline is challenging. In such offline cases, local search techniques are often employed and only local optimality guaranteed when the search is done. In order to understand the current and future possibilities of offline learning, we are going to have to learn how to use locally in order to obtain results from each class.\n\n\nThe following is an outline of the approach used to learn the best hypothesis classes in real-time.\nIn some cases, the ability to perform a local search can be done by using an on-demand (i.e. on-demand) application such as by writing an article or making a comment.\nIn this example, we can perform local search at the local search engine (i.e. on-demand) using a query that can be queried from a user to a query in real-time. In this case, we need to perform local search at the local search engine (i.e. on-demand) using a query that can be queried from a user to a query in real-time. In this example, we could implement a local search that could be queried from a user to a query in real-time. In this example, we could use a local search that could be queried from a user to a query in real-time. In this example, we could implement a local search that could be queried from a user to a query in real-time. In this example, we could use a local search that could be queried from a user to a query in real-time.\nA common feature of local search is that it offers an API for querying from a user using a local search. In some instances, a local search can be done on-demand and only by calling on the local search engine to query a specific query in real-time, as the following example uses the query method (i.e. on-demand and on-demand) in real-time. In this example, we could use the local search that can be queried from a user to a query in real-time, as the following example uses the query method (i.e. on-demand and on-demand) in real-time. In this example, we could use a local search that could be queried from a user to a query in real-time. In this example, we could use a local search", "histories": [["v1", "Thu, 14 Jun 2012 20:07:30 GMT  (185kb,D)", "http://arxiv.org/abs/1206.3318v1", "This is the longer version of the same-titled paper appearing in the Proceedings of the Twenty-Ninth International Conference on Machine Learning (ICML), 2012"]], "COMMENTS": "This is the longer version of the same-titled paper appearing in the Proceedings of the Twenty-Ninth International Conference on Machine Learning (ICML), 2012", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["michael bowling", "martin zinkevich"], "accepted": true, "id": "1206.3318"}, "pdf": {"name": "1206.3318.pdf", "metadata": {"source": "CRF", "title": "On Local Regret", "authors": ["Michael Bowling", "Martin Zinkevich"], "emails": ["bowling@cs.ualberta.ca", "maz@yahoo-inc.com"], "sections": [{"heading": "1 Introduction", "text": "An online learning task involves repeatedly taking actions and, after an action is chosen, observing the result of that action. This is in contrast to offline learning where the decisions are made based on a fixed batch of training data. As a consequence offline learning typically requires i.i.d. assumptions about how the results of actions are generated (on the training data, and all future data). In online learning, no such assumptions are required. Instead, the metric of performance used is regret: the amount of additional utility that could have been gained if some alternative sequence of actions had been chosen. The set of alternative sequences that are considered defines the notion of regret. Regret is more than just a measure of performance, though, it also guides algorithms. For specific notions of regret, no-regret algorithms exist, for which the total regret is growing at worst sublinearly with time, hence their average regret goes to zero. These guarantees can be made with no i.i.d., or equivalent assumption, on the results of the actions.\nOne traditional drawback of regret concepts is that the number of alternatives considered must be finite. This is typically achieved by assuming the number of available actions is finite, and for practical purposes, small. In offline learning this is not at all the case: offline hypothesis classes are usually very large, if not infinite. There have been attempts to achieve regret guarantees for infinite action spaces, but these have all required assumptions to be made on the action outcomes (e.g., convexity or smoothness). In this work, we propose new notions of regret, specifically for very large or infinite action sets, while avoiding any significant assumptions on the sequence of action outcomes. Instead, the action set is assumed to come equipped with a notion of locality, and regret is redefined to respect this notion of locality. This approach allows the online paradigm with its style of regret guarantees to be applied to previously intractable tasks and hypothesis classes."}, {"heading": "2 Background", "text": "For t \u2208 {1, 2, . . .}, let at \u2208 A be the action at time t, and ut : A\u2192 R be the utility function over actions at time t.\nRequirement 1. For all t, maxa,b\u2208A |ut(a)\u2212 ut(b)| \u2264 \u2206.\nThe basic building block of regret is the additional utility that could have been gained if some action b was chosen in place of action a: RTa,b = \u2211T t=1 1(a t = a) (ut(b)\u2212 ut(a)), where 1(condition) is equal to 1 when condition is true\nar X\niv :1\n20 6.\n33 18\nv1 [\ncs .A\nI] 1\n4 Ju\nn 20\nand 0 otherwise. We can use this building block to define the traditional notions of regret.\nRTinternal = max a,b\u2208A RT,+a,b R T swap = \u2211 a\u2208A max b\u2208A RT,+a,b (1)\nRTexternal = max b\u2208A (\u2211 a\u2208A RTa,b )+ (2)\nwhere x+ = max(x, 0) so that RT,+a,b = max(R T a,b, 0). Internal regret [Hart and Mas-Colell, 2002] is the maximum utility that could be gained if one action had been chosen in place of some other action. Swap regret [Greenwald and Jafari, 2003] is the maximum utility gained if each action could be replaced by another. External regret [Hannan, 1957], which is the original pioneering concept of regret, is the maximum utility gained by replacing all actions with one particular action. This is the most relaxed of the three concepts, and while the others must concern themselves with |A|2 possible regret values (for all pairs of actions) external regret only need worry about |A| regret values. So although the guarantee is weaker, it is a simpler concept to learn which can make it considerably more attractive. These three regret notions have the following relationships.\nRTinternal \u2264 RTswap \u2264 |A|RTinternal RTexternal \u2264 RTswap (3)"}, {"heading": "2.1 Infinite Action Spaces", "text": "This paper considers situations where A is infinite. To keep the notation simple, we will use max operations over actions to mean suprema operations and summations over actions to mean the suprema of the sum over all finite subsets of actions. Since we will be focused on regret over a finite time period, there will only ever be a finite set of actually selected actions and, hence only a finite number of non-zero regrets, RTa,b. The summations over actions will always be thought to be restricted to this finite set.\nNone of the three traditional regret concepts are well-suited to A being infinite. Not only does |A| appear in the regret bounds, but one can demonstrate that it is impossible to have no regret in some infinite cases. Consider A = N and let ut be a step function, so ut(a) = 1 if a > yt for some yt and 0 otherwise. Imagine yt is selected so that Pr[at > yt|u1,...,T\u22121, a1,...,T\u22121] \u2264 0.001, which is always possible. Essentially, high utility is always just beyond the largest action selected. Now, consider y\u2217 = 1 + maxt\u2264T yt. In expectation 1T \u2211T t=1 u\nt(at) \u2264 0.001 while 1 T \u2211T t=1 u\nt(y\u2217) = 1 (i.e., there is large internal and external regret for not having played y\u2217,) so the average regret cannot approach zero.\nMost attempts to handle infinite action spaces have proceeded by making assumptions on both A and u. For example, if A is a compact, convex subset of Rn and the utilities are convex with bounded gradient on A, then you can minimize regret even though A is infinite [Zinkevich, 2003]. We take an alternative approach where we make use of a notion of locality on the set A, and modify regret concepts to respect this locality. Different notions of locality then result in different notions of regret. Although this typically results in a weaker form of regret for finite sets, it breaks all dependence of regret on the size ofA and allows it to even be applied whenA is infinite and u is an arbitrary (although still bounded) function. Wide range regret methods Lehrer [2003] can also bound regret with respect to a set of (countably) infinite \u201calternatives\u201d, but unlike our results, their asymptotic bound does not apply uniformly across the set, and uniform finite-time bounds depend upon a finite action space Blum and Mansour [2007]."}, {"heading": "3 Local Regret Concepts", "text": "Let G = (V,E) be a directed graph on the set of actions, i.e., V = A. We do not assume A is finite, but we do assume G has bounded out-degree D = maxa\u2208V |{b : (a, b) \u2208 E}|. This graph can be viewed as defining a notion of locality. The semantics of an edge from a to b is that one should consider possibly taking action b in place of action a. Or rather, if there is no edge from a to b then one need not have any regret for not having taken action b when a was taken. By limiting regret only to the edges in this graph, we get the notion of local regret. Just as with traditional regret, which we will now refer to as global regret, we can define different variants of regret.\nRTlocalinternal = max (a,b)\u2208E RT,+a,b R T localswap = \u2211 a\u2208A max b:(a,b)\u2208E RT,+a,b (4)\nLocal internal and local swap regret just involve limiting regret to edges in G. Local external regret is more subtle and requires a notion of edge lengths. For all edges (i, j) \u2208 E, let c(i, j) > 0 be the edge\u2019s positive length. Define d(a, b) to be the sum of the edge lengths on a shortest path from vertex a to vertex b, and Eb = {(i, j) \u2208 E : d(i, j) = c(i, j) + d(j, b)} to be the set of edges that are on any shortest path to vertex b.\nRTlocalexternal = max b\u2208A  \u2211 (i,j)\u2208Eb RTi,j/D + (5) Global external regret considers changing all actions to some target action, regardless of locality or distance between the actions. In local external regret, only adjacent actions are considered, and so actions are only replaced with actions that take one step toward the target action. The factor of 1/D scales the regret of any one action by the out-degree, which is the maximum number of actions that could be one-step along a shortest path. This keeps local external regret on the same scale as local swap regret.\nIt is easy to see that these concepts hold the same relationships between each other as their global counterparts.\nRTlocalinternal \u2264 RTlocalswap \u2264 |A|RTlocalinternal (6) RTlocalexternal \u2264 RTlocalswap (7)\nMore interestingly, in complete graphs where there is an edge between every pair of actions (all with unit lengths) and so everything is local, we can exactly equate global and local regret.\nTheorem 1. If G is a complete graph with unit edge lengths then,\nRTlocalinternal = R T internal R T localswap = R T swap and R T localexternal = R T external/D. (8)\nProof.\nRTlocalinternal = max (a,b)\u2208E RT,+a,b = max a,b\u2208A RT,+a,b = R T internal (9)\nRTlocalswap = \u2211 a\u2208A max b:(a,b)\u2208E RT,+a,b = \u2211 a\u2208A max b\u2208A RT,+a,b = R T swap (10)\nRTlocalexternal = max b\u2208A \u2211 (i,j)\u2208Eb RT,+i,j /D (11)\n= 1/Dmax b\u2208A \u2211 a\u2208A RT,+a,b = R T external/D (12)\nSo our concepts of local regret match up with global regret when the graph is complete. Of course, we are not really interested in complete graphs, but rather more intricate locality structures with a large or infinite number of vertices, but a small out-degree. Before going on to present algorithms for minimizing local regret, we consider possible graphs for three different online decision tasks to illustrate where the graphs come from and what form they might take.\nExample 1 (Online Max-3SAT). Consider an online version of Max-3SAT. The task is to choose an assignment for n boolean variables: A = {0, 1}n. After an assignment is chosen a clause is observed; the utility is 1 if the clause is satisfied by the chosen assignment, 0 otherwise. Note that |A| = 2n which is computationally intractable for global regret concepts if n is even moderately large. One possible locality graph for this hypothesis class is the hypercube with an edge from a to b if and only if a and b differ on the assignment of exactly one variable (see Figure 1(a)), and all edges have unit lengths. So the out-degree D for this graph is only n. Local regret, then, corresponds to the regret for not having changed the assignment of just one variable. In essence, minimizing this concept of regret is the online equivalent of local search (e.g., WalkSAT [Selman et al., 1993]) on the maximum satisfiability problem, an offline task where all of the clauses are known up front.\nExample 2 (Online Disjunct Learning). Consider a boolean online classification task where input features are boolean vectors x \u2208 {0, 1}n and the target y is also boolean. Consider A = {0, 1}n, to be the set of all disjuncts such that a \u2208 A corresponds to the disjunct xi1 \u2228 xi2 \u2228 . . . \u2228 xik where i1\u2264j\u2264k are all of the k indices of a such that aij = 1. In this online task, one must repeatedly choose a disjunct and then observe an instance which includes a feature vector and the correct response. There is a utility of 1 if the chosen disjunct over the feature vector results in the correct response; 0 otherwise. Although a very different task, the action space A = {0, 1}n is the same as with Online MaxSAT and we can consider the same locality structure as that proposed for disjuncts: a hypercube with unit length edges for adding or removing a single variable to the disjunction (see Figure 1(a)). And as before |A| = 2n while D = n.\nExample 3 (Online Decision Tree Learning). Imagine the same boolean online classification task for learning disjuncts, but the hypothesis class is the set of all possible decision trees. The number of possible decision trees for n boolean variables is more than a staggering 22 n\n, which for any practical purpose is infinite. We can construct a graph structure that mimics the way decision trees are typically constructed offline, such as with C4.5 [Quinlan, 1993]. In the graph G, add an edge from one decision tree to another if and only if the latter can be constructed by choosing any node (internal or leaf) of the former and replacing the subtree rooted at the node with a decision stump or a label. There is one exception: you cannot replace a non-leaf subtree with a stump splitting on the same variable as that of the root of the subtree. See Figure 1(b) for a portion of the graph. Edges that replace a subtree with a label have length 1, while edges replacing a subtree with a stump (being a more complex change) have distance 1.1. So, we have local regret for not having further refined a leaf or collapsing a subtree to a simpler stump or leaf. Notice that the graph edges in this case are not all symmetric (viz., collapsing edges). In essence, this is the online equivalent of tree splitting algorithms. While |A| \u2265 22n , the out-degree is no more than (n + 1)2n+1. The maximum size of the out-degree still appears disconcertingly large, and we will return to this issue in Section 5 where we show how we can exploit the graph structure to further simplify learning."}, {"heading": "4 An Algorithm for Local Swap Regret", "text": "We now present an algorithm for minimizing local swap regret, similar to global swap regret algorithms [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003], but with substantial differences. The algorithm essentially chooses actions according to the stationary distribution of a Markov process on the graph, with the transition probabilities on the edges being proportional to the accumulated regrets. However there are two caveats that are needed for it to handle infinite graphs: it is prevented from playing beyond a particular distance from a designated root vertex, and there is an internal bias towards the actual actions chosen.\nFormally, let root be some designated vertex. Define d1 to be the unweighted shortest path distance between two vertices. Define the level of a vertex as its distance from root: L(v) = d1(root, v). Note that, L(root) = 0, and \u2200(i, j) \u2208 E, L(j) \u2264 L(i) + 1. All of the algorithms in this paper take a parameter L, and will never choose actions at a level greater than L. In addition, the algorithms all maintain values R\u0303ti,j (which are biased versions of R t i,j) and use these to compute \u03c0tj , the probability of choosing action j at time t. These probabilities are always computed according to the following requirement, which is a generalization of [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003].\nRequirement 2. Given a parameter L, for all t \u2264 T , and some R\u0303t,+i,j let \u03c0t+1 be such that (a) \u2211 j\u2208V \u03c0 t+1 j = 1, and \u2200j \u2208 V , \u03c0t+1j \u2265 0\n(b) \u2200j \u2208 V such that L(j) > L, \u03c0t+1j = 0. (c) \u2200j \u2208 V such that 1 \u2264 L(j) \u2264 L, \u03c0t+1j = \u2211 i:(i,j)\u2208E(R\u0303 t,+ i,j /M)\u03c0 t+1 i + (1\u2212 \u2211 k:(j,k)\u2208E R\u0303 t,+ j,k /M)\u03c0 t+1 j (d) \u03c0t+1root =\u2211 i:(i,root)\u2208E(R\u0303 t,+ i,root/M)\u03c0 t+1 i + \u2211 j:L(j)=L+1 \u2211 i:(i,j)\u2208E(R\u0303 t,+ i,j /M)\u03c0 t+1 i + (1\u2212 \u2211 j:(root,j)\u2208E R\u0303 t,+ root,j/M)\u03c0 t+1 root\n(e) If there exists j \u2208 V such that \u03c0t+1j > 0 and \u2211\nk:(j,k)\u2208E R\u0303 t,+ j,k = 0, then for all j \u2208 V where \u03c0t+1j > 0,\u2211\nk:(j,k)\u2208E R\u0303 t,+ j,k = 0, and we call such a \u03c0 t+1 degenerate.\nwhere M = max(i,j)\u2208E R\u0303 t,+ i,j . These conditions require \u03c0 t+1 to be the stationary distribution of the transition function whose probabilities on outgoing edges are proportional to their biased positive regret, with the root vertex as the starting state, and all outgoing transitions from vertices in level L going to the root vertex instead.\nDefinition 2. (b, L)-regret matching is the algorithm that initializes R\u03030i,j = 0, chooses actions at time t according to a distribution \u03c0t that satisfies Requirement 2 and after choosing action i and observing ut updates R\u0303ti,j = R\u0303 t\u22121 i,j + (ut(j)\u2212 ut(i)\u2212 b) for all j where (i, j) \u2208 E, and for all other (k, l) \u2208 E where k 6= i, R\u0303tk,l = R\u0303t\u22121k,l . There are two distinguishing factors of our algorithm from [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003]: R\u0303 6= R, and past a certain distance from the root, we loop back. R\u0303 differs from R by the bias term, b. This term can be thought of as a bias toward the action selected by the algorithm. This is not the same as approaching the negative orthant with a margin for error. This small amount is only applied to the action taken, which is very different from adding a small margin of error to every edge.\nTheorem 3. For any directed graph with maximum out-degree D and any designated vertex root, (\u2206/(L + 1), L)regret matching, after T steps, will have expected local swap regret no worse than,\n1 T E[RTlocalswap] \u2264 \u2206 L+ 1 + \u2206 \u221a D|EL|\u221a T\n(13)\nwhere EL = {(i, j) \u2208 E|L(i) \u2264 L}. The proof can be found in Appendix A. The overall structure of the proof is similar to [Blackwell, 1956; Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003] with a few significant changes. As with most algorithms based on Blackwell, if there is an action you do not regret taking, playing that action the next round is \u201csafe\u201d. If not, the key quantity in the proof is a flow fi,j = \u03c0t+1i R\u0303 t,+ i,j for each edge. On most of the graph, the incoming flow is equal to the outgoing flow for each node in levels 1 to L. Since all the flow out from the nodes on one level is equal to the flow into the next, the total flow into (and out of) each level is equal. Thus, the flow out of the last level is only 1/(L+ 1) of the total flow on all edges since there are L+ 1 levels, including the root.\nTraditionally, we wish to show that the incoming flow of an action times the utility minus the outgoing flow of an action times the utility summed over all nodes is nonpositive, and then Blackwell\u2019s condition holds. In traditional proofs, for any given node, the flow in and out are equal, so regardless of the utility, they cancel. For our problem, the flow out of the last level is really a flow into the (L+ 1)st level, not the zeroeth level, so the difference in utilities between the zeroeth level and the (L + 1)st level creates a problem. On the other hand, because we subtract b from whatever action we select, we get to subtract b times the total flow. Since exactly 1/(L + 1) fraction of the flow is going into the (L+ 1)st level, these two discrepancies from the traditional approach exactly cancel. The second term of Equation (13) is a result of the traditional Blackwell approach. In the final analysis, we must account for the amount b we subtract from the regret each round. This means that if we get R\u0303 to approach the negative orthant, we only have bT local swap regret left. This is the first term of Equation (13)."}, {"heading": "5 Exploiting Locality Structure", "text": "The local swap regret algorithm in the previous section successfully drops all dependence on the size of the action set and thus can be applied even for infinite action sets. However, the appearance of |EL| in the bound in Theorem 3 is undesirable as |EL| \u2208 O(DL), and L is more likely to be 100 than 2, in order to keep the first term of the bound low. The bound, therefore, practically provides little beyond an asymptotic guarantee for even the simplest setting of Example 1. In this section, we will appeal to (i) the structure in the locality graph, and (ii) local external regret to achieve a more practical regret bound and algorithm."}, {"heading": "5.1 Cartesian Product Graphs", "text": "We begin by considering the case of G having a very strong structure, where it can be entirely decomposed into a set of product graphs. In this case, we can show that by independently minimizing local regret in the product graphs we can minimize local regret in the full graph.\nTheorem 4. LetG be a Cartesian product of graphs,G = G1\u2297 . . .\u2297Gk whereGl = (Vl, El). For all l \u2208 {1, . . . , k}, define utl : Vl \u2192 R, such that utl(al) = ut( \u2329 at1, . . . , a t l\u22121, al, a t l+1, . . . , a t k \u232a ), so utl is a utility function on the lth component of the action at time t assuming the other components remain unchanged. Let E[l] \u2286 E be the set of edges that change only on the lth component, so {E[l]}l=1,...,k forms a partition of E. Let Dl \u2264 D be the maximum degree of Gl. Finally, define\nRT,llocalexternal = max b\u2208Vl  \u2211 (i,j)\u2208Ebl T\u2211 t=1 1(atl = i)(u t l(j)\u2212 utl(i))/Dl + , where Ebl = {(i, j) \u2208 E[l] : d(i, bl) = c(i, j) + d(j, bl)}, i.e., it contains the edges that moves the lth component closer to bl. Then, RTlocalexternal \u2264 \u2211k l=1R T,l localexternal.\nProof.\nRTlocalexternal = max b\u2208V  \u2211 (i,j)\u2208Eb RTi,j/D + (14) = max\nb\u2208V  k\u2211 l=1 \u2211 (i,j)\u2208E[l]\u2229Eb RTi,j/D + (15) \u2264\nk\u2211 l=1 max b\u2208V  \u2211 (i,j)\u2208E[l]\u2229Eb RTi,j/D + (16) Since Dl \u2264 D,\n\u2264 k\u2211\nl=1\nmax b\u2208V  \u2211 (i,j)\u2208E[l]\u2229Eb RTi,j/Dl + (17) =\nk\u2211 l=1 max b\u2208V  \u2211 (i,j)\u2208E[l]\u2229Eb T\u2211 t=1 1(at = i)(ut(j)\u2212 ut(i))/Dl + (18) =\nk\u2211 l=1 max b\u2208V  \u2211 (i,j)\u2208Ebl T\u2211 t=1 1(at = i)(utl(j)\u2212 utl(i))/Dl + (19) =\nk\u2211 l=1 RT,llocalexternal (20)\nThe implication is that we if we apply independent regret minimization to each factor of our product graph, we can minimize local external regret on the full graph. For example, consider the hypercube graphs from Example 1 and 2. By applying n independent external regret algorithms (the component graphs in this case are 2-vertex complete graphs), the overall local external regret for the graph is at most n times bigger than the factors\u2019 regrets, so under regret matching it is bounded by n\u2206 \u221a 2/ \u221a T . Hence, we are able to handle an exponentially large graph (in n) with local external regret only growing linearly (in n). If the component graphs are not complete graphs, then we can simply apply our local swap regret algorithm from the previous section to the graph factors, which minimizes local external regret as well."}, {"heading": "5.2 Color Regret", "text": "Cartesian product graphs are a powerful, but not very general structure. We now substantially generalize the product graph structure, which will allow us to achieve a similar simplification for very general graphs, such as the graph on decision trees in Example 3. The key insight of product graphs is that for any vertex b, an edge moves toward b if and only if its corresponding edge in its component graph moves toward bl. In other words, either all of the edges that correspond to some component edge will be included in the external regret sum, or none of the eges will. We can group together these edges and only worry about the regret of the group and not its constituents. We generalize this fact to graphs which do not have a product structure.\nDefinition 5. An edge-coloring C = {Ci}i=1,2,... for an arbitrary graph G with edge lengths is a partition of E: Ci \u2286 E, \u22c3 i Ci = E, and Ci \u22c2 Cj = \u2205. We say that C is admissble if and only if for all b \u2208 V , C \u2208 C, and (i, j), (i\u2032, j\u2032) \u2208 C, d(i, b) = c(i, j) + d(i, b)\u21d4 d(i\u2032, b) = c(i\u2032, j\u2032) + d(j\u2032, b). In other words, for any arbitrary target, all of the edges with the same color are on a shortest path, or none of the edges are.\nWe now consider treating all of the edges of the same color as a single entity for regret. This gives us the notion of local colored regret.\nRTlocalcolor = \u2211 C\u2208C  \u2211 (i,j)\u2208C RTi,j + (21) Theorem 6. If C is admissible then RTlocalexternal \u2264 RTlocalcolor/D. Proof.\nRTlocalexternal = max b\u2208A  \u2211 (i,j)\u2208Eb RTi,j/D + (22) = max\nb\u2208A \u2211 C\u2208C \u2211 (i,j)\u2208C\u2229Eb RTi,j/D + (23) For a particular target b let Cb = {C \u2208 C : C \u2286 Eb}, i.e., Cb is the set of colors that reduces the distance to b. Then by C\u2019s admissibility,\nRTlocalexternal = max b\u2208A  \u2211 C\u2208Cb \u2211 (i,j)\u2208C RTi,j/D + (24) \u2264 max\nb\u2208A \u2211 C\u2208Cb  \u2211 (i,j)\u2208C RTi,j/D + (25) \u2264 \u2211 C\u2208C  \u2211 (i,j)\u2208C RTi,j/D\n+ (26) = RTlocalcolor/D (27)\nSo by minimizing local colored regret, we minimize local external regret. The natural extension of our local swap regret algorithm from the previous section results in an algorithm that can minimize local colored regret.\nDefinition 7. (b, L,C)-colored-regret-matching is the algorithm that initializes R\u03030C = 0, for all C \u2208 C, chooses actions at time t according to a distribution \u03c0t that satisfies Requirement 2 with R\u0303ti,j \u2261 R\u0303tc(i,j), and after choosing action i and observing ut at time t for all C \u2208 C updates R\u0303tC = R\u0303t\u22121C + \u2211 j:(i,j)\u2208C(u t(j)\u2212 ut(i)\u2212 b).\nTheorem 8. For an arbitrary graph G with maximum degree D, arbitrarily chosen vertex root, and edge coloring C, (\u2206/(L+ 1), L,C)-colored-regret matching applied after T steps will have expected local colored regret no worse than,\n1 T E[RTlocalcolor] \u2264 \u2206D L+ 1 + \u2206 \u221a D|CL|\u221a T\nwhere CL = {C \u2208 C|\u2203(i, j) \u2208 C s.t. L(i) \u2264 L}.\nThe proof is in Appendix B. The consequence of this bound depends upon the number of colors needed for an admissible coloring. Very small admissible colorings are often possible. The hypercube graph needs only 2n colors to give an admissible coloring, which is exponentially smaller than the total number of edges, n2n. We can also find a reasonably tight coloring for our decision tree graph example, despite being a complex asymmetric graph.\nExample 4 (Colored Decision Tree Learning). Reconsider Example 3 and the graph in Figure 1(b). Recall that an edge exists between one decision tree and another if the latter can be constructed from the former by replacing a subtree at any node (internal or leaf) with a label (edge length 1) or a stump (edge length 1.1). We will color this edge with the pair: (i) the sequence of variable assignments that is required to reach the node being replaced, and (ii) the stump or label that replaces it. This coloring is admissible. We can see this fact by considering a color: the sequence of variable assignments and resulting stump or label. If this color is consistent with the target decision tree (i.e., the sequence exists in the target decision tree, and the variable of the added stump matches the variable split on at that point in the target decision tree) then the color must move you closer to the target tree. A formal proof of its admissibility is very involved and can be found in Appendix C."}, {"heading": "6 Experimental Results", "text": "The previous section presented algorithms that minimize local swap and local external regret (by minimizing local colored regret). The regret bounds have no dependence on the size of the graph beyond the graph\u2019s degree, and so provide a guarantee even for infinite graphs. We now explore these algorithms\u2019 practicality as well as illustrate the generality of the concepts by applying them to a diverse set of online problems. The first two tasks we examine, online Max-3SAT and online decision tree learning, have not previously been explored in the online setting. The final task, online disjunct learning, has been explored previously, and will help illustrate some drawbacks of local regret.\nIn all three domains we examine two algorithms. The first minimizes local swap regret by applying (\u2206/(L+1), L)regret matching with L chosen specifically for the problem. This will be labeled \u201cLocal Swap\u201d. The second focuses on local external regret by using a tight, admissible edge-coloring and applying (\u2206/(L + 1), L,C)-colored-regret matching. This will be labeled simply \u201cLocal External\u201d."}, {"heading": "6.1 Online Max-3SAT", "text": "First, we consider Example 1. We randomly constructed problem instances with n = 20 boolean variables and 201 clauses each with 3 literals. On each timestep, the algorithms selected an assignment of the variables, a clause was chosen at random from the set, and the algorithm received a utility of 1 if the assignment satisfied the clause, 0 otherwise. This was repeated for 1000 timesteps. The locality graph used was the n-dimensional hypercube from Example 1. The admissible coloring used to minimize local external regret was the 2n coloring that has two colors per variable (one for turning the variable on, and one for turning the variable off). In both cases we set L =\u221e and b = 0,\nsince the bounds do not depend on L once it exceeds 20. This also achieved the best performance for both algorithms. The average results over 200 randomly constructed sets of clauses are shown in Figure 2, with 95% confidence bars.\nFigure 2 (a) shows the time-averaged colored regret of the two algorithms, to demonstrate how well the algorithms are actually minimizing regret. Both are decreasing over time, while external regret is decreasing much more rapidly. As expected, swap regret may be a stronger concept, but it is more difficult to minimize. The local external regret algorithm after only one time step can have regret for not having made a particular variable assignment, while local swap regret has to observe regret for this assignment from every possible assignment of the other variables to achieve the same result. This is further demonstrated by the number of regret values each algorithm is tracking: local external regret on average had 34 non-zero regret values, while local swap regret had 4200 non-zero regret values. In summary, external regret provides a powerful form of generalization. Figure 2 (b) shows the fraction of the previous 100 clauses that were satisfied. Two baselines are also presented. A random choice of variable assignments can satisfy 78 of the clauses in expectation. We also ran WalkSAT [Selman et al., 1993] offline on the set of 201 clauses, and on average it was able to satisfy all but 4% of the clauses, which gives an offline lower bound for what is possible. Both substantially outperformed random, with the external regret algorithm nearing the performance of the offline WalkSat."}, {"heading": "6.2 Online Decision Tree Learning", "text": "Second, we consider Example 3. We took three datasets from the UCI Machine Learning Repository (each with categorical inputs and a large number of instances): nursery, mushroom, and king-rook versus king-pawn [Frank and Asuncion, 2010]. The categorical attributes were transformed into boolean attributes (which simplified the implementation of the locality graphs) by having a separate boolean feature for each attribute value.1 We made the problems online classification tasks by sampling five instances at random (with replacement) for each timestep, with the utility being the number classified correctly by the algorithm\u2019s chosen decision tree. This was repeated for 1000 timesteps, and so the algorithms classified 5,000 instances in total. The locality graph used was the one described in Example 3. The tight coloring used to minimize local external regret was the one described in Example 4. L was set to 3 for local swap regret, and 100 for local external regret, as this achieved the best performance. Even with the far larger graph, the external regret algorithm was observing nearly one-eighth of the number of non-zero regret values observed by the local swap algorithm. The average results over 50 trials are shown in Figure 3(a)-(c) with 95% confidence bars.\nThe graphs show the average fraction of misclassified instances over the previous 100 timesteps. Two baselines are also plotted: the best single label (i.e., the size of the majority class) and the best decision stump. Both regret algorithms substantially improved on the best label, and local external regret was selecting trees substantially better than the best stump. As a further baseline, we ran the batch algorithm C4.5 in an online fashion, by retraining a decision tree after each timestep using all previously observed examples. C4.5\u2019s performance was impressive, learning highly accurate trees after observing only a small fraction of the data. However, C4.5 has no regret guarantees. As with\n1As a result, there were n = 28 features for nursery, 118 features for mushroom, and 74 features for king-rook versus king-pawn.\nany offline algorithm used in an online fashion, there is an implicit assumption that the past and future data instances are i.i.d.. In our experimental setup, the instances were i.i.d., and as a result C4.5 performed very well. To further illustrate this point, we constructed a simple online classification task where instances with identical attributes were provided with alternating labels. The best label (as well as the single best decision tree) has a 50% accuracy. C4.5 when trained on the previously observed instances, misclassifies every single instance. This is shown along with local regret algorithms in Figure 3 (d)."}, {"heading": "6.3 Online Disjunct Learning", "text": "Finally, we examine online disjunct learning as described in Example 2. This task has received considerable attention, notably the celebrated Winnow algorithm [Littlestone, 1988], which is guaranteed to make a finite number of mistakes if the instances can be perfectly classified by some disjunction. Furthermore, the number of mistakes Winnow2 makes, when no disjunction captures the instances, can be bounded by the number of attribute errors (i.e., the number of input attributes that must be flipped to make the disjunction satisfy the instance) made by the best disjunction. In these experiments we compare our algorithms\u2019 performance to that of Winnow2.\nWe looked at two learning tasks. In the first, we generated a random disjunction over n = 20 boolean variables, where a variable was independently included in the disjunction with probability 4/n. Instances were created with uniform random assignments to all of the variables, with a label being true if and only if the chosen disjunct is true for the instance\u2019s assignment. In the second case, we chose instances uniformly at random from a constructed set of\n21 instances: one for each variable with that variable (only) set to true and the label being true, and one with all of the variables assigned the value of true and the label being false. We call this task Winnow Killer. For both tasks, the n-dimensional hypercube from Example 1 was used as the locality graph with the 2n coloring as our admissible coloring, and L =\u221e and b = 0. The average results over 50 trials are shown in Figure 4, with 95% confience bars.\nThe graphs plot error rates over the previous 100 instances. Three baselines are plotted: randomly assigning a label (guaranteed to get half of the instances correct on expectation), the best disjunct (which makes no mistakes for random disjunctions and makes 121 mistakes on the Winnow Killer task), and Winnow2. Figure 4 (a) shows the results on random disjunctions. Winnow2 is guaranteed to make a finite number of mistakes and indeed its error rate drops to zero quickly. The local regret concepts, though, have difficulties with random disjunctions. The reason can be easily seen for the case of local external regret. Suppose the first instance is labeled true; the algorithm now has regret for all of the variables that were true in that instance (some of these will be in the target disjunction, but many will not). These variables will now be included in the chosen disjunction for a very long time, as the only regret that one can have for not removing them is if their assignment was the sole reason for misclassifying a false instance. In other words, the problem is that there\u2019s no regret for not removing multiple variables simultaneously as this is not a local change. Winnow2, though, also has issues. It performs very poorly in the Winnow Killer task (in fact, if the instances were ordered it could be made to get every instance wrong), as shown in Figure 4 (b). Since the mistake bound for Winnow2 is with respect to the number of attribute errors, a single mistake by the best disjunction can result in n mistakes by Winnow2. A further issue with Winnow is that while its peformance is tied to the performance of disjunctions, its own hypothesis class is not disjunctions but a thresholded linear function, whereas local regret is playing in the same class of hypotheses that it comparing against."}, {"heading": "7 Conclusion", "text": "We introduced a new family of regret concepts based on restricting regret to only nearby hypotheses using a locality graph. We then presented algorithms for minimizing these concepts, even when the number of hypotheses are infinite. Further we showed that we can exploit structure in the graph to achieve tighter bounds and better performance. These new regret concepts mimic local search methods, which are common approaches to offline optimization with intractably hard hypothesis spaces. As such, our concepts and algorithms allows us to make online guarantees, with a similar flavor to their offline counterparts, with these hypothesis spaces.\nThere is a number of interesting directions for future work as well as open problems. Admissible colorings can result in radically improved bounds as well as empirical performance. How can such admissible colorings be constructed for general graphs? What graph structures lead to exponentially small admissible colorings compared to the size of the graph? We can easily construct the minimum admissible coloring for graphs that are recursively constructed as Cartesian product of graphs and complete graphs. While such graphs can have exponentially small admissible colorings,\nthey form a very narrow class of structures. What other structures lead to exponentially small admissible colorings? Furthermore, edge lengths can have a significant impact on the size of the minimum admissible coloring. For example, the decision tree graph from Example 3 was carefully constructed to result in a tight coloring, and, in fact, unit length edges over the same graph would result in an exponentially larger admissible coloring. How can edge lengths be defined to allow for small minimum colorings?"}, {"heading": "Acknowledgements", "text": "This work was supported by NSERC and Yahoo! Research, where the first author was a visiting scientist at the time the research was conducted."}, {"heading": "A Proof for Local Swap Regret", "text": "At its heart, the Hart and Mas-Colell proof for minimizing internal regret relies on the relationship between Markov chains and flows. The Blackwell condition is (roughly speaking) that the probability flow into an action equals the probability flow out of an action. In the variant here, there are two ways to view this flow. Define f such that for all (i, j) \u2208 E, fi,j = \u03c0t+1i R\u0303t,+i,j . Implicitly, f depends on the time t, but we supress this as we always refer to a time t. This flow f is similar to the flows in Hart and Mas-Colell as they apply to the Blackwell condition. However, it lacks the conservation of flow property. Thus, we consider a second flow f \u2032 which satisfies the conservation of flow. To do this, we consider the levels of the graph. To review, root is a distinct vertex, and, L(v) = d1(root, v). If we consider the flow f as starting from the root, it (roughly) goes from level to level outward from the root until it reaches level L. Then, while f flows to level L + 1 and reaches a dead end (violating the conservation property), f \u2032 is switched, and flows back to the root. In order to make the proof work, we have to bound the difference between f and f \u2032. Since this difference is mostly on the flow from level L to level L+ 1, we need to bound the fraction of the total flow that is going out of the last level by showing that this flow is less than the flow going from the root to the first level, and it is less than the flow from the first level to the second level, et cetera.\nFirst we show that for nodes on most levels, the flow in equals the flow out.\nLemma 9. If Requirement 2 holds, then for all j \u2208 V such that 1 \u2264 L(j) \u2264 L,\u2211 i:(i,j)\u2208E fi,j = \u2211 k:(j,k)\u2208E fj,k\nCorollary 10. By summing over the nodes in level `, for any level 1 \u2264 ` \u2264 L,\u2211 (i,j)\u2208E:L(j)=` fi,j = \u2211 (i,j)\u2208E:L(i)=` fi,j .\nProof. From Requirement 2(c) we know there exists an M > 0 such that:\n\u03c0t+1j = \u2211\ni:(i,j)\u2208E\n(Rt,+i,j /M)\u03c0 t+1 i + 1\u2212 \u2211 k:(j,k)\u2208E Rt,+j,k /M \u03c0t+1j (28) \u03c0t+1j  \u2211 k:(j,k)\u2208E Rt,+j,k /M  = \u2211 i:(i,j)\u2208E\nRt,+i,j \u03c0 t+1 i /M (29)\u2211\nk:(j,k)\u2208E\n\u03c0t+1j R t,+ j,k = \u2211 i:(i,j)\u2208E Rt,+i,j \u03c0 t+1 i (30)\nThe lemma follows by the definition of fi,j .\nIf we want the conservation of flow to hold for all nodes, then we need to define a slightly different flow. We want to say that the flow which is currently exiting the first L levels (specifically between level L and level L+1) is actually flowing back into the root. So, we want to subtract the edgesE\u2032\u2032 = {(i, j) \u2208 E : L(j) \u2265 L+1\u2228L(i) \u2265 L+1}, and add the edges E\u2032 = {i \u2208 V : L(i) = L} \u00d7 {root}. For any edge e \u2208 E\u2032, define f \u2032i,j = fi,j + \u2211 k:L(k)=L+1,(i,k)\u2208E fi,k., where fi,j = 0 if (i, j) /\u2208 E. For any edge (i, j) \u2208 E\\(E\u2032 \u222a E\u2032\u2032) where L(i),L(j) \u2264 L, f \u2032i,j = fi,j . Define E\u0303 = (E \u222a E\u2032\\E\u2032\u2032).\nThus, we now have a flow over a graph (V, E\u0303), but we must prove conservation of flow. Lemma 11. If Requirement 2 holds, for any i \u2208 V ,\u2211j:(i,j)\u2208E\u0303 f \u2032i,j = \u2211j:(j,i)\u2208E\u0303 f \u2032j,i Proof. For L(i) \u2208 {1 . . . L\u2212 1}, this is a direct result of Requirement 2(c). For when L(i) > L, there is no flow out or in, making the result trivial. For L(i) = 0 (when i = root), this is a direct result of Requirement 2(d). For when\nL(i) = L, note that \u2211j:(j,i)\u2208E fj,i = \u2211j:(i,j)\u2208E fi,j , for all j where (j, i) \u2208 E, fj,i = f \u2032j,i, and for all (i, j) \u2208 E where L(j) \u2208 {1 . . . L}, fi,j = f \u2032i,j and that the flow \u2211 j:(i,j)\u2208E,L(j)\u2208{0,L+1} fi,j = f\n\u2032 i,root, so\u2211\nj:(j,i)\u2208E\nf \u2032j,i = \u2211\nj:(j,i)\u2208E\nfj,i (31)\n= \u2211\nj:(i,j)\u2208E\nfi,j (32)\n= \u2211\nj:(i,j)\u2208E,L(j)\u2208{0,L+1}\nfi,j + \u2211\nj:(i,j)\u2208E,L(j)\u2208{1...L}\nfi,j (33)\n= f \u2032i,root + \u2211\nj:(i,j)\u2208E,L(j)\u2208{1...L}\nf \u2032i,j (34)\n= \u2211\nj:(i,j)\u2208E\nf \u2032i,j . (35)\nLemma 12. If Requirement 2 holds, then:\u2211 (i,j)\u2208E fi,j \u2265 (L+ 1) \u2211 (i,j)\u2208E:L(j)=L+1 fi,j (36)\n\u2211 (i,j)\u2208E:L(i)=0 fi,j \u2265 \u2211 (i,j)\u2208E:L(j)=L+1 fi,j (37)\nProof. To obtain an intuition, consider the case where all outgoing edges from level j go to level j + 1 (modulo the last level). In this case, the flow from level 0 all goes to level 1, from there goes to level 2, and so forth until it reaches level L and then returns to level 0. Thus, the inflows and outflows of all the levels would be equal. The problem with this is that outgoing edges from level j can go to other nodes in j, or nodes in level j \u2212 1, et cetera. At an intuitive level, a backwards flow would not make more flow through the final level, any more than an eddy would somehow create water at the mouth of a river, and we must simply formally prove this.\nFirst, we define gi,j = \u2211 (k,l)\u2208E:L(k)=i,L(l)=j f \u2032 i,j , the total flow between levels. By Lemma 11 for all i \u2208\nV , \u2211\nj f \u2032 i,j = \u2211 j f \u2032 j,i, so the aggregate flow satisfies the conservation of flow, namely that for all i, \u2211L j=0 gi,j =\u2211L\nj=0 gj,i. Also, if j > i + 1, then gi,j = 0. Define ni = gi,i+1, the flow between one level and the next. Since f , f \u2032, and g are just different groupings of the total flow throughout the graph, \u2211 (i,j)\u2208E fi,j = \u2211 (i,j)\u2208E\u0303 f\n\u2032 i,j =\u2211L\ni=0 \u2211L j=0 gi,j . Since for all i, j \u2208 V , f \u2032i,j \u2265 0, then for all i, j, gi,j \u2265 0. gL,0 + \u2211L\u22121 i=0 ni \u2264 \u2211 (i,j)\u2208E fi,j .\nMoreover, n0 = g0,1 = \u2211 j:(root,j)\u2208E f \u2032 root,j = \u2211 j:(root,j)\u2208E froot,j , and gL,0 \u2265 \u2211 (i,j)\u2208E:L(j)=L+1 fi,j . So if we\nprove that for all i, gL,0 \u2264 ni, then gL,0 \u2264 n0 and that gL,0(L+ 1) \u2264 gL,0 + \u2211L\u22121\ni=0 ni, we have proven the lemma. First, we identify this backwards flow. Define \u03b4i to be the flow that originates at level i or above and flows back to a lower level. Formally, define \u03b40 = 0, and \u03b4i = \u2211\ni\u2032<i,j\u2032\u2265i gj\u2032,i\u2032 \u2212 gL,0. Note that \u03b4i \u2265 0. Thus, for all i where 0 < i < L:\n\u03b4i \u2212 \u03b4i+1 =  \u2211 i\u2032<i,j\u2032\u2265i gj\u2032,i\u2032 \u2212  \u2211 i\u2032<i+1,j\u2032\u2265i+1 gj\u2032,i\u2032  (38) \u03b4i \u2212 \u03b4i+1 =\n \u2211 i\u2032<i,j\u2032=i gj\u2032,i\u2032 +  \u2211 i\u2032<i,j\u2032\u2265i+1 gj\u2032,i\u2032 \u2212  \u2211 i\u2032=i,j\u2032\u2265i+1 gj\u2032,i\u2032 \u2212  \u2211 i\u2032<i,j\u2032\u2265i+1 gj\u2032,i\u2032  (39) \u03b4i \u2212 \u03b4i+1 =\n \u2211 i\u2032<i,j\u2032=i gj\u2032,i\u2032 \u2212  \u2211 i\u2032=i,j\u2032\u2265i+1 gj\u2032,i\u2032  (40) \u03b4i \u2212 \u03b4i+1 =\n(\u2211 i\u2032<i gi,i\u2032 ) \u2212  \u2211 j\u2032\u2265i+1 gj\u2032,i  (41) \u03b4i \u2212 \u03b4i+1 = ( gi,i +\n\u2211 i\u2032<i gi,i\u2032\n) \u2212 gi,i + \u2211 j\u2032\u2265i+1 gj\u2032,i  (42) \u03b4i \u2212 \u03b4i+1 =\n\u2211 i\u2032\u2264i gi,i\u2032 \u2212 \u2211 j\u2032\u2265i gj\u2032,i  (43) Since gi,i+1 = ni, and gi\u22121,i = ni\u22121,\n\u03b4i \u2212 \u03b4i+1 = (gi,i+1 \u2212 ni) +\u2211 i\u2032\u2264i gi,i\u2032 \u2212 (gi\u22121,i \u2212 ni\u22121) + \u2211 j\u2032\u2265i gj\u2032,i  (44) \u03b4i \u2212 \u03b4i+1 =\n\u2212ni + \u2211 i\u2032\u2264i+1 gi,i\u2032 \u2212 \u2212ni\u22121 + \u2211 j\u2032\u2265i\u22121 gj\u2032,i  (45) Since g represents the level graph, gi,i\u2032 = 0 if i\u2032 > i+ 1, or put another way, gj\u2032,i = 0 if j\u2032 < i\u2212 1, so\n\u03b4i \u2212 \u03b4i+1 = ( \u2212ni +\n\u2211 i\u2032 gi,i\u2032\n) \u2212 \u2212ni\u22121 +\u2211 j\u2032 gj\u2032,i  (46) \u03b4i \u2212 \u03b4i+1 = ni\u22121 \u2212 ni (47)\nSo, for all 0 \u2264 i < L\u2212 1:\n\u03b4i+1 \u2212 \u03b4i+2 = ni \u2212 ni+1 (48) ni = \u03b4i+1 \u2212 \u03b4i+2 + ni+1 (49)\nFor n0, note that \u2211 i gi,0 = g0,0 + \u03b41 + gL,0, and \u2211\ni g0,i = g0,0 + n0, so g0,0 + \u03b41 + gL,0 = g0,0 + n0, and gL,0 = n0 \u2212 \u03b41. This is the base case in a recursive proof that for all i < L, gL,0 = ni \u2212 \u03b4i. If we wish to prove it holds for i+ 1, then we assume it holds for i, or gL,0 = ni \u2212 \u03b4i. By Equation (49), for i < L\u2212 1:\ngL,0 = (\u03b4i+1 \u2212 \u03b4i+2 + ni+1)\u2212 \u03b4i (50) = ni+1 \u2212 \u03b4i+1 (51)\nSince \u03b4i \u2265 0, this implies that for i < T , gL,0 \u2264 ni, which completes the proof.\nLemma 13. If Requirements 1 and 2 hold, and b = \u2206/(L+1), then \u2211\n(i,j)\u2208E R\u0303 t,+ i,j \u03c0 t+1 i (u t+1(j)\u2212ut+1(i)\u2212 b) \u2264 0.\nProof. First, consider the case where \u03c0t is degenerate. Then, whenever \u03c0t+1i > 0, we know R t,+ i,j = 0 for all (i, j) \u2208 E, and so our sum of interest is exactly 0. Note that, since fi,j = R\u0303+i,j\u03c0t+1i , what we need to prove is:\u2211 (i,j)\u2208E fi,j(u t+1(j)\u2212 ut+1(i)\u2212 b) \u2264 0 (52)\n \u2211 (i,j)\u2208E fi,j(u t+1(j)\u2212 ut+1(i)) \u2212 b \u2211 (i,j)\u2208E fi,j \u2264 0. (53)\nSuppose \u03c0t is not degenerate. We examine Equation (53)\u2019s two summations. Notice that only edges (i, j) where \u03c0t+1i > 0 have fi,j 6= 0, and by Requirement 2(e) this is only true if L(i) \u2264 L. Also, fi,j > 0 if and only if 0 \u2264 L(i) \u2264 L and 1 \u2264 L(j) \u2264 L+ 1 (because level zero has no incoming edges), so:\u2211\n(i,j)\u2208E\nfi,j(u t+1(j)\u2212 ut+1(i)) = \u2211 (i,j)\u2208E fi,ju t+1(j)\u2212 \u2211 (i,j)\u2208E fi,ju t+1(i) (54)\n= L+1\u2211 `=1 \u2211 (i,j)\u2208E:L(j)=` fi,ju t+1(j)\u2212 L\u2211 `=0 \u2211 (i,j)\u2208E:L(i)=` fi,ju t+1(i). (55)\nRenaming the dummy variables in the second term and then combining:\u2211 (i,j)\u2208E fi,j(u t+1(j)\u2212 ut+1(i)) = L+1\u2211 `=1 \u2211 (i,j)\u2208E:L(j)=` fi,ju t+1(j)\u2212 L\u2211 `=0 \u2211 (j,k)\u2208E:L(j)=` fj,ku t+1(j) (56)\n= L\u2211 `=1  \u2211 (i,j)\u2208E:L(j)=` fi,ju t+1(j)\u2212 \u2211 (j,k)\u2208E:L(j)=` fj,ku t+1(j)  +\n\u2211 (i,j)\u2208E:L(j)=L+1 fi,ju t+1(j)\u2212 \u2211 (j,k)\u2208E:L(j)=0 fj,ku t+1(j). (57)\nFirst, we show that any term between 1 and L is zero. For any 1 \u2264 ` \u2264 L, by summing over nodes in level `:\n\u2211 (i,j)\u2208E:L(j)=` fi,ju t+1(j)\u2212 \u2211 (j,k)\u2208E:L(j)=` fj,ku t+1(j) = \u2211 j:L(j)=`  \u2211 i:(i,j)\u2208E fi,ju t+1(j)\u2212 \u2211 k:(j,k)\u2208E fj,ku t+1(j)  (58)\n= \u2211\nj:L(j)=`\nut+1(j)  \u2211 i:(i,j)\u2208E fi,j \u2212 \u2211 k:(j,k)\u2208E fj,k  . (59) By Lemma 9, \u2211 i:(i,j)\u2208E fi,j =\n\u2211 k:(j,k)\u2208E fj,k, so these terms are zero, leaving:\u2211\n(i,j)\u2208E\nfi,j(u t+1(j)\u2212 ut+1(i)) = \u2211 (i,j)\u2208E:L(j)=L+1 fi,ju t+1(j)\u2212 \u2211 (j,k)\u2208E:L(j)=0 fj,ku t+1(j). (60)\nIf L(j) = 0, then j = root:\u2211 (i,j)\u2208E fi,j(u t+1(j)\u2212 ut+1(i)) = \u2211 (i,j)\u2208E:L(j)=L+1 fi,ju t+1(j)\u2212 \u2211 (j,k)\u2208E:L(j)=0 fj,ku t+1(root). (61)\nMoreover, for any j, ut+1(j)\u2212 ut+1(root) \u2264 \u2206, so:\u2211 (i,j)\u2208E fi,j(u t+1(j)\u2212 ut+1(i)) \u2264 \u2211 (i,j)\u2208E:L(j)=L+1 fi,j(u t+1(root) + \u2206)\u2212 \u2211 (j,k)\u2208E:L(j)=0 fj,ku t+1(root) (62)\n\u2264\u2206 \u2211\n(i,j)\u2208E:L(j)=L+1\nfi,j + u t+1(root)  \u2211 (i,j)\u2208E:L(j)=L+1 fi,j \u2212 \u2211 (j,k)\u2208E:L(j)=0 fj,k  . (63)\nBy Lemma 12, Equation (37), the flow into level L + 1 is less than or equal to the flow out of level 0, so the last part is nonpositive and: \u2211\n(i,j)\u2208E\nfi,j(u t+1(j)\u2212 ut+1(i)) \u2264\u2206 \u2211 (i,j)\u2208E:L(j)=L+1 fi,j (64)\nFrom Lemm 12, Equation (36), we can show that the second term of Equation (53) equals:\nb \u2211\n(i,j)\u2208E\nfi,j \u2265 b(L+ 1) \u2211\n(i,j):L(j)=L+1\nfi,j (65)\nPutting Equations (65) and (64) together with the fact that b = \u2206/(L+ 1), we get,\u2211 (i,j)\u2208E fi,j(u t+1(j)\u2212 ut+1(i)\u2212 b) \u2264 \u2206 \u2211 (i,j):L(j)=L+1 fi,j \u2212 b(L+ 1) \u2211 (i,j):L(j)=L+1 fi,j (66)\n\u2264 (\u2206\u2212 b(L+ 1)) \u2211\n(i,j):L(j)=L+1\nfi,j = 0 (67)\nwhich is what we were trying to prove.\nLemma 13 is very close to the Blackwell condition, but not identical, so we sketch a quick variation on a special case of Blackwell\u2019s theorem so we can apply it to our problem.\nFact 14. (a+ b)+ \u2264 a+ + b+\nLemma 15. [(a+ b)+]2 \u2264 (a+ + b)2\nProof. 1. If a, b \u2265 0: (a+ b)2 \u2264 (a+ b)2\n2. If a, b \u2264 0: [(a+ b)+]2 = 0 \u2264 (a+ + b)2.\n3. If a \u2265 0, b \u2264 0: if \u2212b \u2265 a, then [(a+ b)+]2 = 0 \u2264 (a+ + b)2, otherwise [(a+ b)+]2 = (a+ b)2 = (a+ + b)2.\n4. If a \u2264 0, b \u2265 0: then if \u2212a \u2265 b, then[(a+ b)+]2 = 0 \u2264 (a+ + b)2, otherwise, [(a+ b)+]2 = (a+ b)2 \u2264 b2 = (a+ + b)2.\nFact 16. If ai=1...n \u2265 0 then \u2211n i=1 ai \u2264 \u221a |n|\u2211ni=1 a2i .\nFact 17. E [X]2 \u2264 E [ X2 ]\nWe restate Theorem 3 from Section 4:\nTheorem 3. For any directed graph with maximum out-degree D and any designated vertex root, (\u2206/(L + 1), L)regret matching, after T steps, will have expected local swap regret no worse than,\n1 T E[RTlocalswap] \u2264 \u2206 L+ 1 + \u2206 \u221a D|EL|\u221a T\n(13)\nwhere EL = {(i, j) \u2208 E|L(i) \u2264 L}.\nProof.\nE[RTlocalswap] = E \u2211 i\u2208V ( max j:(i,j)\u2208E T\u2211 t=1 1(at = i)(ut(j)\u2212 ut(i)) )+ (68)\n= E \u2211 i\u2208V ( max j:(i,j)\u2208E T\u2211 t=1 1(at = i)(ut(j)\u2212 ut(i)\u2212 b+ b) )+ (69)\n= E \u2211 i\u2208V ( max j:(i,j)\u2208E ( R\u0303Ti,j + T\u2211 t=1 1(at = i)b ))+ (70) = E\n\u2211 i\u2208V (( T\u2211 t=1 1(at = i)b ) + max j:(i,j)\u2208E R\u0303Ti,j )+ (71) \u2264 E\n[\u2211 i\u2208V (( T\u2211 t=1 1(at = i)b ) + ( max j:(i,j)\u2208E R\u0303Ti,j )+)] (72)\n= E [ bT +\n\u2211 i\u2208V max j:(i,j)\u2208E R\u0303T,+i,j\n] (73)\n\u2264 E bT +\u2211 i\u2208V \u2211 j:(i,j)\u2208E R\u0303T,+i,j  (74) = bT +\n\u2211 (i,j)\u2208EL E [ R\u0303T,+i,j ] (75)\nBy Facts 16 and 17,\n\u2264 bT + |EL| \u2211 (i,j)\u2208EL E [ R\u0303T,+i,j ]2 12 (76) \u2264 bT +\n|EL| \u2211 (i,j)\u2208EL E [ (R\u0303T,+i,j ) 2 ] 12 (77)\nWe can bound the inner term as follows, using Lemma 15:\u2211 (i,j)\u2208EL E [ (R\u0303T,+i,j ) 2 ] \u2264 \u2211 (i,j)\u2208EL E [ (R\u0303T\u22121,+i,j + 1(a T = i)(uT (j)\u2212 uT (i)\u2212 b))2 ]\n(78)\n= \u2211\n(i,j)\u2208EL\nE [( R\u0303T\u22121,+i,j )2] + \u2211 (i,j)\u2208EL E [ (1(aT = i)(uT (j)\u2212 uT (i)\u2212 b))2 ] (79)\n+ \u2211\n(i,j)\u2208EL\nE [ 2R\u0303T\u22121,+i,j 1(a T = i)(uT (j)\u2212 uT (i)\u2212 b) ]\n= \u2211\n(i,j)\u2208EL\nE [( R\u0303T\u22121,+i,j )2] + E  \u2211 (i,j)\u2208EL (1(aT = i)(uT (j)\u2212 uT (i)\u2212 b))2  (80)\n+ 2 \u2211\na1,...,T\u22121,u1,...,T\u22121 E  \u2211 (i,j)\u2208EL R\u0303T\u22121,+i,j \u03c0 T i (u T (j)\u2212 uT (i)\u2212 b) \u2223\u2223\u2223\u2223a1,...,T\u22121, u1,...,T\u22121 \u00d7 Pr[a1,...,T\u22121, u1,...,T\u22121] ) (81)\nBy Lemma 13, \u2211\n(i,j)\u2208EL R\u0303 T\u22121,+ i,j \u03c0 T i (u T (j)\u2212 uT (i)\u2212 b) \u2264 0 regardless of the previous history.\n\u2211 (i,j)\u2208EL E [ (R\u0303T,+i,j ) 2 ] \u2264 \u2211 (i,j)\u2208EL E [( R\u0303T\u22121,+i,j )2] + E  \u2211 (i,j)\u2208EL (1(aT = i)(\u2206\u2212 b))2  (82)\n\u2264 \u2211\n(i,j)\u2208EL\nE [( R\u0303T\u22121,+i,j )2] +D(\u2206\u2212 b)2 (83)\n\u2264 TD(\u2206\u2212 b)2 \u2264 TD ( \u2206 L\nL+ 1\n)2 (84)\nPutting these two pieces together, we get,\nE[RTlocalswap] \u2264 bT + |EL| \u2211 (i,j)\u2208EL E [ (RT,+i,j ) 2 ] 12 (85)\n\u2264 bT + \u221a |EL|TD ( \u2206 L\nL+ 1\n)2 (86)\n\u2264 \u2206T L+ 1\n+ \u221a TD|EL|\u2206 L\nL+ 1 (87)\n1 T E[RTlocalswap] \u2264 \u2206 L+ 1 + \u2206 \u221a D|EL|\u221a T\n(88)"}, {"heading": "B Proof for Color Regret", "text": "Requirement 3. Let C be a countable (but possibly infinite) set of colors. The edge coloring c : E \u2192 C is such that c(i, j) = c(i, k)\u21d4 j = k.\nWe restate Theorem 8 from Section 5.2:\nTheorem 8. For an arbitrary graph G with maximum degree D, arbitrarily chosen vertex root, and edge coloring C, (\u2206/(L+ 1), L,C)-colored-regret matching applied after T steps will have expected local colored regret no worse than,\n1 T E[RTlocalcolor] \u2264 \u2206D L+ 1 + \u2206 \u221a D|CL|\u221a T\nwhere CL = {C \u2208 C|\u2203(i, j) \u2208 C s.t. L(i) \u2264 L}. Proof. First, we show that \u2211\nc\u2208C R\u0303 t,+ c \u2211 (i,j)\u2208E c(i,j)=c \u03c0t+1i (u t+1(j)\u2212 ut+1(i)\u2212 b)) \u2264 0.\n\u2211 c\u2208C R\u0303t,+c \u2211\n(i,j)\u2208E c(i,j)=c\n\u03c0t+1i (u t+1(j)\u2212 ut+1(i)\u2212 b)) = \u2211 c\u2208C \u2211 (i,j)\u2208E c(i,j)=c R\u0303t,+c \u03c0 t+1 i (u t+1(j)\u2212 ut+1(i)\u2212 b)) (89)\n= \u2211 c\u2208C \u2211 (i,j)\u2208E c(i,j)=c R\u0303t,+i,j \u03c0 t+1 i (u t+1(j)\u2212 ut+1(i)\u2212 b)) (90)\nBy Lemma 13:\u2211 c\u2208C R\u0303t,+c \u2211\n(i,j)\u2208E c(i,j)=c\n\u03c0t+1i (u t+1(j)\u2212 ut+1(i)\u2212 b)) = \u2211 (i,j)\u2208E R\u0303t,+i,j \u03c0 t+1 i (u t+1(j)\u2212 ut+1(i)\u2212 b)) \u2264 0 (91)\nNow we can bound our quantity of interest.\nE[RTlocalcolor] = E \u2211 c\u2208C  \u2211 (i,j)\u2208E c(i,j)=c T\u2211 t=1 1(at = i)(ut(j)\u2212 ut(i))  + (92)\n= E \u2211 c\u2208C  \u2211 (i,j)\u2208E c(i,j)=c T\u2211 t=1 1(at = i)(ut(j)\u2212 ut(i)\u2212 b+ b)  + (93)\n= E \u2211 c\u2208C R\u0303Tc +  \u2211\n(i,j)\u2208E c(i,j)=c\nT\u2211 t=1 1(at = i)b   + (94)\n\u2264 E \u2211 c\u2208C R\u0303T,+c +  \u2211\n(i,j)\u2208E c(i,j)=c\nT\u2211 t=1 1(at = i)b    (95)\n= E \u2211 c\u2208C \u2211 (i,j)\u2208E c(i,j)=c T\u2211 t=1 1(at = i)b+ \u2211 c\u2208C RT,+c  (96) \u2264 E [ bTD +\n\u2211 c\u2208C R\u0303T,+c\n] (97)\n= bTD + \u2211 c\u2208CL E [ R\u0303T,+c ] (98)\n\u2264 bTD + ( |CL|\n\u2211 c\u2208CL E [ R\u0303T,+c ]2) 12 (99)\n\u2264 bTD + ( |CL|\n\u2211 c\u2208CL E [ (R\u0303T,+c ) 2 ]) 12\n(100)\nWe can bound the inner term as follows,\u2211 c\u2208CL E [ (R\u0303T,+c ) 2 ] \u2264 \u2211 c\u2208CL E [ (R\u0303Tc ) 2 ]\n(101)\n= \u2211 c\u2208CL E\n R\u0303T\u22121c + \u2211\n(i,j)\u2208E c(i,j)=c\n1(aT = i)(uT (j)\u2212 uT (i)\u2212 b)  2 (102)\n= \u2211 c\u2208CL E [ (R\u0303T\u22121c ) 2 ] + \u2211 c\u2208CL E\n  \u2211\n(i,j)\u2208E c(i,j)=c\n1(aT = i)(uT (j)\u2212 uT (i)\u2212 b)  2 (103)\n+ \u2211 c\u2208CL E 2R\u0303T\u22121c \u2211 (i,j)\u2208E c(i,j)=c 1(aT = i)(uT (j)\u2212 uT (i)\u2212 b) \n= \u2211 c\u2208CL E [ (R\u0303T\u22121c ) 2 ] + \u2211 c\u2208CL E\n  \u2211\n(i,j)\u2208E c(i,j)=c\n1(aT = i)(uT (j)\u2212 uT (i)\u2212 b)  2 (104)\n+ 2 \u2211 c\u2208CL R\u0303T\u22121c \u2211\n(i,j)\u2208E c(i,j)=c\n\u03c0Ti (u T (j)\u2212 uT (i)\u2212 b)\n\u2264 \u2211 c\u2208CL E [ (R\u0303T\u22121c ) 2 ] + \u2211 c\u2208CL E\n  \u2211\n(i,j)\u2208E c(i,j)=c\n1(aT = i)(uT (j)\u2212 uT (i)\u2212 b)  2 (105)\n\u2264 \u2211 c\u2208CL E [ (R\u0303T\u22121c ) 2 ] + (\u2206\u2212 b)2 \u2211 c\u2208CL E\n  \u2211\n(i,j)\u2208E c(i,j)=c\n1(aT = i)  2 (106)\nBecause only one action is taken, and for each color only one edge originating at an action can have that color,\u2211 (i,j)\u2208E c(i,j)=c 1(aT = i) \u2208 {0, 1}:\n\u2211 c\u2208CL E [ (R\u0303T,+c ) 2 ] \u2264 \u2211 c\u2208CL E [ (R\u0303T\u22121c ) 2 ] + (\u2206\u2212 b)2 \u2211 c\u2208CL E\n  \u2211\n(i,j)\u2208E c(i,j)=c\n1(aT = i)   (107)\n= \u2211 c\u2208CL E [ (R\u0303T\u22121c ) 2 ] +D(\u2206\u2212 b)2 (108)\n\u2264 TD(\u2206\u2212 b)2 \u2264 TD ( \u2206 L\nL+ 1\n)2 (109)\nPutting these two pieces together, we get,\nE[RTcolorswap] \u2264 bTD + ( |CL| \u2211 c\u2208CL E [ (R\u0303T,+c ) 2 ]) 12\n(110)\n\u2264 bTD + \u221a |CL|TD ( \u2206 L\nL+ 1\n)2 (111)\n\u2264 \u2206DT L+ 1\n+ \u221a TD|EL|\u2206 L\nL+ 1 (112)\n1 T E[RTcolorswap] \u2264 \u2206D L+ 1 + \u2206 \u221a D|CL|\u221a T\n(113)"}, {"heading": "C Decision Tree Graphs", "text": "A decision tree is a representation of a hypothesis. Given an instance space where there are a finite number of binary features, a decision tree can represent an arbitrary hypothesis. We describe decision trees recursively: the simplest trees are leaves, which represent constant functions. More complex trees have two subtrees, and a root node labeled with a variable. A subtree cannot have a variable that is referred to in the root.\nWe define Tk(S) recursively, where Tk(S) will be the set of trees of depth k or less over the variable set S. Define the set T0(S) = {true, false}. Define Tk(S) such that:\nTk(S) = Tk\u22121(S) \u22c3 s\u2208S ({s} \u00d7 Tk\u22121(S\\{s})\u00d7 Tk\u22121(S\\{s})) (114)\nDefine T \u2217(S) = T|S|(S) to be the set of all decision trees over the variables S. Three example decision trees in T \u2217({x1, x2}) are (x1, true, false), true, and (x1, (x2, true, false), false). Suppose we have an example x, mapping variables to {true, false}. For any tree t, we can recursively define t(x):\n1. If t \u2208 T0, then t(x) = t.\n2. If t \u2208 Tk and x(t1) = true, then t(x) = t2(x).\n3. If t \u2208 Tk and x(t1) = false, then t(x) = t3(x). Define P = {p \u2208 (S \u00d7 {true, false})|S| : \u2200i 6= j, pi,1 6= pj,1} to be the paths in the trees without repeating variables. We can talk about whether a path is in a tree. Define Vp(t) to be a function from T \u2217 to S \u222a {true, false, \u2205}, where Vp(t) = \u2205 if the path p is not present in the tree, and otherwise Vp(t) is the value of the node at the end of the path. Formally,\nV\u2205(t) = { t if t \u2208 T0 t1 otherwise\n(115)\nV(v,l)\u25e6p(t) = \u2205 if t \u2208 T0 or t1 6= vVp(t2) if t /\u2208 T0 and t1 = v and l = true Vp(t3) if t /\u2208 T0 and t1 = v and l = false\n(116)\nGiven a path p \u2208 P , a tree t\u2032 \u2208 T \u2217,define Rp,t\u2032(t) to replace the tree at p with t\u2032 if Vp(t) 6= \u2205. Formally:\nR\u2205,t\u2032(t) = t \u2032 (117)\nR(v,l)\u25e6p,t\u2032(t) = t if t \u2208 T0 or t1 6= v(t1, Rp,t\u2032(t2), t3) if t /\u2208 T0 and t1 = v and l = true (t1, t2, Rp(t3)) if t /\u2208 T0 and t1 = v and l = false\n(118)\nConsider the following operations on decision trees:\n1. ReplaceWithNode(p, v, l1, l2) = Rp,(v,l1,l2) (where it applies): If there exists a node or leaf at path p, replace it with a decision stump with variable v, with label l1 on the true branch, and label l2 on the false branch, but only if Vp(t) 6= v.\n2. ReplaceWithLeaf(p, l1) = Rp,l1 : If there exists a node or leaf at path p, replace it with a leaf l1.\nThese operations create the edges between trees: we will determine how to color them later. BecauseReplaceWithNode is a more complex operation, an edge created byReplaceWithNodewill have length 1.1, whereasReplaceWithLeaf will have length 1.0. This weighting is important: otherwise, consider the following sequence of trees:\n(X, true, false) (false)\n(X, false, true)\nIf splitting was the same length as changing leaves, this bizarre path would be a shortest path between (X, true, false) and (X, false, true). In general, when designing this distance function over trees, a critical concern was whether unnecessary reconstruction would be on a shortest path. For example, a shortest path from (X, (Y, true, false), (Z, false, true)) to (X, (Y, false, true), (Z, true, false)) could pass through false, (X, true, false), (X, (Y, false, true), false). But, since replacing something with a decision tree costs slightly more than changing a leaf, we avoid this.\nMore generally, if the decision about whether or not an edge is on the shortest path can be made locally, then this reduces the number of colors required. Thus, massively reconstructing the root because the leaves are wrong is not only counterintuitive, it makes the algorithm slower and more complex.\nWe first hypothesize a shortest path distance function between trees based on these operations, and then we will prove it satisfies the above operations. Note that this function is not symmetric, because the shortest path distance function on a directed graph is not always symmetric.\nGiven two decision trees A and B, a decision node a in A and a decision node b are in structural agreement if they are on the same path p, and they are labeled with the same variable. A decision node in B that does not agree with a decision node in A is in structural disagreement with A. Given a leaf in B that has a parent that is in structural agreement with A, if the leaf is not present in A, it is in leaf disagreement with A.\nDefine d\u2217s(A,B) to be the structural disagreement distance between A and B, the number of nodes in B that are in structural disagreement with A. Define d\u2217l (A,B) to be the leaf disagreement distance between A and B, the number of leaves in B in disagreement with A. Define d\u2217(A,B) = 1.1d\u2217s(A,B) + d \u2217 l (A,B).\nIntuitively, this distance represents the fact that an example shortest path from A to B can be generated by first fixing all label disagreements between A and B, and then applying ReplaceWithNode to create every node in B that is in structural disagreement with A (correctly labeling leaves where appropriate).\nFact 18. If d : V \u00d7 V \u2192 Z+ is the shortest distance function on a completely connected directed graph (V,E), then for any i, j \u2208 V where (i, j) /\u2208 E, there exists a k such that (i, k) \u2208 E and d(i, j) = d(i, k) + d(k, j). Theorem 19. d\u2217 : V \u00d7 V \u2192 Z+ corresponds to the shortest distance function on a completely connected directed graph (V,E) if there exists a \u2206 > 0 and a \u03b4 = \u2206/2 such that the following properties hold:\n1. For all a, b \u2208 V , d\u2217(a, b) = 0 iff a = b. 2. For all a, b \u2208 V , d\u2217(a, b) > \u03b4 iff a 6= b. 3. For all a, b \u2208 V , if a 6= b there exists a c \u2208 V such that d\u2217(a, c) \u2264 \u2206 and d\u2217(a, b) \u2265 d\u2217(a, c) + d\u2217(c, b). 4. For all a, b, c \u2208 V , if d\u2217(a, c) \u2264 \u2206, then d\u2217(a, b) \u2264 d\u2217(a, c) + d\u2217(c, b).\nProof. Observe that the graph (V,E) with edges E = {(i, j) \u2208 V 2 : d\u2217(i, j) \u2264 \u2206} where the weight of an edge (i, j) \u2208 E is d\u2217(i, j), is a good candidate for the graph under consideration. We prove this in two steps. We first prove by induction that d(i, j) \u2264 d\u2217(i, j). Then, leveraging this, we prove by induction that d(i, j) = d\u2217(i, j).\nFirst, we prove that if d\u2217(i, j) \u2264 \u2206, then d(i, j) = d\u2217(i, j). First, observe that if d\u2217(i, j) = 0, then i = j, so d(i, j) = 0. Secondly, if d\u2217(i, j) \u2208 (0,\u2206], then there exists an edge (i, j) \u2208 E so d(i, j) \u2264 d\u2217(i, j). Since each edge is larger than \u2206/2, for any path of length 2 or greater, the length is larger than \u2206, so only a direct path can be less than or equal to \u2206. This establishes that there is no path between i and j shorter than the direct edge.\nFor any nonnegative integer k, define P (k) to be the property that for any i, j \u2208 V , if the distance d\u2217(i, j) \u2264 k\u03b4, the shortest distance between two vertices in this graph d(i, j) is less than or equal to d\u2217(i, j). This holds for P (0), P (1), and P (2) because of the paragraph above. Now, suppose that P (k) holds for k \u2265 2, we need to establish it holds for P (k + 1). Consider some pair (i, j) \u2208 V where d\u2217(i, j) \u2208 (k\u03b4, (k + 1)\u03b4], then i 6= j, and by condition 3, there exists a k where d\u2217(i, k) \u2264 \u2206 and d\u2217(i, j) \u2265 d\u2217(i, k) + d\u2217(k, j). Since d\u2217(i, j) \u2264 (k + 1)\u03b4 and d\u2217(i, j) > \u03b4, d\u2217(k, j) < k\u03b4, so d\u2217(k, j) = d(k, j). From the paragraph above, d(i, k) = d\u2217(i, k), so d\u2217(i, j) \u2265 d(i, k) + d(k, j), and by the triangle inequality on d, d\u2217(i, j) \u2265 d(i, j).\nThus, since for all (i, j) \u2208 V there exists a k where d\u2217(i, j) \u2264 k\u03b4, for all (i, j) \u2208 V , d(i, j) \u2264 d\u2217(i, j). Next, we prove that if d(i, j) \u2264 \u2206, then d(i, j) = d\u2217(i, j). First, observe that if d(i, j) = 0, then i = j, so d\u2217(i, j) = 0. Secondly, if (i, j) /\u2208 E, then the distance between i and j must be greater than \u2206, because each edge is larger than \u2206/2. Therefore, if d(i, j) \u2208 (0,\u2206] there is a direct edge between i and j with distance d\u2217(i, j), so d\u2217(i, j) \u2264 \u2206, and so by the second paragraph d(i, j) = d\u2217(i, j).\nDefine Q(k) to be the property for any (i, j) \u2208 V , if d(i, j) \u2264 k\u03b4 then d(i, j) = d\u2217(i, j). Q(0), Q(1) and Q(2) hold from the above paragraph. Now, suppose that Q(k) holds for some k \u2265 2, we need to establish the property for Q(k + 1). Consider some pair (i, j) \u2208 V where d(i, j) \u2208 (k\u03b4, (k + 1)\u03b4], then i 6= j, and by condition 18, there exists a k where there exists an edge from i to k and d(i, j) = d(i, k) + d(k, j). Since there exists an edge (i, k), then d(i, k) \u2264 \u2206 and d(i, k) = d\u2217(i, k) > \u03b4. Thus, d(k, j) \u2264 \u03b4(k + 1) \u2212 \u03b4 \u2264 \u03b4k. so d(k, j) = d\u2217(k, j). Moreover, by condition 4, d\u2217(i, j) \u2264 d\u2217(i, k) + d\u2217(k, j) = d(i, j). Thus, since we know that d\u2217(i, j) \u2265 d(i, j), then d\u2217(i, j) = d(i, j).\nTherefore, since d\u2217(i, j) = d(i, j), and d is the shortest distance for graph (V,E), then d\u2217(i, j) is a shortest distance function for a weighted graph.\nLemma 20. For the decision tree metric d\u2217 above, for any two trees A,B where A 6= B, there exists a tree C such that d\u2217(A,C) \u2264 1.1 and d\u2217(A,B) \u2265 d\u2217(A,C) + d\u2217(C,B).\nProof. If B has a leaf at the root, then set C = B. Suppose that, given A and B, there is label disagreement. Find the a node with label disagreement, and correct all the labels in A to form C. This reduces the number of nodes with label disagreement by one, and the decision node disagreement stays the same.\nSuppose that, given A and B, there no label disagreement, but there is structural disagreement. Then select a node d which has decision node disagreement. Define C to be a tree where we replace node d with the corresponding node in tree B, with leaves that agree with the children of d if d has children, and arbitrary otherwise. This reduces the structural disagreement by one. It does not increase the label disagreement, because if d has children with labels in B, it has those same children in C.\nFinally, if A and B have no label disagreement or structural disagreement, then they are the same tree and have distance 0.\nBefore proving a lower bound, we focus on a particular case. Namely, that changing a correct decision node of a tree to have the wrong variable cannot decrease the distance.\nLemma 21. Given two trees A and B and a subtree S in B, if nS is the number of nodes in agreement with B in the subtree S, and lS is the number of leaves in disagreement with A in S, then lS \u2264 nS + 1.\nProof. We prove this by recursion on the size of the subtree S inB. If S is of size 1, then S is a leaf inB, then nS = 0 and lS \u2264 1, so the result holds. Suppose we have proven this for all subtrees S\u2032 of size less than S. If S is rooted at a node in disagreement, then ns = 0 and lS = 0, and the result holds (we don\u2019t need induction for this case). If S is rooted at a node x in agreement, then define Strue to be the subtree of the node down the edge labeled true leaving x, and define Sfalse to be the subtree down the edge labeled false leaving x. |Strue| < |S| and |Sfalse| < |S|, so by induction lStrue \u2264 nStrue + 1 and lSfalse \u2264 nSfalse + 1. Since x is a node in agreement, lS = lStrue + lSfalse , and therefore:\nlS \u2264 nStrue + nSfalse + 1 + 1 (119) (120)\nAgain, since x is a node in agreement, nStrue + nSfalse + 1 = nS , so:\nlS \u2264 nS + 1. (121)\nWe will use this fact in several places in the resulting proofs.\nLemma 22. Given two trees A and B which agree on node y, if you change y in A to a node x or leaf to create C, then d\u2217(A,B) < d\u2217(C,B) + 1.\nProof. If S is the subtree rooted at y in B, then d\u2217s(A,B) + nS = d \u2217 s(C,B) and d \u2217 l (A,B) \u2212 lS = d\u2217l (C,B). By definition, d\u2217(A,B) = d\u2217(C,B) + 1.1nS \u2212 lS . Since y is in agreement, nS \u2265 1. By Lemma 21, we know that lS \u2264 nS + 1, so\nd\u2217(A,B) = d\u2217(C,B) + 1.1nS \u2212 (nS + 1) (122) d\u2217(A,B) = d\u2217(C,B) + 0.1nS + 1 (123)\nSince ns \u2265 1, 0.1ns \u2265 0.1 > 0, so:\nd\u2217(A,B) < d\u2217(C,B) + 1 (124)\nLemma 23. For the decision tree metric d\u2217 above, for any two trees A,B where A 6= B, then for any C such that d\u2217(A,C) \u2264 \u2206, d\u2217(A,B) \u2264 d\u2217(A,C) + d\u2217(C,B).\nProof. First, observe that C has \u201cone\u201d change from A, which can be that:\n1. C has a decision node splitting on variable x where A had a decision node splitting on variable y.\n2. C has a decision node splitting on variable x where A had a leaf l.\n3. A has a node x that was changed to a leaf.\n4. C has a leaf where A had a node.\nIn the first case, there is a question of whether or not the decision node y exists in B. If so, then the structural disagreement has been reduced by one. However, the leaf disagreement is unchanged or increased by one, so d\u2217(A,B) \u2264 1.1 +d\u2217(C,B) = d\u2217(A,C) +d\u2217(C,B). If y is not in B, and x is not in B, then d\u2217(A,B) = d\u2217(C,B) < 1.1+d\u2217(C,B) = d\u2217(A,C)+d\u2217(C,B). If y is inB, by Lemma 22, then d\u2217(A,B) < d\u2217(C,B)+1 < 1.1+d\u2217(C,B) = d\u2217(A,C) + d\u2217(C,B).\nFor the second case, if the new node in C agrees with B, then d\u2217(A,B) = 1.1 + d\u2217(C,B). If the leaf in A agreed with B, then d\u2217(A,B) = d\u2217(C,B)\u2212 1 < 1.1 + d\u2217(C,B) = d\u2217(A,C) + d\u2217(C,B). If the leaf in A disagreed with B and the new node in C disagrees with B, then d\u2217(A,B) = d\u2217(C,B) < 1.1 + d\u2217(C,B) = d\u2217(A,C) + d\u2217(C,B).\nFor the third case, if the new leaf in C agrees with B, then d\u2217(A,B) = 1 + d\u2217(C,B) = d\u2217(A,C) + d\u2217(C,B). If the node in A agreed with B, then by Lemma 22, d\u2217(A,C) < d\u2217(C,B) + 1 = d\u2217(A,C) + d\u2217(C,B). If the node in A disagreed with B, and the new leaf in C disagrees with B, then d\u2217(A,B) = d\u2217(C,B) < 1 + d\u2217(C,B) = d\u2217(A,C) + d\u2217(C,B).\nFinally, for the fourth case, if the new leaf in C agrees with B, then d\u2217(A,B) = 1 + d\u2217(C,B) = d\u2217(A,C) + d\u2217(C,B). If the leaf in A agreed with B, then by Lemma 22, d\u2217(A,C) < d\u2217(C,B) + 1 = d\u2217(A,C) + d\u2217(C,B). If the leaf in A disagreed with B, and the new leaf in C disagrees with B, then there was no change, and this is an illegal transition.\nTheorem 24. The distance d\u2217 as defined above is the distance function for a graph.\nProof. In order to prove this, we use Theorem 19. First \u2206 = 1.1, and \u03b4 = 0.55. Observe that by the definition of d\u2217, if two trees are equal, there is no disagreement, and there is zero distance. Secondly, by the definition of d\u2217, if there is any difference between two trees A and B, there will be disagreement, and d\u2217(A,B) \u2265 1. Thus, Condition 1 and Condition 2 are satisfied.\nNow, by Lemma 20, Condition 3 is satistfied. By Lemma 23, Condition 4 is satisfied.\nIn the graph generated from d\u2217, note that a single label disagreement or a single decision node disagreement results in an edge.\nNow, we have to derive colors.\n1. ReplaceWithNode(p, v, l1, l2): The path, the variable, and the labels form the color. Note that if the tree already has a decision node with label v at path p, this transition is illegal.\n2. ReplaceWithLeaf(p, l1): The path and the leaf form the color.\nLemma 25. ReplaceWithNode(p, v, l1, l2) is on the shortest path to B if\n1. it can be applied to the current tree\n2. the variable v is at the path p in B.\n3. A leaf with the label \u00acl1 is not at the path p \u25e6 (v, true) in B, 4. A leaf with the label \u00acl2 is not at the path p \u25e6 (v, false) in B."}, {"heading": "If these rules do not apply, it is not on the shortest path.", "text": "Proof. Suppose that A is our current tree. Suppose that C = Rp,(v,l1,l2)(A). First, we establish that if the conditions are satisfied, the edge is on the shortest path. Note that if v is at the path p in B, and there is a leaf or another decision node at path p in A, then v is in structural disagreement. Therefore, when we replace that node with v, we reduce the structural disagreement. However, we must be careful not to increase leaf disagreement. If, for any nodes of v in B, they are corrected in A, then leaf disagreement will not increase. Therefore, by reducing the structural disagreement by 1, we reduce the distance by 1.1, at a cost of 1.1, meaning the edge is on the shortest path.\nSecondly, we can go through the conditions one by one to realize any violated condition is sufficient. Regarding the first condition: if the operation cannot be applied to the current tree, then by definition it is not on the shortest path.\nRegarding the second condition: if the variable v is not on path p in B, but A and B are in agreement at the path p, then changing the variable to v will not decrease the distance sufficiently, by Lemma 22, so it is not on the shortest path. Secondly, if A does not agee with B on path p, then d\u2217(A,B) = d\u2217(C,B), and thus C is not on the shortest path.\nRegard the third and fourth conditions. If the variable v is on the path p in B, but there is some leaf that is a child of v in B that is set incorrectly, then the structural distance is decreased, but the leaf disagreement is increased, so d\u2217(A,B) = d\u2217(C,B) + 0.1.\nLemma 26. ReplaceWithLeaf(p, l1) is on the shortest path to B if it applies to the current tree, and if the leaf l1 is at p in B. If these rules do not apply, it is not on the shortest path.\nProof. Suppose that A is the initial tree, and C = Rp,l1(A). If the edge applies, and there is the wrong label or a decision node at p, then the label is in disagreement in A, but not in C. There are no other changes, so d\u2217(A,B) = d\u2217(C,B) + 1 = d\u2217(A,C) + d\u2217(C,B), and therefore the edge is on a shortest path.\nOn the other hand, if there is no leaf at p in B, or the leaf has another label, then this is not the shortest path. First of all, if the operator does not apply to A, it cannot be on the shortest path. If the label Vp(B) 6= l1, butA andB are in agreement at the path p, then by Lemma 22 d\u2217(A,B) < d\u2217(C,B)+1 = d\u2217(A,C) + d\u2217(C,B). If Vp(B) 6= l1, and A and B are not in agreement at the path p, then d\u2217(A,B) = d\u2217(C,B) < d\u2217(C,B) + 1.\nThus, we have established our coloring works for decision trees."}], "references": [{"title": "An analog of the minimax theorem for vector payoffs", "author": ["D. Blackwell"], "venue": "Pacific Journal of Mathematics,", "citeRegEx": "Blackwell.,? \\Q1956\\E", "shortCiteRegEx": "Blackwell.", "year": 1956}, {"title": "From external to internal regret", "author": ["A. Blum", "Y. Mansour"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Blum and Mansour.,? \\Q2007\\E", "shortCiteRegEx": "Blum and Mansour.", "year": 2007}, {"title": "A general class of no regret learning algorithms and game-theoretic equilibria", "author": ["A. Greenwald", "A. Jafari"], "venue": "In Proceedings of the Sixteenth Annual Conference on Learning Theory,", "citeRegEx": "Greenwald and Jafari.,? \\Q2003\\E", "shortCiteRegEx": "Greenwald and Jafari.", "year": 2003}, {"title": "Approximation to bayes risk in repeated plays", "author": ["J. Hannan"], "venue": "Contributions to the Theory of Games,", "citeRegEx": "Hannan.,? \\Q1957\\E", "shortCiteRegEx": "Hannan.", "year": 1957}, {"title": "A simple adaptive procedure leading to correlated equilibrium", "author": ["S. Hart", "A. Mas-Colell"], "venue": null, "citeRegEx": "Hart and Mas.Colell.,? \\Q2002\\E", "shortCiteRegEx": "Hart and Mas.Colell.", "year": 2002}, {"title": "A wide range no-regret theorem", "author": ["E. Lehrer"], "venue": "Games and Economic Behavior,", "citeRegEx": "Lehrer.,? \\Q2003\\E", "shortCiteRegEx": "Lehrer.", "year": 2003}, {"title": "Learning quickly when irrelevant attributes abound: A new linear-threshold algorithm", "author": ["N. Littlestone"], "venue": "Machine Learning,", "citeRegEx": "Littlestone.,? \\Q1988\\E", "shortCiteRegEx": "Littlestone.", "year": 1988}, {"title": "Programs for Machine Learning", "author": ["J.R. Quinlan"], "venue": null, "citeRegEx": "Quinlan.,? \\Q1993\\E", "shortCiteRegEx": "Quinlan.", "year": 1993}, {"title": "Local search strategies for satisfiability testing", "author": ["B. Selman", "H. Kautz", "B. Cohen"], "venue": null, "citeRegEx": "Selman et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Selman et al\\.", "year": 1993}, {"title": "Online convex programming and generalized infinitesimal gradient ascent", "author": ["M. Zinkevich"], "venue": "In Twentieth International Conference on Machine Learning,", "citeRegEx": "Zinkevich.,? \\Q2003\\E", "shortCiteRegEx": "Zinkevich.", "year": 2003}], "referenceMentions": [{"referenceID": 4, "context": "Internal regret [Hart and Mas-Colell, 2002] is the maximum utility that could be gained if one action had been chosen in place of some other action.", "startOffset": 16, "endOffset": 43}, {"referenceID": 2, "context": "Swap regret [Greenwald and Jafari, 2003] is the maximum utility gained if each action could be replaced by another.", "startOffset": 12, "endOffset": 40}, {"referenceID": 3, "context": "External regret [Hannan, 1957], which is the original pioneering concept of regret, is the maximum utility gained by replacing all actions with one particular action.", "startOffset": 16, "endOffset": 30}, {"referenceID": 9, "context": "For example, if A is a compact, convex subset of R and the utilities are convex with bounded gradient on A, then you can minimize regret even though A is infinite [Zinkevich, 2003].", "startOffset": 163, "endOffset": 180}, {"referenceID": 1, "context": "Swap regret [Greenwald and Jafari, 2003] is the maximum utility gained if each action could be replaced by another. External regret [Hannan, 1957], which is the original pioneering concept of regret, is the maximum utility gained by replacing all actions with one particular action. This is the most relaxed of the three concepts, and while the others must concern themselves with |A|2 possible regret values (for all pairs of actions) external regret only need worry about |A| regret values. So although the guarantee is weaker, it is a simpler concept to learn which can make it considerably more attractive. These three regret notions have the following relationships. R internal \u2264 R swap \u2264 |A|R internal R external \u2264 R swap (3) 2.1 Infinite Action Spaces This paper considers situations where A is infinite. To keep the notation simple, we will use max operations over actions to mean suprema operations and summations over actions to mean the suprema of the sum over all finite subsets of actions. Since we will be focused on regret over a finite time period, there will only ever be a finite set of actually selected actions and, hence only a finite number of non-zero regrets, R a,b. The summations over actions will always be thought to be restricted to this finite set. None of the three traditional regret concepts are well-suited to A being infinite. Not only does |A| appear in the regret bounds, but one can demonstrate that it is impossible to have no regret in some infinite cases. Consider A = N and let u be a step function, so u(a) = 1 if a > y for some y and 0 otherwise. Imagine y is selected so that Pr[a > yt|u1,...,T\u22121, a1,...,T\u22121] \u2264 0.001, which is always possible. Essentially, high utility is always just beyond the largest action selected. Now, consider y\u2217 = 1 + maxt\u2264T y. In expectation 1 T \u2211T t=1 u (at) \u2264 0.001 while 1 T \u2211T t=1 u t(y\u2217) = 1 (i.e., there is large internal and external regret for not having played y\u2217,) so the average regret cannot approach zero. Most attempts to handle infinite action spaces have proceeded by making assumptions on both A and u. For example, if A is a compact, convex subset of R and the utilities are convex with bounded gradient on A, then you can minimize regret even though A is infinite [Zinkevich, 2003]. We take an alternative approach where we make use of a notion of locality on the set A, and modify regret concepts to respect this locality. Different notions of locality then result in different notions of regret. Although this typically results in a weaker form of regret for finite sets, it breaks all dependence of regret on the size ofA and allows it to even be applied whenA is infinite and u is an arbitrary (although still bounded) function. Wide range regret methods Lehrer [2003] can also bound regret with respect to a set of (countably) infinite \u201calternatives\u201d, but unlike our results, their asymptotic bound does not apply uniformly across the set, and uniform finite-time bounds depend upon a finite action space Blum and Mansour [2007].", "startOffset": 13, "endOffset": 2765}, {"referenceID": 1, "context": "Wide range regret methods Lehrer [2003] can also bound regret with respect to a set of (countably) infinite \u201calternatives\u201d, but unlike our results, their asymptotic bound does not apply uniformly across the set, and uniform finite-time bounds depend upon a finite action space Blum and Mansour [2007].", "startOffset": 277, "endOffset": 301}, {"referenceID": 8, "context": ", WalkSAT [Selman et al., 1993]) on the maximum satisfiability problem, an offline task where all of the clauses are known up front.", "startOffset": 10, "endOffset": 31}, {"referenceID": 7, "context": "5 [Quinlan, 1993].", "startOffset": 2, "endOffset": 17}, {"referenceID": 4, "context": "4 An Algorithm for Local Swap Regret We now present an algorithm for minimizing local swap regret, similar to global swap regret algorithms [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003], but with substantial differences.", "startOffset": 140, "endOffset": 195}, {"referenceID": 2, "context": "4 An Algorithm for Local Swap Regret We now present an algorithm for minimizing local swap regret, similar to global swap regret algorithms [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003], but with substantial differences.", "startOffset": 140, "endOffset": 195}, {"referenceID": 4, "context": "These probabilities are always computed according to the following requirement, which is a generalization of [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003].", "startOffset": 109, "endOffset": 164}, {"referenceID": 2, "context": "These probabilities are always computed according to the following requirement, which is a generalization of [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003].", "startOffset": 109, "endOffset": 164}, {"referenceID": 4, "context": "There are two distinguishing factors of our algorithm from [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003]: R\u0303 6= R, and past a certain distance from the root, we loop back.", "startOffset": 59, "endOffset": 114}, {"referenceID": 2, "context": "There are two distinguishing factors of our algorithm from [Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003]: R\u0303 6= R, and past a certain distance from the root, we loop back.", "startOffset": 59, "endOffset": 114}, {"referenceID": 0, "context": "The overall structure of the proof is similar to [Blackwell, 1956; Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003] with a few significant changes.", "startOffset": 49, "endOffset": 121}, {"referenceID": 4, "context": "The overall structure of the proof is similar to [Blackwell, 1956; Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003] with a few significant changes.", "startOffset": 49, "endOffset": 121}, {"referenceID": 2, "context": "The overall structure of the proof is similar to [Blackwell, 1956; Hart and Mas-Colell, 2002; Greenwald and Jafari, 2003] with a few significant changes.", "startOffset": 49, "endOffset": 121}, {"referenceID": 8, "context": "We also ran WalkSAT [Selman et al., 1993] offline on the set of 201 clauses, and on average it was able to satisfy all but 4% of the clauses, which gives an offline lower bound for what is possible.", "startOffset": 20, "endOffset": 41}, {"referenceID": 6, "context": "This task has received considerable attention, notably the celebrated Winnow algorithm [Littlestone, 1988], which is guaranteed to make a finite number of mistakes if the instances can be perfectly classified by some disjunction.", "startOffset": 87, "endOffset": 106}], "year": 2012, "abstractText": "Online learning aims to perform nearly as well as the best hypothesis in hindsight. For some hypothesis classes, though, even finding the best hypothesis offline is challenging. In such offline cases, local search techniques are often employed and only local optimality guaranteed. For online decision-making with such hypothesis classes, we introduce local regret, a generalization of regret that aims to perform nearly as well as only nearby hypotheses. We then present a general algorithm to minimize local regret with arbitrary locality graphs. We also show how the graph structure can be exploited to drastically speed learning. These algorithms are then demonstrated on a diverse set of online problems: online disjunct learning, online Max-SAT, and online decision tree learning.", "creator": "TeX"}}}