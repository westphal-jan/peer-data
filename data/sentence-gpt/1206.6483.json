{"id": "1206.6483", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jun-2012", "title": "Subgraph Matching Kernels for Attributed Graphs", "abstract": "We propose graph kernels based on subgraph matchings, i.e. structure-preserving bijections between subgraphs, that can be applied as a parameter for any given subgraph in the order to achieve the desired outcome.\n\n\n\n\nThe goal of the proposed graph tree is to provide the following to help with the performance of your data tree:\nWhen you have defined the graph tree (a graph tree that you want to store as a data tree), you will now have the ability to use the graph for other subgraphs, that you can create, or share the data to the desired end.\nIt's important that we include the code as a way to allow you to include and define subgraphs in your code. If you want to use this code, check out this article on using the graph tree in your project to create a data tree to make sure that it's not hard to access the subgraph tree.\nHere's an example graph tree, which can use the data tree to make a map to make a graph tree that is useful for testing other subgraphs.\nThis post is a continuation of our series and other similar posts by the authors of the same blog.\nAdvertisements", "histories": [["v1", "Wed, 27 Jun 2012 19:59:59 GMT  (409kb)", "http://arxiv.org/abs/1206.6483v1", "Appears in Proceedings of the 29th International Conference on Machine Learning (ICML 2012)"]], "COMMENTS": "Appears in Proceedings of the 29th International Conference on Machine Learning (ICML 2012)", "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["nils kriege", "petra mutzel"], "accepted": true, "id": "1206.6483"}, "pdf": {"name": "1206.6483.pdf", "metadata": {"source": "META", "title": "Subgraph Matching Kernels for Attributed Graphs", "authors": ["Nils Kriege", "Petra Mutzel"], "emails": ["nils.kriege@cs.tu-dortmund.de", "petra.mutzel@cs.tu-dortmund.de"], "sections": [{"heading": "1. Introduction", "text": "Graphs are well-studied versatile representations of structured data and have become ubiquitous in many application domains like chem- and bioinformatics. Comparing graphs is a fundamental problem and computing meaningful similarity measures is a prerequisite to apply a variety of machine learning algorithms to the domain of graphs. Consequently related problems have been extensively studied involving essential graph theoretical questions, which are typically NP-hard, like, e.g, the maximum common subgraph problem. However, graph similarity can be defined in various ways and its computation not necessarily requires to solve these problems exactly to yield a similarity measure appropriate for a wide range of applications.\nTo become applicable to the wealth of so-called ker-\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\nnel methods, including Support Vector Machines as the most prominent example, similarity measures must satisfy the additional constraints to be symmetric and positive semidefinite (p.s.d.). While recent development of graph kernels primarily focuses on large datasets of graphs with simple labels (cf. Table 1), it has been observed on several occasions that the prediction accuracy can be increased by annotating vertices or edges with additional attributes (see, e.g., Borgwardt et al., 2005; Fro\u0308hlich et al., 2005; Harchaoui & Bach, 2007). Since attributes in many cases include continuous values, a meaningful similarity measure must tolerate certain divergence. Therefore, kernels designed for graphs with simple labels often are not suitable for attributed graphs.\nWe propose a new graph kernel which is related to the maximum common subgraph problem. Instead of deriving a similarity measure from a maximum common subgraph our approach counts the number of matchings between subgraphs up to a fixed size and therefore has polynomial runtime. Attributes of mapped vertices and edges are assessed by a flexible scoring scheme and, thus, the approach can be applied to general attributed graphs."}, {"heading": "1.1. Related Work", "text": "In recent years various graph kernels have been proposed, see (Vishwanathan et al., 2010) and references therein. Ga\u0308rtner et al. (2003) and Kashima et al. (2003) devised graph kernels based on random walks, which count the number of labeled walks two graphs have in common. Subsequently random walk kernels were extended to avoid repeated consecutive vertices and were combined with vertex label enrichment techniques by Mahe\u0301 et al. (2004). The runtime was improved particularly for graphs with simple labels (Vishwanathan et al., 2010). Random walk kernels have been extended to take vertex and edge attributes into account and were thereby successfully applied to protein function prediction (Borgwardt et al., 2005).\nA drawback of random walks is that walks are struc-\nturally simple. However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (Ga\u0308rtner et al., 2003). Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009). Furthermore tree patters, which are allowed to contain repeated vertices just like random walks, were proposed by Ramon & Ga\u0308rtner (2003) and later refined by Mahe\u0301 & Vert (2009). While these approaches are based on all common subtree patterns of a specified height, others only take the entire neighborhood of each vertex up to given distance into account (Shervashidze et al., 2011), thus reducing the number of features and the required runtime significantly. Menchetti et al. (2005) proposed a weighted decomposition kernel, which determines matching substructures by a restrictive kernel (selector) and weights each matching by a kernel defined on the context of the matching. A kernel based on shortest-paths was developed by Borgwardt & Kriegel (2005), which first computes the length of shortestpaths between all pairs of vertices and then counts pairs with similar labels and distance. Instead of comparing pairs of individual vertices, the kernel proposed by Costa & De Grave (2010) associates a string encoding the neighborhood subgraph with each vertex.\nSeveral graph kernels were tailored especially to chemical compound. For attributed molecular graphs Fro\u0308hlich et al. (2005) proposed a similarity measure based on an optimal assignment of vertices. However, the proposed function was shown not be p.s.d. (Vishwanathan et al., 2010). Established techniques in cheminformatics are based on features which can be 1. directly generated from the molecular graph, e.g. all paths or subgraphs up to a certain size (Wale et al., 2008), similar to graphlets, 2. taken from a predefined dictionary or 3. generated in a preceding data-mining phase, e.g. using frequent subgraph mining.\nThe proposed techniques can be classified into approaches that use explicit feature mapping and those that directly compute a kernel function. If explicit representations are manageable, these approaches usually outperform other kernels regarding runtime on large datasets, since the number of vector representations scales linear with the dataset size. However, these approaches do not support attributed graphs, cf. Table 1. The computation technique proposed for random walk and tree pattern kernels, in contrast, can be extended to compare vertex and edge attributes by kernels. However, compared to graphlet kernels these approaches are based on simple features including repeated vertices.\nWe propose a technique that uses small subgraphs contained in the two graphs under comparison, similar to graphlets, but simultaneously provide the flexibility to compare vertex and edge attributes by means of arbitrary kernel functions."}, {"heading": "2. Preliminaries", "text": "In this section basic concepts of graph theory are introduced. We refer to simple undirected graphs. Given a graph G = (V,E) we denote by V (G) = V and E(G) = E the set of vertices and edges, respectively. The set of vertices adjacent to a vertex v is denoted by N(v) = {u \u2208 V : (u, v) \u2208 E}. A path of length n is a sequence of vertices (v0, . . . , vn) such that (vi, vi+1) \u2208 E for 0 \u2264 i < n. A graph is connected if at least one path between any pair of vertices exists and disconnected otherwise. A graph G\u2032 = (V \u2032, E\u2032) is a subgraph of a graph G = (V,E), written G\u2032 \u2286 G, iff V \u2032 \u2286 V and E\u2032 \u2286 E. If E\u2032 = (V \u2032 \u00d7 V \u2032) \u2229 E holds, G\u2032 = G[V \u2032] is said to be induced by V \u2032 in G. Note that a subgraph of a connected graph may be disconnected. In the following we will always refer to induced subgraphs and assume graphs to be labeled or attributed, i.e. a graph is a 3-tuple G = (V,E, l), where l : V \u222a E \u2192 L is a labeling function associating the label l(v) to the vertex v and l(e) to the edge e. All labels are from the set L and may as well consist of tuples of attribute-value pairs.\nA graph isomorphism between two labeled graphs G1 = (V1, E1, l1) and G2 = (V2, E2, l2) is a bijection \u03d5 : V1 \u2192 V2 that preserves adjacencies, i.e. \u2200u, v \u2208 V1 : (u, v) \u2208 E1 \u21d4 (\u03d5(u), \u03d5(v)) \u2208 E2, and labels: Let \u03c8\u03d5 : V1 \u00d7 V1 \u2192 V2 \u00d7 V2 be the mapping of vertex pairs implicated by the bijection \u03d5 such that \u03c8\u03d5((u, v)) = (\u03d5(u), \u03d5(v)). Then to preserve labels the conditions \u2200v \u2208 V1 : l1(v) \u2261 l2(\u03d5(v)) and \u2200e \u2208 E1 : l1(e) \u2261 l2(\u03c8\u03d5(e)) must hold, where \u2261 denotes that two labels are considered equivalent. Two\ngraphs G1, G2 are said to be isomorphic, written G1 ' G2, if a graph isomorphism between G1 and G2 exists. An automorphism of a graph G = (V,E) is a graph isomorphism \u03d5 : V \u2192 V . The set of automorphisms of G is denoted by Aut(G)."}, {"heading": "3. A Subgraph Matching Kernel", "text": "Several graph kernels count the number of isomorphic subgraphs contained in two graphs. A common subgraph isomorphism in contrast denotes a mapping between such subgraphs that preserves their structure.\nDefinition 1 (Common Subgraph Isomorphism) Let G1 = (V1, E1, l1), G2 = (V2, E2, l2) be two graphs and V \u20321 \u2286 V1, V \u20322 \u2286 V2 subsets of their vertices. A graph isomorphism \u03d5 of G1[V \u2032 1 ] and G2[V \u2032 2 ] is called common subgraph isomorphism (CSI) of G1 and G2.2\nBased on this definition we define the following kernel and will see later that the function is p.s.d.\nDefinition 2 (CSI Kernel) Let I(G1, G2) denote the set of all CSIs of two graphs G1 and G2 and \u03bb : I(G1, G2)\u2192 R+ a weight function. The function\nkcsi(G1, G2) = \u2211\n\u03d5\u2208I(G1,G2)\n\u03bb(\u03d5) (1)\nis called common subgraph isomorphism kernel. 2\nWhen vertices and edges are annotated with arbitrary attributes it is inappropriate to require a mapping to preserve the structure and the labels of the two graphs exactly. To this end, we generalize Def. 2 to allow for a more flexible scoring of bijections referred to as graph matching.\nDefinition 3 (Subgraph Matching Kernel) Given two graphs G1 = (V1, E1, l1), G2 = (V2, E2, l2), let B(G1, G2) denote the set of all bijections between sets V \u20321 \u2286 V1 and V \u20322 \u2286 V2 and let \u03bb : B(G1, G2)\u2192 R+ be a weight function. The subgraph matching kernel is defined as\nksm(G1, G2) = \u2211\n\u03d5\u2208B(G1,G2) \u03bb(\u03d5) \u220f v\u2208V \u20321 \u03baV (v, \u03d5(v)) \u220f e\u2208V \u20321\u00d7V \u20321 \u03baE(e, \u03c8\u03d5(e)),\nwhere V \u20321 = dom(\u03d5) and \u03baV , \u03baE kernel function defined on vertices and pairs of vertices, respectively. 2\nTheorem 1 The subgraph matching kernel is p.s.d.2\nProof The structure of a graph G = (V,E) with n vertices can be encoded by a tuple (~v, e), where ~v = (vi)n is a sequence of the vertices in V and e = [ei,j ]n\u00d7n is a matrix of elements E \u222a { }, such that ei,j = (vi, vj) if (vi, vj) \u2208 E and otherwise. By\nextending ~v and e by additional -elements we can encode graphs of different size into the same space. Each permutation of the vertices of a graph yields a valid encoding and a graph can be decomposed into all its encodings. This allows us to define a graph kernel by specifying an R-convolution (Haussler, 1999). Let R(~v, e, G) be a relation, where ~v and e are defined as above, G is a graph and R(~v, e, G) = 1 iff (~v, e) is an encoding of G. Let R\u22121(G) = {(~v, e) : R(~v, e, G) = 1} be the set of encodings of G. We can now specify the R-convolution kernel\nkenc(G1, G2) = \u2211\n(~u,e)\u2208R\u22121(G1) (~v,f)\u2208R\u22121(G2)\n\u220f i \u03baV (ui, vi) \u220f i,j \u03baE(ei,j , fi,j),\nwhere \u03baV ( , \u00b7) = 0. Combining this kernel with a convolution kernel based on subgraph decomposition and a suitable weight function yields\nk(G1, G2) = \u2211\nG\u20321\u2286G1 \u2211 G\u20322\u2286G2\n1\n|V (G\u20321)|! kenc(G\n\u2032 1, G \u2032 2). (2)\nThis kernel is equivalent to ksm with \u03bb(\u03d5) = 1, since there are exactly n! pairs of encodings of two graphs with n vertices corresponding to the same bijection.\nWe can identify Def. 2 as a special case of Def. 3, where\n\u03baV (v1, v2) = { 1 if l1(v1) \u2261 l2(v2), 0 otherwise and\n\u03baE(e1, e2) =  1 if e1 \u2208 E1 \u2227 e2 \u2208 E2 \u2227 l1(e) \u2261 l2(e)\nor e1 /\u2208 E1 \u2227 e2 /\u2208 E2, 0 otherwise.\nThese kernels assure that exactly the conditions of graph isomorphism are fulfilled. Therefore the CSI kernel is a special case of the subgraph matching kernel and we may state the following corollary.\nCorollary 1 The CSI kernel is p.s.d. 2"}, {"heading": "3.1. Relation to the Subgraph Kernel", "text": "The definitions of subgraph kernels proposed slightly differs. Here we refer to induced subgraphs of unbounded size.\nDefinition 4 (Subgraph Kernel) Given two graphs G1, G2 \u2208 G and a weight function \u03bbs : G \u2192 R+. The subgraph kernel is defined as\nks(G1, G2) = \u2211\nG\u20321\u2286G1 \u2211 G\u20322\u2286G2 \u03bbs(G \u2032 1)k'(G \u2032 1, G \u2032 2), (3)\nwhere k' : G \u00d7 G \u2192 {0, 1} is the isomorphism kernel, i.e. k'(G \u2032 1, G \u2032 2) = 1 iff G \u2032 1 ' G\u20322. 2\nThe subgraph kernel basically counts isomorphic subgraphs, while the CSI kernel counts the number of isomorphisms between subgraphs. Since there may be more than one isomorphism between a pair of isomorphic subgraphs, both concepts differ in detail.\nTheorem 2 Let ks be a subgraph kernel with weight function \u03bbs and kcsi a CSI kernel with weight function \u03bbcsi(\u03d5) = \u03bbs(G) |Aut(G)| , where G = G1[dom(\u03d5)]. Then kcsi(G1, G2) = ks(G1, G2) for all graphs G1, G2 \u2208 G. 2 Proof For each pair (G\u20321, G \u2032 2) that contributes to the sum of Eq. (3), G\u20321 ' G\u20322 holds. CSIs exist for these pairs of graphs only. There are |Aut(G\u20321)| = |Aut(G\u20322)| isomorphism between G\u20321 and G \u2032 2, each of which is contained in I(G1, G2) and contributes to Eq. (1). This is compensated by the correction term |Aut(G\u20321)|\u22121."}, {"heading": "3.2. Relation to the Pharmacophore Kernel", "text": "Mahe\u0301 et al. (2006) proposed a kernel to compare chemical compounds based on characteristic features together with their relative spatial arrangement, socalled pharmacophores. To this end, a molecule is represented by a set of pairs M = {(xi, li) \u2208 R3 \u00d7 L}i, where xi are the coordinates of a feature i in a 3- dimensional space and li is an associated label. The set of pharmacophores of a molecule M is P(M) = {(a1, a2, a3) \u2208 M3 : a1 6= a2, a1 6= a3, a2 6= a3}. The pharmacophore kernel is then defined as\nkp(M1,M2) = \u2211\np1\u2208P(M1) \u2211 p2\u2208P(M2) ki(p1, p2)ks(p1, p2)\nand measures the similarity of two molecules based on triples of similar characteristic features with a similar spatial arrangement, which is quantified by the two kernels ki and ks, respectively. These are defined as ki(p, p \u2032) = \u220f3 i=1 kfeat(li, l \u2032 i) and ks(p, p\n\u2032) =\u220f3 i=1 kdist(||xi, xi+1||, ||x\u2032i, x\u2032i+1||), where || \u00b7 || denotes the Euclidean distance and the index i + 1 is taken modulo 3.\nFrom the representation M of a molecule as used by the pharmacophore kernel we can construct a graph G(M) = (VM , EM , lM ), such that VM = {v1, . . . , v|M |} with lM (vi) = li and EM = VM \u00d7 VM with lM ((vi, vj)) = ||xi, xj ||. Theorem 3 Let kp be a pharmacophore kernel and ksm a subgraph matching kernel with weight function \u03bb(\u03d5) = 6 if |dom(\u03d5)| = 3 and 0 otherwise and vertex and edge kernels defined as \u03baV (v1, v2) = kfeat(l(v1), l(v2)) and \u03baE(e1, e2) = kdist(l(e1), l(e2)). Then kp(M1,M2) = ksm(G(M1), G(M2)) holds. 2\nProof The weight function \u03bb ensures that only subgraphs with three vertices contribute to the value of\nksm. Since G(M) is a complete graph by definition, each common subgraph induced by three vertices is a triangle, i.e. all triples of vertices with their pairwise distances are taken into account. For each subset with three vertices there are six different triples representing all possible permutations. Comparing two subsets with three elements, 3! = 6 combinations of associated triples correspond to the same mapping of three vertices. Thus, multiplying the value of 3-element subgraph matchings by 6 compensates for this."}, {"heading": "3.3. Kernel Computation", "text": "In this section we propose an algorithm to compute the CSI and subgraph matching kernel. Our technique is inspired by a classical result of Levi (1973) who observed a relation between common subgraphs of two graphs and cliques in their product graph. Given two graphs G1 = (V1, E1, l1) and G2 = (V2, E2, l2), the (modular) product graph GP = (VP , EP ) of G1 and G2 is defined by VP = {(v1, v2) \u2208 V1\u00d7V2 : l1(v1) \u2261 l2(v2)} and EP containing an edge connecting two vertices (u1, u2), (v1, v2) \u2208 VP iff u1 6= v1, u2 6= v2 and either e1 = (u1, v1) \u2208 E1 and e2 = (u2, v2) \u2208 E2 and l1(e1) \u2261 l2(e2) (c-edge) or e1 /\u2208 E1 and e2 /\u2208 E2 (dedge). The distinction of c-edges and d-edges is due to Koch (2001); c-edges represent common adjacency and d-edges common non-adjacency1. Thus, two vertices of the product graph are adjacent iff the corresponding vertex mappings can be part of the same CSI, see Fig. 1 for an example.\nLevi (1973) observed that each maximum clique in the product graph is associated with a maximum common subgraph of the factor graphs. Furthermore, the vertex set C is a clique in GP iff there is a corresponding CSI \u03d5 \u2208 I(G1, G2). As a consequence we can enumerate (or count) all CSIs by enumerating (counting) the cliques of the product graph. To compute\n1The concept of product graphs has been used for the computation of graph kernels before. Note that the definition used here is different from the direct product graph, which contains only c-edges, proposed by Ga\u0308rtner et al. (2003) to compute a random walk kernel.\nthe subgraph matching kernel we extend the approach by means of a weighted product graph, where vertices and edges are annotated with the values of \u03baV and \u03baE , respectively. Each clique is then associated with the product of the weights of all vertices and edges contained in it.\nDefinition 5 (Weighted Product Graph) Given two graphs G1 = (V1, E1, l1), G2 = (V2, E2, l2) and vertex and edge kernels \u03baV and \u03baE , the weighted product graph (WPG) GP = (VP , EP , c) of G1 and G2 is defined by\nVP = {(v1, v2) \u2208 V1 \u00d7 V2 : \u03baV (v1, v2) > 0} EP = {((u1, u2), (v1, v2)) \u2208 VP \u00d7 VP : u1 6= v1 \u2227\nu2 6= v2 \u2227 \u03baE((u1, v1), (u2, v2)) > 0} c(v) = \u03baV (v1, v2) \u2200v = (v1, v2) \u2208 VP c(e) = \u03baE((u1, v1), (u2, v2)) \u2200e \u2208 EP ,\nwhere e = ((u1, u2), (v1, v2)). 2\nIf we assume \u03baE(e1, e2) = 0 if e1 \u2208 E1 and e2 /\u2208 E2 or vice versa, the distinction of c- and d-edges carries over to weighted product graphs.\nAlgorithm 1: SMKernel(w, C, P )\nInput : WPG GP = (VP , EP , c), weight function \u03bb Initial : value\u2190 0; SMKernel(1, \u2205, VP ) Param.: Weight w of the clique C, candidate set P Output: Result of the kernel function value\n1 while |P | > 0 do 2 v \u2190 arbitrary element of P 3 C \u2032 \u2190 C \u222a {v} 4 w\u2032 \u2190 w \u00b7 c(v) . multiply by vertex weight 5 forall the u \u2208 C do 6 w\u2032 \u2190 w\u2032 \u00b7 c(u, v) . multiply by edge weights 7 value\u2190 value+ w\u2032 \u00b7 \u03bb(C \u2032) 8 SMKernel(w\u2032, C \u2032, P \u2229N(v)) . extend clique 9 P \u2190 P \\ {v}\nAlgorithm 1 computes the subgraph matching kernel by enumeration of cliques. A current clique is extended stepwise by all vertices preserving the clique property. These vertices form the candidate set P . Whenever the current clique C is extended by a new vertex v, the weight of the vertex itself (line 4) and all the edges connecting v to a vertex in C (line 6) are multiplied with the weight of the current clique w to obtain the weight of the new clique. The algorithm effectively avoids duplicates by removing a vertex from the candidate set after all cliques containing it have been exhaustively explored (line 9)."}, {"heading": "3.3.1. Restriction to Subgraph Classes", "text": "In this section we discuss restrictions to certain classes of subgraphs, their relation to cliques in the product graph and appropriate modifications of the enumeration algorithm. Since finding a maximum clique or a maximum CSI is known to be an NP-hard problem, it may be required in practice to restrict the size of the subgraphs considered. Modifying Algorithm 1 to stop the recursion whenever a fixed maximum size k has been reached, effectively restricts the size of the cliques and thereby the size of the matched subgraphs, which is quantified by the number of vertices.\nRestricting to connected subgraphs may also significantly reduce the search space, especially when graphs are sparse. Moreover disconnected subgraphs convey less structural information and may therefore be considered less relevant. This constraint can be realized by an adaption of a technique proposed by Koch (2001). A clique that is spanned by c-edges, a so-called c-clique, corresponds to a connected CSI. Algorithm 1 can be modified to only enumerate c-cliques by making sure that only vertices are added that are adjacent to a vertex in the current clique via at least one cedge. The restricted variants remain p.s.d., since they are equivalent to the general subgraph matching kernel with a suitably chosen weight function."}, {"heading": "3.3.2. Runtime Analysis", "text": "Complexity The runtime of Algorithm 1 depends on the number of cliques in the product graph. Since there is a one-to-one correspondence between cliques and bijections contributing to the kernel value, we can derive an upper bound for the number of cliques in GP by considering the number of possible bijections. There are ( n k ) induced subgraphs of size k in a graph with n vertices and up to k! isomorphisms between graphs of size k. Thus, we have\nC(k) = k\u2211 i=0 i! ( n1 i )( n2 i ) \u2264 k\u2211 i=0 ( n1n2 i ) cliques of size up to k in GP . Therefore the worst-case runtime of Algorithm 1 (modified to stop recursion at depth k) is O(nC(k)) = O(knk+1), where n = n1n2.\nPractical considerations The analysis of the complexity shows that a reasonable performance in practice can only be expected when the maximum size of the subgraphs considered is restricted. Therefore, the approach competes against subgraph or graphlet kernels. Besides the differences described in Sec. 3.1, the methods of computation exhibit substantially different characteristics: The runtime of our algorithm heavily\ndepends on the number of allowed mappings of subgraphs. For instances with diverse labels in combination with a restrictive vertex kernel (e.g. Dirac kernel) the size of the product graph is typically substantially reduced, such that |VP | |V1| \u00b7 |V2|. In a similar way diverse edge labels may diminish the number of edges. Due to d-edges sparse graphs tend to have dense product graphs and contain a large number of cliques. However, in this case the number of enumerated cliques can be significantly reduced by restricting to c-cliques.\nThe computation of subgraph kernels is based on explicit mapping into feature space. While this is beneficial for certain datasets, the number of subgraphs quickly becomes very large for graphs with diverse labels rendering explicit mapping prohibitive (Shervashidze et al., 2009). Furthermore, subgraph kernels are not applicable to attributed graphs. In these respects, our approach is complementary to subgraph kernels and shows promise for instances for which these approaches fall short."}, {"heading": "4. Experimental Evaluation", "text": ""}, {"heading": "4.1. Method & Datasets", "text": "We performed classification experiments using the CSVM implementation LIBSVM2. We report mean prediction accuracies as well as standard deviations obtained by 10-fold cross-validation repeated 10 times with random fold assignment. Within each fold the parameter C was chosen from {10\u22123, 10\u22122, . . . , 103} by cross-validation based on the training set.\nWe compared the subgraph matching kernel (SM and CSM with connection constraint) to kernels based on fixed length random walks (FLRW) and tree patterns3 (TP), both supporting attributed graphs. Our implementation is similar to the efficient dynamic programming approach proposed by Harchaoui & Bach (2007). Furthermore, we compare to the Geometric Random Walk (GRW), Shortest Path (SP), Weisfeiler-Lehman Subtree (WL) and Weisfeiler-Lehman Shortest Path (WLSP) kernel. WLSP is similar to NSPDK recently proposed by Costa & De Grave (2010).\nThese graph kernels can be tuned by several parameters. The maximum size of (C)SM was chosen from k \u2208 {1, 2, . . . , 7} and a uniform weight function was used. FLRW was computed for walks of length l \u2208 {1, 2, . . . , 8} and the parameter \u03bb for GRW was cho-\n2http://www.csie.ntu.edu.tw/~cjlin/libsvm 3The definition by Ramon & Ga\u0308rtner (2003) is vague regarding subtrees without children. We require subtrees to have at least one child, see (Mahe\u0301 & Vert, 2009) for a detailed discussion of this issue.\nsen from {10\u22125, 10\u22124, . . . , 10\u22122}. For TP we used a uniform weight \u03bb chosen from {10\u22125, 10\u22124, . . . , 10\u22122} with height h \u2208 {1, 2, 3, 4}. The number of iterations of WL/WLSP was chosen from h \u2208 {0, 1, . . . , 5}. All parameters were selected by cross-validation on the training datasets only. As remarked before (Wale et al., 2008; Costa & De Grave, 2010) kernels using features of different size are typically biased towards large features. Therefore, we also normalized kernel values separately for each feature size where applicable. Since the runtimes may depend on the selected parameters, we report the time required to compute a complete Gram matrix for each dataset using parameters frequently selected by the optimization process.\nFor a fair comparison all kernels were adapted to take vertex and edge labels into account and implemented in Java. For the pharmacophore kernel (PH) we used the implementation provided by the authors4. Experiments were conducted using Sun Java JDK v1.6.0 on an Intel Xeon E5430 machine at 2.66GHz with 8GB of RAM using a single processor only.\nGraphs with simple labels We employed benchmark datasets containing molecules5 and proteins: The MUTAG dataset consists of 188 chemical compounds divided into two classes according to their mutagenic effect on a bacterium. The PTC dataset contains compounds labeled according to carcinogenicity on rodents divided into male mice (MM), male rats (MR), female mice (FM) and female rats (FR). Molecules can naturally be represented by graphs, where vertices represent atoms and edges represent chemical bonds. We have removed explicit hydrogen atoms and labeled vertices by atom type and edges by bond type (single, double, triple or aromatic).\nWe have obtained the dataset ENZYME from Borgwardt et al. (2005), which is associated with the task of assigning 600 enzymes to one of the 6 EC top level classes. Vertices represent secondary structure elements (SSE) and are annotated by their type, i.e. helix/sheet/turn. Two vertices are connected by an edge if they are neighbors along the amino acid sequence or one of three nearest neighbors in space. Edges are annotated with their type, i.e. structural/sequential.\nAttributed graphs Benchmark datasets containing attributed graphs are less wide-spread. We used the ENZYME dataset adding an attribute representing the 3d length of the SSE in A\u030a to each vertex. The vertex kernel was defined as the product of a Dirac kernel\n4ChemCPP v1.0.2, http://chemcpp.sourceforge.net 5Both datasets are widely used (see, e.g., Kashima et al., 2003) and can be obtained from http://cdb.ics.uci.edu\non the type attributes and the Brownian bridge kernel with parameter c = 3 originally used on the length attribute, see (Borgwardt et al., 2005). The edge kernel remains a Dirac kernel on the type attribute.\nFurther classification problems were derived from the chemical compound datasets BZR, COX2, DHFR and ER which come with 3D coordinates, and were used by Mahe\u0301 et al. (2006) to study the pharmacophore kernel. We generated complete graphs from the compounds, where edges are labeled with distances6 as described in Sect. 3.2 and vertex labels correspond to atom types. We used a triangular kernel to compare distances defined by k(d1, d2) = 1 c \u00b7max{0, c\u2212|d1\u2212 d2|} and chose c from {0.1, 0.25, 0.5, 1.0} by cross-validation."}, {"heading": "4.2. Results & Discussion", "text": "The classification accuracies and runtimes are summarized in Tables 2 and 3. In terms of classification accuracy on graphs with simple labels no general suggestion which kernel performs best can be derived. CSM performs best on FM, where walk-based kernels perform slightly worse. For the multiclass classification problem ENZYME with simple labels CSM yields results comparable to WL and WLSP, while others perform worse. This observation also holds for ENZYME with attributes, where WL and WLSP can no longer be applied. All approaches benefit significantly from the additional vertex annotations, which indicates the importance of attributes, and CSM reaches the highest classification accuracy. On molecular distance graphs we observed that SM performs best in two of four cases and competitive on the other datasets. However, the differences here are rather small. Mahe\u0301 et al. (2006) suggested to extend the pharmacophore kernel to take more than 3 points into account. At least for the instances we have tested, we observed that this does not lead to a significant increase in classification accuracy. Nevertheless, this might prove useful where more complex binding mechanism must be considered.\nThe runtime results on graphs with simple labels clearly show that computation schemes based on explicit mapping outperform other approaches. These all lie in the same order of magnitude and CSM is slower than FLRW and TP. For attributed graphs SP no longer allows explicit mapping. This leads to a considerable increase in runtime of SP on the ENZYME dataset, where it is now the slowest of the four tested approaches, while the other kernels noticeably benefit from the sparsity introduced by the vertex kernel taking the length attribute into account. TP could not\n6These distances were directly used for SP, which then reduces to a kernel basically comparing edges.\nbe employed to molecular distance graphs, since the runtime to compute a Gram matrix here exceeded 24h even for the most restrictive edge kernel with c = 0.1. This can be explained by the fact that this class of graphs contains vertices with large sets of matching neighbors, all subsets of which are considered by TP. The runtime of PH also is very high rendering the approach infeasible for large datasets. We observed that the runtime of SM increased with the parameter c, which is as expected, since the product graph becomes more dense when the threshold parameter is raised. Therefore, we have also compared the runtime of PH and SM both using a Gaussian RBF kernel to compare distances, which leads to a very dense product graph. We found SM to be nevertheless approximately five times faster than PH, suggesting that our method of computation is superior in general. We also compared CSM to SM and observed that CSM is significantly faster on sparse graphs, while still reaching a comparable prediction accuracy."}, {"heading": "5. Conclusion & Future Work", "text": "We have proposed a new graph kernel, which takes complex graph structures not containing repeated vertices into account and supports attributed graphs without restriction. The experimental evaluation shows promising results for attributed graphs from chem- and bioinformatics. Improving the runtime for large-scale datasets and large graphs remains future work. However, our approach already works well in practice for medium-sized graphs, large graphs when vertex and edge kernels are sparse, or when restricted to small or connected subgraphs. Thus, we believe subgraph matching kernels are a viable alternative to existing approaches for attributed graphs."}, {"heading": "Acknowledgments", "text": "We would like to thank Karsten Borgwardt and Nino Shervashidze for providing their kernel implementations and datasets. Nils Kriege was supported by the German Research Foundation (DFG), priority programme \u201cAlgorithm Engineering\u201d (SPP 1307)."}], "references": [{"title": "Shortest-path kernels on graphs", "author": ["K.M. Borgwardt", "Kriegel", "H.-P"], "venue": "In Proc. ICDM, pp", "citeRegEx": "Borgwardt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Borgwardt et al\\.", "year": 2005}, {"title": "Protein function prediction via graph kernels", "author": ["K.M. Borgwardt", "C.S. Ong", "S. Schnauer", "S.V.N. Vishwanathan", "A.J. Smola", "Kriegel", "H.-P"], "venue": "Suppl 1:i47\u2013i56,", "citeRegEx": "Borgwardt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Borgwardt et al\\.", "year": 2005}, {"title": "Fast neighborhood subgraph pairwise distance kernel", "author": ["F. Costa", "K. De Grave"], "venue": "In Proc. ICML, pp", "citeRegEx": "Costa and Grave,? \\Q2010\\E", "shortCiteRegEx": "Costa and Grave", "year": 2010}, {"title": "Optimal assignment kernels for attributed molecular graphs", "author": ["H. Fr\u00f6hlich", "J.K. Wegner", "F. Sieker", "A. Zell"], "venue": "In Proc. ICML,", "citeRegEx": "Fr\u00f6hlich et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Fr\u00f6hlich et al\\.", "year": 2005}, {"title": "On graph kernels: Hardness results and efficient alternatives", "author": ["T. G\u00e4rtner", "P. Flach", "S. Wrobel"], "venue": null, "citeRegEx": "G\u00e4rtner et al\\.,? \\Q2003\\E", "shortCiteRegEx": "G\u00e4rtner et al\\.", "year": 2003}, {"title": "Image classification with segmentation graph kernels", "author": ["Z. Harchaoui", "F. Bach"], "venue": "In Proc. CVPR,", "citeRegEx": "Harchaoui and Bach,? \\Q2007\\E", "shortCiteRegEx": "Harchaoui and Bach", "year": 2007}, {"title": "Convolution kernels on discrete structures", "author": ["D. Haussler"], "venue": "Tech Rep UCSC-CRL-99-10", "citeRegEx": "Haussler,? \\Q1999\\E", "shortCiteRegEx": "Haussler", "year": 1999}, {"title": "Marginalized kernels between labeled graphs", "author": ["H. Kashima", "K. Tsuda", "A. Inokuchi"], "venue": "In Proc. ICML, pp", "citeRegEx": "Kashima et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Kashima et al\\.", "year": 2003}, {"title": "Enumerating all connected maximal common subgraphs in two graphs", "author": ["I. Koch"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Koch,? \\Q2001\\E", "shortCiteRegEx": "Koch", "year": 2001}, {"title": "A note on the derivation of maximal common subgraphs of two directed or undirected graphs", "author": ["G. Levi"], "venue": "Calcolo,", "citeRegEx": "Levi,? \\Q1973\\E", "shortCiteRegEx": "Levi", "year": 1973}, {"title": "Graph kernels based on tree patterns for molecules", "author": ["P. Mah\u00e9", "Vert", "J.-P"], "venue": "Mach. Learn.,", "citeRegEx": "Mah\u00e9 et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Mah\u00e9 et al\\.", "year": 2009}, {"title": "Extensions of marginalized graph kernels", "author": ["P. Mah\u00e9", "N. Ueda", "T. Akutsu", "Perret", "J.-L", "Vert", "J.-P"], "venue": "In Proc. ICML,", "citeRegEx": "Mah\u00e9 et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Mah\u00e9 et al\\.", "year": 2004}, {"title": "The pharmacophore kernel for virtual screening with support vector machines", "author": ["P. Mah\u00e9", "L. Ralaivola", "V. Stoven", "Vert", "J.-P"], "venue": "J Chem Inf Model,", "citeRegEx": "Mah\u00e9 et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Mah\u00e9 et al\\.", "year": 2003}, {"title": "Weighted decomposition kernels", "author": ["S. Menchetti", "F. Costa", "P. Frasconi"], "venue": "In Proc. ICML,", "citeRegEx": "Menchetti et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Menchetti et al\\.", "year": 2005}, {"title": "Expressivity versus efficiency of graph kernels", "author": ["J. Ramon", "T. G\u00e4rtner"], "venue": "In First International Workshop on Mining Graphs, Trees and Sequences,", "citeRegEx": "Ramon and G\u00e4rtner,? \\Q2003\\E", "shortCiteRegEx": "Ramon and G\u00e4rtner", "year": 2003}, {"title": "Efficient graphlet kernels for large graph comparison", "author": ["N. Shervashidze", "S.V.N. Vishwanathan", "T.H. Petri", "K. Mehlhorn", "K.M. Borgwardt"], "venue": "In AISTATS,", "citeRegEx": "Shervashidze et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Shervashidze et al\\.", "year": 2009}, {"title": "Comparison of descriptor spaces for chemical compound retrieval and classification", "author": ["N. Wale", "I.A. Watson", "G. Karypis"], "venue": "Knowl Inf Sys,", "citeRegEx": "Wale et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wale et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 16, "context": "While recently proposed kernels based on common subgraphs (Wale et al., 2008; Shervashidze et al., 2009) in general can not be applied to attributed graphs, our approach allows to rate mappings of subgraphs by a flexible scoring scheme comparing vertex and edge attributes by kernels.", "startOffset": 58, "endOffset": 104}, {"referenceID": 15, "context": "While recently proposed kernels based on common subgraphs (Wale et al., 2008; Shervashidze et al., 2009) in general can not be applied to attributed graphs, our approach allows to rate mappings of subgraphs by a flexible scoring scheme comparing vertex and edge attributes by kernels.", "startOffset": 58, "endOffset": 104}, {"referenceID": 9, "context": "To compute the kernel we propose a graphtheoretical algorithm inspired by a classical relation between common subgraphs of two graphs and cliques in their product graph observed by Levi (1973). Encouraging experimental results on a classification task of realworld graphs are presented.", "startOffset": 181, "endOffset": 193}, {"referenceID": 3, "context": "Table 1), it has been observed on several occasions that the prediction accuracy can be increased by annotating vertices or edges with additional attributes (see, e.g., Borgwardt et al., 2005; Fr\u00f6hlich et al., 2005; Harchaoui & Bach, 2007).", "startOffset": 157, "endOffset": 239}, {"referenceID": 0, "context": "Random walk kernels have been extended to take vertex and edge attributes into account and were thereby successfully applied to protein function prediction (Borgwardt et al., 2005).", "startOffset": 156, "endOffset": 180}, {"referenceID": 2, "context": "G\u00e4rtner et al. (2003) and Kashima et al.", "startOffset": 0, "endOffset": 22}, {"referenceID": 2, "context": "G\u00e4rtner et al. (2003) and Kashima et al. (2003) devised graph kernels based on random walks, which count the number of labeled walks two graphs have in common.", "startOffset": 0, "endOffset": 48}, {"referenceID": 2, "context": "G\u00e4rtner et al. (2003) and Kashima et al. (2003) devised graph kernels based on random walks, which count the number of labeled walks two graphs have in common. Subsequently random walk kernels were extended to avoid repeated consecutive vertices and were combined with vertex label enrichment techniques by Mah\u00e9 et al. (2004). The runtime was improved particularly for graphs with simple labels (Vishwanathan et al.", "startOffset": 0, "endOffset": 326}, {"referenceID": 4, "context": "RW (G\u00e4rtner et al., 2003) \u00d7 \u221a", "startOffset": 3, "endOffset": 25}, {"referenceID": 15, "context": "SP (Borgwardt & Kriegel, 2005) \u00d7 ( \u221a ) Graphlet (Shervashidze et al., 2009) \u221a \u00d7 NSPDK (Costa & De Grave, 2010) \u221a \u00d7 WL (Shervashidze et al.", "startOffset": 48, "endOffset": 75}, {"referenceID": 4, "context": "However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (G\u00e4rtner et al., 2003).", "startOffset": 101, "endOffset": 123}, {"referenceID": 15, "context": "Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009).", "startOffset": 186, "endOffset": 213}, {"referenceID": 4, "context": "However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (G\u00e4rtner et al., 2003). Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009). Furthermore tree patters, which are allowed to contain repeated vertices just like random walks, were proposed by Ramon & G\u00e4rtner (2003) and later refined by Mah\u00e9 & Vert (2009).", "startOffset": 102, "endOffset": 477}, {"referenceID": 4, "context": "However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (G\u00e4rtner et al., 2003). Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009). Furthermore tree patters, which are allowed to contain repeated vertices just like random walks, were proposed by Ramon & G\u00e4rtner (2003) and later refined by Mah\u00e9 & Vert (2009). While these approaches are based on all common subtree patterns of a specified height, others only take the entire neighborhood of each vertex up to given distance into account (Shervashidze et al.", "startOffset": 102, "endOffset": 517}, {"referenceID": 4, "context": "However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (G\u00e4rtner et al., 2003). Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009). Furthermore tree patters, which are allowed to contain repeated vertices just like random walks, were proposed by Ramon & G\u00e4rtner (2003) and later refined by Mah\u00e9 & Vert (2009). While these approaches are based on all common subtree patterns of a specified height, others only take the entire neighborhood of each vertex up to given distance into account (Shervashidze et al., 2011), thus reducing the number of features and the required runtime significantly. Menchetti et al. (2005) proposed a weighted decomposition kernel, which determines matching substructures by a restrictive kernel (selector) and weights each matching by a kernel defined on the context of the matching.", "startOffset": 102, "endOffset": 825}, {"referenceID": 4, "context": "However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (G\u00e4rtner et al., 2003). Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009). Furthermore tree patters, which are allowed to contain repeated vertices just like random walks, were proposed by Ramon & G\u00e4rtner (2003) and later refined by Mah\u00e9 & Vert (2009). While these approaches are based on all common subtree patterns of a specified height, others only take the entire neighborhood of each vertex up to given distance into account (Shervashidze et al., 2011), thus reducing the number of features and the required runtime significantly. Menchetti et al. (2005) proposed a weighted decomposition kernel, which determines matching substructures by a restrictive kernel (selector) and weights each matching by a kernel defined on the context of the matching. A kernel based on shortest-paths was developed by Borgwardt & Kriegel (2005), which first computes the length of shortestpaths between all pairs of vertices and then counts pairs with similar labels and distance.", "startOffset": 102, "endOffset": 1097}, {"referenceID": 4, "context": "However, computing kernels by counting common subgraphs of unbounded size is known to be NP-complete (G\u00e4rtner et al., 2003). Thus, another direction in the development of graph kernels focuses on small subgraphs of a fixed size k \u2208 {3, 4, 5}, referred to as graphlets, which primarily apply to unlabeled graphs (Shervashidze et al., 2009). Furthermore tree patters, which are allowed to contain repeated vertices just like random walks, were proposed by Ramon & G\u00e4rtner (2003) and later refined by Mah\u00e9 & Vert (2009). While these approaches are based on all common subtree patterns of a specified height, others only take the entire neighborhood of each vertex up to given distance into account (Shervashidze et al., 2011), thus reducing the number of features and the required runtime significantly. Menchetti et al. (2005) proposed a weighted decomposition kernel, which determines matching substructures by a restrictive kernel (selector) and weights each matching by a kernel defined on the context of the matching. A kernel based on shortest-paths was developed by Borgwardt & Kriegel (2005), which first computes the length of shortestpaths between all pairs of vertices and then counts pairs with similar labels and distance. Instead of comparing pairs of individual vertices, the kernel proposed by Costa & De Grave (2010) associates a string encoding the neighborhood subgraph with each vertex.", "startOffset": 102, "endOffset": 1331}, {"referenceID": 16, "context": "all paths or subgraphs up to a certain size (Wale et al., 2008), similar to graphlets, 2.", "startOffset": 44, "endOffset": 63}, {"referenceID": 3, "context": "For attributed molecular graphs Fr\u00f6hlich et al. (2005) proposed a similarity measure based on an optimal assignment of vertices.", "startOffset": 32, "endOffset": 55}, {"referenceID": 6, "context": "This allows us to define a graph kernel by specifying an R-convolution (Haussler, 1999).", "startOffset": 71, "endOffset": 87}, {"referenceID": 8, "context": "Our technique is inspired by a classical result of Levi (1973) who observed a relation between common subgraphs of two graphs and cliques in their product graph.", "startOffset": 51, "endOffset": 63}, {"referenceID": 8, "context": "The distinction of c-edges and d-edges is due to Koch (2001); c-edges represent common adjacency and d-edges common non-adjacency.", "startOffset": 49, "endOffset": 61}, {"referenceID": 4, "context": "Note that the definition used here is different from the direct product graph, which contains only c-edges, proposed by G\u00e4rtner et al. (2003) to compute a random walk kernel.", "startOffset": 120, "endOffset": 142}, {"referenceID": 8, "context": "This constraint can be realized by an adaption of a technique proposed by Koch (2001). A clique that is spanned by c-edges, a so-called c-clique, corresponds to a connected CSI.", "startOffset": 74, "endOffset": 86}, {"referenceID": 15, "context": "While this is beneficial for certain datasets, the number of subgraphs quickly becomes very large for graphs with diverse labels rendering explicit mapping prohibitive (Shervashidze et al., 2009).", "startOffset": 168, "endOffset": 195}, {"referenceID": 16, "context": "As remarked before (Wale et al., 2008; Costa & De Grave, 2010) kernels using features of different size are typically biased towards large features.", "startOffset": 19, "endOffset": 62}, {"referenceID": 0, "context": "We have obtained the dataset ENZYME from Borgwardt et al. (2005), which is associated with the task of assigning 600 enzymes to one of the 6 EC top level classes.", "startOffset": 41, "endOffset": 65}, {"referenceID": 0, "context": "on the type attributes and the Brownian bridge kernel with parameter c = 3 originally used on the length attribute, see (Borgwardt et al., 2005).", "startOffset": 120, "endOffset": 144}, {"referenceID": 10, "context": "Further classification problems were derived from the chemical compound datasets BZR, COX2, DHFR and ER which come with 3D coordinates, and were used by Mah\u00e9 et al. (2006) to study the pharmacophore kernel.", "startOffset": 153, "endOffset": 172}, {"referenceID": 10, "context": "Mah\u00e9 et al. (2006) suggested to extend the pharmacophore kernel to take more than 3 points into account.", "startOffset": 0, "endOffset": 19}], "year": 2012, "abstractText": "We propose graph kernels based on subgraph matchings, i.e. structure-preserving bijections between subgraphs. While recently proposed kernels based on common subgraphs (Wale et al., 2008; Shervashidze et al., 2009) in general can not be applied to attributed graphs, our approach allows to rate mappings of subgraphs by a flexible scoring scheme comparing vertex and edge attributes by kernels. We show that subgraph matching kernels generalize several known kernels. To compute the kernel we propose a graphtheoretical algorithm inspired by a classical relation between common subgraphs of two graphs and cliques in their product graph observed by Levi (1973). Encouraging experimental results on a classification task of realworld graphs are presented.", "creator": "LaTeX with hyperref package"}}}