{"id": "1206.6825", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jun-2012", "title": "Non-Minimal Triangulations for Mixed Stochastic/Deterministic Graphical Models", "abstract": "We observe that certain large-clique graph triangulations can be useful to reduce both computational and space requirements when making queries on mixed stochastic/deterministic graphical models. We demonstrate that many of these large-clique triangulations are non-minimal and are thus unattainable via the variable elimination algorithm. We introduce ancestral pairs as the basis for novel triangulation heuristics and prove that no more than the addition of edges between ancestral pairs need be considered when searching for state space optimal triangulations in such graphs. These observations provide insight into the role of computational processes in shaping the natural and non-parametric nature of natural and non-parametric structures. Our results demonstrate that a number of large-clique triangulations are non-minimal and can be avoided if the complexity of these structures is reduced to the minimum and is not reduced by computational processes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Wed, 27 Jun 2012 15:41:21 GMT  (199kb)", "http://arxiv.org/abs/1206.6825v1", "Appears in Proceedings of the Twenty-Second Conference on Uncertainty in Artificial Intelligence (UAI2006)"]], "COMMENTS": "Appears in Proceedings of the Twenty-Second Conference on Uncertainty in Artificial Intelligence (UAI2006)", "reviews": [], "SUBJECTS": "cs.AI cs.DS", "authors": ["chris bartels", "jeff a bilmes"], "accepted": false, "id": "1206.6825"}, "pdf": {"name": "1206.6825.pdf", "metadata": {"source": "CRF", "title": "Non-Minimal Triangulations for Mixed Stochastic/Deterministic Graphical Models", "authors": ["Chris D. Bartels", "Jeff A. Bilmes"], "emails": ["bartels@ee.washington.edu", "bilmes@ee.washington.edu"], "sections": [{"heading": "1 INTRODUCTION", "text": "When expressing a probability distribution as a Bayesian network, it is often beneficial to include variables whose value is a deterministic function of other variables. These variables have a variety of possible uses, such as the representation of hard or soft constraints [10]. One might also use a hidden deterministic variable to factor a dense probability table into a product of smaller tables. Even when the graph designer does not specify deterministic variables, methods have been developed to discover these factorizations [31]. In addition to their computational advantages, they are often a powerful representational tool in that deterministic variables can have real meaning and their posterior probabilities p(d|evidence) are often needed for further \u201csemantic\u201d processing. Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].\nComputing exact probabilistic quantities can be done using a junction tree [22, 27], as a search procedure [3, 10], or\nusing a hybrid scheme [10]. All exact inference methods in one way or another explicitly or at least implicitly define at least one graph triangulation [17], and many modern techniques can take advantage of a \u201cgood\u201d triangulation. An important question, however, is how should the quality of a given triangulation be quantitatively judged?\nA common measure of triangulation quality is the size of the clique potentials formed in traditional junction tree message passing, usually called the state space or weight [22, 19, 32]. Specifically, the state space or cardinality of a vertex v, notated |v|, is the number of distinct values it may hold. The state space of a clique, C, holding vertices v1, v2, ..., vk is defined as S(C) = \u220fk i=1 |vi|. Lastly, the state space of a graph, G, with maximal cliques C1, C2, ..., Ck is defined as S(G) = \u2211k i=1 S(Ci). This measure is not fully adequate to describe the utility of a triangulation in every situation. Varying methods of computing probabilities have different performances and a wide variety of time-space trade offs. Search methods can be run in constant memory and use triangulations (which are often value specific) only indirectly. In addition, combinations of deterministic functions and evidence form constraints that can create large numbers of zeros in the distribution. Methods such as zero compression [16] and constraint propagation [12, 3, 20] can be used to exploit this, but the costs of queries on such a distribution are difficult to determine without actually performing the computation. With this being said, state space can give a measure of the upper bound of the computational requirements. As will be seen, we obtain significant wall-clock speedups under this assumption using a modern probabilistic inference engine.\nThis leads to the question of what method should be used to exploit deterministic variables in inference. Here we consider arbitrary deterministic functions (other techniques exist for certain classes of functions, such as sums [23]). In this work we use a hybrid approach where a junction tree is formed, but a search is used to process the messages entering and leaving the individual cliques. This can take advantage of some of the constraints imposed by the joint effect of determinism and evidence, but a more basic optimization comes from the fact that the value of a deterministic variable can be uniquely determined given its parents.\nFor a given parent combination it contributes only a constant time factor to evaluate the function, and performing this calculation does not require zero compression or any form of constraint propagation. If a deterministic variable lives in a maximal clique that is missing one or more of its parents, its value can not be determined uniquely and it needs to be iterated just as if it were stochastic. We now modify our definition of clique state space to reflect this:\nDefinition 1. The state space of a clique, C, with v1, ..., vk, and the set D = {v|v is deterministic and parents of v \u2208 C} is: S(C) = \u220f v\u2208C\\D |v|.\nGiven this new optimization criterion, we show (Section 3) that on graphs with deterministic variables, triangulations that only minimize treewidth can use unboundedly more computational resources than triangulations with large cliques."}, {"heading": "2 BACKGROUND", "text": "In this section, we define much of the notation, terminology, and known theorems required in later sections. A chord is an edge connecting two non-consecutive vertices in a cycle. A graph is triangulated if it contains no chordless cycles of length greater than three. A triangulation of a graph G = (V,E) is a (possibly empty) set of edges F such that E \u2229 F = \u2205 and the graph T (G) = (V,E \u222a F ) is triangulated. The edges in F are called fill-in edges. The term triangulation will also be used to mean the graph T (G). Given a graph G = (V,E), the neighbors of v \u2208 V are defined as NEG(v) = (w \u2208 V |{v, w} \u2208 E). A triangulation F of graph G = (V,E) is minimal if G\u2032 = (V,E \u222a F0) is not triangulated for any F0 \u2282 F . A edge e is a non-minimal edge in T1(G) = (V,E \u222aF ) if T2(G) = (V,E\u222aF\\e) is also triangulated. A clique is a set of vertices for which every vertex in the set is connected to every other vertex in the set. A maximal clique is a clique that is not a subset of some larger clique. The treewidth of a triangulated graph [2] is the size of its largest maximal clique minus 1. The treewidth of an arbitrary graph is the smallest width of all triangulations. A vertex is simplicial in the graph G if NEG(v) form a complete set. Triangulated graphs with more than one node have at least two simplicial vertices.\nVertex elimination [28, 8, 9] is an algorithm that can be used to triangulate graphs. An elimination order is a bijection \u03b1 : {1, 2, ..., |V |} \u2194 V . We use \u03b1(v) to denote the integer position of node v in the ordering \u03b1, and \u03b1\u22121(i) to denote the vertex indexed by the integer i in ordering \u03b1. The deficiency [28] of a vertex v in G is: DG(v) = ({u,w}|{v, u} \u2208 E, {v, w} \u2208 E, {u,w} /\u2208 E}). Given G = (V,E), the v-elimination graph Gv is defined by adding the edges DG(v) and then deleting v and its incident edges from G. Creating Gv from G is known as eliminating the vertex v. The elimination graph, denoted as \u03be\u03b1(G), is the original graph G with the addition of any edges added at each step in the elimination process (see [28], MTE(G;\u03b1)). A perfect ordering is an ordering for\nwhich elimination adds no edges.\n(a) (b)\nand Figure 1). Elimination can, however, create any minimal triangulation [25]:\nTheorem 2. If T (G) = (V,E\u222aF ) is a minimal triangulation of G = (V,E), then there exists an elimination order \u03b1 such that \u03be\u03b1(G) = T (G) [25, Theorem 1].\nThe choice of triangulation can make an exponential difference in the time and memory needed for inference and finding an optimal one is NP-hard [2, 32], so heuristic search methods must be used. Many search methods exist, and are often based on choosing an ordering of the nodes for vertex elimination [18, 19, 24, 28]. Most heuristics that do not involve elimination (such as [6, 26]) will choose minimal triangulations over non-minimal triangulations."}, {"heading": "3 MINIMAL VERSUS NON-MINIMAL", "text": "With a sense of the usefulness of deterministic variables and background on triangulation and elimination, we continue by discussing when and why one would want to move beyond conventional triangulation techniques. It is a common belief that triangulations that minimize clique size are desirable for use in computing queries on a graphical model. The reason is that it can be shown that many of the metrics of performance are upper bounded in some exponential function on w, the inherent treewidth of the graph [7, 13]. Although w can form an upper bound it is not necessarily optimal. An instance of this is when it may be more desirable to cluster many small cardinality variables together in a clique to avoid increasing the sizes of cliques that contain large cardinality variables. In addition, some queries can be performed on junction trees without actually storing the clique potentials in memory; instead only the separator potentials are stored. In such a scheme one might want to increase clique size to reduce separator size and, in turn, reduce memory requirements (at the cost of more time) [11]. Also see [1] where large cliques are used to reduce junction tree clique degree. Later in this section it will be shown that large cliques can be beneficial when deterministic variables are present in the graph.\nIn graphs without deterministic variables, state space optimal triangulations might not always be treewidth optimal, but we show here that they will always be minimal and therefore obtainable using some elimination order. Many papers attempt to minimize state space by searching over elimination orders [19, 24] implying that this theorem has been assumed in the past, but we have not found a published proof in the literature. The proof of the following is given in the Appendix:\nTheorem 3. Given a graph G = (V,E) where all of the variables are stochastic and have state space \u2265 2, some elimination graph of G will have optimal state space.\nWhen using deterministic variables, state space optimal triangulations might not be obtainable from any elimination order. Consider Figure 2 where d is a deterministic function of its parents a and b, the cardinalities of a, b, c and e are all \u03b7, and the cardinality of d is \u03b72 \u2212 1 (the largest sensible cardinality for d). This graph is triangulated as is, and its state space with no additional fill-in is 2\u03b74 \u2212 \u03b72. If one considers the graph in Figure 2(b) the cost is reduced to \u03b74 + \u03b73 \u2212 \u03b72. One might also run elimination beginning with d, resulting in the graph of Figure 2(c) and cost \u03b74. None of these nor any elimination ordering will give the optimal triangulation seen in Figure 2(d) having state space of 2\u03b73. This state space is a factor of \u03b7 smaller than any elimination based triangulation. One might also notice that in this example the problem can be solved by transforming the graph into one that does not include the deterministic variable, where a and b are both connected directly c and e. Standard elimination can then be used on the transformed graph. Although this approach could work, it will be shown in Section 5 and Figure 3 that the optimal choice of which transformations to make can not be made locally and is not any simpler than choosing a fill-in."}, {"heading": "4 ELIMINATION GRAPH DETECTION AND COMPLEXITY", "text": "It has been demonstrated that elimination is unable to create certain (potentially useful) triangulations, but given a triangulation, how can one tell if an elimination order could have generated it? We give a polynomial time algorithm to solve this problem in Algorithm 1, and a correctness proof is given in the Appendix. It takes as input a graph, G, and a triangulation, T (G), and returns true if T (G) can be obtained by some elimination order. This algorithm is essential in our results where we show that most of the desirable triangulations in our test set could not have been generated by elimination.\nNext, we give results on the computational complexity of finding triangulations in the mixed stochastic/deterministic setting. It was proven in [2] that it is NP-complete to determine whether a graph has treewidth \u2264 k. It was proven in [32] that finding optimal state space triangulations in graphical models with binary variables is NP-hard through a reduction from the Elimination Degree Se-\nAlgorithm 1 isEliminationGraph On input \u3008G = (V, E), T (G) = (V, E \u222a F )\u3009 if |V | = 0 then\nreturn true else\nA = {v|(v simplicial in T (G)) & (NEG(v)=NET (G)(v))} if A = \u2205 then\nreturn false else\nv \u2208 A, return isEliminationGraph( Gv , (T (G))v ) end if\nend if\nquence problem. Here we state that the decision version of the triangulation problem remains in NP for any polynomial time heuristic f(T (G), I), where I contains vertex information such as cardinality and determinism. This general definition allows us to prove NP-completeness for determining if a triangulation is sufficiently good under our modified definition of state space. We show that the state space problem remains NP-complete through a reduction from the treewidth problem. This reduction is simpler than the reduction from the Elimination Degree Sequence problem and is valid for variables with arbitrary cardinalities. See the Appendix for the proofs. Definition 4. MAXTRI = {\u3008G = (V,E), I, \u03b1\u3009 | G has a triangulation with f(T (G), I) < \u03b1 } Theorem 5. MAXTRI is in NP for all polynomial f(G, I). Definition 6. MAXSTATESPACE = {\u3008G = (V,E), I, \u03b1\u3009 | G has a T (G) with state space < \u03b1} Theorem 7. MAXSTATESPACE is NP-complete."}, {"heading": "5 ELIMINATION WITH EXTRA FILL-IN", "text": "At this point, we know that elimination alone is not sufficient to generate all triangulations, and more importantly some graphs with deterministic dependencies can not be optimally triangulated by any elimination order. Because finding state space optimal triangulations is NP-hard, it is necessary to develop heuristic approaches that are able to find the desired non-minimal triangulations. This section describes an algorithm called extra-elimination that extends elimination to make it possible to find any triangulation. This algorithm is given here in its most general form, but at this point it has too much flexibility. Later in the paper we limit its options to make it a practical search algorithm. Definition 8. Extra-Elimination : Alternate the following two steps until no vertices remain: (a) Add edges to the current graph, (b) Eliminate a vertex. When finished, take the union of the extra edges added in the (a) steps and the fill-in edges added in the (b) steps and add them to the original graph.\nExtra-elimination allows extra edges to be added at any point during the elimination process (with the restriction that one is not allowed to add extra edges to a vertex that has already been eliminated), but the same triangulation will result regardless of when extra edges are added.\nExtra-elimination can be considerably constrained by taking into account that we are considering Bayesian networks with deterministic variables that have values given by arbitrary functions of their parents. In such a graph, moralization will cause each deterministic variable to be in at least one maximal clique with its parents, but the variable might also be a member of other maximal cliques due to its nonparent neighbors. In these cases we can sometimes reduce the state space by adding fill-in edges that ensure that every maximal clique that contains a deterministic variable d also contains d\u2019s parents. We call edges that can accomplish this goal ancestral edges and these are the edges that we will pick from when choosing extra fill-in edges. Definition 9. An ancestral edge is one that connects a parent of a deterministic node d to a child or undirected neighbor of d. An ancestral pair is a pair of nodes such that an edge between them would be ancestral.\nAncestral edges are named for the case where they connect a node\u2019s parent to the node\u2019s child, but they can exist for a number of reasons. These include a deterministic node\u2019s undirected neighbors gained during moralization, undirected neighbors needed to triangulate the graph, or a neighbor from another ancestral edge (see Figures 3(a)3(c)). In certain contexts there might be neighbors from other sources as well, such as DBN frame boundaries [4] or the creation of cliques for the analysis of posteriors or MAP calculations.\nThe following theorem states that the optimal state space triangulation can always be found using extra-elimination where we limit the choice of extra edges to ancestral pairs. The proof (in Appendix) shows that the state space optimal triangulation will be a minimal triangulation of a graph augmented by ancestral edges. Theorem 10. Elimination with extra-elimination edge addition where the extra edges are limited to ancestral edges\nis sufficient to find an optimal state space triangulation when all cardinalities are \u2265 2.\nOur problem is still not solved, though. Theorem 10 only tells us that the needed non-minimal edges will be ancestral in the optimal triangulation. Not all ancestral edges may be needed, and not all needed ancestral edges will be known without knowing the rest of the optimal triangulation. It might at first seem that we can look at each deterministic node, d, with parents pa(d), and non-parent neighbor c and add ancestral edges between pa(d) and c if S(c\u222ad\u222apa(d)) is less than S(c \u222a d) + S(d \u222a pa(d)). For example, in Figure 3(d) choosing ancestral pairs will only depend on the cardinality of d. Suppose |a| = |b| = |c| = |e| = 10 and |d| = 40, then the graph will have a state space of 900 with no fill-in, and a state space of 2000 when, as in Figure 3(e), all ancestral edges have been added. In the general case, the choice of ancestral pairs needed for a state space optimal triangulation can not be made without knowing the rest of the triangulation. In Figure 3(f), either (a, c) or (f, d) and either (b, e) or (d, h) needs to be added in order to triangulate the graph. Just as in Figure 3(d) it is not locally optimal to add the ancestral edges, but if (a, c) and (b, e) are added to triangulate the graph, as in Figure 3(g), the ancestral edges might now be beneficial. If the cardinality of all of the stochastic variables is 10 and the cardinality of d is 40, then Figure 3(g) has a state space of 12100, but Figure 3(h) that includes the ancestral edges has a state space of only 6000.\nExtra-elimination with ancestral edges gives a framework for finding triangulations in networks with deterministic dependencies, but gives no guidance on which ancestral pairs should be chosen. We now describe a pre-processing step that adds ancestral edges to a graph, and this new graph is then triangulated using standard elimination heuristics. The heuristics given here will only choose edges from what\nwe will define as pre-triangulation ancestral pairs. A pair of vertices is a pre-triangulation ancestral pair if an edge between them is ancestral in the original moralized graph, or ancestral after other pre-triangulation ancestral edges have been added. Note that this definition implies a recursion: if an ancestral edge is added it might create additional ancestral pairs.\nFour heuristics for deciding which extra edges to add are proposed here. The first is to use all pre-triangulation ancestral edges, called all-extra. The next is to randomly select a subset of pre-triangulation ancestral edges, called sampled-extra. The third heuristic is to choose the pretriangulation extra edges that are locally optimal, called locally-optimal-extra (lo-extra). That is, if we have a deterministic node, v, with parents pa(v) and non-parent neighbor c, the set of edges between c and pa(v) is locally optimal if S(c \u222a v \u222a pa(v)) < S(c \u222a v) + S(v \u222a pa(v)). The fourth method is similar to all-extra, except that it ignores ancestral pairs that are a result of undirected edges (such as from moralization). It only considers ancestral pairs resulting from children of deterministic nodes plus any ancestral pairs that are recursively formed from other ancestral edge additions. This method is called some-extra and is included primarily to show the effect of ancestral edges due to these less obvious causes.\nIt should be stressed that considering only pre-triangulation ancestral edges does not consider all possible ancestral edge triangulations. The fill-in due to an elimination step could increase the potential number of ancestral edges. This is illustrated in Figure 3(i). To consider all possible ancestral pairs one would also need to recursively consider the additional ancestral pairs caused by the fill-in edges added after each elimination step."}, {"heading": "5.1 RESULTS", "text": "The goal of the experiments is to compare the four extraelimination heuristics to elimination. For each graph and each of the four extra-elimination heuristics, 19642 triangulations were generated and 488 of these were timed. The same procedure was repeated four times using pure elimination. There are two reasons for this repetition. First, it provides a fair comparison between elimination and the overall best of the four extra-elimination methods. Second, it ensures that a large part of the elimination search space has been explored. Note that the elimination triangulations have a significant advantage over the four extra-elimination methods individually since 4\u00d7 as many cases were considered.\nThe 19642 triangulations were generated using a variety of state of the art elimination heuristics. 20 one-step look ahead heuristics were used, including minimum weight, fill, size, and various combinations and repetitions of these. For each look ahead heuristic there was an additional parameter from 1-3 where the next node in the order is chosen randomly from the top x choices. This parameter is similar to the Stochastic-Greedy Algorithm given in [15]. Maxi-\nmum cardinality search was also used, bringing the total to 61. For each of the 61 methods one triangulation was chosen for timing by having the lowest state space from separate pools of 100, 50, 10, and 1 triangulations. All of the above were repeated using a modified state space heuristic.\nThe triangulations were timed on a calculation of the probability of evidence, stopping if more than 1 Gb of memory was used. Our probability computation engine is hybrid inference/search [10] where message passing is done over the junction tree and search is done within a clique. For search, we use an algorithm that consists of backtracking and an optimized static variable order.\nThe first set of graphs is composed of 356 randomly generated Bayesian networks. Each graph has 30 nodes, a maximum in-degree of 4, and the set of edges is chosen uniformly over all graphs fulfilling the constraints. Each node has a 0.5 probability of being deterministic and a 0.1 probability of being observed. The stochastic variables have cardinalities between 2 and 5 and the observed variables have a cardinality of 50. The deterministic variables have cardinalities between 2 and the product of their parents\u2019 cardinalities, with a upper bound of 125. For each graph, the fastest triangulation from each of the five methods is chosen. Table 1 gives counts of the number of graphs where each method was the best overall, and the number of times each method was various orders of magnitude slower than the best. Figure 4 compares the number of graphs where the best triangulation could and could not have been created using elimination (determined using Algorithm 1). Table 2 gives results over sets of graphs with a fixed number of deterministic variables. With little determinism, there is less opportunity for improvement over elimination, and with much determinism the total state space of the graph is small and the solution can be found quickly regardless of the triangulation.\nThe second set of results (Table 3) uses 10 real-world dynamic Bayesian networks. In addition to what was done on the random graphs, a set of 488 triangulations was generated using one instance of maximum cardinality search, minimum weight, fill, or size (labeled once). This is to compare our elimination baseline to a typical baseline. The\nfollowing are descriptions of the graphs. Aurora Decoding: whole word model for speech recognition, [5]. Edit Distance training 1, 2, decoding: learns edit distance parameters from data [14]. Feature Detect: extracts phonetic features from speech data. Image Concept Detect: for image classification. Mandarin: speech recognition graph modeling tonal phones using asynchronous feature streams [33]. MultiStream: speech recognition training graph with asynchronous feature streams based on [34]. PhoneFree 1, 2: word pronunciation scoring using a phone-free model.\nOn the randomly generated graphs, all-extra was the overall winner scoring the best on over half of the graphs. Sampled-extra was the second best overall, followed by some-extra. Lo-extra and elimination performed poorly overall. All-extra performs well when there is a high percentage of determinism (as in this set of random graphs). One might conclude that all-extra is the only method that should ever be considered, but in one case it was 15 times as slow as the best (which was an elimination graph). Sampled-extra has the potential to perform very well as it subsumes all of the other methods, but the large number of fill-in choices keep it, on average, slower than all-extra. The results on the real-world DBNs were much less dramatic. This because the cliques that are necessarily formed when partitioning the DBNs can account for a majority of the compute time and make the graphs fairly dense to begin with (see [4]). The extra-elimination heuristics gave significant improvement on 4 graphs with 2 more than doubling in speed. The median performance of the new heuristics was much better in many cases, but poor in others."}, {"heading": "6 CONCLUSION", "text": "This paper has shown that large clique triangulations can be computationally useful on graphs containing deterministic variables. An example was given where the optimal triangulation has a state space that is arbitrarily smaller than all elimination based triangulations. An algorithm was presented to determine if a triangulation could have been generated using elimination, and it was shown that the generalized triangulation problem is NP-complete. Extraelimination was introduced as a framework for producing any triangulation, and it was proven that extra edges can be limited to the ancestral edges when optimizing for state space. Novel heuristics based on ancestral edges were presented and results were given on randomly generated and real world graphs. Future work will include a joint search for triangulation and within-clique dynamic variable orderings for use in hybrid inference/search procedures."}, {"heading": "A APPENDIX", "text": "Lemma 11. If G = (V,E), G\u2032 = (V,E\u2032) triangulated with E\u2032 \u2286 E, |E \\ E\u2032| = k then there is an increasing sequence G\u2032 = G0 \u2282 ... \u2282 Gk = G of triangulated graphs that differ by exactly one edge. [21, Lemma 2.21, page 20]\nLemma 12. Consider T (G) = (V,E \u222a F ) with nonminimal edge (u, v) and all v \u2208 C are stochastic. C is the (necessarily) unique maximal clique in T (G) that contains u and v in T \u2032(G) = (V,E \u222a F \\ (u, v)), C is split into cliques Cu = C \\ {u} and Cv = C \\ {v}. Define c = S(C \\ {u, v}), if Cu and Cv are maximal cliques in T \u2032(G) then S(T \u2032(G)) \u2212 S(T (G)) will be c(|u| + |v| \u2212 |u||v|). If Cu is a subset of a maximal clique it is (1 \u2212 |u|)c|v|, if Cv is a subset it is (1 \u2212 |v|)c|u|, and if both are it is \u2212c|u||v|. Proof. The cliques not containing both u and v will be unaffected by the edge removal. S(C) = c|u||v|, and S(Cv) = c|v| and S(Cu) = c|u|.\nLemma 13. In a graph where all variables are stochastic with cardinality \u2265 2, a triangulation that is state space optimal and minimal will exist. Proof. Suppose we have a non-minimal triangulation T (G) and remove an edge (u, v) creating T \u2032(G), from Lemma 13 S(T \u2032(G)) \u2212 S(T (G)) < 0. From Lemma 11, we can create a sequence from any T (G) to any minimal T \u2032(G), and the state space of each graph will be <= the previous graph.\nProof of Theorem 3. From Lemma 13 and Theorem 2.\nThe following lemma is assumed by [25] but never proven:\nLemma 14. If G1 = (V,E), G2 = (V,E\u222aE2), \u03be\u03b1(G1) = (V,E \u222a F1), and \u03be\u03b1(G2) = (V,E \u222a E2 \u222a F2), then F1 \u2286 (E2 \u222a F2). Proof. Obvious for |V | = 1, assume it is true for |V | = N \u2212 1 and consider |V | = N . NEG1(\u03b1\n\u22121(1)) \u2286 NEG2(\u03b1 \u22121(1)), so DG1(\u03b1 \u22121(1)) \u2286 (DG2(\u03b1\n\u22121(1)) \u222a E2). Therefore (G1)\u03b1\u22121(1) is a spanning subgraph of (G2)\u03b1\u22121(1), and a proof by the induction hypothesis.\nTheorem 15. If G = (V,E) with ordering \u03b1, then {v, w} is a fill-in of \u03be\u03b1 iff \u2203 a chain [v, v1, v2, ..., vk, w] in G such that \u03b1(vi) < min(\u03b1(v), \u03b1(w))\u2200 i = 1...k [29, Lemma 4].\nLemma 16. E\u03b1(G) = T (G), \u03b1(k) is simplicial in T (G), and NEG(\u03b1(k)) = NET (G)(\u03b1(k)), then \u03b2 = (\u03b1(k), \u03b1(1), \u03b1(2), ..., \u03b1(k \u2212 1), \u03b1(k + 1), ..., \u03b1(|V |)) and E\u03b2(G) = T (G). Proof. Eliminate T (G) according to \u03b2. \u03b1(k) is simplicial in T (G) so eliminating it will not add edges. For i = 1, . . . , k \u2212 1, k + 1, . . . , |V |, \u03b1(i) will have the same neighbors eliminating according to \u03b2 as it does eliminating according to \u03b1. Therefore, \u03b2 is a perfect ordering of T (G). E\u03b2(G) = (V,E \u222a F\u03b2), E\u03b2(T (G)) = (V,E \u222a F ) from Lemma 14, F\u03b2 \u2286 F .\nNow suppose edge (v, w) \u2208 F but (v, w) /\u2208 F\u03b2 . NEG(\u03b1(k)) \u2286 NEE\u03b2(G)(\u03b1(k)) \u2286 NET (G)(\u03b1(k)) = NEG(\u03b1(k)), so v, w 6= \u03b1(k). Define S\u03b1 = {u \u2208 V :\n\u03b1(u) < min[\u03b1(v), \u03b1(w)]} and S\u03b2 = {u \u2208 V : \u03b2(u) < min[\u03b2(v), \u03b2(w)]}. If k < min[\u03b1(v), \u03b1(w)] then S\u03b1 = S\u03b2 . If k > min[\u03b1(v), \u03b1(w)] then S\u03b1 = S\u03b2 \\ \u03b1(k). From Theorem 15, there is a path in G, [v, v1, v2, ..., vl, w], where \u03b1(vi) \u2208 S\u03b1 \u2200 i = 1...l \u2014 but since (v, w) /\u2208 F\u03b2 , no such path [v, v1, v2, ..., vm, w] exists in G such that \u03b2(vi) \u2208 S\u03b2 \u2200 i = 1...m. This, however, is a contradiction since S\u03b1 \u2286 S\u03b2 . Therefore, we must have that (v, w) \u2208 F\u03b2 . Therefore, F\u03b2 = F .\nTheorem 17. isEliminationGraph will return true if and only if F can be generated by some elimination order \u03b1. Proof. First we will show if return= true then \u2203\u03b1 such that E\u03b1 = T (G). The proof is by induction on |V |. It holds for |V | = 1, assume it is true when |V | = N \u2212 1, and consider when |V | = N . We assumed return=true on \u3008G,T (G)\u3009, so return=true on \u3008Gv , (T (G))v\u3009, and from the induction hypothesis \u2203\u03b2 s.t. E\u03b2(Gv) = (T (G))v . Construct \u03b1 by concatenating v to the front of \u03b2. NEG(v) = NET (G)(v) so NEE\u03b1(G)(v) = NET (G)(v).\nNext we show if \u03be\u03b1 = (V,E\u222aF ) then isEliminationGraph will return true. This will be proven by induction on |V |. Obvious for |V | = 1, assume it is true when |V | = N \u2212 1, and consider when |V | = N . We use Lemma 16 to construct \u03b2 from \u03b1. G\u03b1(k) is eliminated in the order \u03b2 \\\u03b1(k) it will generate T (G)\u03b1(k), and from the induction hypothesis isEliminationGraph will return true.\nProof of Theorem 5. Verify a member of MAXTRI using V =\u201dOn input \u3008V,E, I, F, \u03b1\u3009: 1) Build G = (V,E \u222a F ). 2) Check if G is triangulated. 3) If f(G, I) < \u03b1 accept; otherwise reject.\u201d |F | < |V |2, testing if G = (V,E \u222aF ) is triangulated is \u2208 P [29, 30].\nProof of Theorem 7. MAXTREEWIDTH = {\u3008G = (V,E), k\u3009 | G has treewidth \u2264 k }, is NP-complete [2]. To reduce from MAXTREEWIDTH, give v \u2208 V cardinality |V | and no determinism, and return MAXSTATESPACE(G, I, |V |k+1). There are \u2264 |V | \u2212 1 maximal cliques in T (G), so if T (G) has a treewidth \u2264 k we get a max. state space (|V | \u2212 1)|V |k < |V |k+1, and MAXSTATESPACE will accept. If the treewidth of G is \u2265 k + 1 the min. state space is |V |k+1 and MAXSTATESPACE will reject. Similarly, if MAXSTATESPACE accepts the treewidth \u2264 k and if it rejects the treewidth is > k.\nLemma 18. Consider G,T (G) with cardinalities \u2265 2. Suppose an edge (p, c) is added to form Tnew(G). If S(Tnew(G)) < S(T (G)) then (p, c) is ancestral with respect to some deterministic node d. Proof. From lemma 12, if the state space decreases the maximal clique with p, c in Tnew(G) can not have only stochastic variables. There must be deterministic variable d and a maximal clique C1 \u2208 T (G) s.t. c, d \u2208 C1, p /\u2208 C1 where p is a parent of d, and the addition of (p, c) creates a new maximal clique C2 such that C1 \u2282 C2 and p \u2208 C2. From moralization c can not be a parent of n, so it must be a child or undirected neighbor.\nProof of Theorem10. The optimal state space triangulation is T (G) = (V,E \u222a F ). Define set A as all edges \u2208 F and ancestral in T (G), and G\u2032 = (V,E \u222a A). T (G) is a triangulation of G\u2032 with fill-in F \u2032 = F \\ A. We want to conclude that F \u2032 is a minimal triangulation of G\u2032. Assume this is not true, and \u2203 M \u2282 F \u2032 such that Tmin(G\u2032) = (V, (E \u222aA)\u222aM) is triangulated. From Lemma 11 there is\nan increasing sequence of graphs from Tmin(G\u2032) to T (G). S(T (G)) is optimal so S(Tmin(G\u2032)) \u2265 S(T (G)). If S(Tmin(G\n\u2032)) > S(T (G)) at least one graph in the sequence must have a lower state space than the previous, but from Lemma 18 this is a contradiction. Therefore, F \u2032 is a minimal triangulation of G\u2032 and T (G) is an elimination graph of G\u2032. If S(Tmin(G\u2032)) = S(T (G)), Tmin(G\u2032) is also an optimal triangulation and elimination graph."}, {"heading": "Acknowledgments", "text": "This work was supported by ONR MURI grant N000140510388 and by NSF grant IIS-0093430. Feature Detect graph courtesy of Simon King, Image Concept courtesy of Brock Pytlik, PhoneFree 1 and 2 courtesy of Karen Livescu."}], "references": [{"title": "The generalized distributive law", "author": ["S.M. Aji", "J. McEliece"], "venue": "IEEE Trans. on Information Theory, 46:325\u2013343", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2000}, {"title": "Complexity of finding embeddings in a k-tree", "author": ["S. Arnborg", "D.J. Corneil", "A.P. Proskurowski"], "venue": "SIAM J. Alg. Dis. Meth., 8:227\u2013284", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1987}, {"title": "Value elimination: Bayesian inference via backtracking search", "author": ["F. Bacchus", "S. Dalmao", "T. Pitassi"], "venue": "Proc. UAI", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "On triangulating dynamic graphical models", "author": ["J. Bilmes", "C. Bartels"], "venue": "Proc. UAI, Acapulco, Mexico", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "and et", "author": ["J. Bilmes", "G. Zweig"], "venue": "al. Discriminatively structured dynamic graphical models for speech recognition. In In Final Report: JHU 2001 Summer Workshop", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "F", "author": ["H.L. Bodlaender", "A.M. Koster"], "venue": "van den Eijkhof, and L. C. van der Gaag. Pre-processing for triangulation of probabilistic networks. In Proc. UAI", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2001}, {"title": "Recursive conditioning", "author": ["A. Darwiche"], "venue": "Artificial Intelligence, 126:5\u201341", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2001}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "J. ACM, 7(3):201\u2013215", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1960}, {"title": "Bucket elimination: A unifying framework for several probabilistic inference algorithms", "author": ["R. Dechter"], "venue": "Proc. UAI", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1996}, {"title": "Constraint Processing", "author": ["R. Dechter"], "venue": "Morgan Kaufmann", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "Topological parameters for time-space tradeoff", "author": ["R. Dechter", "Y.E. Fattah"], "venue": "Artificial Intelligence,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2001}, {"title": "Hybrid processing of beliefs and constraints", "author": ["R. Dechter", "D. Larkin"], "venue": "Proc. UAI", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2001}, {"title": "Mixtures of deterministicprobabilistic networks and their and/or search space", "author": ["R. Dechter", "R. Mateescu"], "venue": "Proc. UAI", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2004}, {"title": "A dynamic Bayesian framework to model context and memory in edit distance learning: An application to pronunciation classification", "author": ["K. Filali", "J. Bilmes"], "venue": "In Proc. ACL,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2005}, {"title": "Optimizing exact genetic linkage computations", "author": ["M. Fishelson", "D. Geiger"], "venue": "Journal of Computational Biology, 11(2- 3):263\u201375", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2004}, {"title": "Approximations in bayesian belief universes for knowledge-based systems", "author": ["F. Jensen", "S. Andersen"], "venue": "Proc. UAI", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1990}, {"title": "Optimal junction trees", "author": ["F. Jensen", "F. Jensen"], "venue": "Proc. UAI", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1994}, {"title": "Triangulation of graphs-algorithms giving small total state space", "author": ["U. Kjaerulff"], "venue": "Technical Report R-90-09,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1990}, {"title": "Bayesian inference in the presence of determinism", "author": ["D. Larkin", "R. Dechter"], "venue": "Proc. AISTATS", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2003}, {"title": "Graphical Models", "author": ["S. Lauritzen"], "venue": "Oxford Science Publications", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1996}, {"title": "Local computations with probabilities on graphical structures and their application to expert systems", "author": ["S. Lauritzen", "D. Spiegelhalter"], "venue": "The Journal of the Royal Statistical Society, 50:57\u2013224", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1988}, {"title": "Convolutional factor graphs as probabilistic models", "author": ["Y. Mao", "F. Kschischang", "B. Frey"], "venue": "Proc. UAI", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "Triangulation by continuous embedding", "author": ["M. Meila", "M.I. Jordan"], "venue": "Advances in Neural Information Processing Systems, volume 9", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1997}, {"title": "Minimal triangulation of a graph and optimal pivoting order in a sparse matrix", "author": ["T. Ohtsuki", "L.K. Cheung", "T. Fujisawa"], "venue": "J. Math. Anal. Appl., 54:622\u2013633", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1976}, {"title": "How to use the minimal separators of a graph for its chordal triangulation", "author": ["A. Parra", "P. Scheffler"], "venue": "Automata, Languages and Programming, pages 123\u2013134", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1995}, {"title": "Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference", "author": ["J. Pearl"], "venue": "Morgan Kaufmann, 2nd printing edition", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1988}, {"title": "Triangulated graphs and the elimination process", "author": ["D.J. Rose"], "venue": "J. Math. Anal. Appl., 32:597\u2013609", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1970}, {"title": "Algorithmic aspects of vertex elimination on graphs", "author": ["D.J. Rose", "R.E. Tarjan", "G.S. Lueker"], "venue": "SIAM J. Comp., 5:266\u2013283", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1976}, {"title": "Simple linear-time algorithms to test chordality of graphs", "author": ["R.E. Tarjan", "M. Yannakakis"], "venue": "test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs. SIAM J. Comp., 13:566\u2013579", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1984}, {"title": "Exploiting functional dependence in bayesian network inference", "author": ["J. Vomlel"], "venue": "Proc. UAI", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2002}, {"title": "Optimal decomposition of belief networks", "author": ["W. Wilson"], "venue": "Proc. UAI", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1991}, {"title": "DBN multistream models for Mandarin toneme recognition", "author": ["L. Xin", "G. Ji", "J. Bilmes", "M. Ostendorf"], "venue": "Proc. ICASSP", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2005}, {"title": "DBN based multi-stream models for speech", "author": ["Y. Zhang", "Q. Diao", "S. Huang", "W. Hu", "C. Bartels", "J. Bilmes"], "venue": null, "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2003}], "referenceMentions": [{"referenceID": 9, "context": "These variables have a variety of possible uses, such as the representation of hard or soft constraints [10].", "startOffset": 104, "endOffset": 108}, {"referenceID": 29, "context": "Even when the graph designer does not specify deterministic variables, methods have been developed to discover these factorizations [31].", "startOffset": 132, "endOffset": 136}, {"referenceID": 9, "context": "Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].", "startOffset": 116, "endOffset": 138}, {"referenceID": 12, "context": "Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].", "startOffset": 116, "endOffset": 138}, {"referenceID": 10, "context": "Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].", "startOffset": 116, "endOffset": 138}, {"referenceID": 6, "context": "Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].", "startOffset": 116, "endOffset": 138}, {"referenceID": 18, "context": "Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].", "startOffset": 116, "endOffset": 138}, {"referenceID": 2, "context": "Their usefulness has prompted a body of research on efficient calculations in mixed deterministic/stochastic graphs [10, 13, 11, 7, 20, 3].", "startOffset": 116, "endOffset": 138}, {"referenceID": 20, "context": "Computing exact probabilistic quantities can be done using a junction tree [22, 27], as a search procedure [3, 10], or using a hybrid scheme [10].", "startOffset": 75, "endOffset": 83}, {"referenceID": 25, "context": "Computing exact probabilistic quantities can be done using a junction tree [22, 27], as a search procedure [3, 10], or using a hybrid scheme [10].", "startOffset": 75, "endOffset": 83}, {"referenceID": 2, "context": "Computing exact probabilistic quantities can be done using a junction tree [22, 27], as a search procedure [3, 10], or using a hybrid scheme [10].", "startOffset": 107, "endOffset": 114}, {"referenceID": 9, "context": "Computing exact probabilistic quantities can be done using a junction tree [22, 27], as a search procedure [3, 10], or using a hybrid scheme [10].", "startOffset": 107, "endOffset": 114}, {"referenceID": 9, "context": "Computing exact probabilistic quantities can be done using a junction tree [22, 27], as a search procedure [3, 10], or using a hybrid scheme [10].", "startOffset": 141, "endOffset": 145}, {"referenceID": 16, "context": "All exact inference methods in one way or another explicitly or at least implicitly define at least one graph triangulation [17], and many modern techniques can take advantage of a \u201cgood\u201d triangulation.", "startOffset": 124, "endOffset": 128}, {"referenceID": 20, "context": "A common measure of triangulation quality is the size of the clique potentials formed in traditional junction tree message passing, usually called the state space or weight [22, 19, 32].", "startOffset": 173, "endOffset": 185}, {"referenceID": 17, "context": "A common measure of triangulation quality is the size of the clique potentials formed in traditional junction tree message passing, usually called the state space or weight [22, 19, 32].", "startOffset": 173, "endOffset": 185}, {"referenceID": 30, "context": "A common measure of triangulation quality is the size of the clique potentials formed in traditional junction tree message passing, usually called the state space or weight [22, 19, 32].", "startOffset": 173, "endOffset": 185}, {"referenceID": 15, "context": "Methods such as zero compression [16] and constraint propagation [12, 3, 20] can be used to exploit this, but the costs of queries on such a distribution are difficult to determine without actually performing the computation.", "startOffset": 33, "endOffset": 37}, {"referenceID": 11, "context": "Methods such as zero compression [16] and constraint propagation [12, 3, 20] can be used to exploit this, but the costs of queries on such a distribution are difficult to determine without actually performing the computation.", "startOffset": 65, "endOffset": 76}, {"referenceID": 2, "context": "Methods such as zero compression [16] and constraint propagation [12, 3, 20] can be used to exploit this, but the costs of queries on such a distribution are difficult to determine without actually performing the computation.", "startOffset": 65, "endOffset": 76}, {"referenceID": 18, "context": "Methods such as zero compression [16] and constraint propagation [12, 3, 20] can be used to exploit this, but the costs of queries on such a distribution are difficult to determine without actually performing the computation.", "startOffset": 65, "endOffset": 76}, {"referenceID": 21, "context": "Here we consider arbitrary deterministic functions (other techniques exist for certain classes of functions, such as sums [23]).", "startOffset": 122, "endOffset": 126}, {"referenceID": 1, "context": "The treewidth of a triangulated graph [2] is the size of its largest maximal clique minus 1.", "startOffset": 38, "endOffset": 41}, {"referenceID": 26, "context": "Vertex elimination [28, 8, 9] is an algorithm that can be used to triangulate graphs.", "startOffset": 19, "endOffset": 29}, {"referenceID": 7, "context": "Vertex elimination [28, 8, 9] is an algorithm that can be used to triangulate graphs.", "startOffset": 19, "endOffset": 29}, {"referenceID": 8, "context": "Vertex elimination [28, 8, 9] is an algorithm that can be used to triangulate graphs.", "startOffset": 19, "endOffset": 29}, {"referenceID": 26, "context": "The deficiency [28] of a vertex v in G is: DG(v) =", "startOffset": 15, "endOffset": 19}, {"referenceID": 26, "context": "The elimination graph, denoted as \u03be\u03b1(G), is the original graph G with the addition of any edges added at each step in the elimination process (see [28], MTE(G;\u03b1)).", "startOffset": 147, "endOffset": 151}, {"referenceID": 23, "context": "(a) (b) Figure 1: Triangulation (b) of (a) impossible with elimination [25] All elimination graphs are triangulated [28], and a graph is triangulated if and only if it has a perfect elimination ordering [28, Theorem 1].", "startOffset": 71, "endOffset": 75}, {"referenceID": 26, "context": "(a) (b) Figure 1: Triangulation (b) of (a) impossible with elimination [25] All elimination graphs are triangulated [28], and a graph is triangulated if and only if it has a perfect elimination ordering [28, Theorem 1].", "startOffset": 116, "endOffset": 120}, {"referenceID": 23, "context": "Some triangulations of a graph can not be generated via any elimination order ([25] and Figure 1).", "startOffset": 79, "endOffset": 83}, {"referenceID": 23, "context": "Elimination can, however, create any minimal triangulation [25]:", "startOffset": 59, "endOffset": 63}, {"referenceID": 1, "context": "The choice of triangulation can make an exponential difference in the time and memory needed for inference and finding an optimal one is NP-hard [2, 32], so heuristic search methods must be used.", "startOffset": 145, "endOffset": 152}, {"referenceID": 30, "context": "The choice of triangulation can make an exponential difference in the time and memory needed for inference and finding an optimal one is NP-hard [2, 32], so heuristic search methods must be used.", "startOffset": 145, "endOffset": 152}, {"referenceID": 17, "context": "Many search methods exist, and are often based on choosing an ordering of the nodes for vertex elimination [18, 19, 24, 28].", "startOffset": 107, "endOffset": 123}, {"referenceID": 22, "context": "Many search methods exist, and are often based on choosing an ordering of the nodes for vertex elimination [18, 19, 24, 28].", "startOffset": 107, "endOffset": 123}, {"referenceID": 26, "context": "Many search methods exist, and are often based on choosing an ordering of the nodes for vertex elimination [18, 19, 24, 28].", "startOffset": 107, "endOffset": 123}, {"referenceID": 5, "context": "Most heuristics that do not involve elimination (such as [6, 26]) will choose minimal triangulations over non-minimal triangulations.", "startOffset": 57, "endOffset": 64}, {"referenceID": 24, "context": "Most heuristics that do not involve elimination (such as [6, 26]) will choose minimal triangulations over non-minimal triangulations.", "startOffset": 57, "endOffset": 64}, {"referenceID": 6, "context": "The reason is that it can be shown that many of the metrics of performance are upper bounded in some exponential function on w, the inherent treewidth of the graph [7, 13].", "startOffset": 164, "endOffset": 171}, {"referenceID": 12, "context": "The reason is that it can be shown that many of the metrics of performance are upper bounded in some exponential function on w, the inherent treewidth of the graph [7, 13].", "startOffset": 164, "endOffset": 171}, {"referenceID": 10, "context": "In such a scheme one might want to increase clique size to reduce separator size and, in turn, reduce memory requirements (at the cost of more time) [11].", "startOffset": 149, "endOffset": 153}, {"referenceID": 0, "context": "Also see [1] where large cliques are used to reduce junction tree clique degree.", "startOffset": 9, "endOffset": 12}, {"referenceID": 17, "context": "Many papers attempt to minimize state space by searching over elimination orders [19, 24] implying that this theorem has been assumed in the past, but we have not found a published proof in the literature.", "startOffset": 81, "endOffset": 89}, {"referenceID": 22, "context": "Many papers attempt to minimize state space by searching over elimination orders [19, 24] implying that this theorem has been assumed in the past, but we have not found a published proof in the literature.", "startOffset": 81, "endOffset": 89}, {"referenceID": 1, "context": "It was proven in [2] that it is NP-complete to determine whether a graph has treewidth \u2264 k.", "startOffset": 17, "endOffset": 20}, {"referenceID": 30, "context": "It was proven in [32] that finding optimal state space triangulations in graphical models with binary variables is NP-hard through a reduction from the Elimination Degree SeAlgorithm 1 isEliminationGraph", "startOffset": 17, "endOffset": 21}, {"referenceID": 3, "context": "In certain contexts there might be neighbors from other sources as well, such as DBN frame boundaries [4] or the creation of cliques for the analysis of posteriors or MAP calculations.", "startOffset": 102, "endOffset": 105}, {"referenceID": 14, "context": "This parameter is similar to the Stochastic-Greedy Algorithm given in [15].", "startOffset": 70, "endOffset": 74}, {"referenceID": 9, "context": "Our probability computation engine is hybrid inference/search [10] where message passing is done over the junction tree and search is done within a clique.", "startOffset": 62, "endOffset": 66}, {"referenceID": 4, "context": "Aurora Decoding: whole word model for speech recognition, [5].", "startOffset": 58, "endOffset": 61}, {"referenceID": 13, "context": "Edit Distance training 1, 2, decoding: learns edit distance parameters from data [14].", "startOffset": 81, "endOffset": 85}, {"referenceID": 31, "context": "Mandarin: speech recognition graph modeling tonal phones using asynchronous feature streams [33].", "startOffset": 92, "endOffset": 96}, {"referenceID": 32, "context": "MultiStream: speech recognition training graph with asynchronous feature streams based on [34].", "startOffset": 90, "endOffset": 94}, {"referenceID": 3, "context": "This because the cliques that are necessarily formed when partitioning the DBNs can account for a majority of the compute time and make the graphs fairly dense to begin with (see [4]).", "startOffset": 179, "endOffset": 182}, {"referenceID": 23, "context": "The following lemma is assumed by [25] but never proven:", "startOffset": 34, "endOffset": 38}, {"referenceID": 27, "context": "\u201d |F | < |V |, testing if G = (V,E \u222aF ) is triangulated is \u2208 P [29, 30].", "startOffset": 63, "endOffset": 71}, {"referenceID": 28, "context": "\u201d |F | < |V |, testing if G = (V,E \u222aF ) is triangulated is \u2208 P [29, 30].", "startOffset": 63, "endOffset": 71}, {"referenceID": 1, "context": "MAXTREEWIDTH = {\u3008G = (V,E), k\u3009 | G has treewidth \u2264 k }, is NP-complete [2].", "startOffset": 71, "endOffset": 74}], "year": 0, "abstractText": "We observe that certain large-clique graph triangulations can be useful for reducing computational requirements when making queries on mixed stochastic/deterministic graphical models. We demonstrate that many of these largeclique triangulations are non-minimal and are thus unattainable via the elimination algorithm. We introduce ancestral pairs as the basis for novel triangulation heuristics and prove that no more than the addition of edges between ancestral pairs need be considered when searching for state space optimal triangulations in such graphs. Empirical results on random and real world graphs are given. We also present an algorithm and correctness proof for determining if a triangulation can be obtained via elimination, and we show that the decision problem associated with finding optimal state space triangulations in this mixed setting is NP-complete.", "creator": null}}}