{"id": "1207.6713", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Jul-2012", "title": "Model-Lite Case-Based Planning", "abstract": "There is increasing awareness in the planning community that depending on complete models impedes the applicability of planning technology in many real world domains where the burden of specifying complete domain models is too high. In this paper, we consider a novel solution for this challenge that combines generative planning on incomplete domain models with a library of plan cases that are known to be correct. While this was arguably the original motivation for case-based planning, most existing case-based planners assume (and depend on) from-scratch planners that work on complete domain models. In contrast, our approach views the plan generated with respect to the incomplete model as a \"skeletal plan\" and augments it with directed mining of plan fragments from library cases. We will present the details of our approach and present an empirical evaluation of our method in comparison to a state-of-the-art case-based planner that depends on complete domain models. The analysis is based on an extended model definition, a subset of which are available in this paper.", "histories": [["v1", "Sat, 28 Jul 2012 17:00:01 GMT  (193kb)", "http://arxiv.org/abs/1207.6713v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["hankz hankui zhuo", "tuan anh nguyen 0001", "subbarao kambhampati"], "accepted": true, "id": "1207.6713"}, "pdf": {"name": "1207.6713.pdf", "metadata": {"source": "CRF", "title": "Model-Lite Case-Based Planning", "authors": ["Hankz Hankui Zhuo", "Tuan Nguyen"], "emails": ["zhuohank@mail.sysu.edu.cn", "rao@asu.edu", "natuan@asu.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 7.\n67 13\nv1 [\ncs .A\nI] 2\n8 Ju\nl 2 01\n2"}, {"heading": "Introduction", "text": "Most work in planning assumes that complete domain models are given as input in order to synthesize plans. However, there is increasing awareness that building domain models at any level of completeness presents steep challenges for domain creators. Indeed, recent work in web-service composition (c.f. (Bertoli, Pistore, and Traverso 2010; Hoffmann, Bertoli, and Pistore 2007)) and work-flow management (c.f. (Blythe, Deelman, and Gil 2004)) suggest that dependence on complete models can well be the real bottle-neck inhibiting applications of current planning technology.\nThere has thus been interest in the so-called \u201cmodel-lite\u201d planning approaches (c.f. (Kambhampati 2007)) that aim to synthesize plans even in the presence of incomplete domain models. The premise here is that while complete models cannot be guaranteed, it is often possible for the domain experts to put together reasonable but incomplete models. The challenge then is to work with these incomplete domain models, and yet produce plans that have a high chance of success with respect to the \u201ccomplete\u201d (but unknown) domain model. This is only possible if the planner has access to additional sources of knowledge besides the incomplete domain model.\nCopyright c\u00a9 2012, All rights reserved.\nInterestingly, one of the original motivations for casebased planning was also the realization that in many domains complete domain models are not available. Over years however, case-based planning systems deviated from this motivation and focused instead on \u201cplan reuse\u201d where the motivation is to improve the performance of a planner operating with a complete domain model. In this paper, we return to the original motivation by considering \u201cmodel-lite casebased planning.\u201d In particular, we consider plan synthesis when the planner has an incomplete domain theory, but has access to a library of plans that \u201cworked\u201d in the past. This plan library can thus be seen as providing additional knowledge of the domain over and above the incomplete domain theory.\nOur task is to effectively bring to bear this additional knowledge on plan synthesis to improve the correctness of the plans generated. We take a two stage process. First, we use the incomplete domain model to synthesize a \u201cskeletal\u201d plan. Next, with the skeletal plan in hand, we \u201cmine\u201d the case library for fragments of plans that can be spliced into the skeletal plan to increase its correctness. The plan improved this way is returned as the best-guess solution to the original problem. We will describe the details of our framework, called ML-CBP and present a systematic empirical evaluation of its effectiveness. We compare the effectiveness of our model-lite case-based planner with OAKPlan (Serina 2010), the current state-of-the-art model-complete case-based planner.\nWe organize the paper as follows. We first review related work, and then present the formal details of our framework. After that, we give a detailed description of ML-CBP algorithm. Finally, we evaluate ML-CBP in three planning domains, and compare its performance to OAKPlan."}, {"heading": "Related Work", "text": "As the title implies, our work is related both to casebased planning and model-lite planning. As mentioned in the introduction, our work is most similar to the spirit of original case-based planning systems such as CHEF (Hammond 1989) and PLEXUS (Alterman 1986), which viewed the case library as an extensional representation of the domain knowledge. CHEF\u2019s use of case modification rules, for example, serves a similar purpose as our use of incomplete domain models. Our work however differs from CHEF in two ways. First, unlike us, CHEF as-\nsumes access to a (more) complete domain model during its debugging stage. Second, CHEF tries to adapt a specific case to the problem at hand, while our work expands a skeletal plan with relevant plan fragments mined from multiple library plans. The post-CHEF case-based planning work largely focused on having access to a fromscratch planner operating on complete domain models (c.f. (Kambhampati and Hendler 1992; Veloso et al. 1995)). The most recent of this line of work is OAKPlan (Serina 2010), which we compare against.\nThe recent focus on planning with incomplete domain models originated with the work on \u201cmodel-lite planning\u201d (Kambhampati 2007). Approaches for model-lite planning must either consider auxiliary knowledge sources or depend on long-term learning. While our work views the caselibrary as the auxiliary knowledge source, work by Nguyen et al. (Nguyen, Kambhampati, and Do 2010) and Weber et. al. (Bryce and Weber 2011) assume that domain writers are able to provide annotations about missing preconditions and effects. It would be interesting to see if these techniques can be combined with ours. One interesting question, for example, is whether the case library can be compiled over time into such possible precondition/effect annotations.\nA third strand of research that is also related to our work is that of action model learning. Work such as (Yang, Wu, and Jiang 2007; Zhuo et al. 2010; Zettlemoyer, Pasula, and Kaelbling 2005) focuses on learning action models directly from observed (or pre-specified) plan traces. The connection between this strand of work and our work can be seen in terms of the familiar up-front vs. demand-driven knowledge transfer: the learning methods attempt to condense the case library directly into STRIPS models before using it in planning, while we transfer knowledge from cases on a per-problem basis. Finally, in contrast, work such as (Amir 2005), as well as much of the reinforcement learning work (Sutton and Barto 1998) focuses on learning models from trial-and-error execution1. This too can be complementary to our work in that execution failures can be viewed as opportunities to augment the case-library (c.f. (Ihrig and Kambhampati 1997))."}, {"heading": "Problem Definition", "text": "A planning problem can be described as a triple P = (\u03a3, s0, g), where s0 is an initial state, g is a goal, and \u03a3 is defined by \u03a3 = (S,A, \u03b3), where S is a set of states, A is a set of action models, and \u03b3 is a transition function defined by \u03b3 : S \u00d7 A \u2192 S. A solution to a planning problem is an action sequence (or a plan) denoted by (a1, a2, . . . , an), where ai is an action. An action model is defined as (a, PRE(a),ADD(a),DEL(a)), where a is an action name with zero or more parameters, PRE(a) is a precondition list specifying the condition under which a can be applied, ADD(a) is an adding list and DEL(a) is a deleting list indicating the effects of a. Notice that we focus on the STRIPS action model description (Fikes and Nilsson 1971) in this paper. An action model a is called \u201cincomplete\u201d when there are predicates missing in PRE(a), ADD(a), or DEL(a). A set of incomplete action models is denoted by\n1This latter has to in general be limited to ergodic domains\nA\u0303. An incomplete planning problem is denoted by P\u0303 = \u3008s0, g, A\u0303\u3009. A plan example p is composed by an initial state, a goal and an action sequence that transits the initial state and the goal, i.e., p = \u3008s0, a1, . . . , an, g\u3009, where s0 is the initial state, ai is an action, and g is the goal. We denote a set of plan examples by E.\nOur planning problem in this paper is defined by: given as input a quadruple \u3008s0, g, A\u0303, E\u3009, where s0 is an initial state, and g a goal, as described above, A\u0303 is a set of incomplete action models, and E is a plan example set, our ML-CBP algorithm outputs a solution that transits s0 and g.\nAn example input of our planning problem in blocks2 domain is shown in Figure 1, which is composed of three parts: incomplete action models (Figure 1(a)), an initial state s0 and a goal g (Figure 1(b)), and a plan example set (Figure 1(c)). In Figure 1(a), the dark parts indicate the missing predicates. In Figure 1(c), p1 and p2 are two plan examples, where initial states and goals are bracketed. An example output is a solution to the planning problem given in Figure 1, i.e., \u201cunstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C)\u201d.\nOur ML-CBP Algorithm\nAlgorithm 1 Our ML-CBP algorithm\nInput: P\u0303 = \u3008s0, g, A\u0303\u3009, and a set of plan examples E. Output: the plan psol for solving the problem.\n1: generate a set of causal pairs l with P\u0303 ; 2: build a set of plan fragments \u03d5: \u03d5=build fragments(l, E); 3: mine a set of frequent plan fragments F : F=freq mining(\u03d5); 4: psol = \u2205; 5: if concat frag(psol, l, F , P\u0303 ) = true then 6: return psol; 7: else 8: return NULL; 9: end if\nAn overview of our ML-CBP algorithm can be found in Algorithm 1. We first generate a skeletal plan, presented by a set of causal pairs, based on \u3008s0, g, A\u0303\u3009. After that, we build a set of plan fragments based on plan examples and causal pairs, and then mine a set of frequent plan fragments with a specific threshold. These frequent fragments will be integrated together to form the final solution psol based on causal pairs. Next, we describe each step in detail."}, {"heading": "Generate causal pairs", "text": "Given the initial state s0 and goal g, we generate a set of causal pairs l. A causal pair is an action pair \u3008ai, aj\u3009 that ai provides one or more conditions for aj . The procedure to generate l is shown in Algorithm 2. Note that, in step 3 of Algorithm 2, l\u2032 is an empty set if p cannot be achieved. In other words, skeletal plans may not provide any guidance for some top level goals. Actions in causal pairs l is viewed\n2http://www.cs.toronto.edu/aips2000/\nAlgorithm 2 Generate causal pairs\ninput: initial state s0, goal g, incomplete action models A\u0303. output: a set of causal pairs l.\n1: l = \u2205; 2: for each proposition p \u2208 g do 3: generate a plan, denoted by a set of causal pairs l\u2032, to transit s0 to p; 4: l = l \u222a l\u2032; 5: end for 6: return l;\nas a set of landmarks for helping construct the final solution, as will be seen in the coming sections. We show an example of the generated causal pairs in Example 1. Example 1: As an example, causal pairs generated for the planning problem given in Figure 1 is {\u3008pickup(B),stack(B A)\u3009, \u3008 unstack(C A), stack(C B)\u3009, \u3008 pickup(D), stack(D C)\u3009}."}, {"heading": "Creating Plan Fragments", "text": "In the procedure \u201cbuild fragments\u201d of Algorithm 1, we would like to build a set of plan fragments \u03d5 by building mappings between \u201cobjects\u201d in \u3008s0, g\u3009 of P\u0303 and \u3008si0, g\ni\u3009 of a plan example pi \u2208 E. In other words, a mapping, denoted by m, is composed of a set of pairs {\u3008o\u2032, o\u3009}, where o\u2032 is an object (i.e., an instantiated parameter) from plan example pi, and o is an object from P\u0303 . We can apply mapping m to a plan example pi, whose result is denoted by pi|m, such that si 0 |m and s0 share common propositions, likewise for gi and g. We measure a mapping m by the number of propositions shared by initial states si\n0 |m and s0, and goals gi and g. We\ndenote the number of shared propositions by \u03bb(pi,m), i.e.,\n\u03bb(pi,m) = |(s i 0|m) \u2229 s0|+ |(g i|m) \u2229 g|.\nAn example to demonstrate how to calculate \u03bb is given as follows. Example 2: In Figure 1, a possible mapping m between \u3008s0, g\u3009 and \u3008s10, g\n1\u3009 of p1 is {\u3008b4, D\u3009, \u3008b1, C\u3009, \u3008b3, B\u3009, \u3008b2, A\u3009}. The result of applying m to s1\n0 is s1 0 |m={(clear C)(clear A)(clear\nB)(clear D)(ontable C)(ontable A)(ontable B)(ontable D)(handempty)}. Likewise, we can calculate the result of applying m to g1. It is not difficult to see that \u03bb(p1,m) = |(s 1 0|m) \u2229 s0|+ |(g 1|m) \u2229 g| = 10.\nIt is possible that there are many different mappings between P\u0303 and pi. We choose a mappingm\u2217 with the largest \u03bb to maximally map pi to P\u0303 , i.e., m\u2217 = argmaxm \u03bb(pi,m). We assume that all propositions are \u201cequally\u201d important in describing states. The more common propositions P\u0303 and pi share, the more \u201csimilar\u201d they are. Note that mappings between objects of the same types are subject to the constraint that they should have the set of \u201cfeatures\u201d in the domain, defined by unary predicates of the corresponding types. For instance, \u201cb3\u201d can be mapped to \u201cB\u201d in our running example since both of them are the two blocks having the same features \u201con table\u201d and \u201cclear\u201d in the two problems. In practice, we find that this requirement significantly reduces the amount of mappings that need to be considered, actually allowing us to find m\u2217 in a reasonable running time.\nWe apply m\u2217 to pi to get a new plan example pi|m\u2217 , which is denoted by (ai\n1 , ai 2 , . . . , ain). We scan the action\nsequence from a1 to an to get subsequences that satisfies the constraint that all the objects in the subsequences should be in P\u0303 . We call these subsequences plan fragments. We can build a set of plan fragments using plan examples E. Example 3: In Example 2, we find that m\u2217 = {\u3008b4, D\u3009, \u3008b1, C\u3009, \u3008b3, B\u3009, \u3008b2, A\u3009}. Thus, p1|m\u2217 is \u201cpickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C)\u201d, which is a plan fragment. For p2 in Figure 1, m\u2217 is {\u3008b3, C\u3009, \u3008b1, B\u3009, \u3008b2, A\u3009}. Thus, p2|m\u2217 is \u201cunstack(B C) putdown(B) unstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B)\u201d, which is also a plan fragment."}, {"heading": "Mining Frequent Plan Fragments", "text": "In step 3 of Algorithm 1, we aim at building a set of frequent plan fragments F using the procedure \u201cfreq mining\u201d. Given that there will not be any function perfectly mapping the two planning problems, our intuition is that a plan fragment occurring multiple times in different plan examples increases\nour confidence on both the quality of the mapping between objects involved and the success of reusing the fragment as part of a solution plan for the problem being solved. We thus borrow the notion of frequent patterns defined in (Zaki 2001; Pei et al. 2004) to use for mining our frequent plan fragments. The problem of mining sequential patterns can be stated as follows. Let I = {i1, i2, . . . , in} be a set of n items. We call a subset X \u2286 I an itemset and |X | the size of X . A sequence is an ordered list of itemsets, denoted by s = \u3008s1, s2, . . . , sm\u3009, where sj is an itemset. The size of a sequence is the number of itemsets in the sequence, i.e., |s| = m. The length l of a sequence s = (s1, s2, . . . , sm) is defined as l = \u2211m i=1 |si|. A sequence sa = (a1, a2, . . . , an) is a subsequence of another sequence sb = (b1, b2, . . . , bm) if there exist integers 1 \u2264 i1 < i2 < . . . < in \u2264 m such that a1 \u2286 bi1 , a2 \u2286 bi2 , . . . , an \u2286 bin , denoted by sa \u2291 sb. A sequence database S is a set of tuples \u3008sid, s\u3009, where sid is a sequenceid and s is a sequence. A tuple \u3008sid, s\u3009 is said to contain a sequence a, if a is a subsequence of s. The support of a sequence a in a sequence database S is the number of tuples in the database containing a, i.e.,\nsupS(a) = |{\u3008sid, s\u3009|(\u3008sid, s\u3009 \u2208 S) \u2229 (a \u2291 s)}|.\nGiven a positive integer \u03b4 as the support threshold, we call a a frequent sequence if supS(a) \u2265 \u03b4. Given a sequence database and the support threshold, frequent sequential pattern mining problem is to find the complete set of sequential patterns whose support is larger than the threshold.\nWe view each action of plan fragments as an itemset, and a plan fragment as a sequence, which suggests plan fragments can be viewed as a sequence database. Note that in our case an itemset has only one element, and the indices of those in the subsequence are continuous. We fix a threshold \u03b4 and use the SPADE algorithm (Zaki 2001) to mine a set of frequent patterns. There are many frequent patterns which are subsequences of other frequent patterns. We eliminate these \u201csubsequences\u201d and keep the \u201dmaximal\u201d patterns, i.e., those with the longest length, as the final set of frequent plan fragments F . Example 4: In Example 3, if we set \u03b4 to be 2 and 1, the results are shown below (frequent plan fragments are partitioned by commas):\nplan fragments: 1. pickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C) 2. unstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B) frequent plan fragments F (\u03b4 = 2): {pickup(B) stack(B A) pickup(C) stack(C B)} frequent plan fragments F (\u03b4 = 1): {pickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C), unstack(B C)putdown(B)unstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B)}\nNote that the following frequent patterns are eliminated when \u03b4 = 2 (likewise when \u03b4 = 1): {pickup(B), stack(B A), pickup(C), stack(C B), pickup(B) stack(B A), stack(B A) pickup(C), pickup(C) stack(C B), pickup(B) stack(B A) pickup(C), stack(B A) pickup(C) stack(C B)}."}, {"heading": "Generating Final Solution", "text": "In steps 4-6 of Algorithm 1, we generate the final solution using frequent plan fragments generated by step 3. We address the procedure concat frag by Algorithm 3. In Algorithm 3, we scan each causal pair in l and each frequent plan fragment in F ; if a plan fragment contains an action (or both actions) of a causal pair, we append the plan fragment to the final solution psol and remove all the causal pairs that are satisfied by the new psol; and then recursively call the procedure concat frag until the solution is found, i.e., l = \u2205, or no solution is found, i.e., the procedure returns false (l 6= \u2205).\nAlgorithm 3 concat frag(psol, l, F ,P\u0303 );\ninput: a plan psol, a set of causal pairs l, a set of frequent plan fragments F , and an incomplete problem; output: true or false.\n1: if l = \u2205 then 2: psol = remove first actions(psol, P\u0303 ); 3: psol = remove last actions(psol, P\u0303 ); 4: if psol is executable based on P\u0303 then 5: return true; 6: else 7: return false; 8: end if 9: end if\n10: for each pair \u3008ai, aj\u3009 \u2208 l and each f \u2208 F do 11: if (ai \u2208 f \u2228 aj \u2208 f ) and share(psol, f ) =true then 12: psol \u2032\n=append(psol, f ); 13: l\u2032=removelinks(psol \u2032\n, l); 14: F \u2032 \u2190 F \u2212 {f}; 15: if concat frag(psol \u2032\n, l\u2032, F ,P\u0303 ) =true then 16: return true; 17: end if 18: end if 19: end for 20: return false\nIn step 2 of Algorithm 3, we repeatedly remove the first action of psol that cannot be applied in s0. In step 3 of Algorithm 3, we repeatedly remove the last action of psol that deletes propositions of goal g. After steps 2 and 3, the remainder plan can be executed from s0 to g using A\u0303, then the algorithm returns true, otherwise, returns false. In step 11 of Algorithm 3, the procedure share returns true if psol is empty or psol and f share a common action subsequence. That is to say, two plan fragments are concatenated only if they have some sort of connection, which is indicated by common action subsequence. In step 12 of Algorithm 3, we concatenate psol and f based on their maximal common action subsequence, which is viewed as the strongest connection between them. Note that the common action subsequence should start from the beginning of psol OR end at the end of psol. In other words, f can be concatenated at the end of psol or at the beginning, as is shown in Figure 2. In step 13 of Algorithm 3, the procedure removelinks remove all causal pairs in l that are \u201csatisfied\u201d by psol. The result is denoted by l\u2032. Example 5 demonstrates how to generate final solutions.\nExample 5: In Example 4, we have two frequent plan fragments by setting \u03b4 = 1. We concatenate these two fragments together. The result is shown as follows. The boldfaced part is the actions shared by fragments 1 an d 2. The concatenating result is shown in the third row. After concatenating, we can see that all the causal pairs in l is satisfied and will be removed according to step 13 of Algorithm 3. Furthermore, according to steps 2 and 3 of Algorithm 3, the first two actions are removed since they cannot be applied in s0, and no action is removed at the end of the plan since no action deletes propositions of g. The result is shown in the fourth row. The result is executable from s0 to g, which means it is the final solution.\nfragment 1: pickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C) fragment 2: unstack(B C) putdown(B) unstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B) result: unstack(B C) putdown(B) unstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C) solution: unstack(C A) putdown(C) pickup(B) stack(B A) pickup(C) stack(C B) pickup(D) stack(D C)"}, {"heading": "Experiments", "text": ""}, {"heading": "Dataset and Criterion", "text": "We evaluate our ML-CBP algorithm in three planning domains: blocks2, driverlog3 and depots3. In each domain, we generate from 40 to 200 plan examples using a classical planner such as FF planner4 and solve 100 new planning problems based on different percentages of completeness of domain models. For example, we use 4\n5 to indicate one pred-\nicate is missing among five predicates of the domain. We define the accuracy of our ML-CBP algorithm as the percentage of correctly solved planning problems. Specifically, we exploit ML-CBP to generate a solution to a planning problem, and execute the solution from the initial state to the goal. If the solution can be successfully executed starting from the initial state, and the goal is achieved, then the number of correctly solved problems is increased by one.\n3http://planning.cis.strath.ac.uk/competition/ 4http://members.deri.at/\u223cjoergh/ff.html\nThe accuracy, denoted by \u03bb, can be computed by \u03bb = Nc Nt , where Nc is the number of correctly solved problems, and Nt is the number of total testing problems. Note that when testing the accuracy of ML-CBP, we assume that we have complete domain models available for executing generated solutions. It is easy to see that the larger the accuracy \u03bb is, the better our ML-CBP algorithm functions."}, {"heading": "Experimental Results", "text": "We would like to evaluate ML-CBP in the following aspects: (1) the change of accuracies with respect to different number of plan examples; (2) the change of accuracies with respect to different percentages of completeness; (3) the change of accuracies with respect to different support threshold \u03b4; (4) the average of plan lengths; (5) the running time of ML-CBP. We compared our ML-CBP algorithm with the state-of-the-art CBP (Case Based Planning) system OAKPlan (Serina 2010). OAKPlan requires a complete domain model and a case library as input for a new planning problem. To make OAKPlan be comparable with our ML-CBP algorithm, we fed an incomplete domain model to OAKPlan, which was the same as the input of ML-CBP, instead of an complete domain model.\nVarying the number of plan examples We would like to test the change of the accuracy when the number of plan examples increasing. We set the percentage of completeness as 60%, and the threshold \u03b4 as 15. We varied the number of plan examples from 40 to 200 and run ML-CBP to solve 100 planning problems. We calculated the accuracy \u03bb for each case. The result is shown in Figure 3.\nFrom Figure 3, we found that both accuracies of ML-CBP and OAKPlan generally became larger when the number of plan examples increased. This is consistent with our intuition, since there is more knowledge to be used when plan examples become larger. On the other hand, we also found that ML-CBP generally had higher accuracy than OAKPlan in all the three domains. This is because ML-CBP exploits the information of incomplete domain models to mine multiple high quality plan fragments, i.e., ML-CBP integrates the knowledge from both incomplete domain models and plan examples, which may help each other, to attain the final solution. In contrast, OAKPlan first retrieves a case, and then adapts the case using the inputted incomplete domain model, which may fail to make use of valuable information from other cases (or plan fragments) when adapting the case.\nBy observation, we found that the accuracy of ML-CBP was no less than 0.8 when the number of plan examples was more than 160.\nVarying the percentage of completeness To test the change of accuracies with respect to different degrees of completeness, we varied the percentage of completeness from 20% to 100%, and ran ML-CBP with 200 plan examples by setting \u03b4 = 15. We also compared the accuracy with OAKPlan. The result is shown in Figure 4.\nWe found both accuracies of ML-CBP and OAKPlan increased when the percentage of completeness increased, due to more information provided when the percentage increasing. When the percentage is 100%, both ML-CBP and OAKPlan can solve all the solvable planning problems successfully. Similar to Figure 3, ML-CBP functions better than OAKPlan. The reason is similar to Figure 3, i.e., simultaneously exploiting both knowledge from incomplete domain models and plan examples could be helpful.\nBy observing all three domains in Figure 4, we found that ML-CBP functioned much better when the percentage was smaller. This indicates that exploiting multiple plan fragments, as ML-CBP does, plays a more important role when the percentage is smaller. OAKPlan does not consider this factor, i.e., it still retrieves only one case.\nAverage of plan length We calculated an average of plan length for all problems successfully solved by ML-CBP when \u03b4 was 15, the percentage of completeness was 60%, and 200 plan examples were used. As a baseline, we exploited FF to solve the same problems using the corresponding complete domain models and calculate an average of their plan length. The result is shown in Table 1.\nFrom Table 1, we found that the plan length of ML-CBP was larger than FF in some cases, such as blocks and driverlog. However, it was also possible that ML-CBP had shorter plans than FF (e.g., depots), since high quality plan fragments could help acquire shorter plans.\nVarying the support threshold We tested different support thresholds to see how they affected the accuracy. We set the completeness to be 60%. The result is shown in Table 2. The bold parts indicate the highest accuracies. We found that the threshold could not be too high or too low, as was shown in domains blocks and driverlog. A high threshold\nmay incur false negative, i.e., \u201cgood\u201d plan fragments are excluded when mining frequent plan fragments in step 3 of Algorithm 1. In contrast, a low threshold may incur false positive, i.e., \u201cbad\u201d plan fragments are introduced. Both of these two cases may reduce the accuracy. We can see that the best choice for the threshold could be 15 (the accuracies of \u03b4 = 15 and \u03b4 = 25 are close in depots).\nThe running time We show the average CPU time of our ML-CBP algorithm over 100 planning problems with respect to different number of plan examples in Figure 5. As can be seen from the figure, the running time increases polynomially with the number of input plan traces. This can be verified by fitting the relationship between the number of plan examples and the running time to a performance curve with a polynomial of order 2 or 3. For example, the fit polynomial for blocks is \u22120.0022x2 + 1.1007x\u2212 45.2000."}, {"heading": "Conclusion", "text": "In this paper, we presented a system called ML-CBP for doing model-lite case-based planning. ML-CBP is able to integrate knowledge from both incomplete domain models and a library of plan examples to produce solutions to new planning problems. With the incomplete domain models, we first generate a skeletal plan using of-the-shelf planners, and then mine sequential information from plan examples to finally generate solutions. Our experiments show that ML-CBP is effective in three benchmark domains compared to casebased planners that rely on complete domain models. Our approach is thus well suited for scenarios where the planner is limited to incomplete models of the domain, but does have access to a library of plans correct with respect to the complete (but unknown) domain theory. Our work can be seen as a contribution both to model-lite planning, which is interested in plan synthesis under incomplete domain models, and the original vision of case-based planning, which aimed to use a library of cases as an extensional representation of planning knowledge."}], "references": [{"title": "E", "author": ["Amir"], "venue": "2005. Learning partially observable deterministic action models. In Proceedings of IJCAI, 1433\u2013", "citeRegEx": "Amir 2005", "shortCiteRegEx": null, "year": 1439}, {"title": "Automated composition of web services via planning in asynchronous domains", "author": ["Pistore Bertoli", "P. Traverso 2010] Bertoli", "M. Pistore", "P. Traverso"], "venue": "Artificial Intelligence Journal 174(3-4):316\u2013361", "citeRegEx": "Bertoli et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bertoli et al\\.", "year": 2010}, {"title": "Automatically composedworkflows for grid environments", "author": ["Deelman Blythe", "J. Gil 2004] Blythe", "E. Deelman", "Y. Gil"], "venue": "IEEE Intelligent Systems", "citeRegEx": "Blythe et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Blythe et al\\.", "year": 2004}, {"title": "and Weber", "author": ["D. Bryce"], "venue": "C.", "citeRegEx": "Bryce and Weber 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "N", "author": ["R. Fikes", "Nilsson"], "venue": "J.", "citeRegEx": "Fikes and Nilsson 1971", "shortCiteRegEx": null, "year": 1971}, {"title": "K", "author": ["Hammond"], "venue": "J.", "citeRegEx": "Hammond 1989", "shortCiteRegEx": null, "year": 1989}, {"title": "Web service composition as planning, revisited: In between background theoriesandinitial state uncertainty", "author": ["Bertoli Hoffmann", "J. Pistore 2007] Hoffmann", "P. Bertoli", "M. Pistore"], "venue": "Proceedings of AAAI", "citeRegEx": "Hoffmann et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Hoffmann et al\\.", "year": 2007}, {"title": "and Kambhampati", "author": ["L.H. Ihrig"], "venue": "S.", "citeRegEx": "Ihrig and Kambhampati 1997", "shortCiteRegEx": null, "year": 1997}, {"title": "J", "author": ["S. Kambhampati", "Hendler"], "venue": "A.", "citeRegEx": "Kambhampati and Hendler 1992", "shortCiteRegEx": null, "year": 1992}, {"title": "M", "author": ["T.A. Nguyen", "S. Kambhampati", "Do"], "venue": "B.", "citeRegEx": "Nguyen. Kambhampati. and Do 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Mining sequential patterns by pattern-growth: The prefixspan approach", "author": ["Pei"], "venue": "IEEE Transactions on Knowledge and Data Engineering", "citeRegEx": "Pei,? \\Q2004\\E", "shortCiteRegEx": "Pei", "year": 2004}, {"title": "I", "author": ["Serina"], "venue": "2010. Kernel functions for casebased planning. Artificial Intelligence 174(16-17):1369\u2013", "citeRegEx": "Serina 2010", "shortCiteRegEx": null, "year": 1406}, {"title": "A", "author": ["R.S. Sutton", "Barto"], "venue": "G.", "citeRegEx": "Sutton and Barto 1998", "shortCiteRegEx": null, "year": 1998}, {"title": "Learning action models from plan examples using weighted MAX-SAT", "author": ["Wu Yang", "Q. Jiang 2007] Yang", "K. Wu", "Y. Jiang"], "venue": "Artificial Intelligence Journal", "citeRegEx": "Yang et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Yang et al\\.", "year": 2007}, {"title": "M", "author": ["Zaki"], "venue": "J.", "citeRegEx": "Zaki 2001", "shortCiteRegEx": null, "year": 2001}, {"title": "L", "author": ["L.S. Zettlemoyer", "H.M. Pasula", "Kaelbling"], "venue": "P.", "citeRegEx": "Zettlemoyer. Pasula. and Kaelbling 2005", "shortCiteRegEx": null, "year": 2005}, {"title": "L", "author": ["H.H. Zhuo", "Q. Yang", "D.H. Hu", "Li"], "venue": "2010. Learning complex action models with quantifiers and implications. Artificial Intelligence 174(18):1540 \u2013", "citeRegEx": "Zhuo et al. 2010", "shortCiteRegEx": null, "year": 1569}], "referenceMentions": [], "year": 2012, "abstractText": "There is increasing awareness in the planning community that depending on complete models impedes the applicability of planning technology in many real world domains where the burden of specifying complete domain models is too high. In this paper, we consider a novel solution for this challenge that combines generative planning on incomplete domain models with a library of plan cases that are known to be correct. While this was arguably the original motivation for casebased planning, most existing case-based planners assume (and depend on) from-scratch planners that work on complete domain models. In contrast, our approach views the plan generated with respect to the incomplete model as a \u201cskeletal plan\u201d and augments it with directed mining of plan fragments from library cases. We will present the details of our approach and present an empirical evaluation of our method in comparison to a state-of-the-art case-based planner that depends on complete domain models.", "creator": "LaTeX with hyperref package"}}}