{"id": "1208.1692", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Aug-2012", "title": "On Finding Optimal Polytrees", "abstract": "Inferring probabilistic networks from data is a notoriously difficult task. Under various goodness-of-fit measures, finding an optimal network is NP-hard, even if restricted to polytrees of bounded in-degree. Polynomial-time algorithms are known only for rare special cases, perhaps most notably for branchings, that is, polytrees in which the in-degree of every node is at most one. Here, we study the complexity of finding an optimal polytree that can be turned into a branching by deleting some number of arcs or nodes, treated as a parameter. In the first two cases, there is a much faster sequence of branches, with greater complexity, and with less complexity. In these cases, all branches can be separated by any nonlinear gradient in length and thus are more stable in the right direction, making it harder for branches to be separated. In the second case, the trees can be split in two, but if a branch is a tree that is bounded by an interval, its branches can be split in three. The difference in complexity in the first case is in the second case. This process is repeated with a different sequence.\n\nThe first two papers describe how to perform a series of transformations over a set of nodes in the polymath (B&F) branch of the same branch of the same branch. A series of parallel transformations for an ensemble of nodes, with its initial size in each node, is an example of a simple example. It can be written in Haskell, Haskell, and C++, and there are a variety of other Haskell tools that can be used to perform the computation.\nThe first of the first paper describes how to generate multiple sequences in a single monad in the function (L+0). In the second paper, the computation of a monad in a single monad is done in a single monad that is a set of monads with the highest complexity, and can be done on the second monad (i.e., the second monad). In each case, it can be repeated to a sequence of monads (in a single monad). In the third paper, the computation of a monad in a single monad is done in the same monad that is a set of monads in a single monad, and can be done on the second monad that is a set of monads in a single monad. For example, we can consider this with the first monad and the second monad that", "histories": [["v1", "Wed, 8 Aug 2012 15:32:42 GMT  (18kb)", "https://arxiv.org/abs/1208.1692v1", null], ["v2", "Fri, 10 Aug 2012 13:36:15 GMT  (18kb)", "http://arxiv.org/abs/1208.1692v2", "(author's self-archived copy)"]], "reviews": [], "SUBJECTS": "cs.DS cs.AI cs.CC", "authors": ["serge gaspers", "mikko koivisto", "mathieu liedloff", "sebastian ordyniak", "stefan szeider"], "accepted": true, "id": "1208.1692"}, "pdf": {"name": "1208.1692.pdf", "metadata": {"source": "CRF", "title": "On Finding Optimal Polytrees", "authors": ["Serge Gaspers"], "emails": ["gaspers@kr.tuwien.ac.at", "mikko.koivisto@cs.helsinki.fi", "mathieu.liedloff@univ-orleans.fr", "ordyniak@kr.tuwien.ac.at", "stefan@szeider.net"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 8.\n16 92\nv2 [\ncs .D\nS] 1"}, {"heading": "1 Introduction", "text": "There has been extensive research on learning probabilistic networks from data by maximizing some suitable scoring function. Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two.\nGiven the recent advances in exact exponential algorithms in general (see, e.g., the book by Fomin and Kratsch (2010)), and in finding optimal DAGs in particular, it is natural to ask, whether \u201cfast\u201d exponential-time algorithms exist for finding optimal polytrees. For general DAGs the fastest known algorithms run in time within a polynomial factor of 2n, where n is the number of nodes Koivisto and Sood (2004); Ott and Miyano (2003); Parviainen and Koivisto (2009); Silander and Myllyma\u0308ki (2006). However, it is not clear, whether even these bounds can be achieved for polytrees; a brute-force algorithm would visit each polytree one by one, whose num-\nber scales as the number of directed labelled trees nn\u221222n\u22121 Cayley (1889). Do significantly faster algorithms exist? Does the problem become easier if only a small number of nodes are allowed an in-degree larger than one?\nIn this work, we take a first step towards answering these questions by considering polytrees that differ from branchings by only a few arcs. More precisely, we study the problem of finding an optimal k-branching, defined as a polytree that can be turned into a branching by deleting k arcs. We make the standard assumption that the scoring function decomposes into a sum of local scores; see the next section for precise definitions. We note that k-branchings generalize branchings in a different direction than the Tree-augmented Naive Bayes classifier (TAN) due to Friedman, Geiger, and Goldszmidt (1997). Namely, in a TAN the in-degree of each node is at most two, and there is a designated class node of in-degree zero, removing of which leaves a spanning tree; the tree is undirected in the sense that the symmetric conditional mutual information is employed to score arcs.\nPolynomial-time result for k-branchings Our main result is an algorithm that finds an optimal k-branching in polynomial time for every constant k. (See the next section for a formal definition of the problem.) Our overall approach is straightforward: we search exhaustively over all possible sets of at most k \u201cextra arcs\u201d, fix the guessed arcs, and solve the induced optimization problem for branchings. Implementing this seemingly innocent algorithm, however, requires successful treatment of certain complications that arise when applying the existing matroid machinery for finding optimal branchings. In particular, one needs to control the interaction of the extra arcs with the solution from the induced subproblem.\nFixed-parameter tractability Our algorithm for the k-branching is polynomial for fixed k, but the degree of the polynomial depends on k, hence the algorithm does not scale well in k. We therefore investigate variants of the k-branching problem that admit fixed-parameter tractability in the sense of Downey and Fellows (1999): the running time bound is given by a polynomial whose degree is independent of the parameter, the parameter contributing a constant factor to the bound.\nIn particular, we show that the k-branching problem is fixed-parameter tractable if the set of arcs incident to nodes with more than one parent form a connected polytree with exactly one sink, and each node has a bounded number of potential parent sets. This result is interesting as we show that the k-branching problem remains NPhard under these restrictions.\nWe complement the fixed-parameter tractability result by showing that more general variants of the k-branching problem are not fixed-parameter tractable, subject to complexity theoretic assumptions. In particular, we show that the k-branching problem is not fixed-parameter tractable when parameterized by the number of nodes whose deletion produces a branching.\n2 The k-branching problem\nA probabilistic network is a multivariate probability distribution that obeys a structural representation in terms of a directed graph and a corresponding collection of univariate conditional probability distributions. For our purposes, it is crucial to treat the directed graph explicitly, whereas the conditional probabilities will enter our formalism only implicitly. Such a graph is formalized as a pair (N,A), where N is the node set and A \u2286 N \u00d7N is the arc set; we identify the graph with the arc set A when there is no ambiguity about the node set. A node u is said to be a parent of v in the graph if the arc (u, v) is in A; we denote by Av the set of parents of v. When our interest is in the undirected structure of the graph, we may denote by A the skeleton of A, that is, the set of edges { {u, v} : (u, v) \u2208 A }. For instance, we call A a polytree if A is acyclic, and a branching if additionally each node has at most one parent.\nWhen learning a probabilistic network from data it is customary to introduce a scoring function that assigns each graph A a real-valued score f(A) that measures how well A fits the data. While there are plenty of alternative scoring functions, derived under different statistical paradigms and assumptions Lam and Bacchus (1994); Chickering (1995); Heckerman, Geiger, and Chickering (1995); Dasgupta (1999), the most popular ones share one important property: they are decomposable, that is,\nf(A) = \u2211\nv\u2208N\nfv(Av) ,\nwith some \u201clocal\u201d scoring functions fv. The generic computational problem is to maximize the scoring function over some appropriate class of graphs given the local scoring functions as input. Note that the score fv(Av) need not be a sum of any individual arc weights, and that the parent set Av may be empty. Figure 1 shows a table representing a local scoring function f , together with an optimal polytree.\nWe study this problem by restricting ourselves to a graph class that is a subclass of polytrees but a superclass of branchings. We call a polytree A a k-branching if there exists a set of at most k arcs D \u2286 A such that in A \\D every node has at most one parent. Note that any branching is a 0-branching. The k-branching problem is to find a k-branching A that maximizes f(A), given the values fv(Av) for each node v and some collection of possible parent sets Av \u2286 N \\ {v}.\n3 An algorithm for the k-branching problem\nThroughout this section we consider a fixed instance of the k-branching problem, that is, a node set N and scoring functions fv for each v \u2208 N . Thus all arcs will refer to elements of N \u00d7N . We will use the following additional notation. If A is an arc set, then H(A) denotes the heads of the arcs in A, that is, the set { v : (u, v) \u2208 A }. If C is a set of edges, then N(C) denotes the induced node set { u, v : {u, v} \u2208 C }.\nWe present an algorithm that finds an optimal k-branching by implementing the following approach. First, we guess an arc set D of size at most k. Then we search for an optimal polytree A that contains D such that in A \\D every node has at most one parent; in other words, B = A \\D is an optimal branching with respect to an induced scoring function. Clearly, the set D must be acyclic. The challenge is in devising an algorithm that finds an optimal branching B that is disjoint from D while guaranteeing that the arcs in D will not create undirected cycles in the union B \u222aD. To this end, we will employ an appropriate weighted matroid intersection formulation that extends the standard formulation for branchings.\nWe will need some basic facts about matroids. A matroid is a pair (E, I), where E is a set of elements, called the ground set, and I is a collection of subsets of E, called the independent sets, such that\n(M1) \u2205 \u2208 I;\n(M2) if A \u2286 B and B \u2208 I then A \u2208 I; and\n(M3) if A,B \u2208 I and |A| < |B| then there exists an e \u2208 B \\A such that A \u222a {e} \u2208 I.\nThe rank of a matroid is the cardinality of its maximal independent sets. Any subset of E that is not independent is called dependent. Any minimal dependent set is called a circuit.\nThe power of matroid formulations is much due to the availability of efficient algorithms Brezovec, Cornue\u0301jols, and Glover (1986); Edmonds (1970, 1979); Frank (1981); Iri and Tomizawa (1976); Lawler (1976) for the weighted matroid intersection problem, defined as follows. Given two matroidsM1 = (E, I1) and M2 = (E, I2), and a weight function w : E \u2192 R, find an I \u2286 E that is independent in both matroids and maximizes the total weight of I , that is, w(I) = \u2211\ne\u2208I w(e). The complexity of the fastest algorithm we are aware of (for the general problem) is summarized as follows.\nTheorem 1 (Brezovec, Cornue\u0301jols, and Glover, 1986). The weighted matroid intersection problem can be solved in O(mr(r + c+ logm)) time, where m = |E|, r is the minimum of the ranks of M1 and M2, and c is the time needed for finding the circuit of I \u222a {e} in both M1 and M2 where e \u2208 E and I is independent in both M1 and M2.\nWe now proceed to the specification of two matroids, M1(S) = (N \u00d7 N, I1(S)) and M2(N \u00d7 N, I2(S)), parametrized by an arbitrary arc set S such that S is acyclic.\nThe in-degree matroid M1(S): Let I1(S) consist of all arc sets B such that no arc in B has a head in H(S) and every node outside H(S) is the head of at most one arc in B.\nThe acyclicity matroid M2(S): Let I2(S) consist of all arc sets B such that B \u222a S is acyclic.\nWe observe that the standard matroid intersection formulation of branchings is obtained as the special case of S = \u2205: then an arc set is seen to be branching if and only if it is independent in both the in-degree matroid and the acyclicity matroid.\nThe next two lemmas show that M1(S) and M2(S) are indeed matroids whenever S is acyclic.\nLemma 2. M1(S) is a matroid.\nProof. Fix the arc set S and denote I1(S) by I1 for short. Clearly, \u2205 \u2208 I1 and if A \u2286 B and B \u2208 I1 then also A \u2208 I1. Consequently, M1(S) satisfies (M1) and (M2). To see that M1(S) satisfies (M3) let A,B \u2208 I1 with |A| < |B|. Because of the definition of M1(S) the sets A and B contain at most one arc with head v, for every v \u2208 N \\H(S). Because |A| < |B| there is a node v \u2208 N \\H(S) such that v is the head of an arc in B but v is not the head of an arc in A. Let e \u2208 B be the arc with head v. Then e \u2208 B \\A and A\u222a {e} \u2208 I1. Hence, M1(S) satisfies (M3).\nLemma 3. M2(S) is a matroid.\nProof. Fix the arc set S and denote I2(S) by I2 for short. Because the skeleton S is acyclic and acylicity is a hereditary property (a graph property is called hereditary if it is closed under taking induced subgraphs) it follows that \u2205 \u2208 I2 and if A \u2286 B and B \u2208 I2 then also A \u2208 I2. Consequently, M2(S) satisfies (M1) and (M2). To see that M2(S) satisfies (M3) let A,B \u2208 I2 with |A| < |B|. Consider the sets A\u2032 = A \u222a S and B\u2032 = B \u222a S. Let C be a connected subset of A\u2032. Because both A\u2032 and B\u2032 are acyclic, it follows that the number of edges of B\u2032 with both endpoints in N(C) is at most the number of edges of A\u2032 with both endpoints in N(C). Because every edge in A\u2032 \\ S corresponds to an arc in A and similarly every edge in B\u2032 \\ S corresponds to an arc in B and |A| < |B|, it follows that there is an arc e \u2208 B \\A whose endpoints are contained in two distinct components of A\u2032. Consequently, the set A\u2032 \u222a {e} is acyclic and hence A \u222a {e} \u2208 I2.\nWe now relate the common independent sets of these two matroids to k-branchings. If A is a k-branching, we call an arc set D a deletion set of A if D is a subset of A, contains at most k arcs, and in A \\D every node has at most one parent.\nLemma 4. Let A be an arc set and D a subset of A of size at most k such that no two arcs from D\u2032 = { (u, v) \u2208 A \\ D : v \u2208 H(D) } have the same head and such that S is acyclic, where S = D \u222a D\u2032. We have that A is a k-branching with deletion set D if and only if A \\ S is independent in both M1(S) and M2(S).\nProof. (\u21d2) : Suppose A is a k-branching with deletion set D. Then A \\ D is a branching, which shows that every node v outside H(S) has in-degree at most one in A \\ S. Since by definition all arcs with a head in H(S) are contained in S, no arc in A \\ S has a head in H(S). Therefore, A \\ S is independent in M1(S). Since every k-branching is a polytree, (A \\ S) \u222a S = A is acyclic, and therefore A \\ S is independent in M2(S).\n(\u21d0) : Since A \\ S is independent in M2(S), we have that (A \\ S) \u222a S = A is acyclic. Thus, A is a polytree. As A \\ S is independent in M1(S), every node outside H(S) has in-degree at most one in A \\ S and every node from H(S) has in-degree zero in A \\ S. Since the head of every arc from D\u2032 is in H(S) and no two arcs from D\u2032 have a common head, (A \\ S) \u222a D\u2032 = A \\D has maximum in-degree at most one. Because |D| \u2264 k, we have that A is a k-branching with deletion set D.\nThe characterization of Lemma 4 enables the following algorithm for the k-branching problem. Define the weight function by letting w(u, v) = fv({u}) \u2212 fv(\u2205) for all arcs (u, v). Guess the arc sets D and D\u2032, put S = D \u222a D\u2032, check that S is acyclic, find a maximum-weight set B that is independent in both M1(S) and M2(S); output a k-branching A = B \u222a S that yields the maximum weight over all guesses D and D\u2032, where the weight of B \u222a S is obtained as\nw(B) + \u2211\nv\u2208H(S)\n( fv(Sv)\u2212 fv(\u2205) ) .\nIt is easy to verify that maximizing this weight is equivalent to maximizing the score f(A). Figure 2 illustrates the algorithm for the scoring function of Figure 1.\nIt remains to analyze the complexity of the algorithm. Denote by n the number of nodes. For a moment, consider the arc set S fixed. To apply Theorem 1, we bound the associated key quantities: the size of the ground set is O(n2); the rank of both matroids is clearly O(n); circuit detection can be performed in O(n) time, by a depth-first search for M1(S) and by finding a node that has higher in-degree than it is allowed to have in M2(S). Thus, by Theorem 1, a maximum-weight set that is independent in both matroids can be found in O(n4) time. Then consider the number of possible choices for the set S = D\u222aD\u2032. There are O(n2k) possibilities for choosing a set D of at most k arcs such that D is acyclic. For a fixed D, there are O(nk) possibilities for choosing a subset D\u2032 \u2286 N\u00d7H(D) such that D \u222aD\u2032 is acyclic and no two arcs from D\u2032 have the same head. Thus there are O(n3k) relevant choices for the set S.\nWe have shown the following.\nTheorem 5. The k-branching problem can be solved in O(n3k+4) time."}, {"heading": "4 Fixed-parameter tractability", "text": "Theorem 5 shows that the k-branching problem can be solved in \u201cnon-uniform polynomial time\u201d as the order of the polynomial time bound depends on k. In this section we study the question of whether one can get k \u201cout of the exponent\u201d and obtain a uniform polynomial-time algorithm.\nThe framework of Parameterized Complexity Downey and Fellows (1999) offers the suitable tools and methods for such an investigation, as it allows us to distinguish between uniform and non-uniform polynomial-time tractability with respect to a parameter. An instance of a parameterized problem is a pair (I, k) where I is the main part and k is the parameter; the latter is usually a non-negative integer. A parameterized problem is fixedparameter tractable if there exist a computable function f and a constant c such that instances (I, k) of size n can be solved in time O(f(k)nc). FPT is the class of all fixed-parameter tractable decision problems. Fixed-parameter tractable problems are also called uniform polynomial-time tractable because if k is considered constant, then instances with parameter k can be solved in polynomial time where the order of the polynomial is independent of k (in contrast to non-uniform polynomial-time running times such as nk).\nParameterized complexity offers a completeness theory similar to the theory of NP-completeness. One uses parameterized reductions which are many-one reductions where the parameter for one problem maps into the\nparameter for the other. More specifically, problemL reduces to problemL\u2032 if there is a mappingR from instances of L to instances of L\u2032 such that (i) (I, k) is a yes-instance of L if and only if (I \u2032, k\u2032) = R(I, k) is a yes-instance of L\u2032, (ii) k\u2032 \u2264 g(k) for a computable function g, and (iii) R can be computed in time O(f(k)nc) where f is a computable function, c is a constant, and n denotes the size of (I, k). The parameterized complexity class W[1] is considered as the parameterized analog to NP. For example, the parameterized Maximum Clique problem (given a graph G and a parameter k \u2265 0, does G contain a complete subgraph on k vertices?) is W[1]-complete under parameterized reductions. Note that there exists a trivial non-uniform polynomial-time nk algorithm for the Maximum Clique problems that checks all sets of k vertices. FPT 6= W[1] is a widely accepted complexity theoretic assumption Downey and Fellows (1999). For example, FPT = W[1] implies the (unlikely) existence of a 2o(n) algorithm for n-variable 3SAT Impagliazzo, Paturi, and Zane (2001); Flum and Grohe (2006). A first parameterized analysis of probabilistic network structure learning using structural parameters such as treewidth has recently been carried out by Ordyniak and Szeider (2010).\nThe algorithm from Theorem 5 considers O(n3k) relevant choices for the set S = D\u222aD\u2032, and for each fixed choice of S the running time is polynomial. Thus, for restrictions of the problem for which the enumeration of all relevant sets S is fixed parameter tractable, one obtains an FPT algorithm. One such restriction requires that S = D\u222aD\u2032 is an in-tree, i.e., a directed tree where every arc is directed towards a designated root, and each node has a bounded number of potential parent sets.\nTheorem 6. The k-branching problem is fixed-parameter tractable if we require that (i) the set S = D \u222aD\u2032 of arcs is an in-tree and (ii) each node has a bounded number of potential parent sets.\nProof. To compute a k-branching A, the algorithm guesses its deletion set D and the set D\u2032 = {(u, v) \u2208 A \\D : v \u2208 H(D)}. As A is a k-branching, |D| \u2264 k and for every v \u2208 H(D) there is at most one arc in D\u2032 with head v. The algorithm first guesses the root r for the in-tree S. Then it goes over all possible choices for D and D\u2032 as follows, until D has at least k arcs.\nGuess a leaf \u2113 of S (initially, r is the unique leaf of S), and guess a non-empty parent set P for \u2113 in A. If |D|+ |P |+ 1 > k, then backtrack. Otherwise, choose at most one arc (p, \u2113) to add to D\u2032, where p \u2208 P , and add all other arcs from a node from P to \u2113 to D (if |P | = 1, no arc is added to D\u2032). Now, check whether the current choice for S = D \u222a D\u2032 leads to a k-branching by checking whether S is acyclic and using the matroids M1(S) and M2(S) as in Theorem 5.\nThere are at most n choices for r. The in-tree S is expanded in at most k steps, as each step adds at least one arc to D. In each step, \u2113 is chosen among at most k + 1 leaves, there is a constant number of choices for its parent set P and at most k + 2 choices for adding (or not) an arc (p, \u2113), with p \u2208 P , to D\u2032 (as |P | \u2264 k + 1). The acyclicity check for S and the weighted matroid intersection can be computed in time O(n4), leading to a total running time of O(k2kckn5), where c is such that every node has at most c potential parent sets.\nCondition (i) in Theorem 6 may be replaced by other conditions requiring the connectivity of D or a small distance between arcs from D, giving other fixed-parameter tractable restrictions of the k-branching problem.\nThe following theorem shows that an exponential dependency on k or some other parameter is necessary since the k-branching problem remains NP-hard under the restrictions given above.\nTheorem 7. The k-branching problem is NP-hard even if we require that (i) the set S = D \u222a D\u2032 of arcs is an in-tree and (ii) each node has at most 3 potential parent sets.\nProof. We devise a polynomial reduction from 3-SAT-2 a version of 3-SATISFIABILITY where every literal occurs at most in two clauses. 3-SAT-2 is well known to be NP-hard Garey and Johnson (1979). Our reduction uses the same ideas as the proof of Theorem 6 in Dasgupta (1999). Let \u03a6 be an instance of 3-SAT-2 with clauses C1, . . . , Cm and variables x1, . . . , xn. We define the set N of nodes as follows. For every variable xi in \u03a6 the set N contains the nodes pi, xi, x1i , x 2 i , x 1 i and x 2 i . Furthermore, for every clause Cj the set N contains the nodes pn+j and Cj . Let 1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m, and 1 \u2264 l \u2264 2. We set f(Cj , xli) = 1 if the clause Cj is the l-th clause that contains the literal xi. Similarly, we set f(Cj , xli) = 1 if the clause Cj is the l-th clause that contains the literal xi. We set f(xi, {x1i , x 2 i }) = f(xi, {x 1 i , x 2 i }) = 1, f(p1, {x1}) = f(pi, {xi, pi\u22121}) = 1 for every 1 < i \u2264 n, and f(pn+j , {Cj, pn+j\u22121}) = 1 for every 1 \u2264 j \u2264 m. Furthermore, we set f(v, P ) = 0 for all the remaining combinations of v \u2208 N and P \u2286 N . This completes the construction of N and f . Observe that every node of N has at most 3 potential parent sets. This completes our construction. We will have shown the theorem after showing the following claim.\nClaim: \u03a6 is satisfiable if and only if there is a 2n + m-branching D such that f(D) \u2265 2(m + n), the set S = D \u222aD\u2032 of arcs is an in-tree, and each node of N has at most 3 potential parent sets.\n(\u21d2) : Suppose that the formula \u03a6 is satisfiable and let \u03b2 be a satisfying assignment for \u03a6. Furthermore, for every 1 \u2264 j \u2264 m let lj be a literal of Cj that is set to true by \u03b2. We construct a 2n+m-branching D as follows. For every 1 \u2264 j \u2264 m the digraph D contains an arc (xli, Cj) if lj = xi and Cj is the l-th clause that contains xi and an arc (xli, Cj) if lj = xi and Cj is the l-th clause that contains xi for some 1 \u2264 i \u2264 n and 1 \u2264 l \u2264 2. Furthermore, for every 1 \u2264 i \u2264 n the digraph D contains the arcs (x1i , xi) and (x 2 i , xi) if \u03b2(xi) = false and the arcs (x1i , xi) and (x 2 i , xi) if \u03b2(xi) = true. Last but not least D contains the arcs (xi, pi), (Cj , pn+j) and (pl, pl+1) for every 1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m, and 1 \u2264 l < m + n. Figure 3 shows an optimal 2n + m-branching D for some 3-SAT-2 formula. It is easy to see that D is a 2n +m-branching such that f(D) = 2(m + n) and the set S = D \u222aD\u2032 of arcs is an in-tree.\n(\u21d0) : Suppose there is a 2n + m-branching D such that f(D) \u2265 2(m + n). Because f(D) \u2265 2(m + n) it follows that every node of N achieves its maximum score in D. Hence, D has to contain the arcs (xi, pi), (Cj , pn+j), (pl, pl+1), for every 1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m, and 1 \u2264 l < m + n. For the same reasons D has to contain either the arcs (x1i , xi) and (x 2 i , xi) or the arcs (x 1 i , xi) and (x 2 i , xi) for every 1 \u2264 i \u2264 n. Furthermore, for every 1 \u2264 j \u2264 m the 2n + m-branching D has to contain one arc of the form (xli, Cj) or (x l i, Cj) where Cj is the l-th clause that contains xi or xi, respectively, for some 1 \u2264 i \u2264 n and 1 \u2264 l \u2264 2. Let 1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m, and 1 \u2264 l \u2264 2. We first show that whenever D contains an arc (xli, xi) then D contains no arc of the form (xli, Cj) and similarly if D contains an arc (x l i, xi) then D contains no arc of the form (xi, Cj). Suppose for a contradiction that D contains an arc (xli, xi) together with an arc (x l i, Cj) or an arc (x l i, xi) together with an arc (xli, Cj). In the first case D contains the undirected cycle (x l i, xi, pi, . . . , pn+j , Cj , x l i) and in the second case D contains the cycle (xli, xi, pi, . . . , pn+j, Cj , x l i) contradicting our assumption that D is a 2n +m-branching. It now follows that the assignment \u03b2 with \u03b2(xi) = true if D does not contain the arcs (x1i , xi) and (x 2 i , xi) and \u03b2(xi) = false if D does not contain the arcs (x1i , xi) and (x 2 i , xi) is a satisfying assignment for \u03a6.\nSo far we have measured the difference of a polytree to branchings in terms of the number of arcs to be deleted. Next we investigate the consequences of measuring the difference by the number of nodes to be deleted. We call a polytree A a k-node branching if there exists a set of at most k nodes X \u2286 A such that A \\ X is a branching. The k-node branching problem is to find a k-node branching A that maximizes f(A). Clearly every k-branching is a k-node branching, but the reverse does not hold. In other words, the k-node branching problem generalizes the k-branching problem.\nIn the following we show that the k-node branching problem is hard for the parameterized complexity class W[1]; this provides strong evidence that the problem is not fixed-parameter tractable.\nTheorem 8. The k-node branching problem is W[1]-hard.\nProof. We devise a parameterized reduction from the following problem, called Partitioned Clique, which is well-known to be W[1]-complete for parameter k Pietrzak (2003). The Instance is a k-partite graph G = (V,E) with partition V1, . . . , Vk such that |Vi| = n for every 1 \u2264 i \u2264 k. The question is whether there are nodes v1, . . . , vk such that vi \u2208 Vi for 1 \u2264 i \u2264 k and {vi, vj} \u2208 E for 1 \u2264 i < j \u2264 k? (The graph K = ({v1, . . . , vk}, { {vi, vj} : 1 \u2264 i < j \u2264 k }) is a k-clique of G.)\nLet G = (V,E) be an instance of this problem with partition V1, . . . , Vk , |V1| = \u00b7 \u00b7 \u00b7 = |Vk| = n, and parameter k. Let k\u2032 = ( k\n2\n)\n+ k, \u03b1 = 1, and s = k\u2032\u03b1. Let A = { aij : 1 \u2264 i < j \u2264 k } and Ai = { alk \u2208 A : l = i or k = i } for every 1 \u2264 i \u2264 k. Then N is defined as N = A \u222a {c1, . . . , ck} \u222a { v1, . . . , vk : v \u2208 V }. Let V wi = { v\n1, . . . , vk : v \u2208 Vi and v 6= w }. We define the score function f as follows. We set f(ci, Ai \u222a V wi ) = \u03b1 for every 1 \u2264 i \u2264 k and w \u2208 Vi, and f(aij , {uj, wi}) = \u03b1 for every 1 \u2264 i < j \u2264 k, u \u2208 Vi, w \u2208 Vj , and {u,w} \u2208 E(G). Furthermore, we set f(v, P ) = 0 for all the remaining combinations of v and P . This completes our construction. We will have the theorem after showing the following claim.\nClaim: G has a k-clique if and only if there is a k\u2032-node branching D such that f(D) \u2265 s. (\u21d2) : Suppose that G has a k-clique K . Then it is easy to see that the DAG D on N defined by the arc set { (vj , aij), (vj , aji) : v \u2208 V (K) \u2229 Vi and 1 \u2264 i, j \u2264 k } \u222a { (vi, aij), (vi, aji) : v \u2208 V (K) \u2229 Vj and 1 \u2264 i, j \u2264 k } \u222a { (aij , ci) : 1 \u2264 i < j \u2264 k } \u222a { (aij , cj) : 1 \u2264 i < j \u2264 k } \u222a { (vj, ci) : v \u2208 Vi \\ ( \u22c3\ne\u2208E(K) e) and 1 \u2264 i, j \u2264 k } is a k\u2032-node branching and f(D) = s. Figure 4 shows an optimal k\u2032-node branching D constructed from an example graph G.\n(\u21d0) : Suppose there is a k\u2032-node branching D with f(D) \u2265 s. It follows that every node of D achieves its maximum score. In particular, for every 1 \u2264 i \u2264 k the nodes ci must have score \u03b1 in D and hence there is a node wi \u2208 Vi such that ci is adjacent to all nodes in V wi i \u222a Ai. Furthermore, for every 1 \u2264 i < j \u2264 k the node aij is adjacent to exactly one node in Vi and to exactly one node in Vj . Let vli be the unique node in Vi adjacent to aij and similarly let vmi be the unique node in Vj that is adjacent to aij for every 1 \u2264 i < j \u2264 k. Then wi = vi and wj = vj because otherwise the skeleton of D would contain the cycle (vi, aij , ci) or the cycle (vj , aij , cj). Consequently, the edges represented by the parents of aij in D for all 1 \u2264 i < j \u2264 k form a k-clique in G."}, {"heading": "5 Concluding remarks", "text": "We have studied a natural approach to extend the known efficient algorithms for branchings to polytrees that differ from branchings in only a few extra arcs. At first glance, one might expect this to be achievable by simply guessing the extra arcs and solving the remaining problem for branchings. However, we do not know whether such a reduction is possible in the strict sense. Indeed, we had to take a slight detour and modify the two matroids in a way that guarantees a control for the interactions caused by the presence of high-in-degree nodes. As a result, we got an algorithm that runs in time polynomial in the input size: namely, there can be more than (\nn\u22121 k+1\n)\nrelevant input values for each of the n nodes; so, the runtime of our algorithm is less than cubic in the size of the input,\nsupposing the local scores are given explicitly. While this answers one question in the affirmative, it also raises several further questions, some of which we give in the next paragraphs.\nOur complexity analysis relied on a result concerning the general weighted matroid intersection problem. Do significantly faster algorithms exist when restricted to our two specific matroids? One might expect such algorithms exist, since the related problem for branchings can be solved in O(n2) time by the algorithm of Tarjan (1977).\nEven if we could solve the matroid intersection problem faster, our algorithm would remain practical only for very small values of k. Can one find an optimal k-branching significantly faster, especially if allowing every node to have at most two parents? As the current algorithm makes around n3k mutually overlapping guesses, there might be a way to considerably reduce the time complexity. Specifically, we ask whether the restricted problem is fixed-parameter tractable with respect to the parameter k, that is, solvable in O(f(k)p(n)) time for some computable function f and polynomial p Downey and Fellows (1999). The fixed-parameter algorithm given in Section 4 can be seen as a first step towards an answer to this question. Can we find other restrictions under which the k-branching problem becomes fixed-parameter tractable?\nCan we use a similar approach for the more general k-node branching problem, i.e., is there a polynomial time algorithm for the k-node branching problem for every fixed k? Likewise, we do not know whether the problem is easier or harder for polytrees than for general DAGs: Do similar techniques apply to finding maximum-score DAGs that can be turned into branchings by deleting some k arcs?"}, {"heading": "Acknowledgments", "text": "Serge Gaspers, Sebastian Ordyniak, and Stefan Szeider acknowledge support from the European Research Council (COMPLEX REASON, 239962). Serge Gaspers acknowledges support from the Australian Research Council (DE120101761). Mikko Koivisto acknowledges the support from the Academy of Finland (Grant 125637). Mathieu Liedloff acknowledges the support from the French Agence Nationale de la Recherche (ANR AGAPE ANR-09-BLAN-0159-03)."}], "references": [{"title": "An algorithm to construct a minimum directed spanning tree in a directed network", "author": ["F.C. Bock"], "venue": "Avi-Itzak, B., ed., Developments in Operations Research. Gordon and Breach. 29\u201344.", "citeRegEx": "Bock,? 1971", "shortCiteRegEx": "Bock", "year": 1971}, {"title": "Two algorithms for weighted matroid intersection", "author": ["C. Brezovec", "G. Cornu\u00e9jols", "F. Glover"], "venue": "Mathematical Programming 36(1):39\u201353.", "citeRegEx": "Brezovec et al\\.,? 1986", "shortCiteRegEx": "Brezovec et al\\.", "year": 1986}, {"title": "A note on finding optimum branchings", "author": ["P.M. Camerini", "L. Fratta", "F. Maffioli"], "venue": "Networks 9:309\u2013312.", "citeRegEx": "Camerini et al\\.,? 1979", "shortCiteRegEx": "Camerini et al\\.", "year": 1979}, {"title": "A theorem on trees", "author": ["A. Cayley"], "venue": "Quart. J. Math. 23:376\u2013378.", "citeRegEx": "Cayley,? 1889", "shortCiteRegEx": "Cayley", "year": 1889}, {"title": "A transformational characterization of equivalent Bayesian network structures", "author": ["D.M. Chickering"], "venue": "Uncertainty in artificial intelligence (UAI 1995).", "citeRegEx": "Chickering,? 1995", "shortCiteRegEx": "Chickering", "year": 1995}, {"title": "Learning Bayesian networks is NP-complete", "author": ["D.M. Chickering"], "venue": "Learning from data (Fort Lauderdale, FL, 1995), volume 112 of Lecture Notes in Statist. Springer Verlag. 121\u2013130.", "citeRegEx": "Chickering,? 1996", "shortCiteRegEx": "Chickering", "year": 1996}, {"title": "On the shortest arborescence of a directed graph", "author": ["Y.J. Chu", "T.H. Liu"], "venue": "Science Sinica 14:1396\u20131400.", "citeRegEx": "Chu and Liu,? 1965", "shortCiteRegEx": "Chu and Liu", "year": 1965}, {"title": "Learning polytrees", "author": ["S. Dasgupta"], "venue": "Uncertainty in Artificial Intelligence (UAI 1999).", "citeRegEx": "Dasgupta,? 1999", "shortCiteRegEx": "Dasgupta", "year": 1999}, {"title": "Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Monographs in Computer Science. New York: Springer Verlag.", "citeRegEx": "Downey and Fellows,? 1999", "shortCiteRegEx": "Downey and Fellows", "year": 1999}, {"title": "Optimum branchings", "author": ["J.R. Edmonds"], "venue": "Journal of Research of the National Bureau of Standards 71B(4):233\u2013240.", "citeRegEx": "Edmonds,? 1967", "shortCiteRegEx": "Edmonds", "year": 1967}, {"title": "Submodular functions, matroids and certain polyhedra", "author": ["J.R. Edmonds"], "venue": "Combinatorial Structures and their Applications, 69\u201387.", "citeRegEx": "Edmonds,? 1970", "shortCiteRegEx": "Edmonds", "year": 1970}, {"title": "Matroid intersection", "author": ["J.R. Edmonds"], "venue": "Annals of Discrete Mathematics 4:39\u201349.", "citeRegEx": "Edmonds,? 1979", "shortCiteRegEx": "Edmonds", "year": 1979}, {"title": "Parameterized Complexity Theory, volume XIV of Texts in Theoretical Computer Science", "author": ["J. Flum", "M. Grohe"], "venue": "An EATCS Series. Berlin: Springer Verlag.", "citeRegEx": "Flum and Grohe,? 2006", "shortCiteRegEx": "Flum and Grohe", "year": 2006}, {"title": "Exact Exponential Algorithms", "author": ["F.V. Fomin", "D. Kratsch"], "venue": "Texts in Theoretical Computer Science. An EATCS Series. Springer.", "citeRegEx": "Fomin and Kratsch,? 2010", "shortCiteRegEx": "Fomin and Kratsch", "year": 2010}, {"title": "A weighted matroid intersection algorithm", "author": ["A. Frank"], "venue": "Journal of Algorithms 2:328\u2013336.", "citeRegEx": "Frank,? 1981", "shortCiteRegEx": "Frank", "year": 1981}, {"title": "Bayesian network classifiers", "author": ["N. Friedman", "D. Geiger", "M. Goldszmidt"], "venue": "Machine Learning 29:131\u2013 163.", "citeRegEx": "Friedman et al\\.,? 1997", "shortCiteRegEx": "Friedman et al\\.", "year": 1997}, {"title": "Packing rooted directed cuts in a weighted directed graph", "author": ["D.R. Fulkerson"], "venue": "Mathematical Programming 6:1\u201313.", "citeRegEx": "Fulkerson,? 1974", "shortCiteRegEx": "Fulkerson", "year": 1974}, {"title": "Efficient algorithms for finding minimum spanning trees in undirected and directed graphs", "author": ["H.N. Gabow", "Z. Galil", "T. Spencer", "R.E. Tarjan"], "venue": "Combinatorica 6(2):109\u2013122.", "citeRegEx": "Gabow et al\\.,? 1986", "shortCiteRegEx": "Gabow et al\\.", "year": 1986}, {"title": "Efficient implementation of graph algorithms using contraction", "author": ["H.N. Gabow", "Z. Galil", "T.H. Spencer"], "venue": "Journal of the ACM 36(3):540\u2013572.", "citeRegEx": "Gabow et al\\.,? 1989", "shortCiteRegEx": "Gabow et al\\.", "year": 1989}, {"title": "Computers and Intractability", "author": ["M.R. Garey", "D.R. Johnson"], "venue": "San Francisco: W. H. Freeman and Company, New York.", "citeRegEx": "Garey and Johnson,? 1979", "shortCiteRegEx": "Garey and Johnson", "year": 1979}, {"title": "Learning Bayesian networks: The combination of knowledge and statistical data", "author": ["D. Heckerman", "D. Geiger", "D.M. Chickering"], "venue": "Machine Learning 20(3):197\u2013243.", "citeRegEx": "Heckerman et al\\.,? 1995", "shortCiteRegEx": "Heckerman et al\\.", "year": 1995}, {"title": "Which problems have strongly exponential complexity? J", "author": ["R. Impagliazzo", "R. Paturi", "F. Zane"], "venue": "of Computer and System Sciences 63(4):512\u2013530.", "citeRegEx": "Impagliazzo et al\\.,? 2001", "shortCiteRegEx": "Impagliazzo et al\\.", "year": 2001}, {"title": "An algorithm for finding an optimal \u2019independent\u2019 assignment", "author": ["M. Iri", "N. Tomizawa"], "venue": "Journal of the Operations Research Society of Japan 19:32\u201357.", "citeRegEx": "Iri and Tomizawa,? 1976", "shortCiteRegEx": "Iri and Tomizawa", "year": 1976}, {"title": "A simple derivation of Edmonds\u2019 algorithm for optimum branchings", "author": ["R.M. Karp"], "venue": "Networks 1(3):265\u2013272.", "citeRegEx": "Karp,? 1971", "shortCiteRegEx": "Karp", "year": 1971}, {"title": "Exact Bayesian structure discovery in Bayesian networks", "author": ["M. Koivisto", "K. Sood"], "venue": "J. Mach. Learn. Res. 5:549\u2013573.", "citeRegEx": "Koivisto and Sood,? 2004", "shortCiteRegEx": "Koivisto and Sood", "year": 2004}, {"title": "Learning Bayesian belief networks: An approach based on the MDL principle", "author": ["W. Lam", "F. Bacchus"], "venue": "Computational Intelligence 10:269\u2013293.", "citeRegEx": "Lam and Bacchus,? 1994", "shortCiteRegEx": "Lam and Bacchus", "year": 1994}, {"title": "Combinatorial Optimization: Networks and Matroids", "author": ["E.L. Lawler"], "venue": "New York: Holt, Rinehart and Winston.", "citeRegEx": "Lawler,? 1976", "shortCiteRegEx": "Lawler", "year": 1976}, {"title": "Algorithms and complexity results for exact Bayesian structure learning", "author": ["S. Ordyniak", "S. Szeider"], "venue": "Uncertainty in Artificial Intelligence (UAI 2010).", "citeRegEx": "Ordyniak and Szeider,? 2010", "shortCiteRegEx": "Ordyniak and Szeider", "year": 2010}, {"title": "Finding optimal gene networks using biological constraints", "author": ["S. Ott", "S. Miyano"], "venue": "Genome Informatics 14:124\u2013133.", "citeRegEx": "Ott and Miyano,? 2003", "shortCiteRegEx": "Ott and Miyano", "year": 2003}, {"title": "Exact structure discovery in Bayesian networks with less space", "author": ["P. Parviainen", "M. Koivisto"], "venue": "Uncertainty in Artificial Intelligence (UAI 2009), 436\u2013443.", "citeRegEx": "Parviainen and Koivisto,? 2009", "shortCiteRegEx": "Parviainen and Koivisto", "year": 2009}, {"title": "On the parameterized complexity of the fixed alphabet shortest common supersequence and longest common subsequence problems", "author": ["K. Pietrzak"], "venue": "J. of Computer and System Sciences 67(4):757\u2013771.", "citeRegEx": "Pietrzak,? 2003", "shortCiteRegEx": "Pietrzak", "year": 2003}, {"title": "A simple approach for finding the globally optimal Bayesian network structure", "author": ["T. Silander", "P. Myllym\u00e4ki"], "venue": "Uncertainty in Artificial Intelligence (UAI 2006), 445\u2013452.", "citeRegEx": "Silander and Myllym\u00e4ki,? 2006", "shortCiteRegEx": "Silander and Myllym\u00e4ki", "year": 2006}, {"title": "Finding optimum branchings", "author": ["R.E. Tarjan"], "venue": "Networks 7:25\u201335.", "citeRegEx": "Tarjan,? 1977", "shortCiteRegEx": "Tarjan", "year": 1977}], "referenceMentions": [{"referenceID": 4, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al.", "startOffset": 0, "endOffset": 15}, {"referenceID": 3, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al.", "startOffset": 172, "endOffset": 191}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al.", "startOffset": 249, "endOffset": 261}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al.", "startOffset": 249, "endOffset": 300}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al.", "startOffset": 249, "endOffset": 318}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977).", "startOffset": 249, "endOffset": 339}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977).", "startOffset": 249, "endOffset": 373}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977).", "startOffset": 249, "endOffset": 386}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two.", "startOffset": 249, "endOffset": 401}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two.", "startOffset": 249, "endOffset": 420}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two.", "startOffset": 249, "endOffset": 575}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two. Given the recent advances in exact exponential algorithms in general (see, e.g., the book by Fomin and Kratsch (2010)), and in finding optimal DAGs in particular, it is natural to ask, whether \u201cfast\u201d exponential-time algorithms exist for finding optimal polytrees.", "startOffset": 249, "endOffset": 1008}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two. Given the recent advances in exact exponential algorithms in general (see, e.g., the book by Fomin and Kratsch (2010)), and in finding optimal DAGs in particular, it is natural to ask, whether \u201cfast\u201d exponential-time algorithms exist for finding optimal polytrees. For general DAGs the fastest known algorithms run in time within a polynomial factor of 2, where n is the number of nodes Koivisto and Sood (2004); Ott and Miyano (2003); Parviainen and Koivisto (2009); Silander and Myllym\u00e4ki (2006).", "startOffset": 249, "endOffset": 1302}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two. Given the recent advances in exact exponential algorithms in general (see, e.g., the book by Fomin and Kratsch (2010)), and in finding optimal DAGs in particular, it is natural to ask, whether \u201cfast\u201d exponential-time algorithms exist for finding optimal polytrees. For general DAGs the fastest known algorithms run in time within a polynomial factor of 2, where n is the number of nodes Koivisto and Sood (2004); Ott and Miyano (2003); Parviainen and Koivisto (2009); Silander and Myllym\u00e4ki (2006).", "startOffset": 249, "endOffset": 1325}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two. Given the recent advances in exact exponential algorithms in general (see, e.g., the book by Fomin and Kratsch (2010)), and in finding optimal DAGs in particular, it is natural to ask, whether \u201cfast\u201d exponential-time algorithms exist for finding optimal polytrees. For general DAGs the fastest known algorithms run in time within a polynomial factor of 2, where n is the number of nodes Koivisto and Sood (2004); Ott and Miyano (2003); Parviainen and Koivisto (2009); Silander and Myllym\u00e4ki (2006).", "startOffset": 249, "endOffset": 1357}, {"referenceID": 0, "context": "Edmonds (1967) gave an efficient algorithm for the class of branchings, that is, directed forests with in-degree at most one; the algorithm was discovered independently by Chu and Liu (1965), and it has been later simplified and expedited by others Bock (1971); Camerini, Fratta, and Maffioli (1979); Fulkerson (1974); Gabow et al. (1986); Gabow, Galil, and Spencer (1989); Karp (1971); Tarjan (1977). Chickering (1996) showed that for general directed acyclic graphs, DAGs, the problem is NP-hard even if the in-degree is at most two. Motivated by this gap, Dasgupta (1999) asked for a network class that is more general than branchings yet admitting provably good structure-learning algorithms; his findings concerning polytrees, that is, DAGs without undirected cycles, were however rather negative, showing that the optimization problem is NP-hard even if the in-degree is at most two. Given the recent advances in exact exponential algorithms in general (see, e.g., the book by Fomin and Kratsch (2010)), and in finding optimal DAGs in particular, it is natural to ask, whether \u201cfast\u201d exponential-time algorithms exist for finding optimal polytrees. For general DAGs the fastest known algorithms run in time within a polynomial factor of 2, where n is the number of nodes Koivisto and Sood (2004); Ott and Miyano (2003); Parviainen and Koivisto (2009); Silander and Myllym\u00e4ki (2006). However, it is not clear, whether even these bounds can be achieved for polytrees; a brute-force algorithm would visit each polytree one by one, whose num-", "startOffset": 249, "endOffset": 1388}, {"referenceID": 3, "context": "ber scales as the number of directed labelled trees n2 Cayley (1889). Do significantly faster algorithms exist? Does the problem become easier if only a small number of nodes are allowed an in-degree larger than one? In this work, we take a first step towards answering these questions by considering polytrees that differ from branchings by only a few arcs.", "startOffset": 55, "endOffset": 69}, {"referenceID": 3, "context": "ber scales as the number of directed labelled trees n2 Cayley (1889). Do significantly faster algorithms exist? Does the problem become easier if only a small number of nodes are allowed an in-degree larger than one? In this work, we take a first step towards answering these questions by considering polytrees that differ from branchings by only a few arcs. More precisely, we study the problem of finding an optimal k-branching, defined as a polytree that can be turned into a branching by deleting k arcs. We make the standard assumption that the scoring function decomposes into a sum of local scores; see the next section for precise definitions. We note that k-branchings generalize branchings in a different direction than the Tree-augmented Naive Bayes classifier (TAN) due to Friedman, Geiger, and Goldszmidt (1997). Namely, in a TAN the in-degree of each node is at most two, and there is a designated class node of in-degree zero, removing of which leaves a spanning tree; the tree is undirected in the sense that the symmetric conditional mutual information is employed to score arcs.", "startOffset": 55, "endOffset": 825}, {"referenceID": 8, "context": "We therefore investigate variants of the k-branching problem that admit fixed-parameter tractability in the sense of Downey and Fellows (1999): the running time bound is given by a polynomial whose degree is independent of the parameter, the parameter contributing a constant factor to the bound.", "startOffset": 117, "endOffset": 143}, {"referenceID": 22, "context": "While there are plenty of alternative scoring functions, derived under different statistical paradigms and assumptions Lam and Bacchus (1994); Chickering (1995); Heckerman, Geiger, and Chickering (1995); Dasgupta (1999), the most popular ones share one important property: they are decomposable, that is,", "startOffset": 119, "endOffset": 142}, {"referenceID": 4, "context": "While there are plenty of alternative scoring functions, derived under different statistical paradigms and assumptions Lam and Bacchus (1994); Chickering (1995); Heckerman, Geiger, and Chickering (1995); Dasgupta (1999), the most popular ones share one important property: they are decomposable, that is,", "startOffset": 143, "endOffset": 161}, {"referenceID": 4, "context": "While there are plenty of alternative scoring functions, derived under different statistical paradigms and assumptions Lam and Bacchus (1994); Chickering (1995); Heckerman, Geiger, and Chickering (1995); Dasgupta (1999), the most popular ones share one important property: they are decomposable, that is,", "startOffset": 143, "endOffset": 203}, {"referenceID": 4, "context": "While there are plenty of alternative scoring functions, derived under different statistical paradigms and assumptions Lam and Bacchus (1994); Chickering (1995); Heckerman, Geiger, and Chickering (1995); Dasgupta (1999), the most popular ones share one important property: they are decomposable, that is,", "startOffset": 143, "endOffset": 220}, {"referenceID": 9, "context": "The power of matroid formulations is much due to the availability of efficient algorithms Brezovec, Cornu\u00e9jols, and Glover (1986); Edmonds (1970, 1979); Frank (1981); Iri and Tomizawa (1976); Lawler (1976) for the weighted matroid intersection problem, defined as follows.", "startOffset": 131, "endOffset": 166}, {"referenceID": 9, "context": "The power of matroid formulations is much due to the availability of efficient algorithms Brezovec, Cornu\u00e9jols, and Glover (1986); Edmonds (1970, 1979); Frank (1981); Iri and Tomizawa (1976); Lawler (1976) for the weighted matroid intersection problem, defined as follows.", "startOffset": 131, "endOffset": 191}, {"referenceID": 9, "context": "The power of matroid formulations is much due to the availability of efficient algorithms Brezovec, Cornu\u00e9jols, and Glover (1986); Edmonds (1970, 1979); Frank (1981); Iri and Tomizawa (1976); Lawler (1976) for the weighted matroid intersection problem, defined as follows.", "startOffset": 131, "endOffset": 206}, {"referenceID": 8, "context": "The framework of Parameterized Complexity Downey and Fellows (1999) offers the suitable tools and methods for such an investigation, as it allows us to distinguish between uniform and non-uniform polynomial-time tractability with respect to a parameter.", "startOffset": 42, "endOffset": 68}, {"referenceID": 8, "context": "FPT 6= W[1] is a widely accepted complexity theoretic assumption Downey and Fellows (1999). For example, FPT = W[1] implies the (unlikely) existence of a 2 algorithm for n-variable 3SAT Impagliazzo, Paturi, and Zane (2001); Flum and Grohe (2006).", "startOffset": 65, "endOffset": 91}, {"referenceID": 8, "context": "FPT 6= W[1] is a widely accepted complexity theoretic assumption Downey and Fellows (1999). For example, FPT = W[1] implies the (unlikely) existence of a 2 algorithm for n-variable 3SAT Impagliazzo, Paturi, and Zane (2001); Flum and Grohe (2006).", "startOffset": 65, "endOffset": 223}, {"referenceID": 8, "context": "FPT 6= W[1] is a widely accepted complexity theoretic assumption Downey and Fellows (1999). For example, FPT = W[1] implies the (unlikely) existence of a 2 algorithm for n-variable 3SAT Impagliazzo, Paturi, and Zane (2001); Flum and Grohe (2006). A first parameterized analysis of probabilistic network structure learning using structural parameters such as treewidth has recently been carried out by Ordyniak and Szeider (2010).", "startOffset": 65, "endOffset": 246}, {"referenceID": 8, "context": "FPT 6= W[1] is a widely accepted complexity theoretic assumption Downey and Fellows (1999). For example, FPT = W[1] implies the (unlikely) existence of a 2 algorithm for n-variable 3SAT Impagliazzo, Paturi, and Zane (2001); Flum and Grohe (2006). A first parameterized analysis of probabilistic network structure learning using structural parameters such as treewidth has recently been carried out by Ordyniak and Szeider (2010). The algorithm from Theorem 5 considers O(n) relevant choices for the set S = D\u222aD, and for each fixed choice of S the running time is polynomial.", "startOffset": 65, "endOffset": 429}, {"referenceID": 18, "context": "3-SAT-2 is well known to be NP-hard Garey and Johnson (1979). Our reduction uses the same ideas as the proof of Theorem 6 in Dasgupta (1999).", "startOffset": 36, "endOffset": 61}, {"referenceID": 7, "context": "Our reduction uses the same ideas as the proof of Theorem 6 in Dasgupta (1999). Let \u03a6 be an instance of 3-SAT-2 with clauses C1, .", "startOffset": 63, "endOffset": 79}, {"referenceID": 30, "context": "We devise a parameterized reduction from the following problem, called Partitioned Clique, which is well-known to be W[1]-complete for parameter k Pietrzak (2003). The Instance is a k-partite graph G = (V,E) with partition V1, .", "startOffset": 147, "endOffset": 163}, {"referenceID": 31, "context": "Do significantly faster algorithms exist when restricted to our two specific matroids? One might expect such algorithms exist, since the related problem for branchings can be solved in O(n) time by the algorithm of Tarjan (1977). Even if we could solve the matroid intersection problem faster, our algorithm would remain practical only for very small values of k.", "startOffset": 215, "endOffset": 229}, {"referenceID": 8, "context": "Specifically, we ask whether the restricted problem is fixed-parameter tractable with respect to the parameter k, that is, solvable in O(f(k)p(n)) time for some computable function f and polynomial p Downey and Fellows (1999). The fixed-parameter algorithm given in Section 4 can be seen as a first step towards an answer to this question.", "startOffset": 200, "endOffset": 226}], "year": 2012, "abstractText": "Inferring probabilistic networks from data is a notoriously difficult task. Under various goodness-of-fit measures, finding an optimal network is NP-hard, even if restricted to polytrees of bounded in-degree. Polynomialtime algorithms are known only for rare special cases, perhaps most notably for branchings, that is, polytrees in which the in-degree of every node is at most one. Here, we study the complexity of finding an optimal polytree that can be turned into a branching by deleting some number of arcs or nodes, treated as a parameter. We show that the problem can be solved via a matroid intersection formulation in polynomial time if the number of deleted arcs is bounded by a constant. The order of the polynomial time bound depends on this constant, hence the algorithm does not establish fixed-parameter tractability when parameterized by the number of deleted arcs. We show that a restricted version of the problem allows fixed-parameter tractability and hence scales well with the parameter. We contrast this positive result by showing that if we parameterize by the number of deleted nodes, a somewhat more powerful parameter, the problem is not fixed-parameter tractable, subject to a complexity-theoretic assumption.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}