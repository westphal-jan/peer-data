{"id": "1211.0439", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Nov-2012", "title": "Learning curves for multi-task Gaussian process regression", "abstract": "We study the average case performance of multi-task Gaussian process (GP) regression as captured in the learning curve, i.e. the average Bayes error for a chosen task versus the total number of examples $n$ for all tasks $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $n$ for each task $", "histories": [["v1", "Fri, 2 Nov 2012 12:46:24 GMT  (137kb,D)", "http://arxiv.org/abs/1211.0439v1", "9 pages, to appear in Advances in Neural Information Processing Systems 25"]], "COMMENTS": "9 pages, to appear in Advances in Neural Information Processing Systems 25", "reviews": [], "SUBJECTS": "cs.LG cond-mat.dis-nn stat.ML", "authors": ["peter sollich", "simon r f ashton"], "accepted": true, "id": "1211.0439"}, "pdf": {"name": "1211.0439.pdf", "metadata": {"source": "CRF", "title": "Learning curves for multi-task Gaussian process regression", "authors": ["Simon R F Ashton", "Peter Sollich"], "emails": ["peter.sollich@kcl.ac.uk"], "sections": [{"heading": "1 Introduction and motivation", "text": "Gaussian processes (GPs) [1] have been popular in the NIPS community for a number of years now, as one of the key non-parametric Bayesian inference approaches. In the simplest case one can use a GP prior when learning a function from data. In line with growing interest in multi-task or transfer learning, where relatedness between tasks is used to aid learning of the individual tasks (see e.g. [2, 3]), GPs have increasingly also been used in a multi-task setting. A number of different choices of covariance functions have been proposed [4, 5, 6, 7, 8]. These differ e.g. in assumptions on whether the functions to be learned are related to a smaller number of latent functions or have free-form inter-task correlations; for a recent review see [9].\nGiven this interest in multi-task GPs, one would like to quantify the benefits that they bring compared to single-task learning. PAC-style bounds for classification [2, 3, 10] in more general multi-task scenarios exist, but there has been little work on average case analysis. The basic question in this setting is: how does the Bayes error on a given task depend on the number of training examples for all tasks, when averaged over all data sets of the given size. For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20]. Already two-task GP regression is much more difficult to analyse, and progress was made only very recently at NIPS 2009 [21], where upper and lower bounds for learning curves were derived. The tightest of these bounds, however, either required evaluation by Monte Carlo sampling, or assumed knowledge of the corresponding single-task learning curves. Here our aim is to obtain accurate learning curve approximations that apply to an arbitrary number T of tasks, and that can be evaluated explicitly without recourse to sampling.\nar X\niv :1\n21 1.\n04 39\nv1 [\ncs .L\nG ]\n2 N\nov 2\nWe begin (Sec. 2) by expressing the Bayes error for any single task in a multi-task GP regression problem in a convenient feature space form, where individual training examples enter additively. This requires the introduction of a non-trivial tensor structure combining feature space components and tasks. Considering the change in error when adding an example for some task leads to partial differential equations linking the Bayes errors for all tasks. Solving these using the method of characteristics then gives, as our primary result, the desired learning curve approximation (Sec. 3). In Sec. 4 we discuss some of its predictions. The approximation correctly delineates the limits of pure transfer learning, when all examples are from tasks other than the one of interest. Next we compare with numerical simulations for some two-task scenarios, finding good qualitative agreement. These results also highlight a surprising feature, namely that asymptotically the relatedness between tasks can become much less useful. We analyse this effect in some detail, showing that it is most extreme for learning of smooth functions. Finally we discuss the case of many tasks, where there is an unexpected separation of the learning curves into a fast initial error decay arising from \u201ccollective learning\u201d, and a much slower final part where tasks are learned almost independently."}, {"heading": "2 GP regression and Bayes error", "text": "We consider GP regression for T functions f\u03c4 (x), \u03c4 = 1, 2, . . . , T . These functions have to be learned from n training examples (x`, \u03c4`, y`), ` = 1, . . . , n. Here x` is the training input, \u03c4` \u2208 {1, . . . , T} denotes which task the example relates to, and y` is the corresponding training output. We assume that the latter is given by the target function value f\u03c4`(x`) corrupted by i.i.d. additive Gaussian noise with zero mean and variance \u03c32\u03c4` . This setup allows the noise level \u03c3 2 \u03c4 to depend on the task.\nIn GP regression the prior over the functions f\u03c4 (x) is a Gaussian process. This means that for any set of inputs x` and task labels \u03c4`, the function values {f\u03c4`(x`)} have a joint Gaussian distribution. As is common we assume this to have zero mean, so the multi-task GP is fully specified by the covariances \u3008f\u03c4 (x)f\u03c4 \u2032(x\u2032)\u3009 = C(\u03c4, x, \u03c4 \u2032, x\u2032). For this covariance we take the flexible form from [5], \u3008f\u03c4 (x)f\u03c4 \u2032(x\u2032)\u3009 = D\u03c4\u03c4 \u2032C(x, x\u2032). Here C(x, x\u2032) determines the covariance between function values at different input points, encoding \u201cspatial\u201d behaviour such as smoothness and the lengthscale(s) over which the functions vary, while the matrixD is a free-form inter-task covariance matrix.\nOne of the attractions of GPs for regression is that, even though they are non-parametric models with (in general) an infinite number of degrees of freedom, predictions can be made in closed form, see e.g. [1]. For a test point x for task \u03c4 , one would predict as output the mean of f\u03c4 (x) over the (Gaussian) posterior, which is yTK\u22121k\u03c4 (x). Here K is the n \u00d7 n Gram matrix with entries K`m = D\u03c4`\u03c4mC(x`, xm)+\u03c3 2 \u03c4` \u03b4`m, while k\u03c4 (x) is a vector with the n entries k\u03c4,` = D\u03c4`\u03c4C(x`, x). The error bar would be taken as the square root of the posterior variance of f\u03c4 (x), which is\nV\u03c4 (x) = D\u03c4\u03c4C(x, x)\u2212 kT\u03c4 (x)K\u22121k\u03c4 (x) (1) The learning curve for task \u03c4 is defined as the mean-squared prediction error, averaged over the location of test input x and over all data sets with a specified number of examples for each task, say n1 for task 1 and so on. As is standard in learning curve analysis we consider a matched scenario where the training outputs y` are generated from the same prior and noise model that we use for inference. In this case the mean-squared prediction error \u0302\u03c4 is the Bayes error, and is given by the average posterior variance [1], i.e. \u0302\u03c4 = \u3008V\u03c4 (x)\u3009x. To obtain the learning curve this is averaged over the location of the training inputs x`: \u03c4 = \u3008\u0302\u03c4 \u3009. This average presents the main challenge for learning curve prediction because the training inputs feature in a highly nonlinear way in V\u03c4 (x). Note that the training outputs, on the other hand, do not appear in the posterior variance V\u03c4 (x) and so do not need to be averaged over.\nWe now want to write the Bayes error \u0302\u03c4 in a form convenient for performing, at least approximately, the averages required for the learning curve. Assume that all training inputs x`, and also the test input x, are drawn from the same distribution P (x). One can decompose the input-dependent part of the covariance function into eigenfunctions relative to P (x), according to C(x, x\u2032) =\u2211 i \u03bbi\u03c6i(x)\u03c6i(x\n\u2032). The eigenfunctions are defined by the condition \u3008C(x, x\u2032)\u03c6i(x\u2032)\u3009x\u2032 = \u03bbi\u03c6i(x) and can be chosen to be orthonormal with respect to P (x), \u3008\u03c6i(x)\u03c6j(x)\u3009x = \u03b4ij . The sum over i here is in general infinite (unless the covariance function is degenerate, as e.g. for the dot product kernel C(x, x\u2032) = x \u00b7 x\u2032). To make the algebra below as simple as possible, we let the eigenvalues \u03bbi be arranged in decreasing order and truncate the sum to the finite range i = 1, . . . ,M ; M is then some large effective feature space dimension and can be taken to infinity at the end.\nIn terms of the above eigenfunction decomposition, the Gram matrix has elements K`m = D\u03c4`\u03c4m \u2211 i \u03bbi\u03c6i(x`)\u03c6i(xm)+\u03c3 2 \u03c4` \u03b4`m = \u2211 i,\u03c4,j,\u03c4 \u2032 \u03b4\u03c4`,\u03c4\u03c6i(x`)\u03bbi\u03b4ijD\u03c4\u03c4 \u2032\u03c6j(xm)\u03b4\u03c4 \u2032,\u03c4m+\u03c3 2 \u03c4` \u03b4`m\nor in matrix formK = \u03a8L\u03a8T + \u03a3 where \u03a3 is the diagonal matrix from the noise variances and\n\u03a8`,i\u03c4 = \u03b4\u03c4`,\u03c4\u03c6i(x`), Li\u03c4,j\u03c4 \u2032 = \u03bbi\u03b4ijD\u03c4\u03c4 \u2032 (2)\nHere \u03a8 has its second index ranging over M (number of kernel eigenvalues) times T (number of tasks) values; L is a square matrix of this size. In Kronecker (tensor) product notation, L = D\u2297\u039b if we define \u039b as the diagonal matrix with entries \u03bbi\u03b4ij . The Kronecker product is convenient for the simplifications below; we will use that for generic square matrices, (A \u2297 B)(A\u2032 \u2297 B\u2032) = (AA\u2032)\u2297 (BB\u2032), (A\u2297B)\u22121 = A\u22121 \u2297B\u22121, and tr (A\u2297B) = (trA)(trB). In thinking about the mathematical expressions, it is often easier to picture Kronecker products over feature spaces and tasks as block matrices. For example, L can then be viewed as consisting of T \u00d7T blocks, each of which is proportional to \u039b.\nTo calculate the Bayes error, we need to average the posterior variance V\u03c4 (x) over the test input x. The first term in (1) then becomesD\u03c4\u03c4 \u3008C(x, x)\u3009 = D\u03c4\u03c4 tr\u039b. In the second one, we need to average\n\u3008k\u03c4,`(x)k\u03c4,m\u3009x = D\u03c4\u03c4`\u3008C(x`, x)C(x, xm)\u3009xD\u03c4m\u03c4 = D\u03c4\u03c4` \u2211 ij \u03bbi\u03bbj\u03c6i(x`)\u3008\u03c6i(x)\u03c6j(x)\u3009x\u03c6j(xm)D\u03c4m\u03c4\n= \u2211\ni,\u03c4 \u2032,j,\u03c4 \u2032\u2032\nD\u03c4\u03c4 \u2032\u03a8l,i\u03c4 \u2032\u03bbi\u03bbj\u03b4ij\u03a8m,j\u03c4 \u2032\u2032D\u03c4 \u2032\u2032\u03c4\nIn matrix form this is \u3008k\u03c4 (x)kT\u03c4 (x)\u3009x = \u03a8[(De\u03c4eT\u03c4D) \u2297 \u039b2]\u03a8T = \u03a8M\u03c4\u03a8T Here the last equality defines M\u03c4 , and we have denoted by e\u03c4 the T -dimensional vector with \u03c4 -th component equal to one and all others zero. Multiplying by the inverse Gram matrix K\u22121 and taking the trace gives the average of the second term in (1); combining with the first gives the Bayes error on task \u03c4\n\u0302\u03c4 = \u3008V\u03c4 (x)\u3009x = D\u03c4\u03c4 tr\u039b\u2212 tr\u03a8M\u03c4\u03a8T(\u03a8L\u03a8T + \u03a3)\u22121\nApplying the Woodbury identity and re-arranging yields\n\u0302\u03c4 = D\u03c4\u03c4 tr\u039b\u2212 trM\u03c4\u03a8T\u03a3\u22121\u03a8(I +L\u03a8T\u03a3\u22121\u03a8)\u22121\n= D\u03c4\u03c4 tr\u039b\u2212 trM\u03c4L\u22121[I \u2212 (I +L\u03a8T\u03a3\u22121\u03a8)\u22121]\nBut\ntrM\u03c4L \u22121 = tr {[(De\u03c4eT\u03c4D)\u2297\u039b2][D \u2297\u039b]\u22121}\n= tr {[De\u03c4eT\u03c4 ]\u2297\u039b} = eT\u03c4De\u03c4 tr\u039b = D\u03c4\u03c4 tr\u039b\nso the first and second terms in the expression for \u0302\u03c4 cancel and one has\n\u0302\u03c4 = trM\u03c4L \u22121(I +L\u03a8T\u03a3\u22121\u03a8)\u22121 = trL\u22121M\u03c4L \u22121(L\u22121 + \u03a8T\u03a3\u22121\u03a8)\u22121\n= tr [D \u2297\u039b]\u22121[(De\u03c4eT\u03c4D)\u2297\u039b2][D \u2297\u039b]\u22121(L\u22121 + \u03a8T\u03a3\u22121\u03a8)\u22121 = tr [e\u03c4e T \u03c4 \u2297 I](L\u22121 + \u03a8T\u03a3\u22121\u03a8)\u22121\nThe matrix in square brackets in the last line is just a projector P\u03c4 onto task \u03c4 ; thought of as a matrix of T \u00d7T blocks (each of size M \u00d7M ), this has an identity matrix in the (\u03c4, \u03c4) block while all other blocks are zero. We can therefore write, finally, for the Bayes error on task \u03c4 ,\n\u0302\u03c4 = trP\u03c4 (L \u22121 + \u03a8T\u03a3\u22121\u03a8)\u22121 (3)\nBecause \u03a3 is diagonal and given the definition (2) of \u03a8, the matrix \u03a8T\u03a3\u22121\u03a8 is a sum of contributions from the individual training examples ` = 1, . . . , n. This will be important for deriving the learning curve approximation below. We note in passing that, because \u2211 \u03c4 P\u03c4 = I , the sum of the\nBayes errors on all tasks is \u2211 \u03c4 \u0302\u03c4 = tr (L\n\u22121+\u03a8T\u03a3\u22121\u03a8)\u22121, in close analogy to the corresponding expression for the single-task case [13]."}, {"heading": "3 Learning curve prediction", "text": "To obtain the learning curve \u03c4 = \u3008\u0302\u03c4 \u3009, we now need to carry out the average \u3008. . .\u3009 over the training inputs. To help with this, we can extend an approach for the single-task scenario [13] and define a response or resolvent matrix G = (L\u22121 + \u03a8T\u03a3\u22121\u03a8 + \u2211 \u03c4 v\u03c4P\u03c4 )\n\u22121 with auxiliary parameters v\u03c4 that will be set back to zero at the end. One can then ask how G = \u3008G\u3009 and hence \u03c4 \u2032 = trP\u03c4 \u2032G changes with the number n\u03c4 of training points for task \u03c4 . Adding an example at position x for task \u03c4 increases \u03a8T\u03a3\u22121\u03a8 by \u03c3\u22122\u03c4 \u03c6\u03c4\u03c6 T \u03c4 , where \u03c6\u03c4 has elements (\u03c6\u03c4 )i\u03c4 \u2032 = \u03c6i(x)\u03b4\u03c4\u03c4 \u2032 . Evaluating the difference (G\u22121 + \u03c3\u22122\u03c4 \u03c6\u03c4\u03c6T\u03c4 )\u22121 \u2212 G with the help of the Woodbury identity and approximating it with a derivative gives\n\u2202G \u2202n\u03c4 = \u2212 G\u03c6\u03c4\u03c6 T \u03c4 G \u03c32\u03c4 + \u03c6 T \u03c4 G\u03c6\u03c4\nThis needs to be averaged over the new example and all previous ones. If we approximate by averaging numerator and denominator separately we get\n\u2202G \u2202n\u03c4 =\n1\n\u03c32\u03c4 + trP\u03c4G\n\u2202G \u2202v\u03c4 (4)\nHere we have exploited for the average over x that the matrix \u3008\u03c6\u03c4\u03c6T\u03c4 \u3009x has (i, \u03c4 \u2032), (j, \u03c4 \u2032\u2032)-entry \u3008\u03c6i(x)\u03c6j(x)\u3009x\u03b4\u03c4\u03c4 \u2032\u03b4\u03c4\u03c4 \u2032\u2032 = \u03b4ij\u03b4\u03c4\u03c4 \u2032\u03b4\u03c4\u03c4 \u2032\u2032 , hence simply \u3008\u03c6\u03c4\u03c6T\u03c4 \u3009x = P\u03c4 . We have also used the auxiliary parameters to rewrite \u2212\u3008GP\u03c4G\u3009 = \u2202\u3008G\u3009/\u2202v\u03c4 = \u2202G/\u2202v\u03c4 . Finally, multiplying (4) by P\u03c4 \u2032 and taking the trace gives the set of quasi-linear partial differential equations\n\u2202 \u03c4 \u2032 \u2202n\u03c4 =\n1\n\u03c32\u03c4 + \u03c4\n\u2202 \u03c4 \u2032 \u2202v\u03c4 (5)\nThe remaining task is now to find the functions \u03c4 (n1, . . . , nT , v1, . . . , vT ) by solving these differential equations. We initially attempted to do this by tracking the \u03c4 as examples are added one task at a time, but the derivation is laborious already for T = 2 and becomes prohibitive beyond. Far more elegant is to adapt the method of characteristics to the present case. We need to find a 2T -dimensional surface in the 3T -dimensional space (n1, . . . , nT , v1, . . . , vT , 1, . . . , T ), which is specified by the T functions \u03c4 (. . .). A small change (\u03b4n1, . . . , \u03b4nT , \u03b4v1, . . . , \u03b4vT , \u03b4 1, . . . , \u03b4 T ) in all 3T coordinates is tangential to this surface if it obeys the T constraints (one for each \u03c4 \u2032)\n\u03b4 \u03c4 \u2032 = \u2211 \u03c4 ( \u2202 \u03c4 \u2032 \u2202n\u03c4 \u03b4n\u03c4 + \u2202 \u03c4 \u2032 \u2202v\u03c4 \u03b4v\u03c4 ) From (5), one sees that this condition is satisfied whenever \u03b4 \u03c4 = 0 and \u03b4n\u03c4 = \u2212\u03b4v\u03c4 (\u03c32\u03c4 + \u03c4 ) It follows that all the characteristic curves given by \u03c4 (t) = \u03c4,0 = const., v\u03c4 (t) = v\u03c4,0(1 \u2212 t), n\u03c4 (t) = v\u03c4,0(\u03c3 2 \u03c4 + \u03c4,0) t for t \u2208 [0, 1] are tangential to the solution surface for all t, so lie within this surface if the initial point at t = 0 does. Because at t = 0 there are no training examples (n\u03c4 (0) = 0), this initial condition is satisfied by setting\n\u03c4,0 = trP\u03c4\n( L\u22121 +\n\u2211 \u03c4 \u2032 v\u03c4 \u2032,0P\u03c4 \u2032 )\u22121 Because \u03c4 (t) is constant along the characteristic curve, we get by equating the values at t = 0 and t = 1\n\u03c4,0 = trP\u03c4\n( L\u22121 +\n\u2211 \u03c4 \u2032 v\u03c4 \u2032,0P\u03c4 \u2032 )\u22121 = \u03c4 ({n\u03c4 \u2032 = v\u03c4 \u2032,0(\u03c32\u03c4 \u2032 + \u03c4 \u2032,0)}, {v\u03c4 \u2032 = 0})\nExpressing v\u03c4 \u2032,0 in terms of n\u03c4 \u2032 gives then\n\u03c4 = trP\u03c4\n( L\u22121 +\n\u2211 \u03c4 \u2032 n\u03c4 \u2032 \u03c32\u03c4 \u2032 + \u03c4 \u2032 P\u03c4 \u2032\n)\u22121 (6)\nThis is our main result: a closed set of T self-consistency equations for the average Bayes errors \u03c4 . Given L as defined by the eigenvalues \u03bbi of the covariance function, the noise levels \u03c32\u03c4 and the\nnumber of examples n\u03c4 for each task, it is straightforward to solve these equations numerically to find the average Bayes error \u03c4 for each task.\nThe r.h.s. of (6) is easiest to evaluate if we view the matrix inside the brackets as consisting of M \u00d7M blocks of size T \u00d7T (which is the reverse of the picture we have used so far). The matrix is then block diagonal, with the blocks corresponding to different eigenvalues \u03bbi. Explicitly, because L\u22121 = D\u22121 \u2297\u039b\u22121, one has\n\u03c4 = \u2211 i ( \u03bb\u22121i D \u22121 + diag({ n\u03c4 \u2032 \u03c32\u03c4 \u2032 + \u03c4 \u2032 }) )\u22121 \u03c4\u03c4\n(7)"}, {"heading": "4 Results and discussion", "text": "We now consider the consequences of the approximate prediction (7) for multi-task learning curves in GP regression. A trivial special case is the one of uncorrelated tasks, where D is diagonal. Here one recovers T separate equations for the individual tasks as expected, which have the same form as for single-task learning [13]."}, {"heading": "4.1 Pure transfer learning", "text": "Consider now the case of pure transfer learning, where one is learning a task of interest (say \u03c4 = 1) purely from examples for other tasks. What is the lowest average Bayes error that can be obtained? Somewhat more generally, suppose we have no examples for the first T0 tasks, n1 = . . . = nT0 = 0, but a large number of examples for the remaining T1 = T \u2212 T0 tasks. Denote E = D\u22121 and write this in block form as\nE = ( E00 E01 ET01 E11 ) Now multiply by \u03bb\u22121i and add in the lower right block a diagonal matrix N = diag({n\u03c4/(\u03c32\u03c4 + \u03c4 )}\u03c4=T0+1,...,T ). The matrix inverse in (7) then has top left block \u03bbi[E\u2212100 + E \u22121 00 E01(\u03bbiN + E11 \u2212ET01E\u2212100 E01)\u22121ET01E \u22121 00 ]. As the number of examples for the last T1 tasks grows, so do all (diagonal) elements of N . In the limit only the term \u03bbiE\u2212100 survives, and summing over i gives 1 = tr\u039b(E \u22121 00 )11 = \u3008C(x, x)\u3009(E \u22121 00 )11. The Bayes error on task 1 cannot become lower than this, placing a limit on the benefits of pure transfer learning. That this prediction of the approximation (7) for such a lower limit is correct can also be checked directly: once the last T1 tasks f\u03c4 (x) (\u03c4 = T0 + 1, . . . T ) have been learn perfectly, the posterior over the first T0 functions is, by standard Gaussian conditioning, a GP with covariance C(x, x\u2032)(E00)\u22121. Averaging the posterior variance of f1(x) then gives the Bayes error on task 1 as 1 = \u3008C(x, x)\u3009(E\u2212100 )11, as found earlier. This analysis can be extended to the case where there are some examples available also for the first T0 tasks. One finds for the generalization errors on these tasks the prediction (7) withD\u22121 replaced by E00. This is again in line with the above form of the GP posterior after perfect learning of the remaining T1 tasks."}, {"heading": "4.2 Two tasks", "text": "We next analyse how well the approxiation (7) does in predicting multi-task learning curves for T = 2 tasks. Here we have the work of Chai [21] as a baseline, and as there we choose\nD = ( 1 \u03c1 \u03c1 1 ) The diagonal elements are fixed to unity, as in a practical application where one would scale both task functions f1(x) and f2(x) to unit variance; the degree of correlation of the tasks is controlled by \u03c1. We fix \u03c02 = n2/n and plot learning curves against n. In numerical simulations we ensure integer values of n1 and n2 by setting n2 = bn\u03c02c, n1 = n \u2212 n2; for evaluation of (7) we use directly n2 = n\u03c02, n1 = n(1\u2212 \u03c02). For simplicity we consider equal noise levels \u03c321 = \u03c322 = \u03c32. As regards the covariance function and input distribution, we analyse first the scenario studied in [21]: a squared exponential (SE) kernel C(x, x\u2032) = exp[\u2212(x \u2212 x\u2032)2/(2l2)] with lengthscale l, and one-dimensional inputs x with a Gaussian distributionN (0, 1/12). The kernel eigenvalues \u03bbi\nare known explicitly from [22] and decay exponentially with i. Figure 1(left) compares numerically simulated learning curves with the predictions for 1, the average Bayes error on task 1, from (7). Five pairs of curves are shown, for \u03c12 = 0, 0.25, 0.5, 0.75, 1. Note that the two extreme values represent single-task limits, where examples from task 2 are either ignored (\u03c1 = 0) or effectively treated as being from task 1 (\u03c1 = 1). Our predictions lie generally below the true learning curves, but qualitatively represent the trends well, in particular the variation with \u03c12. The curves for the different \u03c12 values are fairly evenly spaced vertically for small number of examples, n, corresponding to a linear dependence on \u03c12. As n increases, however, the learning curves for \u03c1 < 1 start to bunch together and separate from the one for the fully correlated case (\u03c1 = 1). The approximation (7) correctly captures this behaviour, which is discussed in more detail below.\nFigure 1(middle) has analogous results for the case of inputs x uniformly distributed on the interval [0, 1]; the \u03bbi here decay exponentially with i2 [17]. Quantitative agreement between simulations and predictions is better for this case. The discussion in [17] suggests that this is because the approximation method we have used implicitly neglects spatial variation of the dataset-averaged posterior variance \u3008V\u03c4 (x)\u3009; but for a uniform input distribution this variation will be weak except near the ends of the input range [0, 1]. Figure 1(right) displays similar results for an OU kernel C(x, x\u2032) = exp(\u2212|x \u2212 x\u2032|/l), showing that our predictions also work well when learning rough (nowhere differentiable) functions."}, {"heading": "4.3 Asymptotic uselessness", "text": "The two-task results above suggest that multi-task learning is less useful asymptotically: when the number of training examples n is large, the learning curves seem to bunch towards the curve for \u03c1 = 0, where task 2 examples are ignored, except when the two tasks are fully correlated (\u03c1 = 1). We now study this effect.\nWhen the number of examples for all tasks becomes large, the Bayes errors \u03c4 will become small and eventually be negligible compared to the noise variances \u03c32\u03c4 in (7). One then has an explicit prediction for each \u03c4 , without solving T self-consistency equations. If we write, for T tasks, n\u03c4 = n\u03c0\u03c4 with \u03c0\u03c4 the fraction of examples for task \u03c4 , and set \u03b3\u03c4 = \u03c0\u03c4/\u03c32\u03c4 , then for large n\n\u03c4 = \u2211 i ( \u03bb\u22121i D \u22121 + n\u0393 )\u22121 \u03c4\u03c4 = \u2211 i(\u0393 \u22121/2[\u03bb\u22121i (\u0393 1/2D\u03931/2)\u22121 + nI]\u22121\u0393\u22121/2)\u03c4\u03c4 (8)\nwhere \u0393 = diag(\u03b31, . . . , \u03b3T ). Using an eigendecomposition of the symmetric matrix \u03931/2D\u03931/2 =\u2211T a=1 \u03b4avav T a , one then shows in a few lines that (8) can be written as\n\u03c4 \u2248 \u03b3\u22121\u03c4 \u2211 a(va,\u03c4 ) 2\u03b4ag(n\u03b4a) (9)\nwhere g(h) = tr (\u039b\u22121 + h)\u22121 = \u2211 i(\u03bb \u22121 i + h)\n\u22121 and va,\u03c4 is the \u03c4 -th component of the a-th eigenvector va. This is the general asymptotic form of our prediction for the average Bayes error for task \u03c4 .\nTo get a more explicit result, consider the case where sample functions from the GP prior have (mean-square) derivatives up to order r. The kernel eigenvalues \u03bbi then decay as1 i\u2212(2r+2) for large i, and using arguments from [17] one deduces that g(h) \u223c h\u2212\u03b1 for large h, with \u03b1 = (2r+1)/(2r+ 2). In (9) we can then write, for large n, g(n\u03b4a) \u2248 (\u03b4a/\u03b3\u03c4 )\u2212\u03b1g(n\u03b3\u03c4 ) and hence\n\u03c4 \u2248 g(n\u03b3\u03c4 ){ \u2211 a(va,\u03c4 ) 2(\u03b4a/\u03b3\u03c4 ) 1\u2212\u03b1} (10)\nWhen there is only a single task, \u03b41 = \u03b31 and this expression reduces to 1 = g(n\u03b31) = g(n1/\u03c321). Thus g(n\u03b3\u03c4 ) = g(n\u03c4/\u03c32\u03c4 ) is the error we would get by ignoring all examples from tasks other than \u03c4 , and the term in {. . .} in (10) gives the \u201cmulti-task gain\u201d, i.e. the factor by which the error is reduced because of examples from other tasks. (The absolute error reduction always vanishes trivially for n\u2192\u221e, along with the errors themselves.) One observation can be made directly. Learning of very smooth functions, as defined e.g. by the SE kernel, corresponds to r \u2192 \u221e and hence \u03b1 \u2192 1, so the multi-task gain tends to unity: multi-task learning is asymptotically useless. The only exception occurs when some of the tasks are fully correlated, because one or more of the eigenvalues \u03b4a of \u03931/2D\u03931/2 will then be zero.\nFig. 2(left) shows this effect in action, plotting Bayes error against \u03c12 for the two-task setting of Fig. 1(left) with n = 500. Our predictions capture the nonlinear dependence on \u03c12 quite well, though the effect is somewhat weaker in the simulations. For larger n the predictions approach a curve that is constant for \u03c1 < 1, signifying negligible improvement from multi-task learning except at \u03c1 = 1. It is worth contrasting this with the lower bound from [21], which is linear in \u03c12. While this provides a very good approximation to the learning curves for moderate n [21], our results here show that asymptotically this bound can become very loose.\nWhen predicting rough functions, there is some asymptotic improvement to be had from multi-task learning, though again the multi-task gain is nonlinear in \u03c12: see Fig. 2(left, inset) for the OU case, which has r = 1). A simple expression for the gain can be obtained in the limit of many tasks, to which we turn next.\n1 See the discussion of Sacks-Ylvisaker conditions in e.g. [1]; we consider one-dimensional inputs here though the discussion can be generalized."}, {"heading": "4.4 Many tasks", "text": "We assume as for the two-task case that all inter-task correlations, D\u03c4,\u03c4 \u2032 with \u03c4 6= \u03c4 \u2032, are equal to \u03c1, while D\u03c4,\u03c4 = 1. This setup was used e.g. in [23], and can be interpreted as each task having a component proportional to \u221a \u03c1 of a shared latent function, with an independent task-specific signal\nin addition. We assume for simplicity that we have the same number n\u03c4 = n/T of examples for each task, and that all noise levels are the same, \u03c32\u03c4 = \u03c3\n2. Then also all Bayes errors \u03c4 = will be the same. Carrying out the matrix inverses in (7) explicitly, one can then write this equation as\n= gT (n/(\u03c3 2 + ), \u03c1) (11)\nwhere gT (h, \u03c1) is related to the single-task function g(h) from above by\ngT (h, \u03c1) = T \u2212 1 T\n(1\u2212 \u03c1)g(h(1\u2212 \u03c1)/T ) + ( \u03c1+\n1\u2212 \u03c1 T\n) g(h[\u03c1+ (1\u2212 \u03c1)/T ]) (12)\nNow consider the limit T \u2192 \u221e of many tasks. If n and hence h = n/(\u03c32 + ) is kept fixed, gT (h, \u03c1) \u2192 (1 \u2212 \u03c1) + \u03c1g(h\u03c1); here we have taken g(0) = 1 which corresponds to tr\u039b = \u3008C(x, x)\u3009x = 1 as in the examples above. One can then deduce from (11) that the Bayes error for any task will have the form = (1\u2212\u03c1)+\u03c1\u0303, where \u0303 decays from one to zero with increasing n as for a single task, but with an effective noise level \u03c3\u03032 = (1\u2212 \u03c1+ \u03c32)/\u03c1. Remarkably, then, even though here n/T \u2192 0 so that for most tasks no examples have been seen, the Bayes error for each task decreases by \u201ccollective learning\u201d to a plateau of height 1\u2212\u03c1. The remaining decay of to zero happens only once n becomes of order T . Here one can show, by taking T \u2192\u221e at fixed h/T in (12) and inserting into (11), that = (1 \u2212 \u03c1)\u0304 where \u0304 again decays as for a single task but with an effective number of examples n\u0304 = n/T and effective noise level \u03c3\u03042/(1\u2212 \u03c1). This final stage of learning therefore happens only when each task has seen a considerable number of exampes n/T . Fig. 2(right) validates these predictions against simulations, for a number of tasks (T = 200) that is in the same ballpark as in the many-tasks application example of [24]. The inset for T = 1000 shows clearly how the two learning curve stages separate as T becomes larger.\nFinally we can come back to the multi-task gain in the asymptotic stage of learning. For GP priors with sample functions with derivatives up to order r as before, the function \u0304 from above will decay as (n\u0304/\u03c3\u03042)\u2212\u03b1; since = (1 \u2212 \u03c1)\u0304 and \u03c3\u03042 = \u03c32/(1 \u2212 \u03c1), the Bayes error is then proportional to (1 \u2212 \u03c1)1\u2212\u03b1. This multi-task gain again approaches unity for \u03c1 < 1 for smooth functions (\u03b1 = (2r + 1)/(2r + 2) \u2192 1). Interestingly, for rough functions (\u03b1 < 1), the multi-task gain decreases for small \u03c12 as 1 \u2212 (1 \u2212 \u03b1) \u221a \u03c12 and so always lies below a linear dependence on \u03c12 initially. This shows that a linear-in-\u03c12 lower error bound cannot generally apply to T > 2 tasks, and indeed one can verify that the derivation in [21] does not extend to this case."}, {"heading": "5 Conclusion", "text": "We have derived an approximate prediction (7) for learning curves in multi-task GP regression, valid for arbitrary inter-task correlation matrices D. This can be evaluated explicitly knowing only the kernel eigenvalues, without sampling or recourse to single-task learning curves. The approximation shows that pure transfer learning has a simple lower error bound, and provides a good qualitative account of numerically simulated learning curves. Because it can be used to study the asymptotic behaviour for large training sets, it allowed us to show that multi-task learning can become asymptotically useless: when learning smooth functions it reduces the asymptotic Bayes error only if tasks are fully correlated. For the limit of many tasks we found that, remarkably, some initial \u201ccollective learning\u201d is possible even when most tasks have not seen examples. A much slower second learning stage then requires many examples per task. The asymptotic regime of this also showed explicitly that a lower error bound that is linear in \u03c12, the square of the inter-task correlation, is applicable only to the two-task setting T = 2.\nIn future work it would be interesting to use our general result to investigate in more detail the consequences of specific choices for the inter-task correlationsD, e.g. to represent a lower-dimensional latent factor structure. One could also try to deploy similar approximation methods to study the case of model mismatch, where the inter-task correlations D would have to be learned from data. More challenging, but worthwhile, would be an extension to multi-task covariance functions where task and input-space correlations to not factorize."}], "references": [{"title": "Gaussian Processes for Machine Learning", "author": ["C K I Williams", "C Rasmussen"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2006}, {"title": "A model of inductive bias learning", "author": ["J Baxter"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2000}, {"title": "A notion of task relatedness yielding provable multiple-task learning guarantees", "author": ["S Ben-David", "R S Borbely"], "venue": "Mach. Learn.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Semiparametric latent factor models", "author": ["Y W Teh", "M Seeger", "M I Jordan"], "venue": "In Workshop on Artificial Intelligence and Statistics", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2005}, {"title": "Kernel multi-task learning using task-specific features", "author": ["E V Bonilla", "F V Agakov", "C K I Williams"], "venue": "In Proceedings of the 11th International Conference on Artificial Intelligence and Statistics (AISTATS). Omni Press,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "Multi-task Gaussian process prediction", "author": ["E V Bonilla", "K M A Chai", "C K I Williams"], "venue": "editors, NIPS", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "Sparse convolved Gaussian processes for multi-output regression", "author": ["M Alvarez", "N D Lawrence"], "venue": "editors, NIPS", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Focused multi-task learning using Gaussian processes", "author": ["G Leen", "J Peltonen", "S Kaski"], "venue": "Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Kernels for vector-valued functions: a review", "author": ["M A \u00c1lvarez", "L Rosasco", "N D Lawrence"], "venue": "Foundations and Trends in Machine Learning,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "Bounds for linear multi-task learning", "author": ["A Maurer"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}, {"title": "General bounds on Bayes errors for regression with Gaussian processes", "author": ["M Opper", "F Vivarelli"], "venue": "editors, NIPS", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1999}, {"title": "Finite-dimensional approximation of Gaussian processes", "author": ["G F Trecate", "C K I Williams", "M Opper"], "venue": "editors, NIPS", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1999}, {"title": "Learning curves for Gaussian processes", "author": ["P Sollich"], "venue": "NIPS 11,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1999}, {"title": "Learning curves for Gaussian processes regression: A framework for good approximations", "author": ["D Malzahn", "M Opper"], "venue": "editors, NIPS", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2001}, {"title": "A variational approach to learning curves", "author": ["D Malzahn", "M Opper"], "venue": "editors, NIPS", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2002}, {"title": "Statistical mechanics of learning: a variational approach for real data", "author": ["D Malzahn", "M Opper"], "venue": "Phys. Rev. Lett.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2002}, {"title": "Learning curves for Gaussian process regression: approximations and bounds", "author": ["P Sollich", "A Halees"], "venue": "Neural Comput.,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2002}, {"title": "Gaussian process regression with mismatched models", "author": ["P Sollich"], "venue": "editors, NIPS", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2002}, {"title": "Can Gaussian process regression be made robust against model mismatch? In Deterministic and Statistical Methods in Machine Learning, volume 3635 of Lecture Notes in Artificial Intelligence, pages 199\u2013210", "author": ["P Sollich"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2005}, {"title": "Exact larning curves for Gaussian process regression on large random graphs", "author": ["M Urry", "P Sollich"], "venue": "editors, NIPS", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2010}, {"title": "Generalization errors and learning curves for regression with multi-task Gaussian processes", "author": ["K M A Chai"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2009}, {"title": "Gaussian regression and optimal finite dimensional linear models", "author": ["H Zhu", "C K I Williams", "R J Rohwer", "M Morciniec"], "venue": "Neural Networks and Machine Learning. Springer,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1998}, {"title": "One-shot learning of object categories using dependent Gaussian processes", "author": ["E Rodner", "J Denzler"], "venue": "Pattern Recognition,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2010}, {"title": "Solving a huge number of similar tasks: a combination of multi-task learning and a hierarchical Bayesian approach", "author": ["T Heskes"], "venue": "In Proceedings of the Fifteenth International Conference on Machine Learning", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1998}], "referenceMentions": [{"referenceID": 0, "context": "Gaussian processes (GPs) [1] have been popular in the NIPS community for a number of years now, as one of the key non-parametric Bayesian inference approaches.", "startOffset": 25, "endOffset": 28}, {"referenceID": 1, "context": "[2, 3]), GPs have increasingly also been used in a multi-task setting.", "startOffset": 0, "endOffset": 6}, {"referenceID": 2, "context": "[2, 3]), GPs have increasingly also been used in a multi-task setting.", "startOffset": 0, "endOffset": 6}, {"referenceID": 3, "context": "A number of different choices of covariance functions have been proposed [4, 5, 6, 7, 8].", "startOffset": 73, "endOffset": 88}, {"referenceID": 4, "context": "A number of different choices of covariance functions have been proposed [4, 5, 6, 7, 8].", "startOffset": 73, "endOffset": 88}, {"referenceID": 5, "context": "A number of different choices of covariance functions have been proposed [4, 5, 6, 7, 8].", "startOffset": 73, "endOffset": 88}, {"referenceID": 6, "context": "A number of different choices of covariance functions have been proposed [4, 5, 6, 7, 8].", "startOffset": 73, "endOffset": 88}, {"referenceID": 7, "context": "A number of different choices of covariance functions have been proposed [4, 5, 6, 7, 8].", "startOffset": 73, "endOffset": 88}, {"referenceID": 8, "context": "in assumptions on whether the functions to be learned are related to a smaller number of latent functions or have free-form inter-task correlations; for a recent review see [9].", "startOffset": 173, "endOffset": 176}, {"referenceID": 1, "context": "PAC-style bounds for classification [2, 3, 10] in more general multi-task scenarios exist, but there has been little work on average case analysis.", "startOffset": 36, "endOffset": 46}, {"referenceID": 2, "context": "PAC-style bounds for classification [2, 3, 10] in more general multi-task scenarios exist, but there has been little work on average case analysis.", "startOffset": 36, "endOffset": 46}, {"referenceID": 9, "context": "PAC-style bounds for classification [2, 3, 10] in more general multi-task scenarios exist, but there has been little work on average case analysis.", "startOffset": 36, "endOffset": 46}, {"referenceID": 10, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 11, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 12, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 13, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 14, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 15, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 16, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 17, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 18, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 163, "endOffset": 199}, {"referenceID": 19, "context": "For a single regression task, this learning curve has become relatively well understood since the late 1990s, with a number of bounds and approximations available [11, 12, 13, 14, 15, 16, 17, 18, 19] as well as some exact predictions [20].", "startOffset": 234, "endOffset": 238}, {"referenceID": 20, "context": "Already two-task GP regression is much more difficult to analyse, and progress was made only very recently at NIPS 2009 [21], where upper and lower bounds for learning curves were derived.", "startOffset": 120, "endOffset": 124}, {"referenceID": 4, "context": "For this covariance we take the flexible form from [5], \u3008f\u03c4 (x)f\u03c4 \u2032(x\u2032)\u3009 = D\u03c4\u03c4 \u2032C(x, x\u2032).", "startOffset": 51, "endOffset": 54}, {"referenceID": 0, "context": "[1].", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "In this case the mean-squared prediction error \u000f\u0302\u03c4 is the Bayes error, and is given by the average posterior variance [1], i.", "startOffset": 118, "endOffset": 121}, {"referenceID": 12, "context": "We note in passing that, because \u2211 \u03c4 P\u03c4 = I , the sum of the Bayes errors on all tasks is \u2211 \u03c4 \u000f\u0302\u03c4 = tr (L \u22121+\u03a8T\u03a3\u22121\u03a8)\u22121, in close analogy to the corresponding expression for the single-task case [13].", "startOffset": 194, "endOffset": 198}, {"referenceID": 12, "context": "To help with this, we can extend an approach for the single-task scenario [13] and define a response or resolvent matrix G = (L\u22121 + \u03a8T\u03a3\u22121\u03a8 + \u2211 \u03c4 v\u03c4P\u03c4 ) \u22121 with auxiliary parameters v\u03c4 that will be set back to zero at the end.", "startOffset": 74, "endOffset": 78}, {"referenceID": 0, "context": ", v\u03c4 (t) = v\u03c4,0(1 \u2212 t), n\u03c4 (t) = v\u03c4,0(\u03c3 2 \u03c4 + \u03c4,0) t for t \u2208 [0, 1] are tangential to the solution surface for all t, so lie within this surface if the initial point at t = 0 does.", "startOffset": 61, "endOffset": 67}, {"referenceID": 12, "context": "Here one recovers T separate equations for the individual tasks as expected, which have the same form as for single-task learning [13].", "startOffset": 130, "endOffset": 134}, {"referenceID": 20, "context": "Here we have the work of Chai [21] as a baseline, and as there we choose", "startOffset": 30, "endOffset": 34}, {"referenceID": 20, "context": "As regards the covariance function and input distribution, we analyse first the scenario studied in [21]: a squared exponential (SE) kernel C(x, x\u2032) = exp[\u2212(x \u2212 x\u2032)2/(2l2)] with lengthscale l, and one-dimensional inputs x with a Gaussian distributionN (0, 1/12).", "startOffset": 100, "endOffset": 104}, {"referenceID": 21, "context": "are known explicitly from [22] and decay exponentially with i.", "startOffset": 26, "endOffset": 30}, {"referenceID": 0, "context": "Figure 1(middle) has analogous results for the case of inputs x uniformly distributed on the interval [0, 1]; the \u03bbi here decay exponentially with i [17].", "startOffset": 102, "endOffset": 108}, {"referenceID": 16, "context": "Figure 1(middle) has analogous results for the case of inputs x uniformly distributed on the interval [0, 1]; the \u03bbi here decay exponentially with i [17].", "startOffset": 149, "endOffset": 153}, {"referenceID": 16, "context": "The discussion in [17] suggests that this is because the approximation method we have used implicitly neglects spatial variation of the dataset-averaged posterior variance \u3008V\u03c4 (x)\u3009; but for a uniform input distribution this variation will be weak except near the ends of the input range [0, 1].", "startOffset": 18, "endOffset": 22}, {"referenceID": 0, "context": "The discussion in [17] suggests that this is because the approximation method we have used implicitly neglects spatial variation of the dataset-averaged posterior variance \u3008V\u03c4 (x)\u3009; but for a uniform input distribution this variation will be weak except near the ends of the input range [0, 1].", "startOffset": 287, "endOffset": 293}, {"referenceID": 16, "context": "The kernel eigenvalues \u03bbi then decay as1 i\u2212(2r+2) for large i, and using arguments from [17] one deduces that g(h) \u223c h\u2212\u03b1 for large h, with \u03b1 = (2r+1)/(2r+ 2).", "startOffset": 88, "endOffset": 92}, {"referenceID": 20, "context": "It is worth contrasting this with the lower bound from [21], which is linear in \u03c1.", "startOffset": 55, "endOffset": 59}, {"referenceID": 20, "context": "While this provides a very good approximation to the learning curves for moderate n [21], our results here show that asymptotically this bound can become very loose.", "startOffset": 84, "endOffset": 88}, {"referenceID": 0, "context": "[1]; we consider one-dimensional inputs here though the discussion can be generalized.", "startOffset": 0, "endOffset": 3}, {"referenceID": 22, "context": "in [23], and can be interpreted as each task having a component proportional to \u221a \u03c1 of a shared latent function, with an independent task-specific signal in addition.", "startOffset": 3, "endOffset": 7}, {"referenceID": 23, "context": "2(right) validates these predictions against simulations, for a number of tasks (T = 200) that is in the same ballpark as in the many-tasks application example of [24].", "startOffset": 163, "endOffset": 167}, {"referenceID": 20, "context": "This shows that a linear-in-\u03c1 lower error bound cannot generally apply to T > 2 tasks, and indeed one can verify that the derivation in [21] does not extend to this case.", "startOffset": 136, "endOffset": 140}], "year": 2012, "abstractText": "We study the average case performance of multi-task Gaussian process (GP) regression as captured in the learning curve, i.e. the average Bayes error for a chosen task versus the total number of examples n for all tasks. For GP covariances that are the product of an input-dependent covariance function and a free-form intertask covariance matrix, we show that accurate approximations for the learning curve can be obtained for an arbitrary number of tasks T . We use these to study the asymptotic learning behaviour for large n. Surprisingly, multi-task learning can be asymptotically essentially useless, in the sense that examples from other tasks help only when the degree of inter-task correlation, \u03c1, is near its maximal value \u03c1 = 1. This effect is most extreme for learning of smooth target functions as described by e.g. squared exponential kernels. We also demonstrate that when learning many tasks, the learning curves separate into an initial phase, where the Bayes error on each task is reduced down to a plateau value by \u201ccollective learning\u201d even though most tasks have not seen examples, and a final decay that occurs once the number of examples is proportional to the number of tasks.", "creator": "LaTeX with hyperref package"}}}