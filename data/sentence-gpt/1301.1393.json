{"id": "1301.1393", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Two New Definitions of Stable Models of Logic Programs with Generalized Quantifiers", "abstract": "We present alternative definitions of the first-order stable model semantics and its extension to incorporate generalized quantifiers by referring to the familiar notion of a reduct instead of referring to the SM operator in the original definitions. Also, we extend the FLP stable model semantics to allow generalized quantifiers by referring to an operator that is similar to the $\\sm$ operator. For a reasonable syntactic class of logic programs, we show that the two stable model semantics of generalized quantifiers are interchangeable. This simplifies our approach to a standard library-dependent semantics in the standard library of logic programs.\n\n\n\nThe most recent version of the Standard Library includes many versions of the standard library-dependent semantics in order to support the following definitions.\nThe Standard Library\nThe Standard Library\nThe Standard Library\nThe Standard Library\nFor the general purpose of providing a set of basic semantics for programming languages, we can also use the Standard Library in an alternative form:\nIn particular, it contains several alternative definitions of the standard library-dependent semantics in order to support the following definitions:\nTo support the following definitions of the standard library-dependent semantics, we may consider:\nTo support the following definition of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard library-dependent semantics, we may consider a standard library-dependent semantics for programming languages:\nTo support the following definitions of the standard", "histories": [["v1", "Tue, 8 Jan 2013 02:29:49 GMT  (17kb,D)", "http://arxiv.org/abs/1301.1393v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["joohyung lee", "yunsong meng"], "accepted": false, "id": "1301.1393"}, "pdf": {"name": "1301.1393.pdf", "metadata": {"source": "CRF", "title": "Two New Definitions of Stable Models of Logic Programs with Generalized Quantifiers", "authors": ["Joohyung Lee", "Yunsong Meng"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Most versions of the stable model semantics involve grounding. For instance, according to the FLP semantics from [1; 2], assuming that the domain is {\u22121, 1, 2}, program\np(2) \u2190 \u0131not SUM\u3008x :p(x)\u3009<2 p(\u22121) \u2190 SUM\u3008x :p(x)\u3009>\u22121 p(1) \u2190 p(\u22121)\n(1)\nis identified with its ground instance w.r.t the domain:\np(2) \u2190 \u0131not SUM\u3008{\u22121:p(\u22121), 1:p(1), 2:p(2)}\u3009<2 p(\u22121) \u2190 SUM\u3008{\u22121:p(\u22121), 1:p(1), 2:p(2)}\u3009>\u22121 p(1) \u2190 p(\u22121) .\n(2)\nAs described in [1], it is straightforward to extend the definition of satisfaction to ground aggregate expressions. For instance, set {p(\u22121), p(1)} does not satisfy the body of the first rule of (2), but satisfies the bodies of the other rules. The FLP reduct of program (2) relative to {p(\u22121), p(1)} consists of the last two rules, and {p(\u22121), p(1)} is its minimal model. Indeed, {p(\u22121), p(1)} is the only FLP answer set of program (2).\nOn the other hand, according to the semantics from [3], program (2) is identified with some complex propositional formula containing nested implications:( \u00ac ( (p(2)\u2192p(\u22121)\u2228p(1)) \u2227 (p(1)\u2227p(2)\u2192p(\u22121)) \u2227 (p(\u22121)\u2227p(1)\u2227p(2)\u2192\u22a5) ) \u2192 p(2)\n) \u2227 (( p(\u22121)\u2192p(1)\u2228p(2) ) \u2192 p(\u22121)\n) \u2227 ( p(\u22121)\u2192 p(1) ) .\nar X\niv :1\n30 1.\n13 93\nv1 [\ncs .L\nO ]\n8 J\nan 2\n01 3\nUnder the stable model semantics of propositional formulas [3], this formula has two answer sets: {p(\u22121), p(1)} and {p(\u22121), p(1), p(2)}. The relationship between the FLP and the Ferraris semantics was studied in [4; 5].\nUnlike the FLP semantics, the definition from [3] is not applicable when the domain is infinite because it would require the representation of an aggregate expression to involve \u201cinfinite\u201d conjunctions and disjunctions. This limitation was overcome in the semantics presented in [4; 6], which extends the first-order stable model semantics from [7; 8] to incorporate aggregate expressions. Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].\nIn this paper, we revisit the first-order stable model semantics and its extension to incorporate generalized quantifiers. We provide an alternative, equivalent definition of a stable model by referring to grounding and reduct instead of the SM operator. Our work is inspired by the work of Truszczynski [12], who introduces infinite conjunctions and disjunctions to account for grounding quantified sentences. Our definition of a stable model can be viewed as a reformulation and a further generalization of his definition to incorporate generalized quantifiers. We define grounding in the same way as done in the FLP semantics, but define a reduct differently so that the semantics agrees with the one by Ferraris [3]. As we explain in Section 3.3, our reduct of program (2) relative to {p(\u22121), p(1)} is\n\u22a5 \u2190 \u22a5 p(\u22121) \u2190 SUM\u3008{\u22121:p(\u22121), 1:p(1), 2:\u22a5)\u3009}>\u22121 p(1) \u2190 p(\u22121) ,\n(3)\nwhich is the program obtained from (2) by replacing each maximal subformula that is not satisfied by {p(\u22121), p(1)} with \u22a5. Set {p(\u22121), p(1)} is an answer set of program (1) as it is a minimal model of the reduct. Likewise the reduct relative to {p(\u22121), p(1), p(2)} is\np(2) \u2190 > p(\u22121) \u2190 SUM{\u3008\u22121:p(\u22121), 1:p(1), 2:p(2)\u3009}>\u22121 p(1) \u2190 p(\u22121)\nand {p(\u22121), p(1), p(2)} is a minimal model of the program. The semantics is more direct than the one from [3] as it does not involve the complex translation into a propositional formula.\nWhile the FLP semantics in [1] was defined in the context of logic programs with aggregates, it can be straightforwardly extended to allow other \u201ccomplex atoms.\u201d Indeed, the FLP reduct is the basis of the semantics of HEX programs [13]. In [14], the FLP reduct was applied to provide a semantics of nonmonotonic dl-programs [11]. In [5], the FLP semantics of logic programs with aggregates was generalized to the first-order level. That semantics is defined in terms of the FLP operator, which is similar to the SM operator. This paper further extends the definition to allow generalized quantifiers.\nBy providing an alternative definition in the way that the other semantics was defined, this paper provides a useful insight into the relationship between the first-order\nstable model semantics and the FLP stable model semantics for programs with generalized quantifiers. While the two semantics behave differently in the general case, we show that they coincide on some reasonable syntactic class of logic programs. This implies that an implementation of one of the semantics can be viewed as an implementation of the other semantics if we limit attention to that class of logic programs.\nThe paper is organized as follows. Section 2 reviews the first-order stable model semantics and its equivalent definition in terms of grounding and reduct, and Section 3 extends that definition to incorporate generalized quantifiers. Section 4 provides an alternative definition of the FLP semantics with generalized quantifiers via a translation into second-order formulas. Section 5 compares the FLP semantics and the first-order stable model semantics in the general context of programs with generalized quantifiers."}, {"heading": "2 First-Order Stable Model Semantics", "text": ""}, {"heading": "2.1 Review of First-Order Stable Model Semantics", "text": "This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.\nA formula is defined the same as in first-order logic. A signature consists of function constants and predicate constants. Function constants of arity 0 are also called object constants. We assume the following set of primitive propositional connectives and quantifiers:\n\u22a5,>, \u2227, \u2228, \u2192, \u2200, \u2203 .\n\u00acF is an abbreviation of F \u2192 \u22a5, and F \u2194 G stands for (F \u2192 G) \u2227 (G \u2192 F ). We distinguish between atoms and atomic formulas as follows: an atom of a signature \u03c3 is an n-ary predicate constant followed by a list of n terms that can be formed from function constants in \u03c3 and object variables; atomic formulas of \u03c3 are atoms of \u03c3, equalities between terms of \u03c3, and the 0-place connectives \u22a5 and >.\nThe stable models of F relative to a list of predicates p = (p1, . . . , pn) are defined via the stable model operator with the intensional predicates p, denoted by SM[F ;p].1 Let u be a list of distinct predicate variables u1, . . . , un. By u = p we denote the conjunction of the formulas \u2200x(ui(x) \u2194 pi(x)), where x is a list of distinct object variables of the same length as the arity of pi, for all i = 1, . . . , n. By u \u2264 p we denote the conjunction of the formulas \u2200x(ui(x) \u2192 pi(x)) for all i = 1, . . . , n, and u < p stands for (u \u2264 p) \u2227 \u00ac(u = p). For any first-order sentence F , expression SM[F ;p] stands for the second-order sentence\nF \u2227 \u00ac\u2203u((u < p) \u2227 F \u2217(u)),\nwhere F \u2217(u) is defined recursively:\n\u2013 pi(t)\u2217 = ui(t) for any list t of terms; \u2013 F \u2217 = F for any atomic formula F that does not contain members of p; \u2013 (F \u2227G)\u2217 = F \u2217 \u2227G\u2217;\n1 The intensional predicates p are the predicates that we \u201cintend to characterize\u201d by F .\n\u2013 (F \u2228G)\u2217 = F \u2217 \u2228G\u2217; \u2013 (F \u2192 G)\u2217 = (F \u2217 \u2192 G\u2217) \u2227 (F \u2192 G); \u2013 (\u2200xF )\u2217 = \u2200xF \u2217; \u2013 (\u2203xF )\u2217 = \u2203xF \u2217.\nA model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies SM[F ;p].\nExample 1 Let F be sentence \u2200x(\u00acp(x)\u2192 q(x)), and let I be an interpretation whose universe is the set of all nonnegative integers N, and pI(n) = FALSE, qI(n) = TRUE for all n \u2208 N. Section 2.4 of [8] tells us that I satisfies SM[F ; pq]."}, {"heading": "2.2 Alternative Definition of First-Order Stable Models via Reduct", "text": "For any signature \u03c3 and its interpretation I , by \u03c3I we mean the signature obtained from \u03c3 by adding new object constants \u03be , called object names, for every element \u03be in the universe of I . We identify an interpretation I of \u03c3 with its extension to \u03c3I defined by I(\u03be ) = \u03be.\nIn order to facilitate defining a reduct, we provide a reformulation of the standard semantics of first-order logic via \u201ca ground formula w.r.t. an interpretation.\u201d\nDefinition 1. For any interpretation I of a signature \u03c3, a ground formula w.r.t. I is defined recursively as follows.\n\u2013 p(\u03be 1 , . . . , \u03be n), where p is a predicate constant of \u03c3 and \u03be i are object names of \u03c3I , is a ground formula w.r.t. I; \u2013 > and \u22a5 are ground formulas w.r.t. I; \u2013 If F and G are ground formulas w.r.t. I , then F \u2227 G, F \u2228 G, F \u2192 G are ground\nformulas w.r.t. I; \u2013 If S is a set of pairs of the form \u03be :F where \u03be is an object name in \u03c3I and F is a\nground formula w.r.t. I , then \u2200(S) and \u2203(S) are ground formulas w.r.t. I .\nThe following definition describes a process that turns any first-order sentence into a ground formula w.r.t. an interpretation:\nDefinition 2. Let F be any first-order sentence of a signature \u03c3, and let I be an interpretation of \u03c3 whose universe is U . By grI [F ] we denote the ground formula w.r.t. I , which is obtained by the following process:\n\u2013 grI [p(t1, . . . , tn)] = p((tI1) , . . . , (tIn) );\n\u2013 grI [t1 = t2] = { > if tI1 = tI2, and \u22a5 otherwise; \u2013 grI [>] = >; grI [\u22a5] = \u22a5; \u2013 grI [F G] = grI [F ] grI [G] ( \u2208 {\u2227,\u2228,\u2192}); \u2013 grI [QxF (x)] = Q({\u03be :grI [F (\u03be )] | \u03be \u2208 U}) (Q \u2208 {\u2200,\u2203}).\nDefinition 3. For any interpretation I and any ground formula F w.r.t. I , the truth value of F under I , denoted by F I , is defined recursively as follows.\n\u2013 p(\u03be 1 , . . . , \u03be n)I = pI(\u03be1, . . . , \u03ben); \u2013 >I = TRUE; \u22a5I = FALSE; \u2013 (F \u2227G)I = TRUE iff F I = TRUE and GI = TRUE; \u2013 (F \u2228G)I = TRUE iff F I = TRUE or GI = TRUE; \u2013 (F \u2192 G)I = TRUE iff GI = TRUE whenever F I = TRUE; \u2013 \u2200(S)I = TRUE iff the set {\u03be | \u03be :F (\u03be ) \u2208 S and F (\u03be )I = TRUE} is the same as\nthe universe of I; \u2013 \u2203(S)I = TRUE iff the set {\u03be | \u03be :F (\u03be ) \u2208 S and F (\u03be )I = TRUE} is not empty.\nWe say that I satisfies F , denoted I |= F , if F I = TRUE.\nExample 1 continued (I). grI [F ] is \u2200({n : (\u00acp(n )\u2192 q(n )) | n \u2208 N}). Clearly, I satisfies grI [F ].\nAn interpretation I of a signature \u03c3 can be represented as a pair \u3008I f unc, Ipred\u3009, where I f unc is the restriction of I to the function constants of \u03c3, and Ipred is the set of atoms, formed using predicate constants from \u03c3 and the object names from \u03c3I , which are satisfied by I . For example, interpretation I in Example 1 can be represented as \u3008I f unc, {q(n ) | n \u2208 N}\u3009, where I f unc maps each integer to itself.\nThe following proposition is immediate from the definitions:\nProposition 1. Let \u03c3 be a signature that contains finitely many predicate constants, let \u03c3pred be the set of predicate constants in \u03c3, let I = \u3008I f unc, Ipred\u3009 be an interpretation of \u03c3, and let F be a first-order sentence of \u03c3. Then I |= F iff Ipred |= grI [F ].\nThe introduction of the intermediate form of a ground formula w.r.t. an interpretation helps us define a reduct.\nDefinition 4. For any ground formula F w.r.t. I , the reduct of F relative to I , denoted by F I , is obtained by replacing each maximal subformula that is not satisfied by I with \u22a5. It can also be defined recursively as follows.\n\u2013 (p(\u03be 1 , . . . , \u03be n))I =\n{ p(\u03be 1 , . . . , \u03be n) if I |= p(\u03be 1 , . . . , \u03be n),\n\u22a5 otherwise; \u2013 >I = >; \u22a5I = \u22a5;\n\u2013 (F G)I = { F I GI if I |= F G ( \u2208 {\u2227,\u2228,\u2192}), \u22a5 otherwise;\n\u2013 Q(S)I = { Q({\u03be : (F (\u03be ))I | \u03be :F (\u03be ) \u2208 S}) if I |= Q(S) (Q \u2208 {\u2200,\u2203}), \u22a5 otherwise.\nThe following theorem tells us how first-order stable models can be characterized in terms of grounding and reduct.\nTheorem 1. Let \u03c3 be a signature that contains finitely many predicate constants, let \u03c3pred be the set of predicate constants in \u03c3, let I = \u3008I f unc, Ipred\u3009 be an interpretation of \u03c3, and let F be a first-order sentence of \u03c3. I satisfies SM[F ;\u03c3pred] iff Ipred is a minimal set of atoms that satisfies (\u0131grI [F ]) I .\nExample 1 continued (II). The reduct of grI [F ] relative to I , (grI [F ])I , is \u2200({n : (\u00ac\u22a5 \u2192 q(n )) | n \u2208 N}), which is equivalent to \u2200({n : q(n ) | n \u2208 N}). Clearly, Ipred = {q(n ) | n \u2208 N} is a minimal set of atoms that satisfies (grI [F ])I ."}, {"heading": "2.3 Relation to Infinitary Formulas by Truszczynski", "text": "The definitions of grounding and a reduct in the previous section are inspired by the work of Truszczynski [12], where he introduces infinite conjunctions and disjunctions to account for the result of grounding \u2200 and \u2203 w.r.t. a given interpretation. Differences between the two approaches are illustrated in the following example:\nExample 2 Consider the formula F = \u2200x p(x) and the interpretation I whose universe is the set of all nonnegative integers N. According to [12], grounding of F w.r.t. I results in the infinitary propositional formula\n{p(n ) | n \u2208 N}\u2227 .\nOn the other hand, formula grI [F ] is\n\u2200({n :p(n ) | n \u2208 N}).\nOur definition of a reduct is essentially equivalent to the one defined in [12]. In the next section, we extend our definition to incorporate generalized quantifiers."}, {"heading": "3 Stable Models of Formulas with Generalized Quantifiers", "text": ""}, {"heading": "3.1 Review: Formulas with Generalized Quantifiers", "text": "We follow the definition of a formula with generalized quantifiers from [15, Section 5] (that is to say, with Lindstro\u0308m quantifiers [16] without the isomorphism closure condition).\nWe assume a set Q of symbols for generalized quantifiers. Each symbol in Q is associated with a tuple of nonnegative integers \u3008n1, . . . , nk\u3009 (k \u2265 0, and each ni is \u2265 0), called the type. A (GQ-)formula (with the set Q of generalized quantifiers) is defined in a recursive way:\n\u2013 an atomic formula (in the sense of first-order logic) is a GQ-formula; \u2013 if F1, . . . , Fk (k \u2265 0) are GQ-formulas and Q is a generalized quantifier of type \u3008n1, . . . , nk\u3009 in Q, then\nQ[x1] . . . [xk](F1(x1), . . . , Fk(xk)) (4)\nis a GQ-formula, where each xi (1 \u2264 i \u2264 k) is a list of distinct object variables whose length is ni.\nWe say that an occurrence of a variable x in a GQ-formula F is bound if it belongs to a subformula of F that has the form Q[x1] . . . [xk](F1(x1), . . . , Fk(xk)) such that x is in some xi. Otherwise the occurrence is free. We say that x is free in F if F contains a free occurrence of x. A (GQ-)sentence is a GQ-formula with no free variables.\nWe assume that Q contains type \u3008\u3009 quantifiers Q\u22a5 and Q>, type \u30080, 0\u3009 quantifiers Q\u2227, Q\u2228, Q\u2192, and type \u30081\u3009 quantifiers Q\u2200, Q\u2203. Each of them corresponds to the standard logical connectives and quantifiers \u2014 \u22a5,>,\u2227,\u2228,\u2192,\u2200,\u2203. These generalized quantifiers will often be written in the familiar form. For example, we write F \u2227 G in place of Q\u2227[][](F,G), and write \u2200xF (x) in place of Q\u2200[x](F (x)).\nAs in first-order logic, an interpretation I consists of the universe U and the evaluation of predicate constants and function constants. For each generalized quantifier Q of type \u3008n1, . . . , nk\u3009, QU is a function from P(Un1)\u00d7 \u00b7 \u00b7 \u00b7 \u00d7 P(Unk) to {TRUE, FALSE}, where P(Uni) denotes the power set of Uni .\nExample 3 Besides the standard connectives and quantifiers, the following are some examples of generalized quantifiers.\n\u2013 type \u30081\u3009 quantifier Q\u22642 such that QU\u22642(R) = TRUE iff |R| \u2264 2; 2 \u2013 type \u30081\u3009 quantifier Qmajority such that QUmajority(R) = TRUE iff |R| > |U \\R|; \u2013 type \u30081, 1\u3009 quantifier Q(SUM,<) such that QU(SUM,<)(R1, R2) = TRUE iff \u2022 SUM(R1) is defined, \u2022 R2 = {b}, where b is an integer, and \u2022 SUM(R1) < b.\nGiven a sentence F of \u03c3I , F I is defined recursively as follows:\n\u2013 p(t1, . . . , tn)I = pI(tI1, . . . , tIn), \u2013 (t1 = t2)I = (tI1 = tI2), \u2013 For a generalized quantifier Q of type \u3008n1, . . . , nk\u3009,\n(Q[x1] . . . [xk](F1(x1), . . . , Fk(xk))) I = QU ((x1 :F1(x1)) I , . . . , (xk :Fk(xk)) I),\nwhere (xi :Fi(xi))I = {\u03be \u2208 Uni | (Fi(\u03be ))I = TRUE}.\nWe assume that, for the standard logical connectives and quantifiers Q, functions QU have the standard meaning:\n\u2013 QU\u2200 (R) = TRUE iff R = U ; \u2013 QU\u2203 (R) = TRUE iff R \u2229 U 6= \u2205; \u2013 QU\u2227 (R1, R2) = TRUE iff R1 = R2 = { };3 \u2013 QU\u2228 (R1, R2) = TRUE iff R1 = { } or R2 = { };\n\u2013 QU\u2192(R1, R2) = TRUE iff R1 is \u2205 or R2 is { }; \u2013 QU\u22a5() = FALSE; \u2013 QU>() = TRUE.\n2 It is clear from the type of the quantifier that R is any subset of U . We will skip such explanation. 3 denotes the empty tuple. For any interpretation I , U0 = { }. For I to satisfy Q\u2227[][](F,G), both ( :F )I and ( :G)I have to be { }, which means that F I = GI = TRUE.\nWe say that an interpretation I satisfies a GQ-sentence F , or is a model of F , and write I |= F , if F I = TRUE. A GQ-sentence F is logically valid if every interpretation satisfies F . A GQ-formula with free variables is said to be logically valid if its universal closure is logically valid.\nExample 4 Program (1) in the introduction is identified with the following GQ-formulaF1:\n(\u00acQ(SUM,<)[x][y](p(x), y=2)\u2192 p(2)) \u2227 (Q(SUM,>)[x][y](p(x), y=\u22121)\u2192 p(\u22121)) \u2227 (p(\u22121)\u2192 p(1)) .\nConsider two Herbrand interpretations of the universeU = {\u22121, 1, 2}: I1 = {p(\u22121), p(1)} and I2 = {p(\u22121), p(1), p(2)}. We have (Q(SUM,<)[x][y](p(x), y = 2))I1 = TRUE since\n\u2013 (x : p(x))I1 = {\u22121, 1} and (y : y=2)I1 = {2}; \u2013 QU(SUM,<)({\u22121, 1}, {2}) = TRUE.\nSimilarly, (Q(SUM,>)[x][y](p(x), y=\u22121))I2 = TRUE since\n\u2013 (x : p(x))I2 = {\u22121, 1, 2} and (y : y=\u22121)I2 = {\u22121}; \u2013 QU(SUM,>)({\u22121, 1, 2}, {\u22121}) = TRUE.\nConsequently, both I1 and I2 satisfy F1.\n3.2 Review: SM-Based Definition of Stable Models of GQ-Formulas\nFor any GQ-formula F and any list of predicates p = (p1, . . . , pn), formula SM[F ;p] is defined as\nF \u2227 \u00ac\u2203u((u < p) \u2227 F \u2217(u)),\nwhere F \u2217(u) is defined recursively:\n\u2013 pi(t)\u2217 = ui(t) for any list t of terms; \u2013 F \u2217 = F for any atomic formula F that does not contain members of p; \u2013\n(Q[x1] . . . [xk](F1(x1), . . . , Fk(xk))) \u2217 =\nQ[x1] . . . [xk](F \u2217 1 (x1), . . . , F \u2217 k (xk)) \u2227 Q[x1] . . . [xk](F1(x1), . . . , Fk(xk)).\nWhen F is a sentence, the models of SM[F ;p] are called the p-stable models of F : they are the models of F that are \u201cstable\u201d on p. We often simply write SM[F ] in place of SM[F ;p] when p is the list of all predicate constants occurring in F , and call p-stable models simply stable models.\nAs explained in [17], this definition of a stable model is a proper generalization of the first-order stable model semantics.\nExample 4 continued (I). For GQ-sentence F1 considered earlier, SM[F1] is\nF1 \u2227 \u00ac\u2203u(u < p \u2227 F \u22171 (u)) , (5)\nwhere F \u22171 (u) is equivalent to the conjunction of F1 and\n(\u00acQ(SUM,<)[x][y](p(x), y=2)\u2192 u(2)) \u2227 ((Q(SUM,>)[x][y](u(x), y=\u22121) \u2227 Q(SUM,>)[x][y](p(x), y=\u22121))\u2192 u(\u22121)) \u2227 (u(\u22121)\u2192 u(1)) .\nThe equivalence can be explained by Proposition 1 from [9], which simplifies the transformation for monotone and antimonotone GQs. I1 and I2 considered earlier satisfy (5) and thus are stable models of F1."}, {"heading": "3.3 Reduct-Based Definition of Stable Models of GQ-Formulas", "text": "The reduct-based definition of stable models presented in Section 2.2 can be extended to GQ-formulas as follows.\nLet I be an interpretation of a signature \u03c3. As before, we assume a set Q of generalized quantifiers, which contains all propositional connectives and standard quantifiers.\nDefinition 5. A ground GQ-formula w.r.t. I is defined recursively as follows:\n\u2013 p(\u03be 1 , . . . , \u03be n), where p is a predicate constant of \u03c3 and \u03be i are object names of \u03c3I , is a ground GQ-formula w.r.t. I; \u2013 for any Q \u2208 Q of type \u3008n1, . . . , nk\u3009, if each Si is a set of pairs of the form \u03be :F where \u03be is a list of object names from \u03c3I whose length is ni and F is a ground GQ-formula w.r.t. I , then\nQ(S1, . . . , Sk)\nis a ground GQ-formula w.r.t. I .\nThe following definition of grounding turns any GQ-sentence into a ground GQformula w.r.t. an interpretation:\nDefinition 6. Let F be a GQ-sentence of a signature \u03c3, and let I be an interpretation of \u03c3. By grI [F ] we denote the ground GQ-formula w.r.t. I that is obtained by the process similar to the one in Definition 2 except that the last two clauses are replaced by the following single clause:\n\u2013 grI [Q[x1] . . . [xk](F1(x1), . . . , Fk(xk))] = Q(S1, . . . , Sk) where Si = {\u03be :grI [Fi(\u03be )] | \u03be is a list of object names from \u03c3I whose length is ni}.\nFor any interpretation I and any ground GQ-formula F w.r.t. I , the satisfaction relation I |= F is defined recursively as follows.\nDefinition 7. For any interpretation I and any ground GQ-formula F w.r.t. I , the satisfaction relation I |= F is defined similar to Definition 3 except that the last five clauses are replaced by the following single clause:\n\u2013 Q(S1, . . . , Sk)I = QU (SI1 , . . . , SIk) where SIi = {\u03be | \u03be :F (\u03be ) \u2208 Si, F (\u03be )I =\nTRUE}.\nExample 4 continued (II). For Herbrand interpretation I1 = {p(\u22121), p(1)}, formula grI1 [F1] is 4\n(\u00acQ(SUM,<)({\u22121:p(\u22121), 1:p(1), 2:p(2)}, {\u22121:\u22a5, 1:\u22a5, 2:>})\u2192 p(2)) \u2227 (Q(SUM,>)({\u22121:p(\u22121), 1:p(1), 2:p(2)}, {\u22121:>, 1:\u22a5, 2:\u22a5})\u2192 p(\u22121)) \u2227 (p(\u22121)\u2192 p(1)) .\n(6)\nI1 satisfies Q(SUM,<)({\u22121 : p(\u22121), 1 : p(1), 2 : p(2)}, {\u22121 : \u22a5, 1 : \u22a5, 2 : >}) because I1 |= p(\u22121), I1 |= p(1), I1 6|= p(2), and\nQU(SUM,<)({\u22121, 1}, {2}) = TRUE.\nI1 satisfies Q(SUM,>)({\u22121:p(\u22121), 1:p(1), 2:p(2)}, {\u22121:>, 1:\u22a5, 2:\u22a5}) because\nQU(SUM,>)({\u22121, 1}, {\u22121}) = TRUE.\nConsequently, I1 satisfies (6).\nProposition 2. Let \u03c3 be a signature that contains finitely many predicate constants, let \u03c3pred be the set of predicate constants in \u03c3, let I = \u3008I f unc, Ipred\u3009 be an interpretation of \u03c3, and let F be a GQ-sentence of \u03c3. Then I |= F iff Ipred |= grI [F ].\nDefinition 8. For any GQ-formula F w.r.t. I , the reduct of F relative to I , denoted by F I , is defined in the same way as in Definition 4 by replacing the last two clauses with the following single clause:\n\u2013 (Q(S1, . . . , Sk))I =\n{ Q(S\nI 1 , . . . , S I k) if I |= Q(S1, . . . , Sk),\n\u22a5 otherwise; where SIi = {\u03be : (F (\u03be ))I | \u03be :F (\u03be ) \u2208 Si}.\nTheorem 2. Let \u03c3 be a signature that contains finitely many predicate constants, let \u03c3pred be the set of predicate constants in \u03c3, let I = \u3008I f unc, Ipred\u3009 be an interpretation of \u03c3, and let F be a GQ-sentence of \u03c3. I |= SM[F ;\u03c3pred] iff Ipred is a minimal set of atoms that satisfies (\u0131grI [F ]) I .\nExample 4 continued (III). Interpretation I1 considered earlier can be identified with the tuple \u3008I f unc, {p(\u22121), p(1)}\u3009 where I f unc maps every term to itself. The reduct (grI1 [F1]) I1 is\n(\u22a5 \u2192 \u22a5) \u2227 (Q(SUM,>)({\u22121:p(\u22121), 1:p(1), 2:\u22a5}, {\u22121:>, 1:\u22a5, 2:\u22a5})\u2192 p(\u22121)) \u2227 (p(\u22121)\u2192 p(1)) ,\nwhich is the GQ-formula representation of (3). We can check that {p(\u22121), p(1)} is a minimal model of the reduct.\nExtending Theorem 2 to allow an arbitrary list of intensional predicates, rather than \u03c3pred, is straightforward in view of Proposition 1 from [18].\n4 For simplicity, we write \u22121, 1, 2 instead of their object names (\u22121) , 1 , 2 ."}, {"heading": "4 FLP Semantics of Programs with Generalized Quantifiers", "text": "The FLP stable model semantics [1] is an alternative way to define stable models. It is the basis of HEX programs, an extension of the stable model semantics with higherorder and external atoms, which is implemented in system DLV-HEX. The first-order generalization of the FLP stable model semantics for programs with aggregates was given in [5], using the FLP operator that is similar to the SM operator. In this section we show how it can be extended to allow generalized quantifiers."}, {"heading": "4.1 FLP Semantics of Programs with Generalized Quantifiers", "text": "A (general) rule is of the form H \u2190 B (7)\nwhere H and B are arbitrary GQ-formulas. A (general) program is a finite set of rules. Let p be a list of distinct predicate constants p1, . . . , pn, and let u be a list of distinct predicate variables u1, . . . , un. For any formula G, formula G(u) is obtained from G by replacing all occurrences of predicates from p with the corresponding predicate variables from u.\nLet \u03a0 be a finite program whose rules have the form (7). The GQ-representation \u03a0GQ of \u03a0 is the conjunction of the universal closures of B \u2192 H for all rules (7) in \u03a0 . By FLP[\u03a0;p] we denote the second-order formula\n\u03a0GQ \u2227 \u00ac\u2203u(u < p \u2227\u03a04(u))\nwhere \u03a04(u) is defined as the conjunction of the universal closures of\nB \u2227B(u)\u2192H(u)\nfor all rules H \u2190 B in \u03a0 . We will often simply write FLP[\u03a0] instead of FLP[\u03a0;p] when p is the list of all predicate constants occurring in \u03a0 , and call a model of FLP[\u03a0] an FLP-stable model of \u03a0 .\nExample 4 continued (IV). For formula F1 considered earlier, FLP[F1] is\nF1 \u2227 \u00ac\u2203u(u < p \u2227 F41 (u)) , (8)\nwhere F41 (u) is\n(\u00acQ(SUM,<)[x][y](p(x), y=2) \u2227 \u00acQ(SUM,<)[x][y](u(x), y=2)\u2192 u(2)) \u2227 (Q(SUM,>)[x][y](p(x), y=\u22121) \u2227 (Q(SUM,>)[x][y](u(x), y=\u22121)\u2192 u(\u22121)) \u2227 (p(\u22121) \u2227 u(\u22121)\u2192 u(1)) .\nI1 considered earlier satisfies (8) but I2 does not."}, {"heading": "5 Comparing the FLP Semantics and the First-Order Stable Model Semantics", "text": "In this section, we show a class of programs with GQs for which the FLP semantics and the first-order stable model semantics coincide.\nThe following definition is from [17]. We say that a generalized quantifier Q is monote in the i-th argument position if the following holds for any universe U : if QU (R1, . . . , Rk) = TRUE and Ri \u2286 R\u2032i \u2286 Uni , then\nQU (R1, . . . , Ri\u22121, R \u2032 i, Ri+1, . . . , Rk) = TRUE.\nConsider a program \u03a0 consisting of rules of the form\nA1; . . . ;Al \u2190 E1, . . . , Em, \u0131not Em+1, . . . , \u0131not En\n(l \u2265 0; n \u2265 m \u2265 0), where each Ai is an atomic formula and each Ei is an atomic formula or a GQ-formula (4) such that all F1(x1), . . . , Fk(xk) are atomic formulas. Furthermore we require that, for every GQ-formula (4) in one of Em+1, . . . , En, Q is monotone in all its argument positions.\nProposition 3. Let \u03a0 be a program whose syntax is described as above, and let F be the GQ-representation of \u03a0 . Then FLP[\u03a0;p] is equivalent to SM[F ;p].\nExample 5 Consider the following one-rule program:\np(a)\u2190 \u0131not Q\u22640[x] p(x) . (9)\nThis program does not belong to the syntactic class of programs stated in Proposition 3 since Q\u22640[x] p(x) is not monotone in {1}. Indeed, both \u2205 and {p(a)} satisfy SM[\u03a0; p], but only \u2205 satisfies FLP[\u03a0; p].\nConditions under which the FLP semantics coincides with the first-order stable model semantics has been studied in [4; 5] in the context of logic programs with aggregates."}, {"heading": "6 Conclusion", "text": "We introduced two definitions of a stable model. One is a reformulation of the first-order stable model semantics and its extension to allow generalized quantifiers by referring to grounding and reduct, and the other is a reformulation of the FLP semantics and its extension to allow generalized quantifiers by referring to a translation into secondorder logic. These new definitions help us understand the relationship between the FLP semantics and the first-order stable model semantics, and their extensions. For the class of programs where the two semantics coincide, system DLV-HEX can be viewed as an implementation of the stable model semantics of GQ-formulas; A recent extension of system F2LP [19] to allow \u201ccomplex\u201d atoms may be considered as a front-end to DLVHEX to implement the generalized FLP semantics."}, {"heading": "Acknowledgements", "text": "We are grateful to Vladimir Lifschitz for useful discussions related to this paper. We are also grateful to Joseph Babb and the anonymous referees for their useful comments. This work was partially supported by the National Science Foundation under Grant IIS0916116 and by the South Korea IT R&D program MKE/KIAT 2010-TD-300404-001."}], "references": [{"title": "Recursive aggregates in disjunctive logic programs: Semantics and complexity", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA).", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2004}, {"title": "Semantics and complexity of recursive aggregates in answer set programming", "author": ["W. Faber", "G. Pfeifer", "N. Leone"], "venue": "Artificial Intelligence 175(1)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2005}, {"title": "On reductive semantics of aggregates in answer set programming", "author": ["J. Lee", "Y. Meng"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2009}, {"title": "First-order extension of the flp stable model semantics via modified circumscription", "author": ["M. Bartholomew", "J. Lee", "Y. Meng"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI).", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "On the stable model semantics of first-order formulas with aggregates", "author": ["P. Ferraris", "V. Lifschitz"], "venue": "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), AAAI Press", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Stable models of formulas with generalized quantifiers (preliminary report)", "author": ["J. Lee", "Y. Meng"], "venue": "Technical Communications of the 28th International Conference on Logic Programming.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Logic programs with abstract constraint atoms", "author": ["V.W. Marek", "M. Truszczynski"], "venue": "Proceedings of the AAAI Conference on Artificial Intelligence (AAAI).", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2004}, {"title": "Combining answer set programming with description logics for the semantic web", "author": ["T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits"], "venue": "Artificial Intelligence 172(1213)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2008}, {"title": "Connecting first-order ASP and the logic FO(ID) through reducts", "author": ["M. Truszczynski"], "venue": "Correct Reasoning: Essays on Logic-Based AI in Honor of Vladimir Lifschitz.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "A uniform integration of higher-order reasoning and external evaluations in answer-set programming", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI).", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "A logical semantics for description logic programs", "author": ["M. Fink", "D. Pearce"], "venue": "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA).", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2010}, {"title": "Generalized quantifiers", "author": ["D. Westerst\u00e5hl"], "venue": " In: The Stanford Encyclopedia of Philosophy (Winter 2008 Edition). ", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "First-order predicate logic with generalized quantifiers", "author": ["P. Lindstr\u00f6m"], "venue": "Theoria 32", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1966}, {"title": "Stable models of formulas with generalized quantifiers", "author": ["J. Lee", "Y. Meng"], "venue": "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "Reformulating the situation calculus and the event calculus in the general theory of stable models and in answer set programming", "author": ["J. Lee", "R. Palla"], "venue": "Journal of Artificial Intelligence Research (JAIR) 43", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2012}, {"title": "System F2LP \u2014 computing answer sets of first-order formulas", "author": ["J. Lee", "R. Palla"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "As described in [1], it is straightforward to extend the definition of satisfaction to ground aggregate expressions.", "startOffset": 16, "endOffset": 19}, {"referenceID": 2, "context": "On the other hand, according to the semantics from [3], program (2) is identified with some complex propositional formula containing nested implications: ( \u00ac ( (p(2)\u2192p(\u22121)\u2228p(1)) \u2227 (p(1)\u2227p(2)\u2192p(\u22121)) \u2227 (p(\u22121)\u2227p(1)\u2227p(2)\u2192\u22a5) ) \u2192 p(2) )", "startOffset": 51, "endOffset": 54}, {"referenceID": 2, "context": "Under the stable model semantics of propositional formulas [3], this formula has two answer sets: {p(\u22121), p(1)} and {p(\u22121), p(1), p(2)}.", "startOffset": 59, "endOffset": 62}, {"referenceID": 2, "context": "Unlike the FLP semantics, the definition from [3] is not applicable when the domain is infinite because it would require the representation of an aggregate expression to involve \u201cinfinite\u201d conjunctions and disjunctions.", "startOffset": 46, "endOffset": 49}, {"referenceID": 8, "context": "Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].", "startOffset": 80, "endOffset": 83}, {"referenceID": 9, "context": "Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].", "startOffset": 250, "endOffset": 254}, {"referenceID": 10, "context": "Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].", "startOffset": 296, "endOffset": 300}, {"referenceID": 11, "context": "Our work is inspired by the work of Truszczynski [12], who introduces infinite conjunctions and disjunctions to account for grounding quantified sentences.", "startOffset": 49, "endOffset": 53}, {"referenceID": 2, "context": "We define grounding in the same way as done in the FLP semantics, but define a reduct differently so that the semantics agrees with the one by Ferraris [3].", "startOffset": 152, "endOffset": 155}, {"referenceID": 2, "context": "The semantics is more direct than the one from [3] as it does not involve the complex translation into a propositional formula.", "startOffset": 47, "endOffset": 50}, {"referenceID": 0, "context": "While the FLP semantics in [1] was defined in the context of logic programs with aggregates, it can be straightforwardly extended to allow other \u201ccomplex atoms.", "startOffset": 27, "endOffset": 30}, {"referenceID": 12, "context": "\u201d Indeed, the FLP reduct is the basis of the semantics of HEX programs [13].", "startOffset": 71, "endOffset": 75}, {"referenceID": 13, "context": "In [14], the FLP reduct was applied to provide a semantics of nonmonotonic dl-programs [11].", "startOffset": 3, "endOffset": 7}, {"referenceID": 10, "context": "In [14], the FLP reduct was applied to provide a semantics of nonmonotonic dl-programs [11].", "startOffset": 87, "endOffset": 91}, {"referenceID": 4, "context": "In [5], the FLP semantics of logic programs with aggregates was generalized to the first-order level.", "startOffset": 3, "endOffset": 6}, {"referenceID": 7, "context": "This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.", "startOffset": 20, "endOffset": 23}, {"referenceID": 6, "context": "This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.", "startOffset": 46, "endOffset": 49}, {"referenceID": 7, "context": "4 of [8] tells us that I satisfies SM[F ; pq].", "startOffset": 5, "endOffset": 8}, {"referenceID": 11, "context": "The definitions of grounding and a reduct in the previous section are inspired by the work of Truszczynski [12], where he introduces infinite conjunctions and disjunctions to account for the result of grounding \u2200 and \u2203 w.", "startOffset": 107, "endOffset": 111}, {"referenceID": 11, "context": "According to [12], grounding of F w.", "startOffset": 13, "endOffset": 17}, {"referenceID": 11, "context": "Our definition of a reduct is essentially equivalent to the one defined in [12].", "startOffset": 75, "endOffset": 79}, {"referenceID": 15, "context": "We follow the definition of a formula with generalized quantifiers from [15, Section 5] (that is to say, with Lindstr\u00f6m quantifiers [16] without the isomorphism closure condition).", "startOffset": 132, "endOffset": 136}, {"referenceID": 16, "context": "As explained in [17], this definition of a stable model is a proper generalization of the first-order stable model semantics.", "startOffset": 16, "endOffset": 20}, {"referenceID": 8, "context": "The equivalence can be explained by Proposition 1 from [9], which simplifies the transformation for monotone and antimonotone GQs.", "startOffset": 55, "endOffset": 58}, {"referenceID": 17, "context": "Extending Theorem 2 to allow an arbitrary list of intensional predicates, rather than \u03c3, is straightforward in view of Proposition 1 from [18].", "startOffset": 138, "endOffset": 142}, {"referenceID": 0, "context": "The FLP stable model semantics [1] is an alternative way to define stable models.", "startOffset": 31, "endOffset": 34}, {"referenceID": 4, "context": "The first-order generalization of the FLP stable model semantics for programs with aggregates was given in [5], using the FLP operator that is similar to the SM operator.", "startOffset": 107, "endOffset": 110}, {"referenceID": 16, "context": "The following definition is from [17].", "startOffset": 33, "endOffset": 37}, {"referenceID": 18, "context": "For the class of programs where the two semantics coincide, system DLV-HEX can be viewed as an implementation of the stable model semantics of GQ-formulas; A recent extension of system F2LP [19] to allow \u201ccomplex\u201d atoms may be considered as a front-end to DLVHEX to implement the generalized FLP semantics.", "startOffset": 190, "endOffset": 194}], "year": 2013, "abstractText": "We present alternative definitions of the first-order stable model semantics and its extension to incorporate generalized quantifiers by referring to the familiar notion of a reduct instead of referring to the SM operator in the original definitions. Also, we extend the FLP stable model semantics to allow generalized quantifiers by referring to an operator that is similar to the SM operator. For a reasonable syntactic class of logic programs, we show that the two stable model semantics of generalized quantifiers are interchangeable.", "creator": "LaTeX with hyperref package"}}}