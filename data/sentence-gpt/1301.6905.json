{"id": "1301.6905", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Jan-2013", "title": "Towards a Logic-Based Unifying Framework for Computing", "abstract": "Computer Science today lacks a unified view of Computing. Instead, the main subareas, most notably artificial intelligence, database systems and programming languages, offer different and often competing approaches to knowledge representation, problem-solving and computation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Tue, 29 Jan 2013 12:23:26 GMT  (756kb)", "http://arxiv.org/abs/1301.6905v1", null], ["v2", "Thu, 24 Apr 2014 07:25:29 GMT  (0kb,I)", "http://arxiv.org/abs/1301.6905v2", "An improved version of this paper will be published in the journal, New Generation Computing, with the title \"Reactive Computing as Model Generation\". In the meanwhile, a copy of the revised paper can be found onthis http URL"]], "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.DB cs.PL", "authors": ["robert kowalski", "fariba sadri"], "accepted": false, "id": "1301.6905"}, "pdf": {"name": "1301.6905.pdf", "metadata": {"source": "CRF", "title": "Towards a Logic-Based Unifying Framework for Computing", "authors": ["ROBERT KOWALSKI"], "emails": [], "sections": [{"heading": null, "text": "Towards a Logic-Based Unifying Framework\nfor Computing ROBERT KOWALSKI, Imperial College London FARIBA SADRI, Imperial College London\nComputer Science today lacks a unified view of Computing. Instead, the main subareas, most notably artificial intelligence, database systems and programming languages, offer different and often competing approaches to knowledge representation, problem-solving and computation.\nIn this paper we propose a unifying logic-based, framework for Computing, inspired by artificial intelligence, but scaled down for practical database and programming applications. Computation in the framework is viewed as the task of generating a sequence of state transitions, with the purpose of making an agent\u2019s goals all true. States are represented by sets of atomic sentences (or facts), representing the values of program variables, tuples in a coordination language, facts in relational databases, or Herbrand models. In the model-theoretic semantics, the entire sequence of states and events are combined into a single model-theoretic structure, by associating time stamps with facts. But in the operational semantics, facts are updated destructively, without time stamps. We show that the model generated by destructive updates is identical to the model generated by reasoning with facts containing time stamps. We also extend the model with intentional predicates and composite event predicates defined by logic programs containing conditions in first-order logic (FOL). We extend the notions of local stratification and weak stratification to generate the associated model.\nKeywords: state transition system, reactive systems, composite events, model generation, frame problem, FOL-stratification, FOL-perfect model"}, {"heading": "1. INTRODUCTION", "text": "Computing today, as a scientific discipline, lacks a unifying framework. It consists, instead, of diverse techniques in such various areas as artificial intelligence, databases and programming. Logic programming was an early attempt to provide a unifying framework for computing, based on the use of logic for knowledge representation and problem-solving. Arguably, this attempt had only limited success, because it failed to address adequately the fundamental role of state transition systems in computing.\nIn this paper, we present a candidate unifying framework for computing, based on the use of logic for representing state transition systems. Although the approach has its origins in research about representing and reasoning about states, actions and events in artificial intelligence, it has been scaled-down to make it more like conventional programming languages and database and information management systems.\nEarlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b]. In those papers, we referred to the framework as LPS, to highlight its focus on providing a Logic-based approach to Production Systems. In this paper, for the sake of continuity, we retain the name LPS, although the intended applications of the approach have been extended considerably. These applications include its use as an agent programming language, active database language, and a language for programming concurrent systems. It can also be used for teleo-reactive computing [Nillson 2001; Kowalski and Sadri 2012a], composite (or complex) event processing, and complex processes.\nAn LPS framework <R, L, D> represents the goals and beliefs of a single agent embedded in a global environment. The reactive rules R, which represent the agent\u2019s maintenance goals, have the logical form of material implications X [antecedent  Y consequent]. The logic program L represents the agent\u2019s view of the changing state and the state transforming events. The domain theory D,\nwhich also has the form of a logic program, is a causal theory, which specifies the effect of concurrent sets of events on the state of the environment.\nThe global environment and the agent\u2019s own internal state are combined in a separate, single state S, represented by a set of atomic sentences, called facts or fluents. The state is like a relational database, but also like a set of program variables or tuples in a coordination language [Carriero and Gelernter 1989].\nState transitions are generated by sets of concurrently occurring events. These events can include both the simultaneous actions of a single agent, the simultaneous actions of several agents, or external events of other origin. Their preconditions and postconditions are specified by the domain theory D. The domain theory D is similar to the situation calculus [McCarthy and Hayes 1969] or event calculus [Kowalski and Sergot 1986], but instead of using frame axioms to update states, it performs destructive updates on the current state, deleting facts that are terminated by the set of all events occurring in the state transition and adding facts that are initiated by the set of events.\nThe logic program L = Lint  Levents  Ltimeless  Ltemp performs a supporting role.\nLint defines intensional predicates in terms of extensional predicates, Levents defines composite events in terms of state conditions and simpler events, Ltimeless defines time independent predicates, and Ltemp defines temporal relationships, such as successor and inequality relations between time points.\nThe logic program S  Lint  Ltimeless can be viewed as a deductive database state. The logic program Levents  Ltemp  Ltimeless superimposes a collection of composite events on top of the sequence of successive states and simple events. These composite events can be viewed as state-connecting paths, as in transaction logic [Bonner and Kifer 1993].\nThe reactive rules R, logic programs L and domain theory D can contain state conditions that are formulas of first-order logic (FOL), which are like FOL queries to a relational or deductive database. The semantics of these FOL conditions is given by generalising negative literals to FOL conditions in the definitions of local stratification [Przymusinski 1987] and weak stratification [Przymusinska and Przymusinski 1988].\nAlthough the operational semantics employs destructive updates and destructive assignment to maintain only a current state, the model-theoretic semantics is defined relative to the entire sequence of states, events and paths combined into a single model in which facts and events are time-stamped. In the model-theoretic semantics, the computational task is to generate a model that makes the reactive rules R all true. The logic program L contributes to the definition of the model by adding intensional facts and composite events to the sequence of time-stamped extensional facts and simple events.\nIn this paper, we show that, given the same initial state and the same sequence of state-transforming events, the model generated by LPS using destructive updates is identical to the \u201cnatural\u201d model generated by using a frame axiom. We define a generalization of weak stratification in order to specify this natural model.\nThe view of computation in LPS as model generation needs to be distinguished from the use of model checking for proving program properties. In a sense, the reactive rules are program properties that are represented explicitly in the program and are used operationally in the attempt to generate a model that makes them true. In [Kowalski and Sadri 2012a], we showed how to derive a program property\nthat is not represented explicitly. The derivation uses ordinary deduction, presented as a proof tree. It would be interesting to investigate the use of model checking techniques for the same purpose.\nThe paper is organised as follows: Section 2 introduces the framework informally by means of examples, and aims to give a flavour of the breadth of its applications. Then sections 3-6 investigate the framework more formally. Section 3 defines the language, section 4 introduces the model theory, section 5 presents the operational semantics, section 6 gives further details of the model theory, and section 7 discusses soundness and completeness. Section 8 shows that destructive updates in LPS generate the same models as the frame axiom. In sections 9 and 10, we discuss related and future work.\nCompared with earlier papers, the main contributions of this paper are its more rigorous treatment of the semantics of reactive rules and logic programs with FOL conditions, and its demonstration of the relationship between the frame axiom and destructive updates. We also present a preliminary approach to the treatment of concurrent events."}, {"heading": "2. EXAMPLES", "text": ""}, {"heading": "2.1 Emergencies", "text": "The following example is a variant of an example in [Hausmann et al. 2012]. In this example, a reactive agent monitors a building for outbreaks of fire. The agent receives inputs from a heat sensor and a smoke detector. If these inputs are sufficiently close together in time, then the agent recognises a possible fire, and attempts to deal with it. There are two alternative ways of dealing with the possible fire. One alternative is to activate local fire suppression devices and then to call for a security guard to inspect the area. The other alternative is simply to call the fire department.\nThe example illustrates several features of LPS, including reactivity, composite events, composite processes and non-determinism. The representation is an LPS framework <R, L, D> consisting of a main program R, which contains a single reactive rule, and a logic program L. However, S, Lint and the domain theory D are all empty. In an elaboration of the example, S  Lint  Ltimeless could include such additional information as the geography of the building and the location, identity and capabilities of the security guards. Here the variables T and Ti all represent time points. The predicates heat-sensed and smoke-detected represent input events taking place over short periods of time [Tf1, Tf2] and [Ts1, Ts2], respectively.\nWe use the forward arrow  for the implication symbol in reactive rules, and the backward arrow  in logic programming clauses. As in Prolog, identifiers beginning with an upper case letter denote variables, and numbers or identifiers beginning with a lower case letter denote constants.\nR heat-sensed(Area, Tf1, Tf2)  smoke-detected(Area, Ts1, Ts2) \n|Tf1 \u2013 Ts1|  60 sec  max(Tf2, Ts2, T)  fire-response(Area, T, T1, T2 )  T < T1\nLevents fire-response(Area, T, T1, T4 )\n activate-fire-suppression(Area, T1, T2)  T < T1  T +5 sec \nsend-security-guard(Guard, Area, T3, T4)  T2 <T3  T2 + 10 sec\nfire-response(Area, T, T1, T2)  call-fire-department(Area, T1, T2)  T <T1  T + 120 sec\nAll variables in a reactive rule are universally quantified with scope the entire rule, except for variables that are only in the consequent of a rule. These are existentially quantified with scope the consequent of the rule. Analogously, all variables in a logic programming clause that are not explicitly quantified are universally quantified with scope the entire clause. However, variables that occur only in the body of a clause and are not explicitly quantified can also be considered to be existentially quantified with scope the body of the clause.\nNotice that in this example the antecedent of the rule represents an unnamed composite event and the consequent represents a named composite action, fire-response. This composite action can be regarded as consisting of two alternative plans, each of which is represented by a clause in Levents. The first plan consists of two actions, and the second plan consists of a single action.\nFor simplicity in this example, the events heat-sensed, smoke-detected, activate-fire-suppression, send-security-guard and call-fire-department are all simple events, which are either directly observed in the environment or directly performed as simple actions. In general, events that are not defined in Levents are simple events.\nBoth plans are temporally constrained. In practice, the first plan might be preferred and tried before the second. If any part of the first plan fails, then the second plan can be tried. Moreover, even if the first plan fails, it can be retried as long as the temporal constraints can be satisfied. If both plans fail and cannot be retried, then the reactive rule cannot be made true. This can be avoided by adding additional alternative plans for the consequent of the rule. Notice that the temporal constraints in the logic program ensure that, if the first plan takes too long, then the second plan, which involves calling the fire department, can still be tried.\nIn this example, as in many others, there are potentially many different models that can be generated to make the reactive rule true, some of which are preferable to others. In theory, LPS could be augmented with a control component that decides what actions to perform with a view towards optimising the utility of the resulting model. However, in practice, it is probably sufficient for the programmer simply to order the alternatives, taking both time constraints and preferred outcomes into account.\nWe will see later that LPS is incomplete because it can only generate models that make the consequents of reactive rules true when their antecedents become true. It cannot preventatively make a reactive rule true by making its antecedent false, and it cannot proactively make its consequent true in anticipation of its antecedent becoming true in the future.\nWe will also see later that the explicit representation of time is necessary for the model-theoretic semantics. Moreover, it facilitates the representation and processing of temporal constraints on the timing of fluents and events. However, we will also see that it can be hidden in an external syntax."}, {"heading": "2.2 Dialogue", "text": "In this example, an agent \u201cme\u201d attempts to make a reactive rule true, by generating an output sentence whenever it receives an input sentence from the agent \u201cyou\u201d. The predicate sentence(Agent, T1, T2) represents a composite event taking place from time T1 to time T2.\nR sentence(you, T1, T2)  sentence(me, T3, T4)  T2 < T3  T3 \u2264 T2 + 3 sec\nThe temporal constraint in the consequent of the rule indicates that the composite output action sentence(me, T3, T4) needs to start within 3 seconds of the completed input.\nThe utterance by an agent A of a word W is treated as a simple (or atomic) event that takes place over an interval of time, and is represented by an atomic sentence word(A, W, T1, T2). The interval is represented by its start and end times, T1 and T2, respectively.\nWe assume that the language of LPS is sorted (or typed). In this example, the language would contain disjoint sorts for agents, words, and time points; and the different arguments of the predicate word would be restricted to terms of the appropriate sort.\nThe following sequence of input events represents the utterance by agent \u201cyou\u201d of the stream of words \u201cwhat is your name\u201d. For simplicity, time points are represented by positive integers:\nword(you, what, 1, 2) word(you, is, 2, 3) word(you, your, 3, 4) word(you, name, 4, 5)\nComposite events of uttering nouns, noun phrases, sentences and other parts of speech are represented by means of logic programs in Levents. These programs are similar to the logical representation of definite clause grammars [Pereira and Warren 1980] in Prolog, and used in [Kowalski 1979] to illustrate parsing as reasoning:\nLevents adjective(Agent, T1, T2)  word(Agent, my, T1, T2)\nadjective(Agent, T1, T2)  word(Agent, your, T1, T2)\nnoun(Agent, T1, T2)  word(Agent, name, T1, T2) noun(Agent, T1, T2)  word(Agent, fariba, T1, T2) noun(Agent, T1, T2)  word(Agent, what, T1, T2) verb(Agent, T1, T2)  word(Agent, is, T1, T2)\nsentence(Agent, T1, T3) noun-phrase(Agent, T1, T2)  verb-phrase(Agent, T2, T3) noun-phrase(Agent, T1, T3)  adjective(Agent, T1, T2)  noun(Agent, T2, T3) noun-phrase(Agent, T1, T2)  noun(Agent, T1, T2) verb-phrase(Agent, T1, T3)  verb(Agent, T1, T2)  noun-phrase(Agent, T2, T3) verb-phrase(Agent, T1, T2)  verb(Agent, T1, T2)\nIn this example, S and Lint are empty. Notice that the logic program Levents does not distinguish between recognising sentences and generating them.\nThe operational semantics of LPS, which we define later in paper, reasons forwards from the antecedents of rules to their consequents, and evaluates simple events and FOL state conditions in the rules in their temporal order. It decomposes composite events in the consequents of rules top-down into conditions and simpler events. But it is neutral with respect to the evaluation of composite events in the antecedents of rules, and it is neutral with respect to whether state conditions are evaluated top-down (backwards) or bottom-up (forwards).\nGiven the above sequence of input events, one way of satisfying the top-level goal,\nrepresented by the reactive rule, is to generate the following sequence of actions:\nword(me, my, 6, 7) word(me, name, 7, 8) word(me, is, 8, 9) word(me, fariba, 9, 10)\nAssuming that there are no further sentences uttered by \u201cyou\u201d, the reactive rule is true in the resulting Herbrand model:\n{word(you,what, 1, 2) noun(you,1, 2) noun-phrase(you, 1, 2) word(you,is, 2, 3) verb(you,2, 3) noun-phrase(you, 3, 5) word(you,your, 3, 4) adjective(you,3, 4) noun-phrase(you, 3, 4) word(you,name, 4, 5) noun(you,4, 5) verb-phrase(you, 2, 5) sentence(you, 1, 3) sentence(you, 1, 5)\nword(me, my, 6, 7) adjective(me, 6, 7) noun-phrase(me, 6, 8) word(me, name, 7, 8) noun(me, 7, 8) noun-phrase(me, 7, 8) word(me, is, 8, 9) verb(me, 8, 9) noun-phrase(me, 9, 10) word(me, fariba, 9, 10) noun(me, 9, 10) verb-phrase(me, 8, 10) sentence(me, 7, 9) sentence(me, 7, 10) sentence(me, 6, 10)}  Temp\nHere Temp is the extension of the temporal inequality relation defined by Ltemp. Notice that the grammar would need to be refined to avoid concluding sentence(you, 1, 3), sentence(me, 7, 9), sentence(me, 7, 10), which are intuitively unintended.\nIn some of the earlier versions of LPS, we treated events as instantaneous and states as having duration. However, in the remainder of this paper, we do the opposite and treat states as instantaneous and events as having duration. The different treatments are different ways of ensuring that the truth value of a fluent does not change within a state, but changes only in the transition from one state to the next. The general approach of LPS is compatible with both treatments of time."}, {"heading": "2.3 Blocks world", "text": "In the previous examples, there are no internal states. Instead, events come and go without leaving any trace. This is not typical of programs in LPS.\nThe blocks world illustrates the more typical case of a program with an internal state. In this example, the state can be viewed as the extensional part of a deductive database, in which on(Block, Place, T) is an extensional predicate, and clear(Place, T) is an intensional predicate. We assume that the language is ordersorted, with sorts for blocks, places and time points. The sort places includes the sort blocks and contains in addition the constant table.\nAssuming, for simplicity, that the table is always clear, the predicate\nclear(Place, T) is defined by two clauses in Lint:\nLint clear(table, T)\nclear(Block, T)   X on(X, Block, T)\nWe treat negative literals in the body of a clause as a special case of an FOL condition. Operationally, an FOL condition is a query to predicates defined at a lower stratum than the stratum of the predicate defined in the head of the clause. Clauses satisfying this condition (which we call FOL-stratification and define formally later) are a natural generalisation of locally stratified logic programs. In\nthis example, there are two strata: The lower stratum corresponds to the extensional part of the database, and the upper stratum corresponds to the intensional part. More generally, as we will see later, the intensional predicates can be spread over several strata.\nIn general, events, including the agent\u2019s own actions and external events, update only the extensional part of a database state. The intensional fluents are updated implicitly, as a result of updates to the extensional part.\nIn general, the set of simple events taking place from T1 to T2 generate a state transition from the state whose fluents all hold at time T1 into the next state whose fluents all hold at time T2. In this example, the updates are associated with the simple event move(Block, Place, T1, T2), defined by the domain theory D. This is similar to the treatment of events in the event calculus. We assume that the arguments of move are typed, so that it is not possible to move the table.\nAs in the event calculus, it is convenient to represent time-stamped fluents and events by means of meta-predicates, writing for example holds(p, t) instead of p(t) and happens(e, t1, t2) instead of e(t1, t2). We also combine both notations interchangeably.\nIn general D consists of two parts, Dpost which is concerned with the postconditions of events and Dpre which is concerned with the preconditions of events. In this example Dpost specifies the fluents that are initiated and terminated by the simple event move(Block, Place), and is given below. Dpre will be described later.\nDpost initiated(on(Block, Place), T1, T2)  happens(move(Block, Place), T1, T2) terminated(on(Block, Support), T1, T2)  happens(move(Block, Place), T1, T2) \non(Block, Support, T1)\nThe task of putting a block on a place can be triggered by an input event requesting that the block be put on the place, represented by a reactive rule:\nR request(on(Block, Place), T1, T2)  make-on(Block, Place, T3, T4)  T2 \u2264 T3\nHere request(on(Block, Place), T1, T2) is a simple, external event, which does not initiate or terminate any fluents. Alternatively, it could initiate a fluent that stores a record of the request.\nIn a more realistic example, additional conditions might be included in the antecedent of the rule, for example to check that the request is authorised, and additional constraints might be included in the consequent of the rule to constrain the amount of time that can elapse between the request and its fulfilment.\nThe predicate make-on can be defined as a composite action/event, using an\nauxiliary composite action/event make-clear:\nLevents make-on(Block, Place, T, T)  on(Block, Place, T)\nmake-on(Block, Place, T1, T4)  \u00ac on(Block, Place, T1) \nmake-clear(Block, TB1, TB2)  make-clear(Place, TP1, TP2)  move(Block, Place, T3, T4)  T1 \u2264 TB1  T1 \u2264 TP1  TB2 \u2264 T3  TP2 \u2264 T3\nmake-clear(Place, T, T)  clear(Place, T) make-clear(Place, T1, T4)  Place  table  on(Block, Place, T1) \nmake-clear(Block, T1, T2)  move(Block, table, T3, T4)  T2 < T3\nNotice that the two make-clear events in the body of the second make-on clause are partially ordered. They can be performed in any order, as well as at the same time,\nfor example by using two hands. Notice, moreover, that, it might be desirable to add an extra condition to the body of the clause, constraining the make-clear events so that one of them starts as soon as the condition \u00ac on(Block, Place, T1) is verified.\nThe clauses in Levents are written in a teleo-reactive style, and have a base case corresponding to the goal of the composite action. Teleo-reactive programs facilitate both the re-execution of plan subgoals when plans fail, and the omission of plan subgoals when the environment opportunistically solves these subgoals instead. These features of teleo-reactive programs apply also to LPS programs more generally. We present an example later in this subsection.\nIn an earlier version of LPS [Kowalski and Sadri 2011] we allowed \u201cplanning\nclauses\u201d, which in the case of make-clear could have the form:\nclear(Place, T3)  on(Block, Place, T1)  clear(Block,T1) \nmove(Block, table, T2, T3)  T1 < T2\nSuch planning clauses allow a higher level of knowledge representation than the version of LPS presented in [Kowalski and Sadri 2012a; Kowalski and Sadri 2012b] and in this paper. However, the behaviour of programs containing planning clauses is more complicated and harder to understand.\nIt is possible to transform planning clauses into composite event definitions and vice versa. In any case, it is important to appreciate that LPS programs do not perform planning from first principles, but simply execute pre-existing, explicitly represented conditional plans. This is similar to plans in practical BDI agent languages.\nIn earlier papers, we allowed only one action to be executed at a time. In this paper, we allow concurrent actions and other events. In the blocks world, in particular, we can allow several agents to pick up blocks concurrently, in which case an action by one agent becomes an external event for another agent.\nIn the simplest case, concurrent events are independent, and their combined effects are simply the collection of their individual effects. However, in other cases, concurrent events can have combined effects that are different from the effects of their individual events. For example, two concurrent events of picking up two ends of a table have different combined effects from the individual events of picking up only one end of the table.\nIn this example, we consider the case of competing events, which are prevented from occurring concurrently by means of integrity constraints in Dpre. These integrity constraints have the form of logic programming clauses with head false; but as we will see later, they play a different role in the semantics from other logic programming clauses.\nDpre false  happens(move(Block, Place), T1, T2) \n [clear(Block, T1)  clear(Place, T1)]\nfalse  happens(move(Block, Place), T1, T2)  Block = Place false  happens(move(Block, Place1), T1, T2) \nhappens(move(Block, Place2), T1, T2)  Place1  Place2\nfalse  happens(move(Block1, Place), T1, T2) \nhappens(move(Block2, Place), T1, T2)  Block1 Block2  Place table\nfalse  happens(move(Block1, Block2), T1, T2) \nhappens(move(Block2, Place), T1, T2)\nThe integrity constraints in Dpre also represent the preconditions of individual events, as exemplified by the first two constraints above. Notice that, given three candidate events, say move(a, b), move(c, d) and move(d, e) each of which is possible in isolation, but not in combination, there are two possible sets of two concurrent events, {move(a, b), move(c, d)}, {move(a, b), move(d, e)}, three possible singleton sets {move(a, b)}, {move(c, d)}, {move(d, e)} and the empty set {}.\nAs a concrete example, consider two agents ag1 and ag2 with initial goals: make-on(a, c, T1, T2)  T1 > 0, and make-on(d, f, T3, T4)  T3 > 0, respectively. Let the initial state be as pictured:\nb d\na c f\nThe two agents can attempt to achieve their individual goals, first by incrementally generating a tree of subgoals, each. Here we ignore the time parameters for ease of reading:\nag1 ag2\nmake-on(a, c) make-on(d, f)\nmake-clear(a)  make-clear(c)  make-clear(d)  make-clear(f)  move(a,c) move(d, f)\nmove(b, table)  move(d, table)  clear(d)  clear(f)  move(d, f) move(a,c)\nmove(d, f)\nThe tree has other branches, but we assume either that they have already been explored and failed, or that they can be explored in the future.\nHaving generated these branches, suppose agent ag1 selects candidate actions {move(b, table), move(d, table)} and ag2 selects candidate action{move(d, f)} for execution at the same time \u2013 other variations are also possible. The three actions are not possible concurrently. Suppose the successful actions are move(b, table) and move(d, f), i.e. one action is successful for each agent. The state will be transformed into the following:\nd\na c f b\nThe initial goal of agent ag2 has been achieved. However, only the first subgoal of the current plan of agent ag1 has been achieved. Agent ag1 can continue with its current plan, in which case it will unnecessarily retry the action move(d, table). Or it\ncan take advantage of the opportunistic solution by agent ag2 of the higher-level subgoal make-clear(c) in the higher-level, more abstract plan make-clear(a)  make-clear(c)  move(a,c), and solve its initial goal, by performing the action move(a,c) in one step.\nThe model-theoretic semantics of LPS defines computation as the task of generating a model that makes an agent\u2019s reactive rules and initial goals all true. It is not concerned with optimising the generated model. In the example above, the chosen solution is a model that contains the fewest actions. In other applications, it may be desirable to generate a model that maximizes concurrency, as in the following example."}, {"heading": "2.4 The Dining Philosophers", "text": "Although the dining philosophers\u2019 problem was originally proposed as a problem of concurrent programming, the problem can also be viewed in both database and AI knowledge representation and problem-solving terms:\nIn the initial state, five philosophers sit around a circular table with a bowl of spaghetti in the middle of the table and five forks, one to the left and one to the right of each philosopher. Each philosopher alternates between thinking and eating. In order to eat, a philosopher needs two adjacent forks. A philosopher can pick up the two adjacent forks if they are both available.\nThe setting of the problem is similar to that of the blocks world. The forks are like blocks, having a fork is like there being an object on a block, and a fork being available is like a block being clear. Similar constraints apply to picking up a fork as apply to picking up a block: A fork cannot be picked up and moved simultaneously to two different locations (philosophers).\nThe solution of the dining philosophers\u2019 problem presented below is similar to the solution in C-Linda [Carriero and Gelernter 1989]. Here we assume that the five philosophers are represented by five separate processors or agents, each of which has its own local copy of the same framework <R, L, D>, but shares a single copy of the global state. The global state acts as a coordination medium, which nondeterministically decides which possible sets of concurrent events actually occur.\nThe only extensional predicate in the representation is the predicate available(Fork, T), and Lint ={}. In the initial state S0, all five forks are available. To facilitate updating the state destructively, the extensional fluents are represented without time parameters:\nS0 = {available(fork(0)), available(fork(1)), available(fork(2)), available(fork(3)),\navailable(fork(4))}.\nFor simplicity the predicate adjacent(fork(0), philosopher(0), fork(1)) is treated as time-independent:\nLtimeless adjacent(fork(0), philosopher(0), fork(1)) adjacent(fork(1), philosopher(1), fork(2)) adjacent(fork(2), philosopher(2), fork(3)) adjacent(fork(3), philosopher(3), fork(4)) adjacent(fork(4), philosopher(4), fork(0))\nThe extensional fluents are like tuples in a relational database, or in a coordination language [Carriero and Gelernter 1989]. They are also like the values of \u201cvariables\u201d\nin conventional programming languages. For example, updating the state by adding the fluent available(fork(f)) is like executing an assignment statement available(fork(f)) := true, assigning the value true to the \u201cvariable\u201d available(fork(f)).\nThe solution in C-Linda uses four tickets. To eat, a philosopher needs not only two forks but also one ticket. This ensures that at least one philosopher is always able to eat. We have programmed this solution in LPS, but here we present a solution using a simple action of picking up two adjacent forks simultaneously.\nEach philosopher, philosopher(i), 0 \u2264 i \u2264 4, can perform four simple actions, of thinking, picking up forks, eating, and putting down forks. These can be combined into a single composite action, dine:\nLevents dine(philosopher(i), T1, T6)  think(philosopher(i), T1, T2)  adjacent(F1, philosopher(i), F2) \npickup-forks(F1, philosopher(i), F2, T3, T4)  T2 \u2264 T3  eat(philosopher(i), T4, T5)  putdown-forks(F1, philosopher(i), F2, T5, T6)\nNotice that the temporal constraints here allow a lapse of time between thinking and picking up forks, because forks may not be available as soon as thinking is completed. But no such lapse of time takes place between picking up forks and eating and between eating and putting down forks.\nThe composite action dine can be triggered by means of a reactive rule and an\nevent of it becoming time to eat:\nR time-to-eat(philosopher(i), T1, T2)  dine(philosopher(i), T3, T4)  T2 \u2264 T3\nFor example, the five instances of the rule could be triggered by the five concurrent external events:\nev1 = {time-to-eat(philosopher(0), 0, 1), time-to-eat(philosopher(1), 0, 1),\ntime-to-eat(philosopher(2), 0, 1), time-to-eat(philosopher(3), 0, 1), time-to-eat(philosopher(4), 0, 1)}\nAdditional temporal constraints could be imposed on the consequent of the rule, to try to prevent the philosophers from starving while waiting to eat.\nThe solution of the dining philosophers\u2019 problem is shared between the reactive rules and logic programs used by the individual philosophers and the domain theory used to update the global state. For the philosophers\u2019 part, it suffices for each philosopher to employ the one reactive rule in R and the one logic programming clause in Levents. The domain theory D defines the post-conditions and preconditions of the simple atomic actions. In this simple formulation of the problem, the only actions that change the state are the actions of picking up and putting down forks:\nDpost terminated(available(F), T1, T2) \nhappens(pickup-forks(F1, philosopher(I), F2), T1, T2)  (F = F1  F = F2)\ninitiated(available(F), T1, T2) \nhappens(putdown-forks(F1, philosopher(I), F2), T1, T2)  (F = F1  F = F2)\nDpre false  happens(pickup-forks(F1, philosopher(I), F2), T1, T2)   [available(F1, T1)  available(F2, T1)]\nfalse  happens(pickup-forks(F1, philosopher(I), F), T1, T2) \nhappens(pickup-forks(F, philosopher(J), F2), T1, T2)\nThe first constraint in Dpre ensures that a philosopher picks up forks only if they are available, and the second constraint ensures that two philosophers I and J do not pick up the same fork F simultaneously.\nIn general, when a simple event happens, then all fluents initiated by the event are added and all fluents terminated by the event are deleted in the state transition. In this sense, simple events are atomic, in that either all their effects succeed or all their effects fail at the same time. The domain theory D and its use for defining state transitions provides a declarative semantics for such forms of atomicity, with details concerning roll-back and critical sections relegated to the implementation.\nThe model-theoretic and operational semantics, defined later, are the semantics of a single agent, say agent 0 for example, interacting with a single current state. In the dining philosopher\u2019s problem, this single state is a global state shared with other philosophers. The domain theory is used to update this state.\nIn order to generate the external events for agent 0 and to correctly update the global state, it is necessary to simulate the other agents and to generate their candidate actions, which are external events for agent 0. It is also necessary to arbitrate between competing candidate actions and to choose a set of concurrent actions that satisfy the integrity constraints in Dpre. This choice of concurrent actions is non-deterministic, but one such sequence of choices is shown below. In fact, this is the sequence generated by our Prolog prototype of LPS.\nHere S0, S1,\u2026, S12 is the sequence of states, and ev1,\u2026, ev12 is the sequence of events, where evi is the set of all events that take place concurrently in the transition from state Si-1 to state Si:\nS2 = S1 = S0 ev2 = {} ev3 = {think(philosopher(0)), think(philosopher(1)), think(philosopher(2)),\nthink(philosopher(3)), think(philosopher(4))}\nS3 = S2 ev4 = {pickup-forks(fork(0), philosopher(0), fork(1)),\npickup-forks(fork(2), philosopher(2), fork(3))}\nS4 = {available(fork(4))} ev5 = {eat(philosopher(0)), eat(philosopher(2))} S5 = S4 ev6 = {putdown-forks(fork(0), philosopher(0), fork(1)),\nputdown-forks(fork(2), philosopher(2), fork(3))}\nS6 = S2 = S1 = S0 ev7 = {pickup-forks(fork(1), philosopher(1), fork(2)),\npickup-forks(fork(3), philosopher(3), fork(4))}\nS7 = {available(fork(0)) } ev8 = {eat(philosopher(1)), eat(philosopher(3))} S8 = S7 ev9 = {putdown-forks(fork(1), philosopher(1), fork(2)),\nputdown-forks(fork(3), philosopher(3), fork(4))}\nS9 = S6 = S2 = S1 = S0 ev10 ={pickup-forks(fork(4), philosopher(4), fork(0)} S10 = {available(fork(1)), available(fork(2)), available(fork(3))} ev11 ={eat(philosopher(4))} S11 = S10 ev12 = {putdown-forks(fork(4), philosopher(4), fork(0))}"}, {"heading": "S12 = S9 = S6 = S2 = S1 = S0", "text": "In the model-theoretic semantics, all the events and states are combined into a single Herbrand model M by adding an extra temporal argument to fluents and events. The model M also contains the extension of the temporal inequality relation \u2264 and the composite actions:\ndine(philosopher(0), 2, 6) dine(philosopher(2), 2, 6) dine(philosopher(1), 2, 9) dine(philosopher(3), 2, 9) dine(philosopher(4), 2, 12)\nThe operational semantics correctly generates a model M in which the reactive rule R and the integrity constraints Dpre are all true. The logic program L is used to help generate the model, and therefore is also true in M. Note that even though the global state has information about the availability of all five forks, an individual agent may have access only to information about the availability of forks adjacent to it. In fact the agent can function simply by relying on the environment to tell it when its actions, including picking up forks, are successful."}, {"heading": "3. THE LANGUAGE", "text": "An LPS program <R, L, D> combines the reactive rules R and logic programs L of an individual agent with a domain theory D that is used to perform updates on a current state Si that is possibly shared with other agents. The shared state Si arbitrates between the candidate actions of different agents, non-deterministically choosing a set evi of concurrent events that satisfies the integrity constraints in Dpre, and using Dpost to transform Si-1 into Si.\nThe agent receives observations of the events evi and can query the current state Si to generate candidate actions actsi+1 with the purpose of making the reactive rules R all true. The truth value of R is determined with respect to a natural, minimal model associated with the entire sequence of states S0,\u2026, Si,\u2026. and events ev1,\u2026, evi,\u2026. augmented with higher-level predicates defined by the logic program L = Lint  Levents  Ltimeless  Ltemp.\nThe reactive rules R, logic programs L and D can contain FOL conditions, which operationally query the extended current state. The model-theoretic semantics for FOL conditions generalises the perfect model semantics for negative conditions. It generalises local stratification, by restricting the strata of predicates in FOL conditions in the body of a clause to ones that are lower than the stratum of the predicate occurring in the head. It generalises the perfect model semantics, by generating submodels whose predicates belong to lower strata before using them to generate models whose predicates belong to higher strata.\nStates Si are sets of atomic sentences (or simple fluents), which can be viewed as the extensional component of a deductive database. The domain theory D updates only these extensional predicates. The logic program Lint implicitly updates intensional predicates as ramifications of changes to the extensional predicates. The logic program Levents both recognises and constructs composite events.\nIn the operational semantics, fluents are represented without explicit time. Updates associated with a set evi of events are performed destructively, using the domain theory D to delete fluents that are terminated by evi and to add fluents that are initiated by evi. Fluents that are neither initiated nor terminated simply persist without reasoning that they persist, and without copying them explicitly from one state into the next.\nIn a possible world semantics, as employed in modal logic or TR logic, states are also represented by sets of fluents, but they are linked by an accessibility relation associated with the state transforming events. However, in the model-theoretic semantics of LPS, fluents and events are time-stamped and combined in a single, non-modal model-theoretic structure.\nIn the version of LPS presented in this paper, we assume that time is linear and discrete, and that the succession of time points is represented by the relation succ(s, t) defined in Ltemp (with the aid of Ltimeless) where s and t are real numbers. For simplicity, we assume that there is a state transition from Si-1 to Si associated with each instance succ(ti-1, ti), that all fluents in Si hold at time ti, and that all events in evi occur from time ti-1 to ti. The set evi can be empty. In other papers, we have made the opposite assumption, associating time points with simple events and time intervals with states. The two conventions are mostly interchangeable.\nTo distinguish between a fluent p without a time stamp, needed for destructive updates in the operational semantics, and the same fluent with a time stamp t, needed for the model-theoretic semantics, we either add an extra argument p(t) to p, or we treat p as a term and include it in a meta-predicate such as holds(p, t). To distinguish between a state Si whose fluents are all without time stamps, and the same state in which all the fluents have the same time stamp ti, we write Si*. Similarly, for a simple or composite event e without a time stamp, either we write e(t1, t2), or we include e as a term within a meta-predicate such as happens(e, t1, t2).\nFor the concurrent occurrence of an unstamped set evi of simple events, occurring from time ti-1 to time ti we write evi* for the same set of events with their time stamps."}, {"heading": "3.1 Vocabulary", "text": "We assume an order-sorted language in which the constants and variables of the language are assigned sorts that may be hierarchically ordered. The argument places of function symbols and predicate symbols are correspondingly assigned sorts, so that formulas are well-formed only if the argument places are filled by terms of the allowed sort.\nThe predicate symbols of the language are partitioned into (disjoint) sets representing fluents, events, auxiliary predicates and meta-predicates:\nFluent predicate symbols are partitioned into extensional predicates, which represent facts in the states Si, and intensional predicates defined in Lint.\nEvent predicates are analogously partitioned into simple event predicates and composite event predicates. Simple events can represent either externally generated events or internally generated actions. Composite event predicates are defined in Levents.\nAuxiliary predicates consist of time-independent predicates, such as max and min and others used for arithmetic, defined in Ltimeless, as well as temporal predicates, such as succ, defined in Ltemp.\nThe meta-predicates consist of\n The predicates initiated and terminated defined by the domain theory D,\nand used for performing state transitions; and\n The predicates holds and happens.\nFluents and events occur as terms when they are arguments of the metapredicates.\nStates Si are not represented explicitly in the language, but are represented implicitly by the set of all the extensional facts that are true at time ti. These extensional facts represent the kernel of the state Si. However, conceptually, the set Si*  Lint  Ltimeless, which is the kernel extended by the intensional and timeindependent predicates, can be thought of as the time-stamped extended state at time ti. Similarly, the sets evi of events are not represented explicitly, but are represented implicitly by the set of simple events that occur from time ti-1 to ti."}, {"heading": "3.2 Internal and external syntax", "text": "The explicit representation of time, defined by Ltemp, underpins the model-theoretic semantics of the language. However, at the potential expense of restricting the expressive power of the language, the language can also be expressed in an external syntax in which time is implicit. For example, in [Kowalski and Sadri 2011], temporal ordering is indicated by the order in which formulas are written and by the use of special logical connectives. This is similar to the syntax of TR Logic [Bonner and Kifer 1993], in which P  Q means \u201cdo P and then do Q\u201d. In LPS, depending on the context, this translates into an internal syntax with an explicit representation of time, for example as P(T1, T2)  Q(T2, T3) or as P(T1, T2)  Q(T3, T4)  T2 < T3, if P and Q are events.\nThe internal syntax is also compatible with a modal external syntax. For example, P  \u25caQ can similarly be translated into P(T1, T2)  Q(T3, T4)  T2 < T3, if P and Q are events, and P  \u25cbQ can be translated into P(T1, T2)  Q(T2, T3). However in modal logic, events and actions are not represented by formulas, but by parameters of modal operators, and P and Q would be restricted to fluents. If P and Q are fluents, then P  \u25caQ can be translated into P(T1)  Q(T2)  T1 < T2, and P  \u25cbQ can be translated into P(T1)  Q(T2)  succ(T1, T2).\nGraphical notations for representing partial ordering are also possible. For\nexample, a notation such as:\ncould be used to represent P(T1)  Q(T2)  R(T3)  T1 + 2 < T3  T2 < T3  T2 + 6.\nIn the remainder of the paper, we use the internal syntax with explicit time, because it clarifies the model-theoretic semantics, and because it is neutral with respect to external syntax.\nP\nQ R\n(2,\u221e)\n(0, 6]\nNote that the internal syntax of LPS employs a relational syntax in which function symbols are used only for constructing names of composite objects. It would also be possible to employ an external syntax in which function symbols are used with equality for representing functional relations, as in colour(a) = red or colour(a) = colour(b). In the internal syntax, these would be translated into colour(a, red) and colour(a, X)  colour(b, X) respectively, together with integrity constraints to represent the fact that objects have only one colour. In practice, such integrity constraints might be emergent properties that would not have to be checked explicitly.\nNotice that functional external syntax could be combined with infix notation. For\nexample, T3  T2 + 6 could be regarded as shorthand for T3  T  +(T2, 6, T)."}, {"heading": "3.3 Reactive Rules", "text": "Reactive rules (or simply rules) in R are sentences of the logical form:\nX [antecedent(X) Y consequent(X, Y)]\nwhere X is the set (or tuple) of all unbound variables, including time variables, that occur in antecedent(X), and Y is the set (or tuple) of all unbound variables, including time variables, that occur only in consequent(X, Y). In addition to the variables in X and Y, the rule can contain other variables that are bound in FOL conditions. For notational convenience, we write consequent(X, Y) even though consequent(X, Y) need not contain all the variables that occur in antecedent(X). Because of these restrictions on the quantification of variables, we can omit the quantifiers X and Y. More formally:\nDefinition 3.1 (Reactive rule). A reactive rule is a sentence of the form:\nantecedent(X) consequent(X, Y)\nwhere both antecedent(X) and consequent(X, Y) are a conjunction1 of FOL state conditions, event atoms and temporal constraints.\n An FOL state condition (or simply a state condition) is an FOL formula in\nthe vocabulary of the fluent and time-independent predicates, containing at most a single time variable, which is unbound.\nOperationally, the evaluation of a state condition can be understood as a query to the current extended state Si*  Lint  Ltimeless, where the time parameter refers to the current time ti.\n An event atom is an atomic formula whose predicate symbol is a simple or\ncomposite event. Similarly an action atom is an event atom whose predicate symbol is an action.\n1 In [Kowalski and Sadri 2012b] we allowed consequents of rules to be disjunctions of such conjunctions.\nThis is because we focused on programs consisting of reactive rules without logic programs. In this paper, we obtain a similar effect by allowing consequents to contain predicates defined by nondeterministic logic programs. Alternatively, it would be easy to extend the language of this paper to include the disjunctive consequents of the earlier paper.\n A temporal constraint is an atomic formula of the form succ(time1, time2),\ntime1 < time2 or time1 \u2264 time2 where time1 and time2 represent time points, one of which is a variable, and the other of which is a variable or a constant.\nThe temporal constraints contain only variables that occur in the state conditions and event atoms of the rule, and all the time parameters that occur in the antecedent are constrained directly or indirectly in the consequent to be earlier than or equal to the time parameters that occur only in the consequent.\nNotice that, although fluents can occur as subformulas of FOL conditions, events can occur only as atomic conjuncts. This makes it impossible to represent, for example, the condition that no event of a certain kind occurs within a certain interval of time. This restriction simplifies the operational semantics, so that any non-temporal condition in a reactive rule can be treated as a query to the extended current state Si*  Lint  Ltimeless augmented with evi*. The restriction is not necessary for the model-theoretic semantics, and can be removed at the expense of complicating the operational semantics."}, {"heading": "3.4 Goal clauses", "text": "In both the model-theoretic and operational semantics, whenever the antecedent of a reactive rule becomes true, the consequent of the rule becomes a goal to be made true in the future.\nIn addition to satisfying such derived goals, it may also be required to make an initial set of goals true in the future. For this purpose, and because the operational semantics maintains a goal state containing goal clauses, we define goal clauses here more generally:\nDefinition 3.2 (Goal clause). A goal clause is an existentially quantified conjunction of FOL state conditions, event atoms and temporal constraints. All the variables in the temporal constraints occur in the state conditions and event atoms of the goal clause.\nNote that a goal clause can also be regarded as a reactive rule with an empty (or true) antecedent."}, {"heading": "3.5 Logic programs", "text": "The logic programs L = Lint  Levents  Ltimeless  Ltemp play a supporting role to the reactive rules of an LPS program <R, L, D>. Like the antecedents and consequents of rules, they can also contain non-atomic FOL conditions, as in the extended logic programs of [Lloyd and Topor 1984].\nDefinition 3.3 (Extended logic program). An extended logic program is a set P of\nsentences (or clauses) of the form:\nhead(X)  body(X, Y)\nwhere X is the set of all variables that occur in head(X), and Y is set of all unbound variables that occur only in body(X, Y). The head of the clause head(X) is an atomic formula and the body of the clause body(X, Y) is a (possibly empty) conjunction of\nconditions, which are atomic and non-atomic FOL formulas.2 An extended logic program whose body is a (possibly empty) conjunction of atomic formulas is a Horn clause program.\nClauses are implicitly quantified in the form:\nX [head(X)  Y body(X, Y)]\nwhich is more often written in the logically equivalent form:\nXY [head(X)  body(X, Y)]\nThese quantifiers are normally left implicit, because they can always be reconstructed unambiguously. Also, we drop the qualification \u201cextended\u201d and call extended logic programs simply \u201clogic programs\u201d.\nLloyd and Topor reduce logic programs with FOL conditions in their bodies to normal logic programs whose bodies are literals, namely conjunctions of atomic formulas and negations of atomic formulas. In contrast, we evaluate FOL conditions using the standard definition of truth for formulas of first-order logic. However, for this purpose, we need to ensure that that the predicates of non-atomic FOL conditions are fully defined before the conditions are evaluated. For this purpose, we employ a simple generalisation of local stratification, called FOL-stratification. Later we will generalize this to weak FOL-stratification.\nFOL-stratification is exemplified by the clause that defines the subset relation \nin terms of the membership relation :\nU  V  Z [Z  U  Z  V]\nGiven a set of atomic sentences Memb defining the extension of the predicate , the FOL condition in the body of the clause can be viewed as a query to the extensional database Memb. The results of the query are used to define the predicate  in the head of the clause.\nThe relationship between the two predicates  and  in the clause can be viewed in terms of stratification: The predicate  is defined in a lower stratum, and the predicate  is defined in a higher stratum.\nLoosely speaking, a logic program is FOL-stratified if there is a well-ordering of the ground atoms of the language into distinct strata, such that, for every ground instance C of a clause in the program, the non-atomic FOL conditions in the body of C are defined in lower strata than the stratum of the head of C, and atomic conditions in the body are defined in the same or lower strata than the head.3 In LPS, the component programs Lint, Levents, Ltimeless and Ltemp are all FOL-stratified in this sense.\nFor example, the logic program Lint can be FOL-stratified by assigning extensional and time independent atoms to a lower stratum, and intensional predicates to a\n2 Although a conjunction of FOL formulas is itself an FOL formula, we distinguish between atomic and\nnon-atomic FOL formulas, because non-atomic formulas generalise negative literals in normal logic programming."}, {"heading": "3 Replacing an FOL condition in an FOL-stratified program by one that is logically equivalent does not", "text": "affect the FOL perfect model, if the resulting program is also FOL-stratified. However, it may change a program that is FOL-stratified into one that is not. For example, the program p  p is stratified, but the program p   p is not.\nhigher stratum. As a consequence, FOL conditions in the bodies of clauses can be evaluated without using the intensional predicates. However, the stratification can be extended to multiple levels. For example, if the predicate clear is intensional, then the predicate shallow can be defined as an intensional predicate at a higher stratum than the stratum of clear.\nshallow(Place, T)  Block [on(Block, Place, T)  clear(Block, T)]\nSimilarly, the logic program Levents can be FOL-stratified by assigning fluent, simple event and time-independent predicates to a lower-stratum than composite event predicates. FOL conditions involving the lower-stratum predicates can be viewed as queries to the extended current state Si*  Lint  Ltimeless augmented with evi*.\nWe will define FOL-stratification and its semantics more formally later.\nDefinition 3.4 (The logic programs L). Ltimeless is an FOL-stratified logic program\ncontaining only predicates without time parameters.\nLtemp is an FOL-stratified logic program defining the temporal predicates succ, \u2264 and <, as a discrete total ordering.\nLint is an FOL-stratified logic program, consisting of clauses of the form head(X, T)  body(X, Y, T) in which the predicate in the head is an intensional predicate, and the predicates in the body are intensional, extensional or timeindependent predicates. The intensional predicates are assigned to higher strata than the extensional and time-independent predicates. Each clause in Lint contains exactly one time parameter T that is a variable.\nLevents is an FOL-stratified logic program, consisting of clauses of the form head(X, T1, T2)  body(X, Y, T1, T2) in which the predicate in the head is a composite event predicate, and the predicates in the body are composite event, simple event, fluent, time-independent or temporal predicates. The composite event predicates are all assigned to a higher stratum than the simple event, fluent and time-independent predicates. T1 and T2 represent the interval over which the composite event takes place, and are constrained to be, respectively, the earliest and latest time variables occurring in a fluent or event atom in body(X, Y, T1, T2)4.\nThe time variables in temporal constraints must all occur in the head or unbound\nin fluent or event atoms in the body.\nNote that the body of a clause in Levents is equivalent in form both to a goal clause, and to an antecedent or consequent of a reactive rule."}, {"heading": "3.6 The domain theory D", "text": "The domain theory D of an LPS program <R, L, D> has two components D = Dpost  Dpre. The first component Dpost is an FOL-stratified logic program that specifies the extensional fluents that are initiated and terminated by simple events. The second component Dpre is a set of integrity constraints restricting the occurrence and co-occurrence of simple events.\n4 Note that X might include other time parameters, as in the emergency example of section 2.\nDefinition 3.5 (Domain theory D). Dpost is a set of clauses of the form:\nhead(T2)  body(T1, T2)\nand Dpre is a set of integrity constraints of the form:\nfalse  body(T1, T2)\nhead(T2) is an atom of the form initiated(P, T2) or terminated(P, T2), where P is an extensional fluent. body(T1, T2) is an FOL formula containing only simple event predicates with time parameters T1 and T2, fluent predicates with time parameter T1, and time-independent predicates.\nIn the operational semantics, body(T1, T2) is a query to the augmented current state Si*  Lint  Ltimeless  evi* at time ti. An answer to the query is a ground instantiation of the free variables in body(T1, T2), leaving bound variables to be treated according to the classical semantics of universal and existential quantifiers.\nThe FOL-stratification of Dpost consists of two strata: The predicates defined by Si*  Lint  Ltimeless  evi* constitute the lower stratum, and the meta-predicates initiated(P, T2) and terminated(P, T2), constitute the higher stratum"}, {"heading": "3.7 The environment", "text": "An LPS framework <R, L, D> represents the goals R and beliefs L of an individual agent embedded in an environment, which consists of a current state Si and current set evi of events. For simplicity, the current state includes both the agent\u2019s own local state and the whole of the external, global state. Similarly, the current events include both the agent\u2019s own local actions and all external, global events.\nIn a multi-agent system, the global components are shared among all the agents, but the local components are encapsulated. In a closed system, consisting of a single agent with no external environment, the entire state is internal, and all events are internal actions.\nDpost uses the events evi to update the state Si, and Dpre ensures that the set evi of events is possible. Dpost updates both the local and global components of the state, using both local and global events. In the case of purely internal actions, these updates are performed entirely by the agent itself. In the case of concurrent events whose effects depend on both internal actions and external events, the updates are performed by the external environment.\nThe computational task for LPS is defined in terms of making the goals R  G0 of an individual agent true in a model that is determined by the combined local and global components of the environment. This ensures that, in a multi-agent setting, all the agents have the same consistent (and co-ordinated) view of the shared components of the environment. However, it does not mean that all the agents have unrestricted access to all the information in the environment. An agent\u2019s access to the environment is restricted inherently by its vocabulary. Moreover, the external environment might also impose further restrictions of its own.\nIn a more refined formalization of LPS, it might be desirable to decompose the environment into separate local and global components. However, to simplify the treatment in this paper, we combine the local and global components of the environment into a single entity."}, {"heading": "4. THE MODEL-THEORETIC SEMANTICS OF LPS", "text": "In this section, we present two alternative semantics: The first involves an event theory ET that uses a frame axiom to express that any fluent that is not terminated by a state transition persists from one state to the next. The second uses destructive state updates. In section 8, we show that the two semantics generate the same intended models."}, {"heading": "4.1 The event theory ET", "text": "The event theory ET is a logic program that, given Dpost  L  S0*  ev*, defines when an extensional fluent P holds at a time point T > 0:\nDefinition 4.1 (Event theory ET). The event theory ET consists of the two clauses:\nholds(P, T2)  initiated(P, T1, T2) holds(P, T2)  holds(P, T1)  succ(T1, T2)  \u00ac terminated(P, T1, T2)\nET is a hybrid of the situation calculus and the event calculus. The second clause is a frame axiom in the spirit of the situation calculus. However, because states are not represented explicitly in LPS, the ontology of ET is that of the event calculus.\nWith the aid of ET, we can give a simple characterization of the computational\ntask for LPS:\nDefinition 4.2 (Computational task according to ET). Given an LPS program <R, L, D>, an initial state S0 and initial set of goal clauses G0, the computational task is to generate, for every set exti of external events, where i  1, a set actsi+1 of actions, such that:\nET  Dpost  L  S0*  ev* entails R  G0  Dpre\nwhere ev* = ev1*  ev2*  \u2026  evi*  \u2026\nevi = exti  actsi, for i  1, and act1 = {}.\nThe notion of entailment here is deliberately unspecified, and many different notions of entailment have been proposed for similar event theories, mainly to give them a non-monotonic semantics. The semantics that we will define later is also non-monotonic, and is expressed in terms of the truth of R  G0  Dpre in a uniquely determined, intended model of ET  Dpost  L  S0*  ev*.\nBut, independent of the definition of entailment, reasoning with ET is computationally infeasible. It is not practical either to reason forwards with frame axioms, duplicating facts that hold from one state to the next, or to reason backwards, to determine whether a fact holds in a given state by determining whether it held in previous states. As a consequence, frame axioms are rarely used in practical applications, and destructive assignment or destructive updates are generally used instead.\nThe computational infeasibility of reasoning with the frame axiom(s) has received hardly any attention. For example, [Shanahan 1987], in Solving the Frame Problem, explicitly excludes consideration of \u201cimplementation issues\u201d on page 7. In this paper,\nwe consider computational feasibility to be one of the core issues related not only to implementation, but also to the semantics of state transition systems.\nIn contrast with the use of the frame axiom to reason about change of state in ET,\ncomputation in LPS is performed by using destructive change of state.\nTo avoid repetition, we use the following notation in definition 4.3 and elsewhere\nfor the sequences of time stamped events and states:\nev* = ev1*  ev2*  \u2026  evi*  \u2026\nevi = exti  actsi, for i  1, where act1 = {} S* = S0*  S1*  \u2026  Si*  \u2026\nDefinition 4.3 (Informal specification of the computational task). Given an LPS program <R, L, D>, an initial state S0 and initial set of goal clauses G0, the computational task is to generate, for every set exti of external events where i  1, a set actsi+1 of actions such that R  G0  Dpre is true in the intended model of:\nL  S*  ev*\nwhere for i  1, Si is obtained from Si-1 by deleting all the fluents in Si-1 terminated by evi and adding all the fluents initiated by evi as determined by D.\nIn this specification, the computational task is shared between an agent attempting to execute a collection of candidate-actsi to make R  G0 true and the environment, maintaining Dpre, by arbitrating between the agent\u2019s candidate-actsi and other candidate actions of other agents. The result of this arbitration is a set of events, evi = exti  actsi, selected by the environment, where actsi is the subset of candidate-actsi that have succeeded, and exti is the set of all other successful events.\nThis specification is incomplete. It needs to be augmented with a definition of the intended model, and with a more precise statement of the definition of Si in terms of Si-1. We present the augmented specification in the next subsection."}, {"heading": "4.2 An abstract specification of the computational task", "text": "In general, a logic program P can be viewed as an intensional definition of the predicates that occur in the heads of clauses in P in terms of the predicates that occur in the bodies of clauses in P. These head predicates can also be represented extensionally as a set sem(P) of ground atoms. The set sem(P) has a dual interpretation: syntactically as a set of sentences, and semantically as a modeltheoretic structure. Viewed in semantic terms, sem(P) is a Herbrand interpretation, which represents the set of all the ground atoms that are true in the interpretation.\nIn the simplest case, when P is a set of Horn clauses, there exists an extensional representation sem(P) = min(P) of P that is also minimal (with respect to set inclusion) [van Emden and Kowalski 1976]. This case does not cater for logic programs that contain non-atomic FOL conditions. Later we define two semantics that do cater for such FOL conditions. Both semantics are defined for the case in which non-atomic FOL conditions in the body of a clause are defined in lower strata than the stratum of the head of the clause. The first semantics generalizes local stratification, and the second semantics generalizes weak stratification.\nThe following definition expands the specification of the computational task in 4.3, and presents it in an abstract form that is independent of the semantics sem.\nThe only assumption is that sem associates a unique Herbrand interpretation with every logic program in the class of programs under consideration.5\nDefinition 4.4 (Abstract specification of the computational task). Let sem be a mapping from logic programs P to sets of ground atoms that are instances of the heads of clauses in P. Given an LPS program <R, L, D>, an initial state S0 and initial set of goal clauses G0, the computational task is to generate, for every set exti of external events, where i  1, a set actsi+1 of actions, such that R  G0  Dpre is true in the Herbrand interpretation:\nsem(L  S*  ev*) , where for i  1:\nSi = (Si-1 \u2013 {p | terminated(p, ti-1, ti)  sem(Dpost  Lint  Ltimeless  Si-1*  evi*)})\n {p | initiated(p, ti-1, ti)  sem(Dpost  Lint  Ltimeless  Si-1*  evi*)}.\nIn this definition, the clauses in Dpost can be viewed as querying the augmented current state Lint  Ltimeless  Si-1*  evi* to determine the fluents that have been initiated and the fluents that have been terminated by the set evi of events that take place in the transition from Si-1 to Si.\nThe definition appeals to the notion of truth in a Herbrand interpretation. This\nnotion requires, in turn, the concept of the Herbrand universe:\nDefinition 4.5 (Herbrand universe and Herbrand base). Given the vocabulary of a sorted language, the Herbrand universe is the set of all well-sorted ground terms that can be constructed from the vocabulary. The Herbrand base is the set of all well-sorted ground atoms that can be constructed from the vocabulary.\nDefinition 4.6 (Herbrand interpretation and Herbrand model). A Herbrand interpretation is a subset of the Herbrand base. A Herbrand model M of a set S of sentences is a Herbrand interpretation such that every sentence s in S is true in M.\nThe truth value of a sentence s in a Herbrand interpretation M depends not only upon M, but also upon the Herbrand universe U:\nDefinition 4.7 (Truth). If s  H is an atomic sentence, then s is true in M if and\nonly if s  M, and  s is true in M if and only if s  H.\nFor any formula s(X) with free variables X, X s(X) is true in M if and only if s(x) is true in M for every x  U, and X s(X) is true in M if and only if s(x) is true in M for some x  U.\nThe truth values of all other FOL sentences of the language are defined as usual in classical FOL. In particular, the negation  s of a sentence is true in M if and only if s is not true in M. Thus negation is classical negation, but also has the flavour of negation as failure, because  s is true in M if and only if s fails to be true in M.\nIt is possible to extend the definition of truth to include sentences with aggregation operators, which construct such objects as the set of all terms that satisfy a given formula, the number of such terms, or their sum. This extension is necessary for defining the postconditions of concurrent events whose effects are\n5 This includes the stable model semantics [Gelfond and Lifschitz 1988], if we take sem to be the\nintersection of all stable models, and if we allow the mapping to be partial in case there are no models.\ncumulative (like pushing a block in different directions). We do not explore this possibility further in this paper.\n4.3 The simplified case in which L and Dpost are sets of Horn clauses\nThe abstract semantics of definition 4.4 specializes naturally to the simplified case in which L and Dpost are Horn clause programs. In this case, the semantic mapping sem is given by the minimal model. In general, every set of Horn clauses has a minimal Herbrand model:\nDefinition 4.8 (Minimal model). Given a set of Horn clauses P with Herbrand base H, the minimal model min(P) of P is the smallest set M  H such that, for every ground instance head  body of a clause in P, head  M if body is true in M.\nNotice that with this definition, the minimal model of P is equivalent to the minimal model of ground(P), the set of all ground instances of P.\nSince the body of a Horn clause is a conjunction of atomic formulas, the condition that body is true in M is equivalent to the condition that atom  M for every atomic condition atom in body. As we will see in section 6, the formulation in terms of the truth of body in M has the advantage that it also applies to FOL-stratified clauses whose bodies contain FOL conditions belonging to strata that are lower than the stratum of the head of the clause.\nHere we instantiate the semantics of LPS for the simplified case where L and\nDpost are Horn clause programs:\nDefinition 4.9 (Computational task for Horn clauses). Given an LPS program <R, L, D>, in which L and Dpost are sets of Horn clauses, the computational task is as given in definition 4.4 with sem = min.\nLater in the paper, we instantiate the abstract semantics for more general logic programs containing non-atomic FOL conditions. In the meanwhile, we use the more abstract semantics sem, to evaluate conditions in the operational semantics."}, {"heading": "5. THE OPERATIONAL SEMANTICS", "text": "The operational semantics (OS) can be thought of as a potentially non-terminating cycle, in which external events and internal actions are merged, the state is destructively updated, and the agent thinks and decides what to do next. Thinking can be interrupted to observe changes in the environment, and to perform actions.\nThe cycle is relatively abstract, and is compatible with many different implementations. In particular, although the OS is defined for programs written with an explicit representation of time, it can also be implemented, as in [Kowalski and Sadri 2011], directly for programs written in an external syntax in which temporal order is indicated by the order in which conditions and events are written.\nThe cycle is also only semi-constructive. Extended states can contain a countably infinite number of ground atoms, and an FOL query can have a countably infinite number of answers. In practice, these infinities can be avoided, for example by eliminating function symbols, as in Datalog. None the less, it simplifies the treatment if we do not impose any theoretically unnecessary restrictions.\nWe assume that the i-th cycle coincides with the i-th state Si, and that states are instantaneous, holding at the time point ti. The set of events evi takes place from time ti-1 to time ti, transforming the state Si-1 into the state Si. This is equivalent to assuming that the state Si-1 holds fixed between times ti-1 and ti, and that the events evi take place instantaneously at time ti.\nAs we will see, actions are selected for possible execution at the end of the cycle, but are combined with external events at the beginning of the next cycle. In the case of conflict between the selected actions and external events, the environment determines which sets of concurrent events actually occur."}, {"heading": "5.1 Goal States", "text": "In addition to maintaining the current state Si, the OS maintains a goal state Gi, which is a set (or conjunction) of goal trees. Every node in a goal tree is a goal clause representing an alternative way of solving the top-level goal clause at the root of the tree. This top-level goal clause is either an initial goal clause, or an instance of the consequent of a reactive rule introduced when the antecedent of the rule becomes true. To solve the computational task, all the goal trees must eventually be reduced to true.\nDefinition 5.1 (Goal state). A goal state is a set (or conjunction) of goal trees.\nA goal tree for a goal clause C0 is a set (or disjunction) of goal clauses organized as nodes in a tree. The root of the tree is the goal clause C0. Every child node Ci is obtained from its parent node Ci-1 by goal-reduction in steps 2.1 and 2.2 of cycle.\nA branch of a goal tree is a sequence of nodes C0, C1, \u2026 Cn, n \u2265 0, starting with\nthe root node C0, and such that every node Ci is a child of the previous node Ci-1.\nThe top-level goal clause C0 of a goal tree is reduced to true if and only if there is a branch C0, C1, \u2026 Cn of the tree with Cn = true. In this case we also say that the goal tree is reduced to true.\nThe top-level goal clause C0 of a goal tree is reduced to false if and only if every branch C0, C1, \u2026 Cn of the tree contains a goal clause Cn = false. In this case we also say that the goal tree is reduced to false.\nLogically, a goal state is the (possibly infinite) conjunction of its goal trees, and a goal tree is the disjunction of the (finitely many) goal clauses that are its nodes. An empty goal state is logically equivalent to true, and a goal tree that is reduced to false is logically equivalent to false. Operationally, each goal tree is a separate thread, independent of other goal trees.\nTo simplify the OS, we will assume that composite events in the antecedents of reactive rules have been pre-processed, by performing backward reasoning (with Levents) in advance, reducing composite events to conjunctions of simple events, FOL conditions and temporal constraints. In the general case, this could give rise to an infinite set of reactive rules.\nAlthough a practical implementation can work only with finite sets, in theory the OS can handle such infinite sets. At the expense of complicating the OS, composite event definitions could also be executed in the forward direction, as in many of the integrity checking methods developed for deductive databases. Alternatively, backward reasoning could be used at \u201crun time\u201d to reduce composite event predicates to simpler event predicates. For simplicity, we ignore these (and other) possibilities in this paper.\nIn addition to maintaining a goal state, the OS maintains a current set of reactive rules Ri. A new rule is added to Ri when a conjunct in the antecedent of a rule becomes true. The new rule represents an instance of the rest of the original rule that needs to be true in the future."}, {"heading": "5.2 The OS Cycle", "text": "Given an LPS program <R, L, D>, the i-th iteration of the OS cycle uses the set evi of combined external events exti and actions acti to transform the state Si-1, rules Ri-1 and goal state Gi-1 at time ti-1 into Si, Ri and Gi at time ti, generating a possibly empty set candidate-actsi+1 of candidate actions to be merged with external events and executed at the beginning of the next cycle. Initially i = 1, R0 = R, act1 = {}, and G0, if it is not empty, consists of a one-node tree rooted at an initial goal clause C0.\nTo be faithful to the model-theoretic semantics, it is not possible to restrict the amount of time that can be spent on step 0 of the cycle, which updates the state, and on step 1, which processes the antecedents of reactive rules. In a practical system, it would be necessary to ensure that these steps can be performed in a timely manner, before the next time in the succession of time points.\nAssuming that this assurance can be given for steps 0 and 1, it is also necessary, to restrict the amount of time spent on goal reduction in step for the same reasons, 2. This can be done in a number of different ways. If the time of the next iteration of the cycle is known in advance, then the number of goal-reduction steps can simply be restricted so that the time is not exceeded. Alternatively, the number of goal reduction steps can be limited by a maximum amount Max, and this amount could be decreased every time goal reduction is performed. We have implemented this latter approach in our Prolog prototype, and it is the one we assume here.\nWith these assumptions, the i-th iteration of the cycle consists of the following\nsteps:\nStep 0. Update the current state. The environment arbitrates among the various candidate actions submitted by different agents, together with any other externally generated events, returning a set evi = exti  actsi that includes both external events exti and a subset actsi of the submitted candidate actions candidate-actsi, such that Dpre is true in sem(Si-1*  Lint  Ltimeless  evi*). State Si-1 is transformed into Si, by deleting any fluents p such that terminated(p, ti-1, ti)  sem(Dpost  Lint  Ltimeless  Si-1*  evi*) and adding any fluents p such that initiated(p, ti-1, ti)  sem(Dpost  Lint  Ltimeless  Si-1*  evi*).\nLet Gi = Gi-1, Ri = Ri-1 and candidate-actsi+1 = {}.\nStep 1. Process antecedents of rules. For every reactive rule in Ri, construct every parsing of the rule into the form:\nearly-antecedents  other-antecedents  consequent\nwhere early-antecedents is a conjunction of state conditions and simple events such that all the time parameters in early-antecedents can be unified with the current time ti, without making any temporal constraints in other-antecedents false, and without constraining any of the time parameters in state conditions or events in other-antecedents to be equal to or earlier than ti. For each such parsing, and each ground instance early-antecedents \u03c3 that is true in sem(Lint  Ltimeless  Si*  evi*), generate the corresponding \u201cresolvent\u201d:\nother-antecedents \u03c3  consequent \u03c3\nsimplify the temporal constraints in the resolvent, and add the simplified resolvent as a new reactive rule to Ri.\nFor simplification, it is sufficient to delete any temporal constraints that are true in sem(Ltemp  Ltimeless). If after simplification, other-antecedents \u03c3 is an empty conjunction (equivalent to true), then the simplified resolvent is deleted from Ri and added to Gi as a new top-level goal, starting a new goal tree (or thread).\nStep 2. Process goal clauses. If the number of steps that can be performed has reached Max, or if there are no new steps that can be performed in this iteration of the cycle, then this iteration of the cycle terminates.\nOtherwise, while the number of goal-reduction steps performed so far has not reached Max, and there are new steps that can be performed in this iteration of the cycle, choose any goal clause C in Gi and perform one of the steps 2.1, 2.2 or 2.3.\nStep 2.1. Reduce a composite event. Select a composite event atom in C, unify the composite event atom with the head of some clause in Levents and update Gi by adding the resolvent to Gi as a child of C. Note that there are no restrictions on the time parameters in this step. This allows the goal-reduction of composite events to look-ahead into the future, which is a kind of forward planning.\nStep 2.2. Reduce a conjunction of state conditions and simple events. Select a parsing of C of the form:\nearly-consequents  other-consequents\nwhere early-consequents is a conjunction of state conditions and simple events such that all the time parameters in early-consequents can be unified with the current time ti, without making any temporal constraints in other-consequents false, and without constraining any of the time parameters in state conditions or events in other-consequents to be equal to or earlier than ti.\nIf there is a ground instance early-consequents \u03c3 that is true in sem(Lint  Ltimeless  Si*  evi*), then choose one such instance, generate the \u201cresolvent\u201d other-consequents \u03c3, simplify the temporal constraints, and update Gi by adding the simplified resolvent to Gi as a child of C.\nIf after simplification, the resolvent is an empty conjunction (equivalent to true), then the entire goal tree containing the goal clause can be deleted, because the toplevel goal clause in the tree is then also true.\nStep 2.3. Choose a conjunction of simple actions for attempted execution. Select a parsing of C of the form:\nactions  other-consequents\nwhere actions is a conjunction of simple actions happens(a, T1, T2) such that all the time parameters T1, T2 can be unified with the times ti and ti+1 respectively, without making any temporal constraints in other-consequents false, and without constraining any of the time parameters in state conditions or events in otherconsequents to be equal to or earlier than ti.\nAdd all of the simple actions happens(a, T1, T2) in actions to candidate-actsi+1. Using the successful execution of these actions to resolve these and other action subgoals takes place in step 2.2 of the next iteration of the cycle.\nNotes:\n1. Steps 1 and 2 of the OS are the operational semantics of a single agent, possibly interacting with other agents, both by observing changes in the environment and by performing actions. In the multi-agent case, step 0 is global to all the agents, and as a simplifying assumption the different agent cycles are all synchronized, so that all of the agents try to perform their actions at the same time. Step 0 nondeterministically selects a single possible set of concurrent events and updates the current state for all the agents. In this way, the global state serves as a coordination medium, in the manner of the Linda programming paradigm [Carriero and Gelenter 1989] and the blackboard model [Hayes-Roth 1985].\nIn the special case of a single agent maintaining only an internal state without any interaction with the external environment, the internal state serves the same function as the global state. In such a case, the agent needs to take responsibility itself for ensuring that the collection of selected candidate actions candidate-actsi+1 = actsi+1 = evi+1 is possible as specified by Dpre.\n2. Step 2.3 allows the possibility that the selected actions may contain variables other than time variables. This could be useful in the case of external actions where the variables can give feedback about the result of the action. For example, the variable X in the action move-forward(X, T) might be instantiated by the environment indicating how far the action succeeded.\nAlternatively, and in the case of internal actions, we can insist that only ground simple actions are selected for attempted execution. In the case of external actions, feedback from the environment can be given instead by means of the change of state resulting from the selected actions and other external events.\n3. In steps 1, 2.2 and 2.3, different parsings amount to different ways of sequencing state conditions and simple events in the same conjunction. For example, the conjunction p(T1)  q(T2)  r(T3)  T1 \u2264 T3  T2 \u2264 T3 has the four correct parsings:\np(T1)  q(T2)  r(T3) at the same time p(T1)  q(T2) at the same time and before r(T3) p(T1) before q(T2)  r(T3) q(T2) before p(T1)  r(T3)\nThe three parsings in which r(T3) is selected before p(T1) or q(T2) are incorrect and not allowed. Moreover, they are useless, because selecting r(T3) before p(T1) or q(T2) makes it impossible to evaluate p(T1) or q(T2) in the future.\n4. If a goal clause becomes false, then there is no point in trying to solve other subgoals in the same goal clause. If an entire goal tree is reduced to false, then the top-level goal clause in the tree is false, the instance of the reactive rule that generated it is false, and the reactive rule itself is also false. In theory, the OS should terminate in failure. However, in practice, we may want to allow the OS to continue, trying to make all instances of the rules true in the future. Moreover, we\nalso have the option of providing a fail-safe, alternative way of solving any goal that is vulnerable to failure.\n5. In the various repetitions of step 2 within a given iteration of a cycle, the OS can select any goal clause C in Gi. It can jump from one goal tree to another, attempting to solve different top-level goal clauses concurrently. Or it can focus on one goal tree at a time. Within a given goal tree, it can jump from one branch to another, trying alternative ways of solving the same top-level goal clause concurrently. Or it could focus on one way of solving a top-level goal clause, extending one branch of the goal tree at a time.\n6. In different iterations of a cycle, in step 2, the OS can re-select the same goal clause C. In step 2.1, however, it may do so only to try to unify the selected composite event atom in C with the head of a clause in Levents not tried in previous iterations of the cycle. In step 2.2 it can re-try the same parsing early-consequents of conditions and simple event atoms, because the relevant part of the augmented current state Lint  Ltimeless  Si*  evi* may have changed. For similar reasons, in step 2.3 it can re-try the same conjunction of actions, because actions that were not possible before may become possible in the new current state."}, {"heading": "6. FOL-STRATIFICATION", "text": "The operational semantics appeals to the abstract semantics sem. In this section, we define FOL-stratification and instantiate sem to the FOL-perfect model semantics. FOL-stratification is a generalisation of local stratification in which the restriction on negative literals is generalised to non-atomic FOL formulas. The construction of FOL-perfect models similarly generalises the construction of perfect models.\nAs usual in logic programming, we treat a logic program P with variables as standing for the set ground(P) of all its ground instances over the Herbrand universe. By a ground instance of a clause head(X)  body(X, Y) we mean a clause of the form head(x)  body(x, y), where x and y are sets of ground terms substituted for the sets of variables X and Y respectively. The variables in X and Y do not include any variables bound by quantifiers in FOL conditions in body(X, Y).\nDefinition 6.1 (FOL-stratification). Let P be a ground logic program. Let\nH = 0\u2264i\u2264\u03b1 Hi, be a partitioning and ordering of the Herbrand base H of P. For A  H, let stratum(A) = i if and only if A  Hi. Then P is FOL-stratified with respect to Hi, 0\u2264i\u2264\u03b1, if and only if for every clause head  body in P and for every condition C in body:\nif C is an atomic condition, then stratum(C) \u2264 stratum(head) if C is a non-atomic FOL condition, then stratum(A) < stratum(head) for every atomic subformula A of C.\nThe definition of FOL-perfect model iteratively uses the perfect model of lower stratum predicates to evaluate FOL conditions in the bodies of clauses, reducing the clauses to Horn clauses, and generating the perfect model of the next higher stratum as the minimal model of the reduced clauses:\nDefinition 6.2 (FOL-perfect model). Let P be an FOL-stratified ground logic program with respect to Hi, 0\u2264i\u2264\u03b1. Let Pi be the set of all clauses head  body in P such that stratum(head) = i. Then P0 is a set of Horn clauses.\nThe FOL-perfect model of P is defined by:\n1. perfect(P0) = min(P0). 2. perfect(Pi+1) = min(Pi+1  perfect(Pi)).\n3. If \u03b2 is a limit ordinal, then perfect(P\u03b2) = 0\u2264 i<\u03b2 perfect(Pi). 4. perfect(P) = perfect(P\u03b1).\nCase 2 of the definition appeals to the notion of the minimal model of a program Pi+1 possibly containing FOL conditions defined by perfect(Pi). The definition of the minimal model of a set of Horn clauses generalises naturally to this case:\nDefinition 6.3 (Minimal model of program with FOL conditions). Let P = I  E be a ground logic program with Herbrand base H, where E is a set of ground atoms defining all the predicates in HE  H that occur in FOL conditions in the clauses I.\nThen the minimal model min(P) of P is the smallest set M  H such that, for every clause head  body in P, head  M if body is true in M, where an FOL condition all of whose predicates belong to HE is true in M if and only if the condition is true in E.\nNotice the definition exploits the dual interpretation of the Herbrand interpretation E both syntactically as a set of sentences in P = I  E, and semantically as determining the truth of FOL conditions whose predicates belong to HE.\nNotice also that the generation of min(P) can be regarded as a two-stage process: First the FOL conditions whose predicates all belong to HE are evaluated in E, resulting in a set of Horn clauses reduct(P, E), then min(P) is generated as the minimal model of reduct(P, E). The reduct reduct(P, E) generalises the treatment of negative literals in the Gelfond and Lifschitz [1988] reduct to FOL-conditions:\nDefinition 6.4 (Reduct). Let P = I  E be a ground logic program with Herbrand base H, where E is a set of ground atoms defining all the predicates in HE  H that occur in FOL conditions in the clauses in I.\nreduct(P, E) is the set of Horn clauses generated from P by deleting all FOL conditions in the bodies of clauses in I that are true in E and deleting all clauses in I that have an FOL condition that is false in E.\nNote that E is contained in reduct(P, E). Thus case 2 of the definition of FOL-perfect model could be rewritten alternatively as:\n2. perfect(Pi+1) = min(reduct(Pi+1, perfect(Pi))\nwhere min is the usual minimal model of a set of Horn clauses. We will see later that this alternative formulation of the definition has the advantage that it extends naturally to the case in which the program P is not statically FOL-stratified, but becomes FOL-stratified dynamically during the construction of the perfect model.\nThe definition of FOL-perfect model reduces to the definition of perfect model if all non-atomic FOL conditions are simply negative literals. As in the case of perfect\nmodels of locally stratified programs, FOL-perfect models of FOL-stratified programs do not depend upon the stratification, always exist and are unique.\nWith the definitions of FOL-stratification and FOL-perfect model now in place, we can instantiate the abstract specification of the computational task, given in definition 4.4, to the case in which all the different components of an LPS framework <R, L, D> are individually FOL-stratified.\nRecall that definition 4.4 requires a specification of the semantics of the following\ncombinations of the components of the framework:\nsem(L  S*  ev* ) and sem(Dpost  Lint  Ltimeless  Si-1*  evi*) , for all i > 0\nThus we need to show that each of the combined programs\nL  S*  ev* and Dpost  Lint  Ltimeless  Si-1*  evi*, for all i > 0,\nis also FOL-stratified.\nIn the case of the first program, it suffices to put the Herbrand base of S*  ev* in the lowest stratum followed by the stratifications of the head predicates of Ltimeless, Lint, Ltemp, and Levents, in that order.6\nSimilarly in the case of the programs Dpost  Lint  Ltimeless  Si-1*  evi*, it suffices to put the Herbrand base of Si-1*  evi* in the lowest stratum followed by the stratifications of the head predicates of Ltimeless, Lint and Dpost, in that order.\nWith these stratifications, the computational task is well-defined:\nDefinition 6.5 (Computational task for FOL-stratified programs). Given an LPS program <R, L, D>, in which L and Dpost are FOL-stratified, the computational task is as given in definition 4.4 with sem = perfect."}, {"heading": "7. SOUNDNESS AND COMPLETENESS", "text": "In this section we discuss the soundness and completeness of the operational semantics OS of LPS for the case sem = perfect.\nTHEOREM 7.1 (SOUNDNESS) Given an LPS program < R, L, D>, an initial state S0, and initial goal state G0, suppose for every set exti of external events, where i  1, the OS generates a set actsi+1 of actions.\nLet S* and ev* be the resulting sequences of states and events. Then R  G0 is true in perfect(L  S*  ev*), if for every top-level goal clause C added in a goal state Gi, i \u2265 0, there exists a goal state Gj such that i \u2264 j and C is reduced to true in Gj.\nNote that, in the special case where the sequence ev* is finite, the theorem states that if the goal state eventually becomes true, then R  G0 is true. Note also that the theorem refers to R  G0, rather than to R  G0  Dpre, because the requirement that Dpre be true in perfect(L  S*  ev*) is covered by step 0 of the OS.\n6 Note that other stratifications produce the same result: for example, the order Ltimeless, Ltemp, Lint, and Levents.\nSKETCH OF PROOF. The statement of the theorem mimics the definition of truth for reactive rules and goal clauses. In particular, a sentence in the form of a reactive rule X [antecedent  Y consequent] is true in a model, if whenever an instance of the antecedent becomes true the corresponding instance of the consequent becomes true.\nBut whenever an instance of the antecedent becomes true, the corresponding instance of the consequent is added as a top-level goal clause C to the current goal state Gi. The fact that the corresponding instance of the consequent becomes true is equivalent to there existing a goal state Gj where i \u2264 j and C is reduced to true in Gj.\nThe only-if half of the theorem also holds under certain conditions on the nondeterministic choices made in step 2 of the OS. In particular, the OS should perform every goal-reduction that is possible in step 2.2, to ensure that any sub-goals that are true in the model generated so far are recognized as being true by reducing them to true. Similarly, the bound MAX on the amount of time available for reducing composite events in step 2.1 should be large enough, to ensure that any subgoals that are true in the model generated so far are recognized as true.\nAs pointed out in [Kowalski and Sadri 2012b], the operational semantics is incomplete. In particular, it cannot (1) preventively make a reactive rule true by making its antecedent false, or (2) proactively make a reactive rule true by making its consequent true before its antecedent becomes true.\nExamples of these two kinds of incompleteness include:\n1. attacks(X, you, T1)  \u00ac prepared-for-attack(you, T1)\n surrender(you, T2)  T1 < T2  T1 + \nThe OS cannot make the rule true by performing actions to make prepared-for-attack(you, T) true and so \u00ac prepared-for-attack(you, T) false.\n2. enter-bus(T1)  have-ticket(T2)  T1 < T2  T1 + \nThe OS cannot make the rule true by performing actions to make have-ticket(T2) true before enter-bus(T1).\nWe have investigated the completeness of LPS with respect to the generation of more restricted supported models. Informally speaking and ignoring composite events, a Herbrand model M = perfect(L  S*  ev* ) of a set of reactive rules R is supported if for every action in every acti in M there is an instance of a reactive rule in R of the form:\nantecedent  early-consequents  action  other-consequents\nsuch that antecedent  early-consequents is true in M. It is possible to show that, under certain conditions, the OS can generate all such supported models. However, we do not discuss this issue further in this paper."}, {"heading": "8. SOLVING THE COMPUTATIONAL ASPECT OF THE", "text": "FRAME PROBLEM\nIn this section, we show that the models obtained by destructive updates in LPS are identical to the models obtained by using the event theory ET:\nholds(P, T2)  initiated(P, T1, T2) holds(P, T2)  holds(P, T1)  succ(T1, T2)  \u00ac terminated(P, T1, T2)\nWe also define a generalization of FOL-stratification, which is needed to define the natural, intended model of Q = ET  Dpost  L  S0*  ev*. We will then show that the intended model of Q is identical to the FOL-perfect model of L  S*  ev*."}, {"heading": "8.1 Weak stratification and weakly perfect models", "text": "The intended model of Q is constructed by partitioning the Herbrand base H of Q into strata associated with the succession of time points t0,..., ti, ti+1,... determined by succ(ti, ti+1)  perfect(Ltemp  Ltimeless):\nH0 = {holds(p, t0) | p is an extensional fluent} \n{a | a is an atom with a time-independent predicate}  {a | a is an atom with a temporal predicate, including succ}  {happens(e, t, u) | e is a simple event, and t and u are time points}\nFor i  0, H3i+1 = {holds(p, ti) | p is an intensional fluent} H3i+2 = {initiated(p, t, ti+1) | p is an extensional fluent, and t is a time point} \n{terminated(p, t, ti+1) | p is an extensional fluent, and t is a time point}\nH3i+3 = {holds(p, ti+1) | p is an extensional fluent} H+1 = {happens(e, t, u) | e is a composite event, and t and u are time points}\nThe sets H0 and H3i+1 are themselves stratified: H0 is partitioned into strata corresponding to the stratification of Ltimeless  Ltemp, and H3i+1 is partitioned into strata corresponding to the stratification of Lint.\nApplied to the predicates in the heads of clauses in Q, this stratification of H\ndetermines an associated stratification of ground(Q):\nQ0 = S0*  ground(Ltimeless)  ground(Ltemp)  ev* For i  0, Q 3i+1 = {holds(p, ti)  body  ground(Lint)} Q3i+2 = {initiated(p, t, ti+1) \u2190 body  ground(Dpost)} \n{terminated(p, t, ti+1) \u2190 body  ground(Dpost)}\nQ3i+3 = {holds(p, ti+1)  body  ground(ET)} Q+1 = ground(Levents)\nUnfortunately, Q is not FOL-stratified, because Q3i+3 contains unstratified instances of the frame axiom:\nholds(p, ti+1)  holds(p, tj)  succ(tj, ti+1)   terminated(p, tj, ti+1)\nwhere j > i+1 and holds(p, tj) is at a higher stratum than holds(p, ti+1). The problem and its solution are similar to those for the program [Apt and Bol 1994]:\nSucc: successor(X, s(X)) Even: even(0)\neven(Y)  successor(X, Y)   even(X)\nThe program has a natural stratification with all ground instances of Succ in the lowest stratum, and with even(s(n)) in the stratum one higher than the stratum of even(n). However, the program is not locally stratified, because there are ground instances of the second clause in Even, for example even(0)  successor(s(0), 0)   even(s(0)), where the negative condition is at a higher stratum that the head.\nThe problem is that the definition of local-stratification is too static, and does not take into account the dynamic stratification obtained by the use of the reduct in the construction of the perfect model. If we ignore the fact that the original program is not locally stratified, and attempt to generate its perfect model, we see that the second clause in Even is replaced in effect by the locally stratified clauses:\neven(s(t))   even(t) for all t such that successor(t, s(t))  min(Succ).\nThis dynamic variant of local stratification is called weak stratification, and it can also be applied more generally to programs with FOL conditions. The definition is virtually identical to the definition of perfect model, with perfect replaced by weaklyperfect, and without requiring the program to be statically stratified in advance:\nDefinition 8.1 (Weak FOL-stratification and weakly FOL-perfect model). Let P be a ground logic program. Let H = 0\u2264i\u2264\u03b1 Hi, be a partitioning and ordering of the Herbrand base H of P. Let Pi be the set of all clauses head  body in P such that stratum(head) = i.\n1. If P0 is a set of Horn clauses all of whose conditions are in H0, then:\nweakly-perfect(P0) = min(P0).\n2. If Pi is weakly FOL-stratified, with intended model weakly-perfect(Pi), and if reduct(Pi+1, weakly-perfect(Pi)) is a set of Horn clauses all of whose conditions are in Hi+1, then Pi+1 is weakly FOL stratified and:\nweakly-perfect(Pi+1) = min(reduct(Pi+1, weakly-perfect(Pi))).\n3. If \u03b2 is a limit ordinal, and for all 0\u2264 i< \u03b2, Pi is weakly FOL-stratified with intended model weakly-perfect(Pi), then P\u03b2 is weakly FOL-stratified and:\nweakly-perfect(P\u03b2) = 0\u2264 i<\u03b2 weakly-perfect(Pi).\n4. weakly-perfect(P) = weakly-perfect(P\u03b1)\nIt is possible to show that if a program is weakly FOL-stratified with respect to one stratification, then it is weakly FOL-stratified with respect to every other stratification, and consequently the weakly FOL-perfect model is unique.\nIn the case of the program Q, the use of the reduct in the construction of the weakly-perfect model eliminates the unstratified instances of Q3i+3 and replaces them by the stratified instances:\nholds(P, ti+1)  holds(P, ti)   terminated(P, ti, ti+1) for all ti, ti+1 such that succ(ti, ti+1)  perfect(Ltemp  Ltimeless)."}, {"heading": "8.2 The Frame Theorem", "text": "The following theorem links the two characterizations of the semantics of LPS.\nTHEOREM 8.2 (FRAME THEOREM).\nperfect(L  S*  ev*) = weakly-perfect(ET  Dpost  L  S0*  ev*)\n\u2013 {head | head  body  ground(Dpost)}.\nEquivalently, perfect(Dpost  L  S*  ev*)\n= weakly-perfect(ET  Dpost  L  S0*  ev*\nSKETCH OF PROOF. It suffices to show that\nperfect(Dpost  Lint  Ltimeless  Ltemp  S*  ev*)\n= weakly-perfect(ET  Dpost  Lint  Ltimeless  Ltemp  S0*  ev*).\nThis is because, in both models, Levents is used only in the last strata to superimpose composite events on the underlying sequence of states and simple events.\nNote that ground(ET) = Q3  Q6 \u2026 Q3i+3 ..., where\nQ3i+3 = {holds(p, ti+1)  body  ground(ET)}\nIt suffices to show that for all i > 0,\nperfect(Dpost  Lint  Ltimeless  Ltemp  S0*  S1* ...  Si+1*  ev*)\n= weakly-perfect(Dpost  Lint  Ltimeless  Ltemp  S0*  Q3 \u2026 Q3i+3  ev*).\nThis can be proved by induction on i."}, {"heading": "9. COMPARISON WITH OTHER WORK", "text": "LPS evolved from our attempts to reconcile and combine conflicting approaches to computing in such different areas as logic programming, production systems, active and deductive databases, agent programming languages, and the representation of causal theories in AI."}, {"heading": "9.1 Deductive databases", "text": "Our attention was first drawn to the distinction between reactive rules and logic programs by the distinction made by [Nicolas and Gallaire 1978] between deduction rules and integrity constraints in deductive databases, both of which have a logical semantics. However, the exact nature of the relationship between their semantics was the subject of considerable debate in the early 1980s.\nThe two main views, to begin with, were the consistency view and the theoremhood view, both of which were defined relative to the completion of the database [Clark 1978]. In the consistency view, an integrity constraint is satisfied if it is\nconsistent with the completion of the database. In the theorem-hood view, it is satisfied if it is a theorem, logically entailed by the completion.\n[Reiter 1988] also proposed an epistemic view, according to which integrity constraints are statements about what the database knows. However, [Reiter 1988] also showed that in many cases all three views are equivalent. For relational databases, in particular, the three views are also equivalent to the standard view that a database satisfies an integrity constraint if it is true in the database regarded as a Herband model. The semantics of LPS is an extension of this idea in two ways: First, it extends the idea of a database defined by a set of ground atomic sentences to the idea of the database defined by an FOL-stratified logic program. Second, it extends the notion that an integrity constraint is true in a model representing a database state to the idea that the integrity constraint is true in a model representing the entire collection of states and events.\nThe use of logic programs in LPS with FOL conditions was largely inspired by transaction logic [Bonner and Kifer 1993], which uses such programs to define database transactions. Although transaction logic focuses primarily on performing composite actions, reactive rules can also be programmed using transactions. Like LPS, transaction logic also employs destructive updates. But it employs a possible world semantics, in which the semantics of transactions is defined in terms of paths between possible worlds."}, {"heading": "9.2 Abductive logic programming", "text": "The distinction between logic programs and integrity constraints also underpins abductive logic programming (ALP) [Kakas et al. 1998; Denecker and Kakas 2002]. In ALP, a program consists of a triple <L, IC, A>, where L is a logic program, IC is a set of integrity constraints, and A is a set of \u201cabducible\u201d predicates, not defined by L. A goal G is an observation to explain or a state to achieve. The goal is solved by generating a set  of ground atoms in the vocabulary of the abducible predicates such that L   entails G, and L   satisfies the integrity constraints IC. Similarly to the case of deductive databases, different notions of entailment and integrity constraint satisfaction have been proposed.\nLPS is a variant of ALP, in which the abducible predicates are restricted to simple actions, and observations are events and fluents that can be queried in the global state and do not require explanation. Moreover, the semantics is simplified so that entailment and integrity satisfaction are understood in the same way, as meaning that G  IC is true in the FOL-perfect model of L  . The operational semantics of LPS is a variant of the IFF proof procedure [Fung and Kowalski 1997], originally developed for Kunen\u2019s three valued completion semantics [Kunen 1987]."}, {"heading": "9.3 Logic programming semantics", "text": "The inclusion of FOL conditions in LPS is an important feature, motivated by their use in transaction logic to query databases states during the course of performing database updates. FOL-stratification and weak-FOL stratification with their associated models provide a natural setting for evaluating such FOL conditions. Moreover, weak FOL-stratification also provides a natural semantics for event theories such as ET. But stratification goes against current trends in logic programming, where the dominant approaches are the well-founded semantics [Van Gelder et al. 1991] and stable model semantics [Gelfond and Lifschitz 1988].\nIt may, of course, be possible to redo the semantics of FOL conditions in other approaches. In particular, there may be a natural way to represent alternative sets of possible concurrent events and the resulting states as alternative stable models. It may also be possible to modify the evaluation of FOL conditions to use a threevalued semantics.\nOn the other hand, the extension of stratification and perfect models to the case of FOL conditions may have other uses. For example, the application of Datalog to declarative networking [Loo et al 2009; Hellerstein 2010; Loo et al 2012] makes heavy use of stratification, and the extensions of stratification in this paper might also be useful in that domain."}, {"heading": "9.3 Agent systems", "text": "LPS is a direct descendant of our work on ALP agents [Kowalski and Sadri 1999, Kowalski 2011], which embed ALP in the thinking component of a BDI-like agent [Rao and Georgeff 1995] cycle. In ALP agents, the logic program L represents the agent\u2019s beliefs, and the goals and integrity constraints G  IC represents the agent\u2019s desires. The logic program L includes a deductive database that represents the agent\u2019s view of its environment. The database is updated by means of an event theory, which uses frame axioms. The ALP agent approach was developed further in the KGP agent model [Kakas et al. 2004; Mancarella et al. 2009]. In contrast, LPS and most practical agent systems employ a destructively updated database that represents the current state.\nA number of other authors have also developed agent languages and systems within a logic programming context. For example in both DALI [Costantini and Tocchino 2004; Costantini and Tocchino 2006] and EVOLP [Brogi et al. 2002], events transform an initial agent logic program into a sequence of logic programs. The semantics of this evolutionary sequence is given by the associated sequence of models of the sequence of programs. In LPS, this sequence is represented by a single model by using time stamps.\nIn EVOLP, the sequence of logic programs is non-deterministic and allows for a directed graph of possible state evolutions, because stratification is not imposed. In LPS, non-determinism arises from the possibility of choosing different actions to generate state transitions, while still imposing stratification. Moreover, EVOLP allows rules to be updated, and not only fluents as in LPS.\nFLUX [Thielscher 2005] is an agent language with several features similar to LPS, including the use of destructive assignment to update states. In FLUX, these states are not represented by atomic sentences as in LPS, but are reified as terms in a list-like structure.\n[Thielscher 2010] provides a declarative semantics for AgentSpeak by defining its cycle and procedures by means of a meta-interpreter represented as a logic program. Like LPS, the resulting agent language incorporates a formal transition theory. However, unlike LPS, the language does not distinguish between different kinds of AgentSpeak procedures, according to their different functionalities. LPS, in contrast, distinguishes between reactive rules, and logic programs, representing different kinds of procedures in different ways. Somewhat closer to LPS is the agent architecture of [Hayashi et al. 2005; Hayashi et al 2009], which separates the representation of reactive rules and planning clauses. Planning is done by means of Hierarchical Task Networks, which are like logic programs that reduce composite events to simpler events in LPS.\n[Eiter et al. 1999]] define an extension of logic programming in which the clauses represent the conditions under which actions are permitted, forbidden, obliged or waived. All reasoning takes place and is completed within a single iteration of the agent cycle. In the LPS cycle, reasoning can be interrupted both to assimilate events and to generate actions.\nIn contrast with approaches that map agent programs into logic programs, MetaTEM [Fischer 1994] maps agent programs into temporal modal logic sentences of the form \u201cpast or present conditions imply present or future conclusions\u201d. As in LPS, computation attempts to generate a model in which such agent programs are true. In contrast with MetaTEM, which employs a possible world semantics and frame axioms for updating states, LPS uses a language with an explicit representation of time, an extension of the perfect model semantics, and an operational semantics with destructive updates."}, {"heading": "9.4 Active databases", "text": "As pointed out by [Bailey et al. 1995], although they differ in their intended applications and research communities, agent systems and active databases employ similar approaches to programming reactive systems. For example, AgentSpeak [Rao 1996] employs agent programs that are plans consisting of a triggering event, a context, which specifies the conditions that should hold when the plan is triggered, and a body, which specifies the goals the agent should achieve or test, and the actions the agent should execute. Active databases employ similar eventcondition-action (ECA) rules to react to events, test conditions and perform actions. Both agent system plans and ECA rules maintain a destructively updated database state, but lack a declarative semantics.\nA number of researchers, working mainly in the deductive database area, have addressed the problem of developing a declarative, logic-based semantics for active databases. In the majority of these approaches ECA rules are mapped into logic programs to provide them with a logic programming semantics.\n[Zaniolo 1993], for example, uses a situation calculus-like representation with frame axioms, and reduces ECA rules to logic programs. Statelog [Lausen et al. 1998] also uses a situation-calculus-like representation for the succession of database states. Like Zaniolo, Statelog represents ECA rules as logic programs, and gives them a semantics based on logic programming.\n[Fernandes 1997] also views ECA rules in terms of change of state, but use the event calculus as the basis for an ECA language coupled with a deductive database. The event calculus is used to evaluate the condition part of the ECA rules and to provide a specification for the effects of executing the action part. The ECA language also allows the recognition of complex events from an event history.\nERA (Evolving Reactive Algebraic Programs) [Alferes et al. 2006] extends the dynamic logic programming system EVOLP [Brogi et al. 2002] by adding complex events and actions as well as external actions. ERA combines ECA and logic programming rules, and the firing of the ECA rules can generate actions that add or delete ECA or logic programming rules, as well as external actions. In the operational semantics the ECA and logic programming rules maintain their distinct characteristics, but in the declarative semantics the ECA rules are translated into logic programs. The declarative semantics is based on a variant of stable models developed for EVOLP.\n[Caroprese et al.2006] also transform active integrity constraints into logic programs. They characterise the set of \u201cfounded\u201d repairs for the database as the\nstable model of the database augmented by the logic programming representation of the active integrity constraints. [Fraternali and Tanca 1995] also consider active databases but provide a logic-based core syntax for representing low-level, procedural features of active database rules. They provide procedural semantics for core rules and show how this can capture the procedural semantics of known active database systems."}, {"heading": "9.5 Production systems", "text": "Arguably, production systems [Newell 1973], in which programs are expressed as condition-action rules, are the simplest example of a reactive system, and the earliest ancestor both of agent systems and active databases. It was the attempt to understand the difference and relationship between production rules and logic programming rules that eventually led to our development of LPS. Several other authors have made related attempts, with the aim of providing production rules with a declarative semantics. In the majority of these approaches production rules are mapped into logic programs.\n[Raschid 1994] focuses on the use of production rules as reactive rules and as forward-reasoning logic rules. She first maps rules that add facts into logic programs, and rules that delete facts into integrity constraints. She then transforms the resulting combination of logic programs and integrity constraints into normal logic programs, and uses the fixed point semantics of logic programming to chain forward and simulate the production system cycle. [Baral and Lobo 1995] translate production rules into the situation calculus represented as a logic program with the stable model semantics. Their use of the situation calculus is similar to our characterization of the computational task using the event theory ET, and thus uses a frame axiom. [Dung and Mancarella 2002], on the other hand, use an argumentation theoretic framework to provide semantics for production rules extended with negation as failure.\nRecently, there has been a revival of work on implementing production systems in logic programming terms. For example, [Damasio et al. 2010] use incremental Answer Set Programming (ASP) to realize different conflict resolution strategies for the RIF-PRD production system dialect. [Eiter et al 2012] simulate production systems in ACTHEX, an ASP framework with an interface to an external environment. The simulation does not use an explicit representation of state, but achieves state changes by updating and accessing the environment via action atoms and external atoms. [Rezk and Kifer 2012] combine production rules and ontologies, using transaction logic.\nIn comparison with other approaches that map reactive rules into logic programs, our approach has been to develop a semantics that respects the distinct natures of logic programs and reactive rules. In LPS, reactive rules and logic programs are both expressed in logical form, but logic programs represent beliefs that determine model theoretic structures, and reactive rules represent goals that are meant to be true in those models."}, {"heading": "9.6 Causal theories in AI", "text": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al. 2004] employ the event calculus to represent and reason about the relationship between fluents, actions and other events. Unlike the situation calculus, which reifies global states or situations, the event calculus reifies time\npoints and events. However, in both the situation calculus and event calculus, axioms are used to derive atomic sentences representing states of the world. Destructive updates are not possible, because it is not possible to change the axioms in the middle of a proof.\nHowever, because ALP agents are embedded in an agent cycle, they can also directly observe the current state of the world, and thereby avoid the need to reason about it. In other words, the world can serve as its own representation, as advocated by [Brooks 1991]. This ability of an agent to observe the world instead of reasoning about its representation highlights the fact that the world is a semantic structure that gives meaning to an agent\u2019s thoughts. Because the world is a semantic structure, it is not constrained by the restrictions of axioms that are not allowed to change during the course of a proof.\nAdopting this view of the world as a semantic structure is compatible with a model-theoretic semantics of ALP, in which the logic program L and set of assumptions  determines a model of L   that makes the goal and integrity constraints G  IC all true. Moreover, it justifies the destructive updates and modeltheoretic semantics of LPS. To the best of our knowledge, LPS is the only framework employing a causal theory that combines destructive updates with a logic-based semantics.\nWe do not claim that the use of destructive updates eliminates all need to reason with frame axioms. On the contrary, frame axioms are needed to prove certain properties of LPS programs. This is an area of work that we are currently investigating."}, {"heading": "9.7 Parallelism and concurrency", "text": "LPS combines an AI approach to the representation of concurrent actions with a Linda-like use of a shared state as a coordination medium. The AI component comes from the use of the domain theory D, to reason about the combined effects of concurrent actions, in the spirit of [Reiter 1996]\u2019s treatment of concurrent actions in the situation calculus and [Miller and Shanahan 2002]\u2019s treatment in the event calculus.\nRecently, [Khandelwal and Fox 2012] have extended Miller and Shanahan\u2019s approach, to define the effects of multiple actions by using aggregate formulas in first-order logic. Our approach can be regarded as an approximation to theirs, and would benefit from a similar extension using aggregate formulas.\nUnlike some other approaches that use message passing to handle concurrency, LPS uses a Linda-like shared state, which is similar also to the blackboard architecture used in AI. Our assumption that the environment non-deterministically decides which sets of possible concurrent events actually occur is similar to the use of a \u201csupervisor\u201d in [Dovier et al. 2012], to arbitrate between the conflicting actions of different agents in the pursuit of different goals. In addition, [Dovier et al. 2012] also provides communication primitives, to allow agents to resolve conflicts through negotiation. The semantics is defined in terms of state transitions, but does not provide an explicit treatment of reactivity.\nAlthough the approach to concurrency behaves naturally with such challenging problems in concurrent programming as the dining philosophers\u2019 problem, we need to investigate more deeply the relationship with the treatment of parallelism and concurrency in databases management systems and conventional programming languages more generally. In this respect, it is encouraging to note the recent developments [Hellerstein 2010] in the use of Datalog and the explicit\nrepresentation of time for programming distributed and parallel systems. Although frame axioms are represented explicitly in [Hellerstein 2010], they are not used in the implementation, using instead \u201ctraditional storage technology rather than rederiving tuples each timestep\u201d. Our frame theorem can be regarded as a justification for the use of such technology."}, {"heading": "9.8 Reactive systems", "text": "An LPS framework <R, L, D> is essentially a reactive system in which logic programs L and causal theories D play a supporting role to reactive rules R. [Harel 1986] contrasts reactive systems with \u201ctransformational systems\u201d, which transform inputs into outputs in a mathematically well-behaved manner. In contrast with transformational systems, reactive systems are \u201cevent-driven, continuously having to react to external and internal stimuli\u201d. He further characterises them as being an extension of state transition systems, having the general form \u201cwhen event  occurs in state A, if condition C is true at the time, the system transfers to state B\u201d. [Harel 2009] notes that StateCharts, a graphical language for reactive systems, is \u201cthe heart of the UML - what many people refer to as its driving behavioral kernel\u201d.\nAs [Reisig 2012] puts it, an initialized, deterministic transition system is \u201ca triple C = (Q, I, F) where Q is a set (its elements are denoted as states), I \u2286 Q (the initial states), and F : Q \u2192 Q (the next-state function)\u201d. Transition systems can be extended to reactive systems in which the transition from one state to the next is \u201cnot conducted by the program, but by the outside world\u201d.\nBut even in their simpler \u201cinitialized, deterministic\u201d form, transition systems have been proposed as a general model of Computing. Reisig points out that in [Knuth 1973], the first volume of The Art of Computer Programming, Donald Knuth suggests their use as a general semantics for algorithms.\nLPS can be viewed as an attempt to reconcile Harel\u2019s two kinds of computational formalism, with reactive rules providing the main reactive component of the system, and logic programs providing structure for the \u201ctransformational part\u201d. In addition, LPS also attempts to incorporate deductive database functionality and features of causal theories in AI."}, {"heading": "10 Future work", "text": "LPS has its origins in AI knowledge representation and reasoning languages, but for the sake of efficiency and to focus on the features required for database and programming applications, the AI features have been deliberately restricted and simplified. For example, the abductive explanation of observations, which was one of the main motivations of ALP, has been deliberately left out. Similarly, the ability to perform preventative maintenance, which is a feature of the IFF proof procedure for ALP, has also been left out.\nThere are two complementary, directions for future work. One direction is to reintroduce into LPS some of the more powerful, but also more expensive features of ALP agents \u2013 for example the planning clauses in some of the earlier versions of LPS. Such features might also include more expressive integrity constraints, bearing in mind that reactive rules are just a species of integrity constraint in ALP.\nThe other direction is to further restrict the framework to make it more efficient or to specialize it for particular application domains \u2013 for example, by restricting the use of function symbols, as in Datalog. This direction also includes further\ndevelopment of the operational semantics \u2013 for example to specify efficient strategies for executing composite events in the antecedents and consequents of rules.\nThere is also a third direction, which combines the other two, by adding more powerful features for particular classes of applications. This includes extending the syntax of FOL conditions to include the use of aggregation operators and more complex kinds of composite events.\nThe extension to include aggregation operators should not be too difficult, because it requires only extending the definition of the truth of a sentence in a Herbrand interpretation. Moreover, it can be implemented in a similar manner to the implementation of aggregate operators in relational database systems, Prolog and ASP.\nThe extension to include more complex composite events does not require any extension of the semantics, but requires only extending the current state to include a window of previous events. This window can then be queried along with other facts in the current state using arbitrary FOL conditions, augmented perhaps with aggregation operators.\nWe have implemented a prototype of LPS in LPA Prolog, which includes some of the details necessary for a more complete language. For example, the implementation uses a Prolog-like depth-first search to choose goal clauses for goal reduction. Some obvious additional improvements include the use of a constraint solver for handling temporal constraints and the use of a UML-like graphical external syntax."}, {"heading": "ACKNOWLEDGEMENTS", "text": "We are grateful to Imperial College for EPSRC Pathways to Impact funding, which has supported the implementation of LPS. Many thanks also to David Kinny and Ken Satoh for helpful discussions, and to Ken Satoh and Luis Pereira for their comments on an earlier draft of this paper."}], "references": [{"title": "An Event-Condition-Action Logic Programming Language", "author": ["J.J. Alferes", "F. Banti", "Brogi A."], "venue": "In: 10th European Conference on Logics in Artificial Intelligence, M. Fisher, W. van der Hoek, B. Konev and A. Lisitsa (eds.), JELIA06: Lecture Notes in Artificial Intelligence 4160, Springer-Verlag. 29- 42.", "citeRegEx": "Alferes et al\\.,? 2006", "shortCiteRegEx": "Alferes et al\\.", "year": 2006}, {"title": "Logic programming and negation: A survey", "author": ["K.R. Apt", "R.N. Bol"], "venue": "The Journal of Logic Programming,", "citeRegEx": "Apt and Bol,? \\Q1994\\E", "shortCiteRegEx": "Apt and Bol", "year": 1994}, {"title": "Active databases and agent systems\u2014A comparison", "author": ["J. Bailey", "M. Georgeff", "D. Kemp", "D. Kinny", "K. Ramamohanarao"], "venue": "Rules in Database Systems,", "citeRegEx": "Bailey et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Bailey et al\\.", "year": 1995}, {"title": "Characterizing production systems using logic programming and situation calculus http://www.cs.utep.edu/baral/papers/char-prod-systems.ps", "author": ["C. Baral", "J. Lobo"], "venue": null, "citeRegEx": "Baral and Lobo,? \\Q1995\\E", "shortCiteRegEx": "Baral and Lobo", "year": 1995}, {"title": "Transaction logic programming", "author": ["A. Bonner", "M. Kifer"], "venue": "Warren D. S., (ed.), Logic Programming: Proc. of the 10th International Conf., 257-279.", "citeRegEx": "Bonner and Kifer,? 1993", "shortCiteRegEx": "Bonner and Kifer", "year": 1993}, {"title": "Evolving Logic Programs", "author": ["A. Brogi", "J.A. Leite", "L.M. Pereira"], "venue": "In: 8th European Conference on Logics in Artificial Intelligence (JELIA'02), S. Flesca, S. Greco, N. Leone, G. Ianni (eds.), Spriger-Verlag, LNCS 2424, Springer-Verlag, 50-61.", "citeRegEx": "Brogi et al\\.,? 2002", "shortCiteRegEx": "Brogi et al\\.", "year": 2002}, {"title": "Intelligence Without Representation", "author": ["R.A. Brooks"], "venue": "Artificial Intelligence", "citeRegEx": "Brooks,? \\Q1991\\E", "shortCiteRegEx": "Brooks", "year": 1991}, {"title": "Declarative Semantics of Production Rules for Integrity Maintenance", "author": ["Caroprese", "S.L. Greco", "C. Sirangelo", "E. Zumpano"], "venue": "In: 22nd International Conference on Logic Programming, Etalle, S., Truszczynski, M. (eds.), LNCS 4079, 26\u201440.", "citeRegEx": "Caroprese et al\\.,? 2006", "shortCiteRegEx": "Caroprese et al\\.", "year": 2006}, {"title": "Linda in Context", "author": ["N. Carriero", "D. Gelernter"], "venue": "Communications of the ACM. Volume 32 Issue 4.", "citeRegEx": "Carriero and Gelernter,? 1989", "shortCiteRegEx": "Carriero and Gelernter", "year": 1989}, {"title": "Negation as Failure", "author": ["K. Clark"], "venue": "In: Readings in Nonmonotonic Reasoning, Morgan Kaufmann, 311\u2014325.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "The DALI Logic Programming Agent-Oriented Language", "author": ["S. Costantini", "A. Tocchio"], "venue": "In: Alferes, J.J., Leite, J. (eds.) JELIA 2004. LNCS (LNAI), vol. 3229, Springer, Heidelberg. 685\u2013688.", "citeRegEx": "Costantini and Tocchio,? 2004", "shortCiteRegEx": "Costantini and Tocchio", "year": 2004}, {"title": "About Declarative Semantics of Logic-Based Agent Languages, Dalt 2005, LNAI 3904, Baldoni, M", "author": ["S. Costantini", "A. Tocchio"], "venue": "et al (eds.), 106-123.", "citeRegEx": "Costantini and Tocchio,? 2006", "shortCiteRegEx": "Costantini and Tocchio", "year": 2006}, {"title": "Declarative semantics for the rule interchange format production rule dialect", "author": ["C. Dam\u00e1sio", "J. Alferes", "J. Leite"], "venue": "The Semantic Web\u2013ISWC", "citeRegEx": "Dam\u00e1sio et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Dam\u00e1sio et al\\.", "year": 2010}, {"title": "Abduction in logic programming", "author": ["M. Denecker", "A.C. Kakas"], "venue": "Computational Logic: Logic Programming and Beyond. Springer-Verlag, London, UK, 402\u2013436.", "citeRegEx": "Denecker and Kakas,? 2002", "shortCiteRegEx": "Denecker and Kakas", "year": 2002}, {"title": "Autonomous agents coordination: Action languages meet CLP() and Linda, Theory and Practice of Logic Programming", "author": ["A. Dovier", "A. Formisano", "E. Pontelli"], "venue": null, "citeRegEx": "Dovier et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dovier et al\\.", "year": 2012}, {"title": "Production Systems with Negation as Failure", "author": ["P.M. Dung", "P. Mancarella"], "venue": "IEEE Transactions on Knowledge and Data Engineering, Volume 14 , Issue 2, 336\u2014352.", "citeRegEx": "Dung and Mancarella,? 2002", "shortCiteRegEx": "Dung and Mancarella", "year": 2002}, {"title": "Heterogeneous active agents, I", "author": ["T. Eiter", "V.S. Subrahmanian", "G. G Pick"], "venue": "AI Journal, vol. 108, no. 1-2, 179-255.", "citeRegEx": "Eiter et al\\.,? 1999", "shortCiteRegEx": "Eiter et al\\.", "year": 1999}, {"title": "Simulating production rules using ACTHEX", "author": ["T. Eiter", "C. Feier", "M. Fink"], "venue": "Correct Reasoning,", "citeRegEx": "Eiter et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2012}, {"title": "The Semantics of Predicate Logic as a Programming", "author": ["M. van Emden", "R. Kowalski"], "venue": "Language, in JACM,", "citeRegEx": "Emden and Kowalski,? \\Q1976\\E", "shortCiteRegEx": "Emden and Kowalski", "year": 1976}, {"title": "A Logic-Based Integration of Active and Deductive Databases", "author": ["A.A.A. Fernandes", "M.H. Williams", "N. Paton"], "venue": "New Generation Computing, Volume 15, Number 2, 205\u2014244.", "citeRegEx": "Fernandes et al\\.,? 1997", "shortCiteRegEx": "Fernandes et al\\.", "year": 1997}, {"title": "A Survey of Concurrent METATEM - The Language and its Applications", "author": ["M. Fisher"], "venue": "Lecture notes in computer science, 827, Springer Verlag 480-505.", "citeRegEx": "Fisher,? 1994", "shortCiteRegEx": "Fisher", "year": 1994}, {"title": "A Structured Approach for the Definition of the Semantics of Active Databases", "author": ["P. Fraternali", "L. Tanca"], "venue": "ACM Transactions on Database Systems (TODS) Volume 20, Issue 4 (December 1995), 414\u2014471.", "citeRegEx": "Fraternali and Tanca,? 1995", "shortCiteRegEx": "Fraternali and Tanca", "year": 1995}, {"title": "The IFF Proof Procedure for Abductive Logic Programming", "author": ["T.H. Fung", "R. Kowalski"], "venue": "J. of Logic Programming.", "citeRegEx": "Fung and Kowalski,? 1997", "shortCiteRegEx": "Fung and Kowalski", "year": 1997}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "Lifschitz", "August"], "venue": "In Proceedings of the 5th International Conference on Logic programming (Vol", "citeRegEx": "Gelfond et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1988}, {"title": "Statecharts: A Visual Formalism for Complex Systems, Sci", "author": ["D. Harel"], "venue": "Comput. Programming 8 231-274.", "citeRegEx": "Harel,? 1987", "shortCiteRegEx": "Harel", "year": 1987}, {"title": "Statecharts in the making: a personal account", "author": ["D. Harel"], "venue": "Communications of the ACM,", "citeRegEx": "Harel,? \\Q2009\\E", "shortCiteRegEx": "Harel", "year": 2009}, {"title": "A new HTN planning framework for agents in dynamic environments", "author": ["H. Hayashi", "K. Cho", "A. Ohsuga"], "venue": "Computational Logic in Multi-Agent Systems,", "citeRegEx": "Hayashi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hayashi et al\\.", "year": 2005}, {"title": "Background Sensing Control for Planning Agents Working in the Real World", "author": ["H. Hayashi", "S. Tokura", "F. Ozaki", "Doi. M."], "venue": "International Journal of Intelligent Information and Database Systems, Inderscience Publishers, 3(4): 483-501.", "citeRegEx": "Hayashi et al\\.,? 2009", "shortCiteRegEx": "Hayashi et al\\.", "year": 2009}, {"title": "Complex Actions for Event Processing, Research Report, Institute for Informatics, University of Munich", "author": ["S. Hausmann", "M. Scherr", "F. Bry"], "venue": null, "citeRegEx": "Hausmann et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hausmann et al\\.", "year": 2012}, {"title": "A blackboard architecture for control, Artificial Intelligence, Volume 26, Issue", "author": ["B. Hayes-Roth"], "venue": null, "citeRegEx": "Hayes.Roth,? \\Q1985\\E", "shortCiteRegEx": "Hayes.Roth", "year": 1985}, {"title": "The Declarative Imperative: Experiences and Conjectures in Distributed Logic, SIGMOD Record 39(1)", "author": ["J.M. Hellerstein"], "venue": null, "citeRegEx": "Hellerstein,? \\Q2010\\E", "shortCiteRegEx": "Hellerstein", "year": 2010}, {"title": "The Role of Logic Programming in Abduction", "author": ["A.C. Kakas", "R. Kowalski", "F. Toni"], "venue": "Handbook of Logic in Artificial Intelligence and Programming", "citeRegEx": "Kakas et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Kakas et al\\.", "year": 1998}, {"title": "The KGP model of agency", "author": ["A.C. Kakas", "P. Mancarella", "F. Sadri", "K Stathis", "F. Toni"], "venue": "In Proc. ECAI-2004", "citeRegEx": "Kakas et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Kakas et al\\.", "year": 2004}, {"title": "General Descriptions of Additive Effects via Aggregates in the Circumscriptive Event Calculus", "author": ["A. Khandelwal", "P. Fox"], "venue": null, "citeRegEx": "Khandelwal and Fox,? \\Q2012\\E", "shortCiteRegEx": "Khandelwal and Fox", "year": 2012}, {"title": "Logic for Problem Solving", "author": ["R. Kowalski"], "venue": null, "citeRegEx": "Kowalski,? \\Q1979\\E", "shortCiteRegEx": "Kowalski", "year": 1979}, {"title": "Computational Logic and Human Thinking: How to be Artificially Intelligent", "author": ["R. Kowalski"], "venue": null, "citeRegEx": "Kowalski,? \\Q2011\\E", "shortCiteRegEx": "Kowalski", "year": 2011}, {"title": "From Logic Programming Towards Multi-agent Systems", "author": ["R. Kowalski", "F. Sadri"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Kowalski and Sadri,? \\Q1999\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 1999}, {"title": "Integrating Logic Programming and Production Systems in Abductive Logic Programming Agents", "author": ["R. Kowalski", "F. Sadri"], "venue": "Proceedings of The Third International Conference on Web Reasoning and Rule Systems, Chantilly, Virginia, USA.", "citeRegEx": "Kowalski and Sadri,? 2009", "shortCiteRegEx": "Kowalski and Sadri", "year": 2009}, {"title": "An Agent Language with Destructive Assignment and ModelTheoretic Semantics", "author": ["R. Kowalski", "F. Sadri"], "venue": "Proc. of the 11th International Workshop on Computational Logic in Multi-Agent Systems (CLIMA),", "citeRegEx": "Kowalski and Sadri,? \\Q2010\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2010}, {"title": "Abductive Logic Programming Agents with Destructive Databases", "author": ["R. Kowalski", "F. Sadri"], "venue": "Annals of Mathematics and Artificial Intelligence, Volume 62,", "citeRegEx": "Kowalski and Sadri,? \\Q2011\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2011}, {"title": "Teleo-Reactive abductive logic programs", "author": ["R. Kowalski", "F. Sadri"], "venue": "Logic Programs, Norms and Action,", "citeRegEx": "Kowalski and Sadri,? \\Q2012\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2012}, {"title": "RuleML 2012, A Logic-Based Framework for Reactive Systems, Rules on the Web: Research and Applications, 2012 \u2013 Springer-Verlag", "author": ["R. Kowalski", "F. Sadri"], "venue": "A. Bikakis and A. Giurca (Eds.), LNCS 7438, pp. 1\u201315.", "citeRegEx": "Kowalski and Sadri,? 2012b", "shortCiteRegEx": "Kowalski and Sadri", "year": 2012}, {"title": "A Logic-based Calculus of Events", "author": ["R. Kowalski", "M. Sergot"], "venue": "In: New Generation Computing, Vol. 4, No.1, 67\u201495.", "citeRegEx": "Kowalski and Sergot,? 1986", "shortCiteRegEx": "Kowalski and Sergot", "year": 1986}, {"title": "Negation in Logic Programming", "author": ["K. Kunen"], "venue": "Journal of Logic Programming, 4:4 289\u2014 308.", "citeRegEx": "Kunen,? 1987", "shortCiteRegEx": "Kunen", "year": 1987}, {"title": "On Active Deductive Databases: The Statelog Approach", "author": ["G. Lausen", "B. Lud\u00e4scher", "W. May"], "venue": "In: Transactions and Change in Logic Databases, Decker, H., Freitag B., Kifer, M., Voronkov, A. (eds.), LNCS 1472, Springer.", "citeRegEx": "Lausen et al\\.,? 1998", "shortCiteRegEx": "Lausen et al\\.", "year": 1998}, {"title": "Making PROLOG More Expressive", "author": ["J.W. Lloyd", "R.W. Topor"], "venue": "Journal of Logic Programming", "citeRegEx": "Lloyd and Topor,? \\Q1984\\E", "shortCiteRegEx": "Lloyd and Topor", "year": 1984}, {"title": "Recent Advances in Declarative Networking, Practical Aspects of Declarative Languages-14th International Symposium, PADL", "author": ["B. Loo", "H. Gill", "C. Liu", "Y. Mao", "W. Marczak", "M. Sherr", "A. Wang", "W. Zhuo"], "venue": null, "citeRegEx": "Loo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Loo et al\\.", "year": 2012}, {"title": "Declarative Networking", "author": ["B.T. Loo", "B.T. Condie", "M. Garofalakis", "D.E. Gay", "J.M. Hellerstein", "P. Maniatis", "R. Ramakrishnan", "T. Roscoe", "I. Stoica"], "venue": "Communications of the ACM (CACM).", "citeRegEx": "Loo et al\\.,? 2009", "shortCiteRegEx": "Loo et al\\.", "year": 2009}, {"title": "The CIFF Proof Procedure for Abductive Logic Programming with Constraints: Theory, Implementation and Experiments", "author": ["P. Mancarella", "G. Terreni", "F. Sadri", "F. Toni", "U. Endriss"], "venue": "Theory and Practice of Logic Programming.", "citeRegEx": "Mancarella et al\\.,? 2009", "shortCiteRegEx": "Mancarella et al\\.", "year": 2009}, {"title": "Some Philosophical Problems from the Standpoint of Artificial Intelligence, Machine Intelligence 4, Edinburgh University Press", "author": ["J. McCarthy", "P. Hayes"], "venue": "463-502.", "citeRegEx": "McCarthy and Hayes,? 1969", "shortCiteRegEx": "McCarthy and Hayes", "year": 1969}, {"title": "Some Alternative Formulations of the Event Calculus", "author": ["Miller R.", "M. Shanahan"], "venue": "Computational logic: logic programming and beyond. Springer-Verlag, 452-490.", "citeRegEx": "R. and Shanahan,? 2002", "shortCiteRegEx": "R. and Shanahan", "year": 2002}, {"title": "Production Systems: Models of Control Structure", "author": ["A. Newell"], "venue": "In: Chase W. (ed.), Visual Information Processing, 463-526 New York, Academic Press, pp. 463\u2014526.", "citeRegEx": "Newell,? 1973", "shortCiteRegEx": "Newell", "year": 1973}, {"title": "Database: Theory vs", "author": ["J.M. Nicolas", "H. Gallaire"], "venue": "Interpretation. In: Gallaire, H., Minker, J. (eds.), Logic and Databases, Plenum, New York.", "citeRegEx": "Nicolas and Gallaire,? 1978", "shortCiteRegEx": "Nicolas and Gallaire", "year": 1978}, {"title": "Teleo-reactive Programs and the Triple-tower Architecture, Electronic Transactions on Artificial Intelligence, Vol", "author": ["N.J. Nilsson"], "venue": "5, Section B, 99-110.", "citeRegEx": "Nilsson,? 2001", "shortCiteRegEx": "Nilsson", "year": 2001}, {"title": "Definite clause grammars for language analysis\u2014A survey of the formalism and a comparison with augmented transition networks, Artificial Intelligence", "author": ["Pereira", "F.C.N", "Warren", "D.H.D"], "venue": "Volume 13,", "citeRegEx": "Pereira et al\\.,? \\Q1980\\E", "shortCiteRegEx": "Pereira et al\\.", "year": 1980}, {"title": "On the declarative semantics of stratified deductive databases and logic programs", "author": ["T. Przymusinski"], "venue": "Foundations of Deductive Databases and Logic Programming, Morgan Kaufmann, J. Minker (Ed.) 193 \u2013 216.", "citeRegEx": "Przymusinski,? 1987", "shortCiteRegEx": "Przymusinski", "year": 1987}, {"title": "Weakly perfect model semantics for logic programs, Fifth Int'l Conf", "author": ["H. Przymusinska", "T. Przymusinski"], "venue": "Symp. on Logic Programming.", "citeRegEx": "Przymusinska and Przymusinski,? 1988", "shortCiteRegEx": "Przymusinska and Przymusinski", "year": 1988}, {"title": "A Semantics for a Class of Stratified Production System Programs", "author": ["L. Raschid"], "venue": "J. Log. Program. 21(1): 31\u201457.", "citeRegEx": "Raschid,? 1994", "shortCiteRegEx": "Raschid", "year": 1994}, {"title": "AgentSpeak (L): BDI agents speak out in a logical computable language", "author": ["A. Rao"], "venue": "Agents Breaking Away,", "citeRegEx": "Rao,? \\Q1996\\E", "shortCiteRegEx": "Rao", "year": 1996}, {"title": "On Integrity Constraints", "author": ["R. Reiter"], "venue": "In: 2nd Conference on Theoretical Aspects of Reasoning about Knowledge, pp. 97\u2014111.", "citeRegEx": "Reiter,? 1988", "shortCiteRegEx": "Reiter", "year": 1988}, {"title": "Natural actions, concurrency and continuous time in the situation calculus", "author": ["R. Reiter"], "venue": "In Proceedings of Principles of Knowledge Representation", "citeRegEx": "Reiter,? \\Q1996\\E", "shortCiteRegEx": "Reiter", "year": 1996}, {"title": "The expressive power of abstract-state machines", "author": ["W. Reisig"], "venue": "Computing and Informatics,", "citeRegEx": "Reisig,? \\Q2012\\E", "shortCiteRegEx": "Reisig", "year": 2012}, {"title": "Formalizing production systems with rule-based ontologies", "author": ["M. Rezk", "M. Kifer"], "venue": "Foundations of Information and Knowledge Systems,", "citeRegEx": "Rezk and Kifer,? \\Q2012\\E", "shortCiteRegEx": "Rezk and Kifer", "year": 2012}, {"title": "Solving the frame problem: a mathematical investigation of the common sense law of inertia", "author": ["M. Shanahan"], "venue": null, "citeRegEx": "Shanahan,? \\Q1997\\E", "shortCiteRegEx": "Shanahan", "year": 1997}, {"title": "FLUX: A logic programming method for reasoning agents", "author": ["M. Thielscher"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Thielscher,? \\Q2005\\E", "shortCiteRegEx": "Thielscher", "year": 2005}, {"title": "Integrating Action Calculi and AgentSpeak", "author": ["M. Thielscher"], "venue": "Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning (KR), Lin, F and Sattler, U. (eds.), Toronto.", "citeRegEx": "Thielscher,? 2010", "shortCiteRegEx": "Thielscher", "year": 2010}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Gelder et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "On the Unification of Active Databases and Deductive databases", "author": ["C. Zaniolo"], "venue": "In: 11th British National Conference on Databases, 23-39.", "citeRegEx": "Zaniolo,? 1993", "shortCiteRegEx": "Zaniolo", "year": 1993}], "referenceMentions": [{"referenceID": 37, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 38, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 39, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 41, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 8, "context": "The state is like a relational database, but also like a set of program variables or tuples in a coordination language [Carriero and Gelernter 1989].", "startOffset": 119, "endOffset": 148}, {"referenceID": 49, "context": "The domain theory D is similar to the situation calculus [McCarthy and Hayes 1969] or event calculus [Kowalski and Sergot 1986], but instead of using frame axioms to update states, it performs destructive updates on the current state, deleting facts that are terminated by the set of all events occurring in the state transition and adding facts that are initiated by the set of events.", "startOffset": 57, "endOffset": 82}, {"referenceID": 42, "context": "The domain theory D is similar to the situation calculus [McCarthy and Hayes 1969] or event calculus [Kowalski and Sergot 1986], but instead of using frame axioms to update states, it performs destructive updates on the current state, deleting facts that are terminated by the set of all events occurring in the state transition and adding facts that are initiated by the set of events.", "startOffset": 101, "endOffset": 127}, {"referenceID": 4, "context": "These composite events can be viewed as state-connecting paths, as in transaction logic [Bonner and Kifer 1993].", "startOffset": 88, "endOffset": 111}, {"referenceID": 55, "context": "The semantics of these FOL conditions is given by generalising negative literals to FOL conditions in the definitions of local stratification [Przymusinski 1987] and weak stratification [Przymusinska and Przymusinski 1988].", "startOffset": 142, "endOffset": 161}, {"referenceID": 56, "context": "The semantics of these FOL conditions is given by generalising negative literals to FOL conditions in the definitions of local stratification [Przymusinski 1987] and weak stratification [Przymusinska and Przymusinski 1988].", "startOffset": 186, "endOffset": 222}, {"referenceID": 28, "context": "The following example is a variant of an example in [Hausmann et al. 2012].", "startOffset": 52, "endOffset": 74}, {"referenceID": 34, "context": "These programs are similar to the logical representation of definite clause grammars [Pereira and Warren 1980] in Prolog, and used in [Kowalski 1979] to illustrate parsing as reasoning:", "startOffset": 134, "endOffset": 149}, {"referenceID": 39, "context": "In an earlier version of LPS [Kowalski and Sadri 2011] we allowed \u201cplanning clauses\u201d, which in the case of make-clear could have the form:", "startOffset": 29, "endOffset": 54}, {"referenceID": 41, "context": "Such planning clauses allow a higher level of knowledge representation than the version of LPS presented in [Kowalski and Sadri 2012a; Kowalski and Sadri 2012b] and in this paper.", "startOffset": 108, "endOffset": 160}, {"referenceID": 8, "context": "The solution of the dining philosophers\u2019 problem presented below is similar to the solution in C-Linda [Carriero and Gelernter 1989].", "startOffset": 103, "endOffset": 132}, {"referenceID": 8, "context": "The extensional fluents are like tuples in a relational database, or in a coordination language [Carriero and Gelernter 1989].", "startOffset": 96, "endOffset": 125}, {"referenceID": 39, "context": "For example, in [Kowalski and Sadri 2011], temporal ordering is indicated by the order in which formulas are written and by the use of special logical connectives.", "startOffset": 16, "endOffset": 41}, {"referenceID": 4, "context": "[Bonner and Kifer 1993], in which P \uf0c4 Q means \u201cdo P and then do Q\u201d.", "startOffset": 0, "endOffset": 23}, {"referenceID": 41, "context": "1 In [Kowalski and Sadri 2012b] we allowed consequents of rules to be disjunctions of such conjunctions.", "startOffset": 5, "endOffset": 31}, {"referenceID": 45, "context": "Like the antecedents and consequents of rules, they can also contain non-atomic FOL conditions, as in the extended logic programs of [Lloyd and Topor 1984].", "startOffset": 133, "endOffset": 155}, {"referenceID": 39, "context": "In particular, although the OS is defined for programs written with an explicit representation of time, it can also be implemented, as in [Kowalski and Sadri 2011], directly for programs written in an external syntax in which temporal order is indicated by the order in which conditions and events are written.", "startOffset": 138, "endOffset": 163}, {"referenceID": 29, "context": "In this way, the global state serves as a coordination medium, in the manner of the Linda programming paradigm [Carriero and Gelenter 1989] and the blackboard model [Hayes-Roth 1985].", "startOffset": 165, "endOffset": 182}, {"referenceID": 41, "context": "As pointed out in [Kowalski and Sadri 2012b], the operational semantics is incomplete.", "startOffset": 18, "endOffset": 44}, {"referenceID": 1, "context": "The problem and its solution are similar to those for the program [Apt and Bol 1994]:", "startOffset": 66, "endOffset": 84}, {"referenceID": 52, "context": "Our attention was first drawn to the distinction between reactive rules and logic programs by the distinction made by [Nicolas and Gallaire 1978] between deduction rules and integrity constraints in deductive databases, both of which have a logical semantics.", "startOffset": 118, "endOffset": 145}, {"referenceID": 9, "context": "The two main views, to begin with, were the consistency view and the theoremhood view, both of which were defined relative to the completion of the database [Clark 1978].", "startOffset": 157, "endOffset": 169}, {"referenceID": 59, "context": "[Reiter 1988] also proposed an epistemic view, according to which integrity constraints are statements about what the database knows.", "startOffset": 0, "endOffset": 13}, {"referenceID": 59, "context": "However, [Reiter 1988] also showed that in many cases all three views are equivalent.", "startOffset": 9, "endOffset": 22}, {"referenceID": 4, "context": "The use of logic programs in LPS with FOL conditions was largely inspired by transaction logic [Bonner and Kifer 1993], which uses such programs to define database transactions.", "startOffset": 95, "endOffset": 118}, {"referenceID": 31, "context": "The distinction between logic programs and integrity constraints also underpins abductive logic programming (ALP) [Kakas et al. 1998; Denecker and Kakas 2002].", "startOffset": 114, "endOffset": 158}, {"referenceID": 13, "context": "The distinction between logic programs and integrity constraints also underpins abductive logic programming (ALP) [Kakas et al. 1998; Denecker and Kakas 2002].", "startOffset": 114, "endOffset": 158}, {"referenceID": 22, "context": "The operational semantics of LPS is a variant of the IFF proof procedure [Fung and Kowalski 1997], originally developed for Kunen\u2019s three valued completion semantics [Kunen 1987].", "startOffset": 73, "endOffset": 97}, {"referenceID": 43, "context": "The operational semantics of LPS is a variant of the IFF proof procedure [Fung and Kowalski 1997], originally developed for Kunen\u2019s three valued completion semantics [Kunen 1987].", "startOffset": 166, "endOffset": 178}, {"referenceID": 30, "context": "For example, the application of Datalog to declarative networking [Loo et al 2009; Hellerstein 2010; Loo et al 2012] makes heavy use of stratification, and the extensions of stratification in this paper might also be useful in that domain.", "startOffset": 66, "endOffset": 116}, {"referenceID": 32, "context": "The ALP agent approach was developed further in the KGP agent model [Kakas et al. 2004; Mancarella et al. 2009].", "startOffset": 68, "endOffset": 111}, {"referenceID": 48, "context": "The ALP agent approach was developed further in the KGP agent model [Kakas et al. 2004; Mancarella et al. 2009].", "startOffset": 68, "endOffset": 111}, {"referenceID": 5, "context": "For example in both DALI [Costantini and Tocchino 2004; Costantini and Tocchino 2006] and EVOLP [Brogi et al. 2002], events transform an initial agent logic program into a sequence of logic programs.", "startOffset": 96, "endOffset": 115}, {"referenceID": 64, "context": "FLUX [Thielscher 2005] is an agent language with several features similar to LPS, including the use of destructive assignment to update states.", "startOffset": 5, "endOffset": 22}, {"referenceID": 65, "context": "[Thielscher 2010] provides a declarative semantics for AgentSpeak by defining its cycle and procedures by means of a meta-interpreter represented as a logic program.", "startOffset": 0, "endOffset": 17}, {"referenceID": 26, "context": "Somewhat closer to LPS is the agent architecture of [Hayashi et al. 2005; Hayashi et al 2009], which separates the representation of reactive rules and planning clauses.", "startOffset": 52, "endOffset": 93}, {"referenceID": 16, "context": "38 [Eiter et al. 1999]] define an extension of logic programming in which the clauses represent the conditions under which actions are permitted, forbidden, obliged or waived.", "startOffset": 3, "endOffset": 22}, {"referenceID": 2, "context": "As pointed out by [Bailey et al. 1995], although they differ in their intended applications and research communities, agent systems and active databases employ similar approaches to programming reactive systems.", "startOffset": 18, "endOffset": 38}, {"referenceID": 58, "context": "For example, AgentSpeak [Rao 1996] employs agent programs that are plans consisting of a triggering event, a context, which specifies the conditions that should hold when the plan is triggered, and a body, which specifies the goals the agent should achieve or test, and the actions the agent should execute.", "startOffset": 24, "endOffset": 34}, {"referenceID": 67, "context": "[Zaniolo 1993], for example, uses a situation calculus-like representation with frame axioms, and reduces ECA rules to logic programs.", "startOffset": 0, "endOffset": 14}, {"referenceID": 44, "context": "Statelog [Lausen et al. 1998] also uses a situation-calculus-like representation for the succession of database states.", "startOffset": 9, "endOffset": 29}, {"referenceID": 0, "context": "ERA (Evolving Reactive Algebraic Programs) [Alferes et al. 2006] extends the dynamic logic programming system EVOLP [Brogi et al.", "startOffset": 43, "endOffset": 64}, {"referenceID": 5, "context": "2006] extends the dynamic logic programming system EVOLP [Brogi et al. 2002] by adding complex events and actions as well as external actions.", "startOffset": 57, "endOffset": 76}, {"referenceID": 21, "context": "[Fraternali and Tanca 1995] also consider active databases but provide a logic-based core syntax for representing low-level, procedural features of active database rules.", "startOffset": 0, "endOffset": 27}, {"referenceID": 51, "context": "Arguably, production systems [Newell 1973], in which programs are expressed as condition-action rules, are the simplest example of a reactive system, and the earliest ancestor both of agent systems and active databases.", "startOffset": 29, "endOffset": 42}, {"referenceID": 57, "context": "[Raschid 1994] focuses on the use of production rules as reactive rules and as forward-reasoning logic rules.", "startOffset": 0, "endOffset": 14}, {"referenceID": 3, "context": "[Baral and Lobo 1995] translate production rules into the situation calculus represented as a logic program with the stable model semantics.", "startOffset": 0, "endOffset": 21}, {"referenceID": 15, "context": "[Dung and Mancarella 2002], on the other hand, use an argumentation theoretic framework to provide semantics for production rules extended with negation as failure.", "startOffset": 0, "endOffset": 26}, {"referenceID": 62, "context": "[Rezk and Kifer 2012] combine production rules and ontologies, using transaction logic.", "startOffset": 0, "endOffset": 21}, {"referenceID": 36, "context": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al.", "startOffset": 11, "endOffset": 51}, {"referenceID": 35, "context": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al.", "startOffset": 11, "endOffset": 51}, {"referenceID": 32, "context": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al. 2004] employ the event calculus to represent and reason about the relationship between fluents, actions and other events.", "startOffset": 76, "endOffset": 95}, {"referenceID": 6, "context": "In other words, the world can serve as its own representation, as advocated by [Brooks 1991].", "startOffset": 79, "endOffset": 92}, {"referenceID": 60, "context": "The AI component comes from the use of the domain theory D, to reason about the combined effects of concurrent actions, in the spirit of [Reiter 1996]\u2019s treatment of concurrent actions in the situation calculus and [Miller and Shanahan 2002]\u2019s treatment in the event calculus.", "startOffset": 137, "endOffset": 150}, {"referenceID": 33, "context": "Recently, [Khandelwal and Fox 2012] have extended Miller and Shanahan\u2019s approach, to define the effects of multiple actions by using aggregate formulas in first-order logic.", "startOffset": 10, "endOffset": 35}, {"referenceID": 14, "context": "Our assumption that the environment non-deterministically decides which sets of possible concurrent events actually occur is similar to the use of a \u201csupervisor\u201d in [Dovier et al. 2012], to arbitrate between the conflicting actions of different agents in the pursuit of different goals.", "startOffset": 165, "endOffset": 185}, {"referenceID": 14, "context": "In addition, [Dovier et al. 2012] also provides communication primitives, to allow agents to resolve conflicts through negotiation.", "startOffset": 13, "endOffset": 33}, {"referenceID": 30, "context": "In this respect, it is encouraging to note the recent developments [Hellerstein 2010] in the use of Datalog and the explicit", "startOffset": 67, "endOffset": 85}, {"referenceID": 30, "context": "Although frame axioms are represented explicitly in [Hellerstein 2010], they are not used in the implementation, using instead \u201ctraditional storage technology rather than rederiving tuples each timestep\u201d.", "startOffset": 52, "endOffset": 70}, {"referenceID": 25, "context": "[Harel 2009] notes that StateCharts, a graphical language for reactive systems, is \u201cthe heart of the UML - what many people refer to as its driving behavioral kernel\u201d.", "startOffset": 0, "endOffset": 12}, {"referenceID": 61, "context": "As [Reisig 2012] puts it, an initialized, deterministic transition system is \u201ca triple C = (Q, I, F) where Q is a set (its elements are denoted as states), I \u2286 Q (the initial", "startOffset": 3, "endOffset": 16}], "year": 2013, "abstractText": "Computer Science today lacks a unified view of Computing. Instead, the main subareas, most notably artificial intelligence, database systems and programming languages, offer different and often competing approaches to knowledge representation, problem-solving and computation. In this paper we propose a unifying logic-based, framework for Computing, inspired by artificial intelligence, but scaled down for practical database and programming applications. Computation in the framework is viewed as the task of generating a sequence of state transitions, with the purpose of making an agent\u2019s goals all true. States are represented by sets of atomic sentences (or facts), representing the values of program variables, tuples in a coordination language, facts in relational databases, or Herbrand models. In the model-theoretic semantics, the entire sequence of states and events are combined into a single model-theoretic structure, by associating time stamps with facts. But in the operational semantics, facts are updated destructively, without time stamps. We show that the model generated by destructive updates is identical to the model generated by reasoning with facts containing time stamps. We also extend the model with intentional predicates and composite event predicates defined by logic programs containing conditions in first-order logic (FOL). We extend the notions of local stratification and weak stratification to generate the associated model.", "creator": "Microsoft\u00ae Office Word 2007"}}}