{"id": "1305.0103", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-May-2013", "title": "Clustering Unclustered Data: Unsupervised Binary Labeling of Two Datasets Having Different Class Balances", "abstract": "We consider the unsupervised learning problem of assigning labels to unlabeled data. A naive approach is to use clustering methods, but this works well only when data is properly clustered and each cluster corresponds to an underlying class. In this paper, we first show that this unsupervised labeling problem in balanced binary cases can be solved if two unlabeled datasets having different class balances are available. More specifically, estimation of the sign of the difference between probability densities of two unlabeled datasets gives the solution. We then introduce a new method to directly estimate the sign of the density difference without density estimation. Finally, we demonstrate the usefulness of the proposed method against several clustering methods on various toy problems and real-world datasets.", "histories": [["v1", "Wed, 1 May 2013 06:32:12 GMT  (76kb)", "http://arxiv.org/abs/1305.0103v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["marthinus christoffel du plessis", "masashi sugiyama"], "accepted": false, "id": "1305.0103"}, "pdf": {"name": "1305.0103.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Masashi Sugiyama"], "emails": ["christo@sg.cs.titech.ac.jp,", "sugi@cs.titech.ac.jp"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 5.\n01 03\nv1 [\ncs .L\nG ]\n1 M"}, {"heading": "1 Introduction", "text": "Gathering labeled data is expensive and time consuming in many practical machine learning problems, and therefore class labels are often absent. In this paper, we consider the problem of labeling, which is aimed at giving a label to each sample. Labeling is similar to classification, but it is slightly simpler than classification because classes do not have to be specified. That is, labeling just tries to split unlabeled samples into disjoint subsets, and class labels such as male/female or positive/negative are not assigned to samples.\nA naive approach to the labeling problem is to use a clustering technique which is aimed at assigning a label to each sample of the dataset to divide the dataset into disjoint clusters. The tacit assumption in clustering is that the clusters correspond to the underlying classes. However, this assumption is often violated in practical datasets, for example, when clusters are not well separated or a dataset exhibits within-class multimodality.\nAn example of the labeling problem is illustrated in Figure 1. Figure 1(a) denotes the densities of the two classes. Figure 1(b) denotes samples drawn from a mixture of the two original densities. Because the two clusters are highly overlapping, it may not be possible to properly label them by a clustering method.\nIn this paper we show that if one more dataset with a different class balance is available (Figure 1(c)), the labeling problem can be solved (Figures 1(d) and\n1(e)). More specifically, we show that a labeling for the samples can be obtained by estimating the sign of the difference between probability densities of two unlabeled datasets. A naive way is to first separately estimate two densities from two\nsets of samples and then take the sign of their difference to obtain a labeling. However, this naive procedure violates Vapnik\u2019s principle[1]:\nIf you possess a restricted amount of information for solving some problem, try to solve the problem directly and never solve a more general problem as an intermediate step. It is possible that the available information is sufficient for a direct solution but is insufficient for solving a more general intermediate problem.\nThis principle was used in the development of support vector machines (SVMs): Rather than modeling two classes of samples, SVM directly learns a decision boundary that is sufficient for performing pattern recognition.\nIn the current context, estimating two densities is more general than labeling samples. Thus, the above naive scheme may be improved by estimating the density difference directly and then taking its sign to obtain the class labels. Recently, a method was introduced to directly estimate the density difference, called the least-squares density difference (LSDD) estimator [2]. Thus, the use of LSDD for labeling is expected to improve the performance.\nHowever, the LSDD-based procedure is still indirect; directly estimating the sign of the density difference would be the most suitable approach to labeling. In this paper, we show that the sign of the density difference can be directly estimated by lower-bounding the L1-distance between probability densities. Based on this, we give a practical algorithm for labeling and illustrate its usefulness through experiments on various real-world datasets."}, {"heading": "2 Problem Formulation and Fundamental Approaches", "text": "In this section, we formulate the problem of labeling, give our fundamental strategy, and consider two naive approaches."}, {"heading": "2.1 Problem Formulation", "text": "Suppose that there are two probability distributions p(x, y) and p\u2032(x, y) on x \u2208 R d and y \u2208 {1,\u22121}, which are different only in class balances:\np(y) 6= p\u2032(y) but p(x|y) = p\u2032(x|y). (1)\nFrom these distributions, we are given two sets of unlabeled samples:\nXp = {xi} n i=1 i.i.d. \u223c p(x) and Xp\u2032 = {x \u2032 j} n\u2032 j=1 i.i.d. \u223c p\u2032(x).\nThe goal of labeling is to obtain a labeling for the two sets of samples, Xp and Xp\u2032 , that corresponds to the underlying class labels {yi}ni=1 and {y \u2032 j} n\u2032\nj=1. However, different from classification, we do not obtain correct class labels, but we obtain correct class separation up to label commutation."}, {"heading": "2.2 Fundamental strategy", "text": "We wish to obtain a labeling for samples in Xp and Xp\u2032 . Here we show that we can obtain the solution for the case where the class priors are equal. We may write the class-posterior distribution for the equal prior case as\nq(y = 1|x) = p(x|y)q(y)\nq(x) ,\nwhere q(y = 1) = q(y = \u22121) = 1 2 . A class label can then be assigned to a point by evaluating\nsign [q(y = 1|x)\u2212 q(y = \u22121|x)]\nWe can write the criterion as\nq(y = 1|x)\u2212 q(y = \u22121|x) = p(x|y = 1)1 2\nq(x) \u2212\np(x|y = \u22121)1 2\nq(x) ,\n\u221d p(x|y = 1)\u2212 p(x|y = \u22121).\nWe do not have any labeled samples to calculate p(x|y = 1)\u2212 p(x|y = \u22121), but we can rewrite it in terms of marginal distributions. To see this, the above is multiplied with p(y = 1)\u2212 p\u2032(y = 1), which gives\np(x|y = 1)\u2212 p(x|y = \u22121) \u221d [p(y = 1)\u2212 p\u2032(y = 1)] [p(x|y = 1)\u2212 p(x|y = \u22121)]\n\u221d p(x, y = 1)\u2212 p\u2032(x, y = 1)\n\u2212 p(y = 1)p(x|y = \u22121) + p\u2032(y = 1)p(x|y = \u22121).\nNote that the sign may change since p(y = 1) \u2212 p\u2032(y = 1) may be positive or negative. To write the third and fourth term as a joint distribution, we add and subtract p(x|y = \u22121), giving\np(x|y = 1)\u2212 p(x|y = \u22121) \u221d p(x, y = 1)\u2212 p\u2032(x, y = \u22121) + [1\u2212 p(y = 1)] p(x|y =\u22121)\n\u2212 [1\u2212 p\u2032(y = 1)] p(x|y = \u22121).\nSince p(y = \u22121) = 1\u2212 p(y = 1) and p\u2032(y = \u22121) = 1\u2212 p\u2032(y = 1), we can express the above as\nq(y = 1|x)\u2212 q(y = \u22121|x) \u221d p(x)\u2212 p\u2032(x).\nThe exact class labels can not be recovered since the term p(y = 1)\u2212 p\u2032(y = 1) can be positive or negative. Therefore, we assign the label y \u2208 {1,\u22121} to a point x according to the following criterion:\ny = sign [p(x)\u2212 p\u2032(x)]. (2)\nThus, now we need a good method to estimate sign [p(x)\u2212 p\u2032(x)]."}, {"heading": "2.3 Kernel Density Estimation", "text": "A naive approach to estimating the sign of density-difference is to use kernel density estimators (KDEs) [3]. For Gaussian kernels, the KDE solutions are given by\np\u0302(x) \u221d n\u2211\ni=1\nexp ( \u2212 \u2016x\u2212 xi\u2016 2\n2\u03c32\n) and p\u0302\u2032(x) \u221d n\u2032\u2211\nj=1\nexp ( \u2212 \u2016x\u2212 x\u2032j\u2016 2\n2\u03c3\u20322\n) .\nThe Gaussian widths \u03c3 and \u03c3\u2032 may be determined based on least-squares crossvalidation [4]. Finally, a labeling is obtained as\ny = sign [p\u0302(x)\u2212 p\u0302\u2032(x)]. (3)"}, {"heading": "2.4 Direct Estimation of the Density Difference", "text": "KDE is a nice density estimator, but it is not necessarily suitable in densitydifference estimation, because small estimation error incurred in each density estimate can cause a big error in the final density-difference estimate. More intuitively, good density estimators tend to be smooth and thus a densitydifference estimator obtained from such smooth density estimators tends to be over-smoothed [5,6].\nThe density difference can be estimated in a single shot using the least-squares density difference (LSDD) approach [2]. In this approach, we directly fit a model g(x) to the density difference under the square loss:\ng\u0302 = argmin g\n1\n2\n\u222b (g(x)\u2212 (p(x)\u2212 p\u2032(x))) 2 dx,\nwhich can be efficiently obtained for a kernel density-difference model. A comprehensive review of LSDD is provided in Appendix B. Finally, a labeling is obtained as\ny = sign[g\u0302(x)]."}, {"heading": "3 Direct Estimation of the Sign of the Density Difference", "text": "We expect that an improved solution can be obtained by LSDD over KDEs due to more direct nature of LSDD. However, LSDD is still indirect because the sign of density difference is inspected after the density difference is estimated. In this section, we show how to directly estimate the sign of the density difference."}, {"heading": "3.1 Derivation of the Objective Function", "text": "By lower-bounding the L1-distance between probability densities, defined as \u222b\n|p(x)\u2212 p\u2032(x)| dx, (4)\nwe can obtain the sign of the density difference. We begin by considering the following self-evident relation:\n|t| \u2265 tz, if |z| \u2264 1.\nWe can apply this relation at each point x, to obtain\n|p(x)\u2212 p\u2032(x)| \u2265 g(x) [p(x)\u2212 p\u2032(x)] if |g(x)| \u2264 1, \u2200x.\nBy applying the above inequality to Eq.(4) and maximizing with respect to g(x), we can obtain the tightest lower bound as\n\u222b |p(x)\u2212 p\u2032(x)| dx \u2265 sup\ng\n\u222b g(x) [p(x)\u2212 p\u2032(x)] dx (5)\ns.t. |g(x)| \u2264 1, \u2200x.\nIt is straightforward to verify that the above relation will be met with equality when\ng(x) = sign (p(x)\u2212 p\u2032(x)) .\nWhat makes the expression in the right-hand side of Eq.(5) especially useful is that the probability densities occur linearly in the integral. By replacing the integrals with sample averages and searching g(x) from a parametric family (denoted as g\u03b1(x)), we can write the above as\n\u03b1 = argmin \u03b1\n1 n\u2032\nn\u2032\u2211\nj=1\ng\u03b1(x \u2032 j)\u2212\n1\nn\nn\u2211\ni=1\ng\u03b1(xi)\ns.t. |g\u03b1(x)| \u2264 1, \u2200x.\n(6)"}, {"heading": "3.2 Optimization", "text": "Here we briefly discuss how to solve the problem in Eq. (6). A more detailed explanation is given in Appendix A.\nThe function in Eq. (6) should satisfy the constraint |g(x)| \u2264 1, \u2200x. We can consider a clipped version of the function that always satisfies the constraint,\ng\u0303(x) = R(g(x)), where R(z) =    1 z > 1, \u22121 z < \u22121,\nz otherwise.\nWe use a linear-in-parameter model,\ng(x) =\nb\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x),\nwhere \u03d5\u2113(x) are the basis functions. Using the above definitions, we can rewrite Eq.(6) as\nJ(\u03b1) = 1\nn\u2032\nn\u2032\u2211\ni=1\nR\n( b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x \u2032 i)\n) \u2212 1\nn\nn\u2211\nj=1\nR\n( b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(xj)\n) + \u03bb\n2\nb\u2211\n\u2113=1\n\u03b12\u2113 , (7)\nwhere \u03bb 2 \u2211b \u2113=1 \u03b1 2 \u2113 is a regularization term. Although the above is a non-convex problem, we can efficiently find a local optimal solution using the convex-concave procedure (CCCP) [7] (also known as difference of convex (d.c.) programming [8]). The CCCP procedure requires the objective function to be split into a convex and concave part,\nJ(\u03b1) = Jvex(\u03b1) + Jcave(\u03b1).\nThe concave part is then upper-bounded as\nJcave(\u03b1) \u2264 J\u0304cave(\u03b1, b, c),\nwhere the bound is specified by b and c (details are given in Appendix A). This bound is convex w.r.t. b and c if \u03b1 is fixed. Using this bound, the optimization problem can then be expressed as\nJ(\u03b1) \u2264 Jvex(\u03b1) + J\u0304cave(\u03b1, b, c).\nThe strategy to minimize J(\u03b1) is then to alternately minimize the right-hand side by minimizing w.r.t. \u03b1 (keeping b and c constant) and minimize w.r.t. b and c (keeping \u03b1 constant). Minimization w.r.t. \u03b1 minimizes the current upper bound and minimization w.r.t. b and c corresponds to tightening the bound at the current point.\nMinimization w.r.t. b and c can be performed by\nbi =\n{ 0 \u2211b \u2113=1 \u03b1\u2113\u03d5\u2113(x \u2032 i) < 1,\n1 otherwise, and cj =\n{ 0 \u2211b \u2113=1 \u03b1\u2113\u03d5(xj) < \u22121,\n1 otherwise. (8)\nMinimization of the upper bound (assuming b and c is constant) can be performed by solving the following convex quadratic problem:\nJ\u0304(\u03b1) = 1\nn\u2032\nn\u2032\u2211\ni=1\n\u03be\u2032i+ 1\nn\nn\u2211\nj=1\n\u03bej\u2212 b\u2211\n\u2113=1\n\u03b1\u2113  1 n\u2032 n\u2032\u2211\ni=1\nbi\u03d5\u2113(x \u2032 i)+\n1\nn\nn\u2211\nj=1\ncj\u03d5\u2113(xj)\n +\u03bb\n2\nb\u2211\n\u2113=1\n\u03b12\u2113\ns.t. \u03be\u2032i \u2265 0, \u03be \u2032 i \u2265\nb\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x \u2032 i) + 1, \u2200i = 1, . . . , n \u2032\n\u03bej \u2265 0, \u03bej \u2265 b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(xj)\u2212 1 \u2200j = 1, . . . , n.\n(9)\nThe above constrained problem can be solved with an off-the-shelf QP solver. Our final optimization algorithm is summarized below:\n1. Initialize the starting value:\n\u03b11 \u2190 argmin \u03b1 Jvex(\u03b1).\n2. For t = 1, . . . T :\n(a) Tighten the upper-bound: Obtain b and c as\nb, c\u2190 argmin b,c\nJ\u0304(\u03b1t, b, c),\nby using Eq.(8).\n(b) Minimize the upper bound: Set\n\u03b1t+1 \u2190 argmin \u03b1 Jvex(\u03b1) + J\u0304cave(\u03b1, b, c, )\nby solving the convex problem in Eq.(9).\nIn practice, Gaussian kernels centered at the sample points in Xp and Xp\u2032 are chosen as the basis functions. All hyper-parameters are set by cross-validation."}, {"heading": "4 Experiments", "text": "We first illustrate the operation of our method and characterize the failures of other methods on various toy examples. Then we use real-world benchmark data to show the superiority of our algorithm."}, {"heading": "4.1 Numerical Illustration", "text": "Toy Problem 1: We illustrate the problem and our method with a simple example. Suppose that the class-conditional densities for the two classes are given as\np(x|y = 1) = Nx (\u221212, I2\u00d72) and p(x|y = \u22121) = Nx (12, I2\u00d72) ,\nwhereNx(\u00b5,\u03a3) denotes the normal density with mean \u00b5 and covariance\u03a3 w.r.t. x. 12 is a 2\u00d71 vector of ones and I is a 2\u00d72 identity matrix. We generate 2 sets of 30 samples with class-priors p(y = 1) = 0.3 and p\u2032(y = 1) = 0.7, respectively. The result is illustrated in Figure 1. As can be seen from this example, we are able to obtain a labeling of the classes that roughly corresponds to the true (unknown) labels of the data.\nToy Problem 2: One way to obtain a labeling is to use clustering. The tacit assumption in clustering is that samples in the same cluster belong the same class. This assumption however is not always be true, for example, when the class conditional densities are multimodal. Here we consider a problem with the following class conditional densities:\np(x|y = 1) = 1\n2 Nx([3 0]\n\u22a4 , I2\u00d72) +\n1 2 Nx([\u22123 0] \u22a4 , I2\u00d72)\np(x|y = \u22121) = 1\n2 Nx([0 3]\n\u22a4 , I2\u00d72) +\n1 2 Nx([0 \u2212 3] \u22a4 , I2\u00d72).\nThe two distributions are plotted in Figure 2a. We can try to obtain a class label by performing clustering on Xp\u222aXp\u2032 1. The results for k-means and spectral clustering, given in Figures 2d and 2e, show that these methods fail to reveal the true labeling. On the other hand, the proposed method still gives a reasonable result (Figure 2f)."}, {"heading": "4.2 Benchmark Datasets", "text": "We compare our method against several competing methods on benchmark datasets. For each experiment, we constructed the datasets Xp and Xp\u2032 by drawing n and n\u2032 samples from the positive and negative classes of the datasets according to a prior of p(y = 1) and p\u2032(y = 1). The labeling was then performed using these two datasets. Since we can obtain a labeling, but cannot determine the original class labels, we cannot measure the performance using the misclassification rate directly. Assume that the label assigned for the sample xi is\nli =\n{ \u22121 p(xi)\u2212 q(xi) < 0\n1 otherwise.\nThe misclassification rate (MCR) assuming that the current labels are correct is\nMCR := 1\nn\n\u2211\ni:lj 6=yi\n1 + 1\nn\u2032\n\u2211\nj:l\u2032 j 6=y\u2032 i\n1.\nThe misclassification rate assuming that the labels are the opposite is 1\u2212MCR. We define the labeling error rate (LER) as\nLER := min (MCR, 1\u2212MCR) .\nNote that this definition is somewhat more optimistic than using the misclassification rate. The smaller the dataset is, the lower the error would be for randomly\n1 If clustering is performed separately on Xp and Xp\u2032 , we do not know which clusters in each dataset correspond to the clusters in the other dataset. We can also not perform clustering on one dataset and apply it to the other dataset, since most clustering methods do not give out of sample labeling. For these reasons, it makes most sense to perform clustering on the combined dataset.\nassigning labels to samples: The expected LER for randomly assigning labels to samples (with equal probability) is\n1\n2n+n\u2032(n+ n\u2032)\nn+n\u2032\u2211\ni=0\nmin (i, n+ n\u2032 \u2212 i)\n( n+ n\u2032\ni\n) .\nFor n+ n\u2032 = 40, 60, 80, the expected labeling error rate is 0.437, 0.449, 0.456. We compared the following methods:\n\u2013 Direct Sign Density Difference (DSDD) Estimation (proposed): Directly estimate sign (p(x)\u2212 p\u2032(x)) using the method described in Section 3. Hyperparameters are selected via cross validation. \u2013 Least-Squares Density Difference (LSDD) Estimation: Estimate sign [p(x)\u2212 p\u2032(x)] by estimating p(x)\u2212 p\u2032(x) using the least squares fitting method [9]. Hyperparameters are selected via cross validation. \u2013 Kernel Density Estimation (KDE): Estimate sign [p(x)\u2212 p\u2032(x)] by estimating the densities p(x) and p\u2032(x) with kernel density estimation (KDE). Hyperparameters are selected using least-squares cross validation. \u2013 K-Means (KM): Cluster the data into two clusters using the K-means algorithm. \u2013 Spectral Clustering (SC): Cluster the data into two clusters using the spectral clustering algorithm [10]. The affinity matrix was constructed with 7 nearest neighbors. \u2013 Squared-loss Mutual Information based Clustering (SMIC) : Cluster the data according to the SMIC method [11]. SMIC was chosen since it provides model selection, avoiding the need for subjective parameter tuning.\nWe compare the performance of the methods by varying the class balance. Two class balances were selected: one with a large difference between the classes (p(y = 1) = 0.2 and p\u2032(y = 1) = 0.8) and one with a small difference between the two priors (p(y = 1) = 0.35 and p\u2032(y = 1) = 0.65). The average labeling error rate and standard deviation of the two experiments, with |Xp| = |Xp\u2032 | = 40 is given in Tables 1 and 2.\nFrom the results we see that methods which follow the approach proposed in Section 2 of estimating the sign of the density difference (i.e., DSDD, LSDD, and KDE) generally work better than methods using the cluster structure of the data (i.e., KM, SC and SMIC). The thyroid dataset lends itself to interpretation of why these methods work better. The labels in the thyroid dataset correspond to healthy and diseased. The diseased label is caused by either a hyper-functioning or hypo-functioning thyroid. These two underlying causes cause within-class multimodality which may cause clustering-based methods to fail.\nAmong the methods which estimate the sign of the density difference, we see that DSDD generally performs better than LSDD and LSDD in turn performs better than KDE. This is as expected since KDE solves a more general problem than LSDD, and LSDD solves a more general problem than DSDD. This pattern is even more pronounced on the more difficult case where the class balances are close to each other (Table 2)."}, {"heading": "5 Conclusion", "text": "The problem of unsupervised labeling of two unbalanced datasets was considered. We first showed that this problem can be solved if two unlabeled datasets having different class balances are available. The solution can be obtained by estimating of the sign of the difference between probability densities. We introduced a method to directly estimate the sign of the density difference and avoid density estimation. The method was shown on various datasets to outperform\ncompeting methods that either estimate the density difference or use the cluster structure of the data.\nBecause the sign of density difference corresponds to the Bayes optimal classifier under equal class balance, it may be estimated by any classifier that separates Xp and Xp\u2032 . Following this idea, we tested the support vector machine (SVM) for estimating the sign of density difference. However, this did not work well due to the high overlap of Xp and Xp\u2032\u2014both the datasets are mixtures of two classes, only with different mixing ratios.\nFrom this classification point of view, we can actually see that our objective function (7) corresponds to the robust SVM [12] that minimizes the ramp loss (a clipped hinge loss). Thanks to the robustness brought by the ramp loss, the overlapped datasets Xp and Xp\u2032 can be separated more reliably, and thus we obtained good estimation of the sign of density difference.\nFurthermore, this view conversely shows that the robust SVM is actually a suitable classification method because it directly estimates the Bayes optimal classifier, the sign of density difference. Labeling and classification are different problems, but one can actually give insight into the other. In the future work, we will further investigate the relation between labeling and classification."}, {"heading": "A Optimization", "text": "This section outlines the optimization of Eq. (7) using the convex concave procedure[7]. The non-convex function R(z) can be re-written as\nR(z) = C\u22121(z)\u2212 C1(z)\u2212 1, where C\u01eb(z) = max(0, z \u2212 \u01eb).\nThe convex part of the objective function can then be expressed as\nJvex(\u03b1) = 1\nn\u2032\nn\u2032\u2211\ni=1\nC\u22121\n( b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x \u2032 i)\n) + 1\nn\nn\u2211\nj=1\nC1\n( b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(xj)\n) + \u03bb\n2\nb\u2211\n\u2113=1\n\u03b12\u2113 ,\nand the concave part as\nJcave(\u03b1) = \u2212 1\nn\u2032\nn\u2032\u2211\ni=1\nC1\n( b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x \u2032 i)\n) \u2212 1\nn\nn\u2211\nj=1\nC\u22121\n( b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(xj)\n) .\nThe following self-evident relation can be used to bound the concave part\ntz \u2212 \u03d5(t) \u2264 sup y\u2208R yz \u2212 \u03d5(y)\n\u21d2 \u03d5(t) \u2265 tz \u2212 \u03d5\u2217(z),\nwhere\n\u03d5\u2217(z) = sup y\u2208R yz \u2212 \u03d5(y)\nis known as the convex conjugate. The convex conjugate of the function C\u01eb(z) is\nC\u2217\u01eb (z) =    \u221e z < 0 \u01ebz 0 \u2264 z \u2264 1\n\u221e z > 0.\nThis gives an upper bound on the concave function as\nJ\u0304cave(\u03b1, b, c) = 1\nn\u2032\nn\u2032\u2211\ni=1\n( C\u22171 (bi)\u2212 bi b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x \u2032 i)\n) + 1\nn\nn\u2211\nj=1\n( C\u2217\u22121(cj)\u2212 cj b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(xj)\n) ,\nwhere b = [b1 b2 . . . bn\u2032 ] and c = [c1 c2 . . . cn] specify the bound.\nA.1 Tightening the bound\nThe bound can be tightened around \u03b1 by minimizing Jcave(\u03b1, b, c) w.r.t. b and c. To ensure that we have a non-trivial bound, we can explicitly write the conjugate as constraints,\nJ\u0304cave(\u03b1, b, c) = 1\nn\u2032\nn\u2032\u2211\ni=1\nbi\n( 1\u2212 b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(x \u2032 i)\n) + 1\nn\nn\u2211\nj=1\ncj\n( \u22121\u2212 b\u2211\n\u2113=1\n\u03b1\u2113\u03d5\u2113(xj)\n)\ns.t. 0 \u2264 bi \u2264 1, 0 \u2264 cj \u2264 1.\nThe above optimization problem is separable in all unknowns, and the optimal value can be obtained by Eq. (8).\nA.2 Minimizing the upper bound\nThe upper bound of the objective function with b and c is\nJvex(\u03b1) + J\u0304cave(\u03b1, b, c).\nBy replacing each function C\u01eb(z) with a slack variable \u03bei, and the constraint\n\u03bei \u2265 0, \u03bei \u2265 z \u2212 \u01eb,\nwe obtain the objective function in Eq. (9)"}, {"heading": "B Least-squares estimation of the density difference", "text": "In [9] it was proposed to directly estimate the density difference by fitting a model g(x) to the true density difference f(x) under a square loss:\nargmin g\n1\n2\n\u222b ( g(x)\u2212 [p(x)\u2212 p\u2032(x)] )2 dx.\nThe density difference was modeled by a linear-in-parameter model g(x):\ng(x) =\nb\u2211\n\u2113=1\n\u03b8\u2113\u03c8\u2113(x) = \u03b8 \u22a4 \u03c8(x), (10)\nwhere b denotes the number of basis functions, \u03c8(x) = (\u03c81(x), . . . , \u03c8b(x)) \u22a4 is a b-dimensional basis function vector, \u03b8 = (\u03b81, . . . , \u03b8b) \u22a4 is a b-dimensional parameter vector, and \u22a4 denotes the transpose. A Gaussian kernel model is used to model the density difference:\ng(x) =\nn+n\u2032\u2211\n\u2113=1\n\u03b8\u2113 exp\n( \u2212 \u2016x\u2212 c\u2113\u20162\n2\u03c32\n) ,\nwhere (c1, . . . , cn, cn+1, . . . , cn+n\u2032) := (x1, . . . ,xn,x \u2032 1, . . . ,x \u2032 n\u2032) are Gaussian kernel centers. For the model in Eq. (10), the optimal parameter \u03b8\u2217 is given by\n\u03b8\u2217 := argmin \u03b8\n1\n2\n\u222b ( g(x)\u2212 [p(x)\u2212 p\u2032(x)] )2 dx\n= argmin \u03b8\n[ 1\n2\n\u222b g(x)2dx\u2212 \u222b g(x) [p(x)\u2212 p\u2032(x)] dx ]\n= argmin \u03b8\n[ 1\n2 \u03b8\u22a4H\u03b8 \u2212 h\u22a4\u03b8\n]\n=H\u22121h,\nwhere H is the b\u00d7 b matrix and h is the b-dimensional vector defined as\nH := \u222b \u03c8(x)\u03c8(x)\u22a4dx,\nh := \u222b \u03c8(x)p(x)dx\u2212 \u222b \u03c8(x)p\u2032(x)dx.\nFor the Gaussian kernel model, the integral in H can be computed analytically as\nH\u2113,\u2113\u2032 =\n\u222b exp ( \u2212 \u2016x\u2212 c\u2113\u20162\n2\u03c32\n) exp ( \u2212 \u2016x\u2212 c\u2113\u2032\u20162\n2\u03c32\n) dx\n= (\u03c0\u03c32)d/2 exp ( \u2212 \u2016c\u2113 \u2212 c\u2113\u2032\u20162\n4\u03c32\n) ,\nwhere d is the dimensionality of x. Replacing the expectations in h by empirical estimators and adding an \u21132regularizer to the objective function, we arrive at the following optimization problem:\n\u03b8\u0302 := argmin \u03b8\n[ 1\n2 \u03b8\u22a4H\u03b8 \u2212 h\u0302\n\u22a4 \u03b8 +\n1 2 \u03bb\u03b8\u22a4\u03b8\n] , (11)\nwhere \u03bb (\u2265 0) is the regularization parameter and h\u0302 is the b-dimensional vector defined as\nh\u0302 = 1\nn\nn\u2211\ni=1\n\u03c8(xi)\u2212 1\nn\u2032\nn\u2032\u2211\nj=1\n\u03c8(x\u2032j).\nTaking the derivative of the objective function in Eq.(11) and equating it to\nzero, we can obtain the solution \u03b8\u0302 analytically as\n\u03b8\u0302 = (H + \u03bbIb) \u22121 h\u0302,\nwhere Ib denotes the b-dimensional identity matrix. Finally, the density difference estimator is\nf\u0302(x) = \u03b8\u0302 \u22a4 \u03c8(x)."}], "references": [{"title": "The Nature of Statistical Learning Theory", "author": ["V. Vapnik"], "venue": "Statistics for Engineering and Information Science Series. Springer", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2000}, {"title": "Density-difference estimation", "author": ["M. Sugiyama", "T. Kanamori", "T. Suzuki", "M.C. du Plessis", "S. Liu", "I. Takeuchi"], "venue": "In Bartlett, P., Pereira, F., Burges, C., Bottou, L., Weinberger, K., eds.: Advances in Neural Information Processing Systems 25.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Density estimation for statistics and data analysis", "author": ["B. Silverman"], "venue": "Chapman and Hall, London, UK", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1986}, {"title": "Nonparametric and semiparametric models", "author": ["W. H\u00e4rdle", "M. M\u00fcller", "S. Sperlich", "A. Werwatz"], "venue": "Springer", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2004}, {"title": "On nonparametric discrimination using density differences", "author": ["P. Hall", "M.P. Wand"], "venue": "Biometrika 75(3)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1988}, {"title": "Two-sample test statistics for measuring discrepancies between two multivariate probability density functions using kernelbased density estimates", "author": ["N.H. Anderson", "P. Hall", "D. Titterington"], "venue": "Journal of Multivariate Analysis 50(1)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1994}, {"title": "The concave-convex procedure (CCCP)", "author": ["A.L. Yuille", "A. Rangarajan"], "venue": "Advances in Neural Information Processing Systems 14, MIT Press", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2002}, {"title": "DC programming: overview", "author": ["R. Horst", "N.V. Thoai"], "venue": "Journal of Optimization Theory and Applications 103(1)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1999}, {"title": "Density-difference estimation", "author": ["M. Sugiyama", "T. Kanamori", "T. Suzuki", "M.C. du Plessis", "S. Liu", "I. Takeuchi"], "venue": "Neural Computation", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Normalized cuts and image segmentation", "author": ["J. Shi", "J. Malik"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on 22(8)", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2000}, {"title": "On informationmaximization clustering: Tuning parameter selection and analytic solution", "author": ["M. Sugiyama", "M. Yamada", "M. Kimura", "H. Hachiya"], "venue": "In Getoor, L., Scheffer, T., eds.: Proceedings of 28th International Conference on Machine Learning (ICML2011), Bellevue, Washington, USA", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2011}, {"title": "Kernel Methods for Pattern Analysis", "author": ["J. Shawe-Taylor", "N. Cristianini"], "venue": "Cambridge University Press, New York, NY, USA", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}], "referenceMentions": [{"referenceID": 0, "context": "However, this naive procedure violates Vapnik\u2019s principle[1]: If you possess a restricted amount of information for solving some problem, try to solve the problem directly and never solve a more general problem as an intermediate step.", "startOffset": 57, "endOffset": 60}, {"referenceID": 1, "context": "Recently, a method was introduced to directly estimate the density difference, called the least-squares density difference (LSDD) estimator [2].", "startOffset": 140, "endOffset": 143}, {"referenceID": 2, "context": "3 Kernel Density Estimation A naive approach to estimating the sign of density-difference is to use kernel density estimators (KDEs) [3].", "startOffset": 133, "endOffset": 136}, {"referenceID": 3, "context": "The Gaussian widths \u03c3 and \u03c3 may be determined based on least-squares crossvalidation [4].", "startOffset": 85, "endOffset": 88}, {"referenceID": 4, "context": "More intuitively, good density estimators tend to be smooth and thus a densitydifference estimator obtained from such smooth density estimators tends to be over-smoothed [5,6].", "startOffset": 170, "endOffset": 175}, {"referenceID": 5, "context": "More intuitively, good density estimators tend to be smooth and thus a densitydifference estimator obtained from such smooth density estimators tends to be over-smoothed [5,6].", "startOffset": 170, "endOffset": 175}, {"referenceID": 1, "context": "The density difference can be estimated in a single shot using the least-squares density difference (LSDD) approach [2].", "startOffset": 116, "endOffset": 119}, {"referenceID": 6, "context": "Although the above is a non-convex problem, we can efficiently find a local optimal solution using the convex-concave procedure (CCCP) [7] (also known as difference of convex (d.", "startOffset": 135, "endOffset": 138}, {"referenceID": 7, "context": ") programming [8]).", "startOffset": 14, "endOffset": 17}, {"referenceID": 2, "context": "p(x|y = 1) = 1 2 Nx([3 0] \u22a4 , I2\u00d72) + 1 2 Nx([\u22123 0] \u22a4 , I2\u00d72) p(x|y = \u22121) = 1 2 Nx([0 3] \u22a4 , I2\u00d72) + 1 2 Nx([0 \u2212 3] \u22a4 , I2\u00d72).", "startOffset": 20, "endOffset": 25}, {"referenceID": 2, "context": "p(x|y = 1) = 1 2 Nx([3 0] \u22a4 , I2\u00d72) + 1 2 Nx([\u22123 0] \u22a4 , I2\u00d72) p(x|y = \u22121) = 1 2 Nx([0 3] \u22a4 , I2\u00d72) + 1 2 Nx([0 \u2212 3] \u22a4 , I2\u00d72).", "startOffset": 83, "endOffset": 88}, {"referenceID": 8, "context": "\u2013 Least-Squares Density Difference (LSDD) Estimation: Estimate sign [p(x)\u2212 p(x)] by estimating p(x)\u2212 p(x) using the least squares fitting method [9].", "startOffset": 145, "endOffset": 148}, {"referenceID": 9, "context": "\u2013 Spectral Clustering (SC): Cluster the data into two clusters using the spectral clustering algorithm [10].", "startOffset": 103, "endOffset": 107}, {"referenceID": 10, "context": "\u2013 Squared-loss Mutual Information based Clustering (SMIC) : Cluster the data according to the SMIC method [11].", "startOffset": 106, "endOffset": 110}], "year": 2013, "abstractText": "We consider the unsupervised learning problem of assigning labels to unlabeled data. A naive approach is to use clustering methods, but this works well only when data is properly clustered and each cluster corresponds to an underlying class. In this paper, we first show that this unsupervised labeling problem in balanced binary cases can be solved if two unlabeled datasets having different class balances are available. More specifically, estimation of the sign of the difference between probability densities of two unlabeled datasets gives the solution. We then introduce a new method to directly estimate the sign of the density difference without density estimation. Finally, we demonstrate the usefulness of the proposed method against several clustering methods on various toy problems and real-world datasets.", "creator": "LaTeX with hyperref package"}}}