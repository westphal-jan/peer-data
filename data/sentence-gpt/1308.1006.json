{"id": "1308.1006", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Aug-2013", "title": "Fast Semidifferential-based Submodular Function Optimization", "abstract": "We present a practical and powerful new framework for both unconstrained and constrained submodular function optimization based on discrete semidifferentials (sub- and super-differentials). The resulting algorithms, which repeatedly compute and then efficiently optimize submodular semigradients, offer new and generalize many old methods for submodular optimization. Our approach, moreover, takes steps towards providing a unifying paradigm applicable to both submodular min- imization and maximization, problems that historically have been treated quite distinctly by the submodular submodular and its submodular modular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular submodular", "histories": [["v1", "Mon, 5 Aug 2013 15:19:48 GMT  (221kb,D)", "http://arxiv.org/abs/1308.1006v1", "This work appeared in Proc. International Conference of Machine Learning (ICML, 2013)"]], "COMMENTS": "This work appeared in Proc. International Conference of Machine Learning (ICML, 2013)", "reviews": [], "SUBJECTS": "cs.DS cs.DM cs.LG", "authors": ["rishabh k iyer", "stefanie jegelka", "jeff a bilmes"], "accepted": true, "id": "1308.1006"}, "pdf": {"name": "1308.1006.pdf", "metadata": {"source": "CRF", "title": "Fast Semidifferential-based Submodular Function Optimization", "authors": ["Rishabh Iyer", "Stefanie Jegelka", "Jeff Bilmes"], "emails": ["rkiyer@u.washington.edu", "stefje@eecs.berkeley.edu", "bilmes@u.washington.edu"], "sections": [{"heading": "1 Introduction", "text": "In this paper, we address minimization and maximization problems of the following form:\nProblem 1: min X\u2208C f(X), Problem 2: max X\u2208C f(X)\nwhere f : 2V \u2192 R is a discrete set function on subsets of a ground set V = {1, 2, \u00b7 \u00b7 \u00b7 , n}, and C \u2286 2V is a family of feasible solution sets. The set C could express, for example, that solutions must be an independent set in a matroid, a limited budget knapsack, or a cut (or spanning tree, path, or matching) in a graph. Without making any further assumptions about f , the above problems are trivially worst-case exponential time and moreover inapproximable.\nIf we assume that f is submodular, however, then in many cases the above problems can be approximated and in some cases solved exactly in polynomial time. A function f : 2V \u2192 R is said to be submodular [9] if for all subsets S, T \u2286 V , it holds that f(S) + f(T ) \u2265 f(S \u222a T ) + f(S \u2229 T ). Defining f(j|S) , f(S \u222a j)\u2212 f(S) as the gain of j \u2208 V with respect to S \u2286 V , then f is submodular if and only if f(j|S) \u2265 f(j|T ) for all S \u2286 T and j /\u2208 T . Traditionally, submodularity has been a key structural property for problems in combinatorial optimization, and for applications in econometrics, circuit and game theory, and operations research. More recently, submodularity\u2019s popularity in machine learning has been on the rise.\nOn the other hand, a potential stumbling block is that machine learning problems are often large (e.g., \u201cbig data\u201d) and are getting larger. For general unconstrained submodular minimization, the computational\n\u2217A shorter version of this appeared in Proc. International Conference of Machine Learning (ICML), Atlanta, 2013 \u2020rkiyer@u.washington.edu \u2021stefje@eecs.berkeley.edu \u00a7bilmes@u.washington.edu\nar X\niv :1\n30 8.\n10 06\nv1 [\ncs .D\nS] 5\nA ug\ncomplexity often scales as a high-order polynomial. These algorithms are designed to solve the most general case and the worst-case instances are often contrived and unrealistic. Typical-case instances are much more benign, so simpler algorithms (e.g., graph-cut) might suffice. In the constrained case, however, the problems often become NP-complete. Algorithms for submodular maximization are very different in nature from their submodular minimization cohorts, and their complexity too varies depending on the problem. In any case, there is an urgent need for efficient, practical, and scalable algorithms for the aforementioned problems if submodularity is to have a lasting impact on the field of machine learning.\nIn this paper, we address the issue of scalability and simultaneously draw connections across the apparent gap between minimization and maximization problems. We demonstrate that many algorithms for submodular maximization may be viewed as special cases of a generic minorize-maximize framework that relies on discrete semidifferentials. This framework encompasses state-of-the-art greedy and local search techniques, and provides a rich class of very practical algorithms. In addition, we show that any approximate submodular maximization algorithm can be seen as an instance of our framework.\nWe also present a complementary majorize-minimize framework for submodular minimization that makes two contributions. For unconstrained minimization, we obtain new nontrivial bounds on the lattice of minimizers, thereby reducing the possible space of candidate minimizers. This method easily integrates into any other exact minimization algorithm as a preprocessing step to reduce running time. In the constrained case, we obtain practical algorithms with bounded approximation factors. We observe these algorithms to be empirically competitive to more complicated ones.\nAs a whole, the semidifferential framework offers a new unifying perspective and basis for treating submodular minimization and maximization problems in both the constrained and unconstrained case. While it has long been known [9] that submodular functions have tight subdifferentials, our results rely on a recently discovered property [18, 22] showing that submodular functions also have superdifferentials. Furthermore, our approach is entirely combinatorial, thus complementing (and sometimes obviating) related relaxation methods."}, {"heading": "2 Motivation and Background", "text": "Submodularity\u2019s escalating popularity in machine learning is due to its natural applicability. Indeed, instances of Problems 1 and 2 are seen in many forms, to wit:\nMAP inference/Image segmentation: Markov Random Fields with pairwise attractive potentials are important in computer vision, where MAP inference is identical to unconstrained submodular minimization solved via minimum cut [3]. A richer higher-order model can be induced for which MAP inference corresponds to Problem 1 where V is a set of edges in a graph, and C is a set of cuts in this graph \u2014 this was shown to significantly improve many image segmentation results [22]. Moreover, [6] efficiently solve MAP inference in a sparse higher-order graphical model by restating the problem as a submodular vertex cover, i.e., Problem 1 where C is the set of all vertex covers in a graph.\nClustering: Variants of submodular minimization have been successfully applied to clustering problems [38, 36].\nLimited Vocabulary Speech Corpora: The problem of finding a maximum size speech corpus with bounded vocabulary [32] can be posed as submodular function minimization subject to a size constraint. Alternatively, cardinality can be treated as a penalty, reducing the problem to unconstrained submodular minimization [23].\nSize constraints: The densest k-subgraph and size-constrained graph cut problems correspond to submodular minimization with cardinality constraints, problems that are very hard [44]. Specialized algorithms for cardinality and related constraints were proposed e.g. in [44, 35].\nMinimum Power Assignment: In wireless networks, one seeks a connectivity structure that maintains connectivity at a minimum energy consumption. This problem is equivalent to finding a suitable structure (e.g., a spanning tree) minimizing a submodular cost function [45].\nTransportation: Costs in real-world transportation problems are often non-additive. For example, it may be cheaper to take a longer route owned by one carrier rather than a shorter route that switches carriers. Such economies of scale, or \u201cright of usage\u201d properties are captured in the \u201cCategorized Bottleneck Path Problem\u201d \u2013 a shortest path problem with submodular costs [1]. Similar costs have been considered for spanning tree and matching problems.\nSummarization/Sensor placement: Submodular maximization also arises in many subset extraction problems. Sensor placement [25], document summarization [31] and speech data subset selection [29], for example, are instances of submodular maximization.\nDeterminantal Point Processes: The Determinantal Point Processes (DPPs) which have found numerous applications in machine learning [26] are known to be log-submodular distributions. In particular, the MAP inference problem is a form of non-monotone submodular maximization.\nIndeed, there is strong motivation for solving Problems 1 and 2 but, as mentioned above, these problems come not without computational difficulties. Much work has therefore been devoted to developing optimal or near optimal algorithms. Among the several algorithms [33] for the unconstrained variant of Problem 1, where C = 2V , the best complexity to date is O(n5\u03b3 + n6) [40] (\u03b3 is the cost of evaluating f). This has motivated studies on faster, possibly special case or approximate, methods [42, 23]. Constrained minimization problems, even for simple constraints such as a cardinality lower bound, are mostly NP-hard, and not approximable to within better than a polynomial factor. Approximation algorithms for these problems with various techniques have been studied in [44, 16, 12, 21]. Unlike submodular minimization, all forms of submodular maximization are NP-hard. Most such problems, however, admit constant-factor approximations, which are attained via very simple combinatorial algorithms [39, 4].\nMajorization-minimization (MM)1 algorithms are known to be useful in machine learning [15]. Notable examples include the EM algorithm [34] and the convex-concave procedure [46]. Discrete instances have been used to minimize the difference between submodular functions [37, 17], but these algorithms generally lack theoretical guarantees. This paper shows, by contrast, that for submodular optimization, MM algorithms have strong theoretical properties and empirically work very well."}, {"heading": "3 Submodular semi-differentials", "text": "We first briefly introduce submodular semidifferentials. Throughout this paper, we assume normalized submodular functions (i.e., f(\u2205) = 0). The subdifferential \u2202f (Y ) of a submodular set function f : 2V \u2192 R for a set Y \u2286 V is defined [9] analogously to the subdifferential of a continuous convex function:\n\u2202f (Y ) = {y \u2208 Rn : (1) f(X)\u2212 y(X) \u2265 f(Y )\u2212 y(Y ) for all X \u2286 V }\nFor a vector x \u2208 RV and X \u2286 V , we write x(X) = \u2211 j\u2208X x(j) \u2014 in such case, we say that x is a normalized modular function. We shall denote a subgradient at Y by hY \u2208 \u2202f (Y ). The extreme points of \u2202f (Y ) may be computed via a greedy algorithm: Let \u03c3 be a permutation of V that assigns the elements in Y to the first |Y | positions (\u03c3(i) \u2208 Y if and only if i \u2264 |Y |). Each such permutation defines a chain with elements S\u03c30 = \u2205,\n1MM also refers to minorization-maximization here.\nS\u03c3i = {\u03c3(1), \u03c3(2), . . . , \u03c3(i)} and S\u03c3|Y | = Y . This chain defines an extreme point h \u03c3 Y of \u2202f (Y ) with entries\nh\u03c3Y (\u03c3(i)) = f(S \u03c3 i )\u2212 f(S\u03c3i\u22121). (2)\nSurprisingly, we can also define superdifferentials \u2202f (Y ) of a submodular function [22, 18] at Y :\n\u2202f (Y ) = {y \u2208 Rn : (3) f(X)\u2212 y(X) \u2264 f(Y )\u2212 y(Y ); for all X \u2286 V }\nWe denote a generic supergradient at Y by gY . It is easy to show that the polyhedron \u2202 f is non-empty. We define three special supergradients g\u0302Y (\u201cgrow\u201d), g\u030cY (\u201cshrink\u201d) and g\u0304Y as follows [18]:\ng\u0302Y (j) = f(j | V \\ {j}) g\u0302Y (j) = f(j | Y ) g\u030cY (j) = f(j | Y \\ {j}) g\u030cY (j) = f(j | \u2205) g\u0304Y (j) = f(j | V \\ {j})\ufe38 \ufe37\ufe37 \ufe38 g\u0304Y (j) = f(j | \u2205)\ufe38 \ufe37\ufe37 \ufe38\nfor j \u2208 Y for j /\u2208 Y.\nFor a monotone submodular function, i.e., a function satisfying f(A) \u2264 f(B) for all A \u2286 B \u2286 V , the suband supergradients defined here are nonnegative."}, {"heading": "4 The discrete MM framework", "text": "With the above semigradients, we can define a generic MM algorithm. In each iteration, the algorithm optimizes a modular approximation formed via the current solution Y . For minimization, we use an upper bound\nmgY (X) = f(Y ) + gY (X)\u2212 gY (Y ) \u2265 f(X), (4)\nand for maximization a lower bound\nmhY (X) = f(Y ) + hY (X)\u2212 hY (Y ) \u2264 f(X). (5)\nBoth these bounds are tight at the current solution, satisfying mgY (Y ) = mhY (Y ) = f(Y ). In almost all cases, optimizing the modular approximation is much faster than optimizing the original cost function f .\nAlgorithm 1 shows our discrete MM scheme for maximization (MMax) [and minimization (MMin)] , and for both constrained and unconstrained settings. Since we are minimizing a tight upper bound, or maximizing a tight lower bound, the algorithm must make progress.\nLemma 4.1. Algorithm 1 monotonically improves the objective function value for Problems 1 and 2 at every iteration, as long as a linear function can be exactly optimized over C.\nAlgorithm 1: Semigradient Descent Algorithm\n1: Start with an arbitrary X0. 2: repeat 3: Pick a semigradient hXt [ gXt ] at X t 4: Xt+1 := argmaxX\u2208CmhXt (X) [ Xt+1 := argminX\u2208Cm\ngXt (X)] 5: t\u2190 t+ 1 6: until we have converged (Xi\u22121 = Xi)\nProof. By definition, it holds that f(Xt+1) \u2264 mgXt (Xt+1). Since Xt+1 minimizes mgXt , it follows that\nf(Xt+1) \u2264 mgXt (Xt+1) \u2264 mgXt (Xt) = f(Xt). (6)\nThe observation that Algorithm 1 monotonically increases the objective of maximization problems follows analogously.\nContrary to standard continuous subgradient descent schemes, Algorithm 1 produces a feasible solution at each iteration, thereby circumventing any rounding or projection steps that might be challenging under certain types of constraints. In addition, it is known that for relaxed instances of our problems, subgradient descent methods can suffer from slow convergence [2]. Nevertheless, Algorithm 1 still relies on the choice of the semigradients defining the bounds. Therefore, we next analyze the effect of certain choices of semigradients."}, {"heading": "5 Submodular function minimization", "text": "For minimization problems, we use MMin with the supergradients g\u0302X , g\u030cX and g\u0304X . In both the unconstrained and constrained settings, this yields a number of new approaches to submodular minimization."}, {"heading": "5.1 Unconstrained Submodular Minimization", "text": "We begin with unconstrained minimization, where C = 2V in Problem 1. Each of the three supergradients yields a different variant of Algorithm 1, and we will call the resulting algorithms MMin-I, II and III, respectively. We make one more assumption: of the minimizing arguments in Step 4 of Algorithm 1, we always choose a set of minimum cardinality.\nMMin-I is very similar to the algorithms proposed in [23]. Those authors, however, decompose f and explicitly represent graph-representable parts of the function f . We do not require or consider such a restriction here.\nLet us define the sets A = {j : f(j|\u2205) < 0} and B = {j : f(j|V \\ {j}) \u2264 0}. Submodularity implies that A \u2286 B, and this allows us to define a lattice2 L = [A,B] whose least element is the set A and whose greatest element is the set is B. This sublattice L of [\u2205, V ] retains all minimizers X\u2217 (i.e., A \u2286 X\u2217 \u2286 B for all X\u2217):\nLemma 5.1. [9] Let L\u2217 be the lattice of the global minimizers of a submodular function f . Then L\u2217 \u2286 L, where we use \u2286 to denote a sublattice.\nLemma 5.1 has been used to prune down the search space of the minimum norm point algorithm from the power set of V to a smaller lattice [2, 10]. Indeed, A and B may be obtained by using MMin-III:\nLemma 5.2. With X0 = \u2205 and X0 = V , MMin-III returns the sets A and B, respectively. Initialized by an arbitrary X0, MMin-III converges to (X0 \u2229B) \u222aA.\n2This lattice contains all sets S satisfying A \u2286 S \u2286 B\nProof. When using X0 = \u2205, we obtain X1 = argminX f(\u2205) + \u2211 j\u2208X f(j) = A. Since A \u2286 B, the algorithm will converge to X1 = A. At this point, no more elements will be added, since for all i /\u2208 A we have g\u0304X1(i) = f(i | \u2205) > 0. Moreover, the algorithm will not remove any elements: for all i \u2208 A, it holds that g\u0304X1(i) = f(i | V \\ i) \u2264 f(i) \u2264 0. By a similar argumentation, the initialization X0 = V will lead to X1 = B, where the algorithm terminates. If we start with any arbitrary X0, MMin-III will remove the elements j with f(j|V \\ j) > 0 and add the element j with f(j|\u2205) < 0. Hence it will add the elements in A that are not in X0 and remove those element from X0 that are not in B. Let the resulting set be X1. As before, for all i \u2208 A, it holds that g\u0304X1(i) = f(i | V \\ i) \u2264 f(i) \u2264 0, so these elements will not be removed in any possible subsequent iteration. The elements i \u2208 X1 \\A were not removed, so f(i | V \\ i) \u2264 0. Hence, no more elements will be removed after the first iteration. Similarly, no elements will be added since for all i /\u2208 X1, it holds that f(i | \u2205) \u2265 f(i | V \\ i) > 0.\nLemma 5.2 implies that MMin-III effectively provides a contraction of the initial lattice to L, and, if X0 is not in L, it returns a set in L. Henceforth, we therefore assume that we start with a set X0 \u2208 L.\nWhile the known lattice L has proven useful for warm-starts, MMin-I and II enable us to prune L even further. Let A+ be the set obtained by starting MMin-I at X\n0 = \u2205, and B+ be the set obtained by starting MMin-II at X0 = V . This yields a new, smaller sublattice L+ = [A+, B+] that retains all minimizers:\nTheorem 5.3. For any minimizer X\u2217 \u2208 L, it holds that A \u2286 A+ \u2286 X\u2217 \u2286 B+ \u2286 B. Hence L\u2217 \u2286 L+ \u2286 L. Furthermore, when initialized with X0 = \u2205 and X0 = V , respectively, both MMin-I and II converge in O(n) iterations to a local minimum of f .\nBy a local minimum, we mean a set X that satisfies f(X) \u2264 f(Y ) for any set Y that differs from X by a single element. We point out that Theorem 5.3 generalizes part of Lemma 3 in [23]. For the proof, we build on the following Lemma:\nLemma 5.4. Every iteration of MMin-I can be written as Xt+1 = Xt \u222a {j : f(j|Xt) < 0}. Similarly, every iteration of MMin-II can be expressed as Xt+1 = Xt\\{j : f(j|Xt \\ j) > 0}.\nProof. (Lemma 5.4) Throughout this paper, we assume that we select only the minimal minimizer of the modular function at every step. In other words, we do not choose the elements that have zero marginal cost. We observe that in iteration t+ 1 of MMin-I, we add the elements i with g\u0302Xt(i) < 0, i.e., X\nt+1 = Xt \u222a {j : f(j|Xt) < 0}. No element will ever be removed, since g\u0302Xt(i) = f(i | V \\ i) \u2264 f(i | Xt\u22121) \u2264 0. If we start with X0 = \u2205, then after the first iteration, it holds that X1 = argminX f(\u2205) + \u2211 j\u2208X f(j). Hence X\n1 = A. MMin-I terminates when reaching a set A+, where f(j|A+) \u2265 0, for all j /\u2208 A+.\nThe analysis of MMin-II is analogous. In iteration t+ 1, we remove the elements i with g\u030cXt(i) > 0, i.e., Xt+1 = Xt\\{j : f(j|Xt \u2212 j) > 0}. Similarly to the argumentation above, MMin-II never adds any elements. If we begin with X0 = V , then X1 = arg minXf(V )+ \u2211 j\u2208V \\X f(j|V \u2212{j}), and therefore X1 = B. MMin-II terminates with a set B+.\nNow we can prove Theorem 5.3.\nProof. (Thm. 5.3) Since, by Lemma 5.4, MMin-I only adds elements and MMin-II only removes elements, at least one in each iteration, both algorithms terminate after O(n) iterations.\nLet us now turn to the relation of X\u2217 to A and B. Since f(i) < 0 for all i \u2208 A, the set X1 = A found in the first iteration of MMin-I must be a subset of X\u2217. Consider any subset Xt \u2286 X\u2217. Any element j for which f(j | Xt) < 0 must be in X\u2217 as well, because by submodularity, f(j | X\u2217) \u2264 f(j | Xt) < 0. This means f(X\u2217 \u222a j) < f(X\u2217), which would otherwise contradict the optimality of X\u2217. The set of such j is exactly Xt+1, and therefore Xt+1 \u2286 X\u2217. This induction shows that MMin-I, whose first solution is A \u2286 X\u2217, always returns a subset of X\u2217. Analogously, B \u2287 X\u2217, and MMin-II only removes elements j /\u2208 X\u2217.\nFinally, we argue that A+ is a local minimum; the proof for B+ is analogous. Algorithm MMin-I generates a chain \u2205 = X0 \u2286 X1 \u2286 X2 \u00b7 \u00b7 \u00b7 \u2286 A+ = XT . For any t \u2264 T , consider j \u2208 Xt \\Xt\u22121. Submodularity implies that f(j|A+ \\ j) \u2264 f(j|Xt\u22121) < 0. The last inequality follows from the fact that j was added in iteration t. Therefore, removing any j \u2208 A+ will increase the cost. Regarding the elements i /\u2208 A+, we observe that MMin-I has terminated, which implies that f(i | A+) \u2265 0. Hence, adding i to A+ will not improve the solution, and A+ is a local minimum.\nTheorem 5.3 has a number of nice implications. First, it provides a tighter bound on the lattice of minimizers of the submodular function f that, to the best of our knowledge, has not been used or mentioned before. The sets A+ and B+ obtained above are guaranteed to be supersets and subsets of A and B, respectively, as illustrated in Figure 2. This means we can start any algorithm for submodular minimization from the lattice L+ instead of the initial lattice 2V or L. When using an algorithm whose running time is a high-order polynomial of |V |, any reduction of the ground set V is beneficial. Second, each iteration of MMin takes linear time. Therefore, its total running time is O(n2). Third, Theorem 5.3 states that both MMin-I and II converge to a local minimum. This may be counter-intuitive if one considers that each algorithm either only adds or only removes elements. In consequence, a local minimum of a submodular function can be obtained in O(n2), a fact that is of independent interest and that does not hold for local maximizers [8].\nThe following example illustrates that L+ can be a strict subset of L and therefore provides non-trivial pruning. Let w1, w2 \u2208 RV , w1 \u2265 0 be two vectors, each defining a linear (modular) function. Then the function f(X) = \u221a w1(X) + w2(X) is submodular. Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128]. Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10]. The tightened sublattice contains exactly the minimizer: A+ = B+ = X\n\u2217 = [1, 6, 7, 8, 10]. As a refinement to Theorem 5.3, we can show that MMin-I and MMin-II converge to the local minima of\nlowest and highest cardinality, respectively.\nLemma 5.5. The set A+ is the smallest local minimum of f (by cardinality), and B+ is the largest. Moreover, every local minimum Z is in L+: Z \u2208 L+ for every local minimum Z.\nProof. The proof proceeds analogously to the proof of Theorem 5.3. Let Ys be the local minimum of smallest-cardinality, and Y` the largest one. First, we note that X\n0 = \u2205 \u2286 Ys. For induction, assume that Xt \u2286 Ys. For contradiction, assume there is an element j \u2208 Xt+1 that is not in Ys. Since j \u2208 Xt+1 \\Xt, it holds by construction that f(j | Ys) \u2264 f(j | Xt) < 0, implying that f(Ys \u222a j) < f(Ys). This contradicts the local optimality of Ys, and therefore it must hold that X\nt+1 \u2286 Ys. Consequently, A+ \u2286 Ys. But A+ is itself a local minimum, and hence equality holds. The result for B+ follows analogously.\nBy the same argumentation as above for Ys and Y`, we conclude that each local minimum Z satisfies A+ \u2286 Z \u2286 B+, and therefore Z \u2208 L+ \u2286 L.\nAs a corollary, Lemma 5.5 implies that if a submodular function has a unique local minimum, MMin-I and II must find this minimum, which is a global one.\nIn the following we consider two extensions of MMin-I and II. First, we analyze an algorithm that alternates between MMin-I and MMin-II. While such an algorithm does not provide much benefit when started at X0 = \u2205 or X0 = V , we see that with a random initialization X0 = R, the alternation ensures convergence to a local minimum. Second, we address the question of which supergradients to select in general.\nIn particular, we show that the supergradients g\u0302 and g\u030c subsume alternativee supergradients and provide the tightest results with MMin. Hence, our results are the tight.\nAlternating MMin-I and II and arbitrary initializations. Instead of running only one of MMin-I and II, we can run one until it stops and then switch to the other. Assume we initialize both algorithms with a random set X0 = R \u2208 L+. By Theorem 5.3, we know that MMin-I will return a subset R1 \u2283 R (no element will be removed because all removable elements are not in B, and R \u2282 B by assumption). When MMin-I terminates, it holds that g\u0302R1(j) = f(j|R1) \u2265 0 for all j /\u2208 R1, and therefore R1 cannot be increased using g\u0302R1 . We will call such a set an I-minimum. Similarly, MMin-II returns a set R1 \u2286 R from which, considering that g\u030cR1(j) = f(j|R1 \\ j) \u2264 0 for all j \u2208 R1, no elements can be removed. We call such a non-decreasable set a D-minimum. Every local minimum is both an I-minimum and a D-minimum.\nWe can apply MMin-II to the I-minimum R1 returned by MMin-I. Let us call the resulting set R2. Analogously, applying MMin-I to R1 yields R2 \u2287 R1.\nLemma 5.6. The sets R2 and R 2 are local optima. Furthermore, R1 \u2286 R2 \u2286 R2 \u2286 R1.\nProof. It is easy to see that A \u2286 R1 \u2286 B, and A \u2286 R1 \u2286 B. By Lemma 5.4, MMin-I applied to R1 will only add elements, and MMin-II on R1 will only remove elements. Since R1 is an I-minimum, adding an element j \u2208 V \\R1 to any set X \u2282 R1 never helps, and therefore R1 contains all of R1, R2 and R2. Similarly, R1 is contained in R2, R 2 and R1. In consequence, it suffices to look at the contracted lattice [R1, R 1], and any local minimum in this sublattice is a local minimum on [\u2205, V ]. Theorem 5.3 applied to the sublattice [R1, R1] (and the submodular function restricted to the sublattice) yields the inclusion R2 \u2286 R2, so R1 \u2286 R2 \u2286 R2 \u2286 R1, and both R2 and R 2 are local minima.\nThe following lemma provides a more general view.\nLemma 5.7. Let S1 \u2286 S1 be such that S1 is an I-minimum and S1 is a D-minimum. Then there exist local minima S2 \u2286 S2 in [S1, S1] such that initializing with any X0 \u2208 [S1, S1], an alternation of MMin-I and II converges to a local minimum in [S2, S 2], and\nmin X\u2208[S1,S1] f(X) = min X\u2208[S2,S2] f(X). (7)\nProof. Let S2, S 2 be the smallest and largest local minima within [S1, S 1]. By the same argumentation as for Lemma 5.6, using X0 \u2208 [S1, S1] leads to a local minimum within [S2, S2]. Since by definition all local optima in [S1, S 1] are within [S2, S 2], the global minimum within [S1, S 1] will also be in [S2, S 2].\nThe above lemmas have a number of implications for minimization algorithms. First, many of the properties for initializing with V or the empty set can be transferred to arbitrary initializations. In particular, the succession of MMin-I and II will terminate in O(n2) iterations, regardless of what X0 is. Second, Lemmas 5.6 and 5.7 provide useful pruning opportunities: we can prune down the initial lattice to [R2, R\n2] or [S2, S 2], respectively. In particular, if any global optimizer of f is contained in [S1, S 1], it will also be contained in [S2, S 2].\nChoice of supergradients. We close this section with a remark about the choice of supergradients. The following Lemma states how g\u0302X and g\u030cX subsume alternative choices of supergradients and MMin-I and II lead to the tightest results possible.\nLemma 5.8. Initialized with X0 = \u2205, Algorithm 1 will converge to a subset of A+ with any choice of supergradients. Initialized with X0 = V , the algorithm will converge to a superset of B+ with any choice of supergradients. If X0 is a local minimum, then the algorithm will not move with any supergradient.\nThe proof of Lemma 5.8 is very similar to the proof of Theorem 5.3."}, {"heading": "5.2 Constrained submodular minimization", "text": "MMin straightforwardly generalizes to constraints more complex than C = 2V , and Theorem 5.3 still holds for more general lattices or ring family constraints.\nBeyond lattices, MMin applies to any set of constraints C as long as we have an efficient algorithm at hand that minimizes a nonnegative modular cost function over C. This subroutine can even be approximate. Such algorithms are available for cardinality bounds, independent sets of a matroid and many other combinatorial constraints such as trees, paths or cuts.\nAs opposed to unconstrained submodular minimization, almost all cases of constrained submodular minimization are very hard [44, 21, 12], and admit at most approximate solutions in polynomial time. The next theorem states an upper bound on the approximation factor achieved by MMin-I for nonnegative, nondecreasing cost functions. An important ingredient in the bound is the curvature [5] of a monotone submodular function f , defined as\n\u03baf = 1\u2212minj\u2208V f(j | V \\j) / f(j) (8)\nTheorem 5.9. Let X\u2217 \u2208 argminX\u2208C f(X). The solution X\u0302 returned by MMin-I satisfies\nf(X\u0302) \u2264 |X \u2217|\n1 + (|X\u2217| \u2212 1)(1\u2212 \u03baf ) f(X\u2217) \u2264 1 1\u2212 \u03baf f(X\u2217)"}, {"heading": "If the minimization in Step 4 is done with approximation factor \u03b2, then f(X\u0302) \u2264 \u03b2/(1\u2212 \u03baf )f(X\u2217).", "text": "Before proving this result, we remark that a similar, slightly looser bound was shown for cuts in [22], by using a weaker notion of curvature. Note that the bound in Theorem 5.9 is at most n1+(n\u22121)(1\u2212\u03baf ) , where n = |V | is the dimension of the problem.\nProof. We will use the shorthand g , g\u0302\u2205. To prove Theorem 5.9, we use the following result shown in [20]:\nf(X\u0302) \u2264 g(X \u2217)/f(i)\n1 + (1\u2212 \u03baf )(g(X\u2217)/f(i)\u2212 1) f(X\u2217) (9)\nfor any i \u2208 V . We now transfer this result to curvature. To do so, we use i\u2032 \u2208 arg maxi\u2208V f(i), so that g(X\u2217) = \u2211 j\u2208X\u2217 f(j) \u2264 |X\u2217|f(i\u2032). Observing that the function p(x) = x 1+(1\u2212\u03baf )(x\u22121) is increasing in x yields that\nf(X\u0302) \u2264 |X \u2217|\n1 + (1\u2212 \u03baf )(|X\u2217| \u2212 1) f(X\u2217). (10)\nFor problems where \u03baf < 1, Theorem 5.9 yields a constant approximation factor and refines bounds for constrained minimization that are given in [12, 44]. To our knowledge, this is the first curvature dependent bound for this general class of minimization problems.\nA class of functions with \u03baf = 1 are matroid rank functions, implying that these functions are difficult instances the MMin algorithms. But several classes of functions occurring in applications have more benign curvature. For example, concave over modular functions were used in [31, 22]. These comprise, for instance, functions of the form f(X) = (w(X))a, for some a \u2208 [0, 1] and a nonnegative weight vector w, whose curvature is \u03baf \u2248 1\u2212 a(minj w(j)w(V ) )\n1\u2212a > 0. A special case is f(X) = |X|a, with curvature \u03baf = 1\u2212 ana\u22121, or f(X) = log(1 + w(X)) satisfying \u03baf \u2248 1\u2212 minj w(j)w(V ) .\nThe bounds of Theorem 5.9 hold after the first iteration. Nevertheless, empirically we often found that for problem instances that are not worst-case, subsequent iterations can improve the solution substantially. Using Theorem 5.9, we can bound the number of iterations the algorithm will take. To do so, we assume an \u03b7-approximate version, where we proceed only if f(Xt+1) \u2264 (1\u2212 \u03b7)f(Xt) for some \u03b7 > 0. In practice, the algorithm usually terminates after 5 to 10 iterations for an arbitrarily small \u03b7.\nLemma 5.10. MMin-I runs in O( 1\u03b7T log n 1+(n\u22121)(1\u2212\u03baf ) ) time, where T is the time for minimizing a modular function subject to X \u2208 C.\nProof. At the end of the first iteration, we obtain a set X1 such that f(X1) \u2264 n1+(n\u22121)(1\u2212\u03baf )f(X \u2217). The \u03b7-approximate assumption implies that f(Xt+1) \u2264 (1\u2212\u03b7)f(Xt) \u2264 (1\u2212\u03b7)tf(X1). Using that log(1\u2212\u03b7) \u2264 \u03b7\u22121 and Theorem 5.9, we see that the algorithm terminates after at most O( 1\u03b7 log n 1+(n\u22121)(1\u2212\u03baf ) ) iterations."}, {"heading": "5.3 Experiments", "text": "We will next see that, apart from its theoretical properties, MMin is in practice competitive to more complex algorithms. We implement and compare algorithms using Matlab and the SFO toolbox [24].\nUnconstrained minimization We first study the results in Section 5.1 for contracting the lattice of possible minimizers. We measure the size of the new lattices relative to the ground set. Applying MMin-I and II (lattice L+) to Iwata\u2019s test function [10], we observe an average reduction of 99.5% in the lattice. MMin-III (lattice L) obtains only about 60% reduction. Averages are taken for n between 20 and 120.\nIn addition, we use concave over modular functions \u221a w1(X) + \u03bbw2(V \\X) with randomly chosen vectors w1, w2 in [0, 1] n and n = 50. We also consider the application of selecting limited vocabulary speech corpora.\n[32, 23] use functions of the form \u221a w1(\u0393(X)) + w2(V \\X), where \u0393(X) is the neighborhood function of a bipartite graph. Here, we choose n = 100 and random vectors w1 and w2. For both function classes, we vary \u03bb such that the optimal solution X\u2217 moves from X\u2217 = \u2205 to X\u2217 = V . The results are shown in Figure 3. In both cases, we observe a significant reduction of the search space. When used as a preprocessing step for the minimum norm point algorithm (MN) [10], this pruned lattice speeds up the MN algorithm accordingly, in particular for the speech data. The dotted lines represent the relative time of MN including the respective preprocessing, taken with respect to MN without preprocessing. Figure 3 also shows the average results over 10 random choices of weights in both cases. In order to obtain accurate estimates of the timings, we run each experiment 5 times and take the minimum of these timing valuess.\nConstrained minimization. For constrained minimization, we compare MMin-I to two methods: a simple algorithm (MU) that minimizes the upper bound g(X) = \u2211 i\u2208X f(i) [12] (this is identical to the first iteration of MMin-I), and a more complex algorithm (EA) that computes an approximation to the submodular polyhedron [13] and in many cases yields a theoretically optimal approximation. MU has the theoretical bounds of Theorem 5.9, while EA achieves a worst-case approximation factor of O( \u221a n log n). We show two experiments: the theoretical worst-case and average-case instances. Figure 4 illustrates the results.\nWorst case. We use a very hard cost function [13]\nf(X) = min{|X|, |X \u2229 R\u0304|+ \u03b2, \u03b1}, (11)\nwhere \u03b1 = n1/2+ and \u03b2 = n2 , and R is a random set such that |R| = \u03b1. This function is the theoretical worst case. Figure 4 shows results for cardinality lower bound constraints; the results for other, more complex constraints are similar. As shrinks, the problem becomes harder. In this case, EA and MMin-I achieve about the same empirical approximation factors, which matches the theoretical guarantee of n1/2\u2212 .\nAverage case. We next compare the algorithms on more realistic functions that occur in applications. Figure 4 shows the empirical approximation factors for minimum submodular-cost spanning tree, bipartite matching, and shortest path. We use four classes of randomized test functions: (1) concave (square\nroot or log) over modular (CM), (2) clustered CM (CCM) of the form f(X) = \u2211k i=1 \u221a w(X \u2229 Ck) for clusters C1, \u00b7 \u00b7 \u00b7 , Ck, (3) Best Set (BS) functions where the optimal feasible set R is chosen randomly (f(X) = I(|X \u2229 R| \u2265 1) + \u2211 j\u2208R\\X wj) and (4) worst case-like functions (WC) similar to equation (11). Functions of type (1) and (2) have been used in speech and computer vision [31, 22, 17] and have reduced curvature (\u03baf < 1). Functions of type (3) and (4) have \u03baf = 1. In all four cases, we consider both sparse and dense graphs, with random weight vectors w. The plots show averages over 20 instances of these graphs. For sparse graphs, we consider grid like graphs in the form of square grids, grids with diagonals and cubic grids. For dense graphs, we sparsely connect a few dense cluster subgraphs. For matchings, we restrict ourselves to bipartite graphs, and consider both sparse and dense variants of these.\nFirst, we observe that in many cases, MMin clearly outperforms MU. This suggests the practical utility of more than one iteration. Second, despite its simplicity, MMin performs comparably to EA, and sometimes even better. In summary, the experiments suggest that the complex EA only gains on a few worst-case instances, whereas in many (average) cases, MMin yields near-optimal results (factor 1\u20132). In terms of running time, MMin is definitely preferable: on small instances (for example n = 40), our Matlab implementation of MMin takes 0.2 seconds, while EA needs about 58 seconds. On larger instances (n = 500), the running times differ on the order of seconds versus hours."}, {"heading": "6 Submodular maximization", "text": "Just like for minimization, for submodular maximization too we obtain a family of algorithms where each member is specified by a distinct schedule of subgradients. We will only select subgradients that are vertices of the subdifferential, i.e., each subgradient corresponds to a permutation of V . For any of those choices, MMax converges quickly. To bound the running time, we assume that we proceed only if we make sufficient progress, i.e., if f(Xt+1) \u2265 (1 + \u03b7)f(Xt).\nLemma 6.1. MMax with X0 = argmaxj f(j) runs in time O(T log1+\u03b7 n), where T is the time for maximizing a modular function subject to X \u2208 C.\nProof. Let X\u2217 be the optimal solution, then\nf(X\u2217) \u2264 \u2211 i\u2208X\u2217 f(j) \u2264 nmax j\u2208V f(j) = nf(X0). (12)\nFurthermore, we know that f(Xt) \u2265 (1 + \u03b7)tf(X0). Therefore, we have reached the maximum function value after at most (log n)/ log(1 + \u03b7) iterations.\nIn practice, we observe that MMax terminates within 3-10 iterations. We next consider specific subgradients and their theoretical implications. For unconstrained problems, we assume the submodular function to be non-monotone (the results trivially hold for monotone functions too); for constrained problems, we assume the function f to be monotone nondecreasing. Our results rely on the observation that many maximization algorithms actually compute a specific subgradient and run MMax with this subgradient. To our knowledge, this observation is new."}, {"heading": "6.1 Unconstrained Maximization", "text": "Random Permutation (RA/RP). In iteration t, we randomly pick a permutation \u03c3 that defines a subgradient at Xt\u22121, i.e., Xt\u22121 is assigned to the first |Xt\u22121| positions. At X0 = \u2205, this can be any permutation. Stopping after the first iteration (RP) achieves an approximation factor of 1/4 in expectation, and 1/2 for symmetric functions. Making further iterations (RA) only improves the solution.\nLemma 6.2. When running Algorithm RP with X0 = \u2205, it holds after one iteration that E(f(X1)) \u2265 14f(X \u2217) if f is a general non-negative submodular function, and E(f(X1)) \u2265 12f(X \u2217) if f is symmetric.\nProof. Each permutation has the same probability 1/n! of being chosen. Therefore, it holds that\nE(f(X1)) = E\u03c3(max X\u2286V h\u03c3\u2205 (X)) (13)\n= 1\nn! \u2211 \u03c3 max X\u2286V h\u03c3\u2205 (X) (14)\nLet \u2205 \u2286 S\u03c31 \u2286 S\u03c32 \u00b7 \u00b7 \u00b7S\u03c3n = V be the chain corresponding to a given permutation \u03c3. We can bound\nmax X\u2286V h\u03c3\u2205 (X) \u2265 n\u2211 k=0 ( n k ) 2n f(S\u03c3k ) (15)\nbecause maxX\u2286V h \u03c3 \u2205 (X) \u2265 f(S \u03c3 k ),\u2200k and \u2211n k=0 (nk) 2n = 1. Together, Equations (14) and (15) imply that\nE(f(X1)) \u2265 E\u03c3(max X\u2286V h\u03c3\u2205 (X)) (16)\n= \u2211 \u03c3 n\u2211 k=0 ( n k ) 2n f(S\u03c3k ) 1 n! (17)\n= n\u2211 k=0 ( n k ) n!2n \u2211 \u03c3 f(S\u03c3k ) (18)\n= n\u2211 k=0 ( n k ) n!2n k!(n\u2212 k)! \u2211 S:|S|=k f(S) (19)\n= \u2211 S f(S) 2n (20)\n= ES(f(S)) (21)\nBy ES(f(S)), we denote the expected function value when the set S is sampled uniformly at random, i.e., each element is included with probability 1/2. [8] shows that ES(f(S)) \u2265 14f(X\n\u2217). For symmetric submodular functions, the factor is 12 .\nRandomized local search (RLS). Instead of using a completely random subgradient as in RA, we fix the positions of two elements: the permutation must satisfy that \u03c3t(|Xt| + 1) \u2208 argmaxj f(j|Xt) and \u03c3t(|Xt| \u2212 1) \u2208 argminj f(j|Xt\\j). The remaining positions are assigned randomly. An \u03b7-approximate version of MMax with such subgradients returns an \u03b7-approximate local maximum that achieves an improved approximation factor of 1/3\u2212 \u03b7 in O(n 2 logn \u03b7 ) iterations.\nLemma 6.3. Algorithm RLS returns a local maximum X that satisfies max{f(X), f(V \\X)} \u2265 ( 13 \u2212 \u03b7)f(X \u2217) in O(n 2 logn \u03b7 ) iterations.\nProof. At termination (t = T ), it holds that maxj f(j|XT ) \u2264 0 and minj f(j|XT \\ j) \u2265 0; this implies that the set Xt is local optimum.\nTo show local optimality, recall that the subgradient h\u03c3 T XT satisfies h \u03c3T XT (X T ) = f(XT ), and h\u03c3 T XT (Y ) \u2265 h\u03c3 T\nXT (X T ) for all Y \u2286 V . Therefore, it must hold that maxj /\u2208XT f(j|XT ) = maxj /\u2208XT h\u03c3\nT\nXT (j) \u2264 0, and minj\u2208XT f(j|XT \\j) = h\u03c3 T XT (j) \u2265 0, which implies that the set X T is a local maximum.\nWe now use a result by [8] showing that if a set X is a local optimum, then f(X) \u2265 13f(X \u2217) if f is a general non-negative submodular set function and f(X) \u2265 12f(X \u2217) if f is a symmetric submodular function. If the set is an \u03b7-approximate local optimum, we obtain a 13 \u2212 \u03b7 approximation [8]. A complexity analysis similar to Theorem 6.1 reveals that the worst case complexity of this algorithm is O(n\n2 logn \u03b7 ).\nNote that even finding an exact local maximum is hard for submodular functions [8], and therefore it is necessary to resort to an \u03b7-approximate version, which converges to an \u03b7-approximate local maximum.\nDeterministic local search (DLS). A completely deterministic variant of RLS defines the permutation by an entirely greedy ordering. We define permutation \u03c3t used in iteration t via the chain \u2205 = S\u03c3t0 \u2282 S\u03c3 t\n1 \u2282 . . . \u2282 S\u03c3tn it will generate. The initial permutation is \u03c30(j) = argmaxk/\u2208S\u03c30j\u22121 f(k|S \u03c30 j\u22121) for j = 1, 2, . . .. In\nsubsequent iterations t, the permutation \u03c3t is\n\u03c3t(j) =  \u03c3t\u22121(j) if t even, j \u2208 Xt\u22121 argmaxk f(k|S\u03c3 t j\u22121) if t even, j /\u2208 Xt\u22121 argmink f(k|S\u03c3 t j+1\\k) if t odd, j \u2208 Xt\u22121\n\u03c3t\u22121(j) if t odd, j /\u2208 Xt\u22121.\nThis schedule is equivalent to the deterministic local search (DLS) algorithm by [8], and therefore achieves an approximation factor of 1/3\u2212 \u03b7.\nBi-directional greedy (BG). The procedures above indicate that greedy and local search algorithms implicitly define specific chains and thereby subgradients. Likewise, the deterministic bi-directional greedy algorithm by [4] induces a distinct permutation of the ground set. It is therefore equivalent to MMax with the corresponding subgradients and achieves an approximation factor of 1/3. This factor improves that of the local search techniques by removing \u03b7. Moreover, unlike for local search, the 1/3 approximation holds already after the first iteration.\nLemma 6.4. The set X1 obtained by Algorithm 1 with the subgradient equivalent to BG satisfies that f(X) \u2265 13f(X \u2217).\nProof. Given an initial ordering \u03c4 , the bi-directional greedy algorithm by [4] generates a chain of sets. Let \u03c3\u03c4 denote the permutation defined by this chain, obtainable by mimicking the algorithm. We run MMax with the corresponding subgradient. By construction, the set S\u03c4 returned by the bi-directional greedy algorithm is contained in the chain. Therefore, it holds that\nf(X1) \u2265 max X\u2286V\nh\u03c3 \u03c4\n\u2205 (X) (22)\n\u2265 max k\nf(S\u03c3 \u03c4\nk ) (23)\n\u2265 f(S\u03c4 ) (24)\n\u2265 1 3 f(X\u2217). (25)\nThe first inequality follows since the subgradient is tight for all sets in the chain. For the second inequality, we used that S\u03c4 belongs to the chain, and hence S\u03c4 = S\u03c3 \u03c4\nj for some j. The last inequality follows from the approximation factor satisfied by S\u03c4 [4]. We can continue the algorithm, using any one of the adaptive schedules above to get a locally optimal solution. This can only improve the solution.\nRandomized bi-directional greedy (RG). Like its deterministic variant, the randomized bi-directional greedy algorithm by [4] can be shown to run MMax with a specific subgradient. Starting from \u2205 and V , it implicitly defines a random chain of subsets and thereby (random) subgradients. A simple analysis shows that this subgradient leads to the best possible approximation factor of 1/2 in expectation.\nLike its deterministic counterpart, the Randomized bi-directional Greedy algorithm (RG) by [4] induces a (random) permutation \u03c3\u03c4 based on an initial ordering \u03c4 .\nLemma 6.5. If the subgradient in MMax is determined by \u03c3\u03c4 , then the set X1 after the first iteration satisfies E(f(X1)) \u2265 12f(X \u2217), where the expectation is taken over the randomness in \u03c3\u03c4 .\nProof. The permutation \u03c3\u03c4 is obtained by a randomized algorithm, but once \u03c3\u03c4 is fixed, the remainder of\nMMax is deterministic. By an argumentation similar to that in the proof of Lemma 6.4, it holds that\nE(f(X)) \u2265 E(max X\nh\u03c3 \u03c4\n\u2205 (X)) (26)\n\u2265 E(max k\nf(S\u03c3 \u03c4\nk )) (27)\n\u2265 E(f(S\u03c3 \u03c4 )) (28)\n\u2265 1 2 f(X\u2217) (29)\nThe last inequality follows from a result in [4]."}, {"heading": "6.2 Constrained Maximization", "text": "In this final section, we analyze subgradients for maximization subject to the constraint X \u2208 C. Here we assume that f is monotone. An important subgradient results from the greedy permutation \u03c3g, defined as\n\u03c3g(i) \u2208 argmax j /\u2208S\u03c3gi\u22121 and S\u03c3 g i\u22121\u222a{j}\u2208C\nf(j|S\u03c3 g\ni\u22121). (30)\nThis definition might be partial; we arrange any remaining elements arbitrarily. When using the corresponding subgradient h\u03c3 g , we recover a number of approximation results already after one iteration:\nLemma 6.6. Using h\u03c3 g in iteration 1 of MMax yields the following approximation bounds for X1:\n\u2022 1\u03baf (1\u2212 e \u2212\u03baf ), if C = {X \u2286 V : |X| \u2264 k} \u2022 1p+\u03baf , for the intersection C=\u2229 p i=1Ii of p matroids \u2022 1\u03baf (1\u2212 ( K\u2212\u03baf K )\nk), for any down-monotone constraint C, where K and k are the maximum and minimum cardinality of the maximal feasible sets in C.\nProof. We prove the first result for cardinality constraints. The proofs for the matroid and general downmonotone constraints are analogous. By the construction of \u03c3g, the set S\u03c3 g\nk is exactly the set returned by the greedy algorithm. This implies that\nf(X1) \u2265 argmax X:|X|\u2264k\nh\u03c3 g\n\u2205 (X) (31)\n\u2265 h\u03c3 g \u2205 (S \u03c3g k ) (32) = f(S\u03c3 g\nk ) (33)\n\u2265 (1\u2212 e \u2212\u03baf )\n\u03baf f(X\u2217). (34)\nThe last inequality follows from [39, 5]. A very similar construction of a greedy permutation provides bounds for budget constraints, i.e., c(S) ,\u2211 i\u2208S c(i) \u2264 B for some given nonnegative costs c. In particular, define a permutation as:\n\u03c3g(i) \u2208 argmax j /\u2208S\u03c3gi\u22121,c(S\u03c3 g i\u22121\u222a{j})\u2264B\nf(j|S\u03c3gi\u22121) c(j) . (35)\nThe following result then follows from [30, 43].\nLemma 6.7. Using \u03c3g in MMax under the budget constraints yields:\nmax{ max i:c(i)\u2264B\nf(i), f(X1)} \u2265 (1\u2212 1/ \u221a e)f(X\u2217). (36)\nLet \u03c3ijk be a permutation with i, j, k in the first three positions, and the remaining arrangement greedy. Running O(n3) restarts of MM yields sets Xijk (after one iteration) with\nmax i,j,k\u2208V\nf(Xijk) \u2265 (1\u2212 1/e)f(X\u2217). (37)\nThe proof is analogous to that of Lemma 6.6. Table 1 lists results for monotone submodular maximization under different constraints.\nIt would be interesting if some of the constrained variants of non-monotone submodular maximization could be naturally subsumed in our framework too. In particular, some recent algorithms [27, 28] propose local search based techniques to obtain constant factor approximations for non-monotone submodular maximization under knapsack and matroid constraints. Unfortunately, these algorithms require swap operations along with inserting and deleting elements. We do not currently know how to phrase these swap operations via our framework and leave this relation as an open problem.\nWhile a number of algorithms cannot be naturally seen as an instance of our framework, we show in the following section that any polynomial time approximation algorithm for unconstrained or constrained variants of submodular optimization can be ultimately seen as an instance of our algorithm, via a polynomial-time computable subgradient."}, {"heading": "6.3 Generality", "text": "The correspondences between MMax and maximization algorithms hold even more generally:\nTheorem 6.8. For any polynomial-time unconstrained submodular maximization algorithm that achieves an approximation factor \u03b1, there exists a schedule of subgradients (obtainable in polynomial time) that, if used within MMax, leads to a solution with the same approximation factor \u03b1.\nThe proof relies on the following observation.\nLemma 6.9. Any submodular function f satisfies\nmax X\u2208C f(X) = max X\u2208C,h\u2208Pf h(X) = max X\u2208C,\u03c3\u2208\u03a3\nh\u03c3\u2205 (X). (38)\nLemma 6.9 implies that there exists a permutation (and equivalent subgradient) with which MMax finds the optimal solution in the first iteration. Known hardness results [7] imply that this permutation may not be obtainable in polynomial time.\nProof. (Lemma 6.9) The first equality in Lemma 6.9 follows from the fact that any submodular function f can be written as\nf(X) = max h\u2208Pf h(X). (39)\nFor the second equality, we use the fact that a linear program over a polytope has a solution at one of the extreme points of the corresponding polytope.\nWe can now prove Theorem 6.8\nProof. (Thm. 6.8) Let Y be the set returned by the approximation algorithm; this set is polynomial-time computable by definition. Let \u03c4 be an arbitrary permutation that places the elements in Y in the first |Y | positions. The subgradient h\u03c4 defined by \u03c4 is a subgradient both for \u2205 and for Y . Therefore, using X0 = \u2205 and h\u03c4 in the first iteration, we obtain a set X1 with\nf(X1) \u2265 h\u03c4\u2205(X 1) \u2265 h\u03c4\u2205(Y ) = f(Y ) \u2265 \u03b1f(X \u2217). (40)\nThe equality follows from the fact that Y belongs to the chain of \u03c4 .\nWhile the above theorem shows the optimality of MMax in the unconstrained setting, a similar result holds for the constrained case:\nCorollary 6.10. Let C be any constraint such that a linear function can be exactly maximized over C. For any polynomial-time algorithm for submodular maximization over C that achieves an approximation factor \u03b1, there exists a schedule of subgradients (obtainable in polynomial time) that, if used within MMax, leads to a solution with the same approximation factor \u03b1.\nThe proof of Corollary 6.10 follows directly from the Theorem 6.8. Lastly, we pose the question of selecting the optimal subgradient in each iteration. An optimal subgradient h would lead to a function mh whose maximization yields the largest improvement. Unfortunately, obtaining such an \u201coptimal\u201d subgradient is impossible:\nTheorem 6.11. The problem of finding the optimal subgradient \u03c3OPT = argmax\u03c3,X\u2286V h \u03c3 Xt(X) in Step 4 of Algorithm 1 is NP-hard even when C = 2V . Given such an oracle, however, MMax using subgradient \u03c3OPT returns a global optimizer.\nProof. Lemma 6.9 implies that an optimal subgradient at X0 = \u2205 or X0 = V is a subgradient at an optimal solution. An argumentation as in Equation (40) shows that using this subgradient in MM leads to an optimal solution. Since this would solve submodular maximization (which is NP-hard), it must be NP-hard to find such a subgradient.\nTo show that this holds for arbitrary Xt (and correspondingly at every iteration), we use that the submodular subdifferential can be expressed as a direct product between a submodular polyhedron and an anti-submodular polyhedron [9]. Any problem involving an optimization over the sub-differential, can then be expressed as an optimization over a submodular polyhedron (which is a subdifferential at the empty set) and an anti-submodular polyhedron (which is a subdifferential at V ) [9]. Correspondingly, Equation (38) can be expressed as the sum of two submodular maximization problems."}, {"heading": "6.4 Experiments", "text": "We now empirically compare variants of MMax with different subgradients. As a test function, we use the objective of [29], f(X) = \u2211 i\u2208V \u2211 j\u2208X sij \u2212 \u03bb \u2211 i,j\u2208X sij , where \u03bb is a redundancy parameter. This non-monotone function was used to find the most diverse yet relevant subset of objects in a large corpus. We use the objective with both synthetic and real data. We generate 10 instances of random similarity matrices {sij}ij and vary \u03bb from 0.5 to 1. Our real-world data is the Speech Training data subset selection problem [29] on the TIMIT corpus [11], using the string kernel metric [41] for similarity. We use 20 \u2264 n \u2264 30 so that the exact solution can still be computed with the algorithm of [14].\nWe compare the algorithms DLS, BG, RG, RLS, RA and RP, and a baseline RS that picks a set uniformly at random. RS achieves a 1/4 approximation in expectation [8]. For random algorithms, we select the best solution out of 5 repetitions. Figure 5 shows that DLS, BG, RG and RLS dominate. Even though RG has the best theoretical worst-case bounds, it performs slightly poorer than the local search ones and BG. Moreover, MMax with random subgradients (RP) is much better than choosing a set uniformly at random (RS). In general, the empirical approximation factors are much better than the theoretical worst-case bounds. Importantly, the MMax variants are extremely fast, about 200-500 times faster than the exact branch and bound technique of [14]."}, {"heading": "7 Discussion and Conclusions", "text": "In this paper, we introduced a general MM framework for submodular optimization algorithms. This framework is akin to the class of algorithms for minimizing the difference between submodular functions [37, 17]. In addition, it may be viewed as a special case of a proximal minimization algorithm that uses Bregman\ndivergences derived from submodular functions [19]. To our knowledge this is the first generic and unifying framework of combinatorial algorithms for submodular optimization.\nAn alternative framework relies on relaxing the discrete optimization problem by using a continuous extension (the Lova\u0301sz extension for minimization and multilinear extension for maximization). Relaxations have been applied to some constrained [16] and unconstrained [2] minimization problems as well as maximization problems [4]. Such relaxations, however, rely on a final rounding step that can be challenging \u2014 the combinatorial framework obviates this step. Moreover, our results show that in many cases, it yields good results very efficiently.\nAcknowledgments: We thank Karthik Mohan, John Halloran and Kai Wei for discussions. This material is based upon work supported by the National Science Foundation under Grant No. IIS-1162606, and by a Google, a Microsoft, and an Intel research award. This material is also based upon work supported in part by the Office of Naval Research under contract/grant number N00014-11-1-068, NSF CISE Expeditions award CCF-1139158 and DARPA XData Award FA8750-12-2-0331, and gifts from Amazon Web Services, Google, SAP, Cisco, Clearstory Data, Cloudera, Ericsson, Facebook, FitWave, General Electric, Hortonworks, Intel, Microsoft, NetApp, Oracle, Samsung, Splunk, VMware and Yahoo!."}], "references": [{"title": "Categorized bottleneck-minisum path problems on networks", "author": ["I. Averbakh", "O. Berman"], "venue": "Operations Research Letters, 16:291\u2013297,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1994}, {"title": "Learning with Submodular functions: A convex Optimization Perspective", "author": ["F. Bach"], "venue": "Arxiv,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Interactive graph cuts for optimal boundary and region segmentation of objects in n-d images", "author": ["Y. Boykov", "M.P. Jolly"], "venue": "ICCV,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2001}, {"title": "A tight (1/2) linear-time approximation to unconstrained submodular maximization", "author": ["N. Buchbinder", "M. Feldman", "J. Naor", "R. Schwartz"], "venue": "FOCS,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Submodular set functions, matroids and the greedy algorithm: tight worstcase bounds and some generalizations of the Rado-Edmonds theorem", "author": ["M. Conforti", "G. Cornuejols"], "venue": "Discrete Applied Mathematics, 7(3):251\u2013274,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1984}, {"title": "Minimizing sparse high-order energies by submodular vertex-cover", "author": ["A. Delong", "O. Veksler", "A. Osokin", "Y. Boykov"], "venue": "In NIPS,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "A threshold of ln n for approximating set cover", "author": ["U. Feige"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1998}, {"title": "Maximizing non-monotone submodular functions", "author": ["U. Feige", "V. Mirrokni", "J. Vondr\u00e1k"], "venue": "SIAM J. COMPUT., 40(4):1133\u20131155,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "Submodular functions and optimization, volume 58", "author": ["S. Fujishige"], "venue": "Elsevier Science,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "A submodular function minimization algorithm based on the minimum-norm base", "author": ["S. Fujishige", "S. Isotani"], "venue": "Pacific Journal of Optimization, 7:3\u201317,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2011}, {"title": "Timit, acoustic-phonetic continuous speech corpus", "author": ["J. Garofolo", "L. Fisher Lamel", "J. W", "Fiscus", "D. Pallet", "N. Dahlgren"], "venue": "In DARPA,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1993}, {"title": "Approximability of combinatorial problems with multi-agent submodular cost functions", "author": ["G. Goel", "C. Karande", "P. Tripathi", "L. Wang"], "venue": "FOCS,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2009}, {"title": "Approximating submodular functions everywhere", "author": ["M.X. Goemans", "N.J.A. Harvey", "S. Iwata", "V. Mirrokni"], "venue": "SODA, pages 535\u2013544,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "The maximization of submodular functions: Old and new proofs for the correctness of the dichotomy algorithm", "author": ["B. Goldengorin", "G.A. Tijssen", "M. Tso"], "venue": "University of Groningen,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1999}, {"title": "A tutorial on MM algorithms", "author": ["D.R. Hunter", "K. Lange"], "venue": "The American Statistician,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2004}, {"title": "Submodular function minimization under covering constraints", "author": ["S. Iwata", "K. Nagano"], "venue": "In FOCS, pages 671\u2013680. IEEE,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "Algorithms for approximate minimization of the difference between submodular functions, with applications", "author": ["R. Iyer", "J. Bilmes"], "venue": "UAI,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "The submodular Bregman and Lov\u00e1sz-Bregman divergences with applications", "author": ["R. Iyer", "J. Bilmes"], "venue": "NIPS,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2012}, {"title": "Mirror descent like algorithms for submodular optimization", "author": ["R. Iyer", "S. Jegelka", "J. Bilmes"], "venue": "NIPS Workshop on Discrete Optimization in Machine Learning (DISCML),", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}, {"title": "Combinatorial Problems with submodular coupling in machine learning and computer vision", "author": ["S. Jegelka"], "venue": "PhD thesis, ETH Zurich,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2012}, {"title": "Approximation bounds for inference using cooperative cuts", "author": ["S. Jegelka", "J.A. Bilmes"], "venue": "ICML,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Submodularity beyond submodular energies: coupling edges in graph cuts", "author": ["S. Jegelka", "J.A. Bilmes"], "venue": "CVPR,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "On fast approximate submodular minimization", "author": ["S. Jegelka", "H. Lin", "J. Bilmes"], "venue": "NIPS,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "SFO: A toolbox for submodular function optimization", "author": ["A. Krause"], "venue": "JMLR, 11:1141\u20131144,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2010}, {"title": "Near-optimal sensor placements in Gaussian processes: Theory, efficient algorithms and empirical studies", "author": ["A. Krause", "A. Singh", "C. Guestrin"], "venue": "JMLR, 9:235\u2013284,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2008}, {"title": "Determinantal point processes for machine learning", "author": ["A. Kulesza", "B. Taskar"], "venue": "arXiv preprint arXiv:1207.6083,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2012}, {"title": "Non-monotone submodular maximization under matroid and knapsack constraints", "author": ["J. Lee", "V.S. Mirrokni", "V. Nagarajan", "M. Sviridenko"], "venue": "STOC, pages 323\u2013332. ACM,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2009}, {"title": "Submodular maximization over multiple matroids via generalized exchange properties", "author": ["Jon Lee", "Maxim Sviridenko", "Jan Vondr\u00e1k"], "venue": "In APPROX,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "How to select a good training-data subset for transcription: Submodular active selection for sequences", "author": ["H. Lin", "J. Bilmes"], "venue": "Interspeech,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2009}, {"title": "Multi-document summarization via budgeted maximization of submodular functions", "author": ["H. Lin", "J. Bilmes"], "venue": "NAACL,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2010}, {"title": "A class of submodular functions for document summarization", "author": ["H. Lin", "J. Bilmes"], "venue": "ACL,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2011}, {"title": "Optimal selection of limited vocabulary speech corpora", "author": ["H. Lin", "J. Bilmes"], "venue": "Interspeech,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2011}, {"title": "Submodular function minimization", "author": ["S Thomas McCormick"], "venue": "Discrete Optimization, 12:321\u2013391,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2005}, {"title": "The EM algorithm and extensions", "author": ["G.J. McLachlan", "T. Krishnan"], "venue": "New York,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1997}, {"title": "Size-constrained submodular minimization through minimum norm base", "author": ["K. Nagano", "Y. Kawahara", "K. Aihara"], "venue": "ICML,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2011}, {"title": "Minimum average cost clustering", "author": ["K. Nagano", "Y. Kawahara", "S. Iwata"], "venue": "NIPS,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2010}, {"title": "A submodular-supermodular procedure with applications to discriminative structure learning", "author": ["M. Narasimhan", "J. Bilmes"], "venue": "UAI,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2005}, {"title": "Q-clustering", "author": ["M. Narasimhan", "N. Jojic", "J. Bilmes"], "venue": "NIPS, 18:979,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2006}, {"title": "An analysis of approximations for maximizing submodular set functions\u2014i", "author": ["G.L. Nemhauser", "L.A. Wolsey", "M.L. Fisher"], "venue": "Mathematical Programming, 14(1):265\u2013294,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 1978}, {"title": "A faster strongly polynomial time algorithm for submodular function minimization", "author": ["J.B. Orlin"], "venue": "Mathematical Programming, 118(2):237\u2013251,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2009}, {"title": "Efficient computation of gapped substring kernels on large alphabets", "author": ["J. Rousu", "J. Shawe-Taylor"], "venue": "Journal of Machine Learning Research, 6(2):1323,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2006}, {"title": "Efficient minimization of decomposable submodular functions", "author": ["P. Stobbe", "A. Krause"], "venue": "NIPS,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2010}, {"title": "A note on maximizing a submodular set function subject to a knapsack constraint", "author": ["M. Sviridenko"], "venue": "Operations Research Letters, 32(1):41\u201343,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2004}, {"title": "Submodular approximation: Sampling-based algorithms and lower bounds", "author": ["Z. Svitkina", "L. Fleischer"], "venue": "FOCS, pages 697\u2013706,", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2008}, {"title": "Minimum-energy broadcasting in static ad hoc wireless networks", "author": ["P.-J. Wan", "G. Calinescu", "X.-Y. Li", "O. Frieder"], "venue": "Wireless Networks, 8:607\u2013617,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2002}, {"title": "The concave-convex procedure (CCCP)", "author": ["A.L. Yuille", "A. Rangarajan"], "venue": "NIPS,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2002}], "referenceMentions": [{"referenceID": 8, "context": "A function f : 2 \u2192 R is said to be submodular [9] if for all subsets S, T \u2286 V , it holds that f(S) + f(T ) \u2265 f(S \u222a T ) + f(S \u2229 T ).", "startOffset": 46, "endOffset": 49}, {"referenceID": 8, "context": "While it has long been known [9] that submodular functions have tight subdifferentials, our results rely on a recently discovered property [18, 22] showing that submodular functions also have superdifferentials.", "startOffset": 29, "endOffset": 32}, {"referenceID": 17, "context": "While it has long been known [9] that submodular functions have tight subdifferentials, our results rely on a recently discovered property [18, 22] showing that submodular functions also have superdifferentials.", "startOffset": 139, "endOffset": 147}, {"referenceID": 21, "context": "While it has long been known [9] that submodular functions have tight subdifferentials, our results rely on a recently discovered property [18, 22] showing that submodular functions also have superdifferentials.", "startOffset": 139, "endOffset": 147}, {"referenceID": 2, "context": "MAP inference/Image segmentation: Markov Random Fields with pairwise attractive potentials are important in computer vision, where MAP inference is identical to unconstrained submodular minimization solved via minimum cut [3].", "startOffset": 222, "endOffset": 225}, {"referenceID": 21, "context": "A richer higher-order model can be induced for which MAP inference corresponds to Problem 1 where V is a set of edges in a graph, and C is a set of cuts in this graph \u2014 this was shown to significantly improve many image segmentation results [22].", "startOffset": 241, "endOffset": 245}, {"referenceID": 5, "context": "Moreover, [6] efficiently solve MAP inference in a sparse higher-order graphical model by restating the problem as a submodular vertex cover, i.", "startOffset": 10, "endOffset": 13}, {"referenceID": 37, "context": "Clustering: Variants of submodular minimization have been successfully applied to clustering problems [38, 36].", "startOffset": 102, "endOffset": 110}, {"referenceID": 35, "context": "Clustering: Variants of submodular minimization have been successfully applied to clustering problems [38, 36].", "startOffset": 102, "endOffset": 110}, {"referenceID": 31, "context": "Limited Vocabulary Speech Corpora: The problem of finding a maximum size speech corpus with bounded vocabulary [32] can be posed as submodular function minimization subject to a size constraint.", "startOffset": 111, "endOffset": 115}, {"referenceID": 22, "context": "Alternatively, cardinality can be treated as a penalty, reducing the problem to unconstrained submodular minimization [23].", "startOffset": 118, "endOffset": 122}, {"referenceID": 43, "context": "Size constraints: The densest k-subgraph and size-constrained graph cut problems correspond to submodular minimization with cardinality constraints, problems that are very hard [44].", "startOffset": 177, "endOffset": 181}, {"referenceID": 43, "context": "in [44, 35].", "startOffset": 3, "endOffset": 11}, {"referenceID": 34, "context": "in [44, 35].", "startOffset": 3, "endOffset": 11}, {"referenceID": 44, "context": ", a spanning tree) minimizing a submodular cost function [45].", "startOffset": 57, "endOffset": 61}, {"referenceID": 0, "context": "Such economies of scale, or \u201cright of usage\u201d properties are captured in the \u201cCategorized Bottleneck Path Problem\u201d \u2013 a shortest path problem with submodular costs [1].", "startOffset": 162, "endOffset": 165}, {"referenceID": 24, "context": "Sensor placement [25], document summarization [31] and speech data subset selection [29], for example, are instances of submodular maximization.", "startOffset": 17, "endOffset": 21}, {"referenceID": 30, "context": "Sensor placement [25], document summarization [31] and speech data subset selection [29], for example, are instances of submodular maximization.", "startOffset": 46, "endOffset": 50}, {"referenceID": 28, "context": "Sensor placement [25], document summarization [31] and speech data subset selection [29], for example, are instances of submodular maximization.", "startOffset": 84, "endOffset": 88}, {"referenceID": 25, "context": "Determinantal Point Processes: The Determinantal Point Processes (DPPs) which have found numerous applications in machine learning [26] are known to be log-submodular distributions.", "startOffset": 131, "endOffset": 135}, {"referenceID": 32, "context": "Among the several algorithms [33] for the unconstrained variant of Problem 1, where C = 2 , the best complexity to date is O(n\u03b3 + n) [40] (\u03b3 is the cost of evaluating f).", "startOffset": 29, "endOffset": 33}, {"referenceID": 39, "context": "Among the several algorithms [33] for the unconstrained variant of Problem 1, where C = 2 , the best complexity to date is O(n\u03b3 + n) [40] (\u03b3 is the cost of evaluating f).", "startOffset": 133, "endOffset": 137}, {"referenceID": 41, "context": "This has motivated studies on faster, possibly special case or approximate, methods [42, 23].", "startOffset": 84, "endOffset": 92}, {"referenceID": 22, "context": "This has motivated studies on faster, possibly special case or approximate, methods [42, 23].", "startOffset": 84, "endOffset": 92}, {"referenceID": 43, "context": "Approximation algorithms for these problems with various techniques have been studied in [44, 16, 12, 21].", "startOffset": 89, "endOffset": 105}, {"referenceID": 15, "context": "Approximation algorithms for these problems with various techniques have been studied in [44, 16, 12, 21].", "startOffset": 89, "endOffset": 105}, {"referenceID": 11, "context": "Approximation algorithms for these problems with various techniques have been studied in [44, 16, 12, 21].", "startOffset": 89, "endOffset": 105}, {"referenceID": 20, "context": "Approximation algorithms for these problems with various techniques have been studied in [44, 16, 12, 21].", "startOffset": 89, "endOffset": 105}, {"referenceID": 38, "context": "Most such problems, however, admit constant-factor approximations, which are attained via very simple combinatorial algorithms [39, 4].", "startOffset": 127, "endOffset": 134}, {"referenceID": 3, "context": "Most such problems, however, admit constant-factor approximations, which are attained via very simple combinatorial algorithms [39, 4].", "startOffset": 127, "endOffset": 134}, {"referenceID": 14, "context": "Majorization-minimization (MM) algorithms are known to be useful in machine learning [15].", "startOffset": 85, "endOffset": 89}, {"referenceID": 33, "context": "Notable examples include the EM algorithm [34] and the convex-concave procedure [46].", "startOffset": 42, "endOffset": 46}, {"referenceID": 45, "context": "Notable examples include the EM algorithm [34] and the convex-concave procedure [46].", "startOffset": 80, "endOffset": 84}, {"referenceID": 36, "context": "Discrete instances have been used to minimize the difference between submodular functions [37, 17], but these algorithms generally lack theoretical guarantees.", "startOffset": 90, "endOffset": 98}, {"referenceID": 16, "context": "Discrete instances have been used to minimize the difference between submodular functions [37, 17], but these algorithms generally lack theoretical guarantees.", "startOffset": 90, "endOffset": 98}, {"referenceID": 8, "context": "The subdifferential \u2202f (Y ) of a submodular set function f : 2 \u2192 R for a set Y \u2286 V is defined [9] analogously to the subdifferential of a continuous convex function: \u2202f (Y ) = {y \u2208 R : (1) f(X)\u2212 y(X) \u2265 f(Y )\u2212 y(Y ) for all X \u2286 V } For a vector x \u2208 R and X \u2286 V , we write x(X) = \u2211 j\u2208X x(j) \u2014 in such case, we say that x is a normalized modular function.", "startOffset": 94, "endOffset": 97}, {"referenceID": 21, "context": "Surprisingly, we can also define superdifferentials \u2202 (Y ) of a submodular function [22, 18] at Y : \u2202 (Y ) = {y \u2208 R : (3) f(X)\u2212 y(X) \u2264 f(Y )\u2212 y(Y ); for all X \u2286 V } We denote a generic supergradient at Y by gY .", "startOffset": 84, "endOffset": 92}, {"referenceID": 17, "context": "Surprisingly, we can also define superdifferentials \u2202 (Y ) of a submodular function [22, 18] at Y : \u2202 (Y ) = {y \u2208 R : (3) f(X)\u2212 y(X) \u2264 f(Y )\u2212 y(Y ); for all X \u2286 V } We denote a generic supergradient at Y by gY .", "startOffset": 84, "endOffset": 92}, {"referenceID": 17, "context": "We define three special supergradients \u011dY (\u201cgrow\u201d), \u01e7Y (\u201cshrink\u201d) and \u1e21Y as follows [18]: \u011dY (j) = f(j | V \\ {j}) \u011dY (j) = f(j | Y ) \u01e7Y (j) = f(j | Y \\ {j}) \u01e7Y (j) = f(j | \u2205) \u1e21Y (j) = f(j | V \\ {j}) } {{ } \u1e21Y (j) = f(j | \u2205) } {{ } for j \u2208 Y for j / \u2208 Y.", "startOffset": 84, "endOffset": 88}, {"referenceID": 1, "context": "In addition, it is known that for relaxed instances of our problems, subgradient descent methods can suffer from slow convergence [2].", "startOffset": 130, "endOffset": 133}, {"referenceID": 22, "context": "MMin-I is very similar to the algorithms proposed in [23].", "startOffset": 53, "endOffset": 57}, {"referenceID": 8, "context": "[9] Let L\u2217 be the lattice of the global minimizers of a submodular function f .", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "1 has been used to prune down the search space of the minimum norm point algorithm from the power set of V to a smaller lattice [2, 10].", "startOffset": 128, "endOffset": 135}, {"referenceID": 9, "context": "1 has been used to prune down the search space of the minimum norm point algorithm from the power set of V to a smaller lattice [2, 10].", "startOffset": 128, "endOffset": 135}, {"referenceID": 22, "context": "3 generalizes part of Lemma 3 in [23].", "startOffset": 33, "endOffset": 37}, {"referenceID": 7, "context": "In consequence, a local minimum of a submodular function can be obtained in O(n), a fact that is of independent interest and that does not hold for local maximizers [8].", "startOffset": 165, "endOffset": 168}, {"referenceID": 2, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 8, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 16, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 13, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 13, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 9, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 15, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 3, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 12, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 1, "context": "Specifically, let w1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w2 = [\u22129, 4, 6,\u22121, 10,\u22124,\u22126,\u22121, 2,\u22128].", "startOffset": 23, "endOffset": 59}, {"referenceID": 0, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 32, "endOffset": 45}, {"referenceID": 5, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 32, "endOffset": 45}, {"referenceID": 6, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 32, "endOffset": 45}, {"referenceID": 9, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 32, "endOffset": 45}, {"referenceID": 0, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 54, "endOffset": 73}, {"referenceID": 3, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 54, "endOffset": 73}, {"referenceID": 5, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 54, "endOffset": 73}, {"referenceID": 6, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 54, "endOffset": 73}, {"referenceID": 7, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 54, "endOffset": 73}, {"referenceID": 9, "context": "Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10].", "startOffset": 54, "endOffset": 73}, {"referenceID": 0, "context": "The tightened sublattice contains exactly the minimizer: A+ = B+ = X \u2217 = [1, 6, 7, 8, 10].", "startOffset": 73, "endOffset": 89}, {"referenceID": 5, "context": "The tightened sublattice contains exactly the minimizer: A+ = B+ = X \u2217 = [1, 6, 7, 8, 10].", "startOffset": 73, "endOffset": 89}, {"referenceID": 6, "context": "The tightened sublattice contains exactly the minimizer: A+ = B+ = X \u2217 = [1, 6, 7, 8, 10].", "startOffset": 73, "endOffset": 89}, {"referenceID": 7, "context": "The tightened sublattice contains exactly the minimizer: A+ = B+ = X \u2217 = [1, 6, 7, 8, 10].", "startOffset": 73, "endOffset": 89}, {"referenceID": 9, "context": "The tightened sublattice contains exactly the minimizer: A+ = B+ = X \u2217 = [1, 6, 7, 8, 10].", "startOffset": 73, "endOffset": 89}, {"referenceID": 43, "context": "As opposed to unconstrained submodular minimization, almost all cases of constrained submodular minimization are very hard [44, 21, 12], and admit at most approximate solutions in polynomial time.", "startOffset": 123, "endOffset": 135}, {"referenceID": 20, "context": "As opposed to unconstrained submodular minimization, almost all cases of constrained submodular minimization are very hard [44, 21, 12], and admit at most approximate solutions in polynomial time.", "startOffset": 123, "endOffset": 135}, {"referenceID": 11, "context": "As opposed to unconstrained submodular minimization, almost all cases of constrained submodular minimization are very hard [44, 21, 12], and admit at most approximate solutions in polynomial time.", "startOffset": 123, "endOffset": 135}, {"referenceID": 4, "context": "An important ingredient in the bound is the curvature [5] of a monotone submodular function f , defined as \u03baf = 1\u2212minj\u2208V f(j | V \\j) / f(j) (8) Theorem 5.", "startOffset": 54, "endOffset": 57}, {"referenceID": 21, "context": "Before proving this result, we remark that a similar, slightly looser bound was shown for cuts in [22], by using a weaker notion of curvature.", "startOffset": 98, "endOffset": 102}, {"referenceID": 19, "context": "9, we use the following result shown in [20]: f(X\u0302) \u2264 g(X \u2217)/f(i) 1 + (1\u2212 \u03baf )(g(X\u2217)/f(i)\u2212 1) f(X\u2217) (9)", "startOffset": 40, "endOffset": 44}, {"referenceID": 11, "context": "9 yields a constant approximation factor and refines bounds for constrained minimization that are given in [12, 44].", "startOffset": 107, "endOffset": 115}, {"referenceID": 43, "context": "9 yields a constant approximation factor and refines bounds for constrained minimization that are given in [12, 44].", "startOffset": 107, "endOffset": 115}, {"referenceID": 30, "context": "For example, concave over modular functions were used in [31, 22].", "startOffset": 57, "endOffset": 65}, {"referenceID": 21, "context": "For example, concave over modular functions were used in [31, 22].", "startOffset": 57, "endOffset": 65}, {"referenceID": 0, "context": "These comprise, for instance, functions of the form f(X) = (w(X)), for some a \u2208 [0, 1] and a nonnegative weight vector w, whose curvature is \u03baf \u2248 1\u2212 a(j w(j) w(V ) ) 1\u2212a > 0.", "startOffset": 80, "endOffset": 86}, {"referenceID": 23, "context": "We implement and compare algorithms using Matlab and the SFO toolbox [24].", "startOffset": 69, "endOffset": 73}, {"referenceID": 9, "context": "Applying MMin-I and II (lattice L+) to Iwata\u2019s test function [10], we observe an average reduction of 99.", "startOffset": 61, "endOffset": 65}, {"referenceID": 0, "context": "In addition, we use concave over modular functions \u221a w1(X) + \u03bbw2(V \\X) with randomly chosen vectors w1, w2 in [0, 1] n and n = 50.", "startOffset": 110, "endOffset": 116}, {"referenceID": 31, "context": "[32, 23] use functions of the form \u221a w1(\u0393(X)) + w2(V \\X), where \u0393(X) is the neighborhood function of a bipartite graph.", "startOffset": 0, "endOffset": 8}, {"referenceID": 22, "context": "[32, 23] use functions of the form \u221a w1(\u0393(X)) + w2(V \\X), where \u0393(X) is the neighborhood function of a bipartite graph.", "startOffset": 0, "endOffset": 8}, {"referenceID": 9, "context": "When used as a preprocessing step for the minimum norm point algorithm (MN) [10], this pruned lattice speeds up the MN algorithm accordingly, in particular for the speech data.", "startOffset": 76, "endOffset": 80}, {"referenceID": 11, "context": "For constrained minimization, we compare MMin-I to two methods: a simple algorithm (MU) that minimizes the upper bound g(X) = \u2211 i\u2208X f(i) [12] (this is identical to the first iteration of MMin-I), and a more complex algorithm (EA) that computes an approximation to the submodular polyhedron [13] and in many cases yields a theoretically optimal approximation.", "startOffset": 137, "endOffset": 141}, {"referenceID": 12, "context": "For constrained minimization, we compare MMin-I to two methods: a simple algorithm (MU) that minimizes the upper bound g(X) = \u2211 i\u2208X f(i) [12] (this is identical to the first iteration of MMin-I), and a more complex algorithm (EA) that computes an approximation to the submodular polyhedron [13] and in many cases yields a theoretically optimal approximation.", "startOffset": 290, "endOffset": 294}, {"referenceID": 12, "context": "We use a very hard cost function [13]", "startOffset": 33, "endOffset": 37}, {"referenceID": 30, "context": "Functions of type (1) and (2) have been used in speech and computer vision [31, 22, 17] and have reduced curvature (\u03baf < 1).", "startOffset": 75, "endOffset": 87}, {"referenceID": 21, "context": "Functions of type (1) and (2) have been used in speech and computer vision [31, 22, 17] and have reduced curvature (\u03baf < 1).", "startOffset": 75, "endOffset": 87}, {"referenceID": 16, "context": "Functions of type (1) and (2) have been used in speech and computer vision [31, 22, 17] and have reduced curvature (\u03baf < 1).", "startOffset": 75, "endOffset": 87}, {"referenceID": 7, "context": "[8] shows that ES(f(S)) \u2265 1 4f(X \u2217).", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "We now use a result by [8] showing that if a set X is a local optimum, then f(X) \u2265 13f(X \u2217) if f is a general non-negative submodular set function and f(X) \u2265 1 2f(X \u2217) if f is a symmetric submodular function.", "startOffset": 23, "endOffset": 26}, {"referenceID": 7, "context": "If the set is an \u03b7-approximate local optimum, we obtain a 13 \u2212 \u03b7 approximation [8].", "startOffset": 79, "endOffset": 82}, {"referenceID": 7, "context": "Note that even finding an exact local maximum is hard for submodular functions [8], and therefore it is necessary to resort to an \u03b7-approximate version, which converges to an \u03b7-approximate local maximum.", "startOffset": 79, "endOffset": 82}, {"referenceID": 7, "context": "This schedule is equivalent to the deterministic local search (DLS) algorithm by [8], and therefore achieves an approximation factor of 1/3\u2212 \u03b7.", "startOffset": 81, "endOffset": 84}, {"referenceID": 3, "context": "Likewise, the deterministic bi-directional greedy algorithm by [4] induces a distinct permutation of the ground set.", "startOffset": 63, "endOffset": 66}, {"referenceID": 3, "context": "Given an initial ordering \u03c4 , the bi-directional greedy algorithm by [4] generates a chain of sets.", "startOffset": 69, "endOffset": 72}, {"referenceID": 3, "context": "The last inequality follows from the approximation factor satisfied by S [4].", "startOffset": 73, "endOffset": 76}, {"referenceID": 3, "context": "Like its deterministic variant, the randomized bi-directional greedy algorithm by [4] can be shown to run MMax with a specific subgradient.", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "Like its deterministic counterpart, the Randomized bi-directional Greedy algorithm (RG) by [4] induces a (random) permutation \u03c3 based on an initial ordering \u03c4 .", "startOffset": 91, "endOffset": 94}, {"referenceID": 3, "context": "The last inequality follows from a result in [4].", "startOffset": 45, "endOffset": 48}, {"referenceID": 38, "context": "The last inequality follows from [39, 5].", "startOffset": 33, "endOffset": 40}, {"referenceID": 4, "context": "The last inequality follows from [39, 5].", "startOffset": 33, "endOffset": 40}, {"referenceID": 29, "context": "The following result then follows from [30, 43].", "startOffset": 39, "endOffset": 47}, {"referenceID": 42, "context": "The following result then follows from [30, 43].", "startOffset": 39, "endOffset": 47}, {"referenceID": 26, "context": "In particular, some recent algorithms [27, 28] propose local search based techniques to obtain constant factor approximations for non-monotone submodular maximization under knapsack and matroid constraints.", "startOffset": 38, "endOffset": 46}, {"referenceID": 27, "context": "In particular, some recent algorithms [27, 28] propose local search based techniques to obtain constant factor approximations for non-monotone submodular maximization under knapsack and matroid constraints.", "startOffset": 38, "endOffset": 46}, {"referenceID": 6, "context": "Known hardness results [7] imply that this permutation may not be obtainable in polynomial time.", "startOffset": 23, "endOffset": 26}, {"referenceID": 8, "context": "To show that this holds for arbitrary X (and correspondingly at every iteration), we use that the submodular subdifferential can be expressed as a direct product between a submodular polyhedron and an anti-submodular polyhedron [9].", "startOffset": 228, "endOffset": 231}, {"referenceID": 8, "context": "Any problem involving an optimization over the sub-differential, can then be expressed as an optimization over a submodular polyhedron (which is a subdifferential at the empty set) and an anti-submodular polyhedron (which is a subdifferential at V ) [9].", "startOffset": 250, "endOffset": 253}, {"referenceID": 28, "context": "As a test function, we use the objective of [29], f(X) = \u2211 i\u2208V \u2211 j\u2208X sij \u2212 \u03bb \u2211 i,j\u2208X sij , where \u03bb is a redundancy parameter.", "startOffset": 44, "endOffset": 48}, {"referenceID": 28, "context": "Our real-world data is the Speech Training data subset selection problem [29] on the TIMIT corpus [11], using the string kernel metric [41] for similarity.", "startOffset": 73, "endOffset": 77}, {"referenceID": 10, "context": "Our real-world data is the Speech Training data subset selection problem [29] on the TIMIT corpus [11], using the string kernel metric [41] for similarity.", "startOffset": 98, "endOffset": 102}, {"referenceID": 40, "context": "Our real-world data is the Speech Training data subset selection problem [29] on the TIMIT corpus [11], using the string kernel metric [41] for similarity.", "startOffset": 135, "endOffset": 139}, {"referenceID": 13, "context": "We use 20 \u2264 n \u2264 30 so that the exact solution can still be computed with the algorithm of [14].", "startOffset": 90, "endOffset": 94}, {"referenceID": 7, "context": "RS achieves a 1/4 approximation in expectation [8].", "startOffset": 47, "endOffset": 50}, {"referenceID": 13, "context": "Importantly, the MMax variants are extremely fast, about 200-500 times faster than the exact branch and bound technique of [14].", "startOffset": 123, "endOffset": 127}, {"referenceID": 36, "context": "This framework is akin to the class of algorithms for minimizing the difference between submodular functions [37, 17].", "startOffset": 109, "endOffset": 117}, {"referenceID": 16, "context": "This framework is akin to the class of algorithms for minimizing the difference between submodular functions [37, 17].", "startOffset": 109, "endOffset": 117}, {"referenceID": 18, "context": "divergences derived from submodular functions [19].", "startOffset": 46, "endOffset": 50}, {"referenceID": 15, "context": "Relaxations have been applied to some constrained [16] and unconstrained [2] minimization problems as well as maximization problems [4].", "startOffset": 50, "endOffset": 54}, {"referenceID": 1, "context": "Relaxations have been applied to some constrained [16] and unconstrained [2] minimization problems as well as maximization problems [4].", "startOffset": 73, "endOffset": 76}, {"referenceID": 3, "context": "Relaxations have been applied to some constrained [16] and unconstrained [2] minimization problems as well as maximization problems [4].", "startOffset": 132, "endOffset": 135}], "year": 2013, "abstractText": "We present a practical and powerful new framework for both unconstrained and constrained submodular function optimization based on discrete semidifferentials (suband super-differentials). The resulting algorithms, which repeatedly compute and then efficiently optimize submodular semigradients, offer new and generalize many old methods for submodular optimization. Our approach, moreover, takes steps towards providing a unifying paradigm applicable to both submodular minimization and maximization, problems that historically have been treated quite distinctly. The practicality of our algorithms is important since interest in submodularity, owing to its natural and wide applicability, has recently been in ascendance within machine learning. We analyze theoretical properties of our algorithms for minimization and maximization, and show that many state-of-the-art maximization algorithms are special cases. Lastly, we complement our theoretical analyses with supporting empirical experiments.", "creator": "LaTeX with hyperref package"}}}