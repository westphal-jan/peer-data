{"id": "1311.6591", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Nov-2013", "title": "On the Complexity and Approximation of Binary Evidence in Lifted Inference", "abstract": "Lifted inference algorithms exploit symmetries in probabilistic models to speed up inference. They show impressive performance when calculating unconditional probabilities in relational models, but often resort to non-lifted inference when computing conditional probabilities. The reason is that conditioning on evidence breaks many of the model's symmetries, which can preempt standard lifting techniques. Recent theoretical results show, for example, that conditioning on evidence which corresponds to binary relations is #P-hard, suggesting that no lifting is to be expected in the worst case. In this paper, we balance this negative result by identifying the Boolean rank of the evidence as a key parameter for characterizing the complexity of conditioning in lifted inference. In particular, we show that conditioning on binary evidence with bounded Boolean rank is efficient. This opens up the possibility of approximating evidence by a low-rank Boolean matrix factorization, which we investigate both theoretically and empirically. Our results suggest that the results for higher order theory are robust.", "histories": [["v1", "Tue, 26 Nov 2013 08:39:49 GMT  (147kb,D)", "http://arxiv.org/abs/1311.6591v1", "To appear in Advances in Neural Information Processing Systems 26 (NIPS), Lake Tahoe, USA, December 2013"]], "COMMENTS": "To appear in Advances in Neural Information Processing Systems 26 (NIPS), Lake Tahoe, USA, December 2013", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["guy van den broeck", "adnan darwiche"], "accepted": true, "id": "1311.6591"}, "pdf": {"name": "1311.6591.pdf", "metadata": {"source": "CRF", "title": "On the Complexity and Approximation of Binary Evidence in Lifted Inference", "authors": ["Guy Van den Broeck"], "emails": ["guyvdb@cs.ucla.edu", "darwiche@cs.ucla.edu"], "sections": [{"heading": "1 Introduction", "text": "Statistical relational models are capable of representing both probabilistic dependencies and relational structure [1, 2]. Due to their first-order expressivity, they concisely represent probability distributions over a large number of propositional random variables, causing inference in these models to quickly become intractable. Lifted inference algorithms [3] attempt to overcome this problem by exploiting symmetries found in the relational structure of the model.\nIn the absence of evidence, exact lifted inference algorithms can work well. For large classes of statistical relational models [4], they perform inference that is polynomial in the number of objects in the model [5], and are therein exponentially faster than classical inference algorithms. When conditioning a query on a set of evidence literals, however, these lifted algorithms lose their advantage over classical ones. The intuitive reason is that evidence breaks the symmetries in the model. The technical reason is that these algorithms perform an operation called shattering, which ends up reducing the first-order model to a propositional one. This issue is implicitly reflected in the experiment sections of exact lifted inference papers. Most report on experiments without evidence. Examples include publications on FOVE [3, 6, 7] and WFOMC [8, 5]. Others found ways to efficiently deal with evidence on only unary predicates. They perform experiments without evidence on binary or higher-arity relations. There are examples for FOVE [9, 10], WFOMC [11], PTP [12] and CP [13].\nThis evidence problem has largely been ignored in the exact lifted inference literature, until recently, when Bui et al. [10] and Van den Broeck and Davis [11] showed that conditioning on unary evidence is tractable. More precisely, conditioning on unary evidence is polynomial in the size of evidence. This type of evidence expresses attributes of objects in the world, but not relations between them. Unfortunately, Van den Broeck and Davis [11] also showed that this tractability does not extend to\nar X\niv :1\n31 1.\n65 91\nv1 [\ncs .A\nI] 2\n6 N\nov 2\nevidence on binary relations, for which conditioning on evidence is #P-hard. Even if conditioning is hard in general, its complexity should depend on properties of the specific relation that is conditioned on. It is clear that some binary evidence is easy to condition on, even if it talks about a large number of objects, for example when all atoms are true (\u2200X,Y p(X,Y )) or false (\u2200X,Y \u00acp(X,Y )). As our first main contribution, we formalize this intuition and characterize the complexity of conditioning more precisely in terms of the Boolean rank of the evidence. We show that it is a measure of how much lifting is possible, and that one can efficiently condition on large amounts of evidence, provided that its Boolean rank is bounded.\nDespite the limitations, useful applications of exact lifted inference were found by sidestepping the evidence problem. For example, in lifted generative learning [14], the most challenging task is to compute partition functions without evidence. Regardless, the lack of symmetries in real applications is often cited as a reason for rejecting the idea of lifted inference entirely (informally called the \u201cdeath sentence for lifted inference\u201d). This problem has been avoided for too long, and as lifted inference gains maturity, solving it becomes paramount. As our second main contribution, we present a first general solution to the evidence problem. We propose to approximate evidence by an over-symmetric matrix, and will show that this can be achieved by minimizing Boolean rank. The need for approximating evidence is new and specific to lifted inference: in (undirected) probabilistic graphical models, more evidence typically makes inference easier. Practically, we will show that existing tools from the data mining community can be used for this low-rank Boolean matrix factorization task.\nThe evidence problem is less pronounced in the approximate lifted inference literature. These algorithms often introduce approximations that lead to symmetries in their computation, even when there are no symmetries in the model. Also for approximate methods, however, the benefits of lifting will decrease with the amount of symmetry-breaking evidence (e.g., Kersting et al. [15]). We will show experimentally that over-symmetric evidence approximation is also a viable technique for approximate lifted inference."}, {"heading": "2 Encoding Binary Relations in Unary", "text": "Our analysis of conditioning is based on a reduction, turning evidence on a binary relation into evidence on several unary predicates. We first introduce some necessary background."}, {"heading": "2.1 Background", "text": "An atom p(t1, . . . , tn) consists of a predicate p /n of arity n followed by n arguments, which are either (lowercase) constants or (uppercase) logical variables. A literal is an atom a or its negation \u00aca. A formula combines atoms with logical connectives (e.g., \u2228, \u2227,\u21d4). A formula is ground if it does not contain any logical variables. A possible world assigns a truth value to each ground atom. Statistical relational languages define a probability distribution over possible words, where ground atoms are individual random variables. Numerous languages have been proposed in recent years, and our analysis will apply to many, including MLNs [16], parfactors [3] and WFOMC problems [8]. Example 1. The following MLNs model the dependencies between web pages. A first, peer-to-peer model says that student web pages are more likely to link to other student pages.\nw studentpage(X) \u2227 linkto(X,Y )\u21d2 studentpage(Y ) It increases the probability of a world by a factor ew with every pair of pages X,Y that satisfies the formula. A second, hierarchical model says that professors are more likely to link to course pages.\nw profpage(X) \u2227 linkto(X,Y )\u21d2 coursepage(Y )\nIn this context, evidence e is a truth-value assignment to a set of ground atoms, and is often represented as a conjunction of literals. In unary evidence, atoms have one argument (e.g., studentpage(a)) while in binary evidence, they have two (e.g., linkto(a, b)). Without loss of generality, we assume full evidence on certain predicates (i.e., all their ground atoms are in e).1 We will sometimes represent unary evidence as a Boolean vector and binary evidence as a Boolean matrix.\n1Partial evidence on the relation p can be encoded as full evidence on predicates p0 and p1 by adding formulas \u2200X,Y p(X,Y ) \u21d0 p1(X,Y ) and \u2200X,Y \u00ac p(X,Y ) \u21d0 p0(X,Y ) to the model.\nExample 2. Evidence e = p(a, a)\u2227 p(a, b)\u2227\u00acp(a, c)\u2227 \u00b7 \u00b7 \u00b7 \u2227\u00ac p(d, c)\u2227 p(d, d) is represented by\nP =\n p(X,Y ) Y=a Y=b Y=c Y=d X=a 1 1 0 0 X=b 1 1 0 1 X=c 0 0 1 0\nX=d 1 0 0 1  We will look at computing conditional probabilities Pr(q | e) for single ground atoms q. Finally, we assume a representation language that can express universally quantified logical constraints."}, {"heading": "2.2 Vector-Product Binary Evidence", "text": "Certain binary relations can be represented by a pair of unary predicates. By adding the formula\n\u2200X, \u2200Y, p(X,Y )\u21d4 q(X) \u2227 r(Y ) (1) to our statistical relational model and conditioning on the q and r relations, we can condition on certain types of binary p relations. Assuming that we condition on the q and r predicates, adding this formula (as hard clauses) to the model does not change the probability distribution over the atoms in the original model. It is merely an indirect way of conditioning on the p relation.\nIf we now represent these unary relations by vectors q and r, and the binary relation by the binary matrix P, the above technique allows us to condition on any relation P that can be factorized in the outer vector product P = q r\u1d40. Example 3. Consider the following outer vector factorization of the Boolean matrix P.\nP = 0 0 0 01 0 0 10 0 0 0 1 0 0 1  = 010 1  100 1  \u1d40\nIn a model containing Formula 1, this factorization indicates that we can condition on the 16 binary evidence literals \u00acp(a, a) \u2227 \u00acp(a, b) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00ac p(d, c) \u2227 p(d, d) of P by conditioning on the the 8 unary literals \u00ac q(a) \u2227 q(b) \u2227 \u00ac q(c) \u2227 q(d) \u2227 r(a) \u2227 \u00ac r(b) \u2227 \u00ac r(c) \u2227 r(d) represented by q and r."}, {"heading": "2.3 Matrix-Product Binary Evidence", "text": "This idea of encoding a binary relation in unary relations can be generalized to n pairs of unary relations, by adding the following formula to our model.\n\u2200X, \u2200Y, p(X,Y )\u21d4 (q1(X) \u2227 r1(Y )) \u2228 (q2(X) \u2227 r2(Y )) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (qn(X) \u2227 rn(Y )) (2) By conditioning on the qi and ri relations, we can now condition on a much richer set of binary p relations. The relations that can be expressed this way are all the matrices that can be represented by the sum of outer products (in Boolean algebra, where + is \u2228 and 1 \u2228 1 = 1):\nP = q1 r \u1d40 1 \u2228q2 r \u1d40 2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 qn r\u1d40n = QR \u1d40 (3)\nwhere the columns of Q and R are the qi and ri vectors respectively, and the matrix multiplication is performed in Boolean algebra, that is,\n(QR\u1d40)i,j = \u2228\nr Qi,r \u2227Rj,r Example 4. Consider the following P, its decomposition into a sum/disjunction of outer vector products, and the corresponding Boolean matrix multiplication.\nP = 1 1 0 01 1 0 10 0 1 0 1 0 0 1  = 010 1  100 1  \u1d40 \u2228 110 0  110 0  \u1d40 \u2228 001 0  001 0  \u1d40 = 0 1 01 1 00 0 1 1 0 0  1 1 00 1 00 0 1 1 0 0  \u1d40\nThis factorization shows that we can condition on the binary evidence literals of P (see Example 2) by conditioning on the unary literals\ne = [\u00ac q1(a) \u2227 q1(b) \u2227 \u00ac q1(c) \u2227 q1(d)] \u2227 [r1(a) \u2227 \u00ac r1(b) \u2227 \u00ac r1(c) \u2227 r1(d)] \u2227 [q2(a) \u2227 q2(b) \u2227 \u00ac q2(c) \u2227 \u00ac q2(d)] \u2227 [r2(a) \u2227 r2(b) \u2227 \u00ac r2(c) \u2227 \u00ac r2(d)] \u2227 [\u00ac q3(a) \u2227 \u00ac q3(b) \u2227 q3(c) \u2227 \u00ac q3(d)] \u2227 [\u00ac r3(a) \u2227 \u00ac r3(b) \u2227 r3(c) \u2227 \u00ac r3(d)] ."}, {"heading": "3 Boolean Matrix Factorization", "text": "Matrix factorization (or decomposition) is a popular linear algebra tool. Some well-known instances are singular value decomposition and non-negative matrix factorization (NMF) [17, 18]. NMF factorizes into a product of non-negative matrices, which are more easily interpretable, and therefore attracted much attention for unsupervised learning and feature extraction. These factorizations all work with real-valued matrices. We instead consider Boolean-valued matrices, with only 0/1 entries."}, {"heading": "3.1 Boolean Rank", "text": "Factorizing a matrix P as QR\u1d40 in Boolean algebra is a known problem called Boolean Matrix Factorization (BMF) [19, 20]. BMF factorizes a (k \u00d7 l) matrix P into a (k \u00d7 n) matrix Q and a (l \u00d7 n) matrix R, where potentially n k and n l and we always have that n \u2264 min(k, l). Any Boolean matrix can be factorized this way and the smallest number n for which it is possible is called the Boolean rank of the matrix. Unlike (textbook) real-valued rank, computing the Boolean rank is NP-hard and cannot be approximated unless P=NP [19]. The Boolean and real-valued rank are incomparable, and the Boolean rank can be exponentially smaller than the real-valued rank. Example 5. The factorization in Example 4 is a BMF with Boolean rank 3. It is only a decomposition in Boolean algebra and not over the real numbers. Indeed, the matrix product over the reals contains an incorrect value of 2:0 1 01 1 00 0 1\n1 0 0\n\u00d7real 1 1 00 1 00 0 1\n1 0 0\n \u1d40 = 1 1 0 02 1 0 10 0 1 0 1 0 0 1  6= P Note that P is of full real-valued rank (having four non-zero singular values) and that its Boolean rank is lower than its real-valued rank."}, {"heading": "3.2 Approximate Boolean Factorization", "text": "Computing Boolean ranks is a theoretical problem. Because most real-world matrices will have nearly full rank (i.e., almost min(k, l)), applications of BMF look at approximate factorizations. The goal is to find a pair of (small) Boolean matrices Qk\u00d7n and Rl\u00d7n such that Pk\u00d7l \u2248 ( Qk\u00d7n R \u1d40 l\u00d7n ) , or more specifically, to find matrices that optimize some objective that trades off approximation error and Boolean rank n. When n k and n l, this approximation extracts interesting structure and removes noise from the matrix. This has caused BMF to receive considerable attention in the data mining community recently, as a tool for analyzing high-dimensional data. It is used to find important and interpretable (i.e., Boolean) concepts in a data matrix.\nUnfortunately, the approximate BMF optimization problem is NP-hard as well, and inapproximable [20]. However, several algorithms have been proposed that work well in practice. Algorithms exist that find good approximations for fixed values of n [20], or when P is sparse [21]. BMF is related to other data mining tasks, such as biclustering [22] and tiling databases [23], whose algorithms could also be used for approximate BMF. In the context of social network analysis, BMF is related to stochastic block models [24] and their extensions, such as infinite relational models."}, {"heading": "4 Complexity of Binary Evidence", "text": "Our goal in this section is to provide a new complexity result for reasoning with binary evidence in the context of lifted inference. Our result can be thought of as a parametrized complexity result, similar to ones based on treewidth in the case of propositional inference. To state the new result, however, we must first define formally the computational task. We will also review the key complexity result that is known about this computation now (i.e., the one we will be improving on).\nConsider an MLN \u2206 and let \u0393m contain a set of ground literals representing binary evidence. That is, for some binary predicate p(X,Y ), evidence \u0393m contains precisely one literal (positive or negative) for each grounding of predicate p(X,Y ). Here, m represents the number of objects that parameters X and Y may take.2 Therefore, evidence \u0393m must contain precisely m2 literals.\n2We assume without loss of generality that all logical variables range over the same set of objects.\nSuppose now that Prm is the distribution induced by MLN \u2206 over m objects, and q is a ground literal. Our analysis will apply to classes of models \u2206 that are domain-liftable [4], which means that the complexity of computing Prm(q) without evidence is polynomial in m. One such class is the set of MLNs with two logical variables per formula [5].\nOur task is then to compute the posterior probability Prm(q|em), where em is a conjunction of the ground literals in binary evidence \u0393m. Moreover, our goal here is to characterize the complexity of this computation as a function of evidence size m.\nThe following recent result provides a lower bound on the complexity of this computation [11]. Theorem 1. Suppose that evidence \u0393m is binary. Then there exists a domain-liftable MLN \u2206 with a corresponding distribution Prm, and a posterior marginal Prm(q|em) that cannot be computed by any algorithm whose complexity grows polynomially in evidence size m, unless P = NP .\nThis is an analogue to results according to which, for example, the complexity of computing posterior probabilities in propositional graphical models is exponential in the worst case. Yet, for these models, the complexity of inference can be parametrized, allowing one to bound the complexity of inference on some models. Perhaps the best example of such a parametrized complexity is the one based on treewidth, which can be thought of as a measure of the model\u2019s sparsity (or tree-likeness). In this case, inference can be shown to be linear in the size of the model and exponential only in its treewidth. Hence, this parametrized complexity result allows us to state that inference can be done efficiently on models with bounded treewidth.\nWe now provide a similar parameterized complexity result, but for evidence in lifted inference. In this case, the parameter we use to characterize complexity is that of Boolean rank. Theorem 2. Suppose that evidence \u0393m is binary and has a bounded Boolean rank. Then for every domain-liftable MLN \u2206 and corresponding distribution Prm, the complexity of computing posterior marginal Prm(q|em) grows polynomially in evidence size m.\nThe proof of this theorem is based on the reduction from binary to unary evidence, which is described in Section 2. In particular, our reduction first extends the MLN \u2206 with Formula 2, leading to the new MLN \u2206\u2032 and new pairs of unary predicates qi and ri. This does not change the domain-liftability of \u2206\u2032, as Formula 2 is itself liftable. We then replace binary evidence \u0393m by unary evidence \u0393\u2032. That is, the ground literals of the binary predicate p are replaced by ground literals of the unary predicates qi and ri (see Example 4). This unary evidence is obtained by Boolean matrix factorization. As the matrix size in our reduction is m2, the following Lemma implies that the first step of our reduction is polynomial in m for bounded rank evidence. Lemma 3 (Miettinen [25]). The complexity of Boolean matrix factorization for matrices with bounded Boolean rank is polynomial in their size.\nThe main observation in our reduction is that Formula 2 has size n, which is the Boolean rank of the given binary evidence. Hence, when the Boolean rank n is bounded by a constant, the size of the extended MLN \u2206\u2032 is independent of the evidence size and is proportional to the size of the original MLN \u2206.\nWe have now reduced inference on MLN \u2206 and binary evidence \u0393m into inference on an extended MLN \u2206\u2032 and unary evidence \u0393\u2032. The second observation behind the proof is the following. Lemma 4 (Van den Broeck and Davis [11], Van den Broeck [26]). Suppose that evidence \u0393m is unary. Then for every domain-liftable MLN \u2206 and corresponding distribution Prm, the complexity of computing posterior marginal Prm(q|em) grows polynomially in evidence size m.\nHence, computing posterior probabilities can be done in time which is polynomial in the size of unary evidence m, which completes our proof.\nWe can now identify additional similarities between treewidth and Boolean rank. Exact inference algorithms for probabilistic graphical models typically perform two steps, namely to (a) compute a tree decomposition of the graphical model (or a corresponding variable order), and (b) perform inference that is polynomial in the size of the decomposition, but potentially exponential in its (tree)width. The analogous steps for conditioning are to (a) perform a BMF, and (b) perform inference that is polynomial in the size of the BMF, but potentially exponential in its rank. The (a) steps are both NP-hard, yet are efficient assuming bounded treewidth [27] or bounded Boolean rank (Lemma 3). Whereas\ntreewidth is a measure of tree-likeness and sparsity of the graphical model, Boolean rank seems to be a fundamentally different property, more related to the presence of symmetries in evidence."}, {"heading": "5 Over-Symmetric Evidence Approximation", "text": "Theorem 2 opens up many new possibilities. Even for evidence with high Boolean rank, it is possible to find a low-rank approximate BMF of the evidence, as is commonly done for other data mining and machine learning problems. Algorithms already exist for solving this task (cf. Section 3).\nExample 6. The evidence matrix from Example 4 has Boolean rank three. Dropping the third pair of vectors reduces the Boolean rank to two.1 1 0 01 1 0 10 0 1 0\n1 0 0 1\n \u2248 010\n1\n 100\n1\n \u1d40 \u2228 110 0  110 0  \u1d40 @\n@ @ @ @@ \u2228\n001 0  001 0  \u1d40 = 0 11 10 0 1 0  1 10 10 0 1 0  \u1d40 = 1 1 0 01 1 0 10 0 0 0 1 0 0 1  This factorization is approximate, as it flips the evidence for atom p(c, c) from true to false (represented by the bold 0). By paying this price, the evidence has more symmetries, and we can condition on the binary relation by introducing only two instead of three new pairs (qi, ri) of unary predicates.\nLow-rank approximate BMF is an instance of a more general idea; that of over-symmetric evidence approximation. This means that when we want to compute Pr(q | e), we approximate it by computing Pr(q | e\u2032) instead, with evidence e\u2032 that permits more efficient inference. In this case, it is more efficient because it maintains more symmetries of the model and permits more lifting. Because all lifted inference algorithms, exact or approximate, exploit symmetries, we expect this general idea, and low-rank approximate BMF in particular, to improve the performance of any lifted inference algorithm.\nHaving a small amount of incorrect evidence in the approximation need not be a problem. As these literals are not covered by the first most important vector pairs, they can be considered as noise in the original matrix. Hence, a low-rank approximation may actually improve the performance of, for example, a lifted collective classification algorithm. On the other hand, the approximation made in Example 6 may not be desirable if we are querying attributes of the constant c, and we may prefer to approximate other areas of the evidence matrix instead. There are many challenges in finding appropriate evidence approximations, which makes the task all the more interesting."}, {"heading": "6 Empirical Evaluation", "text": "To complement the theoretical analysis from the previous sections, we will now report on experiments that investigate the following practical questions.\nQ1 How well can we approximate a real-world relational data set by a low-rank Boolean matrix? Q2 Is Boolean rank a good indicator of the complexity of inference, as suggested by Theorem 2? Q3 Is over-symmetric evidence approximation a viable technique for approximate lifted inference?\nTo answer Q1, we compute approximations of the linkto binary relation in the WebKB data set using the ASSO algorithm for approximate BMF [20]. The WebKB data set consists of web pages from the computer science departments of four universities [28]. The data has information about words that appear on pages, labels of pages and links between web pages (linkto relation). There are four folds, one for each university. The exact evidence matrix for the linkto relation ranges in size from 861 by 861 to 1240 by 1240. Its real-valued rank ranges from 384 to 503. Performing a BMF approximation in this domain adds or removes hyperlinks between web pages, so that more web pages can be grouped together that behave similarly.\nFigure 1 plots the approximation error for increasing Boolean ranks, measured as the number of incorrect evidence literals. The error goes down quickly for low rank, and is reduced by half after Boolean rank 70 to 80, even though the matrix dimensions and real-valued rank are much higher. Note that these evidence matrices contain around a million entries, and are sparse. Hence, these approximations correctly label 99.7% to 99.95% of the atoms.\nTo answer Q2, we perform two sets of experiments. Firstly, we look at exact lifted inference and investigate the influence of adding Formula 2 to the \u201cpeer-to-peer\u201d and \u201chierarchical\u201d MLNs from Example 1. The goals is to condition on linkto relations with increasing rank n. These models are compiled using the WFOMC [8] algorithm into first-order NNF circuits, which allow for exact domain-lifted inference (c.f., Lemma 4). Table 2 shows the sizes of these circuits. As expected, circuit sizes grow exponentially with n. Evidence breaks more symmetries in the peer-to-peer model than in the hierarchical model, causing the circuit size to increase more quickly with Boolean rank.\nSince the connection between rank and exact inference is obvious from Theorem 2, the more interesting question in Q2 is whether Boolean rank is indicative of the complexity of approximate lifted inference as well. Therefore, we investigate its influence on the Lifted MCMC algorithm (LMCMC) [29] with Rao-Blackwellized probability estimation [30]. LMCMC interleaves standard MCMC steps (here Gibbs sampling) with jumps to states that are symmetric in the graphical model, in order to speed up mixing of the chain. We run LMCMC on the WebKB MLN of Davis and Domingos [31], which has 333 first-order formulas and over 1 million random variables. It classifies web pages into 6 categories, based on their link structure and the 50 most predictive words they contain. We learn its parameters with the Alchemy package and obtain evidence sets of varying Boolean rank from the factorizations of Figure 1.3. For these, we run both vanilla and lifted MCMC, and measure the KL divergence (KLD) between the marginal distribution at each iteration4, and a ground truth obtained from 3 million iterations on the corresponding evidence set. Figure 3 plots the KLD of LMCMC divided by the KLD of MCMC. It shows that the improvement of LMCMC over MCMC goes down with Boolean rank, answering Q2 positively.\nTo answer Q3, we look at the KLD between different evidence approximations Pr(. | e\u2032n) of rank n, and the true marginals Pr(. | e) conditioned on exact evidence. As this requires a good estimate of Pr(. | e), we make our learned WebKB model more tractable by removing formulas about word content. For two approximations e\u2032a and e \u2032 b such that rank a < b, we expect LMCMC to converge faster to Pr(. | e\u2032a) than to Pr(. | e\u2032b), as suggested by Figure 3. However, because Pr(. | e\u2032a) is a more crude approximation of Pr(. | e) than Pr(. | e\u2032b) is, the KLD at convergence should be worse for a\n3 When synthetically generating evidence of these ranks, results are comparable. 4 Runtime per iteration is comparable for both algorithms. BMF runtime is negligible.\nthan for b. Hence, we expect to see a trade-off, where the lowest ranks are optimal in the beginning, higher ranks become optimal later one, and the exact model is optimal at convergence.\nFigure 4 shows exactly that, for a representative sample of ranks and data sets. In Figure 4(a), rank 2 and 10 outperform LMCMC with the exact evidence at first. Exact evidence overtakes rank 2 after 40k iterations, and rank 10 after 50k. After 80k iterations, even non-lifted MCMC outperforms these crude approximations. Figure 4(b) shows the other side of the spectrum, where a rank 75 and 150 approximation are overtaken at iterations 90k and 125k. Figure 4(c) is representative of other datasets. Note here that at around iteration 50k, rank 75 in turn outperforms the rank 150 approximation, which has fewer symmetries and does not permit as much lifting. Finally, Figure 4(d) shows the ideal case for low-rank approximation. This is the largest dataset, and therefore the most challenging inference task. Here, LMCMC on e converges slowly compared to its approximations e\u2032, and e\u2032 results in almost perfect marginals. The crossover point where exact inference outperforms the approximation is never reached in practice. This answers Q3 positively."}, {"heading": "7 Conclusions", "text": "We presented two main results. The first is a more precise complexity characterization of conditioning on binary evidence, in terms of its Boolean rank. The second is a technique to approximate binary evidence by a low-rank Boolean matrix factorization. This is a first type of over-symmetric evidence approximation that can speed up lifted inference. We showed empirically that low-rank BMF speeds up approximate inference, leading to improved approximations.\nFor future work, we want to evaluate the practical implications of the theory developed for other lifted inference algorithms, such as lifted BP, and look at the performance of over-symmetric evidence approximation on machine learning tasks such as collective classification. There are many remaining challenges in finding good evidence-approximation schemes, including ones that are query-specific (cf. de Salvo Braz et al. [32]) or that incrementally run inference to find better approximations (cf. Kersting et al. [33]). Furthermore, we want to investigate other subsets of binary relations for which conditioning could be efficient, in particular functional relations p(X,Y ), where each X has at most a limited number of associated Y values."}, {"heading": "Acknowledgments", "text": "We thank Pauli Miettinen, Mathias Niepert, and Jilles Vreeken for helpful suggestions. This work was supported by ONR grant #N00014-12-1-0423, NSF grant #IIS-1118122, NSF grant #IIS0916161, and the Research Foundation-Flanders (FWO-Vlaanderen)."}], "references": [{"title": "editors", "author": ["L. Getoor", "B. Taskar"], "venue": "An Introduction to Statistical Relational Learning. MIT Press", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "Probabilistic inductive logic programming: theory and applications", "author": ["Luc De Raedt", "Paolo Frasconi", "Kristian Kersting", "Stephen Muggleton", "editors"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2008}, {"title": "First-order probabilistic inference", "author": ["David Poole"], "venue": "In Proceedings of IJCAI, pages 985\u2013991,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "Liftability of probabilistic inference: Upper and lower bounds", "author": ["Manfred Jaeger", "Guy Van den Broeck"], "venue": "In Proceedings of the 2nd International Workshop on Statistical Relational AI,,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2012}, {"title": "Lifted first-order probabilistic inference", "author": ["Rodrigo de Salvo Braz", "Eyal Amir", "Dan Roth"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2005}, {"title": "Lifted probabilistic inference with counting formulas", "author": ["B. Milch", "L.S. Zettlemoyer", "K. Kersting", "M. Haimes", "L.P. Kaelbling"], "venue": "Proceedings of the 23rd AAAI Conference on Artificial Intelligence", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2008}, {"title": "Lifted probabilistic inference by first-order knowledge compilation", "author": ["Guy Van den Broeck", "Nima Taghipour", "Wannes Meert", "Jesse Davis", "Luc De Raedt"], "venue": "In Proceedings of IJCAI,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Lifted variable elimination with arbitrary constraints", "author": ["N. Taghipour", "D. Fierens", "J. Davis", "H. Blockeel"], "venue": "Proceedings of the 15th International Conference on Artificial Intelligence and Statistics", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "and R", "author": ["H.H. Bui", "T.N. Huynh"], "venue": "de Salvo Braz. Exact lifted inference with distinct soft evidence on every object. In Proceedings of the 26th AAAI Conference on Artificial Intelligence", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Conditioning in first-order knowledge compilation and lifted probabilistic inference", "author": ["Guy Van den Broeck", "Jesse Davis"], "venue": "In Proceedings of the 26th AAAI Conference on Artificial Intelligence,,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Probabilistic theorem proving", "author": ["Vibhav Gogate", "Pedro Domingos"], "venue": "In Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Lifted inference seen from the other side: The tractable features", "author": ["A. Jha", "V. Gogate", "A. Meliou", "D. Suciu"], "venue": "Proceedings of the 24th Conference on Neural Information Processing Systems (NIPS)", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2010}, {"title": "Lifted generative parameter learning", "author": ["Guy Van den Broeck", "Wannes Meert", "Jesse Davis"], "venue": "In Statistical Relational AI (StaRAI) workshop,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2013}, {"title": "Counting belief propagation", "author": ["K. Kersting", "B. Ahmadi", "S. Natarajan"], "venue": "Proceedings of the 25th Conference on Uncertainty in Artificial Intelligence (UAI), pages 277\u2013284", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "Markov logic networks", "author": ["M. Richardson", "P. Domingos"], "venue": "Machine learning, 62(1):107\u2013136", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2006}, {"title": "Algorithms for non-negative matrix factorization", "author": ["D. Seung", "L. Lee"], "venue": "Advances in neural information processing systems, 13:556\u2013562", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2001}, {"title": "Algorithms and applications for approximate nonnegative matrix factorization", "author": ["M. Berry", "M. Browne", "A. Langville", "V. Pauca", "R. Plemmons"], "venue": "Computational Statistics and Data Analysis", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2006}, {"title": "The discrete basis problem", "author": ["Pauli Miettinen", "Taneli Mielik\u00e4inen", "Aristides Gionis", "Gautam Das", "Heikki Mannila"], "venue": "In Knowledge Discovery in Databases,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2006}, {"title": "The discrete basis problem", "author": ["Pauli Miettinen", "Taneli Mielikainen", "Aristides Gionis", "Gautam Das", "Heikki Mannila"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2008}, {"title": "Sparse Boolean matrix factorizations", "author": ["Pauli Miettinen"], "venue": "In IEEE 10th International Conference on Data Mining (ICDM),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2010}, {"title": "Mathematical classification and clustering, volume 11", "author": ["Boris Mirkin"], "venue": "Kluwer Academic Pub,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1996}, {"title": "Tiling databases", "author": ["Floris Geerts", "Bart Goethals", "Taneli Mielik\u00e4inen"], "venue": "In Discovery science,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2004}, {"title": "Stochastic blockmodels: First steps", "author": ["Paul W Holland", "Kathryn Blackmond Laskey", "Samuel Leinhardt"], "venue": "Social networks,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1983}, {"title": "Matrix decomposition methods for data mining: Computational complexity and algorithms", "author": ["Pauli Miettinen"], "venue": "PhD thesis,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2009}, {"title": "Lifted Inference and Learning in Statistical Relational Models", "author": ["Guy Van den Broeck"], "venue": "PhD thesis,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2013}, {"title": "Treewidth: Algorithmic techniques and results", "author": ["Hans L Bodlaender"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1997}, {"title": "Relational learning with statistical predicate invention: Better models for hypertext", "author": ["M. Craven", "S. Slattery"], "venue": "Machine Learning Journal, 43(1/2):97\u2013119", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2001}, {"title": "Markov chains on orbits of permutation groups", "author": ["Mathias Niepert"], "venue": "In Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2012}, {"title": "Symmetry-aware marginal density estimation", "author": ["Mathias Niepert"], "venue": "In Proceedings of the 27th Conference on Artificial Intelligence (AAAI),", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2013}, {"title": "Deep transfer via second-order markov logic", "author": ["Jesse Davis", "Pedro Domingos"], "venue": "In Proceedings of the 26th annual international conference on machine learning,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2009}, {"title": "Anytime lifted belief propagation", "author": ["R. de Salvo Braz", "S. Natarajan", "H. Bui", "J. Shavlik", "S. Russell"], "venue": "Proceedings of the 6th International Workshop on Statistical Relational Learning,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2009}, {"title": "Informed lifting for message-passing", "author": ["K. Kersting", "Y. El Massaoudi", "B. Ahmadi", "F. Hadiji"], "venue": "Proceedings of the 24th AAAI Conference on Artificial Intelligence,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "Statistical relational models are capable of representing both probabilistic dependencies and relational structure [1, 2].", "startOffset": 115, "endOffset": 121}, {"referenceID": 1, "context": "Statistical relational models are capable of representing both probabilistic dependencies and relational structure [1, 2].", "startOffset": 115, "endOffset": 121}, {"referenceID": 2, "context": "Lifted inference algorithms [3] attempt to overcome this problem by exploiting symmetries found in the relational structure of the model.", "startOffset": 28, "endOffset": 31}, {"referenceID": 3, "context": "For large classes of statistical relational models [4], they perform inference that is polynomial in the number of objects in the model [5], and are therein exponentially faster than classical inference algorithms.", "startOffset": 51, "endOffset": 54}, {"referenceID": 2, "context": "Examples include publications on FOVE [3, 6, 7] and WFOMC [8, 5].", "startOffset": 38, "endOffset": 47}, {"referenceID": 4, "context": "Examples include publications on FOVE [3, 6, 7] and WFOMC [8, 5].", "startOffset": 38, "endOffset": 47}, {"referenceID": 5, "context": "Examples include publications on FOVE [3, 6, 7] and WFOMC [8, 5].", "startOffset": 38, "endOffset": 47}, {"referenceID": 6, "context": "Examples include publications on FOVE [3, 6, 7] and WFOMC [8, 5].", "startOffset": 58, "endOffset": 64}, {"referenceID": 7, "context": "There are examples for FOVE [9, 10], WFOMC [11], PTP [12] and CP [13].", "startOffset": 28, "endOffset": 35}, {"referenceID": 8, "context": "There are examples for FOVE [9, 10], WFOMC [11], PTP [12] and CP [13].", "startOffset": 28, "endOffset": 35}, {"referenceID": 9, "context": "There are examples for FOVE [9, 10], WFOMC [11], PTP [12] and CP [13].", "startOffset": 43, "endOffset": 47}, {"referenceID": 10, "context": "There are examples for FOVE [9, 10], WFOMC [11], PTP [12] and CP [13].", "startOffset": 53, "endOffset": 57}, {"referenceID": 11, "context": "There are examples for FOVE [9, 10], WFOMC [11], PTP [12] and CP [13].", "startOffset": 65, "endOffset": 69}, {"referenceID": 8, "context": "[10] and Van den Broeck and Davis [11] showed that conditioning on unary evidence is tractable.", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[10] and Van den Broeck and Davis [11] showed that conditioning on unary evidence is tractable.", "startOffset": 34, "endOffset": 38}, {"referenceID": 9, "context": "Unfortunately, Van den Broeck and Davis [11] also showed that this tractability does not extend to", "startOffset": 40, "endOffset": 44}, {"referenceID": 12, "context": "For example, in lifted generative learning [14], the most challenging task is to compute partition functions without evidence.", "startOffset": 43, "endOffset": 47}, {"referenceID": 13, "context": "[15]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "Numerous languages have been proposed in recent years, and our analysis will apply to many, including MLNs [16], parfactors [3] and WFOMC problems [8].", "startOffset": 107, "endOffset": 111}, {"referenceID": 2, "context": "Numerous languages have been proposed in recent years, and our analysis will apply to many, including MLNs [16], parfactors [3] and WFOMC problems [8].", "startOffset": 124, "endOffset": 127}, {"referenceID": 6, "context": "Numerous languages have been proposed in recent years, and our analysis will apply to many, including MLNs [16], parfactors [3] and WFOMC problems [8].", "startOffset": 147, "endOffset": 150}, {"referenceID": 15, "context": "Some well-known instances are singular value decomposition and non-negative matrix factorization (NMF) [17, 18].", "startOffset": 103, "endOffset": 111}, {"referenceID": 16, "context": "Some well-known instances are singular value decomposition and non-negative matrix factorization (NMF) [17, 18].", "startOffset": 103, "endOffset": 111}, {"referenceID": 17, "context": "Factorizing a matrix P as QR in Boolean algebra is a known problem called Boolean Matrix Factorization (BMF) [19, 20].", "startOffset": 109, "endOffset": 117}, {"referenceID": 18, "context": "Factorizing a matrix P as QR in Boolean algebra is a known problem called Boolean Matrix Factorization (BMF) [19, 20].", "startOffset": 109, "endOffset": 117}, {"referenceID": 17, "context": "Unlike (textbook) real-valued rank, computing the Boolean rank is NP-hard and cannot be approximated unless P=NP [19].", "startOffset": 113, "endOffset": 117}, {"referenceID": 18, "context": "Unfortunately, the approximate BMF optimization problem is NP-hard as well, and inapproximable [20].", "startOffset": 95, "endOffset": 99}, {"referenceID": 18, "context": "Algorithms exist that find good approximations for fixed values of n [20], or when P is sparse [21].", "startOffset": 69, "endOffset": 73}, {"referenceID": 19, "context": "Algorithms exist that find good approximations for fixed values of n [20], or when P is sparse [21].", "startOffset": 95, "endOffset": 99}, {"referenceID": 20, "context": "BMF is related to other data mining tasks, such as biclustering [22] and tiling databases [23], whose algorithms could also be used for approximate BMF.", "startOffset": 64, "endOffset": 68}, {"referenceID": 21, "context": "BMF is related to other data mining tasks, such as biclustering [22] and tiling databases [23], whose algorithms could also be used for approximate BMF.", "startOffset": 90, "endOffset": 94}, {"referenceID": 22, "context": "In the context of social network analysis, BMF is related to stochastic block models [24] and their extensions, such as infinite relational models.", "startOffset": 85, "endOffset": 89}, {"referenceID": 3, "context": "Our analysis will apply to classes of models \u2206 that are domain-liftable [4], which means that the complexity of computing Prm(q) without evidence is polynomial in m.", "startOffset": 72, "endOffset": 75}, {"referenceID": 9, "context": "The following recent result provides a lower bound on the complexity of this computation [11].", "startOffset": 89, "endOffset": 93}, {"referenceID": 23, "context": "Lemma 3 (Miettinen [25]).", "startOffset": 19, "endOffset": 23}, {"referenceID": 9, "context": "Lemma 4 (Van den Broeck and Davis [11], Van den Broeck [26]).", "startOffset": 34, "endOffset": 38}, {"referenceID": 24, "context": "Lemma 4 (Van den Broeck and Davis [11], Van den Broeck [26]).", "startOffset": 55, "endOffset": 59}, {"referenceID": 25, "context": "The (a) steps are both NP-hard, yet are efficient assuming bounded treewidth [27] or bounded Boolean rank (Lemma 3).", "startOffset": 77, "endOffset": 81}, {"referenceID": 18, "context": "To answer Q1, we compute approximations of the linkto binary relation in the WebKB data set using the ASSO algorithm for approximate BMF [20].", "startOffset": 137, "endOffset": 141}, {"referenceID": 26, "context": "The WebKB data set consists of web pages from the computer science departments of four universities [28].", "startOffset": 100, "endOffset": 104}, {"referenceID": 6, "context": "These models are compiled using the WFOMC [8] algorithm into first-order NNF circuits, which allow for exact domain-lifted inference (c.", "startOffset": 42, "endOffset": 45}, {"referenceID": 27, "context": "Therefore, we investigate its influence on the Lifted MCMC algorithm (LMCMC) [29] with Rao-Blackwellized probability estimation [30].", "startOffset": 77, "endOffset": 81}, {"referenceID": 28, "context": "Therefore, we investigate its influence on the Lifted MCMC algorithm (LMCMC) [29] with Rao-Blackwellized probability estimation [30].", "startOffset": 128, "endOffset": 132}, {"referenceID": 29, "context": "We run LMCMC on the WebKB MLN of Davis and Domingos [31], which has 333 first-order formulas and over 1 million random variables.", "startOffset": 52, "endOffset": 56}, {"referenceID": 30, "context": "[32]) or that incrementally run inference to find better approximations (cf.", "startOffset": 0, "endOffset": 4}, {"referenceID": 31, "context": "[33]).", "startOffset": 0, "endOffset": 4}], "year": 2013, "abstractText": "Lifted inference algorithms exploit symmetries in probabilistic models to speed up inference. They show impressive performance when calculating unconditional probabilities in relational models, but often resort to non-lifted inference when computing conditional probabilities. The reason is that conditioning on evidence breaks many of the model\u2019s symmetries, which can preempt standard lifting techniques. Recent theoretical results show, for example, that conditioning on evidence which corresponds to binary relations is #P-hard, suggesting that no lifting is to be expected in the worst case. In this paper, we balance this negative result by identifying the Boolean rank of the evidence as a key parameter for characterizing the complexity of conditioning in lifted inference. In particular, we show that conditioning on binary evidence with bounded Boolean rank is efficient. This opens up the possibility of approximating evidence by a low-rank Boolean matrix factorization, which we investigate both theoretically and empirically.", "creator": "LaTeX with hyperref package"}}}