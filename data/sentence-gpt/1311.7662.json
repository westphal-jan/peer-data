{"id": "1311.7662", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Nov-2013", "title": "The Power of Asymmetry in Binary Hashing", "abstract": "When approximating binary similarity using the hamming distance between short binary hashes, we show that even if the similarity is symmetric, we can have shorter and more accurate hashes by using two distinct code maps. I.e. binary hashes in the short binary hash format. So to compute these two code maps, we just use the same hash type as above to find a binary hash where our function of course is the same as the string. The two methods are similar to the one described above. In the long binary hash format, you can also choose binary hashes for two different types of hashes (which in the short binary hash format also works in the long binary hash format). The results here show that even if the binary hash is symmetric, we can have a slightly stronger hash of a binary hash. In the long binary hash format, we have a similar hash as above.\n\n\nWhat are the differences between binary hashes for Binary hashes?\nDifference between binary hashes and Binary hashes is not something that has been studied by researchers at MIT. When a binary hash is found, the two binary hashes are identical to the two binary hashes of another binary hash. In binary hash format, both hashes are identical to the one previously found in binary hash. Binary hashes represent the same hash as the one previously found in binary hash.\nWhat about binary hashes?\nFor binary hashes, a binary hash is the most common way to find a binary hash by searching through the binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary hash, by comparing the two binary hashes of the previous binary", "histories": [["v1", "Fri, 29 Nov 2013 18:53:32 GMT  (118kb,D)", "http://arxiv.org/abs/1311.7662v1", "Accepted to NIPS 2013, 9 pages, 5 figures"]], "COMMENTS": "Accepted to NIPS 2013, 9 pages, 5 figures", "reviews": [], "SUBJECTS": "cs.LG cs.CV cs.IR", "authors": ["behnam neyshabur", "nati srebro", "ruslan salakhutdinov", "yury makarychev", "payman yadollahpour"], "accepted": true, "id": "1311.7662"}, "pdf": {"name": "1311.7662.pdf", "metadata": {"source": "CRF", "title": "The Power of Asymmetry in Binary Hashing", "authors": ["Behnam Neyshabur", "Payman Yadollahpour", "Yury Makarychev"], "emails": ["btavakoli@ttic.edu", "pyadolla@ttic.edu", "yury@ttic.edu", "rsalakhu@cs.toronto.edu", "nati@ttic.edu"], "sections": [{"heading": "1 Introduction", "text": "Encoding high-dimensional objects using short binary hashes can be useful for fast approximate similarity computations and nearest neighbor searches. Calculating the hamming distance between two short binary strings is an extremely cheap computational operation, and the communication cost of sending such hash strings for lookup on a server (e.g. sending hashes of all features or patches in an image taken on a mobile device) is low. Furthermore, it is also possible to quickly look up nearby hash strings in populated hash tables. Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13]. Moreover, compact binary codes are remarkably storage efficient, and allow one to store massive datasets in memory. It is therefore desirable to find short binary hashes that correspond well to some target notion of similarity. Pioneering work on Locality Sensitive Hashing used random linear thresholds for obtaining bits of the hash [1]. Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3]. More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] . It is important to obtain accurate and short hashes\u2014the computational and communication costs scale linearly with the length of the hash, and more importantly, the memory cost of the hash table can scale exponentially with the length.\nIn all the above-mentioned approaches, similarity S(x, x\u2032) between two objects is approximated by the hamming distance between the outputs of the same hash function, i.e. between f(x) and f(x\u2032), for some f \u2208 {\u00b11}k. The emphasis here is that the same hash function is applied to both x and x\u2032 (in methods like LSH multiple hashes might be used to boost accuracy, but the comparison is still between outputs of the same function).\nThe only exception we are aware of is where a single mapping of objects to fractional vectors f\u0303(x) \u2208 [\u22121, 1]k is used, its thresholding f(x) = sign f\u0303(x) \u2208 {\u00b11}k is used in the database, and similarity between x and x\u2032 is approximated using \u2329 f(x), f\u0303(x\u2032) \u232a . This has become known as \u201casymmetric hashing\u201d [2, 4], but even with such a-\nsymmetry, both mappings are based on the same fractional mapping f\u0303(\u00b7). That is, the asymmetry is in that one side of the comparison gets thresholded while the other is fractional, but not in the actual mapping.\nIn this paper, we propose using two distinct mappings f(x), g(x) \u2208 {\u00b11}k and approximating the similarity S(x, x\u2032) by the hamming distance between f(x) and g(x\u2032). We refer to such hashing schemes as \u201casymmetric\u201d. Our main result is that even if the target similarity function is symmetric and \u201cwell behaved\u201d (e.g., even if it is based on\nar X\niv :1\n31 1.\n76 62\nv1 [\ncs .L\nG ]\n2 9\nN ov\nEuclidean distances between objects), using asymmetric binary hashes can be much more powerful, and allow better approximation of the target similarity with shorter code lengths. In particular, we show extreme examples of collections of points in Euclidean space, where the neighborhood similarity S(x, x\u2032) can be realized using an asymmetric binary hash (based on a pair of distinct functions) of lengthO(r) bits, but where a symmetric hash (based on a single function) would require at least \u2126(2r) bits. Although actual data is not as extreme, our experimental results on real data sets demonstrate significant benefits from using asymmetric binary hashes.\nAsymmetric hashes can be used in almost all places where symmetric hashes are typically used, usually without any additional storage or computational cost. Consider the typical application of storing hash vectors for all objects in a database, and then calculating similarities to queries by computing the hash of the query and its hamming distance to the stored database hashes. Using an asymmetric hash means using different hash functions for the database and for the query. This neither increases the size of the database representation, nor the computational or communication cost of populating the database or performing a query, as the exact same operations are required. In fact, when hashing the entire database, asymmetric hashes provide even more opportunity for improvement. We argue that using two different hash functions to encode database objects and queries allows for much more flexibility in choosing the database hash. Unlike the query hash, which has to be stored compactly and efficiently evaluated on queries as they appear, if the database is fixed, an arbitrary mapping of database objects to bit strings may be used. We demonstrate that this can indeed increase similarity accuracy while reducing the bit length required."}, {"heading": "2 Minimum Code Lengths and the Power of Asymmetry", "text": "Let S : X \u00d7 X \u2192 {\u00b11} be a binary similarity function over a set of objects X , where we can interpret S(x, x\u2032) to mean that x and x\u2032 are \u201csimilar\u201d or \u201cdissimilar\u201d, or to indicate whether they are \u201cneighbors\u201d. A symmetric binary coding of X is a mapping f : X \u2192 {\u00b11}k, where k is the bit-length of the code. We are interested in constructing codes such that the hamming distance between f(x) and f(x\u2032) corresponds to the similarity S(x, x\u2032). That is, for some threshold \u03b8 \u2208 R, S(x, x\u2032) \u2248 sign(\u3008f(x), f(x\u2032)\u3009 \u2212 \u03b8). Although discussing the hamming distance, it is more convenient for us to work with the inner product \u3008u, v\u3009, which is equivalent to the hamming distance dh(u, v) since \u3008u, v\u3009 = (k \u2212 2dh(u, v)) for u, v \u2208 {\u00b11}k.\nIn this section, we will consider the problem of capturing a given similarity using an arbitrary binary code. That is, we are given the entire similarity mapping S, e.g. as a matrix S \u2208 {\u00b11}n\u00d7n over a finite domain X = {x1, . . . , xn} of n objects, with Sij = S(xi, xj). We ask for an encoding ui = f(xi) \u2208 {\u00b11}k of each object xi \u2208 X , and a threshold \u03b8, such that Sij = sign(\u3008ui, uj\u3009 \u2212 \u03b8), or at least such that equality holds for as many pairs (i, j) as possible. It is important to emphasize that the goal here is purely to approximate the given matrix S using a short binary code\u2014there is no out-of-sample generalization (yet).\nWe now ask: Can allowing an asymmetric coding enable approximating a symmetric similarity matrix S with a shorter code length?\nDenoting U \u2208 {\u00b11}n\u00d7k for the matrix whose columns contain the codewords ui, the minimal binary code length that allows exactly representing S is then given by the following matrix factorization problem:\nks(S) = min k,U,\u03b8 k s.t U \u2208 {\u00b11}k\u00d7n \u03b8 \u2208 R Y , U>U \u2212 \u03b81n \u2200ij SijYij > 0\n(1)\nwhere 1n is an n\u00d7 n matrix of ones. We begin demonstrating the power of asymmetry by considering an asymmetric variant of the above problem. That is, even if S is symmetric, we allow associating with each object xi two distinct binary codewords, ui \u2208 {\u00b11}k and vi \u2208 {\u00b11}k (we can think of this as having two arbitrary mappings ui = f(xi) and vi = g(xi)), such that Sij = sign(\u3008ui, vj\u3009 \u2212 \u03b8). The minimal asymmetric binary code length is then given by:\nka(S) = min k,U,V,\u03b8 k s.t U, V \u2208 {\u00b11}k\u00d7n \u03b8 \u2208 R Y , U>V \u2212 \u03b81n \u2200ij SijYij > 0\n(2)\nWriting the binary coding problems as matrix factorization problems is useful for understanding the power we can get by asymmetry: even if S is symmetric, and even if we seek a symmetric Y , insisting on writing Y as a square of a binary matrix might be a tough constraint. This is captured in the following Theorem, which establishes that there could be an exponential gap between the minimal asymmetry binary code length and the minimal symmetric code length, even if the matrix S is symmetric and very well behaved: Theorem 1. For any r, there exists a set of n = 2r points in Euclidean space, with similarity matrix Sij ={ 1 if \u2016xi \u2212 xj\u2016 \u2264 1 \u22121 if \u2016xi \u2212 xj\u2016 > 1 , such that ka(S) \u2264 2r but ks(S) \u2265 2r/2\nProof. Let I1 = {1, . . . , n/2} and I2 = {n/2 + 1, . . . , n}. Consider the matrix G defined by Gii = 1/2, Gij = \u22121/(2n) if i, j \u2208 I1 or i, j \u2208 I2, and Gij = 1/(2n) otherwise. Matrix G is diagonally dominant. By the Gershgorin circle theorem, G is positive definite. Therefore, there exist vectors x1, . . . , xn such that \u3008xi, xj\u3009 = Gij (for every i and j). Define\nSij = { 1 if \u2016xi \u2212 xj\u2016 \u2264 1 \u22121 if \u2016xi \u2212 xj\u2016 > 1 .\nNote that if i = j then Sij = 1; if i 6= j and (i, j) \u2208 I1\u00d7I1\u222aI2\u00d7I2 then \u2016xi \u2212 xj\u20162 = Gii+Gjj\u22122Gij = 1+1/n > 1 and therefore Sij = \u22121. Finally, if i 6= j and (i, j) \u2208 I1 \u00d7 I2 \u222a I2 \u00d7 I1 then \u2016xi \u2212 xj\u20162 = Gii + Gjj \u2212 2Gij = 1 + 1/n < 1 and therefore Sij = 1. We show that ka(S) \u2264 2r. Let B be an r \u00d7 n matrix whose column vectors are the vertices of the cube {\u00b11}r (in any order); let C be an r \u00d7 n matrix defined by Cij = 1 if j \u2208 I1 and Cij = \u22121\nif j \u2208 I2. Let U = [ B C ] and V = [ B \u2212C ] . For Y = U>V \u2212 \u03b81n where threshold \u03b8 = \u22121 , we have that Yij \u2265 1 if Sij = 1 and Yij \u2264 \u22121 if Sij = \u22121. Therefore, ka(S) \u2264 2r. Now we show that ks = ks(S) \u2265 n/2. Consider Y , U and \u03b8 as in (1). Let Y \u2032 = (U>U). Note that Y \u2032ij \u2208 [\u2212ks, ks] and thus \u03b8 \u2208 [\u2212ks + 1, ks \u2212 1]. Let q = [1, . . . , 1,\u22121, . . . ,\u22121]> (n/2 ones followed by n/2 minus ones). We have,\n0 \u2264 q>Y \u2032q = n\u2211 i=1 Y \u2032ii + \u2211 i,j:Sij=\u22121 Y \u2032ij \u2212 \u2211 i,j:Sij=1,i6=j Y \u2032ij\n\u2264 n\u2211 i=1 ks + \u2211 i,j:Sij=\u22121 (\u03b8 \u2212 1)\u2212 \u2211 i,j:Sij=1,i6=j (\u03b8 + 1)\n= nks + (0.5n 2 \u2212 n)(\u03b8 \u2212 1)\u2212 0.5n2(\u03b8 + 1)\n= nks \u2212 n2 \u2212 n(\u03b8 \u2212 1) \u2264 2nks \u2212 n2.\nWe conclude that ks \u2265 n/2.\nThe construction of Theorem 1 shows that there exists data sets for which an asymmetric binary hash might be much shorter then a symmetric hash. This is an important observation as it demonstrates that asymmetric hashes could be much more powerful, and should prompt us to consider them instead of symmetric hashes. The precise construction of Theorem 1 is of course rather extreme (in fact, the most extreme construction possible) and we would not expect actual data sets to have this exact structure, but we will show later significant gaps also on real data sets."}, {"heading": "3 Approximate Binary Codes", "text": "As we turn to real data sets, we also need to depart from seeking a binary coding that exactly captures the similarity matrix. Rather, we are usually satisfied with merely approximating S, and for any fixed code length k seek the\n(symmetric or asymmetric) k-bit code that \u201cbest captures\u201d the similarity matrix S. This is captured by the following optimization problem:\nmin U,V,\u03b8\nL(Y ;S) , \u03b2 \u2211\ni,j:Sij=1\n`(Yij) + (1\u2212 \u03b2) \u2211\ni,j:Sij=\u22121 `(\u2212Yij) s.t. U, V \u2208 {\u00b11}k\u00d7n \u03b8 \u2208 R\nY , U>V \u2212 \u03b81n\n(3)\nwhere `(z) = 1z\u22640 is the zero-one-error and \u03b2 is a parameter that allows us to weight positive and negative errors differently. Such weighting can compensate for Sij being imbalanced (typically many more pairs of points are nonsimilar rather then similar), and allows us to obtain different balances between precision and recall.\nThe optimization problem (3) is a discrete, discontinuous and highly non-convex problem. In our experiments, we replace the zero-one loss `(\u00b7) with a continuous loss and perform local search by greedily updating single bits so as to improve this objective. Although the resulting objective (let alone the discrete optimization problem) is still not convex even if `(z) is convex, we found it beneficial to use a loss function that is not flat on z < 0, so as to encourage moving towards the correct sign. In our experiments, we used the square root of the logistic loss, `(z) = log1/2(1 + e\u2212z).\nBefore moving on to out-of-sample generalizations, we briefly report on the number of bits needed empirically to find good approximations of actual similarity matrices with symmetric and asymmetric codes. We experimented with several data sets, attempting to fit them with both symmetric and asymmetric codes, and then calculating average precision by varying the threshold \u03b8 (while keeping U and V fixed). Results for two similarity matrices, one based on Euclidean distances between points uniformly distributed in a hypoercube, and the other based on semantic similarity between images, are shown in Figure 1."}, {"heading": "4 Out of Sample Generalization: Learning a Mapping", "text": "So far we focused on learning binary codes over a fixed set of objects by associating an arbitrary code word with each object and completely ignoring the input representation of the objects xi. We discussed only how well binary hashing can approximate the similarity, but did not consider generalizing to additional new objects. However, in most applications, we would like to be able to have such an out-of-sample generalization. That is, we would like to learn a mapping f : X \u2192 {\u00b11}k over an infinite domain X using only a finite training set of objects, and then apply the mapping to obtain binary codes f(x) for future objects to be encountered, such that S(x, x\u2032) \u2248 sign(\u3008f(x), f(x\u2032)\u3009\u2212\u03b8). Thus, the mapping f : X \u2192 {\u00b11}k is usually limited to some constrained parametric class, both so we could represent and evaluate it efficiently on new objects, and to ensure good generalization. For example, when X = Rd, we can consider linear threshold mappings fW (x) = sign(Wx), where W \u2208 Rk\u00d7d and sign(\u00b7) operates elementwise, as in Minimal Loss Hashing [8]. Or, we could also consider more complex classes, such as multilayer networks [11, 9].\nWe already saw that asymmetric binary codes can allow for better approximations using shorter codes, so it is natural to seek asymmetric codes here as well. That is, instead of learning a single parametric map f(x) we can learn a\npair of maps f : X \u2192 {\u00b11}k and g : X \u2192 {\u00b11}k, both constrained to some parametric class, and a threshold \u03b8, such that S(x, x\u2032) \u2248 sign(\u3008f(x), g(x\u2032)\u3009\u2212 \u03b8). This has the potential of allowing for better approximating the similarity, and thus better overall accuracy with shorter codes (despite possibly slightly harder generalization due to the increase in the number of parameters).\nIn fact, in a typical application where a database of objects is hashed for similarity search over future queries, asymmetry allows us to go even further. Consider the following setup: We are given n objects x1, . . . , xn \u2208 X from some infinite domain X and the similarities S(xi, xj) between these objects. Our goal is to hash these objects using short binary codes which would allow us to quickly compute approximate similarities between these objects (the \u201cdatabase\u201d) and future objects x (the \u201cquery\u201d). That is, we would like to generate and store compact binary codes for objects in a database. Then, given a new query object, we would like to efficiently compute a compact binary code for a given query and retrieve similar items in the database very fast by finding binary codes in the database that are within small hamming distance from the query binary code. Recall that it is important to ensure that the bit length of the hashes are small, as short codes allow for very fast hamming distance calculations and low communication costs if the codes need to be sent remotely. More importantly, if we would like to store the database in a hash table allowing immediate lookup, the size of the hash table is exponential in the code length.\nThe symmetric binary hashing approach (e.g. [8]), would be to find a single parametric mapping f : X \u2192 {\u00b11}k such that S(x, xi) \u2248 sign(\u3008f(x), f(xi)\u3009 \u2212 \u03b8) for future queries x and database objects xi, calculate f(xi) for all database objects xi, and store these hashes (perhaps in a hash table allowing for fast retrieval of codes within a short hamming distance). The asymmetric approach described above would be to find two parametric mappings f : X \u2192 {\u00b11}k and g : X \u2192 {\u00b11}k such that S(x, xi) \u2248 sign(\u3008f(x), g(xi)\u3009 \u2212 \u03b8), and then calculate and store g(xi).\nBut if the database is fixed, we can go further. There is actually no need for g(\u00b7) to be in a constrained parametric class, as we do not need to generalize g(\u00b7) to future objects, nor do we have to efficiently calculate it on-the-fly nor communicate g(x) to the database. Hence, we can consider allowing the database hash function g(\u00b7) to be an arbitrary mapping. That is, we aim to find a simple parametric mapping f : X \u2192 {\u00b11}k and n arbitrary codewords v1, . . . , vn \u2208 {\u00b11}k for each x1, . . . , xn in the database, such that S(x, xi) \u2248 sign(\u3008f(x), vi\u3009\u2212\u03b8) for future queries x and for the objects xi, . . . , xn in the database. This form of asymmetry can allow us for greater approximation power, and thus better accuracy with shorter codes, at no additional computational or storage cost.\nIn Section 6 we evaluate empirically both of the above asymmetric strategies and demonstrate their benefits. But before doing so, in the next Section, we discuss a local-search approach for finding the mappings f, g, or the mapping f and the codes v1, . . . , vn."}, {"heading": "5 Optimization", "text": "We focus on x \u2208 X \u2282 Rd and linear threshold hash maps of the form f(x) = sign(Wx), where W \u2208 Rk\u00d7d. Given training points x1, . . . , xn, we consider the two models discussed above: LIN:LIN We learn two linear threshold functions f(x) = sign(Wqx) and g(x) = sign(Wdx). I.e. we need to find the parameters Wq,Wd \u2208 Rk\u00d7d. LIN:V We learn a single linear threshold function f(x) = sign(Wqx) and n codewords v1, . . . , vn \u2208 Rk. I.e. we need to find Wq \u2208 Rk\u00d7d, as well as V \u2208 Rk\u00d7n (where vi are the columns of V ). In either case we denote ui = f(xi), and in LIN:LIN also vi = g(xi), and learn by attempting to minimizing the objective in (3), where `(\u00b7) is again a continuous loss function such as the square root of the logistic. That is, we learn by optimizing the problem (3) with the additional constraint U = sign(WqX), and possibly also V = sign(WdX) (for LIN:LIN), where X = [x1 . . . xn] \u2208 Rd\u00d7n.\nWe optimize these problems by alternatively updating rows of Wq and either rows of Wd (for LIN:LIN ) or of V (for LIN:V ). To understand these updates, let us first return to (3) (with unconstrained U, V ), and consider updating a row u(t) \u2208 Rn of U . Denote\nY (t) = U>V \u2212 \u03b81n \u2212 u(t) > v(t),\nthe prediction matrix with component t subtracted away. It is easy to verify that we can write:\nL(U>V \u2212 \u03b81n;S) = C \u2212 u(t)Mv(t) >\n(4)\nwhere C = 12 (L(Y (t) + 1n;S) + L(Y (t) \u2212 1n;S)) does not depend on u(t) and v(t), and M \u2208 Rn\u00d7n also does not depend on u(t), v(t) and is given by:\nMij = \u03b2ij 2\n( `(Sij(Y (t) ij \u2212 1))\u2212 `(Sij(Y (t) ij + 1)) ) ,\nwith \u03b2ij = \u03b2 or \u03b2ij = (1 \u2212 \u03b2) depending on Sij . This implies that we can optimize over the entire row u(t) concurrently by maximizing u(t)Mv(t) >\n, and so the optimum (conditioned on \u03b8, V and all other rows of U ) is given by\nu(t) = sign(Mv(t)). (5)\nSymmetrically, we can optimize over the row v(t) conditioned on \u03b8, U and the rest of V , or in the case of LIN:V , conditioned on \u03b8, Wq and the rest of V .\nSimilarly, optimizing over a row w(t) of Wq amount to optimizing:\narg max w(t)\u2208Rd\nsign(w(t)X)Mv(t) >\n= arg max w(t)\u2208Rd \u2211 i \u2329 Mi, v (t) \u232a sign( \u2329 w(t), xi \u232a ). (6)\nThis is a weighted zero-one-loss binary classification problem, with targets sign( \u2329 Mi, v (t) \u232a ) and weights \u2223\u2223\u2329Mi, v(t)\u232a\u2223\u2223. We approximate it as a weighted logistic regression problem, and at each update iteration attempt to improve the objective using a small number (e.g. 10) epochs of stochastic gradient descent on the logistic loss. For LIN:LIN , we also symmetrically update rows of Wd.\nWhen optimizing the model for some bit-length k, we initialize to the optimal k \u2212 1-length model. We initialize the new bit either randomly, or by thresholding the rank-one projection of M (for unconstrained U, V ) or the rank-one projection after projecting the columns of M (for LIN:V ) or both rows and columns of M (for LIN:LIN ) to the column space of X . We take the initialization (random, or rank-one based) that yields a lower objective value."}, {"heading": "6 Empirical Evaluation", "text": "In order to empirically evaluate the benefits of asymmetry in hashing, we replicate the experiments of [8], which were in turn based on [5], on six datasets using learned (symmetric) linear threshold codes. These datasets include: LabelMe and Peekaboom are collections of images, represented as 512D GIST features [13], Photo-tourism is a database of image patches, represented as 128 SIFT features [12], MNIST is a collection of 785D greyscale handwritten images, and Nursery contains 8D features. Similar to [8, 5], we also constructed a synthetic 10D Uniform dataset, containing uniformly sampled 4000 points for a 10D hypercube. We used 1000 points for training and 3000 for testing.\nFor each dataset, we find the Euclidean distance at which each point has, on average, 50 neighbours. This defines our ground-truth similarity in terms of neighbours and non-neighbours. So for each dataset, we are given a set of n points x1, . . . , xn, represented as vectors in X = Rd, and the binary similarities S(xi, xj) between the points, with +1 corresponding to xi and xj being neighbors and -1 otherwise. Based on these n training points, [8] present a sophisticated optimization approach for learning a thresholded linear hash function of the form f(x) = sign(Wx), whereW \u2208 Rk\u00d7d. This hash function is then applied and f(x1), . . . , f(xn) are stored in the database. [8] evaluate the quality of the hash by considering an independent set of test points and comparing S(x, xi) to sign(\u3008f(x), f(xi)\u3009\u2212 \u03b8) on the test points x and the database objects (i.e. training points) xi.\nIn our experiments, we followed the same protocol, but with the two asymmetric variations LIN:LIN and LIN:V, using the optimization method discussed in Sec. 5. In order to obtain different balances between precision and recall, we should vary \u03b2 in (3), obtaining different codes for each value of \u03b2. However, as in the experiments of [8], we actually learn a code (i.e. mappings f(\u00b7) and g(\u00b7), or a mapping f(\u00b7) and matrix V ) using a fixed value of \u03b2 = 0.7, and then only vary the threshold \u03b8 to obtain the precision-recall curve.\nIn all of our experiments, in addition to Minimal Loss Hashing (MLH), we also compare our approach to three other widely used methods: Kernel-Based Supervised Hashing (KSH) of [6], Binary Reconstructive Embedding (BRE)\nof [5], and Locality-Sensitive Hashing (LSH) of [1]. 1\nIn our first set of experiments, we test performance of the asymmetric hash codes as a function of the bit length. Figure 2 displays Average Precision (AP) of data points retrieved using Hamming distance as a function of code length. These results are similar to ones reported by [8], where MLH yields higher precision compared to BRE and LSH. Observe that for all six datasets both variants of our method, asymmetric LIN:LIN and asymmetric LIN:V , consistently outperform all other methods for different binary code length. The gap is particularly large for short\n1We used the BRE, KSH and MLH implementations available from the original authors. For each method, we followed the instructions provided by the authors. More specifically, we set the number of points for each hash function in BRE to 50 and the number of anchors in KSH to 300 (the default values). For MLH, we learn the threshold and shrinkage parameters by cross-validation and other parameters are initialized to the suggested values in the package.\n16 bits 64 bits 16 bits 64bits LabelMe MNIST\ncodes. For example, for the LabelMe dataset, MLH and KSH with 16 bits achieve AP of 0.52 and 0.54 respectively, whereas LIN:V already achieves AP of 0.54 with only 8 bits. Figure 3 shows similar performance gains appear for a number of other datasets. We also note across all datasets LIN:V improves upon LIN:LIN for short-sized codes. These results clearly show that an asymmetric binary hash can be much more compact than a symmetric hash.\nNext, we show, in Figure 4, the full Precision-Recall curves for two datasets, LabelMe and MNIST, and for two specific code lengths: 16 and 64 bits. The performance of LIN:LIN and LIN:V is almost uniformly superior to that of MLH, KSH and BRE methods. We observed similar behavior also for the four other datasets across various different code lengths.\nResults on previous 6 datasets show that asymmetric binary codes can significantly outperform other state-of-theart methods on relatively small scale datasets. We now consider a much larger LabelMe dataset [13], called Semantic 22K LabelMe. It contains 20,019 training images and 2,000 test images, where each image is represented by a 512D GIST descriptor. The dataset also provides a semantic similarity S(x, x\u2032) between two images based on semantic content (object labels overlap in two images). As argued by [8], hash functions learned using semantic labels should be more useful for content-based image retrieval compared to Euclidean distances. Figure 5 shows that LIN:V with 64 bits substantially outperforms MLH and KSH with 64 bits."}, {"heading": "7 Summary", "text": "The main point we would like to make is that when considering binary hashes in order to approximate similarity, even if the similarity measure is entirely symmetric and \u201cwell behaved\u201d, much power can be gained by considering asymmetric codes. We substantiate this claim by both a theoretical analysis of the possible power of asymmetric codes, and by showing, in a fairly direct experimental replication, that asymmetric codes outperform state-of-the-art\nresults obtained for symmetric codes. The optimization approach we use is very crude. However, even using this crude approach, we could find asymmetric codes that outperformed well-optimized symmetric codes. It should certainly be possible to develop much better, and more well-founded, training and optimization procedures.\nAlthough we demonstrated our results in a specific setting using linear threshold codes, we believe the power of asymmetry is far more widely applicable in binary hashing, and view the experiments here as merely a demonstration of this power. Using asymmetric codes instead of symmetric codes could be much more powerful, and allow for shorter and more accurate codes, and is usually straightforward and does not require any additional computational, communication or significant additional memory resources when using the code. We would therefore encourage the use of such asymmetric codes (with two distinct hash mappings) wherever binary hashing is used to approximate similarity."}, {"heading": "Acknowledgments", "text": "This research was partially supported by NSF CAREER award CCF-1150062 and NSF grant IIS-1302662."}], "references": [{"title": "Locality-sensitive hashing scheme based on p-stable distributions", "author": ["M. Datar", "N. Immorlica", "P. Indyk", "V.S. Mirrokni"], "venue": "Proceedings of the twentieth annual symposium on Computational geometry, pages 253\u2013262. ACM", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2004}, {"title": "Asymmetric distance estimation with sketches for similarity search in highdimensional spaces", "author": ["W. Dong", "M. Charikar"], "venue": "SIGIR", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2008}, {"title": "Iterative quantization: A procrustean approach to learning binary codes for large-scale image retrieval", "author": ["Y. Gong", "S. Lazebnik", "A. Gordo", "F. Perronnin"], "venue": "TPAMI", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Asymmetric distances for binary embeddings", "author": ["A. Gordo", "F. Perronnin"], "venue": "CVPR", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Learning to hash with binary reconstructive embeddings", "author": ["B. Kulis", "T. Darrell"], "venue": "NIPS", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "R", "author": ["W. Liu"], "venue": "Ji J. Wang, Y.-G. Jiang, and S.-F. Chang. Supervised hashing with kernels. CVPR", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "Hashing with graphs", "author": ["W. Liu", "J. Wang", "S. Kumar", "S.-F. Chang"], "venue": "ICML", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2011}, {"title": "Minimal loss hashing for compact binary codes", "author": ["M. Norouzi", "D.J. Fleet"], "venue": "ICML", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Hamming distance metric learning", "author": ["M. Norouzi", "D.J. Fleet", "R. Salakhutdinov"], "venue": "NIPS", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Locality-sensitive binary codes from shift-invariant kernels", "author": ["M. Raginsky", "S. Lazebnik"], "venue": "NIPS", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "Semantic hashing", "author": ["R. Salakhutdinov", "G. Hinton"], "venue": "International Journal of Approximate Reasoning", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "S", "author": ["N. Snavely"], "venue": "M. Seitz, and R.Szeliski. Photo tourism: Exploring photo collections in 3d. In Proc. SIGGRAPH", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Small codes and large image databases for recognition", "author": ["A. Torralba", "R. Fergus", "Y. Weiss"], "venue": "CVPR", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2008}, {"title": "Sequential projection learning for hashing with compact codes", "author": ["J. Wang", "S. Kumar", "S. Chang"], "venue": "ICML", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2010}, {"title": "Spectral hashing", "author": ["Y. Weiss", "A. Torralba", "R. Fergus"], "venue": "NIPS", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 10, "context": "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].", "startOffset": 208, "endOffset": 223}, {"referenceID": 8, "context": "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].", "startOffset": 208, "endOffset": 223}, {"referenceID": 9, "context": "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].", "startOffset": 208, "endOffset": 223}, {"referenceID": 12, "context": "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].", "startOffset": 208, "endOffset": 223}, {"referenceID": 0, "context": "Pioneering work on Locality Sensitive Hashing used random linear thresholds for obtaining bits of the hash [1].", "startOffset": 107, "endOffset": 110}, {"referenceID": 14, "context": "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].", "startOffset": 85, "endOffset": 102}, {"referenceID": 10, "context": "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].", "startOffset": 85, "endOffset": 102}, {"referenceID": 4, "context": "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].", "startOffset": 85, "endOffset": 102}, {"referenceID": 6, "context": "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].", "startOffset": 85, "endOffset": 102}, {"referenceID": 2, "context": "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].", "startOffset": 85, "endOffset": 102}, {"referenceID": 13, "context": "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .", "startOffset": 136, "endOffset": 149}, {"referenceID": 7, "context": "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .", "startOffset": 136, "endOffset": 149}, {"referenceID": 8, "context": "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .", "startOffset": 136, "endOffset": 149}, {"referenceID": 5, "context": "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .", "startOffset": 136, "endOffset": 149}, {"referenceID": 1, "context": "This has become known as \u201casymmetric hashing\u201d [2, 4], but even with such asymmetry, both mappings are based on the same fractional mapping f\u0303(\u00b7).", "startOffset": 46, "endOffset": 52}, {"referenceID": 3, "context": "This has become known as \u201casymmetric hashing\u201d [2, 4], but even with such asymmetry, both mappings are based on the same fractional mapping f\u0303(\u00b7).", "startOffset": 46, "endOffset": 52}, {"referenceID": 7, "context": "For example, when X = R, we can consider linear threshold mappings fW (x) = sign(Wx), where W \u2208 Rk\u00d7d and sign(\u00b7) operates elementwise, as in Minimal Loss Hashing [8].", "startOffset": 162, "endOffset": 165}, {"referenceID": 10, "context": "Or, we could also consider more complex classes, such as multilayer networks [11, 9].", "startOffset": 77, "endOffset": 84}, {"referenceID": 8, "context": "Or, we could also consider more complex classes, such as multilayer networks [11, 9].", "startOffset": 77, "endOffset": 84}, {"referenceID": 7, "context": "[8]), would be to find a single parametric mapping f : X \u2192 {\u00b11} such that S(x, xi) \u2248 sign(\u3008f(x), f(xi)\u3009 \u2212 \u03b8) for future queries x and database objects xi, calculate f(xi) for all database objects xi, and store these hashes (perhaps in a hash table allowing for fast retrieval of codes within a short hamming distance).", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "In order to empirically evaluate the benefits of asymmetry in hashing, we replicate the experiments of [8], which were in turn based on [5], on six datasets using learned (symmetric) linear threshold codes.", "startOffset": 103, "endOffset": 106}, {"referenceID": 4, "context": "In order to empirically evaluate the benefits of asymmetry in hashing, we replicate the experiments of [8], which were in turn based on [5], on six datasets using learned (symmetric) linear threshold codes.", "startOffset": 136, "endOffset": 139}, {"referenceID": 12, "context": "These datasets include: LabelMe and Peekaboom are collections of images, represented as 512D GIST features [13], Photo-tourism is a database of image patches, represented as 128 SIFT features [12], MNIST is a collection of 785D greyscale handwritten images, and Nursery contains 8D features.", "startOffset": 107, "endOffset": 111}, {"referenceID": 11, "context": "These datasets include: LabelMe and Peekaboom are collections of images, represented as 512D GIST features [13], Photo-tourism is a database of image patches, represented as 128 SIFT features [12], MNIST is a collection of 785D greyscale handwritten images, and Nursery contains 8D features.", "startOffset": 192, "endOffset": 196}, {"referenceID": 7, "context": "Similar to [8, 5], we also constructed a synthetic 10D Uniform dataset, containing uniformly sampled 4000 points for a 10D hypercube.", "startOffset": 11, "endOffset": 17}, {"referenceID": 4, "context": "Similar to [8, 5], we also constructed a synthetic 10D Uniform dataset, containing uniformly sampled 4000 points for a 10D hypercube.", "startOffset": 11, "endOffset": 17}, {"referenceID": 7, "context": "Based on these n training points, [8] present a sophisticated optimization approach for learning a thresholded linear hash function of the form f(x) = sign(Wx), whereW \u2208 Rk\u00d7d.", "startOffset": 34, "endOffset": 37}, {"referenceID": 7, "context": "[8] evaluate the quality of the hash by considering an independent set of test points and comparing S(x, xi) to sign(\u3008f(x), f(xi)\u3009\u2212 \u03b8) on the test points x and the database objects (i.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "However, as in the experiments of [8], we actually learn a code (i.", "startOffset": 34, "endOffset": 37}, {"referenceID": 5, "context": "In all of our experiments, in addition to Minimal Loss Hashing (MLH), we also compare our approach to three other widely used methods: Kernel-Based Supervised Hashing (KSH) of [6], Binary Reconstructive Embedding (BRE)", "startOffset": 176, "endOffset": 179}, {"referenceID": 4, "context": "of [5], and Locality-Sensitive Hashing (LSH) of [1].", "startOffset": 3, "endOffset": 6}, {"referenceID": 0, "context": "of [5], and Locality-Sensitive Hashing (LSH) of [1].", "startOffset": 48, "endOffset": 51}, {"referenceID": 7, "context": "These results are similar to ones reported by [8], where MLH yields higher precision compared to BRE and LSH.", "startOffset": 46, "endOffset": 49}, {"referenceID": 12, "context": "We now consider a much larger LabelMe dataset [13], called Semantic 22K LabelMe.", "startOffset": 46, "endOffset": 50}, {"referenceID": 7, "context": "As argued by [8], hash functions learned using semantic labels should be more useful for content-based image retrieval compared to Euclidean distances.", "startOffset": 13, "endOffset": 16}], "year": 2013, "abstractText": "When approximating binary similarity using the hamming distance between short binary hashes, we show that even if the similarity is symmetric, we can have shorter and more accurate hashes by using two distinct code maps. I.e. by approximating the similarity between x and x\u2032 as the hamming distance between f(x) and g(x\u2032), for two distinct binary codes f, g, rather than as the hamming distance between f(x) and f(x\u2032).", "creator": "LaTeX with hyperref package"}}}