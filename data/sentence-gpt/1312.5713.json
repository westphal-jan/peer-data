{"id": "1312.5713", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Dec-2013", "title": "Giving the AI definition a form suitable for the engineer", "abstract": "This article tackles a number of technical issues related to the AI definition. These include the format of the data, the Undef and Nothing symbols, different ways of defining the meaning of life, as well as the introduction of the concept of \"incorrect move\". These are issues of no material importance, if we are interested in the AI definition from a purely theoretical point of view; however, if we want to develop a real program satisfying that definition, we are to find these issues important.\n\n\nThe AI concept of \"incorrect move\" has become a popular subject of discussion around the internet for some time. This article will be more about the concept of \"incorrect move\", although a closer look at the topic is necessary to understand this.\nThis article is a bit of a mess. The AI definition is defined by a number of common rules:\nYou must set a function to be considered accurate when a given event occurs. This may be the case in some situations; as you may see, the function is called with a non-empty string (i.e. a function like that at the beginning of this code). However, there are two different definitions of the function:\nIf it is a function that changes a particular event, you need to change a certain value. If it is a function that is a function that does not change a particular event, you need to change the function. There is a general set of exceptions that you must include:\nIf the function is a function that does not change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular event, you cannot change a particular", "histories": [["v1", "Thu, 19 Dec 2013 19:28:18 GMT  (28kb)", "http://arxiv.org/abs/1312.5713v1", null], ["v2", "Tue, 31 Mar 2015 10:26:48 GMT  (28kb)", "http://arxiv.org/abs/1312.5713v2", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["dimiter dobrev"], "accepted": false, "id": "1312.5713"}, "pdf": {"name": "1312.5713.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["d@dobrev.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n31 2.\n57 13\nv1 [\ncs .A\nThis article tackles a number of technical issues related to the AI definition. These include the format of the data, the Undef and Nothing symbols, different ways of defining the meaning of life, as well as the introduction of the concept of \u2018incorrect move\u2019. These are issues of no material importance, if we are interested in the AI definition from a purely theoretical point of view; however, if we want to develop a real program satisfying that definition, we are to find these issues important."}, {"heading": "Introduction", "text": "If you want to answer the question: \u2018What is AI?\u2019, the first thing to do would be to consider whom you are giving your answer to, and what is the purpose of your answer \u2013 whether your aim is to convince the reader that AI exists and it possesses certain features that are interesting from a theoretical point of view, or you want to write an instruction for creation of AI, in which your reader will find useful practical advice and technical tricks that could help him in his actual attempt to write the program called AI.\nLet\u2019s first take for example another device called \u2018computer\u2019. If we want to define it, first we have to consider whom we are giving our definition to. Perhaps our readers are mathematicians and are interested in the questions: \u2018Is such a device actually existing?\u2019, \u2018What are its features?\u2019, \u2018Could we reduce\nit to another device that we know? (i.e. reducing the matter to the previous case)\u2019. Mathematicians would be happy to have a definition like the \u2018Turing machine\u2019 or like the \u2018unlimited register machine\u2019 since what they need is an easy to handle, simple description. If you want to prove by induction, you will have to check for each and every instruction of the Turing machine whether it preserves the induction assumption. The good thing is that all instructions of the Turing machine are of one and the same type. If you decide to prove by induction using the model of a real computer, you will face the problem that with it the possible instructions are hundreds and it is almost impossible to check for each and every of them whether it preserves the induction assumption.\nIf you want to answer the question: \u2018What is a computer?, and if your answer is intended for engineers, then you will have to say something about CPU and memory, buses for data transmission, the numeral system utilized to encode the data, etc.\nThe difference between mathematicians and engineers is first the way they think, and second \u2013 the aim they pursue. For the mathematicians the concept is interesting from a theoretical point of view, and the engineer wants to create a real product and that\u2019s why he is interested in a series of technical details, which are irrelevant for the mathematician.\nHere is a typical ratiocination of a mathematician: \u2018I would like to call my friend Peter but I have forgotten his telephone number. No problem, the set of telephone numbers is finite \u2013 I will call all of them and one of them will be the number of Peter.\u2019 Such reasoning is very common in mathematical proofs. For the mathematician the question is: \u2018Can I call Peter?\u2019 and the answer is \u2018Yes, I can\u2019. Of course, engineers do not use such proofs since they are not interested in the question \u2018Is this theoretically possible?\u2019. Engineers are looking for a real, working solution. Even if they do not know why something works, they do not worry since the important thing for them is for the solution to work, and why it works is not that important.\nIn articles [1, 2, 4] we tried to catch the fancy of mathematicians, and proposed an AI definition that is useful from a theoretical point of view; however, for the needs of practice, we need to go into details that will be needed for the development of a real program satisfying the definition.\nThat is to say, the purpose of this article is to catch the fancy of engineers and tell them what Artificial Intelligence is in a way that would be useful to them for the development of a real working program.\nIn [4] we described one concrete program which satisfies the definition of AI but this program was so inefficient that in order to work it requires infinity fast computer. In [1] we gave an algorithm which will find an efficient program that satisfies the definition of AI. This will be done for finite number\nof steps but this finite number is so big that in practice it is infinite. So this algorithm is as useless as the one which answers the question \u2018Can I call Peter?\u2019 In the current paper we will not deal with the question about the existence of AI. Here we will turn our attention on practical questions connected with the design of this program."}, {"heading": "Format of the data", "text": "As we\u2019ve already mentioned in articles [1 - 4], the Artificial Intelligence is a step device that inputs and outputs certain information on each step. Of course, a question arises about the format of this information.\nIn [1], both the input and the output data were Boolean vectors. There, the rewards was expressed by two special bits from the input, which we called \u2018victory\u2019 and \u2018loss\u2019. That is to say the data in [1] has some structure, while in [2] the input data are just letters of a finite alphabet (just like the output data). The victory or loss is just some subsets of the set of the input symbols, i.e. the data in [2] has no structure whatsoever.\nArticle [1] was published in a popular science magazine, which is why it was written for the general public; at the same time, article [2] was designated for a mathematical magazine and the technical details in it were cleared up. It was assumed that for mathematicians the format of the data is of no importance.\n[3] reviews a particular world. This is the Tic-tac-toe game. The format of the data is the same as in [1], with the exception that we\u2019ve added one bit, which we\u2019ve called \u2018incorrect move\u2019. [3] shows that the Boolean vector is not the most suitable format possible, since the input with it shows the symbol in the current box on the game board. There are three options: empty, circle and cross. Those three options are coded in two bits, where one of the four combinations of the two bits is simply not used, i.e. this input never comes. The situation with the output is similar. The possible actions there are six, which are coded in three bits, where two of the eight combinations are simply not used, i.e. when the device tries to play such combination, it always receives a reply \u2018incorrect move\u2019.\nThe fact that through the use of coding we can convert data from one format into another one means that, from theoretical point of view, the format of the data is irrelevant, but from a practical point of view it is important for us to choose the correct format to avoid the need of coding. The aim of AI is to understand the world; therefore, to make this aim easily achievable, it is good for this world to be simple and easy to understand. If we put a coding at the input and output, this could make the world so\ncomplex that our device would not be able to understand it. Let\u2019s take for example the digits from 0 to 9. What will happen if we shuffle them? Well, nothing special. If we\u2019ve managed to learn them in this sequence, we will be able to learn the new sequence as well. Let\u2019s now take the numbers from 0 to 99 and shuffle them. Let\u2019s start with a small shuffle by simply changing the places of the two digits. This shuffle will not be a problem since once we\u2019ve learned to write the numbers from left to right, we will be able to learn to write them from right to left. Now, let\u2019s apply to the numbers from 0 to 99 a completely arbitrary permutation. Now, that would be a serious problem because we will ruin the natural logic this numbers follow. Let the new sequence be the following: 38, 12, 76, etc. There is no logic at all in this new sequence, and if we want to learn to count from 0 to 99 this would be a serious challenge.\nThe situation with the Boolean vectors is analogical. We are making the presumption that in them the world is presented in a natural way and an eventual coding would complicate the world and will make the task of understanding it more difficult. If we shuffle the naught and the one, this will not be a problem provided that these are two symbols coded arbitrary with 0 and 1, but if we assume that these symbols follow a certain sequence (i.e. 0 is smaller than 1), then the shuffling could complicate the world. If we change the places of the coordinates in the vector, that would also not be a problem provided that there is no logic in the arrangement of the coordinates, but if the neighboring coordinates are more related than the further ones, then the shuffling could also complicate the world. If we apply an arbitrary permutation to the vectors, this would most surely be a problem because it will hide the logic the format has been chosen to (if there is logic at all).\nAs we\u2019ve already mentioned in [5], we will want for the world to represent a sum of various factors, which could be independent but could also affect one another. For a world like this, the presentation of the data with the use of vectors is particularly suitable. Vectors will be also used to present the internal state of the world. (The world is something external for our device, and for us, the developers of the device, the format of the internal states of the world is irrelevant but the device will search for a model of the world and in this model the internal states of the world need to be described. For the purposes thereof, the vector format is very suitable since if we have two independent models of the world we can easily unite them into one where the new states will be concatenation of the vectors of the states of the two models.)"}, {"heading": "Signals", "text": "Definition: A function of one argument (the time) that a scalr returns is called a signal.\nThis means that the coordinates of the vectors are signals. Let\u2019s take four types of signals: input, output, reward and internal. The output signals are the coordinates of the output vector. The input and reward signals are the coordinates of the input vector.\nNote: We\u2019ve explicitly separated the input in two: reward part, which gives us the meaning, and a purely information part. Same thing was done in [1]. In [1] the reward was expressed in two signals, which we called \u2018victory\u2019 and \u2018loss\u2019. The same thing was done in [3], but there we have yet another reward signal called \u2018incorrect move\u2019. The situation in [2] is quite different \u2013 there we have only one input signal that encodes both the information and the reward part of the input.\nApart from the signals taking part in the input and output vector, we also have a lot of internal signals, which will make the device work and which we will use to build a model of the world. We will assume that the device is looking for a presentation of the world with the use of a vector, the coordinates of which are internal signals. The set of all internal signals possible is infinite but at any specific moment the device has concentrated on a finite number of internal signals that it finds interesting and adequate for the world it has fallen into."}, {"heading": "Non-Boolean vectors", "text": "Well then, once we\u2019ve decided that the format of the data and of the internal states of the world will be a vector one, let\u2019s ask the question whether we could limit the same to the Boolean vectors. The answer is \u2018No\u2019. In [3] we saw that if we use only Boolean vectors, this acquires additional coding.\nIf we limit the set to the Boolean vectors only, the input and output signals will be Boolean functions. Let\u2019s expand the definition with some more complicated signals. We will allow for the signal to return k possible values from the set {0, 1, ..., k\u22121} instead of having only two possible values from the {0, 1} set. We will assume that the sequence of these values is not an arbitrary one (i.e. that the \u2018bigger\u2019 order in the {0, 1, ..., k \u2212 1} sequence corresponds to some natural order typical of the world, if, of course, such an order exists). We assume that the sequence of the possible values of the signal is not an arbitrary one and that the world is presented in the most natural way possible without us being burdened by some unnecessary encoding.\nThus, we\u2019ve expanded the set of signals to the set of finite functions. We will expand it a bit more by allowing the signal to return infinite scalars as well, in the form of an integer, a natural or a real number. We will again assume that the presentation of the data as an integer or a real number is not arbitrary but connected to the internal structure of the world. Therefore, we will expect for the real numbers to posses the quality of continuous (i.e. that small changes will not have a material significance). We will expect that the \u2018bigger\u2019 relation is not an arbitrary one as well but related to the natural structure of the world.\nRepresenting the infinite objects as finite\nWe will take a device the input and output of which are vectors from scalars, where some of the scalars are finite but there could also be infinite scalars. With this, the practical solution where we have a program that inputs and outputs a finite quantity of information at each step falls out. The assumption that we can have countable scalars leads to the result that the input and output will not be finite. If we also assume uncountable scalars (as the real numbers) this leads to the result that the input and output vectors cannot be coded at all as a finite sequence of bits.\nThis means that the allowance of infinite objects as a part of the input and output leads to a theoretical model that does not completely correspond to the practice. However, we can assume that the natural and real numbers taking part in the input and output vectors are not real but computerpresented (for example, that same are presented in 64 bits, coded with the use of the standard computer coding). Thus we have two models. The first one is theoretical; in it the device operates with an input and output that contain real and natural numbers. With the second model, those numbers are not real and natural but rather the pseudo-real and pseudo-natural ones the computer operates with.\nWhich of those two models will we work with? We will work with the theoretical one and will apply the results in practice using the practical model. That\u2019s the same thing people dealing with Turing machines do. They work with the theoretical model of a computer with an infinite memory (since the Turing machine uses an endless tape). Then they apply the results to real computers that have finite memory.\nThe only case we will use the practical instead of the theoretical model would be when we want to use the fact that the sets of the inputs and outputs are finite. We will need this to produce some pointless evidence of existence of the type: \u2018Telephone numbers are finite in number, therefore I can call\nPeter.\u2019"}, {"heading": "The Undef and Nothing symbols", "text": "Many programming languages introduce a special symbol for the case when we do not have a value or we don\u2019t know the value. This symbol will be useful in our case too. We will call it the Undef symbol.\nAnother special symbol will be Nothing. We will need it for the case when nothing happens. We will not give a specific definition of that when nothing happens in the world, but will consider that one of the input symbols has an additional meaning and that this is very informal and for reference only, without having any concrete meaning. For example, in real world silence could be taken for the symbol Nothing. It is interesting that when someone sleeps in a noisy room, he wakes up if the noise suddenly stops. That means that the sudden silence is perceived as an interesting event. This means that the symbol Nothing is a symbol as all other symbols and its meaning as \u2018nothing\u2019 is for reference only.\nIs it necessary for a specific symbol to have a special meaning? From theoretical point of view it is not, but in this article we deal with the question of the practical solution of the problem, and we want to facilitate the device to understand the world to a maximum extent and that\u2019s why we presume that we\u2019ve provided it with some preliminary information. This information is the special meaning of the symbol Nothing.\nWhen will we use the symbol Nothing? For example, at the input, when there is no input. Of course, the unavailability of an input is also an input, but this is a more special input.\nWhen will we use the symbol Undef? This will be when the input is unknown (for example, when a sensor failed or delayed the transmission of the information). We can even assume that there is a chance for the missing information to appear with a delay (i.e. that after one more step certain information will come that the value of Undef at the previous step should have been this or that). Of course, our device should be able to receive and process such information because otherwise that information would be useless.\nFrom any signal we could derive a new one by saying \u2018that signal before k steps\u2019, i.e. this is a memory of the signal. There is, of course, the question how to define this memory for the moments when t \u2212 k is a negative value, i.e. what to remember for a moment before the birth. The natural value suitable for this case is the symbol Undef.\nLet\u2019s take another internal symbol. Let\u2019s have a model of the world\nconsisting of a finite-state non-deterministic automaton. Let\u2019s have a signal bringing back the state of this automaton in the t moment. If the device was deterministic, its respective signal would also be deterministic. But we might not know the state the non-deterministic automaton is in at a given moment. Then it would be natural for the signal to return the Undef symbol. In a few more steps we may find out what state we\u2019ve been in. Then certain additional information might come in saying us that the signal from that step has been this or that rather than Undef.\nAs you can see, the assumption of the symbols Undef and Nothing is very suitable with the input signals and even more suitable with internal symbols.\nWith output signals we will also use the symbol Nothing. Imagine that at a certain moment you don\u2019t know what to do. In this case, it would be most suitable to do nothing but you have to do something because your device must come out with an output because otherwise it would stay stuck in silence, which, we assume, is unacceptable.\nWhich should be the output corresponding to \u2018I\u2019m doing nothing\u2019? Let this be the symbol Nothing. Any other symbol could play this role but we assume that we\u2019ve simplified and standardized the world to a degree that makes it easier to be understood.\nIt is natural for the symbol Nothing to be the anchor for the device to hang on to when it comes to (gets born in) a completely unknown world. Its first step would be to try what will happen when it plays Nothing along all coordinates of the output vector. Then it will try to give value to one of the coordinates and leave the others be Nothing.\nWe can assume that with the output signals we have the right to use also the symbol Undef, assuming that with a delay of a few steps the device will have the right to specify the value of the output and say what should have been in the place of the symbol Undef. This assumption would make things very complicated and that\u2019s why we are not making it. This means that the symbol Undef would not participate in output signals?\nDo we need the symbol Nothing with reward signals? The answer is \u2018Yes\u2019. In articles [1, 3, 4] we assumed that the reward is made by two Boolean signals called \u2018loss\u2019 and \u2018victory\u2019. When those two signals are simultaneously one, we take this for a draw, and when the two signals are simultaneously zero, we assume that we have no reward. As you can see, there is one redundant coding added. In [4] we calculated the success of the device by calculating the arithmetic mean of victories, losses and draws, but this arithmetic mean does not include the cases when we obtained no reward at all.\nIt is not logical to assume that our device will get a reward at each and every step. It is better to assume that most steps do not get a reward, and therefore we will use the symbol Nothing for cases like these.\nTo make things simple and logical, let\u2019s assume that the reward is given by one signal which has a value of 1, 0 or 1/2 respectively in the cases of victory, loss or draw, and in cases when there is no reward, the signal will have a Nothing value. Then the success of the device will be the arithmetic mean of the values of this signal which are different from Nothing.\nTo make things simpler, we will assume that for the cases of input, output and internal signals the symbol Nothing coincides with the symbol zero. We decided that one of the symbols will have a more special meaning and that the most suitable symbol of the purpose is zero. The other advantage is that it is present in all formats. It is present in the Boolean format, in the finite format, in natural numbers, as well as in real number, etc.\nThe only case when we will assume that zero and Nothing are different symbols will be in the reward signals. There we make the arithmetic mean of all values different from Nothing, and the zero is a normal number, which can easily participate in the arithmetic mean. We would like to underline that Nothing does not participate in the calculation of the arithmetic mean, and that\u2019s why we will assume that it is not a zero but something different."}, {"heading": "Possible evaluations", "text": "In [1] we said that a program recognised as Artificial Intelligence is any program which copes better than a human being in an arbitrary world. To be able to compare and say who did better and who did worse, we must have an order of lives telling us which life is better and which life is worse.\nWe will call this order \u2018the meaning of life\u2019. To define this order, we will first define the meaning of life for the cases of finite life, and then we will expand the order for the case of infinite life.\nLet\u2019s take an arbitrary linear order of finite lives (We have to remind you that we call life the sequence of input and output vectors from the moment of birth until a given moment in time or to infinity).\nEach linear order between finite lives has a corresponding evaluation function (we will call this function Success). This means that if one life is better than another, the Success function for the better life returns bigger value than for the worse life.\nHow are we to continue the definition of the meaning of life in a natural way so that it includes infinite lives as well. Let\u2019s take the sequence of the beginnings of an infinite life. Let\u2019s calculate the value of the function Success for each beginning. We get a sequence of real numbers and if this sequence is convergent, it is natural to define the function Success for this infinite life to be equal to its limit (here, plus and minus infinity are also possible limits). If\nthe sequence is divergent , then we will consider that the function Success for this infinite life does not have an exact value but that its value is somewhere between the limit inferior and limit superior of the sequence. Thus, we get a new function Success, which returns an exact value for some lives, and an interval of the lowest possible to the highest possible value for other lives.\nThus, the new function Success defines a partial order in the set of all lives (this order will not be linear). One life is better than another if the value of the function Success is bigger than the value of Success for the other, or if the interval this value is found in is to the right (i.e. is bigger) than the interval the other value is found in.\nThe Artificial Intelligence is a device left to understand the world on its own; however, the meaning of life should have been given in advance. We cannot expect the device to cope well, if it does not know which result is good and which is bad. The device must be able to calculate the function Success on its own at any given moment, and the function Success must depend only on the reward signals because the input and output signals have different purpose.\nThe simplest solution is to assume that we have one reward signal that returns the value of the function Success. This solution is not very good because in this way we are putting pressure on the world making it remember what has happened to the device up to the present moment so that it could give as reward an overall evaluation of its entire life. It is better to have one reward signal and the function Success to be the arithmetic mean of all values of this signal. Thus the world will evaluate the device for its last step and not for its entire life up to the present moment. When nothing interesting has happened on the current step and there is no need for the function Success to change, we may assume that the signal returns the previous value of Success and thus the arithmetic mean will be preserved; but then again, we are still putting pressure on the world making it remember what has happened up to the present moment and that\u2019s why for this case we will return the symbol Nothing. This is a simpler way to preserve the arithmetic mean.\nWhatever the function Success is, we can find an reward signal whose arithmetic mean is exactly this function. This reward signal is not specified exactly because at some moments we have a choice to select whether the signal is to return the symbol Nothing or to return its current arithmetic mean. We should also point out that we assume that the function Success returns zero for the empty life (for the life with a length of zero). This latter is not a problem since if we add a constant to the function Success or multiply it by a positive constant, we will not change the order it defines.\nTherefore, an arbitrary meaning of life could be presented as the arithmetic mean of an reward signal which returns a real number. Nonetheless, we\ndo not like this solution because we would like for the world to be stable and the evaluation (the function Success) not to be able to jump uncontrollably. That\u2019s why we will assume that the reward signal is a finite function and returns a value from the set {Nothing, 0, 1, ..., k}, i.e. we will assume that there are k+2 possible values. Therefore, the function Success will be in the [0, k] interval.\nThis solution is also not a perfect one because we might want to have different levels of priority. For example, it is important not to be late for school but it is much more important not to die in a car accident. Here, \u2018much more important\u2019 means \u2018infinitely more important\u2019. We want for our definitio to allow the world have N levels of priority. For the purpose thereof, we will assume that we have N reward signals and that the function Success returns not a number but a vector. This vector is derived by calculating the arithmetic mean by coordinates, where for each coordinate the sum is divided by the number of times this coordinate has been different from the symbol Nothing. The comparison between two such vectors will be made by coordinates. We take the coordinate of the highest level of priority, and if for this coordinate the values of the two vectors are equal, we take the next coordinate and so on and so forth.\nCould we emulate a world with two levels of priority, when the reward signal is not limited? Yes, let the small priority return 0 or 1, and the big priority return 0 or 2 multiplied by the number of times up to the current moment when the value of the signal has been different from the symbol Nothing. In addition, the world must remember the moment when it came out with 2 multiplied by something, and from that moment on add 2 to each reward. Thus, if a reward is obtained only from the small priority, the function Success will be in the interval [0, 1], but if we have a reward from the high priority, the function Success will be bigger than or equal to 2. Here, with this emulation, we eliminated the limitation of the reward signal and burdened the world remember what has happened up to the present moment.\nIs there a meaning of a life that cannot be presented by N levels of priority? The answer is \u2018Yes\u2019. Let\u2019s take a meaning of life that has a countable number of levels of priority. This could be emulated by an unlimited reward signal but cannot be presented by N limited reward signals for any N . Which means that by choosing this definition of the evaluation we limit ourselves and thus not every meaning of life would be possible; however, we believe that the worlds with N levels of priority are sufficient for the practice, and that it is not necessary to review worlds with countable levels of priority. What is more, for the practice, in most cases, it is sufficient for the level of priority to be one.\nApart from the N reward signals to calculate the function Success from,\nwe will also have yet another Boolean reward signal, which we will call \u2018an incorrect move\u2019. We will discuss this signal in the following section."}, {"heading": "Incorrect move", "text": "What is an incorrect move? For example, in chess, if a player tries to play with the knight with the moves of a queen, this would be an incorrect move. Also in chess, a player may not make any move which places his king in check, i.e. any move after which a player is in check is an incorrect move. There are many games in which capture is compulsory. In games like these, an incorrect move is when a player can capture but does not do so.\nIt is clear that in most worlds there are incorrect moves. Provided that we\u2019ve fixed the set of output vectors, it is natural to assume that not all of their values represent a correct move. It is normal, for a given output vector to represent a correct move at a given moment and at another moment to represent an incorrect move.\nTo allow the world to have incorrect moves, we should answer two questions: \u2018What happens with the world when the device plays an incorrect move\u2019, and \u2018How does the world return to the device information about the fact that the last move was an incorrect one?\u2019\nWe do not discuss incorrect moves in articles [1, 2]. In these articles we assume that the world punishes the device for an incorrect move by slapping it on the wrist (i.e. gives it a bad reward). For example, in the world where you play chess what will happen when you try to play an incorrect move? One possible solution is for us to define the world so that with each incorrect move you lose the game and you automatically start a new game.\nArticle [3] introduces a separate signal called \u2018an incorrect move\u2019. In this article we assume that the attempts of the device to play an incorrect move do not lead to a change in the world. The result is that the world remains in the same internal state but returns the signal \u2018incorrect move\u2019 to the device. The mistake in [3] is that the incorrect move is taken as punishment and it is assumed that the device will learn to play only correct moves and will avoid the incorrect ones to avoid being punished.\nThe information about which move is correct and which is not is very important for the understanding of the world. Let\u2019s take for example the situation when we are trying to find our way in the dark by touching the walls with our hands. The touching of the walls could be taken as an incorrect move because we are trying to push our hand through a space it cannot cross because there is a wall ahead. Nevertheless, we are consciously making this incorrect move in order to find out where the wall is.\nMaybe it\u2019s better to change the definition of a world given in [1, 2] and add one more function to the functions World and View, which define the world. We will call this function Correct. For each internal state of the world it returns the set of all possible moves.\nWe want to make the task of the device the simplest possible, and define the world in a way that is the most easy to grasp. That\u2019s why, it is reasonable to assume that at each step the device receives as an input not only the value of the function View but also the value of the function Correct.\nThus, we have two problems emerging: The first problem is that the information the function Correct will return could be too much. If the possible outputs are k in number, the possible values of the function Correct are 2k. Respectively, if the outputs are countably many in number, the value of the function Correct is a continuum, etc.\nThe second problem is that in this way we will complicate the world by imposing the requirement for it to calculate the function Correct at each step, to encode the result in a suitable format and transmit it to the device.\nWe will get rid of these problems, if we assume that the world does not explicitly tell the device which answers are correct but that at each incorrect move it returns information that the move is incorrect.\nThis means that we assume that we have one Boolean signal called \u2018an incorrect move\u2019. We will allow the device to make incorrect moves and when this signal returns a one, we will not consider this a punishment for the device but a piece of useful information.\nNevertheless, we will make four assumptions: 1. We will assume that the incorrect move does not change the internal state of the world, i.e. by making an incorrect move the device loses nothing. We may say that neither it gains something. The only thing gained is the information it obtains. By making a move and this move turns out to be an incorrect one, the device obtains the information that this move is incorrect, which may turn out a piece of useful information.\n2. We will assume that if we\u2019ve tried one move and the world has told us that it is incorrect, there is no need for the device to try it one more time while the state of the world is the same. Of course, if we assume that the function Correct is fixed and we know which the correct moves are before we\u2019ve tried them, the above assumption is correct, but we might want to assume something even weaker. For example, imagine a world with a builtin clock, which marks how much time the device took to think. In this world, the function Correct depends not only on the state of the world, but also on the time we took to make a move. Well, we will assume that even if the function Correct changes according to the delay, the incorrect moves will only increase in number, i.e. we will assume that if a move is incorrect, it\nwill be still incorrect even if we repeat it. 3. We will assume that the device has no right to make the same incorrect moves infinitely, i.e. that it must remember the incorrect moves it made and not repeat them at least until a correct move is received. Once a correct move is received, the device may clear its memory and try moves that have been incorrect because the fact that a move has been incorrect the previous step does not mean that it will be incorrect the next step.\nThe reason we made the aforementioned assumption is not to allow the device find itself in deadlock. Of course, the possible incorrect moves could be many or even infinitely many, which could again result in a delay or deadlock, but knowing that the possible outputs are finite or pseudo-infinite (which is also finite), we will come to the conclusion that, at least in theory, such a deadlock cannot occur.\n4. We will assume that the function Correct never returns the empty set, i.e. we will assume that there is always at least one correct move. If we assume that dead ends exist (i.e. situations in which the function Correct returns the empty set), we can associate these moments with death. We can think of death as a mistake which we are trying to avoid but this mistake is always fatal, and therefore we cannot learn from it. That\u2019s why it is better to think that there are no such moments in our world.\nAnd yet, when we are programming the device called AI, we may program it to look for a state in which there are more possible moves. In chess, we are trying to deploy our figures so that the possible moves are as many as possible. The loss of the queen highly reduces the number of possible moves, which makes this loss unwanted. In life, people strive for freedom. This means they want to have as many possible moves as possible. Any person closed in a very little or narrow place feels uncomfortable. Any locked or shackled man feels uncomfortable too. That\u2019s how we can explain people\u2019s strive for money and power because this gives additional freedom. When you have money you may or you may not buy a boat, but if don\u2019t have money, you don\u2019t have a choice. Therefore, man instinctively strives for a state giving him more opportunities. It is logical to use this principle with the Artificial Intelligence. If our device avoids cases when the possible moves are few in number, it would try to avoid death as well, since this is the case when we have no possible moves left.\nHow will we use the incorrect moves?\nOK, our device understands the world and knows which move is correct and which not. How will we expect it to act? When one move is incorrect for sure,\nthe device will not try it in order to avoid losing processor time (here \u2018for sure\u2019 means with a very high probability because nothing is absolutely sure). When a move is incorrect almost for sure, the device will try it because it loses nothing by trying it but only obtains information. If the move is really an incorrect one, this will be known with a much greater certainty the next time and, if by chance, it turns out to be correct, the device might lose but it might also win by finding new unsuspected opportunities. When it doesn\u2019t know whether the move is correct or incorrect, the device might try it but may also not try it. On one side, it will want to check whether the move is correct, but on the other, it will fear eventual unpleasant consequences. For example, you are not trying to jump off the window to see whether you will manage to do it, because if you do succeed by chance, the consequences might turn out to be very bad.\nQuestion: Are incorrect moves part of life? When we are trying an incorrect move, does this increase the number of steps (i.e. the parameter of time)? The answer is \u2018No\u2019. If we look at the Boolean signal \u2018incorrect move\u2019, we will see that it is zero for each t, i.e. all moves saved in the history are correct ones. We will assume that the incorrect moves are simply not saved in the history (life).\nLife is a sequence of input and output vectors. If the signal \u2018incorrect move\u2019 is one of the coordinates of the input vector, this coordinate is always a zero. We will assume that the signal \u2018incorrect move\u2019 is not a part of the history because it is useless to include a signal which is constantly a zero.\nAfter all, we said that we want the information obtained from the incorrect moves to be possible to be used. That\u2019s why, we will change the definition of life by inserting the set of vectors of the incorrect moves we\u2019ve tried between the input vector and the correct output vector. Life will become a sequence of an input vector, a set of incorrect output vectors, a correct output vector, etc.\nThe following article will discuss the dependencies without memory. These are dependencies of the type: \u2018If I see this and do that, the result will be this and that.\u2019 These dependencies are represented as implications of the type: a(t \u2212 1) = 1, b(t) = 0, do(t) = 1 \u21d2 bad move(t + 1) = 1. This implication must be read as follows: If the signal b at this step is a zero and if the signal a at the previous step was a one and if we chose the signal do at this step to be a one, then this is an incorrect move. We chose the signal do because it is an output signal, and the signals a and b are given because these are input signals which we do not chose but are given by the world.\nThis implication leads to bad move = 1 but this will not be saved in the history because only the correct moves are saved there.\nThe aforementioned implication tells us that with certain circumstances\ncertain move, will be incorrect. Here we see that on the basis of the information collected from the incorrect moves we can learn to predict such moves. The next article will show how from the fact that a certain move is incorrect we can extract more information about the state of the world and what will happen at the next step.\nAdding the incorrect moves to the definition\nof AI\nIn [4] we\u2019ve defined AI as a device whose IQ is sufficiently high. The calculation of the IQ uses as a base a set of test worlds by taking the average success of the device for the worlds within that set. The worlds used in [4] are the worlds generated by an arbitrary Turing machine (whose complexity does not exceed the value of a parameter we call \u2018level of intelligence\u2019).\nThe set of test worlds we\u2019ve used in [4] has been selected so as the worlds are maximally natural and comprehensible. The objective is not to encumber the device and make it understand incomprehensible worlds; on the contrary \u2013 we are trying to make things easier for it by making the worlds maximally natural and comprehensible.\nOne of the problems in [4] is that all moves in it are correct, i.e. the device we\u2019ve defined in [4] has not idea what an incorrect move is and would not be able to cope in a world in which some of the moves are incorrect ones. It would be nice if we could adjust the definition in [4] so that it allows worlds with incorrect moves. What is more, by adding the incorrect moves, the worlds would we\u2019ve chosen for test worlds would become more natural and comprehensible.\nYet another problem in [4] represents the worlds that get into deadlock. If the world is generated by an arbitrary Turing machine, this machine could find itself in deadlock at a given moment. The problems here are two: how do we know that the machine is in deadlock and what shall we do once we know it. The first problem in [4] is solved in simple way: if the machine does not come up with a result in 800 steps, we shall consider that it is in deadlock. We will not change the solution of the first problem, but we shall change the solution of the second one.\nIn [4], when the Turing machine is in deadlock we shut if off and restart it, i.e. we are saving what has been recorded on the tape, but we are changing its internal state so that its next state is the initial one. This solution is no good. It is like unplugging your PC out of the socket without taking care of what is to remain saved on the hard disk drive. An attitude like this towards\nyour PC could make its behavior rather complicated and unpredictable. By shutting-off the deadlocking program we are unduly making the world it generates more complicated. It would be better if once we\u2019ve stopped it we say to the device that this move has been incorrect and reboot the machine by recovering the information recorded on its tape to the moment the machine started working on that incorrect move. Thus, the fact that we\u2019ve made an incorrect move would not have an impact on the future in the respective world. Thus, the world generated by the machine would be much more natural and comprehensible.\nThere is yet another problem. It is possible for the arbitrary Turing machine to reach a state (of the tape) where each move leads to a deadlock. This means that we will have to give up the requirement of the existence of at least one correct move. The latter means that the world has to be one in which the device cannot \u2018die\u2019. In [4] we\u2019ve already given up the requirement for the world not to contain any fatal errors. Following the same logic and taking into account the same reasons, we could give up the requirement for the device not to be able to \u2018die\u2019. The notions of \u2018death\u2019 and \u2018fatal error\u2019 may look synonymous, but if you take a look at our definitions of them, you will see that they are two different things.\nIn [4], there is one more case when the Turing machine is shutting-off. There the life consist of 100 games each one no longer than 1000 steps. That is why, if one game continue more that 1000 steps it is shutting-off. Anyway, this is not a real shutting-off because we only add one \u2018draw\u2019 reward without changing the way the Turing machine works. (We don\u2019t change its internal state neither the configuration on the ribbon.)"}, {"heading": "Example", "text": "We will use the example we reviewed in [3]. This is the world of the game Tic-Tac-Toe, where the device does not see the entire board but only a single cell from it (Figure 1).\nThe eye of the device is located on top of the cell being viewed. The possible moves are six. The eye may move in four directions, we can put an X in the cell the eye is located on at the moment, and the sixth command is to request a new game (i.e. to clear all cells and start the game anew).\nIn [3] the world used only Boolean vectors; here, we will give up this limitation, which will make the definition of the world simpler and the world will respectively become easier to understand.\nInstead of two Boolean signals to encode what the eye sees, we will have one input signal with three possible values {0, 1, 2}, which will correspond\nto an empty cell, an X and an O. Instead of the two reward signals \u2018victory\u2019 and \u2018loss\u2019, we will have one with four possible values: {Nothing, 0, 1, 2}, which will correspond to \u2018no reward\u2019, \u2018loss\u2019, \u2018draw\u2019 and \u2018victory\u2019, instead of the three Boolean output signals, which coded the six possible outputs, now we will have four output signals. The first two will give us the direction of movement of the eye. We will call them vertical and horizontal. Their possible values will be in the set {0, 1, 2}, which will correspond to \u2018does not move\u2019, \u2018up\u2019 and \u2018down\u2019, or respectively \u2018does not move\u2019, \u2018left\u2019 and \u2018right\u2019. The other two output signals will be Boolean and we will call them put cross and new game. Their functions are clear.\nIn [3] we had six possible actions and at each move we could make only one of them. Now we can make four actions at one and the same time. If we want, we can make no action (by placing a zero on the four coordinates of the output vector). We could assume that we have the right to make only one action and any other output is taken by the world as an incorrect move, but it is more interesting to assume that we can make up to four actions in one single move. For example, we can put an X, move up and left and request a new game. Of course, all four actions must be correct because otherwise we will receive \u2018an incorrect move\u2019 and nothing will happen.\nWhen we put several actions in one move, we must specify their sequence. It is all the same whether we will first move up and then left or vice versa. It is all the same whether we will first move and then request a new game or vice versa. The only action which cannot commute with the rest is placing an X. That\u2019s why we will always assume that we have first put the X and then made all other actions.\nThus we present the game Tic-Tac-Toe from [3] as a world of one level of priority, with one input signal, four output and two rewards. (The second reward signal is \u2018an incorrect move\u2019, which remains as defined in [3].)\nWhy is the current representation of the world better than the one made in [3]? Because we have lesser encoding, which makes the world simpler and easier to understand. Let\u2019s take for example the rule: \u2018If the cell that\nyou see is not empty and if you try to put an X, this is an incorrect move\u2019. Now this rule could be presented as an implication of only three atoms: cell(t) 6= 0, put cross(t) = 1 \u21d2 bad move(t+ 1) = 1\nIn [3] this implication would comprise six atoms because there the signal cell is encoded with the use of two Boolean signals and the output \u2013 with the use of three signals. When we try to find a dependency without a memory, such as the above one, we have to decrease the number of implications by taking only the shortest of them. For this reason, the shortest an implication is, the better the chance for our device to locate it.\nBibliography\n. [1] Dobrev D. AI \u2013 What is this, In: PC Magazine \u2013 Bulgaria, November\u20192000, pp.12-13 (www.dobrev.com/AI/definition.html). [2] Dobrev D. A Definition of Artificial Intelligence, In: Mathematica Balkanica, New Series, Vol. 19, 2005, Fasc. 1-2, pp.67-74. [3] Dobrev D. Testing AI in one Artificial World, Proceedings of XI International Conference \u201dKnowledge-Dialogue-Solution\u201d, June 2005, Varna, Bulgaria, Vol.2, pp.461-464 (www.dobrev.com/AI/).\n[4] Dobrev D. Formal Definition of Artificial Intelligence, In: International Journal \u201cInformation Theories & Applications\u201d, vol.12, Number 3, 2005, pp.277-285 (www.dobrev.com/AI/).\n[5] Dobrev D. Comparison between the two definitions of AI, In: arXiv:1302.0216, January, 2013."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "This article tackles a number of technical issues related to the AI definition. These include the format of the data, the Undef and Nothing symbols, different ways of defining the meaning of life, as well as the introduction of the concept of \u2018incorrect move\u2019. These are issues of no material importance, if we are interested in the AI definition from a purely theoretical point of view; however, if we want to develop a real program satisfying that definition, we are to find these issues important.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}