{"id": "1312.6105", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "Hybrid Automated Reasoning Tools: from Black-box to Clear-box Integration", "abstract": "Recently, researchers in answer set programming and constraint programming spent significant efforts in the development of hybrid languages and solving algorithms combining the strengths of these traditionally separate fields. These efforts resulted in a new research area: constraint answer set programming (CASP). CASP languages and systems proved to be largely successful at providing efficient solutions to problems involving hybrid reasoning tasks, such as scheduling problems with elements of planning. Yet, the development of CASP systems is difficult, requiring non-trivial expertise in multiple areas. This suggests a need for a study identifying general development principles of hybrid systems. Once these principles and their implications are well understood, the development of hybrid languages and systems may become a well-established and well-understood routine process. As a step in this direction, in this paper we conduct a case study aimed at evaluating various integration schemas of CASP methods. Using the first steps of the research, we can identify the principles of hybrid algorithms and how they could be implemented.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Fri, 20 Dec 2013 20:44:58 GMT  (204kb,D)", "http://arxiv.org/abs/1312.6105v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["marcello balduccini", "yulia lierler"], "accepted": false, "id": "1312.6105"}, "pdf": {"name": "1312.6105.pdf", "metadata": {"source": "CRF", "title": "Hybrid Automated Reasoning Tools: from Black-box to Clear-box Integration", "authors": ["Marcello Balduccini", "Yulia Lierler"], "emails": ["marcello.balduccini@gmail.com", "ylierler@unomaha.edu"], "sections": [{"heading": "1 Introduction", "text": "Knowledge representation and automated reasoning are areas of Artificial Intelligence dedicated to understanding and automating various aspects of reasoning. Such traditionally separate fields of AI as answer set programming (ASP) [4], propositional satisfiability (SAT) [13], constraint (logic) programming (CSP/CLP) [22,14] are all representatives of directions of research in automated reasoning. The algorithmic techniques developed in subfields of automated reasoning are often suitable for distinct reasoning tasks. For example, answer set programming proved to be an effective tool for formalizing elaborate planning tasks whereas CSP is efficient in solving difficult scheduling problems. Nevertheless, if the task is to solve complex scheduling problems requiring elements of planning then neither ASP nor CSP alone is sufficient. In recent years, researchers attempted to address this problem by developing hybrid approaches that combine algorithms and systems from different AI subfields. Research in satisfiability modulo theories (SMT) [21] is a well-known example of this trend.\nMore recent examples include constraint answer set programming (CASP) [16], which integrates answer set programming with constraint (logic) programming. Constraint answer set programming allows to combine the best of two different automated\nar X\niv :1\n31 2.\n61 05\nv1 [\ncs .A\nI] 2\n0 D\nreasoning worlds: (1) modeling capabilities of ASP together with advances of its SATlike technology in solving and (2) constraint processing techniques for effective reasoning over non-boolean constructs. This new area has already demonstrated promising activity, including the development of the CASP solvers ACSOLVER [19], CLINGCON [11], EZCSP [2], and IDP [25]. Related techniques have also been used in the domain of hybrid planning for robotics [23]. CASP opens new horizons for declarative programming applications. Yet the developments in this field pose a number of questions, which also apply to the automated reasoning community as a whole.\nThe broad attention received by the SMT and CASP paradigms, which aim to integrate and build synergies between diverse constraint technologies, and the success they enjoyed suggest a necessity of a principled and general study of methods to develop such hybrid solvers. [16] provides a study of the relationship between various CASP solvers highlighting the importance of creating unifying approaches to describe such systems. For instance, the CASP systems ACSOLVER, CLINGCON, and EZCSP came to being within two consecutive years. These systems rely on different ASP and CSP technologies, so it is difficult to clearly articulate their similarities and differences. In addition, the CASP solvers adopt different communication schemas among their heterogeneous solving components. The system EZCSP adopts a \u201cblack-box\u201d architecture, whereas ACSOLVER and CLINGCON advocate tighter integration. The crucial message transpiring from these developments in the CASP community is the ever growing need for standardized techniques to integrate computational methods spanning multiple research areas. Currently such an integration requires nontrivial expertise in multiple areas, for instance, in SAT, ASP and CSP. We argue for undertaking an effort to mitigate difficulties of designing hybrid reasoning systems by identifying general principles for their development and studying the implications of various design choices.\nAs a step in this direction, in this paper we conduct a case study aiming to explore a crucial aspect in building hybrid systems \u2013 the integration schemas of participating solving methods. We study various integration schemas and their performance, using CASP as our test-bed domain. As an exemplary subject for our study we take the CASP system EZCSP. Originally, EZCSP was developed as an inference engine for CASP that allowed a lightweight, black-box, integration of ASP and CSP. In order for our analysis to be conclusive we found it important to study the different integration mechanisms using the same technology. Within the course of this work we implemented \u201cgrey-box\u201d and \u201cclear-box\u201d approaches for combining ASP and CSP reasoning within EZCSP. We evaluate these configurations of EZCSP on three domains \u2013 Weighted Sequence, Incremental Scheduling, and Reverse Folding \u2013 from the Model and Solve track of the Third Answer Set Programming Competition \u2013 2011 (ASPCOMP) [1]. Hybrid paradigms such as CASP allow for mixing language constructs and computational mechanisms stemming from different formalisms. Yet, one may design encodings that favor only single reasoning capabilities of a hybrid system. For this reason, in our study we evaluate different encodings for the proposed benchmarks that we call \u201cpure ASP\u201d, \u201ctrue CASP\u201d, and \u201cpure CSP\u201d. As a result we expect to draw a comprehensive picture comparing and contrasting various integration schemas on several kinds of encodings possible within hybrid approaches.\nWe start with a brief review of the CASP formalism. Then we draw a parallel to SMT solving, aimed at showing that it is possible to transfer to SMT the results obtained in this work for CASP solving. In Section 3 we review the integration schemas used in the design of hybrid solvers focusing on the schemas implemented in EZCSP within this project. Section 4 provides a brief introduction to the application domains considered, and discusses the variants of the encodings we compared. Experimental results and their analysis form Section 5."}, {"heading": "2 Review: the CASP and SMT problems", "text": "The review of logic programs with constraint atoms follows the lines of [15]. A regular program is a finite set of rules of the form\na0 \u2190 a1, . . . , al, not al+1, . . . , not am, not not am+1, . . . , not not an, (1)\nwhere a0 is \u22a5 or an atom, and each ai (1 \u2264 i \u2264 n) is an atom. This is a special case of programs with nested expressions [18]. We refer the reader to [18] for details on the definition of an answer set of a logic program. A choice rule construct {a} [20] of the LPARSE language can be seen as an abbreviation for a rule a\u2190 not not a [9]. We adopt this abbreviation.\nA constraint satisfaction problem (CSP) is defined as a triple \u3008X,D,C\u3009, where X is a set of variables, D is a domain of values, and C is a set of constraints. Every constraint is a pair \u3008t, R\u3009, where t is an n-tuple of variables and R is an n-ary relation on D. An evaluation of the variables is a function from the set of variables to the domain of values, \u03bd : X \u2192 D. An evaluation \u03bd satisfies a constraint \u3008(x1, . . . , xn), R\u3009 if (v(x1), . . . , v(xn)) \u2208 R. A solution is an evaluation that satisfies all constraints.\nConsider an alphabet consisting of regular and constraint atoms, denoted by A and C respectively. By C\u0303, we denote the set of all literals over C. The constraint literals are identified with constraints via a function \u03b3 : C\u0303 \u2192 C so that for any literal l, \u03b3(l) has a solution if and only if \u03b3(l) does not have one (where l denotes a complement of l). For a set Y of constraint literals over C, by \u03b3(Y ) we denote a set of corresponding constraints, i.e., {\u03b3(c) | c \u2208 Y }. Furthermore, each variable in \u03b3(Y ) is associated with a domain. For a set M of literals, by M+ and MC we denote the set of positive literals in M and the set of constraint literals over C in M , respectively.\nA logic program with constraint atoms is a regular logic program over an extended alphabet A \u222a C such that, in rules of the form (1), a0 is \u22a5 or a0 \u2208 A. Given a logic program with constraint atoms \u03a0 , by \u03a0C we denote \u03a0 extended with choice rules {c} for each constraint atom c occurring in \u03a0 . We say that a consistent and complete set M of literals over atoms of \u03a0 is an answer set of \u03a0 if\n(a1) M+ is an answer set of \u03a0C and (a2) MC has a solution.\nThe CASP problem is the problem of determining, given a logic program with constraint atoms \u03a0 , whether \u03a0 has an answer set.\nFor example, let \u03a0 be the program\nam\u2190 X < 12 lightOn\u2190 switch, not am {switch} \u22a5 \u2190 not lightOn.\n(2)\nIntuitively, this program states that (a) light is on only if an action of switch occurs during the pm hours and (b) light is on (according to the last rule in the program). Consider a domain of X to be integers from 0 till 24. It is easy to see that a set\n{switch, lightOn,\u00ac am,\u00acX < 12}\nforms the only answer set of program (2). One may now draw a parallel to satisfiability modulo theories (SMT). To do so we first formally define the SMT problem. A theory T is a set of closed first-order formulas. A CNF formula F (a set of clauses) is T -satisfiable if F \u2227 T is satisfiable in the first-order sense. Otherwise, it is called T -unsatisfiable. Let M be a set of literals. We sometimes may identify M with a conjunction consisting of all its elements. We say that M is a T -model of F if\n(m1) M is a model of F and (m2) M is T -satisfiable.\nThe SMT problem for a theory T is the problem of determining, given a formula F , whether F has a T -model. It is easy to see that in the CASP problem, \u03a0C in condition (a1) plays the role of F in (m1) in the SMT problem. At the same time, the condition (a2) is similar in nature to the condition (m2).\nGiven this tight conceptual relation between the SMT and CASP formalisms, it is not surprising that solvers stemming from these different research areas share a lot in common in their design even though these areas have been developing to a large degree independently (CASP being a much younger field). We start next section by reviewing major design principles/methods in crafting SMT solvers. We then discuss how CASP solvers follow one or another method. This discussion allows us to systematize solvers\u2019 design patterns present both in SMT and CASP so that their relation becomes clearer. Such transparent view on solvers\u2019 architectures immediately translates findings in one area into another. Thus although the case study conducted in this research uses CASP technology only, we expect similar results to hold for SMT, and for the construction of hybrid automated reasoning methods in general."}, {"heading": "3 SMT/CASP Integration Schemas", "text": "Satisfiability modulo theories (SMT) integrates different theories \u201cunder one roof\u201d. Often it also integrates different computational procedures for processing such hybrid theories. We are interested in these synergic procedures explored by the SMT community over the past decade. We follow [21, Section 3.2] for a review of several integration techniques exploited in SMT.\nIn every discussed approach, a formula F is treated as a satisfiability formula where each of its atoms is considered as a propositional symbol, forgetting about the theory T . Such view naturally invites an idea of lazy integration: the formula F is given to a SAT solver, if the solver determines that F is unsatisfiable then F is T -unsatisfiable as well. Otherwise, a propositional model M of F found by the SAT solver is checked by a specialized T -solver which determines whether M is T -satisfiable. If so, then it is also a T -model of F , otherwise M is used to build a clause C that precludes this assignment, i.e., M 6|= C while F \u222a C is T -satisfiable if and only if F is T - satisfiable. The SAT solver is invoked on an augmented formula F \u222aC. Such process is repeated until the procedure finds a T -model or returns unsatisfiable. Note how in this approach two automated reasoning systems \u2013 a SAT solver and a specialized T -solver \u2013 interleave: a SAT solver generates \u201ccandidate models\u201d whereas a T -solver tests whether these models are in accordance with requirements specified by theory T . We find that it is convenient to introduce the following terminology for the future discussion: a base solver and a theory solver, where a base solver is responsible for generating candidate models and theory solver is responsible for any additional testing required for stating whether a candidate model is indeed a solution.\nIt is easy to see how the lazy integration policy translates into the realm of CASP. Given a program with constraint atoms \u03a0 , an answer set solver serves the role of a base solver by generating answer sets of \u03a0C (that are \u201ccandidate answer sets\u201d for \u03a0) and then uses a CLP/CSP solver as a theory solver to verify whether condition (a2) is satisfied on these candidate answer sets. Constraint answer set solver EZCSP embraces the lazy integration approach in its design.3 To solve the CASP problem, EZCSP offers a user several options for base and theory solvers. For instance, it allows for the use of answer set solvers CLASP [10], CMODELS [12], DLV [5] as base solvers and CLP systems SICSTUS PROLOG [24] and BPROLOG [26] as theory solvers. Such variety in possible configurations of EZCSP illustrates how lazy integration provides great flexibility in choosing underlying base and theory solving technology in addressing problems of interest.\nThe Davis-Putnam-Logemann-Loveland (DPLL) procedure [6] is a backtrackingbased search algorithm for deciding the satisfiability of a propositional CNF formula. DPLL-like procedures form the basis for most modern SAT solvers as well as answer set solvers. If a DPLL-like procedure underlies a base solver in the SMT and CASP tasks then it opens a door to several refinements of lazy integration. We now describe these refinements that will also be a focus of the present case study.\nIn the lazy integration approach a base solver is invoked iteratively. Consider the SMT task: a CNF formula Fi+1 of the i + 1th iteration to a SAT solver consists of a CNF formula Fi of the ith iteration and an additional clause (or a set of clauses). Modern DPLL-like solvers commonly implement such technique as incremental solving. For instance, incremental SAT-solving allows the user to solve several SAT problems F1, . . . , Fn one after another (using single invocation of the solver), if Fi+1 results from Fi by adding clauses. In turn, the solution to Fi+1 may benefit from the knowledge obtained during solving F1, . . . , Fi. Various modern SAT-solvers, including MIN-\n3 [2] refers to lazy integration of EZCSP as lightweight integration of ASP and constraint programming.\nISAT [7,8], implement interfaces for incremental SAT solving. Similarly, the answer set solver CMODELS implements an interface that allows the user to solve several ASP problems \u03a01, . . . ,\u03a0n one after another, if \u03a0i+1 results from \u03a0i by adding a set of rules whose heads are \u22a5. It is natural to utilize incremental DPLL-like procedures for enhancing the lazy integration protocol: we call this refinement lazy+ integration. In this approach rather than invoking a base solver from scratch an incremental interface provided by a solver is used to implement the iterative process.\n[21] also reviews such integration techniques used in SMT as on-line SAT solver and theory propagation. In the on-line SAT solver approach, the T -satisfiability of the (partial) assignment is checked incrementally, while the assignment is being built by the DPLL-like procedure. This can be done fully eagerly as soon as a change in the partial assignment occurs or at some regular intervals, for instance. Once the inconsistency is detected, a SAT solver is instructed to backtrack. The theory propagation approach extends the on-line SAT solver technique by allowing a theory solver not only to verify that a current partial assignment is T -consistent but also to detect literals in a CNF formula that must hold given the current partial assignment. The CASP solver CLINGCON exemplifies the implementation of the theory propagation integration schema in CASP by unifying answer set solver CLASP as a base solver and constraint processing system GECODE. ACSOLVER and IDP systems are other CASP solvers that implement the theory propagation integration schema. Three Kinds of EZCSP: To conduct our analysis of various integration schemas and their effect on the performance of the hybrid systems we used the CASP solver EZCSP as a baseline technology. As mentioned earlier, original EZCSP implements the lazy integration schema. In the course of this work we developed enhanced interfaces with answer set solver CMODELS that allowed for the two other integration schemas: lazy+ integration and on-line SAT solver. These implementations rely on API interfaces provided by CMODELS allowing for varying level of integration between the solvers. The development of these API interfaces in CMODELS was greatly facilitated by the API interface provided by MINISAT v. 1.12b supporting non-clausal constraints [8]. In the following we call\n\u2013 EZCSP implementing lazy integration with CMODELS as a base solver \u2013 a blackbox. \u2013 EZCSP implementing lazy+ integration with CMODELS \u2013 a grey-box. \u2013 EZCSP implementing on-line SAT solver integration with CMODELS (fully eagerly)\n\u2013 a clear-box.\nIn all these configurations of EZCSP we assume BPROLOG to serve in the role of a theory solver."}, {"heading": "4 Application Domains", "text": "In this work we compare and contrast different integration schemas of hybrid solvers on three application domains that stem from various subareas of computer science. This section provides a brief overview of these applications. All benchmark domains are from the Third Answer Set Programming Competition \u2013 2011 (ASPCOMP) [1], in\nparticular, the Model and Solve track. We chose these domains for our investigation as they display features that benefit from the synergy of computational methods in ASP and CSP. Each considered problem contains variables ranging over a large integer domain thus making grounding required in pure ASP a bottleneck. On the other hand, the modeling capabilities of ASP and availability of such sophisticated solving technique as learning makes ASP attractive for designing solutions to these domains. As a result, CASP languages and solvers become a natural choice for these benchmarks making them ideal for our investigation.\nThree Kinds of CASP Encodings: It is easy to note that hybrid languages such as CASP allow for mix-and-match constructs and processing techniques stemming from different formalisms. Yet, any pure ASP encoding of a problem is also a CASP formalization of the same problem. Similarly, it is possible to encode a problem in such a way that only the CSP solving capabilities of the CASP paradigm are employed. In this study for two of the benchmarks we considered three kinds of encodings in the CASP language of EZCSP: pure-ASP encoding; pure-CSP encoding; and true-CASP encoding. In the third benchmark, the use of three distinct encodings was not possible because both ASP and CSP features play a major role in the efficiency of the computation.\nAnalysis of these varying kinds of encodings in CASP gives us a better perspective on how different integration schemas are effected by the design choices made during the encoding of a problem. At the same time considering the encoding variety allows us to verify our intuition that true-CASP is an appropriate modeling and solving choice for the explored domains.\nThe weighted-sequence (WSEQ) domain is a handcrafted benchmark problem. Its key features are inspired by the important industrial problem of finding an optimal join order by cost-based query optimizers in database systems. [17] provides a complete description of the problem itself as well as the formalization that became \u201cgolden standard\u201d in this work, i.e., the formalization named SEQ++.\nIn the weighted-sequence problem we are given a set of leaves (nodes) and an integer m \u2013 maximum cost. Each leaf is a pair (weight, cardinality) where weight and cardinality are integers. Every sequence (permutation) of leaves is such that all leaves but the first are assigned a color that, in turn, associates a leaf with a cost (via a cost formula). A colored sequence is associated with the cost that is a sum of leaves\u2019 costs. The task is to find a colored sequence with cost at most m. We refer the reader to [17] for the details of pure-ASP encoding SEQ++. The same paper also contains the details on a true-CASP variant of SEQ++ in the language of CLINGCON. We further adapted that encoding to the language of EZCSP by means of simple syntactic transformations. Here we provide a review of details of the SEQ++ formalization that we find most relevant to this presentation. The non-domain predicates of the pure-ASP encoding are leafPos , posColor, posCost. Intuitively, leafPos is responsible for assigning a position to a leaf, posColor is responsible for assigning a color to each position, posCost carries information on costs associated with each leaf. The main difference between the pure-ASP and true-CASP encodings is in the treatment of the cost values of the leaves. We first note that cost predicate posCost in the pure-ASP encoding is \u201dfunctional\u201d. In other words, when this predicate occurs in an answer set its first argument uniquely determines its second argument. Often, such functional predicates in ASP en-\ncodings can be replaced by constraint atoms in CASP encodings. Indeed, this is the case in the weighted-sequence problem. Thus in the true-CASP encoding, predicate posCost is replaced by constraint atoms, making it possible to evaluate cost values by CSP techniques. This approach is expected to benefit performance especially when the cost values are large. Predicates leafPos and posColor are also functional. The pure-CSP encoding is obtained from the true-CASP encoding by replacing leafPos and posColor predicates by constraint atoms.\nThe incremental scheduling (IS) domain stems from a problem occurring in commercial printing. In this domain, a schedule is maintained up-to-date with respect to jobs being added and equipment going offline. A problem description includes a set of devices, each with predefined number of instances (slots for jobs), and a set of jobs to be produced. The penalty for a job being tardy is computed as td \u00b7 imp, where td is the job\u2019s tardiness and imp is a positive integer denoting the job\u2019s importance. The total penalty of a schedule is the sum of the penalties of the jobs. The task is to find a schedule whose total penalty is no larger than the value specified in a problem instance. We direct the reader to [3] for a complete description of the domain. The pure-CSP encoding used in our experiments is the official competition encoding submitted to ASPCOMP by the EZCSP team. In this encoding, constraint atoms are used for (i) assigning start times to jobs, (ii) selecting which device instance will perform a job, and (iii) calculating tardiness and penalties. The true-CASP encoding was obtained from the pure-CSP encoding by introducing a new relation on instance(j, i), stating that job j runs on device-instance i. This relation and ASP constructs of the EZCSP language replaced the constraint atoms responsible for the assignment of device instances in the pure-CSP encoding. The pure-ASP encoding was obtained from the true-CASP encoding by introducing suitable new relations, such as start(j, s) and penalty(j, p), to replace all the remaining constraint atoms.\nIn the reverse folding (RF) domain, one manipulates a sequence of n pairwise connected segments located on a 2D plane in order to take the sequence from an initial configuration to a goal configuration. The sequence is manipulated by pivot moves: rotations of a segment around its starting point by 90 degree in either direction. A pivot move on a segment causes the segments that follow to rotate around the same center. Concurrent pivot moves are prohibited. At the end of each move, the segments in the sequence must not intersect. A problem instance specifies the number of segments, the goal configuration, and required number of moves, t. The task is to find a sequence of exactly t pivot moves that produces the goal configuration. The true-CASP encoding used for our experiments is from the official ASPCOMP 2011 submission package of the EZCSP team. In this encoding, relation pivot(s, i, d) states that at step s the ith segment is rotated in direction d. The effects of pivot moves are described by constraint atoms, which allow carrying out the corresponding calculations with CSP techniques. The pure-ASP encoding was obtained from the true-CASP encoding by adopting an ASP-based formalization of the effects of pivot moves. This was accomplished by introducing two new relations, tfoldx (s, i, x) and tfoldy(s, i, y), stating that the new start of segment i at step s is \u3008x, y\u3009. The definition of the relations is provided by suitable ASP rules."}, {"heading": "5 Experimental Results", "text": "The experimental comparison of the integration schemas was conducted on a computer with an Intel Core i7 processor running at 3GHz. Memory limit for each process and timeout considered were 3 GB RAM and 6, 000 seconds respectively. The version of EZCSP used in the experiments was 1.6.20b49: it incorporated CMODELS version 3.83 as a base solver and BPROLOG 7.4 3 as a theory solver. Answer set solver CMODELS 3.83 was also used for the experiments with the pureASP encodings. In order to provide a frame of reference with respect to the state of the art in CASP, the tables for WSEQ and IS include performance information for CLINGCON 2.0.3 on true-CASP encodings adapted to the language of CLINGCON. The ezcsp executable used in the experiments and the encodings can be downloaded from http://www.mbalduccini.tk/ezcsp/aspocp2013/ezcsp-binaries.tgz and\nhttp://www.mbalduccini.tk/ezcsp/aspocp2013/experiments.tgz respectively. In all figures presented:\n\u2013 CASP Black, CASP Grey, CASP Clear denote EZCSP implementing respectively black-box, grey-box and clear-box, and running a true-CASP encoding; \u2013 Pure-CSP denotes EZCSP implementing black-box running a pure-CSP encoding (note that for pure-CSP encodings there is no difference in performance between the integration schemas); \u2013 ASP denotes CMODELS running a pure-ASP encoding; \u2013 Clingcon denotes CLINGCON running a true-CASP encoding.\nWe begin our analysis with WSEQ. The instances used in the experiments are the 30 instances available via ASPCOMP. WSEQ proves to be a domain that truly requires the interaction of the ASP and CSP solvers. Answer set solver CMODELS on the pureASP encoding runs out of memory on every instance (in the tables, out-of-memory conditions and timeouts are both rendered as out-of-time results). EZCSP on the pureCSP encoding reaches the timeout limit on every instance. The true-CASP encoding running in black-box also times out on every instance. As shown in Figure 1, the trueCASP encoding running in grey-box performs slightly better. The true-CASP encoding running in clear-box instead performs substantially better. Figure 2 reports the total times across all the instances for all solvers/encodings pairs considered. Notably, CASP solver CLINGCON on true-CASP encoding is several orders of magnitude faster than any other configuration. This confirms that for this domain tight integration schemas indeed have an advantage. Recall that CLINGCON implements a tighter integration schema than that of EZCSP clear-box that, in addition to the on-line SAT solver schema of clear-box, also includes theory propagation. Answer set solver CLASP serves the role of base solver of CLINGCON whereas GECODE is the theory solver.\nIn case of the IS domain we considered two sets of experiments. In the former we used the 50 official instances from ASPCOMP. We refer to these instances as easy.\nFigure 4 depicts the overall per-instance performance on the IS-easy domain. It appears that tight integration schemas have an advantage, allowing the true-CASP encoding to outperform the pure-CSP encoding. As one might expect, the best performance for the true-CASP encoding is obtained with the clear-box integration schema, as shown in Figure 3 and in Figure 5. Figure 3 provides a comparison of the total times. In this case the early pruning of the search space made possible by the clear-box architecture yields substantial benefits. As expected, it is also the case that grey-box is faster than blackbox. As for WSEQ, CLINGCON is the fastest, and CMODELS on the pure-ASP encoding runs out of memory in all the instances.\nThe next experiment reveals an interesting change in behavior of solver/encodings pairs as the complexity of the instances of the IS domain grows. In this test, we used a set of 30 instances obtained by (1) generating randomly 500 fresh instances; (2) running the true-CASP encoding with the grey-box integration schema on them with a timeout\nof 300 seconds; (3) selecting randomly, from those, 15 instances that resulted in timeout and 15 instances that were solved in 25 seconds or more. The numerical parameters used in the process were selected with the purpose of identifying challenging instances. The overall per-instance execution times reported in Figure 7 clearly indicate the level of difficulty of the selected instances. Remarkably, these more difficult instances are solved more efficiently by the pure-CSP encoding that relies only on the CSP solver, as evidenced by Figure 6. In fact, the pure-CSP encoding outperforms every other method of computation, including CLINGCON on true-CASP encoding. More specifically, solving the instances with the true-CASP encoding takes between 30% and 50% longer than with the pure-CSP encoding. (Once again, CMODELS runs out of memory.)\nThe final experiment focuses on the RF domain. We used the 50 official instances from ASPCOMP to conduct the analysis. Figure 9 presented shows that this domain is comparatively easy. Figure 10 illustrates that the black-box and grey-box integration schemas are several orders of magnitude faster than clear-box. This somewhat surpris-\ning result can be explained by the fact that in this domain frequent checks with the theory solver add more overhead rather than being of help in identifying an earlier point to backtrack. CMODELS on the pure-ASP encoding runs out of memory in all but 3 instances. The total execution times are presented in Figure 8."}, {"heading": "6 Conclusions", "text": "The case study conducted in this work clearly illustrates the influence that integration methods have on the behavior of hybrid systems. Each integration schema may be of use and importance for some domain. Thus systematic means ought to be found for facilitating building hybrid systems supporting various coupling mechanisms. Building clear and flexible API interfaces allowing for various types of interactions between the solvers seems a necessary step towards making the development of hybrid solving\nsystems effective. This work provides evidence for the need of an effort to this ultimate goal."}], "references": [{"title": "Representing constraint satisfaction problems in answer set programming", "author": ["M. Balduccini"], "venue": "Proceedings of ICLP\u201909 Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP\u201909)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2009}, {"title": "Industrial-Size Scheduling with ASP+CP", "author": ["M. Balduccini"], "venue": "Delgrande, J.P., Faber, W. (eds.) 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR11). Lecture Notes in Artificial Intelligence (LNCS), vol. 6645, pp. 284\u2013296. Springer Verlag, Berlin", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "I. Niemel\u00e4", "M. Truszczy\u0144ski"], "venue": "Communications of the ACM 54(12), 92\u2013103", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "The DLV system: Model generator and application frontends", "author": ["S. Citrigno", "T. Eiter", "W. Faber", "G. Gottlob", "C. Koch", "N. Leone", "C. Mateis", "G. Pfeifer", "F. Scarcello"], "venue": "Proceedings of Workshop on Logic Programming (WLP97)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1997}, {"title": "A machine program for theorem proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM 5(7), 394\u2013397", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1962}, {"title": "Effective preprocessing in sat through variable and clause elimination", "author": ["N. Een", "A. Biere"], "venue": "SAT", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2005}, {"title": "An extensible sat-solver", "author": ["N. Een", "N. S\u00f6rensson"], "venue": "SAT", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}, {"title": "Weight constraints as nested expressions", "author": ["P. Ferraris", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming 5, 45\u201374", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Proceedings of 20th International Joint Conference on Artificial Intelligence (IJCAI\u201907). pp. 386\u2013392. MIT Press", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Constraint answer set solving", "author": ["M. Gebser", "M. Ostrowski", "T. Schaub"], "venue": "Proceedings of 25th International Conference on Logic Programming (ICLP). pp. 235\u2013249. Springer", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning 36, 345\u2013377", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Satisfiability solvers", "author": ["C.P. Gomes", "H. Kautz", "A. Sabharwal", "B. Selman"], "venue": "van Harmelen, F., Lifschitz, V., Porter, B. (eds.) Handbook of Knowledge Representation, pp. 89\u2013134. Elsevier", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2008}, {"title": "Constraint logic programming: A survey", "author": ["J. Jaffar", "M. Maher"], "venue": "Journal of Logic Programming 19(20), 503\u2013581", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1994}, {"title": "Constraint answer set programming (2012), http://www.cs.utexas", "author": ["Y. Lierler"], "venue": null, "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "On the relation of constraint answer set programming languages and algorithms", "author": ["Y. Lierler"], "venue": "Proceedings of the 26th Conference on Artificial Intelligence (AAAI-12). MIT Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "Weighted-sequence problem: Asp vs casp and declarative vs problem oriented solving", "author": ["Y. Lierler", "S. Smith", "M. Truszczynski", "A. Westlund"], "venue": "Fourteenth International Symposium on Practical Aspects of Declarative Languages", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Nested expressions in logic programs", "author": ["V. Lifschitz", "L.R. Tang", "H. Turner"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 369\u2013389", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1999}, {"title": "Integrating answer set programming and constraint logic programming", "author": ["V.S. Mellarkod", "M. Gelfond", "Y. Zhang"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2008}, {"title": "Extending the Smodels system with cardinality and weight constraints", "author": ["I. Niemel\u00e4", "P. Simons"], "venue": "Minker, J. (ed.) Logic-Based Artificial Intelligence, pp. 491\u2013521. Kluwer", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2000}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM 53(6), 937\u2013977", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2006}, {"title": "Constraint porgramming", "author": ["F. Rossi", "P. van Beck", "T. Walsh"], "venue": "van Harmelen, F., Lifschitz, V., Porter, B. (eds.) Handbook of Knowledge Representation, pp. 181\u2013212. Elsevier", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2008}, {"title": "A Systematic Analysis of Levels of Integration between Low-Level Reasoning and Task Planning", "author": ["P. Schuller", "V. Patoglu", "E. Erdem"], "venue": "Workshop on Combining Task and Motion Planning at the IEEE International Conference on Robotics and Automation 2013", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "The IDP system: a model expansion system for an extension of classical logic", "author": ["J. Wittocx", "M. Mari\u00ebn", "M. Denecker"], "venue": "LaSh. pp. 153\u2013165", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2008}, {"title": "The language features and architecture of B-Prolog", "author": ["N.F. Zhou"], "venue": "Journal of Theory and Practice of Logic Programming (TPLP) 12(1\u20132), 189\u2013218", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 2, "context": "Such traditionally separate fields of AI as answer set programming (ASP) [4], propositional satisfiability (SAT) [13], constraint (logic) programming (CSP/CLP) [22,14] are all representatives of directions of research in automated reasoning.", "startOffset": 73, "endOffset": 76}, {"referenceID": 11, "context": "Such traditionally separate fields of AI as answer set programming (ASP) [4], propositional satisfiability (SAT) [13], constraint (logic) programming (CSP/CLP) [22,14] are all representatives of directions of research in automated reasoning.", "startOffset": 113, "endOffset": 117}, {"referenceID": 20, "context": "Such traditionally separate fields of AI as answer set programming (ASP) [4], propositional satisfiability (SAT) [13], constraint (logic) programming (CSP/CLP) [22,14] are all representatives of directions of research in automated reasoning.", "startOffset": 160, "endOffset": 167}, {"referenceID": 12, "context": "Such traditionally separate fields of AI as answer set programming (ASP) [4], propositional satisfiability (SAT) [13], constraint (logic) programming (CSP/CLP) [22,14] are all representatives of directions of research in automated reasoning.", "startOffset": 160, "endOffset": 167}, {"referenceID": 19, "context": "Research in satisfiability modulo theories (SMT) [21] is a well-known example of this trend.", "startOffset": 49, "endOffset": 53}, {"referenceID": 14, "context": "More recent examples include constraint answer set programming (CASP) [16], which integrates answer set programming with constraint (logic) programming.", "startOffset": 70, "endOffset": 74}, {"referenceID": 17, "context": "This new area has already demonstrated promising activity, including the development of the CASP solvers ACSOLVER [19], CLINGCON [11], EZCSP [2], and IDP [25].", "startOffset": 114, "endOffset": 118}, {"referenceID": 9, "context": "This new area has already demonstrated promising activity, including the development of the CASP solvers ACSOLVER [19], CLINGCON [11], EZCSP [2], and IDP [25].", "startOffset": 129, "endOffset": 133}, {"referenceID": 0, "context": "This new area has already demonstrated promising activity, including the development of the CASP solvers ACSOLVER [19], CLINGCON [11], EZCSP [2], and IDP [25].", "startOffset": 141, "endOffset": 144}, {"referenceID": 22, "context": "This new area has already demonstrated promising activity, including the development of the CASP solvers ACSOLVER [19], CLINGCON [11], EZCSP [2], and IDP [25].", "startOffset": 154, "endOffset": 158}, {"referenceID": 21, "context": "Related techniques have also been used in the domain of hybrid planning for robotics [23].", "startOffset": 85, "endOffset": 89}, {"referenceID": 14, "context": "[16] provides a study of the relationship between various CASP solvers highlighting the importance of creating unifying approaches to describe such systems.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "The review of logic programs with constraint atoms follows the lines of [15].", "startOffset": 72, "endOffset": 76}, {"referenceID": 16, "context": "This is a special case of programs with nested expressions [18].", "startOffset": 59, "endOffset": 63}, {"referenceID": 16, "context": "We refer the reader to [18] for details on the definition of an answer set of a logic program.", "startOffset": 23, "endOffset": 27}, {"referenceID": 18, "context": "A choice rule construct {a} [20] of the LPARSE language can be seen as an abbreviation for a rule a\u2190 not not a [9].", "startOffset": 28, "endOffset": 32}, {"referenceID": 7, "context": "A choice rule construct {a} [20] of the LPARSE language can be seen as an abbreviation for a rule a\u2190 not not a [9].", "startOffset": 111, "endOffset": 114}, {"referenceID": 8, "context": "For instance, it allows for the use of answer set solvers CLASP [10], CMODELS [12], DLV [5] as base solvers and CLP systems SICSTUS PROLOG [24] and BPROLOG [26] as theory solvers.", "startOffset": 64, "endOffset": 68}, {"referenceID": 10, "context": "For instance, it allows for the use of answer set solvers CLASP [10], CMODELS [12], DLV [5] as base solvers and CLP systems SICSTUS PROLOG [24] and BPROLOG [26] as theory solvers.", "startOffset": 78, "endOffset": 82}, {"referenceID": 3, "context": "For instance, it allows for the use of answer set solvers CLASP [10], CMODELS [12], DLV [5] as base solvers and CLP systems SICSTUS PROLOG [24] and BPROLOG [26] as theory solvers.", "startOffset": 88, "endOffset": 91}, {"referenceID": 23, "context": "For instance, it allows for the use of answer set solvers CLASP [10], CMODELS [12], DLV [5] as base solvers and CLP systems SICSTUS PROLOG [24] and BPROLOG [26] as theory solvers.", "startOffset": 156, "endOffset": 160}, {"referenceID": 4, "context": "The Davis-Putnam-Logemann-Loveland (DPLL) procedure [6] is a backtrackingbased search algorithm for deciding the satisfiability of a propositional CNF formula.", "startOffset": 52, "endOffset": 55}, {"referenceID": 0, "context": "3 [2] refers to lazy integration of EZCSP as lightweight integration of ASP and constraint programming.", "startOffset": 2, "endOffset": 5}, {"referenceID": 5, "context": "ISAT [7,8], implement interfaces for incremental SAT solving.", "startOffset": 5, "endOffset": 10}, {"referenceID": 6, "context": "ISAT [7,8], implement interfaces for incremental SAT solving.", "startOffset": 5, "endOffset": 10}, {"referenceID": 19, "context": "[21] also reviews such integration techniques used in SMT as on-line SAT solver and theory propagation.", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "12b supporting non-clausal constraints [8].", "startOffset": 39, "endOffset": 42}, {"referenceID": 15, "context": "[17] provides a complete description of the problem itself as well as the formalization that became \u201cgolden standard\u201d in this work, i.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "We refer the reader to [17] for the details of pure-ASP encoding SEQ++.", "startOffset": 23, "endOffset": 27}, {"referenceID": 1, "context": "We direct the reader to [3] for a complete description of the domain.", "startOffset": 24, "endOffset": 27}], "year": 2013, "abstractText": "Recently, researchers in answer set programming and constraint programming spent significant efforts in the development of hybrid languages and solving algorithms combining the strengths of these traditionally separate fields. These efforts resulted in a new research area: constraint answer set programming (CASP). CASP languages and systems proved to be largely successful at providing efficient solutions to problems involving hybrid reasoning tasks, such as scheduling problems with elements of planning. Yet, the development of CASP systems is difficult, requiring non-trivial expertise in multiple areas. This suggests a need for a study identifying general development principles of hybrid systems. Once these principles and their implications are well understood, the development of hybrid languages and systems may become a well-established and wellunderstood routine process. As a step in this direction, in this paper we conduct a case study aimed at evaluating various integration schemas of CASP methods.", "creator": "LaTeX with hyperref package"}}}