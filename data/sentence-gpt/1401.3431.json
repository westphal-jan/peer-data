{"id": "1401.3431", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Compositional Belief Update", "abstract": "In this paper we explore a class of belief update operators, in which the definition of the operator is compositional with respect to the sentence to be added. The goal is to provide an update operator that is intuitive, in that its definition is based on a recursive decomposition of the update sentences structure, and that may be reasonably implemented. In addressing update, we first provide a definition phrased in terms of the models of a knowledge base. While this operator satisfies a core group of the benchmark Katsuno-Mendelzon update postulates, not all of the postulates are satisfied. Other Katsuno-Mendelzon postulates can be obtained by suitably restricting the syntactic form of the sentence for update, as we show. In restricting the syntactic form of the sentence for update, we also obtain a hierarchy of update operators with Winsletts standard semantics as the most basic interesting approach captured. We subsequently give an algorithm which captures this approach; in the general case the algorithm is exponential, but with some not-unreasonable assumptions we obtain an algorithm that is linear in the size of the knowledge base. Hence the resulting approach has much better complexity characteristics than other operators in some situations. We also explore other compositional belief change operators: erasure is developed as a dual operator to update; we show that a forget operator is definable in terms of update; and we give a definition of the compositional revision operator. We obtain that compositional revision, under the most natural definition, yields the Satoh revision operator. In particular, we obtain that compositional revision, by using a set of set of predicates: that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that is, that", "histories": [["v1", "Wed, 15 Jan 2014 04:48:21 GMT  (300kb)", "http://arxiv.org/abs/1401.3431v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["james delgrande", "yi jin", "francis jeffry pelletier"], "accepted": false, "id": "1401.3431"}, "pdf": {"name": "1401.3431.pdf", "metadata": {"source": "CRF", "title": "Compositional Belief Update", "authors": ["James Delgrande", "Yi Jin", "Francis Jeffry Pelletier"], "emails": ["jim@cs.sfu.ca", "yij@cs.sfu.ca", "jeffpell@sfu.ca"], "sections": [{"heading": "1. Introduction", "text": "A knowledge base is typically not a static entity, but rather evolves over time. New information may be added, and old or out-of-date information may be removed. A fundamental issue concerns how such change should be managed. A major body of research addresses this question via the specification of rationality postulates, or standards that a change operator should satisfy. These postulates describe belief change at the knowledge level, independent of how beliefs are represented and manipulated. There are various rationales for motivating a change in an evolving knowledge base, and these differing rationales have been seen as calling for differences in the background knowledge-level postulates. For example, one may think that some alteration in the world has occurred, with the result that we should update the knowledge base\u2019s representation of the world in some appropriate way. Or, we may think that our previous sources of information were fallible or incomplete and that we now have better, more accurate information about the world. So, in this case we should revise our beliefs. Another motivation might be to merge already-existing stores of beliefs,\nc\u00a92008 AI Access Foundation. All rights reserved.\nwithout giving any a priori preference to one or the other of the belief sets, but aiming to achieve a balanced resolution of conflicts. Such a merging might be used to combine the belief states of different agents, so as to come up with a joint course of action based on some sort of \u201call things considered\u201d assimilation of the knowledge and preferences of the agents that are involved. And we can also imagine a linguistic reform, so that a concept (or rather, the associated word) was no longer to be used. In such a case one might say that the users forgot about this concept/word.\nThese differences in motivation have led to specific differences in the sorts of postulates that are associated with the different motivations. Initially, in the AGM approach (Alchourro\u0301n, Ga\u0308rdenfors, & Makinson, 1985; Ga\u0308rdenfors, 1988), standards for belief revision and contraction functions were given, wherein it was assumed that a knowledge base is receiving information concerning a static1 domain, and that it is the increased amount or accuracy of information that is responsible for the changes in the knowledge base. Subsequently, Katsuno and Mendelzon (1992) explored a distinct notion of belief change, with functions for belief update and erasure, wherein an agent changes its beliefs in response to what it perceives as changes in the environment. The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a \u201cmerged\u201d knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the \u201cdesires\u201d and \u201cgoals\u201d of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino Pe\u0301rez, 1998; Everaere, Konieczny, & Marquis, 2007).\nThe distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino Pe\u0301rez (1998) compared merging with revision; Nayak et al. (2006) compared forgetting with update. Some of the postulates suggested by the initial authors of these different conceptions of belief change have been challenged by other writers. And since our own approach towards update conflicts with some of Katsuno and Mendelzon\u2019s postulates, we wish to show that\n1. Note that \u201cstatic\u201d does not imply \u201cwith no mention of time\u201d. For example, one could have information in a knowledge base about the state of the world at different points in time, and revise information at these points in time. Thus, belief revision is also applicable to the situation where an agent investigates a past event and tries to reason about what was the real state of the world when this event took place. Further considerations on how revision and update are interrelated are in the work of Lang (2006). 2. Nayak, Chen, and Lin (2006) described this difference thus: \u201cWhile belief erasure purports to answer the question \u2018What should I believe if I can no longer support the belief that the cook killed Cock Robin?\u2019, forgetting purports to answer the question \u2018What should I believe if Killing was a concept not afforded in my language?\u2019.\u201d\nthis is not, by itself, a reason to reject our theory \u2014 every theory has met with objurgation concerning its foundational postulates.\nAlthough our focus in this paper is with update \u2014 and hence with the postulates given by Katsuno and Mendelzon (1992) and the objections related to these postulates \u2014 we believe that considerations similar to the ones we bring forward in this arena would hold with respect to the other sorts of belief change postulates. That is, we think that the rationale we have for imposing a compositionality constraint on belief update should be brought to bear on the cases of belief revision, belief merging, and forgetting.\nThe knowledge level specifications of these types of belief change allow for different ways to implement any of them. Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006). These approaches are formulated in terms of the distance between models of the knowledge base and models of a sentence for revision or update. In general there has been less work dealing with systems that may be readily implementable (but see, e.g., Williams, 1996; Delgrande & Schaub, 2003).\nIn this paper we develop a specific update operator where the operator is intended to be compositional, in that an update \u03c8 \u22c4\u00b5 can be expressed recursively in terms of the syntactic structure of \u00b5. Thus, if a knowledge base is to be updated by a disjunction \u00b5 = a \u2228 b, the idea is that this update will be a function of the update by a in a certain combination with the update by b. The update of the knowledge base by a conjunction \u00b5 = a \u2227 b will also be a function (a different one) of the update by a in combination with the update by b. The goal is to arrive at an operator whose results are intuitive, in that its definition is based on a recursive decomposition of a formula; hence the (generally abstract) notion of update will be anchored in part in a more familiar computational setting. Second, the hope is that these operators will be efficiently implementable, at least in some cases, by exploiting restrictions to the syntactic form of the formula. The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999).\nThese goals are generally realised. First, the operators have reasonable properties: many of the Katsuno and Mendelzon benchmark properties are satisfied, including those deemed essential by Herzig and Rifi (1999). While we don\u2019t obtain full irrelevance of syntax, we do obtain weaker results in this regard; as well we show how irrelevance of syntax can be obtained by restricting the syntactic form of the sentence for update. The approach is also related to other approaches in the literature, and hence serves to establish some links between approaches. In fact, the family of compositional update operators obtained by imposing various syntactic restrictions can be regarded as constituting a family of operators of which Winslett\u2019s standard semantics makes up the most basic nontrivial approach. As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget. We also define a revision operator using the obvious definition for such an operator; it proves to be the case that this operator corresponds with the revision operator in the work of Satoh (1988).\nThe approach leads to a straightforward algorithm for implementing these operators. This algorithm is efficient, compared to the model-based definition of this and other distancebased operators. For a knowledge base in disjunctive normal form, the size of the knowledge base contributes only a linear factor to the overall complexity. As well, further efficiency is obtained when the size of the input sentence is bounded by a constant.\nThe next section reviews belief revision, update, forgetting, and merging, and describes two specific approaches to update. The section following describes our approach, after which, in the next section, we give a discussion and analysis. The last section contains concluding remarks; proofs of theorems are given in an Appendix."}, {"heading": "2. Background", "text": "As described, our goal is to introduce a compositional method of carrying out belief change. But since part of our overall goal also is to examine the place of a compositional belief change operation in all the various arenas where this can take place, we start by outlining some of the details for each of these different conceptions that motivate belief change, along with some motivational considerations and some areas where the different types of belief change part ways. These operators were introduced implicitly, by means of a set of postulates that any legitimate such operator was required to obey. However, in all these areas there has been some dispute concerning the correctness of the various postulates, and we mention some of these as we proceed, since our own approach in the case of update does not obey all the standard postulates for update. We start with the historically earlier case of revision before moving to our central concern of update. These are followed by short expositions concerning forgetting and merging."}, {"heading": "2.1 Formal Preliminaries", "text": "We consider a propositional language L, over a finite set of atoms, that is, propositional letters, P = {\u22a4, a, b, c, . . . }, and truth-functional connectives \u00ac, \u2227, and \u2228. Where convenient, \u2283 and \u2261 are also used, and are considered as being introduced by definition. We use \u2194 for logical equivalence; that is, \u03b1 \u2194 \u03b2 is an abbreviation for \u22a2 (\u03b1 \u2261 \u03b2). Lits is the set of literals P \u222a {\u00acl | l \u2208 P}. In particular, \u00ac\u22a4 is also denoted as \u22a5. A set of literals \u0393 is consistent just if \u22a5 6\u2208 \u0393 and for no atom p \u2208 P do we have p,\u00acp \u2208 \u0393. For a literal l, we use l to denote \u00acl if l \u2208 P, or l\u2032 \u2208 P if \u00acl\u2032 = l. Similarly, for a set of literals \u0393, we use \u0393 to denote the set {l | l \u2208 \u0393}. The expression atom(\u00b5) denotes the set of atoms in formula \u00b5. An interpretation \u03c9 of L is a maximal consistent set of literals, i.e., \u22a4 \u2208 \u03c9 and for every other p \u2208 P precisely one of p \u2208 \u03c9, \u00acp \u2208 \u03c9 holds. A model of a sentence \u00b5 is an interpretation that makes \u00b5 true, according to the usual definition of truth. Mod(\u00b5) denotes the set of models of sentence \u00b5. We also make use of the notation ModL(\u00b5) to denote the set of models of sentence \u00b5 over the language of \u00b5 (that is to say, over the language atom(\u00b5).) For interpretation \u03c9 we write \u03c9 |= \u00b5 to mean \u00b5 is true in \u03c9. For interpretation \u03c9 and set of literals \u0393, we define \u03c9 \u2193 \u0393 = \u03c9 \\ (\u0393 \u222a \u0393). That is, \u03c9 \u2193 \u0393 is the set of literals in \u03c9 but containing neither l nor l for each l \u2208 \u0393. For example, if \u03c9 = {a,\u00acb,\u00acc} then \u03c9 \u2193 {b,\u00acc} = {a}.\nWe denote the negation-normal form (in which negation applies to atoms only) of a sentence \u00b5 by nnf (\u00b5). Similarly, we denote the conjunctive normal form and the disjunctive\nnormal form of \u00b5 by cnf (\u00b5) and dnf (\u00b5) respectively.3 For a set of sentences \u0393 (which will always be finite), we use \u2228 \u0393 to denote the disjunction and \u2227\n\u0393 the conjunction of the sentences in \u0393. Proofs will often be based on the structure of a formula, specifically on the depth of a formula; for formula \u00b5, the depth of \u00b5, depth(\u00b5) is the maximum nesting of connectives in \u00b5. Hence depth(\u00aca \u2228 (b \u2227 \u00acc)) = 3.\nLater we make use of the notion of the prime implicants of a sentence. A consistent set of literals \u0393 is a prime implicant of \u00b5 iff: \u0393 \u22a2 \u00b5 and for any \u0393\u2032 \u2282 \u0393 we have \u0393\u2032 6\u22a2 \u00b5.4 In the limiting case where \u22a2 \u00b5, we take the (sole) prime implicant of \u00b5 to be {\u22a4}."}, {"heading": "2.2 Belief Revision and Contraction", "text": "In the seminal approach of AGM (Alchourro\u0301n et al., 1985), postulates are proposed to constrain belief revision. In this approach, a knowledge base K is assumed to be a belief set, a set of sentences closed under logical consequence. The revision of a belief set by a formula, K \u2217\u03c6, is a new belief set in which the formula \u03c6 is believed. The interesting case is that in which \u00ac\u03c6 is initially believed, and so to attain a consistent belief set (assuming that \u03c6 is satisfiable), some beliefs have to be dropped. Exactly which beliefs must be dropped is not stipulated in the AGM approach; however, constraints in the form of postulates that govern what are seen as legitimate revision operators are given. In contrast, in their development of belief update Katsuno and Mendelzon (1992) represented the knowledge base by a formula in some language L. Hence, in this paper we also express things in terms of postulates phrased in terms of formulas, rather than belief sets.\nThe following R-postulates comprise Katsuno and Mendelzon\u2019s reformulation of the AGM revision postulates, where \u2217 is a function from L\u00d7 L to L.\n(R1) \u03c8 \u2217 \u00b5 \u22a2 \u00b5.\n(R2) If \u03c8 \u2227 \u00b5 is satisfiable, then \u03c8 \u2217 \u00b5\u2194 \u03c8 \u2227 \u00b5.\n(R3) If \u00b5 is satisfiable then \u03c8 \u2217 \u00b5 is also satisfiable.\n(R4) If \u03c81 \u2194 \u03c82 and \u00b51 \u2194 \u00b52 then \u03c81 \u2217 \u00b51 \u2194 \u03c82 \u2217 \u00b52.\n(R5) (\u03c8 \u2217 \u00b5) \u2227 \u03c6 \u22a2 \u03c8 \u2217 (\u00b5 \u2227 \u03c6).\n(R6) If (\u03c8 \u2217 \u00b5) \u2227 \u03c6 is satisfiable then \u03c8 \u2217 (\u00b5 \u2227 \u03c6) \u22a2 (\u03c8 \u2217 \u00b5) \u2227 \u03c6.\nA dual operation, called contraction is also defined, in which a formula is deleted from the knowledge base. This operation can be seen as governed by the C-postulates, again using a Katsuno and Mendelzon formulation in terms of a function from L\u00d7 L to L.\n3. Of course for formula \u00b5, there are many different but logically equivalent ways to express cnf (\u00b5) and dnf (\u00b5). We assume a fixed procedure for converting to cnf (or dnf), by converting to negation normal form, and then distributing disjunctions over conjunctions (or vice versa for dnf), hence justifying the use of the term the conjunctive (disjunctive) normal form of a formula, rather than a (disjunctive) normal form. 4. The notion of prime implicant should not be confused with the dual notion of a prime implicate. A prime implicate of a formula \u00b5 is a clause, or disjunction of literals, \u03c1, such that \u00b5 \u22a2 \u03c1 but for any proper subclause \u03c1\u2032 of \u03c1, we have \u00b5 6\u22a2 \u03c1\u2032.\n(C1) \u03c8 \u22a2 \u03c8 \u2212 \u00b5.\n(C2) If \u03c8 6\u22a2 \u00b5 then \u03c8 \u2212 \u00b5\u2194 \u03c8.\n(C3) If 6\u22a2 \u00b5 then \u03c8 \u2212 \u00b5 6\u22a2 \u00b5.\n(C4) If \u03c81 \u2194 \u03c82 and \u00b51 \u2194 \u00b52 then \u03c81 \u2212 \u00b51 \u2194 \u03c82 \u2212 \u00b52.\n(C5) (\u03c8 \u2212 \u00b5) \u2227 \u00b5 \u22a2 \u03c8.\nRevision and contraction are related in the AGM approach by what have come to be known as the Levi and Harper identities. They may be expressed as follows (using formulas rather than belief sets):\n\u03c8 \u2217 \u00b5 \u2194 (\u03c8 \u2212 \u00ac\u00b5) \u2227 \u00b5 (1)\n\u03c8 \u2212 \u00b5 \u2194 \u03c8 \u2228 (\u03c8 \u2217 \u00ac\u00b5). (2)\nThe first case asserts that revising \u03c8 by \u00b5 corresponds to the contraction of \u03c8 by \u00ac\u00b5 conjoined with \u00b5. The second asserts that contracting \u00b5 from \u03c8 corresponds to the disjunction of \u03c8 with the result of \u03c8 updated by \u00ac\u00b5.\nAlthough this makes a nice picture, there have been various objections to some of the presuppositions of the AGM model (e.g., the representation of belief states by theories, that is, by infinite sets of formulas) and to some of the postulates that are said to govern the operations of revision and contraction (especially (C5), the postulate of \u201crecovery\u201d). Issues involved with (C5) have been discussed by Fuhrmann, 1991; Tennant, 1997; Hansson & Rott, 1998; Rott & Pagnucco, 1999, and others."}, {"heading": "2.3 Belief Update and Erasure", "text": "The account of revision and contraction described in the preceding subsection is usually seen as applying most straightforwardly to the case where one has a store of information about \u201can unchanging, static world\u201d but where new information about that world is received by the agent, thereby forcing a change in the representation of this \u201cunchanging, static world.\u201d But a different picture was put forward by Katsuno and Mendelzon (1992), where there was a \u201cchanging, dynamic world\u201d. In such a conception, the new information that is gathered by the agent reflects the idea that the world is different than it was when the knowledge base was previously constructed. The sorts of changes to the knowledge base that are required by this type of new information are seen as different from the sorts envisaged when it is thought that changes to the knowledge base are only going to make its contents successively more accurate. Although this simplistic distinction is not all there is to the differences between the two pictures (as we mentioned in Footnote 1), it has led to a large body of work that does point to a different conception. Distinct operations that change knowledge bases have been proposed: update, which makes changes to the knowledge base given information concerning a change in the state of the world, and erasure, for removing out-of-date information.\nA formula is said to be complete just if it implies the truth or falsity of every other formula. In the approach of (Katsuno & Mendelzon, 1992), update is a function \u22c4 from L\u00d7 L to L satisfying the following U-postulates.\n(U1) \u03c8 \u22c4 \u00b5 \u22a2 \u00b5.\n(U2) If \u03c8 \u22a2 \u00b5 then (\u03c8 \u22c4 \u00b5) \u2194 \u03c8.\n(U3) If \u00b5 and \u03c8 are satisfiable then so is \u03c8 \u22c4 \u00b5.\n(U4) If \u03c81 \u2194 \u03c82 and \u00b51 \u2194 \u00b52 then (\u03c81 \u22c4 \u00b51) \u2194 (\u03c82 \u22c4 \u00b52).\n(U5) (\u03c8 \u22c4 \u00b5) \u2227 \u03c6 \u22a2 \u03c8 \u22c4 (\u00b5 \u2227 \u03c6).\n(U6) If \u03c8 \u22c4 \u00b51 \u22a2 \u00b52 and \u03c8 \u22c4 \u00b52 \u22a2 \u00b51 then (\u03c8 \u22c4 \u00b51) \u2194 (\u03c8 \u22c4 \u00b52).\n(U7) If \u03c8 is complete then (\u03c8 \u22c4 \u00b51) \u2227 (\u03c8 \u22c4 \u00b52) \u22a2 \u03c8 \u22c4 (\u00b51 \u2228 \u00b52).\n(U8) (\u03c81 \u2228 \u03c82) \u22c4 \u00b5\u2194 (\u03c81 \u22c4 \u00b5) \u2228 (\u03c82 \u22c4 \u00b5)\nThese postulates are not, however, uncontentious. Herzig and Rifi (1999) discussed the plausibility of the postulates given; they assert that U2, U5, and U6 are undesirable, while U7 is unimportant. This leaves (according to the authors) U1, U3, U4, and U8 as being desirable.\nErasure is also defined, in a manner analogous to the way we described how contraction was related to belief revision. In both cases, some specified formula is not believed in the result. The erasure of \u00b5 from \u03c8 is denoted \u03c8 \u00b5, and the formula \u00b5 is not believed in the resulting state. As with all our other operations, there is a set of postulates characterizing erasure (given in Katsuno & Mendelzon, 1992). Update and erasure are also interdefinable by means of identities, analogous to the Levi and Harper identities, which related revision and contraction:\n\u03c8 \u22c4 \u00b5 \u2194 (\u03c8 \u00ac\u00b5) \u2227 \u00b5 (3)\n\u03c8 \u00b5 \u2194 \u03c8 \u2228 (\u03c8 \u22c4 \u00ac\u00b5). (4)\nThe first case asserts that update by \u00b5 corresponds to erasing \u00ac\u00b5 along with the conjunction with \u00b5. The second asserts that erasing \u00b5 from \u03c8 corresponds to disjoining \u03c8 with the result of \u03c8 updated by \u00ac\u00b5.\nThere have been various specific update (and revision) operators proposed based on the distance between interpretations. We focus on two update operators, both due to Winslett. The first, the Possible Models Approach (PMA) of (Winslett, 1988) is a well-known example of an update operator satisfying the Katsuno and Mendelzon update postulates. The second, the standard semantics of (Winslett, 1990) is a weak (in fact, arguably the weakest reasonable) approach to update. We denote these operators by \u22c4pma and \u22c4ss respectively.\nFor \u03c8 \u22c4pma \u00b5, we have that, for each interpretation w of \u03c8, \u22c4pma selects from the interpretations of \u00b5 those that are \u201cclosest\u201d to w. The update is determined by the set of these closest interpretations. The notion of \u201ccloseness\u201d between two interpretations w1 and w2 is the Hamming distance, given as follows:\nDefinition 1 diff (w1, w2) = The set of all propositional letters on which w1 and w2 differ.\nInterpretation w1 is not less close to w than w2, w1 \u2264w w2, just if diff (w,w1) \u2286 diff (w,w2). It follows that \u2264w is a partial order on interpretations. The \u2264w-minimal set with respect to \u00b5 is designated Min(Mod(\u00b5), w). \u00bfFrom this we can specify the PMA update operator:\nMod(\u03c8 \u22c4pma \u00b5) = \u22c3\nw\u2208Mod(\u03c8)\nMin(Mod(\u00b5), w).\nThe update operator \u03c8 \u22c4ss \u00b5 is defined so that for each model of \u03c8, those models of \u00b5 that retain the truth values of atoms not in \u00b5 are chosen. That is:\nMod(\u03c8 \u22c4ss \u00b5) = \u22c3\nw1\u2208Mod(\u03c8)\n{w2 \u2208Mod(\u00b5) | diff (w1, w2) \u2286 atom(\u00b5)}\nThe operator \u03c8 \u22c4ss \u00b5 is the weakest \u201creasonable\u201d update operator in the following sense (Winslett, 1990): First, for an update \u03c8 \u22c4ss \u00b5, \u00b5 is true in every model of \u03c8 \u22c4ss \u00b5. Second, every model of \u03c8 over the language excluding atoms in \u00b5 is a model of \u03c8 \u22c4ss \u00b5 (again over this restricted language). Moreover, \u03c8 \u22c4ss \u00b5 consists of the maximal set of interpretations that satisfies the preceding two properties. Hence in the update of \u03c8 by \u00b5, the truth values of atoms in \u03c8 but not in \u00b5 are unaffected by the update.\nExample 1 (Katsuno & Mendelzon, 1992) Let L = {b,m} be the language of discourse. Let \u03c8 = (b\u2227\u00acm)\u2228 (\u00acb\u2227m), and \u00b5 = b. The interpretations of \u03c8 are w1 = (\u00acb,m), w2 = (b,\u00acm); and the interpretations of \u00b5 are: w \u2032 1 = (b,m), w \u2032 2 = (b,\u00acm). Thus diff (w1, w \u2032 1) = {b} and diff (w1, w \u2032 2) = {b,m}, hence w \u2032 1 \u2264w1 w \u2032 2 and w \u2032 2 6\u2264w1 w \u2032 1, so Min(Mod(\u00b5), w1) = {w \u2032 1}. Similarly, Min(Mod(\u00b5), w2) = {w \u2032 2}. Hence, (\u03c8 \u22c4pma \u00b5) \u2194 b. The same result obtains for \u22c4ss.\nFor concreteness, take b to mean \u201cthe book is on the floor\u201d, and m to mean \u201cthe magazine is on the floor\u201d. So \u03c8 means that either the book or the magazine is on the floor, but not both. A robot is ordered to put the book on the floor. Intuitively, at the end of this action the book will be on the floor, and the location of the magazine will be unknown. Both operators give this result.\nExample 2 Let \u03c8 = (\u00acb \u2227 \u00acm) and \u00b5 = (b \u2228m). Then (\u03c8 \u22c4pma \u00b5) \u2194 (b \u2261 \u00acm), whereas (\u03c8 \u22c4ss \u00b5) \u2194 (b \u2228m).\nHere, neither the book nor the magazine is on the floor. The robot is ordered to put at least one of them on the floor. According to the \u22c4pma operator, exactly one will be on the floor after this action, while according to the \u22c4ss operator, at least one will be on the floor."}, {"heading": "2.4 Forget", "text": "While our focus is on a specific approach to update and erasure, we also relate our approach to that of the forget operator. The notion of forgetting goes back to George Boole (1854), though it has received more recent attention in Artificial Intelligence by, e.g., Lin & Reiter, 1994; Lin, 2001; Lang et al., 2003; Nayak et al., 2006. In a propositional context, to forget an atom, or set of atoms, is to remove all information concerning the atom or set of atoms.\nIt has been suggested (in Nayak et al., 2006) that forgetting corresponds to the removal of literals or atoms from the language of discourse in the case of propositional forgetting (i.e., 0-place predicate forgetting). In the more general case, it is seen as removing a predicate or relation from the language, and hence removing any further consequences that might have been due to this predicate\u2019s presence.\nLet \u03c8[p/q] denote the formula \u03c8 where all occurrences of atom p are replaced by q. Then the usual definition for forgetting (again, going back to Boole) atom p in \u03c8 is given by \u03c8[p/\u22a4] \u2228 \u03c8[p/\u22a5]. In order to forget a set of atoms \u0393, one takes the disjunction of the substitution of all 2|\u0393| combinations of \u22a4, \u22a5 for elements of \u0393.\nWe have the following definitions. For single atoms we basically follow Nayak et al. (2006); for sets of atoms we use the definition from (Lin & Reiter, 1994). To begin, the p-dual of an interpretation \u03c9 is the interpretation like \u03c9 but where the truth value assigned to p is changed to its negation. A set of interpretations is closed under p-duals just if, for any interpretation \u03c9 in the set, the p-dual of \u03c9 is also in the set.\nDefinition 2 Given a set of interpretations \u2126 and atom p, the operator \u228e\n(\u2126, p) yields the least set of interpretations containing \u2126 and closed under p-duals.\nGiven this, we can define forget for an atom and set of atoms, where the latter is defined recursively in terms of the former:\nDefinition 3 Basis Case: Let \u03c8 be a formula and p an atom. Then forget of p with respect to \u03c8 is given by:\nMod(\u03c8 \u2299 p) = \u228e (Mod(\u03c8), p)\n= Mod(\u03c8[p/\u22a4] \u2228 \u03c8[p/\u22a5]).\nInductive Case: Let \u03c8 be a formula and \u0393 = {p1, . . . , pn} a set of atoms. Then forget of \u0393 with respect to \u03c8 is given by:\n\u03c8 \u2299 \u0393 = (\u03c8 \u2299 (\u0393 \\ {pn}))\u2299 pn.\nFor example, a \u2227 (b \u2228 c)\u2299 a\u2194 \u00aca \u2227 (b \u2228 c)\u2299 a\u2194 b \u2228 c. (Given a knowledge base that has stored that Alberta is in Canada and also that either Vancouver is in British Columbia or Charlottetown is in Ontario, forgetting that Alberta is in Canada would yield that either Vancouver is in British Columbia or Charlottetown is in Ontario. This would be the same result if the initial knowledge base had that Alberta was not in Canada, but that either Vancouver is in British Columbia or Charlottetown is in Ontario.) For another example, (a \u2228 b) \u2299 a \u2194 \u22a4. This last example illustrates that forget is distinct from erasure, since a property of erasure is that if \u03c8 does not imply \u00b5 then (\u03c8 \u00b5) \u2194 \u03c8 (Katsuno & Mendelzon, 1992)."}, {"heading": "2.5 Belief Merging", "text": "Merging differs formally from the preceding three pictures of how knowledge bases are changed. The preceding operators had a knowledge base and a sentence that may need to occasion a change in the knowledge base. If one rephrases this in terms of agents, these\nother types of change postulate an agent, with a store of beliefs, who is now faced with a new belief that needs to be accommodated. In the case of merging, however, we start with many belief sets that need all to be dealt with in some way that yields \u201cthe best, overall\u201d single belief state. In terms of agents, again, we have here a number of agents, each with a belief set, and we are trying to construct that belief set which best represents the total beliefs of the community of agents. So, rather than being a function that maps a belief set and a sentence onto a belief set, it is instead a function that maps a number of belief sets into a single one. Following our earlier practice of representing belief sets by a single formula (in the manner of Katsuno & Mendelzon, 1992), we can see that the earlier rationales for belief change envision it as a function L \u00d7 L \u2192 L, whereas merging envisions a function L\u00d7L\u00d7 . . .\u00d7L\u2192 L. Note that the general case allows for some of the knowledge bases on this list to be identical to one another, thus the list is actually a multi-set (bag).\nThe goal in merging, then, is to construct, from a finite list of knowledge bases E, some appropriate, single \u201cmerged\u201d knowledge base. Despite this formal difference from the earlier three types of belief change, we nevertheless include a discussion here because of the conceptual similarities that hold between merging and any of the other versions of belief change. Indeed, it seems plausible to suggest that merging might be definable in terms of the others, or maybe that it is some sort of generalization of the others. In these cases, our considerations about compositionality of belief change operators may be relevant.\nDefinition 4 A knowledge set is a multi-set (bag) of knowledge bases.\nDefinition 5 If E is a knowledge set, then \u2227\nE is the conjunction of the formulas representing all the knowledge bases that are in E.\nKonieczny and Pino Pe\u0301rez (1998, 2002) proposed the following M-principles to govern all merging operators. A merge function \u25b3 is a function from a knowledge set E to a knowledge base \u25b3(E) satisfying the following postulates, where \u2294 is multiset union.5\n(M1) \u25b3(E) is consistent\n(M2) If \u2227 E is consistent then \u25b3(E) = \u2227 E.\n(M3) If E1 and E2 are knowledge sets such that E1 \u2194 E2, then \u25b3(E1) \u2194 \u25b3(E2)\n(M4) If K1 and K2 are knowledge bases that are not mutually consistent, then \u25b3(K1 \u2294 K2) 6\u22a2 K1\n(M5) \u25b3(E1) \u2227\u25b3(E2) \u22a2 \u25b3(E1 \u2294 E2)\n(M6) If \u25b3(E1) \u2227\u25b3(E2) is consistent, then \u25b3(E1 \u2294 E2) \u22a2 \u25b3(E1) \u2227\u25b3(E2)\nSome of these merging postulates have been contested: For example, Meyer (2000) argued that M4 and M6 should be rejected. (He argues this on the grounds that there are many plausible merging operations that do not obey these postulates).\n5. For simplicity, we list the postulates of (Konieczny & Pino Pe\u0301rez, 1998), which do not include integrity constraints.\nA natural method for determining whether a formula \u03c6 should be in the merged knowledge base is to determine whether it appears in the majority of the members of the knowledge set that is being merged (\u201cthe merged knowledge base should allow the opinion of the majority to prevail\u201d). Liberatore and Schaerf (1998) introduced the method of arbitration, whereby the goal is to adopt as many different opinions as possible from the members of the knowledge set (\u201ctry to take as many differing opinions as possible into account\u201d). Konieczny and Pino Pe\u0301rez (1998) proved that there is no arbitration operator (at least, not of the sort that they characterize) that obeys M1 \u2013 M6.6 The interplay between various merging operations and the ability of an agent to hide, lie, or otherwise camouflage its preferences from other agents as they try to construct a merged knowledge base has been surveyed in Everaere et al. (2007)."}, {"heading": "3. The Approach", "text": "This section discusses our approach. Following intuitions and motivation of the formal approach, we introduce compositional update and, subsequently, erasure. We also consider the notion of compositional belief revision, but conclude that, at least with respect to our specific approach, there is no separate, distinct, notion of compositional revision. Analysis of properties of these operators is covered in the next section."}, {"heading": "3.1 Intuitions", "text": "Our goal is to define update operators in a compositional fashion so that, for updating by formula \u00b5, update is defined in terms of the syntactic components of \u00b5. The general idea behind update is that for \u03c8 \u22c4 \u00b5, each model of \u03c8 is replaced by the \u201cclosest\u201d model(s) in \u00b5 (Katsuno & Mendelzon, 1992). In our approach, the notion of \u201cclose\u201d for each model of \u03c8 is determined in part by the syntactic structure of \u00b5. That is, \u00b5 is recursively decomposed; the resulting (base case) literals are used to determine models of the update by sets of literals; and the results are combined depending on the connective(s) in \u00b5.\nConsider how this may be carried out. We are given a knowledge base \u03c8 and a sentence \u00b5, and we wish to determine a new knowledge base where \u00b5 is believed. For a base case, \u00b5 = l is a literal, and we wish to update the knowledge base \u03c8 by literal l. If \u03c8 implies l then we need do nothing. If \u03c8 does not imply l, then we wish to arrive at a knowledge base in which l is believed. That is, we want to change the knowledge base only enough so that it entails l. Clearly, we can do this by replacing each model \u03c9 of \u03c8 by the interpretation \u03c9\u2032 = (\u03c9 \u2193 {l}) \u222a {l}.7 Thus, we would have that every resulting interpretation entails l.\nConsider next updating a knowledge base \u03c8 by a conjunction of literals \u00b5 = l1 \u2227 l2. A knowledge base in which l1\u2227l2 is believed will, obviously, be one in which every model of the knowledge base entails both l1 and l2. We carry this out by replacing each interpretation \u03c9 \u2208 Mod(\u03c8) with an interpretation \u03c9\u2032 = (\u03c9 \u2193 {l1, l2}) \u222a {l1, l2}. There is a limiting case that needs to be taken care of, where l1 is l2. In this situation, there is no interpretation in which l1, l2 are true, and in this case \u03c9\n\u2032 does not exist, reflecting an attempt to update by an inconsistent formula.\n6. This forms a part of the rationale for Meyer (2000, 2001) to deny M4 and M6. 7. To be clear, if \u03c9 |= l then \u03c9\u2032 = \u03c9; and if \u03c9 6|= l then \u03c9\u2032 is like \u03c9 but with l replacing its complement.\nTo update a knowledge base \u03c8 by a disjunction of literals \u00b5 = l1 \u2228 l2, we want to modify models of \u03c8 so that at least one of l1 or l2 is true. Consider \u03c9 \u2208Mod(\u03c8) such that \u03c9 6|= l1 \u2228 l2. Then \u03c91 = (\u03c9 \u2193 {l1}) \u222a {l1} is an interpretation that involves the least change to \u03c9 in which l1 is true, while \u03c92 = (\u03c9 \u2193 {l2})\u222a {l2} does the same for l2. Arguably then \u03c9 should be replaced by \u03c91 and \u03c92.\nLast, we generalize the above considerations to deal with arbitrary formulas. So to update by a disjunction of formulas, we recursively determine the update given by the individual disjuncts and return the union of the resulting sets of interpretations."}, {"heading": "3.2 A Compositional Update Operator", "text": "Based on the preceding intuitions, we define an update operator \u22c4c. We begin with some preliminary definitions. In the following, UL is a function from an interpretation \u03c9 and finite set of formulas \u0393 to a set of interpretations. Informally, \u03c9 is a model of the knowledge base and \u0393 is a set of formulas resulting from the partial decomposition of a formula for update. The value of UL is the set of interpretations closest to \u03c9, according to \u0393. To ease notation, in the case of a single formula we sometimes write UL(\u03c9, \u00b5) for UL(\u03c9, {\u00b5}).\nDefinition 6 For interpretation \u03c9 and finite \u0393 \u2286 L, define UL(\u03c9,\u0393) as follows:\n1. If \u0393 \u2286 Lits then\nUL(\u03c9,\u0393) =\n{\n{(\u03c9 \u2193 \u0393) \u222a \u0393} if \u0393 6\u22a2 \u22a5 \u2205 otherwise\n2. If \u0393 = {\u03b1 \u2227 \u03b2} \u222a \u0393\u2032 then UL(\u03c9,\u0393) = UL(\u03c9, {\u03b1, \u03b2} \u222a \u0393\u2032)\n3. If \u0393 = {\u03b1 \u2228 \u03b2} \u222a \u0393\u2032 then UL(\u03c9,\u0393) = UL(\u03c9, {\u03b1} \u222a \u0393\u2032) \u222a UL(\u03c9, {\u03b2} \u222a \u0393\u2032)\n4. If \u0393 = {\u00ac(\u03b1 \u2228 \u03b2)} \u222a \u0393\u2032 then UL(\u03c9,\u0393) = UL(\u03c9, {\u00ac\u03b1,\u00ac\u03b2} \u222a \u0393\u2032)\n5. If \u0393 = {\u00ac(\u03b1 \u2227 \u03b2)} \u222a \u0393\u2032 then UL(\u03c9,\u0393) = UL(\u03c9, {\u00ac\u03b1} \u222a \u0393\u2032) \u222a UL(\u03c9, {\u00ac\u03b2} \u222a \u0393\u2032)\n6. If \u0393 = {\u00ac\u00ac\u03b1} \u222a \u0393\u2032 then UL(\u03c9,\u0393) = UL(\u03c9, {\u03b1} \u222a \u0393\u2032)\nIt is worth noting that the recursion steps of the above definition resemble closely the procedure which we use to convert a formula to its disjunctive normal form. Before defining update in terms of this operator, we first investigate some of its properties. Foremost, we need to show that UL is well-defined. That is, in specifying UL(\u03c9,\u0393), the definition is phrased in terms of some member of \u0393; it needs to be shown that the order in which elements are \u201cselected\u201d in the recursion does not affect the result.\nTheorem 1 UL is well-defined.\nThe next two results reflect the influence of the structure of a formula on the recursive decomposition in the definition of UL.\nTheorem 2 UL(\u03c9,\u0393) = UL(\u03c9,nnf ( \u2227 \u0393)).\nTheorem 3 UL(\u03c9,\u0393) = UL(\u03c9, dnf ( \u2227 \u0393)).\nNote that a similar result does not extend to conjunctive normal form. A counterexample is given by the following:\nUL(\u03c9, {a \u2228 (b \u2227 c)}) = UL(\u03c9, {a}) \u222a UL(\u03c9, {b, c})\n6= UL(\u03c9, {a}) \u222a UL(\u03c9, {a, c}) \u222a UL(\u03c9, {b, a}) \u222a UL(\u03c9, {b, c})\n= UL(\u03c9, {a, a \u2228 c}) \u222a UL(\u03c9, {b, a \u2228 c})\n= UL(\u03c9, {(a \u2228 b), (a \u2228 c)})\n= UL(\u03c9, {(a \u2228 b) \u2227 (a \u2228 c)}).\nWe consider next a couple of fundamental properties of UL:\nTheorem 4 For every \u00b5 \u2208 \u0393 and w\u2032 \u2208 UL(\u03c9,\u0393) we have w\u2032 |= \u00b5.\nTheorem 5 UL(\u03c9,\u0393) = \u2205 iff \u0393 \u22a2 \u22a5.\nWe next define our update operator directly in terms of UL.\nDefinition 7\nMod(\u03c8 \u22c4c \u00b5) = {\u03c9 \u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c8)}.\nRecall Example 1 in which \u00b5 = b and \u03c8 = (b\u2227\u00acm)\u2228 (\u00acb\u2227m). We have that Mod(\u03c8 \u22c4c \u00b5) = {\u03c9\u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b5}), \u03c9 \u2208 Mod(\u03c8)} = {(\u03c9 \u2193 {b}) \u222a {b} | \u03c9 \u2208 Mod(\u03c8)}. Thus, Mod(\u03c8 \u22c4c \u00b5) = {{b,\u00acm}, {b,m}}, and so (\u03c8 \u22c4c \u00b5) \u2194 b. This is the same result as we obtain with both Winslett\u2019s approaches.8\nFor Example 2, where \u03c8 = \u00acb \u2227 \u00acm and \u00b5 = (b \u2228 m), we obtain Mod(\u03c8 \u22c4c \u00b5) = {{b,\u00acm}, {\u00acb,m}}. In this case, our update operator behaves the same as \u22c4pma, but differently from \u22c4ss.\nWe can similarly define an erasure operator via UL. To erase \u00b5 from \u03c8, and in analogy to the Harper Identity, one can update by \u00ac\u00b5 and add the result to \u03c8. Thus:\nDefinition 8\nMod(\u03c8 c\u00b5) =Mod(\u03c8) \u222a {\u03c9 \u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00ac\u00b5}), \u03c9 \u2208Mod(\u03c8)}.\nWe get the results:\nTheorem 6\n\u03c8 \u22c4c \u00b5 \u2194 (\u03c8 c\u00ac\u00b5) \u2227 \u00b5\n\u03c8 c\u00b5 \u2194 \u03c8 \u2228 (\u03c8 \u22c4c \u00ac\u00b5).\n8. We note however that these approaches differ. Specifically, the PMA update operator satisfies all of the KM postulates, whereas our operator does not; see Section 4 for details."}, {"heading": "3.3 Erasure", "text": "In Definition 8 we defined a dual to update, called erasure, directly in terms of UL. We can equally well define a function analogous to UL, call it EL, to directly define an erasure operator from first principles. We do this now, toward such a definition of erasure. Briefly, our motivation is: if we want to erase \u00b5 as a consequence of \u03c8, then semantically we want to add interpretations to the models of \u03c8. If \u00b5 corresponds to a single literal, then for each model of \u03c8 we would want to add an interpretation in which l was replaced by l\u0304. If \u00b5 corresponds to a conjunction, then \u00b5 can be erased by erasing either of the conjuncts; if \u00b5 corresponds to a disjunction, then to erase \u00b5 both disjuncts must be erased. By continuing in this fashion we obtain the following definition:\nDefinition 9 For interpretation \u03c9 and finite \u0393 \u2286 L, define EL(\u03c9,\u0393) as follows:\n1. If \u0393 \u2286 Lits then\nEL(\u03c9,\u0393) =\n{\n{(\u03c9 \u2193 \u0393) \u222a \u0393} if \u2228\n\u0393 6\u22a2 \u22a4 \u2205 otherwise\n2. If \u0393 = {\u03b1 \u2227 \u03b2} \u222a \u0393\u2032 then EL(\u03c9,\u0393) = EL(\u03c9, {\u03b1} \u222a \u0393\u2032) \u222a EL(\u03c9, {\u03b2} \u222a \u0393\u2032)\n3. If \u0393 = {\u03b1 \u2228 \u03b2} \u222a \u0393\u2032 then EL(\u03c9,\u0393) = EL(\u03c9, {\u03b1, \u03b2} \u222a \u0393\u2032)\n4. If \u0393 = {\u00ac(\u03b1 \u2228 \u03b2)} \u222a \u0393\u2032 then EL(\u03c9,\u0393) = EL(\u03c9, {\u00ac\u03b1} \u222a \u0393\u2032) \u222a EL(\u03c9, {\u00ac\u03b2} \u222a \u0393\u2032)\n5. If \u0393 = {\u00ac(\u03b1 \u2227 \u03b2)} \u222a \u0393\u2032 then EL(\u03c9,\u0393) = EL(\u03c9, {\u00ac\u03b1,\u00ac\u03b2} \u222a \u0393\u2032)\n6. If \u0393 = {\u00ac\u00ac\u03b1} \u222a \u0393\u2032 then EL(\u03c9,\u0393) = EL(\u03c9, {\u03b1} \u222a \u0393\u2032)\nThe following results are analogous to Theorems 2 and 3; note the occurrence of cnf in Theorem 8, in contrast to dnf in Theorem 3.\nTheorem 7 EL(\u03c9,\u0393) = EL(\u03c9,nnf ( \u2227 \u0393)).\nTheorem 8 EL(\u03c9,\u0393) = EL(\u03c9, cnf ( \u2227 \u0393)).\nWe can now directly define an erasure operator \u2032c in terms of EL:\nDefinition 10 Mod(\u03c8 \u2032c \u00b5) =Mod(\u03c8) \u222a {\u03c9 \u2032 | \u03c9\u2032 \u2208 EL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c8)}\nUnsurprisingly, this notion of erasure and that given in Definition 8 are equivalent. We show this by first establishing the following result:\nLemma 1 For interpretation \u03c9 and \u0393 \u2286 L, we have EL(\u03c9,\u0393) = UL(\u03c9, {\u00ac \u2227 \u0393})\n\u00bfFrom this, it follows that our notions of erasure as given via the Harper Identity, and by direct definition via Definition 9 coincide:\nTheorem 9 \u03c8 c\u00b5\u2194 \u03c8 \u2032 c \u00b5.\nHence we just use the symbol c for erasure. As a corollary, Theorem 9 also establishes the well-definedness of \u2032c . 9\n9. That is, since UL is well-defined (Theorem 1), so is c (Definition 8) and hence so is \u2032 c by the above\nequivalence."}, {"heading": "3.4 Revision", "text": "In this section we consider extending the compositional approach to belief revision. To begin, it might be pointed out that there is nothing about the underlying motivation that makes \u22c4c an update operator, and this point suggests that \u22c4c might also be regarded as a revision operator, albeit with weak properties. However, regardless of intuitions, the recursive decomposition implicit in Definition 6 yields an operator with update-like properties, in that for sentence for update \u00b5, one effectively deals with the models of the disjuncts in dnf (\u00b5). For revision, in contrast, the intuition is that one deals with models of \u00b5 that are (in some sense) closest to those of the knowledge base \u03c8. Hence, the operator \u22c4c is not really appropriate as a revision operator.\nThis suggests a possibly-feasible approach to defining compositional revision: To define a revision \u03c8\u2217\u00b5, one first uses the operator \u22c4c to find a candidate set of models of \u00b5, and then employs some distance function to determine the subset of these models that are closest to models of \u03c8 as a whole. That is, for formulas \u03c8, \u00b5, an update of \u03c8 by \u00b5 is defined (in one fashion or another) with respect to all the models of \u03c8. For revision in contrast, a definition of the revision of \u03c8 by \u00b5 makes reference to only a subset of the models of \u03c8, those that are closest (in some sense) to the models of \u00b5. In this sense then, update is a logically weaker operator than revision. Thus a revision operator can be defined with respect to \u03c8 and \u00b5 by first applying some (compositional) update operator to get a candidate set of models of \u00b5. This set can then be \u201cfiltered\u201d, by removing those models that are not of minimal distance to the closest models of \u03c8. So depending on the notion of distance employed, one might expect to obtain different revision operators for a given compositional update operator.\nThere are two common notions of distance that are used for model-based belief change, one based on set containment and the other on cardinality. In the first case, for formulas \u03b1, \u03b2, define\n\u2206min(\u03b1, \u03b2) = min\u2286({M1\u2206M2 |M1 \u2208Mod(\u03b1),M2 \u2208Mod(\u03b2)}),\nwhere for sets A and B, A\u2206B is the symmetric difference of A and B. Satoh\u2019s (1988) revision operator \u03c8 \u2217S \u00b5 is defined as follows.\nDefinition 11\nMod(\u03c8 \u2217S \u00b5) = {w \u2032 \u2208Mod(\u00b5) | \u2203w \u2208Mod(\u03c8), w\u2206w\u2032 \u2208 \u2206min(\u03c8, \u00b5)}.\nFor example, let \u03c8 = a\u2227b\u2227c and let \u00b5 = \u00aca\u2228(\u00acb\u2227\u00acc). Then \u03c8\u2217S\u00b5 = (\u00aca\u2227b\u2227c)\u2228(a\u2227\u00acb\u2227\u00acc).\nWe can define a corresponding compositional revision operator as follows:\nDefinition 12\nMod(\u03c8 \u2217 \u00b5) = {w\u2032 | w\u2032 \u2208 UL(w, {\u00b5}), where w \u2208Mod(\u03c8), w\u2206w\u2032 \u2208 \u2206min(\u03c8, \u00b5)}.\nHowever, it turns out that this revision operator in fact coincides the Satoh revision operator:\nTheorem 10 \u03c8 \u2217 \u00b5 \u2194 \u03c8 \u2217S \u00b5.\nIt follows as a straightforward corollary that if we use a distance metric based on the number of differing propositional symbols between two interpretations, we obtain the revision operator of (Dalal, 1988).10 So in the obvious approaches to compositional revision, we do not obtain new revision operators; which is to say, the recursive decomposition in the definition of UL does not serve to select among models of \u00b5 in any interesting sense with respect to revision.\nHowever, these considerations do lead to one interesting result, and that is they point the way to algorithms that may more efficiently compute the Satoh or Dalal revision: To compute the Satoh revision for example, one can use Definition 6 to determine a relevant subset of models of \u00b5, and then use \u2206min(\u03c8, \u00b5) to determine the closest subset of these models to the set of models of \u03c8. As we discuss in Section 5, this initial filtering of models of \u00b5 may be done efficiently in certain syntactically-restricted cases."}, {"heading": "4. Analysis of Compositional Update and Erasure", "text": "To start, we consider which of the Katsuno-Mendelzon update postulates our operator satisfies. We do not consider the set of corresponding compositional erasure postulates, since the results are analogous to those of the update postulates, and so are of limited additional interest. After considering the update postulates, we further explore the update and erasure operators, including properties resulting from the restriction of the syntactic form of the formula for update, and a comparison to related approaches.\nTheorem 11 \u22c4c satisfies U1, U3, U5, U7, U8.\nFor a counterexample to U2, consider the first example given above, illustrating the approaches of Winslett, where for \u03c8 \u22c4c \u00b5 we have \u03c8 = (b \u2227 \u00acm) \u2228 (\u00acb \u2227m) and \u00b5 = b \u2228m. In our approach, for the update (as given in Definition 7) the first disjunct of \u00b5 viz., b, yields interpretations {b,\u00acm} and {b,m} and the update by the second disjunct, m, gives interpretations {b,m} and {\u00acb,m}. Hence \u03c8\u22c4c(b\u2228m) is characterized by the interpretations {b,m}, {b,\u00acm}, and {\u00acb,m} and so we get \u03c8 \u22c4c (b \u2228 m) \u2194 (b \u2228 m). U2 would dictate that the result be \u03c8; however, the above example suggests that U2 is problematic in the context of update. To borrow an example from other works (Herzig & Rifi, 1999; Brewka & Herzberg, 1993), suppose an agent believes p (that a certain coin shows heads). Now the world changes because of a toss of this coin (where the agent does not see the result). Letting \u00acp be that the coin shows tails, we note that the agent should believe (p\u2228\u00acp). Yet note that p \u22a2 (p\u2228\u00acp); so U2 would stipulate that p\u22c4(p\u2228\u00acp) should be p, contrary to what we want. The operator \u22c4c, on the other hand, includes an additional model. This appears to make sense, because by updating by b \u2228m we are really telling the knowledge base that the world has changed so that one of b \u2227m or b \u2227 \u00acm or \u00acb \u2227m is true. Thus, in this case the update operator behaves like the Gricean belief change operator of Delgrande, Nayak, and Pagnucco (2005), where the goal is to incorporate all and only the new information.\n10. That is, for fixed formulas, any model of the Dalal revision is a model of the Satoh revision. Rephrasing Definitions 11 and 12 for cardinality-based distance gives a result analogous to Theorem 10 for Dalal revision. We omit the details.\nWe note that we can modify our \u22c4c operator in a simple fashion to satisfy U2 as follows: 11\n\u03c8 \u22c4\u2032c \u00b5 =\n{\n\u03c8 if \u03c8 \u22a2 \u00b5 \u03c8 \u22c4c \u00b5 otherwise\nBut for our purposes, although U2 is indeed now satisfied, this modification sheds no light on our original goal of investigating ramifications of developing a compositional update operator, and so we do not further pursue this modification.\nWe next consider a counterexample for U4. Although ((\u00aca \u2227 b) \u2228 b) \u2194 b, nonetheless Mod(a\u22c4c((\u00aca\u2227b)\u2228b)) = {{\u00aca, b}, {a, b}} whileMod(a\u22c4cb) = {{a, b}}. SoU4 is not satisfied since in our compositional approach parts of a sentence may provide implicit results not explicit in the sentence. Consider (\u00aca\u2228b)\u2227(\u00acb\u2228c) to further illustrate this point. Updating by this sentence is effected by updating by the individual components, viz., (\u00aca \u2228 b) and (\u00acb \u2228 c). However, implicit in these parts is the fact that (\u00aca \u2228 c) is also true, and the addition of this (implied) sentence would affect the result of the update. We consider this behaviour further below.\nA counterexample for U6 is given by the following. Let\n\u03c8 = a \u2228 b\n\u00b51 = (a \u2228 \u00aca)\n\u00b52 = \u22a4\nWe have that\nMod((a \u2228 b) \u22c4c (a \u2228 \u00aca)) = Mod(\u22a4)\nBut we also have:\nMod((a \u2228 b) \u22c4c \u22a4) = Mod(a \u2228 b)\nSo we have a case where \u03c8 \u22c4c \u00b51 \u22a2 \u00b52 and also \u03c8 \u22c4c \u00b52 \u22a2 \u00b51. Thus the antecedent conditions of U6 are satisfied, but not \u03c8 \u22c4c \u00b51 \u2194 \u03c8 \u22c4c \u00b52.\nWhile \u22c4c does not satisfy U4 (substitution of logical equivalents) in general, it does satisfy some weaker conditions. First, our update obviously satisfies substitution of logical equivalents in the first argument of \u22c4c. As well, in light of Theorems 2 and 3, if \u00b51 and \u00b52 share the same negation normal form or disjunctive normal form, then they may be substituted one for the other as a formula for update. We summarize these results as follows:\nObservation 1\n1. If \u03c81 \u2194 \u03c82 then (\u03c81 \u22c4c \u00b5) \u2194 (\u03c82 \u22c4c \u00b5).\n2. If nnf (\u00b51) = nnf (\u00b52) then (\u03c8 \u22c4c \u00b51) \u2194 (\u03c8 \u22c4c \u00b52).\n3. If dnf (\u00b51) = dnf (\u00b52) then (\u03c8 \u22c4c \u00b51) \u2194 (\u03c8 \u22c4c \u00b52).\n11. Borgida (1985) employed a similar definition with respect to a revision operator.\nDespite failing to satisfy some postulates (which, it can be noted, overlap with the postulates that Herzig & Rifi, 1999, think are undesirable), \u22c4c does exhibit a nice property, reflecting the compositional nature of our operator, but which operators appearing in the literature and satisfying the Katsuno and Mendelzon postulates fail to satisfy. The following version of the disjunction property holds.\nTheorem 12 \u03c8 \u22c4c (\u00b51 \u2228 \u00b52) \u2194 (\u03c8 \u22c4c \u00b51) \u2228 (\u03c8 \u22c4c \u00b52)\nCorollary 1 (\u03c8 \u22c4c \u00b51) \u2227 (\u03c8 \u22c4c \u00b52) implies \u03c8 \u22c4c (\u00b51 \u2228 \u00b52).\nThe corollary can be observed to be a strengthening of U7. Our update operator satisfies those postulates deemed desirable by Herzig and Rifi (1999), with the exception of U4. As discussed above, U4 is not satisfied due to the interaction of parts of a sentence. It would seem that if we could \u201ccompile out\u201d the implicit information in a sentence then we would obtain the full substitution of equivalents, as expressed in U4. So, one way to satisfy U4 is to redefine \u22c4c so that we first get this information implicit in the interaction of the compositionally distinct parts of the update sentence. We do this by defining operators that consider the set of prime implicants of a sentence. We call this modified operator \u22c4pic . Let PI(\u00b5) be the set of prime implicants of \u00b5.\nDefinition 13 \u03c8 \u22c4pic \u00b5 = \u03c8 \u22c4c \u2228 PI(\u00b5)\nTheorem 13 \u22c4pic satisfies U4\nAlthough \u22c4pic satisfies U4, we now lose U7. A counter-example for U7 is given by\n\u03c8 = a \u2227 b \u2227 c \u2227 d\n\u00b51 = (a \u2227 d) \u2228 (\u00acc \u2227 d)\n\u00b52 = (\u00aca \u2227 d) \u2228 (\u00acc \u2227 d).\nWe have that\nMod(\u03c8 \u22c4pic \u00b51) = {{a, b, c, d}, {a, b,\u00acc, d}} and Mod(\u03c8 \u22c4pic \u00b52) = {{\u00aca, b, c, d}, {a, b,\u00acc, d}}\nHence Mod(\u03c8 \u22c4pic \u00b51) \u2229Mod(\u03c8 \u22c4 pi c \u00b52) = {{a, b,\u00acc, d}}. On the other hand\nMod(\u03c8 \u22c4pic (\u00b51 \u2228 \u00b52)) = Mod(\u03c8 \u22c4 pi c ((a \u2227 d) \u2228 (\u00acc \u2227 d) \u2228 (\u00aca \u2227 d) \u2228 (\u00acc \u2227 d)))\n= Mod(\u03c8 \u22c4pic d) = {{a, b, c, d}}.\nConversion to prime implicants in effect removes irrelevant or redundant syntactic information, as illustrated in the preceding example where \u00b51 \u2228 \u00b52 was in fact equivalent to the atom d. We can further pursue this line of inquiry by considering, for a formula for update \u00b5, a syntactic representation of the proposition expressed by \u00b5 over the language of \u00b5. For a given formula \u00b5, recall that ModL(\u00b5) is the set of models of \u00b5, over the language of \u00b5. The formula \u2228\u2227\nModL(\u00b5) then would be this formula expressed in disjunctive normal form; for example ModL((a \u2228 b) \u2227 c) would be expressed as (a \u2227 b \u2227 c) \u2228 (a \u2227 \u00acb \u2227 c) \u2228 (\u00aca \u2227 b \u2227 c).\nWe define an update operator as follows:\nDefinition 14 Mod(\u03c8 \u22c4ssc \u00b5) =Mod(\u03c8 \u22c4c ( \u2228\u2227 ModL(\u00b5))).\nWe obtain that this update operator is in fact the same as that of Winslett\u2019s standard semantics:\nTheorem 14 \u03c8 \u22c4ssc \u00b5\u2194 \u03c8 \u22c4ss \u00b5.\nWe can pursue this direction one step further, and define an update operator where the update formula \u00b5 is characterized by its models expressed in dnf. That is we can define:\nMod(\u03c8 \u22c4trivc \u00b5) =Mod(\u03c8 \u22c4c ( \u2228\u2227 Mod(\u00b5))).\nThis is the same as Definition 14, except over models of \u00b5, rather than models of \u00b5 in the language of \u00b5. However it is easily shown that this is not an interesting operator, since it removes all old information and we have:\nObservation 2 (\u03c8 \u22c4trivc \u00b5) \u2194 \u00b5.\nWe next proceed in a slightly different direction and compare our update operator with the forget operator. Recall that forgetting a set of atoms from a formula \u03c8 basically removes all information having to do with this set of atoms; in a sense forgetting is analogous to decreasing the language by this set of atoms.\nTo begin with, it can be noted that our update operator can have contraction-like properties similar to forget. For example, (a\u2227b)\u22c4c (a\u2228\u00aca) is readily shown to be equivalent to b. So again, in a sense, this update can be read as updating by precisely a \u2228 \u00aca, which in this case would indicate tautologous information concerning a. In fact, we have the following result (recall that we use \u2299 to denote forget):\nTheorem 15 Let \u03c8 \u2208 L and let \u0393 \u2286 P. Then\n\u03c8 \u2299 \u0393 = \u03c8 \u22c4c\n\n\n\u2227\np\u2208\u0393\n(p \u2228 \u00acp).\n\n\nHence forgetting a set of atoms is a special case of our update operator. (Given Theorem 6, forget is of course also expressible via erasure in an analogous fashion.) Last, we establish a result between the forget operator and Winslett\u2019s standard semantics. While in hindsight obvious, this result does not appear to have been previously noted.\nTheorem 16 For formula \u03c8 and \u0393 \u2286 P, let \u00b5 = \u2227\nl\u2208\u0393(l \u2228 \u00acl). Then\n\u03c8 \u2299 \u0393 = \u03c8 \u22c4ssc \u00b5.\nIn summary, it can be observed from the above discussion that we have obtained a hierarchy of operators, based on the extent to which information in \u00b5 is made explicit. For the most basic case, we have \u03c8 \u22c4trivc \u00b5, where the update formula \u00b5 is a syntactic representation of all models of the language; a trivial update operator results. The most basic interesting operator is given by \u03c8 \u22c4ssc \u00b5, which is the same as Winslett\u2019s standard semantics, followed by \u03c8 \u22c4pic \u00b5 and \u03c8 \u22c4c \u00b5. As well, by introducing tautologies, we also capture the notion of forgetting of atoms.\nWe have already noted that our update operator \u22c4c is distinct from the Winslett PMA approach. To the best of our knowledge it is also distinct from all other specific approaches appearing in the literature, including those surveyed in (Herzig & Rifi, 1999)."}, {"heading": "5. Algorithms and Complexity", "text": "In this section we present a syntactic characterization as well as an algorithm for computing compositional update. We also analyze the complexity of this algorithm under a variety of assumptions. Specifically, we analyze the complexity of the algorithm when applied to any propositional sentences in general, to any sentences in disjunctive normal form, and to any sentences whose sizes are bounded by some specified constant.\nWe start with some background notions. Recall that \u03c8[p/q] denotes the formula \u03c8 where all occurrences of atom p are replaced by q. We write \u2203 p.\u03c8 to denote the formula \u03c8[p/\u22a4] \u2228 \u03c8[p/\u22a5]. If P = {p1, \u00b7 \u00b7 \u00b7 , pn} is a set of atoms then \u2203P.\u03c8, called an eliminant of P in \u03c8, stands for \u2203 p1.(\u00b7 \u00b7 \u00b7 \u2203 (pn.\u03c8)) (Brown, 1990). Intuitively, an eliminant of P in \u03c8 can be viewed as a formula representing the same knowledge of \u03c8 that is not concerned with atoms in P . We have eliminated information about members of P by replacing them by their two possible values, \u22a4 and \u22a5, thus leaving only the other information in \u03c8.\nIt has been shown that Winslett\u2019s standard semantics can be syntactically captured based on the notion of eliminant (Doherty, Lukaszewicz, & Madalin\u0301ska-Bugaj, 1998). Let P = atom(\u00b5), then\n\u03c8 \u22c4ss \u00b5\u2194 (\u2203P.\u03c8) \u2227 \u00b5 (5)"}, {"heading": "5.1 Syntactic Characterization and Algorithms", "text": "We are now ready to provide a syntactical characterization of compositional update. The idea is quite similar to that of (Doherty et al., 1998). However, our approach first converts the update formula to disjunctive normal form, then deals with each disjunct.\nUpdate(\u03c8, \u00b5) = \u2228 {(\u2203P.\u03c8) \u2227 t | t \u2208 dnf (\u00b5), P = atom(t)}\nThe following results establish the correspondence between the semantical definition and syntactic characterizations of compositional update.\nLemma 2 Suppose t is a term (a conjunction of literals) and P = atom(t). Then\nMod((\u2203P.\u03c8) \u2227 t) = {w\u2032 | w\u2032 \u2208 UL(w, t), w \u2208Mod(\u03c8)}\nTheorem 17 Mod(\u03c8 \u22c4c \u00b5) =Mod(Update(\u03c8, \u00b5)).\nCorollary 2 \u03c8 \u22c4c \u00b5\u2194 Update(\u03c8, \u00b5)\nAll we need to compute compositional update, therefore, is the ability to compute eliminants. As proposed by Brown (1990), an eliminant \u2203P.\u03c8 can be constructed as follows.\n1. Convert \u03c8 to dnf t1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 tn (each ti is a conjunction of literals)\n2. Replace each ti by ti \u2193 P .\nNow we are ready to provide the algorithms for compositional update. We will assume that dnf (\u00b5) refers to the disjunctive normal form of \u00b5 represented in clause form, in which a formula is represented by sets of sets of literals. In this case, the members of dnf (\u00b5) are implicitly disjoined, while a set of literals making up a member of dnf (\u00b5) is implicitly conjoined.\nIn the following algorithms, let \u03c8, \u00b5 \u2208 L and P be a set of atoms:\nAlgorithm Eliminant(P,\u03c8) 1. \u03c8\u2032 \u2190 \u22a5 2. for each term t \u2208 dnf (\u03c8) 3. t\u2032 \u2190 \u22a4 4. for each literal l \u2208 t 5. if l /\u2208 P and l /\u2208 P 6. t\u2032 \u2190 t\u2032 \u2227 l 7. \u03c8\u2032 \u2190 \u03c8\u2032 \u2228 t\u2032 8. return \u03c8\u2032\nAlgorithm Update(\u03c8, \u00b5) 1. \u03c8\u2032 \u2190 \u22a5 2. for each term t \u2208 dnf (\u00b5) 3. P = atom(t) 4. \u03c8\u2032 \u2190 \u03c8\u2032 \u2228 (Eliminant(P,\u03c8) \u2227 t) 5. return \u03c8\u2032\nLet\u2019s consider again Example 1 in which \u00b5 = b and \u03c8 = (b \u2227 \u00acm) \u2228 (\u00acb \u2227 m). We have that Update(\u03c8, \u00b5) = \u22a5 \u2228 (Eliminant({b}, \u03c8) \u2227 b). Since Eliminant({b}, \u03c8) = \u22a5 \u2228 (\u22a4 \u2227 \u00acm) \u2228 (\u22a4 \u2227 m), which is equivalent to \u22a4, we obtain that Update(\u03c8, \u00b5) \u2194 b. Thus, Update(\u03c8, \u00b5) \u2194 \u03c8 \u22c4c \u00b5, as we have already shown that \u03c8 \u22c4c \u00b5\u2194 b.\nFor Example 2, where \u03c8 = \u00acb \u2227 \u00acm and \u00b5 = (b \u2228 m), we obtain Update(\u03c8, \u00b5) = (b \u2227 \u00acm) \u2228 (\u00acb \u2227m). Again, this result is same as what we obtain with \u22c4c."}, {"heading": "5.2 Complexity", "text": "In the sequel, we analyze the space complexity of the update algorithm; that is, we are interested in how large the updated knowledge base could be. Unfortunately, when applied to arbitrary formulas, the algorithm Update may cause exponential space blowup, as the disjunctive normal form of a formula could be exponentially large.\nTheorem 18 The space complexity of Update(\u03c8, \u00b5) is O(2(|\u03c8|+|\u00b5|)) for \u03c8, \u00b5 \u2208 L;\nHowever, we are able to show that such exponential space blowup is inevitable for any algorithm of compositional update. To this end, we need to introduce so-called advice-taking Turing machine (TM) and non-uniform complexity class, see (Johnson, 1990).\nAn advice-taking TM is a TM with an advice oracle, which can be considered as a function a from positive integers to strings. On input x, the machine loads string a(|x|) and then continues as usual based on two inputs x and a(|x|). Note that the oracle string a(|x|) only depends on the size of the input x. We call an advice oracle a polynomial iff |a(n)| < p(n) for some fixed polynomial p and all positive integers n. If X is a usual complexity class defined in terms of resource-bounded machines (e.g., P or NP) then X/poly is the class of the problem that can be decided on machines with the same resource bound augmented by polynomial advice oracles. Any class X/poly is also known as the non-uniform X; in particular, P/poly appears to be much more powerful than P. However, it has been shown very unlikely that NP \u2286 P/poly, otherwise the polynomial hierarchy would collapse\nat \u03a3p2 (Karp & Lipton, 1980). This result is used to show that it is unlikely that there exists an algorithm for compositional update with a polynomial space bound.\nTheorem 19 Assume there exist a polynomial p and an algorithm Update of compositional update such that Update(\u03c8, \u00b5) \u2194 \u03c8 \u22c4c \u00b5 and |Update(\u03c8, \u00b5)| \u2264 p(|\u03c8| + |\u00b5|), for any belief base \u03c8 and formula \u00b5. Then NP \u2286 P/poly.\nWe can pursue the above result one step further, and show that algorithms for any sensible update operators will cause exponential blowup. Formally, we say an update operator \u22c4 is sensible iff for any consistent set of literals \u0393:\nMod(\u03c8 \u22c4 \u2227 \u0393) = {\u03c9\u2032 | \u03c9\u2032 \u2208 (w \u2193 \u0393) \u222a \u0393, \u03c9 \u2208Mod(\u03c8)}\nArguably, the above condition is very intuitive and natural (cf. discussions in Section 3). In fact, almost all update operators in the literature are sensible.\nTheorem 20 If there exists a polynomially space bounded algorithm for any sensible update operator, then NP \u2286 P/poly.\nWe remark that the above result also proves Winslett\u2019s conjecture stating that there does not exist a polynomially space bounded algorithm for her standard semantics (see Winslett, 1990).\nThe algorithm becomes tractably better when applied to formulas in disjunctive normal form, and to update formulas whose sizes are bounded.\nTheorem 21 The space complexity of Update(\u03c8, \u00b5) is:\n1. O(|\u03c8| \u00d7 |\u00b5|) for \u03c8, \u00b5 in dnf; and\n2. O(|\u03c8|) for \u03c8 in dnf and |\u00b5| < k for some constant k.\nArguably, in practice, the update formula \u00b5 (representing the changes of the world) will be relatively small. Therefore, it is relatively easy to convert \u00b5 to dnf, and it is also reasonable to assume the size of \u00b5 is bounded. As we usually do not restrict the size of the belief base \u03c8, converting \u03c8 to dnf could be computationally much more expensive. Fortunately, we only need to compile (off-line) the original belief base once into dnf, and the output of Update algorithm is automatically the dnf of the updated belief base. This will considerably facilitate the further update of the belief base."}, {"heading": "6. Conclusion", "text": "We have presented belief change operators for updating a knowledge base where the definition of these operators is compositional with respect to the sentence to be added. The intent is to provide operators with transparent definitions, based on the structure of the formula for belief change. As a result we lose some of the standard postulates for update, although we do satisfy a core group of the standard postulate set. We achieve full irrelevance of syntax if the sentence for update is replaced by the disjunction of its prime implicants.\nThe approach is interesting because first, it is founded on differing intuitions than other operators, in that it is based on a decomposition of the formula rather than on the models of the formula, and second, it allows a straightforward and (under reasonable assumptions) efficient implementation. While distinct from previous update operators that have appeared in the literature, we can capture Winslett\u2019s standard semantics approach to update in a restriction of our approach. In fact, the update operator, under different syntactic restrictions, may be regarded as constituting a family of update operators of which Winslett\u2019s standard semantics is the weakest interesting approach. When we turn from update to revision, we discover there is no new, interesting compositional revision operator; nevertheless, our results indicate that by first computing the compositional update, one can implement the Satoh or Dalal revision operator more efficiently, because we consider only a subset of the models of the formula of revision, and in certain cases this will have a significant speedup over a naive algorithm.\nAn open question concerns combining this approach with one that is designed to exploit the structure of the knowledge base (such as discussed in Parikh, 1999 and characterized in terms of PMA updates in Peppas, Chopra, & Foo, 2004). A second, technical question that is not fully explored concerns the behaviour of \u22c4c as an erasure operator. For example, let \u03c8 = (a \u2228 b) \u2227 (\u00aca \u2228 \u00acb). Then, we get that \u03c8 \u22c4c (a \u2228 b) \u2194 a \u2228 b. So, in updating the knowledge base with a formula already implied by the knowledge base, we have actually removed information. This, as discussed earlier, is quite reasonable if one considers that an update (in contrast to a revision) by a \u2228 b asserts that the world has changed so that one of {a, b}, {\u00aca, b}, {a,\u00acb} is now true. Finally, it would be of interest to apply the compositional approach to the merging of knowledge bases."}, {"heading": "Acknowledgments", "text": "An early precursor of this paper was presented at FLAIRS 2007 (Delgrande, Pelletier, & Suderman, 2007). We are grateful to that audience for comments; and we have also benefited from the perceptive comments of three JAIR referees. Delgrande and Pelletier also acknowledge the support of the Canadian NSERC granting agency."}, {"heading": "Appendix A. Proof of Theorems", "text": "Proof 1.\nObserve that UL is associative and commutative with respect to top-level conjunctions and top-level disjunctions. That is, for example\nUL(\u03c9, {\u03b1 \u2227 (\u03b2 \u2227 \u03b3)} \u222a \u0393\u2032) = UL(\u03c9, {(\u03b1 \u2227 \u03b2) \u2227 \u03b3} \u222a \u0393\u2032).\nA similar observation can be made about negations of such top-level conjunctions and disjunctions; for example we have\nUL(\u03c9, {\u00ac(\u03b1 \u2227 (\u03b2 \u2227 \u03b3))} \u222a \u0393\u2032) = UL(\u03c9, {\u00ac((\u03b1 \u2227 \u03b2) \u2227 \u03b3)} \u222a \u0393\u2032).\nWe use such basic facts without comment in the sequel.\nThe above means in particular that for showing the order-independence of UL with respect to its second argument, we just need consider the general case of UL(\u03c9,\u0393) where \u0393 = {\u00b51} \u222a {\u00b52}, since we have that UL(\u03c9, {\u03b11, . . . , \u03b1n}) = UL(\u03c9, {\u03b11, \u2227n i=2 \u03b1i}).\nGiven this preamble, what we need to show is that for formulas \u00b51 and \u00b52, that UL(\u03c9, {\u00b51} \u222a {\u00b52}) is independent of whether the initial recursion is in terms of \u00b51 or \u00b52.\nThe proof is on the depth of a formula.\nBASE:\nAssume that depth(\u00b51) \u2264 1 and depth(\u00b52) \u2264 1:\n1. If depth(\u00b51) = depth(\u00b52) = 0 then \u00b51, \u00b52 are atoms and the result follows trivially.\n2. If the only connective for \u00b51, \u00b52 is negation then \u00b51, \u00b52 are literals and again the result follows trivially.\n3. If the connectives for \u00b51, \u00b52 are from {\u00ac,\u2227}, then \u00b51, \u00b52 reduce to sets of literals, and the previous case applies.\n4. \u00b51 is a1 \u2228 a2, and \u00b51 is a literal, then only Step 3 of the definition applies, and our result obtains easily. The converse where \u00b52 is a1 \u2228 a2, and \u00b52 is a literal of course yields the same result.\n5. If \u00b51 is a1 \u2227 a2 and \u00b52 is b1 \u2228 b2, then we have\nUL(\u03c9, {a1 \u2227 a2} \u222a {\u00b52}) = UL(\u03c9, {a1, a2} \u222a {\u00b52})\n= UL(\u03c9, {a1, a2} \u222a {b1 \u2228 b2})\n= UL(\u03c9, {b1 \u2228 b2} \u222a {a1, a2})\n= UL(\u03c9, {b1} \u222a {a1, a2}) \u222a UL(\u03c9, {b2} \u222a {a1, a2})\n= UL(\u03c9, {b1} \u222a {a1 \u2227 a2}) \u222a UL(\u03c9, {b2} \u222a {a1 \u2227 a2})\n= UL(\u03c9, {b1 \u2228 b2} \u222a {a1 \u2227 a2})\n= UL(\u03c9, {b1 \u2228 b2} \u222a {\u00b51})\n6. If \u00b51 is a1 \u2228 a2 and \u00b52 is b1 \u2228 b2, then we have\nUL(\u03c9, {a1 \u2228 a2} \u222a {\u00b52}) = UL(\u03c9, {a1} \u222a {\u00b52}) \u222a UL(\u03c9, {a2} \u222a {\u00b52})\n= UL(\u03c9, {a1} \u222a {b1 \u2228 b2}) \u222a UL(\u03c9, {a2} \u222a {b1 \u2228 b2})\n= UL(\u03c9, {b1 \u2228 b2} \u222a {a1}) \u222a UL(\u03c9, {b1 \u2228 b2} \u222a {a2})\n= (UL(\u03c9, {b1} \u222a {a1}) \u222a UL(\u03c9, {b2} \u222a {a1})) \u222a\n(UL(\u03c9, {b1} \u222a {a2}) \u222a UL(\u03c9, {b2} \u222a {a2}))\n= UL(\u03c9, {b1, a1}) \u222a UL(\u03c9, {b2, a1}) \u222a\nUL(\u03c9, {b1, a2}) \u222a UL(\u03c9, {b2, a2})\nAnalogous manipulations show that UL(\u03c9, {b1 \u2228 b2} \u222a {\u00b51}) yields the same result.\nSTEP: For the induction hypothesis, assume that our result holds for depth(\u00b51) \u2264 n and depth(\u00b52) \u2264 n. We show that the desired result obtains for depth(\u00b51) \u2264 (n + 1) and depth(\u00b52) \u2264 (n+ 1). A: Consider first where depth(\u00b51) \u2264 n and depth(\u00b52) = n+ 1.\n1. \u00b52 is of the form \u00ac\u00ac\u03b1:\nUL(\u03c9, {\u00b51} \u222a {\u00b52}) is the same as UL(\u03c9, {\u00b51} \u222a {\u03b1}), and our result follows by the induction hypothesis.\n2. \u00b52 is \u03b1 \u2227 \u03b2:\nUL(\u03c9, {\u00b51} \u222a {\u00b52}) = UL(\u03c9, {\u00b51} \u222a {\u03b1 \u2227 \u03b2}) = UL(\u03c9, {\u00b51, \u03b1, \u03b2}) = UL(\u03c9, {\u03b1 \u2227 \u03b2} \u222a {\u00b51}).\n3. \u00b52 is \u03b1 \u2228 \u03b2:\nUL(\u03c9, {\u00b51} \u222a {\u00b52}) = UL(\u03c9, {\u00b51} \u222a {\u03b1 \u2228 \u03b2}) = UL(\u03c9, {\u00b51, \u03b1}) \u222a UL(\u03c9, {\u00b51, \u03b2}) while UL(\u03c9, {\u00b52} \u222a {\u00b51}) = UL(\u03c9, {\u03b1 \u2228 \u03b2} \u222a {\u00b51}) = UL(\u03c9, {\u00b51, \u03b1}) \u222a UL(\u03c9, {\u00b51, \u03b2}).\n4. \u00b52 is \u00ac(\u03b1 \u2227 \u03b2) or \u00b52 is \u00ac(\u03b1 \u2228 \u03b2):\nThis is handled the same as \u03b1 \u2228 \u03b2 or \u03b1 \u2227 \u03b2 respectively.\nB: Consider next where depth(\u00b51) = n+ 1 and depth(\u00b52) = n+ 1.\n1. \u00b51 or \u00b52 is \u00ac\u00ac\u03b1:\nThis is the same as \u00b51 or \u00b52 being \u03b1, from which our result holds via the induction hypothesis.\n2. \u00b51 or \u00b52 is \u03b11 \u2227 \u03b21:\nAssume without loss of generality that \u00b51 is \u03b11 \u2227 \u03b21.\n(a) \u00b52 is \u03b12 \u2227 \u03b22:\nUL(\u03c9, {\u00b51} \u222a {\u00b52}) = UL(\u03c9, {\u03b11 \u2227 \u03b21} \u222a {\u03b12 \u2227 \u03b22}) = UL(\u03c9, {\u03b11, \u03b21, \u03b12, \u03b22}) = UL(\u03c9, {\u00b52} \u222a {\u00b51}).\n(b) \u00b52 is \u03b12 \u2228 \u03b22:\nThis case is handled the same as in the base case, where \u03b11, \u03b21, \u03b12, \u03b22 are atoms.\n(c) \u00b52 is \u00ac(\u03b12 \u2227 \u03b22) or \u00b52 is \u00ac(\u03b12 \u2228 \u03b22):\nThis is handled the same as \u03b12 \u2228 \u03b22 or \u03b12 \u2227 \u03b22 respectively.\n3. \u00b51 or \u00b52 is \u03b1 \u2228 \u03b2:\nThe proof here is the same as in the base case, where \u03b1, \u03b2 are atoms.\n4. \u00b51 (\u00b52) is \u00ac(\u03b1 \u2227 \u03b2) or \u00b51 (\u00b52) is \u00ac(\u03b1 \u2228 \u03b2):\nThis is handled the same as \u03b1 \u2228 \u03b2 or \u03b1 \u2227 \u03b2 respectively.\nSince this covers all cases, our result follows by induction.\nProof 2.\nThe proof follows straightforwardly from the observations that for arbitrary \u03c9, \u0393, we have:\nUL(\u03c9, {\u00ac\u00ac\u03b1} \u222a \u0393) = UL(\u03c9, {\u03b1} \u222a \u0393)\nUL(\u03c9, {\u00ac(\u03b1 \u2227 \u03b2)} \u222a \u0393) = UL(\u03c9, {\u00ac\u03b1 \u2228 \u00ac\u03b2} \u222a \u0393)\nUL(\u03c9, {\u00ac(\u03b1 \u2228 \u03b2)} \u222a \u0393) = UL(\u03c9, {\u00ac\u03b1 \u2227 \u00ac\u03b2} \u222a \u0393)\nAn induction argument establishes that the value of UL doesn\u2019t change under conversion of elements of its second argument to negation normal form.\nProof 3.\nThis result follows from the preceding, plus the fact that for arbitrary \u03c9, \u0393 we have that: UL(\u03c9, {\u03b1 \u2227 (\u03b2 \u2228 \u03b3)} \u222a \u0393) = UL(\u03c9, {(\u03b1 \u2227 \u03b2) \u2228 (\u03b1 \u2227 \u03b3)} \u222a \u0393); that is, UL is invariant under distribution of conjunction over disjunction.\nProof 4.\nProof is by induction on the maximum depth of a formula in \u0393.\nIf the maximum depth is 0, then all members of \u0393 are literals, and the result is immediate from Definition 6. Otherwise the induction hypothesis is that the result holds where the maximum depth of a formula in \u0393 is n, and the step is easily shown by appeal to truth conditions in classical propositional logic.\nProof 5. Right-to-left: This is a corollary of Theorem 4.\nLeft-to-right:\nFor arbitrary \u0393 we have by Theorem 3 that UL(\u03c9,\u0393) = UL(\u03c9, dnf (\u0393)). Let dnf (\u0393) = \u03b31 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03b3n where each \u03b3i is a conjunction of literals. Via Definition 6 we have that UL(\u03c9, dnf (\u0393)) = UL(\u03c9, {\u03b31}) \u222a \u00b7 \u00b7 \u00b7 \u222a UL(\u03c9, {\u03b3n}). For each \u03b3i, if \u03b3i contains a complementary pair of literals then UL(\u03c9, {\u03b3i}) = \u2205; otherwise UL(\u03c9, {\u03b3i}) 6= \u2205.\nIf we assume that \u0393 6\u22a2 \u22a5, then there is some \u03b3i with no complementary literals, consequently UL(\u03c9, {\u03b3i}) 6= \u2205 and so \u2205 6= UL(\u03c9, dnf (\u0393)) = UL(\u03c9,\u0393).\nThus \u0393 6\u22a2 \u22a5 implies UL(\u03c9,\u0393) 6|= \u22a5, which was to be shown.\nLemma 3 \u03c8 \u2227 \u00b5 \u22a2 \u03c8 \u22c4c \u00b5.\nProof of Lemma 3. If \u03c8 \u2227 \u00b5 \u22a2 \u22a5 then the result is immediate.\nConsequently assume that \u03c8 \u2227 \u00b5 is satisfiable, and let \u03c9 \u2208 Mod(\u03c8 \u2227 \u00b5). We show that \u03c9 \u2208Mod(\u03c8 \u22c4c \u00b5). Given Definition 7, and since we already have \u03c9 \u2208Mod(\u03c8), we just need to show that \u03c9 \u2208 UL(\u03c9, {\u00b5}).\nWe have by assumption that \u03c9 \u2208 Mod(\u00b5), whence (Theorem 3) \u03c9 \u2208 Mod(dnf (\u00b5)). Since Mod(dnf (\u00b5)) = Mod(dnf (\u00b51)) \u222a \u00b7 \u00b7 \u00b7 \u222aMod(dnf (\u00b5n)) for dnf (\u00b5) = \u00b51 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00b5n we get \u03c9 \u2208Mod(dnf (\u00b5i)) for some disjunct \u00b5i of dnf (\u00b5).\nSince \u03c9 \u2208Mod(dnf (\u00b5i)) it follows from the definition of UL that \u03c9 = UL(\u03c9, {\u00b5i}); hence \u03c9 \u2208Mod(dnf (\u00b5)) and so \u03c9 \u2208 UL(\u03c9, {\u00b5}), which was to be shown.\nProof 6. The second part of the theorem follows immediately from Definitions 7 and 8.\nFor the first part: Since \u03c8 \u2227 \u00b5 \u22a2 \u03c8 \u22c4c \u00b5 (Lemma 3), we have\n\u03c8 \u22c4c \u00b5 \u2194 (\u03c8 \u2227 \u00b5) \u2228 (\u03c8 \u22c4c \u00b5)\n\u2194 (\u03c8 \u2227 \u00b5) \u2228 ((\u03c8 \u22c4c \u00b5) \u2227 \u00b5)\n\u2194 (\u03c8 \u2228 (\u03c8 \u22c4c \u00b5)) \u2227 \u00b5\n\u2194 (\u03c8 c\u00ac\u00b5) \u2227 \u00b5\nThe last step applies the other part of the theorem, established above.\nProof 7.\nThe proof is the same as that for Theorem 2 with minor modifications.\nProof 8.\nThe proof is analogous to that of Theorem 3, and is omitted.\nProof of Lemma 1.\nThe proof is straightforward, except setting up the induction is a bit fiddly. The induction is based on the maximum depth of a formula in \u0393. For \u0393 \u2286 L, let depth(\u0393) = max\u00b5\u2208\u0393 depth(\u00b5). We then stipulate that \u0393 precedes \u0393\n\u2032 in the ordering for the induction if depth(\u0393) < depth(\u0393\u2032), or if depth(\u0393) = depth(\u0393\u2032) = n and the number of formulas in \u0393 of depth n is less than that in \u0393\u2032.\nBASE:\nLet \u0393 be a set of literals. If \u2228 \u0393 \u22a2 \u22a4 then EL(\u03c9,\u0393) = \u2205 = UL(\u03c9, {\u00ac \u2227 \u0393}).\nIf \u2228 \u0393 6\u22a2 \u22a4 then:\nEL(\u03c9,\u0393) = (\u03c9 \u2193 \u0393) \u222a \u0393\n= (\u03c9 \u2193 \u0393) \u222a \u0393\n= UL(\u03c9,\u0393) = UL ( \u03c9, { \u00ac \u2227 \u0393 })\nSTEP: Assume that the result holds for the first n sets of formulas in the ordering, and let \u00b5 be a formula of maximum depth in \u0393. Let \u0393\u2032 = \u0393 \\ {\u00b5}. If \u00b5 = \u03b1 \u2227 \u03b2, then\nEL(\u03c9,\u0393) = EL(\u03c9, {\u03b1 \u2227 \u03b2} \u222a \u0393\u2032)\n= EL(\u03c9, {\u03b1} \u222a \u0393\u2032) \u222a EL(\u03c9, {\u03b2} \u222a \u0393\u2032) = EL(\u03c9, {\u2227({\u03b1} \u222a \u0393\u2032)}) \u222a EL(\u03c9, {\u2227({\u03b2} \u222a \u0393\u2032)}) = UL(\u03c9, {\u00ac \u2227 ({\u03b1} \u222a \u0393\u2032)}) \u222a UL(\u03c9, {\u00ac \u2227 ({\u03b2} \u222a \u0393\u2032)}) = UL(\u03c9, {\u00ac\u03b1 \u2228 (\u00ac \u2227 \u0393\u2032)}) \u222a UL(\u03c9, {\u00ac\u03b2 \u2228 (\u00ac \u2227 \u0393\u2032)}) = UL(\u03c9, {\u00ac\u03b1 \u2228 (\u00ac \u2227 \u0393\u2032) \u2228 \u00ac\u03b2 \u2228 (\u00ac \u2227 \u0393\u2032)}) = UL(\u03c9, {\u00ac\u03b1 \u2228 \u00ac\u03b2 \u2228 (\u00ac \u2227 \u0393\u2032)}) = UL(\u03c9, {\u00ac(\u03b1 \u2227 \u03b2 \u2227 (\u2227\u0393\u2032))})\n= UL(\u03c9, {\u00ac(\u2227\u0393)}).\nThe change from EL to UL above is justified by the induction hypothesis; otherwise all steps are by definition of UL or EL, or simple manipulation.\nIf \u00b5 = \u03b1 \u2228 \u03b2, then\nEL(\u03c9,\u0393) = EL(\u03c9, {\u03b1 \u2228 \u03b2} \u222a \u0393\u2032)\n= EL(\u03c9, {\u03b1, \u03b2} \u222a \u0393\u2032) = UL(\u03c9, {\u00ac \u2227 ({\u03b1, \u03b2} \u222a \u0393\u2032)})\n= UL(\u03c9, {\u00ac(\u2227\u0393)}).\nAgain, the change from EL to UL above is justified by the induction hypothesis. Other cases are handled analogously; their proofs are omitted. Hence our result follows by induction.\nProof 9.\nMod(\u03c8 c\u00b5) = Mod(\u03c8) \u222a {\u03c9 \u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00ac\u00b5}), \u03c9 \u2208Mod(\u03c8)}\n= Mod(\u03c8) \u222a {\u03c9\u2032 | \u03c9\u2032 \u2208 EL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c8)} = Mod(\u03c8 \u2032c \u00b5)\nThe first and last steps above are justified by Definitions 8 and 10 respectively; the middle step follows from Lemma 1.\nProof 10. It follows immediately from Definitions 11 and 12 thatMod(\u03c8\u2217\u00b5) \u2286Mod(\u03c8\u2217S \u00b5).\nTo show the converse, we let w\u2032 \u2208Mod(\u03c8 \u2217S \u00b5) and show that w \u2032 \u2208Mod(\u03c8 \u2217 \u00b5).\nGiven that the Satoh revision operator satisfies irrelevance of syntax (R4), we can assume without loss of generality that \u00b5 is in dnf; i.e. \u00b5 = \u00b51 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00b5n where each \u00b5i is a conjunction of literals.\nWe have by assumption that w\u2032 \u2208Mod(\u03c8 \u2217S \u00b5); hence \u2203w \u2208Mod(\u03c8) such that w\u2206w \u2032 \u2208\n\u2206min(\u03c8, \u00b5).\nSince w\u2032 \u2208Mod(\u03c8 \u2217S \u00b5), we have that w \u2032 \u2208 Mod(\u00b5) = Mod(\u00b51 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00b5n). Thus there is a clause from \u00b5, \u00b5i, such that w \u2032 \u2208 Mod(\u00b5i). Assume without loss of generality that \u00b5i is subset-minimal among the sets of literals making up the disjuncts of \u00b5.\nIf we can show w\u2032 \u2208 UL(w, {\u00b5i}) then we will have shown that w \u2032 satisfies the conditions to be a member of Mod(\u03c8 \u2217 \u00b5). We show this as follows. Let Ui be the set of literals in \u00b5i. We have that for l 6\u2208 Ui that l \u2208 w iff l \u2208 w\n\u2032 (since otherwise this would contradict w\u2206w\u2032 \u2208 \u2206min(\u03c8, \u00b5)).\nIt follows that (w \u2193 Ui) \u222a Ui = w \u2032. But this means that w\u2032 \u2208 UL(w,Ui), or w \u2032 \u2208 UL(w, {ui}) and so w\n\u2032 \u2208 UL(w, {\u00b5}). Hence w\u2032 \u2208Mod(\u03c8 \u2217 \u00b5), which was to be shown.\nProof 11.\nU1: By Theorem 4 , UL(\u03c9, {\u00b5}) |= \u00b5 for every \u03c9 \u2208Mod(\u03c8), whenceMod(\u03c8\u22c4c\u00b5) \u2286Mod(\u00b5) or \u03c8 \u22c4c \u00b5 \u22a2 \u00b5.\nU3: By assumption \u03c8 6\u22a2 \u22a5, and so Mod(\u03c8) 6= \u2205. Our result then follows immediately from Theorem 5 and Definition 7.\nU5: If Mod(\u03c8 \u22c4c \u00b5) \u2229Mod(\u03c6) = \u2205 then our result follows vacuously.\nOtherwise, let \u03c9 \u2208Mod(\u03c8 \u22c4c \u00b5) \u2229Mod(\u03c6).\nSince \u03c9 \u2208 Mod(\u03c8 \u22c4c \u00b5) then, by Theorem 3, there exists \u03c9 \u2032 \u2208 Mod(\u03c8) and \u0393 \u2286 Lits such that \u2227 \u0393 is a disjunct of dnf (\u00b5) where \u03c9 = (\u03c9\u2032 \u2193 \u0393) \u222a \u0393.\nBecause \u03c9 \u2208Mod(\u03c6) there is a set of literals \u0393\u2032 such that \u2227 \u0393\u2032 is a disjunct of dnf (\u03c6) such that \u0393\u2032 \u2286 \u03c9.\nBy definition, \u2227 \u0393\u222a\u0393\u2032 is a clause in dnf (\u00b5\u2227\u03c6). We note that \u03c9 = (\u03c9\u2032 \u2193 (\u0393\u222a\u0393\u2032))\u222a(\u0393\u222a\u0393\u2032) so by Definition 7 we have \u03c9 \u2208Mod(\u03c8 \u22c4c (\u00b5 \u2227 \u03c6)).\nU7:\nMod(\u03c8 \u22c4c \u00b51) \u2229Mod(\u03c8 \u22c4c \u00b52)\n\u2286 Mod(\u03c8 \u22c4c \u00b51) \u222aMod(\u03c8 \u22c4c \u00b52)\n\u2286 Mod(\u03c8 \u22c4c (\u00b51 \u2228 \u00b52))\nThe last step follows from Theorem 3, using the fact that dnf (\u03b1\u2228\u03b2) = dnf (\u03b1)\u2228dnf (\u03b2).\nHence (\u03c8 \u22c4c \u00b51) \u2227 (\u03c8 \u22c4c \u00b52) implies \u03c8 \u22c4c (\u00b51 \u2228 \u00b52).\nU8:\nMod((\u03c81 \u2228 \u03c82) \u22c4c \u00b5) = {\u03c9 \u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c81 \u2228 \u03c82)}\n= {\u03c9\u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c81) \u222aMod(\u03c82)} = {\u03c9\u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c81)}\n\u222a {\u03c9\u2032 \u2208 UL(\u03c9, {\u00b5}), \u03c9 \u2208Mod(\u03c82)}\n= Mod(\u03c81 \u22c4c \u00b5) \u222aMod(\u03c82 \u22c4c \u00b5).\nFromMod((\u03c81\u2228\u03c82)\u22c4c\u00b5) =Mod(\u03c81\u22c4c\u00b5)\u222aMod(\u03c82\u22c4c\u00b5) it follows that ((\u03c81\u2228\u03c82)\u22c4c\u00b5) \u2194 (\u03c81 \u22c4c \u00b5) \u2228 (\u03c82 \u22c4c \u00b5).\nProof 12.\nMod(\u03c8 \u22c4c (\u00b51 \u2228 \u00b52)) = {\u03c9 \u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b51 \u2228 \u00b52}), \u03c9 \u2208Mod(\u03c8)}\n= {\u03c9\u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b51}), \u03c9 \u2208Mod(\u03c8)} \u222a\n{\u03c9\u2032 | \u03c9\u2032 \u2208 UL(\u03c9, {\u00b52}), \u03c9 \u2208Mod(\u03c8)}\n= Mod(\u03c8 \u22c4c \u00b51) \u222aMod(\u03c8 \u22c4c \u00b52)\n= Mod((\u03c8 \u22c4c \u00b51) \u2228 (\u03c8 \u22c4c \u00b52))\nProof 13. We need to show that if \u03c81 \u2194 \u03c82 and \u00b51 \u2194 \u00b52 then we have that (\u03c81 \u22c4c\u00b51) \u2194 (\u03c82 \u22c4c\u00b51). Since \u00b51 \u2194 \u00b52 by assumption, we have that PI(\u00b51) = PI(\u00b52). 12 Since (\u03c81 \u22c4c \u2228\nPI(\u00b51)) \u2194 (\u03c82 \u22c4c \u2228 PI(\u00b51)) and (\u03c82 \u22c4c \u2228 PI(\u00b51)) \u2194 (\u03c82 \u22c4c \u2228 PI(\u00b52)), we have (\u03c81 \u22c4c \u2228\nPI(\u00b51)) \u2194 (\u03c82 \u22c4c \u2228 PI(\u00b52)), whence (\u03c8 \u22c4 pi c \u00b51) \u2194 (\u03c8 \u22c4 pi c \u00b52).\nProof 14. We have that Mod(\u03c8 \u22c4ssc \u00b5) = Mod(\u03c8 \u22c4c ( \u2228 ( \u2227\nModL(\u00b5)))). Using Definition 7, the right hand side is equal to {\u03c9\u2032 | \u03c9\u2032 \u2208 UL(\u03c9, { \u2228 ( \u2227\nModL(\u00b5))}), \u03c9 \u2208 Mod(\u03c8)}. Hence, each \u03c9 \u2208 Mod(\u03c8) is replaced by a set of interpretations \u2126 where \u2126 = {(\u03c9 \u2193 \u03c9\u2032\u2032) \u222a \u03c9\u2032\u2032 | \u03c9\u2032\u2032 \u2208 ModL(\u00b5)}. Which is to say, \u03c9 \u2208 Mod(\u03c8) is replaced by a set of interpretations \u2126 where \u03c9\u2032\u2032 \u2208 \u2126 just if \u03c9 and \u03c9\u2032\u2032 differ only over the language of \u00b5. But this is just the definition for Mod(\u03c8 \u22c4ssc \u00b5).\nProof 15. Let \u0393 = {p1, . . . , pn}.\n\u03c8 \u2299 \u0393 = \u03c8 \u2299 {p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pn}\n= [(\u03c8 \u2299 {p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pn}) \u22c4c pn] \u2228 [(\u03c8 \u2299 {p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pn}) \u22c4c \u00acpn]\n12. Equality isn\u2019t quite right here. Rather we have equality modulo associativity and commutativity, which is all that we need for our result.\nThe second step above is just Definition 3 for forget expressed in terms of update. Definition 3 can be successively reapplied to eventually terminate with a disjunction with 2n disjuncts, where each disjunct is a sequence of n updates of literals from \u0393. Moreover, every maximum consistent set of literals from \u0393 appears in some disjunct.\nWe have the easy result, that we state without proof, that for disjoint sets of literals \u03931, \u03932, that (\u03c8 \u22c4c (\u2227\u03931)) \u22c4c (\u2227\u03932) = (\u03c8 \u22c4c \u2227(\u03931 \u222a \u03932)).\nHence we get finally that\n\u03c8 \u2299 \u0393 = \u2227\n\u039b\u2286\u0393\n\u03c8 \u22c4c ((\u2227\u039b) \u2227 \u00ac \u2227 (\u0393 \\ \u039b))\n= \u03c8 \u22c4c\n\n\n\u2227\np\u2208\u0393\n(p \u2228 \u00acp).\n\n\nProof 16.\n\u00bfFrom Theorem 15 we have that\n\u03c8 \u2299 \u0393 = \u03c8 \u22c4c\n(\n\u2227\na\u2208\u0393\n(a \u2228 \u00aca).\n)\n= \u03c8 \u22c4c \u00b5.\n\u00bfFrom Observation 1 we get that \u03c8 \u22c4c \u00b5 = \u03c8 \u22c4c dnf (\u00b5). An easy argument shows that dnf (\u00b5) = \u2228\u2227\nModL(\u00b5), and so Definition 14 yields \u03c8 \u22c4c dnf (\u00b5) = \u03c8 \u22c4 ss c \u00b5. Theorem 14 is\n\u03c8 \u22c4ssc \u00b5 = \u03c8 \u22c4ss \u00b5. Putting this all together we get \u03c8 \u2299 \u2227(\u0393) = \u03c8 \u22c4 ss c \u00b5.\nProof of Lemma 2.\nEquation (5) implies that Mod((\u2203P.\u03c8) \u2227 t) = Mod(\u03c8 \u22c4ss t). According to Theorem 14 and Definition 14, we then have Mod(\u03c8 \u22c4ss t) =Mod(\u03c8 \u22c4c ( \u2228 ( \u2227\nModL(t)))) =Mod(\u03c8 \u22c4c t). From Definition 7, it follows that Mod((\u2203P.\u03c8) \u2227 t) = {w\u2032 | w\u2032 \u2208 UL(w, t), w \u2208Mod(\u03c8)}.\nProof 17.\nAccording to Definition 7,Mod(\u03c8\u22c4c\u00b5) = {w \u2032 | w\u2032 \u2208 UL(w, {\u00b5}), w \u2208Mod(\u03c8)}. By Theorem 3, we have {w\u2032 | w\u2032 \u2208 UL(w, {\u00b5}), w \u2208 Mod(\u03c8)} = {w\u2032 | w\u2032 \u2208 UL(w, {dnf (\u00b5)}), w \u2208 Mod(\u03c8)}. From Definition 6, it follows that Mod(\u03c8 \u22c4c \u00b5) = {w\n\u2032 | w\u2032 \u2208 UL(w, t), t \u2208 dnf (\u00b5), w \u2208Mod(\u03c8)}. According to Lemma 2, thus Mod(\u03c8 \u22c4c \u00b5) =Mod(Update(\u03c8, \u00b5)).\nProof 18.\nThe size of dnf (\u03c8) is O(2|\u03c8|). Hence, the size of Eliminant(P,\u03c8) is also O(2|\u03c8|). Similarly, the size of dnf (\u00b5) is O(2|\u00b5|). Therefore, |Update(\u03c8, \u00b5)| = O(2|\u00b5| \u00d7 2|\u03c8|) = O(2|\u03c8|+|\u00b5|).\nProof 19.\nThis proof is inspired by the ideas in (Cadoli, Donini, Liberatore, & Schaerf, 1995), where it was shown that many revision operators cause exponential blowup. We show that\nif there exists a polynomially space bounded algorithm of compositional update, then 3SAT is in P/poly.13 The proof consists of two steps.\nSTEP 1:\nFor any integer n, we first construct a belief base \u03c8n and a formula \u00b5n, whose sizes are polynomial wrt. n. Let X = {x1, \u00b7 \u00b7 \u00b7 , xn} and Y = {y1, \u00b7 \u00b7 \u00b7 , yn} be two disjoint set of atoms and let C be a set of new atoms for each 3-literal clause over X, i.e., C = {ci | \u03b3i is a 3-literal clause of X}. We obtain \u03c8n and \u00b5n as follows:\n\u03c8n = {\u03b3i \u2228 \u00acci | \u03b3i is a 3-literal clause of X} \u00b5n = \u2227n i=1(\u00acx1 \u2227 \u00acyi)\nIt is easy to see that |\u03c8n| \u2208 O(n 3) and |\u00b5n| \u2208 O(n).\nThen we show that for any 3CNF \u03b2 of size n, there exists an interpretation \u03c9\u03b2 (on atoms X \u222a Y \u222a C) such that \u03c9\u03b2 |= \u03c8n \u22c4c \u00b5n iff \u03b2 is satisfiable. We assume, without loss of generality, that atom(\u03b2) \u2286 X; or otherwise, we can always substitute atoms of \u03b2 respectively by elements of X to obtain a new sentence \u03b2X such that \u03b2 is satisfiable iff \u03b2X is satisfiable. Then w\u03b2 can be obtained as follows:\nw\u03b2 = {ci \u2208 C | \u03b3i is a clause of \u03b2} \u222a {\u00acci \u2208 C | \u03b3i is not a clause of \u03b2} \u222aX \u222a Y\nWe now show that \u03b2 is satisfiable iff \u03c9\u03b2 |= \u03c8n \u22c4c \u00b5n.\n\u21d2 Assume \u03b2 is satisfiable. Let \u03c9 be a model of \u03b2. We construct another interpretation \u03c9\u2032 = UL(\u03c9, {\u00acci \u2208 C | \u03b3i is not a clause of \u03b2}). It is easy to see that \u03c9\n\u2032 |= \u03c8n and \u03c9\u03b2 = UL(\u03c9 \u2032, {\u00acxi,\u00acyi | 1 \u2264 i \u2264 n}). It follows that \u03c9\u03b2 |= \u03c8n \u22c4c \u00b5n.\n\u21d0 Assume \u03c9\u03b2 |= \u03c8n \u22c4c \u00b5n. Then there exists an interpretation \u03c9 such that \u03c9 |= \u03c8n and \u03c9\u03b2 = UL(\u03c9, {\u00acxi,\u00acyi | 1 \u2264 i \u2264 n}). We claim that \u03c9 |= \u03b2. Assume \u03c9 6|= \u03b2. Then there exists a 3-literal clause \u03b3i of \u03b2 such that \u03c9 6|= \u03b3i. From \u03c9\u03b2 = UL(\u03c9, {\u00acxi,\u00acyi | 1 \u2264 i \u2264 n}) and ci \u2208 \u03c9\u03b2, if follows that ci \u2208 \u03c9. This implies \u03c9 6|= \u03b3i \u2228 \u00acci, which contradicts \u03c9 |= \u03c8n. Thus, \u03b2 is indeed satisfiable.\nSTEP 2:\nSuppose Update is a polynomial space bounded algorithm of compositional update. Then 3SAT can be solved by an advice taking TM as follows: Given an arbitrary 3CNF \u03b2 of size n, the machine first loads the advice string Update(\u03c8n, \u00b5n) and computes (in polynomial time) \u03c9\u03b2 ; then it verifies \u03c9\u03b2 |= Update(\u03c8n, \u00b5n). Since |\u03c8n| \u2208 O(n\n3), |\u00b5n| \u2208 O(n), and |Update(\u03c8n, \u00b5n)| \u2264 p(|\u03c8n| + |\u00b5n|), we can do the verification in polynomial time. Since Update(\u03c8n, \u00b5n) \u2194 \u03c8n \u22c4c \u00b5n, we have \u03c9\u03b2 |= \u03c8n \u22c4c \u00b5n iff \u03c9\u03b2 |= Update(\u03c8n, \u00b5n). Therefore, \u03b2 is satisfiable iff \u03c9\u03b2 |= Update(\u03c8n, \u00b5n). This shows that 3SAT \u2208 P/poly. As 3SAT is NP-complete, we have NP \u2286 P/poly.\nProof 20.\n13. A 3-literal clause is clause consists of precisely 3 literals and a 3CNF is a conjunction of 3-literal clauses. 3SAT is the satisfiability problem for 3CNFs, which has been shown NP-complete.\nThis proof is exactly same as that of Theorem 19, as the update formula \u00b5n used there is a consistent conjunction of literals.\nProof 21. Since \u03c8, \u00b5 are in dnf, |\u03c8| = |dnf (\u03c8)| and |\u00b5| = dnf (\u00b5). Thus |Eliminant(P,\u03c8)| = O|\u03c8|. Therefore |Update(\u03c8, \u00b5)| = O(|\u03c8| \u00d7 |\u00b5|).\nIn case |\u00b5| < k, we have |Update(\u03c8, \u00b5)| = O(|\u03c8| \u00d7 k) = O(\u03c8)."}], "references": [{"title": "On the logic of theory change: Partial meet functions for contraction and revision", "author": ["C. Alchourr\u00f3n", "P. G\u00e4rdenfors", "D. Makinson"], "venue": "Journal of Symbolic Logic,", "citeRegEx": "Alchourr\u00f3n et al\\.,? \\Q1985\\E", "shortCiteRegEx": "Alchourr\u00f3n et al\\.", "year": 1985}, {"title": "An Investigation of the Laws of Thought", "author": ["G. Boole"], "venue": "Walton, London. (Reprinted by Dover Books, New York, 1954).", "citeRegEx": "Boole,? 1854", "shortCiteRegEx": "Boole", "year": 1854}, {"title": "Language features for flexible handling of exceptions in information systems", "author": ["A. Borgida"], "venue": "ACM Transactions on Database Systems, 10.", "citeRegEx": "Borgida,? 1985", "shortCiteRegEx": "Borgida", "year": 1985}, {"title": "How to do things with worlds: On formalizing actions and plans", "author": ["G. Brewka", "J. Herzberg"], "venue": "J. Logic Computation,", "citeRegEx": "Brewka and Herzberg,? \\Q1993\\E", "shortCiteRegEx": "Brewka and Herzberg", "year": 1993}, {"title": "A taxonomy and current issues in multidatabase systems", "author": ["M. Bright", "A. Hurson", "S. Pakzad"], "venue": null, "citeRegEx": "Bright et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Bright et al\\.", "year": 1992}, {"title": "Boolean Reasoning", "author": ["F. Brown"], "venue": "Kluwer Academic Publishers.", "citeRegEx": "Brown,? 1990", "shortCiteRegEx": "Brown", "year": 1990}, {"title": "The size of a revised knowledge base", "author": ["M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf"], "venue": "Proceedings of the fourteenth ACM SIGACT-SIGMODSIGART symposium on Principles of database systems,", "citeRegEx": "Cadoli et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Cadoli et al\\.", "year": 1995}, {"title": "Investigations into theory of knowledge base revision", "author": ["M. Dalal"], "venue": "In Proceedings of the AAAI National Conference on Artificial Intelligence,", "citeRegEx": "Dalal,? \\Q1988\\E", "shortCiteRegEx": "Dalal", "year": 1988}, {"title": "Gricean belief change", "author": ["J. Delgrande", "A. Nayak", "M. Pagnucco"], "venue": "Studia Logica,", "citeRegEx": "Delgrande et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Delgrande et al\\.", "year": 2005}, {"title": "A consistency-based approach for belief change", "author": ["J. Delgrande", "T. Schaub"], "venue": "Artificial Intelligence,", "citeRegEx": "Delgrande and Schaub,? \\Q2003\\E", "shortCiteRegEx": "Delgrande and Schaub", "year": 2003}, {"title": "Compositional belief update", "author": ["J. Delgrande", "F. Pelletier", "M. Suderman"], "venue": "In Proceedings of FLAIRS-20,", "citeRegEx": "Delgrande et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Delgrande et al\\.", "year": 2007}, {"title": "The PMA and relativizing change for action update", "author": ["P. Doherty", "W. Lukaszewicz", "E. Madali\u0144ska-Bugaj"], "venue": "Proceedings of the International Conference on the Principles of Knowledge Representation and Reasoning,", "citeRegEx": "Doherty et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Doherty et al\\.", "year": 1998}, {"title": "Quota and Gmin merging operators", "author": ["P. Everaere", "S. Konieczny", "P. Marquis"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence,", "citeRegEx": "Everaere et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Everaere et al\\.", "year": 2005}, {"title": "The strategy-proofness landscape of merging", "author": ["P. Everaere", "S. Konieczny", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Everaere et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Everaere et al\\.", "year": 2007}, {"title": "Introducing actions into qualitative simulation", "author": ["K. Forbus"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence, pp. 1273\u20131278.", "citeRegEx": "Forbus,? 1989", "shortCiteRegEx": "Forbus", "year": 1989}, {"title": "Theory contraction through base contraction", "author": ["A. Fuhrmann"], "venue": "Journal of Philosophical Logic, 20, 175\u2013203.", "citeRegEx": "Fuhrmann,? 1991", "shortCiteRegEx": "Fuhrmann", "year": 1991}, {"title": "Knowledge in Flux: Modelling the Dynamics of Epistemic States", "author": ["P. G\u00e4rdenfors"], "venue": "The MIT Press, Cambridge, MA.", "citeRegEx": "G\u00e4rdenfors,? 1988", "shortCiteRegEx": "G\u00e4rdenfors", "year": 1988}, {"title": "Propositional belief update and minimal change", "author": ["A. Herzig", "O. Rifi"], "venue": "Artificial Intelligence,", "citeRegEx": "Herzig and Rifi,? \\Q1999\\E", "shortCiteRegEx": "Herzig and Rifi", "year": 1999}, {"title": "A catalog of complexity classes", "author": ["D. Johnson"], "venue": "van Leeuwen, J. (Ed.), Handbook of Theoretical Computer Science: Volume A: Algorithms and Complexity, pp. 67\u2013161. Elsevier, Amsterdam.", "citeRegEx": "Johnson,? 1990", "shortCiteRegEx": "Johnson", "year": 1990}, {"title": "Some connections between non-uniform and uniform complexity classes", "author": ["R.M. Karp", "R.J. Lipton"], "venue": "In Proc. of the 12th ACM sym. on Theory of Computing", "citeRegEx": "Karp and Lipton,? \\Q1980\\E", "shortCiteRegEx": "Karp and Lipton", "year": 1980}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["H. Katsuno", "A. Mendelzon"], "venue": "Belief Revision,", "citeRegEx": "Katsuno and Mendelzon,? \\Q1992\\E", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1992}, {"title": "Merging information under constraints: A logical framework", "author": ["S. Konieczny", "R. Pino P\u00e9rez"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Konieczny and P\u00e9rez,? \\Q2002\\E", "shortCiteRegEx": "Konieczny and P\u00e9rez", "year": 2002}, {"title": "On the difference between merging knowledge bases and combining them", "author": ["S. Konieczny"], "venue": "Cohn, A. G., Giunchiglia, F., & Selman, B. (Eds.), KR2000: Principles of Knowledge Representation and Reasoning, pp. 135\u2013144, San Francisco. Morgan Kaufmann.", "citeRegEx": "Konieczny,? 2000", "shortCiteRegEx": "Konieczny", "year": 2000}, {"title": "On the logic of merging", "author": ["S. Konieczny", "R. Pino P\u00e9rez"], "venue": null, "citeRegEx": "Konieczny and P\u00e9rez,? \\Q1998\\E", "shortCiteRegEx": "Konieczny and P\u00e9rez", "year": 1998}, {"title": "About time, revision, and update", "author": ["J. Lang"], "venue": "Dix, J., & Hunter, A. (Eds.), Proceedings of the Eleventh International Workshop on Non-Monotonic Reasoning (NMR 2006).", "citeRegEx": "Lang,? 2006", "shortCiteRegEx": "Lang", "year": 2006}, {"title": "Propositional independence : Formulavariable independence and forgetting", "author": ["J. Lang", "P. Liberatore", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Lang et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lang et al\\.", "year": 2003}, {"title": "Arbitration (or how to merge knowledge bases)", "author": ["P. Liberatore", "M. Schaerf"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "Liberatore and Schaerf,? \\Q1998\\E", "shortCiteRegEx": "Liberatore and Schaerf", "year": 1998}, {"title": "Forget it", "author": ["F. Lin", "R. Reiter"], "venue": "In AAAI Fall Symposium on Relevance,", "citeRegEx": "Lin and Reiter,? \\Q1994\\E", "shortCiteRegEx": "Lin and Reiter", "year": 1994}, {"title": "On strongest neccessary and weakest sufficient conditions", "author": ["F. Lin"], "venue": "Artificial Intelligence, 128 (1-2), 143\u2013159.", "citeRegEx": "Lin,? 2001", "shortCiteRegEx": "Lin", "year": 2001}, {"title": "Merging databases under constraints", "author": ["J. Lin", "A.O. Mendelzon"], "venue": "International Journal of Cooperative Information Systems,", "citeRegEx": "Lin and Mendelzon,? \\Q1998\\E", "shortCiteRegEx": "Lin and Mendelzon", "year": 1998}, {"title": "Merging epistemic states", "author": ["T. Meyer"], "venue": "Pacific Rim International Conference on Artificial Intelligence, pp. 286\u2013296.", "citeRegEx": "Meyer,? 2000", "shortCiteRegEx": "Meyer", "year": 2000}, {"title": "On the semantics of combination operations", "author": ["T. Meyer"], "venue": "Journal of Applied NonClassical Logics, 11 (1-2), 59\u201384.", "citeRegEx": "Meyer,? 2001", "shortCiteRegEx": "Meyer", "year": 2001}, {"title": "Forgetting and knowledge update", "author": ["A. Nayak", "Y. Chen", "F. Lin"], "venue": "Proceedings of the Nineteenth Australian Joint Conference of Artificial Intelligence (AI-06),", "citeRegEx": "Nayak et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Nayak et al\\.", "year": 2006}, {"title": "Beliefs, belief revision, and splitting languages", "author": ["R. Parikh"], "venue": "Moss, L., Ginzburg, J., & de Rijke, M. (Eds.), Logic, Language and Computation, Vol 2, pp. 266\u2013278. CSLI Publications.", "citeRegEx": "Parikh,? 1999", "shortCiteRegEx": "Parikh", "year": 1999}, {"title": "Distance semantics for relevance-sensitive belief revision. In KR2004: Principles of Knowledge Representation and Reasoning, San Francisco", "author": ["P. Peppas", "S. Chopra", "N. Foo"], "venue": null, "citeRegEx": "Peppas et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Peppas et al\\.", "year": 2004}, {"title": "On the semantics of theory change: Arbitration between old and new information", "author": ["P. Revesz"], "venue": "Beeri, C. (Ed.), Proceedings of the Twelth ACM Symposium on Principles of Database Systems, pp. 71\u201382, Washington D.C.", "citeRegEx": "Revesz,? 1993", "shortCiteRegEx": "Revesz", "year": 1993}, {"title": "Severe withdrawal (and recovery)", "author": ["H. Rott", "M. Pagnucco"], "venue": "Journal of Philosophical Logic,", "citeRegEx": "Rott and Pagnucco,? \\Q1999\\E", "shortCiteRegEx": "Rott and Pagnucco", "year": 1999}, {"title": "Nonmonotonic reasoning by minimal belief revision", "author": ["K. Satoh"], "venue": "Proceedings of the International Conference on Fifth Generation Computer Systems, pp. 455\u2013462, Tokyo.", "citeRegEx": "Satoh,? 1988", "shortCiteRegEx": "Satoh", "year": 1988}, {"title": "Amalgamating knowledge bases", "author": ["S. Subrahmanian"], "venue": "ACM Transactions on Database Systems, 19, 291\u2013331.", "citeRegEx": "Subrahmanian,? 1994", "shortCiteRegEx": "Subrahmanian", "year": 1994}, {"title": "On having bad contractions or: No room for recovery", "author": ["N. Tennant"], "venue": "Journal of Applied Non-Classical Logic, 7, 241\u2013266.", "citeRegEx": "Tennant,? 1997", "shortCiteRegEx": "Tennant", "year": 1997}, {"title": "Updating propositional formulas", "author": ["A. Weber"], "venue": "Proc. First Conference on Expert Database Systems, pp. 487\u2013500.", "citeRegEx": "Weber,? 1986", "shortCiteRegEx": "Weber", "year": 1986}, {"title": "Towards a practical approach to belief revision: Reason-based change", "author": ["Williams", "M.-A."], "venue": "Aiello, L., Doyle, J., & Shapiro, S. (Eds.), Proceedings of the Fifth International Conference on the Principles of Knowledge Representation and Reasoning, pp. 412\u2013421, Cambridge, MA.", "citeRegEx": "Williams and M..A.,? 1996", "shortCiteRegEx": "Williams and M..A.", "year": 1996}, {"title": "Reasoning about action using a possible models approach", "author": ["M. Winslett"], "venue": "Proceedings of the AAAI National Conference on Artificial Intelligence, pp. 89\u201393, St. Paul, Minnesota.", "citeRegEx": "Winslett,? 1988", "shortCiteRegEx": "Winslett", "year": 1988}, {"title": "Updating Logical Databases", "author": ["M. Winslett"], "venue": "Cambridge University Press, Cambridge.", "citeRegEx": "Winslett,? 1990", "shortCiteRegEx": "Winslett", "year": 1990}], "referenceMentions": [{"referenceID": 16, "context": "Initially, in the AGM approach (Alchourr\u00f3n, G\u00e4rdenfors, & Makinson, 1985; G\u00e4rdenfors, 1988), standards for belief revision and contraction functions were given, wherein it was assumed that a knowledge base is receiving information concerning a static1 domain, and that it is the increased amount or accuracy of information that is responsible for the changes in the knowledge base.", "startOffset": 31, "endOffset": 91}, {"referenceID": 15, "context": "Initially, in the AGM approach (Alchourr\u00f3n, G\u00e4rdenfors, & Makinson, 1985; G\u00e4rdenfors, 1988), standards for belief revision and contraction functions were given, wherein it was assumed that a knowledge base is receiving information concerning a static1 domain, and that it is the increased amount or accuracy of information that is responsible for the changes in the knowledge base. Subsequently, Katsuno and Mendelzon (1992) explored a distinct notion of belief change, with functions for belief update and erasure, wherein an agent changes its beliefs in response to what it perceives as changes in the environment.", "startOffset": 44, "endOffset": 425}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions.", "startOffset": 42, "endOffset": 55}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions.", "startOffset": 42, "endOffset": 114}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions.", "startOffset": 42, "endOffset": 129}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a \u201cmerged\u201d knowledge base that best represents the information in a set of other knowledge bases.", "startOffset": 42, "endOffset": 753}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a \u201cmerged\u201d knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the \u201cdesires\u201d and \u201cgoals\u201d of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino P\u00e9rez, 1998; Everaere, Konieczny, & Marquis, 2007). The distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino P\u00e9rez (1998) compared merging with revision; Nayak et al.", "startOffset": 42, "endOffset": 1493}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a \u201cmerged\u201d knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the \u201cdesires\u201d and \u201cgoals\u201d of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino P\u00e9rez, 1998; Everaere, Konieczny, & Marquis, 2007). The distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino P\u00e9rez (1998) compared merging with revision; Nayak et al.", "startOffset": 42, "endOffset": 1556}, {"referenceID": 1, "context": "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a \u201cmerged\u201d knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the \u201cdesires\u201d and \u201cgoals\u201d of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino P\u00e9rez, 1998; Everaere, Konieczny, & Marquis, 2007). The distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino P\u00e9rez (1998) compared merging with revision; Nayak et al. (2006) compared forgetting with update.", "startOffset": 42, "endOffset": 1608}, {"referenceID": 24, "context": "Further considerations on how revision and update are interrelated are in the work of Lang (2006). 2.", "startOffset": 86, "endOffset": 98}, {"referenceID": 24, "context": "Further considerations on how revision and update are interrelated are in the work of Lang (2006). 2. Nayak, Chen, and Lin (2006) described this difference thus: \u201cWhile belief erasure purports to answer the question \u2018What should I believe if I can no longer support the belief that the cook killed Cock Robin?\u2019, forgetting purports to answer the question \u2018What should I believe if Killing was a concept not afforded in my language?\u2019.", "startOffset": 86, "endOffset": 130}, {"referenceID": 2, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 80, "endOffset": 121}, {"referenceID": 7, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 80, "endOffset": 121}, {"referenceID": 37, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 80, "endOffset": 121}, {"referenceID": 14, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 137, "endOffset": 180}, {"referenceID": 40, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 137, "endOffset": 180}, {"referenceID": 42, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 137, "endOffset": 180}, {"referenceID": 38, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 197, "endOffset": 272}, {"referenceID": 22, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.", "startOffset": 197, "endOffset": 272}, {"referenceID": 32, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006).", "startOffset": 289, "endOffset": 344}, {"referenceID": 33, "context": "The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999).", "startOffset": 211, "endOffset": 225}, {"referenceID": 25, "context": "As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget.", "startOffset": 87, "endOffset": 146}, {"referenceID": 32, "context": "As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget.", "startOffset": 87, "endOffset": 146}, {"referenceID": 16, "context": "Although our focus in this paper is with update \u2014 and hence with the postulates given by Katsuno and Mendelzon (1992) and the objections related to these postulates \u2014 we believe that considerations similar to the ones we bring forward in this arena would hold with respect to the other sorts of belief change postulates.", "startOffset": 89, "endOffset": 118}, {"referenceID": 2, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006). These approaches are formulated in terms of the distance between models of the knowledge base and models of a sentence for revision or update. In general there has been less work dealing with systems that may be readily implementable (but see, e.g., Williams, 1996; Delgrande & Schaub, 2003). In this paper we develop a specific update operator where the operator is intended to be compositional, in that an update \u03c8 \u22c4\u03bc can be expressed recursively in terms of the syntactic structure of \u03bc. Thus, if a knowledge base is to be updated by a disjunction \u03bc = a \u2228 b, the idea is that this update will be a function of the update by a in a certain combination with the update by b. The update of the knowledge base by a conjunction \u03bc = a \u2227 b will also be a function (a different one) of the update by a in combination with the update by b. The goal is to arrive at an operator whose results are intuitive, in that its definition is based on a recursive decomposition of a formula; hence the (generally abstract) notion of update will be anchored in part in a more familiar computational setting. Second, the hope is that these operators will be efficiently implementable, at least in some cases, by exploiting restrictions to the syntactic form of the formula. The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999). These goals are generally realised. First, the operators have reasonable properties: many of the Katsuno and Mendelzon benchmark properties are satisfied, including those deemed essential by Herzig and Rifi (1999). While we don\u2019t obtain full irrelevance of syntax, we do obtain weaker results in this regard; as well we show how irrelevance of syntax can be obtained by restricting the syntactic form of the sentence for update.", "startOffset": 81, "endOffset": 2042}, {"referenceID": 2, "context": "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006). These approaches are formulated in terms of the distance between models of the knowledge base and models of a sentence for revision or update. In general there has been less work dealing with systems that may be readily implementable (but see, e.g., Williams, 1996; Delgrande & Schaub, 2003). In this paper we develop a specific update operator where the operator is intended to be compositional, in that an update \u03c8 \u22c4\u03bc can be expressed recursively in terms of the syntactic structure of \u03bc. Thus, if a knowledge base is to be updated by a disjunction \u03bc = a \u2228 b, the idea is that this update will be a function of the update by a in a certain combination with the update by b. The update of the knowledge base by a conjunction \u03bc = a \u2227 b will also be a function (a different one) of the update by a in combination with the update by b. The goal is to arrive at an operator whose results are intuitive, in that its definition is based on a recursive decomposition of a formula; hence the (generally abstract) notion of update will be anchored in part in a more familiar computational setting. Second, the hope is that these operators will be efficiently implementable, at least in some cases, by exploiting restrictions to the syntactic form of the formula. The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999). These goals are generally realised. First, the operators have reasonable properties: many of the Katsuno and Mendelzon benchmark properties are satisfied, including those deemed essential by Herzig and Rifi (1999). While we don\u2019t obtain full irrelevance of syntax, we do obtain weaker results in this regard; as well we show how irrelevance of syntax can be obtained by restricting the syntactic form of the sentence for update. The approach is also related to other approaches in the literature, and hence serves to establish some links between approaches. In fact, the family of compositional update operators obtained by imposing various syntactic restrictions can be regarded as constituting a family of operators of which Winslett\u2019s standard semantics makes up the most basic nontrivial approach. As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget. We also define a revision operator using the obvious definition for such an operator; it proves to be the case that this operator corresponds with the revision operator in the work of Satoh (1988).", "startOffset": 81, "endOffset": 3041}, {"referenceID": 0, "context": "2 Belief Revision and Contraction In the seminal approach of AGM (Alchourr\u00f3n et al., 1985), postulates are proposed to constrain belief revision.", "startOffset": 65, "endOffset": 90}, {"referenceID": 0, "context": "2 Belief Revision and Contraction In the seminal approach of AGM (Alchourr\u00f3n et al., 1985), postulates are proposed to constrain belief revision. In this approach, a knowledge base K is assumed to be a belief set, a set of sentences closed under logical consequence. The revision of a belief set by a formula, K \u2217\u03c6, is a new belief set in which the formula \u03c6 is believed. The interesting case is that in which \u00ac\u03c6 is initially believed, and so to attain a consistent belief set (assuming that \u03c6 is satisfiable), some beliefs have to be dropped. Exactly which beliefs must be dropped is not stipulated in the AGM approach; however, constraints in the form of postulates that govern what are seen as legitimate revision operators are given. In contrast, in their development of belief update Katsuno and Mendelzon (1992) represented the knowledge base by a formula in some language L.", "startOffset": 66, "endOffset": 818}, {"referenceID": 20, "context": "\u201d But a different picture was put forward by Katsuno and Mendelzon (1992), where there was a \u201cchanging, dynamic world\u201d.", "startOffset": 45, "endOffset": 74}, {"referenceID": 17, "context": "Herzig and Rifi (1999) discussed the plausibility of the postulates given; they assert that U2, U5, and U6 are undesirable, while U7 is unimportant.", "startOffset": 0, "endOffset": 23}, {"referenceID": 42, "context": "The first, the Possible Models Approach (PMA) of (Winslett, 1988) is a well-known example of an update operator satisfying the Katsuno and Mendelzon update postulates.", "startOffset": 49, "endOffset": 65}, {"referenceID": 43, "context": "The second, the standard semantics of (Winslett, 1990) is a weak (in fact, arguably the weakest reasonable) approach to update.", "startOffset": 38, "endOffset": 54}, {"referenceID": 43, "context": "The operator \u03c8 \u22c4ss \u03bc is the weakest \u201creasonable\u201d update operator in the following sense (Winslett, 1990): First, for an update \u03c8 \u22c4ss \u03bc, \u03bc is true in every model of \u03c8 \u22c4ss \u03bc.", "startOffset": 88, "endOffset": 104}, {"referenceID": 1, "context": "The notion of forgetting goes back to George Boole (1854), though it has received more recent attention in Artificial Intelligence by, e.", "startOffset": 45, "endOffset": 58}, {"referenceID": 1, "context": "Then the usual definition for forgetting (again, going back to Boole) atom p in \u03c8 is given by \u03c8[p/\u22a4] \u2228 \u03c8[p/\u22a5]. In order to forget a set of atoms \u0393, one takes the disjunction of the substitution of all 2|\u0393| combinations of \u22a4, \u22a5 for elements of \u0393. We have the following definitions. For single atoms we basically follow Nayak et al. (2006); for sets of atoms we use the definition from (Lin & Reiter, 1994).", "startOffset": 63, "endOffset": 338}, {"referenceID": 30, "context": "(M3) If E1 and E2 are knowledge sets such that E1 \u2194 E2, then \u25b3(E1) \u2194 \u25b3(E2) (M4) If K1 and K2 are knowledge bases that are not mutually consistent, then \u25b3(K1 \u2294 K2) 6\u22a2 K1 (M5) \u25b3(E1) \u2227\u25b3(E2) \u22a2 \u25b3(E1 \u2294 E2) (M6) If \u25b3(E1) \u2227\u25b3(E2) is consistent, then \u25b3(E1 \u2294 E2) \u22a2 \u25b3(E1) \u2227\u25b3(E2) Some of these merging postulates have been contested: For example, Meyer (2000) argued that M4 and M6 should be rejected.", "startOffset": 334, "endOffset": 347}, {"referenceID": 23, "context": "Liberatore and Schaerf (1998) introduced the method of arbitration, whereby the goal is to adopt as many different opinions as possible from the members of the knowledge set (\u201ctry to take as many differing opinions as possible into account\u201d).", "startOffset": 0, "endOffset": 30}, {"referenceID": 20, "context": "Konieczny and Pino P\u00e9rez (1998) proved that there is no arbitration operator (at least, not of the sort that they characterize) that obeys M1 \u2013 M6.", "startOffset": 0, "endOffset": 32}, {"referenceID": 12, "context": "6 The interplay between various merging operations and the ability of an agent to hide, lie, or otherwise camouflage its preferences from other agents as they try to construct a merged knowledge base has been surveyed in Everaere et al. (2007).", "startOffset": 221, "endOffset": 244}, {"referenceID": 37, "context": "Satoh\u2019s (1988) revision operator \u03c8 \u2217S \u03bc is defined as follows.", "startOffset": 0, "endOffset": 15}, {"referenceID": 7, "context": "It follows as a straightforward corollary that if we use a distance metric based on the number of differing propositional symbols between two interpretations, we obtain the revision operator of (Dalal, 1988).", "startOffset": 194, "endOffset": 207}, {"referenceID": 28, "context": "This appears to make sense, because by updating by b \u2228m we are really telling the knowledge base that the world has changed so that one of b \u2227m or b \u2227 \u00acm or \u00acb \u2227m is true. Thus, in this case the update operator behaves like the Gricean belief change operator of Delgrande, Nayak, and Pagnucco (2005), where the goal is to incorporate all and only the new information.", "startOffset": 73, "endOffset": 300}, {"referenceID": 2, "context": "Borgida (1985) employed a similar definition with respect to a revision operator.", "startOffset": 0, "endOffset": 15}, {"referenceID": 17, "context": "Our update operator satisfies those postulates deemed desirable by Herzig and Rifi (1999), with the exception of U4.", "startOffset": 67, "endOffset": 90}, {"referenceID": 5, "context": "\u03c8)) (Brown, 1990).", "startOffset": 4, "endOffset": 17}, {"referenceID": 11, "context": "The idea is quite similar to that of (Doherty et al., 1998).", "startOffset": 37, "endOffset": 59}, {"referenceID": 5, "context": "As proposed by Brown (1990), an eliminant \u2203P.", "startOffset": 15, "endOffset": 28}, {"referenceID": 18, "context": "To this end, we need to introduce so-called advice-taking Turing machine (TM) and non-uniform complexity class, see (Johnson, 1990).", "startOffset": 116, "endOffset": 131}], "year": 2008, "abstractText": "In this paper we explore a class of belief update operators, in which the definition of the operator is compositional with respect to the sentence to be added. The goal is to provide an update operator that is intuitive, in that its definition is based on a recursive decomposition of the update sentence\u2019s structure, and that may be reasonably implemented. In addressing update, we first provide a definition phrased in terms of the models of a knowledge base. While this operator satisfies a core group of the benchmark Katsuno-Mendelzon update postulates, not all of the postulates are satisfied. Other Katsuno-Mendelzon postulates can be obtained by suitably restricting the syntactic form of the sentence for update, as we show. In restricting the syntactic form of the sentence for update, we also obtain a hierarchy of update operators with Winslett\u2019s standard semantics as the most basic interesting approach captured. We subsequently give an algorithm which captures this approach; in the general case the algorithm is exponential, but with some not-unreasonable assumptions we obtain an algorithm that is linear in the size of the knowledge base. Hence the resulting approach has much better complexity characteristics than other operators in some situations. We also explore other compositional belief change operators: erasure is developed as a dual operator to update; we show that a forget operator is definable in terms of update; and we give a definition of the compositional revision operator. We obtain that compositional revision, under the most natural definition, yields the Satoh revision operator.", "creator": "dvips(k) 5.96 Copyright 2005 Radical Eye Software"}}}