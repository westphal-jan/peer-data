{"id": "1401.3484", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Modularity Aspects of Disjunctive Stable Models", "abstract": "Practically all programming languages allow the programmer to split a program into several modules which brings along several advantages in software development. In this paper, we are interested in the area of answer-set programming where fully declarative and nonmonotonic languages are applied. In this context, obtaining a modular structure for programs is by no means straightforward since the output of an entire program cannot in general be composed from the output of its components. To better understand the effects of disjunctive information on modularity we restrict the scope of analysis to the case of disjunctive logic programs (DLPs) subject to stable-model semantics. We define the notion of a DLP-function, where a well-defined input/output interface is provided, and establish a novel module theorem which indicates the compositionality of stable-model semantics for DLP-functions. The module theorem extends the well-known splitting-set theorem and enables the decomposition of DLP-functions given their strongly connected components based on positive dependencies induced by rules. In this setting, it is also possible to split shared disjunctive rules among components using a generalized shifting technique. The concept of modular equivalence is introduced for the mutual comparison of DLP-functions using a generalization of a translation-based verification method. Our approach allows us to use a generalization of DLP-functions using a generalization of a translation-based verification method to specify that the translation-based verification method is compatible with a DLP-programmer's implementation. In the discussion of this topic we will also discuss the idea of a DLP-programmer's implementation with respect to the equivalence theorem, DLP-functions, and the common definition of non-monotonic and non-monotonic languages: (1) Functional language. This terminology describes the concept of the DLP-function in terms of a DLP-programmer's implementation and the generalization of a translation-based verification method. In this paper we propose the concept of a DLP-programmer's implementation with respect to the equivalence theorem, DLP-functions, and the common definition of non-monotonic and non-monotonic languages.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Wed, 15 Jan 2014 05:36:41 GMT  (492kb)", "http://arxiv.org/abs/1401.3484v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["tomi janhunen", "emilia oikarinen", "hans tompits", "stefan woltran"], "accepted": false, "id": "1401.3484"}, "pdf": {"name": "1401.3484.pdf", "metadata": {"source": "CRF", "title": "Modularity Aspects of Disjunctive Stable Models", "authors": ["Tomi Janhunen", "Emilia Oikarinen", "Hans Tompits", "Stefan Woltran"], "emails": ["Tomi.Janhunen@tkk.fi", "Emilia.Oikarinen@tkk.fi", "tompits@kr.tuwien.ac.at", "woltran@dbai.tuwien.ac.at"], "sections": [{"heading": "1. Introduction", "text": "Practically all programming languages used in software development allow the programmer to split a program into several modules which interact through well-defined input/output interfaces. Given this, the entire program can be viewed as a composition of its component modules which are typically linked together in the respective run-time environment. The expected benefits of modular program development are manifold. First, it imposes a good programming style to be followed by the programmer. A complex software system is much easier to develop as a set of interacting components rather than a monolithic program. Second, a modular architecture allows for additional flexibility as regards delegating programming tasks amongst a team of programmers. In this setting, the goal of each programmer is to implement desired input/output behavior(s) in terms of concrete module(s) which together implement the software system being developed. Third, modular program\nc\u00a92009 AI Access Foundation. All rights reserved.\ndesign can also be exploited in order to boost the execution of programs. Program optimization is also facilitated by structural information encompassed by module interfaces.\nAnswer-set programming (ASP) (Marek & Truszczy\u0144ski, 1999; Niemel\u00e4, 1999; Gelfond & Leone, 2002) is a paradigm for declarative problem solving in which solutions of problems are described in terms of rules subject to a nonmonotonic semantics based on stable models (Gelfond & Lifschitz, 1988). In typical problem representations, a tight correspondence between solutions and stable models is sought for, and default negation is fully exploited in order to obtain concise encodings of relations involved in such problem descriptions. Furthermore, recursive definitions enable, e.g., the representation of closures of relations in a very natural way. Due to efficient implementations and emerging applications, the paradigm has received increasing attention during the past two decades.1 In the meantime, a number of extensions\u2014such as disjunctions, weight constraints, and aggregates\u2014have been proposed to the basic syntax of normal logic programs. In this paper, we concentrate on the class of disjunctive logic programs (DLPs) which is appropriate for solving search problems residing up to the second level of the polynomial-time hierarchy. The semantical account of DLPs is based on the respective generalization of stable-model semantics (Gelfond & Lifschitz, 1991).\nIn this paper, our goal is to investigate modularity in the context of DLPs and stablemodel semantics. Since stable models are defined only over complete programs, they do not lend themselves to modular programming prima facie. Perhaps for this reason, the concept of a module has not yet raised too much attention in the realm of answer-set programming. Except for a few dedicated papers (Gaifman & Shapiro, 1989; Eiter, Gottlob, & Veith, 1997b; Baral, Dzifcak, & Takahashi, 2006), modules mostly appeared as a by-product in studies of formal properties like stratification, splitting, or, more lately, in work on equivalence relations between programs (Lifschitz & Turner, 1994; Eiter, Gottlob, & Mannila, 1997a; Eiter, Ianni, Lukasiewicz, Schindlauer, & Tompits, 2008). In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs. The main result is a module theorem which links stable models associated with individual modules to those of their composition. Such a result is significant as it indicates that stable models are compositional in very much the same sense as classical models are in propositional logic. The only major restriction implied by the module theorem is that the definition of any set of positively interdependent atoms must be given within the same module.\nBesides the general benefits of modular program development discussed above, we are also looking for potential computational advantages of modularizing reasoning tasks in ASP. In this context, the search for stable models is probably the most central reasoning task. Results like the module theorem discussed above provide the basis for modularizing the search task. Extra care, however, is required because the computation of stable models for modules in separation is not necessarily efficient. More sophisticated methods, such as identifying cones of influence in Boolean circuits (Junttila & Niemel\u00e4, 2000), can be devised to identify modules which are relevant for the search of stable models\u2014the rest is only used to expand a qualified stable model to one for the entire program. This strategy alleviates the treatment of extremely large program instances and it is also amenable to query evaluation.\n1. The 20th anniversary of stable-model semantics was celebrated at ICLP\u201908 which was held in Udine, Italy, in December 2008.\nUnfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b).\nThere are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving. The idea is to gradually extend a program instance in terms of additional modules, e.g., when solving AI planning problems. Moreover, theoretical results like the splitting-set theorem (Lifschitz & Turner, 1994) and the module theorem can be directly exploited in correctness proofs. For instance, it is proved by Oikarinen and Janhunen (2008b) that the models of a prioritized circumscription can be captured with disjunctive stable models using a particular translation. A similar proof strategy is adopted in Theorem 8.5 of this paper.\nWe anticipate that compositional semantics can also prove useful if one tries to boost the search for stable models via parallelization, e.g., by computing stable models for modules in parallel. However, in order to avoid excessive communication costs, extra caution is needed when stable models computed in separation are linked together and potentially rejected. One possibility is to identify mutually independent modules as the basis for distribution. Besides this aspect, modularization may also lead to novel methods for the (non-parallelized) computation of stable models, other than the traditional ones.\nStructure and Preview of Results In this paper, we concentrate on the formal underpinnings of modular programming in the context of disjunctive logic programs under stable-model semantics. We proceed as follows. Our first goal is to generalize the theory developed for normal programs and smodels programs (Oikarinen & Janhunen, 2008a) to the case of disjunctive programs. To this end, we first introduce the notion of a DLPfunction in Section 2. The term goes back to Gelfond and Gabaldon (1999) who introduced LP-functions as (partial) definitions of new relations in terms of old, known ones. To enable such a functional view of disjunctive programs, they are endowed with a well-defined input/output interface. The idea is to partition the signature of a program encapsulated in this way into input atoms, output atoms, and hidden (or local) atoms. These distinctions provide the basis for the systematic composition of larger disjunctive logic programs out of program modules. However, arbitrary combinations of program modules are not meaningful and, first of all, we adopt syntactic restrictions introduced by Gaifman and Shapiro (1989) from the context of negation/disjunction-free logic programs. The interplay of default negation and disjunctions brings along new factors which lead to a relaxation of the restrictions in the sense that program modules are allowed to share rules. Then, having the basic syntactic issues of DLP-functions laid out, we concentrate on their semantics in Section 3. In this respect, we follow a strict model-theoretic approach and, in particular,\naddress the role of input atoms when it comes to viewing DLP-functions as mathematical functions. We proceed step by step and assign three different classes of models to each DLP-function, viz. classical models, minimal models, and stable models. The last provides an appropriate generalization of disjunctive stable models (Gelfond & Lifschitz, 1991) in the presence of input atoms.\nOur second objective is to establish the adequacy of the concept of a DLP-function in view of a compositional semantics. This will be witnessed by the main result of the paper, viz. the module theorem which shows how stable models of a DLP-function, \u03a0, can be alternatively obtained as unions of compatible stable models for the modules constituting \u03a0. The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs\u2014neither involving default negation nor disjunctions. As observed by them, too, syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models.2 In the current paper, we strive for analogous results but in the case of programs permitting both default negation and disjunctions. It turns out that strongly connected components of positive dependency graphs provide a key criterion when it comes to confining program composition. The compositionality properties of disjunctive programs under stable-model semantics have also arisen in the context of the so-called splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). In fact, the module theorem established herein is a proper generalization of its predecessor (Oikarinen & Janhunen, 2008a). We illustrate the potential of our modular architecture by the evaluation of quantified Boolean formulas (QBFs), which serve as canonical representatives of the classes of the polynomial-time hierarchy (PH). Due to basic complexity results established by Eiter and Gottlob (1995), it is natural from our perspective to concentrate on the second level of the PH in the case of disjunctive programs.\nThe third aim of this paper is to have a look at some particular applications of the module theorem in disjunctive logic programming. In Section 6, we take an opposite view to the modular construction of DLP-functions and consider possibilities for their decomposition even in the absence of any other structural information. It turns out that strongly connected components can also be exploited in this respect but, in addition, the occurrences of hidden atoms must be taken into account when splitting a DLP-function into its components. As demonstrated in Section 7, our results open new prospects as regards unwinding disjunctions using the principle of shifting (Gelfond, Przymusinska, Lifschitz, & Truszczy\u0144ski, 1991; Dix, Gottlob, & Marek, 1996; Eiter, Fink, Tompits, & Woltran, 2004). A proper generalization of this principle that partially covers also programs involving head-cycles is formulated and proved correct. Moreover, due to the modular nature of DLP-functions, it makes perfect sense to compare them as modules. The notion of modular equivalence is introduced for this purpose in Section 8. Interestingly, modular equivalence supports substitutions of equivalent programs and it also lends itself for translation-based verification as put forth by Oikarinen\n2. The main concern of Gaifman and Shapiro (1989) is modularity with respect to the logical consequences of a definite program and hence the intersection of its Herbrand models.\nand Janhunen (2004, 2009) in the related cases of ordinary equivalence and smodels programs. Section 9 contrasts our approach with related work. Finally, Section 10 provides a brief summary of results and concludes this paper."}, {"heading": "2. The Class of DLP-Functions", "text": "The topic of this section is the syntax of DLP-functions as well as syntactic restrictions imposed on composition of DLP-functions. A disjunctive rule is an expression of the form\na1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 an \u2190 b1, . . . , bm,\u223cc1, . . . ,\u223cck, (1)\nwhere n,m, k \u2265 0, and a1, . . . , an, b1, . . . , bm, and c1, . . . , ck are propositional atoms. Since the order of atoms is considered insignificant, we write A \u2190 B,\u223cC as a shorthand for rules of form (1), where A = {a1, . . . , an}, B = {b1, . . . , bm}, and C = {c1, . . . , ck} are the respective sets of atoms. The basic intuition behind a rule A \u2190 B,\u223cC is that if each atom in the positive body B can be inferred and none of the atoms in the negative body C, then some atom in the head A can be inferred. When both B and C are empty, we have a disjunctive fact, written A \u2190. If A is empty, then we have a constraint, written \u22a5 \u2190 B,\u223cC.\nA disjunctive logic program (DLP) is conventionally formed as a finite set of disjunctive rules. Additionally, we want a distinguished input and output interface for each DLP. To this end, we extend a definition originally proposed by Gaifman and Shapiro (1989) to the case of disjunctive programs.3 It is natural that such an interface imposes certain restrictions on the rules allowed in a module. Given a set R of disjunctive rules, we write At(R) for the signature of R, i.e., the set of (ground) atoms effectively appearing in the rules of R.\nDefinition 2.1 A DLP-function, \u03a0, is a quadruple \u3008R, I,O,H\u3009, where I, O, and H are pairwise distinct sets of input atoms, output atoms, and hidden atoms, respectively, and R is a DLP such that for each rule A \u2190 B,\u223cC \u2208 R,\n1. A \u222aB \u222a C \u2286 I \u222aO \u222aH, and\n2. if A 6= \u2205, then A \u2229 (O \u222aH) 6= \u2205.\nA DLP-function \u03a0 = \u3008R, I,O,H\u3009 is occasionally identified with R and, by a slight abuse of notation, we write A \u2190 B,\u223cC \u2208 \u03a0 to denote A \u2190 B,\u223cC \u2208 R. By the first condition of Definition 2.1, the rules in a DLP-function \u03a0 must obey the interface specification of \u03a0, i.e., At(R) \u2286 I \u222a O \u222aH. As regards the sets of atoms I, O, and H involved in the module interface, the atoms in I \u222a O are considered to be visible and hence accessible to other DLP-functions conjoined with \u03a0; either to produce input for \u03a0 or to utilize the output of \u03a0. On the other hand, the hidden atoms in H are used to formalize some auxiliary concepts of \u03a0 which may not make sense in the context of other DLP-functions but may save space substantially as demonstrated, e.g., by Janhunen and Oikarinen (2007, Example 4.5). The second condition of Definition 2.1 is concerned with the set of atoms O \u222aH defined by the rules of R. The principle is that each non-empty disjunctive head must involve at least one atom from O \u222a H. This is just to ensure that a DLP-function \u03a0 must not interfere with\n3. Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).\nthe definitions of its input atoms I in terms of rules A \u2190 B,\u223cC satisfying A \u2286 I. But otherwise, the rules of \u03a0 may be conditioned by input atoms.4 Given a set S of atoms, we distinguish the set of rules that define the atoms of S in R, i.e., the set of defining rules\nDefR(S) = {A \u2190 B,\u223cC \u2208 R | A \u2229 S 6= \u2205}. (2)\nOur next objective is to specify the conditions on which the composition of DLP-functions may take place. Roughly speaking, the idea is that larger DLP-functions can be formed in a modular fashion using smaller DLP-functions as components. As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs. Thus, program union as operator for composition without further restrictions is not satisfactory with respect to compositionality.\nWe start by adapting the construction of Gaifman and Shapiro (1989) to the case of disjunctive programs.\nDefinition 2.2 Two DLP-functions \u03a01 = \u3008R1, I1, O1, H1\u3009 and \u03a02 = \u3008R2, I2, O2, H2\u3009 respect the input/output interfaces of each other if and only if\n1. (I1 \u222aO1 \u222aH1) \u2229H2 = \u2205,\n2. (I2 \u222aO2 \u222aH2) \u2229H1 = \u2205,\n3. O1 \u2229O2 = \u2205,\n4. DefR1(O1) = DefR1\u222aR2(O1), and\n5. DefR2(O2) = DefR1\u222aR2(O2).\nThe first three of the conditions above are due to Gaifman and Shapiro (1989) and they imply that the sets O1, H1, O2, and H1 are mutually pairwise distinct. Violations with respect to the first two conditions can be circumvented by a renaming strategy. For instance, if an atom a \u2208 H1 appears in I2 \u222aO2 \u222aH2, hence violating the second condition, it is possible to replace all occurrences of a in \u03a01 by a new atom a\n\u2032 6\u2208 I2 \u222a O2 \u222a H2 not appearing in \u03a02. This removes the conflict with respect to a and so forth. 5\nOn the other hand, the last two conditions of Definition 2.2 concern the distribution of rules involved in the definitions (2) of sets of atoms O1 and O2, i.e., the sets of rules DefR1(O1) and DefR2(O2), in R1 and R2, respectively. As regards disjunctive rules, the principle is that these sets of defining rules must remain intact when the union R1 \u222a R2 is formed which means that each module is supposed to have copies of all rules that form the definition of its output atoms. In spite of this, two modules \u03a01 and \u03a02 subject to the conditions of Definition 2.2 may effectively share disjunctive rules A \u2190 B,\u223cC with a non-empty head A such that A \u2229O1 6= \u2205 and A \u2229O2 6= \u2205, as to be demonstrated next.\n4. In particular, input atoms in the head A of a rule act very much like atoms in the negative body \u223cC. 5. An opposite view to program composition is considered in Section 6, where possibilities for decompos-\ning a disjunctive program into smaller DLP-functions are studied. As a counterpart to renaming, a revealing operator introduced in Definition 7.3 can be used for circumventing the first two conditions in Definition 2.2.\nExample 2.3 Consider the following two DLP-functions:6\n{b}\na \u2228 b \u2190 c; d \u2190 a,\u223cd\n{a, c}\nand\n{a}\na \u2228 b \u2190 c; e \u2190 a,\u223ce\n{b, c}\nMore formally, we have \u03a01 = \u3008R1, {a, c}, {b}, {d}\u3009 and \u03a02 = \u3008R2, {b, c}, {a}, {e}\u3009 such that R1 \u2229 R2 = {a \u2228 b \u2190 c}. We show that \u03a01 and \u03a02 respect the input/output interfaces of each other: First, both hidden atoms d and e occur in exactly one of the two programs and thus the first two conditions in Definition 2.2 are satisfied. Second, we have disjoint output atoms, viz. atom b in \u03a01 and atom a in \u03a02. Finally, we have DefR1({b}) = DefR1\u222aR2({b}) = DefR2({a}) = DefR1\u222aR2({a}) = {a \u2228 b \u2190 c}, which shows that also the final two conditions in Definition 2.2 are satisfied, and as far as syntax is concerned, it makes sense to compose a larger DLP-function which is obtained as a kind of a union of \u03a01 and \u03a02; see (4) below.\nIn contrast to disjunctive programs, shared rules do not arise in the context of normal logic programs since only one head atom is allowed in each rule. The same can be stated about smodels programs (Simons, Niemel\u00e4, & Soininen, 2002) although such programs may contain, among other rule types, choice rules of the form\n{a1, . . . , an} \u2190 B,\u223cC (3)\nwith heads of cardinality greater than one. As observed by Oikarinen and Janhunen (2008a), the heads of choice rules possessing multiple atoms can be freely split without affecting their semantics. When splitting such rules into n different rules {ai} \u2190 B,\u223cC where 1 \u2264 i \u2264 n, the only concern is the creation of n copies of the rule body B,\u223cC which could reserve a quadratic space in the worst case. A new atom can be introduced to circumvent this. But the nature of proper disjunctive rules (1), the subject of study in this paper, is somewhat different. Unlike choice rules, disjunctive rules may interact through rule heads. In Example 2.3, the definition of a depends on b and vice versa. However, given a choice rule {a, b} \u2190 c for instance, the choices regarding a and b are independent of each other: if c is true, both atoms can have any truth value. This is quite different from the interpretation of a\u2228b \u2190 c which makes either a or b true given that c is true. To grasp the interaction of a and b it is natural to have b as an input to the definition of a and, conversely, a as input to that of b. As to be demonstrated in Section 7, shared rules can be rewritten so that input atoms are removed from the rule head but as a drawback of the rewriting technique, the compactness of the representation is partly lost. Therefore, we appreciate the extra flexibility provided by shared rules and interpret them to reflect the true nature of disjunctive rules.\nIn general, DLP-functions are composed according to the following principle:\n6. Here and henceforth we make use of a tabular format to represent DLP-functions: the output signature is given on the top, the input signature at the bottom, and the rules are listed in between. Thus, the declaration of the hidden signature remains implicit.\nDefinition 2.4 (Composition) Let \u03a01 = \u3008R1, I1, O1, H1\u3009 and \u03a02 = \u3008R2, I2, O2, H2\u3009 be two DLP-functions that respect the input/output interfaces of each other. Then, the composition of \u03a01 and \u03a02 is defined and determined by\n\u03a01 \u2295\u03a02 = \u3008R1 \u222aR2, (I1 \\O2) \u222a (I2 \\O1), O1 \u222aO2, H1 \u222aH2\u3009. (4)\nThe treatment of atom types under Definitions 2.2 and 2.4 is summarized in Figure 1. The two symmetric figures on the left-hand side illustrate the signatures of DLP-functions \u03a01 = \u3008R1, I1, O1, H1\u3009 and \u03a02 = \u3008R2, I2, O2, H2\u3009 subject to composition. Input signatures and output signatures are emphasized by light gray and dark gray shadings, respectively. The superposition of the two figures yields the diagram given on the right which represents the resulting nine categories of atoms. Only three of them may involve shared atoms that originate from both\u03a01 and\u03a02. The interface conditions introduced above should be intuitive to readers acquainted with the principles of object-oriented programming:\n1. Although \u03a01 and \u03a02 must not share hidden atoms, they may share input atoms, i.e., I1\u2229I2 6= \u2205 is allowed. Output atoms are treated differently as O1\u2229O2 = \u2205 is assumed.\n2. An input atom of \u03a01 becomes an output atom in \u03a01 \u2295 \u03a02 if it appears as an output atom in \u03a02, i.e., \u03a02 provides the input for \u03a01 in this setting. The input atoms of \u03a02 are treated in a symmetric fashion.\n3. The hidden atoms of \u03a01 and \u03a02 retain their status in \u03a01 \u2295\u03a02.\nExample 2.5 Recall Example 2.3 in which we showed that DLP-functions \u03a01 and \u03a02 respect the input/output interfaces of each other. Thus, the composition of \u03a01 and \u03a02 is defined, and \u03a01\u2295\u03a02 is \u3008R1 \u222aR2, I, O,H\u3009 where the set I of input atoms is ({a, c}\\{a})\u222a({b, c}\\{b}) = {c}, the set O of output atoms is {a} \u222a {b} = {a, b}, and the set H of hidden atoms is {d} \u222a {e} = {d, e}, i.e., using our tabular format to represent modules, we have\n{b}\na \u2228 b \u2190 c; d \u2190 a,\u223cd\n{a, c}\n\u2295\n{a}\na \u2228 b \u2190 c; e \u2190 a,\u223ce\n{b, c}\n=\n{a, b}\na \u2228 b \u2190 c; d \u2190 a,\u223cd; e \u2190 a,\u223ce\n{c}\nThe definitions of a and b in \u03a01 \u2295 \u03a02 share the rule a \u2228 b \u2190 c. Thanks to the flexibility of Definition 2.4, we are also able to split \u03a01 \u2295\u03a02 into its components whenever appropriate.\nFollowing previous approaches (Gelfond & Gabaldon, 1999; Oikarinen & Janhunen, 2008a), we define the signature At(\u03a0) of a DLP-function \u03a0 = \u3008R, I,O,H\u3009 as I \u222a O \u222aH.7 For notational convenience, we distinguish the visible and hidden parts of At(\u03a0) by setting Atv(\u03a0) = I \u222a O and Ath(\u03a0) = H = At(\u03a0) \\ Atv(\u03a0), respectively. Moreover, Ati(\u03a0) and Ato(\u03a0) are used to refer to the sets of input and output atoms of \u03a0, respectively. These notations provide us a way to access the module interface when it is left implicit, e.g., to neglect the internal structure of modules. Lastly, for any set S \u2286 At(\u03a0) of atoms, we denote the projections of S on Ati(\u03a0), Ato(\u03a0), Atv(\u03a0), and Ath(\u03a0) by Si, So, Sv, and Sh, respectively.\nIn formal terms, a DLP-function \u03a0 = \u3008R, I,O,H\u3009 is designed to provide a mapping from subsets of I to a set of subsets of O \u222a H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored. In the sequel, the (syntactic) class of DLP-functions is denoted by D. It is assumed, for the sake of simplicity, that D spans over a fixed (at most denumerable) signature At(D)8 so that At(\u03a0) \u2286 At(D) holds for each DLP-function \u03a0 \u2208 D. Given DLP-functions \u03a01, \u03a02, and \u03a03 that pairwise respect the input/output interfaces of each other, it holds that\n\u2022 \u03a01 \u2295\u03a02 \u2208 D (closure),\n\u2022 \u03a01 \u2295\u2205 = \u2205\u2295\u03a01 = \u03a01, for the empty DLP-function \u2205 = \u3008\u2205, \u2205, \u2205, \u2205\u3009 (identity),\n\u2022 \u03a01 \u2295\u03a02 = \u03a02 \u2295\u03a01 (commutativity), and\n\u2022 \u03a01 \u2295 (\u03a02 \u2295\u03a03) = (\u03a01 \u2295\u03a02)\u2295\u03a03 (associativity).\nThe theory of modules put forth by Oikarinen and Janhunen (2008a) is based on a more restrictive operator for program composition, viz. the join \u2294. The idea behind this operator is to forbid positive dependencies between programs which is to be explicated next.\nTechnically speaking, we define the positive dependency graph DG+(\u03a0) of a DLP-function \u03a0 = \u3008R, I,O,H\u3009 using only positive dependencies\u2014following the definition by Ben-Eliyahu and Dechter (1994). However, we exclude input atoms from the graph as their definitions are external to \u03a0 anyway. Thus, we let DG+(\u03a0) = \u3008O \u222aH,\u22641\u3009 where b \u22641 a holds for a pair of atoms a, b \u2208 O \u222aH if and only if there is a rule A \u2190 B,\u223cC \u2208 R such that a \u2208 A and b \u2208 B. The reflexive and transitive closure of \u22641 gives rise to the dependency relation \u2264 over Ato(\u03a0)\u222aAth(\u03a0). A strongly connected component (SCC) S of the graph DG\n+(\u03a0) is a maximal set S \u2286 Ato(\u03a0)\u222aAth(\u03a0) such that b \u2264 a for every pair a, b \u2208 S of atoms. Given that \u03a01 \u2295 \u03a02 is defined, we say that \u03a01 and \u03a02 are mutually dependent iff DG\n+(\u03a01 \u2295 \u03a02) has an SCC S such that S \u2229 Ato(\u03a01) 6= \u2205 and S \u2229 Ato(\u03a02) 6= \u2205 (Oikarinen & Janhunen, 2008a), i.e., the component S is shared by the DLP-functions \u03a01 and \u03a02 in this way. If \u03a01 and \u03a02 are not mutually dependent, we also call them mutually independent.\nDefinition 2.6 (Joins) Given two DLP-functions \u03a01 and \u03a02, if the composition \u03a01 \u2295 \u03a02 is defined and \u03a01 and \u03a02 are mutually independent, then the join, \u03a01 \u2294 \u03a02, of \u03a01 and \u03a02 is defined and it coincides with \u03a01 \u2295\u03a02.\n7. Consequently, the length of \u03a0 in symbols, denoted by \u2016\u03a0\u2016, gives an upper bound for |At(\u03a0)| which is important when one considers the computational cost of translating programs (Janhunen, 2006). 8. In practice, this set could be the set of all identifiers (names for propositions or similar objects).\nIn case that \u03a01 \u2294 \u03a02 is defined, and thus \u03a01 and \u03a02 are mutually independent, exactly one of the following conditions holds for each SCC S of DG+(\u03a01 \u2295\u03a02):\nS \u2286 Ato(\u03a01) \u222aAth(\u03a01); or (5)\nS \u2286 Ato(\u03a02) \u222aAth(\u03a02). (6)\nExample 2.7 Recall the programs \u03a01 and \u03a02 from Example 2.5 for which we obtain the positive dependency graph DG+(\u03a01\u2295\u03a02) = \u3008{a, b, d, e}, {\u3008a, d\u3009, \u3008a, e\u3009}\u3009. Hence, the SCCs of the graph are simply singletons {a}, {b}, {d}, and {e}. Together with the observation that Ato(\u03a01) and Ato(\u03a02) are disjoint, we derive that \u03a01 and \u03a02 are not mutually dependent. Thus, the join \u03a01 \u2294\u03a02 = \u03a01\u2295\u03a02 is defined since the composition \u03a01\u2295\u03a02 is defined on the basis of the analysis performed in Example 2.5.\nExample 2.8 As an example of two DLP-functions which have their composition defined yet which are ineligible for a join, consider the following situation:\n{b}\na \u2228 b \u2190 c; b \u2190 a,\u223cc\n{a, c}\n\u2295\n{a}\na \u2228 b \u2190 c; a \u2190 b,\u223cc\n{b, c}\n=\n{a, b}\na \u2228 b \u2190 c; a \u2190 b,\u223cc; b \u2190 a,\u223cc\n{c}\nHere, the result of composition involves an SCC S = {a, b} in the respective positive dependency graph, which has a non-empty intersection with the output signatures of the programs subject to composition. Hence, the respective join of the modules in question is not defined."}, {"heading": "3. Model Theory and Stable-Model Semantics", "text": "Having the syntax of DLP-functions defined, we now turn to their semantics. We proceed in three steps and introduce, correspondingly, three kinds of models, viz. classical models, minimal models, and, finally, stable models for each DLP-function. The last provide the intended semantics for a DLP-function whereas the first two serve as auxiliary concepts.\nAs usual, an interpretation for a DLP-function \u03a0 is defined as an arbitrary subset of At(\u03a0). Given a particular interpretation M \u2286 At(\u03a0), an atom a \u2208 At(\u03a0) is true under M , denoted M |= a, iff a \u2208 M , otherwise a is false under M , denoted M 6|= a. For a negative literal \u223ca, we define M |= \u223ca iff M 6|= a. A set L of literals is satisfied by M , denoted by M |= L, iff M |= l, for every literal l \u2208 L. We also define the disjunctive interpretation \u2228\nL of a set L of literals: M |= \u2228\nL iff M |= l for some literal l \u2208 L. To begin with, we cover DLP-functions with a pure classical semantics, which treats disjunctive rules as classical implications. It should be emphasized that classical models of a DLP-function \u03a0 are specific interpretations as defined above and hence subsets of At(\u03a0).\nDefinition 3.1 An interpretation M \u2286 At(\u03a0) is a (classical) model of a DLP-function \u03a0 = \u3008R, I,O,H\u3009, denoted M |= \u03a0, iff M |= R, i.e., for every rule A \u2190 B,\u223cC \u2208 R,\nM |= B \u222a \u223cC implies M |= \u2228 A.\nThe set of all classical models of \u03a0 is denoted by CM(\u03a0).\nClassical models provide an appropriate level of abstraction to address the role of input atoms in DLP-functions. Given a DLP-function \u03a0 and an interpretation M \u2286 At(\u03a0), the projection Mi can be viewed as the actual input for \u03a0 which may (or may not) produce the respective output Mo, depending on the semantics assigned to \u03a0. The treatment of input atoms in the sequel will be based on partial evaluation: the idea is to pre-interpret input atoms appearing in \u03a0 with respect to Mi.\nDefinition 3.2 For a DLP-function \u03a0 = \u3008R, I,O,H\u3009 and an actual input Mi \u2286 I for \u03a0, the instantiation of \u03a0 with respect to Mi, denoted by \u03a0/Mi, is the quadruple \u3008R\n\u2032, \u2205, O,H\u3009 where R\u2032 contains a reduced rule\n(A \\ I) \u2190 (B \\ I),\u223c(C \\ I) (7)\nfor each rule A \u2190 B,\u223cC \u2208 R such that Mi |= \u223cAi \u222aBi \u222a \u223cCi.\nExample 3.3 Consider the following DLP-function \u03a0:\n{a, b}\na \u2228 b \u2190 \u223cc; a \u2190 c,\u223cb; b \u2190 c,\u223ca\n{c}\nFor the actual input {c} \u2286 Ati(\u03a0), the reduct \u03a0/{c} is the DLP-function\n\u3008{a \u2190 \u223cb; b \u2190 \u223ca}, \u2205, {a, b}, \u2205\u3009.\nOn the other hand, with the actual input \u2205 \u2286 Ati(\u03a0), we obtain the reduct\n\u03a0/\u2205 = \u3008{a \u2228 b}, \u2205, {a, b}, \u2205\u3009.\nThe rules of form (7) are free of input atoms which indicates that the reduct \u03a0/Mi is a DLP-function without input. Atoms in Ato(\u03a0) \u222aAth(\u03a0) are not affected in \u03a0/Mi.\nProposition 3.4 Let \u03a0 be a DLP-function and M \u2286 At(\u03a0) an interpretation that defines an actual input Mi \u2286 Ati(\u03a0) for \u03a0. For all interpretations N \u2286 At(\u03a0) such that Ni = Mi,\nN |= \u03a0 \u21d0\u21d2 No \u222aNh |= \u03a0/Mi.\nProof. Consider any N \u2286 At(\u03a0) such that Ni = Mi. (=\u21d2) Suppose that N |= \u03a0. Assume that No \u222a Nh does not satisfy (7) for some rule A \u2190 B,\u223cC in \u03a0. It follows that Mi |= \u223cAi \u222aBi \u222a\u223cCi, and therefore Ni |= \u223cAi \u222aBi \u222a\u223cCi. Thus, N 6|= A \u2190 B,\u223cC, a contradiction. It follows that No \u222aNh |= \u03a0/Mi.\n(\u21d0=) Let No \u222a Nh |= \u03a0/Mi hold. Assuming N 6|= A \u2190 B,\u223cC for a rule of \u03a0 implies N |= B \u222a \u223cC and N 6|= \u2228\nA. It follows that Ni |= \u223cAi \u222a Bi \u222a \u223cCi and the corresponding rule (7) is included in \u03a0/Mi as Ni = Mi. But this rule is not satisfied by No \u222a Nh since\nN 6|= A \u2190 B,\u223cC implies No \u222a Nh |= (B \\ I) \u222a \u223c(C \\ I) and No \u222a Nh 6|= \u2228\n(A \\ I), a contradiction. Hence, we have that N |= \u03a0.\nThus, the input reduction, as given in Definition 3.2, is fully compatible with classical semantics and we can characterize the semantic operator CM also in terms of the equation\nCM(\u03a0) = \u22c3\nMi\u2286Ati(\u03a0)\n{Mi \u222aN | N \u2208 CM(\u03a0/Mi)}. (8)\nRecall that the models of any DLP-function \u03a0 are subsets of At(\u03a0). Hence, we have here that each N \u2208 CM(\u03a0/Mi) is a subset of At(\u03a0/Mi) and thusMi\u2229N = \u2205 for eachMi \u2286 Ati(\u03a0) since no atom from Ati(\u03a0) occurs in \u03a0/Mi by definition.\nHandling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them. The rough idea is to keep the interpretation of input atoms fixed while minimizing (i.e., falsifying) others as far as possible.\nDefinition 3.5 Let \u03a0 = \u3008R, I,O,H\u3009 be a DLP-function. A model M \u2286 At(\u03a0) of \u03a0 is I-minimal iff there is no model N of \u03a0 such that Ni = Mi and N \u2282 M .\nIn the sequel, the set of I-minimal models of \u03a0 = \u3008R, I,O,H\u3009 is denoted by MM(\u03a0) and we treat input atoms by stipulating I-minimality of models. Using this idea, Proposition 3.4 lifts for minimal models given the fact that Ati(\u03a0/Mi) = \u2205.\nProposition 3.6 Let \u03a0 be a DLP-function and M \u2286 At(\u03a0) an interpretation that defines an actual input Mi \u2286 Ati(\u03a0) for \u03a0. For all interpretations N \u2286 At(\u03a0) such that Ni = Mi,\nN \u2208 MM(\u03a0) \u21d0\u21d2 No \u222aNh \u2208 MM(\u03a0/Mi).\nProof. Consider any N \u2286 At(\u03a0) such that Ni = Mi. (=\u21d2) Let N \u2208 MM(\u03a0). It follows by Proposition 3.4 that No \u222a Nh |= \u03a0/Mi. Assume that No \u222a Nh /\u2208 MM(\u03a0/Mi). Recall that Ati(\u03a0/Mi) = \u2205. Thus, there is an interpretation S \u2282 No \u222a Nh such that S |= \u03a0/Mi. It follows by Proposition 3.4 that N\n\u2032 |= \u03a0 for an interpretation N \u2032 = Mi\u222aS. But then N \u2032 i = Ni and N\n\u2032 \u2282 N jointly contradict N \u2208 MM(\u03a0). (\u21d0=) Suppose that No \u222aNh \u2208 MM(\u03a0/Mi). So, No \u222aNh |= \u03a0/Mi, and N |= \u03a0 follows by Proposition 3.4. Let us then assume that N 6\u2208 MM(\u03a0), i.e., there is a model N \u2032 |= \u03a0 with N \u2032i = Ni and N \u2032 \u2282 N . Thus, we have (N \u2032o \u222aN \u2032 h) \u2282 (No \u222aNh), and since N \u2032 i = Ni = Mi it follows that N \u2032o \u222aN \u2032 h |= \u03a0/Mi by Proposition 3.4. Then, however, N \u2032 o \u222aN \u2032 h |= \u03a0/Mi is in contradiction with No \u222aNh \u2208 MM(\u03a0/Mi). The set MM(\u03a0) of Ati(\u03a0)-minimal models is sufficient to determine the semantics of a positive DLP-function \u03a0, i.e., whose rules are of the form A \u2190 B. Recall that for such rules A \\ Ati(\u03a0) 6= \u2205 holds whenever A 6= \u2205. In order to cover arbitrary DLP-functions, we interpret negative body literals in the way proposed by Gelfond and Lifschitz (1991).\nDefinition 3.7 Given a DLP-function \u03a0 = \u3008R, I,O,H\u3009 and an interpretation M \u2286 At(\u03a0), the reduct of \u03a0 with respect to M is the positive DLP-function \u03a0M = \u3008RM , I, O,H\u3009 where\nRM = {A \u2190 B | A \u2190 B,\u223cC \u2208 R and M |= \u223cC}. (9)\nDefinition 3.8 An interpretation M \u2286 At(\u03a0) is a stable model of a DLP-function \u03a0 with an input signature Ati(\u03a0) iff M \u2208 MM(\u03a0 M ), i.e., M is an Ati(\u03a0)-minimal model of \u03a0 M .\nHidden atoms play no special role in Definition 3.8. In contrast to this, they will affect possibilities for program decomposition, as to be presented in Section 6, and their status will be finally explicated when the notion of modular equivalence is introduced in Section 8. Definition 3.8 covers also the case of an ordinary disjunctive logic program, which is simply a DLP-function \u03a0 = \u3008R, \u2205, O, \u2205\u3009: a model M \u2286 At(\u03a0) = O of \u03a0 is stable iff M is a minimal model of RM . The definition of stable models gives rise to a semantic operator SM : D \u2192 22 At(D) for DLP-functions:\nSM(\u03a0) = {M \u2286 At(\u03a0) | M \u2208 MM(\u03a0M )}. (10)\nProposition 3.6 provides us a way to dismiss Ati(\u03a0)-minimality in the definition of stable models if desirable. Given a stable model M of \u03a0, the projection N = Mo\u222aMh is a minimal model of (\u03a0/Mi) N and hence a stable model of \u03a0/Mi. In other words, we have\n(\u03a0/Mi) M = (\u03a0/Mi) Mo\u222aMh = \u03a0M/Mi.\nThus, we can derive the following result:\nCorollary 3.9 For any DLP-function \u03a0, we have\nSM(\u03a0) = {M \u2286 At(\u03a0) | Mo \u222aMh \u2208 SM(\u03a0/Mi)}.\nExample 3.10 Recall the DLP-function \u03a0 from Example 3.3, having no hidden atoms, given as follows:\n{a, b}\na \u2228 b \u2190 \u223cc; a \u2190 c,\u223cb; b \u2190 c,\u223ca\n{c}\n\u03a0 has four stable models in total: M1 = {a}, M2 = {b}, M3 = {a, c}, and M4 = {b, c}, which are the {c}-minimal models of the respective reducts of \u03a0:\n\u03a0M1 = \u3008{a \u2228 b \u2190; a \u2190 c}, {c}, {a, b}, \u2205\u3009, \u03a0M2 = \u3008{a \u2228 b \u2190; b \u2190 c}, {c}, {a, b}, \u2205\u3009, \u03a0M3 = \u3008{a \u2190 c}, {c}, {a, b}, \u2205\u3009, and \u03a0M4 = \u3008{b \u2190 c}, {c}, {a, b}, \u2205\u3009.\nNow, it is easy to verify that each Mj is a {c}-minimal model of the reduct \u03a0 Mj .\nFor illustrating Corollary 3.9, recall the reducts\n\u03a0/{c} = \u3008{a \u2190 \u223cb; b \u2190 \u223ca}, \u2205, {a, b}, \u2205\u3009 and \u03a0/\u2205 = \u3008{a \u2228 b}, \u2205, {a, b}, \u2205\u3009.\nThen, we have that SM(\u03a0/{c}) = {{a}, {b}} and SM(\u03a0/\u2205) = {{a}, {b}}.\nAn immediate observation is that we loose the general antichain property of stable models when input signatures are introduced. For instance, we haveM1 \u2282 M3 andM2 \u2282 M4 in Example 3.10. However, since the interpretation of input atoms is fixed by the semantics, we perceive antichains locally, i.e., the set {N \u2208 SM(\u03a0) | Ni = Mi} of stable models forms an antichain, for each input Mi \u2286 Ati(\u03a0). In Example 3.10, the sets of stable models associated with actual inputs \u2205 and {c} are {M1,M2} and {M3,M4}, respectively."}, {"heading": "4. Characterizations using Classical Logic", "text": "It is well known how the set of stable models of an ordinary disjunctive logic program, i.e., a DLP-function \u03a0 of the form \u3008R, \u2205, O, \u2205\u3009, can be characterized via classical propositional logic, using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003). In this section, we generalize these concepts to arbitrary DLP-functions. To this end, the main concern is the role of input atoms and how to incorporate them into these concepts. Furthermore, we extend the tightness property of programs (Erdem & Lifschitz, 2003) to DLP-functions by introducing the notion of I-tightness in Section 4.2."}, {"heading": "4.1 Program Completion and Loop Formulas", "text": "Given a DLP-function \u03a0, a loop of \u03a0 is any non-empty subset of a strongly connected component of the positive dependency graph DG+(\u03a0). Recall that DG+(\u03a0) has only the atoms of Ato(\u03a0)\u222aAth(\u03a0) as its nodes. In particular, each singleton {a} with a \u2208 Ato(\u03a0)\u222a Ath(\u03a0) is thus a loop.\nExample 4.1 Consider DLP-functions \u03a01 and \u03a02 defined as follows:\n\u03a01:\n{b, c}\na \u2228 c \u2190 b; b \u2190 a\n{a}\n\u03a02:\n{a, b}\na \u2228 c \u2190 b; b \u2190 a\n{c}\nHere, \u03a01 has only singleton loops {b} and {c}. In particular, {a, b} is not a loop as it contains the input atom a. On the other hand, for \u03a02 we have loops {a}, {b}, and {a, b}.\nIn what follows, we use, for a set S of propositional formulas (or atoms), \u00acS to denote a conjunction \u2227\ns\u2208S \u00acs and \u2228 S as a shorthand for \u2228\ns\u2208S s. Moreover, if appearing within a formula, a set S is implicitly understood as a conjunction of its elements. For a DLP-function \u03a0 and an atom a \u2208 Ato(\u03a0) \u222aAth(\u03a0), we define the set of supporting formulas\nSuppF(a,\u03a0) = {B \u2227 \u00acC \u2227 \u00ac(A \\ {a}) | A \u2190 B,\u223cC \u2208 \u03a0 and a \u2208 A}\nand for a loop L \u2286 Ato(\u03a0) \u222aAth(\u03a0) of \u03a0, the set of externally supporting formulas\nESuppF(L,\u03a0) = {B \u2227 \u00acC \u2227 \u00ac(A \\ L) | A \u2190 B,\u223cC \u2208 \u03a0, A \u2229 L 6= \u2205, and B \u2229 L = \u2205}.\nClark\u2019s completion procedure and (conjunctive) loop formulas can be generalized for DLPfunctions in the following way:\nDefinition 4.2 For a DLP-function \u03a0, the completion of \u03a0 is the set of formulas\nComp(\u03a0) = {B \u2227 \u00acC \u2192 \u2228\nA | A \u2190 B,\u223cC \u2208 \u03a0} \u222a {a \u2192 \u2228\nSuppF(a,\u03a0) | a \u2208 Ato(\u03a0) \u222aAth(\u03a0)}\nand the set of loop formulas for \u03a0 is\nLF(\u03a0) = {L \u2192 \u2228 ESuppF(L,\u03a0) | L \u2286 Ato(\u03a0) \u222aAth(\u03a0) is a loop of \u03a0}. 9\nObserve that in the case of Ati(\u03a0) = \u2205, i.e., Ato(\u03a0) \u222a Ath(\u03a0) = At(\u03a0), the completion Comp(\u03a0) reduces to the definition provided by Lee and Lifschitz (2003) and the same holds for the set LF(\u03a0) of loop formulas. Generally speaking, the propositional theories Comp(\u03a0) and LF(\u03a0) characterize the set SM(\u03a0) of stable models in the following sense:\nTheorem 4.3 For a DLP-function \u03a0 and an interpretation M \u2286 At(\u03a0),"}, {"heading": "M \u2208 SM(\u03a0) if and only if M |= Comp(\u03a0) and M |= LF(\u03a0).", "text": "Proof. We first relate the sets SuppF(a,\u03a0) and ESuppF(L,\u03a0), as introduced above for a DLP-function \u03a0, with the respective sets of complementary rules\nSuppCR(a,\u03a0) = {A \\ {a} \u2190 B,\u223cC | A \u2190 B,\u223cC \u2208 \u03a0 and a \u2208 A} and ESuppCR(L,\u03a0) = {A \\ L \u2190 B,\u223cC | A \u2190 B,\u223cC \u2208 \u03a0, A \u2229 L 6= \u2205, and B \u2229 L = \u2205}.\nFirst, it is straightforward that, for each interpretation M \u2286 At(\u03a0), we have M |= Comp(\u03a0) iff jointly M |= \u03a0 and for each a \u2208 M \u2229 (Ato(\u03a0) \u222a Ath(\u03a0)), M 6|= SuppCR(a,\u03a0). Quite similarly, it holds that M |= LF(\u03a0) iff, for each loop L \u2286 M \u2229 (Ato(\u03a0) \u222a Ath(\u03a0)) of \u03a0, M 6|= ESuppCR(L,\u03a0). On the other hand, by viewing SuppCR(a,\u03a0) and ESuppCR(L,\u03a0) as DLP-functions having the same signatures as \u03a0, we can apply Proposition 3.4 in order to evaluate input atoms. Thus, we obtain the following relationships for each DLP-function \u03a0, interpretation M \u2286 At(\u03a0), atom a \u2208 Ato(\u03a0) \u222a Ath(\u03a0), and loop L \u2286 Ato(\u03a0) \u222a Ath(\u03a0) of \u03a0:\n1. M |= \u03a0 iff Mo \u222aMh |= \u03a0/Mi,\n2. M |= SuppCR(a,\u03a0) iff Mo \u222aMh |= SuppCR(a,\u03a0/Mi), and\n3. M |= ESuppCR(L,\u03a0) iff Mo \u222aMh |= ESuppCR(L,\u03a0/Mi).\nFinally, recall that for each interpretation M \u2286 At(\u03a0), we have Ato(\u03a0) = Ato(\u03a0/Mi) and Ath(\u03a0) = Ath(\u03a0/Mi). Inspecting the definition of Comp(\u03a0) and LF(\u03a0) again, we can conclude for each interpretation M \u2286 At(\u03a0) that M |= Comp(\u03a0) \u222a LF(\u03a0) iff Mo \u222aMh |= Comp(\u03a0/Mi)\u222aLF(\u03a0/Mi). In turn, we know that Mo \u222aMh |= Comp(\u03a0/Mi)\u222aLF(\u03a0/Mi) iff Mo \u222aMh is a stable model of the program \u03a0/Mi by the results of Lee and Lifschitz (2003); recall that \u03a0/Mi is an ordinary disjunctive program without any input atoms. Finally, we have SM(\u03a0) = {M \u2286 At(\u03a0) | Mo \u222aMh \u2208 SM(\u03a0/Mi)} by Corollary 3.9. This equality shows the claim.\nExample 4.4 Let us demonstrate the functioning of program completion and loop formulas on the DLP-functions from Example 4.1, i.e., on \u03a01 = \u3008R, {a}, {b, c}, \u2205\u3009 and \u03a02 = \u3008R, {c}, {a, b}, \u2205\u3009, where R = {a \u2228 c \u2190 b; b \u2190 a}. The completions are\n9. Although it may seem that the case of a singleton loop L = {a} is somewhat redundant, this is not so, since some tautological rules such as a \u2228 b \u2190 a make a difference.\nComp(\u03a01) = {b \u2192 a \u2228 c, a \u2192 b} \u222a {b \u2192 a, c \u2192 b \u2227 \u00aca} and Comp(\u03a02) = {b \u2192 a \u2228 c, a \u2192 b} \u222a {b \u2192 a, a \u2192 b \u2227 \u00acc}.\nFurthermore, the sets of loop formulas are\nLF(\u03a01) = {b \u2192 \u2228 ESuppF({b},\u03a01), c \u2192 \u2228\nESuppF({c},\u03a01)} = {b \u2192 a, c \u2192 b \u2227 \u00aca} and\nLF(\u03a02) = {b \u2192 \u2228 ESuppF({b},\u03a02), a \u2192 \u2228\nESuppF({a},\u03a02), a \u2227 b \u2192 \u2228\nESuppF({a, b},\u03a02)} = {b \u2192 a, a \u2192 b \u2227 \u00acc, a \u2227 b \u2192 \u22a5}.\nIn the last formula, the occurrence of \u22a5 is in view of ESuppF({a, b},\u03a02) = \u2205, which yields an empty disjunction \u2228\nESuppF({a, b},\u03a02) = \u22a5 as usual. Computing the classical models of Comp(\u03a01) \u222a LF(\u03a01) = Comp(\u03a01) yields two such models, M1 = {a, b} and M2 = \u2205. One can check that these are indeed the stable models of \u03a01 by recalling that Ati(\u03a01) = {a}. Thus, M1 relates to an actual input M1\u2229Ati(\u03a01) = {a} whereas M2 is based on M2 \u2229 Ati(\u03a01) = \u2205. On the other hand, the classical models of Comp(\u03a02) \u222a LF(\u03a02) are M1 = {c} and M2 = \u2205, which again relate to the two possible inputs over Ati(\u03a02) = {c}. Finally, we note that {a, b} is also a model of Comp(\u03a02) but ruled out by LF(\u03a02)."}, {"heading": "4.2 Tight DLP-functions", "text": "We now extend the well-known concept of tightness (Erdem & Lifschitz, 2003) to DLPfunctions. This is of interest since we can exploit the fact that the positive dependency graph DG+(\u03a0) is reduced modulo input atoms. In other words, since the dependency graph DG+(\u03a0) has only the atoms of Ato(\u03a0) \u222a Ath(\u03a0) as its nodes, tightness for DLP-functions can be defined with respect to the input signature.\nIn the beginning of Section 4, loops were defined as arbitrary non-empty subsets of strongly connected components in DG+(\u03a0). Thus, if DG+(\u03a0) is acyclic then \u03a0 has only singleton loops. However, the converse is not necessarily true, since, for a program \u03a0 having only singleton loops, DG+(\u03a0) may have edges \u3008a, a\u3009, i.e., cycles of length one.\nDefinition 4.5 A DLP-function \u03a0 is Ati(\u03a0)-tight (or tight, for short), if the positive dependency graph DG+(\u03a0) is acyclic.\nExample 4.6 Recall DLP-functions \u03a01 = \u3008R, {a}, {b, c}, \u2205\u3009 and \u03a02 = \u3008R, {c}, {a, b}, \u2205\u3009 based on R = {a \u2228 c \u2190 b; b \u2190 a} from Example 4.1. Here, \u03a01 is {a}-tight since the potential non-singleton loop {a, b} contains the input atom a. On the other hand, \u03a02 is not {c}-tight. It is worth mentioning that the \u201cordinary\u201d variant of \u03a01, viz. DLP-function \u3008R, \u2205, {a, b, c}, \u2205\u3009, is not \u2205-tight\u2014in particular, since R is not tight in the usual sense.\nWe note that the last observation, viz. that a DLP-function \u3008R, I,O,H\u3009 may be I-tight although R is not a tight program, relies on the use of disjunctions in the program. In fact, for DLP-functions \u3008R, I,O,H\u3009, where R is a set of normal rules of the form a \u2190 B,\u223cC, we have that a DLP-function \u03a0 = \u3008R, I,O,H\u3009 is I-tight iff R is tight. To verify this, note that the second item of Definition 2.1 implies that the head atom of a normal rule a \u2190 B,\u223cC must not appear in I, and thus no loop of \u03a0 may involve atoms from I.\nWe now show that the notion of tightness introduced in Definition 4.5 enables us to characterize the stable models of a DLP-function by the classical models of its completion. Since each \u201cordinary\u201d program can be represented as a DLP-function, we thus properly generalize the well-known completion semantics (Clark, 1978). The following lemma is already sufficient for this result in view of Definition 4.2 and Theorem 4.3.\nLemma 4.7 For any tight DLP-function \u03a0, LF(\u03a0) \u2286 Comp(\u03a0).\nProof. Recall that for each a \u2208 Ato(\u03a0) \u222a Ath(\u03a0), a \u2192 \u2228\nSuppF(a,\u03a0) is contained in Comp(\u03a0). Moreover, since \u03a0 is tight, \u03a0 has only singleton loops, and thus LF(\u03a0) contains only formulas a \u2192 \u2228\nESuppF({a},\u03a0), again for each a \u2208 Ato(\u03a0) \u222a Ath(\u03a0). It remains to show that, for each atom a, SuppF(a,\u03a0) is equivalent to ESuppF({a},\u03a0) whenever the positive dependency graph DG+(\u03a0) is acyclic. We repeat the definition of SuppF(a,\u03a0) and give the definition for ESuppF(L,\u03a0), simplified for the case L = {a}:\nSuppF(a,\u03a0) = {B \u2227 \u00acC \u2227 \u00ac(A \\ {a}) | A \u2190 B,\u223cC \u2208 \u03a0 and a \u2208 A}; ESuppF({a},\u03a0) = {B \u2227 \u00acC \u2227 \u00ac(A \\ {a}) | A \u2190 B,\u223cC \u2208 \u03a0, a \u2208 A, and B \u2229 {a} = \u2205}.\nNow it is easy to see that for an acyclic dependency graphDG+(\u03a0), a \u2208 A impliesB\u2229{a} = \u2205 for every rule A \u2190 B,\u223cC \u2208 \u03a0. Thus, we conclude that SuppF(a,\u03a0) = ESuppF({a},\u03a0) holds for each a \u2208 Ato(\u03a0) \u222aAth(\u03a0). Hence, the claim follows.\nExample 4.8 Recalling the DLP-function \u03a01 = \u3008R, {a}, {b, c}, \u2205\u3009 from Example 4.4 with R = {a \u2228 c \u2190 b; b \u2190 a}, we obtain\nComp(\u03a01) = {b \u2192 a \u2228 c, a \u2192 b} \u222a {b \u2192 a, c \u2192 b \u2227 \u00aca} and LF(\u03a01) = {b \u2192 \u2228 ESuppF({b},\u03a01), c \u2192 \u2228\nESuppF({c},\u03a01)} = {b \u2192 a, c \u2192 b \u2227 \u00aca}.\nNow, \u03a01 is tight and we observe that LF(\u03a01) \u2286 Comp(\u03a01) as expected.\nThe observations presented so far lead us to the following result:\nTheorem 4.9 For a tight DLP-function \u03a0 and an interpretation M \u2286 At(\u03a0),"}, {"heading": "M \u2208 SM(\u03a0) if and only if M |= Comp(\u03a0).", "text": "In particular, this result is compatible with an existing characterization of stable models in the case of Ati(\u03a0) = \u2205, i.e., if Ato(\u03a0) \u222a Ath(\u03a0) = At(\u03a0). Then, the notion of Ati(\u03a0)tightness coincides with ordinary tightness, and the definition of the completion Comp(\u03a0) reduces to the one provided by Lee and Lifschitz (2003)."}, {"heading": "5. Compositional Semantics", "text": "In what follows, our objective is to establish the main result of this paper, i.e., to show that stable-model semantics, as given by Definition 3.8, is fully compositional when larger DLP-functions \u03a0 are formed as joins \u03a01 \u2294 . . . \u2294 \u03a0n of DLP-functions. More precisely, the interconnection of SM(\u03a0) and SM(\u03a01), . . . ,SM(\u03a0n) is explicated in Section 5.1. In analogy\nto Section 3, we follow a quite rigorous approach and consider such a relationship for classical models first, then for minimal models, and eventually cover the case of stable models which comprises our module theorem. Then, in Section 5.2, we use quantified Boolean formulas from the second level of polynomial hierarchy and their modular representation in terms of DLP-functions to illustrate the module theorem. Finally, we devote Section 5.3 to a comparison with the splitting set theorem proven by Lifschitz and Turner (1994)."}, {"heading": "5.1 Module Theorem", "text": "To begin with, we formalize the criteria for combining interpretations as well as models.\nDefinition 5.1 Given two DLP-functions \u03a01 and \u03a02, interpretations M1 \u2286 At(\u03a01) and M2 \u2286 At(\u03a02) are mutually compatible (with respect to \u03a01 and \u03a02), or just compatible, if\nM1 \u2229Atv(\u03a02) = M2 \u2229Atv(\u03a01). (11)\nAccording to (11), any two compatible interpretations M1 and M2 for \u03a01 and \u03a02, respectively, agree about the truth values of their joint visible atoms in Atv(\u03a01)\u2229Atv(\u03a02). A quick inspection of Figure 1 reveals the three cases that may arise when the join \u03a0 = \u03a01\u2294\u03a02 is defined and joint output atoms for \u03a01 and \u03a02 are thereafter disallowed: There may exist\n1. joint input atoms in Ati(\u03a0) = Ati(\u03a01) \u2229Ati(\u03a02), or\n2. atoms in Ato(\u03a01) \u2229Ati(\u03a02) that are output atoms in \u03a01 and input atoms in \u03a02, or\n3. by symmetry, atoms in Ati(\u03a01) \u2229Ato(\u03a02).\nRecall that according to Definition 2.6, atoms in the last two categories end up in Ato(\u03a0) when \u03a0 = \u03a01 \u2294 \u03a02 is formed. Atoms in Atv(\u03a01) \u2229 Atv(\u03a02) provide the basis to combine compatible interpretations for \u03a01 and \u03a02.\nDefinition 5.2 Let \u03a01 and \u03a02 be two DLP-functions such that \u03a0 = \u03a01 \u2294 \u03a02 is defined. Given any sets of interpretations A1 \u2286 2 At(\u03a01) and A2 \u2286 2 At(\u03a02), the natural join of A1 and A2 with respect to Atv(\u03a01) \u2229Atv(\u03a02), denoted by A1 \u22ca\u22c9 A2, is the set of interpretations\nA1 \u22ca\u22c9 A2 = {M1 \u222aM2 | M1 \u2208 A1, M2 \u2208 A2, and M1 and M2 are compatible}. (12)\nOur first modularity result is formulated for DLP-functions under classical semantics as defined in Section 3. The combination of classical models is understood as in (12).\nProposition 5.3 For all positive DLP-functions \u03a01 and \u03a02 such that \u03a01 \u2295\u03a02 is defined,\nCM(\u03a01 \u2295\u03a02) = CM(\u03a01) \u22ca\u22c9 CM(\u03a02). (13)\nProof. Consider an interpretationM \u2286 At(\u03a01\u2295\u03a02) and its projectionsM1 = M\u2229At(\u03a01) and M2 = M \u2229 At(\u03a02) with respect to \u03a01 = \u3008R1, I1, O1, H1\u3009 and \u03a02 = \u3008R2, I2, O2, H2\u3009. It follows that M1 and M2 are compatible and M = M1 \u222aM2 so that\nM \u2208 CM(\u03a01 \u2295\u03a02) \u21d0\u21d2 M |= R1 \u222aR2 \u21d0\u21d2 M1 |= R1 and M2 |= R2 \u21d0\u21d2 M1 \u2208 CM(\u03a01) and M2 \u2208 CM(\u03a02) \u21d0\u21d2 M \u2208 CM(\u03a01) \u22ca\u22c9 CM(\u03a02).\nGeneralizing Proposition 5.3 for stable models of DLP-functions is much more elaborate. We will cover the case of positive DLP-functions under minimal models first. The proof of Theorem 5.5 exploits program completion, loop formulas, as well as the characterization of stable and minimal models from Section 4 as follows:\nLemma 5.4 For all DLP-functions \u03a01 and \u03a02 such that \u03a01 \u2294 \u03a02 is defined, the following conditions hold:\nComp(\u03a01 \u2294\u03a02) = Comp(\u03a01) \u222a Comp(\u03a02); (14)\nLF(\u03a01 \u2294\u03a02) = LF(\u03a01) \u222a LF(\u03a02). (15)\nProof. We begin the proof by analyzing how formulas introduced by Clark\u2019s completion and loop formulas are related with joins of DLP-functions. To this end, we will now establish that the sets of formulas associated with \u03a01 \u2294 \u03a02 are directly obtained as unions of sets of formulas associated with \u03a01 = \u3008R1, I1, O1, H1\u3009 and \u03a02 = \u3008R2, I2, O2, H2\u3009: First, an implication B\u2227\u00acC \u2192 \u2228\nA belongs to Comp(\u03a01\u222a\u03a02) if and only if it belongs to Comp(\u03a01), Comp(\u03a02), or both in case of a shared rule. Second, let us consider any atom a \u2208 O \u222aH, where O = O1 \u222aO2 and H = H1 \u222aH2 are disjoint because \u03a01 \u2294\u03a02 is defined. For the same reason, either a \u2208 O1\u222aH1 or a \u2208 O2\u222aH2, i.e., the atom a is defined either by \u03a01 or \u03a02. Thus, we have either DefR1(a) = DefR1\u222aR2(a) or DefR2(a) = DefR1\u222aR2(a) by Definition 2.2, which implies that either SuppF(a,\u03a01\u2294\u03a02) = SuppF(a,\u03a01) or SuppF(a,\u03a01\u2294\u03a02) = SuppF(a,\u03a02). It follows that the implication a \u2192 \u2228\nSuppF(a,\u03a01 \u2294 \u03a02) is a member of Comp(\u03a01 \u2294 \u03a02) if and only if either (i) a \u2192 \u2228 SuppF(a,\u03a01) belongs to Comp(\u03a01) or (ii) a \u2192 \u2228\nSuppF(a,\u03a02) belongs to Comp(\u03a02). Thus, we may conclude (14) for the completions involved.\nThird, recall that each loop L \u2286 At(\u03a01 \u2294\u03a02) of \u03a01 \u2294\u03a02 is contained in some SCC S of \u03a01 \u2294\u03a02. It follows by (5), (6), and Definition 2.2 that either\n1. L \u2286 O1 \u222aH1 is a loop of \u03a01 and DefR1(L) = DefR1\u222aR2(L), or\n2. L \u2286 O2 \u222aH2 is a loop of \u03a02 and DefR2(L) = DefR1\u222aR2(L).\nIn the cases above, we have either ESuppF(L,\u03a01\u2294\u03a02) = ESuppF(L,\u03a01) or ESuppF(L,\u03a01\u2294 \u03a02) = ESuppF(L,\u03a02). Thus, the respective loop formula L \u2192 \u2228\nESuppF(L,\u03a01 \u2294 \u03a02) belongs to LF(\u03a01 \u2294\u03a02) if and only if it is contained in LF(\u03a01) \u222a LF(\u03a02).\nTheorem 5.5 For all positive DLP-functions \u03a01 and \u03a02 such that \u03a01 \u2294\u03a02 is defined,\nMM(\u03a01 \u2294\u03a02) = MM(\u03a01) \u22ca\u22c9 MM(\u03a02). (16)\nProof. Consider any M \u2286 At(\u03a01\u2294\u03a02) and the respective projections M1 = M \u2229At(\u03a01) and M2 = M \u2229At(\u03a02) which are compatible and, moreover, M = M1 \u222aM2. We obtain the following chain of equivalences:\nM \u2208 MM(\u03a01 \u2294\u03a02) \u21d0\u21d2 M |= Comp(\u03a01 \u2294\u03a02) and M |= LF(\u03a01 \u2294\u03a02) [Theorem 4.3]\n\u21d0\u21d2\n{\nM1 |= Comp(\u03a01) and M1 |= LF(\u03a01) M2 |= Comp(\u03a02) and M2 |= LF(\u03a02)\n[(14) and (15)]\n\u21d0\u21d2 M1 \u2208 MM(\u03a01) and M2 \u2208 MM(\u03a02) [Theorem 4.3] \u21d0\u21d2 M \u2208 MM(\u03a01) \u22ca\u22c9 MM(\u03a02). [Definition 5.2]\nExample 5.6 Let us demonstrate the result of Theorem 5.5 in a practical setting using DLPfunctions \u03a01 and \u03a02 as visualized below and their composition \u03a0 = \u3008R, \u2205, {a, b, c, d, e}, \u2205\u3009.\n\u03a01 :\n{a, b, c} a \u2228 b \u2190; a \u2190 b; b \u2190 a; a \u2190 c;\nc \u2228 d \u2228 e \u2190 a, b\n{d, e}\n\u03a02 :\n{d, e} d \u2190 c; e \u2190 d; d \u2190 e;\nc \u2228 d \u2228 e \u2190 a, b\n{a, b, c}\nThe join \u03a01 \u2294 \u03a02 is defined because the SCCs of the composition \u03a0 are S1 = {a, b, c} and S2 = {d, e}. The Ati(\u03a01)-minimal models of \u03a01 are {a, b, c}, {a, b, d}, {a, b, e}, and {a, b, d, e}. Likewise, calculating MM(\u03a02), we get\nMM(\u03a02) = {\u2205, {a}, {b}, {c, d, e}, {a, b, d, e}, {a, c, d, e}, {b, c, d, e}, {a, b, c, d, e}}.\nHence, the only minimal model of \u03a0 is M = {a, b, d, e} and the compatibility condition underlying (16) correctly excludes N = {a, b, c, d, e} 6\u2208 MM(\u03a0). Note that there is no support to c being true in \u03a01 when d and e are true. Accordingly, c \u2228 d \u2228 e \u2190 a, b is not active.\nWe are now prepared to present our central result:\nTheorem 5.7 (Module Theorem) For all DLP-functions \u03a01 and \u03a02 such that \u03a01 \u2294 \u03a02 is defined,\nSM(\u03a01 \u2294\u03a02) = SM(\u03a01) \u22ca\u22c9 SM(\u03a02). (17)\nProof. Again, we take an interpretation M \u2286 At(\u03a01\u2294\u03a02) and the respective compatible projections M1 = M \u2229At(\u03a01) and M2 = M \u2229At(\u03a02) into consideration. The proof of (17) can be based on (16) once a number of preliminary facts has been established:\n1. The composition \u03a0M11 \u2295\u03a0 M2 2 is defined.\nSince \u03a01 \u2294\u03a02 is defined, we know that \u03a01\u2295\u03a02 is defined. This indicates that \u03a01 and \u03a02 respect the input/output interfaces of each other. The construction of \u03a0 M1 1 and \u03a0M22 does not affect this property which implies that \u03a0 M1 1 \u2295\u03a0 M2 2 is defined.\n2. The join \u03a0M11 \u2294\u03a0 M2 2 is defined.\nBy the preceding item, the positive dependency graph DG+(\u03a0M11 \u2295 \u03a0 M2 2 ) is defined. Let us assume that \u03a0M11 and \u03a0 M2 2 are mutually dependent, i.e., there is an SCC S of the graph above such that S \u2229 Ato(\u03a0 M1 1 ) 6= \u2205 and S \u2229 Ato(\u03a0 M2 2 ) 6= \u2205. Since the dependency graph has potentially fewer dependencies than the respective graph\nDG+(\u03a01\u2295\u03a02) for \u03a01 and \u03a02, it follows that S is contained in some SCC S \u2032 of the latter. Since Ato(\u03a0 M1 1 ) = Ato(\u03a01) and Ato(\u03a0 M2 2 ) = Ato(\u03a02), we obtain S\n\u2032\u2229Ato(\u03a01) 6= \u2205 and S\u2032 \u2229Ato(\u03a02) 6= \u2205. Thus, \u03a01 and \u03a02 are mutually dependent, a contradiction.\n3. The reduct (\u03a01 \u2294\u03a02) M coincides with \u03a0M11 \u2294\u03a0 M2 2 .\nA rule A \u2190 B belongs to (\u03a01 \u2294\u03a02) M if and only if there is a rule A \u2190 B,\u223cC in \u03a01, \u03a02, or both such that C \u2229M = \u2205. Equivalently, there is a rule A \u2190 B,\u223cC in \u03a01 such that C \u2229 M1 = \u2205, or there is a rule A \u2190 B,\u223cC in \u03a02 such that C \u2229 M2 = \u2205, i.e., A \u2190 B \u2208 \u03a0M11 or A \u2190 B \u2208 \u03a0 M2 2 .\nWe therefore get the following chain of equivalences:\nM \u2208 SM(\u03a01 \u2294\u03a02) \u21d0\u21d2 M \u2208 MM((\u03a01 \u2294\u03a02) M ) [Definition 3.8]\n\u21d0\u21d2 M \u2208 MM(\u03a0M11 \u2294\u03a0 M2 2 ) [Item 3 above] \u21d0\u21d2 M \u2208 MM(\u03a0M11 ) \u22ca\u22c9 MM(\u03a0 M2 2 ) [Theorem 5.5] \u21d0\u21d2 M1 \u2208 MM(\u03a0 M1 1 ) and M2 \u2208 MM(\u03a0 M2 2 ) [Definition 5.2] \u21d0\u21d2 M1 \u2208 SM(\u03a01) and M2 \u2208 SM(\u03a02) [Definition 3.8] \u21d0\u21d2 M \u2208 SM(\u03a01) \u22ca\u22c9 SM(\u03a02). [Definition 5.2]\nThe moral of Theorem 5.7 and Definition 2.6 is that stable semantics supports modularization as long as positively interdependent atoms are enforced in the same module.\nExample 5.8 Let \u03a01 and \u03a02 be DLP-functions as defined below and \u03a0 = \u03a01 \u2294 \u03a02 their join (which is clearly defined):\n{b}\na \u2228 b \u2190; b \u2228 c \u2190\n{a, c}\n\u2294\n{c}\na \u2228 c \u2190; b \u2228 c \u2190\n{a, b}\n=\n{b, c}\na \u2228 b \u2190; a \u2228 c \u2190; b \u2228 c \u2190\n{a}\nIt is straightforward to verify that SM(\u03a01) = {{b}, {a, b}, {a, c}, {b, c}} and SM(\u03a02) = {{c}, {a, b}, {a, c}, {b, c}}. Since Atv(\u03a01) \u2229Atv(\u03a02) = {a, b, c}, we obtain\nSM(\u03a01) \u22ca\u22c9 SM(\u03a02) = SM(\u03a01) \u2229 SM(\u03a02) = {{a, b}, {a, c}, {b, c}}.\nA simple cross-check confirms that SM(\u03a0) is indeed given by this set.\nExample 5.9 Consider the DLP-functions \u03a01 and \u03a02 from Example 2.8. Then, SM(\u03a01) = {\u2205, {a, b}, {b, c}} and SM(\u03a02) = {\u2205, {a, b}, {a, c}}. As shown in Example 2.8, the join of \u03a01 and \u03a02 is undefined. Thus, Theorem 5.7 is not applicable. Concerning the composition \u03a01 \u2295\u03a02, we note that SM(\u03a01 \u2295\u03a02) = {\u2205, {a, c}, {b, c}} 6= {\u2205, {a, b}} = SM(\u03a01) \u22ca\u22c9 SM(\u03a02).\nTheorem 5.7 can be easily extended for DLP-functions consisting of more than two modules. In view of this, we say that a finite sequence M1, . . . ,Mn of stable models for modules \u03a01, . . . ,\u03a0n, respectively, is compatible, iff Mi and Mj are pairwise compatible, for all 1 \u2264 i, j \u2264 n. This property guarantees that each Mi can be recovered from the union M =\n\u22c3n i=1Mi by taking the respective projection M \u2229At(\u03a0i) = Mi.\nCorollary 5.10 Let \u03a01, . . . ,\u03a0n be a sequence of DLP-functions such that the join \u03a01\u2294\u00b7 \u00b7 \u00b7\u2294 \u03a0n is defined. Then,\nSM(\u03a01 \u2294 \u00b7 \u00b7 \u00b7 \u2294\u03a0n) = SM(\u03a01) \u22ca\u22c9 \u00b7 \u00b7 \u00b7 \u22ca\u22c9 SM(\u03a0n). (18)\nExample 5.11 The following example simply extends Example 5.8:\n{b}\na \u2228 b \u2190; b \u2228 c \u2190\n{a, c}\n\u2294\n{c}\na \u2228 c \u2190; b \u2228 c \u2190\n{a, b}\n\u2294\n{a}\na \u2228 b \u2190; a \u2228 c \u2190\n{b, c}\n=\n{a, b, c} a \u2228 b \u2190; a \u2228 c \u2190; b \u2228 c \u2190\n\u2205\nNow we have SM(\u03a01) = {{b}, {a, b}, {a, c}, {b, c}}, SM(\u03a02) = {{c}, {a, b}, {a, c}, {b, c}}, and SM(\u03a03) = {{a}, {a, b}, {a, c}, {b, c}}. Thus, we learn from Corollary 5.10 that\nSM(\u03a01 \u2294\u03a02 \u2294\u03a03) = SM(\u03a01) \u22ca\u22c9 SM(\u03a02) \u22ca\u22c9 SM(\u03a03) = {{a, b}, {a, c}, {b, c}}."}, {"heading": "5.2 Modular Representation of Quantified Boolean Formulas", "text": "Our next objective is to illustrate the theory developed so far in terms of a more extensive example. To this end, we consider the pair of DLP-functions \u03a0satn and \u03a0 unsat n as depicted in Figure 2. Their purpose is the evaluation of quantified Boolean formulas (QBFs) of the form\n\u2203X\u2200Y n \u2228\ni=1\n(\u00acAi \u2227Bi \u2227 \u00acCi \u2227Di), (19)\nwhere each Aj , Bj , Cj , and Dj is a set of Boolean variables, and the parameter n gives the number of disjuncts in the matrix which is a Boolean formula \u03c6 in disjunctive normal form (DNF).10 Without loss of generality, we may assume that X =\n\u22c3n i=1(Ai \u222a Bi), Y =\n\u22c3n i=1(Ci \u222aDi), and X \u2229 Y = \u2205 hold for the sets X and Y of Boolean variables in (19). It is important to point out that in general the evaluation of QBFs of the form (19) constitutes a \u03a3p2-complete decision problem which perfectly matches the complexity of checking the existence of stable models for a disjunctive program. Given this completeness property, it follows that in principle any decision problem in \u03a3p2 can be turned into a QBF of the form (19), albeit more direct representations can be obtained for particular problem domains. In this respect, let us address three specific domains prior to detailing the generic approach.\n1. The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques. The simplified encoding provided by Koch, Leone, and Pfeifer (2003) is based on two kinds of disjunctive rules:\nstrat(x1) \u2228 strat(x2) \u2228 strat(x3) \u2228 strat(x4) \u2190 prod(y, x1, x2, x3, x4), (20)\nstrat(x) \u2190 ctrl(x, x1, x2, x3, x4), strat(x1), strat(x2), strat(x3), strat(x4), (21)\n10. Also, recall the shorthands \u00acS = V\ns\u2208S \u00acs and S =\nV\ns\u2208S s introduced right after Example 4.1.\nFunction \u03a0satn : X\nFor 1 \u2264 i \u2264 n and x \u2208 Ai: \u2190 x, act(i); For 1 \u2264 i \u2264 n and x \u2208 Bi: x \u2190 act(i);\nFor 1 \u2264 i \u2264 n: Ai \u2190 Bi,\u223cact(i)\n{act(1), . . . , act(n)}\nFunction \u03a0unsatn : \u2205\nFor 1 \u2264 i \u2264 n: Ci \u222a {u} \u2190 Di, act(i); For y \u2208 Y : y \u2190 u;\nu \u2190 \u223cu\n{act(1), . . . , act(n)}\ncertificates. The required DLPs can be worked out via reductions into propositional (un)satisfiability. In particular, the test for unsatisfiability can be realized in analogy to \u03a0unsatn analyzed below.\nIn the general case, we use Boolean variables and propositional atoms interchangeably in order to describe how the validity problem of (19) is captured by DLP-functions from Figure 2. The design of \u03a0satn and \u03a0 unsat n is based on the explanatory approach from Janhunen et al. (2006), where (19) is equivalently viewed as a formula \u2203X\u00ac\u2203Y \u00ac\u03c6 having the matrix \u00ac\u03c6 in conjunctive normal form (CNF). A clause11 Ai \u2228 \u00acBi \u2228 Ci \u2228 \u00acDi in \u00ac\u03c6 is active whenever Ai \u2228 \u00acBi is false and the truth of the clause becomes dependent on Ci \u2228 \u00acDi; or to put it dually, \u00acAi \u2227Bi is true and the truth of \u00acAi \u2227Bi \u2227\u00acCi \u2227Di depends on \u00acCi \u2227Di. The validity of the formula \u2203X\u00ac\u2203Y \u00ac\u03c6 is captured as follows: Given an input interpretation Mi \u2286 {act(1), . . . , act(n)}, the upper DLP-function \u03a0 sat n from Figure 2 tries to explain the activation statuses of the clauses in \u00ac\u03c6 by checking that the respective theory {\u00acAi \u2227Bi | act(i) \u2208 Mi}\u222a{Ai \u2228 \u00acBi | act(i) 6\u2208 Mi} is satisfiable. The lower DLP-function, \u03a0 unsat n , plays the role of a coNP-oracle: it captures a test for the theory {Ci \u2228 \u00acDi | act(i) \u2208 Mi} being unsatisfiable. The correctness of the representation provided by these DLP-functions will be addressed soon, but it is enough to understand their syntax and intuitive meaning for the moment. A concrete QBF instance is evaluated as follows.\nExample 5.12 Consider DLP-functions \u03a0satn and \u03a0 unsat n from Figure 2 in the case of QBF\n\u2203x1\u2203x2\u2200y1\u2200y2[(x1\u2227y1\u2227y2)\u2228(\u00acx2\u2227y1\u2227\u00acy2)\u2228(x1\u2227\u00acy1\u2227y2)\u2228(x1\u2227\u00acx2\u2227\u00acy1\u2227\u00acy2)]. (22)\nThus, the parameter for this instance is n = 4, and the input signature is {act(1), . . . , act(4)} for both \u03a0sat4 and \u03a0 unsat 4 , as illustrated in Figure 3. The output signature of the former DLPfunction is {x1, x2} and all other atoms, i.e., y1, y2, and u, remain hidden in the latter. The joint input signature is used to specify the active part of the matrix in (22). The DLPfunction \u03a0sat4 provides an explanation, i.e., an assignment to variables x1 and x2 as its output, whereas \u03a0unsat4 is only responsible for the respective unsatisfiability check. As regards the validity of the QBF given in (22), the input interpretation {act(1), act(2), act(3), act(4)} yields a positive answer. The respective explanation, i.e., the output interpretation found by \u03a0sat4 , is {x1}. It is easy to check that when x1 is true and x2 is false then the remainder of the matrix is true whatever values are assigned to y1 and y2. Hence, the QBF (22) is valid.\n11. For the purposes of this section, we interpret disjunctions A \u2228 \u00acB of sets A and \u00acB = {\u00acb | b \u2208 B} of positive and negative literals, respectively, as disjunctions of their elements.\nAs regards the general DLP-functions \u03a0satn and \u03a0 unsat n in Figure 2, they have identical input signatures, only \u03a0satn has output atoms, and the hidden atoms of \u03a0 unsat n are fully respected. Hence, the composition \u03a0satn \u2295\u03a0 unsat n is defined. Moreover, the atoms appearing in rules that involve positive dependencies belong to disjoint sets X and Y \u222a {u}. It is therefore clear that DG+(\u03a0satn \u2295 \u03a0 unsat n ) cannot have an SCC S such that S \u2229 X 6= \u2205 and S \u2229 (Y \u222a {u}) 6= \u2205. This implies that \u03a0satn \u2294\u03a0 unsat n is defined regardless of the QBF (19) in question. Let us exploit this fact in the context of specific DLP-functions of Example 5.12.\nExample 5.13 There are four stable models for the DLP-function \u03a0sat4 :\n{act(1), act(2), act(3), act(4), x1}, {act(1), act(3), x1, x2}, {act(2)}, and {x2},\nlisted in decreasing level of activation. On the other hand, the DLP-function \u03a0unsat4 has a unique stable model {act(1), act(2), act(3), act(4), y1, y2, u}, i.e., the interpretation {y1, y2, u} is the unique stable model of \u03a0unsat4 /{act(1), act(2), act(3), act(4)} where the set of rules is given by\n{ u \u2190 y1, y2; u \u2228 y2 \u2190 y1; u \u2228 y1 \u2190 y2; u \u2228 y1 \u2228 y2; y1 \u2190 u; y2 \u2190 u; u \u2190 \u223cu },\nand \u03a0unsat4 /Mi has no stable models for any other input interpretation Mi. Moreover, we may apply the module theorem to calculate SM(\u03a0sat4 \u2294\u03a0 unsat 4 ) by combining compatible pairs of models. There is only one such pair:\n{act(1), act(2), act(3), act(4), x1} \u2208 SM(\u03a0 sat 4 ) and\n{act(1), act(2), act(3), act(4), y1, y2, u} \u2208 SM(\u03a0 unsat 4 ).\nThus, {act(1), act(2), act(3), act(4), x1, y1, y2, u} is the unique stable model of the join \u03a0 sat 4 \u2294 \u03a0unsat4 . Since SM(\u03a0 sat 4 \u2294\u03a0 unsat 4 ) is non-empty, we conclude that (22) is indeed valid.\nIt is natural to ask what can be stated about the stable models of the general DLPfunctions \u03a0unsatn and \u03a0 sat n associated with the QBF \u2203X\u2200Y \u03c6 given in (19). If M is a stable model of \u03a0satn , then the respective projectionMX = X\u2229M determines M , i.e., it holds for all 1 \u2264 i \u2264 n in the matrix \u03c6 that act(i) \u2208 M if and only ifMX |= \u00acAi\u2227Bi. Moreover, the model MX is minimal in the sense that there is no strictly smaller interpretation N \u2282 MX with this property. This is an additional feature brought along the minimality of stable models. As a consequence, the DLP-function \u03a0satn does not capture all possible truth assignments to variables in X but no relevant truth assignments are lost. On the other hand, any stable model M of \u03a0unsatn indicates that the respective theory\n{Ci \u2228 \u00acDi | 1 \u2264 i \u2264 n, act(i) \u2208 M}\nis inconsistent, or alternatively, the formula \u2228\n1\u2264i\u2264n,act(i)\u2208M \u00acCi \u2227Di is valid. Concerning the correctness of the representation given in Figure 2, due to an existing proof by Janhunen et al. (2006), we only present the main steps\u2014fully exploiting the benefits from our modular approach.\nTheorem 5.14 A QBF \u2203X\u2200Y \u03c6 of the form (19) is valid iff SM(\u03a0satn \u2294\u03a0 unsat n ) is non-empty.\nProof sketch. Consider any QBF \u2203X\u2200Y \u03c6 of the form (19). The following are equivalent:\n1. The formula \u2203X\u2200Y \u03c6 is valid.\n2. There is a minimal interpretation N \u2286 X such that, for the set I = {1 \u2264 i \u2264 n | N 6|= Ai \u2228 \u00acBi} of indices determined by N with N |= {\u00acAi \u2227Bi | i \u2208 I}\u222a{Ai \u2228 \u00acBi | i 6\u2208 I}, the theory {Ci \u2228 \u00acDi | i \u2208 I} is unsatisfiable.\n3. The DLP-functions \u03a0satn and \u03a0 unsat n have compatible stable models M1 = N \u222a{act(i) |\ni \u2208 I} and M2 = {act(i) | i \u2208 I} \u222a Y \u222a {u}, respectively.\n4. The DLP-function \u03a0satn \u2294\u03a0 unsat n has a stable model\nM = M1 \u222aM2 = N \u222a {act(i) | i \u2208 I} \u222a Y \u222a {u}.\nIn the second item, the minimality ofN means that there is noN \u2032 \u2282 N such that {1 \u2264 i \u2264 n | N \u2032 6|= Ai \u2228 \u00acBi} = I. This can be assumed without loss of generality.\nTheorem 5.14 and the module theorem suggest an approximation strategy for verifying the validity of QBFs of the form (19). If either SM(\u03a0satn ) or SM(\u03a0 unsat n ) is empty, we know directly that the formula is not valid. Otherwise, we check whether SM(\u03a0satn \u2294\u03a0 unsat n ) = \u2205."}, {"heading": "5.3 Splitting Sets", "text": "For the sake of comparison, we formulate the splitting-set theorem (Lifschitz & Turner, 1994) for a DLP-function \u03a0 = \u3008R, \u2205, O, \u2205\u3009, which essentially forms an \u201cordinary\u201d disjunctive program. Splitting sets are sets of atoms that are closed in the following sense:\nDefinition 5.15 Given a DLP-function \u03a0 = \u3008R, \u2205, O, \u2205\u3009, a set U \u2286 O of atoms is a splitting set for \u03a0 if and only if, for every rule A \u2190 B,\u223cC \u2208 R,"}, {"heading": "A \u2229 U 6= \u2205 implies A \u222aB \u222a C \u2286 U .", "text": "By Definitions 2.1 and 5.15, the sets \u2205 and O are always splitting sets for \u03a0. However, one is mostly interested in other non-trivial splitting sets \u2205 \u2282 U \u2282 O for \u03a0, but such sets need not exist. Nevertheless, any splitting set U divides the respective set of rules R in two parts. The bottom, bU (R), of R with respect to U contains all rules A \u2190 B,\u223cC \u2208 R such that A \u222a B \u222a C \u2286 U , whereas the top, tU (R), of R is R \\ bU (R). The splitting of R into bU (R) and tU (R) becomes a proper one, i.e., bU (R) 6= \u2205 and tU (R) 6= \u2205, if\n1. U is non-trivial and\n2. every atom a \u2208 O has at least one defining rule A \u2190 B,\u223cC \u2208 R such that a \u2208 A.\nAccording to Lifschitz and Turner (1994), a solution to R with respect to U \u2286 O is a pair \u3008X,Y \u3009 where X \u2286 U , Y \u2286 O\\U , X \u2208 SM(bU (R)), and Y \u2208 SM(tU (R)/X). Here, tU (R)/X denotes the partial evaluation of tU (R) in the sense of Definition 3.2 using X \u2286 U as an input interpretation. Using a similar idea, let us introduce DLP-functions corresponding to bU (R) and tU (R). Given a splitting set U for \u03a0, the join \u03a0 = \u03a0B \u2294\u03a0T , where\n\u03a0B = \u3008bU (R), \u2205, U, \u2205\u3009 and \u03a0T = \u3008tU (R), U,O \\ U, \u2205\u3009\nis defined. Then, the following result is implied by Theorem 5.7.\nCorollary 5.16 (Splitting-Set Theorem from Lifschitz & Turner, 1994) For every DLP-function \u03a0 = \u3008R, \u2205, O, \u2205\u3009 corresponding to a set R of disjunctive rules, every splitting set U \u2286 O for \u03a0, and every interpretation M \u2286 At(\u03a0) = O, the following conditions are equivalent:\n1. M is a stable model of \u03a0.\n2. M \u2229 U \u2208 SM(\u03a0B) and M \u2208 SM(\u03a0T ).\n3. \u3008M \u2229 U,M \\ U\u3009 is a solution to R with respect to U .\nIn fact, Theorem 5.7 is strictly stronger than the splitting-set theorem. As previously demonstrated by Oikarinen and Janhunen (2008a), splitting sets are applicable to DLPfunctions like \u03a0 = \u3008{a \u2190 \u223cb; b \u2190 \u223ca}, \u2205, {a, b}, \u2205\u3009 only in the trivial way, i.e., only U1 = \u2205 are U2 = {a, b} are splitting sets for \u03a0. In contrast, Theorem 5.7 applies to the preceding DLP-function in more versatile ways, i.e., \u03a01\u2294\u03a02 is defined for \u03a01 = \u3008{a \u2190 \u223cb}, {b}, {a}, \u2205\u3009 and \u03a02 = \u3008{b \u2190 \u223ca}, {a}, {b}, \u2205\u3009. As a consequence of \u03a01 \u2294\u03a02 being defined, it is possible to determine the sets of stable models SM(\u03a01) = {{a}, {b}} = SM(\u03a02) in separation, if appropriate, and then conclude that SM(\u03a0) = SM(\u03a01) \u22ca\u22c9 SM(\u03a02) = {{a}, {b}} holds as well. Yet another generality aspect of splitting concerns the role of input atoms\u2014they are assumed nonexistent above. Theorem 5.7, however, enables us to treat them as well."}, {"heading": "6. Decomposing DLP-Functions", "text": "The objectives of this section are contrary to the construction of a DLP-function as a join of modules. The idea is to exploit the strongly connected components of DG+(\u03a0), for a DLPfunction \u03a0, in order to decompose \u03a0 into smaller components, e.g., when there is no a priori information about the internal structure of \u03a0. For simplicity, we will first consider DLPfunctions \u03a0 having no hidden atoms, i.e., where Ath(\u03a0) = \u2205. The effects of hidden atoms on the decomposition of DLP-functions will be addressed thereafter. As defined in conjunction with Definition 2.6, the SCCs in DG+(\u03a0) are induced by the positive dependency relation \u2264 which is reflexive and transitive, i.e., a preorder by definition. In the sequel, the set of SCCs in DG+(\u03a0) is denoted by SCC+(\u03a0). The positive dependency relation \u2264 lifts for the elements of SCC+(\u03a0) as follows: S1 \u2264 S2 if and only if there are atoms a1 \u2208 S1 and a2 \u2208 S2 such that a1 \u2264 a2. To this end, it does not matter which pair of atoms is inspected.\nLemma 6.1 For any DLP-function \u03a0 and any components S1, S2 \u2208 SCC +(\u03a0), S1 \u2264 S2 if and only if a1 \u2264 a2 for every a1 \u2208 S1 and a2 \u2208 S2.\nProof. (=\u21d2) If S1 \u2264 S2, there are b1 \u2208 S1 and b2 \u2208 S2 such that b1 \u2264 b2. Consider any a1 \u2208 S1 and a2 \u2208 S2. It follows that a1 \u2264 b1 and b2 \u2264 a2 by the definition of SCCs. Thus, a1 \u2264 a2 as \u2264 is transitive.\n(\u21d0=) This holds trivially as SCCs are non-empty.\nProposition 6.2 The relation \u2264 over SCC+(\u03a0) is reflexive, transitive, and antisymmetric.\nProof. The relation \u2264 over SCC+(\u03a0) is reflexive and transitive by definition. For antisymmetry, consider any S1, S2 \u2208 SCC\n+(\u03a0) such that S1 \u2264 S2 and S2 \u2264 S1. It follows by Lemma 6.1 that, for every a1 \u2208 S1 and a2 \u2208 S2, a1 \u2264 a2 and a2 \u2264 a1. Thus, S1 = S2 by the maximality of components in SCC+(\u03a0).\nConsequently, we may conclude that \u3008SCC+(\u03a0),\u2264\u3009 is a partially ordered set. Since \u03a0 is finite by definition, \u3008SCC+(\u03a0),\u2264\u3009 has maxima and minima but these elements need not be unique. In particular, for each S \u2208 SCC+(\u03a0) there is a minimum element S1 \u2208 SCC\n+(\u03a0) such that S1 \u2264 S and S2 \u2264 S1 implies S2 = S1, for any S2 \u2208 SCC\n+(\u03a0). Thus, we may apply the principle of well-founded induction using the minima of \u3008SCC+(\u03a0),\u2264\u3009 as basis.\nGiven the structure \u3008SCC+(\u03a0),\u2264\u3009, the DLP-function \u03a0 = \u3008R, I,O, \u2205\u3009 can be decomposed in the following way: The set of rules associated with S \u2208 SCC+(\u03a0) is DefR(S) from (2), i.e., the set of defining rules for S in R. In general, the head of an arbitrary rule A \u2190 B,\u223cC \u2208 R may coincide in the sense of (2) with several SCCs, which implies that the rule is included in DefR(S) for several S \u2208 SCC\n+(\u03a0). However, such a distribution of rules is in perfect harmony with the last two conditions of Definition 2.2. We must also bear in mind integrity constraints \u22a5 \u2190 B,\u223cC which are not included in DefR(S) for any S \u2208 SCC+(\u03a0). To access the integrity constraints of any set R of rules, we define\nIC(R) = {A \u2190 B,\u223cC \u2208 R | A = \u2205}. (23)\nWe are now ready to present a decomposition of \u03a0 based on SCC+(\u03a0).\nDefinition 6.3 Given a DLP-function \u03a0 = \u3008R, I,O, \u2205\u3009, the decomposition induced by SCC+(\u03a0) includes a DLP-function\n\u03a00 = \u3008IC(R),At(IC(R)) \u222a (I \\At(R)), \u2205, \u2205\u3009 (24)\nand, for each S \u2208 SCC+(\u03a0), a DLP-function\n\u03a0S = \u3008DefR(S),At(DefR(S)) \\ S, S, \u2205\u3009. (25)\nThe purpose of the extra module \u03a00 is to keep track of integrity constraints as well as input atoms that are not mentioned by the rules of R. The other modules involved in the decomposition \u03a0 are induced by SCCs. Each \u03a0S refers to other modules using At(DefR(S)) \\ S as its input signature and provides the defining rules (if any) for every atom in S. Recall that an output atom having no defining rules will be falsified by default.\nProposition 6.4 For a DLP-function \u03a0 = \u3008R, I,O, \u2205\u3009 and its decomposition based on SCC+(\u03a0), the join\n\u03a00 \u2294 ( \u2294 S\u2208SCC+(\u03a0)\u03a0S) (26)\nis defined and equal to \u03a0.\nProof. Let us consider \u03a00 and \u03a0S for any S \u2208 SCC +(\u03a0). The composition \u03a00 \u2295 \u03a0S is defined because these modules involve no hidden atoms, Ato(\u03a00) = \u2205, and we have DefR1(\u2205) = \u2205 = DefR1\u222aR2(\u2205) and DefR2(S) = DefR(S) = DefR1\u222aR2(S) for the sets of rules R1 = IC(R) and R2 = DefR(S). The join \u03a00 \u2294 \u03a0S is defined as the respective composition is and the integrity constraints in \u03a00 do not create any dependencies in DG +(\u03a00 \u2295\u03a0S).\nLet us perform a similar analysis for \u03a0S1 and \u03a0S2 based on two different components S1, S2 \u2208 SCC\n+(\u03a0). It is clear that \u03a0S1 \u2295 \u03a0S2 is defined since these modules involve no hidden atoms, S1 \u2229 S2 = \u2205, and we have that DefR1(S1) = DefR(S1) = DefR1\u222aR2(S1) and DefR2(S2) = DefR(S2) = DefR1\u222aR2(S2), for R1 = DefR(S1) and R2 = DefR(S2).\nSince all pairwise joins are defined, also the overall join (26) is defined. By Definition 2.4 and the definition of SCC+(\u03a0), the outcome is equal to \u03a0 because\n1. IC(R) \u222a \u22c3\nS\u2208SCC+(\u03a0)DefR(S) = R,\n2. \u22c3\nS\u2208SCC+(\u03a0) S = O, and\n3. (At(IC(R)) \\O) \u222a ((I \\At(R)) \\O) \u222a \u22c3\nS\u2208SCC+(\u03a0)(At(DefR(S)) \\O) = I.\nCorollary 6.5 For a DLP-function \u03a0 with Ath(\u03a0) = \u2205 and its decomposition based on SCC+(\u03a0),\nSM(\u03a0) = SM(\u03a00) \u22ca\u22c9 (\u22ca\u22c9S\u2208SCC+(\u03a0)SM(\u03a0S)).\nExample 6.6 Consider the following DLP-function \u03a0:\n{a, b, c, d}\na \u2228 b \u2228 c \u2228 d \u2190; \u2190 a, c; \u2190 b, c; \u2190 a, d; \u2190 b, d; a \u2190 b; c \u2190 d; b \u2190 a; d \u2190 c.\n\u2205\nSo, Ati(\u03a0) = \u2205, Ato(\u03a0) = {a, b, c, d}, and Ath(\u03a0) = \u2205. There are two SCCs in DG +(\u03a0), viz. S1 = {a, b} and S2 = {c, d}. The resulting decomposition of \u03a0 consists of\n\u03a00 = \u3008{\u2190 a, c; \u2190 a, d; \u2190 b, c; \u2190 b, d}, {a, b, c, d}, \u2205, \u2205\u3009, \u03a0S1 = \u3008{a \u2228 b \u2228 c \u2228 d \u2190; a \u2190 b; b \u2190 a}, {c, d}, {a, b}, \u2205\u3009, and \u03a0S2 = \u3008{a \u2228 b \u2228 c \u2228 d \u2190; c \u2190 d; d \u2190 c}, {a, b}, {c, d}, \u2205\u3009.\nThe respective sets of stable models are\nSM(\u03a00) = {{a, b}, {c, d}, {a}, {b}, {c}, {d}, \u2205}, SM(\u03a0S1) = {{a, b}, {c}, {d}, {c, d}}, SM(\u03a0S1) = {{c, d}, {a}, {b}, {a, b}}, and SM(\u03a0) = {{a, b}, {c, d}}.\nNext, we address the case of DLP-functions involving hidden atoms, i.e., for which Ath(\u03a0) 6= \u2205 holds. Then, the components in DG\n+(\u03a0) are subsets of Ato(\u03a0) \u222a Ath(\u03a0) and we have to revise (25) accordingly. For a DLP-function \u03a0 = \u3008R, I,O,H\u3009 and S \u2208 SCC+(\u03a0),\n\u03a0S = \u3008DefR(S),At(DefR(S)) \\ S, S \u2229O,S \u2229H\u3009. (27)\nUnfortunately, a decomposition based on modules of the form (27) is likely to be too finegrained. For certain components S1, S2 \u2208 SCC +(\u03a0) such that S1 6= S2, the respective\nmodules \u03a0S1 and \u03a0S2 conforming to (27) might not respect hidden atoms of each other. A similar setting may arise with \u03a00 and an individual module \u03a0S based on some S \u2208 SCC\n+(\u03a0) if the integrity constraints of \u03a0 refer to hidden atoms of \u03a0S . The problem would disappear if all hidden atoms of \u03a0 were revealed but this is hardly appropriate\u2014there are good reasons to hide certain atoms from a knowledge representation perspective.\nA way to approach this problem is to distinguish components S1 \u2208 SCC +(\u03a0) and"}, {"heading": "S2 \u2208 SCC", "text": "+(\u03a0) for which the respective modules \u03a0S1 and \u03a0S2 would not respect the hidden atoms of each other, i.e., a hidden atom defined by one would be referred by the other\u2014either positively or negatively. Similar conflicts could also arise due to integrity constraints packed into the module \u03a00 distinguished in Definition 6.3. At first sight, we should amalgamate \u03a00 with any other module whose hidden atoms occur in the integrity constraints of \u03a00. But, in order to avoid fusions of this kind as far as possible, it is worth redistributing integrity constraints referring to hidden atoms. This is clearly possible for integrity constraints referring to hidden atoms involved in a single component only. To formalize the ideas presented so far, we distinguish a precise relation among the components of SCC+(\u03a0) as follows.\nDefinition 6.7 Given a DLP-function \u03a0, components S1, S2 \u2208 SCC +(\u03a0) do not respect the hidden atoms of each other, denoted by S1 !h S2, if and only if S1 6= S2 and there is\n1. a hidden atom h \u2208 Ath(\u03a0S1) such that h \u2208 Ati(\u03a0S2), or\n2. a hidden atom h \u2208 Ath(\u03a0S2) such that h \u2208 Ati(\u03a0S1), or\n3. there are hidden atoms h1 \u2208 Ath(\u03a0S1) and h2 \u2208 Ath(\u03a0S2) which both have an occurrence in some integrity constraint \u2190 B,\u223cC of \u03a0.\nIt is clear that !h is irreflexive and symmetric for the components of SCC +(\u03a0) for any DLP-function \u03a0. Moreover, the transitive closure of !h, denoted by ! + h , gives rise to a repartitioning of SCC+(\u03a0). Each maximal block S1, . . . , Sn of components such that Si ! + h Sj holds for every i 6= j induces a module \u03a0S as determined by (27) for the union S = S1 \u222a . . . \u222a Sn. The key observation is that modules associated with different blocks of components respect hidden atoms of each other which makes Theorem 5.7 applicable at that level of abstraction. To summarize the treatment of DLP-functions involving hidden atoms in their rules, we revise Definition 6.3 accordingly.\nDefinition 6.8 Given a DLP-function \u03a0 = \u3008R, I,O,H\u3009, the decomposition induced by SCC+(\u03a0) and !+h includes a DLP-function\n\u03a00 = \u3008IC0(R),At(IC0(R)) \u222a (I \\At(R)), \u2205, \u2205\u3009 (28)\nwhere IC0(R) = {\u2190 B,\u223cC \u2208 R | (B \u222a C) \u2229H = \u2205} and, for each maximal block S1, . . . , Sn of components of SCC+(\u03a0) such that Si ! + h Sj for every i 6= j, a DLP-function\n\u03a0S = \u3008DefR(S) \u222a ICS(R),At(DefR(S) \u222a ICS(R)) \\ S, S \u2229O,S \u2229H\u3009 (29)\nwhere S = S1 \u222a . . . \u222a Sn and ICS(R) = {\u2190 B,\u223cC \u2208 R | (B \u222a C) \u2229 (S \u2229H) 6= \u2205}.\nAs regards Example 6.6, Definitions 6.3 and 6.8 yield identical decompositions for the DLP-function in question. The effects of hiding are demonstrated by the following example:\nExample 6.9 Consider a DLP-function \u03a0 = \u3008R, \u2205, O,H\u3009, for\nR = {\u2190 a,\u223cc; a \u2228 b \u2190; b \u2228 c \u2228 d \u2190; c \u2190 d; d \u2190 c,\u223cb}\nand O\u222aH = {a, b, c, d}, where the exact partitioning of atoms in O and H varies from case to case as analyzed below. The SCCs in SCC+(\u03a0) are S1 = {a}, S2 = {b}, and S3 = {c, d}.\n1. If we take all atoms visible in \u03a0, i.e., if H = \u2205, the decomposition of \u03a0 yields three modules, \u03a0S1 = \u3008{a \u2228 b \u2190}, {b}, {a}, \u2205\u3009, \u03a0S2 = \u3008{a \u2228 b \u2190; b \u2228 c \u2228 d \u2190}, {a, c, d}, {b}, \u2205\u3009, and \u03a0S3 = \u3008{b \u2228 c \u2228 d \u2190; c \u2190 d; d \u2190 c,\u223cb}, {b}, {c, d}, \u2205\u3009, in addition to the module \u03a00 = \u3008{\u2190 a,\u223cc}, {a, c}, \u2205, \u2205\u3009 encompassing integrity constraints.\n2. If we hide H = {a} in \u03a0, we obtain S1 !h S2 by the disjunctive rule a\u2228 b \u2190. Therefore, components S1 and S2 must be placed in the same block which is also maximal\u2014 giving rise to a module \u03a0S = \u3008{\u2190 a,\u223cc; a \u2228 b \u2190; b \u2228 c \u2228 d \u2190}, {c, d}, {b}, {a}\u3009 where S = S1 \u222a S2 = {a, b}. The other modules are \u03a00 = \u2205 and \u03a0S3 listed above.\n3. Finally, if we set H = {a, c} for \u03a0, we obtain S2 !h S3 by b\u2228c\u2228d \u2190 and S1 !h S3 by \u2190 a,\u223cc in addition to S1 !h S2 as stated above. Since \u03a00 = \u2205, the decomposition of \u03a0 effectively collapses to a single module \u03a0S\u2032 = \u03a0 where S \u2032 = S1 \u222a S2 \u222a S3.\nWe note about the non-trivial modules mentioned above that\nSM(\u03a0S1) = {{a}, {b}}, SM(\u03a0S2) = {{b}, {a, b}, {b, c}, {a, c}, {b, d}, {a, d}, {b, c, d}, {a, c, d}}, SM(\u03a0S3) = {{b}, {c, d}}, SM(\u03a00) = {\u2205, {c}, {a, c}}, and SM(\u03a0S) = {{b}, {a, c}, {b, c}, {b, d}, {a, c, d}, {b, c, d}}.\nBut, regardless of the decomposition obtained, it holds for the respective joins that\nSM(\u03a0) = SM(\u03a0S1) \u22ca\u22c9 SM(\u03a0S2) \u22ca\u22c9 SM(\u03a0S3) \u22ca\u22c9 SM(\u03a00) = SM(\u03a0S) \u22ca\u22c9 SM(\u03a0S3) \u22ca\u22c9 SM(\u2205) = SM(\u03a0S\u2032) \u22ca\u22c9 SM(\u2205) = {{a, c, d}, {b}}.\nIn the calculations involving \u22ca\u22c9 it is important to notice that the allowed combinations of stable models are determined in terms of joint visible atoms of the modules involved. For instance, we have Atv(\u03a0S1) \u2229 Atv(\u03a0S3) = {a, b} \u2229 {b, c, d} = {b} so that SM(\u03a0S1) \u22ca\u22c9 SM(\u03a0S3) is {{a} \u222a {c, d}, {b} \u222a {b}} = {{a, c, d}, {b}} by Definition 5.2. Thus, interestingly, the role of the remaining two modules \u03a0S2 and \u03a00 is merely to approve upon these two models. Recalling the discussion from the introduction, this suggests a strategy which gives precedence to\n1. an evaluation of modules having only few stable models, and\n2. a combination of stable models for modules that have only few visible atoms in common."}, {"heading": "7. Shifting Disjunctions", "text": "In this section, we continue the pursuit of applications for the module theorem established in Section 5. We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper. Roughly speaking, the idea behind shifting is to translate a disjunctive rule A \u2190 B,\u223cC into several normal (non-disjunctive) rules by shifting head atoms h \u2208 A to negative literals \u223ch in the body. For instance, a simple disjunctive rule a \u2228 b \u2228 c \u2190 is captured by normal rules\na \u2190 \u223cb,\u223cc, b \u2190 \u223ca,\u223cc, and c \u2190 \u223ca,\u223cb.\nAs shown by Eiter et al. (2004), such a local shifting transformation preserves ordinary equivalence, i.e., stable models.12 The application of this technique is, however, pre-empted in the presence of head-cycles (Ben-Eliyahu & Dechter, 1994). Such a cycle is provided by an SCC S that intersects with the head A of some disjunctive rule A \u2190 B,\u223cC of \u03a0 such that |S\u2229A| > 1. For instance, local shifting is no longer applicable to the rule a\u2228 b\u2228 c \u2190 in the presence of a \u2190 b and b \u2190 a which create a strongly connected component S = {a, b}. As a consequence, the respective DLP-functions\n\u03a01 = \u3008{a \u2228 b \u2228 c \u2190; a \u2190 b; b \u2190 a}, \u2205, {a, b, c}, \u2205\u3009, (30)\n\u03a02 = \u3008{a \u2190 \u223cb,\u223cc; b \u2190 \u223ca,\u223cc; c \u2190 \u223ca,\u223cb; a \u2190 b; b \u2190 a}, \u2205, {a, b, c}, \u2205\u3009 (31)\nhave different stable models: SM(\u03a01) = {{a, b}, {c}} and SM(\u03a02) = {{c}}. Such a discrepancy of stable models can be settled by applying the decomposition technique from Section 6. In fact, it leads to a proper generalization of the local shifting transformation which is formalized below for DLP-functions and their strongly connected components.\nDefinition 7.1 Let \u03a0 = \u3008R, I,O,H\u3009 be a DLP-function and SCC+(\u03a0) the respective set of SCCs. The general shifting of \u03a0 is the DLP-function GSH(\u03a0) = \u3008IC(R) \u222aR\u2032, I, O,H\u3009, where R\u2032 is the set of rules\n{(A \u2229 S) \u2190 B,\u223cC,\u223c(A \\ S) | A \u2190 B,\u223cC \u2208 R, S \u2208 SCC+(\u03a0) and A \u2229 S 6= \u2205}. (32)\nHence, the idea is to project the head A of the rule with respect to each component S, and atoms in the difference A \\ S are shifted to the negative body. This can be viewed as the contribution of a disjunctive rule A \u2190 B,\u223cC for a particular component S.\nExample 7.2 For \u03a01 from (30), we have SCC +(\u03a01) = {{a, b}, {c}}, so that\nGSH(\u03a01) = \u3008{a \u2228 b \u2190 \u223cc; c \u2190 \u223ca,\u223cb; a \u2190 b; b \u2190 a}, \u2205, {a, b, c}, \u2205\u3009.\nMost importantly, we have SM(GSH(\u03a01)) = {{a, b}, {c}} = SM(\u03a01), in contrast to the set SM(\u03a02) = {{c}} of stable models for \u03a02 from (31).\n12. In addition to ordinary equivalence, also uniform equivalence (Eiter & Fink, 2003) is preserved by local shifting but not strong equivalence (Lifschitz, Pearce, & Valverde, 2001).\nWe now prove the correctness of the general shifting principle from Definition 7.1. The aim is to exploit the decomposition of \u03a0 from Definition 6.3 together with the modular reconstruction of \u03a0 from Proposition 6.4 and the compositionality of stable semantics from Corollary 6.5. To extend the coverage of Corollary 6.5, we introduce explicit operators for revealing and hiding atoms of DLP-functions as follows:\nDefinition 7.3 Let \u03a0 = \u3008R, I,O,H\u3009 be a DLP-function. Then,\n1. Reveal(\u03a0, A) = \u3008R, I,O \u222aA,H \\A\u3009, for a set A \u2286 H of hidden atoms, and\n2. Hide(\u03a0, A) = \u3008R, I,O \\A,H \u222aA\u3009, for a set A \u2286 O of output atoms.\nSince the definition of stable models does not make a difference between output atoms and hidden atoms, the following properties are easy to verify. The role of hidden atoms becomes important in Section 8 when DLP-functions are compared with each other.\nProposition 7.4 Let \u03a0 be any DLP-function.\n1. For any A \u2286 Ath(\u03a0), SM(\u03a0) = SM(Reveal(\u03a0, A)).\n2. For any A \u2286 Ato(\u03a0), SM(\u03a0) = SM(Hide(\u03a0, A)).\nLemma 7.5 Let \u03a0 be a DLP-function with Ath(\u03a0) = \u2205, S a component in SCC +(\u03a0), and \u03a0S the respective module in the decomposition of \u03a0 according to Definition 6.3. Then,\nSM(\u03a0S) = SM(GSH(\u03a0S)). (33)\nProof. Recall that \u03a0S = \u3008DefR(S), I, S, \u2205\u3009, where the input signature I = At(DefR(S))\\ S. Notice that S is the only component in SCC+(\u03a0S) and hence GSH(\u03a0S) has a set of rules\nR\u2032 = {(A \u2229 S) \u2190 B,\u223cC,\u223c(A \\ S) | A \u2190 B,\u223cC \u2208 DefR(S)}.\nConsider any interpretation M \u2286 I \u222aS, where I and S are the input and output signatures of \u03a0S , respectively. Thus, Mi = M \u2229 I and Mo = M \u2229 S. Then, the following equivalences hold:\nA \u2190 B \u2208 (DefR(S)/Mi) Mo\n\u21d0\u21d2 \u2203A \u2190 B,\u223cC \u2208 DefR(S)/Mi such that Mo |= \u223cC \u21d0\u21d2 \u2203A\u2032 \u2190 B\u2032,\u223cC \u2032 \u2208 DefR(S) such that A = A \u2032 o, B = B \u2032 o, C = C \u2032 o,\nMi |= \u223cA \u2032 i \u222aB \u2032 i \u222a \u223cC \u2032 i , and Mo |= \u223cC \u2032 o\n\u21d0\u21d2 \u2203A \u2190 B\u2032,\u223cC \u2032,\u223cA\u2032i \u2208 R \u2032 such that A = A\u2032o, B = B \u2032 o, C = C \u2032 o,\nMi |= \u223cA \u2032 i \u222aB \u2032 i \u222a \u223cC \u2032 i , and Mo |= \u223cC \u2032 o\n\u21d0\u21d2 \u2203A \u2190 B,\u223cC \u2208 R\u2032/Mi such that Mo |= \u223cC \u21d0\u21d2 A \u2190 B \u2208 (R\u2032/Mi) Mo .\nThus, we conclude that (DefR(S)/Mi) Mo coincides with (R\u2032/Mi) Mo , and, consequently, Mo \u2208 MM((DefR(S)/Mi) Mo) if and only if Mo \u2208 MM((R \u2032/Mi)\nMo). Therefore, SM(\u03a0S/Mi) = SM(GSH(\u03a0S)/Mi). Since M and, in particular, Mi were arbitrarily chosen in the beginning, we obtain the equality of stable models stated in (33) directly by Corollary 3.9.\nTheorem 7.6 For any DLP-function \u03a0 = \u3008R, I,O,H\u3009, SM(\u03a0) = SM(GSH(\u03a0)).\nProof. Since \u03a0 may have hidden atoms, Corollary 6.5 is not applicable to its decomposition based on SCC+(\u03a0). Thus, we have to start with \u03a0\u2032 = Reveal(\u03a0, H) = \u3008R, I,O \u222aH, \u2205\u3009 rather than \u03a0 itself. Since SCCs are independent of hiding, we have SCC+(\u03a0\u2032) = SCC+(\u03a0) and GSH(\u03a0\u2032) = Reveal(GSH(\u03a0), H). Since Ath(\u03a0\n\u2032) = \u2205 by construction, we know by Proposition 6.4 that \u03a0\u20320 \u2294 ( \u2294 S\u2208SCC+(\u03a0)\u03a0 \u2032 S) = \u03a0 \u2032. Applying GSH(\u00b7) to this equation yields\nGSH(\u03a0\u2032) = \u03a0\u20320 \u2294 ( \u2294 S\u2208SCC+(\u03a0)GSH(\u03a0 \u2032 S)). (34)\nAs regards the respective sets of stable models, we obtain\nSM(\u03a0\u2032) = SM(\u03a0\u20320) \u22ca\u22c9 (\u22ca\u22c9S\u2208SCC+(\u03a0\u2032)SM(\u03a0 \u2032 S)) [Corollary 6.5]\n= SM(\u03a0\u20320) \u22ca\u22c9 (\u22ca\u22c9S\u2208SCC+(\u03a0\u2032)SM(GSH(\u03a0 \u2032 S))) [Lemma 7.5] = SM(GSH(\u03a0\u2032)). [Corollary 6.5 and (34)]\nIt follows by Proposition 7.4 that SM(Hide(\u03a0\u2032, H)) = SM(\u03a0\u2032) = SM(GSH(\u03a0\u2032)) = SM(Hide(GSH(\u03a0\u2032), H)). Since Hide(\u03a0\u2032, H) = \u03a0 and Hide(GSH(\u03a0\u2032), H) = GSH(\u03a0), we have established that SM(\u03a0) = SM(GSH(\u03a0)) as desired.\nAccording to Definition 6.3, decompositions of DLP-functions create multiple copies of disjunctive rules whose heads intersect with several SCCs. The introduction of such copies can be circumvented by applying the general shifting technique from Definition 7.1.\nExample 7.7 For the DLP-function \u03a0 from Example 6.6, we obtain R1 = {a\u2228b \u2190 \u223cc,\u223cd; a \u2190 b; b \u2190 a} and R2 = {c \u2228 d \u2190 \u223ca,\u223cb; c \u2190 d; d \u2190 c} as the sets of rules associated with \u03a01 = \u3008R1, {c, d}, {a, b}, \u2205\u3009 and \u03a02 = \u3008R2, {a, b}, {c, d}, \u2205\u3009, for which \u03a01 \u2294 \u03a02 = \u3008R1 \u222aR2, \u2205, {a, b, c, d}, \u2205\u3009 is defined.\nThese observations enable us to view disjunctive rules which are shared by the modules associated with SCCs as syntactic sugar. However, a clever implementation can save space using shared rules. In the worst case, unwinding a rule a1\u2228 \u00b7 \u00b7 \u00b7\u2228an \u2190 B,\u223cC that coincides with the respective SCCs S1, . . . , Sn such that a1 \u2208 S1, . . . , an \u2208 Sn may create n copies of the body B \u222a\u223cC. Such a quadratic blow-up can be partly alleviated by introducing a new atom b as a name for the body. Thus the result of shifting a1 \u2208 S1, . . . , an \u2208 Sn becomes\na1 \u2190 b,\u223ca2, . . . ,\u223can; ... ai \u2190 b,\u223ca1, . . . ,\u223cai\u22121,\u223cai+1, . . . ,\u223can; ... an \u2190 b,\u223ca1, . . . ,\u223can\u22121\ntogether with the defining rule b \u2190 B,\u223cC for b. There is an implementation of the general shifting principle called dencode.13 If requested to do so, it calculates beforehand whether it pays off to introduce a new atom for the body for each disjunctive rule or not.\n13. Available at http://www.tcs.hut.fi/Software/asptools/ for experimenting."}, {"heading": "8. Equivalence of DLP-Functions", "text": "The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of logic program modules\u2014giving rise to the notion of modular equivalence for logic programs. In this section, we generalize the concept of modular equivalence for DLP-functions and introduce a translation-based method for checking modular equivalence of DLP-functions following analogous approaches of Oikarinen and Janhunen (2004, 2009)."}, {"heading": "8.1 Modular Equivalence", "text": "Module interfaces must be taken properly into account when DLP-functions are compared. For this reason, we consider two DLP-functions \u03a01 and \u03a02 to be compatible if and only if Ati(\u03a01) = Ati(\u03a02) and Ato(\u03a01) = Ato(\u03a02).\nDefinition 8.1 DLP-functions \u03a01 and \u03a02 are modularly equivalent, denoted by \u03a01 \u2261m \u03a02, if and only if\n1. \u03a01 and \u03a02 are compatible and\n2. there is a bijection f : SM(\u03a01) \u2192 SM(\u03a02) such that for all interpretations M \u2208 SM(\u03a01), M \u2229Atv(\u03a01) = f(M) \u2229Atv(\u03a02).\nThe proof that \u2261m is congruent for \u2294 lifts from the case of normal programs (Oikarinen & Janhunen, 2008a) to the disjunctive case using Theorem 5.7.\nProposition 8.2 Let \u03a01, \u03a02, and \u03a0 be DLP-functions. If \u03a01 \u2261m \u03a02 and both \u03a01 \u2294\u03a0 and \u03a02 \u2294\u03a0 are defined, then \u03a01 \u2294\u03a0 \u2261m \u03a02 \u2294\u03a0.\nProof. Let \u03a01 = \u3008R1, I1, O1, H1\u3009 and \u03a02 = \u3008R2, I2, O2, H2\u3009 be DLP-functions such that \u03a01 \u2261m \u03a02, and \u03a0 = \u3008R, I,O,H\u3009 a DLP-function acting as an arbitrary context for \u03a01 and \u03a02 such that \u03a01 \u2294\u03a0 and \u03a02 \u2294\u03a0 are defined. Consider any M \u2208 SM(\u03a01 \u2294\u03a0). Theorem 5.7 implies that M1 = M \u2229At(\u03a01) \u2208 SM(\u03a01) and N = M \u2229At(\u03a0) \u2208 SM(\u03a0). Since \u03a01 \u2261m \u03a02, we have I1 = I2, O1 = O2, and there is a bijection f : SM(\u03a01) \u2192 SM(\u03a02) such that\nM1 \u2229 (I1 \u222aO1) = f(M1) \u2229 (I2 \u222aO2) (35)\nholds for M1. Define M2 = f(M1). Since M1 and N are compatible by definition and (35) holds, the models M2 and N are compatible as I1 = I2 and O1 = O2. Thus, M2 \u222a N \u2208 SM(\u03a02\u2294\u03a0) by Theorem 5.7 and we have effectively described how M is mapped to a model in SM(\u03a02 \u2294\u03a0) by a function g : SM(\u03a01 \u2294\u03a0) \u2192 SM(\u03a02 \u2294\u03a0) defined by\ng(M) = f(M \u2229At(\u03a01)) \u222a (M \u2229At(\u03a0)).\nClearly, g maps the set of visible atoms in M to itself, that is,\nM \u2229 (I1 \u222a I \u222aO1 \u222aO) = g(M) \u2229 (I2 \u222a I \u222aO2 \u222aO).\nThe justifications for g being a bijection are as follows:\n\u2022 g is an injection: M 6= N implies g(M) 6= g(N) for all M,N \u2208 SM(\u03a01 \u2294 \u03a0), since f(M \u2229At(\u03a01)) 6= f(N \u2229At(\u03a01)) or M \u2229At(\u03a0) 6= N \u2229At(\u03a0).\n\u2022 g is a surjection: for any N \u2208 SM(\u03a02 \u2294 \u03a0), M = f \u22121(N \u2229 At(\u03a02)) \u222a (N \u2229 At(\u03a0)) \u2208\nSM(\u03a01 \u2294\u03a0) and g(M) = N , since f is a surjection.\nThe inverse function g\u22121 : SM(\u03a02 \u2294 \u03a0) \u2192 SM(\u03a01 \u2294 \u03a0) of g can be defined by setting g\u22121(N) = f\u22121(N \u2229At(\u03a02)) \u222a (N \u2229At(\u03a0)). Thus, \u03a01 \u2294\u03a0 \u2261m \u03a02 \u2294\u03a0.\nNote that \u03a0 \u2261m GSH(\u03a0) follows directly from Theorem 7.6. Applying Proposition 8.2 in the context of Theorem 7.6 indicates that shifting can be localized to a particular component \u03a01 in a larger DLP-function \u03a01 \u2294\u03a0 since \u03a01 \u2294\u03a0 \u2261m GSH(\u03a01) \u2294\u03a0."}, {"heading": "8.2 Verifying Modular Equivalence", "text": "Oikarinen and Janhunen (2004) proposed a translation-based method for the verification of weak equivalence of disjunctive logic programs. Two logic programs are weakly equivalent iff they have exactly the same set of stable models. Thus, weak equivalence can be seen as a special case of modular equivalence for DLP-functions \u03a01 and \u03a02 where Ati(\u03a01) \u222a Ath(\u03a01) = Ati(\u03a02) \u222a Ath(\u03a02) = \u2205. This motivates us to adjust the translationbased technique for the verification of modular equivalence. As observed in previous work (Janhunen & Oikarinen, 2007; Oikarinen & Janhunen, 2008a), the verification of visible/modular equivalence involves a counting problem in general. A reduction of computational time complexity can be achieved for programs that have enough visible atoms, referred to as the EVA property for short, (Janhunen & Oikarinen, 2007). For any DLPfunction \u03a0 = \u3008R, I,O,H\u3009, we define the hidden part of \u03a0 as the restricted DLP-function \u03a0h = \u3008DefR(H), I \u222aO,H, \u2205\u3009 which enables the evaluation of hidden atoms in H given arbitrary truth values for all other atoms in I \u222a O. Recalling Definition 3.2, we use an instantiation of \u03a0h with respect to an interpretation Mv \u2286 Ati(\u03a0h), i.e., \u03a0h/Mv, to define the EVA property for the DLP-function \u03a0.\nDefinition 8.3 A DLP-function \u03a0 = \u3008R, I,O,H\u3009 has enough visible atoms iff \u03a0h/Mv has a unique stable model for each Mv \u2286 Atv(\u03a0) = Ati(\u03a0h).\nThe idea behind the translation-based method of Oikarinen and Janhunen (2004) is that ordinary disjunctive programs R1 and R2 are weakly equivalent iff their translations TR(R1, R2) and TR(R2, R1) have no stable models. In the following, we propose a modified version of the translation function adjusted to verification of modular equivalence. In order to be able to verify modular equivalence, we need to take the semantics of the atoms in the input signature into account as well as the role of hidden atoms when modular equivalence of programs is under consideration. In the case of DLP-functions, we transform any pair \u03a01 and \u03a02 of compatible DLP-functions into a DLP-function EQT(\u03a01,\u03a02) that has a stable model iff there is some stable model M \u2208 SM(\u03a01) for which there is no stable model N \u2208 SM(\u03a02) with M \u2229Atv(\u03a01) = N \u2229Atv(\u03a02). We form the translation as a composition of DLP-functions in order to fully exploit the compositionality of the stable model semantics when justifying the correctness of the method.\nIn what follows, we use new atoms a\u2022, a\u25e6, and a\u2217 not appearing in At(\u03a01) \u222a At(\u03a02) for any atom a, and we use the shorthand A\u2022 = {a\u2022 | a \u2208 A} for any set A of atoms, and\nanalogously defined shorthands A\u25e6 and A\u2217. Moreover, diff, unsat, unsat\u2022, and ok are new atoms not appearing in At(\u03a01) \u222a At(\u03a02). The translation EQT(\u03a01,\u03a02), which is to be summarized by Definition 8.4 below, consists of the following three parts:\n(i) The DLP-function \u03a01 naturally captures a stable model M \u2208 SM(\u03a01).\n(ii) The DLP-function hidden(\u03a02) = \u3008Rh, I \u222aO,H \u2217, \u2205\u3009 provides a representation for the\nhidden part of \u03a02 = \u3008R, I,O,H\u3009 evaluated with respect to the visible part of M . The input signature of hidden(\u03a02) consists of the visible atoms in Atv(\u03a02) = Atv(\u03a01) = I\u222a O. The set Rh contains a rule A \u2217 h \u2190 Bv\u222aB \u2217 h,\u223c(Av\u222aCv\u222aC \u2217 h) for each A \u2190 B,\u223cC \u2208 R such that Ah 6= \u2205, i.e., A \u2190 B,\u223cC \u2208 DefR(H). The hidden parts of rules are renamed systematically using atoms from Ath(\u03a02)\n\u2217. This is to capture the unique stable model N for (\u03a02)h/Mv expressed in Ath(\u03a02)\n\u2217 rather than Ath(\u03a02). Note that the existence and uniqueness of such an N is guaranteed by the EVA property.\n(iii) Finally, the DLP-function\nTR(\u03a02) = \u3008RTR, I \u222aO \u222aH \u2217, O\u2022 \u222aH\u2022 \u222a {unsat, unsat\u2022, diff, ok}, O\u25e6 \u222aH\u25e6\u3009\nprovides a minimality check. The set RTR contains\n1. a rule unsat \u2190 Bv \u222aB \u2217 h,\u223c(Av \u222aA \u2217 h \u222a Cv \u222a C \u2217 h) for each rule A \u2190 B,\u223cC \u2208 R, 2. rules a\u2022 \u2190 a,\u223ca\u25e6,\u223cunsat and a\u25e6 \u2190 a,\u223ca\u2022,\u223cunsat for each a \u2208 O, and rules a\u2022 \u2190 a\u2217,\u223ca\u25e6,\u223cunsat and a\u25e6 \u2190 a\u2217,\u223ca\u2022,\u223cunsat for each a \u2208 H,\n3. a rule unsat\u2022 \u2190 Bi \u222a B \u2022 o \u222a B \u2022 h,\u223c(Ai \u222a A \u2022 o \u222a A \u2022 h \u222a Cv \u222a C \u2217 h),\u223cunsat for each rule\nA \u2190 B,\u223cC \u2208 R,\n4. a rule diff \u2190 a,\u223ca\u2022,\u223cunsat for each a \u2208 O, and a rule diff \u2190 a\u2217,\u223ca\u2022,\u223cunsat for each a \u2208 H, and\n5. the following rules:\nok \u2190 unsat, ok \u2190 diff,\u223cunsat,\u223cunsat\u2022, and \u22a5 \u2190 \u223cok.\nThe intuition behind the translation TR(\u03a02) is as follows. The rules in the first item check whether an interpretation L \u2286 At(\u03a02) corresponding to the actual input K = (L \u2229 (I \u222aO)) \u222a {a\u2217 | a \u2208 L \u2229H} \u2286 Atv(\u03a02) \u222a Ath(\u03a02)\n\u2217 for TR(\u03a02) satisfies the rules in \u03a02. If the rules of \u03a02 are satisfied, then the rules in items 2\u20134 are activated by the literals \u223cunsat in their bodies. The rules in the second item are used to generate a subset L\u2032 of L such that L\u2032 \u2229 Ati(\u03a02) = L \u2229 Ati(\u03a02). This is achieved by introducing a new atom a\u2022 for each a \u2208 Ato(\u03a02) \u222a Ath(\u03a02). The rules in the third item check whether the representation of L\u2032 in Ati(\u03a02) \u222a Ato(\u03a02) \u2022 \u222a Ath(\u03a02) \u2022, i.e., K \u2032 = (L\u2032 \u2229 I) \u222a {a\u2022 | a \u2208 L\u2032 \u2229 (O \u222aH)}, satisfies the rules in \u03a0L2 . The rules in the fourth item check whether L\u2032 is a proper subset of L. Finally, the rules in the fifth item summarize the reasons why L cannot be a stable model of \u03a02, i.e., either the rules in \u03a02 are not satisfied in L, or L is not a minimal model of \u03a0 L 2 . As the net effect of this construction, TR(\u03a02)/K has a stable model iff L is not a stable model of \u03a02.\nDefinition 8.4 Let \u03a01 and \u03a02 = \u3008R, I,O,H\u3009 be compatible DLP-functions having enough visible atoms. Then, the translation EQT(\u03a01,\u03a02) is given by \u03a01 \u2294 hidden(\u03a02) \u2294 TR(\u03a02).\nThe translation TR(\u03a02) for the minimality check essentially contains the same rules as TR(R1, R2) \\ R1, where TR(R1, R2) is the translation defined by Oikarinen and Janhunen (2004) for sets R1 and R2 of disjunctive rules. There are two further aspects, however. First, occurrences of hidden atoms from H are additionally represented using their counterparts from H\u2217. Second, we only need renamed versions of atoms in O \u222aH because the interpretation of atoms in the input signature I is kept fixed. Finally, we note that for DLP-functions \u03a01 and \u03a02 which correspond to ordinary disjunctive logic programs, i.e., for \u03a01 = \u3008R1, \u2205, O, \u2205\u3009 and \u03a02 = \u3008R2, \u2205, O, \u2205\u3009, the translation EQT(\u03a01,\u03a02) coincides with TR(R1, R2).\nTheorem 8.5 Let \u03a01 and \u03a02 be compatible DLP-functions having enough visible atoms. Then, \u03a01 \u2261m \u03a02 iff both SM(EQT(\u03a01,\u03a02)) = \u2205 and SM(EQT(\u03a02,\u03a01)) = \u2205.\nProof sketch. Let \u03a01 and \u03a02 = \u3008R, I,O,H\u3009 be compatible DLP-functions having enough visible atoms. By Theorem 5.7, given compatible interpretations M1 \u2286 At(\u03a01), M2 \u2286 At(hidden(\u03a02)), and M3 \u2286 At(TR(\u03a02)), M = M1\u222aM2\u222aM3 is a stable model of the translation EQT(\u03a01,\u03a02) iff M1 \u2208 SM(\u03a01), M2 \u2208 SM(hidden(\u03a02)), and M3 \u2208 SM(TR(\u03a02)). Given any interpretation M1 \u2286 At(\u03a01), there is a unique stable model M2 \u2208 SM(hidden(\u03a02)) compatible with M1, since \u03a02 has the EVA property. Hence, hidden(\u03a02) does not constrain stable models in the composition EQT(\u03a01,\u03a02). Whenever M3 is compatible with both M1 and M2, it holds that M3\u2229(I\u222aO\u222aH \u2217) = (M1\u222aM2)\u2229(I\u222aO\u222aH \u2217) and M3 \u2208 SM(TR(\u03a02)) iff the interpretation M3\u2229(I\u222aO)\u222a{a \u2208 H | a \u2217 \u2208 M3} is not a stable model of \u03a02 as established by Oikarinen and Janhunen (2004, Theorem 1). When verifying modular equivalence of DLP-functions of the forms \u03a01 \u2294\u03a0 and \u03a02 \u2294\u03a0, it is possible to further streamline the translations involved in the verification task.\nTheorem 8.6 Let \u03a01 and \u03a02 be compatible DLP-functions having enough visible atoms, and \u03a0 a DLP-function such that \u03a01 \u2294\u03a0 and \u03a02 \u2294\u03a0 are defined. Then, \u03a01 \u2294\u03a0 \u2261m \u03a02 \u2294\u03a0 iff both SM(EQT(\u03a01,\u03a02) \u2294\u03a0) = \u2205 and SM(EQT(\u03a02,\u03a01) \u2294\u03a0) = \u2205.\nThe context \u03a0 can be an arbitrary DLP-function, i.e., it is not necessary for \u03a0 to have the EVA property, as long as \u03a01 \u2294 \u03a0 and \u03a02 \u2294 \u03a0 are defined. To prove Theorem 8.6, notice that due to the structure of the translation, EQT(\u03a01,\u03a02)\u2294\u03a0 is defined whenever \u03a01 \u2294\u03a0 is defined, and then Theorems 5.7 and 8.5 can be applied."}, {"heading": "9. Related Work", "text": "Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over relational databases. In their approach, query programs are formalized as triples \u3008\u03c0,R,S\u3009 where \u03c0 is a set of disjunctive rules and R and S are the signatures for the input and output relations, respectively, whereas auxiliary (hidden) predicates are left implicit. Hence, in the propositional case, the only notable difference with respect to Definition 2.1 is that input atoms are not allowed to occur in the heads of disjunctive rules. As regards semantics, the\nprogram \u03c0 is reduced with respect to a complete input database D specified in terms of R, yielding the instantiation \u03c0[D], and, among others, stable-model semantics is applied to \u03c0[D] in analogy to Definition 3.2. However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294.\nModularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7):\ntclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y).\nHere, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule\nloop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x)\nwhich captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures\nIn = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n}\nin the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion. The outcome determines the meaning of the modular description via an embedding into ASP (Lifschitz & Turner, 1999).\nFaber, Greco, and Leone (2007) apply the magic-set method in the evaluation of datalog programs with negation. Their notion of a module is based on the concept of an independent\nset. For a non-disjunctive logic program \u03a0 = \u3008R, \u2205, O, \u2205\u3009, such a set S \u2286 O satisfies, for any a \u2208 S, the following two conditions:\n1. if there is a rule h \u2190 B,\u223cC \u2208 R such that h = a, then B \u222a C \u2286 S, and\n2. if a \u2208 B \u222a C for some dangerous rule h \u2190 B,\u223cC \u2208 R, then {h} \u222aB \u222a C \u2286 S.\nWe skip the exact definition of dangerous rules which, roughly speaking, may interfere with the existence of stable models. It is clear that independent sets are splitting sets in the sense of Definition 5.15, but not vice versa in general. Hence, the module theorem provided by Faber et al. (2007) can be viewed as a special case of the splitting-set theorem and, therefore, observations presented in Section 5.3 apply to independent sets as well."}, {"heading": "10. Conclusion and Discussion", "text": "In this paper, we introduced a formal framework for modular programming in the context of disjunctive logic programs under stable-model semantics. The framework is based on the notion of a DLP-function which puts into effect appropriate input/output interfacing for disjunctive logic programs. Analogous module concepts have already been studied in the cases of normal logic programs and smodels programs (Oikarinen & Janhunen, 2008a) and even propositional theories (Janhunen, 2008a), but the special characteristics of disjunctive rules are properly taken into account in the syntactic and semantic definitions of DLPfunctions presented herein. In this respect, we would like to draw the reader\u2019s attention to Definition 2.1 (item 2), Definition 2.2 (items 4\u20135), as well as Definition 3.2.\nUndoubtedly, the main result of this paper is the module theorem, i.e., Theorem 5.7, which is proved for DLP-functions in general\u2014thus covering the class of disjunctive programs. The module theorem is important as it provides a compositional semantics for disjunctive programs and it generalizes existing approaches such as those based on splitting sets (Lifschitz & Turner, 1994) and magic sets (Faber et al., 2007). Although our approach is based on a number of design decisions, e.g., as regards the definition of module composition, it nevertheless brings out the limits of modular programming in the context of a nonmonotonic declarative language. The module theorem can be exploited in a number of ways in ASP based on disjunctive logic programs. As demonstrated in Section 6, it provides the basis for decomposing disjunctive programs into their components and hence the localization of reasoning tasks. Moreover, as established in Section 7, the technique of shifting disjunctive rules can be generalized for disjunctive programs involving head-cycles. Actually, the generalized form enables us to remove shared disjunctive rules altogether but this might not be desirable due to higher space requirements. Finally, the theory of modular equivalence is fully applicable to DLP-functions as demonstrated in Section 8.\nIn addition to the results discussed above, we anticipate further applications of the module theorem in the future. We strongly believe that research in this direction not only yields results of theoretical interest but also leads to the development of practicably useful software engineering methods for ASP. In fact, first tools for decomposing and linking programs have already been implemented in the context of the smodels system.14 The results of Section 6 enable the development of analogous tools to be used with disjunctive solvers such as\n14. See modlist and lpcat in the ASP tools collection at http://www.tcs.hut.fi/Software/asptools/.\nclaspD, cmodels, dlv, and GnT. There is also an implementation of the general shifting principle, called dencode, in the ASP tool collection. The results of Section 8 pave the way for extending a translation-based verification tool, dlpeq (Janhunen & Oikarinen, 2004), for the verification of modular equivalence. Such an extension is already available in the respective tool, lpeq, for smodels programs (Oikarinen & Janhunen, 2009).15\nAcknowledgments This work was partially supported by the Academy of Finland under projects #211025 (\u201cAdvanced Constraint Programming Techniques for Large Structured Problems\u201d) and #122399 (\u201cMethods for Constructing and Solving Large Constraint Models\u201d), and by the Austrian Science Foundation (FWF) under projects P18019 (\u201cFormal Methods for Comparing and Optimizing Nonmonotonic Logic Programs\u201d) and P21698 (\u201cMethods and Methodologies for Developing Answer-Set Programs\u201d). The authors would like to thank the anonymous referees for their constructive comments as well as Martin Gebser and Torsten Schaub for their suggestion to exploit program completion and loop formulas in the proof of the module theorem. A preliminary version of this paper appeared in the proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907), Vol. 4483 of LNCS, pp. 175\u2013187, Tempe, AZ, USA, Springer."}], "references": [{"title": "Macros, macro calls and use of ensembles in modular answer set programming", "author": ["C. Baral", "J. Dzifcak", "H. Takahashi"], "venue": "Proceedings of the 22nd International Conference on Logic Programming (ICLP\u201906 ),", "citeRegEx": "Baral et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Baral et al\\.", "year": 2006}, {"title": "Propositional semantics for disjunctive logic programs", "author": ["R. Ben-Eliyahu", "R. Dechter"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Ben.Eliyahu and Dechter,? \\Q1994\\E", "shortCiteRegEx": "Ben.Eliyahu and Dechter", "year": 1994}, {"title": "Modularity in logic programming", "author": ["M. Bugliesi", "E. Lamma", "P. Mello"], "venue": "Journal of Logic Programming,", "citeRegEx": "Bugliesi et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Bugliesi et al\\.", "year": 1994}, {"title": "Negation as failure", "author": ["K.L. Clark"], "venue": "Logic and Data Bases,", "citeRegEx": "Clark,? \\Q1978\\E", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "Reducing disjunctive to non-disjunctive semantics by shift-operations", "author": ["J. Dix", "G. Gottlob", "V.W. Marek"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Dix et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Dix et al\\.", "year": 1996}, {"title": "Conflict-driven disjunctive answer set solving", "author": ["C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. K\u00f6nig", "M. Ostrowski", "T. Schaub"], "venue": "Proceedings of the 11th International Conference on Principles and Knowledge Representation and Reasoning,", "citeRegEx": "Drescher et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Drescher et al\\.", "year": 2008}, {"title": "Uniform equivalence of logic programs under the stable model semantics", "author": ["T. Eiter", "M. Fink"], "venue": "Proceedings of the 19th International Conference on Logic Programming (ICLP\u201903),", "citeRegEx": "Eiter and Fink,? \\Q2003\\E", "shortCiteRegEx": "Eiter and Fink", "year": 2003}, {"title": "Simplifying logic programs under uniform and strong equivalence", "author": ["T. Eiter", "M. Fink", "H. Tompits", "T. Woltran"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904 ),", "citeRegEx": "Eiter et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2004}, {"title": "On the computational cost of disjunctive logic programming: Propositional case", "author": ["T. Eiter", "G. Gottlob"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Eiter and Gottlob,? \\Q1995\\E", "shortCiteRegEx": "Eiter and Gottlob", "year": 1995}, {"title": "Modular logic programming and generalized quantifiers", "author": ["T. Eiter", "G. Gottlob", "H. Veith"], "venue": "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201997 ),", "citeRegEx": "Eiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 1997}, {"title": "Combining answer set programming with description logics for the Semantic Web", "author": ["T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits"], "venue": "Artificial Intelligence,", "citeRegEx": "Eiter et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2008}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Erdem and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Erdem and Lifschitz", "year": 2003}, {"title": "Magic sets and their application to data integration", "author": ["W. Faber", "G. Greco", "N. Leone"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Faber et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Faber et al\\.", "year": 2007}, {"title": "Fully abstract compositional semantics for logic programs", "author": ["H. Gaifman", "E. Shapiro"], "venue": "In Proceedings of the 16th Annual ACM Symposium on Principles of Programming Languages,", "citeRegEx": "Gaifman and Shapiro,? \\Q1989\\E", "shortCiteRegEx": "Gaifman and Shapiro", "year": 1989}, {"title": "Engineering an incremental ASP solver", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "S. Thiele"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908),", "citeRegEx": "Gebser et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2008}, {"title": "Detecting inconsistencies in large biological networks with answer set programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele", "B. Usadel", "P. Veber"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908),", "citeRegEx": "Gebser et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2008}, {"title": "Building a knowledge base: An example", "author": ["M. Gelfond", "A. Gabaldon"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Gelfond and Gabaldon,? \\Q1999\\E", "shortCiteRegEx": "Gelfond and Gabaldon", "year": 1999}, {"title": "Logic programming and knowledge representation \u2013 the A-Prolog perspective", "author": ["M. Gelfond", "N. Leone"], "venue": "Artificial Intelligence,", "citeRegEx": "Gelfond and Leone,? \\Q2002\\E", "shortCiteRegEx": "Gelfond and Leone", "year": 2002}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the 5th International Conference on Logic Programming", "citeRegEx": "Gelfond and Lifschitz,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1991\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Disjunctive defaults", "author": ["M. Gelfond", "H. Przymusinska", "V. Lifschitz", "M. Truszczy\u0144ski"], "venue": "Proceedings of the 2nd International Conference on Principles and Knowledge Representation and Reasoning,", "citeRegEx": "Gelfond et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1991}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Giunchiglia et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "Some (in)translatability results for normal logic programs and propositional theories", "author": ["T. Janhunen"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "Janhunen,? \\Q2006\\E", "shortCiteRegEx": "Janhunen", "year": 2006}, {"title": "Modular equivalence in general", "author": ["T. Janhunen"], "venue": "Proceedings of the 18th European Conference on Artificial Intelligence", "citeRegEx": "Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Janhunen", "year": 2008}, {"title": "Removing redundancy from answer set programs", "author": ["T. Janhunen"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908),", "citeRegEx": "Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Janhunen", "year": 2008}, {"title": "Unfolding partiality and disjunctions in stable model semantics", "author": ["T. Janhunen", "I. Niemel\u00e4", "D. Seipel", "P. Simons", "You", "J.-H"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Janhunen et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Janhunen et al\\.", "year": 2006}, {"title": "lpeq and dlpeq \u2013 translators for automated equivalence testing of logic programs", "author": ["T. Janhunen", "E. Oikarinen"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904 ),", "citeRegEx": "Janhunen and Oikarinen,? \\Q2004\\E", "shortCiteRegEx": "Janhunen and Oikarinen", "year": 2004}, {"title": "Automated verification of weak equivalence within the smodels system", "author": ["T. Janhunen", "T. Oikarinen"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Janhunen and Oikarinen,? \\Q2007\\E", "shortCiteRegEx": "Janhunen and Oikarinen", "year": 2007}, {"title": "Towards an efficient tableau method for boolean circuit satisfiability checking", "author": ["T. Junttila", "I. Niemel\u00e4"], "venue": "Proceedings of the First International Conference on Computational Logic (CL 2000),", "citeRegEx": "Junttila and Niemel\u00e4,? \\Q2000\\E", "shortCiteRegEx": "Junttila and Niemel\u00e4", "year": 2000}, {"title": "Enhancing disjunctive logic programming systems by SAT checkers", "author": ["C. Koch", "N. Leone", "G. Pfeifer"], "venue": "Artificial Intelligence,", "citeRegEx": "Koch et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Koch et al\\.", "year": 2003}, {"title": "Loop formulas for disjunctive logic programs", "author": ["J. Lee", "V. Lifschitz"], "venue": "Proceedings of the 19th International Conference on Logic Programming (ICLP\u201903 ), Vol. 2916 of LNCS,", "citeRegEx": "Lee and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Lee and Lifschitz", "year": 2003}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Leone et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Computing circumscription", "author": ["V. Lifschitz"], "venue": "Proceedings of the 9th International Joint Conference on Artificial Intelligence", "citeRegEx": "Lifschitz,? \\Q1985\\E", "shortCiteRegEx": "Lifschitz", "year": 1985}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Lifschitz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "A modular action description language", "author": ["V. Lifschitz", "W. Ren"], "venue": "In Proceedings of the 21st National Conference on Artificial Intelligence", "citeRegEx": "Lifschitz and Ren,? \\Q2006\\E", "shortCiteRegEx": "Lifschitz and Ren", "year": 2006}, {"title": "Splitting a logic program", "author": ["V. Lifschitz", "H. Turner"], "venue": "Proceedings of the 11th International Conference on Logic Programming", "citeRegEx": "Lifschitz and Turner,? \\Q1994\\E", "shortCiteRegEx": "Lifschitz and Turner", "year": 1994}, {"title": "Representing transition systems by logic programs", "author": ["V. Lifschitz", "H. Turner"], "venue": "Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "Lifschitz and Turner,? \\Q1999\\E", "shortCiteRegEx": "Lifschitz and Turner", "year": 1999}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhao,? \\Q2004\\E", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": null, "citeRegEx": "Marek and Truszczy\u0144ski,? \\Q1999\\E", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Applications of circumscription to formalizing commonsense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence,", "citeRegEx": "McCarthy,? \\Q1986\\E", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Niemel\u00e4,? \\Q1999\\E", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "Verifying the equivalence of logic programs in the disjunctive case", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904 ),", "citeRegEx": "Oikarinen and Janhunen,? \\Q2004\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2004}, {"title": "Achieving compositionality of the stable model semantics for smodels programs", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Oikarinen and Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2008}, {"title": "Implementing prioritized circumscription by computing disjunctive stable models", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Artificial Intelligence: Methodology, Systems, and Applications, 13th International Conference (AIMSA\u201908),", "citeRegEx": "Oikarinen and Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2008}, {"title": "A translation-based approach to the verification of modular equivalence", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Oikarinen and Janhunen,? \\Q2009\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2009}, {"title": "A theory of diagnosis from first principles", "author": ["R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "Reiter,? \\Q1987\\E", "shortCiteRegEx": "Reiter", "year": 1987}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "Simons et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Simons et al\\.", "year": 2002}], "referenceMentions": [{"referenceID": 40, "context": "Answer-set programming (ASP) (Marek & Truszczy\u0144ski, 1999; Niemel\u00e4, 1999; Gelfond & Leone, 2002) is a paradigm for declarative problem solving in which solutions of problems are described in terms of rules subject to a nonmonotonic semantics based on stable models (Gelfond & Lifschitz, 1988).", "startOffset": 29, "endOffset": 95}, {"referenceID": 21, "context": "In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs.", "startOffset": 38, "endOffset": 55}, {"referenceID": 13, "context": "In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs.", "startOffset": 94, "endOffset": 121}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al.", "startOffset": 75, "endOffset": 98}, {"referenceID": 31, "context": ", 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally.", "startOffset": 62, "endOffset": 82}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced.", "startOffset": 76, "endOffset": 657}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b). There are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving.", "startOffset": 76, "endOffset": 1043}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b). There are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving. The idea is to gradually extend a program instance in terms of additional modules, e.g., when solving AI planning problems. Moreover, theoretical results like the splitting-set theorem (Lifschitz & Turner, 1994) and the module theorem can be directly exploited in correctness proofs. For instance, it is proved by Oikarinen and Janhunen (2008b) that the models of a prioritized circumscription can be captured with disjunctive stable models using a particular translation.", "startOffset": 76, "endOffset": 1445}, {"referenceID": 15, "context": "The term goes back to Gelfond and Gabaldon (1999) who introduced LP-functions as (partial) definitions of new relations in terms of old, known ones.", "startOffset": 22, "endOffset": 50}, {"referenceID": 13, "context": "However, arbitrary combinations of program modules are not meaningful and, first of all, we adopt syntactic restrictions introduced by Gaifman and Shapiro (1989) from the context of negation/disjunction-free logic programs.", "startOffset": 135, "endOffset": 162}, {"referenceID": 3, "context": "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step.", "startOffset": 63, "endOffset": 76}, {"referenceID": 3, "context": "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs\u2014neither involving default negation nor disjunctions.", "startOffset": 64, "endOffset": 472}, {"referenceID": 3, "context": "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs\u2014neither involving default negation nor disjunctions. As observed by them, too, syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models.2 In the current paper, we strive for analogous results but in the case of programs permitting both default negation and disjunctions. It turns out that strongly connected components of positive dependency graphs provide a key criterion when it comes to confining program composition. The compositionality properties of disjunctive programs under stable-model semantics have also arisen in the context of the so-called splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). In fact, the module theorem established herein is a proper generalization of its predecessor (Oikarinen & Janhunen, 2008a). We illustrate the potential of our modular architecture by the evaluation of quantified Boolean formulas (QBFs), which serve as canonical representatives of the classes of the polynomial-time hierarchy (PH). Due to basic complexity results established by Eiter and Gottlob (1995), it is natural from our perspective to concentrate on the second level of the PH in the case of disjunctive programs.", "startOffset": 64, "endOffset": 1651}, {"referenceID": 13, "context": "The main concern of Gaifman and Shapiro (1989) is modularity with respect to the logical consequences of a definite program and hence the intersection of its Herbrand models.", "startOffset": 20, "endOffset": 47}, {"referenceID": 13, "context": "To this end, we extend a definition originally proposed by Gaifman and Shapiro (1989) to the case of disjunctive programs.", "startOffset": 59, "endOffset": 86}, {"referenceID": 16, "context": "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).", "startOffset": 77, "endOffset": 105}, {"referenceID": 16, "context": "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).", "startOffset": 77, "endOffset": 122}, {"referenceID": 16, "context": "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).", "startOffset": 77, "endOffset": 158}, {"referenceID": 13, "context": "As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs.", "startOffset": 23, "endOffset": 50}, {"referenceID": 13, "context": "As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs. Thus, program union as operator for composition without further restrictions is not satisfactory with respect to compositionality. We start by adapting the construction of Gaifman and Shapiro (1989) to the case of disjunctive programs.", "startOffset": 23, "endOffset": 451}, {"referenceID": 13, "context": "The first three of the conditions above are due to Gaifman and Shapiro (1989) and they imply that the sets O1, H1, O2, and H1 are mutually pairwise distinct.", "startOffset": 51, "endOffset": 78}, {"referenceID": 22, "context": "As observed by Oikarinen and Janhunen (2008a), the heads of choice rules possessing multiple atoms can be freely split without affecting their semantics.", "startOffset": 29, "endOffset": 46}, {"referenceID": 22, "context": "Consequently, the length of \u03a0 in symbols, denoted by \u2016\u03a0\u2016, gives an upper bound for |At(\u03a0)| which is important when one considers the computational cost of translating programs (Janhunen, 2006).", "startOffset": 176, "endOffset": 192}, {"referenceID": 15, "context": "In formal terms, a DLP-function \u03a0 = \u3008R, I,O,H\u3009 is designed to provide a mapping from subsets of I to a set of subsets of O \u222a H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored.", "startOffset": 168, "endOffset": 196}, {"referenceID": 15, "context": "In formal terms, a DLP-function \u03a0 = \u3008R, I,O,H\u3009 is designed to provide a mapping from subsets of I to a set of subsets of O \u222a H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored. In the sequel, the (syntactic) class of DLP-functions is denoted by D. It is assumed, for the sake of simplicity, that D spans over a fixed (at most denumerable) signature At(D)8 so that At(\u03a0) \u2286 At(D) holds for each DLP-function \u03a0 \u2208 D. Given DLP-functions \u03a01, \u03a02, and \u03a03 that pairwise respect the input/output interfaces of each other, it holds that \u2022 \u03a01 \u2295\u03a02 \u2208 D (closure), \u2022 \u03a01 \u2295\u2205 = \u2205\u2295\u03a01 = \u03a01, for the empty DLP-function \u2205 = \u3008\u2205, \u2205, \u2205, \u2205\u3009 (identity), \u2022 \u03a01 \u2295\u03a02 = \u03a02 \u2295\u03a01 (commutativity), and \u2022 \u03a01 \u2295 (\u03a02 \u2295\u03a03) = (\u03a01 \u2295\u03a02)\u2295\u03a03 (associativity). The theory of modules put forth by Oikarinen and Janhunen (2008a) is based on a more restrictive operator for program composition, viz.", "startOffset": 168, "endOffset": 929}, {"referenceID": 1, "context": "Technically speaking, we define the positive dependency graph DG(\u03a0) of a DLP-function \u03a0 = \u3008R, I,O,H\u3009 using only positive dependencies\u2014following the definition by Ben-Eliyahu and Dechter (1994). However, we exclude input atoms from the graph as their definitions are external to \u03a0 anyway.", "startOffset": 162, "endOffset": 193}, {"referenceID": 32, "context": "Handling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them.", "startOffset": 127, "endOffset": 160}, {"referenceID": 39, "context": "Handling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them.", "startOffset": 127, "endOffset": 160}, {"referenceID": 18, "context": "In order to cover arbitrary DLP-functions, we interpret negative body literals in the way proposed by Gelfond and Lifschitz (1991).", "startOffset": 102, "endOffset": 131}, {"referenceID": 3, "context": ", a DLP-function \u03a0 of the form \u3008R, \u2205, O, \u2205\u3009, can be characterized via classical propositional logic, using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003).", "startOffset": 134, "endOffset": 147}, {"referenceID": 30, "context": ", Ato(\u03a0) \u222a Ath(\u03a0) = At(\u03a0), the completion Comp(\u03a0) reduces to the definition provided by Lee and Lifschitz (2003) and the same holds for the set LF(\u03a0) of loop formulas.", "startOffset": 88, "endOffset": 113}, {"referenceID": 30, "context": "In turn, we know that Mo \u222aMh |= Comp(\u03a0/Mi)\u222aLF(\u03a0/Mi) iff Mo \u222aMh is a stable model of the program \u03a0/Mi by the results of Lee and Lifschitz (2003); recall that \u03a0/Mi is an ordinary disjunctive program without any input atoms.", "startOffset": 119, "endOffset": 144}, {"referenceID": 3, "context": "Since each \u201cordinary\u201d program can be represented as a DLP-function, we thus properly generalize the well-known completion semantics (Clark, 1978).", "startOffset": 132, "endOffset": 145}, {"referenceID": 30, "context": "Then, the notion of Ati(\u03a0)tightness coincides with ordinary tightness, and the definition of the completion Comp(\u03a0) reduces to the one provided by Lee and Lifschitz (2003).", "startOffset": 147, "endOffset": 172}, {"referenceID": 32, "context": "3 to a comparison with the splitting set theorem proven by Lifschitz and Turner (1994).", "startOffset": 59, "endOffset": 87}, {"referenceID": 31, "context": "The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques.", "startOffset": 48, "endOffset": 68}, {"referenceID": 31, "context": "The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques. The simplified encoding provided by Koch, Leone, and Pfeifer (2003) is based on two kinds of disjunctive rules:", "startOffset": 48, "endOffset": 287}, {"referenceID": 22, "context": "Quite recently, Oikarinen and Janhunen (2008b) presented an efficient encoding of prioritized circumscription as a disjunctive program (and thus, as a special case, of parallel circumscription as well)\u2014enabling a concise representation of minimal diagnoses in the sense of Reiter (1987).", "startOffset": 30, "endOffset": 47}, {"referenceID": 22, "context": "Quite recently, Oikarinen and Janhunen (2008b) presented an efficient encoding of prioritized circumscription as a disjunctive program (and thus, as a special case, of parallel circumscription as well)\u2014enabling a concise representation of minimal diagnoses in the sense of Reiter (1987). The resulting disjunctive rules involve head-cycles (see Section 7 for details) which typically pre-empt a polynomial-time translation into a computationally easier normal logic program.", "startOffset": 30, "endOffset": 287}, {"referenceID": 22, "context": "The design of \u03a0sat n and \u03a0 unsat n is based on the explanatory approach from Janhunen et al. (2006), where (19) is equivalently viewed as a formula \u2203X\u00ac\u2203Y \u00ac\u03c6 having the matrix \u00ac\u03c6 in conjunctive normal form (CNF).", "startOffset": 77, "endOffset": 100}, {"referenceID": 22, "context": "Concerning the correctness of the representation given in Figure 2, due to an existing proof by Janhunen et al. (2006), we only present the main steps\u2014fully exploiting the benefits from our modular approach.", "startOffset": 96, "endOffset": 119}, {"referenceID": 32, "context": "According to Lifschitz and Turner (1994), a solution to R with respect to U \u2286 O is a pair \u3008X,Y \u3009 where X \u2286 U , Y \u2286 O\\U , X \u2208 SM(bU (R)), and Y \u2208 SM(tU (R)/X).", "startOffset": 13, "endOffset": 41}, {"referenceID": 22, "context": "As previously demonstrated by Oikarinen and Janhunen (2008a), splitting sets are applicable to DLPfunctions like \u03a0 = \u3008{a \u2190 \u223cb; b \u2190 \u223ca}, \u2205, {a, b}, \u2205\u3009 only in the trivial way, i.", "startOffset": 44, "endOffset": 61}, {"referenceID": 20, "context": "We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper.", "startOffset": 62, "endOffset": 102}, {"referenceID": 4, "context": "We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper.", "startOffset": 62, "endOffset": 102}, {"referenceID": 7, "context": "As shown by Eiter et al. (2004), such a local shifting transformation preserves ordinary equivalence, i.", "startOffset": 12, "endOffset": 32}, {"referenceID": 22, "context": "Equivalence of DLP-Functions The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006).", "startOffset": 217, "endOffset": 233}, {"referenceID": 22, "context": "Equivalence of DLP-Functions The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of logic program modules\u2014giving rise to the notion of modular equivalence for logic programs.", "startOffset": 218, "endOffset": 266}, {"referenceID": 22, "context": "2 Verifying Modular Equivalence Oikarinen and Janhunen (2004) proposed a translation-based method for the verification of weak equivalence of disjunctive logic programs.", "startOffset": 46, "endOffset": 62}, {"referenceID": 22, "context": "The idea behind the translation-based method of Oikarinen and Janhunen (2004) is that ordinary disjunctive programs R1 and R2 are weakly equivalent iff their translations TR(R1, R2) and TR(R2, R1) have no stable models.", "startOffset": 62, "endOffset": 78}, {"referenceID": 22, "context": "The translation TR(\u03a02) for the minimality check essentially contains the same rules as TR(R1, R2) \\ R1, where TR(R1, R2) is the translation defined by Oikarinen and Janhunen (2004) for sets R1 and R2 of disjunctive rules.", "startOffset": 165, "endOffset": 181}, {"referenceID": 7, "context": "Related Work Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over relational databases.", "startOffset": 13, "endOffset": 34}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated.", "startOffset": 50, "endOffset": 71}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey.", "startOffset": 50, "endOffset": 664}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion.", "startOffset": 50, "endOffset": 1149}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7): tclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y). Here, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule loop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations.", "startOffset": 50, "endOffset": 2220}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7): tclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y). Here, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule loop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion.", "startOffset": 50, "endOffset": 2976}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7): tclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y). Here, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule loop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion. The outcome determines the meaning of the modular description via an embedding into ASP (Lifschitz & Turner, 1999). Faber, Greco, and Leone (2007) apply the magic-set method in the evaluation of datalog programs with negation.", "startOffset": 50, "endOffset": 3220}, {"referenceID": 12, "context": "Hence, the module theorem provided by Faber et al. (2007) can be viewed as a special case of the splitting-set theorem and, therefore, observations presented in Section 5.", "startOffset": 38, "endOffset": 58}, {"referenceID": 12, "context": "The module theorem is important as it provides a compositional semantics for disjunctive programs and it generalizes existing approaches such as those based on splitting sets (Lifschitz & Turner, 1994) and magic sets (Faber et al., 2007).", "startOffset": 217, "endOffset": 237}], "year": 2009, "abstractText": "Practically all programming languages allow the programmer to split a program into several modules which brings along several advantages in software development. In this paper, we are interested in the area of answer-set programming where fully declarative and nonmonotonic languages are applied. In this context, obtaining a modular structure for programs is by no means straightforward since the output of an entire program cannot in general be composed from the output of its components. To better understand the effects of disjunctive information on modularity we restrict the scope of analysis to the case of disjunctive logic programs (DLPs) subject to stable-model semantics. We define the notion of a DLP-function, where a well-defined input/output interface is provided, and establish a novel module theorem which indicates the compositionality of stable-model semantics for DLP-functions. The module theorem extends the well-known splitting-set theorem and enables the decomposition of DLP-functions given their strongly connected components based on positive dependencies induced by rules. In this setting, it is also possible to split shared disjunctive rules among components using a generalized shifting technique. The concept of modular equivalence is introduced for the mutual comparison of DLP-functions using a generalization of a translation-based verification method.", "creator": "dvips(k) 5.96 Copyright 2005 Radical Eye Software"}}}