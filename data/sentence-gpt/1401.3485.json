{"id": "1401.3485", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Hypertableau Reasoning for Description Logics", "abstract": "We present a novel reasoning calculus for the description logic SHOIQ^+---a knowledge representation formalism with applications in areas such as the Semantic Web. Unnecessary nondeterminism and the construction of large models are two primary sources of inefficiency in the tableau-based reasoning calculi used in state-of-the-art reasoners. In order to reduce nondeterminism, we base our calculus on hypertableau and hyperresolution calculi, which we extend with a blocking condition to ensure termination of the semantics. The argument below is a simplified version of our argument.\n\n\n\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 53 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 111 112 113 114 116 117 118 119 120 121 123 125 127 128 129 130 131 132 133 135 136 137 138 139 140 141 142 143 144 145 146 148 149 150 151 152 155 157 159 161 162 163 164 165 166 167 168 169 171 173 176 177 178 179 181 182 183 184 185 187 188 189 190 191 193 195 196 197 198 199 200 201 2 3 4 5 6 7 8 9 10 11", "histories": [["v1", "Wed, 15 Jan 2014 05:37:06 GMT  (519kb)", "http://arxiv.org/abs/1401.3485v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["boris motik", "rob shearer", "ian horrocks"], "accepted": false, "id": "1401.3485"}, "pdf": {"name": "1401.3485.pdf", "metadata": {"source": "CRF", "title": "Hypertableau Reasoning for Description Logics", "authors": ["Boris Motik", "Rob Shearer", "Ian Horrocks"], "emails": ["boris.motik@comlab.ox.ac.uk", "rob.shearer@comlab.ox.ac.uk", "ian.horrocks@comlab.ox.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "Description Logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2007) are a family of knowledge representation formalisms with well-understood formal properties. DLs have been applied to numerous problems in computer science such as information integration and metadata management. Recent interest in DLs has been spurred by their application in the Semantic Web: the DL SHOIQ provides the logical underpinning for the Web Ontology Language (OWL) (Patel-Schneider, Hayes, & Horrocks, 2004), and the DL SROIQ (Kutz, Horrocks, & Sattler, 2006) is used in OWL 2\u2014an extension of OWL currently being standardized by the World Wide Web Consortium.\nA central component of most DL applications is an efficient and scalable reasoner. Modern reasoners, such as Pellet (Parsia & Sirin, 2004), FaCT++ (Tsarkov & Horrocks, 2006), and RACER (Haarslev & Mo\u0308ller, 2001), are typically based on tableau calculi (Baader & Nutt, 2007), which demonstrate the (un)satisfiability of a knowledge base K via a constructive search for an abstraction of a model of K. Numerous optimizations have been developed in an effort to reduce the size of the search space (Horrocks, 2007). Despite major advances in tableau reasoning algorithms, however, ontologies are still encountered in practice that cannot be handled by existing DL reasoners. Two main sources of complexity in tableau calculi have been identified in the literature (Donini, 2007).\nThis first source of complexity is known as or-branching : given a disjunctive assertion\nc\u00a92009 AI Access Foundation. All rights reserved.\n(C tD)(s), a tableau algorithm nondeterministically guesses that either C(s) or D(s) holds. To show the unsatisfiability of K, every possible guess must lead to a contradiction: if assuming that C(s) holds leads to a contradiction, the algorithm must backtrack and assume that D(s) holds, which can give rise to exponential behavior. General concept inclusions (GCIs)\u2014implications of the form C v D\u2014are the main source of disjunctions: to ensure that C v D holds, a tableau algorithm adds a disjunction (\u00acC tD)(s) to each individual s in the model. Various absorption optimizations (Horrocks, 1998; Tsarkov & Horrocks, 2004; Hudek & Weddell, 2006; Horrocks, 2007) have been developed to reduce the nondeterminism in tableau calculi.\nThe second source of complexity in tableau calculi is known as and-branching : the expansion of a model due to existential quantifiers can generate very large models. Apart from memory consumption problems, and-branching can increase or-branching by increasing the number of individuals to which GCIs are applied.\nIn this paper, we present a reasoning calculus that addresses both sources of complexity. We focus on the DL SHOIQ+, which is obtained by extending SHOIQ with local reflexivity and disjoint, reflexive, irreflexive, symmetric, and asymmetric roles. SROIQ further extends SHOIQ+ with generalized role inclusions of the form R1 \u25e6 . . . \u25e6Rn v R. Generalized role inclusions can be encoded using standard GCIs as proposed by Demri and de Nivelle (2005); thus, by adding a suitable preprocessing phase, the results from this paper should allow us to handle SROIQ (and hence OWL 2) as well.\nOur algorithm can be viewed as a hybrid of resolution and tableau, and is related to the hypertableau (Baumgartner, Furbach, & Niemela\u0308, 1996) and hyperresolution (Robinson, 1965) calculi. It first preprocesses a SHOIQ+ knowledge base into a set of DL-clauses\u2014 universally quantified implications containing DL concepts and roles as predicates. The main derivation rule for DL-clauses is hyperresolution: an atom from the consequent of a DL-clause is derived only if all atoms from the DL-clause antecedent can be matched to already derived consequences. Hyperresolution is very effective at restricting or-branching. Consider, for example, the following example:\nR(x, y1) \u2227 S(x, y2)\u2192 A(x) \u2228B(y1) \u2228 C(y2)(1)\nThis DL-clause derives a disjunction only if it is applied to assertions of the form R(a, b) and S(c, d) where a = c. The presence of variables in (1) allows us to simultaneously work with individuals a, b, c and d, and to check whether a = c. In contrast, derivation rules in tableau algorithms consider at most pairs of individuals; consequently, no absorption technique we are aware of can localize nondeterminism only to the individuals that satisfy the mentioned constraints. As we discuss in detail in Section 3.3.1, our calculus generalizes all known absorption variants. Furthermore, in contrast to absorption techniques, our algorithm is guaranteed to exhibit no nondeterminism on Horn knowledge bases (Hustadt, Motik, & Sattler, 2005) such as GALEN, NCI, and SNOMED CT (see Section 7). Finally, our calculus provides a uniform proof-theoretic framework that can handle several useful extensions of commonly used DLs (see Section 4.1.3).\nHyperresolution decides many fragments of first-order logic (e.g., Fermu\u0308ller, Leitsch, Hustadt, & Tammet, 2001; Fermu\u0308ller, Tammet, Zamov, & Leitsch, 1993), as well as description and modal logics (e.g., Georgieva, Hustadt, & Schmidt, 2003; Hustadt & Schmidt, 1999). Unlike most of these fragments, SHOIQ+ allows for cyclic GCIs of the form\nC v \u2203R.C, on which hyperresolution can generate infinite paths of successors. To ensure termination, we use the pairwise blocking technique (Horrocks, Sattler, & Tobies, 2000b) to detect cyclic computations. Due to hyper-inferences, the soundness and correctness proofs by Horrocks et al. (2000b) do not carry over immediately to our calculus; in fact, certain simpler blocking conditions applicable to weaker DLs cannot be straightforwardly transferred to our setting. To limit and-branching, we extend the blocking condition by Horrocks et al. to anywhere pairwise blocking : an individual can be blocked by another individual that is not necessarily its ancestor, which can reduce the sizes of the constructed models. Anywhere blocking has already been used with single blocking (Buchheit, Donini, & Schaerf, 1993; Baader, Buchheit, & Hollunder, 1996; Donini & Massacci, 2000; Donini, Lenzerini, Nardi, & Schaerf, 1998); however, to the best of our knowledge, it has been neither used with the more sophisticated pairwise blocking nor tested in practice.\nEnsuring termination of a tableau decision procedure for DLs with nominals, inverse roles, and number restrictions has proven notoriously difficult. This problem was finally solved by Horrocks and Sattler (2007) by extending the tableau calculus with a nominal introduction rule. In certain situations, this rule guesses and introduces new nominals, and is thus a potential source of inefficiency in practice. In this paper, we present a variant of this rule that is simpler and more efficient.\nWe have implemented our calculus in a new reasoner called HermiT.1 Even with a rather na\u0308\u0131ve implementation, the deterministic treatment of GCIs significantly reduces classification times for several real-world ontologies. Furthermore, pairwise anywhere blocking seems to be very effective in limiting model sizes and it allows HermiT to classify several ontologies that, to the best of our knowledge, no other reasoner can handle."}, {"heading": "2. Preliminaries", "text": "We now define the syntax and the semantics of the description logic SHOIQ+. A signature is a triple \u03a3 = (NR, NC , NI) consisting of mutually disjoint sets of atomic roles NR, atomic concepts NC , and individuals NI . The set of roles is then NR \u222a {R\u2212 | R \u2208 NR}. The function inv(\u00b7) is defined on the set of roles as follows, where R is an atomic role: inv(R) = R\u2212 and inv(R\u2212) = R. An RBox R is a finite set of axioms of the form R1 v R2 (role inclusion), Dis(S1, S2) (role disjointness), Ref(R) (reflexivity), Irr(S) (irreflexivity), Sym(R) (symmetry), Asy(S) (asymmetry), and Tra(R) (transitivity), where R, R1, and R2 are roles, and S, S1, and S2 are simple roles, as defined next. Let v\u2217R be the reflexive-transitive closure of the following relation: {(R1, R2) | R1 v R2 \u2208 R or inv(R1) v inv(R2) \u2208 R}. A role R is transitive in R if a role R\u2032 exists such that R\u2032 v\u2217R R, R v\u2217R R\u2032, and either Tra(R\u2032) \u2208 R or Tra(inv(R\u2032)) \u2208 R. A role S is simple if no transitive role R exists such that R v\u2217R S. The set of concepts is the smallest set containing > (the top concept), \u22a5 (the bottom concept), A (atomic concept), {a} (nominal), \u00acC (negation), C uD (conjunction), C tD (disjunction), \u2203R.C (existential restriction), \u2200R.C (universal restriction), \u2203S.Self (local reflexivity), \u2265 nS.C (at-least restriction), and \u2264 nS.C (at-most restriction), for A an atomic concept, a an individual, C and D concepts, R a role, S a simple role, and n a nonnegative integer. A TBox T is a finite set of general concept inclusions (GCIs) C v D for C and D concepts. An ABox A is a finite set of assertions of the form C(a) (concept assertion), R(a, b)\n1. http://www.hermit-reasoner.com/\n(role assertion), a \u2248 b (equality assertion), and a 6\u2248 b (inequality assertion), where C is a concept, R is a role, and a and b are individuals. A SHOIQ+ knowledge base K is a triple (R, T ,A). With |K| we denote the size of K\u2014that is, the number of symbols required to encode K on the input tape of a Turing machine (numbers can be coded in binary).\nAn interpretation for K is a tuple I = (4I , \u00b7I), where 4I is a nonempty set, and \u00b7I assigns an element aI \u2208 4I to each individual a, a set AI \u2286 4I to each atomic concept A, and a relation RI \u2286 4I\u00d74I to each atomic role R. The function \u00b7I is extended to concepts and roles as shown in the upper part of Table 1. I is a model of K, written I |= K, if it satisfies all axioms of K as shown in the lower part of Table 1. The basic inference problem for SHOIQ+ is checking whether K is satisfiable\u2014that is, checking whether a model of K exists. A concept C subsumes a concept D, written K |= C v D, if CI \u2286 DI for each model I of K. It is easy to see that K |= C v D if and only if K \u222a {(C u \u00acD)(a)} is unsatisfiable, where a is an individual that does not occur in K (Baader & Nutt, 2007).\nThe negation-normal form nnf(C) of a concept C is the concept obtained from C by using de Morgan\u2019s laws, the dualities between existential and universal restrictions, and the dualities between at-least and at-most restrictions to push negations inwards so that they occur only in front of atomic concepts, nominals, and local reflexivity concepts. The concept nnf(C) is logically equivalent to C, and it can be computed from C in time linear in the size of C (Baader & Nutt, 2007). We use \u00ac\u0307C to denote nnf(\u00acC).\nAs mentioned in Section 1, extending SHOIQ+ with general role inclusions would yield SROIQ (Kutz et al., 2006)\u2014the DL that underpins OWL 2. ALCHOIQ+ is obtained from SHOIQ+ by disallowing transitivity axioms. SHIQ+ is obtained from SHOIQ+ by disallowing nominals. SHOQ+ is obtained from SHOIQ+ by disallowing inverse roles. SHOIQ and SHIQ are obtained from SHOIQ+ and SHIQ+, respectively, by disallow-\ning local reflexivity, role disjointness, reflexivity, irreflexivity, symmetry, and asymmetry axioms. Finally, SHOI is obtained from SHOIQ by disallowing at-least and at-most restrictions."}, {"heading": "3. Motivation and Algorithm Overview", "text": "In this section, we present an overview of the main aspects of our algorithm. We explain in Section 3.1 the root causes of the scalability problems encountered in tableau algorithms, and in Section 3.2 we outline how we address them. Finally, in Section 3.3 we discuss the relationship between our algorithm and some related approaches."}, {"heading": "3.1 Causes of Scalability Problems in Tableau Algorithms", "text": "To show that a knowledge base K = (R, T ,A) is satisfiable, a tableau algorithm constructs a derivation\u2014a sequence of ABoxes A0,A1, . . . ,An where A0 = A and each Ai is obtained from Ai\u22121 by an application of one derivation rule.2 The derivation rules make the information implicit in the axioms of R and T explicit, and thus evolve the ABox A towards a (representation of a) model of K. The algorithm terminates either if no derivation rule is applicable to some An, in which case An represents a model of K, or if An contains an obvious contradiction, in which case the model construction has failed. The following derivation rules are commonly used in DL tableau calculi.\n\u2022 t-rule: Given (C1 t C2)(s), derive either C1(s) or C2(s).\n\u2022 u-rule: Given (C1 u C2)(s), derive C1(s) and C2(s).\n\u2022 \u2203-rule: Given (\u2203R.C)(s), derive R(s, t) and C(t) for t a fresh individual.\n\u2022 \u2200-rule: Given (\u2200R.C)(s) and R(s, t), derive C(t).\n\u2022 v-rule: Given a GCI C v D and an individual s, derive (\u00acC tD)(s).\nThe t-rule is nondeterministic: if (C1tC2)(s) is true, then C1(s) or C2(s) or both are true. Therefore, tableau calculi make a nondeterministic guess and choose either C1 or C2; if one choice leads to a contradiction, the algorithm must backtrack and try the other choice. Thus, K is unsatisfiable only if all choices lead to a contradiction. We next discuss two sources of complexity inherent in the tableau derivation rules."}, {"heading": "3.1.1 Or-Branching", "text": "Handing disjunctions through reasoning by case is often called or-branching. The v-rule adds a disjunction for each GCI to each individual in an ABox and is thus a major source of or-branching and inefficiency (Horrocks, 2007). Consider, for example, the knowledge base K1 = (\u2205, T1,A1), with T1 and A1 specified as follows:\nT1 = {\u2203R.A v A} A1 = {\u00acA(a0), R(a0, b1), R(b1, a1), . . . , R(an\u22121, bn), R(bn, an), A(an)} (2)\n2. Some formalizations of tableau algorithms work on completion graphs (Horrocks & Sattler, 2007), which have a natural correspondence to ABoxes.\nThe ABox A1 is graphically shown in Figure 1. The individuals occurring in the ABox are represented as black dots, an assertion of the form A(a0) is represented by placing A next to the individual a0, and an assertion of the form R(a0, b1) is represented as an R-labeled arrow from a0 to b1. Initially, A1 contains only the concept assertions shown in line (i).\nTo satisfy the GCI in T1, a tableau algorithm applies the v-rule, thus adding the assertions shown in line (ii) of Figure 1. Tableau algorithms are usually free to choose the order in which they process the assertions in an ABox; in fact, finding an order that exhibits good performance in practice requires advanced heuristics (Tsarkov & Horrocks, 2005b). Let us assume that the algorithm chooses to process the assertions on ai before those on bj . Hence, by applying the derivation rules to all ai, a tableau algorithm derives the assertions shown in line (iii) of Figure 1; after that, by applying the derivation rules to all bi, the algorithm derives the assertions shown in line (iv) of Figure 1. The ABox now contains both A(an) and \u00acA(an), which is a contradiction. Thus, the algorithm needs to backtrack its most recent choice, so it flips its guess on bn\u22121 to A(bn\u22121). This generates a contradiction on bn\u22121, so the algorithm backtracks from all guesses for bi, changes the guess on an to A(an), and repeats the work for all bi. This also leads to a contradiction, so the algorithm must revise its guess for an\u22121; but then, two guesses are again possible for an. In general, after revising a guess for ai, all possibilities for aj , i < j \u2264 n, must be reexamined, which results in exponential behavior. None of the standard backtracking optimizations (Horrocks, 2007) are helpful: the problem arises because the order in which the individuals are processed makes the guesses on ai independent from the guesses on aj for i 6= j.\nThe GCI \u2203R.A v A, however, is not inherently nondeterministic: it is equivalent to the Horn clause \u2200x, y : [R(x, y) \u2227A(y)\u2192 A(x)], which can be applied bottom-up to derive the assertions A(bn), A(an\u22121), . . . , A(a0) and eventually reveal a contradiction on a0. These inferences are deterministic,3 so we can conclude that K1 is unsatisfiable without any backtracking. This example suggests that the processing of GCIs in tableau algorithms can be \u201cunnecessarily\u201d nondeterministic. Hustadt et al. (2005) have identified a class of knowledge bases without \u201cunnecessary\u201d nondeterminism: knowledge bases expressed in the description logic Horn-SHIQ can always be translated into Horn clauses, suggesting that reasoning without any nondeterminism is possible in principle. Ideally, a practical DL reasoning procedure should exhibit no nondeterminism on Horn knowledge bases.\n3. More precisely, each inference is deterministic, but the order in which the inferences are performed is don\u2019t-care nondeterministic.\nIn the context of tableau calculi, various absorption optimizations (Horrocks, 2007) have been developed to control the nondeterminism arising in the application of GCIs. We discuss these optimizations in depth in Section 3.3.1."}, {"heading": "3.1.2 And-Branching", "text": "The introduction of new individuals in the \u2203-rule is often called and-branching, and it is another major source of inefficiency in tableau algorithms (Donini, 2007). Consider, for example, the (satisfiable) knowledge base K2 = (\u2205, T2,A2), with T2 and A2 specified as follows (where n and m are integers):\nT2 = { A1 v \u2265 2S.A2, . . . , An\u22121 v \u2265 2S.An, An v A1, Ai v (B1 t C1) u . . . u (Bm t Cm) for 1 \u2264 i \u2264 n }\nA2 = { A1(a) } (3)\nAt-least restrictions are dealt with in tableau algorithms by the \u2265-rule, which is quite similar to the \u2203-rule: from (\u2265 nR.C)(s), the \u2265-rule derives R(s, ti) and C(ti) for 1 \u2264 i \u2264 n, and ti 6\u2248 tj for 1 \u2264 i < j \u2264 n. Thus, the assertion A1(a) implies the existence of at least two individuals in A2, which imply the existence of at least two individuals in A3, and so on. Given K2, a tableau algorithm thus constructs a binary tree, shown in Figure 2a, in which each individual is labeled with some Ai and an element of \u03a0 = {B1, C1} \u00d7 . . .\u00d7 {Bm, Cm}. All individuals in the tree at depth n are instances of An; because of the GCI An v A1, these individuals must be instances of A1 as well, so we can repeat the whole construction and generate an even deeper tree. Clearly, a na\u0308\u0131ve application of the tableau rules does not terminate if the TBox contains existential quantifiers in cycles.\nTo ensure termination is such cases, tableau algorithms employ blocking (Baader & Nutt, 2007), which is based on an important observation about the shape of ABoxes that can be derived from some input ABox A. The individuals in A are called named (shown as black circles), and they can be connected by role assertions in an arbitrary way. The individuals introduced by the \u2203- and \u2265-rules are called blockable (shown as white circles). For example, if \u2203R.C(a) is expanded into R(a, s) and C(s), then s is called a blockable individual and it is an R-successor of a. It is not difficult to see that, if the knowledge base does not contain\nnominals, no tableau derivation rule can connect s with an arbitrary named individual: the individual s can participate only in inferences that derive an assertion of the form D(s) with D a concept, create a new successor of s, connect s to an existing predecessor or successor, or, in the presence of (local) reflexivity, connect s to itself. Hence, each ABox A\u2032 obtained from A can be seen as a \u201cforest\u201d of the form shown in Figure 3: each named individual can be arbitrarily connected to other named individuals and to a tree of blockable successors. The concept label LA(s) is defined as the set of all concepts C such that C(s) \u2208 A, and the edge label LA(s, s\u2032) as the set of all atomic roles such that R(s, s\u2032) \u2208 A.\nThe forest-like structure of ABoxes enables blocking. Description logics such as SHIQ+ and SHOIQ+ allow for inverse roles and number restrictions, which has been handled in the literature by ancestor pairwise blocking (Horrocks et al., 2000b): for individuals s, s\u2032, t, and t\u2032 occurring in an ABox A as shown in Figure 3, t blocks s (shown by a double border on s) if and only if LA(s) = LA(t), LA(s\u2032) = LA(t\u2032), LA(s, s\u2032) = LA(t, t\u2032), and LA(s\u2032, s) = LA(t\u2032, t).4 In tableau algorithms, the \u2203- and \u2265-rules are applicable only to nonblocked individuals, which ensures termination: the number of different concept and edge labels is exponential in |K|, so an exponentially long branch in a forest-like ABox must contain a blocked individual, thus limiting the length of each branch in an ABox. Let A be an ABox as in Figure 3 to which no tableau derivation rule is applicable, and in which s is blocked by t. We can construct a model from A by unraveling\u2014that is, by replicating the fragment between s and t infinitely often. Intuitively, blocking ensures that the part of the ABox between s and s\u2032 \u201cbehaves\u201d just like the part between t and t\u2032, so unraveling indeed generates a model. If our logic were able to connect blockable individuals in a nontree-like way, then unraveling would not generate a model; in fact, the notion of ancestors, descendants, and blocking would itself be ill-defined.\nConsider now an \u201cunlucky\u201d run of a tableau algorithm with ancestor pairwise blocking on K2. The number of elements in \u03a0 is exponential in |K2|, so it can happen that blocking comes into effect only after the algorithm constructs an exponentially deep tree; since the tree is binary, it is doubly exponential in total. In a \u201clucky\u201d run, the algorithm can always pick Bj instead of Cj ; then, the algorithm constructs a polynomially deep binary tree, so\n4. Our blocking definition must include both edge labels in both directions because, unlike in some other tableau formalizations, our edge labels include only atomic roles.\nthe tree is exponential in total. Thus, the and-branching caused by the \u2203- and \u2265-rules can lead to unnecessary generation of an ABox that is doubly exponential in the size of the input, which limits the scalability of tableau algorithms in practice."}, {"heading": "3.2 The Hypertableau Algorithm at a Glance", "text": "In this section we present an informal overview of our hypertableau algorithm that addresses the problems due to or- and and-branching outlined in Section 3.1. We then formalize the algorithm in Section 4."}, {"heading": "3.2.1 Derivation Rules", "text": "The hyperresolution calculus (Robinson, 1965) has often been used for first-order theorem proving. It works on clauses\u2014implications of the form \u2227n i=1 Ui \u2192 \u2228m j=1 Vj where Ui\nand Vj are first-order atoms. The conjunction \u2227n i=1 Ui is called the antecedent, and the\ndisjunction \u2228m j=1 Vj is called the consequent ; we sometimes omit \u2192 if the antecedent is empty. For Di a possibly empty disjunction of literals and \u03c3 the most general unifier of (A1, B1), . . . , (Am, Bm), the hyperresolution derivation rule is defined as follows (assuming that the unifier \u03c3 exists):5\nA1 \u2228D1 . . . Am \u2228Dm B1 \u2227 . . . \u2227Bm \u2192 C1 \u2228 . . . \u2228 Ck D1\u03c3 \u2228 . . . \u2228Dm\u03c3 \u2228 C1\u03c3 \u2228 . . . \u2228 Ck\u03c3\nTo make the calculus refutationally complete for first-order logic, one additionally needs a factoring derivation rule, which we do not discuss any further.\nThe hypertableau calculus (Baumgartner et al., 1996) is based on the observation that, if the literals in C1\u03c3 \u2228 . . . \u2228 Cn\u03c3 do not share variables, we can replace the clause with a nondeterministically chosen atom Ci\u03c3 that we assume to be true. If we assume that all clauses are safe (i.e., that each variable occurring in a clause also occurs in the clause\u2019s antecedent), then Ai \u2228Di and C1\u03c3 \u2228 . . . \u2228 Cn\u03c3 are always ground, so they can always be nondeterministically split into atoms. Such a hypertableau inference is written as\nA1 . . . Am B1 \u2227 . . . \u2227Bm \u2192 C1 \u2228 . . . \u2228 Ck C1\u03c3 | . . . | Ck\u03c3\nwhere \u03c3 is the most general unifier of (A1, B1), . . . , (Am, Bm) and | represents or-branching. On Horn clauses, each inference is deterministic,6 and the calculus exhibits a \u201cminimal\u201d amount of don\u2019t-known nondeterminism on general clauses.\nThe hypertableau calculus by Baumgartner et al. (1996) can be easily applied to DLs: GCIs can be translated into first-order formulae (Borgida, 1996), which can then be converted into clauses, as shown in the following example.\nA v \u2203R.B \u2200x : [A(x)\u2192 \u2203y : R(x, y) \u2227B(y)] A(x)\u2192 B(f(x)) A(x)\u2192 R(x, f(x))\n5. It is usual in resolution theorem proving to assume that the notation Ai \u2228Di does not imply that Ai is the left-most disjunct in the disjunction, and we follow this convention. 6. As mentioned before, the order in which inferences are applied is nevertheless don\u2019t-care nondeterministic.\nLet A be an ABox containing the assertions A(a), R(a, b), and B(b). The GCI A v \u2203R.B is clearly satisfied in A, so there is no need to perform any inference. The clauses obtained by skolemization, however, are not satisfied in A, so the hypertableau calculus derives R(a, f(a)) and B(f(a)). Hence, skolemization may make the calculus perform unnecessary inferences, which may be inefficient.\nTherefore, instead of working with skolemized clauses, our calculus first preprocesses a SHOIQ+ knowledge base K into a pair \u039e(K) = (\u039eT R(K),\u039eA(K)), where \u039eA(K) is an ABox and \u039eT R(K) is a set of DL-clauses\u2014implications of the form \u2227n i=1 Ui \u2192 \u2228m j=1 Vj , where Ui are of the form R(x, y) or A(x), and Vj are of the form R(x, y), A(x), \u2203R.C(x), \u2265 nR.C(x), or x \u2248 y. The preprocessing step is introduced formally in Section 4.1. The DL-clauses in \u039eT R(K) are used in the Hyp-rule, which is inspired by the hypertableau derivation rule. For example, a GCI \u2203R.\u00acA v B is translated into a DL-clause R(x, y)\u2192 B(x) \u2228A(y); then, if an ABox contains R(a, b), the Hyp-rule derives either B(a) or A(b).\nAt-most restrictions are translated in our approach into DL-clauses containing equalities; for example, the axiom A v \u2264 2R.B is translated into the DL-clause\nA(x)\u2227R(x, y1)\u2227B(y1)\u2227R(x, y2)\u2227B(y2)\u2227R(x, y3)\u2227B(y3)\u2192 y1 \u2248 y2 \u2228 y1 \u2248 y3 \u2228 y2 \u2248 y3.\nWhile a concept of the form \u2264 nR.B can be encoded using O(log n) bits, the corresponding DL-clause contains O(n2) literals; thus, our translation incurs an exponential blowup. We do not believe, however, this issue to be particular to our approach: tableau algorithms deal with at-most restrictions using a specialized \u2264-rule whose application requires O(n) space; thus, our translation merely makes the exponential space requirement explicit. Consequently, the (hyper)tableau algorithms are unlikely to be able to handle large numbers in number restrictions, and specialized algorithms, such as the one proposed by Faddoul, Farsinia, Haarslev, and Mo\u0308ller (2008), may be required.\nBecause of the translation described in the previous paragraph, the Hyp-rule can derive equalities of the form s \u2248 t. These are then dealt with using the \u2248-rule: whenever s \u2248 t \u2208 A and s 6= t, the \u2248-rule replaces s with t or vice versa in all assertions in A; this is usually called merging.\nApart from the Hyp- and the \u2248-rule, our calculus contains the \u2265-rule from the tableau calculus that deals with existential quantifiers, the \u22a5-rule that detects obvious contradictions (which can be of the form s 6\u2248 s, or A(s) and \u00acA(s)), and the NI -rule that ensures termination in the presence of nominals, number restrictions, and inverse roles. We discuss the NI -rule in more detail in Section 3.2.4.\nThe rules of the algorithm are formalized in Definition 7 on page 193 and Table 5 on page 196, and the reader may find it useful to briefly examine these definitions before continuing."}, {"heading": "3.2.2 Anywhere Pairwise Blocking", "text": "We employ pairwise blocking from Section 3.1.2 to ensure termination of the calculus; to curb and-branching, however, we extend it to anywhere pairwise blocking. The key idea is to extend the set of potential blockers for s beyond the ancestors of s. In doing so, we must avoid cyclic blocks: if s is allowed to block t and t can block s, then neither s nor t is guaranteed to have all its successors constructed, which would render the calculus incomplete. Therefore, we parameterize our algorithm with a strict ordering \u227a on individuals that\ncontains the ancestor relation. We allow t to block s only if, in addition to the conditions mentioned in Section 3.1.2, we have t \u227a s. This version of blocking is formalized in Definition 7 on page 193. Note that, if \u227a coincides with the ancestor relation, then anywhere blocking becomes equivalent to ancestor blocking.\nAnywhere blocking can reduce and-branching in practice. Consider again the knowledge base K2 from Section 3.1.2. After we exhaust the exponentially many members of \u03a0, all subsequently created individuals will be blocked. In the best case, we can always choose Bj instead of Cj , so we create a polynomial path in the tree and then use the individuals from that path to block their siblings, as shown in Figure 2b. Hence, there is a derivation for K2 with anywhere blocking that can be constructed in polynomial time."}, {"heading": "3.2.3 Problems Due to Merging", "text": "Merging can easily lead to termination problems even for very simple DLs, as shown in the following example. For simplicity, we present the TBox as a set of DL-clauses C3.\nA3 = { A(a), \u2203R.>(a), R(a, b), R(a, a) } C3 = { R(x, y1) \u2227R(x, y2)\u2192 y1 \u2248 y2, A(x) \u2227R(x, y)\u2192 \u2203R.>(y) } (4)\nConsider now the derivation in our calculus on A3 and C3 illustrated in Figure 4: by the second DL-clause, the Hyp-rule derives \u2203R.>(b), which the \u2203-rule expands to R(b, c); then, by the first DL-clause, the Hyp-rule derives b \u2248 a, so the \u2248-rule merges b into a. Clearly, the resulting ABox is isomorphic to the original one (that c is a blockable and b a named individual is not relevant here), so we can repeat the same sequence of inferences, which leads to nontermination. To the best of our knowledge, this problem was first identified by Baader and Sattler (2001), and it is commonly known as a \u201cyo-yo.\u201d\nThis problem arises because, due to merging, a can have an unbounded number of blockable R-successors: the blockable individual c is created as an R-successor of b, but merging b into a makes c a blockable R-successor of a. This, in turn, allows us to apply the DL-clauses from C3 to a an arbitrary number of times, which leads to nontermination.\nThis problem can be solved by always merging a descendant s into its ancestor t, and pruning s before merging\u2014that is, by removing all assertions containing a blockable descendant of s and thus ensuring that t does not \u201cinherit\u201d new successors.7 Pruning is formally defined in Definition 7 on page 193.\n7. Horrocks et al. (2000b) do not physically remove successors, but mark them as \u201cnot present\u201d by setting the relevant edge labels to \u2205. This has exactly the same effect as pruning.\nThus, before merging b into a in our example, we prune b\u2014that is, we remove the assertion R(b, c). Merging then produces an ABox that represents a model of A3 and C3, so the algorithm terminates. Note that pruning is well-defined only because our ABoxes are forest-shaped, cf. Figure 3: if connections between individuals were arbitrary and, in particular, cyclic, it would not be clear which part of the ABox should be pruned."}, {"heading": "3.2.4 Nominals", "text": "With nominals, it is possible to derive ABoxes that are not forest-like, as the following simple example demonstrates. For presentation purposes, we use the concept \u2203R.{c} in the DL-clauses even though such concepts would be further decomposed in our algorithm.\nA4 = { A(a), A(b) } C4 = { A(x)\u2192 (\u2203R.B)(x), B(x)\u2192 (\u2203R.C)(x), C(x)\u2192 (\u2203S.{c})(x) } (5)\nSuccessive applications of the Hyp- and \u2203-rules to A4 and C4 can produce the ABox A14 shown on the left-hand side of Figure 5. This ABox is clearly not forest-shaped: the two paths of role atoms in A14 start at the named individuals a and b and end in a named individual c. Nevertheless, if role relations between blockable individuals remain forestlike, termination of the derivation can be ensured using blocking. Some DLs that include nominals produce only such extended forest-like ABoxes (Horrocks & Sattler, 2001).\nIf a DL includes inverse roles, number restrictions, and nominals, the shape of an ABox becomes much more involved. To this end, assume now that we extend C4 with the DL-clause S(y1, x) \u2227 S(y2, x)\u2192 y1 \u2248 y2 (which axiomatizes S to be inverse-functional and effectively introduces number restrictions). On A14, the Hyp-rule then derives s2 \u2248 s4. Note that both s2 and s4 are blockable individuals; furthermore, neither individual is an ancestor of the other, so we can merge, say, s4 into s2. This produces the ABox A24 shown on the righthand side of Figure 5, in which the assertion R(s3, s2) makes A24 not forest-shaped. By extending the example, it is possible to use nominals, inverse roles, and number restrictions to arrange blockable individuals in cycles. The derived ABoxes are thus not forest-shaped, which makes defining suitable notions of pruning and unraveling difficult and prevents us from using blocking to ensure termination of the calculus.\nTo solve this problem, we need to extend the arbitrarily interconnected part of A24 by changing the status of s2 from a blockable into a root individual\u2014that is, an individual similar to the named ones in that it can be arbitrarily interconnected. Our extended forest-like ABoxes thus consist of a set of arbitrarily interconnected root individuals each of which can be the root of a \u201ctree\u201d (ignoring reflexive connections and connections back to root individuals) that otherwise consists entirely of blockable individuals (see Figure 3 on page 172). Named individuals are just the subset of the root individuals that occur in the input ABox. When we talk about individuals, we mean either root or blockable ones (see Definition 7 on page 193 for a formal definition).\nReturning to our example, after changing the status of s2 from a blockable into a root individual, only s1 and s3 are blockable in A24, so the ABox has the extended forest-like shape and we can apply blocking and pruning as usual. This is schematically shown in Figure 6. More generally, we apply the following preliminary version of the NI -rule, which we denote with (*) for easier reference:\nWe change s into a root individual whenever A contains assertions R(s, a) and A(s) where a is a root or a named individual, s is a blockable individual that is not a successor of a, and a must satisfy an at-most restriction \u2264 nR\u2212.A.\nNote that, if s is a successor of a, then the part of the ABox involving s and a is forestshaped, so the NI -rule need not be applicable.\nThis solution, however, introduces another problem: the number of root individuals can now grow arbitrarily, as shown in the following example.\nA5 = { A(b) } C5 = {\nA(x)\u2192 (\u2203R.A)(x), A(x)\u2192 (\u2203S.{a})(x), S(y1, x) \u2227 S(y2, x) \u2227 S(y3, x)\u2192 y1 \u2248 y2 \u2228 y2 \u2248 y3 \u2228 y1 \u2248 y3\n} (6)\nOn A5 and C5, our calculus can produce the ABox A15 shown on the left-hand side of Figure 7. ABox A15 does not explicitly contain at-most restriction concepts, so the precondition of (*) cannot be checked directly; we shall discuss this issue shortly. For the moment, however, please note that the last DL-clause in C5 corresponds to the axiom > v \u2264 2S\u2212.>, so individuals c and d can be seen as satisfying the precondition of (*); therefore, we change them into root individuals. Furthermore, the third DL-clause from C5 is not satisfied, so the Hyp-rule derives c \u2248 b, and the \u2248-rule can merge c into b. Since d is now not a blockable individual, we cannot prune it, so we obtain the ABox A25 shown in the middle of Figure 7.8\n8. To reduce clutter, we do not repeat the labels of individuals.\nSince \u2203R.A(d) is not satisfied, we can extend A25 with R(d, e), A(e), \u2203R.A(e), \u2203S.{a}(e), and S(e, a) to produce the ABox A35 shown on the right-hand side of Figure 7. Individual e can be seen as satisfying the precondition of (*), so it is changed into a root individual. This ABox is isomorphic to A15, so we can repeat the same inferences forever.\nWe solve this problem with an NI -rule that refines (*). Assume that A contains an individual s that satisfies the precondition of (*)\u2014that is, A contains assertions R(s, a) and A(s), where a is a root or a named individual, s is a blockable individual that is not a successor of a, and a must satisfy an at-most restriction \u2264 nR\u2212.A. In any model of A, there can be at most n different individuals bi that participate in assertions of the form R(bi, a) and A(bi). Hence, we associate with a a set of n fresh root individuals {b1, . . . , bn} that represent the R\u2212-neighbors of a. We turn s into a root individual by nondeterministically choosing bj from this set and merging s into bj . In this way, the number of new root individuals that can be introduced as a result of the at-most restriction \u2264 nR\u2212.A on a is limited to n. The complete definition of the NI -rule is given in Table 5 on page 196. In the example from Figure 7, the NI -rule introduces at most two fresh root individuals. When the NI -rule is applied for the third time, instead of introducing e, one of the previously introduced root individuals is reused, which ensures termination of the calculus.\nWhen formulating the NI -rule, we are faced with a technical problem: at-most restriction concepts are translated in our calculus into DL-clauses, which makes testing the condition from the previous paragraph difficult. For example, an application of the Hyprule to the third DL-clause in (6) (obtained from the axiom > v \u2264 2S\u2212.>) can produce an equality such as c \u2248 b; this equality alone does not reflect the fact that a must satisfy the at-most restriction \u2264 2S\u2212.>. To enable the application of the NI -rule, we introduce annotated equalities in which the annotations establish an association with the at-most restriction. The third DL-clause from (6) is thus represented in our algorithm as follows:\nS(y1, x) \u2227 S(y2, x) \u2227 S(y3, x)\u2192 y1 \u2248 y2 @x\u22642S\u2212.> \u2228 y2 \u2248 y3 @ x \u22642S\u2212.> \u2228 y1 \u2248 y3 @ x \u22642S\u2212.> (7)\nThe Hyp-rule then derives c \u2248 b@a\u22642S\u2212.>, which has the same meaning as c \u2248 b; however, the annotation says that, since a must satisfy the at-most restriction \u2264 2S\u2212.>, both b and c must also be merged with one of the (two) individuals reserved as S\u2212-neighbors of a."}, {"heading": "3.2.5 Nominals and Merging", "text": "The introduction of the NI -rule leads to another problem: repeated merging between root individuals can lead to nontermination in a \u201ccaterpillar\u201d derivation. Consider, for example, an application of the hypertableau calculus to the following knowledge base:\nA6 = { S(a, a), \u2203R.B(a) } C6 = { B(x)\u2192 \u2203R.C(x), C(x)\u2192 \u2203S.D(x), D(x)\u2192 x \u2248 a, S(y1, x) \u2227 S(y2, x)\u2192 y1 \u2248 y2 @x\u22641S\u2212.> } (8)\nThe ABox and the first DL-clause cause the introduction of two new blockable individuals b and c; the next two DL-clauses connect c with a by the role S; the last DL-clause produces c \u2248 c@x\u22641S\u2212.>; and an application of the NI -rule to this assertion causes c to become a root individual. The ABox A16 resulting from these inferences is shown in the left-hand side of Figure 8a. Since S is inverse-functional, the individuals a and c must be merged. Because individual c is a root, it is no longer a descendant of a, so we can choose to merge a into c. The blockable individual b is then pruned (in order to avoid the problems outlined in Section 3.2.3), and the resulting ABox is shown in the middle part of Figure 8a. The existential restriction \u2203R.B on c, however, is not satisfied, so a similar sequence of rule applications constructs the ABox A26 shown in the right-hand side of of Figure 8a. This ABox is isomorphic to A16, so the same inferences can be repeated forever.\nThis problem can be intuitively explained by the following observation. The NI -rule introduces fresh root individuals as neighbors of an existing root individual; thus, each\nroot individual in an ABox can be seen as a part of a \u201cchain\u201d showing which individual caused the introduction of which root individual. Each chain is initially anchored at a named individual: such individuals occur in the input ABox and are not introduced by the NI -rule. The length of a path of blockable individuals can be used to limit the length of the \u201cchains\u201d of root individuals. If we allow chain anchors to be removed from an ABox, then the chains remain limited in length in any given ABox; however, over the course of derivation, one end of the chain can be extended indefinitely as the other end is shortened.\nWe solve this problem by allowing named individuals to be merged only into other named individuals, as specified by the postcondition of the \u2248-rule in Table 5 on page 196. This ensures that each chain of root individuals always remains anchored at a named individual. In our example, instead of merging a into c, we merge c into a, which results in the ABox shown in Figure 8b. No derivation rule is applicable to this ABox, so the algorithm terminates."}, {"heading": "3.2.6 The NI -Rule and Unraveling", "text": "The NI -rule is required not only to ensure that ABoxes are forest shaped, but also to enable the application of blocking and unraveling. Consider, for example, the knowledge base shown in (9), in which we omit the annotations on equalities for the sake of clarity. Intuitively, the axioms of the knowledge base state that the individual a can have no R\u2212neighbors, and that there is an infinite chain of individuals each of which is an S\u2212-neighbor of a.\nA7 = { A(a), (\u2203R.B)(a), }\nC7 =  A(x) \u2227R(y, x)\u2192 \u22a5, B(x)\u2192 (\u2203R.B)(x), B(x)\u2192 (\u2203S.{a})(x), R(y1, x) \u2227R(y2, x)\u2192 y1 \u2248 y2, S(y1, x) \u2227 S(y2, x) \u2227 S(y3, x) \u2227 S(y4, x)\u2192\ny1 \u2248 y2 \u2228 y1 \u2248 y3 \u2228 y1 \u2248 y4 \u2228 y2 \u2248 y3 \u2228 y2 \u2248 y4 \u2228 y3 \u2248 y4,\n (9)\nWithout the NI -rule, an application of our calculus to A7 and C7 might produce the ABox A17 shown in Figure 9a. The individual d is blocked in A17 by the individual c, so the derivation terminates. Note that the last DL-clause from C7 (which corresponds to the axiom > v \u2264 3S\u2212.>) is satisfied: a is the only individual in A17 that has S\u2212-neighbors and it has only two such neighbors. To construct a model from A17, we unravel the blocked parts of the ABox\u2014that is, we construct an infinite path that extends past d by \u201cduplicating\u201d the fragment of the model between c and d an infinite number of times. This, however, creates additional S\u2212-neighbors of a, which invalidates the last DL-clause from C7; thus, the unraveled ABox does not define a model of A7 and C7.\nThe NI -rule elegantly solves this problem. Since a must satisfy an at-most restriction of the form \u2264 3S\u2212.>, as soon as S(b, a), S(c, a), and S(d, a) are derived, the NI -rule is applied to turn b, c, and d into root individuals. This corrects the problems with unraveling: root individuals do not become blocked, so we introduce another fresh blockable individual e. This individual is merged with another S\u2212-neighbor of a, producing an individual with two R\u2212-neighbors, as illustrated in Figure 9b. R is inverse-functional, however, so the neighbors are merged. Merging continues until b has been merged into a, causing a to become its own\nR-neighbor, at which point our algorithm correctly determines that the knowledge base represented by A7 and C7 is unsatisfiable."}, {"heading": "3.3 Related Work", "text": ""}, {"heading": "3.3.1 Hypertableau vs. Absorption", "text": "Absorption has been extensively used in tableau calculi to address the problems with orbranching outlined in Section 3.1.1 (Horrocks, 2007). The basic absorption algorithm tries to rewrite GCIs into the form A v C where A is an atomic concept. After such preprocessing, instead of deriving \u00acA t C for each individual in an ABox, C(s) is derived only if the ABox contains A(s); thus, the nondeterminism introduced by the absorbed GCIs is localized. This basic technique has been refined and extended in several ways. Negative absorption rewrites GCIs into the form \u00acA v C where A is an atomic concept; then, C(s) is derived only if an ABox contains \u00acA(s) (Horrocks, 2007). Role absorption rewrites GCIs into the form \u2203R.> v C; then, C(s) is derived only if an ABox contains R(s, t) (Tsarkov & Horrocks,\n2004). Binary absorption rewrites GCIs into the form A1 uA2 v C; then, C(s) is derived only if an ABox contains both A1(s) and A2(s) (Hudek & Weddell, 2006).\nThese techniques have proven indispensable in practice; however, our analysis shows potential for further improvement. For example, the axiom \u2203R.A v A from (2) cannot be absorbed directly, and applying role absorption to (2) produces the axiom \u2203R.> v A t \u2200R.\u00acA containing a disjunction in the consequent. Binary absorption is not directly applicable to (2) since the axiom does not contain two concepts on the left-hand side of v, but the algorithm by Hudek and Weddell (2006) additionally transforms (2) into an absorbable axiom A v \u2200R\u2212.A. Consider, however, the following axiom:\n> v \u2200R.\u00acC t \u2200S.D(10)\nThe binary absorption algorithm can process the two disjuncts in (10) in two ways. If \u2200R.\u00acC is processed before \u2200S.D, then (10) is transformed into the axioms shown in (11), both of which can be applied deterministically in a tableau algorithm. If, however, \u2200S.D is processed before \u2200R.\u00acC, then (10) is transformed into the axioms shown in (12). The first axiom is absorbable, but the second is not, so a tableau algorithm will be nondeterministic.\nC v \u2200R\u2212.Q1 Q1 v \u2200S.D(11) Q2 v \u2200R.\u00acC > v D t \u2200S\u2212.Q2(12)\nHeuristics are used in practice to find a \u201cgood\u201d absorption (see, e.g., Wu & Haarslev, 2008), but there are no guarantees that the result will incur the \u201cleast\u201d amount of nondeterminism; this is so even on Horn knowledge bases, for which reasoning without any nondeterminism is possible in principle (Hustadt et al., 2005). In contrast, our algorithm is guaranteed to preprocesses a Horn knowledge base into Horn DL-clauses that will always result in deterministic derivations. For example, (10) is transformed into a Horn DL-clause (13).\nR(x, y1) \u2227 C(y1) \u2227 S(x, y2)\u2192 D(y2)(13)\nEven in the case of inherently nondeterministic knowledge bases, absorption can be further optimized. Consider axiom (14), which is translated into DL-clause (15):\n> v A t \u2200R.B t \u2200S.C(14) R(x, y1) \u2227 S(x, y2)\u2192 A(x) \u2228B(y1) \u2228 C(y2)(15)\nThe binary absorption algorithm transforms (14) into the following axioms:\nQ1 uQ2 v A(16) > v B t \u2200R\u2212.Q1(17) > v C t \u2200S\u2212.Q2(18)\nAxiom (16) is absorbable; however, (17) and (18) are not, so their application introduces a nondeterministic choice point for each individual occurring in an ABox. This problem can be ameliorated by using role absorption and transforming (17) and (18) into (19) and (20):\n\u2203R\u2212.> v B t \u2200R\u2212.Q1(19)\n\u2203S\u2212.> v C t \u2200S\u2212.Q2(20)\nNow (19) can be used to derive (B t \u2200R\u2212.Q1)(b) from R(a, b), and (20) can be used to derive (C t \u2200S\u2212.Q2)(d) from S(c, d); however, these two disjunctions are derived even if a 6= c. In contrast, the DL-clause (15) derives a disjunction only if a = c; thus, literals R(x, y1) and S(x, y2) in (15) act as \u201cguards.\u201d The presence of variables in the antecedent (the shared variable x in this example) makes the guards more selective than if each guard were applied in isolation. Furthermore, if a = c, we derive a disjunction A(a) \u2228B(b) \u2228 C(d), which involves three different individuals (a, b, and d in this case); in contrast, consequences of tableau algorithms typically involve just one individual. Thus, through the usage of variables, DL-clauses can be more global in their effect than tableau rules.\nTo the best of our knowledge, no known absorption technique can localize the effects of axioms with number restrictions, such as (21).\n\u2265 2R.B v A(21)\nIn order to ensure that only instances of B are counted, tableau algorithms need to include a choose-rule that, for each assertion R(a, b), nondeterministically derives B(b) or \u00acB(b). In the hypertableau setting, however, (21) is translated into the following DL-clause:\nR(x, y1) \u2227R(x, y2) \u2227B(y1) \u2227B(y2)\u2192 A(x) \u2228 y1 \u2248 y2(22)\nNo choose-rule is needed, as the DL-clause is simply applied to assertions of the form R(a, b), B(b), R(a, c), and B(c); furthermore, the conclusion is a tautology whenever b = c. The presence of \u201cguard\u201d atoms in the antecedent of (22) thus significantly reduces the nondeterminism introduced by such number restrictions. Furthermore, on Horn knowledge bases with number restrictions (which includes the common case of functional roles), our calculus exhibits no nondeterminism; in contrast, tableau calculi still need the choose-rule, which introduces nondeterminism even if all GCIs have been fully absorbed.\nThe hypertableau calculus as presented in this paper does not generalize negative absorption directly; for example, the negatively absorbed axiom (23) is translated into a DL-clause (24) which is then applied to all individuals in an ABox.\n\u00acA v B(23) \u2192 A(x) \u2228B(x)(24)\nNegative absorption can, however, easily be applied in our setting: to negatively absorb an atomic concept A, we simply replace in the input ABox and the DL-clauses all occurrences of A with \u00acA\u2032 where A\u2032 is a fresh concept, and then move the literals involving A\u2032 to the appropriate side of DL-clauses. In our example, (24) would be thus converted into (25), which can then be applied deterministically.\nA\u2032(x)\u2192 B(x)(25)\nNote that this will transform a DL-clause A(x)\u2192 B(x) into \u2192 A\u2032(x) \u2228B(a); however, a similar situation arises in tableau calculi, where applying negative absorption to \u00acA v B means that A v B cannot be absorbed.\nTo summarize, unlike various absorption techniques that are guided primarily by heuristics, the hypertableau calculus provides a framework that captures all variants of absorption we are aware of, guarantees deterministic behavior whenever the input knowledge base is Horn, eliminates the need for the nondeterministic choose-rule, and allows for a more powerful use of \u201cguard\u201d atoms to further localize any remaining nondeterminism. Furthermore, in Section 4.1.3 we show that the our calculus provides a proof-theoretic framework for DLs that can uniformly handle certain useful extensions of SHOIQ+."}, {"heading": "3.3.2 Relationship with Caching", "text": "Various caching optimizations can be used to reduce the sizes of the models constructed during knowledge base classification (Ding & Haarslev, 2006; Horrocks, 2007). In the proposed approaches, caching is used in parallel with blocking\u2014that is, caching alone does not guarantee termination of the calculus, and caching must be carefully integrated with blocking in order not to affect soundness and/or completeness. This integration is particularly problematic in the presence of inverse roles. In contrast, anywhere blocking alone is sufficient to guarantee termination of the calculus. Furthermore, in Section 6.2 we present an optimization of anywhere blocking that can be seen as a very simple but effective form of general caching. Finally, as we discuss in Section 7, an efficient implementation of anywhere blocking can be obtained using very simple techniques. Thus, anywhere blocking achieves many of the effects of caching without much of the added complexity.\nDonini and Massacci (2000) have used anywhere blocking with caching of unsatisfiable concepts to obtain a tableau algorithm for the DL ALC that runs in single exponential time. Gore\u0301 and Nguyen (2007) have presented an algorithm for the DL SHI that also runs in exponential time and achieves termination solely by caching both satisfiable and unsatisfiable concepts. These algorithms, however, seem to be incompatible with all absorption variants, and the latter are essential for making tableau algorithms practical. Furthermore, it is unclear how to extend these algorithms to DLs that provide number restrictions, nominals, and inverse roles, such as SHOIQ+."}, {"heading": "3.3.3 Relationship with First-Order Calculi", "text": "The original hypertableau calculus for first-order logic was subsequently extended with equality and has been implemented in the KRHyper theorem prover (Baumgartner, Furbach, & Pelzer, 2008). The calculus can be used for finite model generation, and it decides function-free clause logic.\nHyperresolution with splitting has been used to decide several description and modal logics (Georgieva et al., 2003; Hustadt & Schmidt, 1999). These approaches, however, rely on skolemization, which, as we have discussed previously, can be inefficient in practice. Furthermore, these approaches deal with logics that are much weaker than SHOIQ+; in particular, we are not aware of a hyperresolution-based decision procedure that can handle inverse roles, number restrictions, and nominals.\nOur hypertableau calculus is related to the Extended Positive (EP) tableau calculus for first-order logic by Bry and Torge (1998). Instead of relying on skolemization, EP satisfies existential quantifiers by introducing new constants, and this is done in a way that makes the calculus complete for finite satisfiability. EP is, however, unlikely to be practical due to\na high degree of nondeterminism. Furthermore, EP does not provide a decision procedure for DLs such as SHOIQ+ that do not enjoy the finite model property (Baader & Nutt, 2007). Consider, for example, the knowledge base whose TBox contains axioms (26) and (27), and whose ABox contains assertion (28):\nA v \u2203R.A(26) > v \u2264 1R\u2212.>(27)\n(\u00acA u \u2203R.A)(a)(28)\nEP will try to satisfy the existential quantifier on a by \u201creusing\u201d a\u2014that is, by adding assertions R(a, a) and A(a). This leads to a contradiction, so EP will backtrack, introduce a fresh individual b, and add assertions R(a, b) and A(b); to satisfy (26), it will then also add \u2203R.A(b). To satisfy the existential quantifier in the latter assertion, EP will again try to \u201creuse\u201d a; this will fail, so it will try to \u201creuse\u201d b by adding an assertion R(b, b). Due to (27), however, b will be merged into a, which results in a contradiction; therefore, EP will backtrack, introduce yet another fresh individual c and add the assertions R(b, c), A(c), and \u2203R.A(c). By repeating the argument, it is easy to see that EP will generate ever larger models and will not terminate. This is unsurprising since the knowledge base is satisfied only in infinite models. To achieve termination on such knowledge bases, EP would need to be extended with blocking techniques such as the ones described in this paper.\nBaumgartner and Schmidt (2006) developed a so-called blocking transformation of firstorder clauses, which can improve the performance of bottom-up model generation methods. Roughly speaking, the clauses are modified in a way that makes a bottom-up calculus derive s \u2248 t or s 6\u2248 t for each term s that is a subterm of t; then, an application of paramodulation to s \u2248 t achieves an effect that is analogous to \u201creusing\u201d s instead of t in the EP tableau calculus. This transformation, however, does not ensure termination for DLs that do not have the finite model property. For example, for the same reasons as explained in the previous paragraph, hyperresolution with splitting does not terminate on the clauses obtained by an application of the blocking transformation to (the clauses corresponding to) (26)\u2013(28). Furthermore, even for DLs that enjoy the finite model property, an \u201cunlucky\u201d sequence of applications of derivation rules can prevent a bottom-up model generation method with blocking from terminating (please refer to Section 3.2.3 for more details)."}, {"heading": "4. The Satisfiability Checking Algorithm", "text": "We now present the hypertableau algorithm that can be used to check the satisfiability of a SHOIQ+ knowledge base K. Our algorithm consists of two phases: the preprocessing phase is described in Section 4.1, and the hypertableau phase is described in Section 4.2."}, {"heading": "4.1 Preprocessing", "text": "The goal of the preprocessing phase is to transform a SHOIQ+ knowledge base K into an ABox \u039eA(K) and a set of DL-clauses \u039eT R(K) that are equisatisfiable with K.\nDefinition 1 (DL-Clause). The concepts >, \u22a5, and concepts of the form A and \u00acA for A an atomic concept are called literal concepts. Let NV be a set of variables disjoint from the\nTable 2: Satisfaction of DL-Clauses in an Interpretation\nI, \u00b5 |= C(s) iff sI,\u00b5 \u2208 CI I, \u00b5 |= R(s, t) iff \u3008sI,\u00b5, tI,\u00b5\u3009 \u2208 RI I, \u00b5 |= s \u2248 t iff sI,\u00b5 = tI,\u00b5\nI, \u00b5 |= \u2227m i=1 Ui \u2192 \u2228n j=1 Vj iff I, \u00b5 |= Ui for each 1 \u2264 i \u2264 m implies\nI, \u00b5 |= Vj for some 1 \u2264 j \u2264 n I |= \u2227m i=1 Ui \u2192 \u2228n j=1 Vj iff I, \u00b5 |= \u2227m i=1 Ui \u2192 \u2228n j=1 Vj for all mappings \u00b5 I |= C iff I |= r for each DL-clause r \u2208 C\nset of individuals NI . An atom is an expression of the form B(s), \u2265 nS.B(s), R(s, t), or s \u2248 t, for s and t individuals or variables, B a literal concept, R an atomic role, S a (not necessarily atomic) role, and n a positive integer. A DL-clause is an expression of the form\nU1 \u2227 . . . \u2227 Um \u2192 V1 \u2228 . . . \u2228 Vn\nwhere Ui and Vj are atoms, m \u2265 0, and n \u2265 0. The conjunction U1 \u2227 . . . \u2227 Um is called the antecedent, and the disjunction V1 \u2228 . . . \u2228 Vn is called the consequent. The empty antecedent and the empty consequent of a DL-clause are written as > and \u22a5, respectively.\nLet I = (4I , \u00b7I) be an interpretation and \u00b5 : NV \u21924I a mapping of variables to elements of the interpretation domain. Let aI,\u00b5 = aI for an individual a and xI,\u00b5 = \u00b5(x) for a variable x. Satisfaction of an atom, DL-clause, and a set of DL-clauses C in I and \u00b5 is defined in Table 2."}, {"heading": "4.1.1 Elimination of Transitivity Axioms", "text": "Transitivity axioms are handled in tableau algorithms by the \u2200+-rule: if R is transitive and an ABox contains \u2200R.C(s) and R(s, t), the \u2200+-rule derives \u2200R.C(t). In our algorithm, however, concepts of the form \u2200R.C are translated into DL-clauses, so the \u2200+-rule cannot be applied. Therefore, instead of handling transitivity directly, we encode a SHOIQ+ knowledge base K into an equisatisfiable ALCHOIQ+ knowledge base \u2126(K). This encoding eliminates all transitivity axioms, but simulates their effects using additional GCIs.\nDefinition 2. Given a SHOIQ+ knowledge base K = (R, T ,A), the concept closure of K is the smallest set of concepts clos(K) such that\n\u2022 if C v D \u2208 T , then nnf(\u00acC tD) \u2208 clos(K),\n\u2022 if C(a) \u2208 A, then nnf(C) \u2208 clos(K),\n\u2022 if C \u2208 clos(K) and D syntactically occurs in C, then D \u2208 clos(K),\n\u2022 if \u2264 nR.C \u2208 clos(K), then \u00ac\u0307C \u2208 clos(K), and\n\u2022 if \u2200R.C \u2208 clos(K), S v\u2217R R, and Tra(S) \u2208 R, then \u2200S.C \u2208 clos(K).\nThe \u2126-encoding of K is the ALCHOIQ+ knowledge base \u2126(K) = (R\u2032, T \u2032,A) where R\u2032 is obtained from R by removing all transitivity axioms and\nT \u2032 = T \u222a {\u2200R.C v \u2200S.(\u2200S.C) | \u2200R.C \u2208 clos(K), S v\u2217R R, and Tra(S) \u2208 R}.\nSimilar encodings are known for various description (Tobies, 2001) and modal (Schmidt & Hustadt, 2003) logics. Note that, in order to guarantee decidability (Horrocks, Sattler, & Tobies, 2000a), number restrictions and local reflexivity are allowed in SHOIQ+ only on simple roles\u2014that is, on roles not having transitive subroles; for similar reasons, role disjointness, irreflexivity, and asymmetry axioms are also allowed only on simple roles.\nLemma 1. A SHOIQ+ knowledge base K is satisfiable if and only if \u2126(K) is satisfiable, and \u2126(K) can be computed in time polynomial in |K|.\nThe full proof of an analogous result for the DL SHIQ is given by Motik (2006) in Theorem 5.2.3, and the generalization of this result to SHOIQ+ is straightforward; therefore, we omit the proof of Lemma 1 for the sake of brevity. After the elimination of transitivity axioms, there is no distinction between simple and complex roles. Hence, in the rest of this paper we assume that all roles are simple unless otherwise stated and, without loss of generality, we treat \u2203R.B as a syntactic shortcut for \u2265 1R.B."}, {"heading": "4.1.2 Normalization", "text": "Before translation into a set of DL-clauses, a a knowledge base is first brought into a normalized form. This is done in order to make all negations explicit, and to ensure that the resulting DL-clauses are compatible with blocking.\nTo understand the first issue, consider the axiom \u00acA v \u00ac(\u2203R.\u2203R.\u2203R.B). Converting this axiom into DL-clauses is not straightforward because of the implicit negations; for example, the concept A is seemingly negated but, due to the negation implicit in the implication, A actually occurs positively in the axiom. Therefore, we replace this axiom with the following equivalent axiom. This makes all negations explicit, so the result can be easily translated into a DL-clause.\n> v A t \u2200R.\u2200R.\u2200R.\u00acB R(x, y1) \u2227R(y1, y2) \u2227R(y2, y3) \u2227B(y3)\u2192 A(x)(29)\nTo understand the second issue, consider the knowledge base K8, consisting of an ABox A8 and a TBox that corresponds to the set of DL-clauses C8.\nA8 = { \u00acA(a), B(a) } C8 = { R(x, y1) \u2227R(y1, y2) \u2227R(y2, y3) \u2227B(y3)\u2192 A(x), B(x)\u2192 \u2203R.B(x) } (30)\nBy applying the rules from Section 3.2, our algorithm constructs on K8 the ABox shown in Figure 10. According to the definition of blocking introduced in Definition 7,9 c is now blocked by b; furthermore, no rule is applicable to the ABox, so the algorithm terminates, leading us to believe thatK8 is satisfiable. The ABox, however, does not represent a model of K8: if we expand \u2203R.B(c) into R(c, d) and B(d), by the first DL-clause in C8 we can derive\n9. The version of blocking introduced in Definition 7 differs from the one presented in Section 3.1.2 in that the concept label LA(s) of an individual s consists only of atomic concepts A such that A(s) \u2208 A.\nA(a), which then contradicts \u00acA(a). This problem arises because the antecedent of the first DL-clause in C8 checks for a path of three R-successors, whereas the pairwise blocking condition ensures only that all paths of length two are fully constructed. Intuitively, the antecedents of each DL-clause should check for paths that \u201cfit\u201d into the fully constructed model fragments. We can ensure this by renaming complex concepts into simpler ones. Thus, we transform the culprit DL-clause into the following ones, which check only for paths of length one.\n> v A t \u2200R.\u00acQ1 R(x, y) \u2227Q1(y)\u2192 A(x)(31) > v Q1 t \u2200R.\u00acQ2 R(x, y) \u2227Q2(y)\u2192 Q1(x)(32) > v Q2 t \u2200R.\u00acB R(x, y) \u2227B(y)\u2192 Q2(x)(33)\nThe application of these DL-clauses to the ABox shown in Figure 10 would additionally derive Q2(a), Q2(b), and Q1(a), so c would not be blocked. The calculus would then expand \u2203R.B(c) and discover a contradiction.\nTo formalize these ideas, we define a normalized form of DL knowledge bases. Definition 3 (Normalized Form). A GCI is normalized if it is of the form > v \u2294n i=1Ci, where each Ci is of the form B, {a}, \u2200R.B, \u2203R.Self, \u00ac\u2203R.Self, \u2265 nR.B, or \u2264 nR.B, for B a literal concept, R a role, and n a nonnegative integer.\nA TBox T is normalized if each GCI in it is normalized. An ABox A is normalized if each concept assertion in A contains only a literal concept, each role assertion in A contains only an atomic role, and A contains at least one assertion. An ALCHOIQ+ knowledge base K = (R, T ,A) is normalized if T and A are normalized.\nThe following transformation can be used to normalize a knowledge base.\nDefinition 4 (Normalization). For an ALCHOIQ+ knowledge base K, the knowledge base \u2206(K) is computed as shown in Table 3.\nNormalization can be seen as a variant of the well-known structural transformation (Plaisted & Greenbaum, 1986; Nonnengart & Weidenbach, 2001). An application of the structural transformation to (29) would replace each complex subconcept with a positive atomic concept, eventually producing > v A t \u2200R.Q1. This axiom cannot be translated into a Horn DL-clause, whereas (29) can; thus, the structural transformation can destroy\nHorn-ness. To prevent this, we introduce the function pos(C) (c.f. Table 3) that returns false if the clausification of C does not require adding atoms into the consequent of a DLclause. We then replace an occurrence of a concept C in a concept D with a negative literal concept \u00acQC if pos(C) = false, and with a positive literal concept QC if pos(C) = true. Special care must be taken when replacing a concept D in a concept \u2264 nR.D: since D occurs in \u2264 nR.D under an implicit negation, we replace D with \u00ac\u0307\u03b1\u00ac\u0307D in order to preserve Horn-ness. On a Horn knowledge base K (Hustadt et al., 2005), normalization performs the same replacements as the one presented by Hustadt et al., so \u2206(K) is a Horn knowledge base as well.\nLemma 2. The following properties hold for each ALCHOIQ+ knowledge base K and the corresponding knowledge base \u2206(K):\n\u2022 K is satisfiable if and only if \u2206(K) is satisfiable;\n\u2022 \u2206(K) is normalized; and\n\u2022 \u2206(K) can be computed in time polynomial in |K|.\nProof. (Sketch) Since our transformation can be seen a syntactic variant of the structural transformation, the proof that K and \u2206(K) are equisatisfiable is completely analogous to the ones by Plaisted and Greenbaum (1986) and Nonnengart and Weidenbach (2001), so we omit it for the sake of brevity. For the second claim, note that \u2206 essentially rewrites each GCI into a form > v \u2294n i=1Ci and then keeps replacing nested subconcepts of Ci until the GCI becomes normalized; it adds >(a) to the ABox so that the ABox is not empty; and it replaces all inverse role assertions with equivalent assertions on the atomic roles. Thus, \u2206(K) is normalized. Finally, each occurrence of a concept in K can be replaced with a new atomic concept at most once, and all necessary syntactic transformations can be performed in polynomial time, so \u2206(K) can be computed in polynomial time."}, {"heading": "4.1.3 Translation into DL-Clauses", "text": "We now introduce the notion of HT-clauses\u2014syntactically restricted DL-clauses on which our hypertableau calculus is guaranteed to terminate. In the rest of this paper, we often use the function ar, which, given a role R and variables or constants s and t, returns an atom that is semantically equivalent to R(s, t) but that contains an atomic role; that is,\nar(R, s, t) = { R(s, t) if R is an atomic role S(t, s) if R is an inverse role and R = S\u2212 .\nDefinition 5 (HT-Clause). We assume that, for each individual a, the set of atomic concepts NC contains a unique nominal guard concept which we denote as Oa; furthermore, we assume that nominal guard concepts do not occur in any input knowledge base.\nAn annotated equality is an atom of the form s \u2248 t@u\u2264nS.B, where s, t, and u are constants or variables, n is a nonnegative integer, S is a role, and B is a literal concept; the part @u\u2264nS.B of the atom is called the annotation. This atom is semantically equivalent to s \u2248 t.10\nAn HT-clause is a DL-clause r of the following form, for m \u2265 0 and n \u2265 0:\nU1 \u2227 . . . \u2227 Um \u2192 V1 \u2228 . . . \u2228 Vn(34)\nFurthermore, it must be possible to separate the variables into a center variable x, a set of branch variables yi, and a set of nominal variables zj such that the following properties hold, for A an atomic concept, B a literal concept not containing a nominal guard concept, Oa a nominal guard concept, R an atomic role, and S a role.\n\u2022 Each atom in the antecedent of r is of the form A(x), R(x, x), R(x, yi), R(yi, x), A(yi), or A(zj).\n\u2022 Each atom in the consequent of r is of the form B(x), \u2265 hS.B(x), B(yi), R(x, x), R(x, yi), R(yi, x), R(x, zj), R(zj , x), x \u2248 zj, or yi \u2248 yj @x\u2264hS.B.\n\u2022 Each yi occurs in the antecedent of r in an atom of the form R(x, yi) or R(yi, x).\n10. As explained in Section 3.2.4, annotations are only used to ensure termination of the hypertableau phase.\n\u2022 Each zj occurs in the antecedent of r in an atom of the form Oa(zj).\n\u2022 Each equality yi \u2248 yj @x\u2264hS.A in the consequent of r occurs in a subclause of r of the form (35) where y1, . . . , yh+1 are branch variables such that no yk with 1 \u2264 k \u2264 h+ 1 occurs elsewhere in r.\n. . . h+1\u2227 k=1 [ar(S, x, yk) \u2227A(yk)] . . .\u2192 . . . \u2228 1\u2264k<`\u2264h+1 yk \u2248 y` @x\u2264hS.A . . .(35)\n\u2022 Each equality yi \u2248 yj @x\u2264hS.\u00acA in the consequent of r occurs in a subclause of r of the form (36) where y1, . . . , yh+1 are branch variables such that no yk with 1 \u2264 k \u2264 h+ 1 occurs elsewhere in r.\n. . . h+1\u2227 k=1 ar(S, x, yk) . . .\u2192 . . . h+1\u2228 k=1 A(yk) \u2228 \u2228 1\u2264k<`\u2264h+1 yk \u2248 y` @x\u2264hS.\u00acA . . .(36)\nHT-clauses are more general than what is strictly needed to captureALCHOIQ+ knowledge bases. For example, HT-clauses of the form R(x, y) \u2227A(y)\u2192 S(x, y) express a form of relativized role inclusions, and HT-clauses of the form R(x, y) \u2227 S(y, x)\u2192 U(x, y) \u2228 T (y, x) capture safe role expressions (Tobies, 2001).\nWe now show how to transform a normalized ALCHOIQ+ knowledge base into a set of HT-clauses, after which we explain the need for nominal guard concepts.\nDefinition 6 (Clausification). The clausification of a normalized ALCHOIQ+ knowledge base K = (R, T ,A) is the pair \u039e(K) = (\u039eT R(K),\u039eA(K)) in which \u039eT R(K) is a set of DLclauses and \u039eA(K) is an ABox, both obtained as shown in Table 4.\nBy Definition 3, concepts of the form \u00ac{a} are converted to ABox assertions during normalization, so Table 4 need not handle them. Positive nominal concepts are naturally translated into equalities containing constants; for example, > v \u00acA t {a} corresponds to A(x)\u2192 x \u2248 a. Such DL-clauses are impractical: given an equality assertion a \u2248 b, the \u2248-rule would need to replace all occurrences of a with b not only in the assertions, but in the DL-clauses as well; thus, the mentioned DL-clause should be replaced with A(x)\u2192 x \u2248 b. To avoid the need for changing a set of DL-clauses in a derivation, we \u201cextract\u201d all constants into the ABox; for example, > v \u00acA t {a} is transformed into the DL-clause A(x) \u2227Oa(z{a})\u2192 x \u2248 z{a} and the assertion Oa(a). All constants are thus \u201cpushed\u201d into the assertions, so the \u2248-rule can perform replacements only in the ABox.\nLemma 3. Let K be a normalized ALCHIQ knowledge base. Then, K is equisatisfiable with \u039e(K) = (\u039eT R(K),\u039eA(K)), and \u039eT R(K) contains only HT-clauses.\nProof. By inspecting Table 4, \u039eT R(KB) clearly contains only HT-clauses. The following equivalences between DL concepts and first-order formulae are well known (Borgida, 1996):\n\u2200R.B(x) \u2261 \u2200y : \u00acR(x, y) \u2228B(y) \u2264 nR.B(x) \u2261 \u2200y1, . . . , yn+1 : \u2227 1\u2264i\u2264n+1 [R(x, yi) \u2227B(yi)]\u2192 \u2228 1\u2264i<j\u2264n+1 yi \u2248 yj\n{a}(x) \u2261 x \u2248 a\nNote: Each y(i)C and zC is a fresh variable unique for C (and i).\nLet \u039e\u2032T R(K) be the set of HT-clauses defined just like \u039eT R(K), but with the difference that lhs({a}) = > and rhs({a}) = x \u2248 a. Then, (\u039e\u2032T R(K),\u039eA(K)) is obtained from K by replacing concepts of the form \u2200R.B, \u2264 nR.B and {a} with the equivalent first-order formulae, so K and (\u039e\u2032T R(K),\u039eA(K)) are clearly equisatisfiable. We now show that (\u039e\u2032T R(K),\u039eA(K)) is equisatisfiable with (\u039eT R(K),\u039eA(K)).\n(\u21d2) Each model I \u2032 of (\u039e\u2032T R(K),\u039eA(K)) is extended to a model I of (\u039eT R(K),\u039eA(K)) by setting OIa = {aI \u2032} for each nominal guard concept Oa.\n(\u21d0) Each model I of \u039e(K) is a model of (\u039e\u2032T R(K),\u039eA(K)): for each \u03b3 \u2208 \u039e\u2032T R(K), we have \u03b4 \u2208 \u039eT R(K) and Oak(ak) \u2208 \u039eA(K), where \u03b3 and \u03b4 are of the form shown below.\n\u03b3 = \u2227 Ui \u2192 \u2228 Vj \u2228 \u2228n k=1 xk \u2248 ak\n\u03b4 = \u2227 Ui \u2227 \u2227n k=1Oak(z{ak})\u2192 \u2228 Vj \u2228 \u2228n k=1 xk \u2248 z{ak}\nNow if the disjunction \u2228n k=1 xk \u2248 ak in some \u03b3 were not true in I for some values of x1, . . . , xn, then clearly \u03b4 would not be true in I for the same values of x1, . . . , xn."}, {"heading": "4.2 The Hypertableau Calculus for HT-Clauses", "text": "We now present the hypertableau calculus for deciding the satisfiability of an ABox A and a set of HT-clauses C. As explained in Section 3, our algorithm uses several types of individuals. Each individual is either root or blockable as summarized next; when we refer simply to an individual, we mean either a root or a blockable one.\n\u2022 Root individuals are those that either occur in the input ABox, or are introduced by the NI -rule. Their important characteristic is that they can be connected in arbitrary, and not just tree-like, ways.\n\u2013 Root individuals that occur in the input ABox are called named individuals.\n\u2013 Root individuals that are introduced by the NI -rule are defined as finite strings of the form a.\u03b31. . . . .\u03b3n where a is a named individual, each \u03b3` is of the form \u3008R.B.i\u3009, and n \u2265 0. Root individuals introduced by applying the NI -rule to an assertion s \u2248 t@u\u2264nR.B are all of the form u.\u3008R.B.i\u3009 with 1 \u2264 i \u2264 n.\n\u2022 Blockable individuals are introduced by the \u2265-rule, and make up the tree-like parts of a model. The set of blockable individuals is disjoint from the set of root individuals. Blockable individuals are defined as finite strings of the form s.i1.i2. . . . .in where s is a root individual, each i` is an integer, and n \u2265 1. This string representation naturally induces the parent\u2013child relationship between individuals; for example, s.2 is the second child of the individual s, which can be either blockable or root.\nWe now introduce our algorithm.\nDefinition 7 (Hypertableau Algorithm). Individuals. Given a set of named individuals NI , the set of root individuals NO is the smallest set such that NI \u2286 NO and, if x \u2208 NO, then x.\u3008R,B, i\u3009 \u2208 NO for each role R, literal concept B, and positive integer i. The set of all individuals NA is the smallest set such that NO \u2286 NA and, if x \u2208 NA, then x.i \u2208 NA for each positive integer i. The individuals in NA \\NO are blockable individuals. A blockable individual x.i is a successor of x, and x is a predecessor of x.i. Descendant and ancestor are the transitive closures of successor and predecessor, respectively.\nABoxes. The hypertableau algorithm operates on ABoxes that are obtained by extending the standard definition from Section 2 as follows.\n\u2022 In addition to assertions from Section 2, an ABox can contain annotated equality assertions and a special assertion \u22a5 that is false in all interpretations. Furthermore, assertions can refer to the individuals from NA and not only from NI .\n\u2022 Each (in)equality s \u2248 t (s 6\u2248 t) also stands for the symmetric (in)equality t \u2248 s (t 6\u2248 s). The same is true for annotated equalities.\n\u2022 An ABox A can contain renamings of the form a 7\u2192 b where a and b are root individuals. Let 7\u2192\u2217 be the reflexive-transitive closure of 7\u2192 in A. An individual b is the canonical name of a root individual a in A, written b = \u2016a\u2016A, if b is the only individual such that a 7\u2192\u2217 b and there exists no individual c 6= b such that b 7\u2192\u2217 c; if no such individual exists, then \u2016a\u2016A = a.11\nAn input ABox is an ABox containing only named individuals, no annotated equalities, and no renamings, and in which all concepts are literal and all roles are atomic.\nSatisfaction of such ABoxes in an interpretation is obtained by a straightforward generalization of the definitions in Section 2: all individuals are interpreted as elements of the interpretation domain 4I , and I |= a 7\u2192 b iff aI = bI .\nPairwise Anywhere Blocking. The labels of an individual s and of an individual pair \u3008s, t\u3009 in an ABox A are defined as follows:\nLA(s) = { A | A(s) \u2208 A and A is an atomic concept } LA(s, t) = { R | R(s, t) \u2208 A }\nLet \u227a be a strict ordering (i.e., a transitive and irreflexive relation) on NA containing the ancestor relation\u2014that is, if s\u2032 is an ancestor of s, then s\u2032 \u227a s. By induction on \u227a, we assign to each individual s in A a status as follows:\n\u2022 a blockable individual s is directly blocked by a blockable individual t if and only if the following conditions are satisfied, for s\u2032 and t\u2032 the predecessors of s and t, respectively:\n\u2013 t is not blocked,\n\u2013 t \u227a s, \u2013 LA(s) = LA(t) and LA(s\u2032) = LA(t\u2032), and \u2013 LA(s, s\u2032) = LA(t, t\u2032) and LA(s\u2032, s) = LA(t\u2032, t);\n\u2022 s is indirectly blocked iff it has a predecessor that is blocked; and\n\u2022 s is blocked iff it is either directly or indirectly blocked.\nPruning. The ABox pruneA(s) is obtained from A by removing all assertions containing a descendant of s.\nMerging. The ABox mergeA(s\u2192 t) is obtained from pruneA(s) by replacing the individual s with the individual t in all assertions and their annotations (but not in renamings) and, if both s and t are root individuals, adding the renaming s 7\u2192 t.\nDerivation Rules. Table 5 specifies derivation rules that, given an ABox A and a set of HT-clauses C, derive one or more ABoxes A1, . . . ,An. In the Hyp-rule, \u03c3 is a mapping\n11. As we show in Lemma 4, the derivation rules of our calculus ensure that 7\u2192 is a functional and acyclic relation, so an individual b satisfying the definition always exists. The second part of the definition of \u2016a\u2016A is thus just a technical aid necessary to make the definition complete.\nfrom the set of variables NV to the individuals occurring in the assertions of A, and \u03c3(U) is the result of replacing each variable x in the atom U with \u03c3(x).\nRule Precedence. The \u2248-rule can be applied to a (possibly annotated) equality s \u2248 t in an ABox A only if A does not contain an equality s \u2248 t@u\u2264nR.B to which the NI-rule is applicable (with the same s and t).\nClash. An ABox A contains a clash iff \u22a5 \u2208 A; otherwise, A is clash-free. Derivation. For a set of HT-clauses C and an input ABox A, a derivation is a pair (T, \u03bb) where T is a finitely branching tree and \u03bb is a function that labels the nodes of T with ABoxes such that the following properties hold for each node t \u2208 T :\n\u2022 \u03bb(t) = A if t is the root of T ;\n\u2022 t is a leaf of T if \u22a5 \u2208 \u03bb(t) or no derivation rule is applicable to \u03bb(t) and C;\n\u2022 t has children t1, . . . , tn such that \u03bb(t1), . . . , \u03bb(tn) are exactly the results of applying one (arbitrarily chosen, but respecting the rule precedence) applicable rule to \u03bb(t) and C in all other cases.\nWe stress several important aspects of Definition 7. If the preconditions of the NI -rule are satisfied for an annotated equality s \u2248 t@u\u2264nR.B, then the rule must be applied even if s = t; hence, such an equality plays a role in a derivation even though it is a logical tautology. Furthermore, even though the NI -rule is not applied to s \u2248 t@u\u2264nR.B if u is a blockable individual, the equality cannot be eagerly simplified into s \u2248 t because u can subsequently be merged into a root individual so the annotation might become important. Finally, if C has been obtained by a normalization of a DL knowledge base that does not use nominals, inverse roles, or number restrictions, then the precondition of the NI -rule will never be satisfied, so we need not keep track of annotations at all.\nRenamings are used to keep track of root individuals that are merged into other root individuals, which is necessary to make the NI -rule sound. For example, if a root individual a.\u3008R,B, 2\u3009 is merged into a named individual b, then the NI -rule must use b instead of a.\u3008R,B, 2\u3009 in all future inferences.\nThe proof of Lemma 6 shows that assertions containing at least one indirectly blocked individual are not used to construct a model from an ABox labeling a leaf in a derivation. All derivation rules are therefore applicable only to individuals that are either directly blocked or not blocked, as this is sufficient for completeness. Since all rules are sound, however, one may choose to disregard this restriction if that makes implementation easier.\nWe next introduce a notion of HT-ABoxes, which formalizes the idea of forest-shaped ABoxes introduced in Section 3.1.2.\nDefinition 8 (HT-ABoxes). An ABox A is an HT-ABox if it satisfies the following conditions, for R an atomic role, S a role, B a literal concept not containing a nominal guard concept, Oa a nominal guard concept, s, t, u \u2208 NA, a \u2208 NO, b \u2208 NI , and i, j integers.\n1. Each role assertion in A is of the form R(a, s), R(s, a), R(s, s.i), R(s.i, s), or R(s, s).\nClearly, each input ABox is an HT-ABox. We now prove that, given an HT-ABox, our calculus produces only HT-ABoxes.\nLemma 4 (HT-Preservation). For C a set of HT-clauses and A an HT-ABox, each ABox A\u2032 obtained by applying a derivation rule to C and A is an HT-ABox.\nProof. Let C, A, and A\u2032 be as stated in the lemma. We now analyze each derivation rule from Table 5 and show that A\u2032 satisfies the remaining conditions of HT-ABoxes.\n(Hyp-rule) Consider an application of the Hyp-rule to an HT-clause r of type (34) with a mapping \u03c3, deriving an assertion \u03c3(V ).\nAssume that V is of the form yi \u2248 yj @x\u2264k R.B, so \u03c3(V ) is of the form s \u2248 t@u\u2264k R.B. By Definition 5, the antecedent of r then contains atoms of the form ar(R, x, yi) and ar(R, x, yj) so, by the precondition of the Hyp-rule, A contains assertions ar(R, u, s) and ar(R, u, t). If u is a root individual and either s or t is a blockable individual that is not a successor of u, then \u03c3(V ) clearly satisfies Property (2) of HT-ABoxes. Otherwise, since A satisfies Property (1) of HT-ABoxes, we have the possibilities shown in Table 6, for v a blockable individual, and a and b root individuals. For brevity, we omit the symmetric combinations where the roles of ar(R, u, s) and ar(R, u, t) are exchanged. Clearly, \u03c3(V ) satisfies Property (2) of HT-ABoxes. Finally, \u03c3(V ) obviously satisfies Property (4) of HT-ABoxes.\nAssume that V is of the form x \u2248 zj , so \u03c3(V ) is of the form s \u2248 t. By Definition 5, the antecedent of r then contains an atom Oa(zj), so either Oa(s) \u2208 A or Oa(t) \u2208 A. By Property (3) of HT-ABoxes, either s or t is a named individual, so \u03c3(V ) satisfies Property (2) of HT-ABoxes.\nAssume that V is of the form R(x, x). Then, \u03c3(V ) is of the form R(s, s), and it satisfies Property (1) of HT-ABoxes.\nAssume that V is of the form R(x, yi) or R(yi, x), so \u03c3(V ) is of the form R(s, t). By Definition 5, the antecedent of r then contains an atom of the form S(x, yi) or S(yi, x), and either S(s, t) \u2208 A or S(t, s) \u2208 A; these assertions satisfy Property (1) of HT-ABoxes, so R(s, t) satisfies it as well.\nAssume that V is of the form R(x, zj) or R(zj , x), so \u03c3(V ) is of the form R(s, t). By Definition 5, the antecedent of r then contains an atom of the form Oa(zj) for Oa a nominal guard concept, and either Oa(s) \u2208 A or Oa(t) \u2208 A; by Property (3) of HT-ABoxes, either s or t is a named individual, so R(s, t) satisfies Property (1) of HT-ABoxes.\nAssume that V is of the form B(x), \u2265 nS.B(x), or B(yi), so \u03c3(V ) is of the form B(s) or \u2265 nS.B(s). By Definition 5, B is a literal but not a nominal guard concept, so \u03c3(V ) satisfies Property (3) of HT-ABoxes.\n(\u2265-rule) Consider an application of the \u2265-rule to an assertion \u2265 nR.B(s). By Property (3) of HT-ABoxes, B is not a nominal guard concept, so all assertions B(ti) introduced by the rule satisfy Property (3) of HT-ABoxes. Furthermore, all ti introduced by the rule are fresh blockable successors of s, and all role assertions introduced by the rule are of the form R(s, ti) or R(ti, s), so they satisfy Properties (1) and (5) of HT-ABoxes. The inequalities introduced by the rule trivially satisfy the properties of HT-ABoxes.\n(\u2248-rule) Consider an application of the \u2248-rule to a possibly annotated equality s \u2248 t, where s is merged into t (the annotation of the equality plays no role here). By the conditions on the 7\u2192 relation of A, the ABox A contains no renaming for s or t, so the renaming s 7\u2192 t is the only renaming for s in A\u2032, and adding this renaming to A does not introduce a cycle in 7\u2192. Merging replaces all occurrences of s in A, so no assertion of A\u2032 contains s. Hence, the 7\u2192 relation in A\u2032 satisfies Property (7) of HT-ABoxes.\nThe NI -rule is not applicable to s \u2248 t by the rule precedence, so, by the preconditions of the NI -rule and Property (2) of HT-ABoxes, s \u2248 t can be of the form v \u2248 a, v.i \u2248 v.j, v.i \u2248 v, or v.i.j \u2248 v for a \u2208 NO and v \u2208 NA; we denote this property with (*). Since pruning and replacements are applied to all assertions of A uniformly, A\u2032 clearly satisfies Property (4) of HT-ABoxes. Furthermore, pruning removes all successors of s, so A\u2032 satisfies Property (5) of HT-ABoxes. We next consider the types of assertions of A that change when s is merged into t.\nConsider a role assertion R(s, u) \u2208 A that is changed into R(t, u) \u2208 A\u2032. If either t or u is a root individual, then R(t, u) clearly satisfies Property (1) of HT-ABoxes, so assume that t and u are both blockable individuals. Then, u is not a successor of s, since the \u2248-rule prunes all assertions that contain a descendant of the merged individual. But then, by (*) and since R(s, u) satisfies Property (1) of HT-ABoxes, we have the possibilities shown in Table 7. The cases when R(u, s) \u2208 A is changed into R(u, t) \u2208 A\u2032 by merging are analogous.\nWe now consider the form of equalities that can be derived from other equalities via merging. An equality u \u2248 v@s\u2264nR.C can be changed into u \u2248 v@t\u2264nR.C , but the resulting equality always satisfies Property (2) of HT-ABoxes. Furthermore, for a a root individual, s \u2248 u@a\u2264nR.C can be changed into t \u2248 u@a\u2264nR.C , and s \u2248 a can be changed into t \u2248 a; however, in both cases, the resulting equality satisfies Property (2) of HT-ABoxes. For the remaining cases, assume that a possibly annotated equality s \u2248 u is changed into a possibly annotated equality t \u2248 u. If s is a root individual, then t is a root individual as well (the \u2248-rule never merges a root individual into a blockable one), so t \u2248 u satisfies Property (2) of\nHT-ABoxes. Assume that s is a blockable individual. Since the \u2248-rule prunes all assertions that contain a descendant of the merged individual, u is not a successor of s. By (*), Property (2) of HT-ABoxes, and the fact that the NI -rule is not applicable to A, we have the possibilities shown in Table 8. In all cases, the resulting assertion satisfies Property (2) of HT-ABoxes. Furthermore, replacing s with t in s \u2248 t \u2208 A results in t \u2248 t \u2208 A\u2032, so A\u2032 satisfies Property (6) of HT-ABoxes.\nConsider an assertion C(s) \u2208 A that is changed into C(t) \u2208 A\u2032. The only nontrivial case is when C is a nominal guard concept Oa. By Property (3) of HT-ABoxes, s is then a named individual. The \u2248-rule replaces named individuals only with other named individuals, so t is a named individual as well. Thus, C(t) satisfies Property (3) of HT-ABoxes.\n(NI -rule) Consider an application of the NI -rule to an equality s \u2248 t@u\u2264nR.B that merges s into a root individual \u2016u.\u3008R,B, i\u3009\u2016A. The individual s is blockable, so no renaming is added to A and the 7\u2192 relation in A\u2032 satisfies Property (7) of HT-ABoxes. Since s is replaced by a root individual in role and equality assertions, all resulting assertions satisfy Properties (1) and (2) of HT-ABoxes. Since s is not a named individual, no assertion involving a nominal guard concept is affected by merging, so A\u2032 satisfies Property (3). Since pruning and replacements are applied to all assertions of A uniformly, A\u2032 clearly satisfies Property (4) of HT-ABoxes. Pruning removes all successors of s, so A\u2032 satisfies Property (5) of\nHT-ABoxes. Finally, A\u2032 is clearly not empty, so it satisfies Property (6).\nWe next prove soundness and completeness of our calculus. We use these notions as is customary in resolution-based theorem proving: a calculus is sound if its derivation rules preserve satisfiability of a theory, and it is complete if, whenever the calculus terminates without detecting a contradiction, the theory is indeed satisfiable.\nLemma 5 (Soundness). Let C be a set of HT-clauses and A an input ABox such that (C,A) is satisfiable. Then, each derivation for C and A contains a branch such that \u03bb(t) is clash-free for each node t on the branch.\nProof. We say that a model I of an ABox A0 is NI-compatible with A0 if the following conditions are satisfied:\n\u2022 For each root individual a occurring in A0, each concept \u2264 nR.B, and each \u03b1 \u2208 4I such that aI \u2208 (\u2264 nR.B)I , \u3008aI , \u03b1\u3009 \u2208 RI , and \u03b1 \u2208 BI , we have \u03b1 = (a.\u3008R,B, i\u3009)I for some 1 \u2264 i \u2264 n.12\n\u2022 If s \u2248 t@u\u2264nR.B \u2208 A0, then we have \u3008uI , sI\u3009 \u2208 RI , \u3008uI , tI\u3009 \u2208 RI , sI \u2208 BI , tI \u2208 BI , and uI \u2208 (\u2264 nR.B)I .13\nTo prove this lemma, we first show the following property (*): if (C,A0) is satisfiable in a model that is NI -compatible with A0 and A1, . . . ,An are ABoxes obtained by applying a derivation rule to C and A0, then some (C,Ai) is satisfiable in a model that is NI -compatible withAi. Let I be a model of (C,A0) that is NI -compatible withA0, and consider all possible derivation rules that can derive A1, . . . ,An from A0 and C.\n(Hyp-rule) Consider an application of the Hyp-rule to an HT-clause r of the form (34). Since \u03c3(Ui) \u2208 A0, we have I |= \u03c3(Ui) for all 1 \u2264 i \u2264 m. But then, I |= \u03c3(Vj) for some 1 \u2264 j \u2264 n. Since Aj := A0 \u222a {\u03c3(Vj)}, we have I |= (C,Aj).\nIf I |= \u03c3(Vj) for some atom Vj not of the form \u03c8 = yk \u2248 y` @x\u2264hR.B, then I is clearly NI - compatible with Aj . Furthermore, for each Vj of the form \u03c8, clearly \u3008\u03c3(x)I , \u03c3(yk)I\u3009 \u2208 RI , \u3008\u03c3(x)I , \u03c3(y`)I\u3009 \u2208 RI , \u03c3(yk)I \u2208 BI , and \u03c3(y`)I \u2208 BI . Let (**) denote these two properties.\nAssume that I is not NI -compatible withAj for each 1 \u2264 j \u2264 n. By (**), then I 6|= \u03c3(Vj) for each Vj not of the form \u03c8, and \u03c3(x)I 6\u2208 (\u2264 hR.B)I for each Vj of the form \u03c8. Let \u00b5 : NV \u21924I be a variable mapping such that \u00b5(x) = \u03c3(x)I and \u00b5(yk) = \u03c3(yk)I for each branch variable yk not occurring in an atom of the form \u03c8; furthermore, for each set of branch variables y1, . . . , yh+1 occurring in an atom of the form \u03c8, we set \u00b5(y1), . . . , \u00b5(yh+1) to arbitrarily chosen domain elements that verify \u03c3(x)I 6\u2208 (\u2264 hR.B)I . Clearly, I, \u00b5 6|= Vj for each Vj not occurring in a subset (35) or (36) of r; furthermore, by the definition of \u00b5, we have that I, \u00b5 6|= Vj for each Vj occurring in a subset of (35) or (36) of r. But then, we conclude I, \u00b5 6|= (C,A0), which is a contradiction.\n(\u2265-rule) Since \u2265 nR.B(s) \u2208 A0, we have I |= \u2265 nR.B(s), which implies that domain elements \u03b11, . . . , \u03b1n \u2208 4I exist where \u3008sI , \u03b1i\u3009 \u2208 RI and \u03b1i \u2208 BI for 1 \u2264 i \u2264 n, and \u03b1i 6= \u03b1j\n12. Intuitively, this condition ensures that each root individual a.\u3008R, B, i\u3009 is interpreted as an appropriate \u201cneighbor\u201d of aI . 13. Intuitively, this condition ensures that u, s, and t are interpreted in I in accordance with the annotation.\nfor 1 \u2264 i < j \u2264 n. Let I \u2032 be an interpretation obtained from I by setting tI\u2032i = \u03b1i. Clearly, I \u2032 |= ar(R, s, ti), I \u2032 |= B(ti), and I \u2032 |= ti 6\u2248 tj for i 6= j, so I \u2032 |= (C,A1). The individuals ti are not root individuals, so I \u2032 is NI -compatible with A1.\n(\u2248-rule) Assume that the \u2248-rule is applied to the assertion s \u2248 t \u2208 A0 and s is merged into t. Since I |= s \u2248 t, we have sI = tI . Pruning removes assertions, so I is a model of the pruned ABox by monotonicity. Merging simply replaces an individual with a synonym, so I |= (C,A1). Furthermore, by Property (7) of HT-ABoxes, A does not contain renamings for s and t, so \u2016s\u2016A1 = t; hence, I is NI -compatible with A1.\n(\u22a5-rule) This rule is never applicable if (C,A0) is satisfiable. (NI -rule) Assume that the NI -rule is applied to some s \u2248 t@u\u2264nR.B \u2208 A0 and s is merged into a root individual. Since I is NI -compatible with A0, we have uI \u2208 (\u2264 nR.B)I , \u3008uI , sI\u3009 \u2208 RI , sI \u2208 BI , and sI = (u.\u3008R,B, i\u3009)I for some 1 \u2264 i \u2264 n. Let vi = \u2016u.\u3008R,B, i\u3009\u2016A0 ; since I is NI -compatible, we have (u.\u3008R,B, i\u3009)I = vIi . Thus, the NI -rule replaces s by its synonym vi, so I |= (C,Ai) just like in the case of the \u2248-rule. If vi does not occur in A0, the interpretation I may not be NI -compatible with Ai because it does not interpret vi.\u3008S,C, `\u3009 correctly. We then extend I to I \u2032 as follows. For each m, S, and C such that vIi \u2208 (\u2264 mS.C)I , let \u03b11, . . . , \u03b1k be the elements of 4I such that \u3008vIi , \u03b1j\u3009 \u2208 SI and \u03b1j \u2208 CI ; clearly, k \u2264 m. We then set (vi.\u3008S,C, `\u3009)I \u2032 = \u03b1` for 1 \u2264 ` \u2264 k. Since none of vi.\u3008S,C, `\u3009 occurs in Ai, we have I \u2032 |= (C,Ai), so I \u2032 is NI -compatible with Aj . This completes the proof of (*). To prove the main claim of this lemma, let A be an input ABox. Similarly as for the NI -rule in the proof of (*), we can extend I to a model I \u2032 of (C,A). Since A does not contain annotated equalities, I \u2032 is NI -compatible with A. The claim of this lemma then follows by a straightforward inductive application of (*).\nLemma 6 (Completeness). If a derivation for a set of HT-clauses C and an input ABox A exists in which some leaf node is labeled with a clash-free ABox A\u2032, then (C,A) is satisfiable.\nProof. We prove the lemma by constructing from A\u2032 a model of (C,A). Since our logic does not have the finite model property, we obtain this model by unraveling A\u2032 as intuitively explained in Section 3.1.2. As usual, elements of the unraveled model are paths (Horrocks & Sattler, 2001, 2007), as defined next.\nGiven an individual s that is directly blocked in A\u2032, let the blocker of s be an arbitrarily chosen but fixed individual t such that s is directly blocked by t.\nA path is finite sequence of pairs of individuals p = [ s0 s\u20320 , . . . , sns\u2032n ]. Let tail(p) = sn and tail\u2032(p) = s\u2032n. Furthermore, let q = [p |\nsn+1 s\u2032n+1 ] be the path [ s0 s\u20320 , . . . , sns\u2032n , sn+1 s\u2032n+1 ]; we say that q is a\nsuccessor of p, and p is a predecessor of q. The set of all paths P(A\u2032) is defined inductively as follows:\n\u2022 [aa ] \u2208 P(A \u2032) for each root individual a occurring in A\u2032;\n\u2022 [p | s\u2032s\u2032 ] \u2208 P(A \u2032) if p \u2208 P(A\u2032), s\u2032 is a successor of tail(p), s\u2032 occurs in A\u2032, and s\u2032 is not\nblocked in A\u2032; and\n\u2022 [p | ss\u2032 ] \u2208 P(A \u2032) if p \u2208 P(A\u2032), s\u2032 is a successor of tail(p), s\u2032 occurs in A\u2032, s\u2032 is directly\nblocked in A\u2032, and s is the blocker of s\u2032 in A\u2032.\nLet I be the interpretation constructed from A\u2032 as shown in Table 9. A\u2032 is an HT-ABox, so 4I is not empty. We now show that, for each ps of the form [ ss\u2032 ] or [qs | s s\u2032 ] and each individual w, the following claims hold (*):\n\u2022 R(s, s) \u2208 A\u2032 (resp. A(s) \u2208 A\u2032) iff \u3008ps, ps\u3009 \u2208 RI (resp. ps \u2208 AI): Immediate by the definition of I.\n\u2022 If B(w) \u2208 A\u2032 and LA\u2032(w) = LA\u2032(s\u2032) for B a literal concept, then ps \u2208 BI : The proof is immediate if B is atomic. If B = \u00acA, since the \u22a5-rule is not applicable to A\u2032, we have A(w) 6\u2208 A\u2032; but then, we have A(s\u2032) 6\u2208 A\u2032 and A(s) 6\u2208 A\u2032, which by the case for atomic concepts implies ps 6\u2208 AI .\n\u2022 If \u2265 nR.B(s) \u2208 A\u2032, then ps \u2208 (\u2265 nR.B)I : By the definition of paths, s is not blocked; since the \u2265-rule is not applicable to \u2265 nR.B(s), individuals u1, . . . , un exist such that ar(R, s, ui) \u2208 A\u2032 and B(ui) \u2208 A\u2032 for 1 \u2264 i \u2264 n, and ui 6\u2248 uj \u2208 A\u2032 for 1 \u2264 i < j \u2264 n. Each assertion ar(R, s, ui) satisfies Property (1) of HT-ABoxes, so each ui can be of one of the following forms.\n\u2013 ui = s. Let pui = ps. But then, by the previous two cases we conclude that ar(R, s, ui) \u2208 A\u2032 and B(ui) \u2208 A\u2032 imply \u3008ps, pui\u3009 \u2208 RI and pui \u2208 BI . \u2013 ui is a successor of s. If ui is directly blocked by the blocker vi, let pui = [ps | viui ]; otherwise, ui is not blocked because s is not blocked, and let pui = [ps | uiui ]. Either way, we have ar(R, tail(ps), ui) \u2208 A\u2032, which, by the definition of I, implies \u3008ps, pui\u3009 \u2208 RI . Furthermore, B(ui) \u2208 A\u2032 and LA\u2032(ui) = LA\u2032(tail(pui)) imply pui \u2208 BI . \u2013 ui is a blockable predecessor of s. Since s is blockable, we have ps = [qs | ss\u2032 ]; hence, let pui = qs. If s\n\u2032 is not blocked, then s = s\u2032 and tail(pui) = ui, so we have ar(R, s\u2032, tail(pui)) \u2208 A\u2032. If s\u2032 is blocked by the blocker s, then by the definition of pairwise blocking LA\u2032(tail(pui), s\u2032) = LA\u2032(ui, s) and LA\u2032(s\u2032, tail(pui)) = LA\u2032(s, ui), so we again have ar(R, s\u2032, tail(pui)) \u2208 A\u2032. Either way, we have \u3008ps, pui\u3009 \u2208 RI by\nthe definition of I. Furthermore, B(ui) \u2208 A\u2032 and LA\u2032(ui) = LA\u2032(tail(pui)) imply pui \u2208 BI .\n\u2013 ui and s do not satisfy any of the previous three conditions. If s is a blockable individual, then ui is a root individual, so let pui = [ ui ui\n]. If s is a root individual, then ui is not blocked in A\u2032 by Condition 3.2 of the \u2265-rule, so some pui \u2208 4I exists that has the form pui = [p | uiui ]. Either way, we have ar(R, s, ui) \u2208 A\n\u2032 and B(ui) \u2208 A\u2032, which imply \u3008ps, pui\u3009 \u2208 RI and pui \u2208 BI .\nConsider now each 1 \u2264 i < j \u2264 n. If tail\u2032(pui) 6\u2248 tail\u2032(puj ) \u2208 A\u2032, since \u22a5 6\u2208 A\u2032 and the \u22a5-rule is not applicable, we have tail\u2032(pui) 6= tail\u2032(puj ), so pui 6= puj . Furthermore, if tail\u2032(pui) 6\u2248 tail\u2032(puj ) /\u2208 A\u2032, this is because tail\u2032(pui) 6= ui, which is possible only if s\u2032 is directly blocked by the blocker s and ui = s or ui is a blockable predecessor of s. Note, however, that s can have at most one blockable predecessor, and that there can be at most one ui such that ui = s. Therefore, we have ui 6= uj , which implies pui 6= puj , and we conclude ps \u2208 (\u2265 nR.B)I .\nFor an assertion \u03b1\u2032 \u2208 A\u2032 of the form a \u2248 b and a 6\u2248 b with a and b named individuals, it is straightforward to see that I |= \u03b1\u2032. Furthermore, if \u03b1\u2032 is of the form R(a, b) or B(a), or \u2265 nR.B(a) with a a named individual, (*) implies I |= \u03b1\u2032. Consider now each \u03b1 \u2208 A. By induction on the application of the derivation rules, it is straightforward to show that, if \u03b1 6\u2208 A\u2032, then A\u2032 contains renamings that, when applied to \u03b1, produce an assertion \u03b1\u2032 \u2208 A\u2032. But then, since I |= \u03b1\u2032, we have I |= \u03b1 by the definition of I.\nIt remains to be shown that I |= C. Consider each HT-clause r \u2208 C containing atoms of the form Ai(x), Uk(x, x), ar(Ri, x, yi), Bi(yi), and Cj(zj) in the antecedent. Furthermore, consider a variable mapping \u00b5 such that the antecedent of r is true in I and \u00b5\u2014that is, px \u2208 AIi , \u3008px, px\u3009 \u2208 U Ik , \u3008px, pyi\u3009 \u2208 RIi , pyi \u2208 BIi , and pzj \u2208 CIj for px = \u00b5(x), pyi = \u00b5(yi), and pzj = \u00b5(zj). Let s = tail(px), s \u2032 = tail\u2032(px), and t\u2032i = tail \u2032(pyi). By the definition of I and the fact that LA\u2032(s\u2032i) = LA\u2032(si), we have Ai(s) \u2208 A\u2032, Uk(s, s) \u2208 A\u2032, and Bi(t\u2032i) \u2208 A\u2032. Depending on the relationship between px and pyi , we define ti as follows.\n\u2022 pyi is a successor of px or pyi = px. Let ti = t\u2032i. Clearly, Bi(ti) \u2208 A\u2032; furthermore, the definition of I and \u3008px, pyi\u3009 \u2208 RIi imply ar(Ri, s, t\u2032i) \u2208 A\u2032, so we have ar(Ri, s, ti) \u2208 A\u2032.\n\u2022 pyi is a predecessor of px. We have the following cases.\n\u2013 s directly blocks s\u2032. Let ti be the predecessor of s; such ti exists since s is blockable. The definition of I and \u3008px, pyi\u3009 \u2208 RIi imply ar(Ri, s\u2032, tail(pyi)) \u2208 A\u2032 and B(tail(pyi)) \u2208 A\u2032, and by the definition of pairwise blocking we conclude that ar(Ri, s, ti) \u2208 A\u2032 and Bi(ti) \u2208 A\u2032. \u2013 s\u2032 is not blocked. Let ti = t\u2032i. By the definition of I, we have Bi(ti) \u2208 A\u2032 and ar(Ri, s, ti) \u2208 A\u2032.\n\u2022 pyi and px do not match any of the conditions mentioned thus far. By the definition of I, then either px or pyi is of the form [ a a ]. Let ti = tail(pyi). By \u3008px, pyi\u3009 \u2208 R I i and\nthe definition of I, we conclude that Bi(ti) \u2208 A\u2032 and ar(Ri, s, ti) \u2208 A\u2032.\nBy Definition 5, the antecedent of r contains an atom of the form Oa(zj) for each nominal variable zj . Thus, by the definition of I and Property (3) of HT-ABoxes, we have pzj is of the form [ujuj ] for uj a named individual; furthermore, Cj(uj) \u2208 A\n\u2032. Let \u03c3 be a mapping such that \u03c3(x) = s, \u03c3(yi) = ti, and \u03c3(zj) = uj . Clearly, neither s nor ti are indirectly blocked, and \u03c3(Uj) \u2208 A\u2032 for each atom Uj in the antecedent of r. The Hyp-rule is not applicable to r, A\u2032, and \u03c3, so r contains an atom Vi in the consequent such that \u03c3(Vi) \u2208 A\u2032. Depending on the type of Vi, we have the following possibilities.\nAssume that Vi is of the form yi \u2248 yj @x\u2264k S.B; thus, we have ti \u2248 tj @s\u2264k S.B \u2208 A\u2032. Since the \u2248-rule is not applicable to A\u2032, we have ti = tj . By Definition 5, r contains a subclause of the form (35) or (36), so the antecedent of r contains atoms ar(S, x, yi) and ar(S, x, yj); therefore, \u3008px, pyi\u3009 \u2208 SI and \u3008px, pyj \u3009 \u2208 SI . The NI -rule is not applicable to ti \u2248 tj @s\u2264k S.B so, by the preconditions of the NI -rule, if s is a root individual, then ti (tj) is either a root individual or a successor of s. This rules out the possibility when px is of the form [aa ] and pyi (pyj ) is neither a successor of px nor of the form [ b b ]. Hence, by the construction of I, we have that pyi (pyj ) is either a successor of px, equal to px, the predecessor of px, or is of the form [aa ]. We now consider the following cases (w.l.o.g. we omit the symmetric cases obtained by swapping pyi and pyj ):\n\u2022 pyi is of the form [aa ]. Then, ti = tj implies pyi = pyj by the definition of paths.\n\u2022 pyi is a successor of px. Then, pyi = [px|uiti ] for ui = ti if ti is not blocked or ui the blocker of ti. Either way, ti is different from s and the predecessor of s (if the latter exists). We have the following possibilities for pyj :\n\u2013 pyj is a successor of px. Then, pyj = [px| uj tj ], so ti = tj clearly implies pyi = pyj . \u2013 pyj = px or pyj is the predecessor of px. Then tj = s or tj is the predecessor of s, which contradicts the fact that ti 6= tj .\n\u2022 pyi = px. Then ti = s. The only nontrivial case is if pyj is the predecessor of px; but then, tj 6= s, which contradicts the fact that ti 6= tj .\n\u2022 pyi is the predecessor of px. The only remaining possibility is for pyj to be the predecessor of px. Since px can have at most one predecessor, we have pyi = pyj .\nThus, we conclude that I, \u00b5 |= r. Assume that Vi is of the form x \u2248 zj ; thus, we have s \u2248 uj \u2208 A. Since the \u2248-rule is not applicable to A\u2032, we have s = uj . Since uj is a named individual, it cannot block other individuals, so s\u2032 = s, which implies px = pzj . Thus, I, \u00b5 |= r.\nAssume that Vi is of the form Ti(x, x); thus, we have Ti(s, s) \u2208 A\u2032. By (*), we then have \u3008px, px\u3009 \u2208 RIi . Thus, we have I, \u00b5 |= r.\nAssume that Vi is of the form Di(x) for Di a literal concept or of the form \u2265 nT.B; thus, we have Di(s) \u2208 A\u2032. By (*), we then have px \u2208 DIi . Thus, we have I, \u00b5 |= r.\nAssume that Vi is of the form Ei(yi) for Ei a literal concept; thus, we have Ei(ti) \u2208 A\u2032. We have already established that LA\u2032(ti) = LA\u2032(t\u2032i); by (*), we then have pyi \u2208 EIi . Thus, we have I, \u00b5 |= r.\nAssume that Vi is of the form ar(Si, x, yi), so ar(Si, s, ti) \u2208 A\u2032. By the definition of blocking, we have ar(Si, s\u2032, t\u2032i) \u2208 A\u2032. Finally, by the definition of I, we have \u3008px, pyi\u3009 \u2208 SIi . Thus, we have I, \u00b5 |= r.\nAssume that Vi is of the form ar(Sj , x, zj), so ar(Sj , s, uj) \u2208 A\u2032. Since uj is a named individual, by the definition of I we have \u3008px, pzj \u3009 \u2208 SIj . Thus, we have I, \u00b5 |= r.\nWe next prove termination of the hypertableau calculus.\nLemma 7 (Termination). For a set of HT-clauses C and an input ABox A, let |C,A| be the sum of the size of A, of the number of concepts and roles in C, and of dlog ne for each integer n occurring in C in an atom of the form \u2265 nR.B and yi \u2248 yj @x\u2264nR.B. The total number of individuals introduced on each path in each derivation for C and A is at most doubly exponential in |C,A|, and each derivation for C and A is finite.\nProof. We prove the claim by showing that (i) each derivation rule can be applied at most once to a fixed set of individuals on a derivation path, and (ii) the number of new individuals introduced on each derivation path is at most doubly exponential in |C,A|. The supply of blockable individuals is infinite, so we can assume that no blockable individual is introduced twice on a derivation path. Furthermore, if the root individual s is removed from an ABox A\u2032 due to merging, then a renaming is added to A\u2032 that ensures \u2016s\u2016A\u2032 6= s. Once a renaming is added to A\u2032, all ABoxes occurring below A\u2032 in a derivation will contain this renaming as well, so no subsequent application of the NI -rule can reintroduce s.\nNext, we prove (i) by considering each derivation rule.\n\u2022 An application of the Hyp-rule to an HT-clause r of the form (34) and a mapping \u03c3 introduces an assertion \u03c3(Vi), which prevents a subsequent reapplication of the Hyp-rule to the same r and \u03c3. Merging and pruning can remove \u03c3(Vi) in subsequent derivation steps, but this also removes at least one individual occurring in \u03c3 from the set of potential premises of the Hyp-rule, thus preventing the reuse of the same \u03c3 in a future application of the Hyp-rule to r.\n\u2022 An application of the \u2265-rule to an assertion \u2265 nR.B(s) introduces t1, . . . , tn as fresh successors of s and the assertions B(ti), ar(R, s, ti), and ti 6\u2248 tj for 1 \u2264 i < j \u2264 n. Thus, the individuals u1, . . . , un from Condition 3 of the \u2265-rule can be matched to t1, . . . , tn. Furthermore, if s is a root individual, none of ti can become blocked and Condition 3.2 is always satisfied for ti; moreover, if s is blockable, Condition 3.2 is trivially satisfied for ti. If some ti is merged into another individual v, then B(v), ar(R, s, v), and v 6\u2248 tj are added to the ABox, so the ABox still contains individuals that can be matched to Condition 3 of the\u2265-rule. Finally, if some ti becomes indirectly blocked, then s is blocked and the \u2265-rule is not applicable to s.\n\u2022 An application of the \u2248-rule to s \u2248 t removes either s or t, so the rule cannot be reapplied to the same s and t\n\u2022 An application of the \u22a5-rule produces an ABox that labels a derivation leaf.\n\u2022 An application of the NI -rule to an equality s \u2248 t@u\u2264nR.B removes s, so the rule cannot be reapplied to the same \u2264 nR.B, s and u.\nNext, we prove (ii)\u2014that is, that the total number of individuals introduced on a derivation path is at most doubly exponential in |C,A|. A path of length n between individuals s and t in an ABox A\u2032 is a sequence of individuals u0, u1, . . . , un such that u0 = s, un = t, and, for each 0 \u2264 i \u2264 n\u2212 1, either R(ui, ui+1) \u2208 A\u2032 or R(ui+1, ui) \u2208 A\u2032 for R an atomic role.\nA root path for a root individual t in an ABox A\u2032 is a path between t and a named individual s such that all intermediate individuals ui, 1 \u2264 i \u2264 n \u2212 1, are root individuals. The level lev(t) of t is the length of the shortest root path for t. Thus, lev(t) = 0 if t is a named individual.\nThe depth dep(t) of an individual t is the number of ancestors of t. Thus, dep(t) = 0 if t is a root individual. Due to Property (5) of HT-ABoxes, if an individual t occurs in an ABox A\u2032, then A\u2032 contains a path of length dep(t) between a root individual s and t such that the individuals ui, 0 \u2264 i \u2264 n \u2212 1, are all ancestors of t; since each individual has at most one predecessor, these ui are also the only ancestors of t.\nWe now show that the maximum level of a root individual and the maximum depth of every individual are both at most exponential in the size of C and A.\nAn application of an derivation rule never increases the level of an individual. This is because a named individual is never pruned and can be merged only into another named individual,14 and a root individual can be merged only into another root individual. Such rule applications can only make a root path shorter, and not longer.\nLet m be the number of atomic concepts and n the number of atomic roles that occur in A and C, let \u2118 = 22m+2n + 1, and let A\u2032 be an ABox labeling a node of a derivation for A and C. We next show that (1) dep(t) \u2264 \u2118 for each individual t occurring in A\u2032, and (2) if t is a root individual, then lev(t) \u2264 \u2118.\n(Claim 1) For a pair of individuals s and t occurring in A\u2032, there are 2m different possible labels LA\u2032(s) and 2n different possible labels LA\u2032(s, t). Thus, if A\u2032 contains at least \u2118 = 2m \u00b7 2m \u00b7 2n \u00b7 2n + 1 predecessor-successor pairs of blockable individuals, then A\u2032 must contain two pairs \u3008s, s.i\u3009 and \u3008t, t.j\u3009 such that the following conditions are satisfied:\nLA\u2032(s.i) = LA\u2032(t.j) LA\u2032(s) = LA\u2032(t) LA\u2032(s, s.i) = LA\u2032(t, t.j) LA\u2032(s.i, s) = LA\u2032(t.j, t)\nSince \u227a contains the ancestor relation, a path in A\u2032 containing \u2118 blockable individuals must include at least one blocked individual, so a blockable individual of depth \u2118 must be blocked. The \u2265-rule is applied only to individuals that are not blocked, so the rule cannot introduce an individual u such that dep(u) > \u2118.\n(Claim 2) We show that the following stronger claim (*) holds for each root individual s occurring in an assertion in A\u2032 (the symmetry of \u2248 applies as usual):\n1. lev(s) \u2264 \u2118;\n2. if R(s, t) \u2208 A\u2032 or R(t, s) \u2208 A\u2032 or t \u2248 u@s\u2264nR.B \u2208 A\u2032 with t a blockable nonsuccessor of s, then lev(s) + dep(t) \u2264 \u2118; and\n3. if s \u2248 t \u2208 A\u2032 with t a blockable nonsuccessor of s (where the equality can be annotated), then lev(s) + dep(t) \u2264 \u2118+ 1.\n14. If a derivation rule replaced a named individual with an individual that is not named, the levels of other root individuals could increase.\nThis claim is clearly true for the input ABox A labeling the root of a derivation, which contains only named individuals. We now assume that (*) holds for some ABox A\u2032 and consider all possible derivation rules that can be applied to A\u2032.\n\u2022 Assume that the Hyp-rule derives an assertion R(s, t) or R(t, s), where s is a root individual and t is a blockable nonsuccessor of s. Let R(x, y) or R(y, x) be the atom from the consequent of an HT-clause r that is instantiated by the derivation rule. We have the following two possibilities for the antecedent of r.\n\u2013 The antecedent of r contains an atom of the form S(x, y) or S(y, x) that is matched to an assertion of the form S(s, t) or S(t, s) in A\u2032. Since A\u2032 satisfies (*), the resulting ABox satisfies (*) as well.\n\u2013 The antecedent of r contains an atom of the form Oa(x) or Oa(y) that is matched to an assertion of the form Oa(s) in A\u2032 (since t is blockable, A\u2032 cannot contain Oa(t) by Property 3 of HT-ABoxes). Then dep(t) \u2264 \u2118 and lev(s) = 0, so the resulting ABox satisfies (*) as well.\n\u2022 Assume that the Hyp-rule derives an assertion t \u2248 u@s\u2264nR.B, where s is a root individual and t is a blockable nonsuccessor of s. By Definition 5, the antecedent of the HT-clause then contains atoms of the form ar(R, x, yi) and ar(R, x, yj) that are matched to assertions ar(R, s, t) and ar(R, s, u) in A\u2032. Since A\u2032 satisfies (*), we have lev(s) + dep(t) \u2264 \u2118, so the resulting equality satisfies Item 2 of (*). To show that t \u2248 u@s\u2264nR.B satisfies Item 3 of (*), assume that u is a root individual and t is a nonsuccessor of u. Since A\u2032 contains ar(R, s, u), we have that lev(u) \u2264 lev(s) + 1; but then, lev(u) + dep(t) \u2264 \u2118+ 1, as required.\n\u2022 If the Hyp-rule derives an assertion s \u2248 t, where s is a root individual and t is a blockable nonsuccessor of s, the only remaining possibility is that the consequent of the HT-clause then contains the equality x \u2248 zj . By Definition 5, the antecedent then contains Oa(zj) that is matched to an assertion Oa(s) in A\u2032, where s is a named individual. Then dep(t) \u2264 \u2118 and lev(s) = 0, so the resulting ABox satisfies (*).\n\u2022 Assume that the \u2265-rule introduces an assertion of the form R(s, t) or R(t, s) where t is a fresh individual. Individual t is always a successor of s, so the resulting ABox trivially satisfies (*).\n\u2022 Assume that the \u2248-rule is applied to an assertion of the form u \u2248 s and that u is merged into s. By the definition of merging, we have that dep(u) \u2265 dep(s) and u is pruned. If s is a blockable individual, then u is blockable as well, and the resulting ABox satisfies (*) because u is replaced with an individual of equal or smaller depth. Therefore, we assume that s is a root individual and consider the types of assertions that can be added to A\u2032 as a result of merging.\n\u2013 If R(u, u) is changed into R(s, s), the resulting ABox clearly satisfies (*). \u2013 Assume that R(u, t) where t is a root individual is changed into R(s, t). This\ninference can make root paths to s and t only shorter and not longer, so the levels of s and t can only decrease rather than increase. Thus, the resulting ABox satisfies Item 1 of (*).\n\u2013 Assume that R(u, t), where t is a predecessor of u, is changed into R(s, t); the only nontrivial case is when t is a blockable nonsuccessor of s. Since t is a predecessor of u, we have dep(t) + 1 = dep(u); since A\u2032 satisfies (*), we have lev(s) + dep(u) \u2264 \u2118+ 1; but then, lev(s) + dep(t) \u2264 \u2118 as required.\n\u2013 The cases when R(t, u) is changed into R(t, s) are analogous.\n\u2013 Assume that a possibly annotated equality v \u2248 u is changed into v \u2248 s. The only nontrivial case is when v is a blockable nonsuccessor of s. If u is a root individual, then the level of s after merging is bounded by min(lev(s), lev(u)) before merging, so (*) is preserved. If u and v are both blockable individuals, then by Property (2) of HT-ABoxes, either u is an ancestor of v, or u and v are siblings, or v is an ancestor of u. If u is an ancestor of v, then pruning u removes v \u2248 u from A\u2032. If v is a sibling or an ancestor of u, then u must be a nonsuccessor of s, so lev(s) + dep(u) \u2264 \u2118+ 1; but then, dep(v) \u2264 dep(u), so lev(s) + dep(v) \u2264 \u2118+ 1 and (*) is preserved.\n\u2013 Assume that v \u2248 v\u2032@u\u2264nR.B is changed into v \u2248 v\u2032@s\u2264nR.B or v \u2248 s@s\u2264nR.B. The only nontrivial case is when v is a blockable nonsuccessor of s. Since u is pruned before merging, by Properties (2) and (4) of HT-ABoxes v must be a predecessor of u, so dep(v) + 1 = dep(u). Furthermore, by the same properties u must be a blockable nonsuccessor of s, so lev(s) + dep(u) \u2264 \u2118+ 1. But then, lev(s) + dep(v) \u2264 \u2118, as required.\n\u2022 An application of the \u22a5-rule trivially preserves (*).\n\u2022 Assume that the NI -rule is applied to an assertion s \u2248 t@u\u2264nR.B replacing s with a root individual v = \u2016u.\u3008R,B, i\u3009\u2016A\u2032 . If v already occurs in an assertion in A\u2032, then v satisfies Item 1 of (*). If, however, v is fresh, by Property (4) of HT-ABoxes v will be connected to u by a role assertion, so lev(v) \u2264 lev(u) + 1. Furthermore, since s is a blockable nonsuccessor of u, we have lev(u) + dep(s) \u2264 \u2118. Finally, since s is blockable, dep(s) \u2265 1, so lev(u) \u2264 \u2118\u2212 1. As a consequence, we conclude that lev(v) \u2264 \u2118, which proves Item 1 of (*). The proof that the assertions introduced through merging satisfy (*) is analogous to the case for the \u2248-rule.\nWe now complete the proof of claim (ii)\u2014that is, that the total number of individuals introduced by derivation rules is at most doubly exponential in |C,A|.\nAll named individuals are of level 0 and are never introduced by the derivation rules. An application of the NI -rule to a root individual u of level ` can introduce at most n root individuals of level `+ 1 for each concept \u2264 nR.B that occurs in C. Thus, for each named individual, the derivation rules can create a tree of root individuals. The maximum depth of the tree is \u2118, which is exponential in |C,A|. Furthermore, the maximum branching factor b is equal to the sum of all numbers occurring in C in atoms of the form yi \u2248 yj @x\u2264nR.B. Clearly, b is exponential in |C,A|, so each such tree is doubly exponential in |C,A|.15\nSimilarly, each root individual can become the root of a tree of blockable individuals of depth \u2118. Each blockable individual is introduced by applying the \u2265-rule to its predecessor.\n15. If numbers were coded in unary, then the branching factor would be polynomial, but each such tree would still be doubly exponential in |C,A|.\nFurthermore, the \u2265-rule can be applied to an individual s at most once for each concept of the form \u2265 nR.B. Thus, the branching factor is exponential assuming binary coding of numbers, and each such tree is at most doubly exponential in |C,A|.\nThus, the total number of individuals appearing in a derivation is at most doubly exponential in |C,A|. Since the branching factor in the derivation is exponentially bounded by |C,A|, each derivation is finite.\nWe now state the main theorem of this section.\nTheorem 1. The satisfiability of a SHOIQ+ knowledge base K can be decided by computing K\u2032 = \u2206(\u2126(K)) and then checking whether some derivation for \u039e(K\u2032) contains a leaf node labeled with a clash-free ABox. Such an algorithm can be implemented such that it runs in 2NExpTime in |K|.\nProof. The first part of the theorem follows immediately from Lemmas 1, 2, 5, and 6. By Lemma 7, the total number of individuals is doubly exponential in |\u039eA(K\u2032),\u039eT R(K\u2032)|. Since the structural transformation is polynomial, the total number of individuals is doubly exponential in |K|. Thus, the existence of a leaf derivation node labeled with a clash-free ABox can be checked by nondeterministically applying the hypertableau derivation rules to construct an ABox that is at most doubly exponential in |K|."}, {"heading": "5. Discussion", "text": "In this section we discuss the possibilities of optimizing the blocking condition to single and subset blocking; furthermore, we argue that modifying the algorithm to make it optimal w.r.t. worst-case complexity might be difficult."}, {"heading": "5.1 Single Blocking", "text": "For DLs such as SHOQ+ that do not provide for inverse roles, pairwise blocking can be weakened to atomic single blocking, defined as follows.\nDefinition 9 (Atomic Single Blocking). Atomic single blocking is obtained from pairwise blocking (see Definition 7) by changing the notion of direct blocking: a blockable individual s is directly blocked by a blockable individual t if and only if t is not blocked, t \u227a s, and LA(s) = LA(t) for LA(s) as in Definition 7.16\nIn some cases, this simpler blocking condition can make the hypertableau algorithm construct smaller ABoxes, which can lead to increased efficiency. We next formalize the notion of HT-clauses to which atomic single blocking is applicable.\nDefinition 10 (Simple HT-Clause). An HT-clause r is simple if it satisfies the following restrictions, for x a center variable, yi a branch variable, zj a nominal variable, B a literal concept, and R an atomic role:\n\u2022 Each atom in the antecedent of r is of the form A(x), R(x, x), R(x, yi), A(yi), or A(zj).\n16. The name \u201catomic\u201d reflects the fact that LA(s) contains only atomic concepts.\n\u2022 Each atom in the consequent of r is of the form B(x), \u2265 hR.B(x), B(yi), R(x, x), R(x, yi), R(x, zj), x \u2248 zj, or yi \u2248 yj.\nIt is straightforward to see that, if K is a SHOQ+ knowledge base, then \u039eT R(K) contains only simple HT-clauses. The completeness of the hypertableau algorithm with atomic single blocking on simple HT-clauses is straightforward to show.\nLemma 8. Let C be a set of simple HT-clauses, and A an input ABox. If a derivation with atomic single blocking for C and A exists in which a leaf node is labeled with a clash-free ABox A\u2032, then (C,A) is satisfiable.\nProof. By slightly modifying the proof of Lemma 4, it is possible to show the following property (*): each atom in A\u2032 involving an atomic role is of the form R(s, a), R(s, s), or R(s, s.i), for a a named individual and s any individual.\nLet I be a model constructed in the same way as in Lemma 6, but by using single blocking. Due to (*), whenever \u3008p1, p2\u3009 \u2208 RI , then p2 is either of the form [aa ] for a a named individual, it is a successor of p1, or p2 = p1. The proof that I is a model of (C,A) is a straightforward consequence of the following observations about the proof of Lemma 6:\n\u2022 In the proof that \u2265 nR.B(s) \u2208 A\u2032 implies ps \u2208 (\u2265 nR.B)I , individual ui can never be a blockable predecessor of s. Thus, labels LA\u2032(s, ui), LA\u2032(ui, s), and LA\u2032(ui) are never relevant.\n\u2022 In the proof that I |= C, it is not possible that pyi is a predecessor of px. Thus, labels LA\u2032(s\u2032, tail(pyi)), LA\u2032(tail(pyi), s\u2032), and LA\u2032(tail(pyi)) are never relevant.\nThe proof that I is a model of (A, C) thus requires only LA\u2032(s) = LA\u2032(t) to hold when s is blocked by the blocker t; hence, I is a model of (A, C) even if atomic single blocking is used.\nThe following variant of single blocking can also be applied to DLs with inverse roles but no number restrictions, such as SHOI.\nDefinition 11 (Full Single Blocking). Full single blocking is obtained from atomic single blocking (see Definition 9) by changing the definition of LA(s) as follows:\nLA(s) = { C | C(s) \u2208 A where C is of the form A or \u2265 1R.B with A an atomic and B a literal concept }\nFor t to directly block s in A under atomic single blocking, it suffices if s and t occur in the same atomic concepts in A. Intuitively, this is because the model construction from Lemma 6 \u201ccopies\u201d all nonatomic concepts from t to s; hence, assertions of the form C(s) where C is not atomic are not relevant. In contrast, in full single blocking, s and t must occur in A in exactly the same concepts (apart from negated atomic concepts). Intuitively, given a clash-free ABox A\u2032 to which no derivation rule is applicable, a model for (A, C) is constructed from A\u2032 by replacing s with t; for the result to be a model, the two individuals must occur in exactly the same concepts.\nFull single blocking must be applied with care in the hypertableau setting. Consider the following knowledge base K9, consisting of an ABox A9 and a set of HT-clauses C9.\nA9 = { \u2203T.C(a) } C9 = {C(x)\u2192 \u2203R.D(x), D(x)\u2192 \u2203S\u2212.C(x), R(x, y1) \u2227 S(x, y2)\u2192 \u22a5} (37)\nOn K9, the hypertableau algorithm with full single blocking produces the ABox shown in Figure 11. The individual d is blocked by b, so the algorithm terminates; an expansion of \u2203R.D(d), however, would reveal that K9 is unsatisfiable. The problem arises because the HT-clause R(x, y1) \u2227 S(x, y2)\u2192 \u22a5 contains two role atoms, which allows the HT-clause to examine both the successor and the predecessor of x. Full single blocking, however, does not ensure that both predecessors and successors of x have been fully built. We can correct this problem by requiring the normalized GCIs to contain at most one \u2200R.C concept. For example, if we replace our HT-clause with R(x, y1)\u2192 Q(x) and Q(x) \u2227 S(x, y2)\u2192 \u22a5, then the first HT-clause would additionally derive Q(b), so d would not be blocked by b.\nWe can apply full single blocking to the DL SHOI provided that each HT-clause contains at most one role atom in the antecedent. We can always ensure this by suitably renaming complex concepts with atomic ones.\nLemma 9. Let A be an ABox and C a set of HT-clauses such that, for each r \u2208 C, ( i) r contains no atoms of the form R(x, x), ( ii) the antecedent of r contains at most one role atom, and ( iii) all at-least restriction concepts are of the form \u2265 1S.B for S a role and B a literal concept. If a derivation with full single blocking for C and A exists in which a leaf node is labeled with a clash-free ABox A\u2032, then (C,A) is satisfiable.\nProof. Let A\u2032\u2032 be obtained from A\u2032 by removing each assertion containing an indirectly blocked individual. Since no derivation rule is applicable to indirectly blocked individuals, no derivation rule is applicable to A\u2032\u2032 and C. For an individual s occurring in A\u2032\u2032, let [s]A\u2032\u2032 = s if s is not blocked in A\u2032\u2032, and let [s]A\u2032\u2032 = s\u2032 if s is blocked in A\u2032\u2032 by the blocker s\u2032.\nNote the following useful property (*): if \u00acA(s) \u2208 A\u2032\u2032, then A(s) 6\u2208 A\u2032\u2032 since the \u22a5-rule is not applicable to A\u2032\u2032; but then, A([s]A\u2032\u2032) 6\u2208 A\u2032\u2032 as well.\nWe now construct an interpretation I from A\u2032\u2032 as follows.\n4I = {s | s occurs in A\u2032\u2032 and it is not blocked in A\u2032\u2032} sI = [s]A\u2032\u2032 for each individual s occurring in A\u2032\u2032 AI = {[s]A\u2032\u2032 | A(s) \u2208 A\u2032\u2032} RI = {\u3008[s]A\u2032\u2032 , [t]A\u2032\u2032\u3009 | R(s, t) \u2208 A\u2032\u2032}\nIt is straightforward to see that I |= A\u2032\u2032. Consider now each HT-clause r \u2208 C that contains in the antecedent one atom of the form R(x, y), as well as atoms of the form Ai(x), Bi(y), Ci(zi). Let \u03c3 be a mapping from the variables of r to the individuals in A\u2032\u2032 such that I |= \u03c3(Ui) for each atom Ui from the antecedent of r. By the definition of I, individuals s and t then exist such that R(s, t) \u2208 A\u2032\u2032, \u03c3(x) = [s]A\u2032\u2032 , and \u03c3(y) = [t]A\u2032\u2032 . By the definition of full single blocking, then Ai(s) \u2208 A\u2032\u2032 and Bi(t) \u2208 A\u2032\u2032 as well. Furthermore, since each zi occurs in a nominal guard concept, \u03c3(zi) is a named individual. Let \u03c3\u2032 be such that \u03c3\u2032(x) = s, \u03c3\u2032(y) = t, and \u03c3\u2032(zi) = \u03c3(zi). Since the Hyp-rule is not applicable to C and A\u2032\u2032 for \u03c3\u2032, we have \u03c3\u2032(Vj) \u2208 A\u2032\u2032 for some atom Vj from the consequent of r. Consider now the possible forms that Vj can have.\n\u2022 If Vj = S(x, y), then I |= S(\u03c3(x), \u03c3(y)) by the definition of I. The case Vj = S(y, x) is analogous.\n\u2022 If Vj = A(x) for A an atomic concept, then A([s]A\u2032\u2032) \u2208 A\u2032\u2032 by the definition of full single blocking; but then, I |= A(\u03c3(x)) by the definition of I. The case when Vj = A(y) is analogous.\n\u2022 If Vj = \u00acA(x), then A([s]A\u2032\u2032) 6\u2208 A\u2032\u2032 by (*); but then, by the definition of I we have I |= \u00acA(\u03c3(x)). The case when Vj = \u00acA(y) is analogous.\n\u2022 If Vj = D(x) for D = \u2265 1R.B, then D([s]A\u2032\u2032) \u2208 A\u2032\u2032 by the definition of full single blocking. Since the \u2265-rule is not applicable to [s]A\u2032\u2032 , an individual t exists such that ar(R, s, t) \u2208 A\u2032\u2032 and if B is atomic, then B(t) \u2208 A\u2032\u2032, and if B = \u00acA, then A(t) 6\u2208 A\u2032\u2032. By the definition of full single blocking, if B is atomic, then B([t]A\u2032\u2032) \u2208 A\u2032\u2032, and if B = \u00acA, then A([t]A\u2032\u2032) 6\u2208 A\u2032\u2032. By the definition of I, we have \u3008[s]A\u2032\u2032 , [t]A\u2032\u2032\u3009 \u2208 RI , and [t]A\u2032\u2032 \u2208 BI ; therefore, I |= D(\u03c3(x)). The case when Vj = D(y) is analogous.\n\u2022 If Vj = x \u2248 zi, then \u03c3\u2032(x) \u2248 \u03c3\u2032(zi) \u2208 A\u2032\u2032; since the \u2248-rule is not applicable to A\u2032\u2032, we have \u03c3\u2032(x) = \u03c3\u2032(zi). But then, since named individuals cannot block other individuals, we have \u03c3(x) = \u03c3\u2032(x); hence, I |= \u03c3(x) \u2248 \u03c3(zi).\nThus, in all cases we have I |= \u03c3(Vj). The case when r does not contain a role atom R(x, y) in the antecedent is analogous, so I |= (A, C)."}, {"heading": "5.2 Subset Blocking", "text": "In tableau algorithms for DLs without inverse roles, full single blocking condition from Definition 11 can be further weakened to full subset blocking (Baader et al., 1996).\nDefinition 12 (Full Subset Blocking). Full subset blocking is obtained from full single blocking (see Definition 11) by changing the notion of direct blocking: a blockable individual s is directly blocked by an individual t if and only if t is not blocked, t \u227a s, and LA(s) \u2286 LA(t).\nFull subset blocking is problematic in the hypertableau setting. Consider the knowledge base that consists of an ABox A10 and a TBox corresponding to the HT-clauses C10.\nA10 = { \u2203T.C(a) } C10 = { C(x)\u2192 \u2203R.C(x), C(x)\u2192 \u2203S.D(x), S(x, y) \u2227D(y)\u2192 E(x), R(x, y) \u2227 E(y)\u2192 \u22a5 } (38)\nOn K10, our algorithm can produce the ABox shown in Figure 12, in which d is blocked by b. If, however, we expand \u2203S.D(d) into S(d, e) and D(e), we can derive E(d); together with R(b, d) and the HT-clause R(x, y) \u2227 E(y)\u2192 \u22a5, we get a contradiction.\nThe problem arises because, in the hypertableau setting, the syntactic distinction between atomic and inverse roles is lost: an atom R\u2212(x, y) is transformed (by the function ar) into the semantically equivalent atom R(y, x). The HT-clause S(x, y) \u2227D(y)\u2192 E(x) can be seen as including an implicit inverse role, because it examines a successor of x in the antecedent in order to derive new information about x in the consequent, thus mimicking the behavior of tableau algorithms with the semantically equivalent GCI D v \u2200S\u2212.E.\nThe semantically equivalent but inverse-free GCI \u2203S.D v E would, in our hypertableau algorithm, be transformed into exactly the same HT-clause. In the tableau setting, however, this GCI would be treated very differently: it would result in the v-rule deriving (E t \u2200S.\u00acD)(s) for all individuals s. A similar effect could be achieved in the hypertableau setting by translating \u2203S.D v E into two HT-clauses: > \u2192 E(x) \u2228Q(x) and Q(x) \u2227 S(x, y) \u2227D(y)\u2192 \u22a5. This introduces nondeterminism, but solves the problem with full subset blocking by deriving either E(c) or Q(c), the first of which leads to an immediate contradiction, and the second of which delays blocking.\nIn general, it is easy to see that full subset blocking could be used in the hypertableau setting by modifying the preprocessing phase so as to ensure that HT-clauses do not include such implicit inverses. It is not clear, however, if this would be very useful: it would result in (possibly) smaller ABoxes, but at the cost of (possibly) larger derivation trees."}, {"heading": "5.3 The Number of Blockable Individuals", "text": "Buchheit et al. (1993) presented a tableau algorithm for the DL ALCNR which, due to anywhere blocking, runs in NExpTime instead of 2NExpTime, and Donini et al. (1998) presented a similar result for the basic DLALC. It is interesting to compare these algorithms to ours to see whether anywhere blocking can improve the worst-case complexity of our algorithm when K is a SHIQ+ knowledge base. In such a case, no HT-clause in \u039e(K) contains a nominal guard concept, which prevents the derivation of assertions satisfying the preconditions of the NI -rule; hence, no new root individuals are introduced in a derivation, which eliminates a significant source of complexity.\nThe following example shows that, unfortunately, anywhere blocking does not improve the worst-case complexity; in fact, we identify a tension between and- and or-\nbranching. In the example, we use the well-known encoding of binary numbers by concepts B0, B1, . . . , Bk\u22121: we assign to each individual s in an ABox A a binary number `A(s) = bk\u22121 . . . b1b0 such that bi = 1 if and only if Bi(s) \u2208 A. Using k concepts, we can thus encode 2k different binary numbers. Furthermore, for any atomic role R, using the well-known R-successor counting formula (Tobies, 2000), we can ensure that, whenever an individual t is an R-successor of s in A, then `A(t) = (`A(s) + 1) mod 2k; we omit this formula for the sake of brevity. Let K11 be the following knowledge base. For the sake of brevity, we omit the HT-clauses corresponding to the axioms in K11.\nC(a)(39) C v \u2203L.C u \u2203R.C(40)\n(The R-successor formula for B0, . . . , Bk\u22121)(41) (The L-successor formula for B0, . . . , Bk\u22121)(42) B0 u . . . uBk\u22121 v A(43) \u2203L.A u \u2203R.A v A(44)\nFigure 13 schematically presents a derivation on K11 in which a doubly exponential number of blockable individuals is introduced.17 For simplicity of presentation, we use single anywhere blocking. Due to (39)\u2013(42), our algorithm can create individuals a.1, a.2, a.1.1, a.1.2, a.1.1.1, a.1.1.2, and so on, such that s.1 is an L-successor of s, and s.2 is an R-successor of s. After creating the individuals of the form a.12 k\u22121.1 and a.12 k\u22121.2 where 12 k\u22121 is a string of 2k\u22121 ones, each individual x.1 blocks x.2 (c.f. Figure 13a). But then, due to (43), a.12 k\u22121.1 and a.12 k\u22121.2 become instances of A. By (44), a.12 k\u22121 is made an instance of A as well, so it does not block its sibling a.12 k\u22122.2 any more; hence, a.12\nk\u22122.2 is now expanded to exponential depth (c.f. Figure 13b). By repeating this process, the algorithm derives that a.12 k\u22122 is an instance of A, but then it does not block its sibling a.12 k\u22123.2 (c.f. Figure 13d). Eventually, the algorithm constructs a binary tree of exponential depth, thus creating a doubly-exponential number of blockable nodes in total (c.f. Figure 13d).\nBuchheit et al. and Donini et al. obtained the nondeterministic exponential behavior by applying the u-, t-, \u2200-, and v-rules exhaustively before applying the \u2203-rule. Such a strategy ensures that the label of an individual s is fully constructed before introducing a successor of s, which prevents individuals from being indirectly blocked. On K11, this means that the GCI (44) is applied to each individual s before introducing its successors. Thus, before the existentials on s are expanded, the assertion (\u2200L.\u00acA t \u2200R.\u00acA tA)(s) is introduced and one disjunct is chosen nondeterministically. The choices (\u2200L.\u00acA)(s) and (\u2200R.\u00acA)(s) will lead to a clash, so the algorithm eventually derives A(s), before it expands the existentials on s and introduces s.1 and s.2. Thus, while generating at most exponential models, this algorithm incurs a massive amount of nondeterminism.\nNondeterministic exponential behavior can be guaranteed in the hypertableau algorithm by nondeterministically fixing the label of each individual before applying the \u2264-rule to it. This technique is similar to the one used by Tobies (2001) in order to obtain a PSpace\n17. Initially, we suggested informally that our algorithm should run in NExpTime on SHIQ (Motik, Shearer, & Horrocks, 2007). As this example shows, this is not the case.\ndecision procedure for concept satisfiability in a DL with inverse roles but without GCIs. The performance results in Section 7, however, seem to suggest that this might not be beneficial in practice. Still, it might be worth exploring whether nondeterministically adding concepts to labels of individuals can be used as an optimization that would detect \u201cearly blocks\u201d and thus prevent the construction of large models."}, {"heading": "5.4 The Number of Root Individuals", "text": "SHOIQ is NExpTime-complete (Tobies, 2000), and it is straightforward to extend this result to SHOIQ+. Thus, one might wonder whether the complexity result in Theorem 1 can be sharpened to obtain a worst-case optimal decision procedure. This, unfortunately, is not the case: we present an example on which our algorithm generates a doubly-exponential number of root individuals. We construct K12 by extending K11 (axioms (39)\u2013(44)) with the following two axioms:\nB0 u . . . uBk\u22121 v {b}(45) A v \u2264 2L\u2212.> u\u2264 2R\u2212.>(46)\nAs shown in Section 5.3, the axioms of K11 can cause our algorithm to construct a binary tree of blockable individuals with exponential depth. Axiom (45) of K12, however, merges the leaves of this tree into the single named individual b, and axiom (46) ensures that the NI-rule is applied to each of the remaining blockable individuals, beginning with the neighbors of b. If, at each application of the NI-rule, we always merge blockable individuals into root individuals as shown in Figure 14a, then our algorithm constructs the ABox shown in Figure 14b, which contains two binary trees of root individuals of depth 2k/2. Unlike the case with K11, fully constructing individual labels does not avoid double-exponential behavior, since the promotion of blockable individuals to root individuals prevents blocking."}, {"heading": "6. Algorithm Optimizations", "text": "DL reasoning algorithms are often used in practice to compute a classification of a knowledge base K\u2014that is, to determine whether K |= A v B for each pair of atomic concepts A and B occurring in K. A na\u0308\u0131ve classification algorithm would involve a quadratic number of calls to the subsumption checking algorithm, each of which can potentially be highly expensive. To obtain acceptable levels of performance, various optimizations have been developed that reduce the number of subsumption checks and the time required for each check (Baader, Hollunder, Nebel, Profitlich, & Franconi, 1994). The well-known dependency-directed backtracking optimization (Horrocks, 2007) can readily be used with the hypertableau calculus. Furthermore, we have developed two simple optimizations that, to the best of our knowledge, have not been considered previously in the literature."}, {"heading": "6.1 Reading Classification Relationships from Concept Labels", "text": "Let (A, C) be an ABox and a set of HT-clauses obtained by clausifying a knowledge base K, and let A and B be atomic concepts for which we want to check whether K |= A v B; since A and B are atomic, this is the case if and only if (A\u2032, C) is unsatisfiable where\nb\na\nL R\nL\nL R\nR\nL\nL R\nL\nL R\nR\nR\nb.\u3008L,>, 1\u3009 b.\u3008L,>, 2\u3009\nb.\u3008L,>, 2\u3009.\u3008L,>, 2\u3009b.\u3008L,>, 2\u3009.\u3008L,>, 1\u3009b.\u3008L,>, 1\u3009.\u3008L,>, 1\u3009 b.\u3008L,>, 1\u3009.\u3008L,>, 2\u3009\n(a) A root introduction strategy for the NI-rule\na\nL R\nL\nL R\nR\nb\n|2k/2 \u2212 1|\n|2k/2 \u2212 1|\n(b) The resulting tree, containing a doubly-exponential number of root individuals\nA\u2032 = A \u222a {A(a),\u00acB(a)} and a is a fresh individual. Let A1 be a clash-free ABox labeling a leaf in a derivation from (A\u2032, C). We can use A1 to learn the following things about subsumption in K. The proofs of these claims are straightforward.\n1. If C(a) \u2208 A1 for some concept C and the derivation of C(a) does not depend on a nondeterministic choice, then K |= A v C.\n2. If A1 has been obtained from A\u2032 deterministically, then K |= A v C only if C(a) \u2208 A1.\n3. If C(b) \u2208 A1 but D(b) 6\u2208 A1 for C and D concepts and b an individual that is not blocked, then K 6|= C v D.\nThus, if K is deterministic, we can classify it using a linear number of calls to the hypertableau algorithm: for each atomic concept A, we check the satisfiability of (A \u222a {A(a)}, C); if the algorithm produces a clash-free ABox A1, the set of subsumers of A are contained in LA1(a). These optimizations are applicable in the case of tableau algorithms as well; however, they might be less effective due to increased or-branching."}, {"heading": "6.2 Caching Blocking Labels", "text": "Let T and R be a SHIQ+ TBox and RBox, respectively, and let C = \u039eT R(T \u222a R); since T does not contain nominals, no assertions involving nominal guard concepts are needed. Furthermore, assume that the classification of T \u222a R involves n calls to the hypertableau algorithm for ({Ai(ai),\u00acBi(ai)}, C). Then, if a derivation for ({Ai(ai),\u00acBi(ai)}, C) contains a leaf node labeled with a clash-free ABox Ai, we can use the nonblocked individuals from Ai as blockers in all subsequent satisfiability checks of ({Aj(aj),\u00acBj(aj)}, C) for j > i.\nThis is a simple consequence of the following fact. Let I1 and I2 be two models of T \u222aR such that 4I1 \u22294I2 = \u2205; furthermore, let I be defined as 4I = 4I1 \u222a4I2 , AI = AI1 \u222aAI2 , and RI = RI1 \u222aRI2 , for each atomic concept A and each atomic role R. Then, by a simple induction on the structure of axioms in T \u222a R, it is trivial to show that I |= T \u222a R. This property does not hold in the presence of nominals, which can impose a bound on the number of elements in the interpretation of a concept; the bound could be satisfied in I1 and I2 individually, but violated in I.\nOur optimization is correct because, instead of ({Ai(ai),\u00acBi(ai)}, C), we can check the satisfiability of (Ai \u222a {Ai(ai),\u00acBi(ai)}, C), and in doing so we can use the individuals from Ai as potential blockers due to anywhere blocking. This optimization can be seen as a very simple form of model caching (Horrocks, 2007), and it has been key to obtaining the results that we present in Section 7. For example, on GALEN only one subsumption test is costly because it computes a substantial part of a model of the TBox; all subsequent subsumption tests reuse large parts of that model.\nIn practice, we do not need to keep the entire ABox Ai around; rather, for each nonblocked blockable individual t with a predecessor t\u2032, we simply need to retain the sets LAi(t), LAi(t\u2032), LAi(t, t\u2032), and LAi(t\u2032, t)."}, {"heading": "7. Implementation and Evaluation", "text": "Based on the calculus from Section 4, we have implemented a prototype DL reasoner called HermiT. In order to estimate how well our calculus performs in practice, we have compared HermiT with two state-of-the-art tableau reasoners on several practical problems. The objective of this evaluation was not to establish the superiority of HermiT, but to compare the behavior of our calculus with that of the tableau calculi used in many existing systems, and to demonstrate the usefulness of our calculus on realistic problems.\nIt is important to understand that HermiT is a prototype, and as such does not always outperform the well-established reasoners. In particular, HermiT may be uncompetitive\non ontologies where specialized optimizations are needed for good performance. For example, HermiT cannot process the SNOMED CT ontology due to the very large number of concepts, while many other reasoners can classify the ontology easily. These reasoners, however, employ techniques that are quite different from the standard tableau algorithm; for example, on an EL++ ontology such as SNOMED CT, Pellet uses the reasoning algorithm by Baader, Brandt, and Lutz (2005), and other reasoners employ specialized techniques as well (Haarslev, Mo\u0308ller, & Wandelt, 2008). Similarly, artificial test problems such as those used in the TANCS comparison at the Tableaux\u201998 conference (Balsiger & Heuerding, 1998; Balsiger, Heuerding, & Schwendimann, 2000) and the DL\u201998 workshop (Horrocks & PatelSchneider, 1998b) are often either easy for reasoners employing particular optimizations or are only difficult due to the fact that they encode large propositional satisfiability problems (Horrocks & Patel-Schneider, 1998a). Since our goal was to demonstrate the usefulness of the hypertableau calculus on realistic problems, we have chosen to ignore such ontologies and test problems, as they mainly test specialized calculi and optimizations that are applicable to various sublanguages of SHOIQ+. Instead, we focus our evaluation on practical ontologies in which the main difficulty is due to nontrivial reasoning problems encountered during classification.\nIn addition to the hypertableau calculus described in Section 4, HermiT also implements the optimizations from Section 6 and the well-known dependency directed backtracking optimization (Horrocks, 2007). Thus, HermiT fully supports SHOIQ+ and it can perform both satisfiability and subsumption testing as well as knowledge base classification. An extensive discussion of implementation techniques is beyond the scope of this paper; we only comment briefly on the implementation of anywhere blocking. In the DL community, it is commonly understood that anywhere blocking is more costly than ancestor blocking because, to determine the blocking status of an individual, one may need to examine all individuals in an ABox and not just the individual\u2019s ancestors. Our implementation avoids this problem by maintaining a hash table in which individuals are indexed by their four blocking labels. The table is created by scanning all individuals in A in the increasing sequence of the ordering \u227a. For each individual s in A, if the parent of s is blocked, then s is indirectly blocked; otherwise, the algorithm queries the hash table for an individual whose blocking labels are equal to those of s. If the hash table contains such an individual t, then s is directly blocked in A by t; otherwise, s is not blocked in A so it is added into the hash table. The blocking status of all individuals in A can thus be determined with a linear number of hash table lookups.\nWe used Pellet 2.0.0rc4 (Parsia & Sirin, 2004) and FaCT++ 1.2.2 (Tsarkov & Horrocks, 2006) as reference implementations of the SHOIQ tableau algorithm (Horrocks & Sattler, 2007). Pellet employs ancestor blocking, while FaCT++ has recently been extended with anywhere blocking. At the time of writing, however, the implementation of anywhere blocking in FaCT++ was known to be incorrect,18 so we switched this feature off and used FaCT++ with ancestor blocking as well. To measure the effects of ancestor vs. anywhere blocking, we also used HermiT-Anc\u2014a version of HermiT with ancestor blocking.\nWe used a collection of 392 test ontologies that we assembled from three independent sources.\n18. Personal communication with Dmitry Tsarkov.\n\u2022 The Gardiner ontology suite (Gardiner, Horrocks, & Tsarkov, 2006) is a collection of OWL ontologies gathered from the Web and includes many of the most commonlyused OWL ontologies.\n\u2022 The Open Biological Ontologies (OBO) Foundry19 is a collection of biology and life science ontologies.\n\u2022 GALEN (Rector & Rogers, 2006) is a large and complex biomedical ontology which has proven notoriously difficult to classify with existing reasoners.\nWe have preprocessed all ontologies to resolve ontology imports and eliminate some trivial syntactic errors. Thus, each test ontology can be parsed as a single file using the OWL API. All test ontologies are available online.20\nWe measured the time needed to classify each test ontology using the mentioned reasoners. All tests were performed on a 2.2 GHz MacBook Pro with 2 GB of physical memory. A classification attempt was aborted if it exhausted all available memory (Java tools were allowed to use 1 GB of heap space), or if it exceeded a timeout of 30 minutes.\nThe three reasoners exhibited negligible differences in performance on most of the test ontologies. Therefore, we discuss next only the test results for \u201cinteresting\u201d ontologies\u2014 that is, ontologies that can be classified by at least one of the tested reasoners, and that are either not trivial or on which the tested reasoners exhibited a significant difference in performance. These include several ontologies from the OBO corpus (Molecule Role, XP Uber Anatomy, XP Plant Anatomy, Cellular Component, Gazetteer, CHEBI), two versions of the National Cancer Institute (NCI) Thesaurus (Hartel et al., 2005), two versions of the GALEN medical terminology ontology, two versions of the Foundational Model of Anatomy (FMA) (Golbreich et al., 2006), the Wine ontology from the OWL Guide,21 two SWEET ontologies developed at NASA,22 and a version of the DOLCE ontology developed at the Institute of Cognitive Science and Technology of the Italian National Research Council.23 Basic statistical information about these ontologies is summarized in Table 10. We noticed that, for all three reasoners, classification times may vary from run to run. For Pellet and HermiT, this is due to Java\u2019s collection library: the order of iteration over collections often depends on the objects\u2019 hash codes, and these may vary from run to run; that, in turn, may change the order in which the derivation rules are applied, and some orders may be better than others. We conjecture that FaCT++ is susceptible to similar variations. While the times may vary, we have not noticed a case where an ontology might be successfully classified in one run, but not in another. Therefore, in Table 11 we present the classification times for the \u201cinteresting\u201d ontologies that we obtained on one particular run; these times can be taken as being \u201ctypical.\u201d We identified four groups of ontologies, which we delineate in Tables 10 and 11 by horizontal lines.\n19. http://obofoundry.org/ 20. http://hermit-reasoner.com/2009/JAIR_benchmarks/ 21. http://www.w3.org/TR/owl-guide/ 22. http://sweet.jpl.nasa.gov/ontology/ 23. http://www.loa-cnr.it/DOLCE.html\nOn the ontologies in the first group, HermiT performs similarly to HermiT-Anc, which suggests little impact of anywhere blocking on the performance. Consequently, we believe that HermiT outperforms the other reasoners mainly due to the reduced nondeterminism of the hypertableau calculus. As shown in Table 10, Molecule Role, XP Uber Anatomy, and NCI-1 do not use disjunctions, so HermiT classifies them deterministically using a linear number of calls to the hypertableau algorithm. FaCT++ outperforms HermiT on NCI-1 because this ontology can be classified using the completely defined concepts optimization (Tsarkov & Horrocks, 2005a), which FaCT++ implements but HermiT does not. This optimization enables FaCT++ to use simpler structural reasoning techniques on ontologies that satisfy certain syntactic constraints.\nOn the ontologies in the second group, HermiT-Anc is significantly slower than HermiT. This suggests that anywhere blocking significantly improves the performance since it prevents the construction of large models. Pellet runs out of memory on all ontologies in this group; furthermore, FaCT++ cannot process two of them and is significantly slower than HermiT on CHEBI. FaCT++, however, is faster than HermiT-Anc on CHEBI and GALENdoctored, and we conjecture that this is mainly due to the ordering heuristics (Tsarkov & Horrocks, 2005b) used by FaCT++. The superior performance of HermiT on the ontologies in this group is mainly due to the fact that all of these ontologies can be classified deterministically using a linear number of concept satisfiability tests. Furthermore, HermiT\u2019s classification time is in most cases dominated by only the first such test, as the caching of blocking labels described in Section 6.2 makes subsequent tests easy.\nOn the ontologies in the third group, HermiT is significantly slower than the other reasoners. As Table 10 shows, all ontologies in this group contain nominals, which prevents HermiT from caching blocking labels. Furthermore, due to nominals, the ABox must be\ntaken into account during classification, and HermiT currently reapplies the hypertableau rules to the entire ABox in each run. Effectively, HermiT does not reuse any computation between different hypertableau runs. The other two reasoners, however, use the completion graph caching optimization (Sirin, Cuenca Grau, & Parsia, 2006), in which the tableau rules are first applied to the entire ABox, and the resulting completion graph is used as a starting point in each subsequent run.\nHermiT was unable to classify the two ontologies in the fourth group. Both NCI-2 and FMA-Constitutional use disjunctions, so they cannot be classified using a linear number of concept satisfiability tests; instead, HermiT uses the classification algorithm by Baader et al. (1994). All classification tests are straightforward (each test takes less than 50 ms); however, the resulting taxonomy is rather shallow, so HermiT makes an almost quadratic number of tests. Both Pellet and FaCT++, however, use more optimized versions of the classification algorithm that reduce the number of tests that need to be performed.\nTo summarize, although HermiT is not better than Pellet and FaCT++ on all ontologies, our results clearly demonstrate the practical potential of both the reduced nondeterminism and anywhere blocking. In fact, anywhere blocking can mean the difference between success and failure on complex ontologies, which suggests that and-branching is a more significant source of inefficiency in practice than or-branching. Anywhere blocking is applicable\nto tableau calculi as well (as mentioned earlier, FaCT++ already contains a preliminary version of it), so we believe that our results can be used to improve the performance of tableau reasoners as well without the need for a major redesign. Conversely, most of the optimizations used in tableau reasoners can be used with the hypertableau algorithm, and incorporating them into HermiT would make HermiT competitive with Pellet and FaCT++ in those cases where HermiT is currently slower."}, {"heading": "8. Conclusion", "text": "In this paper we presented a novel reasoning algorithm for DLs. The algorithm is based on hyperresolution with anywhere blocking, which reduces the nondeterminism due to GCIs and the sizes of generated models. Furthermore, the algorithm uses a novel refinement of the NI -rule which can reduce the amount of nondeterminism introduced in order to handle the interaction between nominals, inverse roles, and number restrictions (Horrocks & Sattler, 2007). This refined version of the NI -rule is equally applicable to tableau algorithms.\nWe have implemented our calculus and have conducted an extensive performance comparison. Our results show that the combination of the new calculus and novel optimizations significantly increases the performance of DL reasoning in practice: our reasoner is currently the only one that can classify several complex ontologies.\nDespite this advance in performance, there are still some ontologies, such as the full version of GALEN,24 that defeat HermiT (and state-of-the-art tableau reasoners). This is because the large number of cyclic axioms in these ontologies cause HermiT to construct extremely large ABoxes and eventually exhaust all available memory. To alleviate this problem, we have developed a reasoning technique in which the \u2265-rule is modified to nondeterministically reuse individuals from the ABox generated thus far. Initial experiments with this technique have shown very promising results (Motik & Horrocks, 2008).\nFinally, we plan to extend our technique to the DL SROIQ, which extends SHOIQ with more expressive role inclusion axioms that allow us to express, for example, that the brother of a person\u2019s father is also that person\u2019s uncle. This logic is of considerable interest as it underpins OWL 2\u2014the extension of OWL currently being standardized by the W3C."}, {"heading": "Acknowledgments", "text": "This is an extended version of a paper published at CADE 2007 (Motik et al., 2007). We thank the anonymous reviewer for numerous comments that have contributed to the quality of this paper."}], "references": [{"title": "Pushing the EL Envelope", "author": ["F. Baader", "S. Brandt", "C. Lutz"], "venue": "Proc. of the 19th Int. Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Baader et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2005}, {"title": "The Description Logic Handbook: Theory, Implementation and Applications (2nd edition)", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2007}, {"title": "An Empirical Analysis of Optimization Techniques for Terminological Representation systems or: \u201cMaking KRIS Get a Move on", "author": ["F. Baader", "B. Hollunder", "B. Nebel", "Profitlich", "H.-J", "E. Franconi"], "venue": "Applied Intelligence,", "citeRegEx": "Baader et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Baader et al\\.", "year": 1994}, {"title": "Basic Description Logics", "author": ["F. Baader", "W. Nutt"], "venue": null, "citeRegEx": "Baader and Nutt,? \\Q2007\\E", "shortCiteRegEx": "Baader and Nutt", "year": 2007}, {"title": "An Overview of Tableau Algorithms for Description Logics", "author": ["F. Baader", "U. Sattler"], "venue": "Studia Logica,", "citeRegEx": "Baader and Sattler,? \\Q2001\\E", "shortCiteRegEx": "Baader and Sattler", "year": 2001}, {"title": "Comparison of Theorem Provers for Modal Logics \u2014 Introduction and Summary", "author": ["P. Balsiger", "A. Heuerding"], "venue": "Proc. of the 2nd Int. Conf. on Analytic Tableaux and Related Methods (TABLEAUX\u201998),", "citeRegEx": "Balsiger and Heuerding,? \\Q1998\\E", "shortCiteRegEx": "Balsiger and Heuerding", "year": 1998}, {"title": "A Benchmark Method for the Propositional Modal Logics K, KT, S4", "author": ["P. Balsiger", "A. Heuerding", "S. Schwendimann"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Balsiger et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Balsiger et al\\.", "year": 2000}, {"title": "Hyper Tableaux", "author": ["P. Baumgartner", "U. Furbach", "I. Niemel\u00e4"], "venue": "In Proc. of the European Workshop on Logics in Artificial Intelligence (JELIA \u201996),", "citeRegEx": "Baumgartner et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 1996}, {"title": "The Hyper Tableaux Calculus with Equality and an Application to Finite Model Computation", "author": ["P. Baumgartner", "U. Furbach", "B. Pelzer"], "venue": "Journal of Logic and Computation", "citeRegEx": "Baumgartner et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 2008}, {"title": "Blocking and Other Enhancements for BottomUp Model Generation Methods", "author": ["P. Baumgartner", "R.A. Schmidt"], "venue": "Proc. of the 3rd Int. Joint Conf. on Automated Reasoning (IJCAR 2006),", "citeRegEx": "Baumgartner and Schmidt,? \\Q2006\\E", "shortCiteRegEx": "Baumgartner and Schmidt", "year": 2006}, {"title": "On the Relative Expressiveness of Description Logics and Predicate Logics", "author": ["A. Borgida"], "venue": "Artificial Intelligence,", "citeRegEx": "Borgida,? \\Q1996\\E", "shortCiteRegEx": "Borgida", "year": 1996}, {"title": "A Deduction Method Complete for Refutation and Finite Satisfiability", "author": ["F. Bry", "S. Torge"], "venue": "Proc. European Workshop on Logics in Artificial Intelligence (JELIA \u201998),", "citeRegEx": "Bry and Torge,? \\Q1998\\E", "shortCiteRegEx": "Bry and Torge", "year": 1998}, {"title": "Decidable Reasoning in Terminological Knowledge Representation Systems", "author": ["M. Buchheit", "F.M. Donini", "A. Schaerf"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Buchheit et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Buchheit et al\\.", "year": 1993}, {"title": "Deciding Regular Grammar Logics with Converse Through First-Order Logic", "author": ["S. Demri", "H. de Nivelle"], "venue": "Journal of Logic, Language and Information,", "citeRegEx": "Demri and Nivelle,? \\Q2005\\E", "shortCiteRegEx": "Demri and Nivelle", "year": 2005}, {"title": "Tableau Caching for Description Logics with Inverse and Transitive Roles", "author": ["Y. Ding", "V. Haarslev"], "venue": "Proc. of the 2006 Int. Workshop on Description Logics (DL 2006),", "citeRegEx": "Ding and Haarslev,? \\Q2006\\E", "shortCiteRegEx": "Ding and Haarslev", "year": 2006}, {"title": "Complexity of Reasoning", "author": ["F.M. Donini"], "venue": null, "citeRegEx": "Donini,? \\Q2007\\E", "shortCiteRegEx": "Donini", "year": 2007}, {"title": "AL-log: Integrating Datalog and Description Logics", "author": ["F.M. Donini", "M. Lenzerini", "D. Nardi", "A. Schaerf"], "venue": "Journal of Intelligent Information Systems,", "citeRegEx": "Donini et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Donini et al\\.", "year": 1998}, {"title": "A Hybrid Tableau Algorithm for ALCQ", "author": ["J. Faddoul", "N. Farsinia", "V. Haarslev", "R. M\u00f6ller"], "venue": "Proc. of the 18th European Conf. on Artificial Intelligence (ECAI 2008),", "citeRegEx": "Faddoul et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Faddoul et al\\.", "year": 2008}, {"title": "Resolution Methods for the Decision Problem, Vol. 679 of LNAI", "author": ["C. Ferm\u00fcller", "T. Tammet", "N. Zamov", "A. Leitsch"], "venue": null, "citeRegEx": "Ferm\u00fcller et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Ferm\u00fcller et al\\.", "year": 1993}, {"title": "Resolution Decision Procedures", "author": ["C.G. Ferm\u00fcller", "A. Leitsch", "U. Hustadt", "T. Tammet"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Ferm\u00fcller et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Ferm\u00fcller et al\\.", "year": 2001}, {"title": "Automated Benchmarking of Description Logic Reasoners", "author": ["T. Gardiner", "I. Horrocks", "D. Tsarkov"], "venue": "In Proc. of the 2006 Description Logic Workshop (DL 2006),", "citeRegEx": "Gardiner et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gardiner et al\\.", "year": 2006}, {"title": "Hyperresolution for Guarded Formulae", "author": ["L. Georgieva", "U. Hustadt", "R.A. Schmidt"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "Georgieva et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Georgieva et al\\.", "year": 2003}, {"title": "The Foundational Model of Anatomy in OWL: Experience and Perspectives", "author": ["C. Golbreich", "S. Zhang", "O. Bodenreider"], "venue": "Journal of Web Semantics,", "citeRegEx": "Golbreich et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Golbreich et al\\.", "year": 2006}, {"title": "EXPTIME Tableaux with Global Caching for Description Logics with Transitive Roles, Inverse Roles and Role Hierarchies", "author": ["R. Gor\u00e9", "L.A. Nguyen"], "venue": "In Proc. of the 16th Int. Conf. on Automated Reasoning with Tableaux and Related Methods (TABLEAUX 2007),", "citeRegEx": "Gor\u00e9 and Nguyen,? \\Q2007\\E", "shortCiteRegEx": "Gor\u00e9 and Nguyen", "year": 2007}, {"title": "RACER System Description", "author": ["V. Haarslev", "R. M\u00f6ller"], "venue": "Proc. of the 1st Int. Joint Conf. on Automated Reasoning (IJCAR", "citeRegEx": "Haarslev and M\u00f6ller,? \\Q2001\\E", "shortCiteRegEx": "Haarslev and M\u00f6ller", "year": 2001}, {"title": "The Revival of Structural Subsumption in Tableau-Based Description Logic Reasoners", "author": ["V. Haarslev", "R. M\u00f6ller", "S. Wandelt"], "venue": "Proc. of the 21st Int. Workshop on Description Logics (DL 2008),", "citeRegEx": "Haarslev et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Haarslev et al\\.", "year": 2008}, {"title": "Modeling a description logic vocabulary for cancer research", "author": ["F.W. Hartel", "S. de Coronado", "R. Dionne", "G. Fragoso", "J. Golbeck"], "venue": "Journal of Biomedical Informatics,", "citeRegEx": "Hartel et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hartel et al\\.", "year": 2005}, {"title": "Using an Expressive Description Logic: FaCT or Fiction", "author": ["I. Horrocks"], "venue": "Proc. of the 6th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Horrocks,? \\Q1998\\E", "shortCiteRegEx": "Horrocks", "year": 1998}, {"title": "Implementation and Optimization Techniques", "author": ["I. Horrocks"], "venue": null, "citeRegEx": "Horrocks,? \\Q2007\\E", "shortCiteRegEx": "Horrocks", "year": 2007}, {"title": "Comparing Subsumption Optimizations", "author": ["I. Horrocks", "P.F. Patel-Schneider"], "venue": "Proc. of the 1998 Description Logic Workshop (DL\u201998),", "citeRegEx": "Horrocks and Patel.Schneider,? \\Q1998\\E", "shortCiteRegEx": "Horrocks and Patel.Schneider", "year": 1998}, {"title": "Ontology Reasoning in the SHOQ(D) Description Logic", "author": ["I. Horrocks", "P.F. Patel-Schneider"], "venue": "DL Systems Comparison", "citeRegEx": "Horrocks and Patel.Schneider,? \\Q1998\\E", "shortCiteRegEx": "Horrocks and Patel.Schneider", "year": 1998}, {"title": "Practical Reasoning for Very Expressive Description Logics", "author": ["I. Horrocks", "U. Sattler", "S. Tobies"], "venue": "Logic Journal of the IGPL,", "citeRegEx": "Horrocks et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2000}, {"title": "Reasoning with Individuals for the Description Logic SHIQ", "author": ["I. Horrocks", "U. Sattler", "S. Tobies"], "venue": "Proc. of the 17th Int. Conf. on Automated Deduction (CADE-17),", "citeRegEx": "Horrocks et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2000}, {"title": "Binary Absorption in Tableaux-Based Reasoning for Description Logics", "author": ["A.K. Hudek", "G. Weddell"], "venue": "Proc. of the 2006 Int. Workshop on Description Logics (DL 2006),", "citeRegEx": "Hudek and Weddell,? \\Q2006\\E", "shortCiteRegEx": "Hudek and Weddell", "year": 2006}, {"title": "Data Complexity of Reasoning in Very Expressive Description Logics", "author": ["U. Hustadt", "B. Motik", "U. Sattler"], "venue": "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Hustadt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2005}, {"title": "Issues of Decidability for Description Logics in the Framework of Resolution", "author": ["U. Hustadt", "R.A. Schmidt"], "venue": "Vol. 1761 of LNAI,", "citeRegEx": "Hustadt and Schmidt,? \\Q1999\\E", "shortCiteRegEx": "Hustadt and Schmidt", "year": 1999}, {"title": "Reasoning in Description Logics using Resolution and Deductive Databases", "author": ["B. Motik"], "venue": "Ph.D. thesis,", "citeRegEx": "Motik,? \\Q2006\\E", "shortCiteRegEx": "Motik", "year": 2006}, {"title": "Individual Reuse in Description Logic Reasoning", "author": ["B. Motik", "I. Horrocks"], "venue": "In Proc. of the 4th Int. Joint Conf. on Automated Reasoning (IJCAR", "citeRegEx": "Motik and Horrocks,? \\Q2008\\E", "shortCiteRegEx": "Motik and Horrocks", "year": 2008}, {"title": "Optimized Reasoning in Description Logics using Hypertableaux", "author": ["B. Motik", "R. Shearer", "I. Horrocks"], "venue": "Proc. of the 21st Conference on Automated Deduction (CADE-21),", "citeRegEx": "Motik et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2007}, {"title": "Computing Small Clause Normal Forms", "author": ["A. Nonnengart", "C. Weidenbach"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Nonnengart and Weidenbach,? \\Q2001\\E", "shortCiteRegEx": "Nonnengart and Weidenbach", "year": 2001}, {"title": "Pellet: An OWL-DL Reasoner", "author": ["B. Parsia", "E. Sirin"], "venue": "Poster at the 3rd Int. Semantic Web Conference (ISWC", "citeRegEx": "Parsia and Sirin,? \\Q2004\\E", "shortCiteRegEx": "Parsia and Sirin", "year": 2004}, {"title": "OWL Web Ontology Language: Semantics and Abstract Syntax, W3C Recommendation", "author": ["P.F. Patel-Schneider", "P. Hayes", "I. Horrocks"], "venue": null, "citeRegEx": "Patel.Schneider et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Patel.Schneider et al\\.", "year": 2004}, {"title": "A Structure-Preserving Clause Form Translation", "author": ["D.A. Plaisted", "S. Greenbaum"], "venue": "Journal of Symbolic Logic and Computation,", "citeRegEx": "Plaisted and Greenbaum,? \\Q1986\\E", "shortCiteRegEx": "Plaisted and Greenbaum", "year": 1986}, {"title": "Ontological and Practical Issues in Using a Description Logic to Represent Medical Concept Systems: Experience from GALEN", "author": ["A.L. Rector", "J. Rogers"], "venue": "Tutorial Lectures of the 2nd Int. Summer School 2006,", "citeRegEx": "Rector and Rogers,? \\Q2006\\E", "shortCiteRegEx": "Rector and Rogers", "year": 2006}, {"title": "Automatic Deduction with Hyper-Resolution", "author": ["A. Robinson"], "venue": "Int. Journal of Computer Mathematics,", "citeRegEx": "Robinson,? \\Q1965\\E", "shortCiteRegEx": "Robinson", "year": 1965}, {"title": "A Principle for Incorporating Axioms into the FirstOrder Translation of Modal Formulae", "author": ["R.A. Schmidt", "U. Hustadt"], "venue": "Proc. of the 19th Int. Conf. on Automated Deduction (CADE-19),", "citeRegEx": "Schmidt and Hustadt,? \\Q2003\\E", "shortCiteRegEx": "Schmidt and Hustadt", "year": 2003}, {"title": "From Wine to Water: Optimizing Description Logic Reasoning for Nominals", "author": ["E. Sirin", "B. Cuenca Grau", "B. Parsia"], "venue": "Proc. of the 10th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Sirin et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Sirin et al\\.", "year": 2006}, {"title": "The Complexity of Reasoning with Cardinality Restrictions and Nominals in Expressive Description Logics", "author": ["S. Tobies"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Tobies,? \\Q2000\\E", "shortCiteRegEx": "Tobies", "year": 2000}, {"title": "Complexity Results and Practical Algorithms for Logics in Knowledge Representation", "author": ["S. Tobies"], "venue": "Ph.D. thesis, RWTH Aachen,", "citeRegEx": "Tobies,? \\Q2001\\E", "shortCiteRegEx": "Tobies", "year": 2001}, {"title": "Efficient Reasoning with Range and Domain Constraints", "author": ["D. Tsarkov", "I. Horrocks"], "venue": "Proc. of the 2004 Int. Workshop on Description Logics (DL 2004),", "citeRegEx": "Tsarkov and Horrocks,? \\Q2004\\E", "shortCiteRegEx": "Tsarkov and Horrocks", "year": 2004}, {"title": "Optimised Classification for Taxonomic Knowledge Bases", "author": ["D. Tsarkov", "I. Horrocks"], "venue": "Proc. of the 2005 Int. Workshop on Description Logics (DL", "citeRegEx": "Tsarkov and Horrocks,? \\Q2005\\E", "shortCiteRegEx": "Tsarkov and Horrocks", "year": 2005}, {"title": "Ordering Heuristics for Description Logic Reasoning", "author": ["D. Tsarkov", "I. Horrocks"], "venue": "Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Tsarkov and Horrocks,? \\Q2005\\E", "shortCiteRegEx": "Tsarkov and Horrocks", "year": 2005}, {"title": "FaCT++ Description Logic Reasoner: System Description", "author": ["D. Tsarkov", "I. Horrocks"], "venue": "In Proc. of the 3rd Int. Joint Conf. on Automated Reasoning (IJCAR 2006),", "citeRegEx": "Tsarkov and Horrocks,? \\Q2006\\E", "shortCiteRegEx": "Tsarkov and Horrocks", "year": 2006}, {"title": "Planning of Axiom Absorption", "author": ["J. Wu", "V. Haarslev"], "venue": "Proc. of the 21st Int. Workshop on Description Logics (DL 2008),", "citeRegEx": "Wu and Haarslev,? \\Q2008\\E", "shortCiteRegEx": "Wu and Haarslev", "year": 2008}], "referenceMentions": [{"referenceID": 28, "context": "Numerous optimizations have been developed in an effort to reduce the size of the search space (Horrocks, 2007).", "startOffset": 95, "endOffset": 111}, {"referenceID": 15, "context": "Two main sources of complexity in tableau calculi have been identified in the literature (Donini, 2007).", "startOffset": 89, "endOffset": 103}, {"referenceID": 27, "context": "Various absorption optimizations (Horrocks, 1998; Tsarkov & Horrocks, 2004; Hudek & Weddell, 2006; Horrocks, 2007) have been developed to reduce the nondeterminism in tableau calculi.", "startOffset": 33, "endOffset": 114}, {"referenceID": 28, "context": "Various absorption optimizations (Horrocks, 1998; Tsarkov & Horrocks, 2004; Hudek & Weddell, 2006; Horrocks, 2007) have been developed to reduce the nondeterminism in tableau calculi.", "startOffset": 33, "endOffset": 114}, {"referenceID": 44, "context": "Our algorithm can be viewed as a hybrid of resolution and tableau, and is related to the hypertableau (Baumgartner, Furbach, & Niemel\u00e4, 1996) and hyperresolution (Robinson, 1965) calculi.", "startOffset": 162, "endOffset": 178}, {"referenceID": 27, "context": "Various absorption optimizations (Horrocks, 1998; Tsarkov & Horrocks, 2004; Hudek & Weddell, 2006; Horrocks, 2007) have been developed to reduce the nondeterminism in tableau calculi. The second source of complexity in tableau calculi is known as and-branching : the expansion of a model due to existential quantifiers can generate very large models. Apart from memory consumption problems, and-branching can increase or-branching by increasing the number of individuals to which GCIs are applied. In this paper, we present a reasoning calculus that addresses both sources of complexity. We focus on the DL SHOIQ, which is obtained by extending SHOIQ with local reflexivity and disjoint, reflexive, irreflexive, symmetric, and asymmetric roles. SROIQ further extends SHOIQ with generalized role inclusions of the form R1 \u25e6 . . . \u25e6Rn v R. Generalized role inclusions can be encoded using standard GCIs as proposed by Demri and de Nivelle (2005); thus, by adding a suitable preprocessing phase, the results from this paper should allow us to handle SROIQ (and hence OWL 2) as well.", "startOffset": 34, "endOffset": 944}, {"referenceID": 26, "context": "To ensure termination, we use the pairwise blocking technique (Horrocks, Sattler, & Tobies, 2000b) to detect cyclic computations. Due to hyper-inferences, the soundness and correctness proofs by Horrocks et al. (2000b) do not carry over immediately to our calculus; in fact, certain simpler blocking conditions applicable to weaker DLs cannot be straightforwardly transferred to our setting.", "startOffset": 63, "endOffset": 219}, {"referenceID": 15, "context": "Anywhere blocking has already been used with single blocking (Buchheit, Donini, & Schaerf, 1993; Baader, Buchheit, & Hollunder, 1996; Donini & Massacci, 2000; Donini, Lenzerini, Nardi, & Schaerf, 1998); however, to the best of our knowledge, it has been neither used with the more sophisticated pairwise blocking nor tested in practice. Ensuring termination of a tableau decision procedure for DLs with nominals, inverse roles, and number restrictions has proven notoriously difficult. This problem was finally solved by Horrocks and Sattler (2007) by extending the tableau calculus with a nominal introduction rule.", "startOffset": 72, "endOffset": 549}, {"referenceID": 28, "context": "The v-rule adds a disjunction for each GCI to each individual in an ABox and is thus a major source of or-branching and inefficiency (Horrocks, 2007).", "startOffset": 133, "endOffset": 149}, {"referenceID": 28, "context": "None of the standard backtracking optimizations (Horrocks, 2007) are helpful: the problem arises because the order in which the individuals are processed makes the guesses on ai independent from the guesses on aj for i 6= j.", "startOffset": 48, "endOffset": 64}, {"referenceID": 27, "context": "Tableau algorithms are usually free to choose the order in which they process the assertions in an ABox; in fact, finding an order that exhibits good performance in practice requires advanced heuristics (Tsarkov & Horrocks, 2005b). Let us assume that the algorithm chooses to process the assertions on ai before those on bj . Hence, by applying the derivation rules to all ai, a tableau algorithm derives the assertions shown in line (iii) of Figure 1; after that, by applying the derivation rules to all bi, the algorithm derives the assertions shown in line (iv) of Figure 1. The ABox now contains both A(an) and \u00acA(an), which is a contradiction. Thus, the algorithm needs to backtrack its most recent choice, so it flips its guess on bn\u22121 to A(bn\u22121). This generates a contradiction on bn\u22121, so the algorithm backtracks from all guesses for bi, changes the guess on an to A(an), and repeats the work for all bi. This also leads to a contradiction, so the algorithm must revise its guess for an\u22121; but then, two guesses are again possible for an. In general, after revising a guess for ai, all possibilities for aj , i < j \u2264 n, must be reexamined, which results in exponential behavior. None of the standard backtracking optimizations (Horrocks, 2007) are helpful: the problem arises because the order in which the individuals are processed makes the guesses on ai independent from the guesses on aj for i 6= j. The GCI \u2203R.A v A, however, is not inherently nondeterministic: it is equivalent to the Horn clause \u2200x, y : [R(x, y) \u2227A(y)\u2192 A(x)], which can be applied bottom-up to derive the assertions A(bn), A(an\u22121), . . . , A(a0) and eventually reveal a contradiction on a0. These inferences are deterministic,3 so we can conclude that K1 is unsatisfiable without any backtracking. This example suggests that the processing of GCIs in tableau algorithms can be \u201cunnecessarily\u201d nondeterministic. Hustadt et al. (2005) have identified a class of knowledge bases without \u201cunnecessary\u201d nondeterminism: knowledge bases expressed in the description logic Horn-SHIQ can always be translated into Horn clauses, suggesting that reasoning without any nondeterminism is possible in principle.", "startOffset": 214, "endOffset": 1916}, {"referenceID": 28, "context": "In the context of tableau calculi, various absorption optimizations (Horrocks, 2007) have been developed to control the nondeterminism arising in the application of GCIs.", "startOffset": 68, "endOffset": 84}, {"referenceID": 15, "context": "The introduction of new individuals in the \u2203-rule is often called and-branching, and it is another major source of inefficiency in tableau algorithms (Donini, 2007).", "startOffset": 150, "endOffset": 164}, {"referenceID": 44, "context": "The hyperresolution calculus (Robinson, 1965) has often been used for first-order theorem proving.", "startOffset": 29, "endOffset": 45}, {"referenceID": 7, "context": "The hypertableau calculus (Baumgartner et al., 1996) is based on the observation that, if the literals in C1\u03c3 \u2228 .", "startOffset": 26, "endOffset": 52}, {"referenceID": 10, "context": "(1996) can be easily applied to DLs: GCIs can be translated into first-order formulae (Borgida, 1996), which can then be converted into clauses, as shown in the following example.", "startOffset": 86, "endOffset": 101}, {"referenceID": 7, "context": "The hypertableau calculus by Baumgartner et al. (1996) can be easily applied to DLs: GCIs can be translated into first-order formulae (Borgida, 1996), which can then be converted into clauses, as shown in the following example.", "startOffset": 29, "endOffset": 55}, {"referenceID": 4, "context": "To the best of our knowledge, this problem was first identified by Baader and Sattler (2001), and it is commonly known as a \u201cyo-yo.", "startOffset": 67, "endOffset": 93}, {"referenceID": 27, "context": "Horrocks et al. (2000b) do not physically remove successors, but mark them as \u201cnot present\u201d by setting the relevant edge labels to \u2205.", "startOffset": 0, "endOffset": 24}, {"referenceID": 28, "context": "1 (Horrocks, 2007).", "startOffset": 2, "endOffset": 18}, {"referenceID": 28, "context": "Negative absorption rewrites GCIs into the form \u00acA v C where A is an atomic concept; then, C(s) is derived only if an ABox contains \u00acA(s) (Horrocks, 2007).", "startOffset": 138, "endOffset": 154}, {"referenceID": 33, "context": "Binary absorption is not directly applicable to (2) since the axiom does not contain two concepts on the left-hand side of v, but the algorithm by Hudek and Weddell (2006) additionally transforms (2) into an absorbable axiom A v \u2200R\u2212.", "startOffset": 147, "endOffset": 172}, {"referenceID": 34, "context": ", Wu & Haarslev, 2008), but there are no guarantees that the result will incur the \u201cleast\u201d amount of nondeterminism; this is so even on Horn knowledge bases, for which reasoning without any nondeterminism is possible in principle (Hustadt et al., 2005).", "startOffset": 230, "endOffset": 252}, {"referenceID": 28, "context": "Various caching optimizations can be used to reduce the sizes of the models constructed during knowledge base classification (Ding & Haarslev, 2006; Horrocks, 2007).", "startOffset": 125, "endOffset": 164}, {"referenceID": 15, "context": "Donini and Massacci (2000) have used anywhere blocking with caching of unsatisfiable concepts to obtain a tableau algorithm for the DL ALC that runs in single exponential time.", "startOffset": 0, "endOffset": 27}, {"referenceID": 15, "context": "Donini and Massacci (2000) have used anywhere blocking with caching of unsatisfiable concepts to obtain a tableau algorithm for the DL ALC that runs in single exponential time. Gor\u00e9 and Nguyen (2007) have presented an algorithm for the DL SHI that also runs in exponential time and achieves termination solely by caching both satisfiable and unsatisfiable concepts.", "startOffset": 0, "endOffset": 200}, {"referenceID": 21, "context": "Hyperresolution with splitting has been used to decide several description and modal logics (Georgieva et al., 2003; Hustadt & Schmidt, 1999).", "startOffset": 92, "endOffset": 141}, {"referenceID": 11, "context": "Our hypertableau calculus is related to the Extended Positive (EP) tableau calculus for first-order logic by Bry and Torge (1998). Instead of relying on skolemization, EP satisfies existential quantifiers by introducing new constants, and this is done in a way that makes the calculus complete for finite satisfiability.", "startOffset": 109, "endOffset": 130}, {"referenceID": 9, "context": "Baumgartner and Schmidt (2006) developed a so-called blocking transformation of firstorder clauses, which can improve the performance of bottom-up model generation methods.", "startOffset": 0, "endOffset": 31}, {"referenceID": 48, "context": "Similar encodings are known for various description (Tobies, 2001) and modal (Schmidt & Hustadt, 2003) logics.", "startOffset": 52, "endOffset": 66}, {"referenceID": 36, "context": "The full proof of an analogous result for the DL SHIQ is given by Motik (2006) in Theorem 5.", "startOffset": 66, "endOffset": 79}, {"referenceID": 34, "context": "On a Horn knowledge base K (Hustadt et al., 2005), normalization performs the same replacements as the one presented by Hustadt et al.", "startOffset": 27, "endOffset": 49}, {"referenceID": 41, "context": "(Sketch) Since our transformation can be seen a syntactic variant of the structural transformation, the proof that K and \u2206(K) are equisatisfiable is completely analogous to the ones by Plaisted and Greenbaum (1986) and Nonnengart and Weidenbach (2001), so we omit it for the sake of brevity.", "startOffset": 185, "endOffset": 215}, {"referenceID": 39, "context": "(Sketch) Since our transformation can be seen a syntactic variant of the structural transformation, the proof that K and \u2206(K) are equisatisfiable is completely analogous to the ones by Plaisted and Greenbaum (1986) and Nonnengart and Weidenbach (2001), so we omit it for the sake of brevity.", "startOffset": 219, "endOffset": 252}, {"referenceID": 48, "context": "For example, HT-clauses of the form R(x, y) \u2227A(y)\u2192 S(x, y) express a form of relativized role inclusions, and HT-clauses of the form R(x, y) \u2227 S(y, x)\u2192 U(x, y) \u2228 T (y, x) capture safe role expressions (Tobies, 2001).", "startOffset": 201, "endOffset": 215}, {"referenceID": 10, "context": "The following equivalences between DL concepts and first-order formulae are well known (Borgida, 1996):", "startOffset": 87, "endOffset": 102}, {"referenceID": 47, "context": "Furthermore, for any atomic role R, using the well-known R-successor counting formula (Tobies, 2000), we can ensure that, whenever an individual t is an R-successor of s in A, then `A(t) = (`A(s) + 1) mod 2k; we omit this formula for the sake of brevity.", "startOffset": 86, "endOffset": 100}, {"referenceID": 12, "context": "Buchheit et al. and Donini et al. obtained the nondeterministic exponential behavior by applying the u-, t-, \u2200-, and v-rules exhaustively before applying the \u2203-rule. Such a strategy ensures that the label of an individual s is fully constructed before introducing a successor of s, which prevents individuals from being indirectly blocked. On K11, this means that the GCI (44) is applied to each individual s before introducing its successors. Thus, before the existentials on s are expanded, the assertion (\u2200L.\u00acA t \u2200R.\u00acA tA)(s) is introduced and one disjunct is chosen nondeterministically. The choices (\u2200L.\u00acA)(s) and (\u2200R.\u00acA)(s) will lead to a clash, so the algorithm eventually derives A(s), before it expands the existentials on s and introduces s.1 and s.2. Thus, while generating at most exponential models, this algorithm incurs a massive amount of nondeterminism. Nondeterministic exponential behavior can be guaranteed in the hypertableau algorithm by nondeterministically fixing the label of each individual before applying the \u2264-rule to it. This technique is similar to the one used by Tobies (2001) in order to obtain a PSpace", "startOffset": 0, "endOffset": 1110}, {"referenceID": 47, "context": "SHOIQ is NExpTime-complete (Tobies, 2000), and it is straightforward to extend this result to SHOIQ.", "startOffset": 27, "endOffset": 41}, {"referenceID": 28, "context": "The well-known dependency-directed backtracking optimization (Horrocks, 2007) can readily be used with the hypertableau calculus.", "startOffset": 61, "endOffset": 77}, {"referenceID": 28, "context": "This optimization can be seen as a very simple form of model caching (Horrocks, 2007), and it has been key to obtaining the results that we present in Section 7.", "startOffset": 69, "endOffset": 85}, {"referenceID": 28, "context": "In addition to the hypertableau calculus described in Section 4, HermiT also implements the optimizations from Section 6 and the well-known dependency directed backtracking optimization (Horrocks, 2007).", "startOffset": 186, "endOffset": 202}, {"referenceID": 26, "context": "These include several ontologies from the OBO corpus (Molecule Role, XP Uber Anatomy, XP Plant Anatomy, Cellular Component, Gazetteer, CHEBI), two versions of the National Cancer Institute (NCI) Thesaurus (Hartel et al., 2005), two versions of the GALEN medical terminology ontology, two versions of the Foundational Model of Anatomy (FMA) (Golbreich et al.", "startOffset": 205, "endOffset": 226}, {"referenceID": 22, "context": ", 2005), two versions of the GALEN medical terminology ontology, two versions of the Foundational Model of Anatomy (FMA) (Golbreich et al., 2006), the Wine ontology from the OWL Guide,21 two SWEET ontologies developed at NASA,22 and a version of the DOLCE ontology developed at the Institute of Cognitive Science and Technology of the Italian National Research Council.", "startOffset": 121, "endOffset": 145}, {"referenceID": 0, "context": "Both NCI-2 and FMA-Constitutional use disjunctions, so they cannot be classified using a linear number of concept satisfiability tests; instead, HermiT uses the classification algorithm by Baader et al. (1994). All classification tests are straightforward (each test takes less than 50 ms); however, the resulting taxonomy is rather shallow, so HermiT makes an almost quadratic number of tests.", "startOffset": 189, "endOffset": 210}, {"referenceID": 38, "context": "This is an extended version of a paper published at CADE 2007 (Motik et al., 2007).", "startOffset": 62, "endOffset": 82}], "year": 2009, "abstractText": "We present a novel reasoning calculus for the description logic SHOIQ\u2014a knowledge representation formalism with applications in areas such as the Semantic Web. Unnecessary nondeterminism and the construction of large models are two primary sources of inefficiency in the tableau-based reasoning calculi used in state-of-the-art reasoners. In order to reduce nondeterminism, we base our calculus on hypertableau and hyperresolution calculi, which we extend with a blocking condition to ensure termination. In order to reduce the size of the constructed models, we introduce anywhere pairwise blocking. We also present an improved nominal introduction rule that ensures termination in the presence of nominals, inverse roles, and number restrictions\u2014a combination of DL constructs that has proven notoriously difficult to handle. Our implementation shows significant performance improvements over state-of-the-art reasoners on several well-known ontologies.", "creator": "TeX"}}}