{"id": "1401.3487", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "The DL-Lite Family and Relations", "abstract": "The recently introduced series of description logics under the common moniker DL-Lite has attracted attention of the description logic and semantic web communities due to the low computational complexity of inference, on the one hand, and the ability to represent conceptual modeling formalisms, on the other. The main aim of this article is to carry out a thorough and systematic investigation of inference in extensions of the original DL-Lite logics along five axes: by (i) adding the Boolean connectives and (ii) number restrictions to concept constructs, (iii) allowing role hierarchies, (iv) allowing role disjointness, symmetry, asymmetry, reflexivity, irreflexivity and transitivity constraints, and (v) adopting or dropping the unique same assumption. We analyze the combined complexity of satisfiability for the resulting logics, as well as the data complexity of instance checking and answering positive existential queries in the previous two series. We then demonstrate the power of the Lite logics for inference using the terms 'delimiter' and 'error_reliability' to generate the logics in relation to the problem. In each case, the logics are applied to the problem: the logical case has the largest problem and the second largest problem (the solution is also the logical case). In each case, we use the second most-complex of the Lites logics, with the shortest solution being the problem with the most-complex of the problem. The total complexity of the problem, the type of problem, the type of problem, the type of problem, and the types of solution are then examined in an equivalent type. We describe the logics of the logical case as follows. In each case, we have the least-complex of the problem, with the least-complex of the problem. In each case, we then use the otherest of the problem, including the most-complex of the problem. In each case, we have the least-complex of the problem, including the most-complex of the problem. In each case, we use the otherest of the problem. In each case, we have the most-complex of the problem. In each case, we use the otherest of the problem. In each case, we use the otherest of the problem. In each case, we use the otherest of the problem. In each case, we use the otherest of the problem. In each case, we use the otherest of the problem. In each case, we use the otherest of", "histories": [["v1", "Wed, 15 Jan 2014 05:37:57 GMT  (893kb)", "http://arxiv.org/abs/1401.3487v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["alessandro artale", "diego calvanese", "roman kontchakov", "michael zakharyaschev"], "accepted": false, "id": "1401.3487"}, "pdf": {"name": "1401.3487.pdf", "metadata": {"source": "CRF", "title": "The DL-Lite Family and Relations", "authors": ["Alessandro Artale", "Diego Calvanese", "Roman Kontchakov", "Michael Zakharyaschev"], "emails": ["artale@inf.unibz.it", "calvanese@inf.unibz.it", "roman@dcs.bbk.ac.uk", "michael@dcs.bbk.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "Description Logic (cf. Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003 and references therein) is a family of knowledge representation formalisms developed over the past three decades and, in recent years, widely used in various application areas such as:\n\u2022 conceptual modeling (Bergamaschi & Sartori, 1992; Calvanese et al., 1998b, 1999; McGuinness & Wright, 1998; Franconi & Ng, 2000; Borgida & Brachman, 2003; Berardi, Calvanese, & De Giacomo, 2005; Artale et al., 1996, 2007, 2007b),\n\u2022 information and data integration (Beeri, Levy, & Rousset, 1997; Levy & Rousset, 1998; Goasdoue, Lattes, & Rousset, 2000; Calvanese et al., 1998a, 2002a, 2002b, 2008; Noy, 2004; Meyer, Lee, & Booth, 2005),\n\u2022 ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al., 2008),\n\u2022 the Semantic Web (Heflin & Hendler, 2001; Horrocks, Patel-Schneider, & van Harmelen, 2003).\nc\u00a92009 AI Access Foundation. All rights reserved.\nDescription logics (DLs, for short) underlie the standard Web Ontology Language OWL,1 which is now in the process of being standardized by the W3C in its second edition, OWL 2. The widespread use of DLs as flexible modeling languages stems from the fact that, similarly to more traditional modeling formalisms, they structure the domain of interest into classes (or concepts, in the DL parlance) of objects with common properties. Properties are associated with objects by means of binary relationships (or roles) to other objects. Constraints available in standard DLs also resemble those used in conceptual modeling formalisms for structuring information: is-a hierarchies (i.e., inclusions) and disjointness for concepts and roles, domain and range constraints for roles, mandatory participation in roles, functionality and more general numeric restrictions for roles, covering within concept hierarchies, etc. In a DL knowledge base (KB), these constraints are combined to form a TBox asserting intensional knowledge, while an ABox collects extensional knowledge about individual objects, such as whether an object is an instance of a concept, or two objects are connected by a role. The standard reasoning services over a DL KB include checking its consistency (or satisfiability), instance checking (whether a certain individual is an instance of a concept), and logic entailment (whether a certain constraint is logically implied by the KB). More sophisticated services are emerging that can support modular development of ontologies by checking, for example, whether one ontology is a conservative extension of another with respect to a certain vocabulary (see, e.g., Ghilardi, Lutz, & Wolter, 2006; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Kontchakov, Wolter, & Zakharyaschev, 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009).\nDescription logics have recently been used to provide access to large amounts of data through a high-level conceptual interface, which is of relevance to both data integration and ontology-based data access. In this setting, the TBox constitutes the conceptual, high-level view of the information managed by the system, and the ABox is physically stored in a relational database and accessed using the standard relational database technology (Poggi et al., 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind of queries that have most often been considered are first-order conjunctive queries, which correspond to the commonly used Select-Project-Join SQL queries. The key properties for such an approach to be viable in practice are (i) efficiency of query evaluation, with the ideal target being traditional database query processing, and (ii) that query evaluation can be done by leveraging the relational technology already used for storing the data.\nWith these objectives in mind, a series of description logics\u2014the DL-Lite family\u2014has recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov, and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati (2008a). Most logics of the family meet the requirements above and, at the same time, are capable of representing many important types of constraints used in conceptual modeling. In particular, inference in various DL-Lite logics can be done efficiently both in the size of the data (data complexity) and in the overall size of the KB (combined complexity): it was shown that KB satisfiability in these logics is polynomial for combined complexity, while answering queries is in AC0 for data complexity\u2014which, roughly, means that, given a\n1. http://www.w3.org/2007/OWL/\nconjunctive query over a KB, the query and the TBox can be rewritten (independently of the ABox) into a union of conjunctive queries over the ABox alone. (It is to be emphasized that the data complexity measure is very important in the application context of the DL-Lite logics, since one can reasonably assume that the size of the data largely dominates the size of the TBox.) Query rewriting techniques have been implemented in various systems such as QuOnto2 (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005; Poggi, Rodriguez, & Ruzzi, 2008b), ROWLKit (Corona, Ruzzi, & Savo, 2009), Owlgres (Stocker & Smith, 2008) and REQUIEM (Pe\u0301rez-Urbina, Motik, & Horrocks, 2009). It has also been demonstrated (Kontchakov et al., 2008) that developing, analyzing and re-using DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various types of entailment between such ontologies with respect to given vocabularies, in particular, by minimal module extraction tools (Kontchakov et al., 2009)\u2014which do not yet exist for richer languages.\nThe significance of the DL-Lite family is testified by the fact that it forms the basis of OWL 2 QL, one of the three profiles of OWL 2.3 The OWL 2 profiles are fragments of the full OWL 2 language that have been designed and standardized for specific application requirements. According to (the current version of) the official W3C profiles document, the purpose of OWL 2 QL is to be the language of choice for applications that use very large amounts of data and where query answering is the most important reasoning task.\nThe common denominator of the DL-Lite logics constructed so far is as follows: (i) quantification over roles and their inverses is not qualified (in other words, in concepts of the form \u2203R.C we must have C = >) and (ii) the TBox axioms are concept inclusions that cannot represent any kind of disjunctive information (say, that two concepts cover the whole domain). The other DL-Lite-related dialects were designed\u2014with the aim of capturing more conceptual modeling constraints, but in a somewhat ad hoc manner\u2014by extending this \u2018core\u2019 language with a number of constructs such as global functionality constraints, role inclusions and restricted Boolean operators on concepts (see Section 4 for details). Although some attempts have been made (Calvanese et al., 2006; Artale et al., 2007a; Kontchakov & Zakharyaschev, 2008) to put the original DL-Lite logics into a more general perspective and investigate their extensions with a variety of DL constructs required for conceptual modeling, the resulting picture still remains rather fragmentary and far from comprehensive. A systematic investigation of the DL-Lite family and relatives has become even more urgent and challenging in view of the choice of the constructs to be included in the specification of the OWL 2 QL profile4 (in particular, because OWL does not make the unique name assumption, UNA, which was usually adopted in DL-Lite, and uses equalities and inequalities between object names instead).\nThe main aim of this article is to fill in this gap and provide a thorough and comprehensive understanding of the interaction between various DL-Lite constructs and their impact on the computational complexity of reasoning. To achieve this goal, we consider a spectrum of logics, classified according to five mutually orthogonal features:\n(1) the presence or absence of role inclusions;\n2. http://www.dis.uniroma1.it/quonto/ 3. http://www.w3.org/TR/owl2-profiles/ 4. http://www.w3.org/TR/owl2-profiles/#OWL_2_QL\n(2) the form of the allowed concept inclusions, where we consider four classes, called core, Krom, Horn, and Bool, that exhibit different computational properties;\n(3) the form of the allowed numeric constraints, ranging from none, to global functionality constraints only, and to arbitrary number restrictions;\n(4) the presence or absence of the unique name assumption (and the equalities and inequalities between object names, if this assumption is dropped); and\n(5) the presence or absence of standard role constraints such as disjointness, symmetry, asymmetry, reflexivity, irreflexivity, and transitivity.\nFor all the resulting cases, we investigate the combined and data complexity of KB satisfiability and instance checking, as well as the data complexity of query answering. The obtained tight complexity results are summarized in Section 3.4 (Table 2 and Remark 3.1).\nAs already mentioned, the original motivation and distinguishing feature for the logics in the DL-Lite family was their \u2018lite\u2019-ness in the sense of low computational complexity of the reasoning tasks (query answering in AC0 for data complexity and tractable KB satisfiability for combined complexity). In the broader perspective we take here, not all of our logics meet this requirement, in particular, those with Krom or Bool concept inclusions.5 However, we identify another distinguishing feature that can be regarded as the natural logic-based characterization of the DL-Lite family: embeddability into the one-variable fragment of firstorder logic without equality and function symbols. This allows us to relate the complexity of DL-Lite logics to the complexity of the corresponding fragments of first-order logic, and thus to obtain a deep insight into the underlying logical properties of each DL-Lite variant. For example, most upper complexity bounds established below follow from this embedding and well-known results on the classical decision problem (see, e.g., Bo\u0308rger, Gra\u0308del, & Gurevich, 1997) and descriptive complexity (see, e.g., Immerman, 1999).\nOne of the most interesting findings in this article is that number restrictions, even expressed locally, instead of global role functionality, can be added to the original DL-Lite logics (under the UNA and without role inclusions) \u2018for free,\u2019 that is, without changing their computational complexity. The first-order approach shows that in most cases we can also extend the DL-Lite logics with the role constraints mentioned above, again keeping the same complexity. It also gives a framework to analyze the effect of adopting or dropping the UNA and using (in)equalities between object names. For example, we observe that if equality is allowed in the language of DL-Lite (which only makes sense without the UNA) then query answering becomes LogSpace-complete for data complexity, and therefore not first-order rewritable. It also turns out that dropping the UNA results in P-hardness of reasoning (for both combined and data complexity) in the presence of functionality constraints (NLogSpace-hardness was shown by Calvanese et al., 2008), and in NP-hardness if arbitrary number restrictions are allowed.\nAnother interesting finding is the dramatic impact of role inclusions, when combined with number restrictions (or even functionality constraints), on the computational complexity of reasoning. As was already observed by Calvanese et al. (2006), such a combination increases data complexity of instance checking from membership in LogSpace to\n5. Note, by the way, that logics with Bool concept inclusions turn out to be quite useful in conceptual modeling and reasonably manageable computationally (Kontchakov et al., 2008).\nNLogSpace-hardness. We show here that the situation is actually even worse: for data complexity, instance checking turns out to be P-complete in the case of core and Horn logics and coNP-complete in the case of Krom and Bool logics; moreover, KB satisfiability, which is NLogSpace-complete for combined complexity in the simplest \u2018core\u2019 case\u2014i.e., efficiently tractable, when role inclusions or number restrictions are used separately\u2014becomes ExpTime-complete\u2014i.e., provably intractable, when they are used together.\nTo retain both role inclusions and functionality constraints in the language and keep complexity within the required limits, Poggi et al. (2008a) introduced another DL-Lite dialect, called DL-LiteA, which restricts the interaction between role inclusions and functionality constraints. Here we extend this result by showing that the DL-Lite logics with such a limited interaction between role inclusions and number restrictions can still be embedded into the one-variable fragment of first-order logic, and so exhibit the same behavior as their fragments with only role inclusions or only number restrictions.\nThe article is structured in the following way. In Section 2, we introduce the logics of the extended DL-Lite family and illustrate their features as conceptual modeling formalisms. In Section 3, we discuss the reasoning services and the complexity measures to be analyzed in what follows, and give an overview of the obtained complexity results. In Section 4, we place the introduced DL-Lite logics in the context of the original DL-Lite family, and discuss its relationship with OWL 2. In Section 5, we study the combined complexity of KB satisfiability and instance checking, while in Section 6, we consider the data complexity of these problems. In Section 7, we study the data complexity of query answering. In Section 8, we analyze the impact of dropping the UNA and adding (in)equalities between object names on the complexity of reasoning. Section 9 concludes the article.\n2. The Extended DL-Lite Family of Description Logics\nDescription Logic (Baader et al., 2003) is a family of logics that have been studied and used in knowledge representation and reasoning since the 1980s. In DLs, the elements of the domain of interest are structured into concepts (unary predicates), and their properties are specified by means of roles (binary predicates). Complex concept and role expressions (or simply concepts and roles) are constructed, starting from a set of concept and role names, by applying suitable constructs, where the set of available constructs depends on the specific description logic. Concepts and roles can then be used in a knowledge base to assert knowledge, both at the intensional level, in a so-called TBox (\u2018T\u2019 for terminological), and at the extensional level, in a so-called ABox (\u2018A\u2019 for assertional). A TBox typically consists of a set of axioms stating the inclusion between concepts and roles. In an ABox, one can assert membership of objects (i.e., constants) in concepts, or that a pair of objects is connected by a role. DLs are supported by reasoning services, such as satisfiability checking and query answering, that rely on their logic-based semantics.\n2.1 Syntax and Semantics of the Logics in the DL-Lite Family\nWe introduce now the (extended) DL-Lite family of description logics, which was initially proposed with the aim of capturing typical conceptual modeling formalisms, such as UML class diagrams and ER models (see Section 2.2 for details), while maintaining good computational properties of standard DL reasoning tasks (Calvanese et al., 2005). We begin\nby defining the logic DL-LiteHNbool , which can be regarded as the supremum of the original DL-Lite family (Calvanese et al., 2005, 2006, 2007b) in the lattice of description logics.\nDL-LiteHNbool. The language of DL-Lite HN bool contains object names a0, a1, . . . , concept names A0, A1, . . . , and role names P0, P1, . . . . Complex roles R and concepts C of this language are defined as follows:\nR ::= Pk | P\u2212k , B ::= \u22a5 | Ak | \u2265 q R, C ::= B | \u00acC | C1 u C2,\nwhere q is a positive integer. The concepts of the form B will be called basic. A DL-LiteHNbool TBox, T , is a finite set of concept and role inclusion axioms (or simply concept and role inclusions) of the form:\nC1 v C2 and R1 v R2,\nand an ABox, A, is a finite set of assertions of the form:\nAk(ai), \u00acAk(ai), Pk(ai, aj) and \u00acPk(ai, aj).\nTaken together, T and A constitute the DL-LiteHNbool knowledge base K = (T ,A). In the following, we denote by role(K) the set of role names occurring in T and A, by role\u00b1(K) the set {Pk, P\u2212k | Pk \u2208 role(K)}, and by ob(A) the set of object names in A. For a role R, we set:\ninv(R) =\n{ P\u2212k , if R = Pk,\nPk, if R = P \u2212 k .\nAs usual in description logic, an interpretation, I = (\u2206I , \u00b7I), consists of a nonempty domain \u2206I and an interpretation function \u00b7I that assigns to each object name ai an element aIi \u2208 \u2206I , to each concept name Ak a subset AIk \u2286 \u2206I of the domain, and to each role name Pk a binary relation P I k \u2286 \u2206I \u00d7 \u2206I over the domain. Unless otherwise stated, we adopt here the unique name assumption (UNA):\naIi 6= aIj for all i 6= j. (UNA)\nHowever, we shall always indicate which of our results depend on the UNA and which do not, and when they do depend on this assumption, we discuss also the consequences of dropping it (see also Sections 4 and 8).\nThe role and concept constructs are interpreted in I in the standard way:\n(P\u2212k ) I = {(y, x) \u2208 \u2206I \u00d7\u2206I | (x, y) \u2208 P Ik }, (inverse role) \u22a5I = \u2205, (the empty set)\n(\u2265q R)I = { x \u2208 \u2206I | ]{y \u2208 \u2206I | (x, y) \u2208 RI} \u2265 q } , (at least q R-successors)\n(\u00acC)I = \u2206I \\ CI , (not in C) (C1 u C2)I = CI1 \u2229 CI2 , (both in C1 and in C2)\nwhere ]X denotes the cardinality of X. We will use standard abbreviations such as\nC1 t C2 = \u00ac(\u00acC1 u \u00acC2), > = \u00ac\u22a5, \u2203R = (\u2265 1R), \u2264 q R = \u00ac(\u2265 q + 1R).\nConcepts of the form \u2264 q R and \u2265 q R are called number restrictions, and those of the form \u2203R are called existential concepts.\nThe satisfaction relation |= is also standard:\nI |= C1 v C2 iff CI1 \u2286 CI2 , I |= R1 v R2 iff RI1 \u2286 RI2 , I |= Ak(ai) iff aIi \u2208 AIk , I |= Pk(ai, aj) iff (aIi , aIj ) \u2208 P Ik , I |= \u00acAk(ai) iff aIi /\u2208 AIk , I |= \u00acPk(ai, aj) iff (aIi , aIj ) /\u2208 P Ik .\nA knowledge base K = (T ,A) is said to be satisfiable (or consistent) if there is an interpretation, I, satisfying all the members of T and A. In this case we write I |= K (as well as I |= T and I |= A) and say that I is a model of K (and of T and A).\nThe languages of the DL-Lite family we investigate in this article are obtained by restricting the language of DL-LiteHNbool along three axes: (i) the Boolean operators (bool ) on concepts, (ii) the number restrictions (N ) and (iii) the role inclusions, or hierarchies (H).\nSimilarly to classical logic, we adopt the following definitions. A DL-LiteHNbool TBox T will be called a Krom TBox 6 if its concept inclusions are restricted to:\nB1 v B2, B1 v \u00acB2 or \u00acB1 v B2 (Krom)\n(here and below all the Bi and B are basic concepts). T will be called a Horn TBox if its concept inclusions are restricted to:\nl\nk\nBk v B (Horn)\n(by definition, the empty conjunction is >). Finally, we will call T a core TBox if its concept inclusions are restricted to:\nB1 v B2 or B1 v \u00acB2. (core)\nAs B1 v \u00acB2 is equivalent to B1 u B2 v \u22a5, core TBoxes can be regarded as sitting in the intersection of Krom and Horn TBoxes.\nRemark 2.1 We will sometimes use conjunctions on the right-hand side of concept inclusions in these restricted languages: C v d k Bk. Clearly, this \u2018syntactic sugar\u2019 does not add any extra expressive power.\nDL-LiteHNkrom, DL-Lite HN horn and DL-Lite HN core. The fragments of DL-Lite HN bool with Krom, Horn, and core TBoxes will be denoted by DL-LiteHNkrom, DL-Lite HN horn and DL-Lite HN core, respectively. Other fragments are obtained by limiting the use of number restrictions and role inclusions.\n6. The Krom fragment of first-order logic consists of all formulas in prenex normal form whose quantifier-free part is a conjunction of binary clauses.\nDL-LiteH\u03b1 . The fragment of DL-Lite HN \u03b1 , \u03b1 \u2208 {core, krom, horn, bool}, without number restrictions \u2265q R, for q \u2265 2, (but with role inclusions) will be denoted by DL-LiteH\u03b1 . Note that, in DL-LiteH\u03b1 , we can still use existential concepts \u2203R (that is, \u22651R). DL-LiteHF\u03b1 . Denote by DL-Lite HF \u03b1 the fragment of DL-Lite HN \u03b1 in which of all number restrictions \u2265q R, we have existential concepts (with q = 1) and only those with q = 2 that occur in concept inclusions of the form \u22652R v \u22a5. Such an inclusion is called a global functionality constraint because it states that role R is functional (more precisely, if I |= (\u22652R v \u22a5) and both (x, y) \u2208 RI and (x, z) \u2208 RI , then y = z).\nDL-LiteN\u03b1 , DL-Lite F \u03b1 and DL-Lite\u03b1. If role inclusions are excluded from the language, then for each \u03b1 \u2208 {core, krom, horn, bool} we obtain three fragments: DL-LiteN\u03b1 (with arbitrary number restrictions), DL-LiteF\u03b1 (with functionality constraints and existential concepts \u2203R), and DL-Lite\u03b1 (without number restrictions different from \u2203R).\nAs we shall see later on in this article, the logics of the form DL-LiteHF\u03b1 and DL-Lite HN \u03b1 , even for \u03b1 = core, turn out to be computationally rather costly because of the interaction between role inclusions and functionality constraints (or, more generally, number restrictions). On the other hand, for the purpose of conceptual modeling one may need both of these constructs; cf. the example in Section 2.2. A compromise can be found by artificially limiting the interplay between role inclusions and number restrictions in a way similar to the logic DL-LiteA proposed by Poggi et al. (2008a).\nFor a TBox T , let v\u2217T denote the reflexive and transitive closure of the relation{ (R,R\u2032), (inv(R), inv(R\u2032)) | R v R\u2032 \u2208 T } and let R \u2261\u2217T R\u2032 iff R v\u2217T R\u2032 and R\u2032 v\u2217T R. Say that R\u2032 is a proper sub-role of R in T if R\u2032 v\u2217T R and R\u2032 6\u2261\u2217T R. DL-Lite (HN ) \u03b1 . We now introduce the logics DL-Lite (HN ) \u03b1 , \u03b1 \u2208 {core, krom, horn, bool}, which, on the one hand, restrict the logics DL-LiteHN\u03b1 by limiting the interaction between role inclusions and number restrictions in order to reduce complexity of reasoning, and, on the other hand, include additional constructs, such as limited qualified existential quantifiers, role disjointness, (a)symmetry and (ir)reflexivity constraints, which increase the expressive power of the logics but do not affect their computational properties.\nDL-Lite (HN ) \u03b1 TBoxes T must satisfy the conditions (A1)\u2013(A3) below. (We remind the reader that an occurrence of a concept on the right-hand (left-hand) side of a concept inclusion is called negative if it is in the scope of an odd (even) number of negations \u00ac; otherwise the occurrence is called positive.)\n(A1) T may contain only positive occurrences of qualified number restrictions \u2265 q R.C, where C is a conjunction of concepts allowed on the right-hand side of \u03b1-concept inclusions;\n(A2) if \u2265 q R.C occurs in T , then T does not contain negative occurrences of number restrictions \u2265 q\u2032R or \u2265 q\u2032 inv(R) with q\u2032 \u2265 2;\n(A3) if R has a proper sub-role in T , then T does not contain negative occurrences of \u2265 q R or \u2265 q inv(R) with q \u2265 2.\n(It follows that no DL-Lite (HN ) \u03b1 TBox can contain both, say, a functionality constraint \u22652R v \u22a5 and an occurrence of \u2265q R.C, for any q \u2265 1.) Additionally, DL-Lite (HN ) \u03b1 TBoxes can contain role constraints (or axioms) of the form:\nDis(R1, R2), Asym(Pk), Sym(Pk), Irr(Pk), and Ref(Pk).\nThe meaning of these new constructs is defined as usual: for an interpretation I = (\u2206I , \u00b7I),\n\u2022 (\u2265q R.C)I = { x \u2208 \u2206I | ]{y \u2208 CI | (x, y) \u2208 RI} \u2265 q } ;\n\u2022 I |= Dis(R1, R2) iff RI1 \u2229RI2 = \u2205 (roles R1 and R2 are disjoint);\n\u2022 I |= Asym(Pk) iff P Ik \u2229 (P \u2212 k ) I = \u2205 (role Pk is asymmetric);\n\u2022 I |= Sym(Pk) iff P Ik = (P \u2212 k ) I (Pk is symmetric);\n\u2022 I |= Irr(Pk) iff (x, x) /\u2208 P Ik for all x \u2208 \u2206I (Pk is irreflexive);\n\u2022 I |= Ref(Pk) iff (x, x) \u2208 P Ik for all x \u2208 \u2206I (Pk is reflexive).\nIt is to be emphasized that these extra constructs are often used in conceptual modeling and their introduction in DL-Lite (HN ) \u03b1 is motivated by the OWL 2 QL proposal. (Note that DL-Lite (HN ) \u03b1 contains both DL-Lite H \u03b1 and DL-Lite N \u03b1 as its proper fragments.)\nDL-Lite (HN )+ \u03b1 . For \u03b1 \u2208 {bool, horn, krom, core}, denote by DL-Lite(HN ) + \u03b1 the extension of DL-Lite (HN ) \u03b1 with role transitivity constraints of the form Tra(Pk), the meaning of which is as expected:\n\u2022 I |= Tra(Pk) iff (x, y) \u2208 P Ik and (y, z) \u2208 P Ik imply (x, z) \u2208 P Ik , for all x, y, z \u2208 \u2206I (Pk is transitive).\nWe remind the reader of the standard restriction limiting the use of transitive roles in DLs (see, e.g., Horrocks, Sattler, & Tobies, 2000):\n\u2022 only simple roles R are allowed in concepts of the form \u2265 q R, for q \u2265 2,\nwhere by a simple role in a given TBox T we understand a role without transitive sub-roles (including itself). In particular, if T contains Tra(P ) then P and P\u2212 are not simple, and so T cannot contain occurrences of concepts of the form \u2265 q P and \u2265 q P\u2212, for q \u2265 2.\nDL-Lite (HF) \u03b1 and DL-Lite (HF)+ \u03b1 . We also define languages DL-Lite (HF) \u03b1 as sub-languages of DL-Lite (HN ) \u03b1 , in which only number restrictions of the form \u2203R, \u2203R.C and functionality constraints \u22652R v \u22a5 are allowed\u2014provided, of course, that they satisfy (A1)\u2013(A3); in particular, \u2203R.C is not allowed ifR is functional. As before, DL-Lite(HF) +\n\u03b1 are the extensions\nof DL-Lite (HF) \u03b1 with role transitivity constraints (satisfying the restriction above).\nThus, the extended DL-Lite family we consider in this article consists of 40 different logics collected in Table 1. The inclusions between these logics are shown in Figure 1. They are obtained by taking the product of the left- and right-hand parts of the picture, where the subscript \u03b1 on the right-hand part ranges over {core, krom, horn, bool}, i.e., the subscripts on the left-hand part, and similarly, the superscript \u03b2 on the left-hand part ranges over { ,F ,N ,H,HF ,HN , (HF), (HN ), (HF)+, (HN )+}, i.e., the superscripts on the right-hand part.\nThe position of these logics relative to other DL-Lite logics known in the literature and the OWL 2 QL profile will be discussed in Section 4. And starting from Section 5, we begin a thorough investigation of the computational properties of the logics in the extended DLLite family, both with and without the UNA. But before that we illustrate the expressive power of the DL-Lite logics by a concrete example.\n2.2 DL-Lite for Conceptual Modeling\nA tight correspondence between conceptual modeling formalisms, such as the ER model and UML class diagrams, and various description logics has been pointed out in various papers (e.g., Calvanese et al., 1998b, 1999; Borgida & Brachman, 2003; Berardi et al., 2005). Here we give an example showing how DL-Lite logics can be used for conceptual modeling purposes; for more details see the work by Artale et al. (2007b).\nLet us consider the UML class diagram depicted in Figure 2 and representing (a portion of) a company information system. According to the diagram, all managers are employees and are partitioned into area managers and top managers. This information can be represented by means of the following concept inclusions (where in brackets we specify the minimal DL-Lite language the inclusion belongs to):\nManager v Employee (DL-Litecore) AreaManager v Manager (DL-Litecore) TopManager v Manager (DL-Litecore) AreaManager v \u00acTopManager (DL-Litecore) Manager v AreaManager t TopManager (DL-Litebool)\nEach employee has two functional attributes, empCode and salary, with integer values. Unlike OWL, here we do not distinguish between abstract objects and data values. Hence we model a datatype, such as Integer , by means of a concept, and an attribute, such as employee\u2019s salary, by means of a role. Thus, salary can be represented as follows:\nEmployee v \u2203salary (DL-Litecore) \u2203salary\u2212 v Integer (DL-Litecore) \u2265 2 salary v \u22a5 (DL-LiteFcore)\nThe functional attribute empCode with values in Integer is represented in the same way. The binary relationship worksOn has Employee as its domain and Project as its range:\n\u2203worksOn v Employee (DL-Litecore) \u2203worksOn\u2212 v Project (DL-Litecore)\nThe binary relationship boss with domain Employee and range Manager is treated analogously. Each employee works on a project and has exactly one boss, while a project must\ninvolve at least three employees:\nEmployee v \u2203worksOn (DL-Litecore) Employee v \u2203boss (DL-Litecore) \u2265 2 boss v \u22a5 (DL-LiteFcore)\nProject v \u2265 3 worksOn\u2212 (DL-LiteNcore)\nA top manager manages exactly one project and also works on that project, while a project is managed by exactly one top manager:\n\u2203manages v TopManager (DL-Litecore) \u2203manages\u2212 v Project (DL-Litecore) TopManager v \u2203manages (DL-Litecore) Project v \u2203manages\u2212 (DL-Litecore)\n\u2265 2 manages v \u22a5 (DL-LiteFcore) \u2265 2 manages\u2212 v \u22a5 (DL-LiteFcore)\nmanages v worksOn (DL-LiteHcore)\nAll in all, the only languages in the extended DL-Lite family capable of representing the UML class diagram in Figure 2 are DL-LiteHNbool and DL-Lite (HN ) bool . Note, however, that except for the covering constraint, Manager v AreaManager tTopManager , all other concept inclusions in the DL-Lite translation of the UML class diagram belong to variants of the \u2018core\u2019 fragments DL-LiteHNcore and DL-Lite (HN ) core . It is not hard to imagine a situation where one needs Horn concept inclusions to represent integrity constraints over UML class diagrams, for example, to express (together with the above axioms) that \u2018no chief executive officer may work on five projects and be a manager of one of them:\u2019\nCEO u (\u2265 5 worksOn) u \u2203manages v \u22a5 (DL-LiteNhorn)\nIn the context of UML class diagrams, the Krom fragment DL-Litekrom (with its variants) seems to be useless: it extends DL-Litecore with concept inclusions of the form \u00acB1 v B2 or, equivalently, > v B1 t B2, which are rarely used in conceptual modeling. Indeed, this would correspond to partitioning the whole domain of interest in just two parts, while more general and useful covering constraints of the form B v B1 t \u00b7 \u00b7 \u00b7 tBk require the full Bool language. On the other hand, the Krom fragments are important for pinpointing the borderlines of various complexity classes over the description logics of the DL-Lite family and their extensions; see Table 2.\n3. Reasoning in DL-Lite Logics\nWe discuss now the reasoning problems we consider in this article, their mutual relationships, and the complexity measures we adopt. We also provide an overview of the complexity results for DL-Lite logics obtained in this article."}, {"heading": "3.1 Reasoning Problems", "text": "We will concentrate on three fundamental and standard reasoning tasks for description logics: satisfiability (or consistency), instance checking, and query answering.\nFor a DL L in the extended DL-Lite family, we define an L-concept inclusion as any concept inclusion allowed in L. Similarly, we define the notions of L-KB and L-TBox. Finally, define an L-concept as any concept that can occur on the right-hand side of an L-concept inclusion or a conjunction of such concepts.\nSatisfiability. The KB satisfiability problem is to check, given an L-KB K, whether there is a model of K. Clearly, satisfiability is the minimal requirement for any ontology. As is well known in DL (Baader et al., 2003), many other reasoning tasks for description logics are reducible to the satisfiability problem. Consider, for example, the subsumption problem: given an L-TBox T and an L-concept inclusion C1 v C2, decide whether T |= C1 v C2, that is, CI1 \u2286 CI2 , for every model I of T . To reduce this problem to (un)satisfiability, take a fresh concept name A, a fresh object name a, and set K = (T \u2032,A), where\nT \u2032 = T \u222a {A v C1, A v \u00acC2} and A = {A(a)}.\nIt is easy to see that T |= C1 v C2 iff K is not satisfiable. For core, Krom and Horn KBs, if C2 = d kDk, where each Dk is a (possibly negated) basic concept, checking unsatisfiability of K amounts to checking unsatisfiability of each of the KBs Kk = (Tk,A), where Tk = T \u222a {A v C1, A v \u00acDk} (for Horn KBs, replace A v \u00acB with the equivalent A uB v \u22a5).\nThe concept satisfiability problem\u2014given an L-TBox T and an L-concept C, decide whether CI 6= \u2205 in a model I of T\u2014is also easily reducible to KB satisfiability. Indeed, take a fresh concept name A, a fresh object name a, and set K = (T \u2032,A), where\nT \u2032 = T \u222a {A v C} and A = {A(a)}.\nThen C is satisfiable with respect to T iff K is satisfiable.\nInstance checking. The instance checking problem is to decide, given an object name a, an L-concept C and an L-KB K = (T ,A), whether K |= C(a), that is, aI \u2208 CI , for every model I of K. Instance checking is also reducible to (un)satisfiability: an object a is an instance of an L-concept C in every model of K = (T ,A) iff the KB K\u2032 = (T \u2032,A\u2032), with\nT \u2032 = T \u222a {A v \u00acC} and A\u2032 = A \u222a {A(a)},\nis not satisfiable, where A is a fresh concept name. For core, Krom and Horn KBs, if C = d kDk, where each Dk is a (possibly negated) basic concept, we can proceed as for subsumption: checking the unsatisfiability of K\u2032 amounts to checking the unsatisfiability of each KB K\u2032k = (T \u2032k ,A\u2032) with T \u2032k = T \u222a {A v \u00acDk}.\nConversely, KB satisfiability is reducible to the complement of instance checking: K is satisfiable iff K 6|= A(a), for a fresh concept name A and a fresh object a.\nQuery answering. A positive existential query q(x1, . . . , xn) is any first-order formula \u03d5(x1, . . . , xn) constructed by means of conjunction, disjunction and existential quantification starting from atoms of the from Ak(t) and Pk(t1, t2), where Ak is a concept name, Pk\na role name, and t, t1, t2 are terms taken from the list of variables y0, y1, . . . and the list of object names a0, a1, . . . (i.e., \u03d5 is a positive existential formula). More precisely,\nt ::= yi | ai, \u03d5 ::= Ak(t) | Pk(t1, t2) | \u03d51 \u2227 \u03d52 | \u03d51 \u2228 \u03d52 | \u2203yi \u03d5.\nThe free variables of \u03d5 are called distinguished variables of q and the bound ones are nondistinguished variables of q. We write q(x1, . . . , xn) for a query with distinguished variables x1, . . . , xn. A conjunctive query is a positive existential query that contains no disjunction (it is constructed from atoms by means of conjunction and existential quantification only).\nGiven a query q(~x) = \u03d5(~x) with ~x = x1, . . . , xn and an n-tuple ~a of object names, we write q(~a) for the result of replacing every occurrence of xi in \u03d5(~x) with the ith member of ~a. Queries containing no distinguished variables will be called ground (they are also known as Boolean).\nLet I = (\u2206I , \u00b7I) be an interpretation. An assignment a in \u2206I is a function associating with every variable y an element a(y) of \u2206I . We will use the following notation: aI,ai = a I i and yI,a = a(y). The satisfaction relation for positive existential formulas with respect to a given assignment a is defined inductively by taking:\nI |=a Ak(t) iff tI,a \u2208 AIk ,\nI |=a Pk(t1, t2) iff (tI,a1 , t I,a 2 ) \u2208 P I k ,\nI |=a \u03d51 \u2227 \u03d52 iff I |=a \u03d51 and I |=a \u03d52, I |=a \u03d51 \u2228 \u03d52 iff I |=a \u03d51 or I |=a \u03d52, I |=a \u2203yi \u03d5 iff I |=b \u03d5, for some assignment b in \u2206I that may differ from a on yi.\nFor a ground query q(~a), the satisfaction relation does not depend on the assignment a, and so we write I |= q(~a) instead of I |=a q(~a). The answer to such a query is either \u2018yes\u2019 or \u2018no.\u2019\nFor a KB K = (T ,A), we say that a tuple ~a of object names from A is a certain answer to q(~x) with respect to K, and write K |= q(~a), if I |= q(~a) whenever I |= K. The query answering problem can be formulated as follows: given an L-KB K = (T ,A), a query q(~x), and a tuple ~a of object names from A, decide whether K |= q(~a).\nNote that the instance checking problem is a special case of query answering: an object a is an instance of an L-concept C with respect to a KB K iff the answer to the query A(a) with respect to K\u2032 is \u2018yes,\u2019 where K\u2032 = (T \u2032,A) and T \u2032 = T \u222a {C v A}, with A a fresh concept name. For Horn-concepts B1 u \u00b7 \u00b7 \u00b7 uBk, we consider the query A1(a) \u2227 \u00b7 \u00b7 \u00b7 \u2227Ak(a) with respect to K\u2032, where K\u2032 = (T \u2032,A) and T \u2032 = T \u222a {B1 v A1, . . . , Bk v Ak}, with the Ai fresh concept names. Similarly, we deal with Krom-concepts D1 u \u00b7 \u00b7 \u00b7 uDk, where each Di is a possibly negated basic concept. For core-concepts, the reduction holds just for conjunctions of basic concepts."}, {"heading": "3.2 Complexity Measures: Data and Combined Complexity", "text": "The computational complexity of the reasoning problems discussed above can be analyzed with respect to different complexity measures, which depend on those parameters of the\nproblem that are regarded to be the input (i.e., can vary) and those that are regarded to be fixed. For satisfiability and instance checking, the parameters to consider are the size of the TBox T and the size of the ABox A, that is the number of symbols in T and A, denoted |T | and |A|, respectively. The size |K| of the knowledge K = (T ,A) is simply given by |T |+ |A|. For query answering, one more parameter to consider would be the size of the query. However, in our analysis we adopt the standard database assumption that the size of queries is always bounded by some reasonable constant and, in any case, negligible with respect to both the size of the TBox and the size of the ABox. Thus we do not count the query as part of the input.\nHence, we consider our reasoning problems under two complexity measures. If the whole KB K is regarded as an input, then we deal with combined complexity. If, however, only the ABox A is counted as an input, while the TBox T (and the query) is regarded to be fixed, then our concern is data complexity (Vardi, 1982). Combined complexity is of interest when we are still designing and testing the ontology. On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008). Since the logics of the DL-Lite family were tailored to deal with large data sets stored in relational databases, data complexity of both instance checking and query answering is of particular interest to us.\n3.3 Remarks on the Complexity Classes LogSpace and AC0\nIn this paper, we deal with the following complexity classes:\nAC0 ( LogSpace \u2286 NLogSpace \u2286 P \u2286 NP \u2286 ExpTime.\nTheir definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006). Here we only remind the reader of the two smallest classes LogSpace and AC0.\nA problem belongs to LogSpace if there is a two-tape Turing machine M such that, starting with an input of length n written on the read-only input tape,M stops in an accepting or rejecting state having used at most log n cells of the (initially blank) read/write work tape. A LogSpace transducer is a three-tape Turing machine that, having started with an input of length n written on the read-only input tape, writes the result (of polynomial size) on the write-only output tape using at most log n cells of the (initially blank) read/write work tape. A LogSpace-reduction is a reduction computable by a LogSpace transducer; the composition of two LogSpace transducers is also a LogSpace transducer (Kozen, 2006, Lemma 5.1).\nThe formal definition of the complexity class AC0 (see, e.g., Boppana & Sipser, 1990; Vollmer, 1999 and references therein) is based on the circuit model, where functions are represented as directed acyclic graphs built from unbounded fan-in And, Or and Not gates (i.e., And and Or gates may have an unbounded number of incoming edges). For this definition we assume that decision problems are encoded in the alphabet {0, 1} and so can be regarded as Boolean functions. AC0 is the class of problems definable using\na family of circuits of constant depth and polynomial size, which can be generated by a deterministic Turing machine in logarithmic time (in the size of the input); the latter condition is called LogTime-uniformity. Intuitively, AC0 allows us to use polynomially many processors but the run-time must be constant. A typical example of an AC0 problem is evaluation of first-order queries over databases (or model checking of first-order sentences over finite models), where only the database (first-order model) is regarded as the input and the query (first-order sentence) is assumed to be fixed (Abiteboul, Hull, & Vianu, 1995; Vollmer, 1999). On the other hand, the undirected graph reachability problem is known to be in LogSpace (Reingold, 2008) but not in AC0. A Boolean function f : {0, 1}n \u2192 {0, 1} is called AC0-reducible (or constant-depth reducible) to a function g : {0, 1}n \u2192 {0, 1} if there is a (LogTime-uniform) family of constant-depth circuits built from And, Or, Not and g gates that computes f . In this case we say that there is an AC0-reduction. Note that all the reductions considered in Section 3.1 are AC0-reductions. Unless otherwise indicated, in what follows we write \u2018reduction\u2019 for \u2018AC0-reduction.\u2019"}, {"heading": "3.4 Summary of Complexity Results", "text": "In this article, our aim is to investigate (i) the combined and data complexity of the satisfiability and instance checking problems and (ii) the data complexity of the query answering problem for the logics of the extended DL-Lite family, both with and without the UNA. The obtained and known results for the first 32 logics from Table 1 (the logics DL-Lite (HF)+ \u03b1 and DL-Lite (HN )+ \u03b1 are not included) are summarized in Table 2 (we remind the reader that satisfiability and instance checking are reducible to the complements of each other and that instance checking is a special case of query answering). In fact, all of the results in the table follow from the lower and upper bounds marked with [\u2265] and [\u2264], respectively (by taking into account the hierarchy of languages of the DL-Lite family): for example, the NLogSpace membership of satisfiability in DL-LiteNkrom in Theorem 5.7 implies the same upper bound for DL-LiteFkrom, DL-Litekrom, DL-Lite N core, DL-Lite F core and DL-Litecore because all of them are sub-languages of DL-LiteNkrom.\nRemark 3.1 Two further complexity results are to be noted (they are not included in Table 2):\n(i) If equality between object names is allowed in the language of DL-Lite, which only makes sense if the UNA is dropped, then the AC0 memberships in Table 2 are replaced by LogSpace-completeness (see Section 8, Theorem 8.3 and 8.9); inequality constraints do not affect the complexity.\n(ii) If we extend any of our languages with role transitivity constraints then the combined complexity of satisfiability remains the same, while for data complexity, instance checking and query answering become NLogSpace-hard (see Lemma 6.3), i.e., the membership in AC0 for data complexity is replaced by NLogSpace-completeness, while all other complexity results remain the same.\nIn either case, the property of first-order rewritability\u2014that is, the possibility of rewriting a given query q and a given TBox T into a single first-order query q\u2032 returning the certain answers to q over (T ,A) for every ABox A, which ensures that the query answering problem is in AC0 for data complexity\u2014is lost.\n(in particular, DL-Lite[ |H]\u03b1 is either DL-Lite\u03b1 or DL-Lite H \u03b1 ).\nDL-Lite\u03b2core/horn means DL-Lite \u03b2 core or DL-Lite \u03b2 horn (likewise for DL-Lite \u03b2 krom/bool). \u2018\u2264 [X]\u2019 (\u2018\u2265 [X]\u2019) means that the upper (respectively, lower) bound follows from [X].\nDetailed proofs of our results will be given in Sections 5\u20138. For the variants of logics involving number restrictions, all upper bounds hold also under the assumption that the numbers q in concepts of the form \u2265 q R are given in binary. (Intuitively, this follows from the fact that in our proofs we only use those numbers that explicitly occur in the KB.) All lower bounds remain the same for the unary coding, since in the corresponding proofs we only use numbers not exceeding 4.\nIn the next section we consider the extended DL-Lite family in a more general context by identifying its place among other DL-Lite-related logics, in particular the OWL 2 profiles.\n4. The Landscape of DL-Lite Logics\nThe original family of DL-Lite logics was created with two goals in mind: to identify description logics that, on the one hand, are capable of representing some basic features of conceptual modeling formalisms (such as UML class diagrams and ER diagrams) and, on the other hand, are computationally tractable, in particular, matching the AC0 data complexity of database query answering.\nAs we saw in Section 2.2, to represent UML class diagrams one does not need the typical quantification constructs of the basic description logic ALC (Schmidt-Schau\u00df & Smolka, 1991), namely, universal restriction \u2200R.C and qualified existential quantification \u2203R.C: one can always take the role filler C to be >. Indeed, domain and range restrictions for a relationship P can be expressed by the concepts inclusions \u2203P v B1 and \u2203P\u2212 v B2, respectively. Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-LiteFcore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-LiteFhorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-LiteHcore. It may be worth mentioning that DL-LiteHcore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b) demonstrated how n-ary relations can be represented in DL-LiteFcore by means of reification.\nA further variant of DL-Lite, called DL-LiteA (\u2018A\u2019 for attributes), was introduced by Poggi et al. (2008a) with the aim of capturing as many features of conceptual modeling formalisms as possible, while still maintaining the computational properties of the basic variants of DL-Lite. One of the features in DL-LiteA, borrowed from conceptual modeling formalisms and adopted also in OWL, is the distinction between (abstract) objects and data values, and consequently, between concepts (sets of objects) and datatypes (sets of data values), and between roles (i.e., object properties in OWL, relating objects with objects) and attributes (i.e., data properties in OWL, relating objects with data values). However, as far as the results in this paper are concerned, the distinction between concepts and datatypes, and between roles and attributes has no impact on reasoning whatsoever, since datatypes can simply be treated as special concepts that are mutually disjoint and are also disjoint from the proper concepts. Instead, more relevant for reasoning is the possibility to express in DL-LiteA both role inclusions and functionality, i.e., DL-LiteA includes both DL-LiteHcore and DL-Lite F core, but not DL-Lite HF core.\nAs we have already mentioned, role inclusions and functionality constraints cannot be combined in an unrestricted way without losing the good computational properties: in\nTheorems 5.10 and 6.7, we prove that satisfiability of DL-LiteHFcore KBs is ExpTime-hard for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness was shown by Calvanese et al., 2006). In DL-LiteA, to keep query answering in AC\n0 for data complexity and satisfiability in NLogSpace for combined complexity, functional roles (and attributes) are not allowed to be specialized, i.e., used positively on the right-hand side of role (and attribute) inclusion axioms. So, condition (A3) is a slight generalization of this restriction. DL-LiteA also allows axioms of the form B v \u2203R.C for non-functional roles R, which is covered by conditions (A1) and (A2). Thus, DL-LiteA can be regarded as a proper fragment of both DL-Lite (HF) core and DL-Lite (HN ) horn . We show in Sections 5.3 and 7 that these three languages enjoy very similar computational properties under the UNA: tractable satisfiability and query answering in AC0.\nWe conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential query answering under the UNA. The original eight DL-Lite logics, called by Calvanese et al. (2007b) \u2018the DL-Lite family,\u2019 are shown in the bottom sector of the picture (the logics DL-Lite+A and DL-Lite + A,u extend DL-LiteA and DL-LiteA,u with identification constraints, which are out of the scope of this article). Their nearest relatives are the logic DL-Lite (HN ) horn and its fragments, which are all in AC0 as well. The next layer contains the logics DL-LiteHFcore and DL-LiteHFhorn, in which query answering is data-complete for P (no matter whether the UNA is adopted or not). In fact, these logics are fragments of the much more expressive DL Horn-SHIQ, which was shown to enjoy the same data complexity of query answering by Eiter et al. (2008). It remains to be seen whether polynomial query answering is practically feasible; recent experiments with the DL EL (Lutz, Toman, & Wolter, 2008) indicate that this may indeed be the case. Finally, very distant relatives of the DL-Lite family comprise\nthe upper layer of the picture, where query answering is data-complete for coNP, that is, the same as for the very expressive DL SHIQ.\n4.1 The DL-Lite Family and OWL 2\nThe upcoming version 2 of the Web Ontology Language OWL7 defines three profiles,8 that is, restricted versions of the language that suit specific needs. The DL-Lite family, notably DL-LiteHcore (or the original DL-LiteR), is at the basis of one of these OWL 2 profiles, called OWL 2 QL. According to http://www.w3.org/TR/owl2-profiles/, \u2018OWL 2 QL is aimed at applications that use very large volumes of instance data, and where query answering is the most important reasoning task. In OWL 2 QL, [. . . ] sound and complete conjunctive query answering can be performed in LogSpace with respect to the size of the data (assertions) [and] polynomial time algorithms can be used to implement the ontology consistency and class expression subsumption reasoning problems. The expressive power of the profile is necessarily quite limited, although it does include most of the main features of conceptual models such as UML class diagrams and ER diagrams.\u2019 In this section, we briefly discuss the results obtained in this article in the context of additional constructs that are present in OWL 2.\nA very important difference between the DL-Lite family and OWL is the status of the unique name assumption (UNA): this assumption is quite common in data management, and hence adopted in the DL-Lite family, but not adopted in OWL. Instead, the OWL syntax provides explicit means for stating that object names, say a and b, are supposed to denote the same individual, a \u2248 b, or that they should be interpreted differently, a 6\u2248 b (in OWL, these constructs are called sameAs and differentFrom).\nThe complexity results we obtain for logics of the form DL-LiteH\u03b1 do not depend on whether the UNA is adopted or not (because every model of a DL-LiteH\u03b1 KB without UNA can be \u2018untangled\u2019 into a model of the same KB respecting the UNA; see Lemma 8.10). However, this is not the case for the logics DL-LiteF\u03b1 and DL-Lite N \u03b1 , where there is an obvious interaction between the UNA and number restrictions (cf. Table 2). For example, under the UNA, instance checking for DL-LiteFcore is in AC\n0 for data complexity, whereas dropping this assumption results in a much higher complexity: in Section 8, we prove that it is P-complete. The addition of the equality construct \u2248 to DL-LiteHcore and DL-LiteHhorn slightly changes data complexity of query answering and instance checking, as it rises from membership in AC0 to LogSpace-completeness; see Section 8. What is more important, however, is that in this case we loose first-order rewritability of query answering and instance checking, and as a result cannot use the standard database query engines in a straightforward manner.\nSince the OWL 2 profiles are defined as syntactic restrictions of the language without changing the basic semantic assumptions, it was chosen not to include in the OWL 2 QL profile any construct that interferes with the UNA and which, in the absence of the UNA, would cause higher complexity. That is why OWL 2 QL does not include number restrictions, not even functionality constraints. Also, keys (the mechanism of identifying objects by means of the values of their properties) are not supported, although they are an impor-\n7. http://www.w3.org/2007/OWL/ 8. In logic, profiles would be called fragments as they are defined by placing restrictions on the OWL 2\nsyntax only.\ntant notion in conceptual modeling. Indeed, keys can be considered as a generalization of functionality constraints (Toman & Weddell, 2005, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007a, 2008b), since asserting a unary key, i.e., one involving only a single role R, is equivalent to asserting the functionality of the inverse of R. Hence, in the absence of the UNA, allowing keys would change the computational properties.\nAs we have already mentioned, some other standard OWL constructs, such as role disjointness, (a)symmetry and (ir)reflexivity constraints, can be added to the DL-Lite logics without changing their computational behavior. Role transitivity constraints, Tra(R), asserting that R must be interpreted as a transitive role, can also be added to DL-Lite (HN ) horn but this leads to the increase of the data complexity for all reasoning problems to NLogSpace, although satisfiability remains in P for combined complexity. These results can be found in Section 5.3.\nOf other constructs of OWL 2 that so far are not supported by the DL-Lite logics we mention nominals (i.e., singleton concepts), Boolean operators on roles, and role chains."}, {"heading": "5. Satisfiability: Combined Complexity", "text": "DL-LiteHNbool is clearly a sub-logic of the description logic SHIQ, the satisfiability problem for which is known to be ExpTime-complete (Tobies, 2001).\nIn Section 5.1 we show, however, that the satisfiability problem for DL-LiteNbool KBs is reducible to the satisfiability problem for the one-variable fragment, QL1, of first-order logic without equality and function symbols. As satisfiability of QL1-formulas is NP-complete (see, e.g., Bo\u0308rger et al., 1997) and the logics under consideration contain full Booleans on concepts, satisfiability of DL-LiteNbool KBs is NP-complete as well. We shall also see that the translations of Horn and Krom KBs into QL1 belong to the Horn and Krom fragments of QL1, respectively, which are known to be P- and NLogSpace-complete (see, e.g., Papadimitriou, 1994; Bo\u0308rger et al., 1997). In Section 5.2, we will show how to simulate the behavior of polynomial-space-bounded alternating Turing machines by means of DL-LiteHFcore KBs. This will give the (optimal) ExpTime lower bound for satisfiability of KBs in all the languages of our family containing unrestricted occurrences of both functionality constraints and role inclusions. In Section 5.3, we extend the embedding into QL1, defined in Section 5.1, to the logic DL-Lite\n(HN ) bool , thereby establishing the same upper bounds as for DL-Lite N bool and its\nfragments. Finally, in Section 5.4 we investigate the impact of role transitivity constraints.\n5.1 DL-LiteNbool and its Fragments: First-Order Perspective Our aim in this section is to construct a reduction of the satisfiability problem for DL-LiteNbool KBs to satisfiability of QL1-formulas. We will do this in two steps: first we present a lengthy yet quite \u2018natural\u2019 and transparent (yet exponential) reduction \u00b7\u2020, and then we shall see from the proof that this reduction can be substantially optimized to a linear reduction \u00b7\u2021.\nLet K = (T ,A) be a DL-LiteNbool KB. Recall that role\u00b1(K) denotes the set of direct and inverse role names occurring in K and ob(A) the set of object names occurring in A. For R \u2208 role\u00b1(K), let QRT be the set of natural numbers containing 1 and all the numbers q for which the concept \u2265 q R occurs in T (recall that the ABox does not contain number restrictions). Note that |QRT | \u2265 2 if T contains a functionality constraint for R.\nWith every object name ai \u2208 ob(A) we associate the individual constant ai of QL1 and with every concept name Ai the unary predicate Ai(x) from the signature of QL1. For each role R \u2208 role\u00b1(K), we introduce |QRT |-many fresh unary predicates\nEqR(x), for q \u2208 QRT .\nThe intended meaning of these predicates is as follows: for a role name Pk,\n\u2022 EqPk(x) and EqP\u2212k (x) represent the sets of points with at least q distinct Pk-successors and at least q distinct Pk-predecessors, respectively. In particular, E1Pk(x) and E1P \u2212 k (x) represent the domain and range of Pk, respectively.\nAdditionally, for every pair of roles Pk, P \u2212 k \u2208 role \u00b1(K), we take two fresh individual constants\ndpk and dp \u2212 k\nof QL1, which will serve as \u2018representatives\u2019 of the points from the domains of Pk and P\u2212k , respectively (provided that they are not empty). Let dr(K) = { dr | R \u2208 role\u00b1(K) } . Furthermore, for each pair of object names ai, aj \u2208 ob(A) and each R \u2208 role\u00b1(K), we take a fresh propositional variable Raiaj of QL1 to encode the ABox assertion R(ai, aj).9\nBy induction on the construction of a DL-LiteNbool concept C we define the QL1-formula C\u2217:\n\u22a5\u2217 = \u22a5, (Ai)\u2217 = Ai(x), (\u2265q R)\u2217 = EqR(x), (\u00acC)\u2217 = \u00acC\u2217(x), (C1 u C2)\u2217 = C\u22171 (x) \u2227 C\u22172 (x).\nThe DL-LiteNbool TBox T corresponds then to the QL1-sentence \u2200x T \u2217(x), where\nT \u2217(x) = \u2227\nC1vC2\u2208T\n( C\u22171 (x)\u2192 C\u22172 (x) ) . (1)\nThe ABox A is translated into the following pair of QL1-sentences\nA\u20201 = \u2227\nAk(ai)\u2208A\nAk(ai) \u2227 \u2227\n\u00acAk(ai)\u2208A\n\u00acAk(ai), (2)\nA\u20202 = \u2227\nPk(ai,aj)\u2208A\nPkaiaj \u2227 \u2227\n\u00acPk(ai,aj)\u2208A\n\u00acPkaiaj . (3)\nFor every role R \u2208 role\u00b1(K), we need two QL1-formulas:\n\u03b5R(x) = E1R(x)\u2192 inv(E1R)(inv(dr)), (4) \u03b4R(x) = \u2227\nq,q\u2032\u2208QRT , q \u2032>q\nq\u2032>q\u2032\u2032>q for no q\u2032\u2032\u2208QRT\n( Eq\u2032R(x)\u2192 EqR(x) ) , (5)\n9. In what follows, we slightly abuse notation and write R(ai, aj) \u2208 A to indicate that Pk(ai, aj) \u2208 A if R = Pk, or Pk(aj , ai) \u2208 A if R = P\u2212k .\nwhere (by overloading the inv operator),\ninv(EqR) =\n{ EqP \u2212 k , if R = Pk,\nEqPk, if R = P \u2212 k ,\nand inv(dr) =\n{ dp\u2212k , if R = Pk,\ndpk, if R = P \u2212 k .\nFormula (4) says that if the domain of R is not empty then its range is not empty either: it contains the constant inv(dr), the \u2018representative\u2019 of the domain of inv(R).\nWe also need formulas representing the relationship of the propositional variables Raiaj with the unary predicates for the role domain and range: for a role R \u2208 role\u00b1(K), let R\u2020 be the following QL1-sentence\n\u2227 ai\u2208ob(A) \u2227 q\u2208QRT \u2227 aj1 ,...,ajq\u2208ob(A) jk 6=jk\u2032 for k 6=k\u2032 ( q\u2227 k=1 Raiajk \u2192 EqR(ai) ) \u2227 \u2227 ai,aj\u2208ob(A) ( Raiaj \u2192 inv(R)ajai ) , (6)\nwhere inv(R)ajai is the propositional variable P \u2212 k ajai if R = Pk and Pkajai if R = P \u2212 k . Note that the first conjunct of (6) is the only part of the translation that relies on the UNA. Finally, for the DL-LiteNbool knowledge base K = (T ,A), we set\nK\u2020 = \u2200x [ T \u2217(x) \u2227 \u2227 R\u2208role\u00b1(K) ( \u03b5R(x) \u2227 \u03b4R(x) ) ] \u2227 [ A\u20201 \u2227 A\u20202 \u2227 \u2227 R\u2208role\u00b1(K) R\u2020 ] .\nThus, K\u2020 is a universal sentence of QL1.\nExample 5.1 Consider, for example, the KB K = (T ,A) with T = { A v \u2203P\u2212, \u2203P\u2212 v A, A v \u2265 2P, > v \u2264 1P\u2212, \u2203P v A } and A = {A(a), P (a, a\u2032)}. Then we obtain the following first-order translation:\nK\u2020 = \u2200x\u03c7(x) \u2227 A(a) \u2227 Paa\u2032 \u2227( Paa\u2032 \u2192 E1P (a) ) \u2227 ( Paa\u2192 E1P (a) ) \u2227(\nPa\u2032a\u2192 E1P (a\u2032) ) \u2227 ( Pa\u2032a\u2032 \u2192 E1P (a\u2032) ) \u2227(\nP\u2212aa\u2032 \u2192 E1P\u2212(a) ) \u2227 ( P\u2212aa\u2192 E1P\u2212(a) ) \u2227(\nP\u2212a\u2032a\u2192 E1P\u2212(a\u2032) ) \u2227 ( P\u2212a\u2032a\u2032 \u2192 E1P\u2212(a\u2032) ) \u2227(\nPaa\u2032 \u2227 Paa\u2192 E2P (a) ) \u2227 ( Pa\u2032a \u2227 Pa\u2032a\u2032 \u2192 E2P (a\u2032) ) \u2227(\nP\u2212aa\u2032 \u2227 P\u2212aa\u2192 E2P\u2212(a) ) \u2227 ( P\u2212a\u2032a \u2227 P\u2212a\u2032a\u2032 \u2192 E2P\u2212(a\u2032) ) \u2227(\nPaa\u2032 \u2194 P\u2212a\u2032a ) \u2227 ( Pa\u2032a\u2194 P\u2212aa\u2032 ) \u2227 ( Paa\u2194 P\u2212aa ) \u2227 ( Pa\u2032a\u2032 \u2194 P\u2212a\u2032a\u2032 ) .\nwhere\n\u03c7(x) = ( A(x)\u2192 E1P\u2212(x) ) \u2227 ( E1P \u2212(x)\u2192 A(x) ) \u2227 ( A(x)\u2192 E2P (x) ) \u2227(\n> \u2192 \u00acE2P\u2212(x) ) \u2227 ( E1P (x)\u2192 A(x) ) \u2227(\nE1P (x)\u2192 E1P\u2212(dp\u2212) ) \u2227 ( E1P \u2212(x)\u2192 E1P (dp) ) \u2227(\nE2P (x)\u2192 E1P (x) ) \u2227 ( E2P \u2212(x)\u2192 E1P\u2212(x) ) . (7)\nTheorem 5.2 A DL-LiteNbool knowledge base K = (T ,A) is satisfiable iff the QL1-sentence K\u2020 is satisfiable.\nProof (\u21d0) If K\u2020 is satisfiable then there is a model M of K\u2020 whose domain consists of all the constants occurring in K\u2020\u2014i.e., ob(A) \u222a dr(K) (say, an Herbrand model of K\u2020). We denote this domain by D and the interpretations of the (unary) predicates P , propositional variables p and constants a of QL1 in M by PM, pM and aM, respectively. Thus, for every constant a, we have aM = a. Let D0 be the set of all constants a, a \u2208 ob(A). Without loss of generality we may assume that D0 6= \u2205.\nWe construct an interpretation I for DL-LiteNbool based on some domain \u2206I \u2287 D0 that will be inductively defined as the union\n\u2206I = \u221e\u22c3 m=0 Wm, where W0 = D0.\nThe interpretations of the object names ai in I are given by their interpretations in M, namely, aIi = a M i \u2208 W0. Each set Wm+1, for m \u2265 0, is constructed by adding to Wm some new elements that are fresh copies of certain elements from D \\D0. If such a new element w\u2032 is a copy of w \u2208 D \\D0 then we write cp(w\u2032) = w, while for w \u2208 D0 we let cp(w) = w. The set Wm \\Wm\u22121, for m \u2265 0, will be denoted by Vm (for convenience, let W\u22121 = \u2205, so that V0 = D0).\nThe interpretations AIk of concept names Ak in I are defined by taking\nAIk = { w \u2208 \u2206I | M |= A\u2217k[cp(w)] } . (8)\nThe interpretation P Ik of a role name Pk in I will be defined inductively as the union\nP Ik = \u221e\u22c3 m=0 Pmk , where P m k \u2286Wm \u00d7Wm,\nalong with the construction of \u2206I . First, for a role R \u2208 role\u00b1(K), we define the required R-rank r(R, d) of a point d \u2208 D by taking\nr(R, d) = max ( {0} \u222a { q \u2208 QRT | M |= EqR[d] } ) .\nIt follows from (5) that if r(R, d) = q then, for every q\u2032 \u2208 QRT , we have M |= Eq\u2032R[d] whenever q\u2032 \u2264 q, and M |= \u00acEq\u2032R[d] whenever q < q\u2032. We also define the actual R-rank rm(R,w) of a point w \u2208 \u2206I at step m by taking\nrm(R,w) = { ]{w\u2032 \u2208Wm | (w,w\u2032) \u2208 Pmk }, if R = Pk, ]{w\u2032 \u2208Wm | (w\u2032, w) \u2208 Pmk }, if R = P \u2212 k .\nFor the basis of induction we set, for each role name Pk \u2208 role(K), P 0k = { (aMi , a M j ) \u2208W0 \u00d7W0 | M |= Pkaiaj } . (9)\nObserve that, by (6), for all R \u2208 role\u00b1(K) and w \u2208W0,\nr0(R,w) \u2264 r(R, cp(w)). (10)\nSuppose now that Wm and the P m k , for m \u2265 0, have already been defined. If we had rm(R,w) = r(R, cp(w)), for all roles R \u2208 role\u00b1(K) and points w \u2208 Wm, then the interpretation I we need would be constructed. However, in general this is not the case because there may be some \u2018defects\u2019 in the sense that the actual rank of some points is smaller than the required rank.\nFor a role name Pk \u2208 role(K), consider the following two sets of defects in Pmk : \u039bmk = { w \u2208 Vm | rm(Pk, w) < r(Pk, cp(w)) } ,\n\u039bm\u2212k = { w \u2208 Vm | rm(P\u2212k , w) < r(P \u2212 k , cp(w)) } .\nThe purpose of, say, \u039bmk is to identify those \u2018defective\u2019 points w \u2208 Vm from which precisely r(Pk, cp(w)) distinct Pk-arrows should start (according to M), but some arrows are still missing (only rm(Pk, w) many arrows exist). To \u2018cure\u2019 these defects, we extend Wm and Pmk respectively to Wm+1 and P m+1 k according to the following rules: (\u039bmk ) Let w \u2208 \u039bmk , q = r(Pk, cp(w)) \u2212 rm(Pk, w) and d = cp(w). We have M |= Eq\u2032Pk[d] for some q\u2032 \u2208 QRT with q\u2032 \u2265 q > 0. Then, by (5), M |= E1Pk[d] and, by (4), M |= E1P\u2212k [dp \u2212 k ]. In this case we take q fresh copies w \u2032 1, . . . , w \u2032 q of dp \u2212 k (and set\ncp(w\u2032i) = dp \u2212 k , for 1 \u2264 i \u2264 q), add them to Wm+1 and add the pairs (w,w \u2032 i), 1 \u2264 i \u2264 q, to Pm+1k .\n(\u039bm\u2212k ) Let w \u2208 \u039b m\u2212 k , q = r(P \u2212 k , cp(w))\u2212 rm(P \u2212 k , w) and d = cp(w). Then M |= Eq\u2032P \u2212 k [d]\nfor some q\u2032 \u2208 QRT with q\u2032 \u2265 q > 0. So, by (5), we have M |= E1P \u2212 k [d] and, by (4), M |= E1Pk[dpk]. Take q fresh copies w\u20321, . . . , w\u2032q of dpk (and set cp(w\u2032i) = dpk, for 1 \u2264 i \u2264 q), add them to Wm+1 and add the pairs (w\u2032i, w), 1 \u2264 i \u2264 q, to P m+1 k .\nExample 5.3 Consider again the KBK and its first-order translationK\u2020 from Example 5.1. Consider also a model M of K\u2020 with the domain D = {a, a\u2032, dp, dp\u2212}, where\nAM = (E1P ) M = (E1P \u2212)M = (E2P ) M = D, (E2P \u2212)M = \u2205, (Paa\u2032)M = (P\u2212a\u2032a)M = t.\nWe begin the construction of the interpretation I of K by setting W0 = V0 = D0 = {a, a\u2032} and P 0 = {(a, a\u2032)}. Then we compute the required and actual ranks r(R,w) and r0(R,w), for R \u2208 {P, P\u2212} and w \u2208 V0:\n(i) r(P, a) = 2 and r0(P, a) = 1, (ii) r(P, a \u2032) = 2 and r0(P, a \u2032) = 0, (iii) r(P\u2212, a) = 1 and r0(P \u2212, a) = 0, (iv) r(P\u2212, a\u2032) = 1 and r0(P \u2212, a\u2032) = 1.\nAt the next step, we draw a P -arrow from a to a fresh copy of dp\u2212 to cure defect (i), draw two P -arrows from a\u2032 to two more fresh copies of dp\u2212 in order to cure defects (ii), and finally we take a fresh copy of dp and connect it to a by a P -arrow, thereby curing defect (iii).\nOne more step of this \u2018unraveling\u2019 construction is shown in Figure 4.\nObserve the following important property of the construction: for m,m0 \u2265 0, w \u2208 Vm0 and R \u2208 role\u00b1(K),\nrm(R,w) =  0, if m < m0,\nq, if m = m0, for some q \u2264 r(R, cp(w)), r(R, cp(w)), if m > m0.\n(11)\n.\nTo prove this property, consider all possible cases:\n\u2022 If m < m0 then the point w has not been added to Wm yet, i.e., w /\u2208Wm, and so we have rm(R,w) = 0.\n\u2022 If m = m0 and m0 = 0 then rm(R,w) \u2264 r(R, cp(w)) follows from (10).\n\u2022 If m = m0 and m0 > 0 then w was added at step m0 to cure a defect of some point w\u2032 \u2208 Wm0\u22121. This means that there is Pk \u2208 role(K) such that either (w\u2032, w) \u2208 P m0 k\nand w\u2032 \u2208 \u039bm0\u22121k or (w,w \u2032) \u2208 Pm0k and w \u2032 \u2208 \u039b(m0\u22121)\u2212k . Consider the former case. We have cp(w) = dp\u2212k . Since fresh witnesses are picked up every time the rule (\u039b m0\u22121 k ) is applied, rm0(P \u2212 k , w) = 1, rm0(Pk, w) = 0 and rm0(R,w) = 0, for every R 6= Pk, P \u2212 k . So it suffices to show that r(P\u2212k , dp \u2212 k ) \u2265 1. Indeed, as M |= EqPk[cp(w\n\u2032)] for some q \u2208 QRT , we have, by (5), M |= E1Pk[cp(w\u2032)], and so, by (4), M |= E1P \u2212 k [dp \u2212 k ]. By the definition of r, we have r(P\u2212k , dp \u2212 k ) \u2265 1. The latter case is considered analogously.\n\u2022 If m = m0 + 1 then, for each role name Pk, all defects of w are cured at step m0 + 1 by applying the rules (\u039bm0k ) and (\u039b m0\u2212 k ). Therefore, rm0+1(R,w) = r(R, cp(w)).\n\u2022 If m > m0 +1 then (11) follows from the observation that new arrows involving w can only be added at step m0 + 1, that is, for all m \u2265 0 and each role name Pk \u2208 role(K),\nPm+1k \\ P m k \u2286 Vm \u00d7 Vm+1 \u222a Vm+1 \u00d7 Vm. (12)\nIt follows that, for all R \u2208 role\u00b1(K), q \u2208 QRT and w \u2208 \u2206I , we have:\nM |= EqR[cp(w)] iff w \u2208 (\u2265 q R)I . (13)\nIndeed, if M |= EqR[cp(w)] then, by definition, r(R, cp(w)) \u2265 q. Let w \u2208 Vm0 . Then, by (11), rm(R,w) = r(R, cp(w)) \u2265 q, for all m > m0. It follows from the definition of\nrm(R,w) and R I that w \u2208 (\u2265 q R)I . Conversely, let w \u2208 (\u2265 q R)I and w \u2208 Vm0 . Then, by (11), q \u2264 rm(R,w) = r(R, cp(w)), for all m > m0. So, by the definition of r(R, cp(w)) and (5), M |= EqR[cp(w)].\nBy induction on the construction of concepts C in K one can readily see that, for every w \u2208 \u2206I , we have\nM |= C\u2217[cp(w)] iff w \u2208 CI . (14)\nIndeed, the basis is trivial for B = \u22a5 and follows from (8) for B = Ak and from (13) for B = \u2265 q R, while the induction step for the Booleans (C = \u00acC1 and C = C1 u C2) immediately follows from the induction hypothesis.\nFinally, we show that for each \u03c8 \u2208 T \u222a A,\nM |= \u03c8\u2020 iff I |= \u03c8.\nThe case \u03c8 = C1 v C2 follows from (14); for \u03c8 = Ak(ai) and \u03c8 = \u00acAk(ai) from the definition of AIk . For \u03c8 = Pk(ai, aj) and \u03c8 = \u00acPk(ai, aj), we have (aIi , aIj ) \u2208 P Ik iff, by (12), (aIi , a I j ) \u2208 P 0k iff, by (9), M |= Pkaiaj .\nThus, we have established that I |= K. (\u21d2) Conversely, suppose that I |= K is an interpretation with domain \u2206I . We construct a model M of K\u2020 based on the same \u2206I . For every ai \u2208 ob(A), we let aMi = aIi and, for every R \u2208 role\u00b1(K), we take some d \u2208 (\u2265 1R)I if (\u2265 1R)I 6= \u2205 and an arbitrary element d \u2208 \u2206I otherwise, and let drM = d. Next, for every concept name Ak, we let AMk = AIk and, for every role R \u2208 role\u00b1(K) and q \u2208 QRT , we set EqRM = (\u2265 q R)I . Finally, for every role R \u2208 role\u00b1(K) and every pair of objects ai, aj \u2208 ob(A), we define (Raiaj)M to be true iff I |= R(ai, aj). One can readily check that M |= K\u2020. Details are left to the reader. q\nThe first-order translation K\u2020 of K is obviously too lengthy to provide us with reasonably low complexity results: |K\u2020| \u2264 |K|+ (2+ q2T ) \u00b7 |role(K)|+ 2 \u00b7 |role(K)| \u00b7 |ob(A)|qT . However, it follows from the proof above that a lot of information in this translation is redundant and can be safely omitted.\nNow we define a more concise translation K\u2021 of K = (T ,A) into QL1 by taking:\nK\u2021 = \u2200x [ T \u2217(x) \u2227 \u2227 R\u2208role\u00b1(K) ( \u03b5R(x) \u2227 \u03b4R(x) )] \u2227 A\u20201 \u2227 A\u20212 ,\nwhere T \u2217(x), \u03b5R(x), \u03b4R(x) and A\u2020 1\nare defined as before by means of (1), (4), (5) and (2), respectively, and\nA\u20212 = \u2227\na\u2208ob(A)\n\u2227 R\u2208role\u00b1(K)\n\u2203a\u2032\u2208ob(A) R(a,a\u2032)\u2208A\nEqR,aR(a) \u2227 \u2227\n\u00acPk(ai,aj)\u2208A\n(\u00acPk(ai, aj))\u22a5, (15)\nwhere qR,a is the maximum number in Q R T such that there are qR,a many distinct ai with R(a, ai) \u2208 A (here we use the UNA) and (\u00acPk(ai, aj))\u22a5 = \u22a5 if Pk(ai, aj) \u2208 A and > otherwise. Now both the size of A\u20212 and the size of K\u2021 are linear in the size of A and K, respectively, no matter whether the numbers are coded in unary or in binary.\nMore importantly, the translation \u00b7\u2021 can actually be done in LogSpace. Indeed, this is trivially the case for T \u2217(x), \u03b5R(x), \u03b4R(x), A\u2020 1 and the last conjunct of A\u20212 . As for the first conjunct of A\u20212 then, for R \u2208 role\u00b1(K) and a \u2208 ob(A), the maximum qR,a in QRT such that there are qR,a many distinct ai with R(a, ai) \u2208 A, can be computed using log min(maxQRT , |ob(A)|) + log |ob(A)| cells. Initially we set q = 0, and then enumerate all object names ai in A incrementing the current q each time we find R(a, ai) \u2208 A. We stop if q = maxQRT or we reach the end of the object name list. The resulting qR,a is the maximum number in QRT not exceeding q.\nExample 5.4 The translation K\u2021 of the KB K from Example 5.1 looks as follows:\nK\u2021 = \u2200x\u03c7(x) \u2227 A(a) \u2227 E1P (a) \u2227 E1P\u2212(a\u2032),\nwhere \u03c7(x) is defined by (7).\nCorollary 5.5 A DL-LiteNbool KB K is satisfiable iff the QL1-sentence K\u2021 is satisfiable.\nProof The claim follows from the fact that K\u2020 is satisfiable iff K\u2021 is satisfiable. Indeed, if M |= K\u2020 then clearly M |= K\u2021. Conversely, if M |= K\u2021 then one can construct a new model M\u2032 based on the same domain D as M by taking:\n\u2022 AM\u2032k = AMk , for all concept names Ak; \u2022 EqRM \u2032 = EqR M, for all R \u2208 role\u00b1(K) and q \u2208 QRT ; \u2022 (Raiaj)M \u2032 is true iff R(ai, aj) \u2208 A;\n\u2022 aM\u2032i = aMi , for all ai \u2208 ob(A);\n\u2022 drM\u2032 = drM, for all R \u2208 role\u00b1(K).\nWe claim that M\u2032 |= K\u2020. Indeed, EqRM \u2032 = EqR M, for every R \u2208 role\u00b1(K) and q \u2208 QRT . It follows then that M\u2032 |= \u2200x T \u2217(x) and M\u2032 |= \u2200x \u03b5R(x). By definition, M\u2032 |= A\u2020 1 , M\u2032 |= A\u20202\nand M\u2032 |= \u2200x \u03b4R(x). It remains to show that M\u2032 |= R\u2020. Suppose M\u2032 |= \u2227q i=1Raaji , that is R(a, aji) \u2208 A, for distinct aj1 , . . . , ajq , and q \u2208 QRT . Clearly, we have q \u2264 qR,a and M |= EqR(a) and thus M\u2032 |= EqR(a). q\nAs an immediate consequence of Corollary 5.5, the facts that the translation \u00b7\u2021 can be done in LogSpace, that the satisfiability problem for QL1-formulas is NP-complete and that DL-Litebool contains all the Booleans\u2014and so can encode full propositional logic\u2014we obtain the following result:\nTheorem 5.6 Satisfiability of DL-LiteNbool, DL-Lite F bool and DL-Litebool knowledge bases is NP-complete for combined complexity.\nObserve now that if K is a DL-LiteNkrom KB then K\u2021 is in the Krom fragment of QL1.\nTheorem 5.7 Satisfiability of DL-LiteN\u03b1 , DL-Lite F \u03b1 and DL-Lite\u03b1 knowledge bases, where \u03b1 \u2208 {core, krom}, is NLogSpace-complete for combined complexity.\nProof As the satisfiability problem for Krom formulas with the prefix of the form \u2200x (as in K\u2021) is NLogSpace-complete (see, e.g., Bo\u0308rger et al., 1997, Exercise 8.3.7) and \u00b7\u2021 is a LogSpace reduction, satisfiability is in NLogSpace for all the logics mentioned in the theorem. As for the lower bound, it suffices to recall that the NLogSpace-hardness for satisfiability of propositional Krom formulas is proved by reduction of the directed graph reachability problem using only \u2018core\u2019 propositional formulas (Bo\u0308rger et al., 1997), and so satisfiability in all of the above logics is NLogSpace-hard. q\nIf K is a DL-LiteNhorn KB then K\u2021 belongs to the universal Horn fragment of QL1.\nTheorem 5.8 Satisfiability of DL-LiteNhorn, DL-Lite F horn and DL-Litehorn KBs is P-complete for combined complexity.\nProof As QL1 contains no function symbols and K\u2021 is universal, satisfiability of K\u2021 is LogSpace-reducible to satisfiability of a set of propositional Horn formulas, namely, the formulas that are obtained from K\u2021 by replacing x with each of the constants occurring in K\u2021. It remains to recall that the satisfiability problem for propositional Horn formulas is P-complete (see, e.g., Papadimitriou, 1994), which gives the required upper bound for DL-LiteNhorn and lower bound for DL-Litehorn. q\n5.2 DL-LiteHFcore is ExpTime-hard Unfortunately, the translation \u00b7\u2021 constructed in the previous section cannot be extended to logics of the form DL-LiteHN\u03b1 with both number restrictions and role inclusions. In this section we show that the satisfiability problem for DL-LiteHFcore KBs is ExpTime-hard, which matches the upper bound for satisfiability of DL-LiteHNbool KBs even under binary coding of natural numbers (Tobies, 2001).\nNote first that, although intersection is not allowed on the left-hand side of DL-LiteHFcore concept inclusions, in certain cases (when the right-hand side is consistent) we can \u2018simulate\u2019 it by using role inclusions and functionality constraints. Suppose that a knowledge base K contains a concept inclusion of the form C1 u C2 v C. Define a new KB K\u2032 by replacing this axiom in K with the following set of new axioms, where R1, R2, R3, R12, R23 are fresh role names:\nC1 v \u2203R1 C2 v \u2203R2, (16) R1 v R12, R2 v R12, (17)\n\u2265 2R12 v \u22a5, (18) \u2203R\u22121 v \u2203R \u2212 3 , (19)\n\u2203R3 v C, (20) R3 v R23, R2 v R23, (21) \u2265 2R\u221223 v \u22a5. (22)\nLemma 5.9 (i) If I |= K\u2032 then I |= K, for every interpretation I. (ii) If I |= K and CI 6= \u2205 then there is a model I \u2032 of K\u2032 which has the same domain as I and agrees with it on every symbol from K.\nProof (i) Suppose that I |= K\u2032 and x \u2208 CI1 \u2229 CI2 . By (16), there is y with (x, y) \u2208 RI1 , and so y \u2208 (\u2203R\u22121 )I , and there is z with (x, z) \u2208 RI2 . By (17), {(x, y), (x, z)} \u2286 RI12, whence y = z in view of (18). By (19), y \u2208 (\u2203R\u22123 )I and hence there is u with (u, y) \u2208 RI3 and u \u2208 (\u2203R3)I . By (20), u \u2208 CI . By (21), (u, y) \u2208 RI23 and (x, y) \u2208 RI23. Finally, it follows from (22) that u = x, and so x \u2208 CI . Thus, I |= K.\n(ii) Take some point c \u2208 CI and define an extension I \u2032 of I to the new role names by setting:\n\u2022 RI\u20321 = {(x, x) | x \u2208 CI1 }, \u2022 RI\u20322 = {(x, x) | x \u2208 CI2 }, \u2022 RI\u20323 = {(x, x) | x \u2208 (C1 u C2)I} \u222a {(c, x) | x \u2208 (C1 u \u00acC2)I}, \u2022 RI\u203212 = RI \u2032 1 \u222aRI \u2032 2 and R I\u2032 23 = R I\u2032 2 \u222aRI \u2032 3 .\nIt is readily seen that I \u2032 satisfies all the axioms (16)\u2013(22), and so I \u2032 |= K\u2032. q\nWe are now in a position to prove the following:\nTheorem 5.10 Satisfiability of DL-LiteHFcore KBs is ExpTime-hard for combined complexity (with or without the UNA).\nProof We will prove this theorem in two steps. First we consider the logic DL-LiteHFhorn and show how to encode the behavior of polynomial-space-bounded alternating Turing machines (ATMs, for short) by means of DL-LiteHFhorn KBs. As APSpace = ExpTime, where APSpace is the class of problems recognized by polynomial-space-bounded ATMs (see, e.g., Kozen, 2006), this will establish ExpTime-hardness of satisfiability for DL-LiteHFhorn. Then, using Lemma 5.9, we will show how to get rid of conjunctions on the left-hand side of the concept inclusions involved in this encoding of ATMs and thus establish ExpTime-hardness of DL-LiteHFcore.\nWithout loss of generality, we can consider only ATMs M with binary computational trees. This means that, for every non-halting state q and every symbol a from the tape alphabet, M has precisely two instructions of the form\n(q, a) ;0M (q \u2032, a\u2032, d\u2032) and (q, a) ;1M (q \u2032\u2032, a\u2032\u2032, d\u2032\u2032), (23)\nwhere d\u2032, d\u2032\u2032 \u2208 {\u2192,\u2190} and \u2192 (resp., \u2190) means \u2018move the head right (resp., left) one cell\u2019. We remind the reader that each non-halting state ofM is either an and-state or an or-state.\nGiven such an ATMM, a polynomial function p(n) such that every run ofM on every input of length n does not use more than p(n) tape cells, and an input word ~a = a1, . . . , an, we construct a DL-LiteHFhorn knowledge base KM,~a with the following properties: (i) the size of KM,~a is polynomial in the size of M, ~a, and (ii) M accepts ~a iff KM,~a is not satisfiable. Denote by Q the set of states and by \u03a3 the tape alphabet of M.\nTo encode the instructions of M, we need the following roles:\n\u2022 Sq, S0q , S1q , for each q \u2208 Q: informally, x \u2208 (\u2203S\u2212q )I , for some interpretation I, means that x represents a configuration of M with the state q, and x \u2208 (\u2203Skq )I means that the next state, according to the transition ;kM, is q, where k \u2208 {0, 1};\n\u2022 Hi, H0i , H1i , for each i \u2264 p(n): x \u2208 (\u2203H \u2212 i ) I means that x represents a configuration of\nM where the head scans the ith cell, and x \u2208 (\u2203Hki )I that, according to the transition ;kM, k \u2208 {0, 1}, in the next configuration the head scans the ith cell; \u2022 Cia, C0ia, C1ia, for each i \u2264 p(n) and each a \u2208 \u03a3: x \u2208 (\u2203C \u2212 ia) I means that x represents\na configuration of M where the ith cell contains a, and x \u2208 (\u2203Ckia)I that, according to ;kM, k \u2208 {0, 1}, in the next configuration the ith cell contains a.\nThis intended meaning can be encoded using the following concept inclusions: for every instruction (q, a) ;kM (q \u2032, a\u2032,\u2192) of M and every i < p(n),\n\u2203S\u2212q u \u2203H\u2212i u \u2203C \u2212 ia v \u2203H k i+1 u \u2203Skq\u2032 u \u2203Ckia\u2032 , (24)\nand for every instruction (q, a) ;kM (q \u2032, a\u2032,\u2190) of M and every i, 1 < i \u2264 p(n),\n\u2203S\u2212q u \u2203H\u2212i u \u2203C \u2212 ia v \u2203H k i\u22121 u \u2203Skq\u2032 u \u2203Ckia\u2032 . (25)\nTo preserve the symbols on the tape that are not in the active cell, we use the following concept inclusions, for k \u2208 {0, 1}, i, j \u2264 p(n) with j 6= i, and a \u2208 \u03a3:\n\u2203H\u2212j u \u2203C \u2212 ia v \u2203C k ia. (26)\nTo \u2018synchronize\u2019 our roles, we need two more (functional) roles Tk and a number of role inclusions to be added to the TBox: for all k \u2208 {0, 1}, i \u2264 p(n), q \u2208 Q, and a \u2208 \u03a3,\nCkia v Cia, Hki v Hi, Skq v Sq, (27) Ckia v Tk, Hki v Tk, Skq v Tk, (28) \u2265 2Tk v \u22a5. (29)\nIt remains to encode the acceptance conditions forM on ~a. This can be done with the help of the role names Yk, for k \u2208 {0, 1}, and the concept name A:\n\u2203S\u2212q v A, q an accepting state, (30) Yk v Tk, (31) \u2265 2T\u2212k v \u22a5, (32) \u2203T\u2212k uA v \u2203Y \u2212 k , (33) \u2203S\u2212q u \u2203Yk v A, q an or-state, (34) \u2203S\u2212q u \u2203Y0 u \u2203Y1 v A, q an and-state. (35)\nThe TBox T of the DL-LiteHFhorn knowledge base KM,~a we are constructing consists of the axioms (24)\u2013(35) together with the auxiliary axiom\nA uD v \u22a5, (36)\nwhere D is a fresh concept name. The ABox A of KM,~a is comprised of the following assertions, for some object names s and u:\nSq0(u, s), q0 the initial state, (37) H1(u, s), (38) Ciai(u, s), i \u2264 p(n), ai the ith symbol on the input tape, (39) D(s). (40)\nClearly, KM,~a = (T ,A) is a DL-LiteHFhorn KB and its size is polynomial in the size of M, ~a.\nLemma 5.11 The ATM M accepts ~a iff the KB KM,~a is not satisfiable.\nProof (\u21d2) Suppose that M accepts ~a but I |= KM,~a for some interpretation I. Then we can reconstruct the full computation tree for M on ~a by induction in the following way.\nLet the root of the tree be the point sI . By (37)\u2013(39), s represents the initial configuration of M on ~a in accordance with the intended meaning of the roles Sq0 , H1 and Ciai explained above (it does not matter if, for instance, we also have sI \u2208 (\u2203H\u22125 )I).\nAssume now that we have already found a point x \u2208 \u2206I representing some configuration\nc = b1, . . . , bi\u22121, (q, bi), bi+1, . . . , bp(n), (41)\nwhere q is the current non-halting state and the head scans the ith cell containing bi. This means that we have\nx \u2208 (\u2203S\u2212q )I \u2229 (\u2203H\u2212i ) I and x \u2208 (\u2203C\u2212jbj ) I , for all j \u2264 p(n).\nAssume also that M contains two instructions of the form (23) for (q, bi), that is q is nonhalting. If we have (q, bi) ; k M (q\n\u2032, b\u2032,\u2192), for k = 0 or 1, then, by (24) and (26), there are points ys, yh and yj , for j \u2264 p(n), in \u2206I such that\n(x, ys) \u2208 (Skq\u2032)I , (x, yh) \u2208 (Hki+1)I , (x, yi) \u2208 (Ckib\u2032)I , (x, yj) \u2208 (Ckjbj ) I , for j 6= i.\nBy (28)\u2013(29), S0q\u2032 , H 0 i+1, C 0 ib\u2032i and the C0jbj , j 6= i, are all sub-roles of the functional role Tk, and so all the points ys, yh and yj coincide; we denote this point by xk. By (27), we then have:\n(x, xk) \u2208 T Ik , xk \u2208 (\u2203S\u2212q\u2032 ) I \u2229 (\u2203H\u2212i+1) I \u2229 (\u2203C\u2212ib\u2032) I and xk \u2208 (\u2203C\u2212jbj ) I , for j 6= i.\nSimilarly, if we have (q, bi) ; k M (q \u2032\u2032, b\u2032\u2032,\u2190), for k = 0 or 1, then, by (25) and (26), there is a point xk \u2208 \u2206I such that\n(x, xk) \u2208 T Ik , xk \u2208 (\u2203S\u2212q\u2032\u2032) I \u2229 (\u2203H\u2212i\u22121) I \u2229 (\u2203C\u2212ib\u2032\u2032) I and xk \u2208 (\u2203C\u2212jbj ) I , for j 6= i.\nThus, for k = 0, 1, xk is a Tk-successor of x representing the configuration ck of M after it has executed (q, bi) ; k M (q\n\u2032\u2032, b\u2032\u2032, d) in c; in this case ck is called the k-successor of c. According to (30), every point in the constructed computation tree for M on ~a representing a configuration with an accepting state is in AI . Suppose now, inductively, that x represents some configuration c of the form (41), q is an or-state, xk represents the ksuccessor of c and (x, xk) \u2208 T Ik , for k = 0, 1, and one of the xk, say x0, is in AI . In view of (33), we have x0 \u2208 (\u2203Y \u22120 )I . As T \u2212 0 is functional by (32) and Y0 is a sub-role of T0 by (31), (x, x0) \u2208 Y I0 , and so, by (34), x \u2208 AI . The case of x being an and-state is considered analogously with the help of (35).\nSince M accepts ~a, we then conclude that sI \u2208 AI , contrary to (36) and (40). (\u21d0) Conversely, suppose now thatM does not accept ~a. Consider the full computation tree (\u2206, <0 \u222a <1) with nodes labeled with configurations ofM in such a way that the root is labeled with the initial configuration\n(q0, a1), a2, . . . , an, an+1, . . . , ap(n),\n(where the ai, for n+1 \u2264 i \u2264 p(n), are all \u2018blank\u2019), and if some node x in the tree is labeled with a non-halting c of the form (41) andM contains two instructions of the form (23), then x has one <0-successor labeled with the 0-successor of c and one <1-successor labeled with the 1-successor of c. (It should be emphasized that (\u2206, <0 \u222a <1) is a tree, where different nodes may be labeled with the same configuration.)\nWe use this tree to construct an interpretation I = (\u2206I , \u00b7I) as follows:\n\u2022 \u2206I = \u2206 \u222a {u}, for some u /\u2208 \u2206;\n\u2022 sI is the root of \u2206 and uI = u;\n\u2022 DI = {sI};\n\u2022 (x, xk) \u2208 (Skq\u2032)I , (x, xk) \u2208 (Hki+1)I , (x, xk) \u2208 (Ckib\u2032)I , and (x, xk) \u2208 (Ckjbj ) I , for j 6= i,\niff x is labeled with c of the form (41), (q, bi) ; k M (q \u2032, b\u2032,\u2192) and x <k xk, for k = 0, 1;\n\u2022 (x, xk) \u2208 (Skq\u2032)I , (x, xk) \u2208 (Hki\u22121)I , (x, xk) \u2208 (Ckib\u2032)I , and (x, xk) \u2208 (Ckjbj ) I , for j 6= i,\niff x is labeled with c of the form (41), (q, bi) ; k M (q \u2032, b\u2032,\u2190) and x <k xk, for k = 0, 1;\n\u2022 (u, sI) \u2208 (Sq0)I , (u, sI) \u2208 (H1)I , (u, sI) \u2208 (Ciai)I , i \u2264 p(n) and over \u2206 the extensions for the roles Sq, Hi and Cia are defined according to (27);\n\u2022 T Ik = <k, for k = 0, 1;\n\u2022 Y I0 , Y I1 and AI are defined inductively:\n\u2013 Induction basis: if x \u2208 \u2206 is labeled with an accepting configuration, then x \u2208 AI . \u2013 Induction step: (i) if x <k xk, for k = 0, 1, and xk \u2208 AI , then (x, xk) \u2208 Y Ik ; (ii) if x is an or-state (respectively, and-state) and (x, xk) \u2208 Y Ik for some (respectively, all) k \u2208 {0, 1}, then x \u2208 AI .\nIt follows from the given definition that I |= KM,~a. Details are left to the reader. q\nThe lemma we have just proved establishes that satisfiability of DL-LiteHFhorn KBs is ExpTime-hard. Our next aim is to show how one can eliminate the conjunctions in the left-hand side of the TBox axioms (24)\u2013(26), (33)\u2013(35). We will do this with the help of Lemma 5.9. Before applying it, we check first that if KM,~a is satisfiable then it is satisfiable in an interpretation I such that I |= KM,~a and CI 6= \u2205, for every C occurring in an axiom of the form C1 u C2 v C in K. Consider, for instance, axiom (24) and assume that I |= KM,~a, but (\u2203Skq\u2032)I = \u2205. Then, we can construct a new interpretation I \u2032 by adding two new points, say x and y, to the domain of I, and setting (x, y) \u2208 (Skq\u2032)I \u2032 , (x, y) \u2208 (Sq\u2032)I \u2032 , (x, y) \u2208 (Tk)I \u2032 . Furthermore, if q\u2032 is an accepting state, we also set y \u2208 AI\u2032 and (x, y) \u2208 Y I\u2032k . One can readily check that I \u2032 is still a model for KM,~a. The other conjuncts of (24) and the remaining axioms are considered analogously.\nAfter an application of Lemma 5.9 to an axiom of the form C1uC2 v C with C2 = C \u20322uC \u2032\u20322 we obtain, by (16)\u2013(22), a new KB K\u2032 with the concept inclusion of the form C \u20322uC \u2032\u20322 v \u2203R1, which also requires treatment by means of the same lemma. To be able to do this, we again\nhave to check that K\u2032 is satisfiable in some interpretation I \u2032\u2032 with (\u2203R1)I \u2032\u2032 6= \u2205. Suppose that I \u2032 |= K\u2032 and (\u2203R1)I \u2032\n= \u2205. Then we can construct I \u2032\u2032 by adding two new points, say x and y, to the domain of I \u2032, adding x to CI\u2032 and (x, y) to each of RI\u20321 , RI \u2032 12, R I\u2032 23 and R I\u2032 3 . It is readily seen that I \u2032\u2032 |= K\u2032. It is to be noted that the proof above does not depend on whether the UNA is adopted or not. q\nAs an immediate consequence we obtain:\nCorollary 5.12 Satisfiability of DL-LiteHF\u03b1 and DL-Lite HN \u03b1 KBs with or without the UNA is ExpTime-complete for combined complexity, where \u03b1 \u2208 {core, krom, horn, bool}."}, {"heading": "5.3 Reconciling Number Restrictions and Role Inclusions", "text": "As we have seen in the previous section, the unrestricted interaction between number restrictions and role inclusions allowed in the logics of the form DL-LiteHN\u03b1 results in high combined complexity of satisfiability. In Section 6.2, we shall see that the data complexity of instance checking and query answering also becomes unacceptably high for these logics. A quick look at the proof of Theorem 5.10 reveals the \u2018culprit:\u2019 the interplay between role inclusions R1 v R, R2 v R and functionality constraints \u22652R v \u22a5, which effectively mean that if R1(x, y) and R2(x, z) then y = z. In this section we study the case when such an interplay is not allowed.\nRecall from Section 2.1 that DL-Lite (HN ) \u03b1 TBoxes T , for \u03b1 \u2208 {core, krom, horn, bool},\nsatisfy the following conditions:\n(A1) T may contain only positive occurrences of qualified number restrictions \u2265 q R.C, where C is a conjunction of concepts allowed on the right-hand side of \u03b1-concept inclusions;\n(A2) if \u2265 q R.C occurs in T , then T does not contain negative occurrences of number restrictions \u2265 q\u2032R or \u2265 q\u2032 inv(R) with q\u2032 \u2265 2;\n(A3) if R has a proper sub-role in T , then T does not contain negative occurrences of \u2265 q R or \u2265 q inv(R) with q \u2265 2.\nDL-Lite (HN ) \u03b1 TBoxes can contain role constraints such as Dis(R1, R2), Asym(Pk), Sym(Pk), Irr(Pk), and Ref(Pk). Our main aim in this section is to prove the following theorem and develop the technical tools we need to investigate the data complexity of reasoning with DL-Lite (HN ) bool and its sublogics later on in the paper.\nTheorem 5.13 For combined complexity, (i) satisfiability of DL-Lite (HN ) bool KBs is NPcomplete; (ii) satisfiability of DL-Lite (HN ) horn KBs is P-complete; and (iii) satisfiability of DL-Lite (HN ) krom and DL-Lite (HN ) core KBs is NLogSpace-complete.\nLet us consider first the sub-language of DL-Lite (HN ) bool without qualified number restrictions and the role constraints mentioned above; we denote it by DL-Lite (HN )\u2212 bool . This sublanguage is required for purely technical reasons. In Section 7, we will also use DL-Lite (HN )\u2212 horn , but we do not need the core or Krom fragments.\nSuppose we are given a DL-Lite (HN )\u2212 bool KB K = (T ,A). Let Id be a distinguished role name. We will use it to simulate the identity relation required for encoding the role constraints. We assume that either K does not contain Id at all or satisfies the following conditions:\n(Id1) Id(ai, aj) \u2208 A iff i = j, for all ai, aj \u2208 ob(A),\n(Id2) { > v \u2203Id, Id\u2212 v Id } \u2286 T , and QIdT = QId \u2212 T = {1},\n(Id3) Id is only allowed in role inclusions of the form Id \u2212 v Id and Id v R.\nIn what follows, without loss of generality, we will assume that\n(Q) QRT \u2286 QR \u2032 T whenever R v\u2217T R\u2032 (for if this is not the case we can always add the missing numbers to QR \u2032 T , e.g., by introducing fictitious concept inclusions of the form \u22a5 v \u2265 q R\u2032). Now, in the same way as in Section 5.1, we define two translations \u00b7\u2020e and \u00b7\u2021e of K into the one-variable fragment QL1 of first-order logic. The former translation, \u00b7\u2020e , retains the information about the relationships between ABox objects, and we show that every model of K\u2020e can again be \u2018unraveled\u2019 into a model of K. We define \u00b7\u2020e by taking:\nK\u2020e = \u2200x [ T \u2217(x) \u2227 T R(x) \u2227 \u2227 R\u2208role\u00b1(K) ( \u03b5R(x) \u2227 \u03b4R(x) ) ] \u2227\n[ A\u20201 \u2227 A\u20202 \u2227 \u2227 R\u2208role\u00b1(K) R\u2020 \u2227 \u2227\nRvR\u2032\u2208T ai,aj\u2208ob(A)\n( Raiaj \u2192 R\u2032aiaj )] ,\nwhere T \u2217(x), A\u20201 , A\u20202 , \u03b5R(x), \u03b4R(x) and R\u2020 are as in (1)\u2013(6) and\nT R(x) = \u2227\nRvR\u2032\u2208T or inv(R)vinv(R\u2032)\u2208T\n\u2227 q\u2208QRT ( EqR(x)\u2192 EqR\u2032(x) ) . (42)\nThe following lemma is an analogue of Theorem 5.2:\nLemma 5.14 A DL-Lite (HN )\u2212 bool KB K is satisfiable iff the QL 1-sentence K\u2020e is satisfiable.\nProof The proof basically follows the lines of the proof of Theorem 5.2 with some modifications. We present a modified unraveling construction here; the converse direction is exactly the same as in Theorem 5.2.\nIn each equivalence class [Ri] = {Rj | Ri \u2261\u2217T Rj} we select a single role (a representative of that class) and denote it by rep\u2217T (Ri). When extending P m k to P m+1 k , we use the following modified \u2018curing\u2019 rules:\n(\u039bmk ) If Pk 6= rep\u2217T (Pk) do nothing: the defects are cured for rep\u2217T (Pk). Otherwise, let w \u2208 \u039bmk , q = r(Pk, cp(w)) \u2212 rm(Pk, w) and d = cp(w). We have M |= Eq\u2032Pk[d] for some q\u2032 \u2265 q > 0. Then, by (5), M |= E1Pk[d] and, by (4), M |= E1P\u2212k [dp \u2212 k ]. In this\ncase we take q fresh copies w\u20321, . . . , w \u2032 q of dp \u2212 k (and set cp(w \u2032 i) = dp \u2212 k , for 1 \u2264 i \u2264 q), add them to Wm+1 and\n\u2022 add the pairs (w,w\u2032i), 1 \u2264 i \u2264 q, to each P m+1 j with Pk v\u2217T Pj (including\nPj = Pk);\n\u2022 add the pairs (w\u2032i, w), 1 \u2264 i \u2264 q, to each P m+1 j with P \u2212 k v \u2217 T Pj ; \u2022 if Id occurs in K, add the pairs (w\u2032i, w\u2032i), 1 \u2264 i \u2264 q, to each P m+1 j with Id v\u2217T Pj .\n(\u039bm\u2212k ) This rule is the mirror image of (\u039b m k ): Pk and dp \u2212 k are replaced everywhere with\nP\u2212k and dpk, respectively; see the proof of Theorem 5.2.\nIt follows from this definition that Id never has any defects and is interpreted in the resulting interpretation I by the identity relation IdI = { (w,w) | w \u2208 \u2206I } ; the interpretations of roles respect all the role inclusions, i.e., RI1 \u2286 RI2 whenever R1 v\u2217T R2. It remains to show that the constructed interpretation I is indeed a model of K. First, (11) trivially holds for Id as both the required and actual ranks are equal to 1. Second, (11) holds for R such that R 6= Id and R has no proper sub-roles: the proof is exactly the same as in Theorem 5.2, taking into account that we cure defects only for a single role in each equivalence class and that, by (42), for all R\u2032 \u2208 [R], we have r(R\u2032, cp(w)) = r(R, cp(w)) and r(inv(R), cp(w)) = r(inv(R\u2032), cp(w)). It follows that (13) holds for Id and any role R without proper sub-roles. However, (13) does not necessarily hold for roles R with proper sub-roles: as follows from the construction, the actual rank may be greater than the required rank, in which case we only have the following:\nif M |= EqR[cp(w)] then w \u2208 (\u2265 q R)I .\nHowever, this is enough for our purposes. By induction on the structure of concepts and using (A3), one can show that I |= C1 v C2 whenever M |= \u2200x (C\u22171 (x)\u2192 C\u22172 (x)), for each concept inclusion C1 v C2 \u2208 T , and therefore, I |= T . We also have I |= A (see the proof of Theorem 5.2) and thus I |= K. q\nRemark 5.15 It follows from the proofs of Theorem 5.2 and Lemma 5.14 that, for the DL-Lite (HN )\u2212 bool KB K = (T ,A), every model M of K\n\u2021e induces a model IM of K with the following properties:\n(ABox) For all ai, aj \u2208 ob(A), we have (aIMi , a IM j ) \u2208 RIM iff R(ai, aj) \u2208 Cl e T (A), where\nCleT (A) = { R2(ai, aj) | R1(ai, aj) \u2208 A, R1 v\u2217T R2 } .\n(forest) The object names a \u2208 ob(A) induce a partitioning of \u2206IM into disjoint labeled trees Ta = (Ta, Ea, `a) with nodes Ta, edges Ea, root a\nIM , and a labeling function `a : Ea \u2192 role\u00b1(K) \\ {Id, Id\u2212}.\n(copy) There is a function cp : \u2206IM \u2192 ob(A) \u222a dr(K) such that\n\u2022 cp(aIM) = a for a \u2208 ob(A), and \u2022 cp(w) = dr if, for some a and w\u2032 \u2208 Ta, (w\u2032, w) \u2208 Ea and `a(w\u2032, w) = inv(R).\n(iso) For each R \u2208 role\u00b1(K), all labeled subtrees generated by elements w \u2208 \u2206IM with cp(w) = dr are isomorphic.\n(concept) w \u2208 BIM iff M |= B\u2217[cp(w)], for each basic concept B in K and each w \u2208 \u2206IM .\n(role) IdIM = { (w,w) \u2223\u2223 w \u2208 \u2206IM} and, for every other role name Pk,\nP IMk = { (aIMi , a IM j ) | R(ai, aj) \u2208 A, R v \u2217 T Pk } \u222a { (w,w) | Id v\u2217T Pk } \u222a\u22c3\na\u2208ob(A)\n{ (w,w\u2032) \u2208 Ea | `a(w,w\u2032) = R, R v\u2217T Pk } .\nSuch a model will be called an untangled model of K (the untangled model of K induced by M, to be more precise).\nThe translation \u00b7\u2020e generalizes \u00b7\u2020 and thus suffers from the same exponential blowup. So we define an optimized translation, \u00b7\u2021e , which is linear in the size of K, by taking:\nK\u2021e = \u2200x [ T \u2217(x) \u2227 T R(x) \u2227 \u2227 R\u2208role\u00b1(K) ( \u03b5R(x) \u2227 \u03b4R(x) ) ] \u2227 A\u20201 \u2227 A\u20212e ,\nwhere T \u2217(x), T R(x), \u03b5R(x), \u03b4R(x) and A\u2020 1\nare defined by (1), (42), (4), (5) and (2), respectively, and\nA\u20212e = \u2227\na\u2208ob(A)\n\u2227 R\u2208role\u00b1(K)\n\u2203a\u2032\u2208ob(A) R(a,a\u2032)\u2208CleT (A)\nEqeR,aR(a) \u2227 \u2227\n\u00acPk(ai,aj)\u2208A\n(\u00acPk(ai, aj))\u22a5e , (43)\nwhere qeR,a is the maximum number in Q R T such that there are q e R,a many distinct ai with R(a, ai) \u2208 CleT (A) (here we use the UNA) and (\u00acPk(ai, aj))\u22a5e = \u22a5 if Pk(ai, aj) \u2208 CleT (A) and > otherwise; cf. (15). We note again that if QRT = {1}, for all roles R \u2208 role\n\u00b1(K), then the translation does not depend on whether the UNA is adopted or not.\nThe following corollary is proved similarly to Corollary 5.5:\nCorollary 5.16 A DL-Lite (HN )\u2212 bool KB K is satisfiable iff the QL 1-sentence K\u2021e is satisfiable.\nIt should be clear that the translation \u00b7\u2021e can be computed in NLogSpace (for combined complexity). Indeed, this is readily seen for T \u2217(x), T R(x), \u03b5R(x), \u03b4R(x), and A\u2020 1 . In order to compute A\u20212e , we need to be able to check whether R(ai, aj) \u2208 CleT (A): this test can be performed by a non-deterministic algorithm using logarithmic space in |role\u00b1(K)| (it is basically the same as the standard directed graph reachability problem, which is NLogSpace-complete; see, e.g., Kozen, 2006); it can be done using N \u00b7 log |role\u00b1(K)| + 2 log |ob(A)| cells on the work tape, where N is a constant (in fact, N = 3 is enough: one\nhas to store R, the current role R\u2032 and the path length for the graph reachability subroutine, which is also bounded by log |role\u00b1(K)|). Therefore, the translation \u00b7\u2021e can be computed by an NLogSpace transducer.\nNow we show how satisfiability of DL-Lite (HN ) bool KBs can be easily reduced to satisfiability\nof DL-Lite (HN )\u2212 bool KBs. First, we assume that DL-Lite (HN ) bool KBs contain no role symmetry and asymmetry constraints because Asym(Pk) can be equivalently replaced with Dis(Pk, P \u2212 k ) and Sym(Pk) with P \u2212 k v Pk (it should be noted that the introduction of P \u2212 k v Pk in the TBox does not violate (A3)). The following lemma allows us to get rid of qualified number restrictions as well as role disjointness, reflexivity and irreflexivity constraints:\nLemma 5.17 For every DL-Lite (HN ) bool KB K \u2032 = (T \u2032,A\u2032), one can construct a DL-Lite(HN ) \u2212 bool KB K = (T ,A) such that\n\u2022 every untangled model IM of K is a model of K\u2032, provided that\nthere are no R1(ai, aj), R2(ai, aj) \u2208 CleT (A) with Dis(R1, R2) \u2208 T \u2032, there is no R(ai, ai) \u2208 CleT (A) with Irr(R) \u2208 T \u2032;\n(44)\n\u2022 every model I \u2032 of K\u2032 gives rise to a model I of K based on the same domain as I \u2032 and such that I agrees with I \u2032 on all symbols from K\u2032.\nIf K\u2032 is a DL-Lite(HN )horn KB then K is a DL-Lite (HN )\u2212 horn KB. Proof First, for every pair R, C such that \u2265 q R.C occurs in T \u2032, we introduce a fresh role name RC . Then we replace each (positive) occurrence of \u2265 q R.C in T \u2032 with \u2265 q RC and add the following concept and role inclusions to the TBox:\n\u2203R\u2212C v C and RC v R.\nWe repeat this procedure until all the occurrences of qualified number restrictions are eliminated. Denote by T \u2032\u2032 the resulting TBox. Observe that (A1) and (A2) ensure that T \u2032\u2032 satisfies (A3). We also notice that C occurs only on the right-hand side of those extra axioms and thus T \u2032\u2032 belongs to the same fragment as T \u2032. It should be clear that, since the \u2265 q R.C occur only positively, every model of T \u2032\u2032 is a model of T \u2032. Conversely, for every model I \u2032 of T \u2032, there is a model I \u2032\u2032 of T \u2032\u2032 based on the same domain such that I \u2032\u2032 coincides with I \u2032 on all symbols in T \u2032 and RI\u2032\u2032C = {(w, u) \u2208 RI\n\u2032 | u \u2208 CI\u2032}, for each new role RC . So, without loss of generality we may assume that T \u2032 = T \u2032\u2032.\nLet T \u2032 = T \u20320 \u222a T \u2032ref \u222a T \u2032irref \u222a T \u2032disj,\nwhere T \u2032ref, T \u2032irref and T \u2032disj are the sets of role reflexivity, irreflexivity and disjointness constraints in T \u2032 and T \u20320 is the remaining DL-Lite (HN )\u2212 bool TBox. Let\nT \u20321 = { > v \u2203Id, Id\u2212 v Id } \u222a { Id v P | Ref(P ) \u2208 T \u2032ref } ,\nA\u20321 = { Id(ai, ai) | ai \u2208 ob(A\u2032) } .\nWe construct K by modifying the DL-Lite(HN ) \u2212\nbool KB K0 = (T \u2032 0 \u222a T \u20321 ,A\u2032 \u222a A\u20321) in two steps: Step 1. For every reflexivity constraint Ref(P ) \u2208 T \u2032ref, take a fresh role name SP and\n\u2022 add a new role inclusion SP v P to the TBox;\n\u2022 replace every basic concept B in T \u20320 with BSP , which is defined inductively as follows:\n\u2013 ASP = A, for each concept name A, \u2013 (\u2265 q R)SP = \u2265 q R, for each role R /\u2208 {P, P\u2212}, \u2013 (\u2265 q P )SP = \u2265 (q \u2212 1)SP and (\u2265 q P\u2212)SP = \u2265 (q \u2212 1)S\u2212P , for q \u2265 2, \u2013 (\u2203P )SP = > and (\u2203P\u2212)SP = >;\n\u2022 replace R(ai, aj) \u2208 A\u2032 such that R \u2261\u2217T \u2032 P with SP (ai, aj) whenever i 6= j.\nIntuitively, we split the role P into its irreflexive part SP and Id. Note that if P has a reflexive proper sub-role then, by (A3), there are no restrictions on the maximal number of P -successors and P -predecessors, and therefore on SP if Ref(P ) \u2208 T \u2032. Let (T1,A) be the resulting DL-Lite\n(HN )\u2212 bool KB. Clearly, (T1,A) satisfies (Id1)\u2013(Id3). Observe that\nCleT1(A) role(K\u2032) = Cl e T \u20320\u222aT \u20321 (A\u2032), (45)\nwhere role(K\u2032) means the restriction to the role names in K\u2032. Let IM be an untangled model of (T1,A). We show that IM |= T \u20320 . Consider a role P with Ref(P ) \u2208 T \u2032. Notice that SP has no proper sub-roles in T1 and IdIM is disjoint with SIMP . Thus, S IM P \u222a Id IM \u2286 P IM and\n(*) (BSP )IM \u2286 BIM , for B = \u2265 q R with q \u2265 2, whenever Ref(P ) \u2208 T \u2032, R \u2208 {P, P\u2212} and P has a proper sub-role in T \u2032.\nIf P has no proper sub-roles in T \u2032 (i.e., no proper sub-roles in T1 different from SP and Id) then we have SIMP \u222a Id\nIM = P IM . So, for all basic concepts B in T \u20320 not covered by (*), we have BIM = (BSP )IM . It follows from (A3) that IM |= T \u20320 . Step 2. Next we take into account the set D = T \u2032disj \u222a {Dis(Pk, Id) | Irr(Pk) \u2208 T \u2032irref} of disjointness constraints by modifying the KB (T1,A) constructed at the previous step. Observe that \u2203R1 v \u22a5 is a logical consequence of any T \u222a{Dis(R1, R2)} whenever R1 v\u2217T R2. Let T = T1 \u222a T2, where T2 is defined by taking\nT2 = { \u2203R1 v \u22a5 \u2223\u2223 R1 v\u2217T1 R2 and either Dis(R1, R2) \u2208 D or Dis(R2, R1) \u2208 D}. By (role), for any untangled model IM of (T ,A) and R1, R2 \u2208 role\u00b1(K), IM |= Dis(R1, R2) if there are no R1(ai, aj), R2(ai, aj) \u2208 CleT1(A), which, by (45), means that there are no R1(ai, aj), R2(ai, aj) \u2208 CleT \u20320\u222aT \u20321 (A\n\u2032). So, if (44) holds then every untangled model IM of (T ,A) is also a model of T1 \u222a D and thus, IM |= T \u2032disj. As Id\nIM is the identity relation, we have IM |= T \u2032ref \u222a T \u2032irref. By (45), IM |= A\u2032 and as we have shown above, IM |= T \u20320 . Therefore, IM |= K\u2032.\nConversely, suppose I \u2032 is a model of K\u2032. Let I be an interpretation such that IdI is the identity relation, SIP = P\nI\u2032 \\ IdI\u2032 , for all P with Ref(P ) \u2208 T \u2032, and AI = AI\u2032 , P I = P I \u2032 and aI = aI \u2032 , for all concept, role and object names A, P and a in K\u2032. Clearly, I |= (T \u20320 \u222a T \u20321 ,A\u2032 \u222a A\u20321). By the definition of the SP , I |= T1 and, since I |= D, we obtain I |= T2 and thus I |= T . By (45), I |= A, whence I |= K. q\nNow, as follows from Lemma 5.17, given a DL-Lite (HN ) \u03b1 KB K\u2032, for \u03b1 \u2208 {krom, horn,\nbool}, we can compute the DL-Lite(HN ) \u2212\nbool KB K using a LogSpace transducer (which is essentially required for checking whether R \u2261\u2217T \u2032 P ). We immediately obtain Theorem 5.13 from Lemma 5.14 by observing that, for each \u03b1 \u2208 {krom, horn, bool}, K\u2021e belongs to the respective first-order fragment and that condition (44) can be checked in NLogSpace (computing CleT (A) requires directed graph accessibility checks). The result for DL-Lite (HN ) core follows from the corresponding result for DL-Lite (HN ) krom ."}, {"heading": "5.4 Role Transitivity Constraints", "text": "We now consider the languages DL-Lite (HN )+ \u03b1 , \u03b1 \u2208 {core, krom, horn, bool}, which extend DL-Lite (HN ) \u03b1 with role transitivity constraints of the form Tra(Pk). We remind the reader that a role is called simple (see, e.g., Horrocks et al., 2000) if it has no transitive sub-roles (including itself) and that only simple roles R are allowed in concepts of the form \u2265 q R, for q \u2265 2. In particular, if T contains Tra(P ) then P and P\u2212 are not simple, and so T cannot contain occurrences of concepts of the form \u2265 q P and \u2265 q P\u2212, for q \u2265 2.\nFor a DL-Lite (HN )+ \u03b1 KB K = (T ,A), define the transitive closure TraT (A) of A by\ntaking TraT (A) = A \u222a { P (ai1 , ain) | \u2203ai2 . . . ain\u22121 P (ai1 , aij+1) \u2208 A, 1 \u2264 j < n, Tra(P ) \u2208 T } .\nClearly, TraT (A) can be computed in NLogSpace: for each pair (ai, aj) of objects in ob(A), we add P (ai, aj) to TraT (A) iff there is a P -path of length < |ob(A)| between ai and aj in A (recall that the directed graph reachability problem is NLogSpace-complete).\nLemma 5.18 A DL-Lite (HN )+ \u03b1 KB (T ,A) is satisfiable iff the DL-Lite(HN )\u03b1 KB (T \u2032,A\u2032) is satisfiable, where T \u2032 results from T by removing all the transitivity axioms and\nA\u2032 = CleT (TraT (CleT (A))).\nProof Indeed, if the KB (T \u2032,A\u2032) is satisfiable then we construct a model I for it as described in the proofs of Lemmas 5.14 and 5.17 and then take the transitive closure of P I for every P with Tra(P ) \u2208 T (and update each RI with P v\u2217T R). As P and P\u2212 are simple, T contains no axioms imposing upper bounds on the number of P -successors and predecessors, and so the resulting interpretation must be a model of (T ,A). The converse direction is trivial. q\nWe note that an analogue of Remark 5.15 also holds in this case: just replace CleT (A) with CleT (TraT (Cl e T (A))) in (ABox) and take the transitive closure for each transitive subrole in (role).\nRemark 5.19 It should be noted that there are two different reasons for the reduction in Lemma 5.18 to be in NLogSpace rather than in LogSpace (as the reduction \u00b7\u2021 is). First, in order to compute CleT (A), for each pair of ai, aj , one has to find a path in the directed graph induced by the role inclusion axioms. Second, in order to compute TraT (Cl e T (A)), one has to find a path in the graph induced by the ABox A itself. So, if we are concerned with the data complexity, CleT (A) can be computed in LogSpace (in fact, in AC0, as we shall\nsee in Section 6.1) because the role inclusion graph (and hence its size) does not depend on A. The second reason, however, is more \u2018dangerous\u2019 for data complexity as we shall see in Section 6.1.\nAs a consequence of Lemma 5.18 and Theorem 5.13 we obtain the following:\nCorollary 5.20 For combined complexity, (i) satisfiability of DL-Lite (HN )+ bool KBs is NPcomplete; (ii) satisfiability of DL-Lite (HN )+ horn KBs is P-complete; and (iii) satisfiability of DL-Lite (HN )+ krom and DL-Lite (HN )+ core KBs is NLogSpace-complete.\nNote again that if the KBs do not contain number restrictions of the form \u2265q R, for q \u2265 2, (as in the extensions of the DL-LiteH\u03b1 languages) then the result does not depend on the UNA.\nRemark 5.21 It should be noted that role disjointness, symmetry, asymmetry and transitivity constraints can be added to any of the logics DL-LiteHF\u03b1 and DL-Lite HN \u03b1 , for \u03b1 \u2208 {core, krom, horn, bool}, without changing the combined complexity of their satisfiability problems (which, by Corollary 5.12, are all ExpTime-complete). Indeed, as follows from Theorem 10 of Glimm et al. (2007), KB satisfiability in the extension of SHIQ with role conjunction is in ExpTime if the length of role conjunctions is bounded by some constant (in our case, this constant is 2 because Dis(R1, R2) can be encoded by \u2203(R1 u R2).> v \u22a5; Asym(R) is dealt with similarly). We conjecture that role reflexivity and irreflexivity constraints do not change complexity either."}, {"heading": "6. Instance Checking: Data Complexity", "text": "So far we have assumed the whole KB K = (T ,A) to be the input for the satisfiability problem. According to the classification suggested by Vardi (1982), we have been considering its combined complexity. Two other types of complexity for knowledge bases are:\n\u2022 the schema (or TBox ) complexity, where only the TBox T is regarded to be the input, while the ABox A is assumed to be fixed; and\n\u2022 the data (or ABox ) complexity, where only the ABox A is regarded to be the input.\nIt is easy to see that the schema complexity of the satisfiability problem for all our logics considered above coincides with the corresponding combined complexity. In this section, we analyze the data complexity of satisfiability and instance checking.\n6.1 DL-LiteNbool, DL-Lite H bool and DL-Lite (HN ) bool are in AC 0\nIn what follows, without loss of generality we assume that all role and concept names of a given knowledge base K = (T ,A) occur in its TBox and write role(T ), role\u00b1(T ) and dr(T ) instead of role(K), role\u00b1(K) and dr(K), respectively; the set of concept names in T is denoted by con(T ). In this section we reduce satisfiability of DL-Lite(HN )bool KBs to model checking in first-order logic. To this end, we fix a signature containing two unary predicates Ak and Ak, for each concept name Ak, and two binary predicates Pk and Pk, for each role name Pk.\nConsider first the case of a DL-Lite (HN )\u2212 bool KB K. We represent the ABox A of K as a first-order model AA of the above signature. The domain of AA is ob(A) and, for all ai, aj \u2208 ob(A) and all predicates Ak, Ak, Pk and Pk in the signature,\nAA |= Ak[ai] iff Ak(ai) \u2208 A, AA |= Ak[ai] iff \u00acAk(ai) \u2208 A, AA |= Pk[ai, aj ] iff Pk(ai, aj) \u2208 A, AA |= Pk[ai, aj ] iff \u00acPk(ai, aj) \u2208 A.\nNow we construct a first-order sentence \u03d5T in the same signature such that (i) \u03d5T depends on T but does not depend on A, and (ii) AA |= \u03d5T iff K\u2021e is satisfiable.\nTo simplify presentation, we denote by ext(T ) the extension of T with the following concept inclusions:\n\u2022 \u2265 q\u2032R v \u2265 q R, for all R \u2208 role\u00b1(T ) and q, q\u2032 \u2208 QRT such that q\u2032 > q and q\u2032 > q\u2032\u2032 > q for no q\u2032\u2032 \u2208 QRT , and\n\u2022 \u2265 q R v \u2265 q R\u2032, for all q \u2208 QRT and R v R\u2032 \u2208 T or inv(R) v inv(R\u2032) \u2208 T .\nClearly, (ext(T ))\u2217(x) is equivalent (in first-order logic) to T \u2217(x)\u2227T R(x)\u2227 \u2227 R\u2208role\u00b1(T ) \u03b4R(x); see (1), (5) and (42). Let Bcon(T ) be the set of basic concepts occurring in T (i.e., concepts of the form A and \u2265 q R, for A \u2208 con(T ), R \u2208 role\u00b1(T ) and q \u2208 QRT ). To indicate which basic concepts hold or do not hold on a domain element of a first-order model of K\u2021e , we use functions \u03be : Bcon(T ) \u2192 {>,\u22a5}, which will be called types. Denote by Tp the set of all such types (there are 2|Bcon(T )| of them). For a complex concept C, we define \u03be(C) by induction: \u03be(\u00acC) = \u00ac\u03be(C) and \u03be(C1 u C2) = \u03be(C1) \u2227 \u03be(C2). The propositional variable-free formula\n\u03beT = \u2227\nC1vC2\u2208ext(T )\n( \u03be(C1)\u2192 \u03be(C2) ) ensures that the type \u03be is consistent with concept and role inclusions in T . It should be emphasized that \u03beT is built from \u22a5 and > using the Boolean connectives and therefore does not depend on a particular domain element of AA. The following formula is true if a given element x of AA is of type \u03be (see A\u2020 1 and A\u20212e ; (2) and (43), respectively):\n\u03be\u2217(x) = \u2227\nAk\u2208con(T )\n( (Ak(x)\u2192 \u03be(Ak)) \u2227 (Ak(x)\u2192 \u00ac\u03be(Ak)) ) \u2227\n\u2227 R\u2208role\u00b1(T ) \u2227 q\u2208QRT ( EqR T (x)\u2192 \u03be(\u2265 q R) ) \u2227 \u2227 Pk\u2208role(T ) \u2200x\u2200y ( P Tk (x, y) \u2227 Pk(x, y)\u2192 \u22a5 ) ,\nwhere EqR T (x) and RT (x, y), for R \u2208 role\u00b1(T ), are abbreviations defined by\nEqR T (x) = \u2203y1 . . . \u2203yq ( \u2227 1\u2264i<j\u2264q (yi 6= yj) \u2227 \u2227 1\u2264i\u2264q RT (x, yi) ) , (46)\nRT (x, y) = \u2228\nPkv\u2217T R Pk(x, y) \u2228 \u2228 P\u2212k v \u2217 T R Pk(y, x). (47)\nClearly, we have R(ai, aj) \u2208 CleT (A) iff AA |= RT [ai, aj ] and AA |= EqRT [a] iff a has at least q distinct R-successors in CleT (A) (and thus in every model of K).\nWithout loss of generality we may assume that role\u00b1(T ) = {R1, . . . , Rk} 6= \u2205. Denote by Tpk the set of k-tuples ~\u03be containing a type \u03bedri \u2208 Tp for each role Ri \u2208 role\u00b1(T ). We then set\n\u03d5T = \u2228\n~\u03be\u2208Tpk \u2200x\u03d1~\u03beT (x),\nwhere\n\u03d1 (\u03bedr1 ,...,\u03bedrk ) T (x) = \u2228 \u03be\u2208Tp ( \u03be\u2217(x) \u2227 \u03beT \u2227 \u2227 Ri\u2208role\u00b1(T )\n\u03beTdri \u2227\u2227 Ri\u2208role\u00b1(T ) (( \u03be(\u2203Ri) \u2228 \u2228 S\u2208role\u00b1(T ) \u03beds(\u2203Ri) ) \u2192 \u03beinv(dri)(\u2203inv(Ri)) )) .\nTo explain the meaning of the subformulas of \u03d5T , assume that (T ,A) is satisfiable. In order to construct a model M for K\u2021e from the first-order model AA, we have to specify the basic concepts that contain a given constant of K\u2021e . In other words, we have to select a type for each dri \u2208 dr(T ) and each a \u2208 ob(A). The formula \u03d5T says that one can select a k-tuple of types ~\u03be = (\u03bedr1 , . . . , \u03bedrk) \u2208 Tp\nk such that one of its disjuncts is true in AA. Such a k-tuple fixes the \u2018witness\u2019 part of the model M, consisting of the dri, and determines the basic concepts these dri belong to. Then each disjunct of \u03d5T says that (having fixed the \u2018witness\u2019 part of the model), for every a \u2208 ob(A), there is a type \u03be (determining the basic concepts a belongs to) such that\n\u2022 \u03be is consistent with the information about a in A (cf. \u03be\u2217(x));\n\u2022 \u03be is also consistent with the concept and role inclusions of T (cf. \u03beT );\n\u2022 each of \u03bedr1 , . . . , \u03bedrk is consistent with the concept and role inclusions of T (cf. \u03beTdri);\n\u2022 each role Ri with a nonempty domain (i.e., either \u03be or any of \u03beds is > on \u2203Ri) has a nonempty range, in particular, \u03beinv(dri)(\u2203inv(Ri)) = >; see also \u03b5R(x) as defined by (4).\nLemma 6.1 AA |= \u03d5T iff K\u2021e is satisfiable.\nProof (\u21d2) Fix some ~\u03be = (\u03bedr1 , . . . , \u03bedrk) \u2208 Tp k such that AA |= \u2200x\u03d1 ~\u03be T (x). Then, for each a \u2208 ob(A), fix some type such that the respective disjunct of \u03d1~\u03beT (x) holds on a in AA and denote it by \u03bea. Define a first-order model M over the domain ob(A) \u222a dr(T ) by taking:\n\u2022 M |= B\u2217[c] iff \u03bec(B) = >, for all c \u2208 ob(A) \u222a dr(T ) and B \u2208 Bcon(T )\n(B\u2217 is the unary predicate for B as defined on p. 22). It is easy to check that M |= K\u2021e . (\u21d0) Suppose now that K\u2021e is satisfiable. Then there is a model M of K\u2021e with domain ob(A) \u222a dr(T ). To see that AA |= \u03d5T , it suffices to take the functions \u03bedri and \u03bea defined by:\n\u2022 \u03bedri(B) = > iff M |= B\u2217[dri], for dri \u2208 dr(T ) and B \u2208 Bcon(T ),\n\u2022 \u03bea(B) = > iff M |= B\u2217[a], for a \u2208 ob(A) and B \u2208 Bcon(T ).\nDetails are left to the reader. q\nIt follows from Lemmas 6.1 and 5.17 and Corollary 5.16 that we have:\nCorollary 6.2 The satisfiability and instance checking problems for DL-LiteNbool, DL-Lite H bool and DL-Lite (HN ) bool KBs are in AC 0 for data complexity.\nProof DL-LiteNbool and DL-Lite H bool are sub-languages of DL-Lite (HN )\u2212 bool , and for them the result immediately follows from Lemma 6.1 and Corollary 5.16. For a DL-Lite (HN ) bool KB K\u2032 = (T \u2032,A\u2032), by Lemma 5.17, we construct a DL-Lite(HN ) \u2212\nbool KB K = (T ,A) such that K\u2032 is satisfiable iff K is satisfiable and (44) holds. The latter condition corresponds to the following first-order sentence\n\u03b3T \u2032 = \u2227\nDis(R1,R2)\u2208T \u2032 \u2200x\u2200y\n( RT1 (x, y) \u2227RT2 (x, y)\u2192 \u22a5 ) \u2227 \u2227 Irr(Pk)\u2208T \u2032 \u2200x ( P Tk (x, x)\u2192 \u22a5 ) ,\nevaluated in AA. Therefore, K\u2032 is satisfiable iff AA |= \u03d5T \u2227 \u03b3T \u2032 . Let \u03c8 = \u03d5T \u2227 \u03b3T \u2032 and \u03c8\u2032 be the result of replacing each SP (t1, t2), for Ref(P ) \u2208 T \u2032, with P (t1, t2)\u2227 (t1 6= t2); see the proof of Lemma 5.17. It remains to observe that AA |= \u03c8 iff AA\u2032 |= \u03c8\u2032. q\nAs before, this result does not depend on the UNA for any member of the DL-Lite family that has no number restrictions of the form \u2265 q R, for q \u2265 2 (in particular, for DL-LiteHbool and its fragments).\nWe also note that transitive roles cannot be included in our languages for free if we are concerned with data complexity:\nLemma 6.3 Satisfiability and instance checking of DL-Litecore KBs extended with role transitivity constraints are NLogSpace-hard for data complexity.\nProof Suppose we are given a directed graph. Let P be a role name. Define an ABox A by taking P (ai, aj) \u2208 A iff there is an edge (ai, aj) in the graph. Then a node an is reachable from a node a0 iff the DL-Litecore ABox A \u222a {\u00acP (a0, an)} is not satisfiable in models with transitive P . This encoding immediately gives the claim of the lemma because the directed graph reachability problem is NLogSpace-complete, NLogSpace is closed under the complement (see, e.g., Kozen, 2006) and the TBox {Tra(P )} does not depend on the input. q\nOn the other hand, as the reduction of Lemma 5.18 is computable in NLogSpace, we obtain the following:\nCorollary 6.4 Satisfiability and instance checking of DL-Lite (HN )+ bool KBs are NLogSpacecomplete for data complexity.\nProof The upper bound is obtained by applying the NLogSpace reduction of Lemma 5.18 and using Corollary 6.2. The lower bound follows from Lemma 6.3. q"}, {"heading": "6.2 P- and coNP-hardness for Data Complexity", "text": "Let us now turn to the data complexity of instance checking for the DL-Lite logics with arbitrary number restrictions and role inclusions. As follows from the results of Ortiz et al. (2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHNbool is in coNP for data complexity, while the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ imply a polynomial-time upper bound for DL-LiteHFhorn.\nHere we show that these upper bounds are optimal in the following sense: on the one hand, instance checking in DL-LiteHFcore is P-hard for data complexity; on the other hand, it becomes coNP-hard for both DL-LiteHFkrom and DL-Lite HN core (that is, if we allow negated concept names or arbitrary number restrictions\u2014in fact, \u2265 2R is enough). Note that the results of this section do not depend on whether we adopt the UNA or not.\nTheorem 6.5 The instance checking (and query answering) problem for DL-LiteHFkrom KBs is data-hard for coNP (with or without the UNA).\nProof The proof is by reduction of the unsatisfiability problem for 2+2CNF, which is known to be coNP-complete (Schaerf, 1993). Given a 2+2CNF formula\n\u03d5 = n\u2227 k=1 (ak,1 \u2228 ak,2 \u2228 \u00acak,3 \u2228 \u00acak,4),\nwhere each ak,j is one of the propositional variables a1, . . . , am, we construct a KB (T ,A\u03d5) whose TBox T does not depend on \u03d5. We will use the object names f , ck, for 1 \u2264 k \u2264 n, and ai, for 1 \u2264 i \u2264 m, role names S, Sf and Pj , Pj,t, Pj,f, for 1 \u2264 j \u2264 4, and concept names A and D.\nDefine A\u03d5 to be the set of the following assertions, for 1 \u2264 k \u2264 n:\nS(f, ck), P1(ck, ak,1), P2(ck, ak,2), P3(ck, ak,3), P4(ck, ak,4),\nand let T consist of the axioms\n\u2265 2Pj v \u22a5, for1 \u2264 j \u2264 4, (48) Pj,f v Pj , Pj,t v Pj , for 1 \u2264 j \u2264 4, (49) \u00ac\u2203Pj,t v \u2203Pj,f, for 1 \u2264 j \u2264 4, (50) \u2203P\u2212j,f v \u00acA, \u2203P \u2212 j,t v A, for 1 \u2264 j \u2264 4, (51)\n\u2203P1,f u \u2203P2,f u \u2203P3,t u \u2203P4,t v \u2203S\u2212f , (52) \u2265 2S\u2212 v \u22a5, (53)\nSf v S, (54) \u2203Sf v D. (55)\nNote that axiom (52) does not belong to DL-LiteHFkrom because of the conjunctions in its left-hand side. However, it can be eliminated with the help of Lemma 5.9. So let us prove that (T ,A\u03d5) |= D(f) iff \u03d5 is not satisfiable.\n(\u21d0) Suppose that \u03d5 is not satisfiable and I |= (T ,A\u03d5). Define an assignment a of the truth values t and f to propositional variables by taking a(ai) = t iff a I i \u2208 AI . As \u03d5 is false\nunder a, there is k, 1 \u2264 k \u2264 n, such that a(ak,1) = a(ak,2) = f and a(ak,3) = a(ak,4) = t. In view of (50), for each j, 1 \u2264 j \u2264 4, we have cIk \u2208 (\u2203Pj,t)I \u222a (\u2203Pj,f)I , and by (49), cIk \u2208 (\u2203Pj)I . Therefore, by (48) and (51), cIk \u2208 (\u2203Pj,t)I if a(ak,j) = t and cIk \u2208 (\u2203Pj,f)I if a(ak,j) = f, and hence, by (52), c I k \u2208 (\u2203S \u2212 f ) I . Then by (53) and (54), we have fI \u2208 (\u2203Sf)I , from which, by (55), fI \u2208 DI . It follows that (T ,A\u03d5) |= D(f). (\u21d2) Conversely, suppose that \u03d5 is satisfiable. Then there is an assignment a such that a(ak,1) = t or a(ak,2) = t or a(ak,3) = f or a(ak,4) = f, for all 1 \u2264 k \u2264 n. Define I by taking\n\u2022 \u2206I = { xi | 1 \u2264 i \u2264 m } \u222a { yk | 1 \u2264 k \u2264 n } \u222a { z } ,\n\u2022 aIi = xi, for 1 \u2264 i \u2264 m, cIk = yk, for 1 \u2264 k \u2264 n, fI = z,\n\u2022 AI = { xi | a(ai) = t } \u222a { yk | 1 \u2264 k \u2264 n } \u222a { z } ,\n\u2022 P Ij,t = { (yk, a I k,j) | 1 \u2264 k \u2264 n, a(ak,j) = t } \u222a { (xi, xi) | a(ai) = t } \u222a { (z, z) } ,\n\u2022 P Ij,f = { (yk, a I k,j) | 1 \u2264 k \u2264 n, a(ak,j) = f } \u222a { (xi, xi) | a(ai) = f } ,\n\u2022 P Ij = P Ij,t \u222a P Ij,f, for 1 \u2264 j \u2264 4,\n\u2022 SIf = { (z, yk) | a(ak,1 \u2228 ak,2 \u2228 \u00acak,3 \u2228 \u00acak,4) = f } = \u2205,\n\u2022 SI = { (z, yk) | 1 \u2264 k \u2264 n } ,\n\u2022 DI = { z | a(\u03d5) = f } = \u2205.\nIt is not hard to check that I |= (T ,A\u03d5) and I 6|= D(f). q\nTheorem 6.6 The instance checking (and the query answering) problem for DL-LiteHNcore KBs is data-hard for coNP (with or without the UNA).\nProof The proof is again by reduction of the unsatisfiability problem for 2+2CNF. The main difference from the previous one is that DL-LiteHNcore, unlike DL-Lite HF krom, cannot express \u2018covering conditions\u2019 like (50). It turns out, however, that we can use number restrictions to represent constraints of this kind. Given a 2+2CNF formula \u03d5, we take the same ABox A\u03d5 constructed in the proof of Theorem 6.5. The (\u03d5 independent) TBox T , describing the meaning of any such representation of \u03d5 in terms of A\u03d5, is also defined in the same way as in that proof, except that the axiom (50) is now replaced by the following set of axioms:\nTj,1 v Tj , Tj,2 v Tj , Tj,3 v Tj , (56) \u2265 2T\u2212j v \u22a5, (57) \u2203Pj v \u2203Tj,1, \u2203Pj v \u2203Tj,2, (58)\n\u2203T\u2212j,1 u \u2203T \u2212 j,2 v \u2203T \u2212 j,3, (59)\n\u2265 2Tj v \u2203Pj,t \u2203Tj,3 v \u2203Pj,f, (60)\nwhere Tj , Tj,1, Tj,2, Tj,3 are fresh role names, for each j, 1 \u2264 j \u2264 4. Note that axioms (52) and (59) do not belong to DL-LiteHNcore because of the conjunctions in their left-hand side, but\nwe can easily eliminate them using Lemma 5.9. So it remains to prove that (T ,A\u03d5) |= D(f) iff \u03d5 is not satisfiable.\n(\u21d0) Suppose that \u03d5 is not satisfiable and I |= (T ,A\u03d5). Define an assignment a of the truth values t and f to propositional variables by taking a(ai) = t iff a I i \u2208 AI . As \u03d5 is false under a, there is k, 1 \u2264 k \u2264 n, such that a(ak,1) = a(ak,2) = f, a(ak,3) = a(ak,4) = t. For each j, 1 \u2264 j \u2264 4, we have cIk \u2208 (\u2203Pj)I ; by (58), cIk \u2208 (\u2203Tj,1)I , (\u2203Tj,2)I . So there are v1, v2 such that (c I k , v1) \u2208 T Ij,1 and (cIk , v2) \u2208 T Ij,2. If v1 6= v2 then cIk \u2208 (\u2265 2Tj)I and, by (60), cIk \u2208 (Pj,t)I . Otherwise, if v1 = v2 = v, we have v \u2208 (\u2203T \u2212 j,3) I by (59), and so by (56) and (57), cIk \u2208 (\u2203Tj,3)I , from which, by (60), cIk \u2208 (Pj,f)I . Therefore, cIk \u2208 (\u2203Pj,t)I \u222a (\u2203Pj,f)I , and by (49), cIk \u2208 (\u2203Pj)I . Thus, by (48) and (51), cIk \u2208 (\u2203Pj,t)I if a(ak,j) = t and c I k \u2208 (\u2203Pj,f)I if a(ak,j) = f, and hence, by (52), cIk \u2208 (\u2203S \u2212 f ) I . Then by (53) and (54), we have fI \u2208 (\u2203Sf)I , from which, by (55), fI \u2208 DI . It follows that (T ,A\u03d5) |= D(f).\n(\u21d2) Conversely, suppose that \u03d5 is satisfiable. Then there is an assignment a such that a(ak,1) = t or a(ak,2) = t or a(ak,3) = f or a(ak,4) = f, for all 1 \u2264 k \u2264 n. Define I by taking\n\u2022 \u2206I = { xi | 1 \u2264 i \u2264 m } \u222a { yk | 1 \u2264 k \u2264 n } \u222a { uk,j,1, uk,j,2 | 1 \u2264 j \u2264 4, 1 \u2264 k \u2264 n } \u222a { z } ,\n\u2022 aIi = xi, for 1 \u2264 i \u2264 m, cIk = yk, for 1 \u2264 k \u2264 n, fI = z,\n\u2022 AI = {xi | a(ai) = t}, \u2022 P Ij,t = { (yk, a I k,j) | 1 \u2264 k \u2264 n, a(ak,j) = t } , for 1 \u2264 j \u2264 4,\n\u2022 P Ij,f = { (yk, a I k,j) | 1 \u2264 k \u2264 n, a(ak,j) = f } , for 1 \u2264 j \u2264 4,\n\u2022 P Ij = P Ij,t \u222a P Ij,f, for 1 \u2264 j \u2264 4,\n\u2022 T Ij,1 = { (yk, uk,j,1) | 1 \u2264 k \u2264 n } , for 1 \u2264 j \u2264 4,\n\u2022 T Ij,2 = { (yk, uk,j,2) | 1 \u2264 k \u2264 n, a(ak,j) = t } \u222a{\n(yk, uk,j,1) | 1 \u2264 k \u2264 n, a(ak,j) = f } , for 1 \u2264 j \u2264 4,\n\u2022 T Ij,3 = { (yi, uk,j,1) | 1 \u2264 k \u2264 n, a(ak,j) = f } , for 1 \u2264 j \u2264 4,\n\u2022 T Ij = T Ij,1 \u222a T Ij,2,\n\u2022 SIf = { (z, yk) | a(ak,1 \u2228 ak,2 \u2228 \u00acak,3 \u2228 \u00acak,4) = f } = \u2205,\n\u2022 SI = { (z, yk) | 1 \u2264 k \u2264 n } ,\n\u2022 DI = { z | a(\u03d5) = f } = \u2205.\nIt is not hard to check that I |= (T ,A\u03d5) and I 6|= D(f). q\nOur next lower bound would follow from Theorem 6, item 2 in the work of Calvanese et al. (2006); unfortunately, the proof there is incorrect and cannot be repaired.\nTheorem 6.7 The instance checking (and query answering) problem for DL-LiteHFcore KBs is data-hard for P (with or without the UNA).\nProof The proof is by reduction of the entailment problem for Horn-CNF, which is known to be P-complete (see, e.g., Bo\u0308rger et al., 1997, Exercise 2.2.4). Given a Horn-CNF formula\n\u03d5 = n\u2227 k=1 (\u00acak,1 \u2228 \u00acak,2 \u2228 ak,3) \u2227 p\u2227 l=1 al,0,\nwhere each ak,j and each al,0 is one of the propositional variables a1, . . . , am, we construct a KB (T ,A\u03d5) whose TBox T does not depend on \u03d5. We will need the object names c1, . . . , cn and vk,j,i, for 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3, 1 \u2264 i \u2264 m (for each variable, we take one object name for each possible occurrence of this variable in each non-unit clause), role names S, St and Pj , Pj,t, for 1 \u2264 j \u2264 3, and a concept name A.\nDefine A\u03d5 to be the set containing the assertions:\nS(v1,1,i, v1,2,i), S(v1,2,i, v1,3,i), S(v1,3,i, v2,1,i), S(v2,1,i, v2,2,i), S(v2,2,i, v2,3,i), . . . . . . , S(vn,2,i, vn,3,i), S(vn,3,i, v1,1,i), for 1 \u2264 i \u2264 m, Pj(vk,j,i, ck) iff ak,j = ai, for 1 \u2264 i \u2264 m, 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3, A(v1,1,i) iff al,0 = ai, for 1 \u2264 i \u2264 m, 1 \u2264 l \u2264 p\n(all objects for each variable are organized in an S-cycle and Pj(vk,j,i, ck) \u2208 A\u03d5 iff the variable ai occurs in the kth non-unit clause of \u03d5 in the jth position). Let T consist of the following concept and role inclusions:\nSt v S, (61) \u2265 2S v \u22a5, (62)\nA v \u2203St, (63) \u2203S\u2212t v A, (64) \u2265 2P1 v \u22a5 \u2265 2P2 v \u22a5, (65) P1,t v P1, P2,t v P2, (66) A v \u2203P1,t, A v \u2203P2,t, (67) \u2265 2P\u22123 v \u22a5, (68) P3,t v P3, (69)\n\u2203P\u22121,t u \u2203P \u2212 2,t v \u2203P \u2212 3,t, (70)\n\u2203P3,t v A. (71)\nAs before, here we have an axiom, namely (70), that does not belong to DL-LiteHFcore because of the conjunction in its left-hand side, but again it can be eliminated with the help of Lemma 5.9. Our aim is to show that (T ,A\u03d5) |= A(v1,1,i0) iff \u03d5 |= ai0 .\n(\u21d0) Suppose that \u03d5 |= ai0 . Consider an arbitrary model I of (T ,A\u03d5) and define a to be the assignment of the truth values t and f to propositional variables such that a(ai) = t iff vI1,1,i \u2208 AI , for 1 \u2264 i \u2264 m. By (61)\u2013(64), for each i, 1 \u2264 i \u2264 m, we have either vIk,j,i \u2208 AI , for all k, j with 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3, or vIk,j,i /\u2208 AI , for all k, j with 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3. Now, if we have a(ak,1) = t and a(ak,2) = t, for 1 \u2264 k \u2264 n then, by (65)\u2013(67), cIk \u2208 (\u2203P \u2212 1,t) I , (\u2203P\u22122,t)I . By (70), cIk \u2208 (\u2203P \u2212 3,t) I and hence, by (68) and (69), vIk,3,i \u2208 (\u2203P3,t)I ,\nwhere ak,3 = ai, which means, by (71), that v I k,3,i \u2208 AI , and so vI1,1,i \u2208 AI and a(ai) = t. It follows that a(\u03d5) = t, and hence a(ai0) = t, which, by definition, means that v I 1,1,i0\n\u2208 AI . So we can conclude that (T ,A\u03d5) |= A(v1,1,i0).\n(\u21d2) Conversely, suppose that \u03d5 6|= ai0 . Then there is an assignment a with a(\u03d5) = t and a(ai0) = f. We construct a model I of (T ,A\u03d5) such that I 6|= A(v1,1,i0). Define I by taking\n\u2022 \u2206I = { xk,j,i, zk,j,i | 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3, 1 \u2264 i \u2264 m } \u222a { yk | 1 \u2264 k \u2264 n } ,\n\u2022 cIk = yk, for 1 \u2264 k \u2264 n,\n\u2022 vIk,j,i = xk,j,i, for 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3, 1 \u2264 i \u2264 m,\n\u2022 AI = { xk,j,i | 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3, a(ai) = t } ,\n\u2022 SI = \u22c3\n1\u2264i\u2264m Si, where Si =\n{ (xk,1,i, xk,2,i), (xk,2,i, xk,3,i), (xk,3,i, xk\u22951,1,i) | 1 \u2264 k \u2264 n } and k \u2295 1 = k + 1 if k < n, and k \u2295 1 = 1 if k = n,\n\u2022 SIt = \u22c3\n1\u2264i\u2264m a(ai)=t\nSi,\n\u2022 P Ij = { (xk,j,i, yk) | 1 \u2264 k \u2264 n, ai = ak,j } \u222a{\n(xk,j,i, zk,j,i) | 1 \u2264 k \u2264 n, ai 6= ak,j } , for 1 \u2264 j \u2264 2,\n\u2022 P I3 = { (xk,3,i, yk) | 1 \u2264 k \u2264 n, ai = ak,3 } ,\n\u2022 P Ij,t = { (xk,j,i, yk) | 1 \u2264 k \u2264 n, ai = ak,j , a(ai) = t } \u222a{\n(xk,j,i, zk,j,i) | 1 \u2264 k \u2264 n, ai 6= ak,j } , for 1 \u2264 j \u2264 2,\n\u2022 P I3,t = { (xk,3,i, yk) | 1 \u2264 k \u2264 n, ai = ak,3, a(ai) = t } .\nIt is routine to check that we indeed have I |= (T ,A\u03d5) and I 6|= A(v1,1,i0). See Figure 5 for an example. q"}, {"heading": "7. Query Answering: Data Complexity", "text": "The positive existential query answering problem is known to be data-complete for coNP in the case of DL-LiteHNbool : the upper bound follows from the results of Ortiz et al. (2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHFhorn, query answering is data-complete for P, as follows from the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ, while for DL-LiteHhorn it is in AC\n0 (Calvanese et al., 2006). In fact, the coNP upper bound holds for the extension of DL-LiteHNbool with role disjointness and (a)symmetry constraints (this follows from Glimm et al., 2007, Theorem 10; cf. Remark 5.21). We conjecture that the same result holds for role (ir)reflexivity constraints.\nOur main result in this section is the following:\nTheorem 7.1 The positive existential query answering problem for the logics DL-LiteNhorn, DL-LiteHhorn and DL-Lite (HN ) horn is in AC 0 for data complexity.\nProof Suppose that we are given a consistent DL-Lite (HN ) horn KB K \u2032 = (T \u2032,A\u2032) (with all its concept and role names occurring in the TBox T \u2032) and a positive existential query in prenex form q(~x) = \u2203~y \u03d5(~x, ~y) in the signature of K\u2032. Consider the DL-Lite(HN ) \u2212\nhorn KB K = (T ,A) provided by Lemma 5.17 (the language DL-Lite\n(HN )\u2212 horn is defined in Section 5.3).\nLemma 7.2 For every tuple ~a of object names in K\u2032, we have K\u2032 |= q(~a) iff I |= q(~a) for all untangled models I of K.\nProof (\u21d2) Suppose that K\u2032 |= q(~a) and I is an untangled model I of K. By Lemma 5.17 and in view of consistency of K\u2032, which ensures that (44) holds, we then have I |= K\u2032 and therefore, I |= q(~a).\n(\u21d0) Suppose I \u2032 |= K\u2032. By Lemma 5.17, there is a model I of K with the same domain as I \u2032 that coincides with I \u2032 on all symbols in K\u2032. As I |= q(~a), we must then have I \u2032 |= q(~a), and so K\u2032 |= q(~a) as required. q\nNext we show that, as K\u2021e is a Horn sentence, it is enough to consider just one special model I0 of K in the formulation of Lemma 7.2. Let M0 be the minimal Herbrand model of (the universal Horn sentence) K\u2021e . We remind the reader (for details consult, e.g., Apt, 1990; Rautenberg, 2006) that M0 can be constructed by taking the intersection of all Herbrand models for K\u2021e , that is, of all models based on the domain that consists of constant symbols from K\u2021e\u2014i.e., \u039b = ob(A) \u222a dr(T ); cf. Remark 5.15. We then have the following\nM0 |= B\u2217[c] iff K\u2021e |= B\u2217(c), for B \u2208 Bcon(T ) and c \u2208 \u039b.\nLet I0 be the untangled model of K induced by M0. Denote the domain of I0 by \u2206I0 . Property (copy) of Remark 5.15 provides us with a function cp : \u2206I0 \u2192 \u039b.\nThere are two consequences of Lemma 5.14. First, we have\naI0i \u2208 B I0 iff K |= B(ai), for B \u2208 Bcon(T ) and ai \u2208 ob(A). (72)\nSecond, for every R \u2208 role\u00b1(T ), if RI0 6= \u2205 then RI 6= \u2205, for all models I of K. Indeed, if RI0 6= \u2205 then M0 |= (\u2203R)\u2217[dr]. Therefore, (T \u222a {\u2203R v \u22a5},A) is not satisfiable, and thus RI 6= \u2205, for all I with I |= K. Moreover, if RI0 6= \u2205 then\nw \u2208 BI0 iff K |= \u2203R v B, for B \u2208 Bcon(T ) and w \u2208 \u2206I0 with cp(w) = dr. (73)\nLemma 7.3 If I0 |= q(~a) then I |= q(~a) for all untangled models I of K.\nProof Suppose I |= K. As q(~a) is a positive existential sentence, it is enough to construct a homomorphism h : I0 \u2192 I. We remind the reader that, by (forest), the domain \u2206I0 of I0 is partitioned into disjoint trees Ta, for a \u2208 ob(A). Define the depth of a point w \u2208 \u2206I0 to be the length of the shortest path in the respective tree to its root. Denote by Wm the set of points of depth \u2264 m; in particular, W0 = {aI0 | a \u2208 ob(A)}. We construct h as the union of maps hm, m \u2265 0, where each hm is defined on Wm and has the following properties: hm+1(w) = hm(w), for all w \u2208Wm, and\n(am) for every w \u2208Wm, if w \u2208 BI0 then hm(w) \u2208 BI , for each B \u2208 Bcon(T );\n(bm) for all u, v \u2208Wm, if (u, v) \u2208 RI0 then (hm(u), hm(v)) \u2208 RI , for each R \u2208 role\u00b1(T ).\nFor the basis of induction, we set h0(a I0 i ) = a I i , for ai \u2208 ob(A). Property (a0) follows then from (72) and (b0) from (ABox) of Remark 5.15. For the induction step, suppose that hm has already been defined for Wm, m \u2265 0. Set hm+1(w) = hm(w) for all w \u2208 Wm. Consider an arbitrary v \u2208 Wm+1 \\Wm. By (forest), there is a unique u \u2208 Wm such that (u, v) \u2208 Ea, for some Ta. Let `a(u, v) = S. Then, by (copy), cp(v) = inv(ds). By (role), u \u2208 (\u2203S)I0 and, by (am), hm(u) \u2208 (\u2203S)I , which means that there is w \u2208 \u2206I with (hm(u), w) \u2208 SI . Set hm+1(v) = w. As cp(v) = inv(ds) and (\u2203inv(S))I0 6= \u2205, it follows from (73) that if v \u2208 BI0 then w\u2032 \u2208 BI whenever we have w\u2032 \u2208 (\u2203inv(S))I . As w \u2208 (\u2203inv(S))I , we obtain (am+1) for v. To show (bm+1), we notice that, by (role), we have (w, v) \u2208 RI0 , for some w \u2208 Wm+1, just in two cases: either w \u2208Wm+1 \\Wm, and then w = v and Id v\u2217T R, or w \u2208Wm, and then w = u and S v\u2217T R. In the former case, (hm+1(v), hm+1(v)) \u2208 RI because IdI is the identity relation by (role). In the latter case, we have (u, v) \u2208 SI0 ; hence (hm+1(u), hm+1(v)) \u2208 SI and, as S v\u2217T R, (hm+1(u), hm+1(v)) \u2208 RI . q\nAssume now that, in the query q(~x) = \u2203~y \u03d5(~x, ~y), we have ~y = y1, . . . , yk, and \u03d5 is a quantifier-free formula. Our next lemma shows that in this case to check whether I0 |= q(~a) it suffices to consider only the points of depth \u2264 m0 in \u2206I0 , for some m0 that does not depend on |A|.\nLemma 7.4 Let m0 = k+ |role\u00b1(T )|. If I0 |= \u2203~y \u03d5(~a, ~y) then there is an assignment a0 in Wm0 (i.e., a0(yi) \u2208Wm0 for all i) such that I0 |=a0 \u03d5(~a, ~y).\nProof Suppose that I0 |=a \u03d5(~a, ~y), for some assignment a in \u2206I0 , and that there is yi, 1 \u2264 i \u2264 k, with a(yi) /\u2208 Wm0 . Let Y be the minimal subset of ~y that contains yi and every y such that either P (y\u2032, y) or P (y, y\u2032) is a subformula of \u03d5, for some y\u2032 \u2208 Y and some role name P . Let yj \u2208 Y be such that there is m > |role\u00b1(T )| with a(yj) \u2208 Wm and\na(y) /\u2208Wm\u22121 for all y \u2208 Y (for convenience, W\u22121 = \u2205 as before). Clearly, such an m exists: a(yi) /\u2208Wm0 , Y has at most k variables and, by (forest), relations P I0 can connect a point in Wn \\Wn\u22121 only with a point in Wn+1 \\Wn\u22122, for n \u2265 1. Let w = a(yj) be a point in Ta. As w \u2208Wm \\Wm\u22121, we have cp(w) = dr, for some R \u2208 role\u00b1(T ). As there are at most |role\u00b1(T )| distinct labels in each labeled tree Ta and in view of (copy), for each point u of depth > |role\u00b1(T )|, there is a point u\u2032 of depth \u2264 |role\u00b1(T )| in the same Ta such that cp(u) = cp(u\u2032); by (iso), the trees generated by u and u\u2032 are isomorphic. So, there is an isomorphism g from the labeled tree generated by w (which contains all a(y), for y \u2208 Y ) onto the labeled tree generated by some point of depth \u2264 |role\u00b1(T )| in Ta. Define a new assignment aY by taking aY (y) = g(a(y)) if y \u2208 Y and aY (y) = a(y) otherwise. By (copy), (concept) and (role) we then have I0 |=aY \u03d5(~a, ~y) and aY (y) \u2208 Wm0 , for each y \u2208 Y . If aY (yj) /\u2208Wm0 for some j, we repeat the described construction. After at most k iterations we shall obtain an assignment a0 required by the lemma. q\nTo complete the proof of Theorem 7.1, we encode the problem \u2018K |= q(~a)?\u2019 as a model checking problem for first-order formulas. In precisely the same way as in Section 6.1, we fix a signature that contains unary predicates A, A, for each concept name A, and binary predicates P , P , for each role name P , and then represent the ABox A of K as a first-order model AA with domain ob(A). Now we define a first-order formula \u03d5T ,q(~x) in the above signature such that (i) \u03d5T ,q(~x) depends on T and q but not on A, and (ii) AA |= \u03d5T ,q(~a) iff I0 |= q(~a).\nWe begin by defining formulas \u03c8B(x), for B \u2208 Bcon(T ), that describe the types of the elements of ob(A) in the model I0 in the following sense (see also (72)):\nAA |= \u03c8B[ai] iff aI0i \u2208 B I0 , for B \u2208 Bcon(T ) and ai \u2208 ob(A). (74)\nThese formulas are defined as the \u2018fixed-points\u2019 of sequences \u03c80B(x), \u03c8 1 B(x), . . . of formulas with one free variable, where\n\u03c80B(x) =\n{ A(x), if B = A,\nEqR T (x), if B = \u2265 q R,\n\u03c8iB(x) = \u03c8 0 B(x) \u2228 \u2228 B1u\u00b7\u00b7\u00b7uBkvB\u2208ext(T ) ( \u03c8i\u22121B1 (x) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c8 i\u22121 Bk (x) ) , for i \u2265 1,\nand EqR T (x) is given by (46). (As in Section 6.1, to simplify presentation we use ext(T ) instead of T .) It should be clear that if there is some i such that, for all B \u2208 Bcon(T ), \u03c8iB(x) \u2261 \u03c8 i+1 B (x) (i.e., every \u03c8 i B(x) is equivalent to \u03c8 i+1 B (x) in first-order logic), then \u03c8iB(x) \u2261 \u03c8 j B(x) for every B \u2208 Bcon(T ) and j \u2265 i. So the minimum such i does not exceed N = |Bcon(T )|, and we set \u03c8B(x) = \u03c8NB (x). Next we introduce sentences \u03b8B,dr, for B \u2208 Bcon(T ) and dr \u2208 dr(T ), that describe the types of elements in dr(T ) in the following sense (see also (73)):\nAA |= \u03b8B,dr iff w \u2208 BI0 , for B \u2208 Bcon(T ) and each w \u2208 \u2206I0 with cp(w) = dr. (75)\n(By (concept), this definition is correct.) These sentences are defined similarly to \u03c8B(x). Namely, for each B \u2208 Bcon(T ) and each dr \u2208 dr(T ), we inductively define a sequence\n\u03b80B,dr, \u03b8 1 B,dr, . . . by taking\n\u03b80B,dr = \u03c1 0 B,dr and \u03b8 i B,dr = \u03c1 i B,dr \u2228 \u2228 B1u\u00b7\u00b7\u00b7uBkvB\u2208ext(T ) ( \u03b8i\u22121B1,dr \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b8 i\u22121 Bk,dr ) , for i \u2265 1,\nwhere \u03c1iB,dr = \u22a5, for all i \u2265 0, whenever B 6= \u2203R and\n\u03c10\u2203R,dr = \u2203x\u03c8\u2203inv(R)(x) and \u03c1i\u2203R,dr = \u2228\nds\u2208dr(T )\n\u03b8i\u22121\u2203inv(R),ds, for i \u2265 1.\nIt should be clear that there is i \u2264 |role\u00b1(T )|\u00b7N such that \u03b8iB,dr \u2261 \u03b8 i+1 B,dr, for all B \u2208 Bcon(T ) and dr \u2208 dr(T ). So we set \u03b8B,dr = \u03b8 |role\u00b1(T )|\u00b7N B,dr .\nNow we consider the directed graphGT = (VT , ET ), where VT is the set of all equivalence classes [R], [R] = {R\u2032 | R \u2261\u2217T R\u2032}, such that \u2203R is not empty in some model of T , and ET is the set of all pairs ([Ri], [Rj ]) such that\n(path) T |= \u2203inv(Ri) v \u2265 q Rj and either inv(Ri) 6v\u2217T Rj or q \u2265 2,\nand Rj has no proper sub-role satisfying (path). We have ([Ri], [Rj ]) \u2208 ET iff, for any ABox A\u2032, whenever the minimal untangled model I0 of (T ,A\u2032) contains a copy w of inv(dr\u2032i), for R\u2032i \u2208 [Ri], then w is connected to a copy of inv(dr\u2032j), for R\u2032j \u2208 [Rj ], by all relations S with Rj v\u2217T S.\nRecall now that we are given a query q(~x) = \u2203~y \u03d5(~x, ~y), where \u03d5 is a quantifier-free positive formula and ~y = y1, . . . , yk. Let \u03a3T ,m0 be the set of all paths in the graph GT of length \u2264 m0. More precisely,\n\u03a3T ,m0 = { \u03b5 } \u222a { ([R1], [R2], . . . , [Rn]) | 1 \u2264 n \u2264 m0, ([Rj ], [Rj+1]) \u2208 ET , for 1 \u2264 j < n } .\nFor \u03c3, \u03c3\u2032 \u2208 \u03a3T ,m0 and a role R \u2208 role\u00b1(T ), we write \u03c3 R\u2192 \u03c3\u2032 if one of the following three conditions is satisfied: (i) \u03c3 = \u03c3\u2032 and Id v\u2217T R, (ii) \u03c3.[S] = \u03c3\u2032 or (iii) \u03c3 = \u03c3\u2032.[inv(S)], for some role S with S v\u2217T R.\nLet \u03a3kT ,m0 be the set of all k-tuples of the form ~\u03c3 = (\u03c31, . . . , \u03c3k), \u03c3i \u2208 \u03a3T ,m0 . Intuitively, when evaluating the query \u2203~y \u03d5(~x, ~y) over I0, each bound, or non-distinguished, variable yi is mapped to a point w in Wm0 . However, the first-order model AA does not contain the points from Wm0 \\W0, and to represent them, we use the following \u2018trick.\u2019 By (forest), every point w in Wm0 is uniquely determined by the pair (a, \u03c3), where a\nI0 is the root of the tree Ta containing w, and \u03c3 is the sequence of labels `a(u, v) on the path from a\nI0 to w. It follows from the unraveling procedure and (path) that \u03c3 \u2208 \u03a3T ,m0 . So, in the formula \u03d5T ,q we are about to define we assume that the yi range over W0 and represent the first component of the pairs (a, \u03c3), whereas the second component is encoded in the ith member of ~\u03c3 (these yi should not be confused with the yi in the original query q, which range over all of Wm0). In order to treat arbitrary terms t occurring in \u03d5(~x, ~y) in a uniform way, we set t~\u03c3 = \u03b5, if t = a \u2208 ob(A) or t = xi, and t~\u03c3 = \u03c3i, if t = yi (the distinguished variables xi and the object names a are mapped to W0 and do not require the second component of the pairs).\nGiven an assignment a0 in Wm0 we denote by split(a0) the pair (a, ~\u03c3), where a is an assignment in AA and ~\u03c3 = (\u03c31, . . . , \u03c3k) \u2208 \u03a3kT ,m0 are such that\n\u2022 for each distinguished variable xi, a(xi) = a with aI0 = a0(xi);\n\u2022 for each bound variable yi, a(yi) = a and \u03c3i = ([R1], . . . , [Rn]), n \u2264 m0, with aI0 being the root of the tree containing a0(yi) and R1, . . . , Rn being the sequence of labels `a(u, v) on the path from a I0 to a0(yi).\nNot every pair (a, ~\u03c3), however, corresponds to an assignment in Wm0 because some paths in ~\u03c3 may not exist in our I0: GT represents possible paths in all models for the fixed TBox T and varying ABox. As follows from the unraveling procedure, a point in Wm0 \\W0 corresponds to a \u2208 ob(A) and \u03c3 = ([R], . . . ) \u2208 \u03a3T ,m0 iff a does not have enough R-witnesses in A, i.e., iff AA |= \u00ac\u03c80\u2265q R[a] \u2227 \u03c8\u2265q R[a], for some q \u2208 QRT . Thus, for every (a, ~\u03c3) with ~\u03c3 = (\u03c31, . . . , \u03c3k), there is an assignment a0 in Wm0 with split(a0) = (a, ~\u03c3) iff AA |=a \u03b7~\u03c3(~y), where\n\u03b7(\u03c31,...,\u03c3k)(y1, . . . , yk) = \u2227\n1\u2264i\u2264k \u03c3i 6=\u03b5\n\u2228 q\u2208QRiT ( \u00ac\u03c80\u2265q Ri(yi) \u2227 \u03c8\u2265q Ri(yi) ) and each Ri, for 1 \u2264 i \u2264 k with \u03c3i 6= \u03b5, is such that \u03c3i = ([Ri], . . . ).\nWe define now, for every ~\u03c3 \u2208 \u03a3kT ,m0 , concept name A and role name R,\nA~\u03c3(t) =\n{ \u03c8A(t), if t ~\u03c3 = \u03b5,\n\u03b8A,inv(ds), if t ~\u03c3 = \u03c3\u2032.[S], for some \u03c3\u2032 \u2208 \u03a3T ,m0 ,\nR~\u03c3(t1, t2) =  RT (t1, t2), if t ~\u03c3 1 = t ~\u03c3 2 = \u03b5, (t1 = t2), if t ~\u03c3 1 R\u2192 t~\u03c32 and either t~\u03c31 6= \u03b5 or t~\u03c32 6= \u03b5,\n\u22a5, otherwise,\nwhere RT (y1, y2) is given by (47). We claim that, for every assignment a0 in Wm0 and (a, \u03c3) = split(a0),\nI0 |=a0 A(t) iff AA |=a A~\u03c3(t), for all concept names A and terms t, (76) I0 |=a0 R(t1, t2) iff AA |=a R~\u03c3(t1, t2), for all roles R and terms t1, t2. (77)\nFor A(a), A(xi) or A(yi) with \u03c3i = \u03b5 the claim follows from (74). For A(yi) with \u03c3i = \u03c3 \u2032.[S], by (copy), we have cp(a(yi)) = inv(dr), for some R \u2208 [S]; the claim then follows from (75). For R(yi1 , yi2) with \u03c3i1 = \u03c3i2 = \u03b5, the claim follows from (ABox). Let us consider the case of R(yi1 , yi2) with \u03c3i2 6= \u03b5: we have a0(yi2) /\u2208W0 and thus, by (role), I0 |=a0 R(yi1 , yi2) iff\n\u2022 a0(yi1), a0(yi2) are in the same tree Ta, for a \u2208 ob(A), i.e., AA |=a (yi1 = yi2),\n\u2022 and either (a0(yi1), a0(yi2)) \u2208 Ea and then `a(a0(yi1), a0(yi2)) = S for some S v\u2217T R, or (a0(yi2), a0(yi1)) \u2208 Ea and then `a(a0(yi2), a0(yi1)) = S for some inv(S) v\u2217T R, or a0(yi1) = a0(yi2) and then Id v\u2217T R, i.e., \u03c3i1 R\u2192 \u03c3i2 .\nOther cases are similar and left to the reader. Finally, let \u03d5~\u03c3(~x, ~y) be the result of attaching the superscript ~\u03c3 to each atom of \u03d5 and\n\u03d5T ,q(~x) = \u2203~y \u2228\n~\u03c3\u2208\u03a3kT ,m0\n( \u03d5~\u03c3(~x, ~y) \u2227 \u03b7~\u03c3(~y) ) .\nAs follows from (76)\u2013(77), for every assignment a0 in Wm0 , we have I0 |=a0 \u03d5(~x, ~y) iff AA |=a \u03d5~\u03c3(~x, ~y) for (a, \u03c3) = split(a0). For the converse direction notice that, if AA |=a \u03b7~\u03c3(~y) then there is an assignment a0 in Wm0 with split(a0) = (a, ~\u03c3).\nClearly, AA |= \u03d5T ,q(~a) iff I0 |= q(~a), for every tuple ~a. We also note that, for every pair of tuples ~a and ~b of object names in ob(A), \u03d5~\u03c3(~a,~b) is a positive existential sentence with inequalities, and so is domain-independent.10 It is also easily seen that, for each ~b, \u03b7~\u03c3(~b) is domain-independent. It follows from the minimality of I0 that \u03d5T ,q(~a) is domainindependent, for each tuple ~a of object names in ob(A).\nFinally, note that the resulting query contains \u2264 |role\u00b1(T )|k\u00b7(k+|role\u00b1(T )|) disjuncts. q\n8. DL-Lite without the Unique Name Assumption\nIn this section, unless otherwise stated, we assume that the interpretations do not respect the UNA, that is, we may have aIi = a I j for distinct object names ai and aj . The consequence relation |=noUNA refers to the class of such interpretations. Description logics without the UNA are usually extended with additional equality and inequality constraints of the form:\nai \u2248 aj and ai 6\u2248 aj ,\nwhere ai, aj are object names. Their semantics is quite obvious: we have I |= ai \u2248 aj iff aIi = a I j , and I |= ai 6\u2248 aj iff aIi 6= aIj . The equality and inequality constraints are supposed to belong to the ABox part of a knowledge base. It is to be noted, however, that reasoning with equalities is LogSpace-reducible to reasoning without them:\nLemma 8.1 For every KB K = (T ,A), one can construct in LogSpace in the size of A a KB K\u2032 = (T ,A\u2032) without equality constraints such that I |= K iff I |= K\u2032, for every interpretation I.\nProof Let G = (V,E) be the undirected graph with V = ob(A), E = { (ai, aj) | ai \u2248 aj \u2208 A or aj \u2248 ai \u2208 A }\nand [ai] the set of all vertices of G that are reachable from ai. Define A\u2032 by removing all the equality constraints from A and replacing every ai with aj \u2208 [ai] with minimal j. Note that this minimal j can be computed in LogSpace: just enumerate the object names aj with respect to the order of their indexes j and check whether the current aj is reachable from ai in G. It remains to recall that reachability in undirected graphs is SLogSpace-complete and that SLogSpace = LogSpace (Reingold, 2008). q\nAs we mentioned in Section 5.3, the logics of the form DL-LiteH\u03b1 do not \u2018feel\u2019 whether we adopt the UNA or not. With this observation and Lemmas 5.17, 5.18 and 8.1 at hand, we obtain the following result as a consequence of Theorem 5.13:\n10. A query q(~x) is said to be domain-independent in case AA |=a q(~x) iff A |=a q(~x), for each A such that the domain of A contains ob(A), the active domain of AA, and AA = AAA and PA = PAA , for all concept and role names A and P .\nTheorem 8.2 With or without the UNA, for combined complexity, (i) satisfiability of DL-LiteHbool KBs is NP-complete; (ii) satisfiability of DL-Lite H horn KBs is P-complete; and (iii) satisfiability of DL-LiteHkrom and DL-Lite H core KBs is NLogSpace-complete. These results hold even if the KBs contain role disjointness, (a)symmetry, (ir)reflexivity and transitivity constraints, equalities and inequalities.\nOn the other hand, from Corollary 6.2 and Lemmas 5.17, 5.18 and 8.1 we can derive the following:\nTheorem 8.3 Without the UNA, satisfiability and instance checking for DL-LiteHbool KBs are in AC0 for data complexity. These problems are also in AC0 if the KBs contain role disjointness, (a)symmetry and (ir)reflexivity constraints and inequalities. However, they are LogSpace-complete if the KBs may contain equalities, and NLogSpace-complete if role transitivity constraints are allowed.\nWe also note that our complexity results (Corollary 5.12, Theorems 6.5, 6.6 and 6.7) for the logics DL-LiteHF\u03b1 and DL-Lite HN \u03b1 do not depend on the UNA.\nIn this section, we analyze the combined and data complexity of reasoning in the logics\nof the form DL-Lite (HF) \u03b1 and DL-Lite (HN ) \u03b1 (as well as their fragments) without the UNA. The obtained and known results are summarized in Table 2 on page 17.\n8.1 DL-Lite (HN ) \u03b1 : Arbitrary Number Restrictions\nThe following theorem shows that the interaction between number restrictions and the possibility of identifying objects in the ABox results in a higher complexity.\nTheorem 8.4 Without the UNA, satisfiability of DL-LiteNcore KBs (even without equality and inequality constraints) is NP-hard for both combined and data complexity.\nProof The proof is by reduction of the following variant of the 3SAT problem\u2014called monotone one-in-three 3SAT\u2014which is known to be NP-complete (Garey & Johnson, 1979): given a positive 3CNF formula\n\u03d5 = n\u2227 k=1 ( ak,1 \u2228 ak,2 \u2228 ak,3 ) ,\nwhere each ak,j is one of the propositional variables a1, . . . , am, decide whether there is an assignment for the variables aj such that exactly one variable is true in each of the clauses in \u03d5. To encode this problem in the language of DL-LiteNcore, we need object names a k i , for 1 \u2264 k \u2264 n, 1 \u2264 i \u2264 m, and ck and tk, for 1 \u2264 k \u2264 n, role names S and P , and concept names A1, A2, A3. Let A\u03d5 be the ABox containing the following assertions:\nS(a1i , a 2 i ), . . . , S(a n\u22121 i , a n i ), S(a n i , a 1 i ), for 1 \u2264 i \u2264 m, S(t1, t2), . . . , S(tn\u22121, tn), S(tn, t1),\nP (ck, t k), for 1 \u2264 k \u2264 n, P (ck, a k k,j), Aj(a k k,j), for 1 \u2264 k \u2264 n, 1 \u2264 j \u2264 3,\nand let T be the TBox with the following axioms:\nA1 v \u00acA2, A2 v \u00acA3, A3 v \u00acA1, \u2265 2S v \u22a5, \u2265 4P v \u22a5.\nClearly, (T ,A\u03d5) is a DL-LiteNcore KB and T does not depend on \u03d5 (so that we cover both combined and data complexity). We claim that the answer to the monotone one-in-three 3SAT problem is positive iff (T ,A\u03d5) is satisfiable without the UNA.\n(\u21d0) Suppose I |= (T ,A\u03d5). Define an assignment a of the truth values f and t to propositional variables by taking a(ai) = t iff (a 1 i ) I = (t1)I . Our aim is to show that a(ak,j) = t for exactly one j \u2208 {1, 2, 3}, for each k, 1 \u2264 k \u2264 n. For all j \u2208 {1, 2, 3}, we have (cIk , (a k k,j) I) \u2208 P I . Moreover, (akk,i)I 6= (akk,j)I for i 6= j. As cIk \u2208 (\u2264 3P )I and (cIk , (t k)I) \u2208 P I , we then must have (akk,j)I = (tk)I for some unique j \u2208 {1, 2, 3}. It follows from functionality of S that, for each 1 \u2264 k \u2264 n, we have (a1k,j)I = (t1)I for exactly one j \u2208 {1, 2, 3}.\n(\u21d2) Let a be an assignment satisfying the monotone one-in-three 3SAT problem. Take some ai0 with a(ai0) = t (clearly, such an i0 exists, for otherwise a(\u03d5) = f) and construct an interpretation I = (\u2206I , \u00b7I) by taking:\n\u2022 \u2206I = { yk, z k | 1 \u2264 k \u2264 n } \u222a { xki | a(ai) = f, 1 \u2264 i \u2264 m, 1 \u2264 k \u2264 n } ,\n\u2022 cIk = yk and (tk)I = zk, for 1 \u2264 k \u2264 n,\n\u2022 (aki )I =\n{ xki , if a(ai) = f,\nzk, if a(ai) = t, for 1 \u2264 i \u2264 m, 1 \u2264 k \u2264 n,\n\u2022 SI = {\n((a1i ) I , (a2i ) I), . . . , ((an\u22121i ) I , (ani ) I), ((ani ) I , (a1i )\nI) | 1 \u2264 i \u2264 m } ,\n\u2022 P I = {\n(cIk , (t k)I), (cIk , (a k k,1) I), (cIk , (a k k,2) I), (cIk , (a k k,3) I) | 1 \u2264 k \u2264 n\n} .\nIt is readily checked that I |= (T ,A\u03d5). q\nIn fact, the above lower bound is optimal:\nTheorem 8.5 Without the UNA, satisfiability of DL-LiteN\u03b1 , DL-Lite (HN ) \u03b1 and DL-Lite (HN )+ \u03b1 KBs with equality and inequality constraints is NP-complete for both combined and data complexity and any \u03b1 \u2208 {core, krom, horn, bool}.\nProof The lower bound is immediate from Theorem 8.4, and the matching upper bound can be proved by the following non-deterministic algorithm. Given a DL-Lite (HN )+ bool KB K = (T ,A), we\n\u2022 guess an equivalence relation \u223c over ob(A);\n\u2022 select in each equivalence class ai/\u223c a representative, say ai, and replace every occurrence of a \u2208 ai/\u223c in A with ai;\n\u2022 fail if the equalities and inequalities are violated in the resulting ABox\u2014i.e., if it contains ai 6\u2248 ai or ai \u2248 aj , for i 6= j;\n\u2022 otherwise, remove the equality and inequality constraints from the ABox and denote the result by A\u2032;\n\u2022 use the NP satisfiability checking algorithm for DL-Lite(HN ) +\nbool to decide whether the KB K\u2032 = (T ,A\u2032) is consistent under the UNA.\nClearly, if the algorithm returns \u2018yes,\u2019 then I \u2032 |= K\u2032, for some I \u2032 respecting the UNA, and we can construct a model I of K (not necessarily respecting the UNA) by extending I \u2032 with the following interpretation of object names: aI = aI\n\u2032 i , whenever ai is the representative\nof a/\u223c (I coincides with I \u2032 on all other symbols). Conversely, if I |= K then we take the equivalence relation \u223c defined by ai \u223c aj iff aIi = aIj . Let I \u2032 be constructed from I by removing the interpretations of all object names that are not representatives of the equivalence classes for \u223c. It follows that I \u2032 respects the UNA and I \u2032 |= K\u2032, so the algorithm returns \u2018yes.\u2019 q\n8.2 DL-Lite (HF) \u03b1 : Functionality Constraints Let us consider now DL-Lite (HF)+ bool and its fragments. The following lemma shows that for these logics reasoning without the UNA can be reduced in polynomial time in the size of the ABox to reasoning under the UNA.\nLemma 8.6 For every DL-Lite (HF)+ bool KB K = (T ,A) with equality and inequality constraints, one can construct in polynomial time in |A| a DL-Lite(HF) +\nbool KB K \u2032 = (T ,A\u2032) such\nthat A\u2032 contains no equalities and inequalities and K is satisfiable without the UNA iff K\u2032 is satisfiable under the UNA.\nProof In what follows by identifying aj with ak in A we mean replacing each occurrence of ak in A with aj . We construct A\u2032 by first identifying aj with ak, for each aj \u2248 ak \u2208 A, and removing the equality from A, and then exhaustively applying the following procedure to A:\n\u2022 if \u2265 2R v \u22a5 \u2208 T and R(ai, aj), R(ai, ak) \u2208 CleT (A), for distinct aj and ak, then identify aj with ak (recall that a functional R cannot have transitive sub-roles and thus CleT (A) is enough).\nIf the resulting ABox contains ai 6\u2248 ai, for some ai, then, clearly, K is not satisfiable, so we add A(ai) and \u00acA(ai) to the ABox, for some concept name A. Finally, we remove all inequalities from the ABox and denote the result by A\u2032. It should be clear that A\u2032 is computed from A in polynomial time and that, without the UNA, K is satisfiable iff K\u2032 is satisfiable. So it suffices to show that K\u2032 is satisfiable without the UNA iff it is satisfiable under the UNA. The implication (\u21d0) is trivial.\n(\u21d2) Observe that the above procedure ensures that\nqeR,a \u2264 1, for each R with \u2265 2S v \u22a5 \u2208 T , R v\u2217T S and a \u2208 ob(A\u2032)\n(see page 37 for definitions). Let K\u2032\u2032 be the DL-Lite(HN ) \u2212\nbool KB provided by Lemma 5.17 for K\u2032. It follows from the above property and the proofs of Lemma 5.14 and Corollary 5.16\nthat if K\u2032\u2032 is satisfiable without the UNA then (K\u2032\u2032)\u2021e is satisfied in a first-order model with some constants interpreted by the same domain element. As (K\u2032\u2032)\u2021e is a universal first-order sentence containing no equality, it is satisfiable in a first-order model such that all constants are interpreted by distinct elements. It follows from the proofs of Lemma 5.14 and Corollary 5.16 that this first-order model can be unraveled into a model J for K\u2032\u2032 respecting the UNA. By Lemma 5.17, J is a model of K\u2032. q\nThe reduction above cannot be done better than in P, as shown by the next theorem:\nTheorem 8.7 Without the UNA, satisfiability of DL-LiteFcore KBs (even without equality and inequality constraints) is P-hard for both combined and data complexity.\nProof The proof is by reduction of the entailment problem for Horn-CNF (as in the proof of Theorem 6.7). Let\n\u03d5 = n\u2227 k=1 ( ak,1 \u2227 ak,2 \u2192 ak,3 ) \u2227 p\u2227 l=1 al,0\nbe a Horn-CNF formula, where each ak,j and each al,0 is one of the propositional variables a1, . . . , am and ak,1, ak,2, ak,3 are all distinct, for each k, 1 \u2264 k \u2264 n. To encode the Pcomplete problem \u2018\u03d5 |= ai?\u2019 in the language of DL-LiteFcore we need object names t, aki , for 1 \u2264 k \u2264 n, 1 \u2264 i \u2264 m, and fk and gk, for 1 \u2264 k \u2264 n, and role names P , Q, S and T . The ABox A contains the following assertions\nS(a1i , a 2 i ), . . . , S(a n\u22121 i , a n i ), S(a n i , a 1 i ), for 1 \u2264 i \u2264 m, P (akk,1, fk), P (a k k,2, gk), Q(gk, a k k,3), Q(fk, a k k,1), for 1 \u2264 k \u2264 n, T (t, a1l,0), for 1 \u2264 l \u2264 p,\nand the TBox T asserts that all of the roles are functional:\n\u2265 2P v \u22a5, \u2265 2Q v \u22a5, \u2265 2S v \u22a5 and \u2265 2T v \u22a5.\nClearly, K = (T ,A) is a DL-LiteFcore KB and T does not depend on \u03d5. We claim that \u03d5 |= aj iff (T ,A\u222a {\u00acT (t, a1j )}) is not satisfiable without the UNA. To show this, it suffices to prove that \u03d5 |= aj iff K |=noUNA T (t, a1j ).\n(\u21d2) Suppose \u03d5 |= aj . Then we can derive aj from \u03d5 using the following inference rules:\n\u2022 \u03d5 |= al,0 for each l, 1 \u2264 l \u2264 p;\n\u2022 if \u03d5 |= ak,1 and \u03d5 |= ak,2, for some k, 1 \u2264 k \u2264 n, then \u03d5 |= ak,3.\nWe show that K |=noUNA T (t, a1j ) by induction on the length of the derivation of aj from \u03d5. The basis of induction is trivial. So assume that aj = ak,3, \u03d5 |= ak,1, \u03d5 |= ak,2, for some k, 1 \u2264 k \u2264 n, and that K |=noUNA T (t, a1k,1) \u2227 T (t, a1k,2). Suppose also that I |= K. Since T is functional, we have (a1k,1) I = (a1k,2) I . Since S is functional, (ak \u2032 k,1) I = (ak \u2032 k,2) I , for all k\u2032, 1 \u2264 k\u2032 \u2264 n, and in particular, for k\u2032 = k. Then, since P is functional, fIk = gIk , from which, by functionality of Q, (akk,3) I = (akk,1) I . Finally, since S is functional, (ak \u2032 k,3) I = (ak \u2032 k,1) I ,\nfor all k\u2032, 1 \u2264 k\u2032 \u2264 n, and in particular, for k\u2032 = 1. Thus, I |= T (t, a1j ) and therefore K |=noUNA T (t, a1j ).\n(\u21d0) Suppose that \u03d5 6|= aj . Then there is an assignment a such that a(\u03d5) = t and a(aj) = f. Construct an interpretation I by taking\n\u2022 \u2206I = { xki | a(ai) = f, 1 \u2264 k \u2264 n, 1 \u2264 i \u2264 m } \u222a { zk, uk, vk | 1 \u2264 k \u2264 n } \u222a { w } ,\n\u2022 (aki )I =\n{ xki , if a(ai) = f,\nzk, if a(ai) = t, for 1 \u2264 k \u2264 n and 1 \u2264 i \u2264 m,\n\u2022 tI = w, T I = { (w, z1) } ,\n\u2022 SI = {\n((a1i ) I , (a2i ) I), . . . , ((an\u22121i ) I , (ani ) I), ((ani ) I , (a1i )\nI) | 1 \u2264 i \u2264 m } ,\n\u2022 fIk = uk and gIk =\n{ vk, if a(ak,2) = f,\nuk, if a(ak,2) = t, for 1 \u2264 k \u2264 n,\n\u2022 P I = {\n((akk,1) I , fIk ), ((a k k,2) I , gIk ) | 1 \u2264 k \u2264 n\n} ,\n\u2022 QI = {\n(gIk , (a k k,3) I), (fIk , (a k k,1) I) | 1 \u2264 k \u2264 n\n} .\nIt is readily checked that I |= K and I 6|= T (t, a1j ), and so K 6|=noUNA T (t, a1j ). q\nThe above result strengthens the NLogSpace lower bound for instance checking in DL-LiteFcore proved by Calvanese et al. (2008).\nCorollary 8.8 Without the UNA, satisfiability of DL-LiteF\u03b1 , DL-Lite (HF) \u03b1 and DL-Lite (HF)+ \u03b1 KBs, \u03b1 \u2208 {core, krom, horn}, with equalities and inequalities is P-complete for both combined and data complexity.\nWithout the UNA, satisfiability of DL-LiteFbool, DL-Lite (HF) bool and DL-Lite (HF)+ bool KBs with equalities and inequalities is NP-complete for combined complexity and P-complete for data complexity.\nProof The upper bounds follow from Lemma 8.6 and the corresponding upper bounds for the UNA case. The NP lower bound for combined complexity is obvious and the polynomial lower bounds follow from Theorem 8.7. q"}, {"heading": "8.3 Query Answering: Data Complexity", "text": "The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al., 2006, 2008; Glimm et al., 2007), respectively (see the discussion at the beginning of Section 7). We present here the following result:\nTheorem 8.9 Without the UNA, positive existential query answering for DL-LiteHhorn KBs with role disjointness, (a)symmetry, (ir)reflexivity constraints and inequalities is in AC0 for data complexity. This problem is LogSpace-complete if, additionally, equalities are allowed in the KBs.\nProof The proof follows the lines of the proof of Theorem 7.1 and uses the observation that models without the UNA give no more answers than their untangled counterparts. More precisely, let KB K\u2032 = (T \u2032,A\u2032) be as above. Suppose that it is consistent. Let q(~x) be a positive existential query in the signature of K\u2032. Given K\u2032, Lemma 5.17 provides us with a KB K. It is easy to see that K is a DL-LiteHhorn KB extended with inequality constraints. The following is an analogue of Lemma 7.2, which also allows us to get rid of those inequalities:\nLemma 8.10 For every tuple ~a of object names in K\u2032, we have K\u2032 |=noUNA q(~a) iff I |= q(~a) for all untangled models I of K (respecting the UNA).\nProof (\u21d2) Suppose that K\u2032 |=noUNA q(~a) and I is an untangled model of K. As I respects the UNA, by Lemma 5.17 and in view of satisfiability of K\u2032, which ensures that (44) holds, we then have I |= K\u2032 and therefore, I |= q(~a).\n(\u21d0) Suppose I \u2032 |= K\u2032. We construct an interpretation J \u2032 respecting the UNA as follows. Let \u2206J \u2032 be the disjoint union of \u2206I \u2032 and ob(A). Define a function h : \u2206J \u2032 \u2192 \u2206I\u2032 by taking h(a) = aI \u2032 , for each a \u2208 ob(A), and h(w) = w, for each w \u2208 \u2206I\u2032 , and let\naJ \u2032 = a, AJ \u2032 = { u | h(u) \u2208 AI\u2032 } and PJ \u2032 = { (u, v) | (h(x), h(v)) \u2208 P I\u2032 } ,\nfor each object, concept and role name a, A, P . Clearly, J \u2032 respects the UNA and J \u2032 |= K\u2032. It also follows that h is a homomorphism.\nBy Lemma 5.17, there is a model I of K with the same domain as J \u2032 that coincides with J \u2032 on all symbols in K\u2032. As I |= q(~a), we must then have J \u2032 |= q(~a), and since h is a homomorphism, I \u2032 |= q(~a). Therefore, K\u2032 |=noUNA q(~a) as required. q\nThe remaining part of the proof is exactly as in Theorem 7.1 (since now we may assume that K is a DL-LiteHhorn KB containing no inequality constraints).\nLogSpace-completeness for the case with equalities follows from Lemma 8.1. q"}, {"heading": "9. Conclusion", "text": "In this article, we investigated the boundaries of the \u2018extended DL-Lite family\u2019 of description logics by providing a thorough and comprehensive understanding of the interaction between various DL-Lite constructs and their impact on the computational complexity of reasoning. We studied 40 different logics, classified according to five mutually orthogonal features: (1) the presence or absence of role inclusion assertions, (2) the form of the allowed concept inclusion assertions, distinguishing four main logical groups called core, Krom, Horn, and Bool, (3) the form of the allowed numeric constraints, ranging from none, to global functionality constraints only, and to arbitrary number restrictions, (4) the presence or absence of the unique name assumption (and equalities and inequalities between object names, if this assumption is dropped), and (5) the presence or absence of standard role constraints such as role disjointness, role symmetry, asymmetry, reflexivity, irreflexivity and transitivity. For all of the resulting logics, we studied the combined and data complexity of KB satisfiability and instance checking, as well as the data complexity of answering positive existential queries.\nThe obtained tight complexity results are illustrated in Figure 6, where the combined complexity of satisfiability is represented by the height of vertical dashed lines, while the data complexity of instance checking by the size and color of the circle on top of these lines (recall that satisfiability and instance checking are reducible to the complement of each other). The data complexity of query answering for the core and Horn logics, shown on the left-hand side of the separating vertical plane, coincides with the data complexity of instance checking; for the Krom and Bool logics, shown on the right-hand side of the plane, query answering is always data-complete for coNP. The upper layer shows the complexity of logics with role inclusions, in which case it does not depend on whether we adopt the UNA or not. The middle and the lower layers deal with the logics without role inclusions when the UNA is dropped or adopted, respectively. In each of these layers, the twelve languages are arranged in the 4 \u00d7 3 grid: one axis shows the type of concepts inclusions allowed (Horn, core, Krom, Bool), while the other the type of number restrictions (none, global functionality F or arbitrary N ). Some observations are in order:\n\u2022 Under the UNA but without role inclusions, number restrictions do not increase the complexity of reasoning, which depends only on the form of concept inclusions allowed.\n\u2022 On the other hand, without any form of number restrictions, the logics can have role inclusions and are insensitive to the UNA; again, the complexity is determined by the shape of concept inclusions only.\n\u2022 In either of the above cases, instance checking is in AC0 for data complexity, which means that the problems are first-order rewritable.\n\u2022 Without UNA adopted and without either disjunctions or role inclusions, functionality leads to P-completeness of instance checking for data complexity, which suggests its reducibility to Datalog.\n\u2022 For data complexity, there is no difference between the core and Horn logics, and between the Krom and Bool ones, which means that the core and Krom logics can be extended with conjunctions on the left-hand side of concept inclusions \u2018for free.\u2019\nFinally, for the logics DL-Lite (HF) \u03b1 and DL-Lite (HN ) \u03b1 with both (qualified) number restrictions and role inclusions, whose interaction is restricted by conditions (A1)\u2013(A3), the complexity of reasoning always coincides with the complexity of the fragments DL-LiteF\u03b1 and, respectively, DL-LiteN\u03b1 without role inclusions, no matter whether we adopt the UNA or not.\nRole disjointness, symmetry and asymmetry constraints can be added to any of the\nlanguages without changing their complexity. In fact, the DL-Lite (HN ) \u03b1 and DL-Lite (HF) \u03b1 logics contain all of the above types of constraints together with role reflexivity and irreflexivity. We conjecture that (ir)reflexivity constraints can be added to all other logics without affecting their complexity. However, if we extend any DL-Lite logic with role transitivity constraints, then the combined complexity of satisfiability remains the same, while instance checking and query answering become data-hard for NLogSpace. And the addition of equality between object names\u2014which only makes sense if the UNA is dropped\u2014leads to an increase from membership in AC0 to LogSpace-completeness for data complexity; all other results remain unchanged.\nThe list of DL constructs considered in this paper is far from being complete. For example, it would be of interest to analyze the impact of nominals, role chains and Boolean operators on roles on the computational behavior of the DL-Lite logics. Another interesting and practically important problem is to investigate in depth the interaction between various constructs with the aim of pushing restrictions like (A1)\u2013(A3) as far as possible.\nOne of the main ideas behind the DL-Lite logics was to provide efficient access to large amounts of data through a high-level conceptual interface. This is supposed to be achieved by representing the high-level view of the information managed by the system as a DL-Lite TBox T , the data stored in a relational database as an ABox A, and then rewriting positive existential queries to the knowledge base (T ,A) as standard first-order queries to the database represented by A. Such an approach is believed to be viable because, for a number of DL-Lite logics, the query answering problem is in AC0 for data complexity; cf. Theorems 7.1, 8.9 and Figure 6. The first-order rewriting technique has been implemented in various system, notably in QuOnto (Acciarri et al., 2005; Poggi et al., 2008b), which can query, relying on ontology-to-relational mappings, data stored in any standard relational database management system, and in Owlgres (Stocker & Smith, 2008), which can access an ABox stored in a Postgres database (though, to the best of our knowledge, the latter implementation is incomplete for conjunctive query answering). It is to be noted, however, that the size of the rewritten query can be substantially larger than the size of the original query, which can cause problems even for a very efficient database query engine.\nFor a positive existential query q and TBox T , there are two major sources of high complexity of the first-order formula \u03d5T ,q in the proof of Theorem 7.1: (i) the formulas \u03c8B(x) computing whether an ABox object is an instance of a concept B (and the formulas\n\u03b8R,dr computing whether objects with outgoing R-arrows are instances of B), and (ii) the disjunction over the paths ~\u03c3 in the graph GT . In the case of DL-Lite (HN ) core , the size of \u03c8B(x) is linear in |T |, while for DL-Lite(HN )horn it can become exponential (however, various optimizations are possible). The size of the disjunction in (ii) is exponential in the number of non-distinguished variables in q. One way of removing source (i) would be to extend the given database (ABox) A by precomputing the Horn closure of the ABox with respect to the TBox and storing the resulting data in a supplementary database. This approach is advocated by Lutz et al. (2008) for querying databases via the description logic EL. It could also be promising for the Horn fragments of expressive description logics such as SHIQ (Hustadt et al., 2005; Hustadt, Motik, & Sattler, 2007)\u2014containing DL-LiteHFhorn as a sub-language\u2014for which the data complexity of instance checking (Hustadt et al., 2005, 2007) and conjunctive query answering is polynomial (Eiter et al., 2008). The disadvantage of using a supplementary database is the necessity to update it every time the ABox is changed. It would be interesting to investigate this alternative approach for DL-Lite logics and compare it with the approach described above. Another important problem is to characterize those queries for which the disjunction in (ii) can be represented by a formula of polynomial size.\nAs the unique name assumption is replaced in OWL by the constructs sameAs and differentFrom (i.e., \u2248 and 6\u2248), a challenging problem is to investigate possible ways of dealing with equality (inequality does not require any special treatment as shown in the proof of Lemma 8.10). Although reasoning with equality is LogSpace-reducible to reasoning without it (cf. Lemma 8.1), we lose the property of first-order rewritability, and computing equivalence classes under \u2248 may be too costly for real-world applications.\nDL-Lite logics are among those few examples of DLs for which usually very complex \u2018non-standard\u2019 reasoning problems\u2014such as checking whether one ontology is a conservative extension of another one with respect to a given signature \u03a3 (Kontchakov et al., 2008), computing minimal modules of ontologies with respect to \u03a3 (Kontchakov et al., 2009) or uniform interpolants (Wang, Wang, Topor, & Pan, 2008)\u2014can be supported by practical reasoning tools. However, only first steps have been made in this direction, and more research is needed in order to include these reasoning problems and tools into the standard OWL toolkit. It would be also interesting to investigate the unification problem for DL-Lite logics (Baader & Narendran, 2001).\nFinally, there exist certain parallels between the Horn logics of the DL-Lite family, EL, Horn-SHIQ and the first-order language of tuple and equality generating dependencies, TGDs and EGDs, used in the theory of databases (see, e.g., Gottlob & Nash, 2008). Further investigations of the relationships between these logics may lead to a deeper understanding of the role description logics can play in the database framework."}, {"heading": "Acknowledgments", "text": "This research has been partially supported by FET project TONES (Thinking ONtologiES), funded within the EU 6th Framework Programme under contract FP6-7603, and by the large-scale integrating project (IP) OntoRule (ONTOlogies meet Business RULEs ONtologiES), funded by the EC under ICT Call 3 FP7-ICT-2008-3, contract number FP7231875. We thank the referees for their constructive criticism, comments, and suggestions."}], "references": [{"title": "QuOnto: Querying ontologies", "author": ["A. Acciarri", "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "M. Palmieri", "R. Rosati"], "venue": "In Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI", "citeRegEx": "Acciarri et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Acciarri et al\\.", "year": 2005}, {"title": "Logic programming", "author": ["K. Apt"], "venue": "van Leeuwen, J. (Ed.), Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics, pp. 493\u2013574. Elsevier and MIT Press.", "citeRegEx": "Apt,? 1990", "shortCiteRegEx": "Apt", "year": 1990}, {"title": "DL-Lite in the light of first-order logic", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 22nd Nat. Conf. on Artificial Intelligence (AAAI", "citeRegEx": "Artale et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2007}, {"title": "Reasoning over extended ER models", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "V. Ryzhikov", "M. Zakharyaschev"], "venue": "In Proc. of the 26th Int. Conf. on Conceptual Modeling (ER 2007),", "citeRegEx": "Artale et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2007}, {"title": "Describing database objects in a concept language environment", "author": ["A. Artale", "F. Cesarini", "G. Soda"], "venue": "IEEE Trans. on Knowledge and Data Engineering,", "citeRegEx": "Artale et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Artale et al\\.", "year": 1996}, {"title": "Evolving objects in temporal information systems", "author": ["A. Artale", "C. Parent", "S. Spaccapietra"], "venue": "Ann. of Mathematics and Artificial Intelligence,", "citeRegEx": "Artale et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2007}, {"title": "Unification of concepts terms in description logics", "author": ["F. Baader", "P. Narendran"], "venue": "J. of Symbolic Computation,", "citeRegEx": "Baader and Narendran,? \\Q2001\\E", "shortCiteRegEx": "Baader and Narendran", "year": 2001}, {"title": "The Description Logic Handbook: Theory, Implementation and Applications", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2003}, {"title": "Rewriting queries using views in description logics", "author": ["C. Beeri", "A.Y. Levy", "Rousset", "M.-C"], "venue": "In Proc. of the 16th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems", "citeRegEx": "Beeri et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Beeri et al\\.", "year": 1997}, {"title": "Reasoning on UML class diagrams", "author": ["D. Berardi", "D. Calvanese", "G. De Giacomo"], "venue": "Artificial Intelligence,", "citeRegEx": "Berardi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Berardi et al\\.", "year": 2005}, {"title": "On taxonomic reasoning in conceptual design", "author": ["S. Bergamaschi", "C. Sartori"], "venue": "ACM Trans. on Database Systems,", "citeRegEx": "Bergamaschi and Sartori,? \\Q1992\\E", "shortCiteRegEx": "Bergamaschi and Sartori", "year": 1992}, {"title": "The complexity of finite functions", "author": ["R. Boppana", "M. Sipser"], "venue": "Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity,", "citeRegEx": "Boppana and Sipser,? \\Q1990\\E", "shortCiteRegEx": "Boppana and Sipser", "year": 1990}, {"title": "The Classical Decision Problem", "author": ["E. B\u00f6rger", "E. Gr\u00e4del", "Y. Gurevich"], "venue": "Perspectives in Mathematical Logic. Springer", "citeRegEx": "B\u00f6rger et al\\.,? \\Q1997\\E", "shortCiteRegEx": "B\u00f6rger et al\\.", "year": 1997}, {"title": "Conceptual modeling with description logics", "author": ["A. Borgida", "R.J. Brachman"], "venue": "In Baader et al. (Baader et al., 2003),", "citeRegEx": "Borgida and Brachman,? \\Q2003\\E", "shortCiteRegEx": "Borgida and Brachman", "year": 2003}, {"title": "Ontology-based database access", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "R. Rosati"], "venue": "In Proc. of the 15th Ital. Conf. on Database Systems (SEBD", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Data integration through DL-LiteA ontologies", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "R. Rosati", "M. Ruzzi"], "venue": "Revised Selected Papers of the 3rd Int. Workshop on Semantics in Data and Knowledge Bases (SDKB 2008),", "citeRegEx": "Calvanese et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2008}, {"title": "DL-Lite: Tractable description logics for ontologies", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI", "citeRegEx": "Calvanese et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2005}, {"title": "Data complexity of query answering in description logics", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Calvanese et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2006}, {"title": "Can OWL model football leagues", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In Proc. of the 3rd Int. Workshop on OWL: Experiences and Directions (OWLED 2007),", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Inconsistency tolerance in P2P data integration: An epistemic logic approach", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Information Systems,", "citeRegEx": "Calvanese et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2008}, {"title": "Path-based identification constraints in description logics", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Calvanese et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2008}, {"title": "Description logics for information integration", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini"], "venue": "Essays in Honour of Robert A. Kowalski, Vol. 2408 of Lecture Notes in Computer Science,", "citeRegEx": "Calvanese et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2002}, {"title": "A framework for ontology integration", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini"], "venue": "The Emerging Semantic Web \u2014 Selected Papers from the First Semantic Web Working Symposium,", "citeRegEx": "Calvanese et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2002}, {"title": "Description logic framework for information integration", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini", "D. Nardi", "R. Rosati"], "venue": "In Proc. of the 6th Int. Conf. on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Calvanese et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 1998}, {"title": "Description logics for conceptual data modeling", "author": ["D. Calvanese", "M. Lenzerini", "D. Nardi"], "venue": "Logics for Databases and Information Systems,", "citeRegEx": "Calvanese et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 1998}, {"title": "Unifying class-based representation formalisms", "author": ["D. Calvanese", "M. Lenzerini", "D. Nardi"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Calvanese et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 1999}, {"title": "Filling the gap between OWL 2 QL and QuOnto: ROWLKit", "author": ["C. Corona", "M. Ruzzi", "D.F. Savo"], "venue": "In Proc. of the 22nd Int. Workshop on Description Logics (DL 2009),", "citeRegEx": "Corona et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Corona et al\\.", "year": 2009}, {"title": "Modular reuse of ontologies: Theory and practice", "author": ["B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Grau et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "Ontobroker: Ontology based access to distributed and semi-structured information", "author": ["S. Decker", "M. Erdmann", "D. Fensel", "R. Studer"], "venue": "Database Semantic: Semantic Issues in Multimedia Systems, chap", "citeRegEx": "Decker et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Decker et al\\.", "year": 1999}, {"title": "Scalable grounded conjunctive query evaluation over large and expressive knowledge bases", "author": ["J. Dolby", "A. Fokoue", "A. Kalyanpur", "L. Ma", "E. Schonberg", "K. Srinivas", "X. Sun"], "venue": "In Proc. of the 7th Int. Semantic Web Conf. (ISWC 2008),", "citeRegEx": "Dolby et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Dolby et al\\.", "year": 2008}, {"title": "Query answering in the description logic Horn-SHIQ", "author": ["T. Eiter", "G. Gottlob", "M. Ortiz", "M. \u0160imkus"], "venue": "In Proc. of the 11th Eur. Conference on Logics in Artificial Intelligence (JELIA", "citeRegEx": "Eiter et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2008}, {"title": "The i.com tool for intelligent conceptual modeling", "author": ["E. Franconi", "G. Ng"], "venue": "In Proc. of the 7th Int. Workshop on Knowledge Representation meets Databases (KRDB 2000),", "citeRegEx": "Franconi and Ng,? \\Q2000\\E", "shortCiteRegEx": "Franconi and Ng", "year": 2000}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completeness", "author": ["M. Garey", "D. Johnson"], "venue": null, "citeRegEx": "Garey and Johnson,? \\Q1979\\E", "shortCiteRegEx": "Garey and Johnson", "year": 1979}, {"title": "Did I damage my ontology? A case for conservative extensions in description logics", "author": ["S. Ghilardi", "C. Lutz", "F. Wolter"], "venue": "Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Ghilardi et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ghilardi et al\\.", "year": 2006}, {"title": "Conjunctive query answering for the description logic SHIQ", "author": ["B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler"], "venue": "In Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Glimm et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Glimm et al\\.", "year": 2007}, {"title": "The use of CARIN language and algorithms for information integration: The Picsel system", "author": ["F. Goasdoue", "V. Lattes", "Rousset", "M.-C"], "venue": "Int. J. of Cooperative Information Systems,", "citeRegEx": "Goasdoue et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Goasdoue et al\\.", "year": 2000}, {"title": "Efficient core computation in data exchange", "author": ["G. Gottlob", "A. Nash"], "venue": "J. of the ACM,", "citeRegEx": "Gottlob and Nash,? \\Q2008\\E", "shortCiteRegEx": "Gottlob and Nash", "year": 2008}, {"title": "RDF semantics", "author": ["P. Hayes"], "venue": "W3C Recommendation. http://www.w3.org/TR/ rdf-mt/.", "citeRegEx": "Hayes,? 2004", "shortCiteRegEx": "Hayes", "year": 2004}, {"title": "A portrait of the Semantic Web in action", "author": ["J. Heflin", "J. Hendler"], "venue": "IEEE Intelligent Systems,", "citeRegEx": "Heflin and Hendler,? \\Q2001\\E", "shortCiteRegEx": "Heflin and Hendler", "year": 2001}, {"title": "Ontology reasoning with large data repositories", "author": ["S. Heymans", "L. Ma", "D. Anicic", "Z. Ma", "N. Steinmetz", "Y. Pan", "J. Mei", "A. Fokoue", "A. Kalyanpur", "A. Kershenbaum", "E. Schonberg", "K. Srinivas", "C. Feier", "G. Hench", "B. Wetzstein", "U. Keller"], "venue": "Ontology Management,", "citeRegEx": "Heymans et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Heymans et al\\.", "year": 2008}, {"title": "Practical reasoning for very expressive description logics", "author": ["I. Horrocks", "U. Sattler", "S. Tobies"], "venue": "J. of the Interest Group in Pure and Applied Logic,", "citeRegEx": "Horrocks et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2000}, {"title": "Reasoning in description logics by a reduction to disjunctive Datalog", "author": ["U. Hustadt", "B. Motik", "U. Sattler"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Hustadt et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2007}, {"title": "Data complexity of reasoning in very expressive description logics", "author": ["U. Hustadt", "B. Motik", "U. Sattler"], "venue": "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Hustadt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2005}, {"title": "Descriptive Complexity", "author": ["N. Immerman"], "venue": "Springer.", "citeRegEx": "Immerman,? 1999", "shortCiteRegEx": "Immerman", "year": 1999}, {"title": "Resource description framework (RDF): Concepts and abstract syntax", "author": ["G. Klyne", "J.J. Carroll"], "venue": "W3C Recommendation", "citeRegEx": "Klyne and Carroll,? \\Q2004\\E", "shortCiteRegEx": "Klyne and Carroll", "year": 2004}, {"title": "Minimal module extraction from DL-Lite ontologies using QBF solvers", "author": ["R. Kontchakov", "L. Pulina", "U. Sattler", "T. Schneider", "P. Selmer", "F. Wolter", "M. Zakharyaschev"], "venue": "In Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Kontchakov et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2009}, {"title": "Can you tell the difference between DL-Lite ontologies", "author": ["R. Kontchakov", "F. Wolter", "M. Zakharyaschev"], "venue": "In Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Kontchakov et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2008}, {"title": "DL-Lite and role inclusions", "author": ["R. Kontchakov", "M. Zakharyaschev"], "venue": "Proc. of the 3rd Asian Semantic Web Conf. (ASWC 2008),", "citeRegEx": "Kontchakov and Zakharyaschev,? \\Q2008\\E", "shortCiteRegEx": "Kontchakov and Zakharyaschev", "year": 2008}, {"title": "Theory of Computation", "author": ["D. Kozen"], "venue": "Springer.", "citeRegEx": "Kozen,? 2006", "shortCiteRegEx": "Kozen", "year": 2006}, {"title": "Data integration: A theoretical perspective", "author": ["M. Lenzerini"], "venue": "Proc. of the 21st ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS 2002), pp. 233\u2013246.", "citeRegEx": "Lenzerini,? 2002", "shortCiteRegEx": "Lenzerini", "year": 2002}, {"title": "Combining Horn rules and description logics in CARIN", "author": ["A.Y. Levy", "Rousset", "M.-C"], "venue": "Artificial Intelligence,", "citeRegEx": "Levy et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Levy et al\\.", "year": 1998}, {"title": "Conceptual modelling for configuration: A description logic-based approach. Artificial Intelligence for Engineering Design, Analysis, and Manufacturing", "author": ["D. McGuinness", "J.R. Wright"], "venue": "Special Issue on Configuration,", "citeRegEx": "McGuinness and Wright,? \\Q1998\\E", "shortCiteRegEx": "McGuinness and Wright", "year": 1998}, {"title": "Knowledge integration for description logics", "author": ["T. Meyer", "K. Lee", "R. Booth"], "venue": "In Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI", "citeRegEx": "Meyer et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Meyer et al\\.", "year": 2005}, {"title": "Semantic integration: A survey of ontology-based approaches", "author": ["N.F. Noy"], "venue": "SIGMOD Record, 33 (4), 65\u201370.", "citeRegEx": "Noy,? 2004", "shortCiteRegEx": "Noy", "year": 2004}, {"title": "Characterizing data complexity for conjunctive query answering in expressive description logics", "author": ["M. Ortiz", "D. Calvanese", "T. Eiter"], "venue": "In Proc. of the 21st Nat. Conf. on Artificial Intelligence (AAAI", "citeRegEx": "Ortiz et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2006}, {"title": "Data complexity of query answering in expressive description logics via tableaux", "author": ["M. Ortiz", "D. Calvanese", "T. Eiter"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Ortiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2008}, {"title": "Computational Complexity", "author": ["C. Papadimitriou"], "venue": "Addison-Wesley.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "A comparison of query rewriting techniques for DL-Lite", "author": ["H. P\u00e9rez-Urbina", "B. Motik", "I. Horrocks"], "venue": "In Proc. of the 22nd Int. Workshop on Description Logics (DL 2009),", "citeRegEx": "P\u00e9rez.Urbina et al\\.,? \\Q2009\\E", "shortCiteRegEx": "P\u00e9rez.Urbina et al\\.", "year": 2009}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. on Data Semantics,", "citeRegEx": "Poggi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Poggi et al\\.", "year": 2008}, {"title": "Ontology-based database access with DIG-Mastro and the OBDA Plugin for Prot\u00e9g\u00e9", "author": ["A. Poggi", "M. Rodriguez", "M. Ruzzi"], "venue": "Proc. of the 4th Int. Workshop on OWL: Experiences and Directions (OWLED 2008 DC)", "citeRegEx": "Poggi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Poggi et al\\.", "year": 2008}, {"title": "A Concise Introduction to Mathematical Logic", "author": ["W. Rautenberg"], "venue": "Springer.", "citeRegEx": "Rautenberg,? 2006", "shortCiteRegEx": "Rautenberg", "year": 2006}, {"title": "Undirected connectivity in log-space", "author": ["O. Reingold"], "venue": "J. of the ACM, 55 (4).", "citeRegEx": "Reingold,? 2008", "shortCiteRegEx": "Reingold", "year": 2008}, {"title": "On the complexity of the instance checking problem in concept languages with existential quantification", "author": ["A. Schaerf"], "venue": "J. of Intelligent Information Systems, 2, 265\u2013278.", "citeRegEx": "Schaerf,? 1993", "shortCiteRegEx": "Schaerf", "year": 1993}, {"title": "Attributive concept descriptions with complements", "author": ["M. Schmidt-Schau\u00df", "G. Smolka"], "venue": "Artificial Intelligence,", "citeRegEx": "Schmidt.Schau\u00df and Smolka,? \\Q1991\\E", "shortCiteRegEx": "Schmidt.Schau\u00df and Smolka", "year": 1991}, {"title": "Owlgres: A scalable OWL reasoner", "author": ["M. Stocker", "M. Smith"], "venue": "In Proc. of the 5th Int. Workshop on OWL: Experiences and Directions (OWLED", "citeRegEx": "Stocker and Smith,? \\Q2008\\E", "shortCiteRegEx": "Stocker and Smith", "year": 2008}, {"title": "Complexity results and practical algorithms for logics in Knowledge Representation", "author": ["S. Tobies"], "venue": "Ph.D. thesis, LuFG Theoretical Computer Science, RWTH-Aachen, Germany.", "citeRegEx": "Tobies,? 2001", "shortCiteRegEx": "Tobies", "year": 2001}, {"title": "On the interaction between inverse features and pathfunctional dependencies in description logics", "author": ["D. Toman", "G.E. Weddell"], "venue": "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Toman and Weddell,? \\Q2005\\E", "shortCiteRegEx": "Toman and Weddell", "year": 2005}, {"title": "On keys and functional dependencies as first-class citizens in description logics", "author": ["D. Toman", "G.E. Weddell"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Toman and Weddell,? \\Q2008\\E", "shortCiteRegEx": "Toman and Weddell", "year": 2008}, {"title": "The complexity of relational query languages (extended abstract)", "author": ["M. Vardi"], "venue": "Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC\u201982), pp. 137\u2013146.", "citeRegEx": "Vardi,? 1982", "shortCiteRegEx": "Vardi", "year": 1982}, {"title": "Introduction to Circuit Complexity: A Uniform Approach", "author": ["H. Vollmer"], "venue": "Springer.", "citeRegEx": "Vollmer,? 1999", "shortCiteRegEx": "Vollmer", "year": 1999}, {"title": "Forgetting concepts in DL-Lite", "author": ["Z. Wang", "K. Wang", "R.W. Topor", "J.Z. Pan"], "venue": "Proc. of the 5th Eur. Semantic Web Conf. (ESWC 2008),", "citeRegEx": "Wang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 54, "context": "\u2022 information and data integration (Beeri, Levy, & Rousset, 1997; Levy & Rousset, 1998; Goasdoue, Lattes, & Rousset, 2000; Calvanese et al., 1998a, 2002a, 2002b, 2008; Noy, 2004; Meyer, Lee, & Booth, 2005),", "startOffset": 35, "endOffset": 205}, {"referenceID": 30, "context": "\u2022 ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al., 2008),", "startOffset": 29, "endOffset": 92}, {"referenceID": 40, "context": "\u2022 ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al., 2008),", "startOffset": 29, "endOffset": 92}, {"referenceID": 15, "context": "In this setting, the TBox constitutes the conceptual, high-level view of the information managed by the system, and the ABox is physically stored in a relational database and accessed using the standard relational database technology (Poggi et al., 2008a; Calvanese et al., 2008).", "startOffset": 234, "endOffset": 279}, {"referenceID": 14, "context": ", 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind of queries that have most often been considered are first-order conjunctive queries, which correspond to the commonly used Select-Project-Join SQL queries. The key properties for such an approach to be viable in practice are (i) efficiency of query evaluation, with the ideal target being traditional database query processing, and (ii) that query evaluation can be done by leveraging the relational technology already used for storing the data. With these objectives in mind, a series of description logics\u2014the DL-Lite family\u2014has recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov, and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati (2008a).", "startOffset": 9, "endOffset": 902}, {"referenceID": 14, "context": ", 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind of queries that have most often been considered are first-order conjunctive queries, which correspond to the commonly used Select-Project-Join SQL queries. The key properties for such an approach to be viable in practice are (i) efficiency of query evaluation, with the ideal target being traditional database query processing, and (ii) that query evaluation can be done by leveraging the relational technology already used for storing the data. With these objectives in mind, a series of description logics\u2014the DL-Lite family\u2014has recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov, and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati (2008a). Most logics of the family meet the requirements above and, at the same time, are capable of representing many important types of constraints used in conceptual modeling.", "startOffset": 9, "endOffset": 970}, {"referenceID": 47, "context": "It has also been demonstrated (Kontchakov et al., 2008) that developing, analyzing and re-using DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various types of entailment between such ontologies with respect to given vocabularies, in particular, by minimal module extraction tools (Kontchakov et al.", "startOffset": 30, "endOffset": 55}, {"referenceID": 46, "context": ", 2008) that developing, analyzing and re-using DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various types of entailment between such ontologies with respect to given vocabularies, in particular, by minimal module extraction tools (Kontchakov et al., 2009)\u2014which do not yet exist for richer languages.", "startOffset": 270, "endOffset": 295}, {"referenceID": 17, "context": "Although some attempts have been made (Calvanese et al., 2006; Artale et al., 2007a; Kontchakov & Zakharyaschev, 2008) to put the original DL-Lite logics into a more general perspective and investigate their extensions with a variety of DL constructs required for conceptual modeling, the resulting picture still remains rather fragmentary and far from comprehensive.", "startOffset": 38, "endOffset": 118}, {"referenceID": 14, "context": "It also turns out that dropping the UNA results in P-hardness of reasoning (for both combined and data complexity) in the presence of functionality constraints (NLogSpace-hardness was shown by Calvanese et al., 2008), and in NP-hardness if arbitrary number restrictions are allowed. Another interesting finding is the dramatic impact of role inclusions, when combined with number restrictions (or even functionality constraints), on the computational complexity of reasoning. As was already observed by Calvanese et al. (2006), such a combination increases data complexity of instance checking from membership in LogSpace to", "startOffset": 193, "endOffset": 527}, {"referenceID": 47, "context": "Note, by the way, that logics with Bool concept inclusions turn out to be quite useful in conceptual modeling and reasonably manageable computationally (Kontchakov et al., 2008).", "startOffset": 152, "endOffset": 177}, {"referenceID": 59, "context": "To retain both role inclusions and functionality constraints in the language and keep complexity within the required limits, Poggi et al. (2008a) introduced another DL-Lite dialect, called DL-LiteA, which restricts the interaction between role inclusions and functionality constraints.", "startOffset": 125, "endOffset": 146}, {"referenceID": 7, "context": "Description Logic (Baader et al., 2003) is a family of logics that have been studied and used in knowledge representation and reasoning since the 1980s.", "startOffset": 18, "endOffset": 39}, {"referenceID": 16, "context": "2 for details), while maintaining good computational properties of standard DL reasoning tasks (Calvanese et al., 2005).", "startOffset": 95, "endOffset": 119}, {"referenceID": 59, "context": "A compromise can be found by artificially limiting the interplay between role inclusions and number restrictions in a way similar to the logic DL-LiteA proposed by Poggi et al. (2008a). For a TBox T , let vT denote the reflexive and transitive closure of the relation { (R,R\u2032), (inv(R), inv(R\u2032)) | R v R\u2032 \u2208 T }", "startOffset": 164, "endOffset": 185}, {"referenceID": 9, "context": "A tight correspondence between conceptual modeling formalisms, such as the ER model and UML class diagrams, and various description logics has been pointed out in various papers (e.g., Calvanese et al., 1998b, 1999; Borgida & Brachman, 2003; Berardi et al., 2005).", "startOffset": 178, "endOffset": 263}, {"referenceID": 2, "context": "Here we give an example showing how DL-Lite logics can be used for conceptual modeling purposes; for more details see the work by Artale et al. (2007b).", "startOffset": 130, "endOffset": 152}, {"referenceID": 7, "context": "As is well known in DL (Baader et al., 2003), many other reasoning tasks for description logics are reducible to the satisfiability problem.", "startOffset": 23, "endOffset": 44}, {"referenceID": 69, "context": "If, however, only the ABox A is counted as an input, while the TBox T (and the query) is regarded to be fixed, then our concern is data complexity (Vardi, 1982).", "startOffset": 147, "endOffset": 160}, {"referenceID": 54, "context": "On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008).", "startOffset": 361, "endOffset": 454}, {"referenceID": 50, "context": "On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008).", "startOffset": 361, "endOffset": 454}, {"referenceID": 15, "context": "On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008).", "startOffset": 361, "endOffset": 454}, {"referenceID": 57, "context": "Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006).", "startOffset": 57, "endOffset": 135}, {"referenceID": 70, "context": "Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006).", "startOffset": 57, "endOffset": 135}, {"referenceID": 49, "context": "Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006).", "startOffset": 57, "endOffset": 135}, {"referenceID": 70, "context": "A typical example of an AC problem is evaluation of first-order queries over databases (or model checking of first-order sentences over finite models), where only the database (first-order model) is regarded as the input and the query (first-order sentence) is assumed to be fixed (Abiteboul, Hull, & Vianu, 1995; Vollmer, 1999).", "startOffset": 281, "endOffset": 328}, {"referenceID": 62, "context": "On the other hand, the undirected graph reachability problem is known to be in LogSpace (Reingold, 2008) but not in AC.", "startOffset": 88, "endOffset": 104}, {"referenceID": 63, "context": "[A] complexity of the respective fragment of propositional Boolean logic [B] follows from the proof of the data complexity result for instance checking in ALE (Schaerf, 1993) [C] (Calvanese et al.", "startOffset": 159, "endOffset": 174}, {"referenceID": 17, "context": "[A] complexity of the respective fragment of propositional Boolean logic [B] follows from the proof of the data complexity result for instance checking in ALE (Schaerf, 1993) [C] (Calvanese et al., 2006) [D] follows from Horn-SHIQ (Hustadt, Motik, & Sattler, 2005; Eiter, Gottlob, Ortiz, & \u0160imkus, 2008) [E] follows from SHIQ (Ortiz, Calvanese, & Eiter, 2006, 2008; Glimm, Horrocks, Lutz, & Sattler, 2007) [F] follows from SHIQ (Tobies, 2001)", "startOffset": 179, "endOffset": 203}, {"referenceID": 66, "context": ", 2006) [D] follows from Horn-SHIQ (Hustadt, Motik, & Sattler, 2005; Eiter, Gottlob, Ortiz, & \u0160imkus, 2008) [E] follows from SHIQ (Ortiz, Calvanese, & Eiter, 2006, 2008; Glimm, Horrocks, Lutz, & Sattler, 2007) [F] follows from SHIQ (Tobies, 2001)", "startOffset": 232, "endOffset": 246}, {"referenceID": 38, "context": "It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004).", "startOffset": 75, "endOffset": 111}, {"referenceID": 1, "context": "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore.", "startOffset": 50, "endOffset": 188}, {"referenceID": 1, "context": "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively.", "startOffset": 50, "endOffset": 531}, {"referenceID": 1, "context": "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2).", "startOffset": 50, "endOffset": 683}, {"referenceID": 1, "context": "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-Litecore. It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity.", "startOffset": 50, "endOffset": 1080}, {"referenceID": 1, "context": "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-Litecore. It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b) demonstrated how n-ary relations can be represented in DL-Litecore by means of reification.", "startOffset": 50, "endOffset": 1413}, {"referenceID": 1, "context": "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v \u00acB2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-Litecore. It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b) demonstrated how n-ary relations can be represented in DL-Litecore by means of reification. A further variant of DL-Lite, called DL-LiteA (\u2018A\u2019 for attributes), was introduced by Poggi et al. (2008a) with the aim of capturing as many features of conceptual modeling formalisms as possible, while still maintaining the computational properties of the basic variants of DL-Lite.", "startOffset": 50, "endOffset": 1612}, {"referenceID": 14, "context": "7, we prove that satisfiability of DL-LiteHF core KBs is ExpTime-hard for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness was shown by Calvanese et al., 2006). In DL-LiteA, to keep query answering in AC 0 for data complexity and satisfiability in NLogSpace for combined complexity, functional roles (and attributes) are not allowed to be specialized, i.e., used positively on the right-hand side of role (and attribute) inclusion axioms. So, condition (A3) is a slight generalization of this restriction. DL-LiteA also allows axioms of the form B v \u2203R.C for non-functional roles R, which is covered by conditions (A1) and (A2). Thus, DL-LiteA can be regarded as a proper fragment of both DL-Lite (HF) core and DL-Lite (HN ) horn . We show in Sections 5.3 and 7 that these three languages enjoy very similar computational properties under the UNA: tractable satisfiability and query answering in AC. We conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential query answering under the UNA. The original eight DL-Lite logics, called by Calvanese et al. (2007b) \u2018the DL-Lite family,\u2019 are shown in the bottom sector of the picture (the logics DL-Lite+A and DL-Lite + A,u extend DL-LiteA and DL-LiteA,u with identification constraints, which are out of the scope of this article).", "startOffset": 171, "endOffset": 1214}, {"referenceID": 14, "context": "7, we prove that satisfiability of DL-LiteHF core KBs is ExpTime-hard for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness was shown by Calvanese et al., 2006). In DL-LiteA, to keep query answering in AC 0 for data complexity and satisfiability in NLogSpace for combined complexity, functional roles (and attributes) are not allowed to be specialized, i.e., used positively on the right-hand side of role (and attribute) inclusion axioms. So, condition (A3) is a slight generalization of this restriction. DL-LiteA also allows axioms of the form B v \u2203R.C for non-functional roles R, which is covered by conditions (A1) and (A2). Thus, DL-LiteA can be regarded as a proper fragment of both DL-Lite (HF) core and DL-Lite (HN ) horn . We show in Sections 5.3 and 7 that these three languages enjoy very similar computational properties under the UNA: tractable satisfiability and query answering in AC. We conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential query answering under the UNA. The original eight DL-Lite logics, called by Calvanese et al. (2007b) \u2018the DL-Lite family,\u2019 are shown in the bottom sector of the picture (the logics DL-Lite+A and DL-Lite + A,u extend DL-LiteA and DL-LiteA,u with identification constraints, which are out of the scope of this article). Their nearest relatives are the logic DL-Lite (HN ) horn and its fragments, which are all in AC as well. The next layer contains the logics DL-LiteHF core and DL-LiteHF horn, in which query answering is data-complete for P (no matter whether the UNA is adopted or not). In fact, these logics are fragments of the much more expressive DL Horn-SHIQ, which was shown to enjoy the same data complexity of query answering by Eiter et al. (2008). It remains to be seen whether polynomial query answering is practically feasible; recent experiments with the DL EL (Lutz, Toman, & Wolter, 2008) indicate that this may indeed be the case.", "startOffset": 171, "endOffset": 1871}, {"referenceID": 66, "context": "Satisfiability: Combined Complexity DL-LiteHN bool is clearly a sub-logic of the description logic SHIQ, the satisfiability problem for which is known to be ExpTime-complete (Tobies, 2001).", "startOffset": 174, "endOffset": 188}, {"referenceID": 12, "context": "We shall also see that the translations of Horn and Krom KBs into QL belong to the Horn and Krom fragments of QL, respectively, which are known to be P- and NLogSpace-complete (see, e.g., Papadimitriou, 1994; B\u00f6rger et al., 1997).", "startOffset": 176, "endOffset": 229}, {"referenceID": 12, "context": "As for the lower bound, it suffices to recall that the NLogSpace-hardness for satisfiability of propositional Krom formulas is proved by reduction of the directed graph reachability problem using only \u2018core\u2019 propositional formulas (B\u00f6rger et al., 1997), and so satisfiability in all of the above logics is NLogSpace-hard.", "startOffset": 231, "endOffset": 252}, {"referenceID": 66, "context": "In this section we show that the satisfiability problem for DL-LiteHF core KBs is ExpTime-hard, which matches the upper bound for satisfiability of DL-LiteHN bool KBs even under binary coding of natural numbers (Tobies, 2001).", "startOffset": 211, "endOffset": 225}, {"referenceID": 35, "context": "Indeed, as follows from Theorem 10 of Glimm et al. (2007), KB satisfiability in the extension of SHIQ with role conjunction is in ExpTime if the length of role conjunctions is bounded by some constant (in our case, this constant is 2 because Dis(R1, R2) can be encoded by \u2203(R1 u R2).", "startOffset": 38, "endOffset": 58}, {"referenceID": 69, "context": "According to the classification suggested by Vardi (1982), we have been considering its combined complexity.", "startOffset": 45, "endOffset": 58}, {"referenceID": 52, "context": "As follows from the results of Ortiz et al. (2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHN bool is in coNP for data complexity, while the results of Hustadt et al.", "startOffset": 31, "endOffset": 51}, {"referenceID": 41, "context": "(2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHN bool is in coNP for data complexity, while the results of Hustadt et al. (2005) and Eiter et al.", "startOffset": 137, "endOffset": 159}, {"referenceID": 31, "context": "(2005) and Eiter et al. (2008) for Horn-SHIQ imply a polynomial-time upper bound for DL-LiteHF horn.", "startOffset": 11, "endOffset": 31}, {"referenceID": 63, "context": "Proof The proof is by reduction of the unsatisfiability problem for 2+2CNF, which is known to be coNP-complete (Schaerf, 1993).", "startOffset": 111, "endOffset": 126}, {"referenceID": 14, "context": "Our next lower bound would follow from Theorem 6, item 2 in the work of Calvanese et al. (2006); unfortunately, the proof there is incorrect and cannot be repaired.", "startOffset": 72, "endOffset": 96}, {"referenceID": 17, "context": "(2008) for Horn-SHIQ, while for DL-Litehorn it is in AC 0 (Calvanese et al., 2006).", "startOffset": 58, "endOffset": 82}, {"referenceID": 38, "context": "The positive existential query answering problem is known to be data-complete for coNP in the case of DL-LiteHN bool : the upper bound follows from the results of Ortiz et al. (2006), while the lower bound was established for DL-Litekrom by Calvanese et al.", "startOffset": 163, "endOffset": 183}, {"referenceID": 14, "context": "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993).", "startOffset": 65, "endOffset": 89}, {"referenceID": 14, "context": "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHF horn, query answering is data-complete for P, as follows from the results of Hustadt et al.", "startOffset": 65, "endOffset": 105}, {"referenceID": 14, "context": "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHF horn, query answering is data-complete for P, as follows from the results of Hustadt et al. (2005) and Eiter et al.", "startOffset": 65, "endOffset": 230}, {"referenceID": 14, "context": "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHF horn, query answering is data-complete for P, as follows from the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ, while for DL-Litehorn it is in AC 0 (Calvanese et al.", "startOffset": 65, "endOffset": 254}, {"referenceID": 61, "context": "We remind the reader (for details consult, e.g., Apt, 1990; Rautenberg, 2006) that M0 can be constructed by taking the intersection of all Herbrand models for K\u2021e , that is, of all models based on the domain that consists of constant symbols from K\u2021e\u2014i.", "startOffset": 21, "endOffset": 77}, {"referenceID": 62, "context": "It remains to recall that reachability in undirected graphs is SLogSpace-complete and that SLogSpace = LogSpace (Reingold, 2008).", "startOffset": 112, "endOffset": 128}, {"referenceID": 14, "context": "The above result strengthens the NLogSpace lower bound for instance checking in DL-Litecore proved by Calvanese et al. (2008).", "startOffset": 102, "endOffset": 126}, {"referenceID": 43, "context": "The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al.", "startOffset": 102, "endOffset": 144}, {"referenceID": 31, "context": "The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al.", "startOffset": 102, "endOffset": 144}, {"referenceID": 35, "context": ", 2008) and SHIQ (Ortiz et al., 2006, 2008; Glimm et al., 2007), respectively (see the discussion at the beginning of Section 7).", "startOffset": 17, "endOffset": 63}, {"referenceID": 0, "context": "The first-order rewriting technique has been implemented in various system, notably in QuOnto (Acciarri et al., 2005; Poggi et al., 2008b), which can query, relying on ontology-to-relational mappings, data stored in any standard relational database management system, and in Owlgres (Stocker & Smith, 2008), which can access an ABox stored in a Postgres database (though, to the best of our knowledge, the latter implementation is incomplete for conjunctive query answering).", "startOffset": 94, "endOffset": 138}, {"referenceID": 43, "context": "It could also be promising for the Horn fragments of expressive description logics such as SHIQ (Hustadt et al., 2005; Hustadt, Motik, & Sattler, 2007)\u2014containing DL-LiteHF horn as a sub-language\u2014for which the data complexity of instance checking (Hustadt et al.", "startOffset": 96, "endOffset": 151}, {"referenceID": 31, "context": ", 2005, 2007) and conjunctive query answering is polynomial (Eiter et al., 2008).", "startOffset": 60, "endOffset": 80}, {"referenceID": 47, "context": "DL-Lite logics are among those few examples of DLs for which usually very complex \u2018non-standard\u2019 reasoning problems\u2014such as checking whether one ontology is a conservative extension of another one with respect to a given signature \u03a3 (Kontchakov et al., 2008), computing minimal modules of ontologies with respect to \u03a3 (Kontchakov et al.", "startOffset": 233, "endOffset": 258}, {"referenceID": 46, "context": ", 2008), computing minimal modules of ontologies with respect to \u03a3 (Kontchakov et al., 2009) or uniform interpolants (Wang, Wang, Topor, & Pan, 2008)\u2014can be supported by practical reasoning tools.", "startOffset": 67, "endOffset": 92}], "year": 2009, "abstractText": "The recently introduced series of description logics under the common moniker \u2018DLLite\u2019 has attracted attention of the description logic and semantic web communities due to the low computational complexity of inference, on the one hand, and the ability to represent conceptual modeling formalisms, on the other. The main aim of this article is to carry out a thorough and systematic investigation of inference in extensions of the original DL-Lite logics along five axes: by (i) adding the Boolean connectives and (ii) number restrictions to concept constructs, (iii) allowing role hierarchies, (iv) allowing role disjointness, symmetry, asymmetry, reflexivity, irreflexivity and transitivity constraints, and (v) adopting or dropping the unique name assumption. We analyze the combined complexity of satisfiability for the resulting logics, as well as the data complexity of instance checking and answering positive existential queries. Our approach is based on embedding DL-Lite logics in suitable fragments of the one-variable first-order logic, which provides useful insights into their properties and, in particular, computational behavior.", "creator": "TeX"}}}