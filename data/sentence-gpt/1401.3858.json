{"id": "1401.3858", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Logical Foundations of RDF(S) with Datatypes", "abstract": "The Resource Description Framework (RDF) is a Semantic Web standard that provides a data language, simply called RDF, as well as a lightweight ontology language, called RDF Schema. We investigate embeddings of RDF in logic and show how standard logic programming and description logic technology can be used for reasoning with RDF. We subsequently consider extensions of RDF with datatype support, considering D entailment, defined in the RDF semantics specification, and D* entailment, a semantic weakening of D entailment, introduced by ter Horst.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Thu, 16 Jan 2014 05:02:49 GMT  (497kb)", "http://arxiv.org/abs/1401.3858v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["jos de bruijn", "stijn heymans"], "accepted": false, "id": "1401.3858"}, "pdf": {"name": "1401.3858.pdf", "metadata": {"source": "CRF", "title": "Logical Foundations of RDF(S) with Datatypes", "authors": ["Jos de Bruijn", "Stijn Heymans"], "emails": ["bruijn@kr.tuwien.ac.at", "heymans@kr.tuwien.ac.at"], "sections": [{"heading": "1. Introduction", "text": "The Resource Description Framework (RDF) (Klyne & Carroll, 2004), together with its vocabulary description language RDF Schema (RDFS) (Brickley & Guha, 2004), constitutes the basic language of the Semantic Web. Statements in RDF are triples of the form \u3008s, p, o\u3009. Sets of triples are called RDF graphs: intuitively, each triple can be viewed as an edge from node s to node o with label p. Here, s, o, and p are constant symbols \u2013 uniform resource identifiers (URIs) or literals (e.g., strings) \u2013 or anonymous identifiers, called blank nodes. Consider, for example, the graphs S = {\u3008o, rdf:type, A\u3009, \u3008A, rdfs:subClassOf, B\u3009} and E = {\u3008o, rdf:type, B\u3009}. Hayes (2004) defines notions of RDF and RDFS entailment. We have that, compared with RDF entailment, RDFS entailment gives additional meaning to rdfs:subClassOf statements: S RDFS-entails E, but S does not RDF-entail E.\nThe RDF semantics specification (Hayes, 2004) defines four increasingly expressive normative entailment relations between RDF graphs, namely simple, RDF, RDFS, and D entailment, where the latter extends RDFS entailment with support for datatypes (e.g., strings and integers). Furthermore, it defines extensional RDFS (eRDFS) entailment as a possible extension of RDFS entailment that is more in line with description logic-based languages such as OWL DL (Patel-Schneider, Hayes, & Horrocks, 2004) and OWL 2 DL (Motik, Patel-Schneider, & Parsia, 2009b). Intuitively, the difference between the RDFS and eRDFS entailment regimes is that, for the latter, whenever an ontological relation (e.g., subclass or property domain) implicitly holds in an interpretation, the corresponding RDF statement (rdfs:subClassOf, rdfs:domain, respectively) must be true, whereas this is not\nc\u00a92010 AI Access Foundation. All rights reserved.\nalways the case with the RDFS entailment regime. The following example illustrates this difference.\nExample 1. Let S be the graph\n{\u3008mother, rdfs:subPropertyOf, parent\u3009, \u3008parent, rdfs:domain, P erson\u3009}\nwhich says that Person is in the domain of parent, and the property mother is a subproperty of parent. Using eRDFS entailment we can conclude from S that Person is in the domain of mother:\nS |=erdfs \u3008mother, rdfs:domain, P erson\u3009\nsince it must the case that the subject of any mother triple has the type Person; thus, Person is implicitly in the domain of mother. We cannot draw this conclusion when using RDFS entailment; in RDFS, only explicitly asserted domain constraints can be derived.\nWe further also consider D* entailment (ter Horst, 2005), which is a semantic weakening of D entailment for the purpose of more efficient computation of consequences. D* entailment extends RDFS entailment, but is not more expensive in terms of computational complexity.\nThere have been several investigations into the formal properties of the RDF semantics (Gutierrez, Hurtado, & Mendelzon, 2004; Gutierrez, Hurtado, Mendelzon, & Pe\u0301rez, 2010; de Bruijn, Franconi, & Tessaris, 2005; ter Horst, 2005): Gutierrez et al. (2004, 2010) reconstruct the semantics from a graph database perspective, and de Bruijn et al. (2005) reconstruct the semantics from a logical language perspective. The investigation of the RDF semantics by ter Horst (2005) stays very close to the RDF specification. Additionally, ter Horst shows that the entailment rules for computing RDFS entailment presented in the original specification (Hayes, 2004) are not complete with respect to the RDFS semantics. These reconstructions have led to a number of complexity results for RDF entailment. In particular, simple, RDF, and RDFS entailment are NP-complete in the combined size of the graphs. This high complexity is due to the presence of blank nodes (essentially existentially quantified variables): if the entailed graph is known to be ground, the respective problems turn out to be decidable in polynomial time. These bounds have not been shown to be tight. As we will show in Section 5, the bound is tight for RDFS entailment, but not for simple and RDF entailment, which can be decided in logarithmic space.\nTo investigate the relationship between RDF and logic we embed the various RDF entailment regimes in F-Logic (Kifer, Lausen, & Wu, 1995), which is a syntactic extension of first-order logic (FOL) with object oriented modeling constructs. F-Logic has constructs to explicitly specify attributes, as well as generalization/specialization and instantiation relationships. Like RDFS, the syntax of F-Logic has some seemingly higher-order features, namely, the same identifier can be used for a class, an instance, and an attribute. However, the semantics of F-Logic is strictly first-order (Kifer et al., 1995). It turns out that the attribute value construct in F-Logic is exactly equivalent to the triple construct in RDF, and the typing (class membership) construct in F-Logic is very close in spirit to the one in RDF.\nIn addition, we consider the embedding of a large subset of extensional RDFS in FOL and the tractable description logic language DL-LiteR (Calvanese, Giacomo, Lembo, Lenzerini,\n& Rosati, 2007), thereby showing that, under certain restrictions, extensional RDFS can be seen as a standard first-order knowledge representation language.\nOur contributions with this paper can be summarized as follows.\n1. We define embeddings of simple, RDF, RDFS, and extensional RDFS into F-Logic, and show that simple, RDF, and RDFS entailment can be decided using standard logic programming techniques, as their embeddings are in the Horn fragment of F-Logic.\n2. We define an alternative, direct embedding of extensional RDFS into the Horn fragment of F-Logic for a fragment of RDF graphs, namely those in which the RDFS vocabulary is only used in a standard way. We subsequently exploit earlier results about the relationship between F-Logic statements and description logic statements (de Bruijn & Heymans, 2008) to show that extensional RDFS reasoning with ground RDF graphs can be reduced to reasoning in the tractable description logic DL-LiteR (Calvanese et al., 2007).\n3. We extend the embeddings mentioned under 1. with support for datatypes, considering both D* and D entailment. The embeddings of the extensions of simple, RDF, and RDFS entailment with D* datatype support are all essentially in the Horn fragment of F-Logic. The extensions of simple, RDF, and RDFS with D datatype support can be embedded in the Horn fragment of F-Logic when suitably restricting the datatypes that may be considered.\n4. We analyze the complexity of deciding the mentioned entailment relations. From the mentioned embeddings we obtain a number of novel complexity upper bounds, namely, simple and RDF entailment, as well as their extensions with datatypes (under suitable restrictions), are in LogSpace in the size of the entailing graph and a large fragment of extensional RDFS entailment is in NP in the combined size of the graphs and in PTime in the size of the entailing graph. We also establish a novel PTime lower bound for RDFS entailment and a novel coNP lower bound for simple entailment extended with D datatype support, when considering arbitrary datatypes, both in the size of the entailing graph. See Table 2 on page 553 for an overview of the complexity results for RDF.\nThe structure of the remainder of the paper is as follows. In Section 2 we review the logics under consideration, namely F-Logic and DL-LiteR. In Section 3 we review the RDF(S) semantics, define embeddings into F-Logic and FOL, show faithfulness of these embeddings, and demonstrate the relationship with DL-LiteR. In Section 4 we consider extensions of the RDF entailment regimes with datatype support based on both D* and D entailment and embeddings of these extensions into logic. In Section 5 we extensively investigate the complexity of the various RDF entailment regimes. We conclude the paper and outline future work in Section 6.\nThis paper extends a paper we published at the International Semantic Web Conference (de Bruijn & Heymans, 2007) with embeddings of the D* and D entailment regimes and novel lower bounds for the complexity of deciding RDFS, D* , and D entailment.\nFor reasons of legibility, the definitions of the various RDF-related notions of interpretation may be found in Appendix A, the embeddings of the RDF entailment regimes may be found in Appendix B, and the proofs of Sections 3 and 4 may be found in Appendix C."}, {"heading": "2. Preliminaries", "text": "In this section we review F-Logic and DL-LiteR."}, {"heading": "2.1 Frame Logic", "text": "We consider Frame Logic (F-Logic) as defined by Kifer, Lausen, and Wu (1995). To simplify matters, and because these constructs are not necessary for the embedding of RDF, we do not consider function symbols, parameterized methods, functional (single-valued) methods, inheritable methods, and compound molecules, following de Bruijn and Heymans (2008).\nThe signature of an F-language L is of the form \u03a3 = \u3008C,P\u3009 with C and P disjoint sets of constant and predicate symbols; each predicate symbol has an associated arity n \u2265 0. Let V be a set of variable symbols. Terms and atomic formulas are constructed as usual: x \u2208 V and c \u2208 C are terms and >, \u22a5, p(t1, . . . , tn), and t1 = t2 are atomic formulas, with p \u2208 P an n-ary predicate symbol, and t1, . . . , tn terms.\nA molecule in F-Logic is one of the following statements: (i) an is-a assertion of the form t1 : t2, which states that an individual t1 is of type t2, or (ii) a data molecule (called \u201cmethod\u201d by Kifer et al., 1995) of the form t1[t2 t3], with t1, t2, and t3 terms, which states that an individual t1 has an attribute t2 with value t3. An F-Logic molecule is ground if it does not contain variables.\nFormulas of an F-language L are either atomic formulas, molecules, or compound formulas which are constructed in the usual way from atomic formulas, molecules, and the logical connectives \u00ac,\u2227,\u2228,\u2283, the quantifiers \u2203, \u2200 and the auxiliary symbols \u2018(\u2019 and \u2018)\u2019. We denote universal closure, i.e., the universal quantification of every variable that has a free occurrence in the formula, with (\u2200).\nA theory is a set of formulas. A theory or formula is called equality-free if the equality symbol \u2018=\u2019 does not appear in it.\nF-Logic Horn formulas are of the form (\u2200)B1 \u2227 . . . \u2227 Bn \u2283 H, with B1,. . . , Bn, and H atomic formulas or molecules. F-Logic Datalog formulas are F-Logic Horn formulas such that every variable in H occurs in some equality-free Bi. The latter condition is called safeness.\nAn F-structure is a tuple I = \u3008U,\u2208U , IC , I , IP \u3009, where U is a non-empty set and \u2208U is a binary relation over U . A constant symbol c \u2208 C is interpreted as an element of the domain: IC(c) \u2208 U . An n-ary predicate symbol p \u2208 P is interpreted as a relation over the domain U : IP (p) \u2286 Un. I associates a binary relation over U with each k \u2208 U : I (k) \u2286 U \u00d7 U . Variable assignments B are defined in the usual way.\nGiven an F-structure I, a variable assignment B, and a term t of L, tI,B is defined as: xI,B = xB for variable symbol x and tI,B = IC(t) for t \u2208 C.\nSatisfaction of atomic formulas and molecules \u03c6 in I, given a variable assignment B, denoted (I, B) |=f \u03c6, is defined as \u2013 (I, B) |=f >, (I, B)6|=f \u22a5,\n\u2013 (I, B) |=f p(t1, . . . , tn) iff (tI,B1 , . . . , t I,B n ) \u2208 IP (p), \u2013 (I, B) |=f t1 = t2 iff tI,B1 = t I,B 2 , \u2013 (I, B) |=f t1 : t2 iff tI,B1 \u2208U t I,B 2 , and \u2013 (I, B) |=f t1[t2 t3] iff \u3008tI,B1 , t I,B 3 \u3009 \u2208 I (t I,B 2 ).\nThis extends to arbitrary formulas in the usual way. An F-structure I satisfies a formula \u03c6, denoted I |=f \u03c6, if (I, B) |=f \u03c6 for every variable assignment B. I satisfies a theory \u03a6 \u2286 L if it satisfies all formulas in \u03a6; in this case, I is called a model of \u03a6. A theory \u03a6 F-entails a formula \u03c6 \u2208 L, denoted \u03a6 |=f \u03c6, iff for every model I of \u03a6, I |=f \u03c6.\nA Herbrand F-structure is an F-structure I = \u3008U, \u2208U , IC , I , IP \u3009 such that U is the set of constants and for every constant symbol c \u2208 C, IC(c) = c. As an abuse of notation, for Herbrand structures we use I to denote both the structure and the set of ground atomic formulas satisfied by the structure. Finally, a Herbrand F-structure I is a minimal Herbrand model of a theory \u03a6 if it is a model and there is no Herbrand F-structure I\u2032 that is a model of \u03a6 such that I\u2032 I.\nClassical first-order logic (FOL) is F-Logic without molecules. Contextual first-order logic is classical FOL where C and P are not required to be disjoint, predicate symbols do not have an associated arity, and for every structure I = \u3008U, \u2208U , IC , I , IP \u3009, IP assigns a relation IiP (p) \u2286 Un to every p \u2208 P, for every nonnegative integer i. We denote satisfaction and entailment in classical and contextual first-order logic using the symbols |= and |=c, respectively. Contextual FOL is sometimes also referred to as FOL with \u201cpunning\u201d.\nF-Logic can be straightforwardly embedded into FOL, as shown in (Kifer et al., 1995, Theorem 18.1).\nProposition 1. Let \u03a6 and \u03c6 be an F-Logic theory and formula that do not contain the binary and ternary predicate symbols isa and data, respectively, and let \u03a6\u2032 and \u03c6\u2032 be the FOL theory and formula obtained from \u03a6 and \u03c6 by replacing every is-a molecule a : b with isa(a, b) and every data molecule a[b c] with data(a, b, c). Then,\n\u03a6 |=f \u03c6 iff \u03a6\u2032 |= \u03c6\u2032\n2.2 DL-LiteR\nA DL-LiteR (Calvanese et al., 2007) language consists of pairwise disjoint sets of concept (NC), role (NR), and individual (NI) identifiers. Concepts and roles in DL-LiteR are defined as follows:\nCl \u2212\u2192 A | \u2203R Cr \u2212\u2192 A | \u2203R | \u00acA | \u00ac\u2203R\nR,R\u2032 \u2212\u2192 P | P\u2212\nwith A \u2208 NC and P \u2208 NR, Cl and Cr left- (resp., right-)hand side concepts, and R and R\u2032 roles.\nA DL-LiteR knowledge base K = (T ,A) consists of a TBox T , which is a set of inclusion axioms of the forms\nCl v Cr R v R\u2032\nand an ABox A, which is a set of concept and role membership assertions of the forms\nA(a) P (a1, a2)\nwith a, a1, a2 \u2208 NI . We define the semantics of DL-LiteR through a translation to FOL, in the form of the mapping function \u03c0, which is defined in Table 1.1 The mapping \u03c0 extends naturally to sets of axioms and assertions.\nGiven a DL-LiteR knowledge base K = (T ,A), the FOL equivalent of K is the FOL theory \u03a6 = \u03c0(K) = \u03c0(T ) \u222a \u03c0(A).\nContextual DL-LiteR is like DL-LiteR, except that the sets of concept (NC), role (NR), and individual (NI) identifiers are not required to be disjoint. The semantics of a contextual DL-LiteR knowledge base K = (T ,A) is given through the same mapping \u03c0(K), which yields a contextual FOL theory. Note that contextual DL-LiteR is essentially a subset of the QL profile of OWL 2 (Motik, Grau, Horrocks, Wu, Fokoue, & Lutz, 2009a)."}, {"heading": "3. RDF and RDF Schema", "text": "We first review the definitions of the RDF syntax and semantics. We then proceed with the embedding of graphs and axiomatization of the entailment regimes into F-Logic, and finally the embedding of extensional RDFS into FOL and DL-LiteR."}, {"heading": "3.1 RDF(S) Syntax and Semantics", "text": "We proceed with a review of the definitions of the RDF syntax (Klyne & Carroll, 2004) and semantics (Hayes, 2004).\nA vocabulary V = \u3008C,PL, T L\u3009 consists of a set C of RDF URI references (simply referred to as URIs), a set PL of plain literals (i.e., Unicode character strings with an optional language tag), and a set T L of typed literals (i.e., pairs (s, u) of a Unicode string s and a URI u, denoting a datatype); see (Klyne & Carroll, 2004, Sections 6.4, 6.5, 6.6) for more details about the specific form of these symbols. Note that C, PL, and T L are mutually disjoint. The symbols in V are collectively referred to as names.\nLet B be a set of blank nodes that is disjoint from the set of names in V . Terms are names or blank nodes. A generalized RDF graph S is a set of generalized triples \u3008s, p, o\u3009 \u2013\n1. Borgida (1996) discusses the relationship between description logics and first-order logic in detail.\nsubject, predicate, object \u2013 with s, p, o \u2208 C \u222aPL\u222aT L\u222aB. A normal RDF graph S is a set of normal triples \u3008s, p, o\u3009, with s \u2208 C \u222aB, p \u2208 C, and o \u2208 C \u222aPL\u222aT L\u222aB.2 A ground triple is a triple that does not contain blank nodes. A ground generalized, respectively normal RDF graph is a set of ground generalized, respectively normal triples. With bl(\u3008s, p, o\u3009) \u2286 B (resp., bl(S) \u2286 B) we denote the set of blank nodes in a triple \u3008s, p, o\u3009 (resp., graph S). In the remainder, whenever speaking about triples or RDF graphs, we mean generalized triples, respectively generalized RDF graphs, unless stated otherwise.\nAn interpretation is a tuple I = \u3008IR, IP,LV, IS, IL, IEXT\u3009, where IR is a non-empty set, called the domain, IP is a set of properties, LV \u2286 IR is a set of literal values with PL \u2286 LV, IS is a mapping IS : C \u2192 IR\u222a IP, IL is a mapping IL : T L \u2192 IR, and IEXT is an extension function IEXT : IP\u2192 2(IR\u00d7IR).\nGiven an interpretation I, a subset of the blank nodes B\u2032 \u2286 B, and a mapping A : B\u2032 \u2192 IR, which is used to interpret blank nodes, for any given term t we define tI,A as:\n\u2013 if t \u2208 C, then tI,A = IS(t), \u2013 if t \u2208 T L, then tI,A = IL(t), and\n\u2013 if t \u2208 PL, then tI,A = t, \u2013 if t \u2208 B\u2032, then tI,A = A(t).\nAn interpretation I satisfies a triple \u3008s, p, o\u3009 with respect to a mapping A : B\u2032 \u2192 IR, with bl(\u3008s, p, o\u3009) \u2286 B\u2032, denoted (I, A) |= \u3008s, p, o\u3009, if pI,A \u2208 IP and \u3008sI,A, oI,A\u3009 \u2208 IEXT(pI,A). I satisfies a graph S with respect to a mapping A : bl(S) \u2192 IR, denoted (I, A) |= S, if (I, A) |= \u3008s, p, o\u3009 for every \u3008s, p, o\u3009 \u2208 S.\nAn interpretation I satisfies an RDF graph S, denoted I |= S, if (I, A) |= S for some mapping A : bl(S) \u2192 IR; in this case, I is a model of S. Any interpretation is an sinterpretation (simple interpretation).\nThe notions of rdf -, rdfs-, and erdfs-interpretation are defined through additional conditions on s-interpretation. For example, an s-interpretation is an rdf -interpretation only if for every object k, k \u2208 IP iff \u3008k, IS(rdf:Property)\u3009 \u2208 IEXT (IS(rdf:type)) and it satisfies the triple \u3008rdf:nil, rdf:type, rdf:List\u3009. Triples that are required to be satisfied by every x-interpretation are called x-axiomatic triples, for x \u2208 {rdf, rdfs, erdfs} or simply axiomatic triples when the entailment regime is clear from the context. The precise definitions of rdf -, rdfs-, and erdfs-interpretation are found in Appendix A.\nEntailment and Satisfiability Given a vocabulary V and an entailment regime x \u2208 {s, rdf, rdfs, erdfs}, a generalized (resp., normal) RDF graph S x-entails a generalized (resp., normal) RDF graph E, denoted S |=x E, if every x-interpretation of V that is a model of S is also a model of E.\nGiven an entailment regime x \u2208 {s, rdf, rdfs, erdfs}, a generalized (resp., normal) RDF graph S is x-satisfiable if it has a model that is an x-interpretation; otherwise it is xunsatisfiable. The following observations can be made about satisfiability for the various entailment regimes; the observations concerning normal RDF graphs are due to Hayes (2004).\nProposition 2. 1. Every generalized and every normal RDF graph is s-satisfiable. 2. Every normal RDF graph is rdf-satisfiable.\n2. Normal RDF graphs correspond the RDF graphs defined by Hayes (2004). In contrast to normal RDF, generalized RDF graphs allow blank nodes and literals in predicate, and literals in subject positions.\n3. There is a generalized RDF graph that is rdf-unsatisfiable. 4. There is a normal (and generalized) RDF graph that is rdfs- and erdfs-unsatisfiable."}, {"heading": "3.2 Embedding RDF in Logic", "text": "We translate a graph to a conjunction of data molecules, where URIs and literals are constant symbols and blank nodes are existentially quantified variables. We axiomatize the entailment regimes using sets of formulas that are independent from the graphs. In the remainder we assume that RDF graphs are finite.\nGiven a vocabulary V = \u3008C,PL, T L\u3009, an F-language L conforms with V if it has a signature of the form \u03a3 = \u3008C\u2032,P\u3009, with C\u2032 \u2287 C \u222a PL \u222a T L.3\nDefinition 1. Let V be a vocabulary, let S be an RDF graph of V , let bl(S) = {b1, . . . , bn} be the set of blank nodes appearing in S, let \u3008s, p, o\u3009 be a triple in S, and let L be an F-language that conforms with V . Then,\ntr(\u3008s, p, o\u3009) = s[p o] and tr(S) = \u2203 b1, . . . , bn (\u2227 {tr(\u3008s, p, o\u3009) | \u3008s, p, o\u3009 \u2208 S} ) are formulas of L.\nThe axiomatizations of the entailment regimes are theories \u03a8x, with x \u2208 {s, rdf, rdfs, erdfs}, which are defined in Appendix B.\nIf \u03c6 is an F-Logic formula in prenex normal form with only existential quantifiers, then sk(\u03c6) denotes the Skolemization of \u03c6, i.e., every existentially quantified variable is replaced with a globally unique new constant symbol. This extends to theories in the natural way.\nProposition 3. Let S be an RDF graph of a vocabulary V and let x \u2208 {s, rdf, rdfs} be an entailment regime. Then, sk(tr(S)) \u222a \u03a8x can be equivalently rewritten to a set of F-Logic Horn formulas.\nWe have that \u03a8erdfs cannot be equivalently rewritten to a set of Horn formulas, because of the use of universal quantification in the antecedents of some of the implications in \u03a8erdfs.\nWe now show faithfulness of our embedding.\nTheorem 1. Let S and E be RDF graphs of a vocabulary V , and let x \u2208 {s, rdf, rdfs, erdfs} be an entailment regime. Then,\nS |=x E iff tr(S) \u222a\u03a8x |=f tr(E) and S is x-satisfiable iff tr(S) \u222a\u03a8x has a model.\nThe following corollary follows immediately from Theorem 1 and the classical results about Skolemization (see, e.g., Fitting, 1996).\nCorollary 1. Let S and E be RDF graphs of a vocabulary V , and let x \u2208 {s, rdf, rdfs, erdfs} be an entailment regime. Then,\nS |=x E if and only if sk(tr(S)) \u222a\u03a8x |=f tr(E).\n3. Even though typed literals are pairs in RDF, we treat them simply as constant symbols in our embedding.\nObserve that \u03a8rdf , \u03a8rdfs, and \u03a8erdfs are infinite due to the infinite set of RDF axiomatic triples. However, for checking RDF entailment we need only a finite subset of \u03a8x. Given an RDF graph S, let \u03a8x\u2212S be obtained from \u03a8\nx by removing all formulas originating from axiomatic triples involving container membership properties (i.e., rdf: 1, rdf: 2, . . . ) not appearing in S, with the exception of the axiomatic triples involving rdf: 1.\nProposition 4. Let S and E be RDF graphs and let x \u2208 {s, rdf, rdfs, erdfs} be an entailment regime. Then,\nS |=x E if and only if sk(tr(S)) \u222a\u03a8x\u2212S\u222aE |=f tr(E).\nBy Proposition 3 we have that sk(tr(S)) \u222a\u03a8s, tr(S)sk \u222a\u03a8rdf, and sk(tr(S)) \u222a\u03a8rdfs are equivalent to sets of Horn formulas. Therefore, Proposition 4 implies that simple, RDF, and RDFS entailment can be computed using reasoners that can compute ground entailment of F-Logic Horn theories, such as FLORA-2 (Yang, Kifer, & Zhao, 2003). Notice that tr(E) can be seen as a boolean conjunctive query (i.e., a yes/no query), where the existentially quantified variables in tr(E) are the non-distinguished variables."}, {"heading": "3.3 Direct Embedding of Extensional RDFS", "text": "We now consider an alternative, direct embedding of the extensional RDFS entailment regime. This embedding, rather than axiomatizing the entailment regime, embeds ontological statements, e.g., rdfs:subClassOf statements, directly as formulas.\nWe first define the notion of standard use of the RDF(S) vocabulary, which intuitively corresponds to not using the vocabulary in locations where it can change the semantics of the RDF(S) ontology vocabulary (e.g., \u3008rdf:type, rdfs:subPropertyOf, a\u3009).\nDefinition 2. Let S be an RDF graph. Then, S has only standard use of the RDF(S) vocabulary if\n\u2022 rdf:type, rdfs:subClassOf, rdfs:domain, rdfs:range, and rdfs:subPropertyOf do not appear in subject or object positions of any triple in S and\n\u2022 rdfs:ContainerMembershipProperty, rdfs:Resource, rdfs:Class, rdfs:Datatype, and rdf:Property appear only in object positions of rdf:type-triples in S.\nWe are now ready to define the direct embedding trerdfs of the extensional RDFS entailment regime for graphs with only standard use of RDFS vocabulary. While trerdfs deals with an important part of the RDF(S) vocabulary, the axiomatization of the eRDFS semantics of the remainder of the RDF(S) vocabulary may be found in Appendix B, in the form of the theory \u03a8erdfs-V , where V is a vocabulary.\nDefinition 3. Let \u3008s, p, o\u3009 be an RDF triple. Then,\ntrerdfs(\u3008s, type, Datatype\u3009) = s :Datatype \u2227 \u2200x(x :s \u2283 x :Literal), trerdfs(\u3008s, type, ContainerMembership- = s :ContainerMembershipProperty\nProperty\u3009) \u2227\u2200x, y(x[s y] \u2283 x[member y]), trerdfs(\u3008s, type, o\u3009) = s :o,\ntrerdfs(\u3008s, subClassOf, o\u3009) = \u2200x(x :s \u2283 x :o), trerdfs(\u3008s, subPropertyOf, o\u3009) = \u2200x, y(x[s y] \u2283 x[o y]),\ntrerdfs(\u3008s, domain, o\u3009) = \u2200x, y(x[s y] \u2283 x :o), trerdfs(\u3008s, range, o\u3009) = \u2200x, y(x[s y] \u2283 y :o), and\ntrerdfs(\u3008s, p, o\u3009) = s[p o], otherwise.\nLet S be an RDF graph and let bl(S) = {b1, . . . , bn} be the set of blank nodes in S. Then,\ntrerdfs(S) = {\u2203 b1, . . . , bn( \u2227 {trerdfs(\u3008s, p, o\u3009) | \u3008s, p, o\u3009 \u2208 S})}\nWe say that a term t occurs in a property position if it occurs as the predicate of a triple, as the subject or object of an rdfs:subPropertyOf triple, as the subject of an rdfs:domain or rdfs:range triple, or the graph contains \u3008t, rdf:type, rdf:Property\u3009 or \u3008t, rdf:type, ContainerMembershipProperty\u3009. A term t occurs in a class position if it occurs as the subject or object of an rdfs:subClassOf triple, as the object of an rdfs:domain, rdfs:range, or rdf:type triple, as the subject of a triple \u3008t, rdf:type, rdfs:Class\u3009, or as the subject of a triple \u3008t, rdf:type, rdfs:Datatype\u3009.\nLet S be an RDF graph with only standard use of the RDF(S) vocabulary. The property (resp., class) vocabulary of S consists of all the names appearing in property (resp., class) positions in S or the RDF(S) axiomatic triples with only standard use of the RDF(S) vocabulary.\nGiven two RDF graphs S and E with only standard use of the RDF(S) vocabulary, we write E E S if the property, resp. class vocabularies of E are subsets of the property, resp. class vocabularies of S, there are no blank nodes in class or property positions in E,4 and rdfs:Resource, rdfs:Class, and rdf:Property do not appear in E.\nTheorem 2. Let S and E be RDF graphs with only standard use of the RDFS vocabulary such that E E S. Then,\nS |=erdfs E iff trerdfs(S) \u222a\u03a8erdfs-V |=f trerdfs(E)\nWe define \u03a8erdfs-V\u2212S analogously to \u03a8 erdfs \u2212S , i.e., it does not contain statements concerning container membership properties not appearing in the graph S, with the exception of rdf: 1. The following proposition follows from an argument analogous to the proof of Property 4.\nProposition 5. Let S and E be RDF graphs with only standard use of the RDFS vocabulary such that E E S. Then,\nS |=erdfs E iff sk(trerdfs(S)) \u222a\u03a8erdfs-V\u2212S\u222aE |=f tr erdfs(E).\n4. This restriction on the use of blank nodes in the entailed graph was not mentioned in the extended abstract of this paper (de Bruijn & Heymans, 2007). This was an error.\nWe have that whenever E does not contain the terms rdfs:subClassOf, rdfs:subPropertyOf, rdfs:domain, and rdfs:range, trerdfs(E) is a conjunction of atomic molecules prefixed by an existential quantifiers (i.e., a conjunctive query).\nWe have that sk(trerdfs(S)) \u222a \u03a8erdfs-V\u2212S\u222aE is a finite set of Horn formulas. Therefore, if the graphs satisfy the mentioned conditions, query answering techniques used in F-Logic reasoners such as FLORA-2 (Yang et al., 2003) can be used for checking extensional RDFS entailment."}, {"heading": "3.4 Embedding Extensional RDFS into First-Order Logic", "text": "We now consider an embedding of extensional RDFS entailment into first-order logic (FOL), based on the direct embedding of extensional RDFS in F-Logic defined above.\nWe say that an F-Logic theory \u03a6 is translatable to contextual FOL if \u03a6 does not contain unary or binary predicates and for every molecule of the form t1[t2 t3] or t1 : t2 holds that t2 is a constant symbol. FO(\u03a6) is the contextual FOL theory obtained from \u03a6 by replacing:\n\u2022 every data molecule t1[t2 t3] with the atomic formula t2(t1, t3) and\n\u2022 every is-a molecule t1 : t2 with the atomic formula t2(t1). The following proposition follows immediately from an earlier result (de Bruijn & Heymans, 2008, Theorem 3.2).\nProposition 6. Let \u03a6, respectively \u03c6, be an equality-free F-Logic theory, respectively formula, that is translatable to contextual FOL. Then,\n\u03a6 |=f \u03c6 iff FO(\u03a6) |=c FO(\u03c6).\nWe say that an RDF graph S is a non-higher-order graph if S does not contain blank nodes in class or property positions, and has only standard use of the RDFS vocabulary. Observe that if S is a non-higher-order RDF graph, then trerdfs(S)\u222a\u03a8erdfs-V is translatable to contextual FOL. Notice also that every ground RDF graph that has only standard use of the RDFS vocabulary is a non-higher-order RDF graph.\nTheorem 3. Let S and E be non-higher-order RDF graphs such that E E S. Then,\nS |=erdfs E iff FO(trerdfs(S) \u222a\u03a8erdfs-V ) |=c FO(trerdfs(E)).\nProof. Follows immediately from Theorem 2, the fact that FO(trerdfs(S)) and FO(trerdfs(E)) do not contain the equality symbol, and Proposition 6.\nConcerning the relationship with DL-LiteR, we make the following observation.\nProposition 7. Let S be a ground non-higher-order graph.5 Then, FO(trerdfs(S)\u222a\u03a8erdfs-V ) can be equivalently rewritten to the FOL equivalent \u03a6 = \u03c0(K) of a contextual DL-LiteR knowledge base K.\nAnalogous to Proposition 5, one may discard the axiomatic triples concerning container membership properties that are not used, and thus one only needs to reason with a finite knowledge base.\n5. Note that, when considering a variant of DL-LiteR that allows existentially quantified variables in the ABox \u2013 also allowed in OWL DL \u2013 this restriction could be relaxed to S being a non-ground non-higherorder RDF graph."}, {"heading": "4. Extensions with Datatypes", "text": "The entailment regimes we dealt with in the previous section do not consider many of the useful datatypes (e.g., strings, integers). In fact, rdf:XMLLiteral is the only datatype that was considered. The RDF semantics specification (Hayes, 2004) defines the notion of D entailment (datatype entailment), which extends RDFS entailment with support for datatypes. Ter Horst (2005) defines the notion of D* entailment, which is also an extension of RDFS entailment, but semantically weaker than D entailment. We first review D* entailment, after which we review D entailment. Both semantics were originally defined as extensions of RDFS entailment. However, one might extend any of the entailment regimes we considered with datatype support. Therefore, we consider extensions of simple, RDF, RDFS, and extensional RDFS entailment with both kinds of datatype semantics. We first review the datatype semantics, after which we present embeddings of both semantics into F-Logic. Finally, we discuss a notion of normalization that may be used to remove equality statements from the embeddings to speed up processing."}, {"heading": "4.1 Extension of the RDF Entailment Regimes with Datatypes", "text": "Datatypes define sets of concrete data values (e.g., strings and integers), along with their lexical representations. A datatype is a tuple d = \u3008Ld, V d, L2V d\u3009 consisting of\n\u2022 a lexical space Ld, which is a set of character strings (e.g., \u201c0\u201d, \u201c1\u201d, \u201c01\u201d, . . . , in the case of an integer datatype),\n\u2022 a value space V d, which is a set of values (e.g., the numbers 0, 1, 2, . . . , in the case of an integer datatype), and\n\u2022 a lexical-to-value mapping L2V d, which is a mapping from the lexical space to the value space (e.g., {\u201c0\u201d 7\u2192 0, \u201c1\u201d 7\u2192 1, \u201c01\u201d 7\u2192 1, . . .}, for an integer datatype).\nA simple datatype map D is a partial mapping from URIs to datatypes. A simple datatype map D is a datatype map if D(rdf:XMLLiteral) = xml where xml is the built-in XML literal datatype as defined in the RDF specification (Klyne & Carroll, 2004). With dom(D) and ran(D) we denote the domain and range of D, respectively.\nGiven a simple datatype map D, we call a typed literal (s, u) \u2208 T L well-typed if u \u2208 dom(D) and s \u2208 LD(u); (s, u) is ill-typed if u \u2208 dom(D) and s /\u2208 LD(u).\nWe now review the notions of D* and D entailment. Similar to the previous section, the definitions of D* - and D-interpretations can be found in Appendix A.\nD* entailment Given a simple datatype map D , an RDF graph S s-D* entails an RDF graph E, denoted S |=s-D* E, if every s-D* -interpretation that is a model of S is a model of E.\nGiven a datatype map D , an RDF graph S x-D*-entails an RDF graph E, denoted S |=x-D* E, if every x-D* -interpretation that is a model of S is a model of E, for x \u2208 {rdf, rdfs, erdfs}.\nNotice that if dom(D) = {rdf:XMLLiteral} and x \u2208 {rdf, rdfs, erdfs}, then x-D* - entailment corresponds to x-entailment, with the exception that when considering rdf -D* - entailment, the triple \u3008rdf:XMLLiteral, rdf:type, rdfs:Datatype\u3009 is additionally entailed. In addition, if dom(D) = \u2205, then s-D* -entailment corresponds to s-entailment.\nThe following example shows how equality may be introduced by the D* semantics.\nExample 2. Consider a datatype map that contains the XML schema string datatype (Peterson, Gao, Malhotra, Sperberg-McQueen, & Thompson, 2009). Certain equalities hold between plain literals without language tags and typed literals of this datatype, because the set of plain literals without language tags corresponds to the value space of the string datatype. So, equalities such as \u201ca\u201d = (\u201ca\u201d, string) and \u201cxxx\u201d = (\u201cxxx\u201d, string) necessarily hold. Similar for equalities between datatypes. For example, if the datatype map contains both integer and decimal, then further equalities such as (\u201c1\u201d, integer) = (\u201c1\u201d, decimal) and (\u201c1\u201d, decimal) = (\u201c1.0\u201d, decimal) necessarily hold.\nD entailment Given a simple datatype map D , an RDF graph S s-D-entails an RDF graph E, denoted S |=s-D E, if every s-D-interpretation which is a model of S is a model of E.\nGiven a datatype map D , an RDF graph S x-D-entails an RDF graph E, denoted S |=x-D E, if every x-D-interpretation which is a model of S is a model of E, for x \u2208 {rdf, rdfs, erdfs}. An RDF graph S x-D-entails an RDF graph E, denoted S |=x-D E, if every x-D-interpretation which is a model of S is also a model of E.\nThere are two main differences between D* entailment and D entailment: (i) D entailment allows for easy extension towards languages which can express equality between URIs denoting datatypes; whenever two URIs denote the same datatype, typed literals with these two URIs as datatypes are interpreted in the same way (see Example 3); and (ii) D entailment directly links the class extension of a datatype with the value space of this datatype. The latter complicates the evaluation of entailment somewhat, and was likely the main motivation for the introduction of D* entailment. The complication becomes clear when declaring blank nodes as members of specific datatypes, as illustrated in Example 4.\nExample 3. Consider an extension of D entailment with equality by imposing the following condition on interpretations:\n(+) An interpretation I satisfies a triple \u3008x, owl:sameAs, y\u3009 with respect to a blank node assignment A iff xI,A = yI,A.\nNow consider a datatype map D = {bool 7\u2192 boolean}, where boolean is defined as follows:\n\u2022 Lboolean = {\u201c1\u201d, \u201c0\u201d, \u201ct\u201d, \u201cf\u201d},\n\u2022 V boolean = {true, false}, and\n\u2022 L2V boolean = {\u201c1\u201d 7\u2192 true, \u201c0\u201d 7\u2192 false, \u201ct\u201d 7\u2192 true, \u201cf\u201d 7\u2192 false},\nand an RDF graph S = {\u3008myBool, owl:sameAs, bool\u3009, \u3008a, b, (\u201c1\u201d,myBool)\u3009}. In D-interpretations, typed literals of which the datatype URIs are interpreted the same are interpreted the same as well. Therefore, under D entailment extended with condition (+) the triple \u3008a, b, (\u201ct\u201d,myBool)\u3009 can be derived from S: (\u201c1\u201d,myBool) and (\u201ct\u201d,myBool) are both interpreted as L2V boolean(\u201c1\u201d) = L2V boolean(\u201ct\u201d) = true; hence, (\u201c1\u201d,myBool) and (\u201ct\u201d,myBool) are interpreted in the same way in every interpretation. Similarly, it can be shown that the triples \u3008a, b, (\u201c1\u201d, bool)\u3009 and \u3008a, b, (\u201ct\u201d, bool)\u3009 are entailed by S.\nNone of these derivations is valid when considering D* entailment extended with condition (+). In fact, because myBool is not in the domain of D, (\u201c1\u201d,myBool) is interpreted as an arbitrary (abstract) symbol; it is treated in the same way as a URI.\nExample 4. Consider a datatype map D that includes the XML schema datatypes string and integer (Peterson et al., 2009), which have disjoint value spaces. Consider also the graph S = {\u3008 : x, rdf:type, string\u3009, \u3008 : x, rdf:type, integer\u3009}. In an rdfs-D*-interpretation I the class extensions of string and integer are not necessarily the same as the value spaces of the respective datatypes. Therefore, there may be an object k \u2208 IR that is neither an integer nor a string, but which is in the class extensions of both string and integer. Consequently, there is an rdfs-D*-interpretation that is a model of S and S is rdfs-D*-satisfiable.\nIn an rdfs-D-interpretation the class extensions of string and integer are necessarily the same as the value spaces of the respective datatypes. Since these value spaces are disjoint, there can be no object that is both in the class extension of string and in the class extension of integer. Therefore, S is not rdfs-D-satisfiable."}, {"heading": "4.2 Embeddings of Datatypes in Logic", "text": "Given a datatype map D, we use a set of formulas \u03a8y \u2286 L, defined in Appendix B, to axiomatize the semantics of an entailment regime y \u2208 {x-D*, x-D}, with x \u2208 {s, rdf, rdfs, erdfs}.\nAnalogous to Proposition 3, we have:\nProposition 8. Let S be an RDF graph of a vocabulary V . Then, sk(tr(S)) \u222a \u03a8y, with y \u2208 {s-D*, rdf-D*, rdfs-D*, s-D, rdf-D, rdfs-D}, can be equivalently rewritten to a set of FLogic Horn formulas.\nWe first show faithfulness of our embedding of D* entailment.\nTheorem 4. Let S and E be RDF graphs of a vocabulary V , let D be a datatype map, and let x \u2208 {s, rdf, rdfs, erdfs} be an entailment regime. Then,\nS |=x-D* E if and only if tr(S) \u222a\u03a8x-D* |=f tr(E) and\nS is x-D*-satisfiable iff tr(S) \u222a\u03a8x-D* has a model.\nWe now turn to x-D-entailment. It turns out that when considering datatype maps with arbitrary datatypes, one needs to reason by case (see Proposition 14 in Section 5), which complicates matters. We therefore restrict ourselves to definite datatypes, which do not bring this complication. An example of a definite datatype map is one that includes only the set of datatypes in the OWL 2 EL and QL profiles (Motik et al., 2009a).\nDefinition 4. A datatype map D is definite if\n\u2022 the value space of every datatype d \u2208 ran(D) is infinite,\n\u2022 for any n \u2265 1 distinct datatypes d1, . . . , dn \u2208 ran(D) holds that either (a) the value spaces are disjoint, i.e., V di \u2229 V dj = \u2205 (1 \u2264 i < j \u2264 n) or (b) their intersection is infinite, i.e., V d1 \u2229 \u00b7 \u00b7 \u00b7 \u2229 V dn is an infinite set, and\n\u2022 for no two datatypes d1, d2 \u2208 ran(D) holds that d1 \u2208 V d2.\nTheorem 5. Let S and E be RDF graphs of a vocabulary V , let D be a definite datatype map, and let x \u2208 {s, rdf, rdfs, erdfs} be an entailment regime. Then,\nS |=x-D E if and only if tr(S) \u222a\u03a8x-D |=f tr(E) and\nS is x-D-satisfiable iff tr(S) \u222a\u03a8x-D has a model."}, {"heading": "4.3 Normalization of Datatypes", "text": "The set of equality statements in the axiomatizations \u03a8x-D* and \u03a8x-D is potentially large and, in general, polynomial in the size of the vocabulary V . In addition, it requires equality reasoning, which tends to deteriorate the performance of a reasoner. We discuss how to normalize the embedding of a graph in F-Logic, thereby removing the need for expressing equality.\nGiven a vocabulary V , we assume a strict (e.g., lexicographical) order < on the set of literals PL \u222a T L. For a given datatype map D, we define V D = \u22c3 u\u2208dom(D) V D(u), i.e., the values in D. For each v \u2208 V D, we define the literals that represent the value v as: v = {(s, u) \u2208 T L | L2V D(u)(s) = v} \u222a {l \u2208 PL | l = v}. The representation of v, denoted r(v), is the least element in v according to the order <.\nGiven a set of formulas \u03a6 \u2286 L such that L conforms with V , the datatype normalization of \u03a6, denoted (\u03a6)n, is obtained from \u03a6 by replacing every plain literal l \u2208 PL with r(l) and replacing every well-typed literal (s, u) \u2208 T L with r(L2V D(u)(s)).\nObserve that the only equality statements in the normalizations (tr(S) \u222a \u03a8x-D)n and (tr(S) \u222a \u03a8x-D*)n are trivial statements of the form t = t, where t is a literal. Therefore, these statements may be discarded.\nThe following proposition follows straightforwardly from the shape of the axiomatizations \u03a8y and the definition of normalization.\nProposition 9. Let S and E be RDF graphs of a vocabulary V , let D be datatype map D, and let y \u2208 {s-D*, rdf-D*, rdfs-D*, erdfs-D*, s-D, rdf-D, rdfs-D, erdfs-D}. Then,\ntr(S) \u222a\u03a8y |=f tr(E) iff (tr(S) \u222a\u03a8y)n |=f (tr(E))n"}, {"heading": "5. Complexity", "text": "In this section we review the complexity of the various RDF entailment relations and present several novel results, exploiting the embeddings presented in Sections 3 and 4.\nThe complexity of non-ground simple entailment and RDFS entailment, and upper bounds for ground entailment are known from the literature, and analogous results for RDF entailment follow immediately. Recall that, although the set of axiomatic triples is infinite, only a finite subset, linear in the size of the graphs, needs to be taken into account when checking entailment (cf. Proposition 4).\nProposition 10 (Gutierrez et al., 2004, 2010; ter Horst, 2005; de Bruijn et al., 2005). The decision problems S |=s E, S |=rdf E, S |=rdfs E, and S |=rdfs-D* E, given RDF graphs S\nand E, are NP-complete in the combined size of S and E, and polynomial in the size of S. If E is ground, then the respective problems are in PTime. In addition, the problems S |=erdfs E and S |=rdfs-D E are NP-hard.\nThe membership proofs by Gutierrez et al. (2004, 2010), ter Horst (2005), and de Bruijn et al. (2005) rely on the fact that the set of all (relevant) entailed triples of a given graph can be computed in polynomial time using the RDFS entailment rules (ter Horst, 2005); the problem can then be reduced to subgraph homomorphism. From Corollary 1 and the fact that the problem of checking ground entailment in Datalog (Dantsin, Eiter, Gottlob, & Voronkov, 2001) is polynomial in the size of the data (i.e., tr(S)) we obtain a novel argument for membership.\nNP-hardness of non-ground entailment has been shown through a reduction from a known NP-hard problem (ter Horst, 2005).\nFrom the embedding in F-Logic (Theorem 1), we obtain the following upper bound for the complexity of simple and RDF entailment.\nProposition 11. Let S and E be RDF graphs. If E is fixed, the problems S |=s E and S |=rdf E are decidable in LogSpace in the size of S. The problems S |=s E and S |=rdf E are decidable in LogSpace in the combined size of the graphs if E is ground.\nProof Sketch. It is easy to see that the only fact that could potentially be recursively derived from \u03a8rdf is rdf:type[rdf:type rdf:Property]; however, rdf:type[rdf:type rdf:Property] \u2208 \u03a8rdf. Thus, sk(tr(S)) and sk(tr(S))\u222a\u03a8rdf may be treated as nonrecursive Datalog programs.\nThe proposition then follows straightforwardly from Corollary 1 and the fact that ground entailment in nonrecursive Datalog is in LogSpace in the size of the data (Abiteboul, Hull, & Vianu, 1995), with the data being the input RDF graphs.\nIt turns out that we cannot obtain a LogSpace upper bound for RDFS entailment. In fact, it turns out that ground rdfs-, and hence ground rdfs-D* - and rdfs-D-entailment, is PTime-hard.\nProposition 12. There exist ground RDF graphs S and E such that the decision problems S |=rdfs E, S |=rdfs-D* E, and S |=rdfs-D E are PTime-hard.\nProof. We proceed by reduction from the PTime-hard problem path system accessibility (Jones & Laaser, 1974; Gary & Johnson, 1979), which is defined as: Instance: A set X of nodes, subsets S, T \u2286 X of source and terminal nodes, and a relation R \u2286 X \u00d7X \u00d7X. Question: A node x \u2208 X is accessible if x \u2208 S or if there exist accessible nodes y, z \u2208 X such that \u3008x, y, z\u3009 \u2208 R. Is there an accessible terminal node t \u2208 T?\nIn the remainder sp is short for rdfs:subPropertyOf. We now encode this problem into RDFS. The graph G is constructed as follows:\n\u2022 for every source node x \u2208 S include the triple \u3008x, sp, sp\u3009,\n\u2022 for every terminal node x \u2208 T include the triple \u3008a, sp, x\u3009, and\n\u2022 for every tuple \u3008x, y, z\u3009 \u2208 R include the triple \u3008x, y, z\u3009.\nWe show that a node t \u2208 X is accessible iff G |=rdfs \u3008t, sp, sp\u3009. It follows that there exists an accessible node iff G |=rdfs \u3008a, sp, sp\u3009.\n(\u21d2) We proceed by induction. Base case: if t \u2208 S then \u3008t, sp, sp\u3009 \u2208 G, so clearly G |=rdfs \u3008t, sp, sp\u3009.\nInduction step: consider \u3008t, y, z\u3009 \u2208 R such that y, z are accessible. We have that \u3008t, y, z\u3009 is included in G and G |=rdfs \u3008y, sp, sp\u3009 and G |=rdfs \u3008z, sp, sp\u3009, since y and z are accessible. Condition 10 in Table 5 implies that G |=rdfs \u3008t, sp, z\u3009. By transitivity of sp (condition 9 in Table 5) we can subsequently conclude that G |=rdfs \u3008t, sp, sp\u3009.\n(\u21d0) Assume, on the contrary, that t \u2208 X is not accessible. It is then straightforward to construct an rdfs-interpretation I such that I |=rdfs G and I 6|=rdfs \u3008t, sp, sp\u3009, a contradiction.\nUsing the correspondence of Proposition 7, the results on the complexity of reasoning in DL-LiteR (Calvanese et al., 2007), and the classical results on skolemization (Fitting, 1996) we obtain the following result for extensional RDFS entailment. Recall the notion of standard use of the RDFS vocabulary from Definition 2.\nProposition 13. Let S and E be RDF graphs with only standard use of the RDFS vocabulary such that E E S. Then, the problem of deciding S |=erdfs E is NP-complete, and NLogSpace-complete if E is ground.\nProof. Assume that E is ground. We first demonstrate membership. We have that FO(sk(trerdfs(S))\u222a\u03a8erdfs-V ) is a theory of contextual FOL that is equivalent to a contextual DL-LiteR knowledge base (by Proposition 7). If E is ground, then, as a straightforward consequence from Theorems 2 and 3,\nS |=erdfs E iff FO(sk(trerdfs(S)) \u222a\u03a8erdfs-V\u2212S\u222aE ) |=c FO(tr erdfs(E)).\nA contextual DL-LiteR theory \u03a6 c (resp., formula \u03c6c) can be straightforwardly rewritten\nto a corresponding classical DL-LiteR theory \u03a6 (resp., formula \u03c6) such that\n\u03a6c |=c \u03c6c iff \u03a6 |= \u03c6.\nSince this transformation is linear in the size of the knowledge base, the complexity of deciding satisfiability and entailment of contextual DL-LiteR knowledge bases is the same as that of DL-LiteR knowledge bases, namely NLogSpace (Calvanese et al., 2007).\nHardness is shown by reduction from a known NLogSpace-hard problem: Graph reachability (Papadimitriou, 1994) can be encoded using subclass statements: edges in the graph are represented in the RDF graph S by rdfs:subClassOf-triples and t is reachable from s iff S |=erdfs {\u3008s, rdfs:subClassOf, t\u3009}.\nThis result immediately leads to the following NP algorithm for deciding S |=erdfs E, in case E is not ground: 1. Guess a mapping \u03b8 from blank nodes in E to ground terms in FO(sk(trerdfs(S))\u222a\u03a8erdfs-V\u2212S\u222aE ). 2. Check whether FO(sk(trerdfs(S)) \u222a\u03a8erdfs-V\u2212S\u222aE ) |=c FO(trerdfs(E)\u03b8). This algorithm is clearly sound and complete, since the theory FO(sk(trerdfs(S))\u222a\u03a8erdfs-V\u2212S\u222aE ) is universal.\nNP-hardness follows from NP-hardness of simple entailment (Proposition 10), which is straightforwardly encoded into extensional RDFS entailment.\nFor x-D-entailment with arbitrary datatype maps we obtain the following novel lower bound.\nProposition 14. There are RDF graphs S and E and a datatype map D such that deciding S |=s-D E is coNP-hard in the size of S.\nProof. We proceed by reduction from the complement of graph k-colorability for k \u2265 3, i.e., the nonexistence of a k-coloring. This problem is coNP-complete (Gary & Johnson, 1979):\nInstance: A graph G = \u3008V,E\u3009 and a positive integer k \u2264 |V | such that k \u2265 3. Question: A k-coloring is an assignment from nodes to colors f : V \u2192 {1, 2, . . . , k} such that no two adjacent nodes share the same color, i.e., if \u3008u, v\u3009 \u2208 E, then f(u) 6= f(v). Is it the case that there is no k-coloring?\nLet D be a datatype map that includes rdf:XMLLiteral and that maps a URI d to a datatype D(d) with an ordered value space of cardinality k, let S be the smallest RDF graph such that:\n\u2022 for every v \u2208 V , \u3008v, rdf:type, d\u3009 \u2208 S and\n\u2022 for every \u3008u, v\u3009 \u2208 E, \u3008u, R, v\u3009 \u2208 S,\nwhere R is a URI, and let H = {\u3008 :x, R, :x\u3009}, where :x is a blank node. We now show that G does not have a k-coloring if and only if S |=s-D H. (\u21d2) Assume, on the contrary, that S 6|=s-D H, which means there is an s-D-interpretation I such that I |= S and I 6|= H. Therefore, (*) there is no s \u2208 IR such that \u3008s, s\u3009 \u2208 IEXT(IS(R)). Consider any \u3008u, v\u3009 \u2208 E; by (*) we have that IS(u) 6= IS(v). Since \u3008u, rdf:type, d\u3009, \u3008v, rdf:type, d\u3009 \u2208 S, IS(u), IS(v) \u2208 D(d), by condition 20 in Table 8. Now let f(v) = IS(v) for every v \u2208 V . We have that f is a k-coloring, a contradiction.\n(\u21d0) Analogously, if there exists a k-coloring, one can construct an s-D-interpretation that is a model of S, but not of H.\nA polynomial (resp., logspace) datatype map D is a datatype map for which holds that deciding well-typedness of literals and deciding L2V D(u)(s) = L2V D(u\n\u2032)(s\u2032) and l = L2V D(u)(s), where l is a plain literal and (s, u), (s\u2032, u\u2032) are well-typed literals, can be done in PTime (resp., LogSpace).\nConsidering definite datatype maps, we obtain the following lower bound from Theorem 5 and the data complexity of Datalog, exploiting Skolemization, analogous to Corollary 1, and exploiting the fact that we need to take into account only a subset of the RDF(S) axiomatic triples, analogous to Proposition 4.\nProposition 15. Let D be a definite polynomial datatype map. Then, the decision problems S |=s-D E, S |=rdf-D E, and S |=rdfs-D E are NP-complete in the combined size of S and E, and polynomial in the size of S. If E is ground, then the respective problems are in PTime.\nIt turns out that, analogous to the case without datatypes, we can further refine the upper bounds of simple- and rdf -entailment.\nLemma 1. Let \u03a6 be a theory and let D be a logspace datatype map. Then, (\u03a6)n can be computed in LogSpace.\nProof. With WL we denote the set of plain and well-typed literals, and with < the lexicographical ordering over WL. If l is a plain literal, we define vl = l; if (s, u) is a well-typed literal, v(s,u) = L2V D(u)(s). The following algorithm returns the representation of a literal l \u2208 WL in LogSpace: iterate over all literals l\u2032 < l, until the least literal l\u2032\u2032 such that vl\u2032\u2032 = vl is found; observe that deciding l\u2032 < l and deciding vl \u2032\u2032 = vl can be done in LogSpace.\nFrom the lemma we obtain the following upper bound, by considerations analogous to Proposition 11 and the fact that the axioms in \u03a8D\\\u03a8rdf do not introduce recursion.\nProposition 16. Let S and E be RDF graphs and let D be a logspace datatype map. Then, the problems S |=s-D* E and S |=rdf-D* E are decidable in LogSpace in the size of S, and in the combined size of the graphs if E is ground.\nFurthermore, if D is definite, the problems S |=s-D E and S |=rdf-D E are decidable in LogSpace in the size of S, and in the combined size of the graphs if E is ground.\nTable 2 summarizes the complexity of reasoning with the entailment regimes of RDF; \u201cstand. RDFS\u201d stands for \u201conly standard use of the RDFS vocabulary; S and E are such that E E S\u201d. The results in the first and fourth line of the table, and the upper bound for ground rdfs-entailment were previously known (Gutierrez et al., 2004; de Bruijn et al., 2005; ter Horst, 2005). To the best of our knowledge, the other results are novel.\nTable 3 summarizes the complexity of reasoning with datatypes, measured in the size of the entailing graph S. \u201cDefinite D\u201d stands for D entailment restricted to definite datatype maps. The LogSpace results require the datatype map D to be logspace as well, i.e., it must be decidable in LogSpace whether two literals are equal under the interpretation given by D . We suspect that many datatype maps of interest are logspace \u2013 examples are the XML schema datatypes (Peterson et al., 2009). The upper bounds for rdfs- and rdfs-D*-\nentailment are known from the literature (ter Horst, 2005). To the best of our knowledge, the other results in the table are novel."}, {"heading": "6. Conclusions and Future Work", "text": "We have presented embeddings of the different RDF entailment regimes in F-Logic, and we have shown how deductive database and description logic technology can be used for reasoning with RDF.\nKnown complexity results from the fields of deductive databases and description logics resulted in several novel upper bounds, in particular, ground simple- and rdf -entailment are in LogSpace, as are the respective extensions with D* datatype semantics; non-ground (resp., ground) erdfs-entailment of graphs with only standard use of the RDFS vocabulary is in NP (resp., NLogSpace). To the best of our knowledge these are the first known upper bounds for extensional RDFS entailment for a nontrivial subset of RDF graphs. For the case of extensions of simple-, rdf -, and rdfs-entailment with D datatype support, the upper bounds for non-ground and ground entailment are the same as for D* entailment when considering definite datatypes, which do not require reasoning by case.\nIn addition, we have established several lower bounds through reductions from known hard problems. In particular, rdfs-entailment turns out to be PTime-hard and simpleentailment extended with D datatype support turns out to be coNP-hard, both in the size of the entailing graph. We also found a matching lower bound for the NLogSpace result for ground erdfs-entailment of graphs with only standard use of the RDFS vocabulary.\nThe negative result concerning ground rdfs-entailment (i.e., PTime-hardness) might come as a surprise because the language seems far less expressive than other PTime-hard languages (e.g., variable-free Datalog (Dantsin et al., 2001) and DL-LiteR,u, an extension of DL-LiteR (Calvanese et al., 2007)). The PTime-hardness proof suggests that the complexity originates from the possibility to use RDFS vocabulary in arbitrary places in RDF statements, e.g., rdfs:subPropertyOf in the object position of a triple. Indeed, ground entailment in the minimal RDFS fragment by Mun\u0303oz, Pe\u0301rez, and Gutierrez (2009) can be decided in O(nlogn).6 We suspect that the minimal RDFS fragment can be extended with many useful features, such as class and property declarations and the RDFS metadata vocabulary, without compromising the O(nlogn) upper bound. This is a topic for future work.\nThe negative result concerning D entailment, even when not considering the RDFS vocabulary (i.e., coNP-hardness), suggests that one should restrict oneself to a weaker datatype semantics such as D* or one should use only definite datatype maps, which precludes the use of finite datatypes such as bool or int (Peterson et al., 2009). The latter approach was taken in the specification of the tractable fragments (also called profiles) of OWL 2 (Motik et al., 2009a), which has a datatype semantics similar to the D semantics.\nThe investigation reported on in this paper has formed the basis for the specification of combinations of RIF-BLD rules (RIF Working Group, 2010a), which are essentially Horn logic formulas, with RDF graphs. The RIF RDF and OWL specification (RIF Working Group, 2010b) gives a model-theoretic account of the semantics of RIF-RDF combinations\n6. This minimal RDFS disallows the use of any RDF(S) vocabulary besides the properties in the RDF(S) ontology vocabulary, and allows the use of these properties only in the predicate position of triples.\nand suggests how such combinations can be embedded into RIF-BLD rules, based on the embedding in Section 3.2. A particular challenge for future work is the combination of RDF graphs with extensions of RIF-BLD that allow nonmonotonic negation in the rules, and the interaction of this negation with blank nodes.\nAnother topic for future investigation is the precise relationship between extensional RDFS and OWL. In particular, the relationship between extensional RDFS with only standard use of the RDFS vocabulary and the OWL 2 QL fragment of OWL 2 (Motik et al., 2009a), which is based on contextual DL-LiteR. The embedding in the proof of Proposition 7 provides a promising starting point."}, {"heading": "Acknowledgments", "text": "Jos de Bruijn was partially supported by the European Commission under the projects Knowledge Web (IST-2004-507482) and ONTORULE (FP7 231875). Stijn Heymans was partially supported by the Austrian Science Fund (FWF) under projects P20305 and P20840 and by the European Commission under the project ONTORULE (FP7 231875)."}, {"heading": "Appendix A. RDF(S) Semantics", "text": "In this appendix we define the notions of RDF, RDFS, eRDFS, D* , and D interpretations (Hayes, 2004; ter Horst, 2005). Recall the definition of interpretation in Section 3.1.\nRDF Interpretations The RDF vocabulary consists of the following symbols:\nrdf:type rdf:Property rdf:XMLLiteral rdf:nil rdf:List rdf:Statement rdf:subject rdf:predicate rdf:object rdf:first rdf:rest rdf:Seq rdf:Bag rdf:value rdf:Alt rdf: 1 rdf: 2 . . .\nThe RDF ontology vocabulary consists of the symbols rdf:type and rdf:Property. Note that rdf: i, for any positive integer i, is part of the RDF vocabulary. Thus, the RDF vocabulary is infinite. In the remainder, we omit the prefix rdf: when using the RDF vocabulary.\nA typed literal (s, XMLLiteral) is a well-typed XML literal if s is in the lexical space of XMLLiteral, as defined in (Klyne & Carroll, 2004, Section 5.1); the XML value of s, denoted xml(s), is in one-to-one correspondence with s. If s is not in the lexical space of XMLLiteral, then (s, XMLLiteral) is an ill-typed XML literal.\nGiven an interpretation I, the class extension of an object x \u2208 IR is the set of elements connected to x via type, i.e., the instances of x. It is defined as ICEXT(x) = {k | \u3008k, x\u3009 \u2208 IEXT(IS(type))}.\nAn interpretation I of a vocabulary V = \u3008C,PL, T L\u3009 is an rdf-interpretation if V includes the RDF vocabulary and conditions 1\u20134 in Table 4 hold in I.\nRDFS Interpretations The RDFS vocabulary consists of:\nrdfs:domain rdfs:range rdfs:Resource rdfs:Literal rdfs:Datatype rdfs:Class rdfs:subClassOf rdfs:subPropertyOf rdfs:member rdfs:Container rdfs:label rdfs:ContainerMembershipProperty rdfs:comment rdfs:seeAlso rdfs:isDefinedBy\nThe RDFS ontology vocabulary consists of the symbols rdfs:subClassOf, rdfs:subPropertyOf, rdfs:domain, rdfs:range, rdfs:Class, and rdfs:Datatype. In the remainder we omit the prefix rdfs: when using the RDFS vocabulary.\nWe say that an rdf -interpretation I of a vocabulary V is an rdfs-interpretation if V includes the RDFS vocabulary and conditions 5\u201315 depicted in Table 5 hold in I. As a shortcut, we define IEXTp(o) = {s | \u3008s, IS(o)\u3009 \u2208 IEXT(IS(p))}.\nAn RDF (resp, RDFS) axiomatic triple is a triple that is satisfied in every rdf -(resp, rdfs-) interpretation. Conditions 1 and 5 correspond to the RDF(S) axiomatic triples in the following way; see also (Hayes, 2004, Sections 3.1 and 4.1):\n\u2022 IS(s) \u2208 IP corresponds to the axiomatic triple \u3008s, type, rdf:Property\u3009,\n\u2022 IS(s) \u2208 IEXTp(o) corresponds to the axiomatic triple \u3008s, p, o\u3009, and\n\u2022 IS(s) \u2208 ICEXT(IS(c)) corresponds to the axiomatic triple \u3008s, type, c\u3009.\nExtensional RDFS Interpretations The normative RDFS semantics, reviewed above, is also called the intensional RDFS semantics. The RDF semantics specification (Hayes, 2004) also defines an extensional RDFS semantics (eRDFS).\nAn rdfs-interpretation I is an erdfs-interpretation if the conditions depicted in Table 6 hold.\nD* Interpretations Given a vocabulary V and a simple datatype map D, an s-interpretation of V is an s-D*-interpretation if V includes dom(D) and conditions 16\u201319 in Table 7 are satisfied for each u \u2208 dom(D).\nGiven a vocabulary V and datatype map D, an rdf (resp., rdfs, erdfs)-interpretation I of V is an rdf -D* (resp., rdfs-D* , erdfs-D* )-interpretation if I is an s-D* -interpretation.\nD Interpretations Given a vocabulary V and a simple datatype map D, an s-D* -interpretation of V is an s-D-interpretation if it satisfies conditions 20\u201322 in Table 8 for each u \u2208 dom(D).\nGiven a vocabulary V and a datatype map D, an rdf (resp., rdfs, erdfs)-interpretation I of V is an rdf -D (resp., rdfs-D , erdfs-D)-interpretation if I is an s-D-interpretation."}, {"heading": "Appendix B. Embeddings", "text": "This appendix contains the axiomatization \u03a8x of the entailment regimes x \u2208 {s, rdf, rdf, erdfs} and the axiomatization of the datatype entailment regimes \u03a8x-D*,\u03a8x-D, referenced from Sections 3 and 4.\nFollowing the convention in Appendix A we omit the prefixes rdf: and rdfs: when using the RDF and RDF vocabularies."}, {"heading": "B.1 RDF Entailment Regimes", "text": "The axiomatization of the s, rdf , rdfs, and erdfs entailment regimes, denoted \u03a8x, for x \u2208 {s, rdf, rdfs, erdfs}, is defined in Table 9."}, {"heading": "B.2 Datatype Entailment Regimes", "text": "The axiomatization of the D* and D entailment regimes, denoted \u03a8x-D* and \u03a8x-D, respectively, for x \u2208 {s, rdf, rdfs, erdfs}, is defined in Table 10.\nNote that D entailment requires that whenever two URIs are mapped to the same individual in a given interpretation, the URIs can be used interchangeably in typed literals. However, since equality between URIs cannot be stated in RDF(S) \u2013 or indeed inferred \u2013 we do not need to consider this case in our embeddings."}, {"heading": "B.3 Extensional RDFS", "text": "Let V = \u3008C,PL, T L\u3009 be a vocabulary. The mapping function trerdfs, defined in Section 3.3, deals with the eRDFS semantics of most of the RDF(S) vocabulary through direct embedding. We define here the theory \u03a8erdfs-V , which deals with the remainder of the RDF(S) vocabulary.\n\u03a8erdfs-V = {trerdfs(\u3008s, p, o\u3009) | \u3008s, p, o\u3009 is an RDF(S) axiomatic triple with only standard use of the RDF(S) vocabulary}\u222a {t :XMLLiteral | t \u2208 T L is a well-typed XML literal}\u222a {t : illxml | t \u2208 T L is an ill-typed XML literal}\u222a {t :Literal | t \u2208 PL}\u222a {\u2200x(x :Literal \u2227 x : illxml \u2283 \u22a5)}"}, {"heading": "Appendix C. Proofs", "text": "This appendix contains the proofs of the propositions and theorems in Sections 3 and 4."}, {"heading": "C.1 Proof of Proposition 2", "text": "Consider a generalized RDF graph S, an interpretation I = \u3008IR, IP, IS, IEXT\u3009 for which holds that IP = IR includes every term in S, IS(c) = c for any URI c, IL(l) = l for any typed literal l, and for every triple \u3008s, p, o\u3009 \u2208 S, (s, o) \u2208 IEXT (p), and a blank node\nassignment A : bl(S)\u2192 IR that maps every blank node to itself. Clearly, (I, A) |= S, I |= S, and I is an s-interpretation. Therefore, S is s-satisfiable.\nIt is easy to see that the following generalized RDF graph is rdf -, and hence rdfs- and erdfs-unsatisfiable, by the negation in condition 4 in Table 4: S = {\u3008(\u201c<notXML\u201d, XMLLiteral), type, XMLLiteral\u3009}: (\u201c<notXML\u201d, XMLLiteral) is an ill-typed XML literal, so by condition 4 in Table 4, IL((\u201c<notXML\u201d, XMLLiteral)) /\u2208 ICEXT(IS(XMLLiteral)). However, if the graph were satisfied in some rdf -interpretation, it must be the case that IL((\u201c<notXML\u201d, XMLLiteral)) \u2208 ICEXT(IS(XMLLiteral)), a contradiction.\nHayes (2004) observed that one can create a similar situation with a normal RDF graph and a range constraint; this graph is rdfs- and hence erdfs-unsatisfiable."}, {"heading": "C.2 Proof of Theorem 1", "text": "We first show that S 6|=x E iff tr(S) \u222a \u03a8x 6|=f tr(E). From this follows immediately that S |=x E iff tr(S) \u222a\u03a8x |=f tr(E). (\u21d2) Let V = \u3008C,PL, T L\u3009 be the vocabulary of S and E and let L be an F-language that conforms with V . Assume that S 6|=x E. This means that there is an x-interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009 such that I |= S and I 6|= E. We construct a corresponding F-structure I = \u3008U, \u2208U , IC , I , IP \u3009 in the following way:\n(i) U = IR \u222a IP,\n(ii) IF (t) = IS(t) for every URI reference t \u2208 C, IF (t) = t for every plain literal t \u2208 PL, and IF (t) = IL(t) for every typed literal t \u2208 T L,\n(iii) I (k) = IEXT(k) for every k \u2208 IP and I (k) = \u2205 for every k /\u2208 IP,\n(iv) IP (illD) = {u | t \u2208 T L is an ill-typed XML literal and IL(t) = u}.\nIt is straightforward to verify that I |=f tr(S) \u222a \u03a8x and I 6|=f tr(E). Hence, tr(S) \u222a \u03a8x 6|=f tr(E). (\u21d0) Assume that tr(S)\u222a\u03a8x 6|=f tr(E). This means that (by (Fitting, 1996, Theorem 5.9.4) and Proposition 6) there is a Herbrand F-structure I = \u3008U, \u2208U , IC , I , IP \u3009 such that I |=f tr(S)\u222a\u03a8x and I 6|=f tr(E). Since I is a Herbrand F-structure, U includes all constant symbols, and IC maps every constant symbol to itself. We construct a corresponding interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009 as follows:\n(i) IP = {p | \u3008p, IF (Property)\u3009 \u2208 I (IF (type))} \u222a {p | \u2203s, o.\u3008s, o\u3009 \u2208 I (p)},\n(ii) LV = PL \u222a {xml(s) | ((s, XMLLiteral) \u2208 T L \u2227 (s, XMLLiteral) is a well-typed XML literal)} \u222a {l | \u3008l, IF (Literal)\u3009 \u2208 I (IF (type))},\n(iii) IR = U \u222a LV,\n(iv) IS(t) = IF (t) for every URI t \u2208 C, IL((s, u)) = xml(s) if (s, u) \u2208 T L is a well-typed XML literal; IL((s, u)) = IF ((s, u)) for (s, u) \u2208 T L if (s, u) \u2208 T L is not a well-typed XML literal, and\n(v) for any p \u2208 U and any \u3008s, o\u3009 \u2208 I (p): \u3008s\u2032, o\u2032\u3009 \u2208 IEXT(p), where s\u2032 (resp., o\u2032) is: if there is some (t, XMLLiteral) \u2208 T L such that (t, XMLLiteral) is a well-typed XML literal and IF ((t, XMLLiteral)) = s (resp., \u00b7 \u00b7 \u00b7 = o), then s\u2032 = xml(t) (resp., o\u2032 = xml(t)); otherwise s\u2032 = s (resp., o\u2032 = o).\nOne can verify that I is an x-interpretation, I |= S, and I 6|= E. Hence, S 6|= E.\nThe second part of the theorem can be shown analogously."}, {"heading": "C.3 Proof of Proposition 4", "text": "By Corollary 1 we have that S |=x E iff sk(tr(S)) \u222a \u03a8x |=f tr(E). Therefore, we need to show sk(tr(S)) \u222a\u03a8x\u2212S\u222aE |=f tr(E) iff sk(tr(S)) \u222a\u03a8x |=f tr(E). (\u21d2) Trivial, since sk(tr(S)) \u222a\u03a8x\u2212S\u222aE \u2286 sk(tr(S)) \u222a\u03a8x. (\u21d0) Consider the case x = erdfs. Let I be a minimal Herbrand model of sk(tr(S))\u222a\u03a8x and let I\u2032 be obtained from I by removing all triples involving container membership properties n that appear in \u03a8x\\\u03a8x\u2212S\u222aE . We can verify, e.g., by doing a case analysis on the shape of the triples in S, that I\u2032 is a minimal model of sk(tr(S))\u222a\u03a8x\u2212S\u222aE . Similarly, one can verify that if I |=f tr(E), then I\u2032 |=f tr(E).\nAnalogous for x \u2208 {s, rdf, rdfs}."}, {"heading": "C.4 Proof of Theorem 2", "text": "We prove both directions by contraposition.\n(\u21d2) Assume trerdfs(S) \u222a \u03a8erdfs-V 6|=f trerdfs(E). This means that there is a Herbrand Fstructure I = \u3008U, \u2208U , IC , I , IP \u3009 such that I |=f trerdfs(S) \u222a \u03a8erdfs-V and I 6|=f trerdfs(E).\nWe define xml\u2032(x) = xml(s) if x is a well-typed XML literal (s, XMLLiteral); otherwise xml\u2032(x) = x. We construct a corresponding interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009 as follows:\n(i) LV = {xml\u2032(l) | l \u2208U IF (Literal)},\n(ii) IP = IR = U \u222a LV \u222a {type, subClassOf, domain, range, subPropertyOf},\n(iii) IS(t) = t for every URI reference t in S, E, or the RDF(S) vocabulary,\n(iv) IL(t) = xml\u2032(t) for any t \u2208 T L,\n(v) for any p \u2208 U and any \u3008s, o\u3009 \u2208 I (p), \u3008xml\u2032(s), xml\u2032(o)\u3009 \u2208 IEXT(p),\n(vi) IEXT(type) is the smallest relation such that\n(a) IEXT(type) \u2287 {\u3008xml\u2032(s), xml\u2032(o)\u3009 | s \u2208U o};\n(b) ICEXT(Resource) = ICEXT(Class) = IR; and\n(c) ICEXT(Property) = IP,\n(vii) IEXT(domain) is the set of all tuples \u3008x, y\u3009, x, y \u2208 IR, such that (if \u3008u, v\u3009 \u2208 IEXT(x), then u \u2208 ICEXT(y)); analogous for IEXT(subClassOf), IEXT(subPropertyOf), and IEXT(range) (see Table 6 for the precise conditions).\nOne can verify that I |= S, and I 6|= E, since S and E have only standard use of the RDFS vocabulary, E does not include occurrences of Resource, Class, or Property, and the class and property vocabularies of E are subsets of the respective vocabularies of S.\nI clearly satisfies conditions 1\u20134 in Table 4, conditions 6\u201315 in Table 5, and conditions 7\u2032\u201312\u2032 in Table 6. To verify that I satisfies condition 5 in Table 4 one only needs to keep in mind that ICEXT(Resource) = ICEXT(Class) = IR and ICEXT(Property) = IP. So, I is an erdfs-interpretation and thus S 6|=erdfs E. (\u21d0) Assume S 6|=erdfs E. This means there is some erdfs-interpretation I\u2032 such that, for any URI t, IS(t) = t (making I\u2032 similar to a Herbrand interpretation) and such that I\u2032 |= S and I\u2032 6|= E. Let I = \u3008IR, IP,LV, IS, IL, IEXT\u3009 be an erdfs-interpretation obtained from I\u2032 such that IP = IR and ICEXT(IS(Class)) = IR, and such that IEXT is minimally extended to satisfy the semantic conditions in Tables 4, 5, and 6. Clearly, there must be such an erdfs-interpretation and I |= S. We also have, by the restrictions on the class and property vocabularies as well as the non-occurrence in E of Resource, Class, and Property, that I 6|= E.\nWe construct a corresponding F-Logic interpretation I = \u3008U, \u2208U , IC , I , IP \u3009 as follows: (i) U = IR, (ii) IF (t) = t for every URI or plain literal t, IF (t) = t for every t \u2208 T L, (iii) I (k) = IEXT(k) for every k \u2208 U , and (iv) \u2208U= IEXT(IS(type)).\nIt can be straightforwardly verified that I |=f trerdfs(S) \u222a \u03a8erdfs-V and I6|=f trerdfs(E). Therefore, it must be the case that trerdfs(S) \u222a\u03a8erdfs-V 6|=f trerdfs(E)."}, {"heading": "C.5 Proof of Proposition 7", "text": "\u03a6 is obtained from FO(trerdfs(S) \u222a\u03a8erdfs-V ) in the following way:\n(i) Class membership and property value statements of the forms A(a), P (a1, a2) are included as such,\n(ii) Subclass and subproperty statements are included as such,\n(iii) Domain constraints of the form \u2200x, y(P (x, y) \u2283 A(x)) are rewritten to role-typing statements of the form \u2200x(\u2203y(P (x, y)) \u2283 A(x)),\n(iv) Range constraints of the form \u2200x, y(P (x, y) \u2283 A(y)) are rewritten to role-typing statements of the form \u2200x(\u2203y(P (y, x)) \u2283 A(x)), and\n(v) Constraints of the form \u2200x(A(x) \u2227B(x) \u2283 \u22a5) are rewritten to \u2200x(A(x) \u2283 \u00acB(x)).\n\u03a6 and FO(trerdfs(S)) are obviously equivalent, and it is easy to verify that \u03a6 is the FOL equivalent of a contextual DL-LiteR knowledge base."}, {"heading": "C.6 Proof of Theorem 4", "text": "We first establish the second part of the theorem, i.e., S is x-D*-satisfiable iff tr(S)\u222a\u03a8x-D* has a model.\n(\u21d2) Let V = \u3008C,PL, T L\u3009 be the vocabulary of S and let L be an F-language that conforms with V . Assume that S is x-D*-satisfiable. This means that there is an x-D*-interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009 such that I |= S. We construct a corresponding F-structure I = \u3008U, \u2208U , IC , I , IP \u3009 in the following way (analogous to the construction in the \u2018\u21d2\u2019 direction in the proof of Theorem 1):\n(i) U = IR \u222a IP,\n(ii) IF (t) = IS(t) for every URI reference t \u2208 C, IF (t) = t for every plain literal t \u2208 PL, IF (t) = IL(t) for every typed literal t \u2208 T L,\n(iii) I (k) = IEXT(k) for every k \u2208 IP,\n(iv) IP (illD) = {u | t \u2208 T L is an ill-typed literal and IL(t) = u}.\nClearly, I |=f tr(S). If a literal t \u2208 T L is an ill-typed XML literal, then clearly it is an ill-typed literal. Then, there is no ill-typed literal t such that IS(t) \u2208 LV (by condition 19 in Table 7), and hence there is no ill-typed literal t such that IS(t) \u2208 ICEXT(Literal) or IS(t) \u2208 ICEXT(XMLLiteral), by condition 4 in Table 4 (if x = rdf, x = rdfs, or x = erdfs) and condition 6 in Table 5 (if x = rdfs or x = erdfs). Satisfaction of \u03a8x is then established straightforwardly.\nConsider a well-typed literal (s, u) and a plain literal l. In case l = L2V D(u)(s), IL((s, u)) = l, by condition 18 in Table 7, and thus IF ((s, u)) = IF (l) = l and I |=f l = (s, u), by (ii). Analogous for the case of two distinct well-typed literals. Therefore, I |=f \u03a8V -D*-=.\nConsider the definition of \u03a8x-D* in Table 10. We have established that I |=f \u03a8x \u222a \u03a8V -D*-=. Satisfaction of the second, first, third, and fourth sets of formulas in the table follows immediately from, respectively, (iv), and conditions 18, 17, and 19 in Table 7. Therefore, I |=f \u03a8x-D*.\nThis establishes I |=f tr(S) \u222a\u03a8x-D*. (\u21d0) Assume that tr(S) \u222a\u03a8x-D* has a model. Let \u03a6 = tr(S) \u222a\u03a8x-D*.\nLet \u03a6\u2248 be obtained from \u03a6 by replacing every occurrence of = with \u2248 and adding the usual congruence axioms (cf. Fitting, 1996, Chapter 9). It is known that this axiomatization of equality preserves satisfiability and entailment in first-order logic (Fitting, 1996, Theorem 9.3.9). This is also the case for F-Logic, by Proposition 1.\nWe extend the signature of \u03a6\u2248 with a set of URI references C\u2032, disjoint from C, with cardinality |bl(S)|; i.e., the signature is \u03a3\u2032 = \u3008C \u222a PL \u222a T L \u222a C\u2032,P \u222a {\u2248}\u3009. Since \u03a6\u2248 has a model (as \u03a6 has), there exists, by classical results, a Herbrand F-structure I such that I |=f \u03a6\u2248. We have that U = C \u222a C\u2032 \u222a PL \u222a T L.\nFor any u \u2208 U , define \u03c3 as follows:\n\u2022 if u \u2208 C such that u \u2208 dom(D), \u03c3(u) = D(u),\n\u2022 if (s, u) \u2208 T L is a well-typed literal and u \u2208 dom(D), \u03c3((s, u)) = L2V D(u)(s),\n\u2022 otherwise, \u03c3(u) = u.\nWe construct a corresponding interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009:\n(i) IP = {\u03c3(p) | \u3008p, IF (Property)\u3009 \u2208 I (IF (type))} \u222a {\u03c3(p) | \u2203s, o.\u3008s, o\u3009 \u2208 I (p)},\n(ii) LV = PL \u222a {L2V D(u)(s) | (s, u) \u2208 T L, u \u2208 dom(D), (s, u) is a well-typed literal)} \u222a {\u03c3(l) | \u3008l, IF (Literal)\u3009 \u2208 I (IF (type)) & (x = rdfs or x = erdfs)},\n(iii) IR = U \u222a LV,\n(iv) IS(u) = \u03c3(u) for every URI reference u \u2208 C; IL((s, u)) = \u03c3((s, u)) for every (s, u) \u2208 T L, and\n(v) for any p \u2208 IP, IEXT is the smallest set such that \u3008s, o\u3009 \u2208 I (p) implies \u3008\u03c3(s), \u03c3(o)\u3009 \u2208 IEXT(\u03c3(p)).\nIt is easy to see that I |= S. Remains to verify that I is an x-D*-interpretation. Verifying that I is an x-interpretation is straightforward. It remains to verify the satisfaction of the conditions in Table 7.\nSatisfaction of condition 16 follows directly from the definition of I and \u03c3. For condition 17, we have that u \u2208 dom(D) and thus u[type Datatype] \u2208 \u03a8x-D*. As I satisfies \u03a8x-D* we have that \u3008IF (u), IF (Datatype)\u3009 \u2208 I (IF (type)), and so \u3008\u03c3(IF (u)), \u03c3(IF (Datatype))\u3009 \u2208 IEXT(\u03c3(IF (type))). By construction of IS, this yields IS(u) \u2208 ICEXT(IS(Datatype)).\nConsider some (s, u) \u2208 T L such that u \u2208 dom(D) and s \u2208 LD(u). Then, (s, u) is welltyped, and so IL((s, u)) = L2V D(u)(s) \u2208 LV. By definition of \u03a8x-D*, we have (s, u)[type u] \u2208 \u03a8x-D*; it follows that L2V D(u)(s) \u2208 ICEXT(D(u)). This establishes satisfaction of condition 18.\nCondition 19 is satisfied by the fact that LV does not contain ill-typed literals. Indeed, PL \u222a {L2V D(u)(s) | (s, u) \u2208 T L, u \u2208 dom(D), (s, u) is a well-typed literal)} does not contain ill-typed literals and if x is rdfs or erdfs, there is no ill-typed literal t such that I |=f t[type Literal], by the last axiom in the definition of \u03a8rdfs in Table 9.\nIt is easy to verify, for both directions, that we have I 6|= E iff I 6|=f tr(E). The first part of the theorem follows."}, {"heading": "C.7 Proof of Theorem 5", "text": "We first show correspondence of satisfiability.\n(\u21d2) Let V = \u3008C,PL, T L\u3009 be the vocabulary of S and E, let rdf be an x-D-interpretation that satisfies S and let L be an F-language that conforms with V . We construct an Fstructure I = \u3008U, \u2208U , IC , I , IP \u3009 that corresponds to I, using steps (i)\u2013(iv) as in the (\u21d2) direction of the proof of Theorem 4, with the additional step\n(v) IP (dt) = {\u3008x, u\u3009 | x \u2208 ICEXT(u) and u \u2208 ran(D)}.\nFrom the argument in the (\u21d2) direction in the proof of Theorem 4 follows that I |=f tr(S)\u222a \u03a8x-D*. Consider \u03a8x-D \\ \u03a8x-D*, as defined in Table 10. Satisfaction of the first set follows immediately from conditions 20 and 21 in Table 8. Satisfaction of the second set follows immediately from condition 20 in Table 8. Satisfaction of the third set follows immediately from (v).\nConsider any two u1, u2 \u2208 dom(D) such that V D(u1) \u2229 V D(u2) = \u2205. By condition 20 in Table 8, ICEXT(IS(u1))\u2229ICEXT(IS(u2)) = \u2205. From (v) then follows that there is no k \u2208 U such that \u3008k, IF (u1)\u3009 \u2208 IP (dt) and \u3008k, IF (u2)\u3009 \u2208 IP (dt). Consequently, I 6|=f \u2203x(dt(x, u1) \u2227 dt(x, u2)) and thus the fourth set of sentences is satisfied.\nConsider some (s, u) \u2208 T L and some u\u2032 \u2208 dom(D) such that IL((s, u)) = L2V D(u)(s) /\u2208 V D(u \u2032). By condition 20 in Table 8, ICEXT(IS(u\u2032)) = V D(u \u2032), and thus IL((s, u)) /\u2208 ICEXT(IS(u\u2032)). From (v) follows \u3008IF ((s, u)), IF (u\u2032)\u3009 /\u2208 IP (dt) and thus I6|=f dt((s, u), u\u2032), establishing satisfaction of the sixth set. The argument for the fifth set is obtained by replacing (s, u) \u2208 T L with l \u2208 PL.\nWe thus obtain I |=f \u03a8x-D. Therefore, tr(S) \u222a\u03a8x-D has a model.\n(\u21d0) Assume \u03a6 = tr(S) \u222a\u03a8x-D has a model. Let \u03a6\u2248 be obtained from \u03a6 as in the proof of Theorem 4 and let I = \u3008U, \u2208U , IC , I , IP \u3009 be a Herbrand F-structure that is a model of \u03a6\u2248. We construct a corresponding interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009 in the following way. W.l.o.g. we assume that no value space V d, for d \u2208 ran(D), contains any typed literal t \u2208 T L.\nWe observe that (*) for any two d1, d2 \u2208 dom(D) must hold that either V D(d1) and V D(d2) are disjoint or their overlap is infinite, since D is definite. In addition, if V D(d1) and V D(d2) are disjoint, then, by satisfaction of the fourth set in the definition of \u03a8x-D, (**) I6|=f t[type d1] \u2227 t[type d2] for any t \u2208 C \u222a C\u2032.\nFor a given URI u \u2208 C \u222a C\u2032 we define the mapping \u03c3 as follows:\n\u2022 if u \u2208 dom(D), then \u03c3(u) = D(u),\n\u2022 if \u3008u, u\u2032\u3009 \u2208 I (type), for some u\u2032 \u2208 dom(D), then \u03c3(u) = v, where v is such that\n\u2013 v \u2208 V D(u1) \u2229 \u00b7 \u00b7 \u00b7 \u2229 V D(un), where u1, . . . , un \u2208 dom(D) are all the datatype identifiers such that \u3008u, u1\u3009, . . . , \u3008u, un\u3009 \u2208 I (type); \u2013 there is no u\u2032 \u2208 C such that v = \u03c3(u\u2032); and \u2013 there is no (s, u\u2032) \u2208 T L such that u\u2032 \u2208 dom(D) and v = L2V D(u\u2032)(s);\nsuch a v must exist, because u cannot be a member of two disjoint datatypes, by (**), and V D(u1) \u2229 \u00b7 \u00b7 \u00b7 \u2229 V D(un) is an infinite set, by Definition 4,\n\u2022 otherwise, \u03c3(u) = u.\nFor a given literal l \u2208 PL \u222a T L we define \u03c3 as:\n\u2022 if l = (s, u) \u2208 T L is a well-typed literal, then \u03c3(s, u) = L2V D(u)(s),\n\u2022 otherwise \u03c3(l) = IF (l).\nOne can verify that \u03c3 is such that for any two distinct t1, t2 \u2208 C \u222aPL\u222a T L, either \u03c3(t1) = \u03c3(t2) and \u3008t1, t2\u3009 \u2208 IP (\u2248) (by definition of \u03a8V -D*-=) or \u03c3(t1) 6= \u03c3(t2).\nWe construct an RDF interpretation I = \u3008IR, IP,LV, IS, IL, IEXT\u3009, similar to the construction in the (\u21d0) direction of the proof of Theorem 4. Note that the respective constructions differ only in steps (ii) and (v).\n(i) IP = {\u03c3(p) | \u3008p, IF (Property)\u3009 \u2208 I (IF (type))} \u222a {\u03c3(p) | \u2203s, o.\u3008s, o\u3009 \u2208 I (p)}, (ii) LV = PL \u222a \u22c3 {V d | d \u2208 ran(D)} \u222a {\u03c3(l) | \u3008l, IF (Literal)\u3009 \u2208 I (IF (type)) & (x =\nrdfs or x = erdfs)},\n(iii) IR = U \u222a LV,\n(iv) IS(u) = \u03c3(u) for every u \u2208 C; IL((s, u)) = \u03c3((s, u)) for every (s, u) \u2208 T L, and\n(v) IEXT is the smallest set such that\n\u2022 ICEXT(IS(u)) = V D(u) for every u \u2208 dom(D), and \u2022 for any p \u2208 IP and \u3008s, o\u3009 \u2208 I (p), \u3008\u03c3(s), \u03c3(o)\u3009 \u2208 IEXT(\u03c3(p)).\nSatisfaction of all conditions up to and including 19 are established analogous to the (\u21d0) direction in the proof of Theorem 4. Notice that condition 20 is satisfied in I by (v).\nConsider a typed literal t = (s, u\u2032) \u2208 T L and a datatype identifier u \u2208 dom(D). If IS(u\u2032) = IS(u), then it must be the case that D(u\u2032) = D(u), by construction of I. If s \u2208 LD(u\u2032), then (s, u\u2032) is a well-typed literal, and thus IL((s, u\u2032)) = L2V D(u\u2032) = L2V D(u), by (iv). If s /\u2208 LD(u\u2032), then (s, u\u2032) is an ill-typed literal and IL((s, u\u2032)) = (s, u\u2032) /\u2208 LV, because LV does not contain ill-typed literals. Therefore, conditions 21 and 22 in Table 8 are satisfied.\nConsequently, I is an x-D-interpretation. We have that I |= S and and thus S is x-Dsatisfiable.\nThe second part of the theorem follows from the observation that, for both directions, we have I 6|= E iff I 6|=f tr(E)."}], "references": [{"title": "On the relative expressiveness of description logics and predicate logics", "author": ["A. Borgida"], "venue": "Artificial Intelligence, 82 (1\u20132), 353\u2013367.", "citeRegEx": "Borgida,? 1996", "shortCiteRegEx": "Borgida", "year": 1996}, {"title": "RDF vocabulary description language 1.0", "author": ["D. Brickley", "R.V. Guha"], "venue": "RDF schema. Recommendation", "citeRegEx": "Brickley and Guha,? \\Q2004\\E", "shortCiteRegEx": "Brickley and Guha", "year": 2004}, {"title": "Tractable reasoning and efficient query answering in description logics: the dl-lite family", "author": ["D. Calvanese", "G.D. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Complexity and expressive power of logic programming", "author": ["E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov"], "venue": "ACM Computing Surveys (CSUR),", "citeRegEx": "Dantsin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Dantsin et al\\.", "year": 2001}, {"title": "Logical reconstruction of normative RDF", "author": ["J. de Bruijn", "E. Franconi", "S. Tessaris"], "venue": "In Proceedings of the Workshop OWL: Experiences and Directions", "citeRegEx": "Bruijn et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bruijn et al\\.", "year": 2005}, {"title": "Logical foundations of (e)RDF(S): Complexity and reasoning", "author": ["J. de Bruijn", "S. Heymans"], "venue": "In Proceedings of the 6th International Semantic Web Conference (ISWC2007),", "citeRegEx": "Bruijn and Heymans,? \\Q2007\\E", "shortCiteRegEx": "Bruijn and Heymans", "year": 2007}, {"title": "On the relationship between description logic-based and f-logic-based ontologies", "author": ["J. de Bruijn", "S. Heymans"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Bruijn and Heymans,? \\Q2008\\E", "shortCiteRegEx": "Bruijn and Heymans", "year": 2008}, {"title": "First Order Logic and Automated Theorem Proving (second edition)", "author": ["M. Fitting"], "venue": "Springer.", "citeRegEx": "Fitting,? 1996", "shortCiteRegEx": "Fitting", "year": 1996}, {"title": "Computers and Intractability \u2013 A Guide to the Theory of NP-Completeness. W.H", "author": ["M.R. Gary", "D.S. Johnson"], "venue": null, "citeRegEx": "Gary and Johnson,? \\Q1979\\E", "shortCiteRegEx": "Gary and Johnson", "year": 1979}, {"title": "Foundations of semantic web databases", "author": ["C. Gutierrez", "C. Hurtado", "A.O. Mendelzon"], "venue": "In Proceedings of the 23rd ACM Symposium on Principles of Database Systems", "citeRegEx": "Gutierrez et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Gutierrez et al\\.", "year": 2004}, {"title": "Foundations of semantic web databases", "author": ["C. Gutierrez", "C.A. Hurtado", "A.O. Mendelzon", "J. P\u00e9rez"], "venue": "Journal of Computer and System Sciences", "citeRegEx": "Gutierrez et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Gutierrez et al\\.", "year": 2010}, {"title": "RDF semantics", "author": ["P. Hayes"], "venue": "Recommendation 10 February 2004, W3C.", "citeRegEx": "Hayes,? 2004", "shortCiteRegEx": "Hayes", "year": 2004}, {"title": "Complete problems for deterministic polynomial time", "author": ["N.D. Jones", "W.T. Laaser"], "venue": "In Proceedings of the 6th Annual ACM Symposium on Theory of Computing", "citeRegEx": "Jones and Laaser,? \\Q1974\\E", "shortCiteRegEx": "Jones and Laaser", "year": 1974}, {"title": "Logical foundations of object-oriented and framebased languages", "author": ["M. Kifer", "G. Lausen", "J. Wu"], "venue": "Journal of the ACM,", "citeRegEx": "Kifer et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Kifer et al\\.", "year": 1995}, {"title": "Resource description framework (RDF): Concepts and abstract", "author": ["G. Klyne", "J.J. Carroll"], "venue": "syntax. Recommendation", "citeRegEx": "Klyne and Carroll,? \\Q2004\\E", "shortCiteRegEx": "Klyne and Carroll", "year": 2004}, {"title": "OWL 2 web ontology language profiles", "author": ["B. Motik", "B.C. Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz"], "venue": "Recommendation", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "OWL 2 web ontology language structural specification and functional-style", "author": ["B. Motik", "P.F. Patel-Schneider", "B. Parsia"], "venue": "syntax. Recommendation", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Simple and efficient minimal RDFS", "author": ["S. Mu\u00f1oz", "J. P\u00e9rez", "C. Gutierrez"], "venue": "Journal of Web Semantics,", "citeRegEx": "Mu\u00f1oz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Mu\u00f1oz et al\\.", "year": 2009}, {"title": "Computational Complexity", "author": ["C.H. Papadimitriou"], "venue": "Addison Wesley.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "OWL web ontology language semantics and abstract", "author": ["P.F. Patel-Schneider", "P. Hayes", "I. Horrocks"], "venue": "syntax. Recommendation", "citeRegEx": "Patel.Schneider et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Patel.Schneider et al\\.", "year": 2004}, {"title": "W3C XML schema definition language (XSD) 1.1 part 2: Datatypes", "author": ["D. Peterson", "S. Gao", "A. Malhotra", "C.M. Sperberg-McQueen", "H.S. Thompson"], "venue": "Working draft", "citeRegEx": "Peterson et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Peterson et al\\.", "year": 2009}, {"title": "RIF basic logic dialect", "author": ["RIF Working Group"], "venue": "Recommendation 22 June 2010, W3C.", "citeRegEx": "Group,? 2010a", "shortCiteRegEx": "Group", "year": 2010}, {"title": "RIF RDF and OWL compatibility", "author": ["RIF Working Group"], "venue": "Recommendation 22 June 2010, W3C.", "citeRegEx": "Group,? 2010b", "shortCiteRegEx": "Group", "year": 2010}, {"title": "Completeness, decidability and complexity of entailment for RDF schema and a semantic extension involving the OWL vocabulary", "author": ["H.J. ter Horst"], "venue": "Journal of Web Semantics,", "citeRegEx": "Horst,? \\Q2005\\E", "shortCiteRegEx": "Horst", "year": 2005}, {"title": "FLORA-2: A rule-based knowledge representation and inference infrastructure for the semantic web", "author": ["G. Yang", "M. Kifer", "C. Zhao"], "venue": "In Proceedings of the Second International Conference on Ontologies, Databases and Applications of Semantics (ODBASE2003). Springer", "citeRegEx": "Yang et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Yang et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 11, "context": "Hayes (2004) defines notions of RDF and RDFS entailment.", "startOffset": 0, "endOffset": 13}, {"referenceID": 11, "context": "The RDF semantics specification (Hayes, 2004) defines four increasingly expressive normative entailment relations between RDF graphs, namely simple, RDF, RDFS, and D entailment, where the latter extends RDFS entailment with support for datatypes (e.", "startOffset": 32, "endOffset": 45}, {"referenceID": 11, "context": "Additionally, ter Horst shows that the entailment rules for computing RDFS entailment presented in the original specification (Hayes, 2004) are not complete with respect to the RDFS semantics.", "startOffset": 126, "endOffset": 139}, {"referenceID": 13, "context": "However, the semantics of F-Logic is strictly first-order (Kifer et al., 1995).", "startOffset": 58, "endOffset": 78}, {"referenceID": 4, "context": "(2004, 2010) reconstruct the semantics from a graph database perspective, and de Bruijn et al. (2005) reconstruct the semantics from a logical language perspective.", "startOffset": 81, "endOffset": 102}, {"referenceID": 4, "context": "(2004, 2010) reconstruct the semantics from a graph database perspective, and de Bruijn et al. (2005) reconstruct the semantics from a logical language perspective. The investigation of the RDF semantics by ter Horst (2005) stays very close to the RDF specification.", "startOffset": 81, "endOffset": 224}, {"referenceID": 2, "context": "We subsequently exploit earlier results about the relationship between F-Logic statements and description logic statements (de Bruijn & Heymans, 2008) to show that extensional RDFS reasoning with ground RDF graphs can be reduced to reasoning in the tractable description logic DL-LiteR (Calvanese et al., 2007).", "startOffset": 286, "endOffset": 310}, {"referenceID": 5, "context": "To simplify matters, and because these constructs are not necessary for the embedding of RDF, we do not consider function symbols, parameterized methods, functional (single-valued) methods, inheritable methods, and compound molecules, following de Bruijn and Heymans (2008).", "startOffset": 248, "endOffset": 274}, {"referenceID": 2, "context": "2 DL-LiteR A DL-LiteR (Calvanese et al., 2007) language consists of pairwise disjoint sets of concept (NC), role (NR), and individual (NI) identifiers.", "startOffset": 22, "endOffset": 46}, {"referenceID": 11, "context": "We proceed with a review of the definitions of the RDF syntax (Klyne & Carroll, 2004) and semantics (Hayes, 2004).", "startOffset": 100, "endOffset": 113}, {"referenceID": 0, "context": "Borgida (1996) discusses the relationship between description logics and first-order logic in detail.", "startOffset": 0, "endOffset": 15}, {"referenceID": 11, "context": "The following observations can be made about satisfiability for the various entailment regimes; the observations concerning normal RDF graphs are due to Hayes (2004).", "startOffset": 153, "endOffset": 166}, {"referenceID": 11, "context": "Normal RDF graphs correspond the RDF graphs defined by Hayes (2004). In contrast to normal RDF, generalized RDF graphs allow blank nodes and literals in predicate, and literals in subject positions.", "startOffset": 55, "endOffset": 68}, {"referenceID": 24, "context": "Therefore, if the graphs satisfy the mentioned conditions, query answering techniques used in F-Logic reasoners such as FLORA-2 (Yang et al., 2003) can be used for checking extensional RDFS entailment.", "startOffset": 128, "endOffset": 147}, {"referenceID": 11, "context": "The RDF semantics specification (Hayes, 2004) defines the notion of D entailment (datatype entailment), which extends RDFS entailment with support for datatypes.", "startOffset": 32, "endOffset": 45}, {"referenceID": 11, "context": "The RDF semantics specification (Hayes, 2004) defines the notion of D entailment (datatype entailment), which extends RDFS entailment with support for datatypes. Ter Horst (2005) defines the notion of D* entailment, which is also an extension of RDFS entailment, but semantically weaker than D entailment.", "startOffset": 33, "endOffset": 179}, {"referenceID": 20, "context": "Consider a datatype map D that includes the XML schema datatypes string and integer (Peterson et al., 2009), which have disjoint value spaces.", "startOffset": 84, "endOffset": 107}, {"referenceID": 8, "context": "The membership proofs by Gutierrez et al. (2004, 2010), ter Horst (2005), and de Bruijn et al.", "startOffset": 25, "endOffset": 73}, {"referenceID": 4, "context": "(2004, 2010), ter Horst (2005), and de Bruijn et al. (2005) rely on the fact that the set of all (relevant) entailed triples of a given graph can be computed in polynomial time using the RDFS entailment rules (ter Horst, 2005); the problem can then be reduced to subgraph homomorphism.", "startOffset": 39, "endOffset": 60}, {"referenceID": 2, "context": "Using the correspondence of Proposition 7, the results on the complexity of reasoning in DL-LiteR (Calvanese et al., 2007), and the classical results on skolemization (Fitting, 1996) we obtain the following result for extensional RDFS entailment.", "startOffset": 98, "endOffset": 122}, {"referenceID": 7, "context": ", 2007), and the classical results on skolemization (Fitting, 1996) we obtain the following result for extensional RDFS entailment.", "startOffset": 52, "endOffset": 67}, {"referenceID": 2, "context": "Since this transformation is linear in the size of the knowledge base, the complexity of deciding satisfiability and entailment of contextual DL-LiteR knowledge bases is the same as that of DL-LiteR knowledge bases, namely NLogSpace (Calvanese et al., 2007).", "startOffset": 233, "endOffset": 257}, {"referenceID": 18, "context": "Hardness is shown by reduction from a known NLogSpace-hard problem: Graph reachability (Papadimitriou, 1994) can be encoded using subclass statements: edges in the graph are represented in the RDF graph S by rdfs:subClassOf-triples and t is reachable from s iff S |=erdfs {\u3008s, rdfs:subClassOf, t\u3009}.", "startOffset": 87, "endOffset": 108}, {"referenceID": 9, "context": "The results in the first and fourth line of the table, and the upper bound for ground rdfs-entailment were previously known (Gutierrez et al., 2004; de Bruijn et al., 2005; ter Horst, 2005).", "startOffset": 124, "endOffset": 189}, {"referenceID": 20, "context": "We suspect that many datatype maps of interest are logspace \u2013 examples are the XML schema datatypes (Peterson et al., 2009).", "startOffset": 100, "endOffset": 123}, {"referenceID": 3, "context": ", variable-free Datalog (Dantsin et al., 2001) and DL-LiteR,u, an extension of DL-LiteR (Calvanese et al.", "startOffset": 24, "endOffset": 46}, {"referenceID": 2, "context": ", 2001) and DL-LiteR,u, an extension of DL-LiteR (Calvanese et al., 2007)).", "startOffset": 49, "endOffset": 73}, {"referenceID": 20, "context": ", coNP-hardness), suggests that one should restrict oneself to a weaker datatype semantics such as D* or one should use only definite datatype maps, which precludes the use of finite datatypes such as bool or int (Peterson et al., 2009).", "startOffset": 213, "endOffset": 236}, {"referenceID": 2, "context": ", 2001) and DL-LiteR,u, an extension of DL-LiteR (Calvanese et al., 2007)). The PTime-hardness proof suggests that the complexity originates from the possibility to use RDFS vocabulary in arbitrary places in RDF statements, e.g., rdfs:subPropertyOf in the object position of a triple. Indeed, ground entailment in the minimal RDFS fragment by Mu\u00f1oz, P\u00e9rez, and Gutierrez (2009) can be decided in O(nlogn).", "startOffset": 50, "endOffset": 378}, {"referenceID": 11, "context": "In this appendix we define the notions of RDF, RDFS, eRDFS, D* , and D interpretations (Hayes, 2004; ter Horst, 2005).", "startOffset": 87, "endOffset": 117}, {"referenceID": 11, "context": "The RDF semantics specification (Hayes, 2004) also defines an extensional RDFS semantics (eRDFS).", "startOffset": 32, "endOffset": 45}, {"referenceID": 11, "context": "Hayes (2004) observed that one can create a similar situation with a normal RDF graph and a range constraint; this graph is rdfs- and hence erdfs-unsatisfiable.", "startOffset": 0, "endOffset": 13}], "year": 2010, "abstractText": "The Resource Description Framework (RDF) is a Semantic Web standard that provides a data language, simply called RDF, as well as a lightweight ontology language, called RDF Schema. We investigate embeddings of RDF in logic and show how standard logic programming and description logic technology can be used for reasoning with RDF. We subsequently consider extensions of RDF with datatype support, considering D entailment, defined in the RDF semantics specification, and D* entailment, a semantic weakening of D entailment, introduced by ter Horst. We use the embeddings and properties of the logics to establish novel upper bounds for the complexity of deciding entailment. We subsequently establish two novel lower bounds, establishing that RDFS entailment is PTime-complete and that simple-D entailment is coNP-hard, when considering arbitrary datatypes, both in the size of the entailing graph. The results indicate that RDFS may not be as lightweight as one may expect.", "creator": "TeX"}}}