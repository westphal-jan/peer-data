{"id": "1401.3887", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "The Complexity of Integer Bound Propagation", "abstract": "Bound propagation is an important Artificial Intelligence technique used in Constraint Programming tools to deal with numerical constraints. It is typically embedded within a search procedure (\"branch and prune\") and used at every node of the search tree to narrow down the search space, so it is critical that it be fast. The procedure invokes constraint propagators until a common fixpoint is reached, but the known algorithms for this have a pseudo-polynomial worst-case time complexity: they are fast indeed when the variables have a small numerical range, but they have the well-known problem of being prohibitively slow when these ranges are large. An important question is therefore whether strongly-polynomial algorithms exist that compute the common bound consistent fixpoint of a set of constraints. This paper answers this question. In particular we show that this fixpoint computation is in fact NP-complete, even when restricted to binary linear constraints. Our model is the same, which is the same for non-linear constraints in other languages, such as the ABI.\n\n\n\nAs a consequence, the approach to solving problems in non-linear operations can also be applied to the problem of solving algorithms in different languages. In this post we will demonstrate how our approach allows this approach to be applied in non-linear situations and to resolve them in the next post. In the next post we will introduce an algorithm which can solve all known problems in non-linear operations. We will present our solution to the problem of solving at the start of this post. In this post, we will examine how these algorithms are used in a non-linear manner, in some cases by solving various problems in non-linear operations (such as the Turing test of C++). The first method is the NP-complete method (if applicable) which is used in all cases for general operations. In some cases, the NP-complete method is used in all cases as a single-point fixpoint (if applicable) which is used in all cases as a single-point solution (if applicable) which is used in all cases as a single-point solution (if applicable) which is used in all cases as a single-point solution (if applicable) which is used in all cases as a single-point solution (if applicable) which is used in all cases as a single-point solution (if applicable) which is used in all cases as a single-point solution (if applicable) which is used in all cases as a single-point solution (if applicable) which is", "histories": [["v1", "Thu, 16 Jan 2014 05:15:30 GMT  (211kb)", "http://arxiv.org/abs/1401.3887v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["lucas bordeaux", "george katsirelos", "nina narodytska", "moshe y vardi"], "accepted": false, "id": "1401.3887"}, "pdf": {"name": "1401.3887.pdf", "metadata": {"source": "CRF", "title": "The Complexity of Integer Bound Propagation", "authors": ["Lucas Bordeaux", "George Katsirelos", "Nina Narodytska", "Moshe Y. Vardi"], "emails": ["lucasb@microsoft.com", "gkatsi@gmail.com", "ninan@cse.unsw.edu.au", "vardi@cs.rice.edu"], "sections": [{"heading": "1. Introduction and Overview of the Main Results", "text": "Constraint solvers typically solve problems by interleaving search and propagation. Propagation is an iterative procedure which, at each iteration, propagates every constraint in the problem to narrow the domains of its variables. The iteration stops when no constraint changes the domains of its variables. In this case, propagation has reached a common fixpoint for all constraints. This iterative algorithm is guaranteed to compute the fixpoint in polynomial time if propagating each constraint takes polynomial time and the domains of the variables are defined as lists of values. Very often, however, it is inconvenient or infeasible to list all values explicitly: instead the domains are defined by lower and upper bounds. We focus on this representation, and on variables taking integer values. In this setting, computing a fixpoint by the iterative algorithm may require exponential time even if each constraint can be propagated in polynomial time. We show that this exponential behaviour is not simply due to the iterative algorithm being suboptimal; rather it is intrinsic to the\nc\u00a92011 AI Access Foundation. All rights reserved.\nproblem of computing a fixpoint, as it is NP-complete even when the system of constraints is restricted to binary linear inequality constraints."}, {"heading": "1.1 Bound Propagation and Slow Convergence", "text": "We illustrate the behaviour of the iterative fixpoint algorithm using a system of two constraints:\nx+ y = 7, x+ 1 \u2265 2y, with initial bounds: x \u2208 [0, 5], y \u2208 [0, 10]\nA possible trace of the fixpoint computation is the following. The lower bound of y is initially 0 but from the constraint x + y = 7 we deduce that y cannot take values 0 or 1: if it does, then the sum is < 7, even if we fix x to its highest allowed value. Therefore the intervals can be narrowed down to x \u2208 [0, 5], y \u2208 [2, 10]. Similarly:\nfrom x+ y = 7, we deduce: x \u2208 [0, 5], y \u2208 [2, 7]; from x+ 1 \u2265 2y, we deduce: x \u2208 [3, 5], y \u2208 [2, 7]; and: x \u2208 [3, 5], y \u2208 [2, 3]; back to x+ y = 7, we now deduce: x \u2208 [4, 5], y \u2208 [2, 3].\nAt this point we have reached a common fixpoint for both constraints, because we cannot deduce that the domains need to be narrowed any further.\nThis algorithm, however, exhibits slow convergence behaviour even in deceivingly simple examples such as:\nx < y, y < x with initial bounds: x \u2208 [0, 108], y \u2208 [0, 108] (1)\nThe iterative algorithm for fixpoint computation shrinks the bounds by one unit in each iteration, which means that 108 iterations will be required to reach the fixpoint, which in this case is empty. This slow convergence is in fact exponential in the size of the problem representation, as log(108) bits are enough to represent each bound. This behaviour is not limited to artificial examples as the previous one but in fact happens time and again when solving problems with large numerical ranges. This severely limits the application of CP in areas such as software verification or theorem proving where large ranges are needed (e.g., the whole 32-bit integer range).\nDue to the importance of the problem, efforts have been made to alleviate slow convergence, notably Jaffar, Maher, Stuckey, and Yap (1994), Lhomme, Gottlieb, Rueher, and Taillibert (1996), Lebbah and Lhomme (2002), Leconte and Berstel (2006); but all proposed algorithmic improvements prevent slow convergence only in specific cases. Fully addressing the slow convergence problem would require a strongly polynomial algorithm for fixpoint computation. Therefore the question is: does such an algorithm exist, or is bound propagation in fact intractable?"}, {"heading": "1.2 Prior Complexity Results on Propagation", "text": "Standard propagation algorithms are iterative processes that apply \u201dpropagators\u201d, i.e., narrowing functions associated with each constraint, until reaching a fixpoint. Their complexity is therefore determined by two complementary questions:\nQ1: How hard is it to compute each propagator?\nQ2: How hard is it to find a common fixpoint of the propagators?\nThe complexity of constraint propagation has in a sense been extremely well-studied, but all the results we are aware of for bound propagation deal with Question 1 only. Those prior hardness results showed that for some complex constraints we cannot have polynomial-time propagators reaching certain levels of consistency. Two such results are:\n\u2022 Given a linear equality it has been observed (Yuanlin & Yap, 2000; Choi, Harvey, Lee, & Stuckey, 2006) that any propagator that reaches arc consistency or bound(Z) consistency1 needs to solve a knapsack problem, which is NP-complete in the weak sense. For this reason propagators for linear constraints used in practice either reach a weaker consistency such as bound(R) consistency, or are restricted to very small domains, as proposed for instance in Trick (2001).\n\u2022 Results by Bessie\u0300re (2006) prove that even bounded-arity (two-variable) constraints can be constructed for which checking bound(Z) consistency is NP-complete.\nQuestion 2 only makes sense, of course, in the common case where the propagators are polynomial-time computable (if they are not, computing their common fixpoint cannot be easy in general). The only known fact in this case is that the standard, iterative propagation algorithms often take an exponential number of steps to reach a fixpoint in practice, as mentioned and illustrated in Section 1.1. This leaves open the question whether better algorithms exist or fixpoint computation is, in fact, intrinsically hard."}, {"heading": "1.3 Our Main Results", "text": "In this paper we consider very simple, common propagators and address Question 2. We show that in general even surprisingly simple propagators can lead to a fixpoint computation problem that is NP-hard. This not only explains why all standard, iterative fixpointcomputation algorithms have an exponential worst-case in practice, but also shows it is unlikely that the there exists an algorithm with better worst case. In particular an important class of simple propagators whose fixpoint computation is NP-hard is the bound(R) consistency propagators for linear constraints (Proposition 1). These are ubiquitous constraints, and very weak and widely used propagators for these constraints. Many problems that use numerical computations and large domains tend to include at least linear constraints, therefore there are few cases where slow convergence will be avoidable. We nevertheless identify one such case: if the coefficients of the linear constraints are all unit (1 in absolute value), then bound(R) consistency can be obtained in polynomial time by a non-standard propagation algorithm based on Linear Programming. We also study other types of basic numerical constraints: multiplication and max."}, {"heading": "1.4 Outline", "text": "In Section 2 we summarize the required material on Constraint Satisfaction Problems and bound propagation. Section 3 then focuses on linear constraints. We prove the\n1. We give the formal definitions of bound(R) and bound(Z) consistency in Section 2.2.\naforementioned Proposition 1, then identify restricted forms of linear constraints for which propagation is tractable. Section 4 presents results for some other basic propagators: for quadratic constraints, the hardness result can be strengthened and holds even for a fixed number of variables; for max constraints, fixpoint computation has an interesting complexity (between P and NP-complete) and is proved equivalent to an important open problem; we last comment on max-closed constraints. We conclude in Section 5."}, {"heading": "2. Formal Background", "text": "In this section we summarize the required material on Constraint Satisfaction Problems and bound propagation. More details on this material can be found in papers by e.g. Schulte and Carlsson (2006), and Bessie\u0300re (2006)."}, {"heading": "2.1 Constraint Satisfaction Problems", "text": "A Constraint Satisfaction Problem (CSP) is a triple \u3008X,D,C\u3009, where: X = {x1 \u00b7 \u00b7 \u00b7 xn} is a set of variables, D = {D1 \u00b7 \u00b7 \u00b7Dn} is a set of finite domains (finite sets of values), one for each variable, and C is a set of constraints. In this paper we consider discrete domains: all the elements in D are integers. For the moment we simply define constraints very generally as logical predicates over subsets of X; later in the paper we consider specific types of constraints, for instance linear ones. An assignment is a function \u03c4 that assigns a value \u03c4(xi) \u2208 Di to every variable xi. A solution to the CSP is an assignment that satisfies the constraints. Throughout the paper, we keep the following conventions:\n\u2022 n = |X| denotes the number of variables;\n\u2022 m = |C| is the number of constraints;\n\u2022 d = maxi\u22081..n |Di| is the size of the largest domain.\nIt is important to note that Di may be represented as an interval, rather than an explicit set of values. In this work, we only consider domains represented as intervals: each domain is of the form Di = [li, ui], where li and ui are the lower and upper bounds of the domain."}, {"heading": "2.2 Propagators and Notions of Bound Consistency", "text": "The constraints of the problem are associated with propagators. (In our setting there will be, in general, several propagators per constraint.) We follow the classical presentation of propagators as operators on a lattice, initiated in work by Benhamou (1996) and on which more details can be found in papers by Apt (1999), and Schulte and Carlsson (2006): each propagator is a function that can narrow the domains of (some of) the variables, removing values that cannot appear in any solution. Thus, we talk about the current domain of a variable xi, as the result of it being narrowed by the application of one or more propagators. We denote by x\u2212i the current lower bound of xi and by x + i its current upper bound. x \u2212 i and x+i are initially set to the initial bounds li, ui and remain afterwards constrained by li \u2264 x \u2212 i \u2264 x + i \u2264 ui. We denote by D the Cartesian product of the intervals [li, ui] for all i \u2208 1..n.\nDefinition 1 (Propagator) A propagator for a constraint k \u2208 1..m is a function f : P(D) \u2192 P(D), that is:\n\u2022 monotone, i.e., A\u2032 \u2286 A \u2192 f(A\u2032) \u2286 f(A);\n\u2022 contracting, i.e., f(A) \u2286 A;\n\u2022 correct, i.e., no point in A \\ f(A) satisfies the constraint.\nWe restrict ourselves to propagators that are polynomial-time computable. Bound consistency propagators are additionally restricted to elements of P(D) that are representable as Cartesian products of intervals, plus the special value \u2205.\nSeveral types of propagators can be used for numerical constraints; these propagators are characterized by the level of consistency they enforce. Since we have restricted our focus to interval domains, we present only bound consistency. The two main variants are bound(Z) and bound(R) consistency:\nDefinition 2 (Bound(Z|R) support) A bound(Z) (bound(R)) support of a constraint k is an assignment \u03c4 of integer (real) values to the variables X such that x\u2212i \u2264 \u03c4(xi) \u2264 x + i for i \u2208 1..n and \u03c4 satisfies the constraint k.\nDefinition 3 (Bound(Z|R) consistency) A constraint k is bound(Z) (bound(R)) consistent iff for every variable xi \u2208 X, there exists a bound(Z) (bound(R)) support \u03c4\n\u2212 with \u03c4\u2212(xi) = x \u2212 i and a bound(Z) (bound(R)) support \u03c4 + with \u03c4+(xi) = x + i .\nThe difference between the two is easily understood on an example:\nExample 1 Consider the constraint 2x+ 2y + 3z = 4.\n\u2022 The intervals x, y, z \u2208 [0, 1] are bound(R) consistent since each of the integer bounds has a real-valued support: x = 0 is supported by the tuple (x = 0, y = 1, z = 2/3); z = 1 and y = 0 by the tuple (x = 1/2, y = 0, z = 1); x = 1, y = 1 and z = 0 by the tuple (x = 1, y = 1, z = 0).\n\u2022 These intervals are, however, not bound(Z) consistent: the only integer solution is (x = 1, y = 1, z = 0), which means that bound(Z) consistency would reduce the bounds further to x \u2208 [1, 1], y \u2208 [1, 1], z \u2208 [0, 0].\nBound(Z) consistency requires that we check the existence of an integer-valued support, and for some classes of constraints such as linear equalities each propagator would need to solve an NP-complete problem. Since our focus is on the computation of common fixpoint of simple operators, we only consider bound(R) consistency in this paper. As noted previously in the literature (Schulte & Stuckey, 2005), bound(R) consistency it is in fact \u201cthe bound consistency implemented for most primitive constraints\u201d, precisely because it is often the only one for which propagators are easy to compute in general for large domains. In the rest of the paper we focus on several of the main basic types of numerical constraints (in particular linear ones), and give further details on the bound(R) consistency propagators obtained for these constraints. In all the cases we consider the propagators are very simple indeed."}, {"heading": "2.3 Fixpoints", "text": "Propagators are monotone narrowing operators, thus we may consider the problem of identifying the greatest common fixpoint of a set of propagators.\nDefinition 4 (Greatest Common Fixpoint) The greatest common fixpoint gfp(F ) of a set of propagators F is the largest Cartesian product of intervals A \u2286 D such that for each operator f \u2208 F , we have f(A) = A.\nThere are two computational problems related to fixpoints:\n\u2022 Function Problem: Effectively compute gfp(F );\n\u2022 Decision Problem: Decide whether gfp(F ) 6= \u2205, i.e., whether there exists a (nonempty) fixpoint. (Note that our definition of propagators implies that f(\u2205) = \u2205 for all f \u2208 F . Therefore \u2205 is always a common fixpoint.) In other words: do the propagators stabilize to non-empty domains?\nAs often in complexity work we mostly focus on the Decision problem in this paper. The reason is that the basic complexity classes (NP in particular) are defined for decision problems, and that hardness results on the decision problem also imply that the function problem is hard. The only place where we refer to the function problem is this section, where we describe the basic greatest fixpoint computation algorithm.\nAn algorithm for computing gfp(F ) is specified in Fig. 1. It is presented in its simplest form, which excludes several possible optimizations related, in particular, to the fact that not all constraints necessarily deal with all variables. (These optimizations are well-known and orthogonal to our discussion in this paper.) In this algorithm we initialize the Cartesian product of domains to D, in other words we initially have x\u2212i = li and x + i = ui, for all i \u2208 1..n; and we simply apply all propagators until a stable state is reached, i.e., no propagator shrinks any domain further. The reader can verify that this algorithm specifies formally the reasoning that we presented informally in our introductory example (Sec. 1.1)."}, {"heading": "2.4 Complexity Upper Bound of Fixpoint Propagation", "text": "The worst-case time upper bound of fixpoint computation can be analyzed as follows2. Let p = |F | be the number of propagators. (Note that we have in general one or more propagators per constraint, i.e., p \u2265 m.) We enter the while loop at most nd times since at every new iteration we must reduce at least one bound by one unit, and each time the foreach loop is entered at most p times. Overall the algorithm therefore terminates after a number of propagator applications of:\nO(npd).\nIn other words, it is in fact exponential in the number of bits of the encoding: this complexity can be written O(np\u00b72b), where b is the number of bits of the bound encoding. This is despite the fact that each propagator is polynomial in the size of the encoding. Such algorithms are called pseudo-polynomial. In contrast algorithms that are truly polynomial in the number of bits of the encoding, i.e., whose worst-case time complexity is O(\u03c0(n,m, log d)), for some polynomial \u03c0, are called strongly polynomial (Papadimitiou, 1994). The problem of a pseudo-polynomial algorithm for this problem is that it scales linearly with the size of the domains, which may themselves be exponentially large. Since the propagators we consider take strongly polynomial time, the analyis of the upper bound is summarized as follows:\nObservation 1 The naive fixpoint computation algorithm (Fig. 1) always terminates in pseudo-polynomial-time.\nThe question is whether strongly polynomial algorithms exist. The rest of the paper focusses on this question, for several classes of propagators."}, {"heading": "3. Linear Constraints", "text": "In this section we consider linear inequalities, i.e., our set of constraints C contains m inequalities of the form:\n\u2211\ni\u22081...n\nai,kxi \u2265 ck, k \u2208 1 . . . m (2)\nwhere each ck and ai,k are integers. It is convenient to introduce some extra notation: we denote by si,k the sign of the ith term in constraint k, i.e.,:\nsi,k =\n{\n+ if ai,k \u2265 0 \u2212 if ai,k < 0\n(3)\nMoreover, given a sign s \u2208 {\u2212,+}, the sign \u2212s is defined as + if s = \u2212 and as \u2212 otherwise. The sign +s will simply denote s. With this notation the terms ai,kx \u2212si,k i and ai,kx +si,k i simply represent the smallest and largest elements of the set {ai,kv | v \u2208 [x \u2212 i , x + i ]}.\n2. Few papers give explicit upper bounds on the complexity of computing a fixpoint of a set of bound consistency propagators. The earliest reference we are aware of is the work of Lhomme (1993); it considers constraints on the reals but assumes finite precision (floating points), and its analysis directly adapts to discrete intervals."}, {"heading": "3.1 Bound(R) Consistency Propagators for Linear Inequalities", "text": "We briefly summarize the material we need on bound(R) consistency in the case of linear inequalities. We refer the reader to the literature for more details, in particular the papers by Harvey and Stuckey (2003), Schulte and Carlsson (2006), Bessie\u0300re (2006), and Apt and Zoeteweij (2007) have substantial material on bound(R) consistency and linear constraints. Also of interest are works that show how to improve bound propagation for long linear constraints (Harvey & Schimpf, 2002; Katriel, Sellmann, Upfal, & Van Hentenryck, 2007).\nConsider a variable xi. Its bound x \u2212si,k i is bound(R) inconsistent w.r.t. the kth inequality of the system iff: even when we fix the other terms to their maximum, we obtain something lower than ck. It is bound consistent if the opposite is true i.e., iff:\na1,kx +s1,k 1 + . . . + ai\u22121,kx +si\u22121,k i\u22121 + ai,kx \u2212si,k i + ai+1,kx +si+1,k i+1 + . . .+ an,kx +sn,k n \u2265 ck (4)\nWe call this the bound consistency inequality of variable xi w.r.t. constraint k. The bound consistency propagator for a linear inequality simply shrinks the bounds of each variable xi. Let:\nqi,k = ck \u2212 \u2211\nj\u2208[1,n], j 6=i\naj,kx +sj,k j\nbe the minimal quantity that has to be reached by ai,kx \u2212si,k i to satisfy the bound consistency inequality (in other words: xi is bound consistent w.r.t. constraint k iff ai,kx \u2212si,k i \u2265 qi,k). The (bound(R) consistency) propagator associated with constraint k \u2208 1..m and variable i \u2208 1..n is the function that reduces the bound of xi to the closest bound consistent value. It is defined by the following pseudo-code:\nLi,k:\nif ai,k > 0 then x \u2212 i := max\n( x\u2212i , \u2308 qi,k ai,k \u2309)\nif ai,k < 0 then x + i := min\n( x+i , \u230a qi,k ai,k \u230b)\n(5)\n(The propagator does nothing if ai,k = 0.)"}, {"heading": "3.2 NP-completeness of Integer Fixpoint Computation", "text": "We now prove that the propagators Li,k introduced in the previous sub-section (Eq. 5), although very simple when considered independently, give rise to complex fixpoints. More precisely, we show the NP-completeness of the following decision problem:\nDecision Problem 1 (Bound(R)-Consistency for Linear Constraints) INPUT: a CSP whose set of constraints C are linear inequalities. QUESTION: Let F = {Li,k : i \u2208 1..n, k \u2208 1..m} be the set of bound(R) consistency propagators associated with the CSP. Do the propagators in F have a non-empty common fixpoint?"}, {"heading": "3.2.1 Characterising the Fixpoints by Inequalities", "text": "Our first observation is that the bounds obtained when a fixpoint is reached are characterized by the bound consistency conditions of Eq. 4. In other words a fixpoint is reached iff the\nlower and upper bounds x\u2212i and x + i satisfy the following inequalities, for each variable i and constraint k: \n  \n  \na1,kx +s1,k 1 + ..+ ai\u22121,kx +si\u22121,k i\u22121 + ai,kx \u2212si,k i + ai+1,kx +si+1,k i+1 + ..+ an,kx +sn,k n \u2265 ck \u2200k \u2208 1 . . . m, i \u2208 1 . . . n li \u2264 x \u2212 i \u2264 x + i \u2264 ui \u2200i \u2208 1 . . . n\n(6)\nIt is clear that Decision Problem 1 is answered positively iff there are integer values for the bounds x\u2212i and x + i , i \u2208 1..n, that satisfy the Linear Program 6. (If a fixpoint exists then the bounds given by this fixpoint satisfy the inequalities and are within the initial bounds li, ui. Conversely if the inequalities are satisfied we have a fixpoint.)\nA first consequence for Decision Problem 1 is that its membership in NP is straightforward since it is solvable by Integer Programming."}, {"heading": "3.2.2 Linear Inequalities with Two-Variables-Per-inequality", "text": "The key to understanding why Decision Problem 1 is hard is to connect fixpoint computation to the special case of Integer (Linear) Programming where all constraints have Two Variables Per Inequality (TVPI in the LP terminology, see Bar-Yehuda & Rawitz, 2001):\nDefinition 5 A TVPI instance with m constraints and n variables is an Integer Linear Program of the following form:\n{\nakxik + bkxjk \u2265 ck \u2200k \u2208 1 . . . m li \u2264 xi \u2264 ui \u2200i \u2208 1 . . . n\nwhere a, b, c are vectors of arbitrary (possibly negative) integers.\nThe feasibility of TVPI constraints is NP-complete3 but can be decided in pseudopolynomial time. An early pseudo-polynomial time algorithm can be found in work by Aspvall and Shiloach (1980); this algorithm essentially reduces the problem to a 2-SAT instance of size m \u00b7 d, which is solvable in linear time (the overall algorithm therefore runs in pseudo-polynomial time, but also with a pseudo-polynomial space requirement). A particularly relevant algorithm for TVPI constraints is proposed in the work of BarYehuda and Rawitz (2001). This algorithm has pseudo-polynomial time complexity with low, strongly polynomial space requirements. Interestingly, this algorithm essentially uses bound propagation (in fact, precisely bound(R) consistency), and embeds it in what amounts to a backtrack-free search with a \u201cparallel\u201d improvement that allows to amortize its overall runtime.\nThis seems to suggest a strong relation between propagation and TVPI constraints; in particular one could easily be mistaken to believe that propagation is a decision procedure for systems of TVPI constraints. We say that propagation provides a decision procedure for a class of constraints if propagation fails exactly when the constraints are unsatisfiable (in\n3. Here we focus on feasibility only. The optimization problem, i.e., optimizing a linear function under TVPI constraints, is strongly NP-hard, i.e., NP-hard even for bounded domain sizes (in fact domains {0, 1} are enough), because it trivially encodes Max-2SAT (Bar-Yehuda & Rawitz, 2001).\nother words: the existence of a bound consistent state suffices to guarantee the existence of a solution). This is the usual condition that guarantees a backtrack-free search; but propagation rarely achieves this in the general case and it is in fact not a decision procedure for TVPI constraints:\nExample 2 Consider the problem x + y = 1, x = y with x, y \u2208 [0, 1]. The problem is inconsistent yet it is bound(R) consistent (and also, in fact, bound(Z) consistent).\nTo prove our main result we need to identify a restricted case of TVPI constraints for which fixpoint computation is indeed a decision procedure. This particular case is monotone TVPI constraints, in which the two variables in each inequality have coefficients with opposite signs, i.e., the problem is of the following form:\nDefinition 6 A monotone TVPI instance with m constraints and n variables is an Integer Linear Program of the following form:\n{\nakxik \u2212 bkxjk \u2265 ck \u2200k \u2208 1 . . . m li \u2264 xi \u2264 ui \u2200i \u2208 1 . . . n\nwhere ak \u2265 0, bk \u2265 0,\u2200k \u2208 1 . . . m.\nWe can now prove our NP-hardness result from monotone TVPI constraints, using the following result:\nTheorem 1 (Lagarias, 1985) The feasibility of Two-Variable-Per-Inequality monotone Integer Programming is NP-complete."}, {"heading": "3.2.3 NP-hardness", "text": "We now prove that Decision Problem 1 is NP-hard. We already know that it is in NP, therefore we can state our main result for bound(R) consistency for linear constraints as:\nProposition 1 Decision problem 1 is NP-complete.\nProof. We show that fixpoint computation decides systems of monotone TVPI constraints. Consider a monotone TVPI instance Q of the form given by Def. 6. We want to show the equivalence: Q has an integer solution iff the set of bound(R) consistency propagators obtained for Q have a non-empty common fixpoint.\n\u2022 \u201cQ has an integer solution\u201d means that there exist integer values vi for each variable xi satisfying li \u2264 vi \u2264 ui and, \u2200k \u2208 1 . . . m:\nakvik \u2212 bkvjk \u2265 ck (7)\n\u2022 \u201cThere exists a common fixpoint\u201d means that bounds x\u2212i , x + i , can be found for all\ni \u2208 1 . . . n, satisfying li \u2264 x \u2212 i \u2264 x + i \u2264 ui and, \u2200k \u2208 1 . . . m:\nakx \u2212 ik \u2212 bkx \u2212 jk \u2265 ck akx + ik \u2212 bkx + jk \u2265 ck (8)\n(These are simply the constraints of Eq. 6 for variable xik (left) and xjk (right), rewritten by taking into account a > 0, b > 0.)\nWe prove the two directions of the iff:\n\u2022 Consider an integer solution to Q in which each variable xi takes value vi. It is easy to verify that the bounds x\u2212i = x + i = vi satisfy li \u2264 x \u2212 i \u2264 x + i \u2264 ui and Eq. 8.\n\u2022 Consider a bound consistent state described by the bounds x\u2212i , x + i . It is easy to verify\nthat the solution v defined by vi = x + i , i \u2208 1 . . . n satisfies li \u2264 vi \u2264 ui and Eq. 7.\nThis means that we can reduce the problem of monotone TVPI feasibility to the existence of a fixpoint, and that Decision Problem 1 is therefore NP-hard. 2\nNote that the NP-hardness result for Decision Problem 1 holds even for (monotone) TVPI constraints, while the pseudo-polynomial upper bound of Section 2.4 holds for general linear constraints of unbounded sizes; as said earlier the membership in NP is also valid for general linear constraints."}, {"heading": "3.3 A Comment on Linear Equalities", "text": "From the beginning of this section we have focused on linear inequalities for reasons that should become clear in this sub-section. Readers may wonder whether considering equalities would make any difference. The short answer is no.\nA first observation is that an inequality \u2211\ni\u22081...n aixi \u2265 c can directly be encoded into the equality \u2211\ni\u22081...n aixi\u2212 y = c where y is a new variable ranging over [0, u] for u > \u2211 i aix +si i ,\nso that there is a bijection between solutions of the two constraints. Therefore the problem of propagating inequalities reduces to the problem of propagating equalities, and the NPcompleteness result still holds for problems whose linear constraints are all equalities (or for any mix of equalities / inequalities).\nA second observation is the following: because we focus on bound(R) consistency, the propagation obtained for an equality \u2211\ni\u22081...n aixi = c is the same as the one obtained using two constraints \u2211\ni\u22081...n aixi \u2264 c and \u2211\ni\u22081...n aixi \u2265 c. For this reason it is convenient to assume that constraints are of homogeneous form, and to restrict ourselves to linear inequalities4."}, {"heading": "3.4 Tractable Classes of Linear Constraints", "text": "Intractable problems often become tractable when additional restrictions are imposed on the topology of the constraint graph, or on the constraints themselves. In this subsection we identify one significant class of linear constraints that can be propagated in strongly polynomial time, based on a restriction on the coefficients of the constraints.\nOur initial observation is that one source of complexity of the propagators Li,k of Eq. 5 is that they use rounding : when we update a variable\u2019s bounds, we obtain from the other variables a real value that is rounded upwards for lower bounds and downwards for upper bounds. The effects of rounding were noticed by previous authors and used to optimize\n4. Note also that in the case of inequalities the propagators for bound(Z) consistency are the same as for bound(R) consistency. Since we want propagators to be polynomial-time computable, the case we want to avoid however is bound(Z) consistency for linear equalities, where we cannot define polynomial-time computable propagators unless P=NP.\npropagation (Harvey & Stuckey, 2003). Rounding effectively means that propagation stabilizes to integral solutions of Linear Programs. The Linear Programs in question have a very specific form, but the intractability is due to the integrality. Therefore in this sub-section (1) we observe that if we remove the rounding, the problem becomes tractable; (2) we use this observation to show that if the coefficients are unit (i.e., belong to {\u22121, 0,+1}), there is effectively no rounding, which means that the same tractability result holds."}, {"heading": "3.4.1 Linear Propagators without Rounding", "text": "We now consider operators similar to those of Eq. 5 but without rounding, in other words we now associate to the linear constraints the following operators:\nSi,k:\nif ai,k > 0 then x \u2212 i := max\n(\nx\u2212i , qi,k ai,k\n)\nif ai,k < 0 then x + i := min\n(\nx+i , qi,k ai,k\n)\n(9)\nEven when the initial bounds are integers as assumed throughout this paper, these operators will in general reduce these bounds to real-values. Note that such propagators can effectively be used to deal with variables with a real-valued domain, indeed they are used both in the Constraint Programming community (Behamou & Granvilliers, 2006) and in the Operations Research community, where a different terminology is used (Feasibility-Based Bounds Tightening, see e.g. Belotti, Cafieri, Lee & Liberti, 2010).\nThe decision problem we focus on is now whether there exist real-valued bounds that are a fixpoint. We note that this problem is tractable; a similar result has been reported independently in the work of Belotti, Cafieri, Lee, and Liberti (2010).\nDecision Problem 2 (Fixpoint of Continuous Linear Propagators) INPUT: a CSP whose set of constraints C are linear inequalities. QUESTION: Does the set of real-valued propagators F = {Si,k : i \u2208 1..n, k \u2208 1..m} associated to C have a common fixpoint?\nObservation 2 Decision problem 2 can be decided by Linear Programming.\nIt is easy to see that the fixpoints of operators Si,k are exactly the real-valued solutions to the system of linear constraints of Eq. 6. Note that we have been careful in the statement of Observation 2: whether Linear Programming is strongly polynomial is in fact a longstanding open question (Smale, 1998). The best \u201cpolynomial-time\u201d LP algorithms are, encouragingly, of time complexity O(\u03c0(n,m, b)) for some polynomial \u03c0, where b is the number of bits of the number encoding\u2014this looks strongly polynomial (Khachian, 1979). But there is a catch: the complexity is counted in number of operations, and operations on the rationals can in principle expand the size of the numbers (repeated multiplications can blow-up the representation exponentially). However, for practical purposes, typical LP implementations prevent the blow-up of number representation by limiting the precision to b bits throughout the execution; solvability by Linear Programming is widely regarded as synonymous to strong tractability, and provably sub-exponential LP algorithms exist (Matousek, Sharir, & Welzl, 1996). In other words, Observation 2 should really be read as a carefully phrased way to say that Problem 2 is efficiently solvable in practice."}, {"heading": "3.4.2 Linear Constraints with Unit Coefficients", "text": "A unit linear constraint is of the usual form \u2211\ni\u22081...n ai,kxi \u2265 ck but with the additional restriction that each coefficient ai,k is chosen in {\u22121, 0,+1}. Our introductory example of slow convergence (Eq. 1) was a (particularly simple) example of unit linear constraints, and the slow convergence could in this particular case be avoided. Note that we are considering linear unit constraints of any number of variables. A special case of unit constraints that have been widely studied is the class of unit-TVPI constraints (i.e., both unit and TVPI). This is perhaps the most important class of linear constraints whose integer feasibility can be solved in strongly polynomial time, see for instance work by Jaffar et al. (1994).\nProposition 2 When all constraints have unit coefficients, Decision Problem 1 can be decided by Linear Programming.\nProof. The LP is, of course, of the form given in Eq. 6. The observation is, in short, that no rounding is needed when the coefficients are unit.\nMore precisely, for any Cartesian product of intervals A, let L(A) = \u22c2\ni,k Li,k(A) and S(A) = \u22c2\ni,k Si,k(A). We show that when all coefficients are unit and when (as defined) the bounds of the initial Cartesian product D are integral, then we have Lt(D) = St(D), for all t \u2265 0. We first note that the bounds of Lt(D) are integral for all t since the original state D has integral bounds and that each operator in L applies rounding. The equality Lt(D) = St(D) is now proved by induction on t. For t = 0, Lt(D) = St(D) = D. If the induction hypothesis holds at step t, then St+1(D) = S(St(D)) = S(Lt(D)). Now St+1(D) = L(Lt(D)) = Lt+1(D) because Lt(D) has integral bounds, hence applying S or L on this Cartesian product gives the same result. (In Eq. 5 all qi,ks are integral in this case and all ai,ks are unit therefore the division qi,k/ai,k gives an integer, which means that the propagators Li,k with rounding return the same result as the non-rounded propagators Si,k of Eq. 9.)\nNow having Lt(D) = St(D), for all t \u2265 0 it is easy to see that gfp{Li,k} = gfp{Si,k}. Because the domains are finite Lt(D) stabilizes for a finite t. For this particular t, Lt(D) is the greatest fixpoint of L and the same greatest Cartesian product St(D) is also the greatest fixpoint of S. 2\nNote that in general Linear Programming does not necessarily find integer solutions to the system of Eq. 6; what the result shows is that LP will find a solution iff an integer one exists. If we want to actually compute the largest consistent bounds x\u2212i and x + i of a certain variable xi, we can simply minimize x \u2212 i or maximize x + i under the constraints of Eq. 6. The previous proof shows that these extremal values are integral."}, {"heading": "3.4.3 Are There Other Tractable Cases?", "text": "It is interesting to consider whether other properties make the propagation solvable in strongly polynomial time. With respect to restrictions on the constraint graph, there are nevertheless reasons to be pessimistic: we note that the feasibility of monotone TVPI Integer Programming remains NP-complete under strict restrictions on the constraint graph, as shown in the work of Hochbaum and Naor (1994). This suggests that such restrictions are unlikely to lead to interesting tractable classes of fixpoint computation.\nRegarding the restrictions on coefficients, we note that in general the NP-completeness of (monotone) TVPI constraints assumes that the coefficients ak, bk, ck are arbitrary. The Unit restriction imposes, on the contrary, the strongest restriction on coefficients: that their absolute value be \u2264 1. If we impose a more general bound \u03b2 on these absolute values then one may wonder whether the problem exhibits some form of fixed-parameter tractability. We leave this question open for future work."}, {"heading": "4. Generalizations and Non-Linear Constraints", "text": "By Proposition 1, fixpoint computation for numerical constraints as basic and common as linear constraints is intractable. Several cases of non-linear constraints are nevertheless of interest. First, we show that if the simplest possible type of polynomials (a single squaring operation) is added to linear constraints, then our general hardness result can be strengthened. Second, it is interesting to note that if we enrich unit linear constraints with simple min or max constraints, then fixpoint computation is equivalent to a puzzling open problem discussed recently in the theorem-proving literature. Last, we briefly comment on connections between our results and the tractability of max-closed constraints."}, {"heading": "4.1 Quadratic Constraints", "text": "For the purposes of this section it is sufficient to enrich our linear constraint language (constraints of the form given by Eq. 2) with squaring constraints of the form:\nxi = x 2 j\nIt is also sufficient to restrict ourselves to non-negative values for variables xi and xj , i.e., 0 \u2264 li \u2264 ui and 0 \u2264 lj \u2264 uj. In this setting the bound(R) consistency propagators are defined by the following instructions:\nx\u2212i := max(x \u2212 i ,\n(\nx\u2212j )2 ) x+i := min(x + i , ( x+j )2 )\nx\u2212j := max(x \u2212 j ,\n\u2308\n\u221a\nx\u2212i\n\u2309\n) x+j := min(x + j ,\n\u230a\n\u221a\nx+i\n\u230b\n)\nIn other words the fixpoints are integer solutions to the following bound consistency inequalities:\nx\u2212i \u2265 ( x\u2212j )2 ; x+i \u2264 ( x+j )2 ; x\u2212j \u2265\n\u221a\nx\u2212i ; x + j \u2264\n\u221a\nx+i (10)\nWhen these simple quadratic constraints are added to the language of linear constraints, our NP-completeness result can be strengthened: the problem is NP-complete even when considering a bounded(!) number of variables and constraints; in fact one TVPI constraint and one squaring constraint. This is due to the fact that fixpoint computation converges to a state that encodes a complex number-theoretic problem.\nProposition 3 Given a CSP with 3 variables and 2 constraints a1x1 + a2x2 = c, x1 = x 2 3, determining whether their associated bound(R) consistency propagators have a fixpoint is NP-complete.\nProof. Membership in NP is straightforward. We show the hardness result for the special case where ai \u2265 0, i \u2208 {1, 2, 3} and focus, as said, on positive intervals. We first note that the bound consistency inequalities of (Eq. 10) for the squaring constraint x1 = x 2 3 are satisfied iff x\u22121 = (x \u2212 3 ) 2 and x+1 = (x + 3 )\n2 since we focus on integer bounds. (This property of the squaring propagator is noticed in a slightly different form in Schulte & Stuckey, 2005). From a propagation viewpoint the equality a1x1 + a2x2 = c is seen as two inequalities a1x1 + a2x2 \u2265 c and \u2212a1x1 \u2212 a2x2 \u2265 c whose bound consistent inequalities (Eq. 4) are effectively satisfied iff a1x \u2212 1 + a2x + 2 = c and a1x + 1 + a2x \u2212 2 = c.\nWe rely on a theorem (Manders & Adleman, 1978) which shows that deciding whether an equation of the form a1x 2 3 + a2x2 = c has integer solutions, where a1, a2 and c are non-negative integers, is NP-complete. We reduce this problem to the existence of bound consistent bounds for the conjunction a1x1+ a2x2 = c, x1 = x 2 3 with initial bounds l1 = l2 = l3 = 0 and u1 = u2 = u3 = c. We just need to show that fixpoint computation is complete for this system\u2014a bound consistent state is found iff the original equation has a solution:\n\u2022 If the original equation has a solution, i.e., a pair of non-negative integer values \u3008v2, v3\u3009 satisfying a1v 2 3 + a2v2 = c, then we define x \u2212 1 = x + 1 = v 2 3, x \u2212 2 = x + 2 = v2, and\nx\u22123 = x + 3 = v3. These bounds are such that 0 \u2264 x \u2212 i \u2264 x + i \u2264 c and satisfy the bound consistency conditions of Eq. 10 and Eq. 4.\n\u2022 If the conjunction has a bound consistent state, i.e., bounds x\u2212i , x + i such that Eq. 10\nand Eq. 4 are satisfied, then the solution v defined by v2 = x + 2 and v3 = x \u2212 3 satisfies the original equation a1v 2 3 + a2v2 = c.\n2"}, {"heading": "4.2 Connections to the Max-Atom Problem", "text": "Another common type of primitive non-linear constraints is of the form:\nxh = max(xi, xj)\nThe bound(R) consistency propagators for this constraint are the following (Schulte & Stuckey, 2005):\nx\u2212h := max(x \u2212 h , x \u2212 i , x \u2212 j ) x + i := min(x + i , x + h )\nx+h := min(x + h ,max(x + i , x + j )) x + j := min(x + j , x + h )\n(In fact to strictly reach bound(R) consistency one would need to additionally check whether the bounds of xh have an empty intersection with the bounds of one of the max-ed variables, say xi, in which case we can essentially impose the constraint xj = xh; for the purposes of this section the simpler formulation above is equivalent.) In other words the fixpoints are characterized by the following inequalities:\nx+h \u2264 max(x + i , x + j ) x + i \u2264 x + h x + j \u2264 x + h x \u2212 h \u2265 x \u2212 i x \u2212 h \u2265 x \u2212 j\nThe fixpoint computation of max constraints mixed with unit linear constraints is interesting because its complexity is an open problem. Note that there is no rounding or use of\ncoefficients in the definition of the bound consistency inequalities, therefore the complexity arising from rounding in all our NP-complete variants of propagation does not arise here. The open problem we connect to is called Max-Atom in the work of Bezem, Nieuwenhuis, and Rodr\u0301\u0131guez-Carbonell (2008); see this reference for prior problems of interest that are shown equivalent to Max-Atom. A max-atom constraint is of the form: max(xi, xj)+c \u2265 xh. The work reported by Bezem et al. (2008) shows a number of results on the feasibility of conjunctions of max-atom constraints: (1) There is no significant complexity difference between integer and real feasibility; (2) The problem can be decided in pseudo-polynomial time using what amounts to a fixpoint computation algorithm; (3) The problem has short proofs of unsatisfiability and is therefore in NP\u2229coNP; which means that it is of a very different nature from our other NP-complete variants. In fact, a recent result (Atserias & Maneva, 2010) shows that the complexity of Max-Atom is equivalent to well-known open problems called mean-payoff games, which have in turn connections to some important open questions in model-checking: parity games, a class of games reducible to mean-payoff games, are equivalent to the model-checking problem of \u00b5-calculus (Emerson, Jutla, & Sistla, 1993; Jurdzinski, 1998).\nHere we draw a simple connection that follows from the observation that the bound consistency inequalities for the upper bounds include the constraint x+h \u2264 max(x + i , x + j ) which encode max-atom constraints almost directly.\nProposition 4 Bound(R) consistency for a combination of unit linear and max constraints can be solved in polynomial time only if Max-Atom can be also be solved in polynomial time.\nProof. To reduce a Max-Atom instance with variables xi, i \u2208 1 . . . n and m constraints to a fixpoint computation problem we simply introduce one fresh variable yk, for each k \u2208 1 . . . m. Let the kth constraint be of the form max(xik , xjk)+ ck \u2265 xhk , it rewrites to the conjunction max(xik , xjk) = yk, yk + ck \u2265 xhk . The lower bounds of all variables are fixed to 0 and the upper bounds need only be set to \u2211\nk\u22081...m ck by the small model property (Lemma 2) of the paper by Bezem et al. (2008). The bound consistency equations for the upper bounds directly encode the problem. 2"}, {"heading": "4.3 Max-Closed Constraints", "text": "We last note a connection between our results and the class of max-closed constraints introduced by Jeavons and Cooper (1995) (more on this in, e.g., Petke & Jeavons, 2009). A constraint R(x1, . . . , xn) is max-closed if whenever we have two solutions \u3008v1 . . . vn\u3009 and \u3008w1 . . . wn\u3009, their maximum defined as \u3008max(v1, w1), . . . ,max(vn, wn)\u3009 is also a solution. Results by Jeavons and Cooper (1995) show that max-closed constraints are tractable: if a system of constraints is max-closed, then its feasibility can be determined in polynomial time. However note that this result essentially assumes an explicit (or table) representation of the constraint, i.e., it is assumed that each constraint is defined by explicitly listing the tuples that are solutions to it. In contrast some important types of constraints such as the numerical constraints considered in this paper are implicitly defined : we do not know the list of solutions to R(x1, . . . , xn) but can only verify efficiently whether a particular tuple is accepted by the constraint.\nImplicitly-defined max-closed constraints played an important role in this paper: both the monotone TVPI constraints, considered in Section 3.2 and the Max-atom constraints considered in Section 4.2, are max-closed, as shown respectively by Hochbaum and Naor (1994), and Bezem et al. (2008). In sharp contrast to the case of explicitly-defined constraints, the resolution of implicitly-defined max-closed constraints is therefore only pseudopolynomial and it is in fact intractable, as shown by the special case of monotone TVPI constraints:\nObservation 3 The feasibility of \u201dimplicitly-defined\u201d max-closed constraints is NP-complete.\nAs shown in Section 3.2 with the particular example of monotone TVPI constraints, even the fixpoint computation of implicitly defined max-closed constraints is, in fact, NPcomplete in general."}, {"heading": "5. Conclusion", "text": "Reasoning about intervals was introduced in the AI literature by the works of Cleary (1987), and Davis (1987)5. A substantial body of AI work has ensued (see, e.g. Hyvo\u0308nen, 1992); bound computation is now used by most finite-domain CP solvers (Schulte & Carlsson, 2006).\nIn this paper we have theoretically investigated the complexity of computing the common fixpoint of a set of bound consistency propagators. We have shown that even when the propagators are themselves very simple, the fixpoint computation used in these algorithms can be complex, it is indeed NP-complete even for a very restricted constraint class \u2013 linear monotone inequalities with two variables per inequality. We also considered some special classes of constraints, like quadratic constraints and max constraints. Finally, we identified a class of constraints, namely, linear inequalities with unit coefficients, that allows a tractable fixpoint computation algorithm.\nBound propagation is a successful and widely used technique in Constraint Programing. There is a large literature on propagating single constraints (Van Hoeve & Katriel, 2006; Bessie\u0300re, 2006; Rossi, van Beek, & Walsh, 2006) and it is perhaps a surprise that no prior study exists on the complexity of the fixpoint computation. The NP-completeness of fixpoint computation for simple types of constraints is a fundamental and somewhat surprising result, and one that sheds light on slow convergence phenomena.\nThis result also \u201cputs bound propagation on the map\u201d of AI computational problems: together with knapsack constraints and some forms of learning in neural nets (Schaeffer & Yannakakis, 1991), it is one of the few important AI problems we are aware of that have a pseudo-polynomial complexity and yet are intractable."}, {"heading": "Acknowledgments", "text": "Preliminary results of Bordeaux, Hamadi, and Vardi (2007) showed the NP-completeness of propagation in the case where quadratic constraints are considered (Prop. 3). This\n5. As often, a good case can be made that similar ideas are already present in earlier work, in particular the work of Laurie\u0300re (1978). Interval computations are of course also used in other areas and the fixpoint computation methods we consider relate to the broader theme of interval arithmetic pioneered by Moore (1966).\npaper is a thoroughly revised version whose central result for linear constraints is new and more general. Part of this work was done while G. Katsirelos, N. Narodytska and M. Vardi were visiting Microsoft Research, Cambridge. Part of this work was done while G. Katsirelos was employed by NICTA, Australia. NICTA is funded by the Australian Governments Department of Broadband, Communications, and the Digital Economy and the Australian Research Council. This work was partially supported by the ANR UNLOC project: ANR 08-BLAN-0289-01. Discussions with Youssef Hamadi and Claude-Guy Quimper are gratefully acknowledged. Thanks also to the anonymous reviewers whose feedback helped improve the paper."}], "references": [{"title": "The essence of constraint propagation", "author": ["K.R. Apt"], "venue": "Theoretical Computer Science (TCS), 221 (1-2), 179\u2013210.", "citeRegEx": "Apt,? 1999", "shortCiteRegEx": "Apt", "year": 1999}, {"title": "An analysis of arithmetic constraints on integer intervals. Constraints", "author": ["K.R. Apt", "P. Zoeteweij"], "venue": null, "citeRegEx": "Apt and Zoeteweij,? \\Q2007\\E", "shortCiteRegEx": "Apt and Zoeteweij", "year": 2007}, {"title": "A polynomial time algorithm for solving systems of linear inequalities with two variables per inequality", "author": ["B. Aspvall", "Y. Shiloach"], "venue": "SIAM J. on Computing,", "citeRegEx": "Aspvall and Shiloach,? \\Q1980\\E", "shortCiteRegEx": "Aspvall and Shiloach", "year": 1980}, {"title": "Mean-payoff games and the max-atom problem", "author": ["A. Atserias", "E. Maneva"], "venue": "Tech. rep., Universitat Politecnica de Catalunya", "citeRegEx": "Atserias and Maneva,? \\Q2010\\E", "shortCiteRegEx": "Atserias and Maneva", "year": 2010}, {"title": "Efficient algorithms for integer programs with two variables per", "author": ["R. Bar-Yehuda", "D. Rawitz"], "venue": "constraint. Algorithmica,", "citeRegEx": "Bar.Yehuda and Rawitz,? \\Q2001\\E", "shortCiteRegEx": "Bar.Yehuda and Rawitz", "year": 2001}, {"title": "Continuous and interval constraints", "author": ["F. Behamou", "L. Granvilliers"], "venue": "Handbook of Constraint Programming,", "citeRegEx": "Behamou and Granvilliers,? \\Q2006\\E", "shortCiteRegEx": "Behamou and Granvilliers", "year": 2006}, {"title": "Feasibility-based bounds tightening via fixed points", "author": ["P. Belotti", "S. Cafieri", "J. Lee", "L. Liberti"], "venue": "In Proc. of Int. Conf. on Combinatorial Optimization and Applications (COCOA),", "citeRegEx": "Belotti et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Belotti et al\\.", "year": 2010}, {"title": "Heterogeneous constraint solving", "author": ["F. Benhamou"], "venue": "Proc. of Int. Conf. on Algebraic and Logic Programming (ALP), pp. 62\u201376.", "citeRegEx": "Benhamou,? 1996", "shortCiteRegEx": "Benhamou", "year": 1996}, {"title": "Constraint propagation", "author": ["C. Bessi\u00e8re"], "venue": "Rossi, F., van Beek, P., & Walsh, T. (Eds.), Handbook of Constraint Programming, chap. 3. Elsevier.", "citeRegEx": "Bessi\u00e8re,? 2006", "shortCiteRegEx": "Bessi\u00e8re", "year": 2006}, {"title": "The max-atom problem and its relevance", "author": ["M. Bezem", "R. Nieuwenhuis", "E. Rod\u0155\u0131guez-Carbonell"], "venue": "In Proc. of Int. Conf. on Logic for Programming, Artificial Intelligence and Reasoning (LPAR),", "citeRegEx": "Bezem et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Bezem et al\\.", "year": 2008}, {"title": "An analysis of slow convergence in interval propagation", "author": ["L. Bordeaux", "Y. Hamadi", "M.Y. Vardi"], "venue": "In Proc. of Int. Conf. on Principles and Practice of Constraint Programming (CP),", "citeRegEx": "Bordeaux et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bordeaux et al\\.", "year": 2007}, {"title": "Finite domain bounds consistency revisited", "author": ["C.W. Choi", "W. Harvey", "J.H.M. Lee", "P.J. Stuckey"], "venue": "In Australian Conf. on Artificial Intelligence,", "citeRegEx": "Choi et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Choi et al\\.", "year": 2006}, {"title": "Logical arithmetic", "author": ["J.G. Cleary"], "venue": "Future Computing Systems, 2 (2), 125\u2013149.", "citeRegEx": "Cleary,? 1987", "shortCiteRegEx": "Cleary", "year": 1987}, {"title": "Constraint propagation with interval labels", "author": ["E. Davis"], "venue": "Artificial Intelligence, 32 (3), 281\u2013331.", "citeRegEx": "Davis,? 1987", "shortCiteRegEx": "Davis", "year": 1987}, {"title": "On model-checking for fragments of \u03bc-calculus", "author": ["E.A. Emerson", "C.S. Jutla", "A.P. Sistla"], "venue": "In Proc. of Int. Conf. on Computer-Aided Verification (CAV),", "citeRegEx": "Emerson et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Emerson et al\\.", "year": 1993}, {"title": "Bound consistency techniques for long linear constraints", "author": ["W. Harvey", "J. Schimpf"], "venue": "In Proc. of CP workshop on Techniques for Implementing Constraint Propgramming Systems (TRICS)", "citeRegEx": "Harvey and Schimpf,? \\Q2002\\E", "shortCiteRegEx": "Harvey and Schimpf", "year": 2002}, {"title": "Improving linear constraint propagation by changing constraint", "author": ["W. Harvey", "P.J. Stuckey"], "venue": "representation. Constraints,", "citeRegEx": "Harvey and Stuckey,? \\Q2003\\E", "shortCiteRegEx": "Harvey and Stuckey", "year": 2003}, {"title": "Simple and fast algorithms for linear and integer programs with two variables per inequality", "author": ["D.S. Hochbaum", "J. Naor"], "venue": "SIAM J. on Computing,", "citeRegEx": "Hochbaum and Naor,? \\Q1994\\E", "shortCiteRegEx": "Hochbaum and Naor", "year": 1994}, {"title": "Constraint reasoning based on interval arithmetic: The tolerance propagation approach", "author": ["E. Hyv\u00f6nen"], "venue": "Artificial Intelligence, 58 (1-3), 71\u2013112.", "citeRegEx": "Hyv\u00f6nen,? 1992", "shortCiteRegEx": "Hyv\u00f6nen", "year": 1992}, {"title": "Beyond finite domains", "author": ["J. Jaffar", "M.J. Maher", "P.J. Stuckey", "R.H.C. Yap"], "venue": "In Proc. of Int. Workshop on Principles and Practice of Constraint Programming (PPCP),", "citeRegEx": "Jaffar et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Jaffar et al\\.", "year": 1994}, {"title": "Tractable constraints on ordered domains", "author": ["P. Jeavons", "M.C. Cooper"], "venue": "Artificial Intelligence,", "citeRegEx": "Jeavons and Cooper,? \\Q1995\\E", "shortCiteRegEx": "Jeavons and Cooper", "year": 1995}, {"title": "Deciding the winner in parity games is in UP \u2229 co-UP", "author": ["M. Jurdzinski"], "venue": "Inf. Process. Lett., 68 (3), 119\u2013124.", "citeRegEx": "Jurdzinski,? 1998", "shortCiteRegEx": "Jurdzinski", "year": 1998}, {"title": "Propagating knapsack constraints in sublinear time", "author": ["I. Katriel", "M. Sellmann", "E. Upfal", "P. Van Hentenryck"], "venue": "In Proc. of (North Amer.) Nat. Conf. on Artificial Intelligence (AAAI),", "citeRegEx": "Katriel et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Katriel et al\\.", "year": 2007}, {"title": "A polynomial algorithm for linear programming", "author": ["L. Khachian"], "venue": "Doklady Akad. USSR, 244, 1093\u20131096.", "citeRegEx": "Khachian,? 1979", "shortCiteRegEx": "Khachian", "year": 1979}, {"title": "The computational complexity of simultaneous diophantine approximation problems", "author": ["J.C. Lagarias"], "venue": "SIAM J. on Computing, 14 (1), 196\u2013209.", "citeRegEx": "Lagarias,? 1985", "shortCiteRegEx": "Lagarias", "year": 1985}, {"title": "A language and a program for stating and solving combinatorial problems", "author": ["Lauri\u00e8re", "J.-L."], "venue": "Artificial Intelligence, 10 (1), 29\u2013127.", "citeRegEx": "Lauri\u00e8re and J..L.,? 1978", "shortCiteRegEx": "Lauri\u00e8re and J..L.", "year": 1978}, {"title": "Accelerating filtering techniques for numeric CSPs", "author": ["Y. Lebbah", "O. Lhomme"], "venue": "Artificial Intelligence,", "citeRegEx": "Lebbah and Lhomme,? \\Q2002\\E", "shortCiteRegEx": "Lebbah and Lhomme", "year": 2002}, {"title": "Extending a CP solver with congruences as domains for program verification", "author": ["M. Leconte", "B. Berstel"], "venue": "In CP Workshop on Software Testing, Verification and Analysis,", "citeRegEx": "Leconte and Berstel,? \\Q2006\\E", "shortCiteRegEx": "Leconte and Berstel", "year": 2006}, {"title": "Consistency techniques for numeric CSPs", "author": ["O. Lhomme"], "venue": "Proc. of Int. Joint. Conf. on Artificial Intelligence (IJCAI), pp. 232\u2013238.", "citeRegEx": "Lhomme,? 1993", "shortCiteRegEx": "Lhomme", "year": 1993}, {"title": "Boosting the interval narrowing algorithm", "author": ["O. Lhomme", "A. Gottlieb", "M. Rueher", "P. Taillibert"], "venue": "In Proc.of Joint Int. Conf. and Symp. on Logic Programming (JICSLP),", "citeRegEx": "Lhomme et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Lhomme et al\\.", "year": 1996}, {"title": "NP-complete decision problems for binary quadratics", "author": ["K.L. Manders", "L.M. Adleman"], "venue": "J. of Computer and System Sciences,", "citeRegEx": "Manders and Adleman,? \\Q1978\\E", "shortCiteRegEx": "Manders and Adleman", "year": 1978}, {"title": "A subexponential bound for linear programming", "author": ["J. Matousek", "M. Sharir", "E. Welzl"], "venue": null, "citeRegEx": "Matousek et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Matousek et al\\.", "year": 1996}, {"title": "Interval Analysis", "author": ["R.E. Moore"], "venue": "Prentice-Hall.", "citeRegEx": "Moore,? 1966", "shortCiteRegEx": "Moore", "year": 1966}, {"title": "Computational Complexity", "author": ["C. Papadimitiou"], "venue": "Addison Wesley.", "citeRegEx": "Papadimitiou,? 1994", "shortCiteRegEx": "Papadimitiou", "year": 1994}, {"title": "Tractable benchmarks for constraint programming", "author": ["J. Petke", "P. Jeavons"], "venue": "Tech. rep. CS-RR-09-07,", "citeRegEx": "Petke and Jeavons,? \\Q2009\\E", "shortCiteRegEx": "Petke and Jeavons", "year": 2009}, {"title": "Simple local search problems that are hard to solve", "author": ["A.A. Schaeffer", "M. Yannakakis"], "venue": "SIAM J. on Computing,", "citeRegEx": "Schaeffer and Yannakakis,? \\Q1991\\E", "shortCiteRegEx": "Schaeffer and Yannakakis", "year": 1991}, {"title": "Finite domain constraint programming", "author": ["C. Schulte", "M. Carlsson"], "venue": "Handbook of Constraint Programming,", "citeRegEx": "Schulte and Carlsson,? \\Q2006\\E", "shortCiteRegEx": "Schulte and Carlsson", "year": 2006}, {"title": "When do bounds and domain propagation lead to the same search space", "author": ["C. Schulte", "P.J. Stuckey"], "venue": "ACM Trans. on Programming Languages and Systems (TOPLAS),", "citeRegEx": "Schulte and Stuckey,? \\Q2005\\E", "shortCiteRegEx": "Schulte and Stuckey", "year": 2005}, {"title": "Mathematical problems for the next century", "author": ["S. Smale"], "venue": "Mathematical Intelligencer, 20, 7\u201315.", "citeRegEx": "Smale,? 1998", "shortCiteRegEx": "Smale", "year": 1998}, {"title": "A dynamic programming approach for consistency and propagation for knapsack constraints", "author": ["M.A. Trick"], "venue": "Proc. of Int. Conf. on Integration of AI and OR Techniques in CP for Combinatorial Optimisation Problems (CP-AI-OR).", "citeRegEx": "Trick,? 2001", "shortCiteRegEx": "Trick", "year": 2001}, {"title": "Arc consistency on n-ary monotonic and linear constraints", "author": ["Z. Yuanlin", "R.H.C. Yap"], "venue": "In Proc. of Int. Conf. on Principles and Practice of Constraint Programming (CP),", "citeRegEx": "Yuanlin and Yap,? \\Q2000\\E", "shortCiteRegEx": "Yuanlin and Yap", "year": 2000}], "referenceMentions": [{"referenceID": 26, "context": "Due to the importance of the problem, efforts have been made to alleviate slow convergence, notably Jaffar, Maher, Stuckey, and Yap (1994), Lhomme, Gottlieb, Rueher, and Taillibert (1996), Lebbah and Lhomme (2002), Leconte and Berstel (2006); but all proposed algorithmic improvements prevent slow convergence only in specific cases.", "startOffset": 140, "endOffset": 188}, {"referenceID": 26, "context": "Due to the importance of the problem, efforts have been made to alleviate slow convergence, notably Jaffar, Maher, Stuckey, and Yap (1994), Lhomme, Gottlieb, Rueher, and Taillibert (1996), Lebbah and Lhomme (2002), Leconte and Berstel (2006); but all proposed algorithmic improvements prevent slow convergence only in specific cases.", "startOffset": 189, "endOffset": 214}, {"referenceID": 26, "context": "Due to the importance of the problem, efforts have been made to alleviate slow convergence, notably Jaffar, Maher, Stuckey, and Yap (1994), Lhomme, Gottlieb, Rueher, and Taillibert (1996), Lebbah and Lhomme (2002), Leconte and Berstel (2006); but all proposed algorithmic improvements prevent slow convergence only in specific cases.", "startOffset": 189, "endOffset": 242}, {"referenceID": 38, "context": "For this reason propagators for linear constraints used in practice either reach a weaker consistency such as bound(R) consistency, or are restricted to very small domains, as proposed for instance in Trick (2001). \u2022 Results by Bessi\u00e8re (2006) prove that even bounded-arity (two-variable) constraints can be constructed for which checking bound(Z) consistency is NP-complete.", "startOffset": 201, "endOffset": 214}, {"referenceID": 8, "context": "\u2022 Results by Bessi\u00e8re (2006) prove that even bounded-arity (two-variable) constraints can be constructed for which checking bound(Z) consistency is NP-complete.", "startOffset": 13, "endOffset": 29}, {"referenceID": 35, "context": "Schulte and Carlsson (2006), and Bessi\u00e8re (2006).", "startOffset": 0, "endOffset": 28}, {"referenceID": 8, "context": "Schulte and Carlsson (2006), and Bessi\u00e8re (2006).", "startOffset": 33, "endOffset": 49}, {"referenceID": 6, "context": ") We follow the classical presentation of propagators as operators on a lattice, initiated in work by Benhamou (1996) and on which more details can be found in papers by Apt (1999), and Schulte and Carlsson (2006): each propagator is a function that can narrow the domains of (some of) the variables, removing values that cannot appear in any solution.", "startOffset": 102, "endOffset": 118}, {"referenceID": 0, "context": ") We follow the classical presentation of propagators as operators on a lattice, initiated in work by Benhamou (1996) and on which more details can be found in papers by Apt (1999), and Schulte and Carlsson (2006): each propagator is a function that can narrow the domains of (some of) the variables, removing values that cannot appear in any solution.", "startOffset": 170, "endOffset": 181}, {"referenceID": 0, "context": ") We follow the classical presentation of propagators as operators on a lattice, initiated in work by Benhamou (1996) and on which more details can be found in papers by Apt (1999), and Schulte and Carlsson (2006): each propagator is a function that can narrow the domains of (some of) the variables, removing values that cannot appear in any solution.", "startOffset": 170, "endOffset": 214}, {"referenceID": 33, "context": ", whose worst-case time complexity is O(\u03c0(n,m, log d)), for some polynomial \u03c0, are called strongly polynomial (Papadimitiou, 1994).", "startOffset": 110, "endOffset": 130}, {"referenceID": 27, "context": "The earliest reference we are aware of is the work of Lhomme (1993); it considers constraints on the reals but assumes finite precision (floating points), and its analysis directly adapts to discrete intervals.", "startOffset": 54, "endOffset": 68}, {"referenceID": 13, "context": "We refer the reader to the literature for more details, in particular the papers by Harvey and Stuckey (2003), Schulte and Carlsson (2006), Bessi\u00e8re (2006), and Apt and Zoeteweij (2007) have substantial material on bound(R) consistency and linear constraints.", "startOffset": 84, "endOffset": 110}, {"referenceID": 13, "context": "We refer the reader to the literature for more details, in particular the papers by Harvey and Stuckey (2003), Schulte and Carlsson (2006), Bessi\u00e8re (2006), and Apt and Zoeteweij (2007) have substantial material on bound(R) consistency and linear constraints.", "startOffset": 84, "endOffset": 139}, {"referenceID": 6, "context": "We refer the reader to the literature for more details, in particular the papers by Harvey and Stuckey (2003), Schulte and Carlsson (2006), Bessi\u00e8re (2006), and Apt and Zoeteweij (2007) have substantial material on bound(R) consistency and linear constraints.", "startOffset": 140, "endOffset": 156}, {"referenceID": 0, "context": "We refer the reader to the literature for more details, in particular the papers by Harvey and Stuckey (2003), Schulte and Carlsson (2006), Bessi\u00e8re (2006), and Apt and Zoeteweij (2007) have substantial material on bound(R) consistency and linear constraints.", "startOffset": 161, "endOffset": 186}, {"referenceID": 2, "context": "An early pseudo-polynomial time algorithm can be found in work by Aspvall and Shiloach (1980); this algorithm essentially reduces the problem to a 2-SAT instance of size m \u00b7 d, which is solvable in linear time (the overall algorithm therefore runs in pseudo-polynomial time, but also with a pseudo-polynomial space requirement).", "startOffset": 66, "endOffset": 94}, {"referenceID": 2, "context": "An early pseudo-polynomial time algorithm can be found in work by Aspvall and Shiloach (1980); this algorithm essentially reduces the problem to a 2-SAT instance of size m \u00b7 d, which is solvable in linear time (the overall algorithm therefore runs in pseudo-polynomial time, but also with a pseudo-polynomial space requirement). A particularly relevant algorithm for TVPI constraints is proposed in the work of BarYehuda and Rawitz (2001). This algorithm has pseudo-polynomial time complexity with low, strongly polynomial space requirements.", "startOffset": 66, "endOffset": 439}, {"referenceID": 24, "context": "We can now prove our NP-hardness result from monotone TVPI constraints, using the following result: Theorem 1 (Lagarias, 1985) The feasibility of Two-Variable-Per-Inequality monotone Integer Programming is NP-complete.", "startOffset": 110, "endOffset": 126}, {"referenceID": 38, "context": "Note that we have been careful in the statement of Observation 2: whether Linear Programming is strongly polynomial is in fact a longstanding open question (Smale, 1998).", "startOffset": 156, "endOffset": 169}, {"referenceID": 23, "context": "The best \u201cpolynomial-time\u201d LP algorithms are, encouragingly, of time complexity O(\u03c0(n,m, b)) for some polynomial \u03c0, where b is the number of bits of the number encoding\u2014this looks strongly polynomial (Khachian, 1979).", "startOffset": 200, "endOffset": 216}, {"referenceID": 19, "context": "This is perhaps the most important class of linear constraints whose integer feasibility can be solved in strongly polynomial time, see for instance work by Jaffar et al. (1994).", "startOffset": 157, "endOffset": 178}, {"referenceID": 17, "context": "With respect to restrictions on the constraint graph, there are nevertheless reasons to be pessimistic: we note that the feasibility of monotone TVPI Integer Programming remains NP-complete under strict restrictions on the constraint graph, as shown in the work of Hochbaum and Naor (1994). This suggests that such restrictions are unlikely to lead to interesting tractable classes of fixpoint computation.", "startOffset": 265, "endOffset": 290}, {"referenceID": 21, "context": "In fact, a recent result (Atserias & Maneva, 2010) shows that the complexity of Max-Atom is equivalent to well-known open problems called mean-payoff games, which have in turn connections to some important open questions in model-checking: parity games, a class of games reducible to mean-payoff games, are equivalent to the model-checking problem of \u03bc-calculus (Emerson, Jutla, & Sistla, 1993; Jurdzinski, 1998).", "startOffset": 362, "endOffset": 412}, {"referenceID": 9, "context": "The work reported by Bezem et al. (2008) shows a number of results on the feasibility of conjunctions of max-atom constraints: (1) There is no significant complexity difference between integer and real feasibility; (2) The problem can be decided in pseudo-polynomial time using what amounts to a fixpoint computation algorithm; (3) The problem has short proofs of unsatisfiability and is therefore in NP\u2229coNP; which means that it is of a very different nature from our other NP-complete variants.", "startOffset": 21, "endOffset": 41}, {"referenceID": 9, "context": "m ck by the small model property (Lemma 2) of the paper by Bezem et al. (2008). The bound consistency equations for the upper bounds directly encode the problem.", "startOffset": 59, "endOffset": 79}, {"referenceID": 20, "context": "3 Max-Closed Constraints We last note a connection between our results and the class of max-closed constraints introduced by Jeavons and Cooper (1995) (more on this in, e.", "startOffset": 125, "endOffset": 151}, {"referenceID": 20, "context": "3 Max-Closed Constraints We last note a connection between our results and the class of max-closed constraints introduced by Jeavons and Cooper (1995) (more on this in, e.g., Petke & Jeavons, 2009). A constraint R(x1, . . . , xn) is max-closed if whenever we have two solutions \u3008v1 . . . vn\u3009 and \u3008w1 . . . wn\u3009, their maximum defined as \u3008max(v1, w1), . . . ,max(vn, wn)\u3009 is also a solution. Results by Jeavons and Cooper (1995) show that max-closed constraints are tractable: if a system of constraints is max-closed, then its feasibility can be determined in polynomial time.", "startOffset": 125, "endOffset": 427}, {"referenceID": 16, "context": "2, are max-closed, as shown respectively by Hochbaum and Naor (1994), and Bezem et al.", "startOffset": 44, "endOffset": 69}, {"referenceID": 9, "context": "2, are max-closed, as shown respectively by Hochbaum and Naor (1994), and Bezem et al. (2008). In sharp contrast to the case of explicitly-defined constraints, the resolution of implicitly-defined max-closed constraints is therefore only pseudopolynomial and it is in fact intractable, as shown by the special case of monotone TVPI constraints: Observation 3 The feasibility of \u201dimplicitly-defined\u201d max-closed constraints is NP-complete.", "startOffset": 74, "endOffset": 94}, {"referenceID": 8, "context": "There is a large literature on propagating single constraints (Van Hoeve & Katriel, 2006; Bessi\u00e8re, 2006; Rossi, van Beek, & Walsh, 2006) and it is perhaps a surprise that no prior study exists on the complexity of the fixpoint computation.", "startOffset": 62, "endOffset": 137}, {"referenceID": 11, "context": "Conclusion Reasoning about intervals was introduced in the AI literature by the works of Cleary (1987), and Davis (1987)5.", "startOffset": 89, "endOffset": 103}, {"referenceID": 11, "context": "Conclusion Reasoning about intervals was introduced in the AI literature by the works of Cleary (1987), and Davis (1987)5.", "startOffset": 89, "endOffset": 121}, {"referenceID": 32, "context": "Interval computations are of course also used in other areas and the fixpoint computation methods we consider relate to the broader theme of interval arithmetic pioneered by Moore (1966).", "startOffset": 174, "endOffset": 187}], "year": 2011, "abstractText": "Bound propagation is an important Artificial Intelligence technique used in Constraint Programming tools to deal with numerical constraints. It is typically embedded within a search procedure (\u201dbranch and prune\u201d) and used at every node of the search tree to narrow down the search space, so it is critical that it be fast. The procedure invokes constraint propagators until a common fixpoint is reached, but the known algorithms for this have a pseudo-polynomial worst-case time complexity: they are fast indeed when the variables have a small numerical range, but they have the well-known problem of being prohibitively slow when these ranges are large. An important question is therefore whether stronglypolynomial algorithms exist that compute the common bound consistent fixpoint of a set of constraints. This paper answers this question. In particular we show that this fixpoint computation is in fact NP-complete, even when restricted to binary linear constraints.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}