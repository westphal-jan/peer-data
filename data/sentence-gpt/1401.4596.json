{"id": "1401.4596", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jan-2014", "title": "Unfounded Sets and Well-Founded Semantics of Answer Set Programs with Aggregates", "abstract": "Logic programs with aggregates (LPA) are one of the major linguistic extensions to Logic Programming (LP). In this work, we propose a generalization of the notions of unfounded set and well-founded semantics for programs with monotone and antimonotone aggregates (LPAma programs). In particular, we present a new notion of unfounded set for LPAma programs, which is a sound generalization of the original definition for standard (aggregate-free) LP. On this basis, we define a well-founded operator for LPAma programs, the fixpoint of which is called well-founded model (or well-founded semantics) for LPAma programs. The most important properties of unfounded sets and the well-founded semantics for standard LP are retained by this generalization, notably existence and uniqueness of the well-founded model, together with a strong relationship to the answer set semantics for LPAma programs. We show that one of the D-well-founded semantics, defined by Pelov, Denecker, and Bruynooghe for a broader class of aggregates using approximating operators, coincides with the well-founded model as defined in this work on LPAma programs. We also discuss some complexity issues, most importantly we give a formal proof of tractable computation of the well-founded model for LPA programs. Moreover, we prove that for general LPA programs, which may contain aggregates that are neither monotone nor antimonotone, deciding satisfaction of aggregate expressions with respect to partial interpretations is coNP-complete. As a consequence, a well-founded semantics for general LPA programs that allows for tractable computation is unlikely to exist, which justifies the restriction on LPAma programs. Finally, we present a prototype system extending DLV, which supports the well-founded semantics for LPAma programs, at the time of writing the only implemented system that does so. Experiments with this prototype show significant computational advantages of aggregate constructs over equivalent aggregate-free encodings. The result is that our model of general LPA programs is not a homogeneous, linear linear system, but an independent linear system.\n\n\n\n\nThe paper \"Applied LPA Programming in LPA.\" (published October 2, 2016, pp. 33-34). The paper \"Applied LPA Programming in LPA.\" (published October 2, 2016, pp. 33-34). The paper \"Applied LPA Programming in LPA.\" (published October 2", "histories": [["v1", "Sat, 18 Jan 2014 21:05:13 GMT  (449kb)", "http://arxiv.org/abs/1401.4596v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["mario alviano", "francesco calimeri", "wolfgang faber", "nicola leone", "simona perri"], "accepted": false, "id": "1401.4596"}, "pdf": {"name": "1401.4596.pdf", "metadata": {"source": "CRF", "title": "Unfounded Sets and Well-Founded Semantics of Answer Set Programs with Aggregates", "authors": ["Mario Alviano", "Francesco Calimeri", "Wolfgang Faber", "Simona Perri"], "emails": ["alviano@mat.unical.it", "calimeri@mat.unical.it", "faber@mat.unical.it", "leone@mat.unical.it", "perri@mat.unical.it"], "sections": [{"heading": null, "text": "for LPAm,a programs, which is a sound generalization of the original definition for standard (aggregate-free) LP. On this basis, we define a well-founded operator for LPAm,a programs, the fixpoint of which is called well-founded model (or well-founded semantics) for LPAm,a programs. The most important properties of unfounded sets and the well-founded semantics for standard LP are retained by this generalization, notably existence and uniqueness of the well-founded model, together with a strong relationship to the answer set semantics for LPAm,a programs. We show that one of the D\u0303-well-founded semantics, defined by Pelov, Denecker, and Bruynooghe for a broader class of aggregates using approximating operators, coincides with the well-founded model as defined in this work on LPAm,a programs. We also discuss some complexity issues, most importantly we give a formal proof of tractable computation of the well-founded model for LPAm,a programs. Moreover, we prove that for general LPA programs, which may contain aggregates that are neither monotone nor antimonotone, deciding satisfaction of aggregate expressions with respect to partial interpretations is coNP-complete. As a consequence, a well-founded semantics for general LPA programs that allows for tractable computation is unlikely to exist, which justifies the restriction on LPAm,a programs. Finally, we present a prototype system extending DLV, which supports the well-founded semantics for LPAm,a programs, at the time of writing the only implemented system that does so. Experiments with this prototype show significant computational advantages of aggregate constructs over equivalent aggregate-free encodings."}, {"heading": "1. Introduction", "text": "The use of logical formulas as a basis for a knowledge representation language was proposed about 50 years ago in some seminal works of McCarthy (1959), and McCarthy and Hayes (1969). However, it was soon realized that the monotonic nature of classical logic (the addition of new knowledge may only increase the set of consequences of a theory in classical logic) is not always suited to model commonsense reasoning, which sometimes is intrinsically nonmonotonic (Minsky, 1975). As an alternative, it was suggested to represent\nc\u00a92011 AI Access Foundation. All rights reserved.\ncommonsense reasoning using logical languages with nonmonotonic consequence relations, which can better simulate some forms of human reasoning, allowing new knowledge to invalidate some of the previous conclusions. This observation opened a new and important research field, called nonmonotonic reasoning, and led to the definition and investigation of new logical formalisms, called nonmonotonic logics. The most popular nonmonotonic logics are circumscription (McCarthy, 1980, 1986), default logic (Reiter, 1980), and nonmonotonic modal logics (McDermott & Doyle, 1980; McDermott, 1982; Moore, 1985). Later on, from cross fertilizations between the field of nonmonotonic logics and that of logic programming, another nonmonotonic language, called Declarative Logic Programming (LP) has emerged, incorporating a nonmonotonic negation operator denoted by not. Declarative Logic Programming has gained popularity in the last years, and today it is a widely used formalism for knowledge representation and reasoning, with applications in various scientific disciplines and even in industry (Ricca, Alviano, Dimasi, Grasso, Ielpa, Iiritano, Manna, & Leone, 2010; Ricca, Grasso, Alviano, Manna, Lio, Iiritano, & Leone, 2011; Manna, Ricca, & Terracina, 2011; Manna, Ruffolo, Oro, Alviano, & Leone, 2011). In LP problems are solved by means of declarative specifications of requirements to be achieved. No ad-hoc algorithms are required.\nSeveral semantics for LP have been proposed in the literature, which have to take care about the inherent non-monotonicity of the not operator in programs. The well-founded semantics (Van Gelder, Ross, & Schlipf, 1991) is one of the most prominent among them. It associates a three-valued model, the well-founded model, to every logic program. Originally, the well-founded semantics has been defined for normal logic programs, that is, standard logic programs with nonmonotonic negation. A distinguishing property of the well-founded semantics is that existence and uniqueness of the well-founded model is guaranteed for all logic programs. Moreover, the well-founded semantics is computable in polynomial time with respect to the input program in the propositional case.\nEven if LP is a declarative programming language, standard LP does not allow for representing properties over sets of data in a natural way, a relevant aspect in many application domains. For addressing this insufficiency, several extensions of LP have been proposed, the most relevant of which is the introduction of aggregate functions (LPA; Kemp & Stuckey, 1991; Denecker, Pelov, & Bruynooghe, 2001; Dix & Osorio, 1997; Gelfond, 2002; Simons, Niemela\u0308, & Soininen, 2002; Dell\u2019Armi, Faber, Ielpa, Leone, & Pfeifer, 2003; Pelov & Truszczyn\u0301ski, 2004; Pelov, Denecker, & Bruynooghe, 2004). Among them, recursive definitions involving aggregate functions (i.e., aggregation in which aggregated data depend on the evaluation of the aggregate itself) are particularly interesting, as the definition of their semantics is not straightforward (Pelov, 2004; Faber, Leone, & Pfeifer, 2004; Son & Pontelli, 2007; Liu, Pontelli, Son, & Truszczynski, 2010). Note that a similar construct, referred to as abstract constraint, has been introduced in the literature (Marek & Truszczyn\u0301ski, 2004; Liu & Truszczyn\u0301ski, 2006; Son, Pontelli, & Tu, 2007; Truszczyn\u0301ski, 2010; Brewka, 1996). All of the results in this paper carry over also to LP with abstract constraints, for which well-founded semantics to our knowledge has not been defined so far.\nIn this paper we focus on the fragment of LPA allowing for monotone and antimonotone aggregate expressions (LPAm,a; Calimeri, Faber, Leone, & Perri, 2005). LP A m,a programs have many interesting properties. Among them, we highlight similarities between monotone aggregate expressions and positive standard literals, and between antimonotone aggregate\nexpressions and negative standard literals. In particular, we take advantage of this aspect for defining unfounded sets and, based on this definition, a well-founded semantics for the LPAm,a fragment. The well-founded semantics for LP A m,a programs obtained in this way retains many desirable properties of the original well-founded semantics for LP, which it extends: For each LPAm,a program a unique well-founded model exists, which is polynomialtime computable, approximates the programs answer sets, and coincides with the answer set on stratified LPAm,a programs.\nActually it turns out that the well-founded semantics thus obtained coincides (on LPAm,a programs) with a well-founded semantics proposed by Pelov, Denecker, and Bruynooghe (2007). Pelov et al. define several semantics of logic programs with aggregates using various approximating immediate consequence operators. The notion of logic program adopted by Pelov et al. is more general than the one considered in the present work, allowing for arbitrary first-order formulas in bodies, unrestricted aggregates, and non-Herbrand interpretations. Because of the equivalence of the two semantics, some properties proved by Pelov et al. carry over to this work as well. This applies to the results that the well-founded model is total on stratified programs (Theorem 9), that the well-founded model is contained in each answer set (Theorem 16), and that the well-founded model is computable in polynomial time (Theorem 21). However, the framework introduced in this article is considerably different from the one developed by Pelov et al., which allows for giving alternative proofs to these result. Vice versa, this article contains many new results, which carry over to the framework of Pelov et al. on LPAm,a programs. In particular, it provides an alternative definition of the well-founded semantics, a characterization of answer sets by means of unfounded sets, and an implemented system computing the well-founded semantics, at the time of writing the only one of its kind.\nWe would like to point out that for most extensions of LPAm,a programs that come to mind, the definition of unfounded sets would have to be considerably changed (see for instance the definition provided in Faber, 2005), and moreover the main desired properties of the well-founded semantics would no longer be guaranteed. For instance, the most obvious extension, including aggregate expressions that are neither monotone nor antimonotone would most likely not be computable in polynomial time: In fact, while the evaluation of aggregate expressions with respect to partial interpretations is tractable for monotone and antimonotone aggregates, the same task is coNP-complete for general aggregate expressions. Also, for instance allowing aggregates in rule heads would necessarily complicate the definition of unfounded sets, would not guarantee the existence of a well-founded model for every program, and would most likely not guarantee polynomial-time computability.\nThe concepts defined in this paper directly give rise to a computation method for the well-founded semantics on LPAm,a programs. We have implemented this method, which is\u2014 to the best of our knowledge\u2014the first of its kind. We have conducted experiments with this system on LPAm,a encodings of a particular problem domain, and compared it with encodings not using aggregates. The latter encodings were tested with the system from which our prototype was derived and with XSB, a state-of-the-art system for computing the well-founded model. The experiments show a clear advantage of the LPAm,a encodings run on our prototype system.\nSummarizing, the main contributions of the paper are as follows.\n\u2022 We define a new notion of unfounded set for logic programs with monotone and antimonotone aggregates (LPAm,a programs). This notion is a sound generalization of the concept of unfounded set previously given for standard logic programs. We show that our definition coincides with the original definition of unfounded sets (Van Gelder et al., 1991) on the class of normal (aggregate-free) programs, and that it shares its distinguishing properties (such as the existence of the greatest unfounded set).\n\u2022 We define a well-founded operator WP for logic programs with aggregates, which extends the classical well-founded operator (Van Gelder et al., 1991). The total fixpoints of WP are exactly the answer sets of P, and its least fixpoint W \u03c9 P(\u2205) is contained in\nthe intersection of all answer sets. We also show that the operator is equivalent to an operator defined by Pelov et al. (2007).\n\u2022 We provide a declarative characterization of answer sets in terms of unfounded sets. In particular, we prove that the answer sets of an LPAm,a program are precisely the unfounded-free models.\n\u2022 We show that reasoning with aggregates without restrictions may easily increase the complexity of the computation. In particular, we prove that deciding the truth or falsity of an aggregate expression with respect to a partial interpretation is a coNP-complete problem. However, while the problem is intractable in general, it is polynomial-time solvable for monotone and antimonotone aggregates.\n\u2022 We analyze the complexity of the well-founded semantics, confirming and extending results in the work of Pelov et al. (2007). Importantly, it turns out that W\u03c9P(\u2205) is polynomial-time computable for propositional LPAm,a programs. For non-ground programs, the data-complexity remains polynomial, while the program complexity rises from P to EXPTIME, as for aggregate-free programs.\n\u2022 We present a prototype system supporting the well-founded semantics defined in this article. The prototype, obtained by extending DLV, is the first system implementing a well-founded semantics for (unrestricted) LPAm,a programs.\n\u2022 We report on experimental results on the implemented prototype. More specifically, we define the Attacks problem, a problem inspired by the classic Win-Lose problem often considered in the context of the well-founded semantics for standard logic programs. We compare the execution times of our prototype with an LPAm,a encoding and with equivalent LP encodings. In particular, one of the tested LP encodings is obtained by means of a compilation of aggregates into standard LP, which is also briefly presented in this paper. The obtained results evidence computational advantages for the problem encoding using aggregate expressions over those without them.\nThe presentation is organized as follows. In Section 2 we present the basics of the LPA language and, in particular, we introduce the LPAm,a fragment. For this fragment, we define unfounded sets and well-founded semantics in Section 3. Relationships between well-founded semantics and answer set semantics are discussed in Section 4. A complexity analysis of the well-founded semantics for LPAm,a programs is reported in Section 5. In\nSection 6 we discuss the implemented prototype system and the experimentation. Finally, related work is discussed in Section 7, and in Section 8 we draw our conclusions.\n2. The LPA Language\nSyntax, instantiation, interpretations and models of LPA programs are introduced in this section. Moreover, we introduce the LPAm,a fragment of the language, for which we define a well-founded semantics in Section 3. For additional background on standard LP, we refer to the literature (Gelfond & Lifschitz, 1991; Baral, 2003)."}, {"heading": "2.1 Syntax", "text": "We assume sets of variables, constants, and predicates to be given. Similar to Prolog, we assume variables to be strings starting with uppercase letters and constants to be nonnegative integers or strings starting with lowercase letters. Predicates are strings starting with lowercase letters. An arity (non-negative integer) is associated with each predicate. Moreover, the language allows for using built-in predicates (i.e., predicates with a fixed meaning) for the common arithmetic operations over positive integers (i.e., =, \u2264, \u2265, +, \u00d7, etc.; written in infix notation), which are interpreted in the standard mathematical way."}, {"heading": "2.1.1 Standard Atom", "text": "A term is either a variable or a constant. A standard atom is an expression p(t1, . . . , tn), where p is a predicate of arity n and t1, . . . , tn are terms. An atom p(t1, . . . , tn) is ground if t1, . . . , tn are constants."}, {"heading": "2.1.2 Set Term", "text": "A set term is either a symbolic set or a ground set. A symbolic set is a pair {Terms :Conj}, where Terms is a list of terms (variables or constants) and Conj is a conjunction of standard atoms, that is, Conj is of the form a1, . . . , ak and each ai (1 \u2264 i \u2264 k) is a standard atom. Intuitively, a set term {X :a(X, c), p(X)} stands for the set of X-values making the conjunction a(X, c), p(X) true, i.e., {X |a(X, c) and p(X) are true}. A ground set is a set of pairs of the form \u3008consts :conj \u3009, where consts is a list of constants and conj is a conjunction of ground standard atoms."}, {"heading": "2.1.3 Aggregate Function", "text": "An aggregate function is of the form f(S), where S is a set term, and f is an aggregate function symbol. Intuitively, an aggregate function can be thought of as a (possibly partial) function mapping multisets of constants to a constant. Throughout the remainder of the paper, we will adopt the notation of the DLV system (Leone, Pfeifer, Faber, Eiter, Gottlob, Perri, & Scarcello, 2006) for representing aggregates.\nExample 1 The most common aggregate functions are listed below:\n\u2022 #min, minimal term, undefined for the empty set;\n\u2022 #max, maximal term, undefined for the empty set;\n\u2022 #count, number of terms;\n\u2022 #sum, sum of integers;\n\u2022 #times, product of integers;\n\u2022 #avg, average of integers, undefined for the empty set."}, {"heading": "2.1.4 Aggregate Atom", "text": "An aggregate atom is a structure of the form f(S) \u227a T , where f(S) is an aggregate function, \u227a \u2208 {<, \u2264, >,\u2265} is a comparison operator, and T is a term (variable or constant). An aggregate atom f(S) \u227a T is ground if T is a constant and S is a ground set.\nExample 2 The following are aggregate atoms in DLV notation:\n#max{Z : r(Z), a(Z, V )} > Y #max{\u30082 : r(2), a(2,m)\u3009, \u30082 : r(2), a(2, n)\u3009} > 1"}, {"heading": "2.1.5 Literal", "text": "A literal is either (i) a standard atom, or (ii) a standard atom preceded by the negation as failure symbol not, or (iii) an aggregate atom. Two standard literals are complementary if they are of the form a and not a, for some standard atom a. For a standard literal \u2113, we denote by \u00ac.\u2113 the complement of \u2113. Abusing of notation, if L is a set of standard literals, then \u00ac.L denotes the set {\u00ac.\u2113 | \u2113 \u2208 L}."}, {"heading": "2.1.6 Program", "text": "A rule r is a construct of the form\na :\u2212 \u21131, . . . , \u2113m.\nwhere a is a standard atom, \u21131, . . . , \u2113m are literals, and m \u2265 0. The atom a is referred to as the head of r, and the conjunction \u21131, . . . , \u2113m as the body of r. If the body is empty (m = 0), then the rule is called fact. We denote the head atom by H(r) = a, and the set of body literals by B(r) = {\u21131, . . . , \u2113m}. Moreover, the set of positive standard body literals is denoted by B+(r), the set of negative standard body literals by B\u2212(r), and the set of aggregate body literals by BA(r). A rule r is ground if H(r) and all the literals in B(r) are ground. A program is a set of rules. A program is ground if all its rules are ground."}, {"heading": "2.1.7 Safety", "text": "A local variable of a rule r is a variable appearing solely in sets terms of r; a variable of r which is not local is global. A rule r is safe if both the following conditions hold: (i) for each global variable X of r there is a positive standard literal \u2113 \u2208 B+(r) such that X appears in \u2113; (ii) each local variable of r appearing in a symbolic set {Terms :Conj} also appears in Conj . Note that condition (i) is the standard safety condition adopted in LP to guarantee that the variables are range restricted (Ullman, 1989), while condition (ii) is specific for aggregates. A program is safe if all its rules are safe.\nExample 3 Consider the following rules:\np(X) :\u2212 q(X,Y, V ), #max{Z : r(Z), a(Z, V )} > Y. p(X) :\u2212 q(X,Y, V ), #sum{Z : r(X), a(X,S)} > Y. p(X) :\u2212 q(X,Y, V ), #min{Z : r(Z), a(Z, V )} > T.\nThe first rule is safe, while the second is not because the local variable Z violates condition (ii). Also the third rule is not safe, since the global variable T violates condition (i)."}, {"heading": "2.2 Program Instantiation, Interpretations and Models", "text": "In Section 3 we define a well-founded semantics for a relevant class of LPA programs. The well-founded semantics is defined for ground programs, while programs with variables are associated with equivalent ground programs. In this section we introduce preliminary notions such as program instantiation, interpretations and models."}, {"heading": "2.2.1 Universe and Base", "text": "Given an LPA program P, the universe of P, denoted by UP , is the set of constants appearing in P. The base of P, denoted by BP , is the set of standard atoms constructible from predicates of P with constants in UP ."}, {"heading": "2.2.2 Instantiation", "text": "A substitution is a mapping from a set of variables to UP . Given a substitution \u03c3 and an LPA object obj (rule, set, etc.), we denote by obj \u03c3 the object obtained by replacing each variable X in obj by \u03c3(X). A substitution from the set of global variables of a rule r (to UP) is a global substitution for r; a substitution from the set of local variables of a set term S (to UP) is a local substitution for S. Given a set term without global variables S = {Terms :Conj}, the instantiation of S is the following ground set:\ninst(S) = {\u3008Terms \u03c3 :Conj \u03c3\u3009 | \u03c3 is a local substitution for S}.\nA ground instance of a rule r is obtained in two steps: First, a global substitution \u03c3 for r is applied, and then every set term S in r\u03c3 is replaced by its instantiation inst(S). The instantiation Ground(P) of a program P is the set of instances of all the rules in P.\nExample 4 Consider the following program P1:\nq(1) :\u2212 not p(2, 2). q(2) :\u2212 not p(2, 1). t(X) :\u2212 q(X), #sum{Y : p(X,Y )} > 1. p(2, 2) :\u2212 not q(1). p(2, 1) :\u2212 not q(2).\nThe instantiation Ground(P1) of P1 is the following program: q(1) :\u2212 not p(2, 2). q(2) :\u2212 not p(2, 1). t(1) :\u2212 q(1), #sum{\u30081 : p(1, 1)\u3009, \u30082 : p(1, 2)\u3009} > 1. p(2, 2) :\u2212 not q(1). p(2, 1) :\u2212 not q(2). t(2) :\u2212 q(2), #sum{\u30081 : p(2, 1)\u3009, \u30082 : p(2, 2)\u3009} > 1."}, {"heading": "2.2.3 Aggregate Function Domain", "text": "Given a set X, let 2 X\ndenote the set of all multisets over elements from X. The domain of an aggregate function is the set of multisets on which the function is defined. Without loss of generality, we assume that aggregate functions map to Z (the set of integers).\nExample 5 Let us look at common domains for the aggregate functions of Example 1: #count is defined over 2 UP, #sum and #times over 2 Z , #min, #max and #avg over 2 Z \\ {\u2205}."}, {"heading": "2.2.4 Interpretation", "text": "An interpretation I for an LPA program P is a consistent set of standard ground literals, that is, I \u2286 BP \u222a \u00ac.BP and I \u2229 \u00ac.I = \u2205. We denote by I\n+ and I\u2212 the set of standard positive and negative literals occurring in I, respectively. An interpretation I is total if I+ \u222a \u00ac.I\u2212 = BP , otherwise I is partial. The set of all the interpretations of P is denoted by IP . Given an interpretation I and a standard literal \u2113, the evaluation of \u2113 with respect to I is defined as follows: (i) if \u2113 \u2208 I, then \u2113 is true with respect to I; (ii) if \u00ac.\u2113 \u2208 I, then \u2113 is false with respect to I; (iii) otherwise, if \u2113 6\u2208 I and \u00ac.\u2113 6\u2208 I, then \u2113 is undefined with respect to I. An interpretation also provides a meaning to set terms, aggregate functions and aggregate literals, namely a multiset, a value, and a truth value, respectively. We first consider a total interpretation I. The evaluation I(S) of a set term S with respect to I is the multiset I(S) defined as follows: Let SI = {\u3008t1, ..., tn\u3009 | \u3008t1, ..., tn : Conj \u3009 \u2208 S and all the atoms in Conj are true with respect to I}; I(S) is the multiset obtained as the projection of the tuples of SI on their first constant, that is, I(S) = [t1 | \u3008t1, ..., tn\u3009 \u2208 S\nI ]. The evaluation I(f(S)) of an aggregate function f(S) with respect to I is the result of the application of f on I(S).1 If the multiset I(S) is not in the domain of f , then I(f(S)) = \u22a5 (where \u22a5 is a fixed symbol not occurring in P). A ground aggregate atom \u2113 = f(S) \u227a k is true with respect to I if both I(f(S)) 6= \u22a5 and I(f(S)) \u227a k hold; otherwise, \u2113 is false.\nExample 6 Let I1 be a total interpretation having I + 1 = {f(1), g(1, 2), g(1, 3), g(1, 4), g(2, 4), h(2), h(3), h(4)}. Assuming that all variables are local, we can check that:\n\u2022 #count{X : g(X,Y )} > 2 is false; indeed, if S1 is the corresponding ground set, then SI11 = {\u30081\u3009, \u30082\u3009}, I1(S1) = [1, 2] and #count([1, 2]) = 2.\n\u2022 #count{X,Y : g(X,Y )} > 2 is true; indeed, if S2 is the corresponding ground set, then SI12 = {\u30081, 2\u3009, \u30081, 3\u3009, \u30081, 4\u3009, \u30082, 4\u3009}, I1(S2) = [1, 1, 1, 2] and #count([1, 1, 1, 2]) = 4.\n\u2022 #times{Y : f(X), g(X,Y )} <= 24 is true; indeed, if S3 is the corresponding ground set, then SI13 = {\u30082\u3009, \u30083\u3009, \u30084\u3009}, I1(S3) = [2, 3, 4] and #times([2, 3, 4]) = 24.\n\u2022 #sum{X : g(X,Y ), h(Y )} <= 3 is true; indeed, if S4 is the corresponding ground set, then SI14 = {\u30081\u3009, \u30082\u3009}, I1(S4) = [1, 2] and #sum([1, 2]) = 3.\n\u2022 #sum{X,Y : g(X,Y ), h(Y )} <= 3 is false; indeed, if S5 is the corresponding ground set, then SI15 = {\u30081, 2\u3009, \u30081, 3\u3009, \u30081, 4\u3009, \u30082, 4\u3009}, I1(S5) = [1, 1, 1, 2] and #sum([1, 1, 1, 2]) = 5.;\n\u2022 #min{X : f(X), h(X)} >= 2 is false; indeed, if S6 is the corresponding ground set, then SI16 = \u2205, I1(S6) = \u2205, and I1(#min(\u2205)) = \u22a5 (we recall that \u2205 is not in the domain of #min).\n1. In this paper, we only consider aggregate functions value of which is polynomial-time computable with respect to the input multiset.\nWe now consider a partial interpretation I and refer to an interpretation J such that I \u2286 J as an extension of I. If a ground aggregate atom \u2113 is true (resp. false) with respect to each total interpretation J extending I, then \u2113 is true (resp. false) with respect to I; otherwise, \u2113 is undefined.\nExample 7 Let S7 be the ground set in the literal \u21131 = #sum{\u30081 : p(2, 1)\u3009, \u30082 : p(2, 2)\u3009} > 1, and consider a partial interpretation I2 = {p(2, 2)}. Since each total interpretation extending I2 contains either p(2, 1) or not p(2, 1), we have either I2(S7) = [2] or I2(S7) = [1, 2]. Thus, the application of #sum yields either 2 > 1 or 3 > 1, and thus \u21131 is true with respect to I2.\nRemark 1 Observe that our definitions of interpretation and truth values preserve \u201cknowledge monotonicity\u201d: If an interpretation J extends I (i.e., I \u2286 J), each literal which is true with respect to I is true with respect to J , and each literal which is false with respect to I is false with respect to J as well."}, {"heading": "2.2.5 Model", "text": "Given an interpretation I, a rule r is satisfied with respect to I if at least one of the following conditions is satisfied: (i) H(r) is true with respect to I; (ii) some literal in B(r) is false with respect to I; (iii) H(r) and some literal in B(r) are undefined with respect to I. An interpretation M is a model of an LPA program P if all the rules r in Ground(P) are satisfied with respect to M .\nExample 8 Consider again the program P1 of Example 4. Let I3 be a total interpretation for P1 such that I + 3 = {q(2), p(2, 2), t(2)}. Then I3 is a minimal model of P1.\n2.3 The LPAm,a Language\nThe definition of LPAm,a programs, the fragment of LP A analyzed in this paper, is based on the following notion of monotonicity of literals."}, {"heading": "2.3.1 Monotonicity", "text": "Given two interpretations I and J , we say that I \u2264 J if I+ \u2286 J+ and I\u2212 \u2287 J\u2212. A ground literal \u2113 is monotone if, for all interpretations I, J such that I \u2264 J , we have that: (i) \u2113 true with respect to I implies \u2113 true with respect to J , and (ii) \u2113 false with respect to J implies \u2113 false with respect to I. A ground literal \u2113 is antimonotone if the opposite happens, that is, for all interpretations I, J such that I \u2264 J , we have that: (i) \u2113 false with respect to I implies \u2113 false with respect to J , and (ii) \u2113 true with respect to J implies \u2113 true with respect to I. A ground literal \u2113 is nonmonotone if \u2113 is neither monotone nor antimonotone. Note that positive standard literals are monotone, whereas negative standard literals are antimonotone. Aggregate literals, instead, may be monotone, antimonotone or nonmonotone. Some examples are shown below and the complete picture for the most common aggregate functions is summarized in Table 1.\nExample 9 Let us assume a universe in which all numerical constants are non-negative integers. All ground instances of the following aggregate literals are thus monotone:\nGround instances of the following literals are instead antimonotone:\n#count{Z : r(Z)} < 1; #sum{Z : r(Z)} \u2264 10.\n2.3.2 LPAm,a Programs\nLet LPAm,a denote the fragment of LP A allowing monotone and antimonotone literals. For an LPAm,a rule r, the set of its monotone and antimonotone body literals are denoted by Bm(r) and Ba(r), respectively. An LPAm,a program P is stratified if there exists a function || \u00b7 ||, called level mapping, from the set of predicates of P to ordinals, such that for each pair a, b of predicates, occurring in the head and body of a rule r \u2208 P, respectively: (i) if b appears in an antimonotone literal, then ||b|| < ||a||, (ii) otherwise ||b|| \u2264 ||a||. Intuitively, stratification forbids recursion through antimonotone literals (for aggregate-free programs this definition coincides with the common notion of stratification with respect to negation).\nExample 10 Consider an LPAm,a program consisting of the following rules: q(X) :\u2212 p(X), #count{Y : a(Y,X), b(X)} \u2264 2. p(X) :\u2212 q(X), b(X).\nand assume that the predicates a and b are defined by facts, which we do not include explicitly. The program is stratified, as the level mapping ||a|| = ||b|| = 1, ||p|| = ||q|| = 2 satisfies the required conditions. If we add the rule b(X) :\u2212 p(X), then no such levelmapping exists, and the program becomes unstratified.\nWe would like to note that the definition of LPAm,a could be enlarged, as in the form given above classifies literals independently of the context (that is, the program) in which\nthey occur. Some aggregates that are nonmonotone by the definition given above, might not manifest their nonmonotone effects in a given context: If one limits the interpretations to be considered to those that do not violate the program in which the literal occurs, some interpretation pairs that violate monotonicity and antimonotonicity may no longer be present. In fact, one could refine the definition in this way (considering only pairs of non-violating interpretations of a given context program). The modified definition would enlarge the class of LPAm,a programs, while retaining all of the results in this paper, but for simplicity of exposition we refrain from doing it formally. As an example, any aggregate atom involving #max with a < operator is formally not in LPAm,a, but when one considers occurrences in a program that has no non-violating interpretation I such that I(S) = \u2205 (where S the set term of the aggregate), then the aggregate behaves in an antimonotone way in that particular program. We have noted these cases by a footnote in Table 1."}, {"heading": "3. Unfounded Sets and Well-Founded Semantics", "text": "In this section we introduce a new notion of unfounded set for LPAm,a programs, which extends the original definition for aggregate-free programs introduced by Van Gelder et al. (1991). Unfounded sets are then used for extending the well-founded semantics, originally defined for aggregate-free programs by Van Gelder et al., to LPAm,a programs. We also highlight a number of desirable properties of this semantics. In the following we deal with ground programs, so we will usually denote by P a ground program. We will also use the notation L \u222a\u0307 \u00ac.L\u2032 for the set (L \\ L\u2032) \u222a \u00ac.L\u2032, where L and L\u2032 are sets of standard ground literals.\nDefinition 1 (Unfounded Set) A set X \u2286 BP of ground atoms is an unfounded set for an LPAm,a program P with respect to a (partial) interpretation I if and only if, for each rule r \u2208 P having H(r) \u2208 X , at least one of the following conditions holds:\n(1) some (antimonotone) literal in Ba(r) is false with respect to I, or\n(2) some (monotone) literal in Bm(r) is false with respect to I \u222a\u0307 \u00ac.X .\nIntuitively, each rule with its head atom belonging to an unfounded set X is already satisfied with respect to I (in case condition (1) holds), or it is satisfiable by taking as false all the atoms in the unfounded set (in case condition (2) holds). Note that, according to the definition above, the empty set is an unfounded set with respect to every program and interpretation.\nExample 11 Consider an interpretation I4 = {a(1), a(2), a(3)} for the following program P2:\nr1 : a(1) :\u2212 #count{\u30081:a(1)\u3009, \u30082:a(2)\u3009, \u30083:a(3)\u3009} > 2. r2 : a(2). r3 : a(3) :\u2212 #count{\u30081:a(1)\u3009, \u30082:a(2)\u3009, \u30083:a(3)\u3009} > 2.\nThen X1 = {a(1)} is an unfounded set for P2 with respect to I4, since condition (2) of Definition 1 holds for r1 (the only rule with head a(1)). Indeed, the (monotone) literal appearing in Bm(r1) is false with respect to I4 \u222a\u0307 \u00ac.X1 = {not a(1), a(2), a(3)}. Similarly, {a(3)} and {a(1), a(3)} are unfounded sets for P2 with respect to I4. Clearly, also \u2205 is an unfounded set. All other sets of atoms are not unfounded for P2 with respect to I4.\nAs formalized below, Definition 1 generalizes the one given by Van Gelder et al. (1991) for aggregate-free programs: A set of standard atoms X \u2286 BP is an unfounded set for a program P with respect to an interpretation I if and only if, for each rule r \u2208 P such that H(r) \u2208 X , either (i) B(r) \u2229 \u00ac.I 6= \u2205, or (ii) B+(r) \u2229 X 6= \u2205.\nTheorem 1 For an aggregate-free program P, Definition 1 is equivalent to the one introduced in the work of Van Gelder et al. (1991).\nProof. For an aggregate-free program P, conditions (1) and (2) of Definition 1 are equivalent to (a) B\u2212(r) \u2229 \u00ac.I 6= \u2205 and (b) B+(r) \u2229 \u00ac.(I \u222a\u0307 \u00ac.X ) 6= \u2205, respectively. Condition (b) is equivalent to B+(r) \u2229 (\u00ac.(I \\ X ) \u222a \u00ac.\u00ac.X ) 6= \u2205, which holds if and only if either (b.1) B+(r) \u2229 \u00ac.(I \\ X ) 6= \u2205, or (b.2) B+(r) \u2229 X 6= \u2205. Condition (b.2) is exactly condition (ii) in the work of Van Gelder et al. Concerning condition (b.1), since B+(r) contains only positive literals, we can ignore the negative literals in \u00ac.(I \\X ), that is, the positive literals in I \\ X . By noting that the negative literals in I \\ X are precisely the negative literals in I, we can then conclude that (b.1) is equivalent to B+(r) \u2229 \u00ac.I 6= \u2205. Finally, by combining the previous statement with condition (a) above, we obtain condition (i) in the work of Van Gelder et al. \u2737\nThus, Definition 1 is an alternative characterization of unfounded sets for aggregate-free programs. In fact, while condition (1) of Definition 1 does not exactly cover the first one in Van Gelder et al., condition (2) catches all cases of the second in the work of Van Gelder et al. and those \u201cmissed\u201d by condition (1).\nTheorem 2 If X and X \u2032 are unfounded sets for an LPAm,a program P with respect to an interpretation I, then X \u222a X \u2032 is an unfounded set for P with respect to I.\nProof. Let r \u2208 P be such that H(r) \u2208 X \u222a X \u2032. We want to show that either (1) some (antimonotone) literal in Ba(r) is false with respect to I, or (2) some (monotone) literal in Bm(r) is false with respect to J = I \u222a\u0307 \u00ac.(X \u222a X \u2032). By symmetry, we can assume that H(r) belongs to X . Since X is an unfounded set with respect to I by hypothesis, either (a) some (antimonotone) literal in Ba(r) is false with respect to I, or (b) some (monotone) literal in Bm(r) is false with respect to K = I \u222a\u0307 \u00ac.X . Case (a) is equals to (1). Thus, it remains to prove that case (b) implies (2). Indeed, we have that J \u2264 K because J+ \u2286 K+ and J\u2212 \u2287 K\u2212. Therefore, by definition of monotonicity, each monotone literal \u2113 which is false with respect to K is false with respect to J as well, and so we are done. \u2737\nAs a corollary of Theorem 2, the union of all the unfounded sets is an unfounded set as well.\nCorollary 3 The union of all the unfounded sets for an LPAm,a program P with respect to an interpretation I is an unfounded set for P with respect to I as well. We refer to this set as the greatest unfounded set of P with respect to I, denoted by GUSP(I).\nBelow is an important monotonicity property of the greatest unfounded set.\nProposition 4 Let I and J be interpretations for an LPAm,a program P. If I \u2286 J , then GUSP(I) \u2286 GUSP(J).\nProof. Since GUSP(J) is the union of all the unfounded sets for P with respect to J by definition, it is enough to show that X = GUSP(I) is an unfounded set for P with respect to J . Thus, we want to show that, for each rule r \u2208 P such that H(r) \u2208 X , either (1) some (antimonotone) literal in Ba(r) is false with respect to J , or (2) some (monotone) literal in Bm(r) is false with respect to J \u222a\u0307 \u00ac.X . We already know that X is an unfounded set for P with respect to I by Corollary 3. Therefore, either (a) some (antimonotone) literal in Ba(r) is false with respect to I, or (b) some (monotone) literal in Bm(r) is false with respect to I \u222a\u0307 \u00ac.X . Since I \u2286 J , we have that J and J \u222a\u0307 \u00ac.X are extensions of the interpretations I and I \u222a\u0307 \u00ac.X , respectively. Hence, by Remark 1, (a) implies (1) and (b) implies (2), and so we are done. \u2737\nWe are now ready for extending the well-founded operator defined by Van Gelder et al. (1991) to the case of LPAm,a programs.\nDefinition 2 Let P be an LPAm,a program. The immediate logical consequence operator TP : IP \u2192 2 BP and the well-founded operator WP : IP \u2192 2 BP\u222a\u00ac.BP are defined as follows:\nTP(I) = {\u2113 \u2208 BP | \u2203r \u2208 P such that H(r) = \u2113 and all the literals in B(r) are true with respect to I} WP(I) = TP(I) \u222a \u00ac.GUSP(I).\nIntuitively, given an interpretation I for a program P, WP derives as true a set of atoms belonging to every model extending I (by means of the TP operator). Moreover, WP derives as false all the atoms belonging to some unfounded set for P with respect to I (by means of the GUSP operator). Note that TP(I) and GUSP(I) are set of atoms, so WP(I) + = TP(I) and WP(I) \u2212 = \u00ac.GUSP(I). The following proposition formalizes the intuition that Definition 2 extends the WP operator defined by Van Gelder et al. (1991) for standard programs to LPAm,a programs.\nProposition 5 Let P be an aggregate-free program. The WP operator of Definition 2 coincides with the WP operator defined by Van Gelder et al. (1991).\nProof. Since WP is equal to the union of TP and \u00ac.GUSP in both cases, we have just to show that our definitions of TP and GUSP coincide with those introduced by Van Gelder et al. (1991) for aggregate-free programs.\n\u2022 The two immediate logical consequence operators (TP) coincide for an aggregate-free program P. Indeed, for each rule r \u2208 P, B(r) has only standard literals.\n\u2022 Our definition of GUSP(I) coincides with the one of Van Gelder et al. (1991) for an aggregate-free program P and an interpretation I. Indeed, in both cases GUSP(I) is defined as the union of all the unfounded sets for P with respect to I, and our notion of unfounded set coincides with the one in the work of Van Gelder et al. for standard programs by Theorem 1. \u2737\nWe next show that a fixpoint of the well-founded operator WP is a (possibly partial) model.\nTheorem 6 Let P be an LPAm,a program and M a (partial) interpretation. If M is a fixpoint of WP , then M is a (partial) model of P.\nProof. Let us assume that WP(M) = M holds. Thus, TP(M) \u2286 M and \u00ac.GUSP(M) \u2286 M hold. Consider now a rule r \u2208 P. If all the literals in B(r) are true with respect to M , then H(r) \u2208 TP(M) \u2286 M . If H(r) is false with respect to M , then H(r) \u2208 GUSP(M). Since GUSP(M) is an unfounded set for P with respect to M by Corollary 3, either some literal in Ba(r) is false with respect to M , or some literal in Bm(r) is false with respect to M \u222a\u0307 \u00ac.GUSP(M) = M . We can then conclude that r is satisfied by M . \u2737\nThe theorem below states that WP is a monotone operator in the meet semilattice induced on IP by the subset-containment relationship. We recall here that a meet semilattice is a partially ordered set which has a meet (or greatest lower bound) for any nonempty finite subset. An example of such a meet semilattice for a program with base {a, b} is reported in Figure 1.\nTheorem 7 Let P be an LPAm,a program. The well-founded operator WP is a monotone operator in the meet semilattice \u3008IP ,\u2286\u3009.\nProof. Since WP is equal to the union of TP and \u00ac.GUSP by Definition 2, we have just to prove the monotonicity of the operators TP and GUSP .\n\u2022 We first show that TP is a monotone operator, that is, for each pair of interpretations I, J for P such that I \u2286 J , it holds that TP(I) \u2286 TP(J). Consider an atom \u2113 \u2208 TP(I). By Definition 2, there is a rule r \u2208 P such that H(r) = \u2113 and all the literals in B(r) are true with respect to I. Since I \u2286 J , we can conclude that all the literals in B(r) are true with respect to J as well (see Remark 1), and so H(r) = \u2113 belongs to TP(J) by Definition 2.\n\u2022 We already know that GUSP is a monotone operator from Proposition 4: For each pair of interpretations I, J for P such that I \u2286 J , it holds that GUSP(I) \u2286 GUSP(J).\n\u2737\nWe can now prove that the sequence W0 = \u2205, Wn+1 = WP(Wn) is well-defined, that is, each element of the sequence is an interpretation.\nTheorem 8 Let P be an LPAm,a program. The sequence W0 = \u2205, Wn+1 = WP(Wn) is well-defined.\nProof. We use strong induction. The base case is trivial, since W0 = \u2205. In order to prove the consistency of Wn+1 = TP(Wn)\u222a\u00ac.GUSP(Wn), we assume the consistency of every Wm such that m \u2264 n. Since WP is a monotone operator by Theorem 7, it is enough to show that GUSP(Wn)\u2229Wn+1 = \u2205. To this end, we next show that any set X of atoms such that X \u2229Wn+1 6= \u2205 is not an unfounded set for P with respect to Wn (and so is not contained in GUSP(Wn)). Let Wm+1 be the first element of the sequence such that X \u2229Wm+1 6= \u2205 (note that m \u2264 n). Consider any atom \u2113 \u2208 X \u2229Wm+1. By definition of TP , there is a rule r \u2208 P having H(r) = \u2113 and such that all the literals in B(r) are true with respect to Wm. Note that no atom in Wm can belong to X (for the way in which Wm+1 has been chosen). Thus, by Remark 1, all the literals in B(r) are true with respect to both Wn and Wn \u222a\u0307 \u00ac.X (we recall that Wn \u2287 Wm because WP is monotone). This ends the proof, as neither condition (1) nor (2) of Definition 1 hold for \u2113. \u2737\nTheorem 8 and Theorem 7 imply that WP admits a least fixpoint (Tarski, 1955), which is referred to as the well-founded model of P. The well-founded semantics of an LPAm,a program P is given by this model. We can now state a first important property of the well-founded semantics of LPAm,a programs.\nProperty 1 For every LPAm,a program, the well-founded model always exists and is unique.\nAnother important property of well-founded semantics easily follows from Proposition 5.\nProperty 2 On aggregate-free programs, the well founded semantics as defined in this paper coincides with the classical well-founded semantics of Van Gelder et al. (1991).\nAlthough the well-founded model, in general, might leave some atoms as undefined, there are cases where W\u03c9P(\u2205) is a total interpretation.\nExample 12 Consider the following program P3: a(1) :\u2212 #sum{\u30081:a(1)\u3009, \u30082:a(2)\u3009} > 2. a(2) :\u2212 b. b :\u2212 not c.\nThe iterated application of WP yields the following sets:\n1. WP(\u2205) = {not a(1), not c}; 2. WP({not a(1), not c}) = {not a(1), not c, b}; 3. WP({not a(1), not c, b}) = {not a(1), not c, b, a(2)} = W \u03c9 P(\u2205).\nIn this case, the well-founded model is total. Indeed, each atom in BP is either true or false with respect to W\u03c9P(\u2205).\nThe totality of the well-founded model of the program above is due to its stratification, as formalized by the next theorem. Given Corollary 25, an equivalent result has been stated already by Pelov et al. (2007) as Theorem 7.2 and its Corollary 7.1. However, its proof is labelled as sketch by Pelov et al., which moreover relies on rather different formalisms than our proof.\nTheorem 9 On stratified LPAm,a programs, the well-founded model is total.\nProof. Let P be a stratified LPAm,a program. In order to prove that W \u03c9 P(\u2205) is total, we show that each (standard) atom in BP \\W \u03c9 P(\u2205) is false with respect to W \u03c9 P(\u2205). By definition of stratification, there is a level mapping || \u00b7 || of the (standard) predicates of P such that, for each pair a, b of standard predicates occurring in the head and body of a rule r \u2208 P, respectively, the following conditions are satisfied: (i) if b appears in an antimonotone literal, then ||b|| < ||a|| holds; (ii) otherwise, if b appears in a monotone literal, then ||b|| \u2264 ||a|| holds. We are then in order to define a non-decreasing sequence of subsets of BP as follows:\nL0 = \u2205 Li+1 = Li \u222a {\u2113 \u2208 BP | the predicate of \u2113 is p and ||p|| = i}, \u2200i \u2208 N.\nOur aim is then to show that, for each i \u2208 N, the set Li+1\\W \u03c9 P(\u2205) is contained in \u00ac.W \u03c9 P(\u2205) \u2212. We use induction on i. The base case is trivial because L0 = \u2205 holds by definition. Now suppose that all the atoms in Li \\W \u03c9 P(\u2205) are false with respect to W \u03c9 P(\u2205) in order to show that all the atoms in Li+1 \\ W \u03c9 P(\u2205) are false with respect to W \u03c9 P(\u2205) as well. To this end, we prove that Li+1 \\ W \u03c9 P(\u2205) is an unfounded set for P with respect to W \u03c9 P(\u2205). Consider a rule r \u2208 Ground(P) with H(r) \u2208 Li+1 \\ W \u03c9 P(\u2205). We want to show that either (1) some (antimonotone) literal in Ba(r) is false with respect to W\u03c9P(\u2205), or (2) some (monotone) literal in Bm(r) is false with respect to W\u03c9P(\u2205) \u222a\u0307 \u00ac.(Li+1 \\W \u03c9 P(\u2205)). Since H(r) \u2208 Li+1, by definition of stratification the following propositions hold:\n(a) each literal in Ba(r) is either a negated standard atom belonging to Li, or an aggregate literal depending only on atoms in Li;\n(b) each literal in Bm(r) is either a standard atom belonging to Li+1, or an aggregate literal depending only on atoms in Li+1.\nSince H(r) 6\u2208 W\u03c9P(\u2205) (that is, H(r) 6\u2208 TP(W \u03c9 P(\u2205))), there is a literal \u2113 in B(r) such that \u2113 is not true with respect to W\u03c9P(\u2205) (by definition of TP). If \u2113 is an antimonotone literal, we apply (a) and the induction hypothesis and conclude that (1) holds (\u2113 cannot be undefined with respect to W\u03c9P(\u2205), so \u2113 must be false). If \u2113 is a monotone literal, we apply (b) and the induction hypothesis and conclude that (2) holds (\u2113 cannot be undefined with respect to W\u03c9P(\u2205) \u222a\u0307 \u00ac.(Li+1 \\W \u03c9 P(\u2205)) and W \u03c9 P(\u2205) \u222a\u0307 \u00ac.(Li+1 \\W \u03c9 P(\u2205)) \u2264 W \u03c9 P(\u2205) holds, so \u2113 must be false). \u2737"}, {"heading": "4. Answer Set Characterization via Unfounded Sets", "text": "The well-founded semantics is a three-valued semantics, that is, each program is associated with a model in which atoms are either true, false or undefined. Other semantics in the literature associate programs with two-valued models (i.e., models without undefined atoms). A commonly accepted two-value semantics in LP is the answer set semantics. In this section we present a number of results concerning unfounded sets and answer sets of LPAm,a programs. We first recall the definition of answer sets provided by Faber, Leone, and Pfeifer (2011).\nDefinition 3 (Minimal Model) A total model M for P is (subset-)minimal if no total model N for P exists such that N+ \u2282 M+. Note that, under these definitions, the words interpretation and model refer to possibly partial interpretations, while a minimal model is always a total interpretation.\nWe next provide the transformation by which the reduct of a ground program with respect to a total interpretation is formed. Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs.\nDefinition 4 (Program Reduct) Given an LPA program P and a total interpretation I, let Ground(P)I denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.:\nGround(P)I = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}.\nWe are now ready for introducing the notion of answer set for LPA programs.\nDefinition 5 (Answer Set for LPA Programs) Given an LPA program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P)M .\nExample 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs:\nP4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.}\nWe then obtain the following transformed programs: Ground(P4)\nI5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4)\nI6 = \u2205 Ground(P5)\nI5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.}\nHence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5).\nNote that any answer set M of P is also a total model of P because Ground(P)M \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P)M are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M).\nOn the language LPAm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al. (2007). This equivalence follows from Propositions 3.7 and 3.8 of Ferraris (2011), which respectively state that stable models of Pelov et al. (2003) on LPAm,a coincide with a semantics defined by Ferraris (2011), which in turn coincides with Definition 5 on a larger class of programs. This means that all our results involving answer sets also hold for these other semantics on LPAm,a. On the other hand, this also implies that some of the results (for example Theorem 16) are consequences of results in the work of Pelov et al. (2007) by virtue of Theorem 24 in Section 7.\nIn the remainder of this section we highlight relevant relationships between answer sets and unfounded sets. Before introducing our results, let us provide an additional definition.\nDefinition 6 (Unfounded-free Interpretation) An interpretation I for an LPAm,a program P is unfounded-free if and only if I \u2229 X = \u2205 holds for each unfounded set X for P with respect to I.\nFor total interpretations, an equivalent characterization of the unfounded-free property is given below.\nLemma 10 A total interpretation I for an LPAm,a program P is unfounded-free if and only if the empty set is the only subset of I+ which is an unfounded set for P with respect to I.\nProof. (\u21d2) Straightforward: By Definition 6, I is disjoint from all the unfounded set for P with respect to I.\n(\u21d0) We prove the contrapositive: If I is not unfounded-free, then there exists a non-empty subset of I+ which is an unfounded set for P with respect to I. From Definition 6, if I is not unfounded-free, then there exists an unfounded set X for P with respect to I such that I \u2229 X 6= \u2205. We next show that I \u2229 X is an unfounded set for P with respect to I, i.e., for each rule r \u2208 P such that H(r) \u2208 I \u2229 X , either (1) some (antimonotone) literal in Ba(r) is false with respect to I, or (2) some (monotone) literal in Bm(r) is false with respect to I \u222a\u0307 \u00ac.(I \u2229 X ). Since X is an unfounded set, by Definition 1, either (a) some (antimonotone) literal in Ba(r) is false with respect to I, or (b) some (monotone) literal in Bm(r) is false with respect to I \u222a\u0307 \u00ac.X . Thus, we can end the proof by showing that I \u222a\u0307 \u00ac.X = I \u222a\u0307 \u00ac.(I \u2229 X ). To this end, observe that (i) \u00ac.X = \u00ac.(X \\ I) \u222a \u00ac.(I \u2229 X ). Moreover, since I is total, \u00ac.(BP \\ I\n+) = I\u2212, and thus (ii) \u00ac.(X \\ I) = \u00ac.(X \\ I+) \u2286 I\u2212 \u2286 I \\ X . By using (i) in I \u222a\u0307 \u00ac.X = (I \\X )\u222a\u00ac.X and simplifying with (ii) we obtain I \u222a\u0307 \u00ac.X = (I \\X )\u222a\u00ac.(I \u2229X ). We conclude by observing that I \\ X = I \\ (I \u2229 X ), and thus I \u222a\u0307 \u00ac.X = I \u222a\u0307 \u00ac.(I \u2229 X ) holds. \u2737\nNow we give another interesting characterization of total models for LPAm,a programs.\nLemma 11 A total interpretation M is a (total) model for an LPAm,a program P if and only if \u00ac.M\u2212 is an unfounded set for P with respect to M .\nProof. We start by observing that each rule r \u2208 P such that H(r) \u2208 M+ is satisfied by M . Thus, we have to show that, for each rule r \u2208 P with H(r) \u2208 \u00ac.M\u2212, some literal in B(r) is false with respect to M if and only if either (1) some (antimonotone) literal in Ba(r) is false with respect to M , or (2) some (monotone) literal in Bm(r) is false with respect to M \u222a\u0307 \u00ac.(\u00ac.M\u2212). To this end, it is enough to prove that M \u222a\u0307 \u00ac.(\u00ac.M\u2212) = M holds. By definition, (\u2217) M \u222a\u0307 \u00ac.(\u00ac.M\u2212) = (M \\ \u00ac.M\u2212) \u222a \u00ac.\u00ac.M\u2212. From the consistency of M we have that M and \u00ac.M\u2212 are disjoint. Moreover, \u00ac.\u00ac.M\u2212 = M\u2212 is a subset of M . By simplifying (\u2217) with the last two sentences, we obtain M \u222a\u0307 \u00ac.(\u00ac.M\u2212) = M . \u2737\nNow we give further characterizations of answer sets for LPAm,a programs.\nTheorem 12 A total model M is an answer set of an LPAm,a program P if and only if M is unfounded-free.\nProof. (\u21d2) We prove the contrapositive: If a total model M of an LPAm,a program P is not unfounded-free, then M is not an answer set of P. By Lemma 10, since M is a total interpretation and it is not unfounded-free, there exists an unfounded set X for P with respect to M such that X \u2286 M+ and X 6= \u2205. Therefore, to prove that M is not an answer set of P, we next show that M \u222a\u0307 \u00ac.X is a model of PM such that M \u222a\u0307 \u00ac.X \u2282 M . To this end, consider a rule r \u2208 PM . By Definition 4 of reduct, all the literals in B(r) are true with respect to M , and so H(r) \u2208 M+ because M is a model of P and PM \u2286 P. We now have to consider two cases:\n1. H(r) 6\u2208 X . In this case, H(r) \u2208 M \u222a\u0307 \u00ac.X as well.\n2. H(r) \u2208 X . In this case, since X is an unfounded set for P with respect to M , either (1) some literal in Ba(r) is false with respect to M , or (2) some literal in Bm(r) is false with respect to M \u222a\u0307 \u00ac.X . By previous considerations, since r \u2208 PM , (1) cannot hold, and so we can conclude that some literal in B(r) is false with respect to M \u222a\u0307 \u00ac.X .\nHence, we have that r is satisfied by M \u222a\u0307 \u00ac.X either by head (in case H(r) 6\u2208 X ), or by body (in case H(r) \u2208 X ), and so we are done.\n(\u21d0) We prove the contrapositive: If a total model M of an LPAm,a program P is not an answer set of P, then M is not unfounded-free. Since M is a model of P \u2287 PM but not an answer set of P, there exists a total model N of PM such that N+ \u2282 M+. We next show that M+ \\N+ is an unfounded set for P with respect to M , that is, for each rule r \u2208 P such that H(r) \u2208 M+ \\N+, either (1) some (antimonotone) literal in Ba(r) is false with respect to M , or (2) some (monotone) literal in Bm(r) is false with respect to M \u222a\u0307 \u00ac.(M+ \\N+).\nWe start by showing thatM \u222a\u0307 \u00ac.(M+ \\N+) = N . By definition, (a)M \u222a\u0307 \u00ac.(M+ \\N+) = (M \\ (M+ \\ N+)) \u222a \u00ac.(M+ \\ N+). From N+ \u2282 M+ we have (b) M \\ (M+ \\ N+) = N+ \u222aM\u2212. Moreover, since N and M are total interpretations and N+ \u2282 M+, we have (c) N\u2212 \u2283 M\u2212 and (d) \u00ac.(M+ \\N+) = N\u2212 \\M\u2212. Thus, by using (b) and (d) in (a) we obtain M \u222a\u0307 \u00ac.(M+ \\N+) = N+\u222aM\u2212\u222a(N\u2212\\M\u2212), and by observing that M\u2212\u222a(N\u2212\\M\u2212) = N\u2212 holds because of (c), we conclude (e) M \u222a\u0307 \u00ac.(M+ \\N+) = N+ \u222aN\u2212 = N . Consider now a rule r \u2208 P such that H(r) \u2208 M+ \\N+. We have to deal with two cases:\n1. r \u2208 P \\PM . In this case, by Definition 4, there must be a literal \u2113 \u2208 B(r) such that \u2113 is false with respect to M . If \u2113 is an antimonotone literal, then (1) holds. Otherwise, \u2113 is a monotone literal and so \u2113 is false with respect to N as well, since N \u2264 M ; thus, (2) holds because of (e).\n2. r \u2208 PM . In this case, since N is a model of PM and H(r) is false with respect to N (because H(r) \u2208 M+ \\N+ by assumption), there must be a literal \u2113 \u2208 B(r) such that \u2113 is false with respect to N . If \u2113 is an antimonotone literal, then \u2113 is false with respect to M as well, since N \u2264 M , and so (1) holds. Otherwise, \u2113 is a monotone literal and (2) holds because of (e). \u2737\nWe are then ready to state an important connection between answer sets and unfounded sets.\nTheorem 13 A total interpretation M for an LPAm,a program P is an answer set of P if and only if GUSP(M) = \u00ac.M \u2212.\nProof. (\u21d2) Let M be an answer set of P. By Lemma 11, \u00ac.M\u2212 is an unfounded set for P with respect to M , and hence GUSP(M) \u2287 \u00ac.M\n\u2212. By Theorem 12, M is unfounded-free, and hence GUSP(M) \u2286 \u00ac.M \u2212 because M is total. In sum, GUSP(M) = \u00ac.M \u2212.\n(\u21d0) LetM be a total interpretation such thatGUSP(M) = \u00ac.M \u2212. ThenM andGUSP(M) = \u00ac.M\u2212 are disjoint, and soM is unfounded-free. Moreover, by Corollary 3, GUSP(M) = M \u2212 is an unfounded set for P with respect to M and so, by applying Lemma 11, we conclude that M is a model of P. We are then in order to apply Theorem 12 (M is an unfounded-free model of P) and conclude that M is an answer set of P. \u2737\nThe following theorem shows that answer sets of LPAm,a programs are exactly the total fixpoints of the well-founded operator defined in Section 3.\nTheorem 14 Let M be a total interpretation for an LPAm,a program P. Then M is an answer set for P if and only if M is a fixpoint of the well-founded operator WP .\nProof. (\u21d2) LetM be an answer set of P. We want to show thatM is a fixpoint ofWP , that is, WP(M) = M . Our aim is then to show that TP(M) = M + and \u00ac.GUSP(M) = M \u2212. Since M is an answer set, by applying Theorem 13, we obtain GUSP(M) = \u00ac.M \u2212, which is equivalent to \u00ac.GUSP(M) = M \u2212. Therefore, it remains to prove that TP(M) = M +:\n(\u2286) Consider an atom \u2113 \u2208 TP(M). By Definition 2, there is a rule r \u2208 P such that H(r) = \u2113 and all the literals in B(r) are true with respect to M . Thus, \u2113 \u2208 M+ holds because M is a model of P.\n(\u2287) Consider an atom \u2113 \u2208 M+. Since M is an answer set of P, we can apply Theorem 12 and conclude that M is unfounded-free. Hence, the (singleton) set {\u2113} \u2286 M+ is not an unfounded set for P with respect to M . Thus, by Definition 1, there is a rule r \u2208 P such that H(r) = \u2113 and neither (1) some (antimonotone) literal in Ba(r) is false with respect to M , nor (2) some (monotone) literal in Bm(r) is false with respect to M \u222a\u0307 \u00ac.{\u2113}. Since M is a total interpretation, neither (1) nor (2) is equivalent to both (i) all the (antimonotone) literals in Ba(r) are true with respect to M , and (ii) all the (monotone) literals in Bm(r) are true with respect to M \u222a\u0307 \u00ac.{\u2113}. By observing that M \u222a\u0307 \u00ac.{\u2113} \u2264 M , we can state that (ii) implies that all the (monotone) literals in Bm(r) are true with respect to M as well. By combining the latter statement with (i) we obtain that all the literals in B(r) are true with respect to M , and so \u2113 \u2208 TP(M) by Definition 2.\n(\u21d0) Let M be a total fixpoint of WP , i.e., WP(M) = M . Thus, M \u2212 = \u00ac.GUSP(M) by Definition 2, and so M is an answer set for P because of Theorem 13. \u2737\nObserve that Theorem 14 is a generalization of Theorem 5.4 of Van Gelder et al. (1991) to the class of LPAm,a programs. It is also worth noting that WP(I) extends I preserving its \u201ccorrectness\u201d: If I is contained in an answer set M , then WP(I) may add to I some literals of M , but never introduces any literal which would be inconsistent with M .\nProposition 15 Let I be an interpretation for an LPAm,a program P, and let M be an answer set for P. If I \u2286 M , then WP(I) \u2286 M .\nProof. This is a trivial consequence of the monotonicity of the operator WP (Theorems 7) and Theorem 14. Indeed, by Theorems 7, WP is I \u2286 M implies WP(I) \u2286 WP(M), and WP(M) = M by Theorem 14. \u2737\nWe next show that the well-founded model of an LPAm,a program is contained in all the answer sets (if any) of P. We would like to point out that due to Theorem 24 in Section 7 (showing the equivalence of the well-founded operators defined in this work and the one defined in Pelov et al., 2007) and Propositions 3.77 and 3.8 of Ferraris (2011; showing the equivalence of answer sets in Faber et al., 2011 and stable models in Pelov et al., 2007), the following results also hold by virtue of the definitions of the well-founded and stable semantics in the work of Pelov et al., in particular due to Proposition 7.3 of that paper. We nevertheless also provide a proof using the concepts defined earlier.\nTheorem 16 Let P be an LPAm,a program. For each answer set M of P, W \u03c9 P(\u2205) \u2286 M .\nProof. Let M be an answer set of P. Note that W\u03c9P(\u2205) is the limit of the sequence W0 = \u2205, Wn = WP(Wn\u22121). We show that Wn \u2286 M by induction on n. The base case is trivially true since W0 = \u2205 by definition. Now assume Wn \u2286 M in order to show that Wn+1 \u2286 M . Since Wn+1 = WP(Wn) by definition and Wn \u2286 M by induction hypothesis, we apply Proposition 15 and conclude that Wn+1 \u2286 M . \u2737\nThe theorem above suggests another property of well-founded semantics for LPAm,a programs.\nProperty 3 The well-founded semantics for LPAm,a programs approximates the answer set semantics: The well-founded model is contained in the intersection of all answer sets (if any).\nBy combining Theorem 14 and Theorem 16, we obtain the following claim.\nCorollary 17 Let P be an LPAm,a program. If W \u03c9 P(\u2205) is a total interpretation, then it is the unique answer set of P.\nTherefore, by combining Theorem 9 and the corollary above, we obtain another property of well-founded semantics for LPAm,a programs.\nProperty 4 On stratified LPAm,a programs, the well-founded model coincides with the unique answer set."}, {"heading": "5. The Complexity of the Well-Founded Semantics", "text": "For the complexity analysis carried out in this section, we consider ground programs and polynomial-time computable aggregate functions (note that all example aggregate functions appearing in this paper fall into this class). However, we eventually provide a discussion on how results change when considering non-ground programs. We start with an important property of monotone and antimonotone aggregate literals.\nLemma 18 Let I be a partial interpretation for a ground LPAm,a program P. We define two total interpretations for P as follows: Imin = I \u222a\u00ac.(BP \\ I) and Imax = I \u222a (BP \\\u00ac.I). For each (ground) aggregate literal A occurring in P, the following statements hold:\n1. If A is a monotone literal, then A is true (resp. false) with respect to I if and only if A is true with respect to Imin (resp. false with respect to Imax).\n2. If A is an antimonotone literal, then A is true (resp. false) with respect to I if and only if A is true with respect to Imax (resp. false with respect to Imin).\nProof. We start by noting that Imin (resp. Imax) is a total interpretation extending I and such that all the standard atoms which are undefined with respect to I are false with respect to Imin (resp. true with respect to Imax). Thus, we have (\u2217) Imin \u2264 I \u2264 Imax. If A is monotone and true with respect to Imin (resp. false with respect to Imax), then A is true (resp. false) with respect to I because of (\u2217). If A is antimonotone and true with respect to Imax (resp. false with respect to Imin), then A is true (resp. false) with respect to I because of (\u2217). We end the proof by observing that if A is true (resp. false) with respect to I, then A is true with respect to Imin and Imax by definition. \u2737\nWe are now ready to analyze the computational complexity of the well-founded semantics for LPAm,a programs. Our analysis will lead to prove the following fundamental property.\nProperty 5 The well-founded model for a ground LPAm,a program is efficiently (polynomialtime) computable.\nGiven Corollary 25, this property also follows from Theorem 7.4 in the work of Pelov et al. (2007). In the following, we will provide an alternative proof based on the concepts defined earlier in this paper, which also leads to several interesting intermediate results.\nProperty 5 is not trivial because aggregates may easily increase the complexity of the evaluation. Indeed, even deciding the truth of an aggregate with respect to a partial interpretation is intractable in general; a similar observation has already been made by Pelov (2004). However, this task is polynomial-time computable for the aggregate literals occurring in LPAm,a programs.\nProposition 19 Deciding whether a ground aggregate literal A is true (resp. false) with respect to a partial interpretation I is:\n(a) co-NP-complete in general;\n(b) polynomial-time computable if A is either a monotone or an antimonotone literal.\nProof. (a) As for the membership, we consider the complementary problem, that is, deciding whether a ground aggregate literal A is not true (resp. not false) with respect to a partial interpretation I, and prove that it belongs to NP. In order to show that A is not true (resp. not false) with respect to I it is enough to find a total interpretation J extending I (that is, J \u2287 I) such that A is false (resp. true) with respect to J . Thus, we can guess such a J and check the falsity (resp. truth) of A with respect to J in polynomial\ntime (if the aggregate function can be computed in polynomial time with respect to the size of the input multiset, as we are assuming).\nAs for the hardness, we first consider the problem of checking the truth of an aggregate and provide a polynomial-time reduction from TAUTOLOGY. The TAUTOLOGY problem is co-NP-complete and can be stated as follow: Given a proposition formula \u03a6 on variables X1, . . . , Xn, does each truth assignment v for the variables X1, . . . , Xn satisfy the formula \u03a6? Without loss of generality, we assume that \u03a6 is a 3-DNF formula of the form\n\u03a6 = D1 \u2228 \u00b7 \u00b7 \u00b7 \u2228Dm,\nwhere each disjunct Di is a conjunction \u2113 1 i \u2227 \u2113 2 i \u2227 \u2113 3 i , and each \u2113 j i is a positive or negative literal (note that, in the context of TAUTOLOGY, the term \u201cliteral\u201d denotes a variable Xk or a variable preceded by the negation symbol \u00ac). For a given \u03a6, we then consider a partial interpretation I = {\u22a4} and construct an aggregate literal A = #sum{S} \u2265 1, where S contains two groups of elements. The elements in the first group represent disjuncts of \u03a6 and are\n\u30081 : \u03b3(\u21131i ), \u03b3(\u2113 2 i ), \u03b3(\u2113 3 i )\u3009, i = 1, . . . ,m ,\nwhere, for each i = 1, . . . ,m and j = 1, . . . , 3, the propositional atom \u03b3(\u2113ji ) is defined as follows:\n\u03b3(\u2113ji ) =\n\n\n\nxtk if \u2113 j i is a positive literal Xk, for some k \u2208 {1, . . . , n}.\nx f k if \u2113 j i is a negative literal \u00acXk, for some k \u2208 {1, . . . , n}.\nThe elements in the second group represent variables of \u03a6 and are as follows:\n\n  \n  \n\u3008 1, xk : \u22a4\u3009 \u3008\u22121, xk : x t k\u3009 \u3008\u22121, xk : x f k\u3009 \u3008 1, x\u0302k : x t k, x f k\u3009 , k = 1, . . . , n ,\nwhere xk and x\u0302k are constants associated with the variable Xk. Note that, for each variable Xk of \u03a6, there are two atoms in A, x t k and x f k . Thus, for each interpretation J , four cases are possible:\n(1) {not xtk, not x f k} \u2286 J : In this case, only \u30081, xk : \u22a4\u3009 contribute to the evaluation of\nA, and its contribution is 1;\n(2) {xtk, x f k} \u2286 J : In this case, all the four elements contribute to the evaluation of A,\nand thus their contribution is 1\u2212 1+ 1 = 1 (note that \u3008\u22121, xk : x t k\u3009 and \u3008\u22121, xk : x f k\u3009 give a total contribution of \u22121 because of our pure set approach);\n(3) {xtk, not x f k} \u2286 J : In this case, only \u30081, xk : \u22a4\u3009 and \u3008\u22121, xk : x t k\u3009 contribute, giving\n1\u2212 1 = 0;\n(4) {not xtk, x f k} \u2286 J : In this case, only \u30081, xk : \u22a4\u3009 and \u3008\u22121, xk : x f k\u3009 contribute, giving\n1\u2212 1 = 0.\nThus, for each k \u2208 {1, . . . , n}, the total contribution of the four elements of S associated with the variable Xk is either 0 or 1. Note that also the total contribution of the other elements of S (i.e., those in the first group) is either 0 or 1. Therefore, if there is k \u2208 {1, . . . , n} such that either case (1) or (2) occurs, the interpretation J trivially satisfies A. Otherwise, J is such that, for each variable k \u2208 {1, . . . , n}, either (3) or (4) occurs. In this case, we say that J is a good interpretation.\nWe next define a one-to-one mapping between the set of assignments for \u03a6 and the set of good interpretations. Let v be an assignment for \u03a6. The good interpretation Iv associated with v is such that \u22a4 \u2208 Iv and\n\n\n\n{xtk, not x f k} \u2286 Iv if v(Xk) = 1\n{not xtk, x f k} \u2286 Iv if v(Xk) = 0\n, k = 1, . . . , n .\nWe want to show that v satisfies \u03a6 if and only if A is true with respect to Iv. Since Iv is a good interpretation, the elements of S in the second group give a total contribution of 0, and so we have just to consider the elements of S in the first group. These elements give a contribution of 1 if and only if {\u03b3(\u21131i ), \u03b3(\u2113 2 i ), \u03b3(\u2113 3 i )} \u2286 I holds for at least one i \u2208 {1, . . . , n}, and this holds if and only v(Di) = 1 holds for the disjunct Di. We can then conclude that A is true with respect to Iv if and only v(\u03a6) = 1.\nConcerning the check of falsity of an aggregate, we can start from a 3-DNF formula \u03a6 and construct an aggregate literal A\u2032 = #sum{S} < 1, where S is obtained as described above. Then \u03a6 is a tautology if and only if A\u2032 is false with respect to I = {\u22a4}.\n(b) Let I be a partial interpretation for an LPAm,a program P and A an aggregate literal occurring in P. We want to show that deciding whether A is true (resp. false) with respect to I can be done in polynomial-time in the size of BP . By Lemma 18, it is enough to evaluate the aggregate with respect to either Imin = I \u222a \u00ac.(BP \\ I) or Imax = I \u222a (BP \\ \u00ac.I). We then end the proof by observing that the interpretations Imin and Imax can be constructed in polynomial time, and that the value of the aggregate function in A can be computed in polynomial time with respect to the size of the input multiset by assumption. \u2737\nIn order to prove the tractability of the well-founded semantics we need an efficient method for computing the greatest unfounded set, which is part of the well-founded operator WP . Hence, we next give a polynomial-time construction of the set BP \\GUSP(I) by means of a monotone operator.\nDefinition 7 Let I be an interpretation for an LPAm,a program P. The operator \u03c6I : 2BP \u2192 2BP is defined as follows:\n\u03c6I(Y ) = {\u2113 \u2208 BP | \u2203 r \u2208 P with H(r) = \u2113 such that no (antimonotone) literal in Ba(r) is false with respect to I, and all the (monotone) literals in Bm(r) are true with respect to Y \\ \u00ac.I\u2212}\nThe least fixpoint of \u03c6I coincides with the greatest unfounded set of P with respect to I.\nTheorem 20 Let P be an LPAm,a program and I an interpretation for P. Then:\n1. The \u03c6I operator has a least fixpoint \u03c6 \u03c9 I (\u2205);\n2. GUSP(I) = BP \\ \u03c6 \u03c9 I (\u2205).\nProof. The \u03c6I operator is a monotonically increasing operator in the meet semilattice \u3008BP ,\u2286\u3009, and it therefore admits a least fixpoint \u03c6 \u03c9 I (\u2205) (Tarski, 1955). We next prove that GUSP(I) = BP \\ \u03c6 \u03c9 I (\u2205) in two steps:\n(\u2286) We first observe that \u03c6\u03c9I (\u2205) can be computed iteratively, starting from the empty set, as the limit of the sequence F0 = \u2205, Fi+1 = \u03c6I(Fi). Thus, we prove by induction on i that GUSP(I) \u2286 BP \\Fi holds. The base case is trivial, since F0 = \u2205 by definition and GUSP(I) is a subset of BP by Definition 1. We then assume GUSP(I) \u2286 BP \\ Fi in order to prove that GUSP(I) \u2286 BP \\Fi+1. Since GUSP(I) is an unfounded set for P with respect to I by Theorem 2, by Definition 1 we have that, for each \u2113 \u2208 GUSP(I) and for each rule r \u2208 P with H(r) = \u2113, either (1) some (antimonotone) literal in Ba(r) is false with respect to I, or (2) some (monotone) literal in Bm(r) is false with respect to I \u222a\u0307 \u00ac.GUSP(I). We want to show that such a \u2113 does not belong to Fi+1, that is, each rule r as above is such that either (i) some (antimonotone) literal in Ba(r) is false with respect to I, or (ii) some (monotone) literal in Bm(r) is not true with respect to Fi \\ \u00ac.I\n\u2212 (recall that Fi+1 = \u03c6I(Fi) by definition). Since (1) and (i) are equals, we have to show that (2) implies (ii). To this end, assume that there is a (monotone) literal \u2113\u2032 \u2208 Bm(r) which is false with respect to I \u222a\u0307 \u00ac.GUSP(I). Our aim is to show that \u2113\u2032 is false with respect to J = (Fi \\ \u00ac.I \u2212) \u222a \u00ac.(BP \\ (Fi \\ \u00ac.I \u2212)), since in this case \u2113\u2032 would be not true with respect to Fi \\ \u00ac.I \u2212 (see Lemma 18). We start by proving that (I \u222a\u0307 \u00ac.GUSP(I)) \u2212 = I\u2212 \u222a \u00ac.GUSP(I) is a subset of J\n\u2212. Observe that J\u2212 = \u00ac.(BP \\ (Fi \\ \u00ac.I \u2212)) = I\u2212 \u222a \u00ac.(BP \\ Fi) because \u00ac.I \u2212 is a subset of BP . Thus, since GUSP(I) \u2286 BP \\ Fi by induction hypothesis, we obtain (I \u222a\u0307 \u00ac.GUSP(I)) \u2212 = I\u2212 \u222a \u00ac.GUSP(I) \u2286 I \u2212 \u222a \u00ac.(BP \\ Fi) = J\n\u2212. Since J is total, (I \u222a\u0307 \u00ac.GUSP(I))\n\u2212 \u2286 J\u2212 implies that there is an extension K of I \u222a\u0307 \u00ac.GUSP(I) such that K\u2212 \u2286 J\u2212 and K+ \u2287 J\u2212 (for example, the one containing as true all the standard positive literals which are undefined with respect to I \u222a\u0307 \u00ac.GUSP(I)). Since \u2113\u2032 is false with respect to I \u222a\u0307 \u00ac.GUSP(I) by assumption and K is an extension of I \u222a\u0307 \u00ac.GUSP(I), \u2113\n\u2032 is false with respect to K by Remark 1. Thus, since J \u2264 K and \u2113\u2032 is monotone, the latter implies that \u2113\u2032 is false with respect to J as well.\n(\u2287) We prove that BP \\ \u03c6 \u03c9 I (\u2205) is an unfounded set for P with respect to I, that is, for\neach r \u2208 P with H(r) \u2208 BP \\\u03c6 \u03c9 I (\u2205), either (1) some (antimonotone) literal in B a(r) is false with respect to I, or (2) some (monotone) literal in Bm(r) is false with respect to I \u222a\u0307 \u00ac.(BP \\ \u03c6 \u03c9 I (\u2205)). By Definition 7, H(r) 6\u2208 \u03c6 \u03c9 I (\u2205) implies either that (i) some (antimonotone) literal in Ba(r) is false with respect to I, or that (ii) some (monotone) literal in Bm(r) is not true with respect to \u03c6\u03c9I (\u2205) \\ \u00ac.I\n\u2212. Since (i) and (1) are equals, we have to show that (ii) implies (2). To this end, assume that there is a (monotone) literal \u2113 \u2208 Bm(r) which is not true with respect to \u03c6\u03c9I (\u2205) \\ \u00ac.I\n\u2212. Thus, there is an extension of \u03c6\u03c9I (\u2205) \\ \u00ac.I\n\u2212 for which \u2113 is false, and in particular \u2113 must be false with respect to J = (\u03c6\u03c9I (\u2205) \\ \u00ac.I \u2212) \u222a \u00ac.(BP \\ (\u03c6 \u03c9 I (\u2205) \\ \u00ac.I\n\u2212)) because of Lemma 18. Now observe that (I \u222a\u0307 \u00ac.(BP \\ \u03c6 \u03c9 I (\u2205))) \u2212 = I\u2212\u222a\u00ac.(BP \\\u03c6 \u03c9 I (\u2205)) = \u00ac.(BP \\(\u03c6 \u03c9 I (\u2205)\\\u00ac.I \u2212)) =\nJ\u2212 holds (because \u00ac.I\u2212 \u2286 BP), and so (I \u222a\u0307 \u00ac.(BP \\ \u03c6 \u03c9 I (\u2205))) + \u2286 J+ because J is total. By combining the last two sentences we obtain I \u222a\u0307 \u00ac.(BP \\ \u03c6 \u03c9 I (\u2205)) \u2264 J . Therefore, since \u2113 is a monotone literal which is false with respect to J , the latter implies that \u2113 is false with respect to I \u222a\u0307 \u00ac.(BP \\ \u03c6 \u03c9 I (\u2205)) as well, and so (2) holds. \u2737\nEventually, Property 5 is a consequence of the following theorem. As mentioned earlier, this theorem also follows from Theorem 7.4 in the work of Pelov et al. (2007) because of Corollary 25, but the proof provided here differs considerably from the one of Theorem 7.4 in the work of Pelov et al.\nTheorem 21 Given an LPAm,a program P:\n1. The greatest unfounded set GUSP(I) of P with respect to a given interpretation I is polynomial-time computable;\n2. W\u03c9P(\u2205) is polynomial-time computable.\nProof. (1.) From Theorem 20, GUSP(I) = BP \\ \u03c6 \u03c9 I (\u2205). We next show that \u03c6 \u03c9 I (\u2205) is efficiently computable. The fixpoint \u03c6\u03c9I (\u2205) is the limit \u03c6\u03bb of the sequence \u03c60 = \u2205, \u03c6k = \u03c6I(\u03c6k\u22121). This limit is reached in a polynomial number of applications of \u03c6I because each new element of the sequence \u03c6k must add at least a new atom (otherwise the limit has been already reached), that is, \u03bb \u2264 |BP |. If we show that each application of \u03c6I is feasible in polynomial time, we can conclude that \u03c6\u03bb is computable in polynomial time. Each step processes at most all the rules once, and for each rule checks the truth-value of at most all body literals once. The check of the truth valuation is clearly tractable for all standard (i.e., non-aggregates) literals; the tractability of the check for aggregate literals stems from Proposition 19, as we deal with monotone and antimonotone aggregate atoms only. In conclusion, \u03c6\u03bb is computable in polynomial time, and GUSP(I) is tractable as well since it is obtainable as BP \\ \u03c6 \u03c9 I (\u2205).\n(2.) By the argumentation carried out for \u03c6\u03c9I (\u2205), we can show that W \u03c9 P(\u2205) is computed in a number of steps which is polynomial (actually linear) in |BP |. Indeed, each step is polynomial-time computable: We have just proved the tractability of GUSP(I), and TP is polynomial-time computable as well. \u2737\nThis result has a positive impact also for the computation of the answer set semantics of logic programs with aggregates. Indeed, as stated in Theorem 16, W\u03c9P(\u2205) approximates the intersection of all answer sets (if any) from the bottom, and can be therefore used to efficiently prune the search space. It is worthwhile noting that the computation of the well-founded semantics is also hard for polynomial-time. In particular, deciding whether a (ground) atom is true with respect to the well-founded semantics is P-complete, as this task is P-hard even for the standard well-founded semantics of aggregate-free programs (and, from Proposition 5, our semantics coincides with the standard well-founded on aggregatefree programs).\nWe end this section by briefly addressing the complexity of non-ground programs. When considering data-complexity (i.e., an LPAm,a program P is fixed and the input only consists of facts), the results are as for propositional programs: Deciding whether a (ground) atom is true with respect to the well-founded semantics of a non-ground program is P-complete,\nunder data-complexity (Van Gelder et al., 1991). However, if program complexity (i.e., an LPAm,a program P is given as input) is considered, complexity of reasoning rises exponentially. Indeed, a non-ground program P can be reduced, by naive instantiation, to a ground instance of the problem, and in general the size of Ground(P) is single exponential in the size of P. The complexity of reasoning increases accordingly by one exponential, from P to EXPTIME, and the result can be derived using complexity upgrading techniques (Eiter, Gottlob, & Mannila, 1997; Gottlob, Leone, & Veith, 1999)."}, {"heading": "6. Compilation into Standard LP, Implementation and Experimental", "text": "Results\nThe well-founded semantics for LPAm,a programs has been implemented by extending the DLV system (Leone et al., 2006). In this section we briefly describe the implemented prototype and report on the results of our experiments aimed at assessing its efficiency. Note that, even if LPAm,a programs can be replaced by equivalent LP programs (for a rewriting strategy see Section 6.1 below), our experimental results highlight a significant performance advantage of LPAm,a encodings."}, {"heading": "6.1 Compilation into Standard Logic Programming", "text": "In this section we briefly present a strategy for representing #count, #sum and #times with standard constructs.2 The compilation is in the spirit of the one introduced for #min and #max by Alviano, Faber, and Leone (2008) and defines a subprogram computing the value of a (possibly recursive) aggregate. The compilation takes into account specific properties of monotone and antimonotone aggregate functions, and is therefore referred to as monotone/antimonotone encoding (mae).\nThe monotone/antimonotone encoding of an LPAm,a program P is obtained by replacing each aggregate literal A = f(S) \u227a T by a new predicate symbol f\u227a. Predicate f\u227a is defined by means of a subprogram (i.e., a set of rules) that can be thought of as a compilation of A into standard LP. The compilation uses a total order < of the elements of UP \u222a{\u22a5}, where \u22a5 is a symbol not occurring in P and such that \u22a5 < u for each u \u2208 UP . We further assume the presence of a \u201cbuilt-in\u201d relation Y < Y \u2032, where Y = Y1, . . . , Yn and Y \u2032 = Y \u2032 1 , . . . , Y \u2032 n are lists of terms. This built-in relation has y < y\u2032 if and only if y precedes y\u2032 in the lexicographical order induced by <. Moreover, we will use a built-in relation Y \u2264 Y \u2032, where y \u2264 y\u2032 is true if and only if either y < y\u2032 or y = y\u2032. For simplicity, let us assume that A is of the form f({Y : p(Y , Z)}) \u227a k, where Y and Z are lists of local variables and k is an integer constant. For such an aggregate, we introduce a new predicate symbol faux of arity |Y |+ 1 and rules for modeling that an atom faux(y, s) must be true whenever the value of f({Y : p(Y , Z), Y \u2264 y}) is at least s. Thus, we use a fact for representing the value of the aggregate function for the empty set, and a rule for increasing this value for larger sets. The lexicographical order induced by < is used to guarantee that all elements in the set are\n2. Since we are considering only monotone and antimonotone aggregate literals, the domains of #sum and #times are assumed to be N and N+, respectively.\nconsidered at most once. In particular, the following rules are introduced:\nfaux(\u22a5, \u03b1). faux(Y \u2032, X) :\u2212 faux(Y , S), p(Y \u2032, Z),\nY < Y \u2032, X = \u03b2.\nwhere\n\n\n \u03b1 = 0, \u03b2 = S + 1 if f = #count; \u03b1 = 0, \u03b2 = S + Y \u20321 if f = #sum; \u03b1 = 1, \u03b2 = S \u00d7 Y \u20321 if f = #times.\nIf \u227a\u2208 {\u2265, >}, truth of an aggregate f({Y : p(Y , Z)}) \u227a k must be inferred if and only if some atom faux(y, s) such that s \u227a k is true. This aspect is modeled by means of the following rules:\nf\u2265k :\u2212 faux(Y , S), S \u2265 k. f>k :\u2212 faux(Y , S), S > k.\nIf \u227a is \u2264, instead, truth of an aggregate f({Y : p(Y , Z)}) \u2264 k must be inferred if and only if all atoms faux(y, s) such that s > k are false (and similar if \u227a is <). These aspects are modeled by means of the following rules:\nf\u2264k :\u2212 not f>k. f<k :\u2212 not f\u2265k.\nExtending the technique to aggregate literals with global variables is quite simple: Global variables are added to the arguments of all the atoms used in the compilation, and a new predicate fgroup\u2212by is used for collecting their possible substitutions."}, {"heading": "6.2 System Architecture and Usage", "text": "We have extended DLV by implementing the well-founded operator and the well-founded semantics for LPAm,a programs described in this paper. The architecture of the prototype is\nreported in Figure 2. In detail, we modified two modules of DLV, the Intelligent Grounding module and the Model Generator module. In our prototype, the well-founded semantics is adopted if one of -wf or --well-founded is specified on the command-line. Otherwise, the stable model semantics is adopted as usual. The well-founded operator WP introduced in Section 3 is used for both semantics. In particular, for the stable model semantics, the well-founded model is profitably used for pruning the search space. For the well-founded semantics, the well-founded model is printed after the computation of the least fixpoint of the well-founded operator. In this case the output of the system consists of two sets, for representing true and undefined standard atoms in the well-founded model. A binary of the prototype is available at http://www.dlvsystem.com/dlvRecAggr/."}, {"heading": "6.3 Experimental Results", "text": "To our knowledge, the implemented prototype is currently the only system supporting a well-founded semantics for logic programs with recursive aggregates. For certain special cases, such as when the well-founded model is total, the well-founded model coincides with other semantics such as answer sets (see Corollary 17) and in theses cases systems supporting those semantics such as IDP (Wittocx, Marie\u0308n, & Denecker, 2008), Smodels (Simons et al., 2002), or clasp (Gebser, Kaufmann, Neumann, & Schaub, 2007), can be used to compute the well-founded model.\nWe are however interested in systems that are able to compute the well-founded model for all input programs. One of the major systems supporting the well-founded semantics, XSB (Swift & Warren, 2010), has some support for aggregates, but (apart from #min and #max) XSB does not support recursive aggregates (i.e., aggregates occurring in recursive definitions). Therefore, our experiments have been designed for investigating the computational behavior of aggregate constructs with respect to equivalent encodings without aggregates.\nMore specifically, we introduce the Attacks problem, which is inspired by the classic Win-Lose problem often used in the context of the well-founded semantics for standard logic programs, and study performance on it.\nDefinition 8 (Attacks Problem) In the Attacks problem, a set of p players and a positive integer m are given. Each player attacks n other players. A player wins if no more than m winners attack it. This kind of problem is frequently present in turn-based strategy games.\nNote that the definition of winner is recursive and, in particular, a recursive aggregate is the natural way of encoding this problem.\nExample 14 An instance of the Attacks problem in which p = 6, n = 2 and m = 1 could be the following:\n\u2022 player a attacks players b and c;\n\u2022 player b attacks players a and c;\n\u2022 player c attacks players a and b;\n\u2022 player d attacks players b and f ;\n\u2022 player e attacks players c and f ;\n\u2022 player f attacks players d and e.\nA graphical representation of this instance is shown in Figure 3. Since d is only attacked by f , we can conclude that d is a winner. Similarly for e. Therefore, f is not a winner because f is attacked by d and e, which are winners. For the other players, namely a, b and c, we cannot determine who is a winner or not.\nIn our experiments, instances of Attacks are encoded by means of the predicates max, player and attacks for representing the parameter m, the set of players and the attacks of the players, respectively. We consider three equivalent encodings for the Attacks problem."}, {"heading": "6.3.1 Aggregate-Based Encoding", "text": "This encoding is a natural representation of the Attacks problem in LPAm,a. The complete encoding consists of a single rule, reported below:\nwin(X) :\u2212 max(M), player(X), #count{Y : attacks(Y,X), win(Y )} \u2264 M."}, {"heading": "6.3.2 Join-Based Encoding", "text": "An equivalent encoding can be obtained by computing a number of joins proportional to m. The tested encoding is reported below:\nwin(X) :\u2212 player(X), not lose(X). lose(X) :\u2212 max(1), attacks(Y1, X), win(Y1), attacks(Y2, X), win(Y2), Y1 < Y2. lose(X) :\u2212 max(2), attacks(Y1, X), win(Y1),\nattacks(Y2, X), win(Y2), Y1 < Y2, attacks(Y3, X), win(Y3), Y1 < Y3, Y2 < Y3.\nlose(X) :\u2212 max(3), . . .\nNote that in the encoding above there is a rule for each possible value of parameter m. However, only one of these rules is considered by our solver during program instantiation. In fact, only the rule is instantiated, which contains the instance of atom max(m) for which a fact is present. All the other rules are satisfied because of a false body literal."}, {"heading": "6.3.3 Mae-Based Encoding", "text": "This encoding has been obtained by applying the compilation presented in Section 6.1 with some minor simplifications. The full encoding is reported below:\nwin(X) :\u2212 player(X), not lose(X). lose(X) :\u2212 count(X,Y, S), max(M), S > M. count(X,Y, 1) :\u2212 aux(X,Y ). count(X,Y \u2032, S\u2032) :\u2212 count(X,Y, S), aux(X,Y \u2032), Y < Y \u2032, S\u2032 = S + 1. aux(X,Y ) :\u2212 attacks(Y,X), win(Y ).\nIntuitively, an atom count(x, y, s) stands for \u201cthere are at least s constants y\u2032 such that y\u2032 \u2264 y and attacks(y\u2032, x), win(y\u2032) is true\u201d. Note that the rules defining predicate count use the natural order of integers to guarantee that each y\u2032 is counted at most once.\nExample 15 The instance shown in Figure 3 is represented by means of the following facts:\nplayer(a). player(b). player(c). player(d). player(e). player(f). attacks(a, b). attacks(b, a). attacks(c, a). attacks(d, b). attacks(e, c). attacks(f, d). attacks(a, c). attacks(b, c). attacks(c, b). attacks(d, f). attacks(e, f). attacks(f, e). max(1).\nFor all the encodings, the well-founded model restricted to the win predicate is {win(d), win(e), not win(f)}. Note that win(a), win(b) and win(c) are neither true nor false, and so they are undefined."}, {"heading": "6.3.4 Discussion", "text": "We performed an intensive experimentation for this benchmark by varying the parameters p, m and n. For each combination of these parameters, we measured the average execution time of DLV and XSB (version 3.2) on 3 randomly generated instances. The experiments have been performed on a 3GHz Intel R\u00a9 Xeon R\u00a9 processor system with 4GB RAM under the Debian 4.0 operating system with GNU/Linux 2.6.23 kernel. The DLV prototype used has been compiled with GCC 4.4.1. For every instance, we have allowed a maximum running time of 600 seconds (10 minutes) and a maximum memory usage of 3GB.\nThe results of our experimentation are reported in Figures 4\u20137. In the graphs, DLVA is the implemented prototype with the aggregate-based encoding, DLV-join and DLV-mae the implemented prototype with the aggregate-free encodings, XSB-join and XSB-mae the XSB system with the aggregate-free encodings (as mentioned earlier, XSB does not support\nrecursive aggregates). For the XSB system, we explicitly set indices and tabled predicates for optimizing its computation.\nFor each graph, the number of players is fixed, while parameters m (x-axis) and n (y-axis) vary. Therefore, the size of the instances grows moving from left to right along the y-axis, while it is invariant with respect to the x-axis. However, the number of joins required by the join-based encoding depends on the parameter m. As a matter of fact, we can observe in the graphs in Figures 4\u20135 that the average execution time of the join-based encoding increases along both the x- and y-axis (for both DLV and XSB). Instead, for the encoding using aggregates, and for the mae-based encoding, the average execution time only depends on instance sizes, as shown in the graphs in Figures 6\u20137.\nFor the join-based encoding, XSB is generally faster than DLV, but consumes much more memory. Indeed, in Figure 5, we can observe that XSB terminates its computation in a few seconds for the smallest instances, but rapidly runs out of memory on slightly larger instances. Considering the mae-based encoding, we can observe significant performance gains for both DLV and XSB (see Figures 6\u20137). Indeed, both systems complete their computation in the allowed time and memory on larger instances. Computational advantages of the mae-based encoding with respect to the join-based encoding are particularly evident\nfor XSB, which solved all tested instances with this encoding. However, also XSB with the mae-based encoding is outperformed by DLV with native support for aggregate constructs (see Figure 7).\nIn sum, the experimental results highlight that the presence of aggregate constructs can significantly speed-up the computation. Indeed, the encoding using recursive aggregates outperforms the aggregate-free encodings in all tested instances."}, {"heading": "7. Related Work", "text": "Defining a well-founded semantics for logic programs with aggregates has been a challenge of major interest in the last years. The first attempts, not relying on a notion of unfounded set, have been defined on a restricted language. Some of these are discussed by Kemp and Stuckey (1991). Another semantics falling in this class is the one introduced by Van Gelder (1992), subsequently generalized by Osorio and Jayaraman (1999). The main problem of these semantics is that they often leave too many undefined literals, as shown by Ross and Sagiv (1997).\nA first attempt to define a well-founded semantics for unrestricted LPA has been done by Kemp and Stuckey (1991). This semantics is based on a notion of unfounded sets. According to Kemp and Stuckey, a set X of standard atoms is an unfounded set for a (ground) program P with respect to an interpretation I if, for each rule r \u2208 P with H(r) \u2208 X , either (a) some literal in B(r) is false with respect to I, or (b) B(r) \u2229 X 6= \u2205. Note that only standard literals are considered by condition (b), and aggregates are not covered by it. We point out that this definition of unfounded set makes the semantics inadequate for programs with recursive aggregates, even if only monotone aggregates are considered. For example, for the program {a(1):\u2212#count{X : a(X)} > 0.}, the well-founded model in the work of Kemp and Stuckey is \u2205, while a reasonable well-founded semantics should identify a(1) as false.\nPelov et al. (2007) defined a well-founded semantics based on approximating operators, namely D\u0303-well-founded semantics, which extends the standard well-founded semantics; indeed, they coincide for aggregate-free programs. More in detail, in that work aggregates are evaluated in one of three possible ways. Therefore, a family of semantics is defined by Pelov et al., which can be ordered by precision: More precise three-valued aggregates lead to more precise semantics. In general, higher precision comes at the price of a higher computational complexity. The authors discuss the following three-valued aggregate relations for the evaluation of aggregate literals: trivial, bound and ultimate approximating aggregates, where the first is the less precise, and the last is the most precise. Semantics relying on trivial approximating aggregates is very imprecise, but it is still suitable for the class of stratified aggregate programs. Both trivial and bound approximations have polynomial complexity, while ultimate has been shown to be intractable for nonmonotone aggregate functions (Pelov, 2004). A detailed comparison with our results is presented in Section 7.1.\nFerraris (2005) showed that the semantics of Smodels programs with positive weight constraints is equal to answer sets as defined by Faber et al. (2004) on the respective fragment. Since by Theorem 16 W\u03c9P(\u2205) approximates answer sets as defined by Faber et al., W\u03c9P(\u2205) can be used also as an approximating operator for the respective Smodels programs. Indeed, it can be shown that the AtMost pruning operator of Smodels (Simons et al., 2002) is a special case of the \u03c6I operator (defined in the proof of Theorem 21).\nOther works attempted to define stronger notions of well-founded semantics (also for programs with aggregates), like the Ultimate Well-Founded Semantics (Denecker et al., 2001), or WFS1 and WFS2 (Dix & Osorio, 1997). Whether a characterization of these semantics in terms of unfounded sets can exist for these semantics is unclear and left for future research.\nConcerning compilations of LPA programs into standard LP, a transformation was provided by Van Gelder (1992). The compilation that we presented in Section 6.1 differs from the one introduced by Van Gelder in several respects. Our approach uses a total order of the universe of the input program and takes advantage of the character of monotonicity/antimonotonicity of the aggregate literals in the input program, while the transformation defined by Van Gelder uses uninterpreted function symbols for representing ground sets, and recursive negation for checking truth of aggregate literals. We briefly discuss these aspects in the following. Roughly, for an aggregate f(S) \u227a k, uninterpreted function symbols are used by the transformation in the work of Van Gelder for determining all pairs S\u2032, k\u2032 such that S\u2032 is a ground set associated with S and k\u2032 = f(S\u2032). After that, the transformation defined by Van Gelder checks whether there exists a pair S\u2032, k\u2032 satisfying the following\nconditions: (i) for every element \u3008consts : conj\u3009 in S\u2032, conj is true; (ii) k\u2032 \u227a k holds. We point out that Condition (i) requires recursive negation in order to be checked. Indeed, it is equivalent to \u201cthere is no element \u3008consts : conj\u3009 in S\u2032 such that conj is not true.\u201d This aspect of the transformation has an undesirable side effect: Stratified LPAm,a programs may have partial well-founded models, that is, Theorem 9 does not hold for programs compiled with the transformation introduced by Van Gelder. An example of this side effect is given by Van Gelder, where it is shown that this transformation possibly leads to partial well-founded models for instances of Company Controls, a well-known problem that can be modeled by using monotone recursive aggregates."}, {"heading": "7.1 Comparison with the work of Pelov et al. (2007)", "text": "In this section we report a detailed comparison of the well-founded semantics as defined in this paper with the one of Pelov et al. (2007). We recall that Pelov et al. defines wellfounded and stable semantics as the least and total fixpoints of the three-valued stable model operator extended to aggregate programs.\nWe start by observing that the evaluation of ultimate approximating aggregates coincides with the evaluation of aggregates defined in this article; also the evaluation of bound approximating aggregates coincides for monotone and antimonotone aggregates (as a consequence of Lemma 18 in this paper and Proposition 7.16 in the work of Pelov et al., 2007).\nLet us now introduce a translation of an aggregate literal into a formula of standard literals. For a (partial) interpretation I, let conj(I) denote the conjunction of all the literals in I. The translation trm(A) of a ground aggregate literal A is defined as follows:\ntrm(A) = \u2228\n{conj(I) | I is a subset-minimal interpretation such that A is true with respect to I}\nNote that, for each (partial) interpretation J , the evaluation of A with respect to J coincides with the evaluation of trm(A) with respect to J (Proposition 2 and Proposition 3 in the work of Pelov et al., 2003). Moreover, for a monotone (resp. antimonotone) aggregate literal A, only positive (resp. negative) literals appear in trm(A).\nFor a rule r in a ground LPAm,a program P and an aggregate literal A \u2208 B(r), the translation trm(P, r, A) of A in r is the program obtained from P by removing r and by adding a rule r\u2032 such that H(r\u2032) = H(r) and B(r\u2032) = B(r) \\ {A} \u222a conj, for each conj \u2208 trm(A). Therefore, the full translation trm(P) of P is defined as the recursive application of trm(P, r, A) (note that the order in which rules and aggregates are processed is not relevant). We next show that P and trm(P) have the same unfounded sets.\nLemma 22 A set of atoms X is an unfounded set for a program P with respect to an interpretation I if and only if X is an unfounded set for trm(P) with respect to I.\nProof. We use induction on the number of aggregate literals in P. If P has no aggregate literals, then P = trm(P). Now consider a program P and a rule r \u2208 P with an aggregate literal A in B(r). We want to show that a set X of atoms is an unfounded set for P with respect to I if and only if X is an unfounded set for trm(P, r, A) with respect to I, since in this case we might apply the induction hypothesis and prove the claim. Thus, we can end the proof by means of the following observations: (i) A is false with respect to an\ninterpretation J if and only if trm(A) is false with respect to J , that is, if and only if for each conjunction conj \u2208 trm(A) there is a literal \u2113 \u2208 conj such that \u2113 is false with respect to J ; (ii) such an \u2113 is a positive (resp. negative) standard literal if and only if A is monotone (resp. antimonotone). \u2737\nWe can then prove that the well-founded operators of P and trm(P) coincide.\nLemma 23 Let P be an LPAm,a program and I an interpretation for P. Then WP(I) = Wtrm(P)(I).\nProof. We have to show that (1) TP(I) = Ttrm(P)(I) and (2) GUSP(I) = GUStrm(P)(I). We note that (2) immediately follows from Lemma 22. In order to prove (1), we consider an aggregate literal A occurring in P. By previous considerations, we have that A is true with respect to I if and only if there is a conjunct in trm(A) which is true with respect to I. Thus, (1) holds. \u2737\nWe are now ready to relate our well-founded operator with the one provided by Pelov et al. (2007).\nTheorem 24 For the class of LPAm,a programs, the well-founded operator herein defined coincides with the one of Pelov et al. (2007; for both the ultimate and bound approximating aggregate semantics).3\nProof. By Lemma 23, we already know that WP(I) = Wtrm(P)(I). We also have that Wtrm(P)(I) coincides with the one in the work of Van Gelder et al. (1991) by Theorem 1 (since trm(P) is a standard logic program). On the other hand, for both the ultimate and bound approximating aggregate semantics, the well-founded operators (as defined in Pelov et al., 2007) of P and trm(P) coincide: This is a consequence of Theorem 1 in the work of Pelov et al. (2003), because the three-valued immediate consequence operators in the work of Pelov et al. (2003) and Pelov et al. (2007) coincide (see Definition 7 in Pelov et al., 2003 and Definition 7.5 in Pelov et al., 2007). Moreover, the well-founded operator of Pelov et al. (2007) coincides with the one in the work of Van Gelder et al. for standard logic programs, thereby obtaining the equality of the operators. \u2737\nThe correspondence of the two well-founded semantics immediately follows from the theorem above. Indeed, the two well-founded models are defined as the fixpoints of the respective well-founded operators.\nCorollary 25 The well-founded model herein defined and the one of Pelov et al. (2007; for both the ultimate and bound approximating aggregate semantics) coincide for LPAm,a programs.\nAs mentioned also earlier, by virtue of the above theorem and corollary, some of the results presented in this paper also follow from earlier results in the literature. In particular, Theorem 9, Theorem 16 and some of our complexity results follow from definitions and results of Pelov (2004) and Pelov et al. (2007).\n3. Note that this operator is referred to as stable revision operator by Pelov et al. (2007)."}, {"heading": "8. Conclusion", "text": "In this paper we introduced a new notion of unfounded set for LPAm,a programs and analyzed a well-founded semantics for this language based on this notion. This semantics generalizes the traditional well-founded semantics for aggregate-free programs and also coincides with well-founded semantics for aggregate programs as defined by Pelov et al. (2007; the latter not being defined by means of a notion of unfounded set). We could also show that this semantics and its main operator WP have close ties with answer sets as defined by Faber et al. (2004, 2011), and can hence serve as approximations.\nWe proved that computing this semantics is a tractable problem. Indeed, the semantics is given by the least fixpoint of the well-founded operatorWP . The fixpoint is reached after a polynomial number of applications of the operator WP (with respect to the size of the input program), each of them requiring polynomial time. For showing that an application of WP is polynomial-time feasible, we have proved that evaluating monotone and antimonotone aggregate literals remains polynomial-time computable also for partial interpretations, since in this case only one of the possibly exponential extensions must be checked. For a monotone aggregate literal, this extension is obtained by falsifying each undefined literal, while for an antimonotone aggregate literal, each undefined literal is taken as true in the extension.\nMotivated by these positive theoretical results, we have implemented the first system supporting a well-founded semantics for unrestricted LPAm,a. Allowing for using monotone and antimonotone aggregate literals, the implemented prototype is ready for experimenting with the LPAm,a framework. The experiments conducted on the Attacks benchmark highlight the computational gains of a native implementation of aggregate constructs with respect to equivalent encodings in standard LP."}, {"heading": "Acknowledgments", "text": "Partly supported by Regione Calabria and EU under POR Calabria FESR 2007-2013 within the PIA project of DLVSYSTEM s.r.l., and by MIUR under the PRIN project LoDeN and under the PON project FRAME proposed by Atos Italia S.p.a.; we also thank the anonymous reviewers for their valuable comments."}], "references": [{"title": "Compiling minimum and maximum aggregates into standard ASP", "author": ["M. Alviano", "W. Faber", "N. Leone"], "venue": "Proceedings of the 23rd Italian Conference on Computational Logic (CILC", "citeRegEx": "Alviano et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Alviano et al\\.", "year": 2008}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press.", "citeRegEx": "Baral,? 2003", "shortCiteRegEx": "Baral", "year": 2003}, {"title": "Well-Founded Semantics for Extended Logic Programs with Dynamic Preferences", "author": ["G. Brewka"], "venue": "Journal of Artificial Intelligence Research, 4, 19\u201336.", "citeRegEx": "Brewka,? 1996", "shortCiteRegEx": "Brewka", "year": 1996}, {"title": "Declarative and Computational Properties of Logic Programs with Aggregates", "author": ["F. Calimeri", "W. Faber", "N. Leone", "S. Perri"], "venue": "In Nineteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Calimeri et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2005}, {"title": "Aggregate Functions in DLV", "author": ["T. Dell\u2019Armi", "W. Faber", "G. Ielpa", "N. Leone", "G. Pfeifer"], "venue": "Proceedings ASP03 - Answer Set Programming: Advances in Theory and Implementation,", "citeRegEx": "Dell.Armi et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Dell.Armi et al\\.", "year": 2003}, {"title": "Ultimate Well-Founded and Stable Model Semantics for Logic Programs with Aggregates", "author": ["M. Denecker", "N. Pelov", "M. Bruynooghe"], "venue": "Proceedings of the 17th International Conference on Logic Programming,", "citeRegEx": "Denecker et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Denecker et al\\.", "year": 2001}, {"title": "On Well-Behaved Semantics Suitable for Aggregation", "author": ["J. Dix", "M. Osorio"], "venue": "In Proceedings of the International Logic Programming Symposium (ILPS \u201997),", "citeRegEx": "Dix and Osorio,? \\Q1997\\E", "shortCiteRegEx": "Dix and Osorio", "year": 1997}, {"title": "Unfounded Sets for Disjunctive Logic Programs with Arbitrary Aggregates", "author": ["W. Faber"], "venue": "Baral, C., Greco, G., Leone, N., & Terracina, G. (Eds.), Logic Programming and Nonmonotonic Reasoning \u2014 8th International Conference, LPNMR\u201905, Diamante, Italy, September 2005, Proceedings, Vol. 3662 of Lecture Notes in Computer Science, pp. 40\u201352. Springer Verlag.", "citeRegEx": "Faber,? 2005", "shortCiteRegEx": "Faber", "year": 2005}, {"title": "Recursive aggregates in disjunctive logic programs: Semantics and complexity", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Proceedings of the 9th European Conference on Artificial Intelligence (JELIA 2004),", "citeRegEx": "Faber et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Faber et al\\.", "year": 2004}, {"title": "Semantics and complexity of recursive aggregates in answer set programming", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Artificial Intelligence,", "citeRegEx": "Faber et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Faber et al\\.", "year": 2011}, {"title": "Answer Sets for Propositional Theories", "author": ["P. Ferraris"], "venue": "Baral, C., Greco, G., Leone, N., & Terracina, G. (Eds.), Logic Programming and Nonmonotonic Reasoning \u2014 8th International Conference, LPNMR\u201905, Diamante, Italy, September 2005, Proceedings, Vol. 3662 of Lecture Notes in Computer Science, pp. 119\u2013131. Springer Verlag.", "citeRegEx": "Ferraris,? 2005", "shortCiteRegEx": "Ferraris", "year": 2005}, {"title": "Logic programs with propositional connectives and aggregates", "author": ["P. Ferraris"], "venue": "ACM Transactions on Computational Logic, 12 (4). In press.", "citeRegEx": "Ferraris,? 2011", "shortCiteRegEx": "Ferraris", "year": 2011}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "In Twentieth International Joint Conference on Artificial Intelligence", "citeRegEx": "Gebser et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Representing Knowledge in A-Prolog", "author": ["M. Gelfond"], "venue": "Kakas, A. C., & Sadri, F. (Eds.), Computational Logic. Logic Programming and Beyond, Vol. 2408 of LNCS, pp. 413\u2013451. Springer.", "citeRegEx": "Gelfond,? 2002", "shortCiteRegEx": "Gelfond", "year": 2002}, {"title": "Classical Negation in Logic Programs and Disjunctive Databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1991\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Succinctness as a Source of Expression Complexity", "author": ["G. Gottlob", "N. Leone", "H. Veith"], "venue": "Annals of Pure and Applied Logic,", "citeRegEx": "Gottlob et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Gottlob et al\\.", "year": 1999}, {"title": "Semantics of Logic Programs with Aggregates", "author": ["D.B. Kemp", "P.J. Stuckey"], "venue": "Proceedings of the International Symposium on Logic Programming", "citeRegEx": "Kemp and Stuckey,? \\Q1991\\E", "shortCiteRegEx": "Kemp and Stuckey", "year": 1991}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Leone et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Logic programs with abstract constraint atoms: The role of computations", "author": ["L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczynski"], "venue": "Artificial Intelligence,", "citeRegEx": "Liu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2010}, {"title": "Properties and applications of programs with monotone and convex constraints", "author": ["L. Liu", "M. Truszczy\u0144ski"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Liu and Truszczy\u0144ski,? \\Q2006\\E", "shortCiteRegEx": "Liu and Truszczy\u0144ski", "year": 2006}, {"title": "The HiLeX System for Semantic Information Extraction. Transactions on Large-Scale Data and KnowledgeCentered Systems", "author": ["M. Manna", "M. Ruffolo", "E. Oro", "M. Alviano", "N. Leone"], "venue": null, "citeRegEx": "Manna et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Manna et al\\.", "year": 2011}, {"title": "Consistent Query Answering via ASP from Different Perspectives: Theory and Practice", "author": ["M. Manna", "F. Ricca", "G. Terracina"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Manna et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Manna et al\\.", "year": 2011}, {"title": "Logic programs with abstract constraint atoms", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "In Proceedings of the Nineteenth National Conference on Artificial Intelligence (AAAI", "citeRegEx": "Marek and Truszczy\u0144ski,? \\Q2004\\E", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 2004}, {"title": "Programs with Common Sense", "author": ["J. McCarthy"], "venue": "Proceedings of the Teddington Conference on the Mechanization of Thought Processes, pp. 75\u201391. Her Majesty\u2019s Stationery Office.", "citeRegEx": "McCarthy,? 1959", "shortCiteRegEx": "McCarthy", "year": 1959}, {"title": "Circumscription \u2014 a Form of Non-Monotonic Reasoning", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 13 (1\u20132), 27\u201339.", "citeRegEx": "McCarthy,? 1980", "shortCiteRegEx": "McCarthy", "year": 1980}, {"title": "Applications of Circumscription to Formalizing Common-Sense Knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 28 (1), 89\u2013116.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Formalization of Common Sense, papers by John McCarthy edited by V", "author": ["J. McCarthy"], "venue": "Lifschitz. Ablex.", "citeRegEx": "McCarthy,? 1990", "shortCiteRegEx": "McCarthy", "year": 1990}, {"title": "Some Philosophical Problems from the Standpoint of Artificial Intelligence", "author": ["J. McCarthy", "P.J. Hayes"], "venue": "Machine Intelligence", "citeRegEx": "McCarthy and Hayes,? \\Q1969\\E", "shortCiteRegEx": "McCarthy and Hayes", "year": 1969}, {"title": "Non-Monotonic Logic II: Nonmonotonic Modal Theories", "author": ["D.V. McDermott"], "venue": "Journal of the ACM, 29 (1), 33\u201357.", "citeRegEx": "McDermott,? 1982", "shortCiteRegEx": "McDermott", "year": 1982}, {"title": "Non-Monotonic Logic I", "author": ["D.V. McDermott", "J. Doyle"], "venue": "Artificial Intelligence,", "citeRegEx": "McDermott and Doyle,? \\Q1980\\E", "shortCiteRegEx": "McDermott and Doyle", "year": 1980}, {"title": "A Framework for Representing Knowledge", "author": ["M. Minsky"], "venue": "Winston, P. H. (Ed.), The Psychology of Computer Vision, pp. 211\u2013277. McGraw-Hill.", "citeRegEx": "Minsky,? 1975", "shortCiteRegEx": "Minsky", "year": 1975}, {"title": "Semantical Considerations on Nonmonotonic Logic", "author": ["R.C. Moore"], "venue": "Artificial Intelligence, 25 (1), 75\u201394.", "citeRegEx": "Moore,? 1985", "shortCiteRegEx": "Moore", "year": 1985}, {"title": "Aggregation and Negation-As-Failure", "author": ["M. Osorio", "B. Jayaraman"], "venue": "New Generation Computing,", "citeRegEx": "Osorio and Jayaraman,? \\Q1999\\E", "shortCiteRegEx": "Osorio and Jayaraman", "year": 1999}, {"title": "Semantics of Logic Programs with Aggregates", "author": ["N. Pelov"], "venue": "Ph.D. thesis, Katholieke Universiteit Leuven, Leuven, Belgium.", "citeRegEx": "Pelov,? 2004", "shortCiteRegEx": "Pelov", "year": 2004}, {"title": "Translation of Aggregate Programs to Normal Logic Programs", "author": ["N. Pelov", "M. Denecker", "M. Bruynooghe"], "venue": "Proceedings ASP03 - Answer Set Programming: Advances in Theory and Implementation,", "citeRegEx": "Pelov et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Pelov et al\\.", "year": 2003}, {"title": "Partial stable models for logic programs with aggregates", "author": ["N. Pelov", "M. Denecker", "M. Bruynooghe"], "venue": "In Proceedings of the 7th International Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR-7),", "citeRegEx": "Pelov et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Pelov et al\\.", "year": 2004}, {"title": "Well-founded and Stable Semantics of Logic Programs with Aggregates", "author": ["N. Pelov", "M. Denecker", "M. Bruynooghe"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Pelov et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Pelov et al\\.", "year": 2007}, {"title": "Semantics of disjunctive programs with monotone aggregates - an operator-based approach", "author": ["N. Pelov", "M. Truszczy\u0144ski"], "venue": "In Proceedings of the 10th International Workshop on Non-monotonic Reasoning (NMR", "citeRegEx": "Pelov and Truszczy\u0144ski,? \\Q2004\\E", "shortCiteRegEx": "Pelov and Truszczy\u0144ski", "year": 2004}, {"title": "A Logic for Default Reasoning", "author": ["R. Reiter"], "venue": "Artificial Intelligence, 13 (1\u20132), 81\u2013132.", "citeRegEx": "Reiter,? 1980", "shortCiteRegEx": "Reiter", "year": 1980}, {"title": "A Logic-Based System for e-Tourism", "author": ["F. Ricca", "M. Alviano", "A. Dimasi", "G. Grasso", "S.M. Ielpa", "S. Iiritano", "M. Manna", "N. Leone"], "venue": "Fundamenta Informaticae. IOS Press,", "citeRegEx": "Ricca et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Ricca et al\\.", "year": 2010}, {"title": "Team-building with Answer Set Programming in the Gioia-Tauro Seaport. Theory and Practice of Logic Programming", "author": ["F. Ricca", "G. Grasso", "M. Alviano", "M. Manna", "V. Lio", "S. Iiritano", "N. Leone"], "venue": null, "citeRegEx": "Ricca et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ricca et al\\.", "year": 2011}, {"title": "Monotonic Aggregation in Deductive Databases", "author": ["K.A. Ross", "Y. Sagiv"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Ross and Sagiv,? \\Q1997\\E", "shortCiteRegEx": "Ross and Sagiv", "year": 1997}, {"title": "Extending and Implementing the Stable Model Semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "Simons et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Simons et al\\.", "year": 2002}, {"title": "A Constructive semantic characterization of aggregates in answer set programming", "author": ["T.C. Son", "E. Pontelli"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Son and Pontelli,? \\Q2007\\E", "shortCiteRegEx": "Son and Pontelli", "year": 2007}, {"title": "Answer Sets for Logic Programs with Arbitrary Abstract Constraint Atoms", "author": ["T.C. Son", "E. Pontelli", "P.H. Tu"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Son et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Son et al\\.", "year": 2007}, {"title": "XSB: Extending prolog with tabled logic programming", "author": ["T. Swift", "D.S. Warren"], "venue": "Computing Research Repository (CoRR),", "citeRegEx": "Swift and Warren,? \\Q2010\\E", "shortCiteRegEx": "Swift and Warren", "year": 2010}, {"title": "A lattice-theoretical fixpoint theorem and its applications", "author": ["A. Tarski"], "venue": "Pacific J. Math, 5, 285\u2013309.", "citeRegEx": "Tarski,? 1955", "shortCiteRegEx": "Tarski", "year": 1955}, {"title": "Reducts of propositional theories, satisfiability relations, and generalizations of semantics of logic programs", "author": ["M. Truszczy\u0144ski"], "venue": "Artificial Intelligence, 174, 1285\u20131306.", "citeRegEx": "Truszczy\u0144ski,? 2010", "shortCiteRegEx": "Truszczy\u0144ski", "year": 2010}, {"title": "Principles of Database and Knowledge Base Systems", "author": ["J.D. Ullman"], "venue": "Computer Science Press.", "citeRegEx": "Ullman,? 1989", "shortCiteRegEx": "Ullman", "year": 1989}, {"title": "The Well-Founded Semantics of Aggregation", "author": ["A. Van Gelder"], "venue": "Proceedings of the Eleventh Symposium on Principles of Database Systems (PODS\u201992), pp. 127\u2013138. ACM Press.", "citeRegEx": "Gelder,? 1992", "shortCiteRegEx": "Gelder", "year": 1992}, {"title": "The Well-Founded Semantics for General Logic Programs", "author": ["A. Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "Journal of the ACM,", "citeRegEx": "Gelder et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "The IDP system: A model expansion system for an extension of classical logic", "author": ["J. Wittocx", "M. Mari\u00ebn", "M. Denecker"], "venue": "Proceedings of the 2nd Workshop on Logic and Search, Computation of Structures from Declarative Descriptions", "citeRegEx": "Wittocx et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wittocx et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 30, "context": "However, it was soon realized that the monotonic nature of classical logic (the addition of new knowledge may only increase the set of consequences of a theory in classical logic) is not always suited to model commonsense reasoning, which sometimes is intrinsically nonmonotonic (Minsky, 1975).", "startOffset": 279, "endOffset": 293}, {"referenceID": 23, "context": "The use of logical formulas as a basis for a knowledge representation language was proposed about 50 years ago in some seminal works of McCarthy (1959), and McCarthy and Hayes (1969).", "startOffset": 136, "endOffset": 152}, {"referenceID": 23, "context": "The use of logical formulas as a basis for a knowledge representation language was proposed about 50 years ago in some seminal works of McCarthy (1959), and McCarthy and Hayes (1969). However, it was soon realized that the monotonic nature of classical logic (the addition of new knowledge may only increase the set of consequences of a theory in classical logic) is not always suited to model commonsense reasoning, which sometimes is intrinsically nonmonotonic (Minsky, 1975).", "startOffset": 136, "endOffset": 183}, {"referenceID": 38, "context": "The most popular nonmonotonic logics are circumscription (McCarthy, 1980, 1986), default logic (Reiter, 1980), and nonmonotonic modal logics (McDermott & Doyle, 1980; McDermott, 1982; Moore, 1985).", "startOffset": 95, "endOffset": 109}, {"referenceID": 28, "context": "The most popular nonmonotonic logics are circumscription (McCarthy, 1980, 1986), default logic (Reiter, 1980), and nonmonotonic modal logics (McDermott & Doyle, 1980; McDermott, 1982; Moore, 1985).", "startOffset": 141, "endOffset": 196}, {"referenceID": 31, "context": "The most popular nonmonotonic logics are circumscription (McCarthy, 1980, 1986), default logic (Reiter, 1980), and nonmonotonic modal logics (McDermott & Doyle, 1980; McDermott, 1982; Moore, 1985).", "startOffset": 141, "endOffset": 196}, {"referenceID": 13, "context": "For addressing this insufficiency, several extensions of LP have been proposed, the most relevant of which is the introduction of aggregate functions (LP; Kemp & Stuckey, 1991; Denecker, Pelov, & Bruynooghe, 2001; Dix & Osorio, 1997; Gelfond, 2002; Simons, Niemel\u00e4, & Soininen, 2002; Dell\u2019Armi, Faber, Ielpa, Leone, & Pfeifer, 2003; Pelov & Truszczy\u0144ski, 2004; Pelov, Denecker, & Bruynooghe, 2004).", "startOffset": 150, "endOffset": 397}, {"referenceID": 33, "context": ", aggregation in which aggregated data depend on the evaluation of the aggregate itself) are particularly interesting, as the definition of their semantics is not straightforward (Pelov, 2004; Faber, Leone, & Pfeifer, 2004; Son & Pontelli, 2007; Liu, Pontelli, Son, & Truszczynski, 2010).", "startOffset": 179, "endOffset": 287}, {"referenceID": 47, "context": "Note that a similar construct, referred to as abstract constraint, has been introduced in the literature (Marek & Truszczy\u0144ski, 2004; Liu & Truszczy\u0144ski, 2006; Son, Pontelli, & Tu, 2007; Truszczy\u0144ski, 2010; Brewka, 1996).", "startOffset": 105, "endOffset": 220}, {"referenceID": 2, "context": "Note that a similar construct, referred to as abstract constraint, has been introduced in the literature (Marek & Truszczy\u0144ski, 2004; Liu & Truszczy\u0144ski, 2006; Son, Pontelli, & Tu, 2007; Truszczy\u0144ski, 2010; Brewka, 1996).", "startOffset": 105, "endOffset": 220}, {"referenceID": 32, "context": "Actually it turns out that the well-founded semantics thus obtained coincides (on LPm,a programs) with a well-founded semantics proposed by Pelov, Denecker, and Bruynooghe (2007). Pelov et al.", "startOffset": 140, "endOffset": 179}, {"referenceID": 33, "context": "We also show that the operator is equivalent to an operator defined by Pelov et al. (2007).", "startOffset": 71, "endOffset": 91}, {"referenceID": 33, "context": "\u2022 We analyze the complexity of the well-founded semantics, confirming and extending results in the work of Pelov et al. (2007). Importantly, it turns out that W P(\u2205) is polynomial-time computable for propositional LPm,a programs.", "startOffset": 107, "endOffset": 127}, {"referenceID": 1, "context": "For additional background on standard LP, we refer to the literature (Gelfond & Lifschitz, 1991; Baral, 2003).", "startOffset": 69, "endOffset": 109}, {"referenceID": 48, "context": "Note that condition (i) is the standard safety condition adopted in LP to guarantee that the variables are range restricted (Ullman, 1989), while condition (ii) is specific for aggregates.", "startOffset": 124, "endOffset": 138}, {"referenceID": 49, "context": "Unfounded Sets and Well-Founded Semantics In this section we introduce a new notion of unfounded set for LPm,a programs, which extends the original definition for aggregate-free programs introduced by Van Gelder et al. (1991). Unfounded sets are then used for extending the well-founded semantics, originally defined for aggregate-free programs by Van Gelder et al.", "startOffset": 205, "endOffset": 226}, {"referenceID": 49, "context": "As formalized below, Definition 1 generalizes the one given by Van Gelder et al. (1991) for aggregate-free programs: A set of standard atoms X \u2286 BP is an unfounded set for a program P with respect to an interpretation I if and only if, for each rule r \u2208 P such that H(r) \u2208 X , either (i) B(r) \u2229 \u00ac.", "startOffset": 67, "endOffset": 88}, {"referenceID": 49, "context": "Theorem 1 For an aggregate-free program P, Definition 1 is equivalent to the one introduced in the work of Van Gelder et al. (1991).", "startOffset": 111, "endOffset": 132}, {"referenceID": 49, "context": "We are now ready for extending the well-founded operator defined by Van Gelder et al. (1991) to the case of LPm,a programs.", "startOffset": 72, "endOffset": 93}, {"referenceID": 49, "context": "The following proposition formalizes the intuition that Definition 2 extends the WP operator defined by Van Gelder et al. (1991) for standard programs to LPm,a programs.", "startOffset": 108, "endOffset": 129}, {"referenceID": 49, "context": "The WP operator of Definition 2 coincides with the WP operator defined by Van Gelder et al. (1991).", "startOffset": 78, "endOffset": 99}, {"referenceID": 49, "context": "GUSP in both cases, we have just to show that our definitions of TP and GUSP coincide with those introduced by Van Gelder et al. (1991) for aggregate-free programs.", "startOffset": 115, "endOffset": 136}, {"referenceID": 49, "context": "\u2022 Our definition of GUSP(I) coincides with the one of Van Gelder et al. (1991) for an aggregate-free program P and an interpretation I.", "startOffset": 58, "endOffset": 79}, {"referenceID": 46, "context": "Theorem 8 and Theorem 7 imply that WP admits a least fixpoint (Tarski, 1955), which is referred to as the well-founded model of P.", "startOffset": 62, "endOffset": 76}, {"referenceID": 49, "context": "Property 2 On aggregate-free programs, the well founded semantics as defined in this paper coincides with the classical well-founded semantics of Van Gelder et al. (1991).", "startOffset": 150, "endOffset": 171}, {"referenceID": 33, "context": "Given Corollary 25, an equivalent result has been stated already by Pelov et al. (2007) as Theorem 7.", "startOffset": 68, "endOffset": 88}, {"referenceID": 7, "context": "We first recall the definition of answer sets provided by Faber, Leone, and Pfeifer (2011).", "startOffset": 58, "endOffset": 91}, {"referenceID": 8, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs.", "startOffset": 46, "endOffset": 66}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs.", "startOffset": 47, "endOffset": 114}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al.", "startOffset": 47, "endOffset": 1756}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al.", "startOffset": 47, "endOffset": 1808}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al. (2007). This equivalence follows from Propositions 3.", "startOffset": 47, "endOffset": 1830}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al. (2007). This equivalence follows from Propositions 3.7 and 3.8 of Ferraris (2011), which respectively state that stable models of Pelov et al.", "startOffset": 47, "endOffset": 1905}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al. (2007). This equivalence follows from Propositions 3.7 and 3.8 of Ferraris (2011), which respectively state that stable models of Pelov et al. (2003) on LPm,a coincide with a semantics defined by Ferraris (2011), which in turn coincides with Definition 5 on a larger class of programs.", "startOffset": 47, "endOffset": 1973}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al. (2007). This equivalence follows from Propositions 3.7 and 3.8 of Ferraris (2011), which respectively state that stable models of Pelov et al. (2003) on LPm,a coincide with a semantics defined by Ferraris (2011), which in turn coincides with Definition 5 on a larger class of programs.", "startOffset": 47, "endOffset": 2035}, {"referenceID": 7, "context": "Note that this definition is a generalization (Faber et al., 2004) of the Gelfond-Lifschitz transformation (1991) for standard logic programs. Definition 4 (Program Reduct) Given an LP program P and a total interpretation I, let Ground(P) denote the transformed program obtained from Ground(P) by deleting rules in which a body literal is false with respect to I, i.e.: Ground(P) = {r \u2208 Ground(P) | all the literals in B(r) are true with respect to I}. We are now ready for introducing the notion of answer set for LP programs. Definition 5 (Answer Set for LP Programs) Given an LP program P, a total interpretation M of P is an answer set of P if and only if M is a minimal model of Ground(P) . Example 13 Consider two total interpretations I5 = {p(0)} and I6 = {not p(0)} for the following two programs: P4 = {p(0) :\u2212 #count{X :p(X)} > 0.} P5 = {p(0) :\u2212 #count{X :p(X)} \u2264 0.} We then obtain the following transformed programs: Ground(P4) I5 = Ground(P4) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} > 0.} Ground(P4) I6 = \u2205 Ground(P5) I5 = \u2205 Ground(P5) I6 = Ground(P5) = {p(0) :\u2212 #count{\u30080:p(0)\u3009} \u2264 0.} Hence, I6 is the only answer set of P4. Indeed, I5 is not a minimal model of Ground(P4) I5 . Moreover, P5 has no answer sets. Indeed, I5 is not a minimal model of Ground(P5) I5 , and I6 is not a model of Ground(P5) I6 = Ground(P5). Note that any answer set M of P is also a total model of P because Ground(P) \u2286 Ground(P), and the rules in Ground(P) \\ Ground(P) are satisfied with respect to M (by Definition 4, each of these rules must have at least one body literal which is false with respect to M). On the language LPm,a considered in this work, answer sets as defined in Definition 5 coincide with stable models as defined by Pelov, Denecker, and Bruynooghe (2003) and hence also those defined by Pelov et al. (2007) and Son et al. (2007). This equivalence follows from Propositions 3.7 and 3.8 of Ferraris (2011), which respectively state that stable models of Pelov et al. (2003) on LPm,a coincide with a semantics defined by Ferraris (2011), which in turn coincides with Definition 5 on a larger class of programs. This means that all our results involving answer sets also hold for these other semantics on LPm,a. On the other hand, this also implies that some of the results (for example Theorem 16) are consequences of results in the work of Pelov et al. (2007) by virtue of Theorem 24 in Section 7.", "startOffset": 47, "endOffset": 2359}, {"referenceID": 49, "context": "4 of Van Gelder et al. (1991) to the class of LPm,a programs.", "startOffset": 9, "endOffset": 30}, {"referenceID": 33, "context": "4 in the work of Pelov et al. (2007). In the following, we will provide an alternative proof based on the concepts defined earlier in this paper, which also leads to several interesting intermediate results.", "startOffset": 17, "endOffset": 37}, {"referenceID": 33, "context": "4 in the work of Pelov et al. (2007). In the following, we will provide an alternative proof based on the concepts defined earlier in this paper, which also leads to several interesting intermediate results. Property 5 is not trivial because aggregates may easily increase the complexity of the evaluation. Indeed, even deciding the truth of an aggregate with respect to a partial interpretation is intractable in general; a similar observation has already been made by Pelov (2004). However, this task is polynomial-time computable for the aggregate literals occurring in LPm,a programs.", "startOffset": 17, "endOffset": 483}, {"referenceID": 46, "context": "The \u03c6I operator is a monotonically increasing operator in the meet semilattice \u3008BP ,\u2286\u3009, and it therefore admits a least fixpoint \u03c6 \u03c9 I (\u2205) (Tarski, 1955).", "startOffset": 139, "endOffset": 153}, {"referenceID": 33, "context": "4 in the work of Pelov et al. (2007) because of Corollary 25, but the proof provided here differs considerably from the one of Theorem 7.", "startOffset": 17, "endOffset": 37}, {"referenceID": 17, "context": "The well-founded semantics for LPm,a programs has been implemented by extending the DLV system (Leone et al., 2006).", "startOffset": 95, "endOffset": 115}, {"referenceID": 7, "context": "2 The compilation is in the spirit of the one introduced for #min and #max by Alviano, Faber, and Leone (2008) and defines a subprogram computing the value of a (possibly recursive) aggregate.", "startOffset": 87, "endOffset": 111}, {"referenceID": 42, "context": "For certain special cases, such as when the well-founded model is total, the well-founded model coincides with other semantics such as answer sets (see Corollary 17) and in theses cases systems supporting those semantics such as IDP (Wittocx, Mari\u00ebn, & Denecker, 2008), Smodels (Simons et al., 2002), or clasp (Gebser, Kaufmann, Neumann, & Schaub, 2007), can be used to compute the well-founded model.", "startOffset": 278, "endOffset": 299}, {"referenceID": 16, "context": "Some of these are discussed by Kemp and Stuckey (1991). Another semantics falling in this class is the one introduced by Van Gelder (1992), subsequently generalized by Osorio and Jayaraman (1999).", "startOffset": 31, "endOffset": 55}, {"referenceID": 16, "context": "Some of these are discussed by Kemp and Stuckey (1991). Another semantics falling in this class is the one introduced by Van Gelder (1992), subsequently generalized by Osorio and Jayaraman (1999).", "startOffset": 31, "endOffset": 139}, {"referenceID": 16, "context": "Some of these are discussed by Kemp and Stuckey (1991). Another semantics falling in this class is the one introduced by Van Gelder (1992), subsequently generalized by Osorio and Jayaraman (1999). The main problem of these semantics is that they often leave too many undefined literals, as shown by Ross and Sagiv (1997).", "startOffset": 31, "endOffset": 196}, {"referenceID": 16, "context": "Some of these are discussed by Kemp and Stuckey (1991). Another semantics falling in this class is the one introduced by Van Gelder (1992), subsequently generalized by Osorio and Jayaraman (1999). The main problem of these semantics is that they often leave too many undefined literals, as shown by Ross and Sagiv (1997).", "startOffset": 31, "endOffset": 321}, {"referenceID": 33, "context": "Both trivial and bound approximations have polynomial complexity, while ultimate has been shown to be intractable for nonmonotone aggregate functions (Pelov, 2004).", "startOffset": 150, "endOffset": 163}, {"referenceID": 42, "context": "Indeed, it can be shown that the AtMost pruning operator of Smodels (Simons et al., 2002) is a special case of the \u03c6I operator (defined in the proof of Theorem 21).", "startOffset": 68, "endOffset": 89}, {"referenceID": 5, "context": "Other works attempted to define stronger notions of well-founded semantics (also for programs with aggregates), like the Ultimate Well-Founded Semantics (Denecker et al., 2001), or WFS and WFS (Dix & Osorio, 1997).", "startOffset": 153, "endOffset": 176}, {"referenceID": 10, "context": "A first attempt to define a well-founded semantics for unrestricted LP has been done by Kemp and Stuckey (1991). This semantics is based on a notion of unfounded sets.", "startOffset": 88, "endOffset": 112}, {"referenceID": 10, "context": "A first attempt to define a well-founded semantics for unrestricted LP has been done by Kemp and Stuckey (1991). This semantics is based on a notion of unfounded sets. According to Kemp and Stuckey, a set X of standard atoms is an unfounded set for a (ground) program P with respect to an interpretation I if, for each rule r \u2208 P with H(r) \u2208 X , either (a) some literal in B(r) is false with respect to I, or (b) B(r) \u2229 X 6 = \u2205. Note that only standard literals are considered by condition (b), and aggregates are not covered by it. We point out that this definition of unfounded set makes the semantics inadequate for programs with recursive aggregates, even if only monotone aggregates are considered. For example, for the program {a(1):\u2212#count{X : a(X)} > 0.}, the well-founded model in the work of Kemp and Stuckey is \u2205, while a reasonable well-founded semantics should identify a(1) as false. Pelov et al. (2007) defined a well-founded semantics based on approximating operators, namely D\u0303-well-founded semantics, which extends the standard well-founded semantics; indeed, they coincide for aggregate-free programs.", "startOffset": 88, "endOffset": 918}, {"referenceID": 6, "context": "Ferraris (2005) showed that the semantics of Smodels programs with positive weight constraints is equal to answer sets as defined by Faber et al.", "startOffset": 0, "endOffset": 16}, {"referenceID": 6, "context": "Ferraris (2005) showed that the semantics of Smodels programs with positive weight constraints is equal to answer sets as defined by Faber et al. (2004) on the respective fragment.", "startOffset": 133, "endOffset": 153}, {"referenceID": 5, "context": "Other works attempted to define stronger notions of well-founded semantics (also for programs with aggregates), like the Ultimate Well-Founded Semantics (Denecker et al., 2001), or WFS and WFS (Dix & Osorio, 1997). Whether a characterization of these semantics in terms of unfounded sets can exist for these semantics is unclear and left for future research. Concerning compilations of LP programs into standard LP, a transformation was provided by Van Gelder (1992). The compilation that we presented in Section 6.", "startOffset": 154, "endOffset": 467}, {"referenceID": 33, "context": "1 Comparison with the work of Pelov et al. (2007) In this section we report a detailed comparison of the well-founded semantics as defined in this paper with the one of Pelov et al.", "startOffset": 30, "endOffset": 50}, {"referenceID": 33, "context": "1 Comparison with the work of Pelov et al. (2007) In this section we report a detailed comparison of the well-founded semantics as defined in this paper with the one of Pelov et al. (2007). We recall that Pelov et al.", "startOffset": 30, "endOffset": 189}, {"referenceID": 33, "context": "We are now ready to relate our well-founded operator with the one provided by Pelov et al. (2007).", "startOffset": 78, "endOffset": 98}, {"referenceID": 45, "context": "We also have that Wtrm(P)(I) coincides with the one in the work of Van Gelder et al. (1991) by Theorem 1 (since trm(P) is a standard logic program).", "startOffset": 71, "endOffset": 92}, {"referenceID": 33, "context": "On the other hand, for both the ultimate and bound approximating aggregate semantics, the well-founded operators (as defined in Pelov et al., 2007) of P and trm(P) coincide: This is a consequence of Theorem 1 in the work of Pelov et al. (2003), because the three-valued immediate consequence operators in the work of Pelov et al.", "startOffset": 128, "endOffset": 244}, {"referenceID": 33, "context": "On the other hand, for both the ultimate and bound approximating aggregate semantics, the well-founded operators (as defined in Pelov et al., 2007) of P and trm(P) coincide: This is a consequence of Theorem 1 in the work of Pelov et al. (2003), because the three-valued immediate consequence operators in the work of Pelov et al. (2003) and Pelov et al.", "startOffset": 128, "endOffset": 337}, {"referenceID": 33, "context": "On the other hand, for both the ultimate and bound approximating aggregate semantics, the well-founded operators (as defined in Pelov et al., 2007) of P and trm(P) coincide: This is a consequence of Theorem 1 in the work of Pelov et al. (2003), because the three-valued immediate consequence operators in the work of Pelov et al. (2003) and Pelov et al. (2007) coincide (see Definition 7 in Pelov et al.", "startOffset": 128, "endOffset": 361}, {"referenceID": 33, "context": "On the other hand, for both the ultimate and bound approximating aggregate semantics, the well-founded operators (as defined in Pelov et al., 2007) of P and trm(P) coincide: This is a consequence of Theorem 1 in the work of Pelov et al. (2003), because the three-valued immediate consequence operators in the work of Pelov et al. (2003) and Pelov et al. (2007) coincide (see Definition 7 in Pelov et al., 2003 and Definition 7.5 in Pelov et al., 2007). Moreover, the well-founded operator of Pelov et al. (2007) coincides with the one in the work of Van Gelder et al.", "startOffset": 128, "endOffset": 512}, {"referenceID": 33, "context": "In particular, Theorem 9, Theorem 16 and some of our complexity results follow from definitions and results of Pelov (2004) and Pelov et al.", "startOffset": 111, "endOffset": 124}, {"referenceID": 33, "context": "In particular, Theorem 9, Theorem 16 and some of our complexity results follow from definitions and results of Pelov (2004) and Pelov et al. (2007).", "startOffset": 111, "endOffset": 148}, {"referenceID": 33, "context": "Note that this operator is referred to as stable revision operator by Pelov et al. (2007).", "startOffset": 70, "endOffset": 90}], "year": 2011, "abstractText": "Logic programs with aggregates (LP) are one of the major linguistic extensions to Logic Programming (LP). In this work, we propose a generalization of the notions of unfounded set and well-founded semantics for programs with monotone and antimonotone aggregates (LPm,a programs). In particular, we present a new notion of unfounded set for LPm,a programs, which is a sound generalization of the original definition for standard (aggregate-free) LP. On this basis, we define a well-founded operator for LPm,a programs, the fixpoint of which is called well-founded model (or well-founded semantics) for LPm,a programs. The most important properties of unfounded sets and the well-founded semantics for standard LP are retained by this generalization, notably existence and uniqueness of the well-founded model, together with a strong relationship to the answer set semantics for LPm,a programs. We show that one of the D\u0303-well-founded semantics, defined by Pelov, Denecker, and Bruynooghe for a broader class of aggregates using approximating operators, coincides with the well-founded model as defined in this work on LPm,a programs. We also discuss some complexity issues, most importantly we give a formal proof of tractable computation of the well-founded model for LPm,a programs. Moreover, we prove that for general LP programs, which may contain aggregates that are neither monotone nor antimonotone, deciding satisfaction of aggregate expressions with respect to partial interpretations is coNP-complete. As a consequence, a well-founded semantics for general LP programs that allows for tractable computation is unlikely to exist, which justifies the restriction on LPm,a programs. Finally, we present a prototype system extending DLV, which supports the well-founded semantics for LPm,a programs, at the time of writing the only implemented system that does so. Experiments with this prototype show significant computational advantages of aggregate constructs over equivalent aggregate-free encodings.", "creator": "gnuplot 4.2 patchlevel 6 "}}}