{"id": "1401.4604", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jan-2014", "title": "Completeness Guarantees for Incomplete Ontology Reasoners: Theory and Practice", "abstract": "To achieve scalability of query answering, the developers of Semantic Web applications are often forced to use incomplete OWL 2 reasoners, which fail to derive all answers for at least one query, ontology, and data set. The lack of completeness guarantees, however, may be unacceptable for applications in areas such as health care and defence, where missing answers can adversely affect the applications functionality. Furthermore, even if an application can tolerate some level of incompleteness, it is often advantageous to estimate how many and what kind of answers are being lost in each query.\n\n\n\n\nOne of the advantages of Semantic Web applications is that many of its key benefits will be eliminated. This problem arises from the fact that there are no clear alternatives to using multiple queries. The first is that the query is not as easy to understand as the other application in an application. As far as the problem goes, only a single query can solve it for the purposes of a single query. This means that the query is the only one with an exact query, which can easily solve the problems of other queries, such as the query's type (type of query, as opposed to the types of query, which only provide the answers of any query). The reason that many developers prefer to use multiple queries is that a single query will do the most good job at the same time, which means that the application needs to work on the same information in order to achieve the same type of query.\nThe drawback of applying multiple queries is that a single query could not answer the problem, whereas a single query could not solve it. In a particular case, a single query would not have solved the problem, as the query would still be incomplete, whereas a single query could not solve the problem, as the query would still be incomplete, which means that the application needs to work on the same information in order to achieve the same type of query. This is problematic because it has an obvious relationship with many other non-standard queries that will be introduced during the entire runtime.\nIn terms of performance, there is no such problem when dealing with large queries. It is an excellent option, but it is not the case when evaluating applications that are large enough to handle large queries.\nThe only way to solve the problem is to solve the problem on a single query, which means that the application needs to work on a single query, which means that the application needs to work on the same information in order to achieve the same type of query. This means that the application", "histories": [["v1", "Sat, 18 Jan 2014 21:10:03 GMT  (775kb)", "http://arxiv.org/abs/1401.4604v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["bernardo cuenca grau", "boris motik", "giorgos stoilos", "ian horrocks"], "accepted": false, "id": "1401.4604"}, "pdf": {"name": "1401.4604.pdf", "metadata": {"source": "CRF", "title": "Completeness Guarantees for Incomplete Ontology Reasoners: Theory and Practice", "authors": ["Bernardo Cuenca Grau", "Boris Motik", "Giorgos Stoilos", "Ian Horrocks"], "emails": ["bernardo.cuenca.grau@cs.ox.ac.uk", "boris.motik@cs.ox.ac.uk", "giorgos.stoilos@cs.ox.ac.uk", "ian.horrocks@cs.ox.ac.uk"], "sections": [{"heading": null, "text": "In this paper, we present a novel logic-based framework that allows one to check whether a reasoner is complete for a given query Q and ontology T \u2014that is, whether the reasoner is guaranteed to compute all answers to Q w.r.t. T and an arbitrary data set A. Since ontologies and typical queries are often fixed at application design time, our approach allows application developers to check whether a reasoner known to be incomplete in general is actually complete for the kinds of input relevant for the application.\nWe also present a technique that, given a query Q, an ontology T , and reasoners R1 and R2 that satisfy certain assumptions, can be used to determine whether, for each data set A, reasoner R1 computes more answers to Q w.r.t. T and A than reasoner R2. This allows application developers to select the reasoner that provides the highest degree of completeness forQ and T that is compatible with the application\u2019s scalability requirements.\nOur results thus provide a theoretical and practical foundation for the design of future ontology-based information systems that maximise scalability while minimising or even eliminating incompleteness of query answers."}, {"heading": "1. Introduction", "text": "Efficient management and querying of large amounts of data is a core problem for a growing range of applications in fields as diverse as biology (Sidhu, Dillon, Chang, & Sidhu, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), geography (Goodwin, 2005), astronomy (Derriere, Richard, & Preite-Martinez, 2006), agriculture (Soergel, Lauser, Liang, Fisseha, Keizer, & Katz, 2004), and defence (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005). In order to facilitate interoperability, such applications often use standard data models and query languages. In particular, RDF (Hayes, 2004) provides a standard model for semistructured data, SPARQL (Prud\u2019hommeaux & Seaborne, 2008) is a standard query language for RDF, and ontology languages such as OWL (Horrocks, Patel-Schneider, & van Harmelen, 2003) and OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider,\nc2012 AI Access Foundation. All rights reserved.\n& Sattler, 2008b) can be used to describe background knowledge about the application domain. Thus, answering SPARQL queries over RDF data sets structured using an OWL ontology is a key service in ontology-based information systems.\nAn important question in the design of such systems is the selection of an appropriate reasoner. Systems such as Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007), HermiT (Motik, Shearer, & Horrocks, 2009b), and RACER (Haarslev & Mo\u0308ller, 2001) are based on (hyper)tableau algorithms that are provably complete\u2014that is, they are guaranteed to compute all answers for each query, ontology, and data set. Completeness, however, comes at the cost of scalability, as answering queries over OWL 2 ontologies is of high computational complexity (Glimm, Horrocks, Lutz, & Sattler, 2007; Ortiz, Calvanese, & Eiter, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Lutz, Toman, & Wolter, 2009). Thus, complete systems often fail to meet the scalability demands of applications that manage data sets consisting of hundreds of millions or even billions of assertions.\nScalability of query answering can be ensured by restricting the expressive power of the ontology language to the level that makes provably complete reasoning tractable. This has led to the development of three profiles of OWL 2 (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2009a): OWL 2 EL, OWL 2 RL, and OWL 2 QL. Query answering in all three profiles can be implemented in polynomial time w.r.t. the size of data (and even in logarithmic space in the case of OWL 2 QL). Such appealing theoretical properties have spurred the development of specialised reasoners such as QuONTO (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005) that target specific profiles and typically reject ontologies that fall outside the target profile.\nA different solution to the scalability problem is adopted in reasoners such as Oracle\u2019s Semantic Data Store (Wu, Eadon, Das, Chong, Kolovski, Annamalai, & Srinivasan, 2008), Sesame (Broekstra, Kampman, & van Harmelen, 2002), Jena (McBride, Brian, 2001), OWLim (Kiryakov, Ognyanov, & Manov, 2005), Minerva (Ma, Yang, Qiu, Xie, Pan, & Liu, 2006), DLE-Jena (Meditskos & Bassiliades, 2008), and Virtuoso (Erling & Mikhailov, 2009). These reasoners accept all OWL 2 ontologies as input\u2014that is, they never reject inputs. Furthermore, to the best of our knowledge, all of these systems are intended to be sound, which means that all results of a query are indeed correct answers. Finally, these reasoners typically use scalable reasoning techniques, such as various (deductive) database algorithms. As a consequence, the reasoners are incomplete: for each reasoner, at least one query, ontology, and data set exist for which the reasoner does not return all answers to the query. Some of these reasoners were actually designed to be complete for a particular profile of OWL 2 (typically this is OWL 2 RL due to its close connection with datalog), and they can often additionally handle certain kinds of axiom that fall outside the target profile.\nSince incomplete reasoners can handle large data sets, they often provide the best practical choice for developers of ontology-based applications. For example, OWLim was used for reasoning in the backend of the BBC\u2019s 2010 World Cup website, and Oracle\u2019s reasoner is being used by the University of Texas Health Science Center to improve large-scale public health surveillance. In order to verify that the selected reasoner meets the application\u2019s requirements, developers typically resort to empirical testing, in which they check the reasoner\u2019s answers w.r.t. the application ontology and queries for representative data sets. Although primarily intended for testing performance, benchmark suites such as the Lehigh\nUniversity Benchmark (LUBM) (Guo, Pan, & Heflin, 2005) and the University Ontology Benchmark (UOBM) (Ma et al., 2006) have been used for such completeness testing.\nEmpirical completeness testing, however, has several important limitations. First, tests are not generic, as data sets used for testing typically have a fixed and/or repetitive structure, which can skew test results. Second, test data is not exhaustive, as completeness is tested only w.r.t. a limited number of data sets. Finally, query answers may not be verifiable: since complete reasoners fail to handle large data sets, they often cannot compute the control answers needed to check the answers produced by an incomplete reasoner. As a consequence, empirical completeness tests provide only limited assurance of a reasoner\u2019s ability to meet the requirements of a given application.\nIn this paper, we present a radically different approach to solving these problems. We observed that, given a query Q and ontology T , even if a reasoner is not complete for the language of T , the reasoner may be able to correctly answerQ w.r.t. T and an arbitrary data set A; in such a case, we say that the reasoner is (Q, T )-complete. Given that ontology-based applications often use a limited set of queries and a fixed ontology (or at least the queries and the ontology evolve relatively slowly), a scalable reasoner that is generally incomplete, but is (Q, T )-complete for all relevant combinations of Q and T , may provide a solid foundation for ontology-based applications, allowing them to enjoy \u2018the best of both worlds\u2019: regardless of the data set encountered, such applications will enjoy completeness guarantees normally available only with computationally-intensive complete reasoners, while at the same time exhibiting scalability levels normally available only by sacrificing completeness. To develop an approach for testing the (Q, T )-completeness of a given reasoner, we proceed as follows.\nIn Section 3 we develop a logic-based framework that allows us to establish formally provable (Q, T )-completeness guarantees. The following two notions are central to our framework. First, in order to abstract away from the implementation details of concrete reasoners, we introduce the notion of an abstract reasoner\u2014an idealised reasoner that captures the intended behaviour and salient features (such as soundness and monotonicity) of a class of concrete reasoners. Second, we introduce the notion of a test suite\u2014a finite set of data sets and queries. Intuitively, given Q and T , our goal is to construct a test suite such that, if a reasoner correctly answers all queries on all data sets in the test suite, then the reasoner is guaranteed to be (Q, T )-complete.\nUnfortunately, as we show in Section 3.4, for certain Q and T , it is impossible to construct a finite test suite that will provide the aforementioned completeness guarantees. Therefore, we investigate assumptions onQ, T , and the reasoner under which testing (Q, T )- completeness becomes practically feasible.\nIn Section 3.5 we consider the case where Q and T can be rewritten into a union of conjunctive queries R\u2014that is, when answering Q w.r.t T and a data set A is equivalent to evaluating R over A. For T expressed in OWL 2 QL, a rewriting R can be computed using the algorithm by Calvanese et al. (2007); additionally, the algorithm by Pe\u0301rez-Urbina, Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside this fragment. We show that such R can be converted into a test suite ER that can be used for testing the (Q, T )-completeness of any reasoner that satisfies some basic assumptions; roughly speaking, the reasoner\u2019s answers should not depend on the names of the individuals occurring in a data set, and its answers must increase monotonically when new data is added. The size of each test in ER is polynomial in the size of the longest conjunctive query in R,\nso it should be feasible to compute correct answers to the tests using a complete reasoner. The number of tests in ER, however, can be exponential in the size of R, which may lead to problems in practice. As a remedy, in Section 3.6 we strengthen our assumptions and require the reasoner not to drop answers when \u2018merging\u2019 individuals\u2014that is, if the reasoner returns a given inputs Q, T , and A, then for each (possibly noninjective) mapping \u00b5 the reasoner returns \u00b5(a) given inputs Q, T , and \u00b5(A)\u2014and we show that (Q, T )-completeness of such reasoners can be checked using a test suite IR obtained from R by a linear transformation.\nThat Q and T should be rewritable into a union of conjunctive queries effectively prevents T from stating recursive axioms. To overcome this restriction, in Section 3.7 we consider first-order reproducible reasoners\u2014that is, reasoners whose behaviour on Q, T , and A can be seen as computing certain answers of Q w.r.t. some (possibly unknown) first-order theory FT and A. Since FT can be a datalog program, most reasoners based on deductive databases are first-order reproducible. In addition, we require Q and T to be rewritable into datalog\u00b1,\u2228\u2014an extension of datalog that allows for existential quantifiers and disjunction in rule heads. In many cases, T can be transformed into a datalog\u00b1,\u2228 program using equivalence-preserving transformations; furthermore, the algorithm by Pe\u0301rez-Urbina et al. (2010) can in many cases produce a plain datalog rewriting. We then show how to transform a datalog\u00b1,\u2228 rewriting of Q and T into a test suite that can be used to test (Q, T )-completeness of first-order reproducible reasoners.\nIn Section 4 we turn our attention to comparing incomplete reasoners. Roughly speaking, given Q and T , reasoner R1 is \u2018more complete\u2019 than reasoner R2 if, for each data set A, reasoner R1 computes all the answers to Q w.r.t. T and A that are computed by R2. We show that comparing incomplete reasoners is infeasible in general. Therefore, we introduce the notion of compact reasoners\u2014that is, reasoners whose behaviour on Q, T , and A can be seen as first selecting some subset T  of T and then using a complete reasoner to evaluate Q w.r.t. T  and A. Thus, the class of compact reasoners captures all reasoners that reduce the input ontology T to a set of axioms that match certain parameters, such as fitting into language fragments. For Q and T that can be rewritten into a union of conjunctive queries R, we show that the test suite IR can be used to compare compact reasoners.\nWe have implemented our approaches for computing test suites, and have tested completeness of several well-known reasoners (see Section 5). These show that test suites can be efficiently computed for realistic ontologies. Furthermore, we were able to guarantee (Q, T )-completeness of the evaluated reasoners for many queries and ontologies. Finally, when no (Q, T )-completeness guarantee could be provided, we were able to compute a counter-example\u2014a small data set for which the reasoner at hand was incomplete."}, {"heading": "2. Preliminaries", "text": "In this section we briefly introduce Description Logics (DLs) (Baader, McGuinness, Nardi, & Patel-Schneider, 2002)\u2014a family of knowledge representation formalisms which underpin the OWL and OWL 2 ontology languages. We describe description logics in the wider framework of first-order logic since many of our results hold for arbitrary first-order theories.\nWe then introduce the datalog\u00b1,\u2228 and datalog languages, and we define the syntax and semantics of unions of conjunctive queries (UCQs). Finally, we introduce the notions of UCQ, datalog, and datalog\u00b1,\u2228 rewritings, which underpin many of our techniques."}, {"heading": "2.1 Description Logics and First-Order Logic", "text": "Most of the results in this paper hold for arbitrary first-order theories, rather than description logics. Our work, however, is motivated by description logics and ontologies, so we use the DL terminology throughout the paper; for example, we often talk about TBoxes and ABoxes instead of first-order theories and sets of facts.\nAll definitions in this paper are implicitly parameterised by a signature \u03a3 = \u03a3P ,\u03a3I, which consists of countably infinite disjoint sets of predicates \u03a3P and individuals (commonly called constants in first-order logic) \u03a3I . Each predicate is associated with a nonnegative arity ; predicates of zero arity are commonly called propositional symbols. The notions of variables, terms, atoms, first-order formulae, and sentences are defined as usual (Fitting, 1996); we do not consider function symbols in this article and we assume all formulae to be function-free. The atom that is false (true) in all interpretations is written \u22a5 (). An atom is a fact if it does not contain variables. We use the standard first-order notions of satisfiability, unsatisfiability, and entailment (written |=) of sets of first-order sentences.\nWe assume that \u03a3P contains the special equality and inequality predicates \u2248 and \u2248, respectively; atoms of the form \u2248(t1, t2) and \u2248(t1, t2) are commonly written as t1 \u2248 t2 and t1 \u2248 t2, respectively. We make a technical assumption that \u2248 and \u2248 are distinct predicates rather than, as it is common in first-order logic, that t1 \u2248 t2 is an abbreviation for \u00ac(t1 \u2248 t2); furthermore, we assume that each theory that uses \u2248 and \u2248 axiomatises their semantics as follows, where (5) is instantiated for each predicate P of arity n and each i with 1 \u2264 i \u2264 n.\n\u2200x, y.[x \u2248 y \u2227 x \u2248 y \u2192 \u22a5] (1) \u2200x.[x \u2248 x] (2)\n\u2200x, y.[x \u2248 y \u2192 y \u2248 x] (3) \u2200x, y, z.[x \u2248 y \u2227 y \u2248 z \u2192 x \u2248 z] (4)\n\u2200x1, . . . , xi, . . . , xn, yi.[P (x1, . . . , xi, . . . , xn) \u2227 xi \u2248 yi \u2192 P (x1, . . . , yi, . . . , xn)] (5)\nNote that, according to this assumption, each set of facts is satisfiable. For example, the set of atoms {a \u2248 b, a \u2248 b} is satisfiable since both a \u2248 b and a \u2248 b are positive variable-free atoms that are semantically independent from each other; moreover, axiom (1) is required to obtain the expected contradiction.\nAn individual renaming (often just renaming) is a partial function \u00b5 : \u03a3I \u2192 \u03a3I that maps individuals to individuals. The domain and the range of \u00b5 are written dom(\u00b5) and rng(\u00b5); unless otherwise noted, we assume that dom(\u00b5) is finite. For \u03b1 an object containing individuals (such as a formula, a set of formulae, or a tuple of individuals), ind(\u03b1) is the set of individuals occurring in \u03b1, and \u00b5(\u03b1) is obtained from \u03b1 by simultaneously replacing each individual a \u2208 ind(\u03b1) \u2229 dom(\u00b5) with \u00b5(a).\nWe use the notion of substitutions from first-order logic; that is, a substitution \u03c3 is a mapping of variables to terms. For \u03b1 a term, an atom, or a formula, the result of applying a substitution \u03c3 to \u03b1 is written as \u03c3(\u03b1).\nA TBox T a is a finite set of first-order sentences that contains axioms (1)\u2013(5) whenever \u2248 and/or \u2248 are used. An ABox A is a finite set of facts. Note that this definition allows for atoms of the form a \u2248 b and a \u2248 b in ABoxes; furthermore, since ABoxes can contain only positive atoms, each ABox (when considered without a TBox) is satisfiable.\nA description logic DL is a (usually infinite) recursive set of TBoxes satisfying the following conditions:\n\u2022 for each T \u2208 DL and each renaming \u00b5, we have \u00b5(T ) \u2208 DL, and\n\u2022 for each T \u2208 DL and each T  \u2286 T , we have T  \u2208 DL. If T \u2208 DL, we say that T is a DL-TBox. Finally, FOL is the largest description logic that contains all finite sets of first-order sentences over the signature in question.\nWe next present an overview of the DLs commonly considered in the literature. Typically, the predicates in DL signatures are required to be unary or binary; the former are commonly called atomic concepts and the latter are commonly called atomic roles. DLs typically use a specialised syntax, summarised in Table 1, that provides a set of constructors for constructing complex concepts and roles from simpler ones, as well as different kinds of axioms. Using the translation from Table 2, concepts can be translated into first-order formulae with one free variable, roles can be translated into first-order formulae with two free variables, and axioms can be translated into first-order sentences. Note that the translation uses counting quantifiers \u2203\u2265n and \u2203\u2264n, which can be expressed by using ordinary quantifiers and equality by well-known transformations.\nIn the rest of this paper, we commonly write TBoxes and ABoxes in DL syntax; however, to simplify the presentation, we identify T and A written in DL syntax with \u03c0(T ) and \u03c0(A)."}, {"heading": "2.2 Datalog\u00b1,\u2228", "text": "We next introduce a fragment of first-order logic called datalog\u00b1,\u2228 as an extension of datalog\u00b1 by Cal\u0300\u0131, Gottlob, Lukasiewicz, Marnette, and Pieris (2010). A datalog\u00b1,\u2228 rule (or commonly just a rule) r is a formula of the form (6), where each Bj is an atom different from \u22a5 whose free variables are contained in x, and\n\u2022 m = 1 and \u03d51(x, y1) = \u22a5, or\n\u2022 m \u2265 1 and, for each 1 \u2264 i \u2264 m, formula \u03d5i(x, yi) is a conjunction of atoms different from \u22a5 whose free variables are contained in x \u222a yi.\n\u2200x.[B1 \u2227 . . . \u2227Bn \u2192 m\ni=1\n\u2203yi.\u03d5i(x, yi)] (6)\nA rule is safe if each variable in x also occurs in some Bj ; unless otherwise noted, all rules are assumed to be safe. For brevity, the outer quantifier \u2200x is commonly left implicit. The body of r is the set of atoms body(r) = {B1, . . . , Bn}, and the head of r is the formula head(r) = m i=1 \u2203yi.\u03d5i(x, yi). A datalog\u00b1,\u2228 program is a finite set of safe datalog\u00b1,\u2228 rules. Note that, since\u2248 and \u2248 are treated as ordinary predicates, they can occur in rules, provided that their semantics is appropriately axiomatised; furthermore, note that the latter can be achieved using datalog\u00b1,\u2228 rules.\nLet r be a datalog\u00b1,\u2228 rule. Then, r is a datalog\u2228 rule if head(r) contains no existential quantifier. Also, r is a datalog\u00b1 rule if m = 1. Finally, r is a datalog rule if m = 1 and the head of r is a single atom without existential quantifiers (Ceri, Gottlob, & Tanca, 1989).\nIn several places in this paper, we check whether a set of first-order sentences entails a datalog\u00b1,\u2228 rule, which can be accomplished using the following simple result.\nProposition 2.1. Let F be a set of first-order sentences, and let r be a datalog\u00b1,\u2228 rule of the form (6). Then, for each substitution \u03c3 mapping the free variables of r to distinct individuals not occurring in F or r, we have F |= r if and only if\nF \u222a {\u03c3(B1), . . . ,\u03c3(Bn)} |= m\ni=1\n\u2203yi.\u03d5i(\u03c3(x), yi)\nProof. Let x be the tuple of free variables in r and let \u03c3 be an arbitrary substitution mapping the variables in x to distinct individuals not occurring in F or r. The claim of this proposition follows from the following equivalences:\nF |= \u2200x.[B1 \u2227 . . . \u2227Bn \u2192 m\ni=1\n\u2203yi.\u03d5i(x, yi)] iff\nF \u222a {\u00ac[\u2200x.B1 \u2227 . . . \u2227Bn \u2192 m\ni=1\n\u2203yi.\u03d5i(x, yi)]} is unsatisfiable iff\nF \u222a {\u2203x.[B1 \u2227 . . . \u2227Bn \u2227 \u00ac m\ni=1\n\u2203yi.\u03d5i(x, yi)]} is unsatisfiable iff (skolem. of \u2203x)\nF \u222a {\u03c3(B1) \u2227 . . . \u2227 \u03c3(Bn) \u2227 \u00ac m\ni=1\n\u2203yi.\u03d5i(\u03c3(x), yi)} is unsatisfiable iff\nF \u222a {\u03c3(B1), . . . ,\u03c3(Bn),\u00ac m\ni=1\n\u2203yi.\u03d5i(\u03c3(x), yi)} is unsatisfiable iff\nF \u222a {\u03c3(B1), . . . ,\u03c3(Bn)} |= m\ni=1\n\u2203yi.\u03d5i(\u03c3(x), yi)."}, {"heading": "2.3 Queries", "text": "In order to achieve a high degree of generality, we define a query Q as a finite set of firstorder sentences containing a distinct query predicate Q. Intuitively, the query predicate Q determines the answers of Q. In order to simplify the notation, we typically assume that the association between Q and the query predicate is implicit (e.g., we may require each query to contain precisely one such predicate), and we assume that no query predicate occurs in a TBox or an ABox.\nA tuple of constants a is a certain answer to a query Q with query predicate Q with respect to a TBox T and an ABox A if the arity of a agrees with the arity of Q and T \u222aA \u222aQ |= Q(a). The set of all certain answers of Q w.r.t. T and A is denoted as cert(Q, T ,A). If the query predicate of Q is propositional (i.e., if the query is Boolean), then cert(Q, T ,A) is either empty or it contains the tuple of zero length; in such cases, we commonly write cert(Q, T ,A) = f and cert(Q, T ,A) = t, respectively.\nWe use \u2217 as the special Boolean query that checks a first-order theory for unsatisfiability. Thus, cert(\u2217, T ,A) = t if and only if T \u222aA is unsatisfiable.\nA query Q with a query predicate Q is a union of conjunctive queries (UCQ) if it is a datalog program in which each rule contains Q in the head but not in the body. A UCQ Q is a conjunctive query (CQ) if it contains exactly one rule.\nA union of conjunctive queries Q is ground if, for each rule r \u2208 Q, each variable occurring in the body of r also occurs in the head of r. Roughly speaking, when computing cert(Q, T ,A) for a ground Q, all variables in Q can be matched only to the individuals in T and A, but not to unnamed objects whose existence is guaranteed by existential quantifiers. Many state of the art reasoners used in practice support only ground UCQs. Note that Q = {A(x) \u2192 Q(x), R(x, y) \u2192 Q(x, y)} is not a ground UCQ; in fact, Q is not even a valid first-order theory since predicate Q does not have unique arity. To obtain a UCQ, one can \u2018pad\u2019 the head of the first rule\u2014that is, one can introduce a special fresh individual null and rewrite the rules as Q = {A(x) \u2192 Q(x,null), R(x, y) \u2192 Q(x, y)}.\nBy the properties of first-order logic entailment, cert satisfies the following properties for each query Q, all TBoxes T and T , and all ABoxes A and A.\n1. Monotonicity : T \u2286 T  and A \u2286 A imply\n\u2022 cert(\u2217, T ,A) = t implies cert(\u2217, T ,A) = t, and \u2022 cert(Q, T ,A) \u2286 cert(Q, T ,A).\n2. Invariance under renamings: For each renaming \u00b5 and each tuple of individuals a,\n\u2022 cert(\u2217, T ,A) = t implies cert(\u2217, \u00b5(T ), \u00b5(A)) = t, and \u2022 a \u2208 cert(Q, T ,A) implies \u00b5(a) \u2208 cert(\u00b5(Q), \u00b5(T ), \u00b5(A))."}, {"heading": "2.4 Rewritings", "text": "Intuitively, a rewriting of a query Q w.r.t. a TBox T is another query that captures all the information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; Pe\u0301rez-Urbina et al., 2010). In practice, UCQs (Calvanese et al., 2007) and datalog (Pe\u0301rez-Urbina et al., 2010) are the most widely used target languages for query rewriting. For the sake of generality, however, in this paper we use a notion of a datalog\u00b1,\u2228 rewriting.\nDefinition 2.2. Let Q be a query and let T be a TBox. A datalog\u00b1,\u2228 rewriting (or simply a rewriting) of Q w.r.t. T is a triple R = RD,R\u22a5,RQ where\n\u2022 RD is a datalog\u00b1,\u2228 program not containing \u22a5 or Q such that T |= RD,\n\u2022 R\u22a5 is a datalog program such that head(r) = \u22a5 for each r \u2208 R\u22a5, and\n\u2022 RQ is a UCQ whose query predicate is Q,\nsuch that the following properties hold for each ABox A:\n\u2022 cert(\u2217, T ,A) = cert(\u2217,RD \u222aR\u22a5,A), and\n\u2022 if cert(\u2217, T ,A) = f, then cert(Q, T ,A) = cert(RQ,RD \u222aR\u22a5,A).\nRewriting R is a datalog rewriting if RD is a datalog program. Furthermore, rewriting R is a UCQ rewriting if RD = \u2205; such an R is usually written as just R = R\u22a5,RQ.\nNote that Definition 2.2 requires T |= RD to hold, which precludes rewritings consisting of axioms that are unsound w.r.t. T . For example, let Q = {A(x) \u2192 Q(x)} and T = \u2205; then, RD = {B(x) \u2192 A(x)} does not satisfy the definition of a rewriting since formula B(x) \u2192 A(x) is not a logical consequence of T .\nFor a wide range of T and Q, a datalog\u00b1,\u2228 rewriting of Q w.r.t. T can be computed using straightforward equivalence-preserving transformations of T ; this can be further optimised by eliminating axioms from T that are irrelevant to answering Q. Furthermore, several algorithms for computing UCQ and datalog rewritings have been proposed in the literature. For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when T is expressed in a logic from the DL-Lite family, and this approach can be extended to the OWL 2 QL profile of OWL 2 (Motik et al., 2009a). Similarly, Pe\u0301rez-Urbina et al. (2010) proposed an algorithm for computing the simplest possible datalog rewriting when T is expressed in the description logic ELHIO.\nRewritings produced by known algorithms often contain predicates that do not occur in T and Q; such predicates are sometimes called fresh. For example, many rewriting algorithms normalise TBoxes by replacing complex concepts with fresh atomic concepts. A rewriting R = RD,R\u22a5,RQ obtained in such a way is unlikely to satisfy the requirement that T |= RD. However, predicates occurring in R but not in T can often be eliminated via unfolding. For example, let Q = {A(x) \u2192 Q(x)} and T = {\u2203R.\u2203S.B  A}, and assume that a rewriting algorithm produces\nRD = {S(x, y) \u2227B(x) \u2192 C(x), R(x, y) \u2227 C(y) \u2192 A(x)}.\nTo satisfy Definition 2.2, predicate C can be unfolded and RD replaced with\nRD = {R(x, y) \u2227 S(y, z) \u2227B(z) \u2192 A(x)},\nfor which T |= RD holds. Unfolding, however, may not always be possible (e.g., this might be the case when fresh predicates occur in recursive axioms), which may limit the applicability of some of the results presented in this paper."}, {"heading": "3. Completeness Guarantees for Incomplete Reasoners", "text": "In this section, we introduce the formal framework that will allow us to establish completeness guarantees for incomplete reasoners. Our results are not restricted to any particular description logic, but are applicable to all TBoxes that satisfy the following criterion.\nDefinition 3.1. A TBox T is admissible if a description logic DL exists such that T is a DL-TBox, and both checking TBox satisfiability and answering Boolean UCQs w.r.t. an arbitrary ABox are decidable for DL."}, {"heading": "3.1 Concrete and Abstract Reasoners", "text": "Concrete reasoners are complex software systems that differ greatly in the functionality and the supported interfaces, and that use a range of different implementation techniques. To make our results general and independent from specific implementation techniques, we introduce the notion of an abstract reasoner. An abstract reasoner can be thought of as an\nidealised reasoner that captures the intended behaviour and salient features of a class of concrete reasoners. A concrete reasoner belonging to this class may use arbitrary algorithms, as long as their observable behaviour mirrors that of the abstract reasoner.\nDefinition 3.2. An abstract reasoner ans for a description logic DL is a computable function that takes as input an arbitrary DL-TBox T , an arbitrary ABox A, and either the special unsatisfiability query \u2217 or an arbitrary UCQ Q. The return value of ans is defined as follows:\n\u2022 ans(\u2217, T ,A) is either t or f;\n\u2022 if ans(\u2217, T ,A) = t, then ans(Q, T ,A) is of no interest and can be arbitrary; and\n\u2022 if ans(\u2217, T ,A) = f, then ans(Q, T ,A) is a finite set of tuples of individuals, where the arity of each tuple is equal to the arity the query predicate of Q.\nAn abstract reasoner ans for DL is said to be applicable to a TBox T if T is a DL-TBox.\nIntuitively, ans(\u2217, T ,A) asks the abstract reasoner to check whether T \u222a A is unsatisfiable, and ans(Q, T ,A) asks the abstract reasoner to evaluate Q w.r.t. T \u222a A. If T \u222a A is unsatisfiable, then each tuple of constants of the same arity as the query predicate Q is an answer to Q on T \u222a A; therefore, the result of ans(Q, T ,A) is of interest only if ans(\u2217, T ,A) = f\u2014that is, if ans identifies T \u222aA as satisfiable.\nExample 3.3. Consider the abstract reasoners rdf, rdfs, rl, and classify which, given as input a UCQ Q, a TBox T , and an ABox A, compute the answer to Q w.r.t. T and A as described next.\nAbstract reasoner rdf ignores T and evaluatesQ w.r.t.A; more precisely, rdf(\u2217, T ,A) = f and rdf(Q, T ,A) = cert(Q, \u2205,A). Thus, rdf captures the behaviour of RDF reasoners.\nAbstract reasoner rdfs evaluates Q w.r.t. A and a datalog program Prdfs that is constructed by translating each RDFS axiom \u03b1 in T into an equivalent datalog rule; more precisely, rdfs(\u2217, T ,A) = f and rdfs(Q, T ,A) = cert(Q,Prdfs,A). Thus, rdfs captures the behaviour of RDFS reasoners such as Sesame.\nAbstract reasoner rl evaluates Q w.r.t. A and a datalog program Prl that is constructed by translating each OWL 2 RL axiom \u03b1 in T into an equivalent datalog rule; more precisely, rl(\u2217, T ,A) = cert(\u2217,Prl,A) and rl(Q, T ,A) = cert(Q,Prl,A). Thus, rl captures the behaviour of OWL 2 RL reasoners such as Jena and Oracle\u2019s Semantic Data Store.\nAbstract reasoner classify first classifies T using a complete OWL 2 DL reasoner; that is, it computes a TBox T  containing each subclass axiom A  B such that T |= A  B, and A and B are atomic concepts occurring in T . The abstract reasoner then proceeds as rl, but considers T \u222a T  instead of T ; more precisely, classify(\u2217, T ,A) = rl(\u2217, T \u222a T ,Ain) and classify(Q, T ,A) = rl(Q, T \u222a T ,A). In this way, classify captures the behaviour of OWL 2 RL reasoners such as Minerva and DLE-Jena that try to be \u2018more complete\u2019 by materialising certain consequences of T . \u2666\nAn \u2018ideal\u2019 abstract reasoner is one such that, for an arbitrary UCQ Q, TBox T , and ABox A, we have ans(\u2217, T ,A) = cert(\u2217, T , A), and ans(Q, T ,A) = cert(Q, T , A) whenever ans(\u2217, T ,A) = f. We next introduce and discuss several properties of abstract reasoners\nthat are likely to affect how close they come to this ideal and that may also be relevant to the applicability of our results.\nThe following notion of soundness describes abstract reasoners that return only answers that logically follow from Q, T , and A.\nDefinition 3.4. An abstract reasoner ans for DL is sound if the following conditions hold for each UCQ Q, DL-TBox T , and ABox A:\n\u2022 ans(\u2217, T ,A) = t implies cert(\u2217, T ,A) = t; and\n\u2022 ans(\u2217, T ,A) = f implies ans(Q, T ,A) \u2286 cert(Q, T ,A).\nThe following notion of monotonicity describes abstract reasoners for which extending the input TBox and ABox never leads to dropping answers. We also consider a weaker notion of (Q, T )-monotonicity, in which the input query Q and TBox T are fixed.\nDefinition 3.5. An abstract reasoner ans for DL is monotonic if the following conditions hold for each UCQ Q, all DL-TBoxes T and T , and all ABoxes A and A such that T \u2286 T  and A \u2286 A:\n\u2022 ans(\u2217, T ,A) = t implies ans(\u2217, T ,A) = t; and\n\u2022 ans(\u2217, T ,A) = f and ans(\u2217, T ,A) = f imply ans(Q, T ,A) \u2286 ans(Q, T ,A).\nGiven a UCQ Q and a DL-TBox T , ans is (Q, T )-monotonic if the following conditions hold for all ABoxes A and A such that A \u2286 A:\n\u2022 ans(\u2217, T ,A) = t implies ans(\u2217, T ,A) = t; and\n\u2022 ans(\u2217, T ,A) = f and ans(\u2217, T ,A) = f imply ans(Q, T ,A) \u2286 ans(Q, T ,A).\nAs discussed in Section 2.3, the logical consequences of a first-order theory are invariant under renaming and merging of individuals. To define analogous properties for abstract reasoners, we first introduce the notions of T -stable and (Q, T )-stable renamings\u2014that is, renamings that leave all individuals occurring in T (respectively, in Q and T ) unchanged.\nDefinition 3.6. Let Q be a query, let T be a TBox, and let \u00b5 be a renaming. Then, \u00b5 is T - stable if \u00b5(a) = a for each individual a \u2208 dom(\u00b5) \u2229 ind(T ); furthermore, \u00b5 is (Q, T )-stable if \u00b5(a) = a for each individual a \u2208 dom(\u00b5) \u2229 ind(Q \u222a T ).\nThe following notion of weak faithfulness describes abstract reasoners whose answers are invariant under replacement of individuals with fresh individuals. Furthermore, weak (Q, T )-faithfulness relaxes this property to the case when Q and T are fixed.\nDefinition 3.7. An abstract reasoner ans for DL is weakly faithful if the following conditions hold for each UCQ Q, DL-TBox T , ABox A, injective renaming \u00b5, and tuple a:\n\u2022 ans(\u2217, T ,A) = t and ind(T \u222aA) \u2286 dom(\u00b5) imply ans(\u2217, \u00b5(T ), \u00b5(A)) = t; and\n\u2022 ans(\u2217, T ,A) = f, ind(Q \u222a T \u222aA) \u2286 dom(\u00b5), and a \u2208 ans(Q, T ,A) imply ans(\u2217, \u00b5(T ), \u00b5(A)) = f and \u00b5(a) \u2208 ans(\u00b5(Q), \u00b5(T ), \u00b5(A)).\nGiven a UCQ Q and a DL-TBox T , ans is weakly (Q, T )-faithful if the following conditions hold for each ABox A, injective renaming \u00b5, and tuple a:\n\u2022 ans(\u2217, T ,A) = t, ind(T \u222aA) \u2286 dom(\u00b5), and \u00b5 is T -stable imply ans(\u2217, T , \u00b5(A)) = t; and\n\u2022 ans(\u2217, T ,A) = f, ind(Q \u222a T \u222aA) \u2286 dom(\u00b5), \u00b5 is (Q, T )-stable, and a \u2208 ans(Q, T ,A) imply ans(\u2217, T , \u00b5(A)) = f and \u00b5(a) \u2208 ans(Q, T , \u00b5(A)).\nThe following notion of strong faithfulness describes abstract reasoners whose answers are invariant under merging of individuals. Furthermore, strong (Q, T )-faithfulness relaxes this property to the case when Q and T are fixed.\nDefinition 3.8. An abstract reasoner ans for DL is strongly faithful if the following conditions hold for each UCQ Q, DL-TBox T , ABox A, renaming \u00b5, and tuple a:\n\u2022 ans(\u2217, T ,A) = t implies ans(\u2217, \u00b5(T ), \u00b5(A)) = t; and\n\u2022 ans(\u2217, T ,A) = f, a \u2208 ans(Q, T ,A), and ans(\u2217, \u00b5(T ), \u00b5(A)) = f imply \u00b5(a) \u2208 ans(\u00b5(Q), \u00b5(T ), \u00b5(A)).\nGiven a UCQ Q and a DL-TBox T , ans is strongly (Q, T )-faithful if the following conditions hold for each ABox A, renaming \u00b5, and tuple a:\n\u2022 ans(\u2217, T ,A) = t and \u00b5 is T -stable imply ans(\u2217, T , \u00b5(A)) = t; and\n\u2022 ans(\u2217, T ,A) = f, \u00b5 is (Q, T )-stable, a \u2208 ans(Q, T ,A), and ans(\u2217, T , \u00b5(A)) = f imply \u00b5(a) \u2208 ans(Q, T , \u00b5(A)).\nThe results that we present in the rest of this paper are applicable only to abstract reasoners that satisfy various combinations of these properties; as a minimum, we require (Q, T )-monotonicity and weak (Q, T )-faithfulness. The abstract reasoners described in Example 3.3 all satisfy these properties. Testing if this is the case for concrete reasoners may, however, be infeasible in practice; indeed, we are not aware of a technique that would allow one to check whether a concrete reasoner satisfies the required properties. We believe, however, that all concrete reasoners commonly used in practice are intended to be sound, monotonic, and at least weakly faithful, and that strong faithfulness is a reasonable assumption in most cases. If a concrete reasoner fails to satisfy some of these properties on certain inputs, this is likely to be due to implementation bugs; thus, any consequent failure of completeness can be seen as a bug, and detecting such situations should be viewed as a part of a more general problem of testing software systems.\nWe next present several examples of abstract reasoners that do not satisfy some of the mentioned properties.\nExample 3.9. Consider an abstract reasoner that behaves as rdf whenever the number of assertions in the input ABox is smaller than a certain threshold, and that returns the empty set of answers for larger ABoxes. Intuitively, such an abstract reasoner characterises a concrete RDF reasoner that processes inputs only up to a certain size. Such a reasoner is not (Q, T )-monotonic for an arbitrary Q and T . \u2666\nExample 3.10. Consider an abstract reasoner that behaves like rdf, but that, for trust reasons, removes from each input ABox all assertions whose individuals are \u2018blacklisted\u2019 (e.g., they come from an untrusted source). Such an abstract reasoner is not weakly (Q, T )- faithful for an arbitrary Q and T . \u2666\nExample 3.10 suggests that, for an abstract reasoner to be weakly faithful, it should not make decisions that depend on specific names of individuals.\nExample 3.11. Consider an abstract reasoner rl= that, given as input a UCQ Q, a TBox T , and an ABox A, proceeds as follows. First, rl= computes the ABox A obtained by evaluating the datalog program Prl from Example 3.3 over A. Second, rl= computes the query Q= obtained from Q by adding to the body of each rule r \u2208 Q an inequality x \u2248 y for all pairs of distinct variables x and y occurring in r. Third, rl= evaluates Q= over A by considering A as a database\u2014that is, as a finite first-order interpretation in which each individual is mapped to itself (and thus different individuals are distinct). Thus, rl= characterises concrete reasoners that evaluate queries by matching different variables to different individuals. Abstract reasoner rl= is sound, monotonic, and weakly faithful, but it is not strongly faithful. For example, given query Q = {R(x, y) \u2192 Q(x)}, ABox A = {R(a, b)}, and renaming \u00b5 = {a \u2192 c, b \u2192 c}, we have rl=(Q, \u2205,A) = {a}, but rl=(Q, \u2205, \u00b5(A)) = \u2205. \u2666\nExample 3.11 suggests that, for an abstract reasoner to be strongly faithful, it should allow distinct variables in queries and axioms to be mapped to the same individuals.\nWe next identify classes of abstract reasoners that we use throughout this paper. Note that soundness is not required, which contributes to the generality of our results.\nDefinition 3.12. Given a UCQ Q and a TBox T , CQ,Tw (CQ,Ts ) is the class of all (Q, T )- monotonic and weakly (strongly) (Q, T )-faithful abstract reasoners applicable to T .\nFinally, note that all the abstract reasoners introduced in Example 3.3 are sound, monotonic, and strongly (and therefore also weakly) faithful. Consequently, all concrete reasoners based on reasoning techniques outlined in Example 3.3 can be considered sound, monotonic, and strongly faithful, modulo implementation bugs."}, {"heading": "3.2 Completeness of Abstract Reasoners", "text": "We next define the central notion of abstract reasoner completeness for a given query Q and TBox T . Intuitively, a (Q, T )-complete abstract reasoner is indistinguishable from a complete abstract reasoner when applied to Q, T , and an arbitrary ABox A.\nDefinition 3.13. Let DL be a description logic, and let ans be an abstract reasoner for DL. Then, ans is (Q, T )-complete for a UCQ Q and a DL-TBox T if the following conditions hold for each ABox A:\n\u2022 if cert(\u2217, T ,A) = t, then ans(\u2217, T ,A) = t;\n\u2022 if cert(\u2217, T ,A) = f and ans(\u2217, T ,A) = f, then cert(Q, T ,A) \u2286 ans(Q, T ,A).\nFinally, ans is complete if it is (Q, T )-complete for each UCQ Q and each DL-TBox T .\nExample 3.14. Consider the EL-TBox T consisting of the following axioms; the translation of the axioms into first-order logic is shown after the  symbol.\n\u2203takesCo.MathCo  St  \u2200x, y.[takesCo(x, y) \u2227MathCo(y) \u2192 St(x)] (7) CalcCo  MathCo  \u2200x.[CalcCo(x) \u2192 MathCo(x)] (8)\nMathSt  \u2203takesCo.MathCo  \u2200x.[MathSt(x) \u2192 \u2203y.[takesCo(x, y) \u2227MathCo(y)]] (9) St  Prof  \u22a5  \u2200x.[St(x) \u2227 Prof(x) \u2192 \u22a5] (10)\nAxiom (7) states that everyone taking a maths course is a student; axiom (8) states that each calculus course is also a maths course; axiom (9) states that each maths student takes some maths course; and axiom (10) states that no person can be both a student and a professor. Axiom (8) is an RDFS axiom, and all other axioms in T apart from (9) are OWL 2 RL axioms. Consider also query (11) that retrieves students taking a maths course.\nQ = {St(x) \u2227 takesCo(x, y) \u2227MathCo(y) \u2192 Q(x)} (11)\nNone of the abstract reasoners rdf, rdfs, rl, and classify from Example 3.3 are complete in general for answering UCQs over EL-TBoxes. Furthermore, for Q and T from the previous paragraph, abstract reasoners rdf, rdfs, and rl are not (Q, T )-complete, as all of them return the empty set of answers for ABox A = {MathSt(c)}. In contrast, in the following sections we will show that abstract reasoner classify is (Q, T )-complete\u2014that is, that it returns all certain answers to Q, T , and an arbitrary ABox A. \u2666"}, {"heading": "3.3 Test Suites", "text": "Checking (Q, T )-completeness of a concrete reasoner by applying the reasoner to all possible ABoxes and comparing the reasoner\u2019s answers with that of a complete reasoner is clearly infeasible in practice since there are infinitely many candidate input ABoxes. To obtain a practical approach, we need a finite number of tests. We formalise this idea using the following definition.\nDefinition 3.15. Let T be a TBox. A T -test suite is a pair S = S\u22a5,SQ where\n\u2022 S\u22a5 is a finite set of ABoxes such that cert(\u2217, T ,A) = t for each A \u2208 S\u22a5, and\n\u2022 SQ is a finite set of pairs A,Y where A is an ABox such that cert(\u2217, T ,A) = f and Y is a UCQ.\nAn abstract reasoner ans applicable to T passes a T -test suite S if ans satisfies the following two conditions:\n\u2022 for each A \u2208 S\u22a5, we have ans(\u2217, T ,A) = t, and\n\u2022 for each A,Y \u2208 SQ, if ans(\u2217, T ,A) = f, then cert(Y, T ,A) \u2286 ans(Y, T ,A).\nLet Q be a UCQ, and let C be a class of abstract reasoners applicable to T . Then, S is exhaustive for C and Q if each ans \u2208 C that passes S is (Q, T )-complete.\nA T -test suite S is Q-simple if Q is the only query occurring in SQ; then, SQ is commonly written as just a set of ABoxes, and A,Q \u2208 SQ is commonly abbreviated as A \u2208 SQ.\nIntuitively, a T -test suite S = S\u22a5,SQ determines the tests that an abstract reasoner should be subjected to. For a reasoner to pass S, it must correctly identify each ABox A \u2208 S\u22a5 as unsatisfiable, and for each ABox\u2013query pair A,Y \u2208 SQ the reasoner must correctly answer Y w.r.t. T and A.\nGiven Q and T , our goal is to identify a T -test suite S that is exhaustive for Q\u2014that is, a test suite such that each abstract reasoner that passes S is guaranteed to be (Q, T )- complete. Depending on the properties of abstract reasoners, however, different test suites may or may not achieve this goal. Therefore, the notion of exhaustiveness is relative to a class of abstract reasoners C: if S is exhaustive for some class of abstract reasoners C, then S can be used to test an arbitrary abstract reasoner in C. Note that S depends on the target class of abstract reasoners, but not on the actual abstract reasoner being tested; in order words, the construction of S depends on the properties that one can assume to hold for the target abstract reasoner. Furthermore, if an abstract reasoner not contained in C passes S, this will in general not imply a (Q, T )-completeness guarantee. Example 3.16. Let Q and T be as specified in Example 3.14, and let A1\u2013A6 be the following ABoxes.\nA1 = {takesCo(c, d),MathCo(d)} A2 = {takesCo(c, c),MathCo(c)} A3 = {takesCo(c, d),CalcCo(d)} A4 = {takesCo(c, c),CalcCo(c)} A5 = {MathSt(c)} A6 = {St(c),Prof(c)}\nIn the following sections, we will show that the Q-simple T -test suite S = S\u22a5,SQ defined by S\u22a5 = {A6} and SQ = {A1, . . . ,A5} is exhaustive for the class CQ,Tw and Q; consequently, S can be used to test all abstract reasoners from Example 3.3.\nIn particular, note that abstract reasoners rdf and rdfs fail all tests in S\u22a5 and SQ, and that abstract reasoner rl fails the test A5 \u2208 SQ; furthermore, all failed tests provide a counterexample of (Q, T )-completeness. In contrast, abstract reasoner classify from Example 3.14 passes the tests in S, which implies that the abstract reasoner is indeed (Q, T )-complete.\nFinally, consider a variant of the abstract reasoner classify that, similarly to the abstract reasoner described in Example 3.9, returns the empty set of answers if the input ABox contains more than, say, ten assertions. Such an abstract reasoner is not (Q, T )-monotonic and hence does not belong to CQ,Tw . This abstract reasoner clearly passes S; however, since it does not belong to CQ,Tw , passing S (correctly) does not imply that the abstract reasoner is (Q, T )-complete. \u2666\nWe next state the following property, the proof of which is trivial.\nProposition 3.17. Let Q be a UCQ, let T be a TBox, and let C1 and C2 be classes of abstract reasoners applicable to T such that C1 \u2286 C2.\n1. If a T -test suite S is exhaustive for C2 and Q, then S is also exhaustive for C1 and Q.\n2. If no T -test suite exists that is exhaustive for C1 and Q, then no T -test suite exists that is exhaustive for C2 and Q.\nTherefore, when proving existence of a T -test suite exhaustive for Q, the most general result is the one that applies to the largest possible class of abstract reasoners. Furthermore,\nin the following section we will identify cases for which no T -test suite exhaustive for Q can be found; by Proposition 3.17 it suffices to provide nonexistence results for the smallest possible class of abstract reasoners.\nWe finish this section by pointing out an important practically relevant property of Q-simple T -test suites, which has been illustrated in Example 3.16.\nProposition 3.18. Let S = S\u22a5,SQ be a Q-simple T -test suite and let ans be an abstract reasoner applicable to T . If ans does not pass S, then ans is not (Q, T )-complete.\nProof. The ABox in S\u22a5 or SQ for which ans does not satisfy the conditions from Definition 3.15 is a counterexample for the (Q, T )-completeness of ans.\nThus, a Q-simple T -test suite S exhaustive for C and Q provides a sufficient and necessary test for (Q, T )-completeness of the abstract reasoners in C. In contrast, if S is not Q-simple, we show in Section 3.7 that then S provides only a sufficient, but not also a necessary test for (Q, T )-completeness of the abstract reasoners in C."}, {"heading": "3.4 Negative Results", "text": "In Sections 3.5 (resp. Section 3.6) we identify restrictions on a UCQ Q and a TBox T that guarantee existence of T -test suites exhaustive for CQ,Tw (resp. CQ,Ts ) and Q. Before presenting these positive results, we first outline the limits of (Q, T )-completeness testing and thus justify the restrictions we use in the following sections."}, {"heading": "3.4.1 Monotonicity and Weak Faithfulness", "text": "Our approaches for testing (Q, T )-completeness of abstract reasoners are applicable only to reasoners that are (Q, T )-monotonic and weakly (Q, T )-faithful. In this section, we provide a formal justification for these requirements in the form of the following two theorems.\n\u2022 Theorem 3.19 shows that exhaustive test suites do not exist if we consider the class of abstract reasoners satisfying all properties from Section 3.1 apart from (Q, T )- monotonicity; this includes soundness, strong faithfulness (which implies weak faithfulness), and monotonicity w.r.t. the TBox only.\n\u2022 Theorem 3.20 shows that exhaustive test suites do not exist if we consider the class of abstract reasoners satisfying all properties defined in Section 3.1 with the exception of (Q, T )-weak faithfulness; these properties include soundness and monotonicity.\nThe negative results of Theorems 3.19 and 3.20 are very strong: they hold for smallest classes of abstract reasoners we can define based on the notions introduced in Section 3.1 (by Proposition 3.17, the smaller the class of abstract reasoners, the more general the negative result); and they hold regardless of the Q and T considered (modulo a minor technicality: unlike Theorem 3.19, Theorem 3.20 requires T to be satisfiable).\nThe proof of Theorem 3.19 can intuitively be understood as follows. We first assume that S is a T -test suite exhaustive for Q and the class of abstract reasoners to which the theorem applies. Then, we specify an abstract reasoner ans that \u2018does the right thing\u2019 (i.e., it returns the correct answer) when it is given as input the query Q, the TBox T , and\nan arbitrary ABox containing at most as many assertions as the largest test ABox in S; otherwise, ans returns a sound, but an incomplete answer. We finally show the following three properties of ans.\n\u2022 Abstract reasoner ans belongs to the relevant class of abstract reasoners.\n\u2022 Abstract reasoner ans passes S.\n\u2022 Abstract reasoner ans is incomplete for at least one input ABox.\nThese three properties then show that S is not exhaustive for Q and the relevant class of abstract reasoners. Intuitively, this means that the class of abstract reasoners is \u2018too large\u2019, allowing abstract reasoners to treat their input in an erratic way.\nTheorem 3.19. Let Q be an arbitrary UCQ, and let T be an arbitrary admissible TBox. Then, no T -test suite exists that is exhaustive for Q and the class of all sound and strongly faithful abstract reasoners applicable to T satisfying the following conditions for each TBox T  with T \u2286 T  and each ABox A:\n\u2022 ans(\u2217, T ,A) = t implies ans(\u2217, T ,A) = t;\n\u2022 ans(\u2217, T ,A) = f and ans(\u2217, T ,A) = f imply ans(Q, T ,A) \u2286 ans(Q, T ,A).\nProof. Consider an arbitrary T -test suite S = S\u22a5,SQ. Let n be the maximum number of assertions in an ABox from S. Furthermore, let ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(\u2217, Tin,Ain) is determined as follows.\n1. Try to find a renaming \u03be such that dom(\u03be) = ind(T ) and \u03be(T ) \u2286 Tin; if no such \u03be exists, then return f.\n2. If Ain contains at most n assertions, then check the satisfiability of \u03be(T ) \u222aAin using a sound and complete reasoner; return t if \u03be(T ) \u222aAin is unsatisfiable.\n3. Return f.\nFurthermore, the result of ans(Qin, Tin,Ain) is determined as follows.\n4. Try to find a renaming \u03be such that dom(\u03be) = ind(Q \u222a T ), \u03be(T ) \u2286 Tin, and \u03be(Q) = Qin; if no such \u03be exists, then return \u2205.\n5. If Ain contains at most n assertions, then compute cert(\u03be(Q), \u03be(T ),Ain) using a sound and complete reasoner and return the result.\n6. Return \u2205.\nSince T is admissible, checks in steps 2 and 5 can be performed in finite time; furthermore, step 1 can be realised by enumerating all mappings from ind(T ) to ind(Tin), and step 4 can be realised analogously; consequently, ans can be implemented such that it terminates on all inputs. To see that ans is sound and monotonic w.r.t. the TBox, consider arbitrary input Qin, Tin, T in, and Ain such that Tin \u2286 T in.\n\u2022 Assume that ans(\u2217, Tin,Ain) = t. Then, on Qin, Tin, and Ain the abstract reasoner returns in step 2 because \u03be(T ) \u222aAin is unsatisfiable; but then, since \u03be(T ) \u2286 Tin, we have that Tin \u222aAin is unsatisfiable as well, as required for soundness. Furthermore, since \u03be(T ) \u2286 Tin \u2286 T in, on Qin, T in, and Ain the abstract reasoner returns in step 2 as well, so ans(\u2217, T in,Ain) = t, as required for monotonicity w.r.t. the TBox.\n\u2022 Assume that a \u2208 ans(Qin, Tin,Ain). Then, on Qin, Tin, and Ain the abstract reasoner returns in step 5, and therefore we have a \u2208 cert(\u03be(Q), \u03be(T ),Ain); but then, since \u03be(Q) = Qin and \u03be(T ) \u2286 Tin, we have a \u2208 cert(Qin, Tin,Ain), as required for soundness. Furthermore, since \u03be(T ) \u2286 Tin \u2286 T in, on Qin, T in, and Ain the abstract reasoner returns in step 5 as well, so a \u2208 ans(Qin, T in,Ain), as required for monotonicity w.r.t. the TBox.\nTo see that ans is strongly faithful, consider an arbitrary renaming \u03bb. If renaming \u03be exists such that \u03be(Q) = Qin and \u03be(T ) \u2286 Tin, then clearly renaming \u03be exists such that \u03be(Q) = \u03bb(Qin) and \u03be(T ) \u2286 \u03bb(Tin). Consequently, if ans(\u2217, Tin,Ain) returns in step 2, then ans(\u2217,\u03bb(Tin),\u03bb(Ain)) returns in step 2 as well; similarly, if ans(Qin, Tin,Ain) returns in step 5, then ans(\u03bb(Qin),\u03bb(Tin),\u03bb(Ain)) returns in step 5 as well; clearly, ans is strongly faithful. Finally, it is straightforward to see that ans passes S.\nNow let A be an ABox containing at least n + 1 assertions such that cert(Q, \u2205,A) = \u2205; such A clearly exists. If T \u222aA is unsatisfiable, then ans(\u2217, T ,A) = f; furthermore, if T \u222aA is satisfiable, then ans(Q, T ,A) = \u2205; consequently, ans is not (Q, T )-complete. Thus, S is not exhaustive for Q and the class of abstract reasoners considered in this theorem.\nWe next prove Theorem 3.20. The proof is similar to the proof of Theorem 3.19, and the main difference is in the abstract reasoner ans we construct. In particular, given a test suite S, we take ans to return the correct answer on the query Q, the TBox T , and each ABox that contains only the individuals occurring in S; otherwise, the abstract reasoner returns a sound, but an incomplete answer. Again, the class of the abstract reasoners is \u2018too large\u2019, allowing ans to treat inputs in an erratic way.\nUnlike Theorem 3.19, the following theorem requires T to be satisfiable; to understand why, consider an arbitrary unsatisfiable TBox T and UCQ Q. Let S = S\u22a5,SQ be the T -test suite defined by S\u22a5 = {\u2205} (i.e., S\u22a5 contains a single empty ABox) and SQ = \u2205 (i.e., SQ contains no ABoxes), and consider an arbitrary monotonic abstract reasoner ans that passes S\u22a5. Since ans passes S, we have ans(\u2217, T , \u2205) = t; but then, since ans is monotonic, for an arbitrary ABox A we have ans(\u2217, T ,A) = t as well, which in turn implies that ans is (Q, T )-complete. Failure to satisfy weak faithfulness is thus irrelevant if T is unsatisfiable.\nTheorem 3.20. Let T be an arbitrary admissible and satisfiable TBox and let Q be an arbitrary UCQ. Then, no T -test suite exists that is exhaustive for Q and the class of all sound and monotonic abstract reasoners applicable to T .\nProof. Consider an arbitrary T -test suite S = S\u22a5,SQ. Let I be the set of all individuals occurring in S, Q, and T . Furthermore, let ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(\u2217, Tin,Ain) is determined as follows.\n1. If T \u2286 Tin, then return f.\n2. Let Ain,I be the set of assertions in Ain that mention only the individuals in I.\n3. Check the satisfiability of T \u222aAin,I using a sound and complete reasoner; return t if T \u222aAin,I is unsatisfiable, and return f otherwise.\nFurthermore, given a UCQ Qin, the result of ans(Qin, Tin,Ain) is determined as follows:\n4. If T \u2286 Tin or Q = Qin, then return \u2205.\n5. Let Ain,I be the set of assertions in Ain that mention only the individuals in I.\n6. Compute cert(Q, T ,Ain,I) using a sound and complete reasoner and return the result.\nThat ans can be implemented such that it terminates on all inputs can be shown as in the proof of Theorem 3.19. Furthermore, the soundness of ans follows from the following two observations.\n\u2022 Assume that ans(\u2217, Tin,Ain) = t. Then, the abstract reasoner returns in step 3 since T \u222aAin,I is unsatisfiable; but then, since T \u2286 Tin and Ain,I \u2286 Ain, we have that Tin \u222aAin is unsatisfiable as well, as required.\n\u2022 Assume that a \u2208 ans(Qin, Tin,Ain). Then, the abstract reasoner returns in step 6, and therefore we have a \u2208 cert(Q, T ,Ain,I); but then, since Q = Qin, T \u2286 Tin, and Ain,I \u2286 Ain, we have a \u2208 cert(Qin, Tin,Ain), as required.\nFor monotonicity, consider an arbitrary T in and Ain such that Tin \u2286 T in and Ain \u2286 Ain; clearly, we have T \u2286 T in and Ain,I \u2286 Ain,I ; but then, by monotonicity of first-order logic, ans(\u2217, Tin,Ain) = t implies ans(\u2217, T in,Ain) = t, and ans(Q, Tin,Ain) \u2286 ans(Q, T in,Ain). Finally, it is straightforward to see that ans passes S.\nNow consider an arbitrary ABox A such that ind(A) \u2229 I = \u2205 and cert(Q, \u2205,A) = \u2205; such A clearly exists. If T \u222aA is unsatisfiable, since the ABox constructed in step 2 is empty and T is satisfiable, we have ans(\u2217, T ,A) = f; furthermore, if T \u222aA is satisfiable, since the ABox constructed in step 5 is empty, ans(Q, T ,A) cannot contain individuals not occurring in I; consequently, ans is not (Q, T )-complete. Thus, S is not exhaustive for Q and the class of abstract reasoners considered in this theorem."}, {"heading": "3.4.2 Monotonicity and Weak Faithfulness do not Suffice", "text": "Next, we show that (Q, T )-monotonicity and (Q, T )-faithfulness in general do not guarantee existence of a T -test suite exhaustive for Q. In particular, Theorem 3.21 shows that, if T contains a single recursive axiom, no test suite exists that is exhaustive for the class of all sound, monotonic, and strongly faithful abstract reasoners (and by Proposition 3.17 for CQ,Ts and CQ,Tw as well, for each UCQ Q). Although our result is applicable only to a particular Q and T , it is straightforward to adapt the proof to any TBox with a recursive axiom that is \u2018relevant\u2019 to the given query. Example 3.22, however, shows that the concept of \u2018relevance\u2019 is rather difficult to formalise: even if T entails a recursive axiom, this axiom is not necessarily \u2018relevant\u2019 to answering the query. In order not to complicate matters any further, we state the following result for fixed Q and T , and we hope that our proof clearly illustrates the limitations incurred by recursive axioms.\nTheorem 3.21. For Q = {A(x) \u2192 Q(x)} and T = {\u2203R.A  A}, no T -test suite exists that is exhaustive for Q and the class of all sound, monotonic, and strongly faithful abstract reasoners applicable to T .\nProof. Consider an arbitrary T -test suite S = S\u22a5,SQ. Since S is a T -test suite, S\u22a5 contains only ABoxes A such that T \u222aA is unsatisfiable; clearly, no such ABox exists for T as stated in the theorem, so S\u22a5 = \u2205. Let SQ be an arbitrary, but finite, set of pairs A,Y with A an ABox and Y a UCQ, and let n be the maximum number of assertions in an ABox in SQ. Furthermore, consider the following ABox, where ai = aj for all 1 \u2264 i < j \u2264 n + 1:\nAn+1 = {R(a0, a1), . . . , R(an, an+1), A(an+1)}\nWe next construct an abstract reasoner pEvaln with the following properties:\n(P1) for each A,Y \u2208 SQ, we have cert(Y, T ,A) \u2286 pEvaln(Y, T ,A);\n(P2) a0 \u2208 pEvaln(Q, T ,An+1); and\n(P3) pEvaln is sound, monotonic, and strongly faithful.\nNote that a0 \u2208 cert(Q, T ,An+1), so the above three properties imply that S is not exhaustive for Q and the class of abstract reasoners considered in this theorem.\nAbstract reasoner pEvaln accepts as input an FOL-TBox Tin and an ABox Ain. The result of pEvaln(\u2217, Tin,Ain) is determined as follows.\n1. Return f.\nFurthermore, given a UCQ Qin, the result of pEvaln(Qin, Tin,Ain) is determined as follows.\n2. If T \u2286 Tin or Q = Qin, return \u2205.\n3. Asat := Ain\n4. Repeat the following computation n times:\n\u2022 Asat := Asat \u222a {\u03c3(A(x)) | \u03c3 is a substitution s.t. {\u03c3(R(x, y)),\u03c3(A(y))} \u2286 Asat}\n5. Return cert(Q, \u2205,Asat).\nAbstract reasoner pEvaln clearly satisfies Property (P2) because deriving the assertion A(a0) requires n+1 iterations of the loop in step 4. Furthermore, pEvaln also satisfies (P1) because every ABox A occurring in SQ contains at most n individuals and T can be seen as the rule R(x, y) \u2227A(y) \u2192 A(x), which pEvaln applies n times to the input ABox Ain.\nWe finally show (P3). Abstract reasoner pEvaln is clearly sound. Furthermore, for each renaming \u00b5 we have \u00b5(T ) = T and \u00b5(Q) = Q, so pEvaln is clearly strongly faithful.\nTo show that pEvaln is monotonic, consider arbitrary Tin, T in, Ain, and Ain such that Tin \u2286 T in and Ain \u2286 Ain; since pEvaln(\u2217, Tin,Ain) = f for each input, the following are the only relevant cases.\n\u2022 pEvaln returns \u2205 in step 2 on input Qin, T in, and Ain, in which case either T \u2286 T in or Q = Qin. Since Tin \u2286 T in, clearly pEvaln also returns \u2205 in step 2 on input Qin, Tin, and Ain, and monotonicity holds.\n\u2022 pEvaln returns in step 5 on input Qin, T in, and Ain. Then, pEvaln can return in either step 2 or step 5 on input Qin, Tin and Ain; in the former case, monotonicity holds trivially, and in the latter case, pEvaln(Qin, Tin,Ain) \u2286 pEvaln(Qin, T in,Ain) follows directly from the fact that Ain \u2286 Ain.\nThe following example shows that the presence of recursive axioms in T does not preclude the existence of a T -test suite exhaustive for Q.\nExample 3.22. Consider Q and T defined as follows:\nQ = {A(x) \u2227B(x) \u2192 Q(x)} T = {\u2203R.A  A, B  \u2203R.A}\nNote that T contains the axiom mentioned in Theorem 3.21; however, note also that T |= B  A, and so\nR = \u2205, {B(x) \u2192 Q(x)}\nis a UCQ rewriting of Q w.r.t. T . In Section 3.5 we show that the existence of a UCQ rewriting of Q w.r.t. T guarantees existence of a Q-simple T -test suite that is exhaustive for CQ,Tw (and hence also for CQ,Ts ) and Q; for example, S = \u2205, { {B(a)} } is one such T -test suite. Intuitively, T |= B  A is the only consequence of T that is relevant for answering Q; hence, for T  = {B  A} andQ = {A(x) \u2192 Q(x)}, we have that cert(Q, T ,A) = cert(Q, T ,A) for an arbitrary ABox A. Hence, the recursive axiom in T is \u2018irrelevant\u2019 for answering Q, and therefore its presence in T does not preclude the existence of a T -test suite that is exhaustive for CQ,Tw and Q. \u2666\n3.5 Testing (Q, T )-Monotonic and Weakly (Q, T )-Faithful Abstract Reasoners\nIn this section, we identify a sufficient condition that guarantees existence of a Q-simple T -test suite S exhaustive for CQ,Tw and Q; by Proposition 3.17, this result applies to CQ,Ts as well. Roughly speaking, such S can always be computed by \u2018instantiating\u2019 the rules in a UCQ rewriting of Q w.r.t. T in a suitable way. The requirement that Q should be UCQrewritable w.r.t. T invalidates the negative result of Theorem 3.21 since no UCQ rewriting of Q = {A(x) \u2192 Q(x)} w.r.t. T = {\u2203R.A  A} exists.\nThis result allows one to compute Q-simple T -test suites exhaustive for Q in numerous practically relevant cases. In particular, a UCQ rewriting is guaranteed to exist if T is expressed in the DLs underpinning the QL profile of OWL 2 (Motik et al., 2009a; Calvanese et al., 2007); furthermore, as illustrated in Example 3.22, a UCQ rewriting may exist even if T is expressed in other fragments of OWL 2 such as the OWL 2 EL (Motik et al., 2009a; Baader, Brandt, & Lutz, 2005). In practice, such rewritings can be computed using systems such as QuOnto (Acciarri et al., 2005) and REQUIEM (Pe\u0301rez-Urbina et al., 2010).\nWe establish the desired result in two steps. First, in Section 3.5.1 we present a general characterisation of Q-simple T -test suites exhaustive for CQ,Tw and Q. Then, in Section 3.5.2 we use this characterisation to establish the desired connection between rewritings and Q-simple T -test suites exhaustive for Q."}, {"heading": "3.5.1 Characterisation of Simple and Exhaustive Test Suites", "text": "We next prove that a Q-simple T -test suite S = S\u22a5,SQ is exhaustive for CQ,Tw and Q if and only if S contains an isomorphic copy of each \u2018data pattern\u2019 (i.e., a subset of an ABox) that can produce a certain answer to Q and \u2217 w.r.t. T , but that \u2018preserves\u2019 the identity of the individuals occurring in T and Q. To show that this is not just a sufficient, but also a necessary condition for the existence of an exhaustive T -test suite, we observe that, if S does not contain one such copy of a \u2018data pattern\u2019, we can always find an abstract reasoner in CQ,Tw that passes S but that misses certain answers obtained via the missing data pattern and that is therefore not (Q, T )-complete.\nTheorem 3.23. Let Q be a UCQ, let T be an admissible TBox, and let S = S\u22a5,SQ be a Q-simple T -test suite. Then, S is exhaustive for CQ,Tw and Q if and only if the following properties are satisfied for each ABox A.\n1. If T \u222aA is unsatisfiable, then there exist an ABox A \u2208 S\u22a5 and an injective T -stable renaming \u00b5 such that dom(\u00b5) = ind(T \u222aA) and \u00b5(A) \u2286 A.\n2. If T \u222aA is satisfiable, then for each tuple a \u2208 cert(Q, T ,A) there exist an ABox A \u2208 SQ, a tuple b \u2208 cert(Q, T ,A), and an injective (Q, T )-stable renaming \u00b5 such that \u00b5(b) = a, dom(\u00b5) = ind(Q \u222a T \u222aA), and \u00b5(A) \u2286 A.\nProof. (\u21d0) Let S be an arbitrary Q-simple T -test suite that satisfies Properties 1 and 2; we next show that S is exhaustive for CQ,Tw and Q. Consider an arbitrary abstract reasoner ans \u2208 CQ,Tw that passes S\u2014that is, ans satisfies the following two properties:\n(a) ans(\u2217, T ,A) = t for each A \u2208 S\u22a5, and\n(b) ans(\u2217, T ,A) = f implies cert(Q, T ,A) \u2286 ans(Q, T ,A) for each A \u2208 SQ.\nWe next show that ans is (Q, T )-complete\u2014that is, that ans satisfies the two conditions in Definition 3.13 for an arbitrary ABox A. For an arbitrary such A, we have the following two possibilities, depending on the satisfiability of T \u222aA.\nAssume that T \u222a A is unsatisfiable. Since S satisfies Property 1, there exist an ABox A \u2208 S\u22a5 and an injective T -stable renaming \u00b5 s.t. dom(\u00b5) = ind(T \u222aA) and \u00b5(A) \u2286 A. By Condition (a) we have ans(\u2217, T ,A) = t. Since ans is weakly (Q, T )-faithful, \u00b5 is injective and T -stable, and dom(\u00b5) = ind(T \u222aA), we have ans(\u2217, T , \u00b5(A)) = t; finally, since ans is (Q, T )-monotonic and \u00b5(A) \u2286 A, we have ans(\u2217, T ,A) = t, as required by Definition 3.13.\nAssume that T \u222a A is satisfiable and ans(\u2217, T ,A) = f. Furthermore, consider an arbitrary tuple a \u2208 cert(Q, T ,A). Since S satisfies Property 2, there exist an ABox A \u2208 SQ, a tuple b \u2208 cert(Q, T ,A), and an injective (Q, T )-stable renaming \u00b5 such that \u00b5(b) = a, dom(\u00b5) = ind(Q \u222a T \u222aA), and \u00b5(A) \u2286 A. Since \u00b5(A) \u2286 A, ans(\u2217, T ,A) = f, and ans is (Q, T )-monotonic, we have ans(\u2217, T , \u00b5(A)) = f; furthermore, ind(T \u222aA) \u2286 dom(\u00b5), \u00b5 is injective and (Q, T )-stable, and ans is weakly (Q, T )-faithful, so ans(\u2217, T , \u00b5(A)) = f implies ans(\u2217, T ,A) = f. But then, by Condition (b) we have cert(Q, T ,A) \u2286 ans(Q, T ,A), so b \u2208 ans(Q, T ,A). Since ans is weakly (Q, T )-faithful, \u00b5 is injective and (Q, T )-stable, and dom(\u00b5) = ind(Q \u222a T \u222aA), we have \u00b5(b) \u2208 ans(Q, T , \u00b5(A)); since \u00b5(b) = a, we have\na \u2208 ans(Q, T , \u00b5(A)); finally, since ans is (Q, T )-monotonic and \u00b5(A) \u2286 A, we then have a \u2208 ans(Q, T ,A), as required by Definition 3.13.\n(\u21d2) Assume that S is exhaustive for CQ,Tw and Q; we next show that Properties 1 and 2 are satisfied for an arbitrary ABoxA. To this end, we consider a particular abstract reasoner ans for which we prove that ans \u2208 CQ,Tw and that ans passes S; this abstract reasoner will help us identify the ABox, the tuple, and the renaming required to prove Properties 1 and 2.\nLet ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(\u2217, Tin,Ain) is determined as follows.\n1. If T = Tin, then return f.\n2. For each ABox A \u2208 S\u22a5, do the following.\n(a) Check the satisfiability of T \u222a A using a sound, complete, and terminating reasoner.\n(b) If T \u222aA is unsatisfiable, and if an injective T -stable renaming \u00b5 exists such that dom(\u00b5) = ind(T \u222aA) and \u00b5(A) \u2286 Ain, then return t.\n3. Return f.\nFurthermore, the result of ans(Qin, Tin,Ain) is determined as follows.\n4. If T = Tin or Q = Qin, then return \u2205.\n5. Out := \u2205.\n6. For each tuple a of constants occurring in Ain of arity equal to the arity of the query predicate of Q, and for each A \u2208 SQ do the following.\n(a) Compute C := cert(Q, T ,A) using a sound, complete and terminating reasoner. (b) If a tuple b \u2208 C and an injective (Q, T )-stable renaming \u00b5 exist such that\n\u00b5(b) = a, dom(\u00b5) = ind(Q \u222a T \u222aA), and \u00b5(A) \u2286 Ain, then add a to Out.\n7. Return Out.\nWe next show that ans belongs to CQ,Tw ; to this end, we prove that ans terminates on all inputs, and that it is (Q, T )-monotonic and weakly (Q, T )-faithful. Termination. Since T is admissible, checking satisfiability of T \u222aA and the computation of cert(Q, T ,A) are decidable, so the relevant sound, complete and terminating reasoners exist. Furthermore, checking whether a T -stable (resp. (Q, T )-stable) injective renaming \u00b5 exists can be done by enumerating all renamings from ind(T \u222aA) (resp. ind(Q \u222a T \u222aA)) to ind(T \u222aAin) (resp. ind(Q \u222a T \u222aAin)). Therefore, ans can be implemented such that it terminates on each input. (Q, T )-Monotonicity. Consider arbitrary input Qin, Tin, Ain, and Ain such that Ain \u2286 Ain.\n\u2022 Assume that ans(\u2217, Tin,Ain) = t, so on Tin and Ain the abstract reasoner terminates in step 2(b) for some A \u2208 S\u22a5 and \u00b5. But then, since \u00b5(A) \u2286 Ain \u2286 Ain, on Tin and Ain the abstract reasoner also terminates in step 2(b), so ans(\u2217, Tin,Ain) = t, as required.\n\u2022 Assume that ans(\u2217, Tin,Ain) = f and ans(\u2217, Tin,Ain) = f, and consider an arbitrary tuple a \u2208 ans(Qin, Tin,Ain). Then a is added to Out in step 7(b) for some A \u2208 SQ and \u00b5. But then, since \u00b5(A) \u2286 Ain \u2286 Ain, on Qin, Tin, and Ain the abstract reasoner also adds a to Out in step 7(b), so a \u2208 ans(Qin, Tin,Ain), as required.\nWeak (Q, T )-Faithfulness. Consider an arbitrary input Qin, Tin, and Ain, and an arbitrary injective renaming \u03bb.\n\u2022 Assume that ans(\u2217, Tin,Ain) = t, dom(\u03bb) \u2286 ind(T \u222aA), and \u03bb is T -stable. Thus, on Tin and Ain the abstract reasoner terminates in step 2(b) for some A \u2208 S\u22a5 and \u00b5. Let \u00b5 be the renaming such that \u00b5(c) = \u03bb(\u00b5(c)) for each c \u2208 ind(T \u222aA). Clearly, we have dom(\u00b5) = ind(T \u222aA), renaming \u00b5 is T -stable and injective, and \u00b5(A) \u2286 \u03bb(Ain). Thus, on Tin and \u03bb(Ain) the abstract reasoner terminates in step 2(b), so we therefore have ans(\u2217, Tin,\u03bb(Ain)) = t, as required.\n\u2022 Assume that ans(\u2217, Tin,Ain) = f, dom(\u03bb) \u2286 ind(Q \u222a T \u222aA), and \u03bb is (Q, T )-stable, and consider an arbitrary truple a \u2208 ans(Qin, Tin,Ain). Then a is added to Out in step 7(b) for some A \u2208 SQ, \u00b5, and b. Let \u00b5 be the renaming defined s.t. \u00b5(c) = \u03bb(\u00b5(c)) for each individual c \u2208 ind(Q \u222a T \u222aA). Clearly, we have dom(\u00b5) = ind(Q \u222a T \u222aA), renaming \u00b5 is (Q, T )-stable and injective, \u00b5(A) \u2286 \u03bb(Ain), and \u00b5(b) = \u03bb(a). Thus, on Qin, Tin, and \u03bb(Ain) the abstract reasoner terminates in step 7(b) and we clearly have \u03bb(a) \u2208 ans(Qin, Tin,\u03bb(Ain)), as required.\nThis concludes the proof that ans \u2208 CQ,Tw . Furthermore, ans clearly passes S; but then, since S is exhaustive for CQ,Tw and Q, abstract reasoner ans is (Q, T )-complete. We next prove the main claim of this theorem. To this end, consider an arbitrary ABox A; we have the following possibilities, depending on the satisfiability of T \u222aA.\n\u2022 Assume that T \u222aA is unsatisfiable. Then ans(\u2217, T ,A) = t, so the abstract reasoner returns in step 2(b) for some ABox A \u2208 S\u22a5 and some T -stable renaming \u00b5 such that \u00b5(A) \u2286 A and dom(\u00b5) = ind(T \u222aA). Thus, Property 1 holds as required.\n\u2022 Assume that T \u222aA is satisfiable, and consider an arbitrary tuple a \u2208 cert(Q, T ,A). Then ans(\u2217, T ,A) = f and a \u2208 ans(Q, T ,A), so a is added to Out in step 7(b) for some ABox A \u2208 SQ, tuple b \u2208 cert(Q, T ,A), and an injective (Q, T )-stable renaming \u00b5 such that \u00b5(b) = a, dom(\u00b5) = ind(Q \u222a T \u222aA), and \u00b5(A) \u2286 A. Thus, Property 2 holds as required.\nThe following example illustrates Theorem 3.23.\nExample 3.24. Let Q and T be as specified in Example 3.14, and let S = S\u22a5,SQ be specified in Example 3.16. As we show in Section 3.5.2, S is exhaustive for CQ,Tw and Q.\nConsider now an ABox A = {St(a),MathSt(b), takesCo(a, b1)}. Clearly, T \u222a A is satisfiable and cert(Q, T ,A) = {b}. By Theorem 3.23, this certain answer can be obtained by evaluating Q w.r.t. T and an ABox in SQ. Indeed, note that ABox A5 \u2208 SQ is isomorphic to the subset A = {MathSt(b)} of A via renaming \u00b5 = {b \u2192 c}, and that applying Q to T and A5 produces c, which is isomorphic to b via \u00b5.\nNote also that, if we remove A5 from S, we no longer have a T -test suite that is exhaustive for Q. For example, abstract reasoner rl from Example 3.16 would pass such a test suite, but it would not return the required certain answers when applied to A5 (and, consequently, when applied to A either). \u2666\n3.5.2 Computing Test Suites Exhaustive for CQ,Tw Based on Theorem 3.23, in this section we show that a T -test suite exhaustive for CQ,Tw and Q an be obtained by instantiating a UCQ rewriting R of Q w.r.t. T \u2014that is, by replacing all variables in R with individuals in all possible ways. Please note that such an instantiation must be full, in the sense that all possible replacements must be considered. This is because the class CQ,Tw can contain abstract reasoners such as rl= from Example 3.11 that are not strongly faithful and that may incorrectly handle the case when distinct variables are bound to the same individuals.\nDefinition 3.25. Let I be a set of individuals, let r be a datalog rule, and let \u03c3 be a substitution. Then, \u03c3 is an instantiation substitution for r w.r.t. I if \u03c3(x) \u2208 I for each variable x occurring in r. If the latter holds, then the instantiation of r w.r.t. \u03c3 is the ABox\nAr\u03c3 := {\u03c3(B) | B \u2208 body(r)}.\nLet Q be a UCQ, let T be a TBox, let R = R\u22a5,RQ be a UCQ rewriting of Q w.r.t."}, {"heading": "T , let m be the maximum number of distinct variables occurring in a rule in R, and let I be a set containing all individuals occurring in R, Q, and T , as well as m fresh individuals.", "text": "The full instantiation of R w.r.t. I is the pair ER,I = ER,I\u22a5 ,E R,I Q  where E R,I \u22a5 and E R,I Q are the smallest sets of ABoxes such that\n\u2022 Ar\u03c3 \u2208 E R,I \u22a5 for each r \u2208 R\u22a5 and each instantiation substitution \u03c3 for r w.r.t. I, and\n\u2022 Ar\u03c3 \u2208 E R,I Q for each r \u2208 RQ and each instantiation substitution \u03c3 for r w.r.t. I such\nthat cert(\u2217,R\u22a5,Ar\u03c3) = f.\nER,I is clearly unique up to the renaming of the fresh individuals in I, so I is typically left implicit, and one talks of the full instantiation ER = ER\u22a5 ,ERQ of R.\nExample 3.26. Let Q and T be as specified in Example 3.14, and let R = R\u22a5,RQ be such that R\u22a5 = {St(x) \u2227 Prof(x) \u2192 \u22a5} and RQ consists of the following datalog rules:\ntakesCo(x, y) \u2227MathCo(y) \u2192 Q(x) takesCo(x, y) \u2227 CalcCo(y) \u2192 Q(x)\nMathSt(x) \u2192 Q(x)\nThen, R is a UCQ rewriting of Q w.r.t. T , and one can see that the Q-simple T -test suite S = S\u22a5,SQ from Example 3.16 is the full instantiation of R. \u2666\nThe following theorem shows that the full instantiation of a UCQ rewriting of Q w.r.t. T is a Q-simple T -test suite exhaustive for CQ,Tw and Q. According to this theorem, the T -test suite S in Example 3.26 is exhaustive for CQ,Tw and Q.\nTheorem 3.27. Let Q be a UCQ, let T be an admissible TBox, let R = R\u22a5,RQ be a UCQ rewriting of Q w.r.t. T , and let ER = ER\u22a5 ,ERQ be the full instantiation of R. Then, ER is a Q-simple T -test suite that is exhaustive for CQ,Tw and Q.\nProof. Let I be the set of individuals that ER is obtained from. We first show that ER is a Q-simple T -test suite\u2014that is, that it satisfies the two properties in Definition 3.15.\n\u2022 Consider an arbitrary ABox A \u2208 ER\u22a5 . Then, a rule r \u2208 R\u22a5 and an instantiation substitution \u03c3 for r exist such that A = Ar\u03c3; clearly cert(\u2217, {r},A) = t; since R is a UCQ rewriting, T \u222aA is unsatisfiable, as required.\n\u2022 Consider an arbitrary ABox A \u2208 ERQ . Then, cert(\u2217,R\u22a5,A) = f by Definition 3.25; since R is a UCQ rewriting, T \u222aA is satisfiable, as required.\nWe next show that ER satisfies Properties 1 and 2 of Theorem 3.23 for an arbitrary ABox A.\n(Property 1) Assume that T \u222aA is unsatisfiable. Since R is a UCQ rewriting, by Definition 2.2 we have cert(\u2217,R\u22a5,A) = t; but then, a rule r \u2208 R\u22a5 and a substitution \u03c1 exist such that Ar\u03c1 \u2286 A and cert(\u2217, {r},Ar\u03c1) = t. Let \u03bd be an injective renaming such that for each individual c occurring in R or T we have \u03bd(c) = c, and for each individual d occurring in Ar\u03c1 but not in R and T we have that \u03bd(d) is a fresh individual in I; such \u03bd exists since the number of variables in r is smaller or equal to the number of fresh individuals in I. Let \u03c3 be an instantiation substitution for r such that \u03c3(x) = \u03bd(\u03c1(x)) for each variable x occurring in r; then Ar\u03c3 \u2208 ER\u22a5 holds since ER is the full instantiation of R w.r.t. I. Let \u00b5 be any injective renaming that coincides with the inverse of \u03bd on each individual occurring in Ar\u03c3, R, or T ; such \u00b5 exists since \u03bd is injective and the range of \u03bd contains each individual occurring in Ar\u03c3, R, and T . Clearly \u00b5(Ar\u03c3) = Ar\u03c1 holds, so \u00b5(Ar\u03c3) \u2286 A. Furthermore, \u00b5 is clearly T -stable. Thus, Property (1) is satisfied for Ar\u03c3 \u2208 ER\u22a5 and \u00b5.\n(Property 2) Assume that T \u222aA is satisfiable, and consider an arbitrarily chosen tuple a \u2208 cert(Q, T ,A). Since R is a UCQ rewriting, by Definition 2.2 we have cert(\u2217,R\u22a5,A) = f and a \u2208 cert(RQ,R\u22a5,A); but then, clearly a \u2208 cert(RQ, \u2205,A) as well. Then, a rule r \u2208 RQ and a substitution \u03c1 exist such that Ar\u03c1 \u2286 A and a \u2208 cert({r}, \u2205,Ar\u03c1). Let \u03bd be an injective renaming such that for each individual c occurring in R, Q, or T we have \u03bd(c) = c, and for each individual d occurring in Ar\u03c1 but not in R, Q, and T we have that \u03bd(d) is a fresh individual in I; such \u03bd clearly exists since the number of variables in r is smaller or equal to the number of fresh individuals in I. Let \u03c3 be an instantiation substitution for r such that \u03c3(x) = \u03bd(\u03c1(x)) for each variable x occurring in r; then Ar\u03c3 \u2208 ERQ holds since ER is the full instantiation of R w.r.t. I. Let \u00b5 be any injective renaming that coincides with the inverse of \u03bd on each individual occurring in Ar\u03c3, R, Q, or T ; such \u00b5 exists since \u03bd is injective and the range of \u03bd contains each individual occurring in Ar\u03c3, R, Q, and T . Furthermore, clearly a tuple b \u2208 cert({r}, \u2205,Ar\u03c3) exists such that \u03c3(head(r)) = Q(b); since R is a UCQ rewriting and T \u222aAr\u03c3 is satisfiable, we have b \u2208 cert(Q, T ,Ar\u03c3); furthermore, since \u00b5 is injective, \u00b5(b) = a clearly holds. But then, Property (2) is satisfied for Ar\u03c3 \u2208 ERQ , \u00b5, and b."}, {"heading": "3.5.3 Minimising Exhaustive Test Suites", "text": "In practice, it is clearly beneficial to compute test suites that are as \u2018small\u2019 as possible. This goal can be achieved by applying known techniques for minimising UCQ rewritings (Calvanese et al., 2007; Pe\u0301rez-Urbina, Horrocks, & Motik, 2009). By Theorem 3.27, the smallest such rewriting can be instantiated to obtain an exhaustive test suite.\nState of the art query rewriting systems employ subsumption and condensation techniques in order to reduce the size of a rewriting. A datalog rule r subsumes a datalog rule r if a substitution \u03c3 exists such that \u03c3(r) \u2286 r; intuitively, r is then \u2018more general\u2019 than r. If a rewriting contains such rules r and r, then r can be safely removed from the rewriting. Furthermore, if a rule r contains distinct unifiable body atoms Bi and Bj , a condensation of r is the rule \u03c3(r) where \u03c3 is the most general unifier of Bi and Bj . If a rewriting contains such rule r and \u03c3(r) subsumes r, the rule can safely be replaced with \u03c3(r). The following example illustrates how these techniques can be used to obtain small test suites.\nExample 3.28. Let Q and T be as specified in Example 3.14, and let R be the rewriting of Q w.r.t. T from Example 3.26. Then R = R\u22a5,RQ where RQ consists of the following rules is also a UCQ rewriting of Q w.r.t. T .\ntakesCo(x, y) \u2227 takesCo(x, z) \u2227MathCo(y) \u2192 Q(x) (12) takesCo(x, x) \u2227 CalcCo(x) \u2227MathCo(x) \u2192 Q(x) (13)\ntakesCo(x, y) \u2227 CalcCo(y) \u2192 Q(x) (14) St(x) \u2227MathSt(x) \u2192 Q(x) (15)\nMathSt(x) \u2192 Q(x) (16)\nBy Theorem 3.27, the full instantiation of R is also a T -test suite exhaustive for CQ,Tw and Q. The rewriting R, however, contains redundancy and hence the resulting test suite is unnecessarily large. In particular, by applying condensation to query (12), subsumption to queries (13) and (14), and subsumption again to queries (15) and (16), we can obtain the simpler rewriting R. \u2666\nFinally, note that the test suites obtained via full instantiation can contain isomorphic ABoxes. Clearly, all isomorphic copies of an ABox can safely be eliminated from a test suite without losing exhaustiveness for CQ,Tw and Q.\n3.6 Testing (Q, T )-Monotonic and Strongly (Q, T )-Faithful Abstract Reasoners Due to full instantiation, test suites obtained by Definition 3.25 can be exponentially larger than the rewriting they are generated from. As a result, even rewritings of moderate size can yield test suites containing thousands of ABoxes. Intuitively, full instantiation is required to obtain a test suite exhaustive for the class CQ,Tw because this class contains abstract reasoners such as rl= from Example 3.11, which do not correctly handle the case when distinct variables in a query are matched to the same individual.\nIn this section, we show that test suites exhaustive for the class CQ,Ts can be obtained by an injective instantiation of a rewriting\u2014that is, by replacing each variable with a distinct fresh individual. Test suites obtained in such a way are linear in the size of the rewriting, and are thus substantially smaller than test suites obtained by full instantiation.\nExample 3.29. Let Q and T be as specified in Example 3.14, and let S = S\u22a5,SQ be the Q-simple T -test suite from Example 3.16. Furthermore, consider the abstract reasoner rl= from Example 3.11 that is weakly, but not strongly (Q, T )-faithful. It is easy to check that rl= returns complete answers on A1 and A3, but not on A2 and A4. Therefore, by Theorem 3.27, for S to be exhaustive for CQ,Tw and Q, we must include in SQ ABoxes A2 and A4, which are respectively obtained from ABoxes A1 and A3 by merging individual d into c.\nStrongly (Q, T )-faithful abstract reasoners, however, correctly handle inputs obtained by merging individuals. Based on this observation, in this section we show that the Q-simple T -test suite S = S\u22a5,SQ where SQ = {A1,A3,A5}, obtained by injectively instantiating the rewriting R from Example 3.26, is exhaustive for CQ,Ts and Q. \u2666\nAs in Section 3.5, we first develop a characterisation of Q-simple T -test suites that are exhaustive for CQ,Ts and Q; this result is analogous to Theorem 3.23.\nTheorem 3.30. Let Q be a UCQ, let T be an admissible TBox, and let S = S\u22a5,SQ be a Q-simple T -test suite. Then, S is exhaustive for CQ,Ts and Q if and only if the following properties are satisfied for each ABox A.\n1. If T \u222aA is unsatisfiable, then there exist an ABox A \u2208 S\u22a5 and a T -stable renaming \u00b5 such that dom(\u00b5) = ind(T \u222aA) and \u00b5(A) \u2286 A.\n2. If T \u222aA is satisfiable, then for each tuple a \u2208 cert(Q, T ,A) there exist an ABox A \u2208 SQ, a tupleb \u2208 cert(Q, T ,A), and a (Q, T )-stable renaming \u00b5 such that \u00b5(b) = a, dom(\u00b5) = ind(Q \u222a T \u222aA), and \u00b5(A) \u2286 A.\nProof. (\u21d0) Let S be an arbitrary Q-simple T -test suite that satisfies Properties 1 and 2; we next show that S is exhaustive for CQ,Ts and Q. Consider an arbitrary abstract reasoner ans \u2208 CQ,Ts that passes S\u2014that is, ans satisfies the following two properties:\n(a) ans(\u2217, T ,A) = t for each A \u2208 S\u22a5, and\n(b) ans(\u2217, T ,A) = f implies cert(Q, T ,A) \u2286 ans(Q, T ,A) for each A \u2208 SQ.\nWe next show that ans is (Q, T )-complete\u2014that is, that ans satisfies the two conditions in Definition 3.13 for an arbitrary ABox A. For an arbitrary such A, we have the following two possibilities, depending on the satisfiability of T \u222aA.\nAssume that T \u222a A is unsatisfiable. Since S satisfies Property 1, there exist an ABox A \u2208 S\u22a5 and a T -stable renaming \u00b5 such that dom(\u00b5) = ind(T \u222aA) and \u00b5(A) \u2286 A. By Condition (a) we have ans(\u2217, T ,A) = t. Since ans is strongly (Q, T )-faithful and \u00b5 is T - stable, we have ans(\u2217, T , \u00b5(A)) = t; finally, since ans is (Q, T )-monotonic and \u00b5(A) \u2286 A, we have ans(\u2217, T ,A) = t, as required by Definition 3.13.\nAssume that T \u222a A is satisfiable and ans(\u2217, T ,A) = f. Furthermore, consider an arbitrary tuple a \u2208 cert(Q, T ,A). Since S satisfies Property 2, there exist an ABox A \u2208 SQ, a tupleb \u2208 cert(Q, T ,A), and a (Q, T )-stable renaming \u00b5 such that \u00b5(b) = a, \u00b5(A) \u2286 A, and dom(\u00b5) = ind(Q \u222a T \u222aA). Since \u00b5(A) \u2286 A, ans(\u2217, T ,A) = f, and ans is (Q, T )-monotonic, we have ans(\u2217, T , \u00b5(A)) = f; furthermore, \u00b5 is (Q, T )-stable and ans is strongly faithful, so ans(\u2217, T , \u00b5(A)) = f implies ans(\u2217, T ,A) = f. But then, by Condition (b) we have cert(Q, T ,A) \u2286 ans(Q, T ,A), sob \u2208 ans(Q, T ,A). Now ans is strongly (Q, T )-faithful and\n\u00b5 is (Q, T )-stable, so \u00b5(b) \u2208 ans(Q, T , \u00b5(A)); since \u00b5(b) = a, we have a \u2208 ans(Q, T , \u00b5(A)); finally, since ans is (Q, T )-monotonic and \u00b5(A) \u2286 A, we have a \u2208 ans(Q, T ,A), as required by Definition 3.13.\n(\u21d2) Assume that S is exhaustive for CQ,Ts and Q; we next show that Properties 1 and 2 are satisfied for an arbitrary ABoxA. To this end, we consider a particular abstract reasoner ans for which we prove that ans \u2208 CQ,Ts and that ans passes S; this abstract reasoner will help us identify the ABox, the tuple, and the renaming required to prove Properties 1 and 2.\nLet ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(\u2217, Tin,Ain) is determined as follows.\n1. If T = Tin, then return f.\n2. For each ABox A \u2208 S\u22a5, do the following.\n(a) Check the satisfiability of T \u222a A using a sound, complete, and terminating reasoner.\n(b) If T \u222aA is unsatisfiable, and if a T -stable renaming \u00b5 exists such that dom(\u00b5) = ind(T \u222aA) and \u00b5(A) \u2286 Ain, then return t.\n3. Return f.\nFurthermore, the result of ans(Qin, Tin,Ain) is determined as follows.\n4. If T = Tin or Q = Qin, then return \u2205.\n5. Out := \u2205.\n6. For each tuple a of constants occurring in Ain of arity equal to the arity of the query predicate of Q, and for each A \u2208 SQ do the following.\n(a) Compute C := cert(Q, T ,A) using a sound, complete and terminating reasoner. (b) If a tuple b \u2208 C and a (Q, T )-stable renaming \u00b5 exist such that \u00b5(b) = a,\ndom(\u00b5) = ind(Q \u222a T \u222aA), and \u00b5(A) \u2286 Ain, then add a to Out.\n7. Return Out.\nWe next show that ans belongs to CQ,Ts . The proofs that ans terminates and that it is (Q, T )-monotonic are analogous to the proofs in Theorem 3.23. To show strong (Q, T )- faithfulness, consider an arbitrary Qin, Tin, and Ain, and an arbitrary renaming \u03bb.\n\u2022 Assume that ans(\u2217, Tin,Ain) = t and \u03bb is T -stable. Thus, on Tin and Ain the abstract reasoner terminates in step 2(b) for some A \u2208 S\u22a5 and \u00b5. Let \u00b5 be the renaming such that \u00b5(c) = \u03bb(\u00b5(c)) for each c \u2208 ind(T \u222aA). Clearly, we have dom(\u00b5) = ind(T \u222aA), renaming \u00b5 is T -stable, and \u00b5(A) \u2286 \u03bb(Ain). Thus, on Tin and \u03bb(Ain) the abstract reasoner terminates in step 2(b), so we have ans(\u2217, Tin,\u03bb(Ain)) = t, as required.\n\u2022 Assume that ans(\u2217, Tin,Ain) = f and \u03bb is (Q, T )-stable, and consider an arbitrary tuple a \u2208 ans(Qin, Tin,Ain). Then a is added to Out in step 7(b) for some A \u2208 SQ,\n\u00b5, and b. Let \u00b5 be the renaming defined such that \u00b5(c) = \u03bb(\u00b5(c)) for each individual c \u2208 ind(Q \u222a T \u222aA). Clearly, we have dom(\u00b5) = ind(Q \u222a T \u222aA), mapping \u00b5 is (Q, T )-stable, \u00b5(A) \u2286 \u03bb(Ain), and \u00b5(b) = \u03bb(a). Thus, on Qin, Tin, and \u03bb(Ain) the abstract reasoner terminates in step 7(b), so \u03bb(a) \u2208 ans(Qin, Tin,\u03bb(Ain)), as required.\nThis concludes the proof that ans \u2208 CQ,Ts . Furthermore, ans clearly passes S; but then, since S is exhaustive for CQ,Ts and Q, abstract reasoner ans is (Q, T )-complete. The main claim of this theorem can now be shown as in Theorem 3.23.\nWe next use Theorem 3.30 to show that a Q-simple T -test suite that is exhaustive for CQ,Ts and Q can be obtained as an injective instantiation of a UCQ rewriting of Q w.r.t. T .\nDefinition 3.31. Let Q be a UCQ, let T be a TBox, let R = R\u22a5,RQ be a UCQ rewriting of Q w.r.t. T , and let \u03bb be a substitution mapping each variable occurring in R into a distinct fresh individual. The injective instantiation of R w.r.t. \u03bb is the pair IR,\u03bb = IR,\u03bb\u22a5 , I R,\u03bb Q  where IR,\u03bb\u22a5 and I R,\u03bb Q are the smallest sets of ABoxes such that\n\u2022 Ar\u03bb \u2208 I R,\u03bb \u22a5 for each r \u2208 R\u22a5, and\n\u2022 Ar\u03bb \u2208 I R,\u03bb Q for each r \u2208 RQ such that cert(\u2217,R\u22a5,Ar\u03bb) = f.\nIR,\u03bb is clearly unique up to the renaming of the fresh individuals in \u03bb, so \u03bb is typically left implicit, and one talks of the injective instantiation IR = IR\u22a5 , IRQ of R.\nTheorem 3.32. Let Q be a UCQ, let T be an admissible TBox, let R = R\u22a5,RQ be a UCQ rewriting of Q w.r.t. T , and let IR = IR\u22a5 , IRQ be the injective instantiation of R. Then, IR is a Q-simple T -test suite that is exhaustive for CQ,Ts and Q.\nProof. Let \u03bb be the substitution that IR is obtained from. We first show that IR is a Q-simple T -test suite\u2014that is, that it satisfies the two properties in Definition 3.15.\n\u2022 Consider an arbitrary A \u2208 IR\u22a5 . Then, a rule r \u2208 R\u22a5 exist such that A = Ar\u03bb; clearly cert(\u2217, {r},A) = t; since R is a UCQ rewriting, T \u222aA is unsatisfiable, as required.\n\u2022 Consider an arbitrary A \u2208 IRQ . Then, cert(\u2217,R\u22a5,A) = f by Definition 3.31; since R is a UCQ rewriting, T \u222aA is satisfiable, as required.\nWe next show that IR satisfies Properties 1 and 2 of Theorem 3.30 for an arbitrary ABox A.\n(Property 1) Assume that T \u222aA is unsatisfiable. Since R is a UCQ rewriting, by Definition 2.2 we have cert(\u2217,R\u22a5,A) = t; but then, a rule r \u2208 R\u22a5 and a substitution \u03c1 exist such that Ar\u03c1 \u2286 A and cert(\u2217, {r},Ar\u03c1) = t. Let \u00b5 be a renaming such that for each individual c occurring in R or T we have \u00b5(c) = c, and for each variable x in r we have \u00b5(\u03bb(x)) = \u03c1(x). Clearly, \u00b5(Ar\u03bb) = Ar\u03c1, so \u00b5(Ar\u03bb) \u2286 A. Furthermore, it is clear that \u00b5 is T -stable. Thus, Property (1) holds for Ar\u03bb \u2208 IR\u22a5 and \u00b5.\n(Property 2) Assume that T \u222aA is satisfiable, and consider an arbitrarily chosen tuple a \u2208 cert(Q, T ,A). Since R is a UCQ rewriting, by Definition 2.2 we have cert(\u2217,R\u22a5,A) = f and a \u2208 cert(RQ,R\u22a5,A); but then, clearly a \u2208 cert(RQ, \u2205,A) as well. Then, a rule r \u2208 RQ\nand a substitution \u03c1 exist such that Ar\u03c1 \u2286 A and a \u2208 cert({r}, \u2205,Ar\u03c1). Let \u00b5 be the renaming such that for each individual c occurring in R, Q, or T we have \u00b5(c) = c, and for each variable x in r we have \u00b5(\u03bb(x)) = \u03c1(x). Clearly, \u00b5(Ar\u03bb) = Ar\u03c1, so \u00b5(Ar\u03bb) \u2286 A. Furthermore, it is clear that \u00b5 is (Q, T )-stable. Finally, clearly a tuple b \u2208 cert({r}, \u2205,Ar\u03bb) exists such that \u03bb(head(r)) = Q(b); since R is a UCQ rewriting and T \u222aAr\u03bb is satisfiable, we have b \u2208 cert(Q, T ,Ar\u03bb); furthermore, \u00b5(b) = a clearly holds. But then, Property (2) is satisfied for Ar\u03bb \u2208 IRQ , \u00b5, and b."}, {"heading": "3.7 Dealing with Recursive Axioms", "text": "The negative result in Theorem 3.21 (which applies to both CQ,Tw and CQ,Ts ) depends on the presence of a recursive axiom in the TBox; thus, the positive results in Sections 3.5 and 3.6 require the input UCQ to be rewritable w.r.t. the input TBox, which effectively prohibits recursion in TBox axioms. Instead of disallowing recursive axioms, in this section we overcome the limitation of Theorem 3.21 by placing additional requirements on the abstract reasoners by requiring them to be first-order reproducible. Intuitively, the latter means that the reasoner\u2019s behaviour can be seen as complete reasoning in some unknown first-order theory. Such abstract reasoners are not allowed to partially evaluate recursive axioms, which invalidates the approach used to prove Theorem 3.21.\nWe show that a T -test suite exhaustive for Q and the class of first-order reproducible abstract reasoners can be obtained by instantiating a datalog\u00b1,\u2228 rewriting of Q w.r.t. T . Such rewritings exist for a wide range of TBoxes and queries, which in turn allows our results to be applicable to a range of practically interesting cases. In contrast to test suites computed from a UCQ rewriting, however, the test suites obtained from a datalog\u00b1,\u2228 rewriting may not be Q-simple. In fact, we show in Section 3.7.2 that, for certain Q and T , a T -test suite exhaustive for Q and the class of first-order reproducible abstract reasoners exists, but no such test suite is Q-simple. This has an important practicallyrelevant consequence: if a T -test suite S is not Q-simple, a first-order reproducible abstract reasoner that passes S is guaranteed to be (Q, T )-complete; however, if an abstract reasoner does not pass S, in general we cannot conclude that the reasoner is not (Q, T )-complete."}, {"heading": "3.7.1 First-Order Reproducible Abstract Reasoners", "text": "State of the art concrete reasoners such as Oracle\u2019s reasoner, Jena, OWLim, Minerva, Virtuoso, and DLE-Jena are all implemented as RDF triple stores extended with deductive database features. Given T and A as input, these reasoners first precompute all assertions that follow from T \u222a A in a preprocessing step. In practice, this step is commonly implemented by (a technique that can be seen as) evaluating a datalog program over A. After preprocessing, these reasoners can then answer an arbitrary UCQ Q by simply evaluating Q in the precomputed set of assertions.\nMotivated by this observation, we next introduce the new class of first-order reproducible abstract reasoners\u2014that is, abstract reasoners whose behaviour can be conceived as complete reasoning in some unknown first-order theory. Note that this theory is not required to be a datalog program; for example, it can contain existential quantifiers, which can be used to capture the behaviour of concrete reasoners such as Jena and OWLim (Bishop, Kiryakov,\nOgnyanoff, Peikov, Tashev, & Velkov, 2011) that handle existential quantifiers in the input by introducing fresh individuals.\nDefinition 3.33. An abstract reasoner ans for a description logic DL is first-order reproducible if, for each DL-TBox T , a set of first-order sentences FT exists such that, for each ABox A,\n\u2022 ans(\u2217, T ,A) = cert(\u2217,FT ,A), and\n\u2022 if ans(\u2217, T ,A) = f, then for each UCQ Q, we have ans(Q, T ,A) = cert(Q,FT ,A).\nIf FT contains predicates and/or individuals not occurring in T , these are assumed to be \u2018internal\u2019 to ans and not accessible in queries, TBoxes, ABoxes, test suites, and so on. Given a TBox T , CTf is the class of all first-order reproducible abstract reasoners applicable to T .\nExample 3.34. Abstract reasoners rdf, rdfs, rl and classify from Example 3.3 are all firstorder reproducible. Indeed, theory FT is empty in the case of rdf, and it is precisely Prdfs and Prl in the cases of rdfs and rl, respectively. Finally, for abstract reasoner classify, theory FT is the union of Prl and the program containing the axiom \u2200x.[A(x) \u2192 B(x)] for each atomic subsumption A  B entailed by the input TBox. \u2666\nPlease note that a first-order reproducible abstract reasoner ans does not need to actually construct FT : it only matters that some (possibly unknown) theory FT exists that characterises the reasoner\u2019s behaviour as specified in Definition 3.33.\nSince Q\u222aFT \u222aA |= Q\u222aFT \u222aA whenever A \u2286 A, each first-order reproducible abstract reasoner is (Q, T )-monotonic for arbitrary Q and T . Furthermore, it is straightforward to see that each first-order reproducible abstract reasoner is also strongly (Q, T )-faithful. Consequently, we have CTf \u2286 C Q,T s for each UCQ Q and each TBox T .\nWe next show that the negative result in Theorem 3.21 does not directly apply to the class CTf . In particular, we show that the abstract reasoner pEvaln used to prove Theorem 3.21 is not first-order reproducible. Intuitively, pEvaln can be understood as partial evaluation of a datalog program\u2014that is, the rules in the program are applied to the facts only a fixed number of times rather then until a fixpoint is reached.\nProposition 3.35. For each positive integer n, the abstract reasoner pEvaln defined in the proof of Theorem 3.21 is not first-order reproducible.\nProof. Let T = {\u2203R.A  A}, let Q = {A(x) \u2192 Q(x)}, and consider an arbitrary nonnegative integer n. Furthermore, assume that pEvaln \u2208 CTf ; then, a finite set of first-order sentences FT exists such that pEvaln(Q, T ,A) = cert(Q,FT ,A) for each ABox A.\nLet k be a positive integer; furthermore, let rk be the datalog rule and let Ak be the ABox defined as follows, for a0, . . . , ak arbitrary distinct but fixed individuals not occurring in Q \u222a FT :\nrk = R(x0, x1) \u2227 . . . \u2227R(xk\u22121, xk) \u2227A(xk) \u2192 A(x0) Ak = {R(a0, a1), . . . , R(ak\u22121, ak), A(ak)}\nThe following condition holds by Proposition 2.1:\nFT |= rk if and only if FT \u222aAk |= A(a0) (17)\nBy the definition of pEvaln, we have\na0 \u2208 pEvaln(Q, T ,Ak) for each 1 \u2264 k \u2264 n, and a0 \u2208 pEvaln(Q, T ,Ak) for each k > n.\nSince pEvaln(Q, T ,A) = cert(Q,FT ,A), we have\na0 \u2208 cert(Q,FT ,Ak) for each 1 \u2264 k \u2264 n, and a0 \u2208 cert(Q,FT ,Ak) for each k > n.\nSince Q contains only the atom A(x) in the body, we have\nFT \u222aAk |= A(a0) for each 1 \u2264 k \u2264 n, and FT \u222aAk |= A(a0) for each k > n.\nBy condition (17), we then have\nFT |= rk for each 1 \u2264 k \u2264 n FT |= rk for each k > n.\nThis, however, contradicts the obvious observation that r1 |= rk for each k \u2265 1.\nNote that the proof of Proposition 3.35 relies on the fact that the theory FT only depends on the input TBox, and not on the input query. As shown next, had we defined first-order reproducible abstract reasoners by allowing FT to depend also on the input query, then the negative result from Theorem 3.21 would have applied.\nDefinition 3.36. An abstract reasoner ans for DL first-order q-reproducible if, for each UCQ Q and each DL-TBox T , a finite set of first-order sentences FQ,T exists such that, for each ABox A,\n\u2022 ans(\u2217, T ,A) = cert(\u2217,FQ,T ,A), and\n\u2022 if ans(\u2217, T ,A) = f, then ans(Q, T ,A) = cert(Q,FQ,T ,A).\nTheorem 3.37. For Q = {A(x) \u2192 Q(x)} and T = {\u2203R.A  A}, no T -test suite exists that is exhaustive for Q and the class of all sound, monotonic, strongly faithful, and qreproducible abstract reasoners applicable to T .\nProof. To prove this claim, it suffices to show that, for each nonnegative integer n, the abstract reasoner pEvaln defined in the proof of Theorem 3.21 is first-order q-reproducible. Consider an arbitrary nonnegative integer n, an arbitrary DL-TBox T , and an arbitrary UCQ Q. We define FQ,T  such that, if T \u2286 T  or Q = Q, then FQ,T  = \u2205; otherwise, FQ,T  consists of the following n rules:\nA(x0) \u2192 Q(x0) R(x0, x1) \u2227A(x1) \u2192 Q(x0)\n. . .\nR(x0, x1) \u2227R(x1, x2) \u2227 . . . \u2227R(xn\u22121, xn) \u2227A(xn) \u2192 Q(x0)\nClearly, pEvaln(\u2217, T ,A) = cert(\u2217,FQ,T  ,A) = f for each UCQ Q, DL-TBox T  and ABox A, as required. Furthermore, for each Q and T  such that either T \u2286 T  or Q = Q and each ABox A, we have pEvaln(Q, T ,A) = cert(Q,FQ,T  ,A) = \u2205. Finally, for Q = Q, each T  such that T \u2286 T , and each ABox A, we clearly have pEvaln(Q, T ,A) = cert(Q,FQ,T  ,A), as required."}, {"heading": "3.7.2 Simple vs. Non-Simple Test Suites", "text": "Proposition 3.18 from Section 3.3 shows that each Q-simple T -test suite that is exhaustive for Q and a class of abstract reasoners provides a sufficient and necessary test for (Q, T )- completeness. We next show that an analogous result does not hold if T contains recursive axioms, even if we consider only first-order reproducible abstract reasoners. As in Theorem 3.21, we prove the claim for a fixed Q and T since the concept of \u2018relevant recursive axioms\u2019 might be difficult to formalise; however, our proof can easily be adapted to other UCQs and TBoxes. Our result essentially states that no T -test suite exists that provides a necessary and sufficient condition for (Q, T )-completeness of each abstract reasoner in CTf ; consequently, by Proposition 3.18 each T -test suite exhaustive for CTf and Q is not Q-simple. Furthermore, in Section 3.7.3 we show how to compute a T -test suite exhaustive for CTf and Q, so the following claim does not hold vacuously.\nTheorem 3.38. Let Q = {A(x) \u2227B(x) \u2192 Q(x)}, let T = {\u2203R.A  A}, and let C be the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T . Then, no T -test suite S exists that satisfies the following two properties:\n1. S is exhaustive for C and Q; and\n2. for each abstract reasoner ans \u2208 C, if ans is (Q, T )-complete then ans passes S.\nProof. Assume that a T -test suite S = S\u22a5,SQ exists that satisfies properties 1 and 2 of the theorem. Let n be the maximal number of assertions occurring in an ABox in S. We next define two abstract reasoners ans1 and ans2; it is straightforward to check that both are sound, monotonic, strongly faithful, and first-order reproducible.\nGiven an arbitrary FOL-TBox Tin, abstract reasoner ans1 uses the datalog program F1Tin defined as follows:\n\u2022 If T \u2286 Tin, then F1Tin = \u2205.\n\u2022 If T \u2286 Tin, then F1Tin contains the following n rules:\nr0 = B(x0) \u2227A(x0) \u2192 A(x0) r1 = B(x0) \u2227R(x0, x1) \u2227A(x1) \u2192 A(x0) r2 = B(x0) \u2227R(x0, x1) \u2227R(x1, x2) \u2227A(x3) \u2192 A(x0)\n. . . rn = B(x0) \u2227R(x0, x1) \u2227 . . . \u2227R(xn\u22121, xn) \u2227A(xn) \u2192 A(x0)\nGiven an arbitrary FOL-TBox Tin, abstract reasoner ans2 uses the datalog program F2Tin defined as follows, where predicate Z is private to F 2 Tin (and hence it does not affect the soundness of the abstract reasoner):\n\u2022 If T \u2286 Tin, then F2Tin = \u2205.\n\u2022 If T \u2286 Tin, then F2Tin contains F 1 Tin as well as the following rules:\nrZ1 = R(x0, x1) \u2227 . . . \u2227R(xn, xn+1) \u2227A(xn+1) \u2192 Z(x0) rZ2 = R(x0, x1) \u2227 Z(x1) \u2192 Z(x0) rZ3 = Z(x) \u2227B(x) \u2192 A(x)\nNow let A be an arbitrary ABox containing at most n assertions. We next show that, for each assertion \u03b1 not containing predicate Z, we have F1Tin \u222aA |= \u03b1 if and only if F2Tin \u222aA |= \u03b1. The (\u21d2) direction is trivial since F 1 Tin \u2286 F 2 Tin , so we consider the (\u21d0) direction. Furthermore, since rZ3 is the only rule in F2Tin \\ F 1 Tin that does not contain Z in the head, the claim is nontrivial only if \u03b1 is of the form A(a0) for some individual a0 occurring in A. Since the antecedent of rZ3 is satisfied for a0, we have B(a0) \u2208 A and F2Tin \u222aA |= Z(a0). But then, for the latter to be implied by rZ1 and rZ2 , individuals a0, a1, . . . , ak with 0 \u2264 k exist such that R(ai, ai+1) \u2208 A for each 1 \u2264 i < k, and A(ak) \u2208 A. Since A contains at most n assertions, w.l.o.g. we can assume that k \u2264 n. But then, since F1Tin contains rule rk, we have F 1 Tin \u222aA |= A(a0) as well, which proves our claim. As a consequence of this claim and the fact that all ABoxes in S contain at most n assertions, we have cert(\u2217,F1Tin ,A) = cert(\u2217,F 2 Tin ,A) for each A \u2208 S\u22a5, and cert(Y,F 1 Tin ,A) = cert(Y,F 2 Tin ,A) for each A,Y \u2208 SQ. Let A = {B(a0), R(a0, a1), . . . , R(an, an+1), A(an+1)}. Then cert(Q, T ,A) = {a0} and cert(Q,F1Tin ,A) = \u2205, so ans1 is not (Q, T )-complete. Since S is exhaustive for C and Q, abstract reasoner ans1 does not pass S; by the claim from the previous paragraph, abstract reasoner ans2 does not pass S either. We next show that ans2 is (Q, T )-complete, which contradicts the assumption that S satisfies property 2 and thus proves the claim of this theorem.\nConsider an arbitrary ABoxA containing m assertions. Clearly, a0 \u2208 cert(Q, T ,A) if and only if individuals a0, a1, . . . , ak with 0 \u2264 k \u2264 m exist such that B(a0) \u2208 A, R(ai, ai+1) \u2208 A for each 1 \u2264 i < k, and A(ak) \u2208 A. Now assume that k \u2264 n; since rk \u2208 F2Tin , we have F2Tin \u222aA |= A(a0) and thus a0 \u2208 cert(Q,F 2 Tin ,A). In contrast, assume that k > n; since rZ1 \u2208 F2Tin , we have F 2 Tin \u222aA |= Z(ak\u2212n\u22121); since rZ2 \u2208 F 2 Tin , we have F 2 Tin \u222aA |= Z(ai) for each 0 \u2264 i \u2264 k \u2212 n\u2212 1; finally, since rZ3 \u2208 F2Tin , we have F 2 Tin \u222aA |= A(a0); but then, a0 \u2208 cert(Q,F2Tin ,A), as required.\nAs a corollary to Theorem 3.38, we next show that testing abstract reasoners in CTf cannot be done in general using Q-simple test suites.\nCorollary 3.39. For Q = {A(x) \u2227B(x) \u2192 Q(x)} and T = {\u2203R.A  A}, no Q-simple T - test suite exists that is exhaustive for Q and the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T .\nProof. If S is a Q-simple T -test suite that is exhaustive for Q and the class mentioned in the Theorem, by Proposition 3.18 each abstract reasoner ans from the class that does not pass S is not (Q, T )-complete, which contradicts Theorem 3.38.\nTheorem 3.38 effectively says that, if an abstract reasoner ans \u2208 CTf does not pass a T - test suite S, we cannot conclude that ans is not (Q, T )-complete. Please note that this holds only if ans fails a test of the form A,Y where Q = Y: if Q = Y, then A is a counterexample to (Q, T )-completeness of ans. Thus, S may show ans to be not (Q, T )-complete, but it is not guaranteed to do so. This is illustrated by the following example.\nExample 3.40. LetQ = {A(x) \u2227B(x) \u2192 Q(x)} and let T = {\u2203R.A  A,\u2203R.C  C}. Furthermore, let S = \u2205,SQ be the general test suite defined as follows:\nSQ = {  {A(c) }, {A(x) \u2227B(x) \u2192 Q(x) } ,  {R(c, d), A(d) }, {A(c) \u2192 Q } ,  {R(c, d), C(d) }, {C(c) \u2192 Q }  }\nLet R = RD, \u2205,Q where RD = {R(x, y) \u2227A(y) \u2192 A(x), R(x, y) \u2227 C(y) \u2192 C(x)}; clearly, R is a rewriting Q w.r.t. T . In Section 3.7.3 we show how to compute S from R using a variant of injective instantiation in a way that guarantees exhaustiveness for CTf and Q.\nNow let ans1 \u2208 CTf be the abstract reasoner defined by F1T = {R(x, y) \u2227A(y) \u2192 A(x)}. The reasoner does not pass S since cert({C(c) \u2192 Q},F1T , {R(c, d), C(d)}) = f. Note, however, that the reasoner is (Q, T )-complete. Thus, if a test suite is not Q-simple, passing it is a sufficient, but not a necessary condition for (Q, T )-completeness. In fact, note that T contains the TBox for Theorem 3.38, so by the theorem we cannot \u2018reduce\u2019 S so that it correctly identifies all reasoners in CTf that are not (Q, T )-complete.\nIn practice, however, one can try to mitigate this fundamental theoretical limitation by eliminating the irrelevant axioms from the rewriting R and thus increasing the likelihood of obtaining a T -test suite that a (Q, T )-complete abstract reasoner will pass. For example, using the techniques by Cuenca Grau, Horrocks, Kazakov, and Sattler (2008a) we can extract the module of R relevant to the query. In the example from the previous paragraph, this would remove the rule R(x, y) \u2227 C(y) \u2192 C(x) from R, and injective instantiation will produce the test suite S = \u2205,SQ where SQ is defined as follows:\nSQ = {  {A(c) }, {A(x) \u2227B(x) \u2192 Q(x) } ,  {R(c, d), A(d) }, {A(c) \u2192 Q }  }\nAbstract reasoner ans1 from the previous paragraph now passes S and is thus guaranteed to be (Q, T )-complete.\nNow let ans2 be the abstract reasoner defined by F2T = {B(x) \u2227R(x, y) \u2227A(y) \u2192 A(x)}. Clearly, abstract reasoner ans2 is not (Q, T )-complete, so ans2 does not pass SQ. From the latter, however, we cannot immediately conclude that S is not (Q, T )-complete: the test that fails does not involve the original query Q. As a possible remedy, we can try to unfold R to a certain level and then injectively instantiate the result in hope of obtaining a T -test suite that will identify ans2 as not being (Q, T )-complete. In particular, the first unfolding of R produces the following query:\nB(x) \u2227R(x, y) \u2227A(y) \u2192 Q(x)\nInstantiating this rewriting produces the following test suite, which does not prove that ans2 is not (Q, T )-complete.\nSQ = {  {B(c), R(c, d), A(d) }, {A(x) \u2227B(x) \u2192 Q(x) }  }\nAnother round of unfolding, however, produces the following query:\nB(x) \u2227R(x, y) \u2227R(y, z) \u2227A(z) \u2192 Q(x)\nInstantiating this query produces the following test suite:\nSQ = {  {B(c), R(c, d), R(d, e), A(e) }, {A(x) \u2227B(x) \u2192 Q(x) }  }\nNow ans2 does not pass SQ, so we can conclude that ans2 is not (Q, T )-complete. \u2666\nTo better understand Example 3.40, consider a first-order reproducible abstract reasoner ans, an arbitrary UCQ Q, and a TBox T such that R = RD, \u2205,RQ is a datalog rewriting of Q w.r.t. T . Datalog program RD \u222aRQ is equivalent to the (possibly infinite) UCQ RuQ obtained from RD \u222aRQ via exhaustive unfolding. We now have the following possibilities.\nFirst, assume that ans is not (Q, T )-complete. Since RD \u222aRQ is equivalent to RuQ, each certain answer a to Q w.r.t. T and an arbitrary ABox A is \u2018produced\u2019 by some r \u2208 RuQ. But then, the injective instantiation Ar\u03bb of r will provide us with the counterexample for the (Q, T )-completeness of ans. Thus, we can prove that ans is not (Q, T )-complete by generating the elements of RuQ in a fair manner (i.e., without indefinitely delaying the generation of some element of RuQ) and checking whether cert(Q, T ,Ar\u03bb) \u2286 ans(Q, T ,Ar\u03bb); we are guaranteed to eventually encounter some r \u2208 RuQ that invalidates this condition and thus proves that ans is not (Q, T )-complete.\nSecond, assume that ans is (Q, T )-complete. Using the above approach, we will determine that cert(Q, T ,Ar\u03bb) \u2286 ans(Q, T ,Ar\u03bb) holds for each r \u2208 RuQ. Now if RuQ is finite (i.e., if the unfolding of RD \u222aRQ terminates), then RuQ is the UCQ rewriting of Q w.r.t. T , so by the results from Section 3.6 we can conclude that ans is indeed (Q, T )-complete. If, however, RuQ is infinite, then we will never obtain a sufficient assurance for the (Q, T )-complete of ans. In the following section we show a possible remedy to this problem."}, {"heading": "3.7.3 Testing First-Order Reproducible Abstract Reasoners", "text": "In this section, we show how to compute a T -test suite S = S\u22a5,SQ exhaustive for CTf and Q from a datalog\u00b1,\u2228 rewriting R = RD,R\u22a5,RQ of Q w.r.t. T . Since first-order reproducible abstract reasoners are strongly faithful, we need to consider only injective instantiations of R. Thus, the rules in R\u22a5 and RQ should be instantiated as in Section 3.6. A rule r \u2208 RD, however, is instantiated into a pair A,Y \u2208 SQ with A the ABox obtained by instantiating the body of r and Y the Boolean UCQ obtained by instantiating the head of r. Intuitively, such tests allow us to check whether the (unknown) first-order theory FT that captures the behaviour of the abstract reasoner entails r.\nDefinition 3.41. Let Q be a UCQ with query predicate Q, let T be an admissible TBox, let R = RD,R\u22a5,RQ be a datalog\u00b1,\u2228 rewriting of Q w.r.t. T , and let \u03bb be a substitution mapping each variable occurring in R into a distinct fresh individual. The injective instantiation of R w.r.t. \u03bb is the pair IR,\u03bb = IR,\u03bb\u22a5 , I R,\u03bb Q  where I R,\u03bb \u22a5 is the smallest set of ABoxes and IR,\u03bbQ is the smallest set of pairs of an ABox and a UCQ such that\n\u2022 Ar\u03bb \u2208 I R,\u03bb \u22a5 for each r \u2208 R\u22a5,\n\u2022 Ar\u03bb,Q \u2208 I R,\u03bb Q for each r \u2208 RQ such that cert(\u2217,RD \u222aR\u22a5,Ar\u03bb) = f, and\n\u2022 Ar\u03bb,Y \u2208 I R,\u03bb Q for each r \u2208 RD of the form (6) such that cert(\u2217,RD \u222aR\u22a5,Ar\u03bb) = f,\nwhere Y is the UCQ Y = {\u03d5i(\u03bb(x), yi) \u2192 Q | 1 \u2264 i \u2264 m} with the propositional query predicate Q.\nIR,\u03bb is clearly unique up to the renaming of the fresh individuals in \u03bb, so \u03bb is typically left implicit, and one talks of the injective instantiation IR = IR\u22a5 , IRQ of R.\nExample 3.42. Consider the query Q = {A(x) \u2192 Q(x)} and the EL-TBox T consisting of the following axioms, whose translation into first-order logic is shown after the  symbol.\n\u2203R.A  B  \u2200x, y.[R(x, y) \u2227A(y) \u2192 B(x)] \u2203R.C  A  \u2200x, y.[R(x, y) \u2227 C(y) \u2192 A(x)]\nB  C  \u2200x.[B(x) \u2192 C(x)] C  \u2203R.D  \u2200x.[C(x) \u2192 \u2203y.[R(x, y) \u2227D(y)]] A D  \u22a5  \u2200x.[A(x) \u2227D(x) \u2192 \u22a5]\nThen, R = RD,R\u22a5,RQ as defined next is a datalog rewriting of Q w.r.t. T .\nRD = { R(x, y) \u2227A(y) \u2192 B(x), R(x, y) \u2227 C(y) \u2192 A(x), B(x) \u2192 C(x) } R\u22a5 = { A(x) \u2227D(x) \u2192 \u22a5 } RQ = { A(x) \u2192 Q(x) }\nThe injective instantiation IR = IR\u22a5 , IRQ of R is shown below.\nIR\u22a5 = { {A(c), D(c) } } IRQ = {  {A(c) }, {A(x) \u2192 Q(x) } ,\n {R(c, d), A(d) }, {B(c) \u2192 Q } ,  {R(c, d), C(d) }, {A(c) \u2192 Q } ,  {B(c) }, {C(c) \u2192 Q }  } \u2666\nWe now show that the injective instantiation of a datalog\u00b1,\u2228 rewriting of Q w.r.t. T is a T -test suite exhaustive for CTf and Q.\nTheorem 3.43. Let Q be a UCQ, let T be a TBox, let R = RD,R\u22a5,RQ be a datalog\u00b1,\u2228 rewriting of Q w.r.t. T , and let IR = IR\u22a5 , IRQ be the injective instantiation of R. Then, IR is a T -test suite that is exhaustive for CTf and Q.\nProof. Let \u03bb be the substitution that IR is obtained from. We first show that IR is a T -test suite.\n\u2022 Consider an arbitrary A \u2208 IR\u22a5 . Then, a rule r \u2208 R\u22a5 exist such that A = Ar\u03bb; clearly cert(\u2217, {r},A) = t, so cert(\u2217,RD \u222aR\u22a5,A) = t as well; since R is a datalog\u00b1,\u2228 rewriting of Q w.r.t. T , we have that T \u222aA is unsatisfiable, as required.\n\u2022 Consider an arbitrary A \u2208 IRQ . Then, cert(\u2217,RD \u222aR\u22a5,A) = f by Definition 3.41; since R is a datalog\u00b1,\u2228 rewriting of Q w.r.t. T , we have that T \u222aA is satisfiable, as required.\nTo show that IR is exhaustive for CTf and Q, consider an arbitrary abstract reasoner ans \u2208 CTf that passes IR\u2014that is, ans satisfies the following two properties:\n(a) ans(\u2217, T ,A) = t for each A \u2208 IR\u22a5 , and\n(b) ans(\u2217, T ,A) = f implies cert(Y, T ,A) \u2286 ans(Y, T ,A) for each Y,A \u2208 IRQ .\nSince ans is first-order reproducible, a set of first-order sentences FT exists such that, for each ABox A, we have\n\u2022 ans(\u2217, T ,A) = cert(\u2217,FT ,A), and\n\u2022 if ans(\u2217, T ,A) = f, then ans(Q, T ,A) = cert(Q,FT ,A).\nBy the assumption on FT in Definition 3.33 and the fact that \u03bb maps variables to fresh individuals, we have rng(\u03bb) \u2229 ind(FT ) = \u2205.\nLet R1D and R2D be the smallest sets of rules satisfying the following conditions for each rule r \u2208 RD:\n\u2022 cert(\u2217,FT ,Ar\u03bb) = t implies r \u2208 R1D, where r is obtained from r by replacing the head with \u22a5, and\n\u2022 cert(\u2217,FT ,Ar\u03bb) = f implies r \u2208 R2D.\nFurthermore, let R1Q and R2Q be the sets of rules obtained from RQ in an analogous way. Since R1D \u222aR2D is obtained from RD by replacing some head formulae with \u22a5, we clearly have R1D \u222aR2D |= RD; analogously, we have R1Q \u222aR2Q |= RQ.\nWe next show that FT |= R\u22a5; the latter holds if and only if FT |= r for each rule r \u2208 R\u22a5. Consider an arbitrary rule r \u2208 R\u22a5; note that head(r) = \u22a5. Then, by Definition 3.41 we have Ar\u03bb \u2208 IR\u22a5 ; by (a) we have ans(\u2217, T ,Ar\u03bb) = t; by Definition 3.33 we have cert(\u2217,FT ,Ar\u03bb) = t and hence FT \u222aAr\u03bb |= \u22a5; finally, since rng(\u03bb) \u2229 ind(FT ) = \u2205, by Proposition 2.1 we have FT |= r, as required.\nWe next show that FT |= R1D; the latter holds if and only if FT |= r for each rule r \u2208 R1D. Consider an arbitrary rule r \u2208 R1D; note that head(r) = \u22a5. Then, by the definition of R1D we have cert(\u2217,FT ,Ar\u03bb) = t and hence FT \u222aAr\u03bb |= \u22a5; finally, since rng(\u03bb) \u2229 ind(FT ) = \u2205, by Proposition 2.1 we have FT |= r, as required.\nIn a completely analogous way as in the previous paragraph, it is possible to show that FT |= R1Q.\nWe next show that FT |= R2D; the latter holds if and only if FT |= r for each rule r \u2208 R2D. Consider an arbitrary rule r \u2208 R2D of the form (6); by the definition of R2D we have cert(\u2217,FT ,Ar\u03bb) = f, so by Definition 3.33 we have ans(\u2217, T ,Ar\u03bb) = f. Then, by Definition 3.41 we have Ar\u03bb,Y \u2208 IRQ where Y is the UCQ Y = {\u03d5i(\u03bb(x), yi) \u2192 Q | 1 \u2264 i \u2264 m}. Note that T |= r by Definition 2.2, so by Proposition 2.1 we have that T \u222aAr\u03bb |= m i=1 \u03d5i(\u03bb(x), yi); by the definition of Y and the fact that Q does not occur in T , we have Y \u222a T \u222aAr\u03bb |= Q;\nbut then, cert(Y, T ,Ar\u03bb) = t. The latter observation, ans(\u2217, T ,Ar\u03bb) = f, and (b) then imply ans(Y, T ,Ar\u03bb) = t, so by Definition 3.33 we have cert(Y,FT ,Ar\u03bb) = t. Since Q occurs only in Y (note that each predicate occurring in FT but not in T is private to FT , so Q cannot occur in FT ), we have FT \u222aAr\u03bb |= m i=1 \u03d5i(\u03bb(x), yi). Finally, since rng(\u03bb) \u2229 ind(FT ) = \u2205, by Proposition 2.1 we have FT |= r, as required. We next show that Q \u222a FT |= R2Q; the latter holds if and only if Q \u222a FT |= r for each rule r \u2208 R2Q. Consider an arbitrary rule r \u2208 R2Q; note that head(r) is an atom with predicate Q, and that by the definition of R2Q we have cert(\u2217,FT ,Ar\u03bb) = f, so by Definition 3.33 we have ans(\u2217, T ,Ar\u03bb) = f. Furthermore, by Definition 3.41, we have cert(\u2217,RD \u222aR\u22a5,Ar\u03bb) = f. Let a be the tuple of the arguments in \u03bb(head(r)). Then, by Definition 3.41 we have Ar\u03bb,Q \u2208 IRQ ; clearly, a \u2208 cert({r}, \u2205,Ar\u03bb), but then we have a \u2208 cert(RQ,RD \u222aR\u22a5,Ar\u03bb) by the monotonicity of first-order logic. Since R is a rewriting of Q w.r.t. T , by Definition 2.2 we have a \u2208 cert(Q, T ,Ar\u03bb). The latter observation, ans(\u2217, T ,Ar\u03bb) = f, and (b) then imply a \u2208 ans(Q, T ,Ar\u03bb). By Definition 3.33 we have a \u2208 cert(Q,FT ,Ar\u03bb); hence, FT \u222aAr\u03bb |= Q(a). Finally, since we have rng(\u03bb) \u2229 ind(FT ) = \u2205, by Proposition 2.1 we have FT |= r, as required.\nThe following table summarises the entailment relationships between various first-order theories obtained thus far:\nFT |= R\u22a5 FT |= R1D FT |= R2D FT |= R1Q Q \u222a FT |= R2Q R1Q \u222aR2Q |= RQ R1D \u222aR2D |= RD\nClearly, this implies the following entailments:\nFT |= RD \u222aR\u22a5 Q \u222a FT |= RD \u222aR\u22a5 \u222aRQ\nWe now complete the proof of this theorem and show that ans is (Q, T )-complete. To this end, consider an arbitrary ABox A; we have the following possibilities, depending on the satisfiability of T \u222aA.\n\u2022 Assume that T \u222a A is unsatisfiable. Then cert(\u2217,RD \u222aR\u22a5,A) = t by Definition 2.2; by the above mentioned entailments, we have cert(\u2217,FT ,A) = t; consequently, ans(\u2217, T ,A) = t by Definition 3.33, as required.\n\u2022 Assume that T \u222aA is satisfiable and ans(\u2217, T ,A) = f, and consider an arbitrary tuple a \u2208 cert(Q, T ,A). Then, cert(\u2217,RD \u222aR\u22a5,A) = f and a \u2208 cert(RQ,RD \u222aR\u22a5,A) by Definition 2.2. By the above mentioned entailments, we have a \u2208 cert(Q,FT ,A); hence, a \u2208 ans(Q, T ,A) by Definition 3.33, as required.\nNote that the size of the test suite obtained by Theorem 3.43 is linear in the size of the rewriting, which, we believe, makes our approach suitable for use in practice."}, {"heading": "3.7.4 Testing Ground Queries", "text": "As shown in Section 3.7.2, if an abstract reasoner ans \u2208 CTf does not pass a T -test suite S that is not Q-simple, we cannot always conclude that ans is not (Q, T )-complete. From a practical point of view, it would be highly beneficial to identify situations where not passing S would show that ans is indeed incomplete forQ and T . Furthermore, in applications where\nprototypical queries are not known at design time, we would like to design completeness tests that are query-independent\u2014that is, which test an abstract reasoner for completeness w.r.t. T regardless of the input data and query. In this section, we show that we can achieve these two goals by focusing on ground queries. This restriction is not unreasonable in practice, since any SPARQL query can be equivalently expressed as a ground UCQ.\nWe first define a query-independent notion of exhaustiveness of a test suite.\nDefinition 3.44. Let T be a TBox, let S be a T -test suite, and let C be a class of abstract reasoners applicable to T . Then, S is exhaustive for C and all ground UCQs if each ans \u2208 C that passes S is (Q, T )-complete for each ground UCQ Q.\nThen, we define the notion of a ground rewriting of T \u2014a rewriting that captures all query answers w.r.t. T , regardless of the input ground query and ABox\u2014and we show how to instantiate such ground rewritings.\nDefinition 3.45. A ground rewriting of a TBox T is a pair R = RD,R\u22a5 such that, for each ground UCQ Q, the triple RD,R\u22a5,Q is a datalog\u2228 rewriting of T w.r.t. Q. An injective instantiation IR of such R is defined as IR = IR for R = RD,R\u22a5, \u2205.\nNote that Definition 3.45 implies that each variable occurring in the head of a rule in R also occurs in the rule body. Tools such as REQUIEM and KAON2 can easily be adapted to compute a ground rewriting of a TBox T in practice. We next show that injective instantiation of a ground rewriting of T yields a T -test suite that provides us with sufficient and necessary check for completeness w.r.t. all ground UCQs.\nTheorem 3.46. Let T be a TBox, and let R = RD,R\u22a5 be a ground rewriting of T . Then, the following two claims hold.\n1. IR is exhaustive for CTf and all ground UCQs.\n2. Each abstract reasoner ans \u2208 CTf that does not pass IR is not (Q, T )-complete for some ground UCQ Q.\nProof. (Property 1) Consider an arbitrary abstract reasoner ans \u2208 CTf that passes IR. Let FT be the first-order theory that characterises the behaviour of ans; as in the proof of Theorem 3.43, the fact that ans passes IR implies FT |= RD \u222aR\u22a5. Furthermore, consider an arbitrary ground UCQ Q and an arbitrary ABox A. That ans is (Q, T )-complete can be shown as in the proof of Theorem 3.43, with the minor difference that a \u2208 cert(Q, T ,A) implies a \u2208 cert(Q,RD \u222aR\u22a5,A) by Definition 3.45.\n(Property 2) Note that, since R is a ground rewriting of T , by Definition 3.41 all UCQs in IR are ground. Thus, if some abstract reasoner ans \u2208 CTf does not pass IR, this clearly shows that ans is not (Q, T )-complete for some ground UCQ Q."}, {"heading": "4. Comparing Incomplete Abstract Reasoners", "text": "In this section, we investigate techniques that, given a query Q and a TBox T , allow us to determine whether an abstract reasoner ans2 is \u2018more complete\u2019 than an abstract reasoner ans1\u2014that is, whether for all ABoxes A, abstract reasoner ans2 computes more answers to Q and T than abstract reasoner ans1. This idea is formalised by the following definition.\nDefinition 4.1. Let Q be a UCQ, let T be a TBox, and let ans1 and ans2 be abstract reasoners applicable to T . Then, ans1 \u2264Q,T ans2 if the following conditions hold for each ABox A:\n1. cert(\u2217, T ,A) = t and ans1(\u2217, T ,A) = t imply ans2(\u2217, T ,A) = t; and\n2. cert(\u2217, T ,A) = f, ans1(\u2217, T ,A) = f, and ans2(\u2217, T ,A) = f imply\nans1(Q, T ,A) \u2229 cert(Q, T ,A) \u2286 ans2(Q, T ,A) \u2229 cert(Q, T ,A).\nFurthermore, ans1 <Q,T ans2 if ans1 \u2264Q,T ans2 and an ABox A exists such that at least one of the following two conditions holds:\n3. cert(\u2217, T ,A) = t, ans1(\u2217, T ,A) = f, and ans2(\u2217, T ,A) = t; or\n4. cert(\u2217, T ,A) = f, ans1(\u2217, T ,A) = f, ans2(\u2217, T ,A) = f, and\nans1(Q, T ,A) \u2229 cert(Q, T ,A)  ans2(Q, T ,A) \u2229 cert(Q, T ,A).\nExample 4.2. Consider the abstract reasoners rdf, rdfs, rl, and classify introduced in Example 3.3 and the query Q and TBox T from Example 3.14. We clearly have the following:\nrdf \u2264Q,T rdfs \u2264Q,T rl \u2264Q,T classify\nFurthermore, for any two of these abstract reasoners, an ABox exists that distinguishes the abstracts reasoners w.r.t.Q and T ; for example, for ABox A = {takesCo(c, d),MathsCo(d)}, we have rdfs(Q, T ,A) = \u2205 and rl(Q, T ,A) = {c}. As a result, we also have the following:\nrdf <Q,T rdfs <Q,T rl <Q,T classify \u2666\nWe would like to check whether ans1 \u2264Q,T ans2 and ans1 <Q,T ans2 for any given pair of abstract reasoners by subjecting the reasoners to a finite set of tests. Towards this goal, we next define the relations \u2264RQ,T and <RQ,T that compare abstract reasoners w.r.t. a given finite set R of ABoxes. Ideally, given Q and T , we would like to compute a finite R such that \u2264RQ,T and <RQ,T coincide with \u2264Q,T and <Q,T on all abstract reasoners from a class C of interest. These ideas are captured by the following definitions.\nDefinition 4.3. Let Q be a UCQ, let T be a TBox, let R be a finite set of ABoxes, and let ans1 and ans2 be abstract reasoners applicable to T .\nThen, ans1 \u2264RQ,T ans2 if Conditions 1 and 2 from Definition 4.1 hold for each ABox A \u2208 R. Furthermore, ans1 <RQ,T ans2 if ans1 \u2264RQ,T ans2 and either Condition 3 or Condition 4 from Definition 4.1 holds for some ABox A \u2208 R.\nDefinition 4.4. Let Q be a UCQ, let T be a TBox, and let C be a class of abstract reasoners applicable to T . A finite set R of ABoxes is (Q, T )-representative for C if the following conditions hold for all ans1, ans2 \u2208 C:\n1. ans1 \u2264RQ,T ans2 if and only if ans1 \u2264Q,T ans2; and\n2. ans1 <RQ,T ans2 if and only if ans1 <Q,T ans2.\nAs we show next, to prove that R is (Q, T )-representative, it suffices to show the \u2018only if\u2019 implication in Condition 1 and the \u2018if\u2019 implication in Condition 2 from Definition 4.4.\nProposition 4.5. Let Q be a UCQ, let T be a TBox, let C be a class of abstract reasoners applicable to T , and let R be a finite set of ABoxes such that\n1. ans1 \u2264RQ,T ans2 implies ans1 \u2264Q,T ans2, and\n2. ans1 <Q,T ans2 implies ans1 < R Q,T ans2.\nThen, R is (Q, T )-representative for C.\nProof. Note that ans1 \u2264Q,T ans2 trivially implies ans1 \u2264RQ,T ans2; thus, Condition 1 of this proposition clearly implies Condition 1 of Definition 4.4. Furthermore, if some ABox A \u2208 R satisfies Condition 3 or 4 of Definition 4.1, Condition 1 or 2 of Definition 4.1 holds as well; consequently, Conditions 1 and 2 of this proposition imply Condition 2 of Definition 4.4.\nAn obvious question is whether a Q-simple T -test suite that is exhaustive for a class C and Q is also (Q, T )-representative for C. The following example shows that this is not necessarily the case.\nExample 4.6. Let Q and T be as specified in Example 3.14, and let R = {A1, . . . ,A6} for the ABoxes as specified in Example 3.16. As shown in Section 3, the Q-simple T -test suite S = S\u22a5,SQ with S\u22a5 = {A6} and SQ = {A1, . . . ,A5} is exhaustive for CQ,Tw and Q.\nLet trivial be the abstract reasoner that returns the empty set on each input, and consider also the RDF-based abstract reasoner rdf from Example 3.3, which ignores the TBox and evaluates the query directly against the ABox. Clearly, trivial \u2264Q,T rdf; furthermore, trivial <Q,T rdf since for A = {St(c), takesCo(c, d),MathCo(d)} we have rdf(Q, T ,A) = {c} whereas trivial(Q, T ,A) = \u2205. Both abstract reasoners, however, return the empty set of answers for all ABoxes in R and thus rdf \u2264RQ,T trivial. Hence, by using R we cannot differentiate the two abstract reasoners. \u2666"}, {"heading": "4.1 Negative Result", "text": "The following strong result shows that, for numerous TBoxes T , no finite set of ABoxes exists that can differentiate two arbitrary abstract reasoners from the class of all sound, first-order reproducible, monotonic, and strongly faithful reasoners. Note that this result is stronger than the negative result in Theorem 3.21, as it applies to a smaller class of abstract reasoners and all TBoxes that imply at least one concept subsumption.\nTheorem 4.7. Let T be an arbitrary TBox mentioning an atomic role R and atomic concepts A and B such that T |= A  B, and let Q = {B(x) \u2192 Q(x)}. Then, no finite set of ABoxes exists that is (Q, T )-representative for the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T .\nProof. Assume that a finite set of ABoxes R exists that is (Q, T )-representative for the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T . Let n be the maximum number of assertions in an ABox in R.\nFor an arbitrary integer k \u2265 1, let ansk be the first-order reproducible abstract reasoner that, given an FOL-TBox Tin, uses the following datalog program FkTin :\nFkTin =  \u2205 if Tin |= A  B A(x0) \u2227R(x0, x1) \u2227 . . . \u2227R(xk\u22121, xk) \u2192 B(x0) if Tin |= A  B\nClearly, each ansk is sound, monotonic, and strongly faithful; furthermore, ansk(\u2217, T ,A) = f for each ABox A. We next show that ansn+1(Q, T ,A) \u2286 ansn+2(Q, T ,A) for each ABox A \u2208 R. Consider an arbitrary a0 \u2208 ansn+1(Q, T ,A); then, individuals a0, a1, . . . , an+1 exist such that R(a\u22121, a) \u2208 A for each 1 \u2264  \u2264 n + 1. Since A contains at most n assertions but the rule in Fn+1T contains n + 1 body atoms, we have ai = aj for some i = j\u2014that is, A contains an R-cycle. But then, the rule in Fn+2T can be matched to A by mapping x0 to a0, so a0 \u2208 ansn+2(Q, T ,A). Therefore, we have ansn+1 \u2264RQ,T ansn+2.\nForA = {A(a0), R(a0, a1), . . . , R(an, an+1)}, however, we have a0 \u2208 ansn+1(Q, T ,A) and ansn+2(Q, T ,A) = \u2205; thus, ansn+1 \u2264Q,T ansn+2 does not hold, which contradicts our assumption that R is exhaustive for the class of abstract reasoners from this theorem."}, {"heading": "4.2 Compact Abstract Reasoners", "text": "Theorem 4.7 suggests that we need to make additional assumptions on the abstract reasoners that we wish to compare using a finite set of ABoxes. In this section, we show that representative sets of ABoxes can be computed in practice if we further restrict ourselves to abstract reasoners that we call (Q, T )-compact. Intuitively, such an abstract reasoner processes Q, T , and A by computing all certain answers of Q, A, and some subset T  of T , where the subset depends only on T and Q. In other words, the behaviour of compact abstract reasoners can be simulated by the following process: select the subset of axioms in the input TBox that can be processed, and then compute all certain answers w.r.t. the selected fragment of the TBox. The class of (Q, T )-compact abstract reasoners thus captures the properties of concrete reasoners such as Jena or Oracle\u2019s Semantic Data Store that discard axioms from the input TBox that fall outside a certain fragment (e.g., existential restrictions on the right-hand of implications) and then encode the remaining axioms into a suitable set of rules.\nDefinition 4.8. Let Q be a UCQ, and let T be a TBox. An abstract reasoner ans applicable to T is (Q, T )-compact if a TBox T  \u2286 T exists such that the following properties hold for each ABox A:\n1. cert(\u2217, T ,A) = t implies ans(\u2217, T ,A) = t;\n2. cert(\u2217, T ,A) = f implies ans(\u2217, T ,A) = f and ans(Q, T ,A) = cert(Q, T ,A).\nAbstract reasoner ans is compact if it is (Q, T )-compact for each UCQ Q and each TBox T to which ans is applicable. Finally, CQ,Tc is the class of all (Q, T )-compact and strongly (Q, T )-faithful abstract reasoners applicable to T .\nExample 4.9. All abstract reasoners defined in Example 3.3 are (Q, T )-compact for the query Q and EL-TBox T from Example 3.14. Indeed, for abstract reasoner rdf the subset T  of T is given by T  = \u2205; for abstract reasoner rdfs it is T  = {(8)}; for abstract reasoner rl it is T  = {(8), (9), (10)}; and for abstract reasoner classify it is T  = T . \u2666\nThe abstract reasoners ansk defined in the proof of of Theorem 4.7 are not (Q, T )- compact for the query and the TBoxes to which Theorem 4.7 applies.\nProposition 4.10. Let Q = {B(x) \u2192 Q(x)} and let T = {A  B, C  \u2203R.}. Then, for each k \u2265 1, abstract reasoner ansk from the proof of Theorem 4.7 is not (Q, T )-compact.\nProof. Let Q and T be as stated in the theorem and consider an arbitrary k \u2265 1. Let A1 and A2 be ABoxes defined as follows:\nA1 = {A(a0)} A2 = {A(a0), R(a0, a1), . . . , R(ak\u22121, ak)}\nClearly, we have the following:\nansk(Q, T ,A1) = \u2205 ansk(Q, T ,A2) = {a0}\nOne can straightforwardly check, however, that the following holds for each T  with T  \u2286 T :\ncert(Q, T ,A1) = cert(Q, T ,A2)\nThus, ansk is not (Q, T )-compact.\nThus, the negative result from Theorem 4.7 does not immediately apply to a class containing only compact abstract reasoners."}, {"heading": "4.3 Comparing Compact Abstract Reasoners", "text": "In this section, we show that a set of ABoxes that is (Q, T )-representative for CQ,Tc can be obtained by computing, for each subset T  of T , a Q-simple T -test suite that is exhaustive for CQ,T  s . A minor complication arises due to the fact that T  can contain fewer individuals than T . To deal with such cases correctly, the ABoxes in ST \u22a5 are not allowed to contain individuals occurring in T but not in T , and the ABoxes in ST Q are not allowed to contain individuals occurring in T but not in Q \u222a T . This assumption is without loss of generality: given a (Q, T )-test suite ST  , one can replace all individuals in T but not in Q \u222a T  with fresh individuals; the result of such replacement is a (Q, T )-test suite exhaustive for CQ,T  s .\nTheorem 4.11. Let Q be a UCQ, and let T be a TBox. Furthermore, for each T  \u2286 T , let ST  = ST \u22a5 ,ST  Q  be a Q-simple T -test suite that is exhaustive for C Q,T  s and Q such that no ABox in ST \u22a5 contains an individual from ind(T ) \\ ind(T ) and no ABox in ST \nQ contains an individual from ind(T ) \\ ind(Q \u222a T ). Then, the set R of ABoxes defined by\nR = \nT \u2286T ST  \u22a5 \u222a ST  Q\nis (Q, T )-representative for CQ,Tc .\nProof. Assume that R satisfies the conditions of the theorem, and let ans1 and ans2 be arbitrary abstract reasoners in CQ,Tc . We next show that ans1 and ans2 satisfy the two properties in Proposition 4.5.\n\u2022 Property 1 of Proposition 4.5: ans1 \u2264RQ,T ans2 implies ans1 \u2264Q,T ans2 Since ans1 is (Q, T )-compact, a TBox T  \u2286 T exists that satisfies the conditions of Definition 4.8. Assume that ans1 \u2264RQ,T ans2; we next show that Conditions 1 and 2 of Definition 4.1 are satisfied for an arbitrary ABox A.\n(Condition 1) Assume that cert(\u2217, T ,A) = t and ans1(\u2217, T ,A) = t. By the contrapositive of property 2 of Definition 4.8, then cert(\u2217, T ,A) = t. Since R contains all the ABoxes of some Q-simple T -test suite that is exhaustive for CQ,T  s and Q, by Theorem 3.30 there exist an ABox A \u2208 R and a T -stable renaming \u00b5 such that dom(\u00b5) = ind(T  \u222aA) and \u00b5(A) \u2286 A; since A does not contain individuals from ind(T ) \\ ind(T ), renaming \u00b5 is also T -stable. By the definition of a T -test suite, cert(\u2217, T ,A) = t; furthermore, by property 1 of Definition 4.8 we have ans1(\u2217, T ,A) = t. Since ans1 \u2264RQ,T ans2 we have ans2(\u2217, T ,A) = t. Since ans2 is strongly (Q, T )-faithful and \u00b5 is T -stable, we have ans2(\u2217, T , \u00b5(A)) = t. Finally, since \u00b5(A) \u2286 A and ans2 is (Q, T )-monotonic, we have ans2(\u2217, T ,A) = t, as required.\n(Condition 2) Assume that cert(\u2217, T ,A) = f, ans1(\u2217, T ,A) = f, and ans2(\u2217, T ,A) = f, and consider an arbitrary tuple a \u2208 ans(Q, T ,A) \u2229 cert(Q, T ,A). By the contrapositive of property 1 of Definition 4.8, then cert(\u2217, T ,A) = f; but then, by property 2 of Definition 4.8, we have a \u2208 cert(Q, T ,A). Since R contains all the ABoxes of some Qsimple T -test suite that is exhaustive for CQ,T  s and Q, by Theorem 3.30 there exist an ABox A \u2208 R, a tuple b \u2208 cert(Q, T ,A), and a (Q, T )-stable renaming \u00b5 such that dom(\u00b5) = ind(Q \u222a T  \u222aA), \u00b5(A) \u2286 A, and \u00b5(b) = a; since A does not contain individuals from ind(T ) \\ ind(Q \u222a T ), renaming \u00b5 is also (Q, T )-stable. By the definition of a (Q, T )-test suite, cert(\u2217, T ,A) = f; furthermore, by property 2 of Definition 4.8 we have b \u2208 ans1(Q, T ,A). Since ans1 \u2264RQ,T ans2 we have b \u2208 ans2(Q, T ,A). Since ans2 is strongly (Q, T )-faithful and \u00b5 is (Q, T )-stable, we have that a \u2208 ans2(Q, T , \u00b5(A)). Finally, since \u00b5(A) \u2286 A and ans2 is (Q, T )-monotonic, we have a \u2208 ans2(Q, T ,A), as required.\n\u2022 Property 2 of Proposition 4.5: ans1 <Q,T ans2 implies ans1 <RQ,T ans2 Assume that ans1 <Q,T ans2. By Definition 4.1, then ans1 \u2264Q,T ans2 and an ABox A exists satisfying Conditions 3 and 4 of Definition 4.1. Clearly, ans1 \u2264RQ,T ans2; hence, what remains to be shown is that R contains an ABox that satisfies Conditions 3 and 4 of Definition 4.1. Since ans1 is (Q, T )-compact, a TBox T  \u2286 T exists that satisfies the conditions of Definition 4.8.\n(Condition 3) Assume that cert(\u2217, T ,A) = t, and assume also that ans1(\u2217, T ,A) = t and ans2(\u2217, T ,A) = f. As in the proof of Condition 1, we can identify an ABox A \u2208 R and a T -stable renaming \u00b5 such that ans1(\u2217, T ,A) = t and \u00b5(A) \u2286 A. Since ans2 is (Q, T )- monotonic and ans2(\u2217, T ,A) = f, we have ans2(\u2217, T , \u00b5(A)) = f; furthermore, since ans2 is strongly (Q, T )-faithful and \u00b5 is T -stable, we also have ans2(\u2217, T ,A) = f. But then, Condition 3 of Definition 4.1 is satisfied for A \u2208 R.\n(Condition 4) Assume that cert(\u2217, T ,A) = f and ans1(\u2217, T ,A) = ans2(\u2217, T ,A) = f, and consider an arbitrary tuple a \u2208 [ans1(Q, T ,A) \u2229 cert(Q, T ,A)] \\ ans2(Q, T ,A). As in the proof of Condition 2, we can identify an ABox A \u2208 R, a (Q, T )-stable renaming \u00b5, and a\ntupleb \u2208 cert(Q, T ,A) such that \u00b5(A) \u2286 A, \u00b5(b) = a, andb \u2208 ans1(Q, T ,A). Since ans2 is (Q, T )-monotonic and a \u2208 ans2(Q, T ,A), we have a \u2208 ans2(Q, T , \u00b5(A)); furthermore, since ans2 is strongly (Q, T )-faithful and \u00b5 is (Q, T )-stable, we also have b \u2208 ans2(Q, T ,A). But then, Condition 4 of Definition 4.1 is satisfied for A \u2208 R.\nTheorems 3.32 and 4.11 immediately suggest an approach for computing a set of ABoxes that is a (Q, T )-representative for CQ,Tc . First, we compute a UCQ rewriting of Q w.r.t. each subset of T ; then, we instantiate each rule in each such rewriting using an injective instantiation mapping; finally, we compute R as a union of all ABoxes in all test suites. Such a na\u0308\u0131ve procedure, however, is not practical since it requires computing an exponential number of UCQ rewritings. We next present a more practical approach to computing a set of ABoxes that is (Q, T )-representative for CQ,Tc . Intuitively, instead of computing exponentially many rewritings, one can compute a single UCQ rewriting of Q w.r.t. T that is subset-closed\u2014that is, which contains a rewriting for each subset of T .\nDefinition 4.12. A UCQ rewriting R = R\u22a5,RQ of Q w.r.t. T is subset-closed if for each T  \u2286 T a tuple R = R\u22a5,RQ exists such that R\u22a5 \u2286 R\u22a5, RQ \u2286 RQ and R is a UCQ rewriting of Q w.r.t. T .\nThe following corollary is an immediate consequence of Theorems 3.27, 3.32, and 4.11.\nCorollary 4.13. Let Q be a UCQ, let T be a TBox, let R be a subset-closed UCQ rewriting of Q w.r.t. T , and let IR = IR\u22a5 , IRQ be the injective instantiation of R. Then, the set of ABoxes R = IR\u22a5 \u222a IRQ is (Q, T )-representative for C Q,T c .\nPractical query rewriting systems such as REQUIEM are optimised to produce as small a UCQ rewriting as possible, so their output is typically not subset-closed. Therefore, our technique requires the modification of UCQ rewriting algorithms implemented in existing systems. As illustrated by the following example, the required modification typically involves disabling (at least partially) subsumption-based optimisations.\nExample 4.14. Let Q and T be as specified in Example 3.14, and let S = S\u22a5,SQ be the T -test suite from Example 3.16. A system such as REQUIEM can compute such R for the given Q and T . Note, however, that R is not subset-closed; for example, a UCQ rewriting of Q w.r.t. T  = \u2205 is Q, and it is not a subset of RQ. The rewriting can be made subset-closed by extending RQ with the following rules:\nSt(x) \u2227 takesCo(x, y) \u2227MathCo(x, y) \u2192 Q(x) St(x) \u2227 takesCo(x, y) \u2227 CalcCo(x, y) \u2192 Q(x)\nMathSt(x) \u2227 St(x) \u2192 Q(x)\nSystems such as REQUIEM, however, typically discard such rules by applying subsumption optimisations described in Section 3.5.3. \u2666\nAs the following example shows, a subset-closed UCQ rewriting of Q w.r.t. T can, in the worst case, be exponentially larger than the \u2018minimal\u2019 UCQ rewritings of Q w.r.t. T . Example 4.15. Let Q = {C(x) \u2192 Q(x)}, and let T be the following TBox:\nT = {B  Ai | 1 \u2264 i \u2264 n} \u222a {A1  . . . An  C}\nFurthermore, let R = R\u22a5,RQ be such that R\u22a5 = \u2205 and RQ contains the following rules:\nC(x) \u2192 Q(x) B(x) \u2192 Q(x)\nA1(x) \u2227 . . . \u2227An(x) \u2192 Q(x)\nClearly, R is a UCQ rewriting of Q w.r.t. T ; however, the number of rules in a subset-closed UCQ rewriting of Q w.r.t. T is exponential in n. \u2666"}, {"heading": "5. Evaluation", "text": "We implemented our techniques for computing exhaustive test suites and for comparing incomplete concrete reasoners in a prototype tool called SyGENiA.1 Our tool uses REQUIEM for computing UCQ and datalog rewritings.2\nWe considered two evaluation scenarios. The first one uses the well-known Lehigh University Benchmark (LUBM) (Guo et al., 2005), which consists of a relatively small TBox about an academic domain, 14 test queries, and a data generator. The second one uses a small version of GALEN (Rector & Rogers, 2006)\u2014a complex ontology commonly used in medical applications.\nWe evaluated the following concrete reasoners: Sesame v2.3-prl,3 DLE-Jena v2.0,4 OWLim v2.9.1,5 Minerva v1.5,6 and Jena v2.6.37 in all of its three variants (Micro, Mini, and Max)."}, {"heading": "5.1 Computing Exhaustive Test Suites", "text": "Given a UCQ Q and a TBox T , our tool uses REQUIEM to compute a datalog rewriting R for Q and T . If R is a UCQ rewriting, then our tool computes a simple test suite by either full or injective instantiation (see Sections 3.5 and 3.6, respectively); otherwise, the tool computes a non-simple test suite by instantiating R as described in Section 3.7.3."}, {"heading": "5.1.1 Simple Test Suites", "text": "In the case of the LUBM benchmark, each of the 14 test queries leads to a UCQ rewriting w.r.t. the TBox.8 Therefore, we computed a UCQ rewriting for each query Q in the benchmark using REQUIEM and instantiated it, both fully and injectively, thus obtaining Q-simple T -test suites that are exhaustive for Q and CQ,Tw and CQ,Ts , respectively. The times needed to compute the test suites and the size of each test suite are shown in Table 3, where S denotes the total number of ABoxes in the corresponding test suites.\n1. http://code.google.com/p/sygenia/ 2. http://www.cs.ox.ac.uk/projects/requiem/home.html 3. http://www.openrdf.org/ 4. http://lpis.csd.auth.gr/systems/DLE-Jena/ 5. http://www.ontotext.com/owlim/ 6. http://www.alphaworks.ibm.com/tech/semanticstk 7. http://jena.sourceforge.net/ 8. Since REQUIEM does not currently support individuals in the queries, we replaced the individuals in\nqueries by distinguished variables.\nAs shown in the table, simple test suites could be computed in times ranging from 0.05 to 7 seconds, both for CQ,Tw and CQ,Ts . The optimisations implemented in REQUIEM ensure that the UCQ rewritings are relatively small, so the resulting test suites also consist of a relatively small number of ABoxes. Notice, however, the significant difference between the numbers of ABoxes in test suites obtained via injective instantiation (which range from 1 to 169 with an average of 32), and those obtained via full instantiation (which range from 1 to 3, 919 with an average of 702). Furthermore, each rule in a rewriting contains at most 6 atoms, therefore each ABox in a test suite also contains at most 6 assertions.\nIn the case of GALEN, we used the following sample queries, for which REQUIEM can compute a UCQ rewriting:\nQ1 : HaemoglobinConcentrationProcedure(x) \u2192 Q(x) Q2 : PlateletCountProcedure(x) \u2192 Q(x) Q3 : LymphocyteCountProcedure(x) \u2192 Q(x) Q4 : HollowStructure(x) \u2192 Q(x)\nWe instantiated each UCQ rewriting both fully and injectively. The times needed to compute the test suites and the size of each test suite are shown in Table 4.\nAs shown in the table, simple test suites for GALEN can be computed in times ranging from 1.7 to 67 seconds with an average of 33 seconds. Thus, computing test suites for GALEN is more time consuming than for LUBM. This is unsurprising since the TBox of GALEN is significantly more complex than that of LUBM. The number of ABoxes in the test suites ranged from 25 to 151 in the case of injective instantiations and from 79 to over 12, 000 in the case of full instantiations; again, note the significant difference between the sizes of the two kinds of test suites. In all cases, however, each individual ABox was very small, with the largest one containing only 11 assertions."}, {"heading": "5.1.2 Non-Simple Test Suites", "text": "We also computed non-simple test suites for cases where no UCQ rewriting exists. As already mentioned, all LUBM queries are UCQ-rewritable. Therefore, we manually added the following query, for which REQUIEM computes a recursive datalog rewriting.\nQ15 : Organization(x) \u2192 Q(x)\nDue to the complex structure of the GALEN TBox, test queries that are not UCQ rewritable can be easily identified. We have evaluated the following four.\nQ5 : WestergrenESRProcedure(x) \u2192 Q(x) Q6 : ArthroscopicProcedure(x) \u2192 Q(x) Q7 : TrueCavity(x) \u2192 Q(x) Q8 : BacterialCellWall(x) \u2192 Q(x)\nTimes needed to compute test suites and the size of each test suite are shown in Table 5."}, {"heading": "5.2 Completeness Guarantees", "text": "As already discussed, existing concrete reasoners are captured by strongly (Q, T )-faithful abstract reasoners. Hence, in order to establish completeness guarantees for such concrete reasoners, we restricted our tests to test suites computed using injective instantiations."}, {"heading": "5.2.1 Results for Simple Test Suites", "text": "Our results for the original queries of the LUBM benchmark are shown in Table 6. For each concrete reasoner, the first column of the table shows the queries for which we were able to prove completeness using our techniques (i.e., the queries that are complete for an arbitrary data set), and the second column of the table shows the queries on which the concrete reasoner computes all answers on the canonical LUBM data set with one university. Our results clearly show that completeness w.r.t. the data set in the LUBM benchmark is no guarantee of completeness for arbitrary data sets; for example, OWLim, Minerva, and Jena Mini/Micro are complete for all queries w.r.t. the LUBM data set (and some of these systems are even complete for the more expressive UOBM benchmark); however, for certain queries, these systems were found to be incomplete for a data set in our test suites.\nJena Max and DLE-Jena are the only systems that are guaranteed to be complete for all 14 LUBM queries regardless of the data set\u2014that is, these systems behave exactly like a complete OWL reasoner for all LUBM queries and the LUBM TBox. According to Jena\u2019s\ndocumentation, Jena Max supports all types of axioms used in the LUBM TBox, hence it is expected to be complete for the LUBM TBox and queries. Interestingly, when tested with some of the LUBM data sets, Jena Max could not compute the answers to many of the queries, so we used smaller LUBM data sets instead. This demonstrates an additional advantage of our approach: it does not require reasoning w.r.t. very large data sets, since the ABoxes in test suites typically contain only a small number of assertions. Regarding DLEJena, according to its technical description (Meditskos & Bassiliades, 2008), the system uses a complete DL reasoner to materialise certain subsumptions in a preprocessing step and then uses Jena to saturate the ABox, much like the abstract reasoner classify from Example 3.3. Hence, DLE-Jena is at least as complete as Jena Mini and, in addition, it is able to draw the inferences that Jena Mini is missing (see below).\nOWLim is complete for all LUBM queries that do not involve reasoning with existential quantifiers in the consequent of implications. It is well known that the latter is not supported by the system. Jena Mini and Micro exhibited exactly the same behaviour as OWLim, despite the fact that Jena Mini can handle a larger fragment of OWL than OWLim. Clearly, the LUBM TBox and queries are not sufficiently complex to reveal the differences between OWLim, and Jena Mini/Micro.\nMinerva is guaranteed to be complete for only six queries. Like DLE-Jena, it uses a DL reasoner to materialise entailed subsumptions between atomic concepts, but it uses a custom method for saturating the ABox. After investigating several ABoxes from the test suites we concluded that Minerva cannot correctly handle (at-least) inverse role axioms; for example, it cannot find the entailment { R  R\u2212, R(a, b) } |= R(b, a).\nFinally, Sesame is complete for only four queries. This is unsurprising since Sesame is an RDFS reasoner and is thus complete only for a small fragment of OWL 2 DL.\nWe next discuss the results of tests based on the GALEN ontology and test queries Q1\u2013Q4. We could not run Jena Max since GALEN heavily uses existential restrictions, which (according to Jena\u2019s documentation) might cause problems. Minerva was the only system that provided completeness guarantee for at least one query (Q4); this is because Minerva precomputes subsumption relationships between atomic concepts that depend on existential restrictions on the right hand side of TBox axioms, which most other systems do not handle. Also, unlike LUBM, the version of GALEN that we used does not contain inverse roles, so Minerva performed much better on this ontology. All other systems were identified as being incomplete for all test queries."}, {"heading": "5.2.2 Results for Non-Simple Test Suites", "text": "Results for test queries that are not UCQ-rewritable are summarised in Table 7. Symbol \u2018\u2019 indicates that the concrete reasoner was found complete for the given query. Furthermore, whenever a concrete reasoner failed a test suite, we tried to prove the reasoner to be incomplete as discussed in the examples in Section 3.7.2; in all cases we were successful, so symbol \u2018\u00d7\u2019 indicates that the concrete reasoner was identified as being incomplete for a given query. Finally, symbol \u2018\u2212\u2019 indicates that the concrete reasoner ran out of memory.\nIn the case of LUBM, we were able to establish completeness guarantees w.r.t. query Q15 for OWLim, Jena Micro, DLE-Jena, and Jena Max. Note that all these systems can handle recursive TBox statements, so completeness for Q15 is not surprising. RDFS,\nhowever, cannot express recursive TBox statements involving roles, so Sesame\u2014an RDFS reasoner\u2014fails to compute certain answers to some tests.\nIn the case of GALEN, completeness is guaranteed on query Q8 for OWLim, Jena Micro, DLE-Jena, and Minerva, and additionally on query Q6 for Minerva. As already mentioned, answers to queries on GALEN depend on positive occurrences of existential restrictions in axioms, which most systems cannot handle. We could not run Jena Max on GALEN."}, {"heading": "5.3 Comparing Incomplete Concrete Reasoners", "text": "We also implemented the techniques for comparing reasoners from Section 4.3. To this end, we modified REQUIEM to compute subset-closed rewritings, which are then injectively instantiated to obtain a (Q, T )-representative sets of ABoxes R."}, {"heading": "5.3.1 Tests with LUBM", "text": "As shown in Table 8, representative sets of ABoxes could be computed in just a few seconds for most LUBM queries. The only exception wasQ9, for which REQUIEM did not terminate after disabling rule subsumption optimisations. The size of the representative sets ranged between 1 and 777 ABoxes. As expected, representative sets contain more ABoxes than the exhaustive test suites for the same query and TBox (see Table 3).\nAll combinations of system and query for which the tests in Section 5.2 identified the system as incomplete are shown in Table 9. The table shows the proportion of certain answers that each system returned when applied to the LUBM data set, the ABoxes in R, and the ABoxes in the test suite S used in Section 5.2 to check the system\u2019s completeness. As shown in the table, OWLim and Jena Micro exhibited the same behaviour and were \u2018almost\u2019 complete. In contrast, Sesame was the least complete for all queries. Furthermore, please note the difference between the values obtained for R and those for S; in particular, Sesame did not compute any certain answer for Q5 on S, whereas the system is able to compute certain answers for Q5 on some ABoxes (e.g., on the LUBM data set). This is because the ABoxes in S cannot distinguish Sesame from a trivial reasoner that always returns the empty set of answers; however, the set R can make such a distinction."}, {"heading": "5.3.2 Tests with GALEN", "text": "As shown in Table 10, representative sets of ABoxes for GALEN could be computed in times ranging from 2 to 70 seconds, and each set contains only a small number of ABoxes.\nFor each system and query, Table 11 shows the proportion of certain answers returned by the system on R and the test suite S from Section 5.2. Minerva was the most complete system. Jena Micro was better than DLE-Jena (apart from query Q4), while DLE-Jena and OWLim behaved in almost the same way (again apart from query Q4). As expected, Sesame was the least complete system.\nThe discrepancies between OWLim, Jena Micro, DLE-Jena and Minerva are rather surprising. OWLim and Jena theoretically support the same features of OWL; furthermore, DLE-Jena is an extension of Jena (Meditskos & Bassiliades, 2008) so DLE-Jena should be at least as complete as Jena, as in the case of LUBM. In order to explain these discrepancies, we analysed the test suites for queries Q1\u2013Q4. More precisely, we selected ABoxes on which OWLim fails to return all certain answers but on which Jena Micro is complete, and then we identified the minimal set of TBox axioms that entail all certain answers. Our analysis revealed that, for query Q4, OWLim fails to find the entailment\nT \u222a {Device(a),HollowTopology(b), hasTopology(a, b)} |= HollowStructure(a),\nwhich follows from the following GALEN axioms:\nHollowTopology \u2261 Topology  \u2203hasState.Hollow Device  SolidStructure\nHollowStructure \u2261 SolidStructure  \u2203hasTopology.(Topology  \u2203hasState.Hollow)\nAlthough existential restrictions appear in several axioms, we can observe that no reasoning over existential variables is actually required, as the first and third axioms imply (by a simple structural transformation) the following axiom:\nSolidStructure  \u2203hasTopology.HollowTopology  HollowStructure\nThis axiom entails the required answer, and both systems can deal with axioms of this form; however, unlike Jena Micro, OWLim appears to be incapable of dealing with such cases.\nRegarding DLE-Jena, according to its technical description (Meditskos & Bassiliades, 2008), the system has replaced several inference rules of Jena with queries to the DL reasoner, so it does not strictly extend Jena. Our investigation of the exhaustive test suite for query Q4 revealed that DLE-Jena returns many answers that are based on existential restrictions on the right hand side of TBox axioms which Jena misses; however, the investigation also revealed that DLE-Jena misses several inferences that Jena\u2019s TBox reasoner can capture, which is probably due to the replacement of Jena\u2019s inference rules. This also explains why DLE-Jena performs worse than Minerva on GALEN.\nThese results clearly show that the behaviour of systems greatly depends on the given application scenario. For example, DLE-Jena was complete for all LUBM queries, but it did not perform equally well on GALEN. In contrast, Minerva did not perform well on LUBM, but it was the most complete system for GALEN. Our results thus allow application developers to conduct a thorough comparison of reasoning systems for a given application."}, {"heading": "6. Conclusion", "text": "In this paper we have proposed a theoretical framework and practical techniques for establishing formally provable and algorithmically verifiable completeness guarantees for incomplete ontology reasoners. Our approach radically departs from ad hoc evaluation based on well-known benchmarks, and it provides a solid foundation for striking the balance between scalability and completeness in practical applications.\nOur approach also opens up numerous and exciting possibilities for future research. For example, our work opens the door to the design of ontology-based information systems that are optimised for a class of ontologies, queries, and data relevant to a particular application. Such information systems could maximise scalability of reasoning while still ensuring completeness of query answers, even for rich ontologies and sophisticated queries."}, {"heading": "Acknowledgments", "text": "This is an extended version of the paper \u2018How Incomplete is your Semantic Web Reasoner?\u2019 by Giorgos Stoilos, Bernardo Cuenca Grau, and Ian Horrocks published at AAAI 2010 and the paper \u2018Completeness Guarantees for Incomplete Reasoners\u2019 by the same authors published at ISWC 2010.\nThis research has been supported by the EU project SEALS (FP7-ICT-238975), and by the EPSRC projects ExODA (EP/H051511/1) and HermiT (EP/F065841/1). B. Cuenca Grau is supported by a Royal Society University Research Fellowship."}], "references": [{"title": "Quonto: Querying ontologies", "author": ["A. Acciarri", "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "M. Palmieri", "R. Rosati"], "venue": "In Proceedings of the 20th National Conference on Artificial Intelligence", "citeRegEx": "Acciarri et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Acciarri et al\\.", "year": 2005}, {"title": "The DL-Lite family and relations", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev"], "venue": "J. Artificial Intelligence Research (JAIR),", "citeRegEx": "Artale et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2009}, {"title": "The Description Logic Handbook: Theory, implementation and applications", "author": ["F. Baader", "D. McGuinness", "D. Nardi", "P. Patel-Schneider"], "venue": "In Proceedings of the 19th International Joint Conference on AI (IJCAI-05),", "citeRegEx": "Baader et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2002}, {"title": "OWLIM: A family of scalable semantic repositories", "author": ["B. Bishop", "A. Kiryakov", "D. Ognyanoff", "I. Peikov", "Z. Tashev", "R. Velkov"], "venue": "Semantic Web,", "citeRegEx": "Bishop et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bishop et al\\.", "year": 2011}, {"title": "Sesame: A generic architecture for storing and querying RDF and RDF Schema", "author": ["J. Broekstra", "A. Kampman", "F. van Harmelen"], "venue": "In Proceedings of the 1st International Semantic Web Conference (ISWC", "citeRegEx": "Broekstra et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Broekstra et al\\.", "year": 2002}, {"title": "Datalog+/-: A family of logical knowledge representation and query languages for new applications", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris"], "venue": "In Proc. of the 25th Annual IEEE Symposium on Logic in Computer Science (LICS),", "citeRegEx": "Cal\u0300\u0131 et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Cal\u0300\u0131 et al\\.", "year": 2010}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "What you always wanted to know about datalog (and never dared to ask)", "author": ["S. Ceri", "G. Gottlob", "L. Tanca"], "venue": "IEEE Trans. Knowledge Data Engineering,", "citeRegEx": "Ceri et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Ceri et al\\.", "year": 1989}, {"title": "Modular Reuse of Ontologies: Theory and Practice", "author": ["B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Grau et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "OWL 2: The next step for OWL", "author": ["B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. Patel-Schneider", "U. Sattler"], "venue": "Journal of Web Semantics (JWS),", "citeRegEx": "Grau et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "An Ontology of Astronomical Object Types for the Virtual Observatory", "author": ["S. Derriere", "A. Richard", "A. Preite-Martinez"], "venue": "In Proc. of the 26th meeting of the IAU: Virtual Observatory in Action: New Science, New Technology, and Next Generation Facilities,", "citeRegEx": "Derriere et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Derriere et al\\.", "year": 2006}, {"title": "RDF support in the virtuoso DBMS", "author": ["O. Erling", "I. Mikhailov"], "venue": "Networked Knowledge - Networked Media,", "citeRegEx": "Erling and Mikhailov,? \\Q2009\\E", "shortCiteRegEx": "Erling and Mikhailov", "year": 2009}, {"title": "First-Order Logic and Automated Theorem Proving, 2nd Edition", "author": ["M. Fitting"], "venue": "Texts in Computer Science. Springer.", "citeRegEx": "Fitting,? 1996", "shortCiteRegEx": "Fitting", "year": 1996}, {"title": "Conjunctive query answering for the description logic SHIQ", "author": ["B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler"], "venue": "In Proceedings of the International Joint Conference on AI (IJCAI),", "citeRegEx": "Glimm et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Glimm et al\\.", "year": 2007}, {"title": "The Foundational Model of Anatomy in OWL: Experience and Perspectives", "author": ["C. Golbreich", "S. Zhang", "O. Bodenreider"], "venue": "Journal of Web Semantics,", "citeRegEx": "Golbreich et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Golbreich et al\\.", "year": 2006}, {"title": "Experiences of using OWL at the Ordnance Survey", "author": ["J. Goodwin"], "venue": "Proc. of the OWL: Experiences and Directions Workshop (OWLED 2005), Galway, Ireland.", "citeRegEx": "Goodwin,? 2005", "shortCiteRegEx": "Goodwin", "year": 2005}, {"title": "LUBM: A Benchmark for OWL Knowledge Base Systems", "author": ["Y. Guo", "Z. Pan", "J. Heflin"], "venue": "Journal of Web Semantics,", "citeRegEx": "Guo et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Guo et al\\.", "year": 2005}, {"title": "RACER System Description", "author": ["V. Haarslev", "R. M\u00f6ller"], "venue": "Proc. of the 1st Int. Joint Conf. on Automated Reasoning (IJCAR", "citeRegEx": "Haarslev and M\u00f6ller,? \\Q2001\\E", "shortCiteRegEx": "Haarslev and M\u00f6ller", "year": 2001}, {"title": "RDF Semantics", "author": ["P. Hayes"], "venue": "World Wide Web Consortium (W3C) Recommendation.", "citeRegEx": "Hayes,? 2004", "shortCiteRegEx": "Hayes", "year": 2004}, {"title": "From SHIQ and RDF to OWL: the making of a web ontology language", "author": ["I. Horrocks", "P.F. Patel-Schneider", "F. van Harmelen"], "venue": "Journal Web Semantics,", "citeRegEx": "Horrocks et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2003}, {"title": "Owlim-a pragmatic semantic repository for owl", "author": ["A. Kiryakov", "D. Ognyanov", "D. Manov"], "venue": "WISE Workshops,", "citeRegEx": "Kiryakov et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kiryakov et al\\.", "year": 2005}, {"title": "Experiences Using OWL in Military Applications", "author": ["L. Lacy", "G. Aviles", "K. Fraser", "W. Gerber", "A. Mulvehill", "R. Gaskill"], "venue": "In Proc. of the OWL: Experiences and Directions Workshop (OWLED", "citeRegEx": "Lacy et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Lacy et al\\.", "year": 2005}, {"title": "Conjunctive query answering in the description logic EL using a relational database system", "author": ["C. Lutz", "D. Toman", "F. Wolter"], "venue": "In Proceedings of the 21st International Joint Conference on AI (IJCAI),", "citeRegEx": "Lutz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2009}, {"title": "Towards a complete OWL ontology benchmark", "author": ["L. Ma", "Y. Yang", "Z. Qiu", "G.T. Xie", "Y. Pan", "S. Liu"], "venue": "In Proceedings of the 3rd European Semantic Web Conference (ESWC", "citeRegEx": "Ma et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2006}, {"title": "Jena: Implementing the RDF Model and Syntax Specification", "author": ["McBride", "Brian"], "venue": "International Workshop on the Semantic Web 2001.", "citeRegEx": "McBride and Brian,? 2001", "shortCiteRegEx": "McBride and Brian", "year": 2001}, {"title": "Combining a DL reasoner and a rule engine for improving entailment-based OWL reasoning", "author": ["G. Meditskos", "N. Bassiliades"], "venue": "In Proceedings of the 7th International Semantic Web Conference (ISWC", "citeRegEx": "Meditskos and Bassiliades,? \\Q2008\\E", "shortCiteRegEx": "Meditskos and Bassiliades", "year": 2008}, {"title": "OWL 2 Web Ontology Language Profiles", "author": ["B. Motik", "B. Cuenca Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz"], "venue": null, "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Hypertableau Reasoning for Description Logics", "author": ["B. Motik", "R. Shearer", "I. Horrocks"], "venue": "J. Artificial Intelligence Research (JAIR),", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Data complexity of query answering in expressive description logics via tableaux", "author": ["M. Ortiz", "D. Calvanese", "T. Eiter"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Ortiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2008}, {"title": "Efficient Query Answering for OWL", "author": ["H. P\u00e9rez-Urbina", "I. Horrocks", "B. Motik"], "venue": "Proceedings of the 8th International Semantic Web Conference (ISWC 2009),", "citeRegEx": "P\u00e9rez.Urbina et al\\.,? \\Q2009\\E", "shortCiteRegEx": "P\u00e9rez.Urbina et al\\.", "year": 2009}, {"title": "Tractable query answering and rewriting under description logic constraints", "author": ["H. P\u00e9rez-Urbina", "B. Motik", "I. Horrocks"], "venue": "Journal of Applied Logic,", "citeRegEx": "P\u00e9rez.Urbina et al\\.,? \\Q2010\\E", "shortCiteRegEx": "P\u00e9rez.Urbina et al\\.", "year": 2010}, {"title": "SPARQL query language for RDF", "author": ["E. Prud\u2019hommeaux", "A. Seaborne"], "venue": "World Wide Web Consortium (W3C)", "citeRegEx": "Prud.hommeaux and Seaborne,? \\Q2008\\E", "shortCiteRegEx": "Prud.hommeaux and Seaborne", "year": 2008}, {"title": "Ontological and practical issues in using a description logic to represent medical concept systems: Experience from galen", "author": ["A.L. Rector", "J. Rogers"], "venue": "Reasoning Web, Second International Summer School", "citeRegEx": "Rector and Rogers,? \\Q2006\\E", "shortCiteRegEx": "Rector and Rogers", "year": 2006}, {"title": "Protein Ontology Development using OWL", "author": ["A. Sidhu", "T. Dillon", "E. Chang", "B.S. Sidhu"], "venue": "In Proc. of the OWL: Experiences and Directions Workshop (OWLED", "citeRegEx": "Sidhu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sidhu et al\\.", "year": 2005}, {"title": "Pellet: A practical OWL-DL reasoner", "author": ["E. Sirin", "B. Parsia", "B. Cuenca Grau", "A. Kalyanpur", "Y. Katz"], "venue": "Journal of Web Semantics,", "citeRegEx": "Sirin et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Sirin et al\\.", "year": 2007}, {"title": "Reengineering Thesauri for New Applications: The AGROVOC Example", "author": ["D. Soergel", "B. Lauser", "A. Liang", "F. Fisseha", "J. Keizer", "S. Katz"], "venue": "J. of Digital Information,", "citeRegEx": "Soergel et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Soergel et al\\.", "year": 2004}, {"title": "Implementing an inference engine for rdfs/owl constructs and user-defined rules in oracle", "author": ["Z. Wu", "G. Eadon", "S. Das", "E.I. Chong", "V. Kolovski", "M. Annamalai", "J. Srinivasan"], "venue": "In Proceedings of the 2008 IEEE 24th International Conference on Data Engineering (ICDE", "citeRegEx": "Wu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 15, "context": "Efficient management and querying of large amounts of data is a core problem for a growing range of applications in fields as diverse as biology (Sidhu, Dillon, Chang, & Sidhu, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), geography (Goodwin, 2005), astronomy (Derriere, Richard, & Preite-Martinez, 2006), agriculture (Soergel, Lauser, Liang, Fisseha, Keizer, & Katz, 2004), and defence (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005).", "startOffset": 244, "endOffset": 259}, {"referenceID": 18, "context": "In particular, RDF (Hayes, 2004) provides a standard model for semistructured data, SPARQL (Prud\u2019hommeaux & Seaborne, 2008) is a standard query language for RDF, and ontology languages such as OWL (Horrocks, Patel-Schneider, & van Harmelen, 2003) and OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider,", "startOffset": 19, "endOffset": 32}, {"referenceID": 23, "context": "University Benchmark (LUBM) (Guo, Pan, & Heflin, 2005) and the University Ontology Benchmark (UOBM) (Ma et al., 2006) have been used for such completeness testing.", "startOffset": 100, "endOffset": 117}, {"referenceID": 6, "context": "For T expressed in OWL 2 QL, a rewriting R can be computed using the algorithm by Calvanese et al. (2007); additionally, the algorithm by P\u00e9rez-Urbina, Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside this fragment.", "startOffset": 82, "endOffset": 106}, {"referenceID": 6, "context": "For T expressed in OWL 2 QL, a rewriting R can be computed using the algorithm by Calvanese et al. (2007); additionally, the algorithm by P\u00e9rez-Urbina, Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside this fragment.", "startOffset": 82, "endOffset": 179}, {"referenceID": 28, "context": "In many cases, T can be transformed into a datalog\u00b1,\u2228 program using equivalence-preserving transformations; furthermore, the algorithm by P\u00e9rez-Urbina et al. (2010) can in many cases produce a plain datalog rewriting.", "startOffset": 138, "endOffset": 165}, {"referenceID": 12, "context": "The notions of variables, terms, atoms, first-order formulae, and sentences are defined as usual (Fitting, 1996); we do not consider function symbols in this article and we assume all formulae to be function-free.", "startOffset": 97, "endOffset": 112}, {"referenceID": 6, "context": "a TBox T is another query that captures all the information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; P\u00e9rez-Urbina et al., 2010).", "startOffset": 125, "endOffset": 230}, {"referenceID": 30, "context": "a TBox T is another query that captures all the information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; P\u00e9rez-Urbina et al., 2010).", "startOffset": 125, "endOffset": 230}, {"referenceID": 6, "context": "In practice, UCQs (Calvanese et al., 2007) and datalog (P\u00e9rez-Urbina et al.", "startOffset": 18, "endOffset": 42}, {"referenceID": 30, "context": ", 2007) and datalog (P\u00e9rez-Urbina et al., 2010) are the most widely used target languages for query rewriting.", "startOffset": 20, "endOffset": 47}, {"referenceID": 6, "context": "For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when T is expressed in a logic from the DL-Lite family, and this approach can be extended to the OWL 2 QL profile of OWL 2 (Motik et al.", "startOffset": 13, "endOffset": 37}, {"referenceID": 6, "context": "For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when T is expressed in a logic from the DL-Lite family, and this approach can be extended to the OWL 2 QL profile of OWL 2 (Motik et al., 2009a). Similarly, P\u00e9rez-Urbina et al. (2010) proposed an algorithm for computing the simplest possible datalog rewriting when T is expressed in the description logic ELHIO.", "startOffset": 13, "endOffset": 268}, {"referenceID": 6, "context": "In particular, a UCQ rewriting is guaranteed to exist if T is expressed in the DLs underpinning the QL profile of OWL 2 (Motik et al., 2009a; Calvanese et al., 2007); furthermore, as illustrated in Example 3.", "startOffset": 120, "endOffset": 165}, {"referenceID": 0, "context": "In practice, such rewritings can be computed using systems such as QuOnto (Acciarri et al., 2005) and REQUIEM (P\u00e9rez-Urbina et al.", "startOffset": 74, "endOffset": 97}, {"referenceID": 30, "context": ", 2005) and REQUIEM (P\u00e9rez-Urbina et al., 2010).", "startOffset": 20, "endOffset": 47}, {"referenceID": 6, "context": "This goal can be achieved by applying known techniques for minimising UCQ rewritings (Calvanese et al., 2007; P\u00e9rez-Urbina, Horrocks, & Motik, 2009).", "startOffset": 85, "endOffset": 148}, {"referenceID": 16, "context": "The first one uses the well-known Lehigh University Benchmark (LUBM) (Guo et al., 2005), which consists of a relatively small TBox about an academic domain, 14 test queries, and a data generator.", "startOffset": 69, "endOffset": 87}], "year": 2012, "abstractText": "To achieve scalability of query answering, the developers of Semantic Web applications are often forced to use incomplete OWL 2 reasoners, which fail to derive all answers for at least one query, ontology, and data set. The lack of completeness guarantees, however, may be unacceptable for applications in areas such as health care and defence, where missing answers can adversely affect the application\u2019s functionality. Furthermore, even if an application can tolerate some level of incompleteness, it is often advantageous to estimate how many and what kind of answers are being lost. In this paper, we present a novel logic-based framework that allows one to check whether a reasoner is complete for a given query Q and ontology T \u2014that is, whether the reasoner is guaranteed to compute all answers to Q w.r.t. T and an arbitrary data set A. Since ontologies and typical queries are often fixed at application design time, our approach allows application developers to check whether a reasoner known to be incomplete in general is actually complete for the kinds of input relevant for the application. We also present a technique that, given a query Q, an ontology T , and reasoners R1 and R2 that satisfy certain assumptions, can be used to determine whether, for each data set A, reasoner R1 computes more answers to Q w.r.t. T and A than reasoner R2. This allows application developers to select the reasoner that provides the highest degree of completeness forQ and T that is compatible with the application\u2019s scalability requirements. Our results thus provide a theoretical and practical foundation for the design of future ontology-based information systems that maximise scalability while minimising or even eliminating incompleteness of query answers.", "creator": "TeX"}}}